{"sha": "acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWNmMDE3NGI2ZjdhM2Y4ZmUxZTJhMjczNjFiYmY4N2RmZTQ1NDUzMA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2013-10-11T09:26:50Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2013-10-11T09:26:50Z"}, "message": "target.c: New file.\n\nlibgomp/\n\t* target.c: New file.\n\t* Makefile.am (libgomp_la_SOURCES): Add target.c.\n\t* Makefile.in: Regenerated.\n\t* libgomp_g.h (GOMP_task): Add depend argument.\n\t(GOMP_barrier_cancel, GOMP_loop_end_cancel,\n\tGOMP_sections_end_cancel, GOMP_target, GOMP_target_data,\n\tGOMP_target_end_data, GOMP_target_update, GOMP_teams,\n\tGOMP_parallel_loop_static, GOMP_parallel_loop_dynamic,\n\tGOMP_parallel_loop_guided, GOMP_parallel_loop_runtime,\n\tGOMP_parallel, GOMP_cancel, GOMP_cancellation_point,\n\tGOMP_taskgroup_start, GOMP_taskgroup_end,\n\tGOMP_parallel_sections): New prototypes.\n\t* fortran.c (omp_is_initial_device): Add ialias_redirect.\n\t(omp_is_initial_device_): New function.\n\t(ULP, STR1, STR2, ialias_redirect): Removed.\n\t(omp_get_cancellation_, omp_get_proc_bind_, omp_set_default_device_,\n\tomp_set_default_device_8_, omp_get_default_device_,\n\tomp_get_num_devices_, omp_get_num_teams_, omp_get_team_num_): New\n\tfunctions.\n\t* libgomp.map (GOMP_barrier_cancel, GOMP_loop_end_cancel,\n\tGOMP_sections_end_cancel, GOMP_target, GOMP_target_data,\n\tGOMP_target_end_data, GOMP_target_update, GOMP_teams): Export\n\t@@GOMP_4.0.\n\t(omp_is_initial_device, omp_is_initial_device_, omp_get_cancellation,\n\tomp_get_cancellation_, omp_get_proc_bind, omp_get_proc_bind_,\n\tomp_set_default_device, omp_set_default_device_,\n\tomp_set_default_device_8_, omp_get_default_device,\n\tomp_get_default_device_, omp_get_num_devices, omp_get_num_devices_,\n\tomp_get_num_teams, omp_get_num_teams_, omp_get_team_num,\n\tomp_get_team_num_): Export @@OMP_4.0.\n\t* team.c (struct gomp_thread_start_data): Add place field.\n\t(gomp_thread_start): Clear thr->thread_pool and\n\tthr->task before returning.  Use gomp_team_barrier_wait_final\n\tinstead of gomp_team_barrier_wait.  Initialize thr->place.\n\t(gomp_new_team): Initialize work_shares_to_free, work_share_cancelled,\n\tteam_cancelled and task_queued_count fields.\n\t(gomp_free_pool_helper): Clear thr->thread_pool and thr->task\n\tbefore calling pthread_exit.\n\t(gomp_free_thread): No longer static.  Use\n\tgomp_managed_threads_lock instead of gomp_remaining_threads_lock.\n\t(gomp_team_start): Add flags argument.  Set\n\tthr->thread_pool->threads_busy to nthreads immediately after creating\n\tnew pool.  Use gomp_managed_threads_lock instead of\n\tgomp_remaining_threads_lock.  Handle OpenMP 4.0 affinity.\n\t(gomp_team_end): Use gomp_managed_threads_lock instead of\n\tgomp_remaining_threads_lock.  Use gomp_team_barrier_wait_final instead\n\tof gomp_team_barrier_wait.  If team->team_cancelled, call\n\tgomp_fini_worshare on ws chain starting at team->work_shares_to_free\n\trather than thr->ts.work_share.\n\t(initialize_team): Don't call gomp_sem_init here.\n\t* sections.c (GOMP_parallel_sections_start): Adjust gomp_team_start\n\tcaller.\n\t(GOMP_parallel_sections, GOMP_sections_end_cancel): New functions.\n\t* env.c (gomp_global_icv): Add default_device_var, target_data and\n\tbind_var initializers.\n\t(gomp_cpu_affinity, gomp_cpu_affinity_len): Remove.\n\t(gomp_bind_var_list, gomp_bind_var_list_len, gomp_places_list,\n\tgomp_places_list_len): New variables.\n\t(parse_bind_var, parse_one_place, parse_places_var): New functions.\n\t(parse_affinity): Rewritten to construct OMP_PLACES list with unit\n\tsized places.\n\t(gomp_cancel_var): New global variable.\n\t(parse_int): New function.\n\t(handle_omp_display_env): New function.\n\t(initialize_env): Use it.  Initialize default_device_var.\n\tParse OMP_CANCELLATION env var.  Use parse_bind_var to parse\n\tOMP_PROC_BIND instead of parse_boolean.  Use parse_places_var for\n\tOMP_PLACES parsing.  Don't call parse_affinity if OMP_PLACES has\n\tbeen successfully parsed (and call gomp_init_affinity in that case).\n\t(omp_get_cancellation, omp_get_proc_bind, omp_set_default_device,\n\tomp_get_default_device, omp_get_num_devices, omp_get_num_teams,\n\tomp_get_team_num, omp_is_initial_device): New functions.\n\t* libgomp.h: Include stdlib.h.\n\t(ialias_ulp, ialias_str1, ialias_str2, ialias_redirect, ialias_call):\n\tDefine.\n\t(struct target_mem_desc): Forward declare.\n\t(struct gomp_task_icv): Add default_device_var, target_data, bind_var\n\tand thread_limit_var fields.\n\t(gomp_get_num_devices): New prototype.\n\t(gomp_cancel_var): New extern decl.\n\t(struct gomp_team): Add work_shares_to_free, work_share_cancelled,\n\tteam_cancelled and task_queued_count fields.  Add comments about\n\ttask_{,queued_,running_}count.\n\t(gomp_cancel_kind): New enum.\n\t(gomp_work_share_end_cancel): New prototype.\n\t(struct gomp_task): Add next_taskgroup, prev_taskgroup, taskgroup,\n\tcopy_ctors_done, dependers, depend_hash, depend_count, num_dependees\n\tand depend fields.\n\t(struct gomp_taskgroup): New type.\n\t(struct gomp_task_depend_entry,\n\tstruct gomp_dependers_vec): New types.\n\t(gomp_finish_task): Free depend_hash if non-NULL.\n\t(struct gomp_team_state): Add place_partition_off\n\tand place_partition_len fields.\n\t(gomp_bind_var_list, gomp_bind_var_list_len, gomp_places_list,\n\tgomp_places_list_len): New extern decls.\n\t(struct gomp_thread): Add place field.\n\t(gomp_cpu_affinity, gomp_cpu_affinity_len): Remove.\n\t(gomp_init_thread_affinity): Add place argument.\n\t(gomp_affinity_alloc, gomp_affinity_init_place, gomp_affinity_add_cpus,\n\tgomp_affinity_remove_cpu, gomp_affinity_copy_place,\n\tgomp_affinity_same_place, gomp_affinity_finalize_place_list,\n\tgomp_affinity_init_level, gomp_affinity_print_place): New\n\tprototypes.\n\t(gomp_team_start): Add flags argument.\n\t(gomp_thread_limit_var, gomp_remaining_threads_count,\n\tgomp_remaining_threads_lock): Remove.\n\t(gomp_managed_threads_lock): New variable.\n\t(struct gomp_thread_pool): Add threads_busy field.\n\t(gomp_free_thread): New prototype.\n\t* task.c: Include hashtab.h.\n\t(hash_entry_type): New typedef.\n\t(htab_alloc, htab_free, htab_hash, htab_eq): New inlines.\n\t(gomp_init_task): Clear dependers, depend_hash, depend_count,\n\tcopy_ctors_done and taskgroup fields.\n\t(GOMP_task): Add depend argument, handle depend clauses.  If\n\tgomp_team_barrier_cancelled or if it's taskgroup has been\n\tcancelled, don't queue or start new tasks.  Set copy_ctors_done\n\tfield if needed.  Initialize taskgroup field.  If copy_ctors_done\n\tand already cancelled, don't discard the task.  If taskgroup is\n\tnon-NULL, enqueue the task into taskgroup queue.  Increment\n\tnum_children field in taskgroup.  Increment task_queued_count.\n\t(gomp_task_run_pre, gomp_task_run_post_remove_parent,\n\tgomp_task_run_post_remove_taskgroup): New inline functions.\n\t(gomp_task_run_post_handle_depend_hash,\n\tgomp_task_run_post_handle_dependers,\n\tgomp_task_run_post_handle_depend): New functions.\n\t(GOMP_taskwait): Use them.  If more than one new tasks\n\thave been queued, wake other threads if needed.\n\t(gomp_barrier_handle_tasks): Likewise.  If\n\tgomp_team_barrier_cancelled, don't start any new tasks, just free\n\tall tasks.\n\t(GOMP_taskgroup_start, GOMP_taskgroup_end): New functions.\n\t* omp_lib.f90.in\n\t(omp_proc_bind_kind, omp_proc_bind_false,\n\tomp_proc_bind_true, omp_proc_bind_master, omp_proc_bind_close,\n\tomp_proc_bind_spread): New params.\n\t(omp_get_cancellation, omp_get_proc_bind, omp_set_default_device,\n\tomp_get_default_device, omp_get_num_devices, omp_get_num_teams,\n\tomp_get_team_num, omp_is_initial_device): New interfaces.\n\t(omp_get_dynamic, omp_get_nested, omp_in_parallel,\n\tomp_get_max_threads, omp_get_num_procs, omp_get_num_threads,\n\tomp_get_thread_num, omp_get_thread_limit, omp_set_max_active_levels,\n\tomp_get_max_active_levels, omp_get_level, omp_get_ancestor_thread_num,\n\tomp_get_team_size, omp_get_active_level, omp_in_final): Remove\n\tuseless use omp_lib_kinds.\n\t* omp.h.in (omp_proc_bind_t): New typedef.\n\t(omp_get_cancellation, omp_get_proc_bind, omp_set_default_device,\n\tomp_get_default_device, omp_get_num_devices, omp_get_num_teams,\n\tomp_get_team_num, omp_is_initial_device): New prototypes.\n\t* loop.c (gomp_parallel_loop_start): Add flags argument, pass it\n\tthrough to gomp_team_start.\n\t(GOMP_parallel_loop_static_start, GOMP_parallel_loop_dynamic_start,\n\tGOMP_parallel_loop_guided_start, GOMP_parallel_loop_runtime_start):\n\tAdjust gomp_parallel_loop_start callers.\n\t(GOMP_parallel_loop_static, GOMP_parallel_loop_dynamic,\n\tGOMP_parallel_loop_guided, GOMP_parallel_loop_runtime,\n\tGOMP_loop_end_cancel): New functions.\n\t(GOMP_parallel_end): Add ialias_redirect.\n\t* hashtab.h: New file.\n\t* libgomp.texi (Environment Variables): Minor cleanup,\n\tupdate section refs to OpenMP 4.0rc2.\n\t(OMP_DISPLAY_ENV, GOMP_SPINCOUNT): Document these\n\tenvironment variables.\n\t* work.c (gomp_work_share_end, gomp_work_share_end_nowait): Set\n\tteam->work_shares_to_free to thr->ts.work_share before calling\n\tfree_work_share.\n\t(gomp_work_share_end_cancel): New function.\n\t* config/linux/proc.c: Include errno.h.\n\t(gomp_get_cpuset_size, gomp_cpuset_size, gomp_cpusetp): New variables.\n\t(gomp_cpuset_popcount): Add cpusetsize argument, use it instead of\n\tsizeof (cpu_set_t) to determine number of iterations.  Fix up check\n\textern decl.  Use CPU_COUNT_S if available, or CPU_COUNT if\n\tgomp_cpuset_size is sizeof (cpu_set_t).\n\t(gomp_init_num_threads): Initialize gomp_cpuset_size,\n\tgomp_get_cpuset_size and gomp_cpusetp here, use gomp_cpusetp instead\n\tof &cpuset and pass gomp_cpuset_size instead of sizeof (cpu_set_t)\n\tto pthread_getaffinity_np.  Free and clear gomp_cpusetp if it didn't\n\tcontain any logical CPUs.\n\t(get_num_procs): Don't call pthread_getaffinity_np if gomp_cpusetp\n\tis NULL.  Use gomp_cpusetp instead of &cpuset and pass\n\tgomp_get_cpuset_size instead of sizeof (cpu_set_t) to\n\tpthread_getaffinity_np.  Check gomp_places_list instead of\n\tgomp_cpu_affinity.  Adjust gomp_cpuset_popcount caller.\n\t* config/linux/bar.c (gomp_barrier_wait_end,\n\tgomp_barrier_wait_last): Use BAR_* defines.\n\t(gomp_team_barrier_wait_end): Likewise.  Clear BAR_CANCELLED\n\tfrom state where needed.  Set work_share_cancelled to 0 on last\n\tthread.\n\t(gomp_team_barrier_wait_final, gomp_team_barrier_wait_cancel_end,\n\tgomp_team_barrier_wait_cancel, gomp_team_barrier_cancel): New\n\tfunctions.\n\t* config/linux/proc.h (gomp_cpuset_popcount): Add attribute_hidden.\n\tAdd cpusetsize argument.\n\t(gomp_cpuset_size, gomp_cpusetp): Declare.\n\t* config/linux/affinity.c: Include errno.h, stdio.h and string.h.\n\t(affinity_counter): Remove.\n\t(CPU_ISSET_S, CPU_ZERO_S, CPU_SET_S, CPU_CLR_S): Define\n\tif CPU_ALLOC_SIZE isn't defined.\n\t(gomp_init_affinity): Rewritten, if gomp_places_list is NULL, try\n\tsilently create OMP_PLACES=threads, if it is non-NULL afterwards,\n\tbind current thread to the first place.\n\t(gomp_init_thread_affinity): Rewritten.  Add place argument, just\n\tpthread_setaffinity_np to gomp_places_list[place].\n\t(gomp_affinity_alloc, gomp_affinity_init_place, gomp_affinity_add_cpus,\n\tgomp_affinity_remove_cpu, gomp_affinity_copy_place,\n\tgomp_affinity_same_place, gomp_affinity_finalize_place_list,\n\tgomp_affinity_init_level, gomp_affinity_print_place): New functions.\n\t* config/linux/bar.h (BAR_TASK_PENDING, BAR_WAS_LAST,\n\tBAR_WAITING_FOR_TASK, BAR_INCR, BAR_CANCELLED): Define.\n\t(gomp_barrier_t): Add awaited_final field.\n\t(gomp_barrier_init): Initialize awaited_final field.\n\t(gomp_team_barrier_wait_final, gomp_team_barrier_wait_cancel,\n\tgomp_team_barrier_wait_cancel_end, gomp_team_barrier_cancel): New\n\tprototypes.\n\t(gomp_barrier_wait_start): Preserve BAR_CANCELLED bit.  Use BAR_*\n\tdefines.\n\t(gomp_barrier_wait_cancel_start, gomp_team_barrier_wait_final_start,\n\tgomp_team_barrier_cancelled): New inline functions.\n\t(gomp_barrier_last_thread,\n\tgomp_team_barrier_set_task_pending,\n\tgomp_team_barrier_clear_task_pending,\n\tgomp_team_barrier_set_waiting_for_tasks,\n\tgomp_team_barrier_waiting_for_tasks,\n\tgomp_team_barrier_done): Use BAR_* defines.\n\t* config/posix/bar.c (gomp_barrier_init): Clear cancellable field.\n\t(gomp_barrier_wait_end): Use BAR_* defines.\n\t(gomp_team_barrier_wait_end): Clear BAR_CANCELLED from state.\n\tSet work_share_cancelled to 0 on last thread, use __atomic_load_n.\n\tUse BAR_* defines.\n\t(gomp_team_barrier_wait_cancel_end, gomp_team_barrier_wait_cancel,\n\tgomp_team_barrier_cancel): New functions.\n\t* config/posix/affinity.c (gomp_init_thread_affinity): Add place\n\targument.\n\t(gomp_affinity_alloc, gomp_affinity_init_place, gomp_affinity_add_cpus,\n\tgomp_affinity_remove_cpu, gomp_affinity_copy_place,\n\tgomp_affinity_same_place, gomp_affinity_finalize_place_list,\n\tgomp_affinity_init_level, gomp_affinity_print_place): New stubs.\n\t* config/posix/bar.h (BAR_TASK_PENDING, BAR_WAS_LAST,\n\tBAR_WAITING_FOR_TASK, BAR_INCR, BAR_CANCELLED): Define.\n\t(gomp_barrier_t): Add cancellable field.\n\t(gomp_team_barrier_wait_cancel, gomp_team_barrier_wait_cancel_end,\n\tgomp_team_barrier_cancel): New prototypes.\n\t(gomp_barrier_wait_start): Preserve BAR_CANCELLED bit.\n\t(gomp_barrier_wait_cancel_start, gomp_team_barrier_wait_final,\n\tgomp_team_barrier_cancelled): New inline functions.\n\t(gomp_barrier_wait_start, gomp_barrier_last_thread,\n\tgomp_team_barrier_set_task_pending,\n\tgomp_team_barrier_clear_task_pending,\n\tgomp_team_barrier_set_waiting_for_tasks,\n\tgomp_team_barrier_waiting_for_tasks,\n\tgomp_team_barrier_done): Use BAR_* defines.\n\t* barrier.c (GOMP_barrier_cancel): New function.\n\t* omp_lib.h.in (omp_proc_bind_kind, omp_proc_bind_false,\n\tomp_proc_bind_true, omp_proc_bind_master, omp_proc_bind_close,\n\tomp_proc_bind_spread): New params.\n\t(omp_get_cancellation, omp_get_proc_bind, omp_set_default_device,\n\tomp_get_default_device, omp_get_num_devices, omp_get_num_teams,\n\tomp_get_team_num, omp_is_initial_device): New externals.\n\t* parallel.c (GOMP_parallel, GOMP_cancel, GOMP_cancellation_point):\n\tNew functions.\n\t(gomp_resolve_num_threads): Adjust for thread_limit now being in\n\ticv->thread_limit_var.  Use UINT_MAX instead of ULONG_MAX as\n\tinfinity.  If not nested, just return minimum of max_num_threads\n\tand icv->thread_limit_var and if thr->thread_pool, set threads_busy\n\tto the returned value.  Otherwise, don't update atomically\n\tgomp_remaining_threads_count, but instead thr->thread_pool->threads_busy.\n\t(GOMP_parallel_end): Adjust for thread_limit now being in\n\ticv->thread_limit_var.  Use UINT_MAX instead of ULONG_MAX as\n\tinfinity.  Adjust threads_busy in the pool rather than\n\tgomp_remaining_threads_count.  Remember team->nthreads and call\n\tgomp_team_end before adjusting threads_busy, if not nested\n\tafterwards, just set it to 1 non-atomically.  Add ialias.\n\t(GOMP_parallel_start): Adjust gomp_team_start caller.\n\t* testsuite/libgomp.c/atomic-14.c: Add parens to make it valid.\n\t* testsuite/libgomp.c/affinity-1.c: New test.\n\t* testsuite/libgomp.c/atomic-15.c: New test.\n\t* testsuite/libgomp.c/atomic-16.c: New test.\n\t* testsuite/libgomp.c/atomic-17.c: New test.\n\t* testsuite/libgomp.c/cancel-for-1.c: New test.\n\t* testsuite/libgomp.c/cancel-for-2.c: New test.\n\t* testsuite/libgomp.c/cancel-parallel-1.c: New test.\n\t* testsuite/libgomp.c/cancel-parallel-2.c: New test.\n\t* testsuite/libgomp.c/cancel-parallel-3.c: New test.\n\t* testsuite/libgomp.c/cancel-sections-1.c: New test.\n\t* testsuite/libgomp.c/cancel-taskgroup-1.c: New test.\n\t* testsuite/libgomp.c/cancel-taskgroup-2.c: New test.\n\t* testsuite/libgomp.c/depend-1.c: New test.\n\t* testsuite/libgomp.c/depend-2.c: New test.\n\t* testsuite/libgomp.c/depend-3.c: New test.\n\t* testsuite/libgomp.c/depend-4.c: New test.\n\t* testsuite/libgomp.c/for-1.c: New test.\n\t* testsuite/libgomp.c/for-1.h: New file.\n\t* testsuite/libgomp.c/for-2.c: New test.\n\t* testsuite/libgomp.c/for-2.h: New file.\n\t* testsuite/libgomp.c/for-3.c: New test.\n\t* testsuite/libgomp.c/pr58392.c: New test.\n\t* testsuite/libgomp.c/simd-1.c: New test.\n\t* testsuite/libgomp.c/simd-2.c: New test.\n\t* testsuite/libgomp.c/simd-3.c: New test.\n\t* testsuite/libgomp.c/simd-4.c: New test.\n\t* testsuite/libgomp.c/simd-5.c: New test.\n\t* testsuite/libgomp.c/simd-6.c: New test.\n\t* testsuite/libgomp.c/target-1.c: New test.\n\t* testsuite/libgomp.c/target-2.c: New test.\n\t* testsuite/libgomp.c/target-3.c: New test.\n\t* testsuite/libgomp.c/target-4.c: New test.\n\t* testsuite/libgomp.c/target-5.c: New test.\n\t* testsuite/libgomp.c/target-6.c: New test.\n\t* testsuite/libgomp.c/target-7.c: New test.\n\t* testsuite/libgomp.c/taskgroup-1.c: New test.\n\t* testsuite/libgomp.c/thread-limit-1.c: New test.\n\t* testsuite/libgomp.c/thread-limit-2.c: New test.\n\t* testsuite/libgomp.c/thread-limit-3.c: New test.\n\t* testsuite/libgomp.c/udr-1.c: New test.\n\t* testsuite/libgomp.c/udr-2.c: New test.\n\t* testsuite/libgomp.c/udr-3.c: New test.\n\t* testsuite/libgomp.c++/affinity-1.C: New test.\n\t* testsuite/libgomp.c++/atomic-10.C: New test.\n\t* testsuite/libgomp.c++/atomic-11.C: New test.\n\t* testsuite/libgomp.c++/atomic-12.C: New test.\n\t* testsuite/libgomp.c++/atomic-13.C: New test.\n\t* testsuite/libgomp.c++/atomic-14.C: New test.\n\t* testsuite/libgomp.c++/atomic-15.C: New test.\n\t* testsuite/libgomp.c++/cancel-for-1.C: New test.\n\t* testsuite/libgomp.c++/cancel-for-2.C: New test.\n\t* testsuite/libgomp.c++/cancel-parallel-1.C: New test.\n\t* testsuite/libgomp.c++/cancel-parallel-2.C: New test.\n\t* testsuite/libgomp.c++/cancel-parallel-3.C: New test.\n\t* testsuite/libgomp.c++/cancel-sections-1.C: New test.\n\t* testsuite/libgomp.c++/cancel-taskgroup-1.C: New test.\n\t* testsuite/libgomp.c++/cancel-taskgroup-2.C: New test.\n\t* testsuite/libgomp.c++/cancel-taskgroup-3.C: New test.\n\t* testsuite/libgomp.c++/cancel-test.h: New file.\n\t* testsuite/libgomp.c++/for-9.C: New test.\n\t* testsuite/libgomp.c++/for-10.C: New test.\n\t* testsuite/libgomp.c++/for-11.C: New test.\n\t* testsuite/libgomp.c++/simd-1.C: New test.\n\t* testsuite/libgomp.c++/simd-2.C: New test.\n\t* testsuite/libgomp.c++/simd-3.C: New test.\n\t* testsuite/libgomp.c++/simd-4.C: New test.\n\t* testsuite/libgomp.c++/simd-5.C: New test.\n\t* testsuite/libgomp.c++/simd-6.C: New test.\n\t* testsuite/libgomp.c++/simd-7.C: New test.\n\t* testsuite/libgomp.c++/simd-8.C: New test.\n\t* testsuite/libgomp.c++/target-1.C: New test.\n\t* testsuite/libgomp.c++/target-2.C: New test.\n\t* testsuite/libgomp.c++/target-2-aux.cc: New file.\n\t* testsuite/libgomp.c++/target-3.C: New test.\n\t* testsuite/libgomp.c++/taskgroup-1.C: New test.\n\t* testsuite/libgomp.c++/udr-1.C: New test.\n\t* testsuite/libgomp.c++/udr-2.C: New test.\n\t* testsuite/libgomp.c++/udr-3.C: New test.\n\t* testsuite/libgomp.c++/udr-4.C: New test.\n\t* testsuite/libgomp.c++/udr-5.C: New test.\n\t* testsuite/libgomp.c++/udr-6.C: New test.\n\t* testsuite/libgomp.c++/udr-7.C: New test.\n\t* testsuite/libgomp.c++/udr-8.C: New test.\n\t* testsuite/libgomp.c++/udr-9.C: New test.\ngcc/\n\t* tree-pretty-print.c (dump_omp_clause): Handle OMP_CLAUSE__LOOPTEMP_\n\tand new OpenMP 4.0 clauses, handle UDR OMP_CLAUSE_REDUCTION,\n\tformatting fixes, use pp_colon instead of pp_character (..., ':'),\n\tsimilarly pp_right_paren.\n\t(dump_generic_node): Handle OMP_DISTRIBUTE, OMP_TEAMS,\n\tOMP_TARGET_DATA, OMP_TARGET, OMP_TARGET_UPDATE, OMP_TASKGROUP,\n\tallow OMP_FOR_INIT to be NULL, handle OMP_ATOMIC_SEQ_CST.\n\t* tree.c (omp_clause_num_ops, omp_clause_code_name): Add OpenMP 4.0\n\tclauses.\n\t(omp_declare_simd_clauses_equal,\n\tomp_remove_redundant_declare_simd_attrs): New functions.\n\t(attribute_value_equal): Use omp_declare_simd_clauses_equal.\n\t(walk_tree_1): Handle new OpenMP 4.0 clauses.\n\t* tree.h (OMP_LOOP_CHECK): Define.\n\t(OMP_FOR_BODY, OMP_FOR_CLAUSES, OMP_FOR_INIT, OMP_FOR_COND,\n\tOMP_FOR_INCR, OMP_FOR_PRE_BODY): Use it.\n\t(OMP_TASKGROUP_BODY, OMP_TEAMS_BODY, OMP_TEAMS_CLAUSES,\n\tOMP_TARGET_DATA_BODY, OMP_TARGET_DATA_CLAUSES, OMP_TARGET_BODY,\n\tOMP_TARGET_CLAUSES, OMP_TARGET_UPDATE_CLAUSES, OMP_CLAUSE_SIZE,\n\tOMP_ATOMIC_SEQ_CST, OMP_CLAUSE_DEPEND_KIND, OMP_CLAUSE_MAP_KIND,\n\tOMP_CLAUSE_MAP_ZERO_BIAS_ARRAY_SECTION, OMP_CLAUSE_PROC_BIND_KIND,\n\tOMP_CLAUSE_REDUCTION_OMP_ORIG_REF, OMP_CLAUSE_ALIGNED_ALIGNMENT,\n\tOMP_CLAUSE_NUM_TEAMS_EXPR, OMP_CLAUSE_THREAD_LIMIT_EXPR,\n\tOMP_CLAUSE_DEVICE_ID, OMP_CLAUSE_DIST_SCHEDULE_CHUNK_EXPR,\n\tOMP_CLAUSE_SIMDLEN_EXPR): Define.\n\t(OMP_CLAUSE_DECL): Change range up to OMP_CLAUSE__LOOPTEMP_.\n\t(omp_remove_redundant_declare_simd_attrs): New prototype.\n\t* gimple.def (GIMPLE_OMP_TASKGROUP, GIMPLE_OMP_TARGET,\n\tGIMPLE_OMP_TEAMS): New codes.\n\t(GIMPLE_OMP_RETURN): Use GSS_OMP_ATOMIC_STORE instead of GSS_BASE.\n\t* omp-low.c (struct omp_context): Add cancel_label and cancellable\n\tfields.\n\t(target_nesting_level): New variable.\n\t(extract_omp_for_data): Handle GF_OMP_FOR_KIND_DISTRIBUTE and\n\tOMP_CLAUSE_DIST_SCHEDULE.  Don't fallback to library implementation\n\tfor collapse > 1 static schedule unless ordered.\n\t(get_ws_args_for): Add par_stmt argument.  Handle combined loops.\n\t(determine_parallel_type): Adjust get_ws_args_for caller.\n\t(install_var_field): Handle mask & 4 for double indirection.\n\t(scan_sharing_clauses): Ignore shared clause on teams construct.\n\tHandle OMP_CLAUSE__LOOPTEMP_ and new OpenMP 4.0 clauses.\n\t(create_omp_child_function): If inside target or declare target\n\tconstructs, set \"omp declare target\" attribute on the child\n\tfunction.\n\t(find_combined_for): New function.\n\t(scan_omp_parallel): Handle combined loops.\n\t(scan_omp_target, scan_omp_teams): New functions.\n\t(check_omp_nesting_restrictions): Check new OpenMP 4.0 nesting\n\trestrictions and set ctx->cancellable for cancellable constructs.\n\t(scan_omp_1_stmt): Call check_omp_nesting_restrictions also on\n\tselected builtin calls.  Handle GIMPLE_OMP_TASKGROUP,\n\tGIMPLE_OMP_TARGET, GIMPLE_OMP_TEAMS.\n\t(build_omp_barrier): Add lhs argument, return gimple rather than\n\ttree.\n\t(omp_clause_aligned_alignment): New function.\n\t(lower_rec_simd_input_clauses): Only call SET_DECL_VALUE_EXPR\n\ton decls.\n\t(lower_rec_input_clauses): Add FD argument.  Ignore shared clauses\n\ton teams constructs.  Handle user defined reductions and new\n\tOpenMP 4.0 clauses.\n\t(lower_reduction_clauses): Don't set placeholder to address of ref\n\tif it has already the right type.\n\t(lower_send_clauses): Handle OMP_CLAUSE__LOOPTEMP_.\n\t(expand_parallel_call): Use the new non-_start suffixed builtins,\n\thandle OMP_CLAUSE_PROC_BIND, don't call the outlined function\n\tand GOMP_parallel_end after the call.\n\t(expand_task_call): Handle OMP_CLAUSE_DEPEND.\n\t(expand_omp_for_init_counts): Handle combined loops.\n\t(expand_omp_for_init_vars): Add inner_stmt argument, handle combined\n\tloops.\n\t(expand_omp_for_generic): Likewise.  Use GOMP_loop_end_cancel at the\n\tend of cancellable loops.\n\t(expand_omp_for_static_nochunk, expand_omp_for_static_chunk):\n\tLikewise.  Handle collapse > 1 loops.\n\t(expand_omp_simd): Handle combined loops.\n\t(expand_omp_for): Add inner_stmt argument, adjust callers of\n\texpand_omp_for* functions, use expand_omp_for_static*chunk even\n\tfor collapse > 1 unless ordered.\n\t(expand_omp_sections): Use GOMP_sections_end_cancel at the end\n\tof cancellable sections.\n\t(expand_omp_single): Remove need_barrier variable, just rely on\n\tgimple_omp_return_nowait_p.  Adjust build_omp_barrier caller.\n\t(expand_omp_synch): Allow GIMPLE_OMP_TASKGROUP and GIMPLE_OMP_TEAMS.\n\t(expand_omp_atomic_load, expand_omp_atomic_store,\n\texpand_omp_atomic_fetch_op): Handle gimple_omp_atomic_seq_cst_p.\n\t(expand_omp_target): New function.\n\t(expand_omp): Handle combined loops.  Handle GIMPLE_OMP_TASKGROUP,\n\tGIMPLE_OMP_TEAMS, GIMPLE_OMP_TARGET.\n\t(build_omp_regions_1): Immediately close region for\n\tGF_OMP_TARGET_KIND_UPDATE.\n\t(maybe_add_implicit_barrier_cancel): New function.\n\t(lower_omp_sections): Adjust lower_rec_input_clauses caller.  Handle\n\tcancellation.\n\t(lower_omp_single): Likewise.  Add clobber after the barrier.\n\t(lower_omp_taskgroup): New function.\n\t(lower_omp_for): Handle combined loops.  Adjust\n\tlower_rec_input_clauses caller.  Handle cancellation.\n\t(lower_depend_clauses): New function.\n\t(lower_omp_taskreg): Lower depend clauses.  Adjust\n\tlower_rec_input_clauses caller.  Add clobber after the call.  Handle\n\tcancellation.\n\t(lower_omp_target, lower_omp_teams): New functions.\n\t(lower_omp_1): Handle cancellation.  Handle GIMPLE_OMP_TASKGROUP,\n\tGIMPLE_OMP_TARGET, GIMPLE_OMP_TEAMS and GOMP_barrier, GOMP_cancel\n\tand GOMP_cancellation_point calls.\n\t(lower_omp): Fold stmts inside of target region.\n\t(diagnose_sb_1, diagnose_sb_2): Handle GIMPLE_OMP_TASKGROUP,\n\tGIMPLE_OMP_TARGET and GIMPLE_OMP_TEAMS.\n\t* builtin-types.def (DEF_FUNCTION_TYPE_8): Document.\n\t(BT_FN_VOID_OMPFN_PTR_UINT,\n\tBT_FN_VOID_OMPFN_PTR_UINT_LONG_LONG_LONG,\n\tBT_FN_VOID_OMPFN_PTR_UINT_LONG_LONG_LONG_LONG,\n\tBT_FN_VOID_OMPFN_PTR_OMPCPYFN_LONG_LONG_BOOL_UINT): Remove.\n\t(BT_FN_VOID_OMPFN_PTR_UINT_UINT_UINT,\n\tBT_FN_VOID_OMPFN_PTR_UINT_LONG_LONG_LONG_UINT,\n\tBT_FN_VOID_OMPFN_PTR_UINT_LONG_LONG_LONG_LONG_UINT,\n\tBT_FN_BOOL_INT, BT_FN_BOOL_INT_BOOL, BT_FN_VOID_UINT_UINT,\n\tBT_FN_VOID_INT_PTR_SIZE_PTR_PTR_PTR,\n\tBT_FN_VOID_INT_OMPFN_PTR_SIZE_PTR_PTR_PTR,\n\tBT_FN_VOID_OMPFN_PTR_OMPCPYFN_LONG_LONG_BOOL_UINT_PTR): New.\n\t* tree-ssa-alias.c (ref_maybe_used_by_call_p_1,\n\tcall_may_clobber_ref_p_1): Handle BUILT_IN_GOMP_BARRIER_CANCEL,\n\tBUILT_IN_GOMP_TASKGROUP_END, BUILT_IN_GOMP_LOOP_END_CANCEL,\n\tBUILT_IN_GOMP_SECTIONS_END_CANCEL.  Don't handle\n\tBUILT_IN_GOMP_PARALLEL_END.\n\t* gimple-low.c (lower_stmt): Handle GIMPLE_OMP_TASKGROUP,\n\tGIMPLE_OMP_TARGET and GIMPLE_OMP_TEAMS.\n\t* gimple-pretty-print.c (dump_gimple_omp_for): Handle\n\tGF_OMP_FOR_KIND_DISTRIBUTE.\n\t(dump_gimple_omp_target, dump_gimple_omp_teams): New functions.\n\t(dump_gimple_omp_block): Handle GIMPLE_OMP_TASKGROUP.\n\t(dump_gimple_omp_return): Print lhs if it has any.\n\t(dump_gimple_omp_atomic_load, dump_gimple_omp_atomic_store): Handle\n\tgimple_omp_atomic_seq_cst_p.\n\t(pp_gimple_stmt_1): Handle GIMPLE_OMP_TASKGROUP, GIMPLE_OMP_TARGET\n\tand GIMPLE_OMP_TEAMS.\n\t* langhooks.c (lhd_omp_mappable_type): New function.\n\t* tree-vectorizer.c (struct simd_array_to_simduid): Fix up comment.\n\t* langhooks.h (struct lang_hooks_for_types): Add omp_mappable_type\n\thook.\n\t* gimplify.c (enum gimplify_omp_var_data): Add GOVD_MAP,\n\tGOVD_ALIGNED and GOVD_MAP_TO_ONLY.\n\t(enum omp_region_type): Add ORT_TEAMS, ORT_TARGET_DATA and\n\tORT_TARGET.\n\t(struct gimplify_omp_ctx): Add combined_loop field.\n\t(gimplify_call_expr, gimplify_modify_expr): Don't call fold_stmt\n\ton stmts inside of target region.\n\t(is_gimple_stmt): Return true for OMP_DISTRIBUTE and OMP_TASKGROUP.\n\t(omp_firstprivatize_variable): Handle GOVD_MAP, GOVD_ALIGNED,\n\tORT_TARGET and ORT_TARGET_DATA.\n\t(omp_add_variable): Avoid checks on readding var for GOVD_ALIGNED.\n\tHandle GOVD_MAP.\n\t(omp_notice_threadprivate_variable): Complain about threadprivate\n\tvariables in target region.\n\t(omp_notice_variable): Complain about vars with non-mappable type\n\tin target region.  Handle ORT_TEAMS, ORT_TARGET and ORT_TARGET_DATA.\n\t(omp_check_private): Ignore ORT_TARGET* regions.\n\t(gimplify_scan_omp_clauses, gimplify_adjust_omp_clauses_1,\n\tgimplify_adjust_omp_clauses): Handle new OpenMP 4.0 clauses.\n\t(find_combined_omp_for): New function.\n\t(gimplify_omp_for): Handle gimplification of combined loops.\n\t(gimplify_omp_workshare): Gimplify also OMP_TARGET, OMP_TARGET_DATA,\n\tOMP_TEAMS.\n\t(gimplify_omp_target_update): New function.\n\t(gimplify_omp_atomic): Handle OMP_ATOMIC_SEQ_CST.\n\t(gimplify_expr): Handle OMP_DISTRIBUTE, OMP_TARGET, OMP_TARGET_DATA,\n\tOMP_TARGET_UPDATE, OMP_TEAMS, OMP_TASKGROUP.\n\t(gimplify_body): If fndecl has \"omp declare target\" attribute, add\n\timplicit ORT_TARGET context around it.\n\t* tree.def (OMP_DISTRIBUTE, OMP_TEAMS, OMP_TARGET_DATA, OMP_TARGET,\n\tOMP_TASKGROUP, OMP_TARGET_UPDATE): New tree codes.\n\t* tree-nested.c (convert_nonlocal_reference_stmt,\n\tconvert_local_reference_stmt, convert_gimple_call): Handle\n\tGIMPLE_OMP_TARGET, GIMPLE_OMP_TEAMS and GIMPLE_OMP_TASKGROUP.\n\t* omp-builtins.def (BUILT_IN_GOMP_TASK): Use\n\tBT_FN_VOID_OMPFN_PTR_OMPCPYFN_LONG_LONG_BOOL_UINT_PTR\n\tinstead of BT_FN_VOID_OMPFN_PTR_OMPCPYFN_LONG_LONG_BOOL_UINT.\n\t(BUILT_IN_GOMP_TARGET, BUILT_IN_GOMP_TARGET_DATA,\n\tBUILT_IN_GOMP_TARGET_END_DATA, BUILT_IN_GOMP_TARGET_UPDATE,\n\tBUILT_IN_GOMP_TEAMS, BUILT_IN_BARRIER_CANCEL,\n\tBUILT_IN_GOMP_LOOP_END_CANCEL,\n\tBUILT_IN_GOMP_SECTIONS_END_CANCEL, BUILT_IN_OMP_GET_TEAM_NUM,\n\tBUILT_IN_OMP_GET_NUM_TEAMS, BUILT_IN_GOMP_TASKGROUP_START,\n\tBUILT_IN_GOMP_TASKGROUP_END, BUILT_IN_GOMP_PARALLEL_LOOP_STATIC,\n\tBUILT_IN_GOMP_PARALLEL_LOOP_DYNAMIC,\n\tBUILT_IN_GOMP_PARALLEL_LOOP_GUIDED,\n\tBUILT_IN_GOMP_PARALLEL_LOOP_RUNTIME, BUILT_IN_GOMP_PARALLEL,\n\tBUILT_IN_GOMP_PARALLEL_SECTIONS, BUILT_IN_GOMP_CANCEL,\n\tBUILT_IN_GOMP_CANCELLATION_POINT): New built-ins.\n\t(BUILT_IN_GOMP_PARALLEL_LOOP_STATIC_START,\n\tBUILT_IN_GOMP_PARALLEL_LOOP_DYNAMIC_START,\n\tBUILT_IN_GOMP_PARALLEL_LOOP_GUIDED_START,\n\tBUILT_IN_GOMP_PARALLEL_LOOP_RUNTIME_START,\n\tBUILT_IN_GOMP_PARALLEL_START, BUILT_IN_GOMP_PARALLEL_END,\n\tBUILT_IN_GOMP_PARALLEL_SECTIONS_START): Remove.\n\t* tree-inline.c (remap_gimple_stmt, estimate_num_insns):\n\tHandle GIMPLE_OMP_TARGET, GIMPLE_OMP_TEAMS and GIMPLE_OMP_TASKGROUP.\n\t* gimple.c (gimple_build_omp_taskgroup, gimple_build_omp_target,\n\tgimple_build_omp_teams): New functions.\n\t(walk_gimple_op): Handle GIMPLE_OMP_TARGET, GIMPLE_OMP_TEAMS and\n\tGIMPLE_OMP_TASKGROUP.  Walk optional lhs on GIMPLE_OMP_RETURN.\n\t(walk_gimple_stmt, gimple_copy): Handle GIMPLE_OMP_TARGET,\n\tGIMPLE_OMP_TEAMS and GIMPLE_OMP_TASKGROUP.\n\t* gimple.h (enum gf_mask): GF_OMP_FOR_KIND_DISTRIBUTE,\n\tGF_OMP_FOR_COMBINED, GF_OMP_FOR_COMBINED_INTO,\n\tGF_OMP_TARGET_KIND_MASK, GF_OMP_TARGET_KIND_REGION,\n\tGF_OMP_TARGET_KIND_DATA, GF_OMP_TARGET_KIND_UPDATE,\n\tGF_OMP_ATOMIC_SEQ_CST): New.\n\t(gimple_build_omp_taskgroup, gimple_build_omp_target,\n\tgimple_build_omp_teams): New prototypes.\n\t(gimple_has_substatements): Handle GIMPLE_OMP_TARGET,\n\tGIMPLE_OMP_TEAMS and GIMPLE_OMP_TASKGROUP.\n\t(gimple_omp_subcode): Use GIMPLE_OMP_TEAMS instead of\n\tGIMPLE_OMP_SINGLE as end of range.\n\t(gimple_omp_return_set_lhs, gimple_omp_return_lhs,\n\tgimple_omp_return_lhs_ptr, gimple_omp_atomic_seq_cst_p,\n\tgimple_omp_atomic_set_seq_cst, gimple_omp_for_combined_p,\n\tgimple_omp_for_set_combined_p, gimple_omp_for_combined_into_p,\n\tgimple_omp_for_set_combined_into_p, gimple_omp_target_clauses,\n\tgimple_omp_target_clauses_ptr, gimple_omp_target_set_clauses,\n\tgimple_omp_target_kind, gimple_omp_target_set_kind,\n\tgimple_omp_target_child_fn, gimple_omp_target_child_fn_ptr,\n\tgimple_omp_target_set_child_fn, gimple_omp_target_data_arg,\n\tgimple_omp_target_data_arg_ptr, gimple_omp_target_set_data_arg,\n\tgimple_omp_teams_clauses, gimple_omp_teams_clauses_ptr,\n\tgimple_omp_teams_set_clauses): New inlines.\n\t(CASE_GIMPLE_OMP): Add GIMPLE_OMP_TARGET, GIMPLE_OMP_TEAMS\n\tand GIMPLE_OMP_TASKGROUP.\n\t* tree-core.h (enum omp_clause_code): Add new OpenMP 4.0 clause\n\tcodes.\n\t(enum omp_clause_depend_kind, enum omp_clause_map_kind,\n\tenum omp_clause_proc_bind_kind): New.\n\t(union omp_clause_subcode): Add depend_kind, map_kind and\n\tproc_bind_kind fields.\n\t* tree-cfg.c (make_edges): Handle GIMPLE_OMP_TARGET,\n\tGIMPLE_OMP_TEAMS and GIMPLE_OMP_TASKGROUP.\n\t* langhooks-def.h (lhd_omp_mappable_type): New prototype.\n\t(LANG_HOOKS_OMP_MAPPABLE_TYPE): Define.\n\t(LANG_HOOKS_FOR_TYPES_INITIALIZER): Add it.\ngcc/c-family/\n\t* c-cppbuiltin.c (c_cpp_builtins): Predefine _OPENMP to\n\t201307 instead of 201107.\n\t* c-common.c (DEF_FUNCTION_TYPE_8): Define.\n\t(c_common_attribute_table): Add \"omp declare target\" and\n\t\"omp declare simd\" attributes.\n\t(handle_omp_declare_target_attribute,\n\thandle_omp_declare_simd_attribute): New functions.\n\t* c-omp.c: Include c-pragma.h.\n\t(c_finish_omp_taskgroup): New function.\n\t(c_finish_omp_atomic): Add swapped argument, if true,\n\tbuild the operation first with rhs, lhs arguments and use NOP_EXPR\n\tbuild_modify_expr.\n\t(c_finish_omp_for): Add code argument, pass it down to make_code.\n\t(c_omp_split_clauses): New function.\n\t(c_split_parallel_clauses): Removed.\n\t(c_omp_declare_simd_clause_cmp, c_omp_declare_simd_clauses_to_numbers,\n\tc_omp_declare_simd_clauses_to_decls): New functions.\n\t* c-common.h (omp_clause_mask): New type.\n\t(OMP_CLAUSE_MASK_1): Define.\n\t(omp_clause_mask::omp_clause_mask, omp_clause_mask::operator &=,\n\tomp_clause_mask::operator |=, omp_clause_mask::operator ~,\n\tomp_clause_mask::operator |, omp_clause_mask::operator &,\n\tomp_clause_mask::operator <<, omp_clause_mask::operator >>,\n\tomp_clause_mask::operator ==): New methods.\n\t(enum c_omp_clause_split): New.\n\t(c_finish_omp_taskgroup): New prototype.\n\t(c_finish_omp_atomic): Add swapped argument.\n\t(c_finish_omp_for): Add code argument.\n\t(c_omp_split_clauses): New prototype.\n\t(c_split_parallel_clauses): Removed.\n\t(c_omp_declare_simd_clauses_to_numbers,\n\tc_omp_declare_simd_clauses_to_decls): New prototypes.\n\t* c-pragma.c (omp_pragmas): Add new OpenMP 4.0 constructs.\n\t* c-pragma.h (enum pragma_kind): Add PRAGMA_OMP_CANCEL,\n\tPRAGMA_OMP_CANCELLATION_POINT, PRAGMA_OMP_DECLARE_REDUCTION,\n\tPRAGMA_OMP_DISTRIBUTE, PRAGMA_OMP_END_DECLARE_TARGET, PRAGMA_OMP_SIMD,\n\tPRAGMA_OMP_TARGET, PRAGMA_OMP_TASKGROUP and PRAGMA_OMP_TEAMS.\n\tRemove PRAGMA_OMP_PARALLEL_FOR and PRAGMA_OMP_PARALLEL_SECTIONS.\n\t(enum pragma_omp_clause): Add PRAGMA_OMP_CLAUSE_ALIGNED,\n\tPRAGMA_OMP_CLAUSE_DEPEND, PRAGMA_OMP_CLAUSE_DEVICE,\n\tPRAGMA_OMP_CLAUSE_DIST_SCHEDULE, PRAGMA_OMP_CLAUSE_FOR,\n\tPRAGMA_OMP_CLAUSE_FROM, PRAGMA_OMP_CLAUSE_INBRANCH,\n\tPRAGMA_OMP_CLAUSE_LINEAR, PRAGMA_OMP_CLAUSE_MAP,\n\tPRAGMA_OMP_CLAUSE_NOTINBRANCH, PRAGMA_OMP_CLAUSE_NUM_TEAMS,\n\tPRAGMA_OMP_CLAUSE_PARALLEL, PRAGMA_OMP_CLAUSE_PROC_BIND,\n\tPRAGMA_OMP_CLAUSE_SAFELEN, PRAGMA_OMP_CLAUSE_SECTIONS,\n\tPRAGMA_OMP_CLAUSE_SIMDLEN, PRAGMA_OMP_CLAUSE_TASKGROUP,\n\tPRAGMA_OMP_CLAUSE_THREAD_LIMIT, PRAGMA_OMP_CLAUSE_TO and\n\tPRAGMA_OMP_CLAUSE_UNIFORM.\ngcc/ada/\n\t* gcc-interface/utils.c (DEF_FUNCTION_TYPE_8): Define.\ngcc/fortran/\n\t* trans-openmp.c (gfc_omp_clause_default_ctor,\n\tgfc_omp_clause_dtor): Return NULL for OMP_CLAUSE_REDUCTION.\n\t* f95-lang.c (ATTR_NULL, DEF_FUNCTION_TYPE_8): Define.\n\t* types.def (DEF_FUNCTION_TYPE_8): Document.\n\t(BT_FN_VOID_OMPFN_PTR_UINT,\n\tBT_FN_VOID_OMPFN_PTR_UINT_LONG_LONG_LONG,\n\tBT_FN_VOID_OMPFN_PTR_UINT_LONG_LONG_LONG_LONG,\n\tBT_FN_VOID_OMPFN_PTR_OMPCPYFN_LONG_LONG_BOOL_UINT): Remove.\n\t(BT_FN_VOID_OMPFN_PTR_UINT_UINT_UINT,\n\tBT_FN_VOID_OMPFN_PTR_UINT_LONG_LONG_LONG_UINT,\n\tBT_FN_VOID_OMPFN_PTR_UINT_LONG_LONG_LONG_LONG_UINT,\n\tBT_FN_BOOL_INT, BT_FN_BOOL_INT_BOOL, BT_FN_VOID_UINT_UINT,\n\tBT_FN_VOID_INT_PTR_SIZE_PTR_PTR_PTR,\n\tBT_FN_VOID_INT_OMPFN_PTR_SIZE_PTR_PTR_PTR,\n\tBT_FN_VOID_OMPFN_PTR_OMPCPYFN_LONG_LONG_BOOL_UINT_PTR): New.\ngcc/lto/\n\t* lto-lang.c (DEF_FUNCTION_TYPE_8): Define.\ngcc/c/\n\t* c-lang.h (current_omp_declare_target_attribute): New extern\n\tdecl.\n\t* c-parser.c: Include c-lang.h.\n\t(struct c_parser): Change tokens to c_token *.\n\tAdd tokens_buf field.  Change tokens_avail type to unsigned int.\n\t(c_parser_consume_token): If parser->tokens isn't\n\t&parser->tokens_buf[0], increment parser->tokens.\n\t(c_parser_consume_pragma): Likewise.\n\t(enum pragma_context): Add pragma_struct and pragma_param.\n\t(c_parser_external_declaration): Adjust\n\tc_parser_declaration_or_fndef caller.\n\t(c_parser_declaration_or_fndef): Add omp_declare_simd_clauses\n\targument, if it is non-vNULL vector, call c_finish_omp_declare_simd.\n\tAdjust recursive call.\n\t(c_parser_struct_or_union_specifier): Use pragma_struct instead\n\tof pragma_external.\n\t(c_parser_parameter_declaration): Use pragma_param instead of\n\tpragma_external.\n\t(c_parser_compound_statement_nostart, c_parser_label,\n\tc_parser_for_statement): Adjust\n\tc_parser_declaration_or_fndef callers.\n\t(c_parser_expr_no_commas): Add omp_atomic_lhs argument, pass\n\tit through to c_parser_conditional_expression.\n\t(c_parser_conditional_expression): Add omp_atomic_lhs argument,\n\tpass it through to c_parser_binary_expression.  Adjust recursive\n\tcall.\n\t(c_parser_binary_expression): Remove prec argument, add\n\tomp_atomic_lhs argument instead.  Always start from PREC_NONE, if\n\tomp_atomic_lhs is non-NULL and one of the arguments of toplevel\n\tbinop matches it, use build2 instead of parser_build_binary_op.\n\t(c_parser_pragma): Handle PRAGMA_OMP_CANCEL,\n\tPRAGMA_OMP_CANCELLATION_POINT, PRAGMA_OMP_TARGET,\n\tPRAGMA_OMP_END_DECLARE_TARGET, PRAGMA_OMP_DECLARE_REDUCTION.\n\tHandle pragma_struct and pragma_param the same as pragma_external.\n\t(c_parser_omp_clause_name): Parse new OpenMP 4.0 clause names.\n\t(c_parser_omp_variable_list): Parse array sections for\n\tOMP_CLAUSE_{DEPEND,MAP,TO,FROM} clauses.\n\t(c_parser_omp_clause_collapse): Fully fold collapse expression.\n\t(c_parser_omp_clause_reduction): Handle user defined reductions.\n\t(c_parser_omp_clause_branch, c_parser_omp_clause_cancelkind,\n\tc_parser_omp_clause_num_teams, c_parser_omp_clause_thread_limit,\n\tc_parser_omp_clause_aligned, c_parser_omp_clause_linear,\n\tc_parser_omp_clause_safelen, c_parser_omp_clause_simdlen,\n\tc_parser_omp_clause_depend, c_parser_omp_clause_map,\n\tc_parser_omp_clause_device, c_parser_omp_clause_dist_schedule,\n\tc_parser_omp_clause_proc_bind, c_parser_omp_clause_to,\n\tc_parser_omp_clause_from, c_parser_omp_clause_uniform): New functions.\n\t(c_parser_omp_all_clauses): Add finish_p argument.  Don't call\n\tc_finish_omp_clauses if it is false.  Handle new OpenMP 4.0 clauses.\n\t(c_parser_omp_atomic): Parse seq_cst clause, pass true if it is\n\tpresent to c_finish_omp_atomic.  Handle OpenMP 4.0 atomic forms.\n\t(c_parser_omp_for_loop): Add CODE argument, pass it through\n\tto c_finish_omp_for.  Change last argument to cclauses,\n\tand adjust uses to grab parallel clauses from the array of all\n\tthe split clauses.  Adjust c_parser_binary_expression,\n\tc_parser_declaration_or_fndef and c_finish_omp_for callers.\n\t(omp_split_clauses): New function.\n\t(c_parser_omp_simd): New function.\n\t(c_parser_omp_for): Add p_name, mask and cclauses arguments.\n\tAllow the function to be called also when parsing combined constructs,\n\tand call c_parser_omp_simd when parsing for simd.\n\t(c_parser_omp_sections_scope): If section-sequence doesn't start with\n\t#pragma omp section, require exactly one structured-block instead of\n\tsequence of statements.\n\t(c_parser_omp_sections): Add p_name, mask and cclauses arguments.\n\tAllow the function to be called also when parsing combined constructs.\n\t(c_parser_omp_parallel): Add p_name, mask and cclauses arguments.\n\tAllow the function to be called also when parsing combined\n\tconstructs.\n\t(c_parser_omp_taskgroup, c_parser_omp_cancel,\n\tc_parser_omp_cancellation_point, c_parser_omp_distribute,\n\tc_parser_omp_teams, c_parser_omp_target_data,\n\tc_parser_omp_target_update, c_parser_omp_target,\n\tc_parser_omp_declare_simd, c_finish_omp_declare_simd,\n\tc_parser_omp_declare_target, c_parser_omp_end_declare_target,\n\tc_parser_omp_declare_reduction, c_parser_omp_declare): New functions.\n\t(c_parser_omp_construct): Add p_name and mask vars.  Handle\n\tPRAGMA_OMP_DISTRIBUTE, PRAGMA_OMP_SIMD, PRAGMA_OMP_TASKGROUP,\n\tPRAGMA_OMP_TEAMS.  Adjust c_parser_omp_for, c_parser_omp_parallel\n\tand c_parser_omp_sections callers.\n\t(c_parse_file): Initialize tparser.tokens and the_parser->tokens here.\n\t(OMP_FOR_CLAUSE_MASK, OMP_SECTIONS_CLAUSE_MASK,\n\tOMP_SINGLE_CLAUSE_MASK): Use OMP_CLAUSE_MASK_1 instead of 1.\n\t(OMP_PARALLEL_CLAUSE_MASK): Likewise.  Add OMP_CLAUSE_PROC_BIND.\n\t(OMP_TASK_CLAUSE_MASK): Use OMP_CLAUSE_MASK_1 instead of 1.  Add\n\tOMP_CLAUSE_DEPEND.\n\t(OMP_SIMD_CLAUSE_MASK, OMP_CANCEL_CLAUSE_MASK,\n\tOMP_CANCELLATION_POINT_CLAUSE_MASK, OMP_DISTRIBUTE_CLAUSE_MASK,\n\tOMP_TEAMS_CLAUSE_MASK, OMP_TARGET_DATA_CLAUSE_MASK,\n\tOMP_TARGET_UPDATE_CLAUSE_MASK, OMP_TARGET_CLAUSE_MASK,\n\tOMP_DECLARE_SIMD_CLAUSE_MASK): Define.\n\t* c-typeck.c: Include tree-inline.h.\n\t(c_finish_omp_cancel, c_finish_omp_cancellation_point,\n\thandle_omp_array_sections_1, handle_omp_array_sections,\n\tc_clone_omp_udr, c_find_omp_placeholder_r): New functions.\n\t(c_finish_omp_clauses): Handle new OpenMP 4.0 clauses and\n\tuser defined reductions.\n\t(c_tree_equal): New function.\n\t* c-tree.h (temp_store_parm_decls, temp_pop_parm_decls,\n\tc_finish_omp_cancel, c_finish_omp_cancellation_point, c_tree_equal,\n\tc_omp_reduction_id, c_omp_reduction_decl, c_omp_reduction_lookup,\n\tc_check_omp_declare_reduction_r): New prototypes.\n\t* c-decl.c (current_omp_declare_target_attribute): New variable.\n\t(c_decl_attributes): New function.\n\t(start_decl, start_function): Use it instead of decl_attributes.\n\t(temp_store_parm_decls, temp_pop_parm_decls, c_omp_reduction_id,\n\tc_omp_reduction_decl, c_omp_reduction_lookup,\n\tc_check_omp_declare_reduction_r): New functions.\ngcc/cp/\n\t* decl.c (duplicate_decls): Error out for redeclaration of UDRs.\n\t(declare_simd_adjust_this): New function.\n\t(grokfndecl): If \"omp declare simd\" attribute is present,\n\tcall declare_simd_adjust_this if needed and\n\tc_omp_declare_simd_clauses_to_numbers.\n\t* cp-array-notation.c (expand_array_notation_exprs): Handle\n\tOMP_TASKGROUP.\n\t* cp-gimplify.c (cp_gimplify_expr): Handle OMP_SIMD and\n\tOMP_DISTRIBUTE.  Handle is_invisiref_parm decls in\n\tOMP_CLAUSE_REDUCTION.\n\t(cp_genericize_r): Handle OMP_SIMD and OMP_DISTRIBUTE like\n\tOMP_FOR.\n\t(cxx_omp_privatize_by_reference): Return true for\n\tis_invisiref_parm decls.\n\t(cxx_omp_finish_clause): Adjust cxx_omp_create_clause_info\n\tcaller.\n\t* pt.c (apply_late_template_attributes): For \"omp declare simd\"\n\tattribute call tsubst_omp_clauses,\n\tc_omp_declare_simd_clauses_to_decls, finish_omp_clauses\n\tand c_omp_declare_simd_clauses_to_numbers.\n\t(instantiate_class_template_1): Call cp_check_omp_declare_reduction\n\tfor UDRs.\n\t(tsubst_decl): Handle UDRs.\n\t(tsubst_omp_clauses): Add declare_simd argument, if true don't\n\tcall finish_omp_clauses.  Handle new OpenMP 4.0 clauses.\n\tHandle non-NULL OMP_CLAUSE_REDUCTION_PLACEHOLDER on\n\tOMP_CLAUSE_REDUCTION.\n\t(tsubst_expr): For UDRs call pushdecl and\n\tcp_check_omp_declare_reduction.  Adjust tsubst_omp_clauses\n\tcallers.  Handle OMP_SIMD, OMP_DISTRIBUTE, OMP_TEAMS,\n\tOMP_TARGET_DATA, OMP_TARGET_UPDATE, OMP_TARGET, OMP_TASKGROUP.\n\tAdjust finish_omp_atomic caller.\n\t(tsubst_omp_udr): New function.\n\t(instantiate_decl): For UDRs at block scope, don't call\n\tstart_preparsed_function/finish_function.  Call tsubst_omp_udr.\n\t* semantics.c (cxx_omp_create_clause_info): Add need_dtor argument,\n\tuse it instead of need_default_ctor || need_copy_ctor.\n\t(struct cp_check_omp_declare_reduction_data): New type.\n\t(handle_omp_array_sections_1, handle_omp_array_sections,\n\tomp_reduction_id, omp_reduction_lookup,\n\tcp_remove_omp_priv_cleanup_stmt, cp_check_omp_declare_reduction_r,\n\tcp_check_omp_declare_reduction, clone_omp_udr,\n\tfind_omp_placeholder_r, finish_omp_reduction_clause): New functions.\n\t(finish_omp_clauses): Handle new OpenMP 4.0 clauses and user defined\n\treductions.\n\t(finish_omp_for): Add CODE argument, use it instead of hardcoded\n\tOMP_FOR.  Adjust c_finish_omp_for caller.\n\t(finish_omp_atomic): Add seq_cst argument, adjust\n\tc_finish_omp_atomic callers, handle seq_cst and new OpenMP 4.0\n\tatomic variants.\n\t(finish_omp_cancel, finish_omp_cancellation_point): New functions.\n\t* decl2.c (mark_used): Force immediate instantiation of\n\tDECL_OMP_DECLARE_REDUCTION_P decls.\n\t(is_late_template_attribute): Return true for \"omp declare simd\"\n\tattribute.\n\t(cp_omp_mappable_type): New function.\n\t(cplus_decl_attributes): Add implicit \"omp declare target\" attribute\n\tif requested.\n\t* parser.c (cp_debug_parser): Print\n\tparser->colon_doesnt_start_class_def_p.\n\t(cp_ensure_no_omp_declare_simd, cp_finalize_omp_declare_simd): New\n\tfunctions.\n\t(enum pragma_context): Add pragma_member and pragma_objc_icode.\n\t(cp_parser_binary_expression): Handle no_toplevel_fold_p\n\teven for binary operations other than comparison.\n\t(cp_parser_linkage_specification): Call\n\tcp_ensure_no_omp_declare_simd if needed.\n\t(cp_parser_namespace_definition): Likewise.\n\t(cp_parser_init_declarator): Call cp_finalize_omp_declare_simd.\n\t(cp_parser_direct_declarator): Pass declarator to\n\tcp_parser_late_return_type_opt.\n\t(cp_parser_late_return_type_opt): Add declarator argument,\n\tcall cp_parser_late_parsing_omp_declare_simd for declare simd.\n\t(cp_parser_class_specifier_1): Call cp_ensure_no_omp_declare_simd.\n\tParse UDRs before all other methods.\n\t(cp_parser_member_specification_opt): Use pragma_member instead of\n\tpragma_external.\n\t(cp_parser_member_declaration): Call cp_finalize_omp_declare_simd.\n\t(cp_parser_function_definition_from_specifiers_and_declarator,\n\tcp_parser_save_member_function_body): Likewise.\n\t(cp_parser_late_parsing_for_member): Handle UDRs specially.\n\t(cp_parser_next_token_starts_class_definition_p): Don't allow\n\tCPP_COLON if colon_doesnt_start_class_def_p flag is true.\n\t(cp_parser_objc_interstitial_code): Use pragma_objc_icode\n\tinstead of pragma_external.\n\t(cp_parser_omp_clause_name): Parse new OpenMP 4.0 clause names.\n\t(cp_parser_omp_var_list_no_open): Parse array sections for\n\tOMP_CLAUSE_{DEPEND,MAP,TO,FROM} clauses.  Add COLON argument,\n\tif non-NULL, allow parsing to end with a colon rather than close\n\tparen.\n\t(cp_parser_omp_var_list): Adjust cp_parser_omp_var_list_no_open\n\tcaller.\n\t(cp_parser_omp_clause_reduction): Handle user defined reductions.\n\t(cp_parser_omp_clause_branch, cp_parser_omp_clause_cancelkind,\n\tcp_parser_omp_clause_num_teams, cp_parser_omp_clause_thread_limit,\n\tcp_parser_omp_clause_aligned, cp_parser_omp_clause_linear,\n\tcp_parser_omp_clause_safelen, cp_parser_omp_clause_simdlen,\n\tcp_parser_omp_clause_depend, cp_parser_omp_clause_map,\n\tcp_parser_omp_clause_device, cp_parser_omp_clause_dist_schedule,\n\tcp_parser_omp_clause_proc_bind, cp_parser_omp_clause_to,\n\tcp_parser_omp_clause_from, cp_parser_omp_clause_uniform): New\n\tfunctions.\n\t(cp_parser_omp_all_clauses): Add finish_p argument.  Don't call\n\tfinish_omp_clauses if it is false.  Handle new OpenMP 4.0 clauses.\n\t(cp_parser_omp_atomic): Parse seq_cst clause, pass\n\ttrue if it is present to finish_omp_atomic.  Handle new OpenMP 4.0\n\tatomic forms.\n\t(cp_parser_omp_for_loop): Add CODE argument, pass it through\n\tto finish_omp_for.  Change last argument to cclauses,\n\tand adjust uses to grab parallel clauses from the array of all\n\tthe split clauses.\n\t(cp_omp_split_clauses): New function.\n\t(cp_parser_omp_simd): New function.\n\t(cp_parser_omp_for): Add p_name, mask and cclauses arguments.\n\tAllow the function to be called also when parsing combined constructs,\n\tand call c_parser_omp_simd when parsing for simd.\n\t(cp_parser_omp_sections_scope): If section-sequence doesn't start with\n\t#pragma omp section, require exactly one structured-block instead of\n\tsequence of statements.\n\t(cp_parser_omp_sections): Add p_name, mask and cclauses arguments.\n\tAllow the function to be called also when parsing combined constructs.\n\t(cp_parser_omp_parallel): Add p_name, mask and cclauses arguments.\n\tAllow the function to be called also when parsing combined\n\tconstructs.\n\t(cp_parser_omp_taskgroup, cp_parser_omp_cancel,\n\tcp_parser_omp_cancellation_point, cp_parser_omp_distribute,\n\tcp_parser_omp_teams, cp_parser_omp_target_data,\n\tcp_parser_omp_target_update, cp_parser_omp_target,\n\tcp_parser_omp_declare_simd, cp_parser_late_parsing_omp_declare_simd,\n\tcp_parser_omp_declare_target, cp_parser_omp_end_declare_target,\n\tcp_parser_omp_declare_reduction_exprs, cp_parser_omp_declare_reduction,\n\tcp_parser_omp_declare): New functions.\n\t(cp_parser_omp_construct): Add p_name and mask vars.  Handle\n\tPRAGMA_OMP_DISTRIBUTE, PRAGMA_OMP_SIMD, PRAGMA_OMP_TASKGROUP,\n\tPRAGMA_OMP_TEAMS.  Adjust cp_parser_omp_for, cp_parser_omp_parallel\n\tand cp_parser_omp_sections callers.\n\t(cp_parser_pragma): Handle PRAGMA_OMP_CANCEL,\n\tPRAGMA_OMP_CANCELLATION_POINT, PRAGMA_OMP_DECLARE_REDUCTION,\n\tPRAGMA_OMP_DISTRIBUTE, PRAGMA_OMP_SIMD, PRAGMA_OMP_TASKGROUP,\n\tPRAGMA_OMP_TEAMS, PRAGMA_OMP_TARGET, PRAGMA_OMP_END_DECLARE_TARGET.\n\tHandle pragma_member and pragma_objc_icode like pragma_external.\n\t(OMP_FOR_CLAUSE_MASK, OMP_SECTIONS_CLAUSE_MASK,\n\tOMP_SINGLE_CLAUSE_MASK): Use OMP_CLAUSE_MASK_1 instead of 1.\n\t(OMP_PARALLEL_CLAUSE_MASK): Likewise.  Add OMP_CLAUSE_PROC_BIND.\n\t(OMP_TASK_CLAUSE_MASK): Use OMP_CLAUSE_MASK_1 instead of 1.  Add\n\tOMP_CLAUSE_DEPEND.\n\t(OMP_SIMD_CLAUSE_MASK, OMP_CANCEL_CLAUSE_MASK,\n\tOMP_CANCELLATION_POINT_CLAUSE_MASK, OMP_DISTRIBUTE_CLAUSE_MASK,\n\tOMP_TEAMS_CLAUSE_MASK, OMP_TARGET_DATA_CLAUSE_MASK,\n\tOMP_TARGET_UPDATE_CLAUSE_MASK, OMP_TARGET_CLAUSE_MASK,\n\tOMP_DECLARE_SIMD_CLAUSE_MASK): Define.\n\t* parser.h (struct cp_omp_declare_simd_data): New type.\n\t(struct cp_parser): Add colon_doesnt_start_class_def_p and\n\tomp_declare_simd fields.\n\t* cp-objcp-common.h (LANG_HOOKS_OMP_MAPPABLE_TYPE): Define.\n\t* cp-tree.h (struct lang_decl_fn): Add omp_declare_reduction_p\n\tbit.\n\t(DECL_OMP_DECLARE_REDUCTION_P): Define.\n\t(OMP_FOR_GIMPLIFYING_P): Use OMP_LOOP_CHECK macro.\n\t(struct saved_scope): Add omp_declare_target_attribute field.\n\t(cp_omp_mappable_type, omp_reduction_id,\n\tcp_remove_omp_priv_cleanup_stmt, cp_check_omp_declare_reduction,\n\tfinish_omp_cancel, finish_omp_cancellation_point): New prototypes.\n\t(finish_omp_for): Add CODE argument.\n\t(finish_omp_atomic): Add seq_cst argument.\n\t(cxx_omp_create_clause_info): Add need_dtor argument.\ngcc/testsuite/\n\t* c-c++-common/gomp/atomic-15.c: Adjust for C diagnostics.\n\tRemove error test that is now valid in OpenMP 4.0.\n\t* c-c++-common/gomp/atomic-16.c: New test.\n\t* c-c++-common/gomp/cancel-1.c: New test.\n\t* c-c++-common/gomp/depend-1.c: New test.\n\t* c-c++-common/gomp/depend-2.c: New test.\n\t* c-c++-common/gomp/map-1.c: New test.\n\t* c-c++-common/gomp/pr58472.c: New test.\n\t* c-c++-common/gomp/sections1.c: New test.\n\t* c-c++-common/gomp/simd1.c: New test.\n\t* c-c++-common/gomp/simd2.c: New test.\n\t* c-c++-common/gomp/simd3.c: New test.\n\t* c-c++-common/gomp/simd4.c: New test.\n\t* c-c++-common/gomp/simd5.c: New test.\n\t* c-c++-common/gomp/single1.c: New test.\n\t* g++.dg/gomp/block-0.C: Adjust for stricter #pragma omp sections\n\tparser.\n\t* g++.dg/gomp/block-3.C: Likewise.\n\t* g++.dg/gomp/clause-3.C: Adjust error messages.\n\t* g++.dg/gomp/declare-simd-1.C: New test.\n\t* g++.dg/gomp/declare-simd-2.C: New test.\n\t* g++.dg/gomp/depend-1.C: New test.\n\t* g++.dg/gomp/depend-2.C: New test.\n\t* g++.dg/gomp/target-1.C: New test.\n\t* g++.dg/gomp/target-2.C: New test.\n\t* g++.dg/gomp/taskgroup-1.C: New test.\n\t* g++.dg/gomp/teams-1.C: New test.\n\t* g++.dg/gomp/udr-1.C: New test.\n\t* g++.dg/gomp/udr-2.C: New test.\n\t* g++.dg/gomp/udr-3.C: New test.\n\t* g++.dg/gomp/udr-4.C: New test.\n\t* g++.dg/gomp/udr-5.C: New test.\n\t* g++.dg/gomp/udr-6.C: New test.\n\t* gcc.dg/autopar/outer-1.c: Expect 4 instead of 5 loopfn matches.\n\t* gcc.dg/autopar/outer-2.c: Likewise.\n\t* gcc.dg/autopar/outer-3.c: Likewise.\n\t* gcc.dg/autopar/outer-4.c: Likewise.\n\t* gcc.dg/autopar/outer-5.c: Likewise.\n\t* gcc.dg/autopar/outer-6.c: Likewise.\n\t* gcc.dg/autopar/parallelization-1.c: Likewise.\n\t* gcc.dg/gomp/block-3.c: Adjust for stricter #pragma omp sections\n\tparser.\n\t* gcc.dg/gomp/clause-1.c: Adjust error messages.\n\t* gcc.dg/gomp/combined-1.c: Look for GOMP_parallel_loop_runtime\n\tinstead of GOMP_parallel_loop_runtime_start.\n\t* gcc.dg/gomp/declare-simd-1.c: New test.\n\t* gcc.dg/gomp/declare-simd-2.c: New test.\n\t* gcc.dg/gomp/nesting-1.c: Adjust for stricter #pragma omp sections\n\tparser.  Add further #pragma omp sections nesting tests.\n\t* gcc.dg/gomp/target-1.c: New test.\n\t* gcc.dg/gomp/target-2.c: New test.\n\t* gcc.dg/gomp/taskgroup-1.c: New test.\n\t* gcc.dg/gomp/teams-1.c: New test.\n\t* gcc.dg/gomp/udr-1.c: New test.\n\t* gcc.dg/gomp/udr-2.c: New test.\n\t* gcc.dg/gomp/udr-3.c: New test.\n\t* gcc.dg/gomp/udr-4.c: New test.\n\t* gfortran.dg/gomp/appendix-a/a.35.5.f90: Add dg-error.\n\nCo-Authored-By: Richard Henderson <rth@redhat.com>\nCo-Authored-By: Tobias Burnus <burnus@net-b.de>\n\nFrom-SVN: r203408", "tree": {"sha": "2a3d60fbf15f9346c02647762dcc441fe3841855", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2a3d60fbf15f9346c02647762dcc441fe3841855"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "html_url": "https://github.com/Rust-GCC/gccrs/commit/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f7191ecdbd3adad32b561db40fac6978df6409fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7191ecdbd3adad32b561db40fac6978df6409fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f7191ecdbd3adad32b561db40fac6978df6409fe"}], "stats": {"total": 31287, "additions": 27886, "deletions": 3401}, "files": [{"sha": "07f8daf312354923fcfb2fbb54edd26231ffffa4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 242, "deletions": 0, "changes": 242, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -1,3 +1,245 @@\n+2013-10-11  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* tree-pretty-print.c (dump_omp_clause): Handle OMP_CLAUSE__LOOPTEMP_\n+\tand new OpenMP 4.0 clauses, handle UDR OMP_CLAUSE_REDUCTION,\n+\tformatting fixes, use pp_colon instead of pp_character (..., ':'),\n+\tsimilarly pp_right_paren.\n+\t(dump_generic_node): Handle OMP_DISTRIBUTE, OMP_TEAMS,\n+\tOMP_TARGET_DATA, OMP_TARGET, OMP_TARGET_UPDATE, OMP_TASKGROUP,\n+\tallow OMP_FOR_INIT to be NULL, handle OMP_ATOMIC_SEQ_CST.\n+\t* tree.c (omp_clause_num_ops, omp_clause_code_name): Add OpenMP 4.0\n+\tclauses.\n+\t(omp_declare_simd_clauses_equal,\n+\tomp_remove_redundant_declare_simd_attrs): New functions.\n+\t(attribute_value_equal): Use omp_declare_simd_clauses_equal.\n+\t(walk_tree_1): Handle new OpenMP 4.0 clauses.\n+\t* tree.h (OMP_LOOP_CHECK): Define.\n+\t(OMP_FOR_BODY, OMP_FOR_CLAUSES, OMP_FOR_INIT, OMP_FOR_COND,\n+\tOMP_FOR_INCR, OMP_FOR_PRE_BODY): Use it.\n+\t(OMP_TASKGROUP_BODY, OMP_TEAMS_BODY, OMP_TEAMS_CLAUSES,\n+\tOMP_TARGET_DATA_BODY, OMP_TARGET_DATA_CLAUSES, OMP_TARGET_BODY,\n+\tOMP_TARGET_CLAUSES, OMP_TARGET_UPDATE_CLAUSES, OMP_CLAUSE_SIZE,\n+\tOMP_ATOMIC_SEQ_CST, OMP_CLAUSE_DEPEND_KIND, OMP_CLAUSE_MAP_KIND,\n+\tOMP_CLAUSE_MAP_ZERO_BIAS_ARRAY_SECTION, OMP_CLAUSE_PROC_BIND_KIND,\n+\tOMP_CLAUSE_REDUCTION_OMP_ORIG_REF, OMP_CLAUSE_ALIGNED_ALIGNMENT,\n+\tOMP_CLAUSE_NUM_TEAMS_EXPR, OMP_CLAUSE_THREAD_LIMIT_EXPR,\n+\tOMP_CLAUSE_DEVICE_ID, OMP_CLAUSE_DIST_SCHEDULE_CHUNK_EXPR,\n+\tOMP_CLAUSE_SIMDLEN_EXPR): Define.\n+\t(OMP_CLAUSE_DECL): Change range up to OMP_CLAUSE__LOOPTEMP_.\n+\t(omp_remove_redundant_declare_simd_attrs): New prototype.\n+\t* gimple.def (GIMPLE_OMP_TASKGROUP, GIMPLE_OMP_TARGET,\n+\tGIMPLE_OMP_TEAMS): New codes.\n+\t(GIMPLE_OMP_RETURN): Use GSS_OMP_ATOMIC_STORE instead of GSS_BASE.\n+\t* omp-low.c (struct omp_context): Add cancel_label and cancellable\n+\tfields.\n+\t(target_nesting_level): New variable.\n+\t(extract_omp_for_data): Handle GF_OMP_FOR_KIND_DISTRIBUTE and\n+\tOMP_CLAUSE_DIST_SCHEDULE.  Don't fallback to library implementation\n+\tfor collapse > 1 static schedule unless ordered.\n+\t(get_ws_args_for): Add par_stmt argument.  Handle combined loops.\n+\t(determine_parallel_type): Adjust get_ws_args_for caller.\n+\t(install_var_field): Handle mask & 4 for double indirection.\n+\t(scan_sharing_clauses): Ignore shared clause on teams construct.\n+\tHandle OMP_CLAUSE__LOOPTEMP_ and new OpenMP 4.0 clauses.\n+\t(create_omp_child_function): If inside target or declare target\n+\tconstructs, set \"omp declare target\" attribute on the child\n+\tfunction.\n+\t(find_combined_for): New function.\n+\t(scan_omp_parallel): Handle combined loops.\n+\t(scan_omp_target, scan_omp_teams): New functions.\n+\t(check_omp_nesting_restrictions): Check new OpenMP 4.0 nesting\n+\trestrictions and set ctx->cancellable for cancellable constructs.\n+\t(scan_omp_1_stmt): Call check_omp_nesting_restrictions also on\n+\tselected builtin calls.  Handle GIMPLE_OMP_TASKGROUP,\n+\tGIMPLE_OMP_TARGET, GIMPLE_OMP_TEAMS.\n+\t(build_omp_barrier): Add lhs argument, return gimple rather than\n+\ttree.\n+\t(omp_clause_aligned_alignment): New function.\n+\t(lower_rec_simd_input_clauses): Only call SET_DECL_VALUE_EXPR\n+\ton decls.\n+\t(lower_rec_input_clauses): Add FD argument.  Ignore shared clauses\n+\ton teams constructs.  Handle user defined reductions and new\n+\tOpenMP 4.0 clauses.\n+\t(lower_reduction_clauses): Don't set placeholder to address of ref\n+\tif it has already the right type.\n+\t(lower_send_clauses): Handle OMP_CLAUSE__LOOPTEMP_.\n+\t(expand_parallel_call): Use the new non-_start suffixed builtins,\n+\thandle OMP_CLAUSE_PROC_BIND, don't call the outlined function\n+\tand GOMP_parallel_end after the call.\n+\t(expand_task_call): Handle OMP_CLAUSE_DEPEND.\n+\t(expand_omp_for_init_counts): Handle combined loops.\n+\t(expand_omp_for_init_vars): Add inner_stmt argument, handle combined\n+\tloops.\n+\t(expand_omp_for_generic): Likewise.  Use GOMP_loop_end_cancel at the\n+\tend of cancellable loops.\n+\t(expand_omp_for_static_nochunk, expand_omp_for_static_chunk):\n+\tLikewise.  Handle collapse > 1 loops.\n+\t(expand_omp_simd): Handle combined loops.\n+\t(expand_omp_for): Add inner_stmt argument, adjust callers of\n+\texpand_omp_for* functions, use expand_omp_for_static*chunk even\n+\tfor collapse > 1 unless ordered.\n+\t(expand_omp_sections): Use GOMP_sections_end_cancel at the end\n+\tof cancellable sections.\n+\t(expand_omp_single): Remove need_barrier variable, just rely on\n+\tgimple_omp_return_nowait_p.  Adjust build_omp_barrier caller.\n+\t(expand_omp_synch): Allow GIMPLE_OMP_TASKGROUP and GIMPLE_OMP_TEAMS.\n+\t(expand_omp_atomic_load, expand_omp_atomic_store,\n+\texpand_omp_atomic_fetch_op): Handle gimple_omp_atomic_seq_cst_p.\n+\t(expand_omp_target): New function.\n+\t(expand_omp): Handle combined loops.  Handle GIMPLE_OMP_TASKGROUP,\n+\tGIMPLE_OMP_TEAMS, GIMPLE_OMP_TARGET.\n+\t(build_omp_regions_1): Immediately close region for\n+\tGF_OMP_TARGET_KIND_UPDATE.\n+\t(maybe_add_implicit_barrier_cancel): New function.\n+\t(lower_omp_sections): Adjust lower_rec_input_clauses caller.  Handle\n+\tcancellation.\n+\t(lower_omp_single): Likewise.  Add clobber after the barrier.\n+\t(lower_omp_taskgroup): New function.\n+\t(lower_omp_for): Handle combined loops.  Adjust\n+\tlower_rec_input_clauses caller.  Handle cancellation.\n+\t(lower_depend_clauses): New function.\n+\t(lower_omp_taskreg): Lower depend clauses.  Adjust\n+\tlower_rec_input_clauses caller.  Add clobber after the call.  Handle\n+\tcancellation.\n+\t(lower_omp_target, lower_omp_teams): New functions.\n+\t(lower_omp_1): Handle cancellation.  Handle GIMPLE_OMP_TASKGROUP,\n+\tGIMPLE_OMP_TARGET, GIMPLE_OMP_TEAMS and GOMP_barrier, GOMP_cancel\n+\tand GOMP_cancellation_point calls.\n+\t(lower_omp): Fold stmts inside of target region.\n+\t(diagnose_sb_1, diagnose_sb_2): Handle GIMPLE_OMP_TASKGROUP,\n+\tGIMPLE_OMP_TARGET and GIMPLE_OMP_TEAMS.\n+\t* builtin-types.def (DEF_FUNCTION_TYPE_8): Document.\n+\t(BT_FN_VOID_OMPFN_PTR_UINT,\n+\tBT_FN_VOID_OMPFN_PTR_UINT_LONG_LONG_LONG,\n+\tBT_FN_VOID_OMPFN_PTR_UINT_LONG_LONG_LONG_LONG,\n+\tBT_FN_VOID_OMPFN_PTR_OMPCPYFN_LONG_LONG_BOOL_UINT): Remove.\n+\t(BT_FN_VOID_OMPFN_PTR_UINT_UINT_UINT,\n+\tBT_FN_VOID_OMPFN_PTR_UINT_LONG_LONG_LONG_UINT,\n+\tBT_FN_VOID_OMPFN_PTR_UINT_LONG_LONG_LONG_LONG_UINT,\n+\tBT_FN_BOOL_INT, BT_FN_BOOL_INT_BOOL, BT_FN_VOID_UINT_UINT,\n+\tBT_FN_VOID_INT_PTR_SIZE_PTR_PTR_PTR,\n+\tBT_FN_VOID_INT_OMPFN_PTR_SIZE_PTR_PTR_PTR,\n+\tBT_FN_VOID_OMPFN_PTR_OMPCPYFN_LONG_LONG_BOOL_UINT_PTR): New.\n+\t* tree-ssa-alias.c (ref_maybe_used_by_call_p_1,\n+\tcall_may_clobber_ref_p_1): Handle BUILT_IN_GOMP_BARRIER_CANCEL,\n+\tBUILT_IN_GOMP_TASKGROUP_END, BUILT_IN_GOMP_LOOP_END_CANCEL,\n+\tBUILT_IN_GOMP_SECTIONS_END_CANCEL.  Don't handle\n+\tBUILT_IN_GOMP_PARALLEL_END.\n+\t* gimple-low.c (lower_stmt): Handle GIMPLE_OMP_TASKGROUP,\n+\tGIMPLE_OMP_TARGET and GIMPLE_OMP_TEAMS.\n+\t* gimple-pretty-print.c (dump_gimple_omp_for): Handle\n+\tGF_OMP_FOR_KIND_DISTRIBUTE.\n+\t(dump_gimple_omp_target, dump_gimple_omp_teams): New functions.\n+\t(dump_gimple_omp_block): Handle GIMPLE_OMP_TASKGROUP.\n+\t(dump_gimple_omp_return): Print lhs if it has any.\n+\t(dump_gimple_omp_atomic_load, dump_gimple_omp_atomic_store): Handle\n+\tgimple_omp_atomic_seq_cst_p.\n+\t(pp_gimple_stmt_1): Handle GIMPLE_OMP_TASKGROUP, GIMPLE_OMP_TARGET\n+\tand GIMPLE_OMP_TEAMS.\n+\t* langhooks.c (lhd_omp_mappable_type): New function.\n+\t* tree-vectorizer.c (struct simd_array_to_simduid): Fix up comment.\n+\t* langhooks.h (struct lang_hooks_for_types): Add omp_mappable_type\n+\thook.\n+\t* gimplify.c (enum gimplify_omp_var_data): Add GOVD_MAP,\n+\tGOVD_ALIGNED and GOVD_MAP_TO_ONLY.\n+\t(enum omp_region_type): Add ORT_TEAMS, ORT_TARGET_DATA and\n+\tORT_TARGET.\n+\t(struct gimplify_omp_ctx): Add combined_loop field.\n+\t(gimplify_call_expr, gimplify_modify_expr): Don't call fold_stmt\n+\ton stmts inside of target region.\n+\t(is_gimple_stmt): Return true for OMP_DISTRIBUTE and OMP_TASKGROUP.\n+\t(omp_firstprivatize_variable): Handle GOVD_MAP, GOVD_ALIGNED,\n+\tORT_TARGET and ORT_TARGET_DATA.\n+\t(omp_add_variable): Avoid checks on readding var for GOVD_ALIGNED.\n+\tHandle GOVD_MAP.\n+\t(omp_notice_threadprivate_variable): Complain about threadprivate\n+\tvariables in target region.\n+\t(omp_notice_variable): Complain about vars with non-mappable type\n+\tin target region.  Handle ORT_TEAMS, ORT_TARGET and ORT_TARGET_DATA.\n+\t(omp_check_private): Ignore ORT_TARGET* regions.\n+\t(gimplify_scan_omp_clauses, gimplify_adjust_omp_clauses_1,\n+\tgimplify_adjust_omp_clauses): Handle new OpenMP 4.0 clauses.\n+\t(find_combined_omp_for): New function.\n+\t(gimplify_omp_for): Handle gimplification of combined loops.\n+\t(gimplify_omp_workshare): Gimplify also OMP_TARGET, OMP_TARGET_DATA,\n+\tOMP_TEAMS.\n+\t(gimplify_omp_target_update): New function.\n+\t(gimplify_omp_atomic): Handle OMP_ATOMIC_SEQ_CST.\n+\t(gimplify_expr): Handle OMP_DISTRIBUTE, OMP_TARGET, OMP_TARGET_DATA,\n+\tOMP_TARGET_UPDATE, OMP_TEAMS, OMP_TASKGROUP.\n+\t(gimplify_body): If fndecl has \"omp declare target\" attribute, add\n+\timplicit ORT_TARGET context around it.\n+\t* tree.def (OMP_DISTRIBUTE, OMP_TEAMS, OMP_TARGET_DATA, OMP_TARGET,\n+\tOMP_TASKGROUP, OMP_TARGET_UPDATE): New tree codes.\n+\t* tree-nested.c (convert_nonlocal_reference_stmt,\n+\tconvert_local_reference_stmt, convert_gimple_call): Handle\n+\tGIMPLE_OMP_TARGET, GIMPLE_OMP_TEAMS and GIMPLE_OMP_TASKGROUP.\n+\t* omp-builtins.def (BUILT_IN_GOMP_TASK): Use\n+\tBT_FN_VOID_OMPFN_PTR_OMPCPYFN_LONG_LONG_BOOL_UINT_PTR\n+\tinstead of BT_FN_VOID_OMPFN_PTR_OMPCPYFN_LONG_LONG_BOOL_UINT.\n+\t(BUILT_IN_GOMP_TARGET, BUILT_IN_GOMP_TARGET_DATA,\n+\tBUILT_IN_GOMP_TARGET_END_DATA, BUILT_IN_GOMP_TARGET_UPDATE,\n+\tBUILT_IN_GOMP_TEAMS, BUILT_IN_BARRIER_CANCEL,\n+\tBUILT_IN_GOMP_LOOP_END_CANCEL,\n+\tBUILT_IN_GOMP_SECTIONS_END_CANCEL, BUILT_IN_OMP_GET_TEAM_NUM,\n+\tBUILT_IN_OMP_GET_NUM_TEAMS, BUILT_IN_GOMP_TASKGROUP_START,\n+\tBUILT_IN_GOMP_TASKGROUP_END, BUILT_IN_GOMP_PARALLEL_LOOP_STATIC,\n+\tBUILT_IN_GOMP_PARALLEL_LOOP_DYNAMIC,\n+\tBUILT_IN_GOMP_PARALLEL_LOOP_GUIDED,\n+\tBUILT_IN_GOMP_PARALLEL_LOOP_RUNTIME, BUILT_IN_GOMP_PARALLEL,\n+\tBUILT_IN_GOMP_PARALLEL_SECTIONS, BUILT_IN_GOMP_CANCEL,\n+\tBUILT_IN_GOMP_CANCELLATION_POINT): New built-ins.\n+\t(BUILT_IN_GOMP_PARALLEL_LOOP_STATIC_START,\n+\tBUILT_IN_GOMP_PARALLEL_LOOP_DYNAMIC_START,\n+\tBUILT_IN_GOMP_PARALLEL_LOOP_GUIDED_START,\n+\tBUILT_IN_GOMP_PARALLEL_LOOP_RUNTIME_START,\n+\tBUILT_IN_GOMP_PARALLEL_START, BUILT_IN_GOMP_PARALLEL_END,\n+\tBUILT_IN_GOMP_PARALLEL_SECTIONS_START): Remove.\n+\t* tree-inline.c (remap_gimple_stmt, estimate_num_insns):\n+\tHandle GIMPLE_OMP_TARGET, GIMPLE_OMP_TEAMS and GIMPLE_OMP_TASKGROUP.\n+\t* gimple.c (gimple_build_omp_taskgroup, gimple_build_omp_target,\n+\tgimple_build_omp_teams): New functions.\n+\t(walk_gimple_op): Handle GIMPLE_OMP_TARGET, GIMPLE_OMP_TEAMS and\n+\tGIMPLE_OMP_TASKGROUP.  Walk optional lhs on GIMPLE_OMP_RETURN.\n+\t(walk_gimple_stmt, gimple_copy): Handle GIMPLE_OMP_TARGET,\n+\tGIMPLE_OMP_TEAMS and GIMPLE_OMP_TASKGROUP.\n+\t* gimple.h (enum gf_mask): GF_OMP_FOR_KIND_DISTRIBUTE,\n+\tGF_OMP_FOR_COMBINED, GF_OMP_FOR_COMBINED_INTO,\n+\tGF_OMP_TARGET_KIND_MASK, GF_OMP_TARGET_KIND_REGION,\n+\tGF_OMP_TARGET_KIND_DATA, GF_OMP_TARGET_KIND_UPDATE,\n+\tGF_OMP_ATOMIC_SEQ_CST): New.\n+\t(gimple_build_omp_taskgroup, gimple_build_omp_target,\n+\tgimple_build_omp_teams): New prototypes.\n+\t(gimple_has_substatements): Handle GIMPLE_OMP_TARGET,\n+\tGIMPLE_OMP_TEAMS and GIMPLE_OMP_TASKGROUP.\n+\t(gimple_omp_subcode): Use GIMPLE_OMP_TEAMS instead of\n+\tGIMPLE_OMP_SINGLE as end of range.\n+\t(gimple_omp_return_set_lhs, gimple_omp_return_lhs,\n+\tgimple_omp_return_lhs_ptr, gimple_omp_atomic_seq_cst_p,\n+\tgimple_omp_atomic_set_seq_cst, gimple_omp_for_combined_p,\n+\tgimple_omp_for_set_combined_p, gimple_omp_for_combined_into_p,\n+\tgimple_omp_for_set_combined_into_p, gimple_omp_target_clauses,\n+\tgimple_omp_target_clauses_ptr, gimple_omp_target_set_clauses,\n+\tgimple_omp_target_kind, gimple_omp_target_set_kind,\n+\tgimple_omp_target_child_fn, gimple_omp_target_child_fn_ptr,\n+\tgimple_omp_target_set_child_fn, gimple_omp_target_data_arg,\n+\tgimple_omp_target_data_arg_ptr, gimple_omp_target_set_data_arg,\n+\tgimple_omp_teams_clauses, gimple_omp_teams_clauses_ptr,\n+\tgimple_omp_teams_set_clauses): New inlines.\n+\t(CASE_GIMPLE_OMP): Add GIMPLE_OMP_TARGET, GIMPLE_OMP_TEAMS\n+\tand GIMPLE_OMP_TASKGROUP.\n+\t* tree-core.h (enum omp_clause_code): Add new OpenMP 4.0 clause\n+\tcodes.\n+\t(enum omp_clause_depend_kind, enum omp_clause_map_kind,\n+\tenum omp_clause_proc_bind_kind): New.\n+\t(union omp_clause_subcode): Add depend_kind, map_kind and\n+\tproc_bind_kind fields.\n+\t* tree-cfg.c (make_edges): Handle GIMPLE_OMP_TARGET,\n+\tGIMPLE_OMP_TEAMS and GIMPLE_OMP_TASKGROUP.\n+\t* langhooks-def.h (lhd_omp_mappable_type): New prototype.\n+\t(LANG_HOOKS_OMP_MAPPABLE_TYPE): Define.\n+\t(LANG_HOOKS_FOR_TYPES_INITIALIZER): Add it.\n+\n 2013-10-10  Teresa Johnson  <tejohnson@google.com>\n \n \t* predict.c (tree_estimate_probability): Add new parameter"}, {"sha": "2ed3e37f8bfa3ba3ace533e6e3db3577515db382", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -1,3 +1,7 @@\n+2013-10-11  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* gcc-interface/utils.c (DEF_FUNCTION_TYPE_8): Define.\n+\n 2013-10-10  Robert Dewar  <dewar@adacore.com>\n \n \t* par-ch6.adb (Check_Junk_Semicolon_Before_Return): Remove"}, {"sha": "210b0921107e86af89c149d2496d2070dffd12cf", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -5765,6 +5765,7 @@ enum c_builtin_type\n #define DEF_FUNCTION_TYPE_5(NAME, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5) NAME,\n #define DEF_FUNCTION_TYPE_6(NAME, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6) NAME,\n #define DEF_FUNCTION_TYPE_7(NAME, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7) NAME,\n+#define DEF_FUNCTION_TYPE_8(NAME, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8) NAME,\n #define DEF_FUNCTION_TYPE_VAR_0(NAME, RETURN) NAME,\n #define DEF_FUNCTION_TYPE_VAR_1(NAME, RETURN, ARG1) NAME,\n #define DEF_FUNCTION_TYPE_VAR_2(NAME, RETURN, ARG1, ARG2) NAME,\n@@ -5783,6 +5784,7 @@ enum c_builtin_type\n #undef DEF_FUNCTION_TYPE_5\n #undef DEF_FUNCTION_TYPE_6\n #undef DEF_FUNCTION_TYPE_7\n+#undef DEF_FUNCTION_TYPE_8\n #undef DEF_FUNCTION_TYPE_VAR_0\n #undef DEF_FUNCTION_TYPE_VAR_1\n #undef DEF_FUNCTION_TYPE_VAR_2\n@@ -5878,6 +5880,10 @@ install_builtin_function_types (void)\n #define DEF_FUNCTION_TYPE_7(ENUM, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, \\\n \t\t\t    ARG6, ARG7)\t\t\t\t\t\\\n   def_fn_type (ENUM, RETURN, 0, 7, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7);\n+#define DEF_FUNCTION_TYPE_8(ENUM, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, \\\n+\t\t\t    ARG6, ARG7, ARG8)\t\t\t\t\\\n+  def_fn_type (ENUM, RETURN, 0, 8, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6,\t\\\n+\t       ARG7, ARG8);\n #define DEF_FUNCTION_TYPE_VAR_0(ENUM, RETURN) \\\n   def_fn_type (ENUM, RETURN, 1, 0);\n #define DEF_FUNCTION_TYPE_VAR_1(ENUM, RETURN, ARG1) \\"}, {"sha": "3deedba5b784ef916b42803c5758e0308fa91274", "filename": "gcc/builtin-types.def", "status": "modified", "additions": 23, "deletions": 12, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Fbuiltin-types.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Fbuiltin-types.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltin-types.def?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -34,6 +34,8 @@ along with GCC; see the file COPYING3.  If not see\n    DEF_FUNCTION_TYPE_5 (ENUM, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5)\n    DEF_FUNCTION_TYPE_6 (ENUM, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6)\n    DEF_FUNCTION_TYPE_7 (ENUM, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7)\n+   DEF_FUNCTION_TYPE_8 (ENUM, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7,\n+\t\t\tARG8)\n \n      These macros describe function types.  ENUM is as above.  The\n      RETURN type is one of the enumerals already defined.  ARG1, ARG2,\n@@ -230,6 +232,7 @@ DEF_FUNCTION_TYPE_1 (BT_FN_ULONGLONG_ULONGLONG, BT_ULONGLONG, BT_ULONGLONG)\n DEF_FUNCTION_TYPE_1 (BT_FN_UINT16_UINT16, BT_UINT16, BT_UINT16)\n DEF_FUNCTION_TYPE_1 (BT_FN_UINT32_UINT32, BT_UINT32, BT_UINT32)\n DEF_FUNCTION_TYPE_1 (BT_FN_UINT64_UINT64, BT_UINT64, BT_UINT64)\n+DEF_FUNCTION_TYPE_1 (BT_FN_BOOL_INT, BT_BOOL, BT_INT)\n \n DEF_POINTER_TYPE (BT_PTR_FN_VOID_PTR, BT_FN_VOID_PTR)\n \n@@ -341,6 +344,8 @@ DEF_FUNCTION_TYPE_2 (BT_FN_VOID_VPTR_INT, BT_VOID, BT_VOLATILE_PTR, BT_INT)\n DEF_FUNCTION_TYPE_2 (BT_FN_BOOL_VPTR_INT, BT_BOOL, BT_VOLATILE_PTR, BT_INT)\n DEF_FUNCTION_TYPE_2 (BT_FN_BOOL_SIZE_CONST_VPTR, BT_BOOL, BT_SIZE,\n \t\t     BT_CONST_VOLATILE_PTR)\n+DEF_FUNCTION_TYPE_2 (BT_FN_BOOL_INT_BOOL, BT_BOOL, BT_INT, BT_BOOL)\n+DEF_FUNCTION_TYPE_2 (BT_FN_VOID_UINT_UINT, BT_VOID, BT_UINT, BT_UINT)\n \n DEF_POINTER_TYPE (BT_PTR_FN_VOID_PTR_PTR, BT_FN_VOID_PTR_PTR)\n \n@@ -411,8 +416,6 @@ DEF_FUNCTION_TYPE_3 (BT_FN_I4_VPTR_I4_I4, BT_I4, BT_VOLATILE_PTR, BT_I4, BT_I4)\n DEF_FUNCTION_TYPE_3 (BT_FN_I8_VPTR_I8_I8, BT_I8, BT_VOLATILE_PTR, BT_I8, BT_I8)\n DEF_FUNCTION_TYPE_3 (BT_FN_I16_VPTR_I16_I16, BT_I16, BT_VOLATILE_PTR,\n \t\t     BT_I16, BT_I16)\n-DEF_FUNCTION_TYPE_3 (BT_FN_VOID_OMPFN_PTR_UINT, BT_VOID, BT_PTR_FN_VOID_PTR,\n-\t\t     BT_PTR, BT_UINT)\n DEF_FUNCTION_TYPE_3 (BT_FN_PTR_CONST_PTR_INT_SIZE, BT_PTR,\n \t\t     BT_CONST_PTR, BT_INT, BT_SIZE)\n DEF_FUNCTION_TYPE_3 (BT_FN_I1_VPTR_I1_INT, BT_I1, BT_VOLATILE_PTR, BT_I1, BT_INT)\n@@ -467,16 +470,16 @@ DEF_FUNCTION_TYPE_5 (BT_FN_BOOL_VPTR_PTR_I8_INT_INT,\n \t\t     BT_BOOL, BT_VOLATILE_PTR, BT_PTR, BT_I8, BT_INT, BT_INT)\n DEF_FUNCTION_TYPE_5 (BT_FN_BOOL_VPTR_PTR_I16_INT_INT,\n \t\t     BT_BOOL, BT_VOLATILE_PTR, BT_PTR, BT_I16, BT_INT, BT_INT)\n+DEF_FUNCTION_TYPE_5 (BT_FN_VOID_OMPFN_PTR_UINT_UINT_UINT,\n+\t\t     BT_VOID, BT_PTR_FN_VOID_PTR, BT_PTR, BT_UINT, BT_UINT,\n+\t\t     BT_UINT)\n \n DEF_FUNCTION_TYPE_6 (BT_FN_INT_STRING_SIZE_INT_SIZE_CONST_STRING_VALIST_ARG,\n \t\t     BT_INT, BT_STRING, BT_SIZE, BT_INT, BT_SIZE,\n \t\t     BT_CONST_STRING, BT_VALIST_ARG)\n DEF_FUNCTION_TYPE_6 (BT_FN_BOOL_LONG_LONG_LONG_LONG_LONGPTR_LONGPTR,\n \t\t     BT_BOOL, BT_LONG, BT_LONG, BT_LONG, BT_LONG,\n \t\t     BT_PTR_LONG, BT_PTR_LONG)\n-DEF_FUNCTION_TYPE_6 (BT_FN_VOID_OMPFN_PTR_UINT_LONG_LONG_LONG,\n-\t\t     BT_VOID, BT_PTR_FN_VOID_PTR, BT_PTR, BT_UINT,\n-\t\t     BT_LONG, BT_LONG, BT_LONG)\n DEF_FUNCTION_TYPE_6 (BT_FN_BOOL_BOOL_ULL_ULL_ULL_ULLPTR_ULLPTR,\n \t\t     BT_BOOL, BT_BOOL, BT_ULONGLONG, BT_ULONGLONG,\n \t\t     BT_ULONGLONG, BT_PTR_ULONGLONG, BT_PTR_ULONGLONG)\n@@ -497,19 +500,27 @@ DEF_FUNCTION_TYPE_6 (BT_FN_BOOL_VPTR_PTR_I16_BOOL_INT_INT,\n \t\t     BT_INT)\n DEF_FUNCTION_TYPE_6 (BT_FN_BOOL_SIZE_VPTR_PTR_PTR_INT_INT, BT_BOOL, BT_SIZE,\n \t\t     BT_VOLATILE_PTR, BT_PTR, BT_PTR, BT_INT, BT_INT)\n+DEF_FUNCTION_TYPE_6 (BT_FN_VOID_INT_PTR_SIZE_PTR_PTR_PTR,\n+\t\t     BT_VOID, BT_INT, BT_PTR, BT_SIZE, BT_PTR, BT_PTR, BT_PTR)\n \n-\n-DEF_FUNCTION_TYPE_7 (BT_FN_VOID_OMPFN_PTR_UINT_LONG_LONG_LONG_LONG,\n+DEF_FUNCTION_TYPE_7 (BT_FN_VOID_OMPFN_PTR_UINT_LONG_LONG_LONG_UINT,\n \t\t     BT_VOID, BT_PTR_FN_VOID_PTR, BT_PTR, BT_UINT,\n-\t\t     BT_LONG, BT_LONG, BT_LONG, BT_LONG)\n-DEF_FUNCTION_TYPE_7 (BT_FN_VOID_OMPFN_PTR_OMPCPYFN_LONG_LONG_BOOL_UINT,\n-\t\t     BT_VOID, BT_PTR_FN_VOID_PTR, BT_PTR,\n-\t\t     BT_PTR_FN_VOID_PTR_PTR, BT_LONG, BT_LONG,\n-\t\t     BT_BOOL, BT_UINT)\n+\t\t     BT_LONG, BT_LONG, BT_LONG, BT_UINT)\n DEF_FUNCTION_TYPE_7 (BT_FN_BOOL_BOOL_ULL_ULL_ULL_ULL_ULLPTR_ULLPTR,\n \t\t     BT_BOOL, BT_BOOL, BT_ULONGLONG, BT_ULONGLONG,\n \t\t     BT_ULONGLONG, BT_ULONGLONG,\n \t\t     BT_PTR_ULONGLONG, BT_PTR_ULONGLONG)\n+DEF_FUNCTION_TYPE_7 (BT_FN_VOID_INT_OMPFN_PTR_SIZE_PTR_PTR_PTR,\n+\t\t     BT_VOID, BT_INT, BT_PTR_FN_VOID_PTR, BT_PTR, BT_SIZE,\n+\t\t     BT_PTR, BT_PTR, BT_PTR)\n+\n+DEF_FUNCTION_TYPE_8 (BT_FN_VOID_OMPFN_PTR_UINT_LONG_LONG_LONG_LONG_UINT,\n+\t\t     BT_VOID, BT_PTR_FN_VOID_PTR, BT_PTR, BT_UINT,\n+\t\t     BT_LONG, BT_LONG, BT_LONG, BT_LONG, BT_UINT)\n+DEF_FUNCTION_TYPE_8 (BT_FN_VOID_OMPFN_PTR_OMPCPYFN_LONG_LONG_BOOL_UINT_PTR,\n+\t\t     BT_VOID, BT_PTR_FN_VOID_PTR, BT_PTR,\n+\t\t     BT_PTR_FN_VOID_PTR_PTR, BT_LONG, BT_LONG,\n+\t\t     BT_BOOL, BT_UINT, BT_PTR)\n \n DEF_FUNCTION_TYPE_VAR_0 (BT_FN_VOID_VAR, BT_VOID)\n DEF_FUNCTION_TYPE_VAR_0 (BT_FN_INT_VAR, BT_INT)"}, {"sha": "5febbe5e7351eff5f33c2b2969d75ae8c2db1fdf", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -1,3 +1,55 @@\n+2013-10-11  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* c-cppbuiltin.c (c_cpp_builtins): Predefine _OPENMP to\n+\t201307 instead of 201107.\n+\t* c-common.c (DEF_FUNCTION_TYPE_8): Define.\n+\t(c_common_attribute_table): Add \"omp declare target\" and\n+\t\"omp declare simd\" attributes.\n+\t(handle_omp_declare_target_attribute,\n+\thandle_omp_declare_simd_attribute): New functions.\n+\t* c-omp.c: Include c-pragma.h.\n+\t(c_finish_omp_taskgroup): New function.\n+\t(c_finish_omp_atomic): Add swapped argument, if true,\n+\tbuild the operation first with rhs, lhs arguments and use NOP_EXPR\n+\tbuild_modify_expr.\n+\t(c_finish_omp_for): Add code argument, pass it down to make_code.\n+\t(c_omp_split_clauses): New function.\n+\t(c_split_parallel_clauses): Removed.\n+\t(c_omp_declare_simd_clause_cmp, c_omp_declare_simd_clauses_to_numbers,\n+\tc_omp_declare_simd_clauses_to_decls): New functions.\n+\t* c-common.h (omp_clause_mask): New type.\n+\t(OMP_CLAUSE_MASK_1): Define.\n+\t(omp_clause_mask::omp_clause_mask, omp_clause_mask::operator &=,\n+\tomp_clause_mask::operator |=, omp_clause_mask::operator ~,\n+\tomp_clause_mask::operator |, omp_clause_mask::operator &,\n+\tomp_clause_mask::operator <<, omp_clause_mask::operator >>,\n+\tomp_clause_mask::operator ==): New methods.\n+\t(enum c_omp_clause_split): New.\n+\t(c_finish_omp_taskgroup): New prototype.\n+\t(c_finish_omp_atomic): Add swapped argument.\n+\t(c_finish_omp_for): Add code argument.\n+\t(c_omp_split_clauses): New prototype.\n+\t(c_split_parallel_clauses): Removed.\n+\t(c_omp_declare_simd_clauses_to_numbers,\n+\tc_omp_declare_simd_clauses_to_decls): New prototypes.\n+\t* c-pragma.c (omp_pragmas): Add new OpenMP 4.0 constructs.\n+\t* c-pragma.h (enum pragma_kind): Add PRAGMA_OMP_CANCEL,\n+\tPRAGMA_OMP_CANCELLATION_POINT, PRAGMA_OMP_DECLARE_REDUCTION,\n+\tPRAGMA_OMP_DISTRIBUTE, PRAGMA_OMP_END_DECLARE_TARGET, PRAGMA_OMP_SIMD,\n+\tPRAGMA_OMP_TARGET, PRAGMA_OMP_TASKGROUP and PRAGMA_OMP_TEAMS.\n+\tRemove PRAGMA_OMP_PARALLEL_FOR and PRAGMA_OMP_PARALLEL_SECTIONS.\n+\t(enum pragma_omp_clause): Add PRAGMA_OMP_CLAUSE_ALIGNED,\n+\tPRAGMA_OMP_CLAUSE_DEPEND, PRAGMA_OMP_CLAUSE_DEVICE,\n+\tPRAGMA_OMP_CLAUSE_DIST_SCHEDULE, PRAGMA_OMP_CLAUSE_FOR,\n+\tPRAGMA_OMP_CLAUSE_FROM, PRAGMA_OMP_CLAUSE_INBRANCH,\n+\tPRAGMA_OMP_CLAUSE_LINEAR, PRAGMA_OMP_CLAUSE_MAP,\n+\tPRAGMA_OMP_CLAUSE_NOTINBRANCH, PRAGMA_OMP_CLAUSE_NUM_TEAMS,\n+\tPRAGMA_OMP_CLAUSE_PARALLEL, PRAGMA_OMP_CLAUSE_PROC_BIND,\n+\tPRAGMA_OMP_CLAUSE_SAFELEN, PRAGMA_OMP_CLAUSE_SECTIONS,\n+\tPRAGMA_OMP_CLAUSE_SIMDLEN, PRAGMA_OMP_CLAUSE_TASKGROUP,\n+\tPRAGMA_OMP_CLAUSE_THREAD_LIMIT, PRAGMA_OMP_CLAUSE_TO and\n+\tPRAGMA_OMP_CLAUSE_UNIFORM.\n+\n 2013-10-09  Marc Glisse  <marc.glisse@inria.fr>\n \n \tPR tree-optimization/20318"}, {"sha": "5fd7b855115961c9035a4c2aa091b58b778ac33a", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -372,6 +372,10 @@ static tree handle_no_split_stack_attribute (tree *, tree, tree, int, bool *);\n static tree handle_fnspec_attribute (tree *, tree, tree, int, bool *);\n static tree handle_warn_unused_attribute (tree *, tree, tree, int, bool *);\n static tree handle_returns_nonnull_attribute (tree *, tree, tree, int, bool *);\n+static tree handle_omp_declare_simd_attribute (tree *, tree, tree, int,\n+\t\t\t\t\t       bool *);\n+static tree handle_omp_declare_target_attribute (tree *, tree, tree, int,\n+\t\t\t\t\t\t bool *);\n \n static void check_function_nonnull (tree, int, tree *);\n static void check_nonnull_arg (void *, tree, unsigned HOST_WIDE_INT);\n@@ -750,6 +754,10 @@ const struct attribute_spec c_common_attribute_table[] =\n \t\t\t      handle_warn_unused_attribute, false },\n   { \"returns_nonnull\",        0, 0, false, true, true,\n \t\t\t      handle_returns_nonnull_attribute, false },\n+  { \"omp declare simd\",       0, -1, true,  false, false,\n+\t\t\t      handle_omp_declare_simd_attribute, false },\n+  { \"omp declare target\",     0, 0, true, false, false,\n+\t\t\t      handle_omp_declare_target_attribute, false },\n   { NULL,                     0, 0, false, false, false, NULL, false }\n };\n \n@@ -5057,6 +5065,7 @@ enum c_builtin_type\n #define DEF_FUNCTION_TYPE_5(NAME, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5) NAME,\n #define DEF_FUNCTION_TYPE_6(NAME, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6) NAME,\n #define DEF_FUNCTION_TYPE_7(NAME, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7) NAME,\n+#define DEF_FUNCTION_TYPE_8(NAME, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8) NAME,\n #define DEF_FUNCTION_TYPE_VAR_0(NAME, RETURN) NAME,\n #define DEF_FUNCTION_TYPE_VAR_1(NAME, RETURN, ARG1) NAME,\n #define DEF_FUNCTION_TYPE_VAR_2(NAME, RETURN, ARG1, ARG2) NAME,\n@@ -5075,6 +5084,7 @@ enum c_builtin_type\n #undef DEF_FUNCTION_TYPE_5\n #undef DEF_FUNCTION_TYPE_6\n #undef DEF_FUNCTION_TYPE_7\n+#undef DEF_FUNCTION_TYPE_8\n #undef DEF_FUNCTION_TYPE_VAR_0\n #undef DEF_FUNCTION_TYPE_VAR_1\n #undef DEF_FUNCTION_TYPE_VAR_2\n@@ -5157,6 +5167,10 @@ c_define_builtins (tree va_list_ref_type_node, tree va_list_arg_type_node)\n #define DEF_FUNCTION_TYPE_7(ENUM, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, \\\n \t\t\t    ARG6, ARG7)\t\t\t\t\t\\\n   def_fn_type (ENUM, RETURN, 0, 7, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7);\n+#define DEF_FUNCTION_TYPE_8(ENUM, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, \\\n+\t\t\t    ARG6, ARG7, ARG8)\t\t\t\t\\\n+  def_fn_type (ENUM, RETURN, 0, 8, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6,\t\\\n+\t       ARG7, ARG8);\n #define DEF_FUNCTION_TYPE_VAR_0(ENUM, RETURN) \\\n   def_fn_type (ENUM, RETURN, 1, 0);\n #define DEF_FUNCTION_TYPE_VAR_1(ENUM, RETURN, ARG1) \\\n@@ -8024,6 +8038,24 @@ handle_warn_unused_attribute (tree *node, tree name,\n   return NULL_TREE;\n }\n \n+/* Handle an \"omp declare simd\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+handle_omp_declare_simd_attribute (tree *, tree, tree, int, bool *)\n+{\n+  return NULL_TREE;\n+}\n+\n+/* Handle an \"omp declare target\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+handle_omp_declare_target_attribute (tree *, tree, tree, int, bool *)\n+{\n+  return NULL_TREE;\n+}\n+\n /* Handle a \"returns_twice\" attribute; arguments as in\n    struct attribute_spec.handler.  */\n "}, {"sha": "2649248ed95e55a4006ab8202679295dbb8adbc2", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 145, "deletions": 3, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -1034,17 +1034,159 @@ extern void pp_dir_change (cpp_reader *, const char *);\n extern bool check_missing_format_attribute (tree, tree);\n \n /* In c-omp.c  */\n+#if HOST_BITS_PER_WIDE_INT >= 64\n+typedef unsigned HOST_WIDE_INT omp_clause_mask;\n+# define OMP_CLAUSE_MASK_1 ((omp_clause_mask) 1)\n+#else\n+struct omp_clause_mask\n+{\n+  inline omp_clause_mask ();\n+  inline omp_clause_mask (unsigned HOST_WIDE_INT l);\n+  inline omp_clause_mask (unsigned HOST_WIDE_INT l,\n+\t\t\t  unsigned HOST_WIDE_INT h);\n+  inline omp_clause_mask &operator &= (omp_clause_mask);\n+  inline omp_clause_mask &operator |= (omp_clause_mask);\n+  inline omp_clause_mask operator ~ () const;\n+  inline omp_clause_mask operator & (omp_clause_mask) const;\n+  inline omp_clause_mask operator | (omp_clause_mask) const;\n+  inline omp_clause_mask operator >> (int);\n+  inline omp_clause_mask operator << (int);\n+  inline bool operator == (omp_clause_mask) const;\n+  unsigned HOST_WIDE_INT low, high;\n+};\n+\n+inline\n+omp_clause_mask::omp_clause_mask ()\n+{\n+}\n+\n+inline\n+omp_clause_mask::omp_clause_mask (unsigned HOST_WIDE_INT l)\n+: low (l), high (0)\n+{\n+}\n+\n+inline\n+omp_clause_mask::omp_clause_mask (unsigned HOST_WIDE_INT l,\n+\t\t\t\t  unsigned HOST_WIDE_INT h)\n+: low (l), high (h)\n+{\n+}\n+\n+inline omp_clause_mask &\n+omp_clause_mask::operator &= (omp_clause_mask b)\n+{\n+  low &= b.low;\n+  high &= b.high;\n+  return *this;\n+}\n+\n+inline omp_clause_mask &\n+omp_clause_mask::operator |= (omp_clause_mask b)\n+{\n+  low |= b.low;\n+  high |= b.high;\n+  return *this;\n+}\n+\n+inline omp_clause_mask\n+omp_clause_mask::operator ~ () const\n+{\n+  omp_clause_mask ret (~low, ~high);\n+  return ret;\n+}\n+\n+inline omp_clause_mask\n+omp_clause_mask::operator | (omp_clause_mask b) const\n+{\n+  omp_clause_mask ret (low | b.low, high | b.high);\n+  return ret;\n+}\n+\n+inline omp_clause_mask\n+omp_clause_mask::operator & (omp_clause_mask b) const\n+{\n+  omp_clause_mask ret (low & b.low, high & b.high);\n+  return ret;\n+}\n+\n+inline omp_clause_mask\n+omp_clause_mask::operator << (int amount)\n+{\n+  omp_clause_mask ret;\n+  if (amount >= HOST_BITS_PER_WIDE_INT)\n+    {\n+      ret.low = 0;\n+      ret.high = low << (amount - HOST_BITS_PER_WIDE_INT);\n+    }\n+  else if (amount == 0)\n+    ret = *this;\n+  else\n+    {\n+      ret.low = low << amount;\n+      ret.high = (low >> (HOST_BITS_PER_WIDE_INT - amount))\n+\t\t | (high << amount);\n+    }\n+  return ret;\n+}\n+\n+inline omp_clause_mask\n+omp_clause_mask::operator >> (int amount)\n+{\n+  omp_clause_mask ret;\n+  if (amount >= HOST_BITS_PER_WIDE_INT)\n+    {\n+      ret.low = high >> (amount - HOST_BITS_PER_WIDE_INT);\n+      ret.high = 0;\n+    }\n+  else if (amount == 0)\n+    ret = *this;\n+  else\n+    {\n+      ret.low = (high << (HOST_BITS_PER_WIDE_INT - amount))\n+\t\t | (low >> amount);\n+      ret.high = high >> amount;\n+    }\n+  return ret;\n+}\n+\n+inline bool\n+omp_clause_mask::operator == (omp_clause_mask b) const\n+{\n+  return low == b.low && high == b.high;\n+}\n+\n+# define OMP_CLAUSE_MASK_1 omp_clause_mask (1)\n+#endif\n+\n+enum c_omp_clause_split\n+{\n+  C_OMP_CLAUSE_SPLIT_TARGET = 0,\n+  C_OMP_CLAUSE_SPLIT_TEAMS,\n+  C_OMP_CLAUSE_SPLIT_DISTRIBUTE,\n+  C_OMP_CLAUSE_SPLIT_PARALLEL,\n+  C_OMP_CLAUSE_SPLIT_FOR,\n+  C_OMP_CLAUSE_SPLIT_SIMD,\n+  C_OMP_CLAUSE_SPLIT_COUNT,\n+  C_OMP_CLAUSE_SPLIT_SECTIONS = C_OMP_CLAUSE_SPLIT_FOR\n+};\n+\n extern tree c_finish_omp_master (location_t, tree);\n+extern tree c_finish_omp_taskgroup (location_t, tree);\n extern tree c_finish_omp_critical (location_t, tree, tree);\n extern tree c_finish_omp_ordered (location_t, tree);\n extern void c_finish_omp_barrier (location_t);\n extern tree c_finish_omp_atomic (location_t, enum tree_code, enum tree_code,\n-\t\t\t\t tree, tree, tree, tree, tree);\n+\t\t\t\t tree, tree, tree, tree, tree, bool, bool);\n extern void c_finish_omp_flush (location_t);\n extern void c_finish_omp_taskwait (location_t);\n extern void c_finish_omp_taskyield (location_t);\n-extern tree c_finish_omp_for (location_t, tree, tree, tree, tree, tree, tree);\n-extern void c_split_parallel_clauses (location_t, tree, tree *, tree *);\n+extern tree c_finish_omp_for (location_t, enum tree_code, tree, tree, tree,\n+\t\t\t      tree, tree, tree);\n+extern void c_omp_split_clauses (location_t, enum tree_code, omp_clause_mask,\n+\t\t\t\t tree, tree *);\n+extern tree c_omp_declare_simd_clauses_to_numbers (tree, tree);\n+extern void c_omp_declare_simd_clauses_to_decls (tree, tree);\n extern enum omp_clause_default_kind c_omp_predetermined_sharing (tree);\n \n /* Not in c-omp.c; provided by the front end.  */"}, {"sha": "ed4c82caa4612088be699a88337f16cf442113cd", "filename": "gcc/c-family/c-cppbuiltin.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Fc-family%2Fc-cppbuiltin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Fc-family%2Fc-cppbuiltin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-cppbuiltin.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -896,7 +896,7 @@ c_cpp_builtins (cpp_reader *pfile)\n     cpp_define (pfile, \"__SSP__=1\");\n \n   if (flag_openmp)\n-    cpp_define (pfile, \"_OPENMP=201107\");\n+    cpp_define (pfile, \"_OPENMP=201307\");\n \n   if (int128_integer_type_node != NULL_TREE)\n     builtin_define_type_sizeof (\"__SIZEOF_INT128__\","}, {"sha": "dac127ed339960d186bd1f0b736448a7b2d695b8", "filename": "gcc/c-family/c-omp.c", "status": "modified", "additions": 377, "deletions": 31, "changes": 408, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Fc-family%2Fc-omp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Fc-family%2Fc-omp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-omp.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -26,6 +26,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"coretypes.h\"\n #include \"tree.h\"\n #include \"c-common.h\"\n+#include \"c-pragma.h\"\n #include \"gimple.h\"\t\t/* For create_tmp_var_raw.  */\n #include \"langhooks.h\"\n \n@@ -41,6 +42,17 @@ c_finish_omp_master (location_t loc, tree stmt)\n   return t;\n }\n \n+/* Complete a #pragma omp taskgroup construct.  STMT is the structured-block\n+   that follows the pragma.  LOC is the l*/\n+\n+tree\n+c_finish_omp_taskgroup (location_t loc, tree stmt)\n+{\n+  tree t = add_stmt (build1 (OMP_TASKGROUP, void_type_node, stmt));\n+  SET_EXPR_LOCATION (t, loc);\n+  return t;\n+}\n+\n /* Complete a #pragma omp critical construct.  STMT is the structured-block\n    that follows the pragma, NAME is the identifier in the pragma, or null\n    if it was omitted.  LOC is the location of the #pragma.  */\n@@ -122,7 +134,7 @@ c_finish_omp_taskyield (location_t loc)\n tree\n c_finish_omp_atomic (location_t loc, enum tree_code code,\n \t\t     enum tree_code opcode, tree lhs, tree rhs,\n-\t\t     tree v, tree lhs1, tree rhs1)\n+\t\t     tree v, tree lhs1, tree rhs1, bool swapped, bool seq_cst)\n {\n   tree x, type, addr;\n \n@@ -168,6 +180,7 @@ c_finish_omp_atomic (location_t loc, enum tree_code code,\n     {\n       x = build1 (OMP_ATOMIC_READ, type, addr);\n       SET_EXPR_LOCATION (x, loc);\n+      OMP_ATOMIC_SEQ_CST (x) = seq_cst;\n       return build_modify_expr (loc, v, NULL_TREE, NOP_EXPR,\n \t\t\t\tloc, x, NULL_TREE);\n       return x;\n@@ -176,8 +189,12 @@ c_finish_omp_atomic (location_t loc, enum tree_code code,\n   /* There are lots of warnings, errors, and conversions that need to happen\n      in the course of interpreting a statement.  Use the normal mechanisms\n      to do this, and then take it apart again.  */\n-  x = build_modify_expr (input_location, lhs, NULL_TREE, opcode,\n-      \t\t\t input_location, rhs, NULL_TREE);\n+  if (swapped)\n+    {\n+      rhs = build2_loc (loc, opcode, TREE_TYPE (lhs), rhs, lhs);\n+      opcode = NOP_EXPR;\n+    }\n+  x = build_modify_expr (loc, lhs, NULL_TREE, opcode, loc, rhs, NULL_TREE);\n   if (x == error_mark_node)\n     return error_mark_node;\n   gcc_assert (TREE_CODE (x) == MODIFY_EXPR);\n@@ -188,6 +205,7 @@ c_finish_omp_atomic (location_t loc, enum tree_code code,\n     type = void_type_node;\n   x = build2 (code, type, addr, rhs);\n   SET_EXPR_LOCATION (x, loc);\n+  OMP_ATOMIC_SEQ_CST (x) = seq_cst;\n \n   /* Generally it is hard to prove lhs1 and lhs are the same memory\n      location, just diagnose different variables.  */\n@@ -339,8 +357,8 @@ check_omp_for_incr_expr (location_t loc, tree exp, tree decl)\n    the loop.  */\n \n tree\n-c_finish_omp_for (location_t locus, tree declv, tree initv, tree condv,\n-\t\t  tree incrv, tree body, tree pre_body)\n+c_finish_omp_for (location_t locus, enum tree_code code, tree declv,\n+\t\t  tree initv, tree condv, tree incrv, tree body, tree pre_body)\n {\n   location_t elocus;\n   bool fail = false;\n@@ -565,7 +583,7 @@ c_finish_omp_for (location_t locus, tree declv, tree initv, tree condv,\n     return NULL;\n   else\n     {\n-      tree t = make_node (OMP_FOR);\n+      tree t = make_node (code);\n \n       TREE_TYPE (t) = void_type_node;\n       OMP_FOR_INIT (t) = initv;\n@@ -579,54 +597,382 @@ c_finish_omp_for (location_t locus, tree declv, tree initv, tree condv,\n     }\n }\n \n-\n-/* Divide CLAUSES into two lists: those that apply to a parallel\n-   construct, and those that apply to a work-sharing construct.  Place\n-   the results in *PAR_CLAUSES and *WS_CLAUSES respectively.  In\n-   addition, add a nowait clause to the work-sharing list.  LOC is the\n-   location of the OMP_PARALLEL*.  */\n+/* Right now we have 14 different combined constructs, this\n+   function attempts to split or duplicate clauses for combined\n+   constructs.  CODE is the innermost construct in the combined construct,\n+   and MASK allows to determine which constructs are combined together,\n+   as every construct has at least one clause that no other construct\n+   has (except for OMP_SECTIONS, but that can be only combined with parallel).\n+   Combined constructs are:\n+   #pragma omp parallel for\n+   #pragma omp parallel sections\n+   #pragma omp parallel for simd\n+   #pragma omp for simd\n+   #pragma omp distribute simd\n+   #pragma omp distribute parallel for\n+   #pragma omp distribute parallel for simd\n+   #pragma omp teams distribute\n+   #pragma omp teams distribute parallel for\n+   #pragma omp teams distribute parallel for simd\n+   #pragma omp target teams\n+   #pragma omp target teams distribute\n+   #pragma omp target teams distribute parallel for\n+   #pragma omp target teams distribute parallel for simd  */\n \n void\n-c_split_parallel_clauses (location_t loc, tree clauses,\n-\t\t\t  tree *par_clauses, tree *ws_clauses)\n+c_omp_split_clauses (location_t loc, enum tree_code code,\n+\t\t     omp_clause_mask mask, tree clauses, tree *cclauses)\n {\n-  tree next;\n+  tree next, c;\n+  enum c_omp_clause_split s;\n+  int i;\n \n-  *par_clauses = NULL;\n-  *ws_clauses = build_omp_clause (loc, OMP_CLAUSE_NOWAIT);\n+  for (i = 0; i < C_OMP_CLAUSE_SPLIT_COUNT; i++)\n+    cclauses[i] = NULL;\n+  /* Add implicit nowait clause on\n+     #pragma omp parallel {for,for simd,sections}.  */\n+  if (mask & (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_NUM_THREADS))\n+    switch (code)\n+      {\n+      case OMP_FOR:\n+      case OMP_SIMD:\n+        cclauses[C_OMP_CLAUSE_SPLIT_FOR]\n+\t  = build_omp_clause (loc, OMP_CLAUSE_NOWAIT);\n+\tbreak;\n+      case OMP_SECTIONS:\n+\tcclauses[C_OMP_CLAUSE_SPLIT_SECTIONS]\n+\t  = build_omp_clause (loc, OMP_CLAUSE_NOWAIT);\n+\tbreak;\n+      default:\n+\tbreak;\n+      }\n \n   for (; clauses ; clauses = next)\n     {\n       next = OMP_CLAUSE_CHAIN (clauses);\n \n       switch (OMP_CLAUSE_CODE (clauses))\n \t{\n-\tcase OMP_CLAUSE_PRIVATE:\n-\tcase OMP_CLAUSE_SHARED:\n-\tcase OMP_CLAUSE_FIRSTPRIVATE:\n-\tcase OMP_CLAUSE_LASTPRIVATE:\n-\tcase OMP_CLAUSE_REDUCTION:\n+\t/* First the clauses that are unique to some constructs.  */\n+\tcase OMP_CLAUSE_DEVICE:\n+\tcase OMP_CLAUSE_MAP:\n+\t  s = C_OMP_CLAUSE_SPLIT_TARGET;\n+\t  break;\n+\tcase OMP_CLAUSE_NUM_TEAMS:\n+\tcase OMP_CLAUSE_THREAD_LIMIT:\n+\t  s = C_OMP_CLAUSE_SPLIT_TEAMS;\n+\t  break;\n+\tcase OMP_CLAUSE_DIST_SCHEDULE:\n+\t  s = C_OMP_CLAUSE_SPLIT_DISTRIBUTE;\n+\t  break;\n \tcase OMP_CLAUSE_COPYIN:\n-\tcase OMP_CLAUSE_IF:\n \tcase OMP_CLAUSE_NUM_THREADS:\n-\tcase OMP_CLAUSE_DEFAULT:\n-\t  OMP_CLAUSE_CHAIN (clauses) = *par_clauses;\n-\t  *par_clauses = clauses;\n+\tcase OMP_CLAUSE_PROC_BIND:\n+\t  s = C_OMP_CLAUSE_SPLIT_PARALLEL;\n \t  break;\n-\n-\tcase OMP_CLAUSE_SCHEDULE:\n \tcase OMP_CLAUSE_ORDERED:\n+\tcase OMP_CLAUSE_SCHEDULE:\n+\tcase OMP_CLAUSE_NOWAIT:\n+\t  s = C_OMP_CLAUSE_SPLIT_FOR;\n+\t  break;\n+\tcase OMP_CLAUSE_SAFELEN:\n+\tcase OMP_CLAUSE_LINEAR:\n+\tcase OMP_CLAUSE_ALIGNED:\n+\t  s = C_OMP_CLAUSE_SPLIT_SIMD;\n+\t  break;\n+\t/* Duplicate this to all of distribute, for and simd.  */\n \tcase OMP_CLAUSE_COLLAPSE:\n-\t  OMP_CLAUSE_CHAIN (clauses) = *ws_clauses;\n-\t  *ws_clauses = clauses;\n+\t  if (code == OMP_SIMD)\n+\t    {\n+\t      c = build_omp_clause (OMP_CLAUSE_LOCATION (clauses),\n+\t\t\t\t    OMP_CLAUSE_COLLAPSE);\n+\t      OMP_CLAUSE_COLLAPSE_EXPR (c)\n+\t\t= OMP_CLAUSE_COLLAPSE_EXPR (clauses);\n+\t      OMP_CLAUSE_CHAIN (c) = cclauses[C_OMP_CLAUSE_SPLIT_SIMD];\n+\t      cclauses[C_OMP_CLAUSE_SPLIT_SIMD] = c;\n+\t    }\n+\t  if (mask & (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_SCHEDULE))\n+\t    {\n+\t      if (mask & (OMP_CLAUSE_MASK_1\n+\t\t\t  << PRAGMA_OMP_CLAUSE_DIST_SCHEDULE))\n+\t\t{\n+\t\t  c = build_omp_clause (OMP_CLAUSE_LOCATION (clauses),\n+\t\t\t\t\tOMP_CLAUSE_COLLAPSE);\n+\t\t  OMP_CLAUSE_COLLAPSE_EXPR (c)\n+\t\t    = OMP_CLAUSE_COLLAPSE_EXPR (clauses);\n+\t\t  OMP_CLAUSE_CHAIN (c) = cclauses[C_OMP_CLAUSE_SPLIT_FOR];\n+\t\t  cclauses[C_OMP_CLAUSE_SPLIT_FOR] = c;\n+\t\t  s = C_OMP_CLAUSE_SPLIT_DISTRIBUTE;\n+\t\t}\n+\t      else\n+\t\ts = C_OMP_CLAUSE_SPLIT_FOR;\n+\t    }\n+\t  else\n+\t    s = C_OMP_CLAUSE_SPLIT_DISTRIBUTE;\n+\t  break;\n+\t/* Private clause is supported on all constructs but target,\n+\t   it is enough to put it on the innermost one.  For\n+\t   #pragma omp {for,sections} put it on parallel though,\n+\t   as that's what we did for OpenMP 3.1.  */\n+\tcase OMP_CLAUSE_PRIVATE:\n+\t  switch (code)\n+\t    {\n+\t    case OMP_SIMD: s = C_OMP_CLAUSE_SPLIT_SIMD; break;\n+\t    case OMP_FOR: case OMP_SECTIONS:\n+\t    case OMP_PARALLEL: s = C_OMP_CLAUSE_SPLIT_PARALLEL; break;\n+\t    case OMP_DISTRIBUTE: s = C_OMP_CLAUSE_SPLIT_DISTRIBUTE; break;\n+\t    case OMP_TEAMS: s = C_OMP_CLAUSE_SPLIT_TEAMS; break;\n+\t    default: gcc_unreachable ();\n+\t    }\n+\t  break;\n+\t/* Firstprivate clause is supported on all constructs but\n+\t   target and simd.  Put it on the outermost of those and\n+\t   duplicate on parallel.  */\n+\tcase OMP_CLAUSE_FIRSTPRIVATE:\n+\t  if (mask & (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_NUM_THREADS))\n+\t    {\n+\t      if (mask & ((OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_NUM_TEAMS)\n+\t\t\t  | (OMP_CLAUSE_MASK_1\n+\t\t\t     << PRAGMA_OMP_CLAUSE_DIST_SCHEDULE)))\n+\t\t{\n+\t\t  c = build_omp_clause (OMP_CLAUSE_LOCATION (clauses),\n+\t\t\t\t\tOMP_CLAUSE_FIRSTPRIVATE);\n+\t\t  OMP_CLAUSE_DECL (c) = OMP_CLAUSE_DECL (clauses);\n+\t\t  OMP_CLAUSE_CHAIN (c) = cclauses[C_OMP_CLAUSE_SPLIT_PARALLEL];\n+\t\t  cclauses[C_OMP_CLAUSE_SPLIT_PARALLEL] = c;\n+\t\t  if (mask & (OMP_CLAUSE_MASK_1\n+\t\t\t      << PRAGMA_OMP_CLAUSE_NUM_TEAMS))\n+\t\t    s = C_OMP_CLAUSE_SPLIT_TEAMS;\n+\t\t  else\n+\t\t    s = C_OMP_CLAUSE_SPLIT_DISTRIBUTE;\n+\t\t}\n+\t      else\n+\t\t/* This must be\n+\t\t   #pragma omp parallel{, for{, simd}, sections}.  */\n+\t\ts = C_OMP_CLAUSE_SPLIT_PARALLEL;\n+\t    }\n+\t  else if (mask & (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_NUM_TEAMS))\n+\t    {\n+\t      /* This must be #pragma omp {,target }teams distribute.  */\n+\t      gcc_assert (code == OMP_DISTRIBUTE);\n+\t      s = C_OMP_CLAUSE_SPLIT_TEAMS;\n+\t    }\n+\t  else if (mask & (OMP_CLAUSE_MASK_1\n+\t\t\t   << PRAGMA_OMP_CLAUSE_DIST_SCHEDULE))\n+\t    {\n+\t      /* This must be #pragma omp distribute simd.  */\n+\t      gcc_assert (code == OMP_SIMD);\n+\t      s = C_OMP_CLAUSE_SPLIT_TEAMS;\n+\t    }\n+\t  else\n+\t    {\n+\t      /* This must be #pragma omp for simd.  */\n+\t      gcc_assert (code == OMP_SIMD);\n+\t      s = C_OMP_CLAUSE_SPLIT_FOR;\n+\t    }\n+\t  break;\n+\t/* Lastprivate is allowed on for, sections and simd.  In\n+\t   parallel {for{, simd},sections} we actually want to put it on\n+\t   parallel rather than for or sections.  */\n+\tcase OMP_CLAUSE_LASTPRIVATE:\n+\t  if (code == OMP_FOR || code == OMP_SECTIONS)\n+\t    {\n+\t      if (mask & (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_NUM_THREADS))\n+\t\ts = C_OMP_CLAUSE_SPLIT_PARALLEL;\n+\t      else\n+\t\ts = C_OMP_CLAUSE_SPLIT_FOR;\n+\t      break;\n+\t    }\n+\t  gcc_assert (code == OMP_SIMD);\n+\t  if (mask & (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_SCHEDULE))\n+\t    {\n+\t      c = build_omp_clause (OMP_CLAUSE_LOCATION (clauses),\n+\t\t\t\t    OMP_CLAUSE_LASTPRIVATE);\n+\t      OMP_CLAUSE_DECL (c) = OMP_CLAUSE_DECL (clauses);\n+\t      if (mask & (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_NUM_THREADS))\n+\t\ts = C_OMP_CLAUSE_SPLIT_PARALLEL;\n+\t      else\n+\t\ts = C_OMP_CLAUSE_SPLIT_FOR;\n+\t      OMP_CLAUSE_CHAIN (c) = cclauses[s];\n+\t      cclauses[s] = c;\n+\t    }\n+\t  s = C_OMP_CLAUSE_SPLIT_SIMD;\n+\t  break;\n+\t/* Shared and default clauses are allowed on private and teams.  */\n+\tcase OMP_CLAUSE_SHARED:\n+\tcase OMP_CLAUSE_DEFAULT:\n+\t  if (code == OMP_TEAMS)\n+\t    {\n+\t      s = C_OMP_CLAUSE_SPLIT_TEAMS;\n+\t      break;\n+\t    }\n+\t  if (mask & (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_NUM_TEAMS))\n+\t    {\n+\t      c = build_omp_clause (OMP_CLAUSE_LOCATION (clauses),\n+\t\t\t\t    OMP_CLAUSE_CODE (clauses));\n+\t      if (OMP_CLAUSE_CODE (clauses) == OMP_CLAUSE_SHARED)\n+\t\tOMP_CLAUSE_DECL (c) = OMP_CLAUSE_DECL (clauses);\n+\t      else\n+\t\tOMP_CLAUSE_DEFAULT_KIND (c)\n+\t\t  = OMP_CLAUSE_DEFAULT_KIND (clauses);\n+\t      OMP_CLAUSE_CHAIN (c) = cclauses[C_OMP_CLAUSE_SPLIT_TEAMS];\n+\t      cclauses[C_OMP_CLAUSE_SPLIT_TEAMS] = c;\n+\t      \n+\t    }\n+\t  s = C_OMP_CLAUSE_SPLIT_PARALLEL;\n+\t  break;\n+\t/* Reduction is allowed on simd, for, parallel, sections and teams.\n+\t   Duplicate it on all of them, but omit on for or sections if\n+\t   parallel is present.  */\n+\tcase OMP_CLAUSE_REDUCTION:\n+\t  if (code == OMP_SIMD)\n+\t    {\n+\t      c = build_omp_clause (OMP_CLAUSE_LOCATION (clauses),\n+\t\t\t\t    OMP_CLAUSE_REDUCTION);\n+\t      OMP_CLAUSE_DECL (c) = OMP_CLAUSE_DECL (clauses);\n+\t      OMP_CLAUSE_REDUCTION_CODE (c)\n+\t\t= OMP_CLAUSE_REDUCTION_CODE (clauses);\n+\t      OMP_CLAUSE_REDUCTION_PLACEHOLDER (c)\n+\t\t= OMP_CLAUSE_REDUCTION_PLACEHOLDER (clauses);\n+\t      OMP_CLAUSE_CHAIN (c) = cclauses[C_OMP_CLAUSE_SPLIT_SIMD];\n+\t      cclauses[C_OMP_CLAUSE_SPLIT_SIMD] = c;\n+\t    }\n+\t  if (mask & (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_SCHEDULE))\n+\t    {\n+\t      if (mask & (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_NUM_TEAMS))\n+\t\t{\n+\t\t  c = build_omp_clause (OMP_CLAUSE_LOCATION (clauses),\n+\t\t\t\t\tOMP_CLAUSE_REDUCTION);\n+\t\t  OMP_CLAUSE_DECL (c) = OMP_CLAUSE_DECL (clauses);\n+\t\t  OMP_CLAUSE_REDUCTION_CODE (c)\n+\t\t    = OMP_CLAUSE_REDUCTION_CODE (clauses);\n+\t\t  OMP_CLAUSE_REDUCTION_PLACEHOLDER (c)\n+\t\t    = OMP_CLAUSE_REDUCTION_PLACEHOLDER (clauses);\n+\t\t  OMP_CLAUSE_CHAIN (c) = cclauses[C_OMP_CLAUSE_SPLIT_PARALLEL];\n+\t\t  cclauses[C_OMP_CLAUSE_SPLIT_PARALLEL] = c;\n+\t\t  s = C_OMP_CLAUSE_SPLIT_TEAMS;\n+\t\t}\n+\t      else if (mask & (OMP_CLAUSE_MASK_1\n+\t\t\t       << PRAGMA_OMP_CLAUSE_NUM_THREADS))\n+\t\ts = C_OMP_CLAUSE_SPLIT_PARALLEL;\n+\t      else\n+\t\ts = C_OMP_CLAUSE_SPLIT_FOR;\n+\t    }\n+\t  else if (code == OMP_SECTIONS)\n+\t    s = C_OMP_CLAUSE_SPLIT_PARALLEL;\n+\t  else\n+\t    s = C_OMP_CLAUSE_SPLIT_TEAMS;\n+\t  break;\n+\tcase OMP_CLAUSE_IF:\n+\t  /* FIXME: This is currently being discussed.  */\n+\t  if (mask & (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_NUM_THREADS))\n+\t    s = C_OMP_CLAUSE_SPLIT_PARALLEL;\n+\t  else\n+\t    s = C_OMP_CLAUSE_SPLIT_TARGET;\n \t  break;\n-\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n+      OMP_CLAUSE_CHAIN (clauses) = cclauses[s];\n+      cclauses[s] = clauses;\n     }\n }\n \n+\n+/* qsort callback to compare #pragma omp declare simd clauses.  */\n+\n+static int\n+c_omp_declare_simd_clause_cmp (const void *p, const void *q)\n+{\n+  tree a = *(const tree *) p;\n+  tree b = *(const tree *) q;\n+  if (OMP_CLAUSE_CODE (a) != OMP_CLAUSE_CODE (b))\n+    {\n+      if (OMP_CLAUSE_CODE (a) > OMP_CLAUSE_CODE (b))\n+\treturn -1;\n+      return 1;\n+    }\n+  if (OMP_CLAUSE_CODE (a) != OMP_CLAUSE_SIMDLEN\n+      && OMP_CLAUSE_CODE (a) != OMP_CLAUSE_INBRANCH\n+      && OMP_CLAUSE_CODE (a) != OMP_CLAUSE_NOTINBRANCH)\n+    {\n+      int c = tree_low_cst (OMP_CLAUSE_DECL (a), 0);\n+      int d = tree_low_cst (OMP_CLAUSE_DECL (b), 0);\n+      if (c < d)\n+\treturn 1;\n+      if (c > d)\n+\treturn -1;\n+    }\n+  return 0;\n+}\n+\n+/* Change PARM_DECLs in OMP_CLAUSE_DECL of #pragma omp declare simd\n+   CLAUSES on FNDECL into argument indexes and sort them.  */\n+\n+tree\n+c_omp_declare_simd_clauses_to_numbers (tree parms, tree clauses)\n+{\n+  tree c;\n+  vec<tree> clvec = vNULL;\n+\n+  for (c = clauses; c; c = OMP_CLAUSE_CHAIN (c))\n+    {\n+      if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_SIMDLEN\n+\t  && OMP_CLAUSE_CODE (c) != OMP_CLAUSE_INBRANCH\n+\t  && OMP_CLAUSE_CODE (c) != OMP_CLAUSE_NOTINBRANCH)\n+\t{\n+\t  tree decl = OMP_CLAUSE_DECL (c);\n+\t  tree arg;\n+\t  int idx;\n+\t  for (arg = parms, idx = 0; arg;\n+\t       arg = TREE_CHAIN (arg), idx++)\n+\t    if (arg == decl)\n+\t      break;\n+\t  if (arg == NULL_TREE)\n+\t    {\n+\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\"%qD is not an function argument\", decl);\n+\t      continue;\n+\t    }\n+\t  OMP_CLAUSE_DECL (c) = build_int_cst (integer_type_node, idx);\n+\t}\n+      clvec.safe_push (c);\n+    }\n+  if (!clvec.is_empty ())\n+    {\n+      unsigned int len = clvec.length (), i;\n+      clvec.qsort (c_omp_declare_simd_clause_cmp);\n+      clauses = clvec[0];\n+      for (i = 0; i < len; i++)\n+\tOMP_CLAUSE_CHAIN (clvec[i]) = (i < len - 1) ? clvec[i + 1] : NULL_TREE;\n+    }\n+  clvec.release ();\n+  return clauses;\n+}\n+\n+/* Change argument indexes in CLAUSES of FNDECL back to PARM_DECLs.  */\n+\n+void\n+c_omp_declare_simd_clauses_to_decls (tree fndecl, tree clauses)\n+{\n+  tree c;\n+\n+  for (c = clauses; c; c = OMP_CLAUSE_CHAIN (c))\n+    if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_SIMDLEN\n+\t&& OMP_CLAUSE_CODE (c) != OMP_CLAUSE_INBRANCH\n+\t&& OMP_CLAUSE_CODE (c) != OMP_CLAUSE_NOTINBRANCH)\n+      {\n+\tint idx = tree_low_cst (OMP_CLAUSE_DECL (c), 0), i;\n+\ttree arg;\n+\tfor (arg = DECL_ARGUMENTS (fndecl), i = 0; arg;\n+\t     arg = TREE_CHAIN (arg), i++)\n+\t  if (i == idx)\n+\t    break;\n+\tgcc_assert (arg);\n+\tOMP_CLAUSE_DECL (c) = arg;\n+      }\n+}\n+\n /* True if OpenMP sharing attribute of DECL is predetermined.  */\n \n enum omp_clause_default_kind"}, {"sha": "4ff187bcb6f362ee914d2e8824e7ee0899fcaca3", "filename": "gcc/c-family/c-pragma.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Fc-family%2Fc-pragma.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Fc-family%2Fc-pragma.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-pragma.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -1167,18 +1167,27 @@ struct omp_pragma_def { const char *name; unsigned int id; };\n static const struct omp_pragma_def omp_pragmas[] = {\n   { \"atomic\", PRAGMA_OMP_ATOMIC },\n   { \"barrier\", PRAGMA_OMP_BARRIER },\n+  { \"cancel\", PRAGMA_OMP_CANCEL },\n+  { \"cancellation\", PRAGMA_OMP_CANCELLATION_POINT },\n   { \"critical\", PRAGMA_OMP_CRITICAL },\n+  { \"declare\", PRAGMA_OMP_DECLARE_REDUCTION },\n+  { \"distribute\", PRAGMA_OMP_DISTRIBUTE },\n+  { \"end\", PRAGMA_OMP_END_DECLARE_TARGET },\n   { \"flush\", PRAGMA_OMP_FLUSH },\n   { \"for\", PRAGMA_OMP_FOR },\n   { \"master\", PRAGMA_OMP_MASTER },\n   { \"ordered\", PRAGMA_OMP_ORDERED },\n   { \"parallel\", PRAGMA_OMP_PARALLEL },\n   { \"section\", PRAGMA_OMP_SECTION },\n   { \"sections\", PRAGMA_OMP_SECTIONS },\n+  { \"simd\", PRAGMA_OMP_SIMD },\n   { \"single\", PRAGMA_OMP_SINGLE },\n+  { \"target\", PRAGMA_OMP_TARGET },\n   { \"task\", PRAGMA_OMP_TASK },\n+  { \"taskgroup\", PRAGMA_OMP_TASKGROUP },\n   { \"taskwait\", PRAGMA_OMP_TASKWAIT },\n   { \"taskyield\", PRAGMA_OMP_TASKYIELD },\n+  { \"teams\", PRAGMA_OMP_TEAMS },\n   { \"threadprivate\", PRAGMA_OMP_THREADPRIVATE }\n };\n "}, {"sha": "c421284a5c44a67d1ffb5f26751ca58f79015dcf", "filename": "gcc/c-family/c-pragma.h", "status": "modified", "additions": 33, "deletions": 6, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Fc-family%2Fc-pragma.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Fc-family%2Fc-pragma.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-pragma.h?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -29,50 +29,77 @@ typedef enum pragma_kind {\n \n   PRAGMA_OMP_ATOMIC,\n   PRAGMA_OMP_BARRIER,\n+  PRAGMA_OMP_CANCEL,\n+  PRAGMA_OMP_CANCELLATION_POINT,\n   PRAGMA_OMP_CRITICAL,\n+  PRAGMA_OMP_DECLARE_REDUCTION,\n+  PRAGMA_OMP_DISTRIBUTE,\n+  PRAGMA_OMP_END_DECLARE_TARGET,\n   PRAGMA_OMP_FLUSH,\n   PRAGMA_OMP_FOR,\n   PRAGMA_OMP_MASTER,\n   PRAGMA_OMP_ORDERED,\n   PRAGMA_OMP_PARALLEL,\n-  PRAGMA_OMP_PARALLEL_FOR,\n-  PRAGMA_OMP_PARALLEL_SECTIONS,\n   PRAGMA_OMP_SECTION,\n   PRAGMA_OMP_SECTIONS,\n+  PRAGMA_OMP_SIMD,\n   PRAGMA_OMP_SINGLE,\n+  PRAGMA_OMP_TARGET,\n   PRAGMA_OMP_TASK,\n+  PRAGMA_OMP_TASKGROUP,\n   PRAGMA_OMP_TASKWAIT,\n   PRAGMA_OMP_TASKYIELD,\n   PRAGMA_OMP_THREADPRIVATE,\n+  PRAGMA_OMP_TEAMS,\n \n   PRAGMA_GCC_PCH_PREPROCESS,\n \n   PRAGMA_FIRST_EXTERNAL\n } pragma_kind;\n \n \n-/* All clauses defined by OpenMP 2.5 and 3.0.\n+/* All clauses defined by OpenMP 2.5, 3.0, 3.1 and 4.0.\n    Used internally by both C and C++ parsers.  */\n typedef enum pragma_omp_clause {\n   PRAGMA_OMP_CLAUSE_NONE = 0,\n \n+  PRAGMA_OMP_CLAUSE_ALIGNED,\n   PRAGMA_OMP_CLAUSE_COLLAPSE,\n   PRAGMA_OMP_CLAUSE_COPYIN,\n   PRAGMA_OMP_CLAUSE_COPYPRIVATE,\n   PRAGMA_OMP_CLAUSE_DEFAULT,\n+  PRAGMA_OMP_CLAUSE_DEPEND,\n+  PRAGMA_OMP_CLAUSE_DEVICE,\n+  PRAGMA_OMP_CLAUSE_DIST_SCHEDULE,\n+  PRAGMA_OMP_CLAUSE_FINAL,\n   PRAGMA_OMP_CLAUSE_FIRSTPRIVATE,\n+  PRAGMA_OMP_CLAUSE_FOR,\n+  PRAGMA_OMP_CLAUSE_FROM,\n   PRAGMA_OMP_CLAUSE_IF,\n+  PRAGMA_OMP_CLAUSE_INBRANCH,\n   PRAGMA_OMP_CLAUSE_LASTPRIVATE,\n+  PRAGMA_OMP_CLAUSE_LINEAR,\n+  PRAGMA_OMP_CLAUSE_MAP,\n+  PRAGMA_OMP_CLAUSE_MERGEABLE,\n+  PRAGMA_OMP_CLAUSE_NOTINBRANCH,\n   PRAGMA_OMP_CLAUSE_NOWAIT,\n+  PRAGMA_OMP_CLAUSE_NUM_TEAMS,\n   PRAGMA_OMP_CLAUSE_NUM_THREADS,\n   PRAGMA_OMP_CLAUSE_ORDERED,\n+  PRAGMA_OMP_CLAUSE_PARALLEL,\n   PRAGMA_OMP_CLAUSE_PRIVATE,\n+  PRAGMA_OMP_CLAUSE_PROC_BIND,\n   PRAGMA_OMP_CLAUSE_REDUCTION,\n+  PRAGMA_OMP_CLAUSE_SAFELEN,\n   PRAGMA_OMP_CLAUSE_SCHEDULE,\n+  PRAGMA_OMP_CLAUSE_SECTIONS,\n   PRAGMA_OMP_CLAUSE_SHARED,\n-  PRAGMA_OMP_CLAUSE_UNTIED,\n-  PRAGMA_OMP_CLAUSE_FINAL,\n-  PRAGMA_OMP_CLAUSE_MERGEABLE\n+  PRAGMA_OMP_CLAUSE_SIMDLEN,\n+  PRAGMA_OMP_CLAUSE_TASKGROUP,\n+  PRAGMA_OMP_CLAUSE_THREAD_LIMIT,\n+  PRAGMA_OMP_CLAUSE_TO,\n+  PRAGMA_OMP_CLAUSE_UNIFORM,\n+  PRAGMA_OMP_CLAUSE_UNTIED\n } pragma_omp_clause;\n \n extern struct cpp_reader* parse_in;"}, {"sha": "e6efc31731532c3f2e19d11c436a534c682cc4a4", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -1,3 +1,114 @@\n+2013-10-11  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* c-lang.h (current_omp_declare_target_attribute): New extern\n+\tdecl.\n+\t* c-parser.c: Include c-lang.h.\n+\t(struct c_parser): Change tokens to c_token *.\n+\tAdd tokens_buf field.  Change tokens_avail type to unsigned int.\n+\t(c_parser_consume_token): If parser->tokens isn't\n+\t&parser->tokens_buf[0], increment parser->tokens.\n+\t(c_parser_consume_pragma): Likewise.\n+\t(enum pragma_context): Add pragma_struct and pragma_param.\n+\t(c_parser_external_declaration): Adjust\n+\tc_parser_declaration_or_fndef caller.\n+\t(c_parser_declaration_or_fndef): Add omp_declare_simd_clauses\n+\targument, if it is non-vNULL vector, call c_finish_omp_declare_simd.\n+\tAdjust recursive call.\n+\t(c_parser_struct_or_union_specifier): Use pragma_struct instead\n+\tof pragma_external.\n+\t(c_parser_parameter_declaration): Use pragma_param instead of\n+\tpragma_external.\n+\t(c_parser_compound_statement_nostart, c_parser_label,\n+\tc_parser_for_statement): Adjust\n+\tc_parser_declaration_or_fndef callers.\n+\t(c_parser_expr_no_commas): Add omp_atomic_lhs argument, pass\n+\tit through to c_parser_conditional_expression.\n+\t(c_parser_conditional_expression): Add omp_atomic_lhs argument,\n+\tpass it through to c_parser_binary_expression.  Adjust recursive\n+\tcall.\n+\t(c_parser_binary_expression): Remove prec argument, add\n+\tomp_atomic_lhs argument instead.  Always start from PREC_NONE, if\n+\tomp_atomic_lhs is non-NULL and one of the arguments of toplevel\n+\tbinop matches it, use build2 instead of parser_build_binary_op.\n+\t(c_parser_pragma): Handle PRAGMA_OMP_CANCEL,\n+\tPRAGMA_OMP_CANCELLATION_POINT, PRAGMA_OMP_TARGET,\n+\tPRAGMA_OMP_END_DECLARE_TARGET, PRAGMA_OMP_DECLARE_REDUCTION.\n+\tHandle pragma_struct and pragma_param the same as pragma_external.\n+\t(c_parser_omp_clause_name): Parse new OpenMP 4.0 clause names.\n+\t(c_parser_omp_variable_list): Parse array sections for\n+\tOMP_CLAUSE_{DEPEND,MAP,TO,FROM} clauses.\n+\t(c_parser_omp_clause_collapse): Fully fold collapse expression.\n+\t(c_parser_omp_clause_reduction): Handle user defined reductions.\n+\t(c_parser_omp_clause_branch, c_parser_omp_clause_cancelkind,\n+\tc_parser_omp_clause_num_teams, c_parser_omp_clause_thread_limit,\n+\tc_parser_omp_clause_aligned, c_parser_omp_clause_linear,\n+\tc_parser_omp_clause_safelen, c_parser_omp_clause_simdlen,\n+\tc_parser_omp_clause_depend, c_parser_omp_clause_map,\n+\tc_parser_omp_clause_device, c_parser_omp_clause_dist_schedule,\n+\tc_parser_omp_clause_proc_bind, c_parser_omp_clause_to,\n+\tc_parser_omp_clause_from, c_parser_omp_clause_uniform): New functions.\n+\t(c_parser_omp_all_clauses): Add finish_p argument.  Don't call\n+\tc_finish_omp_clauses if it is false.  Handle new OpenMP 4.0 clauses.\n+\t(c_parser_omp_atomic): Parse seq_cst clause, pass true if it is\n+\tpresent to c_finish_omp_atomic.  Handle OpenMP 4.0 atomic forms.\n+\t(c_parser_omp_for_loop): Add CODE argument, pass it through\n+\tto c_finish_omp_for.  Change last argument to cclauses,\n+\tand adjust uses to grab parallel clauses from the array of all\n+\tthe split clauses.  Adjust c_parser_binary_expression,\n+\tc_parser_declaration_or_fndef and c_finish_omp_for callers.\n+\t(omp_split_clauses): New function.\n+\t(c_parser_omp_simd): New function.\n+\t(c_parser_omp_for): Add p_name, mask and cclauses arguments.\n+\tAllow the function to be called also when parsing combined constructs,\n+\tand call c_parser_omp_simd when parsing for simd.\n+\t(c_parser_omp_sections_scope): If section-sequence doesn't start with\n+\t#pragma omp section, require exactly one structured-block instead of\n+\tsequence of statements.\n+\t(c_parser_omp_sections): Add p_name, mask and cclauses arguments.\n+\tAllow the function to be called also when parsing combined constructs.\n+\t(c_parser_omp_parallel): Add p_name, mask and cclauses arguments.\n+\tAllow the function to be called also when parsing combined\n+\tconstructs.\n+\t(c_parser_omp_taskgroup, c_parser_omp_cancel,\n+\tc_parser_omp_cancellation_point, c_parser_omp_distribute,\n+\tc_parser_omp_teams, c_parser_omp_target_data,\n+\tc_parser_omp_target_update, c_parser_omp_target,\n+\tc_parser_omp_declare_simd, c_finish_omp_declare_simd,\n+\tc_parser_omp_declare_target, c_parser_omp_end_declare_target,\n+\tc_parser_omp_declare_reduction, c_parser_omp_declare): New functions.\n+\t(c_parser_omp_construct): Add p_name and mask vars.  Handle\n+\tPRAGMA_OMP_DISTRIBUTE, PRAGMA_OMP_SIMD, PRAGMA_OMP_TASKGROUP,\n+\tPRAGMA_OMP_TEAMS.  Adjust c_parser_omp_for, c_parser_omp_parallel\n+\tand c_parser_omp_sections callers.\n+\t(c_parse_file): Initialize tparser.tokens and the_parser->tokens here.\n+\t(OMP_FOR_CLAUSE_MASK, OMP_SECTIONS_CLAUSE_MASK,\n+\tOMP_SINGLE_CLAUSE_MASK): Use OMP_CLAUSE_MASK_1 instead of 1.\n+\t(OMP_PARALLEL_CLAUSE_MASK): Likewise.  Add OMP_CLAUSE_PROC_BIND.\n+\t(OMP_TASK_CLAUSE_MASK): Use OMP_CLAUSE_MASK_1 instead of 1.  Add\n+\tOMP_CLAUSE_DEPEND.\n+\t(OMP_SIMD_CLAUSE_MASK, OMP_CANCEL_CLAUSE_MASK,\n+\tOMP_CANCELLATION_POINT_CLAUSE_MASK, OMP_DISTRIBUTE_CLAUSE_MASK,\n+\tOMP_TEAMS_CLAUSE_MASK, OMP_TARGET_DATA_CLAUSE_MASK,\n+\tOMP_TARGET_UPDATE_CLAUSE_MASK, OMP_TARGET_CLAUSE_MASK,\n+\tOMP_DECLARE_SIMD_CLAUSE_MASK): Define.\n+\t* c-typeck.c: Include tree-inline.h.\n+\t(c_finish_omp_cancel, c_finish_omp_cancellation_point,\n+\thandle_omp_array_sections_1, handle_omp_array_sections,\n+\tc_clone_omp_udr, c_find_omp_placeholder_r): New functions.\n+\t(c_finish_omp_clauses): Handle new OpenMP 4.0 clauses and\n+\tuser defined reductions.\n+\t(c_tree_equal): New function.\n+\t* c-tree.h (temp_store_parm_decls, temp_pop_parm_decls,\n+\tc_finish_omp_cancel, c_finish_omp_cancellation_point, c_tree_equal,\n+\tc_omp_reduction_id, c_omp_reduction_decl, c_omp_reduction_lookup,\n+\tc_check_omp_declare_reduction_r): New prototypes.\n+\t* c-decl.c (current_omp_declare_target_attribute): New variable.\n+\t(c_decl_attributes): New function.\n+\t(start_decl, start_function): Use it instead of decl_attributes.\n+\t(temp_store_parm_decls, temp_pop_parm_decls, c_omp_reduction_id,\n+\tc_omp_reduction_decl, c_omp_reduction_lookup,\n+\tc_check_omp_declare_reduction_r): New functions.\n+\n 2013-09-25  Tom Tromey  <tromey@redhat.com>\n \n \t* Make-lang.in (c/gccspec.o): Remove."}, {"sha": "0554e72703ff743098c8a05a70156cb0cc27e9d4", "filename": "gcc/c/c-decl.c", "status": "modified", "additions": 174, "deletions": 2, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Fc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Fc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-decl.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -147,6 +147,9 @@ static bool undef_nested_function;\n \n enum machine_mode c_default_pointer_mode = VOIDmode;\n \n+/* If non-zero, implicit \"omp declare target\" attribute is added into the\n+   attribute lists.  */\n+int current_omp_declare_target_attribute;\n \f\n /* Each c_binding structure describes one binding of an identifier to\n    a decl.  All the decls in a scope - irrespective of namespace - are\n@@ -3971,6 +3974,35 @@ groktypename (struct c_type_name *type_name, tree *expr,\n   return type;\n }\n \n+/* Wrapper for decl_attributes that adds some implicit attributes\n+   to VAR_DECLs or FUNCTION_DECLs.  */\n+\n+static tree\n+c_decl_attributes (tree *node, tree attributes, int flags)\n+{\n+  /* Add implicit \"omp declare target\" attribute if requested.  */\n+  if (current_omp_declare_target_attribute\n+      && ((TREE_CODE (*node) == VAR_DECL && TREE_STATIC (*node))\n+\t  || TREE_CODE (*node) == FUNCTION_DECL))\n+    {\n+      if (TREE_CODE (*node) == VAR_DECL\n+\t  && ((DECL_CONTEXT (*node)\n+\t       && TREE_CODE (DECL_CONTEXT (*node)) == FUNCTION_DECL)\n+\t      || (current_function_decl && !DECL_EXTERNAL (*node))))\n+\terror (\"%q+D in block scope inside of declare target directive\",\n+\t       *node);\n+      else if (TREE_CODE (*node) == VAR_DECL\n+\t       && !COMPLETE_TYPE_P (TREE_TYPE (*node)))\n+\terror (\"%q+D in declare target directive does not have mappable type\",\n+\t       *node);\n+      else\n+\tattributes = tree_cons (get_identifier (\"omp declare target\"),\n+\t\t\t\tNULL_TREE, attributes);\n+    }\n+  return decl_attributes (node, attributes, flags);\n+}\n+\n+\n /* Decode a declarator in an ordinary declaration or data definition.\n    This is called as soon as the type information and variable name\n    have been parsed, before parsing the initializer if any.\n@@ -4105,7 +4137,7 @@ start_decl (struct c_declarator *declarator, struct c_declspecs *declspecs,\n     DECL_COMMON (decl) = 1;\n \n   /* Set attributes here so if duplicate decl, will have proper attributes.  */\n-  decl_attributes (&decl, attributes, 0);\n+  c_decl_attributes (&decl, attributes, 0);\n \n   /* Handle gnu_inline attribute.  */\n   if (declspecs->inline_p\n@@ -7727,7 +7759,7 @@ start_function (struct c_declspecs *declspecs, struct c_declarator *declarator,\n \n   loc = DECL_SOURCE_LOCATION (decl1);\n \n-  decl_attributes (&decl1, attributes, 0);\n+  c_decl_attributes (&decl1, attributes, 0);\n \n   if (DECL_DECLARED_INLINE_P (decl1)\n       && DECL_UNINLINABLE (decl1)\n@@ -8324,6 +8356,44 @@ store_parm_decls (void)\n   if (arg_info->pending_sizes)\n     add_stmt (arg_info->pending_sizes);\n }\n+\n+/* Store PARM_DECLs in PARMS into scope temporarily.  Used for\n+   c_finish_omp_declare_simd for function prototypes.  No diagnostics\n+   should be done.  */\n+\n+void\n+temp_store_parm_decls (tree fndecl, tree parms)\n+{\n+  push_scope ();\n+  for (tree p = parms; p; p = DECL_CHAIN (p))\n+    {\n+      DECL_CONTEXT (p) = fndecl;\n+      if (DECL_NAME (p))\n+\tbind (DECL_NAME (p), p, current_scope,\n+\t      /*invisible=*/false, /*nested=*/false,\n+\t      UNKNOWN_LOCATION);\n+    }\n+}\n+\n+/* Undo what temp_store_parm_decls did.  */\n+\n+void\n+temp_pop_parm_decls (void)\n+{\n+  /* Clear all bindings in this temporary scope, so that\n+     pop_scope doesn't create a BLOCK.  */\n+  struct c_binding *b = current_scope->bindings;\n+  current_scope->bindings = NULL;\n+  for (; b; b = free_binding_and_advance (b))\n+    {\n+      gcc_assert (TREE_CODE (b->decl) == PARM_DECL);\n+      gcc_assert (I_SYMBOL_BINDING (b->id) == b);\n+      I_SYMBOL_BINDING (b->id) = b->shadowed;\n+      if (b->shadowed && b->shadowed->u.type)\n+\tTREE_TYPE (b->shadowed->decl) = b->shadowed->u.type;\n+    }\n+  pop_scope ();\n+}\n \f\n \n /* Finish up a function declaration and compile that function\n@@ -10158,4 +10228,106 @@ c_register_addr_space (const char *word, addr_space_t as)\n   ridpointers [rid] = id;\n }\n \n+/* Return identifier to look up for omp declare reduction.  */\n+\n+tree\n+c_omp_reduction_id (enum tree_code reduction_code, tree reduction_id)\n+{\n+  const char *p = NULL;\n+  switch (reduction_code)\n+    {\n+    case PLUS_EXPR: p = \"+\"; break;\n+    case MULT_EXPR: p = \"*\"; break;\n+    case MINUS_EXPR: p = \"-\"; break;\n+    case BIT_AND_EXPR: p = \"&\"; break;\n+    case BIT_XOR_EXPR: p = \"^\"; break;\n+    case BIT_IOR_EXPR: p = \"|\"; break;\n+    case TRUTH_ANDIF_EXPR: p = \"&&\"; break;\n+    case TRUTH_ORIF_EXPR: p = \"||\"; break;\n+    case MIN_EXPR: p = \"min\"; break;\n+    case MAX_EXPR: p = \"max\"; break;\n+    default:\n+      break;\n+    }\n+\n+  if (p == NULL)\n+    {\n+      if (TREE_CODE (reduction_id) != IDENTIFIER_NODE)\n+\treturn error_mark_node;\n+      p = IDENTIFIER_POINTER (reduction_id);\n+    }\n+\n+  const char prefix[] = \"omp declare reduction \";\n+  size_t lenp = sizeof (prefix);\n+  size_t len = strlen (p);\n+  char *name = XALLOCAVEC (char, lenp + len);\n+  memcpy (name, prefix, lenp - 1);\n+  memcpy (name + lenp - 1, p, len + 1);\n+  return get_identifier (name);\n+}\n+\n+/* Lookup REDUCTION_ID in the current scope, or create an artificial\n+   VAR_DECL, bind it into the current scope and return it.  */\n+\n+tree\n+c_omp_reduction_decl (tree reduction_id)\n+{\n+  struct c_binding *b = I_SYMBOL_BINDING (reduction_id);\n+  if (b != NULL && B_IN_CURRENT_SCOPE (b))\n+    return b->decl;\n+\n+  tree decl = build_decl (BUILTINS_LOCATION, VAR_DECL,\n+\t\t\t  reduction_id, integer_type_node);\n+  DECL_ARTIFICIAL (decl) = 1;\n+  DECL_EXTERNAL (decl) = 1;\n+  TREE_STATIC (decl) = 1;\n+  TREE_PUBLIC (decl) = 0;\n+  bind (reduction_id, decl, current_scope, true, false, BUILTINS_LOCATION);\n+  return decl;\n+}\n+\n+/* Lookup REDUCTION_ID in the first scope where it has entry for TYPE.  */\n+\n+tree\n+c_omp_reduction_lookup (tree reduction_id, tree type)\n+{\n+  struct c_binding *b = I_SYMBOL_BINDING (reduction_id);\n+  while (b)\n+    {\n+      tree t;\n+      for (t = DECL_INITIAL (b->decl); t; t = TREE_CHAIN (t))\n+\tif (comptypes (TREE_PURPOSE (t), type))\n+\t  return TREE_VALUE (t);\n+      b = b->shadowed;\n+    }\n+  return error_mark_node;\n+}\n+\n+/* Helper function called via walk_tree, to diagnose invalid\n+   #pragma omp declare reduction combiners or initializers.  */\n+\n+tree\n+c_check_omp_declare_reduction_r (tree *tp, int *, void *data)\n+{\n+  tree *vars = (tree *) data;\n+  if (SSA_VAR_P (*tp)\n+      && !DECL_ARTIFICIAL (*tp)\n+      && *tp != vars[0]\n+      && *tp != vars[1])\n+    {\n+      location_t loc = DECL_SOURCE_LOCATION (vars[0]);\n+      if (strcmp (IDENTIFIER_POINTER (DECL_NAME (vars[0])), \"omp_out\") == 0)\n+\terror_at (loc, \"%<#pragma omp declare reduction%> combiner refers to \"\n+\t\t       \"variable %qD which is not %<omp_out%> nor %<omp_in%>\",\n+\t\t  *tp);\n+      else\n+\terror_at (loc, \"%<#pragma omp declare reduction%> initializer refers \"\n+\t\t       \"to variable %qD which is not %<omp_priv%> nor \"\n+\t\t       \"%<omp_orig%>\",\n+\t\t  *tp);\n+      return *tp;\n+    }\n+  return NULL_TREE;\n+}\n+\n #include \"gt-c-c-decl.h\""}, {"sha": "cbd5d1fa643e08b314388b41ecdc30fcee7736f2", "filename": "gcc/c/c-lang.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Fc%2Fc-lang.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Fc%2Fc-lang.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-lang.h?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -55,5 +55,8 @@ struct GTY(()) language_function {\n   int warn_about_return_type;\n };\n \n+/* If non-zero, implicit \"omp declare target\" attribute is added into the\n+   attribute lists.  */\n+extern GTY(()) int current_omp_declare_target_attribute;\n \n #endif /* ! GCC_C_LANG_H */"}, {"sha": "8d609936107fd6348ea5989207332de3120f9a5a", "filename": "gcc/c/c-parser.c", "status": "modified", "additions": 3025, "deletions": 1043, "changes": 4068, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Fc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Fc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530"}, {"sha": "2565ccb4f15f78e795aca494a04547213cc521d2", "filename": "gcc/c/c-tree.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Fc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Fc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-tree.h?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -526,6 +526,8 @@ extern tree start_struct (location_t, enum tree_code, tree,\n \t\t\t  struct c_struct_parse_info **);\n extern void store_parm_decls (void);\n extern void store_parm_decls_from (struct c_arg_info *);\n+extern void temp_store_parm_decls (tree, tree);\n+extern void temp_pop_parm_decls (void);\n extern tree xref_tag (enum tree_code, tree);\n extern struct c_typespec parser_xref_tag (location_t, enum tree_code, tree);\n extern struct c_parm *build_c_parm (struct c_declspecs *, tree,\n@@ -637,9 +639,12 @@ extern tree c_begin_omp_parallel (void);\n extern tree c_finish_omp_parallel (location_t, tree, tree);\n extern tree c_begin_omp_task (void);\n extern tree c_finish_omp_task (location_t, tree, tree);\n+extern void c_finish_omp_cancel (location_t, tree);\n+extern void c_finish_omp_cancellation_point (location_t, tree);\n extern tree c_finish_omp_clauses (tree);\n extern tree c_build_va_arg (location_t, tree, tree);\n extern tree c_finish_transaction (location_t, tree, int);\n+extern bool c_tree_equal (tree, tree);\n \n /* Set to 0 at beginning of a function definition, set to 1 if\n    a return statement that specifies a return value is seen.  */\n@@ -663,6 +668,10 @@ extern enum machine_mode c_default_pointer_mode;\n /* In c-decl.c */\n extern void c_finish_incomplete_decl (tree);\n extern void c_write_global_declarations (void);\n+extern tree c_omp_reduction_id (enum tree_code, tree);\n+extern tree c_omp_reduction_decl (tree);\n+extern tree c_omp_reduction_lookup (tree, tree);\n+extern tree c_check_omp_declare_reduction_r (tree *, int *, void *);\n \n /* In c-errors.c */\n extern void pedwarn_c90 (location_t, int opt, const char *, ...) ATTRIBUTE_GCC_DIAG(3,4);"}, {"sha": "16e39b2ad7024481db22252e760c62253c88a379", "filename": "gcc/c/c-typeck.c", "status": "modified", "additions": 997, "deletions": 19, "changes": 1016, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Fc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Fc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -37,6 +37,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-iterator.h\"\n #include \"bitmap.h\"\n #include \"gimple.h\"\n+#include \"tree-inline.h\"\n #include \"c-family/c-objc.h\"\n #include \"c-family/c-common.h\"\n #include \"c-family/c-ubsan.h\"\n@@ -10692,20 +10693,555 @@ c_finish_omp_task (location_t loc, tree clauses, tree block)\n   return add_stmt (stmt);\n }\n \n+/* Generate GOMP_cancel call for #pragma omp cancel.  */\n+\n+void\n+c_finish_omp_cancel (location_t loc, tree clauses)\n+{\n+  tree fn = builtin_decl_explicit (BUILT_IN_GOMP_CANCEL);\n+  int mask = 0;\n+  if (find_omp_clause (clauses, OMP_CLAUSE_PARALLEL))\n+    mask = 1;\n+  else if (find_omp_clause (clauses, OMP_CLAUSE_FOR))\n+    mask = 2;\n+  else if (find_omp_clause (clauses, OMP_CLAUSE_SECTIONS))\n+    mask = 4;\n+  else if (find_omp_clause (clauses, OMP_CLAUSE_TASKGROUP))\n+    mask = 8;\n+  else\n+    {\n+      error_at (loc, \"%<#pragma omp cancel must specify one of \"\n+\t\t     \"%<parallel%>, %<for%>, %<sections%> or %<taskgroup%> \"\n+\t\t     \"clauses\");\n+      return;\n+    }\n+  tree ifc = find_omp_clause (clauses, OMP_CLAUSE_IF);\n+  if (ifc != NULL_TREE)\n+    {\n+      tree type = TREE_TYPE (OMP_CLAUSE_IF_EXPR (ifc));\n+      ifc = fold_build2_loc (OMP_CLAUSE_LOCATION (ifc), NE_EXPR,\n+\t\t\t     boolean_type_node, OMP_CLAUSE_IF_EXPR (ifc),\n+\t\t\t     build_zero_cst (type));\n+    }\n+  else\n+    ifc = boolean_true_node;\n+  tree stmt = build_call_expr_loc (loc, fn, 2,\n+\t\t\t\t   build_int_cst (integer_type_node, mask),\n+\t\t\t\t   ifc);\n+  add_stmt (stmt);\n+}\n+\n+/* Generate GOMP_cancellation_point call for\n+   #pragma omp cancellation point.  */\n+\n+void\n+c_finish_omp_cancellation_point (location_t loc, tree clauses)\n+{\n+  tree fn = builtin_decl_explicit (BUILT_IN_GOMP_CANCELLATION_POINT);\n+  int mask = 0;\n+  if (find_omp_clause (clauses, OMP_CLAUSE_PARALLEL))\n+    mask = 1;\n+  else if (find_omp_clause (clauses, OMP_CLAUSE_FOR))\n+    mask = 2;\n+  else if (find_omp_clause (clauses, OMP_CLAUSE_SECTIONS))\n+    mask = 4;\n+  else if (find_omp_clause (clauses, OMP_CLAUSE_TASKGROUP))\n+    mask = 8;\n+  else\n+    {\n+      error_at (loc, \"%<#pragma omp cancellation point must specify one of \"\n+\t\t     \"%<parallel%>, %<for%>, %<sections%> or %<taskgroup%> \"\n+\t\t     \"clauses\");\n+      return;\n+    }\n+  tree stmt = build_call_expr_loc (loc, fn, 1,\n+\t\t\t\t   build_int_cst (integer_type_node, mask));\n+  add_stmt (stmt);\n+}\n+\n+/* Helper function for handle_omp_array_sections.  Called recursively\n+   to handle multiple array-section-subscripts.  C is the clause,\n+   T current expression (initially OMP_CLAUSE_DECL), which is either\n+   a TREE_LIST for array-section-subscript (TREE_PURPOSE is low-bound\n+   expression if specified, TREE_VALUE length expression if specified,\n+   TREE_CHAIN is what it has been specified after, or some decl.\n+   TYPES vector is populated with array section types, MAYBE_ZERO_LEN\n+   set to true if any of the array-section-subscript could have length\n+   of zero (explicit or implicit), FIRST_NON_ONE is the index of the\n+   first array-section-subscript which is known not to have length\n+   of one.  Given say:\n+   map(a[:b][2:1][:c][:2][:d][e:f][2:5])\n+   FIRST_NON_ONE will be 3, array-section-subscript [:b], [2:1] and [:c]\n+   all are or may have length of 1, array-section-subscript [:2] is the\n+   first one knonwn not to have length 1.  For array-section-subscript\n+   <= FIRST_NON_ONE we diagnose non-contiguous arrays if low bound isn't\n+   0 or length isn't the array domain max + 1, for > FIRST_NON_ONE we\n+   can if MAYBE_ZERO_LEN is false.  MAYBE_ZERO_LEN will be true in the above\n+   case though, as some lengths could be zero.  */\n+\n+static tree\n+handle_omp_array_sections_1 (tree c, tree t, vec<tree> &types,\n+\t\t\t     bool &maybe_zero_len, unsigned int &first_non_one)\n+{\n+  tree ret, low_bound, length, type;\n+  if (TREE_CODE (t) != TREE_LIST)\n+    {\n+      if (t == error_mark_node || TREE_TYPE (t) == error_mark_node)\n+\treturn error_mark_node;\n+      if (TREE_CODE (t) != VAR_DECL && TREE_CODE (t) != PARM_DECL)\n+\t{\n+\t  if (DECL_P (t))\n+\t    error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t      \"%qD is not a variable in %qs clause\", t,\n+\t\t      omp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n+\t  else\n+\t    error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t      \"%qE is not a variable in %qs clause\", t,\n+\t\t      omp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n+\t  return error_mark_node;\n+\t}\n+      else if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_DEPEND\n+\t       && TREE_CODE (t) == VAR_DECL && DECL_THREAD_LOCAL_P (t))\n+\t{\n+\t  error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t    \"%qD is threadprivate variable in %qs clause\", t,\n+\t\t    omp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n+\t  return error_mark_node;\n+\t}\n+      return t;\n+    }\n+\n+  ret = handle_omp_array_sections_1 (c, TREE_CHAIN (t), types,\n+\t\t\t\t     maybe_zero_len, first_non_one);\n+  if (ret == error_mark_node || ret == NULL_TREE)\n+    return ret;\n+\n+  type = TREE_TYPE (ret);\n+  low_bound = TREE_PURPOSE (t);\n+  length = TREE_VALUE (t);\n+\n+  if (low_bound == error_mark_node || length == error_mark_node)\n+    return error_mark_node;\n+\n+  if (low_bound && !INTEGRAL_TYPE_P (TREE_TYPE (low_bound)))\n+    {\n+      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\"low bound %qE of array section does not have integral type\",\n+\t\tlow_bound);\n+      return error_mark_node;\n+    }\n+  if (length && !INTEGRAL_TYPE_P (TREE_TYPE (length)))\n+    {\n+      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\"length %qE of array section does not have integral type\",\n+\t\tlength);\n+      return error_mark_node;\n+    }\n+  if (low_bound\n+      && TREE_CODE (low_bound) == INTEGER_CST\n+      && TYPE_PRECISION (TREE_TYPE (low_bound))\n+\t > TYPE_PRECISION (sizetype))\n+    low_bound = fold_convert (sizetype, low_bound);\n+  if (length\n+      && TREE_CODE (length) == INTEGER_CST\n+      && TYPE_PRECISION (TREE_TYPE (length))\n+\t > TYPE_PRECISION (sizetype))\n+    length = fold_convert (sizetype, length);\n+  if (low_bound == NULL_TREE)\n+    low_bound = integer_zero_node;\n+\n+  if (length != NULL_TREE)\n+    {\n+      if (!integer_nonzerop (length))\n+\tmaybe_zero_len = true;\n+      if (first_non_one == types.length ()\n+\t  && (TREE_CODE (length) != INTEGER_CST || integer_onep (length)))\n+\tfirst_non_one++;\n+    }\n+  if (TREE_CODE (type) == ARRAY_TYPE)\n+    {\n+      if (length == NULL_TREE\n+\t  && (TYPE_DOMAIN (type) == NULL_TREE\n+\t      || TYPE_MAX_VALUE (TYPE_DOMAIN (type)) == NULL_TREE))\n+\t{\n+\t  error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t    \"for unknown bound array type length expression must \"\n+\t\t    \"be specified\");\n+\t  return error_mark_node;\n+\t}\n+      if (TREE_CODE (low_bound) == INTEGER_CST\n+\t  && tree_int_cst_sgn (low_bound) == -1)\n+\t{\n+\t  error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t    \"negative low bound in array section in %qs clause\",\n+\t\t    omp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n+\t  return error_mark_node;\n+\t}\n+      if (length != NULL_TREE\n+\t  && TREE_CODE (length) == INTEGER_CST\n+\t  && tree_int_cst_sgn (length) == -1)\n+\t{\n+\t  error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t    \"negative length in array section in %qs clause\",\n+\t\t    omp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n+\t  return error_mark_node;\n+\t}\n+      if (TYPE_DOMAIN (type)\n+\t  && TYPE_MAX_VALUE (TYPE_DOMAIN (type))\n+\t  && TREE_CODE (TYPE_MAX_VALUE (TYPE_DOMAIN (type)))\n+\t\t\t== INTEGER_CST)\n+\t{\n+\t  tree size = size_binop (PLUS_EXPR,\n+\t\t\t\t  TYPE_MAX_VALUE (TYPE_DOMAIN (type)),\n+\t\t\t\t  size_one_node);\n+\t  if (TREE_CODE (low_bound) == INTEGER_CST)\n+\t    {\n+\t      if (tree_int_cst_lt (size, low_bound))\n+\t\t{\n+\t\t  error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t    \"low bound %qE above array section size \"\n+\t\t\t    \"in %qs clause\", low_bound,\n+\t\t\t    omp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n+\t\t  return error_mark_node;\n+\t\t}\n+\t      if (tree_int_cst_equal (size, low_bound))\n+\t\tmaybe_zero_len = true;\n+\t      else if (length == NULL_TREE\n+\t\t       && first_non_one == types.length ()\n+\t\t       && tree_int_cst_equal\n+\t\t\t    (TYPE_MAX_VALUE (TYPE_DOMAIN (type)),\n+\t\t\t     low_bound))\n+\t\tfirst_non_one++;\n+\t    }\n+\t  else if (length == NULL_TREE)\n+\t    {\n+\t      maybe_zero_len = true;\n+\t      if (first_non_one == types.length ())\n+\t\tfirst_non_one++;\n+\t    }\n+\t  if (length && TREE_CODE (length) == INTEGER_CST)\n+\t    {\n+\t      if (tree_int_cst_lt (size, length))\n+\t\t{\n+\t\t  error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t    \"length %qE above array section size \"\n+\t\t\t    \"in %qs clause\", length,\n+\t\t\t    omp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n+\t\t  return error_mark_node;\n+\t\t}\n+\t      if (TREE_CODE (low_bound) == INTEGER_CST)\n+\t\t{\n+\t\t  tree lbpluslen\n+\t\t    = size_binop (PLUS_EXPR,\n+\t\t\t\t  fold_convert (sizetype, low_bound),\n+\t\t\t\t  fold_convert (sizetype, length));\n+\t\t  if (TREE_CODE (lbpluslen) == INTEGER_CST\n+\t\t      && tree_int_cst_lt (size, lbpluslen))\n+\t\t    {\n+\t\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\t\"high bound %qE above array section size \"\n+\t\t\t\t\"in %qs clause\", lbpluslen,\n+\t\t\t\tomp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n+\t\t      return error_mark_node;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+      else if (length == NULL_TREE)\n+\t{\n+\t  maybe_zero_len = true;\n+\t  if (first_non_one == types.length ())\n+\t    first_non_one++;\n+\t}\n+\n+      /* For [lb:] we will need to evaluate lb more than once.  */\n+      if (length == NULL_TREE && OMP_CLAUSE_CODE (c) != OMP_CLAUSE_DEPEND)\n+\t{\n+\t  tree lb = c_save_expr (low_bound);\n+\t  if (lb != low_bound)\n+\t    {\n+\t      TREE_PURPOSE (t) = lb;\n+\t      low_bound = lb;\n+\t    }\n+\t}\n+    }\n+  else if (TREE_CODE (type) == POINTER_TYPE)\n+    {\n+      if (length == NULL_TREE)\n+\t{\n+\t  error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t    \"for pointer type length expression must be specified\");\n+\t  return error_mark_node;\n+\t}\n+      /* If there is a pointer type anywhere but in the very first\n+\t array-section-subscript, the array section can't be contiguous.  */\n+      if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_DEPEND\n+\t  && TREE_CODE (TREE_CHAIN (t)) == TREE_LIST)\n+\t{\n+\t  error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t    \"array section is not contiguous in %qs clause\",\n+\t\t    omp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n+\t  return error_mark_node;\n+\t}\n+    }\n+  else\n+    {\n+      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\"%qE does not have pointer or array type\", ret);\n+      return error_mark_node;\n+    }\n+  if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_DEPEND)\n+    types.safe_push (TREE_TYPE (ret));\n+  /* We will need to evaluate lb more than once.  */\n+  tree lb = c_save_expr (low_bound);\n+  if (lb != low_bound)\n+    {\n+      TREE_PURPOSE (t) = lb;\n+      low_bound = lb;\n+    }\n+  ret = build_array_ref (OMP_CLAUSE_LOCATION (c), ret, low_bound);\n+  return ret;\n+}\n+\n+/* Handle array sections for clause C.  */\n+\n+static bool\n+handle_omp_array_sections (tree c)\n+{\n+  bool maybe_zero_len = false;\n+  unsigned int first_non_one = 0;\n+  vec<tree> types = vNULL;\n+  tree first = handle_omp_array_sections_1 (c, OMP_CLAUSE_DECL (c), types,\n+\t\t\t\t\t    maybe_zero_len, first_non_one);\n+  if (first == error_mark_node)\n+    {\n+      types.release ();\n+      return true;\n+    }\n+  if (first == NULL_TREE)\n+    {\n+      types.release ();\n+      return false;\n+    }\n+  if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_DEPEND)\n+    {\n+      tree t = OMP_CLAUSE_DECL (c);\n+      tree tem = NULL_TREE;\n+      types.release ();\n+      /* Need to evaluate side effects in the length expressions\n+\t if any.  */\n+      while (TREE_CODE (t) == TREE_LIST)\n+\t{\n+\t  if (TREE_VALUE (t) && TREE_SIDE_EFFECTS (TREE_VALUE (t)))\n+\t    {\n+\t      if (tem == NULL_TREE)\n+\t\ttem = TREE_VALUE (t);\n+\t      else\n+\t\ttem = build2 (COMPOUND_EXPR, TREE_TYPE (tem),\n+\t\t\t      TREE_VALUE (t), tem);\n+\t    }\n+\t  t = TREE_CHAIN (t);\n+\t}\n+      if (tem)\n+\tfirst = build2 (COMPOUND_EXPR, TREE_TYPE (first), tem, first);\n+      first = c_fully_fold (first, false, NULL);\n+      OMP_CLAUSE_DECL (c) = first;\n+    }\n+  else\n+    {\n+      unsigned int num = types.length (), i;\n+      tree t, side_effects = NULL_TREE, size = NULL_TREE;\n+      tree condition = NULL_TREE;\n+\n+      if (int_size_in_bytes (TREE_TYPE (first)) <= 0)\n+\tmaybe_zero_len = true;\n+\n+      for (i = num, t = OMP_CLAUSE_DECL (c); i > 0;\n+\t   t = TREE_CHAIN (t))\n+\t{\n+\t  tree low_bound = TREE_PURPOSE (t);\n+\t  tree length = TREE_VALUE (t);\n+\n+\t  i--;\n+\t  if (low_bound\n+\t      && TREE_CODE (low_bound) == INTEGER_CST\n+\t      && TYPE_PRECISION (TREE_TYPE (low_bound))\n+\t\t > TYPE_PRECISION (sizetype))\n+\t    low_bound = fold_convert (sizetype, low_bound);\n+\t  if (length\n+\t      && TREE_CODE (length) == INTEGER_CST\n+\t      && TYPE_PRECISION (TREE_TYPE (length))\n+\t\t > TYPE_PRECISION (sizetype))\n+\t    length = fold_convert (sizetype, length);\n+\t  if (low_bound == NULL_TREE)\n+\t    low_bound = integer_zero_node;\n+\t  if (!maybe_zero_len && i > first_non_one)\n+\t    {\n+\t      if (integer_nonzerop (low_bound))\n+\t\tgoto do_warn_noncontiguous;\n+\t      if (length != NULL_TREE\n+\t\t  && TREE_CODE (length) == INTEGER_CST\n+\t\t  && TYPE_DOMAIN (types[i])\n+\t\t  && TYPE_MAX_VALUE (TYPE_DOMAIN (types[i]))\n+\t\t  && TREE_CODE (TYPE_MAX_VALUE (TYPE_DOMAIN (types[i])))\n+\t\t     == INTEGER_CST)\n+\t\t{\n+\t\t  tree size;\n+\t\t  size = size_binop (PLUS_EXPR,\n+\t\t\t\t     TYPE_MAX_VALUE (TYPE_DOMAIN (types[i])),\n+\t\t\t\t     size_one_node);\n+\t\t  if (!tree_int_cst_equal (length, size))\n+\t\t    {\n+\t\t     do_warn_noncontiguous:\n+\t\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\t\"array section is not contiguous in %qs \"\n+\t\t\t\t\"clause\",\n+\t\t\t\tomp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n+\t\t      types.release ();\n+\t\t      return true;\n+\t\t    }\n+\t\t}\n+\t      if (length != NULL_TREE\n+\t\t  && TREE_SIDE_EFFECTS (length))\n+\t\t{\n+\t\t  if (side_effects == NULL_TREE)\n+\t\t    side_effects = length;\n+\t\t  else\n+\t\t    side_effects = build2 (COMPOUND_EXPR,\n+\t\t\t\t\t   TREE_TYPE (side_effects),\n+\t\t\t\t\t   length, side_effects);\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      tree l;\n+\n+\t      if (i > first_non_one && length && integer_nonzerop (length))\n+\t\tcontinue;\n+\t      if (length)\n+\t\tl = fold_convert (sizetype, length);\n+\t      else\n+\t\t{\n+\t\t  l = size_binop (PLUS_EXPR,\n+\t\t\t\t  TYPE_MAX_VALUE (TYPE_DOMAIN (types[i])),\n+\t\t\t\t  size_one_node);\n+\t\t  l = size_binop (MINUS_EXPR, l,\n+\t\t\t\t  fold_convert (sizetype, low_bound));\n+\t\t}\n+\t      if (i > first_non_one)\n+\t\t{\n+\t\t  l = fold_build2 (NE_EXPR, boolean_type_node, l,\n+\t\t\t\t   size_zero_node);\n+\t\t  if (condition == NULL_TREE)\n+\t\t    condition = l;\n+\t\t  else\n+\t\t    condition = fold_build2 (BIT_AND_EXPR, boolean_type_node,\n+\t\t\t\t\t     l, condition);\n+\t\t}\n+\t      else if (size == NULL_TREE)\n+\t\t{\n+\t\t  size = size_in_bytes (TREE_TYPE (types[i]));\n+\t\t  size = size_binop (MULT_EXPR, size, l);\n+\t\t  if (condition)\n+\t\t    size = fold_build3 (COND_EXPR, sizetype, condition,\n+\t\t\t\t\tsize, size_zero_node);\n+\t\t}\n+\t      else\n+\t\tsize = size_binop (MULT_EXPR, size, l);\n+\t    }\n+\t}\n+      types.release ();\n+      if (side_effects)\n+\tsize = build2 (COMPOUND_EXPR, sizetype, side_effects, size);\n+      first = c_fully_fold (first, false, NULL);\n+      OMP_CLAUSE_DECL (c) = first;\n+      if (size)\n+\tsize = c_fully_fold (size, false, NULL);\n+      OMP_CLAUSE_SIZE (c) = size;\n+      if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_MAP)\n+\treturn false;\n+      tree c2 = build_omp_clause (OMP_CLAUSE_LOCATION (c), OMP_CLAUSE_MAP);\n+      OMP_CLAUSE_MAP_KIND (c2) = OMP_CLAUSE_MAP_POINTER;\n+      if (!c_mark_addressable (t))\n+\treturn false;\n+      OMP_CLAUSE_DECL (c2) = t;\n+      t = build_fold_addr_expr (first);\n+      t = fold_convert_loc (OMP_CLAUSE_LOCATION (c), ptrdiff_type_node, t);\n+      tree ptr = OMP_CLAUSE_DECL (c2);\n+      if (!POINTER_TYPE_P (TREE_TYPE (ptr)))\n+\tptr = build_fold_addr_expr (ptr);\n+      t = fold_build2_loc (OMP_CLAUSE_LOCATION (c), MINUS_EXPR,\n+\t\t\t   ptrdiff_type_node, t,\n+\t\t\t   fold_convert_loc (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\t\t     ptrdiff_type_node, ptr));\n+      t = c_fully_fold (t, false, NULL);\n+      OMP_CLAUSE_SIZE (c2) = t;\n+      OMP_CLAUSE_CHAIN (c2) = OMP_CLAUSE_CHAIN (c);\n+      OMP_CLAUSE_CHAIN (c) = c2;\n+    }\n+  return false;\n+}\n+\n+/* Helper function of finish_omp_clauses.  Clone STMT as if we were making\n+   an inline call.  But, remap\n+   the OMP_DECL1 VAR_DECL (omp_out resp. omp_orig) to PLACEHOLDER\n+   and OMP_DECL2 VAR_DECL (omp_in resp. omp_priv) to DECL.  */\n+\n+static tree\n+c_clone_omp_udr (tree stmt, tree omp_decl1, tree omp_decl2,\n+\t\t tree decl, tree placeholder)\n+{\n+  copy_body_data id;\n+  struct pointer_map_t *decl_map = pointer_map_create ();\n+\n+  *pointer_map_insert (decl_map, omp_decl1) = placeholder;\n+  *pointer_map_insert (decl_map, omp_decl2) = decl;\n+  memset (&id, 0, sizeof (id));\n+  id.src_fn = DECL_CONTEXT (omp_decl1);\n+  id.dst_fn = current_function_decl;\n+  id.src_cfun = DECL_STRUCT_FUNCTION (id.src_fn);\n+  id.decl_map = decl_map;\n+\n+  id.copy_decl = copy_decl_no_change;\n+  id.transform_call_graph_edges = CB_CGE_DUPLICATE;\n+  id.transform_new_cfg = true;\n+  id.transform_return_to_modify = false;\n+  id.transform_lang_insert_block = NULL;\n+  id.eh_lp_nr = 0;\n+  walk_tree (&stmt, copy_tree_body_r, &id, NULL);\n+  pointer_map_destroy (decl_map);\n+  return stmt;\n+}\n+\n+/* Helper function of c_finish_omp_clauses, called via walk_tree.\n+   Find OMP_CLAUSE_PLACEHOLDER (passed in DATA) in *TP.  */\n+\n+static tree\n+c_find_omp_placeholder_r (tree *tp, int *, void *data)\n+{\n+  if (*tp == (tree) data)\n+    return *tp;\n+  return NULL_TREE;\n+}\n+\n /* For all elements of CLAUSES, validate them vs OpenMP constraints.\n    Remove any elements from the list that are invalid.  */\n \n tree\n c_finish_omp_clauses (tree clauses)\n {\n   bitmap_head generic_head, firstprivate_head, lastprivate_head;\n+  bitmap_head aligned_head;\n   tree c, t, *pc = &clauses;\n-  const char *name;\n+  bool branch_seen = false;\n+  bool copyprivate_seen = false;\n+  tree *nowait_clause = NULL;\n \n   bitmap_obstack_initialize (NULL);\n   bitmap_initialize (&generic_head, &bitmap_default_obstack);\n   bitmap_initialize (&firstprivate_head, &bitmap_default_obstack);\n   bitmap_initialize (&lastprivate_head, &bitmap_default_obstack);\n+  bitmap_initialize (&aligned_head, &bitmap_default_obstack);\n \n   for (pc = &clauses, c = clauses; c ; c = *pc)\n     {\n@@ -10716,28 +11252,19 @@ c_finish_omp_clauses (tree clauses)\n       switch (OMP_CLAUSE_CODE (c))\n \t{\n \tcase OMP_CLAUSE_SHARED:\n-\t  name = \"shared\";\n \t  need_implicitly_determined = true;\n \t  goto check_dup_generic;\n \n \tcase OMP_CLAUSE_PRIVATE:\n-\t  name = \"private\";\n \t  need_complete = true;\n \t  need_implicitly_determined = true;\n \t  goto check_dup_generic;\n \n \tcase OMP_CLAUSE_REDUCTION:\n-\t  name = \"reduction\";\n \t  need_implicitly_determined = true;\n \t  t = OMP_CLAUSE_DECL (c);\n-\t  if (AGGREGATE_TYPE_P (TREE_TYPE (t))\n-\t      || POINTER_TYPE_P (TREE_TYPE (t)))\n-\t    {\n-\t      error_at (OMP_CLAUSE_LOCATION (c),\n-\t\t\t\"%qE has invalid type for %<reduction%>\", t);\n-\t      remove = true;\n-\t    }\n-\t  else if (FLOAT_TYPE_P (TREE_TYPE (t)))\n+\t  if (OMP_CLAUSE_REDUCTION_PLACEHOLDER (c) == NULL_TREE\n+\t      && FLOAT_TYPE_P (TREE_TYPE (t)))\n \t    {\n \t      enum tree_code r_code = OMP_CLAUSE_REDUCTION_CODE (c);\n \t      const char *r_name = NULL;\n@@ -10776,14 +11303,88 @@ c_finish_omp_clauses (tree clauses)\n \t\t  remove = true;\n \t\t}\n \t    }\n+\t  else if (OMP_CLAUSE_REDUCTION_PLACEHOLDER (c) == error_mark_node)\n+\t    {\n+\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\"user defined reduction not found for %qD\", t);\n+\t      remove = true;\n+\t    }\n+\t  else if (OMP_CLAUSE_REDUCTION_PLACEHOLDER (c))\n+\t    {\n+\t      tree list = OMP_CLAUSE_REDUCTION_PLACEHOLDER (c);\n+\t      tree type = TYPE_MAIN_VARIANT (TREE_TYPE (t));\n+\t      tree placeholder = build_decl (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\t\t     VAR_DECL, NULL_TREE, type);\n+\t      OMP_CLAUSE_REDUCTION_PLACEHOLDER (c) = placeholder;\n+\t      DECL_ARTIFICIAL (placeholder) = 1;\n+\t      DECL_IGNORED_P (placeholder) = 1;\n+\t      if (TREE_ADDRESSABLE (TREE_VEC_ELT (list, 0)))\n+\t\tc_mark_addressable (placeholder);\n+\t      if (TREE_ADDRESSABLE (TREE_VEC_ELT (list, 1)))\n+\t\tc_mark_addressable (OMP_CLAUSE_DECL (c));\n+\t      OMP_CLAUSE_REDUCTION_MERGE (c)\n+\t\t= c_clone_omp_udr (TREE_VEC_ELT (list, 2),\n+\t\t\t\t   TREE_VEC_ELT (list, 0),\n+\t\t\t\t   TREE_VEC_ELT (list, 1),\n+\t\t\t\t   OMP_CLAUSE_DECL (c), placeholder);\n+\t      OMP_CLAUSE_REDUCTION_MERGE (c)\n+\t\t= build3_loc (OMP_CLAUSE_LOCATION (c), BIND_EXPR,\n+\t\t\t      void_type_node, NULL_TREE,\n+\t\t\t       OMP_CLAUSE_REDUCTION_MERGE (c), NULL_TREE);\n+\t      TREE_SIDE_EFFECTS (OMP_CLAUSE_REDUCTION_MERGE (c)) = 1;\n+\t      if (TREE_VEC_LENGTH (list) == 6)\n+\t\t{\n+\t\t  if (TREE_ADDRESSABLE (TREE_VEC_ELT (list, 3)))\n+\t\t    c_mark_addressable (OMP_CLAUSE_DECL (c));\n+\t\t  if (TREE_ADDRESSABLE (TREE_VEC_ELT (list, 4)))\n+\t\t    c_mark_addressable (placeholder);\n+\t\t  tree init = TREE_VEC_ELT (list, 5);\n+\t\t  if (init == error_mark_node)\n+\t\t    init = DECL_INITIAL (TREE_VEC_ELT (list, 3));\n+\t\t  OMP_CLAUSE_REDUCTION_INIT (c)\n+\t\t    = c_clone_omp_udr (init, TREE_VEC_ELT (list, 4),\n+\t\t\t\t       TREE_VEC_ELT (list, 3),\n+\t\t\t\t       OMP_CLAUSE_DECL (c), placeholder);\n+\t\t  if (TREE_VEC_ELT (list, 5) == error_mark_node)\n+\t\t    OMP_CLAUSE_REDUCTION_INIT (c)\n+\t\t      = build2 (INIT_EXPR, TREE_TYPE (t), t,\n+\t\t\t\tOMP_CLAUSE_REDUCTION_INIT (c));\n+\t\t  if (walk_tree (&OMP_CLAUSE_REDUCTION_INIT (c),\n+\t\t\t\t c_find_omp_placeholder_r,\n+\t\t\t\t placeholder, NULL))\n+\t\t    OMP_CLAUSE_REDUCTION_OMP_ORIG_REF (c) = 1;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  tree init;\n+\t\t  if (AGGREGATE_TYPE_P (TREE_TYPE (t)))\n+\t\t    init = build_constructor (TREE_TYPE (t), NULL);\n+\t\t  else\n+\t\t    init = fold_convert (TREE_TYPE (t), integer_zero_node);\n+\t\t  OMP_CLAUSE_REDUCTION_INIT (c)\n+\t\t    = build2 (INIT_EXPR, TREE_TYPE (t), t, init);\n+\t\t}\n+\t      OMP_CLAUSE_REDUCTION_INIT (c)\n+\t\t= build3_loc (OMP_CLAUSE_LOCATION (c), BIND_EXPR,\n+\t\t\t      void_type_node, NULL_TREE,\n+\t\t\t       OMP_CLAUSE_REDUCTION_INIT (c), NULL_TREE);\n+\t      TREE_SIDE_EFFECTS (OMP_CLAUSE_REDUCTION_INIT (c)) = 1;\n+\t    }\n \t  goto check_dup_generic;\n \n \tcase OMP_CLAUSE_COPYPRIVATE:\n-\t  name = \"copyprivate\";\n+\t  copyprivate_seen = true;\n+\t  if (nowait_clause)\n+\t    {\n+\t      error_at (OMP_CLAUSE_LOCATION (*nowait_clause),\n+\t\t\t\"%<nowait%> clause must not be used together \"\n+\t\t\t\"with %<copyprivate%>\");\n+\t      *nowait_clause = OMP_CLAUSE_CHAIN (*nowait_clause);\n+\t      nowait_clause = NULL;\n+\t    }\n \t  goto check_dup_generic;\n \n \tcase OMP_CLAUSE_COPYIN:\n-\t  name = \"copyin\";\n \t  t = OMP_CLAUSE_DECL (c);\n \t  if (TREE_CODE (t) != VAR_DECL || !DECL_THREAD_LOCAL_P (t))\n \t    {\n@@ -10793,12 +11394,37 @@ c_finish_omp_clauses (tree clauses)\n \t    }\n \t  goto check_dup_generic;\n \n+\tcase OMP_CLAUSE_LINEAR:\n+\t  t = OMP_CLAUSE_DECL (c);\n+\t  if (!INTEGRAL_TYPE_P (TREE_TYPE (t))\n+\t      && TREE_CODE (TREE_TYPE (t)) != POINTER_TYPE)\n+\t    {\n+\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\"linear clause applied to non-integral non-pointer \"\n+\t\t\t\"variable with type %qT\", TREE_TYPE (t));\n+\t      remove = true;\n+\t      break;\n+\t    }\n+\t  if (TREE_CODE (TREE_TYPE (OMP_CLAUSE_DECL (c))) == POINTER_TYPE)\n+\t    {\n+\t      tree s = OMP_CLAUSE_LINEAR_STEP (c);\n+\t      s = pointer_int_sum (OMP_CLAUSE_LOCATION (c), PLUS_EXPR,\n+\t\t\t\t   OMP_CLAUSE_DECL (c), s);\n+\t      s = fold_build2_loc (OMP_CLAUSE_LOCATION (c), MINUS_EXPR,\n+\t\t\t\t   sizetype, s, OMP_CLAUSE_DECL (c));\n+\t      if (s == error_mark_node)\n+\t\ts = size_one_node;\n+\t      OMP_CLAUSE_LINEAR_STEP (c) = s;\n+\t    }\n+\t  goto check_dup_generic;\n+\n \tcheck_dup_generic:\n \t  t = OMP_CLAUSE_DECL (c);\n \t  if (TREE_CODE (t) != VAR_DECL && TREE_CODE (t) != PARM_DECL)\n \t    {\n \t      error_at (OMP_CLAUSE_LOCATION (c),\n-\t\t\t\"%qE is not a variable in clause %qs\", t, name);\n+\t\t\t\"%qE is not a variable in clause %qs\", t,\n+\t\t\tomp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n \t      remove = true;\n \t    }\n \t  else if (bitmap_bit_p (&generic_head, DECL_UID (t))\n@@ -10814,7 +11440,6 @@ c_finish_omp_clauses (tree clauses)\n \t  break;\n \n \tcase OMP_CLAUSE_FIRSTPRIVATE:\n-\t  name = \"firstprivate\";\n \t  t = OMP_CLAUSE_DECL (c);\n \t  need_complete = true;\n \t  need_implicitly_determined = true;\n@@ -10836,7 +11461,6 @@ c_finish_omp_clauses (tree clauses)\n \t  break;\n \n \tcase OMP_CLAUSE_LASTPRIVATE:\n-\t  name = \"lastprivate\";\n \t  t = OMP_CLAUSE_DECL (c);\n \t  need_complete = true;\n \t  need_implicitly_determined = true;\n@@ -10857,16 +11481,167 @@ c_finish_omp_clauses (tree clauses)\n \t    bitmap_set_bit (&lastprivate_head, DECL_UID (t));\n \t  break;\n \n+\tcase OMP_CLAUSE_ALIGNED:\n+\t  t = OMP_CLAUSE_DECL (c);\n+\t  if (TREE_CODE (t) != VAR_DECL && TREE_CODE (t) != PARM_DECL)\n+\t    {\n+\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\"%qE is not a variable in %<aligned%> clause\", t);\n+\t      remove = true;\n+\t    }\n+\t  else if (bitmap_bit_p (&aligned_head, DECL_UID (t)))\n+\t    {\n+\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\"%qE appears more than once in %<aligned%> clauses\",\n+\t\t\tt);\n+\t      remove = true;\n+\t    }\n+\t  else\n+\t    bitmap_set_bit (&aligned_head, DECL_UID (t));\n+\t  break;\n+\n+\tcase OMP_CLAUSE_DEPEND:\n+\t  t = OMP_CLAUSE_DECL (c);\n+\t  if (TREE_CODE (t) == TREE_LIST)\n+\t    {\n+\t      if (handle_omp_array_sections (c))\n+\t\tremove = true;\n+\t      break;\n+\t    }\n+\t  if (t == error_mark_node)\n+\t    remove = true;\n+\t  else if (TREE_CODE (t) != VAR_DECL && TREE_CODE (t) != PARM_DECL)\n+\t    {\n+\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\"%qE is not a variable in %<depend%> clause\", t);\n+\t      remove = true;\n+\t    }\n+\t  else if (!c_mark_addressable (t))\n+\t    remove = true;\n+\t  break;\n+\n+\tcase OMP_CLAUSE_MAP:\n+\tcase OMP_CLAUSE_TO:\n+\tcase OMP_CLAUSE_FROM:\n+\t  t = OMP_CLAUSE_DECL (c);\n+\t  if (TREE_CODE (t) == TREE_LIST)\n+\t    {\n+\t      if (handle_omp_array_sections (c))\n+\t\tremove = true;\n+\t      else\n+\t\t{\n+\t\t  t = OMP_CLAUSE_DECL (c);\n+\t\t  if (!COMPLETE_TYPE_P (TREE_TYPE (t)))\n+\t\t    {\n+\t\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\t\"array section does not have mappable type \"\n+\t\t\t\t\"in %qs clause\",\n+\t\t\t\tomp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n+\t\t      remove = true;\n+\t\t    }\n+\t\t}\n+\t      break;\n+\t    }\n+\t  if (t == error_mark_node)\n+\t    remove = true;\n+\t  else if (TREE_CODE (t) != VAR_DECL && TREE_CODE (t) != PARM_DECL)\n+\t    {\n+\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\"%qE is not a variable in %qs clause\", t,\n+\t\t\tomp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n+\t      remove = true;\n+\t    }\n+\t  else if (TREE_CODE (t) == VAR_DECL && DECL_THREAD_LOCAL_P (t))\n+\t    {\n+\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\"%qD is threadprivate variable in %qs clause\", t,\n+\t\t\tomp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n+\t      remove = true;\n+\t    }\n+\t  else if (!c_mark_addressable (t))\n+\t    remove = true;\n+\t  else if (!COMPLETE_TYPE_P (TREE_TYPE (t))\n+\t\t   && !(OMP_CLAUSE_CODE (c) == OMP_CLAUSE_MAP\n+\t\t\t&& OMP_CLAUSE_MAP_KIND (c) == OMP_CLAUSE_MAP_POINTER))\n+\t    {\n+\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\"%qD does not have a mappable type in %qs clause\", t,\n+\t\t\tomp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n+\t      remove = true;\n+\t    }\n+\t  else if (bitmap_bit_p (&generic_head, DECL_UID (t)))\n+\t    {\n+\t      if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_MAP)\n+\t\terror (\"%qD appears more than once in motion clauses\", t);\n+\t      else\n+\t\terror (\"%qD appears more than once in map clauses\", t);\n+\t      remove = true;\n+\t    }\n+\t  else\n+\t    bitmap_set_bit (&generic_head, DECL_UID (t));\n+\t  break;\n+\n+\tcase OMP_CLAUSE_UNIFORM:\n+\t  t = OMP_CLAUSE_DECL (c);\n+\t  if (TREE_CODE (t) != PARM_DECL)\n+\t    {\n+\t      if (DECL_P (t))\n+\t\terror_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t  \"%qD is not an argument in %<uniform%> clause\", t);\n+\t      else\n+\t\terror_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t  \"%qE is not an argument in %<uniform%> clause\", t);\n+\t      remove = true;\n+\t    }\n+\t  break;\n+\n+\tcase OMP_CLAUSE_NOWAIT:\n+\t  if (copyprivate_seen)\n+\t    {\n+\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\"%<nowait%> clause must not be used together \"\n+\t\t\t\"with %<copyprivate%>\");\n+\t      remove = true;\n+\t      break;\n+\t    }\n+\t  nowait_clause = pc;\n+\t  pc = &OMP_CLAUSE_CHAIN (c);\n+\t  continue;\n+\n \tcase OMP_CLAUSE_IF:\n \tcase OMP_CLAUSE_NUM_THREADS:\n+\tcase OMP_CLAUSE_NUM_TEAMS:\n+\tcase OMP_CLAUSE_THREAD_LIMIT:\n \tcase OMP_CLAUSE_SCHEDULE:\n-\tcase OMP_CLAUSE_NOWAIT:\n \tcase OMP_CLAUSE_ORDERED:\n \tcase OMP_CLAUSE_DEFAULT:\n \tcase OMP_CLAUSE_UNTIED:\n \tcase OMP_CLAUSE_COLLAPSE:\n \tcase OMP_CLAUSE_FINAL:\n \tcase OMP_CLAUSE_MERGEABLE:\n+\tcase OMP_CLAUSE_SAFELEN:\n+\tcase OMP_CLAUSE_SIMDLEN:\n+\tcase OMP_CLAUSE_DEVICE:\n+\tcase OMP_CLAUSE_DIST_SCHEDULE:\n+\tcase OMP_CLAUSE_PARALLEL:\n+\tcase OMP_CLAUSE_FOR:\n+\tcase OMP_CLAUSE_SECTIONS:\n+\tcase OMP_CLAUSE_TASKGROUP:\n+\tcase OMP_CLAUSE_PROC_BIND:\n+\t  pc = &OMP_CLAUSE_CHAIN (c);\n+\t  continue;\n+\n+\tcase OMP_CLAUSE_INBRANCH:\n+\tcase OMP_CLAUSE_NOTINBRANCH:\n+\t  if (branch_seen)\n+\t    {\n+\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\"%<inbranch%> clause is incompatible with \"\n+\t\t\t\"%<notinbranch%>\");\n+\t      remove = true;\n+\t      break;\n+\t    }\n+\t  branch_seen = true;\n \t  pc = &OMP_CLAUSE_CHAIN (c);\n \t  continue;\n \n@@ -10912,7 +11687,8 @@ c_finish_omp_clauses (tree clauses)\n \t\t{\n \t\t  error_at (OMP_CLAUSE_LOCATION (c),\n \t\t\t    \"%qE is predetermined %qs for %qs\",\n-\t\t\t    t, share_name, name);\n+\t\t\t    t, share_name,\n+\t\t\t    omp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n \t\t  remove = true;\n \t\t}\n \t    }\n@@ -11016,3 +11792,205 @@ c_build_va_arg (location_t loc, tree expr, tree type)\n \t\t\"C++ requires promoted type, not enum type, in %<va_arg%>\");\n   return build_va_arg (loc, expr, type);\n }\n+\n+/* Return truthvalue of whether T1 is the same tree structure as T2.\n+   Return 1 if they are the same. Return 0 if they are different.  */\n+\n+bool\n+c_tree_equal (tree t1, tree t2)\n+{\n+  enum tree_code code1, code2;\n+\n+  if (t1 == t2)\n+    return true;\n+  if (!t1 || !t2)\n+    return false;\n+\n+  for (code1 = TREE_CODE (t1);\n+       CONVERT_EXPR_CODE_P (code1)\n+\t || code1 == NON_LVALUE_EXPR;\n+       code1 = TREE_CODE (t1))\n+    t1 = TREE_OPERAND (t1, 0);\n+  for (code2 = TREE_CODE (t2);\n+       CONVERT_EXPR_CODE_P (code2)\n+\t || code2 == NON_LVALUE_EXPR;\n+       code2 = TREE_CODE (t2))\n+    t2 = TREE_OPERAND (t2, 0);\n+\n+  /* They might have become equal now.  */\n+  if (t1 == t2)\n+    return true;\n+\n+  if (code1 != code2)\n+    return false;\n+\n+  switch (code1)\n+    {\n+    case INTEGER_CST:\n+      return TREE_INT_CST_LOW (t1) == TREE_INT_CST_LOW (t2)\n+\t&& TREE_INT_CST_HIGH (t1) == TREE_INT_CST_HIGH (t2);\n+\n+    case REAL_CST:\n+      return REAL_VALUES_EQUAL (TREE_REAL_CST (t1), TREE_REAL_CST (t2));\n+\n+    case STRING_CST:\n+      return TREE_STRING_LENGTH (t1) == TREE_STRING_LENGTH (t2)\n+\t&& !memcmp (TREE_STRING_POINTER (t1), TREE_STRING_POINTER (t2),\n+\t\t    TREE_STRING_LENGTH (t1));\n+\n+    case FIXED_CST:\n+      return FIXED_VALUES_IDENTICAL (TREE_FIXED_CST (t1),\n+\t\t\t\t     TREE_FIXED_CST (t2));\n+\n+    case COMPLEX_CST:\n+      return c_tree_equal (TREE_REALPART (t1), TREE_REALPART (t2))\n+\t     && c_tree_equal (TREE_IMAGPART (t1), TREE_IMAGPART (t2));\n+\n+    case VECTOR_CST:\n+      return operand_equal_p (t1, t2, OEP_ONLY_CONST);\n+\n+    case CONSTRUCTOR:\n+      /* We need to do this when determining whether or not two\n+\t non-type pointer to member function template arguments\n+\t are the same.  */\n+      if (!comptypes (TREE_TYPE (t1), TREE_TYPE (t2))\n+\t  || CONSTRUCTOR_NELTS (t1) != CONSTRUCTOR_NELTS (t2))\n+\treturn false;\n+      {\n+\ttree field, value;\n+\tunsigned int i;\n+\tFOR_EACH_CONSTRUCTOR_ELT (CONSTRUCTOR_ELTS (t1), i, field, value)\n+\t  {\n+\t    constructor_elt *elt2 = CONSTRUCTOR_ELT (t2, i);\n+\t    if (!c_tree_equal (field, elt2->index)\n+\t\t|| !c_tree_equal (value, elt2->value))\n+\t      return false;\n+\t  }\n+      }\n+      return true;\n+\n+    case TREE_LIST:\n+      if (!c_tree_equal (TREE_PURPOSE (t1), TREE_PURPOSE (t2)))\n+\treturn false;\n+      if (!c_tree_equal (TREE_VALUE (t1), TREE_VALUE (t2)))\n+\treturn false;\n+      return c_tree_equal (TREE_CHAIN (t1), TREE_CHAIN (t2));\n+\n+    case SAVE_EXPR:\n+      return c_tree_equal (TREE_OPERAND (t1, 0), TREE_OPERAND (t2, 0));\n+\n+    case CALL_EXPR:\n+      {\n+\ttree arg1, arg2;\n+\tcall_expr_arg_iterator iter1, iter2;\n+\tif (!c_tree_equal (CALL_EXPR_FN (t1), CALL_EXPR_FN (t2)))\n+\t  return false;\n+\tfor (arg1 = first_call_expr_arg (t1, &iter1),\n+\t       arg2 = first_call_expr_arg (t2, &iter2);\n+\t     arg1 && arg2;\n+\t     arg1 = next_call_expr_arg (&iter1),\n+\t       arg2 = next_call_expr_arg (&iter2))\n+\t  if (!c_tree_equal (arg1, arg2))\n+\t    return false;\n+\tif (arg1 || arg2)\n+\t  return false;\n+\treturn true;\n+      }\n+\n+    case TARGET_EXPR:\n+      {\n+\ttree o1 = TREE_OPERAND (t1, 0);\n+\ttree o2 = TREE_OPERAND (t2, 0);\n+\n+\t/* Special case: if either target is an unallocated VAR_DECL,\n+\t   it means that it's going to be unified with whatever the\n+\t   TARGET_EXPR is really supposed to initialize, so treat it\n+\t   as being equivalent to anything.  */\n+\tif (TREE_CODE (o1) == VAR_DECL && DECL_NAME (o1) == NULL_TREE\n+\t    && !DECL_RTL_SET_P (o1))\n+\t  /*Nop*/;\n+\telse if (TREE_CODE (o2) == VAR_DECL && DECL_NAME (o2) == NULL_TREE\n+\t\t && !DECL_RTL_SET_P (o2))\n+\t  /*Nop*/;\n+\telse if (!c_tree_equal (o1, o2))\n+\t  return false;\n+\n+\treturn c_tree_equal (TREE_OPERAND (t1, 1), TREE_OPERAND (t2, 1));\n+      }\n+\n+    case COMPONENT_REF:\n+      if (TREE_OPERAND (t1, 1) != TREE_OPERAND (t2, 1))\n+\treturn false;\n+      return c_tree_equal (TREE_OPERAND (t1, 0), TREE_OPERAND (t2, 0));\n+\n+    case PARM_DECL:\n+    case VAR_DECL:\n+    case CONST_DECL:\n+    case FIELD_DECL:\n+    case FUNCTION_DECL:\n+    case IDENTIFIER_NODE:\n+    case SSA_NAME:\n+      return false;\n+\n+    case TREE_VEC:\n+      {\n+\tunsigned ix;\n+\tif (TREE_VEC_LENGTH (t1) != TREE_VEC_LENGTH (t2))\n+\t  return false;\n+\tfor (ix = TREE_VEC_LENGTH (t1); ix--;)\n+\t  if (!c_tree_equal (TREE_VEC_ELT (t1, ix),\n+\t\t\t     TREE_VEC_ELT (t2, ix)))\n+\t    return false;\n+\treturn true;\n+      }\n+\n+    default:\n+      break;\n+    }\n+\n+  switch (TREE_CODE_CLASS (code1))\n+    {\n+    case tcc_unary:\n+    case tcc_binary:\n+    case tcc_comparison:\n+    case tcc_expression:\n+    case tcc_vl_exp:\n+    case tcc_reference:\n+    case tcc_statement:\n+      {\n+\tint i, n = TREE_OPERAND_LENGTH (t1);\n+\n+\tswitch (code1)\n+\t  {\n+\t  case PREINCREMENT_EXPR:\n+\t  case PREDECREMENT_EXPR:\n+\t  case POSTINCREMENT_EXPR:\n+\t  case POSTDECREMENT_EXPR:\n+\t    n = 1;\n+\t    break;\n+\t  case ARRAY_REF:\n+\t    n = 2;\n+\t    break;\n+\t  default:\n+\t    break;\n+\t  }\n+\n+\tif (TREE_CODE_CLASS (code1) == tcc_vl_exp\n+\t    && n != TREE_OPERAND_LENGTH (t2))\n+\t  return false;\n+\n+\tfor (i = 0; i < n; ++i)\n+\t  if (!c_tree_equal (TREE_OPERAND (t1, i), TREE_OPERAND (t2, i)))\n+\t    return false;\n+\n+\treturn true;\n+      }\n+\n+    case tcc_type:\n+      return comptypes (t1, t2);\n+    default:\n+      gcc_unreachable ();\n+    }\n+  /* We can get here with --disable-checking.  */\n+  return false;\n+}"}, {"sha": "da49d12c629b9c4e6dc3e9a92d1c689bb24a07c6", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 169, "deletions": 0, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -1,3 +1,172 @@\n+2013-10-11  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* decl.c (duplicate_decls): Error out for redeclaration of UDRs.\n+\t(declare_simd_adjust_this): New function.\n+\t(grokfndecl): If \"omp declare simd\" attribute is present,\n+\tcall declare_simd_adjust_this if needed and\n+\tc_omp_declare_simd_clauses_to_numbers.\n+\t* cp-array-notation.c (expand_array_notation_exprs): Handle\n+\tOMP_TASKGROUP.\n+\t* cp-gimplify.c (cp_gimplify_expr): Handle OMP_SIMD and\n+\tOMP_DISTRIBUTE.  Handle is_invisiref_parm decls in\n+\tOMP_CLAUSE_REDUCTION.\n+\t(cp_genericize_r): Handle OMP_SIMD and OMP_DISTRIBUTE like\n+\tOMP_FOR.\n+\t(cxx_omp_privatize_by_reference): Return true for\n+\tis_invisiref_parm decls.\n+\t(cxx_omp_finish_clause): Adjust cxx_omp_create_clause_info\n+\tcaller.\n+\t* pt.c (apply_late_template_attributes): For \"omp declare simd\"\n+\tattribute call tsubst_omp_clauses,\n+\tc_omp_declare_simd_clauses_to_decls, finish_omp_clauses\n+\tand c_omp_declare_simd_clauses_to_numbers.\n+\t(instantiate_class_template_1): Call cp_check_omp_declare_reduction\n+\tfor UDRs.\n+\t(tsubst_decl): Handle UDRs.\n+\t(tsubst_omp_clauses): Add declare_simd argument, if true don't\n+\tcall finish_omp_clauses.  Handle new OpenMP 4.0 clauses.\n+\tHandle non-NULL OMP_CLAUSE_REDUCTION_PLACEHOLDER on\n+\tOMP_CLAUSE_REDUCTION.\n+\t(tsubst_expr): For UDRs call pushdecl and\n+\tcp_check_omp_declare_reduction.  Adjust tsubst_omp_clauses\n+\tcallers.  Handle OMP_SIMD, OMP_DISTRIBUTE, OMP_TEAMS,\n+\tOMP_TARGET_DATA, OMP_TARGET_UPDATE, OMP_TARGET, OMP_TASKGROUP.\n+\tAdjust finish_omp_atomic caller.\n+\t(tsubst_omp_udr): New function.\n+\t(instantiate_decl): For UDRs at block scope, don't call\n+\tstart_preparsed_function/finish_function.  Call tsubst_omp_udr.\n+\t* semantics.c (cxx_omp_create_clause_info): Add need_dtor argument,\n+\tuse it instead of need_default_ctor || need_copy_ctor.\n+\t(struct cp_check_omp_declare_reduction_data): New type.\n+\t(handle_omp_array_sections_1, handle_omp_array_sections,\n+\tomp_reduction_id, omp_reduction_lookup,\n+\tcp_remove_omp_priv_cleanup_stmt, cp_check_omp_declare_reduction_r,\n+\tcp_check_omp_declare_reduction, clone_omp_udr,\n+\tfind_omp_placeholder_r, finish_omp_reduction_clause): New functions.\n+\t(finish_omp_clauses): Handle new OpenMP 4.0 clauses and user defined\n+\treductions.\n+\t(finish_omp_for): Add CODE argument, use it instead of hardcoded\n+\tOMP_FOR.  Adjust c_finish_omp_for caller.\n+\t(finish_omp_atomic): Add seq_cst argument, adjust\n+\tc_finish_omp_atomic callers, handle seq_cst and new OpenMP 4.0\n+\tatomic variants.\n+\t(finish_omp_cancel, finish_omp_cancellation_point): New functions.\n+\t* decl2.c (mark_used): Force immediate instantiation of\n+\tDECL_OMP_DECLARE_REDUCTION_P decls.\n+\t(is_late_template_attribute): Return true for \"omp declare simd\"\n+\tattribute.\n+\t(cp_omp_mappable_type): New function.\n+\t(cplus_decl_attributes): Add implicit \"omp declare target\" attribute\n+\tif requested.\n+\t* parser.c (cp_debug_parser): Print\n+\tparser->colon_doesnt_start_class_def_p.\n+\t(cp_ensure_no_omp_declare_simd, cp_finalize_omp_declare_simd): New\n+\tfunctions.\n+\t(enum pragma_context): Add pragma_member and pragma_objc_icode.\n+\t(cp_parser_binary_expression): Handle no_toplevel_fold_p\n+\teven for binary operations other than comparison.\n+\t(cp_parser_linkage_specification): Call\n+\tcp_ensure_no_omp_declare_simd if needed.\n+\t(cp_parser_namespace_definition): Likewise.\n+\t(cp_parser_init_declarator): Call cp_finalize_omp_declare_simd.\n+\t(cp_parser_direct_declarator): Pass declarator to\n+\tcp_parser_late_return_type_opt.\n+\t(cp_parser_late_return_type_opt): Add declarator argument,\n+\tcall cp_parser_late_parsing_omp_declare_simd for declare simd.\n+\t(cp_parser_class_specifier_1): Call cp_ensure_no_omp_declare_simd.\n+\tParse UDRs before all other methods.\n+\t(cp_parser_member_specification_opt): Use pragma_member instead of\n+\tpragma_external.\n+\t(cp_parser_member_declaration): Call cp_finalize_omp_declare_simd.\n+\t(cp_parser_function_definition_from_specifiers_and_declarator,\n+\tcp_parser_save_member_function_body): Likewise.\n+\t(cp_parser_late_parsing_for_member): Handle UDRs specially.\n+\t(cp_parser_next_token_starts_class_definition_p): Don't allow\n+\tCPP_COLON if colon_doesnt_start_class_def_p flag is true.\n+\t(cp_parser_objc_interstitial_code): Use pragma_objc_icode\n+\tinstead of pragma_external.\n+\t(cp_parser_omp_clause_name): Parse new OpenMP 4.0 clause names.\n+\t(cp_parser_omp_var_list_no_open): Parse array sections for\n+\tOMP_CLAUSE_{DEPEND,MAP,TO,FROM} clauses.  Add COLON argument,\n+\tif non-NULL, allow parsing to end with a colon rather than close\n+\tparen.\n+\t(cp_parser_omp_var_list): Adjust cp_parser_omp_var_list_no_open\n+\tcaller.\n+\t(cp_parser_omp_clause_reduction): Handle user defined reductions.\n+\t(cp_parser_omp_clause_branch, cp_parser_omp_clause_cancelkind,\n+\tcp_parser_omp_clause_num_teams, cp_parser_omp_clause_thread_limit,\n+\tcp_parser_omp_clause_aligned, cp_parser_omp_clause_linear,\n+\tcp_parser_omp_clause_safelen, cp_parser_omp_clause_simdlen,\n+\tcp_parser_omp_clause_depend, cp_parser_omp_clause_map,\n+\tcp_parser_omp_clause_device, cp_parser_omp_clause_dist_schedule,\n+\tcp_parser_omp_clause_proc_bind, cp_parser_omp_clause_to,\n+\tcp_parser_omp_clause_from, cp_parser_omp_clause_uniform): New\n+\tfunctions.\n+\t(cp_parser_omp_all_clauses): Add finish_p argument.  Don't call\n+\tfinish_omp_clauses if it is false.  Handle new OpenMP 4.0 clauses.\n+\t(cp_parser_omp_atomic): Parse seq_cst clause, pass\n+\ttrue if it is present to finish_omp_atomic.  Handle new OpenMP 4.0\n+\tatomic forms.\n+\t(cp_parser_omp_for_loop): Add CODE argument, pass it through\n+\tto finish_omp_for.  Change last argument to cclauses,\n+\tand adjust uses to grab parallel clauses from the array of all\n+\tthe split clauses.\n+\t(cp_omp_split_clauses): New function.\n+\t(cp_parser_omp_simd): New function.\n+\t(cp_parser_omp_for): Add p_name, mask and cclauses arguments.\n+\tAllow the function to be called also when parsing combined constructs,\n+\tand call c_parser_omp_simd when parsing for simd.\n+\t(cp_parser_omp_sections_scope): If section-sequence doesn't start with\n+\t#pragma omp section, require exactly one structured-block instead of\n+\tsequence of statements.\n+\t(cp_parser_omp_sections): Add p_name, mask and cclauses arguments.\n+\tAllow the function to be called also when parsing combined constructs.\n+\t(cp_parser_omp_parallel): Add p_name, mask and cclauses arguments.\n+\tAllow the function to be called also when parsing combined\n+\tconstructs.\n+\t(cp_parser_omp_taskgroup, cp_parser_omp_cancel,\n+\tcp_parser_omp_cancellation_point, cp_parser_omp_distribute,\n+\tcp_parser_omp_teams, cp_parser_omp_target_data,\n+\tcp_parser_omp_target_update, cp_parser_omp_target,\n+\tcp_parser_omp_declare_simd, cp_parser_late_parsing_omp_declare_simd,\n+\tcp_parser_omp_declare_target, cp_parser_omp_end_declare_target,\n+\tcp_parser_omp_declare_reduction_exprs, cp_parser_omp_declare_reduction,\n+\tcp_parser_omp_declare): New functions.\n+\t(cp_parser_omp_construct): Add p_name and mask vars.  Handle\n+\tPRAGMA_OMP_DISTRIBUTE, PRAGMA_OMP_SIMD, PRAGMA_OMP_TASKGROUP,\n+\tPRAGMA_OMP_TEAMS.  Adjust cp_parser_omp_for, cp_parser_omp_parallel\n+\tand cp_parser_omp_sections callers.\n+\t(cp_parser_pragma): Handle PRAGMA_OMP_CANCEL,\n+\tPRAGMA_OMP_CANCELLATION_POINT, PRAGMA_OMP_DECLARE_REDUCTION,\n+\tPRAGMA_OMP_DISTRIBUTE, PRAGMA_OMP_SIMD, PRAGMA_OMP_TASKGROUP,\n+\tPRAGMA_OMP_TEAMS, PRAGMA_OMP_TARGET, PRAGMA_OMP_END_DECLARE_TARGET.\n+\tHandle pragma_member and pragma_objc_icode like pragma_external.\n+\t(OMP_FOR_CLAUSE_MASK, OMP_SECTIONS_CLAUSE_MASK,\n+\tOMP_SINGLE_CLAUSE_MASK): Use OMP_CLAUSE_MASK_1 instead of 1.\n+\t(OMP_PARALLEL_CLAUSE_MASK): Likewise.  Add OMP_CLAUSE_PROC_BIND.\n+\t(OMP_TASK_CLAUSE_MASK): Use OMP_CLAUSE_MASK_1 instead of 1.  Add\n+\tOMP_CLAUSE_DEPEND.\n+\t(OMP_SIMD_CLAUSE_MASK, OMP_CANCEL_CLAUSE_MASK,\n+\tOMP_CANCELLATION_POINT_CLAUSE_MASK, OMP_DISTRIBUTE_CLAUSE_MASK,\n+\tOMP_TEAMS_CLAUSE_MASK, OMP_TARGET_DATA_CLAUSE_MASK,\n+\tOMP_TARGET_UPDATE_CLAUSE_MASK, OMP_TARGET_CLAUSE_MASK,\n+\tOMP_DECLARE_SIMD_CLAUSE_MASK): Define.\n+\t* parser.h (struct cp_omp_declare_simd_data): New type.\n+\t(struct cp_parser): Add colon_doesnt_start_class_def_p and\n+\tomp_declare_simd fields.\n+\t* cp-objcp-common.h (LANG_HOOKS_OMP_MAPPABLE_TYPE): Define.\n+\t* cp-tree.h (struct lang_decl_fn): Add omp_declare_reduction_p\n+\tbit.\n+\t(DECL_OMP_DECLARE_REDUCTION_P): Define.\n+\t(OMP_FOR_GIMPLIFYING_P): Use OMP_LOOP_CHECK macro.\n+\t(struct saved_scope): Add omp_declare_target_attribute field.\n+\t(cp_omp_mappable_type, omp_reduction_id,\n+\tcp_remove_omp_priv_cleanup_stmt, cp_check_omp_declare_reduction,\n+\tfinish_omp_cancel, finish_omp_cancellation_point): New prototypes.\n+\t(finish_omp_for): Add CODE argument.\n+\t(finish_omp_atomic): Add seq_cst argument.\n+\t(cxx_omp_create_clause_info): Add need_dtor argument.\n+\n 2013-10-09  Marek Polacek  <polacek@redhat.com>\n \n \tPR c++/58635"}, {"sha": "c700f58f69fe8373f3efc44346114eee3417f14a", "filename": "gcc/cp/cp-array-notation.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Fcp%2Fcp-array-notation.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Fcp%2Fcp-array-notation.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-array-notation.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -1193,6 +1193,7 @@ expand_array_notation_exprs (tree t)\n     case OMP_SECTION:\n     case OMP_SECTIONS:\n     case OMP_MASTER:\n+    case OMP_TASKGROUP:\n     case OMP_ORDERED:\n     case OMP_CRITICAL:\n     case OMP_ATOMIC:"}, {"sha": "53b0ca8f928208f8414084616aea31554654355d", "filename": "gcc/cp/cp-gimplify.c", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Fcp%2Fcp-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Fcp%2Fcp-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-gimplify.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -669,6 +669,8 @@ cp_gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p)\n       gcc_unreachable ();\n \n     case OMP_FOR:\n+    case OMP_SIMD:\n+    case OMP_DISTRIBUTE:\n       ret = cp_gimplify_omp_for (expr_p, pre_p);\n       break;\n \n@@ -934,7 +936,19 @@ cp_genericize_r (tree *stmt_p, int *walk_subtrees, void *data)\n \t  *walk_subtrees = 0;\n \tbreak;\n       case OMP_CLAUSE_REDUCTION:\n-\tgcc_assert (!is_invisiref_parm (OMP_CLAUSE_DECL (stmt)));\n+\t/* Don't dereference an invisiref in reduction clause's\n+\t   OMP_CLAUSE_DECL either.  OMP_CLAUSE_REDUCTION_{INIT,MERGE}\n+\t   still needs to be genericized.  */\n+\tif (is_invisiref_parm (OMP_CLAUSE_DECL (stmt)))\n+\t  {\n+\t    *walk_subtrees = 0;\n+\t    if (OMP_CLAUSE_REDUCTION_INIT (stmt))\n+\t      cp_walk_tree (&OMP_CLAUSE_REDUCTION_INIT (stmt),\n+\t\t\t    cp_genericize_r, data, NULL);\n+\t    if (OMP_CLAUSE_REDUCTION_MERGE (stmt))\n+\t      cp_walk_tree (&OMP_CLAUSE_REDUCTION_MERGE (stmt),\n+\t\t\t    cp_genericize_r, data, NULL);\n+\t  }\n \tbreak;\n       default:\n \tbreak;\n@@ -1116,7 +1130,9 @@ cp_genericize_r (tree *stmt_p, int *walk_subtrees, void *data)\n     genericize_continue_stmt (stmt_p);\n   else if (TREE_CODE (stmt) == BREAK_STMT)\n     genericize_break_stmt (stmt_p);\n-  else if (TREE_CODE (stmt) == OMP_FOR)\n+  else if (TREE_CODE (stmt) == OMP_FOR\n+\t   || TREE_CODE (stmt) == OMP_SIMD\n+\t   || TREE_CODE (stmt) == OMP_DISTRIBUTE)\n     genericize_omp_for_stmt (stmt_p, walk_subtrees, data);\n   else if (TREE_CODE (stmt) == SIZEOF_EXPR)\n     {\n@@ -1402,7 +1418,8 @@ cxx_omp_clause_dtor (tree clause, tree decl)\n bool\n cxx_omp_privatize_by_reference (const_tree decl)\n {\n-  return is_invisiref_parm (decl);\n+  return (TREE_CODE (TREE_TYPE (decl)) == REFERENCE_TYPE\n+\t  || is_invisiref_parm (decl));\n }\n \n /* Return true if DECL is const qualified var having no mutable member.  */\n@@ -1505,7 +1522,7 @@ cxx_omp_finish_clause (tree c)\n      for making these queries.  */\n   if (!make_shared\n       && CLASS_TYPE_P (inner_type)\n-      && cxx_omp_create_clause_info (c, inner_type, false, true, false))\n+      && cxx_omp_create_clause_info (c, inner_type, false, true, false, true))\n     make_shared = true;\n \n   if (make_shared)"}, {"sha": "ee22423ebd4ad96532580ab50cda1c433067aae1", "filename": "gcc/cp/cp-objcp-common.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Fcp%2Fcp-objcp-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Fcp%2Fcp-objcp-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-objcp-common.h?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -145,6 +145,8 @@ extern void cp_common_init_ts (void);\n #define LANG_HOOKS_OMP_FINISH_CLAUSE cxx_omp_finish_clause\n #undef LANG_HOOKS_OMP_PRIVATIZE_BY_REFERENCE\n #define LANG_HOOKS_OMP_PRIVATIZE_BY_REFERENCE cxx_omp_privatize_by_reference\n+#undef LANG_HOOKS_OMP_MAPPABLE_TYPE\n+#define LANG_HOOKS_OMP_MAPPABLE_TYPE cp_omp_mappable_type\n \n #undef LANG_HOOKS_EH_USE_CXA_END_CLEANUP\n #define LANG_HOOKS_EH_USE_CXA_END_CLEANUP true"}, {"sha": "b1347e20dd6c764791e948bf25e459abea3132e2", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 26, "deletions": 8, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -60,7 +60,7 @@ c-common.h, not after.\n       STMT_EXPR_NO_SCOPE (in STMT_EXPR)\n       BIND_EXPR_TRY_BLOCK (in BIND_EXPR)\n       TYPENAME_IS_ENUM_P (in TYPENAME_TYPE)\n-      OMP_FOR_GIMPLIFYING_P (in OMP_FOR)\n+      OMP_FOR_GIMPLIFYING_P (in OMP_FOR, OMP_SIMD and OMP_DISTRIBUTE)\n       BASELINK_QUALIFIED_P (in BASELINK)\n       TARGET_EXPR_IMPLICIT_P (in TARGET_EXPR)\n       TEMPLATE_PARM_PARAMETER_PACK (in TEMPLATE_PARM_INDEX)\n@@ -1037,6 +1037,9 @@ struct GTY(()) saved_scope {\n \n   int unevaluated_operand;\n   int inhibit_evaluation_warnings;\n+  /* If non-zero, implicit \"omp declare target\" attribute is added into the\n+     attribute lists.  */\n+  int omp_declare_target_attribute;\n \n   struct stmt_tree_s x_stmt_tree;\n \n@@ -1979,7 +1982,8 @@ struct GTY(()) lang_decl_fn {\n   unsigned thunk_p : 1;\n   unsigned this_thunk_p : 1;\n   unsigned hidden_friend_p : 1;\n-  /* 1 spare bit.  */\n+  unsigned omp_declare_reduction_p : 1;\n+  /* No spare bits on 32-bit hosts, 32 on 64-bit hosts.  */\n \n   /* For a non-thunk function decl, this is a tree list of\n      friendly classes. For a thunk function decl, it is the\n@@ -3181,6 +3185,11 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n #define DECL_HIDDEN_FRIEND_P(NODE) \\\n   (LANG_DECL_FN_CHECK (DECL_COMMON_CHECK (NODE))->hidden_friend_p)\n \n+/* Nonzero if NODE is an artificial FUNCTION_DECL for\n+   #pragma omp declare reduction.  */\n+#define DECL_OMP_DECLARE_REDUCTION_P(NODE) \\\n+  (LANG_DECL_FN_CHECK (DECL_COMMON_CHECK (NODE))->omp_declare_reduction_p)\n+\n /* Nonzero if DECL has been declared threadprivate by\n    #pragma omp threadprivate.  */\n #define CP_DECL_THREADPRIVATE_P(DECL) \\\n@@ -4011,7 +4020,7 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n \n /* Used while gimplifying continue statements bound to OMP_FOR nodes.  */\n #define OMP_FOR_GIMPLIFYING_P(NODE) \\\n-  (TREE_LANG_FLAG_0 (OMP_FOR_CHECK (NODE)))\n+  (TREE_LANG_FLAG_0 (OMP_LOOP_CHECK (NODE)))\n \n /* A language-specific token attached to the OpenMP data clauses to\n    hold code (or code fragments) related to ctors, dtors, and op=.\n@@ -5299,6 +5308,7 @@ extern bool possibly_inlined_p\t\t\t(tree);\n extern int parm_index                           (tree);\n extern tree vtv_start_verification_constructor_init_function (void);\n extern tree vtv_finish_verification_constructor_init_function (tree);\n+extern bool cp_omp_mappable_type\t\t(tree);\n \n /* in error.c */\n extern void init_error\t\t\t\t(void);\n@@ -5774,6 +5784,9 @@ extern tree finish_qualified_id_expr\t\t(tree, tree, bool, bool,\n extern void simplify_aggr_init_expr\t\t(tree *);\n extern void finalize_nrv\t\t\t(tree *, tree, tree);\n extern void note_decl_for_pch\t\t\t(tree);\n+extern tree omp_reduction_id\t\t\t(enum tree_code, tree, tree);\n+extern tree cp_remove_omp_priv_cleanup_stmt\t(tree *, int *, void *);\n+extern void cp_check_omp_declare_reduction\t(tree);\n extern tree finish_omp_clauses\t\t\t(tree);\n extern void finish_omp_threadprivate\t\t(tree);\n extern tree begin_omp_structured_block\t\t(void);\n@@ -5782,18 +5795,23 @@ extern tree begin_omp_parallel\t\t\t(void);\n extern tree finish_omp_parallel\t\t\t(tree, tree);\n extern tree begin_omp_task\t\t\t(void);\n extern tree finish_omp_task\t\t\t(tree, tree);\n-extern tree finish_omp_for\t\t\t(location_t, tree, tree,\n-\t\t\t\t\t\t tree, tree, tree, tree, tree);\n+extern tree finish_omp_for\t\t\t(location_t, enum tree_code,\n+\t\t\t\t\t\t tree, tree, tree, tree, tree,\n+\t\t\t\t\t\t tree, tree);\n extern void finish_omp_atomic\t\t\t(enum tree_code, enum tree_code,\n-\t\t\t\t\t\t tree, tree, tree, tree, tree);\n+\t\t\t\t\t\t tree, tree, tree, tree, tree,\n+\t\t\t\t\t\t bool);\n extern void finish_omp_barrier\t\t\t(void);\n extern void finish_omp_flush\t\t\t(void);\n extern void finish_omp_taskwait\t\t\t(void);\n+extern void finish_omp_taskyield\t\t(void);\n+extern void finish_omp_cancel\t\t\t(tree);\n+extern void finish_omp_cancellation_point\t(tree);\n extern tree begin_transaction_stmt\t\t(location_t, tree *, int);\n extern void finish_transaction_stmt\t\t(tree, tree, int, tree);\n extern tree build_transaction_expr\t\t(location_t, tree, int, tree);\n-extern void finish_omp_taskyield\t\t(void);\n-extern bool cxx_omp_create_clause_info\t\t(tree, tree, bool, bool, bool);\n+extern bool cxx_omp_create_clause_info\t\t(tree, tree, bool, bool,\n+\t\t\t\t\t\t bool, bool);\n extern tree baselink_for_fns                    (tree);\n extern void finish_static_assert                (tree, tree, location_t,\n                                                  bool);"}, {"sha": "fe8fe4ee52c15c59b2475fc8cc28f775204d9d7d", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -1341,6 +1341,15 @@ duplicate_decls (tree newdecl, tree olddecl, bool newdecl_is_friend)\n \t    }\n \t  return NULL_TREE;\n \t}\n+      else if (DECL_OMP_DECLARE_REDUCTION_P (olddecl))\n+\t{\n+\t  gcc_assert (DECL_OMP_DECLARE_REDUCTION_P (newdecl));\n+\t  error_at (DECL_SOURCE_LOCATION (newdecl),\n+\t\t    \"redeclaration of %<pragma omp declare reduction%>\");\n+\t  error_at (DECL_SOURCE_LOCATION (olddecl),\n+\t\t    \"previous %<pragma omp declare reduction%> declaration\");\n+\t  return error_mark_node;\n+\t}\n       else if (!types_match)\n \t{\n \t  /* Avoid warnings redeclaring built-ins which have not been\n@@ -7302,6 +7311,22 @@ check_static_quals (tree decl, cp_cv_quals quals)\n \t   decl);\n }\n \n+/* Helper function.  Replace the temporary this parameter injected\n+   during cp_finish_omp_declare_simd with the real this parameter.  */\n+\n+static tree\n+declare_simd_adjust_this (tree *tp, int *walk_subtrees, void *data)\n+{\n+  tree this_parm = (tree) data;\n+  if (TREE_CODE (*tp) == PARM_DECL\n+      && DECL_NAME (*tp) == this_identifier\n+      && *tp != this_parm)\n+    *tp = this_parm;\n+  else if (TYPE_P (*tp))\n+    *walk_subtrees = 0;\n+  return NULL_TREE;\n+}\n+\n /* CTYPE is class type, or null if non-class.\n    TYPE is type this FUNCTION_DECL should have, either FUNCTION_TYPE\n    or METHOD_TYPE.\n@@ -7620,6 +7645,33 @@ grokfndecl (tree ctype,\n   if (TYPE_NOTHROW_P (type) || nothrow_libfn_p (decl))\n     TREE_NOTHROW (decl) = 1;\n \n+  if (flag_openmp)\n+    {\n+      /* Adjust \"omp declare simd\" attributes.  */\n+      tree ods = lookup_attribute (\"omp declare simd\", *attrlist);\n+      if (ods)\n+\t{\n+\t  tree attr;\n+\t  for (attr = ods; attr;\n+\t       attr = lookup_attribute (\"omp declare simd\", TREE_CHAIN (attr)))\n+\t    {\n+\t      if (TREE_CODE (type) == METHOD_TYPE)\n+\t\twalk_tree (&TREE_VALUE (attr), declare_simd_adjust_this,\n+\t\t\t   DECL_ARGUMENTS (decl), NULL);\n+\t      if (TREE_VALUE (attr) != NULL_TREE)\n+\t\t{\n+\t\t  tree cl = TREE_VALUE (TREE_VALUE (attr));\n+\t\t  cl = c_omp_declare_simd_clauses_to_numbers\n+\t\t\t\t\t\t(DECL_ARGUMENTS (decl), cl);\n+\t\t  if (cl)\n+\t\t    TREE_VALUE (TREE_VALUE (attr)) = cl;\n+\t\t  else\n+\t\t    TREE_VALUE (attr) = NULL_TREE;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n   /* Caller will do the rest of this.  */\n   if (check < 0)\n     return decl;"}, {"sha": "4ebc1555909bc7cbf30c6c00846b4f26779afc1e", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 66, "deletions": 7, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -101,7 +101,6 @@ static GTY(()) vec<tree, va_gc> *no_linkage_decls;\n /* Nonzero if we're done parsing and into end-of-file activities.  */\n \n int at_eof;\n-\n \f\n \n /* Return a member function type (a METHOD_TYPE), given FNTYPE (a\n@@ -1135,6 +1134,11 @@ is_late_template_attribute (tree attr, tree decl)\n   if (is_attribute_p (\"unused\", name))\n     return false;\n \n+  /* #pragma omp declare simd attribute needs to be always deferred.  */\n+  if (flag_openmp\n+      && is_attribute_p (\"omp declare simd\", name))\n+    return true;\n+\n   /* If any of the arguments are dependent expressions, we can't evaluate\n      the attribute until instantiation time.  */\n   for (arg = args; arg; arg = TREE_CHAIN (arg))\n@@ -1336,6 +1340,34 @@ cp_check_const_attributes (tree attributes)\n     }\n }\n \n+/* Return true if TYPE is an OpenMP mappable type.  */\n+bool\n+cp_omp_mappable_type (tree type)\n+{\n+  /* Mappable type has to be complete.  */\n+  if (type == error_mark_node || !COMPLETE_TYPE_P (type))\n+    return false;\n+  /* Arrays have mappable type if the elements have mappable type.  */\n+  while (TREE_CODE (type) == ARRAY_TYPE)\n+    type = TREE_TYPE (type);\n+  /* A mappable type cannot contain virtual members.  */\n+  if (CLASS_TYPE_P (type) && CLASSTYPE_VTABLES (type))\n+    return false;\n+  /* All data members must be non-static.  */\n+  if (CLASS_TYPE_P (type))\n+    {\n+      tree field;\n+      for (field = TYPE_FIELDS (type); field; field = DECL_CHAIN (field))\n+\tif (TREE_CODE (field) == VAR_DECL)\n+\t  return false;\n+\t/* All fields must have mappable types.  */\n+\telse if (TREE_CODE (field) == FIELD_DECL\n+\t\t && !cp_omp_mappable_type (TREE_TYPE (field)))\n+\t  return false;\n+    }\n+  return true;\n+}\n+\n /* Like decl_attributes, but handle C++ complexity.  */\n \n void\n@@ -1345,6 +1377,30 @@ cplus_decl_attributes (tree *decl, tree attributes, int flags)\n       || *decl == error_mark_node)\n     return;\n \n+  /* Add implicit \"omp declare target\" attribute if requested.  */\n+  if (scope_chain->omp_declare_target_attribute\n+      && ((TREE_CODE (*decl) == VAR_DECL && TREE_STATIC (*decl))\n+\t  || TREE_CODE (*decl) == FUNCTION_DECL))\n+    {\n+      if (TREE_CODE (*decl) == VAR_DECL\n+\t  && DECL_CLASS_SCOPE_P (*decl))\n+\terror (\"%q+D static data member inside of declare target directive\",\n+\t       *decl);\n+      else if (TREE_CODE (*decl) == VAR_DECL\n+\t       && (DECL_FUNCTION_SCOPE_P (*decl)\n+\t\t   || (current_function_decl && !DECL_EXTERNAL (*decl))))\n+\terror (\"%q+D in block scope inside of declare target directive\",\n+\t       *decl);\n+      else if (!processing_template_decl\n+\t       && TREE_CODE (*decl) == VAR_DECL\n+\t       && !cp_omp_mappable_type (TREE_TYPE (*decl)))\n+\terror (\"%q+D in declare target directive does not have mappable type\",\n+\t       *decl);\n+      else\n+\tattributes = tree_cons (get_identifier (\"omp declare target\"),\n+\t\t\t\tNULL_TREE, attributes);\n+    }\n+\n   if (processing_template_decl)\n     {\n       if (check_for_bare_parameter_packs (attributes))\n@@ -4623,13 +4679,16 @@ mark_used (tree decl, tsubst_flags_t complain)\n      or a constexpr function, we need it right now because a reference to\n      such a data member or a call to such function is not value-dependent.\n      For a function that uses auto in the return type, we need to instantiate\n-     it to find out its type.  */\n-  if ((decl_maybe_constant_var_p (decl)\n-       || (TREE_CODE (decl) == FUNCTION_DECL\n-\t   && DECL_DECLARED_CONSTEXPR_P (decl))\n-       || undeduced_auto_decl (decl))\n-      && DECL_LANG_SPECIFIC (decl)\n+     it to find out its type.  For OpenMP user defined reductions, we need\n+     them instantiated for reduction clauses which inline them by hand\n+     directly.  */\n+  if (DECL_LANG_SPECIFIC (decl)\n       && DECL_TEMPLATE_INFO (decl)\n+      && (decl_maybe_constant_var_p (decl)\n+\t  || (TREE_CODE (decl) == FUNCTION_DECL\n+\t      && (DECL_DECLARED_CONSTEXPR_P (decl)\n+\t\t  || DECL_OMP_DECLARE_REDUCTION_P (decl)))\n+\t  || undeduced_auto_decl (decl))\n       && !uses_template_parms (DECL_TI_ARGS (decl)))\n     {\n       /* Instantiating a function will result in garbage collection.  We"}, {"sha": "83fdfaba40f3e66d00b1305a44f9ae5a25ae9c56", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 3290, "deletions": 1267, "changes": 4557, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530"}, {"sha": "75f327b1d8b7f9ac6eb658ffe35c72bc77d8cfc6", "filename": "gcc/cp/parser.h", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Fcp%2Fparser.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Fcp%2Fparser.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.h?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -196,6 +196,14 @@ typedef struct GTY (()) cp_parser_context {\n } cp_parser_context;\n \n \n+/* Control structure for #pragma omp declare simd parsing.  */\n+struct cp_omp_declare_simd_data {\n+  bool error_seen; /* Set if error has been reported.  */\n+  bool fndecl_seen; /* Set if one fn decl/definition has been seen already.  */\n+  vec<cp_token_cache_ptr> tokens;\n+};\n+\n+\n /* The cp_parser structure represents the C++ parser.  */\n \n typedef struct GTY(()) cp_parser {\n@@ -324,6 +332,12 @@ typedef struct GTY(()) cp_parser {\n   /* TRUE if we can auto-correct a colon to a scope operator.  */\n   bool colon_corrects_to_scope_p;\n \n+  /* TRUE if : doesn't start a class definition.  Should be only used\n+     together with type_definition_forbidden_message non-NULL, in\n+     contexts where new types may not be defined, and the type list\n+     is terminated by colon.  */\n+  bool colon_doesnt_start_class_def_p;\n+\n   /* If non-NULL, then we are parsing a construct where new type\n      definitions are not permitted.  The string stored here will be\n      issued as an error message if a type is defined.  */\n@@ -342,6 +356,10 @@ typedef struct GTY(()) cp_parser {\n      current declaration.  */\n   unsigned num_template_parameter_lists;\n \n+  /* When parsing #pragma omp declare simd, this is a pointer to a\n+     data structure with everything needed for parsing the clauses.  */\n+  cp_omp_declare_simd_data * GTY((skip)) omp_declare_simd;\n+\n   /* TRUE if the function being declared was made a template due to its\n      parameter list containing generic type specifiers (`auto' or concept\n      identifiers) rather than an explicit template parameter list.  */"}, {"sha": "5721a681a4a5c5201f288586c4bdb3845e3208ec", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 258, "deletions": 35, "changes": 293, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -8545,6 +8545,8 @@ can_complete_type_without_circularity (tree type)\n     return 1;\n }\n \n+static tree tsubst_omp_clauses (tree, bool, tree, tsubst_flags_t, tree);\n+\n /* Apply any attributes which had to be deferred until instantiation\n    time.  DECL_P, ATTRIBUTES and ATTR_FLAGS are as cplus_decl_attributes;\n    ARGS, COMPLAIN, IN_DECL are as tsubst.  */\n@@ -8586,14 +8588,32 @@ apply_late_template_attributes (tree *decl_p, tree attributes, int attr_flags,\n \t    {\n \t      *p = TREE_CHAIN (t);\n \t      TREE_CHAIN (t) = NULL_TREE;\n+\t      if (flag_openmp\n+\t\t  && is_attribute_p (\"omp declare simd\",\n+\t\t\t\t     get_attribute_name (t))\n+\t\t  && TREE_VALUE (t))\n+\t\t{\n+\t\t  tree clauses = TREE_VALUE (TREE_VALUE (t));\n+\t\t  clauses = tsubst_omp_clauses (clauses, true, args,\n+\t\t\t\t\t\tcomplain, in_decl);\n+\t\t  c_omp_declare_simd_clauses_to_decls (*decl_p, clauses);\n+\t\t  clauses = finish_omp_clauses (clauses);\n+\t\t  tree parms = DECL_ARGUMENTS (*decl_p);\n+\t\t  clauses\n+\t\t    = c_omp_declare_simd_clauses_to_numbers (parms, clauses);\n+\t\t  if (clauses)\n+\t\t    TREE_VALUE (TREE_VALUE (t)) = clauses;\n+\t\t  else\n+\t\t    TREE_VALUE (t) = NULL_TREE;\n+\t\t}\n \t      /* If the first attribute argument is an identifier, don't\n \t\t pass it through tsubst.  Attributes like mode, format,\n \t\t cleanup and several target specific attributes expect it\n \t\t unmodified.  */\n-\t      if (TREE_VALUE (t)\n-\t\t  && TREE_CODE (TREE_VALUE (t)) == TREE_LIST\n-\t\t  && TREE_VALUE (TREE_VALUE (t))\n-\t\t  && (identifier_p (TREE_VALUE (TREE_VALUE (t)))))\n+\t      else if (TREE_VALUE (t)\n+\t\t       && TREE_CODE (TREE_VALUE (t)) == TREE_LIST\n+\t\t       && TREE_VALUE (TREE_VALUE (t))\n+\t\t       && identifier_p (TREE_VALUE (TREE_VALUE (t))))\n \t\t{\n \t\t  tree chain\n \t\t    = tsubst_expr (TREE_CHAIN (TREE_VALUE (t)), args, complain,\n@@ -8915,6 +8935,9 @@ instantiate_class_template_1 (tree type)\n \t      /* Instantiate members marked with attribute used.  */\n \t      if (r != error_mark_node && DECL_PRESERVE_P (r))\n \t\tmark_used (r);\n+\t      if (TREE_CODE (r) == FUNCTION_DECL\n+\t\t  && DECL_OMP_DECLARE_REDUCTION_P (r))\n+\t\tcp_check_omp_declare_reduction (r);\n \t    }\n \t  else\n \t    {\n@@ -10383,6 +10406,24 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n \t  DECL_INITIAL (r) = NULL_TREE;\n \tDECL_CONTEXT (r) = ctx;\n \n+\t/* OpenMP UDRs have the only argument a reference to the declared\n+\t   type.  We want to diagnose if the declared type is a reference,\n+\t   which is invalid, but as references to references are usually\n+\t   quietly merged, diagnose it here.  */\n+\tif (DECL_OMP_DECLARE_REDUCTION_P (t))\n+\t  {\n+\t    tree argtype\n+\t      = TREE_TYPE (TREE_VALUE (TYPE_ARG_TYPES (TREE_TYPE (t))));\n+\t    argtype = tsubst (argtype, args, complain, in_decl);\n+\t    if (TREE_CODE (argtype) == REFERENCE_TYPE)\n+\t      error_at (DECL_SOURCE_LOCATION (t),\n+\t\t\t\"reference type %qT in \"\n+\t\t\t\"%<#pragma omp declare reduction%>\", argtype);\n+\t    if (strchr (IDENTIFIER_POINTER (DECL_NAME (t)), '~') == NULL)\n+\t      DECL_NAME (r) = omp_reduction_id (ERROR_MARK, DECL_NAME (t),\n+\t\t\t\t\t\targtype);\n+\t  }\n+\n \tif (member && DECL_CONV_FN_P (r))\n \t  /* Type-conversion operator.  Reconstruct the name, in\n \t     case it's the name of one of the template's parameters.  */\n@@ -12815,8 +12856,8 @@ tsubst_copy (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n /* Like tsubst_copy, but specifically for OpenMP clauses.  */\n \n static tree\n-tsubst_omp_clauses (tree clauses, tree args, tsubst_flags_t complain,\n-\t\t    tree in_decl)\n+tsubst_omp_clauses (tree clauses, bool declare_simd,\n+\t\t    tree args, tsubst_flags_t complain, tree in_decl)\n {\n   tree new_clauses = NULL, nc, oc;\n \n@@ -12841,30 +12882,80 @@ tsubst_omp_clauses (tree clauses, tree args, tsubst_flags_t complain,\n \tcase OMP_CLAUSE_PRIVATE:\n \tcase OMP_CLAUSE_SHARED:\n \tcase OMP_CLAUSE_FIRSTPRIVATE:\n-\tcase OMP_CLAUSE_REDUCTION:\n \tcase OMP_CLAUSE_COPYIN:\n \tcase OMP_CLAUSE_COPYPRIVATE:\n \tcase OMP_CLAUSE_IF:\n \tcase OMP_CLAUSE_NUM_THREADS:\n \tcase OMP_CLAUSE_SCHEDULE:\n \tcase OMP_CLAUSE_COLLAPSE:\n \tcase OMP_CLAUSE_FINAL:\n+\tcase OMP_CLAUSE_DEPEND:\n+\tcase OMP_CLAUSE_FROM:\n+\tcase OMP_CLAUSE_TO:\n+\tcase OMP_CLAUSE_UNIFORM:\n+\tcase OMP_CLAUSE_MAP:\n+\tcase OMP_CLAUSE_DEVICE:\n+\tcase OMP_CLAUSE_DIST_SCHEDULE:\n+\tcase OMP_CLAUSE_NUM_TEAMS:\n+\tcase OMP_CLAUSE_THREAD_LIMIT:\n+\tcase OMP_CLAUSE_SAFELEN:\n+\tcase OMP_CLAUSE_SIMDLEN:\n \t  OMP_CLAUSE_OPERAND (nc, 0)\n \t    = tsubst_expr (OMP_CLAUSE_OPERAND (oc, 0), args, complain, \n \t\t\t   in_decl, /*integral_constant_expression_p=*/false);\n \t  break;\n+\tcase OMP_CLAUSE_REDUCTION:\n+\t  if (OMP_CLAUSE_REDUCTION_PLACEHOLDER (oc))\n+\t    {\n+\t      tree placeholder = OMP_CLAUSE_REDUCTION_PLACEHOLDER (oc);\n+\t      if (TREE_CODE (placeholder) == SCOPE_REF)\n+\t\t{\n+\t\t  tree scope = tsubst (TREE_OPERAND (placeholder, 0), args,\n+\t\t\t\t       complain, in_decl);\n+\t\t  OMP_CLAUSE_REDUCTION_PLACEHOLDER (nc)\n+\t\t    = build_qualified_name (NULL_TREE, scope,\n+\t\t\t\t\t    TREE_OPERAND (placeholder, 1),\n+\t\t\t\t\t    false);\n+\t\t}\n+\t      else\n+\t\tgcc_assert (identifier_p (placeholder));\n+\t    }\n+\t  OMP_CLAUSE_OPERAND (nc, 0)\n+\t    = tsubst_expr (OMP_CLAUSE_OPERAND (oc, 0), args, complain,\n+\t\t\t   in_decl, /*integral_constant_expression_p=*/false);\n+\t  break;\n+\tcase OMP_CLAUSE_LINEAR:\n+\tcase OMP_CLAUSE_ALIGNED:\n+\t  OMP_CLAUSE_OPERAND (nc, 0)\n+\t    = tsubst_expr (OMP_CLAUSE_OPERAND (oc, 0), args, complain,\n+\t\t\t   in_decl, /*integral_constant_expression_p=*/false);\n+\t  OMP_CLAUSE_OPERAND (nc, 1)\n+\t    = tsubst_expr (OMP_CLAUSE_OPERAND (oc, 1), args, complain,\n+\t\t\t   in_decl, /*integral_constant_expression_p=*/false);\n+\t  break;\n+\n \tcase OMP_CLAUSE_NOWAIT:\n \tcase OMP_CLAUSE_ORDERED:\n \tcase OMP_CLAUSE_DEFAULT:\n \tcase OMP_CLAUSE_UNTIED:\n \tcase OMP_CLAUSE_MERGEABLE:\n+\tcase OMP_CLAUSE_INBRANCH:\n+\tcase OMP_CLAUSE_NOTINBRANCH:\n+\tcase OMP_CLAUSE_PROC_BIND:\n+\tcase OMP_CLAUSE_FOR:\n+\tcase OMP_CLAUSE_PARALLEL:\n+\tcase OMP_CLAUSE_SECTIONS:\n+\tcase OMP_CLAUSE_TASKGROUP:\n \t  break;\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n     }\n \n-  return finish_omp_clauses (nreverse (new_clauses));\n+  new_clauses = nreverse (new_clauses);\n+  if (!declare_simd)\n+    new_clauses = finish_omp_clauses (new_clauses);\n+  return new_clauses;\n }\n \n /* Like tsubst_copy_and_build, but unshare TREE_LIST nodes.  */\n@@ -13169,6 +13260,15 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,\n \t\t  }\n \t\telse if (DECL_IMPLICIT_TYPEDEF_P (t))\n \t\t  /* We already did a pushtag.  */;\n+\t\telse if (TREE_CODE (decl) == FUNCTION_DECL\n+\t\t\t && DECL_OMP_DECLARE_REDUCTION_P (decl)\n+\t\t\t && DECL_FUNCTION_SCOPE_P (pattern_decl))\n+\t\t  {\n+\t\t    DECL_CONTEXT (decl) = NULL_TREE;\n+\t\t    pushdecl (decl);\n+\t\t    DECL_CONTEXT (decl) = current_function_decl;\n+\t\t    cp_check_omp_declare_reduction (decl);\n+\t\t  }\n \t\telse\n \t\t  {\n \t\t    int const_init = false;\n@@ -13440,7 +13540,7 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,\n       break;\n \n     case OMP_PARALLEL:\n-      tmp = tsubst_omp_clauses (OMP_PARALLEL_CLAUSES (t),\n+      tmp = tsubst_omp_clauses (OMP_PARALLEL_CLAUSES (t), false,\n \t\t\t\targs, complain, in_decl);\n       stmt = begin_omp_parallel ();\n       RECUR (OMP_PARALLEL_BODY (t));\n@@ -13449,51 +13549,73 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,\n       break;\n \n     case OMP_TASK:\n-      tmp = tsubst_omp_clauses (OMP_TASK_CLAUSES (t),\n+      tmp = tsubst_omp_clauses (OMP_TASK_CLAUSES (t), false,\n \t\t\t\targs, complain, in_decl);\n       stmt = begin_omp_task ();\n       RECUR (OMP_TASK_BODY (t));\n       finish_omp_task (tmp, stmt);\n       break;\n \n     case OMP_FOR:\n+    case OMP_SIMD:\n+    case OMP_DISTRIBUTE:\n       {\n \ttree clauses, body, pre_body;\n-\ttree declv, initv, condv, incrv;\n+\ttree declv = NULL_TREE, initv = NULL_TREE, condv = NULL_TREE;\n+\ttree incrv = NULL_TREE;\n \tint i;\n \n-\tclauses = tsubst_omp_clauses (OMP_FOR_CLAUSES (t),\n+\tclauses = tsubst_omp_clauses (OMP_FOR_CLAUSES (t), false,\n \t\t\t\t      args, complain, in_decl);\n-\tdeclv = make_tree_vec (TREE_VEC_LENGTH (OMP_FOR_INIT (t)));\n-\tinitv = make_tree_vec (TREE_VEC_LENGTH (OMP_FOR_INIT (t)));\n-\tcondv = make_tree_vec (TREE_VEC_LENGTH (OMP_FOR_INIT (t)));\n-\tincrv = make_tree_vec (TREE_VEC_LENGTH (OMP_FOR_INIT (t)));\n+\tif (OMP_FOR_INIT (t) != NULL_TREE)\n+\t  {\n+\t    declv = make_tree_vec (TREE_VEC_LENGTH (OMP_FOR_INIT (t)));\n+\t    initv = make_tree_vec (TREE_VEC_LENGTH (OMP_FOR_INIT (t)));\n+\t    condv = make_tree_vec (TREE_VEC_LENGTH (OMP_FOR_INIT (t)));\n+\t    incrv = make_tree_vec (TREE_VEC_LENGTH (OMP_FOR_INIT (t)));\n+\t  }\n \n \tstmt = begin_omp_structured_block ();\n \n \tpre_body = push_stmt_list ();\n \tRECUR (OMP_FOR_PRE_BODY (t));\n \tpre_body = pop_stmt_list (pre_body);\n \n-\tfor (i = 0; i < TREE_VEC_LENGTH (OMP_FOR_INIT (t)); i++)\n-\t  tsubst_omp_for_iterator (t, i, declv, initv, condv, incrv,\n-\t\t\t\t   &clauses, args, complain, in_decl,\n-\t\t\t\t   integral_constant_expression_p);\n+\tif (OMP_FOR_INIT (t) != NULL_TREE)\n+\t  for (i = 0; i < TREE_VEC_LENGTH (OMP_FOR_INIT (t)); i++)\n+\t    tsubst_omp_for_iterator (t, i, declv, initv, condv, incrv,\n+\t\t\t\t     &clauses, args, complain, in_decl,\n+\t\t\t\t     integral_constant_expression_p);\n \n \tbody = push_stmt_list ();\n \tRECUR (OMP_FOR_BODY (t));\n \tbody = pop_stmt_list (body);\n \n-\tt = finish_omp_for (EXPR_LOCATION (t), declv, initv, condv, incrv,\n-\t\t\t    body, pre_body, clauses);\n+\tif (OMP_FOR_INIT (t) != NULL_TREE)\n+\t  t = finish_omp_for (EXPR_LOCATION (t), TREE_CODE (t), declv, initv,\n+\t\t\t      condv, incrv, body, pre_body, clauses);\n+\telse\n+\t  {\n+\t    t = make_node (TREE_CODE (t));\n+\t    TREE_TYPE (t) = void_type_node;\n+\t    OMP_FOR_BODY (t) = body;\n+\t    OMP_FOR_PRE_BODY (t) = pre_body;\n+\t    OMP_FOR_CLAUSES (t) = clauses;\n+\t    SET_EXPR_LOCATION (t, EXPR_LOCATION (t));\n+\t    add_stmt (t);\n+\t  }\n \n \tadd_stmt (finish_omp_structured_block (stmt));\n       }\n       break;\n \n     case OMP_SECTIONS:\n     case OMP_SINGLE:\n-      tmp = tsubst_omp_clauses (OMP_CLAUSES (t), args, complain, in_decl);\n+    case OMP_TEAMS:\n+    case OMP_TARGET_DATA:\n+    case OMP_TARGET:\n+      tmp = tsubst_omp_clauses (OMP_CLAUSES (t), false,\n+\t\t\t\targs, complain, in_decl);\n       stmt = push_stmt_list ();\n       RECUR (OMP_BODY (t));\n       stmt = pop_stmt_list (stmt);\n@@ -13504,9 +13626,18 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,\n       add_stmt (t);\n       break;\n \n+    case OMP_TARGET_UPDATE:\n+      tmp = tsubst_omp_clauses (OMP_TARGET_UPDATE_CLAUSES (t), false,\n+\t\t\t\targs, complain, in_decl);\n+      t = copy_node (t);\n+      OMP_CLAUSES (t) = tmp;\n+      add_stmt (t);\n+      break;\n+\n     case OMP_SECTION:\n     case OMP_CRITICAL:\n     case OMP_MASTER:\n+    case OMP_TASKGROUP:\n     case OMP_ORDERED:\n       stmt = push_stmt_list ();\n       RECUR (OMP_BODY (t));\n@@ -13532,7 +13663,8 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,\n \t  lhs = RECUR (TREE_OPERAND (op1, 0));\n \t  rhs = RECUR (TREE_OPERAND (op1, 1));\n \t  finish_omp_atomic (OMP_ATOMIC, TREE_CODE (op1), lhs, rhs,\n-\t\t\t     NULL_TREE, NULL_TREE, rhs1);\n+\t\t\t     NULL_TREE, NULL_TREE, rhs1,\n+\t\t\t     OMP_ATOMIC_SEQ_CST (t));\n \t}\n       else\n \t{\n@@ -13560,14 +13692,17 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,\n \t      lhs = RECUR (TREE_OPERAND (op11, 0));\n \t      rhs = RECUR (TREE_OPERAND (op11, 1));\n \t      opcode = TREE_CODE (op11);\n+\t      if (opcode == MODIFY_EXPR)\n+\t\topcode = NOP_EXPR;\n \t    }\n \t  else\n \t    {\n \t      code = OMP_ATOMIC;\n \t      lhs = RECUR (TREE_OPERAND (op1, 0));\n \t      rhs = RECUR (TREE_OPERAND (op1, 1));\n \t    }\n-\t  finish_omp_atomic (code, opcode, lhs, rhs, v, lhs1, rhs1);\n+\t  finish_omp_atomic (code, opcode, lhs, rhs, v, lhs1, rhs1,\n+\t\t\t     OMP_ATOMIC_SEQ_CST (t));\n \t}\n       break;\n \n@@ -13639,6 +13774,73 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,\n #undef RETURN\n }\n \n+/* Instantiate the special body of the artificial DECL_OMP_DECLARE_REDUCTION\n+   function.  For description of the body see comment above\n+   cp_parser_omp_declare_reduction_exprs.  */\n+\n+static void\n+tsubst_omp_udr (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n+{\n+  if (t == NULL_TREE || t == error_mark_node)\n+    return;\n+\n+  gcc_assert (TREE_CODE (t) == STATEMENT_LIST);\n+\n+  tree_stmt_iterator tsi;\n+  int i;\n+  tree stmts[7];\n+  memset (stmts, 0, sizeof stmts);\n+  for (i = 0, tsi = tsi_start (t);\n+       i < 7 && !tsi_end_p (tsi);\n+       i++, tsi_next (&tsi))\n+    stmts[i] = tsi_stmt (tsi);\n+  gcc_assert (tsi_end_p (tsi));\n+\n+  if (i >= 3)\n+    {\n+      gcc_assert (TREE_CODE (stmts[0]) == DECL_EXPR\n+\t\t  && TREE_CODE (stmts[1]) == DECL_EXPR);\n+      tree omp_out = tsubst (DECL_EXPR_DECL (stmts[0]),\n+\t\t\t     args, complain, in_decl);\n+      tree omp_in = tsubst (DECL_EXPR_DECL (stmts[1]),\n+\t\t\t    args, complain, in_decl);\n+      DECL_CONTEXT (omp_out) = current_function_decl;\n+      DECL_CONTEXT (omp_in) = current_function_decl;\n+      keep_next_level (true);\n+      tree block = begin_omp_structured_block ();\n+      tsubst_expr (stmts[2], args, complain, in_decl, false);\n+      block = finish_omp_structured_block (block);\n+      block = maybe_cleanup_point_expr_void (block);\n+      add_decl_expr (omp_out);\n+      if (TREE_NO_WARNING (DECL_EXPR_DECL (stmts[0])))\n+\tTREE_NO_WARNING (omp_out) = 1;\n+      add_decl_expr (omp_in);\n+      finish_expr_stmt (block);\n+    }\n+  if (i >= 6)\n+    {\n+      gcc_assert (TREE_CODE (stmts[3]) == DECL_EXPR\n+\t\t  && TREE_CODE (stmts[4]) == DECL_EXPR);\n+      tree omp_priv = tsubst (DECL_EXPR_DECL (stmts[3]),\n+\t\t\t      args, complain, in_decl);\n+      tree omp_orig = tsubst (DECL_EXPR_DECL (stmts[4]),\n+\t\t\t      args, complain, in_decl);\n+      DECL_CONTEXT (omp_priv) = current_function_decl;\n+      DECL_CONTEXT (omp_orig) = current_function_decl;\n+      keep_next_level (true);\n+      tree block = begin_omp_structured_block ();\n+      tsubst_expr (stmts[5], args, complain, in_decl, false);\n+      block = finish_omp_structured_block (block);\n+      block = maybe_cleanup_point_expr_void (block);\n+      cp_walk_tree (&block, cp_remove_omp_priv_cleanup_stmt, omp_priv, NULL);\n+      add_decl_expr (omp_priv);\n+      add_decl_expr (omp_orig);\n+      finish_expr_stmt (block);\n+      if (i == 7)\n+\tadd_decl_expr (omp_orig);\n+    }\n+}\n+\n /* T is a postfix-expression that is not being used in a function\n    call.  Return the substituted version of T.  */\n \n@@ -19340,6 +19542,7 @@ instantiate_decl (tree d, int defer_ok,\n       tree subst_decl;\n       tree tmpl_parm;\n       tree spec_parm;\n+      tree block = NULL_TREE;\n \n       /* Save away the current list, in case we are instantiating one\n \t template from within the body of another.  */\n@@ -19349,7 +19552,11 @@ instantiate_decl (tree d, int defer_ok,\n       local_specializations = pointer_map_create ();\n \n       /* Set up context.  */\n-      start_preparsed_function (d, NULL_TREE, SF_PRE_PARSED);\n+      if (DECL_OMP_DECLARE_REDUCTION_P (code_pattern)\n+\t  && TREE_CODE (DECL_CONTEXT (code_pattern)) == FUNCTION_DECL)\n+\tblock = push_stmt_list ();\n+      else\n+\tstart_preparsed_function (d, NULL_TREE, SF_PRE_PARSED);\n \n       /* Some typedefs referenced from within the template code need to be\n \t access checked at template instantiation time, i.e now. These\n@@ -19386,21 +19593,37 @@ instantiate_decl (tree d, int defer_ok,\n       gcc_assert (!spec_parm);\n \n       /* Substitute into the body of the function.  */\n-      tsubst_expr (DECL_SAVED_TREE (code_pattern), args,\n-\t\t   tf_warning_or_error, tmpl,\n-\t\t   /*integral_constant_expression_p=*/false);\n-\n-      /* Set the current input_location to the end of the function\n-         so that finish_function knows where we are.  */\n-      input_location = DECL_STRUCT_FUNCTION (code_pattern)->function_end_locus;\n+      if (DECL_OMP_DECLARE_REDUCTION_P (code_pattern))\n+\ttsubst_omp_udr (DECL_SAVED_TREE (code_pattern), args,\n+\t\t\ttf_warning_or_error, tmpl);\n+      else\n+\t{\n+\t  tsubst_expr (DECL_SAVED_TREE (code_pattern), args,\n+\t\t       tf_warning_or_error, tmpl,\n+\t\t       /*integral_constant_expression_p=*/false);\n+\n+\t  /* Set the current input_location to the end of the function\n+\t     so that finish_function knows where we are.  */\n+\t  input_location\n+\t    = DECL_STRUCT_FUNCTION (code_pattern)->function_end_locus;\n+\t}\n \n       /* We don't need the local specializations any more.  */\n       pointer_map_destroy (local_specializations);\n       local_specializations = saved_local_specializations;\n \n       /* Finish the function.  */\n-      d = finish_function (0);\n-      expand_or_defer_fn (d);\n+      if (DECL_OMP_DECLARE_REDUCTION_P (code_pattern)\n+\t  && TREE_CODE (DECL_CONTEXT (code_pattern)) == FUNCTION_DECL)\n+\tDECL_SAVED_TREE (d) = pop_stmt_list (block);\n+      else\n+\t{\n+\t  d = finish_function (0);\n+\t  expand_or_defer_fn (d);\n+\t}\n+\n+      if (DECL_OMP_DECLARE_REDUCTION_P (code_pattern))\n+\tcp_check_omp_declare_reduction (d);\n     }\n \n   /* We're not deferring instantiation any more.  */"}, {"sha": "9bfd263776e9da87f37bd252017a227ad07b9fda", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 1512, "deletions": 52, "changes": 1564, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -4047,7 +4047,8 @@ finalize_nrv (tree *tp, tree var, tree result)\n \n bool\n cxx_omp_create_clause_info (tree c, tree type, bool need_default_ctor,\n-\t\t\t    bool need_copy_ctor, bool need_copy_assignment)\n+\t\t\t    bool need_copy_ctor, bool need_copy_assignment,\n+\t\t\t    bool need_dtor)\n {\n   int save_errorcount = errorcount;\n   tree info, t;\n@@ -4071,8 +4072,7 @@ cxx_omp_create_clause_info (tree c, tree type, bool need_default_ctor,\n \tTREE_VEC_ELT (info, 0) = t;\n     }\n \n-  if ((need_default_ctor || need_copy_ctor)\n-      && TYPE_HAS_NONTRIVIAL_DESTRUCTOR (type))\n+  if (need_dtor && TYPE_HAS_NONTRIVIAL_DESTRUCTOR (type))\n     TREE_VEC_ELT (info, 1) = get_dtor (type, tf_warning_or_error);\n \n   if (need_copy_assignment)\n@@ -4086,20 +4086,1054 @@ cxx_omp_create_clause_info (tree c, tree type, bool need_default_ctor,\n   return errorcount != save_errorcount;\n }\n \n+/* Helper function for handle_omp_array_sections.  Called recursively\n+   to handle multiple array-section-subscripts.  C is the clause,\n+   T current expression (initially OMP_CLAUSE_DECL), which is either\n+   a TREE_LIST for array-section-subscript (TREE_PURPOSE is low-bound\n+   expression if specified, TREE_VALUE length expression if specified,\n+   TREE_CHAIN is what it has been specified after, or some decl.\n+   TYPES vector is populated with array section types, MAYBE_ZERO_LEN\n+   set to true if any of the array-section-subscript could have length\n+   of zero (explicit or implicit), FIRST_NON_ONE is the index of the\n+   first array-section-subscript which is known not to have length\n+   of one.  Given say:\n+   map(a[:b][2:1][:c][:2][:d][e:f][2:5])\n+   FIRST_NON_ONE will be 3, array-section-subscript [:b], [2:1] and [:c]\n+   all are or may have length of 1, array-section-subscript [:2] is the\n+   first one knonwn not to have length 1.  For array-section-subscript\n+   <= FIRST_NON_ONE we diagnose non-contiguous arrays if low bound isn't\n+   0 or length isn't the array domain max + 1, for > FIRST_NON_ONE we\n+   can if MAYBE_ZERO_LEN is false.  MAYBE_ZERO_LEN will be true in the above\n+   case though, as some lengths could be zero.  */\n+\n+static tree\n+handle_omp_array_sections_1 (tree c, tree t, vec<tree> &types,\n+\t\t\t     bool &maybe_zero_len, unsigned int &first_non_one)\n+{\n+  tree ret, low_bound, length, type;\n+  if (TREE_CODE (t) != TREE_LIST)\n+    {\n+      if (error_operand_p (t))\n+\treturn error_mark_node;\n+      if (type_dependent_expression_p (t))\n+\treturn NULL_TREE;\n+      if (TREE_CODE (t) != VAR_DECL && TREE_CODE (t) != PARM_DECL)\n+\t{\n+\t  if (processing_template_decl)\n+\t    return NULL_TREE;\n+\t  if (DECL_P (t))\n+\t    error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t      \"%qD is not a variable in %qs clause\", t,\n+\t\t      omp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n+\t  else\n+\t    error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t      \"%qE is not a variable in %qs clause\", t,\n+\t\t      omp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n+\t  return error_mark_node;\n+\t}\n+      else if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_DEPEND\n+\t       && TREE_CODE (t) == VAR_DECL && DECL_THREAD_LOCAL_P (t))\n+\t{\n+\t  error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t    \"%qD is threadprivate variable in %qs clause\", t,\n+\t\t    omp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n+\t  return error_mark_node;\n+\t}\n+      t = convert_from_reference (t);\n+      return t;\n+    }\n+\n+  ret = handle_omp_array_sections_1 (c, TREE_CHAIN (t), types,\n+\t\t\t\t     maybe_zero_len, first_non_one);\n+  if (ret == error_mark_node || ret == NULL_TREE)\n+    return ret;\n+\n+  type = TREE_TYPE (ret);\n+  low_bound = TREE_PURPOSE (t);\n+  length = TREE_VALUE (t);\n+  if ((low_bound && type_dependent_expression_p (low_bound))\n+      || (length && type_dependent_expression_p (length)))\n+    return NULL_TREE;\n+\n+  if (low_bound == error_mark_node || length == error_mark_node)\n+    return error_mark_node;\n+\n+  if (low_bound && !INTEGRAL_TYPE_P (TREE_TYPE (low_bound)))\n+    {\n+      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\"low bound %qE of array section does not have integral type\",\n+\t\tlow_bound);\n+      return error_mark_node;\n+    }\n+  if (length && !INTEGRAL_TYPE_P (TREE_TYPE (length)))\n+    {\n+      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\"length %qE of array section does not have integral type\",\n+\t\tlength);\n+      return error_mark_node;\n+    }\n+  if (low_bound\n+      && TREE_CODE (low_bound) == INTEGER_CST\n+      && TYPE_PRECISION (TREE_TYPE (low_bound))\n+\t > TYPE_PRECISION (sizetype))\n+    low_bound = fold_convert (sizetype, low_bound);\n+  if (length\n+      && TREE_CODE (length) == INTEGER_CST\n+      && TYPE_PRECISION (TREE_TYPE (length))\n+\t > TYPE_PRECISION (sizetype))\n+    length = fold_convert (sizetype, length);\n+  if (low_bound == NULL_TREE)\n+    low_bound = integer_zero_node;\n+\n+  if (length != NULL_TREE)\n+    {\n+      if (!integer_nonzerop (length))\n+\tmaybe_zero_len = true;\n+      if (first_non_one == types.length ()\n+\t  && (TREE_CODE (length) != INTEGER_CST || integer_onep (length)))\n+\tfirst_non_one++;\n+    }\n+  if (TREE_CODE (type) == ARRAY_TYPE)\n+    {\n+      if (length == NULL_TREE\n+\t  && (TYPE_DOMAIN (type) == NULL_TREE\n+\t      || TYPE_MAX_VALUE (TYPE_DOMAIN (type)) == NULL_TREE))\n+\t{\n+\t  error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t    \"for unknown bound array type length expression must \"\n+\t\t    \"be specified\");\n+\t  return error_mark_node;\n+\t}\n+      if (TREE_CODE (low_bound) == INTEGER_CST\n+\t  && tree_int_cst_sgn (low_bound) == -1)\n+\t{\n+\t  error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t    \"negative low bound in array section in %qs clause\",\n+\t\t    omp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n+\t  return error_mark_node;\n+\t}\n+      if (length != NULL_TREE\n+\t  && TREE_CODE (length) == INTEGER_CST\n+\t  && tree_int_cst_sgn (length) == -1)\n+\t{\n+\t  error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t    \"negative length in array section in %qs clause\",\n+\t\t    omp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n+\t  return error_mark_node;\n+\t}\n+      if (TYPE_DOMAIN (type)\n+\t  && TYPE_MAX_VALUE (TYPE_DOMAIN (type))\n+\t  && TREE_CODE (TYPE_MAX_VALUE (TYPE_DOMAIN (type)))\n+\t\t\t== INTEGER_CST)\n+\t{\n+\t  tree size = size_binop (PLUS_EXPR,\n+\t\t\t\t  TYPE_MAX_VALUE (TYPE_DOMAIN (type)),\n+\t\t\t\t  size_one_node);\n+\t  if (TREE_CODE (low_bound) == INTEGER_CST)\n+\t    {\n+\t      if (tree_int_cst_lt (size, low_bound))\n+\t\t{\n+\t\t  error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t    \"low bound %qE above array section size \"\n+\t\t\t    \"in %qs clause\", low_bound,\n+\t\t\t    omp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n+\t\t  return error_mark_node;\n+\t\t}\n+\t      if (tree_int_cst_equal (size, low_bound))\n+\t\tmaybe_zero_len = true;\n+\t      else if (length == NULL_TREE\n+\t\t       && first_non_one == types.length ()\n+\t\t       && tree_int_cst_equal\n+\t\t\t    (TYPE_MAX_VALUE (TYPE_DOMAIN (type)),\n+\t\t\t     low_bound))\n+\t\tfirst_non_one++;\n+\t    }\n+\t  else if (length == NULL_TREE)\n+\t    {\n+\t      maybe_zero_len = true;\n+\t      if (first_non_one == types.length ())\n+\t\tfirst_non_one++;\n+\t    }\n+\t  if (length && TREE_CODE (length) == INTEGER_CST)\n+\t    {\n+\t      if (tree_int_cst_lt (size, length))\n+\t\t{\n+\t\t  error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t    \"length %qE above array section size \"\n+\t\t\t    \"in %qs clause\", length,\n+\t\t\t    omp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n+\t\t  return error_mark_node;\n+\t\t}\n+\t      if (TREE_CODE (low_bound) == INTEGER_CST)\n+\t\t{\n+\t\t  tree lbpluslen\n+\t\t    = size_binop (PLUS_EXPR,\n+\t\t\t\t  fold_convert (sizetype, low_bound),\n+\t\t\t\t  fold_convert (sizetype, length));\n+\t\t  if (TREE_CODE (lbpluslen) == INTEGER_CST\n+\t\t      && tree_int_cst_lt (size, lbpluslen))\n+\t\t    {\n+\t\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\t\"high bound %qE above array section size \"\n+\t\t\t\t\"in %qs clause\", lbpluslen,\n+\t\t\t\tomp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n+\t\t      return error_mark_node;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+      else if (length == NULL_TREE)\n+\t{\n+\t  maybe_zero_len = true;\n+\t  if (first_non_one == types.length ())\n+\t    first_non_one++;\n+\t}\n+\n+      /* For [lb:] we will need to evaluate lb more than once.  */\n+      if (length == NULL_TREE && OMP_CLAUSE_CODE (c) != OMP_CLAUSE_DEPEND)\n+\t{\n+\t  tree lb = cp_save_expr (low_bound);\n+\t  if (lb != low_bound)\n+\t    {\n+\t      TREE_PURPOSE (t) = lb;\n+\t      low_bound = lb;\n+\t    }\n+\t}\n+    }\n+  else if (TREE_CODE (type) == POINTER_TYPE)\n+    {\n+      if (length == NULL_TREE)\n+\t{\n+\t  error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t    \"for pointer type length expression must be specified\");\n+\t  return error_mark_node;\n+\t}\n+      /* If there is a pointer type anywhere but in the very first\n+\t array-section-subscript, the array section can't be contiguous.  */\n+      if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_DEPEND\n+\t  && TREE_CODE (TREE_CHAIN (t)) == TREE_LIST)\n+\t{\n+\t  error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t    \"array section is not contiguous in %qs clause\",\n+\t\t    omp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n+\t  return error_mark_node;\n+\t}\n+    }\n+  else\n+    {\n+      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\"%qE does not have pointer or array type\", ret);\n+      return error_mark_node;\n+    }\n+  if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_DEPEND)\n+    types.safe_push (TREE_TYPE (ret));\n+  /* We will need to evaluate lb more than once.  */\n+  tree lb = cp_save_expr (low_bound);\n+  if (lb != low_bound)\n+    {\n+      TREE_PURPOSE (t) = lb;\n+      low_bound = lb;\n+    }\n+  ret = grok_array_decl (OMP_CLAUSE_LOCATION (c), ret, low_bound, false);\n+  return ret;\n+}\n+\n+/* Handle array sections for clause C.  */\n+\n+static bool\n+handle_omp_array_sections (tree c)\n+{\n+  bool maybe_zero_len = false;\n+  unsigned int first_non_one = 0;\n+  vec<tree> types = vNULL;\n+  tree first = handle_omp_array_sections_1 (c, OMP_CLAUSE_DECL (c), types,\n+\t\t\t\t\t    maybe_zero_len, first_non_one);\n+  if (first == error_mark_node)\n+    {\n+      types.release ();\n+      return true;\n+    }\n+  if (first == NULL_TREE)\n+    {\n+      types.release ();\n+      return false;\n+    }\n+  if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_DEPEND)\n+    {\n+      tree t = OMP_CLAUSE_DECL (c);\n+      tree tem = NULL_TREE;\n+      types.release ();\n+      if (processing_template_decl)\n+\treturn false;\n+      /* Need to evaluate side effects in the length expressions\n+\t if any.  */\n+      while (TREE_CODE (t) == TREE_LIST)\n+\t{\n+\t  if (TREE_VALUE (t) && TREE_SIDE_EFFECTS (TREE_VALUE (t)))\n+\t    {\n+\t      if (tem == NULL_TREE)\n+\t\ttem = TREE_VALUE (t);\n+\t      else\n+\t\ttem = build2 (COMPOUND_EXPR, TREE_TYPE (tem),\n+\t\t\t      TREE_VALUE (t), tem);\n+\t    }\n+\t  t = TREE_CHAIN (t);\n+\t}\n+      if (tem)\n+\tfirst = build2 (COMPOUND_EXPR, TREE_TYPE (first), tem, first);\n+      OMP_CLAUSE_DECL (c) = first;\n+    }\n+  else\n+    {\n+      unsigned int num = types.length (), i;\n+      tree t, side_effects = NULL_TREE, size = NULL_TREE;\n+      tree condition = NULL_TREE;\n+\n+      if (int_size_in_bytes (TREE_TYPE (first)) <= 0)\n+\tmaybe_zero_len = true;\n+      if (processing_template_decl && maybe_zero_len)\n+\t{\n+\t  types.release ();\n+\t  return false;\n+\t}\n+\n+      for (i = num, t = OMP_CLAUSE_DECL (c); i > 0;\n+\t   t = TREE_CHAIN (t))\n+\t{\n+\t  tree low_bound = TREE_PURPOSE (t);\n+\t  tree length = TREE_VALUE (t);\n+\n+\t  i--;\n+\t  if (low_bound\n+\t      && TREE_CODE (low_bound) == INTEGER_CST\n+\t      && TYPE_PRECISION (TREE_TYPE (low_bound))\n+\t\t > TYPE_PRECISION (sizetype))\n+\t    low_bound = fold_convert (sizetype, low_bound);\n+\t  if (length\n+\t      && TREE_CODE (length) == INTEGER_CST\n+\t      && TYPE_PRECISION (TREE_TYPE (length))\n+\t\t > TYPE_PRECISION (sizetype))\n+\t    length = fold_convert (sizetype, length);\n+\t  if (low_bound == NULL_TREE)\n+\t    low_bound = integer_zero_node;\n+\t  if (!maybe_zero_len && i > first_non_one)\n+\t    {\n+\t      if (integer_nonzerop (low_bound))\n+\t\tgoto do_warn_noncontiguous;\n+\t      if (length != NULL_TREE\n+\t\t  && TREE_CODE (length) == INTEGER_CST\n+\t\t  && TYPE_DOMAIN (types[i])\n+\t\t  && TYPE_MAX_VALUE (TYPE_DOMAIN (types[i]))\n+\t\t  && TREE_CODE (TYPE_MAX_VALUE (TYPE_DOMAIN (types[i])))\n+\t\t     == INTEGER_CST)\n+\t\t{\n+\t\t  tree size;\n+\t\t  size = size_binop (PLUS_EXPR,\n+\t\t\t\t     TYPE_MAX_VALUE (TYPE_DOMAIN (types[i])),\n+\t\t\t\t     size_one_node);\n+\t\t  if (!tree_int_cst_equal (length, size))\n+\t\t    {\n+\t\t     do_warn_noncontiguous:\n+\t\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\t\"array section is not contiguous in %qs \"\n+\t\t\t\t\"clause\",\n+\t\t\t\tomp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n+\t\t      types.release ();\n+\t\t      return true;\n+\t\t    }\n+\t\t}\n+\t      if (!processing_template_decl\n+\t\t  && length != NULL_TREE\n+\t\t  && TREE_SIDE_EFFECTS (length))\n+\t\t{\n+\t\t  if (side_effects == NULL_TREE)\n+\t\t    side_effects = length;\n+\t\t  else\n+\t\t    side_effects = build2 (COMPOUND_EXPR,\n+\t\t\t\t\t   TREE_TYPE (side_effects),\n+\t\t\t\t\t   length, side_effects);\n+\t\t}\n+\t    }\n+\t  else if (processing_template_decl)\n+\t    continue;\n+\t  else\n+\t    {\n+\t      tree l;\n+\n+\t      if (i > first_non_one && length && integer_nonzerop (length))\n+\t\tcontinue;\n+\t      if (length)\n+\t\tl = fold_convert (sizetype, length);\n+\t      else\n+\t\t{\n+\t\t  l = size_binop (PLUS_EXPR,\n+\t\t\t\t  TYPE_MAX_VALUE (TYPE_DOMAIN (types[i])),\n+\t\t\t\t  size_one_node);\n+\t\t  l = size_binop (MINUS_EXPR, l,\n+\t\t\t\t  fold_convert (sizetype, low_bound));\n+\t\t}\n+\t      if (i > first_non_one)\n+\t\t{\n+\t\t  l = fold_build2 (NE_EXPR, boolean_type_node, l,\n+\t\t\t\t   size_zero_node);\n+\t\t  if (condition == NULL_TREE)\n+\t\t    condition = l;\n+\t\t  else\n+\t\t    condition = fold_build2 (BIT_AND_EXPR, boolean_type_node,\n+\t\t\t\t\t     l, condition);\n+\t\t}\n+\t      else if (size == NULL_TREE)\n+\t\t{\n+\t\t  size = size_in_bytes (TREE_TYPE (types[i]));\n+\t\t  size = size_binop (MULT_EXPR, size, l);\n+\t\t  if (condition)\n+\t\t    size = fold_build3 (COND_EXPR, sizetype, condition,\n+\t\t\t\t\tsize, size_zero_node);\n+\t\t}\n+\t      else\n+\t\tsize = size_binop (MULT_EXPR, size, l);\n+\t    }\n+\t}\n+      types.release ();\n+      if (!processing_template_decl)\n+\t{\n+\t  if (side_effects)\n+\t    size = build2 (COMPOUND_EXPR, sizetype, side_effects, size);\n+\t  OMP_CLAUSE_DECL (c) = first;\n+\t  OMP_CLAUSE_SIZE (c) = size;\n+\t  if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_MAP)\n+\t    return false;\n+\t  tree c2 = build_omp_clause (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\t      OMP_CLAUSE_MAP);\n+\t  OMP_CLAUSE_MAP_KIND (c2) = OMP_CLAUSE_MAP_POINTER;\n+\t  if (!cxx_mark_addressable (t))\n+\t    return false;\n+\t  OMP_CLAUSE_DECL (c2) = t;\n+\t  t = build_fold_addr_expr (first);\n+\t  t = fold_convert_loc (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\tptrdiff_type_node, t);\n+\t  tree ptr = OMP_CLAUSE_DECL (c2);\n+\t  ptr = convert_from_reference (ptr);\n+\t  if (!POINTER_TYPE_P (TREE_TYPE (ptr)))\n+\t    ptr = build_fold_addr_expr (ptr);\n+\t  t = fold_build2_loc (OMP_CLAUSE_LOCATION (c), MINUS_EXPR,\n+\t\t\t       ptrdiff_type_node, t,\n+\t\t\t       fold_convert_loc (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\t\t\t ptrdiff_type_node, ptr));\n+\t  OMP_CLAUSE_SIZE (c2) = t;\n+\t  OMP_CLAUSE_CHAIN (c2) = OMP_CLAUSE_CHAIN (c);\n+\t  OMP_CLAUSE_CHAIN (c) = c2;\n+\t  ptr = OMP_CLAUSE_DECL (c2);\n+\t  if (TREE_CODE (TREE_TYPE (ptr)) == REFERENCE_TYPE\n+\t      && POINTER_TYPE_P (TREE_TYPE (TREE_TYPE (ptr))))\n+\t    {\n+\t      tree c3 = build_omp_clause (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\t\t  OMP_CLAUSE_MAP);\n+\t      OMP_CLAUSE_MAP_KIND (c3) = OMP_CLAUSE_MAP_POINTER;\n+\t      OMP_CLAUSE_DECL (c3) = ptr;\n+\t      OMP_CLAUSE_DECL (c2) = convert_from_reference (ptr);\n+\t      OMP_CLAUSE_SIZE (c3) = size_zero_node;\n+\t      OMP_CLAUSE_CHAIN (c3) = OMP_CLAUSE_CHAIN (c2);\n+\t      OMP_CLAUSE_CHAIN (c2) = c3;\n+\t    }\n+\t}\n+    }\n+  return false;\n+}\n+\n+/* Return identifier to look up for omp declare reduction.  */\n+\n+tree\n+omp_reduction_id (enum tree_code reduction_code, tree reduction_id, tree type)\n+{\n+  const char *p = NULL;\n+  const char *m = NULL;\n+  switch (reduction_code)\n+    {\n+    case PLUS_EXPR:\n+    case MULT_EXPR:\n+    case MINUS_EXPR:\n+    case BIT_AND_EXPR:\n+    case BIT_XOR_EXPR:\n+    case BIT_IOR_EXPR:\n+    case TRUTH_ANDIF_EXPR:\n+    case TRUTH_ORIF_EXPR:\n+      reduction_id = ansi_opname (reduction_code);\n+      break;\n+    case MIN_EXPR:\n+      p = \"min\";\n+      break;\n+    case MAX_EXPR:\n+      p = \"max\";\n+      break;\n+    default:\n+      break;\n+    }\n+\n+  if (p == NULL)\n+    {\n+      if (TREE_CODE (reduction_id) != IDENTIFIER_NODE)\n+\treturn error_mark_node;\n+      p = IDENTIFIER_POINTER (reduction_id);\n+    }\n+\n+  if (type != NULL_TREE)\n+    m = mangle_type_string (TYPE_MAIN_VARIANT (type));\n+\n+  const char prefix[] = \"omp declare reduction \";\n+  size_t lenp = sizeof (prefix);\n+  if (strncmp (p, prefix, lenp - 1) == 0)\n+    lenp = 1;\n+  size_t len = strlen (p);\n+  size_t lenm = m ? strlen (m) + 1 : 0;\n+  char *name = XALLOCAVEC (char, lenp + len + lenm);\n+  if (lenp > 1)\n+    memcpy (name, prefix, lenp - 1);\n+  memcpy (name + lenp - 1, p, len + 1);\n+  if (m)\n+    {\n+      name[lenp + len - 1] = '~';\n+      memcpy (name + lenp + len, m, lenm);\n+    }\n+  return get_identifier (name);\n+}\n+\n+/* Lookup OpenMP UDR ID for TYPE, return the corresponding artificial\n+   FUNCTION_DECL or NULL_TREE if not found.  */\n+\n+static tree\n+omp_reduction_lookup (location_t loc, tree id, tree type, tree *baselinkp,\n+\t\t      vec<tree> *ambiguousp)\n+{\n+  tree orig_id = id;\n+  tree baselink = NULL_TREE;\n+  if (identifier_p (id))\n+    {\n+      cp_id_kind idk;\n+      bool nonint_cst_expression_p;\n+      const char *error_msg;\n+      id = omp_reduction_id (ERROR_MARK, id, type);\n+      tree decl = lookup_name (id);\n+      if (decl == NULL_TREE)\n+\tdecl = error_mark_node;\n+      id = finish_id_expression (id, decl, NULL_TREE, &idk, false, true,\n+\t\t\t\t &nonint_cst_expression_p, false, true, false,\n+\t\t\t\t false, &error_msg, loc);\n+      if (idk == CP_ID_KIND_UNQUALIFIED\n+\t  && identifier_p (id))\n+\t{\n+\t  vec<tree, va_gc> *args = NULL;\n+\t  vec_safe_push (args, build_reference_type (type));\n+\t  id = perform_koenig_lookup (id, args, false, tf_none);\n+\t}\n+    }\n+  else if (TREE_CODE (id) == SCOPE_REF)\n+    id = lookup_qualified_name (TREE_OPERAND (id, 0),\n+\t\t\t\tomp_reduction_id (ERROR_MARK,\n+\t\t\t\t\t\t  TREE_OPERAND (id, 1),\n+\t\t\t\t\t\t  type),\n+\t\t\t\tfalse, false);\n+  tree fns = id;\n+  if (id && is_overloaded_fn (id))\n+    id = get_fns (id);\n+  for (; id; id = OVL_NEXT (id))\n+    {\n+      tree fndecl = OVL_CURRENT (id);\n+      if (TREE_CODE (fndecl) == FUNCTION_DECL)\n+\t{\n+\t  tree argtype = TREE_VALUE (TYPE_ARG_TYPES (TREE_TYPE (fndecl)));\n+\t  if (same_type_p (TREE_TYPE (argtype), type))\n+\t    break;\n+\t}\n+    }\n+  if (id && BASELINK_P (fns))\n+    {\n+      if (baselinkp)\n+\t*baselinkp = fns;\n+      else\n+\tbaselink = fns;\n+    }\n+  if (id == NULL_TREE && CLASS_TYPE_P (type) && TYPE_BINFO (type))\n+    {\n+      vec<tree> ambiguous = vNULL;\n+      tree binfo = TYPE_BINFO (type), base_binfo, ret = NULL_TREE;\n+      unsigned int ix;\n+      if (ambiguousp == NULL)\n+\tambiguousp = &ambiguous;\n+      for (ix = 0; BINFO_BASE_ITERATE (binfo, ix, base_binfo); ix++)\n+\t{\n+\t  id = omp_reduction_lookup (loc, orig_id, BINFO_TYPE (base_binfo),\n+\t\t\t\t     baselinkp ? baselinkp : &baselink,\n+\t\t\t\t     ambiguousp);\n+\t  if (id == NULL_TREE)\n+\t    continue;\n+\t  if (!ambiguousp->is_empty ())\n+\t    ambiguousp->safe_push (id);\n+\t  else if (ret != NULL_TREE)\n+\t    {\n+\t      ambiguousp->safe_push (ret);\n+\t      ambiguousp->safe_push (id);\n+\t      ret = NULL_TREE;\n+\t    }\n+\t  else\n+\t    ret = id;\n+\t}\n+      if (ambiguousp != &ambiguous)\n+\treturn ret;\n+      if (!ambiguous.is_empty ())\n+\t{\n+\t  const char *str = _(\"candidates are:\");\n+\t  unsigned int idx;\n+\t  tree udr;\n+\t  error_at (loc, \"user defined reduction lookup is ambiguous\");\n+\t  FOR_EACH_VEC_ELT (ambiguous, idx, udr)\n+\t    {\n+\t      inform (DECL_SOURCE_LOCATION (udr), \"%s %#D\", str, udr);\n+\t      if (idx == 0)\n+\t\tstr = get_spaces (str);\n+\t    }\n+\t  ambiguous.release ();\n+\t  ret = error_mark_node;\n+\t  baselink = NULL_TREE;\n+\t}\n+      id = ret;\n+    }\n+  if (id && baselink)\n+    perform_or_defer_access_check (BASELINK_BINFO (baselink),\n+\t\t\t\t   id, id, tf_warning_or_error);\n+  return id;\n+}\n+\n+/* Helper function for cp_parser_omp_declare_reduction_exprs\n+   and tsubst_omp_udr.\n+   Remove CLEANUP_STMT for data (omp_priv variable).\n+   Also append INIT_EXPR for DECL_INITIAL of omp_priv after its\n+   DECL_EXPR.  */\n+\n+tree\n+cp_remove_omp_priv_cleanup_stmt (tree *tp, int *walk_subtrees, void *data)\n+{\n+  if (TYPE_P (*tp))\n+    *walk_subtrees = 0;\n+  else if (TREE_CODE (*tp) == CLEANUP_STMT && CLEANUP_DECL (*tp) == (tree) data)\n+    *tp = CLEANUP_BODY (*tp);\n+  else if (TREE_CODE (*tp) == DECL_EXPR)\n+    {\n+      tree decl = DECL_EXPR_DECL (*tp);\n+      if (!processing_template_decl\n+\t  && decl == (tree) data\n+\t  && DECL_INITIAL (decl)\n+\t  && DECL_INITIAL (decl) != error_mark_node)\n+\t{\n+\t  tree list = NULL_TREE;\n+\t  append_to_statement_list_force (*tp, &list);\n+\t  tree init_expr = build2 (INIT_EXPR, void_type_node,\n+\t\t\t\t   decl, DECL_INITIAL (decl));\n+\t  DECL_INITIAL (decl) = NULL_TREE;\n+\t  append_to_statement_list_force (init_expr, &list);\n+\t  *tp = list;\n+\t}\n+    }\n+  return NULL_TREE;\n+}\n+\n+/* Data passed from cp_check_omp_declare_reduction to\n+   cp_check_omp_declare_reduction_r.  */\n+\n+struct cp_check_omp_declare_reduction_data\n+{\n+  location_t loc;\n+  tree stmts[7];\n+  bool combiner_p;\n+};\n+\n+/* Helper function for cp_check_omp_declare_reduction, called via\n+   cp_walk_tree.  */\n+\n+static tree\n+cp_check_omp_declare_reduction_r (tree *tp, int *, void *data)\n+{\n+  struct cp_check_omp_declare_reduction_data *udr_data\n+    = (struct cp_check_omp_declare_reduction_data *) data;\n+  if (SSA_VAR_P (*tp)\n+      && !DECL_ARTIFICIAL (*tp)\n+      && *tp != DECL_EXPR_DECL (udr_data->stmts[udr_data->combiner_p ? 0 : 3])\n+      && *tp != DECL_EXPR_DECL (udr_data->stmts[udr_data->combiner_p ? 1 : 4]))\n+    {\n+      location_t loc = udr_data->loc;\n+      if (udr_data->combiner_p)\n+\terror_at (loc, \"%<#pragma omp declare reduction%> combiner refers to \"\n+\t\t       \"variable %qD which is not %<omp_out%> nor %<omp_in%>\",\n+\t\t  *tp);\n+      else\n+\terror_at (loc, \"%<#pragma omp declare reduction%> initializer refers \"\n+\t\t       \"to variable %qD which is not %<omp_priv%> nor \"\n+\t\t       \"%<omp_orig%>\",\n+\t\t  *tp);\n+      return *tp;\n+    }\n+  return NULL_TREE;\n+}\n+\n+/* Diagnose violation of OpenMP #pragma omp declare reduction restrictions.  */\n+\n+void\n+cp_check_omp_declare_reduction (tree udr)\n+{\n+  tree type = TREE_VALUE (TYPE_ARG_TYPES (TREE_TYPE (udr)));\n+  gcc_assert (TREE_CODE (type) == REFERENCE_TYPE);\n+  type = TREE_TYPE (type);\n+  int i;\n+  location_t loc = DECL_SOURCE_LOCATION (udr);\n+\n+  if (type == error_mark_node)\n+    return;\n+  if (ARITHMETIC_TYPE_P (type))\n+    {\n+      static enum tree_code predef_codes[]\n+\t= { PLUS_EXPR, MULT_EXPR, MINUS_EXPR, BIT_AND_EXPR, BIT_XOR_EXPR,\n+\t    BIT_IOR_EXPR, TRUTH_ANDIF_EXPR, TRUTH_ORIF_EXPR };\n+      for (i = 0; i < 8; i++)\n+\t{\n+\t  tree id = omp_reduction_id (predef_codes[i], NULL_TREE, NULL_TREE);\n+\t  const char *n1 = IDENTIFIER_POINTER (DECL_NAME (udr));\n+\t  const char *n2 = IDENTIFIER_POINTER (id);\n+\t  if (strncmp (n1, n2, IDENTIFIER_LENGTH (id)) == 0\n+\t      && (n1[IDENTIFIER_LENGTH (id)] == '~'\n+\t\t  || n1[IDENTIFIER_LENGTH (id)] == '\\0'))\n+\t    break;\n+\t}\n+\n+      if (i == 8\n+\t  && TREE_CODE (type) != COMPLEX_EXPR)\n+\t{\n+\t  const char prefix_minmax[] = \"omp declare reduction m\";\n+\t  size_t prefix_size = sizeof (prefix_minmax) - 1;\n+\t  const char *n = IDENTIFIER_POINTER (DECL_NAME (udr));\n+\t  if (strncmp (IDENTIFIER_POINTER (DECL_NAME (udr)),\n+\t\t       prefix_minmax, prefix_size) == 0\n+\t      && ((n[prefix_size] == 'i' && n[prefix_size + 1] == 'n')\n+\t\t  || (n[prefix_size] == 'a' && n[prefix_size + 1] == 'x'))\n+\t      && (n[prefix_size + 2] == '~' || n[prefix_size + 2] == '\\0'))\n+\t    i = 0;\n+\t}\n+      if (i < 8)\n+\t{\n+\t  error_at (loc, \"predeclared arithmetic type %qT in \"\n+\t\t\t \"%<#pragma omp declare reduction%>\", type);\n+\t  return;\n+\t}\n+    }\n+  else if (TREE_CODE (type) == FUNCTION_TYPE\n+\t   || TREE_CODE (type) == METHOD_TYPE\n+\t   || TREE_CODE (type) == ARRAY_TYPE)\n+    {\n+      error_at (loc, \"function or array type %qT in \"\n+\t\t     \"%<#pragma omp declare reduction%>\", type);\n+      return;\n+    }\n+  else if (TREE_CODE (type) == REFERENCE_TYPE)\n+    {\n+      error_at (loc, \"reference type %qT in %<#pragma omp declare reduction%>\",\n+\t\ttype);\n+      return;\n+    }\n+  else if (TYPE_QUALS_NO_ADDR_SPACE (type))\n+    {\n+      error_at (loc, \"const, volatile or __restrict qualified type %qT in \"\n+\t\t     \"%<#pragma omp declare reduction%>\", type);\n+      return;\n+    }\n+\n+  tree body = DECL_SAVED_TREE (udr);\n+  if (body == NULL_TREE || TREE_CODE (body) != STATEMENT_LIST)\n+    return;\n+\n+  tree_stmt_iterator tsi;\n+  struct cp_check_omp_declare_reduction_data data;\n+  memset (data.stmts, 0, sizeof data.stmts);\n+  for (i = 0, tsi = tsi_start (body);\n+       i < 7 && !tsi_end_p (tsi);\n+       i++, tsi_next (&tsi))\n+    data.stmts[i] = tsi_stmt (tsi);\n+  data.loc = loc;\n+  gcc_assert (tsi_end_p (tsi));\n+  if (i >= 3)\n+    {\n+      gcc_assert (TREE_CODE (data.stmts[0]) == DECL_EXPR\n+\t\t  && TREE_CODE (data.stmts[1]) == DECL_EXPR);\n+      if (TREE_NO_WARNING (DECL_EXPR_DECL (data.stmts[0])))\n+\treturn;\n+      data.combiner_p = true;\n+      if (cp_walk_tree (&data.stmts[2], cp_check_omp_declare_reduction_r,\n+\t\t\t&data, NULL))\n+\tTREE_NO_WARNING (DECL_EXPR_DECL (data.stmts[0])) = 1;\n+    }\n+  if (i >= 6)\n+    {\n+      gcc_assert (TREE_CODE (data.stmts[3]) == DECL_EXPR\n+\t\t  && TREE_CODE (data.stmts[4]) == DECL_EXPR);\n+      data.combiner_p = false;\n+      if (cp_walk_tree (&data.stmts[5], cp_check_omp_declare_reduction_r,\n+\t\t\t&data, NULL)\n+\t  || cp_walk_tree (&DECL_INITIAL (DECL_EXPR_DECL (data.stmts[3])),\n+\t\t\t   cp_check_omp_declare_reduction_r, &data, NULL))\n+\tTREE_NO_WARNING (DECL_EXPR_DECL (data.stmts[0])) = 1;\n+      if (i == 7)\n+\tgcc_assert (TREE_CODE (data.stmts[6]) == DECL_EXPR);\n+    }\n+}\n+\n+/* Helper function of finish_omp_clauses.  Clone STMT as if we were making\n+   an inline call.  But, remap\n+   the OMP_DECL1 VAR_DECL (omp_out resp. omp_orig) to PLACEHOLDER\n+   and OMP_DECL2 VAR_DECL (omp_in resp. omp_priv) to DECL.  */\n+\n+static tree\n+clone_omp_udr (tree stmt, tree omp_decl1, tree omp_decl2,\n+\t       tree decl, tree placeholder)\n+{\n+  copy_body_data id;\n+  struct pointer_map_t *decl_map = pointer_map_create ();\n+\n+  *pointer_map_insert (decl_map, omp_decl1) = placeholder;\n+  *pointer_map_insert (decl_map, omp_decl2) = decl;\n+  memset (&id, 0, sizeof (id));\n+  id.src_fn = DECL_CONTEXT (omp_decl1);\n+  id.dst_fn = current_function_decl;\n+  id.src_cfun = DECL_STRUCT_FUNCTION (id.src_fn);\n+  id.decl_map = decl_map;\n+\n+  id.copy_decl = copy_decl_no_change;\n+  id.transform_call_graph_edges = CB_CGE_DUPLICATE;\n+  id.transform_new_cfg = true;\n+  id.transform_return_to_modify = false;\n+  id.transform_lang_insert_block = NULL;\n+  id.eh_lp_nr = 0;\n+  walk_tree (&stmt, copy_tree_body_r, &id, NULL);\n+  pointer_map_destroy (decl_map);\n+  return stmt;\n+}\n+\n+/* Helper function of finish_omp_clauses, called via cp_walk_tree.\n+   Find OMP_CLAUSE_PLACEHOLDER (passed in DATA) in *TP.  */\n+\n+static tree\n+find_omp_placeholder_r (tree *tp, int *, void *data)\n+{\n+  if (*tp == (tree) data)\n+    return *tp;\n+  return NULL_TREE;\n+}\n+\n+/* Helper function of finish_omp_clauses.  Handle OMP_CLAUSE_REDUCTION C.\n+   Return true if there is some error and the clause should be removed.  */\n+\n+static bool\n+finish_omp_reduction_clause (tree c, bool *need_default_ctor, bool *need_dtor)\n+{\n+  tree t = OMP_CLAUSE_DECL (c);\n+  bool predefined = false;\n+  tree type = TREE_TYPE (t);\n+  if (TREE_CODE (type) == REFERENCE_TYPE)\n+    type = TREE_TYPE (type);\n+  if (ARITHMETIC_TYPE_P (type))\n+    switch (OMP_CLAUSE_REDUCTION_CODE (c))\n+      {\n+      case PLUS_EXPR:\n+      case MULT_EXPR:\n+      case MINUS_EXPR:\n+\tpredefined = true;\n+\tbreak;\n+      case MIN_EXPR:\n+      case MAX_EXPR:\n+\tif (TREE_CODE (type) == COMPLEX_TYPE)\n+\t  break;\n+\tpredefined = true;\n+\tbreak;\n+      case BIT_AND_EXPR:\n+      case BIT_IOR_EXPR:\n+      case BIT_XOR_EXPR:\n+      case TRUTH_ANDIF_EXPR:\n+      case TRUTH_ORIF_EXPR:\n+\tif (FLOAT_TYPE_P (type))\n+\t  break;\n+\tpredefined = true;\n+\tbreak;\n+      default:\n+\tbreak;\n+      }\n+  else if (TREE_CODE (type) == ARRAY_TYPE || TYPE_READONLY (type))\n+    {\n+      error (\"%qE has invalid type for %<reduction%>\", t);\n+      return true;\n+    }\n+  else if (!processing_template_decl)\n+    {\n+      t = require_complete_type (t);\n+      if (t == error_mark_node)\n+\treturn true;\n+      OMP_CLAUSE_DECL (c) = t;\n+    }\n+\n+  if (predefined)\n+    {\n+      OMP_CLAUSE_REDUCTION_PLACEHOLDER (c) = NULL_TREE;\n+      return false;\n+    }\n+  else if (processing_template_decl)\n+    return false;\n+\n+  tree id = OMP_CLAUSE_REDUCTION_PLACEHOLDER (c);\n+\n+  type = TYPE_MAIN_VARIANT (TREE_TYPE (t));\n+  if (TREE_CODE (type) == REFERENCE_TYPE)\n+    type = TREE_TYPE (type);\n+  OMP_CLAUSE_REDUCTION_PLACEHOLDER (c) = NULL_TREE;\n+  if (id == NULL_TREE)\n+    id = omp_reduction_id (OMP_CLAUSE_REDUCTION_CODE (c),\n+\t\t\t   NULL_TREE, NULL_TREE);\n+  id = omp_reduction_lookup (OMP_CLAUSE_LOCATION (c), id, type, NULL, NULL);\n+  if (id)\n+    {\n+      if (id == error_mark_node)\n+\treturn true;\n+      id = OVL_CURRENT (id);\n+      mark_used (id);\n+      tree body = DECL_SAVED_TREE (id);\n+      if (TREE_CODE (body) == STATEMENT_LIST)\n+\t{\n+\t  tree_stmt_iterator tsi;\n+\t  tree placeholder = NULL_TREE;\n+\t  int i;\n+\t  tree stmts[7];\n+\t  tree atype = TREE_VALUE (TYPE_ARG_TYPES (TREE_TYPE (id)));\n+\t  atype = TREE_TYPE (atype);\n+\t  bool need_static_cast = !same_type_p (type, atype);\n+\t  memset (stmts, 0, sizeof stmts);\n+\t  for (i = 0, tsi = tsi_start (body);\n+\t       i < 7 && !tsi_end_p (tsi);\n+\t       i++, tsi_next (&tsi))\n+\t    stmts[i] = tsi_stmt (tsi);\n+\t  gcc_assert (tsi_end_p (tsi));\n+\n+\t  if (i >= 3)\n+\t    {\n+\t      gcc_assert (TREE_CODE (stmts[0]) == DECL_EXPR\n+\t\t\t  && TREE_CODE (stmts[1]) == DECL_EXPR);\n+\t      placeholder = build_lang_decl (VAR_DECL, NULL_TREE, type);\n+\t      DECL_ARTIFICIAL (placeholder) = 1;\n+\t      DECL_IGNORED_P (placeholder) = 1;\n+\t      OMP_CLAUSE_REDUCTION_PLACEHOLDER (c) = placeholder;\n+\t      if (TREE_ADDRESSABLE (DECL_EXPR_DECL (stmts[0])))\n+\t\tcxx_mark_addressable (placeholder);\n+\t      if (TREE_ADDRESSABLE (DECL_EXPR_DECL (stmts[1]))\n+\t\t  && TREE_CODE (TREE_TYPE (OMP_CLAUSE_DECL (c)))\n+\t\t     != REFERENCE_TYPE)\n+\t\tcxx_mark_addressable (OMP_CLAUSE_DECL (c));\n+\t      tree omp_out = placeholder;\n+\t      tree omp_in = convert_from_reference (OMP_CLAUSE_DECL (c));\n+\t      if (need_static_cast)\n+\t\t{\n+\t\t  tree rtype = build_reference_type (atype);\n+\t\t  omp_out = build_static_cast (rtype, omp_out,\n+\t\t\t\t\t       tf_warning_or_error);\n+\t\t  omp_in = build_static_cast (rtype, omp_in,\n+\t\t\t\t\t      tf_warning_or_error);\n+\t\t  if (omp_out == error_mark_node || omp_in == error_mark_node)\n+\t\t    return true;\n+\t\t  omp_out = convert_from_reference (omp_out);\n+\t\t  omp_in = convert_from_reference (omp_in);\n+\t\t}\n+\t      OMP_CLAUSE_REDUCTION_MERGE (c)\n+\t\t= clone_omp_udr (stmts[2], DECL_EXPR_DECL (stmts[0]),\n+\t\t\t\t DECL_EXPR_DECL (stmts[1]), omp_in, omp_out);\n+\t    }\n+\t  if (i >= 6)\n+\t    {\n+\t      gcc_assert (TREE_CODE (stmts[3]) == DECL_EXPR\n+\t\t\t  && TREE_CODE (stmts[4]) == DECL_EXPR);\n+\t      if (TREE_ADDRESSABLE (DECL_EXPR_DECL (stmts[3])))\n+\t\tcxx_mark_addressable (OMP_CLAUSE_DECL (c));\n+\t      if (TREE_ADDRESSABLE (DECL_EXPR_DECL (stmts[4])))\n+\t\tcxx_mark_addressable (placeholder);\n+\t      tree omp_priv = convert_from_reference (OMP_CLAUSE_DECL (c));\n+\t      tree omp_orig = placeholder;\n+\t      if (need_static_cast)\n+\t\t{\n+\t\t  if (i == 7)\n+\t\t    {\n+\t\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\t\"user defined reduction with constructor \"\n+\t\t\t\t\"initializer for base class %qT\", atype);\n+\t\t      return true;\n+\t\t    }\n+\t\t  tree rtype = build_reference_type (atype);\n+\t\t  omp_priv = build_static_cast (rtype, omp_priv,\n+\t\t\t\t\t\ttf_warning_or_error);\n+\t\t  omp_orig = build_static_cast (rtype, omp_orig,\n+\t\t\t\t\t\ttf_warning_or_error);\n+\t\t  if (omp_priv == error_mark_node\n+\t\t      || omp_orig == error_mark_node)\n+\t\t    return true;\n+\t\t  omp_priv = convert_from_reference (omp_priv);\n+\t\t  omp_orig = convert_from_reference (omp_orig);\n+\t\t}\n+\t      if (i == 6)\n+\t\t*need_default_ctor = true;\n+\t      OMP_CLAUSE_REDUCTION_INIT (c)\n+\t\t= clone_omp_udr (stmts[5], DECL_EXPR_DECL (stmts[4]),\n+\t\t\t\t DECL_EXPR_DECL (stmts[3]),\n+\t\t\t\t omp_priv, omp_orig);\n+\t      if (cp_walk_tree (&OMP_CLAUSE_REDUCTION_INIT (c),\n+\t\t\t\tfind_omp_placeholder_r, placeholder, NULL))\n+\t\tOMP_CLAUSE_REDUCTION_OMP_ORIG_REF (c) = 1;\n+\t    }\n+\t  else if (i >= 3)\n+\t    {\n+\t      if (CLASS_TYPE_P (type) && !pod_type_p (type))\n+\t\t*need_default_ctor = true;\n+\t      else\n+\t\t{\n+\t\t  tree init;\n+\t\t  tree v = convert_from_reference (t);\n+\t\t  if (AGGREGATE_TYPE_P (TREE_TYPE (v)))\n+\t\t    init = build_constructor (TREE_TYPE (v), NULL);\n+\t\t  else\n+\t\t    init = fold_convert (TREE_TYPE (v), integer_zero_node);\n+\t\t  OMP_CLAUSE_REDUCTION_INIT (c)\n+\t\t    = build2 (INIT_EXPR, TREE_TYPE (v), v, init);\n+\t\t}\n+\t    }\n+\t}\n+    }\n+  if (OMP_CLAUSE_REDUCTION_PLACEHOLDER (c))\n+    *need_dtor = true;\n+  else\n+    {\n+      error (\"user defined reduction not found for %qD\", t);\n+      return true;\n+    }\n+  return false;\n+}\n+\n /* For all elements of CLAUSES, validate them vs OpenMP constraints.\n    Remove any elements from the list that are invalid.  */\n \n tree\n finish_omp_clauses (tree clauses)\n {\n   bitmap_head generic_head, firstprivate_head, lastprivate_head;\n+  bitmap_head aligned_head;\n   tree c, t, *pc = &clauses;\n-  const char *name;\n+  bool branch_seen = false;\n+  bool copyprivate_seen = false;\n \n   bitmap_obstack_initialize (NULL);\n   bitmap_initialize (&generic_head, &bitmap_default_obstack);\n   bitmap_initialize (&firstprivate_head, &bitmap_default_obstack);\n   bitmap_initialize (&lastprivate_head, &bitmap_default_obstack);\n+  bitmap_initialize (&aligned_head, &bitmap_default_obstack);\n \n   for (pc = &clauses, c = clauses; c ; c = *pc)\n     {\n@@ -4108,19 +5142,58 @@ finish_omp_clauses (tree clauses)\n       switch (OMP_CLAUSE_CODE (c))\n \t{\n \tcase OMP_CLAUSE_SHARED:\n-\t  name = \"shared\";\n \t  goto check_dup_generic;\n \tcase OMP_CLAUSE_PRIVATE:\n-\t  name = \"private\";\n \t  goto check_dup_generic;\n \tcase OMP_CLAUSE_REDUCTION:\n-\t  name = \"reduction\";\n \t  goto check_dup_generic;\n \tcase OMP_CLAUSE_COPYPRIVATE:\n-\t  name = \"copyprivate\";\n+\t  copyprivate_seen = true;\n \t  goto check_dup_generic;\n \tcase OMP_CLAUSE_COPYIN:\n-\t  name = \"copyin\";\n+\t  goto check_dup_generic;\n+\tcase OMP_CLAUSE_LINEAR:\n+\t  t = OMP_CLAUSE_DECL (c);\n+\t  if (!type_dependent_expression_p (t)\n+\t      && !INTEGRAL_TYPE_P (TREE_TYPE (t))\n+\t      && TREE_CODE (TREE_TYPE (t)) != POINTER_TYPE)\n+\t    {\n+\t      error (\"linear clause applied to non-integral non-pointer \"\n+\t\t     \"variable with %qT type\", TREE_TYPE (t));\n+\t      remove = true;\n+\t      break;\n+\t    }\n+\t  t = OMP_CLAUSE_LINEAR_STEP (c);\n+\t  if (t == NULL_TREE)\n+\t    t = integer_one_node;\n+\t  if (t == error_mark_node)\n+\t    remove = true;\n+\t  else if (!type_dependent_expression_p (t)\n+\t\t   && !INTEGRAL_TYPE_P (TREE_TYPE (t)))\n+\t    {\n+\t      error (\"linear step expression must be integral\");\n+\t      remove = true;\n+\t    }\n+\t  else\n+\t    {\n+\t      t = mark_rvalue_use (t);\n+\t      if (!processing_template_decl)\n+\t\t{\n+\t\t  t = fold_build_cleanup_point_expr (TREE_TYPE (t), t);\n+\t\t  if (TREE_CODE (TREE_TYPE (OMP_CLAUSE_DECL (c)))\n+\t\t      == POINTER_TYPE)\n+\t\t    {\n+\t\t      t = pointer_int_sum (OMP_CLAUSE_LOCATION (c), PLUS_EXPR,\n+\t\t\t\t\t   OMP_CLAUSE_DECL (c), t);\n+\t\t      t = fold_build2_loc (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\t\t   MINUS_EXPR, sizetype, t,\n+\t\t\t\t\t   OMP_CLAUSE_DECL (c));\n+\t\t      if (t == error_mark_node)\n+\t\t\tremove = true;\n+\t\t    }\n+\t\t}\n+\t      OMP_CLAUSE_LINEAR_STEP (c) = t;\n+\t    }\n \t  goto check_dup_generic;\n \tcheck_dup_generic:\n \t  t = OMP_CLAUSE_DECL (c);\n@@ -4129,9 +5202,11 @@ finish_omp_clauses (tree clauses)\n \t      if (processing_template_decl)\n \t\tbreak;\n \t      if (DECL_P (t))\n-\t\terror (\"%qD is not a variable in clause %qs\", t, name);\n+\t\terror (\"%qD is not a variable in clause %qs\", t,\n+\t\t       omp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n \t      else\n-\t\terror (\"%qE is not a variable in clause %qs\", t, name);\n+\t\terror (\"%qE is not a variable in clause %qs\", t,\n+\t\t       omp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n \t      remove = true;\n \t    }\n \t  else if (bitmap_bit_p (&generic_head, DECL_UID (t))\n@@ -4249,12 +5324,299 @@ finish_omp_clauses (tree clauses)\n \t    }\n \t  break;\n \n+\tcase OMP_CLAUSE_SIMDLEN:\n+\tcase OMP_CLAUSE_SAFELEN:\n+\t  t = OMP_CLAUSE_OPERAND (c, 0);\n+\t  if (t == error_mark_node)\n+\t    remove = true;\n+\t  else if (!type_dependent_expression_p (t)\n+\t\t   && !INTEGRAL_TYPE_P (TREE_TYPE (t)))\n+\t    {\n+\t      error (\"%qs length expression must be integral\",\n+\t\t     omp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n+\t      remove = true;\n+\t    }\n+\t  else\n+\t    {\n+\t      t = mark_rvalue_use (t);\n+\t      t = maybe_constant_value (t);\n+\t      if (!processing_template_decl)\n+\t\t{\n+\t\t  if (TREE_CODE (t) != INTEGER_CST\n+\t\t      || tree_int_cst_sgn (t) != 1)\n+\t\t    {\n+\t\t      error (\"%qs length expression must be positive constant\"\n+\t\t\t     \" integer expression\",\n+\t\t\t     omp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n+\t\t      remove = true;\n+\t\t    }\n+\t\t}\n+\t      OMP_CLAUSE_OPERAND (c, 0) = t;\n+\t    }\n+\t  break;\n+\n+\tcase OMP_CLAUSE_NUM_TEAMS:\n+\t  t = OMP_CLAUSE_NUM_TEAMS_EXPR (c);\n+\t  if (t == error_mark_node)\n+\t    remove = true;\n+\t  else if (!type_dependent_expression_p (t)\n+\t\t   && !INTEGRAL_TYPE_P (TREE_TYPE (t)))\n+\t    {\n+\t      error (\"%<num_teams%> expression must be integral\");\n+\t      remove = true;\n+\t    }\n+\t  else\n+\t    {\n+\t      t = mark_rvalue_use (t);\n+\t      if (!processing_template_decl)\n+\t\tt = fold_build_cleanup_point_expr (TREE_TYPE (t), t);\n+\t      OMP_CLAUSE_NUM_TEAMS_EXPR (c) = t;\n+\t    }\n+\t  break;\n+\n+\tcase OMP_CLAUSE_THREAD_LIMIT:\n+\t  t = OMP_CLAUSE_THREAD_LIMIT_EXPR (c);\n+\t  if (t == error_mark_node)\n+\t    remove = true;\n+\t  else if (!type_dependent_expression_p (t)\n+\t\t   && !INTEGRAL_TYPE_P (TREE_TYPE (t)))\n+\t    {\n+\t      error (\"%<thread_limit%> expression must be integral\");\n+\t      remove = true;\n+\t    }\n+\t  else\n+\t    {\n+\t      t = mark_rvalue_use (t);\n+\t      if (!processing_template_decl)\n+\t\tt = fold_build_cleanup_point_expr (TREE_TYPE (t), t);\n+\t      OMP_CLAUSE_THREAD_LIMIT_EXPR (c) = t;\n+\t    }\n+\t  break;\n+\n+\tcase OMP_CLAUSE_DEVICE:\n+\t  t = OMP_CLAUSE_DEVICE_ID (c);\n+\t  if (t == error_mark_node)\n+\t    remove = true;\n+\t  else if (!type_dependent_expression_p (t)\n+\t\t   && !INTEGRAL_TYPE_P (TREE_TYPE (t)))\n+\t    {\n+\t      error (\"%<device%> id must be integral\");\n+\t      remove = true;\n+\t    }\n+\t  else\n+\t    {\n+\t      t = mark_rvalue_use (t);\n+\t      if (!processing_template_decl)\n+\t\tt = fold_build_cleanup_point_expr (TREE_TYPE (t), t);\n+\t      OMP_CLAUSE_DEVICE_ID (c) = t;\n+\t    }\n+\t  break;\n+\n+\tcase OMP_CLAUSE_DIST_SCHEDULE:\n+\t  t = OMP_CLAUSE_DIST_SCHEDULE_CHUNK_EXPR (c);\n+\t  if (t == NULL)\n+\t    ;\n+\t  else if (t == error_mark_node)\n+\t    remove = true;\n+\t  else if (!type_dependent_expression_p (t)\n+\t\t   && !INTEGRAL_TYPE_P (TREE_TYPE (t)))\n+\t    {\n+\t      error (\"%<dist_schedule%> chunk size expression must be \"\n+\t\t     \"integral\");\n+\t      remove = true;\n+\t    }\n+\t  else\n+\t    {\n+\t      t = mark_rvalue_use (t);\n+\t      if (!processing_template_decl)\n+\t\tt = fold_build_cleanup_point_expr (TREE_TYPE (t), t);\n+\t      OMP_CLAUSE_DIST_SCHEDULE_CHUNK_EXPR (c) = t;\n+\t    }\n+\t  break;\n+\n+\tcase OMP_CLAUSE_ALIGNED:\n+\t  t = OMP_CLAUSE_DECL (c);\n+\t  if (TREE_CODE (t) != VAR_DECL && TREE_CODE (t) != PARM_DECL)\n+\t    {\n+\t      if (processing_template_decl)\n+\t\tbreak;\n+\t      if (DECL_P (t))\n+\t\terror (\"%qD is not a variable in %<aligned%> clause\", t);\n+\t      else\n+\t\terror (\"%qE is not a variable in %<aligned%> clause\", t);\n+\t      remove = true;\n+\t    }\n+\t  else if (bitmap_bit_p (&aligned_head, DECL_UID (t)))\n+\t    {\n+\t      error (\"%qD appears more than once in %<aligned%> clauses\", t);\n+\t      remove = true;\n+\t    }\n+\t  else\n+\t    bitmap_set_bit (&aligned_head, DECL_UID (t));\n+\t  t = OMP_CLAUSE_ALIGNED_ALIGNMENT (c);\n+\t  if (t == error_mark_node)\n+\t    remove = true;\n+\t  else if (t == NULL_TREE)\n+\t    break;\n+\t  else if (!type_dependent_expression_p (t)\n+\t\t   && !INTEGRAL_TYPE_P (TREE_TYPE (t)))\n+\t    {\n+\t      error (\"%<aligned%> clause alignment expression must \"\n+\t\t     \"be integral\");\n+\t      remove = true;\n+\t    }\n+\t  else\n+\t    {\n+\t      t = mark_rvalue_use (t);\n+\t      t = maybe_constant_value (t);\n+\t      if (!processing_template_decl)\n+\t\t{\n+\t\t  if (TREE_CODE (t) != INTEGER_CST\n+\t\t      || tree_int_cst_sgn (t) != 1)\n+\t\t    {\n+\t\t      error (\"%<aligned%> clause alignment expression must be \"\n+\t\t\t     \"positive constant integer expression\");\n+\t\t      remove = true;\n+\t\t    }\n+\t\t}\n+\t      OMP_CLAUSE_ALIGNED_ALIGNMENT (c) = t;\n+\t    }\n+\t  break;\n+\n+\tcase OMP_CLAUSE_DEPEND:\n+\t  t = OMP_CLAUSE_DECL (c);\n+\t  if (TREE_CODE (t) == TREE_LIST)\n+\t    {\n+\t      if (handle_omp_array_sections (c))\n+\t\tremove = true;\n+\t      break;\n+\t    }\n+\t  if (t == error_mark_node)\n+\t    remove = true;\n+\t  else if (TREE_CODE (t) != VAR_DECL && TREE_CODE (t) != PARM_DECL)\n+\t    {\n+\t      if (processing_template_decl)\n+\t\tbreak;\n+\t      if (DECL_P (t))\n+\t\terror (\"%qD is not a variable in %<depend%> clause\", t);\n+\t      else\n+\t\terror (\"%qE is not a variable in %<depend%> clause\", t);\n+\t      remove = true;\n+\t    }\n+\t  else if (!processing_template_decl\n+\t\t   && !cxx_mark_addressable (t))\n+\t    remove = true;\n+\t  break;\n+\n+\tcase OMP_CLAUSE_MAP:\n+\tcase OMP_CLAUSE_TO:\n+\tcase OMP_CLAUSE_FROM:\n+\t  t = OMP_CLAUSE_DECL (c);\n+\t  if (TREE_CODE (t) == TREE_LIST)\n+\t    {\n+\t      if (handle_omp_array_sections (c))\n+\t\tremove = true;\n+\t      else\n+\t\t{\n+\t\t  t = OMP_CLAUSE_DECL (c);\n+\t\t  if (!cp_omp_mappable_type (TREE_TYPE (t)))\n+\t\t    {\n+\t\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\t\"array section does not have mappable type \"\n+\t\t\t\t\"in %qs clause\",\n+\t\t\t\tomp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n+\t\t      remove = true;\n+\t\t    }\n+\t\t}\n+\t      break;\n+\t    }\n+\t  if (t == error_mark_node)\n+\t    remove = true;\n+\t  else if (TREE_CODE (t) != VAR_DECL && TREE_CODE (t) != PARM_DECL)\n+\t    {\n+\t      if (processing_template_decl)\n+\t\tbreak;\n+\t      if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_MAP\n+\t\t  && OMP_CLAUSE_MAP_KIND (c) == OMP_CLAUSE_MAP_POINTER)\n+\t\tbreak;\n+\t      if (DECL_P (t))\n+\t\terror (\"%qD is not a variable in %qs clause\", t,\n+\t\t       omp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n+\t      else\n+\t\terror (\"%qE is not a variable in %qs clause\", t,\n+\t\t       omp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n+\t      remove = true;\n+\t    }\n+\t  else if (TREE_CODE (t) == VAR_DECL && DECL_THREAD_LOCAL_P (t))\n+\t    {\n+\t      error (\"%qD is threadprivate variable in %qs clause\", t,\n+\t\t     omp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n+\t      remove = true;\n+\t    }\n+\t  else if (!processing_template_decl\n+\t\t   && TREE_CODE (TREE_TYPE (t)) != REFERENCE_TYPE\n+\t\t   && !cxx_mark_addressable (t))\n+\t    remove = true;\n+\t  else if (!(OMP_CLAUSE_CODE (c) == OMP_CLAUSE_MAP\n+\t\t     && OMP_CLAUSE_MAP_KIND (c) == OMP_CLAUSE_MAP_POINTER)\n+\t\t   && !cp_omp_mappable_type ((TREE_CODE (TREE_TYPE (t))\n+\t\t\t\t\t      == REFERENCE_TYPE)\n+\t\t\t\t\t     ? TREE_TYPE (TREE_TYPE (t))\n+\t\t\t\t\t     : TREE_TYPE (t)))\n+\t    {\n+\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\"%qD does not have a mappable type in %qs clause\", t,\n+\t\t\tomp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n+\t      remove = true;\n+\t    }\n+\t  else if (bitmap_bit_p (&generic_head, DECL_UID (t)))\n+\t    {\n+\t      if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_MAP)\n+\t\terror (\"%qD appears more than once in motion clauses\", t);\n+\t      else\n+\t\terror (\"%qD appears more than once in map clauses\", t);\n+\t      remove = true;\n+\t    }\n+\t  else\n+\t    bitmap_set_bit (&generic_head, DECL_UID (t));\n+\t  break;\n+\n+\tcase OMP_CLAUSE_UNIFORM:\n+\t  t = OMP_CLAUSE_DECL (c);\n+\t  if (TREE_CODE (t) != PARM_DECL)\n+\t    {\n+\t      if (processing_template_decl)\n+\t\tbreak;\n+\t      if (DECL_P (t))\n+\t\terror (\"%qD is not an argument in %<uniform%> clause\", t);\n+\t      else\n+\t\terror (\"%qE is not an argument in %<uniform%> clause\", t);\n+\t      remove = true;\n+\t    }\n+\t  break;\n+\n \tcase OMP_CLAUSE_NOWAIT:\n \tcase OMP_CLAUSE_ORDERED:\n \tcase OMP_CLAUSE_DEFAULT:\n \tcase OMP_CLAUSE_UNTIED:\n \tcase OMP_CLAUSE_COLLAPSE:\n \tcase OMP_CLAUSE_MERGEABLE:\n+\tcase OMP_CLAUSE_PARALLEL:\n+\tcase OMP_CLAUSE_FOR:\n+\tcase OMP_CLAUSE_SECTIONS:\n+\tcase OMP_CLAUSE_TASKGROUP:\n+\tcase OMP_CLAUSE_PROC_BIND:\n+\t  break;\n+\n+\tcase OMP_CLAUSE_INBRANCH:\n+\tcase OMP_CLAUSE_NOTINBRANCH:\n+\t  if (branch_seen)\n+\t    {\n+\t      error (\"%<inbranch%> clause is incompatible with \"\n+\t\t     \"%<notinbranch%>\");\n+\t      remove = true;\n+\t    }\n+\t  branch_seen = true;\n \t  break;\n \n \tdefault:\n@@ -4276,44 +5638,50 @@ finish_omp_clauses (tree clauses)\n       bool need_copy_ctor = false;\n       bool need_copy_assignment = false;\n       bool need_implicitly_determined = false;\n+      bool need_dtor = false;\n       tree type, inner_type;\n \n       switch (c_kind)\n \t{\n \tcase OMP_CLAUSE_SHARED:\n-\t  name = \"shared\";\n \t  need_implicitly_determined = true;\n \t  break;\n \tcase OMP_CLAUSE_PRIVATE:\n-\t  name = \"private\";\n \t  need_complete_non_reference = true;\n \t  need_default_ctor = true;\n+\t  need_dtor = true;\n \t  need_implicitly_determined = true;\n \t  break;\n \tcase OMP_CLAUSE_FIRSTPRIVATE:\n-\t  name = \"firstprivate\";\n \t  need_complete_non_reference = true;\n \t  need_copy_ctor = true;\n+\t  need_dtor = true;\n \t  need_implicitly_determined = true;\n \t  break;\n \tcase OMP_CLAUSE_LASTPRIVATE:\n-\t  name = \"lastprivate\";\n \t  need_complete_non_reference = true;\n \t  need_copy_assignment = true;\n \t  need_implicitly_determined = true;\n \t  break;\n \tcase OMP_CLAUSE_REDUCTION:\n-\t  name = \"reduction\";\n \t  need_implicitly_determined = true;\n \t  break;\n \tcase OMP_CLAUSE_COPYPRIVATE:\n-\t  name = \"copyprivate\";\n \t  need_copy_assignment = true;\n \t  break;\n \tcase OMP_CLAUSE_COPYIN:\n-\t  name = \"copyin\";\n \t  need_copy_assignment = true;\n \t  break;\n+\tcase OMP_CLAUSE_NOWAIT:\n+\t  if (copyprivate_seen)\n+\t    {\n+\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\"%<nowait%> clause must not be used together \"\n+\t\t\t\"with %<copyprivate%>\");\n+\t      *pc = OMP_CLAUSE_CHAIN (c);\n+\t      continue;\n+\t    }\n+\t  /* FALLTHRU */\n \tdefault:\n \t  pc = &OMP_CLAUSE_CHAIN (c);\n \t  continue;\n@@ -4331,33 +5699,18 @@ finish_omp_clauses (tree clauses)\n \t{\n \tcase OMP_CLAUSE_LASTPRIVATE:\n \t  if (!bitmap_bit_p (&firstprivate_head, DECL_UID (t)))\n-\t    need_default_ctor = true;\n+\t    {\n+\t      need_default_ctor = true;\n+\t      need_dtor = true;\n+\t    }\n \t  break;\n \n \tcase OMP_CLAUSE_REDUCTION:\n-\t  if (AGGREGATE_TYPE_P (TREE_TYPE (t))\n-\t      || POINTER_TYPE_P (TREE_TYPE (t)))\n-\t    {\n-\t      error (\"%qE has invalid type for %<reduction%>\", t);\n-\t      remove = true;\n-\t    }\n-\t  else if (FLOAT_TYPE_P (TREE_TYPE (t)))\n-\t    {\n-\t      enum tree_code r_code = OMP_CLAUSE_REDUCTION_CODE (c);\n-\t      switch (r_code)\n-\t\t{\n-\t\tcase PLUS_EXPR:\n-\t\tcase MULT_EXPR:\n-\t\tcase MINUS_EXPR:\n-\t\tcase MIN_EXPR:\n-\t\tcase MAX_EXPR:\n-\t\t  break;\n-\t\tdefault:\n-\t\t  error (\"%qE has invalid type for %<reduction(%s)%>\",\n-\t\t\t t, operator_name_info[r_code].name);\n-\t\t  remove = true;\n-\t\t}\n-\t    }\n+\t  if (finish_omp_reduction_clause (c, &need_default_ctor,\n+\t\t\t\t\t   &need_dtor))\n+\t    remove = true;\n+\t  else\n+\t    t = OMP_CLAUSE_DECL (c);\n \t  break;\n \n \tcase OMP_CLAUSE_COPYIN:\n@@ -4380,7 +5733,8 @@ finish_omp_clauses (tree clauses)\n \t  else if (TREE_CODE (TREE_TYPE (t)) == REFERENCE_TYPE\n \t\t   && need_complete_non_reference)\n \t    {\n-\t      error (\"%qE has reference type for %qs\", t, name);\n+\t      error (\"%qE has reference type for %qs\", t,\n+\t\t     omp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n \t      remove = true;\n \t    }\n \t}\n@@ -4410,7 +5764,7 @@ finish_omp_clauses (tree clauses)\n \t  if (share_name)\n \t    {\n \t      error (\"%qE is predetermined %qs for %qs\",\n-\t\t     t, share_name, name);\n+\t\t     t, share_name, omp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n \t      remove = true;\n \t    }\n \t}\n@@ -4420,15 +5774,21 @@ finish_omp_clauses (tree clauses)\n       while (TREE_CODE (inner_type) == ARRAY_TYPE)\n \tinner_type = TREE_TYPE (inner_type);\n \n+      if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_REDUCTION\n+\t  && TREE_CODE (inner_type) == REFERENCE_TYPE)\n+\tinner_type = TREE_TYPE (inner_type);\n+\n       /* Check for special function availability by building a call to one.\n \t Save the results, because later we won't be in the right context\n \t for making these queries.  */\n       if (CLASS_TYPE_P (inner_type)\n \t  && COMPLETE_TYPE_P (inner_type)\n-\t  && (need_default_ctor || need_copy_ctor || need_copy_assignment)\n+\t  && (need_default_ctor || need_copy_ctor\n+\t      || need_copy_assignment || need_dtor)\n \t  && !type_dependent_expression_p (t)\n \t  && cxx_omp_create_clause_info (c, inner_type, need_default_ctor,\n-\t\t\t\t\t need_copy_ctor, need_copy_assignment))\n+\t\t\t\t\t need_copy_ctor, need_copy_assignment,\n+\t\t\t\t\t need_dtor))\n \tremove = true;\n \n       if (remove)\n@@ -4809,8 +6169,8 @@ handle_omp_for_class_iterator (int i, location_t locus, tree declv, tree initv,\n    sk_omp scope.  */\n \n tree\n-finish_omp_for (location_t locus, tree declv, tree initv, tree condv,\n-\t\ttree incrv, tree body, tree pre_body, tree clauses)\n+finish_omp_for (location_t locus, enum tree_code code, tree declv, tree initv,\n+\t\ttree condv, tree incrv, tree body, tree pre_body, tree clauses)\n {\n   tree omp_for = NULL, orig_incr = NULL;\n   tree decl, init, cond, incr;\n@@ -4879,7 +6239,7 @@ finish_omp_for (location_t locus, tree declv, tree initv, tree condv,\n     {\n       tree stmt;\n \n-      stmt = make_node (OMP_FOR);\n+      stmt = make_node (code);\n \n       for (i = 0; i < TREE_VEC_LENGTH (declv); i++)\n \t{\n@@ -4937,6 +6297,12 @@ finish_omp_for (location_t locus, tree declv, tree initv, tree condv,\n \n       if (CLASS_TYPE_P (TREE_TYPE (decl)))\n \t{\n+\t  if (code == OMP_SIMD)\n+\t    {\n+\t      error_at (elocus, \"%<#pragma omp simd%> used with class \"\n+\t\t\t\t\"iteration variable %qE\", decl);\n+\t      return NULL;\n+\t    }\n \t  if (handle_omp_for_class_iterator (i, locus, declv, initv, condv,\n \t\t\t\t\t     incrv, &body, &pre_body, clauses))\n \t    return NULL;\n@@ -4991,7 +6357,7 @@ finish_omp_for (location_t locus, tree declv, tree initv, tree condv,\n   if (IS_EMPTY_STMT (pre_body))\n     pre_body = NULL;\n \n-  omp_for = c_finish_omp_for (locus, declv, initv, condv, incrv,\n+  omp_for = c_finish_omp_for (locus, code, declv, initv, condv, incrv,\n \t\t\t      body, pre_body);\n \n   if (omp_for == NULL)\n@@ -5036,7 +6402,7 @@ finish_omp_for (location_t locus, tree declv, tree initv, tree condv,\n \n void\n finish_omp_atomic (enum tree_code code, enum tree_code opcode, tree lhs,\n-\t\t   tree rhs, tree v, tree lhs1, tree rhs1)\n+\t\t   tree rhs, tree v, tree lhs1, tree rhs1, bool seq_cst)\n {\n   tree orig_lhs;\n   tree orig_rhs;\n@@ -5078,8 +6444,36 @@ finish_omp_atomic (enum tree_code code, enum tree_code opcode, tree lhs,\n     }\n   if (!dependent_p)\n     {\n+      bool swapped = false;\n+      if (rhs1 && cp_tree_equal (lhs, rhs))\n+\t{\n+\t  tree tem = rhs;\n+\t  rhs = rhs1;\n+\t  rhs1 = tem;\n+\t  swapped = !commutative_tree_code (opcode);\n+\t}\n+      if (rhs1 && !cp_tree_equal (lhs, rhs1))\n+\t{\n+\t  if (code == OMP_ATOMIC)\n+\t    error (\"%<#pragma omp atomic update%> uses two different \"\n+\t\t   \"expressions for memory\");\n+\t  else\n+\t    error (\"%<#pragma omp atomic capture%> uses two different \"\n+\t\t   \"expressions for memory\");\n+\t  return;\n+\t}\n+      if (lhs1 && !cp_tree_equal (lhs, lhs1))\n+\t{\n+\t  if (code == OMP_ATOMIC)\n+\t    error (\"%<#pragma omp atomic update%> uses two different \"\n+\t\t   \"expressions for memory\");\n+\t  else\n+\t    error (\"%<#pragma omp atomic capture%> uses two different \"\n+\t\t   \"expressions for memory\");\n+\t  return;\n+\t}\n       stmt = c_finish_omp_atomic (input_location, code, opcode, lhs, rhs,\n-\t\t\t\t  v, lhs1, rhs1);\n+\t\t\t\t  v, lhs1, rhs1, swapped, seq_cst);\n       if (stmt == error_mark_node)\n \treturn;\n     }\n@@ -5089,6 +6483,7 @@ finish_omp_atomic (enum tree_code code, enum tree_code opcode, tree lhs,\n \t{\n \t  stmt = build_min_nt_loc (EXPR_LOCATION (orig_lhs),\n \t\t\t\t   OMP_ATOMIC_READ, orig_lhs);\n+\t  OMP_ATOMIC_SEQ_CST (stmt) = seq_cst;\n \t  stmt = build2 (MODIFY_EXPR, void_type_node, orig_v, stmt);\n \t}\n       else\n@@ -5104,10 +6499,12 @@ finish_omp_atomic (enum tree_code code, enum tree_code opcode, tree lhs,\n \t    {\n \t      stmt = build_min_nt_loc (EXPR_LOCATION (orig_lhs1),\n \t\t\t\t       code, orig_lhs1, stmt);\n+\t      OMP_ATOMIC_SEQ_CST (stmt) = seq_cst;\n \t      stmt = build2 (MODIFY_EXPR, void_type_node, orig_v, stmt);\n \t    }\n \t}\n       stmt = build2 (OMP_ATOMIC, void_type_node, integer_zero_node, stmt);\n+      OMP_ATOMIC_SEQ_CST (stmt) = seq_cst;\n     }\n   add_stmt (stmt);\n }\n@@ -5151,6 +6548,69 @@ finish_omp_taskyield (void)\n   release_tree_vector (vec);\n   finish_expr_stmt (stmt);\n }\n+\n+void\n+finish_omp_cancel (tree clauses)\n+{\n+  tree fn = builtin_decl_explicit (BUILT_IN_GOMP_CANCEL);\n+  int mask = 0;\n+  if (find_omp_clause (clauses, OMP_CLAUSE_PARALLEL))\n+    mask = 1;\n+  else if (find_omp_clause (clauses, OMP_CLAUSE_FOR))\n+    mask = 2;\n+  else if (find_omp_clause (clauses, OMP_CLAUSE_SECTIONS))\n+    mask = 4;\n+  else if (find_omp_clause (clauses, OMP_CLAUSE_TASKGROUP))\n+    mask = 8;\n+  else\n+    {\n+      error (\"%<#pragma omp cancel must specify one of \"\n+\t     \"%<parallel%>, %<for%>, %<sections%> or %<taskgroup%> clauses\");\n+      return;\n+    }\n+  vec<tree, va_gc> *vec = make_tree_vector ();\n+  tree ifc = find_omp_clause (clauses, OMP_CLAUSE_IF);\n+  if (ifc != NULL_TREE)\n+    {\n+      tree type = TREE_TYPE (OMP_CLAUSE_IF_EXPR (ifc));\n+      ifc = fold_build2_loc (OMP_CLAUSE_LOCATION (ifc), NE_EXPR,\n+\t\t\t     boolean_type_node, OMP_CLAUSE_IF_EXPR (ifc),\n+\t\t\t     build_zero_cst (type));\n+    }\n+  else\n+    ifc = boolean_true_node;\n+  vec->quick_push (build_int_cst (integer_type_node, mask));\n+  vec->quick_push (ifc);\n+  tree stmt = finish_call_expr (fn, &vec, false, false, tf_warning_or_error);\n+  release_tree_vector (vec);\n+  finish_expr_stmt (stmt);\n+}\n+\n+void\n+finish_omp_cancellation_point (tree clauses)\n+{\n+  tree fn = builtin_decl_explicit (BUILT_IN_GOMP_CANCELLATION_POINT);\n+  int mask = 0;\n+  if (find_omp_clause (clauses, OMP_CLAUSE_PARALLEL))\n+    mask = 1;\n+  else if (find_omp_clause (clauses, OMP_CLAUSE_FOR))\n+    mask = 2;\n+  else if (find_omp_clause (clauses, OMP_CLAUSE_SECTIONS))\n+    mask = 4;\n+  else if (find_omp_clause (clauses, OMP_CLAUSE_TASKGROUP))\n+    mask = 8;\n+  else\n+    {\n+      error (\"%<#pragma omp cancellation point must specify one of \"\n+\t     \"%<parallel%>, %<for%>, %<sections%> or %<taskgroup%> clauses\");\n+      return;\n+    }\n+  vec<tree, va_gc> *vec\n+    = make_tree_vector_single (build_int_cst (integer_type_node, mask));\n+  tree stmt = finish_call_expr (fn, &vec, false, false, tf_warning_or_error);\n+  release_tree_vector (vec);\n+  finish_expr_stmt (stmt);\n+}\n \f\n /* Begin a __transaction_atomic or __transaction_relaxed statement.\n    If PCOMPOUND is non-null, this is for a function-transaction-block, and we"}, {"sha": "583baa6430907a69c5bf467edde30028b9bdeb34", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -1,3 +1,21 @@\n+2013-10-11  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* trans-openmp.c (gfc_omp_clause_default_ctor,\n+\tgfc_omp_clause_dtor): Return NULL for OMP_CLAUSE_REDUCTION.\n+\t* f95-lang.c (ATTR_NULL, DEF_FUNCTION_TYPE_8): Define.\n+\t* types.def (DEF_FUNCTION_TYPE_8): Document.\n+\t(BT_FN_VOID_OMPFN_PTR_UINT,\n+\tBT_FN_VOID_OMPFN_PTR_UINT_LONG_LONG_LONG,\n+\tBT_FN_VOID_OMPFN_PTR_UINT_LONG_LONG_LONG_LONG,\n+\tBT_FN_VOID_OMPFN_PTR_OMPCPYFN_LONG_LONG_BOOL_UINT): Remove.\n+\t(BT_FN_VOID_OMPFN_PTR_UINT_UINT_UINT,\n+\tBT_FN_VOID_OMPFN_PTR_UINT_LONG_LONG_LONG_UINT,\n+\tBT_FN_VOID_OMPFN_PTR_UINT_LONG_LONG_LONG_LONG_UINT,\n+\tBT_FN_BOOL_INT, BT_FN_BOOL_INT_BOOL, BT_FN_VOID_UINT_UINT,\n+\tBT_FN_VOID_INT_PTR_SIZE_PTR_PTR_PTR,\n+\tBT_FN_VOID_INT_OMPFN_PTR_SIZE_PTR_PTR_PTR,\n+\tBT_FN_VOID_OMPFN_PTR_OMPCPYFN_LONG_LONG_BOOL_UINT_PTR): New.\n+\n 2013-10-10  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/58226"}, {"sha": "873c137e58176aa1467d2c90c67a00135f0a3ccd", "filename": "gcc/fortran/f95-lang.c", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ffortran%2Ff95-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ffortran%2Ff95-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ff95-lang.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -531,7 +531,8 @@ gfc_builtin_function (tree decl)\n   return decl;\n }\n \n-/* So far we need just these 4 attribute types.  */\n+/* So far we need just these 6 attribute types.  */\n+#define ATTR_NULL\t\t\t0\n #define ATTR_NOTHROW_LEAF_LIST\t\t(ECF_NOTHROW | ECF_LEAF)\n #define ATTR_NOTHROW_LEAF_MALLOC_LIST\t(ECF_NOTHROW | ECF_LEAF | ECF_MALLOC)\n #define ATTR_CONST_NOTHROW_LEAF_LIST\t(ECF_NOTHROW | ECF_LEAF | ECF_CONST)\n@@ -618,6 +619,7 @@ gfc_init_builtin_functions (void)\n #define DEF_FUNCTION_TYPE_5(NAME, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5) NAME,\n #define DEF_FUNCTION_TYPE_6(NAME, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6) NAME,\n #define DEF_FUNCTION_TYPE_7(NAME, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7) NAME,\n+#define DEF_FUNCTION_TYPE_8(NAME, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8) NAME,\n #define DEF_FUNCTION_TYPE_VAR_0(NAME, RETURN) NAME,\n #define DEF_POINTER_TYPE(NAME, TYPE) NAME,\n #include \"types.def\"\n@@ -630,6 +632,7 @@ gfc_init_builtin_functions (void)\n #undef DEF_FUNCTION_TYPE_5\n #undef DEF_FUNCTION_TYPE_6\n #undef DEF_FUNCTION_TYPE_7\n+#undef DEF_FUNCTION_TYPE_8\n #undef DEF_FUNCTION_TYPE_VAR_0\n #undef DEF_POINTER_TYPE\n     BT_LAST\n@@ -992,6 +995,19 @@ gfc_init_builtin_functions (void)\n                                 builtin_types[(int) ARG6],              \\\n                                 builtin_types[(int) ARG7],              \\\n                                 NULL_TREE);\n+#define DEF_FUNCTION_TYPE_8(ENUM, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, \\\n+\t\t\t    ARG6, ARG7, ARG8)\t\t\t\t\\\n+  builtin_types[(int) ENUM]\t\t\t\t\t\t\\\n+    = build_function_type_list (builtin_types[(int) RETURN],\t\t\\\n+\t\t\t\tbuiltin_types[(int) ARG1],\t\t\\\n+\t\t\t\tbuiltin_types[(int) ARG2],\t\t\\\n+\t\t\t\tbuiltin_types[(int) ARG3],\t\t\\\n+\t\t\t\tbuiltin_types[(int) ARG4],\t\t\\\n+\t\t\t\tbuiltin_types[(int) ARG5],\t\t\\\n+\t\t\t\tbuiltin_types[(int) ARG6],\t\t\\\n+\t\t\t\tbuiltin_types[(int) ARG7],\t\t\\\n+\t\t\t\tbuiltin_types[(int) ARG8],\t\t\\\n+\t\t\t\tNULL_TREE);\n #define DEF_FUNCTION_TYPE_VAR_0(ENUM, RETURN)\t\t\t\t\\\n   builtin_types[(int) ENUM]\t\t\t\t\t\t\\\n     = build_varargs_function_type_list (builtin_types[(int) RETURN],    \\"}, {"sha": "1c4ae62a3d99e259f404e188cdb91128d48193f8", "filename": "gcc/fortran/trans-openmp.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ffortran%2Ftrans-openmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ffortran%2Ftrans-openmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-openmp.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -159,6 +159,9 @@ gfc_omp_clause_default_ctor (tree clause, tree decl, tree outer)\n       || GFC_TYPE_ARRAY_AKIND (type) != GFC_ARRAY_ALLOCATABLE)\n     return NULL;\n \n+  if (OMP_CLAUSE_CODE (clause) == OMP_CLAUSE_REDUCTION)\n+    return NULL;\n+\n   gcc_assert (outer != NULL);\n   gcc_assert (OMP_CLAUSE_CODE (clause) == OMP_CLAUSE_PRIVATE\n \t      || OMP_CLAUSE_CODE (clause) == OMP_CLAUSE_LASTPRIVATE);\n@@ -323,6 +326,9 @@ gfc_omp_clause_dtor (tree clause ATTRIBUTE_UNUSED, tree decl)\n       || GFC_TYPE_ARRAY_AKIND (type) != GFC_ARRAY_ALLOCATABLE)\n     return NULL;\n \n+  if (OMP_CLAUSE_CODE (clause) == OMP_CLAUSE_REDUCTION)\n+    return NULL;\n+\n   /* Allocatable arrays in FIRSTPRIVATE/LASTPRIVATE etc. clauses need\n      to be deallocated if they were allocated.  */\n   return gfc_trans_dealloc_allocated (decl, false, NULL);"}, {"sha": "9bbee3504feb0f903c926e0a0735bd88756209d2", "filename": "gcc/fortran/types.def", "status": "modified", "additions": 23, "deletions": 13, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ffortran%2Ftypes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ffortran%2Ftypes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftypes.def?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -34,6 +34,8 @@ along with GCC; see the file COPYING3.  If not see\n    DEF_FUNCTION_TYPE_5 (ENUM, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5)\n    DEF_FUNCTION_TYPE_6 (ENUM, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6)\n    DEF_FUNCTION_TYPE_7 (ENUM, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7)\n+   DEF_FUNCTION_TYPE_8 (ENUM, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7,\n+\t\t\tARG8)\n \n      These macros describe function types.  ENUM is as above.  The\n      RETURN type is one of the enumerals already defined.  ARG1, ARG2,\n@@ -89,7 +91,7 @@ DEF_FUNCTION_TYPE_1 (BT_FN_VOID_VPTR, BT_VOID, BT_VOLATILE_PTR)\n DEF_FUNCTION_TYPE_1 (BT_FN_UINT_UINT, BT_UINT, BT_UINT)\n DEF_FUNCTION_TYPE_1 (BT_FN_PTR_PTR, BT_PTR, BT_PTR)\n DEF_FUNCTION_TYPE_1 (BT_FN_VOID_INT, BT_VOID, BT_INT)\n-\n+DEF_FUNCTION_TYPE_1 (BT_FN_BOOL_INT, BT_BOOL, BT_INT)\n \n DEF_POINTER_TYPE (BT_PTR_FN_VOID_PTR, BT_FN_VOID_PTR)\n \n@@ -117,7 +119,8 @@ DEF_FUNCTION_TYPE_2 (BT_FN_VOID_VPTR_INT, BT_VOID, BT_VOLATILE_PTR, BT_INT)\n DEF_FUNCTION_TYPE_2 (BT_FN_BOOL_VPTR_INT, BT_BOOL, BT_VOLATILE_PTR, BT_INT)\n DEF_FUNCTION_TYPE_2 (BT_FN_BOOL_SIZE_CONST_VPTR, BT_BOOL, BT_SIZE,\n \t\t     BT_CONST_VOLATILE_PTR)\n-\n+DEF_FUNCTION_TYPE_2 (BT_FN_BOOL_INT_BOOL, BT_BOOL, BT_INT, BT_BOOL)\n+DEF_FUNCTION_TYPE_2 (BT_FN_VOID_UINT_UINT, BT_VOID, BT_UINT, BT_UINT)\n \n DEF_POINTER_TYPE (BT_PTR_FN_VOID_PTR_PTR, BT_FN_VOID_PTR_PTR)\n \n@@ -137,8 +140,6 @@ DEF_FUNCTION_TYPE_3 (BT_FN_I4_VPTR_I4_I4, BT_I4, BT_VOLATILE_PTR, BT_I4, BT_I4)\n DEF_FUNCTION_TYPE_3 (BT_FN_I8_VPTR_I8_I8, BT_I8, BT_VOLATILE_PTR, BT_I8, BT_I8)\n DEF_FUNCTION_TYPE_3 (BT_FN_I16_VPTR_I16_I16, BT_I16, BT_VOLATILE_PTR,\n \t\t     BT_I16, BT_I16)\n-DEF_FUNCTION_TYPE_3 (BT_FN_VOID_OMPFN_PTR_UINT, BT_VOID, BT_PTR_FN_VOID_PTR,\n-                     BT_PTR, BT_UINT)\n DEF_FUNCTION_TYPE_3 (BT_FN_I1_VPTR_I1_INT, BT_I1, BT_VOLATILE_PTR, BT_I1, BT_INT)\n DEF_FUNCTION_TYPE_3 (BT_FN_I2_VPTR_I2_INT, BT_I2, BT_VOLATILE_PTR, BT_I2, BT_INT)\n DEF_FUNCTION_TYPE_3 (BT_FN_I4_VPTR_I4_INT, BT_I4, BT_VOLATILE_PTR, BT_I4, BT_INT)\n@@ -159,6 +160,9 @@ DEF_FUNCTION_TYPE_4 (BT_FN_VOID_SIZE_VPTR_PTR_INT, BT_VOID, BT_SIZE,\n DEF_FUNCTION_TYPE_4 (BT_FN_VOID_SIZE_CONST_VPTR_PTR_INT, BT_VOID, BT_SIZE,\n \t\t     BT_CONST_VOLATILE_PTR, BT_PTR, BT_INT)\n \n+DEF_FUNCTION_TYPE_5 (BT_FN_VOID_OMPFN_PTR_UINT_UINT_UINT,\n+\t\t     BT_VOID, BT_PTR_FN_VOID_PTR, BT_PTR, BT_UINT, BT_UINT,\n+\t\t     BT_UINT)\n DEF_FUNCTION_TYPE_5 (BT_FN_BOOL_LONG_LONG_LONG_LONGPTR_LONGPTR,\n                      BT_BOOL, BT_LONG, BT_LONG, BT_LONG,\n \t\t     BT_PTR_LONG, BT_PTR_LONG)\n@@ -168,9 +172,6 @@ DEF_FUNCTION_TYPE_5 (BT_FN_VOID_SIZE_VPTR_PTR_PTR_INT, BT_VOID, BT_SIZE,\n DEF_FUNCTION_TYPE_6 (BT_FN_BOOL_LONG_LONG_LONG_LONG_LONGPTR_LONGPTR,\n                      BT_BOOL, BT_LONG, BT_LONG, BT_LONG, BT_LONG,\n \t\t     BT_PTR_LONG, BT_PTR_LONG)\n-DEF_FUNCTION_TYPE_6 (BT_FN_VOID_OMPFN_PTR_UINT_LONG_LONG_LONG,\n-                     BT_VOID, BT_PTR_FN_VOID_PTR, BT_PTR, BT_UINT,\n-                     BT_LONG, BT_LONG, BT_LONG)\n DEF_FUNCTION_TYPE_6 (BT_FN_BOOL_BOOL_ULL_ULL_ULL_ULLPTR_ULLPTR,\n \t\t     BT_BOOL, BT_BOOL, BT_ULONGLONG, BT_ULONGLONG,\n \t\t     BT_ULONGLONG, BT_PTR_ULONGLONG, BT_PTR_ULONGLONG)\n@@ -191,17 +192,26 @@ DEF_FUNCTION_TYPE_6 (BT_FN_BOOL_VPTR_PTR_I16_BOOL_INT_INT,\n \t\t     BT_INT)\n DEF_FUNCTION_TYPE_6 (BT_FN_BOOL_SIZE_VPTR_PTR_PTR_INT_INT, BT_BOOL, BT_SIZE,\n \t\t     BT_VOLATILE_PTR, BT_PTR, BT_PTR, BT_INT, BT_INT)\n+DEF_FUNCTION_TYPE_6 (BT_FN_VOID_INT_PTR_SIZE_PTR_PTR_PTR,\n+\t\t     BT_VOID, BT_INT, BT_PTR, BT_SIZE, BT_PTR, BT_PTR, BT_PTR)\n \n-DEF_FUNCTION_TYPE_7 (BT_FN_VOID_OMPFN_PTR_UINT_LONG_LONG_LONG_LONG,\n+DEF_FUNCTION_TYPE_7 (BT_FN_VOID_OMPFN_PTR_UINT_LONG_LONG_LONG_UINT,\n                      BT_VOID, BT_PTR_FN_VOID_PTR, BT_PTR, BT_UINT,\n-                     BT_LONG, BT_LONG, BT_LONG, BT_LONG)\n-DEF_FUNCTION_TYPE_7 (BT_FN_VOID_OMPFN_PTR_OMPCPYFN_LONG_LONG_BOOL_UINT,\n-\t\t     BT_VOID, BT_PTR_FN_VOID_PTR, BT_PTR,\n-\t\t     BT_PTR_FN_VOID_PTR_PTR, BT_LONG, BT_LONG,\n-\t\t     BT_BOOL, BT_UINT)\n+\t\t     BT_LONG, BT_LONG, BT_LONG, BT_UINT)\n DEF_FUNCTION_TYPE_7 (BT_FN_BOOL_BOOL_ULL_ULL_ULL_ULL_ULLPTR_ULLPTR,\n \t\t     BT_BOOL, BT_BOOL, BT_ULONGLONG, BT_ULONGLONG,\n \t\t     BT_ULONGLONG, BT_ULONGLONG,\n \t\t     BT_PTR_ULONGLONG, BT_PTR_ULONGLONG)\n+DEF_FUNCTION_TYPE_7 (BT_FN_VOID_INT_OMPFN_PTR_SIZE_PTR_PTR_PTR,\n+\t\t     BT_VOID, BT_INT, BT_PTR_FN_VOID_PTR, BT_PTR, BT_SIZE,\n+\t\t     BT_PTR, BT_PTR, BT_PTR)\n+\n+DEF_FUNCTION_TYPE_8 (BT_FN_VOID_OMPFN_PTR_UINT_LONG_LONG_LONG_LONG_UINT,\n+\t\t     BT_VOID, BT_PTR_FN_VOID_PTR, BT_PTR, BT_UINT,\n+\t\t     BT_LONG, BT_LONG, BT_LONG, BT_LONG, BT_UINT)\n+DEF_FUNCTION_TYPE_8 (BT_FN_VOID_OMPFN_PTR_OMPCPYFN_LONG_LONG_BOOL_UINT_PTR,\n+\t\t     BT_VOID, BT_PTR_FN_VOID_PTR, BT_PTR,\n+\t\t     BT_PTR_FN_VOID_PTR_PTR, BT_LONG, BT_LONG,\n+\t\t     BT_BOOL, BT_UINT, BT_PTR)\n \n DEF_FUNCTION_TYPE_VAR_0 (BT_FN_VOID_VAR, BT_VOID)"}, {"sha": "aa4c024b1ced3c1378587f1656ed0392ed9841a7", "filename": "gcc/gimple-low.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Fgimple-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Fgimple-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-low.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -425,6 +425,7 @@ lower_stmt (gimple_stmt_iterator *gsi, struct lower_data *data)\n     case GIMPLE_OMP_SECTION:\n     case GIMPLE_OMP_SINGLE:\n     case GIMPLE_OMP_MASTER:\n+    case GIMPLE_OMP_TASKGROUP:\n     case GIMPLE_OMP_ORDERED:\n     case GIMPLE_OMP_CRITICAL:\n     case GIMPLE_OMP_RETURN:\n@@ -466,6 +467,8 @@ lower_stmt (gimple_stmt_iterator *gsi, struct lower_data *data)\n \n     case GIMPLE_OMP_PARALLEL:\n     case GIMPLE_OMP_TASK:\n+    case GIMPLE_OMP_TARGET:\n+    case GIMPLE_OMP_TEAMS:\n       data->cannot_fallthru = false;\n       lower_omp_directive (gsi, data);\n       data->cannot_fallthru = false;"}, {"sha": "f0f816671ec01f45c1e03863005dd7810d1c07c9", "filename": "gcc/gimple-pretty-print.c", "status": "modified", "additions": 116, "deletions": 3, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Fgimple-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Fgimple-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-pretty-print.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -1097,6 +1097,9 @@ dump_gimple_omp_for (pretty_printer *buffer, gimple gs, int spc, int flags)\n \tcase GF_OMP_FOR_KIND_SIMD:\n \t  kind = \" simd\";\n \t  break;\n+\tcase GF_OMP_FOR_KIND_DISTRIBUTE:\n+\t  kind = \" distribute\";\n+\t  break;\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n@@ -1125,6 +1128,9 @@ dump_gimple_omp_for (pretty_printer *buffer, gimple gs, int spc, int flags)\n \tcase GF_OMP_FOR_KIND_SIMD:\n \t  pp_string (buffer, \"#pragma omp simd\");\n \t  break;\n+\tcase GF_OMP_FOR_KIND_DISTRIBUTE:\n+\t  pp_string (buffer, \"#pragma omp distribute\");\n+\t  break;\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n@@ -1239,6 +1245,85 @@ dump_gimple_omp_single (pretty_printer *buffer, gimple gs, int spc, int flags)\n     }\n }\n \n+/* Dump a GIMPLE_OMP_TARGET tuple on the pretty_printer BUFFER.  */\n+\n+static void\n+dump_gimple_omp_target (pretty_printer *buffer, gimple gs, int spc, int flags)\n+{\n+  const char *kind;\n+  switch (gimple_omp_target_kind (gs))\n+    {\n+    case GF_OMP_TARGET_KIND_REGION:\n+      kind = \"\";\n+      break;\n+    case GF_OMP_TARGET_KIND_DATA:\n+      kind = \" data\";\n+      break;\n+    case GF_OMP_TARGET_KIND_UPDATE:\n+      kind = \" update\";\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+  if (flags & TDF_RAW)\n+    {\n+      dump_gimple_fmt (buffer, spc, flags, \"%G%s <%+BODY <%S>%nCLAUSES <\", gs,\n+\t\t       kind, gimple_omp_body (gs));\n+      dump_omp_clauses (buffer, gimple_omp_target_clauses (gs), spc, flags);\n+      dump_gimple_fmt (buffer, spc, flags, \" >\");\n+    }\n+  else\n+    {\n+      pp_string (buffer, \"#pragma omp target\");\n+      pp_string (buffer, kind);\n+      dump_omp_clauses (buffer, gimple_omp_target_clauses (gs), spc, flags);\n+      if (gimple_omp_target_child_fn (gs))\n+\t{\n+\t  pp_string (buffer, \" [child fn: \");\n+\t  dump_generic_node (buffer, gimple_omp_target_child_fn (gs),\n+\t\t\t     spc, flags, false);\n+\t  pp_right_bracket (buffer);\n+\t}\n+      if (!gimple_seq_empty_p (gimple_omp_body (gs)))\n+\t{\n+\t  newline_and_indent (buffer, spc + 2);\n+\t  pp_character (buffer, '{');\n+\t  pp_newline (buffer);\n+\t  dump_gimple_seq (buffer, gimple_omp_body (gs), spc + 4, flags);\n+\t  newline_and_indent (buffer, spc + 2);\n+\t  pp_character (buffer, '}');\n+\t}\n+    }\n+}\n+\n+/* Dump a GIMPLE_OMP_TEAMS tuple on the pretty_printer BUFFER.  */\n+\n+static void\n+dump_gimple_omp_teams (pretty_printer *buffer, gimple gs, int spc, int flags)\n+{\n+  if (flags & TDF_RAW)\n+    {\n+      dump_gimple_fmt (buffer, spc, flags, \"%G <%+BODY <%S>%nCLAUSES <\", gs,\n+\t\t       gimple_omp_body (gs));\n+      dump_omp_clauses (buffer, gimple_omp_teams_clauses (gs), spc, flags);\n+      dump_gimple_fmt (buffer, spc, flags, \" >\");\n+    }\n+  else\n+    {\n+      pp_string (buffer, \"#pragma omp teams\");\n+      dump_omp_clauses (buffer, gimple_omp_teams_clauses (gs), spc, flags);\n+      if (!gimple_seq_empty_p (gimple_omp_body (gs)))\n+\t{\n+\t  newline_and_indent (buffer, spc + 2);\n+\t  pp_character (buffer, '{');\n+\t  pp_newline (buffer);\n+\t  dump_gimple_seq (buffer, gimple_omp_body (gs), spc + 4, flags);\n+\t  newline_and_indent (buffer, spc + 2);\n+\t  pp_character (buffer, '}');\n+\t}\n+    }\n+}\n+\n /* Dump a GIMPLE_OMP_SECTIONS tuple on the pretty_printer BUFFER.  */\n \n static void\n@@ -1275,8 +1360,8 @@ dump_gimple_omp_sections (pretty_printer *buffer, gimple gs, int spc,\n     }\n }\n \n-/* Dump a GIMPLE_OMP_{MASTER,ORDERED,SECTION} tuple on the pretty_printer\n-   BUFFER.  */\n+/* Dump a GIMPLE_OMP_{MASTER,TASKGROUP,ORDERED,SECTION} tuple on the\n+   pretty_printer BUFFER.  */\n \n static void\n dump_gimple_omp_block (pretty_printer *buffer, gimple gs, int spc, int flags)\n@@ -1291,6 +1376,9 @@ dump_gimple_omp_block (pretty_printer *buffer, gimple gs, int spc, int flags)\n \tcase GIMPLE_OMP_MASTER:\n \t  pp_string (buffer, \"#pragma omp master\");\n \t  break;\n+\tcase GIMPLE_OMP_TASKGROUP:\n+\t  pp_string (buffer, \"#pragma omp taskgroup\");\n+\t  break;\n \tcase GIMPLE_OMP_ORDERED:\n \t  pp_string (buffer, \"#pragma omp ordered\");\n \t  break;\n@@ -1350,14 +1438,26 @@ dump_gimple_omp_return (pretty_printer *buffer, gimple gs, int spc, int flags)\n {\n   if (flags & TDF_RAW)\n     {\n-      dump_gimple_fmt (buffer, spc, flags, \"%G <nowait=%d>\", gs,\n+      dump_gimple_fmt (buffer, spc, flags, \"%G <nowait=%d\", gs,\n                        (int) gimple_omp_return_nowait_p (gs));\n+      if (gimple_omp_return_lhs (gs))\n+\tdump_gimple_fmt (buffer, spc, flags, \", lhs=%T>\",\n+\t\t\t gimple_omp_return_lhs (gs));\n+      else\n+\tdump_gimple_fmt (buffer, spc, flags, \">\");\n     }\n   else\n     {\n       pp_string (buffer, \"#pragma omp return\");\n       if (gimple_omp_return_nowait_p (gs))\n \tpp_string (buffer, \"(nowait)\");\n+      if (gimple_omp_return_lhs (gs))\n+\t{\n+\t  pp_string (buffer, \" (set \");\n+\t  dump_generic_node (buffer, gimple_omp_return_lhs (gs),\n+\t\t\t     spc, flags, false);\n+\t  pp_character (buffer, ')');\n+\t}\n     }\n }\n \n@@ -1826,6 +1926,8 @@ dump_gimple_omp_atomic_load (pretty_printer *buffer, gimple gs, int spc,\n   else\n     {\n       pp_string (buffer, \"#pragma omp atomic_load\");\n+      if (gimple_omp_atomic_seq_cst_p (gs))\n+\tpp_string (buffer, \" seq_cst\");\n       if (gimple_omp_atomic_need_value_p (gs))\n \tpp_string (buffer, \" [needed]\");\n       newline_and_indent (buffer, spc + 2);\n@@ -1856,6 +1958,8 @@ dump_gimple_omp_atomic_store (pretty_printer *buffer, gimple gs, int spc,\n   else\n     {\n       pp_string (buffer, \"#pragma omp atomic_store \");\n+      if (gimple_omp_atomic_seq_cst_p (gs))\n+\tpp_string (buffer, \"seq_cst \");\n       if (gimple_omp_atomic_need_value_p (gs))\n \tpp_string (buffer, \"[needed] \");\n       pp_left_paren (buffer);\n@@ -2023,6 +2127,14 @@ pp_gimple_stmt_1 (pretty_printer *buffer, gimple gs, int spc, int flags)\n       dump_gimple_omp_single (buffer, gs, spc, flags);\n       break;\n \n+    case GIMPLE_OMP_TARGET:\n+      dump_gimple_omp_target (buffer, gs, spc, flags);\n+      break;\n+\n+    case GIMPLE_OMP_TEAMS:\n+      dump_gimple_omp_teams (buffer, gs, spc, flags);\n+      break;\n+\n     case GIMPLE_OMP_RETURN:\n       dump_gimple_omp_return (buffer, gs, spc, flags);\n       break;\n@@ -2036,6 +2148,7 @@ pp_gimple_stmt_1 (pretty_printer *buffer, gimple gs, int spc, int flags)\n       break;\n \n     case GIMPLE_OMP_MASTER:\n+    case GIMPLE_OMP_TASKGROUP:\n     case GIMPLE_OMP_ORDERED:\n     case GIMPLE_OMP_SECTION:\n       dump_gimple_omp_block (buffer, gs, spc, flags);"}, {"sha": "37a8123ada194ac79f7e852f8e2251ebb040c30b", "filename": "gcc/gimple.c", "status": "modified", "additions": 78, "deletions": 1, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -1007,6 +1007,22 @@ gimple_build_omp_master (gimple_seq body)\n }\n \n \n+/* Build a GIMPLE_OMP_TASKGROUP statement.\n+\n+   BODY is the sequence of statements to be executed by the taskgroup\n+   construct.  */\n+\n+gimple\n+gimple_build_omp_taskgroup (gimple_seq body)\n+{\n+  gimple p = gimple_alloc (GIMPLE_OMP_TASKGROUP, 0);\n+  if (body)\n+    gimple_omp_set_body (p, body);\n+\n+  return p;\n+}\n+\n+\n /* Build a GIMPLE_OMP_CONTINUE statement.\n \n    CONTROL_DEF is the definition of the control variable.\n@@ -1096,6 +1112,41 @@ gimple_build_omp_single (gimple_seq body, tree clauses)\n }\n \n \n+/* Build a GIMPLE_OMP_TARGET statement.\n+\n+   BODY is the sequence of statements that will be executed.\n+   CLAUSES are any of the OMP target construct's clauses.  */\n+\n+gimple\n+gimple_build_omp_target (gimple_seq body, int kind, tree clauses)\n+{\n+  gimple p = gimple_alloc (GIMPLE_OMP_TARGET, 0);\n+  if (body)\n+    gimple_omp_set_body (p, body);\n+  gimple_omp_target_set_clauses (p, clauses);\n+  gimple_omp_target_set_kind (p, kind);\n+\n+  return p;\n+}\n+\n+\n+/* Build a GIMPLE_OMP_TEAMS statement.\n+\n+   BODY is the sequence of statements that will be executed.\n+   CLAUSES are any of the OMP teams construct's clauses.  */\n+\n+gimple\n+gimple_build_omp_teams (gimple_seq body, tree clauses)\n+{\n+  gimple p = gimple_alloc (GIMPLE_OMP_TEAMS, 0);\n+  if (body)\n+    gimple_omp_set_body (p, body);\n+  gimple_omp_teams_set_clauses (p, clauses);\n+\n+  return p;\n+}\n+\n+\n /* Build a GIMPLE_OMP_ATOMIC_LOAD statement.  */\n \n gimple\n@@ -1612,6 +1663,20 @@ walk_gimple_op (gimple stmt, walk_tree_fn callback_op,\n \treturn ret;\n       break;\n \n+    case GIMPLE_OMP_TARGET:\n+      ret = walk_tree (gimple_omp_target_clauses_ptr (stmt), callback_op, wi,\n+\t\t       pset);\n+      if (ret)\n+\treturn ret;\n+      break;\n+\n+    case GIMPLE_OMP_TEAMS:\n+      ret = walk_tree (gimple_omp_teams_clauses_ptr (stmt), callback_op, wi,\n+\t\t       pset);\n+      if (ret)\n+\treturn ret;\n+      break;\n+\n     case GIMPLE_OMP_ATOMIC_LOAD:\n       ret = walk_tree (gimple_omp_atomic_load_lhs_ptr (stmt), callback_op, wi,\n \t\t       pset);\n@@ -1638,10 +1703,16 @@ walk_gimple_op (gimple stmt, walk_tree_fn callback_op,\n \treturn ret;\n       break;\n \n+    case GIMPLE_OMP_RETURN:\n+      ret = walk_tree (gimple_omp_return_lhs_ptr (stmt), callback_op, wi,\n+\t\t       pset);\n+      if (ret)\n+\treturn ret;\n+      break;\n+\n       /* Tuples that do not have operands.  */\n     case GIMPLE_NOP:\n     case GIMPLE_RESX:\n-    case GIMPLE_OMP_RETURN:\n     case GIMPLE_PREDICT:\n       break;\n \n@@ -1782,12 +1853,15 @@ walk_gimple_stmt (gimple_stmt_iterator *gsi, walk_stmt_fn callback_stmt,\n       /* FALL THROUGH.  */\n     case GIMPLE_OMP_CRITICAL:\n     case GIMPLE_OMP_MASTER:\n+    case GIMPLE_OMP_TASKGROUP:\n     case GIMPLE_OMP_ORDERED:\n     case GIMPLE_OMP_SECTION:\n     case GIMPLE_OMP_PARALLEL:\n     case GIMPLE_OMP_TASK:\n     case GIMPLE_OMP_SECTIONS:\n     case GIMPLE_OMP_SINGLE:\n+    case GIMPLE_OMP_TARGET:\n+    case GIMPLE_OMP_TEAMS:\n       ret = walk_gimple_seq_mod (gimple_omp_body_ptr (stmt), callback_stmt,\n \t\t\t     callback_op, wi);\n       if (ret)\n@@ -2277,8 +2351,11 @@ gimple_copy (gimple stmt)\n \t  /* FALLTHRU  */\n \n \tcase GIMPLE_OMP_SINGLE:\n+\tcase GIMPLE_OMP_TARGET:\n+\tcase GIMPLE_OMP_TEAMS:\n \tcase GIMPLE_OMP_SECTION:\n \tcase GIMPLE_OMP_MASTER:\n+\tcase GIMPLE_OMP_TASKGROUP:\n \tcase GIMPLE_OMP_ORDERED:\n \tcopy_omp_body:\n \t  new_seq = gimple_seq_copy (gimple_omp_body (stmt));"}, {"sha": "07370aedd29ebf1a0d7c29bbb59fcc280b7d7067", "filename": "gcc/gimple.def", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Fgimple.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Fgimple.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.def?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -276,6 +276,10 @@ DEFGSCODE(GIMPLE_OMP_FOR, \"gimple_omp_for\", GSS_OMP_FOR)\n    BODY is the sequence of statements to execute in the master section.  */\n DEFGSCODE(GIMPLE_OMP_MASTER, \"gimple_omp_master\", GSS_OMP)\n \n+/* GIMPLE_OMP_TASKGROUP <BODY> represents #pragma omp taskgroup.\n+   BODY is the sequence of statements to execute in the taskgroup section.  */\n+DEFGSCODE(GIMPLE_OMP_TASKGROUP, \"gimple_omp_taskgroup\", GSS_OMP)\n+\n /* GIMPLE_OMP_ORDERED <BODY> represents #pragma omp ordered.\n    BODY is the sequence of statements to execute in the ordered section.  */\n DEFGSCODE(GIMPLE_OMP_ORDERED, \"gimple_omp_ordered\", GSS_OMP)\n@@ -325,7 +329,7 @@ DEFGSCODE(GIMPLE_OMP_PARALLEL, \"gimple_omp_parallel\", GSS_OMP_PARALLEL)\n DEFGSCODE(GIMPLE_OMP_TASK, \"gimple_omp_task\", GSS_OMP_TASK)\n \n /* OMP_RETURN marks the end of an OpenMP directive.  */\n-DEFGSCODE(GIMPLE_OMP_RETURN, \"gimple_omp_return\", GSS_BASE)\n+DEFGSCODE(GIMPLE_OMP_RETURN, \"gimple_omp_return\", GSS_OMP_ATOMIC_STORE)\n \n /* OMP_SECTION <BODY> represents #pragma omp section.\n    BODY is the sequence of statements in the section body.  */\n@@ -349,6 +353,24 @@ DEFGSCODE(GIMPLE_OMP_SECTIONS_SWITCH, \"gimple_omp_sections_switch\", GSS_BASE)\n    CLAUSES is an OMP_CLAUSE chain holding the associated clauses.  */\n DEFGSCODE(GIMPLE_OMP_SINGLE, \"gimple_omp_single\", GSS_OMP_SINGLE)\n \n+/* GIMPLE_OMP_TARGET <BODY, CLAUSES, CHILD_FN> represents\n+   #pragma omp target {,data,update}\n+   BODY is the sequence of statements inside the target construct\n+   (NULL for target update).\n+   CLAUSES is an OMP_CLAUSE chain holding the associated clauses.\n+   CHILD_FN is set when outlining the body of the target region.\n+   All the statements in BODY are moved into this newly created\n+   function when converting OMP constructs into low-GIMPLE.\n+   DATA_ARG is a vec of 3 local variables in the parent function\n+   containing data to be mapped to CHILD_FN.  This is used to\n+   implement the MAP clauses.  */\n+DEFGSCODE(GIMPLE_OMP_TARGET, \"gimple_omp_target\", GSS_OMP_PARALLEL)\n+\n+/* GIMPLE_OMP_TEAMS <BODY, CLAUSES> represents #pragma omp teams\n+   BODY is the sequence of statements inside the single section.\n+   CLAUSES is an OMP_CLAUSE chain holding the associated clauses.  */\n+DEFGSCODE(GIMPLE_OMP_TEAMS, \"gimple_omp_teams\", GSS_OMP_SINGLE)\n+\n /* GIMPLE_PREDICT <PREDICT, OUTCOME> specifies a hint for branch prediction.\n \n    PREDICT is one of the predictors from predict.def."}, {"sha": "2af4ff932a824d0e27481777b5764200d88d1d58", "filename": "gcc/gimple.h", "status": "modified", "additions": 264, "deletions": 2, "changes": 266, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -105,6 +105,13 @@ enum gf_mask {\n     GF_OMP_FOR_KIND_MASK\t= 3 << 0,\n     GF_OMP_FOR_KIND_FOR\t\t= 0 << 0,\n     GF_OMP_FOR_KIND_SIMD\t= 1 << 0,\n+    GF_OMP_FOR_KIND_DISTRIBUTE\t= 2 << 0,\n+    GF_OMP_FOR_COMBINED\t\t= 1 << 2,\n+    GF_OMP_FOR_COMBINED_INTO\t= 1 << 3,\n+    GF_OMP_TARGET_KIND_MASK\t= 3 << 0,\n+    GF_OMP_TARGET_KIND_REGION\t= 0 << 0,\n+    GF_OMP_TARGET_KIND_DATA\t= 1 << 0,\n+    GF_OMP_TARGET_KIND_UPDATE\t= 2 << 0,\n \n     /* True on an GIMPLE_OMP_RETURN statement if the return does not require\n        a thread synchronization via some sort of barrier.  The exact barrier\n@@ -114,6 +121,7 @@ enum gf_mask {\n \n     GF_OMP_SECTION_LAST\t\t= 1 << 0,\n     GF_OMP_ATOMIC_NEED_VALUE\t= 1 << 0,\n+    GF_OMP_ATOMIC_SEQ_CST\t= 1 << 1,\n     GF_PREDICT_TAKEN\t\t= 1 << 15\n };\n \n@@ -607,7 +615,7 @@ struct GTY(()) gimple_statement_omp_continue {\n   tree control_use;\n };\n \n-/* GIMPLE_OMP_SINGLE */\n+/* GIMPLE_OMP_SINGLE, GIMPLE_OMP_TARGET, GIMPLE_OMP_TEAMS */\n \n struct GTY(()) gimple_statement_omp_single {\n   /* [ WORD 1-7 ]  */\n@@ -786,11 +794,14 @@ gimple gimple_build_omp_critical (gimple_seq, tree);\n gimple gimple_build_omp_section (gimple_seq);\n gimple gimple_build_omp_continue (tree, tree);\n gimple gimple_build_omp_master (gimple_seq);\n+gimple gimple_build_omp_taskgroup (gimple_seq);\n gimple gimple_build_omp_return (bool);\n gimple gimple_build_omp_ordered (gimple_seq);\n gimple gimple_build_omp_sections (gimple_seq, tree);\n gimple gimple_build_omp_sections_switch (void);\n gimple gimple_build_omp_single (gimple_seq, tree);\n+gimple gimple_build_omp_target (gimple_seq, int, tree);\n+gimple gimple_build_omp_teams (gimple_seq, tree);\n gimple gimple_build_cdt (tree, tree);\n gimple gimple_build_omp_atomic_load (tree, tree);\n gimple gimple_build_omp_atomic_store (tree);\n@@ -1250,12 +1261,15 @@ gimple_has_substatements (gimple g)\n     case GIMPLE_TRY:\n     case GIMPLE_OMP_FOR:\n     case GIMPLE_OMP_MASTER:\n+    case GIMPLE_OMP_TASKGROUP:\n     case GIMPLE_OMP_ORDERED:\n     case GIMPLE_OMP_SECTION:\n     case GIMPLE_OMP_PARALLEL:\n     case GIMPLE_OMP_TASK:\n     case GIMPLE_OMP_SECTIONS:\n     case GIMPLE_OMP_SINGLE:\n+    case GIMPLE_OMP_TARGET:\n+    case GIMPLE_OMP_TEAMS:\n     case GIMPLE_OMP_CRITICAL:\n     case GIMPLE_WITH_CLEANUP_EXPR:\n     case GIMPLE_TRANSACTION:\n@@ -1634,7 +1648,7 @@ static inline unsigned\n gimple_omp_subcode (const_gimple s)\n {\n   gcc_gimple_checking_assert (gimple_code (s) >= GIMPLE_OMP_ATOMIC_LOAD\n-\t      && gimple_code (s) <= GIMPLE_OMP_SINGLE);\n+\t      && gimple_code (s) <= GIMPLE_OMP_TEAMS);\n   return s->gsbase.subcode;\n }\n \n@@ -1670,6 +1684,36 @@ gimple_omp_return_nowait_p (const_gimple g)\n }\n \n \n+/* Set the LHS of OMP return.  */\n+\n+static inline void\n+gimple_omp_return_set_lhs (gimple g, tree lhs)\n+{\n+  GIMPLE_CHECK (g, GIMPLE_OMP_RETURN);\n+  g->gimple_omp_atomic_store.val = lhs;\n+}\n+\n+\n+/* Get the LHS of OMP return.  */\n+\n+static inline tree\n+gimple_omp_return_lhs (const_gimple g)\n+{\n+  GIMPLE_CHECK (g, GIMPLE_OMP_RETURN);\n+  return g->gimple_omp_atomic_store.val;\n+}\n+\n+\n+/* Return a pointer to the LHS of OMP return.  */\n+\n+static inline tree *\n+gimple_omp_return_lhs_ptr (gimple g)\n+{\n+  GIMPLE_CHECK (g, GIMPLE_OMP_RETURN);\n+  return &g->gimple_omp_atomic_store.val;\n+}\n+\n+\n /* Return true if OMP section statement G has the GF_OMP_SECTION_LAST\n    flag set.  */\n \n@@ -1739,6 +1783,29 @@ gimple_omp_atomic_set_need_value (gimple g)\n }\n \n \n+/* Return true if OMP atomic load/store statement G has the\n+   GF_OMP_ATOMIC_SEQ_CST flag set.  */\n+\n+static inline bool\n+gimple_omp_atomic_seq_cst_p (const_gimple g)\n+{\n+  if (gimple_code (g) != GIMPLE_OMP_ATOMIC_LOAD)\n+    GIMPLE_CHECK (g, GIMPLE_OMP_ATOMIC_STORE);\n+  return (gimple_omp_subcode (g) & GF_OMP_ATOMIC_SEQ_CST) != 0;\n+}\n+\n+\n+/* Set the GF_OMP_ATOMIC_SEQ_CST flag on G.  */\n+\n+static inline void\n+gimple_omp_atomic_set_seq_cst (gimple g)\n+{\n+  if (gimple_code (g) != GIMPLE_OMP_ATOMIC_LOAD)\n+    GIMPLE_CHECK (g, GIMPLE_OMP_ATOMIC_STORE);\n+  g->gsbase.subcode |= GF_OMP_ATOMIC_SEQ_CST;\n+}\n+\n+\n /* Return the number of operands for statement GS.  */\n \n static inline unsigned\n@@ -4022,6 +4089,56 @@ gimple_omp_for_set_kind (gimple g, int kind)\n }\n \n \n+/* Return true if OMP for statement G has the\n+   GF_OMP_FOR_COMBINED flag set.  */\n+\n+static inline bool\n+gimple_omp_for_combined_p (const_gimple g)\n+{\n+  GIMPLE_CHECK (g, GIMPLE_OMP_FOR);\n+  return (gimple_omp_subcode (g) & GF_OMP_FOR_COMBINED) != 0;\n+}\n+\n+\n+/* Set the GF_OMP_FOR_COMBINED field in G depending on the boolean\n+   value of COMBINED_P.  */\n+\n+static inline void\n+gimple_omp_for_set_combined_p (gimple g, bool combined_p)\n+{\n+  GIMPLE_CHECK (g, GIMPLE_OMP_FOR);\n+  if (combined_p)\n+    g->gsbase.subcode |= GF_OMP_FOR_COMBINED;\n+  else\n+    g->gsbase.subcode &= ~GF_OMP_FOR_COMBINED;\n+}\n+\n+\n+/* Return true if OMP for statement G has the\n+   GF_OMP_FOR_COMBINED_INTO flag set.  */\n+\n+static inline bool\n+gimple_omp_for_combined_into_p (const_gimple g)\n+{\n+  GIMPLE_CHECK (g, GIMPLE_OMP_FOR);\n+  return (gimple_omp_subcode (g) & GF_OMP_FOR_COMBINED_INTO) != 0;\n+}\n+\n+\n+/* Set the GF_OMP_FOR_COMBINED_INTO field in G depending on the boolean\n+   value of COMBINED_P.  */\n+\n+static inline void\n+gimple_omp_for_set_combined_into_p (gimple g, bool combined_p)\n+{\n+  GIMPLE_CHECK (g, GIMPLE_OMP_FOR);\n+  if (combined_p)\n+    g->gsbase.subcode |= GF_OMP_FOR_COMBINED_INTO;\n+  else\n+    g->gsbase.subcode &= ~GF_OMP_FOR_COMBINED_INTO;\n+}\n+\n+\n /* Return the clauses associated with OMP_FOR GS.  */\n \n static inline tree\n@@ -4631,6 +4748,148 @@ gimple_omp_single_set_clauses (gimple gs, tree clauses)\n }\n \n \n+/* Return the clauses associated with OMP_TARGET GS.  */\n+\n+static inline tree\n+gimple_omp_target_clauses (const_gimple gs)\n+{\n+  GIMPLE_CHECK (gs, GIMPLE_OMP_TARGET);\n+  return gs->gimple_omp_parallel.clauses;\n+}\n+\n+\n+/* Return a pointer to the clauses associated with OMP_TARGET GS.  */\n+\n+static inline tree *\n+gimple_omp_target_clauses_ptr (gimple gs)\n+{\n+  GIMPLE_CHECK (gs, GIMPLE_OMP_TARGET);\n+  return &gs->gimple_omp_parallel.clauses;\n+}\n+\n+\n+/* Set CLAUSES to be the clauses associated with OMP_TARGET GS.  */\n+\n+static inline void\n+gimple_omp_target_set_clauses (gimple gs, tree clauses)\n+{\n+  GIMPLE_CHECK (gs, GIMPLE_OMP_TARGET);\n+  gs->gimple_omp_parallel.clauses = clauses;\n+}\n+\n+\n+/* Return the kind of OMP target statemement.  */\n+\n+static inline int\n+gimple_omp_target_kind (const_gimple g)\n+{\n+  GIMPLE_CHECK (g, GIMPLE_OMP_TARGET);\n+  return (gimple_omp_subcode (g) & GF_OMP_TARGET_KIND_MASK);\n+}\n+\n+\n+/* Set the OMP target kind.  */\n+\n+static inline void\n+gimple_omp_target_set_kind (gimple g, int kind)\n+{\n+  GIMPLE_CHECK (g, GIMPLE_OMP_TARGET);\n+  g->gsbase.subcode = (g->gsbase.subcode & ~GF_OMP_TARGET_KIND_MASK)\n+\t\t      | (kind & GF_OMP_TARGET_KIND_MASK);\n+}\n+\n+\n+/* Return the child function used to hold the body of OMP_TARGET GS.  */\n+\n+static inline tree\n+gimple_omp_target_child_fn (const_gimple gs)\n+{\n+  GIMPLE_CHECK (gs, GIMPLE_OMP_TARGET);\n+  return gs->gimple_omp_parallel.child_fn;\n+}\n+\n+/* Return a pointer to the child function used to hold the body of\n+   OMP_TARGET GS.  */\n+\n+static inline tree *\n+gimple_omp_target_child_fn_ptr (gimple gs)\n+{\n+  GIMPLE_CHECK (gs, GIMPLE_OMP_TARGET);\n+  return &gs->gimple_omp_parallel.child_fn;\n+}\n+\n+\n+/* Set CHILD_FN to be the child function for OMP_TARGET GS.  */\n+\n+static inline void\n+gimple_omp_target_set_child_fn (gimple gs, tree child_fn)\n+{\n+  GIMPLE_CHECK (gs, GIMPLE_OMP_TARGET);\n+  gs->gimple_omp_parallel.child_fn = child_fn;\n+}\n+\n+\n+/* Return the artificial argument used to send variables and values\n+   from the parent to the children threads in OMP_TARGET GS.  */\n+\n+static inline tree\n+gimple_omp_target_data_arg (const_gimple gs)\n+{\n+  GIMPLE_CHECK (gs, GIMPLE_OMP_TARGET);\n+  return gs->gimple_omp_parallel.data_arg;\n+}\n+\n+\n+/* Return a pointer to the data argument for OMP_TARGET GS.  */\n+\n+static inline tree *\n+gimple_omp_target_data_arg_ptr (gimple gs)\n+{\n+  GIMPLE_CHECK (gs, GIMPLE_OMP_TARGET);\n+  return &gs->gimple_omp_parallel.data_arg;\n+}\n+\n+\n+/* Set DATA_ARG to be the data argument for OMP_TARGET GS.  */\n+\n+static inline void\n+gimple_omp_target_set_data_arg (gimple gs, tree data_arg)\n+{\n+  GIMPLE_CHECK (gs, GIMPLE_OMP_TARGET);\n+  gs->gimple_omp_parallel.data_arg = data_arg;\n+}\n+\n+\n+/* Return the clauses associated with OMP_TEAMS GS.  */\n+\n+static inline tree\n+gimple_omp_teams_clauses (const_gimple gs)\n+{\n+  GIMPLE_CHECK (gs, GIMPLE_OMP_TEAMS);\n+  return gs->gimple_omp_single.clauses;\n+}\n+\n+\n+/* Return a pointer to the clauses associated with OMP_TEAMS GS.  */\n+\n+static inline tree *\n+gimple_omp_teams_clauses_ptr (gimple gs)\n+{\n+  GIMPLE_CHECK (gs, GIMPLE_OMP_TEAMS);\n+  return &gs->gimple_omp_single.clauses;\n+}\n+\n+\n+/* Set CLAUSES to be the clauses associated with OMP_TEAMS GS.  */\n+\n+static inline void\n+gimple_omp_teams_set_clauses (gimple gs, tree clauses)\n+{\n+  GIMPLE_CHECK (gs, GIMPLE_OMP_TEAMS);\n+  gs->gimple_omp_single.clauses = clauses;\n+}\n+\n+\n /* Return the clauses associated with OMP_SECTIONS GS.  */\n \n static inline tree\n@@ -4973,8 +5232,11 @@ gimple_return_set_retval (gimple gs, tree retval)\n     case GIMPLE_OMP_SECTIONS:\t\t\t\\\n     case GIMPLE_OMP_SECTIONS_SWITCH:\t\t\\\n     case GIMPLE_OMP_SINGLE:\t\t\t\\\n+    case GIMPLE_OMP_TARGET:\t\t\t\\\n+    case GIMPLE_OMP_TEAMS:\t\t\t\\\n     case GIMPLE_OMP_SECTION:\t\t\t\\\n     case GIMPLE_OMP_MASTER:\t\t\t\\\n+    case GIMPLE_OMP_TASKGROUP:\t\t\t\\\n     case GIMPLE_OMP_ORDERED:\t\t\t\\\n     case GIMPLE_OMP_CRITICAL:\t\t\t\\\n     case GIMPLE_OMP_RETURN:\t\t\t\\"}, {"sha": "9bc42e46a7d742f0960718a737859ce93d684137", "filename": "gcc/gimplify.c", "status": "modified", "additions": 553, "deletions": 50, "changes": 603, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -59,9 +59,12 @@ enum gimplify_omp_var_data\n   GOVD_LASTPRIVATE = 32,\n   GOVD_REDUCTION = 64,\n   GOVD_LOCAL = 128,\n-  GOVD_DEBUG_PRIVATE = 256,\n-  GOVD_PRIVATE_OUTER_REF = 512,\n+  GOVD_MAP = 256,\n+  GOVD_DEBUG_PRIVATE = 512,\n+  GOVD_PRIVATE_OUTER_REF = 1024,\n   GOVD_LINEAR = 2048,\n+  GOVD_ALIGNED = 4096,\n+  GOVD_MAP_TO_ONLY = 8192,\n   GOVD_DATA_SHARE_CLASS = (GOVD_SHARED | GOVD_PRIVATE | GOVD_FIRSTPRIVATE\n \t\t\t   | GOVD_LASTPRIVATE | GOVD_REDUCTION | GOVD_LINEAR\n \t\t\t   | GOVD_LOCAL)\n@@ -75,7 +78,10 @@ enum omp_region_type\n   ORT_PARALLEL = 2,\n   ORT_COMBINED_PARALLEL = 3,\n   ORT_TASK = 4,\n-  ORT_UNTIED_TASK = 5\n+  ORT_UNTIED_TASK = 5,\n+  ORT_TEAMS = 8,\n+  ORT_TARGET_DATA = 16,\n+  ORT_TARGET = 32\n };\n \n struct gimplify_omp_ctx\n@@ -86,6 +92,7 @@ struct gimplify_omp_ctx\n   location_t location;\n   enum omp_clause_default_kind default_kind;\n   enum omp_region_type region_type;\n+  bool combined_loop;\n };\n \n static struct gimplify_ctx *gimplify_ctxp;\n@@ -2701,7 +2708,14 @@ gimplify_call_expr (tree *expr_p, gimple_seq *pre_p, bool want_value)\n       notice_special_calls (call);\n       gimplify_seq_add_stmt (pre_p, call);\n       gsi = gsi_last (*pre_p);\n-      fold_stmt (&gsi);\n+      /* Don't fold stmts inside of target construct.  We'll do it\n+\t during omplower pass instead.  */\n+      struct gimplify_omp_ctx *ctx;\n+      for (ctx = gimplify_omp_ctxp; ctx; ctx = ctx->outer_context)\n+\tif (ctx->region_type == ORT_TARGET)\n+\t  break;\n+      if (ctx == NULL)\n+\tfold_stmt (&gsi);\n       *expr_p = NULL_TREE;\n     }\n   else\n@@ -4591,10 +4605,12 @@ is_gimple_stmt (tree t)\n     case OMP_PARALLEL:\n     case OMP_FOR:\n     case OMP_SIMD:\n+    case OMP_DISTRIBUTE:\n     case OMP_SECTIONS:\n     case OMP_SECTION:\n     case OMP_SINGLE:\n     case OMP_MASTER:\n+    case OMP_TASKGROUP:\n     case OMP_ORDERED:\n     case OMP_CRITICAL:\n     case OMP_TASK:\n@@ -4835,7 +4851,14 @@ gimplify_modify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \n   gimplify_seq_add_stmt (pre_p, assign);\n   gsi = gsi_last (*pre_p);\n-  fold_stmt (&gsi);\n+  /* Don't fold stmts inside of target construct.  We'll do it\n+     during omplower pass instead.  */\n+  struct gimplify_omp_ctx *ctx;\n+  for (ctx = gimplify_omp_ctxp; ctx; ctx = ctx->outer_context)\n+    if (ctx->region_type == ORT_TARGET)\n+      break;\n+  if (ctx == NULL)\n+    fold_stmt (&gsi);\n \n   if (want_value)\n     {\n@@ -5610,11 +5633,16 @@ omp_firstprivatize_variable (struct gimplify_omp_ctx *ctx, tree decl)\n \t{\n \t  if (n->value & GOVD_SHARED)\n \t    n->value = GOVD_FIRSTPRIVATE | (n->value & GOVD_SEEN);\n+\t  else if (n->value & GOVD_MAP)\n+\t    n->value |= GOVD_MAP_TO_ONLY;\n \t  else\n \t    return;\n \t}\n+      else if (ctx->region_type == ORT_TARGET)\n+\tomp_add_variable (ctx, decl, GOVD_MAP | GOVD_MAP_TO_ONLY);\n       else if (ctx->region_type != ORT_WORKSHARE\n-\t       && ctx->region_type != ORT_SIMD)\n+\t       && ctx->region_type != ORT_SIMD\n+\t       && ctx->region_type != ORT_TARGET_DATA)\n \tomp_add_variable (ctx, decl, GOVD_FIRSTPRIVATE);\n \n       ctx = ctx->outer_context;\n@@ -5697,7 +5725,7 @@ omp_add_variable (struct gimplify_omp_ctx *ctx, tree decl, unsigned int flags)\n     flags |= GOVD_SEEN;\n \n   n = splay_tree_lookup (ctx->variables, (splay_tree_key)decl);\n-  if (n != NULL)\n+  if (n != NULL && n->value != GOVD_ALIGNED)\n     {\n       /* We shouldn't be re-adding the decl with the same data\n \t sharing class.  */\n@@ -5723,7 +5751,9 @@ omp_add_variable (struct gimplify_omp_ctx *ctx, tree decl, unsigned int flags)\n \t copy into or out of the context.  */\n       if (!(flags & GOVD_LOCAL))\n \t{\n-\t  nflags = flags & GOVD_PRIVATE ? GOVD_PRIVATE : GOVD_FIRSTPRIVATE;\n+\t  nflags = flags & GOVD_MAP\n+\t\t   ? GOVD_MAP | GOVD_MAP_TO_ONLY | GOVD_EXPLICIT\n+\t\t   : flags & GOVD_PRIVATE ? GOVD_PRIVATE : GOVD_FIRSTPRIVATE;\n \t  nflags |= flags & GOVD_SEEN;\n \t  t = DECL_VALUE_EXPR (decl);\n \t  gcc_assert (TREE_CODE (t) == INDIRECT_REF);\n@@ -5752,13 +5782,13 @@ omp_add_variable (struct gimplify_omp_ctx *ctx, tree decl, unsigned int flags)\n \t For local variables TYPE_SIZE_UNIT might not be gimplified yet,\n \t in this case omp_notice_variable will be called later\n \t on when it is gimplified.  */\n-      else if (! (flags & GOVD_LOCAL)\n+      else if (! (flags & (GOVD_LOCAL | GOVD_MAP))\n \t       && DECL_P (TYPE_SIZE_UNIT (TREE_TYPE (decl))))\n \tomp_notice_variable (ctx, TYPE_SIZE_UNIT (TREE_TYPE (decl)), true);\n     }\n-  else if (lang_hooks.decls.omp_privatize_by_reference (decl))\n+  else if ((flags & (GOVD_MAP | GOVD_LOCAL)) == 0\n+\t   && lang_hooks.decls.omp_privatize_by_reference (decl))\n     {\n-      gcc_assert ((flags & GOVD_LOCAL) == 0);\n       omp_firstprivatize_type_sizes (ctx, TREE_TYPE (decl));\n \n       /* Similar to the direct variable sized case above, we'll need the\n@@ -5787,6 +5817,22 @@ omp_notice_threadprivate_variable (struct gimplify_omp_ctx *ctx, tree decl,\n \t\t\t\t   tree decl2)\n {\n   splay_tree_node n;\n+  struct gimplify_omp_ctx *octx;\n+\n+  for (octx = ctx; octx; octx = octx->outer_context)\n+    if (octx->region_type == ORT_TARGET)\n+      {\n+\tn = splay_tree_lookup (octx->variables, (splay_tree_key)decl);\n+\tif (n == NULL)\n+\t  {\n+\t    error (\"threadprivate variable %qE used in target region\",\n+\t\t   DECL_NAME (decl));\n+\t    error_at (octx->location, \"enclosing target region\");\n+\t    splay_tree_insert (octx->variables, (splay_tree_key)decl, 0);\n+\t  }\n+\tif (decl2)\n+\t  splay_tree_insert (octx->variables, (splay_tree_key)decl2, 0);\n+      }\n \n   if (ctx->region_type != ORT_UNTIED_TASK)\n     return false;\n@@ -5835,13 +5881,33 @@ omp_notice_variable (struct gimplify_omp_ctx *ctx, tree decl, bool in_code)\n     }\n \n   n = splay_tree_lookup (ctx->variables, (splay_tree_key)decl);\n+  if (ctx->region_type == ORT_TARGET)\n+    {\n+      if (n == NULL)\n+\t{\n+\t  if (!lang_hooks.types.omp_mappable_type (TREE_TYPE (decl)))\n+\t    {\n+\t      error (\"%qD referenced in target region does not have \"\n+\t\t     \"a mappable type\", decl);\n+\t      omp_add_variable (ctx, decl, GOVD_MAP | GOVD_EXPLICIT | flags);\n+\t    }\n+\t  else\n+\t    omp_add_variable (ctx, decl, GOVD_MAP | flags);\n+\t}\n+      else\n+\tn->value |= flags;\n+      ret = lang_hooks.decls.omp_disregard_value_expr (decl, true);\n+      goto do_outer;\n+    }\n+\n   if (n == NULL)\n     {\n       enum omp_clause_default_kind default_kind, kind;\n       struct gimplify_omp_ctx *octx;\n \n       if (ctx->region_type == ORT_WORKSHARE\n-\t  || ctx->region_type == ORT_SIMD)\n+\t  || ctx->region_type == ORT_SIMD\n+\t  || ctx->region_type == ORT_TARGET_DATA)\n \tgoto do_outer;\n \n       /* ??? Some compiler-generated variables (like SAVE_EXPRs) could be\n@@ -5855,12 +5921,24 @@ omp_notice_variable (struct gimplify_omp_ctx *ctx, tree decl, bool in_code)\n       switch (default_kind)\n \t{\n \tcase OMP_CLAUSE_DEFAULT_NONE:\n-\t  error (\"%qE not specified in enclosing parallel\",\n-\t\t DECL_NAME (lang_hooks.decls.omp_report_decl (decl)));\n \t  if ((ctx->region_type & ORT_TASK) != 0)\n-\t    error_at (ctx->location, \"enclosing task\");\n+\t    {\n+\t      error (\"%qE not specified in enclosing task\",\n+\t\t     DECL_NAME (lang_hooks.decls.omp_report_decl (decl)));\n+\t      error_at (ctx->location, \"enclosing task\");\n+\t    }\n+\t  else if (ctx->region_type == ORT_TEAMS)\n+\t    {\n+\t      error (\"%qE not specified in enclosing teams construct\",\n+\t\t     DECL_NAME (lang_hooks.decls.omp_report_decl (decl)));\n+\t      error_at (ctx->location, \"enclosing teams construct\");\n+\t    }\n \t  else\n-\t    error_at (ctx->location, \"enclosing parallel\");\n+\t    {\n+\t      error (\"%qE not specified in enclosing parallel\",\n+\t\t     DECL_NAME (lang_hooks.decls.omp_report_decl (decl)));\n+\t      error_at (ctx->location, \"enclosing parallel\");\n+\t    }\n \t  /* FALLTHRU */\n \tcase OMP_CLAUSE_DEFAULT_SHARED:\n \t  flags |= GOVD_SHARED;\n@@ -5880,13 +5958,15 @@ omp_notice_variable (struct gimplify_omp_ctx *ctx, tree decl, bool in_code)\n \t    {\n \t      splay_tree_node n2;\n \n+\t      if ((octx->region_type & (ORT_TARGET_DATA | ORT_TARGET)) != 0)\n+\t\tcontinue;\n \t      n2 = splay_tree_lookup (octx->variables, (splay_tree_key) decl);\n \t      if (n2 && (n2->value & GOVD_DATA_SHARE_CLASS) != GOVD_SHARED)\n \t\t{\n \t\t  flags |= GOVD_FIRSTPRIVATE;\n \t\t  break;\n \t\t}\n-\t      if ((octx->region_type & ORT_PARALLEL) != 0)\n+\t      if ((octx->region_type & (ORT_PARALLEL | ORT_TEAMS)) != 0)\n \t\tbreak;\n \t    }\n \t  if (flags & GOVD_FIRSTPRIVATE)\n@@ -6028,6 +6108,9 @@ omp_check_private (struct gimplify_omp_ctx *ctx, tree decl)\n \t\t /* References might be private, but might be shared too.  */\n \t\t || lang_hooks.decls.omp_privatize_by_reference (decl));\n \n+      if ((ctx->region_type & (ORT_TARGET | ORT_TARGET_DATA)) != 0)\n+\tcontinue;\n+\n       n = splay_tree_lookup (ctx->variables, (splay_tree_key) decl);\n       if (n != NULL)\n \treturn (n->value & GOVD_SHARED) == 0;\n@@ -6086,15 +6169,87 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t  flags = GOVD_REDUCTION | GOVD_SEEN | GOVD_EXPLICIT;\n \t  check_non_private = \"reduction\";\n \t  goto do_add;\n-       case OMP_CLAUSE_LINEAR:\n-\t if (gimplify_expr (&OMP_CLAUSE_LINEAR_STEP (c), pre_p, NULL,\n-\t\t\t    is_gimple_val, fb_rvalue) == GS_ERROR)\n-\t   {\n-\t     remove = true;\n-\t     break;\n-\t   }\n-\t flags = GOVD_LINEAR | GOVD_EXPLICIT;\n-\t goto do_add;\n+\tcase OMP_CLAUSE_LINEAR:\n+\t  if (gimplify_expr (&OMP_CLAUSE_LINEAR_STEP (c), pre_p, NULL,\n+\t\t\t     is_gimple_val, fb_rvalue) == GS_ERROR)\n+\t    {\n+\t      remove = true;\n+\t      break;\n+\t    }\n+\t  flags = GOVD_LINEAR | GOVD_EXPLICIT;\n+\t  goto do_add;\n+\n+\tcase OMP_CLAUSE_MAP:\n+\t  if (OMP_CLAUSE_SIZE (c)\n+\t      && gimplify_expr (&OMP_CLAUSE_SIZE (c), pre_p,\n+\t\t\t\tNULL, is_gimple_val, fb_rvalue) == GS_ERROR)\n+\t    {\n+\t      remove = true;\n+\t      break;\n+\t    }\n+\t  decl = OMP_CLAUSE_DECL (c);\n+\t  if (!DECL_P (decl))\n+\t    {\n+\t      if (gimplify_expr (&OMP_CLAUSE_DECL (c), pre_p,\n+\t\t\t\t NULL, is_gimple_lvalue, fb_lvalue)\n+\t\t  == GS_ERROR)\n+\t\t{\n+\t\t  remove = true;\n+\t\t  break;\n+\t\t}\n+\t      break;\n+\t    }\n+\t  flags = GOVD_MAP | GOVD_EXPLICIT;\n+\t  goto do_add;\n+\n+\tcase OMP_CLAUSE_DEPEND:\n+\t  if (TREE_CODE (OMP_CLAUSE_DECL (c)) == COMPOUND_EXPR)\n+\t    {\n+\t      gimplify_expr (&TREE_OPERAND (OMP_CLAUSE_DECL (c), 0), pre_p,\n+\t\t\t     NULL, is_gimple_val, fb_rvalue);\n+\t      OMP_CLAUSE_DECL (c) = TREE_OPERAND (OMP_CLAUSE_DECL (c), 1);\n+\t    }\n+\t  if (error_operand_p (OMP_CLAUSE_DECL (c)))\n+\t    {\n+\t      remove = true;\n+\t      break;\n+\t    }\n+\t  OMP_CLAUSE_DECL (c) = build_fold_addr_expr (OMP_CLAUSE_DECL (c));\n+\t  if (gimplify_expr (&OMP_CLAUSE_DECL (c), pre_p, NULL,\n+\t\t\t     is_gimple_val, fb_rvalue) == GS_ERROR)\n+\t    {\n+\t      remove = true;\n+\t      break;\n+\t    }\n+\t  break;\n+\n+\tcase OMP_CLAUSE_TO:\n+\tcase OMP_CLAUSE_FROM:\n+\t  if (OMP_CLAUSE_SIZE (c)\n+\t      && gimplify_expr (&OMP_CLAUSE_SIZE (c), pre_p,\n+\t\t\t\tNULL, is_gimple_val, fb_rvalue) == GS_ERROR)\n+\t    {\n+\t      remove = true;\n+\t      break;\n+\t    }\n+\t  decl = OMP_CLAUSE_DECL (c);\n+\t  if (error_operand_p (decl))\n+\t    {\n+\t      remove = true;\n+\t      break;\n+\t    }\n+\t  if (!DECL_P (decl))\n+\t    {\n+\t      if (gimplify_expr (&OMP_CLAUSE_DECL (c), pre_p,\n+\t\t\t\t NULL, is_gimple_lvalue, fb_lvalue)\n+\t\t  == GS_ERROR)\n+\t\t{\n+\t\t  remove = true;\n+\t\t  break;\n+\t\t}\n+\t      break;\n+\t    }\n+\t  goto do_notice;\n \n \tdo_add:\n \t  decl = OMP_CLAUSE_DECL (c);\n@@ -6183,19 +6338,36 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \n \tcase OMP_CLAUSE_SCHEDULE:\n \tcase OMP_CLAUSE_NUM_THREADS:\n+\tcase OMP_CLAUSE_NUM_TEAMS:\n+\tcase OMP_CLAUSE_THREAD_LIMIT:\n+\tcase OMP_CLAUSE_DIST_SCHEDULE:\n+\tcase OMP_CLAUSE_DEVICE:\n \t  if (gimplify_expr (&OMP_CLAUSE_OPERAND (c, 0), pre_p, NULL,\n \t\t\t     is_gimple_val, fb_rvalue) == GS_ERROR)\n-\t      remove = true;\n+\t    remove = true;\n \t  break;\n \n \tcase OMP_CLAUSE_NOWAIT:\n \tcase OMP_CLAUSE_ORDERED:\n \tcase OMP_CLAUSE_UNTIED:\n \tcase OMP_CLAUSE_COLLAPSE:\n \tcase OMP_CLAUSE_MERGEABLE:\n+\tcase OMP_CLAUSE_PROC_BIND:\n \tcase OMP_CLAUSE_SAFELEN:\n \t  break;\n \n+\tcase OMP_CLAUSE_ALIGNED:\n+\t  decl = OMP_CLAUSE_DECL (c);\n+\t  if (error_operand_p (decl))\n+\t    {\n+\t      remove = true;\n+\t      break;\n+\t    }\n+\t  if (!is_global_var (decl)\n+\t      && TREE_CODE (TREE_TYPE (decl)) == POINTER_TYPE)\n+\t    omp_add_variable (ctx, decl, GOVD_ALIGNED);\n+\t  break;\n+\n \tcase OMP_CLAUSE_DEFAULT:\n \t  ctx->default_kind = OMP_CLAUSE_DEFAULT_KIND (c);\n \t  break;\n@@ -6235,12 +6407,16 @@ gimplify_adjust_omp_clauses_1 (splay_tree_node n, void *data)\n       gcc_assert ((flags & GOVD_DATA_SHARE_CLASS) == GOVD_PRIVATE);\n       private_debug = true;\n     }\n+  else if (flags & GOVD_MAP)\n+    private_debug = false;\n   else\n     private_debug\n       = lang_hooks.decls.omp_private_debug_clause (decl,\n \t\t\t\t\t\t   !!(flags & GOVD_SHARED));\n   if (private_debug)\n     code = OMP_CLAUSE_PRIVATE;\n+  else if (flags & GOVD_MAP)\n+    code = OMP_CLAUSE_MAP;\n   else if (flags & GOVD_SHARED)\n     {\n       if (is_global_var (decl))\n@@ -6267,6 +6443,8 @@ gimplify_adjust_omp_clauses_1 (splay_tree_node n, void *data)\n     code = OMP_CLAUSE_FIRSTPRIVATE;\n   else if (flags & GOVD_LASTPRIVATE)\n     code = OMP_CLAUSE_LASTPRIVATE;\n+  else if (flags & GOVD_ALIGNED)\n+    return 0;\n   else\n     gcc_unreachable ();\n \n@@ -6277,6 +6455,36 @@ gimplify_adjust_omp_clauses_1 (splay_tree_node n, void *data)\n     OMP_CLAUSE_PRIVATE_DEBUG (clause) = 1;\n   else if (code == OMP_CLAUSE_PRIVATE && (flags & GOVD_PRIVATE_OUTER_REF))\n     OMP_CLAUSE_PRIVATE_OUTER_REF (clause) = 1;\n+  else if (code == OMP_CLAUSE_MAP)\n+    {\n+      OMP_CLAUSE_MAP_KIND (clause) = flags & GOVD_MAP_TO_ONLY\n+\t\t\t\t     ? OMP_CLAUSE_MAP_TO\n+\t\t\t\t     : OMP_CLAUSE_MAP_TOFROM;\n+      if (DECL_SIZE (decl)\n+\t  && TREE_CODE (DECL_SIZE (decl)) != INTEGER_CST)\n+\t{\n+\t  tree decl2 = DECL_VALUE_EXPR (decl);\n+\t  gcc_assert (TREE_CODE (decl2) == INDIRECT_REF);\n+\t  decl2 = TREE_OPERAND (decl2, 0);\n+\t  gcc_assert (DECL_P (decl2));\n+\t  tree mem = build_simple_mem_ref (decl2);\n+\t  OMP_CLAUSE_DECL (clause) = mem;\n+\t  OMP_CLAUSE_SIZE (clause) = TYPE_SIZE_UNIT (TREE_TYPE (decl));\n+\t  if (gimplify_omp_ctxp->outer_context)\n+\t    {\n+\t      struct gimplify_omp_ctx *ctx = gimplify_omp_ctxp->outer_context;\n+\t      omp_notice_variable (ctx, decl2, true);\n+\t      omp_notice_variable (ctx, OMP_CLAUSE_SIZE (clause), true);\n+\t    }\n+\t  tree nc = build_omp_clause (OMP_CLAUSE_LOCATION (clause),\n+\t\t\t\t      OMP_CLAUSE_MAP);\n+\t  OMP_CLAUSE_DECL (nc) = decl;\n+\t  OMP_CLAUSE_SIZE (nc) = size_zero_node;\n+\t  OMP_CLAUSE_MAP_KIND (nc) = OMP_CLAUSE_MAP_POINTER;\n+\t  OMP_CLAUSE_CHAIN (nc) = OMP_CLAUSE_CHAIN (clause);\n+\t  OMP_CLAUSE_CHAIN (clause) = nc;\n+\t}\n+    }\n   *list_p = clause;\n   lang_hooks.decls.omp_finish_clause (clause);\n \n@@ -6352,11 +6560,116 @@ gimplify_adjust_omp_clauses (tree *list_p)\n \t    = (n->value & GOVD_FIRSTPRIVATE) != 0;\n \t  break;\n \n+\tcase OMP_CLAUSE_ALIGNED:\n+\t  decl = OMP_CLAUSE_DECL (c);\n+\t  if (!is_global_var (decl))\n+\t    {\n+\t      n = splay_tree_lookup (ctx->variables, (splay_tree_key) decl);\n+\t      remove = n == NULL || !(n->value & GOVD_SEEN);\n+\t      if (!remove && TREE_CODE (TREE_TYPE (decl)) == POINTER_TYPE)\n+\t\t{\n+\t\t  struct gimplify_omp_ctx *octx;\n+\t\t  if (n != NULL\n+\t\t      && (n->value & (GOVD_DATA_SHARE_CLASS\n+\t\t\t\t      & ~GOVD_FIRSTPRIVATE)))\n+\t\t    remove = true;\n+\t\t  else\n+\t\t    for (octx = ctx->outer_context; octx;\n+\t\t\t octx = octx->outer_context)\n+\t\t      {\n+\t\t\tn = splay_tree_lookup (octx->variables,\n+\t\t\t\t\t       (splay_tree_key) decl);\n+\t\t\tif (n == NULL)\n+\t\t\t  continue;\n+\t\t\tif (n->value & GOVD_LOCAL)\n+\t\t\t  break;\n+\t\t\t/* We have to avoid assigning a shared variable\n+\t\t\t   to itself when trying to add\n+\t\t\t   __builtin_assume_aligned.  */\n+\t\t\tif (n->value & GOVD_SHARED)\n+\t\t\t  {\n+\t\t\t    remove = true;\n+\t\t\t    break;\n+\t\t\t  }\n+\t\t      }\n+\t\t}\n+\t    }\n+\t  else if (TREE_CODE (TREE_TYPE (decl)) == ARRAY_TYPE)\n+\t    {\n+\t      n = splay_tree_lookup (ctx->variables, (splay_tree_key) decl);\n+\t      if (n != NULL && (n->value & GOVD_DATA_SHARE_CLASS) != 0)\n+\t\tremove = true;\n+\t    }\n+\t  break;\n+\n+\tcase OMP_CLAUSE_MAP:\n+\t  decl = OMP_CLAUSE_DECL (c);\n+\t  if (!DECL_P (decl))\n+\t    break;\n+\t  n = splay_tree_lookup (ctx->variables, (splay_tree_key) decl);\n+\t  if (ctx->region_type == ORT_TARGET && !(n->value & GOVD_SEEN))\n+\t    remove = true;\n+\t  else if (DECL_SIZE (decl)\n+\t\t   && TREE_CODE (DECL_SIZE (decl)) != INTEGER_CST\n+\t\t   && OMP_CLAUSE_MAP_KIND (c) != OMP_CLAUSE_MAP_POINTER)\n+\t    {\n+\t      tree decl2 = DECL_VALUE_EXPR (decl);\n+\t      gcc_assert (TREE_CODE (decl2) == INDIRECT_REF);\n+\t      decl2 = TREE_OPERAND (decl2, 0);\n+\t      gcc_assert (DECL_P (decl2));\n+\t      tree mem = build_simple_mem_ref (decl2);\n+\t      OMP_CLAUSE_DECL (c) = mem;\n+\t      OMP_CLAUSE_SIZE (c) = TYPE_SIZE_UNIT (TREE_TYPE (decl));\n+\t      if (ctx->outer_context)\n+\t\t{\n+\t\t  omp_notice_variable (ctx->outer_context, decl2, true);\n+\t\t  omp_notice_variable (ctx->outer_context,\n+\t\t\t\t       OMP_CLAUSE_SIZE (c), true);\n+\t\t}\n+\t      tree nc = build_omp_clause (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\t\t  OMP_CLAUSE_MAP);\n+\t      OMP_CLAUSE_DECL (nc) = decl;\n+\t      OMP_CLAUSE_SIZE (nc) = size_zero_node;\n+\t      OMP_CLAUSE_MAP_KIND (nc) = OMP_CLAUSE_MAP_POINTER;\n+\t      OMP_CLAUSE_CHAIN (nc) = OMP_CLAUSE_CHAIN (c);\n+\t      OMP_CLAUSE_CHAIN (c) = nc;\n+\t      c = nc;\n+\t    }\n+\t  break;\n+\n+\tcase OMP_CLAUSE_TO:\n+\tcase OMP_CLAUSE_FROM:\n+\t  decl = OMP_CLAUSE_DECL (c);\n+\t  if (!DECL_P (decl))\n+\t    break;\n+\t  if (DECL_SIZE (decl)\n+\t      && TREE_CODE (DECL_SIZE (decl)) != INTEGER_CST)\n+\t    {\n+\t      tree decl2 = DECL_VALUE_EXPR (decl);\n+\t      gcc_assert (TREE_CODE (decl2) == INDIRECT_REF);\n+\t      decl2 = TREE_OPERAND (decl2, 0);\n+\t      gcc_assert (DECL_P (decl2));\n+\t      tree mem = build_simple_mem_ref (decl2);\n+\t      OMP_CLAUSE_DECL (c) = mem;\n+\t      OMP_CLAUSE_SIZE (c) = TYPE_SIZE_UNIT (TREE_TYPE (decl));\n+\t      if (ctx->outer_context)\n+\t\t{\n+\t\t  omp_notice_variable (ctx->outer_context, decl2, true);\n+\t\t  omp_notice_variable (ctx->outer_context,\n+\t\t\t\t       OMP_CLAUSE_SIZE (c), true);\n+\t\t}\n+\t    }\n+\t  break;\n+\n \tcase OMP_CLAUSE_REDUCTION:\n \tcase OMP_CLAUSE_COPYIN:\n \tcase OMP_CLAUSE_COPYPRIVATE:\n \tcase OMP_CLAUSE_IF:\n \tcase OMP_CLAUSE_NUM_THREADS:\n+\tcase OMP_CLAUSE_NUM_TEAMS:\n+\tcase OMP_CLAUSE_THREAD_LIMIT:\n+\tcase OMP_CLAUSE_DIST_SCHEDULE:\n+\tcase OMP_CLAUSE_DEVICE:\n \tcase OMP_CLAUSE_SCHEDULE:\n \tcase OMP_CLAUSE_NOWAIT:\n \tcase OMP_CLAUSE_ORDERED:\n@@ -6365,7 +6678,9 @@ gimplify_adjust_omp_clauses (tree *list_p)\n \tcase OMP_CLAUSE_COLLAPSE:\n \tcase OMP_CLAUSE_FINAL:\n \tcase OMP_CLAUSE_MERGEABLE:\n+\tcase OMP_CLAUSE_PROC_BIND:\n \tcase OMP_CLAUSE_SAFELEN:\n+\tcase OMP_CLAUSE_DEPEND:\n \t  break;\n \n \tdefault:\n@@ -6458,12 +6773,39 @@ gimplify_omp_task (tree *expr_p, gimple_seq *pre_p)\n   *expr_p = NULL_TREE;\n }\n \n+/* Helper function of gimplify_omp_for, find OMP_FOR resp. OMP_SIMD\n+   with non-NULL OMP_FOR_INIT.  */\n+\n+static tree\n+find_combined_omp_for (tree *tp, int *walk_subtrees, void *)\n+{\n+  *walk_subtrees = 0;\n+  switch (TREE_CODE (*tp))\n+    {\n+    case OMP_FOR:\n+      *walk_subtrees = 1;\n+      /* FALLTHRU */\n+    case OMP_SIMD:\n+      if (OMP_FOR_INIT (*tp) != NULL_TREE)\n+\treturn *tp;\n+      break;\n+    case BIND_EXPR:\n+    case STATEMENT_LIST:\n+    case OMP_PARALLEL:\n+      *walk_subtrees = 1;\n+      break;\n+    default:\n+      break;\n+    }\n+  return NULL_TREE;\n+}\n+\n /* Gimplify the gross structure of an OMP_FOR statement.  */\n \n static enum gimplify_status\n gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n {\n-  tree for_stmt, decl, var, t;\n+  tree for_stmt, orig_for_stmt, decl, var, t;\n   enum gimplify_status ret = GS_ALL_DONE;\n   enum gimplify_status tret;\n   gimple gfor;\n@@ -6472,9 +6814,9 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n   bool simd;\n   bitmap has_decl_expr = NULL;\n \n-  for_stmt = *expr_p;\n+  orig_for_stmt = for_stmt = *expr_p;\n \n-  simd = TREE_CODE (for_stmt) == OMP_SIMD; \n+  simd = TREE_CODE (for_stmt) == OMP_SIMD;\n   gimplify_scan_omp_clauses (&OMP_FOR_CLAUSES (for_stmt), pre_p,\n \t\t\t     simd ? ORT_SIMD : ORT_WORKSHARE);\n \n@@ -6485,7 +6827,7 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n       has_decl_expr = BITMAP_ALLOC (NULL);\n       if (TREE_CODE (OMP_FOR_PRE_BODY (for_stmt)) == DECL_EXPR\n \t  && TREE_CODE (DECL_EXPR_DECL (OMP_FOR_PRE_BODY (for_stmt)))\n-\t  == VAR_DECL)\n+\t     == VAR_DECL)\n \t{\n \t  t = OMP_FOR_PRE_BODY (for_stmt);\n \t  bitmap_set_bit (has_decl_expr, DECL_UID (DECL_EXPR_DECL (t)));\n@@ -6506,6 +6848,14 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n   gimplify_and_add (OMP_FOR_PRE_BODY (for_stmt), &for_pre_body);\n   OMP_FOR_PRE_BODY (for_stmt) = NULL_TREE;\n \n+  if (OMP_FOR_INIT (for_stmt) == NULL_TREE)\n+    {\n+      for_stmt = walk_tree (&OMP_FOR_BODY (for_stmt), find_combined_omp_for,\n+\t\t\t    NULL, NULL);\n+      gcc_assert (for_stmt != NULL_TREE);\n+      gimplify_omp_ctxp->combined_loop = true;\n+    }\n+\n   for_body = NULL;\n   gcc_assert (TREE_VEC_LENGTH (OMP_FOR_INIT (for_stmt))\n \t      == TREE_VEC_LENGTH (OMP_FOR_COND (for_stmt)));\n@@ -6522,7 +6872,9 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n \n       /* Make sure the iteration variable is private.  */\n       tree c = NULL_TREE;\n-      if (simd)\n+      if (orig_for_stmt != for_stmt)\n+\t/* Do this only on innermost construct for combined ones.  */;\n+      else if (simd)\n \t{\n \t  splay_tree_node n = splay_tree_lookup (gimplify_omp_ctxp->variables,\n \t\t\t\t\t\t (splay_tree_key)decl);\n@@ -6566,7 +6918,9 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n       /* If DECL is not a gimple register, create a temporary variable to act\n \t as an iteration counter.  This is valid, since DECL cannot be\n \t modified in the body of the loop.  */\n-      if (!is_gimple_reg (decl))\n+      if (orig_for_stmt != for_stmt)\n+\tvar = decl;\n+      else if (!is_gimple_reg (decl))\n \t{\n \t  var = create_tmp_var (TREE_TYPE (decl), get_name (decl));\n \t  TREE_OPERAND (t, 0) = var;\n@@ -6599,6 +6953,8 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n \t{\n \tcase PREINCREMENT_EXPR:\n \tcase POSTINCREMENT_EXPR:\n+\t  if (orig_for_stmt != for_stmt)\n+\t    break;\n \t  t = build_int_cst (TREE_TYPE (decl), 1);\n \t  if (c)\n \t    OMP_CLAUSE_LINEAR_STEP (c) = t;\n@@ -6609,6 +6965,8 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n \n \tcase PREDECREMENT_EXPR:\n \tcase POSTDECREMENT_EXPR:\n+\t  if (orig_for_stmt != for_stmt)\n+\t    break;\n \t  t = build_int_cst (TREE_TYPE (decl), -1);\n \t  if (c)\n \t    OMP_CLAUSE_LINEAR_STEP (c) = t;\n@@ -6665,9 +7023,9 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n \t  gcc_unreachable ();\n \t}\n \n-      if (var != decl || TREE_VEC_LENGTH (OMP_FOR_INIT (for_stmt)) > 1)\n+      if ((var != decl || TREE_VEC_LENGTH (OMP_FOR_INIT (for_stmt)) > 1)\n+\t  && orig_for_stmt == for_stmt)\n \t{\n-\t  tree c;\n \t  for (c = OMP_FOR_CLAUSES (for_stmt); c ; c = OMP_CLAUSE_CHAIN (c))\n \t    if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_LASTPRIVATE\n \t\t&& OMP_CLAUSE_DECL (c) == decl\n@@ -6691,21 +7049,49 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n \n   BITMAP_FREE (has_decl_expr);\n \n-  gimplify_and_add (OMP_FOR_BODY (for_stmt), &for_body);\n+  gimplify_and_add (OMP_FOR_BODY (orig_for_stmt), &for_body);\n \n-  gimplify_adjust_omp_clauses (&OMP_FOR_CLAUSES (for_stmt));\n+  if (orig_for_stmt != for_stmt)\n+    for (i = 0; i < TREE_VEC_LENGTH (OMP_FOR_INIT (for_stmt)); i++)\n+      {\n+\tt = TREE_VEC_ELT (OMP_FOR_INIT (for_stmt), i);\n+\tdecl = TREE_OPERAND (t, 0);\n+\tvar = create_tmp_var (TREE_TYPE (decl), get_name (decl));\n+\tomp_add_variable (gimplify_omp_ctxp, var, GOVD_PRIVATE | GOVD_SEEN);\n+\tTREE_OPERAND (t, 0) = var;\n+\tt = TREE_VEC_ELT (OMP_FOR_INCR (for_stmt), i);\n+\tTREE_OPERAND (t, 1) = copy_node (TREE_OPERAND (t, 1));\n+\tTREE_OPERAND (TREE_OPERAND (t, 1), 0) = var;\n+      }\n+\n+  gimplify_adjust_omp_clauses (&OMP_FOR_CLAUSES (orig_for_stmt));\n \n   int kind;\n-  switch (TREE_CODE (for_stmt))\n+  switch (TREE_CODE (orig_for_stmt))\n     {\n     case OMP_FOR: kind = GF_OMP_FOR_KIND_FOR; break;\n     case OMP_SIMD: kind = GF_OMP_FOR_KIND_SIMD; break;\n+    case OMP_DISTRIBUTE: kind = GF_OMP_FOR_KIND_DISTRIBUTE; break;\n     default:\n       gcc_unreachable ();\n     }\n-  gfor = gimple_build_omp_for (for_body, kind, OMP_FOR_CLAUSES (for_stmt),\n+  gfor = gimple_build_omp_for (for_body, kind, OMP_FOR_CLAUSES (orig_for_stmt),\n \t\t\t       TREE_VEC_LENGTH (OMP_FOR_INIT (for_stmt)),\n \t\t\t       for_pre_body);\n+  if (orig_for_stmt != for_stmt)\n+    gimple_omp_for_set_combined_p (gfor, true);\n+  if (gimplify_omp_ctxp\n+      && (gimplify_omp_ctxp->combined_loop\n+\t  || (gimplify_omp_ctxp->region_type == ORT_COMBINED_PARALLEL\n+\t      && gimplify_omp_ctxp->outer_context\n+\t      && gimplify_omp_ctxp->outer_context->combined_loop)))\n+    {\n+      gimple_omp_for_set_combined_into_p (gfor, true);\n+      if (gimplify_omp_ctxp->combined_loop)\n+\tgcc_assert (TREE_CODE (orig_for_stmt) == OMP_SIMD);\n+      else\n+\tgcc_assert (TREE_CODE (orig_for_stmt) == OMP_FOR);\n+    }\n \n   for (i = 0; i < TREE_VEC_LENGTH (OMP_FOR_INIT (for_stmt)); i++)\n     {\n@@ -6726,28 +7112,103 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n   return GS_ALL_DONE;\n }\n \n-/* Gimplify the gross structure of other OpenMP worksharing constructs.\n-   In particular, OMP_SECTIONS and OMP_SINGLE.  */\n+/* Gimplify the gross structure of other OpenMP constructs.\n+   In particular, OMP_SECTIONS, OMP_SINGLE, OMP_TARGET, OMP_TARGET_DATA\n+   and OMP_TEAMS.  */\n \n static void\n gimplify_omp_workshare (tree *expr_p, gimple_seq *pre_p)\n {\n   tree expr = *expr_p;\n   gimple stmt;\n   gimple_seq body = NULL;\n+  enum omp_region_type ort = ORT_WORKSHARE;\n \n-  gimplify_scan_omp_clauses (&OMP_CLAUSES (expr), pre_p, ORT_WORKSHARE);\n-  gimplify_and_add (OMP_BODY (expr), &body);\n+  switch (TREE_CODE (expr))\n+    {\n+    case OMP_SECTIONS:\n+    case OMP_SINGLE:\n+      break;\n+    case OMP_TARGET:\n+      ort = ORT_TARGET;\n+      break;\n+    case OMP_TARGET_DATA:\n+      ort = ORT_TARGET_DATA;\n+      break;\n+    case OMP_TEAMS:\n+      ort = ORT_TEAMS;\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+  gimplify_scan_omp_clauses (&OMP_CLAUSES (expr), pre_p, ort);\n+  if (ort == ORT_TARGET || ort == ORT_TARGET_DATA)\n+    {\n+      struct gimplify_ctx gctx;\n+      push_gimplify_context (&gctx);\n+      gimple g = gimplify_and_return_first (OMP_BODY (expr), &body);\n+      if (gimple_code (g) == GIMPLE_BIND)\n+\tpop_gimplify_context (g);\n+      else\n+\tpop_gimplify_context (NULL);\n+      if (ort == ORT_TARGET_DATA)\n+\t{\n+\t  gimple_seq cleanup = NULL;\n+\t  tree fn = builtin_decl_explicit (BUILT_IN_GOMP_TARGET_END_DATA);\n+\t  g = gimple_build_call (fn, 0);\n+\t  gimple_seq_add_stmt (&cleanup, g);\n+\t  g = gimple_build_try (body, cleanup, GIMPLE_TRY_FINALLY);\n+\t  body = NULL;\n+\t  gimple_seq_add_stmt (&body, g);\n+\t}\n+    }\n+  else\n+    gimplify_and_add (OMP_BODY (expr), &body);\n   gimplify_adjust_omp_clauses (&OMP_CLAUSES (expr));\n \n-  if (TREE_CODE (expr) == OMP_SECTIONS)\n-    stmt = gimple_build_omp_sections (body, OMP_CLAUSES (expr));\n-  else if (TREE_CODE (expr) == OMP_SINGLE)\n-    stmt = gimple_build_omp_single (body, OMP_CLAUSES (expr));\n-  else\n-    gcc_unreachable ();\n+  switch (TREE_CODE (expr))\n+    {\n+    case OMP_SECTIONS:\n+      stmt = gimple_build_omp_sections (body, OMP_CLAUSES (expr));\n+      break;\n+    case OMP_SINGLE:\n+      stmt = gimple_build_omp_single (body, OMP_CLAUSES (expr));\n+      break;\n+    case OMP_TARGET:\n+      stmt = gimple_build_omp_target (body, GF_OMP_TARGET_KIND_REGION,\n+\t\t\t\t      OMP_CLAUSES (expr));\n+      break;\n+    case OMP_TARGET_DATA:\n+      stmt = gimple_build_omp_target (body, GF_OMP_TARGET_KIND_DATA,\n+\t\t\t\t      OMP_CLAUSES (expr));\n+      break;\n+    case OMP_TEAMS:\n+      stmt = gimple_build_omp_teams (body, OMP_CLAUSES (expr));\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  gimplify_seq_add_stmt (pre_p, stmt);\n+  *expr_p = NULL_TREE;\n+}\n+\n+/* Gimplify the gross structure of OpenMP target update construct.  */\n+\n+static void\n+gimplify_omp_target_update (tree *expr_p, gimple_seq *pre_p)\n+{\n+  tree expr = *expr_p;\n+  gimple stmt;\n+\n+  gimplify_scan_omp_clauses (&OMP_TARGET_UPDATE_CLAUSES (expr), pre_p,\n+\t\t\t     ORT_WORKSHARE);\n+  gimplify_adjust_omp_clauses (&OMP_TARGET_UPDATE_CLAUSES (expr));\n+  stmt = gimple_build_omp_target (NULL, GF_OMP_TARGET_KIND_UPDATE,\n+\t\t\t\t  OMP_TARGET_UPDATE_CLAUSES (expr));\n \n   gimplify_seq_add_stmt (pre_p, stmt);\n+  *expr_p = NULL_TREE;\n }\n \n /* A subroutine of gimplify_omp_atomic.  The front end is supposed to have\n@@ -6886,6 +7347,11 @@ gimplify_omp_atomic (tree *expr_p, gimple_seq *pre_p)\n     rhs = tmp_load;\n   storestmt = gimple_build_omp_atomic_store (rhs);\n   gimplify_seq_add_stmt (pre_p, storestmt);\n+  if (OMP_ATOMIC_SEQ_CST (*expr_p))\n+    {\n+      gimple_omp_atomic_set_seq_cst (loadstmt);\n+      gimple_omp_atomic_set_seq_cst (storestmt);\n+    }\n   switch (TREE_CODE (*expr_p))\n     {\n     case OMP_ATOMIC_READ:\n@@ -6902,7 +7368,7 @@ gimplify_omp_atomic (tree *expr_p, gimple_seq *pre_p)\n       break;\n     }\n \n-   return GS_ALL_DONE;\n+  return GS_ALL_DONE;\n }\n \n /* Gimplify a TRANSACTION_EXPR.  This involves gimplification of the\n@@ -7642,17 +8108,27 @@ gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \n \tcase OMP_FOR:\n \tcase OMP_SIMD:\n+\tcase OMP_DISTRIBUTE:\n \t  ret = gimplify_omp_for (expr_p, pre_p);\n \t  break;\n \n \tcase OMP_SECTIONS:\n \tcase OMP_SINGLE:\n+\tcase OMP_TARGET:\n+\tcase OMP_TARGET_DATA:\n+\tcase OMP_TEAMS:\n \t  gimplify_omp_workshare (expr_p, pre_p);\n \t  ret = GS_ALL_DONE;\n \t  break;\n \n+\tcase OMP_TARGET_UPDATE:\n+\t  gimplify_omp_target_update (expr_p, pre_p);\n+\t  ret = GS_ALL_DONE;\n+\t  break;\n+\n \tcase OMP_SECTION:\n \tcase OMP_MASTER:\n+\tcase OMP_TASKGROUP:\n \tcase OMP_ORDERED:\n \tcase OMP_CRITICAL:\n \t  {\n@@ -7668,6 +8144,19 @@ gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \t      case OMP_MASTER:\n \t        g = gimple_build_omp_master (body);\n \t\tbreak;\n+\t      case OMP_TASKGROUP:\n+\t\t{\n+\t\t  gimple_seq cleanup = NULL;\n+\t\t  tree fn\n+\t\t    = builtin_decl_explicit (BUILT_IN_GOMP_TASKGROUP_END);\n+\t\t  g = gimple_build_call (fn, 0);\n+\t\t  gimple_seq_add_stmt (&cleanup, g);\n+\t\t  g = gimple_build_try (body, cleanup, GIMPLE_TRY_FINALLY);\n+\t\t  body = NULL;\n+\t\t  gimple_seq_add_stmt (&body, g);\n+\t\t  g = gimple_build_omp_taskgroup (body);\n+\t\t}\n+\t\tbreak;\n \t      case OMP_ORDERED:\n \t\tg = gimple_build_omp_ordered (body);\n \t\tbreak;\n@@ -8000,6 +8489,7 @@ gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \t\t  && code != OMP_CRITICAL\n \t\t  && code != OMP_FOR\n \t\t  && code != OMP_MASTER\n+\t\t  && code != OMP_TASKGROUP\n \t\t  && code != OMP_ORDERED\n \t\t  && code != OMP_PARALLEL\n \t\t  && code != OMP_SECTIONS\n@@ -8224,6 +8714,13 @@ gimplify_body (tree fndecl, bool do_parms)\n   gcc_assert (gimplify_ctxp == NULL);\n   push_gimplify_context (&gctx);\n \n+  if (flag_openmp)\n+    {\n+      gcc_assert (gimplify_omp_ctxp == NULL);\n+      if (lookup_attribute (\"omp declare target\", DECL_ATTRIBUTES (fndecl)))\n+\tgimplify_omp_ctxp = new_omp_context (ORT_TARGET);\n+    }\n+\n   /* Unshare most shared trees in the body and in that of any nested functions.\n      It would seem we don't have to do this for nested functions because\n      they are supposed to be output and then the outer function gimplified\n@@ -8286,6 +8783,12 @@ gimplify_body (tree fndecl, bool do_parms)\n       nonlocal_vlas = NULL;\n     }\n \n+  if (flag_openmp && gimplify_omp_ctxp)\n+    {\n+      delete_omp_context (gimplify_omp_ctxp);\n+      gimplify_omp_ctxp = NULL;\n+    }\n+\n   pop_gimplify_context (outer_bind);\n   gcc_assert (gimplify_ctxp == NULL);\n "}, {"sha": "b7be47200a824658ac9751fead3a90ada6c54ad5", "filename": "gcc/langhooks-def.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Flanghooks-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Flanghooks-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks-def.h?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -77,6 +77,7 @@ extern tree lhd_omp_assignment (tree, tree, tree);\n struct gimplify_omp_ctx;\n extern void lhd_omp_firstprivatize_type_sizes (struct gimplify_omp_ctx *,\n \t\t\t\t\t       tree);\n+extern bool lhd_omp_mappable_type (tree);\n \n #define LANG_HOOKS_NAME\t\t\t\"GNU unknown\"\n #define LANG_HOOKS_IDENTIFIER_SIZE\tsizeof (struct lang_identifier)\n@@ -166,6 +167,7 @@ extern tree lhd_make_node (enum tree_code);\n #define LANG_HOOKS_TYPE_MAX_SIZE\tlhd_return_null_const_tree\n #define LANG_HOOKS_OMP_FIRSTPRIVATIZE_TYPE_SIZES \\\n   lhd_omp_firstprivatize_type_sizes\n+#define LANG_HOOKS_OMP_MAPPABLE_TYPE\tlhd_omp_mappable_type\n #define LANG_HOOKS_TYPE_HASH_EQ\t\tNULL\n #define LANG_HOOKS_GET_ARRAY_DESCR_INFO\tNULL\n #define LANG_HOOKS_GET_SUBRANGE_BOUNDS\tNULL\n@@ -184,6 +186,7 @@ extern tree lhd_make_node (enum tree_code);\n   LANG_HOOKS_INCOMPLETE_TYPE_ERROR, \\\n   LANG_HOOKS_TYPE_MAX_SIZE, \\\n   LANG_HOOKS_OMP_FIRSTPRIVATIZE_TYPE_SIZES, \\\n+  LANG_HOOKS_OMP_MAPPABLE_TYPE, \\\n   LANG_HOOKS_TYPE_HASH_EQ, \\\n   LANG_HOOKS_GET_ARRAY_DESCR_INFO, \\\n   LANG_HOOKS_GET_SUBRANGE_BOUNDS, \\"}, {"sha": "559d5c1beac9614f326081ed3b24603d75d1af6b", "filename": "gcc/langhooks.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Flanghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Flanghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -523,6 +523,15 @@ lhd_omp_firstprivatize_type_sizes (struct gimplify_omp_ctx *c ATTRIBUTE_UNUSED,\n {\n }\n \n+/* Return true if TYPE is an OpenMP mappable type.  By default return true\n+   if type is complete.  */\n+\n+bool\n+lhd_omp_mappable_type (tree type)\n+{\n+  return COMPLETE_TYPE_P (type);\n+}\n+\n /* Common function for add_builtin_function and\n    add_builtin_function_ext_scope.  */\n static tree"}, {"sha": "a83bf7b71ed31c19804ab84be2a25fa2210e995d", "filename": "gcc/langhooks.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Flanghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Flanghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.h?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -111,6 +111,9 @@ struct lang_hooks_for_types\n      firstprivate variables.  */\n   void (*omp_firstprivatize_type_sizes) (struct gimplify_omp_ctx *, tree);\n \n+  /* Return true if TYPE is a mappable type.  */\n+  bool (*omp_mappable_type) (tree type);\n+\n   /* Return TRUE if TYPE1 and TYPE2 are identical for type hashing purposes.\n      Called only after doing all language independent checks.\n      At present, this function is only called when both TYPE1 and TYPE2 are"}, {"sha": "eaa69306f6726c144e141b665154aff0a4442263", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -1,3 +1,7 @@\n+2013-10-11  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* lto-lang.c (DEF_FUNCTION_TYPE_8): Define.\n+\n 2013-09-25  Tom Tromey  <tromey@redhat.com>\n \n \t* Make-lang.in (LTO_H, LINKER_PLUGIN_API_H, LTO_TREE_H)"}, {"sha": "79cc5609994d76cc808eda6cc318988fe2fe29e8", "filename": "gcc/lto/lto-lang.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Flto%2Flto-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Flto%2Flto-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-lang.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -140,6 +140,7 @@ enum lto_builtin_type\n #define DEF_FUNCTION_TYPE_5(NAME, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5) NAME,\n #define DEF_FUNCTION_TYPE_6(NAME, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6) NAME,\n #define DEF_FUNCTION_TYPE_7(NAME, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7) NAME,\n+#define DEF_FUNCTION_TYPE_8(NAME, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8) NAME,\n #define DEF_FUNCTION_TYPE_VAR_0(NAME, RETURN) NAME,\n #define DEF_FUNCTION_TYPE_VAR_1(NAME, RETURN, ARG1) NAME,\n #define DEF_FUNCTION_TYPE_VAR_2(NAME, RETURN, ARG1, ARG2) NAME,\n@@ -158,6 +159,7 @@ enum lto_builtin_type\n #undef DEF_FUNCTION_TYPE_5\n #undef DEF_FUNCTION_TYPE_6\n #undef DEF_FUNCTION_TYPE_7\n+#undef DEF_FUNCTION_TYPE_8\n #undef DEF_FUNCTION_TYPE_VAR_0\n #undef DEF_FUNCTION_TYPE_VAR_1\n #undef DEF_FUNCTION_TYPE_VAR_2\n@@ -631,6 +633,10 @@ lto_define_builtins (tree va_list_ref_type_node ATTRIBUTE_UNUSED,\n #define DEF_FUNCTION_TYPE_7(ENUM, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, \\\n \t\t\t    ARG6, ARG7)\t\t\t\t\t\\\n   def_fn_type (ENUM, RETURN, 0, 7, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7);\n+#define DEF_FUNCTION_TYPE_8(ENUM, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, \\\n+\t\t\t    ARG6, ARG7, ARG8)\t\t\t\t\\\n+  def_fn_type (ENUM, RETURN, 0, 8, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6,\t\\\n+\t       ARG7, ARG8);\n #define DEF_FUNCTION_TYPE_VAR_0(ENUM, RETURN) \\\n   def_fn_type (ENUM, RETURN, 1, 0);\n #define DEF_FUNCTION_TYPE_VAR_1(ENUM, RETURN, ARG1) \\"}, {"sha": "8fd99548e7ef1c66bd41696cdbe394622d3a44af", "filename": "gcc/omp-builtins.def", "status": "modified", "additions": 49, "deletions": 21, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Fomp-builtins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Fomp-builtins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-builtins.def?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -28,17 +28,31 @@ DEF_GOMP_BUILTIN (BUILT_IN_OMP_GET_THREAD_NUM, \"omp_get_thread_num\",\n \t\t  BT_FN_INT, ATTR_CONST_NOTHROW_LEAF_LIST)\n DEF_GOMP_BUILTIN (BUILT_IN_OMP_GET_NUM_THREADS, \"omp_get_num_threads\",\n \t\t  BT_FN_INT, ATTR_CONST_NOTHROW_LEAF_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_OMP_GET_TEAM_NUM, \"omp_get_team_num\",\n+\t\t  BT_FN_INT, ATTR_CONST_NOTHROW_LEAF_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_OMP_GET_NUM_TEAMS, \"omp_get_num_teams\",\n+\t\t  BT_FN_INT, ATTR_CONST_NOTHROW_LEAF_LIST)\n \n DEF_GOMP_BUILTIN (BUILT_IN_GOMP_ATOMIC_START, \"GOMP_atomic_start\",\n \t\t  BT_FN_VOID, ATTR_NOTHROW_LEAF_LIST)\n DEF_GOMP_BUILTIN (BUILT_IN_GOMP_ATOMIC_END, \"GOMP_atomic_end\",\n \t\t  BT_FN_VOID, ATTR_NOTHROW_LEAF_LIST)\n DEF_GOMP_BUILTIN (BUILT_IN_GOMP_BARRIER, \"GOMP_barrier\",\n \t\t  BT_FN_VOID, ATTR_NOTHROW_LEAF_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_BARRIER_CANCEL, \"GOMP_barrier_cancel\",\n+\t\t  BT_FN_BOOL, ATTR_NOTHROW_LEAF_LIST)\n DEF_GOMP_BUILTIN (BUILT_IN_GOMP_TASKWAIT, \"GOMP_taskwait\",\n \t\t  BT_FN_VOID, ATTR_NOTHROW_LEAF_LIST)\n DEF_GOMP_BUILTIN (BUILT_IN_GOMP_TASKYIELD, \"GOMP_taskyield\",\n \t\t  BT_FN_VOID, ATTR_NOTHROW_LEAF_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_TASKGROUP_START, \"GOMP_taskgroup_start\",\n+\t\t  BT_FN_VOID, ATTR_NOTHROW_LEAF_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_TASKGROUP_END, \"GOMP_taskgroup_end\",\n+\t\t  BT_FN_VOID, ATTR_NOTHROW_LEAF_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_CANCEL, \"GOMP_cancel\",\n+\t\t  BT_FN_BOOL_INT_BOOL, ATTR_NOTHROW_LEAF_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_CANCELLATION_POINT, \"GOMP_cancellation_point\",\n+\t\t  BT_FN_BOOL_INT, ATTR_NOTHROW_LEAF_LIST)\n DEF_GOMP_BUILTIN (BUILT_IN_GOMP_CRITICAL_START, \"GOMP_critical_start\",\n \t\t  BT_FN_VOID, ATTR_NOTHROW_LEAF_LIST)\n DEF_GOMP_BUILTIN (BUILT_IN_GOMP_CRITICAL_END, \"GOMP_critical_end\",\n@@ -156,49 +170,52 @@ DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_ULL_ORDERED_GUIDED_NEXT,\n DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_ULL_ORDERED_RUNTIME_NEXT,\n \t\t  \"GOMP_loop_ull_ordered_runtime_next\",\n \t\t  BT_FN_BOOL_ULONGLONGPTR_ULONGLONGPTR, ATTR_NOTHROW_LEAF_LIST)\n-/* NOTE: Do not change the order of BUILT_IN_GOMP_PARALLEL_LOOP_*_START.\n+/* NOTE: Do not change the order of BUILT_IN_GOMP_PARALLEL_LOOP_*.\n    They are used in index arithmetic with enum omp_clause_schedule_kind\n    in omp-low.c.  */\n-DEF_GOMP_BUILTIN (BUILT_IN_GOMP_PARALLEL_LOOP_STATIC_START,\n-\t\t  \"GOMP_parallel_loop_static_start\",\n-\t\t  BT_FN_VOID_OMPFN_PTR_UINT_LONG_LONG_LONG_LONG,\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_PARALLEL_LOOP_STATIC,\n+\t\t  \"GOMP_parallel_loop_static\",\n+\t\t  BT_FN_VOID_OMPFN_PTR_UINT_LONG_LONG_LONG_LONG_UINT,\n \t\t  ATTR_NOTHROW_LIST)\n-DEF_GOMP_BUILTIN (BUILT_IN_GOMP_PARALLEL_LOOP_DYNAMIC_START,\n-\t\t  \"GOMP_parallel_loop_dynamic_start\",\n-\t\t  BT_FN_VOID_OMPFN_PTR_UINT_LONG_LONG_LONG_LONG,\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_PARALLEL_LOOP_DYNAMIC,\n+\t\t  \"GOMP_parallel_loop_dynamic\",\n+\t\t  BT_FN_VOID_OMPFN_PTR_UINT_LONG_LONG_LONG_LONG_UINT,\n \t\t  ATTR_NOTHROW_LIST)\n-DEF_GOMP_BUILTIN (BUILT_IN_GOMP_PARALLEL_LOOP_GUIDED_START,\n-\t\t  \"GOMP_parallel_loop_guided_start\",\n-\t\t  BT_FN_VOID_OMPFN_PTR_UINT_LONG_LONG_LONG_LONG,\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_PARALLEL_LOOP_GUIDED,\n+\t\t  \"GOMP_parallel_loop_guided\",\n+\t\t  BT_FN_VOID_OMPFN_PTR_UINT_LONG_LONG_LONG_LONG_UINT,\n \t\t  ATTR_NOTHROW_LIST)\n-DEF_GOMP_BUILTIN (BUILT_IN_GOMP_PARALLEL_LOOP_RUNTIME_START,\n-\t\t  \"GOMP_parallel_loop_runtime_start\",\n-\t\t  BT_FN_VOID_OMPFN_PTR_UINT_LONG_LONG_LONG,\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_PARALLEL_LOOP_RUNTIME,\n+\t\t  \"GOMP_parallel_loop_runtime\",\n+\t\t  BT_FN_VOID_OMPFN_PTR_UINT_LONG_LONG_LONG_UINT,\n \t\t  ATTR_NOTHROW_LIST)\n DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_END, \"GOMP_loop_end\",\n \t\t  BT_FN_VOID, ATTR_NOTHROW_LEAF_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_END_CANCEL, \"GOMP_loop_end_cancel\",\n+\t\t  BT_FN_BOOL, ATTR_NOTHROW_LEAF_LIST)\n DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_END_NOWAIT, \"GOMP_loop_end_nowait\",\n \t\t  BT_FN_VOID, ATTR_NOTHROW_LEAF_LIST)\n DEF_GOMP_BUILTIN (BUILT_IN_GOMP_ORDERED_START, \"GOMP_ordered_start\",\n \t\t  BT_FN_VOID, ATTR_NOTHROW_LEAF_LIST)\n DEF_GOMP_BUILTIN (BUILT_IN_GOMP_ORDERED_END, \"GOMP_ordered_end\",\n \t\t  BT_FN_VOID, ATTR_NOTHROW_LEAF_LIST)\n-DEF_GOMP_BUILTIN (BUILT_IN_GOMP_PARALLEL_START, \"GOMP_parallel_start\",\n-\t\t  BT_FN_VOID_OMPFN_PTR_UINT, ATTR_NOTHROW_LIST)\n-DEF_GOMP_BUILTIN (BUILT_IN_GOMP_PARALLEL_END, \"GOMP_parallel_end\",\n-\t\t  BT_FN_VOID, ATTR_NOTHROW_LEAF_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_PARALLEL, \"GOMP_parallel\",\n+\t\t  BT_FN_VOID_OMPFN_PTR_UINT_UINT, ATTR_NOTHROW_LIST)\n DEF_GOMP_BUILTIN (BUILT_IN_GOMP_TASK, \"GOMP_task\",\n-\t\t  BT_FN_VOID_OMPFN_PTR_OMPCPYFN_LONG_LONG_BOOL_UINT,\n+\t\t  BT_FN_VOID_OMPFN_PTR_OMPCPYFN_LONG_LONG_BOOL_UINT_PTR,\n \t\t  ATTR_NOTHROW_LIST)\n DEF_GOMP_BUILTIN (BUILT_IN_GOMP_SECTIONS_START, \"GOMP_sections_start\",\n \t\t  BT_FN_UINT_UINT, ATTR_NOTHROW_LEAF_LIST)\n DEF_GOMP_BUILTIN (BUILT_IN_GOMP_SECTIONS_NEXT, \"GOMP_sections_next\",\n \t\t  BT_FN_UINT, ATTR_NOTHROW_LEAF_LIST)\n-DEF_GOMP_BUILTIN (BUILT_IN_GOMP_PARALLEL_SECTIONS_START,\n-\t\t  \"GOMP_parallel_sections_start\",\n-\t\t  BT_FN_VOID_OMPFN_PTR_UINT_UINT, ATTR_NOTHROW_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_PARALLEL_SECTIONS,\n+\t\t  \"GOMP_parallel_sections\",\n+\t\t  BT_FN_VOID_OMPFN_PTR_UINT_UINT_UINT, ATTR_NOTHROW_LIST)\n DEF_GOMP_BUILTIN (BUILT_IN_GOMP_SECTIONS_END, \"GOMP_sections_end\",\n \t\t  BT_FN_VOID, ATTR_NOTHROW_LEAF_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_SECTIONS_END_CANCEL,\n+\t\t  \"GOMP_sections_end_cancel\",\n+\t\t  BT_FN_BOOL, ATTR_NOTHROW_LEAF_LIST)\n DEF_GOMP_BUILTIN (BUILT_IN_GOMP_SECTIONS_END_NOWAIT,\n \t\t  \"GOMP_sections_end_nowait\",\n \t\t  BT_FN_VOID, ATTR_NOTHROW_LEAF_LIST)\n@@ -208,3 +225,14 @@ DEF_GOMP_BUILTIN (BUILT_IN_GOMP_SINGLE_COPY_START, \"GOMP_single_copy_start\",\n \t\t  BT_FN_PTR, ATTR_NOTHROW_LEAF_LIST)\n DEF_GOMP_BUILTIN (BUILT_IN_GOMP_SINGLE_COPY_END, \"GOMP_single_copy_end\",\n \t\t  BT_FN_VOID_PTR, ATTR_NOTHROW_LEAF_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_TARGET, \"GOMP_target\",\n+\t\t  BT_FN_VOID_INT_OMPFN_PTR_SIZE_PTR_PTR_PTR,\n+\t\t  ATTR_NOTHROW_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_TARGET_DATA, \"GOMP_target_data\",\n+\t\t  BT_FN_VOID_INT_PTR_SIZE_PTR_PTR_PTR, ATTR_NOTHROW_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_TARGET_END_DATA, \"GOMP_target_end_data\",\n+\t\t  BT_FN_VOID, ATTR_NOTHROW_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_TARGET_UPDATE, \"GOMP_target_update\",\n+\t\t  BT_FN_VOID_INT_PTR_SIZE_PTR_PTR_PTR, ATTR_NOTHROW_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_TEAMS, \"GOMP_teams\",\n+\t\t  BT_FN_VOID_UINT_UINT, ATTR_NOTHROW_LIST)"}, {"sha": "26f0c35e28596e93051f1f3f6cd8df7b248236e5", "filename": "gcc/omp-low.c", "status": "modified", "additions": 2333, "deletions": 309, "changes": 2642, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530"}, {"sha": "c58d9ea7eec84d3c58ea9734f0a2a1074d0addd3", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -1,3 +1,64 @@\n+2013-10-11  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* c-c++-common/gomp/atomic-15.c: Adjust for C diagnostics.\n+\tRemove error test that is now valid in OpenMP 4.0.\n+\t* c-c++-common/gomp/atomic-16.c: New test.\n+\t* c-c++-common/gomp/cancel-1.c: New test.\n+\t* c-c++-common/gomp/depend-1.c: New test.\n+\t* c-c++-common/gomp/depend-2.c: New test.\n+\t* c-c++-common/gomp/map-1.c: New test.\n+\t* c-c++-common/gomp/pr58472.c: New test.\n+\t* c-c++-common/gomp/sections1.c: New test.\n+\t* c-c++-common/gomp/simd1.c: New test.\n+\t* c-c++-common/gomp/simd2.c: New test.\n+\t* c-c++-common/gomp/simd3.c: New test.\n+\t* c-c++-common/gomp/simd4.c: New test.\n+\t* c-c++-common/gomp/simd5.c: New test.\n+\t* c-c++-common/gomp/single1.c: New test.\n+\t* g++.dg/gomp/block-0.C: Adjust for stricter #pragma omp sections\n+\tparser.\n+\t* g++.dg/gomp/block-3.C: Likewise.\n+\t* g++.dg/gomp/clause-3.C: Adjust error messages.\n+\t* g++.dg/gomp/declare-simd-1.C: New test.\n+\t* g++.dg/gomp/declare-simd-2.C: New test.\n+\t* g++.dg/gomp/depend-1.C: New test.\n+\t* g++.dg/gomp/depend-2.C: New test.\n+\t* g++.dg/gomp/target-1.C: New test.\n+\t* g++.dg/gomp/target-2.C: New test.\n+\t* g++.dg/gomp/taskgroup-1.C: New test.\n+\t* g++.dg/gomp/teams-1.C: New test.\n+\t* g++.dg/gomp/udr-1.C: New test.\n+\t* g++.dg/gomp/udr-2.C: New test.\n+\t* g++.dg/gomp/udr-3.C: New test.\n+\t* g++.dg/gomp/udr-4.C: New test.\n+\t* g++.dg/gomp/udr-5.C: New test.\n+\t* g++.dg/gomp/udr-6.C: New test.\n+\t* gcc.dg/autopar/outer-1.c: Expect 4 instead of 5 loopfn matches.\n+\t* gcc.dg/autopar/outer-2.c: Likewise.\n+\t* gcc.dg/autopar/outer-3.c: Likewise.\n+\t* gcc.dg/autopar/outer-4.c: Likewise.\n+\t* gcc.dg/autopar/outer-5.c: Likewise.\n+\t* gcc.dg/autopar/outer-6.c: Likewise.\n+\t* gcc.dg/autopar/parallelization-1.c: Likewise.\n+\t* gcc.dg/gomp/block-3.c: Adjust for stricter #pragma omp sections\n+\tparser.\n+\t* gcc.dg/gomp/clause-1.c: Adjust error messages.\n+\t* gcc.dg/gomp/combined-1.c: Look for GOMP_parallel_loop_runtime\n+\tinstead of GOMP_parallel_loop_runtime_start.\n+\t* gcc.dg/gomp/declare-simd-1.c: New test.\n+\t* gcc.dg/gomp/declare-simd-2.c: New test.\n+\t* gcc.dg/gomp/nesting-1.c: Adjust for stricter #pragma omp sections\n+\tparser.  Add further #pragma omp sections nesting tests.\n+\t* gcc.dg/gomp/target-1.c: New test.\n+\t* gcc.dg/gomp/target-2.c: New test.\n+\t* gcc.dg/gomp/taskgroup-1.c: New test.\n+\t* gcc.dg/gomp/teams-1.c: New test.\n+\t* gcc.dg/gomp/udr-1.c: New test.\n+\t* gcc.dg/gomp/udr-2.c: New test.\n+\t* gcc.dg/gomp/udr-3.c: New test.\n+\t* gcc.dg/gomp/udr-4.c: New test.\n+\t* gfortran.dg/gomp/appendix-a/a.35.5.f90: Add dg-error.\n+\n 2013-10-10  Jan Hubicka  <jh@suse.cz>\n \n \t* gcc.target/i386/avx256-unaligned-store-3.c: Update template for"}, {"sha": "5e669fa3543d8d8491b5fcddc4dc6c00e12b91b7", "filename": "gcc/testsuite/c-c++-common/gomp/atomic-15.c", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-15.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -8,39 +8,37 @@ main ()\n {\n   int v;\n   #pragma omp atomic\n-    x = x * 7 + 6;\t/* { dg-error \"expected\" } */\n+    x = x * 7 + 6;\t/* { dg-error \"expected|invalid form of\" } */\n   #pragma omp atomic\n-    x = x * 7 ^ 6;\t/* { dg-error \"expected\" } */\n+    x = x * 7 ^ 6;\t/* { dg-error \"expected|invalid form of\" } */\n   #pragma omp atomic update\n-    x = x - 8 + 6;\t/* { dg-error \"expected\" } */\n+    x = x - 8 + 6;\t/* { dg-error \"expected|invalid form of\" } */\n   #pragma omp atomic\n-    x = x ^ 7 | 2;\t/* { dg-error \"expected\" } */\n+    x = x ^ 7 | 2;\t/* { dg-error \"expected|invalid form of\" } */\n   #pragma omp atomic\n-    x = x / 7 * 2;\t/* { dg-error \"expected\" } */\n+    x = x / 7 * 2;\t/* { dg-error \"expected|invalid form of\" } */\n   #pragma omp atomic\n-    x = x / 7 / 2;\t/* { dg-error \"expected\" } */\n+    x = x / 7 / 2;\t/* { dg-error \"expected|invalid form of\" } */\n   #pragma omp atomic capture\n-    v = x = x | 6;\t/* { dg-error \"invalid operator\" } */\n+    { v = x; x = x * 7 + 6; }\t/* { dg-error \"expected\" \"\" { target c++ } } */\n   #pragma omp atomic capture\n-    { v = x; x = x * 7 + 6; }\t/* { dg-error \"expected\" } */\n+    { v = x; x = x * 7 ^ 6; }\t/* { dg-error \"expected\" \"\" { target c++ } } */\n   #pragma omp atomic capture\n-    { v = x; x = x * 7 ^ 6; }\t/* { dg-error \"expected\" } */\n+    { v = x; x = x - 8 + 6; }\t/* { dg-error \"expected\" \"\" { target c++ } } */\n   #pragma omp atomic capture\n-    { v = x; x = x - 8 + 6; }\t/* { dg-error \"expected\" } */\n+    { v = x; x = x ^ 7 | 2; }\t/* { dg-error \"expected\" \"\" { target c++ } } */\n   #pragma omp atomic capture\n-    { v = x; x = x ^ 7 | 2; }\t/* { dg-error \"expected\" } */\n+    { v = x; x = x / 7 * 2; }\t/* { dg-error \"expected\" \"\" { target c++ } } */\n   #pragma omp atomic capture\n-    { v = x; x = x / 7 * 2; }\t/* { dg-error \"expected\" } */\n+    { v = x; x = x / 7 / 2; }\t/* { dg-error \"expected\" \"\" { target c++ } } */\n   #pragma omp atomic capture\n-    { v = x; x = x / 7 / 2; }\t/* { dg-error \"expected\" } */\n+    { x = x * 7 + 6; v = x; }\t/* { dg-error \"expected|uses two different expressions for memory\" } */\n   #pragma omp atomic capture\n-    { x = x * 7 + 6; v = x; }\t/* { dg-error \"expected\" } */\n+    { x = x * 7 ^ 6; v = x; }\t/* { dg-error \"expected|uses two different expressions for memory\" } */\n   #pragma omp atomic capture\n-    { x = x * 7 ^ 6; v = x; }\t/* { dg-error \"expected\" } */\n+    { x = x - 8 + 6; v = x; }\t/* { dg-error \"expected|uses two different expressions for memory\" } */\n   #pragma omp atomic capture\n-    { x = x - 8 + 6; v = x; }\t/* { dg-error \"expected\" } */\n-  #pragma omp atomic capture\n-    { x = x ^ 7 | 2; v = x; }\t/* { dg-error \"expected\" } */\n+    { x = x ^ 7 | 2; v = x; }\t/* { dg-error \"expected|uses two different expressions for memory\" } */\n   (void) v;\n   return 0;\n }"}, {"sha": "87fbaa23317f1278b806e5affd19a9e6adf89154", "filename": "gcc/testsuite/c-c++-common/gomp/atomic-16.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-16.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -0,0 +1,34 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp\" } */\n+\n+int x = 6;\n+\n+void\n+foo ()\n+{\n+  int v;\n+  #pragma omp atomic seq_cst load\t/* { dg-error \"expected end of line\" } */\n+  v = x;\t\t\t  \t/* { dg-error \"invalid form\" } */\n+  #pragma omp atomic seq_cst, load\t/* { dg-error \"expected end of line\" } */\n+  v = x;\t\t\t  \t/* { dg-error \"invalid form\" } */\n+  #pragma omp atomic seq_cst store\t/* { dg-error \"expected end of line\" } */\n+  x = v;\t\t\t  \t/* { dg-error \"invalid form\" } */\n+  #pragma omp atomic seq_cst ,store\t/* { dg-error \"expected end of line\" } */\n+  x = v;\t\t\t  \t/* { dg-error \"invalid form\" } */\n+  #pragma omp atomic seq_cst update\t/* { dg-error \"expected end of line\" } */\n+  x += v;\n+  #pragma omp atomic seq_cst , update\t/* { dg-error \"expected end of line\" } */\n+  x += v;\n+  #pragma omp atomic seq_cst capture\t/* { dg-error \"expected end of line\" } */\n+  v = x += 2;\t\t\t  \t/* { dg-error \"invalid form\" } */\n+  #pragma omp atomic seq_cst, capture\t/* { dg-error \"expected end of line\" } */\n+  v = x += 2;\t\t\t  \t/* { dg-error \"invalid form\" } */\n+  #pragma omp atomic load , seq_cst\t/* { dg-error \"expected end of line\" } */\n+  v = x;\t\t\t  \t/* { dg-error \"invalid form\" } */\n+  #pragma omp atomic store ,seq_cst\t/* { dg-error \"expected end of line\" } */\n+  x = v;\t\t\t  \t/* { dg-error \"invalid form\" } */\n+  #pragma omp atomic update, seq_cst\t/* { dg-error \"expected end of line\" } */\n+  x += v;\n+  #pragma omp atomic capture, seq_cst\t/* { dg-error \"expected end of line\" } */\n+  v = x += 2;\n+}"}, {"sha": "d8f7bc1b8fa93fb8c57ba562e2a34d75fa837f41", "filename": "gcc/testsuite/c-c++-common/gomp/cancel-1.c", "status": "added", "additions": 396, "deletions": 0, "changes": 396, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fcancel-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fcancel-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fcancel-1.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -0,0 +1,396 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp\" } */\n+\n+void\n+f1 (void)\n+{\n+  #pragma omp cancel parallel\t\t\t/* { dg-error \"orphaned\" } */\n+  #pragma omp cancel for\t\t\t/* { dg-error \"orphaned\" } */\n+  #pragma omp cancel sections\t\t\t/* { dg-error \"orphaned\" } */\n+  #pragma omp cancel taskgroup\t\t\t/* { dg-error \"orphaned\" } */\n+  #pragma omp cancellation point parallel\t/* { dg-error \"orphaned\" } */\n+  #pragma omp cancellation point for\t\t/* { dg-error \"orphaned\" } */\n+  #pragma omp cancellation point sections\t/* { dg-error \"orphaned\" } */\n+  #pragma omp cancellation point taskgroup\t/* { dg-error \"orphaned\" } */\n+}\n+\n+void\n+f2 (void)\n+{\n+  int i;\n+  #pragma omp parallel\n+  {\n+    #pragma omp cancel parallel\n+    #pragma omp cancel for\t\t\t/* { dg-error \"not closely nested inside\" } */\n+    #pragma omp cancel sections\t\t\t/* { dg-error \"not closely nested inside\" } */\n+    #pragma omp cancel taskgroup\t\t/* { dg-error \"not closely nested inside\" } */\n+    #pragma omp cancellation point parallel\n+    #pragma omp cancellation point for\t\t/* { dg-error \"not closely nested inside\" } */\n+    #pragma omp cancellation point sections\t/* { dg-error \"not closely nested inside\" } */\n+    #pragma omp cancellation point taskgroup\t/* { dg-error \"not closely nested inside\" } */\n+    #pragma omp master\n+    {\n+      #pragma omp cancel parallel\t\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancel for\t\t\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancel sections\t\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancel taskgroup\t\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancellation point parallel\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancellation point for\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancellation point sections\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancellation point taskgroup\t/* { dg-error \"not closely nested inside\" } */\n+    }\n+    #pragma omp single\n+    {\n+      #pragma omp cancel parallel\t\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancel for\t\t\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancel sections\t\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancel taskgroup\t\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancellation point parallel\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancellation point for\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancellation point sections\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancellation point taskgroup\t/* { dg-error \"not closely nested inside\" } */\n+    }\n+    #pragma omp critical\n+    {\n+      #pragma omp cancel parallel\t\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancel for\t\t\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancel sections\t\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancel taskgroup\t\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancellation point parallel\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancellation point for\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancellation point sections\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancellation point taskgroup\t/* { dg-error \"not closely nested inside\" } */\n+    }\n+    #pragma omp taskgroup\n+    {\n+      #pragma omp cancel parallel\t\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancel for\t\t\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancel sections\t\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancel taskgroup\t\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancellation point parallel\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancellation point for\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancellation point sections\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancellation point taskgroup\t/* { dg-error \"not closely nested inside\" } */\n+    }\n+    #pragma omp task\n+    {\n+      #pragma omp cancel parallel\t\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancel for\t\t\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancel sections\t\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancel taskgroup\n+      #pragma omp cancellation point parallel\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancellation point for\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancellation point sections\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancellation point taskgroup\n+    }\n+    #pragma omp for\n+    for (i = 0; i < 10; i++)\n+      {\n+\t#pragma omp cancel parallel\t\t/* { dg-error \"not closely nested inside\" } */\n+\t#pragma omp cancel for\n+\t#pragma omp cancel sections\t\t/* { dg-error \"not closely nested inside\" } */\n+\t#pragma omp cancel taskgroup\t\t/* { dg-error \"not closely nested inside\" } */\n+\t#pragma omp cancellation point parallel\t/* { dg-error \"not closely nested inside\" } */\n+\t#pragma omp cancellation point for\n+\t#pragma omp cancellation point sections\t/* { dg-error \"not closely nested inside\" } */\n+\t#pragma omp cancellation point taskgroup/* { dg-error \"not closely nested inside\" } */\n+      }\n+    #pragma omp for ordered\n+    for (i = 0; i < 10; i++)\n+      #pragma omp ordered\n+      {\n+\t#pragma omp cancel parallel\t\t/* { dg-error \"not closely nested inside\" } */\n+\t#pragma omp cancel for\t\t\t/* { dg-error \"not closely nested inside\" } */\n+\t#pragma omp cancel sections\t\t/* { dg-error \"not closely nested inside\" } */\n+\t#pragma omp cancel taskgroup\t\t/* { dg-error \"not closely nested inside\" } */\n+\t#pragma omp cancellation point parallel\t/* { dg-error \"not closely nested inside\" } */\n+\t#pragma omp cancellation point for\t/* { dg-error \"not closely nested inside\" } */\n+\t#pragma omp cancellation point sections\t/* { dg-error \"not closely nested inside\" } */\n+\t#pragma omp cancellation point taskgroup/* { dg-error \"not closely nested inside\" } */\n+      }\n+    #pragma omp sections\n+    {\n+      {\n+\t#pragma omp cancel parallel\t\t/* { dg-error \"not closely nested inside\" } */\n+\t#pragma omp cancel for\t\t\t/* { dg-error \"not closely nested inside\" } */\n+\t#pragma omp cancel sections\n+\t#pragma omp cancel taskgroup\t\t/* { dg-error \"not closely nested inside\" } */\n+\t#pragma omp cancellation point parallel\t/* { dg-error \"not closely nested inside\" } */\n+\t#pragma omp cancellation point for\t/* { dg-error \"not closely nested inside\" } */\n+\t#pragma omp cancellation point sections\n+\t#pragma omp cancellation point taskgroup/* { dg-error \"not closely nested inside\" } */\n+      }\n+      #pragma omp section\n+      {\n+\t#pragma omp cancel parallel\t\t/* { dg-error \"not closely nested inside\" } */\n+\t#pragma omp cancel for\t\t\t/* { dg-error \"not closely nested inside\" } */\n+\t#pragma omp cancel sections\n+\t#pragma omp cancel taskgroup\t\t/* { dg-error \"not closely nested inside\" } */\n+\t#pragma omp cancellation point parallel\t/* { dg-error \"not closely nested inside\" } */\n+\t#pragma omp cancellation point for\t/* { dg-error \"not closely nested inside\" } */\n+\t#pragma omp cancellation point sections\n+\t#pragma omp cancellation point taskgroup/* { dg-error \"not closely nested inside\" } */\n+      }\n+    }\n+    #pragma omp target data\n+    {\n+      #pragma omp cancel parallel\t\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancel for\t\t\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancel sections\t\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancel taskgroup\t\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancellation point parallel\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancellation point for\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancellation point sections\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancellation point taskgroup\t/* { dg-error \"not closely nested inside\" } */\n+    }\n+    #pragma omp target\n+    {\n+      #pragma omp cancel parallel\t\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancel for\t\t\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancel sections\t\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancel taskgroup\t\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancellation point parallel\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancellation point for\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancellation point sections\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancellation point taskgroup\t/* { dg-error \"not closely nested inside\" } */\n+    }\n+  }\n+  #pragma omp target data\n+  {\n+    #pragma omp cancel parallel\t\t\t/* { dg-error \"not closely nested inside\" } */\n+    #pragma omp cancel for\t\t\t/* { dg-error \"not closely nested inside\" } */\n+    #pragma omp cancel sections\t\t\t/* { dg-error \"not closely nested inside\" } */\n+    #pragma omp cancel taskgroup\t\t/* { dg-error \"not closely nested inside\" } */\n+    #pragma omp cancellation point parallel\t/* { dg-error \"not closely nested inside\" } */\n+    #pragma omp cancellation point for\t\t/* { dg-error \"not closely nested inside\" } */\n+    #pragma omp cancellation point sections\t/* { dg-error \"not closely nested inside\" } */\n+    #pragma omp cancellation point taskgroup\t/* { dg-error \"not closely nested inside\" } */\n+  }\n+  #pragma omp target\n+  {\n+    #pragma omp cancel parallel\t\t\t/* { dg-error \"not closely nested inside\" } */\n+    #pragma omp cancel for\t\t\t/* { dg-error \"not closely nested inside\" } */\n+    #pragma omp cancel sections\t\t\t/* { dg-error \"not closely nested inside\" } */\n+    #pragma omp cancel taskgroup\t\t/* { dg-error \"not closely nested inside\" } */\n+    #pragma omp cancellation point parallel\t/* { dg-error \"not closely nested inside\" } */\n+    #pragma omp cancellation point for\t\t/* { dg-error \"not closely nested inside\" } */\n+    #pragma omp cancellation point sections\t/* { dg-error \"not closely nested inside\" } */\n+    #pragma omp cancellation point taskgroup\t/* { dg-error \"not closely nested inside\" } */\n+  }\n+  #pragma omp target teams\n+  {\n+    #pragma omp cancel parallel\t\t\t/* { dg-error \"only distribute or parallel constructs are allowed to be closely nested\" } */\n+    #pragma omp cancel for\t\t\t/* { dg-error \"only distribute or parallel constructs are allowed to be closely nested\" } */\n+    #pragma omp cancel sections\t\t\t/* { dg-error \"only distribute or parallel constructs are allowed to be closely nested\" } */\n+    #pragma omp cancel taskgroup\t\t/* { dg-error \"only distribute or parallel constructs are allowed to be closely nested\" } */\n+    #pragma omp cancellation point parallel\t/* { dg-error \"only distribute or parallel constructs are allowed to be closely nested\" } */\n+    #pragma omp cancellation point for\t\t/* { dg-error \"only distribute or parallel constructs are allowed to be closely nested\" } */\n+    #pragma omp cancellation point sections\t/* { dg-error \"only distribute or parallel constructs are allowed to be closely nested\" } */\n+    #pragma omp cancellation point taskgroup\t/* { dg-error \"only distribute or parallel constructs are allowed to be closely nested\" } */\n+  }\n+  #pragma omp target teams distribute\n+  for (i = 0; i < 10; i++)\n+    {\n+      #pragma omp cancel parallel\t\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancel for\t\t\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancel sections\t\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancel taskgroup\t\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancellation point parallel\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancellation point for\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancellation point sections\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancellation point taskgroup\t/* { dg-error \"not closely nested inside\" } */\n+    }\n+  #pragma omp for\n+  for (i = 0; i < 10; i++)\n+    {\n+      #pragma omp cancel parallel\t\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancel for\n+      #pragma omp cancel sections\t\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancel taskgroup\t\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancellation point parallel\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancellation point for\n+      #pragma omp cancellation point sections\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancellation point taskgroup\t/* { dg-error \"not closely nested inside\" } */\n+    }\n+  #pragma omp for\n+  for (i = 0; i < 10; i++)\n+    #pragma omp target data\n+    {\n+      #pragma omp cancel parallel\t\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancel for\t\t\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancel sections\t\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancel taskgroup\t\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancellation point parallel\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancellation point for\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancellation point sections\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancellation point taskgroup\t/* { dg-error \"not closely nested inside\" } */\n+    }\n+  #pragma omp for\n+  for (i = 0; i < 10; i++)\n+    #pragma omp target\n+    {\n+      #pragma omp cancel parallel\t\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancel for\t\t\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancel sections\t\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancel taskgroup\t\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancellation point parallel\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancellation point for\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancellation point sections\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancellation point taskgroup\t/* { dg-error \"not closely nested inside\" } */\n+    }\n+  #pragma omp for ordered\n+  for (i = 0; i < 10; i++)\n+    #pragma omp ordered\n+      #pragma omp target data\n+      {\n+\t#pragma omp cancel parallel\t\t/* { dg-error \"not closely nested inside\" } */\n+\t#pragma omp cancel for\t\t\t/* { dg-error \"not closely nested inside\" } */\n+\t#pragma omp cancel sections\t\t/* { dg-error \"not closely nested inside\" } */\n+\t#pragma omp cancel taskgroup\t\t/* { dg-error \"not closely nested inside\" } */\n+\t#pragma omp cancellation point parallel\t/* { dg-error \"not closely nested inside\" } */\n+\t#pragma omp cancellation point for\t/* { dg-error \"not closely nested inside\" } */\n+\t#pragma omp cancellation point sections\t/* { dg-error \"not closely nested inside\" } */\n+\t#pragma omp cancellation point taskgroup/* { dg-error \"not closely nested inside\" } */\n+      }\n+  #pragma omp for ordered\n+  for (i = 0; i < 10; i++)\n+    #pragma omp ordered\n+      #pragma omp target\n+      {\n+\t#pragma omp cancel parallel\t\t/* { dg-error \"not closely nested inside\" } */\n+\t#pragma omp cancel for\t\t\t/* { dg-error \"not closely nested inside\" } */\n+\t#pragma omp cancel sections\t\t/* { dg-error \"not closely nested inside\" } */\n+\t#pragma omp cancel taskgroup\t\t/* { dg-error \"not closely nested inside\" } */\n+\t#pragma omp cancellation point parallel\t/* { dg-error \"not closely nested inside\" } */\n+\t#pragma omp cancellation point for\t/* { dg-error \"not closely nested inside\" } */\n+\t#pragma omp cancellation point sections\t/* { dg-error \"not closely nested inside\" } */\n+\t#pragma omp cancellation point taskgroup/* { dg-error \"not closely nested inside\" } */\n+      }\n+  #pragma omp sections\n+  {\n+    {\n+      #pragma omp cancel parallel\t\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancel for\t\t\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancel sections\n+      #pragma omp cancel taskgroup\t\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancellation point parallel\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancellation point for\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancellation point sections\n+      #pragma omp cancellation point taskgroup\t/* { dg-error \"not closely nested inside\" } */\n+    }\n+    #pragma omp section\n+    {\n+      #pragma omp cancel parallel\t\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancel for\t\t\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancel sections\n+      #pragma omp cancel taskgroup\t\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancellation point parallel\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancellation point for\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancellation point sections\n+      #pragma omp cancellation point taskgroup\t/* { dg-error \"not closely nested inside\" } */\n+    }\n+  }\n+  #pragma omp sections\n+  {\n+    #pragma omp target data\n+    {\n+      #pragma omp cancel parallel\t\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancel for\t\t\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancel sections\t\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancel taskgroup\t\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancellation point parallel\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancellation point for\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancellation point sections\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancellation point taskgroup\t/* { dg-error \"not closely nested inside\" } */\n+    }\n+    #pragma omp section\n+    #pragma omp target data\n+    {\n+      #pragma omp cancel parallel\t\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancel for\t\t\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancel sections\t\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancel taskgroup\t\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancellation point parallel\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancellation point for\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancellation point sections\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancellation point taskgroup\t/* { dg-error \"not closely nested inside\" } */\n+    }\n+  }\n+  #pragma omp sections\n+  {\n+    #pragma omp target\n+    {\n+      #pragma omp cancel parallel\t\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancel for\t\t\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancel sections\t\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancel taskgroup\t\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancellation point parallel\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancellation point for\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancellation point sections\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancellation point taskgroup\t/* { dg-error \"not closely nested inside\" } */\n+    }\n+    #pragma omp section\n+    #pragma omp target\n+    {\n+      #pragma omp cancel parallel\t\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancel for\t\t\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancel sections\t\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancel taskgroup\t\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancellation point parallel\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancellation point for\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancellation point sections\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancellation point taskgroup\t/* { dg-error \"not closely nested inside\" } */\n+    }\n+  }\n+  #pragma omp task\n+  {\n+    #pragma omp cancel parallel\t\t\t/* { dg-error \"not closely nested inside\" } */\n+    #pragma omp cancel for\t\t\t/* { dg-error \"not closely nested inside\" } */\n+    #pragma omp cancel sections\t\t\t/* { dg-error \"not closely nested inside\" } */\n+    #pragma omp cancel taskgroup\n+    #pragma omp cancellation point parallel\t/* { dg-error \"not closely nested inside\" } */\n+    #pragma omp cancellation point for\t\t/* { dg-error \"not closely nested inside\" } */\n+    #pragma omp cancellation point sections\t/* { dg-error \"not closely nested inside\" } */\n+    #pragma omp cancellation point taskgroup\n+    #pragma omp taskgroup\n+    {\n+      #pragma omp cancel parallel\t\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancel for\t\t\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancel sections\t\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancel taskgroup\t\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancellation point parallel\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancellation point for\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancellation point sections\t/* { dg-error \"not closely nested inside\" } */\n+      #pragma omp cancellation point taskgroup\t/* { dg-error \"not closely nested inside\" } */\n+    }\n+  }\n+}\n+\n+void\n+f3 (void)\n+{\n+  int i;\n+  #pragma omp for nowait\n+  for (i = 0; i < 10; i++)\n+    {\n+      #pragma omp cancel for\t\t/* { dg-warning \"nowait\" } */\n+    }\n+  #pragma omp sections nowait\n+  {\n+    {\n+      #pragma omp cancel sections\t/* { dg-warning \"nowait\" } */\n+    }\n+    #pragma omp section\n+    {\n+      #pragma omp cancel sections\t/* { dg-warning \"nowait\" } */\n+    }\n+  }\n+  #pragma omp for ordered\n+  for (i = 0; i < 10; i++)\n+    {\n+      #pragma omp cancel for\t\t/* { dg-warning \"ordered\" } */\n+      #pragma omp ordered\n+      {\n+      }\n+    }\n+}"}, {"sha": "8a5850e45fe3f2abf909cc7f33bd1f7ef6adb05b", "filename": "gcc/testsuite/c-c++-common/gomp/depend-1.c", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdepend-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdepend-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdepend-1.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -0,0 +1,79 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp\" } */\n+\n+extern int a[][10], a2[][10];\n+int b[10], c[10][2], d[10], e[10], f[10];\n+int b2[10], c2[10][2], d2[10], e2[10], f2[10];\n+int k[10], l[10], m[10], n[10], o;\n+int *p;\n+void bar (void);\n+int t[10];\n+#pragma omp threadprivate (t)\n+\n+void\n+foo (int g[3][10], int h[4][8], int i[2][10], int j[][9],\n+     int g2[3][10], int h2[4][8], int i2[2][10], int j2[][9])\n+{\n+  #pragma omp task depend(in: bar[2:5]) /* { dg-error \"is not a variable\" } */\n+    ;\n+  #pragma omp task depend(out: t[2:5])\n+    ;\n+  #pragma omp task depend(inout: k[0.5:]) /* { dg-error \"low bound \\[^\\n\\r]* of array section does not have integral type\" } */\n+    ;\n+  #pragma omp task depend(in: l[:7.5f]) /* { dg-error \"length \\[^\\n\\r]* of array section does not have integral type\" } */\n+    ;\n+  #pragma omp task depend(out: m[p:]) /* { dg-error \"low bound \\[^\\n\\r]* of array section does not have integral type\" } */\n+    ;\n+  #pragma omp task depend(inout: n[:p]) /* { dg-error \"length \\[^\\n\\r]* of array section does not have integral type\" } */\n+    ;\n+  #pragma omp task depend(in: o[2:5]) /* { dg-error \"does not have pointer or array type\" } */\n+    ;\n+  #pragma omp task depend(out: a[:][2:4]) /* { dg-error \"array type length expression must be specified\" } */\n+    ;\n+  #pragma omp task depend(inout: b[-1:]) /* { dg-error \"negative low bound in array section\" } */\n+    ;\n+  #pragma omp task depend(inout: c[:-3][1:1]) /* { dg-error \"negative length in array section\" } */\n+    ;\n+  #pragma omp task depend(in: d[11:]) /* { dg-error \"low bound \\[^\\n\\r]* above array section size\" } */\n+    ;\n+  #pragma omp task depend(out: e[:11]) /* { dg-error \"length \\[^\\n\\r]* above array section size\" } */\n+    ;\n+  #pragma omp task depend(out: f[1:10]) /* { dg-error \"high bound \\[^\\n\\r]* above array section size\" } */\n+    ;\n+  #pragma omp task depend(in: g[:][2:4]) /* { dg-error \"for pointer type length expression must be specified\" } */\n+    ;\n+  #pragma omp task depend(in: h[2:2][-1:]) /* { dg-error \"negative low bound in array section\" } */\n+    ;\n+  #pragma omp task depend(inout: h[:1][:-3]) /* { dg-error \"negative length in array section\" } */\n+    ;\n+  #pragma omp task depend(out: i[:1][11:]) /* { dg-error \"low bound \\[^\\n\\r]* above array section size\" } */\n+    ;\n+  #pragma omp task depend(in: j[3:4][:10]) /* { dg-error \"length \\[^\\n\\r]* above array section size\" } */\n+    ;\n+  #pragma omp task depend(out: j[30:10][5:5]) /* { dg-error \"high bound \\[^\\n\\r]* above array section size\" } */\n+    ;\n+  #pragma omp task depend(out: a2[:3][2:4])\n+    ;\n+  #pragma omp task depend(inout: b2[0:])\n+    ;\n+  #pragma omp task depend(inout: c2[:3][1:1])\n+    ;\n+  #pragma omp task depend(in: d2[9:])\n+    ;\n+  #pragma omp task depend(out: e2[:10])\n+    ;\n+  #pragma omp task depend(out: f2[1:9])\n+    ;\n+  #pragma omp task depend(in: g2[:2][2:4])\n+    ;\n+  #pragma omp task depend(in: h2[2:2][0:])\n+    ;\n+  #pragma omp task depend(inout: h2[:1][:3])\n+    ;\n+  #pragma omp task depend(out: i2[:1][9:])\n+    ;\n+  #pragma omp task depend(in: j2[3:4][:9])\n+    ;\n+  #pragma omp task depend(out: j2[30:10][5:4])\n+    ;\n+}"}, {"sha": "99bf8ae1b832e455128df3e7987e6b685004bc6b", "filename": "gcc/testsuite/c-c++-common/gomp/depend-2.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdepend-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdepend-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdepend-2.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp\" } */\n+\n+void bar (int a[10][10][10]);\n+void\n+foo (int a[10][10][10], int **b)\n+{\n+  int c[10][10][10];\n+  #pragma omp task depend(out: a[2:4][3:][:7], b[1:7][2:8])\n+    bar (a);\n+  int i = 1, j = 3, k = 2, l = 6;\n+  #pragma omp task depend(in: a[++i:++j][++k:][:++l])\n+    bar (a);\n+  #pragma omp task depend(out: a[7:2][:][:], c[5:2][:][:])\n+  {\n+    bar (c);\n+    bar (a);\n+  }\n+}"}, {"sha": "694d88cc795b73699ba83ce92f2a3dbd9c030846", "filename": "gcc/testsuite/c-c++-common/gomp/map-1.c", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fmap-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fmap-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fmap-1.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -0,0 +1,103 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp\" } */\n+\n+extern int a[][10], a2[][10];\n+int b[10], c[10][2], d[10], e[10], f[10];\n+int b2[10], c2[10][2], d2[10], e2[10], f2[10];\n+int k[10], l[10], m[10], n[10], o;\n+int *p;\n+int **q;\n+int r[4][4][4][4][4];\n+int t[10];\n+#pragma omp threadprivate (t)\n+#pragma omp declare target\n+void bar (int *);\n+#pragma omp end declare target\n+\n+void\n+foo (int g[3][10], int h[4][8], int i[2][10], int j[][9],\n+     int g2[3][10], int h2[4][8], int i2[2][10], int j2[][9])\n+{\n+  #pragma omp target map(to: bar[2:5]) /* { dg-error \"is not a variable\" } */\n+    ;\n+  #pragma omp target map(from: t[2:5]) /* { dg-error \"is threadprivate variable\" } */\n+    ;\n+  #pragma omp target map(tofrom: k[0.5:]) /* { dg-error \"low bound \\[^\\n\\r]* of array section does not have integral type\" } */\n+    ;\n+  #pragma omp target map(from: l[:7.5f]) /* { dg-error \"length \\[^\\n\\r]* of array section does not have integral type\" } */\n+    ;\n+  #pragma omp target map(to: m[p:]) /* { dg-error \"low bound \\[^\\n\\r]* of array section does not have integral type\" } */\n+    ;\n+  #pragma omp target map(tofrom: n[:p]) /* { dg-error \"length \\[^\\n\\r]* of array section does not have integral type\" } */\n+    ;\n+  #pragma omp target map(to: o[2:5]) /* { dg-error \"does not have pointer or array type\" } */\n+    ;\n+  #pragma omp target map(to: a[:][:]) /* { dg-error \"array type length expression must be specified\" } */\n+    bar (&a[0][0]); /* { dg-error \"referenced in target region does not have a mappable type\" } */\n+  #pragma omp target map(tofrom: b[-1:]) /* { dg-error \"negative low bound in array section\" } */\n+    bar (b);\n+  #pragma omp target map(tofrom: c[:-3][:]) /* { dg-error \"negative length in array section\" } */\n+    bar (&c[0][0]);\n+  #pragma omp target map(from: d[11:]) /* { dg-error \"low bound \\[^\\n\\r]* above array section size\" } */\n+    bar (d);\n+  #pragma omp target map(to: e[:11]) /* { dg-error \"length \\[^\\n\\r]* above array section size\" } */\n+    bar (e);\n+  #pragma omp target map(to: f[1:10]) /* { dg-error \"high bound \\[^\\n\\r]* above array section size\" } */\n+    bar (f);\n+  #pragma omp target map(from: g[:][0:10]) /* { dg-error \"for pointer type length expression must be specified\" } */\n+    bar (&g[0][0]);\n+  #pragma omp target map(from: h[2:1][-1:]) /* { dg-error \"negative low bound in array section\" } */\n+    bar (&h[0][0]);\n+  #pragma omp target map(tofrom: h[:1][:-3]) /* { dg-error \"negative length in array section\" } */\n+    bar (&h[0][0]);\n+  #pragma omp target map(i[:1][11:]) /* { dg-error \"low bound \\[^\\n\\r]* above array section size\" } */\n+    bar (&i[0][0]);\n+  #pragma omp target map(from: j[3:1][:10]) /* { dg-error \"length \\[^\\n\\r]* above array section size\" } */\n+    bar (&j[0][0]);\n+  #pragma omp target map(to: j[30:1][5:5]) /* { dg-error \"high bound \\[^\\n\\r]* above array section size\" } */\n+    bar (&j[0][0]);\n+  #pragma omp target map(to: a2[:1][2:4])\n+    bar (&a2[0][0]);\n+  #pragma omp target map(a2[3:5][:])\n+    bar (&a2[0][0]);\n+  #pragma omp target map(to: a2[3:5][:10])\n+    bar (&a2[0][0]);\n+  #pragma omp target map(tofrom: b2[0:])\n+    bar (b2);\n+  #pragma omp target map(tofrom: c2[:3][:])\n+    bar (&c2[0][0]);\n+  #pragma omp target map(from: d2[9:])\n+    bar (d2);\n+  #pragma omp target map(to: e2[:10])\n+    bar (e2);\n+  #pragma omp target map(to: f2[1:9])\n+    bar (f2);\n+  #pragma omp target map(g2[:1][2:4])\n+    bar (&g2[0][0]);\n+  #pragma omp target map(from: h2[2:2][0:])\n+    bar (&h2[0][0]);\n+  #pragma omp target map(tofrom: h2[:1][:3])\n+    bar (&h2[0][0]);\n+  #pragma omp target map(to: i2[:1][9:])\n+    bar (&i2[0][0]);\n+  #pragma omp target map(from: j2[3:4][:9])\n+    bar (&j2[0][0]);\n+  #pragma omp target map(to: j2[30:1][5:4])\n+    bar (&j2[0][0]);\n+  #pragma omp target map(q[1:2])\n+    ;\n+  #pragma omp target map(tofrom: q[3:5][:10]) /* { dg-error \"array section is not contiguous\" } */\n+    ;\n+  #pragma omp target map(r[3:][2:1][1:2])\n+    ;\n+  #pragma omp target map(r[3:][2:1][1:2][:][0:4])\n+    ;\n+  #pragma omp target map(r[3:][2:1][1:2][1:][0:4]) /* { dg-error \"array section is not contiguous\" } */\n+    ;\n+  #pragma omp target map(r[3:][2:1][1:2][:3][0:4]) /* { dg-error \"array section is not contiguous\" } */\n+    ;\n+  #pragma omp target map(r[3:][2:1][1:2][:][1:]) /* { dg-error \"array section is not contiguous\" } */\n+    ;\n+  #pragma omp target map(r[3:][2:1][1:2][:][:3]) /* { dg-error \"array section is not contiguous\" } */\n+    ;\n+}"}, {"sha": "355ca4008bfcc20008bc7f792c4f3b7fc233175a", "filename": "gcc/testsuite/c-c++-common/gomp/pr58472.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fpr58472.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fpr58472.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fpr58472.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -0,0 +1,16 @@\n+/* PR tree-optimization/58472 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -Wall -fopenmp\" } */\n+\n+float a[1024], b[1024];\n+\n+float\n+foo ()\n+{\n+  float s = 0.f;\n+  unsigned int i;\n+#pragma omp simd reduction(+:s)\n+  for (i = 0; i < 1024; ++i)\n+    s += a[i] * b[i];\n+  return s;\n+}"}, {"sha": "8c8ab91f7f1c0df1d6e422a572398be37862296d", "filename": "gcc/testsuite/c-c++-common/gomp/sections1.c", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fsections1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fsections1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fsections1.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -0,0 +1,73 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp\" } */\n+\n+void bar (int);\n+\n+void\n+foo ()\n+{\n+  #pragma omp sections\n+  {\n+    bar (1);\n+    #pragma omp section\n+    {\n+      bar (2);\n+    }\n+  }\n+  #pragma omp sections\n+  {\n+    #pragma omp section\n+    bar (3);\n+    #pragma omp section\n+    {\n+      bar (4);\n+      bar (5);\n+    }\n+  }\n+  #pragma omp sections\n+  {\n+    {\n+      bar (6);\n+      bar (7);\n+    }\n+    #pragma omp section\n+    bar (8);\n+  }\n+  #pragma omp sections\n+  {\n+    #pragma omp section\n+    {\n+      bar (9);\n+    }\n+    #pragma omp section\n+    bar (10);\n+    #pragma omp section\n+    bar (11);\n+  }\n+  #pragma omp sections\n+  {\n+  }\t\t\t\t/* { dg-error \"expression before\" } */\n+  #pragma omp sections\n+  {\n+    bar (12);\n+    bar (13);\t\t\t/* { dg-error \"pragma omp section\" } */\n+    #pragma omp section\n+    bar (14);\n+  }\n+  #pragma omp sections\n+  {\n+    #pragma omp section\n+  }\t\t\t\t/* { dg-error \"expression before\" } */\n+  #pragma omp sections\n+  {\n+    bar (15);\n+    #pragma omp section\n+    bar (16);\n+    bar (17);\t\t\t/* { dg-error \"pragma omp section\" } */\n+  }\n+  #pragma omp sections\n+  {\n+    bar (18);\n+    #pragma omp section\n+  }\t\t\t\t/* { dg-error \"expression before\" } */\n+}"}, {"sha": "29e464ca035bd6e92420c8f7653efd6cc905261a", "filename": "gcc/testsuite/c-c++-common/gomp/simd1.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fsimd1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fsimd1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fsimd1.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp\" } */\n+/* { dg-additional-options \"-std=c99\" { target c } } */\n+\n+extern int a[1024], b[1024], k, l, m;\n+\n+void\n+foo ()\n+{\n+  int i;\n+  #pragma omp simd safelen(16) aligned(a, b : 32)\n+  for (i = 0; i < 1024; i++)\n+    a[i] *= b[i];\n+}\n+\n+void\n+bar (int *p)\n+{\n+  int i;\n+  #pragma omp simd safelen(16) aligned(a, p : 32) linear(k, l : m + 1)\n+  for (i = 0; i < 1024; i++)\n+    a[i] *= p[i], k += m + 1;\n+}\n+\n+void\n+baz (int *p)\n+{\n+  #pragma omp simd safelen(16) aligned(a, p : 32) linear(k, l : m + 1)\n+  for (int i = 0; i < 1024; i++)\n+    a[i] *= p[i], k += m + 1;\n+}"}, {"sha": "dda9c62d6d131e18d24d7125f24a6cb9167d4263", "filename": "gcc/testsuite/c-c++-common/gomp/simd2.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fsimd2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fsimd2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fsimd2.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp\" } */\n+/* { dg-additional-options \"-std=c99\" { target c } } */\n+\n+extern int a[13][13][13][13], k, l, m;\n+\n+void\n+foo (int *q, float *p)\n+{\n+  int i, j, n, o;\n+#pragma omp simd collapse (4) linear(k : m + 1) aligned(p, q)\n+  for (i = 0; i < 13; i++)\n+    for (j = 0; j < 13; j++)\n+      for (n = 0; n < 13; n++)\n+\tfor (o = 0; o < 13; o += 2)\n+\t  q[k] *= p[k] + 7 * i + 14 * j + 21 * n + 28 * o, k += m + 1;\n+}\n+\n+void\n+bar (float *p)\n+{\n+  int i, j, n, o;\n+#pragma omp simd collapse (4) linear(k : m + 1)\n+  for (i = 0; i < 13; i++)\n+    for (j = 0; j < 13; j++)\n+      for (n = 0; n < 13; n++)\n+\tfor (o = 0; o < 13; o += 2)\n+\t  a[i][j][n][o] *= p[k], k += m + 1;\n+}"}, {"sha": "e8270fc452131c1493f248f544b6f36230fe5f5b", "filename": "gcc/testsuite/c-c++-common/gomp/simd3.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fsimd3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fsimd3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fsimd3.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp\" } */\n+/* { dg-additional-options \"-std=c99\" { target c } } */\n+\n+extern int a[13*13*13*13*2], b[1024], *k, l, m;\n+\n+void\n+foo (int *q, float *p)\n+{\n+  int *i, *j, *n, *o;\n+#pragma omp simd collapse (4) linear(k : m + 1) aligned(p, q)\n+  for (i = &a[0]; i < &a[13*13*13*13*2]; i += 13*13*13*2)\n+    for (j = &a[0]; j < &a[13*13*13*2]; j += 13*13*2)\n+      for (n = &a[0]; n < &a[13*13*2]; n += 13*2)\n+\tfor (o = &a[0]; o < &a[13*2]; o += 2)\n+\t  q[k - &a[0]] *= p[k - &a[0]] + 7 * (i-&a[0]) + 14 * (j-&a[0]) + 21 * (n-&a[0]) + 28 * (o-&a[0]), k += m + 1;\n+}\n+\n+void\n+bar ()\n+{\n+  int *i;\n+  #pragma omp simd safelen(16) aligned(a, b : 32)\n+  for (i = &a[0]; i < &a[1024]; i++)\n+    *i *= b[i - &a[0]];\n+}"}, {"sha": "37901b6a07f240d99ab427dc32ce10861ee8bb49", "filename": "gcc/testsuite/c-c++-common/gomp/simd4.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fsimd4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fsimd4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fsimd4.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp\" } */\n+/* { dg-additional-options \"-std=c99\" { target c } } */\n+\n+struct S *p;\t/* { dg-error \"forward declaration\" \"\" { target c++ } } */\n+float f;\n+int j;\n+\n+void\n+foo (void)\n+{\n+#pragma omp simd linear(p) linear(f : 1)\n+  for (int i = 0; i < 10; i++)\n+    ;\n+#pragma omp simd linear(j : 7.0)\t/* { dg-error \"step expression must be integral\" } */\n+  for (int i = 0; i < 10; i++)\n+    ;\n+}\n+\n+/* { dg-error \"linear clause applied to\" \"\" { target *-*-* } 12 } */\n+/* { dg-error \"(incomplete|undefined) type\" \"\" { target *-*-* } 12 } */"}, {"sha": "a57896d870469a76d34f839a8103c7734050aa9b", "filename": "gcc/testsuite/c-c++-common/gomp/simd5.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fsimd5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fsimd5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fsimd5.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp\" } */\n+/* { dg-additional-options \"-std=c99\" { target c } } */\n+\n+void baz (void) __attribute__((noreturn));\n+\n+void\n+foo (int x)\n+{\n+  if (x)\n+  #pragma omp simd\n+    for (int i = 0; i < 10; i++)\n+      baz ();\n+#pragma omp simd collapse(3)\n+  for (int i = 0; i < 10; i++)\n+    for (int j = 0; j < 10; j++)\n+      for (int k = 0; k < 10; k++)\n+\tbaz ();\n+}"}, {"sha": "c080a8804cf07893392ab381515d3e93acb78e8b", "filename": "gcc/testsuite/c-c++-common/gomp/single1.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fsingle1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fsingle1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fsingle1.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp\" } */\n+\n+void\n+foo (int i)\n+{\n+  #pragma omp single copyprivate (i)\n+    ;\n+  #pragma omp single nowait\n+    ;\n+  #pragma omp single copyprivate (i) nowait\t/* { dg-error \"clause must not be used together with\" } */\n+    ;\n+  #pragma omp single nowait copyprivate (i)\t/* { dg-error \"clause must not be used together with\" } */\n+    ;\n+}"}, {"sha": "86af0404ab31aba51ac04e5ba3f428b8dece0ee9", "filename": "gcc/testsuite/g++.dg/gomp/block-0.C", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fblock-0.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fblock-0.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fblock-0.C?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -22,8 +22,10 @@ void foo()\n     bar ();\n   #pragma omp parallel sections\n     {\n-      bar ();\n-      bar ();\n+      {\n+\tbar ();\n+\tbar ();\n+      }\n     #pragma omp section\n       bar ();\n     }"}, {"sha": "ff281752843c89c68936edf7768aedcc4b3a1e8b", "filename": "gcc/testsuite/g++.dg/gomp/block-3.C", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fblock-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fblock-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fblock-3.C?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -35,8 +35,10 @@ void foo()\n \n   #pragma omp sections\n     {\n-      goto ok1;\n-      ok1:;\n+      {\n+\tgoto ok1;\n+\tok1:;\n+      }\n \n     #pragma omp section\n       for (i = 0; i < 10; ++i)"}, {"sha": "1a20440d7c24316d81bb40269ef55633b1147bc5", "filename": "gcc/testsuite/g++.dg/gomp/clause-3.C", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fclause-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fclause-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fclause-3.C?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -11,7 +11,7 @@ int t;\n void\n foo (int x)\n {\n-  char *p;\n+  char *pp;\n   struct S { int i; int j; } s;\n   char a[32];\n   double d;\n@@ -42,18 +42,18 @@ foo (int x)\n     ;\n #pragma omp p firstprivate (bar) // { dg-error \"is not a variable\" }\n     ;\n-#pragma omp p reduction (+:p) // { dg-error \"has invalid type for\" }\n+#pragma omp p reduction (+:pp) // { dg-error \"user defined reduction not found for\" }\n     ;\n-#pragma omp p reduction (*:s) // { dg-error \"has invalid type for\" }\n+#pragma omp p reduction (*:s) // { dg-error \"user defined reduction not found for\" }\n     ;\n #pragma omp p reduction (-:a) // { dg-error \"has invalid type for\" }\n     ;\n   d = 0;\n #pragma omp p reduction (*:d)\n     ;\n-#pragma omp p reduction (|:d) // { dg-error \"has invalid type for\" }\n+#pragma omp p reduction (|:d) // { dg-error \"user defined reduction not found for\" }\n     ;\n-#pragma omp p reduction (&&:d) // { dg-error \"has invalid type for\" }\n+#pragma omp p reduction (&&:d) // { dg-error \"user defined reduction not found for\" }\n     ;\n #pragma omp p copyin (d) // { dg-error \"must be 'threadprivate'\" }\n     ;"}, {"sha": "1fd88b7efab5bd2a59c1b36c96d1fc57ae473d6e", "filename": "gcc/testsuite/g++.dg/gomp/declare-simd-1.C", "status": "added", "additions": 243, "deletions": 0, "changes": 243, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fdeclare-simd-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fdeclare-simd-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fdeclare-simd-1.C?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -0,0 +1,243 @@\n+// Test parsing of #pragma omp declare simd\n+// { dg-do compile }\n+\n+#pragma omp declare simd uniform (a) aligned (b : 8 * sizeof (int)) \\\n+\t    linear (c : 4) simdlen (8) notinbranch\n+#pragma omp declare simd uniform (c) aligned (b : 4 * sizeof (int)) linear (a \\\n+\t\t\t\t\t\t\t\t\t    : 4) simdlen (4) inbranch\n+int f1 (int a, int *b, int c);\n+\n+#pragma omp declare simd uniform (a) aligned (b : 8 * sizeof (int)) linear (c : 4) simdlen (8)\n+int f2 (int a, int *b, int c)\n+{\n+  return a + *b + c;\n+}\n+\n+#pragma omp declare simd uniform (c) aligned (b : 4 * sizeof (int)) linear (a : 4) simdlen (4)\n+template <typename T>\n+T f3 (int a, int *b, T c);\n+\n+template <>\n+int f3 (int, int *, int);\n+\n+#pragma omp declare simd uniform (c) aligned (b : 4 * sizeof (int)) linear (a : 4) notinbranch simdlen (4)\n+template <typename T>\n+int f4 (int a, int *b, T c)\n+{\n+  return a + *b + c;\n+}\n+\n+template <>\n+int f4 (int, int *, int);\n+\n+template <typename T>\n+int f5 (int a, int *b, T c);\n+\n+#pragma omp declare simd uniform (c) aligned (b : 4 * sizeof (int)) linear (a : 4) simdlen (4)\n+template <>\n+int f5 (int a, int *b, int c);\n+\n+template <int N>\n+int f6 (int a, int *b, int c);\n+\n+#pragma omp declare simd uniform (c) aligned (b : 4 * sizeof (int)) linear (a : 4) inbranch simdlen (4)\n+template <>\n+int f6<3> (int a, int *b, int c);\n+\n+#pragma omp declare simd uniform (a) aligned (b : 8 * sizeof (long long)) linear (c : 4) simdlen (8)\n+__extension__\n+long long f7 (long long a, long long *b, long long c);\n+\n+#pragma omp declare simd uniform (a) aligned (b : 8 * sizeof (int)) linear (c : 4) notinbranch simdlen (8)\n+extern \"C\"\n+int f8 (int a, int *b, int c);\n+\n+extern \"C\"\n+{\n+  #pragma omp declare simd\n+  int f9 (int a, int *b, int c);\n+}\n+\n+namespace N1\n+{\n+  namespace N2\n+  {\n+    #pragma omp declare simd simdlen (2) aligned (b : sizeof (long long) * 2)\n+    __extension__ long long\n+    f10 (long long *b)\n+    {\n+      return *b;\n+    }\n+  }\n+}\n+\n+struct A\n+{\n+  #pragma omp declare simd uniform (a) aligned (b : 8 * sizeof (int)) linear (c : 4) simdlen (8)\n+  #pragma omp declare simd uniform (c) aligned (b : 4 * sizeof (int)) linear (a : 4) simdlen (4)\n+  int f11 (int a, int *b, int c);\n+\n+  #pragma omp declare simd\n+  template <int N>\n+  int f12 (int a, int *b, int c);\n+\n+  #pragma omp declare simd uniform (a) aligned (b : 8 * sizeof (int)) linear (c : 4) notinbranch simdlen (8)\n+  #pragma omp declare simd uniform (c) aligned (b : 4 * sizeof (int)) linear (a : 4) simdlen (4) inbranch\n+  static int f13 (int a, int *b, int c);\n+\n+  #pragma omp declare simd uniform (a) aligned (b : 8 * sizeof (int)) linear (c : 4) simdlen (8)\n+  #pragma omp declare simd uniform (c) aligned (b : 4 * sizeof (int)) linear (a : 4) simdlen (4)\n+  int f14 (int a, int *b, int c) { return a + *b + c; }\n+\n+  #pragma omp declare simd\n+  template <int N>\n+  int f15 (int a, int *b, int c) { return a + *b + c; }\n+\n+  #pragma omp declare simd uniform (a) aligned (b : 8 * sizeof (int)) linear (c : 4) simdlen (8)\n+  #pragma omp declare simd uniform (c) aligned (b : 4 * sizeof (int)) linear (a : 4) simdlen (4)\n+  static int f16 (int a, int *b, int c) { return a + *b + c; }\n+};\n+\n+template <>\n+int A::f12<2> (int, int *, int);\n+\n+template <>\n+int A::f15<2> (int, int *, int);\n+\n+template <typename T>\n+struct B\n+{\n+  #pragma omp declare simd uniform (a) aligned (b : 8 * sizeof (int)) linear (c : 4) simdlen (8) notinbranch\n+  #pragma omp declare simd uniform (c) aligned (b : 4 * sizeof (int)) linear (a : 4) simdlen (4) inbranch\n+  int f17 (int a, int *b, int c);\n+\n+  #pragma omp declare simd\n+  template <int N>\n+  int f18 (int a, int *b, int c);\n+\n+  #pragma omp declare simd uniform (a) aligned (b : 8 * sizeof (int)) linear (c : 4) simdlen (8)\n+  #pragma omp declare simd uniform (c) aligned (b : 4 * sizeof (int)) linear (a : 4) simdlen (4)\n+  static int f19 (int a, int *b, int c);\n+\n+  #pragma omp declare simd uniform (a) aligned (b : 8 * sizeof (int)) linear (c : 4) simdlen (8)\n+  #pragma omp declare simd uniform (c) aligned (b : 4 * sizeof (int)) linear (a : 4) simdlen (4)\n+  int f20 (int a, int *b, int c) { return a + *b + c; }\n+\n+  #pragma omp declare simd\n+  template <int N>\n+  int f21 (int a, int *b, int c) { return a + *b + c; }\n+\n+  #pragma omp declare simd uniform (a) aligned (b : 8 * sizeof (int)) linear (c : 4) simdlen (8)\n+  #pragma omp declare simd uniform (c) aligned (b : 4 * sizeof (int)) linear (a : 4) simdlen (4)\n+  static int f22 (int a, int *b, int c) { return a + *b + c; }\n+\n+  template <int N>\n+  int f23 (int, int *, int);\n+\n+  template <int N>\n+  static int f24 (int, int *, int);\n+\n+  template <int N>\n+  int f25 (int, int *, int);\n+\n+  template <int N>\n+  static int f26 (int, int *, int);\n+};\n+\n+B <int> b;\n+\n+template <>\n+template <>\n+int B<int>::f18<0> (int, int *, int);\n+\n+template <>\n+template <>\n+int B<int>::f21<9> (int, int *, int);\n+\n+#pragma omp declare simd simdlen (8) aligned (b : 8 * sizeof (int)) uniform (a, c)\n+template <>\n+template <>\n+int B<int>::f23<7> (int a, int *b, int c);\n+\n+#pragma omp declare simd simdlen (4) aligned (b : 8 * sizeof (int)) linear (a, c : 2)\n+template <>\n+template <>\n+int B<int>::f24<-1> (int a, int *b, int c);\n+\n+#pragma omp declare simd simdlen (8) aligned (b : 8 * sizeof (int)) uniform (a, c)\n+template <>\n+template <>\n+int B<int>::f25<7> (int a, int *b, int c)\n+{\n+  return a + *b + c;\n+}\n+\n+#pragma omp declare simd simdlen (4) aligned (b : 8 * sizeof (int)) linear (a, c : 2)\n+template <>\n+template <>\n+int B<int>::f26<-1> (int a, int *b, int c)\n+{\n+  return a + *b + c;\n+}\n+\n+int\n+f27 (int x)\n+{\n+  #pragma omp declare simd simdlen (8) aligned (b : 8 * sizeof (int))\n+  extern int f28 (int a, int *b, int c);\n+  {\n+    x++;\n+    #pragma omp declare simd simdlen (4) linear (c)\n+    extern int f29 (int a, int *b, int c);\n+  }\n+  return x;\n+}\n+\n+#pragma omp declare simd simdlen (16)\n+int\n+f30 (int x)\n+{\n+  #pragma omp declare simd simdlen (8) aligned (b : 8 * sizeof (int))\n+  extern int f31 (int a, int *b, int c);\n+  return x;\n+}\n+\n+template <int N>\n+struct C\n+{\n+  #pragma omp declare simd simdlen (N) aligned (a : N * sizeof (int)) linear (c : N) notinbranch\n+  int f32 (int a, int *b, int c);\n+};\n+\n+C <2> c;\n+\n+int\n+f33 (int x)\n+{\n+  if (x)\n+    #pragma omp declare simd simdlen (8) aligned (b : 8 * sizeof (int))\n+    extern int f34 (int a, int *b, int c);\n+  while (x < 10)\n+    #pragma omp declare simd simdlen (8) aligned (b : 8 * sizeof (int))\n+    extern int f35 (int a, int *b, int c);\n+  return x;\n+}\n+\n+#pragma omp declare simd simdlen (N)\n+template <int N>\n+int f36 (int);\n+\n+struct D\n+{\n+  int d;\n+  #pragma omp declare simd simdlen (N) linear (a : sizeof (a) + sizeof (d) + sizeof (this) + sizeof (this->d))\n+  template <int N>\n+  int f37 (int a);\n+  int e;\n+};\n+\n+void\n+f38 (D &d)\n+{\n+  d.f37 <12> (6);\n+}"}, {"sha": "f64004fb012a03911c8e3bbc1e2f522630d848a2", "filename": "gcc/testsuite/g++.dg/gomp/declare-simd-2.C", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fdeclare-simd-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fdeclare-simd-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fdeclare-simd-2.C?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -0,0 +1,67 @@\n+// Test parsing of #pragma omp declare simd\n+// { dg-do compile }\n+\n+#pragma omp declare simd\n+int a;\t// { dg-error \"not immediately followed by function declaration or definition\" }\n+\n+#pragma omp declare simd\n+int fn1 (int a), fn2 (int a);\t// { dg-error \"not immediately followed by a single function declaration or definition\" }\n+\n+#pragma omp declare simd\n+int b, fn3 (int a);\t// { dg-error \"not immediately followed by function declaration or definition\" }\n+\n+#pragma omp declare simd linear (a)\n+int fn4 (int a), c;\t// { dg-error \"not immediately followed by function declaration or definition\" }\n+\n+#pragma omp declare simd\n+extern \"C\"\t\t// { dg-error \"not immediately followed by function declaration or definition\" }\n+{\n+  int fn5 (int a);\n+}\n+\n+#pragma omp declare simd // { dg-error \"not immediately followed by function declaration or definition\" }\n+namespace N1\n+{\n+  int fn6 (int a);\n+}\n+\n+#pragma omp declare simd simdlen (4)\n+struct A\n+{\t\t\t// { dg-error \"not immediately followed by function declaration or definition\" }\n+  int fn7 (int a);\n+};\n+\n+#pragma omp declare simd\n+template <typename T>\n+struct B\n+{\t\t\t// { dg-error \"not immediately followed by function declaration or definition\" }\n+  int fn8 (int a);\n+};\n+\n+struct C\n+{\n+#pragma omp declare simd // { dg-error \"not immediately followed by function declaration or definition\" }\n+  public:\t\t // { dg-error \"expected unqualified-id before\" }\n+    int fn9 (int a);\n+};\n+\n+int t;\n+\n+#pragma omp declare simd\n+#pragma omp declare simd\n+#pragma omp threadprivate(t)\t// { dg-error \"not immediately followed by function declaration or definition\" }\n+int fn10 (int a);\n+\n+#pragma omp declare simd inbranch notinbranch // { dg-error \"clause is incompatible with\" }\n+int fn11 (int);\n+\n+struct D\n+{\n+  int d;\n+  #pragma omp declare simd simdlen (N) linear (a : sizeof (e) + sizeof (this->e)) // { dg-error \"was not declared\" }\n+  template <int N>\n+  int fn12 (int a);\n+  int e;\n+};\n+\n+// { dg-error \"has no member\" \"\" { target *-*-* } 61 }"}, {"sha": "33027de552a8609e2595213190f6191add842af8", "filename": "gcc/testsuite/g++.dg/gomp/depend-1.C", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fdepend-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fdepend-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fdepend-1.C?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -0,0 +1,70 @@\n+// { dg-do compile }\n+// { dg-options \"-fopenmp\" }\n+\n+extern int a[][10], a2[][10];\n+int b[10], c[10][2], d[10], e[10], f[10];\n+int b2[10], c2[10][2], d2[10], e2[10], f2[10];\n+int k[10], l[10], m[10], n[10], o;\n+int *p;\n+void bar (void);\n+int t[10];\n+#pragma omp threadprivate (t)\n+\n+template <int N>\n+void\n+foo (int g[3][10], int h[4][8], int i[2][10], int j[][9],\n+     int g2[3][10], int h2[4][8], int i2[2][10], int j2[][9])\n+{\n+  #pragma omp task depend(out: t[2:5])\n+    ;\n+  #pragma omp task depend(inout: k[0.5:]) // { dg-error \"low bound \\[^\\n\\r]* of array section does not have integral type\" }\n+    ;\n+  #pragma omp task depend(in: l[:7.5f]) // { dg-error \"length \\[^\\n\\r]* of array section does not have integral type\" }\n+    ;\n+  #pragma omp task depend(out: m[p:]) // { dg-error \"low bound \\[^\\n\\r]* of array section does not have integral type\" }\n+    ;\n+  #pragma omp task depend(inout: n[:p]) // { dg-error \"length \\[^\\n\\r]* of array section does not have integral type\" }\n+    ;\n+  #pragma omp task depend(in: o[2:5]) // { dg-error \"does not have pointer or array type\" }\n+    ;\n+  #pragma omp task depend(out: a[:][2:4]) // { dg-error \"array type length expression must be specified\" }\n+    ;\n+  #pragma omp task depend(in: d[11:]) // { dg-error \"low bound \\[^\\n\\r]* above array section size\" }\n+    ;\n+  #pragma omp task depend(out: e[:11]) // { dg-error \"length \\[^\\n\\r]* above array section size\" }\n+    ;\n+  #pragma omp task depend(out: f[1:10]) // { dg-error \"high bound \\[^\\n\\r]* above array section size\" }\n+    ;\n+  #pragma omp task depend(in: g[:][2:4]) // { dg-error \"for pointer type length expression must be specified\" }\n+    ;\n+  #pragma omp task depend(out: i[:1][11:]) // { dg-error \"low bound \\[^\\n\\r]* above array section size\" }\n+    ;\n+  #pragma omp task depend(in: j[3:4][:10]) // { dg-error \"length \\[^\\n\\r]* above array section size\" }\n+    ;\n+  #pragma omp task depend(out: j[30:10][5:5]) // { dg-error \"high bound \\[^\\n\\r]* above array section size\" }\n+    ;\n+  #pragma omp task depend(out: a2[:3][2:4])\n+    ;\n+  #pragma omp task depend(inout: b2[0:])\n+    ;\n+  #pragma omp task depend(inout: c2[:3][1:1])\n+    ;\n+  #pragma omp task depend(in: d2[9:])\n+    ;\n+  #pragma omp task depend(out: e2[:10])\n+    ;\n+  #pragma omp task depend(out: f2[1:9])\n+    ;\n+  #pragma omp task depend(in: g2[:2][2:4])\n+    ;\n+  #pragma omp task depend(in: h2[2:2][0:])\n+    ;\n+  #pragma omp task depend(inout: h2[:1][:3])\n+    ;\n+  #pragma omp task depend(out: i2[:1][9:])\n+    ;\n+  #pragma omp task depend(in: j2[3:4][:9])\n+    ;\n+  #pragma omp task depend(out: j2[30:10][5:4])\n+    ;\n+}"}, {"sha": "c3f19658c5a98fda64b599d940d34279b09c2546", "filename": "gcc/testsuite/g++.dg/gomp/depend-2.C", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fdepend-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fdepend-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fdepend-2.C?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -0,0 +1,87 @@\n+// { dg-do compile }\n+// { dg-options \"-fopenmp\" }\n+\n+extern int a[][10], a2[][10];\n+int b[10], c[10][2], d[10], e[10], f[10];\n+int b2[10], c2[10][2], d2[10], e2[10], f2[10];\n+int k[10], l[10], m[10], n[10], o;\n+int *p;\n+void bar (void);\n+int t[10];\n+#pragma omp threadprivate (t)\n+\n+template <int N>\n+void\n+foo (int g[3][10], int h[4][8], int i[2][10], int j[][9],\n+     int g2[3][10], int h2[4][8], int i2[2][10], int j2[][9])\n+{\n+  #pragma omp task depend(in: bar[2:5]) // { dg-error \"is not a variable\" }\n+    ;\n+  #pragma omp task depend(out: t[2:5])\n+    ;\n+  #pragma omp task depend(inout: k[0.5:]) // { dg-error \"low bound \\[^\\n\\r]* of array section does not have integral type\" }\n+    ;\n+  #pragma omp task depend(in: l[:7.5f]) // { dg-error \"length \\[^\\n\\r]* of array section does not have integral type\" }\n+    ;\n+  #pragma omp task depend(out: m[p:]) // { dg-error \"low bound \\[^\\n\\r]* of array section does not have integral type\" }\n+    ;\n+  #pragma omp task depend(inout: n[:p]) // { dg-error \"length \\[^\\n\\r]* of array section does not have integral type\" }\n+    ;\n+  #pragma omp task depend(in: o[2:5]) // { dg-error \"does not have pointer or array type\" }\n+    ;\n+  #pragma omp task depend(out: a[:][2:4]) // { dg-error \"array type length expression must be specified\" }\n+    ;\n+  #pragma omp task depend(inout: b[-1:]) // { dg-error \"negative low bound in array section\" }\n+    ;\n+  #pragma omp task depend(inout: c[:-3][1:1]) // { dg-error \"negative length in array section\" }\n+    ;\n+  #pragma omp task depend(in: d[11:]) // { dg-error \"low bound \\[^\\n\\r]* above array section size\" }\n+    ;\n+  #pragma omp task depend(out: e[:11]) // { dg-error \"length \\[^\\n\\r]* above array section size\" }\n+    ;\n+  #pragma omp task depend(out: f[1:10]) // { dg-error \"high bound \\[^\\n\\r]* above array section size\" }\n+    ;\n+  #pragma omp task depend(in: g[:][2:4]) // { dg-error \"for pointer type length expression must be specified\" }\n+    ;\n+  #pragma omp task depend(in: h[2:2][-1:]) // { dg-error \"negative low bound in array section\" }\n+    ;\n+  #pragma omp task depend(inout: h[:1][:-3]) // { dg-error \"negative length in array section\" }\n+    ;\n+  #pragma omp task depend(out: i[:1][11:]) // { dg-error \"low bound \\[^\\n\\r]* above array section size\" }\n+    ;\n+  #pragma omp task depend(in: j[3:4][:10]) // { dg-error \"length \\[^\\n\\r]* above array section size\" }\n+    ;\n+  #pragma omp task depend(out: j[30:10][5:5]) // { dg-error \"high bound \\[^\\n\\r]* above array section size\" }\n+    ;\n+  #pragma omp task depend(out: a2[:3][2:4])\n+    ;\n+  #pragma omp task depend(inout: b2[0:])\n+    ;\n+  #pragma omp task depend(inout: c2[:3][1:1])\n+    ;\n+  #pragma omp task depend(in: d2[9:])\n+    ;\n+  #pragma omp task depend(out: e2[:10])\n+    ;\n+  #pragma omp task depend(out: f2[1:9])\n+    ;\n+  #pragma omp task depend(in: g2[:2][2:4])\n+    ;\n+  #pragma omp task depend(in: h2[2:2][0:])\n+    ;\n+  #pragma omp task depend(inout: h2[:1][:3])\n+    ;\n+  #pragma omp task depend(out: i2[:1][9:])\n+    ;\n+  #pragma omp task depend(in: j2[3:4][:9])\n+    ;\n+  #pragma omp task depend(out: j2[30:10][5:4])\n+    ;\n+}\n+\n+void\n+baz (int g[3][10], int h[4][8], int i[2][10], int j[][9],\n+     int g2[3][10], int h2[4][8], int i2[2][10], int j2[][9])\n+{\n+  foo<0> (g, h, i, j, g2, h2, i2, j2);\n+}"}, {"sha": "b6ed4f89cd8cebf50f82cd0b1d522b1fef83fd6f", "filename": "gcc/testsuite/g++.dg/gomp/target-1.C", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftarget-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftarget-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftarget-1.C?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -0,0 +1,32 @@\n+// { dg-do compile }\n+\n+void\n+foo (int x)\n+{\n+  bad1:\t\t\t\t// { dg-error \"jump to label\" }\n+  #pragma omp target\n+    goto bad1;\t\t\t// { dg-error \"from here|exits OpenMP\" }\n+\n+  goto bad2;\t\t\t// { dg-error \"from here\" }\n+  #pragma omp target\n+    {\n+      bad2: ;\t\t\t// { dg-error \"jump to label|enters OpenMP\" }\n+    }\n+\n+  #pragma omp target\n+    {\n+      int i;\n+      goto ok1;\n+      for (i = 0; i < 10; ++i)\n+\t{ ok1: break; }\n+    }\n+\n+  switch (x)\n+  {\n+  #pragma omp target\n+    { case 0:; }\t\t// { dg-error \"jump|enters\" }\n+  }\n+}\n+\n+// { dg-error \"invalid branch to/from an OpenMP structured block\" \"\" { target *-*-* } 8 }\n+// { dg-error \"invalid entry to OpenMP structured block\" \"\" { target *-*-* } 10 }"}, {"sha": "6a14f53cff61061f66f5ecd43f7d1f899f5c8c34", "filename": "gcc/testsuite/g++.dg/gomp/target-2.C", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftarget-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftarget-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftarget-2.C?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -0,0 +1,32 @@\n+// { dg-do compile }\n+\n+void\n+foo (int x, int y)\n+{\n+  bad1:\t\t\t\t// { dg-error \"jump to label\" }\n+  #pragma omp target data map(tofrom: y)\n+    goto bad1;\t\t\t// { dg-error \"from here|exits OpenMP\" }\n+\n+  goto bad2;\t\t\t// { dg-error \"from here\" }\n+  #pragma omp target data map(tofrom: y)\n+    {\n+      bad2: ;\t\t\t// { dg-error \"jump to label|enters OpenMP\" }\n+    }\n+\n+  #pragma omp target data map(tofrom: y)\n+    {\n+      int i;\n+      goto ok1;\n+      for (i = 0; i < 10; ++i)\n+\t{ ok1: break; }\n+    }\n+\n+  switch (x)\n+  {\n+  #pragma omp target data map(tofrom: y)\n+    { case 0:; }\t\t// { dg-error \"jump|enters\" }\n+  }\n+}\n+\n+// { dg-error \"invalid branch to/from an OpenMP structured block\" \"\" { target *-*-* } 8 }\n+// { dg-error \"invalid entry to OpenMP structured block\" \"\" { target *-*-* } 10 }"}, {"sha": "dcab0bb646699c8c842d2880afc974142e3a7be1", "filename": "gcc/testsuite/g++.dg/gomp/taskgroup-1.C", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftaskgroup-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftaskgroup-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftaskgroup-1.C?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -0,0 +1,32 @@\n+// { dg-do compile }\n+\n+void\n+foo (int x)\n+{\n+  bad1:\t\t\t\t// { dg-error \"jump to label\" }\n+  #pragma omp taskgroup\n+    goto bad1;\t\t\t// { dg-error \"from here|exits OpenMP\" }\n+\n+  goto bad2;\t\t\t// { dg-error \"from here\" }\n+  #pragma omp taskgroup\n+    {\n+      bad2: ;\t\t\t// { dg-error \"jump to label|enters OpenMP\" }\n+    }\n+\n+  #pragma omp taskgroup\n+    {\n+      int i;\n+      goto ok1;\n+      for (i = 0; i < 10; ++i)\n+\t{ ok1: break; }\n+    }\n+\n+  switch (x)\n+  {\n+  #pragma omp taskgroup\n+    { case 0:; }\t\t// { dg-error \"jump|enters\" }\n+  }\n+}\n+\n+// { dg-error \"invalid branch to/from an OpenMP structured block\" \"\" { target *-*-* } 8 }\n+// { dg-error \"invalid entry to OpenMP structured block\" \"\" { target *-*-* } 10 }"}, {"sha": "ce40b55ca15d8f4f5c64fac60aba9188a64a3396", "filename": "gcc/testsuite/g++.dg/gomp/teams-1.C", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fteams-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fteams-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fteams-1.C?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -0,0 +1,66 @@\n+// { dg-do compile }\n+\n+void\n+foo (int x)\n+{\n+  bad1:\t\t\t\t// { dg-error \"jump to label\" }\n+  #pragma omp target teams\n+    goto bad1;\t\t\t// { dg-error \"from here|exits OpenMP\" }\n+\n+  goto bad2;\t\t\t// { dg-error \"from here\" }\n+  #pragma omp target teams\n+    {\n+      bad2: ;\t\t\t// { dg-error \"jump to label|enters OpenMP\" }\n+    }\n+\n+  #pragma omp target teams\n+    {\n+      int i;\n+      goto ok1;\n+      for (i = 0; i < 10; ++i)\n+\t{ ok1: break; }\n+    }\n+\n+  switch (x)\n+  {\n+  #pragma omp target teams\n+    { case 0:; }\t\t// { dg-error \"jump|enters\" }\n+  }\n+}\n+\n+void\n+bar (int x)\n+{\n+  bad1:\t\t\t\t// { dg-error \"jump to label\" }\n+  #pragma omp target\n+  #pragma omp teams\n+    goto bad1;\t\t\t// { dg-error \"from here|exits OpenMP\" }\n+\n+  goto bad2;\t\t\t// { dg-error \"from here\" }\n+  #pragma omp target\n+  #pragma omp teams\n+    {\n+      bad2: ;\t\t\t// { dg-error \"jump to label|enters OpenMP\" }\n+    }\n+\n+  #pragma omp target\n+  #pragma omp teams\n+    {\n+      int i;\n+      goto ok1;\n+      for (i = 0; i < 10; ++i)\n+\t{ ok1: break; }\n+    }\n+\n+  switch (x)\n+  {\n+  #pragma omp target\n+  #pragma omp teams\n+    { case 0:; }\t\t// { dg-error \"jump|enters\" }\n+  }\n+}\n+\n+// { dg-error \"invalid branch to/from an OpenMP structured block\" \"\" { target *-*-* } 8 }\n+// { dg-error \"invalid entry to OpenMP structured block\" \"\" { target *-*-* } 10 }\n+// { dg-error \"invalid branch to/from an OpenMP structured block\" \"\" { target *-*-* } 37 }\n+// { dg-error \"invalid entry to OpenMP structured block\" \"\" { target *-*-* } 39 }"}, {"sha": "10c1c8dab92ea48b265b4da8c56c28f54dfa1d60", "filename": "gcc/testsuite/g++.dg/gomp/udr-1.C", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fudr-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fudr-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fudr-1.C?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -0,0 +1,119 @@\n+// { dg-do compile }\n+// { dg-options \"-fopenmp\" }\n+\n+namespace N1\n+{\n+  #pragma omp declare reduction (| : long int : omp_out |= omp_in)\t// { dg-error \"predeclared arithmetic type\" }\n+  #pragma omp declare reduction (+ : char : omp_out += omp_in)\t\t// { dg-error \"predeclared arithmetic type\" }\n+  typedef short T;\n+  #pragma omp declare reduction (min : T : omp_out += omp_in)\t\t// { dg-error \"predeclared arithmetic type\" }\n+  #pragma omp declare reduction (* : _Complex double : omp_out *= omp_in)// { dg-error \"predeclared arithmetic type\" }\n+}\n+namespace N2\n+{\n+  template <typename T1, typename T2, typename T3, typename T4>\n+  struct S\n+  {\n+    #pragma omp declare reduction (| : T1 : omp_out |= omp_in)\t\t// { dg-error \"predeclared arithmetic type\" }\n+    #pragma omp declare reduction (+ : T2 : omp_out += omp_in)\t\t// { dg-error \"predeclared arithmetic type\" }\n+    typedef T3 T;\n+    #pragma omp declare reduction (min : T : omp_out += omp_in)\t\t// { dg-error \"predeclared arithmetic type\" }\n+    #pragma omp declare reduction (* : T4 : omp_out *= omp_in)\t\t// { dg-error \"predeclared arithmetic type\" }\n+  };\n+  S<long int, char, short, _Complex double> s;\n+  template <typename T1, typename T2, typename T3, typename T4>\n+  int foo ()\n+  {\n+    #pragma omp declare reduction (| : T1 : omp_out |= omp_in)\t\t// { dg-error \"predeclared arithmetic type\" }\n+    #pragma omp declare reduction (+ : T2 : omp_out += omp_in)\t\t// { dg-error \"predeclared arithmetic type\" }\n+    typedef T3 T;\n+    #pragma omp declare reduction (min : T : omp_out += omp_in)\t\t// { dg-error \"predeclared arithmetic type\" }\n+    #pragma omp declare reduction (* : T4 : omp_out *= omp_in)\t\t// { dg-error \"predeclared arithmetic type\" }\n+    return 0;\n+  }\n+  int x = foo <long int, char, short, _Complex double> ();\n+}\n+namespace N3\n+{\n+  void bar ();\n+  #pragma omp declare reduction (| : __typeof (bar) : omp_out |= omp_in)// { dg-error \"function or array type\" }\n+  #pragma omp declare reduction (+ : char () : omp_out += omp_in)\t// { dg-error \"function or array type\" }\n+  typedef short T;\n+  #pragma omp declare reduction (min : T[2] : omp_out += omp_in)\t// { dg-error \"function or array type\" }\n+  #pragma omp declare reduction (baz : char & : omp_out *= omp_in)\t// { dg-error \"reference type\" }\n+}\n+namespace N4\n+{\n+  void bar ();\n+  template <typename T1, typename T2, typename T3, typename T4>\n+  struct S\n+  {\n+    #pragma omp declare reduction (| : T1 : omp_out |= omp_in)\t\t// { dg-error \"function or array type\" }\n+    #pragma omp declare reduction (+ : T2 : omp_out += omp_in)\t\t// { dg-error \"function or array type\" }\n+    typedef T3 T;\n+    #pragma omp declare reduction (min : T : omp_out += omp_in)\t\t// { dg-error \"function or array type\" }\n+    #pragma omp declare reduction (baz : T4 : omp_out *= omp_in)\t// { dg-error \"function or array type\" }\n+  };\n+  S<__typeof (bar), char (), short [3], char []> s;\n+  template <typename T1, typename T2, typename T3, typename T4>\n+  int foo ()\n+  {\n+    #pragma omp declare reduction (| : T1 : omp_out |= omp_in)\t\t// { dg-error \"function or array type\" }\n+    #pragma omp declare reduction (+ : T2 : omp_out += omp_in)\t\t// { dg-error \"function or array type\" }\n+    typedef T3 T;\n+    #pragma omp declare reduction (min : T : omp_out += omp_in)\t\t// { dg-error \"function or array type\" }\n+    #pragma omp declare reduction (baz : T4 : omp_out *= omp_in)\t// { dg-error \"function or array type\" }\n+    return 0;\n+  }\n+  int x = foo <__typeof (bar), char (), short[], char [2]> ();\n+}\n+namespace N5\n+{\n+  template <typename T>\n+  struct S\n+  {\n+    #pragma omp declare reduction (baz : T : omp_out *= omp_in)\t\t// { dg-error \"reference type\" }\n+  };\n+  S<char &> s;\n+  template <typename T>\n+  int foo ()\n+  {\n+    #pragma omp declare reduction (baz : T : omp_out *= omp_in)\t\t// { dg-error \"reference type\" }\n+    return 0;\n+  }\n+  int x = foo <char &> ();\n+}\n+namespace N6\n+{\n+  struct A { int a; A () : a (0) {} };\n+  #pragma omp declare reduction (| : const A : omp_out.a |= omp_in.a)\t// { dg-error \"const, volatile or __restrict\" }\n+  #pragma omp declare reduction (+ : __const A : omp_out.a += omp_in.a)\t// { dg-error \"const, volatile or __restrict\" }\n+  typedef volatile A T;\n+  #pragma omp declare reduction (min : T : omp_out.a += omp_in.a)\t// { dg-error \"const, volatile or __restrict\" }\n+  #pragma omp declare reduction (* : A *__restrict : omp_out->a *= omp_in->a)// { dg-error \"const, volatile or __restrict\" }\n+}\n+namespace N7\n+{\n+  struct A { int a; A () : a (0) {} };\n+  template <typename T1, typename T2, typename T3, typename T4>\n+  struct S\n+  {\n+    #pragma omp declare reduction (| : T1 : omp_out |= omp_in)\t\t// { dg-error \"const, volatile or __restrict\" }\n+    #pragma omp declare reduction (+ : T2 : omp_out += omp_in)\t\t// { dg-error \"const, volatile or __restrict\" }\n+    typedef T3 T;\n+    #pragma omp declare reduction (min : T : omp_out += omp_in)\t\t// { dg-error \"const, volatile or __restrict\" }\n+    #pragma omp declare reduction (* : T4 : omp_out *= omp_in)\t\t// { dg-error \"const, volatile or __restrict\" }\n+  };\n+  S<const A, __const A, volatile A, A *__restrict> s;\n+  template <typename T1, typename T2, typename T3, typename T4>\n+  int foo ()\n+  {\n+    #pragma omp declare reduction (| : T1 : omp_out |= omp_in)\t\t// { dg-error \"const, volatile or __restrict\" }\n+    #pragma omp declare reduction (+ : T2 : omp_out += omp_in)\t\t// { dg-error \"const, volatile or __restrict\" }\n+    typedef T3 T;\n+    #pragma omp declare reduction (min : T : omp_out += omp_in)\t\t// { dg-error \"const, volatile or __restrict\" }\n+    #pragma omp declare reduction (* : T4 : omp_out *= omp_in)\t\t// { dg-error \"const, volatile or __restrict\" }\n+    return 0;\n+  }\n+  int x = foo <const A, __const A, volatile A, A *__restrict> ();\n+}"}, {"sha": "48451c4fc0ab9bf595b0a52b3c41692c77ff80e8", "filename": "gcc/testsuite/g++.dg/gomp/udr-2.C", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fudr-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fudr-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fudr-2.C?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -0,0 +1,119 @@\n+// { dg-do compile }\n+// { dg-options \"-fopenmp\" }\n+\n+struct W { int w; W () : w (0) {} W (int x) : w (x) {} };\n+namespace N1\n+{\n+  int v;\n+  #pragma omp declare reduction (foo : long int : omp_out |= v)\t// { dg-error \"combiner refers to variable\" }\n+  #pragma omp declare reduction (foo : char : omp_out = v)\t// { dg-error \"combiner refers to variable\" }\n+  typedef short T;\n+  #pragma omp declare reduction (foo : T : omp_out += N1::v)\t// { dg-error \"combiner refers to variable\" }\n+  #pragma omp declare reduction (foo : int : v *= omp_in)\t// { dg-error \"combiner refers to variable\" }\n+  #pragma omp declare reduction (foo : W : omp_out.w *= omp_in.w + v) // { dg-error \"combiner refers to variable\" }\n+}\n+namespace N2\n+{\n+  int v;\n+  template <typename T1, typename T2, typename T3, typename T4, typename T5>\n+  struct S\n+  {\n+    #pragma omp declare reduction (foo : T1 : omp_out |= v)\t// { dg-error \"combiner refers to variable\" }\n+    #pragma omp declare reduction (foo : T2 : omp_out = v)\t// { dg-error \"combiner refers to variable\" }\n+    typedef T3 T;\n+    #pragma omp declare reduction (foo : T : omp_out += N1::v)\t// { dg-error \"combiner refers to variable\" }\n+    #pragma omp declare reduction (foo : T4 : v *= omp_in)\t// { dg-error \"combiner refers to variable\" }\n+    #pragma omp declare reduction (foo : T5 : omp_out.w *= omp_in.w + v) // { dg-error \"combiner refers to variable\" }\n+  };\n+  S<long int, char, short, _Complex double, W> s;\n+  template <typename T1, typename T2, typename T3, typename T4, typename T5>\n+  int foo ()\n+  {\n+    #pragma omp declare reduction (foo : T1 : omp_out |= v)\t// { dg-error \"combiner refers to variable\" }\n+    #pragma omp declare reduction (foo : T2 : omp_out = v)\t// { dg-error \"combiner refers to variable\" }\n+    typedef T3 T;\n+    #pragma omp declare reduction (foo : T : omp_out += N1::v)\t// { dg-error \"combiner refers to variable\" }\n+    #pragma omp declare reduction (foo : T4 : v *= omp_in)\t// { dg-error \"combiner refers to variable\" }\n+    #pragma omp declare reduction (foo : T5 : omp_out.w *= omp_in.w + v) // { dg-error \"combiner refers to variable\" }\n+    return 0;\n+  }\n+  int x = foo <long int, char, short, _Complex double, W> ();\n+}\n+namespace N3\n+{\n+  int v;\n+  #pragma omp declare reduction (foo : long int : omp_out |= omp_in) initializer (omp_priv = v) // { dg-error \"initializer refers to variable\" }\n+  #pragma omp declare reduction (foo : char : omp_out += omp_in) initializer (omp_priv ((char) N3::v)) // { dg-error \"initializer refers to variable\" }\n+  typedef short T;\n+  #pragma omp declare reduction (foo : T : omp_out += omp_in) initializer (omp_priv = (short) v) // { dg-error \"initializer refers to variable\" }\n+  #pragma omp declare reduction (foo : _Complex double : omp_out *= omp_in) initializer (omp_priv (v)) // { dg-error \"initializer refers to variable\" }\n+  #pragma omp declare reduction (foo : W : omp_out.w *= omp_in.w) initializer (omp_priv (N3::v)) // { dg-error \"initializer refers to variable\" }\n+}\n+namespace N4\n+{\n+  int v;\n+  template <typename T1, typename T2, typename T3, typename T4, typename T5>\n+  struct S\n+  {\n+    #pragma omp declare reduction (foo : T1 : omp_out |= omp_in) initializer (omp_priv = v) // { dg-error \"initializer refers to variable\" }\n+    #pragma omp declare reduction (foo : T2 : omp_out += omp_in) initializer (omp_priv ((char) N3::v)) // { dg-error \"initializer refers to variable\" }\n+    typedef T3 T;\n+    #pragma omp declare reduction (foo : T : omp_out += omp_in) initializer (omp_priv = (short) v) // { dg-error \"initializer refers to variable\" }\n+    #pragma omp declare reduction (foo : T4 : omp_out *= omp_in) initializer (omp_priv (v)) // { dg-error \"initializer refers to variable\" }\n+    #pragma omp declare reduction (foo : T5 : omp_out.w *= omp_in.w) initializer (omp_priv (N3::v)) // { dg-error \"initializer refers to variable\" }\n+  };\n+  S<long int, char, short, _Complex double, W> s;\n+  template <typename T1, typename T2, typename T3, typename T4, typename T5>\n+  int foo ()\n+  {\n+    #pragma omp declare reduction (foo : T1 : omp_out |= omp_in) initializer (omp_priv = v) // { dg-error \"initializer refers to variable\" }\n+    #pragma omp declare reduction (foo : T2 : omp_out += omp_in) initializer (omp_priv ((char) N3::v)) // { dg-error \"initializer refers to variable\" }\n+    typedef T3 T;\n+    #pragma omp declare reduction (foo : T : omp_out += omp_in) initializer (omp_priv = (short) v) // { dg-error \"initializer refers to variable\" }\n+    #pragma omp declare reduction (foo : T4 : omp_out *= omp_in) initializer (omp_priv (v)) // { dg-error \"initializer refers to variable\" }\n+    #pragma omp declare reduction (foo : T5 : omp_out.w *= omp_in.w) initializer (omp_priv (N3::v)) // { dg-error \"initializer refers to variable\" }\n+    return 0;\n+  }\n+  int x = foo <long int, char, short, _Complex double, W> ();\n+}\n+template <typename T>\n+void init (T &, int &);\n+template <typename T>\n+void initializer (T, int &);\n+namespace N5\n+{\n+  int v;\n+  #pragma omp declare reduction (foo : long int : omp_out |= omp_in) initializer (init (omp_priv, v)) // { dg-error \"initializer refers to variable\" }\n+  #pragma omp declare reduction (foo : char : omp_out += omp_in) initializer (initializer (&omp_priv, N3::v)) // { dg-error \"initializer refers to variable\" }\n+  typedef short T;\n+  #pragma omp declare reduction (foo : T : omp_out += omp_in) initializer (init (omp_priv, v)) // { dg-error \"initializer refers to variable\" }\n+  #pragma omp declare reduction (foo : _Complex double : omp_out *= omp_in) initializer (initializer (&omp_priv, v)) // { dg-error \"initializer refers to variable\" }\n+  #pragma omp declare reduction (foo : W : omp_out.w *= omp_in.w) initializer (init (omp_priv, N3::v)) // { dg-error \"initializer refers to variable\" }\n+}\n+namespace N6\n+{\n+  int v;\n+  template <typename T1, typename T2, typename T3, typename T4, typename T5>\n+  struct S\n+  {\n+    #pragma omp declare reduction (foo : T1 : omp_out |= omp_in) initializer (initializer (&omp_priv, v)) // { dg-error \"initializer refers to variable\" }\n+    #pragma omp declare reduction (foo : T2 : omp_out += omp_in) initializer (init (omp_priv, N3::v)) // { dg-error \"initializer refers to variable\" }\n+    typedef T3 T;\n+    #pragma omp declare reduction (foo : T : omp_out += omp_in) initializer (init (omp_priv, v)) // { dg-error \"initializer refers to variable\" }\n+    #pragma omp declare reduction (foo : T4 : omp_out *= omp_in) initializer (init (omp_priv, v)) // { dg-error \"initializer refers to variable\" }\n+    #pragma omp declare reduction (foo : T5 : omp_out.w *= omp_in.w) initializer (initializer (&omp_priv, N3::v)) // { dg-error \"initializer refers to variable\" }\n+  };\n+  S<long int, char, short, _Complex double, W> s;\n+  template <typename T1, typename T2, typename T3, typename T4, typename T5>\n+  int foo ()\n+  {\n+    #pragma omp declare reduction (foo : T1 : omp_out |= omp_in) initializer (init (omp_priv, v)) // { dg-error \"initializer refers to variable\" }\n+    #pragma omp declare reduction (foo : T2 : omp_out += omp_in) initializer (init (omp_priv, N3::v)) // { dg-error \"initializer refers to variable\" }\n+    typedef T3 T;\n+    #pragma omp declare reduction (foo : T : omp_out += omp_in) initializer (initializer (&omp_priv, v)) // { dg-error \"initializer refers to variable\" }\n+    #pragma omp declare reduction (foo : T4 : omp_out *= omp_in) initializer (init (omp_priv, v)) // { dg-error \"initializer refers to variable\" }\n+    #pragma omp declare reduction (foo : T5 : omp_out.w *= omp_in.w) initializer (initializer (omp_priv, N3::v)) // { dg-error \"initializer refers to variable\" }\n+    return 0;\n+  }\n+  int x = foo <long int, char, short, _Complex double, W> ();\n+}"}, {"sha": "a560fc1b5373a2c8817f30e3ee42b3f12dca1ea6", "filename": "gcc/testsuite/g++.dg/gomp/udr-3.C", "status": "added", "additions": 191, "deletions": 0, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fudr-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fudr-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fudr-3.C?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -0,0 +1,191 @@\n+// { dg-do compile }\n+// { dg-options \"-fopenmp\" }\n+\n+struct S { int s; S () : s (0) {} S (int x) : s (x) {} ~S () {} };\n+struct T { int t; T () : t (0) {} T (int x) : t (x) {} ~T () {} };\n+\n+#pragma omp declare reduction (+: ::S: omp_out.s += omp_in.s)\n+#pragma omp declare reduction (*: S: omp_out.s *= omp_in.s) \\\n+\t\t    initializer (omp_priv (1))\n+#pragma omp declare reduction (foo: S: omp_out.s += omp_in.s)\n+\n+void\n+f1 ()\n+{\n+  S s, s2;\n+  T t;\n+  #pragma omp declare reduction (+: T: omp_out.t += omp_in.t)\n+  #pragma omp parallel reduction (+: t) reduction (foo: s) reduction (*: s2)\n+  s.s = 1, t.t = 1, s2.s = 2;\n+  #pragma omp parallel reduction (::operator +: s)\n+  s.s = 1;\n+  #pragma omp parallel reduction (+: s)\n+  s.s = 1;\n+}\n+\n+template <int N>\n+int\n+f2 ()\n+{\n+  S s, s2;\n+  T t;\n+  #pragma omp declare reduction (+: T: omp_out.t += omp_in.t)\n+  #pragma omp parallel reduction (+: t) reduction (foo: s) reduction (*: s2)\n+  s.s = 1, t.t = 1, s2.s = 2;\n+  #pragma omp parallel reduction (::operator +: s)\n+  s.s = 1;\n+  #pragma omp parallel reduction (+: s)\n+  s.s = 1;\n+  return 0;\n+}\n+\n+int x = f2<0> ();\n+\n+void bar (S &);\n+\n+void\n+f3 ()\n+{\n+  #pragma omp declare reduction (foo: S: omp_out.s += omp_in.s) initializer (bar (omp_priv))\n+  #pragma omp declare reduction (bar: S: omp_out.s += omp_in.s) initializer (bar (omp_orig)) // { dg-error \"one of the initializer call arguments should be\" }\n+}\n+\n+template <typename T>\n+int\n+f4 ()\n+{\n+  #pragma omp declare reduction (foo: T: omp_out.s += omp_in.s) initializer (bar (omp_priv))\n+  #pragma omp declare reduction (bar: T: omp_out.s += omp_in.s) initializer (bar (omp_orig)) // { dg-error \"one of the initializer call arguments should be\" }\n+  return 0;\n+}\n+\n+int y = f4 <S> ();\n+\n+namespace N1\n+{\n+  #pragma omp declare reduction (+: ::S: omp_out.s *= omp_in.s)\t\t// { dg-error \"previous\" }\n+  #pragma omp declare reduction (+: S: omp_out.s += omp_in.s)\t\t// { dg-error \"redeclaration of\" }\n+  void\n+  f5 ()\n+  {\n+    #pragma omp declare reduction (f5: S: omp_out.s *= omp_in.s)\t// { dg-error \"previous\" }\n+    #pragma omp declare reduction (f5: ::S: omp_out.s += omp_in.s)\t// { dg-error \"redeclaration of\" }\n+  }\n+}\n+\n+namespace N2\n+{\n+  struct U\n+  {\n+    #pragma omp declare reduction (bar: S: omp_out.s *= omp_in.s)\t// { dg-error \"with\" }\n+    #pragma omp declare reduction (bar: S: omp_out.s += omp_in.s)\t// { dg-error \"cannot be overloaded\" }\n+  };\n+}\n+\n+namespace N3\n+{\n+  #pragma omp declare reduction (+: ::S: omp_out.s *= omp_in.s)\t\t// { dg-error \"previous\" }\n+  #pragma omp declare reduction (+: T: omp_out.t += omp_in.t)\n+  #pragma omp declare reduction (+: S: omp_out.s += omp_in.s)\t\t// { dg-error \"redeclaration of\" }\n+  #pragma omp declare reduction (n3: long: omp_out += omp_in)\t\t// { dg-error \"previous\" }\n+  #pragma omp declare reduction (n3: long int: omp_out += omp_in)\t// { dg-error \"redeclaration of\" }\n+  #pragma omp declare reduction (n3: short unsigned: omp_out += omp_in)\n+  #pragma omp declare reduction (n3: short int: omp_out += omp_in)\n+  void\n+  f6 ()\n+  {\n+    #pragma omp declare reduction (f6: T: omp_out.t += omp_in.t)\n+    #pragma omp declare reduction (f6: S: omp_out.s *= omp_in.s)\t// { dg-error \"previous\" }\n+    #pragma omp declare reduction (f6: ::S: omp_out.s += omp_in.s)\t// { dg-error \"redeclaration of\" }\n+    #pragma omp declare reduction (f6: long: omp_out += omp_in)\t\t// { dg-error \"previous\" }\n+    #pragma omp declare reduction (f6: long int: omp_out += omp_in)\t// { dg-error \"redeclaration of\" }\n+    #pragma omp declare reduction (f6: short unsigned: omp_out += omp_in)\n+    #pragma omp declare reduction (f6: short int: omp_out += omp_in)\n+  }\n+}\n+\n+namespace N4\n+{\n+  struct U\n+  {\n+    #pragma omp declare reduction (bar: T: omp_out.t += omp_in.t)\n+    #pragma omp declare reduction (bar: S: omp_out.s *= omp_in.s)\t// { dg-error \"with\" }\n+    #pragma omp declare reduction (bar: S: omp_out.s += omp_in.s)\t// { dg-error \"cannot be overloaded\" }\n+    #pragma omp declare reduction (bar: long: omp_out += omp_in)\t// { dg-error \"with\" }\n+    #pragma omp declare reduction (bar: long int: omp_out += omp_in)\t// { dg-error \"cannot be overloaded\" }\n+    #pragma omp declare reduction (bar: short unsigned: omp_out += omp_in)\n+    #pragma omp declare reduction (bar: short int: omp_out += omp_in)\n+  };\n+}\n+\n+namespace N5\n+{\n+  template <typename T>\n+  int\n+  f7 ()\n+  {\n+    #pragma omp declare reduction (f7: T: omp_out.s *= omp_in.s)\t// { dg-error \"previous\" }\n+    #pragma omp declare reduction (f7: T: omp_out.s += omp_in.s)\t// { dg-error \"redeclaration of\" }\n+    return 0;\n+  }\n+  int x = f7 <S> ();\n+  template <typename T>\n+  struct U\n+  {\n+    #pragma omp declare reduction (bar: T: omp_out.s *= omp_in.s)\t// { dg-error \"with\" }\n+    #pragma omp declare reduction (bar: T: omp_out.s += omp_in.s)\t// { dg-error \"cannot be overloaded\" }\n+  };\n+  U<S> u;\n+}\n+\n+namespace N6\n+{\n+  template <typename U>\n+  int\n+  f8 ()\n+  {\n+    #pragma omp declare reduction (f8: T: omp_out.t += omp_in.t)\n+    #pragma omp declare reduction (f8: U: omp_out.s *= omp_in.s)\t// { dg-error \"previous\" }\n+    #pragma omp declare reduction (f8: ::S: omp_out.s += omp_in.s)\t// { dg-error \"redeclaration of\" }\n+    #pragma omp declare reduction (f8: long: omp_out += omp_in)\t\t// { dg-error \"previous\" }\n+    #pragma omp declare reduction (f8: long int: omp_out += omp_in)\t// { dg-error \"redeclaration of\" }\n+    #pragma omp declare reduction (f8: short unsigned: omp_out += omp_in)\n+    #pragma omp declare reduction (f8: short int: omp_out += omp_in)\n+    return 0;\n+  }\n+  int x = f8 <S> ();\n+  template <typename V>\n+  struct U\n+  {\n+    typedef V V2;\n+    #pragma omp declare reduction (bar: T: omp_out.t += omp_in.t)\n+    #pragma omp declare reduction (bar: V: omp_out.s *= omp_in.s)\t// { dg-error \"with\" }\n+    #pragma omp declare reduction (bar: V2: omp_out.s += omp_in.s)\t// { dg-error \"cannot be overloaded\" }\n+    #pragma omp declare reduction (bar: long: omp_out += omp_in)\t// { dg-error \"with\" }\n+    #pragma omp declare reduction (bar: long int: omp_out += omp_in)\t// { dg-error \"cannot be overloaded\" }\n+    #pragma omp declare reduction (bar: short unsigned: omp_out += omp_in)\n+    #pragma omp declare reduction (bar: short int: omp_out += omp_in)\n+  };\n+  U<S> u;\n+}\n+\n+namespace N7\n+{\n+  #pragma omp declare reduction (+: S: omp_out.s += omp_in.s) initializer (omp_priv) // { dg-error \"invalid initializer clause\" }\n+  #pragma omp declare reduction (+: T: omp_out.t += omp_in.t) initializer (omp_priv ()) // { dg-error \"invalid initializer clause\" }\n+}\n+\n+namespace N8\n+{\n+  struct A { int a; A (); ~A (); };\n+  struct B { int b; B (); ~B (); B (int); };\n+  struct C : public A, B { int c; C (); ~C (); };\n+  #pragma omp declare reduction (+:B:omp_out.b += omp_in.b) initializer (omp_priv (4))\n+  void bar (C &);\n+  void baz ()\n+  {\n+    C a;\n+    #pragma omp parallel reduction (+:a) // { dg-error \"user defined reduction with constructor initializer for base class\" }\n+    bar (a);\n+  }\n+}"}, {"sha": "f1b388bbd918c512f1c54e78f63f0c066e9d6f24", "filename": "gcc/testsuite/g++.dg/gomp/udr-4.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fudr-4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fudr-4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fudr-4.C?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -0,0 +1,14 @@\n+// { dg-do compile }\n+\n+struct S;\t\t\t\t\t// { dg-error \"forward declaration\" }\n+#pragma omp declare reduction (+:S:omp_out.s += omp_in.s) // { dg-error \"invalid use of incomplete type\" }\n+struct S { int s; S () : s (1) {} };\n+#pragma omp declare reduction (*:S:omp_out.s *= omp_in.s)\n+\n+void\n+foo ()\n+{\n+  S s;\n+  #pragma omp parallel reduction (S::~S:s)\t// { dg-error \"invalid reduction-identifier\" }\n+  s.s = 1;\n+}"}, {"sha": "425f8e95cd9779357d600a6f32cebc15c9aaad47", "filename": "gcc/testsuite/g++.dg/gomp/udr-5.C", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fudr-5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fudr-5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fudr-5.C?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -0,0 +1,41 @@\n+// { dg-do compile }\n+\n+struct S\n+{\n+  int s;\n+  S () : s (0) {}\n+private:\n+  #pragma omp declare reduction (+:S:omp_out.s += omp_in.s)\t// { dg-error \"is private\" }\n+protected:\n+  #pragma omp declare reduction (-:S:omp_out.s += omp_in.s)\t// { dg-error \"is protected\" }\n+};\n+\n+struct T : public S\n+{\n+  void foo ()\n+  {\n+    S s;\n+    #pragma omp parallel reduction (S::operator +:s)\t// { dg-error \"within this context\" }\n+    s.s = 1;\n+    S t;\n+    #pragma omp parallel reduction (S::operator -:t)\n+    t.s = 1;\n+    S u;\n+    #pragma omp parallel reduction (+:u)\t\t// { dg-error \"within this context\" }\n+    u.s = 1;\n+    S v;\n+    #pragma omp parallel reduction (-:v)\n+    v.s = 1;\n+  }\n+};\n+\n+void\n+foo ()\n+{\n+  S s;\n+  #pragma omp parallel reduction (S::operator +:s)\t// { dg-error \"within this context\" }\n+  s.s = 1;\n+  S t;\n+  #pragma omp parallel reduction (S::operator -:t)\t// { dg-error \"within this context\" }\n+  t.s = 1;\n+}"}, {"sha": "9060c87a5421f6173e66d7d6d76fa543e6553f90", "filename": "gcc/testsuite/g++.dg/gomp/udr-6.C", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fudr-6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fudr-6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fudr-6.C?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -0,0 +1,59 @@\n+// { dg-do compile }\n+\n+struct A { int a; A () : a (0) {} };\n+struct B { int b; B () : b (0) {} };\n+struct C : public A, B { int c; C () : c (0) {} };\n+struct D { int d; D () : d (0) {} };\n+struct E { int e; E () : e (0) {} };\n+struct F : public D, E { int f; F () : f (0) {} };\n+struct G : public C, F { int g; G () : g (0) {} };\n+\n+#pragma omp declare reduction (+: A : omp_out.a += omp_in.a) // { dg-message \"operator\" }\n+#pragma omp declare reduction (+: B : omp_out.b += omp_in.b) // { dg-message \"operator\" }\n+#pragma omp declare reduction (+: D : omp_out.d += omp_in.d)\n+#pragma omp declare reduction (+: E : omp_out.e += omp_in.e)\n+#pragma omp declare reduction (+: F : omp_out.f += omp_in.f) // { dg-message \"operator\" }\n+\n+void\n+f1 ()\n+{\n+  G g;\n+  #pragma omp parallel reduction (+: g)\t// { dg-error \"user defined reduction lookup is ambiguous\" }\n+  {\n+    g.g++;\n+  }\n+}\n+\n+#pragma omp declare reduction (*: A : omp_out.a += omp_in.a)\n+#pragma omp declare reduction (*: B : omp_out.b += omp_in.b)\n+#pragma omp declare reduction (*: D : omp_out.d += omp_in.d)\n+#pragma omp declare reduction (*: E : omp_out.e += omp_in.e)\n+#pragma omp declare reduction (*: F : omp_out.f += omp_in.f)\n+#pragma omp declare reduction (*: G : omp_out.g += omp_in.g)\n+\n+void\n+f2 ()\n+{\n+  G g;\n+  #pragma omp parallel reduction (*: g)\n+  {\n+    g.g++;\n+  }\n+}\n+\n+#pragma omp declare reduction (|: A : omp_out.a += omp_in.a)\n+#pragma omp declare reduction (|: B : omp_out.b += omp_in.b)\n+#pragma omp declare reduction (|: C : omp_out.c += omp_in.c) // { dg-message \"operator\" }\n+#pragma omp declare reduction (|: D : omp_out.d += omp_in.d)\n+#pragma omp declare reduction (|: E : omp_out.e += omp_in.e)\n+#pragma omp declare reduction (|: F : omp_out.f += omp_in.f) // { dg-message \"operator\" }\n+\n+void\n+f3 ()\n+{\n+  G g;\n+  #pragma omp parallel reduction (|: g)\t// { dg-error \"user defined reduction lookup is ambiguous\" }\n+  {\n+    g.g++;\n+  }\n+}"}, {"sha": "a9d2185f0ce2c43cb36a5571fe7df5aec3a28de2", "filename": "gcc/testsuite/gcc.dg/autopar/outer-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fgcc.dg%2Fautopar%2Fouter-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fgcc.dg%2Fautopar%2Fouter-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fautopar%2Fouter-1.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -28,6 +28,6 @@ int main(void)\n \n /* Check that outer loop is parallelized.  */\n /* { dg-final { scan-tree-dump-times \"parallelizing outer loop\" 1 \"parloops\" } } */\n-/* { dg-final { scan-tree-dump-times \"loopfn\" 5 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"loopfn\" 4 \"optimized\" } } */\n /* { dg-final { cleanup-tree-dump \"parloops\" } } */\n /* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "e0a142f0d1105aa0ee6036257874fb286b0ecefe", "filename": "gcc/testsuite/gcc.dg/autopar/outer-2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fgcc.dg%2Fautopar%2Fouter-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fgcc.dg%2Fautopar%2Fouter-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fautopar%2Fouter-2.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -28,6 +28,6 @@ int main(void)\n }\n \n /* { dg-final { scan-tree-dump-times \"parallelizing outer loop\" 1 \"parloops\" } } */\n-/* { dg-final { scan-tree-dump-times \"loopfn\" 5 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"loopfn\" 4 \"optimized\" } } */\n /* { dg-final { cleanup-tree-dump \"parloops\" } } */\n /* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "c6e0adbffdfe5ac21d9e8c79a618a565d452f524", "filename": "gcc/testsuite/gcc.dg/autopar/outer-3.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fgcc.dg%2Fautopar%2Fouter-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fgcc.dg%2Fautopar%2Fouter-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fautopar%2Fouter-3.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -28,6 +28,6 @@ int main(void)\n \n /* Check that outer loop is parallelized.  */\n /* { dg-final { scan-tree-dump-times \"parallelizing outer loop\" 1 \"parloops\" } } */\n-/* { dg-final { scan-tree-dump-times \"loopfn\" 5 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"loopfn\" 4 \"optimized\" } } */\n /* { dg-final { cleanup-tree-dump \"parloops\" } } */\n /* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "d60023f5d867b7f460cd4fade25ac7892ff2aeec", "filename": "gcc/testsuite/gcc.dg/autopar/outer-4.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fgcc.dg%2Fautopar%2Fouter-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fgcc.dg%2Fautopar%2Fouter-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fautopar%2Fouter-4.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -32,6 +32,6 @@ int main(void)\n \n \n /* { dg-final { scan-tree-dump-times \"parallelizing outer loop\" 1 \"parloops\" { xfail *-*-* } } } */\n-/* { dg-final { scan-tree-dump-times \"loopfn\" 5 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"loopfn\" 4 \"optimized\" } } */\n /* { dg-final { cleanup-tree-dump \"parloops\" } } */\n /* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "fa80293263c509582b8a4f438ee7408040169bbb", "filename": "gcc/testsuite/gcc.dg/autopar/outer-5.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fgcc.dg%2Fautopar%2Fouter-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fgcc.dg%2Fautopar%2Fouter-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fautopar%2Fouter-5.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -45,6 +45,6 @@ int main(void)\n }\n \n /* { dg-final { scan-tree-dump-times \"parallelizing outer loop\" 1 \"parloops\" { xfail *-*-* } } } */\n-/* { dg-final { scan-tree-dump-times \"loopfn\" 5 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"loopfn\" 4 \"optimized\" } } */\n /* { dg-final { cleanup-tree-dump \"parloops\" } } */\n /* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "b16366932fecfa4d90f515d68aa9718cb9ca3cbc", "filename": "gcc/testsuite/gcc.dg/autopar/outer-6.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fgcc.dg%2Fautopar%2Fouter-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fgcc.dg%2Fautopar%2Fouter-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fautopar%2Fouter-6.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -46,6 +46,6 @@ int main(void)\n /* Check that outer loop is parallelized.  */\n /* { dg-final { scan-tree-dump-times \"parallelizing outer loop\" 1 \"parloops\" } } */\n /* { dg-final { scan-tree-dump-times \"parallelizing inner loop\" 0 \"parloops\" } } */\n-/* { dg-final { scan-tree-dump-times \"loopfn\" 5 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"loopfn\" 4 \"optimized\" } } */\n /* { dg-final { cleanup-tree-dump \"parloops\" } } */\n /* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "de2a0f3cc71274cb7f9e338862cae139b835bb19", "filename": "gcc/testsuite/gcc.dg/autopar/parallelization-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fgcc.dg%2Fautopar%2Fparallelization-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fgcc.dg%2Fautopar%2Fparallelization-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fautopar%2Fparallelization-1.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -28,6 +28,6 @@ int main(void)\n /* Check that the first loop in parloop got parallelized.  */\n \n /* { dg-final { scan-tree-dump-times \"SUCCESS: may be parallelized\" 1 \"parloops\" } } */\n-/* { dg-final { scan-tree-dump-times \"loopfn\" 5 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"loopfn\" 4 \"optimized\" } } */\n /* { dg-final { cleanup-tree-dump \"parloops\" } } */\n /* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "b4530e9d06c50437ff1128d7e56add69e8b1a437", "filename": "gcc/testsuite/gcc.dg/gomp/block-3.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fblock-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fblock-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fblock-3.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -35,9 +35,10 @@ void foo()\n \n   #pragma omp sections\n     {\n-      goto ok1;\n-      ok1:;\n-\n+      {\n+\tgoto ok1;\n+\tok1:;\n+      }\n     #pragma omp section\n       for (i = 0; i < 10; ++i)\n \tif (test(i))"}, {"sha": "fc7d72b7cd2cc9deb1d512ae1f61fd550dc0a9be", "filename": "gcc/testsuite/gcc.dg/gomp/clause-1.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fclause-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fclause-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fclause-1.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -11,7 +11,7 @@ int t;\n void\n foo (int x)\n {\n-  char *p;\n+  char *pp;\n   struct S { int i; int j; } s;\n   char a[32];\n   double d;\n@@ -42,11 +42,11 @@ foo (int x)\n     ;\n #pragma omp p firstprivate (bar) /* { dg-error \"is not a variable\" } */\n     ;\n-#pragma omp p reduction (+:p) /* { dg-error \"has invalid type for\" } */\n+#pragma omp p reduction (+:pp) /* { dg-error \"user defined reduction not found for\" } */\n     ;\n-#pragma omp p reduction (*:s) /* { dg-error \"has invalid type for\" } */\n+#pragma omp p reduction (*:s) /* { dg-error \"user defined reduction not found for\" } */\n     ;\n-#pragma omp p reduction (-:a) /* { dg-error \"has invalid type for\" } */\n+#pragma omp p reduction (-:a) /* { dg-error \"user defined reduction not found for\" } */\n     ;\n   d = 0;\n #pragma omp p reduction (*:d)"}, {"sha": "7e23c3256cb8d13caa44c1281c3adda90cf8e8a9", "filename": "gcc/testsuite/gcc.dg/gomp/combined-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fcombined-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fcombined-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fcombined-1.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -20,5 +20,5 @@ int foo (void)\n       }\n }\n \n-/* { dg-final { scan-tree-dump-times \"GOMP_parallel_loop_runtime_start\" 3 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"GOMP_parallel_loop_runtime\" 3 \"optimized\" } } */\n /* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "259e2c0ae9258bf57dec1bc3b83f932c174c3b8c", "filename": "gcc/testsuite/gcc.dg/gomp/declare-simd-1.c", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fdeclare-simd-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fdeclare-simd-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fdeclare-simd-1.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -0,0 +1,100 @@\n+/* Test parsing of #pragma omp declare simd */\n+/* { dg-do compile } */\n+\n+#pragma omp declare simd uniform (a) aligned (b : 8 * sizeof (int)) \\\n+\t    linear (c : 4) simdlen (8) notinbranch\n+#pragma omp declare simd uniform (c) aligned (b : 4 * sizeof (int)) linear (a \\\n+\t\t\t\t\t\t\t\t\t    : 4) simdlen (4) inbranch\n+int f1 (int a, int *b, int c);\n+\n+#pragma omp declare simd uniform (a) aligned (b : 8 * sizeof (int)) linear (c : 4) simdlen (8)\n+int f2 (int a, int *b, int c)\n+{\n+  return a + *b + c;\n+}\n+\n+#pragma omp declare simd uniform (a) aligned (b : 8 * sizeof (long long)) linear (c : 4) simdlen (8)\n+__extension__\n+long long f3 (long long a, long long *b, long long c);\n+\n+int\n+f4 (int x)\n+{\n+  #pragma omp declare simd simdlen (8) aligned (b : 8 * sizeof (int))\n+  __extension__ __extension__ __extension__\n+  extern int f5 (int a, int *b, int c);\n+  {\n+    x++;\n+    #pragma omp declare simd simdlen (4) linear (c)\n+    extern int f6 (int a, int *b, int c);\n+  }\n+  return x;\n+}\n+\n+#pragma omp declare simd simdlen (16)\n+int\n+f7 (int x)\n+{\n+  #pragma omp declare simd simdlen (8) aligned (b : 8 * sizeof (int))\n+  extern int f8 (int a, int *b, int c);\n+  return x;\n+}\n+\n+int\n+f9 (int x)\n+{\n+  if (x)\n+    #pragma omp declare simd simdlen (8) aligned (b : 8 * sizeof (int))\n+    extern int f10 (int a, int *b, int c);\n+  while (x < 10)\n+    #pragma omp declare simd simdlen (8) aligned (b : 8 * sizeof (int))\n+    extern int f11 (int a, int *b, int c);\n+  return x;\n+}\n+\n+#pragma omp declare simd uniform (a) aligned (b : 8 * sizeof (int)) linear (c : 4) simdlen (8)\n+int f12 (int c; int *b; int a; int a, int *b, int c);\n+\n+#pragma omp declare simd uniform (a) aligned (b : 8 * sizeof (int)) linear (c : 4) simdlen (8)\n+int\n+f13 (int c; int *b; int a; int a, int *b, int c)\n+{\n+  return a + *b + c;\n+}\n+\n+#pragma omp declare simd uniform (a) aligned (b : 8 * sizeof (int)) linear (c : 4) simdlen (8)\n+int\n+f14 (a, b, c)\n+     int a, c;\n+     int *b;\n+{\n+  return a + *b + c;\n+}\n+\n+#pragma omp declare simd uniform (a) aligned (b : 8 * sizeof (int)) linear (c : 4) simdlen (8)\n+int\n+f15 (int a, int *b, int c)\n+{\n+  return a + *b + c;\n+}\n+\n+#pragma omp declare simd uniform (d) aligned (e : 8 * sizeof (int)) linear (f : 4) simdlen (8)\n+int f15 (int d, int *e, int f);\n+\n+#pragma omp declare simd aligned (g : sizeof (*g)) linear (h : 2 * sizeof (g[0]) + sizeof (h)) simdlen (4)\n+int f16 (long *g, int h);\n+\n+#pragma omp declare simd aligned (h : sizeof (*h)) linear (g : 2 * sizeof (h[0]) + sizeof (g)) simdlen (4)\n+int f17 (int g, long *h)\n+{\n+  return g + h[0];\n+}\n+\n+#pragma omp declare simd aligned (i : sizeof (*i)) linear (j : 2 * sizeof (i[0]) + sizeof (j)) simdlen (4)\n+int\n+f18 (j, i)\n+     long *i;\n+     int j;\n+{\n+  return j + i[0];\n+}"}, {"sha": "118549be908dc63fb6a4e5bb79fc9b2482999dd2", "filename": "gcc/testsuite/gcc.dg/gomp/declare-simd-2.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fdeclare-simd-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fdeclare-simd-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fdeclare-simd-2.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -0,0 +1,24 @@\n+/* Test parsing of #pragma omp declare simd */\n+/* { dg-do compile } */\n+\n+#pragma omp declare simd\n+int a;\t/* { dg-error \"not immediately followed by a function declaration or definition\" } */\n+\n+#pragma omp declare simd\n+int fn1 (int a), fn2 (int a);\t/* { dg-error \"not immediately followed by a single function declaration or definition\" } */\n+\n+#pragma omp declare simd\n+int b, fn3 (int a);\t/* { dg-error \"not immediately followed by a function declaration or definition\" } */\n+\n+#pragma omp declare simd linear (a)\n+int fn4 (int a), c;\t/* { dg-error \"not immediately followed by a function declaration or definition\" } */\n+\n+int t;\n+\n+#pragma omp declare simd\n+#pragma omp declare simd\n+#pragma omp threadprivate(t)\t/* { dg-error \"must be followed by function declaration or definition or another\" } */\n+int fn5 (int a);\n+\n+#pragma omp declare simd inbranch notinbranch /* { dg-error \"clause is incompatible with\" } */\n+int fn6 (int);"}, {"sha": "52fcda741ea0e30ab14bdffb9ad3b536aaffb204", "filename": "gcc/testsuite/gcc.dg/gomp/nesting-1.c", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fnesting-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fnesting-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fnesting-1.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -28,17 +28,58 @@ f1 (void)\n     #pragma omp for\t\t/* { dg-error \"may not be closely nested\" } */\n     for (j = 0; j < 3; j++)\n       ;\n+  }\n+  #pragma omp sections\n+  {\n     #pragma omp sections\t/* { dg-error \"may not be closely nested\" } */\n     {\n       ;\n     #pragma omp section\n       ;\n     }\n+  }\n+  #pragma omp sections\n+  {\n     #pragma omp single\t\t/* { dg-error \"may not be closely nested\" } */\n       ;\n+  }\n+  #pragma omp sections\n+  {\n     #pragma omp master\t\t/* { dg-error \"may not be closely nested\" } */\n       ;\n+  }\n+  #pragma omp sections\n+  {\n+    #pragma omp section\n+      ;\n+  }\n+  #pragma omp sections\n+  {\n     #pragma omp section\n+    #pragma omp for\t\t/* { dg-error \"may not be closely nested\" } */\n+    for (j = 0; j < 3; j++)\n+      ;\n+  }\n+  #pragma omp sections\n+  {\n+    #pragma omp section\n+    #pragma omp sections\t/* { dg-error \"may not be closely nested\" } */\n+    {\n+      ;\n+    #pragma omp section\n+      ;\n+    }\n+  }\n+  #pragma omp sections\n+  {\n+    #pragma omp section\n+    #pragma omp single\t\t/* { dg-error \"may not be closely nested\" } */\n+      ;\n+  }\n+  #pragma omp sections\n+  {\n+    #pragma omp section\n+    #pragma omp master\t\t/* { dg-error \"may not be closely nested\" } */\n       ;\n   }\n   #pragma omp single"}, {"sha": "09e65bd3115ffd5f4a8e9002b7366222f8aead2b", "filename": "gcc/testsuite/gcc.dg/gomp/target-1.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ftarget-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ftarget-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ftarget-1.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-do compile } */\n+\n+void\n+foo (int x)\n+{\n+  bad1:\n+  #pragma omp target\n+    goto bad1;\t\t\t/* { dg-error \"invalid branch\" } */\n+\n+  goto bad2;\t\t\t/* { dg-error \"invalid entry\" } */\n+  #pragma omp target\n+    {\n+      bad2: ;\n+    }\n+\n+  #pragma omp target\n+    {\n+      int i;\n+      goto ok1;\n+      for (i = 0; i < 10; ++i)\n+\t{ ok1: break; }\n+    }\n+\n+  switch (x)\t\t\t/* { dg-error \"invalid entry\" } */\n+  {\n+  #pragma omp target\n+    { case 0:; }\n+  }\n+}"}, {"sha": "546a1d0c157795dab0b1528fbf70db24f7e72527", "filename": "gcc/testsuite/gcc.dg/gomp/target-2.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ftarget-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ftarget-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ftarget-2.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-do compile } */\n+\n+void\n+foo (int x, int y)\n+{\n+  bad1:\n+  #pragma omp target data map(tofrom: y)\n+    goto bad1;\t\t\t/* { dg-error \"invalid branch\" } */\n+\n+  goto bad2;\t\t\t/* { dg-error \"invalid entry\" } */\n+  #pragma omp target data map(tofrom: y)\n+    {\n+      bad2: ;\n+    }\n+\n+  #pragma omp target data map(tofrom: y)\n+    {\n+      int i;\n+      goto ok1;\n+      for (i = 0; i < 10; ++i)\n+\t{ ok1: break; }\n+    }\n+\n+  switch (x)\t\t\t/* { dg-error \"invalid entry\" } */\n+  {\n+  #pragma omp target data map(tofrom: y)\n+    { case 0:; }\n+  }\n+}"}, {"sha": "e301efc19c4b5d3f17d90407740277350c3a29cf", "filename": "gcc/testsuite/gcc.dg/gomp/taskgroup-1.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ftaskgroup-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ftaskgroup-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ftaskgroup-1.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-do compile } */\n+\n+void\n+foo (int x)\n+{\n+  bad1:\n+  #pragma omp taskgroup\n+    goto bad1;\t\t\t/* { dg-error \"invalid branch\" } */\n+\n+  goto bad2;\t\t\t/* { dg-error \"invalid entry\" } */\n+  #pragma omp taskgroup\n+    {\n+      bad2: ;\n+    }\n+\n+  #pragma omp taskgroup\n+    {\n+      int i;\n+      goto ok1;\n+      for (i = 0; i < 10; ++i)\n+\t{ ok1: break; }\n+    }\n+\n+  switch (x)\t\t\t/* { dg-error \"invalid entry\" } */\n+  {\n+  #pragma omp taskgroup\n+    { case 0:; }\n+  }\n+}"}, {"sha": "73c00ded78b4b70e3be6f0b3131332dbb6449884", "filename": "gcc/testsuite/gcc.dg/gomp/teams-1.c", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fteams-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fteams-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fteams-1.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -0,0 +1,61 @@\n+/* { dg-do compile } */\n+\n+void\n+foo (int x)\n+{\n+  bad1:\n+  #pragma omp target teams\n+    goto bad1;\t\t\t/* { dg-error \"invalid branch\" } */\n+\n+  goto bad2;\t\t\t/* { dg-error \"invalid entry\" } */\n+  #pragma omp target teams\n+    {\n+      bad2: ;\n+    }\n+\n+  #pragma omp target teams\n+    {\n+      int i;\n+      goto ok1;\n+      for (i = 0; i < 10; ++i)\n+\t{ ok1: break; }\n+    }\n+\n+  switch (x)\t\t\t/* { dg-error \"invalid entry\" } */\n+  {\n+  #pragma omp target teams\n+    { case 0:; }\n+  }\n+}\n+\n+void\n+bar (int x)\n+{\n+  bad1:\n+  #pragma omp target\n+  #pragma omp teams\n+    goto bad1;\t\t\t/* { dg-error \"invalid branch\" } */\n+\n+  goto bad2;\t\t\t/* { dg-error \"invalid entry\" } */\n+  #pragma omp target\n+  #pragma omp teams\n+    {\n+      bad2: ;\n+    }\n+\n+  #pragma omp target\n+  #pragma omp teams\n+    {\n+      int i;\n+      goto ok1;\n+      for (i = 0; i < 10; ++i)\n+\t{ ok1: break; }\n+    }\n+\n+  switch (x)\t\t\t/* { dg-error \"invalid entry\" } */\n+  {\n+  #pragma omp target\n+  #pragma omp teams\n+    { case 0:; }\n+  }\n+}"}, {"sha": "4948a984f69f3f53c6918a112e248abd6b083ee6", "filename": "gcc/testsuite/gcc.dg/gomp/udr-1.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fudr-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fudr-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fudr-1.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -0,0 +1,46 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp\" } */\n+\n+#pragma omp declare reduction (| : long int : omp_out |= omp_in)\t/* { dg-error \"predeclared arithmetic type\" } */\n+#pragma omp declare reduction (+ : char : omp_out += omp_in)\t\t/* { dg-error \"predeclared arithmetic type\" } */\n+typedef short T;\n+#pragma omp declare reduction (min : T : omp_out += omp_in)\t\t/* { dg-error \"predeclared arithmetic type\" } */\n+#pragma omp declare reduction (* : _Complex double : omp_out *= omp_in)\t/* { dg-error \"predeclared arithmetic type\" } */\n+\n+void\n+foo (void)\n+{\n+  #pragma omp declare reduction (| : long int : omp_out |= omp_in)\t/* { dg-error \"predeclared arithmetic type\" } */\n+  #pragma omp declare reduction (+ : char : omp_out += omp_in)\t\t/* { dg-error \"predeclared arithmetic type\" } */\n+  #pragma omp declare reduction (min : T : omp_out += omp_in)\t\t/* { dg-error \"predeclared arithmetic type\" } */\n+  #pragma omp declare reduction (* : _Complex double : omp_out *= omp_in) /* { dg-error \"predeclared arithmetic type\" } */\n+}\n+\n+#pragma omp declare reduction (| : __typeof (foo) : omp_out |= omp_in)\t/* { dg-error \"function or array\" } */\n+#pragma omp declare reduction (+ : char () : omp_out += omp_in)\t\t/* { dg-error \"function or array\" } */\n+#pragma omp declare reduction (min : T[2] : omp_out += omp_in)\t\t/* { dg-error \"function or array\" } */\n+\n+void\n+bar (void)\n+{\n+  #pragma omp declare reduction (| : __typeof (foo) : omp_out |= omp_in)/* { dg-error \"function or array\" } */\n+  #pragma omp declare reduction (+ : char () : omp_out += omp_in)\t/* { dg-error \"function or array\" } */\n+  #pragma omp declare reduction (min : T[2] : omp_out += omp_in)\t/* { dg-error \"function or array\" } */\n+}\n+\n+struct A { int a; };\n+#pragma omp declare reduction (| : const struct A : omp_out.a |= omp_in.a)\t/* { dg-error \"const, volatile or restrict\" } */\n+#pragma omp declare reduction (+ : __const struct A : omp_out.a += omp_in.a)\t/* { dg-error \"const, volatile or restrict\" } */\n+typedef volatile struct A T2;\n+#pragma omp declare reduction (min : T2 : omp_out.a += omp_in.a)\t\t/* { dg-error \"const, volatile or restrict\" } */\n+#pragma omp declare reduction (* : struct A *__restrict : omp_out->a *= omp_in->a)/* { dg-error \"const, volatile or restrict\" } */\n+\n+void\n+baz (void)\n+{\n+  #pragma omp declare reduction (| : const struct A : omp_out.a |= omp_in.a)\t/* { dg-error \"const, volatile or restrict\" } */\n+  #pragma omp declare reduction (+ : __const struct A : omp_out.a += omp_in.a)\t/* { dg-error \"const, volatile or restrict\" } */\n+  typedef volatile struct A T3;\n+  #pragma omp declare reduction (min : T3 : omp_out.a += omp_in.a)\t\t/* { dg-error \"const, volatile or restrict\" } */\n+  #pragma omp declare reduction (* : struct A *__restrict : omp_out->a *= omp_in->a)/* { dg-error \"const, volatile or restrict\" } */\n+}"}, {"sha": "87992d7c6ed3b23238837e0b11a0a29a10edeead", "filename": "gcc/testsuite/gcc.dg/gomp/udr-2.c", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fudr-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fudr-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fudr-2.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -0,0 +1,42 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp\" } */\n+\n+struct W { int w; };\n+void init (struct W *, int, int *);\n+int v;\n+#pragma omp declare reduction (foo : long int : omp_out |= v)\t/* { dg-error \"combiner refers to variable\" } */\n+#pragma omp declare reduction (foo : char : omp_out = v)\t/* { dg-error \"combiner refers to variable\" } */\n+typedef short T;\n+#pragma omp declare reduction (foo : T : omp_out += v)\t/* { dg-error \"combiner refers to variable\" } */\n+#pragma omp declare reduction (foo : int : v *= omp_in)\t/* { dg-error \"combiner refers to variable\" } */\n+#pragma omp declare reduction (foo : struct W : omp_out.w *= omp_in.w + v) /* { dg-error \"combiner refers to variable\" } */\n+\n+void\n+foo (int v)\n+{\n+  #pragma omp declare reduction (foo : long int : omp_out |= v)\t/* { dg-error \"combiner refers to variable\" } */\n+  #pragma omp declare reduction (foo : char : omp_out = v)\t/* { dg-error \"combiner refers to variable\" } */\n+  #pragma omp declare reduction (foo : T : omp_out += v)\t/* { dg-error \"combiner refers to variable\" } */\n+  #pragma omp declare reduction (foo : int : v *= omp_in)\t/* { dg-error \"combiner refers to variable\" } */\n+  #pragma omp declare reduction (foo : struct W : omp_out.w *= omp_in.w + v) /* { dg-error \"combiner refers to variable\" } */\n+}\n+\n+#pragma omp declare reduction (bar : long int : omp_out |= omp_in) initializer (omp_priv = v) /* { dg-error \"initializer refers to variable\" } */\n+#pragma omp declare reduction (bar : char : omp_out += omp_in) initializer (omp_priv = ((char) v)) /* { dg-error \"initializer refers to variable\" } */\n+#pragma omp declare reduction (bar : T : omp_out += omp_in) initializer (omp_priv = (short) v) /* { dg-error \"initializer refers to variable\" } */\n+#pragma omp declare reduction (bar : _Complex double : omp_out *= omp_in) initializer (omp_priv = (v)) /* { dg-error \"initializer refers to variable\" } */\n+#pragma omp declare reduction (bar : struct W : omp_out.w *= omp_in.w) initializer (omp_priv = { v } ) /* { dg-error \"initializer refers to variable\" } */\n+#pragma omp declare reduction (bar2 : struct W : omp_out.w *= omp_in.w) initializer (init (&omp_priv, v, (int *) 0)) /* { dg-error \"initializer refers to variable\" } */\n+#pragma omp declare reduction (bar3 : struct W : omp_out.w *= omp_in.w) initializer (init (&omp_priv, 0, &v)) /* { dg-error \"initializer refers to variable\" } */\n+\n+void\n+bar (int v)\n+{\n+  #pragma omp declare reduction (bar : long int : omp_out |= omp_in) initializer (omp_priv = v) /* { dg-error \"initializer refers to variable\" } */\n+  #pragma omp declare reduction (bar : char : omp_out += omp_in) initializer (omp_priv = ((char) v)) /* { dg-error \"initializer refers to variable\" } */\n+  #pragma omp declare reduction (bar : T : omp_out += omp_in) initializer (omp_priv = (short) v) /* { dg-error \"initializer refers to variable\" } */\n+  #pragma omp declare reduction (bar : _Complex double : omp_out *= omp_in) initializer (omp_priv = (v)) /* { dg-error \"initializer refers to variable\" } */\n+  #pragma omp declare reduction (bar : struct W : omp_out.w *= omp_in.w) initializer (omp_priv = { v }) /* { dg-error \"initializer refers to variable\" } */\n+  #pragma omp declare reduction (bar2 : struct W : omp_out.w *= omp_in.w) initializer (init (&omp_priv, v, (int *) 0)) /* { dg-error \"initializer refers to variable\" } */\n+  #pragma omp declare reduction (bar3 : struct W : omp_out.w *= omp_in.w) initializer (init (&omp_priv, 0, &v)) /* { dg-error \"initializer refers to variable\" } */\n+}"}, {"sha": "bdfcce1d0b65eb526a0eb1b5ddb804a5d7de24b3", "filename": "gcc/testsuite/gcc.dg/gomp/udr-3.c", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fudr-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fudr-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fudr-3.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -0,0 +1,77 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp\" } */\n+\n+struct S { int s; };\n+struct T { int t; };\n+struct U { int u; };\n+\n+#pragma omp declare reduction (+: struct S: omp_out.s += omp_in.s)\n+#pragma omp declare reduction (*: struct S: omp_out.s *= omp_in.s) \\\n+\t\t    initializer (omp_priv = {1})\n+#pragma omp declare reduction (foo: struct S: omp_out.s += omp_in.s)\n+\n+void\n+f1 ()\n+{\n+  struct S s, s2;\n+  struct T t;\n+  #pragma omp declare reduction (+: struct T: omp_out.t += omp_in.t)\n+  #pragma omp parallel reduction (+: t) reduction (foo: s) reduction (*: s2)\n+  s.s = 1, t.t = 1, s2.s = 2;\n+  #pragma omp parallel reduction (+: s)\n+  s.s = 1;\n+}\n+\n+void bar (struct S *);\n+\n+void\n+f2 ()\n+{\n+  #pragma omp declare reduction (foo: struct S: omp_out.s += omp_in.s) initializer (bar (&omp_priv))\n+  #pragma omp declare reduction (bar: struct S: omp_out.s += omp_in.s) initializer (bar (&omp_orig)) /* { dg-error \"one of the initializer call arguments should be\" } */\n+}\n+\n+#pragma omp declare reduction (+: struct U: omp_out.u *= omp_in.u)\t\t/* { dg-error \"previous\" } */\n+#pragma omp declare reduction (+: struct U: omp_out.u += omp_in.u)\t\t/* { dg-error \"redeclaration of\" } */\n+\n+void\n+f3 ()\n+{\n+  #pragma omp declare reduction (f3: struct U: omp_out.u *= omp_in.u)\t\t/* { dg-error \"previous\" } */\n+  #pragma omp declare reduction (f3: struct U: omp_out.u += omp_in.u)\t\t/* { dg-error \"redeclaration of\" } */\n+}\n+\n+struct V\n+{\n+  #pragma omp declare reduction (bar: struct S: omp_out.s *= omp_in.s)\t\t/* { dg-error \"not at file or block scope\" } */\n+  #pragma omp declare reduction (bar: struct S: omp_out.s += omp_in.s)\t\t/* { dg-error \"not at file or block scope\" } */\n+};\n+\n+#pragma omp declare reduction (n3: long: omp_out += omp_in)\t\t/* { dg-error \"previous\" } */\n+#pragma omp declare reduction (n3: long int: omp_out += omp_in)\t\t/* { dg-error \"redeclaration of\" } */\n+#pragma omp declare reduction (n3: short unsigned: omp_out += omp_in)\n+#pragma omp declare reduction (n3: short int: omp_out += omp_in)\n+\n+void\n+f4 (void)\n+{\n+  #pragma omp declare reduction (f4: long: omp_out += omp_in)\t\t/* { dg-error \"previous\" } */\n+  #pragma omp declare reduction (f4: long int: omp_out += omp_in)\t/* { dg-error \"redeclaration of\" } */\n+  #pragma omp declare reduction (f4: short unsigned: omp_out += omp_in)\n+  #pragma omp declare reduction (f4: short int: omp_out += omp_in)\n+}\n+\n+void\n+f5 (void)\n+{\n+  #pragma omp declare reduction (+: struct S: omp_out.s += omp_in.s) initializer (omp_priv) /* { dg-error \"expected\" } */\n+  #pragma omp declare reduction (+: struct T: omp_out.t += omp_in.t) initializer (omp_priv ()) /* { dg-error \"expected\" } */\n+}\n+\n+void\n+f6 (a, b)\n+#pragma omp declare reduction (bar: struct S: omp_out.s *= omp_in.s)\t/* { dg-error \"expected declaration specifiers before\" } */\n+  int a;\n+  int b;\n+{\n+}"}, {"sha": "3758f91e8511d776dd28a5ebbe3cf07461ec8d9f", "filename": "gcc/testsuite/gcc.dg/gomp/udr-4.c", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fudr-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fudr-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fudr-4.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -0,0 +1,6 @@\n+/* { dg-do compile } */\n+\n+struct S;\n+#pragma omp declare reduction (+:struct S:omp_out.s += omp_in.s) /* { dg-error \"invalid use of undefined type\" } */\n+struct S { int s; };\n+#pragma omp declare reduction (*:struct S:omp_out.s *= omp_in.s)"}, {"sha": "a580a3baf663cee140eb241da394e945f9860d57", "filename": "gcc/testsuite/gfortran.dg/gomp/appendix-a/a.35.5.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.35.5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.35.5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.35.5.f90?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -6,7 +6,7 @@ SUBROUTINE WRONG5(N)\n !$OMP CRITICAL\n             CALL WORK(N,1)\n ! incorrect nesting of barrier region in a critical region\n-!$OMP BARRIER\n+!$OMP BARRIER\t! { dg-error \"region may not be closely nested inside of\" }\n             CALL WORK(N,2)\n !$OMP END CRITICAL\n !$OMP END PARALLEL"}, {"sha": "8b6679177473eef0a0723d3139578b2545929606", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -611,14 +611,23 @@ make_edges (void)\n \t    case GIMPLE_OMP_TASK:\n \t    case GIMPLE_OMP_FOR:\n \t    case GIMPLE_OMP_SINGLE:\n+\t    case GIMPLE_OMP_TEAMS:\n \t    case GIMPLE_OMP_MASTER:\n+\t    case GIMPLE_OMP_TASKGROUP:\n \t    case GIMPLE_OMP_ORDERED:\n \t    case GIMPLE_OMP_CRITICAL:\n \t    case GIMPLE_OMP_SECTION:\n \t      cur_region = new_omp_region (bb, code, cur_region);\n \t      fallthru = true;\n \t      break;\n \n+\t    case GIMPLE_OMP_TARGET:\n+\t      cur_region = new_omp_region (bb, code, cur_region);\n+\t      fallthru = true;\n+\t      if (gimple_omp_target_kind (last) == GF_OMP_TARGET_KIND_UPDATE)\n+\t\tcur_region = cur_region->outer;\n+\t      break;\n+\n \t    case GIMPLE_OMP_SECTIONS:\n \t      cur_region = new_omp_region (bb, code, cur_region);\n \t      fallthru = true;"}, {"sha": "a14c7e079b30d50c5294cf813fdfc0fb76320ece", "filename": "gcc/tree-core.h", "status": "modified", "additions": 98, "deletions": 3, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftree-core.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftree-core.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-core.h?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -243,9 +243,27 @@ enum omp_clause_code {\n   /* OpenMP clause: linear (variable-list[:linear-step]).  */\n   OMP_CLAUSE_LINEAR,\n \n+  /* OpenMP clause: aligned (variable-list[:alignment]).  */\n+  OMP_CLAUSE_ALIGNED,\n+\n+  /* OpenMP clause: depend ({in,out,inout}:variable-list).  */\n+  OMP_CLAUSE_DEPEND,\n+\n   /* OpenMP clause: uniform (argument-list).  */\n   OMP_CLAUSE_UNIFORM,\n \n+  /* OpenMP clause: from (variable-list).  */\n+  OMP_CLAUSE_FROM,\n+\n+  /* OpenMP clause: to (variable-list).  */\n+  OMP_CLAUSE_TO,\n+\n+  /* OpenMP clause: map ({alloc:,to:,from:,tofrom:,}variable-list).  */\n+  OMP_CLAUSE_MAP,\n+\n+  /* Internal clause: temporary for combined loops expansion.  */\n+  OMP_CLAUSE__LOOPTEMP_,\n+\n   /* OpenMP clause: if (scalar-expression).  */\n   OMP_CLAUSE_IF,\n \n@@ -276,9 +294,45 @@ enum omp_clause_code {\n   /* OpenMP clause: mergeable.  */\n   OMP_CLAUSE_MERGEABLE,\n \n+  /* OpenMP clause: device (integer-expression).  */\n+  OMP_CLAUSE_DEVICE,\n+\n+  /* OpenMP clause: dist_schedule (static[:chunk-size]).  */\n+  OMP_CLAUSE_DIST_SCHEDULE,\n+\n+  /* OpenMP clause: inbranch.  */\n+  OMP_CLAUSE_INBRANCH,\n+\n+  /* OpenMP clause: notinbranch.  */\n+  OMP_CLAUSE_NOTINBRANCH,\n+\n+  /* OpenMP clause: num_teams(integer-expression).  */\n+  OMP_CLAUSE_NUM_TEAMS,\n+\n+  /* OpenMP clause: thread_limit(integer-expression).  */\n+  OMP_CLAUSE_THREAD_LIMIT,\n+\n+  /* OpenMP clause: proc_bind ({master,close,spread}).  */\n+  OMP_CLAUSE_PROC_BIND,\n+\n   /* OpenMP clause: safelen (constant-integer-expression).  */\n   OMP_CLAUSE_SAFELEN,\n \n+  /* OpenMP clause: simdlen (constant-integer-expression).  */\n+  OMP_CLAUSE_SIMDLEN,\n+\n+  /* OpenMP clause: for.  */\n+  OMP_CLAUSE_FOR,\n+\n+  /* OpenMP clause: parallel.  */\n+  OMP_CLAUSE_PARALLEL,\n+\n+  /* OpenMP clause: sections.  */\n+  OMP_CLAUSE_SECTIONS,\n+\n+  /* OpenMP clause: taskgroup.  */\n+  OMP_CLAUSE_TASKGROUP,\n+\n   /* Internally used only clause, holding SIMD uid.  */\n   OMP_CLAUSE__SIMDUID_\n };\n@@ -784,6 +838,12 @@ struct GTY(()) tree_base {\n        OMP_CLAUSE_LINEAR_NO_COPYIN in\n \t   OMP_CLAUSE_LINEAR\n \n+       OMP_CLAUSE_MAP_ZERO_BIAS_ARRAY_SECTION in\n+\t   OMP_CLAUSE_MAP\n+\n+       OMP_CLAUSE_REDUCTION_OMP_ORIG_REF in\n+\t   OMP_CLAUSE_REDUCTION\n+\n        TRANSACTION_EXPR_RELAXED in\n \t   TRANSACTION_EXPR\n \n@@ -801,6 +861,9 @@ struct GTY(()) tree_base {\n        OMP_PARALLEL_COMBINED in\n            OMP_PARALLEL\n \n+       OMP_ATOMIC_SEQ_CST in\n+\t   OMP_ATOMIC*\n+\n        OMP_CLAUSE_PRIVATE_OUTER_REF in\n \t   OMP_CLAUSE_PRIVATE\n \n@@ -1020,6 +1083,35 @@ struct GTY(()) tree_constructor {\n   vec<constructor_elt, va_gc> *elts;\n };\n \n+enum omp_clause_depend_kind\n+{\n+  OMP_CLAUSE_DEPEND_IN,\n+  OMP_CLAUSE_DEPEND_OUT,\n+  OMP_CLAUSE_DEPEND_INOUT\n+};\n+\n+enum omp_clause_map_kind\n+{\n+  OMP_CLAUSE_MAP_ALLOC,\n+  OMP_CLAUSE_MAP_TO,\n+  OMP_CLAUSE_MAP_FROM,\n+  OMP_CLAUSE_MAP_TOFROM,\n+  /* The following kind is an internal only map kind, used for pointer based\n+     array sections.  OMP_CLAUSE_SIZE for these is not the pointer size,\n+     which is implicitly POINTER_SIZE / BITS_PER_UNIT, but the bias.  */\n+  OMP_CLAUSE_MAP_POINTER\n+};\n+\n+enum omp_clause_proc_bind_kind\n+{\n+  /* Numbers should match omp_proc_bind_t enum in omp.h.  */\n+  OMP_CLAUSE_PROC_BIND_FALSE = 0,\n+  OMP_CLAUSE_PROC_BIND_TRUE = 1,\n+  OMP_CLAUSE_PROC_BIND_MASTER = 2,\n+  OMP_CLAUSE_PROC_BIND_CLOSE = 3,\n+  OMP_CLAUSE_PROC_BIND_SPREAD = 4\n+};\n+\n struct GTY(()) tree_exp {\n   struct tree_typed typed;\n   location_t locus;\n@@ -1077,9 +1169,12 @@ struct GTY(()) tree_omp_clause {\n   location_t locus;\n   enum omp_clause_code code;\n   union omp_clause_subcode {\n-    enum omp_clause_default_kind  default_kind;\n-    enum omp_clause_schedule_kind schedule_kind;\n-    enum tree_code                reduction_code;\n+    enum omp_clause_default_kind   default_kind;\n+    enum omp_clause_schedule_kind  schedule_kind;\n+    enum omp_clause_depend_kind    depend_kind;\n+    enum omp_clause_map_kind       map_kind;\n+    enum omp_clause_proc_bind_kind proc_bind_kind;\n+    enum tree_code                 reduction_code;\n   } GTY ((skip)) subcode;\n \n   /* The gimplification of OMP_CLAUSE_REDUCTION_{INIT,MERGE} for omp-low's"}, {"sha": "2221b9c54869f36fcfc84b788ca96396de92ee1c", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -1345,6 +1345,11 @@ remap_gimple_stmt (gimple stmt, copy_body_data *id)\n \t  copy = gimple_build_omp_master (s1);\n \t  break;\n \n+\tcase GIMPLE_OMP_TASKGROUP:\n+\t  s1 = remap_gimple_seq (gimple_omp_body (stmt), id);\n+\t  copy = gimple_build_omp_taskgroup (s1);\n+\t  break;\n+\n \tcase GIMPLE_OMP_ORDERED:\n \t  s1 = remap_gimple_seq (gimple_omp_body (stmt), id);\n \t  copy = gimple_build_omp_ordered (s1);\n@@ -1367,6 +1372,19 @@ remap_gimple_stmt (gimple stmt, copy_body_data *id)\n \t           (s1, gimple_omp_single_clauses (stmt));\n \t  break;\n \n+\tcase GIMPLE_OMP_TARGET:\n+\t  s1 = remap_gimple_seq (gimple_omp_body (stmt), id);\n+\t  copy = gimple_build_omp_target\n+\t\t   (s1, gimple_omp_target_kind (stmt),\n+\t\t    gimple_omp_target_clauses (stmt));\n+\t  break;\n+\n+\tcase GIMPLE_OMP_TEAMS:\n+\t  s1 = remap_gimple_seq (gimple_omp_body (stmt), id);\n+\t  copy = gimple_build_omp_teams\n+\t\t   (s1, gimple_omp_teams_clauses (stmt));\n+\t  break;\n+\n \tcase GIMPLE_OMP_CRITICAL:\n \t  s1 = remap_gimple_seq (gimple_omp_body (stmt), id);\n \t  copy\n@@ -3831,10 +3849,13 @@ estimate_num_insns (gimple stmt, eni_weights *weights)\n     case GIMPLE_OMP_TASK:\n     case GIMPLE_OMP_CRITICAL:\n     case GIMPLE_OMP_MASTER:\n+    case GIMPLE_OMP_TASKGROUP:\n     case GIMPLE_OMP_ORDERED:\n     case GIMPLE_OMP_SECTION:\n     case GIMPLE_OMP_SECTIONS:\n     case GIMPLE_OMP_SINGLE:\n+    case GIMPLE_OMP_TARGET:\n+    case GIMPLE_OMP_TEAMS:\n       return (weights->omp_cost\n               + estimate_num_insns_seq (gimple_omp_body (stmt), weights));\n "}, {"sha": "7582289c1c2c0d3aafaa91f1de3a195d0a83aac4", "filename": "gcc/tree-nested.c", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftree-nested.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftree-nested.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nested.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -1291,8 +1291,25 @@ convert_nonlocal_reference_stmt (gimple_stmt_iterator *gsi, bool *handled_ops_p,\n       info->suppress_expansion = save_suppress;\n       break;\n \n+    case GIMPLE_OMP_TARGET:\n+      save_suppress = info->suppress_expansion;\n+      convert_nonlocal_omp_clauses (gimple_omp_target_clauses_ptr (stmt), wi);\n+      walk_body (convert_nonlocal_reference_stmt, convert_nonlocal_reference_op,\n+\t\t info, gimple_omp_body_ptr (stmt));\n+      info->suppress_expansion = save_suppress;\n+      break;\n+\n+    case GIMPLE_OMP_TEAMS:\n+      save_suppress = info->suppress_expansion;\n+      convert_nonlocal_omp_clauses (gimple_omp_teams_clauses_ptr (stmt), wi);\n+      walk_body (convert_nonlocal_reference_stmt, convert_nonlocal_reference_op,\n+\t\t info, gimple_omp_body_ptr (stmt));\n+      info->suppress_expansion = save_suppress;\n+      break;\n+\n     case GIMPLE_OMP_SECTION:\n     case GIMPLE_OMP_MASTER:\n+    case GIMPLE_OMP_TASKGROUP:\n     case GIMPLE_OMP_ORDERED:\n       walk_body (convert_nonlocal_reference_stmt, convert_nonlocal_reference_op,\n \t         info, gimple_omp_body_ptr (stmt));\n@@ -1714,8 +1731,25 @@ convert_local_reference_stmt (gimple_stmt_iterator *gsi, bool *handled_ops_p,\n       info->suppress_expansion = save_suppress;\n       break;\n \n+    case GIMPLE_OMP_TARGET:\n+      save_suppress = info->suppress_expansion;\n+      convert_local_omp_clauses (gimple_omp_target_clauses_ptr (stmt), wi);\n+      walk_body (convert_local_reference_stmt, convert_local_reference_op,\n+\t\t info, gimple_omp_body_ptr (stmt));\n+      info->suppress_expansion = save_suppress;\n+      break;\n+\n+    case GIMPLE_OMP_TEAMS:\n+      save_suppress = info->suppress_expansion;\n+      convert_local_omp_clauses (gimple_omp_teams_clauses_ptr (stmt), wi);\n+      walk_body (convert_local_reference_stmt, convert_local_reference_op,\n+\t\t info, gimple_omp_body_ptr (stmt));\n+      info->suppress_expansion = save_suppress;\n+      break;\n+\n     case GIMPLE_OMP_SECTION:\n     case GIMPLE_OMP_MASTER:\n+    case GIMPLE_OMP_TASKGROUP:\n     case GIMPLE_OMP_ORDERED:\n       walk_body (convert_local_reference_stmt, convert_local_reference_op,\n \t\t info, gimple_omp_body_ptr (stmt));\n@@ -2071,7 +2105,10 @@ convert_gimple_call (gimple_stmt_iterator *gsi, bool *handled_ops_p,\n     case GIMPLE_OMP_SECTIONS:\n     case GIMPLE_OMP_SECTION:\n     case GIMPLE_OMP_SINGLE:\n+    case GIMPLE_OMP_TARGET:\n+    case GIMPLE_OMP_TEAMS:\n     case GIMPLE_OMP_MASTER:\n+    case GIMPLE_OMP_TASKGROUP:\n     case GIMPLE_OMP_ORDERED:\n     case GIMPLE_OMP_CRITICAL:\n       walk_body (convert_gimple_call, NULL, info, gimple_omp_body_ptr (stmt));"}, {"sha": "df0f8b52ec6acf495c325208ec22b5b953454a59", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 257, "deletions": 47, "changes": 304, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -319,6 +319,9 @@ dump_omp_clause (pretty_printer *buffer, tree clause, int spc, int flags)\n     case OMP_CLAUSE_UNIFORM:\n       name = \"uniform\";\n       goto print_remap;\n+    case OMP_CLAUSE__LOOPTEMP_:\n+      name = \"_looptemp_\";\n+      goto print_remap;\n   print_remap:\n       pp_string (buffer, name);\n       pp_left_paren (buffer);\n@@ -329,24 +332,28 @@ dump_omp_clause (pretty_printer *buffer, tree clause, int spc, int flags)\n \n     case OMP_CLAUSE_REDUCTION:\n       pp_string (buffer, \"reduction(\");\n-      pp_string (buffer, op_symbol_code (OMP_CLAUSE_REDUCTION_CODE (clause)));\n-      pp_colon (buffer);\n+      if (OMP_CLAUSE_REDUCTION_CODE (clause) != ERROR_MARK)\n+\t{\n+\t  pp_string (buffer,\n+\t\t     op_symbol_code (OMP_CLAUSE_REDUCTION_CODE (clause)));\n+\t  pp_colon (buffer);\n+\t}\n       dump_generic_node (buffer, OMP_CLAUSE_DECL (clause),\n-\t  spc, flags, false);\n+\t\t\t spc, flags, false);\n       pp_right_paren (buffer);\n       break;\n \n     case OMP_CLAUSE_IF:\n       pp_string (buffer, \"if(\");\n       dump_generic_node (buffer, OMP_CLAUSE_IF_EXPR (clause),\n-\t  spc, flags, false);\n+\t\t\t spc, flags, false);\n       pp_right_paren (buffer);\n       break;\n \n     case OMP_CLAUSE_NUM_THREADS:\n       pp_string (buffer, \"num_threads(\");\n       dump_generic_node (buffer, OMP_CLAUSE_NUM_THREADS_EXPR (clause),\n-\t  spc, flags, false);\n+\t\t\t spc, flags, false);\n       pp_right_paren (buffer);\n       break;\n \n@@ -385,30 +392,29 @@ dump_omp_clause (pretty_printer *buffer, tree clause, int spc, int flags)\n       pp_string (buffer, \"schedule(\");\n       switch (OMP_CLAUSE_SCHEDULE_KIND (clause))\n \t{\n-      case OMP_CLAUSE_SCHEDULE_STATIC:\n-\tpp_string (buffer, \"static\");\n-\tbreak;\n-      case OMP_CLAUSE_SCHEDULE_DYNAMIC:\n-\tpp_string (buffer, \"dynamic\");\n-\tbreak;\n-      case OMP_CLAUSE_SCHEDULE_GUIDED:\n-\tpp_string (buffer, \"guided\");\n-\tbreak;\n-      case OMP_CLAUSE_SCHEDULE_RUNTIME:\n-\tpp_string (buffer, \"runtime\");\n-\tbreak;\n-      case OMP_CLAUSE_SCHEDULE_AUTO:\n-\tpp_string (buffer, \"auto\");\n-\tbreak;\n-      default:\n-\tgcc_unreachable ();\n+\tcase OMP_CLAUSE_SCHEDULE_STATIC:\n+\t  pp_string (buffer, \"static\");\n+\t  break;\n+\tcase OMP_CLAUSE_SCHEDULE_DYNAMIC:\n+\t  pp_string (buffer, \"dynamic\");\n+\t  break;\n+\tcase OMP_CLAUSE_SCHEDULE_GUIDED:\n+\t  pp_string (buffer, \"guided\");\n+\t  break;\n+\tcase OMP_CLAUSE_SCHEDULE_RUNTIME:\n+\t  pp_string (buffer, \"runtime\");\n+\t  break;\n+\tcase OMP_CLAUSE_SCHEDULE_AUTO:\n+\t  pp_string (buffer, \"auto\");\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n \t}\n       if (OMP_CLAUSE_SCHEDULE_CHUNK_EXPR (clause))\n \t{\n \t  pp_comma (buffer);\n-\t  dump_generic_node (buffer,\n-\t      OMP_CLAUSE_SCHEDULE_CHUNK_EXPR (clause),\n-\t      spc, flags, false);\n+\t  dump_generic_node (buffer, OMP_CLAUSE_SCHEDULE_CHUNK_EXPR (clause),\n+\t\t\t     spc, flags, false);\n \t}\n       pp_right_paren (buffer);\n       break;\n@@ -419,16 +425,15 @@ dump_omp_clause (pretty_printer *buffer, tree clause, int spc, int flags)\n \n     case OMP_CLAUSE_COLLAPSE:\n       pp_string (buffer, \"collapse(\");\n-      dump_generic_node (buffer,\n-\t\t\t OMP_CLAUSE_COLLAPSE_EXPR (clause),\n+      dump_generic_node (buffer, OMP_CLAUSE_COLLAPSE_EXPR (clause),\n \t\t\t spc, flags, false);\n       pp_right_paren (buffer);\n       break;\n \n     case OMP_CLAUSE_FINAL:\n       pp_string (buffer, \"final(\");\n       dump_generic_node (buffer, OMP_CLAUSE_FINAL_EXPR (clause),\n-\t  spc, flags, false);\n+\t\t\t spc, flags, false);\n       pp_right_paren (buffer);\n       break;\n \n@@ -440,24 +445,187 @@ dump_omp_clause (pretty_printer *buffer, tree clause, int spc, int flags)\n       pp_string (buffer, \"linear(\");\n       dump_generic_node (buffer, OMP_CLAUSE_DECL (clause),\n \t\t\t spc, flags, false);\n-      pp_character (buffer, ':');\n+      pp_colon (buffer);\n       dump_generic_node (buffer, OMP_CLAUSE_LINEAR_STEP (clause),\n \t\t\t spc, flags, false);\n-      pp_character (buffer, ')');\n+      pp_right_paren (buffer);\n+      break;\n+\n+    case OMP_CLAUSE_ALIGNED:\n+      pp_string (buffer, \"aligned(\");\n+      dump_generic_node (buffer, OMP_CLAUSE_DECL (clause),\n+\t\t\t spc, flags, false);\n+      if (OMP_CLAUSE_ALIGNED_ALIGNMENT (clause))\n+\t{\n+\t  pp_colon (buffer);\n+\t  dump_generic_node (buffer, OMP_CLAUSE_ALIGNED_ALIGNMENT (clause),\n+\t\t\t     spc, flags, false);\n+\t}\n+      pp_right_paren (buffer);\n+      break;\n+\n+    case OMP_CLAUSE_DEPEND:\n+      pp_string (buffer, \"depend(\");\n+      switch (OMP_CLAUSE_DEPEND_KIND (clause))\n+\t{\n+\tcase OMP_CLAUSE_DEPEND_IN:\n+\t  pp_string (buffer, \"in\");\n+\t  break;\n+\tcase OMP_CLAUSE_DEPEND_OUT:\n+\t  pp_string (buffer, \"out\");\n+\t  break;\n+\tcase OMP_CLAUSE_DEPEND_INOUT:\n+\t  pp_string (buffer, \"inout\");\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+      pp_colon (buffer);\n+      dump_generic_node (buffer, OMP_CLAUSE_DECL (clause),\n+\t\t\t spc, flags, false);\n+      pp_right_paren (buffer);\n+      break;\n+\n+    case OMP_CLAUSE_MAP:\n+      pp_string (buffer, \"map(\");\n+      switch (OMP_CLAUSE_MAP_KIND (clause))\n+\t{\n+\tcase OMP_CLAUSE_MAP_ALLOC:\n+\tcase OMP_CLAUSE_MAP_POINTER:\n+\t  pp_string (buffer, \"alloc\");\n+\t  break;\n+\tcase OMP_CLAUSE_MAP_TO:\n+\t  pp_string (buffer, \"to\");\n+\t  break;\n+\tcase OMP_CLAUSE_MAP_FROM:\n+\t  pp_string (buffer, \"from\");\n+\t  break;\n+\tcase OMP_CLAUSE_MAP_TOFROM:\n+\t  pp_string (buffer, \"tofrom\");\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+      pp_colon (buffer);\n+      dump_generic_node (buffer, OMP_CLAUSE_DECL (clause),\n+\t\t\t spc, flags, false);\n+     print_clause_size:\n+      if (OMP_CLAUSE_SIZE (clause))\n+\t{\n+\t  if (OMP_CLAUSE_CODE (clause) == OMP_CLAUSE_MAP\n+\t      && OMP_CLAUSE_MAP_KIND (clause) == OMP_CLAUSE_MAP_POINTER)\n+\t    pp_string (buffer, \" [pointer assign, bias: \");\n+\t  else\n+\t    pp_string (buffer, \" [len: \");\n+\t  dump_generic_node (buffer, OMP_CLAUSE_SIZE (clause),\n+\t\t\t     spc, flags, false);\n+\t  pp_right_bracket (buffer);\n+\t}\n+      pp_right_paren (buffer);\n+      break;\n+\n+    case OMP_CLAUSE_FROM:\n+      pp_string (buffer, \"from(\");\n+      dump_generic_node (buffer, OMP_CLAUSE_DECL (clause),\n+\t\t\t spc, flags, false);\n+      goto print_clause_size;\n+\n+    case OMP_CLAUSE_TO:\n+      pp_string (buffer, \"to(\");\n+      dump_generic_node (buffer, OMP_CLAUSE_DECL (clause),\n+\t\t\t spc, flags, false);\n+      goto print_clause_size;\n+\n+    case OMP_CLAUSE_NUM_TEAMS:\n+      pp_string (buffer, \"num_teams(\");\n+      dump_generic_node (buffer, OMP_CLAUSE_NUM_TEAMS_EXPR (clause),\n+\t\t\t spc, flags, false);\n+      pp_right_paren (buffer);\n+      break;\n+\n+    case OMP_CLAUSE_THREAD_LIMIT:\n+      pp_string (buffer, \"thread_limit(\");\n+      dump_generic_node (buffer, OMP_CLAUSE_THREAD_LIMIT_EXPR (clause),\n+\t\t\t spc, flags, false);\n+      pp_right_paren (buffer);\n+      break;\n+\n+    case OMP_CLAUSE_DEVICE:\n+      pp_string (buffer, \"device(\");\n+      dump_generic_node (buffer, OMP_CLAUSE_DEVICE_ID (clause),\n+\t\t\t spc, flags, false);\n+      pp_right_paren (buffer);\n+      break;\n+\n+    case OMP_CLAUSE_DIST_SCHEDULE:\n+      pp_string (buffer, \"dist_schedule(static\");\n+      if (OMP_CLAUSE_DIST_SCHEDULE_CHUNK_EXPR (clause))\n+\t{\n+\t  pp_comma (buffer);\n+\t  dump_generic_node (buffer,\n+\t\t\t     OMP_CLAUSE_DIST_SCHEDULE_CHUNK_EXPR (clause),\n+\t\t\t     spc, flags, false);\n+\t}\n+      pp_right_paren (buffer);\n+      break;\n+\n+    case OMP_CLAUSE_PROC_BIND:\n+      pp_string (buffer, \"proc_bind(\");\n+      switch (OMP_CLAUSE_PROC_BIND_KIND (clause))\n+\t{\n+\tcase OMP_CLAUSE_PROC_BIND_MASTER:\n+\t  pp_string (buffer, \"master\");\n+\t  break;\n+\tcase OMP_CLAUSE_PROC_BIND_CLOSE:\n+\t  pp_string (buffer, \"close\");\n+\t  break;\n+\tcase OMP_CLAUSE_PROC_BIND_SPREAD:\n+\t  pp_string (buffer, \"spread\");\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+      pp_right_paren (buffer);\n       break;\n \n     case OMP_CLAUSE_SAFELEN:\n       pp_string (buffer, \"safelen(\");\n       dump_generic_node (buffer, OMP_CLAUSE_SAFELEN_EXPR (clause),\n \t\t\t spc, flags, false);\n-      pp_character (buffer, ')');\n+      pp_right_paren (buffer);\n+      break;\n+\n+    case OMP_CLAUSE_SIMDLEN:\n+      pp_string (buffer, \"simdlen(\");\n+      dump_generic_node (buffer, OMP_CLAUSE_SIMDLEN_EXPR (clause),\n+\t\t\t spc, flags, false);\n+      pp_right_paren (buffer);\n       break;\n \n     case OMP_CLAUSE__SIMDUID_:\n       pp_string (buffer, \"_simduid_(\");\n       dump_generic_node (buffer, OMP_CLAUSE__SIMDUID__DECL (clause),\n \t\t\t spc, flags, false);\n-      pp_character (buffer, ')');\n+      pp_right_paren (buffer);\n+      break;\n+\n+    case OMP_CLAUSE_INBRANCH:\n+      pp_string (buffer, \"inbranch\");\n+      break;\n+    case OMP_CLAUSE_NOTINBRANCH:\n+      pp_string (buffer, \"notinbranch\");\n+      break;\n+    case OMP_CLAUSE_FOR:\n+      pp_string (buffer, \"for\");\n+      break;\n+    case OMP_CLAUSE_PARALLEL:\n+      pp_string (buffer, \"parallel\");\n+      break;\n+    case OMP_CLAUSE_SECTIONS:\n+      pp_string (buffer, \"sections\");\n+      break;\n+    case OMP_CLAUSE_TASKGROUP:\n+      pp_string (buffer, \"taskgroup\");\n       break;\n \n     default:\n@@ -2192,6 +2360,31 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n       pp_string (buffer, \"#pragma omp simd\");\n       goto dump_omp_loop;\n \n+    case OMP_DISTRIBUTE:\n+      pp_string (buffer, \"#pragma omp distribute\");\n+      goto dump_omp_loop;\n+\n+    case OMP_TEAMS:\n+      pp_string (buffer, \"#pragma omp teams\");\n+      dump_omp_clauses (buffer, OMP_TEAMS_CLAUSES (node), spc, flags);\n+      goto dump_omp_body;\n+\n+    case OMP_TARGET_DATA:\n+      pp_string (buffer, \"#pragma omp target data\");\n+      dump_omp_clauses (buffer, OMP_TARGET_DATA_CLAUSES (node), spc, flags);\n+      goto dump_omp_body;\n+\n+    case OMP_TARGET:\n+      pp_string (buffer, \"#pragma omp target\");\n+      dump_omp_clauses (buffer, OMP_TARGET_CLAUSES (node), spc, flags);\n+      goto dump_omp_body;\n+\n+    case OMP_TARGET_UPDATE:\n+      pp_string (buffer, \"#pragma omp target update\");\n+      dump_omp_clauses (buffer, OMP_TARGET_UPDATE_CLAUSES (node), spc, flags);\n+      is_expr = false;\n+      break;\n+\n     dump_omp_loop:\n       dump_omp_clauses (buffer, OMP_FOR_CLAUSES (node), spc, flags);\n \n@@ -2208,21 +2401,27 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n \t      dump_generic_node (buffer, OMP_FOR_PRE_BODY (node),\n \t\t  spc, flags, false);\n \t    }\n-\t  spc -= 2;\n-\t  for (i = 0; i < TREE_VEC_LENGTH (OMP_FOR_INIT (node)); i++)\n+\t  if (OMP_FOR_INIT (node))\n \t    {\n-\t      spc += 2;\n-\t      newline_and_indent (buffer, spc);\n-\t      pp_string (buffer, \"for (\");\n-\t      dump_generic_node (buffer, TREE_VEC_ELT (OMP_FOR_INIT (node), i),\n-\t\t\t\t spc, flags, false);\n-\t      pp_string (buffer, \"; \");\n-\t      dump_generic_node (buffer, TREE_VEC_ELT (OMP_FOR_COND (node), i),\n-\t\t\t\t spc, flags, false);\n-\t      pp_string (buffer, \"; \");\n-\t      dump_generic_node (buffer, TREE_VEC_ELT (OMP_FOR_INCR (node), i),\n-\t\t\t\t spc, flags, false);\n-\t      pp_right_paren (buffer);\n+\t      spc -= 2;\n+\t      for (i = 0; i < TREE_VEC_LENGTH (OMP_FOR_INIT (node)); i++)\n+\t\t{\n+\t\t  spc += 2;\n+\t\t  newline_and_indent (buffer, spc);\n+\t\t  pp_string (buffer, \"for (\");\n+\t\t  dump_generic_node (buffer,\n+\t\t\t\t     TREE_VEC_ELT (OMP_FOR_INIT (node), i),\n+\t\t\t\t     spc, flags, false);\n+\t\t  pp_string (buffer, \"; \");\n+\t\t  dump_generic_node (buffer,\n+\t\t\t\t     TREE_VEC_ELT (OMP_FOR_COND (node), i),\n+\t\t\t\t     spc, flags, false);\n+\t\t  pp_string (buffer, \"; \");\n+\t\t  dump_generic_node (buffer,\n+\t\t\t\t     TREE_VEC_ELT (OMP_FOR_INCR (node), i),\n+\t\t\t\t     spc, flags, false);\n+\t\t  pp_right_paren (buffer);\n+\t\t}\n \t    }\n \t  if (OMP_FOR_BODY (node))\n \t    {\n@@ -2234,7 +2433,8 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n \t      newline_and_indent (buffer, spc + 2);\n \t      pp_right_brace (buffer);\n \t    }\n-\t  spc -= 2 * TREE_VEC_LENGTH (OMP_FOR_INIT (node)) - 2;\n+\t  if (OMP_FOR_INIT (node))\n+\t    spc -= 2 * TREE_VEC_LENGTH (OMP_FOR_INIT (node)) - 2;\n \t  if (OMP_FOR_PRE_BODY (node))\n \t    {\n \t      spc -= 4;\n@@ -2258,6 +2458,10 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n       pp_string (buffer, \"#pragma omp master\");\n       goto dump_omp_body;\n \n+    case OMP_TASKGROUP:\n+      pp_string (buffer, \"#pragma omp taskgroup\");\n+      goto dump_omp_body;\n+\n     case OMP_ORDERED:\n       pp_string (buffer, \"#pragma omp ordered\");\n       goto dump_omp_body;\n@@ -2276,6 +2480,8 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n \n     case OMP_ATOMIC:\n       pp_string (buffer, \"#pragma omp atomic\");\n+      if (OMP_ATOMIC_SEQ_CST (node))\n+\tpp_string (buffer, \" seq_cst\");\n       newline_and_indent (buffer, spc + 2);\n       dump_generic_node (buffer, TREE_OPERAND (node, 0), spc, flags, false);\n       pp_space (buffer);\n@@ -2286,6 +2492,8 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n \n     case OMP_ATOMIC_READ:\n       pp_string (buffer, \"#pragma omp atomic read\");\n+      if (OMP_ATOMIC_SEQ_CST (node))\n+\tpp_string (buffer, \" seq_cst\");\n       newline_and_indent (buffer, spc + 2);\n       dump_generic_node (buffer, TREE_OPERAND (node, 0), spc, flags, false);\n       pp_space (buffer);\n@@ -2294,6 +2502,8 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n     case OMP_ATOMIC_CAPTURE_OLD:\n     case OMP_ATOMIC_CAPTURE_NEW:\n       pp_string (buffer, \"#pragma omp atomic capture\");\n+      if (OMP_ATOMIC_SEQ_CST (node))\n+\tpp_string (buffer, \" seq_cst\");\n       newline_and_indent (buffer, spc + 2);\n       dump_generic_node (buffer, TREE_OPERAND (node, 0), spc, flags, false);\n       pp_space (buffer);"}, {"sha": "3cce3315ba2938c8eb61804faf852870ed4f16bc", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -1514,16 +1514,19 @@ ref_maybe_used_by_call_p_1 (gimple call, ao_ref *ref)\n \tcase BUILT_IN_GOMP_ATOMIC_START:\n \tcase BUILT_IN_GOMP_ATOMIC_END:\n \tcase BUILT_IN_GOMP_BARRIER:\n+\tcase BUILT_IN_GOMP_BARRIER_CANCEL:\n \tcase BUILT_IN_GOMP_TASKWAIT:\n+\tcase BUILT_IN_GOMP_TASKGROUP_END:\n \tcase BUILT_IN_GOMP_CRITICAL_START:\n \tcase BUILT_IN_GOMP_CRITICAL_END:\n \tcase BUILT_IN_GOMP_CRITICAL_NAME_START:\n \tcase BUILT_IN_GOMP_CRITICAL_NAME_END:\n \tcase BUILT_IN_GOMP_LOOP_END:\n+\tcase BUILT_IN_GOMP_LOOP_END_CANCEL:\n \tcase BUILT_IN_GOMP_ORDERED_START:\n \tcase BUILT_IN_GOMP_ORDERED_END:\n-\tcase BUILT_IN_GOMP_PARALLEL_END:\n \tcase BUILT_IN_GOMP_SECTIONS_END:\n+\tcase BUILT_IN_GOMP_SECTIONS_END_CANCEL:\n \tcase BUILT_IN_GOMP_SINGLE_COPY_START:\n \tcase BUILT_IN_GOMP_SINGLE_COPY_END:\n \t  return true;\n@@ -1858,16 +1861,19 @@ call_may_clobber_ref_p_1 (gimple call, ao_ref *ref)\n \tcase BUILT_IN_GOMP_ATOMIC_START:\n \tcase BUILT_IN_GOMP_ATOMIC_END:\n \tcase BUILT_IN_GOMP_BARRIER:\n+\tcase BUILT_IN_GOMP_BARRIER_CANCEL:\n \tcase BUILT_IN_GOMP_TASKWAIT:\n+\tcase BUILT_IN_GOMP_TASKGROUP_END:\n \tcase BUILT_IN_GOMP_CRITICAL_START:\n \tcase BUILT_IN_GOMP_CRITICAL_END:\n \tcase BUILT_IN_GOMP_CRITICAL_NAME_START:\n \tcase BUILT_IN_GOMP_CRITICAL_NAME_END:\n \tcase BUILT_IN_GOMP_LOOP_END:\n+\tcase BUILT_IN_GOMP_LOOP_END_CANCEL:\n \tcase BUILT_IN_GOMP_ORDERED_START:\n \tcase BUILT_IN_GOMP_ORDERED_END:\n-\tcase BUILT_IN_GOMP_PARALLEL_END:\n \tcase BUILT_IN_GOMP_SECTIONS_END:\n+\tcase BUILT_IN_GOMP_SECTIONS_END_CANCEL:\n \tcase BUILT_IN_GOMP_SINGLE_COPY_START:\n \tcase BUILT_IN_GOMP_SINGLE_COPY_END:\n \t  return true;"}, {"sha": "511972ae313db48cc3eb3651e145c6381cf09be9", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -111,7 +111,8 @@ simduid_to_vf::equal (const value_type *p1, const value_type *p2)\n         D.1737[_7] = stuff;\n \n \n-   This hash maps from the simduid.0 to OMP simd array (D.1737[]).  */\n+   This hash maps from the OMP simd array (D.1737[]) to DECL_UID of\n+   simduid.0.  */\n \n struct simd_array_to_simduid : typed_free_remove<simd_array_to_simduid>\n {"}, {"sha": "dd388602f32e2e28588cc3e747eea16c975dd70b", "filename": "gcc/tree.c", "status": "modified", "additions": 142, "deletions": 0, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -237,7 +237,13 @@ unsigned const char omp_clause_num_ops[] =\n   1, /* OMP_CLAUSE_COPYIN  */\n   1, /* OMP_CLAUSE_COPYPRIVATE  */\n   2, /* OMP_CLAUSE_LINEAR  */\n+  2, /* OMP_CLAUSE_ALIGNED  */\n+  1, /* OMP_CLAUSE_DEPEND  */\n   1, /* OMP_CLAUSE_UNIFORM  */\n+  2, /* OMP_CLAUSE_FROM  */\n+  2, /* OMP_CLAUSE_TO  */\n+  2, /* OMP_CLAUSE_MAP  */\n+  1, /* OMP_CLAUSE__LOOPTEMP_  */\n   1, /* OMP_CLAUSE_IF  */\n   1, /* OMP_CLAUSE_NUM_THREADS  */\n   1, /* OMP_CLAUSE_SCHEDULE  */\n@@ -248,7 +254,19 @@ unsigned const char omp_clause_num_ops[] =\n   0, /* OMP_CLAUSE_UNTIED   */\n   1, /* OMP_CLAUSE_FINAL  */\n   0, /* OMP_CLAUSE_MERGEABLE  */\n+  1, /* OMP_CLAUSE_DEVICE  */\n+  1, /* OMP_CLAUSE_DIST_SCHEDULE  */\n+  0, /* OMP_CLAUSE_INBRANCH  */\n+  0, /* OMP_CLAUSE_NOTINBRANCH  */\n+  1, /* OMP_CLAUSE_NUM_TEAMS  */\n+  1, /* OMP_CLAUSE_THREAD_LIMIT  */\n+  0, /* OMP_CLAUSE_PROC_BIND  */\n   1, /* OMP_CLAUSE_SAFELEN  */\n+  1, /* OMP_CLAUSE_SIMDLEN  */\n+  0, /* OMP_CLAUSE_FOR  */\n+  0, /* OMP_CLAUSE_PARALLEL  */\n+  0, /* OMP_CLAUSE_SECTIONS  */\n+  0, /* OMP_CLAUSE_TASKGROUP  */\n   1, /* OMP_CLAUSE__SIMDUID_  */\n };\n \n@@ -263,7 +281,13 @@ const char * const omp_clause_code_name[] =\n   \"copyin\",\n   \"copyprivate\",\n   \"linear\",\n+  \"aligned\",\n+  \"depend\",\n   \"uniform\",\n+  \"from\",\n+  \"to\",\n+  \"map\",\n+  \"_looptemp_\",\n   \"if\",\n   \"num_threads\",\n   \"schedule\",\n@@ -274,7 +298,19 @@ const char * const omp_clause_code_name[] =\n   \"untied\",\n   \"final\",\n   \"mergeable\",\n+  \"device\",\n+  \"dist_schedule\",\n+  \"inbranch\",\n+  \"notinbranch\",\n+  \"num_teams\",\n+  \"thread_limit\",\n+  \"proc_bind\",\n   \"safelen\",\n+  \"simdlen\",\n+  \"for\",\n+  \"parallel\",\n+  \"sections\",\n+  \"taskgroup\",\n   \"_simduid_\"\n };\n \n@@ -4560,6 +4596,87 @@ build_type_attribute_qual_variant (tree ttype, tree attribute, int quals)\n   return ttype;\n }\n \n+/* Check if \"omp declare simd\" attribute arguments, CLAUSES1 and CLAUSES2, are\n+   the same.  */\n+\n+static bool\n+omp_declare_simd_clauses_equal (tree clauses1, tree clauses2)\n+{\n+  tree cl1, cl2;\n+  for (cl1 = clauses1, cl2 = clauses2;\n+       cl1 && cl2;\n+       cl1 = OMP_CLAUSE_CHAIN (cl1), cl2 = OMP_CLAUSE_CHAIN (cl2))\n+    {\n+      if (OMP_CLAUSE_CODE (cl1) != OMP_CLAUSE_CODE (cl2))\n+\treturn false;\n+      if (OMP_CLAUSE_CODE (cl1) != OMP_CLAUSE_SIMDLEN)\n+\t{\n+\t  if (simple_cst_equal (OMP_CLAUSE_DECL (cl1),\n+\t\t\t\tOMP_CLAUSE_DECL (cl2)) != 1)\n+\t    return false;\n+\t}\n+      switch (OMP_CLAUSE_CODE (cl1))\n+\t{\n+\tcase OMP_CLAUSE_ALIGNED:\n+\t  if (simple_cst_equal (OMP_CLAUSE_ALIGNED_ALIGNMENT (cl1),\n+\t\t\t\tOMP_CLAUSE_ALIGNED_ALIGNMENT (cl2)) != 1)\n+\t    return false;\n+\t  break;\n+\tcase OMP_CLAUSE_LINEAR:\n+\t  if (simple_cst_equal (OMP_CLAUSE_LINEAR_STEP (cl1),\n+\t\t\t\tOMP_CLAUSE_LINEAR_STEP (cl2)) != 1)\n+\t    return false;\n+\t  break;\n+\tcase OMP_CLAUSE_SIMDLEN:\n+\t  if (simple_cst_equal (OMP_CLAUSE_SIMDLEN_EXPR (cl1),\n+\t\t\t\tOMP_CLAUSE_SIMDLEN_EXPR (cl2)) != 1)\n+\t    return false;\n+\tdefault:\n+\t  break;\n+\t}\n+    }\n+  return true;\n+}\n+\n+/* Remove duplicate \"omp declare simd\" attributes.  */\n+\n+void\n+omp_remove_redundant_declare_simd_attrs (tree fndecl)\n+{\n+  tree attr, end_attr = NULL_TREE, last_attr = NULL_TREE;\n+  for (attr = lookup_attribute (\"omp declare simd\", DECL_ATTRIBUTES (fndecl));\n+       attr;\n+       attr = lookup_attribute (\"omp declare simd\", TREE_CHAIN (attr)))\n+    {\n+      tree *pc;\n+      for (pc = &TREE_CHAIN (attr); *pc && *pc != end_attr; )\n+\t{\n+\t  if (is_attribute_p (\"omp declare simd\", TREE_PURPOSE (*pc)))\n+\t    {\n+\t      last_attr = TREE_CHAIN (*pc);\n+\t      if (TREE_VALUE (attr) == NULL_TREE)\n+\t\t{\n+\t\t  if (TREE_VALUE (*pc) == NULL_TREE)\n+\t\t    {\n+\t\t      *pc = TREE_CHAIN (*pc);\n+\t\t      continue;\n+\t\t    }\n+\t\t}\n+\t      else if (TREE_VALUE (*pc) != NULL_TREE\n+\t\t       && omp_declare_simd_clauses_equal\n+\t\t\t\t(TREE_VALUE (TREE_VALUE (*pc)),\n+\t\t\t\t TREE_VALUE (TREE_VALUE (attr))))\n+\t\t{\n+\t\t  *pc = TREE_CHAIN (*pc);\n+\t\t  continue;\n+\t\t}\n+\t    }\n+\t  pc = &TREE_CHAIN (*pc);\n+\t}\n+      end_attr = last_attr;\n+    }\n+}\n+\n /* Compare two attributes for their value identity.  Return true if the\n    attribute values are known to be equal; otherwise return false.\n */\n@@ -4577,6 +4694,13 @@ attribute_value_equal (const_tree attr1, const_tree attr2)\n     return (simple_cst_list_equal (TREE_VALUE (attr1),\n \t\t\t\t   TREE_VALUE (attr2)) == 1);\n \n+  if (flag_openmp\n+      && TREE_VALUE (attr1) && TREE_VALUE (attr2)\n+      && TREE_CODE (TREE_VALUE (attr1)) == OMP_CLAUSE\n+      && TREE_CODE (TREE_VALUE (attr2)) == OMP_CLAUSE)\n+    return omp_declare_simd_clauses_equal (TREE_VALUE (attr1),\n+\t\t\t\t\t   TREE_VALUE (attr2));\n+\n   return (simple_cst_equal (TREE_VALUE (attr1), TREE_VALUE (attr2)) == 1);\n }\n \n@@ -11047,7 +11171,14 @@ walk_tree_1 (tree *tp, walk_tree_fn func, void *data,\n \tcase OMP_CLAUSE_NUM_THREADS:\n \tcase OMP_CLAUSE_SCHEDULE:\n \tcase OMP_CLAUSE_UNIFORM:\n+\tcase OMP_CLAUSE_DEPEND:\n+\tcase OMP_CLAUSE_NUM_TEAMS:\n+\tcase OMP_CLAUSE_THREAD_LIMIT:\n+\tcase OMP_CLAUSE_DEVICE:\n+\tcase OMP_CLAUSE_DIST_SCHEDULE:\n \tcase OMP_CLAUSE_SAFELEN:\n+\tcase OMP_CLAUSE_SIMDLEN:\n+\tcase OMP_CLAUSE__LOOPTEMP_:\n \tcase OMP_CLAUSE__SIMDUID_:\n \t  WALK_SUBTREE (OMP_CLAUSE_OPERAND (*tp, 0));\n \t  /* FALLTHRU */\n@@ -11057,6 +11188,13 @@ walk_tree_1 (tree *tp, walk_tree_fn func, void *data,\n \tcase OMP_CLAUSE_DEFAULT:\n \tcase OMP_CLAUSE_UNTIED:\n \tcase OMP_CLAUSE_MERGEABLE:\n+\tcase OMP_CLAUSE_PROC_BIND:\n+\tcase OMP_CLAUSE_INBRANCH:\n+\tcase OMP_CLAUSE_NOTINBRANCH:\n+\tcase OMP_CLAUSE_FOR:\n+\tcase OMP_CLAUSE_PARALLEL:\n+\tcase OMP_CLAUSE_SECTIONS:\n+\tcase OMP_CLAUSE_TASKGROUP:\n \t  WALK_SUBTREE_TAIL (OMP_CLAUSE_CHAIN (*tp));\n \n \tcase OMP_CLAUSE_LASTPRIVATE:\n@@ -11072,7 +11210,11 @@ walk_tree_1 (tree *tp, walk_tree_fn func, void *data,\n \t    WALK_SUBTREE_TAIL (OMP_CLAUSE_CHAIN (*tp));\n \t  }\n \n+\tcase OMP_CLAUSE_ALIGNED:\n \tcase OMP_CLAUSE_LINEAR:\n+\tcase OMP_CLAUSE_FROM:\n+\tcase OMP_CLAUSE_TO:\n+\tcase OMP_CLAUSE_MAP:\n \t  WALK_SUBTREE (OMP_CLAUSE_DECL (*tp));\n \t  WALK_SUBTREE (OMP_CLAUSE_OPERAND (*tp, 1));\n \t  WALK_SUBTREE_TAIL (OMP_CLAUSE_CHAIN (*tp));"}, {"sha": "88c850af120922e1cd348780dff88d4a014543c1", "filename": "gcc/tree.def", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -1034,6 +1034,25 @@ DEFTREECODE (OMP_FOR, \"omp_for\", tcc_statement, 6)\n    Operands like for OMP_FOR.  */\n DEFTREECODE (OMP_SIMD, \"omp_simd\", tcc_statement, 6)\n \n+/* OpenMP - #pragma omp distribute [clause1 ... clauseN]\n+   Operands like for OMP_FOR.  */\n+DEFTREECODE (OMP_DISTRIBUTE, \"omp_distribute\", tcc_statement, 6)\n+\n+/* OpenMP - #pragma omp teams [clause1 ... clauseN]\n+   Operand 0: OMP_TEAMS_BODY: Teams body.\n+   Operand 1: OMP_TEAMS_CLAUSES: List of clauses.  */\n+DEFTREECODE (OMP_TEAMS, \"omp_teams\", tcc_statement, 2)\n+\n+/* OpenMP - #pragma omp target data [clause1 ... clauseN]\n+   Operand 0: OMP_TARGET_DATA_BODY: Target data construct body.\n+   Operand 1: OMP_TARGET_DATA_CLAUSES: List of clauses.  */\n+DEFTREECODE (OMP_TARGET_DATA, \"omp_target_data\", tcc_statement, 2)\n+\n+/* OpenMP - #pragma omp target [clause1 ... clauseN]\n+   Operand 0: OMP_TARGET_BODY: Target construct body.\n+   Operand 1: OMP_TARGET_CLAUSES: List of clauses.  */\n+DEFTREECODE (OMP_TARGET, \"omp_target\", tcc_statement, 2)\n+\n /* OpenMP - #pragma omp sections [clause1 ... clauseN]\n    Operand 0: OMP_SECTIONS_BODY: Sections body.\n    Operand 1: OMP_SECTIONS_CLAUSES: List of clauses.  */\n@@ -1052,6 +1071,10 @@ DEFTREECODE (OMP_SECTION, \"omp_section\", tcc_statement, 1)\n    Operand 0: OMP_MASTER_BODY: Master section body.  */\n DEFTREECODE (OMP_MASTER, \"omp_master\", tcc_statement, 1)\n \n+/* OpenMP - #pragma omp taskgroup\n+   Operand 0: OMP_TASKGROUP_BODY: Taskgroup body.  */\n+DEFTREECODE (OMP_TASKGROUP, \"omp_taskgroup\", tcc_statement, 1)\n+\n /* OpenMP - #pragma omp ordered\n    Operand 0: OMP_ORDERED_BODY: Master section body.  */\n DEFTREECODE (OMP_ORDERED, \"omp_ordered\", tcc_statement, 1)\n@@ -1061,6 +1084,13 @@ DEFTREECODE (OMP_ORDERED, \"omp_ordered\", tcc_statement, 1)\n    Operand 1: OMP_CRITICAL_NAME: Identifier for critical section.  */\n DEFTREECODE (OMP_CRITICAL, \"omp_critical\", tcc_statement, 2)\n \n+/* OpenMP - #pragma omp target update [clause1 ... clauseN]\n+   Operand 0: OMP_TARGET_UPDATE_CLAUSES: List of clauses.  */\n+DEFTREECODE (OMP_TARGET_UPDATE, \"omp_target_update\", tcc_statement, 1)\n+\n+/* OMP_ATOMIC through OMP_ATOMIC_CAPTURE_NEW must be consecutive,\n+   or OMP_ATOMIC_SEQ_CST needs adjusting.  */\n+\n /* OpenMP - #pragma omp atomic\n    Operand 0: The address at which the atomic operation is to be performed.\n \tThis address should be stabilized with save_expr."}, {"sha": "8200c2e8757974f38d7a2a693f6e0fe5a1fa7a7f", "filename": "gcc/tree.h", "status": "modified", "additions": 78, "deletions": 7, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -1167,12 +1167,13 @@ extern void protected_set_expr_location (tree, location_t);\n #define OMP_TASKREG_BODY(NODE)    TREE_OPERAND (OMP_TASKREG_CHECK (NODE), 0)\n #define OMP_TASKREG_CLAUSES(NODE) TREE_OPERAND (OMP_TASKREG_CHECK (NODE), 1)\n \n-#define OMP_FOR_BODY(NODE)\t   TREE_OPERAND (OMP_FOR_CHECK (NODE), 0)\n-#define OMP_FOR_CLAUSES(NODE)\t   TREE_OPERAND (OMP_FOR_CHECK (NODE), 1)\n-#define OMP_FOR_INIT(NODE)\t   TREE_OPERAND (OMP_FOR_CHECK (NODE), 2)\n-#define OMP_FOR_COND(NODE)\t   TREE_OPERAND (OMP_FOR_CHECK (NODE), 3)\n-#define OMP_FOR_INCR(NODE)\t   TREE_OPERAND (OMP_FOR_CHECK (NODE), 4)\n-#define OMP_FOR_PRE_BODY(NODE)\t   TREE_OPERAND (OMP_FOR_CHECK (NODE), 5)\n+#define OMP_LOOP_CHECK(NODE) TREE_RANGE_CHECK (NODE, OMP_FOR, OMP_DISTRIBUTE)\n+#define OMP_FOR_BODY(NODE)\t   TREE_OPERAND (OMP_LOOP_CHECK (NODE), 0)\n+#define OMP_FOR_CLAUSES(NODE)\t   TREE_OPERAND (OMP_LOOP_CHECK (NODE), 1)\n+#define OMP_FOR_INIT(NODE)\t   TREE_OPERAND (OMP_LOOP_CHECK (NODE), 2)\n+#define OMP_FOR_COND(NODE)\t   TREE_OPERAND (OMP_LOOP_CHECK (NODE), 3)\n+#define OMP_FOR_INCR(NODE)\t   TREE_OPERAND (OMP_LOOP_CHECK (NODE), 4)\n+#define OMP_FOR_PRE_BODY(NODE)\t   TREE_OPERAND (OMP_LOOP_CHECK (NODE), 5)\n \n #define OMP_SECTIONS_BODY(NODE)    TREE_OPERAND (OMP_SECTIONS_CHECK (NODE), 0)\n #define OMP_SECTIONS_CLAUSES(NODE) TREE_OPERAND (OMP_SECTIONS_CHECK (NODE), 1)\n@@ -1184,16 +1185,37 @@ extern void protected_set_expr_location (tree, location_t);\n \n #define OMP_MASTER_BODY(NODE)\t   TREE_OPERAND (OMP_MASTER_CHECK (NODE), 0)\n \n+#define OMP_TASKGROUP_BODY(NODE)   TREE_OPERAND (OMP_TASKGROUP_CHECK (NODE), 0)\n+\n #define OMP_ORDERED_BODY(NODE)\t   TREE_OPERAND (OMP_ORDERED_CHECK (NODE), 0)\n \n #define OMP_CRITICAL_BODY(NODE)    TREE_OPERAND (OMP_CRITICAL_CHECK (NODE), 0)\n #define OMP_CRITICAL_NAME(NODE)    TREE_OPERAND (OMP_CRITICAL_CHECK (NODE), 1)\n \n+#define OMP_TEAMS_BODY(NODE)\t   TREE_OPERAND (OMP_TEAMS_CHECK (NODE), 0)\n+#define OMP_TEAMS_CLAUSES(NODE)\t   TREE_OPERAND (OMP_TEAMS_CHECK (NODE), 1)\n+\n+#define OMP_TARGET_DATA_BODY(NODE) \\\n+  TREE_OPERAND (OMP_TARGET_DATA_CHECK (NODE), 0)\n+#define OMP_TARGET_DATA_CLAUSES(NODE)\\\n+  TREE_OPERAND (OMP_TARGET_DATA_CHECK (NODE), 1)\n+\n+#define OMP_TARGET_BODY(NODE)\t   TREE_OPERAND (OMP_TARGET_CHECK (NODE), 0)\n+#define OMP_TARGET_CLAUSES(NODE)   TREE_OPERAND (OMP_TARGET_CHECK (NODE), 1)\n+\n+#define OMP_TARGET_UPDATE_CLAUSES(NODE)\\\n+  TREE_OPERAND (OMP_TARGET_UPDATE_CHECK (NODE), 0)\n+\n+#define OMP_CLAUSE_SIZE(NODE)\t\t\t\t\t\t\\\n+  OMP_CLAUSE_OPERAND (OMP_CLAUSE_RANGE_CHECK (OMP_CLAUSE_CHECK (NODE),\t\\\n+\t\t\t\t\t      OMP_CLAUSE_FROM,\t\t\\\n+\t\t\t\t\t      OMP_CLAUSE_MAP), 1)\n+\n #define OMP_CLAUSE_CHAIN(NODE)     TREE_CHAIN (OMP_CLAUSE_CHECK (NODE))\n #define OMP_CLAUSE_DECL(NODE)      \t\t\t\t\t\\\n   OMP_CLAUSE_OPERAND (OMP_CLAUSE_RANGE_CHECK (OMP_CLAUSE_CHECK (NODE),\t\\\n \t\t\t\t\t      OMP_CLAUSE_PRIVATE,\t\\\n-\t                                      OMP_CLAUSE_UNIFORM), 0)\n+\t\t\t\t\t      OMP_CLAUSE__LOOPTEMP_), 0)\n #define OMP_CLAUSE_HAS_LOCATION(NODE) \\\n   (LOCATION_LOCUS ((OMP_CLAUSE_CHECK (NODE))->omp_clause.locus)\t\t\\\n   != UNKNOWN_LOCATION)\n@@ -1209,6 +1231,12 @@ extern void protected_set_expr_location (tree, location_t);\n #define OMP_PARALLEL_COMBINED(NODE) \\\n   (OMP_PARALLEL_CHECK (NODE)->base.private_flag)\n \n+/* True if OMP_ATOMIC* is supposed to be sequentially consistent\n+   as opposed to relaxed.  */\n+#define OMP_ATOMIC_SEQ_CST(NODE) \\\n+  (TREE_RANGE_CHECK (NODE, OMP_ATOMIC, \\\n+\t\t     OMP_ATOMIC_CAPTURE_NEW)->base.private_flag)\n+\n /* True on a PRIVATE clause if its decl is kept around for debugging\n    information only and its DECL_VALUE_EXPR is supposed to point\n    to what it has been remapped to.  */\n@@ -1240,6 +1268,21 @@ extern void protected_set_expr_location (tree, location_t);\n #define OMP_CLAUSE_SCHEDULE_CHUNK_EXPR(NODE) \\\n   OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_SCHEDULE), 0)\n \n+#define OMP_CLAUSE_DEPEND_KIND(NODE) \\\n+  (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_DEPEND)->omp_clause.subcode.depend_kind)\n+\n+#define OMP_CLAUSE_MAP_KIND(NODE) \\\n+  (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_MAP)->omp_clause.subcode.map_kind)\n+\n+/* Nonzero if this map clause is for array (rather than pointer) based array\n+   section with zero bias.  Both the non-decl OMP_CLAUSE_MAP and\n+   correspoidng OMP_CLAUSE_MAP_POINTER clause are marked with this flag.  */\n+#define OMP_CLAUSE_MAP_ZERO_BIAS_ARRAY_SECTION(NODE) \\\n+  (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_MAP)->base.public_flag)\n+\n+#define OMP_CLAUSE_PROC_BIND_KIND(NODE) \\\n+  (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_PROC_BIND)->omp_clause.subcode.proc_bind_kind)\n+\n #define OMP_CLAUSE_COLLAPSE_EXPR(NODE) \\\n   OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_COLLAPSE), 0)\n #define OMP_CLAUSE_COLLAPSE_ITERVAR(NODE) \\\n@@ -1260,6 +1303,11 @@ extern void protected_set_expr_location (tree, location_t);\n #define OMP_CLAUSE_REDUCTION_PLACEHOLDER(NODE) \\\n   OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_REDUCTION), 3)\n \n+/* True if a REDUCTION clause may reference the original list item (omp_orig)\n+   in its OMP_CLAUSE_REDUCTION_{,GIMPLE_}INIT.  */\n+#define OMP_CLAUSE_REDUCTION_OMP_ORIG_REF(NODE) \\\n+  (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_REDUCTION)->base.public_flag)\n+\n /* True if a LINEAR clause doesn't need copy in.  True for iterator vars which\n    are always initialized inside of the loop construct, false otherwise.  */\n #define OMP_CLAUSE_LINEAR_NO_COPYIN(NODE) \\\n@@ -1273,9 +1321,29 @@ extern void protected_set_expr_location (tree, location_t);\n #define OMP_CLAUSE_LINEAR_STEP(NODE) \\\n   OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_LINEAR), 1)\n \n+#define OMP_CLAUSE_ALIGNED_ALIGNMENT(NODE) \\\n+  OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_ALIGNED), 1)\n+\n+#define OMP_CLAUSE_NUM_TEAMS_EXPR(NODE) \\\n+  OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_NUM_TEAMS), 0)\n+\n+#define OMP_CLAUSE_THREAD_LIMIT_EXPR(NODE) \\\n+  OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, \\\n+\t\t\t\t\t\tOMP_CLAUSE_THREAD_LIMIT), 0)\n+\n+#define OMP_CLAUSE_DEVICE_ID(NODE) \\\n+  OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_DEVICE), 0)\n+\n+#define OMP_CLAUSE_DIST_SCHEDULE_CHUNK_EXPR(NODE) \\\n+  OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, \\\n+\t\t\t\t\t\tOMP_CLAUSE_DIST_SCHEDULE), 0)\n+\n #define OMP_CLAUSE_SAFELEN_EXPR(NODE) \\\n   OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_SAFELEN), 0)\n \n+#define OMP_CLAUSE_SIMDLEN_EXPR(NODE) \\\n+  OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_SIMDLEN), 0)\n+\n #define OMP_CLAUSE__SIMDUID__DECL(NODE) \\\n   OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE__SIMDUID_), 0)\n \n@@ -3624,6 +3692,9 @@ extern tree build_type_attribute_variant (tree, tree);\n extern tree build_decl_attribute_variant (tree, tree);\n extern tree build_type_attribute_qual_variant (tree, tree, int);\n \n+/* Remove redundant \"omp declare simd\" attributes from fndecl.  */\n+extern void omp_remove_redundant_declare_simd_attrs (tree);\n+\n /* Return 0 if the attributes for two types are incompatible, 1 if they\n    are compatible, and 2 if they are nearly compatible (which causes a\n    warning to be generated).  */"}, {"sha": "557b80a731727150f263883c0bb90f864325545f", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 364, "deletions": 0, "changes": 364, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -1,3 +1,367 @@\n+2013-10-11  Jakub Jelinek  <jakub@redhat.com>\n+\t    Tobias Burnus  <burnus@net-b.de>\n+\t    Richard Henderson  <rth@redhat.com>\n+\n+\t* target.c: New file.\n+\t* Makefile.am (libgomp_la_SOURCES): Add target.c.\n+\t* Makefile.in: Regenerated.\n+\t* libgomp_g.h (GOMP_task): Add depend argument.\n+\t(GOMP_barrier_cancel, GOMP_loop_end_cancel,\n+\tGOMP_sections_end_cancel, GOMP_target, GOMP_target_data,\n+\tGOMP_target_end_data, GOMP_target_update, GOMP_teams,\n+\tGOMP_parallel_loop_static, GOMP_parallel_loop_dynamic,\n+\tGOMP_parallel_loop_guided, GOMP_parallel_loop_runtime,\n+\tGOMP_parallel, GOMP_cancel, GOMP_cancellation_point,\n+\tGOMP_taskgroup_start, GOMP_taskgroup_end,\n+\tGOMP_parallel_sections): New prototypes.\n+\t* fortran.c (omp_is_initial_device): Add ialias_redirect.\n+\t(omp_is_initial_device_): New function.\n+\t(ULP, STR1, STR2, ialias_redirect): Removed.\n+\t(omp_get_cancellation_, omp_get_proc_bind_, omp_set_default_device_,\n+\tomp_set_default_device_8_, omp_get_default_device_,\n+\tomp_get_num_devices_, omp_get_num_teams_, omp_get_team_num_): New\n+\tfunctions.\n+\t* libgomp.map (GOMP_barrier_cancel, GOMP_loop_end_cancel,\n+\tGOMP_sections_end_cancel, GOMP_target, GOMP_target_data,\n+\tGOMP_target_end_data, GOMP_target_update, GOMP_teams): Export\n+\t@@GOMP_4.0.\n+\t(omp_is_initial_device, omp_is_initial_device_, omp_get_cancellation,\n+\tomp_get_cancellation_, omp_get_proc_bind, omp_get_proc_bind_,\n+\tomp_set_default_device, omp_set_default_device_,\n+\tomp_set_default_device_8_, omp_get_default_device,\n+\tomp_get_default_device_, omp_get_num_devices, omp_get_num_devices_,\n+\tomp_get_num_teams, omp_get_num_teams_, omp_get_team_num,\n+\tomp_get_team_num_): Export @@OMP_4.0.\n+\t* team.c (struct gomp_thread_start_data): Add place field.\n+\t(gomp_thread_start): Clear thr->thread_pool and\n+\tthr->task before returning.  Use gomp_team_barrier_wait_final\n+\tinstead of gomp_team_barrier_wait.  Initialize thr->place.\n+\t(gomp_new_team): Initialize work_shares_to_free, work_share_cancelled,\n+\tteam_cancelled and task_queued_count fields.\n+\t(gomp_free_pool_helper): Clear thr->thread_pool and thr->task\n+\tbefore calling pthread_exit.\n+\t(gomp_free_thread): No longer static.  Use\n+\tgomp_managed_threads_lock instead of gomp_remaining_threads_lock.\n+\t(gomp_team_start): Add flags argument.  Set\n+\tthr->thread_pool->threads_busy to nthreads immediately after creating\n+\tnew pool.  Use gomp_managed_threads_lock instead of\n+\tgomp_remaining_threads_lock.  Handle OpenMP 4.0 affinity.\n+\t(gomp_team_end): Use gomp_managed_threads_lock instead of\n+\tgomp_remaining_threads_lock.  Use gomp_team_barrier_wait_final instead\n+\tof gomp_team_barrier_wait.  If team->team_cancelled, call\n+\tgomp_fini_worshare on ws chain starting at team->work_shares_to_free\n+\trather than thr->ts.work_share.\n+\t(initialize_team): Don't call gomp_sem_init here.\n+\t* sections.c (GOMP_parallel_sections_start): Adjust gomp_team_start\n+\tcaller.\n+\t(GOMP_parallel_sections, GOMP_sections_end_cancel): New functions.\n+\t* env.c (gomp_global_icv): Add default_device_var, target_data and\n+\tbind_var initializers.\n+\t(gomp_cpu_affinity, gomp_cpu_affinity_len): Remove.\n+\t(gomp_bind_var_list, gomp_bind_var_list_len, gomp_places_list,\n+\tgomp_places_list_len): New variables.\n+\t(parse_bind_var, parse_one_place, parse_places_var): New functions.\n+\t(parse_affinity): Rewritten to construct OMP_PLACES list with unit\n+\tsized places.\n+\t(gomp_cancel_var): New global variable.\n+\t(parse_int): New function.\n+\t(handle_omp_display_env): New function.\n+\t(initialize_env): Use it.  Initialize default_device_var.\n+\tParse OMP_CANCELLATION env var.  Use parse_bind_var to parse\n+\tOMP_PROC_BIND instead of parse_boolean.  Use parse_places_var for\n+\tOMP_PLACES parsing.  Don't call parse_affinity if OMP_PLACES has\n+\tbeen successfully parsed (and call gomp_init_affinity in that case).\n+\t(omp_get_cancellation, omp_get_proc_bind, omp_set_default_device,\n+\tomp_get_default_device, omp_get_num_devices, omp_get_num_teams,\n+\tomp_get_team_num, omp_is_initial_device): New functions.\n+\t* libgomp.h: Include stdlib.h.\n+\t(ialias_ulp, ialias_str1, ialias_str2, ialias_redirect, ialias_call):\n+\tDefine.\n+\t(struct target_mem_desc): Forward declare.\n+\t(struct gomp_task_icv): Add default_device_var, target_data, bind_var\n+\tand thread_limit_var fields.\n+\t(gomp_get_num_devices): New prototype.\n+\t(gomp_cancel_var): New extern decl.\n+\t(struct gomp_team): Add work_shares_to_free, work_share_cancelled,\n+\tteam_cancelled and task_queued_count fields.  Add comments about\n+\ttask_{,queued_,running_}count.\n+\t(gomp_cancel_kind): New enum.\n+\t(gomp_work_share_end_cancel): New prototype.\n+\t(struct gomp_task): Add next_taskgroup, prev_taskgroup, taskgroup,\n+\tcopy_ctors_done, dependers, depend_hash, depend_count, num_dependees\n+\tand depend fields.\n+\t(struct gomp_taskgroup): New type.\n+\t(struct gomp_task_depend_entry,\n+\tstruct gomp_dependers_vec): New types.\n+\t(gomp_finish_task): Free depend_hash if non-NULL.\n+\t(struct gomp_team_state): Add place_partition_off\n+\tand place_partition_len fields.\n+\t(gomp_bind_var_list, gomp_bind_var_list_len, gomp_places_list,\n+\tgomp_places_list_len): New extern decls.\n+\t(struct gomp_thread): Add place field.\n+\t(gomp_cpu_affinity, gomp_cpu_affinity_len): Remove.\n+\t(gomp_init_thread_affinity): Add place argument.\n+\t(gomp_affinity_alloc, gomp_affinity_init_place, gomp_affinity_add_cpus,\n+\tgomp_affinity_remove_cpu, gomp_affinity_copy_place,\n+\tgomp_affinity_same_place, gomp_affinity_finalize_place_list,\n+\tgomp_affinity_init_level, gomp_affinity_print_place): New\n+\tprototypes.\n+\t(gomp_team_start): Add flags argument.\n+\t(gomp_thread_limit_var, gomp_remaining_threads_count,\n+\tgomp_remaining_threads_lock): Remove.\n+\t(gomp_managed_threads_lock): New variable.\n+\t(struct gomp_thread_pool): Add threads_busy field.\n+\t(gomp_free_thread): New prototype.\n+\t* task.c: Include hashtab.h.\n+\t(hash_entry_type): New typedef.\n+\t(htab_alloc, htab_free, htab_hash, htab_eq): New inlines.\n+\t(gomp_init_task): Clear dependers, depend_hash, depend_count,\n+\tcopy_ctors_done and taskgroup fields.\n+\t(GOMP_task): Add depend argument, handle depend clauses.  If\n+\tgomp_team_barrier_cancelled or if it's taskgroup has been\n+\tcancelled, don't queue or start new tasks.  Set copy_ctors_done\n+\tfield if needed.  Initialize taskgroup field.  If copy_ctors_done\n+\tand already cancelled, don't discard the task.  If taskgroup is\n+\tnon-NULL, enqueue the task into taskgroup queue.  Increment\n+\tnum_children field in taskgroup.  Increment task_queued_count.\n+\t(gomp_task_run_pre, gomp_task_run_post_remove_parent,\n+\tgomp_task_run_post_remove_taskgroup): New inline functions.\n+\t(gomp_task_run_post_handle_depend_hash,\n+\tgomp_task_run_post_handle_dependers,\n+\tgomp_task_run_post_handle_depend): New functions.\n+\t(GOMP_taskwait): Use them.  If more than one new tasks\n+\thave been queued, wake other threads if needed.\n+\t(gomp_barrier_handle_tasks): Likewise.  If\n+\tgomp_team_barrier_cancelled, don't start any new tasks, just free\n+\tall tasks.\n+\t(GOMP_taskgroup_start, GOMP_taskgroup_end): New functions.\n+\t* omp_lib.f90.in\n+\t(omp_proc_bind_kind, omp_proc_bind_false,\n+\tomp_proc_bind_true, omp_proc_bind_master, omp_proc_bind_close,\n+\tomp_proc_bind_spread): New params.\n+\t(omp_get_cancellation, omp_get_proc_bind, omp_set_default_device,\n+\tomp_get_default_device, omp_get_num_devices, omp_get_num_teams,\n+\tomp_get_team_num, omp_is_initial_device): New interfaces.\n+\t(omp_get_dynamic, omp_get_nested, omp_in_parallel,\n+\tomp_get_max_threads, omp_get_num_procs, omp_get_num_threads,\n+\tomp_get_thread_num, omp_get_thread_limit, omp_set_max_active_levels,\n+\tomp_get_max_active_levels, omp_get_level, omp_get_ancestor_thread_num,\n+\tomp_get_team_size, omp_get_active_level, omp_in_final): Remove\n+\tuseless use omp_lib_kinds.\n+\t* omp.h.in (omp_proc_bind_t): New typedef.\n+\t(omp_get_cancellation, omp_get_proc_bind, omp_set_default_device,\n+\tomp_get_default_device, omp_get_num_devices, omp_get_num_teams,\n+\tomp_get_team_num, omp_is_initial_device): New prototypes.\n+\t* loop.c (gomp_parallel_loop_start): Add flags argument, pass it\n+\tthrough to gomp_team_start.\n+\t(GOMP_parallel_loop_static_start, GOMP_parallel_loop_dynamic_start,\n+\tGOMP_parallel_loop_guided_start, GOMP_parallel_loop_runtime_start):\n+\tAdjust gomp_parallel_loop_start callers.\n+\t(GOMP_parallel_loop_static, GOMP_parallel_loop_dynamic,\n+\tGOMP_parallel_loop_guided, GOMP_parallel_loop_runtime,\n+\tGOMP_loop_end_cancel): New functions.\n+\t(GOMP_parallel_end): Add ialias_redirect.\n+\t* hashtab.h: New file.\n+\t* libgomp.texi (Environment Variables): Minor cleanup,\n+\tupdate section refs to OpenMP 4.0rc2.\n+\t(OMP_DISPLAY_ENV, GOMP_SPINCOUNT): Document these\n+\tenvironment variables.\n+\t* work.c (gomp_work_share_end, gomp_work_share_end_nowait): Set\n+\tteam->work_shares_to_free to thr->ts.work_share before calling\n+\tfree_work_share.\n+\t(gomp_work_share_end_cancel): New function.\n+\t* config/linux/proc.c: Include errno.h.\n+\t(gomp_get_cpuset_size, gomp_cpuset_size, gomp_cpusetp): New variables.\n+\t(gomp_cpuset_popcount): Add cpusetsize argument, use it instead of\n+\tsizeof (cpu_set_t) to determine number of iterations.  Fix up check\n+\textern decl.  Use CPU_COUNT_S if available, or CPU_COUNT if\n+\tgomp_cpuset_size is sizeof (cpu_set_t).\n+\t(gomp_init_num_threads): Initialize gomp_cpuset_size,\n+\tgomp_get_cpuset_size and gomp_cpusetp here, use gomp_cpusetp instead\n+\tof &cpuset and pass gomp_cpuset_size instead of sizeof (cpu_set_t)\n+\tto pthread_getaffinity_np.  Free and clear gomp_cpusetp if it didn't\n+\tcontain any logical CPUs.\n+\t(get_num_procs): Don't call pthread_getaffinity_np if gomp_cpusetp\n+\tis NULL.  Use gomp_cpusetp instead of &cpuset and pass\n+\tgomp_get_cpuset_size instead of sizeof (cpu_set_t) to\n+\tpthread_getaffinity_np.  Check gomp_places_list instead of\n+\tgomp_cpu_affinity.  Adjust gomp_cpuset_popcount caller.\n+\t* config/linux/bar.c (gomp_barrier_wait_end,\n+\tgomp_barrier_wait_last): Use BAR_* defines.\n+\t(gomp_team_barrier_wait_end): Likewise.  Clear BAR_CANCELLED\n+\tfrom state where needed.  Set work_share_cancelled to 0 on last\n+\tthread.\n+\t(gomp_team_barrier_wait_final, gomp_team_barrier_wait_cancel_end,\n+\tgomp_team_barrier_wait_cancel, gomp_team_barrier_cancel): New\n+\tfunctions.\n+\t* config/linux/proc.h (gomp_cpuset_popcount): Add attribute_hidden.\n+\tAdd cpusetsize argument.\n+\t(gomp_cpuset_size, gomp_cpusetp): Declare.\n+\t* config/linux/affinity.c: Include errno.h, stdio.h and string.h.\n+\t(affinity_counter): Remove.\n+\t(CPU_ISSET_S, CPU_ZERO_S, CPU_SET_S, CPU_CLR_S): Define\n+\tif CPU_ALLOC_SIZE isn't defined.\n+\t(gomp_init_affinity): Rewritten, if gomp_places_list is NULL, try\n+\tsilently create OMP_PLACES=threads, if it is non-NULL afterwards,\n+\tbind current thread to the first place.\n+\t(gomp_init_thread_affinity): Rewritten.  Add place argument, just\n+\tpthread_setaffinity_np to gomp_places_list[place].\n+\t(gomp_affinity_alloc, gomp_affinity_init_place, gomp_affinity_add_cpus,\n+\tgomp_affinity_remove_cpu, gomp_affinity_copy_place,\n+\tgomp_affinity_same_place, gomp_affinity_finalize_place_list,\n+\tgomp_affinity_init_level, gomp_affinity_print_place): New functions.\n+\t* config/linux/bar.h (BAR_TASK_PENDING, BAR_WAS_LAST,\n+\tBAR_WAITING_FOR_TASK, BAR_INCR, BAR_CANCELLED): Define.\n+\t(gomp_barrier_t): Add awaited_final field.\n+\t(gomp_barrier_init): Initialize awaited_final field.\n+\t(gomp_team_barrier_wait_final, gomp_team_barrier_wait_cancel,\n+\tgomp_team_barrier_wait_cancel_end, gomp_team_barrier_cancel): New\n+\tprototypes.\n+\t(gomp_barrier_wait_start): Preserve BAR_CANCELLED bit.  Use BAR_*\n+\tdefines.\n+\t(gomp_barrier_wait_cancel_start, gomp_team_barrier_wait_final_start,\n+\tgomp_team_barrier_cancelled): New inline functions.\n+\t(gomp_barrier_last_thread,\n+\tgomp_team_barrier_set_task_pending,\n+\tgomp_team_barrier_clear_task_pending,\n+\tgomp_team_barrier_set_waiting_for_tasks,\n+\tgomp_team_barrier_waiting_for_tasks,\n+\tgomp_team_barrier_done): Use BAR_* defines.\n+\t* config/posix/bar.c (gomp_barrier_init): Clear cancellable field.\n+\t(gomp_barrier_wait_end): Use BAR_* defines.\n+\t(gomp_team_barrier_wait_end): Clear BAR_CANCELLED from state.\n+\tSet work_share_cancelled to 0 on last thread, use __atomic_load_n.\n+\tUse BAR_* defines.\n+\t(gomp_team_barrier_wait_cancel_end, gomp_team_barrier_wait_cancel,\n+\tgomp_team_barrier_cancel): New functions.\n+\t* config/posix/affinity.c (gomp_init_thread_affinity): Add place\n+\targument.\n+\t(gomp_affinity_alloc, gomp_affinity_init_place, gomp_affinity_add_cpus,\n+\tgomp_affinity_remove_cpu, gomp_affinity_copy_place,\n+\tgomp_affinity_same_place, gomp_affinity_finalize_place_list,\n+\tgomp_affinity_init_level, gomp_affinity_print_place): New stubs.\n+\t* config/posix/bar.h (BAR_TASK_PENDING, BAR_WAS_LAST,\n+\tBAR_WAITING_FOR_TASK, BAR_INCR, BAR_CANCELLED): Define.\n+\t(gomp_barrier_t): Add cancellable field.\n+\t(gomp_team_barrier_wait_cancel, gomp_team_barrier_wait_cancel_end,\n+\tgomp_team_barrier_cancel): New prototypes.\n+\t(gomp_barrier_wait_start): Preserve BAR_CANCELLED bit.\n+\t(gomp_barrier_wait_cancel_start, gomp_team_barrier_wait_final,\n+\tgomp_team_barrier_cancelled): New inline functions.\n+\t(gomp_barrier_wait_start, gomp_barrier_last_thread,\n+\tgomp_team_barrier_set_task_pending,\n+\tgomp_team_barrier_clear_task_pending,\n+\tgomp_team_barrier_set_waiting_for_tasks,\n+\tgomp_team_barrier_waiting_for_tasks,\n+\tgomp_team_barrier_done): Use BAR_* defines.\n+\t* barrier.c (GOMP_barrier_cancel): New function.\n+\t* omp_lib.h.in (omp_proc_bind_kind, omp_proc_bind_false,\n+\tomp_proc_bind_true, omp_proc_bind_master, omp_proc_bind_close,\n+\tomp_proc_bind_spread): New params.\n+\t(omp_get_cancellation, omp_get_proc_bind, omp_set_default_device,\n+\tomp_get_default_device, omp_get_num_devices, omp_get_num_teams,\n+\tomp_get_team_num, omp_is_initial_device): New externals.\n+\t* parallel.c (GOMP_parallel, GOMP_cancel, GOMP_cancellation_point):\n+\tNew functions.\n+\t(gomp_resolve_num_threads): Adjust for thread_limit now being in\n+\ticv->thread_limit_var.  Use UINT_MAX instead of ULONG_MAX as\n+\tinfinity.  If not nested, just return minimum of max_num_threads\n+\tand icv->thread_limit_var and if thr->thread_pool, set threads_busy\n+\tto the returned value.  Otherwise, don't update atomically\n+\tgomp_remaining_threads_count, but instead thr->thread_pool->threads_busy.\n+\t(GOMP_parallel_end): Adjust for thread_limit now being in\n+\ticv->thread_limit_var.  Use UINT_MAX instead of ULONG_MAX as\n+\tinfinity.  Adjust threads_busy in the pool rather than\n+\tgomp_remaining_threads_count.  Remember team->nthreads and call\n+\tgomp_team_end before adjusting threads_busy, if not nested\n+\tafterwards, just set it to 1 non-atomically.  Add ialias.\n+\t(GOMP_parallel_start): Adjust gomp_team_start caller.\n+\t* testsuite/libgomp.c/atomic-14.c: Add parens to make it valid.\n+\t* testsuite/libgomp.c/affinity-1.c: New test.\n+\t* testsuite/libgomp.c/atomic-15.c: New test.\n+\t* testsuite/libgomp.c/atomic-16.c: New test.\n+\t* testsuite/libgomp.c/atomic-17.c: New test.\n+\t* testsuite/libgomp.c/cancel-for-1.c: New test.\n+\t* testsuite/libgomp.c/cancel-for-2.c: New test.\n+\t* testsuite/libgomp.c/cancel-parallel-1.c: New test.\n+\t* testsuite/libgomp.c/cancel-parallel-2.c: New test.\n+\t* testsuite/libgomp.c/cancel-parallel-3.c: New test.\n+\t* testsuite/libgomp.c/cancel-sections-1.c: New test.\n+\t* testsuite/libgomp.c/cancel-taskgroup-1.c: New test.\n+\t* testsuite/libgomp.c/cancel-taskgroup-2.c: New test.\n+\t* testsuite/libgomp.c/depend-1.c: New test.\n+\t* testsuite/libgomp.c/depend-2.c: New test.\n+\t* testsuite/libgomp.c/depend-3.c: New test.\n+\t* testsuite/libgomp.c/depend-4.c: New test.\n+\t* testsuite/libgomp.c/for-1.c: New test.\n+\t* testsuite/libgomp.c/for-1.h: New file.\n+\t* testsuite/libgomp.c/for-2.c: New test.\n+\t* testsuite/libgomp.c/for-2.h: New file.\n+\t* testsuite/libgomp.c/for-3.c: New test.\n+\t* testsuite/libgomp.c/pr58392.c: New test.\n+\t* testsuite/libgomp.c/simd-1.c: New test.\n+\t* testsuite/libgomp.c/simd-2.c: New test.\n+\t* testsuite/libgomp.c/simd-3.c: New test.\n+\t* testsuite/libgomp.c/simd-4.c: New test.\n+\t* testsuite/libgomp.c/simd-5.c: New test.\n+\t* testsuite/libgomp.c/simd-6.c: New test.\n+\t* testsuite/libgomp.c/target-1.c: New test.\n+\t* testsuite/libgomp.c/target-2.c: New test.\n+\t* testsuite/libgomp.c/target-3.c: New test.\n+\t* testsuite/libgomp.c/target-4.c: New test.\n+\t* testsuite/libgomp.c/target-5.c: New test.\n+\t* testsuite/libgomp.c/target-6.c: New test.\n+\t* testsuite/libgomp.c/target-7.c: New test.\n+\t* testsuite/libgomp.c/taskgroup-1.c: New test.\n+\t* testsuite/libgomp.c/thread-limit-1.c: New test.\n+\t* testsuite/libgomp.c/thread-limit-2.c: New test.\n+\t* testsuite/libgomp.c/thread-limit-3.c: New test.\n+\t* testsuite/libgomp.c/udr-1.c: New test.\n+\t* testsuite/libgomp.c/udr-2.c: New test.\n+\t* testsuite/libgomp.c/udr-3.c: New test.\n+\t* testsuite/libgomp.c++/affinity-1.C: New test.\n+\t* testsuite/libgomp.c++/atomic-10.C: New test.\n+\t* testsuite/libgomp.c++/atomic-11.C: New test.\n+\t* testsuite/libgomp.c++/atomic-12.C: New test.\n+\t* testsuite/libgomp.c++/atomic-13.C: New test.\n+\t* testsuite/libgomp.c++/atomic-14.C: New test.\n+\t* testsuite/libgomp.c++/atomic-15.C: New test.\n+\t* testsuite/libgomp.c++/cancel-for-1.C: New test.\n+\t* testsuite/libgomp.c++/cancel-for-2.C: New test.\n+\t* testsuite/libgomp.c++/cancel-parallel-1.C: New test.\n+\t* testsuite/libgomp.c++/cancel-parallel-2.C: New test.\n+\t* testsuite/libgomp.c++/cancel-parallel-3.C: New test.\n+\t* testsuite/libgomp.c++/cancel-sections-1.C: New test.\n+\t* testsuite/libgomp.c++/cancel-taskgroup-1.C: New test.\n+\t* testsuite/libgomp.c++/cancel-taskgroup-2.C: New test.\n+\t* testsuite/libgomp.c++/cancel-taskgroup-3.C: New test.\n+\t* testsuite/libgomp.c++/cancel-test.h: New file.\n+\t* testsuite/libgomp.c++/for-9.C: New test.\n+\t* testsuite/libgomp.c++/for-10.C: New test.\n+\t* testsuite/libgomp.c++/for-11.C: New test.\n+\t* testsuite/libgomp.c++/simd-1.C: New test.\n+\t* testsuite/libgomp.c++/simd-2.C: New test.\n+\t* testsuite/libgomp.c++/simd-3.C: New test.\n+\t* testsuite/libgomp.c++/simd-4.C: New test.\n+\t* testsuite/libgomp.c++/simd-5.C: New test.\n+\t* testsuite/libgomp.c++/simd-6.C: New test.\n+\t* testsuite/libgomp.c++/simd-7.C: New test.\n+\t* testsuite/libgomp.c++/simd-8.C: New test.\n+\t* testsuite/libgomp.c++/target-1.C: New test.\n+\t* testsuite/libgomp.c++/target-2.C: New test.\n+\t* testsuite/libgomp.c++/target-2-aux.cc: New file.\n+\t* testsuite/libgomp.c++/target-3.C: New test.\n+\t* testsuite/libgomp.c++/taskgroup-1.C: New test.\n+\t* testsuite/libgomp.c++/udr-1.C: New test.\n+\t* testsuite/libgomp.c++/udr-2.C: New test.\n+\t* testsuite/libgomp.c++/udr-3.C: New test.\n+\t* testsuite/libgomp.c++/udr-4.C: New test.\n+\t* testsuite/libgomp.c++/udr-5.C: New test.\n+\t* testsuite/libgomp.c++/udr-6.C: New test.\n+\t* testsuite/libgomp.c++/udr-7.C: New test.\n+\t* testsuite/libgomp.c++/udr-8.C: New test.\n+\t* testsuite/libgomp.c++/udr-9.C: New test.\n+\n 2013-09-20  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR testsuite/57605"}, {"sha": "e546dbe425bea98231b11a401eac0882698608ea", "filename": "libgomp/Makefile.am", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FMakefile.am?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -60,7 +60,7 @@ libgomp_la_LINK = $(LINK) $(libgomp_la_LDFLAGS)\n libgomp_la_SOURCES = alloc.c barrier.c critical.c env.c error.c iter.c \\\n \titer_ull.c loop.c loop_ull.c ordered.c parallel.c sections.c single.c \\\n \ttask.c team.c work.c lock.c mutex.c proc.c sem.c bar.c ptrlock.c \\\n-\ttime.c fortran.c affinity.c\n+\ttime.c fortran.c affinity.c target.c\n \n nodist_noinst_HEADERS = libgomp_f.h\n nodist_libsubinclude_HEADERS = omp.h"}, {"sha": "06048e7ce7967ab3449f972b6524c102d7c7f890", "filename": "libgomp/Makefile.in", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FMakefile.in?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -96,7 +96,7 @@ am_libgomp_la_OBJECTS = alloc.lo barrier.lo critical.lo env.lo \\\n \terror.lo iter.lo iter_ull.lo loop.lo loop_ull.lo ordered.lo \\\n \tparallel.lo sections.lo single.lo task.lo team.lo work.lo \\\n \tlock.lo mutex.lo proc.lo sem.lo bar.lo ptrlock.lo time.lo \\\n-\tfortran.lo affinity.lo\n+\tfortran.lo affinity.lo target.lo\n libgomp_la_OBJECTS = $(am_libgomp_la_OBJECTS)\n DEFAULT_INCLUDES = -I.@am__isrc@\n depcomp = $(SHELL) $(top_srcdir)/../depcomp\n@@ -317,7 +317,7 @@ libgomp_la_LINK = $(LINK) $(libgomp_la_LDFLAGS)\n libgomp_la_SOURCES = alloc.c barrier.c critical.c env.c error.c iter.c \\\n \titer_ull.c loop.c loop_ull.c ordered.c parallel.c sections.c single.c \\\n \ttask.c team.c work.c lock.c mutex.c proc.c sem.c bar.c ptrlock.c \\\n-\ttime.c fortran.c affinity.c\n+\ttime.c fortran.c affinity.c target.c\n \n nodist_noinst_HEADERS = libgomp_f.h\n nodist_libsubinclude_HEADERS = omp.h\n@@ -474,6 +474,7 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sections.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sem.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/single.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/target.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/task.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/team.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/time.Plo@am__quote@"}, {"sha": "2a9fe8f8b8819434bdcc7d4ff6176fb6ac680afd", "filename": "libgomp/barrier.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Fbarrier.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Fbarrier.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fbarrier.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -39,3 +39,15 @@ GOMP_barrier (void)\n \n   gomp_team_barrier_wait (&team->barrier);\n }\n+\n+bool\n+GOMP_barrier_cancel (void)\n+{\n+  struct gomp_thread *thr = gomp_thread ();\n+  struct gomp_team *team = thr->ts.team;\n+\n+  /* The compiler transforms to barrier_cancel when it sees that the\n+     barrier is within a construct that can cancel.  Thus we should\n+     never have an orphaned cancellable barrier.  */\n+  return gomp_team_barrier_wait_cancel (&team->barrier);\n+}"}, {"sha": "789cdce077d34551617b4f5313e3342848403d55", "filename": "libgomp/config/linux/affinity.c", "status": "modified", "additions": 294, "deletions": 57, "changes": 351, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Fconfig%2Flinux%2Faffinity.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Fconfig%2Flinux%2Faffinity.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Flinux%2Faffinity.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -29,90 +29,327 @@\n #endif\n #include \"libgomp.h\"\n #include \"proc.h\"\n+#include <errno.h>\n #include <stdlib.h>\n+#include <stdio.h>\n+#include <string.h>\n #include <unistd.h>\n \n #ifdef HAVE_PTHREAD_AFFINITY_NP\n \n-static unsigned int affinity_counter;\n+#ifndef CPU_ALLOC_SIZE\n+#define CPU_ISSET_S(idx, size, set) CPU_ISSET(idx, set)\n+#define CPU_ZERO_S(size, set) CPU_ZERO(set)\n+#define CPU_SET_S(idx, size, set) CPU_SET(idx, set)\n+#define CPU_CLR_S(idx, size, set) CPU_CLR(idx, set)\n+#endif\n \n void\n gomp_init_affinity (void)\n {\n-  cpu_set_t cpuset, cpusetnew;\n-  size_t idx, widx;\n-  unsigned long cpus = 0;\n+  if (gomp_places_list == NULL)\n+    {\n+      if (!gomp_affinity_init_level (1, ULONG_MAX, true))\n+\treturn;\n+    }\n+\n+  struct gomp_thread *thr = gomp_thread ();\n+  pthread_setaffinity_np (pthread_self (), gomp_cpuset_size,\n+\t\t\t  (cpu_set_t *) gomp_places_list[0]);\n+  thr->place = 1;\n+  thr->ts.place_partition_off = 0;\n+  thr->ts.place_partition_len = gomp_places_list_len;\n+}\n+\n+void\n+gomp_init_thread_affinity (pthread_attr_t *attr, unsigned int place)\n+{\n+  pthread_attr_setaffinity_np (attr, gomp_cpuset_size,\n+\t\t\t       (cpu_set_t *) gomp_places_list[place]);\n+}\n+\n+void **\n+gomp_affinity_alloc (unsigned long count, bool quiet)\n+{\n+  unsigned long i;\n+  void **ret;\n+  char *p;\n+\n+  if (gomp_cpusetp == NULL)\n+    {\n+      if (!quiet)\n+\tgomp_error (\"Could not get CPU affinity set\");\n+      return NULL;\n+    }\n \n-  if (pthread_getaffinity_np (pthread_self (), sizeof (cpuset), &cpuset))\n+  ret = malloc (count * sizeof (void *) + count * gomp_cpuset_size);\n+  if (ret == NULL)\n     {\n-      gomp_error (\"could not get CPU affinity set\");\n-      free (gomp_cpu_affinity);\n-      gomp_cpu_affinity = NULL;\n-      gomp_cpu_affinity_len = 0;\n-      return;\n+      if (!quiet)\n+\tgomp_error (\"Out of memory trying to allocate places list\");\n+      return NULL;\n     }\n \n-  CPU_ZERO (&cpusetnew);\n-  if (gomp_cpu_affinity_len == 0)\n+  p = (char *) (ret + count);\n+  for (i = 0; i < count; i++, p += gomp_cpuset_size)\n+    ret[i] = p;\n+  return ret;\n+}\n+\n+void\n+gomp_affinity_init_place (void *p)\n+{\n+  cpu_set_t *cpusetp = (cpu_set_t *) p;\n+  CPU_ZERO_S (gomp_cpuset_size, cpusetp);\n+}\n+\n+bool\n+gomp_affinity_add_cpus (void *p, unsigned long num,\n+\t\t\tunsigned long len, long stride, bool quiet)\n+{\n+  cpu_set_t *cpusetp = (cpu_set_t *) p;\n+  unsigned long max = 8 * gomp_cpuset_size;\n+  for (;;)\n     {\n-      unsigned long count = gomp_cpuset_popcount (&cpuset);\n-      if (count >= 65536)\n-\tcount = 65536;\n-      gomp_cpu_affinity = malloc (count * sizeof (unsigned short));\n-      if (gomp_cpu_affinity == NULL)\n+      if (num >= max)\n+\t{\n+\t  if (!quiet)\n+\t    gomp_error (\"Logical CPU number %lu out of range\", num);\n+\t  return false;\n+\t}\n+      CPU_SET_S (num, gomp_cpuset_size, cpusetp);\n+      if (--len == 0)\n+\treturn true;\n+      if ((stride < 0 && num + stride > num)\n+\t  || (stride > 0 && num + stride < num))\n \t{\n-\t  gomp_error (\"not enough memory to store CPU affinity list\");\n-\t  return;\n+\t  if (!quiet)\n+\t    gomp_error (\"Logical CPU number %lu+%ld out of range\",\n+\t\t\tnum, stride);\n+\t  return false;\n \t}\n-      for (widx = idx = 0; widx < count && idx < 65536; idx++)\n-\tif (CPU_ISSET (idx, &cpuset))\n+      num += stride;\n+    }\n+}\n+\n+bool\n+gomp_affinity_remove_cpu (void *p, unsigned long num)\n+{\n+  cpu_set_t *cpusetp = (cpu_set_t *) p;\n+  if (num >= 8 * gomp_cpuset_size)\n+    {\n+      gomp_error (\"Logical CPU number %lu out of range\", num);\n+      return false;\n+    }\n+  if (!CPU_ISSET_S (num, gomp_cpuset_size, cpusetp))\n+    {\n+      gomp_error (\"Logical CPU %lu to be removed is not in the set\", num);\n+      return false;\n+    }\n+  CPU_CLR_S (num, gomp_cpuset_size, cpusetp);\n+  return true;\n+}\n+\n+bool\n+gomp_affinity_copy_place (void *p, void *q, long stride)\n+{\n+  unsigned long i, max = 8 * gomp_cpuset_size;\n+  cpu_set_t *destp = (cpu_set_t *) p;\n+  cpu_set_t *srcp = (cpu_set_t *) q;\n+\n+  CPU_ZERO_S (gomp_cpuset_size, destp);\n+  for (i = 0; i < max; i++)\n+    if (CPU_ISSET_S (i, gomp_cpuset_size, srcp))\n+      {\n+\tif ((stride < 0 && i + stride > i)\n+\t    || (stride > 0 && (i + stride < i || i + stride >= max)))\n+\t  {\n+\t    gomp_error (\"Logical CPU number %lu+%ld out of range\", i, stride);\n+\t    return false;\n+\t  }\n+\tCPU_SET_S (i + stride, gomp_cpuset_size, destp);\n+      }\n+  return true;\n+}\n+\n+bool\n+gomp_affinity_same_place (void *p, void *q)\n+{\n+#ifdef CPU_EQUAL_S\n+  return CPU_EQUAL_S (gomp_cpuset_size, (cpu_set_t *) p, (cpu_set_t *) q);\n+#else\n+  return memcmp (p, q, gomp_cpuset_size) == 0;\n+#endif\n+}\n+\n+bool\n+gomp_affinity_finalize_place_list (bool quiet)\n+{\n+  unsigned long i, j;\n+\n+  for (i = 0, j = 0; i < gomp_places_list_len; i++)\n+    {\n+      cpu_set_t *cpusetp = (cpu_set_t *) gomp_places_list[i];\n+      bool nonempty = false;\n+#ifdef CPU_AND_S\n+      CPU_AND_S (gomp_cpuset_size, cpusetp, cpusetp, gomp_cpusetp);\n+      nonempty = gomp_cpuset_popcount (gomp_cpuset_size, cpusetp) != 0;\n+#else\n+      unsigned long k, max = gomp_cpuset_size / sizeof (cpusetp->__bits[0]);\n+      for (k = 0; k < max; k++)\n+\tif ((cpusetp->__bits[k] &= gomp_cpusetp->__bits[k]) != 0)\n+\t  nonempty = true;\n+#endif\n+      if (nonempty)\n+\tgomp_places_list[j++] = gomp_places_list[i];\n+    }\n+\n+  if (j == 0)\n+    {\n+      if (!quiet)\n+\tgomp_error (\"None of the places contain usable logical CPUs\");\n+      return false;\n+    }\n+  else if (j < gomp_places_list_len)\n+    {\n+      if (!quiet)\n+\tgomp_error (\"Number of places reduced from %ld to %ld because some \"\n+\t\t    \"places didn't contain any usable logical CPUs\",\n+\t\t    gomp_places_list_len, j);\n+      gomp_places_list_len = j;\n+    }\n+  return true;\n+}\n+\n+bool\n+gomp_affinity_init_level (int level, unsigned long count, bool quiet)\n+{\n+  unsigned long i, max = 8 * gomp_cpuset_size;\n+\n+  if (gomp_cpusetp)\n+    {\n+      unsigned long maxcount\n+\t= gomp_cpuset_popcount (gomp_cpuset_size, gomp_cpusetp);\n+      if (count > maxcount)\n+\tcount = maxcount;\n+    }\n+  gomp_places_list = gomp_affinity_alloc (count, quiet);\n+  gomp_places_list_len = 0;\n+  if (gomp_places_list == NULL)\n+    return false;\n+  /* SMT (threads).  */\n+  if (level == 1)\n+    {\n+      for (i = 0; i < max && gomp_places_list_len < count; i++)\n+\tif (CPU_ISSET_S (i, gomp_cpuset_size, gomp_cpusetp))\n \t  {\n-\t    cpus++;\n-\t    gomp_cpu_affinity[widx++] = idx;\n+\t    gomp_affinity_init_place (gomp_places_list[gomp_places_list_len]);\n+\t    gomp_affinity_add_cpus (gomp_places_list[gomp_places_list_len],\n+\t\t\t\t    i, 1, 0, true);\n+\t    ++gomp_places_list_len;\n \t  }\n+      return true;\n     }\n   else\n-    for (widx = idx = 0; idx < gomp_cpu_affinity_len; idx++)\n-      if (gomp_cpu_affinity[idx] < CPU_SETSIZE\n-\t  && CPU_ISSET (gomp_cpu_affinity[idx], &cpuset))\n+    {\n+      char name[sizeof (\"/sys/devices/system/cpu/cpu/topology/\"\n+\t\t\t\"thread_siblings_list\") + 3 * sizeof (unsigned long)];\n+      size_t prefix_len = sizeof (\"/sys/devices/system/cpu/cpu\") - 1;\n+      cpu_set_t *copy = gomp_alloca (gomp_cpuset_size);\n+      FILE *f;\n+      char *line = NULL;\n+      size_t linelen = 0;\n+\n+      memcpy (name, \"/sys/devices/system/cpu/cpu\", prefix_len);\n+      memcpy (copy, gomp_cpusetp, gomp_cpuset_size);\n+      for (i = 0; i < max && gomp_places_list_len < count; i++)\n+\tif (CPU_ISSET_S (i, gomp_cpuset_size, copy))\n+\t  {\n+\t    sprintf (name + prefix_len, \"%lu/topology/%s_siblings_list\",\n+\t\t     i, level == 2 ? \"thread\" : \"core\");\n+\t    f = fopen (name, \"r\");\n+\t    if (f != NULL)\n+\t      {\n+\t\tif (getline (&line, &linelen, f) > 0)\n+\t\t  {\n+\t\t    char *p = line;\n+\t\t    bool seen_i = false;\n+\t\t    void *pl = gomp_places_list[gomp_places_list_len];\n+\t\t    gomp_affinity_init_place (pl);\n+\t\t    while (*p && *p != '\\n')\n+\t\t      {\n+\t\t\tunsigned long first, last;\n+\t\t\terrno = 0;\n+\t\t\tfirst = strtoul (p, &p, 10);\n+\t\t\tif (errno)\n+\t\t\t  break;\n+\t\t\tlast = first;\n+\t\t\tif (*p == '-')\n+\t\t\t  {\n+\t\t\t    errno = 0;\n+\t\t\t    last = strtoul (p + 1, &p, 10);\n+\t\t\t    if (errno || last < first)\n+\t\t\t      break;\n+\t\t\t  }\n+\t\t\tfor (; first <= last; first++)\n+\t\t\t  if (CPU_ISSET_S (first, gomp_cpuset_size, copy)\n+\t\t\t      && gomp_affinity_add_cpus (pl, first, 1, 0,\n+\t\t\t\t\t\t\t true))\n+\t\t\t    {\n+\t\t\t      CPU_CLR_S (first, gomp_cpuset_size, copy);\n+\t\t\t      if (first == i)\n+\t\t\t\tseen_i = true;\n+\t\t\t    }\n+\t\t\tif (*p == ',')\n+\t\t\t  ++p;\n+\t\t      }\n+\t\t    if (seen_i)\n+\t\t      gomp_places_list_len++;\n+\t\t  }\n+\t\tfclose (f);\n+\t      }\n+\t  }\n+      if (gomp_places_list == 0)\n \t{\n-\t  if (! CPU_ISSET (gomp_cpu_affinity[idx], &cpusetnew))\n-\t    {\n-\t      cpus++;\n-\t      CPU_SET (gomp_cpu_affinity[idx], &cpusetnew);\n-\t    }\n-\t  gomp_cpu_affinity[widx++] = gomp_cpu_affinity[idx];\n+\t  if (!quiet)\n+\t    gomp_error (\"Error reading %s topology\",\n+\t\t\tlevel == 2 ? \"core\" : \"socket\");\n+\t  free (gomp_places_list);\n+\t  gomp_places_list = NULL;\n+\t  return false;\n \t}\n-\n-  if (widx == 0)\n-    {\n-      gomp_error (\"no CPUs left for affinity setting\");\n-      free (gomp_cpu_affinity);\n-      gomp_cpu_affinity = NULL;\n-      gomp_cpu_affinity_len = 0;\n-      return;\n+      return true;\n     }\n-\n-  gomp_cpu_affinity_len = widx;\n-  if (cpus < gomp_available_cpus)\n-    gomp_available_cpus = cpus;\n-  CPU_ZERO (&cpuset);\n-  CPU_SET (gomp_cpu_affinity[0], &cpuset);\n-  pthread_setaffinity_np (pthread_self (), sizeof (cpuset), &cpuset);\n-  affinity_counter = 1;\n+  return false;\n }\n \n void\n-gomp_init_thread_affinity (pthread_attr_t *attr)\n+gomp_affinity_print_place (void *p)\n {\n-  unsigned int cpu;\n-  cpu_set_t cpuset;\n-\n-  cpu = __atomic_fetch_add (&affinity_counter, 1, MEMMODEL_RELAXED);\n-  cpu %= gomp_cpu_affinity_len;\n-  CPU_ZERO (&cpuset);\n-  CPU_SET (gomp_cpu_affinity[cpu], &cpuset);\n-  pthread_attr_setaffinity_np (attr, sizeof (cpu_set_t), &cpuset);\n+  unsigned long i, max = 8 * gomp_cpuset_size, len;\n+  cpu_set_t *cpusetp = (cpu_set_t *) p;\n+  bool notfirst = false;\n+\n+  for (i = 0, len = 0; i < max; i++)\n+    if (CPU_ISSET_S (i, gomp_cpuset_size, cpusetp))\n+      {\n+\tif (len == 0)\n+\t  {\n+\t    if (notfirst)\n+\t      fputc (',', stderr);\n+\t    notfirst = true;\n+\t    fprintf (stderr, \"%lu\", i);\n+\t  }\n+\t++len;\n+      }\n+    else\n+      {\n+\tif (len > 1)\n+\t  fprintf (stderr, \":%lu\", len);\n+\tlen = 0;\n+      }\n+  if (len > 1)\n+    fprintf (stderr, \":%lu\", len);\n }\n \n #else"}, {"sha": "6b591e5a6c5dfd8054a37837d8e42156e18b8ace", "filename": "libgomp/config/linux/bar.c", "status": "modified", "additions": 96, "deletions": 10, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Fconfig%2Flinux%2Fbar.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Fconfig%2Flinux%2Fbar.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Flinux%2Fbar.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -33,11 +33,11 @@\n void\n gomp_barrier_wait_end (gomp_barrier_t *bar, gomp_barrier_state_t state)\n {\n-  if (__builtin_expect ((state & 1) != 0, 0))\n+  if (__builtin_expect (state & BAR_WAS_LAST, 0))\n     {\n       /* Next time we'll be awaiting TOTAL threads again.  */\n       bar->awaited = bar->total;\n-      __atomic_store_n (&bar->generation, bar->generation + 4,\n+      __atomic_store_n (&bar->generation, bar->generation + BAR_INCR,\n \t\t\tMEMMODEL_RELEASE);\n       futex_wake ((int *) &bar->generation, INT_MAX);\n     }\n@@ -66,7 +66,7 @@ void\n gomp_barrier_wait_last (gomp_barrier_t *bar)\n {\n   gomp_barrier_state_t state = gomp_barrier_wait_start (bar);\n-  if (state & 1)\n+  if (state & BAR_WAS_LAST)\n     gomp_barrier_wait_end (bar, state);\n }\n \n@@ -81,44 +81,130 @@ gomp_team_barrier_wait_end (gomp_barrier_t *bar, gomp_barrier_state_t state)\n {\n   unsigned int generation, gen;\n \n-  if (__builtin_expect ((state & 1) != 0, 0))\n+  if (__builtin_expect (state & BAR_WAS_LAST, 0))\n     {\n       /* Next time we'll be awaiting TOTAL threads again.  */\n       struct gomp_thread *thr = gomp_thread ();\n       struct gomp_team *team = thr->ts.team;\n \n       bar->awaited = bar->total;\n+      team->work_share_cancelled = 0;\n       if (__builtin_expect (team->task_count, 0))\n \t{\n \t  gomp_barrier_handle_tasks (state);\n-\t  state &= ~1;\n+\t  state &= ~BAR_WAS_LAST;\n \t}\n       else\n \t{\n-\t  __atomic_store_n (&bar->generation, state + 3, MEMMODEL_RELEASE);\n+\t  state &= ~BAR_CANCELLED;\n+\t  state += BAR_INCR - BAR_WAS_LAST;\n+\t  __atomic_store_n (&bar->generation, state, MEMMODEL_RELEASE);\n \t  futex_wake ((int *) &bar->generation, INT_MAX);\n \t  return;\n \t}\n     }\n \n   generation = state;\n+  state &= ~BAR_CANCELLED;\n   do\n     {\n       do_wait ((int *) &bar->generation, generation);\n       gen = __atomic_load_n (&bar->generation, MEMMODEL_ACQUIRE);\n-      if (__builtin_expect (gen & 1, 0))\n+      if (__builtin_expect (gen & BAR_TASK_PENDING, 0))\n \t{\n \t  gomp_barrier_handle_tasks (state);\n \t  gen = __atomic_load_n (&bar->generation, MEMMODEL_ACQUIRE);\n \t}\n-      if ((gen & 2) != 0)\n-\tgeneration |= 2;\n+      generation |= gen & BAR_WAITING_FOR_TASK;\n     }\n-  while (gen != state + 4);\n+  while (gen != state + BAR_INCR);\n }\n \n void\n gomp_team_barrier_wait (gomp_barrier_t *bar)\n {\n   gomp_team_barrier_wait_end (bar, gomp_barrier_wait_start (bar));\n }\n+\n+void\n+gomp_team_barrier_wait_final (gomp_barrier_t *bar)\n+{\n+  gomp_barrier_state_t state = gomp_barrier_wait_final_start (bar);\n+  if (__builtin_expect (state & BAR_WAS_LAST, 0))\n+    bar->awaited_final = bar->total;\n+  gomp_team_barrier_wait_end (bar, state);\n+}\n+\n+bool\n+gomp_team_barrier_wait_cancel_end (gomp_barrier_t *bar,\n+\t\t\t\t   gomp_barrier_state_t state)\n+{\n+  unsigned int generation, gen;\n+\n+  if (__builtin_expect (state & BAR_WAS_LAST, 0))\n+    {\n+      /* Next time we'll be awaiting TOTAL threads again.  */\n+      /* BAR_CANCELLED should never be set in state here, because\n+\t cancellation means that at least one of the threads has been\n+\t cancelled, thus on a cancellable barrier we should never see\n+\t all threads to arrive.  */\n+      struct gomp_thread *thr = gomp_thread ();\n+      struct gomp_team *team = thr->ts.team;\n+\n+      bar->awaited = bar->total;\n+      team->work_share_cancelled = 0;\n+      if (__builtin_expect (team->task_count, 0))\n+\t{\n+\t  gomp_barrier_handle_tasks (state);\n+\t  state &= ~BAR_WAS_LAST;\n+\t}\n+      else\n+\t{\n+\t  state += BAR_INCR - BAR_WAS_LAST;\n+\t  __atomic_store_n (&bar->generation, state, MEMMODEL_RELEASE);\n+\t  futex_wake ((int *) &bar->generation, INT_MAX);\n+\t  return false;\n+\t}\n+    }\n+\n+  if (__builtin_expect (state & BAR_CANCELLED, 0))\n+    return true;\n+\n+  generation = state;\n+  do\n+    {\n+      do_wait ((int *) &bar->generation, generation);\n+      gen = __atomic_load_n (&bar->generation, MEMMODEL_ACQUIRE);\n+      if (__builtin_expect (gen & BAR_CANCELLED, 0))\n+\treturn true;\n+      if (__builtin_expect (gen & BAR_TASK_PENDING, 0))\n+\t{\n+\t  gomp_barrier_handle_tasks (state);\n+\t  gen = __atomic_load_n (&bar->generation, MEMMODEL_ACQUIRE);\n+\t}\n+      generation |= gen & BAR_WAITING_FOR_TASK;\n+    }\n+  while (gen != state + BAR_INCR);\n+\n+  return false;\n+}\n+\n+bool\n+gomp_team_barrier_wait_cancel (gomp_barrier_t *bar)\n+{\n+  return gomp_team_barrier_wait_cancel_end (bar, gomp_barrier_wait_start (bar));\n+}\n+\n+void\n+gomp_team_barrier_cancel (struct gomp_team *team)\n+{\n+  gomp_mutex_lock (&team->task_lock);\n+  if (team->barrier.generation & BAR_CANCELLED)\n+    {\n+      gomp_mutex_unlock (&team->task_lock);\n+      return;\n+    }\n+  team->barrier.generation |= BAR_CANCELLED;\n+  gomp_mutex_unlock (&team->task_lock);\n+  futex_wake ((int *) &team->barrier.generation, INT_MAX);\n+}"}, {"sha": "914c86778e560ed576b6c15a3d84e49270f93a2c", "filename": "libgomp/config/linux/bar.h", "status": "modified", "additions": 54, "deletions": 8, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Fconfig%2Flinux%2Fbar.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Fconfig%2Flinux%2Fbar.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Flinux%2Fbar.h?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -38,13 +38,25 @@ typedef struct\n   unsigned total __attribute__((aligned (64)));\n   unsigned generation;\n   unsigned awaited __attribute__((aligned (64)));\n+  unsigned awaited_final;\n } gomp_barrier_t;\n+\n typedef unsigned int gomp_barrier_state_t;\n \n+/* The generation field contains a counter in the high bits, with a few\n+   low bits dedicated to flags.  Note that TASK_PENDING and WAS_LAST can\n+   share space because WAS_LAST is never stored back to generation.  */\n+#define BAR_TASK_PENDING\t1\n+#define BAR_WAS_LAST\t\t1\n+#define BAR_WAITING_FOR_TASK\t2\n+#define BAR_CANCELLED\t\t4\n+#define BAR_INCR\t\t8\n+\n static inline void gomp_barrier_init (gomp_barrier_t *bar, unsigned count)\n {\n   bar->total = count;\n   bar->awaited = count;\n+  bar->awaited_final = count;\n   bar->generation = 0;\n }\n \n@@ -62,27 +74,55 @@ extern void gomp_barrier_wait (gomp_barrier_t *);\n extern void gomp_barrier_wait_last (gomp_barrier_t *);\n extern void gomp_barrier_wait_end (gomp_barrier_t *, gomp_barrier_state_t);\n extern void gomp_team_barrier_wait (gomp_barrier_t *);\n+extern void gomp_team_barrier_wait_final (gomp_barrier_t *);\n extern void gomp_team_barrier_wait_end (gomp_barrier_t *,\n \t\t\t\t\tgomp_barrier_state_t);\n+extern bool gomp_team_barrier_wait_cancel (gomp_barrier_t *);\n+extern bool gomp_team_barrier_wait_cancel_end (gomp_barrier_t *,\n+\t\t\t\t\t       gomp_barrier_state_t);\n extern void gomp_team_barrier_wake (gomp_barrier_t *, int);\n+struct gomp_team;\n+extern void gomp_team_barrier_cancel (struct gomp_team *);\n \n static inline gomp_barrier_state_t\n gomp_barrier_wait_start (gomp_barrier_t *bar)\n {\n-  unsigned int ret = __atomic_load_n (&bar->generation, MEMMODEL_ACQUIRE) & ~3;\n+  unsigned int ret = __atomic_load_n (&bar->generation, MEMMODEL_ACQUIRE);\n+  ret &= -BAR_INCR | BAR_CANCELLED;\n   /* A memory barrier is needed before exiting from the various forms\n      of gomp_barrier_wait, to satisfy OpenMP API version 3.1 section\n      2.8.6 flush Construct, which says there is an implicit flush during\n      a barrier region.  This is a convenient place to add the barrier,\n      so we use MEMMODEL_ACQ_REL here rather than MEMMODEL_ACQUIRE.  */\n-  ret += __atomic_add_fetch (&bar->awaited, -1, MEMMODEL_ACQ_REL) == 0;\n+  if (__atomic_add_fetch (&bar->awaited, -1, MEMMODEL_ACQ_REL) == 0)\n+    ret |= BAR_WAS_LAST;\n+  return ret;\n+}\n+\n+static inline gomp_barrier_state_t\n+gomp_barrier_wait_cancel_start (gomp_barrier_t *bar)\n+{\n+  return gomp_barrier_wait_start (bar);\n+}\n+\n+/* This is like gomp_barrier_wait_start, except it decrements\n+   bar->awaited_final rather than bar->awaited and should be used\n+   for the gomp_team_end barrier only.  */\n+static inline gomp_barrier_state_t\n+gomp_barrier_wait_final_start (gomp_barrier_t *bar)\n+{\n+  unsigned int ret = __atomic_load_n (&bar->generation, MEMMODEL_ACQUIRE);\n+  ret &= -BAR_INCR | BAR_CANCELLED;\n+  /* See above gomp_barrier_wait_start comment.  */\n+  if (__atomic_add_fetch (&bar->awaited_final, -1, MEMMODEL_ACQ_REL) == 0)\n+    ret |= BAR_WAS_LAST;\n   return ret;\n }\n \n static inline bool\n gomp_barrier_last_thread (gomp_barrier_state_t state)\n {\n-  return state & 1;\n+  return state & BAR_WAS_LAST;\n }\n \n /* All the inlines below must be called with team->task_lock\n@@ -91,31 +131,37 @@ gomp_barrier_last_thread (gomp_barrier_state_t state)\n static inline void\n gomp_team_barrier_set_task_pending (gomp_barrier_t *bar)\n {\n-  bar->generation |= 1;\n+  bar->generation |= BAR_TASK_PENDING;\n }\n \n static inline void\n gomp_team_barrier_clear_task_pending (gomp_barrier_t *bar)\n {\n-  bar->generation &= ~1;\n+  bar->generation &= ~BAR_TASK_PENDING;\n }\n \n static inline void\n gomp_team_barrier_set_waiting_for_tasks (gomp_barrier_t *bar)\n {\n-  bar->generation |= 2;\n+  bar->generation |= BAR_WAITING_FOR_TASK;\n }\n \n static inline bool\n gomp_team_barrier_waiting_for_tasks (gomp_barrier_t *bar)\n {\n-  return (bar->generation & 2) != 0;\n+  return (bar->generation & BAR_WAITING_FOR_TASK) != 0;\n+}\n+\n+static inline bool\n+gomp_team_barrier_cancelled (gomp_barrier_t *bar)\n+{\n+  return __builtin_expect ((bar->generation & BAR_CANCELLED) != 0, 0);\n }\n \n static inline void\n gomp_team_barrier_done (gomp_barrier_t *bar, gomp_barrier_state_t state)\n {\n-  bar->generation = (state & ~3) + 4;\n+  bar->generation = (state & -BAR_INCR) + BAR_INCR;\n }\n \n #endif /* GOMP_BARRIER_H */"}, {"sha": "d4ae116e23963b3fe3610b018dad672db986f8bf", "filename": "libgomp/config/linux/proc.c", "status": "modified", "additions": 76, "deletions": 20, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Fconfig%2Flinux%2Fproc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Fconfig%2Flinux%2Fproc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Flinux%2Fproc.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -30,6 +30,7 @@\n #endif\n #include \"libgomp.h\"\n #include \"proc.h\"\n+#include <errno.h>\n #include <stdlib.h>\n #include <unistd.h>\n #ifdef HAVE_GETLOADAVG\n@@ -39,19 +40,28 @@\n #endif\n \n #ifdef HAVE_PTHREAD_AFFINITY_NP\n+unsigned long gomp_cpuset_size;\n+static unsigned long gomp_get_cpuset_size;\n+cpu_set_t *gomp_cpusetp;\n+\n unsigned long\n-gomp_cpuset_popcount (cpu_set_t *cpusetp)\n+gomp_cpuset_popcount (unsigned long cpusetsize, cpu_set_t *cpusetp)\n {\n-#ifdef CPU_COUNT\n-  /* glibc 2.6 and above provide a macro for this.  */\n-  return CPU_COUNT (cpusetp);\n+#ifdef CPU_COUNT_S\n+  /* glibc 2.7 and above provide a macro for this.  */\n+  return CPU_COUNT_S (cpusetsize, cpusetp);\n #else\n+#ifdef CPU_COUNT\n+  if (cpusetsize == sizeof (cpu_set_t))\n+    /* glibc 2.6 and above provide a macro for this.  */\n+    return CPU_COUNT (cpusetp);\n+#endif\n   size_t i;\n   unsigned long ret = 0;\n-  extern int check[sizeof (cpusetp->__bits[0]) == sizeof (unsigned long int)];\n+  extern int check[sizeof (cpusetp->__bits[0]) == sizeof (unsigned long int)\n+\t\t   ? 1 : -1];\n \n-  (void) check;\n-  for (i = 0; i < sizeof (*cpusetp) / sizeof (cpusetp->__bits[0]); i++)\n+  for (i = 0; i < cpusetsize / sizeof (cpusetp->__bits[0]); i++)\n     {\n       unsigned long int mask = cpusetp->__bits[i];\n       if (mask == 0)\n@@ -70,16 +80,63 @@ void\n gomp_init_num_threads (void)\n {\n #ifdef HAVE_PTHREAD_AFFINITY_NP\n-  cpu_set_t cpuset;\n+#if defined (_SC_NPROCESSORS_CONF) && defined (CPU_ALLOC_SIZE)\n+  gomp_cpuset_size = sysconf (_SC_NPROCESSORS_CONF);\n+  gomp_cpuset_size = CPU_ALLOC_SIZE (gomp_cpuset_size);\n+#else\n+  gomp_cpuset_size = sizeof (cpu_set_t);\n+#endif\n \n-  if (pthread_getaffinity_np (pthread_self (), sizeof (cpuset), &cpuset) == 0)\n+  gomp_cpusetp = (cpu_set_t *) gomp_malloc (gomp_cpuset_size);\n+  do\n     {\n-      /* Count only the CPUs this process can use.  */\n-      gomp_global_icv.nthreads_var = gomp_cpuset_popcount (&cpuset);\n-      if (gomp_global_icv.nthreads_var == 0)\n-\tgomp_global_icv.nthreads_var = 1;\n-      return;\n+      int ret = pthread_getaffinity_np (pthread_self (), gomp_cpuset_size,\n+\t\t\t\t\tgomp_cpusetp);\n+      if (ret == 0)\n+\t{\n+\t  unsigned long i;\n+\t  /* Count only the CPUs this process can use.  */\n+\t  gomp_global_icv.nthreads_var\n+\t    = gomp_cpuset_popcount (gomp_cpuset_size, gomp_cpusetp);\n+\t  if (gomp_global_icv.nthreads_var == 0)\n+\t    break;\n+\t  gomp_get_cpuset_size = gomp_cpuset_size;\n+#ifdef CPU_ALLOC_SIZE\n+\t  for (i = gomp_cpuset_size * 8; i; i--)\n+\t    if (CPU_ISSET_S (i - 1, gomp_cpuset_size, gomp_cpusetp))\n+\t      break;\n+\t  gomp_cpuset_size = CPU_ALLOC_SIZE (i);\n+#endif\n+\t  return;\n+\t}\n+      if (ret != EINVAL)\n+\tbreak;\n+#ifdef CPU_ALLOC_SIZE\n+      if (gomp_cpuset_size < sizeof (cpu_set_t))\n+\tgomp_cpuset_size = sizeof (cpu_set_t);\n+      else\n+\tgomp_cpuset_size = gomp_cpuset_size * 2;\n+      if (gomp_cpuset_size < 8 * sizeof (cpu_set_t))\n+\tgomp_cpusetp\n+\t  = (cpu_set_t *) gomp_realloc (gomp_cpusetp, gomp_cpuset_size);\n+      else\n+\t{\n+\t  /* Avoid gomp_fatal if too large memory allocation would be\n+\t     requested, e.g. kernel returning EINVAL all the time.  */\n+\t  void *p = realloc (gomp_cpusetp, gomp_cpuset_size);\n+\t  if (p == NULL)\n+\t    break;\n+\t  gomp_cpusetp = (cpu_set_t *) p;\n+\t}\n+#else\n+      break;\n+#endif\n     }\n+  while (1);\n+  gomp_cpuset_size = 0;\n+  gomp_global_icv.nthreads_var = 1;\n+  free (gomp_cpusetp);\n+  gomp_cpusetp = NULL;\n #endif\n #ifdef _SC_NPROCESSORS_ONLN\n   gomp_global_icv.nthreads_var = sysconf (_SC_NPROCESSORS_ONLN);\n@@ -90,15 +147,14 @@ static int\n get_num_procs (void)\n {\n #ifdef HAVE_PTHREAD_AFFINITY_NP\n-  cpu_set_t cpuset;\n-\n-  if (gomp_cpu_affinity == NULL)\n+  if (gomp_places_list == NULL)\n     {\n       /* Count only the CPUs this process can use.  */\n-      if (pthread_getaffinity_np (pthread_self (), sizeof (cpuset),\n-\t\t\t\t  &cpuset) == 0)\n+      if (gomp_cpusetp\n+\t  && pthread_getaffinity_np (pthread_self (), gomp_get_cpuset_size,\n+\t\t\t\t     gomp_cpusetp) == 0)\n \t{\n-\t  int ret = gomp_cpuset_popcount (&cpuset);\n+\t  int ret = gomp_cpuset_popcount (gomp_get_cpuset_size, gomp_cpusetp);\n \t  return ret != 0 ? ret : 1;\n \t}\n     }"}, {"sha": "bdc85dba99e6032f4b25ec1274a13b664b3a414f", "filename": "libgomp/config/linux/proc.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Fconfig%2Flinux%2Fproc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Fconfig%2Flinux%2Fproc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Flinux%2Fproc.h?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -28,7 +28,10 @@\n #include <sched.h>\n \n #ifdef HAVE_PTHREAD_AFFINITY_NP\n-extern unsigned long gomp_cpuset_popcount (cpu_set_t *);\n+extern unsigned long gomp_cpuset_size attribute_hidden;\n+extern cpu_set_t *gomp_cpusetp attribute_hidden;\n+extern unsigned long gomp_cpuset_popcount (unsigned long, cpu_set_t *)\n+     attribute_hidden;\n #endif\n \n #endif /* GOMP_PROC_H */"}, {"sha": "e7f97ab08d60251e8fe4c47dcaa2512989f59c7d", "filename": "libgomp/config/posix/affinity.c", "status": "modified", "additions": 78, "deletions": 1, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Fconfig%2Fposix%2Faffinity.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Fconfig%2Fposix%2Faffinity.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Fposix%2Faffinity.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -32,7 +32,84 @@ gomp_init_affinity (void)\n }\n \n void\n-gomp_init_thread_affinity (pthread_attr_t *attr)\n+gomp_init_thread_affinity (pthread_attr_t *attr, unsigned int place)\n {\n   (void) attr;\n+  (void) place;\n+}\n+\n+void **\n+gomp_affinity_alloc (unsigned long count, bool quiet)\n+{\n+  (void) count;\n+  if (!quiet)\n+    gomp_error (\"Affinity not supported on this configuration\");\n+  return NULL;\n+}\n+\n+void\n+gomp_affinity_init_place (void *p)\n+{\n+  (void) p;\n+}\n+\n+bool\n+gomp_affinity_add_cpus (void *p, unsigned long num,\n+\t\t\tunsigned long len, long stride, bool quiet)\n+{\n+  (void) p;\n+  (void) num;\n+  (void) len;\n+  (void) stride;\n+  (void) quiet;\n+  return false;\n+}\n+\n+bool\n+gomp_affinity_remove_cpu (void *p, unsigned long num)\n+{\n+  (void) p;\n+  (void) num;\n+  return false;\n+}\n+\n+bool\n+gomp_affinity_copy_place (void *p, void *q, long stride)\n+{\n+  (void) p;\n+  (void) q;\n+  (void) stride;\n+  return false;\n+}\n+\n+bool\n+gomp_affinity_same_place (void *p, void *q)\n+{\n+  (void) p;\n+  (void) q;\n+  return false;\n+}\n+\n+bool\n+gomp_affinity_finalize_place_list (bool quiet)\n+{\n+  (void) quiet;\n+  return false;\n+}\n+\n+bool\n+gomp_affinity_init_level (int level, unsigned long count, bool quiet)\n+{\n+  (void) level;\n+  (void) count;\n+  (void) quiet;\n+  if (!quiet)\n+    gomp_error (\"Affinity not supported on this configuration\");\n+  return NULL;\n+}\n+\n+void\n+gomp_affinity_print_place (void *p)\n+{\n+  (void) p;\n }"}, {"sha": "bdf3978caee9b0a3e54a1721e577a1948d93ced2", "filename": "libgomp/config/posix/bar.c", "status": "modified", "additions": 126, "deletions": 6, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Fconfig%2Fposix%2Fbar.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Fconfig%2Fposix%2Fbar.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Fposix%2Fbar.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -42,6 +42,7 @@ gomp_barrier_init (gomp_barrier_t *bar, unsigned count)\n   bar->total = count;\n   bar->arrived = 0;\n   bar->generation = 0;\n+  bar->cancellable = false;\n }\n \n void\n@@ -72,7 +73,7 @@ gomp_barrier_wait_end (gomp_barrier_t *bar, gomp_barrier_state_t state)\n {\n   unsigned int n;\n \n-  if (state & 1)\n+  if (state & BAR_WAS_LAST)\n     {\n       n = --bar->arrived;\n       if (n > 0)\n@@ -113,12 +114,14 @@ gomp_team_barrier_wait_end (gomp_barrier_t *bar, gomp_barrier_state_t state)\n {\n   unsigned int n;\n \n-  if (state & 1)\n+  state &= ~BAR_CANCELLED;\n+  if (state & BAR_WAS_LAST)\n     {\n       n = --bar->arrived;\n       struct gomp_thread *thr = gomp_thread ();\n       struct gomp_team *team = thr->ts.team;\n \n+      team->work_share_cancelled = 0;\n       if (team->task_count)\n \t{\n \t  gomp_barrier_handle_tasks (state);\n@@ -128,7 +131,7 @@ gomp_team_barrier_wait_end (gomp_barrier_t *bar, gomp_barrier_state_t state)\n \t  return;\n \t}\n \n-      bar->generation = state + 3;\n+      bar->generation = state + BAR_INCR - BAR_WAS_LAST;\n       if (n > 0)\n \t{\n \t  do\n@@ -141,13 +144,18 @@ gomp_team_barrier_wait_end (gomp_barrier_t *bar, gomp_barrier_state_t state)\n   else\n     {\n       gomp_mutex_unlock (&bar->mutex1);\n+      int gen;\n       do\n \t{\n \t  gomp_sem_wait (&bar->sem1);\n-\t  if (bar->generation & 1)\n-\t    gomp_barrier_handle_tasks (state);\n+\t  gen = __atomic_load_n (&bar->generation, MEMMODEL_ACQUIRE);\n+\t  if (gen & BAR_TASK_PENDING)\n+\t    {\n+\t      gomp_barrier_handle_tasks (state);\n+\t      gen = __atomic_load_n (&bar->generation, MEMMODEL_ACQUIRE);\n+\t    }\n \t}\n-      while (bar->generation != state + 4);\n+      while (gen != state + BAR_INCR);\n \n #ifdef HAVE_SYNC_BUILTINS\n       n = __sync_add_and_fetch (&bar->arrived, -1);\n@@ -162,6 +170,81 @@ gomp_team_barrier_wait_end (gomp_barrier_t *bar, gomp_barrier_state_t state)\n     }\n }\n \n+bool\n+gomp_team_barrier_wait_cancel_end (gomp_barrier_t *bar,\n+\t\t\t\t   gomp_barrier_state_t state)\n+{\n+  unsigned int n;\n+\n+  if (state & BAR_WAS_LAST)\n+    {\n+      bar->cancellable = false;\n+      n = --bar->arrived;\n+      struct gomp_thread *thr = gomp_thread ();\n+      struct gomp_team *team = thr->ts.team;\n+\n+      team->work_share_cancelled = 0;\n+      if (team->task_count)\n+\t{\n+\t  gomp_barrier_handle_tasks (state);\n+\t  if (n > 0)\n+\t    gomp_sem_wait (&bar->sem2);\n+\t  gomp_mutex_unlock (&bar->mutex1);\n+\t  return false;\n+\t}\n+\n+      bar->generation = state + BAR_INCR - BAR_WAS_LAST;\n+      if (n > 0)\n+\t{\n+\t  do\n+\t    gomp_sem_post (&bar->sem1);\n+\t  while (--n != 0);\n+\t  gomp_sem_wait (&bar->sem2);\n+\t}\n+      gomp_mutex_unlock (&bar->mutex1);\n+    }\n+  else\n+    {\n+      if (state & BAR_CANCELLED)\n+\t{\n+\t  gomp_mutex_unlock (&bar->mutex1);\n+\t  return true;\n+\t}\n+      bar->cancellable = true;\n+      gomp_mutex_unlock (&bar->mutex1);\n+      int gen;\n+      do\n+\t{\n+\t  gomp_sem_wait (&bar->sem1);\n+\t  gen = __atomic_load_n (&bar->generation, MEMMODEL_ACQUIRE);\n+\t  if (gen & BAR_CANCELLED)\n+\t    break;\n+\t  if (gen & BAR_TASK_PENDING)\n+\t    {\n+\t      gomp_barrier_handle_tasks (state);\n+\t      gen = __atomic_load_n (&bar->generation, MEMMODEL_ACQUIRE);\n+\t      if (gen & BAR_CANCELLED)\n+\t\tbreak;\n+\t    }\n+\t}\n+      while (gen != state + BAR_INCR);\n+\n+#ifdef HAVE_SYNC_BUILTINS\n+      n = __sync_add_and_fetch (&bar->arrived, -1);\n+#else\n+      gomp_mutex_lock (&bar->mutex2);\n+      n = --bar->arrived;\n+      gomp_mutex_unlock (&bar->mutex2);\n+#endif\n+\n+      if (n == 0)\n+\tgomp_sem_post (&bar->sem2);\n+      if (gen & BAR_CANCELLED)\n+\treturn true;\n+    }\n+  return false;\n+}\n+\n void\n gomp_team_barrier_wait (gomp_barrier_t *barrier)\n {\n@@ -176,3 +259,40 @@ gomp_team_barrier_wake (gomp_barrier_t *bar, int count)\n   while (count-- > 0)\n     gomp_sem_post (&bar->sem1);\n }\n+\n+bool\n+gomp_team_barrier_wait_cancel (gomp_barrier_t *bar)\n+{\n+  gomp_barrier_state_t state = gomp_barrier_wait_cancel_start (bar);\n+  return gomp_team_barrier_wait_cancel_end (bar, state);\n+}\n+\n+void\n+gomp_team_barrier_cancel (struct gomp_team *team)\n+{\n+  if (team->barrier.generation & BAR_CANCELLED)\n+    return;\n+  gomp_mutex_lock (&team->barrier.mutex1);\n+  gomp_mutex_lock (&team->task_lock);\n+  if (team->barrier.generation & BAR_CANCELLED)\n+    {\n+      gomp_mutex_unlock (&team->task_lock);\n+      gomp_mutex_unlock (&team->barrier.mutex1);\n+      return;\n+    }\n+  team->barrier.generation |= BAR_CANCELLED;\n+  gomp_mutex_unlock (&team->task_lock);\n+  if (team->barrier.cancellable)\n+    {\n+      int n = team->barrier.arrived;\n+      if (n > 0)\n+\t{\n+\t  do\n+\t    gomp_sem_post (&team->barrier.sem1);\n+\t  while (--n != 0);\n+\t  gomp_sem_wait (&team->barrier.sem2);\n+\t}\n+      team->barrier.cancellable = false;\n+    }\n+  gomp_mutex_unlock (&team->barrier.mutex1);\n+}"}, {"sha": "9fcd4da6723537e60c67182088d6d0da1114cbf7", "filename": "libgomp/config/posix/bar.h", "status": "modified", "additions": 50, "deletions": 8, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Fconfig%2Fposix%2Fbar.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Fconfig%2Fposix%2Fbar.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Fposix%2Fbar.h?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -43,9 +43,20 @@ typedef struct\n   unsigned total;\n   unsigned arrived;\n   unsigned generation;\n+  bool cancellable;\n } gomp_barrier_t;\n+\n typedef unsigned int gomp_barrier_state_t;\n \n+/* The generation field contains a counter in the high bits, with a few\n+   low bits dedicated to flags.  Note that TASK_PENDING and WAS_LAST can\n+   share space because WAS_LAST is never stored back to generation.  */\n+#define BAR_TASK_PENDING\t1\n+#define BAR_WAS_LAST\t\t1\n+#define BAR_WAITING_FOR_TASK\t2\n+#define BAR_CANCELLED\t\t4\n+#define BAR_INCR\t\t8\n+\n extern void gomp_barrier_init (gomp_barrier_t *, unsigned);\n extern void gomp_barrier_reinit (gomp_barrier_t *, unsigned);\n extern void gomp_barrier_destroy (gomp_barrier_t *);\n@@ -55,22 +66,47 @@ extern void gomp_barrier_wait_end (gomp_barrier_t *, gomp_barrier_state_t);\n extern void gomp_team_barrier_wait (gomp_barrier_t *);\n extern void gomp_team_barrier_wait_end (gomp_barrier_t *,\n \t\t\t\t\tgomp_barrier_state_t);\n+extern bool gomp_team_barrier_wait_cancel (gomp_barrier_t *);\n+extern bool gomp_team_barrier_wait_cancel_end (gomp_barrier_t *,\n+\t\t\t\t\t       gomp_barrier_state_t);\n extern void gomp_team_barrier_wake (gomp_barrier_t *, int);\n+struct gomp_team;\n+extern void gomp_team_barrier_cancel (struct gomp_team *);\n \n static inline gomp_barrier_state_t\n gomp_barrier_wait_start (gomp_barrier_t *bar)\n {\n   unsigned int ret;\n   gomp_mutex_lock (&bar->mutex1);\n-  ret = bar->generation & ~3;\n-  ret += ++bar->arrived == bar->total;\n+  ret = bar->generation & (-BAR_INCR | BAR_CANCELLED);\n+  if (++bar->arrived == bar->total)\n+    ret |= BAR_WAS_LAST;\n+  return ret;\n+}\n+\n+static inline gomp_barrier_state_t\n+gomp_barrier_wait_cancel_start (gomp_barrier_t *bar)\n+{\n+  unsigned int ret;\n+  gomp_mutex_lock (&bar->mutex1);\n+  ret = bar->generation & (-BAR_INCR | BAR_CANCELLED);\n+  if (ret & BAR_CANCELLED)\n+    return ret;\n+  if (++bar->arrived == bar->total)\n+    ret |= BAR_WAS_LAST;\n   return ret;\n }\n \n+static inline void\n+gomp_team_barrier_wait_final (gomp_barrier_t *bar)\n+{\n+  gomp_team_barrier_wait (bar);\n+}\n+\n static inline bool\n gomp_barrier_last_thread (gomp_barrier_state_t state)\n {\n-  return state & 1;\n+  return state & BAR_WAS_LAST;\n }\n \n static inline void\n@@ -85,31 +121,37 @@ gomp_barrier_wait_last (gomp_barrier_t *bar)\n static inline void\n gomp_team_barrier_set_task_pending (gomp_barrier_t *bar)\n {\n-  bar->generation |= 1;\n+  bar->generation |= BAR_TASK_PENDING;\n }\n \n static inline void\n gomp_team_barrier_clear_task_pending (gomp_barrier_t *bar)\n {\n-  bar->generation &= ~1;\n+  bar->generation &= ~BAR_TASK_PENDING;\n }\n \n static inline void\n gomp_team_barrier_set_waiting_for_tasks (gomp_barrier_t *bar)\n {\n-  bar->generation |= 2;\n+  bar->generation |= BAR_WAITING_FOR_TASK;\n }\n \n static inline bool\n gomp_team_barrier_waiting_for_tasks (gomp_barrier_t *bar)\n {\n-  return (bar->generation & 2) != 0;\n+  return (bar->generation & BAR_WAITING_FOR_TASK) != 0;\n+}\n+\n+static inline bool\n+gomp_team_barrier_cancelled (gomp_barrier_t *bar)\n+{\n+  return __builtin_expect ((bar->generation & BAR_CANCELLED) != 0, 0);\n }\n \n static inline void\n gomp_team_barrier_done (gomp_barrier_t *bar, gomp_barrier_state_t state)\n {\n-  bar->generation = (state & ~3) + 4;\n+  bar->generation = (state & -BAR_INCR) + BAR_INCR;\n }\n \n #endif /* GOMP_BARRIER_H */"}, {"sha": "57997c5765c28288ea8a53259dd070757d07a8f7", "filename": "libgomp/env.c", "status": "modified", "additions": 729, "deletions": 68, "changes": 797, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Fenv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Fenv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fenv.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -29,6 +29,10 @@\n #include \"libgomp_f.h\"\n #include <ctype.h>\n #include <stdlib.h>\n+#include <stdio.h>\n+#ifdef HAVE_INTTYPES_H\n+# include <inttypes.h>\t/* For PRIu64.  */\n+#endif\n #ifdef STRING_WITH_STRINGS\n # include <string.h>\n # include <strings.h>\n@@ -50,23 +54,28 @@\n \n struct gomp_task_icv gomp_global_icv = {\n   .nthreads_var = 1,\n+  .thread_limit_var = UINT_MAX,\n   .run_sched_var = GFS_DYNAMIC,\n   .run_sched_modifier = 1,\n+  .default_device_var = 0,\n   .dyn_var = false,\n-  .nest_var = false\n+  .nest_var = false,\n+  .bind_var = omp_proc_bind_false,\n+  .target_data = NULL\n };\n \n-unsigned short *gomp_cpu_affinity;\n-size_t gomp_cpu_affinity_len;\n unsigned long gomp_max_active_levels_var = INT_MAX;\n-unsigned long gomp_thread_limit_var = ULONG_MAX;\n-unsigned long gomp_remaining_threads_count;\n+bool gomp_cancel_var = false;\n #ifndef HAVE_SYNC_BUILTINS\n-gomp_mutex_t gomp_remaining_threads_lock;\n+gomp_mutex_t gomp_managed_threads_lock;\n #endif\n unsigned long gomp_available_cpus = 1, gomp_managed_threads = 1;\n unsigned long long gomp_spin_count_var, gomp_throttled_spin_count_var;\n unsigned long *gomp_nthreads_var_list, gomp_nthreads_var_list_len;\n+char *gomp_bind_var_list;\n+unsigned long gomp_bind_var_list_len;\n+void **gomp_places_list;\n+unsigned long gomp_places_list_len;\n \n /* Parse the OMP_SCHEDULE environment variable.  */\n \n@@ -184,6 +193,24 @@ parse_unsigned_long (const char *name, unsigned long *pvalue, bool allow_zero)\n   return false;\n }\n \n+/* Parse a positive int environment variable.  Return true if one was\n+   present and it was successfully parsed.  */\n+\n+static bool\n+parse_int (const char *name, int *pvalue, bool allow_zero)\n+{\n+  unsigned long value;\n+  if (!parse_unsigned_long (name, &value, allow_zero))\n+    return false;\n+  if (value > INT_MAX)\n+    {\n+      gomp_error (\"Invalid value for environment variable %s\", name);\n+      return false;\n+    }\n+  *pvalue = (int) value;\n+  return true;\n+}\n+\n /* Parse an unsigned long list environment variable.  Return true if one was\n    present and it was successfully parsed.  */\n \n@@ -273,6 +300,412 @@ parse_unsigned_long_list (const char *name, unsigned long *p1stvalue,\n   return false;\n }\n \n+/* Parse environment variable set to a boolean or list of omp_proc_bind_t\n+   enum values.  Return true if one was present and it was successfully\n+   parsed.  */\n+\n+static bool\n+parse_bind_var (const char *name, char *p1stvalue,\n+\t\tchar **pvalues, unsigned long *pnvalues)\n+{\n+  char *env;\n+  char value, *values = NULL;\n+  int i;\n+  static struct proc_bind_kinds\n+  {\n+    const char name[7];\n+    const char len;\n+    omp_proc_bind_t kind;\n+  } kinds[] =\n+  {\n+    { \"false\", 5, omp_proc_bind_false },\n+    { \"true\", 4, omp_proc_bind_true },\n+    { \"master\", 6, omp_proc_bind_master },\n+    { \"close\", 5, omp_proc_bind_close },\n+    { \"spread\", 6, omp_proc_bind_spread }\n+  };\n+\n+  env = getenv (name);\n+  if (env == NULL)\n+    return false;\n+\n+  while (isspace ((unsigned char) *env))\n+    ++env;\n+  if (*env == '\\0')\n+    goto invalid;\n+\n+  for (i = 0; i < 5; i++)\n+    if (strncasecmp (env, kinds[i].name, kinds[i].len) == 0)\n+      {\n+\tvalue = kinds[i].kind;\n+\tenv += kinds[i].len;\n+\tbreak;\n+      }\n+  if (i == 5)\n+    goto invalid;\n+\n+  while (isspace ((unsigned char) *env))\n+    ++env;\n+  if (*env != '\\0')\n+    {\n+      if (*env == ',')\n+\t{\n+\t  unsigned long nvalues = 0, nalloced = 0;\n+\n+\t  if (value == omp_proc_bind_false\n+\t      || value == omp_proc_bind_true)\n+\t    goto invalid;\n+\n+\t  do\n+\t    {\n+\t      env++;\n+\t      if (nvalues == nalloced)\n+\t\t{\n+\t\t  char *n;\n+\t\t  nalloced = nalloced ? nalloced * 2 : 16;\n+\t\t  n = realloc (values, nalloced);\n+\t\t  if (n == NULL)\n+\t\t    {\n+\t\t      free (values);\n+\t\t      gomp_error (\"Out of memory while trying to parse\"\n+\t\t\t\t  \" environment variable %s\", name);\n+\t\t      return false;\n+\t\t    }\n+\t\t  values = n;\n+\t\t  if (nvalues == 0)\n+\t\t    values[nvalues++] = value;\n+\t\t}\n+\n+\t      while (isspace ((unsigned char) *env))\n+\t\t++env;\n+\t      if (*env == '\\0')\n+\t\tgoto invalid;\n+\n+\t      for (i = 2; i < 5; i++)\n+\t\tif (strncasecmp (env, kinds[i].name, kinds[i].len) == 0)\n+\t\t  {\n+\t\t    value = kinds[i].kind;\n+\t\t    env += kinds[i].len;\n+\t\t    break;\n+\t\t  }\n+\t      if (i == 5)\n+\t\tgoto invalid;\n+\n+\t      values[nvalues++] = value;\n+\t      while (isspace ((unsigned char) *env))\n+\t\t++env;\n+\t      if (*env == '\\0')\n+\t\tbreak;\n+\t      if (*env != ',')\n+\t\tgoto invalid;\n+\t    }\n+\t  while (1);\n+\t  *p1stvalue = values[0];\n+\t  *pvalues = values;\n+\t  *pnvalues = nvalues;\n+\t  return true;\n+\t}\n+      goto invalid;\n+    }\n+\n+  *p1stvalue = value;\n+  return true;\n+\n+ invalid:\n+  free (values);\n+  gomp_error (\"Invalid value for environment variable %s\", name);\n+  return false;\n+}\n+\n+static bool\n+parse_one_place (char **envp, bool *negatep, unsigned long *lenp,\n+\t\t long *stridep)\n+{\n+  char *env = *envp, *start;\n+  void *p = gomp_places_list ? gomp_places_list[gomp_places_list_len] : NULL;\n+  unsigned long len = 1;\n+  long stride = 1;\n+  int pass;\n+  bool any_negate = false;\n+  *negatep = false;\n+  while (isspace ((unsigned char) *env))\n+    ++env;\n+  if (*env == '!')\n+    {\n+      *negatep = true;\n+      ++env;\n+      while (isspace ((unsigned char) *env))\n+\t++env;\n+    }\n+  if (*env != '{')\n+    return false;\n+  ++env;\n+  while (isspace ((unsigned char) *env))\n+    ++env;\n+  start = env;\n+  for (pass = 0; pass < (any_negate ? 2 : 1); pass++)\n+    {\n+      env = start;\n+      do\n+\t{\n+\t  unsigned long this_num, this_len = 1;\n+\t  long this_stride = 1;\n+\t  bool this_negate = (*env == '!');\n+\t  if (this_negate)\n+\t    {\n+\t      if (gomp_places_list)\n+\t\tany_negate = true;\n+\t      ++env;\n+\t      while (isspace ((unsigned char) *env))\n+\t\t++env;\n+\t    }\n+\n+\t  errno = 0;\n+\t  this_num = strtoul (env, &env, 10);\n+\t  if (errno)\n+\t    return false;\n+\t  while (isspace ((unsigned char) *env))\n+\t    ++env;\n+\t  if (*env == ':')\n+\t    {\n+\t      ++env;\n+\t      while (isspace ((unsigned char) *env))\n+\t\t++env;\n+\t      errno = 0;\n+\t      this_len = strtoul (env, &env, 10);\n+\t      if (errno || this_len == 0)\n+\t\treturn false;\n+\t      while (isspace ((unsigned char) *env))\n+\t\t++env;\n+\t      if (*env == ':')\n+\t\t{\n+\t\t  ++env;\n+\t\t  while (isspace ((unsigned char) *env))\n+\t\t    ++env;\n+\t\t  errno = 0;\n+\t\t  this_stride = strtol (env, &env, 10);\n+\t\t  if (errno)\n+\t\t    return false;\n+\t\t  while (isspace ((unsigned char) *env))\n+\t\t    ++env;\n+\t\t}\n+\t    }\n+\t  if (this_negate && this_len != 1)\n+\t    return false;\n+\t  if (gomp_places_list && pass == this_negate)\n+\t    {\n+\t      if (this_negate)\n+\t\t{\n+\t\t  if (!gomp_affinity_remove_cpu (p, this_num))\n+\t\t    return false;\n+\t\t}\n+\t      else if (!gomp_affinity_add_cpus (p, this_num, this_len,\n+\t\t\t\t\t\tthis_stride, false))\n+\t\treturn false;\n+\t    }\n+\t  if (*env == '}')\n+\t    break;\n+\t  if (*env != ',')\n+\t    return false;\n+\t  ++env;\n+\t}\n+      while (1);\n+    }\n+\n+  ++env;\n+  while (isspace ((unsigned char) *env))\n+    ++env;\n+  if (*env == ':')\n+    {\n+      ++env;\n+      while (isspace ((unsigned char) *env))\n+\t++env;\n+      errno = 0;\n+      len = strtoul (env, &env, 10);\n+      if (errno || len == 0 || len >= 65536)\n+\treturn false;\n+      while (isspace ((unsigned char) *env))\n+\t++env;\n+      if (*env == ':')\n+\t{\n+\t  ++env;\n+\t  while (isspace ((unsigned char) *env))\n+\t    ++env;\n+\t  errno = 0;\n+\t  stride = strtol (env, &env, 10);\n+\t  if (errno)\n+\t    return false;\n+\t  while (isspace ((unsigned char) *env))\n+\t    ++env;\n+\t}\n+    }\n+  if (*negatep && len != 1)\n+    return false;\n+  *envp = env;\n+  *lenp = len;\n+  *stridep = stride;\n+  return true;\n+}\n+\n+static bool\n+parse_places_var (const char *name)\n+{\n+  char *env = getenv (name), *end;\n+  bool any_negate = false;\n+  int level = 0;\n+  unsigned long count = 0;\n+  if (env == NULL)\n+    return false;\n+\n+  while (isspace ((unsigned char) *env))\n+    ++env;\n+  if (*env == '\\0')\n+    goto invalid;\n+\n+  if (strncasecmp (env, \"threads\", 7) == 0)\n+    {\n+      env += 7;\n+      level = 1;\n+    }\n+  else if (strncasecmp (env, \"cores\", 5) == 0)\n+    {\n+      env += 5;\n+      level = 2;\n+    }\n+  else if (strncasecmp (env, \"sockets\", 7) == 0)\n+    {\n+      env += 7;\n+      level = 3;\n+    }\n+  if (level)\n+    {\n+      count = ULONG_MAX;\n+      while (isspace ((unsigned char) *env))\n+\t++env;\n+      if (*env != '\\0')\n+\t{\n+\t  if (*env++ != '(')\n+\t    goto invalid;\n+\t  while (isspace ((unsigned char) *env))\n+\t    ++env;\n+\n+\t  errno = 0;\n+\t  count = strtoul (env, &end, 10);\n+\t  if (errno)\n+\t    goto invalid;\n+\t  env = end;\n+\t  while (isspace ((unsigned char) *env))\n+\t    ++env;\n+\t  if (*env != ')')\n+\t    goto invalid;\n+\t  ++env;\n+\t  while (isspace ((unsigned char) *env))\n+\t    ++env;\n+\t  if (*env != '\\0')\n+\t    goto invalid;\n+\t}\n+      return gomp_affinity_init_level (level, count, false);\n+    }\n+\n+  count = 0;\n+  end = env;\n+  do\n+    {\n+      bool negate;\n+      unsigned long len;\n+      long stride;\n+      if (!parse_one_place (&end, &negate, &len, &stride))\n+\tgoto invalid;\n+      if (negate)\n+\t{\n+\t  if (!any_negate)\n+\t    count++;\n+\t  any_negate = true;\n+\t}\n+      else\n+\tcount += len;\n+      if (count > 65536)\n+\tgoto invalid;\n+      if (*end == '\\0')\n+\tbreak;\n+      if (*end != ',')\n+\tgoto invalid;\n+      end++;\n+    }\n+  while (1);\n+\n+  if (gomp_global_icv.bind_var == omp_proc_bind_false)\n+    return false;\n+\n+  gomp_places_list_len = 0;\n+  gomp_places_list = gomp_affinity_alloc (count, false);\n+  if (gomp_places_list == NULL)\n+    return false;\n+\n+  do\n+    {\n+      bool negate;\n+      unsigned long len;\n+      long stride;\n+      gomp_affinity_init_place (gomp_places_list[gomp_places_list_len]);\n+      if (!parse_one_place (&env, &negate, &len, &stride))\n+\tgoto invalid;\n+      if (negate)\n+\t{\n+\t  void *p;\n+\t  for (count = 0; count < gomp_places_list_len; count++)\n+\t    if (gomp_affinity_same_place\n+\t\t\t(gomp_places_list[count],\n+\t\t\t gomp_places_list[gomp_places_list_len]))\n+\t      break;\n+\t  if (count == gomp_places_list_len)\n+\t    {\n+\t      gomp_error (\"Trying to remove a non-existing place from list \"\n+\t\t\t  \"of places\");\n+\t      goto invalid;\n+\t    }\n+\t  p = gomp_places_list[count];\n+\t  memmove (&gomp_places_list[count],\n+\t\t   &gomp_places_list[count + 1],\n+\t\t   (gomp_places_list_len - count - 1) * sizeof (void *));\n+\t  --gomp_places_list_len;\n+\t  gomp_places_list[gomp_places_list_len] = p;\n+\t}\n+      else if (len == 1)\n+\t++gomp_places_list_len;\n+      else\n+\t{\n+\t  for (count = 0; count < len - 1; count++)\n+\t    if (!gomp_affinity_copy_place\n+\t\t\t(gomp_places_list[gomp_places_list_len + count + 1],\n+\t\t\t gomp_places_list[gomp_places_list_len + count],\n+\t\t\t stride))\n+\t      goto invalid;\n+\t  gomp_places_list_len += len;\n+\t}\n+      if (*env == '\\0')\n+\tbreak;\n+      env++;\n+    }\n+  while (1);\n+\n+  if (gomp_places_list_len == 0)\n+    {\n+      gomp_error (\"All places have been removed\");\n+      goto invalid;\n+    }\n+  if (!gomp_affinity_finalize_place_list (false))\n+    goto invalid;\n+  return true;\n+\n+ invalid:\n+  free (gomp_places_list);\n+  gomp_places_list = NULL;\n+  gomp_places_list_len = 0;\n+  gomp_error (\"Invalid value for environment variable %s\", name);\n+  return false;\n+}\n+\n /* Parse the OMP_STACKSIZE environment varible.  Return true if one was\n    present and it was successfully parsed.  */\n \n@@ -480,112 +913,268 @@ parse_wait_policy (void)\n static bool\n parse_affinity (void)\n {\n-  char *env, *end;\n+  char *env, *end, *start;\n+  int pass;\n   unsigned long cpu_beg, cpu_end, cpu_stride;\n-  unsigned short *cpus = NULL;\n-  size_t allocated = 0, used = 0, needed;\n+  size_t count = 0, needed;\n \n   env = getenv (\"GOMP_CPU_AFFINITY\");\n   if (env == NULL)\n     return false;\n \n-  do\n+  start = env;\n+  for (pass = 0; pass < 2; pass++)\n     {\n-      while (*env == ' ' || *env == '\\t')\n-\tenv++;\n-\n-      cpu_beg = strtoul (env, &end, 0);\n-      cpu_end = cpu_beg;\n-      cpu_stride = 1;\n-      if (env == end || cpu_beg >= 65536)\n-\tgoto invalid;\n-\n-      env = end;\n-      if (*env == '-')\n+      env = start;\n+      if (pass == 1)\n \t{\n-\t  cpu_end = strtoul (++env, &end, 0);\n-\t  if (env == end || cpu_end >= 65536 || cpu_end < cpu_beg)\n+\t  gomp_places_list_len = 0;\n+\t  gomp_places_list = gomp_affinity_alloc (count, true);\n+\t  if (gomp_places_list == NULL)\n+\t    return false;\n+\t}\n+      do\n+\t{\n+\t  while (isspace ((unsigned char) *env))\n+\t    ++env;\n+\n+\t  errno = 0;\n+\t  cpu_beg = strtoul (env, &end, 0);\n+\t  if (errno || cpu_beg >= 65536)\n \t    goto invalid;\n+\t  cpu_end = cpu_beg;\n+\t  cpu_stride = 1;\n \n \t  env = end;\n-\t  if (*env == ':')\n+\t  if (*env == '-')\n \t    {\n-\t      cpu_stride = strtoul (++env, &end, 0);\n-\t      if (env == end || cpu_stride == 0 || cpu_stride >= 65536)\n+\t      errno = 0;\n+\t      cpu_end = strtoul (++env, &end, 0);\n+\t      if (errno || cpu_end >= 65536 || cpu_end < cpu_beg)\n \t\tgoto invalid;\n \n \t      env = end;\n-\t    }\n-\t}\n+\t      if (*env == ':')\n+\t\t{\n+\t\t  errno = 0;\n+\t\t  cpu_stride = strtoul (++env, &end, 0);\n+\t\t  if (errno || cpu_stride == 0 || cpu_stride >= 65536)\n+\t\t    goto invalid;\n \n-      needed = (cpu_end - cpu_beg) / cpu_stride + 1;\n-      if (used + needed >= allocated)\n-\t{\n-\t  unsigned short *new_cpus;\n+\t\t  env = end;\n+\t\t}\n+\t    }\n \n-\t  if (allocated < 64)\n-\t    allocated = 64;\n-\t  if (allocated > needed)\n-\t    allocated <<= 1;\n+\t  needed = (cpu_end - cpu_beg) / cpu_stride + 1;\n+\t  if (pass == 0)\n+\t    count += needed;\n \t  else\n-\t    allocated += 2 * needed;\n-\t  new_cpus = realloc (cpus, allocated * sizeof (unsigned short));\n-\t  if (new_cpus == NULL)\n \t    {\n-\t      free (cpus);\n-\t      gomp_error (\"not enough memory to store GOMP_CPU_AFFINITY list\");\n-\t      return false;\n+\t      while (needed--)\n+\t\t{\n+\t\t  void *p = gomp_places_list[gomp_places_list_len];\n+\t\t  gomp_affinity_init_place (p);\n+\t\t  if (gomp_affinity_add_cpus (p, cpu_beg, 1, 0, true))\n+\t\t    ++gomp_places_list_len;\n+\t\t  cpu_beg += cpu_stride;\n+\t\t}\n \t    }\n \n-\t  cpus = new_cpus;\n-\t}\n+\t  while (isspace ((unsigned char) *env))\n+\t    ++env;\n \n-      while (needed--)\n-\t{\n-\t  cpus[used++] = cpu_beg;\n-\t  cpu_beg += cpu_stride;\n+\t  if (*env == ',')\n+\t    env++;\n+\t  else if (*env == '\\0')\n+\t    break;\n \t}\n-\n-      while (*env == ' ' || *env == '\\t')\n-\tenv++;\n-\n-      if (*env == ',')\n-\tenv++;\n-      else if (*env == '\\0')\n-\tbreak;\n+      while (1);\n     }\n-  while (1);\n \n-  gomp_cpu_affinity = cpus;\n-  gomp_cpu_affinity_len = used;\n+  if (gomp_places_list_len == 0)\n+    {\n+      free (gomp_places_list);\n+      gomp_places_list = NULL;\n+    }\n   return true;\n \n  invalid:\n   gomp_error (\"Invalid value for enviroment variable GOMP_CPU_AFFINITY\");\n   return false;\n }\n \n+\n+static void\n+handle_omp_display_env (unsigned long stacksize, int wait_policy)\n+{\n+  const char *env;\n+  bool display = false;\n+  bool verbose = false;\n+  int i;\n+\n+  env = getenv (\"OMP_DISPLAY_ENV\");\n+  if (env == NULL)\n+    return;\n+\n+  while (isspace ((unsigned char) *env))\n+    ++env;\n+  if (strncasecmp (env, \"true\", 4) == 0)\n+    {\n+      display = true;\n+      env += 4;\n+    }\n+  else if (strncasecmp (env, \"false\", 5) == 0)\n+    {\n+      display = false;\n+      env += 5;\n+    }\n+  else if (strncasecmp (env, \"verbose\", 7) == 0)\n+    {\n+      display = true;\n+      verbose = true;\n+      env += 7;\n+    }\n+  else\n+    env = \"X\";\n+  while (isspace ((unsigned char) *env))\n+    ++env;\n+  if (*env != '\\0')\n+    gomp_error (\"Invalid value for environment variable OMP_DISPLAY_ENV\");\n+\n+  if (!display)\n+    return;\n+\n+  fputs (\"\\nOPENMP DISPLAY ENVIRONMENT BEGIN\\n\", stderr);\n+\n+  fputs (\"  _OPENMP = '201307'\\n\", stderr);\n+  fprintf (stderr, \"  OMP_DYNAMIC = '%s'\\n\",\n+\t   gomp_global_icv.dyn_var ? \"TRUE\" : \"FALSE\");\n+  fprintf (stderr, \"  OMP_NESTED = '%s'\\n\",\n+\t   gomp_global_icv.nest_var ? \"TRUE\" : \"FALSE\");\n+\n+  fprintf (stderr, \"  OMP_NUM_THREADS = '%lu\", gomp_global_icv.nthreads_var);\n+  for (i = 1; i < gomp_nthreads_var_list_len; i++)\n+    fprintf (stderr, \",%lu\", gomp_nthreads_var_list[i]);\n+  fputs (\"'\\n\", stderr);\n+\n+  fprintf (stderr, \"  OMP_SCHEDULE = '\");\n+  switch (gomp_global_icv.run_sched_var)\n+    {\n+    case GFS_RUNTIME:\n+      fputs (\"RUNTIME\", stderr);\n+      break;\n+    case GFS_STATIC:\n+      fputs (\"STATIC\", stderr);\n+      break;\n+    case GFS_DYNAMIC:\n+      fputs (\"DYNAMIC\", stderr);\n+      break;\n+    case GFS_GUIDED:\n+      fputs (\"GUIDED\", stderr);\n+      break;\n+    case GFS_AUTO:\n+      fputs (\"AUTO\", stderr);\n+      break;\n+    }\n+  fputs (\"'\\n\", stderr);\n+\n+  fputs (\"  OMP_PROC_BIND = '\", stderr);\n+  switch (gomp_global_icv.bind_var)\n+    {\n+    case omp_proc_bind_false:\n+      fputs (\"FALSE\", stderr);\n+      break;\n+    case omp_proc_bind_true:\n+      fputs (\"TRUE\", stderr);\n+      break;\n+    case omp_proc_bind_master:\n+      fputs (\"MASTER\", stderr);\n+      break;\n+    case omp_proc_bind_close:\n+      fputs (\"CLOSE\", stderr);\n+      break;\n+    case omp_proc_bind_spread:\n+      fputs (\"SPREAD\", stderr);\n+      break;\n+    }\n+  for (i = 1; i < gomp_bind_var_list_len; i++)\n+    switch (gomp_bind_var_list[i])\n+      {\n+      case omp_proc_bind_master:\n+\tfputs (\",MASTER\", stderr);\n+\tbreak;\n+      case omp_proc_bind_close:\n+\tfputs (\",CLOSE\", stderr);\n+\tbreak;\n+      case omp_proc_bind_spread:\n+\tfputs (\",SPREAD\", stderr);\n+\tbreak;\n+      }\n+  fputs (\"'\\n\", stderr);\n+  fputs (\"  OMP_PLACES = '\", stderr);\n+  for (i = 0; i < gomp_places_list_len; i++)\n+    {\n+      fputs (\"{\", stderr);\n+      gomp_affinity_print_place (gomp_places_list[i]);\n+      fputs (i + 1 == gomp_places_list_len ? \"}\" : \"},\", stderr);\n+    }\n+  fputs (\"'\\n\", stderr);\n+\n+  fprintf (stderr, \"  OMP_STACKSIZE = '%lu'\\n\", stacksize);\n+\n+  /* GOMP's default value is actually neither active nor passive.  */\n+  fprintf (stderr, \"  OMP_WAIT_POLICY = '%s'\\n\",\n+\t   wait_policy > 0 ? \"ACTIVE\" : \"PASSIVE\");\n+  fprintf (stderr, \"  OMP_THREAD_LIMIT = '%u'\\n\",\n+\t   gomp_global_icv.thread_limit_var);\n+  fprintf (stderr, \"  OMP_MAX_ACTIVE_LEVELS = '%lu'\\n\",\n+\t   gomp_max_active_levels_var);\n+\n+  fprintf (stderr, \"  OMP_CANCELLATION = '%s'\\n\",\n+\t   gomp_cancel_var ? \"TRUE\" : \"FALSE\");\n+  fprintf (stderr, \"  OMP_DEFAULT_DEVICE = '%d'\\n\",\n+\t   gomp_global_icv.default_device_var);\n+\n+  if (verbose)\n+    {\n+      fputs (\"  GOMP_CPU_AFFINITY = ''\\n\", stderr);\n+      fprintf (stderr, \"  GOMP_STACKSIZE = '%lu'\\n\", stacksize);\n+#ifdef HAVE_INTTYPES_H\n+      fprintf (stderr, \"  GOMP_SPINCOUNT = '%\"PRIu64\"'\\n\",\n+\t       (uint64_t) gomp_spin_count_var);\n+#else\n+      fprintf (stderr, \"  GOMP_SPINCOUNT = '%lu'\\n\",\n+\t       (unsigned long) gomp_spin_count_var);\n+#endif\n+    }\n+\n+  fputs (\"OPENMP DISPLAY ENVIRONMENT END\\n\", stderr);\n+}\n+\n+\n static void __attribute__((constructor))\n initialize_env (void)\n {\n-  unsigned long stacksize;\n+  unsigned long thread_limit_var, stacksize;\n   int wait_policy;\n-  bool bind_var = false;\n \n   /* Do a compile time check that mkomp_h.pl did good job.  */\n   omp_check_defines ();\n \n   parse_schedule ();\n   parse_boolean (\"OMP_DYNAMIC\", &gomp_global_icv.dyn_var);\n   parse_boolean (\"OMP_NESTED\", &gomp_global_icv.nest_var);\n-  parse_boolean (\"OMP_PROC_BIND\", &bind_var);\n+  parse_boolean (\"OMP_CANCELLATION\", &gomp_cancel_var);\n+  parse_int (\"OMP_DEFAULT_DEVICE\", &gomp_global_icv.default_device_var, true);\n   parse_unsigned_long (\"OMP_MAX_ACTIVE_LEVELS\", &gomp_max_active_levels_var,\n \t\t       true);\n-  parse_unsigned_long (\"OMP_THREAD_LIMIT\", &gomp_thread_limit_var, false);\n-  if (gomp_thread_limit_var != ULONG_MAX)\n-    gomp_remaining_threads_count = gomp_thread_limit_var - 1;\n+  if (parse_unsigned_long (\"OMP_THREAD_LIMIT\", &thread_limit_var, false))\n+    {\n+      gomp_global_icv.thread_limit_var\n+\t= thread_limit_var > INT_MAX ? UINT_MAX : thread_limit_var;\n+    }\n #ifndef HAVE_SYNC_BUILTINS\n-  gomp_mutex_init (&gomp_remaining_threads_lock);\n+  gomp_mutex_init (&gomp_managed_threads_lock);\n #endif\n   gomp_init_num_threads ();\n   gomp_available_cpus = gomp_global_icv.nthreads_var;\n@@ -594,7 +1183,14 @@ initialize_env (void)\n \t\t\t\t &gomp_nthreads_var_list,\n \t\t\t\t &gomp_nthreads_var_list_len))\n     gomp_global_icv.nthreads_var = gomp_available_cpus;\n-  if (parse_affinity () || bind_var)\n+  if (!parse_bind_var (\"OMP_PROC_BIND\",\n+\t\t       &gomp_global_icv.bind_var,\n+\t\t       &gomp_bind_var_list,\n+\t\t       &gomp_bind_var_list_len))\n+    gomp_global_icv.bind_var = omp_proc_bind_false;\n+  if (parse_places_var (\"OMP_PLACES\")\n+      || parse_affinity ()\n+      || gomp_global_icv.bind_var)\n     gomp_init_affinity ();\n   wait_policy = parse_wait_policy ();\n   if (!parse_spincount (\"GOMP_SPINCOUNT\", &gomp_spin_count_var))\n@@ -645,6 +1241,8 @@ initialize_env (void)\n       if (err != 0)\n \tgomp_error (\"Stack size change failed: %s\", strerror (err));\n     }\n+\n+  handle_omp_display_env (stacksize, wait_policy);\n }\n \n \f\n@@ -728,7 +1326,8 @@ omp_get_max_threads (void)\n int\n omp_get_thread_limit (void)\n {\n-  return gomp_thread_limit_var > INT_MAX ? INT_MAX : gomp_thread_limit_var;\n+  struct gomp_task_icv *icv = gomp_icv (false);\n+  return icv->thread_limit_var > INT_MAX ? INT_MAX : icv->thread_limit_var;\n }\n \n void\n@@ -744,6 +1343,60 @@ omp_get_max_active_levels (void)\n   return gomp_max_active_levels_var;\n }\n \n+int\n+omp_get_cancellation (void)\n+{\n+  return gomp_cancel_var;\n+}\n+\n+omp_proc_bind_t\n+omp_get_proc_bind (void)\n+{\n+  struct gomp_task_icv *icv = gomp_icv (false);\n+  return icv->bind_var;\n+}\n+\n+void\n+omp_set_default_device (int device_num)\n+{\n+  struct gomp_task_icv *icv = gomp_icv (true);\n+  icv->default_device_var = device_num >= 0 ? device_num : 0;\n+}\n+\n+int\n+omp_get_default_device (void)\n+{\n+  struct gomp_task_icv *icv = gomp_icv (false);\n+  return icv->default_device_var;\n+}\n+\n+int\n+omp_get_num_devices (void)\n+{\n+  return gomp_get_num_devices ();\n+}\n+\n+int\n+omp_get_num_teams (void)\n+{\n+  /* Hardcoded to 1 on host, MIC, HSAIL?  Maybe variable on PTX.  */\n+  return 1;\n+}\n+\n+int\n+omp_get_team_num (void)\n+{\n+  /* Hardcoded to 0 on host, MIC, HSAIL?  Maybe variable on PTX.  */\n+  return 0;\n+}\n+\n+int\n+omp_is_initial_device (void)\n+{\n+  /* Hardcoded to 1 on host, should be 0 on MIC, HSAIL, PTX.  */\n+  return 1;\n+}\n+\n ialias (omp_set_dynamic)\n ialias (omp_set_nested)\n ialias (omp_set_num_threads)\n@@ -755,3 +1408,11 @@ ialias (omp_get_max_threads)\n ialias (omp_get_thread_limit)\n ialias (omp_set_max_active_levels)\n ialias (omp_get_max_active_levels)\n+ialias (omp_get_cancellation)\n+ialias (omp_get_proc_bind)\n+ialias (omp_set_default_device)\n+ialias (omp_get_default_device)\n+ialias (omp_get_num_devices)\n+ialias (omp_get_num_teams)\n+ialias (omp_get_team_num)\n+ialias (omp_is_initial_device)"}, {"sha": "38b968a8d396524567ed83bfbefd100a947d7d5e", "filename": "libgomp/fortran.c", "status": "modified", "additions": 62, "deletions": 5, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ffortran.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ffortran.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ffortran.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -31,11 +31,6 @@\n \n #ifdef HAVE_ATTRIBUTE_ALIAS\n /* Use internal aliases if possible.  */\n-# define ULP\t\tSTR1(__USER_LABEL_PREFIX__)\n-# define STR1(x)\tSTR2(x)\n-# define STR2(x)\t#x\n-# define ialias_redirect(fn) \\\n-  extern __typeof (fn) fn __asm__ (ULP \"gomp_ialias_\" #fn) attribute_hidden;\n # ifndef LIBGOMP_GNU_SYMBOL_VERSIONING\n ialias_redirect (omp_init_lock)\n ialias_redirect (omp_init_nest_lock)\n@@ -70,6 +65,14 @@ ialias_redirect (omp_get_ancestor_thread_num)\n ialias_redirect (omp_get_team_size)\n ialias_redirect (omp_get_active_level)\n ialias_redirect (omp_in_final)\n+ialias_redirect (omp_get_cancellation)\n+ialias_redirect (omp_get_proc_bind)\n+ialias_redirect (omp_set_default_device)\n+ialias_redirect (omp_get_default_device)\n+ialias_redirect (omp_get_num_devices)\n+ialias_redirect (omp_get_num_teams)\n+ialias_redirect (omp_get_team_num)\n+ialias_redirect (omp_is_initial_device)\n #endif\n \n #ifndef LIBGOMP_GNU_SYMBOL_VERSIONING\n@@ -435,3 +438,57 @@ omp_in_final_ (void)\n {\n   return omp_in_final ();\n }\n+\n+int32_t\n+omp_get_cancellation_ (void)\n+{\n+  return omp_get_cancellation ();\n+}\n+\n+int32_t\n+omp_get_proc_bind_ (void)\n+{\n+  return omp_get_proc_bind ();\n+}\n+\n+void\n+omp_set_default_device_ (const int32_t *device_num)\n+{\n+  return omp_set_default_device (*device_num);\n+}\n+\n+void\n+omp_set_default_device_8_ (const int64_t *device_num)\n+{\n+  return omp_set_default_device (TO_INT (*device_num));\n+}\n+\n+int32_t\n+omp_get_default_device_ (void)\n+{\n+  return omp_get_default_device ();\n+}\n+\n+int32_t\n+omp_get_num_devices_ (void)\n+{\n+  return omp_get_num_devices ();\n+}\n+\n+int32_t\n+omp_get_num_teams_ (void)\n+{\n+  return omp_get_num_teams ();\n+}\n+\n+int32_t\n+omp_get_team_num_ (void)\n+{\n+  return omp_get_team_num ();\n+}\n+\n+int32_t\n+omp_is_initial_device_ (void)\n+{\n+  return omp_is_initial_device ();\n+}"}, {"sha": "7f1dad695240bcef6c87df912ece708470e30b5c", "filename": "libgomp/hashtab.h", "status": "added", "additions": 443, "deletions": 0, "changes": 443, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Fhashtab.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Fhashtab.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fhashtab.h?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -0,0 +1,443 @@\n+/* An expandable hash tables datatype.\n+   Copyright (C) 1999-2013\n+   Free Software Foundation, Inc.\n+   Contributed by Vladimir Makarov <vmakarov@cygnus.com>.\n+\n+This program is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2 of the License, or\n+(at your option) any later version.\n+\n+This program is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with this program; if not, write to the Free Software\n+Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */\n+\n+/* The hash table code copied from include/hashtab.[hc] and adjusted,\n+   so that the hash table entries are in the flexible array at the end\n+   of the control structure, no callbacks are used and the elements in the\n+   table are of the hash_entry_type type.\n+   Before including this file, define hash_entry_type type and\n+   htab_alloc and htab_free functions.  After including it, define\n+   htab_hash and htab_eq inline functions.   */\n+\n+/* This package implements basic hash table functionality.  It is possible\n+   to search for an entry, create an entry and destroy an entry.\n+\n+   Elements in the table are generic pointers.\n+\n+   The size of the table is not fixed; if the occupancy of the table\n+   grows too high the hash table will be expanded.\n+\n+   The abstract data implementation is based on generalized Algorithm D\n+   from Knuth's book \"The art of computer programming\".  Hash table is\n+   expanded by creation of new hash table and transferring elements from\n+   the old table to the new table.  */\n+\n+/* The type for a hash code.  */\n+typedef unsigned int hashval_t;\n+\n+static inline hashval_t htab_hash (hash_entry_type);\n+static inline bool htab_eq (hash_entry_type, hash_entry_type);\n+\n+/* This macro defines reserved value for empty table entry.  */\n+\n+#define HTAB_EMPTY_ENTRY    ((hash_entry_type) 0)\n+\n+/* This macro defines reserved value for table entry which contained\n+   a deleted element. */\n+\n+#define HTAB_DELETED_ENTRY  ((hash_entry_type) 1)\n+\n+/* Hash tables are of the following type.  The structure\n+   (implementation) of this type is not needed for using the hash\n+   tables.  All work with hash table should be executed only through\n+   functions mentioned below.  The size of this structure is subject to\n+   change.  */\n+\n+struct htab {\n+  /* Current size (in entries) of the hash table.  */\n+  size_t size;\n+\n+  /* Current number of elements including also deleted elements.  */\n+  size_t n_elements;\n+\n+  /* Current number of deleted elements in the table.  */\n+  size_t n_deleted;\n+\n+  /* Current size (in entries) of the hash table, as an index into the\n+     table of primes.  */\n+  unsigned int size_prime_index;\n+\n+  /* Table itself.  */\n+  hash_entry_type entries[];\n+};\n+\n+typedef struct htab *htab_t;\n+\n+/* An enum saying whether we insert into the hash table or not.  */\n+enum insert_option {NO_INSERT, INSERT};\n+\n+/* Table of primes and multiplicative inverses.\n+\n+   Note that these are not minimally reduced inverses.  Unlike when generating\n+   code to divide by a constant, we want to be able to use the same algorithm\n+   all the time.  All of these inverses (are implied to) have bit 32 set.\n+\n+   For the record, the function that computed the table is in\n+   libiberty/hashtab.c.  */\n+\n+struct prime_ent\n+{\n+  hashval_t prime;\n+  hashval_t inv;\n+  hashval_t inv_m2;\t/* inverse of prime-2 */\n+  hashval_t shift;\n+};\n+\n+static struct prime_ent const prime_tab[] = {\n+  {          7, 0x24924925, 0x9999999b, 2 },\n+  {         13, 0x3b13b13c, 0x745d1747, 3 },\n+  {         31, 0x08421085, 0x1a7b9612, 4 },\n+  {         61, 0x0c9714fc, 0x15b1e5f8, 5 },\n+  {        127, 0x02040811, 0x0624dd30, 6 },\n+  {        251, 0x05197f7e, 0x073260a5, 7 },\n+  {        509, 0x01824366, 0x02864fc8, 8 },\n+  {       1021, 0x00c0906d, 0x014191f7, 9 },\n+  {       2039, 0x0121456f, 0x0161e69e, 10 },\n+  {       4093, 0x00300902, 0x00501908, 11 },\n+  {       8191, 0x00080041, 0x00180241, 12 },\n+  {      16381, 0x000c0091, 0x00140191, 13 },\n+  {      32749, 0x002605a5, 0x002a06e6, 14 },\n+  {      65521, 0x000f00e2, 0x00110122, 15 },\n+  {     131071, 0x00008001, 0x00018003, 16 },\n+  {     262139, 0x00014002, 0x0001c004, 17 },\n+  {     524287, 0x00002001, 0x00006001, 18 },\n+  {    1048573, 0x00003001, 0x00005001, 19 },\n+  {    2097143, 0x00004801, 0x00005801, 20 },\n+  {    4194301, 0x00000c01, 0x00001401, 21 },\n+  {    8388593, 0x00001e01, 0x00002201, 22 },\n+  {   16777213, 0x00000301, 0x00000501, 23 },\n+  {   33554393, 0x00001381, 0x00001481, 24 },\n+  {   67108859, 0x00000141, 0x000001c1, 25 },\n+  {  134217689, 0x000004e1, 0x00000521, 26 },\n+  {  268435399, 0x00000391, 0x000003b1, 27 },\n+  {  536870909, 0x00000019, 0x00000029, 28 },\n+  { 1073741789, 0x0000008d, 0x00000095, 29 },\n+  { 2147483647, 0x00000003, 0x00000007, 30 },\n+  /* Avoid \"decimal constant so large it is unsigned\" for 4294967291.  */\n+  { 0xfffffffb, 0x00000006, 0x00000008, 31 }\n+};\n+\n+/* The following function returns an index into the above table of the\n+   nearest prime number which is greater than N, and near a power of two. */\n+\n+static unsigned int\n+higher_prime_index (unsigned long n)\n+{\n+  unsigned int low = 0;\n+  unsigned int high = sizeof(prime_tab) / sizeof(prime_tab[0]);\n+\n+  while (low != high)\n+    {\n+      unsigned int mid = low + (high - low) / 2;\n+      if (n > prime_tab[mid].prime)\n+\tlow = mid + 1;\n+      else\n+\thigh = mid;\n+    }\n+\n+  /* If we've run out of primes, abort.  */\n+  if (n > prime_tab[low].prime)\n+    abort ();\n+\n+  return low;\n+}\n+\n+/* Return the current size of given hash table.  */\n+\n+static inline size_t\n+htab_size (htab_t htab)\n+{\n+  return htab->size;\n+}\n+\n+/* Return the current number of elements in given hash table. */\n+\n+static inline size_t\n+htab_elements (htab_t htab)\n+{\n+  return htab->n_elements - htab->n_deleted;\n+}\n+\n+/* Return X % Y.  */\n+\n+static inline hashval_t\n+htab_mod_1 (hashval_t x, hashval_t y, hashval_t inv, int shift)\n+{\n+  /* The multiplicative inverses computed above are for 32-bit types, and\n+     requires that we be able to compute a highpart multiply.  */\n+  if (sizeof (hashval_t) * __CHAR_BIT__ <= 32)\n+    {\n+      hashval_t t1, t2, t3, t4, q, r;\n+\n+      t1 = ((unsigned long long)x * inv) >> 32;\n+      t2 = x - t1;\n+      t3 = t2 >> 1;\n+      t4 = t1 + t3;\n+      q  = t4 >> shift;\n+      r  = x - (q * y);\n+\n+      return r;\n+    }\n+\n+  /* Otherwise just use the native division routines.  */\n+  return x % y;\n+}\n+\n+/* Compute the primary hash for HASH given HTAB's current size.  */\n+\n+static inline hashval_t\n+htab_mod (hashval_t hash, htab_t htab)\n+{\n+  const struct prime_ent *p = &prime_tab[htab->size_prime_index];\n+  return htab_mod_1 (hash, p->prime, p->inv, p->shift);\n+}\n+\n+/* Compute the secondary hash for HASH given HTAB's current size.  */\n+\n+static inline hashval_t\n+htab_mod_m2 (hashval_t hash, htab_t htab)\n+{\n+  const struct prime_ent *p = &prime_tab[htab->size_prime_index];\n+  return 1 + htab_mod_1 (hash, p->prime - 2, p->inv_m2, p->shift);\n+}\n+\n+/* Create hash table of size SIZE.  */\n+\n+static htab_t\n+htab_create (size_t size)\n+{\n+  htab_t result;\n+  unsigned int size_prime_index;\n+\n+  size_prime_index = higher_prime_index (size);\n+  size = prime_tab[size_prime_index].prime;\n+\n+  result = (htab_t) htab_alloc (sizeof (struct htab)\n+\t\t\t\t+ size * sizeof (hash_entry_type));\n+  result->size = size;\n+  result->n_elements = 0;\n+  result->n_deleted = 0;\n+  result->size_prime_index = size_prime_index;\n+  memset (result->entries, 0, size * sizeof (hash_entry_type));\n+  return result;\n+}\n+\n+/* Similar to htab_find_slot, but without several unwanted side effects:\n+    - Does not call htab_eq when it finds an existing entry.\n+    - Does not change the count of elements in the hash table.\n+   This function also assumes there are no deleted entries in the table.\n+   HASH is the hash value for the element to be inserted.  */\n+\n+static hash_entry_type *\n+find_empty_slot_for_expand (htab_t htab, hashval_t hash)\n+{\n+  hashval_t index = htab_mod (hash, htab);\n+  size_t size = htab_size (htab);\n+  hash_entry_type *slot = htab->entries + index;\n+  hashval_t hash2;\n+\n+  if (*slot == HTAB_EMPTY_ENTRY)\n+    return slot;\n+  else if (*slot == HTAB_DELETED_ENTRY)\n+    abort ();\n+\n+  hash2 = htab_mod_m2 (hash, htab);\n+  for (;;)\n+    {\n+      index += hash2;\n+      if (index >= size)\n+\tindex -= size;\n+\n+      slot = htab->entries + index;\n+      if (*slot == HTAB_EMPTY_ENTRY)\n+\treturn slot;\n+      else if (*slot == HTAB_DELETED_ENTRY)\n+\tabort ();\n+    }\n+}\n+\n+/* The following function changes size of memory allocated for the\n+   entries and repeatedly inserts the table elements.  The occupancy\n+   of the table after the call will be about 50%.  Naturally the hash\n+   table must already exist.  Remember also that the place of the\n+   table entries is changed.  */\n+\n+static htab_t\n+htab_expand (htab_t htab)\n+{\n+  htab_t nhtab;\n+  hash_entry_type *olimit;\n+  hash_entry_type *p;\n+  size_t osize, elts;\n+\n+  osize = htab->size;\n+  olimit = htab->entries + osize;\n+  elts = htab_elements (htab);\n+\n+  /* Resize only when table after removal of unused elements is either\n+     too full or too empty.  */\n+  if (elts * 2 > osize || (elts * 8 < osize && osize > 32))\n+    nhtab = htab_create (elts * 2);\n+  else\n+    nhtab = htab_create (osize - 1);\n+  nhtab->n_elements = htab->n_elements - htab->n_deleted;\n+\n+  p = htab->entries;\n+  do\n+    {\n+      hash_entry_type x = *p;\n+\n+      if (x != HTAB_EMPTY_ENTRY && x != HTAB_DELETED_ENTRY)\n+\t*find_empty_slot_for_expand (nhtab, htab_hash (x)) = x;\n+\n+      p++;\n+    }\n+  while (p < olimit);\n+\n+  htab_free (htab);\n+  return nhtab;\n+}\n+\n+/* This function searches for a hash table entry equal to the given\n+   element.  It cannot be used to insert or delete an element.  */\n+\n+static hash_entry_type\n+htab_find (htab_t htab, const hash_entry_type element)\n+{\n+  hashval_t index, hash2, hash = htab_hash (element);\n+  size_t size;\n+  hash_entry_type entry;\n+\n+  size = htab_size (htab);\n+  index = htab_mod (hash, htab);\n+\n+  entry = htab->entries[index];\n+  if (entry == HTAB_EMPTY_ENTRY\n+      || (entry != HTAB_DELETED_ENTRY && htab_eq (entry, element)))\n+    return entry;\n+\n+  hash2 = htab_mod_m2 (hash, htab);\n+  for (;;)\n+    {\n+      index += hash2;\n+      if (index >= size)\n+\tindex -= size;\n+\n+      entry = htab->entries[index];\n+      if (entry == HTAB_EMPTY_ENTRY\n+\t  || (entry != HTAB_DELETED_ENTRY && htab_eq (entry, element)))\n+\treturn entry;\n+    }\n+}\n+\n+/* This function searches for a hash table slot containing an entry\n+   equal to the given element.  To delete an entry, call this with\n+   insert=NO_INSERT, then call htab_clear_slot on the slot returned\n+   (possibly after doing some checks).  To insert an entry, call this\n+   with insert=INSERT, then write the value you want into the returned\n+   slot.  */\n+\n+static hash_entry_type *\n+htab_find_slot (htab_t *htabp, const hash_entry_type element,\n+\t\tenum insert_option insert)\n+{\n+  hash_entry_type *first_deleted_slot;\n+  hashval_t index, hash2, hash = htab_hash (element);\n+  size_t size;\n+  hash_entry_type entry;\n+  htab_t htab = *htabp;\n+\n+  size = htab_size (htab);\n+  if (insert == INSERT && size * 3 <= htab->n_elements * 4)\n+    {\n+      htab = *htabp = htab_expand (htab);\n+      size = htab_size (htab);\n+    }\n+\n+  index = htab_mod (hash, htab);\n+\n+  first_deleted_slot = NULL;\n+\n+  entry = htab->entries[index];\n+  if (entry == HTAB_EMPTY_ENTRY)\n+    goto empty_entry;\n+  else if (entry == HTAB_DELETED_ENTRY)\n+    first_deleted_slot = &htab->entries[index];\n+  else if (htab_eq (entry, element))\n+    return &htab->entries[index];\n+\n+  hash2 = htab_mod_m2 (hash, htab);\n+  for (;;)\n+    {\n+      index += hash2;\n+      if (index >= size)\n+\tindex -= size;\n+\n+      entry = htab->entries[index];\n+      if (entry == HTAB_EMPTY_ENTRY)\n+\tgoto empty_entry;\n+      else if (entry == HTAB_DELETED_ENTRY)\n+\t{\n+\t  if (!first_deleted_slot)\n+\t    first_deleted_slot = &htab->entries[index];\n+\t}\n+      else if (htab_eq (entry, element))\n+\treturn &htab->entries[index];\n+    }\n+\n+ empty_entry:\n+  if (insert == NO_INSERT)\n+    return NULL;\n+\n+  if (first_deleted_slot)\n+    {\n+      htab->n_deleted--;\n+      *first_deleted_slot = HTAB_EMPTY_ENTRY;\n+      return first_deleted_slot;\n+    }\n+\n+  htab->n_elements++;\n+  return &htab->entries[index];\n+}\n+\n+/* This function clears a specified slot in a hash table.  It is\n+   useful when you've already done the lookup and don't want to do it\n+   again.  */\n+\n+static inline void\n+htab_clear_slot (htab_t htab, hash_entry_type *slot)\n+{\n+  if (slot < htab->entries || slot >= htab->entries + htab_size (htab)\n+      || *slot == HTAB_EMPTY_ENTRY || *slot == HTAB_DELETED_ENTRY)\n+    abort ();\n+\n+  *slot = HTAB_DELETED_ENTRY;\n+  htab->n_deleted++;\n+}\n+\n+/* Returns a hash code for pointer P. Simplified version of evahash */\n+\n+static inline hashval_t\n+hash_pointer (const void *p)\n+{\n+  uintptr_t v = (uintptr_t) p;\n+  if (sizeof (v) > sizeof (hashval_t))\n+    v ^= v >> (sizeof (uintptr_t) / 2 * __CHAR_BIT__);\n+  return v;\n+}"}, {"sha": "bdc0486ad12c4ac7221e78be4cd29e7954990e6b", "filename": "libgomp/libgomp.h", "status": "modified", "additions": 125, "deletions": 15, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Flibgomp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Flibgomp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp.h?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -39,6 +39,7 @@\n \n #include <pthread.h>\n #include <stdbool.h>\n+#include <stdlib.h>\n \n #ifdef HAVE_ATTRIBUTE_VISIBILITY\n # pragma GCC visibility push(hidden)\n@@ -201,6 +202,10 @@ struct gomp_team_state\n   /* Active nesting level.  Only active parallel regions are counted.  */\n   unsigned active_level;\n \n+  /* Place-partition-var, offset and length into gomp_places_list array.  */\n+  unsigned place_partition_off;\n+  unsigned place_partition_len;\n+\n #ifdef HAVE_SYNC_BUILTINS\n   /* Number of single stmts encountered.  */\n   unsigned long single_count;\n@@ -214,30 +219,40 @@ struct gomp_team_state\n   unsigned long static_trip;\n };\n \n-/* These are the OpenMP 3.0 Internal Control Variables described in\n+struct target_mem_desc;\n+\n+/* These are the OpenMP 4.0 Internal Control Variables described in\n    section 2.3.1.  Those described as having one copy per task are\n    stored within the structure; those described as having one copy\n    for the whole program are (naturally) global variables.  */\n-\n+   \n struct gomp_task_icv\n {\n   unsigned long nthreads_var;\n   enum gomp_schedule_type run_sched_var;\n   int run_sched_modifier;\n+  int default_device_var;\n+  unsigned int thread_limit_var;\n   bool dyn_var;\n   bool nest_var;\n+  char bind_var;\n+  /* Internal ICV.  */\n+  struct target_mem_desc *target_data;\n };\n \n extern struct gomp_task_icv gomp_global_icv;\n-extern unsigned long gomp_thread_limit_var;\n-extern unsigned long gomp_remaining_threads_count;\n #ifndef HAVE_SYNC_BUILTINS\n-extern gomp_mutex_t gomp_remaining_threads_lock;\n+extern gomp_mutex_t gomp_managed_threads_lock;\n #endif\n extern unsigned long gomp_max_active_levels_var;\n+extern bool gomp_cancel_var;\n extern unsigned long long gomp_spin_count_var, gomp_throttled_spin_count_var;\n extern unsigned long gomp_available_cpus, gomp_managed_threads;\n extern unsigned long *gomp_nthreads_var_list, gomp_nthreads_var_list_len;\n+extern char *gomp_bind_var_list;\n+extern unsigned long gomp_bind_var_list_len;\n+extern void **gomp_places_list;\n+extern unsigned long gomp_places_list_len;\n \n enum gomp_task_kind\n {\n@@ -247,6 +262,27 @@ enum gomp_task_kind\n   GOMP_TASK_TIED\n };\n \n+struct gomp_task;\n+struct gomp_taskgroup;\n+struct htab;\n+\n+struct gomp_task_depend_entry\n+{\n+  void *addr;\n+  struct gomp_task_depend_entry *next;\n+  struct gomp_task_depend_entry *prev;\n+  struct gomp_task *task;\n+  bool is_in;\n+  bool redundant;\n+};\n+\n+struct gomp_dependers_vec\n+{\n+  size_t n_elem;\n+  size_t allocated;\n+  struct gomp_task *elem[];\n+};\n+\n /* This structure describes a \"task\" to be run by a thread.  */\n \n struct gomp_task\n@@ -257,14 +293,33 @@ struct gomp_task\n   struct gomp_task *prev_child;\n   struct gomp_task *next_queue;\n   struct gomp_task *prev_queue;\n+  struct gomp_task *next_taskgroup;\n+  struct gomp_task *prev_taskgroup;\n+  struct gomp_taskgroup *taskgroup;\n+  struct gomp_dependers_vec *dependers;\n+  struct htab *depend_hash;\n+  size_t depend_count;\n+  size_t num_dependees;\n   struct gomp_task_icv icv;\n   void (*fn) (void *);\n   void *fn_data;\n   enum gomp_task_kind kind;\n   bool in_taskwait;\n   bool in_tied_task;\n   bool final_task;\n+  bool copy_ctors_done;\n   gomp_sem_t taskwait_sem;\n+  struct gomp_task_depend_entry depend[];\n+};\n+\n+struct gomp_taskgroup\n+{\n+  struct gomp_taskgroup *prev;\n+  struct gomp_task *children;\n+  bool in_taskgroup_wait;\n+  bool cancelled;\n+  gomp_sem_t taskgroup_sem;\n+  size_t num_children;\n };\n \n /* This structure describes a \"team\" of threads.  These are the threads\n@@ -293,6 +348,12 @@ struct gomp_team\n      of the threads in the team.  */\n   gomp_sem_t **ordered_release;\n \n+  /* List of work shares on which gomp_fini_work_share hasn't been\n+     called yet.  If the team hasn't been cancelled, this should be\n+     equal to each thr->ts.work_share, but otherwise it can be a possibly\n+     long list of workshares.  */\n+  struct gomp_work_share *work_shares_to_free;\n+\n   /* List of gomp_work_share structs chained through next_free fields.\n      This is populated and taken off only by the first thread in the\n      team encountering a new work sharing construct, in a critical\n@@ -324,8 +385,20 @@ struct gomp_team\n \n   gomp_mutex_t task_lock;\n   struct gomp_task *task_queue;\n-  int task_count;\n-  int task_running_count;\n+  /* Number of all GOMP_TASK_{WAITING,TIED} tasks in the team.  */\n+  unsigned int task_count;\n+  /* Number of GOMP_TASK_WAITING tasks currently waiting to be scheduled.  */\n+  unsigned int task_queued_count;\n+  /* Number of GOMP_TASK_{WAITING,TIED} tasks currently running\n+     directly in gomp_barrier_handle_tasks; tasks spawned\n+     from e.g. GOMP_taskwait or GOMP_taskgroup_end don't count, even when\n+     that is called from a task run from gomp_barrier_handle_tasks.\n+     task_running_count should be always <= team->nthreads,\n+     and if current task isn't in_tied_task, then it will be\n+     even < team->nthreads.  */\n+  unsigned int task_running_count;\n+  int work_share_cancelled;\n+  int team_cancelled;\n \n   /* This array contains structures for implicit tasks.  */\n   struct gomp_task implicit_task[];\n@@ -350,7 +423,11 @@ struct gomp_thread\n   /* This semaphore is used for ordered loops.  */\n   gomp_sem_t release;\n \n-  /* user pthread thread pool */\n+  /* Place this thread is bound to plus one, or zero if not bound\n+     to any place.  */\n+  unsigned int place;\n+\n+  /* User pthread thread pool */\n   struct gomp_thread_pool *thread_pool;\n };\n \n@@ -363,11 +440,23 @@ struct gomp_thread_pool\n   unsigned threads_size;\n   unsigned threads_used;\n   struct gomp_team *last_team;\n+  /* Number of threads running in this contention group.  */\n+  unsigned long threads_busy;\n \n   /* This barrier holds and releases threads waiting in threads.  */\n   gomp_barrier_t threads_dock;\n };\n \n+enum gomp_cancel_kind\n+{\n+  GOMP_CANCEL_PARALLEL = 1,\n+  GOMP_CANCEL_LOOP = 2,\n+  GOMP_CANCEL_FOR = GOMP_CANCEL_LOOP,\n+  GOMP_CANCEL_DO = GOMP_CANCEL_LOOP,\n+  GOMP_CANCEL_SECTIONS = 4,\n+  GOMP_CANCEL_TASKGROUP = 8\n+};\n+\n /* ... and here is that TLS data.  */\n \n #ifdef HAVE_TLS\n@@ -402,17 +491,22 @@ static inline struct gomp_task_icv *gomp_icv (bool write)\n /* The attributes to be used during thread creation.  */\n extern pthread_attr_t gomp_thread_attr;\n \n-/* Other variables.  */\n-\n-extern unsigned short *gomp_cpu_affinity;\n-extern size_t gomp_cpu_affinity_len;\n-\n /* Function prototypes.  */\n \n /* affinity.c */\n \n extern void gomp_init_affinity (void);\n-extern void gomp_init_thread_affinity (pthread_attr_t *);\n+extern void gomp_init_thread_affinity (pthread_attr_t *, unsigned int);\n+extern void **gomp_affinity_alloc (unsigned long, bool);\n+extern void gomp_affinity_init_place (void *);\n+extern bool gomp_affinity_add_cpus (void *, unsigned long, unsigned long,\n+\t\t\t\t    long, bool);\n+extern bool gomp_affinity_remove_cpu (void *, unsigned long);\n+extern bool gomp_affinity_copy_place (void *, void *, long);\n+extern bool gomp_affinity_same_place (void *, void *);\n+extern bool gomp_affinity_finalize_place_list (bool);\n+extern bool gomp_affinity_init_level (int, unsigned long, bool);\n+extern void gomp_affinity_print_place (void *);\n \n /* alloc.c */\n \n@@ -486,22 +580,30 @@ extern void gomp_barrier_handle_tasks (gomp_barrier_state_t);\n static void inline\n gomp_finish_task (struct gomp_task *task)\n {\n+  if (__builtin_expect (task->depend_hash != NULL, 0))\n+    free (task->depend_hash);\n   gomp_sem_destroy (&task->taskwait_sem);\n }\n \n /* team.c */\n \n extern struct gomp_team *gomp_new_team (unsigned);\n extern void gomp_team_start (void (*) (void *), void *, unsigned,\n-\t\t\t     struct gomp_team *);\n+\t\t\t     unsigned, struct gomp_team *);\n extern void gomp_team_end (void);\n+extern void gomp_free_thread (void *);\n+\n+/* target.c */\n+\n+extern int gomp_get_num_devices (void);\n \n /* work.c */\n \n extern void gomp_init_work_share (struct gomp_work_share *, bool, unsigned);\n extern void gomp_fini_work_share (struct gomp_work_share *);\n extern bool gomp_work_share_start (bool);\n extern void gomp_work_share_end (void);\n+extern bool gomp_work_share_end_cancel (void);\n extern void gomp_work_share_end_nowait (void);\n \n static inline void\n@@ -580,11 +682,19 @@ extern int gomp_test_nest_lock_25 (omp_nest_lock_25_t *) __GOMP_NOTHROW;\n #endif\n \n #ifdef HAVE_ATTRIBUTE_ALIAS\n+# define ialias_ulp\tialias_str1(__USER_LABEL_PREFIX__)\n+# define ialias_str1(x)\tialias_str2(x)\n+# define ialias_str2(x)\t#x\n # define ialias(fn) \\\n   extern __typeof (fn) gomp_ialias_##fn \\\n     __attribute__ ((alias (#fn))) attribute_hidden;\n+# define ialias_redirect(fn) \\\n+  extern __typeof (fn) fn __asm__ (ialias_ulp \"gomp_ialias_\" #fn) attribute_hidden;\n+# define ialias_call(fn) gomp_ialias_ ## fn\n #else\n # define ialias(fn)\n+# define ialias_redirect(fn)\n+# define ialias_call(fn) fn\n #endif\n \n #endif /* LIBGOMP_H */"}, {"sha": "b102fd883575eb8628ffbcfe0dd5c1c461ed0732", "filename": "libgomp/libgomp.map", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Flibgomp.map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Flibgomp.map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp.map?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -113,6 +113,27 @@ OMP_3.1 {\n \tomp_in_final_;\n } OMP_3.0;\n \n+OMP_4.0 {\n+  global:\n+\tomp_get_cancellation;\n+\tomp_get_cancellation_;\n+\tomp_get_proc_bind;\n+\tomp_get_proc_bind_;\n+\tomp_set_default_device;\n+\tomp_set_default_device_;\n+\tomp_set_default_device_8_;\n+\tomp_get_default_device;\n+\tomp_get_default_device_;\n+\tomp_get_num_devices;\n+\tomp_get_num_devices_;\n+\tomp_get_num_teams;\n+\tomp_get_num_teams_;\n+\tomp_get_team_num;\n+\tomp_get_team_num_;\n+\tomp_is_initial_device;\n+\tomp_is_initial_device_;\n+} OMP_3.1;\n+\n GOMP_1.0 {\n   global:\n \tGOMP_atomic_end;\n@@ -184,3 +205,25 @@ GOMP_3.0 {\n   global:\n \tGOMP_taskyield;\n } GOMP_2.0;\n+\n+GOMP_4.0 {\n+  global:\n+\tGOMP_barrier_cancel;\n+\tGOMP_cancel;\n+\tGOMP_cancellation_point;\n+\tGOMP_loop_end_cancel;\n+\tGOMP_parallel_loop_dynamic;\n+\tGOMP_parallel_loop_guided;\n+\tGOMP_parallel_loop_runtime;\n+\tGOMP_parallel_loop_static;\n+\tGOMP_parallel_sections;\n+\tGOMP_parallel;\n+\tGOMP_sections_end_cancel;\n+\tGOMP_taskgroup_start;\n+\tGOMP_taskgroup_end;\n+\tGOMP_target;\n+\tGOMP_target_data;\n+\tGOMP_target_end_data;\n+\tGOMP_target_update;\n+\tGOMP_teams;\n+} GOMP_3.0;"}, {"sha": "a6930cc318b416abec041ed48e098151e20d1b71", "filename": "libgomp/libgomp.texi", "status": "modified", "additions": 67, "deletions": 19, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Flibgomp.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Flibgomp.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp.texi?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -1083,12 +1083,9 @@ guaranteed not to change during the execution of the program.\n @node Environment Variables\n @chapter Environment Variables\n \n-The variables @env{OMP_DYNAMIC}, @env{OMP_MAX_ACTIVE_LEVELS},\n-@env{OMP_NESTED}, @env{OMP_NUM_THREADS}, @env{OMP_SCHEDULE},\n-@env{OMP_STACKSIZE},@env{OMP_THREAD_LIMIT} and @env{OMP_WAIT_POLICY}\n-are defined by section 4 of the OpenMP specifications in version 3.1,\n-while @env{GOMP_CPU_AFFINITY} and @env{GOMP_STACKSIZE} are GNU \n-extensions.\n+The environment variables which beginning with @env{OMP_} are defined by\n+section 4 of the OpenMP specification in version 4.0, while those\n+beginning with @env{GOMP_} are GNU extensions.\n \n @menu\n * OMP_DYNAMIC::           Dynamic adjustment of threads\n@@ -1099,9 +1096,11 @@ extensions.\n * OMP_SCHEDULE::          How threads are scheduled\n * OMP_THREAD_LIMIT::      Set the maximum number of threads\n * OMP_WAIT_POLICY::       How waiting threads are handled\n+* OMP_DISPLAY_ENV::       Show OpenMP version and environment variables\n * OMP_PROC_BIND::         Whether theads may be moved between CPUs\n * GOMP_CPU_AFFINITY::     Bind threads to specific CPUs\n * GOMP_STACKSIZE::        Set default thread stack size\n+* GOMP_SPINCOUNT::        Set the busy-wait spin count\n @end menu\n \n \n@@ -1119,7 +1118,7 @@ disabled by default.\n @ref{omp_set_dynamic}\n \n @item @emph{Reference}: \n-@uref{http://www.openmp.org/, OpenMP specifications v3.1}, section 4.3\n+@uref{http://www.openmp.org/, OpenMP specifications v4.0}, section 4.3\n @end table\n \n \n@@ -1137,7 +1136,7 @@ If undefined, the number of active levels is unlimited.\n @ref{omp_set_max_active_levels}\n \n @item @emph{Reference}: \n-@uref{http://www.openmp.org/, OpenMP specifications v3.1}, section 4.8\n+@uref{http://www.openmp.org/, OpenMP specifications v4.0}, section 4.9\n @end table\n \n \n@@ -1157,7 +1156,7 @@ regions are disabled by default.\n @ref{omp_set_nested}\n \n @item @emph{Reference}: \n-@uref{http://www.openmp.org/, OpenMP specifications v3.1}, section 4.5\n+@uref{http://www.openmp.org/, OpenMP specifications v4.0}, section 4.6\n @end table\n \n \n@@ -1177,7 +1176,7 @@ level. If undefined one thread per CPU is used.\n @ref{omp_set_num_threads}\n \n @item @emph{Reference}: \n-@uref{http://www.openmp.org/, OpenMP specifications v3.1}, section 4.2\n+@uref{http://www.openmp.org/, OpenMP specifications v4.0}, section 4.2\n @end table\n \n \n@@ -1198,7 +1197,7 @@ dynamic scheduling and a chunk size of 1 is used.\n @ref{omp_set_schedule}\n \n @item @emph{Reference}: \n-@uref{http://www.openmp.org/, OpenMP specifications v3.1}, sections 2.5.1 and 4.1\n+@uref{http://www.openmp.org/, OpenMP specifications v4.0}, sections 2.7.1 and 4.1\n @end table\n \n \n@@ -1218,7 +1217,7 @@ stack size is left unchanged. If undefined, the stack size is system\n dependent.\n \n @item @emph{Reference}: \n-@uref{http://www.openmp.org/, OpenMP specifications v3.1}, sections 4.6\n+@uref{http://www.openmp.org/, OpenMP specifications v4.0}, section 4.7\n @end table\n \n \n@@ -1237,7 +1236,7 @@ the number of threads is not limited.\n @ref{omp_get_thread_limit}\n \n @item @emph{Reference}: \n-@uref{http://www.openmp.org/, OpenMP specifications v3.1}, section 4.9\n+@uref{http://www.openmp.org/, OpenMP specifications v4.0}, section 4.10\n @end table\n \n \n@@ -1250,10 +1249,14 @@ the number of threads is not limited.\n Specifies whether waiting threads should be active or passive. If\n the value is @code{PASSIVE}, waiting threads should not consume CPU\n power while waiting; while the value is @code{ACTIVE} specifies that\n-they should.\n+they should. If undefined, threads wait actively for a short time\n+before waiting passively.\n+\n+@item @emph{See also}:\n+@ref{GOMP_SPINCOUNT}\n \n @item @emph{Reference}: \n-@uref{http://www.openmp.org/, OpenMP specifications v3.1}, sections 4.7\n+@uref{http://www.openmp.org/, OpenMP specifications v4.0}, section 4.8\n @end table\n \n \n@@ -1264,14 +1267,32 @@ they should.\n @table @asis\n @item @emph{Description}:\n Specifies whether threads may be moved between processors. If set to\n-@code{true}, OpenMP theads should not be moved, if set to @code{false}\n-they may be moved.\n+@code{TRUE}, OpenMP theads should not be moved, if set to @code{FALSE}\n+they may be moved. If undefined, threads may move between processors.\n \n @item @emph{See also}:\n @ref{GOMP_CPU_AFFINITY}\n \n @item @emph{Reference}: \n-@uref{http://www.openmp.org/, OpenMP specifications v3.1}, sections 4.4\n+@uref{http://www.openmp.org/, OpenMP specifications v4.0}, section 4.4\n+@end table\n+\n+\n+\n+@node OMP_DISPLAY_ENV\n+@section @env{OMP_DISPLAY_ENV} -- Show OpenMP version and environment variables\n+@cindex Environment Variable\n+@table @asis\n+@item @emph{Description}:\n+If set to @code{TRUE}, the OpenMP version number and the values\n+associated with the OpenMP environment variables are printed to @code{stderr}.\n+If set to @code{VERBOSE}, it additionally shows the value of the environment\n+variables which are GNU extensions. If undefined or set to @code{FALSE},\n+this information will not be shown.\n+\n+\n+@item @emph{Reference}:\n+@uref{http://www.openmp.org/, OpenMP specifications v4.0}, section 4.12\n @end table\n \n \n@@ -1298,7 +1319,7 @@ Fortran, may be used to query the setting of the @code{GOMP_CPU_AFFINITY}\n environment variable. A defined CPU affinity on startup cannot be changed \n or disabled during the runtime of the application.\n \n-If this environment variable is omitted, the host system will handle the \n+If this environment variable is omitted, the host system will handle the\n assignment of threads to CPUs. \n \n @item @emph{See also}:\n@@ -1331,6 +1352,33 @@ GCC Patches Mailinglist}\n \n \n \n+@node GOMP_SPINCOUNT\n+@section @env{GOMP_SPINCOUNT} -- Set the busy-wait spin count\n+@cindex Environment Variable\n+@cindex Implementation specific setting\n+@table @asis\n+@item @emph{Description}:\n+Determines how long a threads waits actively with consuming CPU power\n+before waiting passively without consuming CPU power. The value may be\n+either @code{INFINITE}, @code{INFINITY} to always wait actively or an\n+integer which gives the number of spins of the busy-wait loop. The\n+integer may optionally be followed by the following suffixes acting\n+as multiplication factors: @code{k} (kilo, thousand), @code{M} (mega,\n+million), @code{G} (giga, billion), or @code{T} (tera, trillion).\n+If undefined, 0 is used when @env{OMP_WAIT_POLICY} is @code{PASSIVE},\n+300,000 is used when @env{OMP_WAIT_POLICY} is undefined and\n+30 billion is used when @env{OMP_WAIT_POLICY} is @code{ACTIVE}.\n+If there are more OpenMP threads than available CPUs, 1000 and 100\n+spins are used for @env{OMP_WAIT_POLICY} being @code{ACTIVE} or\n+undefined, respectively; unless the @env{GOMP_SPINCOUNT} is lower\n+or @env{OMP_WAIT_POLICY} is @code{PASSIVE}.\n+\n+@item @emph{See also}:\n+@ref{OMP_WAIT_POLICY}\n+@end table\n+\n+\n+\n @c ---------------------------------------------------------------------\n @c The libgomp ABI\n @c ---------------------------------------------------------------------"}, {"sha": "32c4cf6142193540dd7f7237f413303339caa4b5", "filename": "libgomp/libgomp_g.h", "status": "modified", "additions": 34, "deletions": 1, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Flibgomp_g.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Flibgomp_g.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp_g.h?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -33,6 +33,7 @@\n /* barrier.c */\n \n extern void GOMP_barrier (void);\n+extern bool GOMP_barrier_cancel (void);\n \n /* critical.c */\n \n@@ -76,9 +77,22 @@ extern void GOMP_parallel_loop_guided_start (void (*)(void *), void *,\n \t\t\t\t\t     unsigned, long, long, long, long);\n extern void GOMP_parallel_loop_runtime_start (void (*)(void *), void *,\n \t\t\t\t\t      unsigned, long, long, long);\n+extern void GOMP_parallel_loop_static (void (*)(void *), void *,\n+\t\t\t\t       unsigned, long, long, long, long,\n+\t\t\t\t       unsigned);\n+extern void GOMP_parallel_loop_dynamic (void (*)(void *), void *,\n+\t\t\t\t\tunsigned, long, long, long, long,\n+\t\t\t\t\tunsigned);\n+extern void GOMP_parallel_loop_guided (void (*)(void *), void *,\n+\t\t\t\t       unsigned, long, long, long, long,\n+\t\t\t\t       unsigned);\n+extern void GOMP_parallel_loop_runtime (void (*)(void *), void *,\n+\t\t\t\t\tunsigned, long, long, long,\n+\t\t\t\t\tunsigned);\n \n extern void GOMP_loop_end (void);\n extern void GOMP_loop_end_nowait (void);\n+extern bool GOMP_loop_end_cancel (void);\n \n /* loop_ull.c */\n \n@@ -157,27 +171,46 @@ extern void GOMP_ordered_end (void);\n \n extern void GOMP_parallel_start (void (*) (void *), void *, unsigned);\n extern void GOMP_parallel_end (void);\n+extern void GOMP_parallel (void (*) (void *), void *, unsigned, unsigned);\n+extern bool GOMP_cancel (int, bool);\n+extern bool GOMP_cancellation_point (int);\n \n /* task.c */\n \n extern void GOMP_task (void (*) (void *), void *, void (*) (void *, void *),\n-\t\t       long, long, bool, unsigned);\n+\t\t       long, long, bool, unsigned, void **);\n extern void GOMP_taskwait (void);\n extern void GOMP_taskyield (void);\n+extern void GOMP_taskgroup_start (void);\n+extern void GOMP_taskgroup_end (void);\n \n /* sections.c */\n \n extern unsigned GOMP_sections_start (unsigned);\n extern unsigned GOMP_sections_next (void);\n extern void GOMP_parallel_sections_start (void (*) (void *), void *,\n \t\t\t\t\t  unsigned, unsigned);\n+extern void GOMP_parallel_sections (void (*) (void *), void *,\n+\t\t\t\t    unsigned, unsigned, unsigned);\n extern void GOMP_sections_end (void);\n extern void GOMP_sections_end_nowait (void);\n+extern bool GOMP_sections_end_cancel (void);\n \n /* single.c */\n \n extern bool GOMP_single_start (void);\n extern void *GOMP_single_copy_start (void);\n extern void GOMP_single_copy_end (void *);\n \n+/* target.c */\n+\n+extern void GOMP_target (int, void (*) (void *), const void *,\n+\t\t\t size_t, void **, size_t *, unsigned char *);\n+extern void GOMP_target_data (int, const void *,\n+\t\t\t      size_t, void **, size_t *, unsigned char *);\n+extern void GOMP_target_end_data (void);\n+extern void GOMP_target_update (int, const void *,\n+\t\t\t\tsize_t, void **, size_t *, unsigned char *);\n+extern void GOMP_teams (unsigned int, unsigned int);\n+\n #endif /* LIBGOMP_G_H */"}, {"sha": "f5b33a06658a0fec75681927513a59b2a43dd83f", "filename": "libgomp/loop.c", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Floop.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -439,14 +439,14 @@ static void\n gomp_parallel_loop_start (void (*fn) (void *), void *data,\n \t\t\t  unsigned num_threads, long start, long end,\n \t\t\t  long incr, enum gomp_schedule_type sched,\n-\t\t\t  long chunk_size)\n+\t\t\t  long chunk_size, unsigned int flags)\n {\n   struct gomp_team *team;\n \n   num_threads = gomp_resolve_num_threads (num_threads, 0);\n   team = gomp_new_team (num_threads);\n   gomp_loop_init (&team->work_shares[0], start, end, incr, sched, chunk_size);\n-  gomp_team_start (fn, data, num_threads, team);\n+  gomp_team_start (fn, data, num_threads, flags, team);\n }\n \n void\n@@ -455,7 +455,7 @@ GOMP_parallel_loop_static_start (void (*fn) (void *), void *data,\n \t\t\t\t long incr, long chunk_size)\n {\n   gomp_parallel_loop_start (fn, data, num_threads, start, end, incr,\n-\t\t\t    GFS_STATIC, chunk_size);\n+\t\t\t    GFS_STATIC, chunk_size, 0);\n }\n \n void\n@@ -464,7 +464,7 @@ GOMP_parallel_loop_dynamic_start (void (*fn) (void *), void *data,\n \t\t\t\t  long incr, long chunk_size)\n {\n   gomp_parallel_loop_start (fn, data, num_threads, start, end, incr,\n-\t\t\t    GFS_DYNAMIC, chunk_size);\n+\t\t\t    GFS_DYNAMIC, chunk_size, 0);\n }\n \n void\n@@ -473,7 +473,7 @@ GOMP_parallel_loop_guided_start (void (*fn) (void *), void *data,\n \t\t\t\t long incr, long chunk_size)\n {\n   gomp_parallel_loop_start (fn, data, num_threads, start, end, incr,\n-\t\t\t    GFS_GUIDED, chunk_size);\n+\t\t\t    GFS_GUIDED, chunk_size, 0);\n }\n \n void\n@@ -483,11 +483,59 @@ GOMP_parallel_loop_runtime_start (void (*fn) (void *), void *data,\n {\n   struct gomp_task_icv *icv = gomp_icv (false);\n   gomp_parallel_loop_start (fn, data, num_threads, start, end, incr,\n-\t\t\t    icv->run_sched_var, icv->run_sched_modifier);\n+\t\t\t    icv->run_sched_var, icv->run_sched_modifier, 0);\n+}\n+\n+ialias_redirect (GOMP_parallel_end)\n+\n+void\n+GOMP_parallel_loop_static (void (*fn) (void *), void *data,\n+\t\t\t   unsigned num_threads, long start, long end,\n+\t\t\t   long incr, long chunk_size, unsigned flags)\n+{\n+  gomp_parallel_loop_start (fn, data, num_threads, start, end, incr,\n+\t\t\t    GFS_STATIC, chunk_size, flags);\n+  fn (data);\n+  GOMP_parallel_end ();\n+}\n+\n+void\n+GOMP_parallel_loop_dynamic (void (*fn) (void *), void *data,\n+\t\t\t    unsigned num_threads, long start, long end,\n+\t\t\t    long incr, long chunk_size, unsigned flags)\n+{\n+  gomp_parallel_loop_start (fn, data, num_threads, start, end, incr,\n+\t\t\t    GFS_DYNAMIC, chunk_size, flags);\n+  fn (data);\n+  GOMP_parallel_end ();\n+}\n+\n+void\n+GOMP_parallel_loop_guided (void (*fn) (void *), void *data,\n+\t\t\t  unsigned num_threads, long start, long end,\n+\t\t\t  long incr, long chunk_size, unsigned flags)\n+{\n+  gomp_parallel_loop_start (fn, data, num_threads, start, end, incr,\n+\t\t\t    GFS_GUIDED, chunk_size, flags);\n+  fn (data);\n+  GOMP_parallel_end ();\n+}\n+\n+void\n+GOMP_parallel_loop_runtime (void (*fn) (void *), void *data,\n+\t\t\t    unsigned num_threads, long start, long end,\n+\t\t\t    long incr, unsigned flags)\n+{\n+  struct gomp_task_icv *icv = gomp_icv (false);\n+  gomp_parallel_loop_start (fn, data, num_threads, start, end, incr,\n+\t\t\t    icv->run_sched_var, icv->run_sched_modifier,\n+\t\t\t    flags);\n+  fn (data);\n+  GOMP_parallel_end ();\n }\n \n /* The GOMP_loop_end* routines are called after the thread is told that\n-   all loop iterations are complete.  This first version synchronizes\n+   all loop iterations are complete.  The first two versions synchronize\n    all threads; the nowait version does not.  */\n \n void\n@@ -496,6 +544,12 @@ GOMP_loop_end (void)\n   gomp_work_share_end ();\n }\n \n+bool\n+GOMP_loop_end_cancel (void)\n+{\n+  return gomp_work_share_end_cancel ();\n+}\n+\n void\n GOMP_loop_end_nowait (void)\n {"}, {"sha": "4fc123669ecad60637cfd9cc67b1686cb8339dfe", "filename": "libgomp/omp.h.in", "status": "modified", "additions": 31, "deletions": 11, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Fomp.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Fomp.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fomp.h.in?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -52,6 +52,15 @@ typedef enum omp_sched_t\n   omp_sched_auto = 4\n } omp_sched_t;\n \n+typedef enum omp_proc_bind_t\n+{\n+  omp_proc_bind_false = 0,\n+  omp_proc_bind_true = 1,\n+  omp_proc_bind_master = 2,\n+  omp_proc_bind_close = 3,\n+  omp_proc_bind_spread = 4\n+} omp_proc_bind_t;\n+\n #ifdef __cplusplus\n extern \"C\" {\n # define __GOMP_NOTHROW throw ()\n@@ -88,17 +97,28 @@ extern int omp_test_nest_lock (omp_nest_lock_t *) __GOMP_NOTHROW;\n extern double omp_get_wtime (void) __GOMP_NOTHROW;\n extern double omp_get_wtick (void) __GOMP_NOTHROW;\n \n-void omp_set_schedule (omp_sched_t, int) __GOMP_NOTHROW;\n-void omp_get_schedule (omp_sched_t *, int *) __GOMP_NOTHROW;\n-int omp_get_thread_limit (void) __GOMP_NOTHROW;\n-void omp_set_max_active_levels (int) __GOMP_NOTHROW;\n-int omp_get_max_active_levels (void) __GOMP_NOTHROW;\n-int omp_get_level (void) __GOMP_NOTHROW;\n-int omp_get_ancestor_thread_num (int) __GOMP_NOTHROW;\n-int omp_get_team_size (int) __GOMP_NOTHROW;\n-int omp_get_active_level (void) __GOMP_NOTHROW;\n-\n-int omp_in_final (void) __GOMP_NOTHROW;\n+extern void omp_set_schedule (omp_sched_t, int) __GOMP_NOTHROW;\n+extern void omp_get_schedule (omp_sched_t *, int *) __GOMP_NOTHROW;\n+extern int omp_get_thread_limit (void) __GOMP_NOTHROW;\n+extern void omp_set_max_active_levels (int) __GOMP_NOTHROW;\n+extern int omp_get_max_active_levels (void) __GOMP_NOTHROW;\n+extern int omp_get_level (void) __GOMP_NOTHROW;\n+extern int omp_get_ancestor_thread_num (int) __GOMP_NOTHROW;\n+extern int omp_get_team_size (int) __GOMP_NOTHROW;\n+extern int omp_get_active_level (void) __GOMP_NOTHROW;\n+\n+extern int omp_in_final (void) __GOMP_NOTHROW;\n+\n+extern int omp_get_cancellation (void) __GOMP_NOTHROW;\n+extern omp_proc_bind_t omp_get_proc_bind (void) __GOMP_NOTHROW;\n+\n+extern void omp_set_default_device (int) __GOMP_NOTHROW;\n+extern int omp_get_default_device (void) __GOMP_NOTHROW;\n+extern int omp_get_num_devices (void) __GOMP_NOTHROW;\n+extern int omp_get_num_teams (void) __GOMP_NOTHROW;\n+extern int omp_get_team_num (void) __GOMP_NOTHROW;\n+\n+extern int omp_is_initial_device (void) __GOMP_NOTHROW;\n \n #ifdef __cplusplus\n }"}, {"sha": "3c6deb6bbd51afb302d2864539cbd6e29d64e69f", "filename": "libgomp/omp_lib.f90.in", "status": "modified", "additions": 62, "deletions": 22, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Fomp_lib.f90.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Fomp_lib.f90.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fomp_lib.f90.in?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -27,16 +27,22 @@\n         integer, parameter :: omp_lock_kind = @OMP_LOCK_KIND@\n         integer, parameter :: omp_nest_lock_kind = @OMP_NEST_LOCK_KIND@\n         integer, parameter :: omp_sched_kind = 4\n+        integer, parameter :: omp_proc_bind_kind = 4\n+        integer (omp_sched_kind), parameter :: omp_sched_static = 1\n+        integer (omp_sched_kind), parameter :: omp_sched_dynamic = 2\n+        integer (omp_sched_kind), parameter :: omp_sched_guided = 3\n+        integer (omp_sched_kind), parameter :: omp_sched_auto = 4\n+        integer (omp_proc_bind_kind), parameter :: omp_proc_bind_false = 0\n+        integer (omp_proc_bind_kind), parameter :: omp_proc_bind_true = 1\n+        integer (omp_proc_bind_kind), parameter :: omp_proc_bind_master = 2\n+        integer (omp_proc_bind_kind), parameter :: omp_proc_bind_close = 3\n+        integer (omp_proc_bind_kind), parameter :: omp_proc_bind_spread = 4\n       end module\n \n       module omp_lib\n         use omp_lib_kinds\n         implicit none\n         integer, parameter :: openmp_version = 201107\n-        integer (omp_sched_kind), parameter :: omp_sched_static = 1\n-        integer (omp_sched_kind), parameter :: omp_sched_dynamic = 2\n-        integer (omp_sched_kind), parameter :: omp_sched_guided = 3\n-        integer (omp_sched_kind), parameter :: omp_sched_auto = 4\n \n         interface\n           subroutine omp_init_lock (svar)\n@@ -123,21 +129,18 @@\n \n         interface\n           function omp_get_dynamic ()\n-            use omp_lib_kinds\n             logical (4) :: omp_get_dynamic\n           end function omp_get_dynamic\n         end interface\n \n         interface\n           function omp_get_nested ()\n-            use omp_lib_kinds\n             logical (4) :: omp_get_nested\n           end function omp_get_nested\n         end interface\n \n         interface\n           function omp_in_parallel ()\n-            use omp_lib_kinds\n             logical (4) :: omp_in_parallel\n           end function omp_in_parallel\n         end interface\n@@ -152,28 +155,24 @@\n \n         interface\n           function omp_get_max_threads ()\n-            use omp_lib_kinds\n             integer (4) :: omp_get_max_threads\n           end function omp_get_max_threads\n         end interface\n \n         interface\n           function omp_get_num_procs ()\n-            use omp_lib_kinds\n             integer (4) :: omp_get_num_procs\n           end function omp_get_num_procs\n         end interface\n \n         interface\n           function omp_get_num_threads ()\n-            use omp_lib_kinds\n             integer (4) :: omp_get_num_threads\n           end function omp_get_num_threads\n         end interface\n \n         interface\n           function omp_get_thread_num ()\n-            use omp_lib_kinds\n             integer (4) :: omp_get_thread_num\n           end function omp_get_thread_num\n         end interface\n@@ -226,74 +225,115 @@\n \n         interface\n           function omp_get_thread_limit ()\n-            use omp_lib_kinds\n             integer (4) :: omp_get_thread_limit\n           end function omp_get_thread_limit\n         end interface\n \n         interface omp_set_max_active_levels\n           subroutine omp_set_max_active_levels (max_levels)\n-            use omp_lib_kinds\n             integer (4), intent (in) :: max_levels\n           end subroutine omp_set_max_active_levels\n           subroutine omp_set_max_active_levels_8 (max_levels)\n-            use omp_lib_kinds\n             integer (8), intent (in) :: max_levels\n           end subroutine omp_set_max_active_levels_8\n         end interface\n \n         interface\n           function omp_get_max_active_levels ()\n-            use omp_lib_kinds\n             integer (4) :: omp_get_max_active_levels\n           end function omp_get_max_active_levels\n         end interface\n \n         interface\n           function omp_get_level ()\n-            use omp_lib_kinds\n             integer (4) :: omp_get_level\n           end function omp_get_level\n         end interface\n \n         interface omp_get_ancestor_thread_num\n           function omp_get_ancestor_thread_num (level)\n-            use omp_lib_kinds\n             integer (4), intent (in) :: level\n             integer (4) :: omp_get_ancestor_thread_num\n           end function omp_get_ancestor_thread_num\n           function omp_get_ancestor_thread_num_8 (level)\n-            use omp_lib_kinds\n             integer (8), intent (in) :: level\n             integer (4) :: omp_get_ancestor_thread_num_8\n           end function omp_get_ancestor_thread_num_8\n         end interface\n \n         interface omp_get_team_size\n           function omp_get_team_size (level)\n-            use omp_lib_kinds\n             integer (4), intent (in) :: level\n             integer (4) :: omp_get_team_size\n           end function omp_get_team_size\n           function omp_get_team_size_8 (level)\n-            use omp_lib_kinds\n             integer (8), intent (in) :: level\n             integer (4) :: omp_get_team_size_8\n           end function omp_get_team_size_8\n         end interface\n \n         interface\n           function omp_get_active_level ()\n-            use omp_lib_kinds\n             integer (4) :: omp_get_active_level\n           end function omp_get_active_level\n         end interface\n \n         interface\n           function omp_in_final ()\n-            use omp_lib_kinds\n             logical (4) :: omp_in_final\n           end function omp_in_final\n         end interface\n \n+        interface\n+          function omp_get_cancellation ()\n+            logical (4) :: omp_get_cancellation\n+          end function omp_get_cancellation\n+        end interface\n+\n+        interface\n+          function omp_get_proc_bind ()\n+            use omp_lib_kinds\n+            integer (omp_proc_bind_kind) :: omp_get_proc_bind\n+          end function omp_get_proc_bind\n+        end interface\n+\n+        interface omp_set_default_device\n+          subroutine omp_set_default_device (device_num)\n+            integer (4), intent (in) :: device_num\n+          end subroutine omp_set_default_device\n+          subroutine omp_set_default_device_8 (device_num)\n+            integer (8), intent (in) :: device_num\n+          end subroutine omp_set_default_device_8\n+        end interface\n+\n+        interface\n+          function omp_get_default_device ()\n+            integer (4) :: omp_get_default_device\n+          end function omp_get_default_device\n+        end interface\n+\n+        interface\n+          function omp_get_num_devices ()\n+            integer (4) :: omp_get_num_devices\n+          end function omp_get_num_devices\n+        end interface\n+\n+        interface\n+          function omp_get_num_teams ()\n+            integer (4) :: omp_get_num_teams\n+          end function omp_get_num_teams\n+        end interface\n+\n+        interface\n+          function omp_get_team_num ()\n+            integer (4) :: omp_get_team_num\n+          end function omp_get_team_num\n+        end interface\n+\n+        interface\n+          function omp_is_initial_device ()\n+            logical (4) :: omp_is_initial_device\n+          end function omp_is_initial_device\n+        end interface\n+\n       end module omp_lib"}, {"sha": "804636df82f2986ebded99bdcf83af62250ad07a", "filename": "libgomp/omp_lib.h.in", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Fomp_lib.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Fomp_lib.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fomp_lib.h.in?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -33,6 +33,18 @@\n       parameter (omp_sched_dynamic = 2)\n       parameter (omp_sched_guided = 3)\n       parameter (omp_sched_auto = 4)\n+      integer omp_proc_bind_kind\n+      parameter (omp_proc_bind_kind = 4)\n+      integer (omp_proc_bind_kind) omp_proc_bind_false\n+      integer (omp_proc_bind_kind) omp_proc_bind_true\n+      integer (omp_proc_bind_kind) omp_proc_bind_master\n+      integer (omp_proc_bind_kind) omp_proc_bind_close\n+      integer (omp_proc_bind_kind) omp_proc_bind_spread\n+      parameter (omp_proc_bind_false = 0)\n+      parameter (omp_proc_bind_true = 1)\n+      parameter (omp_proc_bind_master = 2)\n+      parameter (omp_proc_bind_close = 3)\n+      parameter (omp_proc_bind_spread = 4)\n       parameter (openmp_version = 201107)\n \n       external omp_init_lock, omp_init_nest_lock\n@@ -68,3 +80,18 @@\n \n       external omp_in_final\n       logical(4) omp_in_final\n+\n+      external omp_get_cancelllation\n+      logical(4) omp_get_cancelllation\n+\n+      external omp_get_proc_bind\n+      integer(omp_proc_bind_kind) omp_get_proc_bind\n+\n+      external omp_set_default_device, omp_get_default_device\n+      external omp_get_num_devices, omp_get_num_teams\n+      external omp_get_team_num\n+      integer(4) omp_get_default_device, omp_get_num_devices\n+      integer(4) omp_get_num_teams, omp_get_team_num\n+\n+      external omp_is_initial_device\n+      logical(4) omp_is_initial_device"}, {"sha": "ccc0b6a6973c25733d3fdc70e59a41d6c6e6ad52", "filename": "libgomp/parallel.c", "status": "modified", "additions": 126, "deletions": 27, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Fparallel.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Fparallel.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fparallel.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -37,18 +37,19 @@\n unsigned\n gomp_resolve_num_threads (unsigned specified, unsigned count)\n {\n-  struct gomp_thread *thread = gomp_thread();\n+  struct gomp_thread *thr = gomp_thread ();\n   struct gomp_task_icv *icv;\n   unsigned threads_requested, max_num_threads, num_threads;\n-  unsigned long remaining;\n+  unsigned long busy;\n+  struct gomp_thread_pool *pool;\n \n   icv = gomp_icv (false);\n \n   if (specified == 1)\n     return 1;\n-  else if (thread->ts.active_level >= 1 && !icv->nest_var)\n+  else if (thr->ts.active_level >= 1 && !icv->nest_var)\n     return 1;\n-  else if (thread->ts.active_level >= gomp_max_active_levels_var)\n+  else if (thr->ts.active_level >= gomp_max_active_levels_var)\n     return 1;\n \n   /* If NUM_THREADS not specified, use nthreads_var.  */\n@@ -72,30 +73,46 @@ gomp_resolve_num_threads (unsigned specified, unsigned count)\n \tmax_num_threads = count;\n     }\n \n-  /* ULONG_MAX stands for infinity.  */\n-  if (__builtin_expect (gomp_thread_limit_var == ULONG_MAX, 1)\n+  /* UINT_MAX stands for infinity.  */\n+  if (__builtin_expect (icv->thread_limit_var == UINT_MAX, 1)\n       || max_num_threads == 1)\n     return max_num_threads;\n \n+  /* The threads_busy counter lives in thread_pool, if there\n+     isn't a thread_pool yet, there must be just one thread\n+     in the contention group.  If thr->team is NULL, this isn't\n+     nested parallel, so there is just one thread in the\n+     contention group as well, no need to handle it atomically.  */\n+  pool = thr->thread_pool;\n+  if (thr->ts.team == NULL)\n+    {\n+      num_threads = max_num_threads;\n+      if (num_threads > icv->thread_limit_var)\n+\tnum_threads = icv->thread_limit_var;\n+      if (pool)\n+\tpool->threads_busy = num_threads;\n+      return num_threads;\n+    }\n+\n #ifdef HAVE_SYNC_BUILTINS\n   do\n     {\n-      remaining = gomp_remaining_threads_count;\n+      busy = pool->threads_busy;\n       num_threads = max_num_threads;\n-      if (num_threads > remaining)\n-\tnum_threads = remaining + 1;\n+      if (icv->thread_limit_var - busy + 1 < num_threads)\n+\tnum_threads = icv->thread_limit_var - busy + 1;\n     }\n-  while (__sync_val_compare_and_swap (&gomp_remaining_threads_count,\n-\t\t\t\t      remaining, remaining - num_threads + 1)\n-\t != remaining);\n+  while (__sync_val_compare_and_swap (&pool->threads_busy,\n+\t\t\t\t      busy, busy + num_threads - 1)\n+\t != busy);\n #else\n-  gomp_mutex_lock (&gomp_remaining_threads_lock);\n+  gomp_mutex_lock (&gomp_managed_threads_lock);\n   num_threads = max_num_threads;\n-  remaining = gomp_remaining_threads_count;\n-  if (num_threads > remaining)\n-    num_threads = remaining + 1;\n-  gomp_remaining_threads_count -= num_threads - 1;\n-  gomp_mutex_unlock (&gomp_remaining_threads_lock);\n+  busy = pool->threads_busy;\n+  if (icv->thread_limit_var - busy + 1 < num_threads)\n+    num_threads = icv->thread_limit_var - busy + 1;\n+  pool->threads_busy += num_threads - 1;\n+  gomp_mutex_unlock (&gomp_managed_threads_lock);\n #endif\n \n   return num_threads;\n@@ -105,31 +122,113 @@ void\n GOMP_parallel_start (void (*fn) (void *), void *data, unsigned num_threads)\n {\n   num_threads = gomp_resolve_num_threads (num_threads, 0);\n-  gomp_team_start (fn, data, num_threads, gomp_new_team (num_threads));\n+  gomp_team_start (fn, data, num_threads, 0, gomp_new_team (num_threads));\n }\n \n void\n GOMP_parallel_end (void)\n {\n-  if (__builtin_expect (gomp_thread_limit_var != ULONG_MAX, 0))\n+  struct gomp_task_icv *icv = gomp_icv (false);\n+  if (__builtin_expect (icv->thread_limit_var != UINT_MAX, 0))\n     {\n       struct gomp_thread *thr = gomp_thread ();\n       struct gomp_team *team = thr->ts.team;\n-      if (team && team->nthreads > 1)\n+      unsigned int nthreads = team ? team->nthreads : 1;\n+      gomp_team_end ();\n+      if (nthreads > 1)\n \t{\n+\t  /* If not nested, there is just one thread in the\n+\t     contention group left, no need for atomicity.  */\n+\t  if (thr->ts.team == NULL)\n+\t    thr->thread_pool->threads_busy = 1;\n+\t  else\n+\t    {\n #ifdef HAVE_SYNC_BUILTINS\n-\t  __sync_fetch_and_add (&gomp_remaining_threads_count,\n-\t\t\t\t1UL - team->nthreads);\n+\t      __sync_fetch_and_add (&thr->thread_pool->threads_busy,\n+\t\t\t\t    1UL - nthreads);\n #else\n-\t  gomp_mutex_lock (&gomp_remaining_threads_lock);\n-\t  gomp_remaining_threads_count -= team->nthreads - 1;\n-\t  gomp_mutex_unlock (&gomp_remaining_threads_lock);\n+\t      gomp_mutex_lock (&gomp_managed_threads_lock);\n+\t      thr->thread_pool->threads_busy -= nthreads - 1;\n+\t      gomp_mutex_unlock (&gomp_managed_threads_lock);\n #endif\n+\t    }\n \t}\n     }\n-  gomp_team_end ();\n+  else\n+    gomp_team_end ();\n+}\n+ialias (GOMP_parallel_end)\n+\n+void\n+GOMP_parallel (void (*fn) (void *), void *data, unsigned num_threads, unsigned int flags)\n+{\n+  num_threads = gomp_resolve_num_threads (num_threads, 0);\n+  gomp_team_start (fn, data, num_threads, flags, gomp_new_team (num_threads));\n+  fn (data);\n+  ialias_call (GOMP_parallel_end) ();\n+}\n+\n+bool\n+GOMP_cancellation_point (int which)\n+{\n+  if (!gomp_cancel_var)\n+    return false;\n+\n+  struct gomp_thread *thr = gomp_thread ();\n+  struct gomp_team *team = thr->ts.team;\n+  if (which & (GOMP_CANCEL_LOOP | GOMP_CANCEL_SECTIONS))\n+    {\n+      if (team == NULL)\n+\treturn false;\n+      return team->work_share_cancelled != 0;\n+    }\n+  else if (which & GOMP_CANCEL_TASKGROUP)\n+    {\n+      if (thr->task->taskgroup && thr->task->taskgroup->cancelled)\n+\treturn true;\n+      /* FALLTHRU into the GOMP_CANCEL_PARALLEL case,\n+\t as #pragma omp cancel parallel also cancels all explicit\n+\t tasks.  */\n+    }\n+  if (team)\n+    return gomp_team_barrier_cancelled (&team->barrier);\n+  return false;\n }\n+ialias (GOMP_cancellation_point)\n+\n+bool\n+GOMP_cancel (int which, bool do_cancel)\n+{\n+  if (!gomp_cancel_var)\n+    return false;\n+\n+  if (!do_cancel)\n+    return ialias_call (GOMP_cancellation_point) (which);\n \n+  struct gomp_thread *thr = gomp_thread ();\n+  struct gomp_team *team = thr->ts.team;\n+  if (which & (GOMP_CANCEL_LOOP | GOMP_CANCEL_SECTIONS))\n+    {\n+      /* In orphaned worksharing region, all we want to cancel\n+\t is current thread.  */\n+      if (team != NULL)\n+\tteam->work_share_cancelled = 1;\n+      return true;\n+    }\n+  else if (which & GOMP_CANCEL_TASKGROUP)\n+    {\n+      if (thr->task->taskgroup && !thr->task->taskgroup->cancelled)\n+\t{\n+\t  gomp_mutex_lock (&team->task_lock);\n+\t  thr->task->taskgroup->cancelled = true;\n+\t  gomp_mutex_unlock (&team->task_lock);\n+\t}\n+      return true;\n+    }\n+  team->team_cancelled = 1;\n+  gomp_team_barrier_cancel (team);\n+  return true;\n+}\n \f\n /* The public OpenMP API for thread and team related inquiries.  */\n "}, {"sha": "6fb117de0b1610ebf353d2e6f0c61204c4c54ab5", "filename": "libgomp/sections.c", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Fsections.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Fsections.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fsections.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -139,11 +139,27 @@ GOMP_parallel_sections_start (void (*fn) (void *), void *data,\n   num_threads = gomp_resolve_num_threads (num_threads, count);\n   team = gomp_new_team (num_threads);\n   gomp_sections_init (&team->work_shares[0], count);\n-  gomp_team_start (fn, data, num_threads, team);\n+  gomp_team_start (fn, data, num_threads, 0, team);\n+}\n+\n+ialias_redirect (GOMP_parallel_end)\n+\n+void\n+GOMP_parallel_sections (void (*fn) (void *), void *data,\n+\t\t\tunsigned num_threads, unsigned count, unsigned flags)\n+{\n+  struct gomp_team *team;\n+\n+  num_threads = gomp_resolve_num_threads (num_threads, count);\n+  team = gomp_new_team (num_threads);\n+  gomp_sections_init (&team->work_shares[0], count);\n+  gomp_team_start (fn, data, num_threads, flags, team);\n+  fn (data);\n+  GOMP_parallel_end ();\n }\n \n /* The GOMP_section_end* routines are called after the thread is told\n-   that all sections are complete.  This first version synchronizes\n+   that all sections are complete.  The first two versions synchronize\n    all threads; the nowait version does not.  */\n \n void\n@@ -152,6 +168,12 @@ GOMP_sections_end (void)\n   gomp_work_share_end ();\n }\n \n+bool\n+GOMP_sections_end_cancel (void)\n+{\n+  return gomp_work_share_end_cancel ();\n+}\n+\n void\n GOMP_sections_end_nowait (void)\n {"}, {"sha": "2e9865f2ae3e6a85fff66d2691e53f0a21b6abd8", "filename": "libgomp/target.c", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftarget.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftarget.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftarget.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -0,0 +1,96 @@\n+/* Copyright (C) 2013 Free Software Foundation, Inc.\n+   Contributed by Jakub Jelinek <jakub@redhat.com>.\n+\n+   This file is part of the GNU OpenMP Library (libgomp).\n+\n+   Libgomp is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n+   more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* This file handles the maintainence of threads in response to team\n+   creation and termination.  */\n+\n+#include \"libgomp.h\"\n+#include <limits.h>\n+#include <stdbool.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+attribute_hidden int\n+gomp_get_num_devices (void)\n+{\n+  return 0;\n+}\n+\n+/* Called when encountering a target directive.  If DEVICE\n+   is -1, it means use device-var ICV.  If it is -2 (or any other value\n+   larger than last available hw device, use host fallback.\n+   FN is address of host code, OPENMP_TARGET contains value of the\n+   __OPENMP_TARGET__ symbol in the shared library or binary that invokes\n+   GOMP_target.  HOSTADDRS, SIZES and KINDS are arrays\n+   with MAPNUM entries, with addresses of the host objects,\n+   sizes of the host objects (resp. for pointer kind pointer bias\n+   and assumed sizeof (void *) size) and kinds.  */\n+\n+void\n+GOMP_target (int device, void (*fn) (void *), const void *openmp_target,\n+\t     size_t mapnum, void **hostaddrs, size_t *sizes,\n+\t     unsigned char *kinds)\n+{\n+  /* Host fallback.  */\n+  struct gomp_thread old_thr, *thr = gomp_thread ();\n+  old_thr = *thr;\n+  memset (thr, '\\0', sizeof (*thr));\n+  if (gomp_places_list)\n+    {\n+      thr->place = old_thr.place;\n+      thr->ts.place_partition_len = gomp_places_list_len;\n+    }\n+  fn (hostaddrs);\n+  gomp_free_thread (thr);\n+  *thr = old_thr;\n+}\n+\n+void\n+GOMP_target_data (int device, const void *openmp_target, size_t mapnum,\n+\t\t  void **hostaddrs, size_t *sizes, unsigned char *kinds)\n+{\n+}\n+\n+void\n+GOMP_target_end_data (void)\n+{\n+}\n+\n+void\n+GOMP_target_update (int device, const void *openmp_target, size_t mapnum,\n+\t\t    void **hostaddrs, size_t *sizes, unsigned char *kinds)\n+{\n+}\n+\n+void\n+GOMP_teams (unsigned int num_teams, unsigned int thread_limit)\n+{\n+  if (thread_limit)\n+    {\n+      struct gomp_task_icv *icv = gomp_icv (true);\n+      icv->thread_limit_var\n+\t= thread_limit > INT_MAX ? UINT_MAX : thread_limit;\n+    }\n+  (void) num_teams;\n+}"}, {"sha": "a3d343fe1261c1a71819978992a9edf12733d66e", "filename": "libgomp/task.c", "status": "modified", "additions": 655, "deletions": 64, "changes": 719, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftask.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftask.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftask.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -29,6 +29,33 @@\n #include <stdlib.h>\n #include <string.h>\n \n+typedef struct gomp_task_depend_entry *hash_entry_type;\n+\n+static inline void *\n+htab_alloc (size_t size)\n+{\n+  return gomp_malloc (size);\n+}\n+\n+static inline void\n+htab_free (void *ptr)\n+{\n+  free (ptr);\n+}\n+\n+#include \"hashtab.h\"\n+\n+static inline hashval_t\n+htab_hash (hash_entry_type element)\n+{\n+  return hash_pointer (element->addr);\n+}\n+\n+static inline bool\n+htab_eq (hash_entry_type x, hash_entry_type y)\n+{\n+  return x->addr == y->addr;\n+}\n \n /* Create a new task data structure.  */\n \n@@ -42,7 +69,12 @@ gomp_init_task (struct gomp_task *task, struct gomp_task *parent_task,\n   task->in_taskwait = false;\n   task->in_tied_task = false;\n   task->final_task = false;\n+  task->copy_ctors_done = false;\n   task->children = NULL;\n+  task->taskgroup = NULL;\n+  task->dependers = NULL;\n+  task->depend_hash = NULL;\n+  task->depend_count = 0;\n   gomp_sem_init (&task->taskwait_sem, 0);\n }\n \n@@ -78,7 +110,8 @@ gomp_clear_parent (struct gomp_task *children)\n \n void\n GOMP_task (void (*fn) (void *), void *data, void (*cpyfn) (void *, void *),\n-\t   long arg_size, long arg_align, bool if_clause, unsigned flags)\n+\t   long arg_size, long arg_align, bool if_clause, unsigned flags,\n+\t   void **depend)\n {\n   struct gomp_thread *thr = gomp_thread ();\n   struct gomp_team *team = thr->ts.team;\n@@ -94,17 +127,58 @@ GOMP_task (void (*fn) (void *), void *data, void (*cpyfn) (void *, void *),\n     flags &= ~1;\n #endif\n \n+  /* If parallel or taskgroup has been cancelled, don't start new tasks.  */\n+  if (team\n+      && (gomp_team_barrier_cancelled (&team->barrier)\n+\t  || (thr->task->taskgroup && thr->task->taskgroup->cancelled)))\n+    return;\n+\n   if (!if_clause || team == NULL\n       || (thr->task && thr->task->final_task)\n       || team->task_count > 64 * team->nthreads)\n     {\n       struct gomp_task task;\n \n+      /* If there are depend clauses and earlier deferred sibling tasks\n+\t with depend clauses, check if there isn't a dependency.  If there\n+\t is, fall through to the deferred task handling, as we can't\n+\t schedule such tasks right away.  There is no need to handle\n+\t depend clauses for non-deferred tasks other than this, because\n+\t the parent task is suspended until the child task finishes and thus\n+\t it can't start further child tasks.  */\n+      if ((flags & 8) && thr->task && thr->task->depend_hash)\n+\t{\n+\t  struct gomp_task *parent = thr->task;\n+\t  struct gomp_task_depend_entry elem, *ent = NULL;\n+\t  size_t ndepend = (uintptr_t) depend[0];\n+\t  size_t nout = (uintptr_t) depend[1];\n+\t  size_t i;\n+\t  gomp_mutex_lock (&team->task_lock);\n+\t  for (i = 0; i < ndepend; i++)\n+\t    {\n+\t      elem.addr = depend[i + 2];\n+\t      ent = htab_find (parent->depend_hash, &elem);\n+\t      for (; ent; ent = ent->next)\n+\t\tif (i >= nout && ent->is_in)\n+\t\t  continue;\n+\t\telse\n+\t\t  break;\n+\t      if (ent)\n+\t\tbreak;\n+\t    }\n+\t  gomp_mutex_unlock (&team->task_lock);\n+\t  if (ent)\n+\t    goto defer;\n+\t}\n+\n       gomp_init_task (&task, thr->task, gomp_icv (false));\n       task.kind = GOMP_TASK_IFFALSE;\n       task.final_task = (thr->task && thr->task->final_task) || (flags & 2);\n       if (thr->task)\n-\ttask.in_tied_task = thr->task->in_tied_task;\n+\t{\n+\t  task.in_tied_task = thr->task->in_tied_task;\n+\t  task.taskgroup = thr->task->taskgroup;\n+\t}\n       thr->task = &task;\n       if (__builtin_expect (cpyfn != NULL, 0))\n \t{\n@@ -135,29 +209,161 @@ GOMP_task (void (*fn) (void *), void *data, void (*cpyfn) (void *, void *),\n     }\n   else\n     {\n+     defer:;\n       struct gomp_task *task;\n       struct gomp_task *parent = thr->task;\n+      struct gomp_taskgroup *taskgroup = parent->taskgroup;\n       char *arg;\n       bool do_wake;\n-\n-      task = gomp_malloc (sizeof (*task) + arg_size + arg_align - 1);\n-      arg = (char *) (((uintptr_t) (task + 1) + arg_align - 1)\n+      size_t depend_size = 0;\n+\n+      if (flags & 8)\n+\tdepend_size = ((uintptr_t) depend[0]\n+\t\t       * sizeof (struct gomp_task_depend_entry));\n+      task = gomp_malloc (sizeof (*task) + depend_size\n+\t\t\t  + arg_size + arg_align - 1);\n+      arg = (char *) (((uintptr_t) (task + 1) + depend_size + arg_align - 1)\n \t\t      & ~(uintptr_t) (arg_align - 1));\n       gomp_init_task (task, parent, gomp_icv (false));\n       task->kind = GOMP_TASK_IFFALSE;\n       task->in_tied_task = parent->in_tied_task;\n+      task->taskgroup = taskgroup;\n       thr->task = task;\n       if (cpyfn)\n-\tcpyfn (arg, data);\n+\t{\n+\t  cpyfn (arg, data);\n+\t  task->copy_ctors_done = true;\n+\t}\n       else\n \tmemcpy (arg, data, arg_size);\n       thr->task = parent;\n       task->kind = GOMP_TASK_WAITING;\n       task->fn = fn;\n       task->fn_data = arg;\n-      task->in_tied_task = true;\n       task->final_task = (flags & 2) >> 1;\n       gomp_mutex_lock (&team->task_lock);\n+      /* If parallel or taskgroup has been cancelled, don't start new\n+\t tasks.  */\n+      if (__builtin_expect ((gomp_team_barrier_cancelled (&team->barrier)\n+\t\t\t     || (taskgroup && taskgroup->cancelled))\n+\t\t\t    && !task->copy_ctors_done, 0))\n+\t{\n+\t  gomp_mutex_unlock (&team->task_lock);\n+\t  gomp_finish_task (task);\n+\t  free (task);\n+\t  return;\n+\t}\n+      if (taskgroup)\n+\ttaskgroup->num_children++;\n+      if (depend_size)\n+\t{\n+\t  size_t ndepend = (uintptr_t) depend[0];\n+\t  size_t nout = (uintptr_t) depend[1];\n+\t  size_t i;\n+\t  hash_entry_type ent;\n+\n+\t  task->depend_count = ndepend;\n+\t  task->num_dependees = 0;\n+\t  if (parent->depend_hash == NULL)\n+\t    parent->depend_hash\n+\t      = htab_create (2 * ndepend > 12 ? 2 * ndepend : 12);\n+\t  for (i = 0; i < ndepend; i++)\n+\t    {\n+\t      task->depend[i].addr = depend[2 + i];\n+\t      task->depend[i].next = NULL;\n+\t      task->depend[i].prev = NULL;\n+\t      task->depend[i].task = task;\n+\t      task->depend[i].is_in = i >= nout;\n+\t      task->depend[i].redundant = false;\n+\n+\t      hash_entry_type *slot\n+\t\t= htab_find_slot (&parent->depend_hash, &task->depend[i],\n+\t\t\t\t  INSERT);\n+\t      hash_entry_type out = NULL;\n+\t      if (*slot)\n+\t\t{\n+\t\t  /* If multiple depends on the same task are the\n+\t\t     same, all but the first one are redundant.\n+\t\t     As inout/out come first, if any of them is\n+\t\t     inout/out, it will win, which is the right\n+\t\t     semantics.  */\n+\t\t  if ((*slot)->task == task)\n+\t\t    {\n+\t\t      task->depend[i].redundant = true;\n+\t\t      continue;\n+\t\t    }\n+\t\t  for (ent = *slot; ent; ent = ent->next)\n+\t\t    {\n+\t\t      /* depend(in:...) doesn't depend on earlier\n+\t\t\t depend(in:...).  */\n+\t\t      if (i >= nout && ent->is_in)\n+\t\t\tcontinue;\n+\n+\t\t      if (!ent->is_in)\n+\t\t\tout = ent;\n+\n+\t\t      struct gomp_task *tsk = ent->task;\n+\t\t      if (tsk->dependers == NULL)\n+\t\t\t{\n+\t\t\t  tsk->dependers\n+\t\t\t    = gomp_malloc (sizeof (struct gomp_dependers_vec)\n+\t\t\t\t\t   + 6 * sizeof (struct gomp_task *));\n+\t\t\t  tsk->dependers->n_elem = 1;\n+\t\t\t  tsk->dependers->allocated = 6;\n+\t\t\t  tsk->dependers->elem[0] = task;\n+\t\t\t  task->num_dependees++;\n+\t\t\t  continue;\n+\t\t\t}\n+\t\t      /* We already have some other dependency on tsk\n+\t\t\t from earlier depend clause.  */\n+\t\t      else if (tsk->dependers->n_elem\n+\t\t\t       && (tsk->dependers->elem[tsk->dependers->n_elem\n+\t\t\t\t\t\t\t- 1]\n+\t\t\t\t   == task))\n+\t\t\tcontinue;\n+\t\t      else if (tsk->dependers->n_elem\n+\t\t\t       == tsk->dependers->allocated)\n+\t\t\t{\n+\t\t\t  tsk->dependers->allocated\n+\t\t\t    = tsk->dependers->allocated * 2 + 2;\n+\t\t\t  tsk->dependers\n+\t\t\t    = gomp_realloc (tsk->dependers,\n+\t\t\t\t\t    sizeof (struct gomp_dependers_vec)\n+\t\t\t\t\t    + (tsk->dependers->allocated\n+\t\t\t\t\t       * sizeof (struct gomp_task *)));\n+\t\t\t}\n+\t\t      tsk->dependers->elem[tsk->dependers->n_elem++] = task;\n+\t\t      task->num_dependees++;\n+\t\t    }\n+\t\t  task->depend[i].next = *slot;\n+\t\t  (*slot)->prev = &task->depend[i];\n+\t\t}\n+\t      *slot = &task->depend[i];\n+\n+\t      /* There is no need to store more than one depend({,in}out:)\n+\t\t task per address in the hash table chain, because each out\n+\t\t depends on all earlier outs, thus it is enough to record\n+\t\t just the last depend({,in}out:).  For depend(in:), we need\n+\t\t to keep all of the previous ones not terminated yet, because\n+\t\t a later depend({,in}out:) might need to depend on all of\n+\t\t them.  So, if the new task's clause is depend({,in}out:),\n+\t\t we know there is at most one other depend({,in}out:) clause\n+\t\t in the list (out) and to maintain the invariant we now\n+\t\t need to remove it from the list.  */\n+\t      if (!task->depend[i].is_in && out)\n+\t\t{\n+\t\t  if (out->next)\n+\t\t    out->next->prev = out->prev;\n+\t\t  out->prev->next = out->next;\n+\t\t  out->redundant = true;\n+\t\t}\n+\t    }\n+\t  if (task->num_dependees)\n+\t    {\n+\t      gomp_mutex_unlock (&team->task_lock);\n+\t      return;\n+\t    }\n+\t}\n       if (parent->children)\n \t{\n \t  task->next_child = parent->children;\n@@ -171,6 +377,22 @@ GOMP_task (void (*fn) (void *), void *data, void (*cpyfn) (void *, void *),\n \t  task->prev_child = task;\n \t}\n       parent->children = task;\n+      if (taskgroup)\n+\t{\n+\t  if (taskgroup->children)\n+\t    {\n+\t      task->next_taskgroup = taskgroup->children;\n+\t      task->prev_taskgroup = taskgroup->children->prev_taskgroup;\n+\t      task->next_taskgroup->prev_taskgroup = task;\n+\t      task->prev_taskgroup->next_taskgroup = task;\n+\t    }\n+\t  else\n+\t    {\n+\t      task->next_taskgroup = task;\n+\t      task->prev_taskgroup = task;\n+\t    }\n+\t  taskgroup->children = task;\n+\t}\n       if (team->task_queue)\n \t{\n \t  task->next_queue = team->task_queue;\n@@ -185,6 +407,7 @@ GOMP_task (void (*fn) (void *), void *data, void (*cpyfn) (void *, void *),\n \t  team->task_queue = task;\n \t}\n       ++team->task_count;\n+      ++team->task_queued_count;\n       gomp_team_barrier_set_task_pending (&team->barrier);\n       do_wake = team->task_running_count + !parent->in_tied_task\n \t\t< team->nthreads;\n@@ -194,6 +417,220 @@ GOMP_task (void (*fn) (void *), void *data, void (*cpyfn) (void *, void *),\n     }\n }\n \n+static inline bool\n+gomp_task_run_pre (struct gomp_task *child_task, struct gomp_task *parent,\n+\t\t   struct gomp_taskgroup *taskgroup, struct gomp_team *team)\n+{\n+  if (parent && parent->children == child_task)\n+    parent->children = child_task->next_child;\n+  if (taskgroup && taskgroup->children == child_task)\n+    taskgroup->children = child_task->next_taskgroup;\n+  child_task->prev_queue->next_queue = child_task->next_queue;\n+  child_task->next_queue->prev_queue = child_task->prev_queue;\n+  if (team->task_queue == child_task)\n+    {\n+      if (child_task->next_queue != child_task)\n+\tteam->task_queue = child_task->next_queue;\n+      else\n+\tteam->task_queue = NULL;\n+    }\n+  child_task->kind = GOMP_TASK_TIED;\n+  if (--team->task_queued_count == 0)\n+    gomp_team_barrier_clear_task_pending (&team->barrier);\n+  if ((gomp_team_barrier_cancelled (&team->barrier)\n+       || (taskgroup && taskgroup->cancelled))\n+      && !child_task->copy_ctors_done)\n+    return true;\n+  return false;\n+}\n+\n+static void\n+gomp_task_run_post_handle_depend_hash (struct gomp_task *child_task)\n+{\n+  struct gomp_task *parent = child_task->parent;\n+  size_t i;\n+\n+  for (i = 0; i < child_task->depend_count; i++)\n+    if (!child_task->depend[i].redundant)\n+      {\n+\tif (child_task->depend[i].next)\n+\t  child_task->depend[i].next->prev = child_task->depend[i].prev;\n+\tif (child_task->depend[i].prev)\n+\t  child_task->depend[i].prev->next = child_task->depend[i].next;\n+\telse\n+\t  {\n+\t    hash_entry_type *slot\n+\t      = htab_find_slot (&parent->depend_hash, &child_task->depend[i],\n+\t\t\t\tNO_INSERT);\n+\t    if (*slot != &child_task->depend[i])\n+\t      abort ();\n+\t    if (child_task->depend[i].next)\n+\t      *slot = child_task->depend[i].next;\n+\t    else\n+\t      htab_clear_slot (parent->depend_hash, slot);\n+\t  }\n+      }\n+}\n+\n+static size_t\n+gomp_task_run_post_handle_dependers (struct gomp_task *child_task,\n+\t\t\t\t     struct gomp_team *team)\n+{\n+  struct gomp_task *parent = child_task->parent;\n+  size_t i, count = child_task->dependers->n_elem, ret = 0;\n+  for (i = 0; i < count; i++)\n+    {\n+      struct gomp_task *task = child_task->dependers->elem[i];\n+      if (--task->num_dependees != 0)\n+\tcontinue;\n+\n+      struct gomp_taskgroup *taskgroup = task->taskgroup;\n+      if (parent)\n+\t{\n+\t  if (parent->children)\n+\t    {\n+\t      task->next_child = parent->children;\n+\t      task->prev_child = parent->children->prev_child;\n+\t      task->next_child->prev_child = task;\n+\t      task->prev_child->next_child = task;\n+\t    }\n+\t  else\n+\t    {\n+\t      task->next_child = task;\n+\t      task->prev_child = task;\n+\t    }\n+\t  parent->children = task;\n+\t  if (parent->in_taskwait)\n+\t    {\n+\t      parent->in_taskwait = false;\n+\t      gomp_sem_post (&parent->taskwait_sem);\n+\t    }\n+\t}\n+      if (taskgroup)\n+\t{\n+\t  if (taskgroup->children)\n+\t    {\n+\t      task->next_taskgroup = taskgroup->children;\n+\t      task->prev_taskgroup = taskgroup->children->prev_taskgroup;\n+\t      task->next_taskgroup->prev_taskgroup = task;\n+\t      task->prev_taskgroup->next_taskgroup = task;\n+\t    }\n+\t  else\n+\t    {\n+\t      task->next_taskgroup = task;\n+\t      task->prev_taskgroup = task;\n+\t    }\n+\t  taskgroup->children = task;\n+\t  if (taskgroup->in_taskgroup_wait)\n+\t    {\n+\t      taskgroup->in_taskgroup_wait = false;\n+\t      gomp_sem_post (&taskgroup->taskgroup_sem);\n+\t    }\n+\t}\n+      if (team->task_queue)\n+\t{\n+\t  task->next_queue = team->task_queue;\n+\t  task->prev_queue = team->task_queue->prev_queue;\n+\t  task->next_queue->prev_queue = task;\n+\t  task->prev_queue->next_queue = task;\n+\t}\n+      else\n+\t{\n+\t  task->next_queue = task;\n+\t  task->prev_queue = task;\n+\t  team->task_queue = task;\n+\t}\n+      ++team->task_count;\n+      ++team->task_queued_count;\n+      ++ret;\n+    }\n+  free (child_task->dependers);\n+  child_task->dependers = NULL;\n+  if (ret > 1)\n+    gomp_team_barrier_set_task_pending (&team->barrier);\n+  return ret;\n+}\n+\n+static inline size_t\n+gomp_task_run_post_handle_depend (struct gomp_task *child_task,\n+\t\t\t\t  struct gomp_team *team)\n+{\n+  if (child_task->depend_count == 0)\n+    return 0;\n+\n+  /* If parent is gone already, the hash table is freed and nothing\n+     will use the hash table anymore, no need to remove anything from it.  */\n+  if (child_task->parent != NULL)\n+    gomp_task_run_post_handle_depend_hash (child_task);\n+\n+  if (child_task->dependers == NULL)\n+    return 0;\n+\n+  return gomp_task_run_post_handle_dependers (child_task, team);\n+}\n+\n+static inline void\n+gomp_task_run_post_remove_parent (struct gomp_task *child_task)\n+{\n+  struct gomp_task *parent = child_task->parent;\n+  if (parent == NULL)\n+    return;\n+  child_task->prev_child->next_child = child_task->next_child;\n+  child_task->next_child->prev_child = child_task->prev_child;\n+  if (parent->children != child_task)\n+    return;\n+  if (child_task->next_child != child_task)\n+    parent->children = child_task->next_child;\n+  else\n+    {\n+      /* We access task->children in GOMP_taskwait\n+\t outside of the task lock mutex region, so\n+\t need a release barrier here to ensure memory\n+\t written by child_task->fn above is flushed\n+\t before the NULL is written.  */\n+      __atomic_store_n (&parent->children, NULL, MEMMODEL_RELEASE);\n+      if (parent->in_taskwait)\n+\t{\n+\t  parent->in_taskwait = false;\n+\t  gomp_sem_post (&parent->taskwait_sem);\n+\t}\n+    }\n+}\n+\n+static inline void\n+gomp_task_run_post_remove_taskgroup (struct gomp_task *child_task)\n+{\n+  struct gomp_taskgroup *taskgroup = child_task->taskgroup;\n+  if (taskgroup == NULL)\n+    return;\n+  child_task->prev_taskgroup->next_taskgroup = child_task->next_taskgroup;\n+  child_task->next_taskgroup->prev_taskgroup = child_task->prev_taskgroup;\n+  if (taskgroup->num_children > 1)\n+    --taskgroup->num_children;\n+  else\n+    {\n+      /* We access taskgroup->num_children in GOMP_taskgroup_end\n+\t outside of the task lock mutex region, so\n+\t need a release barrier here to ensure memory\n+\t written by child_task->fn above is flushed\n+\t before the NULL is written.  */\n+      __atomic_store_n (&taskgroup->num_children, 0, MEMMODEL_RELEASE);\n+    }\n+  if (taskgroup->children != child_task)\n+    return;\n+  if (child_task->next_taskgroup != child_task)\n+    taskgroup->children = child_task->next_taskgroup;\n+  else\n+    {\n+      taskgroup->children = NULL;\n+      if (taskgroup->in_taskgroup_wait)\n+\t{\n+\t  taskgroup->in_taskgroup_wait = false;\n+\t  gomp_sem_post (&taskgroup->taskgroup_sem);\n+\t}\n+    }\n+}\n+\n void\n gomp_barrier_handle_tasks (gomp_barrier_state_t state)\n {\n@@ -202,6 +639,7 @@ gomp_barrier_handle_tasks (gomp_barrier_state_t state)\n   struct gomp_task *task = thr->task;\n   struct gomp_task *child_task = NULL;\n   struct gomp_task *to_free = NULL;\n+  int do_wake = 0;\n \n   gomp_mutex_lock (&team->task_lock);\n   if (gomp_barrier_last_thread (state))\n@@ -218,26 +656,31 @@ gomp_barrier_handle_tasks (gomp_barrier_state_t state)\n \n   while (1)\n     {\n+      bool cancelled = false;\n       if (team->task_queue != NULL)\n \t{\n-\t  struct gomp_task *parent;\n-\n \t  child_task = team->task_queue;\n-\t  parent = child_task->parent;\n-\t  if (parent && parent->children == child_task)\n-\t    parent->children = child_task->next_child;\n-\t  child_task->prev_queue->next_queue = child_task->next_queue;\n-\t  child_task->next_queue->prev_queue = child_task->prev_queue;\n-\t  if (child_task->next_queue != child_task)\n-\t    team->task_queue = child_task->next_queue;\n-\t  else\n-\t    team->task_queue = NULL;\n-\t  child_task->kind = GOMP_TASK_TIED;\n+\t  cancelled = gomp_task_run_pre (child_task, child_task->parent,\n+\t\t\t\t\t child_task->taskgroup, team);\n+\t  if (__builtin_expect (cancelled, 0))\n+\t    {\n+\t      if (to_free)\n+\t\t{\n+\t\t  gomp_finish_task (to_free);\n+\t\t  free (to_free);\n+\t\t  to_free = NULL;\n+\t\t}\n+\t      goto finish_cancelled;\n+\t    }\n \t  team->task_running_count++;\n-\t  if (team->task_count == team->task_running_count)\n-\t    gomp_team_barrier_clear_task_pending (&team->barrier);\n+\t  child_task->in_tied_task = true;\n \t}\n       gomp_mutex_unlock (&team->task_lock);\n+      if (do_wake)\n+\t{\n+\t  gomp_team_barrier_wake (&team->barrier, do_wake);\n+\t  do_wake = 0;\n+\t}\n       if (to_free)\n \t{\n \t  gomp_finish_task (to_free);\n@@ -255,33 +698,22 @@ gomp_barrier_handle_tasks (gomp_barrier_state_t state)\n       gomp_mutex_lock (&team->task_lock);\n       if (child_task)\n \t{\n-\t  struct gomp_task *parent = child_task->parent;\n-\t  if (parent)\n-\t    {\n-\t      child_task->prev_child->next_child = child_task->next_child;\n-\t      child_task->next_child->prev_child = child_task->prev_child;\n-\t      if (parent->children == child_task)\n-\t\t{\n-\t\t  if (child_task->next_child != child_task)\n-\t\t    parent->children = child_task->next_child;\n-\t\t  else\n-\t\t    {\n-\t\t      /* We access task->children in GOMP_taskwait\n-\t\t\t outside of the task lock mutex region, so\n-\t\t\t need a release barrier here to ensure memory\n-\t\t\t written by child_task->fn above is flushed\n-\t\t\t before the NULL is written.  */\n-\t\t      __atomic_store_n (&parent->children, NULL,\n-\t\t\t\t\tMEMMODEL_RELEASE);\n-\t\t      if (parent->in_taskwait)\n-\t\t\tgomp_sem_post (&parent->taskwait_sem);\n-\t\t    }\n-\t\t}\n-\t    }\n+\t finish_cancelled:;\n+\t  size_t new_tasks\n+\t    = gomp_task_run_post_handle_depend (child_task, team);\n+\t  gomp_task_run_post_remove_parent (child_task);\n \t  gomp_clear_parent (child_task->children);\n+\t  gomp_task_run_post_remove_taskgroup (child_task);\n \t  to_free = child_task;\n \t  child_task = NULL;\n-\t  team->task_running_count--;\n+\t  if (!cancelled)\n+\t    team->task_running_count--;\n+\t  if (new_tasks > 1)\n+\t    {\n+\t      do_wake = team->nthreads - team->task_running_count;\n+\t      if (do_wake > new_tasks)\n+\t\tdo_wake = new_tasks;\n+\t    }\n \t  if (--team->task_count == 0\n \t      && gomp_team_barrier_waiting_for_tasks (&team->barrier))\n \t    {\n@@ -304,9 +736,10 @@ GOMP_taskwait (void)\n   struct gomp_task *task = thr->task;\n   struct gomp_task *child_task = NULL;\n   struct gomp_task *to_free = NULL;\n+  int do_wake = 0;\n \n   /* The acquire barrier on load of task->children here synchronizes\n-     with the write of a NULL in gomp_barrier_handle_tasks.  It is\n+     with the write of a NULL in gomp_task_run_post_remove_parent.  It is\n      not necessary that we synchronize with other non-NULL writes at\n      this point, but we must ensure that all writes to memory by a\n      child thread task work function are seen before we exit from\n@@ -318,6 +751,7 @@ GOMP_taskwait (void)\n   gomp_mutex_lock (&team->task_lock);\n   while (1)\n     {\n+      bool cancelled = false;\n       if (task->children == NULL)\n \t{\n \t  gomp_mutex_unlock (&team->task_lock);\n@@ -331,26 +765,30 @@ GOMP_taskwait (void)\n       if (task->children->kind == GOMP_TASK_WAITING)\n \t{\n \t  child_task = task->children;\n-\t  task->children = child_task->next_child;\n-\t  child_task->prev_queue->next_queue = child_task->next_queue;\n-\t  child_task->next_queue->prev_queue = child_task->prev_queue;\n-\t  if (team->task_queue == child_task)\n+\t  cancelled\n+\t    = gomp_task_run_pre (child_task, task, child_task->taskgroup,\n+\t\t\t\t team);\n+\t  if (__builtin_expect (cancelled, 0))\n \t    {\n-\t      if (child_task->next_queue != child_task)\n-\t\tteam->task_queue = child_task->next_queue;\n-\t      else\n-\t\tteam->task_queue = NULL;\n+\t      if (to_free)\n+\t\t{\n+\t\t  gomp_finish_task (to_free);\n+\t\t  free (to_free);\n+\t\t  to_free = NULL;\n+\t\t}\n+\t      goto finish_cancelled;\n \t    }\n-\t  child_task->kind = GOMP_TASK_TIED;\n-\t  team->task_running_count++;\n-\t  if (team->task_count == team->task_running_count)\n-\t    gomp_team_barrier_clear_task_pending (&team->barrier);\n \t}\n       else\n \t/* All tasks we are waiting for are already running\n \t   in other threads.  Wait for them.  */\n \ttask->in_taskwait = true;\n       gomp_mutex_unlock (&team->task_lock);\n+      if (do_wake)\n+\t{\n+\t  gomp_team_barrier_wake (&team->barrier, do_wake);\n+\t  do_wake = 0;\n+\t}\n       if (to_free)\n \t{\n \t  gomp_finish_task (to_free);\n@@ -364,14 +802,13 @@ GOMP_taskwait (void)\n \t  thr->task = task;\n \t}\n       else\n-\t{\n-\t  gomp_sem_wait (&task->taskwait_sem);\n-\t  task->in_taskwait = false;\n-\t  return;\n-\t}\n+\tgomp_sem_wait (&task->taskwait_sem);\n       gomp_mutex_lock (&team->task_lock);\n       if (child_task)\n \t{\n+\t finish_cancelled:;\n+\t  size_t new_tasks\n+\t    = gomp_task_run_post_handle_depend (child_task, team);\n \t  child_task->prev_child->next_child = child_task->next_child;\n \t  child_task->next_child->prev_child = child_task->prev_child;\n \t  if (task->children == child_task)\n@@ -382,10 +819,17 @@ GOMP_taskwait (void)\n \t\ttask->children = NULL;\n \t    }\n \t  gomp_clear_parent (child_task->children);\n+\t  gomp_task_run_post_remove_taskgroup (child_task);\n \t  to_free = child_task;\n \t  child_task = NULL;\n \t  team->task_count--;\n-\t  team->task_running_count--;\n+\t  if (new_tasks > 1)\n+\t    {\n+\t      do_wake = team->nthreads - team->task_running_count\n+\t\t\t- !task->in_tied_task;\n+\t      if (do_wake > new_tasks)\n+\t\tdo_wake = new_tasks;\n+\t    }\n \t}\n     }\n }\n@@ -398,6 +842,153 @@ GOMP_taskyield (void)\n   /* Nothing at the moment.  */\n }\n \n+void\n+GOMP_taskgroup_start (void)\n+{\n+  struct gomp_thread *thr = gomp_thread ();\n+  struct gomp_team *team = thr->ts.team;\n+  struct gomp_task *task = thr->task;\n+  struct gomp_taskgroup *taskgroup;\n+\n+  /* If team is NULL, all tasks are executed as\n+     GOMP_TASK_IFFALSE tasks and thus all children tasks of\n+     taskgroup and their descendant tasks will be finished\n+     by the time GOMP_taskgroup_end is called.  */\n+  if (team == NULL)\n+    return;\n+  taskgroup = gomp_malloc (sizeof (struct gomp_taskgroup));\n+  taskgroup->prev = task->taskgroup;\n+  taskgroup->children = NULL;\n+  taskgroup->in_taskgroup_wait = false;\n+  taskgroup->cancelled = false;\n+  taskgroup->num_children = 0;\n+  gomp_sem_init (&taskgroup->taskgroup_sem, 0);\n+  task->taskgroup = taskgroup;\n+}\n+\n+void\n+GOMP_taskgroup_end (void)\n+{\n+  struct gomp_thread *thr = gomp_thread ();\n+  struct gomp_team *team = thr->ts.team;\n+  struct gomp_task *task = thr->task;\n+  struct gomp_taskgroup *taskgroup;\n+  struct gomp_task *child_task = NULL;\n+  struct gomp_task *to_free = NULL;\n+  int do_wake = 0;\n+\n+  if (team == NULL)\n+    return;\n+  taskgroup = task->taskgroup;\n+\n+  /* The acquire barrier on load of taskgroup->num_children here\n+     synchronizes with the write of 0 in gomp_task_run_post_remove_taskgroup.\n+     It is not necessary that we synchronize with other non-0 writes at\n+     this point, but we must ensure that all writes to memory by a\n+     child thread task work function are seen before we exit from\n+     GOMP_taskgroup_end.  */\n+  if (__atomic_load_n (&taskgroup->num_children, MEMMODEL_ACQUIRE) == 0)\n+    goto finish;\n+\n+  gomp_mutex_lock (&team->task_lock);\n+  while (1)\n+    {\n+      bool cancelled = false;\n+      if (taskgroup->children == NULL)\n+\t{\n+\t  if (taskgroup->num_children)\n+\t    goto do_wait;\n+\t  gomp_mutex_unlock (&team->task_lock);\n+\t  if (to_free)\n+\t    {\n+\t      gomp_finish_task (to_free);\n+\t      free (to_free);\n+\t    }\n+\t  goto finish;\n+\t}\n+      if (taskgroup->children->kind == GOMP_TASK_WAITING)\n+\t{\n+\t  child_task = taskgroup->children;\n+\t  cancelled\n+\t    = gomp_task_run_pre (child_task, child_task->parent, taskgroup,\n+\t\t\t\t team);\n+\t  if (__builtin_expect (cancelled, 0))\n+\t    {\n+\t      if (to_free)\n+\t\t{\n+\t\t  gomp_finish_task (to_free);\n+\t\t  free (to_free);\n+\t\t  to_free = NULL;\n+\t\t}\n+\t      goto finish_cancelled;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t do_wait:\n+\t  /* All tasks we are waiting for are already running\n+\t     in other threads.  Wait for them.  */\n+\t  taskgroup->in_taskgroup_wait = true;\n+\t}\n+      gomp_mutex_unlock (&team->task_lock);\n+      if (do_wake)\n+\t{\n+\t  gomp_team_barrier_wake (&team->barrier, do_wake);\n+\t  do_wake = 0;\n+\t}\n+      if (to_free)\n+\t{\n+\t  gomp_finish_task (to_free);\n+\t  free (to_free);\n+\t  to_free = NULL;\n+\t}\n+      if (child_task)\n+\t{\n+\t  thr->task = child_task;\n+\t  child_task->fn (child_task->fn_data);\n+\t  thr->task = task;\n+\t}\n+      else\n+\tgomp_sem_wait (&taskgroup->taskgroup_sem);\n+      gomp_mutex_lock (&team->task_lock);\n+      if (child_task)\n+\t{\n+\t finish_cancelled:;\n+\t  size_t new_tasks\n+\t    = gomp_task_run_post_handle_depend (child_task, team);\n+\t  child_task->prev_taskgroup->next_taskgroup\n+\t    = child_task->next_taskgroup;\n+\t  child_task->next_taskgroup->prev_taskgroup\n+\t    = child_task->prev_taskgroup;\n+\t  --taskgroup->num_children;\n+\t  if (taskgroup->children == child_task)\n+\t    {\n+\t      if (child_task->next_taskgroup != child_task)\n+\t\ttaskgroup->children = child_task->next_taskgroup;\n+\t      else\n+\t\ttaskgroup->children = NULL;\n+\t    }\n+\t  gomp_task_run_post_remove_parent (child_task);\n+\t  gomp_clear_parent (child_task->children);\n+\t  to_free = child_task;\n+\t  child_task = NULL;\n+\t  team->task_count--;\n+\t  if (new_tasks > 1)\n+\t    {\n+\t      do_wake = team->nthreads - team->task_running_count\n+\t\t\t- !task->in_tied_task;\n+\t      if (do_wake > new_tasks)\n+\t\tdo_wake = new_tasks;\n+\t    }\n+\t}\n+    }\n+\n+ finish:\n+  task->taskgroup = taskgroup->prev;\n+  gomp_sem_destroy (&taskgroup->taskgroup_sem);\n+  free (taskgroup);\n+}\n+\n int\n omp_in_final (void)\n {"}, {"sha": "f4c47f7cba83aa653d6ae94c0ae6562091571688", "filename": "libgomp/team.c", "status": "modified", "additions": 428, "deletions": 48, "changes": 476, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Fteam.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Fteam.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fteam.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -53,6 +53,7 @@ struct gomp_thread_start_data\n   struct gomp_team_state ts;\n   struct gomp_task *task;\n   struct gomp_thread_pool *thread_pool;\n+  unsigned int place;\n   bool nested;\n };\n \n@@ -84,6 +85,7 @@ gomp_thread_start (void *xdata)\n   thr->thread_pool = data->thread_pool;\n   thr->ts = data->ts;\n   thr->task = data->task;\n+  thr->place = data->place;\n \n   thr->ts.team->ordered_release[thr->ts.team_id] = &thr->release;\n \n@@ -98,7 +100,7 @@ gomp_thread_start (void *xdata)\n       gomp_barrier_wait (&team->barrier);\n \n       local_fn (local_data);\n-      gomp_team_barrier_wait (&team->barrier);\n+      gomp_team_barrier_wait_final (&team->barrier);\n       gomp_finish_task (task);\n       gomp_barrier_wait_last (&team->barrier);\n     }\n@@ -113,7 +115,7 @@ gomp_thread_start (void *xdata)\n \t  struct gomp_task *task = thr->task;\n \n \t  local_fn (local_data);\n-\t  gomp_team_barrier_wait (&team->barrier);\n+\t  gomp_team_barrier_wait_final (&team->barrier);\n \t  gomp_finish_task (task);\n \n \t  gomp_barrier_wait (&pool->threads_dock);\n@@ -126,6 +128,8 @@ gomp_thread_start (void *xdata)\n     }\n \n   gomp_sem_destroy (&thr->release);\n+  thr->thread_pool = NULL;\n+  thr->task = NULL;\n   return NULL;\n }\n \n@@ -149,6 +153,7 @@ gomp_new_team (unsigned nthreads)\n #else\n   gomp_mutex_init (&team->work_share_list_free_lock);\n #endif\n+  team->work_shares_to_free = &team->work_shares[0];\n   gomp_init_work_share (&team->work_shares[0], false, nthreads);\n   team->work_shares[0].next_alloc = NULL;\n   team->work_share_list_free = NULL;\n@@ -167,7 +172,10 @@ gomp_new_team (unsigned nthreads)\n   gomp_mutex_init (&team->task_lock);\n   team->task_queue = NULL;\n   team->task_count = 0;\n+  team->task_queued_count = 0;\n   team->task_running_count = 0;\n+  team->work_share_cancelled = 0;\n+  team->team_cancelled = 0;\n \n   return team;\n }\n@@ -199,16 +207,19 @@ static struct gomp_thread_pool *gomp_new_thread_pool (void)\n static void\n gomp_free_pool_helper (void *thread_pool)\n {\n+  struct gomp_thread *thr = gomp_thread ();\n   struct gomp_thread_pool *pool\n     = (struct gomp_thread_pool *) thread_pool;\n   gomp_barrier_wait_last (&pool->threads_dock);\n-  gomp_sem_destroy (&gomp_thread ()->release);\n+  gomp_sem_destroy (&thr->release);\n+  thr->thread_pool = NULL;\n+  thr->task = NULL;\n   pthread_exit (NULL);\n }\n \n /* Free a thread pool and release its threads. */\n \n-static void\n+void\n gomp_free_thread (void *arg __attribute__((unused)))\n {\n   struct gomp_thread *thr = gomp_thread ();\n@@ -236,9 +247,9 @@ gomp_free_thread (void *arg __attribute__((unused)))\n \t  __sync_fetch_and_add (&gomp_managed_threads,\n \t\t\t\t1L - pool->threads_used);\n #else\n-\t  gomp_mutex_lock (&gomp_remaining_threads_lock);\n+\t  gomp_mutex_lock (&gomp_managed_threads_lock);\n \t  gomp_managed_threads -= pool->threads_used - 1L;\n-\t  gomp_mutex_unlock (&gomp_remaining_threads_lock);\n+\t  gomp_mutex_unlock (&gomp_managed_threads_lock);\n #endif\n \t}\n       free (pool->threads);\n@@ -259,7 +270,7 @@ gomp_free_thread (void *arg __attribute__((unused)))\n \n void\n gomp_team_start (void (*fn) (void *), void *data, unsigned nthreads,\n-\t\t struct gomp_team *team)\n+\t\t unsigned flags, struct gomp_team *team)\n {\n   struct gomp_thread_start_data *start_data;\n   struct gomp_thread *thr, *nthr;\n@@ -270,17 +281,24 @@ gomp_team_start (void (*fn) (void *), void *data, unsigned nthreads,\n   unsigned i, n, old_threads_used = 0;\n   pthread_attr_t thread_attr, *attr;\n   unsigned long nthreads_var;\n+  char bind, bind_var;\n+  unsigned int s = 0, rest = 0, p = 0, k = 0;\n+  unsigned int affinity_count = 0;\n+  struct gomp_thread **affinity_thr = NULL;\n \n   thr = gomp_thread ();\n   nested = thr->ts.team != NULL;\n   if (__builtin_expect (thr->thread_pool == NULL, 0))\n     {\n       thr->thread_pool = gomp_new_thread_pool ();\n+      thr->thread_pool->threads_busy = nthreads;\n       pthread_setspecific (gomp_thread_destructor, thr);\n     }\n   pool = thr->thread_pool;\n   task = thr->task;\n   icv = task ? &task->icv : &gomp_global_icv;\n+  if (__builtin_expect (gomp_places_list != NULL, 0) && thr->place == 0)\n+    gomp_init_affinity ();\n \n   /* Always save the previous state, even if this isn't a nested team.\n      In particular, we should save any work share state from an outer\n@@ -303,14 +321,95 @@ gomp_team_start (void (*fn) (void *), void *data, unsigned nthreads,\n   if (__builtin_expect (gomp_nthreads_var_list != NULL, 0)\n       && thr->ts.level < gomp_nthreads_var_list_len)\n     nthreads_var = gomp_nthreads_var_list[thr->ts.level];\n+  bind_var = icv->bind_var;\n+  if (bind_var != omp_proc_bind_false && (flags & 7) != omp_proc_bind_false)\n+    bind_var = flags & 7;\n+  bind = bind_var;\n+  if (__builtin_expect (gomp_bind_var_list != NULL, 0)\n+      && thr->ts.level < gomp_bind_var_list_len)\n+    bind_var = gomp_bind_var_list[thr->ts.level];\n   gomp_init_task (thr->task, task, icv);\n   team->implicit_task[0].icv.nthreads_var = nthreads_var;\n+  team->implicit_task[0].icv.bind_var = bind_var;\n \n   if (nthreads == 1)\n     return;\n \n   i = 1;\n \n+  if (__builtin_expect (gomp_places_list != NULL, 0))\n+    {\n+      if (bind == omp_proc_bind_false)\n+\tbind = omp_proc_bind_true;\n+      /* Depending on chosen proc_bind model, set subpartition\n+\t for the master thread and initialize helper variables\n+\t P and optionally S, K and/or REST used by later place\n+\t computation for each additional thread.  */\n+      p = thr->place - 1;\n+      switch (bind)\n+\t{\n+\tcase omp_proc_bind_false:\n+\t  bind = omp_proc_bind_true;\n+\t  /* FALLTHRU */\n+\tcase omp_proc_bind_true:\n+\tcase omp_proc_bind_close:\n+\t  if (nthreads > thr->ts.place_partition_len)\n+\t    {\n+\t      /* T > P.  S threads will be placed in each place,\n+\t\t and the final REM threads placed one by one\n+\t\t into the already occupied places.  */\n+\t      s = nthreads / thr->ts.place_partition_len;\n+\t      rest = nthreads % thr->ts.place_partition_len;\n+\t    }\n+\t  else\n+\t    s = 1;\n+\t  k = 1;\n+\t  break;\n+\tcase omp_proc_bind_master:\n+\t  /* Each thread will be bound to master's place.  */\n+\t  break;\n+\tcase omp_proc_bind_spread:\n+\t  if (nthreads <= thr->ts.place_partition_len)\n+\t    {\n+\t      /* T <= P.  Each subpartition will have in between s\n+\t\t and s+1 places (subpartitions starting at or\n+\t\t after rest will have s places, earlier s+1 places),\n+\t\t each thread will be bound to the first place in\n+\t\t its subpartition (except for the master thread\n+\t\t that can be bound to another place in its\n+\t\t subpartition).  */\n+\t      s = thr->ts.place_partition_len / nthreads;\n+\t      rest = thr->ts.place_partition_len % nthreads;\n+\t      rest = (s + 1) * rest + thr->ts.place_partition_off;\n+\t      if (p < rest)\n+\t\t{\n+\t\t  p -= (p - thr->ts.place_partition_off) % (s + 1);\n+\t\t  thr->ts.place_partition_len = s + 1;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  p -= (p - rest) % s;\n+\t\t  thr->ts.place_partition_len = s;\n+\t\t}\n+\t      thr->ts.place_partition_off = p;\n+\t    }\n+\t  else\n+\t    {\n+\t      /* T > P.  Each subpartition will have just a single\n+\t\t place and we'll place between s and s+1\n+\t\t threads into each subpartition.  */\n+\t      s = nthreads / thr->ts.place_partition_len;\n+\t      rest = nthreads % thr->ts.place_partition_len;\n+\t      thr->ts.place_partition_off = p;\n+\t      thr->ts.place_partition_len = 1;\n+\t      k = 1;\n+\t    }\n+\t  break;\n+\t}\n+    }\n+  else\n+    bind = omp_proc_bind_false;\n+\n   /* We only allow the reuse of idle threads for non-nested PARALLEL\n      regions.  This appears to be implied by the semantics of\n      threadprivate variables, but perhaps that's reading too much into\n@@ -341,62 +440,259 @@ gomp_team_start (void (*fn) (void *), void *data, unsigned nthreads,\n \t team will exit.  */\n       pool->threads_used = nthreads;\n \n+      /* If necessary, expand the size of the gomp_threads array.  It is\n+\t expected that changes in the number of threads are rare, thus we\n+\t make no effort to expand gomp_threads_size geometrically.  */\n+      if (nthreads >= pool->threads_size)\n+\t{\n+\t  pool->threads_size = nthreads + 1;\n+\t  pool->threads\n+\t    = gomp_realloc (pool->threads,\n+\t\t\t    pool->threads_size\n+\t\t\t    * sizeof (struct gomp_thread_data *));\n+\t}\n+\n       /* Release existing idle threads.  */\n       for (; i < n; ++i)\n \t{\n-\t  nthr = pool->threads[i];\n+\t  unsigned int place_partition_off = thr->ts.place_partition_off;\n+\t  unsigned int place_partition_len = thr->ts.place_partition_len;\n+\t  unsigned int place = 0;\n+\t  if (__builtin_expect (gomp_places_list != NULL, 0))\n+\t    {\n+\t      switch (bind)\n+\t\t{\n+\t\tcase omp_proc_bind_true:\n+\t\tcase omp_proc_bind_close:\n+\t\t  if (k == s)\n+\t\t    {\n+\t\t      ++p;\n+\t\t      if (p == (team->prev_ts.place_partition_off\n+\t\t\t\t+ team->prev_ts.place_partition_len))\n+\t\t\tp = team->prev_ts.place_partition_off;\n+\t\t      k = 1;\n+\t\t      if (i == nthreads - rest)\n+\t\t\ts = 1;\n+\t\t    }\n+\t\t  else\n+\t\t    ++k;\n+\t\t  break;\n+\t\tcase omp_proc_bind_master:\n+\t\t  break;\n+\t\tcase omp_proc_bind_spread:\n+\t\t  if (k == 0)\n+\t\t    {\n+\t\t      /* T <= P.  */\n+\t\t      if (p < rest)\n+\t\t\tp += s + 1;\n+\t\t      else\n+\t\t\tp += s;\n+\t\t      if (p == (team->prev_ts.place_partition_off\n+\t\t\t\t+ team->prev_ts.place_partition_len))\n+\t\t\tp = team->prev_ts.place_partition_off;\n+\t\t      place_partition_off = p;\n+\t\t      if (p < rest)\n+\t\t\tplace_partition_len = s + 1;\n+\t\t      else\n+\t\t\tplace_partition_len = s;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      /* T > P.  */\n+\t\t      if (k == s)\n+\t\t\t{\n+\t\t\t  ++p;\n+\t\t\t  if (p == (team->prev_ts.place_partition_off\n+\t\t\t\t    + team->prev_ts.place_partition_len))\n+\t\t\t    p = team->prev_ts.place_partition_off;\n+\t\t\t  k = 1;\n+\t\t\t  if (i == nthreads - rest)\n+\t\t\t    s = 1;\n+\t\t\t}\n+\t\t      else\n+\t\t\t++k;\n+\t\t      place_partition_off = p;\n+\t\t      place_partition_len = 1;\n+\t\t    }\n+\t\t  break;\n+\t\t}\n+\t      if (affinity_thr != NULL\n+\t\t  || (bind != omp_proc_bind_true\n+\t\t      && pool->threads[i]->place != p + 1)\n+\t\t  || pool->threads[i]->place <= place_partition_off\n+\t\t  || pool->threads[i]->place > (place_partition_off\n+\t\t\t\t\t\t+ place_partition_len))\n+\t\t{\n+\t\t  unsigned int l;\n+\t\t  if (affinity_thr == NULL)\n+\t\t    {\n+\t\t      unsigned int j;\n+\n+\t\t      if (team->prev_ts.place_partition_len > 64)\n+\t\t\taffinity_thr\n+\t\t\t  = gomp_malloc (team->prev_ts.place_partition_len\n+\t\t\t\t\t * sizeof (struct gomp_thread *));\n+\t\t      else\n+\t\t\taffinity_thr\n+\t\t\t  = gomp_alloca (team->prev_ts.place_partition_len\n+\t\t\t\t\t * sizeof (struct gomp_thread *));\n+\t\t      memset (affinity_thr, '\\0',\n+\t\t\t      team->prev_ts.place_partition_len\n+\t\t\t      * sizeof (struct gomp_thread *));\n+\t\t      for (j = i; j < old_threads_used; j++)\n+\t\t\t{\n+\t\t\t  if (pool->threads[j]->place\n+\t\t\t      > team->prev_ts.place_partition_off\n+\t\t\t      && (pool->threads[j]->place\n+\t\t\t\t  <= (team->prev_ts.place_partition_off\n+\t\t\t\t      + team->prev_ts.place_partition_len)))\n+\t\t\t    {\n+\t\t\t      l = pool->threads[j]->place - 1\n+\t\t\t\t  - team->prev_ts.place_partition_off;\n+\t\t\t      pool->threads[j]->data = affinity_thr[l];\n+\t\t\t      affinity_thr[l] = pool->threads[j];\n+\t\t\t    }\n+\t\t\t  pool->threads[j] = NULL;\n+\t\t\t}\n+\t\t      if (nthreads > old_threads_used)\n+\t\t\tmemset (&pool->threads[old_threads_used],\n+\t\t\t\t'\\0', ((nthreads - old_threads_used)\n+\t\t\t\t       * sizeof (struct gomp_thread *)));\n+\t\t      n = nthreads;\n+\t\t      affinity_count = old_threads_used - i;\n+\t\t    }\n+\t\t  if (affinity_count == 0)\n+\t\t    break;\n+\t\t  l = p;\n+\t\t  if (affinity_thr[l - team->prev_ts.place_partition_off]\n+\t\t      == NULL)\n+\t\t    {\n+\t\t      if (bind != omp_proc_bind_true)\n+\t\t\tcontinue;\n+\t\t      for (l = place_partition_off;\n+\t\t\t   l < place_partition_off + place_partition_len;\n+\t\t\t   l++)\n+\t\t\tif (affinity_thr[l - team->prev_ts.place_partition_off]\n+\t\t\t    != NULL)\n+\t\t\t  break;\n+\t\t      if (l == place_partition_off + place_partition_len)\n+\t\t\tcontinue;\n+\t\t    }\n+\t\t  nthr = affinity_thr[l - team->prev_ts.place_partition_off];\n+\t\t  affinity_thr[l - team->prev_ts.place_partition_off]\n+\t\t    = (struct gomp_thread *) nthr->data;\n+\t\t  affinity_count--;\n+\t\t  pool->threads[i] = nthr;\n+\t\t}\n+\t      else\n+\t\tnthr = pool->threads[i];\n+\t      place = p + 1;\n+\t    }\n+\t  else\n+\t    nthr = pool->threads[i];\n \t  nthr->ts.team = team;\n \t  nthr->ts.work_share = &team->work_shares[0];\n \t  nthr->ts.last_work_share = NULL;\n \t  nthr->ts.team_id = i;\n \t  nthr->ts.level = team->prev_ts.level + 1;\n \t  nthr->ts.active_level = thr->ts.active_level;\n+\t  nthr->ts.place_partition_off = place_partition_off;\n+\t  nthr->ts.place_partition_len = place_partition_len;\n #ifdef HAVE_SYNC_BUILTINS\n \t  nthr->ts.single_count = 0;\n #endif\n \t  nthr->ts.static_trip = 0;\n \t  nthr->task = &team->implicit_task[i];\n+\t  nthr->place = place;\n \t  gomp_init_task (nthr->task, task, icv);\n \t  team->implicit_task[i].icv.nthreads_var = nthreads_var;\n+\t  team->implicit_task[i].icv.bind_var = bind_var;\n \t  nthr->fn = fn;\n \t  nthr->data = data;\n \t  team->ordered_release[i] = &nthr->release;\n \t}\n \n+      if (__builtin_expect (affinity_thr != NULL, 0))\n+\t{\n+\t  /* If AFFINITY_THR is non-NULL just because we had to\n+\t     permute some threads in the pool, but we've managed\n+\t     to find exactly as many old threads as we'd find\n+\t     without affinity, we don't need to handle this\n+\t     specially anymore.  */\n+\t  if (nthreads <= old_threads_used\n+\t      ? (affinity_count == old_threads_used - nthreads)\n+\t      : (i == old_threads_used))\n+\t    {\n+\t      if (team->prev_ts.place_partition_len > 64)\n+\t\tfree (affinity_thr);\n+\t      affinity_thr = NULL;\n+\t      affinity_count = 0;\n+\t    }\n+\t  else\n+\t    {\n+\t      i = 1;\n+\t      /* We are going to compute the places/subpartitions\n+\t\t again from the beginning.  So, we need to reinitialize\n+\t\t vars modified by the switch (bind) above inside\n+\t\t of the loop, to the state they had after the initial\n+\t\t switch (bind).  */\n+\t      switch (bind)\n+\t\t{\n+\t\tcase omp_proc_bind_true:\n+\t\tcase omp_proc_bind_close:\n+\t\t  if (nthreads > thr->ts.place_partition_len)\n+\t\t    /* T > P.  S has been changed, so needs\n+\t\t       to be recomputed.  */\n+\t\t    s = nthreads / thr->ts.place_partition_len;\n+\t\t  k = 1;\n+\t\t  p = thr->place - 1;\n+\t\t  break;\n+\t\tcase omp_proc_bind_master:\n+\t\t  /* No vars have been changed.  */\n+\t\t  break;\n+\t\tcase omp_proc_bind_spread:\n+\t\t  p = thr->ts.place_partition_off;\n+\t\t  if (k != 0)\n+\t\t    {\n+\t\t      /* T > P.  */\n+\t\t      s = nthreads / team->prev_ts.place_partition_len;\n+\t\t      k = 1;\n+\t\t    }\n+\t\t  break;\n+\t\t}\n+\n+\t      /* Increase the barrier threshold to make sure all new\n+\t\t threads and all the threads we're going to let die\n+\t\t arrive before the team is released.  */\n+\t      if (affinity_count)\n+\t\tgomp_barrier_reinit (&pool->threads_dock,\n+\t\t\t\t     nthreads + affinity_count);\n+\t    }\n+\t}\n+\n       if (i == nthreads)\n \tgoto do_release;\n \n-      /* If necessary, expand the size of the gomp_threads array.  It is\n-\t expected that changes in the number of threads are rare, thus we\n-\t make no effort to expand gomp_threads_size geometrically.  */\n-      if (nthreads >= pool->threads_size)\n-\t{\n-\t  pool->threads_size = nthreads + 1;\n-\t  pool->threads\n-\t    = gomp_realloc (pool->threads,\n-\t\t\t    pool->threads_size\n-\t\t\t    * sizeof (struct gomp_thread_data *));\n-\t}\n     }\n \n-  if (__builtin_expect (nthreads > old_threads_used, 0))\n+  if (__builtin_expect (nthreads + affinity_count > old_threads_used, 0))\n     {\n-      long diff = (long) nthreads - (long) old_threads_used;\n+      long diff = (long) (nthreads + affinity_count) - (long) old_threads_used;\n \n       if (old_threads_used == 0)\n \t--diff;\n \n #ifdef HAVE_SYNC_BUILTINS\n       __sync_fetch_and_add (&gomp_managed_threads, diff);\n #else\n-      gomp_mutex_lock (&gomp_remaining_threads_lock);\n+      gomp_mutex_lock (&gomp_managed_threads_lock);\n       gomp_managed_threads += diff;\n-      gomp_mutex_unlock (&gomp_remaining_threads_lock);\n+      gomp_mutex_unlock (&gomp_managed_threads_lock);\n #endif\n     }\n \n   attr = &gomp_thread_attr;\n-  if (__builtin_expect (gomp_cpu_affinity != NULL, 0))\n+  if (__builtin_expect (gomp_places_list != NULL, 0))\n     {\n       size_t stacksize;\n       pthread_attr_init (&thread_attr);\n@@ -410,11 +706,78 @@ gomp_team_start (void (*fn) (void *), void *data, unsigned nthreads,\n \t\t\t    * (nthreads-i));\n \n   /* Launch new threads.  */\n-  for (; i < nthreads; ++i, ++start_data)\n+  for (; i < nthreads; ++i)\n     {\n       pthread_t pt;\n       int err;\n \n+      start_data->ts.place_partition_off = thr->ts.place_partition_off;\n+      start_data->ts.place_partition_len = thr->ts.place_partition_len;\n+      start_data->place = 0;\n+      if (__builtin_expect (gomp_places_list != NULL, 0))\n+\t{\n+\t  switch (bind)\n+\t    {\n+\t    case omp_proc_bind_true:\n+\t    case omp_proc_bind_close:\n+\t      if (k == s)\n+\t\t{\n+\t\t  ++p;\n+\t\t  if (p == (team->prev_ts.place_partition_off\n+\t\t\t    + team->prev_ts.place_partition_len))\n+\t\t    p = team->prev_ts.place_partition_off;\n+\t\t  k = 1;\n+\t\t  if (i == nthreads - rest)\n+\t\t    s = 1;\n+\t\t}\n+\t      else\n+\t\t++k;\n+\t      break;\n+\t    case omp_proc_bind_master:\n+\t      break;\n+\t    case omp_proc_bind_spread:\n+\t      if (k == 0)\n+\t\t{\n+\t\t  /* T <= P.  */\n+\t\t  if (p < rest)\n+\t\t    p += s + 1;\n+\t\t  else\n+\t\t    p += s;\n+\t\t  if (p == (team->prev_ts.place_partition_off\n+\t\t\t    + team->prev_ts.place_partition_len))\n+\t\t    p = team->prev_ts.place_partition_off;\n+\t\t  start_data->ts.place_partition_off = p;\n+\t\t  if (p < rest)\n+\t\t    start_data->ts.place_partition_len = s + 1;\n+\t\t  else\n+\t\t    start_data->ts.place_partition_len = s;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  /* T > P.  */\n+\t\t  if (k == s)\n+\t\t    {\n+\t\t      ++p;\n+\t\t      if (p == (team->prev_ts.place_partition_off\n+\t\t\t\t+ team->prev_ts.place_partition_len))\n+\t\t\tp = team->prev_ts.place_partition_off;\n+\t\t      k = 1;\n+\t\t      if (i == nthreads - rest)\n+\t\t\ts = 1;\n+\t\t    }\n+\t\t  else\n+\t\t    ++k;\n+\t\t  start_data->ts.place_partition_off = p;\n+\t\t  start_data->ts.place_partition_len = 1;\n+\t\t}\n+\t      break;\n+\t    }\n+\t  start_data->place = p + 1;\n+\t  if (affinity_thr != NULL && pool->threads[i] != NULL)\n+\t    continue;\n+\t  gomp_init_thread_affinity (attr, p);\n+\t}\n+\n       start_data->fn = fn;\n       start_data->fn_data = data;\n       start_data->ts.team = team;\n@@ -430,18 +793,16 @@ gomp_team_start (void (*fn) (void *), void *data, unsigned nthreads,\n       start_data->task = &team->implicit_task[i];\n       gomp_init_task (start_data->task, task, icv);\n       team->implicit_task[i].icv.nthreads_var = nthreads_var;\n+      team->implicit_task[i].icv.bind_var = bind_var;\n       start_data->thread_pool = pool;\n       start_data->nested = nested;\n \n-      if (gomp_cpu_affinity != NULL)\n-\tgomp_init_thread_affinity (attr);\n-\n-      err = pthread_create (&pt, attr, gomp_thread_start, start_data);\n+      err = pthread_create (&pt, attr, gomp_thread_start, start_data++);\n       if (err != 0)\n \tgomp_fatal (\"Thread creation failed: %s\", strerror (err));\n     }\n \n-  if (__builtin_expect (gomp_cpu_affinity != NULL, 0))\n+  if (__builtin_expect (gomp_places_list != NULL, 0))\n     pthread_attr_destroy (&thread_attr);\n \n  do_release:\n@@ -450,21 +811,32 @@ gomp_team_start (void (*fn) (void *), void *data, unsigned nthreads,\n   /* Decrease the barrier threshold to match the number of threads\n      that should arrive back at the end of this team.  The extra\n      threads should be exiting.  Note that we arrange for this test\n-     to never be true for nested teams.  */\n-  if (__builtin_expect (nthreads < old_threads_used, 0))\n+     to never be true for nested teams.  If AFFINITY_COUNT is non-zero,\n+     the barrier as well as gomp_managed_threads was temporarily\n+     set to NTHREADS + AFFINITY_COUNT.  For NTHREADS < OLD_THREADS_COUNT,\n+     AFFINITY_COUNT if non-zero will be always at least\n+     OLD_THREADS_COUNT - NTHREADS.  */\n+  if (__builtin_expect (nthreads < old_threads_used, 0)\n+      || __builtin_expect (affinity_count, 0))\n     {\n       long diff = (long) nthreads - (long) old_threads_used;\n \n+      if (affinity_count)\n+\tdiff = -affinity_count;\n+\n       gomp_barrier_reinit (&pool->threads_dock, nthreads);\n \n #ifdef HAVE_SYNC_BUILTINS\n       __sync_fetch_and_add (&gomp_managed_threads, diff);\n #else\n-      gomp_mutex_lock (&gomp_remaining_threads_lock);\n+      gomp_mutex_lock (&gomp_managed_threads_lock);\n       gomp_managed_threads += diff;\n-      gomp_mutex_unlock (&gomp_remaining_threads_lock);\n+      gomp_mutex_unlock (&gomp_managed_threads_lock);\n #endif\n     }\n+  if (__builtin_expect (affinity_thr != NULL, 0)\n+      && team->prev_ts.place_partition_len > 64)\n+    free (affinity_thr);\n }\n \n \n@@ -477,9 +849,26 @@ gomp_team_end (void)\n   struct gomp_thread *thr = gomp_thread ();\n   struct gomp_team *team = thr->ts.team;\n \n-  /* This barrier handles all pending explicit threads.  */\n-  gomp_team_barrier_wait (&team->barrier);\n-  gomp_fini_work_share (thr->ts.work_share);\n+  /* This barrier handles all pending explicit threads.\n+     As #pragma omp cancel parallel might get awaited count in\n+     team->barrier in a inconsistent state, we need to use a different\n+     counter here.  */\n+  gomp_team_barrier_wait_final (&team->barrier);\n+  if (__builtin_expect (team->team_cancelled, 0))\n+    {\n+      struct gomp_work_share *ws = team->work_shares_to_free;\n+      do\n+\t{\n+\t  struct gomp_work_share *next_ws = gomp_ptrlock_get (&ws->next_ws);\n+\t  if (next_ws == NULL)\n+\t    gomp_ptrlock_set (&ws->next_ws, ws);\n+\t  gomp_fini_work_share (ws);\n+\t  ws = next_ws;\n+\t}\n+      while (ws != NULL);\n+    }\n+  else\n+    gomp_fini_work_share (thr->ts.work_share);\n \n   gomp_end_task ();\n   thr->ts = team->prev_ts;\n@@ -489,9 +878,9 @@ gomp_team_end (void)\n #ifdef HAVE_SYNC_BUILTINS\n       __sync_fetch_and_add (&gomp_managed_threads, 1L - team->nthreads);\n #else\n-      gomp_mutex_lock (&gomp_remaining_threads_lock);\n+      gomp_mutex_lock (&gomp_managed_threads_lock);\n       gomp_managed_threads -= team->nthreads - 1L;\n-      gomp_mutex_unlock (&gomp_remaining_threads_lock);\n+      gomp_mutex_unlock (&gomp_managed_threads_lock);\n #endif\n       /* This barrier has gomp_barrier_wait_last counterparts\n \t and ensures the team can be safely destroyed.  */\n@@ -532,8 +921,6 @@ gomp_team_end (void)\n static void __attribute__((constructor))\n initialize_team (void)\n {\n-  struct gomp_thread *thr;\n-\n #ifndef HAVE_TLS\n   static struct gomp_thread initial_thread_tls_data;\n \n@@ -543,13 +930,6 @@ initialize_team (void)\n \n   if (pthread_key_create (&gomp_thread_destructor, gomp_free_thread) != 0)\n     gomp_fatal (\"could not create thread pool destructor.\");\n-\n-#ifdef HAVE_TLS\n-  thr = &gomp_tls_data;\n-#else\n-  thr = &initial_thread_tls_data;\n-#endif\n-  gomp_sem_init (&thr->release, 0);\n }\n \n static void __attribute__((destructor))"}, {"sha": "d20b392baf6c6bd89650b93f1d9e6d1224a454aa", "filename": "libgomp/testsuite/libgomp.c++/affinity-1.C", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Faffinity-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Faffinity-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Faffinity-1.C?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -0,0 +1,4 @@\n+// { dg-do run }\n+// { dg-set-target-env-var OMP_PROC_BIND \"true\" }\n+\n+#include \"../libgomp.c/affinity-1.c\""}, {"sha": "2145f2882332991d18815458851505837ac7a513", "filename": "libgomp/testsuite/libgomp.c++/atomic-10.C", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fatomic-10.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fatomic-10.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fatomic-10.C?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -0,0 +1,99 @@\n+// { dg-do run }\n+\n+extern \"C\" void abort (void);\n+int x = 6;\n+\n+int\n+main ()\n+{\n+  int v, l = 2, s = 1;\n+  #pragma omp atomic\n+    x = -3 + x;\n+  #pragma omp atomic read\n+    v = x;\n+  if (v != 3)\n+    abort ();\n+  #pragma omp atomic update\n+    x = 3 * 2 * 1 + x;\n+  #pragma omp atomic read\n+    v = x;\n+  if (v != 9)\n+    abort ();\n+  #pragma omp atomic capture\n+    v = x = x | 16;\n+  if (v != 25)\n+    abort ();\n+  #pragma omp atomic capture\n+    v = x = x + 14 * 2 / 4;\n+  if (v != 32)\n+    abort ();\n+  #pragma omp atomic capture\n+    v = x = 5 | x;\n+  if (v != 37)\n+    abort ();\n+  #pragma omp atomic capture\n+    v = x = 40 + 12 - 2 - 7 - x;\n+  if (v != 6)\n+    abort ();\n+  #pragma omp atomic read\n+    v = x;\n+  if (v != 6)\n+    abort ();\n+  #pragma omp atomic capture\n+    { v = x; x = 3 + x; }\n+  if (v != 6)\n+    abort ();\n+  #pragma omp atomic capture\n+    { v = x; x = -1 * -1 * -1 * -1 - x; }\n+  if (v != 9)\n+    abort ();\n+  #pragma omp atomic read\n+    v = x;\n+  if (v != -8)\n+    abort ();\n+  #pragma omp atomic capture\n+    { x = 2 * 2 - x; v = x; }\n+  if (v != 12)\n+    abort ();\n+  #pragma omp atomic capture\n+    { x = 7 & x; v = x; }\n+  if (v != 4)\n+    abort ();\n+  #pragma omp atomic capture\n+    { v = x; x = 6; }\n+  if (v != 4)\n+    abort ();\n+  #pragma omp atomic read\n+    v = x;\n+  if (v != 6)\n+    abort ();\n+  #pragma omp atomic capture\n+    { v = x; x = 7 * 8 + 23; }\n+  if (v != 6)\n+    abort ();\n+  #pragma omp atomic read\n+    v = x;\n+  if (v != 79)\n+    abort ();\n+  #pragma omp atomic capture\n+    { v = x; x = 23 + 6 * 4; }\n+  if (v != 79)\n+    abort ();\n+  #pragma omp atomic read\n+    v = x;\n+  if (v != 47)\n+    abort ();\n+  #pragma omp atomic capture\n+    { v = x; x = l ? 17 : 12; }\n+  if (v != 47)\n+    abort ();\n+  #pragma omp atomic capture\n+    { v = x; x = l = s++ + 3; }\n+  if (v != 17 || l != 4 || s != 2)\n+    abort ();\n+  #pragma omp atomic read\n+    v = x;\n+  if (v != 4)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "c7101e01408bb253d99a897029e011843b480eca", "filename": "libgomp/testsuite/libgomp.c++/atomic-11.C", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fatomic-11.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fatomic-11.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fatomic-11.C?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -0,0 +1,108 @@\n+// { dg-do run }\n+\n+extern \"C\" void abort (void);\n+\n+template <typename T>\n+void\n+foo ()\n+{\n+  extern T x;\n+  T v, l = 2, s = 1;\n+  #pragma omp atomic\n+    x = -3 + x;\n+  #pragma omp atomic read\n+    v = x;\n+  if (v != 3)\n+    abort ();\n+  #pragma omp atomic update\n+    x = 3 * 2 * 1 + x;\n+  #pragma omp atomic read\n+    v = x;\n+  if (v != 9)\n+    abort ();\n+  #pragma omp atomic capture\n+    v = x = x | 16;\n+  if (v != 25)\n+    abort ();\n+  #pragma omp atomic capture\n+    v = x = x + 14 * 2 / 4;\n+  if (v != 32)\n+    abort ();\n+  #pragma omp atomic capture\n+    v = x = 5 | x;\n+  if (v != 37)\n+    abort ();\n+  #pragma omp atomic capture\n+    v = x = 40 + 12 - 2 - 7 - x;\n+  if (v != 6)\n+    abort ();\n+  #pragma omp atomic read\n+    v = x;\n+  if (v != 6)\n+    abort ();\n+  #pragma omp atomic capture\n+    { v = x; x = 3 + x; }\n+  if (v != 6)\n+    abort ();\n+  #pragma omp atomic capture\n+    { v = x; x = -1 * -1 * -1 * -1 - x; }\n+  if (v != 9)\n+    abort ();\n+  #pragma omp atomic read\n+    v = x;\n+  if (v != -8)\n+    abort ();\n+  #pragma omp atomic capture\n+    { x = 2 * 2 - x; v = x; }\n+  if (v != 12)\n+    abort ();\n+  #pragma omp atomic capture\n+    { x = 7 & x; v = x; }\n+  if (v != 4)\n+    abort ();\n+  #pragma omp atomic capture\n+    { v = x; x = 6; }\n+  if (v != 4)\n+    abort ();\n+  #pragma omp atomic read\n+    v = x;\n+  if (v != 6)\n+    abort ();\n+  #pragma omp atomic capture\n+    { v = x; x = 7 * 8 + 23; }\n+  if (v != 6)\n+    abort ();\n+  #pragma omp atomic read\n+    v = x;\n+  if (v != 79)\n+    abort ();\n+  #pragma omp atomic capture\n+    { v = x; x = 23 + 6 * 4; }\n+  if (v != 79)\n+    abort ();\n+  #pragma omp atomic read\n+    v = x;\n+  if (v != 47)\n+    abort ();\n+  #pragma omp atomic capture\n+    { v = x; x = l ? 17 : 12; }\n+  if (v != 47)\n+    abort ();\n+  #pragma omp atomic capture\n+    { v = x; x = l = s++ + 3; }\n+  if (v != 17 || l != 4 || s != 2)\n+    abort ();\n+  #pragma omp atomic read\n+    v = x;\n+  if (v != 4)\n+    abort ();\n+}\n+\n+int x = 6;\n+\n+int\n+main ()\n+{\n+  foo <int> ();\n+  return 0;\n+}"}, {"sha": "d1ae9d8c88ca0e71ccb9eb7433aa562c6409bba6", "filename": "libgomp/testsuite/libgomp.c++/atomic-12.C", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fatomic-12.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fatomic-12.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fatomic-12.C?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -0,0 +1,58 @@\n+// { dg-do run }\n+\n+extern \"C\" void abort ();\n+int x = 6, cnt;\n+\n+int\n+foo ()\n+{\n+  return cnt++;\n+}\n+\n+int\n+main ()\n+{\n+  int v, *p;\n+  p = &x;\n+  #pragma omp atomic update\n+    p[foo (), 0] = 16 + 6 - p[foo (), 0];\n+  #pragma omp atomic read\n+    v = x;\n+  if (cnt != 2 || v != 16)\n+    abort ();\n+  #pragma omp atomic capture\n+    v = p[foo () + foo (), 0] = p[foo () + foo (), 0] + 3;\n+  if (cnt != 6 || v != 19)\n+    abort ();\n+  #pragma omp atomic capture\n+    v = p[foo (), 0] = 12 * 1 / 2 + (foo (), 0) + p[foo (), 0];\n+  if (cnt != 9 || v != 25)\n+    abort ();\n+  #pragma omp atomic capture\n+    {\n+      v = p[foo () & 0]; p[foo () & 0] = (foo (), 1) * 9 - p[foo () & 0];\n+    }\n+  if (cnt != 13 || v != 25)\n+    abort ();\n+  #pragma omp atomic read\n+    v = x;\n+  if (v != -16)\n+    abort ();\n+  #pragma omp atomic capture\n+    {\n+      p[0 & foo ()] = 16 - 2 + 3 + p[0 & foo ()]; v = p[0 & foo ()];\n+    }\n+  if (cnt != 16 || v != 1)\n+    abort ();\n+  #pragma omp atomic capture\n+    {\n+      v = p[foo (), 0]; p[foo (), 0] = (foo (), 7) ? 13 : foo () + 6;\n+    }\n+  if (cnt != 19 || v != 1)\n+    abort ();\n+  #pragma omp atomic read\n+    v = x;\n+  if (v != 13)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "0569d1c6deb435a949e94c3423b4c3a13de74cc5", "filename": "libgomp/testsuite/libgomp.c++/atomic-13.C", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fatomic-13.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fatomic-13.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fatomic-13.C?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -0,0 +1,68 @@\n+// { dg-do run }\n+\n+extern \"C\" void abort ();\n+int cnt;\n+\n+int\n+foo ()\n+{\n+  return cnt++;\n+}\n+\n+template <typename T>\n+void\n+bar ()\n+{\n+  extern T x;\n+  T v, *p;\n+  p = &x;\n+  #pragma omp atomic update\n+    p[foo (), 0] = 16 + 6 - p[foo (), 0];\n+  #pragma omp atomic read\n+    v = x;\n+  if (cnt != 2 || v != 16)\n+    abort ();\n+  #pragma omp atomic capture\n+    v = p[foo () + foo (), 0] = p[foo () + foo (), 0] + 3;\n+  if (cnt != 6 || v != 19)\n+    abort ();\n+  #pragma omp atomic capture\n+    v = p[foo (), 0] = 12 * 1 / 2 + (foo (), 0) + p[foo (), 0];\n+  if (cnt != 9 || v != 25)\n+    abort ();\n+  #pragma omp atomic capture\n+    {\n+      v = p[foo () & 0]; p[foo () & 0] = (foo (), 1) * 9 - p[foo () & 0];\n+    }\n+  if (cnt != 13 || v != 25)\n+    abort ();\n+  #pragma omp atomic read\n+    v = x;\n+  if (v != -16)\n+    abort ();\n+  #pragma omp atomic capture\n+    {\n+      p[0 & foo ()] = 16 - 2 + 3 + p[0 & foo ()]; v = p[0 & foo ()];\n+    }\n+  if (cnt != 16 || v != 1)\n+    abort ();\n+  #pragma omp atomic capture\n+    {\n+      v = p[foo (), 0]; p[foo (), 0] = (foo (), 7) ? 13 : foo () + 6;\n+    }\n+  if (cnt != 19 || v != 1)\n+    abort ();\n+  #pragma omp atomic read\n+    v = x;\n+  if (v != 13)\n+    abort ();\n+}\n+\n+int x = 6;\n+\n+int\n+main ()\n+{\n+  bar <int> ();\n+  return 0;\n+}"}, {"sha": "4cd9df812d32cf0e718f2f8d46c710c763cf8df8", "filename": "libgomp/testsuite/libgomp.c++/atomic-14.C", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fatomic-14.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fatomic-14.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fatomic-14.C?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -0,0 +1,99 @@\n+// { dg-do run }\n+\n+extern \"C\" void abort (void);\n+int x = 6;\n+\n+int\n+main ()\n+{\n+  int v, l = 2, s = 1;\n+  #pragma omp atomic seq_cst\n+    x = -3 + x;\n+  #pragma omp atomic read seq_cst\n+    v = x;\n+  if (v != 3)\n+    abort ();\n+  #pragma omp atomic update seq_cst\n+    x = 3 * 2 * 1 + x;\n+  #pragma omp atomic read seq_cst\n+    v = x;\n+  if (v != 9)\n+    abort ();\n+  #pragma omp atomic capture seq_cst\n+    v = x = x | 16;\n+  if (v != 25)\n+    abort ();\n+  #pragma omp atomic capture seq_cst\n+    v = x = x + 14 * 2 / 4;\n+  if (v != 32)\n+    abort ();\n+  #pragma omp atomic capture seq_cst\n+    v = x = 5 | x;\n+  if (v != 37)\n+    abort ();\n+  #pragma omp atomic capture seq_cst\n+    v = x = 40 + 12 - 2 - 7 - x;\n+  if (v != 6)\n+    abort ();\n+  #pragma omp atomic read seq_cst\n+    v = x;\n+  if (v != 6)\n+    abort ();\n+  #pragma omp atomic capture seq_cst\n+    { v = x; x = 3 + x; }\n+  if (v != 6)\n+    abort ();\n+  #pragma omp atomic capture seq_cst\n+    { v = x; x = -1 * -1 * -1 * -1 - x; }\n+  if (v != 9)\n+    abort ();\n+  #pragma omp atomic read seq_cst\n+    v = x;\n+  if (v != -8)\n+    abort ();\n+  #pragma omp atomic capture seq_cst\n+    { x = 2 * 2 - x; v = x; }\n+  if (v != 12)\n+    abort ();\n+  #pragma omp atomic capture seq_cst\n+    { x = 7 & x; v = x; }\n+  if (v != 4)\n+    abort ();\n+  #pragma omp atomic capture seq_cst\n+    { v = x; x = 6; }\n+  if (v != 4)\n+    abort ();\n+  #pragma omp atomic read seq_cst\n+    v = x;\n+  if (v != 6)\n+    abort ();\n+  #pragma omp atomic capture seq_cst\n+    { v = x; x = 7 * 8 + 23; }\n+  if (v != 6)\n+    abort ();\n+  #pragma omp atomic read seq_cst\n+    v = x;\n+  if (v != 79)\n+    abort ();\n+  #pragma omp atomic capture seq_cst\n+    { v = x; x = 23 + 6 * 4; }\n+  if (v != 79)\n+    abort ();\n+  #pragma omp atomic read seq_cst\n+    v = x;\n+  if (v != 47)\n+    abort ();\n+  #pragma omp atomic capture seq_cst\n+    { v = x; x = l ? 17 : 12; }\n+  if (v != 47)\n+    abort ();\n+  #pragma omp atomic capture seq_cst\n+    { v = x; x = l = s++ + 3; }\n+  if (v != 17 || l != 4 || s != 2)\n+    abort ();\n+  #pragma omp atomic read seq_cst\n+    v = x;\n+  if (v != 4)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "1eabce7dbd3ee212674cf64403e77d72ee831789", "filename": "libgomp/testsuite/libgomp.c++/atomic-15.C", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fatomic-15.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fatomic-15.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fatomic-15.C?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -0,0 +1,108 @@\n+// { dg-do run }\n+\n+extern \"C\" void abort (void);\n+\n+template <typename T>\n+void\n+foo ()\n+{\n+  extern T x;\n+  T v, l = 2, s = 1;\n+  #pragma omp atomic seq_cst\n+    x = -3 + x;\n+  #pragma omp atomic read seq_cst\n+    v = x;\n+  if (v != 3)\n+    abort ();\n+  #pragma omp atomic update seq_cst\n+    x = 3 * 2 * 1 + x;\n+  #pragma omp atomic read seq_cst\n+    v = x;\n+  if (v != 9)\n+    abort ();\n+  #pragma omp atomic capture seq_cst\n+    v = x = x | 16;\n+  if (v != 25)\n+    abort ();\n+  #pragma omp atomic capture seq_cst\n+    v = x = x + 14 * 2 / 4;\n+  if (v != 32)\n+    abort ();\n+  #pragma omp atomic capture seq_cst\n+    v = x = 5 | x;\n+  if (v != 37)\n+    abort ();\n+  #pragma omp atomic capture seq_cst\n+    v = x = 40 + 12 - 2 - 7 - x;\n+  if (v != 6)\n+    abort ();\n+  #pragma omp atomic read seq_cst\n+    v = x;\n+  if (v != 6)\n+    abort ();\n+  #pragma omp atomic capture seq_cst\n+    { v = x; x = 3 + x; }\n+  if (v != 6)\n+    abort ();\n+  #pragma omp atomic capture seq_cst\n+    { v = x; x = -1 * -1 * -1 * -1 - x; }\n+  if (v != 9)\n+    abort ();\n+  #pragma omp atomic read seq_cst\n+    v = x;\n+  if (v != -8)\n+    abort ();\n+  #pragma omp atomic capture seq_cst\n+    { x = 2 * 2 - x; v = x; }\n+  if (v != 12)\n+    abort ();\n+  #pragma omp atomic capture seq_cst\n+    { x = 7 & x; v = x; }\n+  if (v != 4)\n+    abort ();\n+  #pragma omp atomic capture seq_cst\n+    { v = x; x = 6; }\n+  if (v != 4)\n+    abort ();\n+  #pragma omp atomic read seq_cst\n+    v = x;\n+  if (v != 6)\n+    abort ();\n+  #pragma omp atomic capture seq_cst\n+    { v = x; x = 7 * 8 + 23; }\n+  if (v != 6)\n+    abort ();\n+  #pragma omp atomic read seq_cst\n+    v = x;\n+  if (v != 79)\n+    abort ();\n+  #pragma omp atomic capture seq_cst\n+    { v = x; x = 23 + 6 * 4; }\n+  if (v != 79)\n+    abort ();\n+  #pragma omp atomic read seq_cst\n+    v = x;\n+  if (v != 47)\n+    abort ();\n+  #pragma omp atomic capture seq_cst\n+    { v = x; x = l ? 17 : 12; }\n+  if (v != 47)\n+    abort ();\n+  #pragma omp atomic capture seq_cst\n+    { v = x; x = l = s++ + 3; }\n+  if (v != 17 || l != 4 || s != 2)\n+    abort ();\n+  #pragma omp atomic read seq_cst\n+    v = x;\n+  if (v != 4)\n+    abort ();\n+}\n+\n+int x = 6;\n+\n+int\n+main ()\n+{\n+  foo <int> ();\n+  return 0;\n+}"}, {"sha": "8183a2d06a1e6bc1d04772179ef8f17f90d0377a", "filename": "libgomp/testsuite/libgomp.c++/cancel-for-1.C", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fcancel-for-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fcancel-for-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fcancel-for-1.C?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -0,0 +1,29 @@\n+// { dg-do run }\n+// { dg-set-target-env-var OMP_CANCELLATION \"true\" }\n+\n+#include <omp.h>\n+#include \"cancel-test.h\"\n+\n+int\n+main ()\n+{\n+  {\n+    S c;\n+    #pragma omp parallel num_threads (32)\n+    {\n+      S a, b;\n+      int i;\n+      #pragma omp for private (b) firstprivate (c)\n+      for (i = 0; i < 1000; ++i)\n+\t{\n+\t  S d;\n+\t  #pragma omp cancel for\n+\t  if (omp_get_cancellation ())\n+\t    abort ();\n+\t  b.bump ();\n+\t  c.bump ();\n+\t}\n+    }\n+  }\n+  S::verify ();\n+}"}, {"sha": "1595a239cd019a8e8952e4fcc9bfd93397e0e5f5", "filename": "libgomp/testsuite/libgomp.c++/cancel-for-2.C", "status": "added", "additions": 126, "deletions": 0, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fcancel-for-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fcancel-for-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fcancel-for-2.C?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -0,0 +1,126 @@\n+// { dg-do run }\n+// { dg-set-target-env-var OMP_CANCELLATION \"true\" }\n+\n+#include <omp.h>\n+#include \"cancel-test.h\"\n+\n+__attribute__((noinline, noclone)) int\n+foo (int *x)\n+{\n+  S a, b, c, d, e;\n+  int v = 0, w = 0;\n+  #pragma omp parallel num_threads (32) shared (v, w) private (c, d) firstprivate (e)\n+  {\n+    S g;\n+    int i;\n+    c.bump ();\n+    e.bump ();\n+    #pragma omp for private (d, g) firstprivate (b)\n+    for (i = 0; i < 1000; ++i)\n+      {\n+\tb.bump ();\n+\td.bump ();\n+\tg.bump ();\n+\t#pragma omp cancel for if (x[0])\n+\tabort ();\n+      }\n+    #pragma omp for private (d, g) firstprivate (b)\n+    for (i = 0; i < 1000; ++i)\n+      {\n+\tb.bump ();\n+\td.bump ();\n+\tg.bump ();\n+\t#pragma omp cancel for if (x[1])\n+\t#pragma omp atomic\n+\tv++;\n+      }\n+    #pragma omp for private (d, g) firstprivate (b)\n+    for (i = 0; i < 1000; ++i)\n+      {\n+\tb.bump ();\n+\td.bump ();\n+\tg.bump ();\n+\t#pragma omp cancel for if (x[2])\n+\t#pragma omp atomic\n+\tw += 8;\n+      }\n+    #pragma omp for private (d, g) firstprivate (b)\n+    for (i = 0; i < 1000; ++i)\n+      {\n+\tb.bump ();\n+\td.bump ();\n+\tg.bump ();\n+\t#pragma omp cancel for if (x[3])\n+\t#pragma omp atomic\n+\tv += 2;\n+      }\n+  }\n+  if (v != 3000 || w != 0)\n+    abort ();\n+  #pragma omp parallel num_threads (32) shared (v, w) private (c, d) firstprivate (e)\n+  {\n+    S g, h;\n+    int i;\n+    c.bump ();\n+    e.bump ();\n+    /* None of these cancel directives should actually cancel anything,\n+       but the compiler shouldn't know that and thus should use cancellable\n+       barriers at the end of all the workshares.  */\n+    #pragma omp cancel parallel if (omp_get_thread_num () == 1 && x[4])\n+    #pragma omp for private (d, g) firstprivate (b)\n+    for (i = 0; i < 1000; ++i)\n+      {\n+\tb.bump ();\n+\td.bump ();\n+\tg.bump ();\n+\t#pragma omp cancel for if (x[0])\n+\tabort ();\n+      }\n+    #pragma omp cancel parallel if (omp_get_thread_num () == 2 && x[4])\n+    #pragma omp for private (d, g) firstprivate (b)\n+    for (i = 0; i < 1000; ++i)\n+      {\n+\tb.bump ();\n+\td.bump ();\n+\tg.bump ();\n+\t#pragma omp cancel for if (x[1])\n+\t#pragma omp atomic\n+\tv++;\n+      }\n+    #pragma omp cancel parallel if (omp_get_thread_num () == 3 && x[4])\n+    #pragma omp for private (d, g) firstprivate (b)\n+    for (i = 0; i < 1000; ++i)\n+      {\n+\tb.bump ();\n+\td.bump ();\n+\tg.bump ();\n+\t#pragma omp cancel for if (x[2])\n+\t#pragma omp atomic\n+\tw += 8;\n+      }\n+    #pragma omp cancel parallel if (omp_get_thread_num () == 4 && x[4])\n+    #pragma omp for private (d, g) firstprivate (b)\n+    for (i = 0; i < 1000; ++i)\n+      {\n+\tb.bump ();\n+\td.bump ();\n+\tg.bump ();\n+\t#pragma omp cancel for if (x[3])\n+\t#pragma omp atomic\n+\tv += 2;\n+      }\n+    #pragma omp cancel parallel if (omp_get_thread_num () == 5 && x[4])\n+  }\n+  if (v != 6000 || w != 0)\n+    abort ();\n+  return 0;\n+}\n+\n+int\n+main ()\n+{\n+  int x[] = { 1, 0, 1, 0, 0 };\n+  if (omp_get_cancellation ())\n+    foo (x);\n+  S::verify ();\n+}"}, {"sha": "033d676b3b27e0dc3bcc1298b4a0697afc946a69", "filename": "libgomp/testsuite/libgomp.c++/cancel-parallel-1.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fcancel-parallel-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fcancel-parallel-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fcancel-parallel-1.C?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -0,0 +1,18 @@\n+// { dg-do run }\n+// { dg-set-target-env-var OMP_CANCELLATION \"true\" }\n+\n+#include <omp.h>\n+#include \"cancel-test.h\"\n+\n+int\n+main ()\n+{\n+  #pragma omp parallel num_threads (32)\n+  {\n+    S a;\n+    #pragma omp cancel parallel\n+    if (omp_get_cancellation ())\n+      abort ();\n+  }\n+  S::verify ();\n+}"}, {"sha": "340423b5586a4bebb38b5d95a19f398a94b3bb8b", "filename": "libgomp/testsuite/libgomp.c++/cancel-parallel-2.C", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fcancel-parallel-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fcancel-parallel-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fcancel-parallel-2.C?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -0,0 +1,57 @@\n+// { dg-do run }\n+// { dg-set-target-env-var OMP_CANCELLATION \"true\" }\n+\n+#include <unistd.h>\n+#include <omp.h>\n+#include \"cancel-test.h\"\n+\n+static void\n+foo (int *x)\n+{\n+  S a, b, c;\n+  #pragma omp parallel firstprivate(x, c) num_threads (32) private (b)\n+  {\n+    S d;\n+    b.bump ();\n+    c.bump ();\n+    int thr = omp_get_thread_num ();\n+    switch (x[thr])\n+      {\n+      case 4:\n+\t#pragma omp cancel parallel\n+\tbreak;\n+      case 3:\n+\t#pragma omp task\n+\tusleep (1000);\n+\t#pragma omp task\n+\tusleep (2000);\n+\t#pragma omp task\n+\tusleep (4000);\n+\tbreak;\n+      case 2:\n+\tusleep (1000);\n+\t/* FALLTHRU */\n+      case 1:\n+\t#pragma omp cancellation point parallel\n+\tbreak;\n+      }\n+    #pragma omp barrier\n+    if (omp_get_cancellation ())\n+      abort ();\n+  }\n+}\n+\n+int\n+main ()\n+{\n+  int i, j, x[32] = { 0, 1, 2, 4, 2, 2, 1, 0 };\n+  foo (x);\n+  for (i = 0; i < 32; i++)\n+    {\n+      for (j = 0; j < 32; j++)\n+\tx[j] = rand () & 3;\n+      x[rand () & 31] = 4;\n+      foo (x);\n+    }\n+  S::verify ();\n+}"}, {"sha": "9db7a4f7b3ea2e8f40485d51ec63b93449efabff", "filename": "libgomp/testsuite/libgomp.c++/cancel-parallel-3.C", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fcancel-parallel-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fcancel-parallel-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fcancel-parallel-3.C?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -0,0 +1,50 @@\n+// { dg-do run }\n+// { dg-set-target-env-var OMP_CANCELLATION \"true\" }\n+\n+#include <omp.h>\n+#include <unistd.h>\n+#include \"cancel-test.h\"\n+\n+static inline void\n+do_some_work (void)\n+{\n+  asm volatile (\"\" : : : \"memory\");\n+}\n+\n+void\n+foo ()\n+{\n+  S a, b, c;\n+  omp_set_dynamic (0);\n+  omp_set_schedule (omp_sched_static, 1);\n+  #pragma omp parallel num_threads (16) private (b) firstprivate (c)\n+  {\n+    S d;\n+    int i, j;\n+    b.bump ();\n+    c.bump ();\n+    do_some_work ();\n+    #pragma omp barrier\n+    if (omp_get_thread_num () == 1)\n+      {\n+\tsleep (2);\n+\t#pragma omp cancellation point parallel\n+      }\n+    for (j = 3; j <= 16; j++)\n+      #pragma omp for schedule (runtime) nowait\n+      for (i = 0; i < j; i++)\n+\tdo_some_work ();\n+    if (omp_get_thread_num () == 0)\n+      {\n+\tsleep (1);\n+\t#pragma omp cancel parallel\n+      }\n+  }\n+}\n+\n+int\n+main ()\n+{\n+  foo ();\n+  S::verify ();\n+}"}, {"sha": "81a9c352018cfac4f2e11bd486d96a17e825d140", "filename": "libgomp/testsuite/libgomp.c++/cancel-sections-1.C", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fcancel-sections-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fcancel-sections-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fcancel-sections-1.C?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -0,0 +1,43 @@\n+// { dg-do run }\n+// { dg-set-target-env-var OMP_CANCELLATION \"true\" }\n+\n+#include <omp.h>\n+#include \"cancel-test.h\"\n+\n+int\n+main ()\n+{\n+  if (!omp_get_cancellation ())\n+    return 0;\n+  #pragma omp parallel num_threads (32)\n+  {\n+    S a;\n+    #pragma omp sections\n+      {\n+\t{\n+\t  S b;\n+\t  #pragma omp cancel sections\n+\t  abort ();\n+\t}\n+      #pragma omp section\n+\t{\n+\t  S c;\n+\t  #pragma omp cancel sections\n+\t  abort ();\n+\t}\n+      #pragma omp section\n+\t{\n+\t  S d;\n+\t  #pragma omp cancel sections\n+\t  abort ();\n+\t}\n+      #pragma omp section\n+\t{\n+\t  S e;\n+\t  #pragma omp cancel sections\n+\t  abort ();\n+\t}\n+      }\n+  }\n+  S::verify ();\n+}"}, {"sha": "4f66859d171d65096e54328c8884fde130b5775c", "filename": "libgomp/testsuite/libgomp.c++/cancel-taskgroup-1.C", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fcancel-taskgroup-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fcancel-taskgroup-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fcancel-taskgroup-1.C?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -0,0 +1,4 @@\n+// { dg-do run }\n+// { dg-set-target-env-var OMP_CANCELLATION \"true\" }\n+\n+#include \"../libgomp.c/cancel-taskgroup-1.c\""}, {"sha": "d4a02e911405453520871eed28123379b52a4ca5", "filename": "libgomp/testsuite/libgomp.c++/cancel-taskgroup-2.C", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fcancel-taskgroup-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fcancel-taskgroup-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fcancel-taskgroup-2.C?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -0,0 +1,4 @@\n+// { dg-do run }\n+// { dg-set-target-env-var OMP_CANCELLATION \"true\" }\n+\n+#include \"../libgomp.c/cancel-taskgroup-2.c\""}, {"sha": "c897265ef8b47e7a467b9ec31db003f09a4aa031", "filename": "libgomp/testsuite/libgomp.c++/cancel-taskgroup-3.C", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fcancel-taskgroup-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fcancel-taskgroup-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fcancel-taskgroup-3.C?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -0,0 +1,58 @@\n+// { dg-do run }\n+// { dg-set-target-env-var OMP_CANCELLATION \"true\" }\n+\n+#include <unistd.h>\n+#include <omp.h>\n+#include \"cancel-test.h\"\n+\n+void\n+foo ()\n+{\n+  S a, b, c, d, e, f;\n+  #pragma omp parallel private (c, d) firstprivate (e, f)\n+  #pragma omp taskgroup\n+  {\n+    c.bump ();\n+    e.bump ();\n+    #pragma omp task firstprivate (b, f) private (d)\n+    {\n+      S h;\n+      b.bump ();\n+      d.bump ();\n+      f.bump ();\n+      #pragma omp cancel taskgroup\n+      if (omp_get_cancellation ())\n+\tabort ();\n+    }\n+  }\n+  #pragma omp parallel private (c, d) firstprivate (e, f)\n+  {\n+    #pragma omp barrier\n+    #pragma omp single\n+    #pragma omp taskgroup\n+    {\n+      int i;\n+      c.bump ();\n+      e.bump ();\n+      for (i = 0; i < 50; i++)\n+\t#pragma omp task firstprivate (b, f) private (d)\n+\t{\n+\t  S h;\n+\t  b.bump ();\n+\t  d.bump ();\n+\t  f.bump ();\n+\t  #pragma omp cancellation point taskgroup\n+\t  usleep (30);\n+\t  #pragma omp cancel taskgroup if (i > 5)\n+\t}\n+    }\n+    usleep (10);\n+  }\n+}\n+\n+int\n+main ()\n+{\n+  foo ();\n+  S::verify ();\n+}"}, {"sha": "776d6ee6321dbed23df40cf8514f9a47a78a0c2e", "filename": "libgomp/testsuite/libgomp.c++/cancel-test.h", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fcancel-test.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fcancel-test.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fcancel-test.h?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -0,0 +1,47 @@\n+#include <stdlib.h>\n+#include <omp.h>\n+\n+struct S\n+{\n+  static int s;\n+  int v;\n+  S ()\n+  {\n+    #pragma omp atomic\n+    s++;\n+  }\n+\n+  S (int x)\n+  {\n+    #pragma omp atomic\n+    s++;\n+    v = x;\n+  }\n+\n+  ~S ()\n+  {\n+    #pragma omp atomic\n+    s--;\n+  }\n+\n+  S (const S &x)\n+  {\n+    #pragma omp atomic\n+    s++;\n+    v = x.v;\n+  }\n+\n+  static void\n+  verify ()\n+  {\n+    if (s) abort ();\n+  }\n+\n+  void\n+  bump ()\n+  {\n+    v++;\n+  }\n+};\n+\n+int S::s = 0;"}, {"sha": "fb1a3e952b17799c5a617d4de239536f17174075", "filename": "libgomp/testsuite/libgomp.c++/for-10.C", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ffor-10.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ffor-10.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ffor-10.C?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -0,0 +1,44 @@\n+extern \"C\" void abort ();\n+\n+#define M(x, y, z) O(x, y, z)\n+#define O(x, y, z) x ## _ ## y ## _ ## z\n+\n+#define F simd\n+#define G simd\n+#define S\n+#define N(x) M(x, G, normal)\n+#include \"../libgomp.c/for-2.h\"\n+#undef S\n+#undef N\n+#undef F\n+#undef G\n+\n+#define F parallel for simd\n+#define G pf_simd\n+#include \"../libgomp.c/for-1.h\"\n+#undef F\n+#undef G\n+\n+#define F for simd\n+#define G f_simd\n+#include \"../libgomp.c/for-1.h\"\n+#undef F\n+#undef G\n+\n+int\n+main ()\n+{\n+  if (test_simd_normal ()\n+      || test_pf_simd_static ()\n+      || test_pf_simd_static32 ()\n+      || test_pf_simd_auto ()\n+      || test_pf_simd_guided32 ()\n+      || test_pf_simd_runtime ()\n+      || test_f_simd_static ()\n+      || test_f_simd_static32 ()\n+      || test_f_simd_auto ()\n+      || test_f_simd_guided32 ()\n+      || test_f_simd_runtime ())\n+    abort ();\n+  return 0;\n+}"}, {"sha": "0244e4de11261844955a95b5318586b1bf512a9b", "filename": "libgomp/testsuite/libgomp.c++/for-11.C", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ffor-11.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ffor-11.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ffor-11.C?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -0,0 +1,108 @@\n+extern \"C\" void abort ();\n+\n+#define M(x, y, z) O(x, y, z)\n+#define O(x, y, z) x ## _ ## y ## _ ## z\n+\n+#pragma omp declare target\n+\n+#define F distribute\n+#define G d\n+#define S\n+#define N(x) M(x, G, normal)\n+#include \"../libgomp.c/for-2.h\"\n+#undef S\n+#undef N\n+#undef F\n+#undef G\n+\n+#define F distribute\n+#define G d_ds128\n+#define S dist_schedule(static, 128)\n+#define N(x) M(x, G, normal)\n+#include \"../libgomp.c/for-2.h\"\n+#undef S\n+#undef N\n+#undef F\n+#undef G\n+\n+#define F distribute simd\n+#define G ds\n+#define S\n+#define N(x) M(x, G, normal)\n+#include \"../libgomp.c/for-2.h\"\n+#undef S\n+#undef N\n+#undef F\n+#undef G\n+\n+#define F distribute simd\n+#define G ds_ds128\n+#define S dist_schedule(static, 128)\n+#define N(x) M(x, G, normal)\n+#include \"../libgomp.c/for-2.h\"\n+#undef S\n+#undef N\n+#undef F\n+#undef G\n+\n+#define F distribute parallel for\n+#define G dpf\n+#include \"../libgomp.c/for-1.h\"\n+#undef F\n+#undef G\n+\n+#define F distribute parallel for dist_schedule(static, 128)\n+#define G dpf_ds128\n+#include \"../libgomp.c/for-1.h\"\n+#undef F\n+#undef G\n+\n+#define F distribute parallel for simd\n+#define G dpfs\n+#include \"../libgomp.c/for-1.h\"\n+#undef F\n+#undef G\n+\n+#define F distribute parallel for simd dist_schedule(static, 128)\n+#define G dpfs_ds128\n+#include \"../libgomp.c/for-1.h\"\n+#undef F\n+#undef G\n+\n+#pragma omp end declare target\n+\n+int\n+main ()\n+{\n+  int err = 0;\n+  #pragma omp target teams reduction(|:err)\n+    {\n+      err |= test_d_normal ();\n+      err |= test_d_ds128_normal ();\n+      err |= test_ds_normal ();\n+      err |= test_ds_ds128_normal ();\n+      err |= test_dpf_static ();\n+      err |= test_dpf_static32 ();\n+      err |= test_dpf_auto ();\n+      err |= test_dpf_guided32 ();\n+      err |= test_dpf_runtime ();\n+      err |= test_dpf_ds128_static ();\n+      err |= test_dpf_ds128_static32 ();\n+      err |= test_dpf_ds128_auto ();\n+      err |= test_dpf_ds128_guided32 ();\n+      err |= test_dpf_ds128_runtime ();\n+      err |= test_dpfs_static ();\n+      err |= test_dpfs_static32 ();\n+      err |= test_dpfs_auto ();\n+      err |= test_dpfs_guided32 ();\n+      err |= test_dpfs_runtime ();\n+      err |= test_dpfs_ds128_static ();\n+      err |= test_dpfs_ds128_static32 ();\n+      err |= test_dpfs_ds128_auto ();\n+      err |= test_dpfs_ds128_guided32 ();\n+      err |= test_dpfs_ds128_runtime ();\n+    }\n+  if (err)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "86b9d9318cb9f31a8533423e9199906fc7a67e6d", "filename": "libgomp/testsuite/libgomp.c++/for-9.C", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ffor-9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ffor-9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ffor-9.C?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -0,0 +1,33 @@\n+extern \"C\" void abort ();\n+\n+#define M(x, y, z) O(x, y, z)\n+#define O(x, y, z) x ## _ ## y ## _ ## z\n+\n+#define F parallel for\n+#define G pf\n+#include \"../libgomp.c/for-1.h\"\n+#undef F\n+#undef G\n+\n+#define F for\n+#define G f\n+#include \"../libgomp.c/for-1.h\"\n+#undef F\n+#undef G\n+\n+int\n+main ()\n+{\n+  if (test_pf_static ()\n+      || test_pf_static32 ()\n+      || test_pf_auto ()\n+      || test_pf_guided32 ()\n+      || test_pf_runtime ()\n+      || test_f_static ()\n+      || test_f_static32 ()\n+      || test_f_auto ()\n+      || test_f_guided32 ()\n+      || test_f_runtime ())\n+    abort ();\n+  return 0;\n+}"}, {"sha": "16ef159b8274734d5ce5339640db47af656d1583", "filename": "libgomp/testsuite/libgomp.c++/simd-1.C", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fsimd-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fsimd-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fsimd-1.C?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -0,0 +1,79 @@\n+// { dg-do run }\n+// { dg-options \"-O2\" }\n+// { dg-additional-options \"-msse2\" { target sse2_runtime } }\n+// { dg-additional-options \"-mavx\" { target avx_runtime } }\n+\n+extern \"C\" void abort ();\n+int a[1024] __attribute__((aligned (32))) = { 1 };\n+int b[1024] __attribute__((aligned (32))) = { 1 };\n+int k, m;\n+struct U { U (); ~U (); int u; };\n+struct V\n+{\n+  V () : v (8) {}\n+  ~V ()\n+  {\n+    if (v > 38 + 4 + 3 * 1024 + 1)\n+      abort ();\n+  }\n+  V &operator= (const V &x) { v = x.v + 1; return *this; }\n+  int v;\n+};\n+\n+__attribute__((noinline, noclone))\n+U::U () : u (6)\n+{\n+}\n+\n+__attribute__((noinline, noclone))\n+U::~U ()\n+{\n+  if (u > 38 + 4 + 3 * 1023)\n+    abort ();\n+}\n+\n+__attribute__((noinline, noclone)) int\n+foo (int *p)\n+{\n+  int i, s = 0;\n+  U u;\n+  V v;\n+  #pragma omp simd aligned(a, p : 32) linear(k: m + 1) \\\n+\t\t   reduction(+:s) lastprivate(u, v)\n+  for (i = 0; i < 1024; i++)\n+    {\n+      a[i] *= p[i];\n+      u.u = p[i] + k;\n+      k += m + 1;\n+      v.v = p[i] + k;\n+      s += p[i] + k;\n+    }\n+  if (u.u != 36 + 4 + 3 * 1023 || v.v != 36 + 4 + 3 * 1024 + 1)\n+    abort ();\n+  return s;\n+}\n+\n+int\n+main ()\n+{\n+#if __SIZEOF_INT__ >= 4\n+  int i;\n+  k = 4;\n+  m = 2;\n+  for (i = 0; i < 1024; i++)\n+    {\n+      a[i] = i - 512;\n+      b[i] = (i - 51) % 39;\n+    }\n+  int s = foo (b);\n+  for (i = 0; i < 1024; i++)\n+    {\n+      if (b[i] != (i - 51) % 39\n+\t  || a[i] != (i - 512) * b[i])\n+\tabort ();\n+    }\n+  if (k != 4 + 3 * 1024 || s != 1596127)\n+    abort ();\n+#endif\n+  return 0;\n+}"}, {"sha": "6b12415bdceb1269b83ce32f2c0a8d0dced16b57", "filename": "libgomp/testsuite/libgomp.c++/simd-2.C", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fsimd-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fsimd-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fsimd-2.C?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -0,0 +1,36 @@\n+// { dg-do run }\n+// { dg-options \"-O2\" }\n+// { dg-additional-options \"-msse2\" { target sse2_runtime } }\n+// { dg-additional-options \"-mavx\" { target avx_runtime } }\n+\n+extern \"C\" void abort ();\n+__UINTPTR_TYPE__ arr[1027];\n+\n+__attribute__((noinline, noclone)) void\n+foo ()\n+{\n+  int i, v;\n+  #pragma omp simd private (v) safelen(16)\n+  for (i = 0; i < 1027; i++)\n+    arr[i] = (__UINTPTR_TYPE__) &v;\n+}\n+\n+int\n+main ()\n+{\n+  int i, j, cnt = 0;\n+  __UINTPTR_TYPE__ arr2[16];\n+  foo ();\n+  for (i = 0; i < 1027; i++)\n+    {\n+      for (j = 0; j < cnt; j++)\n+\tif (arr[i] == arr2[j])\n+\t  break;\n+      if (j != cnt)\n+\tcontinue;\n+      if (cnt == 16)\n+\tabort ();\n+      arr2[cnt++] = arr[i];\n+    }\n+  return 0;\n+}"}, {"sha": "1c6d8e01af90831434a2b6170389215bb0c278b1", "filename": "libgomp/testsuite/libgomp.c++/simd-3.C", "status": "added", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fsimd-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fsimd-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fsimd-3.C?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -0,0 +1,131 @@\n+// { dg-do run }\n+// { dg-options \"-O2\" }\n+// { dg-additional-options \"-msse2\" { target sse2_runtime } }\n+// { dg-additional-options \"-mavx\" { target avx_runtime } }\n+\n+extern \"C\" void abort ();\n+int a[1024] __attribute__((aligned (32))) = { 1 };\n+int b[1024] __attribute__((aligned (32))) = { 1 };\n+unsigned char c[1024] __attribute__((aligned (32))) = { 1 };\n+int k, m;\n+__UINTPTR_TYPE__ u, u2, u3;\n+\n+__attribute__((noinline, noclone)) int\n+foo (int *p)\n+{\n+  int i, s = 0, s2 = 0, t, t2;\n+  #pragma omp simd aligned(a, b, p : 32) linear(k: m + 1) reduction(+:s) \\\n+\t\t   lastprivate (t2)\n+  for (i = 0; i < 512; i++)\n+    {\n+      a[i] *= p[i];\n+      t2 = k + p[i];\n+      k += m + 1;\n+      s += p[i] + k;\n+      c[i]++;\n+    }\n+  #pragma omp simd aligned(a, b, p : 32) linear(k: m + 1) reduction(+:s2) \\\n+\t\t   lastprivate (t, u, u2, u3)\n+  for (i = 512; i < 1024; i++)\n+    {\n+      a[i] *= p[i];\n+      k += m + 1;\n+      t = k + p[i];\n+      u = (__UINTPTR_TYPE__) &k;\n+      u2 = (__UINTPTR_TYPE__) &s2;\n+      u3 = (__UINTPTR_TYPE__) &t;\n+      s2 += t;\n+      c[i]++;\n+    }\n+  return s + s2 + t + t2;\n+}\n+\n+__attribute__((noinline, noclone)) long int\n+bar (int *p, long int n, long int o)\n+{\n+  long int i, s = 0, s2 = 0, t, t2;\n+  #pragma omp simd aligned(a, b, p : 32) linear(k: m + 1) reduction(+:s) \\\n+\t\t   lastprivate (t2)\n+  for (i = 0; i < n; i++)\n+    {\n+      a[i] *= p[i];\n+      t2 = k + p[i];\n+      k += m + 1;\n+      s += p[i] + k;\n+      c[i]++;\n+    }\n+  #pragma omp simd aligned(a, b, p : 32) linear(k: m + 1) reduction(+:s2) \\\n+\t\t   lastprivate (t, u, u2, u3)\n+  for (i = n; i < o; i++)\n+    {\n+      a[i] *= p[i];\n+      k += m + 1;\n+      t = k + p[i];\n+      u = (__UINTPTR_TYPE__) &k;\n+      u2 = (__UINTPTR_TYPE__) &s2;\n+      u3 = (__UINTPTR_TYPE__) &t;\n+      s2 += t;\n+      c[i]++;\n+    }\n+  return s + s2 + t + t2;\n+}\n+\n+int\n+main ()\n+{\n+#if __SIZEOF_INT__ >= 4\n+  int i;\n+  k = 4;\n+  m = 2;\n+  for (i = 0; i < 1024; i++)\n+    {\n+      a[i] = i - 512;\n+      b[i] = (i - 51) % 39;\n+      c[i] = (unsigned char) i;\n+    }\n+  int s = foo (b);\n+  for (i = 0; i < 1024; i++)\n+    {\n+      if (b[i] != (i - 51) % 39\n+\t  || a[i] != (i - 512) * b[i]\n+\t  || c[i] != (unsigned char) (i + 1))\n+\tabort ();\n+      a[i] = i - 512;\n+    }\n+  if (k != 4 + 3 * 1024\n+      || s != 1596127 + (4 + 3 * 511 + b[511]) + (4 + 3 * 1024 + b[1023]))\n+    abort ();\n+  k = 4;\n+  s = bar (b, 512, 1024);\n+  for (i = 0; i < 1024; i++)\n+    {\n+      if (b[i] != (i - 51) % 39\n+\t  || a[i] != (i - 512) * b[i]\n+\t  || c[i] != (unsigned char) (i + 2))\n+\tabort ();\n+      a[i] = i - 512;\n+    }\n+  if (k != 4 + 3 * 1024\n+      || s != 1596127 + (4 + 3 * 511 + b[511]) + (4 + 3 * 1024 + b[1023]))\n+    abort ();\n+  k = 4;\n+  s = bar (b, 511, 1021);\n+  for (i = 0; i < 1021; i++)\n+    {\n+      if (b[i] != (i - 51) % 39\n+\t  || a[i] != (i - 512) * b[i]\n+\t  || c[i] != (unsigned char) (i + 3))\n+\tabort ();\n+      a[i] = i - 512;\n+    }\n+  for (i = 1021; i < 1024; i++)\n+    if (b[i] != (i - 51) % 39\n+\t|| a[i] != i - 512\n+\t|| c[i] != (unsigned char) (i + 2))\n+      abort ();\n+  if (k != 4 + 3 * 1021\n+      || s != 1586803 + (4 + 3 * 510 + b[510]) + (4 + 3 * 1021 + b[1020]))\n+    abort ();\n+#endif\n+  return 0;\n+}"}, {"sha": "bdfacc65264c9ca8863b0b8d332d9edffef3d477", "filename": "libgomp/testsuite/libgomp.c++/simd-4.C", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fsimd-4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fsimd-4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fsimd-4.C?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -0,0 +1,45 @@\n+// { dg-do run }\n+// { dg-options \"-O2\" }\n+// { dg-additional-options \"-msse2\" { target sse2_runtime } }\n+// { dg-additional-options \"-mavx\" { target avx_runtime } }\n+\n+extern \"C\" void abort ();\n+int a[1024] __attribute__((aligned (32))) = { 1 };\n+struct S\n+{\n+  int s;\n+  S () : s (0) {}\n+  ~S () {}\n+};\n+#pragma omp declare reduction (+:S:omp_out.s += omp_in.s)\n+#pragma omp declare reduction (foo:S:omp_out.s += omp_in.s)\n+#pragma omp declare reduction (foo:int:omp_out += omp_in)\n+\n+__attribute__((noinline, noclone)) int\n+foo ()\n+{\n+  int i, u = 0;\n+  S s, t;\n+  #pragma omp simd aligned(a : 32) reduction(+:s) reduction(foo:t, u)\n+  for (i = 0; i < 1024; i++)\n+    {\n+      int x = a[i];\n+      s.s += x;\n+      t.s += x;\n+      u += x;\n+    }\n+  if (t.s != s.s || u != s.s)\n+    abort ();\n+  return s.s;\n+}\n+\n+int\n+main ()\n+{\n+  int i;\n+  for (i = 0; i < 1024; i++)\n+    a[i] = (i & 31) + (i / 128);\n+  int s = foo ();\n+  if (s != 19456)\n+    abort ();\n+}"}, {"sha": "6c4627e210a2798164c9d6213e94c201b5d07ad9", "filename": "libgomp/testsuite/libgomp.c++/simd-5.C", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fsimd-5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fsimd-5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fsimd-5.C?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -0,0 +1,47 @@\n+// { dg-do run }\n+// { dg-options \"-O2\" }\n+// { dg-additional-options \"-msse2\" { target sse2_runtime } }\n+// { dg-additional-options \"-mavx\" { target avx_runtime } }\n+\n+extern \"C\" void abort ();\n+int a[1024] __attribute__((aligned (32))) = { 1 };\n+struct S\n+{\n+  int s;\n+  S () : s (0) {}\n+  ~S () {}\n+};\n+#pragma omp declare reduction (+:S:omp_out.s += omp_in.s)\n+#pragma omp declare reduction (foo:S:omp_out.s += omp_in.s)\n+#pragma omp declare reduction (foo:int:omp_out += omp_in)\n+\n+__attribute__((noinline, noclone)) int\n+foo ()\n+{\n+  int i, u = 0, q = 0;\n+  S s, t;\n+  #pragma omp simd aligned(a : 32) reduction(+:s, q) reduction(foo:t, u) \\\n+\t      safelen(1)\n+  for (i = 0; i < 1024; i++)\n+    {\n+      int x = a[i];\n+      s.s += x;\n+      t.s += x;\n+      u += x;\n+      q++;\n+    }\n+  if (t.s != s.s || u != s.s || q != 1024)\n+    abort ();\n+  return s.s;\n+}\n+\n+int\n+main ()\n+{\n+  int i;\n+  for (i = 0; i < 1024; i++)\n+    a[i] = (i & 31) + (i / 128);\n+  int s = foo ();\n+  if (s != 19456)\n+    abort ();\n+}"}, {"sha": "cfc13d0a0f92bb891e0245a4d434174a65a6c997", "filename": "libgomp/testsuite/libgomp.c++/simd-6.C", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fsimd-6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fsimd-6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fsimd-6.C?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -0,0 +1,70 @@\n+// { dg-do run }\n+// { dg-options \"-O2\" }\n+// { dg-additional-options \"-msse2\" { target sse2_runtime } }\n+// { dg-additional-options \"-mavx\" { target avx_runtime } }\n+\n+extern \"C\" void abort ();\n+int a[1024] __attribute__((aligned (32))) = { 1 };\n+struct S\n+{\n+  int s;\n+  S () : s (0) {}\n+  S (int x) : s (x) {}\n+  ~S () {}\n+};\n+#pragma omp declare reduction (+:S:omp_out.s += omp_in.s) \\\n+\t\t    initializer (omp_priv (0))\n+#pragma omp declare reduction (foo:S:omp_out.s += omp_in.s) \\\n+\t\t    initializer (omp_priv (0))\n+#pragma omp declare reduction (foo:int:omp_out += omp_in) \\\n+\t\t    initializer (omp_priv = 0)\n+\n+__attribute__((noinline, noclone)) S\n+foo (S s)\n+{\n+  int i, v = 0, &u = v;\n+  S t;\n+  #pragma omp simd aligned(a : 32) reduction(+:s) reduction(foo:t, u)\n+  for (i = 0; i < 1024; i++)\n+    {\n+      int x = a[i];\n+      s.s += x;\n+      t.s += x;\n+      u += x;\n+    }\n+  if (t.s != s.s || u != s.s)\n+    abort ();\n+  return t;\n+}\n+\n+__attribute__((noinline, noclone)) int\n+bar (S &s, S &t)\n+{\n+  int i, v = 0, &u = v;\n+  #pragma omp simd aligned(a : 32) reduction(+:s) reduction(foo:t, u)\n+  for (i = 0; i < 1024; i++)\n+    {\n+      int x = a[i];\n+      s.s += x;\n+      t.s += x;\n+      u += x;\n+    }\n+  if (t.s != s.s || u != s.s)\n+    abort ();\n+  return s.s;\n+}\n+\n+int\n+main ()\n+{\n+  int i;\n+  for (i = 0; i < 1024; i++)\n+    a[i] = (i & 31) + (i / 128);\n+  S q;\n+  int s = foo (q).s;\n+  if (s != 19456)\n+    abort ();\n+  S r, v;\n+  if (bar (r, v) != s)\n+    abort ();\n+}"}, {"sha": "5a6f4cef7c1c94cc78981fd664481fca6bfd5967", "filename": "libgomp/testsuite/libgomp.c++/simd-7.C", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fsimd-7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fsimd-7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fsimd-7.C?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -0,0 +1,72 @@\n+// { dg-do run }\n+// { dg-options \"-O2\" }\n+// { dg-additional-options \"-msse2\" { target sse2_runtime } }\n+// { dg-additional-options \"-mavx\" { target avx_runtime } }\n+\n+extern \"C\" void abort ();\n+int a[1024] __attribute__((aligned (32))) = { 1 };\n+struct S\n+{\n+  int s;\n+  S () : s (0) {}\n+  S (int x) : s (x) {}\n+  ~S () {}\n+};\n+#pragma omp declare reduction (+:S:omp_out.s += omp_in.s) \\\n+\t\t    initializer (omp_priv (0))\n+#pragma omp declare reduction (foo:S:omp_out.s += omp_in.s) \\\n+\t\t    initializer (omp_priv (0))\n+#pragma omp declare reduction (foo:int:omp_out += omp_in) \\\n+\t\t    initializer (omp_priv = 0)\n+\n+__attribute__((noinline, noclone)) S\n+foo (S s)\n+{\n+  int i, v = 0, &u = v;\n+  S t;\n+  #pragma omp simd aligned(a : 32) reduction(+:s) reduction(foo:t, u) \\\n+\t\t   safelen(1)\n+  for (i = 0; i < 1024; i++)\n+    {\n+      int x = a[i];\n+      s.s += x;\n+      t.s += x;\n+      u += x;\n+    }\n+  if (t.s != s.s || u != s.s)\n+    abort ();\n+  return t;\n+}\n+\n+__attribute__((noinline, noclone)) int\n+bar (S &s, S &t)\n+{\n+  int i, v = 0, &u = v;\n+  #pragma omp simd aligned(a : 32) reduction(+:s) reduction(foo:t, u) \\\n+\t\t   safelen(1)\n+  for (i = 0; i < 1024; i++)\n+    {\n+      int x = a[i];\n+      s.s += x;\n+      t.s += x;\n+      u += x;\n+    }\n+  if (t.s != s.s || u != s.s)\n+    abort ();\n+  return s.s;\n+}\n+\n+int\n+main ()\n+{\n+  int i;\n+  for (i = 0; i < 1024; i++)\n+    a[i] = (i & 31) + (i / 128);\n+  S q;\n+  int s = foo (q).s;\n+  if (s != 19456)\n+    abort ();\n+  S r, v;\n+  if (bar (r, v) != s)\n+    abort ();\n+}"}, {"sha": "7c75832852964f17e15de9d90f22269cd0089ea4", "filename": "libgomp/testsuite/libgomp.c++/simd-8.C", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fsimd-8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fsimd-8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fsimd-8.C?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -0,0 +1,47 @@\n+// PR libgomp/58482\n+// { dg-do run }\n+// { dg-options \"-O2\" }\n+// { dg-additional-options \"-msse2\" { target sse2_runtime } }\n+// { dg-additional-options \"-mavx\" { target avx_runtime } }\n+\n+extern \"C\" void abort ();\n+int a[1024] __attribute__((aligned (32))) = { 1 };\n+struct S\n+{\n+  int s;\n+  S () : s (0) {}\n+  ~S () {}\n+};\n+#pragma omp declare reduction (+:S:omp_out.s += omp_in.s)\n+#pragma omp declare reduction (foo:S:omp_out.s += omp_in.s)\n+#pragma omp declare reduction (foo:int:omp_out += omp_in)\n+\n+__attribute__((noinline, noclone)) int\n+foo ()\n+{\n+  int i, u = 0;\n+  S s, t;\n+  #pragma omp parallel for simd aligned(a : 32) reduction(+:s) \\\n+\t\t\t\treduction(foo:t, u)\n+  for (i = 0; i < 1024; i++)\n+    {\n+      int x = a[i];\n+      s.s += x;\n+      t.s += x;\n+      u += x;\n+    }\n+  if (t.s != s.s || u != s.s)\n+    abort ();\n+  return s.s;\n+}\n+\n+int\n+main ()\n+{\n+  int i;\n+  for (i = 0; i < 1024; i++)\n+    a[i] = (i & 31) + (i / 128);\n+  int s = foo ();\n+  if (s != 19456)\n+    abort ();\n+}"}, {"sha": "3cf01d9975d98a0c50f67b74dfb3c303c6b1dc08", "filename": "libgomp/testsuite/libgomp.c++/target-1.C", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-1.C?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -0,0 +1 @@\n+#include \"../libgomp.c/target-1.c\""}, {"sha": "b405404e6dc10e89a1ed9226e7c7d7e3cb4601d7", "filename": "libgomp/testsuite/libgomp.c++/target-2-aux.cc", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-2-aux.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-2-aux.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-2-aux.cc?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -0,0 +1,5 @@\n+double f[1024];\n+double (&fr) [1024] = f;\n+double gbuf[1024];\n+double *g = gbuf;\n+double *&gr = g;"}, {"sha": "83207cd51cd1a984aa2e68462385a175b9361ccd", "filename": "libgomp/testsuite/libgomp.c++/target-2.C", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-2.C?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -0,0 +1,58 @@\n+// { dg-options \"-O2 -fopenmp\" }\n+// { dg-additional-sources \"target-2-aux.cc\" }\n+\n+extern \"C\" void abort (void);\n+\n+void\n+fn1 (double *x, double *y, int z)\n+{\n+  int i;\n+  for (i = 0; i < z; i++)\n+    {\n+      x[i] = i & 31;\n+      y[i] = (i & 63) - 30;\n+    }\n+}\n+\n+double b[1024];\n+double (&br) [1024] = b;\n+double cbuf[1024];\n+double *c = cbuf;\n+double *&cr = c;\n+extern double (&fr) [1024];\n+extern double *&gr;\n+\n+double\n+fn2 (int x, double (&dr) [1024], double *&er)\n+{\n+  double s = 0;\n+  double h[1024];\n+  double (&hr) [1024] = h;\n+  double ibuf[1024];\n+  double *i = ibuf;\n+  double *&ir = i;\n+  int j;\n+  fn1 (hr + 2 * x, ir + 2 * x, x);\n+  #pragma omp target map(to: br[:x], cr[0:x], dr[x:x], er[x:x]) \\\n+\t\t     map(to: fr[0:x], gr[0:x], hr[2 * x:x], ir[2 * x:x])\n+    #pragma omp parallel for reduction(+:s)\n+      for (j = 0; j < x; j++)\n+\ts += br[j] * cr[j] + dr[x + j] + er[x + j]\n+\t     + fr[j] + gr[j] + hr[2 * x + j] + ir[2 * x + j];\n+  return s;\n+}\n+\n+int\n+main ()\n+{\n+  double d[1024];\n+  double ebuf[1024];\n+  double *e = ebuf;\n+  fn1 (br, cr, 128);\n+  fn1 (d + 128, e + 128, 128);\n+  fn1 (fr, gr, 128);\n+  double h = fn2 (128, d, e);\n+  if (h != 20416.0)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "2e4586feca0a38c89f3fc8f25d75d546a836344e", "filename": "libgomp/testsuite/libgomp.c++/target-3.C", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-3.C?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -0,0 +1 @@\n+#include \"../libgomp.c/target-2.c\""}, {"sha": "5129896613dce3257d25b35298c5a63f7d5962f3", "filename": "libgomp/testsuite/libgomp.c++/taskgroup-1.C", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftaskgroup-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftaskgroup-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftaskgroup-1.C?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -0,0 +1 @@\n+#include \"../libgomp.c/taskgroup-1.c\""}, {"sha": "c3ddd859ea47fd717febaf803350f8e1e79db8d3", "filename": "libgomp/testsuite/libgomp.c++/udr-1.C", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fudr-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fudr-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fudr-1.C?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -0,0 +1,82 @@\n+// { dg-do run }\n+\n+extern \"C\" void abort ();\n+\n+struct S\n+{\n+  int s;\n+  void foo (S &x) { s += x.s; }\n+  void foo (S &x, bool y) { s += x.s; if (y) abort (); }\n+  S (const S &x) { s = x.s + 1; }\n+  S (const S &x, bool y) { s = x.s + 2; if (y) abort (); }\n+  S () { s = 6; }\n+  ~S ();\n+};\n+\n+S::~S ()\n+{\n+  if (s < 6) abort ();\n+  s = -1;\n+  /* Ensure the above store is not DSEd.  */\n+  asm volatile (\"\" : : \"r\" (&s) : \"memory\");\n+}\n+\n+void\n+bar (S &x)\n+{\n+  if (x.s != 6) abort ();\n+  x.s = 15;\n+}\n+\n+#pragma omp declare reduction (foo: S: omp_out.foo (omp_in)) \\\n+\tinitializer (omp_priv (omp_orig, false))\n+#pragma omp declare reduction (foo: char, int, short: omp_out += omp_in - 4) \\\n+\tinitializer (omp_priv (4))\n+#pragma omp declare reduction (+: S: omp_out.foo (omp_in, false)) \\\n+\tinitializer (omp_priv (omp_orig))\n+\n+namespace N\n+{\n+  #pragma omp declare reduction (foo: S: omp_out.foo (omp_in)) \\\n+\tinitializer (::bar (omp_priv))\n+  namespace M {}\n+}\n+\n+int\n+main ()\n+{\n+  S a, b, c, s, t, u;\n+  if (a.s != 6 || b.s != 6 || c.s != 6\n+      || s.s != 6 || t.s != 6 || u.s != 6) abort ();\n+  s.s = 9; t.s = 10; u.s = 11;\n+  int d = 0, e = 0, f = 0, g = 0, h = 30, v = 2, q = 0;\n+  #pragma omp declare reduction (foo: S: omp_out.foo (omp_in, true)) \\\n+\tinitializer (omp_priv = omp_orig)\n+  {\n+    #pragma omp declare reduction (foo: S: omp_out.foo (omp_in, false)) \\\n+\tinitializer (omp_priv = omp_orig)\n+    #pragma omp parallel num_threads (4) reduction (N::operator +: q) \\\n+\treduction (operator +: a, d) reduction (::operator +: b, e) \\\n+\treduction (+: c, f) reduction (::N::M::operator +: g) \\\n+\treduction (::N::min: h) reduction (foo: s) reduction (N::foo: t) \\\n+\treduction (::foo: u) reduction (::foo: v)\n+    {\n+      if (a.s != 7 || b.s != 7 || c.s != 7\n+\t  || s.s != 10 || t.s != 15 || u.s != 13\n+\t  || v != 4 || d || e || f || g || h != __INT_MAX__) abort ();\n+      asm volatile (\"\" : \"+m\" (a.s), \"+m\" (b.s));\n+      asm volatile (\"\" : \"+m\" (c.s), \"+r\" (d));\n+      asm volatile (\"\" : \"+r\" (e), \"+r\" (f));\n+      asm volatile (\"\" : \"+r\" (g), \"+r\" (h));\n+      asm volatile (\"\" : \"+m\" (s.s), \"+m\" (t.s));\n+      asm volatile (\"\" : \"+m\" (u.s), \"+r\" (v));\n+      a.s++; b.s++; c.s++; d++; e++; f++; g++; h = t.s;\n+      s.s++; t.s++; u.s++; v++; q++;\n+    }\n+  }\n+  if (a.s != 6 + q * 8 || b.s != 6 + q * 8 || c.s != 6 + q * 8\n+      || d != q || e != q || f != q || g != q || h != 15\n+      || s.s != 9 + q * 11 || t.s != 10 + q * 16 || u.s != 11 + q * 14\n+      || v != 2 + q)\n+    abort ();\n+}"}, {"sha": "5408be146bdc13a8ab5f707e1e85202dd0f23c7d", "filename": "libgomp/testsuite/libgomp.c++/udr-2.C", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fudr-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fudr-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fudr-2.C?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -0,0 +1,88 @@\n+// { dg-do run }\n+\n+extern \"C\" void abort ();\n+\n+namespace NS\n+{\n+  struct U\n+  {\n+    void foo (U &, bool);\n+    U ();\n+  };\n+  struct S\n+  {\n+    int s;\n+    #pragma omp declare reduction (foo : U, S : omp_out.foo (omp_in, false))\n+    #pragma omp declare reduction (foo : int : omp_out += omp_in) \\\n+\tinitializer (omp_priv = int ())\n+    void baz (int v)\n+    {\n+      S s;\n+      int q = 0;\n+      if (s.s != 6 || v != 0) abort ();\n+      s.s = 20;\n+      #pragma omp parallel num_threads (4) reduction (foo : s, v) \\\n+\treduction (::NS::U::operator + : q)\n+      {\n+\tif (s.s != 6 || q != 0 || v != 0) abort ();\n+\tasm volatile (\"\" : \"+m\" (s.s), \"+r\" (q), \"+r\" (v));\n+\ts.s++; q++; v++;\n+      }\n+      if (s.s != 20 + q * 7 || q != v) abort ();\n+    }\n+    void foo (S &x) { s += x.s; }\n+    void foo (S &x, bool y) { s += x.s; if (y) abort (); }\n+    S (const S &x) { s = x.s + 1; }\n+    S (const S &x, bool y) { s = x.s + 2; if (y) abort (); }\n+    S () { s = 6; }\n+    S (int x) { s = x; }\n+    ~S ();\n+  };\n+  #pragma omp declare reduction (bar : S : omp_out.foo (omp_in)) \\\n+\tinitializer (omp_priv (8))\n+}\n+\n+NS::S::~S ()\n+{\n+  if (s < 6) abort ();\n+  s = -1;\n+  /* Ensure the above store is not DSEd.  */\n+  asm volatile (\"\" : : \"r\" (&s) : \"memory\");\n+}\n+\n+struct T : public NS::S\n+{\n+  void baz ()\n+  {\n+    S s;\n+    int q = 0;\n+    if (s.s != 6) abort ();\n+    #pragma omp parallel num_threads (4) reduction (foo:s) \\\n+\treduction (+: q)\n+    {\n+      if (s.s != 6 || q != 0) abort ();\n+      asm volatile (\"\" : \"+m\" (s.s), \"+r\" (q));\n+      s.s += 2; q++;\n+    }\n+    if (s.s != 6 + q * 8) abort ();\n+  }\n+};\n+\n+int\n+main ()\n+{\n+  NS::S s;\n+  s.baz (0);\n+  T t;\n+  t.baz ();\n+  int q = 0;\n+  if (s.s != 6) abort ();\n+  // Test ADL\n+  #pragma omp parallel num_threads (4) reduction (bar:s) reduction (+:q)\n+  {\n+    if (s.s != 8 || q != 0) abort ();\n+    asm volatile (\"\" : \"+m\" (s.s), \"+r\" (q));\n+    s.s += 4; q++;\n+  }\n+  if (s.s != 6 + q * 12) abort ();\n+}"}, {"sha": "74a01389c7b196e66719194b222f20d2f5105cf5", "filename": "libgomp/testsuite/libgomp.c++/udr-3.C", "status": "added", "additions": 149, "deletions": 0, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fudr-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fudr-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fudr-3.C?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -0,0 +1,149 @@\n+// { dg-do run }\n+\n+extern \"C\" void abort ();\n+\n+void\n+dblinit (double *p)\n+{\n+  *p = 2.0;\n+}\n+\n+namespace NS\n+{\n+  template <int N>\n+  struct U\n+  {\n+    void foo (U &, bool);\n+    U ();\n+  };\n+  template <int N>\n+  struct S\n+  {\n+    int s;\n+    #pragma omp declare reduction (foo : U<0>, S : omp_out.foo (omp_in, false))\n+    #pragma omp declare reduction (foo : int : omp_out += omp_in) \\\n+\tinitializer (omp_priv = N + 2)\n+    #pragma omp declare reduction (foo : double : omp_out += omp_in) \\\n+\tinitializer (dblinit (&omp_priv))\n+    void baz (int v)\n+    {\n+      S s;\n+      int q = 0;\n+      if (s.s != 6 || v != 0) abort ();\n+      s.s = 20;\n+      double d = 4.0;\n+      #pragma omp parallel num_threads (4) reduction (foo : s, v, d) \\\n+\treduction (::NS::U<N>::operator + : q)\n+      {\n+\tif (s.s != 6 || q != 0 || v != N + 2 || d != 2.0) abort ();\n+\tasm volatile (\"\" : \"+m\" (s.s), \"+r\" (q), \"+r\" (v));\n+\ts.s++; q++; v++;\n+      }\n+      if (s.s != 20 + q * 7 || (N + 3) * q != v || d != 4.0 + 2.0 * q)\n+\tabort ();\n+    }\n+    void foo (S &x) { s += x.s; }\n+    void foo (S &x, bool y) { s += x.s; if (y) abort (); }\n+    S (const S &x) { s = x.s + 1; }\n+    S (const S &x, bool y) { s = x.s + 2; if (y) abort (); }\n+    S () { s = 6; }\n+    S (int x) { s = x; }\n+    ~S ();\n+  };\n+  #pragma omp declare reduction (bar : S<1> : omp_out.foo (omp_in)) \\\n+\tinitializer (omp_priv (8))\n+}\n+\n+template <int N>\n+NS::S<N>::~S ()\n+{\n+  if (s < 6) abort ();\n+  s = -1;\n+  /* Ensure the above store is not DSEd.  */\n+  asm volatile (\"\" : : \"r\" (&s) : \"memory\");\n+}\n+\n+template <int N>\n+struct T : public NS::S<N>\n+{\n+  void baz ()\n+  {\n+    NS::S<N> s;\n+    int q = 0;\n+    if (s.s != 6) abort ();\n+    #pragma omp parallel num_threads (4) reduction (foo:s) \\\n+\treduction (+: q)\n+    {\n+      if (s.s != 6 || q != 0) abort ();\n+      asm volatile (\"\" : \"+m\" (s.s), \"+r\" (q));\n+      s.s += 2; q++;\n+    }\n+    if (s.s != 6 + q * 8) abort ();\n+  }\n+};\n+\n+struct W\n+{\n+  int v;\n+  W () : v (6) {}\n+  ~W () {}\n+};\n+\n+template <typename T, typename D>\n+struct V\n+{\n+  #pragma omp declare reduction (baz: T: omp_out.s += omp_in.s) \\\n+\tinitializer (omp_priv (11))\n+  #pragma omp declare reduction (baz: D: omp_out += omp_in) \\\n+\tinitializer (dblinit (&omp_priv))\n+  static void dblinit (D *x) { *x = 3.0; }\n+  void baz ()\n+  {\n+    T t;\n+    V v;\n+    int q = 0;\n+    D d = 4.0;\n+    if (t.s != 6 || v.v != 4) abort ();\n+    #pragma omp declare reduction (+ : V, W : omp_out.v -= omp_in.v) \\\n+\tinitializer (omp_priv (12))\n+    {\n+      #pragma omp declare reduction (+ : W, V : omp_out.v += omp_in.v) \\\n+\tinitializer (omp_priv (9))\n+      #pragma omp parallel num_threads (4) reduction (+: v, q) \\\n+\treduction (baz: t, d)\n+      {\n+\tif (t.s != 11 || v.v != 9 || q != 0 || d != 3.0) abort ();\n+\tasm volatile (\"\" : \"+m\" (t.s), \"+m\" (v.v), \"+r\" (q));\n+\tt.s += 2; v.v += 3; q++;\n+      }\n+      if (t.s != 6 + 13 * q || v.v != 4 + 12 * q || d != 4.0 + 3.0 * q)\n+\tabort ();\n+    }\n+  }\n+  int v;\n+  V () : v (4) {}\n+  V (int x) : v (x) {}\n+  ~V () {}\n+};\n+\n+int\n+main ()\n+{\n+  NS::S<0> u;\n+  u.baz (0);\n+  T<2> t;\n+  t.baz ();\n+  NS::S<1> s;\n+  int q = 0;\n+  if (s.s != 6) abort ();\n+  // Test ADL\n+  #pragma omp parallel num_threads (4) reduction (bar:s) reduction (+:q)\n+  {\n+    if (s.s != 8 || q != 0) abort ();\n+    asm volatile (\"\" : \"+m\" (s.s), \"+r\" (q));\n+    s.s += 4; q++;\n+  }\n+  if (s.s != 6 + q * 12) abort ();\n+  V <NS::S <0>, double> v;\n+  v.baz ();\n+}"}, {"sha": "3e717467a0efb73e44a430cec5136c3a157c1501", "filename": "libgomp/testsuite/libgomp.c++/udr-4.C", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fudr-4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fudr-4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fudr-4.C?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -0,0 +1,32 @@\n+// { dg-do run }\n+\n+extern \"C\" void abort ();\n+\n+struct S\n+{\n+  int s;\n+  S () : s (0) {}\n+  ~S () {}\n+};\n+\n+#pragma omp declare reduction (+:S:omp_out.s += omp_in.s)\n+#pragma omp declare reduction (foo:S:omp_out.s += omp_in.s)\n+#pragma omp declare reduction (foo:int:omp_out += omp_in)\n+\n+int\n+main ()\n+{\n+  int i, u = 0, q = 0;\n+  S s, t;\n+  if (s.s != 0 || t.s != 0) abort ();\n+  #pragma omp parallel reduction(+:s, q) reduction(foo:t, u)\n+  {\n+    if (s.s != 0 || t.s != 0 || u != 0 || q != 0) abort ();\n+    s.s = 6;\n+    t.s = 8;\n+    u = 9;\n+    q++;\n+  }\n+  if (s.s != 6 * q || t.s != 8 * q || u != 9 * q) abort ();\n+  return 0;\n+}"}, {"sha": "91ae2f697c3d48030a0ceeec9c323ba67f2def56", "filename": "libgomp/testsuite/libgomp.c++/udr-5.C", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fudr-5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fudr-5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fudr-5.C?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530", "patch": "@@ -0,0 +1,49 @@\n+// { dg-do run }\n+\n+extern \"C\" void abort ();\n+\n+struct S\n+{\n+  void foo ()\n+  {\n+    S s;\n+    int j = 0;\n+    #pragma omp declare reduction (bar : int : omp_out += omp_in)\n+    #pragma omp parallel reduction (bar : s) reduction(S::operator+ : j)\n+    s.a = 4, j = 1;\n+    if (s.a != 4 * j) abort ();\n+  }\n+  #pragma omp declare reduction (bar : S : baz (omp_out, omp_in))\n+  static void baz (S &x, S &y) { x.a += y.a; }\n+  S () : a (0) {}\n+  int a;\n+};\n+\n+template <int N>\n+struct T\n+{\n+  void foo ()\n+  {\n+    S s;\n+    T t;\n+    int j = 0;\n+    #pragma omp declare reduction (bar : int : omp_out += omp_in)\n+    #pragma omp parallel reduction (bar : t) reduction (S::bar : s) \\\n+\t\t\t reduction(T<N>::operator+ : j)\n+    s.a = 4, t.a = 5, j = 1;\n+    if (s.a != 4 * j || t.a != 5 * j) abort ();\n+  }\n+  #pragma omp declare reduction (bar : T<N> : baz (omp_out, omp_in))\n+  static void baz (T &x, T &y) { x.a += y.a; }\n+  T () : a (N) {}\n+  int a;\n+};\n+\n+int\n+main ()\n+{\n+  S s;\n+  s.foo ();\n+  T<0> t;\n+  t.foo ();\n+}"}, {"sha": "4be821ed0db05068daf116294a7ba58e3fdfd054", "filename": "libgomp/testsuite/libgomp.c++/udr-6.C", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fudr-6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fudr-6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fudr-6.C?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530"}, {"sha": "6f661895a379308cb8244cb41a1d8e405d44f00e", "filename": "libgomp/testsuite/libgomp.c++/udr-7.C", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fudr-7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fudr-7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fudr-7.C?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530"}, {"sha": "81c4beb8b6eb76e2c021db73918b5cce23a68776", "filename": "libgomp/testsuite/libgomp.c++/udr-8.C", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fudr-8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fudr-8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fudr-8.C?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530"}, {"sha": "58fea18a4ceffa556b5c1b9e9c49dbdb3163271f", "filename": "libgomp/testsuite/libgomp.c++/udr-9.C", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fudr-9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fudr-9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fudr-9.C?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530"}, {"sha": "5d3e45d1df9b7667935e72e42867f35fa268ccc6", "filename": "libgomp/testsuite/libgomp.c/affinity-1.c", "status": "added", "additions": 1146, "deletions": 0, "changes": 1146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2Faffinity-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2Faffinity-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Faffinity-1.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530"}, {"sha": "9046d80220d4c3a562fac77b64daa9a2ecf2b8f3", "filename": "libgomp/testsuite/libgomp.c/atomic-14.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2Fatomic-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2Fatomic-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fatomic-14.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530"}, {"sha": "58331f4a90bfd16fc2148654c102d308fbd8acaf", "filename": "libgomp/testsuite/libgomp.c/atomic-15.c", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2Fatomic-15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2Fatomic-15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fatomic-15.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530"}, {"sha": "d33f670ec1f5a2382f61d9d5763c10680ec20183", "filename": "libgomp/testsuite/libgomp.c/atomic-16.c", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2Fatomic-16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2Fatomic-16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fatomic-16.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530"}, {"sha": "2bd0e9b44dc9c241dce5f5fd1471750020715de6", "filename": "libgomp/testsuite/libgomp.c/atomic-17.c", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2Fatomic-17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2Fatomic-17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fatomic-17.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530"}, {"sha": "f805f13642f547c20e9c68b802d02e199d0ffabe", "filename": "libgomp/testsuite/libgomp.c/cancel-for-1.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2Fcancel-for-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2Fcancel-for-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fcancel-for-1.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530"}, {"sha": "30cfbb1c502bff11c0aa65e2ec9e90bf7c04b29a", "filename": "libgomp/testsuite/libgomp.c/cancel-for-2.c", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2Fcancel-for-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2Fcancel-for-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fcancel-for-2.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530"}, {"sha": "614eb50f0d6ef234fbbd3b0f140a283d0feb5b27", "filename": "libgomp/testsuite/libgomp.c/cancel-parallel-1.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2Fcancel-parallel-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2Fcancel-parallel-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fcancel-parallel-1.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530"}, {"sha": "cae0aa45c0f8152565c8d90fec46914f178e4b61", "filename": "libgomp/testsuite/libgomp.c/cancel-parallel-2.c", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2Fcancel-parallel-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2Fcancel-parallel-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fcancel-parallel-2.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530"}, {"sha": "7ceaed1846753f717e7a3c08d82508ec62bb3c0b", "filename": "libgomp/testsuite/libgomp.c/cancel-parallel-3.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2Fcancel-parallel-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2Fcancel-parallel-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fcancel-parallel-3.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530"}, {"sha": "e0cef0b6ea7ea1fe378554b3d8cce1684145ed76", "filename": "libgomp/testsuite/libgomp.c/cancel-sections-1.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2Fcancel-sections-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2Fcancel-sections-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fcancel-sections-1.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530"}, {"sha": "5a808113fb07092c2b316c2d25b7b2ef66ce1c82", "filename": "libgomp/testsuite/libgomp.c/cancel-taskgroup-1.c", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2Fcancel-taskgroup-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2Fcancel-taskgroup-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fcancel-taskgroup-1.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530"}, {"sha": "c7b8bf756237cd470cc8b81a2842e5bbf24b2d33", "filename": "libgomp/testsuite/libgomp.c/cancel-taskgroup-2.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2Fcancel-taskgroup-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2Fcancel-taskgroup-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fcancel-taskgroup-2.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530"}, {"sha": "2db1205c12a083465a09666ce04679784fd689cb", "filename": "libgomp/testsuite/libgomp.c/depend-1.c", "status": "added", "additions": 215, "deletions": 0, "changes": 215, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2Fdepend-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2Fdepend-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fdepend-1.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530"}, {"sha": "2772309e4b8de7592995eac261654cd84a4c094d", "filename": "libgomp/testsuite/libgomp.c/depend-2.c", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2Fdepend-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2Fdepend-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fdepend-2.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530"}, {"sha": "d565d6e461926e8178e7e3e1efaed3aeece1761d", "filename": "libgomp/testsuite/libgomp.c/depend-3.c", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2Fdepend-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2Fdepend-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fdepend-3.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530"}, {"sha": "a4395ea6fc0ce573583eb2f312b0758ec1d0c414", "filename": "libgomp/testsuite/libgomp.c/depend-4.c", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2Fdepend-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2Fdepend-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fdepend-4.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530"}, {"sha": "e702453fb1a6360ad924663aac42d8533c2abf68", "filename": "libgomp/testsuite/libgomp.c/for-1.c", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2Ffor-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2Ffor-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Ffor-1.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530"}, {"sha": "fa82c5b20d74365eabcb39b2402e1d15146b26c2", "filename": "libgomp/testsuite/libgomp.c/for-1.h", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2Ffor-1.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2Ffor-1.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Ffor-1.h?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530"}, {"sha": "f5a01ab05ec32378e91d45302f9612674544c49b", "filename": "libgomp/testsuite/libgomp.c/for-2.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2Ffor-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2Ffor-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Ffor-2.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530"}, {"sha": "57c385ec8764003e57a565a9808f8e796b62ba6d", "filename": "libgomp/testsuite/libgomp.c/for-2.h", "status": "added", "additions": 269, "deletions": 0, "changes": 269, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2Ffor-2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2Ffor-2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Ffor-2.h?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530"}, {"sha": "06cbf4f9de10b6f2c4d75ded8c4abba350379276", "filename": "libgomp/testsuite/libgomp.c/for-3.c", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2Ffor-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2Ffor-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Ffor-3.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530"}, {"sha": "6ca97adc2d3f2c0d892aa7db25e0004e5a1eb0e1", "filename": "libgomp/testsuite/libgomp.c/pr58392.c", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2Fpr58392.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2Fpr58392.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fpr58392.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530"}, {"sha": "352b3b7ddd4c17245d4c8f9cc594b605671e3e63", "filename": "libgomp/testsuite/libgomp.c/simd-1.c", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2Fsimd-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2Fsimd-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fsimd-1.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530"}, {"sha": "b485fcb6f6f6db511005ec68db61c8732ace87c0", "filename": "libgomp/testsuite/libgomp.c/simd-2.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2Fsimd-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2Fsimd-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fsimd-2.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530"}, {"sha": "34a388301434a07dc09dd6273a6c4ccdb038b275", "filename": "libgomp/testsuite/libgomp.c/simd-3.c", "status": "added", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2Fsimd-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2Fsimd-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fsimd-3.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530"}, {"sha": "fd87c7e1fa75656ff5f16379c52841d660493056", "filename": "libgomp/testsuite/libgomp.c/simd-4.c", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2Fsimd-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2Fsimd-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fsimd-4.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530"}, {"sha": "0b6d41e635614617758de84a9b9e0fa250d60a4d", "filename": "libgomp/testsuite/libgomp.c/simd-5.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2Fsimd-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2Fsimd-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fsimd-5.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530"}, {"sha": "896f34784f2155357d12b9dd29e170ce57ac2ea2", "filename": "libgomp/testsuite/libgomp.c/simd-6.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2Fsimd-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2Fsimd-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fsimd-6.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530"}, {"sha": "f734d3c279dcd9e07b93e1ba21300e5fd4378566", "filename": "libgomp/testsuite/libgomp.c/target-1.c", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-1.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530"}, {"sha": "ada8dad81adbecbbe259d977be4c5785915a53ce", "filename": "libgomp/testsuite/libgomp.c/target-2.c", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-2.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530"}, {"sha": "7002cf287f92900c16cecebaab514a458f5eae71", "filename": "libgomp/testsuite/libgomp.c/target-3.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-3.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530"}, {"sha": "26e935b3673028161695dacd9c51655c8190c1e9", "filename": "libgomp/testsuite/libgomp.c/target-4.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-4.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530"}, {"sha": "436744359cae0b30882a27c84827a709d62ab814", "filename": "libgomp/testsuite/libgomp.c/target-5.c", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-5.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530"}, {"sha": "ea35aa465f500a1577b6a4bac6a22be8eae0c6b0", "filename": "libgomp/testsuite/libgomp.c/target-6.c", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-6.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530"}, {"sha": "90de6c523117b7233e52883d0444e7eccd1183bd", "filename": "libgomp/testsuite/libgomp.c/target-7.c", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-7.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530"}, {"sha": "641a3bc0f2ce55f910a4f004db3ef55b6b573d31", "filename": "libgomp/testsuite/libgomp.c/taskgroup-1.c", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2Ftaskgroup-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2Ftaskgroup-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Ftaskgroup-1.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530"}, {"sha": "6cc716bee89f2e21b0344bb8bdfd47da090964b4", "filename": "libgomp/testsuite/libgomp.c/thread-limit-1.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2Fthread-limit-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2Fthread-limit-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fthread-limit-1.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530"}, {"sha": "0fc9dae0fd1d870d75effa1cde25773bdd965a9e", "filename": "libgomp/testsuite/libgomp.c/thread-limit-2.c", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2Fthread-limit-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2Fthread-limit-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fthread-limit-2.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530"}, {"sha": "af9bd7887abdc0915d8fb775b8db68d79a42db7f", "filename": "libgomp/testsuite/libgomp.c/thread-limit-3.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2Fthread-limit-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2Fthread-limit-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fthread-limit-3.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530"}, {"sha": "ea9da72526e5151941f199f5d0c51eb7036ba8f5", "filename": "libgomp/testsuite/libgomp.c/udr-1.c", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2Fudr-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2Fudr-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fudr-1.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530"}, {"sha": "b58b5c781ab893578bcb86b95a6baefcbbe865f5", "filename": "libgomp/testsuite/libgomp.c/udr-2.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2Fudr-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2Fudr-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fudr-2.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530"}, {"sha": "e0a5b8764df3c8fdd7750b60e00949ca48c9fce3", "filename": "libgomp/testsuite/libgomp.c/udr-3.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2Fudr-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Ftestsuite%2Flibgomp.c%2Fudr-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fudr-3.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530"}, {"sha": "9c5a327263b5ce4f514ad9028448f384aed7547f", "filename": "libgomp/work.c", "status": "modified", "additions": 34, "deletions": 2, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Fwork.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf0174b6f7a3f8fe1e2a27361bbf87dfe454530/libgomp%2Fwork.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fwork.c?ref=acf0174b6f7a3f8fe1e2a27361bbf87dfe454530"}]}