{"sha": "fb9fb29034ae7d09acac8e06246e061040c15c98", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmI5ZmIyOTAzNGFlN2QwOWFjYWM4ZTA2MjQ2ZTA2MTA0MGMxNWM5OA==", "commit": {"author": {"name": "Sebastian Pop", "email": "sebastian.pop@amd.com", "date": "2009-08-12T14:30:06Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2009-08-12T14:30:06Z"}, "message": "Reimplement interchange heuristic.\n\n2009-08-11  Sebastian Pop  <sebastian.pop@amd.com>\n\t    Pranav Garg  <pranav.garg2107@gmail.com>\n\n\t* graphite-interchange.c (gather_access_strides): Removed.\n\t(ppl_max_for_le): New.\n\t(build_linearized_memory_access): New.\n\t(memory_stride_in_loop): New.\n\t(pbb_interchange_profitable_p): Reimplemented.\n\t* graphite-ppl.h (ppl_new_id_map): New.\n\t(ppl_interchange): New.\n\n\t* testsuite/gcc.dg/graphite/interchange-6.c: XFAILed.\n\n\nCo-Authored-By: Pranav Garg <pranav.garg2107@gmail.com>\n\nFrom-SVN: r150692", "tree": {"sha": "f0bff5b8609d31cd4deec4fcf85361ab632abd52", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f0bff5b8609d31cd4deec4fcf85361ab632abd52"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fb9fb29034ae7d09acac8e06246e061040c15c98", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb9fb29034ae7d09acac8e06246e061040c15c98", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fb9fb29034ae7d09acac8e06246e061040c15c98", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb9fb29034ae7d09acac8e06246e061040c15c98/comments", "author": null, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "312aea7f99c563d62878f20ab39985b2a514c586", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/312aea7f99c563d62878f20ab39985b2a514c586", "html_url": "https://github.com/Rust-GCC/gccrs/commit/312aea7f99c563d62878f20ab39985b2a514c586"}], "stats": {"total": 303, "additions": 281, "deletions": 22}, "files": [{"sha": "5c40f970e754a99a4b836a8e91d722a2eff12554", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb9fb29034ae7d09acac8e06246e061040c15c98/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb9fb29034ae7d09acac8e06246e061040c15c98/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fb9fb29034ae7d09acac8e06246e061040c15c98", "patch": "@@ -1,3 +1,14 @@\n+2009-08-12  Sebastian Pop  <sebastian.pop@amd.com>\n+\t    Pranav Garg  <pranav.garg2107@gmail.com>\n+\n+\t* graphite-interchange.c (gather_access_strides): Removed.\n+\t(ppl_max_for_le): New.\n+\t(build_linearized_memory_access): New.\n+\t(memory_stride_in_loop): New.\n+\t(pbb_interchange_profitable_p): Reimplemented.\n+\t* graphite-ppl.h (ppl_new_id_map): New.\n+\t(ppl_interchange): New.\n+\n 2009-08-12  Sebastian Pop  <sebastian.pop@amd.com>\n \n \t* graphite-interchange.c (compute_subscript): Removed."}, {"sha": "a5fc5387fa39a4eba9870d1d4661cbf609e833b0", "filename": "gcc/ChangeLog.graphite", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb9fb29034ae7d09acac8e06246e061040c15c98/gcc%2FChangeLog.graphite", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb9fb29034ae7d09acac8e06246e061040c15c98/gcc%2FChangeLog.graphite", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog.graphite?ref=fb9fb29034ae7d09acac8e06246e061040c15c98", "patch": "@@ -1,3 +1,16 @@\n+2009-08-11  Sebastian Pop  <sebastian.pop@amd.com>\n+\t    Pranav Garg  <pranav.garg2107@gmail.com>\n+\n+\t* graphite-interchange.c (gather_access_strides): Removed.\n+\t(ppl_max_for_le): New.\n+\t(build_linearized_memory_access): New.\n+\t(memory_stride_in_loop): New.\n+\t(pbb_interchange_profitable_p): Reimplemented.\n+\t* graphite-ppl.h (ppl_new_id_map): New.\n+\t(ppl_interchange): New.\n+\n+\t* testsuite/gcc.dg/graphite/interchange-6.c: XFAILed.\n+\n 2009-08-11  Sebastian Pop  <sebastian.pop@amd.com>\n \n \t* graphite-interchange.c (compute_subscript): Removed."}, {"sha": "c9da69be76e5f0b58813a525e84980c86ab6d70e", "filename": "gcc/graphite-interchange.c", "status": "modified", "additions": 225, "deletions": 21, "changes": 246, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb9fb29034ae7d09acac8e06246e061040c15c98/gcc%2Fgraphite-interchange.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb9fb29034ae7d09acac8e06246e061040c15c98/gcc%2Fgraphite-interchange.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-interchange.c?ref=fb9fb29034ae7d09acac8e06246e061040c15c98", "patch": "@@ -53,47 +53,251 @@ along with GCC; see the file COPYING3.  If not see\n #include \"graphite.h\"\n #include \"graphite-poly.h\"\n \n-/* Computes ACCESS_STRIDES, the sum of all the strides of PDR at\n-   LOOP_DEPTH.  */\n+/* Return in RES the maximum of the linear expression LE on polyhedron PS.  */\n \n static void\n-gather_access_strides (poly_dr_p pdr ATTRIBUTE_UNUSED,\n-\t\t       graphite_dim_t loop_depth ATTRIBUTE_UNUSED,\n-\t\t       Value access_strides ATTRIBUTE_UNUSED)\n+ppl_max_for_le (ppl_Pointset_Powerset_C_Polyhedron_t ps,\n+\t\tppl_Linear_Expression_t le, Value res)\n {\n-  /* Empty for now.  */\n+  ppl_Coefficient_t num, denom;\n+  Value dv, nv;\n+  int maximum;\n+\n+  value_init (nv);\n+  value_init (dv);\n+  ppl_new_Coefficient (&num);\n+  ppl_new_Coefficient (&denom);\n+  ppl_Pointset_Powerset_C_Polyhedron_maximize (ps, le, num, denom, &maximum);\n+\n+  if (maximum)\n+    {\n+      ppl_Coefficient_to_mpz_t (num, nv);\n+      ppl_Coefficient_to_mpz_t (denom, dv);\n+      value_division (res, nv, dv);\n+    }\n+\n+  value_clear (nv);\n+  value_clear (dv);\n+  ppl_delete_Coefficient (num);\n+  ppl_delete_Coefficient (denom);\n+}\n+\n+/* Builds a linear expression, of dimension DIM, representing PDR's\n+   memory access:\n+\n+   L = r_{n}*r_{n-1}*...*r_{1}*s_{0} + ... + r_{n}*s_{n-1} + s_{n}.\n+\n+   For an array A[10][20] with two subscript locations s0 and s1, the\n+   linear memory access is 20 * s0 + s1: a stride of 1 in subscript s0\n+   corresponds to a memory stride of 20.  */\n+\n+static ppl_Linear_Expression_t\n+build_linearized_memory_access (poly_dr_p pdr)\n+{\n+  ppl_Linear_Expression_t res;\n+  ppl_Linear_Expression_t le;\n+  ppl_dimension_type i;\n+  ppl_dimension_type first = pdr_subscript_dim (pdr, 0);\n+  ppl_dimension_type last = pdr_subscript_dim (pdr, PDR_NB_SUBSCRIPTS (pdr));\n+  Value size, sub_size;\n+  graphite_dim_t dim = pdr_dim (pdr);\n+\n+  ppl_new_Linear_Expression_with_dimension (&res, dim);\n+\n+  value_init (size);\n+  value_set_si (size, 1);\n+  value_init (sub_size);\n+  value_set_si (sub_size, 1);\n+\n+  for (i = last - 1; i >= first; i--)\n+    {\n+      ppl_set_coef_gmp (res, i, size);\n+\n+      ppl_new_Linear_Expression_with_dimension (&le, dim);\n+      ppl_set_coef (le, i, 1);\n+      ppl_max_for_le (PDR_ACCESSES (pdr), le, sub_size);\n+      value_multiply (size, size, sub_size);\n+      ppl_delete_Linear_Expression (le);\n+    }\n+\n+  value_clear (sub_size);\n+  value_clear (size);\n+  return res;\n }\n \n-/* Returns true when it is profitable to interchange loop at depth1\n-   and loop at depth2 with depth1 < depth2 for the polyhedral black\n-   box PBB.  */\n+/* Set STRIDE to the stride of PDR in memory by advancing by one in\n+   loop DEPTH.  */\n+\n+static void\n+memory_stride_in_loop (Value stride, graphite_dim_t depth, poly_dr_p pdr)\n+{\n+  ppl_Linear_Expression_t le, lma;\n+  ppl_Constraint_t new_cstr;\n+  ppl_Pointset_Powerset_C_Polyhedron_t p1, p2;\n+  graphite_dim_t nb_subscripts = PDR_NB_SUBSCRIPTS (pdr);\n+  ppl_dimension_type i, *map;\n+  ppl_dimension_type dim = pdr_dim (pdr);\n+  ppl_dimension_type dim_i = pdr_iterator_dim (pdr, depth);\n+  ppl_dimension_type dim_k = dim;\n+  ppl_dimension_type dim_L1 = dim + nb_subscripts + 1;\n+  ppl_dimension_type dim_L2 = dim + nb_subscripts + 2;\n+  ppl_dimension_type new_dim = dim + nb_subscripts + 3;\n+\n+  /* Add new dimensions to the polyhedron corresponding to\n+     k, s0', s1',..., L1, and L2.  These new variables are at\n+     dimensions dim, dim + 1,... of the polyhedron P1 respectively.  */\n+  ppl_new_Pointset_Powerset_C_Polyhedron_from_Pointset_Powerset_C_Polyhedron\n+    (&p1, PDR_ACCESSES (pdr));\n+  ppl_Pointset_Powerset_C_Polyhedron_add_space_dimensions_and_embed\n+    (p1, nb_subscripts + 3);\n+\n+  lma = build_linearized_memory_access (pdr);\n+  ppl_set_coef (lma, dim_L1, -1);\n+  ppl_new_Constraint (&new_cstr, lma, PPL_CONSTRAINT_TYPE_EQUAL);\n+  ppl_Pointset_Powerset_C_Polyhedron_add_constraint (p1, new_cstr);\n+\n+  /* Build P2.  */\n+  ppl_new_Pointset_Powerset_C_Polyhedron_from_Pointset_Powerset_C_Polyhedron\n+    (&p2, p1);\n+  map = ppl_new_id_map (new_dim);\n+  ppl_interchange (map, dim_L1, dim_L2);\n+  ppl_interchange (map, dim_i, dim_k);\n+  for (i = 0; i < PDR_NB_SUBSCRIPTS (pdr); i++)\n+    ppl_interchange (map, pdr_subscript_dim (pdr, i), dim + i + 1);\n+  ppl_Pointset_Powerset_C_Polyhedron_map_space_dimensions (p2, map, new_dim);\n+  free (map);\n+\n+  /* Add constraint k = i + 1.  */\n+  ppl_new_Linear_Expression_with_dimension (&le, new_dim);\n+  ppl_set_coef (le, dim_i, 1);\n+  ppl_set_coef (le, dim_k, -1);\n+  ppl_set_inhomogeneous (le, 1);\n+  ppl_new_Constraint (&new_cstr, le, PPL_CONSTRAINT_TYPE_EQUAL);\n+  ppl_Pointset_Powerset_C_Polyhedron_add_constraint (p2, new_cstr);\n+  ppl_delete_Linear_Expression (le);\n+  ppl_delete_Constraint (new_cstr);\n+\n+  /* P1 = P1 inter P2.  */\n+  ppl_Pointset_Powerset_C_Polyhedron_intersection_assign (p1, p2);\n+  ppl_delete_Pointset_Powerset_C_Polyhedron (p2);\n+\n+  /* Maximise the expression L2 - L1.  */\n+  ppl_new_Linear_Expression_with_dimension (&le, new_dim);\n+  ppl_set_coef (le, dim_L2, 1);\n+  ppl_set_coef (le, dim_L1, -1);\n+  ppl_max_for_le (p1, le, stride);\n+  ppl_delete_Linear_Expression (le);\n+}\n+\n+\n+/* Returns true when it is profitable to interchange loop at DEPTH1\n+   and loop at DEPTH2 with DEPTH1 < DEPTH2 for PBB.\n+\n+   Example:\n+\n+   | int a[100][100];\n+   |\n+   | int\n+   | foo (int N)\n+   | {\n+   |   int j;\n+   |   int i;\n+   |\n+   |   for (i = 0; i < N; i++)\n+   |     for (j = 0; j < N; j++)\n+   |       a[j][2 * i] += 1;\n+   |\n+   |   return a[N][12];\n+   | }\n+\n+   The data access A[j][i] is described like this:\n+\n+   | i   j   N   a  s0  s1   1\n+   | 0   0   0   1   0   0  -5    = 0\n+   | 0  -1   0   0   1   0   0    = 0\n+   |-2   0   0   0   0   1   0    = 0\n+   | 0   0   0   0   1   0   0   >= 0\n+   | 0   0   0   0   0   1   0   >= 0\n+   | 0   0   0   0  -1   0 100   >= 0\n+   | 0   0   0   0   0  -1 100   >= 0\n+\n+   The linearized memory access L to A[100][100] is:\n+\n+   | i   j   N   a  s0  s1   1\n+   | 0   0   0   0 100   1   0\n+\n+   Next, to measure the impact of iterating once in loop \"i\", we build\n+   a maximization problem: first, we add to DR accesses the dimensions\n+   k, s2, s3, L1 = 100 * s0 + s1, L2, and D1: polyhedron P1.\n+\n+   | i   j   N   a  s0  s1   k  s2  s3  L1  L2  D1   1\n+   | 0   0   0   1   0   0   0   0   0   0   0   0  -5    = 0  alias = 5\n+   | 0  -1   0   0   1   0   0   0   0   0   0   0   0    = 0  s0 = j\n+   |-2   0   0   0   0   1   0   0   0   0   0   0   0    = 0  s1 = 2 * i\n+   | 0   0   0   0   1   0   0   0   0   0   0   0   0   >= 0\n+   | 0   0   0   0   0   1   0   0   0   0   0   0   0   >= 0\n+   | 0   0   0   0  -1   0   0   0   0   0   0   0 100   >= 0\n+   | 0   0   0   0   0  -1   0   0   0   0   0   0 100   >= 0\n+   | 0   0   0   0 100   1   0   0   0  -1   0   0   0    = 0  L1 = 100 * s0 + s1\n+\n+   Then, we generate the polyhedron P2 by interchanging the dimensions\n+   (s0, s2), (s1, s3), (L1, L2), (i0, i)\n+\n+   | i   j   N   a  s0  s1   k  s2  s3  L1  L2  D1   1\n+   | 0   0   0   1   0   0   0   0   0   0   0   0  -5    = 0  alias = 5\n+   | 0  -1   0   0   0   0   0   1   0   0   0   0   0    = 0  s2 = j\n+   | 0   0   0   0   0   0  -2   0   1   0   0   0   0    = 0  s3 = 2 * k\n+   | 0   0   0   0   0   0   0   1   0   0   0   0   0   >= 0\n+   | 0   0   0   0   0   0   0   0   1   0   0   0   0   >= 0\n+   | 0   0   0   0   0   0   0  -1   0   0   0   0 100   >= 0\n+   | 0   0   0   0   0   0   0   0  -1   0   0   0 100   >= 0\n+   | 0   0   0   0   0   0   0 100   1   0  -1   0   0    = 0  L2 = 100 * s2 + s3\n+\n+   then we add to P2 the equality k = i + 1:\n+\n+   |-1   0   0   0   0   0   1   0   0   0   0   0  -1    = 0  k = i + 1\n+\n+   and finally we maximize the expression \"D1 = max (P1 inter P2, L2 - L1)\".\n+\n+   For determining the impact of one iteration on loop \"j\", we\n+   interchange (k, j), we add \"k = j + 1\", and we compute D2 the\n+   maximal value of the difference.\n+\n+   Finally, the profitability test is D1 < D2: if in the outer loop\n+   the strides are smaller than in the inner loop, then it is\n+   profitable to interchange the loops at DEPTH1 and DEPTH2.  */\n \n static bool\n-pbb_interchange_profitable_p (graphite_dim_t depth1, graphite_dim_t depth2, poly_bb_p pbb)\n+pbb_interchange_profitable_p (graphite_dim_t depth1, graphite_dim_t depth2,\n+\t\t\t      poly_bb_p pbb)\n {\n   int i;\n   poly_dr_p pdr;\n-  Value access_strides1, access_strides2;\n+  Value d1, d2, s;\n   bool res;\n \n   gcc_assert (depth1 < depth2);\n \n-  value_init (access_strides1);\n-  value_init (access_strides2);\n-\n-  value_set_si (access_strides1, 0);\n-  value_set_si (access_strides2, 0);\n+  value_init (d1);\n+  value_set_si (d1, 0);\n+  value_init (d2);\n+  value_set_si (d2, 0);\n+  value_init (s);\n \n   for (i = 0; VEC_iterate (poly_dr_p, PBB_DRS (pbb), i, pdr); i++)\n     {\n-      gather_access_strides (pdr, depth1, access_strides1);\n-      gather_access_strides (pdr, depth2, access_strides2);\n+      memory_stride_in_loop (s, depth1, pdr);\n+      value_addto (d1, d1, s);\n+\n+      memory_stride_in_loop (s, depth2, pdr);\n+      value_addto (d2, d2, s);\n     }\n \n-  res = value_lt (access_strides1, access_strides2);\n+  res = value_lt (d1, d2);\n \n-  value_clear (access_strides1);\n-  value_clear (access_strides2);\n+  value_clear (d1);\n+  value_clear (d2);\n+  value_clear (s);\n \n   return res;\n }"}, {"sha": "cfa31ec08037aee9945d8c3306fda904d8970579", "filename": "gcc/graphite-ppl.h", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb9fb29034ae7d09acac8e06246e061040c15c98/gcc%2Fgraphite-ppl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb9fb29034ae7d09acac8e06246e061040c15c98/gcc%2Fgraphite-ppl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-ppl.h?ref=fb9fb29034ae7d09acac8e06246e061040c15c98", "patch": "@@ -129,5 +129,31 @@ value_max (Value res, Value v1, Value v2)\n   value_assign (res, v1);\n }\n \n+/* Builds a new identity map for dimension DIM.  */\n+\n+static inline ppl_dimension_type *\n+ppl_new_id_map (ppl_dimension_type dim)\n+{\n+  ppl_dimension_type *map, i;\n+\n+  map = (ppl_dimension_type *) XNEWVEC (ppl_dimension_type, dim);\n+\n+  for (i = 0; i < dim; i++)\n+    map[i] = i;\n+\n+  return map;\n+}\n+\n+/* Builds an interchange of dimensions A and B in MAP.  */\n+\n+static inline void\n+ppl_interchange (ppl_dimension_type *map,\n+\t\t ppl_dimension_type a,\n+\t\t ppl_dimension_type b)\n+{\n+  map[a] = b;\n+  map[b] = a;\n+}\n+\n #endif\n "}, {"sha": "408ec9443c46d108bfc6f7b2aa3218d1ab35c08d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb9fb29034ae7d09acac8e06246e061040c15c98/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb9fb29034ae7d09acac8e06246e061040c15c98/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=fb9fb29034ae7d09acac8e06246e061040c15c98", "patch": "@@ -1,3 +1,8 @@\n+2009-08-12  Sebastian Pop  <sebastian.pop@amd.com>\n+\t    Pranav Garg  <pranav.garg2107@gmail.com>\n+\n+\t* testsuite/gcc.dg/graphite/interchange-6.c: XFAILed.\n+\n 2009-08-12  Sebastian Pop  <sebastian.pop@amd.com>\n \n \t* gcc.dg/graphite/interchange-9.c: New."}, {"sha": "0197aecbd01a8d959d6443d9ed876e9509866d3a", "filename": "gcc/testsuite/gcc.dg/graphite/interchange-6.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb9fb29034ae7d09acac8e06246e061040c15c98/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb9fb29034ae7d09acac8e06246e061040c15c98/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-6.c?ref=fb9fb29034ae7d09acac8e06246e061040c15c98", "patch": "@@ -13,5 +13,5 @@ int medium_loop_interchange(int A[100][200])\n   return A[1][1];\n }\n \n-/* { dg-final { scan-tree-dump-times \"will be interchanged\" 1 \"graphite\" } } */ \n+/* { dg-final { scan-tree-dump-times \"will be interchanged\" 1 \"graphite\" { xfail *-*-* } } } */\n /* { dg-final { cleanup-tree-dump \"graphite\" } } */"}]}