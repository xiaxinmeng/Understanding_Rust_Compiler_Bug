{"sha": "8d2733caec5ebdd4664d7645375262b1e097c418", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGQyNzMzY2FlYzVlYmRkNDY2NGQ3NjQ1Mzc1MjYyYjFlMDk3YzQxOA==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1994-05-06T09:27:46Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1994-05-06T09:27:46Z"}, "message": "36th Cygnus<->FSF merge\n\nFrom-SVN: r7221", "tree": {"sha": "983ac189ca3cb9a9e610fd162d9619dc1663d682", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/983ac189ca3cb9a9e610fd162d9619dc1663d682"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8d2733caec5ebdd4664d7645375262b1e097c418", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d2733caec5ebdd4664d7645375262b1e097c418", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d2733caec5ebdd4664d7645375262b1e097c418", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d2733caec5ebdd4664d7645375262b1e097c418/comments", "author": null, "committer": null, "parents": [{"sha": "19d3f3c5230734ad7ecafa3e79e53ebb5c1721f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19d3f3c5230734ad7ecafa3e79e53ebb5c1721f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/19d3f3c5230734ad7ecafa3e79e53ebb5c1721f9"}], "stats": {"total": 3598, "additions": 1578, "deletions": 2020}, "files": [{"sha": "1cf6db3f9662b830e6c75b40e734ff4f91972c8e", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d2733caec5ebdd4664d7645375262b1e097c418/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d2733caec5ebdd4664d7645375262b1e097c418/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=8d2733caec5ebdd4664d7645375262b1e097c418", "patch": "@@ -1,3 +1,55 @@\n+Fri May  6 01:25:38 1994  Mike Stump  (mrs@cygnus.com)\n+\n+\tAdd alpha exception handling support to the compiler.\n+\tQuick and dirty backend in except.c.\n+\n+\t* cp/*:  Remove most remnants of old exception handling support.\n+\t* decl.c (finish_function): Call expand_exception_blocks to put\n+\tthe exception hanlding blocks at the end of the function.\n+\t* dec.c (hack_incomplete_structures): Make sure expand_decl_cleanup\n+\tcomes after expand_decl_init.\n+\t* except.c: Reimplementation.\n+\t* expr.c (cplus_expand_expr): Handle THROW_EXPRs.\n+\t* lex.c (init_lex): Always have catch, try and throw be reserved\n+\twords, so that we may always parse exception handling.\n+\t* parse.y: Cleanup to support new interface into exception handling.\n+\t* tree.def (THROW_EXPR): Add.\n+\n+Thu May  5 17:35:37 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* parse.y (simple_stmt, for loops): Use implicitly_scoped_stmt.\n+\t(various): Lose .kindof_pushlevel and partially_scoped_stmt.\n+\n+Thu May  5 16:17:27 1994  Kung Hsu  (kung@mexican.cygnus.com)\n+\n+\t* parse.y (already_scoped_stmt): move expand_end_binding() to\n+\tfix the unmatched LBB/LBE in stabs.\n+\n+Thu May  5 14:36:17 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* decl.c (set_nested_typename): Set TREE_MANGLED on the new\n+\tidentifiers.\n+\t(pushdecl): Check TREE_MANGLED.\n+\t(xref_tag): Ditto.\n+\t* cp-tree.h (TREE_MANGLED): This identifier is a\n+\tDECL_NESTED_TYPENAME (named to allow for future use to denote\n+\tmangled function names as well).\n+\n+\tImplement inconsistency checking specified in [class.scope0].\n+\t* decl.c (lookup_name_real): Don't set ICV here after all.\n+\t(finish_enum): Also set the type of the enumerators themselves.\n+\t(build_enumerator): Put the CONST_DECL in the list instead of its\n+\tinitial value.\n+\t(pushdecl_class_level): Check inconsistent use of a name in the\n+\tclass body.\n+\t* class.c (finish_struct): Check inconsistent use of a name in the\n+\tclass body.  Don't set DECL_CONTEXT on types here anymore.\n+\t* parse.y (qualified_type_name): Note that the identifier has now\n+\tbeen used (as a type) in the class body.\n+\t* lex.c (do_identifier): Note that the identifier has now been used\n+\t(as a constant) in the class body.\n+\t* error.c (dump_decl): Print type and enum decls better.\n+\n Thu May  5 09:35:35 1994  Brendan Kehoe  (brendan@lisa.cygnus.com)\n \n \t* typeck.c (build_modify_expr): Warn about assignment to `this'."}, {"sha": "8f8bac21925e68278a6b7c447b15ac5f05fbc1c7", "filename": "gcc/cp/call.c", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d2733caec5ebdd4664d7645375262b1e097c418/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d2733caec5ebdd4664d7645375262b1e097c418/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=8d2733caec5ebdd4664d7645375262b1e097c418", "patch": "@@ -2924,18 +2924,6 @@ build_method_call (instance, name, parms, basetype_path, flags)\n \tneed_vtbl = maybe_needed;\n       instance_ptr = build1 (ADDR_EXPR, TYPE_POINTER_TO (basetype), instance);\n     }\n-  else if (instance == current_exception_object)\n-    {\n-      instance_ptr = build1 (ADDR_EXPR, TYPE_POINTER_TO (current_exception_type),\n-\t\t\t    TREE_OPERAND (current_exception_object, 0));\n-      mark_addressable (TREE_OPERAND (current_exception_object, 0));\n-      result = build_field_call (TYPE_BINFO (current_exception_type),\n-\t\t\t\t instance_ptr, name, parms);\n-      if (result)\n-\treturn result;\n-      cp_error (\"exception member `%D' cannot be invoked\", name);\n-      return error_mark_node;\n-    }\n   else\n     {\n       /* The MAIN_VARIANT of the type that `instance_ptr' winds up being.  */"}, {"sha": "730d0cac221fe3a344f24a61717669f38aafb54a", "filename": "gcc/cp/class.c", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d2733caec5ebdd4664d7645375262b1e097c418/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d2733caec5ebdd4664d7645375262b1e097c418/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=8d2733caec5ebdd4664d7645375262b1e097c418", "patch": "@@ -2504,7 +2504,6 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n      int warn_anon;\n {\n   extern int interface_only, interface_unknown;\n-  extern tree EHS_type;\n \n   int old;\n   int round_up_size = 1;\n@@ -2727,10 +2726,25 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n \t      if (! fields)\n \t\tfields = x;\n \t      last_x = x;\n-\t      DECL_CONTEXT (x) = t;\n \t      continue;\n \t    }\n \n+\t  /* Check for inconsistent use of this name in the class body.\n+             Enums, types and static vars have already been checked.  */\n+\t  if (TREE_CODE (x) != CONST_DECL && TREE_CODE (x) != VAR_DECL)\n+\t    {\n+\t      tree name = DECL_NAME (x);\n+\t      tree icv = name ? IDENTIFIER_CLASS_VALUE (name) : NULL_TREE;\n+\n+\t      /* Don't complain about constructors.  */\n+\t      if (icv && name != constructor_name (current_class_type))\n+\t\t{\n+\t\t  cp_error_at (\"declaration of identifier `%D' as `%+#D'\",\n+\t\t\t       name, x);\n+\t\t  cp_error_at (\"conflicts with other use in class as `%#D'\",\n+\t\t\t       icv);\n+\t\t}\n+\t    }\n \n \t  if (TREE_CODE (x) == FUNCTION_DECL)\n \t    {\n@@ -3129,9 +3143,8 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n       fn_fields = default_fn;\n     }\n \n-  /* Create default copy constructor, if needed.  Don't do it for\n-     the exception handler.  */\n-  if (! TYPE_HAS_INIT_REF (t) && ! cant_synth_copy_ctor && t != EHS_type)\n+  /* Create default copy constructor, if needed.  */\n+  if (! TYPE_HAS_INIT_REF (t) && ! cant_synth_copy_ctor)\n     {\n       /* ARM 12.18: You get either X(X&) or X(const X&), but\n \t not both.  --Chip  */"}, {"sha": "4f33c9f28591aa167ca1ae370c899206482efaf2", "filename": "gcc/cp/cp-tree.def", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d2733caec5ebdd4664d7645375262b1e097c418/gcc%2Fcp%2Fcp-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d2733caec5ebdd4664d7645375262b1e097c418/gcc%2Fcp%2Fcp-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.def?ref=8d2733caec5ebdd4664d7645375262b1e097c418", "patch": "@@ -55,10 +55,9 @@ DEFTREECODE (TYPE_EXPR, \"type_expr\", \"e\", 1)\n DEFTREECODE (NEW_EXPR, \"nw_expr\", \"e\", 3)\n DEFTREECODE (VEC_NEW_EXPR, \"vec_nw_expr\", \"e\", 3)\n \n-/* Distinguish variables that are only used to identify exceptions\n-   that were caught.  Only the DECL_NAME (and TREE_CHAIN)\n-   is really used.  */\n-DEFTREECODE (CPLUS_CATCH_DECL, \"catch_decl\", \"d\", 0)\n+/* A throw expression.  operand 0 is the expression, if there was one,\n+   else it is NULL_TREE.  */\n+DEFTREECODE (THROW_EXPR, \"throw_expr\", \"e\", 1)\n \n /* Template definition.  The following fields have the specified uses,\n    although there are other macros in cp-tree.h that should be used for"}, {"sha": "54dc2b2ae374862b15cda05e70cf8fefa72412f3", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 19, "deletions": 38, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d2733caec5ebdd4664d7645375262b1e097c418/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d2733caec5ebdd4664d7645375262b1e097c418/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=8d2733caec5ebdd4664d7645375262b1e097c418", "patch": "@@ -271,18 +271,14 @@ extern int interface_only, interface_unknown;\n \n extern int flag_elide_constructors;\n \n-/* Nonzero means recognize and handle exception handling constructs.  */\n-\n-extern int flag_handle_exceptions;\n-\n /* Nonzero means handle things in ANSI, instead of GNU fashion.  */\n \n extern int flag_ansi;\n \n /* Nonzero means recognize and handle ansi-style exception handling\n    constructs.  */\n \n-extern int flag_ansi_exceptions;\n+extern int flag_handle_exceptions;\n \n /* Nonzero means do argument matching for overloading according to the\n    ANSI rules, rather than what g++ used to believe to be correct.  */\n@@ -1083,10 +1079,14 @@ struct lang_decl\n    or virtual baseclasses.  */\n #define TYPE_USES_COMPLEX_INHERITANCE(NODE) (TREE_LANG_FLAG_1 (NODE))\n \n+/* Nonzero in IDENTIFIER_NODE means that this name is not the name the user\n+   gave; it's a DECL_NESTED_TYPENAME.  Someone may want to set this on\n+   mangled function names, too, but it isn't currently.  */\n+#define TREE_MANGLED(NODE) (TREE_LANG_FLAG_0 (NODE))\n+\n #if 0\t\t\t\t/* UNUSED */\n /* Nonzero in IDENTIFIER_NODE means that this name is overloaded, and\n    should be looked up in a non-standard way.  */\n-#define TREE_OVERLOADED(NODE) (TREE_LANG_FLAG_0 (NODE))\n #define DECL_OVERLOADED(NODE) (DECL_LANG_FLAG_4 (NODE))\n #endif\n \n@@ -1921,27 +1921,20 @@ extern tree lookup_name_nonclass\t\tPROTO((tree));\n /* in edsel.c */\n \n /* in except.c */\n-extern tree lookup_exception_cname\t\tPROTO((tree, tree, tree));\n-extern tree lookup_exception_tname\t\tPROTO((tree));\n-extern tree lookup_exception_object\t\tPROTO((tree, tree, int));\n-extern tree lookup_exception_type\t\tPROTO((tree, tree, tree));\n-extern tree finish_exception\t\t\tPROTO((tree, tree));\n-extern void finish_exception_decl\t\tPROTO((tree, tree));\n-extern void end_exception_decls\t\t\tPROTO((void));\n-extern void cplus_expand_start_try\t\tPROTO((int));\n-extern tree cplus_expand_end_try\t\tPROTO((int));\n-extern void cplus_expand_start_except\t\tPROTO((tree, tree));\n-extern void cplus_expand_end_except\t\tPROTO((tree));\n-extern void cplus_expand_raise\t\t\tPROTO((tree, tree, tree, int));\n-extern tree ansi_exception_object_lookup\tPROTO((tree));\n-extern void cplus_expand_throw\t\t\tPROTO((tree));\n-extern tree cplus_expand_start_catch\t\tPROTO((tree));\n-extern tree ansi_expand_start_catch\t\tPROTO((tree));\n-extern void cplus_expand_end_catch\t\tPROTO((int));\n-extern void cplus_expand_reraise\t\tPROTO((tree));\n-extern void setup_exception_throw_decl\t\tPROTO((void));\n+\n+extern void start_protect\t\t\tPROTO((void));\n+extern void end_protect\t\t\t\tPROTO((tree));\n+extern void expand_exception_blocks\t\tPROTO((void));\n+extern void expand_start_try_stmts\t\tPROTO((void));\n+extern void expand_end_try_stmts\t\tPROTO((void));\n+extern void expand_start_all_catch\t\tPROTO((void));\n+extern void expand_end_all_catch\t\tPROTO((void));\n+extern void start_catch_block\t\t\tPROTO((tree, tree));\n+extern void end_catch_block\t\t\tPROTO((void));\n+extern void expand_throw\t\t\tPROTO((tree));\n+extern void build_exception_table\t\tPROTO((void));\n+extern tree build_throw\t\t\t\tPROTO((tree));\n extern void init_exception_processing\t\tPROTO((void));\n-extern void init_exception_processing_1\t\tPROTO((void));\n \n /* in expr.c */\n /* skip cplus_expand_expr */\n@@ -2291,18 +2284,6 @@ extern void GNU_xref_assign\t\t\tPROTO((tree));\n extern void GNU_xref_hier\t\t\tPROTO((char *, char *, int, int, int));\n extern void GNU_xref_member\t\t\tPROTO((tree, tree));\n \n-#define in_try_block(X) (0)\n-#define in_exception_handler(X) (0)\n-#define expand_raise(X) (0)\n-#define expand_start_try(A,B,C) ((void)0)\n-#define expand_end_try() ((void)0)\n-#define expand_start_except(A,B) ((void)0)\n-#define expand_escape_except() (0)\n-#define expand_end_except() (NULL_TREE)\n-#define expand_catch(X) (0)\n-#define expand_catch_default() (0)\n-#define expand_end_catch() (0)\n-\n /* -- end of C++ */\n \n #endif /* not _CP_TREE_H */"}, {"sha": "e33db79a76567bdf34c66a9795a94849a2209fea", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 46, "deletions": 277, "changes": 323, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d2733caec5ebdd4664d7645375262b1e097c418/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d2733caec5ebdd4664d7645375262b1e097c418/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=8d2733caec5ebdd4664d7645375262b1e097c418", "patch": "@@ -41,6 +41,8 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #define obstack_chunk_alloc xmalloc\n #define obstack_chunk_free free\n \n+extern tree builtin_return_address_fndecl;\n+\n extern struct obstack permanent_obstack;\n \n extern int current_class_depth;\n@@ -122,7 +124,6 @@ static tree grokparms\t\t\t\tPROTO((tree, int));\n static tree lookup_nested_type\t\t\tPROTO((tree, tree));\n static char *redeclaration_error_message\tPROTO((tree, tree));\n static void grok_op_properties\t\t\tPROTO((tree, int, int));\n-static void deactivate_exception_cleanups\tPROTO((void));\n \n tree define_function\t\t\n \tPROTO((char *, tree, enum built_in_function, void (*)(), char *));\n@@ -257,12 +258,6 @@ tree dtor_label;\n \n tree ctor_label;\n \n-/* A FUNCTION_DECL which can call `unhandled_exception'.\n-   Not necessarily the one that the user will declare,\n-   but sufficient to be called by routines that want to abort the program.  */\n-\n-tree unhandled_exception_fndecl;\n-\n /* A FUNCTION_DECL which can call `abort'.  Not necessarily the\n    one that the user will declare, but sufficient to be called\n    by routines that want to abort the program.  */\n@@ -564,11 +559,6 @@ struct binding_level\n     unsigned more_cleanups_ok : 1;\n     unsigned have_cleanups : 1;\n \n-    /* Nonzero if this level can safely have additional\n-       exception-raising statements added to it.  */\n-    unsigned more_exceptions_ok : 1;\n-    unsigned have_exceptions : 1;\n-\n     /* Nonzero if we should accept any name as an identifier in\n        this scope.  This happens in some template definitions.  */\n     unsigned accept_any : 1;\n@@ -657,7 +647,6 @@ push_binding_level (newlevel, tag_transparent, keep)\n   current_binding_level = newlevel;\n   newlevel->tag_transparent = tag_transparent;\n   newlevel->more_cleanups_ok = 1;\n-  newlevel->more_exceptions_ok = 1;\n   newlevel->keep = keep;\n #if defined(DEBUG_CP_BINDING_LEVELS)\n   newlevel->binding_depth = binding_depth;\n@@ -751,23 +740,6 @@ declare_parm_level ()\n   current_binding_level->parm_flag = 1;\n }\n \n-/* Identify this binding level as a level of a default exception handler.  */\n-\n-void\n-declare_implicit_exception ()\n-{\n-  current_binding_level->parm_flag = 3;\n-}\n-\n-/* Nonzero if current binding contour contains expressions\n-   that might raise exceptions.  */\n-\n-int\n-have_exceptions_p ()\n-{\n-  return current_binding_level->have_exceptions;\n-}\n-\n void\n declare_uninstantiated_type_level ()\n {\n@@ -1105,7 +1077,7 @@ poplevel (keep, reverse, functionbody)\n     }\n \n   /* Take care of compiler's internal binding structures.  */\n-  if (tmp == 2 && !implicit_try_block)\n+  if (tmp == 2 && class_binding_level)\n     {\n #if 0\n       /* We did not call push_momentary for this\n@@ -1300,10 +1272,6 @@ print_binding_level (lvl)\n     fprintf (stderr, \" more-cleanups-ok\");\n   if (lvl->have_cleanups)\n     fprintf (stderr, \" have-cleanups\");\n-  if (lvl->more_exceptions_ok)\n-    fprintf (stderr, \" more-exceptions-ok\");\n-  if (lvl->have_exceptions)\n-    fprintf (stderr, \" have-exceptions\");\n   fprintf (stderr, \"\\n\");\n   if (lvl->names)\n     {\n@@ -1664,6 +1632,7 @@ set_nested_typename (decl, classname, name, type)\n       sprintf (buf, \"%s::%s\", IDENTIFIER_POINTER (classname),\n \t       IDENTIFIER_POINTER (name));\n       DECL_NESTED_TYPENAME (decl) = get_identifier (buf);\n+      TREE_MANGLED (DECL_NESTED_TYPENAME (decl)) = 1;\n \n       /* This is a special usage of IDENTIFIER_TYPE_VALUE which have no\n \t correspondence in any binding_level.  This is ok since the\n@@ -2988,7 +2957,6 @@ pushdecl (x)\n \n       /* Keep count of variables in this level with incomplete type.  */\n       if (TREE_CODE (x) != TEMPLATE_DECL\n-\t  && TREE_CODE (x) != CPLUS_CATCH_DECL\n \t  && TYPE_SIZE (TREE_TYPE (x)) == NULL_TREE\n \t  && PROMOTES_TO_AGGR_TYPE (TREE_TYPE (x), ARRAY_TYPE))\n \t{\n@@ -3001,7 +2969,7 @@ pushdecl (x)\n     {\n       if (current_class_name)\n \t{\n-\t  if (!DECL_NESTED_TYPENAME (TYPE_NAME (TREE_TYPE (x))))\n+\t  if (! TREE_MANGLED (name))\n \t    set_nested_typename (x, current_class_name, DECL_NAME (x),\n \t\t\t\t TREE_TYPE (x));\n \t}\n@@ -3107,6 +3075,21 @@ pushdecl_class_level (x)\n \n   if (name)\n     {\n+      if (TYPE_BEING_DEFINED (current_class_type))\n+\t{\n+\t  /* Check for inconsistent use of this name in the class body.\n+\t     Types, enums, and static vars are checked here; other\n+\t     members are checked in finish_struct.  */\n+\t  tree icv = IDENTIFIER_CLASS_VALUE (name);\n+\n+\t  if (icv)\n+\t    {\n+\t      cp_error (\"declaration of identifier `%D' as `%#D'\", name, x);\n+\t      cp_error_at (\"conflicts with previous use in class as `%#D'\",\n+\t\t\t   icv);\n+\t    }\n+\t}\n+\n       push_class_level_binding (name, x);\n       if (TREE_CODE (x) == TYPE_DECL)\n \t{\n@@ -3936,11 +3919,7 @@ lookup_name_real (name, prefer_type, nonclass)\n \t/* Try to find values from base classes if we are presently\n \t   defining a type.  We are presently only interested in\n \t   TYPE_DECLs.  */\n-\t{\n-\t  val = lookup_field (current_class_type, name, 0, 1);\n-\t  if (val)\n-\t    pushdecl_class_level (val);\n-\t}\n+\tval = lookup_field (current_class_type, name, 0, 1);\n \n       /* yylex() calls this with -2, since we should never start digging for\n \t the nested name at the point where we haven't even, for example,\n@@ -4498,6 +4477,7 @@ init_decl_processing ()\n   builtin_function (\"__builtin_constant_p\", int_ftype_int,\n \t\t    BUILT_IN_CONSTANT_P, NULL_PTR);\n \n+  builtin_return_address_fndecl =\n   builtin_function (\"__builtin_return_address\",\n \t\t    build_function_type (ptr_type_node, \n \t\t\t\t\t tree_cons (NULL_TREE,\n@@ -4911,23 +4891,13 @@ init_decl_processing ()\n \t\t       build_function_type (void_type_node, void_list_node),\n \t\t       NOT_BUILT_IN, 0, 0);\n \n-  unhandled_exception_fndecl\n-    = define_function (\"__unhandled_exception\",\n-\t\t       build_function_type (void_type_node, NULL_TREE),\n-\t\t       NOT_BUILT_IN, 0, 0);\n-\n   /* Perform other language dependent initializations.  */\n   init_class_processing ();\n   init_init_processing ();\n   init_search_processing ();\n \n   if (flag_handle_exceptions)\n-    {\n-      if (flag_handle_exceptions == 2)\n-\t/* Too much trouble to inline all the trys needed for this.  */\n-\tflag_this_is_variable = 2;\n-      init_exception_processing ();\n-    }\n+    init_exception_processing ();\n   if (flag_gc)\n     init_gc_processing ();\n   if (flag_no_inline)\n@@ -5097,14 +5067,11 @@ shadow_tag (declspecs)\n \t      push_obstacks (&permanent_obstack, &permanent_obstack);\n \n \t      pushclass (t, 0);\n-\t      finish_exception (t, NULL_TREE);\n \n \t      ename = TYPE_NAME (t);\n \t      if (TREE_CODE (ename) == TYPE_DECL)\n \t\tename = DECL_NAME (ename);\n \t      decl = build_lang_field_decl (VAR_DECL, ename, t);\n-\t      finish_exception_decl (current_class_name, decl);\n-\t      end_exception_decls ();\n \n \t      pop_obstacks ();\n \t    }\n@@ -5779,7 +5746,6 @@ finish_decl (decl, init, asmspec_tree, need_pop)\n   if (type != error_mark_node && IS_AGGR_TYPE (type)\n       && CLASSTYPE_DECLARED_EXCEPTION (type))\n     {\n-      finish_exception_decl (NULL_TREE, decl);\n       CLASSTYPE_GOT_SEMICOLON (type) = 1;\n       goto finish_end;\n     }\n@@ -6111,7 +6077,6 @@ finish_decl (decl, init, asmspec_tree, need_pop)\n \t      cleanup = TREE_OPERAND (init, 2);\n \t      init = TREE_OPERAND (init, 0);\n \t      current_binding_level->have_cleanups = 1;\n-\t      current_binding_level->more_exceptions_ok = 0;\n \t    }\n \t  else\n \t    cleanup = maybe_build_cleanup (decl);\n@@ -6146,14 +6111,6 @@ finish_decl (decl, init, asmspec_tree, need_pop)\n       if (was_temp)\n \tend_temporary_allocation ();\n \n-      /* If we are in need of a cleanup, get out of any implicit\n-\t handlers that have been established so far.  */\n-      if (cleanup && current_binding_level->parm_flag == 3)\n-\t{\n-\t  pop_implicit_try_blocks (decl);\n-\t  current_binding_level->more_exceptions_ok = 0;\n-\t}\n-\n       if (TREE_CODE (decl) == VAR_DECL\n \t  && current_binding_level != global_binding_level\n \t  && ! TREE_STATIC (decl)\n@@ -6343,7 +6300,11 @@ finish_decl (decl, init, asmspec_tree, need_pop)\n \t\texpand_decl (decl);\n \t      else if (cleanup)\n \t\t{\n-\t\t  expand_decl_cleanup (NULL_TREE, cleanup);\n+\t\t  /* XXX: Why don't we use decl here?  */\n+\t\t  /* Ans: Because it was already expanded? */\n+\t\t  if (! expand_decl_cleanup (NULL_TREE, cleanup))\n+\t\t    cp_error (\"parser lost in parsing declaration of `%D'\",\n+\t\t\t      decl);\n \t\t  /* Cleanup used up here.  */\n \t\t  cleanup = NULL_TREE;\n \t\t}\n@@ -8849,8 +8810,6 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t    decl = build_lang_field_decl (VAR_DECL, declarator, type);\n \t    if (ctype == NULL_TREE)\n \t      ctype = current_class_type;\n-\t    finish_exception_decl (TREE_CODE (TYPE_NAME (ctype)) == TYPE_DECL\n-\t\t\t\t   ? TYPE_IDENTIFIER (ctype) : TYPE_NAME (ctype), decl);\n \t    return void_type_node;\n \t  }\n \telse if (TYPE_SIZE (type) == NULL_TREE && !staticp\n@@ -9869,10 +9828,8 @@ xref_tag (code_type_node, name, binfo, globalize)\n        * and don't try to find it as a type. */\n       xref_next_defn = 0;\n       if (t && TYPE_CONTEXT(t))\n-\t{ \n-\t  extern char *index();\n-\t  char *p;\n-\t  if ((p = index(IDENTIFIER_POINTER(name), ':')) && *(p+1) == ':')\n+\t{\n+\t  if (TREE_MANGLED (name))\n \t    ref = t;\n \t  else\n       \t    ref = lookup_tag (code, name, b, 1);\n@@ -10267,6 +10224,7 @@ finish_enum (enumtype, values)\n \n       HOST_WIDE_INT value = TREE_INT_CST_LOW (TREE_VALUE (values));\n       TREE_TYPE (TREE_VALUE (values)) = enumtype;\n+      TREE_TYPE (DECL_INITIAL (TREE_VALUE (values))) = enumtype;\n       minvalue = maxvalue = value;\n       \n       for (pair = TREE_CHAIN (values); pair; pair = TREE_CHAIN (pair))\n@@ -10370,8 +10328,7 @@ build_enumerator (name, value)\n \t}\n       else\n \t{\n-\t  error (\"enumerator value for `%s' not integer constant\",\n-\t\t IDENTIFIER_POINTER (name));\n+\t  cp_error (\"enumerator value for `%D' not integer constant\", name);\n \t  value = NULL_TREE;\n \t}\n     }\n@@ -10404,8 +10361,6 @@ build_enumerator (name, value)\n       TREE_TYPE (value) = integer_type_node;\n     }\n \n-  result = saveable_tree_cons (name, value, NULL_TREE);\n-\n   /* C++ associates enums with global, function, or class declarations.  */\n \n   decl = current_scope ();\n@@ -10439,6 +10394,7 @@ build_enumerator (name, value)\n   if (enum_next_value == integer_one_node)\n     enum_next_value = copy_node (enum_next_value);\n \n+  result = saveable_tree_cons (name, decl, NULL_TREE);\n   return result;\n }\n \n@@ -10494,7 +10450,6 @@ start_function (declspecs, declarator, raises, pre_parsed_p)\n      tree declarator, declspecs, raises;\n      int pre_parsed_p;\n {\n-  extern tree EHS_decl;\n   tree decl1, olddecl;\n   tree ctype = NULL_TREE;\n   tree fntype;\n@@ -10503,9 +10458,6 @@ start_function (declspecs, declarator, raises, pre_parsed_p)\n   extern int used_extern_spec;\n   int doing_friend = 0;\n \n-  if (flag_handle_exceptions && EHS_decl == NULL_TREE)\n-    init_exception_processing_1 ();\n-\n   /* Sanity check.  */\n   my_friendly_assert (TREE_VALUE (void_list_node) == void_type_node, 160);\n   my_friendly_assert (TREE_CHAIN (void_list_node) == NULL_TREE, 161);\n@@ -10829,7 +10781,6 @@ store_parm_decls ()\n   register tree fndecl = current_function_decl;\n   register tree parm;\n   int parms_have_cleanups = 0;\n-  tree eh_decl;\n \n   /* This is either a chain of PARM_DECLs (when a prototype is used).  */\n   tree specparms = current_function_parms;\n@@ -10854,18 +10805,6 @@ store_parm_decls ()\n   /* Create a binding level for the parms.  */\n   expand_start_bindings (0);\n \n-  /* Prepare to catch raises, if appropriate.  */\n-  if (flag_handle_exceptions)\n-    {\n-      /* Get this cleanup to be run last, since it\n-\t is a call to `longjmp'.  */\n-      setup_exception_throw_decl ();\n-      eh_decl = current_binding_level->names;\n-      current_binding_level->names = TREE_CHAIN (current_binding_level->names);\n-    }\n-  if (flag_handle_exceptions)\n-    expand_start_try (integer_one_node, 0, 1);\n-\n   if (specparms != NULL_TREE)\n     {\n       /* This case is when the function was defined with an ANSI prototype.\n@@ -10919,7 +10858,9 @@ store_parm_decls ()\n \t      if (cleanup)\n \t\t{\n \t\t  expand_decl (parm);\n-\t\t  expand_decl_cleanup (parm, cleanup);\n+\t\t  if (! expand_decl_cleanup (parm, cleanup))\n+\t\t    cp_error (\"parser lost in parsing declaration of `%D'\",\n+\t\t\t      parm);\n \t\t  parms_have_cleanups = 1;\n \t\t}\n \t    }\n@@ -10953,14 +10894,6 @@ store_parm_decls ()\n   DECL_SAVED_INSNS (fndecl) = NULL_RTX;\n   expand_function_start (fndecl, parms_have_cleanups);\n \n-  if (flag_handle_exceptions)\n-    {\n-      /* Make the throw decl visible at this level, just\n-\t not in the way of the parameters.  */\n-      pushdecl (eh_decl);\n-      expand_decl_init (eh_decl);\n-    }\n-\n   /* Create a binding contour which can be used to catch\n      cleanup-generated temporaries.  Also, if the return value needs or\n      has initialization, deal with that now.  */\n@@ -10975,7 +10908,8 @@ store_parm_decls ()\n   if (flag_gc)\n     {\n       maybe_gc_cleanup = build_tree_list (NULL_TREE, error_mark_node);\n-      expand_decl_cleanup (NULL_TREE, maybe_gc_cleanup);\n+      if (! expand_decl_cleanup (NULL_TREE, maybe_gc_cleanup))\n+\tcp_error (\"parser lost in parsing declaration of `%D'\", fndecl);\n     }\n \n   /* If this function is `main', emit a call to `__main'\n@@ -11121,7 +11055,6 @@ finish_function (lineno, call_poplevel)\n   register tree fndecl = current_function_decl;\n   tree fntype, ctype = NULL_TREE;\n   rtx head, last_parm_insn, mark;\n-  extern int sets_exception_throw_decl;\n   /* Label to use if this function is supposed to return a value.  */\n   tree no_return_label = NULL_TREE;\n   tree decls = NULL_TREE;\n@@ -11344,8 +11277,6 @@ finish_function (lineno, call_poplevel)\n \t  if (call_poplevel)\n \t    {\n \t      decls = getdecls ();\n-\t      if (flag_handle_exceptions == 2)\n-\t\tdeactivate_exception_cleanups ();\n \t      expand_end_bindings (decls, decls != NULL_TREE, 0);\n \t      poplevel (decls != NULL_TREE, 0, 0);\n \t    }\n@@ -11377,41 +11308,6 @@ finish_function (lineno, call_poplevel)\n \t\t\t\t  current_class_decl, integer_zero_node, 1);\n \t  thenclause = build_modify_expr (current_class_decl, NOP_EXPR,\n \t\t\t\t\t  build_new (NULL_TREE, current_class_type, void_type_node, 0));\n-\t  if (flag_handle_exceptions == 2)\n-\t    {\n-\t      tree cleanup, cleanup_deallocate;\n-\t      tree virtual_size;\n-\n-\t      /* This is the size of the virtual object pointed to by\n-\t\t allocated_this.  In this case, it is simple.  */\n-\t      virtual_size = c_sizeof (current_class_type);\n-\n-\t      allocated_this = build_decl (VAR_DECL, NULL_TREE, ptr_type_node);\n-\t      DECL_REGISTER (allocated_this) = 1;\n-\t      DECL_INITIAL (allocated_this) = error_mark_node;\n-\t      expand_decl (allocated_this);\n-\t      expand_decl_init (allocated_this);\n-\t      /* How we cleanup `this' if an exception was raised before\n-\t\t we are ready to bail out.  */\n-\t      cleanup = TYPE_GETS_REG_DELETE (current_class_type)\n-\t\t? build_opfncall (DELETE_EXPR, LOOKUP_NORMAL, allocated_this, virtual_size, NULL_TREE)\n-\t\t  /* The size of allocated_this is wrong, and hence the\n-\t\t     second argument to operator delete will be wrong. */\n-\t\t  : build_delete (TREE_TYPE (allocated_this), allocated_this,\n-\t\t\t\t  integer_three_node,\n-\t\t\t\t  LOOKUP_NORMAL|LOOKUP_HAS_IN_CHARGE, 1);\n-\t      cleanup_deallocate\n-\t\t= build_modify_expr (current_class_decl, NOP_EXPR, integer_zero_node);\n-\t      cleanup = tree_cons (NULL_TREE, cleanup,\n-\t\t\t\t   build_tree_list (NULL_TREE, cleanup_deallocate));\n-\n-\t      expand_decl_cleanup (allocated_this,\n-\t\t\t\t   build (COND_EXPR, integer_type_node,\n-\t\t\t\t\t  build (NE_EXPR, integer_type_node,\n-\t\t\t\t\t\t allocated_this, integer_zero_node),\n-\t\t\t\t\t  build_compound_expr (cleanup),\n-\t\t\t\t\t  integer_zero_node));\n-\t    }\n \t}\n \n       CLASSTYPE_ABSTRACT_VIRTUALS (current_class_type) = abstract_virtuals;\n@@ -11426,8 +11322,6 @@ finish_function (lineno, call_poplevel)\n \t{\n \t  expand_start_cond (cond, 0);\n \t  expand_expr_stmt (thenclause);\n-\t  if (flag_handle_exceptions == 2)\n-\t    expand_assignment (allocated_this, current_class_decl, 0, 0);\n \t  expand_end_cond ();\n \t}\n \n@@ -11460,14 +11354,6 @@ finish_function (lineno, call_poplevel)\n       /* This is where the body of the constructor ends.  */\n       expand_label (ctor_label);\n       ctor_label = NULL_TREE;\n-      if (flag_handle_exceptions == 2)\n-\t{\n-\t  expand_assignment (allocated_this, integer_zero_node, 0, 0);\n-\t  if (call_poplevel)\n-\t    deactivate_exception_cleanups ();\n-\t}\n-\n-      pop_implicit_try_blocks (NULL_TREE);\n \n       if (call_poplevel)\n \t{\n@@ -11545,19 +11431,6 @@ finish_function (lineno, call_poplevel)\n     /* Emit label at beginning of cleanup code for parameters.  */\n     emit_label (cleanup_label);\n \n-#if 1\n-  /* Cheap hack to get better code from GNU C++.  Remove when cse is fixed.  */\n-  if (exception_throw_decl && sets_exception_throw_decl == 0)\n-    expand_assignment (exception_throw_decl, integer_zero_node, 0, 0);\n-#endif\n-\n-  if (flag_handle_exceptions)\n-    {\n-      expand_end_try ();\n-      expand_start_except (0, 0);\n-      expand_end_except ();\n-    }\n-\n   /* Get return value into register if that's where it's supposed to be.  */\n   if (original_result_rtx)\n     fixup_result_decl (DECL_RESULT (fndecl), original_result_rtx);\n@@ -11590,6 +11463,9 @@ finish_function (lineno, call_poplevel)\n   /* Generate rtl for function exit.  */\n   expand_function_end (input_filename, lineno, 1);\n \n+  if (flag_handle_exceptions)\n+    expand_exception_blocks();\n+\n   /* This must come after expand_function_end because cleanups might\n      have declarations (from inline functions) that need to go into\n      this function's blocks.  */\n@@ -11917,9 +11793,13 @@ hack_incomplete_structures (type)\n \t    rest_of_decl_compilation (decl, NULL_PTR, toplevel, 0);\n \t    if (! toplevel)\n \t      {\n+\t\ttree cleanup;\n \t\texpand_decl (decl);\n-\t\texpand_decl_cleanup (decl, maybe_build_cleanup (decl));\n+\t\tcleanup = maybe_build_cleanup (decl);\n \t\texpand_decl_init (decl);\n+\t\tif (! expand_decl_cleanup (decl, cleanup))\n+\t\t  cp_error (\"parser lost in parsing declaration of `%D'\",\n+\t\t\t    decl);\n \t      }\n \t  }\n \tmy_friendly_assert (current_binding_level->n_incomplete > 0, 164);\n@@ -11982,9 +11862,6 @@ maybe_build_cleanup (decl)\n \trval = build_compound_expr (tree_cons (NULL_TREE, rval,\n \t\t\t\t\t       build_tree_list (NULL_TREE, build_vbase_delete (type, decl))));\n \n-      current_binding_level->have_cleanups = 1;\n-      current_binding_level->more_exceptions_ok = 0;\n-\n       if (TREE_CODE (decl) != PARM_DECL)\n \tresume_momentary (temp);\n \n@@ -12024,27 +11901,8 @@ cplus_expand_expr_stmt (exp)\n \t  cp_warning (\"reference, not call, to function `%D'\", exp);\n \t  warning (\"at this point in file\");\n \t}\n-      if (TREE_RAISES (exp))\n-\t{\n-\t  my_friendly_assert (flag_handle_exceptions, 165);\n-\t  if (flag_handle_exceptions == 2)\n-\t    {\n-\t      if (! current_binding_level->more_exceptions_ok)\n-\t\t{\n-\t\t  extern struct nesting *nesting_stack, *block_stack;\n-\n-\t\t  remove_implicit_immediately\n-\t\t    = (nesting_stack != block_stack);\n-\t\t  cplus_expand_start_try (1);\n-\t\t}\n-\t      current_binding_level->have_exceptions = 1;\n-\t    }\n-\t}\n \n       expand_expr_stmt (break_out_cleanups (exp));\n-\n-      if (remove_implicit_immediately)\n-\tpop_implicit_try_blocks (NULL_TREE);\n     }\n \n   /* Clean up any pending cleanups.  This happens when a function call\n@@ -12082,95 +11940,6 @@ finish_stmt ()\n     cadillac_finish_stmt ();\n }\n \n-void\n-pop_implicit_try_blocks (decl)\n-     tree decl;\n-{\n-  if (decl)\n-    {\n-      my_friendly_assert (current_binding_level->parm_flag == 3, 166);\n-      current_binding_level->names = TREE_CHAIN (decl);\n-    }\n-\n-  while (current_binding_level->parm_flag == 3)\n-    {\n-      tree name = get_identifier (\"(compiler error)\");\n-      tree orig_ex_type = current_exception_type;\n-      tree orig_ex_decl = current_exception_decl;\n-      tree orig_ex_obj = current_exception_object;\n-      tree decl = cplus_expand_end_try (2);\n-\n-      /* @@ It would be nice to make all these point\n-\t to exactly the same handler.  */\n-      /* Start hidden EXCEPT.  */\n-      cplus_expand_start_except (name, decl);\n-      /* reraise ALL.  */\n-      cplus_expand_reraise (NULL_TREE);\n-      current_exception_type = orig_ex_type;\n-      current_exception_decl = orig_ex_decl;\n-      current_exception_object = orig_ex_obj;\n-      /* This will reraise for us.  */\n-      cplus_expand_end_except (error_mark_node);\n-    }\n-\n-  if (decl)\n-    {\n-      TREE_CHAIN (decl) = current_binding_level->names;\n-      current_binding_level->names = decl;\n-    }\n-}\n-\n-/* Push a cleanup onto the current binding contour that will cause\n-   ADDR to be cleaned up, in the case that an exception propagates\n-   through its binding contour.  */\n-\n-void\n-push_exception_cleanup (addr)\n-     tree addr;\n-{\n-  tree decl = build_decl (VAR_DECL, get_identifier (EXCEPTION_CLEANUP_NAME), ptr_type_node);\n-  tree cleanup;\n-\n-  decl = pushdecl (decl);\n-  DECL_REGISTER (decl) = 1;\n-  store_init_value (decl, addr);\n-  expand_decl (decl);\n-  expand_decl_init (decl);\n-\n-  cleanup = build (COND_EXPR, integer_type_node,\n-\t\t   build (NE_EXPR, integer_type_node,\n-\t\t\t  decl, integer_zero_node),\n-\t\t   build_delete (TREE_TYPE (addr), decl,\n-\t\t\t\t lookup_name (in_charge_identifier, 0),\n-\t\t\t\t LOOKUP_NORMAL|LOOKUP_DESTRUCTOR, 0),\n-\t\t   integer_zero_node);\n-  expand_decl_cleanup (decl, cleanup);\n-}\n-\n-/* For each binding contour, emit code that deactivates the\n-   exception cleanups.  All other cleanups are left as they were.  */\n-\n-static void\n-deactivate_exception_cleanups ()\n-{\n-  struct binding_level *b = current_binding_level;\n-  tree xyzzy = get_identifier (EXCEPTION_CLEANUP_NAME);\n-  while (b != class_binding_level)\n-    {\n-      if (b->parm_flag == 3)\n-\t{\n-\t  tree decls = b->names;\n-\t  while (decls)\n-\t    {\n-\t      if (DECL_NAME (decls) == xyzzy)\n-\t\texpand_assignment (decls, integer_zero_node, 0, 0);\n-\t      decls = TREE_CHAIN (decls);\n-\t    }\n-\t}\n-      b = b->level_chain;\n-    }\n-}\n-\n /* Change a static member function definition into a FUNCTION_TYPE, instead\n    of the METHOD_TYPE that we create when it's originally parsed.\n "}, {"sha": "d6eb5d9590839d4fe3ed4f2df7a058ecf2c388ed", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d2733caec5ebdd4664d7645375262b1e097c418/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d2733caec5ebdd4664d7645375262b1e097c418/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=8d2733caec5ebdd4664d7645375262b1e097c418", "patch": "@@ -266,16 +266,10 @@ int write_virtuals;\n int flag_elide_constructors;\n \n /* Nonzero means recognize and handle exception handling constructs.\n-   2 means handle exceptions the way Spring wants them handled.  */\n+   Use ansi syntax and semantics.  WORK IN PROGRESS!  */\n \n int flag_handle_exceptions;\n \n-/* Nonzero means recognize and handle exception handling constructs.\n-   Use ansi syntax and semantics.  WORK IN PROGRESS!\n-   2 means handle exceptions the way Spring wants them handled.  */\n-\n-int flag_ansi_exceptions;\n-\n /* Nonzero means recognize and handle signature language constructs.  */\n \n int flag_handle_signatures;\n@@ -354,9 +348,7 @@ static struct { char *string; int *variable; int on_value;} lang_f_options[] =\n   {\"memoize-lookups\", &flag_memoize_lookups, 1},\n   {\"elide-constructors\", &flag_elide_constructors, 1},\n   {\"handle-exceptions\", &flag_handle_exceptions, 1},\n-  {\"ansi-exceptions\", &flag_ansi_exceptions, 1},\n   {\"handle-signatures\", &flag_handle_signatures, 1},\n-  {\"spring-exceptions\", &flag_handle_exceptions, 2},\n   {\"default-inline\", &flag_default_inline, 1},\n   {\"dollars-in-identifiers\", &dollars_in_ident, 1},\n   {\"enum-int-equiv\", &flag_int_enum_equivalence, 1},\n@@ -2493,6 +2485,8 @@ finish_file ()\n   tree vars = static_aggregates;\n   int needs_cleaning = 0, needs_messing_up = 0;\n \n+  build_exception_table ();\n+\n   if (flag_detailed_statistics)\n     dump_tree_statistics ();\n "}, {"sha": "629c70b92b1bbc73668e23a7857fa4628b1d812d", "filename": "gcc/cp/error.c", "status": "modified", "additions": 16, "deletions": 19, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d2733caec5ebdd4664d7645375262b1e097c418/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d2733caec5ebdd4664d7645375262b1e097c418/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=8d2733caec5ebdd4664d7645375262b1e097c418", "patch": "@@ -559,14 +559,19 @@ dump_decl (t, v)\n       break;\n \n     case TYPE_DECL:\n-      if (TYPE_NAME (TREE_TYPE (t)) != t)\n-\t{\n-\t  if (v > 0)\n-\t    OB_PUTS (\"typedef \");\n-\t  goto general;\n-\t}\n-\n-      dump_type (TREE_TYPE (t), v);\n+      {\n+\t/* Don't say 'typedef class A' */\n+\ttree type = TREE_TYPE (t);\n+        if (IS_AGGR_TYPE (type) && ! TYPE_PTRMEMFUNC_P (type)\n+\t    && type == TYPE_MAIN_VARIANT (type))\n+\t  {\n+\t    dump_type (type, v);\n+\t    break;\n+\t  }\n+      }\n+      if (v > 0)\n+\tOB_PUTS (\"typedef \");\n+      goto general;\n       break;\n       \n     case VAR_DECL:\n@@ -586,9 +591,8 @@ dump_decl (t, v)\n \t  OB_PUTC (' ');\n \t}\n       /* DECL_CLASS_CONTEXT isn't being set in some cases.  Hmm...  */\n-      if (TREE_CODE (t) == FIELD_DECL\n-\t  || (TREE_CODE (t) == VAR_DECL && DECL_CONTEXT (t)\n-\t      && TREE_CODE_CLASS (TREE_CODE (DECL_CONTEXT (t))) == 't'))\n+      if (DECL_CONTEXT (t)\n+\t  && TREE_CODE_CLASS (TREE_CODE (DECL_CONTEXT (t))) == 't')\n \t{\n \t  dump_type (DECL_CONTEXT (t), 0);\n \t  OB_PUTC2 (':', ':');\n@@ -696,14 +700,7 @@ dump_decl (t, v)\n \n     case CONST_DECL:\n       if (NEXT_CODE (t) == ENUMERAL_TYPE)\n-\t{\n-\t  if (DECL_CONTEXT (t))\n-\t    {\n-\t      dump_decl (DECL_CONTEXT (t), 0);\n-\t      OB_PUTC2 (':', ':');\n-\t    }\n-\t  OB_PUTID (DECL_NAME (t));\n-\t}\n+\tgoto general;\n       else\n \tdump_expr (DECL_INITIAL (t), 0);\n       break;"}, {"sha": "60fd39208912162350f1af910abc7fcb998f1680", "filename": "gcc/cp/except.c", "status": "modified", "additions": 1167, "deletions": 1017, "changes": 2184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d2733caec5ebdd4664d7645375262b1e097c418/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d2733caec5ebdd4664d7645375262b1e097c418/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=8d2733caec5ebdd4664d7645375262b1e097c418", "patch": "@@ -1,6 +1,8 @@\n /* Handle exceptional things in C++.\n-   Copyright (C) 1989, 1992, 1993 Free Software Foundation, Inc.\n-   Contributed by Michael Tiemann (tiemann@cygnus.com)\n+   Copyright (C) 1989, 1992, 1993, 1994 Free Software Foundation, Inc.\n+   Contributed by Michael Tiemann <tiemann@cygnus.com>\n+   Rewritten by Mike Stump <mrs@cygnus.com>, based upon an\n+   initial re-implementation courtesy Tad Hunt.\n \n This file is part of GNU CC.\n \n@@ -26,1198 +28,1346 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #include \"rtl.h\"\n #include \"cp-tree.h\"\n #include \"flags.h\"\n-/* On Suns this can get you to the right definition if you\n-   set the right value for TARGET.  */\n-#include <setjmp.h>\n-#ifdef sequent\n-/* Can you believe they forgot this?  */\n-#define _JBLEN 11\n-#endif\n-\n-#ifndef _JBLEN\n-#define _JBLEN (sizeof(jmp_buf)/sizeof(int))\n-#endif\n+#include \"obstack.h\"\n+#include \"expr.h\"\n \n-#undef NULL\n-#define NULL (char *)0\n+/* holds the fndecl for __builtin_return_address () */\n+tree builtin_return_address_fndecl;\n \n-/* This should be part of `ansi_opname', or at least be defined by the std.  */\n-#define EXCEPTION_NAME_PREFIX \"__ex\"\n-#define EXCEPTION_NAME_LENGTH 4\n+/* Define at your own risk!  */\n+#ifdef sun\n+#ifdef sparc\n+#define TRY_NEW_EH\n+#endif\n+#endif\n \n-void init_exception_processing ();\n-void init_exception_processing_1 ();\n+#ifndef TRY_NEW_EH\n \n-/* If non-zero, a VAR_DECL whose cleanup will cause a throw to the\n-   next exception handler.  Its value says whether to throw or not.\n-   In the case of functions which do not issue a RAISE, it should be\n-   possible to optimize away this VAR_DECL (and overhead associated\n-   with it).  */\n-tree exception_throw_decl;\n-/* Use this to know that we did not set `exception_throw_decl',\n-   until GCC optimizer is smart enough to figure it out for itself.  */\n-int sets_exception_throw_decl;\n+static void\n+sorry_no_eh ()\n+{\n+  static int warned = 0;\n+  if (! warned)\n+    {\n+      sorry (\"exception handling not supported\");\n+      warned = 1;\n+    }\n+}\n \n-/* The exception `type' currently in scope, or NULL_TREE if none.  */\n-tree current_exception_type;\n+void\n+build_exception_table ()\n+{\n+}\n \n-/* The exception handler object for the given scope.  */\n-tree current_exception_decl;\n-rtx current_exception_name_as_rtx;\n-rtx current_exception_parms_as_rtx;\n+void\n+expand_exception_blocks ()\n+{\n+}\n \n-/* The ``object'' view of the current exception parameters.\n-   We cast up from the `parms' field to `current_exception_type'.  */\n-tree current_exception_object;\n+void\n+start_protect ()\n+{\n+}\n \n-/* Cache `setjmp', `longjmp', `raise_exception', and `unhandled_exception'\n-   after default conversion.  Maybe later they will get built-in.  */\n-static tree BISJ, BILJ, BIR, BIUE;\n+void\n+end_protect (finalization)\n+     tree finalization;\n+{\n+}\n \n-/* Local variables which give the appearance that exception\n-   handling is part of the language and the execution model.  */\n+void\n+expand_start_try_stmts ()\n+{\n+  sorry_no_eh ();\n+}\n \n-/* The type of the exception handler stack.  */\n-tree EHS_type;\n+void\n+expand_end_try_stmts ()\n+{\n+}\n \n-/* The global handler stack.  */\n-tree EHS_decl;\n+void\n+expand_start_all_catch ()\n+{\n+}\n \n-/* Cached component refs to fields of `EHS_decl'.  */\n-static tree EHS_prev, EHS_handler, EHS_parms, EHS_name;\n-static rtx EHS_parms_as_rtx, EHS_name_as_rtx;\n+void\n+expand_end_all_catch ()\n+{\n+}\n \n-/* The parameter names of this exception type.  */\n+void\n+expand_start_catch_block (typename, identifier)\n+     tree typename, identifier;\n+{\n+}\n \n-static tree last_exception_fields;\n-static tree last_exception_field_types;\n+void\n+expand_end_catch_block ()\n+{\n+}\n \n-/* When ID is VOID_TYPE_NODE, it means ``raise all''.\n-   Cannot be inline, since it uses `alloca', and that\n-   breaks code which pushes the result of this function\n-   on the stack.  */\n-static tree\n-exception_object_name (prefix, id)\n-     tree prefix;\n-     tree id;\n+void\n+init_exception_processing ()\n {\n-  /* First, cons up the `name' of this exception.  */\n-  char *name;\n-  int length = (id == void_type_node ? 3 : IDENTIFIER_LENGTH (id)) + EXCEPTION_NAME_LENGTH;\n+}\n \n-  if (prefix)\n-    length += IDENTIFIER_LENGTH (prefix) + 2;\n+void\n+expand_throw (exp)\n+     tree exp;\n+{\n+  sorry_no_eh ();\n+}\n \n-  name = (char *)alloca (length);\n-  strcpy (name, EXCEPTION_NAME_PREFIX);\n-  length = EXCEPTION_NAME_LENGTH;\n-  if (prefix)\n-    {\n-      strcpy (name + length, IDENTIFIER_POINTER (prefix));\n-#ifdef JOINER\n-      name[length + IDENTIFIER_LENGTH (prefix)] = JOINER;\n #else\n-      name[length + IDENTIFIER_LENGTH (prefix)] = '_';\n-#endif\n-      length += IDENTIFIER_LENGTH (prefix) + 1;\n-    }\n-  if (id == void_type_node)\n-    strcpy (name + length, \"all\");\n-  else\n-    strcpy (name + length, IDENTIFIER_POINTER (id));\n-  return get_identifier (name);\n-}\n \n-tree\n-lookup_exception_cname (ctype, cname, raise_id)\n-     tree ctype, cname;\n-     tree raise_id;\n+static int\n+doing_eh (do_warn)\n+     int do_warn;\n {\n-  tree this_cname = TREE_PURPOSE (raise_id);\n-  if (this_cname == NULL_TREE)\n+  if (! flag_handle_exceptions)\n     {\n-      if (cname)\n+      static int warned = 0;\n+      if (! warned && do_warn)\n \t{\n-\t  tree name = TREE_VALUE (raise_id);\n-\t  if (purpose_member (name, CLASSTYPE_TAGS (ctype)))\n-\t    this_cname = cname;\n+\t  error (\"exception handling disabled, use -fhandle-exceptions to enable.\");\n+\t  warned = 1;\n \t}\n+      return 0;\n     }\n-  else if (this_cname == void_type_node)\n-    this_cname = NULL_TREE;\n-  else if (TREE_CODE (this_cname) != IDENTIFIER_NODE)\n-    {\n-      sorry (\"multiple scope refs in `cplus_expand_raise_stmt'\");\n-      this_cname = error_mark_node;\n-    }\n-  return this_cname;\n+  return 1;\n }\n \n-tree\n-lookup_exception_tname (oname)\n-     tree oname;\n-{\n-  return get_identifier (IDENTIFIER_POINTER (oname) + EXCEPTION_NAME_LENGTH);\n-}\n \n-tree\n-lookup_exception_object (cname, name, complain)\n-     tree cname, name;\n-     int complain;\n+/*\n+NO GNEWS IS GOOD GNEWS WITH GARRY GNUS: This version is much closer\n+to supporting exception handling as per Stroustrup's 2nd edition.\n+It is a complete rewrite of all the EH stuff that was here before\n+\tShortcomings:\n+\t\t1. The type of the throw and catch must still match\n+\t\t   exactly (no support yet for matching base classes)\n+\t\t2. Throw specifications of functions still doesnt't work.\n+\tCool Things:\n+\t\t1. Destructors are called properly :-)\n+\t\t2. No overhead for the non-exception thrown case.\n+\t\t3. Fixing shortcomings 1 and 2 is simple.\n+\t\t\t-Tad Hunt\t(tad@mail.csh.rit.edu)\n+\n+*/\n+\n+/* A couple of backend routines from m88k.c */\n+\n+/* used to cache a call to __builtin_return_address () */\n+static tree BuiltinReturnAddress;\n+\n+\n+\n+\n+\n+#include <stdio.h>\n+\n+/* XXX - Tad: for EH */\n+/* output an exception table entry */\n+\n+static void\n+output_exception_table_entry (file, start_label, end_label, eh_label)\n+     FILE *file;\n+     rtx start_label, end_label, eh_label;\n {\n-  tree oname;\n-  tree decl;\n+  char label[100];\n \n-  if (cname == void_type_node)\n-    cname = NULL_TREE;\n-  else if (cname && TREE_CODE (cname) != IDENTIFIER_NODE)\n+  fprintf (file, \"\\t%s\\t \", ASM_LONG);\t\n+  if (GET_CODE (start_label) == CODE_LABEL)\n     {\n-      sorry (\"multiple scope refs in `lookup_exception_object'\");\n-      cname = NULL_TREE;\n+      ASM_GENERATE_INTERNAL_LABEL (label, \"L\", CODE_LABEL_NUMBER (start_label));\n+      assemble_name (file, label);\n     }\n-  oname = exception_object_name (cname, name);\n-  decl = IDENTIFIER_GLOBAL_VALUE (oname);\n-  if (decl == NULL_TREE || TREE_CODE (decl) != VAR_DECL)\n+  else if (GET_CODE (start_label) == SYMBOL_REF)\n     {\n-      if (complain)\n-\t{\n-\t  push_obstacks_nochange ();\n-\n-\t  if (cname)\n-\t    error (\"no exception name object for name `%s::%s'\",\n-\t\t   IDENTIFIER_POINTER (cname),\n-\t\t   IDENTIFIER_POINTER (name));\n-\t  else\n-\t    error (\"no exception name object for name `%s'\",\n-\t\t   IDENTIFIER_POINTER (name));\n-\t  end_temporary_allocation ();\n-\t  /* Avoid further error messages.  */\n-\t  pushdecl_top_level (build_lang_field_decl (VAR_DECL,\n-\t\t\t\t\t\t     exception_object_name (cname, name),\n-\t\t\t\t\t\t     error_mark_node));\n-\t  pop_obstacks ();\n-\t}\n-      return NULL_TREE;\n+      fprintf (stderr, \"YYYYYYYYYEEEEEEEESSSSSSSSSSSS!!!!!!!!!!\\n\");\n+      assemble_name (file, XSTR (start_label, 0));\n     }\n-  return decl;\n+  putc ('\\n', file);\n+\n+  fprintf (file, \"\\t%s\\t \", ASM_LONG);\n+  ASM_GENERATE_INTERNAL_LABEL (label, \"L\", CODE_LABEL_NUMBER (end_label));\n+  assemble_name (file, label);\n+  putc ('\\n', file);\n+\n+  fprintf (file, \"\\t%s\\t \", ASM_LONG);\n+  ASM_GENERATE_INTERNAL_LABEL (label, \"L\", CODE_LABEL_NUMBER (eh_label));\n+  assemble_name (file, label);\n+  putc ('\\n', file);\n+\n+  putc ('\\n', file);\t\t/* blank line */\n+}\n+   \n+static void\n+easy_expand_asm (str)\n+     char *str;\n+{\n+  expand_asm (build_string (strlen (str)+1, str));\n }\n \n-tree\n-lookup_exception_type (ctype, cname, raise_id)\n-     tree ctype, cname;\n-     tree raise_id;\n+/* unwind the stack. */\n+static void\n+do_unwind (throw_label)\n+     rtx throw_label;\n {\n-  tree name = TREE_VALUE (raise_id);\n-  tree purpose = TREE_PURPOSE (raise_id);\n+#ifdef sparc\n+  extern FILE *asm_out_file;\n+  tree fcall;\n+  tree params;\n+  rtx return_val_rtx;\n+\n+  /* call to  __builtin_return_address () */\n+  params=tree_cons (NULL_TREE, integer_zero_node, NULL_TREE);\n+  fcall = build_function_call (BuiltinReturnAddress, params);\n+  return_val_rtx = expand_expr (fcall, NULL_RTX, SImode, 0);\n+  /* In the return, the new pc is pc+8, as the value comming in is\n+     really the address of the call insn, not the next insn.  */\n+  emit_move_insn (return_val_rtx, plus_constant(gen_rtx (LABEL_REF,\n+\t\t\t\t\t\t\t Pmode,\n+\t\t\t\t\t\t\t throw_label), -8));\n+  easy_expand_asm (\"st %l0,[%fp]\");\n+  easy_expand_asm (\"st %l1,[%fp+4]\");\n+  easy_expand_asm (\"ret\");\n+  easy_expand_asm (\"restore\");\n+  emit_barrier ();\n+#endif\n+#if m88k\n+  rtx temp_frame = frame_pointer_rtx;\n \n-  if (cname && purpose == NULL_TREE)\n-    purpose = cname;\n+  temp_frame = memory_address (Pmode, temp_frame);\n+  temp_frame = copy_to_reg (gen_rtx (MEM, Pmode, temp_frame));\n \n-  if (purpose && purpose != void_type_node)\n-    {\n-      tree link = NULL_TREE;\n+  /* hopefully this will successfully pop the frame! */\n+  emit_move_insn (frame_pointer_rtx, temp_frame);\n+  emit_move_insn (stack_pointer_rtx, frame_pointer_rtx);\n+  emit_move_insn (arg_pointer_rtx, frame_pointer_rtx);\n+  emit_insn (gen_add2_insn (stack_pointer_rtx, gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t\t\t\t     (HOST_WIDE_INT)m88k_debugger_offset (stack_pointer_rtx, 0))));\n \n-      if (TREE_CODE (purpose) != IDENTIFIER_NODE)\n-\t{\n-\t  sorry (\"multiple scope refs in `lookup_exception_type'\");\n-\t  TREE_PURPOSE (raise_id) = NULL_TREE;\n-\t  return NULL_TREE;\n-\t}\n-      if (! is_aggr_typedef (purpose, 1))\n-\treturn NULL_TREE;\n-      ctype = IDENTIFIER_TYPE_VALUE (purpose);\n-      link = purpose_member (name, CLASSTYPE_TAGS (ctype));\n-      if (link)\n-\treturn TREE_VALUE (link);\n-    }\n+#if 0\n+  emit_insn (gen_add2_insn (arg_pointer_rtx, gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t\t\t\t   -(HOST_WIDE_INT)m88k_debugger_offset (arg_pointer_rtx, 0))));\n+\n+  emit_move_insn (stack_pointer_rtx, arg_pointer_rtx);\n \n-  ctype = lookup_name (name, 1);\n-  if (ctype && TREE_CODE (ctype) == TYPE_DECL)\n-    ctype = TREE_TYPE (ctype);\n-  if (ctype && TREE_CODE (ctype) == RECORD_TYPE\n-      && CLASSTYPE_DECLARED_EXCEPTION (ctype))\n-    return ctype;\n-  return NULL_TREE;\n+  emit_insn (gen_add2_insn (stack_pointer_rtx, gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t\t\t\t     (HOST_WIDE_INT)m88k_debugger_offset (arg_pointer_rtx, 0))));\n+#endif\n+#endif\n }\n \n-tree\n-finish_exception (e, list_of_fieldlists)\n-     tree e;\n-     tree list_of_fieldlists;\n-{\n-  tree parmtypes = NULL_TREE, name_field;\n-  tree cname = TYPE_NAME (e);\n \n-  if (TREE_CODE (cname) == TYPE_DECL)\n-    cname = DECL_NAME (cname);\n \n-  if (last_exception_fields)\n-    error (\"cannot declare exceptions within exceptions\");\n-  if (list_of_fieldlists && ! ANON_AGGRNAME_P (cname))\n-    cp_error (\"exception name `%T' must follow body declaration\", e);\n-  if (list_of_fieldlists)\n-    {\n-      tree prev, field;\n-\n-      /* Note: no public, private, or protected allowed.  */\n-      if (TREE_CHAIN (list_of_fieldlists))\n-\terror (\"access declarations invalid in exception declaration\");\n-      else if (TREE_PURPOSE (list_of_fieldlists) != (tree)access_default)\n-\terror (\"access declarations invalid in exception declaration\");\n-      TREE_PURPOSE (list_of_fieldlists) = (tree)access_default;\n-\n-      /* Note also: no member function declarations allowed.  */\n-      for (prev = 0, field = TREE_VALUE (list_of_fieldlists);\n-\t   field; prev = field, field = TREE_CHAIN (field))\n-\t{\n-\t  switch (TREE_CODE (field))\n-\t    {\n-\t    case FIELD_DECL:\n-\t      /* ok.  */\n-\t      parmtypes = tree_cons (NULL_TREE, TREE_TYPE (field), parmtypes);\n-\t      continue;\n-\t    case FUNCTION_DECL:\n-\t      cp_error (\"declaration of function `%D' in exception invalid\",\n-\t\t\t  field);\n-\t      break;\n-\t    case VAR_DECL:\n-\t      if (TREE_STATIC (field))\n-\t\tcp_error (\"declaration of static variable `%D' in exception invalid\", field);\n-\t      else\n-\t\tcp_error (\"declaration of constant field `%D' in exception invalid\", field);\n-\t      break;\n-\t    case CONST_DECL:\n-\t      cp_error (\"declaration of enum value `%D' in exception invalid\", field);\n-\t      break;\n-\t    case SCOPE_REF:\n-\t      error (\"use of `::' in exception context invalid\");\n-\t      break;\n-\t    }\n-\t  if (prev)\n-\t    TREE_CHAIN (prev) = TREE_CHAIN (field);\n-\t  else\n-\t    TREE_VALUE (list_of_fieldlists) = TREE_CHAIN (field);\n-\t}\n-    }\n+#if 0\n+/* This is the startup, and finish stuff per exception table. */\n \n-  /* Now that we've cleaned up the fields, add a name identifier at front.  */\n-  name_field = build_lang_field_decl (FIELD_DECL, get_identifier (\"__name\"),\n-\t\t\t\t      ptr_type_node);\n-  if (list_of_fieldlists)\n-    {\n-      TREE_CHAIN (name_field) = TREE_VALUE (list_of_fieldlists);\n-      TREE_VALUE (list_of_fieldlists) = name_field;\n-    }\n-  else\n-    list_of_fieldlists = build_tree_list (NULL_TREE, name_field);\n+/* XXX - Tad: exception handling section */\n+#ifndef EXCEPT_SECTION_ASM_OP\n+#define EXCEPT_SECTION_ASM_OP\t\"section\\t.gcc_except_table,\\\"a\\\",@progbits\"\n+#endif\n \n-  last_exception_fields = TREE_VALUE (list_of_fieldlists);\n-  if (parmtypes)\n-    {\n-      last_exception_field_types = nreverse (parmtypes);\n-      /* Set the TREE_CHAIN of what is now at the end of the\n-\t list to `void_list_node'.  */\n-      TREE_CHAIN (parmtypes) = void_list_node;\n-    }\n-  else\n-    last_exception_field_types = void_list_node;\n+#ifdef EXCEPT_SECTION_ASM_OP\n+typedef struct {\n+    void *start_protect;\n+    void *end_protect;\n+    void *exception_handler;\n+ } exception_table;\n+#endif /* EXCEPT_SECTION_ASM_OP */\n \n-  popclass (0);\n+#ifdef EXCEPT_SECTION_ASM_OP\n \n-#if 0\n-  /* Remove aggregate types from the list of tags,\n-     since these appear at global scope.  */\n-  while (x && IS_AGGR_TYPE (TREE_VALUE (x)))\n-    x = TREE_CHAIN (x);\n-  CLASSTYPE_TAGS (t) = x;\n-  y = x;\n-  while (x)\n-    {\n-      if (IS_AGGR_TYPE (TREE_VALUE (x)))\n-\tTREE_CHAIN (y) = TREE_CHAIN (x);\n-      x = TREE_CHAIN (x);\n-    }\n-#endif\n+ /* on machines which support it, the exception table lives in another section,\n+\tbut it needs a label so we can reference it...  This sets up that\n+    label! */\n+asm (EXCEPT_SECTION_ASM_OP);\n+exception_table __EXCEPTION_TABLE__[1] = { (void*)0, (void*)0, (void*)0 };\n+asm (TEXT_SECTION_ASM_OP);\n \n-  if (flag_cadillac)\n-    cadillac_finish_exception (e);\n+#endif /* EXCEPT_SECTION_ASM_OP */\n \n-  return e;\n-}\n+#ifdef EXCEPT_SECTION_ASM_OP\n+\n+ /* we need to know where the end of the exception table is... so this\n+    is how we do it! */\n+\n+asm (EXCEPT_SECTION_ASM_OP);\n+exception_table __EXCEPTION_END__[1] = { (void*)-1, (void*)-1, (void*)-1 };\n+asm (TEXT_SECTION_ASM_OP);\n+\n+#endif /* EXCEPT_SECTION_ASM_OP */\n+\n+#endif\n \n void\n-finish_exception_decl (cname, decl)\n-     tree cname, decl;\n+exception_section ()\n {\n-  /* In decl.h.  */\n-  extern tree last_function_parms;\n-\n-  /* An exception declaration.  */\n-  tree t, ctor;\n-  tree parmdecls = NULL_TREE, fields;\n-  tree list_of_fieldlists = temp_tree_cons (NULL_TREE,\n-\t\t\t\t\t    copy_list (last_exception_fields),\n-\t\t\t\t\t    NULL_TREE);\n-  tree edecl = build_lang_field_decl (VAR_DECL,\n-\t\t\t\t      exception_object_name (cname, DECL_NAME (decl)),\n-\t\t\t\t      ptr_type_node);\n-\n-  DECL_LANGUAGE (edecl) = lang_c;\n-  TREE_STATIC (edecl) = 1;\n-  TREE_PUBLIC (edecl) = 1;\n-  finish_decl (pushdecl (edecl), NULL_TREE, NULL_TREE, 0);\n-\n-  /* Now instantiate the exception decl.  */\n-  t = xref_tag (exception_type_node, DECL_NAME (decl), NULL_TREE, 0);\n-\n-  /* finish_struct will pop this.  */\n-  pushclass (t, 0);\n-\n-  /* Now add a constructor which takes as parameters all the types we\n-     just defined.  */\n-  ctor = build_lang_decl (FUNCTION_DECL, DECL_NAME (decl),\n-\t\t\t  build_cplus_method_type (t, TYPE_POINTER_TO (t),\n-\t\t\t\t\t\t   last_exception_field_types));\n-  /* Don't take `name'.  The constructor handles that.  */\n-  fields = TREE_CHAIN (TREE_VALUE (list_of_fieldlists));\n-  while (fields)\n-    {\n-      tree parm = build_decl (PARM_DECL, DECL_NAME (fields), TREE_TYPE (fields));\n-      /* Since there is a prototype, args are passed in their own types.  */\n-      DECL_ARG_TYPE (parm) = TREE_TYPE (parm);\n-#ifdef PROMOTE_PROTOTYPES\n-      if ((TREE_CODE (TREE_TYPE (fields)) == INTEGER_TYPE\n-\t   || TREE_CODE (TREE_TYPE (fields)) == ENUMERAL_TYPE)\n-\t  && TYPE_PRECISION (TREE_TYPE (fields)) < TYPE_PRECISION (integer_type_node))\n-\tDECL_ARG_TYPE (parm) = integer_type_node;\n+#ifdef ASM_OUTPUT_SECTION_NAME\n+  named_section (\".gcc_except_table\");\n+#else\n+  text_section ();\n #endif\n-      TREE_CHAIN (parm) = parmdecls;\n-      parmdecls = parm;\n-      fields = TREE_CHAIN (fields);\n-    }\n-  fields = TREE_VALUE (list_of_fieldlists);\n-  last_function_parms = nreverse (parmdecls);\n-\n-  DECL_CONSTRUCTOR_P (ctor) = 1;\n-  TYPE_HAS_CONSTRUCTOR (t) = 1;\n-  grokclassfn (t, DECL_NAME (decl), ctor, NO_SPECIAL, NULL_TREE);\n-  DECL_EXTERNAL (ctor) = 1;\n-  TREE_STATIC (ctor) = 1;\n-  TREE_PUBLIC (ctor) = 0;\n-  DECL_INLINE (ctor) = 1;\n-  make_decl_rtl (ctor, NULL_PTR, 1);\n-  finish_decl (ctor, NULL_TREE, NULL_TREE, 0);\n-  TREE_CHAIN (ctor) = TREE_VALUE (list_of_fieldlists);\n-  TREE_VALUE (list_of_fieldlists) = ctor;\n-\n-  finish_struct (t, list_of_fieldlists, 0);\n-\n-  if (current_function_decl)\n-    error (\"cannot define exception inside function scope\");\n-  else\n-    {\n-      enum debug_info_type old_write_symbols = write_symbols;\n-      write_symbols = NO_DEBUG;\n-\n-      /* Now build the constructor for this exception.  */\n-      parmdecls = DECL_ARGUMENTS (ctor);\n-      start_function (NULL_TREE, ctor, 0, 1);\n-      store_parm_decls ();\n-      pushlevel (0);\n-      clear_last_expr ();\n-      push_momentary ();\n-      expand_start_bindings (0);\n-\n-      /* Move all the parameters to the fields, skipping `this'.  */\n-      parmdecls = TREE_CHAIN (parmdecls);\n-      /* Install `name' of this exception handler.  */\n-      DECL_INITIAL (fields) = build_unary_op (ADDR_EXPR, edecl, 0);\n-      fields = TREE_CHAIN (fields);\n-      /* Install all the values.  */\n-      while (fields)\n-\t{\n-\t  /* Set up the initialization for this field.  */\n-\t  DECL_INITIAL (fields) = parmdecls;\n-\t  fields = TREE_CHAIN (fields);\n-\t  parmdecls = TREE_CHAIN (parmdecls);\n-\t}\n-      emit_base_init (t, 0);\n-\n-      finish_function (DECL_SOURCE_LINE (ctor), 1);\n-      write_symbols = old_write_symbols;\n-    }\n }\n \n-void\n-end_exception_decls ()\n+\n+\n+\n+/* from: my-cp-except.c */\n+\n+/* VI: \":set ts=4\" */\n+#if 0\n+#include <stdio.h> */\n+#include \"config.h\"\n+#include \"tree.h\"\n+#include \"rtl.h\"\n+#include \"cp-tree.h\"\n+#endif\n+#include \"decl.h\"\n+#if 0\n+#include \"flags.h\"\n+#endif\n+#include \"insn-flags.h\"\n+#include \"obstack.h\"\n+#if 0\n+#include \"expr.h\"\n+#endif\n+\n+/* ======================================================================\n+   Briefly the algorithm works like this:\n+\n+     When a constructor or start of a try block is encountered,\n+     push_eh_entry (&eh_stack) is called.  Push_eh_entry () creates a\n+     new entry in the unwind protection stack and returns a label to\n+     output to start the protection for that block.\n+\n+     When a destructor or end try block is encountered, pop_eh_entry\n+     (&eh_stack) is called.  Pop_eh_entry () returns the ehEntry it\n+     created when push_eh_entry () was called.  The ehEntry structure\n+     contains three things at this point.  The start protect label,\n+     the end protect label, and the exception handler label.  The end\n+     protect label should be output before the call to the destructor\n+     (if any). If it was a destructor, then its parse tree is stored\n+     in the finalization variable in the ehEntry structure.  Otherwise\n+     the finalization variable is set to NULL to reflect the fact that\n+     is the the end of a try block.  Next, this modified ehEntry node\n+     is enqueued in the finalizations queue by calling\n+     enqueue_eh_entry (&queue,entry).\n+\n+\t+---------------------------------------------------------------+\n+\t|XXX: Will need modification to deal with partially\t\t|\n+\t|\t\t\tconstructed arrays of objects\t\t|\n+\t|\t\t\t\t\t\t\t\t|\n+\t|\tBasically, this consists of keeping track of how many\t|\n+\t|\tof the objects have been constructed already (this\t|\n+\t|\tshould be in a register though, so that shouldn't be a\t|\n+\t|\tproblem.\t\t\t\t\t\t|\n+\t+---------------------------------------------------------------+\n+\n+     When a catch block is encountered, there is a lot of work to be\n+     done.\n+\n+     Since we don't want to generate the catch block inline with the\n+     regular flow of the function, we need to have some way of doing\n+     so.  Luckily, we have a couple of routines \"get_last_insn ()\" and\n+     \"set_last_insn ()\" provided.  When the start of a catch block is\n+     encountered, we save a pointer to the last insn generated.  After\n+     the catch block is generated, we save a pointer to the first\n+     catch block insn and the last catch block insn with the routines\n+     \"NEXT_INSN ()\" and \"get_last_insn ()\".  We then set the last insn\n+     to be the last insn generated before the catch block, and set the\n+     NEXT_INSN (last_insn) to zero.\n+\n+     Since catch blocks might be nested inside other catch blocks, and\n+     we munge the chain of generated insns after the catch block is\n+     generated, we need to store the pointers to the last insn\n+     generated in a stack, so that when the end of a catch block is\n+     encountered, the last insn before the current catch block can be\n+     popped and set to be the last insn, and the first and last insns\n+     of the catch block just generated can be enqueue'd for output at\n+     a later time.\n+  \t\t\n+     Next we must insure that when the catch block is executed, all\n+     finalizations for the matching try block have been completed.  If\n+     any of those finalizations throw an exception, we must call\n+     terminate according to the ARM (section r.15.6.1).  What this\n+     means is that we need to dequeue and emit finalizations for each\n+     entry in the ehQueue until we get to an entry with a NULL\n+     finalization field.  For any of the finalization entries, if it\n+     is not a call to terminate (), we must protect it by giving it\n+     another start label, end label, and exception handler label,\n+     setting its finalization tree to be a call to terminate (), and\n+     enqueue'ing this new ehEntry to be output at an outer level.\n+     Finally, after all that is done, we can get around to outputting\n+     the catch block which basically wraps all the \"catch (...) {...}\"\n+     statements in a big if/then/else construct that matches the\n+     correct block to call.\n+     \n+     ===================================================================== */\n+\n+extern rtx emit_insn\t\tPROTO((rtx));\n+extern rtx gen_nop\t\tPROTO(());\n+extern void do_unwind\t\tPROTO((rtx));\n+\n+/* local globals for function calls\n+   ====================================================================== */\n+\n+/* used to cache \"terminate ()\", \"unexpected ()\", \"set_terminate ()\", and\n+   \"set_unexpected ()\" after default_conversion. (lib-except.c) */\n+static tree Terminate, Unexpected, SetTerminate, SetUnexpected, CatchMatch;\n+\n+/* used to cache __find_first_exception_table_match ()\n+   for throw (lib-except.c)  */\n+static tree FirstExceptionMatch;\n+\n+/* used to cache a call to __unwind_function () (lib-except.c) */\n+static tree Unwind;\n+\n+/* holds a ready to emit call to \"terminate ()\". */\n+static tree TerminateFunctionCall;\n+\n+/* ====================================================================== */\n+\n+\n+\n+/* data structures for my various quick and dirty stacks and queues\n+   Eventually, most of this should go away, because I think it can be\n+   integrated with stuff already built into the compiler. */\n+\n+/* =================================================================== */\n+\n+struct labelNode {\n+    rtx label;\n+\tstruct labelNode *chain;\n+ };\n+\n+\n+/* this is the most important structure here.  Basically this is how I store\n+   an exception table entry internally. */\n+struct ehEntry {\n+    rtx start_label;\n+\trtx end_label;\n+\trtx exception_handler_label;\n+\n+\ttree finalization;\n+ };\n+\n+struct ehNode {\n+    struct ehEntry *entry;\n+\tstruct ehNode *chain;\n+ };\n+\n+struct ehStack {\n+    struct ehNode *top;\n+ };\n+\n+struct ehQueue {\n+    struct ehNode *head;\n+\tstruct ehNode *tail;\n+ };\n+\n+struct exceptNode {\n+    rtx catchstart;\n+\trtx catchend;\n+\n+\tstruct exceptNode *chain;\n+ };\n+\n+struct exceptStack {\n+\tstruct exceptNode *top;\n+ };\n+/* ========================================================================= */\n+\n+\n+\n+/* local globals - these local globals are for storing data necessary for\n+   generating the exception table and code in the correct order.\n+\n+   ========================================================================= */\n+\n+/* holds the pc for doing \"throw\" */\n+rtx saved_pc;\n+/* holds the type of the thing being thrown. */\n+rtx saved_throw_type;\n+\n+rtx throw_label;\n+\n+static struct ehStack ehstack;\n+static struct ehQueue ehqueue;\n+static struct ehQueue eh_table_output_queue;\n+static struct exceptStack exceptstack;\n+static struct labelNode *false_label_stack = NULL;\n+static struct labelNode *caught_return_label_stack = NULL;\n+/* ========================================================================= */\n+\n+/* function prototypes */\n+static struct ehEntry *pop_eh_entry\tPROTO((struct ehStack *stack));\n+static void enqueue_eh_entry\t\tPROTO((struct ehQueue *queue, struct ehEntry *entry));\n+static void push_except_stmts\t\tPROTO((struct exceptStack *exceptstack,\n+\t\t\t\t\t rtx catchstart, rtx catchend));\n+static int pop_except_stmts\t\tPROTO((struct exceptStack *exceptstack,\n+\t\t\t\t\t rtx *catchstart, rtx *catchend));\n+static rtx push_eh_entry\t\tPROTO((struct ehStack *stack));\n+static struct ehEntry *dequeue_eh_entry\tPROTO((struct ehQueue *queue));\n+static void new_eh_queue\t\tPROTO((struct ehQueue *queue));\n+static void new_eh_stack\t\tPROTO((struct ehStack *stack));\n+static void new_except_stack\t\tPROTO((struct exceptStack *queue));\n+static void push_last_insn\t\tPROTO(());\n+static rtx pop_last_insn\t\tPROTO(());\n+static void push_label_entry\t\tPROTO((struct labelNode **labelstack, rtx label));\n+static rtx pop_label_entry\t\tPROTO((struct labelNode **labelstack));\n+static rtx top_label_entry\t\tPROTO((struct labelNode **labelstack));\n+static struct ehEntry *copy_eh_entry\tPROTO((struct ehEntry *entry));\n+\n+\n+\n+/* All my cheesy stack/queue/misc data structure handling routines\n+\n+   ========================================================================= */\n+\n+static void\n+push_label_entry (labelstack, label)\n+     struct labelNode **labelstack;\n+     rtx label;\n {\n-  last_exception_field_types = NULL_TREE;\n-  last_exception_fields = NULL_TREE;\n+  struct labelNode *newnode=(struct labelNode*)xmalloc (sizeof (struct labelNode));\n+\n+  newnode->label = label;\n+  newnode->chain = *labelstack;\n+  *labelstack = newnode;\n }\n-\f\n-/* Statement-level exception semantics.  */\n \n-void\n-cplus_expand_start_try (implicit)\n-     int implicit;\n+static rtx\n+pop_label_entry (labelstack)\n+     struct labelNode **labelstack;\n {\n-  tree call_to_setjmp;\n-  tree handler, ref;\n+  rtx label;\n+  struct labelNode *tempnode;\n \n-  /* Start a new block enclosing the whole handler.  */\n-  if (implicit)\n-    {\n-      pushlevel_temporary (1);\n-    }\n-  else\n-    {\n-      pushlevel (0);\n-      clear_last_expr ();\n-      push_momentary ();\n-\n-      /* Encompass whole exception handler in one big binding contour.\n-\t If RAISE should throw out of the whole TRY/EXCEPT block, call\n-\t `expand_start_bindings' with argument of 1.  */\n-      expand_start_bindings (0);\n-    }\n+  if (! *labelstack) return NULL_RTX;\n \n-  /* Allocate handler in that block.  It's real name will come later.\n-     Note that it will be the first name in this binding contour.  */\n-  handler = get_temp_name (EHS_type, 0);\n-  DECL_INITIAL (handler) = error_mark_node;\n-  finish_decl (handler, NULL_TREE, NULL_TREE, 0);\n+  tempnode = *labelstack;\n+  label = tempnode->label;\n+  *labelstack = (*labelstack)->chain;\n+  free (tempnode);\n \n-  /* Must come after call to `finish_decl', else the cleanup for the temp\n-     for the handler will cause the contour we just created to be popped.  */\n-  if (implicit)\n-    declare_implicit_exception ();\n+  return label;\n+}\n \n-  /* Catch via `setjmp'.  */\n-  ref = build_component_ref (handler, get_identifier (\"handler\"), NULL_TREE, 0);\n-  call_to_setjmp = build_function_call (BISJ, build_tree_list (NULL_TREE, ref));\n+static rtx\n+top_label_entry (labelstack)\n+     struct labelNode **labelstack;\n+{\n+  if (! *labelstack) return NULL_RTX;\n \n-  /* RAISE throws to EXCEPT part.  */\n-  expand_start_try (build_binary_op (EQ_EXPR, call_to_setjmp, integer_zero_node, 1), 0, 1);\n+  return (*labelstack)->label;\n }\n \n-/* If KEEP is 1, then declarations in the TRY statement are worth keeping.\n-   If KEEP is 2, then the TRY statement was generated by the compiler.\n-   If KEEP is 0, the declarations in the TRY statement contain errors.  */\n-\n-tree\n-cplus_expand_end_try (keep)\n-     int keep;\n+static void\n+push_except_stmts (exceptstack, catchstart, catchend)\n+     struct exceptStack *exceptstack;\n+     rtx catchstart, catchend;\n {\n-  tree decls, decl, block;\n+  struct exceptNode *newnode = (struct exceptNode*)\n+    xmalloc (sizeof (struct exceptNode));\n \n-  if (keep < 2)\n-    pop_implicit_try_blocks (NULL_TREE);\n+  newnode->catchstart = catchstart;\n+  newnode->catchend = catchend;\n+  newnode->chain = exceptstack->top;\n \n-  decls = getdecls ();\n+  exceptstack->top = newnode;\n+}\n \n-  /* Emit code to avoid falling through into a default\n-     handler that might come later.  */\n-  expand_end_try ();\n+static int\n+pop_except_stmts (exceptstack, catchstart, catchend)\n+     struct exceptStack *exceptstack;\n+     rtx *catchstart, *catchend;\n+{\n+  struct exceptNode *tempnode;\n \n-  /* Pops binding contour local to TRY, and get the exception handler\n-     object built by `...start_try'.  */\n-  switch (keep)\n-    {\n-    case 0:\n-      expand_end_bindings (decls, 0, 1);\n-      block = poplevel (0, 0, 0);\n-      pop_momentary (); \n-      decl = getdecls ();\n-      break;\n-\n-    case 1:\n-      expand_end_bindings (decls, 1, 1);\n-      block = poplevel (1, 1, 0);\n-      pop_momentary ();\n-      decl = getdecls ();\n-      break;\n-\n-    default:\n-      decl = tree_last (decls);\n-      block = NULL_TREE;\n-      break;\n-    }\n+  if (!exceptstack->top) {\n+    *catchstart = *catchend = NULL_RTX;\n+    return 0;\n+  }\n \n-  my_friendly_assert (TREE_CODE (decl) == VAR_DECL\n-\t\t      && TREE_TYPE (decl) == EHS_type, 203);\n-  if (block)\n-    {\n-      BLOCK_HANDLER_BLOCK (block) = 1;\n-      TREE_USED (block) = 1;\n-    }\n+  tempnode = exceptstack->top;\n+  exceptstack->top = exceptstack->top->chain;\n+\n+  *catchstart = tempnode->catchstart;\n+  *catchend = tempnode->catchend;\n+  free (tempnode);\n \n-  /* Pass it back so that its rtl can be bound to its name\n-     (or vice versa).  */\n-  return decl;\n+  return 1;\n }\n \n+/* Push to permanent obstack for rtl generation.\n+   One level only!  */\n+static struct obstack *saved_rtl_obstack;\n void\n-cplus_expand_start_except (name, decl)\n-     tree name, decl;\n+push_rtl_perm ()\n {\n-  int yes;\n-  tree tmp, init;\n+  extern struct obstack permanent_obstack;\n+  extern struct obstack *rtl_obstack;\n+  \n+  saved_rtl_obstack = rtl_obstack;\n+  rtl_obstack = &permanent_obstack;\n+}\n \n-  expand_start_except (0, 1);\n+/* Pop back to normal rtl handling.  */\n+static void\n+pop_rtl_from_perm ()\n+{\n+  extern struct obstack permanent_obstack;\n+  extern struct obstack *rtl_obstack;\n+  \n+  rtl_obstack = saved_rtl_obstack;\n+}\n \n-  /* This is internal `eh'.  */\n-  current_exception_decl = decl;\n-  current_exception_name_as_rtx\n-    = expand_expr (build (COMPONENT_REF, ptr_type_node,\n-\t\t\t  current_exception_decl, TREE_OPERAND (EHS_name, 1)),\n-\t\t   0, 0, 0);\n-  init = build (COMPONENT_REF, ptr_type_node, decl, TREE_OPERAND (EHS_parms, 1));\n-  current_exception_parms_as_rtx = expand_expr (init, 0, 0, 0);\n+static rtx\n+push_eh_entry (stack)\n+     struct ehStack *stack;\n+{\n+  struct ehNode *node = (struct ehNode*)xmalloc (sizeof (struct ehNode));\n+  struct ehEntry *entry = (struct ehEntry*)xmalloc (sizeof (struct ehEntry));\n \n-  if (name)\n-    {\n-      /* Get the exception object into scope (user declared `ex').  */\n-      tmp = pushdecl (build_decl (VAR_DECL, name, ptr_type_node));\n-      DECL_INITIAL (tmp) = error_mark_node;\n-      finish_decl (tmp, init, 0, 0);\n-    }\n-  current_exception_type = NULL_TREE;\n-  yes = suspend_momentary ();\n-  if (name)\n-    {\n-      /* From now on, send the user to our faked-up object.  */\n-      current_exception_object = build1 (INDIRECT_REF, void_type_node, tmp);\n-      IDENTIFIER_LOCAL_VALUE (name) = current_exception_object;\n-    }\n-  resume_momentary (yes);\n+  if (stack == NULL) {\n+    free (node);\n+    free (entry);\n+    return NULL_RTX;\n+  }\n+\n+  /* These are saved for the exception table.  */\n+  push_rtl_perm ();\n+  entry->start_label = gen_label_rtx ();\n+  entry->end_label = gen_label_rtx ();\n+  entry->exception_handler_label = gen_label_rtx ();\n+  pop_rtl_from_perm ();\n+\n+  entry->finalization = NULL_TREE;\n \n-  /* Pop exception handler stack.  */\n-  expand_assignment (EHS_decl, EHS_prev, 0, 0);\n+  node->entry = entry;\n+  node->chain = stack->top;\n+  stack->top = node;\n+\n+  enqueue_eh_entry (&eh_table_output_queue, copy_eh_entry (entry));\n+\n+  return entry->start_label;\n }\n \n-/* Generate the call to `unhandled_exception' that is appropriate\n-   for this particular unhandled exception.  */\n-static tree\n-call_to_unhandled_exception ()\n+static struct ehEntry *\n+pop_eh_entry (stack)\n+     struct ehStack *stack;\n {\n-  extern int lineno;\n-  extern tree combine_strings ();\n-  tree parms = tree_cons (NULL_TREE,\n-\t\t\t  combine_strings (build_string (strlen (input_filename + 1), input_filename)),\n-\t\t\t  build_tree_list (NULL_TREE, build_int_2 (lineno, 0)));\n-  return build_function_call (BIUE, parms);\n+  struct ehNode *tempnode;\n+  struct ehEntry *tempentry;\n+\n+  if (stack && (tempnode = stack->top)) {\n+    tempentry = tempnode->entry;\n+    stack->top = stack->top->chain;\n+    free (tempnode);\n+\n+    return tempentry;\n+  }\n+\n+  return NULL;\n }\n \n-/* Note that this must be mirror image of `...start_try'.\n-   DFAULT is the default clause, if there was one.\n-   DFAULT is ERROR_MARK_NODE when this ends an implicit handler.  */\n-void\n-cplus_expand_end_except (dfault)\n-     tree dfault;\n+static struct ehEntry *\n+copy_eh_entry (entry)\n+     struct ehEntry *entry;\n {\n-  tree decls, raised;\n+  struct ehEntry *newentry;\n \n-  if (dfault == NULL_TREE)\n-    {\n-      /* Uncaught exception at outermost level.  If raised locally,\n-\t reraise the exception.  Otherwise, generate code to call `abort'.  */\n-      if (in_try_block (1) == 0)\n-\t{\n-\t  expand_start_cond (build (EQ_EXPR, integer_type_node,\n-\t\t\t\t    exception_throw_decl, integer_zero_node), 0);\n-\t  expand_expr (call_to_unhandled_exception (), 0, VOIDmode, 0);\n-\t  expand_end_cond ();\n-\t}\n-      /* Try the next handler.  */\n-      if (! expand_escape_except ())\n-\tcompiler_error (\"except nesting botch\");\n-    }\n+  newentry = (struct ehEntry*)xmalloc (sizeof (struct ehEntry));\n+  memcpy ((void*)newentry, (void*)entry, sizeof (struct ehEntry));\n \n-  raised = expand_end_except ();\n+  return newentry;\n+}\n \n-  decls = getdecls ();\n-  expand_end_bindings (decls, decls != 0, 1);\n-  poplevel (decls != 0, 1, 0);\n+static void\n+enqueue_eh_entry (queue, entry)\n+     struct ehQueue *queue;\n+     struct ehEntry *entry;\n+{\n+  struct ehNode *node = (struct ehNode*)xmalloc (sizeof (struct ehNode));\n \n-  /* Implicit handlers do not use the momentary obstack.  */\n-  if (dfault != error_mark_node)\n-    pop_momentary ();\n+  node->entry = entry;\n+  node->chain = NULL;\n \n-  if (! in_try_block (1))\n+  if (queue->head == NULL)\n     {\n-      /* Check that this function is not raising exceptions\n-\t it is not supposed to.  */\n-      while (raised)\n-\t{\n-\t  cp_error (\"exception `%D' raised but not declared raisable\",\n-\t\t      TREE_VALUE (raised));\n-\t  raised = TREE_CHAIN (raised);\n-\t}\n+      queue->head = node;\n     }\n-  else if (dfault == NULL_TREE || dfault == error_mark_node)\n+  else\n     {\n-      expand_start_cond (build (NE_EXPR, integer_type_node,\n-\t\t\t\texception_throw_decl,\n-\t\t\t\tinteger_zero_node), 0);\n-      /* We fell off the end of this try block.  Try going to the next.\n-\t The escape_label will be the beginning of the next try block.  */\n-      if (! expand_escape_except ())\n-\tcompiler_error (\"except nesting botch\");\n-      expand_end_cond ();\n+      queue->tail->chain = node;\n     }\n+  queue->tail = node;\n }\n \n-/* Generate code to raise exception RAISE_ID.\n-   If EXP is NULL_TREE, then PARMS is the list of parameters to use\n-   for constructing this exception.\n-   If EXP is non-NULL, then it is an already constructed object\n-   of the kind that we want.\n+static struct ehEntry *\n+dequeue_eh_entry (queue)\n+     struct ehQueue *queue;\n+{\n+  struct ehNode *tempnode;\n+  struct ehEntry *tempentry;\n+\n+  if (queue->head == NULL)\n+    return NULL;\n+\n+  tempnode = queue->head;\n+  queue->head = queue->head->chain;\n+\n+  tempentry = tempnode->entry;\n+  free (tempnode);\n+\n+  return tempentry;\n+}\n+\n+static void\n+new_eh_queue (queue)\n+     struct ehQueue *queue;\n+{\n+  queue->head = queue->tail = NULL;\n+}\n+\n+static void\n+new_eh_stack (stack)\n+     struct ehStack *stack;\n+{\n+  stack->top = NULL;\n+}\n+\n+static void\n+new_except_stack (stack)\n+     struct exceptStack *stack;\n+{\n+  stack->top = NULL;\n+}\n+/* ========================================================================= */\n+\n+\n+/* sets up all the global eh stuff that needs to be initialized at the\n+   start of compilation.\n+\n+   This includes:\n+\t\t- Setting up all the function call trees\n+\t\t- Initializing the ehqueue\n+\t\t- Initializing the eh_table_output_queue\n+\t\t- Initializing the ehstack\n+\t\t- Initializing the exceptstack\n+*/\n \n-   FOR_RERAISE is non-zero if this raise is called by reraise.  In\n-   this case we do not need to emit extra gotos to avoid warning messages;\n-   the caller will do that once after all the exceptions it reraises\n-   are handled and raised.  */\n void\n-cplus_expand_raise (raise_id, parms, exp, for_reraise)\n-     tree raise_id;\n-     tree parms;\n-     tree exp;\n-     int for_reraise;\n+init_exception_processing ()\n {\n-  /* Allocate new exception of appropriate type, passing\n-     PARMS to its constructor.  */\n-  tree cname, name;\n-  tree decl;\n-  tree xexp = exp;\n-\n-  cname = lookup_exception_cname (current_class_type, current_class_name, raise_id);\n-  if (cname == error_mark_node)\n-    return;\n-  name = TREE_VALUE (raise_id);\n+  extern tree define_function ();\n+  tree unexpected_fndecl, terminate_fndecl;\n+  tree set_unexpected_fndecl, set_terminate_fndecl;\n+  tree catch_match_fndecl;\n+  tree find_first_exception_match_fndecl;\n+  tree unwind_fndecl;\n+  tree temp, PFV;\n \n-  decl = lookup_exception_object (cname, name, 1);\n-  if (decl == NULL_TREE)\n-    return;\n+  /* void (*)() */\n+  PFV = build_pointer_type (build_function_type (void_type_node, void_list_node));\n \n-  if (exp == NULL_TREE)\n-    {\n-      exp = build_method_call (NULL_TREE, name, parms, NULL_TREE, LOOKUP_COMPLAIN);\n-      if (exp == error_mark_node)\n-\treturn;\n-    }\n+  /* arg list for the build_function_type call for set_terminate () and\n+     set_unexpected () */\n+  temp = tree_cons (NULL_TREE, PFV, void_list_node);\n \n-  if (in_try_block (1))\n-    {\n-      expand_raise (decl);\n-    }\n-  else if (! current_function_decl)\n+  push_lang_context (lang_name_c);\n+\n+  set_terminate_fndecl =\n+    define_function (\"set_terminate\",\n+\t\t     build_function_type (PFV, temp),\n+\t\t     NOT_BUILT_IN,\n+\t\t     pushdecl,\n+\t\t     0);\n+  set_unexpected_fndecl =\n+    define_function (\"set_unexpected\",\n+\t\t     build_function_type (PFV, temp),\n+\t\t     NOT_BUILT_IN,\n+\t\t     pushdecl,\n+\t\t     0);\n+\n+  unexpected_fndecl =\n+    define_function (\"unexpected\",\n+\t\t     build_function_type (void_type_node, void_list_node),\n+\t\t     NOT_BUILT_IN,\n+\t\t     pushdecl,\n+\t\t     0);\n+  terminate_fndecl =\n+    define_function (\"terminate\",\n+\t\t     build_function_type (void_type_node, void_list_node),\n+\t\t     NOT_BUILT_IN,\n+\t\t     pushdecl,\n+\t\t     0);\n+  catch_match_fndecl =\n+    define_function (\"__throw_type_match\",\n+\t\t     build_function_type (integer_type_node,\n+\t\t\t\t\t  tree_cons (NULL_TREE, string_type_node, tree_cons (NULL_TREE, string_type_node, void_list_node))),\n+\t\t     NOT_BUILT_IN,\n+\t\t     pushdecl,\n+\t\t     0);\n+  find_first_exception_match_fndecl =\n+    define_function (\"__find_first_exception_table_match\",\n+\t\t     build_function_type (ptr_type_node,\n+\t\t\t\t\t  tree_cons (NULL_TREE, ptr_type_node,\n+\t\t\t\t\t\t     void_list_node)),\n+\t\t     NOT_BUILT_IN,\n+\t\t     pushdecl,\n+\t\t     0);\n+  unwind_fndecl =\n+    define_function (\"__unwind_function\",\n+\t\t     build_function_type (void_type_node,\n+\t\t\t\t\t  tree_cons (NULL_TREE, ptr_type_node, void_list_node)),\n+\t\t     NOT_BUILT_IN,\n+\t\t     pushdecl,\n+\t\t     0);\n+\n+  Unexpected = default_conversion (unexpected_fndecl);\n+  Terminate = default_conversion (terminate_fndecl);\n+  SetTerminate = default_conversion (set_terminate_fndecl);\n+  SetUnexpected = default_conversion (set_unexpected_fndecl);\n+  CatchMatch = default_conversion (catch_match_fndecl);\n+  FirstExceptionMatch = default_conversion (find_first_exception_match_fndecl);\n+  Unwind = default_conversion (unwind_fndecl);\n+  BuiltinReturnAddress = default_conversion (builtin_return_address_fndecl);\n+\n+  TerminateFunctionCall = build_function_call (Terminate, NULL_TREE);\n+\n+  pop_lang_context ();\n+  throw_label = gen_label_rtx ();\n+  saved_pc = gen_rtx (REG, Pmode, 16);\n+  saved_throw_type = gen_rtx (REG, Pmode, 17);\n+\n+  new_eh_queue (&ehqueue);\n+  new_eh_queue (&eh_table_output_queue);\n+  new_eh_stack (&ehstack);\n+  new_except_stack (&exceptstack);\n+}\n+\n+/* call this to begin a block of unwind protection (ie: when an object is\n+   constructed) */\n+void\n+start_protect ()\n+{\n+  if (doing_eh (0))\n     {\n-      if (xexp == NULL_TREE)\n-\tcp_error (\"invalid raise of `%D' outside of functions\", decl);\n-      else\n-\tcp_error (\"invalid reraise of `%D' outside of functions\", decl);\n-    }\n-  else\n-    {\n-      /* Test this raise against what this function permits.  */\n-      tree names = TYPE_RAISES_EXCEPTIONS (TREE_TYPE (current_function_decl));\n-      while (names)\n-\t{\n-\t  if (decl == TREE_TYPE (names))\n-\t    break;\n-\t  names = TREE_CHAIN (names);\n-\t}\n-      if (names == NULL_TREE)\n-\t{\n-\t  error (\"current function not declared to raise exception `%s'\",\n-\t\t IDENTIFIER_POINTER (name));\n-\t  return;\n-\t}\n+      emit_label (push_eh_entry (&ehstack));\n     }\n+}\n+   \n+/* call this to end a block of unwind protection.  the finalization tree is\n+   the finalization which needs to be run in order to cleanly unwind through\n+   this level of protection. (ie: call this when a scope is exited)*/\n+void\n+end_protect (finalization)\n+     tree finalization;\n+{\n+  struct ehEntry *entry = pop_eh_entry (&ehstack);\n \n-  store_expr (exp, EHS_parms_as_rtx, 0);\n+  if (! doing_eh (0))\n+    return;\n \n-  /* Set the global exception handler stack's NAME field\n-     to the `name' of this exception.  The global exception\n-     handler stack is the container for the exception object\n-     we just built.\n+  emit_label (entry->end_label);\n \n-     We go through a function call to make life easier when debugging.  */\n-#if 0\n-  expand_assignment (EHS_name, build_unary_op (ADDR_EXPR, decl, 0), 0, 0);\n-#else\n-  parms = tree_cons (NULL_TREE, build_unary_op (ADDR_EXPR, EHS_name, 0),\n-\t\t     build_tree_list (NULL_TREE,\n-\t\t\t\t      build_unary_op (ADDR_EXPR, decl, 0)));\n-  expand_expr (build_function_call (BIR, parms), 0, 0, 0);\n-#endif\n+  entry->finalization = finalization;\n+\n+  enqueue_eh_entry (&ehqueue, entry);\n+}\n \n-  /* Activate thrower.  If we are inside a TRY statement,\n-     we can cheat and not do this, saving a longjmp.  */\n-  if (in_try_block (1) == 0)\n+/* call this on start of a try block. */\n+void\n+expand_start_try_stmts ()\n+{\n+  if (doing_eh (1))\n     {\n-      sets_exception_throw_decl = 1;\n-      emit_move_insn (DECL_RTL (exception_throw_decl), const1_rtx);\n+      start_protect ();\n     }\n+}\n \n-  if (xexp == NULL_TREE)\n-    {    \n-      /* Invoke destructors for current procedure or handler.  */\n-      if (! expand_escape_except ())\n-\tcompiler_error (\"except nesting botch\");\n-      /* Throw via `longjmp'... Done as side-effect of goto.  */\n-    }\n-  /* To avoid spurious warning messages, we add a goto to the end\n-     of the function.  This code is dead, and the compiler should\n-     know how to delete it, but for now, we are stuck with it.  */\n-  if (! for_reraise\n-      && TREE_TYPE (DECL_RESULT (current_function_decl)) != void_type_node)\n-    expand_null_return ();\n+void\n+expand_end_try_stmts ()\n+{\n+  end_protect (integer_zero_node);\n }\n \n-extern tree cplus_exception_name ();\n+struct insn_save_node {\n+\trtx last;\n+\tstruct insn_save_node *chain;\n+ };\n \n-tree\n-ansi_exception_object_lookup (type)\n-     tree type;\n+static struct insn_save_node *InsnSave = NULL;\n+\n+\n+/* Used to keep track of where the catch blocks start.  */\n+static void\n+push_last_insn ()\n {\n-  tree raise_id = cplus_exception_name (type);\n-  tree decl;\n+  struct insn_save_node *newnode = (struct insn_save_node*)\n+    xmalloc (sizeof (struct insn_save_node));\n \n-  decl = IDENTIFIER_GLOBAL_VALUE (raise_id);\n-  if (decl == NULL_TREE || TREE_CODE (decl) != VAR_DECL)\n-    {\n-      push_obstacks_nochange ();\n-      end_temporary_allocation ();\n-      decl = build_decl (VAR_DECL, raise_id, ptr_type_node);\n-      TREE_PUBLIC (decl) = 1;\n-      TREE_STATIC (decl) = 1;\n-      pushdecl_top_level (decl);\n-      make_decl_rtl (decl, (char*)0, 1);\n-      pop_obstacks ();\n-    }\n-  return decl;\n+  newnode->last = get_last_insn ();\n+  newnode->chain = InsnSave;\n+  InsnSave = newnode;\n }\n \n-/* Generate code to throw an exception using EXP.\n-   Usng ANSI syntax and semantics.\n-   If EXP is NULL_TREE< re-raise instead. */\n+/* Use to keep track of where the catch blocks start.  */\n+static rtx\n+pop_last_insn ()\n+{\n+  struct insn_save_node *tempnode;\n+  rtx temprtx;\n+\n+  if (!InsnSave) return NULL_RTX;\n+\n+  tempnode = InsnSave;\n+  temprtx = tempnode->last;\n+  InsnSave = InsnSave->chain;\n+\n+  free (tempnode);\n+\n+  return temprtx;\n+}\n \n+/* call this to start processing of all the catch blocks. */\n void\n-cplus_expand_throw (exp)\n-     tree exp;\n+expand_start_all_catch ()\n {\n-  tree parms;\n-  int for_reraise;\n-  /* Allocate new exception of appropriate type, passing\n-     PARMS to its constructor.  */\n-  tree decl = ansi_exception_object_lookup (TREE_TYPE (exp));\n-  tree xexp = exp;\n-\n-  if (in_try_block (1))\n+  struct ehEntry *entry;\n+  rtx label;\n+\n+  if (! doing_eh (1))\n+    return;\n+\n+  emit_line_note (input_filename, lineno);\n+  label = gen_label_rtx ();\n+  /* The label for the exception handling block we will save.  */\n+  emit_label (label);\n+  push_label_entry (&caught_return_label_stack, label);\n+\n+  /* Remember where we started. */\n+  push_last_insn ();\n+\n+  /* Will this help us not stomp on it? */\n+  emit_insn (gen_rtx (USE, VOIDmode, saved_throw_type));\n+\n+  while (1)\n     {\n+      entry = dequeue_eh_entry (&ehqueue);\n+      emit_label (entry->exception_handler_label);\n+\n+      expand_expr (entry->finalization, const0_rtx, VOIDmode, 0);\n+\n+      /* When we get down to the matching entry, stop.  */\n+      if (entry->finalization == integer_zero_node)\n+\tbreak;\n+\n+      free (entry);\n+    }\n+\n+  /* This goes when the below moves out of our way.  */\n #if 1\n-      my_friendly_abort (35);\n-#else\n-      expand_raise (decl);\n+  label = gen_label_rtx ();\n+  emit_jump (label);\n #endif\n-    }\n-  else if (! current_function_decl)\n-    error (\"invalid throw outside of functions\");\n-  else\n-    {\n-#if 0\n-      /* Test this raise against what this function permits.  */\n-      tree names = TYPE_RAISES_EXCEPTIONS (TREE_TYPE (current_function_decl));\n-      while (names)\n-\t{\n-\t  if (decl == TREE_TYPE (names))\n-\t    break;\n-\t  names = TREE_CHAIN (names);\n-\t}\n-      if (names == NULL_TREE)\n-\t{\n-\t  error (\"current function not declared to raise exception `%s'\",\n-\t\t IDENTIFIER_POINTER (name));\n-\t  return;\n-\t}\n+  \n+  /* All this should be out of line, and saved back in the exception handler\n+     block area.  */\n+#if 1\n+  entry->start_label = entry->exception_handler_label;\n+  /* These are saved for the exception table.  */\n+  push_rtl_perm ();\n+  entry->end_label = gen_label_rtx ();\n+  entry->exception_handler_label = gen_label_rtx ();\n+  entry->finalization = TerminateFunctionCall;\n+  pop_rtl_from_perm ();\n+  emit_label (entry->end_label);\n+\n+\n+  enqueue_eh_entry (&eh_table_output_queue, copy_eh_entry (entry));\n+\n+  /* After running the finalization, continue on out to the next\n+     cleanup, if we have nothing better to do.  */\n+  emit_move_insn (saved_pc, gen_rtx (LABEL_REF, Pmode, entry->end_label));\n+  /* Will this help us not stomp on it? */\n+  emit_insn (gen_rtx (USE, VOIDmode, saved_throw_type));\n+  emit_jump (throw_label);\n+  emit_label (entry->exception_handler_label);\n+  expand_expr (entry->finalization, const0_rtx, VOIDmode, 0);\n+  emit_barrier ();\n #endif\n-    }\n+  emit_label (label);\n+}\n \n-  store_expr (exp, EHS_parms_as_rtx, 0);\n+/* call this to end processing of all the catch blocks. */\n+void\n+expand_end_all_catch ()\n+{\n+  rtx catchstart, catchend, last;\n+  rtx label;\n \n-  /* Set the global exception handler stack's NAME field\n-     to the `name' of this exception.  The global exception\n-     handler stack is the container for the exception object\n-     we just built.\n+  if (! doing_eh (1))\n+    return;\n \n-     We go through a function call to make life easier when debugging.  */\n-#if 0\n-  expand_assignment (EHS_name, build_unary_op (ADDR_EXPR, decl, 0), 0, 0);\n-#else\n-  parms = tree_cons (NULL_TREE, build_unary_op (ADDR_EXPR, EHS_name, 0),\n-\t\t     build_tree_list (NULL_TREE,\n-\t\t\t\t      build_unary_op (ADDR_EXPR, decl, 0)));\n-  expand_expr (build_function_call (BIR, parms), 0, 0, 0);\n-#endif\n+  /* Find the start of the catch block.  */\n+  last = pop_last_insn ();\n+  catchstart = NEXT_INSN (last);\n+  catchend = get_last_insn ();\n \n-  /* Activate thrower.  If we are inside a TRY statement,\n-     we can cheat and not do this, saving a longjmp.  */\n-  if (in_try_block (1) == 0)\n-    {\n-      sets_exception_throw_decl = 1;\n-      emit_move_insn (DECL_RTL (exception_throw_decl), const1_rtx);\n-    }\n+  NEXT_INSN (last) = 0;\n+  set_last_insn (last);\n \n-  if (xexp == NULL_TREE)\n-    {    \n-      /* Invoke destructors for current procedure or handler.  */\n-      if (! expand_escape_except ())\n-\tcompiler_error (\"except nesting botch\");\n-      /* Throw via `longjmp'... Done as side-effect of goto.  */\n-    }\n+  /* this level of catch blocks is done, so set up the successful catch jump\n+     label for the next layer of catch blocks. */\n+  pop_label_entry (&caught_return_label_stack);\n \n-  /* XXX: for_reraise is never set above here.  */\n-  /* To avoid spurious warning messages, we add a goto to the end\n-     of the function.  This code is dead, and the compiler should\n-     know how to delete it, but for now, we are stuck with it.  */\n-  if (! for_reraise\n-      && TREE_TYPE (DECL_RESULT (current_function_decl)) != void_type_node)\n-    expand_null_return ();\n+  push_except_stmts (&exceptstack, catchstart, catchend);\n+  \n+  /* Here was fall through into the continuation code.  */\n }\n \n-tree\n-cplus_expand_start_catch (raise_id)\n-     tree raise_id;\n+\n+/* this is called from expand_exception_blocks () to expand the toplevel\n+   finalizations for a function. */\n+void\n+expand_leftover_cleanups ()\n {\n-  tree cname = lookup_exception_cname (current_class_type, current_class_name, raise_id);\n-  tree decl;\n-  tree cond;\n+  struct ehEntry *entry;\n+  rtx first_label = NULL_RTX;\n \n-  if (cname == error_mark_node)\n-    {\n-      decl = error_mark_node;\n-      cond = error_mark_node;\n-    }\n-  else\n+  if (! doing_eh (0))\n+    return;\n+\n+  /* Will this help us not stomp on it? */\n+  emit_insn (gen_rtx (USE, VOIDmode, saved_throw_type));\n+\n+  while ((entry = dequeue_eh_entry (&ehqueue)) != 0)\n     {\n-      decl = lookup_exception_object (cname, TREE_VALUE (raise_id), 1);\n-      if (decl == NULL_TREE)\n-\tcond = error_mark_node;\n-      else\n-\tcond = build_binary_op (EQ_EXPR, build_unary_op (ADDR_EXPR, decl, 0),\n-\t\t\t\tbuild (COMPONENT_REF, ptr_type_node,\n-\t\t\t\t       current_exception_decl,\n-\t\t\t\t       TREE_OPERAND (EHS_name, 1)),\n-\t\t\t\t1);\n-    }\n-  expand_start_cond (cond, 0);\n+      if (! first_label)\n+\tfirst_label = entry->exception_handler_label;\n+      emit_label (entry->exception_handler_label);\n+\n+      expand_expr (entry->finalization, const0_rtx, VOIDmode, 0);\n \n-  /* Does nothing right now.  */\n-  expand_catch (decl);\n-  if (current_exception_type\n-      && TYPE_NEEDS_DESTRUCTOR (current_exception_type))\n+      /* leftover try block, opps.  */\n+      if (entry->finalization == integer_zero_node)\n+\tabort ();\n+\n+      free (entry);\n+    }\n+  if (first_label)\n     {\n-      /* Make a cleanup for the name-specific exception object now in scope.  */\n-      tree cleanup = maybe_build_cleanup (current_exception_object);\n-      expand_start_bindings (0);\n-      expand_decl_cleanup (NULL_TREE, cleanup);\n+      rtx label;\n+      struct ehEntry entry;\n+      /* These are saved for the exception table.  */\n+      push_rtl_perm ();\n+      label = gen_label_rtx ();\n+      entry.start_label = first_label;\n+      entry.end_label = label;\n+      entry.exception_handler_label = gen_label_rtx ();\n+      entry.finalization = TerminateFunctionCall;\n+      pop_rtl_from_perm ();\n+      emit_label (label);\n+\n+      enqueue_eh_entry (&eh_table_output_queue, copy_eh_entry (&entry));\n+\n+      /* After running the finalization, continue on out to the next\n+\t cleanup, if we have nothing better to do.  */\n+      emit_move_insn (saved_pc, gen_rtx (LABEL_REF, Pmode, entry.end_label));\n+      /* Will this help us not stomp on it? */\n+      emit_insn (gen_rtx (USE, VOIDmode, saved_throw_type));\n+      emit_jump (throw_label);\n+      emit_label (entry.exception_handler_label);\n+      expand_expr (entry.finalization, const0_rtx, VOIDmode, 0);\n+      emit_barrier ();\n     }\n-  return decl;\n }\n-tree\n-ansi_expand_start_catch (raise_type)\n-     tree raise_type;\n-{\n-  tree decl = ansi_exception_object_lookup (raise_type);\n-  tree cond;\n \n-  if (decl == NULL_TREE)\n-      cond = error_mark_node;\n-  else\n-      cond = build_binary_op (EQ_EXPR, build_unary_op (ADDR_EXPR, decl, 0),\n-\t\t\t      build (COMPONENT_REF, ptr_type_node,\n-\t\t\t\t     current_exception_decl,\n-\t\t\t\t     TREE_OPERAND (EHS_name, 1)),\n-\t\t\t      1);\n-  expand_start_cond (cond, 0);\n-\n-  /* Does nothing right now.  */\n-  expand_catch (decl);\n-  return decl;\n-}\n \n+/* call this to start a catch block. Typename is the typename, and identifier\n+   is the variable to place the object in or NULL if the variable doesn't\n+   matter.  If typename is NULL, that means its a \"catch (...)\" or catch\n+   everything.  In that case we don't need to do any type checking.\n+   (ie: it ends up as the \"else\" clause rather than an \"else if\" clause) */\n void\n-cplus_expand_end_catch (for_reraise)\n-     int for_reraise;\n+expand_start_catch_block (typename, identifier)\n+     tree typename, identifier;\n {\n-  if (current_exception_type\n-      && TYPE_NEEDS_DESTRUCTOR (current_exception_type))\n-    {\n-      /* Destroy the specific exception object now in scope.  */\n-      expand_end_bindings (getdecls (), 0, 1);\n-    }\n-  if (for_reraise)\n+  rtx false_label_rtx;\n+  tree type;\n+\n+  if (! doing_eh (1))\n+    return;\n+\n+  if (typename)\n+    type = groktypename (typename);\n+  else\n+    type = NULL_TREE;\n+\n+  false_label_rtx = gen_label_rtx ();\n+  push_label_entry (&false_label_stack, false_label_rtx);\n+\n+  if (type)\n     {\n-      if (! expand_escape_except ())\n-\tmy_friendly_abort (36);\n+      tree params;\n+      char *typestring;\n+      rtx call_rtx, return_value_rtx;\n+      tree catch_match_fcall;\n+      tree catchmatch_arg, argval;\n+\n+      typestring = build_overload_name (type, 1, 1);\n+\n+      params = tree_cons (NULL_TREE,\n+\t\t\t combine_strings (build_string (strlen (typestring)+1, typestring)),\n+\t\t\t tree_cons (NULL_TREE,\n+\t\t\t\t    make_tree (ptr_type_node, saved_throw_type),\n+\t\t\t\t    NULL_TREE));\n+      catch_match_fcall = build_function_call (CatchMatch, params);\n+      call_rtx = expand_call (catch_match_fcall, NULL_RTX, 0);\n+\n+      return_value_rtx =\n+\thard_function_value (integer_type_node, catch_match_fcall);\n+\n+      /* did the throw type match function return TRUE? */\n+      emit_cmp_insn (return_value_rtx, const0_rtx, NE, NULL_RTX,\n+\t\t    GET_MODE (return_value_rtx), 0, 0);\n+\n+      /* if it returned FALSE, jump over the catch block, else fall into it */\n+      emit_jump_insn (gen_bne (false_label_rtx));\n     }\n   else\n     {\n-      if (! expand_end_catch ())\n-\tmy_friendly_abort (37);\n+      /* Fall into the catch all section. */\n     }\n-  expand_end_cond ();\n+  emit_line_note (input_filename, lineno);\n }\n \n-/* Reraise an exception.\n-   If EXCEPTIONS is NULL_TREE, it means reraise whatever exception was caught.\n-   If EXCEPTIONS is an IDENTIFIER_NODE, it means reraise the exception\n-   object named by EXCEPTIONS.  This must be a variable declared in\n-   an `except' clause.\n-   If EXCEPTIONS is a TREE_LIST, it is the list of exceptions we are\n-   willing to reraise.  */\n \n-void\n-cplus_expand_reraise (exceptions)\n-     tree exceptions;\n+/* Call this to end a catch block.  Its responsible for emitting the\n+   code to handle jumping back to the correct place, and for emitting\n+   the label to jump to if this catch block didn't match.  */\n+void expand_end_catch_block ()\n {\n-  tree ex_ptr;\n-  tree ex_object = current_exception_object;\n-  rtx ex_ptr_as_rtx;\n-\n-  if (exceptions && TREE_CODE (exceptions) == IDENTIFIER_NODE)\n+  if (doing_eh (1))\n     {\n-      /* Don't get tripped up if its TREE_TYPE is `error_mark_node'.  */\n-      ex_object = IDENTIFIER_LOCAL_VALUE (exceptions);\n-      if (ex_object == NULL_TREE || TREE_CODE (ex_object) != INDIRECT_REF)\n-\t{\n-\t  error (\"`%s' is not an exception decl\", IDENTIFIER_POINTER (exceptions));\n-\t  return;\n-\t}\n-      my_friendly_assert (TREE_CODE (TREE_OPERAND (ex_object, 0)) == VAR_DECL,\n-\t\t\t  204);\n-      exceptions = NULL_TREE;\n+      /* label we jump to if we caught the exception */\n+      emit_jump (top_label_entry (&caught_return_label_stack));\n+\n+      /* label we emit to jump to if this catch block didn't match. */\n+      emit_label (pop_label_entry (&false_label_stack));\n     }\n+}\n \n-  ex_ptr = build1 (NOP_EXPR, ptr_type_node, TREE_OPERAND (ex_object, 0));\n-  ex_ptr_as_rtx = expand_expr (ex_ptr, 0, 0, 0);\n+/* cheesyness to save some typing. returns the return value rtx */\n+rtx\n+do_function_call (func, params, return_type)\n+     tree func, params, return_type;\n+{\n+  tree func_call;\n+  func_call = build_function_call (func, params);\n+  expand_call (func_call, NULL_RTX, 0);\n+  if (return_type != NULL_TREE)\n+    return hard_function_value (return_type, func_call);\n+  return NULL_RTX;\n+}\n \n-  /* reraise ALL, used by compiler.  */\n-  if (exceptions == NULL_TREE)\n-    {\n-      /* Now treat reraise like catch/raise.  */\n-      expand_catch (error_mark_node);\n-      expand_raise (error_mark_node);\n-      emit_move_insn (EHS_name_as_rtx, current_exception_name_as_rtx);\n-      store_expr ((tree) EHS_parms_as_rtx, current_exception_parms_as_rtx, 0);\n-      if (in_try_block (1) == 0)\n-\t{\n-\t  sets_exception_throw_decl = 1;\n-\t  emit_move_insn (DECL_RTL (exception_throw_decl), const1_rtx);\n-\t}\n-      /* Set to zero so that destructor will not be called.  */\n-      emit_move_insn (ex_ptr_as_rtx, const0_rtx);\n-      if (! expand_escape_except ())\n-\tmy_friendly_abort (38);\n-\n-      /* To avoid spurious warning messages, we add a goto to the end\n-\t of the function.  This code is dead, and the compiler should\n-\t know how to delete it, but for now, we are stuck with it.  */\n-      if (TREE_TYPE (DECL_RESULT (current_function_decl)) != void_type_node)\n-\texpand_null_return ();\n-\n-      return;\n-    }\n \n-  /* reraise from a list of exceptions.  */\n-  while (exceptions)\n-    {\n-      tree type = lookup_exception_type (current_class_type, current_class_name,\n-\t\t\t\t\t exceptions);\n-      if (type == NULL_TREE)\n-\t{\n-\t  error (\"`%s' is not an exception type\",\n-\t\t IDENTIFIER_POINTER (TREE_VALUE (exceptions)));\n-\t  current_exception_type = NULL_TREE;\n-\t  TREE_TYPE (ex_object) = error_mark_node;\n-\t  TREE_TYPE (ex_ptr) = error_mark_node;\n-\t}\n-      else\n-\t{\n-\t  current_exception_type = type;\n-\t  /* In-place union.  */\n-\t  TREE_TYPE (ex_object) = type;\n-\t  TREE_TYPE (ex_ptr) = TYPE_POINTER_TO (type);\n-\t}\n+/* is called from expand_excpetion_blocks () to generate the code in a function\n+   to \"throw\" if anything in the function needs to preform a throw.\n \n-      /* Now treat reraise like catch/raise.  */\n-      cplus_expand_start_catch (exceptions);\n-      cplus_expand_raise (exceptions, NULL_TREE, ex_ptr, 1);\n-      /* Set to zero so that destructor will not be called.  */\n-      if (TREE_TYPE (ex_ptr) != error_mark_node)\n-\temit_move_insn (ex_ptr_as_rtx, const0_rtx);\n-      cplus_expand_end_catch (1);\n-      exceptions = TREE_CHAIN (exceptions);\n-    }\n-  /* Don't propagate any unhandled exceptions.  */\n-  expand_expr (call_to_unhandled_exception (), 0, VOIDmode, 0);\n-\n-  /* To avoid spurious warning messages, we add a goto to the end\n-     of the function.  This code is dead, and the compiler should\n-     know how to delete it, but for now, we are stuck with it.  */\n-  if (TREE_TYPE (DECL_RESULT (current_function_decl)) != void_type_node)\n-    expand_null_return ();\n+   expands \"throw\" as the following psuedo code:\n+\n+\tthrow:\n+\t\teh = find_first_exception_match (saved_pc);\n+\t    if (!eh) goto gotta_rethrow_it;\n+\t\tgoto eh;\n+\n+\tgotta_rethrow_it:\n+\t\tsaved_pc = __builtin_return_address (0);\n+\t\tpop_to_previous_level ();\n+\t\tgoto throw;\n+\n+ */\n+static void\n+expand_builtin_throw ()\n+{\n+  tree fcall;\n+  tree params;\n+  rtx return_val_rtx;\n+  rtx gotta_rethrow_it = gen_label_rtx ();\n+  rtx gotta_call_terminate = gen_label_rtx ();\n+  rtx unwind_and_throw = gen_label_rtx ();\n+  rtx goto_unwind_and_throw = gen_label_rtx ();\n+\n+  emit_label (throw_label);\n+\n+  /* search for an exception handler for the saved_pc */\n+  return_val_rtx = do_function_call (FirstExceptionMatch,\n+\t\t\t\t     tree_cons (NULL_TREE, make_tree (ptr_type_node, saved_pc), NULL_TREE),\n+\t\t\t\t     ptr_type_node);\n+\n+  /* did we find one? */\n+  emit_cmp_insn (return_val_rtx, const0_rtx, EQ, NULL_RTX,\n+\t\t GET_MODE (return_val_rtx), 0, 0);\n+\n+  /* if not, jump to gotta_rethrow_it */\n+  emit_jump_insn (gen_beq (gotta_rethrow_it));\n+\n+  /* we found it, so jump to it */\n+  emit_indirect_jump (return_val_rtx);\n+\n+  /* code to deal with unwinding and looking for it again */\n+  emit_label (gotta_rethrow_it);\n+\n+  /* call to  __builtin_return_address () */\n+  params=tree_cons (NULL_TREE, integer_zero_node, NULL_TREE);\n+  fcall = build_function_call (BuiltinReturnAddress, params);\n+  return_val_rtx = expand_expr (fcall, NULL_RTX, SImode, 0);\n+\n+  /* did __builtin_return_address () return a valid address? */\n+  emit_cmp_insn (return_val_rtx, const0_rtx, EQ, NULL_RTX,\n+\t\t GET_MODE (return_val_rtx), 0, 0);\n+\n+  emit_jump_insn (gen_beq (gotta_call_terminate));\n+\n+  /* yes it did */\n+  emit_move_insn (saved_pc, return_val_rtx);\n+  do_unwind (throw_label);\n+  emit_jump (throw_label);\n+\n+  /* no it didn't --> therefore we need to call terminate */\n+  emit_label (gotta_call_terminate);\n+  do_function_call (Terminate, NULL_TREE, NULL_TREE);\n }\n-\f\n+\n+\n+/* This is called to expand all the toplevel exception handling\n+   finalization for a function.  It should only be called once per\n+   function.  */\n void\n-setup_exception_throw_decl ()\n+expand_exception_blocks ()\n {\n-  tree call_to_longjmp, parms;\n-\n-  int old = suspend_momentary ();\n-\n-  exception_throw_decl = build_decl (VAR_DECL, get_identifier (THROW_NAME), integer_type_node);\n-  pushdecl (exception_throw_decl);\n-  parms = tree_cons (NULL_TREE, EHS_handler,\n-\t\t     build_tree_list (0, integer_one_node));\n-  call_to_longjmp = build_function_call (BILJ, parms);\n-\n-  expand_decl (exception_throw_decl);\n-  expand_decl_cleanup (exception_throw_decl,\n-\t\t       build (COND_EXPR, void_type_node,\n-\t\t\t      exception_throw_decl,\n-\t\t\t      call_to_longjmp, integer_zero_node));\n-  DECL_INITIAL (exception_throw_decl) = integer_zero_node;\n-  sets_exception_throw_decl = 0;\n-  resume_momentary (old);\n-\n-  /* Cache these, since they won't change throughout the function.  */\n-  EHS_parms_as_rtx = expand_expr (EHS_parms, 0, 0, 0);\n-  EHS_name_as_rtx = expand_expr (EHS_name, 0, 0, 0);\n+  rtx catchstart, catchend;\n+  rtx last;\n+  static rtx funcend;\n+\n+  funcend = gen_label_rtx ();\n+  emit_jump (funcend);\n+  /* expand_null_return (); */\n+\n+  while (pop_except_stmts (&exceptstack, &catchstart, &catchend)) {\n+    last = get_last_insn ();\n+    NEXT_INSN (last) = catchstart;\n+    PREV_INSN (catchstart) = last;\n+    NEXT_INSN (catchend) = 0;\n+    set_last_insn (catchend);\n+  }\n+\n+  expand_leftover_cleanups ();\n+\n+  {\n+    static int have_done = 0;\n+    if (! have_done && TREE_PUBLIC (current_function_decl)\n+\t&& ! DECL_INLINE (current_function_decl))\n+      {\n+\thave_done = 1;\n+\texpand_builtin_throw ();\n+      }\n+  }\n+  emit_label (funcend);\n }\n \n+\n+/* call this to expand a throw statement.  This follows the following\n+   algorithm:\n+\n+\t1. Allocate space to save the current PC onto the stack.\n+\t2. Generate and emit a label and save its address into the\n+\t\tnewly allocate stack space since we can't save the pc directly.\n+\t3. If this is the first call to throw in this function:\n+\t\tgenerate a label for the throw block\n+\t4. jump to the throw block label.  */\n void\n-init_exception_processing ()\n+expand_throw (exp)\n+     tree exp;\n {\n-  extern tree build_function_type (), define_function ();\n-  extern tree unhandled_exception_fndecl;\n-  tree cname = get_identifier (\"ExceptionHandler\");\n-  tree field, chain;\n-  tree ctor, dtor;\n-  tree jmp_buf_type = build_array_type (integer_type_node,\n-\t\t\t\t\tbuild_index_type (build_int_2 (_JBLEN-1, 0)));\n-  tree jmp_buf_arg_type = build_pointer_type (integer_type_node);\n-\n-  tree parmtypes = hash_tree_chain (jmp_buf_arg_type, void_list_node);\n-  tree setjmp_fndecl, longjmp_fndecl, raise_fndecl;\n-\n-  int old_interface_only = interface_only;\n-  int old_interface_unknown = interface_unknown;\n-  interface_only = 1;\n-  interface_unknown = 0;\n-  EHS_type = xref_tag (record_type_node, cname, NULL_TREE, 0);\n-  push_lang_context (lang_name_c);\n-  setjmp_fndecl = define_function (\"setjmp\",\n-\t\t\t\t   build_function_type (integer_type_node,\n-\t\t\t\t\t\t\tparmtypes),\n-\t\t\t\t   NOT_BUILT_IN, pushdecl, 0);\n-  BISJ = default_conversion (setjmp_fndecl);\n-  parmtypes = hash_tree_chain (jmp_buf_arg_type,\n-\t\t\t       hash_tree_chain (integer_type_node, void_list_node));\n-  longjmp_fndecl = define_function (\"longjmp\",\n-\t\t\t\t    build_function_type (void_type_node, parmtypes),\n-\t\t\t\t    NOT_BUILT_IN, pushdecl, 0);\n-  raise_fndecl = define_function (\"__raise_exception\",\n-\t\t\t\t  build_function_type (void_type_node,\n-\t\t\t\t\t\t       hash_tree_chain (ptr_type_node,\n-\t\t\t\t\t\t\t\t\thash_tree_chain (build_pointer_type (ptr_type_node), void_list_node))),\n-\t\t\t\t  NOT_BUILT_IN, pushdecl, 0);\n-  BILJ = default_conversion (longjmp_fndecl);\n-  BIR = default_conversion (raise_fndecl);\n-  BIUE = default_conversion (unhandled_exception_fndecl);\n+  tree raiseid = NULL_TREE;\n+  rtx temp_size;\n+  rtx label;\n+  tree type;\n \n-  pop_lang_context ();\n+  if (! doing_eh (1))\n+    return;\n \n-  /* finish_struct will pop this.  */\n-  pushclass (EHS_type, 0);\n-  field = build_lang_field_decl (FIELD_DECL, get_identifier (\"parms\"), ptr_type_node);\n-  chain = field;\n-  field = build_lang_field_decl (FIELD_DECL, get_identifier (\"name\"),\n-\t\t\t\t build_pointer_type (default_function_type));\n-  TREE_CHAIN (field) = chain;\n-  chain = field;\n-  field = build_lang_field_decl (FIELD_DECL, get_identifier (\"handler\"), jmp_buf_type);\n-  TREE_CHAIN (field) = chain;\n-  chain = field;\n-  field = build_lang_field_decl (FIELD_DECL, get_identifier (\"prev\"),\n-\t\t\t\t TYPE_POINTER_TO (EHS_type));\n-  TREE_CHAIN (field) = chain;\n-  chain = field;\n-\n-  ctor = build_lang_decl (FUNCTION_DECL, cname,\n-\t\t\t  build_cplus_method_type (EHS_type, TYPE_POINTER_TO (EHS_type), void_list_node));\n-  DECL_CONSTRUCTOR_P (ctor) = 1;\n-  TREE_STATIC (ctor) = 1;\n-  TREE_PUBLIC (ctor) = 1;\n-  DECL_EXTERNAL (ctor) = 1;\n-  grokclassfn (EHS_type, cname, ctor, NO_SPECIAL, 0);\n-  grok_ctor_properties (EHS_type, ctor);\n-  finish_decl (pushdecl (ctor), NULL_TREE, NULL_TREE, 0);\n-  /* Must copy the node here because the FUNCTION_DECL\n-     used inside the struct ain't the same as the\n-     FUNCTION_DECL we stick into the global binding\n-     contour.  */\n-  ctor = copy_node (ctor);\n-  TREE_CHAIN (ctor) = chain;\n-  chain = ctor;\n-  dtor = build_lang_decl (FUNCTION_DECL, cname,\n-\t\t\t  build_cplus_method_type (EHS_type, TYPE_POINTER_TO (EHS_type), void_list_node));\n-  TREE_STATIC (dtor) = 1;\n-  TREE_PUBLIC (dtor) = 1;\n-  DECL_EXTERNAL (dtor) = 1;\n-  grokclassfn (EHS_type, cname, dtor, DTOR_FLAG, 0);\n-  finish_decl (pushdecl (dtor), NULL_TREE, NULL_TREE, 0);\n-  /* Copy for the same reason as copying ctor.  */\n-  dtor = copy_node (dtor);\n-  TREE_CHAIN (dtor) = chain;\n-  chain = dtor;\n-  TYPE_HAS_CONSTRUCTOR (EHS_type) = 1;\n-  TYPE_HAS_DESTRUCTOR (EHS_type) = 1;\n-  finish_struct (EHS_type, temp_tree_cons (NULL_TREE, chain, NULL_TREE), 0);\n-  interface_only = old_interface_only;\n-  interface_unknown = old_interface_unknown;\n+  label = gen_label_rtx ();\n+  emit_label (label);\n+  emit_move_insn (saved_pc, gen_rtx (LABEL_REF, Pmode, label));\n+\n+  if (exp)\n+    {\n+      /* throw variable */\n+      /* First, decay it. */\n+      exp = default_conversion (exp);\n+      type = TREE_TYPE (exp);\n+    }\n+  else\n+    type = void_type_node;\n+\n+  {\n+    char *typestring = build_overload_name (type, 1, 1);\n+    tree throw_type = build1 (ADDR_EXPR, ptr_type_node, combine_strings (build_string (strlen (typestring)+1, typestring)));\n+    rtx throw_type_rtx = expand_expr (throw_type, NULL_RTX, VOIDmode, 0);\n+    emit_move_insn (saved_throw_type, throw_type_rtx);\n+  }\n+\n+  emit_jump (throw_label);\n }\n \n+\n+/* output the exception table */\n void\n-init_exception_processing_1 ()\n+build_exception_table ()\n {\n-  register tree EHS_id = get_identifier (\"exceptionHandlerStack\");\n+  extern FILE *asm_out_file;\n+  struct ehEntry *entry;\n \n-  EHS_decl = IDENTIFIER_GLOBAL_VALUE (EHS_id);\n+  if (! doing_eh (0))\n+    return;\n \n-  /* If we have no other definition, default to library implementation.  */\n-  if (EHS_decl == NULL_TREE)\n-    {\n-      EHS_decl = build_decl (VAR_DECL, EHS_id, TYPE_POINTER_TO (EHS_type));\n-      /* If we don't push this, its definition, should it be encountered,\n-\t will not be seen.  */\n-      EHS_decl = pushdecl (EHS_decl);\n-      DECL_EXTERNAL (EHS_decl) = 1;\n-      TREE_STATIC (EHS_decl) = 1;\n-      TREE_PUBLIC (EHS_decl) = 1;\n-      finish_decl (EHS_decl, NULL_TREE, NULL_TREE, 0);\n-    }\n-  else if (TREE_CODE (EHS_decl) != VAR_DECL\n-\t   || TREE_TYPE (EHS_decl) != TYPE_POINTER_TO (EHS_type))\n-    fatal (\"exception handling declarations conflict with compiler's internal model\");\n+  exception_section ();\n \n-  if (EHS_prev == NULL_TREE)\n-    {\n-      register tree EHS_DECL = build1 (INDIRECT_REF, EHS_type, EHS_decl);\n-      EHS_prev = build_component_ref (EHS_DECL, get_identifier (\"prev\"), 0, 0);\n-      EHS_handler = build_component_ref (EHS_DECL, get_identifier (\"handler\"), 0, 0);\n-      EHS_parms = build_component_ref (EHS_DECL, get_identifier (\"parms\"), 0, 0);\n-      EHS_name = build_component_ref (EHS_DECL, get_identifier (\"name\"), 0, 0);\n-    }\n+  /* Beginning marker for table. */\n+  fprintf (asm_out_file, \"        .global ___EXCEPTION_TABLE__\\n\");\n+  fprintf (asm_out_file, \"        .align 4\\n\");\n+  fprintf (asm_out_file, \"___EXCEPTION_TABLE__:\\n\");\n+  fprintf (asm_out_file, \"        .word   0, 0, 0\\n\");\n+\n+ while (entry = dequeue_eh_entry (&eh_table_output_queue)) {\n+     output_exception_table_entry (asm_out_file,\n+\t     entry->start_label, entry->end_label, entry->exception_handler_label);\n+  }\n+\n+  /* Ending marker for table. */\n+  fprintf (asm_out_file, \"        .global ___EXCEPTION_END__\\n\");\n+  fprintf (asm_out_file, \"___EXCEPTION_END__:\\n\");\n+  fprintf (asm_out_file, \"        .word   -1, -1, -1\\n\");\n+}\n+\n+/* end of: my-cp-except.c */\n+#endif\n+\n+\n+/* Build a throw expression.  */\n+tree\n+build_throw (e)\n+     tree e;\n+{\n+  e = build1 (THROW_EXPR, void_type_node, e);\n+  TREE_SIDE_EFFECTS (e) = 1;\n+  return e;\n }"}, {"sha": "c2213d5f661d86fa6606ad47b8883466f05af933", "filename": "gcc/cp/expr.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d2733caec5ebdd4664d7645375262b1e097c418/gcc%2Fcp%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d2733caec5ebdd4664d7645375262b1e097c418/gcc%2Fcp%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexpr.c?ref=8d2733caec5ebdd4664d7645375262b1e097c418", "patch": "@@ -214,6 +214,10 @@ cplus_expand_expr (exp, target, tmode, modifier)\n     case THUNK_DECL:\n       return DECL_RTL (exp);\n \n+    case THROW_EXPR:\n+      expand_throw (TREE_OPERAND (exp, 0));\n+      return NULL;\n+\n     default:\n       break;\n     }"}, {"sha": "33f1d23500e71356a964be4ef9591da7654ca1a9", "filename": "gcc/cp/gxx.gperf", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d2733caec5ebdd4664d7645375262b1e097c418/gcc%2Fcp%2Fgxx.gperf", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d2733caec5ebdd4664d7645375262b1e097c418/gcc%2Fcp%2Fgxx.gperf", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fgxx.gperf?ref=8d2733caec5ebdd4664d7645375262b1e097c418", "patch": "@@ -26,14 +26,6 @@ __typeof__, TYPEOF, NORID\n __volatile, TYPE_QUAL, RID_VOLATILE\n __volatile__, TYPE_QUAL, RID_VOLATILE\n __wchar_t, TYPESPEC, RID_WCHAR  /* Unique to ANSI C++ */,\n-all, ALL, NORID\t\t\t/* Extension */,\n-except, EXCEPT, NORID\t\t/* Extension */,\n-exception, AGGR, RID_EXCEPTION\t/* Extension */,\n-raise, RAISE, NORID\t\t/* Extension */,\n-raises, RAISES, NORID\t\t/* Extension */,\n-reraise, RERAISE, NORID\t\t/* Extension */,\n-throw, THROW, NORID\t\t/* Extension */,\n-try, TRY, NORID\t\t\t/* Extension */,\n asm, ASM_KEYWORD, NORID,\n auto, SCSPEC, RID_AUTO,\n break, BREAK, NORID,\n@@ -79,7 +71,9 @@ static, SCSPEC, RID_STATIC,\n struct, AGGR, RID_RECORD,\n switch, SWITCH, NORID,\n this, THIS, NORID,\n+throw, THROW, NORID,\n template, TEMPLATE, NORID,\n+try, TRY, NORID,\n typedef, SCSPEC, RID_TYPEDEF,\n typeof, TYPEOF, NORID,\n typeid, TYPEID, NORID,"}, {"sha": "d91a97e4a59ebd339c22c9257771a13f471880e0", "filename": "gcc/cp/gxxint.texi", "status": "modified", "additions": 53, "deletions": 5, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d2733caec5ebdd4664d7645375262b1e097c418/gcc%2Fcp%2Fgxxint.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d2733caec5ebdd4664d7645375262b1e097c418/gcc%2Fcp%2Fgxxint.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fgxxint.texi?ref=8d2733caec5ebdd4664d7645375262b1e097c418", "patch": "@@ -8,7 +8,7 @@\n @node Top, Limitations of g++, (dir), (dir)\n @chapter Internal Architecture of the Compiler\n \n-This is meant to describe the C++ frontend for gcc in detail.\n+This is meant to describe the C++ front-end for gcc in detail.\n Questions and comments to mrs@@cygnus.com.\n \n @menu\n@@ -24,6 +24,7 @@ Questions and comments to mrs@@cygnus.com.\n * Error Reporting::             \n * Parser::                      \n * Copying Objects::             \n+* Exception Handling::             \n * Concept Index::               \n @end menu\n \n@@ -555,7 +556,7 @@ IDENTIFIER_NODEs for TYPE_DECLs\n \n @item DECL_IGNORED_P\n A bit that can be set to inform the debug information output routines in\n-the backend that a certain _DECL node should be totally ignored.\n+the back-end that a certain _DECL node should be totally ignored.\n \n Used in cases where it is known that the debugging information will be\n output in another file, or where a sub-type is known not to be needed\n@@ -989,7 +990,7 @@ completely unrelated to access control!\n @node Error Reporting, Parser, Access Control, Top\n @section Error Reporting\n \n-The C++ frontend uses a call-back mechanism to allow functions to print\n+The C++ front-end uses a call-back mechanism to allow functions to print\n out reasonable strings for types and functions without putting extra\n logic in the functions where errors are found.  The interface is through\n the @code{cp_error} function (or @code{cp_warning}, etc.).  The\n@@ -1115,7 +1116,7 @@ conflicts.\n \n Unlike the others, this ambiguity is not recognized by the Working Paper.\n \n-@node  Copying Objects, Concept Index, Parser, Top\n+@node  Copying Objects, Exception Handling, Parser, Top\n @section Copying Objects\n \n The generated copy assignment operator in g++ does not currently do the\n@@ -1141,7 +1142,54 @@ them.\n This issue is currently under discussion in the core reflector\n (2/28/94).\n \n-@node Concept Index,  , Copying Objects, Top\n+@node  Copying Objects, Concept Index, Copying Objects, Top\n+@section Exception Handling\n+\n+This section describes the mapping of C++ exceptions in the C++\n+front-end, into the back-end exception handling framework.\n+\n+The basic mechanism of exception handling in the back-end is\n+unwind-protect a la elisp.  This is a general, robust, and language\n+independent representation for exceptions.\n+\n+The C++ front-end exceptions are mapping into the unwind-protect\n+semantics by the C++ front-end.  The mapping is describe below.\n+\n+Objects with RTTI support, should use the RTTI information to do mapping\n+and checking.  Objects without RTTI, like int and const char *, have to\n+use another means of matching.  Currently we use the normal mangling used in\n+building functions names.  Int's are \"i\", const char * is PCc, etc...\n+\n+Unfortunately, the standard allows standard type conversions on throw\n+parameters so they can match catch handlers.  This means we need a\n+mechanism to handle type conversion at run time, ICK.\n+\n+In C++, all cleanups should be protected by exception regions.  The\n+region starts just after the reason why the cleanup is created has\n+ended.  For example, with an automatic variable, that has a constructor,\n+it would be right after the constructor is run.  The region ends just\n+before the finalization is expanded.  Since the backend may expand the\n+cleanup multiple times along different paths, once for normal end of the\n+region, once for non-local gotos, once for returns, etc, the backend\n+must take special care to protect the finalization expansion, if the\n+expansion is for any other reason than normal region end, and it is\n+`inline' (it is inside the exception region).  The backend can either\n+choose to move them out of line, or it can created an exception region\n+over the finalization to protect it, and in the handler associated with\n+it, it would not run the finalization as it otherwise would have, but\n+rather just rethrow to the outer handler, careful to skip the normal\n+handler for the original region.\n+\n+In Ada, they will use the more runtime intensive approach of having\n+fewer regions, but at the cost of additional work at run time, to keep a\n+list of things that need cleanups.  When a variable has finished\n+construction, they add the cleanup to the list, when the come to the end\n+of the lifetime of the variable, the run the list down.  If the take a\n+hit before the section finishes normally, they examine the list for\n+actions to perform.  I hope they add this logic into the back-end, as it\n+would be nice to get that alternative approach in C++.\n+\n+@node Concept Index,  , Exception Handling, Top\n @section Concept Index\n \n @printindex cp"}, {"sha": "86bc4caea55a22b428d0bf261e0e6f723c5a5c2f", "filename": "gcc/cp/hash.h", "status": "modified", "additions": 85, "deletions": 109, "changes": 194, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d2733caec5ebdd4664d7645375262b1e097c418/gcc%2Fcp%2Fhash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d2733caec5ebdd4664d7645375262b1e097c418/gcc%2Fcp%2Fhash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fhash.h?ref=8d2733caec5ebdd4664d7645375262b1e097c418", "patch": "@@ -3,12 +3,12 @@\n /* Command-line: gperf -p -j1 -g -o -t -N is_reserved_word -k1,4,$,7 gplus.gperf  */\n struct resword { char *name; short token; enum rid rid;};\n \n-#define TOTAL_KEYWORDS 86\n+#define TOTAL_KEYWORDS 80\n #define MIN_WORD_LENGTH 2\n #define MAX_WORD_LENGTH 13\n #define MIN_HASH_VALUE 4\n-#define MAX_HASH_VALUE 196\n-/* maximum key range = 193, duplicates = 0 */\n+#define MAX_HASH_VALUE 166\n+/* maximum key range = 163, duplicates = 0 */\n \n #ifdef __GNUC__\n inline\n@@ -20,19 +20,19 @@ hash (str, len)\n {\n   static unsigned char asso_values[] =\n     {\n-     197, 197, 197, 197, 197, 197, 197, 197, 197, 197,\n-     197, 197, 197, 197, 197, 197, 197, 197, 197, 197,\n-     197, 197, 197, 197, 197, 197, 197, 197, 197, 197,\n-     197, 197, 197, 197, 197, 197, 197, 197, 197, 197,\n-     197, 197, 197, 197, 197, 197, 197, 197, 197, 197,\n-     197, 197, 197, 197, 197, 197, 197, 197, 197, 197,\n-     197, 197, 197, 197, 197, 197, 197, 197, 197, 197,\n-     197, 197, 197, 197, 197, 197, 197, 197, 197, 197,\n-     197, 197, 197, 197, 197, 197, 197, 197, 197, 197,\n-     197, 197, 197, 197, 197,   0, 197,  93,   3,  35,\n-       3,   0,  71,   8,   4,  78, 197,   3,  30,   6,\n-      29,  18,  37, 197,  55,   0,   4,  11,   7,  20,\n-       0,   8, 197, 197, 197, 197, 197, 197,\n+     167, 167, 167, 167, 167, 167, 167, 167, 167, 167,\n+     167, 167, 167, 167, 167, 167, 167, 167, 167, 167,\n+     167, 167, 167, 167, 167, 167, 167, 167, 167, 167,\n+     167, 167, 167, 167, 167, 167, 167, 167, 167, 167,\n+     167, 167, 167, 167, 167, 167, 167, 167, 167, 167,\n+     167, 167, 167, 167, 167, 167, 167, 167, 167, 167,\n+     167, 167, 167, 167, 167, 167, 167, 167, 167, 167,\n+     167, 167, 167, 167, 167, 167, 167, 167, 167, 167,\n+     167, 167, 167, 167, 167, 167, 167, 167, 167, 167,\n+     167, 167, 167, 167, 167,   0, 167,  36,   6,  60,\n+      17,   0,  16,   5,  41,  38, 167,  11,  22,   7,\n+      26,   0,   4, 167,  22,   0,   4,  44,  19,   8,\n+       5,  18, 167, 167, 167, 167, 167, 167,\n     };\n   register int hval = len;\n \n@@ -68,127 +68,103 @@ is_reserved_word (str, len)\n       {\"\",}, {\"\",}, \n       {\"__asm__\",  GCC_ASM_KEYWORD, NORID},\n       {\"this\",  THIS, NORID,},\n-      {\"delete\",  DELETE, NORID,},\n-      {\"except\",  EXCEPT, NORID\t\t/* Extension */,},\n-      {\"__asm\",  GCC_ASM_KEYWORD, NORID},\n-      {\"double\",  TYPESPEC, RID_DOUBLE,},\n-      {\"typeid\",  TYPEID, NORID,},\n-      {\"switch\",  SWITCH, NORID,},\n-      {\"try\",  TRY, NORID\t\t\t/* Extension */,},\n-      {\"enum\",  ENUM, NORID,},\n-      {\"void\",  TYPESPEC, RID_VOID,},\n-      {\"\",}, {\"\",}, {\"\",}, \n-      {\"struct\",  AGGR, RID_RECORD,},\n-      {\"\",}, \n-      {\"do\",  DO, NORID,},\n-      {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n+      {\"goto\",  GOTO, NORID,},\n       {\"__headof__\",  HEADOF, NORID},\n-      {\"\",}, {\"\",}, \n+      {\"\",}, \n+      {\"__asm\",  GCC_ASM_KEYWORD, NORID},\n       {\"__const__\",  TYPE_QUAL, RID_CONST},\n       {\"__volatile\",  TYPE_QUAL, RID_VOLATILE},\n       {\"__const\",  TYPE_QUAL, RID_CONST},\n       {\"__volatile__\",  TYPE_QUAL, RID_VOLATILE},\n-      {\"extern\",  SCSPEC, RID_EXTERN,},\n+      {\"throw\",  THROW, NORID,},\n+      {\"enum\",  ENUM, NORID,},\n+      {\"do\",  DO, NORID,},\n+      {\"template\",  TEMPLATE, NORID,},\n+      {\"sigof\",  SIGOF, NORID\t\t/* Extension */,},\n+      {\"sizeof\",  SIZEOF, NORID,},\n+      {\"delete\",  DELETE, NORID,},\n+      {\"__headof\",  HEADOF, NORID},\n+      {\"try\",  TRY, NORID,},\n+      {\"typeof\",  TYPEOF, NORID,},\n+      {\"typeid\",  TYPEID, NORID,},\n       {\"__typeof__\",  TYPEOF, NORID},\n-      {\"\",}, \n-      {\"signed\",  TYPESPEC, RID_SIGNED,},\n-      {\"case\",  CASE, NORID,},\n-      {\"class\",  AGGR, RID_CLASS,},\n+      {\"double\",  TYPESPEC, RID_DOUBLE,},\n+      {\"private\",  VISSPEC, RID_PRIVATE,},\n+      {\"short\",  TYPESPEC, RID_SHORT,},\n+      {\"extern\",  SCSPEC, RID_EXTERN,},\n       {\"__classof__\",  CLASSOF, NORID},\n-      {\"__extension__\",  EXTENSION, NORID},\n-      {\"\",}, \n-      {\"const\",  TYPE_QUAL, RID_CONST,},\n-      {\"static\",  SCSPEC, RID_STATIC,},\n       {\"\",}, \n-      {\"throw\",  THROW, NORID\t\t/* Extension */,},\n-      {\"goto\",  GOTO, NORID,},\n-      {\"signature\",  AGGR, RID_SIGNATURE\t/* Extension */,},\n+      {\"while\",  WHILE, NORID,},\n       {\"long\",  TYPESPEC, RID_LONG,},\n-      {\"private\",  VISSPEC, RID_PRIVATE,},\n       {\"new\",  NEW, NORID,},\n-      {\"template\",  TEMPLATE, NORID,},\n-      {\"\",}, \n-      {\"while\",  WHILE, NORID,},\n-      {\"\",}, \n       {\"protected\",  VISSPEC, RID_PROTECTED,},\n-      {\"continue\",  CONTINUE, NORID,},\n-      {\"\",}, \n-      {\"raise\",  RAISE, NORID\t\t/* Extension */,},\n-      {\"raises\",  RAISES, NORID\t\t/* Extension */,},\n-      {\"\",}, \n-      {\"union\",  AGGR, RID_UNION,},\n-      {\"short\",  TYPESPEC, RID_SHORT,},\n-      {\"\",}, \n-      {\"__inline\",  SCSPEC, RID_INLINE},\n-      {\"\",}, \n-      {\"__inline__\",  SCSPEC, RID_INLINE},\n-      {\"\",}, \n-      {\"__alignof__\",  ALIGNOF, NORID},\n-      {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n-      {\"sizeof\",  SIZEOF, NORID,},\n-      {\"virtual\",  SCSPEC, RID_VIRTUAL,},\n-      {\"catch\",  CATCH, NORID,},\n       {\"friend\",  SCSPEC, RID_FRIEND,},\n-      {\"typeof\",  TYPEOF, NORID,},\n-      {\"\",}, {\"\",}, \n-      {\"headof\",  HEADOF, NORID,},\n+      {\"auto\",  SCSPEC, RID_AUTO,},\n+      {\"for\",  FOR, NORID,},\n+      {\"__typeof\",  TYPEOF, NORID},\n+      {\"typedef\",  SCSPEC, RID_TYPEDEF,},\n+      {\"__extension__\",  EXTENSION, NORID},\n       {\"int\",  TYPESPEC, RID_INT,},\n-      {\"\",}, {\"\",}, \n+      {\"asm\",  ASM_KEYWORD, NORID,},\n+      {\"__classof\",  CLASSOF, NORID},\n       {\"__signed__\",  TYPESPEC, RID_SIGNED},\n-      {\"__signed\",  TYPESPEC, RID_SIGNED},\n-      {\"\",}, {\"\",}, {\"\",}, \n+      {\"signed\",  TYPESPEC, RID_SIGNED,},\n+      {\"mutable\",  SCSPEC, RID_MUTABLE,},\n+      {\"switch\",  SWITCH, NORID,},\n+      {\"operator\",  OPERATOR, NORID,},\n       {\"__attribute\",  ATTRIBUTE, NORID},\n-      {\"sigof\",  SIGOF, NORID\t\t/* Extension */,},\n+      {\"struct\",  AGGR, RID_RECORD,},\n       {\"__attribute__\",  ATTRIBUTE, NORID},\n+      {\"if\",  IF, NORID,},\n+      {\"void\",  TYPESPEC, RID_VOID,},\n+      {\"break\",  BREAK, NORID,},\n+      {\"__alignof__\",  ALIGNOF, NORID},\n+      {\"__inline\",  SCSPEC, RID_INLINE},\n+      {\"float\",  TYPESPEC, RID_FLOAT,},\n+      {\"__inline__\",  SCSPEC, RID_INLINE},\n+      {\"__signed\",  TYPESPEC, RID_SIGNED},\n+      {\"case\",  CASE, NORID,},\n+      {\"class\",  AGGR, RID_CLASS,},\n       {\"\",}, \n-      {\"__headof\",  HEADOF, NORID},\n+      {\"__label__\",  LABEL, NORID},\n+      {\"default\",  DEFAULT, NORID,},\n+      {\"const\",  TYPE_QUAL, RID_CONST,},\n+      {\"static\",  SCSPEC, RID_STATIC,},\n       {\"\",}, {\"\",}, \n-      {\"unsigned\",  TYPESPEC, RID_UNSIGNED,},\n-      {\"return\",  RETURN, NORID,},\n-      {\"asm\",  ASM_KEYWORD, NORID,},\n-      {\"__wchar_t\",  TYPESPEC, RID_WCHAR  /* Unique to ANSI C++ */,},\n-      {\"break\",  BREAK, NORID,},\n-      {\"__typeof\",  TYPEOF, NORID},\n-      {\"mutable\",  SCSPEC, RID_MUTABLE,},\n+      {\"__alignof\",  ALIGNOF, NORID},\n+      {\"virtual\",  SCSPEC, RID_VIRTUAL,},\n+      {\"union\",  AGGR, RID_UNION,},\n+      {\"\",}, {\"\",}, {\"\",}, \n+      {\"signature\",  AGGR, RID_SIGNATURE\t/* Extension */,},\n+      {\"headof\",  HEADOF, NORID,},\n       {\"\",}, \n-      {\"public\",  VISSPEC, RID_PUBLIC,},\n+      {\"inline\",  SCSPEC, RID_INLINE,},\n+      {\"overload\",  OVERLOAD, NORID,},\n       {\"\",}, \n-      {\"__classof\",  CLASSOF, NORID},\n-      {\"default\",  DEFAULT, NORID,},\n+      {\"volatile\",  TYPE_QUAL, RID_VOLATILE,},\n       {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n-      {\"exception\",  AGGR, RID_EXCEPTION\t/* Extension */,},\n-      {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n-      {\"all\",  ALL, NORID\t\t\t/* Extension */,},\n+      {\"register\",  SCSPEC, RID_REGISTER,},\n+      {\"\",}, \n+      {\"public\",  VISSPEC, RID_PUBLIC,},\n       {\"\",}, {\"\",}, \n-      {\"for\",  FOR, NORID,},\n+      {\"__wchar_t\",  TYPESPEC, RID_WCHAR  /* Unique to ANSI C++ */,},\n       {\"\",}, {\"\",}, \n-      {\"__label__\",  LABEL, NORID},\n-      {\"auto\",  SCSPEC, RID_AUTO,},\n-      {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n-      {\"volatile\",  TYPE_QUAL, RID_VOLATILE,},\n-      {\"__alignof\",  ALIGNOF, NORID},\n+      {\"return\",  RETURN, NORID,},\n+      {\"classof\",  CLASSOF, NORID,},\n       {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n-      {\"dynamic_cast\",  DYNAMIC_CAST, NORID,},\n-      {\"\",}, \n+      {\"unsigned\",  TYPESPEC, RID_UNSIGNED,},\n       {\"char\",  TYPESPEC, RID_CHAR,},\n-      {\"\",}, \n-      {\"if\",  IF, NORID,},\n-      {\"\",}, \n-      {\"typedef\",  SCSPEC, RID_TYPEDEF,},\n-      {\"operator\",  OPERATOR, NORID,},\n-      {\"reraise\",  RERAISE, NORID\t\t/* Extension */,},\n-      {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n-      {\"inline\",  SCSPEC, RID_INLINE,},\n+      {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n+      {\"continue\",  CONTINUE, NORID,},\n       {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n-      {\"\",}, \n-      {\"float\",  TYPESPEC, RID_FLOAT,},\n       {\"\",}, {\"\",}, {\"\",}, \n-      {\"overload\",  OVERLOAD, NORID,},\n-      {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n-      {\"classof\",  CLASSOF, NORID,},\n+      {\"dynamic_cast\",  DYNAMIC_CAST, NORID,},\n       {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n-      {\"\",}, {\"\",}, \n-      {\"register\",  SCSPEC, RID_REGISTER,},\n+      {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n+      {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n+      {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n+      \n+      {\"catch\",  CATCH, NORID,},\n     };\n \n   if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)"}, {"sha": "8e7014310c80ada1bf8099be22e788ca5c4a37ba", "filename": "gcc/cp/init.c", "status": "modified", "additions": 2, "deletions": 31, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d2733caec5ebdd4664d7645375262b1e097c418/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d2733caec5ebdd4664d7645375262b1e097c418/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=8d2733caec5ebdd4664d7645375262b1e097c418", "patch": "@@ -217,12 +217,8 @@ perform_member_init (member, name, init, explicit)\n \t  expand_expr_stmt (build_modify_expr (decl, INIT_EXPR, init));\n \t}\n     }\n-\n-  if (flag_handle_exceptions == 2 && TYPE_NEEDS_DESTRUCTOR (type))\n-    {\n-      cplus_expand_start_try (1);\n-      push_exception_cleanup (build_unary_op (ADDR_EXPR, decl, 0));\n-    }\n+  if (flag_handle_exceptions && TYPE_NEEDS_DESTRUCTOR (type))\n+    cp_warning (\"caution, member `%D' may not be destroyed in the presense of an exception during construction\", member);\n }\n \n /* Subroutine of emit_member_init.  */\n@@ -390,20 +386,6 @@ emit_base_init (t, immediately)\n     emit_line_note_force (DECL_SOURCE_FILE (current_function_decl),\n \t\t\t  DECL_SOURCE_LINE (current_function_decl));\n \n-  /* In this case, we always need IN_CHARGE_NODE, because we have\n-     to know whether to deallocate or not before exiting.  */\n-  if (flag_handle_exceptions == 2\n-      && lookup_name (in_charge_identifier, 0) == NULL_TREE)\n-    {\n-      tree in_charge_node = pushdecl (build_decl (VAR_DECL, in_charge_identifier,\n-\t\t\t\t\t\t  integer_type_node));\n-      store_init_value (in_charge_node, build (EQ_EXPR, integer_type_node,\n-\t\t\t\t\t       current_class_decl,\n-\t\t\t\t\t       integer_zero_node));\n-      expand_decl (in_charge_node);\n-      expand_decl_init (in_charge_node);\n-    }\n-\n   start = ! TYPE_USES_VIRTUAL_BASECLASSES (t);\n   for (pass = start; pass < 2; pass++)\n     {\n@@ -521,11 +503,6 @@ emit_base_init (t, immediately)\n \t  expand_aggr_init_1 (t_binfo, 0,\n \t\t\t      build_indirect_ref (member, NULL_PTR), init,\n \t\t\t      BINFO_OFFSET_ZEROP (binfo), LOOKUP_COMPLAIN);\n-\t  if (flag_handle_exceptions == 2 && TYPE_NEEDS_DESTRUCTOR (BINFO_TYPE (binfo)))\n-\t    {\n-\t      cplus_expand_start_try (1);\n-\t      push_exception_cleanup (member);\n-\t    }\n \t}\n \n       if (pass == 0)\n@@ -594,12 +571,6 @@ emit_base_init (t, immediately)\n \t      expand_aggr_init_1 (t_binfo, 0, ref, NULL_TREE,\n \t\t\t\t  BINFO_OFFSET_ZEROP (base_binfo),\n \t\t\t\t  LOOKUP_COMPLAIN);\n-\t      if (flag_handle_exceptions == 2\n-\t\t  && TYPE_NEEDS_DESTRUCTOR (BINFO_TYPE (base_binfo)))\n-\t\t{\n-\t\t  cplus_expand_start_try (1);\n-\t\t  push_exception_cleanup (base);\n-\t\t}\n \t    }\n \t}\n       CLEAR_BINFO_BASEINIT_MARKED (base_binfo);"}, {"sha": "7c88ba56170145c6f6c65f224f322572158ef03e", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 21, "deletions": 31, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d2733caec5ebdd4664d7645375262b1e097c418/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d2733caec5ebdd4664d7645375262b1e097c418/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=8d2733caec5ebdd4664d7645375262b1e097c418", "patch": "@@ -766,40 +766,16 @@ init_lex ()\n   do { struct resword *s = is_reserved_word (STRING, sizeof (STRING) - 1); \\\n        if (s) s->name = \"\"; } while (0)\n \n-  if (flag_ansi_exceptions)\n-      flag_handle_exceptions = 2;\n-\n-  if (!flag_ansi_exceptions)\n+#if 0\n+  /* let's parse things, and if they use it, then give them an error.  */\n+  if (!flag_handle_exceptions)\n     {\n+      UNSET_RESERVED_WORD (\"throw\");\n+      UNSET_RESERVED_WORD (\"try\");\n       UNSET_RESERVED_WORD (\"catch\");\n     }\n+#endif\n \n-  if (! flag_handle_exceptions)\n-    {\n-      /* Easiest way to not recognize exception\n-\t handling extensions...  */\n-      UNSET_RESERVED_WORD (\"all\");\n-      UNSET_RESERVED_WORD (\"except\");\n-      UNSET_RESERVED_WORD (\"exception\");\n-      UNSET_RESERVED_WORD (\"raise\");\n-      UNSET_RESERVED_WORD (\"raises\");\n-      UNSET_RESERVED_WORD (\"reraise\");\n-      UNSET_RESERVED_WORD (\"try\");\n-      UNSET_RESERVED_WORD (\"throw\");\n-    }\n-  else if (flag_ansi_exceptions)\n-    {\n-      /* Easiest way to not recognize exception\n-\t handling extensions...  */\n-      UNSET_RESERVED_WORD (\"exception\");\n-      UNSET_RESERVED_WORD (\"all\");\n-      UNSET_RESERVED_WORD (\"except\");\n-      UNSET_RESERVED_WORD (\"raise\");\n-      UNSET_RESERVED_WORD (\"raises\");\n-      UNSET_RESERVED_WORD (\"reraise\");\n-      is_reserved_word (\"try\", sizeof (\"try\") - 1)->token = ANSI_TRY;\n-      is_reserved_word (\"throw\", sizeof (\"throw\") - 1)->token = ANSI_THROW;\n-    }\n   if (! (flag_gc || flag_dossier))\n     {\n       UNSET_RESERVED_WORD (\"classof\");\n@@ -3171,6 +3147,13 @@ do_identifier (token)\n \t}\n     }\n \n+  /* Remember that this name has been used in the class definition, as per\n+     [class.scope0] */\n+  if (id && current_class_type\n+      && TYPE_BEING_DEFINED (current_class_type)\n+      && ! IDENTIFIER_CLASS_VALUE (token))\n+    pushdecl_class_level (id);\n+    \n   if (!id || id == error_mark_node)\n     {\n       if (id == error_mark_node && current_class_type != NULL_TREE)\n@@ -3496,7 +3479,14 @@ real_yylex ()\n \tif (strcmp (\"catch\", token_buffer) == 0\n \t    || strcmp (\"throw\", token_buffer) == 0\n \t    || strcmp (\"try\", token_buffer) == 0)\n-\t  pedwarn (\"`catch', `throw', and `try' are all C++ reserved words\");\n+\t  {\n+\t    static int did_warn = 0;\n+\t    if (! did_warn  && ! flag_handle_exceptions)\n+\t      {\n+\t\tpedwarn (\"`catch', `throw', and `try' are all C++ reserved words\");\n+\t\tdid_warn = 1;\n+\t      }\n+\t  }\n \n \tif (value == IDENTIFIER || value == TYPESPEC)\n \t  GNU_xref_ref (current_function_decl, token_buffer);"}, {"sha": "f46f70a22526dd3acbd6e80df90291806fd5ddf6", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 86, "deletions": 417, "changes": 503, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d2733caec5ebdd4664d7645375262b1e097c418/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d2733caec5ebdd4664d7645375262b1e097c418/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=8d2733caec5ebdd4664d7645375262b1e097c418", "patch": "@@ -192,8 +192,7 @@ empty_parms ()\n %left <code> POINTSAT '.' '(' '['\n \n %right SCOPE\t\t\t/* C++ extension */\n-%nonassoc NEW DELETE RAISE RAISES RERAISE TRY EXCEPT CATCH THROW\n-%nonassoc ANSI_TRY ANSI_THROW\n+%nonassoc NEW DELETE TRY CATCH THROW\n \n %type <code> unop\n \n@@ -209,7 +208,7 @@ empty_parms ()\n %type <ttype> asm_operands nonnull_asm_operands asm_operand asm_clobbers\n %type <ttype> maybe_attribute attribute_list attrib\n \n-%type <ttype> compstmt except_stmts ansi_except_stmts implicitly_scoped_stmt\n+%type <ttype> compstmt implicitly_scoped_stmt\n \n %type <ttype> declarator notype_declarator after_type_declarator\n %type <ttype> direct_notype_declarator direct_after_type_declarator\n@@ -251,15 +250,13 @@ empty_parms ()\n /* %type <ttype> primary_no_id */\n %type <ttype> nonmomentary_expr\n %type <itype> forhead.2 initdcl0 notype_initdcl0 member_init_list\n-%type <itype> try ansi_try\n %type <ttype> template_header template_parm_list template_parm\n %type <ttype> template_type template_arg_list template_arg\n %type <ttype> template_instantiation template_type_name tmpl.2\n %type <ttype> template_instantiate_once template_instantiate_some\n %type <itype> fn_tmpl_end\n /* %type <itype> try_for_typename */\n-%type <ttype> condition partially_scoped_stmt xcond paren_cond_or_null\n-%type <strtype> .kindof_pushlevel\n+%type <ttype> condition xcond paren_cond_or_null\n %type <ttype> type_name nested_name_specifier nested_type ptr_to_mem\n %type <ttype> qualified_type_name complete_type_name notype_identifier\n %type <ttype> complex_type_name nested_name_specifier_1\n@@ -486,7 +483,6 @@ template_def:\n \t\t\t\t  0, $<ttype>4);\n \t\t  cplus_decl_attributes (d, $6);\n \t\t  finish_decl (d, NULL_TREE, $5, 0);\n-\t\t  end_exception_decls ();\n \t\t  end_template_decl ($1, d, 0, def);\n \t\t  if (def)\n \t\t    {\n@@ -530,15 +526,13 @@ datadef:\n \t\t}\n \t| typed_declspecs initdecls ';'\n \t\t{\n-\t\t  end_exception_decls ();\n \t\t  note_list_got_semicolon ($<ttype>$);\n \t\t}\n \t/* Normal case: make this fast.  */\n \t| typed_declspecs declarator ';'\n \t\t{ tree d;\n \t\t  d = start_decl ($<ttype>2, $<ttype>$, 0, NULL_TREE);\n \t\t  finish_decl (d, NULL_TREE, NULL_TREE, 0);\n-\t\t  end_exception_decls ();\n \t\t  note_list_got_semicolon ($<ttype>$);\n \t\t}\n         | declmods ';'\n@@ -959,56 +953,6 @@ condition:\n \t| expr\n \t;\n \n-/* Used for the blocks controlled by a condition, to add any DECLs in\n-   the condition to the controlled block.  */\n-.kindof_pushlevel: /* empty */\n-\t\t{ tree d = getdecls ();\n-\t\t  emit_line_note (input_filename, lineno);\n-\t\t  pushlevel (0);\n-\t\t  clear_last_expr ();\n-\t\t  push_momentary ();\n-\t\t  expand_start_bindings (0);\n-\t\t  if (d) pushdecl (d);\n-\t        }    \n-\t;\n-\n-/* Like implicitly_scoped_stmt, but uses .kindof_pushlevel */\n-partially_scoped_stmt:\n-           '{' .kindof_pushlevel '}'\n-\t\t{ pop_implicit_try_blocks (NULL_TREE);\n-\t\t  expand_end_bindings (getdecls (), kept_level_p (), 1);\n-\t\t  $$ = poplevel (kept_level_p (), 1, 0);\n-\t\t  pop_momentary (); \n-\t\t  finish_stmt (); }\n-\t| '{' .kindof_pushlevel maybe_label_decls stmts '}'\n-\t\t{ pop_implicit_try_blocks (NULL_TREE);\n-\t\t  expand_end_bindings (getdecls (), kept_level_p (), 1);\n-\t\t  $$ = poplevel (kept_level_p (), 1, 0);\n-\t\t  pop_momentary (); \n-\t\t  finish_stmt (); }\n-\t| '{' .kindof_pushlevel maybe_label_decls error '}'\n-\t\t{ pop_implicit_try_blocks (NULL_TREE);\n-\t\t  expand_end_bindings (getdecls (), kept_level_p (), 1);\n-\t\t  $$ = poplevel (kept_level_p (), 0, 0);\n-\t\t  pop_momentary (); \n-\t\t  finish_stmt (); }\n-\t| .kindof_pushlevel simple_stmt\n-\t\t{ pop_implicit_try_blocks (NULL_TREE);\n-\t\t  expand_end_bindings (getdecls (), kept_level_p (), 1);\n-\t\t  $$ = poplevel (kept_level_p (), 1, 0);\n-\t\t  pop_momentary (); }\n-\t;\n-\n-already_scoped_stmt:\n-          '{' '}'\n-\t\t{ finish_stmt (); }\n-\t| '{' maybe_label_decls stmts '}'\n-\t\t{ finish_stmt (); }\n-\t| '{' maybe_label_decls error '}'\n-\t\t{ finish_stmt (); }\n-\t| simple_stmt\n-\t;\n-\n nontrivial_exprlist:\n \t  expr_no_commas ',' expr_no_commas\n \t\t{ $$ = tree_cons (NULL_TREE, $$, \n@@ -1262,6 +1206,10 @@ expr_no_commas:\n \t\t    $$ = rval;\n \t\t  else\n \t\t    $$ = build_modify_expr ($$, $2, $3); }\n+\t| THROW\n+\t\t{ $$ = build_throw (NULL_TREE); }\n+\t| THROW expr_no_commas\n+\t\t{ $$ = build_throw ($2); }\n /* These extensions are not defined.  The second arg to build_m_component_ref\n    is old, build_m_component_ref now does an implicit\n    build_indirect_ref (x, NULL_PTR) on the second argument.\n@@ -1767,10 +1715,10 @@ typed_declspecs1:\n \t\t{ $$ = decl_tree_cons (NULL_TREE, $$, $2); }\n \t| declmods typespec reserved_declspecs\n \t\t{ $$ = decl_tree_cons (NULL_TREE, $2, chainon ($3, $$)); }\n- \t| declmods typespec reserved_typespecquals\n- \t\t{ $$ = decl_tree_cons (NULL_TREE, $2, chainon ($3, $$)); }\n- \t| declmods typespec reserved_typespecquals reserved_declspecs\n- \t\t{ $$ = decl_tree_cons (NULL_TREE, $2, \n+\t| declmods typespec reserved_typespecquals\n+\t\t{ $$ = decl_tree_cons (NULL_TREE, $2, chainon ($3, $$)); }\n+\t| declmods typespec reserved_typespecquals reserved_declspecs\n+\t\t{ $$ = decl_tree_cons (NULL_TREE, $2, \n \t\t\t\t       chainon ($3, chainon ($4, $$))); }\n \t;\n \n@@ -1873,7 +1821,7 @@ typespec: structsp\n \t\t    }\n \t\t  else\n \t\t    {\n-  \t\t      error(\"`sigof' applied to non-aggregate type\");\n+\t\t      error(\"`sigof' applied to non-aggregate type\");\n \t\t      $$ = error_mark_node;\n \t\t    }\n \t\t}\n@@ -2150,10 +2098,6 @@ structsp:\n \t\t    /* $$ = $1 from default rule.  */;\n \t\t  else if (CLASSTYPE_DECLARED_EXCEPTION ($$))\n \t\t    {\n-\t\t      if (! semi)\n-\t\t\t$$ = finish_exception ($$, $3);\n-\t\t      else\n-\t\t\twarning (\"empty exception declaration\\n\");\n \t\t    }\n \t\t  else\n \t\t    {\n@@ -2546,12 +2490,10 @@ component_decl_1:\n \t  typed_declspecs components\n \t\t{\n \t\t  $$ = grok_x_components ($$, $2);\n-\t\t  end_exception_decls ();\n \t\t}\n \t| declmods notype_components\n \t\t{ \n \t\t  $$ = grok_x_components ($$, $2);\n-\t\t  end_exception_decls ();\n \t\t}\n \t| notype_declarator maybe_raises maybeasm maybe_attribute\n \t\t{ $$ = grokfield ($$, NULL_TREE, $2, NULL_TREE, $3);\n@@ -2764,6 +2706,18 @@ after_type_declarator:\n \n qualified_type_name:\n \t  type_name %prec EMPTY\n+\t\t{\n+\t\t  /* Remember that this name has been used in the class\n+\t\t     definition, as per [class.scope0] */\n+\t\t  if (current_class_type\n+\t\t      && TYPE_BEING_DEFINED (current_class_type)\n+\t\t      && ! IDENTIFIER_CLASS_VALUE ($$))\n+\t\t    {\n+\t\t      tree t = lookup_name ($$, -2);\n+\t\t      if (t)\n+\t\t\tpushdecl_class_level (t);\n+\t\t    }\n+\t\t}\n \t| nested_type\n \t;\n \n@@ -3072,18 +3026,15 @@ compstmt_or_error:\n \t;\n \n compstmt: '{' .pushlevel '}'\n-\t\t{ pop_implicit_try_blocks (NULL_TREE);\n-\t\t  expand_end_bindings (getdecls (), kept_level_p(), 1);\n+\t\t{ expand_end_bindings (getdecls (), kept_level_p(), 1);\n \t\t  $$ = poplevel (kept_level_p (), 1, 0);\n \t\t  pop_momentary (); }\n \t| '{' .pushlevel maybe_label_decls stmts '}'\n-\t\t{ pop_implicit_try_blocks (NULL_TREE);\n-\t\t  expand_end_bindings (getdecls (), kept_level_p(), 1);\n+\t\t{ expand_end_bindings (getdecls (), kept_level_p(), 1);\n \t\t  $$ = poplevel (kept_level_p (), 1, 0);\n \t\t  pop_momentary (); }\n \t| '{' .pushlevel maybe_label_decls error '}'\n-\t\t{ pop_implicit_try_blocks (NULL_TREE);\n-\t\t  expand_end_bindings (getdecls (), kept_level_p(), 1);\n+\t\t{ expand_end_bindings (getdecls (), kept_level_p(), 1);\n \t\t  $$ = poplevel (kept_level_p (), 0, 0);\n \t\t  pop_momentary (); }\n \t;\n@@ -3094,15 +3045,14 @@ simple_if:\n \t  .pushlevel paren_cond_or_null\n \t\t{ emit_line_note (input_filename, lineno);\n \t\t  expand_start_cond (truthvalue_conversion ($4), 0); }\n-\t  partially_scoped_stmt\n+\t  implicitly_scoped_stmt\n \t;\n \n implicitly_scoped_stmt:\n \t  compstmt\n \t\t{ finish_stmt (); }\n \t| .pushlevel simple_stmt\n-\t\t{ pop_implicit_try_blocks (NULL_TREE);\n-\t\t  expand_end_bindings (getdecls (), getdecls() != NULL_TREE, 1);\n+\t\t{ expand_end_bindings (getdecls (), getdecls() != NULL_TREE, 1);\n \t\t  $$ = poplevel (kept_level_p (), 1, 0);\n \t\t  pop_momentary (); }\n \t;\n@@ -3118,7 +3068,7 @@ simple_stmt:\n \t\t{ finish_stmt (); }\n \t| expr ';'\n \t\t{\n-  \t\t  tree expr = $1;\n+\t\t  tree expr = $1;\n \t\t  emit_line_note (input_filename, lineno);\n \t\t  /* Do default conversion if safe and possibly important,\n \t\t     in case within ({...}).  */\n@@ -3131,16 +3081,14 @@ simple_stmt:\n \t\t  finish_stmt (); }\n \t| simple_if ELSE\n \t\t{ expand_start_else (); }\n-\t  partially_scoped_stmt\n+\t  implicitly_scoped_stmt\n \t\t{ expand_end_cond ();\n-\t\t  pop_implicit_try_blocks (NULL_TREE);\n \t\t  expand_end_bindings (getdecls (), kept_level_p (), 1);\n \t\t  poplevel (kept_level_p (), 1, 0);\n \t\t  pop_momentary ();\n \t\t  finish_stmt (); }\n \t| simple_if %prec IF\n \t\t{ expand_end_cond ();\n-\t\t  pop_implicit_try_blocks (NULL_TREE);\n \t\t  expand_end_bindings (getdecls (), kept_level_p (), 1);\n \t\t  poplevel (kept_level_p (), 1, 0);\n \t\t  pop_momentary ();\n@@ -3152,9 +3100,8 @@ simple_stmt:\n \t\t  cond_stmt_keyword = \"while\"; }\n \t  .pushlevel paren_cond_or_null\n \t\t{ expand_exit_loop_if_false (0, truthvalue_conversion ($4)); }\n-\t  already_scoped_stmt\n-\t\t{ pop_implicit_try_blocks (NULL_TREE);\n-\t\t  expand_end_bindings (getdecls (), kept_level_p (), 1);\n+\t  implicitly_scoped_stmt\n+\t\t{ expand_end_bindings (getdecls (), kept_level_p (), 1);\n \t\t  poplevel (kept_level_p (), 1, 0);\n \t\t  pop_momentary ();\n \t\t  expand_end_loop ();\n@@ -3184,13 +3131,12 @@ simple_stmt:\n \t\t/* Don't let the tree nodes for $7 be discarded\n \t\t   by clear_momentary during the parsing of the next stmt.  */\n \t\t{ push_momentary (); }\n-\t  already_scoped_stmt\n+\t  implicitly_scoped_stmt\n \t\t{ emit_line_note (input_filename, lineno);\n-\t\t  pop_implicit_try_blocks (NULL_TREE);\n-\t\t  expand_end_bindings (getdecls (), kept_level_p (), 1);\n \t\t  expand_loop_continue_here ();\n \t\t  if ($7) cplus_expand_expr_stmt ($7);\n \t\t  pop_momentary ();\n+\t\t  expand_end_bindings (getdecls (), kept_level_p (), 1);\n \t\t  poplevel (kept_level_p (), 1, 0);\n \t\t  pop_momentary ();\n \t\t  expand_end_loop ();\n@@ -3207,13 +3153,12 @@ simple_stmt:\n \t\t   by clear_momentary during the parsing of the next stmt.  */\n \t\t{ push_momentary ();\n \t\t  $<itype>8 = lineno; }\n-\t  already_scoped_stmt\n+\t  implicitly_scoped_stmt\n \t\t{ emit_line_note (input_filename, (int) $<itype>8);\n-\t\t  pop_implicit_try_blocks (NULL_TREE);\n-\t\t  expand_end_bindings (getdecls (), kept_level_p (), 1);\n \t\t  expand_loop_continue_here ();\n \t\t  if ($7) cplus_expand_expr_stmt ($7);\n \t\t  pop_momentary ();\n+\t\t  expand_end_bindings (getdecls (), kept_level_p (), 1);\n \t\t  poplevel (kept_level_p (), 1, 0);\n \t\t  pop_momentary ();\n \t\t  expand_end_loop ();\n@@ -3225,10 +3170,9 @@ simple_stmt:\n \t\t  /* Don't let the tree nodes for $4 be discarded by\n \t\t     clear_momentary during the parsing of the next stmt.  */\n \t\t  push_momentary (); }\n-\t  partially_scoped_stmt\n+\t  implicitly_scoped_stmt\n \t\t{ expand_end_case ($4);\n \t\t  pop_momentary ();\n-\t\t  pop_implicit_try_blocks (NULL_TREE);\n \t\t  expand_end_bindings (getdecls (), kept_level_p (), 1);\n \t\t  poplevel (kept_level_p (), 1, 0);\n \t\t  pop_momentary ();\n@@ -3422,7 +3366,7 @@ simple_stmt:\n \t\t}\n \t/* This is the case with clobbered registers as well.  */\n \t| asm_keyword maybe_type_qual '(' string ':' asm_operands ':'\n-  \t  asm_operands ':' asm_clobbers ')' ';'\n+\t  asm_operands ':' asm_clobbers ')' ';'\n \t\t{ if (TREE_CHAIN ($4)) $4 = combine_strings ($4);\n \t\t  emit_line_note (input_filename, lineno);\n \t\t  c_expand_asm_operands ($4, $6, $8, $10,\n@@ -3447,291 +3391,34 @@ simple_stmt:\n \t\t  finish_stmt (); }\n \t| ';'\n \t\t{ finish_stmt (); }\n-\n-\t/* Exception handling extensions.  */\n-\t| ANSI_THROW ';' { cplus_expand_throw (NULL_TREE); }\n-\t| ANSI_THROW expr ';' { cplus_expand_throw ($2); }\n-\t| THROW raise_identifier '(' nonnull_exprlist ')' ';'\n-\t\t{ cplus_expand_raise ($2, $4, NULL_TREE, 0);\n-\t\t  finish_stmt (); }\n-\t| THROW raise_identifier LEFT_RIGHT ';'\n-\t\t{ cplus_expand_raise ($2, NULL_TREE, NULL_TREE, 0);\n-\t\t  finish_stmt (); }\n-\t| RAISE raise_identifier '(' nonnull_exprlist ')' ';'\n-\t\t{ cplus_expand_raise ($2, $4, NULL_TREE, 0);\n-\t\t  finish_stmt (); }\n-\t| RAISE raise_identifier LEFT_RIGHT ';'\n-\t\t{ cplus_expand_raise ($2, NULL_TREE, NULL_TREE, 0);\n-\t\t  finish_stmt (); }\n-\t| RAISE identifier ';'\n-\t\t{ cplus_expand_reraise ($2);\n-\t\t  finish_stmt (); }\n-\t| try EXCEPT identifier '{'\n-\t\t{\n-\t\t  tree decl = cplus_expand_end_try ($1);\n-\t\t  $<ttype>2 = current_exception_type;\n-\t\t  $<ttype>4 = current_exception_decl;\n-\t\t  $<ttype>$ = current_exception_object;\n-\t\t  cplus_expand_start_except ($3, decl);\n-\t\t  pushlevel (0);\n-\t\t  clear_last_expr ();\n-\t\t  push_momentary ();\n-\t\t  expand_start_bindings (0);\n-\t\t}\n-\t  except_stmts '}'\n-\t\t{\n-\t\t  tree decls = getdecls ();\n-\t\t  /* If there is a default exception to handle,\n-\t\t     handle it here.  */\n-\t\t  if ($6)\n-\t\t    {\n-\t\t      tree decl = build_decl (CPLUS_CATCH_DECL, NULL_TREE, 0);\n-\t\t      tree block;\n-\n-\t\t      pushlevel (1);\n-\t\t      expand_start_bindings (0);\n-\t\t      expand_expr ($6, 0, 0, 0);\n-\t\t      expand_end_bindings (0, 1, 0);\n-\t\t      block = poplevel (1, 0, 0);\n-\n-\t\t      /* This is a catch block.  */\n-\t\t      TREE_LANG_FLAG_2 (block) = 1;\n-\t\t      BLOCK_VARS (block) = decl;\n-\t\t    }\n-\n-\t\t  expand_end_bindings (decls, decls != 0, 1);\n-\t\t  poplevel (decls != 0, 1, 0);\n-\t\t  pop_momentary ();\n-\t\t  current_exception_type = $<ttype>2;\n-\t\t  current_exception_decl = $<ttype>4;\n-\t\t  current_exception_object = $<ttype>5;\n-\t\t  cplus_expand_end_except ($6);\n-\t\t}\n-\t| try error\n-\t\t{\n-\t\t  cplus_expand_end_try ($1);\n-\t\t  /* These are the important actions of\n-\t\t     `cplus_expand_end_except' which we must emulate.  */\n-\t\t  if (expand_escape_except ())\n-\t\t    expand_end_except ();\n-\t\t  expand_end_bindings (0, 0, 1);\n-\t\t  poplevel (0, 0, 0);\n-\t\t}\n-\t| ansi_try ansi_dummy ansi_dummy\n-\t\t{\n-\t\t  tree decl = cplus_expand_end_try ($1);\n-\t\t  $<ttype>2 = current_exception_type;\n-\t\t  $<ttype>3 = current_exception_decl;\n-\t\t  $<ttype>$ = current_exception_object;\n-\t\t  cplus_expand_start_except (NULL, decl);\n-\t\t  pushlevel (0);\n-\t\t  clear_last_expr ();\n-\t\t  push_momentary ();\n-\t\t  expand_start_bindings (0);\n-\t\t}\n-\t  ansi_except_stmts\n-\t\t{\n-\t\t  tree decls = getdecls ();\n-\t\t  /* If there is a default exception to handle,\n-\t\t     handle it here.  */\n-\t\t  if ($5)\n-\t\t    {\n-\t\t      tree decl = build_decl (CPLUS_CATCH_DECL, NULL_TREE, 0);\n-\t\t      tree block;\n-\n-\t\t      pushlevel (1);\n-\t\t      expand_start_bindings (0);\n-\t\t      expand_expr ($5, 0, 0, 0);\n-\t\t      expand_end_bindings (0, 1, 0);\n-\t\t      block = poplevel (1, 0, 0);\n-\n-\t\t      /* This is a catch block.  */\n-\t\t      TREE_LANG_FLAG_2 (block) = 1;\n-\t\t      BLOCK_VARS (block) = decl;\n-\t\t    }\n-\n-\t\t  expand_end_bindings (decls, decls != 0, 1);\n-\t\t  poplevel (decls != 0, 1, 0);\n-\t\t  pop_momentary ();\n-\t\t  current_exception_type = $<ttype>2;\n-\t\t  current_exception_decl = $<ttype>3;\n-\t\t  current_exception_object = $<ttype>4;\n-\t\t  cplus_expand_end_except ($5);\n-\t\t}\n-\t| try RERAISE raise_identifiers /* ';' checked for at bottom.  */\n-\t\t{ tree name = get_identifier (\"(compiler error)\");\n-\t\t  tree orig_ex_type = current_exception_type;\n-\t\t  tree orig_ex_decl = current_exception_decl;\n-\t\t  tree orig_ex_obj = current_exception_object;\n-\t\t  tree decl = cplus_expand_end_try ($1), decls;\n-\n-\t\t  /* Start hidden EXCEPT.  */\n-\t\t  cplus_expand_start_except (name, decl);\n-\t\t  pushlevel (0);\n-\t\t  clear_last_expr ();\n-\t\t  push_momentary ();\n-\t\t  expand_start_bindings (0);\n-\n-\t\t  /* This sets up the reraise.  */\n-\t\t  cplus_expand_reraise ($3);\n-\n-\t\t  decls = getdecls ();\n-\t\t  expand_end_bindings (decls, decls != 0, 1);\n-\t\t  poplevel (decls != 0, 1, 0);\n-\t\t  pop_momentary ();\n-\t\t  current_exception_type = orig_ex_type;\n-\t\t  current_exception_decl = orig_ex_decl;\n-\t\t  current_exception_object = orig_ex_obj;\n-\t\t  /* This will reraise for us.  */\n-\t\t  cplus_expand_end_except (error_mark_node);\n-\t\t  if (yychar == YYEMPTY)\n-\t\t    yychar = YYLEX;\n-\t\t  if (yychar != ';')\n-\t\t    error (\"missing ';' after reraise statement\");\n-\t\t}\n-\t| try  %prec EMPTY\n-\t\t{ yyerror (\"`except' missing after `try' statement\");\n-\t\t  /* Terminate the binding contour started by special\n-\t\t     code in `.pushlevel'.  Automagically pops off\n-\t\t     the conditional we started for `try' stmt.  */\n-\t\t  cplus_expand_end_try ($1);\n-\t\t  expand_end_bindings (0, 0, 1);\n-\t\t  poplevel (0, 0, 0);\n-\t\t  pop_momentary ();\n-\t\t  YYERROR; }\n-\t;\n-\n-try:\t  try_head '}'\n-\t\t/* An empty try block is degenerate, but it's better to\n-\t\t   do extra work here than to do all the special-case work\n-\t\t   everywhere else.  */\n-\t\t{\n-\t\t  $$ = 1;\n-\t\t  pop_implicit_try_blocks (NULL_TREE);\n-\t\t}\n-\t| try_head stmts '}'\n-\t\t{\n-\t\t  $$ = 1;\n-\t\t  pop_implicit_try_blocks (NULL_TREE);\n-\t\t}\n-\t| try_head error '}'\n-\t\t{\n-\t\t  $$ = 0;\n-\t\t  pop_implicit_try_blocks (NULL_TREE);\n-\t\t}\n+\t| try_block\n \t;\n \n-label_colon:\n-\t  IDENTIFIER ':'\n-\t\t{ tree label;\n-\t\tdo_label:\n-\t\t  label = define_label (input_filename, lineno, $1);\n-\t\t  if (label)\n-\t\t    expand_label (label);\n-\t\t}\n-\t| PTYPENAME ':'\n-\t\t{ goto do_label; }\n+try_block:\n+\t  TRY '{' .pushlevel\n+\t\t{ expand_start_try_stmts (); }\n+\t  ansi_try_stmts\n+\t\t{ expand_end_try_stmts ();\n+\t\t  expand_start_all_catch (); }\n+\t  handler_seq\n+\t\t{ expand_end_all_catch (); }\n \t;\n \n-try_head: TRY '{' { cplus_expand_start_try (0); } .pushlevel\n-\n-ansi_try:\t  ansi_try_head '}'\n+ansi_try_stmts:\n+\t  '}'\n \t\t/* An empty try block is degenerate, but it's better to\n \t\t   do extra work here than to do all the special-case work\n \t\t   everywhere else.  */\n-\t\t{\n-\t\t  $$ = 1;\n-\t\t  pop_implicit_try_blocks (NULL_TREE);\n-\t\t}\n-\t| ansi_try_head stmts '}'\n-\t\t{\n-\t\t  $$ = 1;\n-\t\t  pop_implicit_try_blocks (NULL_TREE);\n-\t\t}\n-\t| ansi_try_head error '}'\n-\t\t{\n-\t\t  $$ = 0;\n-\t\t  pop_implicit_try_blocks (NULL_TREE);\n-\t\t}\n-\t;\n-\n-ansi_dummy: ; /* Temporary place-holder. */\n-ansi_try_head: ANSI_TRY '{' { cplus_expand_start_try (0); } .pushlevel\n-\n-except_stmts:\n-\t  /* empty */\n-\t\t{ $$ = NULL_TREE; }\n-\t| except_stmts raise_identifier\n-\t\t{\n-\t\t  tree type = lookup_exception_type (current_class_type, current_class_name, $2);\n-\t\t  if (type == NULL_TREE)\n-\t\t    {\n-\t\t      error (\"`%s' is not an exception type\",\n-\t\t\t     IDENTIFIER_POINTER (TREE_VALUE ($2)));\n-\t\t      current_exception_type = NULL_TREE;\n-\t\t      TREE_TYPE (current_exception_object) = error_mark_node;\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      current_exception_type = type;\n-\t\t      /* In-place union.  */\n-\t\t      TREE_TYPE (current_exception_object) = type;\n-\t\t    }\n-\t\t  $2 = cplus_expand_start_catch ($2);\n-\t\t  pushlevel (1);\n-\t\t  expand_start_bindings (0);\n-\t\t}\n-\t  compstmt\n-\t\t{\n-\t\t  expand_end_bindings (0, 1, 0);\n-\t\t  $4 = poplevel (1, 0, 0);\n-\n-\t\t  cplus_expand_end_catch (0);\n-\n-\t\t  /* Mark this as a catch block.  */\n-\t\t  TREE_LANG_FLAG_2 ($4) = 1;\n-\t\t  if ($2 != error_mark_node)\n-\t\t    {\n-\t\t      tree decl = build_decl (CPLUS_CATCH_DECL, DECL_NAME ($2), 0);\n-\t\t      DECL_RTL (decl) = DECL_RTL ($2);\n-\t\t      TREE_CHAIN (decl) = BLOCK_VARS ($4);\n-\t\t      BLOCK_VARS ($4) = decl;\n-\t\t    }\n+\t\t{ expand_end_bindings (0,1,1);\n+\t\t  poplevel (2,0,0);\n \t\t}\n-\t| except_stmts DEFAULT\n-\t\t{\n-\t\t  if ($1)\n-\t\t    error (\"duplicate default in exception handler\");\n-\t\t  current_exception_type = NULL_TREE;\n-\t\t  /* Takes it right out of scope.  */\n-\t\t  TREE_TYPE (current_exception_object) = error_mark_node;\n-\n-\t\t  if (! expand_catch_default ())\n-\t\t    compiler_error (\"default catch botch\");\n-\n-\t\t  /* The default exception is handled as the\n-\t\t     last in the chain of exceptions handled.  */\n-\t\t  do_pending_stack_adjust ();\n-\t\t  $1 = make_node (RTL_EXPR);\n-\t\t  TREE_TYPE ($1) = void_type_node;\n-\t\t  start_sequence_for_rtl_expr ($1);\n+\t| stmts '}'\n+\t\t{ expand_end_bindings (0,1,1);\n+\t\t  poplevel (2,0,0);\n \t\t}\n-\t  compstmt\n-\t\t{\n-\t\t  extern struct rtx_def *get_insns ();\n-\t\t  do_pending_stack_adjust ();\n-\t\t  if (! expand_catch (NULL_TREE))\n-\t\t    compiler_error (\"except nesting botch\");\n-\t\t  if (! expand_end_catch ())\n-\t\t    compiler_error (\"except nesting botch\");\n-\t\t  RTL_EXPR_SEQUENCE ($1) = get_insns ();\n-\t\t  if ($4)\n-\t\t    {\n-\t\t      /* Mark this block as the default catch block.  */\n-\t\t      TREE_LANG_FLAG_1 ($4) = 1;\n-\t\t      TREE_LANG_FLAG_2 ($4) = 1;\n-\t\t    }\n-\t\t  end_sequence ();\n+\t| error '}'\n+\t\t{ expand_end_bindings (0,1,1);\n+\t\t  poplevel (2,0,0);\n \t\t}\n \t;\n \n@@ -3740,47 +3427,31 @@ optional_identifier:\n \t\t{ $$ = NULL_TREE; }\n \t| identifier ;\n \n-ansi_except_stmts:\n+handler_seq:\n \t  /* empty */\n-\t\t{ $$ = NULL_TREE; }\n-\t| ansi_except_stmts CATCH '(' type_id optional_identifier ')'\n-\t\t{\n-\t\t  tree type = groktypename ($4);\n-\t\t  if (IS_SIGNATURE (type))\n-\t\t    {\n-\t\t      error (\"exception cannot be of signature type\");\n-\t\t      type = error_mark_node;\n-\t\t    }\n-\t\t  current_exception_type = type;\n-\t\t  /* In-place union.  */\n-\t\t  if ($5)\n-\t\t    {\n-\t\t      tree tmp;\n-\t\t      tmp = pushdecl (build_decl (VAR_DECL, $5, type));\n-\t\t      current_exception_object =\n-\t\t          build1 (INDIRECT_REF, type, tmp);\n-\t\t     }\n-\t\t  $4 = ansi_expand_start_catch(type);\n-\t\t  pushlevel (1);\n-\t\t  expand_start_bindings (0);\n-\t\t}\n-\t  compstmt\n-\t\t{\n-\t\t  expand_end_bindings (0, 1, 0);\n-\t\t  $8 = poplevel (1, 0, 0);\n+\t| handler_seq CATCH\n+\t\t{ emit_line_note (input_filename, lineno); }\n+\t  handler_args compstmt\n+\t\t{ expand_end_catch_block (); }\n+\t;\n \n-\t\t  cplus_expand_end_catch (0);\n+handler_args:\n+\t  '(' ELLIPSIS ')'\n+\t\t{ expand_start_catch_block (NULL_TREE, NULL_TREE); }\n+\t| '(' type_id optional_identifier ')'\n+\t\t{ expand_start_catch_block ($2, $3); }\n+\t;\n \n-\t\t  /* Mark this as a catch block.  */\n-\t\t  TREE_LANG_FLAG_2 ($8) = 1;\n-\t\t  if ($4 != error_mark_node)\n-\t\t    {\n-\t\t      tree decl = build_decl (CPLUS_CATCH_DECL, DECL_NAME ($4), 0);\n-\t\t      DECL_RTL (decl) = DECL_RTL ($4);\n-\t\t      TREE_CHAIN (decl) = BLOCK_VARS ($8);\n-\t\t      BLOCK_VARS ($8) = decl;\n-\t\t    }\n+label_colon:\n+\t  IDENTIFIER ':'\n+\t\t{ tree label;\n+\t\tdo_label:\n+\t\t  label = define_label (input_filename, lineno, $1);\n+\t\t  if (label)\n+\t\t    expand_label (label);\n \t\t}\n+\t| PTYPENAME ':'\n+\t\t{ goto do_label; }\n \t;\n \n forhead.1:\n@@ -3869,7 +3540,7 @@ parmlist:  /* empty */\n    as it is ambiguous and must be disambiguated elsewhere.  */\n complex_parmlist:\n \t  parms\n-  \t\t{\n+\t\t{\n \t\t  $$ = chainon ($$, void_list_node);\n \t\t  TREE_PARMLIST ($$) = 1;\n \t\t}\n@@ -4029,16 +3700,14 @@ bad_parm:\n maybe_raises:\n \t  %prec EMPTY /* empty */\n \t\t{ $$ = NULL_TREE; }\n-\t| RAISES raise_identifiers  %prec EMPTY\n-\t\t{ $$ = $2; }\n-\t| ANSI_THROW '(' ansi_raise_identifiers  ')' %prec EMPTY\n+\t| THROW '(' ansi_raise_identifiers  ')' %prec EMPTY\n \t\t{ $$ = $3; }\n \t;\n \n raise_identifier:\n-\t  ALL\n-\t\t{ $$ = void_list_node; }\n-\t| IDENTIFIER\n+/*\t  ALL\n+\t\t{ $$ = void_list_node; } */\n+\t  IDENTIFIER\n \t\t{ $$ = build_decl_list (NULL_TREE, $$); }\n \t| TYPENAME\n \t\t{ $$ = build_decl_list (NULL_TREE, $$); }\n@@ -4057,7 +3726,7 @@ raise_identifiers:\n \t  raise_identifier\n \t| raise_identifiers ',' raise_identifier\n \t\t{\n-  \t\t  TREE_CHAIN ($3) = $$;\n+\t\t  TREE_CHAIN ($3) = $$;\n \t\t  $$ = $3;\n \t\t}\n \t;\n@@ -4066,7 +3735,7 @@ ansi_raise_identifiers:\n \t  ansi_raise_identifier\n \t| ansi_raise_identifiers ',' ansi_raise_identifier\n \t\t{\n-  \t\t  TREE_CHAIN ($3) = $$;\n+\t\t  TREE_CHAIN ($3) = $$;\n \t\t  $$ = $3;\n \t\t}\n \t;"}, {"sha": "edb0b78a4916615d40bd724160667493c8817909", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d2733caec5ebdd4664d7645375262b1e097c418/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d2733caec5ebdd4664d7645375262b1e097c418/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=8d2733caec5ebdd4664d7645375262b1e097c418", "patch": "@@ -1494,44 +1494,6 @@ build_exception_variant (ctype, type, raises)\n   int constp = TYPE_READONLY (type);\n   int volatilep = TYPE_VOLATILE (type);\n \n-  if (raises && TREE_CHAIN (raises))\n-    {\n-      for (i = 0, t = raises; t; t = TREE_CHAIN (t), i++)\n-\ta[i] = t;\n-      /* NULL terminator for list.  */\n-      a[i] = NULL_TREE;\n-      qsort (a, i, sizeof (tree), id_cmp);\n-      while (i--)\n-\tTREE_CHAIN (a[i]) = a[i+1];\n-      raises = a[0];\n-    }\n-  else if (raises)\n-    /* do nothing.  */;\n-  else\n-    return build_type_variant (v, constp, volatilep);\n-\n-  if (ctype)\n-    {\n-      cname = TYPE_NAME (ctype);\n-      if (TREE_CODE (cname) == TYPE_DECL)\n-\tcname = DECL_NAME (cname);\n-    }\n-  else\n-    cname = NULL_TREE;\n-\n-  for (t = raises; t; t = TREE_CHAIN (t))\n-    {\n-      /* See that all the exceptions we are thinking about\n-\t raising have been declared.  */\n-      tree this_cname = lookup_exception_cname (ctype, cname, t);\n-      tree decl = lookup_exception_object (this_cname, TREE_VALUE (t), 1);\n-\n-      if (decl == NULL_TREE)\n-\tdecl = lookup_exception_object (this_cname, TREE_VALUE (t), 0);\n-      /* Place canonical exception decl into TREE_TYPE of RAISES list.  */\n-      TREE_TYPE (t) = decl;\n-    }\n-\n   for (v = TYPE_NEXT_VARIANT (v); v; v = TYPE_NEXT_VARIANT (v))\n     {\n       if (TYPE_READONLY (v) != constp"}, {"sha": "03ca722b5e2e17f1f0b428e4be7413962908f45b", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d2733caec5ebdd4664d7645375262b1e097c418/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d2733caec5ebdd4664d7645375262b1e097c418/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=8d2733caec5ebdd4664d7645375262b1e097c418", "patch": "@@ -2280,6 +2280,7 @@ build_function_call_real (function, params, require_complete, flags)\n \t     function, coerced_params, NULL_TREE);\n \n     TREE_SIDE_EFFECTS (result) = 1;\n+    /* Remove this sometime. */\n     TREE_RAISES (result) |= !! TYPE_RAISES_EXCEPTIONS (fntype);\n     if (! require_complete)\n       return result;"}]}