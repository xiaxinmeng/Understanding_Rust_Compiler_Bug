{"sha": "6dfc55927f4717baa28c751fedb85834733f7b0d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmRmYzU1OTI3ZjQ3MTdiYWEyOGM3NTFmZWRiODU4MzQ3MzNmN2IwZA==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2010-10-11T10:10:01Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-10-11T10:10:01Z"}, "message": "exp_ch6.adb: Code clean up.\n\n2010-10-11  Robert Dewar  <dewar@adacore.com>\n\n\t* exp_ch6.adb: Code clean up.\n\t* exp_util.adb: Minor reformatting.\n\nFrom-SVN: r165294", "tree": {"sha": "2930ab4c0d43a78f782281dd4e092f630a6ad5f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2930ab4c0d43a78f782281dd4e092f630a6ad5f0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6dfc55927f4717baa28c751fedb85834733f7b0d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6dfc55927f4717baa28c751fedb85834733f7b0d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6dfc55927f4717baa28c751fedb85834733f7b0d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6dfc55927f4717baa28c751fedb85834733f7b0d/comments", "author": null, "committer": null, "parents": [{"sha": "44bf8eb058405766cf8e05a740c63644244e218b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44bf8eb058405766cf8e05a740c63644244e218b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/44bf8eb058405766cf8e05a740c63644244e218b"}], "stats": {"total": 271, "additions": 158, "deletions": 113}, "files": [{"sha": "01e062514fc83e8138e9d5bf87ce92b04d1e64b4", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dfc55927f4717baa28c751fedb85834733f7b0d/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dfc55927f4717baa28c751fedb85834733f7b0d/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=6dfc55927f4717baa28c751fedb85834733f7b0d", "patch": "@@ -1,3 +1,8 @@\n+2010-10-11  Robert Dewar  <dewar@adacore.com>\n+\n+\t* exp_ch6.adb: Code clean up.\n+\t* exp_util.adb: Minor reformatting.\n+\n 2010-10-11  Arnaud Charlet  <charlet@adacore.com>\n \n \t* sem_ch3.adb, exp_ch6.adb"}, {"sha": "2ffa9f7906c4b63da4ec5a7ef3f5bde40a26d5a5", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 152, "deletions": 112, "changes": 264, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dfc55927f4717baa28c751fedb85834733f7b0d/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dfc55927f4717baa28c751fedb85834733f7b0d/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=6dfc55927f4717baa28c751fedb85834733f7b0d", "patch": "@@ -134,9 +134,10 @@ package body Exp_Ch6 is\n    --  expression to pass for the master. In most cases, this is the current\n    --  master (_master). The two exceptions are: If the function call is the\n    --  initialization expression for an allocator, we pass the master of the\n-   --  access type. If the function call is the initialization expression for\n-   --  a return object, we pass along the master passed in by the caller. The\n-   --  activation chain to pass is always the local one.\n+   --  access type. If the function call is the initialization expression for a\n+   --  return object, we pass along the master passed in by the caller. The\n+   --  activation chain to pass is always the local one. Note: Master_Actual\n+   --  can be Empty, but only if there are no tasks\n \n    procedure Check_Overriding_Operation (Subp : Entity_Id);\n    --  Subp is a dispatching operation. Check whether it may override an\n@@ -473,10 +474,10 @@ package body Exp_Ch6 is\n      (Function_Call : Node_Id;\n       Function_Id   : Entity_Id;\n       Master_Actual : Node_Id)\n-      --  Note: Master_Actual can be Empty, but only if there are no tasks\n    is\n       Loc    : constant Source_Ptr := Sloc (Function_Call);\n       Actual : Node_Id := Master_Actual;\n+\n    begin\n       --  No such extra parameters are needed if there are no tasks\n \n@@ -1755,6 +1756,7 @@ package body Exp_Ch6 is\n \n    procedure Expand_Call (N : Node_Id) is\n       Loc           : constant Source_Ptr := Sloc (N);\n+      Call_Node     : Node_Id := N;\n       Extra_Actuals : List_Id := No_List;\n       Prev          : Node_Id := Empty;\n \n@@ -1791,13 +1793,14 @@ package body Exp_Ch6 is\n          if No (Prev) or else\n             Nkind (Parent (Prev)) /= N_Parameter_Association\n          then\n-            Set_Next_Named_Actual (Insert_Param, First_Named_Actual (N));\n-            Set_First_Named_Actual (N, Actual_Expr);\n+            Set_Next_Named_Actual\n+              (Insert_Param, First_Named_Actual (Call_Node));\n+            Set_First_Named_Actual (Call_Node, Actual_Expr);\n \n             if No (Prev) then\n-               if No (Parameter_Associations (N)) then\n-                  Set_Parameter_Associations (N, New_List);\n-                  Append (Insert_Param, Parameter_Associations (N));\n+               if No (Parameter_Associations (Call_Node)) then\n+                  Set_Parameter_Associations (Call_Node, New_List);\n+                  Append (Insert_Param, Parameter_Associations (Call_Node));\n                end if;\n             else\n                Insert_After (Prev, Insert_Param);\n@@ -1809,7 +1812,7 @@ package body Exp_Ch6 is\n             Set_Next_Named_Actual\n               (Insert_Param, Next_Named_Actual (Parent (Prev)));\n             Set_Next_Named_Actual (Parent (Prev), Actual_Expr);\n-            Append (Insert_Param, Parameter_Associations (N));\n+            Append (Insert_Param, Parameter_Associations (Call_Node));\n          end if;\n \n          Prev := Actual_Expr;\n@@ -1825,7 +1828,7 @@ package body Exp_Ch6 is\n       begin\n          if Extra_Actuals = No_List then\n             Extra_Actuals := New_List;\n-            Set_Parent (Extra_Actuals, N);\n+            Set_Parent (Extra_Actuals, Call_Node);\n          end if;\n \n          Append_To (Extra_Actuals,\n@@ -1835,7 +1838,7 @@ package body Exp_Ch6 is\n \n          Analyze_And_Resolve (Expr, Etype (EF));\n \n-         if Nkind (N) = N_Function_Call then\n+         if Nkind (Call_Node) = N_Function_Call then\n             Set_Is_Accessibility_Actual (Parent (Expr));\n          end if;\n       end Add_Extra_Actual;\n@@ -1941,7 +1944,7 @@ package body Exp_Ch6 is\n \n       --  Local variables\n \n-      Remote        : constant Boolean := Is_Remote_Call (N);\n+      Remote        : constant Boolean := Is_Remote_Call (Call_Node);\n       Actual        : Node_Id;\n       Formal        : Entity_Id;\n       Orig_Subp     : Entity_Id := Empty;\n@@ -1964,35 +1967,37 @@ package body Exp_Ch6 is\n    begin\n       --  Ignore if previous error\n \n-      if Nkind (N) in N_Has_Etype and then Etype (N) = Any_Type then\n+      if Nkind (Call_Node) in N_Has_Etype\n+        and then Etype (Call_Node) = Any_Type\n+      then\n          return;\n       end if;\n \n       --  Call using access to subprogram with explicit dereference\n \n-      if Nkind (Name (N)) = N_Explicit_Dereference then\n-         Subp        := Etype (Name (N));\n+      if Nkind (Name (Call_Node)) = N_Explicit_Dereference then\n+         Subp        := Etype (Name (Call_Node));\n          Parent_Subp := Empty;\n \n       --  Case of call to simple entry, where the Name is a selected component\n       --  whose prefix is the task, and whose selector name is the entry name\n \n-      elsif Nkind (Name (N)) = N_Selected_Component then\n-         Subp        := Entity (Selector_Name (Name (N)));\n+      elsif Nkind (Name (Call_Node)) = N_Selected_Component then\n+         Subp        := Entity (Selector_Name (Name (Call_Node)));\n          Parent_Subp := Empty;\n \n       --  Case of call to member of entry family, where Name is an indexed\n       --  component, with the prefix being a selected component giving the\n       --  task and entry family name, and the index being the entry index.\n \n-      elsif Nkind (Name (N)) = N_Indexed_Component then\n-         Subp        := Entity (Selector_Name (Prefix (Name (N))));\n+      elsif Nkind (Name (Call_Node)) = N_Indexed_Component then\n+         Subp        := Entity (Selector_Name (Prefix (Name (Call_Node))));\n          Parent_Subp := Empty;\n \n       --  Normal case\n \n       else\n-         Subp        := Entity (Name (N));\n+         Subp        := Entity (Name (Call_Node));\n          Parent_Subp := Alias (Subp);\n \n          --  Replace call to Raise_Exception by call to Raise_Exception_Always\n@@ -2007,8 +2012,8 @@ package body Exp_Ch6 is\n            and then RTE_Available (RE_Raise_Exception_Always)\n          then\n             declare\n-               FA : constant Node_Id := Original_Node (First_Actual (N));\n-\n+               FA : constant Node_Id := Original_Node\n+                                          (First_Actual (Call_Node));\n             begin\n                --  The case we catch is where the first argument is obtained\n                --  using the Identity attribute (which must always be\n@@ -2018,7 +2023,7 @@ package body Exp_Ch6 is\n                  and then Attribute_Name (FA) = Name_Identity\n                then\n                   Subp := RTE (RE_Raise_Exception_Always);\n-                  Set_Name (N, New_Occurrence_Of (Subp, Loc));\n+                  Set_Name (Call_Node, New_Occurrence_Of (Subp, Loc));\n                end if;\n             end;\n          end if;\n@@ -2034,13 +2039,13 @@ package body Exp_Ch6 is\n       --  is a renaming of an entry and rewrite it as an entry call.\n \n       if Ada_Version >= Ada_2005\n-        and then Nkind (N) = N_Procedure_Call_Statement\n+        and then Nkind (Call_Node) = N_Procedure_Call_Statement\n         and then\n-           ((Nkind (Parent (N)) = N_Triggering_Alternative\n-               and then Triggering_Statement (Parent (N)) = N)\n+           ((Nkind (Parent (Call_Node)) = N_Triggering_Alternative\n+               and then Triggering_Statement (Parent (Call_Node)) = Call_Node)\n           or else\n-            (Nkind (Parent (N)) = N_Entry_Call_Alternative\n-               and then Entry_Call_Statement (Parent (N)) = N))\n+            (Nkind (Parent (Call_Node)) = N_Entry_Call_Alternative\n+               and then Entry_Call_Statement (Parent (Call_Node)) = Call_Node))\n       then\n          declare\n             Ren_Decl : Node_Id;\n@@ -2057,12 +2062,13 @@ package body Exp_Ch6 is\n                Ren_Decl := Original_Node (Parent (Parent (Ren_Root)));\n \n                if Nkind (Ren_Decl) = N_Subprogram_Renaming_Declaration then\n-                  Rewrite (N,\n+                  Rewrite (Call_Node,\n                     Make_Entry_Call_Statement (Loc,\n                       Name =>\n                         New_Copy_Tree (Name (Ren_Decl)),\n                       Parameter_Associations =>\n-                        New_Copy_List_Tree (Parameter_Associations (N))));\n+                        New_Copy_List_Tree\n+                          (Parameter_Associations (Call_Node))));\n \n                   return;\n                end if;\n@@ -2080,7 +2086,7 @@ package body Exp_Ch6 is\n       --  (Though it seems that this would be better done in Expand_Actuals???)\n \n       Formal      := First_Formal (Subp);\n-      Actual      := First_Actual (N);\n+      Actual      := First_Actual (Call_Node);\n       Param_Count := 1;\n       while Present (Formal) loop\n \n@@ -2469,7 +2475,7 @@ package body Exp_Ch6 is\n          --  checking mode, all indexed components are checked with a call\n          --  directly from Expand_N_Indexed_Component.\n \n-         if Comes_From_Source (N)\n+         if Comes_From_Source (Call_Node)\n            and then Ekind (Formal) /= E_In_Parameter\n            and then Validity_Checks_On\n            and then Validity_Check_Default\n@@ -2568,50 +2574,53 @@ package body Exp_Ch6 is\n       --  assignment might be transformed to a declaration for an unconstrained\n       --  value if the expression is classwide.\n \n-      if Nkind (N) = N_Function_Call\n-        and then Is_Tag_Indeterminate (N)\n-        and then Is_Entity_Name (Name (N))\n+      if Nkind (Call_Node) = N_Function_Call\n+        and then Is_Tag_Indeterminate (Call_Node)\n+        and then Is_Entity_Name (Name (Call_Node))\n       then\n          declare\n             Ass : Node_Id := Empty;\n \n          begin\n-            if Nkind (Parent (N)) = N_Assignment_Statement then\n-               Ass := Parent (N);\n+            if Nkind (Parent (Call_Node)) = N_Assignment_Statement then\n+               Ass := Parent (Call_Node);\n \n-            elsif Nkind (Parent (N)) = N_Qualified_Expression\n-              and then Nkind (Parent (Parent (N))) = N_Assignment_Statement\n+            elsif Nkind (Parent (Call_Node)) = N_Qualified_Expression\n+              and then Nkind (Parent (Parent (Call_Node)))\n+                         = N_Assignment_Statement\n             then\n-               Ass := Parent (Parent (N));\n+               Ass := Parent (Parent (Call_Node));\n \n-            elsif Nkind (Parent (N)) = N_Explicit_Dereference\n-              and then Nkind (Parent (Parent (N))) = N_Assignment_Statement\n+            elsif Nkind (Parent (Call_Node)) = N_Explicit_Dereference\n+              and then Nkind (Parent (Parent (Call_Node)))\n+                         = N_Assignment_Statement\n             then\n-               Ass := Parent (Parent (N));\n+               Ass := Parent (Parent (Call_Node));\n             end if;\n \n             if Present (Ass)\n               and then Is_Class_Wide_Type (Etype (Name (Ass)))\n             then\n-               if Is_Access_Type (Etype (N)) then\n-                  if Designated_Type (Etype (N)) /=\n+               if Is_Access_Type (Etype (Call_Node)) then\n+                  if Designated_Type (Etype (Call_Node)) /=\n                     Root_Type (Etype (Name (Ass)))\n                   then\n                      Error_Msg_NE\n                        (\"tag-indeterminate expression \"\n                          & \" must have designated type& (RM 5.2 (6))\",\n-                           N, Root_Type (Etype (Name (Ass))));\n+                           Call_Node, Root_Type (Etype (Name (Ass))));\n                   else\n-                     Propagate_Tag (Name (Ass), N);\n+                     Propagate_Tag (Name (Ass), Call_Node);\n                   end if;\n \n-               elsif Etype (N) /= Root_Type (Etype (Name (Ass))) then\n+               elsif Etype (Call_Node) /= Root_Type (Etype (Name (Ass))) then\n                   Error_Msg_NE\n                     (\"tag-indeterminate expression must have type&\"\n-                     & \"(RM 5.2 (6))\", N, Root_Type (Etype (Name (Ass))));\n+                     & \"(RM 5.2 (6))\",\n+                     Call_Node, Root_Type (Etype (Name (Ass))));\n \n                else\n-                  Propagate_Tag (Name (Ass), N);\n+                  Propagate_Tag (Name (Ass), Call_Node);\n                end if;\n \n                --  The call will be rewritten as a dispatching call, and\n@@ -2625,10 +2634,10 @@ package body Exp_Ch6 is\n       --  Ada 2005 (AI-251): If some formal is a class-wide interface, expand\n       --  it to point to the correct secondary virtual table\n \n-      if Nkind_In (N, N_Function_Call, N_Procedure_Call_Statement)\n+      if Nkind_In (Call_Node, N_Function_Call, N_Procedure_Call_Statement)\n         and then CW_Interface_Formals_Present\n       then\n-         Expand_Interface_Actuals (N);\n+         Expand_Interface_Actuals (Call_Node);\n       end if;\n \n       --  Deals with Dispatch_Call if we still have a call, before expanding\n@@ -2639,36 +2648,58 @@ package body Exp_Ch6 is\n       --  back-ends directly handle the generation of dispatching calls and\n       --  would have to undo any expansion to an indirect call.\n \n-      if Nkind_In (N, N_Function_Call, N_Procedure_Call_Statement)\n-        and then Present (Controlling_Argument (N))\n+      if Nkind_In (Call_Node, N_Function_Call, N_Procedure_Call_Statement)\n+        and then Present (Controlling_Argument (Call_Node))\n       then\n-         if Tagged_Type_Expansion then\n-            Expand_Dispatching_Call (N);\n+         declare\n+            Typ        : constant Entity_Id := Find_Dispatching_Type (Subp);\n+            Eq_Prim_Op : Entity_Id := Empty;\n \n-            --  The following return is worrisome. Is it really OK to skip all\n-            --  remaining processing in this procedure ???\n+         begin\n+            if not Is_Limited_Type (Typ) then\n+               Eq_Prim_Op := Find_Prim_Op (Typ, Name_Op_Eq);\n+            end if;\n \n-            return;\n+            if Tagged_Type_Expansion then\n+               Expand_Dispatching_Call (Call_Node);\n \n-         else\n-            Apply_Tag_Checks (N);\n+               --  The following return is worrisome. Is it really OK to skip\n+               --  all remaining processing in this procedure ???\n \n-            --  Expansion of a dispatching call results in an indirect call,\n-            --  which in turn causes current values to be killed (see\n-            --  Resolve_Call), so on VM targets we do the call here to ensure\n-            --  consistent warnings between VM and non-VM targets.\n+               return;\n \n-            Kill_Current_Values;\n-         end if;\n+            --  VM targets\n+\n+            else\n+               Apply_Tag_Checks (Call_Node);\n+\n+               --  Expansion of a dispatching call results in an indirect call,\n+               --  which in turn causes current values to be killed (see\n+               --  Resolve_Call), so on VM targets we do the call here to\n+               --  ensure consistent warnings between VM and non-VM targets.\n+\n+               Kill_Current_Values;\n+            end if;\n+\n+            --  If this is a dispatching \"=\" then we must update the reference\n+            --  to the call node because we generated:\n+            --     x.tag = y.tag and then x = y\n+\n+            if Subp = Eq_Prim_Op\n+              and then Nkind (Call_Node) = N_Op_And\n+            then\n+               Call_Node := Right_Opnd (Call_Node);\n+            end if;\n+         end;\n       end if;\n \n       --  Similarly, expand calls to RCI subprograms on which pragma\n       --  All_Calls_Remote applies. The rewriting will be reanalyzed\n       --  later. Do this only when the call comes from source since we\n       --  do not want such a rewriting to occur in expanded code.\n \n-      if Is_All_Remote_Call (N) then\n-         Expand_All_Calls_Remote_Subprogram_Call (N);\n+      if Is_All_Remote_Call (Call_Node) then\n+         Expand_All_Calls_Remote_Subprogram_Call (Call_Node);\n \n       --  Similarly, do not add extra actuals for an entry call whose entity\n       --  is a protected procedure, or for an internal protected subprogram\n@@ -2693,15 +2724,15 @@ package body Exp_Ch6 is\n       --  At this point we have all the actuals, so this is the point at which\n       --  the various expansion activities for actuals is carried out.\n \n-      Expand_Actuals (N, Subp);\n+      Expand_Actuals (Call_Node, Subp);\n \n       --  If the subprogram is a renaming, or if it is inherited, replace it in\n       --  the call with the name of the actual subprogram being called. If this\n       --  is a dispatching call, the run-time decides what to call. The Alias\n       --  attribute does not apply to entries.\n \n-      if Nkind (N) /= N_Entry_Call_Statement\n-        and then No (Controlling_Argument (N))\n+      if Nkind (Call_Node) /= N_Entry_Call_Statement\n+        and then No (Controlling_Argument (Call_Node))\n         and then Present (Parent_Subp)\n       then\n          if Present (Inherited_From_Formal (Subp)) then\n@@ -2712,13 +2743,14 @@ package body Exp_Ch6 is\n \n          --  The below setting of Entity is suspect, see F109-018 discussion???\n \n-         Set_Entity (Name (N), Parent_Subp);\n+         Set_Entity (Name (Call_Node), Parent_Subp);\n \n          if Is_Abstract_Subprogram (Parent_Subp)\n            and then not In_Instance\n          then\n             Error_Msg_NE\n-              (\"cannot call abstract subprogram &!\", Name (N), Parent_Subp);\n+              (\"cannot call abstract subprogram &!\",\n+               Name (Call_Node), Parent_Subp);\n          end if;\n \n          --  Inspect all formals of derived subprogram Subp. Compare parameter\n@@ -2754,7 +2786,7 @@ package body Exp_Ch6 is\n                Parent_Typ : Entity_Id;\n \n             begin\n-               Actual := First_Actual (N);\n+               Actual := First_Actual (Call_Node);\n                Formal := First_Formal (Subp);\n                Parent_Formal := First_Formal (Parent_Subp);\n                while Present (Formal) loop\n@@ -2842,7 +2874,7 @@ package body Exp_Ch6 is\n       --  Check for violation of No_Abort_Statements\n \n       if Is_RTE (Subp, RE_Abort_Task) then\n-         Check_Restriction (No_Abort_Statements, N);\n+         Check_Restriction (No_Abort_Statements, Call_Node);\n \n       --  Check for violation of No_Dynamic_Attachment\n \n@@ -2855,17 +2887,17 @@ package body Exp_Ch6 is\n                   Is_RTE (Subp, RE_Detach_Handler)   or else\n                   Is_RTE (Subp, RE_Reference))\n       then\n-         Check_Restriction (No_Dynamic_Attachment, N);\n+         Check_Restriction (No_Dynamic_Attachment, Call_Node);\n       end if;\n \n       --  Deal with case where call is an explicit dereference\n \n-      if Nkind (Name (N)) = N_Explicit_Dereference then\n+      if Nkind (Name (Call_Node)) = N_Explicit_Dereference then\n \n       --  Handle case of access to protected subprogram type\n \n          if Is_Access_Protected_Subprogram_Type\n-              (Base_Type (Etype (Prefix (Name (N)))))\n+              (Base_Type (Etype (Prefix (Name (Call_Node)))))\n          then\n             --  If this is a call through an access to protected operation, the\n             --  prefix has the form (object'address, operation'access). Rewrite\n@@ -2877,7 +2909,7 @@ package body Exp_Ch6 is\n                Parm : List_Id;\n                Nam  : Node_Id;\n                Obj  : Node_Id;\n-               Ptr  : constant Node_Id := Prefix (Name (N));\n+               Ptr  : constant Node_Id := Prefix (Name (Call_Node));\n \n                T : constant Entity_Id :=\n                      Equivalent_Type (Base_Type (Etype (Ptr)));\n@@ -2902,8 +2934,8 @@ package body Exp_Ch6 is\n                  Make_Explicit_Dereference (Loc,\n                    Prefix => Nam);\n \n-               if Present (Parameter_Associations (N))  then\n-                  Parm := Parameter_Associations (N);\n+               if Present (Parameter_Associations (Call_Node))  then\n+                  Parm := Parameter_Associations (Call_Node);\n                else\n                   Parm := New_List;\n                end if;\n@@ -2922,15 +2954,15 @@ package body Exp_Ch6 is\n                       Parameter_Associations => Parm);\n                end if;\n \n-               Set_First_Named_Actual (Call, First_Named_Actual (N));\n+               Set_First_Named_Actual (Call, First_Named_Actual (Call_Node));\n                Set_Etype (Call, Etype (D_T));\n \n                --  We do not re-analyze the call to avoid infinite recursion.\n                --  We analyze separately the prefix and the object, and set\n                --  the checks on the prefix that would otherwise be emitted\n                --  when resolving a call.\n \n-               Rewrite (N, Call);\n+               Rewrite (Call_Node, Call);\n                Analyze (Nam);\n                Apply_Access_Check (Nam);\n                Analyze (Obj);\n@@ -2952,13 +2984,13 @@ package body Exp_Ch6 is\n       --  parent operation, will yield the wrong type.\n \n       if Is_Intrinsic_Subprogram (Subp) then\n-         Expand_Intrinsic_Call (N, Subp);\n+         Expand_Intrinsic_Call (Call_Node, Subp);\n \n-         if Nkind (N) = N_Unchecked_Type_Conversion\n+         if Nkind (Call_Node) = N_Unchecked_Type_Conversion\n            and then Parent_Subp /= Orig_Subp\n            and then Etype (Parent_Subp) /= Etype (Orig_Subp)\n          then\n-            Set_Etype (N, Etype (Orig_Subp));\n+            Set_Etype (Call_Node, Etype (Orig_Subp));\n          end if;\n \n          return;\n@@ -2980,13 +3012,13 @@ package body Exp_Ch6 is\n          --  that tree generated is the same in both cases, for Inspector use.\n \n          if Is_RTE (Subp, RE_To_Address) then\n-            Rewrite (N,\n+            Rewrite (Call_Node,\n               Unchecked_Convert_To\n-                (RTE (RE_Address), Relocate_Node (First_Actual (N))));\n+                (RTE (RE_Address), Relocate_Node (First_Actual (Call_Node))));\n             return;\n \n          elsif Is_Null_Procedure (Subp)  then\n-            Rewrite (N, Make_Null_Statement (Loc));\n+            Rewrite (Call_Node, Make_Null_Statement (Loc));\n             return;\n          end if;\n \n@@ -3060,8 +3092,8 @@ package body Exp_Ch6 is\n                else\n                   Bod := Body_To_Inline (Spec);\n \n-                  if (In_Extended_Main_Code_Unit (N)\n-                        or else In_Extended_Main_Code_Unit (Parent (N))\n+                  if (In_Extended_Main_Code_Unit (Call_Node)\n+                        or else In_Extended_Main_Code_Unit (Parent (Call_Node))\n                         or else Has_Pragma_Inline_Always (Subp))\n                     and then (not In_Same_Extended_Unit (Sloc (Bod), Loc)\n                                or else\n@@ -3081,15 +3113,15 @@ package body Exp_Ch6 is\n                   --  visible a private entity in the body of the main unit,\n                   --  that gigi will see before its sees its proper definition.\n \n-                  elsif not (In_Extended_Main_Code_Unit (N))\n+                  elsif not (In_Extended_Main_Code_Unit (Call_Node))\n                     and then In_Package_Body\n                   then\n                      Must_Inline := not In_Extended_Main_Source_Unit (Subp);\n                   end if;\n                end if;\n \n                if Must_Inline then\n-                  Expand_Inlined_Call (N, Subp, Orig_Subp);\n+                  Expand_Inlined_Call (Call_Node, Subp, Orig_Subp);\n \n                else\n                   --  Let the back end handle it\n@@ -3098,13 +3130,13 @@ package body Exp_Ch6 is\n \n                   if Front_End_Inlining\n                     and then Nkind (Spec) = N_Subprogram_Declaration\n-                    and then (In_Extended_Main_Code_Unit (N))\n+                    and then (In_Extended_Main_Code_Unit (Call_Node))\n                     and then No (Body_To_Inline (Spec))\n                     and then not Has_Completion (Subp)\n                     and then In_Same_Extended_Unit (Sloc (Spec), Loc)\n                   then\n                      Cannot_Inline\n-                      (\"cannot inline& (body not seen yet)?\", N, Subp);\n+                      (\"cannot inline& (body not seen yet)?\", Call_Node, Subp);\n                   end if;\n                end if;\n             end Inlined_Subprogram;\n@@ -3122,15 +3154,15 @@ package body Exp_Ch6 is\n \n       Scop := Scope (Subp);\n \n-      if Nkind (N) /= N_Entry_Call_Statement\n+      if Nkind (Call_Node) /= N_Entry_Call_Statement\n         and then Is_Protected_Type (Scop)\n         and then Ekind (Subp) /= E_Subprogram_Type\n         and then not Is_Eliminated (Subp)\n       then\n          --  If the call is an internal one, it is rewritten as a call to the\n          --  corresponding unprotected subprogram.\n \n-         Expand_Protected_Subprogram_Call (N, Subp, Scop);\n+         Expand_Protected_Subprogram_Call (Call_Node, Subp, Scop);\n       end if;\n \n       --  Functions returning controlled objects need special attention:\n@@ -3147,22 +3179,22 @@ package body Exp_Ch6 is\n                 or else\n                   not Is_Concurrent_Record_Type (Etype (First_Formal (Subp))))\n          then\n-            Expand_Ctrl_Function_Call (N);\n+            Expand_Ctrl_Function_Call (Call_Node);\n \n          --  Build-in-place function calls which appear in anonymous contexts\n          --  need a transient scope to ensure the proper finalization of the\n          --  intermediate result after its use.\n \n-         elsif Is_Build_In_Place_Function_Call (N)\n-           and then Nkind_In (Parent (N), N_Attribute_Reference,\n+         elsif Is_Build_In_Place_Function_Call (Call_Node)\n+           and then Nkind_In (Parent (Call_Node), N_Attribute_Reference,\n                                           N_Function_Call,\n                                           N_Indexed_Component,\n                                           N_Object_Renaming_Declaration,\n                                           N_Procedure_Call_Statement,\n                                           N_Selected_Component,\n                                           N_Slice)\n          then\n-            Establish_Transient_Scope (N, Sec_Stack => True);\n+            Establish_Transient_Scope (Call_Node, Sec_Stack => True);\n          end if;\n       end if;\n \n@@ -3187,7 +3219,7 @@ package body Exp_Ch6 is\n             --  the validity of the parameter before setting it.\n \n             Formal := First_Formal (Subp);\n-            Actual := First_Actual (N);\n+            Actual := First_Actual (Call_Node);\n             while Formal /= First_Optional_Parameter (Subp) loop\n                Last_Keep_Arg := Actual;\n                Next_Formal (Formal);\n@@ -3221,8 +3253,8 @@ package body Exp_Ch6 is\n             --  If no arguments, delete entire list, this is the easy case\n \n             if No (Last_Keep_Arg) then\n-               Set_Parameter_Associations (N, No_List);\n-               Set_First_Named_Actual (N, Empty);\n+               Set_Parameter_Associations (Call_Node, No_List);\n+               Set_First_Named_Actual (Call_Node, Empty);\n \n             --  Case where at the last retained argument is positional. This\n             --  is also an easy case, since the retained arguments are already\n@@ -3234,7 +3266,7 @@ package body Exp_Ch6 is\n                   Discard_Node (Remove_Next (Last_Keep_Arg));\n                end loop;\n \n-               Set_First_Named_Actual (N, Empty);\n+               Set_First_Named_Actual (Call_Node, Empty);\n \n             --  This is the annoying case where the last retained argument\n             --  is a named parameter. Since the original arguments are not\n@@ -3251,14 +3283,22 @@ package body Exp_Ch6 is\n                   --  list (they are still chained using First_Named_Actual\n                   --  and Next_Named_Actual, so we have not lost them!)\n \n-                  Temp := First (Parameter_Associations (N));\n+                  Temp := First (Parameter_Associations (Call_Node));\n \n                   --  Case of all parameters named, remove them all\n \n                   if Nkind (Temp) = N_Parameter_Association then\n-                     while Is_Non_Empty_List (Parameter_Associations (N)) loop\n-                        Temp := Remove_Head (Parameter_Associations (N));\n+                     --  Suppress warnings to avoid warning on possible\n+                     --  infinite loop (because Call_Node is not modified).\n+\n+                     pragma Warnings (Off);\n+                     while Is_Non_Empty_List\n+                             (Parameter_Associations (Call_Node))\n+                     loop\n+                        Temp :=\n+                          Remove_Head (Parameter_Associations (Call_Node));\n                      end loop;\n+                     pragma Warnings (On);\n \n                   --  Case of mixed positional/named, remove named parameters\n \n@@ -3278,11 +3318,11 @@ package body Exp_Ch6 is\n                   --  touched since we are only reordering them on the actual\n                   --  parameter association list.\n \n-                  Passoc := Parent (First_Named_Actual (N));\n+                  Passoc := Parent (First_Named_Actual (Call_Node));\n                   loop\n                      Temp := Relocate_Node (Passoc);\n                      Append_To\n-                       (Parameter_Associations (N), Temp);\n+                       (Parameter_Associations (Call_Node), Temp);\n                      exit when\n                        Last_Keep_Arg = Explicit_Actual_Parameter (Passoc);\n                      Passoc := Parent (Next_Named_Actual (Passoc));"}, {"sha": "a0c641bdce02dc8475e0fb0038af6fde5bd338de", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dfc55927f4717baa28c751fedb85834733f7b0d/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dfc55927f4717baa28c751fedb85834733f7b0d/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=6dfc55927f4717baa28c751fedb85834733f7b0d", "patch": "@@ -4842,7 +4842,7 @@ package body Exp_Util is\n       --  No action needed for renamings of class-wide expressions because for\n       --  class-wide types Remove_Side_Effects uses a renaming to capture the\n       --  expression (and hence we would generate a never-ending loop in the\n-      --  frontend).\n+      --  front end).\n \n       if Is_Class_Wide_Type (Exp_Type)\n          and then Nkind (Parent (Exp)) = N_Object_Renaming_Declaration"}]}