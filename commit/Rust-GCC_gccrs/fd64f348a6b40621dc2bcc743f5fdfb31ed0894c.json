{"sha": "fd64f348a6b40621dc2bcc743f5fdfb31ed0894c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmQ2NGYzNDhhNmI0MDYyMWRjMmJjYzc0M2Y1ZmRmYjMxZWQwODk0Yw==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2021-01-06T20:36:18Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2021-01-06T20:36:18Z"}, "message": "PR c++/98305 spurious -Wmismatched-new-delete on template instance\n\ngcc/ChangeLog:\n\n\tPR c++/98305\n\t* builtins.c (new_delete_mismatch_p): New overload.\n\t(new_delete_mismatch_p (tree, tree)): Call it.\n\ngcc/testsuite/ChangeLog:\n\n\tPR c++/98305\n\t* g++.dg/warn/Wmismatched-new-delete-3.C: New test.", "tree": {"sha": "75f82d459a18ec7eb99c5a8017c03ae08303d2d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/75f82d459a18ec7eb99c5a8017c03ae08303d2d9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fd64f348a6b40621dc2bcc743f5fdfb31ed0894c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd64f348a6b40621dc2bcc743f5fdfb31ed0894c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd64f348a6b40621dc2bcc743f5fdfb31ed0894c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd64f348a6b40621dc2bcc743f5fdfb31ed0894c/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "334a295fafdf5e66c4c976874282aea959830eb6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/334a295fafdf5e66c4c976874282aea959830eb6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/334a295fafdf5e66c4c976874282aea959830eb6"}], "stats": {"total": 369, "additions": 280, "deletions": 89}, "files": [{"sha": "02e7815aee5c3914462457da742f034ba8c09d4b", "filename": "gcc/builtins.c", "status": "modified", "additions": 121, "deletions": 89, "changes": 210, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd64f348a6b40621dc2bcc743f5fdfb31ed0894c/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd64f348a6b40621dc2bcc743f5fdfb31ed0894c/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=fd64f348a6b40621dc2bcc743f5fdfb31ed0894c", "patch": "@@ -78,6 +78,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-ssa-live.h\"\n #include \"tree-outof-ssa.h\"\n #include \"attr-fnspec.h\"\n+#include \"demangle.h\"\n \n struct target_builtins default_target_builtins;\n #if SWITCHABLE_TARGET\n@@ -13055,121 +13056,152 @@ call_dealloc_argno (tree exp)\n   return UINT_MAX;\n }\n \n-/* Return true if DELETE_DECL is an operator delete that's not suitable\n-   to call with a pointer returned fron NEW_DECL.  */\n+/* Return true if DELC doesn't refer to an operator delete that's\n+   suitable to call with a pointer returned from the operator new\n+   described by NEWC.  */\n \n static bool\n-new_delete_mismatch_p (tree new_decl, tree delete_decl)\n+new_delete_mismatch_p (const demangle_component &newc,\n+\t\t       const demangle_component &delc)\n {\n-  tree new_name = DECL_ASSEMBLER_NAME (new_decl);\n-  tree delete_name = DECL_ASSEMBLER_NAME (delete_decl);\n-\n-  /* valid_new_delete_pair_p() returns a conservative result.  A true\n-     result is reliable but a false result doesn't necessarily mean\n-     the operators don't match.  */\n-  if (valid_new_delete_pair_p (new_name, delete_name))\n-    return false;\n-\n-  const char *new_str = IDENTIFIER_POINTER (new_name);\n-  const char *del_str = IDENTIFIER_POINTER (delete_name);\n-\n-  if (*new_str != '_')\n-    return *new_str != *del_str;\n+  if (newc.type != delc.type)\n+    return true;\n \n-  ++del_str;\n-  if (*++new_str != 'Z')\n-    return *new_str != *del_str;\n+  switch (newc.type)\n+    {\n+    case DEMANGLE_COMPONENT_NAME:\n+      {\n+\tint len = newc.u.s_name.len;\n+\tconst char *news = newc.u.s_name.s;\n+\tconst char *dels = delc.u.s_name.s;\n+\tif (len != delc.u.s_name.len || memcmp (news, dels, len))\n+\t  return true;\n \n-  ++del_str;\n-  if (*++new_str == 'n')\n-    return *del_str != 'd';\n+\tif (news[len] == 'n')\n+\t  {\n+\t    if (news[len + 1] == 'a')\n+\t      return dels[len] != 'd' || dels[len + 1] != 'a';\n+\t    if (news[len + 1] == 'w')\n+\t      return dels[len] != 'd' || dels[len + 1] != 'l';\n+\t  }\n+\treturn false;\n+      }\n \n-  if (*new_str != 'N')\n-    return *del_str != 'N';\n+    case DEMANGLE_COMPONENT_OPERATOR:\n+      /* Operator mismatches are handled above.  */\n+      return false;\n \n-  /* Handle user-defined member operators below.  */\n-  ++new_str;\n-  ++del_str;\n+    case DEMANGLE_COMPONENT_EXTENDED_OPERATOR:\n+      if (newc.u.s_extended_operator.args != delc.u.s_extended_operator.args)\n+\treturn true;\n+      return new_delete_mismatch_p (*newc.u.s_extended_operator.name,\n+\t\t\t\t    *delc.u.s_extended_operator.name);\n \n-  do\n-    {\n-      /* Determine if both operators are members of the same type.\n-\t If not, they don't match.  */\n-      char *new_end, *del_end;\n-      unsigned long nlen = strtoul (new_str, &new_end, 10);\n-      unsigned long dlen = strtoul (del_str, &del_end, 10);\n-      if (nlen != dlen)\n+    case DEMANGLE_COMPONENT_FIXED_TYPE:\n+      if (newc.u.s_fixed.accum != delc.u.s_fixed.accum\n+\t  || newc.u.s_fixed.sat != delc.u.s_fixed.sat)\n \treturn true;\n+      return new_delete_mismatch_p (*newc.u.s_fixed.length,\n+\t\t\t\t    *delc.u.s_fixed.length);\n \n-      /* Skip past the name length.   */\n-      new_str = new_end;\n-      del_str = del_end;\n+    case DEMANGLE_COMPONENT_CTOR:\n+      if (newc.u.s_ctor.kind != delc.u.s_ctor.kind)\n+\treturn true;\n+      return new_delete_mismatch_p (*newc.u.s_ctor.name,\n+\t\t\t\t    *delc.u.s_ctor.name);\n \n-      /* Skip past the names making sure each has the expected length\n-\t (it would suggest some sort of a corruption if they didn't).  */\n-      while (nlen--)\n-\tif (!*++new_end)\n-\t  return true;\n+    case DEMANGLE_COMPONENT_DTOR:\n+      if (newc.u.s_dtor.kind != delc.u.s_dtor.kind)\n+\treturn true;\n+      return new_delete_mismatch_p (*newc.u.s_dtor.name,\n+\t\t\t\t    *delc.u.s_dtor.name);\n \n-      for (nlen = dlen; nlen--; )\n-\tif (!*++del_end)\n+    case DEMANGLE_COMPONENT_BUILTIN_TYPE:\n+      {\n+\t/* The demangler API provides no better way to compare built-in\n+\t   types except to by comparing their demangled names. */\n+\tsize_t nsz, dsz;\n+\tdemangle_component *pnc = const_cast<demangle_component *>(&newc);\n+\tdemangle_component *pdc = const_cast<demangle_component *>(&delc);\n+\tchar *nts = cplus_demangle_print (0, pnc, 16, &nsz);\n+\tchar *dts = cplus_demangle_print (0, pdc, 16, &dsz);\n+\tif (!nts != !dts)\n \t  return true;\n+\tbool mismatch = strcmp (nts, dts);\n+\tfree (nts);\n+\tfree (dts);\n+\treturn mismatch;\n+      }\n \n-      /* The names have the expected length.  Compare them.  */\n-      if (memcmp (new_str, del_str, dlen))\n+    case DEMANGLE_COMPONENT_SUB_STD:\n+      if (newc.u.s_string.len != delc.u.s_string.len)\n \treturn true;\n+      return memcmp (newc.u.s_string.string, delc.u.s_string.string,\n+\t\t     newc.u.s_string.len);\n \n-      new_str = new_end;\n-      del_str = del_end;\n-\n-      if (*new_str == 'I')\n-\t{\n-\t  /* Template instantiation.  */\n-\t  do\n-\t    {\n-\t      ++new_str;\n-\t      ++del_str;\n+    case DEMANGLE_COMPONENT_FUNCTION_PARAM:\n+    case DEMANGLE_COMPONENT_TEMPLATE_PARAM:\n+      return newc.u.s_number.number != delc.u.s_number.number;\n \n-\t      if (*new_str == 'n')\n-\t\tbreak;\n-\t      if (*new_str != *del_str)\n-\t\treturn true;\n-\t    }\n-\t  while (*new_str);\n-\t}\n+    case DEMANGLE_COMPONENT_CHARACTER:\n+      return newc.u.s_character.character != delc.u.s_character.character;\n \n-      if (*new_str == 'n')\n-\t{\n-\t  if (*del_str != 'd')\n-\t    return true;\n+    case DEMANGLE_COMPONENT_DEFAULT_ARG:\n+    case DEMANGLE_COMPONENT_LAMBDA:\n+      if (newc.u.s_unary_num.num != delc.u.s_unary_num.num)\n+\treturn true;\n+      return new_delete_mismatch_p (*newc.u.s_unary_num.sub,\n+\t\t\t\t    *delc.u.s_unary_num.sub);\n+    default:\n+      break;\n+    }\n \n-\t  ++del_str;\n-\t  if (*++new_str == 'w' && *del_str != 'l')\n-\t    return true;\n-\t  if (*new_str == 'a' && *del_str != 'a')\n-\t    return true;\n-\t  ++new_str;\n-\t  ++del_str;\n-\t  break;\n-\t}\n-    } while (true);\n+  if (!newc.u.s_binary.left != !delc.u.s_binary.left)\n+    return true;\n \n-  if (*new_str != 'E')\n-    return *del_str != *new_str;\n+  if (!newc.u.s_binary.left)\n+    return false;\n \n-  ++new_str;\n-  ++del_str;\n-  if (*new_str != 'j' && *new_str != 'm' && *new_str != 'y')\n-    return true;\n-  if (*del_str != 'P' || *++del_str != 'v')\n+  if (new_delete_mismatch_p (*newc.u.s_binary.left, *delc.u.s_binary.left)\n+      || !newc.u.s_binary.right != !delc.u.s_binary.right)\n     return true;\n \n-  /* Ignore any remaining arguments.  Since both operators are members\n-     of the same class, mismatches in those should be detectable and\n-     diagnosed by the front end.  */\n+  if (newc.u.s_binary.right)\n+    return new_delete_mismatch_p (*newc.u.s_binary.right,\n+\t\t\t\t  *delc.u.s_binary.right);\n   return false;\n }\n \n+/* Return true if DELETE_DECL is an operator delete that's not suitable\n+   to call with a pointer returned fron NEW_DECL.  */\n+\n+static bool\n+new_delete_mismatch_p (tree new_decl, tree delete_decl)\n+{\n+  tree new_name = DECL_ASSEMBLER_NAME (new_decl);\n+  tree delete_name = DECL_ASSEMBLER_NAME (delete_decl);\n+\n+  /* valid_new_delete_pair_p() returns a conservative result (currently\n+     it only handles global operators).  A true result is reliable but\n+     a false result doesn't necessarily mean the operators don't match.  */\n+  if (valid_new_delete_pair_p (new_name, delete_name))\n+    return false;\n+\n+  /* For anything not handled by valid_new_delete_pair_p() such as member\n+     operators compare the individual demangled components of the mangled\n+     name.  */\n+  const char *new_str = IDENTIFIER_POINTER (new_name);\n+  const char *del_str = IDENTIFIER_POINTER (delete_name);\n+\n+  void *np = NULL, *dp = NULL;\n+  demangle_component *ndc = cplus_demangle_v3_components (new_str, 0, &np);\n+  demangle_component *ddc = cplus_demangle_v3_components (del_str, 0, &dp);\n+  bool mismatch = new_delete_mismatch_p (*ndc, *ddc);\n+  free (np);\n+  free (dp);\n+  return mismatch;\n+}\n+\n /* ALLOC_DECL and DEALLOC_DECL are pair of allocation and deallocation\n    functions.  Return true if the latter is suitable to deallocate objects\n    allocated by calls to the former.  */"}, {"sha": "25e13461fe760d710cadd10ff2cf1005485f8475", "filename": "gcc/testsuite/g++.dg/warn/Wmismatched-new-delete-3.C", "status": "added", "additions": 159, "deletions": 0, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd64f348a6b40621dc2bcc743f5fdfb31ed0894c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWmismatched-new-delete-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd64f348a6b40621dc2bcc743f5fdfb31ed0894c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWmismatched-new-delete-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWmismatched-new-delete-3.C?ref=fd64f348a6b40621dc2bcc743f5fdfb31ed0894c", "patch": "@@ -0,0 +1,159 @@\n+/* PR c++/98305 spurious -Wmismatched-new-delete on template instance\n+   { dg-do compile }\n+   { dg-options \"-Wall\" } */\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+void sink (void*, ...);\n+\n+template <class>\n+struct A1\n+{\n+  A1 ();\n+\n+  void* operator new (size_t);\n+  void operator delete (void*);\n+\n+  void* operator new[] (size_t);\n+  void operator delete[] (void*);\n+\n+  template <class, class>\n+  struct A2\n+  {\n+    A2 ();\n+\n+    void* operator new (size_t);\n+    void operator delete (void*);\n+\n+    void* operator new[] (size_t);\n+    void operator delete[] (void*);\n+  };\n+};\n+\n+void test_a1 ()\n+{\n+  {\n+    A1<int> *p = new A1<int>();\n+    sink (p);\n+    delete p;\n+  }\n+\n+  {\n+    A1<long> *p = new A1<long>();\n+    sink (p);\n+    delete p;\n+  }\n+\n+  {\n+    void *p = new A1<int>();\n+    A1<long> *q = (A1<long>*)p;\n+    sink (q);\n+    delete q;       // { dg-warning \"-Wmismatched-new-delete\" }\n+  }\n+}\n+\n+void test_a2 ()\n+{\n+  {\n+    A1<int>::A2<int, int> *p = new A1<int>::A2<int, int>();\n+    sink (p);\n+    delete p;\n+  }\n+  {\n+    A1<void>::A2<int, long> *p = new A1<void>::A2<int, long>();\n+    sink (p);\n+    delete p;\n+  }\n+  {\n+    A1<char*>::A2<long, double> *p = new A1<char*>::A2<long, double>();\n+    sink (p);\n+    delete p;\n+  }\n+\n+  typedef A1<char>::A2<char, char> A;\n+  {\n+    A *p = (A*)new A1<char>::A2<char, int>();\n+    sink (p);\n+    delete p;       // { dg-warning \"-Wmismatched-new-delete\" }\n+  }\n+\n+  {\n+    A *p = (A*)new A1<char>::A2<int, char>();\n+    sink (p);\n+    delete p;       // { dg-warning \"-Wmismatched-new-delete\" }\n+  }\n+\n+  {\n+    A *p = (A*)new A1<int>::A2<char, char>();\n+    sink (p);\n+    delete p;       // { dg-warning \"-Wmismatched-new-delete\" }\n+  }\n+}\n+\n+\n+template <class>\n+struct B1\n+{\n+  B1 ();\n+\n+  void* operator new (size_t);\n+  void operator delete (void*);\n+\n+  void* operator new[] (size_t);\n+  void operator delete[] (void*);\n+\n+  template <class, class>\n+  struct B2\n+  {\n+    B2 ();\n+\n+    void* operator new (size_t);\n+    void operator delete (void*);\n+\n+    void* operator new[] (size_t);\n+    void operator delete[] (void*);\n+  };\n+};\n+\n+\n+void test_b_b ()\n+{\n+  typedef B1<char> B1c;\n+  typedef B1c::B2<B1c, B1c> B1cB2B1c;\n+\n+  {\n+    B1cB2B1c *p = new B1cB2B1c;\n+    sink (p);\n+    delete p;\n+  }\n+\n+  {\n+    B1cB2B1c *p = new B1cB2B1c[1];\n+    sink (p);\n+    delete[] p;\n+  }\n+}\n+\n+\n+void test_a_b ()\n+{\n+  typedef B1<char>::B2<char, char> B;\n+\n+  {\n+    B *p = (B*)new A1<char>::A2<char, int>[1];\n+    sink (p);\n+    delete[] p;     // { dg-warning \"-Wmismatched-new-delete\" }\n+  }\n+\n+  {\n+    B *p = (B*)new A1<char>::A2<int, char>[2];\n+    sink (p);\n+    delete[] p;     // { dg-warning \"-Wmismatched-new-delete\" }\n+  }\n+\n+  {\n+    B *p = (B*)new A1<int>::A2<char, char>[3];\n+    sink (p);\n+    delete[] p;     // { dg-warning \"-Wmismatched-new-delete\" }\n+  }\n+}"}]}