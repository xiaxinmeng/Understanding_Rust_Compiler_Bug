{"sha": "2024f9e4dc4746fc1f87a82ccd998d0c24f75d8c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjAyNGY5ZTRkYzQ3NDZmYzFmODdhODJjY2Q5OThkMGMyNGY3NWQ4Yw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1997-06-25T20:25:24Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1997-06-25T20:25:24Z"}, "message": "Completely rework according to new interface.\n\nFrom-SVN: r14310", "tree": {"sha": "938bbdc79bc8962b1b6cd7bb530731700295bc79", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/938bbdc79bc8962b1b6cd7bb530731700295bc79"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2024f9e4dc4746fc1f87a82ccd998d0c24f75d8c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2024f9e4dc4746fc1f87a82ccd998d0c24f75d8c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2024f9e4dc4746fc1f87a82ccd998d0c24f75d8c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2024f9e4dc4746fc1f87a82ccd998d0c24f75d8c/comments", "author": null, "committer": null, "parents": [{"sha": "f15e9e7ef22cffbdff2f1792dfc0d539fdd26a01", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f15e9e7ef22cffbdff2f1792dfc0d539fdd26a01", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f15e9e7ef22cffbdff2f1792dfc0d539fdd26a01"}], "stats": {"total": 3830, "additions": 1632, "deletions": 2198}, "files": [{"sha": "0c611b89afb4a2e1baad3b51940e3252066979f4", "filename": "gcc/objc/thr-decosf1.c", "status": "modified", "additions": 170, "deletions": 215, "changes": 385, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2024f9e4dc4746fc1f87a82ccd998d0c24f75d8c/gcc%2Fobjc%2Fthr-decosf1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2024f9e4dc4746fc1f87a82ccd998d0c24f75d8c/gcc%2Fobjc%2Fthr-decosf1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fthr-decosf1.c?ref=2024f9e4dc4746fc1f87a82ccd998d0c24f75d8c", "patch": "@@ -28,299 +28,254 @@ Boston, MA 02111-1307, USA.  */\n #include <objc/thr.h>\n #include \"runtime.h\"\n \n-/********\n- *  This structure represents a single mutual exclusion lock.  Lock semantics\n- *  are detailed with the subsequent functions.  We use whatever lock is\n- *  provided by the system.  We augment it with depth and current owner id\n- *  fields to implement and re-entrant lock.\n- */\n-struct objc_mutex \n-{\n-    volatile objc_thread_t      owner;          /* Id of thread that owns.  */\n-    volatile int                depth;          /* # of acquires.           */\n-    pthread_mutex_t             lock;           /* pthread mutex.           */\n-};\n-\n-/*****************************************************************************\n- *  Static variables.\n- */\n-static pthread_key_t    __objc_thread_data_key; /* Data key for thread data.*/\n+/* Key structure for maintiain thread specific storage */\n+static pthread_key_t _objc_thread_storage;\n \n+/* Backend initialization functions */\n \n-/********\n- *  Initialize the threads subsystem.  Returns 0 if successful, or -1 if no\n- *  thread support is available.\n- */\n+/* Initialize the threads subsystem. */\n int\n __objc_init_thread_system(void)\n {\n-    printf(\"__objc_init_thread_system\\n\");\n-    \n-    if (pthread_keycreate(&__objc_thread_data_key, NULL) == 0)\n-        return 0;                               /* Yes, return success.     */\n-    \n-    return -1;                                  /* Failed.                  */\n+  /* Initialize the thread storage key */\n+  return pthread_keycreate(&_objc_thread_storage, NULL);\n }\n \n+/* Close the threads subsystem. */\n int\n-__objc_fini_thread_system(void)\n+__objc_close_thread_system(void)\n {\n+  /* Destroy the thread storage key */\n+  /* Not implemented yet */\n+  /* return pthread_key_delete(&_objc_thread_storage); */\n   return 0;\n }\n \n-/********\n- *  Create a new thread of execution and return its id.  Return NULL if fails.\n- *  The new thread starts in \"func\" with the given argument.\n- */\n+/* Backend thread functions */\n+\n+/* Create a new thread of execution. */\n objc_thread_t\n-objc_thread_create(void (*func)(void *arg), void *arg)\n+__objc_thread_detach(void (*func)(void *arg), void *arg)\n {\n-    objc_thread_t      thread_id = NULL;       /* Detached thread id.      */\n-    pthread_t           new_thread_handle;      /* DCE thread handle.       */\n-\n-    objc_mutex_lock(__objc_runtime_mutex);\n-    \n-    if (pthread_create(&new_thread_handle, pthread_attr_default,\n-                       (void *)func, arg) == 0) {\n-      /* ??? May not work! (64bit)*/\n-        thread_id = *(objc_thread_t *)&new_thread_handle; \n-        pthread_detach(&new_thread_handle);     /* Fully detach thread.     */\n-\t__objc_runtime_threads_alive++;\n+  objc_thread_t thread_id;\n+  pthread_t new_thread_handle;\n+\n+  if (pthread_create(&new_thread_handle, pthread_attr_default,\n+\t\t     (void *)func, arg) == 0)\n+    {\n+      /* ??? May not work! (64bit) */\n+      thread_id = *(objc_thread_t *)&new_thread_handle; \n+      pthread_detach(&new_thread_handle);     /* Fully detach thread.     */\n     }\n-    \n-    objc_mutex_unlock(__objc_runtime_mutex);\n-    return thread_id;\n+  else\n+    thread_id = NULL;\n+  \n+  return thread_id;\n }\n \n-/********\n- *  Set the current thread's priority.\n- */\n+/* Set the current thread's priority. */\n int\n-objc_thread_set_priority(int priority)\n+__objc_thread_set_priority(int priority)\n {\n-    int         sys_priority = 0;\n+  int sys_priority = 0;\n \n-    switch (priority) {\n+  switch (priority)\n+    {\n     case OBJC_THREAD_INTERACTIVE_PRIORITY:\n-        sys_priority = (PRI_FG_MIN_NP + PRI_FG_MAX_NP) / 2;\n-        break;\n+      sys_priority = (PRI_FG_MIN_NP + PRI_FG_MAX_NP) / 2;\n+      break;\n     default:\n     case OBJC_THREAD_BACKGROUND_PRIORITY:\n-        sys_priority = (PRI_BG_MIN_NP + PRI_BG_MAX_NP) / 2;\n-        break;\n+      sys_priority = (PRI_BG_MIN_NP + PRI_BG_MAX_NP) / 2;\n+      break;\n     case OBJC_THREAD_LOW_PRIORITY:\n-        sys_priority = (PRI_BG_MIN_NP + PRI_BG_MAX_NP) / 2;\n-        break;\n+      sys_priority = (PRI_BG_MIN_NP + PRI_BG_MAX_NP) / 2;\n+      break;\n     }\n     \n-    if (pthread_setprio(pthread_self(), sys_priority) >= 0)\n-        return 0;                               /* Changed priority. End.   */\n-    \n-    return -1;                                  /* Failed.                  */\n+  /* Change the priority. */\n+  if (pthread_setprio(pthread_self(), sys_priority) >= 0)\n+    return 0;\n+  else\n+    /* Failed */\n+    return -1;\n }\n \n-/********\n- *  Return the current thread's priority.\n- */\n+/* Return the current thread's priority. */\n int\n-objc_thread_get_priority(void)\n+__objc_thread_get_priority(void)\n {\n-    int         sys_priority;                   /* DCE thread priority.     */\n+  int sys_priority;\n     \n-    if ((sys_priority = pthread_getprio(pthread_self())) >= 0) {\n-        if (sys_priority >= PRI_FG_MIN_NP && sys_priority <= PRI_FG_MAX_NP)\n-            return OBJC_THREAD_INTERACTIVE_PRIORITY;\n-        if (sys_priority >= PRI_BG_MIN_NP && sys_priority <= PRI_BG_MAX_NP)\n-            return OBJC_THREAD_BACKGROUND_PRIORITY;\n-        return OBJC_THREAD_LOW_PRIORITY;\n-    }\n-    return -1;                                  /* Couldn't get priority.   */\n+  if ((sys_priority = pthread_getprio(pthread_self())) >= 0) {\n+    if (sys_priority >= PRI_FG_MIN_NP && sys_priority <= PRI_FG_MAX_NP)\n+      return OBJC_THREAD_INTERACTIVE_PRIORITY;\n+    if (sys_priority >= PRI_BG_MIN_NP && sys_priority <= PRI_BG_MAX_NP)\n+      return OBJC_THREAD_BACKGROUND_PRIORITY;\n+    return OBJC_THREAD_LOW_PRIORITY;\n+  }\n+\n+  /* Failed */\n+  return -1;\n }\n \n-/********\n- *  Yield our process time to another thread.  Any BUSY waiting that is done\n- *  by a thread should use this function to make sure that other threads can\n- *  make progress even on a lazy uniprocessor system.\n- */\n+/* Yield our process time to another thread. */\n void\n-objc_thread_yield(void)\n+__objc_thread_yield(void)\n {\n-    pthread_yield();                            /* Yield to equal thread.   */\n+  pthread_yield();\n }\n \n-/********\n- *  Terminate the current tread.  Doesn't return anything.  Doesn't return.\n- *  Actually, if it failed returns -1.\n- */\n+/* Terminate the current thread. */\n int\n-objc_thread_exit(void)\n+__objc_thread_exit(void)\n {\n-  objc_mutex_lock(__objc_runtime_mutex);\n-  __objc_runtime_threads_alive--;\n-  objc_mutex_unlock(__objc_runtime_mutex);\n-      \n-  pthread_exit(&__objc_thread_exit_status);     /* Terminate thread.        */\n+  /* exit the thread */\n+  pthread_exit(&__objc_thread_exit_status);\n+\n+  /* Failed if we reached here */\n   return -1;\n }\n \n-/********\n- *  Returns an integer value which uniquely describes a thread.  Must not be\n- *  -1 which is reserved as a marker for \"no thread\".\n- */\n+/* Returns an integer value which uniquely describes a thread. */\n objc_thread_t\n-objc_thread_id(void)\n+__objc_thread_id(void)\n {\n   pthread_t self = pthread_self();\n \n   return (objc_thread_t) pthread_getuniqe_np (&self);\n }\n \n-/********\n- *  Sets the thread's local storage pointer.  Returns 0 if successful or -1\n- *  if failed.\n- */\n+/* Sets the thread's local storage pointer. */\n int\n-objc_thread_set_data(void *value)\n+__objc_thread_set_data(void *value)\n {\n-    if (pthread_setspecific(__objc_thread_data_key, (void *)value) == 0)\n-        return 0;                           \t/* Return thread data.      */\n-    return -1;\n+  return pthread_setspecific(_objc_thread_storage, value);\n }\n \n-/********\n- *  Returns the thread's local storage pointer.  Returns NULL on failure.\n- */\n+/* Returns the thread's local storage pointer. */\n void *\n-objc_thread_get_data(void)\n+__objc_thread_get_data(void)\n {\n-    void *      value = NULL;\n-    \n-    if (pthread_getspecific(__objc_thread_data_key, (void *)&value) == 0)\n-        return value;                           /* Return thread data.      */\n-    \n-    return NULL;\n+  void *value = NULL;\n+\n+  if ( !(pthread_getspecific(_objc_thread_storage, &value)) )\n+    return value;\n+\n+  return NULL;\n }\n \n-/********\n- *  Allocate a mutex.  Return the mutex pointer if successful or NULL if\n- *  the allocation fails for any reason.\n- */\n-objc_mutex_t\n-objc_mutex_allocate(void)\n+/* Backend mutex functions */\n+\n+/* Allocate a mutex. */\n+int\n+__objc_mutex_allocate(objc_mutex_t mutex)\n {\n-    objc_mutex_t mutex;\n-    int         err = 0;\n-    \n-    if (!(mutex = (objc_mutex_t)objc_malloc(sizeof(struct objc_mutex))))\n-        return NULL;                            /* Abort if malloc failed.  */\n-    \n-    err = pthread_mutex_init(&mutex->lock, pthread_mutexattr_default);\n-    \n-    if (err != 0) {                             /* System init failed?      */\n-        objc_free(mutex);                       /* Yes, free local memory.  */\n-        return NULL;                            /* Abort.                   */\n-    }\n-    mutex->owner = (objc_thread_t) -1;         /* No owner.                */\n-    mutex->depth = 0;                           /* No locks.                */\n-    return mutex;                               /* Return mutex handle.     */\n+  if (pthread_mutex_init((pthread_mutex_t *)(&(mutex->backend)), \n+\t\t\t pthread_mutexattr_default))\n+    return -1;\n+  else\n+    return 0;\n }\n \n-/********\n- *  Deallocate a mutex.  Note that this includes an implicit mutex_lock to\n- *  insure that no one else is using the lock.  It is legal to deallocate\n- *  a lock if we have a lock on it, but illegal to deallotcate a lock held\n- *  by anyone else.\n- *  Returns the number of locks on the thread.  (1 for deallocate).\n- */\n+/* Deallocate a mutex. */\n int\n-objc_mutex_deallocate(objc_mutex_t mutex)\n+__objc_mutex_deallocate(objc_mutex_t mutex)\n {\n-    int         depth;                          /* # of locks on mutex.     */\n+  if (pthread_mutex_destroy((pthread_mutex_t *)(&(mutex->backend))))\n+    return -1;\n+  else\n+    return 0;\n+}\n \n-    if (!mutex)                                 /* Is argument bad?         */\n-        return -1;                              /* Yes, abort.              */\n-    depth = objc_mutex_lock(mutex);             /* Must have lock.          */\n-    \n-    pthread_mutex_unlock(&mutex->lock);         /* Must unlock system mutex.*/\n-    pthread_mutex_destroy(&mutex->lock);        /* Free system mutex.       */\n-    \n-    objc_free(mutex);                           /* Free memory.             */\n-    return depth;                               /* Return last depth.       */\n+/* Grab a lock on a mutex. */\n+int\n+__objc_mutex_lock(objc_mutex_t mutex)\n+{\n+  return pthread_mutex_lock((pthread_mutex_t *)(&(mutex->backend)));\n }\n \n-/********\n- *  Grab a lock on a mutex.  If this thread already has a lock on this mutex\n- *  then we increment the lock count.  If another thread has a lock on the \n- *  mutex we block and wait for the thread to release the lock.\n- *  Returns the lock count on the mutex held by this thread.\n- */\n+/* Try to grab a lock on a mutex. */\n int\n-objc_mutex_lock(objc_mutex_t mutex)\n+__objc_mutex_trylock(objc_mutex_t mutex)\n {\n-    objc_thread_t thread_id;                   /* Cache our thread id.     */\n+  if (pthread_mutex_trylock((pthread_mutex_t *)(&(mutex->backend))) != 1)\n+    return -1;\n+  else\n+    return 0;\n+}\n+\n+/* Unlock the mutex */\n+int\n+__objc_mutex_unlock(objc_mutex_t mutex)\n+{\n+  return pthread_mutex_unlock((pthread_mutex_t *)(&(mutex->backend)));\n+}\n \n-    if (!mutex)                                 /* Is argument bad?         */\n-        return -1;                              /* Yes, abort.              */\n-    thread_id = objc_thread_id();               /* Get this thread's id.    */\n-    if (mutex->owner == thread_id)              /* Already own lock?        */\n-        return ++mutex->depth;                  /* Yes, increment depth.    */\n+/* Backend condition mutex functions */\n \n-    if (pthread_mutex_lock(&mutex->lock) != 0)  /* Lock DCE system mutex.   */\n-        return -1;                              /* Failed, abort.           */\n-    \n-    mutex->owner = thread_id;                   /* Mark thread as owner.    */\n-    return mutex->depth = 1;                    /* Increment depth to end.  */\n+/* Allocate a condition. */\n+int\n+__objc_condition_allocate(objc_condition_t condition)\n+{\n+  /* Unimplemented. */\n+  return -1;\n+\n+  /*\n+  if (pthread_cond_init((pthread_cond_t *)(&(condition->backend)), NULL))\n+    return -1;\n+  else\n+    return 0;\n+    */\n }\n \n-/********\n- *  Try to grab a lock on a mutex.  If this thread already has a lock on\n- *  this mutex then we increment the lock count and return it.  If another\n- *  thread has a lock on the mutex returns -1.\n- */\n+/* Deallocate a condition. */\n int\n-objc_mutex_trylock(objc_mutex_t mutex)\n+__objc_condition_deallocate(objc_condition_t condition)\n {\n-    objc_thread_t thread_id;                   /* Cache our thread id.     */\n+  /* Unimplemented. */\n+  return -1;\n \n-    if (!mutex)                                 /* Is argument bad?         */\n-        return -1;                              /* Yes, abort.              */\n-    thread_id = objc_thread_id();               /* Get this thread's id.    */\n-    if (mutex->owner == thread_id)              /* Already own lock?        */\n-        return ++mutex->depth;                  /* Yes, increment depth.    */\n-    \n-    if (pthread_mutex_trylock(&mutex->lock) != 1) /* Lock DCE system mutex. */\n-        return -1;                              /* Failed, abort.           */\n-    \n-    mutex->owner = thread_id;                   /* Mark thread as owner.    */\n-    return mutex->depth = 1;                    /* Increment depth to end.  */\n+  /*\n+  return pthread_cond_destroy((pthread_cond_t *)(&(condition->backend)));\n+  */\n }\n \n-/********\n- *  Decrements the lock count on this mutex by one.  If the lock count reaches\n- *  zero, release the lock on the mutex.  Returns the lock count on the mutex.\n- *  It is an error to attempt to unlock a mutex which this thread doesn't hold\n- *  in which case return -1 and the mutex is unaffected.\n- *  Will also return -1 if the mutex free fails.\n- */\n+/* Wait on the condition */\n int\n-objc_mutex_unlock(objc_mutex_t mutex)\n+__objc_condition_wait(objc_condition_t condition, objc_mutex_t mutex)\n {\n-    objc_thread_t thread_id;                   /* Cache our thread id.     */\n-    \n-    if (!mutex)                                 /* Is argument bad?         */\n-        return -1;                              /* Yes, abort.              */\n-    thread_id = objc_thread_id();               /* Get this thread's id.    */\n-    if (mutex->owner != thread_id)              /* Does some else own lock? */\n-        return -1;                              /* Yes, abort.              */\n-    if (mutex->depth > 1)                       /* Released last lock?      */\n-        return --mutex->depth;                  /* No, Decrement depth, end.*/\n-    mutex->depth = 0;                           /* Yes, reset depth to 0.   */\n-    mutex->owner = (objc_thread_t) -1;         /* Set owner to \"no thread\".*/\n-    \n-    if (pthread_mutex_unlock(&mutex->lock) != 0)  /* Unlock system mutex.   */\n-        return -1;                              /* Failed, abort.           */\n-    \n-    return 0;                                   /* No, return success.      */\n+  /* Unimplemented. */\n+  return -1;\n+\n+  /*\n+  return pthread_cond_wait((pthread_cond_t *)(&(condition->backend)),\n+\t\t\t   (pthread_mutex_t *)(&(mutex->backend)));\n+\t\t\t   */\n+}\n+\n+/* Wake up all threads waiting on this condition. */\n+int\n+__objc_condition_broadcast(objc_condition_t condition)\n+{\n+  /* Unimplemented. */\n+  return -1;\n+\n+  /*\n+  return pthread_cond_broadcast((pthread_cond_t *)(&(condition->backend)));\n+  */\n+}\n+\n+/* Wake up one thread waiting on this condition. */\n+int\n+__objc_condition_signal(objc_condition_t condition)\n+{\n+  /* Unimplemented. */\n+  return -1;\n+\n+  /*\n+  return pthread_cond_signal((pthread_cond_t *)(&(condition->backend)));\n+  */\n }\n \n /* End of File */"}, {"sha": "42032542b8017d794d25d7d2bdfeda5ef34b5ce7", "filename": "gcc/objc/thr-irix.c", "status": "modified", "additions": 137, "deletions": 216, "changes": 353, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2024f9e4dc4746fc1f87a82ccd998d0c24f75d8c/gcc%2Fobjc%2Fthr-irix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2024f9e4dc4746fc1f87a82ccd998d0c24f75d8c/gcc%2Fobjc%2Fthr-irix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fthr-irix.c?ref=2024f9e4dc4746fc1f87a82ccd998d0c24f75d8c", "patch": "@@ -32,283 +32,204 @@ Boston, MA 02111-1307, USA.  */\n #include <objc/thr.h>\n #include \"runtime.h\"\n \n-/********\n- *  This structure represents a single mutual exclusion lock.  Lock semantics\n- *  are detailed with the subsequent functions.  We use whatever lock is\n- *  provided by the system.  We augment it with depth and current owner id\n- *  fields to implement and re-entrant lock.\n- */\n-struct objc_mutex \n-{\n-    volatile objc_thread_t     owner;          /* Id of thread that owns.  */\n-    volatile int                depth;          /* # of acquires.           */\n-    ulock_t                     lock;           /* Irix lock.               */\n-};\n-\n-/*****************************************************************************\n- *  Static variables.\n- */\n-static void *  __objc_shared_arena_handle = NULL; /* Storage arena locks.   */\n-\n-/********\n- *  Initialize the threads subsystem.  Returns 0 if successful, or -1 if no\n- *  thread support is available.\n- */\n+/* Key structure for maintiain thread specific storage */\n+static void * __objc_shared_arena_handle = NULL;\n+\n+/* Backend initialization functions */\n+\n+/* Initialize the threads subsystem. */\n int\n __objc_init_thread_system(void)\n {\n-    char        arena_name[64];                 /* Name of IRIX arena.      */\n-\n-    DEBUG_PRINTF(\"__objc_init_thread_system\\n\");\n-    sprintf(arena_name, \"/usr/tmp/objc_%05u\", (unsigned)getpid());\n-    usconfig(CONF_INITUSERS, 256);              /* Up to 256 threads.       */\n-    usconfig(CONF_ARENATYPE, US_SHAREDONLY);    /* Arena only for threads.  */\n-    if (!(__objc_shared_arena_handle = usinit(arena_name))) /* Init Failed? */ \n-        return -1;                              /* Yes, return error code.  */\n-    \n-    return 0;\n+  /* Name of IRIX arena. */\n+  char arena_name[64];\n+\n+  DEBUG_PRINTF(\"__objc_init_thread_system\\n\");\n+\n+  /* Construct a temporary name for arena. */\n+  sprintf(arena_name, \"/usr/tmp/objc_%05u\", (unsigned)getpid());\n+\n+  /* Up to 256 threads.  Arena only for threads. */\n+  usconfig(CONF_INITUSERS, 256);\n+  usconfig(CONF_ARENATYPE, US_SHAREDONLY);\n+\n+  /* Initialize the arena */\n+  if (!(__objc_shared_arena_handle = usinit(arena_name)))\n+    /* Failed */\n+    return -1;\n+\n+  return 0;\n }\n \n+/* Close the threads subsystem. */\n int\n-__objc_fini_thread_system(void)\n+__objc_close_thread_system(void)\n {\n   return 0;\n }\n \n-/********\n- *  Create a new thread of execution and return its id.  Return NULL if fails.\n- *  The new thread starts in \"func\" with the given argument.\n- */\n+/* Backend thread functions */\n+\n+/* Create a new thread of execution. */\n objc_thread_t\n-objc_thread_create(void (*func)(void *arg), void *arg)\n+__objc_thread_detach(void (*func)(void *arg), void *arg)\n {\n-    objc_thread_t      thread_id = NULL;\n-    int                 sys_id;\n-    \n-    objc_mutex_lock(__objc_runtime_mutex);\n-    if ((sys_id = sproc((void *)func, PR_SALL, arg)) >= 0) {\n-        thread_id = (objc_thread_t)sys_id;\n-        __objc_runtime_threads_alive++;\n-    }\n-    objc_mutex_unlock(__objc_runtime_mutex);\n-\n-    return thread_id;\n+  objc_thread_t thread_id;\n+  int sys_id;\n+\n+  if ((sys_id = sproc((void *)func, PR_SALL, arg)) >= 0)\n+    thread_id = (objc_thread_t)sys_id;\n+  else\n+    thread_id = NULL;\n+  \n+  return thread_id;\n }\n \n-/********\n- *  Set the current thread's priority.\n- */\n+/* Set the current thread's priority. */\n int\n-objc_thread_set_priority(int priority)\n+__objc_thread_set_priority(int priority)\n {\n-    int         sys_priority = 0;\n-\n-    switch (priority) {\n-    case OBJC_THREAD_INTERACTIVE_PRIORITY:\n-        break;\n-    default:\n-    case OBJC_THREAD_BACKGROUND_PRIORITY:\n-        break;\n-    case OBJC_THREAD_LOW_PRIORITY:\n-        break;\n-    }\n-    return -1;                                  /* Failed.                  */\n+  /* Not implemented yet */\n+  return -1;\n }\n \n-/********\n- *  Return the current thread's priority.\n- */\n+/* Return the current thread's priority. */\n int\n-objc_thread_get_priority(void)\n+__objc_thread_get_priority(void)\n {\n-    return -1;                                  /* Couldn't get priority.   */\n+  /* Not implemented yet */\n+  return OBJC_THREAD_INTERACTIVE_PRIORITY;\n }\n \n-/********\n- *  Yield our process time to another thread.  Any BUSY waiting that is done\n- *  by a thread should use this function to make sure that other threads can\n- *  make progress even on a lazy uniprocessor system.\n- */\n+/* Yield our process time to another thread. */\n void\n-objc_thread_yield(void)\n+__objc_thread_yield(void)\n {\n-    sginap(0);                                  /* Yield to equal process.  */\n+  sginap(0);\n }\n \n-/********\n- *  Terminate the current tread.  Doesn't return anything.  Doesn't return.\n- *  Actually, if it failed returns -1.\n- */\n+/* Terminate the current thread. */\n int\n-objc_thread_exit(void)\n+__objc_thread_exit(void)\n {\n-    objc_mutex_lock(__objc_runtime_mutex);\n-    __objc_runtime_threads_alive--;\n-    objc_mutex_unlock(__objc_runtime_mutex);\n+  /* IRIX only has exit. */\n+  exit(__objc_thread_exit_status);\n \n-    exit(__objc_thread_exit_status);            /* IRIX only has exit.      */\n-    return -1;\n+  /* Failed if we reached here */\n+  return -1;\n }\n \n-/********\n- *  Returns an integer value which uniquely describes a thread.  Must not be\n- *  NULL which is reserved as a marker for \"no thread\".\n- */\n+/* Returns an integer value which uniquely describes a thread. */\n objc_thread_t\n-objc_thread_id(void)\n+__objc_thread_id(void)\n {\n-    return (objc_thread_t)get_pid();           /* Threads are processes.   */\n+  /* Threads are processes. */\n+  return (objc_thread_t)get_pid();\n }\n \n-/********\n- *  Sets the thread's local storage pointer.  Returns 0 if successful or -1\n- *  if failed.\n- */\n+/* Sets the thread's local storage pointer. */\n int\n-objc_thread_set_data(void *value)\n+__objc_thread_set_data(void *value)\n {\n-    *((void **)&PRDA->usr_prda) = value;        /* Set thread data ptr.     */\n-    return 0;\n+  *((void **)&PRDA->usr_prda) = value;\n+  return 0;\n }\n \n-/********\n- *  Returns the thread's local storage pointer.  Returns NULL on failure.\n- */\n+/* Returns the thread's local storage pointer. */\n void *\n-objc_thread_get_data(void)\n+__objc_thread_get_data(void)\n+{\n+  return *((void **)&PRDA->usr_prda);\n+}\n+\n+/* Backend mutex functions */\n+\n+/* Allocate a mutex. */\n+int\n+__objc_mutex_allocate(objc_mutex_t mutex)\n+{\n+  if (!( (ulock_t)(mutex->backend) = usnewlock(__objc_shared_arena_handle) ))\n+    return -1;\n+  else\n+    return 0;\n+}\n+\n+/* Deallocate a mutex. */\n+int\n+__objc_mutex_deallocate(objc_mutex_t mutex)\n {\n-    return *((void **)&PRDA->usr_prda);         /* Return thread data ptr.  */\n+  usfreelock((ulock_t)(mutex->backend), __objc_shared_arena_handle);\n+  return 0;\n }\n \n-/********\n- *  Allocate a mutex.\n- *  Return the mutex pointer if successful or NULL if the allocation failed\n- *  for any reason.\n- */\n-objc_mutex_t\n-objc_mutex_allocate(void)\n+/* Grab a lock on a mutex. */\n+int\n+__objc_mutex_lock(objc_mutex_t mutex)\n {\n-    objc_mutex_t       mutex;\n-    int                 err = 0;\n-    \n-    if (!(mutex = (objc_mutex_t)objc_malloc(sizeof(struct objc_mutex))))\n-        return NULL;                            /* Abort if malloc failed.  */\n-    \n-    if (!(mutex->lock = usnewlock(__objc_shared_arena_handle)))\n-        err = -1;\n-    \n-    if (err != 0) {                             /* System init failed?      */\n-        objc_free(mutex);                       /* Yes, free local memory.  */\n-        return NULL;                            /* Abort.                   */\n-    }\n-    mutex->owner = NULL;                        /* No owner.                */\n-    mutex->depth = 0;                           /* No locks.                */\n-    return mutex;                               /* Return mutex handle.     */\n+  if (ussetlock((ulock_t)(mutex->backend)) == 0)\n+    return -1;\n+  else\n+    return 0;\n }\n \n-/********\n- *  Deallocate a mutex.  Note that this includes an implicit mutex_lock to\n- *  insure that no one else is using the lock.  It is legal to deallocate\n- *  a lock if we have a lock on it, but illegal to deallotcate a lock held\n- *  by anyone else.\n- *  Returns the number of locks on the thread.  (1 for deallocate).\n- */\n+/* Try to grab a lock on a mutex. */\n int\n-objc_mutex_deallocate(objc_mutex_t mutex)\n+__objc_mutex_trylock(objc_mutex_t mutex)\n {\n-    int         depth;                          /* # of locks on mutex.     */\n-\n-    if (!mutex)                                 /* Is argument bad?         */\n-        return -1;                              /* Yes, abort.              */\n-    depth = objc_mutex_lock(mutex);             /* Must have lock.          */\n-    \n-    usfreelock(mutex->lock, __objc_shared_arena_handle); /* Free IRIX lock. */\n-    \n-    objc_free(mutex);                           /* Free memory.             */\n-    return depth;                               /* Return last depth.       */\n+  if (ustestlock((ulock_t)(mutex->backend)) == 0)\n+    return -1;\n+  else\n+    return 0;\n }\n \n-/********\n- *  Grab a lock on a mutex.  If this thread already has a lock on this mutex\n- *  then we increment the lock count.  If another thread has a lock on the \n- *  mutex we block and wait for the thread to release the lock.\n- *  Returns the lock count on the mutex held by this thread.\n- */\n+/* Unlock the mutex */\n int\n-objc_mutex_lock(objc_mutex_t mutex)\n+__objc_mutex_unlock(objc_mutex_t mutex)\n {\n-    objc_thread_t      thread_id;              /* Cache our thread id.     */\n-\n-    if (!mutex)                                 /* Is argument bad?         */\n-        return -1;                              /* Yes, abort.              */\n-    thread_id = objc_thread_id();               /* Get this thread's id.    */\n-    if (mutex->owner == thread_id) {            /* Already own lock?        */\n-        DEBUG_PRINTF(\"lock owned by: %d:%d\\n\", mutex->owner, mutex->depth);\n-        return ++mutex->depth;                  /* Yes, increment depth.    */\n-    }\n-    \n-    DEBUG_PRINTF(\"lock owned by: %d:%d (attempt by %d)\\n\",\n-                 mutex->owner, mutex->depth, thread_id);\n-\n-    if (ussetlock(mutex->lock) == 0)            /* Did lock acquire fail?   */\n-        return -1;                              /* Yes, abort.              */\n-    \n-    mutex->owner = thread_id;                   /* Mark thread as owner.    */\n-    return mutex->depth = 1;                    /* Increment depth to end.  */\n+  usunsetlock((ulock_t)(mutex->backend));\n+  return 0;\n }\n \n-/********\n- *  Try to grab a lock on a mutex.  If this thread already has a lock on\n- *  this mutex then we increment the lock count and return it.  If another\n- *  thread has a lock on the mutex returns -1.\n- */\n+/* Backend condition mutex functions */\n+\n+/* Allocate a condition. */\n int\n-objc_mutex_trylock(objc_mutex_t mutex)\n+__objc_condition_allocate(objc_condition_t condition)\n {\n-    objc_thread_t      thread_id;              /* Cache our thread id.     */\n-\n-    if (!mutex)                                 /* Is argument bad?         */\n-        return -1;                              /* Yes, abort.              */\n-    thread_id = objc_thread_id();               /* Get this thread's id.    */\n-    if (mutex->owner == thread_id)              /* Already own lock?        */\n-        return ++mutex->depth;                  /* Yes, increment depth.    */\n-    \n-    if (ustestlock(mutex->lock) == 0)           /* Did lock acquire fail?   */\n-        return -1;                              /* Yes, abort.              */\n-    \n-    mutex->owner = thread_id;                   /* Mark thread as owner.    */\n-    return mutex->depth = 1;                    /* Increment depth to end.  */\n+  /* Unimplemented. */\n+  return -1;\n }\n \n-/********\n- *  Decrements the lock count on this mutex by one.  If the lock count reaches\n- *  zero, release the lock on the mutex.  Returns the lock count on the mutex.\n- *  It is an error to attempt to unlock a mutex which this thread doesn't hold\n- *  in which case return -1 and the mutex is unaffected.\n- *  Will also return -1 if the mutex free fails.\n- */\n+/* Deallocate a condition. */\n+int\n+__objc_condition_deallocate(objc_condition_t condition)\n+{\n+  /* Unimplemented. */\n+  return -1;\n+}\n+\n+/* Wait on the condition */\n+int\n+__objc_condition_wait(objc_condition_t condition, objc_mutex_t mutex)\n+{\n+  /* Unimplemented. */\n+  return -1;\n+}\n+\n+/* Wake up all threads waiting on this condition. */\n+int\n+__objc_condition_broadcast(objc_condition_t condition)\n+{\n+  /* Unimplemented. */\n+  return -1;\n+}\n \n+/* Wake up one thread waiting on this condition. */\n int\n-objc_mutex_unlock(objc_mutex_t mutex)\n+__objc_condition_signal(objc_condition_t condition)\n {\n-    objc_thread_t     thread_id;               /* Cache our thread id.     */\n-    \n-    if (!mutex)                                 /* Is argument bad?         */\n-        return -1;                              /* Yes, abort.              */\n-    thread_id = objc_thread_id();               /* Get this thread's id.    */\n-    if (mutex->owner != thread_id)              /* Does some else own lock? */\n-        return -1;                              /* Yes, abort.              */\n-\n-    DEBUG_PRINTF(\"unlock by: %d:%d\\n\", mutex->owner, mutex->depth - 1);\n-    \n-    if (mutex->depth > 1)                       /* Released last lock?      */\n-        return --mutex->depth;                  /* No, Decrement depth, end.*/\n-    mutex->depth = 0;                           /* Yes, reset depth to 0.   */\n-    mutex->owner = NULL;                        /* Set owner to \"no thread\".*/\n-    \n-    usunsetlock(mutex->lock);                   /* Free lock.               */\n-    \n-    return 0;                                   /* No, return success.      */\n+  /* Unimplemented. */\n+  return -1;\n }\n \n /* End of File */"}, {"sha": "6f54ada61082298a8fd248270936d5413274603c", "filename": "gcc/objc/thr-mach.c", "status": "modified", "additions": 170, "deletions": 322, "changes": 492, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2024f9e4dc4746fc1f87a82ccd998d0c24f75d8c/gcc%2Fobjc%2Fthr-mach.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2024f9e4dc4746fc1f87a82ccd998d0c24f75d8c/gcc%2Fobjc%2Fthr-mach.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fthr-mach.c?ref=2024f9e4dc4746fc1f87a82ccd998d0c24f75d8c", "patch": "@@ -31,434 +31,282 @@ Boston, MA 02111-1307, USA.  */\n #include <objc/thr.h>\n #include \"runtime.h\"\n \n-/********\n- *  This structure represents a single mutual exclusion lock.  Lock semantics\n- *  are detailed with the subsequent functions.  We use whatever lock is\n- *  provided by the system.  We augment it with depth and current owner id\n- *  fields to implement and re-entrant lock.\n- */\n-struct objc_mutex \n+/*\n+  Obtain the maximum thread priority that can set for t.  Under the\n+  mach threading model, it is possible for the developer to adjust the\n+  maximum priority downward only-- cannot be raised without superuser\n+  priviledges.  Once lowered, it cannot be raised.\n+  */\n+static int __mach_get_max_thread_priority(cthread_t t, int *base)\n {\n-    volatile objc_thread_t     owner;          /* Id of thread that owns.  */\n-    volatile int                depth;          /* # of acquires.           */\n-    struct mutex                lock;           /* cthread mutex            */\n-};\n-\n-struct objc_condition \n-{\n-    struct condition            condition;      /* cthread condition        */\n-};\n-\n-/********\n- * obtain the maximum thread priority that can set for t.  Under the\n- * mach threading model, it is possible for the developer to adjust the\n- * maximum priority downward only-- cannot be raised without superuser\n- * priviledges.  Once lowered, it cannot be raised.\n- */\n-static int __mach_get_max_thread_priority(cthread_t t, int *base) {\n-    thread_t   \t\t      threadP;\n-    kern_return_t             error;\n-    struct thread_sched_info  info;\n-    unsigned int              info_count=THREAD_SCHED_INFO_COUNT;\n+  thread_t threadP;\n+  kern_return_t error;\n+  struct thread_sched_info info;\n+  unsigned int info_count=THREAD_SCHED_INFO_COUNT;\n     \n-    if (t == NULL)\n-\treturn -1;\n+  if (t == NULL)\n+    return -1;\n \n-    threadP  = cthread_thread(t); \t/* get thread underlying */\n+  threadP  = cthread_thread(t); \t/* get thread underlying */\n \n-    error=thread_info(threadP, THREAD_SCHED_INFO, \n-\t\t      (thread_info_t)&info, &info_count);\n+  error=thread_info(threadP, THREAD_SCHED_INFO, \n+\t\t    (thread_info_t)&info, &info_count);\n \n-    if (error != KERN_SUCCESS)\n-\treturn -1;\n+  if (error != KERN_SUCCESS)\n+    return -1;\n \n-    if (base != NULL)\n-\t*base = info.base_priority;\n+  if (base != NULL)\n+    *base = info.base_priority;\n \n-    return info.max_priority;\n+  return info.max_priority;\n }\n \t\n-/********\n- *  Initialize the threads subsystem.  Returns 0 if successful, or -1 if no\n- *  thread support is available.\n- */\n+/* Backend initialization functions */\n+\n+/* Initialize the threads subsystem. */\n int\n __objc_init_thread_system(void)\n {\n-    DEBUG_PRINTF(\"__objc_init_thread_system\\n\");\n-    return 0;                                    /* Succeeded.       */\n+  return 0;\n }\n \n-\n+/* Close the threads subsystem. */\n int\n-__objc_fini_thread_system(void)\n+__objc_close_thread_system(void)\n {\n   return 0;\n }\n \n-/********\n- *  Create a new thread of execution and return its id.  Return NULL if fails.\n- *  The new thread starts in \"func\" with the given argument.\n- */\n+/* Backend thread functions */\n+\n+/* Create a new thread of execution. */\n objc_thread_t\n-objc_thread_create(void (*func)(void *arg), void *arg)\n+__objc_thread_detach(void (*func)(void *arg), void *arg)\n {\n-    objc_thread_t      thread_id = NULL;       /* Detached thread id.      */\n-    cthread_t           new_thread_handle;      /* cthread handle.          */\n+  objc_thread_t thread_id;\n+  cthread_t new_thread_handle;\n \n-    objc_mutex_lock(__objc_runtime_mutex);\n-    \n-    /* create thread */\n-    new_thread_handle = cthread_fork((cthread_fn_t)func, arg);\n+  /* create thread */\n+  new_thread_handle = cthread_fork((cthread_fn_t)func, arg);\n \n-    if(new_thread_handle) {\n+  if(new_thread_handle)\n+    {\n       /* this is not terribly portable */\n-        thread_id = *(objc_thread_t *)&new_thread_handle; \n-        cthread_detach(new_thread_handle);      /* fully detach thread */\n-        __objc_runtime_threads_alive++;         /* increment thread count */\n+      thread_id = *(objc_thread_t *)&new_thread_handle; \n+      cthread_detach(new_thread_handle);\n     }\n-    \n-    objc_mutex_unlock(__objc_runtime_mutex);\n-    return thread_id;\n+  else\n+    thread_id = NULL;\n+  \n+  return thread_id;\n }\n \n-/********\n- *  Set the current thread's priority.\n- */\n+/* Set the current thread's priority. */\n int\n-objc_thread_set_priority(int priority)\n+__objc_thread_set_priority(int priority)\n {\n-    objc_thread_t   *t\t     = objc_thread_id();\n-    cthread_t        cT\t     = (cthread_t) t; \n-    int \t     maxPriority  = __mach_get_max_thread_priority(cT, NULL);\n-    int              sys_priority = 0;\n+  objc_thread_t *t = objc_thread_id();\n+  cthread_t cT = (cthread_t) t; \n+  int maxPriority = __mach_get_max_thread_priority(cT, NULL);\n+  int sys_priority = 0;\n \n-    if (maxPriority == -1)\n-\treturn -1;\n+  if (maxPriority == -1)\n+    return -1;\n \n-    switch (priority) {\n+  switch (priority)\n+    {\n     case OBJC_THREAD_INTERACTIVE_PRIORITY:\n-        sys_priority = maxPriority;\n-        break;\n+      sys_priority = maxPriority;\n+      break;\n     case OBJC_THREAD_BACKGROUND_PRIORITY:\n-        sys_priority = (maxPriority * 2) / 3;\n-        break;\n+      sys_priority = (maxPriority * 2) / 3;\n+      break;\n     case OBJC_THREAD_LOW_PRIORITY:\n-        sys_priority = maxPriority / 3;\n-        break;\n+      sys_priority = maxPriority / 3;\n+      break;\n     default:\n-\treturn -1;\n+      return -1;\n     }\n \n-    if (sys_priority == 0)\n-\treturn -1;\n-    \n-    if (cthread_priority(cT, sys_priority, 0) == KERN_SUCCESS)\n-        return 0;                               /* Changed priority. End.   */\n-    \n-    return -1;                                  /* Failed.                  */\n+  if (sys_priority == 0)\n+    return -1;\n+\n+  /* Change the priority */\n+  if (cthread_priority(cT, sys_priority, 0) == KERN_SUCCESS)\n+    return 0;\n+  else\n+    return -1;\n }\n \n-/********\n- *  Return the current thread's priority [well, whatever it is closest to].\n- */\n+/* Return the current thread's priority. */\n int\n-objc_thread_get_priority(void)\n+__objc_thread_get_priority(void)\n {\n-    objc_thread_t *t\t        = objc_thread_id();\n-    cthread_t      cT\t        = (cthread_t) t; /* see objc_thread_id() */\n-    int \t   basePriority;\n-    int \t   maxPriority;\n-    int            sys_priority = 0;\n-\n-    int interactiveT, backgroundT, lowT; /* threasholds */\n-\n-    maxPriority = __mach_get_max_thread_priority(cT, &basePriority);\n-\n-    if(maxPriority == -1)\n-\treturn -1;\n-\n-    if (basePriority > ( (maxPriority * 2) / 3))\n-\treturn OBJC_THREAD_INTERACTIVE_PRIORITY; /* interactive priority\n-\t\t\t\t\t\t */\n-    if (basePriority > ( maxPriority / 3))\n-\treturn OBJC_THREAD_BACKGROUND_PRIORITY; /* background priority\n-\t\t\t\t\t\t */\n-    return OBJC_THREAD_LOW_PRIORITY; /* everything else is low */\n+  objc_thread_t *t = objc_thread_id();\n+  cthread_t cT = (cthread_t) t; /* see objc_thread_id() */\n+  int basePriority;\n+  int maxPriority;\n+  int sys_priority = 0;\n+\n+  int interactiveT, backgroundT, lowT; /* threasholds */\n+\n+  maxPriority = __mach_get_max_thread_priority(cT, &basePriority);\n+\n+  if(maxPriority == -1)\n+    return -1;\n+\n+  if (basePriority > ( (maxPriority * 2) / 3))\n+    return OBJC_THREAD_INTERACTIVE_PRIORITY;\n+\n+  if (basePriority > ( maxPriority / 3))\n+    return OBJC_THREAD_BACKGROUND_PRIORITY;\n+\n+  return OBJC_THREAD_LOW_PRIORITY;\n }\n \n-/********\n- *  Yield our process time to another thread.  Any BUSY waiting that is done\n- *  by a thread should use this function to make sure that other threads can\n- *  make progress even on a lazy uniprocessor system.\n- */\n+/* Yield our process time to another thread. */\n void\n-objc_thread_yield(void)\n+__objc_thread_yield(void)\n {\n-    cthread_yield();                            /* Yield to equal thread.   */\n+  cthread_yield();\n }\n \n-/********\n- *  Terminate the current tread.  Doesn't return anything.  Doesn't return.\n- *  Actually, if it failed returns -1.\n- */\n+/* Terminate the current thread. */\n int\n-objc_thread_exit(void)\n+__objc_thread_exit(void)\n {\n-  objc_mutex_lock(__objc_runtime_mutex);\n-  __objc_runtime_threads_alive--;\n-  objc_mutex_unlock(__objc_runtime_mutex);\n-      \n-  cthread_exit(&__objc_thread_exit_status);     /* Terminate thread.        */\n+  /* exit the thread */\n+  cthread_exit(&__objc_thread_exit_status);\n+\n+  /* Failed if we reached here */\n   return -1;\n }\n \n-/********\n- *  Returns an integer value which uniquely describes a thread.  Must not be\n- *  NULL which is reserved as a marker for \"no thread\".\n- */\n+/* Returns an integer value which uniquely describes a thread. */\n objc_thread_t\n-objc_thread_id(void)\n+__objc_thread_id(void)\n {\n   cthread_t self = cthread_self();\n-  return (objc_thread_t)self;\n-}\n \n-/********\n- *  Sets the thread's local storage pointer.  Returns 0 if successful or -1\n- *  if failed.\n- */\n+  return *(objc_thread_t *)&self;\n+}\n \n+/* Sets the thread's local storage pointer. */\n int\n-objc_thread_set_data(void *value)\n+__objc_thread_set_data(void *value)\n {\n   cthread_set_data(cthread_self(), (any_t) value);\n   return 0;\n }\n \n-/********\n- *  Returns the thread's local storage pointer.  Returns NULL on failure.\n- */\n+/* Returns the thread's local storage pointer. */\n void *\n-objc_thread_get_data(void)\n+__objc_thread_get_data(void)\n {\n   return (void *) cthread_data(cthread_self());\n }\n \n-/********\n- *  Allocate a mutex.  Return the mutex pointer if successful or NULL if the\n- *  allocation failed for any reason.\n- */\n-objc_mutex_t\n-objc_mutex_allocate(void)\n+/* Backend mutex functions */\n+\n+/* Allocate a mutex. */\n+int\n+__objc_mutex_allocate(objc_mutex_t mutex)\n {\n-    objc_mutex_t mutex;\n-    int         err = 0;\n-    \n-    if (!(mutex = (objc_mutex_t)objc_malloc(sizeof(struct objc_mutex))))\n-        return NULL;                            /* Abort if malloc failed.  */\n+  int err = 0;\n+  mutex->backend = objc_malloc(sizeof(struct mutex));\n \n-    err = mutex_init(&(mutex->lock));\n-    \n-    if (err != 0) {                             /* System init failed?      */\n-        objc_free(mutex);                       /* Yes, free local memory.  */\n-        return NULL;                            /* Abort.                   */\n+  err = mutex_init((mutex_t)(mutex->backend));\n+\n+  if (err != 0)\n+    {\n+      objc_free(mutex->backend);\n+      return -1;\n     }\n-    mutex->owner = (objc_thread_t) -1;         /* No owner.                */\n-    mutex->depth = 0;                           /* No locks.                */\n-    return mutex;                               /* Return mutex handle.     */\n+  else\n+    return 0;\n }\n \n-/********\n- *  Deallocate a mutex.  Note that this includes an implicit mutex_lock to\n- *  insure that no one else is using the lock.  It is legal to deallocate\n- *  a lock if we have a lock on it, but illegal to deallocate a lock held\n- *  by anyone else.\n- *  Returns the number of locks on the thread.  (1 for deallocate).\n- */\n+/* Deallocate a mutex. */\n int\n-objc_mutex_deallocate(objc_mutex_t mutex)\n+__objc_mutex_deallocate(objc_mutex_t mutex)\n {\n-    int         depth;                          /* # of locks on mutex.     */\n+  mutex_clear((mutex_t)(mutex->backend));\n \n-    if (!mutex)                                 /* Is argument bad?         */\n-        return -1;                              /* Yes, abort.              */\n-    depth = objc_mutex_lock(mutex);             /* Must have lock.          */\n-    \n-    mutex_unlock(&(mutex->lock));               /* Must unlock system mutex.*/\n-    mutex_clear(&(mutex->lock));                /* Free system mutex.       */\n-    \n-    objc_free(mutex);                           /* Free memory.             */\n-    return depth;                               /* Return last depth.       */\n+  objc_free(mutex->backend);\n+  mutex->backend = NULL;\n+  return 0;\n }\n \n-/********\n- *  Grab a lock on a mutex.  If this thread already has a lock on this mutex\n- *  then we increment the lock count.  If another thread has a lock on the \n- *  mutex we block and wait for the thread to release the lock.\n- *  Returns the lock count on the mutex held by this thread.\n- */\n+/* Grab a lock on a mutex. */\n int\n-objc_mutex_lock(objc_mutex_t mutex)\n+__objc_mutex_lock(objc_mutex_t mutex)\n {\n-    objc_thread_t thread_id;                  /* Cache our thread id.     */\n-\n-    if (!mutex)                                 /* Is argument bad?         */\n-        return -1;                              /* Yes, abort.              */\n-    thread_id = objc_thread_id();               /* Get this thread's id.    */\n-    if (mutex->owner == thread_id)              /* Already own lock?        */\n-        return ++mutex->depth;                  /* Yes, increment depth.    */\n-\n-    mutex_lock(&(mutex->lock));                 /* Lock cthread mutex.      */\n-    \n-    mutex->owner = thread_id;                   /* Mark thread as owner.    */\n-    return mutex->depth = 1;                    /* Increment depth to end.  */\n+  mutex_lock((mutex_t)(mutex->backend));\n+  return 0;\n }\n \n-/********\n- *  Try to grab a lock on a mutex.  If this thread already has a lock on\n- *  this mutex then we increment the lock count and return it.  If another\n- *  thread has a lock on the mutex returns -1.\n- */\n+/* Try to grab a lock on a mutex. */\n int\n-objc_mutex_trylock(objc_mutex_t mutex)\n+__objc_mutex_trylock(objc_mutex_t mutex)\n {\n-    objc_thread_t         thread_id;           /* Cache our thread id.     */\n-\n-    if (!mutex)                                 /* Is argument bad?         */\n-        return -1;                              /* Yes, abort.              */\n-    thread_id = objc_thread_id();               /* Get this thread's id.    */\n-    if (mutex->owner == thread_id)              /* Already own lock?        */\n-        return ++mutex->depth;                  /* Yes, increment depth.    */\n-    \n-    if (mutex_try_lock(&(mutex->lock)) == 0)    /* Lock cthread mutex.      */\n-        return -1;                              /* Failed, abort.           */\n-    \n-    mutex->owner = thread_id;                   /* Mark thread as owner.    */\n-    return mutex->depth = 1;                    /* Increment depth to end.  */\n+  if (mutex_try_lock((mutex_t)(mutex->backend)) == 0)\n+    return -1;\n+  else\n+    return 0;\n }\n \n-/********\n- *  Decrements the lock count on this mutex by one.  If the lock count reaches\n- *  zero, release the lock on the mutex.  Returns the lock count on the mutex.\n- *  It is an error to attempt to unlock a mutex which this thread doesn't hold\n- *  in which case return -1 and the mutex is unaffected.\n- *  Will also return -1 if the mutex free fails.\n- */\n+/* Unlock the mutex */\n int\n-objc_mutex_unlock(objc_mutex_t mutex)\n+__objc_mutex_unlock(objc_mutex_t mutex)\n {\n-    objc_thread_t    thread_id;                /* Cache our thread id.     */\n-    \n-    if (!mutex)                                 /* Is argument bad?         */\n-        return -1;                              /* Yes, abort.              */\n-    thread_id = objc_thread_id();               /* Get this thread's id.    */\n-    if (mutex->owner != thread_id)              /* Does some else own lock? */\n-        return -1;                              /* Yes, abort.              */\n-    if (mutex->depth > 1)                       /* Released last lock?      */\n-        return --mutex->depth;                  /* No, Decrement depth, end.*/\n-    mutex->depth = 0;                           /* Yes, reset depth to 0.   */\n-    mutex->owner = (objc_thread_t) -1;         /* Set owner to \"no thread\".*/\n-    \n-    mutex_unlock(&(mutex->lock));               /* unlock cthread mutex.    */\n-    \n-    return 0;                                   /* No, return success.      */\n+  mutex_unlock((mutex_t)(mutex->backend));\n+  return 0;\n }\n \n-/********\n- *  Allocate a condition.  Return the condition pointer if successful or NULL\n- * if the allocation failed for any reason.\n- */\n-objc_condition_t \n-objc_condition_allocate(void)\n-{\n-    objc_condition_t condition;\n-    \n-    if (!(condition = (objc_condition_t)objc_malloc(\n-                        sizeof(struct objc_condition))))\n-        return NULL;                            /* Abort if malloc failed.  */\n+/* Backend condition mutex functions */\n \n-    condition_init(&(condition->condition));\n-    \n-    return condition;                           /* Return mutex handle.     */\n+/* Allocate a condition. */\n+int\n+__objc_condition_allocate(objc_condition_t condition)\n+{\n+  condition->backend = objc_malloc(sizeof(struct condition));\n+  condition_init((condition_t)(condition->backend));\n+  return 0;\n }\n \n-/********\n- *  Deallocate a condition. Note that this includes an implicit \n- *  condition_broadcast to insure that waiting threads have the opportunity\n- *  to wake.  It is legal to dealloc a condition only if no other\n- *  thread is/will be using it. Here we do NOT check for other threads\n- *  waiting but just wake them up.\n- */\n+/* Deallocate a condition. */\n int\n-objc_condition_deallocate(objc_condition_t condition)\n+__objc_condition_deallocate(objc_condition_t condition)\n {\n-\tcondition_broadcast(&(condition->condition));\n-\tcondition_clear(&(condition->condition));\n-\tobjc_free(condition);\n-\treturn 0;\n+  condition_clear((condition_t)(condition->backend));\n+  objc_free(condition->backend);\n+  condition->backend = NULL;\n+  return 0;\n }\n \n-/********\n- *  Wait on the condition unlocking the mutex until objc_condition_signal()\n- *  or objc_condition_broadcast() are called for the same condition. The\n- *  given mutex *must* have the depth set to 1 so that it can be unlocked\n- *  here, so that someone else can lock it and signal/broadcast the condition.\n- *  The mutex is used to lock access to the shared data that make up the\n- *  \"condition\" predicate.\n- */\n+/* Wait on the condition */\n int\n-objc_condition_wait(objc_condition_t condition, objc_mutex_t mutex)\n+__objc_condition_wait(objc_condition_t condition, objc_mutex_t mutex)\n {\n-    objc_thread_t    thread_id;                /* Cache our thread id.     */\n-    \n-    if (!mutex || !condition)                   /* Is argument bad?         */\n-        return -1;                              /* Yes, abort.              */\n-\n-    thread_id = objc_thread_id();               /* Get this thread's id.    */\n-    if (mutex->owner != thread_id)              /* Does some else own lock? */\n-        return -1;                              /* Yes, abort.              */\n-    if (mutex->depth > 1)                       /* Locked more than once ?  */\n-        return -1;                              /* YES, return error        */\n-                                                /* mutex will be unlocked   */\n-    mutex->depth = 0;                           /* Yes, reset depth to 0.   */\n-    mutex->owner = (objc_thread_t) -1;         /* Set owner to \"no thread\".*/\n-    \n-    condition_wait(&(condition->condition),\n-\t\t&(mutex->lock));                        /* unlock, wait ..., lock   */\n-    \n-    mutex->owner = thread_id;                   /* Mark thread as owner.    */\n-    mutex->depth = 1;                           /* Increment depth to end.  */\n-    return 0;                                   /* Return success.          */\n+  condition_wait((condition_t)(condition->backend),\n+\t\t (mutex_t)(mutex->backend));\n+  return 0;\n }\n \n-/********\n- *  Wake up all threads waiting on this condition. It is recommended that \n- *  the called would lock the same mutex as the threads in objc_condition_wait\n- *  before changing the \"condition predicate\" and make this call and unlock it\n- *  right away after this call.\n- */\n+/* Wake up all threads waiting on this condition. */\n int\n-objc_condition_broadcast(objc_condition_t condition)\n+__objc_condition_broadcast(objc_condition_t condition)\n {\n-    if (!condition)\n-\t\treturn -1;\n-\tcondition_broadcast(&(condition->condition));\n-\treturn 0;\n+  condition_broadcast((condition_t)(condition->backend));\n+  return 0;\n }\n \n-/********\n- *  Wake up one thread waiting on this condition. It is recommended that \n- *  the called would lock the same mutex as the threads in objc_condition_wait\n- *  before changing the \"condition predicate\" and make this call and unlock it\n- *  right away after this call.\n- */\n+/* Wake up one thread waiting on this condition. */\n int\n-objc_condition_signal(objc_condition_t condition)\n+__objc_condition_signal(objc_condition_t condition)\n {\n-    if (!condition)\n-\t\treturn -1;\n-\tcondition_signal(&(condition->condition));\n-\treturn 0;\n+  condition_signal((condition_t)(condition->backend));\n+  return 0;\n }\n \n+/* End of File */"}, {"sha": "d54606052d0054d5d645868afe5cd19b2e3220d4", "filename": "gcc/objc/thr-os2.c", "status": "modified", "additions": 116, "deletions": 190, "changes": 306, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2024f9e4dc4746fc1f87a82ccd998d0c24f75d8c/gcc%2Fobjc%2Fthr-os2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2024f9e4dc4746fc1f87a82ccd998d0c24f75d8c/gcc%2Fobjc%2Fthr-os2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fthr-os2.c?ref=2024f9e4dc4746fc1f87a82ccd998d0c24f75d8c", "patch": "@@ -44,71 +44,39 @@ Boston, MA 02111-1307, USA.  */\n \n #include <stdlib.h>\n \n-/********\n- *  This structure represents a single mutual exclusion lock.  Lock semantics\n- *  are detailed with the subsequent functions.  We use whatever lock is\n- *  provided by the system.  We augment it with depth and current owner id\n- *  fields to implement and re-entrant lock.\n- */\n-struct objc_mutex \n-{\n-  volatile objc_thread_t owner;          /* Id of thread that owns.  */\n-  volatile int            depth;          /* # of acquires.           */\n-  HMTX                    handle;         /* OS/2 mutex HANDLE.      */\n-};\n+/* Backend initialization functions */\n \n-/*****************************************************************************\n- *  Static variables.\n- */\n-/* none needed for OS/2 */\n-\n-/********\n- *  Initialize the threads subsystem.  Returns 0 if successful, or -1 if no\n- *  thread support is available.\n- */\n+/* Initialize the threads subsystem. */\n int\n __objc_init_thread_system(void)\n {\n-  DEBUG_PRINTF(\"__objc_init_thread_system (os2-emx)\\n\");\n-\n-  /* no initialization of thread subsystem */\n-  return 0;                               \t/* Yes, return success.     */\n+  return 0;\n }\n \n+/* Close the threads subsystem. */\n int\n-__objc_fini_thread_system(void)\n+__objc_close_thread_system(void)\n {\n-  /* no termination code for thread subsystem */\n   return 0;\n }\n \n-/********\n- *  Create a new thread of execution and return its id.  Return NULL if fails.\n- *  The new thread starts in \"func\" with the given argument.\n- */\n+/* Backend thread functions */\n+\n+/* Create a new thread of execution. */\n objc_thread_t\n-objc_thread_create(void (*func)(void *arg), void *arg)\n+__objc_thread_detach(void (*func)(void *arg), void *arg)\n {\n-  int thread_id = 0;  /* id of the newly created thread */\n+  int thread_id = 0;\n \n-  objc_mutex_lock(__objc_runtime_mutex);\n-\n-  /* create a thread calling \"func\", args \"arg\", stack size 32768 bytes */\n   if ((thread_id = _beginthread (func,NULL,32768,arg)) < 0)\n     thread_id = 0;\n-  else\n-    __objc_runtime_threads_alive++;\n-  \n-  objc_mutex_unlock(__objc_runtime_mutex);\n   \n   return (objc_thread_t)thread_id;\n }\n \n-/********\n- *  Set the current thread's priority.\n- */\n+/* Set the current thread's priority. */\n int\n-objc_thread_set_priority(int priority)\n+__objc_thread_set_priority(int priority)\n {\n   ULONG sys_class = 0;\n   ULONG sys_priority = 0;\n@@ -132,210 +100,168 @@ objc_thread_set_priority(int priority)\n     sys_priority = 0;\n     break;\n   }\n+\n+  /* Change priority */\n   if (!DosSetPriority (PRTYS_THREAD,sys_class,sys_priority,*_threadid))\n-    return 0;                                  \t/* Changed priority. End.   */\n-    \n-  return -1;                                  \t/* Failed.                  */\n+    return 0;\n+  else\n+    return -1;\n }\n \n-/********\n- *  Return the current thread's priority.\n- */\n+/* Return the current thread's priority. */\n int\n-objc_thread_get_priority(void)\n+__objc_thread_get_priority(void)\n {\n   PTIB ptib;\n   PPIB ppib;\n \n-  DosGetInfoBlocks (&ptib,&ppib); /* get information about current thread */\n+  /* get information about current thread */\n+  DosGetInfoBlocks (&ptib,&ppib);\n+\n+  switch (ptib->tib_ptib2->tib2_ulpri)\n+    {\n+    case PRTYC_IDLETIME:\n+    case PRTYC_REGULAR:\n+    case PRTYC_TIMECRITICAL:\n+    case PRTYC_FOREGROUNDSERVER:\n+    default:\n+      return OBJC_THREAD_INTERACTIVE_PRIORITY;\n+    }\n \n-  switch (ptib->tib_ptib2->tib2_ulpri) {\n-  case PRTYC_IDLETIME:\n-  case PRTYC_REGULAR:\n-  case PRTYC_TIMECRITICAL:\n-  case PRTYC_FOREGROUNDSERVER:\n-  default:\n-    return OBJC_THREAD_INTERACTIVE_PRIORITY;\n-  }\n-  return -1;                                  \t/* Couldn't get priority.   */\n+  return -1;\n }\n \n-/********\n- *  Yield our process time to another thread.  Any BUSY waiting that is done\n- *  by a thread should use this function to make sure that other threads can\n- *  make progress even on a lazy uniprocessor system.\n- */\n+/* Yield our process time to another thread. */\n void\n-objc_thread_yield(void)\n+__objc_thread_yield(void)\n {\n-  DosSleep (0);\t                            \t/* Yield to equal thread.   */\n+  DosSleep (0);\n }\n \n-/********\n- *  Terminate the current tread.  Doesn't return anything.  Doesn't return.\n- *  Actually, if it failed returns -1.\n- */\n+/* Terminate the current thread. */\n int\n-objc_thread_exit(void)\n+__objc_thread_exit(void)\n {\n-  objc_mutex_lock(__objc_runtime_mutex);\n-  __objc_runtime_threads_alive--;\n-  objc_mutex_unlock(__objc_runtime_mutex);\n-\n-  _endthread (); /* terminate the thread, NEVER use DosExit () */\n+  /* terminate the thread, NEVER use DosExit () */\n+  _endthread ();\n \n+  /* Failed if we reached here */\n   return -1;\n }\n \n-/********\n- *  Returns an integer value which uniquely describes a thread.  Must not be\n- *  -1 which is reserved as a marker for \"no thread\".\n- */\n+/* Returns an integer value which uniquely describes a thread. */\n objc_thread_t\n-objc_thread_id(void)\n+__objc_thread_id(void)\n {\n-  return (objc_thread_t) *_threadid;  /* Return thread id.        */\n+  return (objc_thread_t) *_threadid;\n }\n \n-/********\n- *  Sets the thread's local storage pointer.  Returns 0 if successful or -1\n- *  if failed.\n- */\n+/* Sets the thread's local storage pointer. */\n int\n-objc_thread_set_data(void *value)\n+__objc_thread_set_data(void *value)\n {\n   *_threadstore () = value;\n \n   return 0;\n }\n \n-/********\n- *  Returns the thread's local storage pointer.  Returns NULL on failure.\n- */\n+/* Returns the thread's local storage pointer. */\n void *\n-objc_thread_get_data(void)\n+__objc_thread_get_data(void)\n {\n   return *_threadstore ();\n }\n \n-/********\n- *  Allocate a mutex.  Return the mutex pointer if successful or NULL if\n- *  the allocation fails for any reason.\n- */\n-objc_mutex_t\n-objc_mutex_allocate(void)\n-{\n-    objc_mutex_t mutex;\n-    int         err = 0;\n-\n-    if (!(mutex = (objc_mutex_t)objc_malloc(sizeof(struct objc_mutex))))\n-        return NULL;                            /* Abort if malloc failed.  */\n-\n-    if (DosCreateMutexSem (NULL,&(mutex->handle),0L,0) > 0) {\n-      objc_free(mutex);\n-      return NULL;\n-    }\n+/* Backend mutex functions */\n \n-    mutex->owner = NULL;                        /* No owner.                */\n-    mutex->depth = 0;                           /* No locks.                */\n-    return mutex;                               /* Return mutex handle.     */\n+/* Allocate a mutex. */\n+int\n+__objc_mutex_allocate(objc_mutex_t mutex)\n+{\n+  if (DosCreateMutexSem (NULL, (HMTX)(&(mutex->backend)),0L,0) > 0)\n+    return -1;\n+  else\n+    return 0;\n }\n \n-/********\n- *  Deallocate a mutex.  Note that this includes an implicit mutex_lock to\n- *  insure that no one else is using the lock.  It is legal to deallocate\n- *  a lock if we have a lock on it, but illegal to deallotcate a lock held\n- *  by anyone else.\n- *  Returns the number of locks on the thread.  (1 for deallocate).\n- */\n+/* Deallocate a mutex. */\n int\n-objc_mutex_deallocate(objc_mutex_t mutex)\n+__objc_mutex_deallocate(objc_mutex_t mutex)\n {\n-    int         depth;                          /* # of locks on mutex.     */\n-\n-    if (!mutex)                                 /* Is argument bad?         */\n-        return -1;                              /* Yes, abort.              */\n-    depth = objc_mutex_lock(mutex);             /* Must have lock.          */\n-\n-    DosCloseMutexSem (mutex->handle);\n-    \n-    objc_free(mutex);                           /* Free memory.             */\n-    return depth;                               /* Return last depth.       */\n+  DosCloseMutexSem ((HMTX)(mutex->backend));\n+  return 0;\n }\n \n-/********\n- *  Grab a lock on a mutex.  If this thread already has a lock on this mutex\n- *  then we increment the lock count.  If another thread has a lock on the \n- *  mutex we block and wait for the thread to release the lock.\n- *  Returns the lock count on the mutex held by this thread.\n- */\n+/* Grab a lock on a mutex. */\n int\n-objc_mutex_lock(objc_mutex_t mutex)\n+__objc_mutex_lock(objc_mutex_t mutex)\n {\n-    objc_thread_t      thread_id;              /* Cache our thread id.     */\n-\n-    if (!mutex)                                 /* Is argument bad?         */\n-        return -1;                              /* Yes, abort.              */\n+  if (DosRequestMutexSem ((HMTX)(mutex->backend),-1L) != 0)\n+    return -1;\n+  else\n+    return 0;\n+}\n \n-    thread_id = objc_thread_id();               /* Get this thread's id.    */\n-    if (mutex->owner == thread_id)              /* Already own lock?        */\n-        return ++mutex->depth;                  /* Yes, increment depth.    */\n+/* Try to grab a lock on a mutex. */\n+int\n+__objc_mutex_trylock(objc_mutex_t mutex)\n+{\n+  if (DosRequestMutexSem ((HMTX)(mutex->backend),0L) != 0)\n+    return -1;\n+  else\n+    return 0;\n+}\n \n-    if (DosRequestMutexSem (mutex->handle,-1L) != 0)\n-      return -1;\n+/* Unlock the mutex */\n+int\n+__objc_mutex_unlock(objc_mutex_t mutex)\n+{\n+  if (DosReleaseMutexSem((HMTX)(mutex->backend)) != 0)\n+    return -1;\n+  else\n+    return 0;\n+}\n \n-    mutex->owner = thread_id;                   /* Mark thread as owner.    */\n+/* Backend condition mutex functions */\n \n-    return ++mutex->depth;                      /* Increment depth to end.  */\n+/* Allocate a condition. */\n+int\n+__objc_condition_allocate(objc_condition_t condition)\n+{\n+  /* Unimplemented. */\n+  return -1;\n }\n \n-/********\n- *  Try to grab a lock on a mutex.  If this thread already has a lock on\n- *  this mutex then we increment the lock count and return it.  If another\n- *  thread has a lock on the mutex returns -1.\n- */\n+/* Deallocate a condition. */\n int\n-objc_mutex_trylock(objc_mutex_t mutex)\n+__objc_condition_deallocate(objc_condition_t condition)\n {\n-    objc_thread_t      thread_id;              /* Cache our thread id.     */\n-\n-    if (!mutex)                                 /* Is argument bad?         */\n-        return -1;                              /* Yes, abort.              */\n-    thread_id = objc_thread_id();               /* Get this thread's id.    */\n-    if (mutex->owner == thread_id)              /* Already own lock?        */\n-        return ++mutex->depth;                  /* Yes, increment depth.    */\n+  /* Unimplemented. */\n+  return -1;\n+}\n \n-    if (DosRequestMutexSem (mutex->handle,0L) != 0)\n-      return -1;\n+/* Wait on the condition */\n+int\n+__objc_condition_wait(objc_condition_t condition, objc_mutex_t mutex)\n+{\n+  /* Unimplemented. */\n+  return -1;\n+}\n \n-    mutex->owner = thread_id;                   /* Mark thread as owner.    */\n-    return ++mutex->depth;                      /* Increment depth to end.  */\n+/* Wake up all threads waiting on this condition. */\n+int\n+__objc_condition_broadcast(objc_condition_t condition)\n+{\n+  /* Unimplemented. */\n+  return -1;\n }\n \n-/********\n- *  Decrements the lock count on this mutex by one.  If the lock count reaches\n- *  zero, release the lock on the mutex.  Returns the lock count on the mutex.\n- *  It is an error to attempt to unlock a mutex which this thread doesn't hold\n- *  in which case return -1 and the mutex is unaffected.\n- *  Will also return -1 if the mutex free fails.\n- */\n+/* Wake up one thread waiting on this condition. */\n int\n-objc_mutex_unlock(objc_mutex_t mutex)\n+__objc_condition_signal(objc_condition_t condition)\n {\n-    objc_thread_t      thread_id;              /* Cache our thread id.     */\n-    \n-    if (!mutex)                                 /* Is argument bad?         */\n-        return -1;                              /* Yes, abort.              */\n-    thread_id = objc_thread_id();               /* Get this thread's id.    */\n-    if (mutex->owner != thread_id)              /* Does some else own lock? */\n-        return -1;                              /* Yes, abort.              */\n-    if (mutex->depth > 1)                       /* Released last lock?      */\n-        return --mutex->depth;                  /* No, Decrement depth, end.*/\n-    mutex->depth = 0;                           /* Yes, reset depth to 0.   */\n-    mutex->owner = NULL;                        /* Set owner to \"no thread\".*/\n-    \n-    if (DosReleaseMutexSem(mutex->handle) != 0)\n-        return -1;                              /* Failed, abort.           */\n-    \n-    return 0;                                   /* No, return success.      */\n+  /* Unimplemented. */\n+  return -1;\n }\n+\n+/* End of File */"}, {"sha": "1b9a9e50049ccf72bf8bf15dc58607896730c8bd", "filename": "gcc/objc/thr-posix.c", "status": "modified", "additions": 114, "deletions": 226, "changes": 340, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2024f9e4dc4746fc1f87a82ccd998d0c24f75d8c/gcc%2Fobjc%2Fthr-posix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2024f9e4dc4746fc1f87a82ccd998d0c24f75d8c/gcc%2Fobjc%2Fthr-posix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fthr-posix.c?ref=2024f9e4dc4746fc1f87a82ccd998d0c24f75d8c", "patch": "@@ -29,294 +29,182 @@ Boston, MA 02111-1307, USA.  */\n #include \"runtime.h\"\n #include <pthread.h>\n \n-/********\n- *  This structure represents a single mutual exclusion lock.  Lock semantics\n- *  are detailed with the subsequent functions.  We use whatever lock is\n- *  provided by the system.  We augment it with depth and current owner id\n- *  fields to implement and re-entrant lock.\n- */\n-struct objc_mutex \n-{\n-    volatile objc_thread_t     owner;          /* Id of thread that owns.  */\n-    volatile int                depth;          /* # of acquires.           */\n-    pthread_mutex_t             lock;           /* pthread mutex.           */\n-};\n-\n-/*****************************************************************************\n- *  Static variables.\n- */\n-static pthread_key_t    __objc_thread_data_key; /* Data key for thread data.*/\n+/* Key structure for maintiain thread specific storage */\n+static pthread_key_t _objc_thread_storage;\n \n+/* Backend initialization functions */\n \n-/********\n- *  Initialize the threads subsystem.  Returns 0 if successful, or -1 if no\n- *  thread support is available.\n- */\n+/* Initialize the threads subsystem. */\n int\n __objc_init_thread_system(void)\n {\n-    if (pthread_key_create(&__objc_thread_data_key, NULL) == 0)\n-        return 0;                               /* Yes, return success.     */\n-    \n-    return -1;                                  /* Failed.                  */\n+  /* Initialize the thread storage key */\n+  return pthread_key_create(&_objc_thread_storage, NULL);\n }\n \n+/* Close the threads subsystem. */\n int\n-__objc_fini_thread_system(void)\n+__objc_close_thread_system(void)\n {\n   return 0;\n }\n \n-/********\n- *  Create a new thread of execution and return its id.  Return NULL if fails.\n- *  The new thread starts in \"func\" with the given argument.\n- */\n+/* Backend thread functions */\n+\n+/* Create a new thread of execution. */\n objc_thread_t\n-objc_thread_create(void (*func)(void *arg), void *arg)\n+__objc_thread_detach(void (*func)(void *arg), void *arg)\n {\n-    objc_thread_t      thread_id = NULL;       /* Detached thread id.      */\n-    pthread_t           new_thread_handle;      /* DCE thread handle.       */\n-\n-    objc_mutex_lock(__objc_runtime_mutex);\n-\n-    if (pthread_create(&new_thread_handle, NULL,\n-                       (void *)func, arg) == 0) {\n-        thread_id = (objc_thread_t) new_thread_handle;\n-        pthread_detach(new_thread_handle);     /* Fully detach thread.     */\n-\t__objc_runtime_threads_alive++;\n-    }\n-    \n-    objc_mutex_unlock(__objc_runtime_mutex);\n-    return thread_id;\n+  objc_thread_t thread_id;\n+  pthread_t new_thread_handle;\n+\n+  if ( !(pthread_create(&new_thread_handle, NULL, (void *)func, arg)) )\n+      thread_id = *(objc_thread_t *)&new_thread_handle;\n+  else\n+    thread_id = NULL;\n+  \n+  return thread_id;\n }\n \n-/********\n- *  Set the current thread's priority.\n- */\n+/* Set the current thread's priority. */\n int\n-objc_thread_set_priority(int priority)\n+__objc_thread_set_priority(int priority)\n {\n-#if 0 /* no get/set priority in Linux pthreads */\n-\n-    int         sys_priority = 0;\n-\n-    switch (priority) {\n-    case OBJC_THREAD_INTERACTIVE_PRIORITY:\n-        sys_priority = (PRI_FG_MIN_NP + PRI_FG_MAX_NP) / 2;\n-        break;\n-    default:\n-    case OBJC_THREAD_BACKGROUND_PRIORITY:\n-        sys_priority = (PRI_BG_MIN_NP + PRI_BG_MAX_NP) / 2;\n-        break;\n-    case OBJC_THREAD_LOW_PRIORITY:\n-        sys_priority = (PRI_BG_MIN_NP + PRI_BG_MAX_NP) / 2;\n-        break;\n-    }\n-    \n-    if (pthread_setprio(pthread_self(), sys_priority) >= 0)\n-        return 0;                               /* Changed priority. End.   */\n-    \n-#endif\n-    return -1;                                  /* Failed.                  */\n+  /* Not implemented yet */\n+  return -1;\n }\n \n-/********\n- *  Return the current thread's priority.\n- */\n+/* Return the current thread's priority. */\n int\n-objc_thread_get_priority(void)\n+__objc_thread_get_priority(void)\n {\n-#if 0 /* no get/set priority in Linux pthreads */\n-    int         sys_priority;                   /* DCE thread priority.     */\n-    \n-    if ((sys_priority = pthread_getprio(pthread_self())) >= 0) {\n-        if (sys_priority >= PRI_FG_MIN_NP && sys_priority <= PRI_FG_MAX_NP)\n-            return OBJC_THREAD_INTERACTIVE_PRIORITY;\n-        if (sys_priority >= PRI_BG_MIN_NP && sys_priority <= PRI_BG_MAX_NP)\n-            return OBJC_THREAD_BACKGROUND_PRIORITY;\n-        return OBJC_THREAD_LOW_PRIORITY;\n-    }\n-#endif\n-    return -1;                                  /* Couldn't get priority.   */\n+  /* Not implemented yet */\n+  return -1;\n }\n \n-/********\n- *  Yield our process time to another thread.  Any BUSY waiting that is done\n- *  by a thread should use this function to make sure that other threads can\n- *  make progress even on a lazy uniprocessor system.\n- */\n+/* Yield our process time to another thread. */\n void\n-objc_thread_yield(void)\n+__objc_thread_yield(void)\n {\n-    pthread_yield();                            /* Yield to equal thread.   */\n+  pthread_yield();\n }\n \n-/********\n- *  Terminate the current tread.  Doesn't return anything.  Doesn't return.\n- *  Actually, if it failed returns -1.\n- */\n+/* Terminate the current thread. */\n int\n-objc_thread_exit(void)\n+__objc_thread_exit(void)\n {\n-  objc_mutex_lock(__objc_runtime_mutex);\n-  __objc_runtime_threads_alive--;\n-  objc_mutex_unlock(__objc_runtime_mutex);\n-      \n-  pthread_exit(&__objc_thread_exit_status);     /* Terminate thread.        */\n+  /* exit the thread */\n+  pthread_exit(&__objc_thread_exit_status);\n+\n+  /* Failed if we reached here */\n   return -1;\n }\n \n-/********\n- *  Returns an integer value which uniquely describes a thread.  Must not be\n- *  -1 which is reserved as a marker for \"no thread\".\n- */\n+/* Returns an integer value which uniquely describes a thread. */\n objc_thread_t\n-objc_thread_id(void)\n+__objc_thread_id(void)\n {\n   pthread_t self = pthread_self();\n \n-  return (objc_thread_t) self;               /* Return thread handle.    */\n+  return *(objc_thread_t *)&self;\n }\n \n-/********\n- *  Sets the thread's local storage pointer.  Returns 0 if successful or -1\n- *  if failed.\n- */\n+/* Sets the thread's local storage pointer. */\n int\n-objc_thread_set_data(void *value)\n+__objc_thread_set_data(void *value)\n {\n-    if (pthread_setspecific(__objc_thread_data_key, (void *)value) == 0)\n-        return 0;                           \t/* Return thread data.      */\n-    return -1;\n+  return pthread_setspecific(_objc_thread_storage, value);\n }\n \n-/********\n- *  Returns the thread's local storage pointer.  Returns NULL on failure.\n- */\n+/* Returns the thread's local storage pointer. */\n void *\n-objc_thread_get_data(void)\n+__objc_thread_get_data(void)\n+{\n+  return pthread_getspecific(_objc_thread_storage);\n+}\n+\n+/* Backend mutex functions */\n+\n+/* Allocate a mutex. */\n+int\n+__objc_mutex_allocate(objc_mutex_t mutex)\n {\n-    return pthread_getspecific(__objc_thread_data_key);\n+  if (pthread_mutex_init((pthread_mutex_t *)(&(mutex->backend)), NULL))\n+    return -1;\n+  else\n+    return 0;\n }\n \n-/********\n- *  Allocate a mutex.  Return the mutex pointer if successful or NULL if\n- *  the allocation fails for any reason.\n- */\n-objc_mutex_t\n-objc_mutex_allocate(void)\n+/* Deallocate a mutex. */\n+int\n+__objc_mutex_deallocate(objc_mutex_t mutex)\n {\n-    objc_mutex_t mutex;\n-    int         err = 0;\n-    \n-    if (!(mutex = (objc_mutex_t)objc_malloc(sizeof(struct objc_mutex))))\n-        return NULL;                            /* Abort if malloc failed.  */\n-\n-    err = pthread_mutex_init(&mutex->lock, NULL);\n-    \n-    if (err != 0) {                             /* System init failed?      */\n-        objc_free(mutex);                       /* Yes, free local memory.  */\n-        return NULL;                            /* Abort.                   */\n-    }\n-    mutex->owner = NULL;                        /* No owner.                */\n-    mutex->depth = 0;                           /* No locks.                */\n-    return mutex;                               /* Return mutex handle.     */\n+  if (pthread_mutex_destroy((pthread_mutex_t *)(&(mutex->backend))))\n+    return -1;\n+  else\n+    return 0;\n }\n \n-/********\n- *  Deallocate a mutex.  Note that this includes an implicit mutex_lock to\n- *  insure that no one else is using the lock.  It is legal to deallocate\n- *  a lock if we have a lock on it, but illegal to deallotcate a lock held\n- *  by anyone else.\n- *  Returns the number of locks on the thread.  (1 for deallocate).\n- */\n+/* Grab a lock on a mutex. */\n int\n-objc_mutex_deallocate(objc_mutex_t mutex)\n+__objc_mutex_lock(objc_mutex_t mutex)\n {\n-    int         depth;                          /* # of locks on mutex.     */\n-\n-    if (!mutex)                                 /* Is argument bad?         */\n-        return -1;                              /* Yes, abort.              */\n-    depth = objc_mutex_lock(mutex);             /* Must have lock.          */\n-    \n-    pthread_mutex_unlock(&mutex->lock);         /* Must unlock system mutex.*/\n-    pthread_mutex_destroy(&mutex->lock);        /* Free system mutex.       */\n-    \n-    objc_free(mutex);                           /* Free memory.             */\n-    return depth;                               /* Return last depth.       */\n+  return pthread_mutex_lock((pthread_mutex_t *)(&(mutex->backend)));\n }\n \n-/********\n- *  Grab a lock on a mutex.  If this thread already has a lock on this mutex\n- *  then we increment the lock count.  If another thread has a lock on the \n- *  mutex we block and wait for the thread to release the lock.\n- *  Returns the lock count on the mutex held by this thread.\n- */\n+/* Try to grab a lock on a mutex. */\n int\n-objc_mutex_lock(objc_mutex_t mutex)\n+__objc_mutex_trylock(objc_mutex_t mutex)\n {\n-    objc_thread_t     thread_id;                /* Cache our thread id. */\n-\n-    if (!mutex)                                 /* Is argument bad?         */\n-        return -1;                              /* Yes, abort.              */\n-    thread_id = objc_thread_id();               /* Get this thread's id.    */\n-    if (mutex->owner == thread_id)              /* Already own lock?        */\n-        return ++mutex->depth;                  /* Yes, increment depth.    */\n-\n-    if (pthread_mutex_lock(&mutex->lock) != 0)  /* Lock DCE system mutex.   */\n-        return -1;                              /* Failed, abort.           */\n-    \n-    mutex->owner = thread_id;                   /* Mark thread as owner.    */\n-    return mutex->depth = 1;                    /* Increment depth to end.  */\n+  return pthread_mutex_trylock((pthread_mutex_t *)(&(mutex->backend)));\n }\n \n-/********\n- *  Try to grab a lock on a mutex.  If this thread already has a lock on\n- *  this mutex then we increment the lock count and return it.  If another\n- *  thread has a lock on the mutex returns -1.\n- */\n+/* Unlock the mutex */\n int\n-objc_mutex_trylock(objc_mutex_t mutex)\n+__objc_mutex_unlock(objc_mutex_t mutex)\n {\n-    objc_thread_t    thread_id;                 /* Cache our thread id. */\n-\n-    if (!mutex)                                 /* Is argument bad?         */\n-        return -1;                              /* Yes, abort.              */\n-    thread_id = objc_thread_id();               /* Get this thread's id.    */\n-    if (mutex->owner == thread_id)              /* Already own lock?        */\n-        return ++mutex->depth;                  /* Yes, increment depth.    */\n-    \n-    if (pthread_mutex_trylock(&mutex->lock) != 1) /* Lock DCE system mutex. */\n-        return -1;                              /* Failed, abort.           */\n-    \n-    mutex->owner = thread_id;                   /* Mark thread as owner.    */\n-    return mutex->depth = 1;                    /* Increment depth to end.  */\n+  return pthread_mutex_unlock((pthread_mutex_t *)(&(mutex->backend)));\n }\n \n-/********\n- *  Decrements the lock count on this mutex by one.  If the lock count reaches\n- *  zero, release the lock on the mutex.  Returns the lock count on the mutex.\n- *  It is an error to attempt to unlock a mutex which this thread doesn't hold\n- *  in which case return -1 and the mutex is unaffected.\n- *  Will also return -1 if the mutex free fails.\n- */\n+/* Backend condition mutex functions */\n+\n+/* Allocate a condition. */\n int\n-objc_mutex_unlock(objc_mutex_t mutex)\n+__objc_condition_allocate(objc_condition_t condition)\n {\n-    objc_thread_t   thread_id;                 /* Cache our thread id.     */\n-    \n-    if (!mutex)                                 /* Is argument bad?         */\n-        return -1;                              /* Yes, abort.              */\n-    thread_id = objc_thread_id();               /* Get this thread's id.    */\n-    if (mutex->owner != thread_id)              /* Does some else own lock? */\n-        return -1;                              /* Yes, abort.              */\n-    if (mutex->depth > 1)                       /* Released last lock?      */\n-        return --mutex->depth;                  /* No, Decrement depth, end.*/\n-    mutex->depth = 0;                           /* Yes, reset depth to 0.   */\n-    mutex->owner = NULL;                        /* Set owner to \"no thread\".*/\n-    \n-    if (pthread_mutex_unlock(&mutex->lock) != 0)  /* Unlock system mutex.   */\n-        return -1;                              /* Failed, abort.           */\n-    \n-    return 0;                                   /* No, return success.      */\n+  if (pthread_cond_init((pthread_cond_t *)(&(condition->backend)), NULL))\n+    return -1;\n+  else\n+    return 0;\n }\n+\n+/* Deallocate a condition. */\n+int\n+__objc_condition_deallocate(objc_condition_t condition)\n+{\n+  return pthread_cond_destroy((pthread_cond_t *)(&(condition->backend)));\n+}\n+\n+/* Wait on the condition */\n+int\n+__objc_condition_wait(objc_condition_t condition, objc_mutex_t mutex)\n+{\n+  return pthread_cond_wait((pthread_cond_t *)(&(condition->backend)),\n+\t\t\t   (pthread_mutex_t *)(&(mutex->backend)));\n+}\n+\n+/* Wake up all threads waiting on this condition. */\n+int\n+__objc_condition_broadcast(objc_condition_t condition)\n+{\n+  return pthread_cond_broadcast((pthread_cond_t *)(&(condition->backend)));\n+}\n+\n+/* Wake up one thread waiting on this condition. */\n+int\n+__objc_condition_signal(objc_condition_t condition)\n+{\n+  return pthread_cond_signal((pthread_cond_t *)(&(condition->backend)));\n+}\n+\n+/* End of File */"}, {"sha": "4c4c2450aac43fbeb04ce40b870f5f9595ff9a8a", "filename": "gcc/objc/thr-pthreads.c", "status": "modified", "additions": 77, "deletions": 277, "changes": 354, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2024f9e4dc4746fc1f87a82ccd998d0c24f75d8c/gcc%2Fobjc%2Fthr-pthreads.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2024f9e4dc4746fc1f87a82ccd998d0c24f75d8c/gcc%2Fobjc%2Fthr-pthreads.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fthr-pthreads.c?ref=2024f9e4dc4746fc1f87a82ccd998d0c24f75d8c", "patch": "@@ -1,6 +1,7 @@\n /* GNU Objective C Runtime Thread Implementation for PCThreads under Linux.\n    Copyright (C) 1996, 1997 Free Software Foundation, Inc.\n    Contributed by Scott Christley <scottc@net-community.com>\n+   Condition functions added by: Mircea Oancea <mircea@first.elcom.pub.ro>\n \n This file is part of GNU CC.\n \n@@ -24,152 +25,103 @@ Boston, MA 02111-1307, USA.  */\n    however invalidate any other reasons why the executable file might be\n    covered by the GNU General Public License.  */\n \n-#include <pthread.h>\n+#include <pcthread.h>\n #include <objc/thr.h>\n #include \"runtime.h\"\n \n /* Key structure for maintiain thread specific storage */\n static pthread_key_t _objc_thread_storage;\n \n-/********\n- *  This structure represents a single mutual exclusion lock.  Lock semantics\n- *  are detailed with the subsequent functions.  We use whatever lock is\n- *  provided by the system.  We augment it with depth and current owner id\n- *  fields to implement and re-entrant lock.\n- */\n-struct objc_mutex \n-{\n-  volatile objc_thread_t     owner;          /* Id of thread that owns.  */\n-  volatile int                depth;          /* # of acquires.           */\n-  pthread_mutex_t             mutex;          /* PCThread mutex           */\n-};\n-\n-struct objc_condition \n-{\n-  pthread_cond_t              condition;      /* cthread condition        */\n-};\n+/* Backend initialization functions */\n \n-/********\n- *  Initialize the threads subsystem.  Returns 0 if successful, or -1 if no\n- *  thread support is available.\n- */\n+/* Initialize the threads subsystem. */\n int\n __objc_init_thread_system(void)\n {\n   /* Initialize the thread storage key */\n   return pthread_key_create(&_objc_thread_storage, NULL);\n }\n \n-/********\n- *  Finalize the threads subsystem.  Returns 0 if successful, or -1 if not\n- */\n+/* Close the threads subsystem. */\n int\n-__objc_fini_thread_system(void)\n+__objc_close_thread_system(void)\n {\n   /* Destroy the thread storage key */\n   /* Not implemented yet */\n   /* return pthread_key_delete(&_objc_thread_storage); */\n   return 0;\n }\n \n-/********\n- *  Create a new thread of execution and return its id.  Return NULL if fails.\n- *  The new thread starts in \"func\" with the given argument.\n- */\n+/* Backend thread functions */\n+\n+/* Create a new thread of execution. */\n objc_thread_t\n-objc_thread_create(void (*func)(void *arg), void *arg)\n+__objc_thread_detach(void (*func)(void *arg), void *arg)\n {\n   objc_thread_t thread_id;\n   pthread_t new_thread_handle;\n \n-  objc_mutex_lock(__objc_runtime_mutex);\n-  \n   if ( !(pthread_create(&new_thread_handle, NULL, (void *)func, arg)) )\n-    {\n       thread_id = *(objc_thread_t *)&new_thread_handle;\n-      __objc_runtime_threads_alive++;\n-    }\n   else\n     thread_id = NULL;\n   \n-  objc_mutex_unlock(__objc_runtime_mutex);\n-  \n   return thread_id;\n }\n \n-/********\n- *  Set the current thread's priority.\n- */\n+/* Set the current thread's priority. */\n int\n-objc_thread_set_priority(int priority)\n+__objc_thread_set_priority(int priority)\n {\n   /* Not implemented yet */\n-  return -1;                                   \t/* Failed.                  */\n+  return -1;\n }\n \n-/********\n- *  Return the current thread's priority.\n- */\n+/* Return the current thread's priority. */\n int\n-objc_thread_get_priority(void)\n+__objc_thread_get_priority(void)\n {\n   /* Not implemented yet */\n-  return OBJC_THREAD_INTERACTIVE_PRIORITY;      /* Highest priority.        */\n+  return OBJC_THREAD_INTERACTIVE_PRIORITY;\n }\n \n-/********\n- *  Yield our process time to another thread.  Any BUSY waiting that is done\n- *  by a thread should use this function to make sure that other threads can\n- *  make progress even on a lazy uniprocessor system.\n- */\n+/* Yield our process time to another thread. */\n void\n-objc_thread_yield(void)\n+__objc_thread_yield(void)\n {\n   pthread_yield(NULL);\n }\n \n-/********\n- *  Terminate the current tread.  Doesn't return anything.  Doesn't return.\n- *  Actually, if it failed returns -1.\n- */\n+/* Terminate the current thread. */\n int\n-objc_thread_exit(void)\n+__objc_thread_exit(void)\n {\n-  objc_mutex_lock(__objc_runtime_mutex);\n-  __objc_runtime_threads_alive--;\n-  objc_mutex_unlock(__objc_runtime_mutex);\n-      \n-  pthread_exit(&__objc_thread_exit_status);     /* Terminate thread.        */\n+  /* exit the thread */\n+  pthread_exit(&__objc_thread_exit_status);\n+\n+  /* Failed if we reached here */\n   return -1;\n }\n \n-/********\n- *  Returns an integer value which uniquely describes a thread.  Must not be\n- *  NULL which is reserved as a marker for \"no thread\".\n- */\n+/* Returns an integer value which uniquely describes a thread. */\n objc_thread_t\n-objc_thread_id(void)\n+__objc_thread_id(void)\n {\n   pthread_t self = pthread_self();\n \n-  return *(objc_thread_t *)&self;            /* Return thread handle.    */\n+  return *(objc_thread_t *)&self;\n }\n \n-/********\n- *  Sets the thread's local storage pointer.  Returns 0 if successful or -1\n- *  if failed.\n- */\n+/* Sets the thread's local storage pointer. */\n int\n-objc_thread_set_data(void *value)\n+__objc_thread_set_data(void *value)\n {\n   return pthread_setspecific(_objc_thread_storage, value);\n }\n \n-/********\n- *  Returns the thread's local storage pointer.  Returns NULL on failure.\n- */\n+/* Returns the thread's local storage pointer. */\n void *\n-objc_thread_get_data(void)\n+__objc_thread_get_data(void)\n {\n   void *value = NULL;\n \n@@ -179,240 +131,88 @@ objc_thread_get_data(void)\n   return NULL;\n }\n \n-/********\n- *  Allocate a mutex.  Return the mutex pointer if successful or NULL if the\n- *  allocation failed for any reason.\n- */\n-objc_mutex_t\n-objc_mutex_allocate(void)\n+/* Backend mutex functions */\n+\n+/* Allocate a mutex. */\n+int\n+__objc_mutex_allocate(objc_mutex_t mutex)\n {\n-  objc_mutex_t mutex;\n-    \n-  if (!(mutex = (objc_mutex_t)objc_malloc(sizeof(struct objc_mutex))))\n-    return NULL;                            /* Abort if malloc failed.  */\n-\n-  /* Create PCThread mutex */\n-  if ( pthread_mutex_init(&(mutex->mutex), NULL) )\n-    {\n-      /* Failed */\n-      objc_free(mutex);\n-      return NULL;\n-    }\n-\n-  mutex->owner = NULL;                        /* No owner.                */\n-  mutex->depth = 0;                           /* No locks.                */\n-  return mutex;                               /* Return mutex handle.     */\n+  if (pthread_mutex_init((pthread_mutex_t *)(&(mutex->backend)), NULL))\n+    return -1;\n+  else\n+    return 0;\n }\n \n-/********\n- *  Deallocate a mutex.  Note that this includes an implicit mutex_lock to\n- *  insure that no one else is using the lock.  It is legal to deallocate\n- *  a lock if we have a lock on it, but illegal to deallocate a lock held\n- *  by anyone else.\n- *  Returns the number of locks on the thread.  (1 for deallocate).\n- */\n+/* Deallocate a mutex. */\n int\n-objc_mutex_deallocate(objc_mutex_t mutex)\n+__objc_mutex_deallocate(objc_mutex_t mutex)\n {\n-  int         depth;                          /* # of locks on mutex.     */\n-\n-  if (!mutex)                                 /* Is argument bad?         */\n-    return -1;                              /* Yes, abort.              */\n-  depth = objc_mutex_lock(mutex);             /* Must have lock.          */\n-\n-  /* Destroy PCThread mutex */\n-  pthread_mutex_destroy(&(mutex->mutex));\n-\n-  objc_free(mutex);                           /* Free memory.             */\n-  return depth;                               /* Return last depth.       */\n+  if (pthread_mutex_destroy((pthread_mutex_t *)(&(mutex->backend))))\n+    return -1;\n+  else\n+    return 0;\n }\n \n-/********\n- *  Grab a lock on a mutex.  If this thread already has a lock on this mutex\n- *  then we increment the lock count.  If another thread has a lock on the \n- *  mutex we block and wait for the thread to release the lock.\n- *  Returns the lock count on the mutex held by this thread.\n- */\n+/* Grab a lock on a mutex. */\n int\n-objc_mutex_lock(objc_mutex_t mutex)\n+__objc_mutex_lock(objc_mutex_t mutex)\n {\n-  objc_thread_t      thread_id;              /* Cache our thread id.     */\n-  int status;\n-\n-  if (!mutex)                                 /* Is argument bad?         */\n-    return -1;                              /* Yes, abort.              */\n-  thread_id = objc_thread_id();               /* Get this thread's id.    */\n-  if (mutex->owner == thread_id)              /* Already own lock?        */\n-    {\n-      return ++mutex->depth;                  /* Yes, increment depth.    */\n-    }\n-\n-  /* Lock the PCThread mutex */\n-  status = pthread_mutex_lock(&(mutex->mutex));\n-  if (status)\n-    {\n-      return status;                            /* Failed */\n-    }\n-\n-  mutex->owner = thread_id;                   /* Mark thread as owner.    */\n-  return mutex->depth = 1;                    /* Increment depth to end.  */\n+  return pthread_mutex_lock((pthread_mutex_t *)(&(mutex->backend)));\n }\n \n-/********\n- *  Try to grab a lock on a mutex.  If this thread already has a lock on\n- *  this mutex then we increment the lock count and return it.  If another\n- *  thread has a lock on the mutex returns -1.\n- */\n+/* Try to grab a lock on a mutex. */\n int\n-objc_mutex_trylock(objc_mutex_t mutex)\n+__objc_mutex_trylock(objc_mutex_t mutex)\n {\n-  objc_thread_t      thread_id;              /* Cache our thread id.     */\n-  int status;\n-\n-  if (!mutex)                                 /* Is argument bad?         */\n-    return -1;                              /* Yes, abort.              */\n-  thread_id = objc_thread_id();               /* Get this thread's id.    */\n-  if (mutex->owner == thread_id)              /* Already own lock?        */\n-    return ++mutex->depth;                  /* Yes, increment depth.    */\n-    \n-  /* Lock the PCThread mutex */\n-  status = pthread_mutex_trylock(&(mutex->mutex));\n-  if (status)\n-    return status;                            /* Failed */\n-\n-  mutex->owner = thread_id;                   /* Mark thread as owner.    */\n-  return mutex->depth = 1;                    /* Increment depth to end.  */\n+  return pthread_mutex_trylock((pthread_mutex_t *)(&(mutex->backend)));\n }\n \n-/********\n- *  Decrements the lock count on this mutex by one.  If the lock count reaches\n- *  zero, release the lock on the mutex.  Returns the lock count on the mutex.\n- *  It is an error to attempt to unlock a mutex which this thread doesn't hold\n- *  in which case return -1 and the mutex is unaffected.\n- *  Will also return -1 if the mutex free fails.\n- */\n+/* Unlock the mutex */\n int\n-objc_mutex_unlock(objc_mutex_t mutex)\n+__objc_mutex_unlock(objc_mutex_t mutex)\n {\n-  objc_thread_t thread_id;                   /* Cache our thread id.     */\n-  int status;\n-    \n-  if (!mutex)                                 /* Is argument bad?         */\n-    return -1;                              /* Yes, abort.              */\n-  thread_id = objc_thread_id();               /* Get this thread's id.    */\n-  if (mutex->owner != thread_id)              /* Does some else own lock? */\n-    return -1;                              /* Yes, abort.              */\n-  if (mutex->depth > 1)                       /* Released last lock?      */\n-    return --mutex->depth;                  /* No, Decrement depth, end.*/\n-  mutex->depth = 0;                           /* Yes, reset depth to 0.   */\n-  mutex->owner = NULL;                        /* Set owner to \"no thread\".*/\n-\n-  /* Unlock the PCThread mutex */\n-  status = pthread_mutex_unlock(&(mutex->mutex));\n-  if (status)\n-    return status;                            /* Failed */\n-\n-  return 0;                                   /* No, return success.      */\n+  return pthread_mutex_unlock((pthread_mutex_t *)(&(mutex->backend)));\n }\n \n-/********\n- *  Allocate a condition.  Return the condition pointer if successful or NULL\n- * if the allocation failed for any reason.\n- */\n-objc_condition_t \n-objc_condition_allocate(void)\n+/* Backend condition mutex functions */\n+\n+/* Allocate a condition. */\n+int\n+__objc_condition_allocate(objc_condition_t condition)\n {\n-    objc_condition_t condition;\n-    \n-    if (!(condition = (objc_condition_t)objc_malloc(\n-                        sizeof(struct objc_condition))))\n-        return NULL;                            /* Abort if malloc failed.  */\n-\n-  \tif ( pthread_cond_init(&(condition->condition), NULL) ) {\n-\t\tobjc_free(condition);\n-\t\treturn NULL;\n-\t}\n-    \n-    return condition;                           /* Return condition handle. */\n+  if (pthread_cond_init((pthread_cond_t *)(&(condition->backend)), NULL))\n+    return -1;\n+  else\n+    return 0;\n }\n \n-/********\n- *  Deallocate a condition. Note that this includes an implicit \n- *  condition_broadcast to insure that waiting threads have the opportunity\n- *  to wake.  It is legal to dealloc a condition only if no other\n- *  thread is/will be using it. Here we do NOT check for other threads\n- *  waiting but just wake them up.\n- */\n+/* Deallocate a condition. */\n int\n-objc_condition_deallocate(objc_condition_t condition)\n+__objc_condition_deallocate(objc_condition_t condition)\n {\n-\tpthread_cond_broadcast(&(condition->condition));\n-\tpthread_cond_destroy(&(condition->condition));\n-\tobjc_free(condition);\n-\treturn 0;\n+  return pthread_cond_destroy((pthread_cond_t *)(&(condition->backend)));\n }\n \n-/********\n- *  Wait on the condition unlocking the mutex until objc_condition_signal()\n- *  or objc_condition_broadcast() are called for the same condition. The\n- *  given mutex *must* have the depth set to 1 so that it can be unlocked\n- *  here, so that someone else can lock it and signal/broadcast the condition.\n- *  The mutex is used to lock access to the shared data that make up the\n- *  \"condition\" predicate.\n- */\n+/* Wait on the condition */\n int\n-objc_condition_wait(objc_condition_t condition, objc_mutex_t mutex)\n+__objc_condition_wait(objc_condition_t condition, objc_mutex_t mutex)\n {\n-    objc_thread_t    thread_id;                /* Cache our thread id.     */\n-    \n-    if (!mutex || !condition)                   /* Is argument bad?         */\n-        return -1;                              /* Yes, abort.              */\n-\n-    thread_id = objc_thread_id();               /* Get this thread's id.    */\n-    if (mutex->owner != thread_id)              /* Does some else own lock? */\n-        return -1;                              /* Yes, abort.              */\n-    if (mutex->depth > 1)                       /* Locked more than once ?  */\n-        return -1;                              /* YES, return error        */\n-                                                /* mutex will be unlocked   */\n-    mutex->depth = 0;                           /* Yes, reset depth to 0.   */\n-    mutex->owner = (objc_thread_t) -1;         /* Set owner to \"no thread\".*/\n-    \n-    pthread_cond_wait(&(condition->condition),\n-\t\t&(mutex->mutex));               /* unlock, wait ..., lock   */\n-    \n-    mutex->owner = thread_id;                   /* Mark thread as owner.    */\n-    mutex->depth = 1;                           /* Increment depth to end.  */\n-    return 0;                                   /* Return success.          */\n+  return pthread_cond_wait((pthread_cond_t *)(&(condition->backend)),\n+\t\t\t   (pthread_mutex_t *)(&(mutex->backend)));\n }\n \n-/********\n- *  Wake up all threads waiting on this condition. It is recommended that \n- *  the called would lock the same mutex as the threads in objc_condition_wait\n- *  before changing the \"condition predicate\" and make this call and unlock it\n- *  right away after this call.\n- */\n+/* Wake up all threads waiting on this condition. */\n int\n-objc_condition_broadcast(objc_condition_t condition)\n+__objc_condition_broadcast(objc_condition_t condition)\n {\n-    if (!condition)\n-\t\treturn -1;\n-\tpthread_cond_broadcast(&(condition->condition));\n-\treturn 0;\n+  return pthread_cond_broadcast((pthread_cond_t *)(&(condition->backend)));\n }\n \n-/********\n- *  Wake up one thread waiting on this condition. It is recommended that \n- *  the called would lock the same mutex as the threads in objc_condition_wait\n- *  before changing the \"condition predicate\" and make this call and unlock it\n- *  right away after this call.\n- */\n+/* Wake up one thread waiting on this condition. */\n int\n-objc_condition_signal(objc_condition_t condition)\n+__objc_condition_signal(objc_condition_t condition)\n {\n-    if (!condition)\n-\t\treturn -1;\n-\tpthread_cond_signal(&(condition->condition));\n-\treturn 0;\n+  return pthread_cond_signal((pthread_cond_t *)(&(condition->backend)));\n }\n \n /* End of File */"}, {"sha": "b196677c6b696d79e4fe7f98018d7d79bee4c75e", "filename": "gcc/objc/thr-single.c", "status": "modified", "additions": 118, "deletions": 166, "changes": 284, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2024f9e4dc4746fc1f87a82ccd998d0c24f75d8c/gcc%2Fobjc%2Fthr-single.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2024f9e4dc4746fc1f87a82ccd998d0c24f75d8c/gcc%2Fobjc%2Fthr-single.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fthr-single.c?ref=2024f9e4dc4746fc1f87a82ccd998d0c24f75d8c", "patch": "@@ -27,214 +27,166 @@ Boston, MA 02111-1307, USA.  */\n #include <objc/thr.h>\n #include \"runtime.h\"\n \n-/********\n- *  This structure represents a single mutual exclusion lock.  Lock semantics\n- *  are detailed with the subsequent functions.  We use whatever lock is\n- *  provided by the system.  We augment it with depth and current owner id\n- *  fields to implement and re-entrant lock.\n- */\n-struct objc_mutex \n-{\n-    volatile objc_thread_t     owner;          /* Id of thread that owns.  */\n-    volatile int                depth;          /* # of acquires.           */\n-};\n-\n-/********\n- *  Initialize the threads subsystem.  Returns 0 if successful, or -1 if no\n- *  thread support is available.\n- */\n+/* Thread local storage for a single thread */\n+static void *thread_local_storage = NULL;\n+\n+/* Backend initialization functions */\n+\n+/* Initialize the threads subsystem. */\n int\n __objc_init_thread_system(void)\n {\n-  DEBUG_PRINTF(\"__objc_init_thread_system\\n\");\n-  return -1;                                  \t/* Failed.                  */\n+  /* No thread support available */\n+  return -1;\n+}\n+\n+/* Close the threads subsystem. */\n+int\n+__objc_close_thread_system(void)\n+{\n+  /* No thread support available */\n+  return -1;\n }\n \n-/********\n- *  Create a new thread of execution and return its id.  Return NULL if fails.\n- *  The new thread starts in \"func\" with the given argument.\n- */\n+/* Backend thread functions */\n+\n+/* Create a new thread of execution. */\n objc_thread_t\n-objc_thread_create(void (*func)(void *arg), void *arg)\n+__objc_thread_detach(void (*func)(void *arg), void *arg)\n {\n-  return NULL;\t\t\t\t   \t/* We can't start threads.  */\n+  /* No thread support available */\n+  return NULL;\n }\n \n-/********\n- *  Set the current thread's priority.\n- */\n+/* Set the current thread's priority. */\n int\n-objc_thread_set_priority(int priority)\n+__objc_thread_set_priority(int priority)\n {\n-  return -1;                                   \t/* Failed.                  */\n+  /* No thread support available */\n+  return -1;\n }\n \n-/********\n- *  Return the current thread's priority.\n- */\n+/* Return the current thread's priority. */\n int\n-objc_thread_get_priority(void)\n+__objc_thread_get_priority(void)\n {\n-  return OBJC_THREAD_INTERACTIVE_PRIORITY;      /* Highest priority.        */\n+  return OBJC_THREAD_INTERACTIVE_PRIORITY;\n }\n \n-/********\n- *  Yield our process time to another thread.  Any BUSY waiting that is done\n- *  by a thread should use this function to make sure that other threads can\n- *  make progress even on a lazy uniprocessor system.\n- */\n+/* Yield our process time to another thread. */\n void\n-objc_thread_yield(void)\n+__objc_thread_yield(void)\n {\n   return;\n }\n \n-/********\n- *  Terminate the current tread.  Doesn't return anything.  Doesn't return.\n- *  Actually, if it failed returns -1.\n- */\n+/* Terminate the current thread. */\n int\n-objc_thread_exit(void)\n+__objc_thread_exit(void)\n {\n-  exit(__objc_thread_exit_status);\n+  /* No thread support available */\n+  /* Should we really exit the program */\n+  /* exit(&__objc_thread_exit_status); */\n   return -1;\n }\n \n-/********\n- *  Returns an integer value which uniquely describes a thread.  Must not be\n- *  NULL which is reserved as a marker for \"no thread\".\n- */\n+/* Returns an integer value which uniquely describes a thread. */\n objc_thread_t\n-objc_thread_id(void)\n+__objc_thread_id(void)\n {\n-  return (objc_thread_t)1;                     /* No thread support, use 1.*/\n+  /* No thread support, use 1. */\n+  return (objc_thread_t)1;\n }\n \n-/********\n- *  Sets the thread's local storage pointer.  Returns 0 if successful or -1\n- *  if failed.\n- */\n-\n-static void *thread_local_storage = NULL;\n-\n+/* Sets the thread's local storage pointer. */\n int\n-objc_thread_set_data(void *value)\n+__objc_thread_set_data(void *value)\n {\n   thread_local_storage = value;\n   return 0;\n }\n \n-/********\n- *  Returns the thread's local storage pointer.  Returns NULL on failure.\n- */\n+/* Returns the thread's local storage pointer. */\n void *\n-objc_thread_get_data(void)\n+__objc_thread_get_data(void)\n {\n   return thread_local_storage;\n }\n \n-/********\n- *  Allocate a mutex.  Return the mutex pointer if successful or NULL if the\n- *  allocation failed for any reason.\n- */\n-objc_mutex_t\n-objc_mutex_allocate(void)\n-{\n-    objc_mutex_t mutex;\n-    \n-    if (!(mutex = (objc_mutex_t)objc_malloc(sizeof(struct objc_mutex))))\n-        return NULL;                            /* Abort if malloc failed.  */\n-    \n-    mutex->owner = NULL;                        /* No owner.                */\n-    mutex->depth = 0;                           /* No locks.                */\n-    return mutex;                               /* Return mutex handle.     */\n-}\n-\n-/********\n- *  Deallocate a mutex.  Note that this includes an implicit mutex_lock to\n- *  insure that no one else is using the lock.  It is legal to deallocate\n- *  a lock if we have a lock on it, but illegal to deallocate a lock held\n- *  by anyone else.\n- *  Returns the number of locks on the thread.  (1 for deallocate).\n- */\n-int\n-objc_mutex_deallocate(objc_mutex_t mutex)\n-{\n-    int         depth;                          /* # of locks on mutex.     */\n-\n-    if (!mutex)                                 /* Is argument bad?         */\n-        return -1;                              /* Yes, abort.              */\n-    depth = objc_mutex_lock(mutex);             /* Must have lock.          */\n-    \n-    objc_free(mutex);                           /* Free memory.             */\n-    return depth;                               /* Return last depth.       */\n-}\n-\n-/********\n- *  Grab a lock on a mutex.  If this thread already has a lock on this mutex\n- *  then we increment the lock count.  If another thread has a lock on the \n- *  mutex we block and wait for the thread to release the lock.\n- *  Returns the lock count on the mutex held by this thread.\n- */\n-int\n-objc_mutex_lock(objc_mutex_t mutex)\n-{\n-    objc_thread_t      thread_id;              /* Cache our thread id.     */\n-\n-    if (!mutex)                                 /* Is argument bad?         */\n-        return -1;                              /* Yes, abort.              */\n-    thread_id = objc_thread_id();               /* Get this thread's id.    */\n-    if (mutex->owner == thread_id)              /* Already own lock?        */\n-        return ++mutex->depth;                  /* Yes, increment depth.    */\n-\n-    mutex->owner = thread_id;                   /* Mark thread as owner.    */\n-\n-    return mutex->depth = 1;                    /* Increment depth to end.  */\n-}\n-\n-/********\n- *  Try to grab a lock on a mutex.  If this thread already has a lock on\n- *  this mutex then we increment the lock count and return it.  If another\n- *  thread has a lock on the mutex returns -1.\n- */\n-int\n-objc_mutex_trylock(objc_mutex_t mutex)\n-{\n-    objc_thread_t      thread_id;              /* Cache our thread id.     */\n-\n-    if (!mutex)                                 /* Is argument bad?         */\n-        return -1;                              /* Yes, abort.              */\n-    thread_id = objc_thread_id();               /* Get this thread's id.    */\n-    if (mutex->owner == thread_id)              /* Already own lock?        */\n-        return ++mutex->depth;                  /* Yes, increment depth.    */\n-    \n-    mutex->owner = thread_id;                   /* Mark thread as owner.    */\n-    return mutex->depth = 1;                    /* Increment depth to end.  */\n-}\n-\n-/********\n- *  Decrements the lock count on this mutex by one.  If the lock count reaches\n- *  zero, release the lock on the mutex.  Returns the lock count on the mutex.\n- *  It is an error to attempt to unlock a mutex which this thread doesn't hold\n- *  in which case return -1 and the mutex is unaffected.\n- *  Will also return -1 if the mutex free fails.\n- */\n-int\n-objc_mutex_unlock(objc_mutex_t mutex)\n-{\n-    objc_thread_t  thread_id;\t\t\t/* Cache our thread id.     */\n-    \n-    if (!mutex)                                 /* Is argument bad?         */\n-        return -1;                              /* Yes, abort.              */\n-    thread_id = objc_thread_id();               /* Get this thread's id.    */\n-    if (mutex->owner != thread_id)              /* Does some else own lock? */\n-        return -1;                              /* Yes, abort.              */\n-    if (mutex->depth > 1)                       /* Released last lock?      */\n-        return --mutex->depth;                  /* No, Decrement depth, end.*/\n-    mutex->depth = 0;                           /* Yes, reset depth to 0.   */\n-    mutex->owner = NULL;                        /* Set owner to \"no thread\".*/\n-    \n-    return 0;                                   /* No, return success.      */\n+/* Backend mutex functions */\n+\n+/* Allocate a mutex. */\n+int\n+__objc_mutex_allocate(objc_mutex_t mutex)\n+{\n+  return 0;\n+}\n+\n+/* Deallocate a mutex. */\n+int\n+__objc_mutex_deallocate(objc_mutex_t mutex)\n+{\n+  return 0;\n+}\n+\n+/* Grab a lock on a mutex. */\n+int\n+__objc_mutex_lock(objc_mutex_t mutex)\n+{\n+  /* There can only be one thread, so we always get the lock */\n+  return 0;\n+}\n+\n+/* Try to grab a lock on a mutex. */\n+int\n+__objc_mutex_trylock(objc_mutex_t mutex)\n+{\n+  /* There can only be one thread, so we always get the lock */\n+  return 0;\n+}\n+\n+/* Unlock the mutex */\n+int\n+__objc_mutex_unlock(objc_mutex_t mutex)\n+{\n+  return 0;\n+}\n+\n+/* Backend condition mutex functions */\n+\n+/* Allocate a condition. */\n+int\n+__objc_condition_allocate(objc_condition_t condition)\n+{\n+  return 0;\n+}\n+\n+/* Deallocate a condition. */\n+int\n+__objc_condition_deallocate(objc_condition_t condition)\n+{\n+  return 0;\n+}\n+\n+/* Wait on the condition */\n+int\n+__objc_condition_wait(objc_condition_t condition, objc_mutex_t mutex)\n+{\n+  return 0;\n+}\n+\n+/* Wake up all threads waiting on this condition. */\n+int\n+__objc_condition_broadcast(objc_condition_t condition)\n+{\n+  return 0;\n+}\n+\n+/* Wake up one thread waiting on this condition. */\n+int\n+__objc_condition_signal(objc_condition_t condition)\n+{\n+  return 0;\n }\n \n /* End of File */"}, {"sha": "0b5227a8e89b02358c114dd7c126e9a66c84f52b", "filename": "gcc/objc/thr-solaris.c", "status": "modified", "additions": 128, "deletions": 300, "changes": 428, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2024f9e4dc4746fc1f87a82ccd998d0c24f75d8c/gcc%2Fobjc%2Fthr-solaris.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2024f9e4dc4746fc1f87a82ccd998d0c24f75d8c/gcc%2Fobjc%2Fthr-solaris.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fthr-solaris.c?ref=2024f9e4dc4746fc1f87a82ccd998d0c24f75d8c", "patch": "@@ -32,400 +32,228 @@ Boston, MA 02111-1307, USA.  */\n #include <synch.h>\n #include <errno.h>\n \n-/********\n- *  This structure represents a single mutual exclusion lock.  Lock semantics\n- *  are detailed with the subsequent functions.  We use whatever lock is\n- *  provided by the system.  We augment it with depth and current owner id\n- *  fields to implement and re-entrant lock.\n- */\n-struct objc_mutex \n-{\n-    volatile objc_thread_t     owner;          /* Id of thread that owns.  */\n-    volatile int                depth;          /* # of acquires.           */\n-    mutex_t                     lock;           /* System mutex.            */\n-};\n+/* Key structure for maintiain thread specific storage */\n+static thread_key_t     __objc_thread_data_key;\n \n-struct objc_condition\n-{\n-    cond_t                     condition;      /* solaris condition        */\n-};\n-\n-/*****************************************************************************\n- *  Static variables.\n- */\n-static thread_key_t     __objc_thread_data_key; /* Data key for thread data.*/\n-\n-/********\n- *  Initialize the threads subsystem.  Returns 0 if successful, or -1 if no\n- *  thread support is available.\n- */\n+/* Backend initialization functions */\n+\n+/* Initialize the threads subsystem. */\n int\n __objc_init_thread_system(void)\n {\n-    DEBUG_PRINTF(\"__objc_init_thread_system\\n\");\n-\n-    if (thr_keycreate(&__objc_thread_data_key, NULL) == 0)\n-        return 0;                               /* Yes, return success.     */\n-    \n-    return -1;                                  /* Failed.                  */\n+  /* Initialize the thread storage key */\n+  if (thr_keycreate(&__objc_thread_data_key, NULL) == 0)\n+    return 0;\n+  else\n+    return -1;\n }\n \n+/* Close the threads subsystem. */\n int\n-__objc_fini_thread_system(void)\n+__objc_close_thread_system(void)\n {\n   return 0;\n }\n \n-/********\n- *  Create a new thread of execution and return its id.  Return -1 if fails.\n- *  The new thread starts in \"func\" with the given argument.\n- */\n+/* Backend thread functions */\n+\n+/* Create a new thread of execution. */\n objc_thread_t\n-objc_thread_create(void (*func)(void *arg), void *arg)\n+__objc_thread_detach(void (*func)(void *arg), void *arg)\n {\n-  objc_thread_t        thread_id = NULL;       /* Detached thread id.      */\n-  thread_t              new_thread_id = 0;      /* Solaris thread id type.  */\n-  int                   errn;\n-\n-  objc_mutex_lock(__objc_runtime_mutex);\n+  objc_thread_t thread_id;\n+  thread_t new_thread_id = 0;\n \n   if (thr_create(NULL, 0, (void *)func, arg,\n                  THR_DETACHED | THR_NEW_LWP,\n-                 &new_thread_id) == 0) {    \t/* Created new thread?      */\n-    thread_id = (objc_thread_t)new_thread_id;  /* Yes, remember its id.    */\n-    __objc_runtime_threads_alive++;\n-  }\n+                 &new_thread_id) == 0)\n+    thread_id = *(objc_thread_t *)&new_thread_id;\n+  else\n+    thread_id = NULL;\n   \n-  objc_mutex_unlock(__objc_runtime_mutex);\n-    \n   return thread_id;\n }\n \n-/********\n- *  Set the current thread's priority.\n- */\n+/* Set the current thread's priority. */\n int\n-objc_thread_set_priority(int priority)\n+__objc_thread_set_priority(int priority)\n {\n-    int         sys_priority = 0;\n+  int sys_priority = 0;\n \n-    switch (priority) {\n+  switch (priority)\n+    {\n     case OBJC_THREAD_INTERACTIVE_PRIORITY:\n-        sys_priority = 300;\n-        break;\n+      sys_priority = 300;\n+      break;\n     default:\n     case OBJC_THREAD_BACKGROUND_PRIORITY:\n-        sys_priority = 200;\n-        break;\n+      sys_priority = 200;\n+      break;\n     case OBJC_THREAD_LOW_PRIORITY:\n-        sys_priority = 1000;\n-        break;\n+      sys_priority = 1000;\n+      break;\n     }\n-    \n-    if (thr_setprio(thr_self(), sys_priority) == 0)\n-        return 0;                               /* Changed priority. End.   */\n-    \n-    return -1;                                  /* Failed.                  */\n+\n+  /* Change priority */\n+  if (thr_setprio(thr_self(), sys_priority) == 0)\n+    return 0;\n+  else\n+    return -1;\n }\n \n-/********\n- *  Return the current thread's priority.\n- */\n+/* Return the current thread's priority. */\n int\n-objc_thread_get_priority(void)\n+__objc_thread_get_priority(void)\n {\n-    int         sys_priority;                   /* Solaris thread priority. */\n+  int sys_priority;\n                                                    \n-    if (thr_getprio(thr_self(), &sys_priority) == 0) {\n-        if (sys_priority >= 250)\n-            return OBJC_THREAD_INTERACTIVE_PRIORITY;\n-        else if (sys_priority >= 150)\n-            return OBJC_THREAD_BACKGROUND_PRIORITY;\n-        return OBJC_THREAD_LOW_PRIORITY;\n+  if (thr_getprio(thr_self(), &sys_priority) == 0)\n+    {\n+      if (sys_priority >= 250)\n+\treturn OBJC_THREAD_INTERACTIVE_PRIORITY;\n+      else if (sys_priority >= 150)\n+\treturn OBJC_THREAD_BACKGROUND_PRIORITY;\n+      return OBJC_THREAD_LOW_PRIORITY;\n     }\n-    \n-    return -1;                                  /* Couldn't get priority.   */\n+\n+  /* Couldn't get priority. */\n+  return -1;\n }\n \n-/********\n- *  Yield our process time to another thread.  Any BUSY waiting that is done\n- *  by a thread should use this function to make sure that other threads can\n- *  make progress even on a lazy uniprocessor system.\n- */\n+/* Yield our process time to another thread. */\n void\n-objc_thread_yield(void)\n+__objc_thread_yield(void)\n {\n-    thr_yield();                                /* Yield to equal thread.   */\n+  thr_yield();\n }\n \n-/********\n- *  Terminate the current tread.  Doesn't return anything.  Doesn't return.\n- *  Actually, if it failed returns -1.\n- */\n+/* Terminate the current thread. */\n int\n-objc_thread_exit(void)\n+__objc_thread_exit(void)\n {\n-  objc_mutex_lock(__objc_runtime_mutex);\n-  __objc_runtime_threads_alive++;\n-  objc_mutex_unlock(__objc_runtime_mutex);\n-  \n-  thr_exit(&__objc_thread_exit_status);         /* Terminate thread.        */\n+  /* exit the thread */\n+  thr_exit(&__objc_thread_exit_status);\n+\n+  /* Failed if we reached here */\n   return -1;\n }\n \n-/********\n- *  Returns an integer value which uniquely describes a thread.  Must not be\n- *  NULL which is reserved as a marker for \"no thread\".\n- */\n+/* Returns an integer value which uniquely describes a thread. */\n objc_thread_t\n-objc_thread_id(void)\n+__objc_thread_id(void)\n {\n-    return (objc_thread_t)thr_self();\n+  return (objc_thread_t)thr_self();\n }\n \n-/********\n- *  Sets the thread's local storage pointer.  Returns 0 if successful or -1\n- *  if failed.\n- */\n+/* Sets the thread's local storage pointer. */\n int\n-objc_thread_set_data(void *value)\n+__objc_thread_set_data(void *value)\n {\n-    if (thr_setspecific(__objc_thread_data_key, value) == 0)\n-        return 0;\n+  if (thr_setspecific(__objc_thread_data_key, value) == 0)\n+    return 0;\n+  else\n     return -1;\n }\n \n-/********\n- *  Returns the thread's local storage pointer.  Returns NULL on failure.\n- */\n+/* Returns the thread's local storage pointer. */\n void *\n-objc_thread_get_data(void)\n+__objc_thread_get_data(void)\n {\n-    void *      value = NULL;\n-    \n-    if (thr_getspecific(__objc_thread_data_key, &value) == 0)\n-        return value;                           /* Return thread data.      */\n-    \n-    return NULL;\n-}\n+  void *value = NULL;\n \n-/********\n- *  Allocate a mutex.  Return the mutex pointer if successful or NULL if\n- *  the allocation fails for any reason.\n- */\n-objc_mutex_t\n-objc_mutex_allocate(void)\n-{\n-    struct objc_mutex *mutex;\n-    int         err = 0;\n-    \n-    if (!(mutex = (objc_mutex_t)objc_malloc(sizeof(struct objc_mutex))))\n-        return NULL;                            /* Abort if malloc failed.  */\n-    \n-    err = mutex_init(&mutex->lock, USYNC_THREAD, 0);\n-    \n-    if (err != 0) {                             /* System init failed?      */\n-        objc_free(mutex);                       /* Yes, free local memory.  */\n-        return NULL;                            /* Abort.                   */\n-    }\n-    mutex->owner = NULL;                        /* No owner.                */\n-    mutex->depth = 0;                           /* No locks.                */\n-    return mutex;                               /* Return mutex handle.     */\n+  if (thr_getspecific(__objc_thread_data_key, &value) == 0)\n+    return value;\n+\n+  return NULL;\n }\n \n-/********\n- *  Deallocate a mutex.  Note that this includes an implicit mutex_lock to\n- *  insure that no one else is using the lock.  It is legal to deallocate\n- *  a lock if we have a lock on it, but illegal to deallotcate a lock held\n- *  by anyone else.\n- *  Returns the number of locks on the thread.  (1 for deallocate).\n- */\n+/* Backend mutex functions */\n+\n+/* Allocate a mutex. */\n int\n-objc_mutex_deallocate(objc_mutex_t mutex)\n+__objc_mutex_allocate(objc_mutex_t mutex)\n {\n-    int         depth;                          /* # of locks on mutex.     */\n-\n-    if (!mutex)                                 /* Is argument bad?         */\n-        return -1;                              /* Yes, abort.              */\n-    depth = objc_mutex_lock(mutex);             /* Must have lock.          */\n-    \n-    mutex_destroy(&mutex->lock);                /* System deallocate.       */\n-    \n-    objc_free(mutex);                           /* Free memory.             */\n-    return depth;                               /* Return last depth.       */\n+  if (mutex_init( (mutex_t *)(&(mutex->backend)), USYNC_THREAD, 0))\n+    return -1;\n+  else\n+    return 0;\n }\n \n-/********\n- *  Grab a lock on a mutex.  If this thread already has a lock on this mutex\n- *  then we increment the lock count.  If another thread has a lock on the \n- *  mutex we block and wait for the thread to release the lock.\n- *  Returns the lock count on the mutex held by this thread.\n- */\n+\n+/* Deallocate a mutex. */\n int\n-objc_mutex_lock(objc_mutex_t mutex)\n+__objc_mutex_deallocate(objc_mutex_t mutex)\n {\n-    objc_thread_t      thread_id;              /* Cache our thread id.     */\n-\n-    if (!mutex)                                 /* Is argument bad?         */\n-        return -1;                              /* Yes, abort.              */\n-    thread_id = objc_thread_id();               /* Get this thread's id.    */\n-    if (mutex->owner == thread_id)              /* Already own lock?        */\n-        return ++mutex->depth;                  /* Yes, increment depth.    */\n-\n-    if (mutex_lock(&mutex->lock) != 0)          /* Did lock acquire fail?   */\n-        return -1;                              /* Yes, abort.              */\n-    \n-    mutex->owner = thread_id;                   /* Mark thread as owner.    */\n-    return mutex->depth = 1;                    /* Increment depth to end.  */\n+  mutex_destroy((mutex_t *)(&(mutex->backend)));\n+  return 0;\n }\n \n-/********\n- *  Try to grab a lock on a mutex.  If this thread already has a lock on\n- *  this mutex then we increment the lock count and return it.  If another\n- *  thread has a lock on the mutex returns -1.\n- */\n+/* Grab a lock on a mutex. */\n int\n-objc_mutex_trylock(objc_mutex_t mutex)\n+__objc_mutex_lock(objc_mutex_t mutex)\n {\n-    objc_thread_t      thread_id;              /* Cache our thread id.     */\n-\n-    if (!mutex)                                 /* Is argument bad?         */\n-        return -1;                              /* Yes, abort.              */\n-    thread_id = objc_thread_id();               /* Get this thread's id.    */\n-    if (mutex->owner == thread_id)              /* Already own lock?        */\n-        return ++mutex->depth;                  /* Yes, increment depth.    */\n-    \n-    if (mutex_trylock(&mutex->lock) != 0)       /* Did lock acquire fail?   */\n-        return -1;                              /* Yes, abort.              */\n-    \n-    mutex->owner = thread_id;                   /* Mark thread as owner.    */\n-    return mutex->depth = 1;                    /* Increment depth to end.  */\n+  if (mutex_lock((mutex_t *)(&(mutex->backend))) != 0)\n+    return -1;\n+  else\n+    return 0;\n }\n \n-/********\n- *  Decrements the lock count on this mutex by one.  If the lock count reaches\n- *  zero, release the lock on the mutex.  Returns the lock count on the mutex.\n- *  It is an error to attempt to unlock a mutex which this thread doesn't hold\n- *  in which case return -1 and the mutex is unaffected.\n- *  Will also return -1 if the mutex free fails.\n- */\n+/* Try to grab a lock on a mutex. */\n int\n-objc_mutex_unlock(objc_mutex_t mutex)\n+__objc_mutex_trylock(objc_mutex_t mutex)\n {\n-    objc_thread_t      thread_id;              /* Cache our thread id.     */\n-    \n-    if (!mutex)                                 /* Is argument bad?         */\n-        return -1;                              /* Yes, abort.              */\n-    thread_id = objc_thread_id();               /* Get this thread's id.    */\n-    if (mutex->owner != thread_id)              /* Does some else own lock? */\n-        return -1;                              /* Yes, abort.              */\n-    if (mutex->depth > 1)                       /* Released last lock?      */\n-        return --mutex->depth;                  /* No, Decrement depth, end.*/\n-    mutex->depth = 0;                           /* Yes, reset depth to 0.   */\n-    mutex->owner = NULL;                        /* Set owner to \"no thread\".*/\n-    \n-    if (mutex_unlock(&mutex->lock) != 0)        /* Did lock release fail?   */\n-        return -1;                              /* Yes, return error value. */\n-    \n-    return 0;                                   /* No, return success.      */\n+  if (mutex_trylock((mutex_t *)(&(mutex->backend))) != 0)\n+    return -1;\n+  else\n+    return 0;\n }\n \n-/********\n- *  Allocate a condition.  Return the condition pointer if successful or NULL\n- * if the allocation failed for any reason.\n- */\n-objc_condition_t\n-objc_condition_allocate(void)\n+/* Unlock the mutex */\n+int\n+__objc_mutex_unlock(objc_mutex_t mutex)\n {\n-    objc_condition_t condition;\n-\n-    if (!(condition = (objc_condition_t)objc_malloc(\n-                        sizeof(struct objc_condition))))\n-        return NULL;                            /* Abort if malloc failed.  */\n+  if (mutex_unlock((mutex_t *)(&(mutex->backend))) != 0)\n+    return -1;\n+  else\n+    return 0;\n+}\n \n-    cond_init(&(condition->condition), USYNC_THREAD, NULL);\n+/* Backend condition mutex functions */\n \n-    return condition;                           /* Return new condition     */\n+/* Allocate a condition. */\n+int\n+__objc_condition_allocate(objc_condition_t condition)\n+{\n+  return cond_init((cond_t *)(&(condition->backend)), USYNC_THREAD, NULL);\n }\n \n-/********\n- *  Deallocate a condition. Note that this includes an implicit\n- *  condition_broadcast to insure that waiting threads have the opportunity\n- *  to wake.  It is legal to dealloc a condition only if no other\n- *  thread is/will be using it. Here we do NOT check for other threads\n- *  waiting but just wake them up.\n- */\n+/* Deallocate a condition. */\n int\n-objc_condition_deallocate(objc_condition_t condition)\n+__objc_condition_deallocate(objc_condition_t condition)\n {\n-    cond_broadcast(&(condition->condition));    /* Wakeup waiting threads   */\n-    cond_destroy(&(condition->condition));      /* Kill condition           */\n-    objc_free(condition);                       /* Release struct memory    */\n-    return 0;\n+  return cond_destroy((cond_t *)(&(condition->backend)));\n }\n \n-/********\n- *  Wait on the condition unlocking the mutex until objc_condition_signal()\n- *  or objc_condition_broadcast() are called for the same condition. The\n- *  given mutex *must* have the depth set to 1 so that it can be unlocked\n- *  here, so that someone else can lock it and signal/broadcast the condition.\n- *  The mutex is used to lock access to the shared data that make up the\n- *  \"condition\" predicate.\n- */\n+/* Wait on the condition */\n int\n-objc_condition_wait(objc_condition_t condition, objc_mutex_t mutex)\n+__objc_condition_wait(objc_condition_t condition, objc_mutex_t mutex)\n {\n-    objc_thread_t    thread_id;                /* Cache our thread id.     */\n-\n-    if (!mutex || !condition)                   /* Is argument bad?         */\n-        return -1;                              /* Yes, abort.              */\n-\n-    thread_id = objc_thread_id();               /* Get this thread's id.    */\n-    if (mutex->owner != thread_id)              /* Does some else own lock? */\n-        return -1;                              /* Yes, abort.              */\n-    if (mutex->depth > 1)                       /* Locked more than once ?  */\n-        return -1;                              /* YES, return error        */\n-                                                /* mutex will be unlocked   */\n-    mutex->depth = 0;                           /* Yes, reset depth to 0.   */\n-    mutex->owner = (objc_thread_t) -1;         /* Set owner to \"no thread\".*/\n-\n-    cond_wait(&(condition->condition),\n-        &(mutex->lock));                        /* unlock, wait ..., lock   */\n-\n-    mutex->owner = thread_id;                   /* Mark thread as owner.    */\n-    mutex->depth = 1;                           /* Must be here !           */\n-\n-    return 0;                                   /* Return success.          */\n+  return cond_wait((cond_t *)(&(condition->backend)),\n+\t\t   (mutex_t *)(&(mutex->backend)));\n }\n \n-/********\n- *  Wake up all threads waiting on this condition. It is recommended that\n- *  the called would lock the same mutex as the threads in objc_condition_wait\n- *  before changing the \"condition predicate\" and make this call and unlock it\n- *  right away after this call.\n- */\n+/* Wake up all threads waiting on this condition. */\n int\n-objc_condition_broadcast(objc_condition_t condition)\n+__objc_condition_broadcast(objc_condition_t condition)\n {\n-    if (!condition)\n-        return -1;\n-    cond_broadcast(&(condition->condition));\n-    return 0;\n+  return cond_broadcast((cond_t *)(&(condition->backend)));\n }\n \n-/********\n- *  Wake up one thread waiting on this condition. It is recommended that\n- *  the called would lock the same mutex as the threads in objc_condition_wait\n- *  before changing the \"condition predicate\" and make this call and unlock it\n- *  right away after this call.\n- */\n+/* Wake up one thread waiting on this condition. */\n int\n-objc_condition_signal(objc_condition_t condition)\n+__objc_condition_signal(objc_condition_t condition)\n {\n-    if (!condition)\n-        return -1;\n-    cond_signal(&(condition->condition));\n-    return 0;\n+  return cond_signal((cond_t *)(&(condition->backend)));\n }\n \n /* End of File */"}, {"sha": "159e3e37665f35f7b5e80e7cdd325df73cb8e7e6", "filename": "gcc/objc/thr-win32.c", "status": "modified", "additions": 159, "deletions": 224, "changes": 383, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2024f9e4dc4746fc1f87a82ccd998d0c24f75d8c/gcc%2Fobjc%2Fthr-win32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2024f9e4dc4746fc1f87a82ccd998d0c24f75d8c/gcc%2Fobjc%2Fthr-win32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fthr-win32.c?ref=2024f9e4dc4746fc1f87a82ccd998d0c24f75d8c", "patch": "@@ -32,306 +32,241 @@ Boston, MA 02111-1307, USA.  */\n #endif\n #include <windows.h>\n \n-/********\n- *  This structure represents a single mutual exclusion lock.  Lock semantics\n- *  are detailed with the subsequent functions.  We use whatever lock is\n- *  provided by the system.  We augment it with depth and current owner id\n- *  fields to implement and re-entrant lock.\n- */\n-struct objc_mutex \n-{\n-  volatile objc_thread_t       owner;        \t/* Id of thread that owns.  */\n-  volatile int                  depth;          /* # of acquires.           */\n-  HANDLE                        handle;         /* Win32 mutex HANDLE.      */\n-};\n-\n-/*****************************************************************************\n- *  Static variables.\n- */\n-static DWORD\t__objc_data_tls = (DWORD)-1;\t/* Win32 Thread Local Index.*/\n-\n-/********\n- *  Initialize the threads subsystem.  Returns 0 if successful, or -1 if no\n- *  thread support is available.\n- */\n+/* Key structure for maintiain thread specific storage */\n+static DWORD\t__objc_data_tls = (DWORD)-1;\n+\n+/* Backend initialization functions */\n+\n+/* Initialize the threads subsystem. */\n int\n __objc_init_thread_system(void)\n {\n-  DEBUG_PRINTF(\"__objc_init_thread_system\\n\");\n-\n+  /* Initialize the thread storage key */\n   if ((__objc_data_tls = TlsAlloc()) != (DWORD)-1)\n-    return 0;                               \t/* Yes, return success.     */\n-    \n-  return -1;                                  \t/* Failed.                  */\n+    return 0;\n+  else\n+    return -1;\n }\n \n+/* Close the threads subsystem. */\n int\n-__objc_fini_thread_system(void)\n+__objc_close_thread_system(void)\n {\n-  if (__objc_data_tls != (DWORD)-1) {\n+  if (__objc_data_tls != (DWORD)-1)\n     TlsFree(__objc_data_tls);\n-    return 0;\n-  }\n-  return -1;\n+  return 0;\n }\n \n-/********\n- *  Create a new thread of execution and return its id.  Return NULL if fails.\n- *  The new thread starts in \"func\" with the given argument.\n- */\n+/* Backend thread functions */\n+\n+/* Create a new thread of execution. */\n objc_thread_t\n-objc_thread_create(void (*func)(void *arg), void *arg)\n+__objc_thread_detach(void (*func)(void *arg), void *arg)\n {\n-  DWORD        \tthread_id = 0;                  /* Detached thread id.      */\n-  HANDLE\twin32_handle;\t\t\t/* Win32 thread handle.     */\n+  DWORD\tthread_id = 0;\n+  HANDLE win32_handle;\n \n-  objc_mutex_lock(__objc_runtime_mutex);\n-  \n-  if ((win32_handle = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)func,\n-                                   arg, 0, &thread_id))) {\n-      __objc_runtime_threads_alive++;\n-  }\n-  else\n-      thread_id = 0;\n-  \n-  objc_mutex_unlock(__objc_runtime_mutex);\n+  if (!(win32_handle = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)func,\n+                                   arg, 0, &thread_id)))\n+    thread_id = 0;\n   \n   return (objc_thread_t)thread_id;\n }\n \n-/********\n- *  Set the current thread's priority.\n- */\n+/* Set the current thread's priority. */\n int\n-objc_thread_set_priority(int priority)\n+__objc_thread_set_priority(int priority)\n {\n-  int         \tsys_priority = 0;\n-\n-  switch (priority) {\n-  case OBJC_THREAD_INTERACTIVE_PRIORITY:\n-    sys_priority = THREAD_PRIORITY_NORMAL;\n-    break;\n-  default:\n-  case OBJC_THREAD_BACKGROUND_PRIORITY:\n-    sys_priority = THREAD_PRIORITY_BELOW_NORMAL;\n-    break;\n-  case OBJC_THREAD_LOW_PRIORITY:\n-    sys_priority = THREAD_PRIORITY_LOWEST;\n-    break;\n-  }\n+  int sys_priority = 0;\n+\n+  switch (priority)\n+    {\n+    case OBJC_THREAD_INTERACTIVE_PRIORITY:\n+      sys_priority = THREAD_PRIORITY_NORMAL;\n+      break;\n+    default:\n+    case OBJC_THREAD_BACKGROUND_PRIORITY:\n+      sys_priority = THREAD_PRIORITY_BELOW_NORMAL;\n+      break;\n+    case OBJC_THREAD_LOW_PRIORITY:\n+      sys_priority = THREAD_PRIORITY_LOWEST;\n+      break;\n+    }\n+\n+  /* Change priority */\n   if (SetThreadPriority(GetCurrentThread(), sys_priority))\n-    return 0;                                  \t/* Changed priority. End.   */\n-    \n-  return -1;                                  \t/* Failed.                  */\n+    return 0;\n+  else\n+    return -1;\n }\n \n-/********\n- *  Return the current thread's priority.\n- */\n+/* Return the current thread's priority. */\n int\n-objc_thread_get_priority(void)\n+__objc_thread_get_priority(void)\n {\n-  int         \tsys_priority;\n+  int sys_priority;\n \n   sys_priority = GetThreadPriority(GetCurrentThread());\n   \n-  switch (sys_priority) {\n-  case THREAD_PRIORITY_HIGHEST:\n-  case THREAD_PRIORITY_TIME_CRITICAL:\n-  case THREAD_PRIORITY_ABOVE_NORMAL:\n-  case THREAD_PRIORITY_NORMAL:\n-    return OBJC_THREAD_INTERACTIVE_PRIORITY;\n-\n-  default:\n-  case THREAD_PRIORITY_BELOW_NORMAL:\n-    return OBJC_THREAD_BACKGROUND_PRIORITY;\n+  switch (sys_priority)\n+    {\n+    case THREAD_PRIORITY_HIGHEST:\n+    case THREAD_PRIORITY_TIME_CRITICAL:\n+    case THREAD_PRIORITY_ABOVE_NORMAL:\n+    case THREAD_PRIORITY_NORMAL:\n+      return OBJC_THREAD_INTERACTIVE_PRIORITY;\n+\n+    default:\n+    case THREAD_PRIORITY_BELOW_NORMAL:\n+      return OBJC_THREAD_BACKGROUND_PRIORITY;\n     \n-  case THREAD_PRIORITY_IDLE:\n-  case THREAD_PRIORITY_LOWEST:\n-    return OBJC_THREAD_LOW_PRIORITY;\n-  }\n-  return -1;                                  \t/* Couldn't get priority.   */\n+    case THREAD_PRIORITY_IDLE:\n+    case THREAD_PRIORITY_LOWEST:\n+      return OBJC_THREAD_LOW_PRIORITY;\n+    }\n+\n+  /* Couldn't get priority. */\n+  return -1;\n }\n \n-/********\n- *  Yield our process time to another thread.  Any BUSY waiting that is done\n- *  by a thread should use this function to make sure that other threads can\n- *  make progress even on a lazy uniprocessor system.\n- */\n+/* Yield our process time to another thread. */\n void\n-objc_thread_yield(void)\n+__objc_thread_yield(void)\n {\n-  Sleep(0);\t                            \t/* Yield to equal thread.   */\n+  Sleep(0);\n }\n \n-/********\n- *  Terminate the current tread.  Doesn't return anything.  Doesn't return.\n- *  Actually, if it failed returns -1.\n- */\n+/* Terminate the current thread. */\n int\n-objc_thread_exit(void)\n+__objc_thread_exit(void)\n {\n-  objc_mutex_lock(__objc_runtime_mutex);\n-  __objc_runtime_threads_alive--;\n-  objc_mutex_unlock(__objc_runtime_mutex);\n-  \n-  ExitThread(__objc_thread_exit_status);   \t/* Terminate thread.        */\n+  /* exit the thread */\n+  ExitThread(__objc_thread_exit_status);\n+\n+  /* Failed if we reached here */\n   return -1;\n }\n \n-/********\n- *  Returns an integer value which uniquely describes a thread.  Must not be\n- *  -1 which is reserved as a marker for \"no thread\".\n- */\n+/* Returns an integer value which uniquely describes a thread. */\n objc_thread_t\n-objc_thread_id(void)\n+__objc_thread_id(void)\n {\n-  return (objc_thread_t)GetCurrentThreadId();  /* Return thread id.        */\n+  return (objc_thread_t)GetCurrentThreadId();\n }\n \n-/********\n- *  Sets the thread's local storage pointer.  Returns 0 if successful or -1\n- *  if failed.\n- */\n+/* Sets the thread's local storage pointer. */\n int\n-objc_thread_set_data(void *value)\n+__objc_thread_set_data(void *value)\n {\n   if (TlsSetValue(__objc_data_tls, value))\n-    return 0;                           \t/* Return thread data.      */\n-  return -1;\n+    return 0;\n+  else\n+    return -1;\n }\n \n-/********\n- *  Returns the thread's local storage pointer.  Returns NULL on failure.\n- */\n+/* Returns the thread's local storage pointer. */\n void *\n-objc_thread_get_data(void)\n+__objc_thread_get_data(void)\n {\n   return TlsGetValue(__objc_data_tls);          /* Return thread data.      */\n }\n \n-/********\n- *  Allocate a mutex.  Return the mutex pointer if successful or NULL if\n- *  the allocation fails for any reason.\n- */\n-objc_mutex_t\n-objc_mutex_allocate(void)\n+/* Backend mutex functions */\n+\n+/* Allocate a mutex. */\n+int\n+__objc_mutex_allocate(objc_mutex_t mutex)\n+{\n+  if ((mutex->backend = (void *)CreateMutex(NULL, 0, NULL)) == NULL)\n+    return -1;\n+  else\n+    return 0;\n+}\n+\n+/* Deallocate a mutex. */\n+int\n+__objc_mutex_deallocate(objc_mutex_t mutex)\n {\n-    objc_mutex_t mutex;\n-    int         err = 0;\n+  CloseHandle((HANDLE)(mutex->backend));\n+  return 0;\n+}\n \n-    if (!(mutex = (objc_mutex_t)objc_malloc(sizeof(struct objc_mutex))))\n-        return NULL;                            /* Abort if malloc failed.  */\n+/* Grab a lock on a mutex. */\n+int\n+__objc_mutex_lock(objc_mutex_t mutex)\n+{\n+  int status;\n \n-    if ((mutex->handle = CreateMutex(NULL, 0, NULL)) == NULL) {\n-        objc_free(mutex);                       /* Failed, free memory.     */\n-        return NULL;                            /* Abort.                   */\n-    }\n-    mutex->owner = NULL;                        /* No owner.                */\n-    mutex->depth = 0;                           /* No locks.                */\n-    return mutex;                               /* Return mutex handle.     */\n+  status = WaitForSingleObject((HANDLE)(mutex->backend), INFINITE);\n+  if (status != WAIT_OBJECT_0 && status != WAIT_ABANDONED)\n+    return -1;\n+  else\n+    return 0;\n }\n \n-/********\n- *  Deallocate a mutex.  Note that this includes an implicit mutex_lock to\n- *  insure that no one else is using the lock.  It is legal to deallocate\n- *  a lock if we have a lock on it, but illegal to deallotcate a lock held\n- *  by anyone else.\n- *  Returns the number of locks on the thread.  (1 for deallocate).\n- */\n+/* Try to grab a lock on a mutex. */\n int\n-objc_mutex_deallocate(objc_mutex_t mutex)\n+__objc_mutex_trylock(objc_mutex_t mutex)\n {\n-    int         depth;                          /* # of locks on mutex.     */\n+  int status;\n \n-    if (!mutex)                                 /* Is argument bad?         */\n-        return -1;                              /* Yes, abort.              */\n-    depth = objc_mutex_lock(mutex);             /* Must have lock.          */\n+  status = WaitForSingleObject((HANDLE)(mutex->backend), 0);\n+  if (status != WAIT_OBJECT_0 && status != WAIT_ABANDONED)\n+    return -1;\n+  else\n+    return 0;\n+}\n \n-    CloseHandle(mutex->handle);\t\t\t/* Close Win32 handle.      */\n-    \n-    objc_free(mutex);                           /* Free memory.             */\n-    return depth;                               /* Return last depth.       */\n+/* Unlock the mutex */\n+int\n+__objc_mutex_unlock(objc_mutex_t mutex)\n+{\n+  if (ReleaseMutex((HANDLE)(mutex->backend)) == 0)\n+    return -1;\n+  else\n+    return 0;\n }\n \n-/********\n- *  Grab a lock on a mutex.  If this thread already has a lock on this mutex\n- *  then we increment the lock count.  If another thread has a lock on the \n- *  mutex we block and wait for the thread to release the lock.\n- *  Returns the lock count on the mutex held by this thread.\n- */\n+/* Backend condition mutex functions */\n+\n+/* Allocate a condition. */\n int\n-objc_mutex_lock(objc_mutex_t mutex)\n+__objc_condition_allocate(objc_condition_t condition)\n {\n-    objc_thread_t      thread_id;              /* Cache our thread id.     */\n-    int                 status;\n-\n-    if (!mutex)                                 /* Is argument bad?         */\n-        return -1;                              /* Yes, abort.              */\n-    thread_id = objc_thread_id();               /* Get this thread's id.    */\n-    if (mutex->owner == thread_id)              /* Already own lock?        */\n-        return ++mutex->depth;                  /* Yes, increment depth.    */\n-\n-    status = WaitForSingleObject(mutex->handle, INFINITE);\n-    if (status != WAIT_OBJECT_0 && status != WAIT_ABANDONED)\n-        return -1;                              /* Failed, abort.           */\n-    \n-    mutex->owner = thread_id;                   /* Mark thread as owner.    */\n+  /* Unimplemented. */\n+  return -1;\n+}\n \n-    return ++mutex->depth;                      /* Increment depth to end.  */\n+/* Deallocate a condition. */\n+int\n+__objc_condition_deallocate(objc_condition_t condition)\n+{\n+  /* Unimplemented. */\n+  return -1;\n }\n \n-/********\n- *  Try to grab a lock on a mutex.  If this thread already has a lock on\n- *  this mutex then we increment the lock count and return it.  If another\n- *  thread has a lock on the mutex returns -1.\n- */\n+/* Wait on the condition */\n int\n-objc_mutex_trylock(objc_mutex_t mutex)\n+__objc_condition_wait(objc_condition_t condition, objc_mutex_t mutex)\n {\n-    objc_thread_t      thread_id;              /* Cache our thread id.     */\n-    DWORD               status;                 /* Return status from Win32.*/\n-\n-    if (!mutex)                                 /* Is argument bad?         */\n-        return -1;                              /* Yes, abort.              */\n-    thread_id = objc_thread_id();               /* Get this thread's id.    */\n-    if (mutex->owner == thread_id)              /* Already own lock?        */\n-        return ++mutex->depth;                  /* Yes, increment depth.    */\n-\n-    status = WaitForSingleObject(mutex->handle, 0);\n-    if (status != WAIT_OBJECT_0 && status != WAIT_ABANDONED)\n-        return -1;                              /* Failed, abort.           */\n-    \n-    mutex->owner = thread_id;                   /* Mark thread as owner.    */\n-    return ++mutex->depth;                      /* Increment depth to end.  */\n+  /* Unimplemented. */\n+  return -1;\n }\n \n-/********\n- *  Decrements the lock count on this mutex by one.  If the lock count reaches\n- *  zero, release the lock on the mutex.  Returns the lock count on the mutex.\n- *  It is an error to attempt to unlock a mutex which this thread doesn't hold\n- *  in which case return -1 and the mutex is unaffected.\n- *  Will also return -1 if the mutex free fails.\n- */\n+/* Wake up all threads waiting on this condition. */\n int\n-objc_mutex_unlock(objc_mutex_t mutex)\n+__objc_condition_broadcast(objc_condition_t condition)\n {\n-    objc_thread_t      thread_id;              /* Cache our thread id.     */\n-    \n-    if (!mutex)                                 /* Is argument bad?         */\n-        return -1;                              /* Yes, abort.              */\n-    thread_id = objc_thread_id();               /* Get this thread's id.    */\n-    if (mutex->owner != thread_id)              /* Does some else own lock? */\n-        return -1;                              /* Yes, abort.              */\n-    if (mutex->depth > 1)                       /* Released last lock?      */\n-        return --mutex->depth;                  /* No, Decrement depth, end.*/\n-    mutex->depth = 0;                           /* Yes, reset depth to 0.   */\n-    mutex->owner = NULL;                        /* Set owner to \"no thread\".*/\n-    \n-    if (ReleaseMutex(mutex->handle) == 0)\n-        return -1;                              /* Failed, abort.           */\n-    \n-    return 0;                                   /* No, return success.      */\n+  /* Unimplemented. */\n+  return -1;\n+}\n+\n+/* Wake up one thread waiting on this condition. */\n+int\n+__objc_condition_signal(objc_condition_t condition)\n+{\n+  /* Unimplemented. */\n+  return -1;\n }\n \n /* End of File */"}, {"sha": "f1c957aaa15c79a784e7926483d32ce6d25790e6", "filename": "gcc/objc/thr.c", "status": "modified", "additions": 443, "deletions": 62, "changes": 505, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2024f9e4dc4746fc1f87a82ccd998d0c24f75d8c/gcc%2Fobjc%2Fthr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2024f9e4dc4746fc1f87a82ccd998d0c24f75d8c/gcc%2Fobjc%2Fthr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fthr.c?ref=2024f9e4dc4746fc1f87a82ccd998d0c24f75d8c", "patch": "@@ -27,20 +27,15 @@ Boston, MA 02111-1307, USA.  */\n #include <stdlib.h>\n #include \"runtime.h\"\n \n-/*************************************************************************\n- *  Universal static variables:\n- */\n-int __objc_thread_exit_status = 0;      /* Global exit status.   */\n+/* Global exit status. */\n+int __objc_thread_exit_status = 0;\n \n /* Flag which lets us know if we ever became multi threaded */\n int __objc_is_multi_threaded = 0;\n+\n /* The hook function called when the runtime becomes multi threaded */\n objc_thread_callback _objc_became_multi_threaded = NULL;\n \n-/*****************************************************************************\n- *  Universal Functionality\n- */\n-\n /*\n   Use this to set the hook function that will be called when the \n   runtime initially becomes multi threaded.\n@@ -60,94 +55,480 @@ objc_thread_callback objc_set_thread_callback(objc_thread_callback func)\n   return temp;\n }\n \n-/********\n- *  First function called in a thread, starts everything else.\n+/*\n+  Private functions\n+\n+  These functions are utilized by the frontend, but they are not\n+  considered part of the public interface.\n+  */\n+\n+/*\n+  First function called in a thread, starts everything else.\n+\n+  This function is passed to the backend by objc_thread_detach\n+  as the starting function for a new thread.\n  */\n struct __objc_thread_start_state\n {\n-    SEL         selector;\n-    id          object;\n-    id          argument;\n+  SEL selector;\n+  id object;\n+  id argument;\n };\n \n static volatile void\n __objc_thread_detach_function(struct __objc_thread_start_state *istate)\n {\n-    if (istate) {                               /* Is state valid?          */\n-        id      (*imp)(id,SEL,id);\n-        SEL     selector = istate->selector;\n-        id      object   = istate->object;\n-        id      argument = istate->argument;\n+  /* Valid state? */\n+  if (istate) {\n+    id (*imp)(id,SEL,id);\n+    SEL selector = istate->selector;\n+    id object   = istate->object;\n+    id argument = istate->argument;\n \n-        objc_free(istate);\n+    /* Don't need anymore so free it */\n+    objc_free(istate);\n \n-\t/* Clear out the thread local storage */\n-\tobjc_thread_set_data(NULL);\n+    /* Clear out the thread local storage */\n+    objc_thread_set_data(NULL);\n \n-\t/* Check to see if we just became multi threaded */\n-\tif (!__objc_is_multi_threaded) {\n-\t  __objc_is_multi_threaded = 1;\n+    /* Check to see if we just became multi threaded */\n+    if (!__objc_is_multi_threaded)\n+      {\n+\t__objc_is_multi_threaded = 1;\n \n-\t  /* Call the hook function */\n-\t  if (_objc_became_multi_threaded != NULL)\n-\t    (*_objc_became_multi_threaded)();\n-\t}\n+\t/* Call the hook function */\n+\tif (_objc_became_multi_threaded != NULL)\n+\t  (*_objc_became_multi_threaded)();\n+      }\n \n-        if ((imp = (id(*)(id, SEL, id))objc_msg_lookup(object, selector))) {\n-            (*imp)(object, selector, argument);\n-        }\n-        else\n-            fprintf(stderr, \"__objc_thread_start called with bad selector.\\n\");\n-    }\n-    else {\n-        fprintf(stderr, \"__objc_thread_start called with NULL state.\\n\");\n-    }\n-    objc_thread_exit();\n+    /* Call the method */\n+    if ((imp = (id(*)(id, SEL, id))objc_msg_lookup(object, selector)))\n+\t(*imp)(object, selector, argument);\n+    else\n+      objc_error(object, OBJC_ERR_UNIMPLEMENTED,\n+\t\t \"objc_thread_detach called with bad selector.\\n\");\n+  }\n+  else\n+    objc_error(nil, OBJC_ERR_BAD_STATE,\n+\t       \"objc_thread_detach called with NULL state.\\n\");\n+\n+  /* Exit the thread */\n+  objc_thread_exit();\n }\n \n-/********\n- *  Detach a new thread of execution and return its id.  Returns NULL if fails.\n- *  Thread is started by sending message with selector to object.  Message\n- *  takes a single argument.\n- */\n+/*\n+  Frontend functions\n+\n+  These functions constitute the public interface to the Objective-C thread\n+  and mutex functionality.\n+  */\n+\n+/* Frontend thread functions */\n+\n+/*\n+  Detach a new thread of execution and return its id.  Returns NULL if fails.\n+  Thread is started by sending message with selector to object.  Message\n+  takes a single argument.\n+  */\n objc_thread_t\n objc_thread_detach(SEL selector, id object, id argument)\n {\n-  struct __objc_thread_start_state *istate;   /* Initialial thread state. */\n-  objc_thread_t        thread_id = NULL;     /* Detached thread id.      */\n+  struct __objc_thread_start_state *istate;\n+  objc_thread_t        thread_id = NULL;\n \n+  /* Allocate the state structure */\n   if (!(istate = (struct __objc_thread_start_state *)\n-\tobjc_malloc(sizeof(*istate))))     /* Can we allocate state?   */\n-    return NULL;                              /* No, abort.               */\n+\tobjc_malloc(sizeof(*istate))))\n+    return NULL;\n \n-  istate->selector = selector;                /* Initialize the thread's  */\n-  istate->object = object;                    /*   state structure.       */\n+  /* Initialize the state structure */\n+  istate->selector = selector;\n+  istate->object = object;\n   istate->argument = argument;\n \n-  if ((thread_id = objc_thread_create((void *)__objc_thread_detach_function,\n-                                      istate)) == NULL) {\n-    objc_free(istate);                       /* Release state if failed.   */\n-    return thread_id;\n-  }\n+  /* lock access */\n+  objc_mutex_lock(__objc_runtime_mutex);\n+\n+  /* Call the backend to spawn the thread */\n+  if ((thread_id = __objc_thread_detach((void *)__objc_thread_detach_function,\n+\t\t\t\t\tistate)) == NULL)\n+    {\n+      /* failed! */\n+      objc_mutex_unlock(__objc_runtime_mutex);\n+      objc_free(istate);\n+      return NULL;\n+    }\n+\n+  /* Increment our thread counter */\n+  __objc_runtime_threads_alive++;\n+  objc_mutex_unlock(__objc_runtime_mutex);\n \n   return thread_id;\n }\n \n-#undef objc_mutex_lock()\n-#undef objc_mutex_unlock()\n+/* Set the current thread's priority. */\n+int\n+objc_thread_set_priority(int priority)\n+{\n+  /* Call the backend */\n+  return __objc_thread_set_priority(priority);\n+}\n \n+/* Return the current thread's priority. */\n int\n-objc_mutex_unlock_x(objc_mutex_t mutex, const char *f, int l)\n+objc_thread_get_priority(void)\n {\n-    printf(\"%16.16s#%4d < unlock\", f, l);\n-    return objc_mutex_unlock(mutex);\n+  /* Call the backend */\n+  return __objc_thread_get_priority();\n }\n \n+/*\n+  Yield our process time to another thread.  Any BUSY waiting that is done\n+  by a thread should use this function to make sure that other threads can\n+  make progress even on a lazy uniprocessor system.\n+  */\n+void\n+objc_thread_yield(void)\n+{\n+  /* Call the backend */\n+  __objc_thread_yield();\n+}\n+\n+/*\n+  Terminate the current tread.  Doesn't return.\n+  Actually, if it failed returns -1.\n+  */\n int\n-objc_mutex_lock_x(objc_mutex_t mutex, const char *f, int l)\n+objc_thread_exit(void)\n {\n-    printf(\"%16.16s#%4d < lock\", f, l);\n-    return objc_mutex_lock(mutex);\n+  /* Decrement our counter of the number of threads alive */\n+  objc_mutex_lock(__objc_runtime_mutex);\n+  __objc_runtime_threads_alive--;\n+  objc_mutex_unlock(__objc_runtime_mutex);\n+\n+  /* Call the backend to terminate the thread */\n+  return __objc_thread_exit();\n+}\n+\n+/*\n+  Returns an integer value which uniquely describes a thread.  Must not be\n+  NULL which is reserved as a marker for \"no thread\".\n+  */\n+objc_thread_t\n+objc_thread_id(void)\n+{\n+  /* Call the backend */\n+  return __objc_thread_id();\n+}\n+\n+/*\n+  Sets the thread's local storage pointer. \n+  Returns 0 if successful or -1 if failed.\n+  */\n+int\n+objc_thread_set_data(void *value)\n+{\n+  /* Call the backend */\n+  return __objc_thread_set_data(value);\n+}\n+\n+/*\n+  Returns the thread's local storage pointer.  Returns NULL on failure.\n+  */\n+void *\n+objc_thread_get_data(void)\n+{\n+  /* Call the backend */\n+  return __objc_thread_get_data();\n+}\n+\n+/* Frontend mutex functions */\n+\n+/*\n+  Allocate a mutex.  Return the mutex pointer if successful or NULL if the\n+  allocation failed for any reason.\n+  */\n+objc_mutex_t\n+objc_mutex_allocate(void)\n+{\n+  objc_mutex_t mutex;\n+\n+  /* Allocate the mutex structure */\n+  if (!(mutex = (objc_mutex_t)objc_malloc(sizeof(struct objc_mutex))))\n+    return NULL;\n+\n+  /* Call backend to create the mutex */\n+  if (__objc_mutex_allocate(mutex))\n+    {\n+      /* failed! */\n+      objc_free(mutex);\n+      return NULL;\n+    }\n+\n+  /* Initialize mutex */\n+  mutex->owner = NULL;\n+  mutex->depth = 0;\n+  return mutex;\n+}\n+\n+/*\n+  Deallocate a mutex.  Note that this includes an implicit mutex_lock to\n+  insure that no one else is using the lock.  It is legal to deallocate\n+  a lock if we have a lock on it, but illegal to deallocate a lock held\n+  by anyone else.\n+  Returns the number of locks on the thread.  (1 for deallocate).\n+  */\n+int\n+objc_mutex_deallocate(objc_mutex_t mutex)\n+{\n+  int depth;\n+\n+  /* Valid mutex? */\n+  if (!mutex)\n+    return -1;\n+\n+  /* Acquire lock on mutex */\n+  depth = objc_mutex_lock(mutex);\n+\n+  /* Call backend to destroy mutex */\n+  if (__objc_mutex_deallocate(mutex))\n+    return -1;\n+\n+  /* Free the mutex structure */\n+  objc_free(mutex);\n+\n+  /* Return last depth */\n+  return depth;\n+}\n+\n+/*\n+  Grab a lock on a mutex.  If this thread already has a lock on this mutex\n+  then we increment the lock count.  If another thread has a lock on the \n+  mutex we block and wait for the thread to release the lock.\n+  Returns the lock count on the mutex held by this thread.\n+  */\n+int\n+objc_mutex_lock(objc_mutex_t mutex)\n+{\n+  objc_thread_t thread_id;\n+  int status;\n+\n+  /* Valid mutex? */\n+  if (!mutex)\n+    return -1;\n+\n+  /* If we already own the lock then increment depth */\n+  thread_id = objc_thread_id();\n+  if (mutex->owner == thread_id)\n+    return ++mutex->depth;\n+\n+  /* Call the backend to lock the mutex */\n+  status = __objc_mutex_lock(mutex);\n+\n+  /* Failed? */\n+  if (status)\n+    return status;\n+\n+  /* Successfully locked the thread */\n+  mutex->owner = thread_id;\n+  return mutex->depth = 1;\n+}\n+\n+/*\n+  Try to grab a lock on a mutex.  If this thread already has a lock on\n+  this mutex then we increment the lock count and return it.  If another\n+  thread has a lock on the mutex returns -1.\n+  */\n+int\n+objc_mutex_trylock(objc_mutex_t mutex)\n+{\n+  objc_thread_t thread_id;\n+  int status;\n+\n+  /* Valid mutex? */\n+  if (!mutex)\n+    return -1;\n+\n+  /* If we already own the lock then increment depth */ \n+  thread_id = objc_thread_id();\n+  if (mutex->owner == thread_id)\n+    return ++mutex->depth;\n+    \n+  /* Call the backend to try to lock the mutex */\n+  status = __objc_mutex_trylock(mutex);\n+\n+  /* Failed? */\n+  if (status)\n+    return status;\n+\n+  /* Successfully locked the thread */\n+  mutex->owner = thread_id;\n+  return mutex->depth = 1;\n+}\n+\n+/* \n+  Unlocks the mutex by one level.\n+  Decrements the lock count on this mutex by one.\n+  If the lock count reaches zero, release the lock on the mutex.\n+  Returns the lock count on the mutex.\n+  It is an error to attempt to unlock a mutex which this thread \n+  doesn't hold in which case return -1 and the mutex is unaffected.\n+  */\n+int\n+objc_mutex_unlock(objc_mutex_t mutex)\n+{\n+  objc_thread_t thread_id;\n+  int status;\n+\n+  /* Valid mutex? */\n+  if (!mutex)\n+    return -1;\n+\n+  /* If another thread owns the lock then abort */\n+  thread_id = objc_thread_id();\n+  if (mutex->owner != thread_id)\n+    return -1;\n+\n+  /* Decrement depth and return */\n+  if (mutex->depth > 1)\n+    return --mutex->depth;\n+\n+  /* Depth down to zero so we are no longer the owner */\n+  mutex->depth = 0;\n+  mutex->owner = NULL;\n+\n+  /* Have the backend unlock the mutex */\n+  status = __objc_mutex_unlock(mutex);\n+\n+  /* Failed? */\n+  if (status)\n+    return status;\n+\n+  return 0;\n+}\n+\n+/* Frontend condition mutex functions */\n+\n+/*\n+  Allocate a condition.  Return the condition pointer if successful or NULL\n+  if the allocation failed for any reason.\n+  */\n+objc_condition_t \n+objc_condition_allocate(void)\n+{\n+  objc_condition_t condition;\n+    \n+  /* Allocate the condition mutex structure */\n+  if (!(condition = \n+\t(objc_condition_t)objc_malloc(sizeof(struct objc_condition))))\n+    return NULL;\n+\n+  /* Call the backend to create the condition mutex */\n+  if (__objc_condition_allocate(condition))\n+    {\n+      /* failed! */\n+      objc_free(condition);\n+      return NULL;\n+    }\n+\n+  /* Success! */\n+  return condition;\n+}\n+\n+/*\n+  Deallocate a condition. Note that this includes an implicit \n+  condition_broadcast to insure that waiting threads have the opportunity\n+  to wake.  It is legal to dealloc a condition only if no other\n+  thread is/will be using it. Here we do NOT check for other threads\n+  waiting but just wake them up.\n+  */\n+int\n+objc_condition_deallocate(objc_condition_t condition)\n+{\n+  /* Broadcast the condition */\n+  if (objc_condition_broadcast(condition))\n+    return -1;\n+\n+  /* Call the backend to destroy */\n+  if (__objc_condition_deallocate(condition))\n+    return -1;\n+\n+  /* Free the condition mutex structure */\n+  objc_free(condition);\n+\n+  return 0;\n+}\n+\n+/*\n+  Wait on the condition unlocking the mutex until objc_condition_signal()\n+  or objc_condition_broadcast() are called for the same condition. The\n+  given mutex *must* have the depth set to 1 so that it can be unlocked\n+  here, so that someone else can lock it and signal/broadcast the condition.\n+  The mutex is used to lock access to the shared data that make up the\n+  \"condition\" predicate.\n+  */\n+int\n+objc_condition_wait(objc_condition_t condition, objc_mutex_t mutex)\n+{\n+  objc_thread_t thread_id;\n+\n+  /* Valid arguments? */\n+  if (!mutex || !condition)\n+    return -1;\n+\n+  /* Make sure we are owner of mutex */\n+  thread_id = objc_thread_id();\n+  if (mutex->owner != thread_id)\n+    return -1;\n+\n+  /* Cannot be locked more than once */\n+  if (mutex->depth > 1)\n+    return -1;\n+\n+  /* Virtually unlock the mutex */\n+  mutex->depth = 0;\n+  mutex->owner = (objc_thread_t)NULL;\n+\n+  /* Call the backend to wait */\n+  __objc_condition_wait(condition, mutex);\n+\n+  /* Make ourselves owner of the mutex */\n+  mutex->owner = thread_id;\n+  mutex->depth = 1;\n+\n+  return 0;\n+}\n+\n+/*\n+  Wake up all threads waiting on this condition. It is recommended that \n+  the called would lock the same mutex as the threads in objc_condition_wait\n+  before changing the \"condition predicate\" and make this call and unlock it\n+  right away after this call.\n+  */\n+int\n+objc_condition_broadcast(objc_condition_t condition)\n+{\n+  /* Valid condition mutex? */\n+  if (!condition)\n+    return -1;\n+\n+  return __objc_condition_broadcast(condition);\n+}\n+\n+/*\n+  Wake up one thread waiting on this condition. It is recommended that \n+  the called would lock the same mutex as the threads in objc_condition_wait\n+  before changing the \"condition predicate\" and make this call and unlock it\n+  right away after this call.\n+  */\n+int\n+objc_condition_signal(objc_condition_t condition)\n+{\n+  /* Valid condition mutex? */\n+  if (!condition)\n+    return -1;\n+\n+  return __objc_condition_signal(condition);\n }\n \n /* End of File */"}]}