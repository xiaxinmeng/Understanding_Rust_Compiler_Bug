{"sha": "99a15921f00b8d3956a66a39bc98c57893a665f0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTlhMTU5MjFmMDBiOGQzOTU2YTY2YTM5YmM5OGM1Nzg5M2E2NjVmMA==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2002-06-14T16:25:36Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2002-06-14T16:25:36Z"}, "message": "gcse.c (delete_null_pointer_checks_1): Inform caller if any null pointer checks were eliminated.\n\n\n        * gcse.c (delete_null_pointer_checks_1): Inform caller if any\n        null pointer checks were eliminated.  Update prototype.\n        (delete_null_pointer_checks): Similarly.\n        * rtl.h (delete_null_pointer_checks): Update prototype.\n        * toplev.c (rest_of_compilation): Only run cleanup_cfg if\n        delete_null_pointer_checks deletes one or more null\n        pointer checks.  Do not run cleanup_cfg before gcse, the\n        CFG is accurate and optimized at that point..\n\nFrom-SVN: r54617", "tree": {"sha": "72e1faa1b66f9c943d6e2c2fa17de7b0761bbfca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/72e1faa1b66f9c943d6e2c2fa17de7b0761bbfca"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/99a15921f00b8d3956a66a39bc98c57893a665f0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99a15921f00b8d3956a66a39bc98c57893a665f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/99a15921f00b8d3956a66a39bc98c57893a665f0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99a15921f00b8d3956a66a39bc98c57893a665f0/comments", "author": null, "committer": null, "parents": [{"sha": "e56c446321eafc7f19e1d7cd0ef0fa2bdfe40b5f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e56c446321eafc7f19e1d7cd0ef0fa2bdfe40b5f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e56c446321eafc7f19e1d7cd0ef0fa2bdfe40b5f"}], "stats": {"total": 45, "additions": 31, "deletions": 14}, "files": [{"sha": "77d95970a1995b95d72c58e71d5a200c5ab340b0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99a15921f00b8d3956a66a39bc98c57893a665f0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99a15921f00b8d3956a66a39bc98c57893a665f0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=99a15921f00b8d3956a66a39bc98c57893a665f0", "patch": "@@ -1,5 +1,14 @@\n 2002-06-13  Jeffrey Law  <law@redhat.com>\n \n+\t* gcse.c (delete_null_pointer_checks_1): Inform caller if any\n+\tnull pointer checks were eliminated.  Update prototype.\n+\t(delete_null_pointer_checks): Similarly.\n+\t* rtl.h (delete_null_pointer_checks): Update prototype.\n+\t* toplev.c (rest_of_compilation): Only run cleanup_cfg if\n+\tdelete_null_pointer_checks deletes one or more null\n+\tpointer checks.  Do not run cleanup_cfg before gcse, the\n+\tCFG is accurate and optimized at that point..\n+\n \t* rs6000.c (rs6000_frame_related): Avoid unwanted sharing\n \tof hard registers.\n "}, {"sha": "f0a7d3bff8412d4fa411d86f461883e81218b50e", "filename": "gcc/gcse.c", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99a15921f00b8d3956a66a39bc98c57893a665f0/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99a15921f00b8d3956a66a39bc98c57893a665f0/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=99a15921f00b8d3956a66a39bc98c57893a665f0", "patch": "@@ -658,7 +658,7 @@ static int handle_avail_expr\tPARAMS ((rtx, struct expr *));\n static int classic_gcse\t\tPARAMS ((void));\n static int one_classic_gcse_pass PARAMS ((int));\n static void invalidate_nonnull_info PARAMS ((rtx, rtx, void *));\n-static void delete_null_pointer_checks_1 PARAMS ((unsigned int *,\n+static int delete_null_pointer_checks_1 PARAMS ((unsigned int *,\n \t\t\t\t\t\t  sbitmap *, sbitmap *,\n \t\t\t\t\t\t  struct null_pointer_info *));\n static rtx process_insert_insn\tPARAMS ((struct expr *));\n@@ -5473,7 +5473,7 @@ invalidate_nonnull_info (x, setter, data)\n    NPI.  NONNULL_AVIN and NONNULL_AVOUT are pre-allocated sbitmaps;\n    they are not our responsibility to free.  */\n \n-static void\n+static int\n delete_null_pointer_checks_1 (block_reg, nonnull_avin,\n \t\t\t      nonnull_avout, npi)\n      unsigned int *block_reg;\n@@ -5484,6 +5484,7 @@ delete_null_pointer_checks_1 (block_reg, nonnull_avin,\n   basic_block bb, current_block;\n   sbitmap *nonnull_local = npi->nonnull_local;\n   sbitmap *nonnull_killed = npi->nonnull_killed;\n+  int something_changed = 0;\n \n   /* Compute local properties, nonnull and killed.  A register will have\n      the nonnull property if at the end of the current block its value is\n@@ -5605,6 +5606,7 @@ delete_null_pointer_checks_1 (block_reg, nonnull_avin,\n \t  emit_barrier_after (new_jump);\n \t}\n \n+      something_changed = 1;\n       delete_insn (last_insn);\n       if (compare_and_branch == 2)\n \tdelete_insn (earliest);\n@@ -5615,6 +5617,8 @@ delete_null_pointer_checks_1 (block_reg, nonnull_avin,\n \t block.)  */\n       block_reg[bb->index] = 0;\n     }\n+\n+  return something_changed;\n }\n \n /* Find EQ/NE comparisons against zero which can be (indirectly) evaluated\n@@ -5641,7 +5645,7 @@ delete_null_pointer_checks_1 (block_reg, nonnull_avin,\n \n    This could probably be integrated with global cprop with a little work.  */\n \n-void\n+int\n delete_null_pointer_checks (f)\n      rtx f ATTRIBUTE_UNUSED;\n {\n@@ -5652,10 +5656,11 @@ delete_null_pointer_checks (f)\n   int regs_per_pass;\n   int max_reg;\n   struct null_pointer_info npi;\n+  int something_changed = 0;\n \n   /* If we have only a single block, then there's nothing to do.  */\n   if (n_basic_blocks <= 1)\n-    return;\n+    return 0;\n \n   /* Trying to perform global optimizations on flow graphs which have\n      a high connectivity will take a long time and is unlikely to be\n@@ -5666,7 +5671,7 @@ delete_null_pointer_checks (f)\n      a couple switch statements.  So we require a relatively large number\n      of basic blocks and the ratio of edges to blocks to be high.  */\n   if (n_basic_blocks > 1000 && n_edges / n_basic_blocks >= 20)\n-    return;\n+    return 0;\n \n   /* We need four bitmaps, each with a bit for each register in each\n      basic block.  */\n@@ -5719,8 +5724,10 @@ delete_null_pointer_checks (f)\n     {\n       npi.min_reg = reg;\n       npi.max_reg = MIN (reg + regs_per_pass, max_reg);\n-      delete_null_pointer_checks_1 (block_reg, nonnull_avin,\n-\t\t\t\t    nonnull_avout, &npi);\n+      something_changed |= delete_null_pointer_checks_1 (block_reg,\n+\t\t\t\t\t\t\t nonnull_avin,\n+\t\t\t\t\t\t\t nonnull_avout,\n+\t\t\t\t\t\t\t &npi);\n     }\n \n   /* Free the table of registers compared at the end of every block.  */\n@@ -5731,6 +5738,8 @@ delete_null_pointer_checks (f)\n   sbitmap_vector_free (npi.nonnull_killed);\n   sbitmap_vector_free (nonnull_avin);\n   sbitmap_vector_free (nonnull_avout);\n+\n+  return something_changed;\n }\n \n /* Code Hoisting variables and subroutines.  */"}, {"sha": "3842426c3d7fe31ed75463bfa075c81607b34b7b", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99a15921f00b8d3956a66a39bc98c57893a665f0/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99a15921f00b8d3956a66a39bc98c57893a665f0/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=99a15921f00b8d3956a66a39bc98c57893a665f0", "patch": "@@ -2035,7 +2035,7 @@ extern void reg_scan\t\t\tPARAMS ((rtx, unsigned int, int));\n extern void reg_scan_update\t\tPARAMS ((rtx, rtx, unsigned int));\n extern void fix_register\t\tPARAMS ((const char *, int, int));\n \n-extern void delete_null_pointer_checks\tPARAMS ((rtx));\n+extern int delete_null_pointer_checks\tPARAMS ((rtx));\n \n /* In regmove.c */\n #ifdef BUFSIZ"}, {"sha": "7965059f37f6f10b48b010c598d6219da5f36c38", "filename": "gcc/toplev.c", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99a15921f00b8d3956a66a39bc98c57893a665f0/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99a15921f00b8d3956a66a39bc98c57893a665f0/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=99a15921f00b8d3956a66a39bc98c57893a665f0", "patch": "@@ -2729,9 +2729,9 @@ rest_of_compilation (decl)\n       if (rtl_dump_file)\n \tdump_flow_info (rtl_dump_file);\n \n-      delete_null_pointer_checks (insns);\n+      if (delete_null_pointer_checks (insns))\n+        cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_PRE_LOOP);\n \n-      cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_PRE_LOOP);\n       close_dump_file (DFI_null, print_rtl_with_bb, insns);\n     }\n \n@@ -2775,13 +2775,13 @@ rest_of_compilation (decl)\n       if (tem || optimize > 1)\n \tcleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_PRE_LOOP);\n       /* Try to identify useless null pointer tests and delete them.  */\n-      if (flag_delete_null_pointer_checks || flag_thread_jumps)\n+      if (flag_delete_null_pointer_checks)\n \t{\n \t  timevar_push (TV_JUMP);\n \n \t  if (flag_delete_null_pointer_checks)\n-\t    delete_null_pointer_checks (insns);\n-\t  /* CFG is no longer maintained up-to-date.  */\n+\t    if (delete_null_pointer_checks (insns))\n+\t      cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_PRE_LOOP);\n \t  timevar_pop (TV_JUMP);\n \t}\n \n@@ -2814,7 +2814,6 @@ rest_of_compilation (decl)\n       timevar_push (TV_GCSE);\n       open_dump_file (DFI_gcse, decl);\n \n-      cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_PRE_LOOP);\n       tem = gcse_main (insns, rtl_dump_file);\n       rebuild_jump_labels (insns);\n       delete_trivially_dead_insns (insns, max_reg_num ());"}]}