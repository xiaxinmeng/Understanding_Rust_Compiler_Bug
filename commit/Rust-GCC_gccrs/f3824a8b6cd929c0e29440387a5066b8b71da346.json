{"sha": "f3824a8b6cd929c0e29440387a5066b8b71da346", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjM4MjRhOGI2Y2Q5MjljMGUyOTQ0MDM4N2E1MDY2YjhiNzFkYTM0Ng==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@google.com", "date": "2010-11-08T04:34:32Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2010-11-08T04:34:32Z"}, "message": "re PR target/46089 (ICE: in gen_reg_rtx, at emit-rtl.c:861 with -mcmodel=large -fsplit-stack)\n\ngcc/:\n\tPR target/46089\n\t* config/i386/i386.c (split_stack_fn_large): New static variable.\n\t(ix86_expand_split_stack_prologue): Handle large model.\nlibgcc/:\n\t* config/i386/morestack.S (__morestack_large_model): New\n\tfunction.\n\nFrom-SVN: r166427", "tree": {"sha": "01d2fff5e4ff4189da1309dc99b45cbd714f2464", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/01d2fff5e4ff4189da1309dc99b45cbd714f2464"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f3824a8b6cd929c0e29440387a5066b8b71da346", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3824a8b6cd929c0e29440387a5066b8b71da346", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f3824a8b6cd929c0e29440387a5066b8b71da346", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3824a8b6cd929c0e29440387a5066b8b71da346/comments", "author": null, "committer": null, "parents": [{"sha": "bf8c0c1b63ef70e19c2391610db3a521b60384f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf8c0c1b63ef70e19c2391610db3a521b60384f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bf8c0c1b63ef70e19c2391610db3a521b60384f4"}], "stats": {"total": 124, "additions": 113, "deletions": 11}, "files": [{"sha": "4088046710fccb60931b681b74ed212736c88f3e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3824a8b6cd929c0e29440387a5066b8b71da346/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3824a8b6cd929c0e29440387a5066b8b71da346/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f3824a8b6cd929c0e29440387a5066b8b71da346", "patch": "@@ -1,3 +1,9 @@\n+2010-11-07  Ian Lance Taylor  <iant@google.com>\n+\n+\tPR target/46089\n+\t* config/i386/i386.c (split_stack_fn_large): New static variable.\n+\t(ix86_expand_split_stack_prologue): Handle large model.\n+\n 2010-11-07  Andreas Schwab  <schwab@linux-m68k.org>\n \n \t* config/m68k/m68k.c (m68k_delegitimize_address): Update to handle"}, {"sha": "b4ba2c16627a114c2ff88492f55738350ea4e7c6", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 67, "deletions": 11, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3824a8b6cd929c0e29440387a5066b8b71da346/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3824a8b6cd929c0e29440387a5066b8b71da346/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=f3824a8b6cd929c0e29440387a5066b8b71da346", "patch": "@@ -11050,6 +11050,11 @@ split_stack_prologue_scratch_regno (void)\n \n static GTY(()) rtx split_stack_fn;\n \n+/* A SYMBOL_REF for the more stack function when using the large\n+   model.  */\n+\n+static GTY(()) rtx split_stack_fn_large;\n+\n /* Handle -fsplit-stack.  These are the first instructions in the\n    function, even before the regular prologue.  */\n \n@@ -11062,6 +11067,7 @@ ix86_expand_split_stack_prologue (void)\n   rtx label, limit, current, jump_insn, allocate_rtx, call_insn, call_fusage;\n   rtx scratch_reg = NULL_RTX;\n   rtx varargs_label = NULL_RTX;\n+  rtx fn;\n \n   gcc_assert (flag_split_stack && reload_completed);\n \n@@ -11125,6 +11131,10 @@ ix86_expand_split_stack_prologue (void)\n   add_reg_note (jump_insn, REG_BR_PROB,\n \t\tGEN_INT (REG_BR_PROB_BASE - REG_BR_PROB_BASE / 100));\n \n+  if (split_stack_fn == NULL_RTX)\n+    split_stack_fn = gen_rtx_SYMBOL_REF (Pmode, \"__morestack\");\n+  fn = split_stack_fn;\n+\n   /* Get more stack space.  We pass in the desired stack space and the\n      size of the arguments to copy to the new stack.  In 32-bit mode\n      we push the parameters; __morestack will return on a new stack\n@@ -11135,9 +11145,10 @@ ix86_expand_split_stack_prologue (void)\n   call_fusage = NULL_RTX;\n   if (TARGET_64BIT)\n     {\n-      rtx reg;\n+      rtx reg10, reg11;\n \n-      reg = gen_rtx_REG (Pmode, R10_REG);\n+      reg10 = gen_rtx_REG (Pmode, R10_REG);\n+      reg11 = gen_rtx_REG (Pmode, R11_REG);\n \n       /* If this function uses a static chain, it will be in %r10.\n \t Preserve it across the call to __morestack.  */\n@@ -11146,24 +11157,69 @@ ix86_expand_split_stack_prologue (void)\n \t  rtx rax;\n \n \t  rax = gen_rtx_REG (Pmode, AX_REG);\n-\t  emit_move_insn (rax, reg);\n+\t  emit_move_insn (rax, reg10);\n \t  use_reg (&call_fusage, rax);\n \t}\n \n-      emit_move_insn (reg, allocate_rtx);\n-      use_reg (&call_fusage, reg);\n-      reg = gen_rtx_REG (Pmode, R11_REG);\n-      emit_move_insn (reg, GEN_INT (args_size));\n-      use_reg (&call_fusage, reg);\n+      if (ix86_cmodel == CM_LARGE || ix86_cmodel == CM_LARGE_PIC)\n+\t{\n+\t  HOST_WIDE_INT argval;\n+\n+\t  /* When using the large model we need to load the address\n+\t     into a register, and we've run out of registers.  So we\n+\t     switch to a different calling convention, and we call a\n+\t     different function: __morestack_large.  We pass the\n+\t     argument size in the upper 32 bits of r10 and pass the\n+\t     frame size in the lower 32 bits.  */\n+\t  gcc_assert ((allocate & 0xffffffff) == allocate);\n+\t  gcc_assert (((HOST_WIDE_INT) args_size & 0xffffffff)\n+\t\t      == (HOST_WIDE_INT) args_size);\n+\n+\t  if (split_stack_fn_large == NULL_RTX)\n+\t    split_stack_fn_large =\n+\t      gen_rtx_SYMBOL_REF (Pmode, \"__morestack_large_model\");\n+\n+\t  if (ix86_cmodel == CM_LARGE_PIC)\n+\t    {\n+\t      rtx label, x;\n+\n+\t      label = gen_label_rtx ();\n+\t      emit_label (label);\n+\t      LABEL_PRESERVE_P (label) = 1;\n+\t      emit_insn (gen_set_rip_rex64 (reg10, label));\n+\t      emit_insn (gen_set_got_offset_rex64 (reg11, label));\n+\t      emit_insn (gen_adddi3 (reg10, reg10, reg11));\n+\t      x = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, split_stack_fn_large),\n+\t\t\t\t  UNSPEC_GOT);\n+\t      x = gen_rtx_CONST (Pmode, x);\n+\t      emit_move_insn (reg11, x);\n+\t      x = gen_rtx_PLUS (Pmode, reg10, reg11);\n+\t      x = gen_const_mem (Pmode, x);\n+\t      emit_move_insn (reg11, x);\n+\t    }\n+\t  else\n+\t    emit_move_insn (reg11, split_stack_fn_large);\n+\n+\t  fn = reg11;\n+\n+\t  argval = ((HOST_WIDE_INT) args_size << 32) + allocate;\n+\t  emit_move_insn (reg10, GEN_INT (argval));\n+\t}\n+      else\n+\t{\n+\t  emit_move_insn (reg10, allocate_rtx);\n+\t  emit_move_insn (reg11, GEN_INT (args_size));\n+\t  use_reg (&call_fusage, reg11);\n+\t}\n+\n+      use_reg (&call_fusage, reg10);\n     }\n   else\n     {\n       emit_insn (gen_push (GEN_INT (args_size)));\n       emit_insn (gen_push (allocate_rtx));\n     }\n-  if (split_stack_fn == NULL_RTX)\n-    split_stack_fn = gen_rtx_SYMBOL_REF (Pmode, \"__morestack\");\n-  call_insn = ix86_expand_call (NULL_RTX, gen_rtx_MEM (QImode, split_stack_fn),\n+  call_insn = ix86_expand_call (NULL_RTX, gen_rtx_MEM (QImode, fn),\n \t\t\t\tGEN_INT (UNITS_PER_WORD), constm1_rtx,\n \t\t\t\tNULL_RTX, 0);\n   add_function_usage_to (call_insn, call_fusage);"}, {"sha": "21099ab697d0b73f548e4aaa5389d44645301bf9", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3824a8b6cd929c0e29440387a5066b8b71da346/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3824a8b6cd929c0e29440387a5066b8b71da346/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=f3824a8b6cd929c0e29440387a5066b8b71da346", "patch": "@@ -1,3 +1,9 @@\n+2010-11-07  Ian Lance Taylor  <iant@google.com>\n+\n+\tPR target/46089\n+\t* config/i386/morestack.S (__morestack_large_model): New\n+\tfunction.\n+\n 2010-10-23  Nathan Froyd  <froydnj@codesourcery.com>\n \n \t* config/libbid/bid_gcc_intrinsics.h (LIBGCC2_WORDS_BIG_ENDIAN):"}, {"sha": "10fa1fdf73a47391ca6f1d906c0a1c4ed9c683c2", "filename": "libgcc/config/i386/morestack.S", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3824a8b6cd929c0e29440387a5066b8b71da346/libgcc%2Fconfig%2Fi386%2Fmorestack.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3824a8b6cd929c0e29440387a5066b8b71da346/libgcc%2Fconfig%2Fi386%2Fmorestack.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fi386%2Fmorestack.S?ref=f3824a8b6cd929c0e29440387a5066b8b71da346", "patch": "@@ -488,6 +488,40 @@ DW.ref.__gcc_personality_v0:\n #endif\n #endif\n \n+#ifdef __x86_64__\n+\n+# This entry point is used for the large model.  With this entry point\n+# the upper 32 bits of %r10 hold the argument size and the lower 32\n+# bits hold the new stack frame size.  There doesn't seem to be a way\n+# to know in the assembler code that we are assembling for the large\n+# model, and there doesn't seem to be a large model multilib anyhow.\n+# If one is developed, then the non-PIC code is probably OK since we\n+# will probably be close to the morestack code, but the PIC code\n+# almost certainly needs to be changed.  FIXME.\n+\n+\t.text\n+\t.global\t__morestack_large_model\n+\t.hidden\t__morestack_large_model\n+\n+#ifdef __ELF__\n+\t.type\t__morestack_large_model,@function\n+#endif\n+\n+__morestack_large_model:\n+\n+\t.cfi_startproc\n+\n+\tmovq\t%r10, %r11\n+\tandl\t$0xffffffff, %r10d\n+\tsarq\t$32, %r11\n+\tjmp\t__morestack\n+\n+\t.cfi_endproc\n+#ifdef __ELF__\n+       .size\t__morestack_large_model, . - __morestack_large_model\n+#endif\n+\n+#endif /* __x86_64__ */\n \n # Initialize the stack test value when the program starts or when a\n # new thread starts.  We don't know how large the main stack is, so we"}]}