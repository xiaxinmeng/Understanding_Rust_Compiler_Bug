{"sha": "aa6d2be1e3455a5f0818d5bd6a44b15a55a39df5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWE2ZDJiZTFlMzQ1NWE1ZjA4MThkNWJkNmE0NGIxNWE1NWEzOWRmNQ==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-10-19T16:56:54Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-10-19T17:06:51Z"}, "message": "libstdc++: Optimize container node-handle type for size\n\nThe use of std::optional in _Node_handle makes the node handle types for\nassociative and unordered containers larger than necessary. It also\ngreatly increases the amount of code included, as <optional> is quite\nlarge.\n\nThe boolean flag that records whether the std::optional contains a value\nis redundant, because the _Node_handle::_M_ptr member provides the same\ninformation. If the node handle has a non-null pointer it also has an\nallocator, and not otherwise. By replacing std::optional with a custom\nunion type (and using _M_ptr to tell which union member is active) all\nnode handle sizes can be reduced by sizeof(allocator_type::pointer).\n\nThis makes the node handle types incompatible with previous releases, so\nmust be done before the C++17 ABI is fixed for GCC 11.\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/bits/node_handle.h (_Node_handle_common): Replace\n\tstd::optional with custom type.\n\t* testsuite/20_util/variant/exception_safety.cc: Add missing\n\theader include.", "tree": {"sha": "c8a40f330e254694f872eb33da58e496626c1d26", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c8a40f330e254694f872eb33da58e496626c1d26"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aa6d2be1e3455a5f0818d5bd6a44b15a55a39df5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa6d2be1e3455a5f0818d5bd6a44b15a55a39df5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa6d2be1e3455a5f0818d5bd6a44b15a55a39df5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa6d2be1e3455a5f0818d5bd6a44b15a55a39df5/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5abe05b4331250b6a7798ce87c0a82adc2bd70f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5abe05b4331250b6a7798ce87c0a82adc2bd70f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5abe05b4331250b6a7798ce87c0a82adc2bd70f3"}], "stats": {"total": 152, "additions": 114, "deletions": 38}, "files": [{"sha": "82b702426d1fa297faf1419bc2d0c5338b8f00cd", "filename": "libstdc++-v3/include/bits/node_handle.h", "status": "modified", "additions": 113, "deletions": 38, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa6d2be1e3455a5f0818d5bd6a44b15a55a39df5/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fnode_handle.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa6d2be1e3455a5f0818d5bd6a44b15a55a39df5/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fnode_handle.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fnode_handle.h?ref=aa6d2be1e3455a5f0818d5bd6a44b15a55a39df5", "patch": "@@ -33,10 +33,10 @@\n \n #pragma GCC system_header\n \n-#if __cplusplus > 201402L\n+#if __cplusplus >= 201703L\n # define __cpp_lib_node_extract 201606\n \n-#include <optional>\n+#include <new>\n #include <bits/alloc_traits.h>\n #include <bits/ptr_traits.h>\n \n@@ -57,84 +57,159 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       get_allocator() const noexcept\n       {\n \t__glibcxx_assert(!this->empty());\n-\treturn allocator_type(*_M_alloc);\n+\treturn allocator_type(_M_alloc._M_alloc);\n       }\n \n       explicit operator bool() const noexcept { return _M_ptr != nullptr; }\n \n       [[nodiscard]] bool empty() const noexcept { return _M_ptr == nullptr; }\n \n     protected:\n-      constexpr _Node_handle_common() noexcept : _M_ptr(), _M_alloc() {}\n+      constexpr _Node_handle_common() noexcept : _M_ptr() { }\n \n-      ~_Node_handle_common() { _M_destroy(); }\n+      ~_Node_handle_common()\n+      {\n+\tif (!empty())\n+\t  _M_reset();\n+      }\n \n       _Node_handle_common(_Node_handle_common&& __nh) noexcept\n-      : _M_ptr(__nh._M_ptr), _M_alloc(std::move(__nh._M_alloc))\n+      : _M_ptr(__nh._M_ptr)\n       {\n-\t__nh._M_ptr = nullptr;\n-\t__nh._M_alloc = nullopt;\n+\tif (_M_ptr)\n+\t  _M_move(std::move(__nh));\n       }\n \n       _Node_handle_common&\n       operator=(_Node_handle_common&& __nh) noexcept\n       {\n-\t_M_destroy();\n-\t_M_ptr = __nh._M_ptr;\n-\tif constexpr (is_move_assignable_v<_NodeAlloc>)\n+\tif (empty())\n \t  {\n-\t    if (_AllocTraits::propagate_on_container_move_assignment::value\n-\t\t|| !this->_M_alloc)\n-\t      this->_M_alloc = std::move(__nh._M_alloc);\n-\t    else\n-\t      {\n-\t\t__glibcxx_assert(this->_M_alloc == __nh._M_alloc);\n-\t      }\n+\t    if (!__nh.empty())\n+\t      _M_move(std::move(__nh));\n \t  }\n+\telse if (__nh.empty())\n+\t  _M_reset();\n \telse\n \t  {\n-\t    __glibcxx_assert(_M_alloc);\n+\t    // Free the current node before replacing the allocator.\n+\t    _AllocTraits::destroy(*_M_alloc, _M_ptr->_M_valptr());\n+\t    _AllocTraits::deallocate(*_M_alloc, _M_ptr, 1);\n+\n+\t    _M_alloc = __nh._M_alloc.release(); // assigns if POCMA\n+\t    _M_ptr = __nh._M_ptr;\n+\t    __nh._M_ptr = nullptr;\n \t  }\n-\t__nh._M_ptr = nullptr;\n-\t__nh._M_alloc = nullopt;\n \treturn *this;\n       }\n \n       _Node_handle_common(typename _AllocTraits::pointer __ptr,\n \t\t\t  const _NodeAlloc& __alloc)\n-      : _M_ptr(__ptr), _M_alloc(__alloc) { }\n+      : _M_ptr(__ptr), _M_alloc(__alloc)\n+      {\n+\t__glibcxx_assert(__ptr != nullptr);\n+      }\n \n       void\n       _M_swap(_Node_handle_common& __nh) noexcept\n       {\n-\tusing std::swap;\n-\tswap(_M_ptr, __nh._M_ptr);\n-\tif (_AllocTraits::propagate_on_container_swap::value\n-\t    || !_M_alloc || !__nh._M_alloc)\n-\t  _M_alloc.swap(__nh._M_alloc);\n+\tif (empty())\n+\t  {\n+\t    if (!__nh.empty())\n+\t      _M_move(std::move(__nh));\n+\t  }\n+\telse if (__nh.empty())\n+\t  __nh._M_move(std::move(*this));\n \telse\n \t  {\n-\t    __glibcxx_assert(_M_alloc == __nh._M_alloc);\n+\t    using std::swap;\n+\t    swap(_M_ptr, __nh._M_ptr);\n+\t    _M_alloc.swap(__nh._M_alloc); // swaps if POCS\n \t  }\n       }\n \n     private:\n+      // Moves the pointer and allocator from __nh to *this.\n+      // Precondition: empty() && !__nh.empty()\n+      // Postcondition: !empty() && __nh.empty()\n       void\n-      _M_destroy() noexcept\n+      _M_move(_Node_handle_common&& __nh) noexcept\n       {\n-\tif (_M_ptr != nullptr)\n-\t  {\n-\t    allocator_type __alloc(*_M_alloc);\n-\t    allocator_traits<allocator_type>::destroy(__alloc,\n-\t\t\t\t\t\t      _M_ptr->_M_valptr());\n-\t    _AllocTraits::deallocate(*_M_alloc, _M_ptr, 1);\n-\t  }\n+\t::new (std::__addressof(_M_alloc)) _NodeAlloc(__nh._M_alloc.release());\n+\t_M_ptr = __nh._M_ptr;\n+\t__nh._M_ptr = nullptr;\n+      }\n+\n+      // Deallocates the node, destroys the allocator.\n+      // Precondition: !empty()\n+      // Postcondition: empty()\n+      void\n+      _M_reset() noexcept\n+      {\n+\t_NodeAlloc __alloc = _M_alloc.release();\n+\t_AllocTraits::destroy(__alloc, _M_ptr->_M_valptr());\n+\t_AllocTraits::deallocate(__alloc, _M_ptr, 1);\n+\t_M_ptr = nullptr;\n       }\n \n     protected:\n-      typename _AllocTraits::pointer\t_M_ptr;\n+      typename _AllocTraits::pointer _M_ptr;\n+\n     private:\n-      optional<_NodeAlloc>\t\t_M_alloc;\n+      // A simplified, non-copyable std::optional<_NodeAlloc>.\n+      // Call release() before destruction iff the allocator member is active.\n+      union _Optional_alloc\n+      {\n+\t_Optional_alloc() { }\n+\t~_Optional_alloc() { }\n+\n+\t_Optional_alloc(_Optional_alloc&&) = delete;\n+\t_Optional_alloc& operator=(_Optional_alloc&&) = delete;\n+\n+\t_Optional_alloc(const _NodeAlloc& __alloc) noexcept\n+\t: _M_alloc(__alloc)\n+\t{ }\n+\n+\t// Precondition: _M_alloc is the active member of the union.\n+\tvoid\n+\toperator=(_NodeAlloc&& __alloc) noexcept\n+\t{\n+\t  using _ATr = _AllocTraits;\n+\t  if constexpr (_ATr::propagate_on_container_move_assignment::value)\n+\t    _M_alloc = std::move(__alloc);\n+\t  else if constexpr (!_AllocTraits::is_always_equal::value)\n+\t    __glibcxx_assert(_M_alloc == __alloc);\n+\t}\n+\n+\t// Precondition: _M_alloc is the active member of both unions.\n+\tvoid\n+\tswap(_Optional_alloc& __other) noexcept\n+\t{\n+\t  using std::swap;\n+\t  if constexpr (_AllocTraits::propagate_on_container_swap::value)\n+\t    swap(_M_alloc, __other._M_alloc);\n+\t  else if constexpr (!_AllocTraits::is_always_equal::value)\n+\t    __glibcxx_assert(_M_alloc == __other._M_alloc);\n+\t}\n+\n+\t// Precondition: _M_alloc is the active member of the union.\n+\t_NodeAlloc& operator*() noexcept { return _M_alloc; }\n+\n+\t// Precondition: _M_alloc is the active member of the union.\n+\t_NodeAlloc release() noexcept\n+\t{\n+\t  _NodeAlloc __tmp = std::move(_M_alloc);\n+\t  _M_alloc.~_NodeAlloc();\n+\t  return __tmp;\n+\t}\n+\n+\tstruct _Empty { };\n+\n+\t[[__no_unique_address__]] _Empty     _M_empty;\n+\t[[__no_unique_address__]] _NodeAlloc _M_alloc;\n+      };\n+\n+      [[__no_unique_address__]] _Optional_alloc _M_alloc;\n \n       template<typename _Key2, typename _Value2, typename _KeyOfValue,\n \t       typename _Compare, typename _ValueAlloc>"}, {"sha": "c96b921259250ed8096cfa185c44f977a47d15ba", "filename": "libstdc++-v3/testsuite/20_util/variant/exception_safety.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa6d2be1e3455a5f0818d5bd6a44b15a55a39df5/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fvariant%2Fexception_safety.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa6d2be1e3455a5f0818d5bd6a44b15a55a39df5/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fvariant%2Fexception_safety.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fvariant%2Fexception_safety.cc?ref=aa6d2be1e3455a5f0818d5bd6a44b15a55a39df5", "patch": "@@ -25,6 +25,7 @@\n #include <memory>\n #include <functional>\n #include <any>\n+#include <optional>\n #include <testsuite_hooks.h>\n \n void"}]}