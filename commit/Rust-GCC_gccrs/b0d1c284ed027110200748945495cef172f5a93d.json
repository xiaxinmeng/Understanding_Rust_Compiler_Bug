{"sha": "b0d1c284ed027110200748945495cef172f5a93d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjBkMWMyODRlZDAyNzExMDIwMDc0ODk0NTQ5NWNlZjE3MmY1YTkzZA==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@net-b.de", "date": "2011-05-03T21:35:44Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2011-05-03T21:35:44Z"}, "message": "re PR fortran/18918 (Eventually support Fortran 2008's coarrays [co-arrays])\n\n2011-05-03  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/18918\n        * gfortran.dg/coarray/caf.dg: New.\n        * gfortran.dg/coarray/image_index_1.f90: New, copied\n        from ../coarray_16.f90.\n\nFrom-SVN: r173341", "tree": {"sha": "8e1ebc8781ec1d21bd6454d54613896e6e987951", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8e1ebc8781ec1d21bd6454d54613896e6e987951"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b0d1c284ed027110200748945495cef172f5a93d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0d1c284ed027110200748945495cef172f5a93d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b0d1c284ed027110200748945495cef172f5a93d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0d1c284ed027110200748945495cef172f5a93d/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6ac00218e10463af6597fb22e942601fd3751fad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ac00218e10463af6597fb22e942601fd3751fad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ac00218e10463af6597fb22e942601fd3751fad"}], "stats": {"total": 182, "additions": 182, "deletions": 0}, "files": [{"sha": "5ce6d37ad1c4332c020c412c6f4abb786b840c37", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0d1c284ed027110200748945495cef172f5a93d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0d1c284ed027110200748945495cef172f5a93d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b0d1c284ed027110200748945495cef172f5a93d", "patch": "@@ -1,3 +1,10 @@\n+2011-05-03  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/18918\n+\t* gfortran.dg/coarray/caf.dg: New.\n+\t* gfortran.dg/coarray/image_index_1.f90: New, copied\n+\tfrom ../coarray_16.f90.\n+\n 2011-05-03  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/28501"}, {"sha": "c7e46f6bedcd75a65240bf23fc0bb17b0ad68110", "filename": "gcc/testsuite/gfortran.dg/coarray/caf.exp", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0d1c284ed027110200748945495cef172f5a93d/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fcaf.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0d1c284ed027110200748945495cef172f5a93d/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fcaf.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fcaf.exp?ref=b0d1c284ed027110200748945495cef172f5a93d", "patch": "@@ -0,0 +1,76 @@\n+# Copyright (C) 2011 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+#\n+# Contributed by Tobias Burnus <burnus@net-b.de>\n+\n+\n+# Test coarray support.\n+#\n+# For the compilation tests, all files are compiles with the\n+# option -fcoarray=single and with -fcoarray=lib\n+#\n+# For the link and execution tests, for -fcoarray=lib the\n+# libcaf_single library is linked. Additionally, with the\n+# required settings another CAF library is used.\n+\n+# Load procedures from common libraries. \n+load_lib gfortran-dg.exp\n+\n+# If a testcase doesn't have special options, use these.\n+global DEFAULT_FFLAGS\n+if ![info exists DEFAULT_FFLAGS] then {\n+    set DEFAULT_FFLAGS \" -pedantic-errors\"\n+}\n+\n+dg-init\n+\n+global runtests\n+global DG_TORTURE_OPTIONS torture_with_loops\n+\n+torture-init\n+set-torture-options $DG_TORTURE_OPTIONS\n+\n+# Main loop.\n+foreach test [lsort [glob -nocomplain $srcdir/$subdir/*.\\[fF\\]{,90,95,03,08} ]] {\n+    # If we're only testing specific files and this isn't one of them, skip it.\n+    if ![runtest_file_p $runtests $test] then {\n+\tcontinue\n+    }\n+\n+# Enable if you want to test several options:\n+#    # look if this is dg-do-run test, in which case\n+#    # we cycle through the option list, otherwise we don't\n+#    if [expr [search_for $test \"dg-do run\"]] {\n+#\tset option_list $torture_with_loops\n+#    } else {\n+#\tset option_list [list { -O } ]\n+#    }\n+    set option_list [list { -O2 } ]\n+\n+    set nshort [file tail [file dirname $test]]/[file tail $test]\n+\n+    foreach flags $option_list {\n+\tverbose \"Testing $nshort (single), $flags\" 1\n+\tdg-test $test \"-fcoarray=single $flags\" \"\" \n+    }\n+\n+    foreach flags $option_list {\n+\tverbose \"Testing $nshort (libcaf_single), $flags\" 1\n+\tdg-test $test \"-fcoarray=lib $flags -lcaf_single\" \"\"\n+    }\n+}\n+torture-finish\n+dg-finish"}, {"sha": "00e5e09a74f31eae7bffcb20280932a38627311d", "filename": "gcc/testsuite/gfortran.dg/coarray/image_index_1.f90", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0d1c284ed027110200748945495cef172f5a93d/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fimage_index_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0d1c284ed027110200748945495cef172f5a93d/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fimage_index_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fimage_index_1.f90?ref=b0d1c284ed027110200748945495cef172f5a93d", "patch": "@@ -0,0 +1,99 @@\n+! { dg-do run }\n+!\n+! Run-time test for IMAGE_INDEX with cobounds only known at\n+! the compile time, suitable for any number of NUM_IMAGES()\n+! For compile-time cobounds, the -fcoarray=lib version still\n+! needs to run-time evalulation if image_index returns > 1\n+! as image_index is 0 if the index would exceed num_images().\n+!\n+! Please set num_images() to >= 13, if possible.\n+!\n+! PR fortran/18918\n+!\n+\n+program test_image_index\n+implicit none\n+integer :: index1, index2, index3\n+logical :: one\n+\n+integer, allocatable :: a(:)[:,:,:], b(:)[:,:], c(:,:)[:]\n+integer, save :: d(2)[-1:3, *]\n+integer, save :: e(2)[-1:-1, 3:*]\n+\n+one = num_images() == 1\n+\n+allocate(a(1)[3:3, -4:-3, 88:*])\n+allocate(b(2)[-1:0,0:*])\n+allocate(c(3,3)[*])\n+\n+index1 = image_index(a, [3, -4, 88] )\n+index2 = image_index(b, [-1, 0] )\n+index3 = image_index(c, [1] )\n+if (index1 /= 1 .or. index2 /= 1 .or. index3 /= 1) call abort()\n+\n+\n+index1 = image_index(a, [3, -3, 88] )\n+index2 = image_index(b, [0, 0] )\n+index3 = image_index(c, [2] )\n+\n+if (one .and. (index1 /= 0 .or. index2 /= 0 .or. index3 /= 0)) &\n+  call abort()\n+if (.not. one .and. (index1 /= 2 .or. index2 /= 2 .or. index3 /= 2)) &\n+  call abort()\n+\n+\n+index1 = image_index(d, [-1, 1] )\n+index2 = image_index(d, [0, 1] )\n+\n+if (one .and. (index1 /= 1 .or. index2 /= 0)) &\n+  call abort()\n+if (.not. one .and. (index1 /= 1 .or. index2 /= 2)) &\n+  call abort()\n+\n+index1 = image_index(e, [-1, 3] )\n+index2 = image_index(e, [-1, 4] )\n+\n+if (one .and. (index1 /= 1 .or. index2 /= 0)) &\n+  call abort()\n+if (.not. one .and. (index1 /= 1 .or. index2 /= 2)) &\n+  call abort()\n+\n+call test(1, a,b,c)\n+\n+! The following test is in honour of the F2008 standard:\n+deallocate(a)\n+allocate(a (10) [10, 0:9, 0:*])\n+\n+index1 = image_index(a, [1, 0, 0] )\n+index2 = image_index(a, [3, 1, 2] )  ! = 213, yeah!\n+index3 = image_index(a, [3, 1, 0] )  ! = 13\n+\n+if (num_images() < 13 .and. (index1 /= 1 .or. index2 /= 0 .or. index3 /= 0)) &\n+  call abort()\n+if (num_images() >= 213 .and. (index1 /= 1 .or. index2 /= 213 .or. index3 /= 13)) &\n+  call abort()\n+if (num_images() >= 13 .and. (index1 /= 1 .or. index2 /= 0 .or. index3 /= 13)) &\n+  call abort()\n+\n+\n+contains\n+subroutine test(n, a, b, c)\n+  integer :: n\n+  integer :: a(1)[3*n:3*n, -4*n:-3*n, 88*n:*], b(2)[-1*n:0*n,0*n:*], c(3*n,3*n)[*]\n+\n+  index1 = image_index(a, [3, -4, 88] )\n+  index2 = image_index(b, [-1, 0] )\n+  index3 = image_index(c, [1] )\n+  if (index1 /= 1 .or. index2 /= 1 .or. index3 /= 1) call abort()\n+\n+\n+  index1 = image_index(a, [3, -3, 88] )\n+  index2 = image_index(b, [0, 0] )\n+  index3 = image_index(c, [2] )\n+\n+  if (one .and. (index1 /= 0 .or. index2 /= 0 .or. index3 /= 0)) &\n+    call abort()\n+  if (.not. one .and. (index1 /= 2 .or. index2 /= 2 .or. index3 /= 2)) &\n+    call abort()\n+end subroutine test\n+end program test_image_index"}]}