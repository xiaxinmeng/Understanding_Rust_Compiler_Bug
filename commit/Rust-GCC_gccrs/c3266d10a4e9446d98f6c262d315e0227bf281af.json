{"sha": "c3266d10a4e9446d98f6c262d315e0227bf281af", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzMyNjZkMTBhNGU5NDQ2ZDk4ZjZjMjYyZDMxNWUwMjI3YmYyODFhZg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-01-03T07:17:39Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-01-03T07:17:39Z"}, "message": "poly_int: subreg_get_info\n\nThis patch makes subreg_get_info handle polynomial sizes.\n\n2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* rtlanal.c (subreg_get_info): Handle polynomial mode sizes.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r256150", "tree": {"sha": "8678c11c6b10809738b276ed45089f17b0fc7b97", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8678c11c6b10809738b276ed45089f17b0fc7b97"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c3266d10a4e9446d98f6c262d315e0227bf281af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3266d10a4e9446d98f6c262d315e0227bf281af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c3266d10a4e9446d98f6c262d315e0227bf281af", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3266d10a4e9446d98f6c262d315e0227bf281af/comments", "author": null, "committer": null, "parents": [{"sha": "fad2288b4b1e63fce8550d70f99bcc16e54bf539", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fad2288b4b1e63fce8550d70f99bcc16e54bf539", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fad2288b4b1e63fce8550d70f99bcc16e54bf539"}], "stats": {"total": 40, "additions": 25, "deletions": 15}, "files": [{"sha": "e7901e52116e6a0f95cf9eca0f6cdde6cc02ac0f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3266d10a4e9446d98f6c262d315e0227bf281af/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3266d10a4e9446d98f6c262d315e0227bf281af/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c3266d10a4e9446d98f6c262d315e0227bf281af", "patch": "@@ -1,3 +1,9 @@\n+2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* rtlanal.c (subreg_get_info): Handle polynomial mode sizes.\n+\n 2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "89c8816fbb913b91acacd92a1ca1ec4d263daa6a", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3266d10a4e9446d98f6c262d315e0227bf281af/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3266d10a4e9446d98f6c262d315e0227bf281af/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=c3266d10a4e9446d98f6c262d315e0227bf281af", "patch": "@@ -3694,8 +3694,9 @@ subreg_get_info (unsigned int xregno, machine_mode xmode,\n \n   gcc_assert (xregno < FIRST_PSEUDO_REGISTER);\n \n-  unsigned int xsize = GET_MODE_SIZE (xmode);\n-  unsigned int ysize = GET_MODE_SIZE (ymode);\n+  poly_uint64 xsize = GET_MODE_SIZE (xmode);\n+  poly_uint64 ysize = GET_MODE_SIZE (ymode);\n+\n   bool rknown = false;\n \n   /* If the register representation of a non-scalar mode has holes in it,\n@@ -3707,6 +3708,7 @@ subreg_get_info (unsigned int xregno, machine_mode xmode,\n       /* As a consequence, we must be dealing with a constant number of\n \t scalars, and thus a constant offset.  */\n       HOST_WIDE_INT coffset = offset.to_constant ();\n+      HOST_WIDE_INT cysize = ysize.to_constant ();\n       nregs_xmode = HARD_REGNO_NREGS_WITH_PADDING (xregno, xmode);\n       unsigned int nunits = GET_MODE_NUNITS (xmode);\n       scalar_mode xmode_unit = GET_MODE_INNER (xmode);\n@@ -3727,7 +3729,7 @@ subreg_get_info (unsigned int xregno, machine_mode xmode,\n \t of each unit.  */\n       if ((coffset / GET_MODE_SIZE (xmode_unit) + 1 < nunits)\n \t  && (coffset / GET_MODE_SIZE (xmode_unit)\n-\t      != ((coffset + ysize - 1) / GET_MODE_SIZE (xmode_unit))))\n+\t      != ((coffset + cysize - 1) / GET_MODE_SIZE (xmode_unit))))\n \t{\n \t  info->representable_p = false;\n \t  rknown = true;\n@@ -3738,8 +3740,12 @@ subreg_get_info (unsigned int xregno, machine_mode xmode,\n \n   nregs_ymode = hard_regno_nregs (xregno, ymode);\n \n+  /* Subreg sizes must be ordered, so that we can tell whether they are\n+     partial, paradoxical or complete.  */\n+  gcc_checking_assert (ordered_p (xsize, ysize));\n+\n   /* Paradoxical subregs are otherwise valid.  */\n-  if (!rknown && known_eq (offset, 0U) && ysize > xsize)\n+  if (!rknown && known_eq (offset, 0U) && maybe_gt (ysize, xsize))\n     {\n       info->representable_p = true;\n       /* If this is a big endian paradoxical subreg, which uses more\n@@ -3761,20 +3767,19 @@ subreg_get_info (unsigned int xregno, machine_mode xmode,\n \n   /* If registers store different numbers of bits in the different\n      modes, we cannot generally form this subreg.  */\n+  poly_uint64 regsize_xmode, regsize_ymode;\n   if (!HARD_REGNO_NREGS_HAS_PADDING (xregno, xmode)\n       && !HARD_REGNO_NREGS_HAS_PADDING (xregno, ymode)\n-      && (xsize % nregs_xmode) == 0\n-      && (ysize % nregs_ymode) == 0)\n+      && multiple_p (xsize, nregs_xmode, &regsize_xmode)\n+      && multiple_p (ysize, nregs_ymode, &regsize_ymode))\n     {\n-      int regsize_xmode = xsize / nregs_xmode;\n-      int regsize_ymode = ysize / nregs_ymode;\n       if (!rknown\n-\t  && ((nregs_ymode > 1 && regsize_xmode > regsize_ymode)\n-\t      || (nregs_xmode > 1 && regsize_ymode > regsize_xmode)))\n+\t  && ((nregs_ymode > 1 && maybe_gt (regsize_xmode, regsize_ymode))\n+\t      || (nregs_xmode > 1 && maybe_gt (regsize_ymode, regsize_xmode))))\n \t{\n \t  info->representable_p = false;\n-\t  info->nregs = CEIL (ysize, regsize_xmode);\n-\t  if (!can_div_trunc_p (offset, regsize_xmode, &info->offset))\n+\t  if (!can_div_away_from_zero_p (ysize, regsize_xmode, &info->nregs)\n+\t      || !can_div_trunc_p (offset, regsize_xmode, &info->offset))\n \t    /* Checked by validate_subreg.  We must know at compile time\n \t       which inner registers are being accessed.  */\n \t    gcc_unreachable ();\n@@ -3800,7 +3805,7 @@ subreg_get_info (unsigned int xregno, machine_mode xmode,\n       HOST_WIDE_INT count;\n       if (!rknown\n \t  && WORDS_BIG_ENDIAN == REG_WORDS_BIG_ENDIAN\n-\t  && regsize_xmode == regsize_ymode\n+\t  && known_eq (regsize_xmode, regsize_ymode)\n \t  && constant_multiple_p (offset, regsize_ymode, &count))\n \t{\n \t  info->representable_p = true;\n@@ -3837,8 +3842,7 @@ subreg_get_info (unsigned int xregno, machine_mode xmode,\n      be exact, otherwise we don't know how to verify the constraint.\n      These conditions may be relaxed but subreg_regno_offset would\n      need to be redesigned.  */\n-  gcc_assert ((xsize % num_blocks) == 0);\n-  poly_uint64 bytes_per_block = xsize / num_blocks;\n+  poly_uint64 bytes_per_block = exact_div (xsize, num_blocks);\n \n   /* Get the number of the first block that contains the subreg and the byte\n      offset of the subreg from the start of that block.  */"}]}