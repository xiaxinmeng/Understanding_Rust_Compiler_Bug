{"sha": "329417d775102803e0321b95ba932a64870ba677", "node_id": "C_kwDOANBUbNoAKDMyOTQxN2Q3NzUxMDI4MDNlMDMyMWI5NWJhOTMyYTY0ODcwYmE2Nzc", "commit": {"author": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2022-05-25T10:33:34Z"}, "committer": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2022-05-25T11:12:53Z"}, "message": "d: add more 'final' and 'override' to gcc/d/*.cc 'visit' impls\n\nThe first round of adding these missed several more cases in other\nfiles where the Visitor pattern is used in the D front-end.\n\ngcc/d/ChangeLog:\n\n\t* expr.cc: Add \"final\" and \"override\" to all \"visit\" vfunc decls\n\tas appropriate.\n\t* imports.cc: Likewise.\n\t* typeinfo.cc: Likewise.\n\nSigned-off-by: Iain Buclaw <ibuclaw@gdcproject.org>", "tree": {"sha": "c4493acf79e7d912d2f8db43f382239a1e91091a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c4493acf79e7d912d2f8db43f382239a1e91091a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/329417d775102803e0321b95ba932a64870ba677", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/329417d775102803e0321b95ba932a64870ba677", "html_url": "https://github.com/Rust-GCC/gccrs/commit/329417d775102803e0321b95ba932a64870ba677", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/329417d775102803e0321b95ba932a64870ba677/comments", "author": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "19aec65ae13c991d76d29076f4088c0a065e241b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19aec65ae13c991d76d29076f4088c0a065e241b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/19aec65ae13c991d76d29076f4088c0a065e241b"}], "stats": {"total": 158, "additions": 79, "deletions": 79}, "files": [{"sha": "7edcbc47abc6f2310ba4b4dac60109265982eca2", "filename": "gcc/d/expr.cc", "status": "modified", "additions": 55, "deletions": 55, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/329417d775102803e0321b95ba932a64870ba677/gcc%2Fd%2Fexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/329417d775102803e0321b95ba932a64870ba677/gcc%2Fd%2Fexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fexpr.cc?ref=329417d775102803e0321b95ba932a64870ba677", "patch": "@@ -234,7 +234,7 @@ class ExprVisitor : public Visitor\n   /* Visitor interfaces, each Expression class should have\n      overridden the default.  */\n \n-  void visit (Expression *)\n+  void visit (Expression *) final override\n   {\n     gcc_unreachable ();\n   }\n@@ -243,7 +243,7 @@ class ExprVisitor : public Visitor\n      expression is void, then the resulting type is void.  Otherwise\n      they are implicitly converted to a common type.  */\n \n-  void visit (CondExp *e)\n+  void visit (CondExp *e) final override\n   {\n     tree cond = convert_for_condition (build_expr (e->econd),\n \t\t\t\t       e->econd->type);\n@@ -263,7 +263,7 @@ class ExprVisitor : public Visitor\n      usual conversions to bring them to a common type before comparison.\n      The result type is bool.  */\n \n-  void visit (IdentityExp *e)\n+  void visit (IdentityExp *e) final override\n   {\n     tree_code code = (e->op == EXP::identity) ? EQ_EXPR : NE_EXPR;\n     Type *tb1 = e->e1->type->toBasetype ();\n@@ -328,7 +328,7 @@ class ExprVisitor : public Visitor\n      equality or inequality.  Operands go through the usual conversions to bring\n      them to a common type before comparison.  The result type is bool.  */\n \n-  void visit (EqualExp *e)\n+  void visit (EqualExp *e) final override\n   {\n     Type *tb1 = e->e1->type->toBasetype ();\n     Type *tb2 = e->e2->type->toBasetype ();\n@@ -475,7 +475,7 @@ class ExprVisitor : public Visitor\n      exists in an associative array.  The result is a pointer to the\n      element, or null if false.  */\n \n-  void visit (InExp *e)\n+  void visit (InExp *e) final override\n   {\n     Type *tb2 = e->e2->type->toBasetype ();\n     Type *tkey = tb2->isTypeAArray ()->index->toBasetype ();\n@@ -490,7 +490,7 @@ class ExprVisitor : public Visitor\n \n   /* Build a relational expression.  The result type is bool.  */\n \n-  void visit (CmpExp *e)\n+  void visit (CmpExp *e) final override\n   {\n     Type *tb1 = e->e1->type->toBasetype ();\n     Type *tb2 = e->e2->type->toBasetype ();\n@@ -539,7 +539,7 @@ class ExprVisitor : public Visitor\n      expression is void, then the resulting type is void.  Otherwise the\n      result is bool.  */\n \n-  void visit (LogicalExp *e)\n+  void visit (LogicalExp *e) final override\n   {\n     tree_code code = (e->op == EXP::andAnd) ? TRUTH_ANDIF_EXPR : TRUTH_ORIF_EXPR;\n \n@@ -571,7 +571,7 @@ class ExprVisitor : public Visitor\n   /* Build a binary operand expression.  Operands go through usual arithmetic\n      conversions to bring them to a common type before evaluating.  */\n \n-  void visit (BinExp *e)\n+  void visit (BinExp *e) final override\n   {\n     tree_code code;\n \n@@ -666,7 +666,7 @@ class ExprVisitor : public Visitor\n      same type, producing a dynamic array with the result.  If one operand\n      is an element type, that element is converted to an array of length 1.  */\n \n-  void visit (CatExp *e)\n+  void visit (CatExp *e) final override\n   {\n     Type *tb1 = e->e1->type->toBasetype ();\n     Type *tb2 = e->e2->type->toBasetype ();\n@@ -745,7 +745,7 @@ class ExprVisitor : public Visitor\n   /* Build an assignment operator expression.  The right operand is implicitly\n      converted to the type of the left operand, and assigned to it.  */\n \n-  void visit (BinAssignExp *e)\n+  void visit (BinAssignExp *e) final override\n   {\n     tree_code code;\n     Expression *e1b = e->e1;\n@@ -818,7 +818,7 @@ class ExprVisitor : public Visitor\n   /* Build a concat assignment expression.  The right operand is appended\n      to the left operand.  */\n \n-  void visit (CatAssignExp *e)\n+  void visit (CatAssignExp *e) final override\n   {\n     Type *tb1 = e->e1->type->toBasetype ();\n     Type *tb2 = e->e2->type->toBasetype ();\n@@ -861,7 +861,7 @@ class ExprVisitor : public Visitor\n   /* Build an assignment expression.  The right operand is implicitly\n      converted to the type of the left operand, and assigned to it.  */\n \n-  void visit (AssignExp *e)\n+  void visit (AssignExp *e) final override\n   {\n     /* First, handle special assignment semantics.  */\n \n@@ -1146,15 +1146,15 @@ class ExprVisitor : public Visitor\n \n   /* Build a throw expression.  */\n \n-  void visit (ThrowExp *e)\n+  void visit (ThrowExp *e) final override\n   {\n     tree arg = build_expr_dtor (e->e1);\n     this->result_ = build_libcall (LIBCALL_THROW, Type::tvoid, 1, arg);\n   }\n \n   /* Build a postfix expression.  */\n \n-  void visit (PostExp *e)\n+  void visit (PostExp *e) final override\n   {\n     tree result;\n \n@@ -1177,7 +1177,7 @@ class ExprVisitor : public Visitor\n \n   /* Build an index expression.  */\n \n-  void visit (IndexExp *e)\n+  void visit (IndexExp *e) final override\n   {\n     Type *tb1 = e->e1->type->toBasetype ();\n \n@@ -1254,7 +1254,7 @@ class ExprVisitor : public Visitor\n \n   /* Build a comma expression.  The type is the type of the right operand.  */\n \n-  void visit (CommaExp *e)\n+  void visit (CommaExp *e) final override\n   {\n     tree t1 = build_expr (e->e1);\n     tree t2 = build_expr (e->e2);\n@@ -1266,7 +1266,7 @@ class ExprVisitor : public Visitor\n   /* Build an array length expression.  Returns the number of elements\n      in the array.  The result is of type size_t.  */\n \n-  void visit (ArrayLengthExp *e)\n+  void visit (ArrayLengthExp *e) final override\n   {\n     if (e->e1->type->toBasetype ()->ty == TY::Tarray)\n       this->result_ = d_array_length (build_expr (e->e1));\n@@ -1281,7 +1281,7 @@ class ExprVisitor : public Visitor\n   /* Build a delegate pointer expression.  This will return the frame\n      pointer value as a type void*.  */\n \n-  void visit (DelegatePtrExp *e)\n+  void visit (DelegatePtrExp *e) final override\n   {\n     tree t1 = build_expr (e->e1);\n     this->result_ = delegate_object (t1);\n@@ -1290,15 +1290,15 @@ class ExprVisitor : public Visitor\n   /* Build a delegate function pointer expression.  This will return the\n      function pointer value as a function type.  */\n \n-  void visit (DelegateFuncptrExp *e)\n+  void visit (DelegateFuncptrExp *e) final override\n   {\n     tree t1 = build_expr (e->e1);\n     this->result_ = delegate_method (t1);\n   }\n \n   /* Build a slice expression.  */\n \n-  void visit (SliceExp *e)\n+  void visit (SliceExp *e) final override\n   {\n     Type *tb = e->type->toBasetype ();\n     Type *tb1 = e->e1->type->toBasetype ();\n@@ -1371,7 +1371,7 @@ class ExprVisitor : public Visitor\n   /* Build a cast expression, which converts the given unary expression to the\n      type of result.  */\n \n-  void visit (CastExp *e)\n+  void visit (CastExp *e) final override\n   {\n     Type *ebtype = e->e1->type->toBasetype ();\n     Type *tbtype = e->to->toBasetype ();\n@@ -1386,7 +1386,7 @@ class ExprVisitor : public Visitor\n \n   /* Build a delete expression.  */\n \n-  void visit (DeleteExp *e)\n+  void visit (DeleteExp *e) final override\n   {\n     tree t1 = build_expr (e->e1);\n     Type *tb1 = e->e1->type->toBasetype ();\n@@ -1416,7 +1416,7 @@ class ExprVisitor : public Visitor\n   /* Build a remove expression, which removes a particular key from an\n      associative array.  */\n \n-  void visit (RemoveExp *e)\n+  void visit (RemoveExp *e) final override\n   {\n     /* Check that the array is actually an associative array.  */\n     if (e->e1->type->toBasetype ()->ty == TY::Taarray)\n@@ -1439,7 +1439,7 @@ class ExprVisitor : public Visitor\n \n   /* Build an unary not expression.  */\n \n-  void visit (NotExp *e)\n+  void visit (NotExp *e) final override\n   {\n     tree result = convert_for_condition (build_expr (e->e1), e->e1->type);\n     /* Need to convert to boolean type or this will fail.  */\n@@ -1452,7 +1452,7 @@ class ExprVisitor : public Visitor\n      complemented.  Note: unlike in C, the usual integral promotions\n      are not performed prior to the complement operation.  */\n \n-  void visit (ComExp *e)\n+  void visit (ComExp *e) final override\n   {\n     TY ty1 = e->e1->type->toBasetype ()->ty;\n     gcc_assert (ty1 != TY::Tarray && ty1 != TY::Tsarray);\n@@ -1463,7 +1463,7 @@ class ExprVisitor : public Visitor\n \n   /* Build an unary negation expression.  */\n \n-  void visit (NegExp *e)\n+  void visit (NegExp *e) final override\n   {\n     TY ty1 = e->e1->type->toBasetype ()->ty;\n     gcc_assert (ty1 != TY::Tarray && ty1 != TY::Tsarray);\n@@ -1484,7 +1484,7 @@ class ExprVisitor : public Visitor\n \n   /* Build a pointer index expression.  */\n \n-  void visit (PtrExp *e)\n+  void visit (PtrExp *e) final override\n   {\n     Type *tnext = NULL;\n     size_t offset;\n@@ -1547,7 +1547,7 @@ class ExprVisitor : public Visitor\n \n   /* Build an unary address expression.  */\n \n-  void visit (AddrExp *e)\n+  void visit (AddrExp *e) final override\n   {\n     tree type = build_ctype (e->type);\n     tree exp;\n@@ -1581,7 +1581,7 @@ class ExprVisitor : public Visitor\n \n   /* Build a function call expression.  */\n \n-  void visit (CallExp *e)\n+  void visit (CallExp *e) final override\n   {\n     Type *tb = e->e1->type->toBasetype ();\n     Expression *e1b = e->e1;\n@@ -1763,7 +1763,7 @@ class ExprVisitor : public Visitor\n \n   /* Build a delegate expression.  */\n \n-  void visit (DelegateExp *e)\n+  void visit (DelegateExp *e) final override\n   {\n     if (e->func->semanticRun == PASS::semantic3done)\n       {\n@@ -1827,15 +1827,15 @@ class ExprVisitor : public Visitor\n \n   /* Build a type component expression.  */\n \n-  void visit (DotTypeExp *e)\n+  void visit (DotTypeExp *e) final override\n   {\n     /* Just a pass through to underlying expression.  */\n     this->result_ = build_expr (e->e1);\n   }\n \n   /* Build a component reference expression.  */\n \n-  void visit (DotVarExp *e)\n+  void visit (DotVarExp *e) final override\n   {\n     VarDeclaration *vd = e->var->isVarDeclaration ();\n \n@@ -1873,7 +1873,7 @@ class ExprVisitor : public Visitor\n   /* Build an assert expression, used to declare conditions that must hold at\n      that a given point in the program.  */\n \n-  void visit (AssertExp *e)\n+  void visit (AssertExp *e) final override\n   {\n     Type *tb1 = e->e1->type->toBasetype ();\n     tree arg = build_expr (e->e1);\n@@ -1958,7 +1958,7 @@ class ExprVisitor : public Visitor\n \n   /* Build a declaration expression.  */\n \n-  void visit (DeclarationExp *e)\n+  void visit (DeclarationExp *e) final override\n   {\n     /* Compile the declaration.  */\n     push_stmt_list ();\n@@ -1977,7 +1977,7 @@ class ExprVisitor : public Visitor\n   /* Build a typeid expression.  Returns an instance of class TypeInfo\n      corresponding to.  */\n \n-  void visit (TypeidExp *e)\n+  void visit (TypeidExp *e) final override\n   {\n     if (Type *tid = isType (e->obj))\n       {\n@@ -2011,7 +2011,7 @@ class ExprVisitor : public Visitor\n \n   /* Build a function/lambda expression.  */\n \n-  void visit (FuncExp *e)\n+  void visit (FuncExp *e) final override\n   {\n     Type *ftype = e->type->toBasetype ();\n \n@@ -2053,7 +2053,7 @@ class ExprVisitor : public Visitor\n \n   /* Build a halt expression.  */\n \n-  void visit (HaltExp *)\n+  void visit (HaltExp *) final override\n   {\n     /* Should we use trap() or abort()?  */\n     tree ttrap = builtin_decl_explicit (BUILT_IN_TRAP);\n@@ -2062,7 +2062,7 @@ class ExprVisitor : public Visitor\n \n   /* Build a symbol pointer offset expression.  */\n \n-  void visit (SymOffExp *e)\n+  void visit (SymOffExp *e) final override\n   {\n     /* Build the address and offset of the symbol.  */\n     size_t soffset = e->isSymOffExp ()->offset;\n@@ -2088,7 +2088,7 @@ class ExprVisitor : public Visitor\n \n   /* Build a variable expression.  */\n \n-  void visit (VarExp *e)\n+  void visit (VarExp *e) final override\n   {\n     if (e->var->needThis ())\n       {\n@@ -2192,7 +2192,7 @@ class ExprVisitor : public Visitor\n \n   /* Build a this variable expression.  */\n \n-  void visit (ThisExp *e)\n+  void visit (ThisExp *e) final override\n   {\n     FuncDeclaration *fd = d_function_chain ? d_function_chain->function : NULL;\n     tree result = NULL_TREE;\n@@ -2214,7 +2214,7 @@ class ExprVisitor : public Visitor\n   /* Build a new expression, which allocates memory either on the garbage\n      collected heap or by using a class or struct specific allocator.  */\n \n-  void visit (NewExp *e)\n+  void visit (NewExp *e) final override\n   {\n     Type *tb = e->type->toBasetype ();\n     tree result;\n@@ -2464,22 +2464,22 @@ class ExprVisitor : public Visitor\n \n   /* Build an integer literal.  */\n \n-  void visit (IntegerExp *e)\n+  void visit (IntegerExp *e) final override\n   {\n     tree ctype = build_ctype (e->type->toBasetype ());\n     this->result_ = build_integer_cst (e->value, ctype);\n   }\n \n   /* Build a floating-point literal.  */\n \n-  void visit (RealExp *e)\n+  void visit (RealExp *e) final override\n   {\n     this->result_ = build_float_cst (e->value, e->type->toBasetype ());\n   }\n \n   /* Build a complex literal.  */\n \n-  void visit (ComplexExp *e)\n+  void visit (ComplexExp *e) final override\n   {\n     Type *tnext;\n \n@@ -2509,7 +2509,7 @@ class ExprVisitor : public Visitor\n   /* Build a string literal, all strings are null terminated except for\n      static arrays.  */\n \n-  void visit (StringExp *e)\n+  void visit (StringExp *e) final override\n   {\n     Type *tb = e->type->toBasetype ();\n     tree type = build_ctype (e->type);\n@@ -2579,7 +2579,7 @@ class ExprVisitor : public Visitor\n      be the type of the array element, and all elements are implicitly\n      converted to that type.  */\n \n-  void visit (ArrayLiteralExp *e)\n+  void visit (ArrayLiteralExp *e) final override\n   {\n     Type *tb = e->type->toBasetype ();\n \n@@ -2711,7 +2711,7 @@ class ExprVisitor : public Visitor\n      taken to be the key type, and common type of all values the value type.\n      All keys and values are then implicitly converted as needed.  */\n \n-  void visit (AssocArrayLiteralExp *e)\n+  void visit (AssocArrayLiteralExp *e) final override\n   {\n     /* Want the mutable type for typeinfo reference.  */\n     Type *tb = e->type->toBasetype ()->mutableOf ();\n@@ -2758,7 +2758,7 @@ class ExprVisitor : public Visitor\n \n   /* Build a struct literal.  */\n \n-  void visit (StructLiteralExp *e)\n+  void visit (StructLiteralExp *e) final override\n   {\n     /* Handle empty struct literals.  */\n     if (e->elements == NULL || e->sd->fields.length == 0)\n@@ -2880,14 +2880,14 @@ class ExprVisitor : public Visitor\n \n   /* Build a null literal.  */\n \n-  void visit (NullExp *e)\n+  void visit (NullExp *e) final override\n   {\n     this->result_ = build_typeof_null_value (e->type);\n   }\n \n   /* Build a vector literal.  */\n \n-  void visit (VectorExp *e)\n+  void visit (VectorExp *e) final override\n   {\n     tree type = build_ctype (e->type);\n \n@@ -2927,15 +2927,15 @@ class ExprVisitor : public Visitor\n \n   /* Build a static array representation of a vector expression.  */\n \n-  void visit (VectorArrayExp *e)\n+  void visit (VectorArrayExp *e) final override\n   {\n     this->result_ = convert_expr (build_expr (e->e1, this->constp_, true),\n \t\t\t\t  e->e1->type, e->type);\n   }\n \n   /* Build a static class literal, return its reference.  */\n \n-  void visit (ClassReferenceExp *e)\n+  void visit (ClassReferenceExp *e) final override\n   {\n     /* The result of build_new_class_expr is a RECORD_TYPE, we want\n        the reference.  */\n@@ -2965,7 +2965,7 @@ class ExprVisitor : public Visitor\n \n   /* Build an uninitialized value, generated from void initializers.  */\n \n-  void visit (VoidInitExp *e)\n+  void visit (VoidInitExp *e) final override\n   {\n     /* The front-end only generates these for the initializer of globals.\n        Represent `void' as zeroes, regardless of the type's default value.  */\n@@ -2976,14 +2976,14 @@ class ExprVisitor : public Visitor\n   /* These expressions are mainly just a placeholders in the frontend.\n      We shouldn't see them here.  */\n \n-  void visit (ScopeExp *e)\n+  void visit (ScopeExp *e) final override\n   {\n     error_at (make_location_t (e->loc), \"%qs is not an expression\",\n \t      e->toChars ());\n     this->result_ = error_mark_node;\n   }\n \n-  void visit (TypeExp *e)\n+  void visit (TypeExp *e) final override\n   {\n     error_at (make_location_t (e->loc), \"type %qs is not an expression\",\n \t      e->toChars ());"}, {"sha": "133d93d49618612c99c3844db042aa1345b79c77", "filename": "gcc/d/imports.cc", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/329417d775102803e0321b95ba932a64870ba677/gcc%2Fd%2Fimports.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/329417d775102803e0321b95ba932a64870ba677/gcc%2Fd%2Fimports.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fimports.cc?ref=329417d775102803e0321b95ba932a64870ba677", "patch": "@@ -67,14 +67,14 @@ class ImportVisitor : public Visitor\n   }\n \n   /* This should be overridden by each symbol class.  */\n-  void visit (Dsymbol *)\n+  void visit (Dsymbol *) final override\n   {\n     gcc_unreachable ();\n   }\n \n   /* Build the module decl for M, this is considered toplevel, regardless\n      of whether there are any parent packages in the module system.  */\n-  void visit (Module *m)\n+  void visit (Module *m) final override\n   {\n     Loc loc = (m->md != NULL) ? m->md->loc\n       : Loc (m->srcfile.toChars (), 1, 0);\n@@ -93,42 +93,42 @@ class ImportVisitor : public Visitor\n \n   /* Build an import of another module symbol.  */\n \n-  void visit (Import *m)\n+  void visit (Import *m) final override\n   {\n     tree module = build_import_decl (m->mod);\n     this->result_ = this->make_import (module);\n   }\n \n   /* Build an import for any kind of user defined type.\n      Use the TYPE_DECL associated with the type symbol.  */\n-  void visit (EnumDeclaration *d)\n+  void visit (EnumDeclaration *d) final override\n   {\n     tree type = build_ctype (d->type);\n     /* Not all kinds of D enums create a TYPE_DECL.  */\n     if (TREE_CODE (type) == ENUMERAL_TYPE)\n       this->result_ = this->make_import (TYPE_STUB_DECL (type));\n   }\n \n-  void visit (AggregateDeclaration *d)\n+  void visit (AggregateDeclaration *d) final override\n   {\n     tree type = build_ctype (d->type);\n     this->result_ = this->make_import (TYPE_STUB_DECL (type));\n   }\n \n-  void visit (ClassDeclaration *d)\n+  void visit (ClassDeclaration *d) final override\n   {\n     /* Want the RECORD_TYPE, not POINTER_TYPE.  */\n     tree type = TREE_TYPE (build_ctype (d->type));\n     this->result_ = this->make_import (TYPE_STUB_DECL (type));\n   }\n \n   /* For now, ignore importing other kinds of dsymbols.  */\n-  void visit (ScopeDsymbol *)\n+  void visit (ScopeDsymbol *) final override\n   {\n   }\n \n   /* Alias symbols aren't imported, but their targets are.  */\n-  void visit (AliasDeclaration *d)\n+  void visit (AliasDeclaration *d) final override\n   {\n     Dsymbol *dsym = d->toAlias ();\n \n@@ -154,14 +154,14 @@ class ImportVisitor : public Visitor\n   }\n \n   /* Visit the underlying alias symbol of overloadable aliases.  */\n-  void visit (OverDeclaration *d)\n+  void visit (OverDeclaration *d) final override\n   {\n     if (d->aliassym != NULL)\n       d->aliassym->accept (this);\n   }\n \n   /* Function aliases are the same as alias symbols.  */\n-  void visit (FuncAliasDeclaration *d)\n+  void visit (FuncAliasDeclaration *d) final override\n   {\n     FuncDeclaration *fd = d->toAliasFunc ();\n \n@@ -170,17 +170,17 @@ class ImportVisitor : public Visitor\n   }\n \n   /* Skip over importing templates and tuples.  */\n-  void visit (TemplateDeclaration *)\n+  void visit (TemplateDeclaration *) final override\n   {\n   }\n \n-  void visit (TupleDeclaration *)\n+  void visit (TupleDeclaration *) final override\n   {\n   }\n \n   /* Import any other kind of declaration.  If the class does not implement\n      symbol generation routines, the compiler will throw an error.  */\n-  void visit (Declaration *d)\n+  void visit (Declaration *d) final override\n   {\n     this->result_ = this->make_import (get_symbol_decl (d));\n   }"}, {"sha": "a6507e80a627118a7eb6b18245ee275da48e797e", "filename": "gcc/d/typeinfo.cc", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/329417d775102803e0321b95ba932a64870ba677/gcc%2Fd%2Ftypeinfo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/329417d775102803e0321b95ba932a64870ba677/gcc%2Fd%2Ftypeinfo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Ftypeinfo.cc?ref=329417d775102803e0321b95ba932a64870ba677", "patch": "@@ -1328,7 +1328,7 @@ class TypeInfoDeclVisitor : public Visitor\n   {\n   }\n \n-  void visit (TypeInfoDeclaration *tid)\n+  void visit (TypeInfoDeclaration *tid) final override\n   {\n     tree ident = get_identifier (tid->ident->toChars ());\n     tree type = tinfo_types[get_typeinfo_kind (tid->tinfo)];\n@@ -1342,7 +1342,7 @@ class TypeInfoDeclVisitor : public Visitor\n     TREE_READONLY (tid->csym) = 1;\n   }\n \n-  void visit (TypeInfoClassDeclaration *tid)\n+  void visit (TypeInfoClassDeclaration *tid) final override\n   {\n     TypeClass *tc = tid->tinfo->isTypeClass ();\n     tid->csym = get_classinfo_decl (tc->sym);\n@@ -1716,40 +1716,40 @@ class SpeculativeTypeVisitor : public Visitor\n     return this->result_;\n   }\n \n-  void visit (Type *t)\n+  void visit (Type *t) final override\n   {\n     Type *tb = t->toBasetype ();\n     if (tb != t)\n       tb->accept (this);\n   }\n \n-  void visit (TypeNext *t)\n+  void visit (TypeNext *t) final override\n   {\n     if (t->next)\n       t->next->accept (this);\n   }\n \n-  void visit (TypeBasic *)\n+  void visit (TypeBasic *) final override\n   {\n   }\n \n-  void visit (TypeVector *t)\n+  void visit (TypeVector *t) final override\n   {\n     t->basetype->accept (this);\n   }\n \n-  void visit (TypeAArray *t)\n+  void visit (TypeAArray *t) final override\n   {\n     t->index->accept (this);\n     visit ((TypeNext *) t);\n   }\n \n-  void visit (TypeFunction *t)\n+  void visit (TypeFunction *t) final override\n   {\n     visit ((TypeNext *) t);\n   }\n \n-  void visit (TypeStruct *t)\n+  void visit (TypeStruct *t) final override\n   {\n     StructDeclaration *sd = t->sym;\n     if (TemplateInstance *ti = sd->isInstantiated ())\n@@ -1764,7 +1764,7 @@ class SpeculativeTypeVisitor : public Visitor\n       }\n   }\n \n-  void visit (TypeClass *t)\n+  void visit (TypeClass *t) final override\n   {\n     ClassDeclaration *cd = t->sym;\n     if (TemplateInstance *ti = cd->isInstantiated ())\n@@ -1776,7 +1776,7 @@ class SpeculativeTypeVisitor : public Visitor\n       }\n   }\n \n-  void visit (TypeTuple *t)\n+  void visit (TypeTuple *t) final override\n   {\n     if (!t->arguments)\n       return;"}]}