{"sha": "cc55969de9b20786ade9537e6497532972e6f566", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2M1NTk2OWRlOWIyMDc4NmFkZTk1MzdlNjQ5NzUzMjk3MmU2ZjU2Ng==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2015-05-22T20:08:43Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2015-05-22T20:08:43Z"}, "message": "combine.c (try_combine): Canonicalize (plus (mult X pow2) Y) into (plus (ashift X log2) Y) if...\n\n\t* combine.c (try_combine): Canonicalize (plus (mult X pow2) Y) into\n\t(plus (ashift X log2) Y) if it is a split point.\n\n\t* gcc.target/hppa/shadd-3.c: New test.\n\nFrom-SVN: r223583", "tree": {"sha": "8753bdc32ff1157eb172568c94c63b6eb3e4fee9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8753bdc32ff1157eb172568c94c63b6eb3e4fee9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cc55969de9b20786ade9537e6497532972e6f566", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc55969de9b20786ade9537e6497532972e6f566", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc55969de9b20786ade9537e6497532972e6f566", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc55969de9b20786ade9537e6497532972e6f566/comments", "author": null, "committer": null, "parents": [{"sha": "83844a7d2a66a0c3b98687890419003980e4bf96", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83844a7d2a66a0c3b98687890419003980e4bf96", "html_url": "https://github.com/Rust-GCC/gccrs/commit/83844a7d2a66a0c3b98687890419003980e4bf96"}], "stats": {"total": 60, "additions": 60, "deletions": 0}, "files": [{"sha": "a6f06d9dfe31ca4fd4c987a521672bf6cc673ae1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc55969de9b20786ade9537e6497532972e6f566/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc55969de9b20786ade9537e6497532972e6f566/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cc55969de9b20786ade9537e6497532972e6f566", "patch": "@@ -1,5 +1,8 @@\n 2015-05-22  Jeff Law  <law@redhat.com>\n \n+\t* combine.c (try_combine): Canonicalize (plus (mult X pow2) Y) into\n+\t(plus (ashift X log2) Y) if it is a split point.\n+\n \t* pa.c (mem_shadd_or_shadd_rtx_p): New function factored out\n \tof hppa_legitimize_address to handle both forms of a multiply\n \tby 2, 4 or 8."}, {"sha": "0817af2a2a376884f0843c01d62121106383bf78", "filename": "gcc/combine.c", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc55969de9b20786ade9537e6497532972e6f566/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc55969de9b20786ade9537e6497532972e6f566/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=cc55969de9b20786ade9537e6497532972e6f566", "patch": "@@ -3746,6 +3746,21 @@ try_combine (rtx_insn *i3, rtx_insn *i2, rtx_insn *i1, rtx_insn *i0,\n \t      split_code = GET_CODE (*split);\n \t    }\n \n+\t  /* Similarly for (plus (mult FOO (const_int pow2))).  */\n+\t  if (split_code == PLUS\n+\t      && GET_CODE (XEXP (*split, 0)) == MULT\n+\t      && CONST_INT_P (XEXP (XEXP (*split, 0), 1))\n+\t      && INTVAL (XEXP (XEXP (*split, 0), 1)) > 0\n+\t      && (i = exact_log2 (UINTVAL (XEXP (XEXP (*split, 0), 1)))) >= 0)\n+\t    {\n+\t      rtx nsplit = XEXP (*split, 0);\n+\t      SUBST (XEXP (*split, 0), gen_rtx_ASHIFT (GET_MODE (nsplit),\n+\t\t\t\t\t     XEXP (nsplit, 0), GEN_INT (i)));\n+\t      /* Update split_code because we may not have a multiply\n+\t\t anymore.  */\n+\t      split_code = GET_CODE (*split);\n+\t    }\n+\n #ifdef INSN_SCHEDULING\n \t  /* If *SPLIT is a paradoxical SUBREG, when we split it, it should\n \t     be written as a ZERO_EXTEND.  */"}, {"sha": "0b0de20c7dffee1f4ef61103cf539f4c66e7f4f9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc55969de9b20786ade9537e6497532972e6f566/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc55969de9b20786ade9537e6497532972e6f566/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=cc55969de9b20786ade9537e6497532972e6f566", "patch": "@@ -209,6 +209,7 @@\n \n 2015-05-21  Jeff Law  <law@redhat.com>\n \n+\t* gcc.target/hppa/shadd-3.c: New test.\n \t* gcc.target/hppa/shadd-4.c: New test.\n \n 2015-05-21  Michael Matz  <matz@suse.de>"}, {"sha": "f0443ea997776e9e5c9ec9cccef876317a71931d", "filename": "gcc/testsuite/gcc.target/hppa/shadd-3.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc55969de9b20786ade9537e6497532972e6f566/gcc%2Ftestsuite%2Fgcc.target%2Fhppa%2Fshadd-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc55969de9b20786ade9537e6497532972e6f566/gcc%2Ftestsuite%2Fgcc.target%2Fhppa%2Fshadd-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fhppa%2Fshadd-3.c?ref=cc55969de9b20786ade9537e6497532972e6f566", "patch": "@@ -0,0 +1,41 @@\n+/* { dg-do compile }  */\n+/* { dg-options \"-O2\" }  */\n+/* In this test we want to verify that combine canonicalizes the\n+   MULT into an ASHIFT which in turn allows postreload-gcse to\n+   find the common subexpression.\n+\n+   Neither pass dumps stuff in a format that is particularly good\n+   for parsing here, so we count the shadd insns.  More is not\n+   necessarily better in this test.  If this test is too fragile\n+   over time we'll have to revisit the combine and/or postreload\n+   dumps.  */\n+/* { dg-final { scan-assembler-times \"sh.add\" 5 } }  */\n+\n+extern void oof (void);\n+typedef struct simple_bitmap_def *sbitmap;\n+struct simple_bitmap_def\n+{\n+  unsigned char *popcount;\n+  unsigned int n_bits;\n+  unsigned long elms[1];\n+};\n+__inline__ void\n+SET_BIT (sbitmap map, unsigned int bitno)\n+{\n+  if (map->popcount)\n+    {\n+      unsigned char oldbit;\n+      oldbit =\n+\t((map)->elms[bitno / 64]);\n+      if (!oldbit)\n+\toof ();\n+    }\n+  map->elms[bitno / 64] |= 1;\n+}\n+\n+void\n+fix_bb_placements (int indx1, int indx2, sbitmap in_queue)\n+{\n+  SET_BIT (in_queue, indx1);\n+  SET_BIT (in_queue, indx2);\n+}"}]}