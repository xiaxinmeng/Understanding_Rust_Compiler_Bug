{"sha": "cccf3bdc5c87885124ff12b812e2819a5bd574e4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2NjZjNiZGM1Yzg3ODg1MTI0ZmYxMmI4MTJlMjgxOWE1YmQ1NzRlNA==", "commit": {"author": {"name": "David Edelsohn", "email": "edelsohn@gnu.org", "date": "2000-07-25T18:46:54Z"}, "committer": {"name": "David Edelsohn", "email": "dje@gcc.gnu.org", "date": "2000-07-25T18:46:54Z"}, "message": "rs6000.c (print_operand, case 'T'): New case.\n\n\t* rs6000.c (print_operand, case 'T'): New case.\n\n\t* rs6000.md (call_indirect_aix32): Convert to expander of\n\tscheduled instructions.\n\t(call_indirect_aix64): Likewise.\n\t(call_value_indirect_aix{32,64}): Likewise.\n\t(call, call_value): Invoke expanders for AIX.  Fall through to\n\tmatchers for SysV.\n\t(call_indirect_nonlocal_aix{32,64}): New patterns (ctr and lr).\n\t(call_value_indirect_nonlocal_aix{32,64}): New patterns.\n\t(call_nonlocal_aix32): Remove CALL_LONG alternative.  Operand 1\n\tonly \"g\" constraint.\n\t(call_nonlocal_aix64): Likewise.\n\t(call_value_nonlocal_aix{32,64}): Likewise.\n\t(call_nonlocal_sysv): New pattern for ctr, lr, and symbolic\n\toperands.\n\t(call_value_nonlocal_sysv): New pattern.\n\t(indirect_jump{si,di}): Use new 'T' modifier.\n\t(tablejump{si,di} matchers): Likewise.\n\t(return_internal_{si,di}): Likewise.\n\t(return_eh_{si,di}): Likewise.\n\nFrom-SVN: r35246", "tree": {"sha": "834e260c80a26db3f1adafbc75a3e216ee6e362a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/834e260c80a26db3f1adafbc75a3e216ee6e362a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cccf3bdc5c87885124ff12b812e2819a5bd574e4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cccf3bdc5c87885124ff12b812e2819a5bd574e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cccf3bdc5c87885124ff12b812e2819a5bd574e4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cccf3bdc5c87885124ff12b812e2819a5bd574e4/comments", "author": null, "committer": null, "parents": [{"sha": "69b1b29156c348ffd39c85043b21d0ffd6cb4a73", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69b1b29156c348ffd39c85043b21d0ffd6cb4a73", "html_url": "https://github.com/Rust-GCC/gccrs/commit/69b1b29156c348ffd39c85043b21d0ffd6cb4a73"}], "stats": {"total": 628, "additions": 319, "deletions": 309}, "files": [{"sha": "d391b95b08e1096e25c26997db83136071f08769", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cccf3bdc5c87885124ff12b812e2819a5bd574e4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cccf3bdc5c87885124ff12b812e2819a5bd574e4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cccf3bdc5c87885124ff12b812e2819a5bd574e4", "patch": "@@ -1,3 +1,27 @@\n+2000-07-25  David Edelsohn  <edelsohn@gnu.org>\n+\n+\t* rs6000.c (print_operand, case 'T'): New case.\n+\n+\t* rs6000.md (call_indirect_aix32): Convert to expander of\n+\tscheduled instructions.\n+\t(call_indirect_aix64): Likewise.\n+\t(call_value_indirect_aix{32,64}): Likewise.\n+\t(call, call_value): Invoke expanders for AIX.  Fall through to\n+\tmatchers for SysV.\n+\t(call_indirect_nonlocal_aix{32,64}): New patterns (ctr and lr).\n+\t(call_value_indirect_nonlocal_aix{32,64}): New patterns.\n+\t(call_nonlocal_aix32): Remove CALL_LONG alternative.  Operand 1\n+\tonly \"g\" constraint.\n+\t(call_nonlocal_aix64): Likewise.\n+\t(call_value_nonlocal_aix{32,64}): Likewise.\n+\t(call_nonlocal_sysv): New pattern for ctr, lr, and symbolic\n+\toperands.\n+\t(call_value_nonlocal_sysv): New pattern.\n+\t(indirect_jump{si,di}): Use new 'T' modifier.\n+\t(tablejump{si,di} matchers): Likewise.\n+\t(return_internal_{si,di}): Likewise.\n+\t(return_eh_{si,di}): Likewise.\n+\n 2000-07-24  Richard Henderson  <rth@cygnus.com>\n \n \t* config/ia64/ia64.c (ia64_print_operand): Handle \"%,\"."}, {"sha": "623a47d1d311eb39c39526bde9e21b1d81a1b0d4", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cccf3bdc5c87885124ff12b812e2819a5bd574e4/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cccf3bdc5c87885124ff12b812e2819a5bd574e4/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=cccf3bdc5c87885124ff12b812e2819a5bd574e4", "patch": "@@ -3984,6 +3984,7 @@ print_operand (file, x, code)\n \t   mask begins at 63 - i from left */\n \t  if (i > 63)\n \t    output_operand_lossage (\"%%S computed all 1's mask\");\n+\n \t  fprintf (file, \"%d\", 63 - i);\n \t  return;\n \t}\n@@ -4010,10 +4011,23 @@ print_operand (file, x, code)\n \t   mask ends at 62 - i from left */\n \t  if (i > 62)\n \t    output_operand_lossage (\"%%S computed all 0's mask\");\n+\n \t  fprintf (file, \"%d\", 62 - i);\n \t  return;\n \t}\n \n+    case 'T':\n+      /* Print the symbolic name of a branch target register.  */\n+      if (GET_CODE (x) != REG || (REGNO (x) != LINK_REGISTER_REGNUM\n+\t\t\t\t  && REGNO (x) != COUNT_REGISTER_REGNUM))\n+\toutput_operand_lossage (\"invalid %%T value\");\n+\n+      if (REGNO (x) == LINK_REGISTER_REGNUM)\n+\tfputs (TARGET_NEW_MNEMONICS ? \"lr\" : \"r\", file);\n+      else\n+\tfputs (\"ctr\", file);\n+      return;\n+\n     case 'u':\n       /* High-order 16 bits of constant for use in unsigned operand.  */\n       if (! INT_P (x))"}, {"sha": "52ef79831539a5c0f573122d0bbbbe16d56588a5", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 281, "deletions": 309, "changes": 590, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cccf3bdc5c87885124ff12b812e2819a5bd574e4/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cccf3bdc5c87885124ff12b812e2819a5bd574e4/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=cccf3bdc5c87885124ff12b812e2819a5bd574e4", "patch": "@@ -9298,122 +9298,96 @@ operands[2] = GEN_INT (INTVAL (operands[1]) >> 32);\n ;; pointer to its TOC, and whose third word contains a value to place in the\n ;; static chain register (r11).  Note that if we load the static chain, our\n ;; \"trampoline\" need not have any executable code.\n-;;\n-;; operands[0] is a register pointing to the 3 word descriptor (aka, the function address)\n-;; operands[1] is the stack size to clean up\n-;; operands[2] is the value FUNCTION_ARG returns for the VOID argument (must be 0 for AIX)\n-;; operands[3] is location to store the TOC\n-;; operands[4] is the TOC register\n-;; operands[5] is the static chain register\n-;;\n-;; We do not break this into separate insns, so that the scheduler will not try\n-;; to move the load of the new TOC before any loads from the TOC.\n-\n-(define_insn \"call_indirect_aix32\"\n-  [(call (mem:SI (match_operand:SI 0 \"gpc_reg_operand\" \"b\"))\n-\t (match_operand 1 \"const_int_operand\" \"n\"))\n-   (use (match_operand 2 \"const_int_operand\" \"n\"))\n-   (use (match_operand 3 \"offsettable_mem_operand\" \"o\"))\n-   (use (match_operand 4 \"gpc_reg_operand\" \"r\"))\n-   (clobber (match_operand 5 \"gpc_reg_operand\" \"=r\"))\n-   (clobber (match_scratch:SI 6 \"=&r\"))\n-   (clobber (match_scratch:SI 7 \"=l\"))]\n-  \"DEFAULT_ABI == ABI_AIX\n-   && (INTVAL (operands[2]) == CALL_NORMAL || (INTVAL (operands[2]) & CALL_LONG) != 0)\"\n-  \"{st|stw} %4,%3\\;{l|lwz} %6,0(%0)\\;{l|lwz} %4,4(%0)\\;mt%7 %6\\;{l|lwz} %5,8(%0)\\;{brl|blrl}\\;{l|lwz} %4,%3\"\n-  [(set_attr \"type\" \"load\")\n-   (set_attr \"length\" \"28\")])\n-\n-(define_insn \"call_indirect_aix64\"\n-  [(call (mem:SI (match_operand:DI 0 \"gpc_reg_operand\" \"b\"))\n-\t (match_operand 1 \"const_int_operand\" \"n\"))\n-   (use (match_operand 2 \"const_int_operand\" \"n\"))\n-   (use (match_operand 3 \"offsettable_mem_operand\" \"o\"))\n-   (use (match_operand 4 \"gpc_reg_operand\" \"r\"))\n-   (clobber (match_operand 5 \"gpc_reg_operand\" \"=r\"))\n-   (clobber (match_scratch:SI 6 \"=&r\"))\n-   (clobber (match_scratch:SI 7 \"=l\"))]\n-  \"TARGET_64BIT && DEFAULT_ABI == ABI_AIX\n-   && (INTVAL (operands[2]) == CALL_NORMAL || (INTVAL (operands[2]) & CALL_LONG) != 0)\"\n-  \"std %4,%3\\;ld %6,0(%0)\\;ld %4,8(%0)\\;mt%7 %6\\;ld %5,16(%0)\\;blrl\\;ld %4,%3\"\n-  [(set_attr \"type\" \"load\")\n-   (set_attr \"length\" \"28\")])\n-\n-(define_insn \"call_value_indirect_aix32\"\n-  [(set (match_operand 0 \"\" \"\")\n-\t(call (mem:SI (match_operand:SI 1 \"gpc_reg_operand\" \"b\"))\n-\t      (match_operand 2 \"const_int_operand\" \"n\")))\n-   (use (match_operand 3 \"const_int_operand\" \"n\"))\n-   (use (match_operand 4 \"offsettable_mem_operand\" \"o\"))\n-   (use (match_operand 5 \"gpc_reg_operand\" \"r\"))\n-   (clobber (match_operand 6 \"gpc_reg_operand\" \"=r\"))\n-   (clobber (match_scratch:SI 7 \"=&r\"))\n-   (clobber (match_scratch:SI 8 \"=l\"))]\n-  \"DEFAULT_ABI == ABI_AIX\n-   && (INTVAL (operands[3]) == CALL_NORMAL || (INTVAL (operands[3]) & CALL_LONG) != 0)\"\n-  \"{st|stw} %5,%4\\;{l|lwz} %7,0(%1)\\;{l|lwz} %5,4(%1)\\;mt%8 %7\\;{l|lwz} %6,8(%1)\\;{brl|blrl}\\;{l|lwz} %5,%4\"\n-  [(set_attr \"type\" \"load\")\n-   (set_attr \"length\" \"28\")])\n-\n-(define_insn \"call_value_indirect_aix64\"\n-  [(set (match_operand 0 \"\" \"\")\n-\t(call (mem:SI (match_operand:DI 1 \"gpc_reg_operand\" \"b\"))\n-\t      (match_operand 2 \"const_int_operand\" \"n\")))\n-   (use (match_operand 3 \"const_int_operand\" \"n\"))\n-   (use (match_operand 4 \"offsettable_mem_operand\" \"o\"))\n-   (use (match_operand 5 \"gpc_reg_operand\" \"r\"))\n-   (clobber (match_operand 6 \"gpc_reg_operand\" \"=r\"))\n-   (clobber (match_scratch:SI 7 \"=&r\"))\n-   (clobber (match_scratch:SI 8 \"=l\"))]\n-  \"TARGET_64BIT && DEFAULT_ABI == ABI_AIX\n-   && (INTVAL (operands[3]) == CALL_NORMAL || (INTVAL (operands[3]) & CALL_LONG) != 0)\"\n-  \"std %5,%4\\;ld %7,0(%1)\\;ld %5,8(%1)\\;mt%8 %7\\;ld %6,16(%1)\\;blrl\\;ld %5,%4\"\n-  [(set_attr \"type\" \"load\")\n-   (set_attr \"length\" \"28\")])\n-\n-;; A function pointer under System V is just a normal pointer\n-;; operands[0] is the function pointer\n-;; operands[1] is the stack size to clean up\n-;; operands[2] is the value FUNCTION_ARG returns for the VOID argument which indicates how to set cr1\n-\n-(define_insn \"call_indirect_sysv\"\n-  [(call (mem:SI (match_operand:SI 0 \"register_operand\" \"l,l\"))\n-\t (match_operand 1 \"const_int_operand\" \"n,n\"))\n-   (use (match_operand 2 \"const_int_operand\" \"O,n\"))\n-   (clobber (match_scratch:SI 3 \"=l,l\"))]\n-  \"DEFAULT_ABI == ABI_V4 || DEFAULT_ABI == ABI_SOLARIS || DEFAULT_ABI == ABI_AIX_NODESC\"\n-  \"*\n-{\n-  if (INTVAL (operands[2]) & CALL_V4_SET_FP_ARGS)\n-    output_asm_insn (\\\"crxor 6,6,6\\\", operands);\n-\n-  else if (INTVAL (operands[2]) & CALL_V4_CLEAR_FP_ARGS)\n-    output_asm_insn (\\\"creqv 6,6,6\\\", operands);\n \n-  return \\\"{brl|blrl}\\\";\n-}\"\n-  [(set_attr \"type\" \"jmpreg\")\n-   (set_attr \"length\" \"4,8\")])\n+(define_expand \"call_indirect_aix32\"\n+  [(set (match_dup 2)\n+\t(mem:SI (match_operand:SI 0 \"gpc_reg_operand\" \"\")))\n+   (set (mem:SI (plus:SI (reg:SI 1) (const_int 20)))\n+\t(reg:SI 2))\n+   (set (reg:SI 2)\n+\t(mem:SI (plus:SI (match_dup 0)\n+\t\t\t (const_int 4))))\n+   (set (reg:SI 11)\n+\t(mem:SI (plus:SI (match_dup 0)\n+\t\t\t (const_int 8))))\n+   (parallel [(call (mem:SI (match_dup 2))\n+\t\t    (match_operand 1 \"\" \"\"))\n+\t      (use (reg:SI 2))\n+\t      (use (reg:SI 11))\n+\t      (set (reg:SI 2)\n+\t\t   (mem:SI (plus:SI (reg:SI 1) (const_int 20))))\n+\t      (clobber (scratch:SI))])]\n+  \"TARGET_32BIT\"\n+  \"\n+{ operands[2] = gen_reg_rtx (SImode); }\")\n \n-(define_insn \"call_value_indirect_sysv\"\n-  [(set (match_operand 0 \"register_operand\" \"=fg,fg\")\n-\t(call (mem:SI (match_operand:SI 1 \"register_operand\" \"l,l\"))\n-\t      (match_operand 2 \"const_int_operand\" \"n,n\")))\n-   (use (match_operand 3 \"const_int_operand\" \"O,n\"))\n-   (clobber (match_scratch:SI 4 \"=l,l\"))]\n-  \"DEFAULT_ABI == ABI_V4 || DEFAULT_ABI == ABI_SOLARIS || DEFAULT_ABI == ABI_AIX_NODESC\"\n-  \"*\n-{\n-  if (INTVAL (operands[3]) & CALL_V4_SET_FP_ARGS)\n-    output_asm_insn (\\\"crxor 6,6,6\\\", operands);\n+(define_expand \"call_indirect_aix64\"\n+  [(set (match_dup 2)\n+\t(mem:DI (match_operand:DI 0 \"gpc_reg_operand\" \"\")))\n+   (set (mem:DI (plus:DI (reg:DI 1) (const_int 40)))\n+\t(reg:DI 2))\n+   (set (reg:DI 2)\n+\t(mem:DI (plus:DI (match_dup 0)\n+\t\t\t (const_int 8))))\n+   (set (reg:DI 11)\n+\t(mem:DI (plus:DI (match_dup 0)\n+\t\t\t (const_int 16))))\n+   (parallel [(call (mem:SI (match_dup 2))\n+\t\t    (match_operand 1 \"\" \"\"))\n+\t      (use (reg:DI 2))\n+\t      (use (reg:DI 11))\n+\t      (set (reg:DI 2)\n+\t\t   (mem:DI (plus:DI (reg:DI 1) (const_int 40))))\n+\t      (clobber (scratch:SI))])]\n+  \"TARGET_64BIT\"\n+  \"\n+{ operands[2] = gen_reg_rtx (DImode); }\")\n \n-  else if (INTVAL (operands[3]) & CALL_V4_CLEAR_FP_ARGS)\n-    output_asm_insn (\\\"creqv 6,6,6\\\", operands);\n+(define_expand \"call_value_indirect_aix32\"\n+  [(set (match_dup 3)\n+\t(mem:SI (match_operand:SI 1 \"gpc_reg_operand\" \"\")))\n+   (set (mem:SI (plus:SI (reg:SI 1) (const_int 20)))\n+\t(reg:SI 2))\n+   (set (reg:SI 2)\n+\t(mem:SI (plus:SI (match_dup 1)\n+\t\t\t (const_int 4))))\n+   (set (reg:SI 11)\n+\t(mem:SI (plus:SI (match_dup 1)\n+\t\t\t (const_int 8))))\n+   (parallel [(set (match_operand 0 \"\" \"\")\n+\t\t   (call (mem:SI (match_dup 3))\n+\t\t\t (match_operand 2 \"\" \"\")))\n+\t      (use (reg:SI 2))\n+\t      (use (reg:SI 11))\n+\t      (set (reg:SI 2)\n+\t\t   (mem:SI (plus:SI (reg:SI 1) (const_int 20))))\n+\t      (clobber (scratch:SI))])]\n+  \"TARGET_32BIT\"\n+  \"\n+{ operands[3] = gen_reg_rtx (SImode); }\")\n \n-  return \\\"{brl|blrl}\\\";\n-}\"\n-  [(set_attr \"type\" \"jmpreg\")\n-   (set_attr \"length\" \"4,8\")])\n+(define_expand \"call_value_indirect_aix64\"\n+  [(set (match_dup 3)\n+\t(mem:DI (match_operand:DI 1 \"gpc_reg_operand\" \"\")))\n+   (set (mem:DI (plus:DI (reg:DI 1) (const_int 40)))\n+\t(reg:DI 2))\n+   (set (reg:DI 2)\n+\t(mem:DI (plus:DI (match_dup 1)\n+\t\t\t (const_int 8))))\n+   (set (reg:DI 11)\n+\t(mem:DI (plus:DI (match_dup 1)\n+\t\t\t (const_int 16))))\n+   (parallel [(set (match_operand 0 \"\" \"\")\n+\t\t   (call (mem:SI (match_dup 3))\n+\t\t\t (match_operand 2 \"\" \"\")))\n+\t      (use (reg:DI 2))\n+\t      (use (reg:DI 11))\n+\t      (set (reg:DI 2)\n+\t\t   (mem:DI (plus:DI (reg:DI 1) (const_int 40))))\n+\t      (clobber (scratch:SI))])]\n+  \"TARGET_64BIT\"\n+  \"\n+{ operands[3] = gen_reg_rtx (DImode); }\")\n \n ;; Now the definitions for the call and call_value insns\n (define_expand \"call\"\n@@ -9435,31 +9409,26 @@ operands[2] = GEN_INT (INTVAL (operands[1]) >> 32);\n       if (INTVAL (operands[2]) & CALL_LONG)\n \toperands[0] = rs6000_longcall_ref (operands[0]);\n \n-      if (DEFAULT_ABI == ABI_V4 || DEFAULT_ABI == ABI_AIX_NODESC || DEFAULT_ABI == ABI_SOLARIS)\n-\temit_call_insn (gen_call_indirect_sysv (force_reg (Pmode, operands[0]),\n-\t\t\t\t\t\toperands[1], operands[2]));\n-      else\n-\t{\n-\t  rtx toc_reg = gen_rtx_REG (Pmode, 2);\n-\t  rtx toc_addr = RS6000_SAVE_TOC;\n+      if (DEFAULT_ABI == ABI_V4\n+          || DEFAULT_ABI == ABI_AIX_NODESC\n+\t  || DEFAULT_ABI == ABI_SOLARIS)\n+\toperands[0] = force_reg (Pmode, operands[0]);\n \n-\t  if (DEFAULT_ABI == ABI_AIX)\n-\t    {\n-\t      /* AIX function pointers are really pointers to a three word\n-\t\t area.  */\n-\t      rtx static_chain = gen_rtx_REG (Pmode, STATIC_CHAIN_REGNUM);\n-\t      emit_call_insn (TARGET_32BIT\n-\t\t\t      ? gen_call_indirect_aix32 (force_reg (Pmode, operands[0]),\n-\t\t\t\t\t\t         operands[1], operands[2],\n-\t\t\t\t\t\t         toc_addr, toc_reg, static_chain)\n-\t\t\t      : gen_call_indirect_aix64 (force_reg (Pmode, operands[0]),\n-\t\t\t\t\t\t         operands[1], operands[2],\n-\t\t\t\t\t\t         toc_addr, toc_reg, static_chain));\n-\t    }\n-\t  else\n-\t    abort ();\n+      else if (DEFAULT_ABI == ABI_AIX)\n+\t{\n+\t  /* AIX function pointers are really pointers to a three word\n+\t     area.  */\n+\t  emit_call_insn (TARGET_32BIT\n+\t\t\t  ? gen_call_indirect_aix32 (force_reg (SImode,\n+\t\t\t\t\t\t\t        operands[0]),\n+\t\t\t\t\t\t     operands[1])\n+\t\t\t  : gen_call_indirect_aix64 (force_reg (DImode,\n+\t\t\t\t\t\t\t        operands[0]),\n+\t\t\t\t\t\t     operands[1]));\n+\t  DONE;\n \t}\n-      DONE;\n+      else\n+\tabort ();\n     }\n }\")\n \n@@ -9483,33 +9452,28 @@ operands[2] = GEN_INT (INTVAL (operands[1]) >> 32);\n       if (INTVAL (operands[3]) & CALL_LONG)\n \toperands[1] = rs6000_longcall_ref (operands[1]);\n \n-      if (DEFAULT_ABI == ABI_V4 || DEFAULT_ABI == ABI_AIX_NODESC || DEFAULT_ABI == ABI_SOLARIS)\n-\temit_call_insn (gen_call_value_indirect_sysv (operands[0], operands[1],\n-\t\t\t\t\t\t      operands[2], operands[3]));\n-      else\n-\t{\n-\t  rtx toc_reg = gen_rtx_REG (Pmode, 2);\n-\t  rtx toc_addr = RS6000_SAVE_TOC;\n+      if (DEFAULT_ABI == ABI_V4\n+\t  || DEFAULT_ABI == ABI_AIX_NODESC\n+\t  || DEFAULT_ABI == ABI_SOLARIS)\n+\toperands[0] = force_reg (Pmode, operands[0]);\n \n-\t  if (DEFAULT_ABI == ABI_AIX)\n-\t    {\n-\t      /* AIX function pointers are really pointers to a three word\n-\t\t area.  */\n-\t      rtx static_chain = gen_rtx_REG (Pmode, STATIC_CHAIN_REGNUM);\n-\t      emit_call_insn (TARGET_32BIT\n-\t\t\t      ? gen_call_value_indirect_aix32 (operands[0],\n-\t\t\t\t\t\t\t       force_reg (Pmode, operands[1]),\n-\t\t\t\t\t\t\t       operands[2], operands[3],\n-\t\t\t\t\t\t\t       toc_addr, toc_reg, static_chain)\n-\t\t\t      : gen_call_value_indirect_aix64 (operands[0],\n-\t\t\t\t\t\t\t       force_reg (Pmode, operands[1]),\n-\t\t\t\t\t\t\t       operands[2], operands[3],\n-\t\t\t\t\t\t\t       toc_addr, toc_reg, static_chain));\n-\t    }\n-\t  else\n-\t    abort ();\n+      else if (DEFAULT_ABI == ABI_AIX)\n+\t{\n+\t  /* AIX function pointers are really pointers to a three word\n+\t     area.  */\n+\t  emit_call_insn (TARGET_32BIT\n+\t\t\t  ? gen_call_value_indirect_aix32 (operands[0],\n+\t\t\t\t\t\t\t   force_reg (SImode,\n+\t\t\t\t\t\t\t\t      operands[1]),\n+\t\t\t\t\t\t\t   operands[2])\n+\t\t\t  : gen_call_value_indirect_aix64 (operands[0],\n+\t\t\t\t\t\t\t   force_reg (DImode,\n+\t\t\t\t\t\t\t\t      operands[1]),\n+\t\t\t\t\t\t\t   operands[2]));\n+\t  DONE;\n \t}\n-      DONE;\n+      else\n+\tabort ();\n     }\n }\")\n \n@@ -9557,7 +9521,7 @@ operands[2] = GEN_INT (INTVAL (operands[1]) >> 32);\n   [(set_attr \"type\" \"branch\")\n    (set_attr \"length\" \"4,8\")])\n \n-(define_insn \"*ret_call_local32\"\n+(define_insn \"*call_value_local32\"\n   [(set (match_operand 0 \"\" \"=fg,fg\")\n \t(call (mem:SI (match_operand:SI 1 \"current_file_function_operand\" \"s,s\"))\n \t      (match_operand 2 \"\" \"g,g\")))\n@@ -9578,7 +9542,7 @@ operands[2] = GEN_INT (INTVAL (operands[1]) >> 32);\n    (set_attr \"length\" \"4,8\")])\n \n \n-(define_insn \"*ret_call_local64\"\n+(define_insn \"*call_value_local64\"\n   [(set (match_operand 0 \"\" \"=fg,fg\")\n \t(call (mem:SI (match_operand:DI 1 \"current_file_function_operand\" \"s,s\"))\n \t      (match_operand 2 \"\" \"g,g\")))\n@@ -9605,154 +9569,178 @@ operands[2] = GEN_INT (INTVAL (operands[1]) >> 32);\n ;; variable argument function.  It is > 0 if FP registers were passed\n ;; and < 0 if they were not.\n \n+(define_insn \"*call_indirect_nonlocal_aix32\"\n+  [(call (mem:SI (match_operand:SI 0 \"register_operand\" \"cl\"))\n+\t (match_operand 1 \"\" \"g\"))\n+   (use (reg:SI 2))\n+   (use (reg:SI 11))\n+   (set (reg:SI 2)\n+\t(mem:SI (plus:SI (reg:SI 1) (const_int 20))))\n+   (clobber (match_scratch:SI 3 \"=l\"))]\n+  \"TARGET_32BIT && DEFAULT_ABI == ABI_AIX\"\n+  \"b%T0l\\;{l|lwz} 2,20(1)\"\n+  [(set_attr \"type\" \"jmpreg\")\n+   (set_attr \"length\" \"8\")])\n+\n (define_insn \"*call_nonlocal_aix32\"\n-  [(call (mem:SI (match_operand:SI 0 \"call_operand\" \"s,s\"))\n-\t (match_operand 1 \"\" \"fg,fg\"))\n-   (use (match_operand:SI 2 \"immediate_operand\" \"O,n\"))\n-   (clobber (match_scratch:SI 3 \"=l,l\"))]\n-  \"DEFAULT_ABI == ABI_AIX\n+  [(call (mem:SI (match_operand:SI 0 \"call_operand\" \"s\"))\n+\t (match_operand 1 \"\" \"g\"))\n+   (use (match_operand:SI 2 \"immediate_operand\" \"O\"))\n+   (clobber (match_scratch:SI 3 \"=l\"))]\n+  \"TARGET_32BIT\n+   && DEFAULT_ABI == ABI_AIX\n    && (INTVAL (operands[2]) & CALL_LONG) == 0\"\n-  \"*\n-{\n-  /* Indirect calls should go through call_indirect */\n-  if (GET_CODE (operands[0]) == REG)\n-    abort ();\n-\n-  if (INTVAL (operands[2]) & CALL_V4_SET_FP_ARGS)\n-    output_asm_insn (\\\"crxor 6,6,6\\\", operands);\n-\n-  else if (INTVAL (operands[2]) & CALL_V4_CLEAR_FP_ARGS)\n-    output_asm_insn (\\\"creqv 6,6,6\\\", operands);\n-\n-  return \\\"bl %z0\\;%.\\\";\n-}\"\n+  \"bl %z0\\;%.\"\n   [(set_attr \"type\" \"branch\")\n-   (set_attr \"length\" \"8,12\")])\n+   (set_attr \"length\" \"8\")])\n+\n+(define_insn \"*call_indirect_nonlocal_aix64\"\n+  [(call (mem:SI (match_operand:DI 0 \"register_operand\" \"cl\"))\n+\t (match_operand 1 \"\" \"g\"))\n+   (use (reg:DI 2))\n+   (use (reg:DI 11))\n+   (set (reg:DI 2)\n+\t(mem:DI (plus:DI (reg:DI 1) (const_int 40))))\n+   (clobber (match_scratch:SI 3 \"=l\"))]\n+  \"TARGET_64BIT && DEFAULT_ABI == ABI_AIX\"\n+  \"b%T0l\\;ld 2,40(1)\"\n+  [(set_attr \"type\" \"jmpreg\")\n+   (set_attr \"length\" \"8\")])\n \n (define_insn \"*call_nonlocal_aix64\"\n-  [(call (mem:SI (match_operand:DI 0 \"call_operand\" \"s,s\"))\n-\t (match_operand 1 \"\" \"fg,fg\"))\n-   (use (match_operand:SI 2 \"immediate_operand\" \"O,n\"))\n-   (clobber (match_scratch:SI 3 \"=l,l\"))]\n+  [(call (mem:SI (match_operand:DI 0 \"call_operand\" \"s\"))\n+\t (match_operand 1 \"\" \"g\"))\n+   (use (match_operand:SI 2 \"immediate_operand\" \"O\"))\n+   (clobber (match_scratch:SI 3 \"=l\"))]\n   \"TARGET_64BIT \n    && DEFAULT_ABI == ABI_AIX\n    && (INTVAL (operands[2]) & CALL_LONG) == 0\"\n-  \"*\n-{\n-  /* Indirect calls should go through call_indirect */\n-  if (GET_CODE (operands[0]) == REG)\n-    abort ();\n-\n-  if (INTVAL (operands[2]) & CALL_V4_SET_FP_ARGS)\n-    output_asm_insn (\\\"crxor 6,6,6\\\", operands);\n-\n-  else if (INTVAL (operands[2]) & CALL_V4_CLEAR_FP_ARGS)\n-    output_asm_insn (\\\"creqv 6,6,6\\\", operands);\n-\n-  return \\\"bl %z0\\;%.\\\";\n-}\"\n+  \"bl %z0\\;%.\"\n   [(set_attr \"type\" \"branch\")\n-   (set_attr \"length\" \"8,12\")])\n-\n-(define_insn \"*call_nonlocal_sysv\"\n-  [(call (mem:SI (match_operand:SI 0 \"call_operand\" \"s,s\"))\n-\t (match_operand 1 \"\" \"fg,fg\"))\n-   (use (match_operand:SI 2 \"immediate_operand\" \"O,n\"))\n-   (clobber (match_scratch:SI 3 \"=l,l\"))]\n-  \"(DEFAULT_ABI == ABI_AIX_NODESC || DEFAULT_ABI == ABI_V4 || DEFAULT_ABI == ABI_SOLARIS)\n-   && (INTVAL (operands[2]) & CALL_LONG) == 0\"\n-  \"*\n-{\n-  /* Indirect calls should go through call_indirect */\n-  if (GET_CODE (operands[0]) == REG)\n-    abort ();\n-\n-  if (INTVAL (operands[2]) & CALL_V4_SET_FP_ARGS)\n-    output_asm_insn (\\\"crxor 6,6,6\\\", operands);\n-\n-  else if (INTVAL (operands[2]) & CALL_V4_CLEAR_FP_ARGS)\n-    output_asm_insn (\\\"creqv 6,6,6\\\", operands);\n+   (set_attr \"length\" \"8\")])\n \n-  return (DEFAULT_ABI == ABI_V4 && flag_pic) ? \\\"bl %z0@plt\\\" : \\\"bl %z0\\\";\n-}\"\n-  [(set_attr \"type\" \"branch\")\n-   (set_attr \"length\" \"4,8\")])\n+(define_insn \"*call_value_indirect_nonlocal_aix32\"\n+  [(set (match_operand 0 \"\" \"=fg\")\n+\t(call (mem:SI (match_operand:SI 1 \"register_operand\" \"cl\"))\n+\t      (match_operand 2 \"\" \"g\")))\n+   (use (reg:SI 2))\n+   (use (reg:SI 11))\n+   (set (reg:SI 2)\n+\t(mem:SI (plus:SI (reg:SI 1) (const_int 20))))\n+   (clobber (match_scratch:SI 3 \"=l\"))]\n+  \"TARGET_32BIT && DEFAULT_ABI == ABI_AIX\"\n+  \"b%T1l\\;{l|lwz} 2,20(1)\"\n+  [(set_attr \"type\" \"jmpreg\")\n+   (set_attr \"length\" \"8\")])\n \n-(define_insn \"*ret_call_nonlocal_aix32\"\n-  [(set (match_operand 0 \"\" \"=fg,fg\")\n-\t(call (mem:SI (match_operand:SI 1 \"call_operand\" \"s,s\"))\n-\t      (match_operand 2 \"\" \"fg,fg\")))\n-   (use (match_operand:SI 3 \"immediate_operand\" \"O,n\"))\n-   (clobber (match_scratch:SI 4 \"=l,l\"))]\n-  \"DEFAULT_ABI == ABI_AIX\n+(define_insn \"*call_value_nonlocal_aix32\"\n+  [(set (match_operand 0 \"\" \"=fg\")\n+\t(call (mem:SI (match_operand:SI 1 \"call_operand\" \"s\"))\n+\t      (match_operand 2 \"\" \"g\")))\n+   (use (match_operand:SI 3 \"immediate_operand\" \"O\"))\n+   (clobber (match_scratch:SI 4 \"=l\"))]\n+  \"TARGET_32BIT\n+   && DEFAULT_ABI == ABI_AIX\n    && (INTVAL (operands[3]) & CALL_LONG) == 0\"\n-  \"*\n-{\n-  /* This should be handled by call_value_indirect */\n-  if (GET_CODE (operands[1]) == REG)\n-    abort ();\n-\n-  if (INTVAL (operands[3]) & CALL_V4_SET_FP_ARGS)\n-    output_asm_insn (\\\"crxor 6,6,6\\\", operands);\n-\n-  else if (INTVAL (operands[3]) & CALL_V4_CLEAR_FP_ARGS)\n-    output_asm_insn (\\\"creqv 6,6,6\\\", operands);\n-\n-  return \\\"bl %z1\\;%.\\\";\n-}\"\n+  \"bl %z1\\;%.\"\n   [(set_attr \"type\" \"branch\")\n-   (set_attr \"length\" \"8,12\")])\n+   (set_attr \"length\" \"8\")])\n \n-(define_insn \"*ret_call_nonlocal_aix64\"\n-  [(set (match_operand 0 \"\" \"=fg,fg\")\n-\t(call (mem:SI (match_operand:DI 1 \"call_operand\" \"s,s\"))\n-\t      (match_operand 2 \"\" \"fg,fg\")))\n-   (use (match_operand:SI 3 \"immediate_operand\" \"O,n\"))\n-   (clobber (match_scratch:SI 4 \"=l,l\"))]\n+(define_insn \"*call_value_indirect_nonlocal_aix64\"\n+  [(set (match_operand 0 \"\" \"=fg\")\n+\t(call (mem:SI (match_operand:DI 1 \"register_operand\" \"cl\"))\n+\t      (match_operand 2 \"\" \"g\")))\n+   (use (reg:DI 2))\n+   (use (reg:DI 11))\n+   (set (reg:DI 2)\n+\t(mem:DI (plus:DI (reg:DI 1) (const_int 40))))\n+   (clobber (match_scratch:SI 3 \"=l\"))]\n+  \"TARGET_64BIT && DEFAULT_ABI == ABI_AIX\"\n+  \"b%T1l\\;ld 2,40(1)\"\n+  [(set_attr \"type\" \"jmpreg\")\n+   (set_attr \"length\" \"8\")])\n+\n+(define_insn \"*call_value_nonlocal_aix64\"\n+  [(set (match_operand 0 \"\" \"=fg\")\n+\t(call (mem:SI (match_operand:DI 1 \"call_operand\" \"s\"))\n+\t      (match_operand 2 \"\" \"g\")))\n+   (use (match_operand:SI 3 \"immediate_operand\" \"O\"))\n+   (clobber (match_scratch:SI 4 \"=l\"))]\n   \"TARGET_64BIT \n    && DEFAULT_ABI == ABI_AIX\n    && (INTVAL (operands[3]) & CALL_LONG) == 0\"\n+  \"bl %z1\\;%.\"\n+  [(set_attr \"type\" \"branch\")\n+   (set_attr \"length\" \"8\")])\n+\n+;; A function pointer under System V is just a normal pointer\n+;; operands[0] is the function pointer\n+;; operands[1] is the stack size to clean up\n+;; operands[2] is the value FUNCTION_ARG returns for the VOID argument\n+;; which indicates how to set cr1\n+\n+(define_insn \"*call_nonlocal_sysv\"\n+  [(call (mem:SI (match_operand:SI 0 \"call_operand\" \"cl,cl,s,s\"))\n+\t (match_operand 1 \"\" \"g,g,g,g\"))\n+   (use (match_operand:SI 2 \"immediate_operand\" \"O,n,O,n\"))\n+   (clobber (match_scratch:SI 3 \"=l,l,l,l\"))]\n+  \"DEFAULT_ABI == ABI_AIX_NODESC\n+   || DEFAULT_ABI == ABI_V4\n+   || DEFAULT_ABI == ABI_SOLARIS\"\n   \"*\n {\n-  /* This should be handled by call_value_indirect */\n-  if (GET_CODE (operands[1]) == REG)\n-    abort ();\n-\n-  if (INTVAL (operands[3]) & CALL_V4_SET_FP_ARGS)\n+  if (INTVAL (operands[2]) & CALL_V4_SET_FP_ARGS)\n     output_asm_insn (\\\"crxor 6,6,6\\\", operands);\n \n-  else if (INTVAL (operands[3]) & CALL_V4_CLEAR_FP_ARGS)\n+  else if (INTVAL (operands[2]) & CALL_V4_CLEAR_FP_ARGS)\n     output_asm_insn (\\\"creqv 6,6,6\\\", operands);\n \n-  return \\\"bl %z1\\;%.\\\";\n+  switch (which_alternative)\n+    {\n+    default:\n+      abort ();\n+    case 0:\n+    case 1:\n+      return \\\"b%T0l\\\";\n+    case 2:\n+    case 3:\n+      return (DEFAULT_ABI == ABI_V4 && flag_pic) ? \\\"bl %z0@plt\\\" : \\\"bl %z0\\\";\n+    }\n }\"\n-  [(set_attr \"type\" \"branch\")\n-   (set_attr \"length\" \"8,12\")])\n-\n-(define_insn \"*ret_call_nonlocal_sysv\"\n-  [(set (match_operand 0 \"\" \"=fg,fg\")\n-\t(call (mem:SI (match_operand:SI 1 \"call_operand\" \"s,s\"))\n-\t      (match_operand 2 \"\" \"fg,fg\")))\n-   (use (match_operand:SI 3 \"immediate_operand\" \"O,n\"))\n-   (clobber (match_scratch:SI 4 \"=l,l\"))]\n-  \"(DEFAULT_ABI == ABI_AIX_NODESC || DEFAULT_ABI == ABI_V4 || DEFAULT_ABI == ABI_SOLARIS)\n-   && (INTVAL (operands[3]) & CALL_LONG) == 0\"\n+  [(set_attr \"type\" \"jmpreg,jmpreg,branch,branch\")\n+   (set_attr \"length\" \"4,8,4,8\")])\n+\n+(define_insn \"*call_value_nonlocal_sysv\"\n+  [(set (match_operand 0 \"\" \"=fg,fg,fg,fg\")\n+\t(call (mem:SI (match_operand:SI 1 \"call_operand\" \"cl,cl,s,s\"))\n+\t      (match_operand 2 \"\" \"g,g,g,g\")))\n+   (use (match_operand:SI 3 \"immediate_operand\" \"O,n,O,n\"))\n+   (clobber (match_scratch:SI 4 \"=l,l,l,l\"))]\n+  \"DEFAULT_ABI == ABI_AIX_NODESC\n+   || DEFAULT_ABI == ABI_V4\n+   || DEFAULT_ABI == ABI_SOLARIS\"\n   \"*\n {\n-  /* This should be handled by call_value_indirect */\n-  if (GET_CODE (operands[1]) == REG)\n-    abort ();\n-\n   if (INTVAL (operands[3]) & CALL_V4_SET_FP_ARGS)\n     output_asm_insn (\\\"crxor 6,6,6\\\", operands);\n \n   else if (INTVAL (operands[3]) & CALL_V4_CLEAR_FP_ARGS)\n     output_asm_insn (\\\"creqv 6,6,6\\\", operands);\n \n-  return (DEFAULT_ABI == ABI_V4 && flag_pic) ? \\\"bl %z1@plt\\\" : \\\"bl %z1\\\";\n+  switch (which_alternative)\n+    {\n+    default:\n+      abort ();\n+    case 0:\n+    case 1:\n+      return \\\"b%T1l\\\";\n+    case 2:\n+    case 3:\n+      return (DEFAULT_ABI == ABI_V4 && flag_pic) ? \\\"bl %z1@plt\\\" : \\\"bl %z1\\\";\n+    }\n }\"\n-  [(set_attr \"type\" \"branch\")\n-   (set_attr \"length\" \"4,8\")])\n+  [(set_attr \"type\" \"jmpreg,jmpreg,branch,branch\")\n+   (set_attr \"length\" \"4,8,4,8\")])\n \n ;; Call subroutine returning any type.\n (define_expand \"untyped_call\"\n@@ -13226,19 +13214,15 @@ operands[2] = GEN_INT (INTVAL (operands[1]) >> 32);\n }\")\n \n (define_insn \"indirect_jumpsi\"\n-  [(set (pc) (match_operand:SI 0 \"register_operand\" \"c,l\"))]\n+  [(set (pc) (match_operand:SI 0 \"register_operand\" \"cl\"))]\n   \"TARGET_32BIT\"\n-  \"@\n-   bctr\n-   {br|blr}\"\n+  \"b%T0\"\n   [(set_attr \"type\" \"jmpreg\")])\n \n (define_insn \"indirect_jumpdi\"\n-  [(set (pc) (match_operand:DI 0 \"register_operand\" \"c,l\"))]\n+  [(set (pc) (match_operand:DI 0 \"register_operand\" \"cl\"))]\n   \"TARGET_64BIT\"\n-  \"@\n-   bctr\n-   {br|blr}\"\n+  \"b%T0\"\n   [(set_attr \"type\" \"jmpreg\")])\n \n ;; Table jump for switch statements:\n@@ -13285,22 +13269,18 @@ operands[2] = GEN_INT (INTVAL (operands[1]) >> 32);\n \n (define_insn \"\"\n   [(set (pc)\n-\t(match_operand:SI 0 \"register_operand\" \"c,l\"))\n+\t(match_operand:SI 0 \"register_operand\" \"cl\"))\n    (use (label_ref (match_operand 1 \"\" \"\")))]\n   \"TARGET_32BIT\"\n-  \"@\n-   bctr\n-   {br|blr}\"\n+  \"b%T0\"\n   [(set_attr \"type\" \"jmpreg\")])\n \n (define_insn \"\"\n   [(set (pc)\n-\t(match_operand:DI 0 \"register_operand\" \"c,l\"))\n+\t(match_operand:DI 0 \"register_operand\" \"cl\"))\n    (use (label_ref (match_operand 1 \"\" \"\")))]\n   \"TARGET_64BIT\"\n-  \"@\n-   bctr\n-   {br|blr}\"\n+  \"b%T0\"\n   [(set_attr \"type\" \"jmpreg\")])\n \n (define_insn \"nop\"\n@@ -13898,21 +13878,17 @@ operands[2] = GEN_INT (INTVAL (operands[1]) >> 32);\n  \"{lm|lmw} %1,%2\")\n  \n (define_insn \"*return_internal_si\"\n-  [(use (match_operand:SI 0 \"register_operand\" \"l,c\"))\n+  [(use (match_operand:SI 0 \"register_operand\" \"lc\"))\n    (return)]\n   \"TARGET_32BIT\"\n-  \"@\n-   {br|blr}\n-   bctr\"\n+  \"b%T0\"\n   [(set_attr \"type\" \"jmpreg\")])\n \n (define_insn \"*return_internal_di\"\n-  [(use (match_operand:DI 0 \"register_operand\" \"l,c\"))\n+  [(use (match_operand:DI 0 \"register_operand\" \"lc\"))\n    (return)]\n   \"TARGET_64BIT\"\n-  \"@\n-   {br|blr}\n-   bctr\"\n+  \"b%T0\"\n   [(set_attr \"type\" \"jmpreg\")])\n \n ; FIXME: This would probably be somewhat simpler if the Cygnus sibcall\n@@ -14037,23 +14013,19 @@ operands[2] = GEN_INT (INTVAL (operands[1]) >> 32);\n \n \n (define_insn \"return_eh_si\"\n-  [(use (match_operand:SI 0 \"register_operand\" \"l,c\"))\n+  [(use (match_operand:SI 0 \"register_operand\" \"lc\"))\n    (return)\n    (use (reg:SI 2))\n    (use (reg:SI 3))]\n   \"TARGET_32BIT\"\n-  \"@\n-   {br|blr}\n-   bctr\"\n+  \"b%T0\"\n   [(set_attr \"type\" \"jmpreg\")])\n \n (define_insn \"return_eh_di\"\n-  [(use (match_operand:DI 0 \"register_operand\" \"l,c\"))\n+  [(use (match_operand:DI 0 \"register_operand\" \"lc\"))\n    (return)\n    (use (reg:DI 2))\n    (use (reg:DI 3))]\n   \"TARGET_64BIT\"\n-  \"@\n-   {br|blr}\n-   bctr\"\n+  \"b%T0\"\n   [(set_attr \"type\" \"jmpreg\")])"}]}