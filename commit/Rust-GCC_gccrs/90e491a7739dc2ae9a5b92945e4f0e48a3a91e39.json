{"sha": "90e491a7739dc2ae9a5b92945e4f0e48a3a91e39", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTBlNDkxYTc3MzlkYzJhZTlhNWI5Mjk0NWU0ZjBlNDhhM2E5MWUzOQ==", "commit": {"author": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2017-10-09T19:43:32Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2017-10-09T19:43:32Z"}, "message": "[multiple changes]\n\n2017-10-09  Bob Duff  <duff@adacore.com>\n\n\t* exp_ch6.adb (Make_Build_In_Place_Call_In_Object_Declaration): Use\n\tDefining_Identifier (Obj_Decl) in two places, because it might have\n\tchanged.\n\t* exp_ch6.adb (Make_Build_In_Place_Call_In_Allocator): Deal with cases\n\tinvolving 'Input on (not visibly) derived types.\n\n2017-10-09  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* atree.adb: Add new soft link Rewriting_Proc.\n\t(Rewrite): Invoke the subprogram attached to the rewriting soft link.\n\t(Set_Rewriting_Proc): New routine.\n\t* attree.ads: Add new access-to-subprogram type Rewrite_Proc.\n\t(Set_Rewriting_Proc): New routine.\n\t* checks.adb (Install_Primitive_Elaboration_Check): Use 'E' character\n\tfor *E*laboration flag to maintain consistency with other elaboration\n\tflag generating subprograms.\n\t* debug.adb: Document the new usage of flag -gnatdL.\n\t* einfo.adb: Node19 is now used as Receiving_Entry.  Node39 is now used\n\tas Protected_Subprogram.  Flag148 is now used as\n\tIs_Elaboration_Checks_OK_Id.  Flag302 is now used as\n\tIs_Initial_Condition_Procedure.\n\t(Is_Elaboration_Checks_OK_Id): New routine.\n\t(Is_Initial_Condition_Procedure): New routine.\n\t(Protected_Subprogram): New routine.\n\t(Receiving_Entry): New routine.\n\t(SPARK_Pragma): Update assertion.\n\t(SPARK_Pragma_Inherited): Update assertion.\n\t(Suppress_Elaboration_Warnings): Removed.\n\t(Set_Is_Elaboration_Checks_OK_Id): New routine.\n\t(Set_Is_Initial_Condition_Procedure): New routine.\n\t(Set_Protected_Subprogram): New routine.\n\t(Set_Receiving_Entry): New routine.\n\t(Set_SPARK_Pragma): Update assertion.\n\t(Set_SPARK_Pragma_Inherited): Update assertion.\n\t(Write_Entity_Flags): Update the output for Flag148 and Flag302.\n\t(Write_Field19_Name): Add output for Receiving_Entry.\n\t(Write_Field39_Name): Add output for Protected_Subprogram.\n\t(Write_Field40_Name): Update the output for SPARK_Pragma.\n\t* einfo.ads: New attributes Is_Elaboration_Checks_OK_Id,\n\tIs_Initial_Condition_Procedure, Protected_Subprogram, Receiving_Entry.\n\tRemove attribute Suppress_Elaboration_Warnings.  Update the stricture\n\tof various entities.\n\t(Is_Elaboration_Checks_OK_Id): New routine along with pragma Inline.\n\t(Is_Initial_Condition_Procedure): New routine along with pragma Inline.\n\t(Protected_Subprogram): New routine along with pragma Inline.\n\t(Receiving_Entry): New routine along with pragma Inline.\n\t(Suppress_Elaboration_Warnings): Removed.\n\t(Set_Is_Elaboration_Checks_OK_Id): New routine along with pragma\n\tInline.\n\t(Set_Is_Initial_Condition_Procedure): New routine along with pragma\n\tInline.\n\t(Set_Protected_Subprogram): New routine along with pragma Inline.\n\t(Set_Receiving_Entry): New routine along with pragma Inline.\n\t(Set_Suppress_Elaboration_Warnings): Removed.\n\t* exp_ch3.adb (Build_Init_Procedure): Use name _Finalizer to maintain\n\tconsistency with other finalizer generating subprograms.\n\t(Default_Initialize_Object): Mark the block which wraps the call to\n\tfinalize as being part of initialization.\n\t* exp_ch7.adb (Expand_N_Package_Declaration): Directly expand pragma\n\tInitial_Condition.\n\t(Expand_N_Package_Body): Directly expand pragma Initial_Condition.\n\t(Next_Suitable_Statement): Update the comment on usage. Skip over call\n\tmarkers generated by the ABE mechanism.\n\t* exp_ch9.adb (Activation_Call_Loc): New routine.\n\t(Add_Accept): Link the accept procedure to the original entry.\n\t(Build_Protected_Sub_Specification): Link the protected or unprotected\n\tversion to the original subprogram.\n\t(Build_Task_Activation_Call): Code cleanup. Use a source location which\n\tis very close to the \"begin\" or \"end\" keywords when generating the\n\tactivation call.\n\t* exp_prag.adb (Expand_Pragma_Initial_Condition): Reimplemented.\n\t* exp_spark.adb (Expand_SPARK): Use Expand_SPARK_N_Loop_Statement to\n\tprocess loops.\n\t(Expand_SPARK_N_Loop_Statement): New routine.\n\t(Expand_SPARK_N_Object_Declaration): Code cleanup. Partially insert the\n\tcall to the Default_Initial_Condition procedure.\n\t(Expand_SPARK_Op_Ne): Renamed to Expand_SPARK_N_Op_Ne.\n\t* exp_util.adb (Build_DIC_Procedure_Body): Capture the SPARK_Mode in\n\teffect.\n\t(Build_DIC_Procedure_Declaration): Capture the SPARK_Mode in effect.\n\t(Insert_Actions): Add processing for N_Call_Marker.\n\t(Kill_Dead_Code): Explicitly kill an elaboration scenario.\n\t* exp_util.ads (Make_Invariant_Call): Update the comment on usage.\n\t* frontend.adb: Initialize Sem_Elab. Process all saved top level\n\telaboration scenarios for ABE issues.\n\t* gcc-interface/trans.c (gnat_to_gnu): Add processing for N_Call_Marker\n\tnodes.\n\t* lib.adb (Earlier_In_Extended_Unit): New variant.\n\t* sem.adb (Analyze): Ignore N_Call_Marker nodes.\n\t(Preanalysis_Active): New routine.\n\t* sem.ads (Preanalysis_Active): New routine.\n\t* sem_attr.adb (Analyze_Access_Attribute): Save certain\n\telaboration-related attributes. Save the scenario for ABE processing.\n\t* sem_ch3.adb (Analyze_Object_Declaration): Save the SPARK mode in\n\teffect. Save certain elaboration-related attributes.\n\t* sem_ch5.adb (Analyze_Assignment): Save certain elaboration-related\n\tattributes. Save the scenario for ABE processing.\n\t* sem_ch6.adb (Analyze_Abstract_Subprogram_Declaration): Save the SPARK\n\tmode in effect. Save certain elaboration-related attributes.\n\t(Analyze_Subprogram_Body_Helper): Skip N_Call_Marker nodes when\n\tlocating the first real statement.\n\t(Analyze_Subprogram_Declaration): Save the SPARK mode in effect. Save\n\tcertain elaboration-related attributes.\n\t* sem_ch7.adb (Analyze_Package_Declaration): Do not suppress\n\telaboration warnings.\n\t* sem_ch8.adb (Attribute_Renaming): Mark a subprogram body which was\n\tgenerated for purposes of wrapping an attribute used as a generic\n\tactual.\n\t(Find_Direct_Name): Save certain elaboration-related attributes. Save\n\tthe scenario for ABE processing.\n\t(Find_Expanded_Name): Save certain elaboration-related attributes. Save\n\tthe scenario for ABE processing.\n\t* sem_ch9.adb (Analyze_Entry_Declaration): Save certain\n\telaboration-related attributes.\n\t(Analyze_Requeue): Save certain elaboration-related attributes. Save\n\tthe scenario for ABE processing.\n\t(Analyze_Single_Task_Declaration): Save certain elaboration-related\n\tattributes.\n\t(Analyze_Task_Type_Declaration): Save certain elaboration-related\n\tattributes.\n\t* sem_ch12.adb (Analyze_Generic_Package_Declaration): Save certain\n\telaboration-related attributes.\n\t(Analyze_Generic_Subprogram_Declaration): Save the SPARK mode in\n\teffect. Save certain elaboration-related attributes.\n\t(Analyze_Package_Instantiation): Save certain elaboration-related\n\tattributes.  Save the scenario for ABE processing. Create completing\n\tbodies in case the instantiation results in a guaranteed ABE.\n\t(Analyze_Subprogram_Instantiation): Save certain elaboration-related\n\tattributes Save the scenario for ABE processing. Create a completing\n\tbody in case the instantiation results in a guaranteed ABE.\n\t(Provide_Completing_Bodies): New routine.\n\t* sem_elab.ads: Brand new implementation.\n\t* sem_prag.adb (Analyze_Pragma, cases Elaborate, Elaborate_All,\n\tElaborate_Body): Do not suppress elaboration warnings.\n\t* sem_res.adb (Make_Call_Into_Operator): Set the parent field of the\n\toperator.\n\t(Resolve_Call): Save certain elaboration-related attributes. Save the\n\tscenario for ABE processing.\n\t(Resolve_Entity_Name): Do not perform any ABE processing here.\n\t(Resolve_Entry_Call): Inherit certain attributes from the original call.\n\t* sem_util.adb (Begin_Keyword_Location): New routine.\n\t(Defining_Entity): Update the parameter profile. Add processing for\n\tconcurrent subunits that are rewritten as null statements.\n\t(End_Keyword_Location): New routine.\n\t(Find_Enclosing_Scope): New routine.\n\t(In_Instance_Visible_Part): Code cleanup.\n\t(In_Subtree): Update the parameter profile. Add new version.\n\t(Is_Preelaborable_Aggregate): New routine.\n\t(Is_Preelaborable_Construct): New routine.\n\t(Mark_Elaboration_Attributes): New routine.\n\t(Scope_Within): Update the parameter profile.\n\t(Scope_Within_Or_Same): Update the parameter profile.\n\t* sem_util.ads (Begin_Keyword_Location): New routine.\n\t(Defining_Entity): Update the parameter profile and the comment on\n\tusage.\n\t(End_Keyword_Location): New routine.\n\t(Find_Enclosing_Scope): New routine.\n\t(In_Instance_Visible_Part): Update the parameter profile.\n\t(In_Subtree): Update the parameter profile. Add new version.\n\t(Is_Preelaborable_Aggregate): New routine.\n\t(Is_Preelaborable_Construct): New routine.\n\t(Mark_Elaboration_Attributes): New routine.\n\t(Scope_Within): Update the parameter profile and the comment on usage.\n\t(Scope_Within_Or_Same): Update the parameter profile and the comment on\n\tusage.\n\t* sem_warn.adb (Check_Infinite_Loop_Warning): Use Has_Condition_Actions\n\tto determine whether a loop has meaningful condition actions.\n\t(Has_Condition_Actions): New routine.\n\t* sinfo.adb (ABE_Is_Certain): Removed.\n\t(Is_Declaration_Level_Node): New routine.\n\t(Is_Dispatching_Call): New routine.\n\t(Is_Elaboration_Checks_OK_Node): New routine.\n\t(Is_Initialization_Block): New routine.\n\t(Is_Known_Guaranteed_ABE): New routine.\n\t(Is_Recorded_Scenario): New routine.\n\t(Is_Source_Call): New routine.\n\t(Is_SPARK_Mode_On_Node): New routine.\n\t(No_Elaboration_Check): Removed.\n\t(Target): New routine.\n\t(Was_Attribute_Reference): New routine.\n\t(Set_ABE_Is_Certain): Removed.\n\t(Set_Is_Declaration_Level_Node): New routine.\n\t(Set_Is_Dispatching_Call): New routine.\n\t(Set_Is_Elaboration_Checks_OK_Node): New routine.\n\t(Set_Is_Initialization_Block): New routine.\n\t(Set_Is_Known_Guaranteed_ABE): New routine.\n\t(Set_Is_Recorded_Scenario): New routine.\n\t(Set_Is_Source_Call): New routine.\n\t(Set_Is_SPARK_Mode_On_Node): New routine.\n\t(Set_No_Elaboration_Check): Removed.\n\t(Set_Target): New routine.\n\t(Set_Was_Attribute_Reference): New routine.\n\t* sinfo.ads: Remove attribute ABE_Is_Certain.  Attribute\n\tDo_Discriminant_Check now utilizes Flag3.  Attribute\n\tNo_Side_Effect_Removal now utilizes Flag17.  Add new node\n\tN_Call_Marker.  Update the structure of various nodes.\n\t(ABE_Is_Certain): Removed along with pragma Inline.\n\t(Is_Declaration_Level_Node): New routine along with pragma Inline.\n\t(Is_Dispatching_Call): New routine along with pragma Inline.\n\t(Is_Elaboration_Checks_OK_Node): New routine along with pragma Inline.\n\t(Is_Initialization_Block): New routine along with pragma Inline.\n\t(Is_Known_Guaranteed_ABE): New routine along with pragma Inline.\n\t(Is_Recorded_Scenario): New routine along with pragma Inline.\n\t(Is_Source_Call): New routine along with pragma Inline.\n\t(Is_SPARK_Mode_On_Node): New routine along with pragma Inline.\n\t(No_Elaboration_Check): Removed along with pragma Inline.\n\t(Target): New routine along with pragma Inline.\n\t(Was_Attribute_Reference): New routine along with pragma Inline.\n\t(Set_ABE_Is_Certain): Removed along with pragma Inline.\n\t(Set_Is_Declaration_Level_Node): New routine along with pragma Inline.\n\t(Set_Is_Dispatching_Call): New routine along with pragma Inline.\n\t(Set_Is_Elaboration_Checks_OK_Node): New routine along with pragma\n\tInline.\n\t(Set_Is_Initialization_Block): New routine along with pragma Inline.\n\t(Set_Is_Known_Guaranteed_ABE): New routine along with pragma Inline.\n\t(Set_Is_Recorded_Scenario): New routine along with pragma Inline.\n\t(Set_Is_Source_Call): New routine along with pragma Inline.\n\t(Set_Is_SPARK_Mode_On_Node): New routine along with pragma Inline.\n\t(Set_No_Elaboration_Check): Removed along with pragma Inline.\n\t(Set_Target): New routine along with pragma Inline.\n\t(Set_Was_Attribute_Reference): New routine along with pragma Inline.\n\t* sprint.adb (Sprint_Node_Actual): Add an entry for N_Call_Marker.\n\nFrom-SVN: r253559", "tree": {"sha": "a6451c66b3e38255388c71e8bb58bdd1b0af5035", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a6451c66b3e38255388c71e8bb58bdd1b0af5035"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/90e491a7739dc2ae9a5b92945e4f0e48a3a91e39", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90e491a7739dc2ae9a5b92945e4f0e48a3a91e39", "html_url": "https://github.com/Rust-GCC/gccrs/commit/90e491a7739dc2ae9a5b92945e4f0e48a3a91e39", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90e491a7739dc2ae9a5b92945e4f0e48a3a91e39/comments", "author": null, "committer": null, "parents": [{"sha": "341af81e6e41d0633adbe3461cf4f987385e26d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/341af81e6e41d0633adbe3461cf4f987385e26d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/341af81e6e41d0633adbe3461cf4f987385e26d2"}], "stats": {"total": 20653, "additions": 13333, "deletions": 7320}, "files": [{"sha": "85825d060f016bbb3dd7069a251992183c77e4ea", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 225, "deletions": 0, "changes": 225, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e491a7739dc2ae9a5b92945e4f0e48a3a91e39/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e491a7739dc2ae9a5b92945e4f0e48a3a91e39/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=90e491a7739dc2ae9a5b92945e4f0e48a3a91e39", "patch": "@@ -1,3 +1,228 @@\n+2017-10-09  Bob Duff  <duff@adacore.com>\n+\n+\t* exp_ch6.adb (Make_Build_In_Place_Call_In_Object_Declaration): Use\n+\tDefining_Identifier (Obj_Decl) in two places, because it might have\n+\tchanged.\n+\t* exp_ch6.adb (Make_Build_In_Place_Call_In_Allocator): Deal with cases\n+\tinvolving 'Input on (not visibly) derived types.\n+\n+2017-10-09  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* atree.adb: Add new soft link Rewriting_Proc.\n+\t(Rewrite): Invoke the subprogram attached to the rewriting soft link.\n+\t(Set_Rewriting_Proc): New routine.\n+\t* attree.ads: Add new access-to-subprogram type Rewrite_Proc.\n+\t(Set_Rewriting_Proc): New routine.\n+\t* checks.adb (Install_Primitive_Elaboration_Check): Use 'E' character\n+\tfor *E*laboration flag to maintain consistency with other elaboration\n+\tflag generating subprograms.\n+\t* debug.adb: Document the new usage of flag -gnatdL.\n+\t* einfo.adb: Node19 is now used as Receiving_Entry.  Node39 is now used\n+\tas Protected_Subprogram.  Flag148 is now used as\n+\tIs_Elaboration_Checks_OK_Id.  Flag302 is now used as\n+\tIs_Initial_Condition_Procedure.\n+\t(Is_Elaboration_Checks_OK_Id): New routine.\n+\t(Is_Initial_Condition_Procedure): New routine.\n+\t(Protected_Subprogram): New routine.\n+\t(Receiving_Entry): New routine.\n+\t(SPARK_Pragma): Update assertion.\n+\t(SPARK_Pragma_Inherited): Update assertion.\n+\t(Suppress_Elaboration_Warnings): Removed.\n+\t(Set_Is_Elaboration_Checks_OK_Id): New routine.\n+\t(Set_Is_Initial_Condition_Procedure): New routine.\n+\t(Set_Protected_Subprogram): New routine.\n+\t(Set_Receiving_Entry): New routine.\n+\t(Set_SPARK_Pragma): Update assertion.\n+\t(Set_SPARK_Pragma_Inherited): Update assertion.\n+\t(Write_Entity_Flags): Update the output for Flag148 and Flag302.\n+\t(Write_Field19_Name): Add output for Receiving_Entry.\n+\t(Write_Field39_Name): Add output for Protected_Subprogram.\n+\t(Write_Field40_Name): Update the output for SPARK_Pragma.\n+\t* einfo.ads: New attributes Is_Elaboration_Checks_OK_Id,\n+\tIs_Initial_Condition_Procedure, Protected_Subprogram, Receiving_Entry.\n+\tRemove attribute Suppress_Elaboration_Warnings.  Update the stricture\n+\tof various entities.\n+\t(Is_Elaboration_Checks_OK_Id): New routine along with pragma Inline.\n+\t(Is_Initial_Condition_Procedure): New routine along with pragma Inline.\n+\t(Protected_Subprogram): New routine along with pragma Inline.\n+\t(Receiving_Entry): New routine along with pragma Inline.\n+\t(Suppress_Elaboration_Warnings): Removed.\n+\t(Set_Is_Elaboration_Checks_OK_Id): New routine along with pragma\n+\tInline.\n+\t(Set_Is_Initial_Condition_Procedure): New routine along with pragma\n+\tInline.\n+\t(Set_Protected_Subprogram): New routine along with pragma Inline.\n+\t(Set_Receiving_Entry): New routine along with pragma Inline.\n+\t(Set_Suppress_Elaboration_Warnings): Removed.\n+\t* exp_ch3.adb (Build_Init_Procedure): Use name _Finalizer to maintain\n+\tconsistency with other finalizer generating subprograms.\n+\t(Default_Initialize_Object): Mark the block which wraps the call to\n+\tfinalize as being part of initialization.\n+\t* exp_ch7.adb (Expand_N_Package_Declaration): Directly expand pragma\n+\tInitial_Condition.\n+\t(Expand_N_Package_Body): Directly expand pragma Initial_Condition.\n+\t(Next_Suitable_Statement): Update the comment on usage. Skip over call\n+\tmarkers generated by the ABE mechanism.\n+\t* exp_ch9.adb (Activation_Call_Loc): New routine.\n+\t(Add_Accept): Link the accept procedure to the original entry.\n+\t(Build_Protected_Sub_Specification): Link the protected or unprotected\n+\tversion to the original subprogram.\n+\t(Build_Task_Activation_Call): Code cleanup. Use a source location which\n+\tis very close to the \"begin\" or \"end\" keywords when generating the\n+\tactivation call.\n+\t* exp_prag.adb (Expand_Pragma_Initial_Condition): Reimplemented.\n+\t* exp_spark.adb (Expand_SPARK): Use Expand_SPARK_N_Loop_Statement to\n+\tprocess loops.\n+\t(Expand_SPARK_N_Loop_Statement): New routine.\n+\t(Expand_SPARK_N_Object_Declaration): Code cleanup. Partially insert the\n+\tcall to the Default_Initial_Condition procedure.\n+\t(Expand_SPARK_Op_Ne): Renamed to Expand_SPARK_N_Op_Ne.\n+\t* exp_util.adb (Build_DIC_Procedure_Body): Capture the SPARK_Mode in\n+\teffect.\n+\t(Build_DIC_Procedure_Declaration): Capture the SPARK_Mode in effect.\n+\t(Insert_Actions): Add processing for N_Call_Marker.\n+\t(Kill_Dead_Code): Explicitly kill an elaboration scenario.\n+\t* exp_util.ads (Make_Invariant_Call): Update the comment on usage.\n+\t* frontend.adb: Initialize Sem_Elab. Process all saved top level\n+\telaboration scenarios for ABE issues.\n+\t* gcc-interface/trans.c (gnat_to_gnu): Add processing for N_Call_Marker\n+\tnodes.\n+\t* lib.adb (Earlier_In_Extended_Unit): New variant.\n+\t* sem.adb (Analyze): Ignore N_Call_Marker nodes.\n+\t(Preanalysis_Active): New routine.\n+\t* sem.ads (Preanalysis_Active): New routine.\n+\t* sem_attr.adb (Analyze_Access_Attribute): Save certain\n+\telaboration-related attributes. Save the scenario for ABE processing.\n+\t* sem_ch3.adb (Analyze_Object_Declaration): Save the SPARK mode in\n+\teffect. Save certain elaboration-related attributes.\n+\t* sem_ch5.adb (Analyze_Assignment): Save certain elaboration-related\n+\tattributes. Save the scenario for ABE processing.\n+\t* sem_ch6.adb (Analyze_Abstract_Subprogram_Declaration): Save the SPARK\n+\tmode in effect. Save certain elaboration-related attributes.\n+\t(Analyze_Subprogram_Body_Helper): Skip N_Call_Marker nodes when\n+\tlocating the first real statement.\n+\t(Analyze_Subprogram_Declaration): Save the SPARK mode in effect. Save\n+\tcertain elaboration-related attributes.\n+\t* sem_ch7.adb (Analyze_Package_Declaration): Do not suppress\n+\telaboration warnings.\n+\t* sem_ch8.adb (Attribute_Renaming): Mark a subprogram body which was\n+\tgenerated for purposes of wrapping an attribute used as a generic\n+\tactual.\n+\t(Find_Direct_Name): Save certain elaboration-related attributes. Save\n+\tthe scenario for ABE processing.\n+\t(Find_Expanded_Name): Save certain elaboration-related attributes. Save\n+\tthe scenario for ABE processing.\n+\t* sem_ch9.adb (Analyze_Entry_Declaration): Save certain\n+\telaboration-related attributes.\n+\t(Analyze_Requeue): Save certain elaboration-related attributes. Save\n+\tthe scenario for ABE processing.\n+\t(Analyze_Single_Task_Declaration): Save certain elaboration-related\n+\tattributes.\n+\t(Analyze_Task_Type_Declaration): Save certain elaboration-related\n+\tattributes.\n+\t* sem_ch12.adb (Analyze_Generic_Package_Declaration): Save certain\n+\telaboration-related attributes.\n+\t(Analyze_Generic_Subprogram_Declaration): Save the SPARK mode in\n+\teffect. Save certain elaboration-related attributes.\n+\t(Analyze_Package_Instantiation): Save certain elaboration-related\n+\tattributes.  Save the scenario for ABE processing. Create completing\n+\tbodies in case the instantiation results in a guaranteed ABE.\n+\t(Analyze_Subprogram_Instantiation): Save certain elaboration-related\n+\tattributes Save the scenario for ABE processing. Create a completing\n+\tbody in case the instantiation results in a guaranteed ABE.\n+\t(Provide_Completing_Bodies): New routine.\n+\t* sem_elab.ads: Brand new implementation.\n+\t* sem_prag.adb (Analyze_Pragma, cases Elaborate, Elaborate_All,\n+\tElaborate_Body): Do not suppress elaboration warnings.\n+\t* sem_res.adb (Make_Call_Into_Operator): Set the parent field of the\n+\toperator.\n+\t(Resolve_Call): Save certain elaboration-related attributes. Save the\n+\tscenario for ABE processing.\n+\t(Resolve_Entity_Name): Do not perform any ABE processing here.\n+\t(Resolve_Entry_Call): Inherit certain attributes from the original call.\n+\t* sem_util.adb (Begin_Keyword_Location): New routine.\n+\t(Defining_Entity): Update the parameter profile. Add processing for\n+\tconcurrent subunits that are rewritten as null statements.\n+\t(End_Keyword_Location): New routine.\n+\t(Find_Enclosing_Scope): New routine.\n+\t(In_Instance_Visible_Part): Code cleanup.\n+\t(In_Subtree): Update the parameter profile. Add new version.\n+\t(Is_Preelaborable_Aggregate): New routine.\n+\t(Is_Preelaborable_Construct): New routine.\n+\t(Mark_Elaboration_Attributes): New routine.\n+\t(Scope_Within): Update the parameter profile.\n+\t(Scope_Within_Or_Same): Update the parameter profile.\n+\t* sem_util.ads (Begin_Keyword_Location): New routine.\n+\t(Defining_Entity): Update the parameter profile and the comment on\n+\tusage.\n+\t(End_Keyword_Location): New routine.\n+\t(Find_Enclosing_Scope): New routine.\n+\t(In_Instance_Visible_Part): Update the parameter profile.\n+\t(In_Subtree): Update the parameter profile. Add new version.\n+\t(Is_Preelaborable_Aggregate): New routine.\n+\t(Is_Preelaborable_Construct): New routine.\n+\t(Mark_Elaboration_Attributes): New routine.\n+\t(Scope_Within): Update the parameter profile and the comment on usage.\n+\t(Scope_Within_Or_Same): Update the parameter profile and the comment on\n+\tusage.\n+\t* sem_warn.adb (Check_Infinite_Loop_Warning): Use Has_Condition_Actions\n+\tto determine whether a loop has meaningful condition actions.\n+\t(Has_Condition_Actions): New routine.\n+\t* sinfo.adb (ABE_Is_Certain): Removed.\n+\t(Is_Declaration_Level_Node): New routine.\n+\t(Is_Dispatching_Call): New routine.\n+\t(Is_Elaboration_Checks_OK_Node): New routine.\n+\t(Is_Initialization_Block): New routine.\n+\t(Is_Known_Guaranteed_ABE): New routine.\n+\t(Is_Recorded_Scenario): New routine.\n+\t(Is_Source_Call): New routine.\n+\t(Is_SPARK_Mode_On_Node): New routine.\n+\t(No_Elaboration_Check): Removed.\n+\t(Target): New routine.\n+\t(Was_Attribute_Reference): New routine.\n+\t(Set_ABE_Is_Certain): Removed.\n+\t(Set_Is_Declaration_Level_Node): New routine.\n+\t(Set_Is_Dispatching_Call): New routine.\n+\t(Set_Is_Elaboration_Checks_OK_Node): New routine.\n+\t(Set_Is_Initialization_Block): New routine.\n+\t(Set_Is_Known_Guaranteed_ABE): New routine.\n+\t(Set_Is_Recorded_Scenario): New routine.\n+\t(Set_Is_Source_Call): New routine.\n+\t(Set_Is_SPARK_Mode_On_Node): New routine.\n+\t(Set_No_Elaboration_Check): Removed.\n+\t(Set_Target): New routine.\n+\t(Set_Was_Attribute_Reference): New routine.\n+\t* sinfo.ads: Remove attribute ABE_Is_Certain.  Attribute\n+\tDo_Discriminant_Check now utilizes Flag3.  Attribute\n+\tNo_Side_Effect_Removal now utilizes Flag17.  Add new node\n+\tN_Call_Marker.  Update the structure of various nodes.\n+\t(ABE_Is_Certain): Removed along with pragma Inline.\n+\t(Is_Declaration_Level_Node): New routine along with pragma Inline.\n+\t(Is_Dispatching_Call): New routine along with pragma Inline.\n+\t(Is_Elaboration_Checks_OK_Node): New routine along with pragma Inline.\n+\t(Is_Initialization_Block): New routine along with pragma Inline.\n+\t(Is_Known_Guaranteed_ABE): New routine along with pragma Inline.\n+\t(Is_Recorded_Scenario): New routine along with pragma Inline.\n+\t(Is_Source_Call): New routine along with pragma Inline.\n+\t(Is_SPARK_Mode_On_Node): New routine along with pragma Inline.\n+\t(No_Elaboration_Check): Removed along with pragma Inline.\n+\t(Target): New routine along with pragma Inline.\n+\t(Was_Attribute_Reference): New routine along with pragma Inline.\n+\t(Set_ABE_Is_Certain): Removed along with pragma Inline.\n+\t(Set_Is_Declaration_Level_Node): New routine along with pragma Inline.\n+\t(Set_Is_Dispatching_Call): New routine along with pragma Inline.\n+\t(Set_Is_Elaboration_Checks_OK_Node): New routine along with pragma\n+\tInline.\n+\t(Set_Is_Initialization_Block): New routine along with pragma Inline.\n+\t(Set_Is_Known_Guaranteed_ABE): New routine along with pragma Inline.\n+\t(Set_Is_Recorded_Scenario): New routine along with pragma Inline.\n+\t(Set_Is_Source_Call): New routine along with pragma Inline.\n+\t(Set_Is_SPARK_Mode_On_Node): New routine along with pragma Inline.\n+\t(Set_No_Elaboration_Check): Removed along with pragma Inline.\n+\t(Set_Target): New routine along with pragma Inline.\n+\t(Set_Was_Attribute_Reference): New routine along with pragma Inline.\n+\t* sprint.adb (Sprint_Node_Actual): Add an entry for N_Call_Marker.\n+\n 2017-10-09  Bob Duff  <duff@adacore.com>\n \n \t* exp_ch7.adb (Create_Finalizer): Suppress checks within the finalizer."}, {"sha": "f5a00991768b26dbf34cd31f18ab5c83ee2233bb", "filename": "gcc/ada/atree.adb", "status": "modified", "additions": 29, "deletions": 10, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e491a7739dc2ae9a5b92945e4f0e48a3a91e39/gcc%2Fada%2Fatree.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e491a7739dc2ae9a5b92945e4f0e48a3a91e39/gcc%2Fada%2Fatree.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.adb?ref=90e491a7739dc2ae9a5b92945e4f0e48a3a91e39", "patch": "@@ -56,6 +56,9 @@ package body Atree is\n    Reporting_Proc : Report_Proc := null;\n    --  Record argument to last call to Set_Reporting_Proc\n \n+   Rewriting_Proc : Rewrite_Proc := null;\n+   --  This soft link captures the procedure invoked during a node rewrite\n+\n    ---------------\n    -- Debugging --\n    ---------------\n@@ -1306,16 +1309,6 @@ package body Atree is\n         Ekind_In (Ekind (E), V1, V2, V3, V4, V5, V6, V7, V8, V9, V10, V11);\n    end Ekind_In;\n \n-   ------------------------\n-   -- Set_Reporting_Proc --\n-   ------------------------\n-\n-   procedure Set_Reporting_Proc (P : Report_Proc) is\n-   begin\n-      pragma Assert (Reporting_Proc = null);\n-      Reporting_Proc := P;\n-   end Set_Reporting_Proc;\n-\n    ------------------\n    -- Error_Posted --\n    ------------------\n@@ -2253,6 +2246,12 @@ package body Atree is\n       if Reporting_Proc /= null then\n          Reporting_Proc.all (Target => Old_Node, Source => New_Node);\n       end if;\n+\n+      --  Invoke the rewriting procedure (if available)\n+\n+      if Rewriting_Proc /= null then\n+         Rewriting_Proc.all (Target => Old_Node, Source => New_Node);\n+      end if;\n    end Rewrite;\n \n    ------------------\n@@ -2390,6 +2389,16 @@ package body Atree is\n       Nodes.Table (N).Link := Union_Id (Val);\n    end Set_Parent;\n \n+   ------------------------\n+   -- Set_Reporting_Proc --\n+   ------------------------\n+\n+   procedure Set_Reporting_Proc (Proc : Report_Proc) is\n+   begin\n+      pragma Assert (Reporting_Proc = null);\n+      Reporting_Proc := Proc;\n+   end Set_Reporting_Proc;\n+\n    --------------\n    -- Set_Sloc --\n    --------------\n@@ -2400,6 +2409,16 @@ package body Atree is\n       Nodes.Table (N).Sloc := Val;\n    end Set_Sloc;\n \n+   ------------------------\n+   -- Set_Rewriting_Proc --\n+   ------------------------\n+\n+   procedure Set_Rewriting_Proc (Proc : Rewrite_Proc) is\n+   begin\n+      pragma Assert (Rewriting_Proc = null);\n+      Rewriting_Proc := Proc;\n+   end Set_Rewriting_Proc;\n+\n    ----------\n    -- Sloc --\n    ----------"}, {"sha": "bf0da1604eaead236623aa0bda0cfe2797503cb7", "filename": "gcc/ada/atree.ads", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e491a7739dc2ae9a5b92945e4f0e48a3a91e39/gcc%2Fada%2Fatree.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e491a7739dc2ae9a5b92945e4f0e48a3a91e39/gcc%2Fada%2Fatree.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.ads?ref=90e491a7739dc2ae9a5b92945e4f0e48a3a91e39", "patch": "@@ -572,10 +572,15 @@ package Atree is\n \n    type Report_Proc is access procedure (Target : Node_Id; Source : Node_Id);\n \n-   procedure Set_Reporting_Proc (P : Report_Proc);\n+   procedure Set_Reporting_Proc (Proc : Report_Proc);\n    --  Register a procedure that is invoked when a node is allocated, replaced\n    --  or rewritten.\n \n+   type Rewrite_Proc is access procedure (Target : Node_Id; Source : Node_Id);\n+\n+   procedure Set_Rewriting_Proc (Proc : Rewrite_Proc);\n+   --  Register a procedure that is invoked when a node is rewritten\n+\n    type Traverse_Result is (Abandon, OK, OK_Orig, Skip);\n    --  This is the type of the result returned by the Process function passed\n    --  to Traverse_Func and Traverse_Proc. See below for details.\n@@ -4231,25 +4236,26 @@ package Atree is\n       --  for extending components are completely unused.\n \n       type Flags_Byte is record\n-         Flag0  : Boolean;\n+         Flag0 : Boolean;\n          --  Note: we don't use Flag0 at the moment. To put Flag0 into use\n          --  requires some awkward work in Treeprs (treeprs.adt), so for the\n          --  moment we don't use it.\n \n-         Flag1  : Boolean;\n-         Flag2  : Boolean;\n-         Flag3  : Boolean;\n+         Flag1 : Boolean;\n+         Flag2 : Boolean;\n+         Flag3 : Boolean;\n          --  These flags are used in the usual manner in Sinfo and Einfo\n \n-         Is_Ignored_Ghost_Node : Boolean;\n-         --  Flag denoting whether the node is subject to pragma Ghost with\n-         --  policy Ignore. The name of the flag should be Flag4, however this\n-         --  requires changing the names of all remaining 300+ flags.\n+         --  The flags listed below use explicit names because following the\n+         --  FlagXXX convention would mean reshuffling of over 300+ flags.\n \n          Check_Actuals : Boolean;\n          --  Flag set to indicate that the marked node is subject to the check\n-         --  for writable actuals. See xxx for more details. Again it would be\n-         --  more uniform to use some Flagx here, but that would be disruptive.\n+         --  for writable actuals.\n+\n+         Is_Ignored_Ghost_Node : Boolean;\n+         --  Flag denoting whether the node is subject to pragma Ghost with\n+         --  policy Ignore.\n \n          Spare2 : Boolean;\n          Spare3 : Boolean;"}, {"sha": "a99da08c73325198b886b4954e2b15f118ffe86a", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e491a7739dc2ae9a5b92945e4f0e48a3a91e39/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e491a7739dc2ae9a5b92945e4f0e48a3a91e39/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=90e491a7739dc2ae9a5b92945e4f0e48a3a91e39", "patch": "@@ -5398,8 +5398,10 @@ package body Checks is\n          elsif Checks_May_Be_Suppressed (E) then\n             if Is_Check_Suppressed (E, Elaboration_Check) then\n                return True;\n+\n             elsif Dynamic_Elaboration_Checks then\n                return Is_Check_Suppressed (E, All_Checks);\n+\n             else\n                return False;\n             end if;\n@@ -5408,8 +5410,10 @@ package body Checks is\n \n       if Scope_Suppress.Suppress (Elaboration_Check) then\n          return True;\n+\n       elsif Dynamic_Elaboration_Checks then\n          return Scope_Suppress.Suppress (All_Checks);\n+\n       else\n          return False;\n       end if;\n@@ -7927,7 +7931,7 @@ package body Checks is\n \n       Flag_Id :=\n         Make_Defining_Identifier (Loc,\n-          Chars => New_External_Name (Chars (Subp_Id), 'F', -1));\n+          Chars => New_External_Name (Chars (Subp_Id), 'E', -1));\n       Set_Is_Frozen (Flag_Id);\n \n       --  Insert the declaration of the elaboration flag in front of the\n@@ -7936,7 +7940,7 @@ package body Checks is\n       Push_Scope (Scope (Subp_Id));\n \n       --  Generate:\n-      --    F : Boolean := False;\n+      --    E : Boolean := False;\n \n       Insert_Action (Subp_Decl,\n         Make_Object_Declaration (Loc,\n@@ -7986,7 +7990,7 @@ package body Checks is\n       end if;\n \n       --  Generate:\n-      --    F := True;\n+      --    E := True;\n \n       Insert_After_And_Analyze (Set_Ins,\n         Make_Assignment_Statement (Loc,\n@@ -8060,12 +8064,14 @@ package body Checks is\n       --  since it clearly was not overridden at any point). For a predefined\n       --  check, we test the specific flag. For a user defined check, we check\n       --  the All_Checks flag. The Overflow flag requires special handling to\n-      --  deal with the General vs Assertion case\n+      --  deal with the General vs Assertion case.\n \n       if C = Overflow_Check then\n          return Overflow_Checks_Suppressed (Empty);\n+\n       elsif C in Predefined_Check_Id then\n          return Scope_Suppress.Suppress (C);\n+\n       else\n          return Scope_Suppress.Suppress (All_Checks);\n       end if;"}, {"sha": "4e747203394d9af42ad4af37c16a1d521498f25a", "filename": "gcc/ada/debug.adb", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e491a7739dc2ae9a5b92945e4f0e48a3a91e39/gcc%2Fada%2Fdebug.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e491a7739dc2ae9a5b92945e4f0e48a3a91e39/gcc%2Fada%2Fdebug.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdebug.adb?ref=90e491a7739dc2ae9a5b92945e4f0e48a3a91e39", "patch": "@@ -75,7 +75,7 @@ package body Debug is\n    --  dI   Inhibit internal name numbering in gnatG listing\n    --  dJ   Prepend subprogram name in messages\n    --  dK   Kill all error messages\n-   --  dL   Output trace information on elaboration checking\n+   --  dL   Ignore external calls from instances for elaboration\n    --  dM   Assume all variables are modified (no current values)\n    --  dN   No file name information in exception messages\n    --  dO   Output immediate error messages\n@@ -414,10 +414,9 @@ package body Debug is\n    --       of all error messages. It is used in regression tests where the\n    --       error messages are target dependent and irrelevant.\n \n-   --  dL   Output trace information on elaboration checking. This debug\n-   --       switch causes output to be generated showing each call or\n-   --       instantiation as it is checked, and the progress of the recursive\n-   --       trace through elaboration calls at compile time.\n+   --  dL   The compiler ignores calls in instances and invoke subprograms\n+   --       which are external to the instance for the static elaboration\n+   --       model. This switch is orthogonal to d.G.\n \n    --  dM   Assume all variables have been modified, and ignore current value\n    --       indications. This debug flag disconnects the tracking of constant\n@@ -664,7 +663,8 @@ package body Debug is\n    --  d.G  Previously the compiler ignored calls via generic formal parameters\n    --       when doing the analysis for the static elaboration model. This is\n    --       now fixed, but we provide this debug flag to revert to the previous\n-   --       situation of ignoring such calls to aid in transition.\n+   --       situation of ignoring such calls to aid in transition. This switch\n+   --       is orthogonal to dL.\n \n    --  d.H  Sets ASIS_GNSA_Mode to True. This signals the front end to suppress\n    --       the call to gigi in ASIS_Mode."}, {"sha": "d943c716d3ff9d3fa6b4870a6d41a5e9fa92f998", "filename": "gcc/ada/doc/gnat_ugn/elaboration_order_handling_in_gnat.rst", "status": "modified", "additions": 1552, "deletions": 1647, "changes": 3199, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e491a7739dc2ae9a5b92945e4f0e48a3a91e39/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Felaboration_order_handling_in_gnat.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e491a7739dc2ae9a5b92945e4f0e48a3a91e39/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Felaboration_order_handling_in_gnat.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Felaboration_order_handling_in_gnat.rst?ref=90e491a7739dc2ae9a5b92945e4f0e48a3a91e39"}, {"sha": "01d64f3aff5b5b3bc9619ad090e26496b0cc247e", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 103, "deletions": 25, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e491a7739dc2ae9a5b92945e4f0e48a3a91e39/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e491a7739dc2ae9a5b92945e4f0e48a3a91e39/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=90e491a7739dc2ae9a5b92945e4f0e48a3a91e39", "patch": "@@ -170,6 +170,7 @@ package body Einfo is\n    --    Extra_Accessibility_Of_Result   Node19\n    --    Non_Limited_View                Node19\n    --    Parent_Subtype                  Node19\n+   --    Receiving_Entry                 Node19\n    --    Size_Check_Code                 Node19\n    --    Spec_Entity                     Node19\n    --    Underlying_Full_View            Node19\n@@ -275,6 +276,9 @@ package body Einfo is\n    --    Validated_Object                Node36\n \n    --    Class_Wide_Clone                Node38\n+\n+   --    Protected_Subprogram            Node39\n+\n    --    SPARK_Pragma                    Node40\n \n    --    Original_Protected_Subprogram   Node41\n@@ -449,7 +453,7 @@ package body Einfo is\n    --    Strict_Alignment                Flag145\n    --    Is_Abstract_Type                Flag146\n    --    Needs_Debug_Info                Flag147\n-   --    Suppress_Elaboration_Warnings   Flag148\n+   --    Is_Elaboration_Checks_OK_Id     Flag148\n    --    Is_Compilation_Unit             Flag149\n    --    Has_Pragma_Elaborate_Body       Flag150\n \n@@ -619,7 +623,8 @@ package body Einfo is\n    --    Has_Private_Extension           Flag300\n \n    --    Ignore_SPARK_Mode_Pragmas       Flag301\n-   --    (unused)                        Flag302\n+   --    Is_Initial_Condition_Procedure  Flag302\n+\n    --    (unused)                        Flag303\n    --    (unused)                        Flag304\n    --    (unused)                        Flag305\n@@ -2237,6 +2242,17 @@ package body Einfo is\n       return Flag6 (Id);\n    end Is_Dispatching_Operation;\n \n+   function Is_Elaboration_Checks_OK_Id (Id : E) return B is\n+   begin\n+      pragma Assert\n+        (Ekind_In (Id, E_Constant, E_Variable)\n+          or else Is_Entry (Id)\n+          or else Is_Generic_Unit (Id)\n+          or else Is_Subprogram (Id)\n+          or else Is_Task_Type (Id));\n+      return Flag148 (Id);\n+   end Is_Elaboration_Checks_OK_Id;\n+\n    function Is_Eliminated (Id : E) return B is\n    begin\n       return Flag124 (Id);\n@@ -2364,14 +2380,20 @@ package body Einfo is\n       return Flag268 (Id);\n    end Is_Independent;\n \n+   function Is_Initial_Condition_Procedure (Id : E) return B is\n+   begin\n+      pragma Assert (Ekind_In (Id, E_Function, E_Procedure));\n+      return Flag302 (Id);\n+   end Is_Initial_Condition_Procedure;\n+\n    function Is_Inlined (Id : E) return B is\n    begin\n       return Flag11 (Id);\n    end Is_Inlined;\n \n    function Is_Inlined_Always (Id : E) return B is\n    begin\n-      pragma Assert (Ekind (Id) = E_Function or else Ekind (Id) = E_Procedure);\n+      pragma Assert (Ekind_In (Id, E_Function, E_Procedure));\n       return Flag1 (Id);\n    end Is_Inlined_Always;\n \n@@ -3084,10 +3106,18 @@ package body Einfo is\n       return Node22 (Id);\n    end Protected_Formal;\n \n+   function Protected_Subprogram (Id : E) return N is\n+   begin\n+      pragma Assert (Ekind_In (Id, E_Function, E_Procedure));\n+      return Node39 (Id);\n+   end Protected_Subprogram;\n+\n    function Protection_Object (Id : E) return E is\n    begin\n-      pragma Assert\n-        (Ekind_In (Id, E_Entry, E_Entry_Family, E_Function, E_Procedure));\n+      pragma Assert (Ekind_In (Id, E_Entry,\n+                                   E_Entry_Family,\n+                                   E_Function,\n+                                   E_Procedure));\n       return Node23 (Id);\n    end Protection_Object;\n \n@@ -3096,6 +3126,12 @@ package body Einfo is\n       return Flag49 (Id);\n    end Reachable;\n \n+   function Receiving_Entry (Id : E) return E is\n+   begin\n+      pragma Assert (Ekind (Id) = E_Procedure);\n+      return Node19 (Id);\n+   end Receiving_Entry;\n+\n    function Referenced (Id : E) return B is\n    begin\n       return Flag156 (Id);\n@@ -3306,6 +3342,9 @@ package body Einfo is\n                        E_Task_Body,\n                        E_Task_Type)\n           or else\n+         Ekind_In (Id, E_Constant,         --  object variants\n+                       E_Variable)\n+          or else\n          Ekind_In (Id, E_Entry,            --  overloadable variants\n                        E_Entry_Family,\n                        E_Function,\n@@ -3319,7 +3358,7 @@ package body Einfo is\n                        E_Package,\n                        E_Package_Body)\n            or else\n-         Ekind (Id) = E_Variable);         --  variable\n+         Ekind (Id) = E_Void);             --  special purpose\n       return Node40 (Id);\n    end SPARK_Pragma;\n \n@@ -3330,7 +3369,10 @@ package body Einfo is\n                        E_Protected_Type,\n                        E_Task_Body,\n                        E_Task_Type)\n-           or else\n+          or else\n+         Ekind_In (Id, E_Constant,         --  object variants\n+                       E_Variable)\n+          or else\n          Ekind_In (Id, E_Entry,            --  overloadable variants\n                        E_Entry_Family,\n                        E_Function,\n@@ -3344,7 +3386,7 @@ package body Einfo is\n                        E_Package,\n                        E_Package_Body)\n            or else\n-         Ekind (Id) = E_Variable);         --  variable\n+         Ekind (Id) = E_Void);             --  special purpose\n       return Flag265 (Id);\n    end SPARK_Pragma_Inherited;\n \n@@ -3444,11 +3486,6 @@ package body Einfo is\n       return Uint24 (Id);\n    end Subps_Index;\n \n-   function Suppress_Elaboration_Warnings (Id : E) return B is\n-   begin\n-      return Flag148 (Id);\n-   end Suppress_Elaboration_Warnings;\n-\n    function Suppress_Initialization (Id : E) return B is\n    begin\n       pragma Assert (Is_Type (Id) or else Ekind (Id) = E_Variable);\n@@ -5397,6 +5434,17 @@ package body Einfo is\n       Set_Flag6 (Id, V);\n    end Set_Is_Dispatching_Operation;\n \n+   procedure Set_Is_Elaboration_Checks_OK_Id (Id : E; V : B := True) is\n+   begin\n+      pragma Assert\n+        (Ekind_In (Id, E_Constant, E_Variable)\n+          or else Is_Entry (Id)\n+          or else Is_Generic_Unit (Id)\n+          or else Is_Subprogram (Id)\n+          or else Is_Task_Type (Id));\n+      Set_Flag148 (Id, V);\n+   end Set_Is_Elaboration_Checks_OK_Id;\n+\n    procedure Set_Is_Eliminated (Id : E; V : B := True) is\n    begin\n       Set_Flag124 (Id, V);\n@@ -5526,14 +5574,20 @@ package body Einfo is\n       Set_Flag268 (Id, V);\n    end Set_Is_Independent;\n \n+   procedure Set_Is_Initial_Condition_Procedure (Id : E; V : B := True) is\n+   begin\n+      pragma Assert (Ekind_In (Id, E_Function, E_Procedure));\n+      Set_Flag302 (Id, V);\n+   end Set_Is_Initial_Condition_Procedure;\n+\n    procedure Set_Is_Inlined (Id : E; V : B := True) is\n    begin\n       Set_Flag11 (Id, V);\n    end Set_Is_Inlined;\n \n    procedure Set_Is_Inlined_Always (Id : E; V : B := True) is\n    begin\n-      pragma Assert (Ekind (Id) = E_Function or else Ekind (Id) = E_Procedure);\n+      pragma Assert (Ekind_In (Id, E_Function, E_Procedure));\n       Set_Flag1 (Id, V);\n    end Set_Is_Inlined_Always;\n \n@@ -6264,6 +6318,12 @@ package body Einfo is\n       Set_Node22 (Id, V);\n    end Set_Protected_Formal;\n \n+   procedure Set_Protected_Subprogram (Id : E; V : E) is\n+   begin\n+      pragma Assert (Ekind_In (Id, E_Function, E_Procedure));\n+      Set_Node39 (Id, V);\n+   end Set_Protected_Subprogram;\n+\n    procedure Set_Protection_Object (Id : E; V : E) is\n    begin\n       pragma Assert (Ekind_In (Id, E_Entry,\n@@ -6278,6 +6338,12 @@ package body Einfo is\n       Set_Flag49 (Id, V);\n    end Set_Reachable;\n \n+   procedure Set_Receiving_Entry (Id : E; V : E) is\n+   begin\n+      pragma Assert (Ekind (Id) = E_Procedure);\n+      Set_Node19 (Id, V);\n+   end Set_Receiving_Entry;\n+\n    procedure Set_Referenced (Id : E; V : B := True) is\n    begin\n       Set_Flag156 (Id, V);\n@@ -6491,7 +6557,10 @@ package body Einfo is\n                        E_Protected_Type,\n                        E_Task_Body,\n                        E_Task_Type)\n-           or else\n+          or else\n+         Ekind_In (Id, E_Constant,         --  object variants\n+                       E_Variable)\n+          or else\n          Ekind_In (Id, E_Entry,            --  overloadable variants\n                        E_Entry_Family,\n                        E_Function,\n@@ -6505,7 +6574,7 @@ package body Einfo is\n                        E_Package,\n                        E_Package_Body)\n            or else\n-         Ekind (Id) = E_Variable);         --  variable\n+         Ekind (Id) = E_Void);             --  special purpose\n       Set_Node40 (Id, V);\n    end Set_SPARK_Pragma;\n \n@@ -6516,7 +6585,10 @@ package body Einfo is\n                        E_Protected_Type,\n                        E_Task_Body,\n                        E_Task_Type)\n-           or else\n+          or else\n+         Ekind_In (Id, E_Constant,         --  object variants\n+                       E_Variable)\n+          or else\n          Ekind_In (Id, E_Entry,            --  overloadable variants\n                        E_Entry_Family,\n                        E_Function,\n@@ -6530,7 +6602,7 @@ package body Einfo is\n                        E_Package,\n                        E_Package_Body)\n            or else\n-         Ekind (Id) = E_Variable);         --  variable\n+         Ekind (Id) = E_Void);             --  special purpose\n       Set_Flag265 (Id, V);\n    end Set_SPARK_Pragma_Inherited;\n \n@@ -6639,11 +6711,6 @@ package body Einfo is\n       Set_Uint24 (Id, V);\n    end Set_Subps_Index;\n \n-   procedure Set_Suppress_Elaboration_Warnings (Id : E; V : B := True) is\n-   begin\n-      Set_Flag148 (Id, V);\n-   end Set_Suppress_Elaboration_Warnings;\n-\n    procedure Set_Suppress_Initialization (Id : E; V : B := True) is\n    begin\n       pragma Assert (Is_Type (Id) or else Ekind (Id) = E_Variable);\n@@ -9562,6 +9629,7 @@ package body Einfo is\n       W (\"Is_Discriminant_Check_Function\",  Flag264 (Id));\n       W (\"Is_Dispatch_Table_Entity\",        Flag234 (Id));\n       W (\"Is_Dispatching_Operation\",        Flag6   (Id));\n+      W (\"Is_Elaboration_Checks_OK_Id\",     Flag148 (Id));\n       W (\"Is_Eliminated\",                   Flag124 (Id));\n       W (\"Is_Entry_Formal\",                 Flag52  (Id));\n       W (\"Is_Exception_Handler\",            Flag286 (Id));\n@@ -9584,6 +9652,7 @@ package body Einfo is\n       W (\"Is_Implementation_Defined\",       Flag254 (Id));\n       W (\"Is_Imported\",                     Flag24  (Id));\n       W (\"Is_Independent\",                  Flag268 (Id));\n+      W (\"Is_Initial_Condition_Procedure\",  Flag302 (Id));\n       W (\"Is_Inlined\",                      Flag11  (Id));\n       W (\"Is_Inlined_Always\",               Flag1   (Id));\n       W (\"Is_Instantiated\",                 Flag126 (Id));\n@@ -9696,7 +9765,6 @@ package body Einfo is\n       W (\"Static_Elaboration_Desired\",      Flag77  (Id));\n       W (\"Stores_Attribute_Old_Prefix\",     Flag270 (Id));\n       W (\"Strict_Alignment\",                Flag145 (Id));\n-      W (\"Suppress_Elaboration_Warnings\",   Flag148 (Id));\n       W (\"Suppress_Initialization\",         Flag105 (Id));\n       W (\"Suppress_Style_Checks\",           Flag165 (Id));\n       W (\"Suppress_Value_Tracking_On_Call\", Flag217 (Id));\n@@ -10399,6 +10467,9 @@ package body Einfo is\n          when E_Record_Type =>\n             Write_Str (\"Parent_Subtype\");\n \n+         when E_Procedure =>\n+            Write_Str (\"Receiving_Entry\");\n+\n          when E_Constant\n             | E_Variable\n          =>\n@@ -11089,6 +11160,11 @@ package body Einfo is\n    procedure Write_Field39_Name (Id : Entity_Id) is\n    begin\n       case Ekind (Id) is\n+         when E_Function\n+            | E_Procedure\n+         =>\n+            Write_Str (\"Protected_Subprogram\");\n+\n          when others =>\n             Write_Str (\"Field39??\");\n       end case;\n@@ -11101,7 +11177,8 @@ package body Einfo is\n    procedure Write_Field40_Name (Id : Entity_Id) is\n    begin\n       case Ekind (Id) is\n-         when E_Entry\n+         when E_Constant\n+            | E_Entry\n             | E_Entry_Family\n             | E_Function\n             | E_Generic_Function\n@@ -11117,6 +11194,7 @@ package body Einfo is\n             | E_Task_Body\n             | E_Task_Type\n             | E_Variable\n+            | E_Void\n          =>\n             Write_Str (\"SPARK_Pragma\");\n "}, {"sha": "7ad4cfa88af19a8c94104d8f164fff98320cad11", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 78, "deletions": 43, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e491a7739dc2ae9a5b92945e4f0e48a3a91e39/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e491a7739dc2ae9a5b92945e4f0e48a3a91e39/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=90e491a7739dc2ae9a5b92945e4f0e48a3a91e39", "patch": "@@ -2198,13 +2198,6 @@ package Einfo is\n --       Rep_Item chain mechanism, because a single pragma Import can apply\n --       to multiple subprogram entities).\n \n---    Incomplete_Actuals (Elist24)\n---       Defined on package entities that are instances. Indicates the actuals\n---       types in the instantiation that are limited views. If this list is\n---       not empty, the instantiation, which appears in a package declaration,\n---       is relocated to the corresponding package body, which must have a\n---       corresponding nonlimited with_clause.\n-\n --    In_Package_Body (Flag48)\n --       Defined in package entities. Set on the entity that denotes the\n --       package (the defining occurrence of the package declaration) while\n@@ -2218,6 +2211,13 @@ package Einfo is\n --       the end of the package declaration. For objects it indicates that the\n --       declaration of the object occurs in the private part of a package.\n \n+--    Incomplete_Actuals (Elist24)\n+--       Defined on package entities that are instances. Indicates the actuals\n+--       types in the instantiation that are limited views. If this list is\n+--       not empty, the instantiation, which appears in a package declaration,\n+--       is relocated to the corresponding package body, which must have a\n+--       corresponding nonlimited with_clause.\n+\n --    Initialization_Statements (Node28)\n --       Defined in constants and variables. For a composite object initialized\n --       initialized with an aggregate that has been converted to a sequence\n@@ -2504,13 +2504,19 @@ package Einfo is\n \n --    Is_Dynamic_Scope (synthesized)\n --       Applies to all Entities. Returns True if the entity is a dynamic\n---       scope (i.e. a block, subprogram, task_type, entry\n---       or extended return statement).\n+--       scope (i.e. a block, subprogram, task_type, entry or extended return\n+--       statement).\n+\n+--    Is_Elaboration_Checks_OK_Id (Flag148)\n+--       Defined in elaboration targets (see terminology in Sem_Elab). Set when\n+--       the target appears in a region which is subject to elabled elaboration\n+--       checks. Such targets are allowed to generate run-time conditional ABE\n+--       checks or guaranteed ABE failures.\n \n --    Is_Elementary_Type (synthesized)\n---       Applies to all entities, true for all elementary types and\n---       subtypes. Either Is_Composite_Type or Is_Elementary_Type (but\n---       not both) is true of any type.\n+--       Applies to all entities, true for all elementary types and subtypes.\n+--       Either Is_Composite_Type or Is_Elementary_Type (but not both) is true\n+--       of any type.\n \n --    Is_Eliminated (Flag124)\n --       Defined in type entities, subprogram entities, and object entities.\n@@ -2703,6 +2709,10 @@ package Einfo is\n --       and incomplete types, this flag is set in both the partial view and\n --       the full view.\n \n+--    Is_Initial_Condition_Procedure (Flag302)\n+--       Defined in functions and procedures. Set for a generated procedure\n+--       which verifies the assumption of pragma Initial_Condition at run time.\n+\n --    Is_Inlined (Flag11)\n --       Defined in all entities. Set for functions and procedures which are\n --       to be inlined. For subprograms created during expansion, this flag\n@@ -3958,6 +3968,11 @@ package Einfo is\n --       formal parameter in the unprotected version of the operation that\n --       is created during expansion.\n \n+--    Protected_Subprogram (Node39)\n+--       Defined in functions and procedures. Set for the pair of subprograms\n+--       which emulate the runtime semantics of a protected subprogram. Denotes\n+--       the entity of the origial protected subprogram.\n+\n --    Protection_Object (Node23)\n --       Applies to protected entries, entry families and subprograms. Denotes\n --       the entity which is used to rename the _object component of protected\n@@ -3967,6 +3982,11 @@ package Einfo is\n --       Defined in labels. The flag is set over the range of statements in\n --       which a goto to that label is legal.\n \n+--    Receiving_Entry (Node19)\n+--       Defined in procedures. Set for an internally generated procedure which\n+--       wraps the original statements of an accept alternative. Designates the\n+--       entity of the task entry being accepted.\n+\n --    Referenced (Flag156)\n --       Defined in all entities. Set if the entity is referenced, except for\n --       the case of an appearance of a simple variable that is not a renaming\n@@ -4038,10 +4058,10 @@ package Einfo is\n --       in a Relative_Deadline pragma for a task type.\n \n --    Renamed_Entity (Node18)\n---       Defined in exceptions, packages, subprograms, and generic units. Set\n---       for entities that are defined by a renaming declaration. Denotes the\n---       renamed entity, or transitively the ultimate renamed entity if\n---       there is a chain of renaming declarations. Empty if no renaming.\n+--       Defined in exception, generic unit, package, and subprogram entities.\n+--       Set when the entity is defined by a renaming declaration. Denotes the\n+--       renamed entity, or transitively the ultimate renamed entity if there\n+--       is a chain of renaming declarations. Empty if no renaming.\n \n --    Renamed_In_Spec (Flag231)\n --       Defined in package entities. If a package renaming occurs within\n@@ -4256,20 +4276,20 @@ package Einfo is\n --       inherited, rather than a local one.\n \n --    SPARK_Pragma (Node40)\n---       Present in concurrent type, entry, operator, [generic] package,\n---       package body, [generic] subprogram, subprogram body and variable\n---       entities. Points to the N_Pragma node that applies to the initial\n---       declaration or body. This is either set by a local SPARK_Mode pragma\n---       or is inherited from the context (from an outer scope for the spec\n---       case or from the spec for the body case). In the case where it is\n---       inherited the flag SPARK_Pragma_Inherited is set. Empty if no\n+--       Present in concurrent type, constant, entry, operator, [generic]\n+--       package, package body, [generic] subprogram, subprogram body and\n+--       variable entities. Points to the N_Pragma node that applies to the\n+--       initial declaration or body. This is either set by a local SPARK_Mode\n+--       pragma or is inherited from the context (from an outer scope for the\n+--       spec case or from the spec for the body case). In the case where it\n+--       is inherited the flag SPARK_Pragma_Inherited is set. Empty if no\n --       SPARK_Mode pragma is applicable.\n \n --    SPARK_Pragma_Inherited (Flag265)\n---       Present in concurrent type, entry, operator, [generic] package,\n---       package body, [generic] subprogram, subprogram body and variable\n---       entities. Set if the SPARK_Pragma attribute points to a pragma that is\n---       inherited, rather than a local one.\n+--       Present in concurrent type, constant, entry, operator, [generic]\n+--       package, package body, [generic] subprogram, subprogram body and\n+--       variable entities. Set if the SPARK_Pragma attribute points to a\n+--       pragma that is inherited, rather than a local one.\n \n --    Spec_Entity (Node19)\n --       Defined in package body entities. Points to corresponding package\n@@ -4395,17 +4415,6 @@ package Einfo is\n --       for the outer level subprogram, this is the starting index in the Subp\n --       table for the entries for this subprogram.\n \n---    Suppress_Elaboration_Warnings (Flag148)\n---       Defined in all entities, can be set only for subprogram entities and\n---       for variables. If this flag is set then Sem_Elab will not generate\n---       elaboration warnings for the subprogram or variable. Suppression of\n---       such warnings is automatic for subprograms for which elaboration\n---       checks are suppressed (without the need to set this flag), but the\n---       flag is also set for various internal entities (such as init procs)\n---       which are known not to generate any possible access before\n---       elaboration, and it is set on variables when a warning is given to\n---       avoid multiple elaboration warnings for the same variable.\n-\n --    Suppress_Initialization (Flag105)\n --       Defined in all variable, type and subtype entities. If set for a base\n --       type, then the generation of initialization procedures is suppressed\n@@ -5565,7 +5574,6 @@ package Einfo is\n    --    Referenced                          (Flag156)\n    --    Referenced_As_LHS                   (Flag36)\n    --    Referenced_As_Out_Parameter         (Flag227)\n-   --    Suppress_Elaboration_Warnings       (Flag148)\n    --    Suppress_Style_Checks               (Flag165)\n    --    Suppress_Value_Tracking_On_Call     (Flag217)\n    --    Used_As_Generic_Actual              (Flag222)\n@@ -5869,6 +5877,7 @@ package Einfo is\n    --    Encapsulating_State                 (Node32)   (constants only)\n    --    Linker_Section_Pragma               (Node33)\n    --    Contract                            (Node34)   (constants only)\n+   --    SPARK_Pragma                        (Node40)   (constants only)\n    --    Has_Alignment_Clause                (Flag46)\n    --    Has_Atomic_Components               (Flag86)\n    --    Has_Biased_Representation           (Flag139)\n@@ -5878,6 +5887,7 @@ package Einfo is\n    --    Has_Thunks                          (Flag228)  (constants only)\n    --    Has_Volatile_Components             (Flag87)\n    --    Is_Atomic                           (Flag85)\n+   --    Is_Elaboration_Checks_OK_Id         (Flag148)  (constants only)\n    --    Is_Eliminated                       (Flag124)\n    --    Is_Finalized_Transient              (Flag252)\n    --    Is_Ignored_Transient                (Flag295)\n@@ -5889,6 +5899,7 @@ package Einfo is\n    --    Is_Volatile_Full_Access             (Flag285)\n    --    Optimize_Alignment_Space            (Flag241)  (constants only)\n    --    Optimize_Alignment_Time             (Flag242)  (constants only)\n+   --    SPARK_Pragma_Inherited              (Flag265)  (constants only)\n    --    Stores_Attribute_Old_Prefix         (Flag270)  (constants only)\n    --    Treat_As_Volatile                   (Flag41)\n    --    Address_Clause                      (synth)\n@@ -5953,6 +5964,7 @@ package Einfo is\n    --    Entry_Accepted                      (Flag152)\n    --    Has_Expanded_Contract               (Flag240)\n    --    Ignore_SPARK_Mode_Pragmas           (Flag301)\n+   --    Is_Elaboration_Checks_OK_Id         (Flag148)\n    --    Is_Entry_Wrapper                    (Flag297)\n    --    Needs_No_Actuals                    (Flag22)\n    --    Sec_Stack_Needed_For_Return         (Flag167)\n@@ -6065,6 +6077,7 @@ package Einfo is\n    --    Contract                            (Node34)\n    --    Import_Pragma                       (Node35)   (non-generic case only)\n    --    Class_Wide_Clone                    (Node38)\n+   --    Protected_Subprogram                (Node39)   (non-generic case only)\n    --    SPARK_Pragma                        (Node40)\n    --    Original_Protected_Subprogram       (Node41)\n    --    Body_Needed_For_SAL                 (Flag40)\n@@ -6090,9 +6103,11 @@ package Einfo is\n    --    Is_DIC_Procedure                    (Flag132)  (non-generic case only)\n    --    Is_Discrim_SO_Function              (Flag176)\n    --    Is_Discriminant_Check_Function      (Flag264)\n+   --    Is_Elaboration_Checks_OK_Id         (Flag148)\n    --    Is_Eliminated                       (Flag124)\n    --    Is_Generic_Actual_Subprogram        (Flag274)  (non-generic case only)\n    --    Is_Hidden_Non_Overridden_Subpgm     (Flag2)    (non-generic case only)\n+   --    Is_Initial_Condition_Procedure      (Flag302)  (non-generic case only)\n    --    Is_Inlined_Always                   (Flag1)    (non-generic case only)\n    --    Is_Instantiated                     (Flag126)  (generic case only)\n    --    Is_Intrinsic_Subprogram             (Flag64)\n@@ -6238,6 +6253,7 @@ package Einfo is\n    --    Default_Expressions_Processed       (Flag108)\n    --    Has_Nested_Subprogram               (Flag282)\n    --    Ignore_SPARK_Mode_Pragmas           (Flag301)\n+   --    Is_Elaboration_Checks_OK_Id         (Flag148)\n    --    Is_Intrinsic_Subprogram             (Flag64)\n    --    Is_Machine_Code_Subprogram          (Flag137)\n    --    Is_Primitive                        (Flag218)\n@@ -6304,6 +6320,7 @@ package Einfo is\n    --    Ignore_SPARK_Mode_Pragmas           (Flag301)\n    --    In_Package_Body                     (Flag48)\n    --    In_Use                              (Flag8)\n+   --    Is_Elaboration_Checks_OK_Id         (Flag148)\n    --    Is_Instantiated                     (Flag126)\n    --    Is_Private_Descendant               (Flag53)\n    --    Is_Visible_Lib_Unit                 (Flag116)\n@@ -6362,6 +6379,7 @@ package Einfo is\n    --    First_Entity                        (Node17)\n    --    Alias                               (Node18)   (non-generic case only)\n    --    Renamed_Entity                      (Node18)   (generic case only)\n+   --    Receiving_Entry                     (Node19)   (non-generic case only)\n    --    Last_Entity                         (Node20)\n    --    Interface_Name                      (Node21)\n    --    Scope_Depth_Value                   (Uint22)\n@@ -6381,6 +6399,7 @@ package Einfo is\n    --    Contract                            (Node34)\n    --    Import_Pragma                       (Node35)   (non-generic case only)\n    --    Class_Wide_Clone                    (Node38)\n+   --    Protected_Subprogram                (Node39)   (non-generic case only)\n    --    SPARK_Pragma                        (Node40)\n    --    Original_Protected_Subprogram       (Node41)\n    --    Body_Needed_For_SAL                 (Flag40)\n@@ -6403,9 +6422,11 @@ package Einfo is\n    --    Is_Called                           (Flag102)  (non-generic case only)\n    --    Is_Constructor                      (Flag76)\n    --    Is_DIC_Procedure                    (Flag132)  (non-generic case only)\n+   --    Is_Elaboration_Checks_OK_Id         (Flag148)\n    --    Is_Eliminated                       (Flag124)\n    --    Is_Generic_Actual_Subprogram        (Flag274)  (non-generic case only)\n    --    Is_Hidden_Non_Overridden_Subpgm     (Flag2)    (non-generic case only)\n+   --    Is_Initial_Condition_Procedure      (Flag302)  (non-generic case only)\n    --    Is_Inlined_Always                   (Flag1)    (non-generic case only)\n    --    Is_Instantiated                     (Flag126)  (generic case only)\n    --    Is_Interrupt_Handler                (Flag89)\n@@ -6614,6 +6635,7 @@ package Einfo is\n    --    Has_Master_Entity                   (Flag21)\n    --    Has_Storage_Size_Clause             (Flag23)   (base type only)\n    --    Ignore_SPARK_Mode_Pragmas           (Flag301)\n+   --    Is_Elaboration_Checks_OK_Id         (Flag148)\n    --    SPARK_Aux_Pragma_Inherited          (Flag266)\n    --    SPARK_Pragma_Inherited              (Flag265)\n    --    First_Component                     (synth)\n@@ -6662,6 +6684,7 @@ package Einfo is\n    --    Has_Size_Clause                     (Flag29)\n    --    Has_Volatile_Components             (Flag87)\n    --    Is_Atomic                           (Flag85)\n+   --    Is_Elaboration_Checks_OK_Id         (Flag148)\n    --    Is_Eliminated                       (Flag124)\n    --    Is_Finalized_Transient              (Flag252)\n    --    Is_Ignored_Transient                (Flag295)\n@@ -7179,6 +7202,7 @@ package Einfo is\n    function Is_Discriminant_Check_Function      (Id : E) return B;\n    function Is_Dispatch_Table_Entity            (Id : E) return B;\n    function Is_Dispatching_Operation            (Id : E) return B;\n+   function Is_Elaboration_Checks_OK_Id         (Id : E) return B;\n    function Is_Eliminated                       (Id : E) return B;\n    function Is_Entry_Formal                     (Id : E) return B;\n    function Is_Entry_Wrapper                    (Id : E) return B;\n@@ -7198,6 +7222,7 @@ package Einfo is\n    function Is_Implementation_Defined           (Id : E) return B;\n    function Is_Imported                         (Id : E) return B;\n    function Is_Independent                      (Id : E) return B;\n+   function Is_Initial_Condition_Procedure      (Id : E) return B;\n    function Is_Inlined                          (Id : E) return B;\n    function Is_Inlined_Always                   (Id : E) return B;\n    function Is_Instantiated                     (Id : E) return B;\n@@ -7322,8 +7347,10 @@ package Einfo is\n    function Private_View                        (Id : E) return N;\n    function Protected_Body_Subprogram           (Id : E) return E;\n    function Protected_Formal                    (Id : E) return E;\n+   function Protected_Subprogram                (Id : E) return N;\n    function Protection_Object                   (Id : E) return E;\n    function Reachable                           (Id : E) return B;\n+   function Receiving_Entry                     (Id : E) return E;\n    function Referenced                          (Id : E) return B;\n    function Referenced_As_LHS                   (Id : E) return B;\n    function Referenced_As_Out_Parameter         (Id : E) return B;\n@@ -7376,7 +7403,6 @@ package Einfo is\n    function String_Literal_Low_Bound            (Id : E) return N;\n    function Subprograms_For_Type                (Id : E) return L;\n    function Subps_Index                         (Id : E) return U;\n-   function Suppress_Elaboration_Warnings       (Id : E) return B;\n    function Suppress_Initialization             (Id : E) return B;\n    function Suppress_Style_Checks               (Id : E) return B;\n    function Suppress_Value_Tracking_On_Call     (Id : E) return B;\n@@ -7868,6 +7894,7 @@ package Einfo is\n    procedure Set_Is_Discriminant_Check_Function  (Id : E; V : B := True);\n    procedure Set_Is_Dispatch_Table_Entity        (Id : E; V : B := True);\n    procedure Set_Is_Dispatching_Operation        (Id : E; V : B := True);\n+   procedure Set_Is_Elaboration_Checks_OK_Id     (Id : E; V : B := True);\n    procedure Set_Is_Eliminated                   (Id : E; V : B := True);\n    procedure Set_Is_Entry_Formal                 (Id : E; V : B := True);\n    procedure Set_Is_Entry_Wrapper                (Id : E; V : B := True);\n@@ -7891,6 +7918,7 @@ package Einfo is\n    procedure Set_Is_Implementation_Defined       (Id : E; V : B := True);\n    procedure Set_Is_Imported                     (Id : E; V : B := True);\n    procedure Set_Is_Independent                  (Id : E; V : B := True);\n+   procedure Set_Is_Initial_Condition_Procedure  (Id : E; V : B := True);\n    procedure Set_Is_Inlined                      (Id : E; V : B := True);\n    procedure Set_Is_Inlined_Always               (Id : E; V : B := True);\n    procedure Set_Is_Instantiated                 (Id : E; V : B := True);\n@@ -8015,8 +8043,10 @@ package Einfo is\n    procedure Set_Private_View                    (Id : E; V : N);\n    procedure Set_Protected_Body_Subprogram       (Id : E; V : E);\n    procedure Set_Protected_Formal                (Id : E; V : E);\n+   procedure Set_Protected_Subprogram            (Id : E; V : N);\n    procedure Set_Protection_Object               (Id : E; V : E);\n    procedure Set_Reachable                       (Id : E; V : B := True);\n+   procedure Set_Receiving_Entry                 (Id : E; V : E);\n    procedure Set_Referenced                      (Id : E; V : B := True);\n    procedure Set_Referenced_As_LHS               (Id : E; V : B := True);\n    procedure Set_Referenced_As_Out_Parameter     (Id : E; V : B := True);\n@@ -8069,7 +8099,6 @@ package Einfo is\n    procedure Set_String_Literal_Low_Bound        (Id : E; V : N);\n    procedure Set_Subprograms_For_Type            (Id : E; V : L);\n    procedure Set_Subps_Index                     (Id : E; V : U);\n-   procedure Set_Suppress_Elaboration_Warnings   (Id : E; V : B := True);\n    procedure Set_Suppress_Initialization         (Id : E; V : B := True);\n    procedure Set_Suppress_Style_Checks           (Id : E; V : B := True);\n    procedure Set_Suppress_Value_Tracking_On_Call (Id : E; V : B := True);\n@@ -8690,6 +8719,7 @@ package Einfo is\n    pragma Inline (Is_Discriminant_Check_Function);\n    pragma Inline (Is_Dispatch_Table_Entity);\n    pragma Inline (Is_Dispatching_Operation);\n+   pragma Inline (Is_Elaboration_Checks_OK_Id);\n    pragma Inline (Is_Elementary_Type);\n    pragma Inline (Is_Eliminated);\n    pragma Inline (Is_Entry);\n@@ -8725,6 +8755,7 @@ package Einfo is\n    pragma Inline (Is_Incomplete_Or_Private_Type);\n    pragma Inline (Is_Incomplete_Type);\n    pragma Inline (Is_Independent);\n+   pragma Inline (Is_Initial_Condition_Procedure);\n    pragma Inline (Is_Inlined);\n    pragma Inline (Is_Inlined_Always);\n    pragma Inline (Is_Instantiated);\n@@ -8868,8 +8899,10 @@ package Einfo is\n    pragma Inline (Private_View);\n    pragma Inline (Protected_Body_Subprogram);\n    pragma Inline (Protected_Formal);\n+   pragma Inline (Protected_Subprogram);\n    pragma Inline (Protection_Object);\n    pragma Inline (Reachable);\n+   pragma Inline (Receiving_Entry);\n    pragma Inline (Referenced);\n    pragma Inline (Referenced_As_LHS);\n    pragma Inline (Referenced_As_Out_Parameter);\n@@ -8922,7 +8955,6 @@ package Einfo is\n    pragma Inline (String_Literal_Low_Bound);\n    pragma Inline (Subprograms_For_Type);\n    pragma Inline (Subps_Index);\n-   pragma Inline (Suppress_Elaboration_Warnings);\n    pragma Inline (Suppress_Initialization);\n    pragma Inline (Suppress_Style_Checks);\n    pragma Inline (Suppress_Value_Tracking_On_Call);\n@@ -9200,6 +9232,7 @@ package Einfo is\n    pragma Inline (Set_Is_Discriminant_Check_Function);\n    pragma Inline (Set_Is_Dispatch_Table_Entity);\n    pragma Inline (Set_Is_Dispatching_Operation);\n+   pragma Inline (Set_Is_Elaboration_Checks_OK_Id);\n    pragma Inline (Set_Is_Eliminated);\n    pragma Inline (Set_Is_Entry_Formal);\n    pragma Inline (Set_Is_Entry_Wrapper);\n@@ -9223,6 +9256,7 @@ package Einfo is\n    pragma Inline (Set_Is_Implementation_Defined);\n    pragma Inline (Set_Is_Imported);\n    pragma Inline (Set_Is_Independent);\n+   pragma Inline (Set_Is_Initial_Condition_Procedure);\n    pragma Inline (Set_Is_Inlined);\n    pragma Inline (Set_Is_Inlined_Always);\n    pragma Inline (Set_Is_Instantiated);\n@@ -9348,8 +9382,10 @@ package Einfo is\n    pragma Inline (Set_Private_View);\n    pragma Inline (Set_Protected_Body_Subprogram);\n    pragma Inline (Set_Protected_Formal);\n+   pragma Inline (Set_Protected_Subprogram);\n    pragma Inline (Set_Protection_Object);\n    pragma Inline (Set_Reachable);\n+   pragma Inline (Set_Receiving_Entry);\n    pragma Inline (Set_Referenced);\n    pragma Inline (Set_Referenced_As_LHS);\n    pragma Inline (Set_Referenced_As_Out_Parameter);\n@@ -9402,7 +9438,6 @@ package Einfo is\n    pragma Inline (Set_String_Literal_Low_Bound);\n    pragma Inline (Set_Subprograms_For_Type);\n    pragma Inline (Set_Subps_Index);\n-   pragma Inline (Set_Suppress_Elaboration_Warnings);\n    pragma Inline (Set_Suppress_Initialization);\n    pragma Inline (Set_Suppress_Style_Checks);\n    pragma Inline (Set_Suppress_Value_Tracking_On_Call);"}, {"sha": "84a07db47c12f3747dcaf61353edb2db6e8e692c", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 21, "deletions": 26, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e491a7739dc2ae9a5b92945e4f0e48a3a91e39/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e491a7739dc2ae9a5b92945e4f0e48a3a91e39/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=90e491a7739dc2ae9a5b92945e4f0e48a3a91e39", "patch": "@@ -2721,36 +2721,30 @@ package body Exp_Ch3 is\n            and then not Restriction_Active (No_Exception_Propagation)\n          then\n             declare\n-               DF_Call : Node_Id;\n-               DF_Id   : Entity_Id;\n+               DF_Id : Entity_Id;\n \n             begin\n                --  Create a local version of Deep_Finalize which has indication\n                --  of partial initialization state.\n \n-               DF_Id := Make_Temporary (Loc, 'F');\n+               DF_Id :=\n+                 Make_Defining_Identifier (Loc,\n+                   Chars => New_External_Name (Name_uFinalizer));\n \n                Append_To (Decls, Make_Local_Deep_Finalize (Rec_Type, DF_Id));\n \n-               DF_Call :=\n-                 Make_Procedure_Call_Statement (Loc,\n-                   Name                   => New_Occurrence_Of (DF_Id, Loc),\n-                   Parameter_Associations => New_List (\n-                     Make_Identifier (Loc, Name_uInit),\n-                     New_Occurrence_Of (Standard_False, Loc)));\n-\n-               --  Do not emit warnings related to the elaboration order when a\n-               --  controlled object is declared before the body of Finalize is\n-               --  seen.\n-\n-               Set_No_Elaboration_Check (DF_Call);\n-\n                Set_Exception_Handlers (Handled_Stmt_Node, New_List (\n                  Make_Exception_Handler (Loc,\n                    Exception_Choices => New_List (\n                      Make_Others_Choice (Loc)),\n                    Statements        => New_List (\n-                     DF_Call,\n+                     Make_Procedure_Call_Statement (Loc,\n+                       Name                   =>\n+                         New_Occurrence_Of (DF_Id, Loc),\n+                       Parameter_Associations => New_List (\n+                         Make_Identifier (Loc, Name_uInit),\n+                         New_Occurrence_Of (Standard_False, Loc))),\n+\n                      Make_Raise_Statement (Loc)))));\n             end;\n          else\n@@ -5814,6 +5808,7 @@ package body Exp_Ch3 is\n \n          Aggr_Init  : Node_Id;\n          Comp_Init  : List_Id := No_List;\n+         Fin_Block  : Node_Id;\n          Fin_Call   : Node_Id;\n          Init_Stmts : List_Id := No_List;\n          Obj_Init   : Node_Id := Empty;\n@@ -5956,14 +5951,7 @@ package body Exp_Ch3 is\n                  Skip_Self => True);\n \n             if Present (Fin_Call) then\n-\n-               --  Do not emit warnings related to the elaboration order when a\n-               --  controlled object is declared before the body of Finalize is\n-               --  seen.\n-\n-               Set_No_Elaboration_Check (Fin_Call);\n-\n-               Append_To (Init_Stmts,\n+               Fin_Block :=\n                  Make_Block_Statement (Loc,\n                    Declarations               => No_List,\n \n@@ -5978,7 +5966,14 @@ package body Exp_Ch3 is\n \n                            Statements        => New_List (\n                              Fin_Call,\n-                             Make_Raise_Statement (Loc)))))));\n+                             Make_Raise_Statement (Loc))))));\n+\n+               --  Signal the ABE mechanism that the block carries out\n+               --  initialization actions.\n+\n+               Set_Is_Initialization_Block (Fin_Block);\n+\n+               Append_To (Init_Stmts, Fin_Block);\n             end if;\n \n          --  Otherwise finalization is not required, the initialization calls"}, {"sha": "5ac2717fa59ae04dbf848e712d86f4f8696a2c70", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 26, "deletions": 10, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e491a7739dc2ae9a5b92945e4f0e48a3a91e39/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e491a7739dc2ae9a5b92945e4f0e48a3a91e39/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=90e491a7739dc2ae9a5b92945e4f0e48a3a91e39", "patch": "@@ -7714,7 +7714,7 @@ package body Exp_Ch6 is\n       Function_Call : Node_Id)\n    is\n       Acc_Type          : constant Entity_Id := Etype (Allocator);\n-      Loc               : Source_Ptr;\n+      Loc               : constant Source_Ptr := Sloc (Function_Call);\n       Func_Call         : Node_Id := Function_Call;\n       Ref_Func_Call     : Node_Id;\n       Function_Id       : Entity_Id;\n@@ -7744,8 +7744,6 @@ package body Exp_Ch6 is\n       pragma Assert (not Is_Expanded_Build_In_Place_Call (Func_Call));\n       Set_Is_Expanded_Build_In_Place_Call (Func_Call);\n \n-      Loc := Sloc (Function_Call);\n-\n       if Is_Entity_Name (Name (Func_Call)) then\n          Function_Id := Entity (Name (Func_Call));\n \n@@ -7801,10 +7799,17 @@ package body Exp_Ch6 is\n          Rewrite (Allocator, New_Allocator);\n \n          --  Initial value of the temp is the result of the uninitialized\n-         --  allocator\n+         --  allocator. Unchecked_Convert is needed for T'Input where T is\n+         --  derived from a controlled type.\n \n          Temp_Init := Relocate_Node (Allocator);\n \n+         if Nkind_In\n+           (Function_Call, N_Type_Conversion, N_Unchecked_Type_Conversion)\n+         then\n+            Temp_Init := Unchecked_Convert_To (Acc_Type, Temp_Init);\n+         end if;\n+\n          --  Indicate that caller allocates, and pass in the return object\n \n          Alloc_Form := Caller_Allocation;\n@@ -7869,6 +7874,15 @@ package body Exp_Ch6 is\n          Rewrite\n            (Ref_Func_Call,\n             OK_Convert_To (Acc_Type, Ref_Func_Call));\n+\n+      --  If the types are incompatible, we need an unchecked conversion. Note\n+      --  that the full types will be compatible, but the types not visibly\n+      --  compatible.\n+\n+      elsif Nkind_In\n+        (Function_Call, N_Type_Conversion, N_Unchecked_Type_Conversion)\n+      then\n+         Ref_Func_Call := Unchecked_Convert_To (Acc_Type, Ref_Func_Call);\n       end if;\n \n       declare\n@@ -7880,7 +7894,8 @@ package body Exp_Ch6 is\n          --  caller-allocates case, this is overwriting the temp with its\n          --  initial value, which has no effect. In the callee-allocates case,\n          --  this is setting the temp to point to the object allocated by the\n-         --  callee.\n+         --  callee. Unchecked_Convert is needed for T'Input where T is derived\n+         --  from a controlled type.\n \n          Actions : List_Id;\n          --  Actions to be inserted. If there are no tasks, this is just the\n@@ -7940,7 +7955,7 @@ package body Exp_Ch6 is\n    procedure Make_Build_In_Place_Call_In_Anonymous_Context\n      (Function_Call : Node_Id)\n    is\n-      Loc             : Source_Ptr;\n+      Loc             : constant Source_Ptr := Sloc (Function_Call);\n       Func_Call       : constant Node_Id := Unqual_Conv (Function_Call);\n       Function_Id     : Entity_Id;\n       Result_Subt     : Entity_Id;\n@@ -7962,8 +7977,6 @@ package body Exp_Ch6 is\n \n       Set_Is_Expanded_Build_In_Place_Call (Func_Call);\n \n-      Loc := Sloc (Function_Call);\n-\n       if Is_Entity_Name (Name (Func_Call)) then\n          Function_Id := Entity (Name (Func_Call));\n \n@@ -8535,7 +8548,10 @@ package body Exp_Ch6 is\n                New_Occurrence_Of (Designated_Type, Obj_Loc),\n              Name => Call_Deref));\n \n-         Set_Renamed_Object (Obj_Def_Id, Call_Deref);\n+         --  At this point, Defining_Identifier (Obj_Decl) is no longer equal\n+         --  to Obj_Def_Id.\n+\n+         Set_Renamed_Object (Defining_Identifier (Obj_Decl), Call_Deref);\n \n          --  If the original entity comes from source, then mark the new\n          --  entity as needing debug information, even though it's defined\n@@ -8544,7 +8560,7 @@ package body Exp_Ch6 is\n          --  Debug_Renaming_Declaration is called during analysis.\n \n          if Comes_From_Source (Obj_Def_Id) then\n-            Set_Debug_Info_Needed (Obj_Def_Id);\n+            Set_Debug_Info_Needed (Defining_Identifier (Obj_Decl));\n          end if;\n \n          Analyze (Obj_Decl);"}, {"sha": "713ba58b72b5d29f3b495d6262aa875c7a4da82c", "filename": "gcc/ada/exp_ch7.adb", "status": "modified", "additions": 22, "deletions": 23, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e491a7739dc2ae9a5b92945e4f0e48a3a91e39/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e491a7739dc2ae9a5b92945e4f0e48a3a91e39/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=90e491a7739dc2ae9a5b92945e4f0e48a3a91e39", "patch": "@@ -2605,8 +2605,8 @@ package body Exp_Ch7 is\n             --  procedures of types Init_Typ or Obj_Typ.\n \n             function Next_Suitable_Statement (Stmt : Node_Id) return Node_Id;\n-            --  Given a statement which is part of a list, return the next\n-            --  statement while skipping over dynamic elab checks.\n+            --  Obtain the next statement which follows list member Stmt while\n+            --  ignoring artifacts related to access-before-elaboration checks.\n \n             -----------------------------\n             -- Find_Last_Init_In_Block --\n@@ -2725,16 +2725,22 @@ package body Exp_Ch7 is\n             -----------------------------\n \n             function Next_Suitable_Statement (Stmt : Node_Id) return Node_Id is\n-               Result : Node_Id := Next (Stmt);\n+               Result : Node_Id;\n \n             begin\n-               --  Skip over access-before-elaboration checks\n+               --  Skip call markers and Program_Error raises installed by the\n+               --  ABE mechanism.\n+\n+               Result := Next (Stmt);\n+               while Present (Result) loop\n+                  if not Nkind_In (Result, N_Call_Marker,\n+                                           N_Raise_Program_Error)\n+                  then\n+                     exit;\n+                  end if;\n \n-               if Dynamic_Elaboration_Checks\n-                 and then Nkind (Result) = N_Raise_Program_Error\n-               then\n                   Result := Next (Result);\n-               end if;\n+               end loop;\n \n                return Result;\n             end Next_Suitable_Statement;\n@@ -4463,7 +4469,7 @@ package body Exp_Ch7 is\n       --  This is done only for non-generic packages\n \n       if Ekind (Spec_Id) = E_Package then\n-         Push_Scope (Corresponding_Spec (N));\n+         Push_Scope (Spec_Id);\n \n          --  Build dispatch tables of library level tagged types\n \n@@ -4475,18 +4481,15 @@ package body Exp_Ch7 is\n \n          Build_Task_Activation_Call (N);\n \n-         --  When the package is subject to pragma Initial_Condition, the\n-         --  assertion expression must be verified at the end of the body\n-         --  statements.\n+         --  Verify the run-time semantics of pragma Initial_Condition at the\n+         --  end of the body statements.\n \n-         if Present (Get_Pragma (Spec_Id, Pragma_Initial_Condition)) then\n-            Expand_Pragma_Initial_Condition (N);\n-         end if;\n+         Expand_Pragma_Initial_Condition (Spec_Id, N);\n \n          Pop_Scope;\n       end if;\n \n-      Set_Elaboration_Flag (N, Corresponding_Spec (N));\n+      Set_Elaboration_Flag (N, Spec_Id);\n       Set_In_Package_Body (Spec_Id, False);\n \n       --  Set to encode entity names in package body before gigi is called\n@@ -4601,14 +4604,10 @@ package body Exp_Ch7 is\n             Build_Task_Activation_Call (N);\n          end if;\n \n-         --  When the package is subject to pragma Initial_Condition and lacks\n-         --  a body, the assertion expression must be verified at the end of\n-         --  the visible declarations. Otherwise the check is performed at the\n-         --  end of the body statements (see Expand_N_Package_Body).\n+         --  Verify the run-time semantics of pragma Initial_Condition at the\n+         --  end of the private declarations when the package lacks a body.\n \n-         if Present (Get_Pragma (Id, Pragma_Initial_Condition)) then\n-            Expand_Pragma_Initial_Condition (N);\n-         end if;\n+         Expand_Pragma_Initial_Condition (Id, N);\n \n          Pop_Scope;\n       end if;"}, {"sha": "17687c05c563e0acfa109722889efa57b8d88ecb", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 117, "deletions": 77, "changes": 194, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e491a7739dc2ae9a5b92945e4f0e48a3a91e39/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e491a7739dc2ae9a5b92945e4f0e48a3a91e39/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=90e491a7739dc2ae9a5b92945e4f0e48a3a91e39", "patch": "@@ -52,7 +52,6 @@ with Sem_Ch6;  use Sem_Ch6;\n with Sem_Ch8;  use Sem_Ch8;\n with Sem_Ch9;  use Sem_Ch9;\n with Sem_Ch11; use Sem_Ch11;\n-with Sem_Elab; use Sem_Elab;\n with Sem_Eval; use Sem_Eval;\n with Sem_Res;  use Sem_Res;\n with Sem_Util; use Sem_Util;\n@@ -3841,6 +3840,12 @@ package body Exp_Ch9 is\n          Set_Original_Protected_Subprogram (New_Id, Def_Id);\n       end if;\n \n+      --  Link the protected or unprotected version to the original subprogram\n+      --  it emulates.\n+\n+      Set_Ekind (New_Id, Ekind (Def_Id));\n+      Set_Protected_Subprogram (New_Id, Def_Id);\n+\n       --  The unprotected operation carries the user code, and debugging\n       --  information must be generated for it, even though this spec does\n       --  not come from source. It is also convenient to allow gdb to step\n@@ -4751,117 +4756,147 @@ package body Exp_Ch9 is\n    --------------------------------\n \n    procedure Build_Task_Activation_Call (N : Node_Id) is\n-      Loc   : constant Source_Ptr := Sloc (N);\n+      function Activation_Call_Loc return Source_Ptr;\n+      --  Find a suitable source location for the activation call\n+\n+      -------------------------\n+      -- Activation_Call_Loc --\n+      -------------------------\n+\n+      function Activation_Call_Loc return Source_Ptr is\n+      begin\n+         --  The activation call must carry the location of the \"end\" keyword\n+         --  when the context is a package declaration.\n+\n+         if Nkind (N) = N_Package_Declaration then\n+            return End_Keyword_Location (N);\n+\n+         --  Otherwise the activation call must carry the location of the\n+         --  \"begin\" keyword.\n+\n+         else\n+            return Begin_Keyword_Location (N);\n+         end if;\n+      end Activation_Call_Loc;\n+\n+      --  Local variables\n+\n       Chain : Entity_Id;\n       Call  : Node_Id;\n+      Loc   : Source_Ptr;\n       Name  : Node_Id;\n-      P     : Node_Id;\n+      Owner : Node_Id;\n+      Stmt  : Node_Id;\n+\n+   --  Start of processing for Build_Task_Activation_Call\n \n    begin\n       --  For sequential elaboration policy, all the tasks will be activated at\n       --  the end of the elaboration.\n \n       if Partition_Elaboration_Policy = 'S' then\n          return;\n-      end if;\n \n-      --  Get the activation chain entity. Except in the case of a package\n-      --  body, this is in the node that was passed. For a package body, we\n-      --  have to find the corresponding package declaration node.\n+      --  Do not create an activation call for a package spec if the package\n+      --  has a completing body. The activation call will be inserted after\n+      --  the \"begin\" of the body.\n \n-      if Nkind (N) = N_Package_Body then\n-         P := Corresponding_Spec (N);\n-         loop\n-            P := Parent (P);\n-            exit when Nkind (P) = N_Package_Declaration;\n-         end loop;\n+      elsif Nkind (N) = N_Package_Declaration\n+        and then Present (Corresponding_Body (N))\n+      then\n+         return;\n+      end if;\n \n-         Chain := Activation_Chain_Entity (P);\n+      --  Obtain the activation chain entity. Block statements, entry bodies,\n+      --  subprogram bodies, and task bodies keep the entity in their nodes.\n+      --  Package bodies on the other hand store it in the declaration of the\n+      --  corresponding package spec.\n \n-      else\n-         Chain := Activation_Chain_Entity (N);\n+      Owner := N;\n+\n+      if Nkind (Owner) = N_Package_Body then\n+         Owner := Unit_Declaration_Node (Corresponding_Spec (Owner));\n       end if;\n \n-      if Present (Chain) then\n-         if Restricted_Profile then\n-            Name := New_Occurrence_Of\n-                      (RTE (RE_Activate_Restricted_Tasks), Loc);\n-         else\n-            Name := New_Occurrence_Of\n-                      (RTE (RE_Activate_Tasks), Loc);\n-         end if;\n+      Chain := Activation_Chain_Entity (Owner);\n \n-         Call :=\n-           Make_Procedure_Call_Statement (Loc,\n-             Name                   => Name,\n-             Parameter_Associations =>\n-               New_List (Make_Attribute_Reference (Loc,\n-                 Prefix         => New_Occurrence_Of (Chain, Loc),\n-                 Attribute_Name => Name_Unchecked_Access)));\n+      --  Nothing to do when there are no tasks to activate. This is indicated\n+      --  by a missing activation chain entity.\n \n-         if Nkind (N) = N_Package_Declaration then\n-            if Present (Corresponding_Body (N)) then\n-               null;\n+      if No (Chain) then\n+         return;\n+      end if;\n \n-            elsif Present (Private_Declarations (Specification (N))) then\n-               Append (Call, Private_Declarations (Specification (N)));\n+      --  The location of the activation call must be as close as possible to\n+      --  the intended semantic location of the activation because the ABE\n+      --  mechanism relies heavily on accurate locations.\n \n-            else\n-               Append (Call, Visible_Declarations (Specification (N)));\n-            end if;\n+      Loc := Activation_Call_Loc;\n \n-         else\n-            if Present (Handled_Statement_Sequence (N)) then\n+      if Restricted_Profile then\n+         Name := New_Occurrence_Of (RTE (RE_Activate_Restricted_Tasks), Loc);\n+      else\n+         Name := New_Occurrence_Of (RTE (RE_Activate_Tasks), Loc);\n+      end if;\n \n-               --  The call goes at the start of the statement sequence after\n-               --  the start of exception range label if one is present.\n+      Call :=\n+        Make_Procedure_Call_Statement (Loc,\n+          Name                   => Name,\n+          Parameter_Associations =>\n+            New_List (Make_Attribute_Reference (Loc,\n+              Prefix         => New_Occurrence_Of (Chain, Loc),\n+              Attribute_Name => Name_Unchecked_Access)));\n \n-               declare\n-                  Stm : Node_Id;\n+      if Nkind (N) = N_Package_Declaration then\n+         if Present (Private_Declarations (Specification (N))) then\n+            Append (Call, Private_Declarations (Specification (N)));\n+         else\n+            Append (Call, Visible_Declarations (Specification (N)));\n+         end if;\n \n-               begin\n-                  Stm := First (Statements (Handled_Statement_Sequence (N)));\n+      else\n+         --  The call goes at the start of the statement sequence after the\n+         --  start of exception range label if one is present.\n \n-                  --  A special case, skip exception range label if one is\n-                  --  present (from front end zcx processing).\n+         if Present (Handled_Statement_Sequence (N)) then\n+            Stmt := First (Statements (Handled_Statement_Sequence (N)));\n \n-                  if Nkind (Stm) = N_Label and then Exception_Junk (Stm) then\n-                     Next (Stm);\n-                  end if;\n+            --  A special case, skip exception range label if one is present\n+            --  (from front end zcx processing).\n \n-                  --  Another special case, if the first statement is a block\n-                  --  from optimization of a local raise to a goto, then the\n-                  --  call goes inside this block.\n+            if Nkind (Stmt) = N_Label and then Exception_Junk (Stmt) then\n+               Next (Stmt);\n+            end if;\n \n-                  if Nkind (Stm) = N_Block_Statement\n-                    and then Exception_Junk (Stm)\n-                  then\n-                     Stm :=\n-                       First (Statements (Handled_Statement_Sequence (Stm)));\n-                  end if;\n+            --  Another special case, if the first statement is a block from\n+            --  optimization of a local raise to a goto, then the call goes\n+            --  inside this block.\n \n-                  --  Insertion point is after any exception label pushes,\n-                  --  since we want it covered by any local handlers.\n+            if Nkind (Stmt) = N_Block_Statement\n+              and then Exception_Junk (Stmt)\n+            then\n+               Stmt := First (Statements (Handled_Statement_Sequence (Stmt)));\n+            end if;\n \n-                  while Nkind (Stm) in N_Push_xxx_Label loop\n-                     Next (Stm);\n-                  end loop;\n+            --  Insertion point is after any exception label pushes, since we\n+            --  want it covered by any local handlers.\n \n-                  --  Now we have the proper insertion point\n+            while Nkind (Stmt) in N_Push_xxx_Label loop\n+               Next (Stmt);\n+            end loop;\n \n-                  Insert_Before (Stm, Call);\n-               end;\n+            --  Now we have the proper insertion point\n \n-            else\n-               Set_Handled_Statement_Sequence (N,\n-                  Make_Handled_Sequence_Of_Statements (Loc,\n-                    Statements => New_List (Call)));\n-            end if;\n-         end if;\n+            Insert_Before (Stmt, Call);\n \n-         Analyze (Call);\n-         Check_Task_Activation (N);\n+         else\n+            Set_Handled_Statement_Sequence (N,\n+              Make_Handled_Sequence_Of_Statements (Loc,\n+                Statements => New_List (Call)));\n+         end if;\n       end if;\n+\n+      Analyze (Call);\n    end Build_Task_Activation_Call;\n \n    -------------------------------\n@@ -10527,6 +10562,11 @@ package body Exp_Ch9 is\n               Make_Defining_Identifier (Eloc,\n                 New_External_Name (Chars (Ename), 'A', Num_Accept));\n \n+            --  Link the acceptor to the original receiving entry\n+\n+            Set_Ekind           (PB_Ent, E_Procedure);\n+            Set_Receiving_Entry (PB_Ent, Eent);\n+\n             if Comes_From_Source (Alt) then\n                Set_Debug_Info_Needed (PB_Ent);\n             end if;"}, {"sha": "dfed6af66a731e345bc77e125007d2707088dff3", "filename": "gcc/ada/exp_prag.adb", "status": "modified", "additions": 253, "deletions": 47, "changes": 300, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e491a7739dc2ae9a5b92945e4f0e48a3a91e39/gcc%2Fada%2Fexp_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e491a7739dc2ae9a5b92945e4f0e48a3a91e39/gcc%2Fada%2Fexp_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_prag.adb?ref=90e491a7739dc2ae9a5b92945e4f0e48a3a91e39", "patch": "@@ -42,6 +42,7 @@ with Restrict; use Restrict;\n with Rident;   use Rident;\n with Rtsfind;  use Rtsfind;\n with Sem;      use Sem;\n+with Sem_Aux;  use Sem_Aux;\n with Sem_Ch8;  use Sem_Ch8;\n with Sem_Util; use Sem_Util;\n with Sinfo;    use Sinfo;\n@@ -1447,82 +1448,287 @@ package body Exp_Prag is\n    -- Expand_Pragma_Initial_Condition --\n    -------------------------------------\n \n-   procedure Expand_Pragma_Initial_Condition (Spec_Or_Body : Node_Id) is\n-      Loc : constant Source_Ptr := Sloc (Spec_Or_Body);\n+   procedure Expand_Pragma_Initial_Condition\n+     (Pack_Id : Entity_Id;\n+      N       : Node_Id)\n+   is\n+      procedure Extract_Package_Body_Lists\n+        (Pack_Body : Node_Id;\n+         Body_List : out List_Id;\n+         Call_List : out List_Id;\n+         Spec_List : out List_Id);\n+      --  Obtain the various declarative and statement lists of package body\n+      --  Pack_Body needed to insert the initial condition procedure and the\n+      --  call to it. The lists are as follows:\n+      --\n+      --    * Body_List - used to insert the initial condition procedure body\n+      --\n+      --    * Call_List - used to insert the call to the initial condition\n+      --      procedure.\n+      --\n+      --    * Spec_List - used to insert the initial condition procedure spec\n+\n+      procedure Extract_Package_Declaration_Lists\n+        (Pack_Decl : Node_Id;\n+         Body_List : out List_Id;\n+         Call_List : out List_Id;\n+         Spec_List : out List_Id);\n+      --  Obtain the various declarative lists of package declaration Pack_Decl\n+      --  needed to insert the initial condition procedure and the call to it.\n+      --  The lists are as follows:\n+      --\n+      --    * Body_List - used to insert the initial condition procedure body\n+      --\n+      --    * Call_List - used to insert the call to the initial condition\n+      --      procedure.\n+      --\n+      --    * Spec_List - used to insert the initial condition procedure spec\n+\n+      --------------------------------\n+      -- Extract_Package_Body_Lists --\n+      --------------------------------\n+\n+      procedure Extract_Package_Body_Lists\n+        (Pack_Body : Node_Id;\n+         Body_List : out List_Id;\n+         Call_List : out List_Id;\n+         Spec_List : out List_Id)\n+      is\n+         Pack_Spec : constant Entity_Id := Corresponding_Spec (Pack_Body);\n \n-      Check     : Node_Id;\n-      Expr      : Node_Id;\n-      Init_Cond : Node_Id;\n-      List      : List_Id;\n-      Pack_Id   : Entity_Id;\n+         Dummy_1 : List_Id;\n+         Dummy_2 : List_Id;\n+         HSS     : Node_Id;\n \n-   begin\n-      if Nkind (Spec_Or_Body) = N_Package_Body then\n-         Pack_Id := Corresponding_Spec (Spec_Or_Body);\n+      begin\n+         pragma Assert (Present (Pack_Spec));\n \n-         if Present (Handled_Statement_Sequence (Spec_Or_Body)) then\n-            List := Statements (Handled_Statement_Sequence (Spec_Or_Body));\n+         --  The different parts of the invariant procedure are inserted as\n+         --  follows:\n \n-         --  The package body lacks statements, create an empty list\n+         --    package Pack is       package body Pack is\n+         --       <IC spec>             <IC body>\n+         --    private               begin\n+         --       ...                   <IC call>\n+         --    end Pack;             end Pack;\n \n-         else\n-            List := New_List;\n+         --  The initial condition procedure spec is inserted in the visible\n+         --  declaration of the corresponding package spec.\n+\n+         Extract_Package_Declaration_Lists\n+           (Pack_Decl => Unit_Declaration_Node (Pack_Spec),\n+            Body_List => Dummy_1,\n+            Call_List => Dummy_2,\n+            Spec_List => Spec_List);\n+\n+         --  The initial condition procedure body is added to the declarations\n+         --  of the package body.\n+\n+         Body_List := Declarations (Pack_Body);\n \n-            Set_Handled_Statement_Sequence (Spec_Or_Body,\n-              Make_Handled_Sequence_Of_Statements (Loc, Statements => List));\n+         if No (Body_List) then\n+            Body_List := New_List;\n+            Set_Declarations (Pack_Body, Body_List);\n          end if;\n \n-      elsif Nkind (Spec_Or_Body) = N_Package_Declaration then\n-         Pack_Id := Defining_Entity (Spec_Or_Body);\n+         --  The call to the initial condition procedure is inserted in the\n+         --  statements of the package body.\n \n-         if Present (Visible_Declarations (Specification (Spec_Or_Body))) then\n-            List := Visible_Declarations (Specification (Spec_Or_Body));\n+         HSS := Handled_Statement_Sequence (Pack_Body);\n \n-         --  The package lacks visible declarations, create an empty list\n+         if No (HSS) then\n+            HSS :=\n+              Make_Handled_Sequence_Of_Statements (Sloc (Pack_Body),\n+                Statements => New_List);\n+            Set_Handled_Statement_Sequence (Pack_Body, HSS);\n+         end if;\n \n-         else\n-            List := New_List;\n+         Call_List := Statements (HSS);\n+      end Extract_Package_Body_Lists;\n+\n+      ---------------------------------------\n+      -- Extract_Package_Declaration_Lists --\n+      ---------------------------------------\n+\n+      procedure Extract_Package_Declaration_Lists\n+        (Pack_Decl : Node_Id;\n+         Body_List : out List_Id;\n+         Call_List : out List_Id;\n+         Spec_List : out List_Id)\n+      is\n+         Pack_Spec : constant Node_Id := Specification (Pack_Decl);\n+\n+      begin\n+         --  The different parts of the invariant procedure are inserted as\n+         --  follows:\n \n-            Set_Visible_Declarations (Specification (Spec_Or_Body), List);\n+         --    package Pack is\n+         --       <IC spec>\n+         --       <IC body>\n+         --    private\n+         --       <IC call>\n+         --    end Pack;\n+\n+         --  The initial condition procedure spec and body are inserted in the\n+         --  visible declarations of the package spec.\n+\n+         Body_List := Visible_Declarations (Pack_Spec);\n+\n+         if No (Body_List) then\n+            Body_List := New_List;\n+            Set_Visible_Declarations (Pack_Spec, Body_List);\n+         end if;\n+\n+         Spec_List := Body_List;\n+\n+         --  The call to the initial procedure is inserted in the private\n+         --  declarations of the package spec.\n+\n+         Call_List := Private_Declarations (Pack_Spec);\n+\n+         if No (Call_List) then\n+            Call_List := New_List;\n+            Set_Private_Declarations (Pack_Spec, Call_List);\n          end if;\n+      end Extract_Package_Declaration_Lists;\n+\n+      --  Local variables\n+\n+      IC_Prag : constant Node_Id :=\n+                  Get_Pragma (Pack_Id, Pragma_Initial_Condition);\n+\n+      Body_List    : List_Id;\n+      Call         : Node_Id;\n+      Call_List    : List_Id;\n+      Call_Loc     : Source_Ptr;\n+      Expr         : Node_Id;\n+      Loc          : Source_Ptr;\n+      Proc_Body    : Node_Id;\n+      Proc_Body_Id : Entity_Id;\n+      Proc_Decl    : Node_Id;\n+      Proc_Id      : Entity_Id;\n+      Spec_List    : List_Id;\n+\n+   --  Start of processing for Expand_Pragma_Initial_Condition\n+\n+   begin\n+      --  Nothing to do when the package is not subject to an Initial_Condition\n+      --  pragma.\n+\n+      if No (IC_Prag) then\n+         return;\n+      end if;\n+\n+      Expr := Get_Pragma_Arg (First (Pragma_Argument_Associations (IC_Prag)));\n+      Loc  := Sloc (IC_Prag);\n+\n+      --  Nothing to do when the pragma or its argument are illegal because\n+      --  there is no valid expression to check.\n+\n+      if Error_Posted (IC_Prag) or else Error_Posted (Expr) then\n+         return;\n+      end if;\n+\n+      --  Obtain the various lists of the context where the individual pieces\n+      --  of the initial condition procedure are to be inserted.\n+\n+      if Nkind (N) = N_Package_Body then\n+         Extract_Package_Body_Lists\n+           (Pack_Body => N,\n+            Body_List => Body_List,\n+            Call_List => Call_List,\n+            Spec_List => Spec_List);\n+\n+      elsif Nkind (N) = N_Package_Declaration then\n+         Extract_Package_Declaration_Lists\n+           (Pack_Decl => N,\n+            Body_List => Body_List,\n+            Call_List => Call_List,\n+            Spec_List => Spec_List);\n \n       --  This routine should not be used on anything other than packages\n \n       else\n-         raise Program_Error;\n+         pragma Assert (False);\n+         return;\n       end if;\n \n-      Init_Cond := Get_Pragma (Pack_Id, Pragma_Initial_Condition);\n+      Proc_Id :=\n+        Make_Defining_Identifier (Loc,\n+          Chars => New_External_Name (Chars (Pack_Id), \"Initial_Condition\"));\n \n-      --  The caller should check whether the package is subject to pragma\n-      --  Initial_Condition.\n+      Set_Ekind                          (Proc_Id, E_Procedure);\n+      Set_Is_Initial_Condition_Procedure (Proc_Id);\n \n-      pragma Assert (Present (Init_Cond));\n+      --  Generate:\n+      --    procedure <Pack_Id>Initial_Condition;\n \n-      Expr :=\n-        Get_Pragma_Arg (First (Pragma_Argument_Associations (Init_Cond)));\n+      Proc_Decl :=\n+        Make_Subprogram_Declaration (Loc,\n+          Make_Procedure_Specification (Loc,\n+            Defining_Unit_Name => Proc_Id));\n \n-      --  The assertion expression was found to be illegal, do not generate the\n-      --  runtime check as it will repeat the illegality.\n+      Append_To (Spec_List, Proc_Decl);\n \n-      if Error_Posted (Init_Cond) or else Error_Posted (Expr) then\n-         return;\n+      --  The initial condition procedure requires debug info when initial\n+      --  condition is subject to Source Coverage Obligations.\n+\n+      if Generate_SCO then\n+         Set_Needs_Debug_Info (Proc_Id);\n       end if;\n \n       --  Generate:\n-      --    pragma Check (Initial_Condition, <Expr>);\n+      --    procedure <Pack_Id>Initial_Condition is\n+      --    begin\n+      --       pragma Check (Initial_Condition, <Expr>);\n+      --    end <Pack_Id>Initial_Condition;\n+\n+      Proc_Body :=\n+        Make_Subprogram_Body (Loc,\n+          Specification              =>\n+            Copy_Subprogram_Spec (Specification (Proc_Decl)),\n+          Declarations               => Empty_List,\n+          Handled_Statement_Sequence =>\n+            Make_Handled_Sequence_Of_Statements (Loc,\n+              Statements => New_List (\n+                Make_Pragma (Loc,\n+                  Chars                        => Name_Check,\n+                  Pragma_Argument_Associations => New_List (\n+                    Make_Pragma_Argument_Association (Loc,\n+                      Expression =>\n+                        Make_Identifier (Loc, Name_Initial_Condition)),\n+                    Make_Pragma_Argument_Association (Loc,\n+                      Expression => New_Copy_Tree (Expr)))))));\n \n-      Check :=\n-        Make_Pragma (Loc,\n-          Chars                        => Name_Check,\n-          Pragma_Argument_Associations => New_List (\n-            Make_Pragma_Argument_Association (Loc,\n-              Expression => Make_Identifier (Loc, Name_Initial_Condition)),\n-            Make_Pragma_Argument_Association (Loc,\n-              Expression => New_Copy_Tree (Expr))));\n+      Append_To (Body_List, Proc_Body);\n+\n+      --  The initial condition procedure requires debug info when initial\n+      --  condition is subject to Source Coverage Obligations.\n+\n+      Proc_Body_Id := Defining_Entity (Proc_Body);\n+\n+      if Generate_SCO then\n+         Set_Needs_Debug_Info (Proc_Body_Id);\n+      end if;\n+\n+      --  The location of the initial condition procedure call must be as close\n+      --  as possible to the intended semantic location of the check because\n+      --  the ABE mechanism relies heavily on accurate locations.\n+\n+      Call_Loc := End_Keyword_Location (N);\n+\n+      --  Generate:\n+      --    <Pack_Id>Initial_Condition;\n+\n+      Call :=\n+        Make_Procedure_Call_Statement (Call_Loc,\n+          Name => New_Occurrence_Of (Proc_Id, Call_Loc));\n+\n+      Append_To (Call_List, Call);\n \n-      Append_To (List, Check);\n-      Analyze (Check);\n+      Analyze (Proc_Decl);\n+      Analyze (Proc_Body);\n+      Analyze (Call);\n    end Expand_Pragma_Initial_Condition;\n \n    ------------------------------------"}, {"sha": "9e5f042c1810b95f9388a122daf452bd3e8df3ff", "filename": "gcc/ada/exp_prag.ads", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e491a7739dc2ae9a5b92945e4f0e48a3a91e39/gcc%2Fada%2Fexp_prag.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e491a7739dc2ae9a5b92945e4f0e48a3a91e39/gcc%2Fada%2Fexp_prag.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_prag.ads?ref=90e491a7739dc2ae9a5b92945e4f0e48a3a91e39", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -42,15 +42,11 @@ package Exp_Prag is\n    --  Subp_Id's body. All generated code is added to list Stmts. If Stmts is\n    --  No_List on entry, a new list is created.\n \n-   procedure Expand_Pragma_Initial_Condition (Spec_Or_Body : Node_Id);\n-   --  Generate a runtime check needed to verify the assumption of introduced\n-   --  by pragma Initial_Condition. Spec_Or_Body denotes the spec or body of\n-   --  the package where the pragma appears. The check is inserted according\n-   --  to the following precedence rules:\n-   --    1) If the package has a body with a statement sequence, the check is\n-   --       inserted at the end of the statments.\n-   --    2) If the package has a body, the check is inserted at the end of the\n-   --       body declarations.\n-   --    3) The check is inserted at the end of the visible declarations.\n+   procedure Expand_Pragma_Initial_Condition\n+     (Pack_Id : Entity_Id;\n+      N       : Node_Id);\n+   --  Verify the run-time semantics of pragma Initial_Condition when it\n+   --  applies to package Pack_Id. N denotes the related package spec or\n+   --  body.\n \n end Exp_Prag;"}, {"sha": "9383c1c65e6612cc074d47f6db33a2a2f8c0a074", "filename": "gcc/ada/exp_spark.adb", "status": "modified", "additions": 58, "deletions": 33, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e491a7739dc2ae9a5b92945e4f0e48a3a91e39/gcc%2Fada%2Fexp_spark.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e491a7739dc2ae9a5b92945e4f0e48a3a91e39/gcc%2Fada%2Fexp_spark.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_spark.adb?ref=90e491a7739dc2ae9a5b92945e4f0e48a3a91e39", "patch": "@@ -61,13 +61,16 @@ package body Exp_SPARK is\n    procedure Expand_SPARK_Indexed_Component (N : Node_Id);\n    --  Insert explicit dereference if required\n \n+   procedure Expand_SPARK_N_Loop_Statement (N : Node_Id);\n+   --  Perform loop statement-specific expansion\n+\n    procedure Expand_SPARK_N_Object_Declaration (N : Node_Id);\n    --  Perform object-declaration-specific expansion\n \n    procedure Expand_SPARK_N_Object_Renaming_Declaration (N : Node_Id);\n    --  Perform name evaluation for a renamed object\n \n-   procedure Expand_SPARK_Op_Ne (N : Node_Id);\n+   procedure Expand_SPARK_N_Op_Ne (N : Node_Id);\n    --  Rewrite operator /= based on operator = when defined explicitly\n \n    procedure Expand_SPARK_Selected_Component (N : Node_Id);\n@@ -118,17 +121,7 @@ package body Exp_SPARK is\n          --  dealt with specially in GNATprove.\n \n          when N_Loop_Statement =>\n-            declare\n-               Scheme : constant Node_Id := Iteration_Scheme (N);\n-            begin\n-               if Present (Scheme)\n-                 and then Present (Iterator_Specification (Scheme))\n-                 and then\n-                   Is_Iterator_Over_Array (Iterator_Specification (Scheme))\n-               then\n-                  Expand_Iterator_Loop_Over_Array (N);\n-               end if;\n-            end;\n+            Expand_SPARK_N_Loop_Statement (N);\n \n          when N_Object_Declaration =>\n             Expand_SPARK_N_Object_Declaration (N);\n@@ -137,7 +130,7 @@ package body Exp_SPARK is\n             Expand_SPARK_N_Object_Renaming_Declaration (N);\n \n          when N_Op_Ne =>\n-            Expand_SPARK_Op_Ne (N);\n+            Expand_SPARK_N_Op_Ne (N);\n \n          when N_Freeze_Entity =>\n             if Is_Type (Entity (N)) then\n@@ -157,6 +150,21 @@ package body Exp_SPARK is\n       end case;\n    end Expand_SPARK;\n \n+   ------------------------------\n+   -- Expand_SPARK_Freeze_Type --\n+   ------------------------------\n+\n+   procedure Expand_SPARK_Freeze_Type (E : Entity_Id) is\n+   begin\n+      --  When a DIC is inherited by a tagged type, it may need to be\n+      --  specialized to the descendant type, hence build a separate DIC\n+      --  procedure for it as done during regular expansion for compilation.\n+\n+      if Has_DIC (E) and then Is_Tagged_Type (E) then\n+         Build_DIC_Procedure_Body (E, For_Freeze => True);\n+      end if;\n+   end Expand_SPARK_Freeze_Type;\n+\n    ----------------------------------------\n    -- Expand_SPARK_N_Attribute_Reference --\n    ----------------------------------------\n@@ -261,20 +269,28 @@ package body Exp_SPARK is\n       end if;\n    end Expand_SPARK_N_Attribute_Reference;\n \n-   ------------------------------\n-   -- Expand_SPARK_Freeze_Type --\n-   ------------------------------\n+   -----------------------------------\n+   -- Expand_SPARK_N_Loop_Statement --\n+   -----------------------------------\n \n-   procedure Expand_SPARK_Freeze_Type (E : Entity_Id) is\n-   begin\n-      --  When a DIC is inherited by a tagged type, it may need to be\n-      --  specialized to the descendant type, hence build a separate DIC\n-      --  procedure for it as done during regular expansion for compilation.\n+   procedure Expand_SPARK_N_Loop_Statement (N : Node_Id) is\n+      Scheme : constant Node_Id := Iteration_Scheme (N);\n \n-      if Has_DIC (E) and then Is_Tagged_Type (E) then\n-         Build_DIC_Procedure_Body (E, For_Freeze => True);\n+   begin\n+      --  Loop iterations over arrays need to be expanded, to avoid getting\n+      --  two names referring to the same object in memory (the array and the\n+      --  iterator) in GNATprove, especially since both can be written (thus\n+      --  possibly leading to interferences due to aliasing). No such problem\n+      --  arises with quantified expressions over arrays, which are dealt with\n+      --  specially in GNATprove.\n+\n+      if Present (Scheme)\n+        and then Present (Iterator_Specification (Scheme))\n+        and then Is_Iterator_Over_Array (Iterator_Specification (Scheme))\n+      then\n+         Expand_Iterator_Loop_Over_Array (N);\n       end if;\n-   end Expand_SPARK_Freeze_Type;\n+   end Expand_SPARK_N_Loop_Statement;\n \n    ------------------------------------\n    -- Expand_SPARK_Indexed_Component --\n@@ -295,22 +311,31 @@ package body Exp_SPARK is\n    ---------------------------------------\n \n    procedure Expand_SPARK_N_Object_Declaration (N : Node_Id) is\n-      Def_Id : constant Entity_Id  := Defining_Identifier (N);\n       Loc    : constant Source_Ptr := Sloc (N);\n-      Typ    : constant Entity_Id  := Etype (Def_Id);\n+      Obj_Id : constant Entity_Id  := Defining_Identifier (N);\n+      Typ    : constant Entity_Id  := Etype (Obj_Id);\n+\n+      Call : Node_Id;\n \n    begin\n       --  If the object declaration denotes a variable without initialization\n       --  whose type is subject to pragma Default_Initial_Condition, create\n       --  and analyze a dummy call to the DIC procedure of the type in order\n       --  to detect potential elaboration issues.\n \n-      if Comes_From_Source (Def_Id)\n+      if Comes_From_Source (Obj_Id)\n+        and then Ekind (Obj_Id) = E_Variable\n         and then Has_DIC (Typ)\n         and then Present (DIC_Procedure (Typ))\n         and then not Has_Init_Expression (N)\n       then\n-         Analyze (Build_DIC_Call (Loc, Def_Id, Typ));\n+         Call := Build_DIC_Call (Loc, Obj_Id, Typ);\n+\n+         --  Partially insert the call into the tree by setting its parent\n+         --  pointer.\n+\n+         Set_Parent (Call, N);\n+         Analyze (Call);\n       end if;\n    end Expand_SPARK_N_Object_Declaration;\n \n@@ -370,11 +395,11 @@ package body Exp_SPARK is\n       end if;\n    end Expand_SPARK_N_Object_Renaming_Declaration;\n \n-   ------------------------\n-   -- Expand_SPARK_Op_Ne --\n-   ------------------------\n+   --------------------------\n+   -- Expand_SPARK_N_Op_Ne --\n+   --------------------------\n \n-   procedure Expand_SPARK_Op_Ne (N : Node_Id) is\n+   procedure Expand_SPARK_N_Op_Ne (N : Node_Id) is\n       Typ : constant Entity_Id := Etype (Left_Opnd (N));\n \n    begin\n@@ -388,7 +413,7 @@ package body Exp_SPARK is\n       else\n          Exp_Ch4.Expand_N_Op_Ne (N);\n       end if;\n-   end Expand_SPARK_Op_Ne;\n+   end Expand_SPARK_N_Op_Ne;\n \n    -------------------------------------\n    -- Expand_SPARK_Potential_Renaming --"}, {"sha": "def22631384384da8da7954a42095c12114710e6", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 56, "deletions": 38, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e491a7739dc2ae9a5b92945e4f0e48a3a91e39/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e491a7739dc2ae9a5b92945e4f0e48a3a91e39/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=90e491a7739dc2ae9a5b92945e4f0e48a3a91e39", "patch": "@@ -52,6 +52,7 @@ with Sem_Ch8;  use Sem_Ch8;\n with Sem_Ch12; use Sem_Ch12;\n with Sem_Ch13; use Sem_Ch13;\n with Sem_Disp; use Sem_Disp;\n+with Sem_Elab; use Sem_Elab;\n with Sem_Eval; use Sem_Eval;\n with Sem_Res;  use Sem_Res;\n with Sem_Type; use Sem_Type;\n@@ -1763,9 +1764,12 @@ package body Exp_Util is\n \n          --  Perform minor decoration in case the body is not analyzed\n \n-         Set_Ekind (Proc_Body_Id, E_Subprogram_Body);\n-         Set_Etype (Proc_Body_Id, Standard_Void_Type);\n-         Set_Scope (Proc_Body_Id, Current_Scope);\n+         Set_Ekind        (Proc_Body_Id, E_Subprogram_Body);\n+         Set_Etype        (Proc_Body_Id, Standard_Void_Type);\n+         Set_Scope        (Proc_Body_Id, Current_Scope);\n+         Set_SPARK_Pragma (Proc_Body_Id, SPARK_Pragma (Proc_Id));\n+         Set_SPARK_Pragma_Inherited\n+                          (Proc_Body_Id, SPARK_Pragma_Inherited (Proc_Id));\n \n          --  Link both spec and body to avoid generating duplicates\n \n@@ -1905,17 +1909,19 @@ package body Exp_Util is\n \n       --  Perform minor decoration in case the declaration is not analyzed\n \n-      Set_Ekind (Proc_Id, E_Procedure);\n-      Set_Etype (Proc_Id, Standard_Void_Type);\n-      Set_Scope (Proc_Id, Current_Scope);\n+      Set_Ekind                  (Proc_Id, E_Procedure);\n+      Set_Etype                  (Proc_Id, Standard_Void_Type);\n+      Set_Is_DIC_Procedure       (Proc_Id);\n+      Set_Scope                  (Proc_Id, Current_Scope);\n+      Set_SPARK_Pragma           (Proc_Id, SPARK_Mode_Pragma);\n+      Set_SPARK_Pragma_Inherited (Proc_Id);\n \n-      Set_Is_DIC_Procedure (Proc_Id);\n       Set_DIC_Procedure (Work_Typ, Proc_Id);\n \n       --  The DIC procedure requires debug info when the assertion expression\n       --  is subject to Source Coverage Obligations.\n \n-      if Opt.Generate_SCO then\n+      if Generate_SCO then\n          Set_Needs_Debug_Info (Proc_Id);\n       end if;\n \n@@ -3387,7 +3393,7 @@ package body Exp_Util is\n       --  The invariant procedure requires debug info when the invariants are\n       --  subject to Source Coverage Obligations.\n \n-      if Opt.Generate_SCO then\n+      if Generate_SCO then\n          Set_Needs_Debug_Info (Proc_Id);\n       end if;\n \n@@ -7232,7 +7238,7 @@ package body Exp_Util is\n                   null;\n                end if;\n \n-            --  Another special case, an attribute denoting a procedure call\n+            --  Special case: an attribute denoting a procedure call\n \n             when N_Attribute_Reference =>\n                if Is_Procedure_Attribute_Name (Attribute_Name (P)) then\n@@ -7250,6 +7256,14 @@ package body Exp_Util is\n                   null;\n                end if;\n \n+            --  Special case: a call marker\n+\n+            when N_Call_Marker =>\n+               if Is_List_Member (P) then\n+                  Insert_List_Before_And_Analyze (P, Ins_Actions);\n+                  return;\n+               end if;\n+\n             --  A contract node should not belong to the tree\n \n             when N_Contract =>\n@@ -8834,6 +8848,11 @@ package body Exp_Util is\n       if Present (N) then\n          Remove_Warning_Messages (N);\n \n+         --  Update the internal structures of the ABE mechanism in case the\n+         --  dead node is an elaboration scenario.\n+\n+         Kill_Elaboration_Scenario (N);\n+\n          --  Generate warning if appropriate\n \n          if W then\n@@ -9190,43 +9209,42 @@ package body Exp_Util is\n       Lo          : constant Node_Id :=\n                       New_Copy_Tree (String_Literal_Low_Bound (Literal_Typ));\n       Index       : constant Entity_Id := Etype (Lo);\n-\n-      Hi          : Node_Id;\n       Length_Expr : constant Node_Id :=\n                       Make_Op_Subtract (Loc,\n-                        Left_Opnd =>\n+                        Left_Opnd  =>\n                           Make_Integer_Literal (Loc,\n                             Intval => String_Literal_Length (Literal_Typ)),\n-                        Right_Opnd =>\n-                          Make_Integer_Literal (Loc, 1));\n+                        Right_Opnd => Make_Integer_Literal (Loc, 1));\n+\n+      Hi : Node_Id;\n \n    begin\n       Set_Analyzed (Lo, False);\n \n-         if Is_Integer_Type (Index) then\n-            Hi :=\n-              Make_Op_Add (Loc,\n-                Left_Opnd  => New_Copy_Tree (Lo),\n-                Right_Opnd => Length_Expr);\n-         else\n-            Hi :=\n-              Make_Attribute_Reference (Loc,\n-                Attribute_Name => Name_Val,\n-                Prefix => New_Occurrence_Of (Index, Loc),\n-                Expressions => New_List (\n-                 Make_Op_Add (Loc,\n-                   Left_Opnd =>\n-                     Make_Attribute_Reference (Loc,\n-                       Attribute_Name => Name_Pos,\n-                       Prefix => New_Occurrence_Of (Index, Loc),\n-                       Expressions => New_List (New_Copy_Tree (Lo))),\n-                  Right_Opnd => Length_Expr)));\n-         end if;\n+      if Is_Integer_Type (Index) then\n+         Hi :=\n+           Make_Op_Add (Loc,\n+             Left_Opnd  => New_Copy_Tree (Lo),\n+             Right_Opnd => Length_Expr);\n+      else\n+         Hi :=\n+           Make_Attribute_Reference (Loc,\n+             Attribute_Name => Name_Val,\n+             Prefix         => New_Occurrence_Of (Index, Loc),\n+             Expressions    => New_List (\n+               Make_Op_Add (Loc,\n+                 Left_Opnd  =>\n+                   Make_Attribute_Reference (Loc,\n+                     Attribute_Name => Name_Pos,\n+                     Prefix         => New_Occurrence_Of (Index, Loc),\n+                     Expressions    => New_List (New_Copy_Tree (Lo))),\n+                 Right_Opnd => Length_Expr)));\n+      end if;\n \n-         return\n-           Make_Range (Loc,\n-             Low_Bound  => Lo,\n-             High_Bound => Hi);\n+      return\n+        Make_Range (Loc,\n+          Low_Bound  => Lo,\n+          High_Bound => Hi);\n    end Make_Literal_Range;\n \n    --------------------------"}, {"sha": "3fab6dd7b695821e4db5a7c316a970e3e99caa82", "filename": "gcc/ada/exp_util.ads", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e491a7739dc2ae9a5b92945e4f0e48a3a91e39/gcc%2Fada%2Fexp_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e491a7739dc2ae9a5b92945e4f0e48a3a91e39/gcc%2Fada%2Fexp_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.ads?ref=90e491a7739dc2ae9a5b92945e4f0e48a3a91e39", "patch": "@@ -856,11 +856,8 @@ package Exp_Util is\n    --  False means that it is not known if the value is positive or negative.\n \n    function Make_Invariant_Call (Expr : Node_Id) return Node_Id;\n-   --  Expr is an object of a type which Has_Invariants set (and which thus\n-   --  also has an Invariant_Procedure set). If invariants are enabled, this\n-   --  function returns a call to the Invariant procedure passing Expr as the\n-   --  argument, and returns it unanalyzed. If invariants are not enabled,\n-   --  returns a null statement.\n+   --  Generate a call to the Invariant_Procedure associated with the type of\n+   --  expression Expr. Expr is passed as an actual parameter in the call.\n \n    function Make_Predicate_Call\n      (Typ  : Entity_Id;"}, {"sha": "b19da8973328e9d316868113d03cbfc93996c5f8", "filename": "gcc/ada/frontend.adb", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e491a7739dc2ae9a5b92945e4f0e48a3a91e39/gcc%2Fada%2Ffrontend.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e491a7739dc2ae9a5b92945e4f0e48a3a91e39/gcc%2Fada%2Ffrontend.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffrontend.adb?ref=90e491a7739dc2ae9a5b92945e4f0e48a3a91e39", "patch": "@@ -87,6 +87,7 @@ begin\n    Checks.Initialize;\n    Sem_Warn.Initialize;\n    Prep.Initialize;\n+   Sem_Elab.Initialize;\n \n    if Generate_SCIL then\n       SCIL_LL.Initialize;\n@@ -422,8 +423,9 @@ begin\n                Instantiate_Bodies;\n             end if;\n \n-            --  Analyze inlined bodies and check elaboration rules in GNATprove\n-            --  mode as well as during compilation.\n+            --  Analyze all inlined bodies, check access-before-elaboration\n+            --  rules, and remove ignored Ghost code when generating code or\n+            --  compiling for GNATprove.\n \n             if Operating_Mode = Generate_Code or else GNATprove_Mode then\n                if Inline_Processing_Required then\n@@ -437,12 +439,24 @@ begin\n                   Collect_Garbage_Entities;\n                end if;\n \n-               Check_Elab_Calls;\n+               --  Examine all top level scenarios collected during analysis\n+               --  and resolution. Diagnose conditional and guaranteed ABEs,\n+               --  install run-time checks to catch ABEs, and guarantee the\n+               --  prior elaboration of external units.\n+\n+               Check_Elaboration_Scenarios;\n \n                --  Remove any ignored Ghost code as it must not appear in the\n                --  executable.\n \n                Remove_Ignored_Ghost_Code;\n+\n+            --  Otherwise check the access-before-elaboration rules even when\n+            --  previous errors were detected or the compilation is verifying\n+            --  semantics.\n+\n+            else\n+               Check_Elaboration_Scenarios;\n             end if;\n \n             --  At this stage we can unnest subprogram bodies if required"}, {"sha": "a7579378cca02fa8da42177b4313daf9f7f1211d", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e491a7739dc2ae9a5b92945e4f0e48a3a91e39/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e491a7739dc2ae9a5b92945e4f0e48a3a91e39/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=90e491a7739dc2ae9a5b92945e4f0e48a3a91e39", "patch": "@@ -7688,6 +7688,15 @@ gnat_to_gnu (Node_Id gnat_node)\n     /* Added Nodes  */\n     /****************/\n \n+    /* Call markers are created by the ABE mechanism to capture the target of\n+       a call along with other elaboration-related attributes which are either\n+       unavailable of expensive to recompute.  Call markers do not have static\n+       and runtime semantics, and should be ignored. */\n+\n+    case N_Call_Marker:\n+      gnu_result = alloc_stmt_list ();\n+      break;\n+\n     case N_Expression_With_Actions:\n       /* This construct doesn't define a scope so we don't push a binding\n \t level around the statement list, but we wrap it in a SAVE_EXPR to"}, {"sha": "a39c2572be0450f6371b6a2d80451baa4ae7b2de", "filename": "gcc/ada/gnat_ugn.texi", "status": "modified", "additions": 1479, "deletions": 1466, "changes": 2945, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e491a7739dc2ae9a5b92945e4f0e48a3a91e39/gcc%2Fada%2Fgnat_ugn.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e491a7739dc2ae9a5b92945e4f0e48a3a91e39/gcc%2Fada%2Fgnat_ugn.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_ugn.texi?ref=90e491a7739dc2ae9a5b92945e4f0e48a3a91e39"}, {"sha": "8de6f355d0cb9b3bce8448bace63679eee2ccd51", "filename": "gcc/ada/lib.adb", "status": "modified", "additions": 25, "deletions": 8, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e491a7739dc2ae9a5b92945e4f0e48a3a91e39/gcc%2Fada%2Flib.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e491a7739dc2ae9a5b92945e4f0e48a3a91e39/gcc%2Fada%2Flib.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib.adb?ref=90e491a7739dc2ae9a5b92945e4f0e48a3a91e39", "patch": "@@ -62,7 +62,9 @@ package body Lib is\n       Yes_After,  -- S1 is in same extended unit as S2, and appears after it\n       No);        -- S2 is not in same extended unit as S2\n \n-   function Check_Same_Extended_Unit (S1, S2 : Source_Ptr) return SEU_Result;\n+   function Check_Same_Extended_Unit\n+     (S1 : Source_Ptr;\n+      S2 : Source_Ptr) return SEU_Result;\n    --  Used by In_Same_Extended_Unit and Earlier_In_Extended_Unit. Returns\n    --  value as described above.\n \n@@ -273,7 +275,10 @@ package body Lib is\n    -- Check_Same_Extended_Unit --\n    ------------------------------\n \n-   function Check_Same_Extended_Unit (S1, S2 : Source_Ptr) return SEU_Result is\n+   function Check_Same_Extended_Unit\n+     (S1 : Source_Ptr;\n+      S2 : Source_Ptr) return SEU_Result\n+   is\n       Max_Iterations : constant Nat := Maximum_Instantiations * 2;\n       --  Limit to prevent a potential infinite loop\n \n@@ -459,6 +464,7 @@ package body Lib is\n          --  Prevent looping forever\n \n          if Counter > Max_Iterations then\n+\n             --  ??? Not quite right, but return a value to be able to generate\n             --  SCIL files and hope for the best.\n \n@@ -502,11 +508,22 @@ package body Lib is\n    -- Earlier_In_Extended_Unit --\n    ------------------------------\n \n-   function Earlier_In_Extended_Unit (S1, S2 : Source_Ptr) return Boolean is\n+   function Earlier_In_Extended_Unit\n+     (S1 : Source_Ptr;\n+      S2 : Source_Ptr) return Boolean\n+   is\n    begin\n       return Check_Same_Extended_Unit (S1, S2) = Yes_Before;\n    end Earlier_In_Extended_Unit;\n \n+   function Earlier_In_Extended_Unit\n+     (N1 : Node_Or_Entity_Id;\n+      N2 : Node_Or_Entity_Id) return Boolean\n+   is\n+   begin\n+      return Earlier_In_Extended_Unit (Sloc (N1), Sloc (N2));\n+   end Earlier_In_Extended_Unit;\n+\n    -----------------------\n    -- Exact_Source_Name --\n    -----------------------\n@@ -747,7 +764,9 @@ package body Lib is\n    begin\n       return\n         Get_Code_Or_Source_Unit\n-          (S, Unwind_Instances => True, Unwind_Subunits => False);\n+          (S                => S,\n+           Unwind_Instances => True,\n+           Unwind_Subunits  => False);\n    end Get_Source_Unit;\n \n    function Get_Source_Unit (N : Node_Or_Entity_Id) return Unit_Number_Type is\n@@ -807,8 +826,7 @@ package body Lib is\n       --  Node may be in spec (or subunit etc) of main unit\n \n       else\n-         return\n-           In_Same_Extended_Unit (N, Cunit (Main_Unit));\n+         return In_Same_Extended_Unit (N, Cunit (Main_Unit));\n       end if;\n    end In_Extended_Main_Code_Unit;\n \n@@ -828,8 +846,7 @@ package body Lib is\n       --  Location may be in spec (or subunit etc) of main unit\n \n       else\n-         return\n-           In_Same_Extended_Unit (Loc, Sloc (Cunit (Main_Unit)));\n+         return In_Same_Extended_Unit (Loc, Sloc (Cunit (Main_Unit)));\n       end if;\n    end In_Extended_Main_Code_Unit;\n "}, {"sha": "be6864a3e8333021c43434f8c8c71983966909a2", "filename": "gcc/ada/lib.ads", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e491a7739dc2ae9a5b92945e4f0e48a3a91e39/gcc%2Fada%2Flib.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e491a7739dc2ae9a5b92945e4f0e48a3a91e39/gcc%2Fada%2Flib.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib.ads?ref=90e491a7739dc2ae9a5b92945e4f0e48a3a91e39", "patch": "@@ -481,13 +481,20 @@ package Lib is\n    --  avoid registering switches added automatically by the gcc driver at the\n    --  end of the command line.\n \n-   function Earlier_In_Extended_Unit (S1, S2 : Source_Ptr) return Boolean;\n+   function Earlier_In_Extended_Unit\n+     (S1 : Source_Ptr;\n+      S2 : Source_Ptr) return Boolean;\n    --  Given two Sloc values for which In_Same_Extended_Unit is true, determine\n    --  if S1 appears before S2. Returns True if S1 appears before S2, and False\n    --  otherwise. The result is undefined if S1 and S2 are not in the same\n    --  extended unit. Note: this routine will not give reliable results if\n    --  called after Sprint has been called with -gnatD set.\n \n+   function Earlier_In_Extended_Unit\n+     (N1 : Node_Or_Entity_Id;\n+      N2 : Node_Or_Entity_Id) return Boolean;\n+   --  Same as above, but the inputs denote nodes or entities\n+\n    procedure Enable_Switch_Storing;\n    --  Enable registration of switches by Store_Compilation_Switch. Used to\n    --  avoid registering switches added automatically by the gcc driver at the"}, {"sha": "aaa3ccb2e4013393577d9ff60b91bed2a65ee98c", "filename": "gcc/ada/sem.adb", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e491a7739dc2ae9a5b92945e4f0e48a3a91e39/gcc%2Fada%2Fsem.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e491a7739dc2ae9a5b92945e4f0e48a3a91e39/gcc%2Fada%2Fsem.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem.adb?ref=90e491a7739dc2ae9a5b92945e4f0e48a3a91e39", "patch": "@@ -612,6 +612,12 @@ package body Sem is\n          when N_With_Clause =>\n             Analyze_With_Clause (N);\n \n+         --  A call to analyze a call marker is ignored because the node does\n+         --  not have any static and run-time semantics.\n+\n+         when N_Call_Marker =>\n+            null;\n+\n          --  A call to analyze the Empty node is an error, but most likely it\n          --  is an error caused by an attempt to analyze a malformed piece of\n          --  tree caused by some other error, so if there have been any other\n@@ -1242,6 +1248,15 @@ package body Sem is\n       Scope_Stack.Locked := True;\n    end Lock;\n \n+   ------------------------\n+   -- Preanalysis_Active --\n+   ------------------------\n+\n+   function Preanalysis_Active return Boolean is\n+   begin\n+      return not Full_Analysis and not Expander_Active;\n+   end Preanalysis_Active;\n+\n    ----------------\n    -- Preanalyze --\n    ----------------"}, {"sha": "500f9220fd243e5fa625baa99dd1b9e569261fc0", "filename": "gcc/ada/sem.ads", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e491a7739dc2ae9a5b92945e4f0e48a3a91e39/gcc%2Fada%2Fsem.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e491a7739dc2ae9a5b92945e4f0e48a3a91e39/gcc%2Fada%2Fsem.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem.ads?ref=90e491a7739dc2ae9a5b92945e4f0e48a3a91e39", "patch": "@@ -683,6 +683,10 @@ package Sem is\n    --  This function returns True if an explicit pragma Suppress for check C\n    --  is present in the package defining E.\n \n+   function Preanalysis_Active return Boolean;\n+   pragma Inline (Preanalysis_Active);\n+   --  Determine whether preanalysis is active at the point of invocation\n+\n    procedure Preanalyze (N : Node_Id);\n    --  Performs a pre-analysis of node N. During pre-analysis no expansion is\n    --  carried out for N or its children. For more info on pre-analysis read"}, {"sha": "5aef17df8ec3bf88cfef06327d1eb9ac9ef46855", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e491a7739dc2ae9a5b92945e4f0e48a3a91e39/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e491a7739dc2ae9a5b92945e4f0e48a3a91e39/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=90e491a7739dc2ae9a5b92945e4f0e48a3a91e39", "patch": "@@ -28,7 +28,6 @@ with Ada.Characters.Latin_1; use Ada.Characters.Latin_1;\n with Atree;    use Atree;\n with Casing;   use Casing;\n with Checks;   use Checks;\n-with Debug;    use Debug;\n with Einfo;    use Einfo;\n with Elists;   use Elists;\n with Errout;   use Errout;\n@@ -806,6 +805,20 @@ package body Sem_Attr is\n               (\"prefix of % attribute cannot be enumeration literal\");\n          end if;\n \n+         --  Preserve relevant elaboration-related attributes of the context\n+         --  which are no longer available or very expensive to recompute once\n+         --  analysis, resolution, and expansion are over.\n+\n+         Mark_Elaboration_Attributes\n+           (N_Id   => N,\n+            Checks => True,\n+            Modes  => True);\n+\n+         --  Save the scenario for later examination by the ABE Processing\n+         --  phase.\n+\n+         Record_Elaboration_Scenario (N);\n+\n          --  Case of access to subprogram\n \n          if Is_Entity_Name (P) and then Is_Overloadable (Entity (P)) then\n@@ -860,14 +873,6 @@ package body Sem_Attr is\n                Kill_Current_Values;\n             end if;\n \n-            --  In the static elaboration model, treat the attribute reference\n-            --  as a call for elaboration purposes.  Suppress this treatment\n-            --  under debug flag. In any case, we are all done.\n-\n-            if not Dynamic_Elaboration_Checks and not Debug_Flag_Dot_UU then\n-               Check_Elab_Call (N);\n-            end if;\n-\n             return;\n \n          --  Component is an operation of a protected type\n@@ -11133,8 +11138,8 @@ package body Sem_Attr is\n             --  'Unrestricted_Access or in case of a subprogram.\n \n             if Is_Entity_Name (P)\n-             and then (Attr_Id = Attribute_Unrestricted_Access\n-                        or else Is_Subprogram (Entity (P)))\n+              and then (Attr_Id = Attribute_Unrestricted_Access\n+                         or else Is_Subprogram (Entity (P)))\n             then\n                Set_Address_Taken (Entity (P));\n             end if;"}, {"sha": "9f538e064381fa0ecd9ea02b20d49cca2f8731e5", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 172, "deletions": 20, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e491a7739dc2ae9a5b92945e4f0e48a3a91e39/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e491a7739dc2ae9a5b92945e4f0e48a3a91e39/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=90e491a7739dc2ae9a5b92945e4f0e48a3a91e39", "patch": "@@ -839,6 +839,10 @@ package body Sem_Ch12 is\n    --  entity is marked as having a limited_view actual when some actual is\n    --  a limited view. This is used to place the instance body properly.\n \n+   procedure Provide_Completing_Bodies (N : Node_Id);\n+   --  Generate completing bodies for all subprograms found within package or\n+   --  subprogram declaration N.\n+\n    procedure Remove_Parent (In_Body : Boolean := False);\n    --  Reverse effect after instantiation of child is complete\n \n@@ -3542,6 +3546,14 @@ package body Sem_Ch12 is\n       Set_SPARK_Pragma_Inherited     (Id);\n       Set_SPARK_Aux_Pragma_Inherited (Id);\n \n+      --  Preserve relevant elaboration-related attributes of the context which\n+      --  are no longer available or very expensive to recompute once analysis,\n+      --  resolution, and expansion are over.\n+\n+      Mark_Elaboration_Attributes\n+        (N_Id   => Id,\n+         Checks => True);\n+\n       --  Analyze aspects now, so that generated pragmas appear in the\n       --  declarations before building and analyzing the generic copy.\n \n@@ -3670,7 +3682,7 @@ package body Sem_Ch12 is\n       Create_Generic_Contract (N);\n \n       Spec := Specification (N);\n-      Id := Defining_Entity (Spec);\n+      Id   := Defining_Entity (Spec);\n       Generate_Definition (Id);\n \n       if Nkind (Id) = N_Defining_Operator_Symbol then\n@@ -3697,14 +3709,27 @@ package body Sem_Ch12 is\n \n       Analyze_Generic_Formal_Part (N);\n \n-      Formals := Parameter_Specifications (Spec);\n-\n       if Nkind (Spec) = N_Function_Specification then\n          Set_Ekind (Id, E_Generic_Function);\n       else\n          Set_Ekind (Id, E_Generic_Procedure);\n       end if;\n \n+      --  Set SPARK_Mode from context\n+\n+      Set_SPARK_Pragma           (Id, SPARK_Mode_Pragma);\n+      Set_SPARK_Pragma_Inherited (Id);\n+\n+      --  Preserve relevant elaboration-related attributes of the context which\n+      --  are no longer available or very expensive to recompute once analysis,\n+      --  resolution, and expansion are over.\n+\n+      Mark_Elaboration_Attributes\n+        (N_Id   => Id,\n+         Checks => True);\n+\n+      Formals := Parameter_Specifications (Spec);\n+\n       if Present (Formals) then\n          Process_Formals (Formals, Spec);\n       end if;\n@@ -3900,6 +3925,16 @@ package body Sem_Ch12 is\n    --  Start of processing for Analyze_Package_Instantiation\n \n    begin\n+      --  Preserve relevant elaboration-related attributes of the context which\n+      --  are no longer available or very expensive to recompute once analysis,\n+      --  resolution, and expansion are over.\n+\n+      Mark_Elaboration_Attributes\n+        (N_Id   => N,\n+         Checks => True,\n+         Level  => True,\n+         Modes  => True);\n+\n       Check_SPARK_05_Restriction (\"generic is not allowed\", N);\n \n       --  Very first thing: check for Text_IO special unit in case we are\n@@ -4562,19 +4597,26 @@ package body Sem_Ch12 is\n             Analyze (Act_Decl);\n             Set_Unit (Parent (N), N);\n             Set_Body_Required (Parent (N), False);\n+         end if;\n \n-            --  We never need elaboration checks on instantiations, since by\n-            --  definition, the body instantiation is elaborated at the same\n-            --  time as the spec instantiation.\n+         --  Save the scenario for later examination by the ABE Processing\n+         --  phase.\n \n-            Set_Suppress_Elaboration_Warnings (Act_Decl_Id);\n-            Set_Kill_Elaboration_Checks       (Act_Decl_Id);\n-         end if;\n+         Record_Elaboration_Scenario (N);\n+\n+         --  The instantiation results in a guaranteed ABE\n \n-         Check_Elab_Instantiation (N);\n+         if Is_Known_Guaranteed_ABE (N) and then Needs_Body then\n+\n+            --  Do not instantiate the corresponding body because gigi cannot\n+            --  handle certain types of premature instantiations.\n \n-         if ABE_Is_Certain (N) and then Needs_Body then\n             Pending_Instantiations.Decrement_Last;\n+\n+            --  Create completing bodies for all subprogram declarations since\n+            --  their real bodies will not be instantiated.\n+\n+            Provide_Completing_Bodies (Instance_Spec (N));\n          end if;\n \n          Check_Hidden_Child_Unit (N, Gen_Unit, Act_Decl_Id);\n@@ -5056,7 +5098,7 @@ package body Sem_Ch12 is\n \n         --  No point in inlining if ABE is inevitable\n \n-        and then not ABE_Is_Certain (N)\n+        and then not Is_Known_Guaranteed_ABE (N)\n \n         --  Or if subprogram is eliminated\n \n@@ -5242,12 +5284,7 @@ package body Sem_Ch12 is\n          Check_Eliminated  (Act_Decl_Id);\n          Set_Is_Eliminated (Anon_Id, Is_Eliminated (Act_Decl_Id));\n \n-         --  In compilation unit case, kill elaboration checks on the\n-         --  instantiation, since they are never needed -- the body is\n-         --  instantiated at the same point as the spec.\n-\n          if Nkind (Parent (N)) = N_Compilation_Unit then\n-            Set_Suppress_Elaboration_Warnings (Act_Decl_Id);\n             Set_Kill_Elaboration_Checks       (Act_Decl_Id);\n             Set_Is_Compilation_Unit (Anon_Id);\n \n@@ -5338,6 +5375,16 @@ package body Sem_Ch12 is\n    --  Start of processing for Analyze_Subprogram_Instantiation\n \n    begin\n+      --  Preserve relevant elaboration-related attributes of the context which\n+      --  are no longer available or very expensive to recompute once analysis,\n+      --  resolution, and expansion are over.\n+\n+      Mark_Elaboration_Attributes\n+        (N_Id   => N,\n+         Checks => True,\n+         Level  => True,\n+         Modes  => True);\n+\n       Check_SPARK_05_Restriction (\"generic is not allowed\", N);\n \n       --  Very first thing: check for special Text_IO unit in case we are\n@@ -5590,8 +5637,17 @@ package body Sem_Ch12 is\n             Set_Ignore_SPARK_Mode_Pragmas (Anon_Id);\n          end if;\n \n-         if not Is_Intrinsic_Subprogram (Gen_Unit) then\n-            Check_Elab_Instantiation (N);\n+         --  Save the scenario for later examination by the ABE Processing\n+         --  phase.\n+\n+         Record_Elaboration_Scenario (N);\n+\n+         --  The instantiation results in a guaranteed ABE. Create a completing\n+         --  body for the subprogram declaration because the real body will not\n+         --  be instantiated.\n+\n+         if Is_Known_Guaranteed_ABE (N) then\n+            Provide_Completing_Bodies (Instance_Spec (N));\n          end if;\n \n          if Is_Dispatching_Operation (Act_Decl_Id)\n@@ -8561,7 +8617,7 @@ package body Sem_Ch12 is\n          --  The parent was a premature instantiation. Insert freeze node at\n          --  the end the current declarative part.\n \n-         if ABE_Is_Certain (Get_Unit_Instantiation_Node (Par)) then\n+         if Is_Known_Guaranteed_ABE (Get_Unit_Instantiation_Node (Par)) then\n             Insert_Freeze_Node_For_Instance (Inst_Node, F_Node);\n \n          --  Handle the following case:\n@@ -13991,6 +14047,102 @@ package body Sem_Ch12 is\n       end if;\n    end Preanalyze_Actuals;\n \n+   -------------------------------\n+   -- Provide_Completing_Bodies --\n+   -------------------------------\n+\n+   procedure Provide_Completing_Bodies (N : Node_Id) is\n+      procedure Build_Completing_Body (Subp_Decl : Node_Id);\n+      --  Generate the completing body for subprogram declaration Subp_Decl\n+\n+      procedure Provide_Completing_Bodies_In (Decls : List_Id);\n+      --  Generating completing bodies for all subprograms found in declarative\n+      --  list Decls.\n+\n+      ---------------------------\n+      -- Build_Completing_Body --\n+      ---------------------------\n+\n+      procedure Build_Completing_Body (Subp_Decl : Node_Id) is\n+         Loc     : constant Source_Ptr := Sloc (Subp_Decl);\n+         Subp_Id : constant Entity_Id  := Defining_Entity (Subp_Decl);\n+         Spec    : Node_Id;\n+\n+      begin\n+         --  Nothing to do if the subprogram already has a completing body\n+\n+         if Present (Corresponding_Body (Subp_Decl)) then\n+            return;\n+\n+         --  Mark the function as having a valid return statement even though\n+         --  the body contains a single raise statement.\n+\n+         elsif Ekind (Subp_Id) = E_Function then\n+            Set_Return_Present (Subp_Id);\n+         end if;\n+\n+         --  Clone the specification to obtain new entities and reset the only\n+         --  semantic field.\n+\n+         Spec := Copy_Subprogram_Spec (Specification (Subp_Decl));\n+         Set_Generic_Parent (Spec, Empty);\n+\n+         --  Generate:\n+         --    function Func ... return ... is\n+         --      <or>\n+         --    procedure Proc ... is\n+         --    begin\n+         --       raise Program_Error with \"access before elaboration\";\n+         --    edn Proc;\n+\n+         Insert_After_And_Analyze (Subp_Decl,\n+           Make_Subprogram_Body (Loc,\n+             Specification              => Spec,\n+             Declarations               => New_List,\n+             Handled_Statement_Sequence =>\n+               Make_Handled_Sequence_Of_Statements (Loc,\n+                 Statements => New_List (\n+                   Make_Raise_Program_Error (Loc,\n+                     Reason => PE_Access_Before_Elaboration)))));\n+      end Build_Completing_Body;\n+\n+      ----------------------------------\n+      -- Provide_Completing_Bodies_In --\n+      ----------------------------------\n+\n+      procedure Provide_Completing_Bodies_In (Decls : List_Id) is\n+         Decl : Node_Id;\n+\n+      begin\n+         if Present (Decls) then\n+            Decl := First (Decls);\n+            while Present (Decl) loop\n+               Provide_Completing_Bodies (Decl);\n+               Next (Decl);\n+            end loop;\n+         end if;\n+      end Provide_Completing_Bodies_In;\n+\n+      --  Local variables\n+\n+      Spec : Node_Id;\n+\n+   --  Start of processing for Provide_Completing_Bodies\n+\n+   begin\n+      if Nkind (N) = N_Package_Declaration then\n+         Spec := Specification (N);\n+\n+         Push_Scope (Defining_Entity (N));\n+         Provide_Completing_Bodies_In (Visible_Declarations (Spec));\n+         Provide_Completing_Bodies_In (Private_Declarations (Spec));\n+         Pop_Scope;\n+\n+      elsif Nkind (N) = N_Subprogram_Declaration then\n+         Build_Completing_Body (N);\n+      end if;\n+   end Provide_Completing_Bodies;\n+\n    -------------------\n    -- Remove_Parent --\n    -------------------"}, {"sha": "769b7e9e814a19431a55a47bd7bea3aec499e937", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e491a7739dc2ae9a5b92945e4f0e48a3a91e39/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e491a7739dc2ae9a5b92945e4f0e48a3a91e39/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=90e491a7739dc2ae9a5b92945e4f0e48a3a91e39", "patch": "@@ -4709,6 +4709,20 @@ package body Sem_Ch3 is\n          end if;\n       end if;\n \n+      --  Set the SPARK mode from the current context (may be overwritten later\n+      --  with explicit pragma).\n+\n+      Set_SPARK_Pragma           (Id, SPARK_Mode_Pragma);\n+      Set_SPARK_Pragma_Inherited (Id);\n+\n+      --  Preserve relevant elaboration-related attributes of the context which\n+      --  are no longer available or very expensive to recompute once analysis,\n+      --  resolution, and expansion are over.\n+\n+      Mark_Elaboration_Attributes\n+        (N_Id   => Id,\n+         Checks => True);\n+\n       --  Initialize alignment and size and capture alignment setting\n \n       Init_Alignment               (Id);"}, {"sha": "03876afafc4d3800052032ab9ea0abf70e48cdf5", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e491a7739dc2ae9a5b92945e4f0e48a3a91e39/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e491a7739dc2ae9a5b92945e4f0e48a3a91e39/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=90e491a7739dc2ae9a5b92945e4f0e48a3a91e39", "patch": "@@ -379,6 +379,15 @@ package body Sem_Ch5 is\n    begin\n       Mark_Coextensions (N, Rhs);\n \n+      --  Preserve relevant elaboration-related attributes of the context which\n+      --  are no longer available or very expensive to recompute once analysis,\n+      --  resolution, and expansion are over.\n+\n+      Mark_Elaboration_Attributes\n+        (N_Id   => N,\n+         Checks => True,\n+         Modes  => True);\n+\n       --  Analyze the target of the assignment first in case the expression\n       --  contains references to Ghost entities. The checks that verify the\n       --  proper use of a Ghost entity need to know the enclosing context.\n@@ -917,11 +926,9 @@ package body Sem_Ch5 is\n          Error_Msg_CRT (\"composite assignment\", N);\n       end if;\n \n-      --  Check elaboration warning for left side if not in elab code\n+      --  Save the scenario for later examination by the ABE Processing phase\n \n-      if not In_Subprogram_Or_Concurrent_Unit then\n-         Check_Elab_Assign (Lhs);\n-      end if;\n+      Record_Elaboration_Scenario (N);\n \n       --  Set Referenced_As_LHS if appropriate. We only set this flag if the\n       --  assignment is a source assignment in the extended main source unit.\n@@ -2044,13 +2051,13 @@ package body Sem_Ch5 is\n \n             begin\n                if No (Iterator) then\n-                  null;   --  error reported below.\n+                  null;  --  error reported below\n \n                elsif not Is_Overloaded (Iterator) then\n                   Check_Reverse_Iteration (Etype (Iterator));\n \n-               --  If Iterator is overloaded, use reversible iterator if\n-               --  one is available.\n+               --  If Iterator is overloaded, use reversible iterator if one is\n+               --  available.\n \n                elsif Is_Overloaded (Iterator) then\n                   Get_First_Interp (Iterator, I, It);\n@@ -3609,8 +3616,7 @@ package body Sem_Ch5 is\n          end if;\n \n       else\n-\n-         --  Pre-Ada2012 for-loops and while loops.\n+         --  Pre-Ada2012 for-loops and while loops\n \n          Analyze_Statements (Statements (N));\n       end if;"}, {"sha": "a85ca60cd5f4cdf947abd5340a72e80901ff56fc", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 34, "deletions": 12, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e491a7739dc2ae9a5b92945e4f0e48a3a91e39/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e491a7739dc2ae9a5b92945e4f0e48a3a91e39/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=90e491a7739dc2ae9a5b92945e4f0e48a3a91e39", "patch": "@@ -226,6 +226,20 @@ package body Sem_Ch6 is\n \n       Generate_Definition (Subp_Id);\n \n+      --  Set the SPARK mode from the current context (may be overwritten later\n+      --  with explicit pragma).\n+\n+      Set_SPARK_Pragma           (Subp_Id, SPARK_Mode_Pragma);\n+      Set_SPARK_Pragma_Inherited (Subp_Id);\n+\n+      --  Preserve relevant elaboration-related attributes of the context which\n+      --  are no longer available or very expensive to recompute once analysis,\n+      --  resolution, and expansion are over.\n+\n+      Mark_Elaboration_Attributes\n+        (N_Id   => Subp_Id,\n+         Checks => True);\n+\n       Set_Is_Abstract_Subprogram (Subp_Id);\n       New_Overloaded_Entity (Subp_Id);\n       Check_Delayed_Subprogram (Subp_Id);\n@@ -1468,7 +1482,7 @@ package body Sem_Ch6 is\n \n          Set_Actual_Subtypes (N, Current_Scope);\n \n-         Set_SPARK_Pragma (Body_Id, SPARK_Mode_Pragma);\n+         Set_SPARK_Pragma           (Body_Id, SPARK_Mode_Pragma);\n          Set_SPARK_Pragma_Inherited (Body_Id);\n \n          --  Analyze any aspect specifications that appear on the generic\n@@ -1769,13 +1783,12 @@ package body Sem_Ch6 is\n \n       if Analyzed (N) then\n          return;\n-      end if;\n \n       --  If there is an error analyzing the name (which may have been\n       --  rewritten if the original call was in prefix notation) then error\n       --  has been emitted already, mark node and return.\n \n-      if Error_Posted (N) or else Etype (Name (N)) = Any_Type then\n+      elsif Error_Posted (N) or else Etype (Name (N)) = Any_Type then\n          Set_Etype (N, Any_Type);\n          return;\n       end if;\n@@ -1849,9 +1862,9 @@ package body Sem_Ch6 is\n \n          New_N :=\n            Make_Indexed_Component (Loc,\n-             Prefix =>\n+             Prefix      =>\n                Make_Selected_Component (Loc,\n-                 Prefix => New_Occurrence_Of (Scope (Entity (P)), Loc),\n+                 Prefix        => New_Occurrence_Of (Scope (Entity (P)), Loc),\n                  Selector_Name => New_Occurrence_Of (Entity (P), Loc)),\n              Expressions => Actuals);\n          Set_Name (N, New_N);\n@@ -1957,7 +1970,8 @@ package body Sem_Ch6 is\n       then\n          New_N :=\n            Make_Selected_Component (Loc,\n-             Prefix => New_Occurrence_Of (Scope (Entity (Prefix (P))), Loc),\n+             Prefix        =>\n+               New_Occurrence_Of (Scope (Entity (Prefix (P))), Loc),\n              Selector_Name => New_Occurrence_Of (Entity (Prefix (P)), Loc));\n          Rewrite (Prefix (P), New_N);\n          Analyze (P);\n@@ -4026,7 +4040,7 @@ package body Sem_Ch6 is\n       --  between the spec and body.\n \n       elsif No (SPARK_Pragma (Body_Id)) then\n-         Set_SPARK_Pragma (Body_Id, SPARK_Mode_Pragma);\n+         Set_SPARK_Pragma           (Body_Id, SPARK_Mode_Pragma);\n          Set_SPARK_Pragma_Inherited (Body_Id);\n       end if;\n \n@@ -4471,12 +4485,11 @@ package body Sem_Ch6 is\n          Stm : Node_Id;\n \n       begin\n-         --  Skip initial labels (for one thing this occurs when we are in\n-         --  front-end ZCX mode, but in any case it is irrelevant), and also\n-         --  initial Push_xxx_Error_Label nodes, which are also irrelevant.\n+         --  Skip call markers installed by the ABE mechanism, labels, and\n+         --  Push_xxx_Error_Label to find the first real statement.\n \n          Stm := First (Statements (HSS));\n-         while Nkind (Stm) = N_Label\n+         while Nkind_In (Stm, N_Call_Marker, N_Label)\n            or else Nkind (Stm) in N_Push_xxx_Label\n          loop\n             Next (Stm);\n@@ -4657,8 +4670,9 @@ package body Sem_Ch6 is\n         and then Is_Entry_Barrier_Function (N)\n       then\n          null;\n+\n       else\n-         Set_SPARK_Pragma (Designator, SPARK_Mode_Pragma);\n+         Set_SPARK_Pragma           (Designator, SPARK_Mode_Pragma);\n          Set_SPARK_Pragma_Inherited (Designator);\n       end if;\n \n@@ -4671,6 +4685,14 @@ package body Sem_Ch6 is\n          Set_Ignore_SPARK_Mode_Pragmas (Designator);\n       end if;\n \n+      --  Preserve relevant elaboration-related attributes of the context which\n+      --  are no longer available or very expensive to recompute once analysis,\n+      --  resolution, and expansion are over.\n+\n+      Mark_Elaboration_Attributes\n+        (N_Id   => Designator,\n+         Checks => True);\n+\n       if Debug_Flag_C then\n          Write_Str (\"==> subprogram spec \");\n          Write_Name (Chars (Designator));"}, {"sha": "f9a590095a088199de0e84e4fa23609a1fa437a0", "filename": "gcc/ada/sem_ch7.adb", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e491a7739dc2ae9a5b92945e4f0e48a3a91e39/gcc%2Fada%2Fsem_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e491a7739dc2ae9a5b92945e4f0e48a3a91e39/gcc%2Fada%2Fsem_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch7.adb?ref=90e491a7739dc2ae9a5b92945e4f0e48a3a91e39", "patch": "@@ -1144,16 +1144,10 @@ package body Sem_Ch7 is\n          end if;\n       end if;\n \n-      if Is_Comp_Unit then\n-\n-         --  Set Body_Required indication on the compilation unit node, and\n-         --  determine whether elaboration warnings may be meaningful on it.\n+      --  Set Body_Required indication on the compilation unit node\n \n+      if Is_Comp_Unit then\n          Set_Body_Required (Parent (N), Body_Required);\n-\n-         if not Body_Required then\n-            Set_Suppress_Elaboration_Warnings (Id);\n-         end if;\n       end if;\n \n       End_Package_Scope (Id);"}, {"sha": "d0c417ba0f576eb6f9df72db4ef8f1451dcec787", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 32, "deletions": 9, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e491a7739dc2ae9a5b92945e4f0e48a3a91e39/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e491a7739dc2ae9a5b92945e4f0e48a3a91e39/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=90e491a7739dc2ae9a5b92945e4f0e48a3a91e39", "patch": "@@ -57,6 +57,7 @@ with Sem_Ch13; use Sem_Ch13;\n with Sem_Dim;  use Sem_Dim;\n with Sem_Disp; use Sem_Disp;\n with Sem_Dist; use Sem_Dist;\n+with Sem_Elab; use Sem_Elab;\n with Sem_Eval; use Sem_Eval;\n with Sem_Res;  use Sem_Res;\n with Sem_Util; use Sem_Util;\n@@ -4133,6 +4134,11 @@ package body Sem_Ch8 is\n                    Statements => New_List (Attr_Node)));\n       end if;\n \n+      --  Signal the ABE mechanism that the generated subprogram body has not\n+      --  ABE ramifications.\n+\n+      Set_Was_Attribute_Reference (Body_Node);\n+\n       --  In case of tagged types we add the body of the generated function to\n       --  the freezing actions of the type (because in the general case such\n       --  type is still not frozen). We exclude from this processing generic\n@@ -4192,15 +4198,6 @@ package body Sem_Ch8 is\n          Error_Msg_N\n            (\"a library unit can only rename another library unit\", N);\n       end if;\n-\n-      --  We suppress elaboration warnings for the resulting entity, since\n-      --  clearly they are not needed, and more particularly, in the case\n-      --  of a generic formal subprogram, the resulting entity can appear\n-      --  after the instantiation itself, and thus look like a bogus case\n-      --  of access before elaboration.\n-\n-      Set_Suppress_Elaboration_Warnings (New_S);\n-\n    end Attribute_Renaming;\n \n    ----------------------\n@@ -5433,6 +5430,16 @@ package body Sem_Ch8 is\n          return;\n       end if;\n \n+      --  Preserve relevant elaboration-related attributes of the context which\n+      --  are no longer available or very expensive to recompute once analysis,\n+      --  resolution, and expansion are over.\n+\n+      if Nkind (N) = N_Identifier then\n+         Mark_Elaboration_Attributes\n+           (N_Id  => N,\n+            Modes => True);\n+      end if;\n+\n       --  Here if Entity pointer was not set, we need full visibility analysis\n       --  First we generate debugging output if the debug E flag is set.\n \n@@ -5907,6 +5914,10 @@ package body Sem_Ch8 is\n \n    <<Done>>\n       Check_Restriction_No_Use_Of_Entity (N);\n+\n+      --  Save the scenario for later examination by the ABE Processing phase\n+\n+      Record_Elaboration_Scenario (N);\n    end Find_Direct_Name;\n \n    ------------------------\n@@ -6421,6 +6432,14 @@ package body Sem_Ch8 is\n \n       Change_Selected_Component_To_Expanded_Name (N);\n \n+      --  Preserve relevant elaboration-related attributes of the context which\n+      --  are no longer available or very expensive to recompute once analysis,\n+      --  resolution, and expansion are over.\n+\n+      Mark_Elaboration_Attributes\n+        (N_Id  => N,\n+         Modes => True);\n+\n       --  Set appropriate type\n \n       if Is_Type (Id) then\n@@ -6529,6 +6548,10 @@ package body Sem_Ch8 is\n       end if;\n \n       Check_Restriction_No_Use_Of_Entity (N);\n+\n+      --  Save the scenario for later examination by the ABE Processing phase\n+\n+      Record_Elaboration_Scenario (N);\n    end Find_Expanded_Name;\n \n    --------------------"}, {"sha": "199cd8a8c7a65778ae05e251faf1cf3162247517", "filename": "gcc/ada/sem_ch9.adb", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e491a7739dc2ae9a5b92945e4f0e48a3a91e39/gcc%2Fada%2Fsem_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e491a7739dc2ae9a5b92945e4f0e48a3a91e39/gcc%2Fada%2Fsem_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch9.adb?ref=90e491a7739dc2ae9a5b92945e4f0e48a3a91e39", "patch": "@@ -50,6 +50,7 @@ with Sem_Ch5;   use Sem_Ch5;\n with Sem_Ch6;   use Sem_Ch6;\n with Sem_Ch8;   use Sem_Ch8;\n with Sem_Ch13;  use Sem_Ch13;\n+with Sem_Elab;  use Sem_Elab;\n with Sem_Eval;  use Sem_Eval;\n with Sem_Prag;  use Sem_Prag;\n with Sem_Res;   use Sem_Res;\n@@ -1656,6 +1657,14 @@ package body Sem_Ch9 is\n          Set_SPARK_Pragma_Inherited (Def_Id);\n       end if;\n \n+      --  Preserve relevant elaboration-related attributes of the context which\n+      --  are no longer available or very expensive to recompute once analysis,\n+      --  resolution, and expansion are over.\n+\n+      Mark_Elaboration_Attributes\n+        (N_Id   => Def_Id,\n+         Checks => True);\n+\n       --  Process formals\n \n       if Present (Formals) then\n@@ -2281,6 +2290,15 @@ package body Sem_Ch9 is\n       Synch_Type  : Entity_Id;\n \n    begin\n+      --  Preserve relevant elaboration-related attributes of the context which\n+      --  are no longer available or very expensive to recompute once analysis,\n+      --  resolution, and expansion are over.\n+\n+      Mark_Elaboration_Attributes\n+        (N_Id   => N,\n+         Checks => True,\n+         Modes  => True);\n+\n       Tasking_Used := True;\n       Check_SPARK_05_Restriction (\"requeue statement is not allowed\", N);\n       Check_Restriction (No_Requeue_Statements, N);\n@@ -2553,6 +2571,12 @@ package body Sem_Ch9 is\n          Error_Msg_N\n            (\"target protected object of requeue must be a variable\", N);\n       end if;\n+\n+      --  A requeue statement is treated as a call for purposes of ABE checks\n+      --  and diagnostics. Annotate the tree by creating a call marker in case\n+      --  the requeue statement is transformed by expansion.\n+\n+      Build_Call_Marker (N);\n    end Analyze_Requeue;\n \n    ------------------------------\n@@ -2836,6 +2860,14 @@ package body Sem_Ch9 is\n       Set_SPARK_Pragma           (Obj_Id, SPARK_Mode_Pragma);\n       Set_SPARK_Pragma_Inherited (Obj_Id);\n \n+      --  Preserve relevant elaboration-related attributes of the context which\n+      --  are no longer available or very expensive to recompute once analysis,\n+      --  resolution, and expansion are over.\n+\n+      Mark_Elaboration_Attributes\n+        (N_Id   => Obj_Id,\n+         Checks => True);\n+\n       --  Instead of calling Analyze on the new node, call the proper analysis\n       --  procedure directly. Otherwise the node would be expanded twice, with\n       --  disastrous result.\n@@ -3099,6 +3131,14 @@ package body Sem_Ch9 is\n       Set_SPARK_Pragma_Inherited     (T);\n       Set_SPARK_Aux_Pragma_Inherited (T);\n \n+      --  Preserve relevant elaboration-related attributes of the context which\n+      --  are no longer available or very expensive to recompute once analysis,\n+      --  resolution, and expansion are over.\n+\n+      Mark_Elaboration_Attributes\n+        (N_Id   => T,\n+         Checks => True);\n+\n       Push_Scope (T);\n \n       if Ada_Version >= Ada_2005 then"}, {"sha": "47e9c99e36e286ff17e5acf3c2257c65b414c0de", "filename": "gcc/ada/sem_elab.adb", "status": "modified", "additions": 7307, "deletions": 3010, "changes": 10317, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e491a7739dc2ae9a5b92945e4f0e48a3a91e39/gcc%2Fada%2Fsem_elab.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e491a7739dc2ae9a5b92945e4f0e48a3a91e39/gcc%2Fada%2Fsem_elab.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_elab.adb?ref=90e491a7739dc2ae9a5b92945e4f0e48a3a91e39"}, {"sha": "ddcd43306b05e96f745c464c25397ec36491abdf", "filename": "gcc/ada/sem_elab.ads", "status": "modified", "additions": 83, "deletions": 148, "changes": 231, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e491a7739dc2ae9a5b92945e4f0e48a3a91e39/gcc%2Fada%2Fsem_elab.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e491a7739dc2ae9a5b92945e4f0e48a3a91e39/gcc%2Fada%2Fsem_elab.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_elab.ads?ref=90e491a7739dc2ae9a5b92945e4f0e48a3a91e39", "patch": "@@ -23,158 +23,93 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  This package contains the routines used to deal with issuing warnings\n---  for cases of calls that may require warnings about possible access\n---  before elaboration.\n+--  This package contains routines which handle access-before-elaboration\n+--  run-time checks and compile-time diagnostics. See the body for details.\n \n with Types; use Types;\n \n package Sem_Elab is\n \n-   -----------------------------\n-   -- Description of Approach --\n-   -----------------------------\n-\n-   --  Every non-static call that is encountered by Sem_Res results in a call\n-   --  to Check_Elab_Call, with N being the call node, and Outer set to its\n-   --  default value of True. In addition X'Access is treated like a call\n-   --  for the access-to-procedure case, and in SPARK mode only we also\n-   --  check variable references.\n-\n-   --  The goal of Check_Elab_Call is to determine whether or not the reference\n-   --  in question can generate an access before elaboration error (raising\n-   --  Program_Error) either by directly calling a subprogram whose body\n-   --  has not yet been elaborated, or indirectly, by calling a subprogram\n-   --  whose body has been elaborated, but which contains a call to such a\n-   --  subprogram.\n-\n-   --  In addition, in SPARK mode, we are checking for a variable reference in\n-   --  another package, which requires an explicit Elaborate_All pragma.\n-\n-   --  The only references that we need to look at the outer level are\n-   --  references that occur in elaboration code. There are two cases. The\n-   --  reference can be at the outer level of elaboration code, or it can\n-   --  be within another unit, e.g. the elaboration code of a subprogram.\n-\n-   --  In the case of an elaboration call at the outer level, we must trace\n-   --  all calls to outer level routines either within the current unit or to\n-   --  other units that are with'ed. For calls within the current unit, we can\n-   --  determine if the body has been elaborated or not, and if it has not,\n-   --  then a warning is generated.\n-\n-   --  Note that there are two subcases. If the original call directly calls a\n-   --  subprogram whose body has not been elaborated, then we know that an ABE\n-   --  will take place, and we replace the call by a raise of Program_Error.\n-   --  If the call is indirect, then we don't know that the PE will be raised,\n-   --  since the call might be guarded by a conditional. In this case we set\n-   --  Do_Elab_Check on the call so that a dynamic check is generated, and\n-   --  output a warning.\n-\n-   --  For calls to a subprogram in a with'ed unit or a 'Access or variable\n-   --  reference (SPARK mode case), we require that a pragma Elaborate_All\n-   --  or pragma Elaborate be present, or that the referenced unit have a\n-   --  pragma Preelaborate, pragma Pure, or pragma Elaborate_Body. If none\n-   --  of these conditions is met, then a warning is generated that a pragma\n-   --  Elaborate_All may be needed (error in the SPARK case), or an implicit\n-   --  pragma is generated.\n-\n-   --  For the case of an elaboration call at some inner level, we are\n-   --  interested in tracing only calls to subprograms at the same level,\n-   --  i.e. those that can be called during elaboration. Any calls to\n-   --  outer level routines cannot cause ABE's as a result of the original\n-   --  call (there might be an outer level call to the subprogram from\n-   --  outside that causes the ABE, but that gets analyzed separately).\n-\n-   --  Note that we never trace calls to inner level subprograms, since\n-   --  these cannot result in ABE's unless there is an elaboration problem\n-   --  at a lower level, which will be separately detected.\n-\n-   --  Note on pragma Elaborate. The checking here assumes that a pragma\n-   --  Elaborate on a with'ed unit guarantees that subprograms within the\n-   --  unit can be called without causing an ABE. This is not in fact the\n-   --  case since pragma Elaborate does not guarantee the transitive\n-   --  coverage guaranteed by Elaborate_All. However, we decide to trust\n-   --  the user in this case.\n-\n-   --------------------------------------\n-   -- Instantiation Elaboration Errors --\n-   --------------------------------------\n-\n-   --  A special case arises when an instantiation appears in a context\n-   --  that is known to be before the body is elaborated, e.g.\n-\n-   --       generic package x is ...\n-   --       ...\n-   --       package xx is new x;\n-   --       ...\n-   --       package body x is ...\n-\n-   --  In this situation it is certain that an elaboration error will\n-   --  occur, and an unconditional raise Program_Error statement is\n-   --  inserted before the instantiation, and a warning generated.\n-\n-   --  The problem is that in this case we have no place to put the\n-   --  body of the instantiation. We can't put it in the normal place,\n-   --  because it is too early, and will cause errors to occur as a\n-   --  result of referencing entities before they are declared.\n-\n-   --  Our approach in this case is simply to avoid creating the body\n-   --  of the instantiation in such a case. The instantiation spec is\n-   --  modified to include dummy bodies for all subprograms, so that\n-   --  the resulting code does not contain subprogram specs with no\n-   --  corresponding bodies.\n-\n-   procedure Check_Elab_Call\n-     (N            : Node_Id;\n-      Outer_Scope  : Entity_Id := Empty;\n-      In_Init_Proc : Boolean   := False);\n-   --  Check a call for possible elaboration problems. The node N is either an\n-   --  N_Function_Call or N_Procedure_Call_Statement node or an access\n-   --  attribute reference whose prefix is a subprogram.\n-   --\n-   --  If SPARK_Mode is On, then N can also be a variable reference, since\n-   --  SPARK requires the use of Elaborate_All for references to variables\n-   --  in other packages.\n-\n-   --  The Outer_Scope argument indicates whether this is an outer level\n-   --  call from Sem_Res (Outer_Scope set to Empty), or an internal recursive\n-   --  call (Outer_Scope set to entity of outermost call, see body). The flag\n-   --  In_Init_Proc should be set whenever the current context is a type\n-   --  init proc.\n-\n-   --  Note: this might better be called Check_Elab_Reference (to recognize\n-   --  the SPARK case), but we prefer to keep the original name, since this\n-   --  is primarily used for checking for calls that could generate an ABE).\n-\n-   procedure Check_Elab_Calls;\n-   --  Not all the processing for Check_Elab_Call can be done at the time\n-   --  of calls to Check_Elab_Call. This is because for internal calls, we\n-   --  need to wait to complete the check until all generic bodies have been\n-   --  instantiated. The Check_Elab_Calls procedure cleans up these waiting\n-   --  checks. It is called once after the completion of instantiation.\n-\n-   procedure Check_Elab_Assign (N : Node_Id);\n-   --  N is either the left side of an assignment, or a procedure argument for\n-   --  a mode OUT or IN OUT formal. This procedure checks for a possible case\n-   --  of access to an entity from elaboration code before the entity has been\n-   --  initialized, and issues appropriate warnings.\n-\n-   procedure Check_Elab_Instantiation\n-     (N           : Node_Id;\n-      Outer_Scope : Entity_Id := Empty);\n-   --  Check an instantiation for possible elaboration problems. N is an\n-   --  instantiation node (N_Package_Instantiation, N_Function_Instantiation,\n-   --  or N_Procedure_Instantiation), and Outer_Scope indicates if this is\n-   --  an outer level call from Sem_Ch12 (Outer_Scope set to Empty), or an\n-   --  internal recursive call (Outer_Scope set to scope of outermost call,\n-   --  see body for further details). The returned value is relevant only\n-   --  for an outer level call, and is set to False if an elaboration error\n-   --  is bound to occur on the instantiation, and True otherwise. This is\n-   --  used by the caller to signal that the body of the instance should\n-   --  not be generated (see detailed description in body).\n-\n-   procedure Check_Task_Activation (N : Node_Id);\n-   --  At the point at which tasks are activated in a package body, check\n-   --  that the bodies of the tasks are elaborated.\n+   procedure Build_Call_Marker (N : Node_Id);\n+   --  Create a call marker for call or requeue statement N and record it for\n+   --  later processing by the ABE mechanism.\n+\n+   procedure Check_Elaboration_Scenarios;\n+   --  Examine each scenario recorded during analysis/resolution and apply the\n+   --  Ada or SPARK elaboration rules taking into account the model in effect.\n+   --  This processing detects and diagnoses ABE issues, installs conditional\n+   --  ABE checks or guaranteed ABE failures, and ensures the elaboration of\n+   --  units.\n+\n+   --  The following type classifies the various enclosing levels used in ABE\n+   --  diagnostics.\n+\n+   type Enclosing_Level_Kind is\n+     (Declaration_Level,\n+      --  A construct is at the \"declaration level\" when it appears within the\n+      --  declarations of a block statement, an entry body, a subprogram body,\n+      --  or a task body, ignoring enclosing packages. Example:\n+\n+      --    package Pack is\n+      --       procedure Proc is                 --  subprogram body\n+      --          package Nested is              --  enclosing package ignored\n+      --             X ...                       --  at declaration level\n+\n+      Generic_Package_Spec,\n+      Generic_Package_Body,\n+      --  A construct is at the \"generic library level\" when it appears in a\n+      --  generic package library unit, ignoring enclosing packages. Example:\n+\n+      --    generic\n+      --    package Pack is                      --  generic package spec\n+      --       package Nested is                 --  enclosing package ignored\n+      --          X ...                          --  at generic library level\n+\n+      Instantiation,\n+      --  A construct is at the \"instantiation library level\" when it appears\n+      --  in a library unit which is also an instantiation. Example:\n+\n+      --    package Inst is new Gen;             --  at instantiation level\n+\n+      Package_Spec,\n+      Package_Body,\n+      --  A construct is at the \"library level\" when it appears in a package\n+      --  library unit, ignoring enclosing packages. Example:\n+\n+      --    package body Pack is                 --  package body\n+      --       package Nested is                 --  enclosing package ignored\n+      --          X ...                          --  at library level\n+\n+      No_Level);\n+      --  This value is used to indicate that none of the levels above are in\n+      --  effect.\n+\n+   subtype Generic_Library_Level is Enclosing_Level_Kind range\n+     Generic_Package_Spec ..\n+     Generic_Package_Body;\n+\n+   subtype Library_Level is Enclosing_Level_Kind range\n+     Package_Spec ..\n+     Package_Body;\n+\n+   subtype Any_Library_Level is Enclosing_Level_Kind range\n+     Generic_Package_Spec ..\n+     Package_Body;\n+\n+   function Find_Enclosing_Level (N : Node_Id) return Enclosing_Level_Kind;\n+   --  Determine the enclosing level of arbitrary node N\n+\n+   procedure Initialize;\n+   --  Initialize the internal structures of this unit\n+\n+   procedure Kill_Elaboration_Scenario (N : Node_Id);\n+   --  Determine whether arbitrary node N denotes a scenario which requires\n+   --  ABE diagnostics or runtime checks and eliminate it from a region with\n+   --  dead code.\n+\n+   procedure Record_Elaboration_Scenario (N : Node_Id);\n+   --  Determine whether atribtray node N denotes a scenario which requires\n+   --  ABE diagnostics or runtime checks. If this is the case, store N into\n+   --  a table for later processing.\n \n end Sem_Elab;"}, {"sha": "0456101092a809a48e2f2a71ff061830d4e8228a", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 6, "deletions": 56, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e491a7739dc2ae9a5b92945e4f0e48a3a91e39/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e491a7739dc2ae9a5b92945e4f0e48a3a91e39/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=90e491a7739dc2ae9a5b92945e4f0e48a3a91e39", "patch": "@@ -14384,12 +14384,11 @@ package body Sem_Prag is\n                Call := Get_Pragma_Arg (Arg1);\n             end if;\n \n-            if Nkind_In (Call,\n-                 N_Indexed_Component,\n-                 N_Function_Call,\n-                 N_Identifier,\n-                 N_Expanded_Name,\n-                 N_Selected_Component)\n+            if Nkind_In (Call, N_Expanded_Name,\n+                               N_Function_Call,\n+                               N_Identifier,\n+                               N_Indexed_Component,\n+                               N_Selected_Component)\n             then\n                --  If this pragma Debug comes from source, its argument was\n                --  parsed as a name form (which is syntactically identical).\n@@ -14999,26 +14998,6 @@ package body Sem_Prag is\n                      Set_Elaborate_Present (Citem, True);\n                      Set_Elab_Unit_Name (Get_Pragma_Arg (Arg), Name (Citem));\n \n-                     --  With the pragma present, elaboration calls on\n-                     --  subprograms from the named unit need no further\n-                     --  checks, as long as the pragma appears in the current\n-                     --  compilation unit. If the pragma appears in some unit\n-                     --  in the context, there might still be a need for an\n-                     --  Elaborate_All_Desirable from the current compilation\n-                     --  to the named unit, so we keep the check enabled.\n-\n-                     if In_Extended_Main_Source_Unit (N) then\n-\n-                        --  This does not apply in SPARK mode, where we allow\n-                        --  pragma Elaborate, but we don't trust it to be right\n-                        --  so we will still insist on the Elaborate_All.\n-\n-                        if SPARK_Mode /= On then\n-                           Set_Suppress_Elaboration_Warnings\n-                             (Entity (Name (Citem)));\n-                        end if;\n-                     end if;\n-\n                      exit Inner;\n                   end if;\n \n@@ -15096,14 +15075,6 @@ package body Sem_Prag is\n                      Set_Elaborate_All_Present (Citem, True);\n                      Set_Elab_Unit_Name (Get_Pragma_Arg (Arg), Name (Citem));\n \n-                     --  Suppress warnings and elaboration checks on the named\n-                     --  unit if the pragma is in the current compilation, as\n-                     --  for pragma Elaborate.\n-\n-                     if In_Extended_Main_Source_Unit (N) then\n-                        Set_Suppress_Elaboration_Warnings\n-                          (Entity (Name (Citem)));\n-                     end if;\n                      exit Innr;\n                   end if;\n \n@@ -15151,27 +15122,8 @@ package body Sem_Prag is\n             then\n                Error_Pragma (\"pragma% must refer to a spec, not a body\");\n             else\n-               Set_Body_Required (Cunit_Node, True);\n+               Set_Body_Required (Cunit_Node);\n                Set_Has_Pragma_Elaborate_Body (Cunit_Ent);\n-\n-               --  If we are in dynamic elaboration mode, then we suppress\n-               --  elaboration warnings for the unit, since it is definitely\n-               --  fine NOT to do dynamic checks at the first level (and such\n-               --  checks will be suppressed because no elaboration boolean\n-               --  is created for Elaborate_Body packages).\n-\n-               --  But in the static model of elaboration, Elaborate_Body is\n-               --  definitely NOT good enough to ensure elaboration safety on\n-               --  its own, since the body may WITH other units that are not\n-               --  safe from an elaboration point of view, so a client must\n-               --  still do an Elaborate_All on such units.\n-\n-               --  Debug flag -gnatdD restores the old behavior of 3.13, where\n-               --  Elaborate_Body always suppressed elab warnings.\n-\n-               if Dynamic_Elaboration_Checks or Debug_Flag_DD then\n-                  Set_Suppress_Elaboration_Warnings (Cunit_Ent);\n-               end if;\n             end if;\n          end Elaborate_Body;\n \n@@ -20249,7 +20201,6 @@ package body Sem_Prag is\n                else\n                   if not Debug_Flag_U then\n                      Set_Is_Preelaborated (Ent);\n-                     Set_Suppress_Elaboration_Warnings (Ent);\n                   end if;\n                end if;\n             end if;\n@@ -20877,7 +20828,6 @@ package body Sem_Prag is\n             if not Debug_Flag_U then\n                Set_Is_Pure (Ent);\n                Set_Has_Pragma_Pure (Ent);\n-               Set_Suppress_Elaboration_Warnings (Ent);\n             end if;\n          end Pure;\n "}, {"sha": "0722e3742f70eb460d8428364c58ba78e1b95508", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 73, "deletions": 42, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e491a7739dc2ae9a5b92945e4f0e48a3a91e39/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e491a7739dc2ae9a5b92945e4f0e48a3a91e39/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=90e491a7739dc2ae9a5b92945e4f0e48a3a91e39", "patch": "@@ -63,8 +63,8 @@ with Sem_Ch13; use Sem_Ch13;\n with Sem_Dim;  use Sem_Dim;\n with Sem_Disp; use Sem_Disp;\n with Sem_Dist; use Sem_Dist;\n-with Sem_Elim; use Sem_Elim;\n with Sem_Elab; use Sem_Elab;\n+with Sem_Elim; use Sem_Elim;\n with Sem_Eval; use Sem_Eval;\n with Sem_Intr; use Sem_Intr;\n with Sem_Util; use Sem_Util;\n@@ -1325,6 +1325,12 @@ package body Sem_Res is\n    begin\n       Op_Node := New_Node (Operator_Kind (Op_Name, Is_Binary), Sloc (N));\n \n+      --  Ensure that the corresponding operator has the same parent as the\n+      --  original call. This guarantees that parent traversals performed by\n+      --  the ABE mechanism succeed.\n+\n+      Set_Parent (Op_Node, Parent (N));\n+\n       --  Binary operator\n \n       if Is_Binary then\n@@ -5785,6 +5791,15 @@ package body Sem_Res is\n    --  Start of processing for Resolve_Call\n \n    begin\n+      --  Preserve relevant elaboration-related attributes of the context which\n+      --  are no longer available or very expensive to recompute once analysis,\n+      --  resolution, and expansion are over.\n+\n+      Mark_Elaboration_Attributes\n+        (N_Id   => N,\n+         Checks => True,\n+         Modes  => True);\n+\n       --  The context imposes a unique interpretation with type Typ on a\n       --  procedure or function call. Find the entity of the subprogram that\n       --  yields the expected type, and propagate the corresponding formal\n@@ -5841,10 +5856,15 @@ package body Sem_Res is\n \n       elsif Nkind_In (Subp, N_Selected_Component, N_Indexed_Component)\n         or else (Is_Entity_Name (Subp)\n-                  and then Ekind (Entity (Subp)) = E_Entry)\n+                  and then Ekind_In (Entity (Subp), E_Entry, E_Entry_Family))\n       then\n          Resolve_Entry_Call (N, Typ);\n-         Check_Elab_Call (N);\n+\n+         --  Annotate the tree by creating a call marker in case the original\n+         --  call is transformed by expansion. The call marker is automatically\n+         --  saved for later examination by the ABE Processing phase.\n+\n+         Build_Call_Marker (N);\n \n          --  Kill checks and constant values, as above for indirect case\n          --  Who knows what happens when another task is activated?\n@@ -6100,14 +6120,14 @@ package body Sem_Res is\n                      --  the proper indexed component.\n \n                      Index_Node :=\n-                        Make_Indexed_Component (Loc,\n-                          Prefix       =>\n-                            Make_Function_Call (Loc,\n-                               Name                   => New_Subp,\n-                               Parameter_Associations =>\n-                                 New_List\n-                                   (Remove_Head (Parameter_Associations (N)))),\n-                           Expressions => Parameter_Associations (N));\n+                       Make_Indexed_Component (Loc,\n+                         Prefix      =>\n+                           Make_Function_Call (Loc,\n+                             Name                   => New_Subp,\n+                             Parameter_Associations =>\n+                               New_List\n+                                 (Remove_Head (Parameter_Associations (N)))),\n+                         Expressions => Parameter_Associations (N));\n                   end if;\n \n                   --  Preserve the parenthesis count of the node\n@@ -6122,7 +6142,13 @@ package body Sem_Res is\n                   Set_Etype (Prefix (N), Ret_Type);\n                   Set_Etype (N, Typ);\n                   Resolve_Indexed_Component (N, Typ);\n-                  Check_Elab_Call (Prefix (N));\n+\n+                  --  Annotate the tree by creating a call marker in case\n+                  --  the original call is transformed by expansion. The call\n+                  --  marker is automatically saved for later examination by\n+                  --  the ABE Processing phase.\n+\n+                  Build_Call_Marker (Prefix (N));\n                end if;\n             end if;\n \n@@ -6633,7 +6659,12 @@ package body Sem_Res is\n       --  All done, evaluate call and deal with elaboration issues\n \n       Eval_Call (N);\n-      Check_Elab_Call (N);\n+\n+      --  Annotate the tree by creating a call marker in case the original call\n+      --  is transformed by expansion. The call marker is automatically saved\n+      --  for later examination by the ABE Processing phase.\n+\n+      Build_Call_Marker (N);\n \n       --  In GNATprove mode, expansion is disabled, but we want to inline some\n       --  subprograms to facilitate formal verification. Indirect calls through\n@@ -7176,7 +7207,7 @@ package body Sem_Res is\n \n          else\n             Error_Msg_N\n-               (\"invalid use of subtype mark in expression or call\", N);\n+              (\"invalid use of subtype mark in expression or call\", N);\n          end if;\n \n       --  Check discriminant use if entity is discriminant in current scope,\n@@ -7269,17 +7300,6 @@ package body Sem_Res is\n                   & \"(SPARK RM 7.1.3(12))\", N);\n             end if;\n \n-            --  Check for possible elaboration issues with respect to reads of\n-            --  variables. The act of renaming the variable is not considered a\n-            --  read as it simply establishes an alias.\n-\n-            if Ekind (E) = E_Variable\n-              and then Dynamic_Elaboration_Checks\n-              and then Nkind (Par) /= N_Object_Renaming_Declaration\n-            then\n-               Check_Elab_Call (N);\n-            end if;\n-\n             --  The variable may eventually become a constituent of a single\n             --  protected/task type. Record the reference now and verify its\n             --  legality when analyzing the contract of the variable\n@@ -7524,14 +7544,13 @@ package body Sem_Res is\n    ------------------------\n \n    procedure Resolve_Entry_Call (N : Node_Id; Typ : Entity_Id) is\n-      Entry_Name  : constant Node_Id    := Name (N);\n-      Loc         : constant Source_Ptr := Sloc (Entry_Name);\n-      Actuals     : List_Id;\n-      First_Named : Node_Id;\n-      Nam         : Entity_Id;\n-      Norm_OK     : Boolean;\n-      Obj         : Node_Id;\n-      Was_Over    : Boolean;\n+      Entry_Name : constant Node_Id    := Name (N);\n+      Loc        : constant Source_Ptr := Sloc (Entry_Name);\n+\n+      Nam      : Entity_Id;\n+      Norm_OK  : Boolean;\n+      Obj      : Node_Id;\n+      Was_Over : Boolean;\n \n    begin\n       --  We kill all checks here, because it does not seem worth the effort to\n@@ -7645,7 +7664,6 @@ package body Sem_Res is\n         and then Present (Contract_Wrapper (Nam))\n         and then Current_Scope /= Contract_Wrapper (Nam)\n       then\n-\n          --  Note the entity being called before rewriting the call, so that\n          --  it appears used at this point.\n \n@@ -7760,16 +7778,29 @@ package body Sem_Res is\n                Entry_Name);\n          end if;\n \n-         Actuals := Parameter_Associations (N);\n-         First_Named := First_Named_Actual (N);\n+         declare\n+            Entry_Call : Node_Id;\n+\n+         begin\n+            Entry_Call :=\n+              Make_Entry_Call_Statement (Loc,\n+                Name                   => Entry_Name,\n+                Parameter_Associations => Parameter_Associations (N));\n \n-         Rewrite (N,\n-           Make_Entry_Call_Statement (Loc,\n-             Name                   => Entry_Name,\n-             Parameter_Associations => Actuals));\n+            --  Inherit relevant attributes from the original call\n \n-         Set_First_Named_Actual (N, First_Named);\n-         Set_Analyzed (N, True);\n+            Set_First_Named_Actual\n+              (Entry_Call, First_Named_Actual (N));\n+\n+            Set_Is_Elaboration_Checks_OK_Node\n+              (Entry_Call, Is_Elaboration_Checks_OK_Node (N));\n+\n+            Set_Is_SPARK_Mode_On_Node\n+              (Entry_Call, Is_SPARK_Mode_On_Node (N));\n+\n+            Rewrite (N, Entry_Call);\n+            Set_Analyzed (N, True);\n+         end;\n \n       --  Protected functions can return on the secondary stack, in which\n       --  case we must trigger the transient scope mechanism."}, {"sha": "fa9c19927a44a09dfc32998dfadd92e5e3aac766", "filename": "gcc/ada/sem_spark.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e491a7739dc2ae9a5b92945e4f0e48a3a91e39/gcc%2Fada%2Fsem_spark.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e491a7739dc2ae9a5b92945e4f0e48a3a91e39/gcc%2Fada%2Fsem_spark.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_spark.adb?ref=90e491a7739dc2ae9a5b92945e4f0e48a3a91e39", "patch": "@@ -2314,6 +2314,7 @@ package body Sem_SPARK is\n          when N_Abstract_Subprogram_Declaration\n             | N_At_Clause\n             | N_Attribute_Definition_Clause\n+            | N_Call_Marker\n             | N_Delta_Constraint\n             | N_Digits_Constraint\n             | N_Empty"}, {"sha": "0ae717cfccded38f0eb9b14e8c997dcd647d2a79", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 783, "deletions": 325, "changes": 1108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e491a7739dc2ae9a5b92945e4f0e48a3a91e39/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e491a7739dc2ae9a5b92945e4f0e48a3a91e39/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=90e491a7739dc2ae9a5b92945e4f0e48a3a91e39", "patch": "@@ -53,6 +53,7 @@ with Sem_Attr; use Sem_Attr;\n with Sem_Ch6;  use Sem_Ch6;\n with Sem_Ch8;  use Sem_Ch8;\n with Sem_Disp; use Sem_Disp;\n+with Sem_Elab; use Sem_Elab;\n with Sem_Eval; use Sem_Eval;\n with Sem_Prag; use Sem_Prag;\n with Sem_Res;  use Sem_Res;\n@@ -941,6 +942,45 @@ package body Sem_Util is\n         and then not In_Same_Extended_Unit (N, T);\n    end Bad_Unordered_Enumeration_Reference;\n \n+   ----------------------------\n+   -- Begin_Keyword_Location --\n+   ----------------------------\n+\n+   function Begin_Keyword_Location (N : Node_Id) return Source_Ptr is\n+      HSS : Node_Id;\n+\n+   begin\n+      pragma Assert (Nkind_In (N, N_Block_Statement,\n+                                  N_Entry_Body,\n+                                  N_Package_Body,\n+                                  N_Subprogram_Body,\n+                                  N_Task_Body));\n+\n+      HSS := Handled_Statement_Sequence (N);\n+\n+      --  When the handled sequence of statements comes from source, the\n+      --  location of the \"begin\" keyword is that of the sequence itself.\n+      --  Note that an internal construct may inherit a source sequence.\n+\n+      if Comes_From_Source (HSS) then\n+         return Sloc (HSS);\n+\n+      --  The parser generates an internal handled sequence of statements to\n+      --  capture the location of the \"begin\" keyword if present in the source.\n+      --  Since there are no source statements, the location of the \"begin\"\n+      --  keyword is effectively that of the \"end\" keyword.\n+\n+      elsif Comes_From_Source (N) then\n+         return Sloc (HSS);\n+\n+      --  Otherwise the construct is internal and should carry the location of\n+      --  the original construct which prompted its creation.\n+\n+      else\n+         return Sloc (N);\n+      end if;\n+   end Begin_Keyword_Location;\n+\n    --------------------------\n    -- Build_Actual_Subtype --\n    --------------------------\n@@ -5760,11 +5800,10 @@ package body Sem_Util is\n    ---------------------\n \n    function Defining_Entity\n-     (N               : Node_Id;\n-      Empty_On_Errors : Boolean := False) return Entity_Id\n+     (N                  : Node_Id;\n+      Empty_On_Errors    : Boolean := False;\n+      Concurrent_Subunit : Boolean := False) return Entity_Id\n    is\n-      Err : Entity_Id := Empty;\n-\n    begin\n       case Nkind (N) is\n          when N_Abstract_Subprogram_Declaration\n@@ -5816,7 +5855,23 @@ package body Sem_Util is\n             return Defining_Identifier (N);\n \n          when N_Subunit =>\n-            return Defining_Entity (Proper_Body (N));\n+            declare\n+               Bod      : constant Node_Id := Proper_Body (N);\n+               Orig_Bod : constant Node_Id := Original_Node (Bod);\n+\n+            begin\n+               --  Retrieve the entity of the original protected or task body\n+               --  if requested by the caller.\n+\n+               if Concurrent_Subunit\n+                 and then Nkind (Bod) = N_Null_Statement\n+                 and then Nkind_In (Orig_Bod, N_Protected_Body, N_Task_Body)\n+               then\n+                  return Defining_Entity (Orig_Bod);\n+               else\n+                  return Defining_Entity (Bod);\n+               end if;\n+            end;\n \n          when N_Function_Instantiation\n             | N_Function_Specification\n@@ -5832,6 +5887,7 @@ package body Sem_Util is\n          =>\n             declare\n                Nam : constant Node_Id := Defining_Unit_Name (N);\n+               Err : Entity_Id := Empty;\n \n             begin\n                if Nkind (Nam) in N_Entity then\n@@ -6862,6 +6918,82 @@ package body Sem_Util is\n       end if;\n    end Enclosing_Subprogram;\n \n+   --------------------------\n+   -- End_Keyword_Location --\n+   --------------------------\n+\n+   function End_Keyword_Location (N : Node_Id) return Source_Ptr is\n+      function End_Label_Loc (Nod : Node_Id) return Source_Ptr;\n+      --  Return the source location of Nod's end label according to the\n+      --  following precedence rules:\n+      --\n+      --    1) If the end label exists, return its location\n+      --    2) If Nod exists, return its location\n+      --    3) Return the location of N\n+\n+      -------------------\n+      -- End_Label_Loc --\n+      -------------------\n+\n+      function End_Label_Loc (Nod : Node_Id) return Source_Ptr is\n+         Label : Node_Id;\n+\n+      begin\n+         if Present (Nod) then\n+            Label := End_Label (Nod);\n+\n+            if Present (Label) then\n+               return Sloc (Label);\n+            else\n+               return Sloc (Nod);\n+            end if;\n+\n+         else\n+            return Sloc (N);\n+         end if;\n+      end End_Label_Loc;\n+\n+      --  Local variables\n+\n+      Owner : Node_Id;\n+\n+   --  Start of processing for End_Keyword_Location\n+\n+   begin\n+      if Nkind_In (N, N_Block_Statement,\n+                      N_Entry_Body,\n+                      N_Package_Body,\n+                      N_Subprogram_Body,\n+                      N_Task_Body)\n+      then\n+         Owner := Handled_Statement_Sequence (N);\n+\n+      elsif Nkind (N) = N_Package_Declaration then\n+         Owner := Specification (N);\n+\n+      elsif Nkind (N) = N_Protected_Body then\n+         Owner := N;\n+\n+      elsif Nkind_In (N, N_Protected_Type_Declaration,\n+                         N_Single_Protected_Declaration)\n+      then\n+         Owner := Protected_Definition (N);\n+\n+      elsif Nkind_In (N, N_Single_Task_Declaration,\n+                         N_Task_Type_Declaration)\n+      then\n+         Owner := Task_Definition (N);\n+\n+      --  This routine should not be called with other contexts\n+\n+      else\n+         pragma Assert (False);\n+         null;\n+      end if;\n+\n+      return End_Label_Loc (Owner);\n+   end End_Keyword_Location;\n+\n    ------------------------\n    -- Ensure_Freeze_Node --\n    ------------------------\n@@ -7735,6 +7867,93 @@ package body Sem_Util is\n       return Empty;\n    end Find_Enclosing_Iterator_Loop;\n \n+   --------------------------\n+   -- Find_Enclosing_Scope --\n+   --------------------------\n+\n+   function Find_Enclosing_Scope (N : Node_Id) return Entity_Id is\n+      Par     : Node_Id;\n+      Spec_Id : Entity_Id;\n+\n+   begin\n+      --  Examine the parent chain looking for a construct which defines a\n+      --  scope.\n+\n+      Par := Parent (N);\n+      while Present (Par) loop\n+         case Nkind (Par) is\n+\n+            --  The construct denotes a declaration, the proper scope is its\n+            --  entity.\n+\n+            when N_Entry_Declaration\n+               | N_Expression_Function\n+               | N_Full_Type_Declaration\n+               | N_Generic_Package_Declaration\n+               | N_Generic_Subprogram_Declaration\n+               | N_Package_Declaration\n+               | N_Private_Extension_Declaration\n+               | N_Protected_Type_Declaration\n+               | N_Single_Protected_Declaration\n+               | N_Single_Task_Declaration\n+               | N_Subprogram_Declaration\n+               | N_Task_Type_Declaration\n+            =>\n+               return Defining_Entity (Par);\n+\n+            --  The construct denotes a body, the proper scope is the entity of\n+            --  the corresponding spec.\n+\n+            when N_Entry_Body\n+               | N_Package_Body\n+               | N_Protected_Body\n+               | N_Subprogram_Body\n+               | N_Task_Body\n+            =>\n+               Spec_Id := Corresponding_Spec (Par);\n+\n+               --  The defining entity of a stand-alone subprogram body defines\n+               --  a scope.\n+\n+               if Nkind (Par) = N_Subprogram_Body and then No (Spec_Id) then\n+                  return Defining_Entity (Par);\n+\n+               --  Otherwise there should be corresponding spec which defines a\n+               --  scope.\n+\n+               else\n+                  pragma Assert (Present (Spec_Id));\n+\n+                  return Spec_Id;\n+               end if;\n+\n+            --  Special cases\n+\n+            --  Blocks, loops, and return statements have artificial scopes\n+\n+            when N_Block_Statement\n+               | N_Loop_Statement\n+            =>\n+               return Entity (Identifier (Par));\n+\n+            when N_Extended_Return_Statement =>\n+               return Return_Statement_Entity (Par);\n+\n+            --  A traversal from a subunit continues via the corresponding stub\n+\n+            when N_Subunit =>\n+               Par := Corresponding_Stub (Par);\n+\n+            when others =>\n+               null;\n+         end case;\n+\n+         Par := Parent (Par);\n+      end loop;\n+\n+      return Standard_Standard;\n+   end Find_Enclosing_Scope;\n+\n    ------------------------------------\n    -- Find_Loop_In_Conditional_Block --\n    ------------------------------------\n@@ -9393,7 +9612,7 @@ package body Sem_Util is\n    -- Get_Task_Body_Procedure --\n    -----------------------------\n \n-   function Get_Task_Body_Procedure (E : Entity_Id) return Node_Id is\n+   function Get_Task_Body_Procedure (E : Entity_Id) return Entity_Id is\n    begin\n       --  Note: A task type may be the completion of a private type with\n       --  discriminants. When performing elaboration checks on a task\n@@ -10523,12 +10742,14 @@ package body Sem_Util is\n    -- Has_Non_Trivial_Precondition --\n    ----------------------------------\n \n-   function Has_Non_Trivial_Precondition (P : Entity_Id) return Boolean is\n-      Cont : constant Node_Id := Find_Aspect (P, Aspect_Pre);\n+   function Has_Non_Trivial_Precondition (Subp : Entity_Id) return Boolean is\n+      Pre : constant Node_Id := Find_Aspect (Subp, Aspect_Pre);\n+\n    begin\n-      return Present (Cont)\n-        and then Class_Present (Cont)\n-        and then not Is_Entity_Name (Expression (Cont));\n+      return\n+        Present (Pre)\n+          and then Class_Present (Pre)\n+          and then not Is_Entity_Name (Expression (Pre));\n    end Has_Non_Trivial_Precondition;\n \n    -------------------\n@@ -10769,160 +10990,6 @@ package body Sem_Util is\n          Ent : Entity_Id;\n          Exp : Node_Id;\n \n-         function Is_Preelaborable_Expression (N : Node_Id) return Boolean;\n-         --  Returns True if and only if the expression denoted by N does not\n-         --  violate restrictions on preelaborable constructs (RM-10.2.1(5-9)).\n-\n-         ---------------------------------\n-         -- Is_Preelaborable_Expression --\n-         ---------------------------------\n-\n-         function Is_Preelaborable_Expression (N : Node_Id) return Boolean is\n-            Exp           : Node_Id;\n-            Assn          : Node_Id;\n-            Choice        : Node_Id;\n-            Comp_Type     : Entity_Id;\n-            Is_Array_Aggr : Boolean;\n-\n-         begin\n-            if Is_OK_Static_Expression (N) then\n-               return True;\n-\n-            elsif Nkind (N) = N_Null then\n-               return True;\n-\n-            --  Attributes are allowed in general, even if their prefix is a\n-            --  formal type. (It seems that certain attributes known not to be\n-            --  static might not be allowed, but there are no rules to prevent\n-            --  them.)\n-\n-            elsif Nkind (N) = N_Attribute_Reference then\n-               return True;\n-\n-            --  The name of a discriminant evaluated within its parent type is\n-            --  defined to be preelaborable (10.2.1(8)). Note that we test for\n-            --  names that denote discriminals as well as discriminants to\n-            --  catch references occurring within init procs.\n-\n-            elsif Is_Entity_Name (N)\n-              and then\n-                (Ekind (Entity (N)) = E_Discriminant\n-                  or else (Ekind_In (Entity (N), E_Constant, E_In_Parameter)\n-                            and then Present (Discriminal_Link (Entity (N)))))\n-            then\n-               return True;\n-\n-            elsif Nkind (N) = N_Qualified_Expression then\n-               return Is_Preelaborable_Expression (Expression (N));\n-\n-            --  For aggregates we have to check that each of the associations\n-            --  is preelaborable.\n-\n-            elsif Nkind_In (N, N_Aggregate, N_Extension_Aggregate) then\n-               Is_Array_Aggr := Is_Array_Type (Etype (N));\n-\n-               if Is_Array_Aggr then\n-                  Comp_Type := Component_Type (Etype (N));\n-               end if;\n-\n-               --  Check the ancestor part of extension aggregates, which must\n-               --  be either the name of a type that has preelaborable init or\n-               --  an expression that is preelaborable.\n-\n-               if Nkind (N) = N_Extension_Aggregate then\n-                  declare\n-                     Anc_Part : constant Node_Id := Ancestor_Part (N);\n-\n-                  begin\n-                     if Is_Entity_Name (Anc_Part)\n-                       and then Is_Type (Entity (Anc_Part))\n-                     then\n-                        if not Has_Preelaborable_Initialization\n-                                 (Entity (Anc_Part))\n-                        then\n-                           return False;\n-                        end if;\n-\n-                     elsif not Is_Preelaborable_Expression (Anc_Part) then\n-                        return False;\n-                     end if;\n-                  end;\n-               end if;\n-\n-               --  Check positional associations\n-\n-               Exp := First (Expressions (N));\n-               while Present (Exp) loop\n-                  if not Is_Preelaborable_Expression (Exp) then\n-                     return False;\n-                  end if;\n-\n-                  Next (Exp);\n-               end loop;\n-\n-               --  Check named associations\n-\n-               Assn := First (Component_Associations (N));\n-               while Present (Assn) loop\n-                  Choice := First (Choices (Assn));\n-                  while Present (Choice) loop\n-                     if Is_Array_Aggr then\n-                        if Nkind (Choice) = N_Others_Choice then\n-                           null;\n-\n-                        elsif Nkind (Choice) = N_Range then\n-                           if not Is_OK_Static_Range (Choice) then\n-                              return False;\n-                           end if;\n-\n-                        elsif not Is_OK_Static_Expression (Choice) then\n-                           return False;\n-                        end if;\n-\n-                     else\n-                        Comp_Type := Etype (Choice);\n-                     end if;\n-\n-                     Next (Choice);\n-                  end loop;\n-\n-                  --  If the association has a <> at this point, then we have\n-                  --  to check whether the component's type has preelaborable\n-                  --  initialization. Note that this only occurs when the\n-                  --  association's corresponding component does not have a\n-                  --  default expression, the latter case having already been\n-                  --  expanded as an expression for the association.\n-\n-                  if Box_Present (Assn) then\n-                     if not Has_Preelaborable_Initialization (Comp_Type) then\n-                        return False;\n-                     end if;\n-\n-                  --  In the expression case we check whether the expression\n-                  --  is preelaborable.\n-\n-                  elsif\n-                    not Is_Preelaborable_Expression (Expression (Assn))\n-                  then\n-                     return False;\n-                  end if;\n-\n-                  Next (Assn);\n-               end loop;\n-\n-               --  If we get here then aggregate as a whole is preelaborable\n-\n-               return True;\n-\n-            --  All other cases are not preelaborable\n-\n-            else\n-               return False;\n-            end if;\n-         end Is_Preelaborable_Expression;\n-\n-      --  Start of processing for Check_Components\n-\n       begin\n          --  Loop through entities of record or protected type\n \n@@ -10969,7 +11036,7 @@ package body Sem_Util is\n \n             --  Require the default expression to be preelaborable\n \n-            elsif not Is_Preelaborable_Expression (Exp) then\n+            elsif not Is_Preelaborable_Construct (Exp) then\n                Has_PE := False;\n                exit;\n             end if;\n@@ -11714,21 +11781,23 @@ package body Sem_Util is\n    -- In_Instance_Visible_Part --\n    ------------------------------\n \n-   function In_Instance_Visible_Part return Boolean is\n-      S : Entity_Id;\n+   function In_Instance_Visible_Part\n+     (Id : Entity_Id := Current_Scope) return Boolean\n+   is\n+      Inst : Entity_Id;\n \n    begin\n-      S := Current_Scope;\n-      while Present (S) and then S /= Standard_Standard loop\n-         if Ekind (S) = E_Package\n-           and then Is_Generic_Instance (S)\n-           and then not In_Package_Body (S)\n-           and then not In_Private_Part (S)\n+      Inst := Id;\n+      while Present (Inst) and then Inst /= Standard_Standard loop\n+         if Ekind (Inst) = E_Package\n+           and then Is_Generic_Instance (Inst)\n+           and then not In_Package_Body (Inst)\n+           and then not In_Private_Part (Inst)\n          then\n             return True;\n          end if;\n \n-         S := Scope (S);\n+         Inst := Scope (Inst);\n       end loop;\n \n       return False;\n@@ -11887,7 +11956,7 @@ package body Sem_Util is\n    -- In_Subtree --\n    ----------------\n \n-   function In_Subtree (Root : Node_Id; N : Node_Id) return Boolean is\n+   function In_Subtree (N : Node_Id; Root : Node_Id) return Boolean is\n       Curr : Node_Id;\n \n    begin\n@@ -11903,6 +11972,30 @@ package body Sem_Util is\n       return False;\n    end In_Subtree;\n \n+   ----------------\n+   -- In_Subtree --\n+   ----------------\n+\n+   function In_Subtree\n+     (N     : Node_Id;\n+      Root1 : Node_Id;\n+      Root2 : Node_Id) return Boolean\n+   is\n+      Curr : Node_Id;\n+\n+   begin\n+      Curr := N;\n+      while Present (Curr) loop\n+         if Curr = Root1 or else Curr = Root2 then\n+            return True;\n+         end if;\n+\n+         Curr := Parent (Curr);\n+      end loop;\n+\n+      return False;\n+   end In_Subtree;\n+\n    ---------------------\n    -- In_Visible_Part --\n    ---------------------\n@@ -15287,51 +15380,207 @@ package body Sem_Util is\n       end if;\n    end Is_Potentially_Unevaluated;\n \n-   ---------------------------------\n-   -- Is_Protected_Self_Reference --\n-   ---------------------------------\n+   --------------------------------\n+   -- Is_Preelaborable_Aggregate --\n+   --------------------------------\n \n-   function Is_Protected_Self_Reference (N : Node_Id) return Boolean is\n+   function Is_Preelaborable_Aggregate (Aggr : Node_Id) return Boolean is\n+      Aggr_Typ   : constant Entity_Id := Etype (Aggr);\n+      Array_Aggr : constant Boolean   := Is_Array_Type (Aggr_Typ);\n \n-      function In_Access_Definition (N : Node_Id) return Boolean;\n-      --  Returns true if N belongs to an access definition\n+      Anc_Part : Node_Id;\n+      Assoc    : Node_Id;\n+      Choice   : Node_Id;\n+      Comp_Typ : Entity_Id;\n+      Expr     : Node_Id;\n \n-      --------------------------\n-      -- In_Access_Definition --\n-      --------------------------\n+   begin\n+      if Array_Aggr then\n+         Comp_Typ := Component_Type (Aggr_Typ);\n+      end if;\n \n-      function In_Access_Definition (N : Node_Id) return Boolean is\n-         P : Node_Id;\n+      --  Inspect the ancestor part\n \n-      begin\n-         P := Parent (N);\n-         while Present (P) loop\n-            if Nkind (P) = N_Access_Definition then\n-               return True;\n-            end if;\n+      if Nkind (Aggr) = N_Extension_Aggregate then\n+         Anc_Part := Ancestor_Part (Aggr);\n \n-            P := Parent (P);\n-         end loop;\n+         --  The ancestor denotes a subtype mark\n \n-         return False;\n-      end In_Access_Definition;\n+         if Is_Entity_Name (Anc_Part)\n+           and then Is_Type (Entity (Anc_Part))\n+         then\n+            if not Has_Preelaborable_Initialization (Entity (Anc_Part)) then\n+               return False;\n+            end if;\n \n-   --  Start of processing for Is_Protected_Self_Reference\n+         --  Otherwise the ancestor denotes an expression\n \n-   begin\n-      --  Verify that prefix is analyzed and has the proper form. Note that\n-      --  the attributes Elab_Spec, Elab_Body, and Elab_Subp_Body, which also\n-      --  produce the address of an entity, do not analyze their prefix\n-      --  because they denote entities that are not necessarily visible.\n-      --  Neither of them can apply to a protected type.\n+         elsif not Is_Preelaborable_Construct (Anc_Part) then\n+            return False;\n+         end if;\n+      end if;\n \n-      return Ada_Version >= Ada_2005\n-        and then Is_Entity_Name (N)\n-        and then Present (Entity (N))\n-        and then Is_Protected_Type (Entity (N))\n-        and then In_Open_Scopes (Entity (N))\n-        and then not In_Access_Definition (N);\n-   end Is_Protected_Self_Reference;\n+      --  Inspect the positional associations\n+\n+      Expr := First (Expressions (Aggr));\n+      while Present (Expr) loop\n+         if not Is_Preelaborable_Construct (Expr) then\n+            return False;\n+         end if;\n+\n+         Next (Expr);\n+      end loop;\n+\n+      --  Inspect the named associations\n+\n+      Assoc := First (Component_Associations (Aggr));\n+      while Present (Assoc) loop\n+\n+         --  Inspect the choices of the current named association\n+\n+         Choice := First (Choices (Assoc));\n+         while Present (Choice) loop\n+            if Array_Aggr then\n+\n+               --  For a choice to be preelaborable, it must denote either a\n+               --  static range or a static expression.\n+\n+               if Nkind (Choice) = N_Others_Choice then\n+                  null;\n+\n+               elsif Nkind (Choice) = N_Range then\n+                  if not Is_OK_Static_Range (Choice) then\n+                     return False;\n+                  end if;\n+\n+               elsif not Is_OK_Static_Expression (Choice) then\n+                  return False;\n+               end if;\n+\n+            else\n+               Comp_Typ := Etype (Choice);\n+            end if;\n+\n+            Next (Choice);\n+         end loop;\n+\n+         --  The type of the choice must have preelaborable initialization if\n+         --  the association carries a <>.\n+\n+         if Box_Present (Assoc) then\n+            if not Has_Preelaborable_Initialization (Comp_Typ) then\n+               return False;\n+            end if;\n+\n+         --  The type of the expression must have preelaborable initialization\n+\n+         elsif not Is_Preelaborable_Construct (Expression (Assoc)) then\n+            return False;\n+         end if;\n+\n+         Next (Assoc);\n+      end loop;\n+\n+      --  At this point the aggregate is preelaborable\n+\n+      return True;\n+   end Is_Preelaborable_Aggregate;\n+\n+   --------------------------------\n+   -- Is_Preelaborable_Construct --\n+   --------------------------------\n+\n+   function Is_Preelaborable_Construct (N : Node_Id) return Boolean is\n+   begin\n+      --  Aggregates\n+\n+      if Nkind_In (N, N_Aggregate, N_Extension_Aggregate) then\n+         return Is_Preelaborable_Aggregate (N);\n+\n+      --  Attributes are allowed in general, even if their prefix is a formal\n+      --  type. It seems that certain attributes known not to be static might\n+      --  not be allowed, but there are no rules to prevent them.\n+\n+      elsif Nkind (N) = N_Attribute_Reference then\n+         return True;\n+\n+      --  Expressions\n+\n+      elsif Nkind (N) in N_Subexpr and then Is_OK_Static_Expression (N) then\n+         return True;\n+\n+      elsif Nkind (N) = N_Qualified_Expression then\n+         return Is_Preelaborable_Construct (Expression (N));\n+\n+      --  Names are preelaborable when they denote a discriminant of an\n+      --  enclosing type. Discriminals are also considered for this check.\n+\n+      elsif Is_Entity_Name (N)\n+        and then Present (Entity (N))\n+        and then\n+          (Ekind (Entity (N)) = E_Discriminant\n+            or else (Ekind_In (Entity (N), E_Constant, E_In_Parameter)\n+                      and then Present (Discriminal_Link (Entity (N)))))\n+      then\n+         return True;\n+\n+      --  Statements\n+\n+      elsif Nkind (N) = N_Null then\n+         return True;\n+\n+      --  Otherwise the construct is not preelaborable\n+\n+      else\n+         return False;\n+      end if;\n+   end Is_Preelaborable_Construct;\n+\n+   ---------------------------------\n+   -- Is_Protected_Self_Reference --\n+   ---------------------------------\n+\n+   function Is_Protected_Self_Reference (N : Node_Id) return Boolean is\n+\n+      function In_Access_Definition (N : Node_Id) return Boolean;\n+      --  Returns true if N belongs to an access definition\n+\n+      --------------------------\n+      -- In_Access_Definition --\n+      --------------------------\n+\n+      function In_Access_Definition (N : Node_Id) return Boolean is\n+         P : Node_Id;\n+\n+      begin\n+         P := Parent (N);\n+         while Present (P) loop\n+            if Nkind (P) = N_Access_Definition then\n+               return True;\n+            end if;\n+\n+            P := Parent (P);\n+         end loop;\n+\n+         return False;\n+      end In_Access_Definition;\n+\n+   --  Start of processing for Is_Protected_Self_Reference\n+\n+   begin\n+      --  Verify that prefix is analyzed and has the proper form. Note that\n+      --  the attributes Elab_Spec, Elab_Body, and Elab_Subp_Body, which also\n+      --  produce the address of an entity, do not analyze their prefix\n+      --  because they denote entities that are not necessarily visible.\n+      --  Neither of them can apply to a protected type.\n+\n+      return Ada_Version >= Ada_2005\n+        and then Is_Entity_Name (N)\n+        and then Present (Entity (N))\n+        and then Is_Protected_Type (Entity (N))\n+        and then In_Open_Scopes (Entity (N))\n+        and then not In_Access_Definition (N);\n+   end Is_Protected_Self_Reference;\n \n    -----------------------------\n    -- Is_RCI_Pkg_Spec_Or_Body --\n@@ -16941,6 +17190,306 @@ package body Sem_Util is\n       return N;\n    end Last_Source_Statement;\n \n+   -----------------------\n+   -- Mark_Coextensions --\n+   -----------------------\n+\n+   procedure Mark_Coextensions (Context_Nod : Node_Id; Root_Nod : Node_Id) is\n+      Is_Dynamic : Boolean;\n+      --  Indicates whether the context causes nested coextensions to be\n+      --  dynamic or static\n+\n+      function Mark_Allocator (N : Node_Id) return Traverse_Result;\n+      --  Recognize an allocator node and label it as a dynamic coextension\n+\n+      --------------------\n+      -- Mark_Allocator --\n+      --------------------\n+\n+      function Mark_Allocator (N : Node_Id) return Traverse_Result is\n+      begin\n+         if Nkind (N) = N_Allocator then\n+            if Is_Dynamic then\n+               Set_Is_Dynamic_Coextension (N);\n+\n+            --  If the allocator expression is potentially dynamic, it may\n+            --  be expanded out of order and require dynamic allocation\n+            --  anyway, so we treat the coextension itself as dynamic.\n+            --  Potential optimization ???\n+\n+            elsif Nkind (Expression (N)) = N_Qualified_Expression\n+              and then Nkind (Expression (Expression (N))) = N_Op_Concat\n+            then\n+               Set_Is_Dynamic_Coextension (N);\n+            else\n+               Set_Is_Static_Coextension (N);\n+            end if;\n+         end if;\n+\n+         return OK;\n+      end Mark_Allocator;\n+\n+      procedure Mark_Allocators is new Traverse_Proc (Mark_Allocator);\n+\n+   --  Start of processing for Mark_Coextensions\n+\n+   begin\n+      --  An allocator that appears on the right-hand side of an assignment is\n+      --  treated as a potentially dynamic coextension when the right-hand side\n+      --  is an allocator or a qualified expression.\n+\n+      --    Obj := new ...'(new Coextension ...);\n+\n+      if Nkind (Context_Nod) = N_Assignment_Statement then\n+         Is_Dynamic :=\n+           Nkind_In (Expression (Context_Nod), N_Allocator,\n+                                               N_Qualified_Expression);\n+\n+      --  An allocator that appears within the expression of a simple return\n+      --  statement is treated as a potentially dynamic coextension when the\n+      --  expression is either aggregate, allocator, or qualified expression.\n+\n+      --    return (new Coextension ...);\n+      --    return new ...'(new Coextension ...);\n+\n+      elsif Nkind (Context_Nod) = N_Simple_Return_Statement then\n+         Is_Dynamic :=\n+           Nkind_In (Expression (Context_Nod), N_Aggregate,\n+                                               N_Allocator,\n+                                               N_Qualified_Expression);\n+\n+      --  An alloctor that appears within the initialization expression of an\n+      --  object declaration is considered a potentially dynamic coextension\n+      --  when the initialization expression is an allocator or a qualified\n+      --  expression.\n+\n+      --    Obj : ... := new ...'(new Coextension ...);\n+\n+      --  A similar case arises when the object declaration is part of an\n+      --  extended return statement.\n+\n+      --    return Obj : ... := new ...'(new Coextension ...);\n+      --    return Obj : ... := (new Coextension ...);\n+\n+      elsif Nkind (Context_Nod) = N_Object_Declaration then\n+         Is_Dynamic :=\n+           Nkind_In (Root_Nod, N_Allocator, N_Qualified_Expression)\n+             or else\n+               Nkind (Parent (Context_Nod)) = N_Extended_Return_Statement;\n+\n+      --  This routine should not be called with constructs that cannot contain\n+      --  coextensions.\n+\n+      else\n+         raise Program_Error;\n+      end if;\n+\n+      Mark_Allocators (Root_Nod);\n+   end Mark_Coextensions;\n+\n+   ---------------------------------\n+   -- Mark_Elaboration_Attributes --\n+   ---------------------------------\n+\n+   procedure Mark_Elaboration_Attributes\n+     (N_Id   : Node_Or_Entity_Id;\n+      Checks : Boolean := False;\n+      Level  : Boolean := False;\n+      Modes  : Boolean := False)\n+   is\n+      function Elaboration_Checks_OK\n+        (Target_Id  : Entity_Id;\n+         Context_Id : Entity_Id) return Boolean;\n+      --  Determine whether elaboration checks are enabled for target Target_Id\n+      --  which resides within context Context_Id.\n+\n+      procedure Mark_Elaboration_Attributes_Id (Id : Entity_Id);\n+      --  Preserve relevant attributes of the context in arbitrary entity Id\n+\n+      procedure Mark_Elaboration_Attributes_Node (N : Node_Id);\n+      --  Preserve relevant attributes of the context in arbitrary node N\n+\n+      ---------------------------\n+      -- Elaboration_Checks_OK --\n+      ---------------------------\n+\n+      function Elaboration_Checks_OK\n+        (Target_Id  : Entity_Id;\n+         Context_Id : Entity_Id) return Boolean\n+      is\n+         Encl_Scop : Entity_Id;\n+\n+      begin\n+         --  Elaboration checks are suppressed for the target\n+\n+         if Elaboration_Checks_Suppressed (Target_Id) then\n+            return False;\n+         end if;\n+\n+         --  Otherwise elaboration checks are OK for the target, but may be\n+         --  suppressed for the context where the target is declared.\n+\n+         Encl_Scop := Context_Id;\n+         while Present (Encl_Scop) and then Encl_Scop /= Standard_Standard loop\n+            if Elaboration_Checks_Suppressed (Encl_Scop) then\n+               return False;\n+            end if;\n+\n+            Encl_Scop := Scope (Encl_Scop);\n+         end loop;\n+\n+         --  Neither the target nor its declarative context have elaboration\n+         --  checks suppressed.\n+\n+         return True;\n+      end Elaboration_Checks_OK;\n+\n+      ------------------------------------\n+      -- Mark_Elaboration_Attributes_Id --\n+      ------------------------------------\n+\n+      procedure Mark_Elaboration_Attributes_Id (Id : Entity_Id) is\n+      begin\n+         --  Mark the status of elaboration checks in effect. Do not reset the\n+         --  status in case the entity is reanalyzed with checks suppressed.\n+\n+         if Checks and then not Is_Elaboration_Checks_OK_Id (Id) then\n+            Set_Is_Elaboration_Checks_OK_Id (Id,\n+              Elaboration_Checks_OK\n+                (Target_Id  => Id,\n+                 Context_Id => Scope (Id)));\n+\n+         --  Entities do not need to capture their enclosing level. The Ghost\n+         --  and SPARK modes in effect are already marked during analysis.\n+\n+         else\n+            null;\n+         end if;\n+      end Mark_Elaboration_Attributes_Id;\n+\n+      --------------------------------------\n+      -- Mark_Elaboration_Attributes_Node --\n+      --------------------------------------\n+\n+      procedure Mark_Elaboration_Attributes_Node (N : Node_Id) is\n+         function Extract_Name (N : Node_Id) return Node_Id;\n+         --  Obtain the Name attribute of call or instantiation N\n+\n+         ------------------\n+         -- Extract_Name --\n+         ------------------\n+\n+         function Extract_Name (N : Node_Id) return Node_Id is\n+            Nam : Node_Id;\n+\n+         begin\n+            Nam := Name (N);\n+\n+            --  A call to an entry family appears in indexed form\n+\n+            if Nkind (Nam) = N_Indexed_Component then\n+               Nam := Prefix (Nam);\n+            end if;\n+\n+            --  The name may also appear in qualified form\n+\n+            if Nkind (Nam) = N_Selected_Component then\n+               Nam := Selector_Name (Nam);\n+            end if;\n+\n+            return Nam;\n+         end Extract_Name;\n+\n+         --  Local variables\n+\n+         Context_Id : Entity_Id;\n+         Nam        : Node_Id;\n+\n+      --  Start of processing for Mark_Elaboration_Attributes_Node\n+\n+      begin\n+         --  Mark the status of elaboration checks in effect. Do not reset the\n+         --  status in case the node is reanalyzed with checks suppressed.\n+\n+         if Checks and then not Is_Elaboration_Checks_OK_Node (N) then\n+\n+            --  Assignments, attribute references, and variable references do\n+            --  not have a \"declarative\" context.\n+\n+            Context_Id := Empty;\n+\n+            --  The status of elaboration checks for calls and instantiations\n+            --  depends on the most recent pragma Suppress/Unsuppress, as well\n+            --  as the suppression status of the context where the target is\n+            --  defined.\n+\n+            --    package Pack is\n+            --       function Func ...;\n+            --    end Pack;\n+\n+            --    with Pack;\n+            --    procedure Main is\n+            --       pragma Suppress (Elaboration_Checks, Pack);\n+            --       X : ... := Pack.Func;\n+            --    ...\n+\n+            --  In the example above, the call to Func has elaboration checks\n+            --  enabled because there is no active general purpose suppression\n+            --  pragma, however the elaboration checks of Pack are explicitly\n+            --  suppressed. As a result the elaboration checks of the call must\n+            --  be disabled in order to preserve this dependency.\n+\n+            if Nkind_In (N, N_Entry_Call_Statement,\n+                            N_Function_Call,\n+                            N_Function_Instantiation,\n+                            N_Package_Instantiation,\n+                            N_Procedure_Call_Statement,\n+                            N_Procedure_Instantiation)\n+            then\n+               Nam := Extract_Name (N);\n+\n+               if Is_Entity_Name (Nam) and then Present (Entity (Nam)) then\n+                  Context_Id := Scope (Entity (Nam));\n+               end if;\n+            end if;\n+\n+            Set_Is_Elaboration_Checks_OK_Node (N,\n+              Elaboration_Checks_OK\n+                (Target_Id  => Empty,\n+                 Context_Id => Context_Id));\n+         end if;\n+\n+         --  Mark the enclosing level of the node. Do not reset the status in\n+         --  case the node is relocated and reanalyzed.\n+\n+         if Level and then not Is_Declaration_Level_Node (N) then\n+            Set_Is_Declaration_Level_Node (N,\n+              Find_Enclosing_Level (N) = Declaration_Level);\n+         end if;\n+\n+         --  Mark the Ghost and SPARK mode in effect\n+\n+         if Modes then\n+            if Ghost_Mode = Ignore then\n+               Set_Is_Ignored_Ghost_Node (N);\n+            end if;\n+\n+            if SPARK_Mode = On then\n+               Set_Is_SPARK_Mode_On_Node (N);\n+            end if;\n+         end if;\n+      end Mark_Elaboration_Attributes_Node;\n+\n+   --  Start of processing for Mark_Elaboration_Attributes\n+\n+   begin\n+      if Nkind (N_Id) in N_Entity then\n+         Mark_Elaboration_Attributes_Id (N_Id);\n+      else\n+         Mark_Elaboration_Attributes_Node (N_Id);\n+      end if;\n+   end Mark_Elaboration_Attributes;\n+\n    ----------------------------------\n    -- Matching_Static_Array_Bounds --\n    ----------------------------------\n@@ -17245,103 +17794,6 @@ package body Sem_Util is\n       end case;\n    end May_Be_Lvalue;\n \n-   -----------------------\n-   -- Mark_Coextensions --\n-   -----------------------\n-\n-   procedure Mark_Coextensions (Context_Nod : Node_Id; Root_Nod : Node_Id) is\n-      Is_Dynamic : Boolean;\n-      --  Indicates whether the context causes nested coextensions to be\n-      --  dynamic or static\n-\n-      function Mark_Allocator (N : Node_Id) return Traverse_Result;\n-      --  Recognize an allocator node and label it as a dynamic coextension\n-\n-      --------------------\n-      -- Mark_Allocator --\n-      --------------------\n-\n-      function Mark_Allocator (N : Node_Id) return Traverse_Result is\n-      begin\n-         if Nkind (N) = N_Allocator then\n-            if Is_Dynamic then\n-               Set_Is_Dynamic_Coextension (N);\n-\n-            --  If the allocator expression is potentially dynamic, it may\n-            --  be expanded out of order and require dynamic allocation\n-            --  anyway, so we treat the coextension itself as dynamic.\n-            --  Potential optimization ???\n-\n-            elsif Nkind (Expression (N)) = N_Qualified_Expression\n-              and then Nkind (Expression (Expression (N))) = N_Op_Concat\n-            then\n-               Set_Is_Dynamic_Coextension (N);\n-            else\n-               Set_Is_Static_Coextension (N);\n-            end if;\n-         end if;\n-\n-         return OK;\n-      end Mark_Allocator;\n-\n-      procedure Mark_Allocators is new Traverse_Proc (Mark_Allocator);\n-\n-   --  Start of processing for Mark_Coextensions\n-\n-   begin\n-      --  An allocator that appears on the right-hand side of an assignment is\n-      --  treated as a potentially dynamic coextension when the right-hand side\n-      --  is an allocator or a qualified expression.\n-\n-      --    Obj := new ...'(new Coextension ...);\n-\n-      if Nkind (Context_Nod) = N_Assignment_Statement then\n-         Is_Dynamic :=\n-           Nkind_In (Expression (Context_Nod), N_Allocator,\n-                                               N_Qualified_Expression);\n-\n-      --  An allocator that appears within the expression of a simple return\n-      --  statement is treated as a potentially dynamic coextension when the\n-      --  expression is either aggregate, allocator, or qualified expression.\n-\n-      --    return (new Coextension ...);\n-      --    return new ...'(new Coextension ...);\n-\n-      elsif Nkind (Context_Nod) = N_Simple_Return_Statement then\n-         Is_Dynamic :=\n-           Nkind_In (Expression (Context_Nod), N_Aggregate,\n-                                               N_Allocator,\n-                                               N_Qualified_Expression);\n-\n-      --  An allocator that appears within the initialization expression of an\n-      --  object declaration is considered a potentially dynamic coextension\n-      --  when the initialization expression is an allocator or a qualified\n-      --  expression.\n-\n-      --    Obj : ... := new ...'(new Coextension ...);\n-\n-      --  A similar case arises when the object declaration is part of an\n-      --  extended return statement.\n-\n-      --    return Obj : ... := new ...'(new Coextension ...);\n-      --    return Obj : ... := (new Coextension ...);\n-\n-      elsif Nkind (Context_Nod) = N_Object_Declaration then\n-         Is_Dynamic :=\n-           Nkind_In (Root_Nod, N_Allocator, N_Qualified_Expression)\n-             or else\n-               Nkind (Parent (Context_Nod)) = N_Extended_Return_Statement;\n-\n-      --  This routine should not be called with constructs that cannot contain\n-      --  coextensions.\n-\n-      else\n-         raise Program_Error;\n-      end if;\n-\n-      Mark_Allocators (Root_Nod);\n-   end Mark_Coextensions;\n-\n    -----------------\n    -- Might_Raise --\n    -----------------\n@@ -18508,8 +18960,8 @@ package body Sem_Util is\n          --  the subtree being replicated.\n \n          elsif not In_Subtree\n-                     (Root => Source,\n-                      N    => Declaration_Node (Id))\n+                     (N    => Declaration_Node (Id),\n+                      Root => Source)\n          then\n             return;\n          end if;\n@@ -18653,8 +19105,8 @@ package body Sem_Util is\n          --  the subtree being replicated.\n \n          elsif not In_Subtree\n-                     (Root => Source,\n-                      N    => Associated_Node_For_Itype (Itype))\n+                     (N    => Associated_Node_For_Itype (Itype),\n+                      Root => Source)\n          then\n             return;\n          end if;\n@@ -21986,15 +22438,18 @@ package body Sem_Util is\n    -- Scope_Within --\n    ------------------\n \n-   function Scope_Within (Scope1, Scope2 : Entity_Id) return Boolean is\n-      Scop : Entity_Id;\n+   function Scope_Within\n+     (Inner : Entity_Id;\n+      Outer : Entity_Id) return Boolean\n+   is\n+      Curr : Entity_Id;\n \n    begin\n-      Scop := Scope1;\n-      while Scop /= Standard_Standard loop\n-         Scop := Scope (Scop);\n+      Curr := Inner;\n+      while Present (Curr) and then Curr /= Standard_Standard loop\n+         Curr := Scope (Curr);\n \n-         if Scop = Scope2 then\n+         if Curr = Outer then\n             return True;\n          end if;\n       end loop;\n@@ -22006,17 +22461,20 @@ package body Sem_Util is\n    -- Scope_Within_Or_Same --\n    --------------------------\n \n-   function Scope_Within_Or_Same (Scope1, Scope2 : Entity_Id) return Boolean is\n-      Scop : Entity_Id;\n+   function Scope_Within_Or_Same\n+     (Inner : Entity_Id;\n+      Outer : Entity_Id) return Boolean\n+   is\n+      Curr : Entity_Id;\n \n    begin\n-      Scop := Scope1;\n-      while Scop /= Standard_Standard loop\n-         if Scop = Scope2 then\n+      Curr := Inner;\n+      while Present (Curr) and then Curr /= Standard_Standard loop\n+         if Curr = Outer then\n             return True;\n-         else\n-            Scop := Scope (Scop);\n          end if;\n+\n+         Curr := Scope (Curr);\n       end loop;\n \n       return False;"}, {"sha": "2ebd54f3989cf09d2ebde956831cad3fe0a5c3c4", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 88, "deletions": 39, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e491a7739dc2ae9a5b92945e4f0e48a3a91e39/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e491a7739dc2ae9a5b92945e4f0e48a3a91e39/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=90e491a7739dc2ae9a5b92945e4f0e48a3a91e39", "patch": "@@ -202,6 +202,10 @@ package Sem_Util is\n    --  given, and the reference N is not in the same extended source unit as\n    --  the declaration of T.\n \n+   function Begin_Keyword_Location (N : Node_Id) return Source_Ptr;\n+   --  Given block statement, entry body, package body, subprogram body, or\n+   --  task body N, return the closest source location to the \"begin\" keyword.\n+\n    function Build_Actual_Subtype\n      (T : Entity_Id;\n       N : Node_Or_Entity_Id) return Node_Id;\n@@ -547,8 +551,9 @@ package Sem_Util is\n    --  instead of 0).\n \n    function Defining_Entity\n-     (N               : Node_Id;\n-      Empty_On_Errors : Boolean := False) return Entity_Id;\n+     (N                  : Node_Id;\n+      Empty_On_Errors    : Boolean := False;\n+      Concurrent_Subunit : Boolean := False) return Entity_Id;\n    --  Given a declaration N, returns the associated defining entity. If the\n    --  declaration has a specification, the entity is obtained from the\n    --  specification. If the declaration has a defining unit name, then the\n@@ -572,6 +577,9 @@ package Sem_Util is\n    --\n    --  The former semantics is appropriate for the back end; the latter\n    --  semantics is appropriate for the front end.\n+   --\n+   --  Set flag Concurrent_Subunit to handle rewritings of concurrent bodies\n+   --  which act as subunits. Such bodies are generally rewritten as null.\n \n    function Denotes_Discriminant\n      (N                : Node_Id;\n@@ -685,6 +693,12 @@ package Sem_Util is\n    --  Utility function to return the Ada entity of the subprogram enclosing\n    --  the entity E, if any. Returns Empty if no enclosing subprogram.\n \n+   function End_Keyword_Location (N : Node_Id) return Source_Ptr;\n+   --  Given block statement, entry body, package body, package declaration,\n+   --  protected body, [single] protected type declaration, subprogram body,\n+   --  task body, or [single] task type declaration N, return the closest\n+   --  source location of the \"end\" keyword.\n+\n    procedure Ensure_Freeze_Node (E : Entity_Id);\n    --  Make sure a freeze node is allocated for entity E. If necessary, build\n    --  and initialize a new freeze node and set Has_Delayed_Freeze True for E.\n@@ -740,12 +754,6 @@ package Sem_Util is\n    --  Call is set to the node for the corresponding call. If the node N is not\n    --  an actual parameter then Formal and Call are set to Empty.\n \n-   function Find_Specific_Type (CW : Entity_Id) return Entity_Id;\n-   --  Find specific type of a class-wide type, and handle the case of an\n-   --  incomplete type coming either from a limited_with clause or from an\n-   --  incomplete type declaration. If resulting type is private return its\n-   --  full view.\n-\n    function Find_Body_Discriminal\n      (Spec_Discriminant : Entity_Id) return Entity_Id;\n    --  Given a discriminant of the record type that implements a task or\n@@ -762,9 +770,12 @@ package Sem_Util is\n    --  discriminant at the same position in this new type.\n \n    function Find_Enclosing_Iterator_Loop (Id : Entity_Id) return Entity_Id;\n-   --  Given an arbitrary entity, try to find the nearest enclosing iterator\n-   --  loop. If such a loop is found, return the entity of its identifier (the\n-   --  E_Loop scope), otherwise return Empty.\n+   --  Find the nearest iterator loop which encloses arbitrary entity Id. If\n+   --  such a loop exists, return the entity of its identifier (E_Loop scope),\n+   --  otherwise return Empty.\n+\n+   function Find_Enclosing_Scope (N : Node_Id) return Entity_Id;\n+   --  Find the nearest scope which encloses arbitrary node N\n \n    function Find_Loop_In_Conditional_Block (N : Node_Id) return Node_Id;\n    --  Find the nested loop statement in a conditional block. Loops subject to\n@@ -868,6 +879,12 @@ package Sem_Util is\n    --  If the state space is that of a package, Pack_Id denotes its entity,\n    --  otherwise Pack_Id is Empty.\n \n+   function Find_Specific_Type (CW : Entity_Id) return Entity_Id;\n+   --  Find specific type of a class-wide type, and handle the case of an\n+   --  incomplete type coming either from a limited_with clause or from an\n+   --  incomplete type declaration. If resulting type is private return its\n+   --  full view.\n+\n    function Find_Static_Alternative (N : Node_Id) return Node_Id;\n    --  N is a case statement whose expression is a compile-time value.\n    --  Determine the alternative chosen, so that the code of non-selected\n@@ -1134,8 +1151,7 @@ package Sem_Util is\n    --  subprogram or entry and returns it, or if no subprogram can be found,\n    --  returns Empty.\n \n-   function Get_Task_Body_Procedure (E : Entity_Id) return Node_Id;\n-   pragma Inline (Get_Task_Body_Procedure);\n+   function Get_Task_Body_Procedure (E : Entity_Id) return Entity_Id;\n    --  Given an entity for a task type or subtype, retrieves the\n    --  Task_Body_Procedure field from the corresponding task type declaration.\n \n@@ -1259,14 +1275,14 @@ package Sem_Util is\n    --  as expressed in pragma Refined_State. This function does not take into\n    --  account the visible refinement region of abstract state Id.\n \n-   function Has_Null_Body (Proc_Id : Entity_Id) return Boolean;\n-   --  Determine whether the body of procedure Proc_Id contains a sole\n-   --  null statement, possibly followed by an optional return. Used to\n-   --  optimize useless calls to assertion checks.\n+   function Has_Non_Trivial_Precondition (Subp : Entity_Id) return Boolean;\n+   --  Determine whether subprogram Subp has a class-wide precondition that is\n+   --  not statically True.\n \n-      function Has_Non_Trivial_Precondition (P : Entity_Id) return Boolean;\n-      --  True if subprogram has a class-wide precondition that is not\n-      --  statically True.\n+   function Has_Null_Body (Proc_Id : Entity_Id) return Boolean;\n+   --  Determine whether the body of procedure Proc_Id contains a sole null\n+   --  statement, possibly followed by an optional return. Used to optimize\n+   --  useless calls to assertion checks.\n \n    function Has_Null_Exclusion (N : Node_Id) return Boolean;\n    --  Determine whether node N has a null exclusion\n@@ -1357,9 +1373,10 @@ package Sem_Util is\n    --  Returns True if current scope is with the private part or the body of\n    --  an instance. Other semantic checks are suppressed in this context.\n \n-   function In_Instance_Visible_Part return Boolean;\n-   --  Returns True if current scope is within the visible part of a package\n-   --  instance, where several additional semantic checks apply.\n+   function In_Instance_Visible_Part\n+     (Id : Entity_Id := Current_Scope) return Boolean;\n+   --  Returns True if arbitrary entity Id is within the visible part of a\n+   --  package instance, where several additional semantic checks apply.\n \n    function In_Package_Body return Boolean;\n    --  Returns True if current scope is within a package body\n@@ -1382,9 +1399,17 @@ package Sem_Util is\n    --  appearing anywhere within such a construct (that is it does not need\n    --  to be directly within).\n \n-   function In_Subtree (Root : Node_Id; N : Node_Id) return Boolean;\n+   function In_Subtree (N : Node_Id; Root : Node_Id) return Boolean;\n    --  Determine whether node N is within the subtree rooted at Root\n \n+   function In_Subtree\n+     (N     : Node_Id;\n+      Root1 : Node_Id;\n+      Root2 : Node_Id) return Boolean;\n+   --  Determine whether node N is within the subtree rooted at Root1 or Root2.\n+   --  This version is more efficient than calling the single root version of\n+   --  Is_Subtree twice.\n+\n    function In_Visible_Part (Scope_Id : Entity_Id) return Boolean;\n    --  Determine whether a declaration occurs within the visible part of a\n    --  package specification. The package must be on the scope stack, and the\n@@ -1765,6 +1790,14 @@ package Sem_Util is\n    --  persistent. A private type is potentially persistent if the full type\n    --  is potentially persistent.\n \n+   function Is_Preelaborable_Aggregate (Aggr : Node_Id) return Boolean;\n+   --  Determine whether aggregate Aggr violates the restrictions of\n+   --  preelaborable constructs as defined in ARM 10.2.1(5-9).\n+\n+   function Is_Preelaborable_Construct (N : Node_Id) return Boolean;\n+   --  Determine whether arbitrary node N violates the restrictions of\n+   --  preelaborable constructs as defined in ARM 10.2.1(5-9).\n+\n    function Is_Protected_Self_Reference (N : Node_Id) return Boolean;\n    --  Return True if node N denotes a protected type name which represents\n    --  the current instance of a protected object according to RM 9.4(21/2).\n@@ -2028,19 +2061,31 @@ package Sem_Util is\n    --  statement in Statements (HSS) that has Comes_From_Source set. If no\n    --  such statement exists, Empty is returned.\n \n+   procedure Mark_Coextensions (Context_Nod : Node_Id; Root_Nod : Node_Id);\n+   --  Given a node which designates the context of analysis and an origin in\n+   --  the tree, traverse from Root_Nod and mark all allocators as either\n+   --  dynamic or static depending on Context_Nod. Any incorrect marking is\n+   --  cleaned up during resolution.\n+\n+   procedure Mark_Elaboration_Attributes\n+     (N_Id   : Node_Or_Entity_Id;\n+      Checks : Boolean := False;\n+      Level  : Boolean := False;\n+      Modes  : Boolean := False);\n+   --  Preserve relevant elaboration-related properties of the context in\n+   --  arbitrary entity or node N_Id. When flag Checks is set, the routine\n+   --  saves the status of Elaboration_Check. When flag Level is set, the\n+   --  routine captures the declaration level of N_Id if applicable. When\n+   --  flag Modes is set, the routine saves the Ghost and SPARK modes in\n+   --  effect if applicable.\n+\n    function Matching_Static_Array_Bounds\n      (L_Typ : Node_Id;\n       R_Typ : Node_Id) return Boolean;\n    --  L_Typ and R_Typ are two array types. Returns True when they have the\n    --  same number of dimensions, and the same static bounds for each index\n    --  position.\n \n-   procedure Mark_Coextensions (Context_Nod : Node_Id; Root_Nod : Node_Id);\n-   --  Given a node which designates the context of analysis and an origin in\n-   --  the tree, traverse from Root_Nod and mark all allocators as either\n-   --  dynamic or static depending on Context_Nod. Any incorrect marking is\n-   --  cleaned up during resolution.\n-\n    function May_Be_Lvalue (N : Node_Id) return Boolean;\n    --  Determines if N could be an lvalue (e.g. an assignment left hand side).\n    --  An lvalue is defined as any expression which appears in a context where\n@@ -2460,15 +2505,19 @@ package Sem_Util is\n    --  this is the case, and False if no scalar parts are present (meaning that\n    --  the result of Valid_Scalars applied to T is always vacuously True).\n \n-   function Scope_Within_Or_Same (Scope1, Scope2 : Entity_Id) return Boolean;\n-   --  Determines if the entity Scope1 is the same as Scope2, or if it is\n-   --  inside it, where both entities represent scopes. Note that scopes\n-   --  are only partially ordered, so Scope_Within_Or_Same (A,B) and\n-   --  Scope_Within_Or_Same (B,A) can both be False for a given pair A,B.\n-\n-   function Scope_Within (Scope1, Scope2 : Entity_Id) return Boolean;\n-   --  Like Scope_Within_Or_Same, except that this function returns\n-   --  False in the case where Scope1 and Scope2 are the same scope.\n+   function Scope_Within\n+     (Inner : Entity_Id;\n+      Outer : Entity_Id) return Boolean;\n+   --  Determine whether scope Inner appears within scope Outer. Note that\n+   --  scopes are partially ordered, so Scope_Within (A, B) and Scope_Within\n+   --  (B, A) may both return False.\n+\n+   function Scope_Within_Or_Same\n+     (Inner : Entity_Id;\n+      Outer : Entity_Id) return Boolean;\n+   --  Determine whether scope Inner appears within scope Outer or both renote\n+   --  the same scope. Note that scopes are partially ordered, so Scope_Within\n+   --  (A, B) and Scope_Within (B, A) may both return False.\n \n    procedure Set_Convention (E : Entity_Id; Val : Convention_Id);\n    --  Same as Basic_Set_Convention, but with an extra check for access types."}, {"sha": "aae54547268ab0135e2bf26a97c1e2b0196cef67", "filename": "gcc/ada/sem_warn.adb", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e491a7739dc2ae9a5b92945e4f0e48a3a91e39/gcc%2Fada%2Fsem_warn.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e491a7739dc2ae9a5b92945e4f0e48a3a91e39/gcc%2Fada%2Fsem_warn.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_warn.adb?ref=90e491a7739dc2ae9a5b92945e4f0e48a3a91e39", "patch": "@@ -248,6 +248,10 @@ package body Sem_Warn is\n       --  If so, Ref is set to point to the reference node, and Var is set to\n       --  the referenced Entity.\n \n+      function Has_Condition_Actions (Iter : Node_Id) return Boolean;\n+      --  Determine whether iteration scheme Iter has meaningful condition\n+      --  actions.\n+\n       function Has_Indirection (T : Entity_Id) return Boolean;\n       --  If the controlling variable is an access type, or is a record type\n       --  with access components, assume that it is changed indirectly and\n@@ -360,6 +364,29 @@ package body Sem_Warn is\n          end if;\n       end Find_Var;\n \n+      ---------------------------\n+      -- Has_Condition_Actions --\n+      ---------------------------\n+\n+      function Has_Condition_Actions (Iter : Node_Id) return Boolean is\n+         Action : Node_Id;\n+\n+      begin\n+         --  A call marker is not considered a meaningful action because it\n+         --  acts as an annotation and has no runtime semantics.\n+\n+         Action := First (Condition_Actions (Iter));\n+         while Present (Action) loop\n+            if Nkind (Action) /= N_Call_Marker then\n+               return True;\n+            end if;\n+\n+            Next (Action);\n+         end loop;\n+\n+         return False;\n+      end Has_Condition_Actions;\n+\n       ---------------------\n       -- Has_Indirection --\n       ---------------------\n@@ -597,7 +624,7 @@ package body Sem_Warn is\n                --  Skip processing for while iteration with conditions actions,\n                --  since they make it too complicated to get the warning right.\n \n-               if Present (Condition_Actions (Iter)) then\n+               if Has_Condition_Actions (Iter) then\n                   return;\n                end if;\n "}, {"sha": "e4f8608eb73a075e87e5b05ceb714db0856ddcec", "filename": "gcc/ada/sinfo.adb", "status": "modified", "additions": 235, "deletions": 57, "changes": 292, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e491a7739dc2ae9a5b92945e4f0e48a3a91e39/gcc%2Fada%2Fsinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e491a7739dc2ae9a5b92945e4f0e48a3a91e39/gcc%2Fada%2Fsinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.adb?ref=90e491a7739dc2ae9a5b92945e4f0e48a3a91e39", "patch": "@@ -61,19 +61,6 @@ package body Sinfo is\n    --  uniform format of the conditions following this. Note that csinfo\n    --  expects this uniform format.\n \n-   function ABE_Is_Certain\n-      (N : Node_Id) return Boolean is\n-   begin\n-      pragma Assert (False\n-        or else NT (N).Nkind = N_Formal_Package_Declaration\n-        or else NT (N).Nkind = N_Function_Call\n-        or else NT (N).Nkind = N_Function_Instantiation\n-        or else NT (N).Nkind = N_Package_Instantiation\n-        or else NT (N).Nkind = N_Procedure_Call_Statement\n-        or else NT (N).Nkind = N_Procedure_Instantiation);\n-      return Flag18 (N);\n-   end ABE_Is_Certain;\n-\n    function Abort_Present\n       (N : Node_Id) return Boolean is\n    begin\n@@ -439,15 +426,15 @@ package body Sinfo is\n    end Classifications;\n \n    function Cleanup_Actions\n-     (N : Node_Id) return List_Id is\n+      (N : Node_Id) return List_Id is\n    begin\n       pragma Assert (False\n         or else NT (N).Nkind = N_Block_Statement);\n       return List5 (N);\n    end Cleanup_Actions;\n \n    function Comes_From_Extended_Return_Statement\n-     (N : Node_Id) return Boolean is\n+      (N : Node_Id) return Boolean is\n    begin\n       pragma Assert (False\n         or else NT (N).Nkind = N_Simple_Return_Statement);\n@@ -951,7 +938,7 @@ package body Sinfo is\n         or else NT (N).Nkind = N_Assignment_Statement\n         or else NT (N).Nkind = N_Selected_Component\n         or else NT (N).Nkind = N_Type_Conversion);\n-      return Flag1 (N);\n+      return Flag3 (N);\n    end Do_Discriminant_Check;\n \n    function Do_Division_Check\n@@ -1856,14 +1843,16 @@ package body Sinfo is\n       return Flag16 (N);\n    end Is_Controlling_Actual;\n \n-   function Is_Disabled\n+   function Is_Declaration_Level_Node\n       (N : Node_Id) return Boolean is\n    begin\n       pragma Assert (False\n-        or else NT (N).Nkind = N_Aspect_Specification\n-        or else NT (N).Nkind = N_Pragma);\n-      return Flag15 (N);\n-   end Is_Disabled;\n+        or else NT (N).Nkind = N_Call_Marker\n+        or else NT (N).Nkind = N_Function_Instantiation\n+        or else NT (N).Nkind = N_Package_Instantiation\n+        or else NT (N).Nkind = N_Procedure_Instantiation);\n+      return Flag5 (N);\n+   end Is_Declaration_Level_Node;\n \n    function Is_Delayed_Aspect\n       (N : Node_Id) return Boolean is\n@@ -1875,6 +1864,23 @@ package body Sinfo is\n       return Flag14 (N);\n    end Is_Delayed_Aspect;\n \n+   function Is_Disabled\n+      (N : Node_Id) return Boolean is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Aspect_Specification\n+        or else NT (N).Nkind = N_Pragma);\n+      return Flag15 (N);\n+   end Is_Disabled;\n+\n+   function Is_Dispatching_Call\n+      (N : Node_Id) return Boolean is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Call_Marker);\n+      return Flag3 (N);\n+   end Is_Dispatching_Call;\n+\n    function Is_Dynamic_Coextension\n       (N : Node_Id) return Boolean is\n    begin\n@@ -1892,8 +1898,27 @@ package body Sinfo is\n       return Flag1 (N);\n    end Is_Effective_Use_Clause;\n \n+   function Is_Elaboration_Checks_OK_Node\n+      (N : Node_Id) return Boolean is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Assignment_Statement\n+        or else NT (N).Nkind = N_Attribute_Reference\n+        or else NT (N).Nkind = N_Call_Marker\n+        or else NT (N).Nkind = N_Entry_Call_Statement\n+        or else NT (N).Nkind = N_Expanded_Name\n+        or else NT (N).Nkind = N_Function_Call\n+        or else NT (N).Nkind = N_Function_Instantiation\n+        or else NT (N).Nkind = N_Identifier\n+        or else NT (N).Nkind = N_Package_Instantiation\n+        or else NT (N).Nkind = N_Procedure_Call_Statement\n+        or else NT (N).Nkind = N_Procedure_Instantiation\n+        or else NT (N).Nkind = N_Requeue_Statement);\n+      return Flag1 (N);\n+   end Is_Elaboration_Checks_OK_Node;\n+\n    function Is_Elsif\n-     (N : Node_Id) return Boolean is\n+      (N : Node_Id) return Boolean is\n    begin\n       pragma Assert (False\n         or else NT (N).Nkind = N_If_Expression);\n@@ -1982,6 +2007,25 @@ package body Sinfo is\n       return Flag4 (N);\n    end Is_Inherited_Pragma;\n \n+   function Is_Initialization_Block\n+      (N : Node_Id) return Boolean is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Block_Statement);\n+      return Flag1 (N);\n+   end Is_Initialization_Block;\n+\n+   function Is_Known_Guaranteed_ABE\n+      (N : Node_Id) return Boolean is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Call_Marker\n+        or else NT (N).Nkind = N_Function_Instantiation\n+        or else NT (N).Nkind = N_Package_Instantiation\n+        or else NT (N).Nkind = N_Procedure_Instantiation);\n+      return Flag18 (N);\n+   end Is_Known_Guaranteed_ABE;\n+\n    function Is_Machine_Number\n       (N : Node_Id) return Boolean is\n    begin\n@@ -2038,6 +2082,44 @@ package body Sinfo is\n       return Flag4 (N);\n    end Is_Qualified_Universal_Literal;\n \n+   function Is_Recorded_Scenario\n+      (N : Node_Id) return Boolean is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Call_Marker\n+        or else NT (N).Nkind = N_Function_Instantiation\n+        or else NT (N).Nkind = N_Package_Instantiation\n+        or else NT (N).Nkind = N_Procedure_Instantiation);\n+      return Flag6 (N);\n+   end Is_Recorded_Scenario;\n+\n+   function Is_Source_Call\n+      (N : Node_Id) return Boolean is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Call_Marker);\n+      return Flag4 (N);\n+   end Is_Source_Call;\n+\n+   function Is_SPARK_Mode_On_Node\n+      (N : Node_Id) return Boolean is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Assignment_Statement\n+        or else NT (N).Nkind = N_Attribute_Reference\n+        or else NT (N).Nkind = N_Call_Marker\n+        or else NT (N).Nkind = N_Entry_Call_Statement\n+        or else NT (N).Nkind = N_Expanded_Name\n+        or else NT (N).Nkind = N_Function_Call\n+        or else NT (N).Nkind = N_Function_Instantiation\n+        or else NT (N).Nkind = N_Identifier\n+        or else NT (N).Nkind = N_Package_Instantiation\n+        or else NT (N).Nkind = N_Procedure_Call_Statement\n+        or else NT (N).Nkind = N_Procedure_Instantiation\n+        or else NT (N).Nkind = N_Requeue_Statement);\n+      return Flag2 (N);\n+   end Is_SPARK_Mode_On_Node;\n+\n    function Is_Static_Coextension\n       (N : Node_Id) return Boolean is\n    begin\n@@ -2425,15 +2507,6 @@ package body Sinfo is\n       return Flag7 (N);\n    end No_Ctrl_Actions;\n \n-   function No_Elaboration_Check\n-      (N : Node_Id) return Boolean is\n-   begin\n-      pragma Assert (False\n-        or else NT (N).Nkind = N_Function_Call\n-        or else NT (N).Nkind = N_Procedure_Call_Statement);\n-      return Flag14 (N);\n-   end No_Elaboration_Check;\n-\n    function No_Entities_Ref_In_Spec\n       (N : Node_Id) return Boolean is\n    begin\n@@ -2465,7 +2538,7 @@ package body Sinfo is\n    begin\n       pragma Assert (False\n         or else NT (N).Nkind = N_Function_Call);\n-      return Flag1 (N);\n+      return Flag17 (N);\n    end No_Side_Effect_Removal;\n \n    function No_Truncation\n@@ -3192,6 +3265,14 @@ package body Sinfo is\n       return Flag15 (N);\n    end Tagged_Present;\n \n+   function Target\n+      (N : Node_Id) return Entity_Id is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Call_Marker);\n+      return Node1 (N);\n+   end Target;\n+\n    function Target_Type\n       (N : Node_Id) return Entity_Id is\n    begin\n@@ -3364,6 +3445,14 @@ package body Sinfo is\n       return Elist2 (N);\n    end Used_Operations;\n \n+   function Was_Attribute_Reference\n+      (N : Node_Id) return Boolean is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Subprogram_Body);\n+      return Flag2 (N);\n+   end Was_Attribute_Reference;\n+\n    function Was_Expression_Function\n       (N : Node_Id) return Boolean is\n    begin\n@@ -3395,19 +3484,6 @@ package body Sinfo is\n    -- Field Set Procedures --\n    --------------------------\n \n-   procedure Set_ABE_Is_Certain\n-      (N : Node_Id; Val : Boolean := True) is\n-   begin\n-      pragma Assert (False\n-        or else NT (N).Nkind = N_Formal_Package_Declaration\n-        or else NT (N).Nkind = N_Function_Call\n-        or else NT (N).Nkind = N_Function_Instantiation\n-        or else NT (N).Nkind = N_Package_Instantiation\n-        or else NT (N).Nkind = N_Procedure_Call_Statement\n-        or else NT (N).Nkind = N_Procedure_Instantiation);\n-      Set_Flag18 (N, Val);\n-   end Set_ABE_Is_Certain;\n-\n    procedure Set_Abort_Present\n       (N : Node_Id; Val : Boolean := True) is\n    begin\n@@ -4285,7 +4361,7 @@ package body Sinfo is\n         or else NT (N).Nkind = N_Assignment_Statement\n         or else NT (N).Nkind = N_Selected_Component\n         or else NT (N).Nkind = N_Type_Conversion);\n-      Set_Flag1 (N, Val);\n+      Set_Flag3 (N, Val);\n    end Set_Do_Discriminant_Check;\n \n    procedure Set_Do_Division_Check\n@@ -5181,6 +5257,17 @@ package body Sinfo is\n       Set_Flag16 (N, Val);\n    end Set_Is_Controlling_Actual;\n \n+   procedure Set_Is_Declaration_Level_Node\n+      (N : Node_Id; Val : Boolean := True) is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Call_Marker\n+        or else NT (N).Nkind = N_Function_Instantiation\n+        or else NT (N).Nkind = N_Package_Instantiation\n+        or else NT (N).Nkind = N_Procedure_Instantiation);\n+      Set_Flag5 (N, Val);\n+   end Set_Is_Declaration_Level_Node;\n+\n    procedure Set_Is_Delayed_Aspect\n       (N : Node_Id; Val : Boolean := True) is\n    begin\n@@ -5200,6 +5287,14 @@ package body Sinfo is\n       Set_Flag15 (N, Val);\n    end Set_Is_Disabled;\n \n+   procedure Set_Is_Dispatching_Call\n+      (N : Node_Id; Val : Boolean := True) is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Call_Marker);\n+      Set_Flag3 (N, Val);\n+   end Set_Is_Dispatching_Call;\n+\n    procedure Set_Is_Dynamic_Coextension\n       (N : Node_Id; Val : Boolean := True) is\n    begin\n@@ -5217,8 +5312,27 @@ package body Sinfo is\n       Set_Flag1 (N, Val);\n    end Set_Is_Effective_Use_Clause;\n \n+   procedure Set_Is_Elaboration_Checks_OK_Node\n+      (N : Node_Id; Val : Boolean := True) is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Assignment_Statement\n+        or else NT (N).Nkind = N_Attribute_Reference\n+        or else NT (N).Nkind = N_Call_Marker\n+        or else NT (N).Nkind = N_Entry_Call_Statement\n+        or else NT (N).Nkind = N_Expanded_Name\n+        or else NT (N).Nkind = N_Function_Call\n+        or else NT (N).Nkind = N_Function_Instantiation\n+        or else NT (N).Nkind = N_Identifier\n+        or else NT (N).Nkind = N_Package_Instantiation\n+        or else NT (N).Nkind = N_Procedure_Call_Statement\n+        or else NT (N).Nkind = N_Procedure_Instantiation\n+        or else NT (N).Nkind = N_Requeue_Statement);\n+      Set_Flag1 (N, Val);\n+   end Set_Is_Elaboration_Checks_OK_Node;\n+\n    procedure Set_Is_Elsif\n-     (N : Node_Id; Val : Boolean := True) is\n+      (N : Node_Id; Val : Boolean := True) is\n    begin\n       pragma Assert (False\n         or else NT (N).Nkind = N_If_Expression);\n@@ -5307,6 +5421,25 @@ package body Sinfo is\n       Set_Flag4 (N, Val);\n    end Set_Is_Inherited_Pragma;\n \n+   procedure Set_Is_Initialization_Block\n+      (N : Node_Id; Val : Boolean := True) is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Block_Statement);\n+      Set_Flag1 (N, Val);\n+   end Set_Is_Initialization_Block;\n+\n+   procedure Set_Is_Known_Guaranteed_ABE\n+      (N : Node_Id; Val : Boolean := True) is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Call_Marker\n+        or else NT (N).Nkind = N_Function_Instantiation\n+        or else NT (N).Nkind = N_Package_Instantiation\n+        or else NT (N).Nkind = N_Procedure_Instantiation);\n+      Set_Flag18 (N, Val);\n+   end Set_Is_Known_Guaranteed_ABE;\n+\n    procedure Set_Is_Machine_Number\n       (N : Node_Id; Val : Boolean := True) is\n    begin\n@@ -5363,6 +5496,44 @@ package body Sinfo is\n       Set_Flag4 (N, Val);\n    end Set_Is_Qualified_Universal_Literal;\n \n+   procedure Set_Is_Recorded_Scenario\n+      (N : Node_Id; Val : Boolean := True) is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Call_Marker\n+        or else NT (N).Nkind = N_Function_Instantiation\n+        or else NT (N).Nkind = N_Package_Instantiation\n+        or else NT (N).Nkind = N_Procedure_Instantiation);\n+      Set_Flag6 (N, Val);\n+   end Set_Is_Recorded_Scenario;\n+\n+   procedure Set_Is_Source_Call\n+      (N : Node_Id; Val : Boolean := True) is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Call_Marker);\n+      Set_Flag4 (N, Val);\n+   end Set_Is_Source_Call;\n+\n+   procedure Set_Is_SPARK_Mode_On_Node\n+      (N : Node_Id; Val : Boolean := True) is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Assignment_Statement\n+        or else NT (N).Nkind = N_Attribute_Reference\n+        or else NT (N).Nkind = N_Call_Marker\n+        or else NT (N).Nkind = N_Entry_Call_Statement\n+        or else NT (N).Nkind = N_Expanded_Name\n+        or else NT (N).Nkind = N_Function_Call\n+        or else NT (N).Nkind = N_Function_Instantiation\n+        or else NT (N).Nkind = N_Identifier\n+        or else NT (N).Nkind = N_Package_Instantiation\n+        or else NT (N).Nkind = N_Procedure_Call_Statement\n+        or else NT (N).Nkind = N_Procedure_Instantiation\n+        or else NT (N).Nkind = N_Requeue_Statement);\n+      Set_Flag2 (N, Val);\n+   end Set_Is_SPARK_Mode_On_Node;\n+\n    procedure Set_Is_Static_Coextension\n       (N : Node_Id; Val : Boolean := True) is\n    begin\n@@ -5750,15 +5921,6 @@ package body Sinfo is\n       Set_Flag7 (N, Val);\n    end Set_No_Ctrl_Actions;\n \n-   procedure Set_No_Elaboration_Check\n-      (N : Node_Id; Val : Boolean := True) is\n-   begin\n-      pragma Assert (False\n-        or else NT (N).Nkind = N_Function_Call\n-        or else NT (N).Nkind = N_Procedure_Call_Statement);\n-      Set_Flag14 (N, Val);\n-   end Set_No_Elaboration_Check;\n-\n    procedure Set_No_Entities_Ref_In_Spec\n       (N : Node_Id; Val : Boolean := True) is\n    begin\n@@ -5790,7 +5952,7 @@ package body Sinfo is\n    begin\n       pragma Assert (False\n         or else NT (N).Nkind = N_Function_Call);\n-      Set_Flag1 (N, Val);\n+      Set_Flag17 (N, Val);\n    end Set_No_Side_Effect_Removal;\n \n    procedure Set_No_Truncation\n@@ -6517,6 +6679,14 @@ package body Sinfo is\n       Set_Flag15 (N, Val);\n    end Set_Tagged_Present;\n \n+   procedure Set_Target\n+      (N : Node_Id; Val : Entity_Id) is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Call_Marker);\n+      Set_Node1 (N, Val); -- semantic field, no parent set\n+   end Set_Target;\n+\n    procedure Set_Target_Type\n       (N : Node_Id; Val : Entity_Id) is\n    begin\n@@ -6689,6 +6859,14 @@ package body Sinfo is\n       Set_Elist2 (N, Val);\n    end Set_Used_Operations;\n \n+   procedure Set_Was_Attribute_Reference\n+      (N : Node_Id; Val : Boolean := True) is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Subprogram_Body);\n+      Set_Flag2 (N, Val);\n+   end Set_Was_Attribute_Reference;\n+\n    procedure Set_Was_Expression_Function\n       (N : Node_Id; Val : Boolean := True) is\n    begin"}, {"sha": "05ac1a30859ccec8fb798b53d93c1548b6aeaf60", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 256, "deletions": 79, "changes": 335, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e491a7739dc2ae9a5b92945e4f0e48a3a91e39/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e491a7739dc2ae9a5b92945e4f0e48a3a91e39/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=90e491a7739dc2ae9a5b92945e4f0e48a3a91e39", "patch": "@@ -845,15 +845,6 @@ package Sinfo is\n    --  section describes the usage of the semantic fields, which are used to\n    --  contain additional information determined during semantic analysis.\n \n-   --  ABE_Is_Certain (Flag18-Sem)\n-   --    This flag is set in an instantiation node or a call node is determined\n-   --    to be sure to raise an ABE. This is used to trigger special handling\n-   --    of such cases, particularly in the instantiation case where we avoid\n-   --    instantiating the body if this flag is set. This flag is also present\n-   --    in an N_Formal_Package_Declaration node since formal package\n-   --    declarations are treated like instantiations, but it is always set to\n-   --    False in this context.\n-\n    --  Accept_Handler_Records (List5-Sem)\n    --    This field is present only in an N_Accept_Alternative node. It is used\n    --    to temporarily hold the exception handler records from an accept\n@@ -1159,7 +1150,7 @@ package Sinfo is\n    --    that an accessibility check is required for the parameter. It is\n    --    not yet decided who takes care of this check (TBD ???).\n \n-   --  Do_Discriminant_Check (Flag1-Sem)\n+   --  Do_Discriminant_Check (Flag3-Sem)\n    --    This flag is set on N_Selected_Component nodes to indicate that a\n    --    discriminant check is required using the discriminant check routine\n    --    associated with the selector. The actual check is generated by the\n@@ -1663,10 +1654,6 @@ package Sinfo is\n    --    place in the various Analyze_xxx_In_Decl_Part routines which perform\n    --    full analysis. The flag prevents the reanalysis of a delayed pragma.\n \n-   --  Is_Expanded_Contract (Flag1-Sem)\n-   --    Present in N_Contract nodes. Set if the contract has already undergone\n-   --    expansion activities.\n-\n    --  Is_Asynchronous_Call_Block (Flag7-Sem)\n    --    A flag set in a Block_Statement node to indicate that it is the\n    --    expansion of an asynchronous entry call. Such a block needs cleanup\n@@ -1701,6 +1688,12 @@ package Sinfo is\n    --    a dispatching call. It is off in all other cases. See Sem_Disp for\n    --    details of its use.\n \n+   --  Is_Declaration_Level_Node (Flag5-Sem)\n+   --    Present in call marker and instantiation nodes. Set when the constuct\n+   --    appears within the declarations of a block statement, an entry body,\n+   --    a subprogram body, or a task body. The flag aids the ABE Processing\n+   --    phase to catch certain forms of guaranteed ABEs.\n+\n    --  Is_Delayed_Aspect (Flag14-Sem)\n    --    Present in N_Pragma and N_Attribute_Definition_Clause nodes which\n    --    come from aspect specifications, where the evaluation of the aspect\n@@ -1715,6 +1708,10 @@ package Sinfo is\n    --    If this flag is set, the aspect or policy is not analyzed for semantic\n    --    correctness, so any expressions etc will not be marked as analyzed.\n \n+   --  Is_Dispatching_Call (Flag3-Sem)\n+   --    Present in call marker nodes. Set when the related call which prompted\n+   --    the creation of the marker is dispatching.\n+\n    --  Is_Dynamic_Coextension (Flag18-Sem)\n    --    Present in allocator nodes, to indicate that this is an allocator\n    --    for an access discriminant of a dynamically allocated object. The\n@@ -1725,6 +1722,15 @@ package Sinfo is\n    --    Present in both N_Use_Type_Clause and N_Use_Package_Clause to indicate\n    --    a use clause is \"used\" in the current source.\n \n+   --  Is_Elaboration_Checks_OK_Node (Flag1-Sem)\n+   --    Present in nodes which represent an elaboration scenario. Those are\n+   --    assignment statement, attribute reference, call marker, entry call\n+   --    statement, expanded name, function call, identifier, instantiation,\n+   --    procedure call statement, and requeue statement nodes. Set when the\n+   --    node appears within a context which allows for the generation of\n+   --    run-time ABE checks. This flag detemines whether the ABE Processing\n+   --    phase generates conditional ABE checks and guaranteed ABE failures.\n+\n    --  Is_Entry_Barrier_Function (Flag8-Sem)\n    --    This flag is set on N_Subprogram_Declaration and N_Subprogram_Body\n    --    nodes which emulate the barrier function of a protected entry body.\n@@ -1735,6 +1741,10 @@ package Sinfo is\n    --    actuals to support a build-in-place style of call have been added to\n    --    the call.\n \n+   --  Is_Expanded_Contract (Flag1-Sem)\n+   --    Present in N_Contract nodes. Set if the contract has already undergone\n+   --    expansion activities.\n+\n    --  Is_Finalization_Wrapper (Flag9-Sem)\n    --    This flag is present in N_Block_Statement nodes. It is set when the\n    --    block acts as a wrapper of a handled construct which has controlled\n@@ -1794,6 +1804,19 @@ package Sinfo is\n    --    This flag is set in an N_Pragma node that appears in a N_Contract node\n    --    to indicate that the pragma has been inherited from a parent context.\n \n+   --  Is_Initialization_Block (Flag1-Sem)\n+   --    Defined in block nodes. Set when the block statement was created by\n+   --    the finalization machinery to wrap initialization statements. This\n+   --    flag aids the ABE Processing phase to suppress the diagnostics of\n+   --    finalization actions in initialization contexts.\n+\n+   --  Is_Known_Guaranteed_ABE (Flag18-Sem)\n+   --    Present in call markers and instantiations. Set when the elaboration\n+   --    or evaluation of the scenario results in a guaranteed ABE. The flag\n+   --    is used to suppress the instantiation of generic bodies because gigi\n+   --    cannot handle certain forms of premature instantiation, as well as to\n+   --    prevent the reexamination of the node by the ABE Processing phase.\n+\n    --  Is_Machine_Number (Flag11-Sem)\n    --    This flag is set in an N_Real_Literal node to indicate that the value\n    --    is a machine number. This avoids some unnecessary cases of converting\n@@ -1839,6 +1862,25 @@ package Sinfo is\n    --    the resolution of accidental overloading of binary or unary operators\n    --    which may occur in instances.\n \n+   --  Is_Recorded_Scenario (Flag6-Sem)\n+   --    Present in call marker and instantiation nodes. Set when the scenario\n+   --    was saved by the ABE Recording phase. This flag aids the ABE machinery\n+   --    to keep its internal data up-to-date in case the node is transformed\n+   --    by Atree.Rewrite.\n+\n+   --  Is_Source_Call (Flag4-Sem)\n+   --    Present in call marker nodes. Set when the related call came from\n+   --    source.\n+\n+   --  Is_SPARK_Mode_On_Node (Flag2-Sem)\n+   --    Present in nodes which represent an elaboration scenario. Those are\n+   --    assignment statement, attribute reference, call marker, entry call\n+   --    statement, expanded name, function call, identifier, instantiation,\n+   --    procedure call statement, and requeue statement nodes. Set when the\n+   --    node appears within a context subject to SPARK_Mode On. This flag\n+   --    determines when the SPARK model of elaboration be activated by the\n+   --    ABE Processing phase.\n+\n    --  Is_Static_Coextension (Flag14-Sem)\n    --    Present in N_Allocator nodes. Set if the allocator is a coextension\n    --    of an object allocated on the stack rather than the heap.\n@@ -2040,13 +2082,6 @@ package Sinfo is\n    --    expansions where the generated assignments are initializations, not\n    --    real assignments.\n \n-   --  No_Elaboration_Check (Flag14-Sem)\n-   --    Present in N_Function_Call and N_Procedure_Call_Statement. Indicates\n-   --    that no elaboration check is needed on the call, because it appears in\n-   --    the context of a local Suppress pragma. This is used on calls within\n-   --    task bodies, where the actual elaboration checks are applied after\n-   --    analysis, when the local scope stack is not present.\n-\n    --  No_Entities_Ref_In_Spec (Flag8-Sem)\n    --    Present in N_With_Clause nodes. Set if the with clause is on the\n    --    package or subprogram spec where the main unit is the corresponding\n@@ -2069,7 +2104,7 @@ package Sinfo is\n    --    It is used to indicate that processing for extended overflow checking\n    --    modes is not required (this is used to prevent infinite recursion).\n \n-   --  No_Side_Effect_Removal (Flag1-Sem)\n+   --  No_Side_Effect_Removal (Flag17-Sem)\n    --    Present in N_Function_Call nodes. Set when a function call does not\n    --    require side effect removal. This attribute suppresses the generation\n    --    of a temporary to capture the result of the function which eventually\n@@ -2281,6 +2316,10 @@ package Sinfo is\n    --    of a FOR loop is known to be null, or is probably null (loop would\n    --    only execute if invalid values are present).\n \n+   --  Target (Node1-Sem)\n+   --    Present in call marker nodes. References the entity of the entry,\n+   --    operator, or subprogram invoked by the related call or requeue.\n+\n    --  Target_Type (Node2-Sem)\n    --    Used in an N_Validate_Unchecked_Conversion node to point to the target\n    --    type entity for the unchecked conversion instantiation which gigi must\n@@ -2353,6 +2392,12 @@ package Sinfo is\n    --    on exit from the scope of the use_type_clause, in particular in the\n    --    case of Use_All_Type, when those operations several scopes.\n \n+   --  Was_Attribute_Reference (Flag2-Sem)\n+   --    Present in N_Subprogram_Body. Set to True if the original source is an\n+   --    attribute reference which is an actual in a generic instantiation. The\n+   --    instantiation prologue renames these attributes, and expansion later\n+   --    converts them into subprogram bodies.\n+\n    --  Was_Expression_Function (Flag18-Sem)\n    --    Present in N_Subprogram_Body. True if the original source had an\n    --    N_Expression_Function, which was converted to the N_Subprogram_Body\n@@ -2478,9 +2523,11 @@ package Sinfo is\n       --  Entity (Node4-Sem)\n       --  Associated_Node (Node4-Sem)\n       --  Original_Discriminant (Node2-Sem)\n+      --  Is_Elaboration_Checks_OK_Node (Flag1-Sem)\n+      --  Is_SPARK_Mode_On_Node (Flag2-Sem)\n+      --  Has_Private_View (Flag11-Sem) (set in generic units)\n       --  Redundant_Use (Flag13-Sem)\n       --  Atomic_Sync_Required (Flag14-Sem)\n-      --  Has_Private_View (Flag11-Sem) (set in generic units)\n       --  plus fields for expression\n \n       --------------------------\n@@ -2625,20 +2672,20 @@ package Sinfo is\n       --  Corresponding_Aspect (Node3-Sem) (set to Empty if not present)\n       --  Pragma_Identifier (Node4)\n       --  Next_Rep_Item (Node5-Sem)\n-      --  Class_Present (Flag6) set if from Aspect with 'Class\n-      --  From_Aspect_Specification (Flag13-Sem)\n-      --  Import_Interface_Present (Flag16-Sem)\n+      --  Is_Generic_Contract_Pragma (Flag2-Sem)\n+      --  Is_Checked_Ghost_Pragma (Flag3-Sem)\n+      --  Is_Inherited_Pragma (Flag4-Sem)\n       --  Is_Analyzed_Pragma (Flag5-Sem)\n+      --  Class_Present (Flag6) set if from Aspect with 'Class\n+      --  Uneval_Old_Accept (Flag7-Sem)\n+      --  Is_Ignored_Ghost_Pragma (Flag8-Sem)\n+      --  Is_Ignored (Flag9-Sem)\n       --  Is_Checked (Flag11-Sem)\n-      --  Is_Checked_Ghost_Pragma (Flag3-Sem)\n+      --  From_Aspect_Specification (Flag13-Sem)\n       --  Is_Delayed_Aspect (Flag14-Sem)\n       --  Is_Disabled (Flag15-Sem)\n-      --  Is_Generic_Contract_Pragma (Flag2-Sem)\n-      --  Is_Ignored (Flag9-Sem)\n-      --  Is_Ignored_Ghost_Pragma (Flag8-Sem)\n-      --  Is_Inherited_Pragma (Flag4-Sem)\n+      --  Import_Interface_Present (Flag16-Sem)\n       --  Split_PPC (Flag17) set if corresponding aspect had Split_PPC set\n-      --  Uneval_Old_Accept (Flag7-Sem)\n       --  Uneval_Old_Warn (Flag18-Sem)\n \n       --  Note: we should have a section on what pragmas are passed on to\n@@ -3780,8 +3827,8 @@ package Sinfo is\n       --  Sloc points to ALL\n       --  Prefix (Node3)\n       --  Actual_Designated_Subtype (Node4-Sem)\n-      --  Atomic_Sync_Required (Flag14-Sem)\n       --  Has_Dereference_Action (Flag13-Sem)\n+      --  Atomic_Sync_Required (Flag14-Sem)\n       --  plus fields for expression\n \n       -------------------------------\n@@ -3847,10 +3894,10 @@ package Sinfo is\n       --  Prefix (Node3)\n       --  Selector_Name (Node2)\n       --  Associated_Node (Node4-Sem)\n-      --  Do_Discriminant_Check (Flag1-Sem)\n+      --  Do_Discriminant_Check (Flag3-Sem)\n       --  Is_In_Discriminant_Check (Flag11-Sem)\n-      --  Is_Prefixed_Call (Flag17-Sem)\n       --  Atomic_Sync_Required (Flag14-Sem)\n+      --  Is_Prefixed_Call (Flag17-Sem)\n       --  plus fields for expression\n \n       --------------------------\n@@ -3943,10 +3990,11 @@ package Sinfo is\n       --  Expressions (List1) (set to No_List if no associated expressions)\n       --  Entity (Node4-Sem) used if the attribute yields a type\n       --  Associated_Node (Node4-Sem)\n-      --  Do_Overflow_Check (Flag17-Sem)\n+      --  Is_Elaboration_Checks_OK_Node (Flag1-Sem)\n+      --  Is_SPARK_Mode_On_Node (Flag2-Sem)\n       --  Header_Size_Added (Flag11-Sem)\n-      --  Must_Be_Byte_Aligned (Flag14-Sem)\n       --  Redundant_Use (Flag13-Sem)\n+      --  Must_Be_Byte_Aligned (Flag14-Sem)\n       --  plus fields for expression\n \n       --  Note: in Modify_Tree_For_C mode, Max and Min attributes are expanded\n@@ -4137,7 +4185,7 @@ package Sinfo is\n       ----------------------------------\n \n       --  NAMED_ARRAY_AGGREGATE ::=\n-      --  | (ARRAY_COMPONENT_ASSOCIATION {, ARRAY_COMPONENT_ASSOCIATION})\n+      --    (ARRAY_COMPONENT_ASSOCIATION {, ARRAY_COMPONENT_ASSOCIATION})\n \n       --  See Record_Aggregate (4.3.1) for node structure\n \n@@ -4674,7 +4722,7 @@ package Sinfo is\n       --  Sloc points to first token of subtype mark\n       --  Subtype_Mark (Node4)\n       --  Expression (Node3)\n-      --  Do_Discriminant_Check (Flag1-Sem)\n+      --  Do_Discriminant_Check (Flag3-Sem)\n       --  Do_Length_Check (Flag4-Sem)\n       --  Float_Truncate (Flag11-Sem)\n       --  Do_Tag_Check (Flag13-Sem)\n@@ -4839,13 +4887,15 @@ package Sinfo is\n       --  Sloc points to :=\n       --  Name (Node2)\n       --  Expression (Node3)\n-      --  Do_Discriminant_Check (Flag1-Sem)\n-      --  Do_Tag_Check (Flag13-Sem)\n+      --  Is_Elaboration_Checks_OK_Node (Flag1-Sem)\n+      --  Is_SPARK_Mode_On_Node (Flag2-Sem)\n+      --  Do_Discriminant_Check (Flag3-Sem)\n       --  Do_Length_Check (Flag4-Sem)\n       --  Forwards_OK (Flag5-Sem)\n       --  Backwards_OK (Flag6-Sem)\n       --  No_Ctrl_Actions (Flag7-Sem)\n       --  Has_Target_Names (Flag8-Sem)\n+      --  Do_Tag_Check (Flag13-Sem)\n       --  Componentwise_Assignment (Flag14-Sem)\n       --  Suppress_Assignment_Checks (Flag18-Sem)\n \n@@ -5101,15 +5151,16 @@ package Sinfo is\n       --  Identifier (Node1) block direct name (set to Empty if not present)\n       --  Declarations (List2) (set to No_List if no DECLARE part)\n       --  Handled_Statement_Sequence (Node4)\n-      --  Cleanup_Actions (List5-Sem)\n-      --  Is_Abort_Block (Flag4-Sem)\n-      --  Is_Task_Master (Flag5-Sem)\n       --  Activation_Chain_Entity (Node3-Sem)\n+      --  Cleanup_Actions (List5-Sem)\n       --  Has_Created_Identifier (Flag15)\n-      --  Is_Task_Allocation_Block (Flag6)\n       --  Is_Asynchronous_Call_Block (Flag7)\n+      --  Is_Task_Allocation_Block (Flag6)\n       --  Exception_Junk (Flag8-Sem)\n+      --  Is_Abort_Block (Flag4-Sem)\n       --  Is_Finalization_Wrapper (Flag9-Sem)\n+      --  Is_Initialization_Block (Flag1-Sem)\n+      --  Is_Task_Master (Flag5-Sem)\n \n       -------------------------\n       -- 5.7  Exit Statement --\n@@ -5273,8 +5324,8 @@ package Sinfo is\n       --   symbol turns out to be a normal string after all.\n       --  Entity (Node4-Sem)\n       --  Associated_Node (Node4-Sem)\n-      --  Has_Private_View (Flag11-Sem) set in generic units.\n       --  Etype (Node5-Sem)\n+      --  Has_Private_View (Flag11-Sem) set in generic units\n \n       --  Note: the Strval field may be set to No_String for generated\n       --  operator symbols that are known not to be string literals\n@@ -5399,6 +5450,7 @@ package Sinfo is\n       --  Is_Protected_Subprogram_Body (Flag7-Sem)\n       --  Is_Task_Body_Procedure (Flag1-Sem)\n       --  Is_Task_Master (Flag5-Sem)\n+      --  Was_Attribute_Reference (Flag2-Sem)\n       --  Was_Expression_Function (Flag18-Sem)\n       --  Was_Originally_Stub (Flag13-Sem)\n \n@@ -5422,9 +5474,9 @@ package Sinfo is\n       --   actual parameter part)\n       --  First_Named_Actual (Node4-Sem)\n       --  Controlling_Argument (Node1-Sem) (set to Empty if not dispatching)\n+      --  Is_Elaboration_Checks_OK_Node (Flag1-Sem)\n+      --  Is_SPARK_Mode_On_Node (Flag2-Sem)\n       --  Do_Tag_Check (Flag13-Sem)\n-      --  No_Elaboration_Check (Flag14-Sem)\n-      --  ABE_Is_Certain (Flag18-Sem)\n       --  plus fields for expression\n \n       --  If any IN parameter requires a range check, then the corresponding\n@@ -5452,11 +5504,11 @@ package Sinfo is\n       --   actual parameter part)\n       --  First_Named_Actual (Node4-Sem)\n       --  Controlling_Argument (Node1-Sem) (set to Empty if not dispatching)\n-      --  No_Side_Effect_Removal (Flag1-Sem)\n+      --  Is_Elaboration_Checks_OK_Node (Flag1-Sem)\n+      --  Is_SPARK_Mode_On_Node (Flag2-Sem)\n       --  Is_Expanded_Build_In_Place_Call (Flag11-Sem)\n       --  Do_Tag_Check (Flag13-Sem)\n-      --  No_Elaboration_Check (Flag14-Sem)\n-      --  ABE_Is_Certain (Flag18-Sem)\n+      --  No_Side_Effect_Removal (Flag17-Sem)\n       --  plus fields for expression\n \n       --------------------------------\n@@ -6165,6 +6217,8 @@ package Sinfo is\n       --  Parameter_Associations (List3) (set to No_List if no\n       --   actual parameter part)\n       --  First_Named_Actual (Node4-Sem)\n+      --  Is_Elaboration_Checks_OK_Node (Flag1-Sem)\n+      --  Is_SPARK_Mode_On_Node (Flag2-Sem)\n \n       ------------------------------\n       -- 9.5.4  Requeue Statement --\n@@ -6180,6 +6234,8 @@ package Sinfo is\n       --  Sloc points to REQUEUE\n       --  Name (Node2)\n       --  Abort_Present (Flag15)\n+      --  Is_Elaboration_Checks_OK_Node (Flag1-Sem)\n+      --  Is_SPARK_Mode_On_Node (Flag2-Sem)\n \n       --------------------------\n       -- 9.6  Delay Statement --\n@@ -6975,7 +7031,11 @@ package Sinfo is\n       --   generic actual part)\n       --  Parent_Spec (Node4-Sem)\n       --  Instance_Spec (Node5-Sem)\n-      --  ABE_Is_Certain (Flag18-Sem)\n+      --  Is_Elaboration_Checks_OK_Node (Flag1-Sem)\n+      --  Is_SPARK_Mode_On_Node (Flag2-Sem)\n+      --  Is_Declaration_Level_Node (Flag5-Sem)\n+      --  Is_Recorded_Scenario (Flag6-Sem)\n+      --  Is_Known_Guaranteed_ABE (Flag18-Sem)\n \n       --  N_Procedure_Instantiation\n       --  Sloc points to PROCEDURE\n@@ -6985,9 +7045,13 @@ package Sinfo is\n       --  Generic_Associations (List3) (set to No_List if no\n       --   generic actual part)\n       --  Instance_Spec (Node5-Sem)\n+      --  Is_Elaboration_Checks_OK_Node (Flag1-Sem)\n+      --  Is_SPARK_Mode_On_Node (Flag2-Sem)\n+      --  Is_Declaration_Level_Node (Flag5-Sem)\n+      --  Is_Recorded_Scenario (Flag6-Sem)\n       --  Must_Override (Flag14) set if overriding indicator present\n       --  Must_Not_Override (Flag15) set if not_overriding indicator present\n-      --  ABE_Is_Certain (Flag18-Sem)\n+      --  Is_Known_Guaranteed_ABE (Flag18-Sem)\n \n       --  N_Function_Instantiation\n       --  Sloc points to FUNCTION\n@@ -6997,9 +7061,13 @@ package Sinfo is\n       --   generic actual part)\n       --  Parent_Spec (Node4-Sem)\n       --  Instance_Spec (Node5-Sem)\n+      --  Is_Elaboration_Checks_OK_Node (Flag1-Sem)\n+      --  Is_SPARK_Mode_On_Node (Flag2-Sem)\n+      --  Is_Declaration_Level_Node (Flag5-Sem)\n+      --  Is_Recorded_Scenario (Flag6-Sem)\n       --  Must_Override (Flag14) set if overriding indicator present\n       --  Must_Not_Override (Flag15) set if not_overriding indicator present\n-      --  ABE_Is_Certain (Flag18-Sem)\n+      --  Is_Known_Guaranteed_ABE (Flag18-Sem)\n \n       --  Note: overriding indicator is an Ada 2005 feature\n \n@@ -7312,7 +7380,6 @@ package Sinfo is\n       --   empty generic actual part)\n       --  Box_Present (Flag15)\n       --  Instance_Spec (Node5-Sem)\n-      --  ABE_Is_Certain (Flag18-Sem)\n \n       --------------------------------------\n       -- 12.7  Formal Package Actual Part --\n@@ -7722,6 +7789,42 @@ package Sinfo is\n    --  reconstructed tree printed by Sprint, and the node descriptions here\n    --  show this syntax.\n \n+      -----------------\n+      -- Call_Marker --\n+      -----------------\n+\n+      --  This node is created during the analysis/resolution of entry calls,\n+      --  requeues, and subprogram calls. It performs several functions:\n+\n+      --    * Call markers provide a uniform model for handling calls by the\n+      --      ABE mechanism, regardless of whether expansion took place.\n+\n+      --    * The call marker captures the target of the related call along\n+      --      with other attributes which are either unavailabe or expensive\n+      --      to recompute once analysis, resolution, and expansion are over.\n+\n+      --    * The call marker aids the ABE Processing phase by signaling the\n+      --      presence of a call in case the original call was transformed by\n+      --      expansion.\n+\n+      --    * The call marker acts as a reference point for the insertion of\n+      --      run-time conditional ABE checks or guaranteed ABE failures.\n+\n+      --  Sprint syntax: #target#\n+\n+      --  The Sprint syntax shown above is not enabled by default\n+\n+      --  N_Call_Marker\n+      --  Sloc points to Sloc of original call\n+      --  Target (Node1-Sem)\n+      --  Is_Elaboration_Checks_OK_Node (Flag1-Sem)\n+      --  Is_SPARK_Mode_On_Node (Flag2-Sem)\n+      --  Is_Dispatching_Call (Flag3-Sem)\n+      --  Is_Source_Call (Flag4-Sem)\n+      --  Is_Declaration_Level_Node (Flag5-Sem)\n+      --  Is_Recorded_Scenario (Flag6-Sem)\n+      --  Is_Known_Guaranteed_ABE (Flag18-Sem)\n+\n       ------------------------\n       -- Compound Statement --\n       ------------------------\n@@ -7851,7 +7954,9 @@ package Sinfo is\n       --  Selector_Name (Node2)\n       --  Entity (Node4-Sem)\n       --  Associated_Node (Node4-Sem)\n-      --  Has_Private_View (Flag11-Sem) set in generic units.\n+      --  Is_Elaboration_Checks_OK_Node (Flag1-Sem)\n+      --  Is_SPARK_Mode_On_Node (Flag2-Sem)\n+      --  Has_Private_View (Flag11-Sem) set in generic units\n       --  Redundant_Use (Flag13-Sem)\n       --  Atomic_Sync_Required (Flag14-Sem)\n       --  plus fields for expression\n@@ -8352,8 +8457,8 @@ package Sinfo is\n    -- Empty --\n    -----------\n \n-   --  Used as the contents of the Nkind field of the dummy Empty node\n-   --  and in some other situations to indicate an uninitialized value.\n+   --  Used as the contents of the Nkind field of the dummy Empty node and in\n+   --  some other situations to indicate an uninitialized value.\n \n    --  N_Empty\n    --  Chars (Name1) is set to No_Name\n@@ -8709,6 +8814,7 @@ package Sinfo is\n       N_Access_Definition,\n       N_Access_To_Object_Definition,\n       N_Aspect_Specification,\n+      N_Call_Marker,\n       N_Case_Expression_Alternative,\n       N_Case_Statement_Alternative,\n       N_Compilation_Unit,\n@@ -8977,9 +9083,6 @@ package Sinfo is\n    --  these routines check that they are being applied to an appropriate\n    --  node, as well as checking that the node is in range.\n \n-   function ABE_Is_Certain\n-     (N : Node_Id) return Boolean;    -- Flag18\n-\n    function Abort_Present\n      (N : Node_Id) return Boolean;    -- Flag15\n \n@@ -9251,7 +9354,7 @@ package Sinfo is\n      (N : Node_Id) return Boolean;    -- Flag13\n \n    function Do_Discriminant_Check\n-     (N : Node_Id) return Boolean;    -- Flag1\n+     (N : Node_Id) return Boolean;    -- Flag3\n \n    function Do_Division_Check\n      (N : Node_Id) return Boolean;    -- Flag13\n@@ -9544,18 +9647,27 @@ package Sinfo is\n    function Is_Controlling_Actual\n      (N : Node_Id) return Boolean;    -- Flag16\n \n+   function Is_Declaration_Level_Node\n+     (N : Node_Id) return Boolean;    -- Flag5\n+\n    function Is_Delayed_Aspect\n      (N : Node_Id) return Boolean;    -- Flag14\n \n    function Is_Disabled\n      (N : Node_Id) return Boolean;    -- Flag15\n \n+   function Is_Dispatching_Call\n+     (N : Node_Id) return Boolean;    -- Flag3\n+\n    function Is_Dynamic_Coextension\n      (N : Node_Id) return Boolean;    -- Flag18\n \n    function Is_Effective_Use_Clause\n      (N : Node_Id) return Boolean;    -- Flag1\n \n+   function Is_Elaboration_Checks_OK_Node\n+     (N : Node_Id) return Boolean;    -- Flag1\n+\n    function Is_Elsif\n      (N : Node_Id) return Boolean;    -- Flag13\n \n@@ -9589,6 +9701,12 @@ package Sinfo is\n    function Is_Inherited_Pragma\n      (N : Node_Id) return Boolean;    -- Flag4\n \n+   function Is_Initialization_Block\n+     (N : Node_Id) return Boolean;    -- Flag1\n+\n+   function Is_Known_Guaranteed_ABE\n+     (N : Node_Id) return Boolean;    -- Flag18\n+\n    function Is_Machine_Number\n      (N : Node_Id) return Boolean;    -- Flag11\n \n@@ -9610,6 +9728,15 @@ package Sinfo is\n    function Is_Qualified_Universal_Literal\n      (N : Node_Id) return Boolean;    -- Flag4\n \n+   function Is_Recorded_Scenario\n+     (N : Node_Id) return Boolean;    -- Flag6\n+\n+   function Is_Source_Call\n+     (N : Node_Id) return Boolean;    -- Flag4\n+\n+   function Is_SPARK_Mode_On_Node\n+     (N : Node_Id) return Boolean;    -- Flag2\n+\n    function Is_Static_Coextension\n      (N : Node_Id) return Boolean;    -- Flag14\n \n@@ -9727,9 +9854,6 @@ package Sinfo is\n    function No_Ctrl_Actions\n      (N : Node_Id) return Boolean;    -- Flag7\n \n-   function No_Elaboration_Check\n-     (N : Node_Id) return Boolean;    -- Flag14\n-\n    function No_Entities_Ref_In_Spec\n      (N : Node_Id) return Boolean;    -- Flag8\n \n@@ -9740,7 +9864,7 @@ package Sinfo is\n      (N : Node_Id) return Boolean;    -- Flag17\n \n    function No_Side_Effect_Removal\n-     (N : Node_Id) return Boolean;    -- Flag1\n+     (N : Node_Id) return Boolean;    -- Flag17\n \n    function No_Truncation\n      (N : Node_Id) return Boolean;    -- Flag17\n@@ -9961,6 +10085,9 @@ package Sinfo is\n    function Tagged_Present\n      (N : Node_Id) return Boolean;    -- Flag15\n \n+   function Target\n+     (N : Node_Id) return Entity_Id;  -- Node1\n+\n    function Target_Type\n      (N : Node_Id) return Entity_Id;  -- Node2\n \n@@ -10021,6 +10148,9 @@ package Sinfo is\n    function Used_Operations\n      (N : Node_Id) return Elist_Id;   -- Elist2\n \n+   function Was_Attribute_Reference\n+     (N : Node_Id) return Boolean;    -- Flag2\n+\n    function Was_Expression_Function\n      (N : Node_Id) return Boolean;    -- Flag18\n \n@@ -10042,9 +10172,6 @@ package Sinfo is\n    --  tree pointers (List1-4), the parent pointer of the Val node is set to\n    --  point back to node N. This automates the setting of the parent pointer.\n \n-   procedure Set_ABE_Is_Certain\n-     (N : Node_Id; Val : Boolean := True);    -- Flag18\n-\n    procedure Set_Abort_Present\n      (N : Node_Id; Val : Boolean := True);    -- Flag15\n \n@@ -10316,7 +10443,7 @@ package Sinfo is\n      (N : Node_Id; Val : Boolean := True);    -- Flag13\n \n    procedure Set_Do_Discriminant_Check\n-     (N : Node_Id; Val : Boolean := True);    -- Flag1\n+     (N : Node_Id; Val : Boolean := True);    -- Flag3\n \n    procedure Set_Do_Division_Check\n      (N : Node_Id; Val : Boolean := True);    -- Flag13\n@@ -10606,18 +10733,27 @@ package Sinfo is\n    procedure Set_Is_Controlling_Actual\n      (N : Node_Id; Val : Boolean := True);    -- Flag16\n \n+   procedure Set_Is_Declaration_Level_Node\n+     (N : Node_Id; Val : Boolean := True);    -- Flag5\n+\n    procedure Set_Is_Delayed_Aspect\n      (N : Node_Id; Val : Boolean := True);    -- Flag14\n \n    procedure Set_Is_Disabled\n      (N : Node_Id; Val : Boolean := True);    -- Flag15\n \n+   procedure Set_Is_Dispatching_Call\n+     (N : Node_Id; Val : Boolean := True);    -- Flag3\n+\n    procedure Set_Is_Dynamic_Coextension\n      (N : Node_Id; Val : Boolean := True);    -- Flag18\n \n    procedure Set_Is_Effective_Use_Clause\n      (N : Node_Id; Val : Boolean := True);    -- Flag1\n \n+   procedure Set_Is_Elaboration_Checks_OK_Node\n+     (N : Node_Id; Val : Boolean := True);    -- Flag1\n+\n    procedure Set_Is_Elsif\n      (N : Node_Id; Val : Boolean := True);    -- Flag13\n \n@@ -10651,6 +10787,12 @@ package Sinfo is\n    procedure Set_Is_Inherited_Pragma\n      (N : Node_Id; Val : Boolean := True);    -- Flag4\n \n+   procedure Set_Is_Initialization_Block\n+     (N : Node_Id; Val : Boolean := True);    -- Flag1\n+\n+   procedure Set_Is_Known_Guaranteed_ABE\n+     (N : Node_Id; Val : Boolean := True);    -- Flag18\n+\n    procedure Set_Is_Machine_Number\n      (N : Node_Id; Val : Boolean := True);    -- Flag11\n \n@@ -10672,6 +10814,15 @@ package Sinfo is\n    procedure Set_Is_Qualified_Universal_Literal\n      (N : Node_Id; Val : Boolean := True);    -- Flag4\n \n+   procedure Set_Is_Recorded_Scenario\n+     (N : Node_Id; Val : Boolean := True);    -- Flag6\n+\n+   procedure Set_Is_Source_Call\n+     (N : Node_Id; Val : Boolean := True);    -- Flag4\n+\n+   procedure Set_Is_SPARK_Mode_On_Node\n+     (N : Node_Id; Val : Boolean := True);    -- Flag2\n+\n    procedure Set_Is_Static_Coextension\n      (N : Node_Id; Val : Boolean := True);    -- Flag14\n \n@@ -10789,9 +10940,6 @@ package Sinfo is\n    procedure Set_No_Ctrl_Actions\n      (N : Node_Id; Val : Boolean := True);    -- Flag7\n \n-   procedure Set_No_Elaboration_Check\n-     (N : Node_Id; Val : Boolean := True);    -- Flag14\n-\n    procedure Set_No_Entities_Ref_In_Spec\n      (N : Node_Id; Val : Boolean := True);    -- Flag8\n \n@@ -10802,7 +10950,7 @@ package Sinfo is\n      (N : Node_Id; Val : Boolean := True);    -- Flag17\n \n    procedure Set_No_Side_Effect_Removal\n-     (N : Node_Id; Val : Boolean := True);    -- Flag1\n+     (N : Node_Id; Val : Boolean := True);    -- Flag17\n \n    procedure Set_No_Truncation\n      (N : Node_Id; Val : Boolean := True);    -- Flag17\n@@ -11023,6 +11171,9 @@ package Sinfo is\n    procedure Set_Tagged_Present\n      (N : Node_Id; Val : Boolean := True);    -- Flag15\n \n+   procedure Set_Target\n+     (N : Node_Id; Val : Entity_Id);          -- Node1\n+\n    procedure Set_Target_Type\n      (N : Node_Id; Val : Entity_Id);          -- Node2\n \n@@ -11083,6 +11234,9 @@ package Sinfo is\n    procedure Set_Used_Operations\n      (N : Node_Id; Val : Elist_Id);           -- Elist2\n \n+   procedure Set_Was_Attribute_Reference\n+     (N : Node_Id; Val : Boolean := True);    -- Flag2\n+\n    procedure Set_Was_Expression_Function\n      (N : Node_Id; Val : Boolean := True);    -- Flag18\n \n@@ -12854,6 +13008,13 @@ package Sinfo is\n         4 => False,   --  SCIL_Entity (Node4-Sem)\n         5 => False),  --  SCIL_Tag_Value (Node5-Sem)\n \n+     N_Call_Marker =>\n+       (1 => True,    --  Target (Node1-Sem)\n+        2 => False,   --  unused\n+        3 => False,   --  unused\n+        4 => False,   --  unused\n+        5 => False),  --  unused\n+\n    --  Entries for Empty, Error and Unused. Even thought these have a Chars\n    --  field for debugging purposes, they are not really syntactic fields, so\n    --  we mark all fields as unused.\n@@ -12890,7 +13051,6 @@ package Sinfo is\n    -- Inline Pragmas --\n    --------------------\n \n-   pragma Inline (ABE_Is_Certain);\n    pragma Inline (Abort_Present);\n    pragma Inline (Abortable_Part);\n    pragma Inline (Abstract_Present);\n@@ -12988,10 +13148,10 @@ package Sinfo is\n    pragma Inline (Do_Range_Check);\n    pragma Inline (Do_Storage_Check);\n    pragma Inline (Do_Tag_Check);\n-   pragma Inline (Elaborate_Present);\n    pragma Inline (Elaborate_All_Desirable);\n    pragma Inline (Elaborate_All_Present);\n    pragma Inline (Elaborate_Desirable);\n+   pragma Inline (Elaborate_Present);\n    pragma Inline (Else_Actions);\n    pragma Inline (Else_Statements);\n    pragma Inline (Elsif_Parts);\n@@ -13080,10 +13240,13 @@ package Sinfo is\n    pragma Inline (Is_Component_Left_Opnd);\n    pragma Inline (Is_Component_Right_Opnd);\n    pragma Inline (Is_Controlling_Actual);\n+   pragma Inline (Is_Declaration_Level_Node);\n    pragma Inline (Is_Delayed_Aspect);\n    pragma Inline (Is_Disabled);\n+   pragma Inline (Is_Dispatching_Call);\n    pragma Inline (Is_Dynamic_Coextension);\n    pragma Inline (Is_Effective_Use_Clause);\n+   pragma Inline (Is_Elaboration_Checks_OK_Node);\n    pragma Inline (Is_Elsif);\n    pragma Inline (Is_Entry_Barrier_Function);\n    pragma Inline (Is_Expanded_Build_In_Place_Call);\n@@ -13095,13 +13258,18 @@ package Sinfo is\n    pragma Inline (Is_Ignored_Ghost_Pragma);\n    pragma Inline (Is_In_Discriminant_Check);\n    pragma Inline (Is_Inherited_Pragma);\n+   pragma Inline (Is_Initialization_Block);\n+   pragma Inline (Is_Known_Guaranteed_ABE);\n    pragma Inline (Is_Machine_Number);\n    pragma Inline (Is_Null_Loop);\n    pragma Inline (Is_Overloaded);\n    pragma Inline (Is_Power_Of_2_For_Shift);\n    pragma Inline (Is_Prefixed_Call);\n    pragma Inline (Is_Protected_Subprogram_Body);\n    pragma Inline (Is_Qualified_Universal_Literal);\n+   pragma Inline (Is_Recorded_Scenario);\n+   pragma Inline (Is_Source_Call);\n+   pragma Inline (Is_SPARK_Mode_On_Node);\n    pragma Inline (Is_Static_Coextension);\n    pragma Inline (Is_Static_Expression);\n    pragma Inline (Is_Subprogram_Descriptor);\n@@ -13140,7 +13308,6 @@ package Sinfo is\n    pragma Inline (Next_Rep_Item);\n    pragma Inline (Next_Use_Clause);\n    pragma Inline (No_Ctrl_Actions);\n-   pragma Inline (No_Elaboration_Check);\n    pragma Inline (No_Entities_Ref_In_Spec);\n    pragma Inline (No_Initialization);\n    pragma Inline (No_Minimize_Eliminate);\n@@ -13218,6 +13385,7 @@ package Sinfo is\n    pragma Inline (Suppress_Loop_Warnings);\n    pragma Inline (Synchronized_Present);\n    pragma Inline (Tagged_Present);\n+   pragma Inline (Target);\n    pragma Inline (Target_Type);\n    pragma Inline (Task_Definition);\n    pragma Inline (Task_Present);\n@@ -13238,11 +13406,11 @@ package Sinfo is\n    pragma Inline (Variants);\n    pragma Inline (Visible_Declarations);\n    pragma Inline (Used_Operations);\n+   pragma Inline (Was_Attribute_Reference);\n    pragma Inline (Was_Expression_Function);\n    pragma Inline (Was_Originally_Stub);\n    pragma Inline (Withed_Body);\n \n-   pragma Inline (Set_ABE_Is_Certain);\n    pragma Inline (Set_Abort_Present);\n    pragma Inline (Set_Abortable_Part);\n    pragma Inline (Set_Abstract_Present);\n@@ -13429,10 +13597,13 @@ package Sinfo is\n    pragma Inline (Set_Is_Component_Left_Opnd);\n    pragma Inline (Set_Is_Component_Right_Opnd);\n    pragma Inline (Set_Is_Controlling_Actual);\n+   pragma Inline (Set_Is_Declaration_Level_Node);\n    pragma Inline (Set_Is_Delayed_Aspect);\n    pragma Inline (Set_Is_Disabled);\n+   pragma Inline (Set_Is_Dispatching_Call);\n    pragma Inline (Set_Is_Dynamic_Coextension);\n    pragma Inline (Set_Is_Effective_Use_Clause);\n+   pragma Inline (Set_Is_Elaboration_Checks_OK_Node);\n    pragma Inline (Set_Is_Elsif);\n    pragma Inline (Set_Is_Entry_Barrier_Function);\n    pragma Inline (Set_Is_Expanded_Build_In_Place_Call);\n@@ -13444,13 +13615,18 @@ package Sinfo is\n    pragma Inline (Set_Is_Ignored_Ghost_Pragma);\n    pragma Inline (Set_Is_In_Discriminant_Check);\n    pragma Inline (Set_Is_Inherited_Pragma);\n+   pragma Inline (Set_Is_Initialization_Block);\n+   pragma Inline (Set_Is_Known_Guaranteed_ABE);\n    pragma Inline (Set_Is_Machine_Number);\n    pragma Inline (Set_Is_Null_Loop);\n    pragma Inline (Set_Is_Overloaded);\n    pragma Inline (Set_Is_Power_Of_2_For_Shift);\n    pragma Inline (Set_Is_Prefixed_Call);\n    pragma Inline (Set_Is_Protected_Subprogram_Body);\n    pragma Inline (Set_Is_Qualified_Universal_Literal);\n+   pragma Inline (Set_Is_Recorded_Scenario);\n+   pragma Inline (Set_Is_Source_Call);\n+   pragma Inline (Set_Is_SPARK_Mode_On_Node);\n    pragma Inline (Set_Is_Static_Coextension);\n    pragma Inline (Set_Is_Static_Expression);\n    pragma Inline (Set_Is_Subprogram_Descriptor);\n@@ -13490,7 +13666,6 @@ package Sinfo is\n    pragma Inline (Set_Next_Rep_Item);\n    pragma Inline (Set_Next_Use_Clause);\n    pragma Inline (Set_No_Ctrl_Actions);\n-   pragma Inline (Set_No_Elaboration_Check);\n    pragma Inline (Set_No_Entities_Ref_In_Spec);\n    pragma Inline (Set_No_Initialization);\n    pragma Inline (Set_No_Minimize_Eliminate);\n@@ -13567,6 +13742,7 @@ package Sinfo is\n    pragma Inline (Set_Synchronized_Present);\n    pragma Inline (Set_TSS_Elist);\n    pragma Inline (Set_Tagged_Present);\n+   pragma Inline (Set_Target);\n    pragma Inline (Set_Target_Type);\n    pragma Inline (Set_Task_Definition);\n    pragma Inline (Set_Task_Present);\n@@ -13586,6 +13762,7 @@ package Sinfo is\n    pragma Inline (Set_Variant_Part);\n    pragma Inline (Set_Variants);\n    pragma Inline (Set_Visible_Declarations);\n+   pragma Inline (Set_Was_Attribute_Reference);\n    pragma Inline (Set_Was_Expression_Function);\n    pragma Inline (Set_Was_Originally_Stub);\n    pragma Inline (Set_Withed_Body);"}, {"sha": "ac2dcd8a14de1344b3c0047d30a8b62480d7a02b", "filename": "gcc/ada/sprint.adb", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e491a7739dc2ae9a5b92945e4f0e48a3a91e39/gcc%2Fada%2Fsprint.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e491a7739dc2ae9a5b92945e4f0e48a3a91e39/gcc%2Fada%2Fsprint.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsprint.adb?ref=90e491a7739dc2ae9a5b92945e4f0e48a3a91e39", "patch": "@@ -1225,6 +1225,15 @@ package body Sprint is\n \n             Write_Char (';');\n \n+         when N_Call_Marker =>\n+            null;\n+\n+            --  Enable the following code for debugging purposes only\n+\n+            --  Write_Indent_Str (\"#\");\n+            --  Write_Id (Target (Node));\n+            --  Write_Char ('#');\n+\n          when N_Case_Expression =>\n             declare\n                Has_Parens : constant Boolean := Paren_Count (Node) > 0;"}]}