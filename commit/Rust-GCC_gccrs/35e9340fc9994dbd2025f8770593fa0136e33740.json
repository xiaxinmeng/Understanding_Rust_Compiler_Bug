{"sha": "35e9340fc9994dbd2025f8770593fa0136e33740", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzVlOTM0MGZjOTk5NGRiZDIwMjVmODc3MDU5M2ZhMDEzNmUzMzc0MA==", "commit": {"author": {"name": "Hans-Peter Nilsson", "email": "hp@bitrange.com", "date": "2000-11-03T20:26:51Z"}, "committer": {"name": "Hans-Peter Nilsson", "email": "hp@gcc.gnu.org", "date": "2000-11-03T20:26:51Z"}, "message": "(htab_create, htab_expand): Correct formatting of comment before\n\tfunction.\n\nFrom-SVN: r37231", "tree": {"sha": "7cb5f41487a2833118881f736e98db2f43fe7b5f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7cb5f41487a2833118881f736e98db2f43fe7b5f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/35e9340fc9994dbd2025f8770593fa0136e33740", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35e9340fc9994dbd2025f8770593fa0136e33740", "html_url": "https://github.com/Rust-GCC/gccrs/commit/35e9340fc9994dbd2025f8770593fa0136e33740", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35e9340fc9994dbd2025f8770593fa0136e33740/comments", "author": null, "committer": null, "parents": [{"sha": "5aa2300021e4f424c8b3e4fb951fd21540dd8324", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5aa2300021e4f424c8b3e4fb951fd21540dd8324", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5aa2300021e4f424c8b3e4fb951fd21540dd8324"}], "stats": {"total": 78, "additions": 42, "deletions": 36}, "files": [{"sha": "5496ff3ec52e9efeff675d164a70fa1030a22f30", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35e9340fc9994dbd2025f8770593fa0136e33740/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35e9340fc9994dbd2025f8770593fa0136e33740/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=35e9340fc9994dbd2025f8770593fa0136e33740", "patch": "@@ -1,3 +1,9 @@\n+2000-11-03  Hans-Peter Nilsson  <hp@bitrange.com>\n+\n+\t* hashtab.c: Change void * to PTR where necessary.\n+\t(htab_create, htab_expand): Correct formatting of comment before\n+\tfunction.\n+\n 2000-10-22  Alex Samuel  <samuel@codesourcery.com>\n \n \t* cp-demangle.c (string_list_def): Add caret_position and comments."}, {"sha": "4bcccee3aaf5cd23098720ea019958975860b335", "filename": "libiberty/hashtab.c", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35e9340fc9994dbd2025f8770593fa0136e33740/libiberty%2Fhashtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35e9340fc9994dbd2025f8770593fa0136e33740/libiberty%2Fhashtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fhashtab.c?ref=35e9340fc9994dbd2025f8770593fa0136e33740", "patch": "@@ -52,18 +52,18 @@ Boston, MA 02111-1307, USA.  */\n \n /* This macro defines reserved value for empty table entry. */\n \n-#define EMPTY_ENTRY    ((void *) 0)\n+#define EMPTY_ENTRY    ((PTR) 0)\n \n /* This macro defines reserved value for table entry which contained\n    a deleted element. */\n \n-#define DELETED_ENTRY  ((void *) 1)\n+#define DELETED_ENTRY  ((PTR) 1)\n \n static unsigned long higher_prime_number PARAMS ((unsigned long));\n static hashval_t hash_pointer PARAMS ((const void *));\n static int eq_pointer PARAMS ((const void *, const void *));\n static void htab_expand PARAMS ((htab_t));\n-static void **find_empty_slot_for_expand  PARAMS ((htab_t, hashval_t));\n+static PTR *find_empty_slot_for_expand  PARAMS ((htab_t, hashval_t));\n \n /* At some point, we could make these be NULL, and modify the\n    hash-table routines to handle NULL specially; that would avoid\n@@ -106,7 +106,7 @@ higher_prime_number (n)\n \n static hashval_t\n hash_pointer (p)\n-     const void *p;\n+     const PTR p;\n {\n   return (hashval_t) ((long)p >> 3);\n }\n@@ -115,16 +115,16 @@ hash_pointer (p)\n \n static int\n eq_pointer (p1, p2)\n-     const void *p1;\n-     const void *p2;\n+     const PTR p1;\n+     const PTR p2;\n {\n   return p1 == p2;\n }\n \n /* This function creates table with length slightly longer than given\n    source length.  Created hash table is initiated as empty (all the\n    hash table entries are EMPTY_ENTRY).  The function returns the\n-   created hash table. */\n+   created hash table.  */\n \n htab_t\n htab_create (size, hash_f, eq_f, del_f)\n@@ -137,7 +137,7 @@ htab_create (size, hash_f, eq_f, del_f)\n \n   size = higher_prime_number (size);\n   result = (htab_t) xcalloc (1, sizeof (struct htab));\n-  result->entries = (void **) xcalloc (size, sizeof (void *));\n+  result->entries = (PTR *) xcalloc (size, sizeof (PTR));\n   result->size = size;\n   result->hash_f = hash_f;\n   result->eq_f = eq_f;\n@@ -178,7 +178,7 @@ htab_empty (htab)\n \t  && htab->entries[i] != DELETED_ENTRY)\n \t(*htab->del_f) (htab->entries[i]);\n \n-  memset (htab->entries, 0, htab->size * sizeof (void *));\n+  memset (htab->entries, 0, htab->size * sizeof (PTR));\n }\n \n /* Similar to htab_find_slot, but without several unwanted side effects:\n@@ -188,7 +188,7 @@ htab_empty (htab)\n    This function also assumes there are no deleted entries in the table.\n    HASH is the hash value for the element to be inserted.  */\n \n-static void **\n+static PTR *\n find_empty_slot_for_expand (htab, hash)\n      htab_t htab;\n      hashval_t hash;\n@@ -199,7 +199,7 @@ find_empty_slot_for_expand (htab, hash)\n \n   for (;;)\n     {\n-      void **slot = htab->entries + index;\n+      PTR *slot = htab->entries + index;\n \n       if (*slot == EMPTY_ENTRY)\n \treturn slot;\n@@ -216,33 +216,33 @@ find_empty_slot_for_expand (htab, hash)\n    entries and repeatedly inserts the table elements.  The occupancy\n    of the table after the call will be about 50%.  Naturally the hash\n    table must already exist.  Remember also that the place of the\n-   table entries is changed. */\n+   table entries is changed.  */\n \n static void\n htab_expand (htab)\n      htab_t htab;\n {\n-  void **oentries;\n-  void **olimit;\n-  void **p;\n+  PTR *oentries;\n+  PTR *olimit;\n+  PTR *p;\n \n   oentries = htab->entries;\n   olimit = oentries + htab->size;\n \n   htab->size = higher_prime_number (htab->size * 2);\n-  htab->entries = (void **) xcalloc (htab->size, sizeof (void **));\n+  htab->entries = (PTR *) xcalloc (htab->size, sizeof (PTR *));\n \n   htab->n_elements -= htab->n_deleted;\n   htab->n_deleted = 0;\n \n   p = oentries;\n   do\n     {\n-      void *x = *p;\n+      PTR x = *p;\n \n       if (x != EMPTY_ENTRY && x != DELETED_ENTRY)\n \t{\n-\t  void **q = find_empty_slot_for_expand (htab, (*htab->hash_f) (x));\n+\t  PTR *q = find_empty_slot_for_expand (htab, (*htab->hash_f) (x));\n \n \t  *q = x;\n \t}\n@@ -257,16 +257,16 @@ htab_expand (htab)\n /* This function searches for a hash table entry equal to the given\n    element.  It cannot be used to insert or delete an element.  */\n \n-void *\n+PTR\n htab_find_with_hash (htab, element, hash)\n      htab_t htab;\n-     const void *element;\n+     const PTR element;\n      hashval_t hash;\n {\n   unsigned int index;\n   hashval_t hash2;\n   size_t size;\n-  void *entry;\n+  PTR entry;\n \n   htab->searches++;\n   size = htab->size;\n@@ -296,10 +296,10 @@ htab_find_with_hash (htab, element, hash)\n /* Like htab_find_slot_with_hash, but compute the hash value from the\n    element.  */\n \n-void *\n+PTR\n htab_find (htab, element)\n      htab_t htab;\n-     const void *element;\n+     const PTR element;\n {\n   return htab_find_with_hash (htab, element, (*htab->hash_f) (element));\n }\n@@ -310,14 +310,14 @@ htab_find (htab, element)\n    after doing some checks).  To insert an entry, call this with\n    INSERT = 1, then write the value you want into the returned slot.  */\n \n-void **\n+PTR *\n htab_find_slot_with_hash (htab, element, hash, insert)\n      htab_t htab;\n-     const void *element;\n+     const PTR element;\n      hashval_t hash;\n      enum insert_option insert;\n {\n-  void **first_deleted_slot;\n+  PTR *first_deleted_slot;\n   unsigned int index;\n   hashval_t hash2;\n   size_t size;\n@@ -334,7 +334,7 @@ htab_find_slot_with_hash (htab, element, hash, insert)\n \n   for (;;)\n     {\n-      void *entry = htab->entries[index];\n+      PTR entry = htab->entries[index];\n       if (entry == EMPTY_ENTRY)\n \t{\n \t  if (insert == NO_INSERT)\n@@ -369,10 +369,10 @@ htab_find_slot_with_hash (htab, element, hash, insert)\n /* Like htab_find_slot_with_hash, but compute the hash value from the\n    element.  */\n \n-void **\n+PTR *\n htab_find_slot (htab, element, insert)\n      htab_t htab;\n-     const void *element;\n+     const PTR element;\n      enum insert_option insert;\n {\n   return htab_find_slot_with_hash (htab, element, (*htab->hash_f) (element),\n@@ -386,9 +386,9 @@ htab_find_slot (htab, element, insert)\n void\n htab_remove_elt (htab, element)\n      htab_t htab;\n-     void *element;\n+     PTR element;\n {\n-  void **slot;\n+  PTR *slot;\n \n   slot = htab_find_slot (htab, element, NO_INSERT);\n   if (*slot == EMPTY_ENTRY)\n@@ -408,7 +408,7 @@ htab_remove_elt (htab, element)\n void\n htab_clear_slot (htab, slot)\n      htab_t htab;\n-     void **slot;\n+     PTR *slot;\n {\n   if (slot < htab->entries || slot >= htab->entries + htab->size\n       || *slot == EMPTY_ENTRY || *slot == DELETED_ENTRY)\n@@ -430,14 +430,14 @@ void\n htab_traverse (htab, callback, info)\n      htab_t htab;\n      htab_trav callback;\n-     void *info;\n+     PTR info;\n {\n-  void **slot = htab->entries;\n-  void **limit = slot + htab->size;\n+  PTR *slot = htab->entries;\n+  PTR *limit = slot + htab->size;\n \n   do\n     {\n-      void *x = *slot;\n+      PTR x = *slot;\n \n       if (x != EMPTY_ENTRY && x != DELETED_ENTRY)\n \tif (!(*callback) (slot, info))"}]}