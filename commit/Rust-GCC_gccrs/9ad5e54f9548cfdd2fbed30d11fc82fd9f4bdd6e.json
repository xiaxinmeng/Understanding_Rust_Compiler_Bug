{"sha": "9ad5e54f9548cfdd2fbed30d11fc82fd9f4bdd6e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWFkNWU1NGY5NTQ4Y2ZkZDJmYmVkMzBkMTFmYzgyZmQ5ZjRiZGQ2ZQ==", "commit": {"author": {"name": "Rask Ingemann Lambertsen", "email": "rask@sygehus.dk", "date": "2007-10-22T11:50:56Z"}, "committer": {"name": "Rask Ingemann Lambertsen", "email": "rask@gcc.gnu.org", "date": "2007-10-22T11:50:56Z"}, "message": "re PR target/29473 (-masm=intel combined with -march=athlon64 has some issues.)\n\n\tPR target/29473\n\tPR target/29493\n\t* config/i386/i386.c (output_pic_addr_const): Support Intel asm syntax.\n\t(print_reg): Print register prefix only with AT&T asm syntax. \n\tSupport pc_rtx for RIP register.\n\t(print_operand_address): Use print_reg()'s pc_rtx support for RIP\n\trelative addressing.  Always print segment register prefix with AT&T\n\tasm syntax and never with Intel asm syntax.\n\t(print_operand): Suppress 'XXX PTR' prefix for BLKmode operands. \n\tFix prefix for 16-byte XFmode operands.\n\t(output_addr_const_extra): Support Intel asm syntax.\n\t(x86_file_start): Don't use register prefix with Intel asm syntax.\n\t* config/i386/i386.md (\"*zero_extendqihi2_movzbl\"): Fix typo.\n\t(\"return_internal_long\"): Fix Intel asm syntax output.\n\t(\"set_got_rex64\"): Support Intel asm syntax.\n\t(\"set_rip_rex64\"): Likewise.\n\t(\"set_got_offset_rex64\"): Likewise.\n\t(\"*sibcall_1_rex64_v\"): Print register prefix only with AT&T asm\n\tsyntax.\n\t(\"*tls_global_dynamic_64\"): Likewise.\n\t(\"*tls_local_dynamic_base_64\"): Likewise.\n\t(\"*load_tp_si\")(\"*load_tp_di\"): Likewise.\n\t(\"*add_tp_si\")(\"*add_tp_di\"): Likewise.\n\t(\"*tls_dynamic_lea_64\"): Likewise.\n\t(\"*sibcall_value_1_rex64_v\"): Likewise.\n\t(\"stack_tls_protect_set_si\"): Likewise.\n\t(\"stack_tls_protect_set_di\"): Likewise.\n\t(\"stack_tls_protect_test_si\"): Likewise.\n\t(\"stack_tls_protect_test_di\"): Likewise.\n\t* config/i386/mmx.md (\"*mov<mode>_internal_rex64\"): Fix Intel asm\n\tsyntax output.\n\t(\"*movv2sf_internal_rex64\"): Likewise.\n\t* config/i386/cpuid.h (__cpuid): Support Intel asm syntax.\n\t(__get_cpuid_max): Likewise.\n\nFrom-SVN: r129548", "tree": {"sha": "8bc43e5e38b767924c7f0cdb1c531b5bb2dddc8c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8bc43e5e38b767924c7f0cdb1c531b5bb2dddc8c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9ad5e54f9548cfdd2fbed30d11fc82fd9f4bdd6e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ad5e54f9548cfdd2fbed30d11fc82fd9f4bdd6e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ad5e54f9548cfdd2fbed30d11fc82fd9f4bdd6e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ad5e54f9548cfdd2fbed30d11fc82fd9f4bdd6e/comments", "author": null, "committer": null, "parents": [{"sha": "cc6c53a3f7b78f1212db92b35f3ef7a904427496", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc6c53a3f7b78f1212db92b35f3ef7a904427496", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc6c53a3f7b78f1212db92b35f3ef7a904427496"}], "stats": {"total": 188, "additions": 120, "deletions": 68}, "files": [{"sha": "620d7877ad6fb436c0cd3e00f0e340654a6e545c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ad5e54f9548cfdd2fbed30d11fc82fd9f4bdd6e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ad5e54f9548cfdd2fbed30d11fc82fd9f4bdd6e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9ad5e54f9548cfdd2fbed30d11fc82fd9f4bdd6e", "patch": "@@ -1,3 +1,40 @@\n+2007-10-22  Rask Ingemann Lambertsen  <rask@sygehus.dk>\n+\n+\tPR target/29473\n+\tPR target/29493\n+\t* config/i386/i386.c (output_pic_addr_const): Support Intel asm syntax.\n+\t(print_reg): Print register prefix only with AT&T asm syntax. \n+\tSupport pc_rtx for RIP register.\n+\t(print_operand_address): Use print_reg()'s pc_rtx support for RIP\n+\trelative addressing.  Always print segment register prefix with AT&T\n+\tasm syntax and never with Intel asm syntax.\n+\t(print_operand): Suppress 'XXX PTR' prefix for BLKmode operands. \n+\tFix prefix for 16-byte XFmode operands.\n+\t(output_addr_const_extra): Support Intel asm syntax.\n+\t(x86_file_start): Don't use register prefix with Intel asm syntax.\n+\t* config/i386/i386.md (\"*zero_extendqihi2_movzbl\"): Fix typo.\n+\t(\"return_internal_long\"): Fix Intel asm syntax output.\n+\t(\"set_got_rex64\"): Support Intel asm syntax.\n+\t(\"set_rip_rex64\"): Likewise.\n+\t(\"set_got_offset_rex64\"): Likewise.\n+\t(\"*sibcall_1_rex64_v\"): Print register prefix only with AT&T asm\n+\tsyntax.\n+\t(\"*tls_global_dynamic_64\"): Likewise.\n+\t(\"*tls_local_dynamic_base_64\"): Likewise.\n+\t(\"*load_tp_si\")(\"*load_tp_di\"): Likewise.\n+\t(\"*add_tp_si\")(\"*add_tp_di\"): Likewise.\n+\t(\"*tls_dynamic_lea_64\"): Likewise.\n+\t(\"*sibcall_value_1_rex64_v\"): Likewise.\n+\t(\"stack_tls_protect_set_si\"): Likewise.\n+\t(\"stack_tls_protect_set_di\"): Likewise.\n+\t(\"stack_tls_protect_test_si\"): Likewise.\n+\t(\"stack_tls_protect_test_di\"): Likewise.\n+\t* config/i386/mmx.md (\"*mov<mode>_internal_rex64\"): Fix Intel asm\n+\tsyntax output.\n+\t(\"*movv2sf_internal_rex64\"): Likewise.\n+\t* config/i386/cpuid.h (__cpuid): Support Intel asm syntax.\n+\t(__get_cpuid_max): Likewise.\n+\n 2007-10-21  Richard Sandiford  <rsandifo@nildram.co.uk>\n \n \t* config/mips/mips-protos.h (mips_regno_mode_ok_for_base_p): Give"}, {"sha": "7fa4f681547c043bcffb785a2a2e5ad3299bcf4a", "filename": "gcc/config/i386/cpuid.h", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ad5e54f9548cfdd2fbed30d11fc82fd9f4bdd6e/gcc%2Fconfig%2Fi386%2Fcpuid.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ad5e54f9548cfdd2fbed30d11fc82fd9f4bdd6e/gcc%2Fconfig%2Fi386%2Fcpuid.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fcpuid.h?ref=9ad5e54f9548cfdd2fbed30d11fc82fd9f4bdd6e", "patch": "@@ -62,9 +62,9 @@\n #if defined(__i386__) && defined(__PIC__)\n /* %ebx may be the PIC register.  */\n #define __cpuid(level, a, b, c, d)\t\t\t\\\n-  __asm__ (\"xchgl\\t%%ebx, %1\\n\\t\"\t\t\t\\\n+  __asm__ (\"xchg{l}\\t{%%}ebx, %1\\n\\t\"\t\t\t\\\n \t   \"cpuid\\n\\t\"\t\t\t\t\t\\\n-\t   \"xchgl\\t%%ebx, %1\\n\\t\"\t\t\t\\\n+\t   \"xchg{l}\\t{%%}ebx, %1\\n\\t\"\t\t\t\\\n \t   : \"=a\" (a), \"=r\" (b), \"=c\" (c), \"=d\" (d)\t\\\n \t   : \"0\" (level))\n #else\n@@ -88,16 +88,16 @@ __get_cpuid_max (unsigned int __ext, unsigned int *__sig)\n \n #ifndef __x86_64__\n   /* See if we can use cpuid.  On AMD64 we always can.  */\n-  __asm__ (\"pushfl\\n\\t\"\n-\t   \"pushfl\\n\\t\"\n-\t   \"popl\\t%0\\n\\t\"\n-\t   \"movl\\t%0, %1\\n\\t\"\n-\t   \"xorl\\t%2, %0\\n\\t\"\n-\t   \"pushl\\t%0\\n\\t\"\n-\t   \"popfl\\n\\t\"\n-\t   \"pushfl\\n\\t\"\n-\t   \"popl\\t%0\\n\\t\"\n-\t   \"popfl\\n\\t\"\n+  __asm__ (\"pushf{l|d}\\n\\t\"\n+\t   \"pushf{l|d}\\n\\t\"\n+\t   \"pop{l}\\t%0\\n\\t\"\n+\t   \"mov{l}\\t{%0, %1|%1, %0}\\n\\t\"\n+\t   \"xor{l}\\t{%2, %0|%0, %2}\\n\\t\"\n+\t   \"push{l}\\t%0\\n\\t\"\n+\t   \"popf{l|d}\\n\\t\"\n+\t   \"pushf{l|d}\\n\\t\"\n+\t   \"pop{l}\\t%0\\n\\t\"\n+\t   \"popf{l|d}\\n\\t\"\n \t   : \"=&r\" (__eax), \"=&r\" (__ebx)\n \t   : \"i\" (0x00200000));\n "}, {"sha": "0429d239efaf938d08666b1b0472e457bde5e388", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 47, "deletions": 32, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ad5e54f9548cfdd2fbed30d11fc82fd9f4bdd6e/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ad5e54f9548cfdd2fbed30d11fc82fd9f4bdd6e/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=9ad5e54f9548cfdd2fbed30d11fc82fd9f4bdd6e", "patch": "@@ -8185,7 +8185,8 @@ output_pic_addr_const (FILE *file, rtx x, int code)\n \t  fputs (\"@PLTOFF\", file);\n \t  break;\n \tcase UNSPEC_GOTPCREL:\n-\t  fputs (\"@GOTPCREL(%rip)\", file);\n+\t  fputs (ASSEMBLER_DIALECT == ASM_ATT ?\n+\t\t \"@GOTPCREL(%rip)\" : \"@GOTPCREL[rip]\", file);\n \t  break;\n \tcase UNSPEC_GOTTPOFF:\n \t  /* FIXME: This might be @TPOFF in Sun ld too.  */\n@@ -8205,7 +8206,8 @@ output_pic_addr_const (FILE *file, rtx x, int code)\n \t  break;\n \tcase UNSPEC_GOTNTPOFF:\n \t  if (TARGET_64BIT)\n-\t    fputs (\"@GOTTPOFF(%rip)\", file);\n+\t    fputs (ASSEMBLER_DIALECT == ASM_ATT ?\n+\t\t   \"@GOTTPOFF(%rip)\": \"@GOTTPOFF[rip]\", file);\n \t  else\n \t    fputs (\"@GOTNTPOFF\", file);\n \t  break;\n@@ -8531,15 +8533,23 @@ put_condition_code (enum rtx_code code, enum machine_mode mode, int reverse,\n void\n print_reg (rtx x, int code, FILE *file)\n {\n-  gcc_assert (REGNO (x) != ARG_POINTER_REGNUM\n-\t      && REGNO (x) != FRAME_POINTER_REGNUM\n-\t      && REGNO (x) != FLAGS_REG\n-\t      && REGNO (x) != FPSR_REG\n-\t      && REGNO (x) != FPCR_REG);\n+  gcc_assert (x == pc_rtx\n+\t      || (REGNO (x) != ARG_POINTER_REGNUM\n+\t\t  && REGNO (x) != FRAME_POINTER_REGNUM\n+\t\t  && REGNO (x) != FLAGS_REG\n+\t\t  && REGNO (x) != FPSR_REG\n+\t\t  && REGNO (x) != FPCR_REG));\n \n-  if (ASSEMBLER_DIALECT == ASM_ATT || USER_LABEL_PREFIX[0] == 0)\n+  if (ASSEMBLER_DIALECT == ASM_ATT)\n     putc ('%', file);\n \n+  if (x == pc_rtx)\n+    {\n+      gcc_assert (TARGET_64BIT);\n+      fputs (\"rip\", file);\n+      return;\n+    }\n+\n   if (code == 'w' || MMX_REG_P (x))\n     code = 2;\n   else if (code == 'b')\n@@ -9036,8 +9046,9 @@ print_operand (FILE *file, rtx x, int code)\n \n   else if (MEM_P (x))\n     {\n-      /* No `byte ptr' prefix for call instructions.  */\n-      if (ASSEMBLER_DIALECT == ASM_INTEL && code != 'X' && code != 'P')\n+      /* No `byte ptr' prefix for call instructions or BLKmode operands.  */\n+      if (ASSEMBLER_DIALECT == ASM_INTEL && code != 'X' && code != 'P'\n+\t  && GET_MODE (x) != BLKmode)\n \t{\n \t  const char * size;\n \t  switch (GET_MODE_SIZE (GET_MODE (x)))\n@@ -9047,7 +9058,12 @@ print_operand (FILE *file, rtx x, int code)\n \t    case 4: size = \"DWORD\"; break;\n \t    case 8: size = \"QWORD\"; break;\n \t    case 12: size = \"XWORD\"; break;\n-\t    case 16: size = \"XMMWORD\"; break;\n+\t    case 16:\n+\t      if (GET_MODE (x) == XFmode)\n+\t\tsize = \"XWORD\";\n+              else\n+\t\tsize = \"XMMWORD\";\n+              break;\n \t    default:\n \t      gcc_unreachable ();\n \t    }\n@@ -9165,45 +9181,43 @@ print_operand_address (FILE *file, rtx addr)\n       break;\n     case SEG_FS:\n     case SEG_GS:\n-      if (USER_LABEL_PREFIX[0] == 0)\n+      if (ASSEMBLER_DIALECT == ASM_ATT)\n \tputc ('%', file);\n       fputs ((parts.seg == SEG_FS ? \"fs:\" : \"gs:\"), file);\n       break;\n     default:\n       gcc_unreachable ();\n     }\n \n+  /* Use one byte shorter RIP relative addressing for 64bit mode.  */\n+  if (TARGET_64BIT && !base && !index)\n+    {\n+      rtx symbol = disp;\n+\n+      if (GET_CODE (disp) == CONST\n+\t  && GET_CODE (XEXP (disp, 0)) == PLUS\n+\t  && CONST_INT_P (XEXP (XEXP (disp, 0), 1)))\n+\tsymbol = XEXP (XEXP (disp, 0), 0);\n+\n+      if (GET_CODE (symbol) == LABEL_REF\n+\t  || (GET_CODE (symbol) == SYMBOL_REF\n+\t      && SYMBOL_REF_TLS_MODEL (symbol) == 0))\n+\tbase = pc_rtx;\n+    }\n   if (!base && !index)\n     {\n       /* Displacement only requires special attention.  */\n \n       if (CONST_INT_P (disp))\n \t{\n \t  if (ASSEMBLER_DIALECT == ASM_INTEL && parts.seg == SEG_DEFAULT)\n-\t    {\n-\t      if (USER_LABEL_PREFIX[0] == 0)\n-\t\tputc ('%', file);\n-\t      fputs (\"ds:\", file);\n-\t    }\n+\t    fputs (\"ds:\", file);\n \t  fprintf (file, HOST_WIDE_INT_PRINT_DEC, INTVAL (disp));\n \t}\n       else if (flag_pic)\n \toutput_pic_addr_const (file, disp, 0);\n       else\n \toutput_addr_const (file, disp);\n-\n-      /* Use one byte shorter RIP relative addressing for 64bit mode.  */\n-      if (TARGET_64BIT)\n-\t{\n-\t  if (GET_CODE (disp) == CONST\n-\t      && GET_CODE (XEXP (disp, 0)) == PLUS\n-\t      && CONST_INT_P (XEXP (XEXP (disp, 0), 1)))\n-\t    disp = XEXP (XEXP (disp, 0), 0);\n-\t  if (GET_CODE (disp) == LABEL_REF\n-\t      || (GET_CODE (disp) == SYMBOL_REF\n-\t\t  && SYMBOL_REF_TLS_MODEL (disp) == 0))\n-\t    fputs (\"(%rip)\", file);\n-\t}\n     }\n   else\n     {\n@@ -9319,7 +9333,8 @@ output_addr_const_extra (FILE *file, rtx x)\n     case UNSPEC_GOTNTPOFF:\n       output_addr_const (file, op);\n       if (TARGET_64BIT)\n-\tfputs (\"@GOTTPOFF(%rip)\", file);\n+\tfputs (ASSEMBLER_DIALECT == ASM_ATT ?\n+\t       \"@GOTTPOFF(%rip)\" : \"@GOTTPOFF[rip]\", file);\n       else\n \tfputs (\"@GOTNTPOFF\", file);\n       break;\n@@ -22736,7 +22751,7 @@ x86_file_start (void)\n   if (X86_FILE_START_FLTUSED)\n     fputs (\"\\t.global\\t__fltused\\n\", asm_out_file);\n   if (ix86_asm_dialect == ASM_INTEL)\n-    fputs (\"\\t.intel_syntax\\n\", asm_out_file);\n+    fputs (\"\\t.intel_syntax noprefix\\n\", asm_out_file);\n }\n \n int"}, {"sha": "c13fcbcb7c18c34452d7cc1f490c48a1fbe9fb58", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ad5e54f9548cfdd2fbed30d11fc82fd9f4bdd6e/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ad5e54f9548cfdd2fbed30d11fc82fd9f4bdd6e/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=9ad5e54f9548cfdd2fbed30d11fc82fd9f4bdd6e", "patch": "@@ -3439,7 +3439,7 @@\n   [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n      (zero_extend:HI (match_operand:QI 1 \"nonimmediate_operand\" \"qm\")))]\n   \"(!TARGET_ZERO_EXTEND_WITH_AND || optimize_size) && reload_completed\"\n-  \"movz{bl|x}\\t{%1, %k0|%k0, %k1}\"\n+  \"movz{bl|x}\\t{%1, %k0|%k0, %1}\"\n   [(set_attr \"type\" \"imovx\")\n    (set_attr \"mode\" \"SI\")])\n \n@@ -14907,7 +14907,7 @@\n   [(call (mem:QI (reg:DI R11_REG))\n \t (match_operand 0 \"\" \"\"))]\n   \"SIBLING_CALL_P (insn) && TARGET_64BIT\"\n-  \"jmp\\t*%%r11\"\n+  \"jmp\\t{*%%}r11\"\n   [(set_attr \"type\" \"call\")])\n \n \n@@ -15037,7 +15037,7 @@\n   [(return)\n    (unspec [(const_int 0)] UNSPEC_REP)]\n   \"reload_completed\"\n-  \"rep{\\;| }ret\"\n+  \"rep\\;ret\"\n   [(set_attr \"length\" \"1\")\n    (set_attr \"length_immediate\" \"0\")\n    (set_attr \"prefix_rep\" \"1\")\n@@ -15116,23 +15116,23 @@\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(unspec:DI [(const_int 0)] UNSPEC_SET_GOT))]\n   \"TARGET_64BIT\"\n-  \"lea{q}\\t_GLOBAL_OFFSET_TABLE_(%%rip), %0\"\n+  \"lea{q}\\t{_GLOBAL_OFFSET_TABLE_(%%rip), %0|%0, _GLOBAL_OFFSET_TABLE_[rip]}\"\n   [(set_attr \"type\" \"lea\")\n    (set_attr \"length\" \"6\")])\n \n (define_insn \"set_rip_rex64\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(unspec:DI [(match_operand:DI 1 \"\" \"\")] UNSPEC_SET_RIP))]\n   \"TARGET_64BIT\"\n-  \"lea{q}\\t%l1(%%rip), %0\"\n+  \"lea{q}\\t{%l1(%%rip), %0|%0, %l1[rip]}\"\n   [(set_attr \"type\" \"lea\")\n    (set_attr \"length\" \"6\")])\n \n (define_insn \"set_got_offset_rex64\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(unspec:DI [(match_operand:DI 1 \"\" \"\")] UNSPEC_SET_GOT_OFFSET))]\n   \"TARGET_64BIT\"\n-  \"movabs{q}\\t$_GLOBAL_OFFSET_TABLE_-%l1, %0\"\n+  \"movabs{q}\\t{$_GLOBAL_OFFSET_TABLE_-%l1, %0|%0, OFFSET FLAT:_GLOBAL_OFFSET_TABLE_-%l1}\"\n   [(set_attr \"type\" \"imov\")\n    (set_attr \"length\" \"11\")])\n \n@@ -15753,7 +15753,7 @@\n    (unspec:DI [(match_operand:DI 1 \"tls_symbolic_operand\" \"\")]\n \t      UNSPEC_TLS_GD)]\n   \"TARGET_64BIT\"\n-  \".byte\\t0x66\\;lea{q}\\t{%a1@TLSGD(%%rip), %%rdi|%%rdi, %a1@TLSGD[%%rip]}\\;.word\\t0x6666\\;rex64\\;call\\t%P2\"\n+  \".byte\\t0x66\\;lea{q}\\t{%a1@TLSGD(%%rip), %%rdi|rdi, %a1@TLSGD[rip]}\\;.word\\t0x6666\\;rex64\\;call\\t%P2\"\n   [(set_attr \"type\" \"multi\")\n    (set_attr \"length\" \"16\")])\n \n@@ -15831,7 +15831,7 @@\n \t\t (match_operand:DI 2 \"\" \"\")))\n    (unspec:DI [(const_int 0)] UNSPEC_TLS_LD_BASE)]\n   \"TARGET_64BIT\"\n-  \"lea{q}\\t{%&@TLSLD(%%rip), %%rdi|%%rdi, %&@TLSLD[%%rip]}\\;call\\t%P1\"\n+  \"lea{q}\\t{%&@TLSLD(%%rip), %%rdi|rdi, %&@TLSLD[rip]}\\;call\\t%P1\"\n   [(set_attr \"type\" \"multi\")\n    (set_attr \"length\" \"12\")])\n \n@@ -15881,7 +15881,7 @@\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(unspec:SI [(const_int 0)] UNSPEC_TP))]\n   \"!TARGET_64BIT\"\n-  \"mov{l}\\t{%%gs:0, %0|%0, DWORD PTR %%gs:0}\"\n+  \"mov{l}\\t{%%gs:0, %0|%0, DWORD PTR gs:0}\"\n   [(set_attr \"type\" \"imov\")\n    (set_attr \"modrm\" \"0\")\n    (set_attr \"length\" \"7\")\n@@ -15894,7 +15894,7 @@\n \t\t (match_operand:SI 1 \"register_operand\" \"0\")))\n    (clobber (reg:CC FLAGS_REG))]\n   \"!TARGET_64BIT\"\n-  \"add{l}\\t{%%gs:0, %0|%0, DWORD PTR %%gs:0}\"\n+  \"add{l}\\t{%%gs:0, %0|%0, DWORD PTR gs:0}\"\n   [(set_attr \"type\" \"alu\")\n    (set_attr \"modrm\" \"0\")\n    (set_attr \"length\" \"7\")\n@@ -15905,7 +15905,7 @@\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(unspec:DI [(const_int 0)] UNSPEC_TP))]\n   \"TARGET_64BIT\"\n-  \"mov{q}\\t{%%fs:0, %0|%0, QWORD PTR %%fs:0}\"\n+  \"mov{q}\\t{%%fs:0, %0|%0, QWORD PTR fs:0}\"\n   [(set_attr \"type\" \"imov\")\n    (set_attr \"modrm\" \"0\")\n    (set_attr \"length\" \"7\")\n@@ -15918,7 +15918,7 @@\n \t\t (match_operand:DI 1 \"register_operand\" \"0\")))\n    (clobber (reg:CC FLAGS_REG))]\n   \"TARGET_64BIT\"\n-  \"add{q}\\t{%%fs:0, %0|%0, QWORD PTR %%fs:0}\"\n+  \"add{q}\\t{%%fs:0, %0|%0, QWORD PTR fs:0}\"\n   [(set_attr \"type\" \"alu\")\n    (set_attr \"modrm\" \"0\")\n    (set_attr \"length\" \"7\")\n@@ -16014,7 +16014,7 @@\n \t(unspec:DI [(match_operand:DI 1 \"tls_symbolic_operand\" \"\")]\n \t\t   UNSPEC_TLSDESC))]\n   \"TARGET_64BIT && TARGET_GNU2_TLS\"\n-  \"lea{q}\\t{%a1@TLSDESC(%%rip), %0|%0, %a1@TLSDESC[%%rip]}\"\n+  \"lea{q}\\t{%a1@TLSDESC(%%rip), %0|%0, %a1@TLSDESC[rip]}\"\n   [(set_attr \"type\" \"lea\")\n    (set_attr \"mode\" \"DI\")\n    (set_attr \"length\" \"7\")\n@@ -21262,7 +21262,7 @@\n \t(call (mem:QI (reg:DI R11_REG))\n \t      (match_operand:DI 1 \"\" \"\")))]\n   \"SIBLING_CALL_P (insn) && TARGET_64BIT\"\n-  \"jmp\\t*%%r11\"\n+  \"jmp\\t{*%%}r11\"\n   [(set_attr \"type\" \"callv\")])\n \f\n ;; We used to use \"int $5\", in honor of #BR which maps to interrupt vector 5.\n@@ -21470,7 +21470,7 @@\n    (set (match_scratch:SI 2 \"=&r\") (const_int 0))\n    (clobber (reg:CC FLAGS_REG))]\n   \"\"\n-  \"mov{l}\\t{%%gs:%P1, %2|%2, DWORD PTR %%gs:%P1}\\;mov{l}\\t{%2, %0|%0, %2}\\;xor{l}\\t%2, %2\"\n+  \"mov{l}\\t{%%gs:%P1, %2|%2, DWORD PTR gs:%P1}\\;mov{l}\\t{%2, %0|%0, %2}\\;xor{l}\\t%2, %2\"\n   [(set_attr \"type\" \"multi\")])\n \n (define_insn \"stack_tls_protect_set_di\"\n@@ -21484,9 +21484,9 @@\n         system call would not have to trash the userspace segment register,\n         which would be expensive */\n      if (ix86_cmodel != CM_KERNEL)\n-        return \"mov{q}\\t{%%fs:%P1, %2|%2, QWORD PTR %%fs:%P1}\\;mov{q}\\t{%2, %0|%0, %2}\\;xor{l}\\t%k2, %k2\";\n+        return \"mov{q}\\t{%%fs:%P1, %2|%2, QWORD PTR fs:%P1}\\;mov{q}\\t{%2, %0|%0, %2}\\;xor{l}\\t%k2, %k2\";\n      else\n-        return \"mov{q}\\t{%%gs:%P1, %2|%2, QWORD PTR %%gs:%P1}\\;mov{q}\\t{%2, %0|%0, %2}\\;xor{l}\\t%k2, %k2\";\n+        return \"mov{q}\\t{%%gs:%P1, %2|%2, QWORD PTR gs:%P1}\\;mov{q}\\t{%2, %0|%0, %2}\\;xor{l}\\t%k2, %k2\";\n   }\n   [(set_attr \"type\" \"multi\")])\n \n@@ -21545,7 +21545,7 @@\n \t\t    UNSPEC_SP_TLS_TEST))\n    (clobber (match_scratch:SI 3 \"=r\"))]\n   \"\"\n-  \"mov{l}\\t{%1, %3|%3, %1}\\;xor{l}\\t{%%gs:%P2, %3|%3, DWORD PTR %%gs:%P2}\"\n+  \"mov{l}\\t{%1, %3|%3, %1}\\;xor{l}\\t{%%gs:%P2, %3|%3, DWORD PTR gs:%P2}\"\n   [(set_attr \"type\" \"multi\")])\n \n (define_insn \"stack_tls_protect_test_di\"\n@@ -21560,9 +21560,9 @@\n         system call would not have to trash the userspace segment register,\n         which would be expensive */\n      if (ix86_cmodel != CM_KERNEL)\n-        return \"mov{q}\\t{%1, %3|%3, %1}\\;xor{q}\\t{%%fs:%P2, %3|%3, QWORD PTR %%fs:%P2}\";\n+        return \"mov{q}\\t{%1, %3|%3, %1}\\;xor{q}\\t{%%fs:%P2, %3|%3, QWORD PTR fs:%P2}\";\n      else\n-        return \"mov{q}\\t{%1, %3|%3, %1}\\;xor{q}\\t{%%gs:%P2, %3|%3, QWORD PTR %%gs:%P2}\";\n+        return \"mov{q}\\t{%1, %3|%3, %1}\\;xor{q}\\t{%%gs:%P2, %3|%3, QWORD PTR gs:%P2}\";\n   }\n   [(set_attr \"type\" \"multi\")])\n "}, {"sha": "72780155d2b163d40bba8b1dbd88789a575c15ec", "filename": "gcc/config/i386/mmx.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ad5e54f9548cfdd2fbed30d11fc82fd9f4bdd6e/gcc%2Fconfig%2Fi386%2Fmmx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ad5e54f9548cfdd2fbed30d11fc82fd9f4bdd6e/gcc%2Fconfig%2Fi386%2Fmmx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fmmx.md?ref=9ad5e54f9548cfdd2fbed30d11fc82fd9f4bdd6e", "patch": "@@ -69,8 +69,8 @@\n   \"TARGET_64BIT && TARGET_MMX\n    && !(MEM_P (operands[0]) && MEM_P (operands[1]))\"\n   \"@\n-    movq\\t{%1, %0|%0, %1}\n-    movq\\t{%1, %0|%0, %1}\n+    mov{q}\\t{%1, %0|%0, %1}\n+    mov{q}\\t{%1, %0|%0, %1}\n     pxor\\t%0, %0\n     movq\\t{%1, %0|%0, %1}\n     movq\\t{%1, %0|%0, %1}\n@@ -128,8 +128,8 @@\n   \"TARGET_64BIT && TARGET_MMX\n    && !(MEM_P (operands[0]) && MEM_P (operands[1]))\"\n   \"@\n-    movq\\t{%1, %0|%0, %1}\n-    movq\\t{%1, %0|%0, %1}\n+    mov{q}\\t{%1, %0|%0, %1}\n+    mov{q}\\t{%1, %0|%0, %1}\n     pxor\\t%0, %0\n     movq\\t{%1, %0|%0, %1}\n     movq\\t{%1, %0|%0, %1}"}]}