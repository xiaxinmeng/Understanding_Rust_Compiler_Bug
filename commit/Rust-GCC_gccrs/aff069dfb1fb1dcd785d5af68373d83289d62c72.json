{"sha": "aff069dfb1fb1dcd785d5af68373d83289d62c72", "node_id": "C_kwDOANBUbNoAKGFmZjA2OWRmYjFmYjFkY2Q3ODVkNWFmNjgzNzNkODMyODlkNjJjNzI", "commit": {"author": {"name": "Philip Herron", "email": "herron.philip@googlemail.com", "date": "2023-01-31T18:52:33Z"}, "committer": {"name": "Philip Herron", "email": "herron.philip@googlemail.com", "date": "2023-02-05T00:10:48Z"}, "message": "gccrs: Fix higher ranked trait bounds computation of self\n\nThis updates the higher ranked trait bounds computation to handle ambigious\ncases. When we have a slice for example:\n\n  let slice = &a[1..3];\n\nThis works by reusing the Index operator overload from libcore, so when the\nindex range of 1..3 is computed, the type system needs to compute what the\ntypes of index are; this works by integer inference variables\nRange<<integer>> that need to be unified with the impl Index for\nRange<Usize> which computes the real type of usize for the index. This is\nfine but what happens when we have the Copy and Clone traits bounds which\nhave implementations for all the primitive types i8, i16, i32, i64...\nwhich is valid for any integer inference variable so the code prior to this\npatch would have grabbed the first impl it would have found and used it\nwhich is incorrect. When we have integer or float inference variables we\nneed to look for their respective defaults or emit an ambigious type bound\nerror.\n\nSigned-off-by: Philip Herron <herron.philip@googlemail.com>\n\ngcc/rust/ChangeLog:\n\n\t* typecheck/rust-hir-trait-reference.h: add const infterface\n\t* typecheck/rust-tyty-subst.cc (SubstitutionParamMapping::get_generic_param): make const\n\t(SubstitutionRef::monomorphize): fix issue\n\t* typecheck/rust-tyty-subst.h: constify interface", "tree": {"sha": "e186ec3c1c669875ffa3e14253422e3291f162d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e186ec3c1c669875ffa3e14253422e3291f162d2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aff069dfb1fb1dcd785d5af68373d83289d62c72", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aff069dfb1fb1dcd785d5af68373d83289d62c72", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aff069dfb1fb1dcd785d5af68373d83289d62c72", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aff069dfb1fb1dcd785d5af68373d83289d62c72/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d4e6b64e7f9e23aeb5d3c40665f18091575921ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4e6b64e7f9e23aeb5d3c40665f18091575921ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d4e6b64e7f9e23aeb5d3c40665f18091575921ed"}], "stats": {"total": 110, "additions": 102, "deletions": 8}, "files": [{"sha": "aec1dd56bccb88dec9ca108190c3e9d8ba94a6ce", "filename": "gcc/rust/typecheck/rust-hir-trait-reference.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aff069dfb1fb1dcd785d5af68373d83289d62c72/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-reference.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aff069dfb1fb1dcd785d5af68373d83289d62c72/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-reference.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-reference.h?ref=aff069dfb1fb1dcd785d5af68373d83289d62c72", "patch": "@@ -496,6 +496,7 @@ class AssociatedImplTrait\n   HIR::ImplBlock *get_impl_block () { return impl; }\n \n   TyTy::BaseType *get_self () { return self; }\n+  const TyTy::BaseType *get_self () const { return self; }\n \n   TyTy::BaseType *\n   setup_associated_types (const TyTy::BaseType *self,"}, {"sha": "3dfe95873bce23c602ae07f8a411b090a0dc6ddf", "filename": "gcc/rust/typecheck/rust-tyty-subst.cc", "status": "modified", "additions": 100, "deletions": 7, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aff069dfb1fb1dcd785d5af68373d83289d62c72/gcc%2Frust%2Ftypecheck%2Frust-tyty-subst.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aff069dfb1fb1dcd785d5af68373d83289d62c72/gcc%2Frust%2Ftypecheck%2Frust-tyty-subst.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-subst.cc?ref=aff069dfb1fb1dcd785d5af68373d83289d62c72", "patch": "@@ -65,7 +65,7 @@ SubstitutionParamMapping::get_param_ty () const\n }\n \n const HIR::TypeParam &\n-SubstitutionParamMapping::get_generic_param ()\n+SubstitutionParamMapping::get_generic_param () const\n {\n   return generic;\n }\n@@ -892,8 +892,7 @@ SubstitutionRef::monomorphize ()\n \t  // setup any associated type mappings for the specified bonds and this\n \t  // type\n \t  auto candidates = Resolver::TypeBoundsProbe::Probe (binding);\n-\n-\t  Resolver::AssociatedImplTrait *associated_impl_trait = nullptr;\n+\t  std::vector<Resolver::AssociatedImplTrait *> associated_impl_traits;\n \t  for (auto &probed_bound : candidates)\n \t    {\n \t      const Resolver::TraitReference *bound_trait_ref\n@@ -914,15 +913,109 @@ SubstitutionRef::monomorphize ()\n \t\t    = associated->get_self ()->can_eq (binding, false);\n \t\t  if (found_trait && found_self)\n \t\t    {\n-\t\t      associated_impl_trait = associated;\n-\t\t      break;\n+\t\t      associated_impl_traits.push_back (associated);\n \t\t    }\n \t\t}\n \t    }\n \n-\t  if (associated_impl_trait != nullptr)\n+\t  if (!associated_impl_traits.empty ())\n \t    {\n-\t      associated_impl_trait->setup_associated_types (binding, bound);\n+\t      // This code is important when you look at slices for example when\n+\t      // you have a slice such as:\n+\t      //\n+\t      // let slice = &array[1..3]\n+\t      //\n+\t      // the higher ranked bounds will end up having an Index trait\n+\t      // implementation for Range<usize> so we need this code to resolve\n+\t      // that we have an integer inference variable that needs to become\n+\t      // a usize\n+\t      //\n+\t      // The other complicated issue is that we might have an intrinsic\n+\t      // which requires the :Clone or Copy bound but the libcore adds\n+\t      // implementations for all the integral types so when there are\n+\t      // multiple candidates we need to resolve to the default\n+\t      // implementation for that type otherwise its an error for\n+\t      // ambiguous type bounds\n+\n+\t      if (associated_impl_traits.size () == 1)\n+\t\t{\n+\t\t  Resolver::AssociatedImplTrait *associate_impl_trait\n+\t\t    = associated_impl_traits.at (0);\n+\t\t  associate_impl_trait->setup_associated_types (binding, bound);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  // if we have a non-general inference variable we need to be\n+\t\t  // careful about the selection here\n+\t\t  bool is_infer_var\n+\t\t    = binding->get_kind () == TyTy::TypeKind::INFER;\n+\t\t  bool is_integer_infervar\n+\t\t    = is_infer_var\n+\t\t      && static_cast<const TyTy::InferType *> (binding)\n+\t\t\t     ->get_infer_kind ()\n+\t\t\t   == TyTy::InferType::InferTypeKind::INTEGRAL;\n+\t\t  bool is_float_infervar\n+\t\t    = is_infer_var\n+\t\t      && static_cast<const TyTy::InferType *> (binding)\n+\t\t\t     ->get_infer_kind ()\n+\t\t\t   == TyTy::InferType::InferTypeKind::FLOAT;\n+\n+\t\t  Resolver::AssociatedImplTrait *associate_impl_trait = nullptr;\n+\t\t  if (is_integer_infervar)\n+\t\t    {\n+\t\t      TyTy::BaseType *type = nullptr;\n+\t\t      bool ok = context->lookup_builtin (\"i32\", &type);\n+\t\t      rust_assert (ok);\n+\n+\t\t      for (auto &impl : associated_impl_traits)\n+\t\t\t{\n+\t\t\t  bool found = impl->get_self ()->is_equal (*type);\n+\t\t\t  if (found)\n+\t\t\t    {\n+\t\t\t      associate_impl_trait = impl;\n+\t\t\t      break;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t  else if (is_float_infervar)\n+\t\t    {\n+\t\t      TyTy::BaseType *type = nullptr;\n+\t\t      bool ok = context->lookup_builtin (\"f64\", &type);\n+\t\t      rust_assert (ok);\n+\n+\t\t      for (auto &impl : associated_impl_traits)\n+\t\t\t{\n+\t\t\t  bool found = impl->get_self ()->is_equal (*type);\n+\t\t\t  if (found)\n+\t\t\t    {\n+\t\t\t      associate_impl_trait = impl;\n+\t\t\t      break;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\n+\t\t  if (associate_impl_trait == nullptr)\n+\t\t    {\n+\t\t      // go for the first one? or error out?\n+\t\t      auto &mappings = *Analysis::Mappings::get ();\n+\t\t      const auto &type_param = subst.get_generic_param ();\n+\t\t      const auto *trait_ref = bound.get ();\n+\n+\t\t      RichLocation r (type_param.get_locus ());\n+\t\t      r.add_range (bound.get_locus ());\n+\t\t      r.add_range (\n+\t\t\tmappings.lookup_location (binding->get_ref ()));\n+\n+\t\t      rust_error_at (\n+\t\t\tr, \"ambiguous type bound for trait %s and type %s\",\n+\t\t\ttrait_ref->get_name ().c_str (),\n+\t\t\tbinding->get_name ().c_str ());\n+\n+\t\t      return false;\n+\t\t    }\n+\n+\t\t  associate_impl_trait->setup_associated_types (binding, bound);\n+\t\t}\n \t    }\n \t}\n     }"}, {"sha": "982861e9bc663939d2bd3a290e1832ad328c3db0", "filename": "gcc/rust/typecheck/rust-tyty-subst.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aff069dfb1fb1dcd785d5af68373d83289d62c72/gcc%2Frust%2Ftypecheck%2Frust-tyty-subst.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aff069dfb1fb1dcd785d5af68373d83289d62c72/gcc%2Frust%2Ftypecheck%2Frust-tyty-subst.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-subst.h?ref=aff069dfb1fb1dcd785d5af68373d83289d62c72", "patch": "@@ -48,7 +48,7 @@ class SubstitutionParamMapping\n \n   const ParamType *get_param_ty () const;\n \n-  const HIR::TypeParam &get_generic_param ();\n+  const HIR::TypeParam &get_generic_param () const;\n \n   // this is used for the backend to override the HirId ref of the param to\n   // what the concrete type is for the rest of the context"}]}