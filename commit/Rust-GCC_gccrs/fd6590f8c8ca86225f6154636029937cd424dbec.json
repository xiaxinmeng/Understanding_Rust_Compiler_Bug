{"sha": "fd6590f8c8ca86225f6154636029937cd424dbec", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmQ2NTkwZjhjOGNhODYyMjVmNjE1NDYzNjAyOTkzN2NkNDI0ZGJlYw==", "commit": {"author": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2008-01-11T20:21:05Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2008-01-11T20:21:05Z"}, "message": "re PR libfortran/34670 (bounds checking for array intrinsics)\n\n2008-01-11  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR libfortran/34670\n\t* m4/iparm.m4 (upcase):  New macro (copied from the m4 manual).\n\t(u_name):  New macro for the upper case name of the intrinsic.\n\t* m4/iforeach.m4 (name`'rtype_qual`_'atype_code):  Add\n\tbounds checking and rank check, depending on\n\tcompile_options.bounds_check.\n\t(`m'name`'rtype_qual`_'atype_code):  Likewise.\n\t(`s'name`'rtype_qual`_'atype_code):  Likewise.\n\t* m4/ifunction.m4 (name`'rtype_qual`_'atype_code):  Add\n\tbounds checking and rank check, depending on\n\tcompile_options.bounds_check.\n\t(`m'name`'rtype_qual`_'atype_code):  Likewise.\n\t(`s'name`'rtype_qual`_'atype_code):  Likewise.\n\t* generated/all_l16.c: Regenerated.\n\t* generated/all_l4.c: Regenerated.\n\t* generated/all_l8.c: Regenerated.\n\t* generated/any_l16.c: Regenerated.\n\t* generated/any_l4.c: Regenerated.\n\t* generated/any_l8.c: Regenerated.\n\t* generated/count_16_l16.c: Regenerated.\n\t* generated/count_16_l4.c: Regenerated.\n\t* generated/count_16_l8.c: Regenerated.\n\t* generated/count_4_l16.c: Regenerated.\n\t* generated/count_4_l4.c: Regenerated.\n\t* generated/count_4_l8.c: Regenerated.\n\t* generated/count_8_l16.c: Regenerated.\n\t* generated/count_8_l4.c: Regenerated.\n\t* generated/count_8_l8.c: Regenerated.\n\t* generated/maxloc0_16_i1.c: Regenerated.\n\t* generated/maxloc0_16_i16.c: Regenerated.\n\t* generated/maxloc0_16_i2.c: Regenerated.\n\t* generated/maxloc0_16_i4.c: Regenerated.\n\t* generated/maxloc0_16_i8.c: Regenerated.\n\t* generated/maxloc0_16_r10.c: Regenerated.\n\t* generated/maxloc0_16_r16.c: Regenerated.\n\t* generated/maxloc0_16_r4.c: Regenerated.\n\t* generated/maxloc0_16_r8.c: Regenerated.\n\t* generated/maxloc0_4_i1.c: Regenerated.\n\t* generated/maxloc0_4_i16.c: Regenerated.\n\t* generated/maxloc0_4_i2.c: Regenerated.\n\t* generated/maxloc0_4_i4.c: Regenerated.\n\t* generated/maxloc0_4_i8.c: Regenerated.\n\t* generated/maxloc0_4_r10.c: Regenerated.\n\t* generated/maxloc0_4_r16.c: Regenerated.\n\t* generated/maxloc0_4_r4.c: Regenerated.\n\t* generated/maxloc0_4_r8.c: Regenerated.\n\t* generated/maxloc0_8_i1.c: Regenerated.\n\t* generated/maxloc0_8_i16.c: Regenerated.\n\t* generated/maxloc0_8_i2.c: Regenerated.\n\t* generated/maxloc0_8_i4.c: Regenerated.\n\t* generated/maxloc0_8_i8.c: Regenerated.\n\t* generated/maxloc0_8_r10.c: Regenerated.\n\t* generated/maxloc0_8_r16.c: Regenerated.\n\t* generated/maxloc0_8_r4.c: Regenerated.\n\t* generated/maxloc0_8_r8.c: Regenerated.\n\t* generated/maxloc1_16_i1.c: Regenerated.\n\t* generated/maxloc1_16_i16.c: Regenerated.\n\t* generated/maxloc1_16_i2.c: Regenerated.\n\t* generated/maxloc1_16_i4.c: Regenerated.\n\t* generated/maxloc1_16_i8.c: Regenerated.\n\t* generated/maxloc1_16_r10.c: Regenerated.\n\t* generated/maxloc1_16_r16.c: Regenerated.\n\t* generated/maxloc1_16_r4.c: Regenerated.\n\t* generated/maxloc1_16_r8.c: Regenerated.\n\t* generated/maxloc1_4_i1.c: Regenerated.\n\t* generated/maxloc1_4_i16.c: Regenerated.\n\t* generated/maxloc1_4_i2.c: Regenerated.\n\t* generated/maxloc1_4_i4.c: Regenerated.\n\t* generated/maxloc1_4_i8.c: Regenerated.\n\t* generated/maxloc1_4_r10.c: Regenerated.\n\t* generated/maxloc1_4_r16.c: Regenerated.\n\t* generated/maxloc1_4_r4.c: Regenerated.\n\t* generated/maxloc1_4_r8.c: Regenerated.\n\t* generated/maxloc1_8_i1.c: Regenerated.\n\t* generated/maxloc1_8_i16.c: Regenerated.\n\t* generated/maxloc1_8_i2.c: Regenerated.\n\t* generated/maxloc1_8_i4.c: Regenerated.\n\t* generated/maxloc1_8_i8.c: Regenerated.\n\t* generated/maxloc1_8_r10.c: Regenerated.\n\t* generated/maxloc1_8_r16.c: Regenerated.\n\t* generated/maxloc1_8_r4.c: Regenerated.\n\t* generated/maxloc1_8_r8.c: Regenerated.\n\t* generated/maxval_i1.c: Regenerated.\n\t* generated/maxval_i16.c: Regenerated.\n\t* generated/maxval_i2.c: Regenerated.\n\t* generated/maxval_i4.c: Regenerated.\n\t* generated/maxval_i8.c: Regenerated.\n\t* generated/maxval_r10.c: Regenerated.\n\t* generated/maxval_r16.c: Regenerated.\n\t* generated/maxval_r4.c: Regenerated.\n\t* generated/maxval_r8.c: Regenerated.\n\t* generated/minloc0_16_i1.c: Regenerated.\n\t* generated/minloc0_16_i16.c: Regenerated.\n\t* generated/minloc0_16_i2.c: Regenerated.\n\t* generated/minloc0_16_i4.c: Regenerated.\n\t* generated/minloc0_16_i8.c: Regenerated.\n\t* generated/minloc0_16_r10.c: Regenerated.\n\t* generated/minloc0_16_r16.c: Regenerated.\n\t* generated/minloc0_16_r4.c: Regenerated.\n\t* generated/minloc0_16_r8.c: Regenerated.\n\t* generated/minloc0_4_i1.c: Regenerated.\n\t* generated/minloc0_4_i16.c: Regenerated.\n\t* generated/minloc0_4_i2.c: Regenerated.\n\t* generated/minloc0_4_i4.c: Regenerated.\n\t* generated/minloc0_4_i8.c: Regenerated.\n\t* generated/minloc0_4_r10.c: Regenerated.\n\t* generated/minloc0_4_r16.c: Regenerated.\n\t* generated/minloc0_4_r4.c: Regenerated.\n\t* generated/minloc0_4_r8.c: Regenerated.\n\t* generated/minloc0_8_i1.c: Regenerated.\n\t* generated/minloc0_8_i16.c: Regenerated.\n\t* generated/minloc0_8_i2.c: Regenerated.\n\t* generated/minloc0_8_i4.c: Regenerated.\n\t* generated/minloc0_8_i8.c: Regenerated.\n\t* generated/minloc0_8_r10.c: Regenerated.\n\t* generated/minloc0_8_r16.c: Regenerated.\n\t* generated/minloc0_8_r4.c: Regenerated.\n\t* generated/minloc0_8_r8.c: Regenerated.\n\t* generated/minloc1_16_i1.c: Regenerated.\n\t* generated/minloc1_16_i16.c: Regenerated.\n\t* generated/minloc1_16_i2.c: Regenerated.\n\t* generated/minloc1_16_i4.c: Regenerated.\n\t* generated/minloc1_16_i8.c: Regenerated.\n\t* generated/minloc1_16_r10.c: Regenerated.\n\t* generated/minloc1_16_r16.c: Regenerated.\n\t* generated/minloc1_16_r4.c: Regenerated.\n\t* generated/minloc1_16_r8.c: Regenerated.\n\t* generated/minloc1_4_i1.c: Regenerated.\n\t* generated/minloc1_4_i16.c: Regenerated.\n\t* generated/minloc1_4_i2.c: Regenerated.\n\t* generated/minloc1_4_i4.c: Regenerated.\n\t* generated/minloc1_4_i8.c: Regenerated.\n\t* generated/minloc1_4_r10.c: Regenerated.\n\t* generated/minloc1_4_r16.c: Regenerated.\n\t* generated/minloc1_4_r4.c: Regenerated.\n\t* generated/minloc1_4_r8.c: Regenerated.\n\t* generated/minloc1_8_i1.c: Regenerated.\n\t* generated/minloc1_8_i16.c: Regenerated.\n\t* generated/minloc1_8_i2.c: Regenerated.\n\t* generated/minloc1_8_i4.c: Regenerated.\n\t* generated/minloc1_8_i8.c: Regenerated.\n\t* generated/minloc1_8_r10.c: Regenerated.\n\t* generated/minloc1_8_r16.c: Regenerated.\n\t* generated/minloc1_8_r4.c: Regenerated.\n\t* generated/minloc1_8_r8.c: Regenerated.\n\t* generated/minval_i1.c: Regenerated.\n\t* generated/minval_i16.c: Regenerated.\n\t* generated/minval_i2.c: Regenerated.\n\t* generated/minval_i4.c: Regenerated.\n\t* generated/minval_i8.c: Regenerated.\n\t* generated/minval_r10.c: Regenerated.\n\t* generated/minval_r16.c: Regenerated.\n\t* generated/minval_r4.c: Regenerated.\n\t* generated/minval_r8.c: Regenerated.\n\t* generated/product_c10.c: Regenerated.\n\t* generated/product_c16.c: Regenerated.\n\t* generated/product_c4.c: Regenerated.\n\t* generated/product_c8.c: Regenerated.\n\t* generated/product_i1.c: Regenerated.\n\t* generated/product_i16.c: Regenerated.\n\t* generated/product_i2.c: Regenerated.\n\t* generated/product_i4.c: Regenerated.\n\t* generated/product_i8.c: Regenerated.\n\t* generated/product_r10.c: Regenerated.\n\t* generated/product_r16.c: Regenerated.\n\t* generated/product_r4.c: Regenerated.\n\t* generated/product_r8.c: Regenerated.\n\t* generated/sum_c10.c: Regenerated.\n\t* generated/sum_c16.c: Regenerated.\n\t* generated/sum_c4.c: Regenerated.\n\t* generated/sum_c8.c: Regenerated.\n\t* generated/sum_i1.c: Regenerated.\n\t* generated/sum_i16.c: Regenerated.\n\t* generated/sum_i2.c: Regenerated.\n\t* generated/sum_i4.c: Regenerated.\n\t* generated/sum_i8.c: Regenerated.\n\t* generated/sum_r10.c: Regenerated.\n\t* generated/sum_r16.c: Regenerated.\n\t* generated/sum_r4.c: Regenerated.\n\t* generated/sum_r8.c: Regenerated.\n\n2008-01-11  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR libfortran/34670\n\t* all_bounds_1.f90: New test case.\n\t* maxloc_bounds_1.f90: New test case.\n\t* maxloc_bounds_2.f90: New test case.\n\t* maxloc_bounds_3.f90: New test case.\n\t* maxloc_bounds_4.f90: New test case.\n\t* maxloc_bounds_5.f90: New test case.\n\t* maxloc_bounds_6.f90: New test case.\n\t* maxloc_bounds_7.f90: New test case.\n\t* maxloc_bounds_8.f90: New test case.\n\nFrom-SVN: r131473", "tree": {"sha": "ae68d60081c905e627e5ae07599bc9c994f7a5fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ae68d60081c905e627e5ae07599bc9c994f7a5fc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fd6590f8c8ca86225f6154636029937cd424dbec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd6590f8c8ca86225f6154636029937cd424dbec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd6590f8c8ca86225f6154636029937cd424dbec", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd6590f8c8ca86225f6154636029937cd424dbec/comments", "author": null, "committer": null, "parents": [{"sha": "15af420d4e77e10803ccf00045a6105e9e55e96d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15af420d4e77e10803ccf00045a6105e9e55e96d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/15af420d4e77e10803ccf00045a6105e9e55e96d"}], "stats": {"total": 11623, "additions": 10147, "deletions": 1476}, "files": [{"sha": "85060acfa8b58ccb68ee8e1f5983d39099ddb5d4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -1,3 +1,16 @@\n+2008-01-11  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR libfortran/34670\n+\t* all_bounds_1.f90: New test case.\n+\t* maxloc_bounds_1.f90: New test case.\n+\t* maxloc_bounds_2.f90: New test case.\n+\t* maxloc_bounds_3.f90: New test case.\n+\t* maxloc_bounds_4.f90: New test case.\n+\t* maxloc_bounds_5.f90: New test case.\n+\t* maxloc_bounds_6.f90: New test case.\n+\t* maxloc_bounds_7.f90: New test case.\n+\t* maxloc_bounds_8.f90: New test case.\n+\n 2008-01-11  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc.dg/struct-ret-3.c: New test."}, {"sha": "d8cb07bf0c6124ad70958873cdaf5ea973ef7e64", "filename": "gcc/testsuite/gfortran.dg/all_bounds_1.f90", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/gcc%2Ftestsuite%2Fgfortran.dg%2Fall_bounds_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/gcc%2Ftestsuite%2Fgfortran.dg%2Fall_bounds_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fall_bounds_1.f90?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -0,0 +1,17 @@\n+! { dg-do run }\n+! { dg-options \"-fbounds-check\" }\n+! { dg-shouldfail \"Incorrect extent in return value of ALL intrinsic\" }\n+program main\n+  logical(kind=4), allocatable :: f(:,:)\n+  logical(kind=4) :: res(3)\n+  character(len=80) line\n+  allocate (f(2,2))\n+  f = .false.\n+  f(1,1) = .true.\n+  f(2,1) = .true.\n+  res = all(f,dim=1)\n+  write(line,fmt='(80L1)') res\n+end program main\n+! { dg-output \"Fortran runtime error: Incorrect extent in return value of ALL intrinsic in dimension 1: is 3, should be 2\" }\n+\n+"}, {"sha": "a107db2017a4817f1216855d11bac194afeaca2a", "filename": "gcc/testsuite/gfortran.dg/maxloc_bounds_1.f90", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/gcc%2Ftestsuite%2Fgfortran.dg%2Fmaxloc_bounds_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/gcc%2Ftestsuite%2Fgfortran.dg%2Fmaxloc_bounds_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fmaxloc_bounds_1.f90?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -0,0 +1,14 @@\n+! { dg-do run }\n+! { dg-options \"-fbounds-check\" }\n+! { dg-shouldfail \"Incorrect extent in return value of MAXLOC intrinsic in dimension 1: is 3, should be 2\" }\n+program main\n+  integer(kind=4), allocatable :: f(:,:)\n+  integer(kind=4) :: res(3)\n+  character(len=80) line\n+  allocate (f(2,2))\n+  f = 3\n+  res = maxloc(f,dim=1)\n+  write(line,fmt='(80I1)') res\n+end program main\n+! { dg-output \"Fortran runtime error: Incorrect extent in return value of MAXLOC intrinsic in dimension 1: is 3, should be 2\" }\n+"}, {"sha": "39af3cb9fded09eafe31ad21e7b6c99d09fb6501", "filename": "gcc/testsuite/gfortran.dg/maxloc_bounds_2.f90", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/gcc%2Ftestsuite%2Fgfortran.dg%2Fmaxloc_bounds_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/gcc%2Ftestsuite%2Fgfortran.dg%2Fmaxloc_bounds_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fmaxloc_bounds_2.f90?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -0,0 +1,16 @@\n+! { dg-do run }\n+! { dg-options \"-fbounds-check\" }\n+! { dg-shouldfail \"Incorrect extent in return value of MAXLOC intrinsic in dimension 1: is 3, should be 2\" }\n+program main\n+  integer(kind=4), allocatable :: f(:,:)\n+  logical, allocatable :: m(:,:)\n+  integer(kind=4) :: res(3)\n+  character(len=80) line\n+  allocate (f(2,2),m(2,2))\n+  f = 3\n+  m = .true.\n+  res = maxloc(f,dim=1,mask=m)\n+  write(line,fmt='(80I1)') res\n+end program main\n+! { dg-output \"Fortran runtime error: Incorrect extent in return value of MAXLOC intrinsic in dimension 1: is 3, should be 2\" }\n+"}, {"sha": "41df6a8d093e71838f10f12c508503c568b5c112", "filename": "gcc/testsuite/gfortran.dg/maxloc_bounds_3.f90", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/gcc%2Ftestsuite%2Fgfortran.dg%2Fmaxloc_bounds_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/gcc%2Ftestsuite%2Fgfortran.dg%2Fmaxloc_bounds_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fmaxloc_bounds_3.f90?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -0,0 +1,16 @@\n+! { dg-do run }\n+! { dg-options \"-fbounds-check\" }\n+! { dg-shouldfail \"Incorrect extent in MASK argument of MAXLOC intrinsic in dimension 2: is 3, should be 2\" }\n+program main\n+  integer(kind=4), allocatable :: f(:,:)\n+  logical, allocatable :: m(:,:)\n+  integer(kind=4) :: res(2)\n+  character(len=80) line\n+  allocate (f(2,2),m(2,3))\n+  f = 3\n+  m = .true.\n+  res = maxloc(f,dim=1,mask=m)\n+  write(line,fmt='(80I1)') res\n+end program main\n+! { dg-output \"Fortran runtime error: Incorrect extent in MASK argument of MAXLOC intrinsic in dimension 2: is 3, should be 2\" }\n+"}, {"sha": "22e5bf0af7aa9ff3676282ae243bdca386b94a81", "filename": "gcc/testsuite/gfortran.dg/maxloc_bounds_4.f90", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/gcc%2Ftestsuite%2Fgfortran.dg%2Fmaxloc_bounds_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/gcc%2Ftestsuite%2Fgfortran.dg%2Fmaxloc_bounds_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fmaxloc_bounds_4.f90?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -0,0 +1,23 @@\n+! { dg-do run }\n+! { dg-options \"-fbounds-check\" }\n+! { dg-shouldfail \"Incorrect extent in return value of MAXLOC intrnisic: is 3, should be 2\" }\n+module tst\n+contains\n+  subroutine foo(res)\n+    integer(kind=4), allocatable :: f(:,:)\n+    integer, dimension(:) :: res\n+    allocate (f(2,5))\n+    f = 3\n+    res = maxloc(f)\n+  end subroutine foo\n+\n+end module tst\n+program main\n+  use tst\n+  implicit none\n+  integer(kind=4) :: res(3)\n+  call foo(res)\n+end program main\n+! { dg-output \"Fortran runtime error: Incorrect extent in return value of MAXLOC intrnisic: is 3, should be 2\" }\n+! { dg-final { cleanup-modules \"tst\" } }\n+"}, {"sha": "cbc0292115353a97a264248d549f2735eae4c978", "filename": "gcc/testsuite/gfortran.dg/maxloc_bounds_5.f90", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/gcc%2Ftestsuite%2Fgfortran.dg%2Fmaxloc_bounds_5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/gcc%2Ftestsuite%2Fgfortran.dg%2Fmaxloc_bounds_5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fmaxloc_bounds_5.f90?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -0,0 +1,22 @@\n+! { dg-do run }\n+! { dg-options \"-fbounds-check\" }\n+! { dg-shouldfail \"Incorrect extent in return value of MAXLOC intrnisic: is 3, should be 2\" }\n+module tst\n+contains\n+  subroutine foo(res)\n+    integer(kind=4), allocatable :: f(:,:)\n+    integer, dimension(:) :: res\n+    allocate (f(2,5))\n+    f = 3\n+    res = maxloc(f,mask=f>2)\n+  end subroutine foo\n+\n+end module tst\n+program main\n+  use tst\n+  implicit none\n+  integer(kind=4) :: res(3)\n+  call foo(res)\n+end program main\n+! { dg-output \"Fortran runtime error: Incorrect extent in return value of MAXLOC intrnisic: is 3, should be 2\" }\n+! { dg-final { cleanup-modules \"tst\" } }"}, {"sha": "74a78ff4727dc9e379f6380e9df2beac0191eb11", "filename": "gcc/testsuite/gfortran.dg/maxloc_bounds_6.f90", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/gcc%2Ftestsuite%2Fgfortran.dg%2Fmaxloc_bounds_6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/gcc%2Ftestsuite%2Fgfortran.dg%2Fmaxloc_bounds_6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fmaxloc_bounds_6.f90?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -0,0 +1,16 @@\n+! { dg-do run }\n+! { dg-options \"-fbounds-check\" }\n+! { dg-shouldfail \"Incorrect extent in MASK argument of MAXLOC intrinsic in dimension 2: is 3, should be 2\" }\n+program main\n+  integer(kind=4), allocatable :: f(:,:)\n+  logical, allocatable :: m(:,:)\n+  integer(kind=4) :: res(2)\n+  character(len=80) line\n+  allocate (f(2,2),m(2,3))\n+  f = 3\n+  m = .true.\n+  res = maxloc(f,mask=m)\n+  write(line,fmt='(80I1)') res\n+end program main\n+! { dg-output \"Fortran runtime error: Incorrect extent in MASK argument of MAXLOC intrinsic in dimension 2: is 3, should be 2\" }\n+! { dg-final { cleanup-modules \"tst\" } }"}, {"sha": "491a044ea0708a0ff9c4aec753d535809ed45965", "filename": "gcc/testsuite/gfortran.dg/maxloc_bounds_7.f90", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/gcc%2Ftestsuite%2Fgfortran.dg%2Fmaxloc_bounds_7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/gcc%2Ftestsuite%2Fgfortran.dg%2Fmaxloc_bounds_7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fmaxloc_bounds_7.f90?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -0,0 +1,22 @@\n+! { dg-do run }\n+! { dg-options \"-fbounds-check\" }\n+! { dg-shouldfail \"Incorrect extent in return value of MAXLOC intrnisic: is 3, should be 2\" }\n+module tst\n+contains\n+  subroutine foo(res)\n+    integer(kind=4), allocatable :: f(:,:)\n+    integer, dimension(:) :: res\n+    allocate (f(2,5))\n+    f = 3\n+    res = maxloc(f,mask=.true.)\n+  end subroutine foo\n+\n+end module tst\n+program main\n+  use tst\n+  implicit none\n+  integer(kind=4) :: res(3)\n+  call foo(res)\n+end program main\n+! { dg-output \"Fortran runtime error: Incorrect extent in return value of MAXLOC intrnisic: is 3, should be 2\" }\n+! { dg-final { cleanup-modules \"tst\" } }"}, {"sha": "4ec1137169531e32f8ac786c3e133bbd54d1e119", "filename": "gcc/testsuite/gfortran.dg/maxloc_bounds_8.f90", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/gcc%2Ftestsuite%2Fgfortran.dg%2Fmaxloc_bounds_8.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/gcc%2Ftestsuite%2Fgfortran.dg%2Fmaxloc_bounds_8.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fmaxloc_bounds_8.f90?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -0,0 +1,16 @@\n+! { dg-do run }\n+! { dg-options \"-fbounds-check\" }\n+! { dg-shouldfail \"Incorrect extent in return value of MAXLOC intrinsic in dimension 1: is 3, should be 2\" }\n+program main\n+  integer(kind=4), allocatable :: f(:,:)\n+  logical, allocatable :: m(:,:)\n+  integer(kind=4) :: res(3)\n+  character(len=80) line\n+  allocate (f(2,2),m(2,2))\n+  f = 3\n+  m = .true.\n+  res = maxloc(f,dim=1,mask=.true.)\n+  write(line,fmt='(80I1)') res\n+end program main\n+! { dg-output \"Fortran runtime error: Incorrect extent in return value of MAXLOC intrinsic in dimension 1: is 3, should be 2\" }\n+"}, {"sha": "34b730795e1590d1d4e0ebb8eb146833a023cbbd", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 183, "deletions": 0, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -1,3 +1,186 @@\n+2008-01-11  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR libfortran/34670\n+\t* m4/iparm.m4 (upcase):  New macro (copied from the m4 manual).\n+\t(u_name):  New macro for the upper case name of the intrinsic.\n+\t* m4/iforeach.m4 (name`'rtype_qual`_'atype_code):  Add\n+\tbounds checking and rank check, depending on\n+\tcompile_options.bounds_check.\n+\t(`m'name`'rtype_qual`_'atype_code):  Likewise.\n+\t(`s'name`'rtype_qual`_'atype_code):  Likewise.\n+\t* m4/ifunction.m4 (name`'rtype_qual`_'atype_code):  Add\n+\tbounds checking and rank check, depending on\n+\tcompile_options.bounds_check.\n+\t(`m'name`'rtype_qual`_'atype_code):  Likewise.\n+\t(`s'name`'rtype_qual`_'atype_code):  Likewise.\n+\t* generated/all_l16.c: Regenerated.\n+\t* generated/all_l4.c: Regenerated.\n+\t* generated/all_l8.c: Regenerated.\n+\t* generated/any_l16.c: Regenerated.\n+\t* generated/any_l4.c: Regenerated.\n+\t* generated/any_l8.c: Regenerated.\n+\t* generated/count_16_l16.c: Regenerated.\n+\t* generated/count_16_l4.c: Regenerated.\n+\t* generated/count_16_l8.c: Regenerated.\n+\t* generated/count_4_l16.c: Regenerated.\n+\t* generated/count_4_l4.c: Regenerated.\n+\t* generated/count_4_l8.c: Regenerated.\n+\t* generated/count_8_l16.c: Regenerated.\n+\t* generated/count_8_l4.c: Regenerated.\n+\t* generated/count_8_l8.c: Regenerated.\n+\t* generated/maxloc0_16_i1.c: Regenerated.\n+\t* generated/maxloc0_16_i16.c: Regenerated.\n+\t* generated/maxloc0_16_i2.c: Regenerated.\n+\t* generated/maxloc0_16_i4.c: Regenerated.\n+\t* generated/maxloc0_16_i8.c: Regenerated.\n+\t* generated/maxloc0_16_r10.c: Regenerated.\n+\t* generated/maxloc0_16_r16.c: Regenerated.\n+\t* generated/maxloc0_16_r4.c: Regenerated.\n+\t* generated/maxloc0_16_r8.c: Regenerated.\n+\t* generated/maxloc0_4_i1.c: Regenerated.\n+\t* generated/maxloc0_4_i16.c: Regenerated.\n+\t* generated/maxloc0_4_i2.c: Regenerated.\n+\t* generated/maxloc0_4_i4.c: Regenerated.\n+\t* generated/maxloc0_4_i8.c: Regenerated.\n+\t* generated/maxloc0_4_r10.c: Regenerated.\n+\t* generated/maxloc0_4_r16.c: Regenerated.\n+\t* generated/maxloc0_4_r4.c: Regenerated.\n+\t* generated/maxloc0_4_r8.c: Regenerated.\n+\t* generated/maxloc0_8_i1.c: Regenerated.\n+\t* generated/maxloc0_8_i16.c: Regenerated.\n+\t* generated/maxloc0_8_i2.c: Regenerated.\n+\t* generated/maxloc0_8_i4.c: Regenerated.\n+\t* generated/maxloc0_8_i8.c: Regenerated.\n+\t* generated/maxloc0_8_r10.c: Regenerated.\n+\t* generated/maxloc0_8_r16.c: Regenerated.\n+\t* generated/maxloc0_8_r4.c: Regenerated.\n+\t* generated/maxloc0_8_r8.c: Regenerated.\n+\t* generated/maxloc1_16_i1.c: Regenerated.\n+\t* generated/maxloc1_16_i16.c: Regenerated.\n+\t* generated/maxloc1_16_i2.c: Regenerated.\n+\t* generated/maxloc1_16_i4.c: Regenerated.\n+\t* generated/maxloc1_16_i8.c: Regenerated.\n+\t* generated/maxloc1_16_r10.c: Regenerated.\n+\t* generated/maxloc1_16_r16.c: Regenerated.\n+\t* generated/maxloc1_16_r4.c: Regenerated.\n+\t* generated/maxloc1_16_r8.c: Regenerated.\n+\t* generated/maxloc1_4_i1.c: Regenerated.\n+\t* generated/maxloc1_4_i16.c: Regenerated.\n+\t* generated/maxloc1_4_i2.c: Regenerated.\n+\t* generated/maxloc1_4_i4.c: Regenerated.\n+\t* generated/maxloc1_4_i8.c: Regenerated.\n+\t* generated/maxloc1_4_r10.c: Regenerated.\n+\t* generated/maxloc1_4_r16.c: Regenerated.\n+\t* generated/maxloc1_4_r4.c: Regenerated.\n+\t* generated/maxloc1_4_r8.c: Regenerated.\n+\t* generated/maxloc1_8_i1.c: Regenerated.\n+\t* generated/maxloc1_8_i16.c: Regenerated.\n+\t* generated/maxloc1_8_i2.c: Regenerated.\n+\t* generated/maxloc1_8_i4.c: Regenerated.\n+\t* generated/maxloc1_8_i8.c: Regenerated.\n+\t* generated/maxloc1_8_r10.c: Regenerated.\n+\t* generated/maxloc1_8_r16.c: Regenerated.\n+\t* generated/maxloc1_8_r4.c: Regenerated.\n+\t* generated/maxloc1_8_r8.c: Regenerated.\n+\t* generated/maxval_i1.c: Regenerated.\n+\t* generated/maxval_i16.c: Regenerated.\n+\t* generated/maxval_i2.c: Regenerated.\n+\t* generated/maxval_i4.c: Regenerated.\n+\t* generated/maxval_i8.c: Regenerated.\n+\t* generated/maxval_r10.c: Regenerated.\n+\t* generated/maxval_r16.c: Regenerated.\n+\t* generated/maxval_r4.c: Regenerated.\n+\t* generated/maxval_r8.c: Regenerated.\n+\t* generated/minloc0_16_i1.c: Regenerated.\n+\t* generated/minloc0_16_i16.c: Regenerated.\n+\t* generated/minloc0_16_i2.c: Regenerated.\n+\t* generated/minloc0_16_i4.c: Regenerated.\n+\t* generated/minloc0_16_i8.c: Regenerated.\n+\t* generated/minloc0_16_r10.c: Regenerated.\n+\t* generated/minloc0_16_r16.c: Regenerated.\n+\t* generated/minloc0_16_r4.c: Regenerated.\n+\t* generated/minloc0_16_r8.c: Regenerated.\n+\t* generated/minloc0_4_i1.c: Regenerated.\n+\t* generated/minloc0_4_i16.c: Regenerated.\n+\t* generated/minloc0_4_i2.c: Regenerated.\n+\t* generated/minloc0_4_i4.c: Regenerated.\n+\t* generated/minloc0_4_i8.c: Regenerated.\n+\t* generated/minloc0_4_r10.c: Regenerated.\n+\t* generated/minloc0_4_r16.c: Regenerated.\n+\t* generated/minloc0_4_r4.c: Regenerated.\n+\t* generated/minloc0_4_r8.c: Regenerated.\n+\t* generated/minloc0_8_i1.c: Regenerated.\n+\t* generated/minloc0_8_i16.c: Regenerated.\n+\t* generated/minloc0_8_i2.c: Regenerated.\n+\t* generated/minloc0_8_i4.c: Regenerated.\n+\t* generated/minloc0_8_i8.c: Regenerated.\n+\t* generated/minloc0_8_r10.c: Regenerated.\n+\t* generated/minloc0_8_r16.c: Regenerated.\n+\t* generated/minloc0_8_r4.c: Regenerated.\n+\t* generated/minloc0_8_r8.c: Regenerated.\n+\t* generated/minloc1_16_i1.c: Regenerated.\n+\t* generated/minloc1_16_i16.c: Regenerated.\n+\t* generated/minloc1_16_i2.c: Regenerated.\n+\t* generated/minloc1_16_i4.c: Regenerated.\n+\t* generated/minloc1_16_i8.c: Regenerated.\n+\t* generated/minloc1_16_r10.c: Regenerated.\n+\t* generated/minloc1_16_r16.c: Regenerated.\n+\t* generated/minloc1_16_r4.c: Regenerated.\n+\t* generated/minloc1_16_r8.c: Regenerated.\n+\t* generated/minloc1_4_i1.c: Regenerated.\n+\t* generated/minloc1_4_i16.c: Regenerated.\n+\t* generated/minloc1_4_i2.c: Regenerated.\n+\t* generated/minloc1_4_i4.c: Regenerated.\n+\t* generated/minloc1_4_i8.c: Regenerated.\n+\t* generated/minloc1_4_r10.c: Regenerated.\n+\t* generated/minloc1_4_r16.c: Regenerated.\n+\t* generated/minloc1_4_r4.c: Regenerated.\n+\t* generated/minloc1_4_r8.c: Regenerated.\n+\t* generated/minloc1_8_i1.c: Regenerated.\n+\t* generated/minloc1_8_i16.c: Regenerated.\n+\t* generated/minloc1_8_i2.c: Regenerated.\n+\t* generated/minloc1_8_i4.c: Regenerated.\n+\t* generated/minloc1_8_i8.c: Regenerated.\n+\t* generated/minloc1_8_r10.c: Regenerated.\n+\t* generated/minloc1_8_r16.c: Regenerated.\n+\t* generated/minloc1_8_r4.c: Regenerated.\n+\t* generated/minloc1_8_r8.c: Regenerated.\n+\t* generated/minval_i1.c: Regenerated.\n+\t* generated/minval_i16.c: Regenerated.\n+\t* generated/minval_i2.c: Regenerated.\n+\t* generated/minval_i4.c: Regenerated.\n+\t* generated/minval_i8.c: Regenerated.\n+\t* generated/minval_r10.c: Regenerated.\n+\t* generated/minval_r16.c: Regenerated.\n+\t* generated/minval_r4.c: Regenerated.\n+\t* generated/minval_r8.c: Regenerated.\n+\t* generated/product_c10.c: Regenerated.\n+\t* generated/product_c16.c: Regenerated.\n+\t* generated/product_c4.c: Regenerated.\n+\t* generated/product_c8.c: Regenerated.\n+\t* generated/product_i1.c: Regenerated.\n+\t* generated/product_i16.c: Regenerated.\n+\t* generated/product_i2.c: Regenerated.\n+\t* generated/product_i4.c: Regenerated.\n+\t* generated/product_i8.c: Regenerated.\n+\t* generated/product_r10.c: Regenerated.\n+\t* generated/product_r16.c: Regenerated.\n+\t* generated/product_r4.c: Regenerated.\n+\t* generated/product_r8.c: Regenerated.\n+\t* generated/sum_c10.c: Regenerated.\n+\t* generated/sum_c16.c: Regenerated.\n+\t* generated/sum_c4.c: Regenerated.\n+\t* generated/sum_c8.c: Regenerated.\n+\t* generated/sum_i1.c: Regenerated.\n+\t* generated/sum_i16.c: Regenerated.\n+\t* generated/sum_i2.c: Regenerated.\n+\t* generated/sum_i4.c: Regenerated.\n+\t* generated/sum_i8.c: Regenerated.\n+\t* generated/sum_r10.c: Regenerated.\n+\t* generated/sum_r16.c: Regenerated.\n+\t* generated/sum_r4.c: Regenerated.\n+\t* generated/sum_r8.c: Regenerated.\n+\n 2008-01-05  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR libfortran/34676"}, {"sha": "2cc81ce423a09d59c02d212fd333c9806af455ae", "filename": "libgfortran/generated/all_l16.c", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fall_l16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fall_l16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fall_l16.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -115,7 +115,25 @@ all_l16 (gfc_array_l16 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" ALL intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" ALL intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)"}, {"sha": "12f9efb2b915a81ee92c268b1c4ec10fa73e28d7", "filename": "libgfortran/generated/all_l4.c", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fall_l4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fall_l4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fall_l4.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -115,7 +115,25 @@ all_l4 (gfc_array_l4 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" ALL intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" ALL intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)"}, {"sha": "c9fa80935ae82a93d70221e755ded43776da1337", "filename": "libgfortran/generated/all_l8.c", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fall_l8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fall_l8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fall_l8.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -115,7 +115,25 @@ all_l8 (gfc_array_l8 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" ALL intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" ALL intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)"}, {"sha": "1ba59edbadd12d283f7e0b830e4b73f702ef603c", "filename": "libgfortran/generated/any_l16.c", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fany_l16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fany_l16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fany_l16.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -115,7 +115,25 @@ any_l16 (gfc_array_l16 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" ANY intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" ANY intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)"}, {"sha": "83116ebe9cac58c4a59daa079d2a7713e7d51b97", "filename": "libgfortran/generated/any_l4.c", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fany_l4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fany_l4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fany_l4.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -115,7 +115,25 @@ any_l4 (gfc_array_l4 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" ANY intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" ANY intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)"}, {"sha": "a85e6e89ca0dbdf5dcf91bc181f7b051c16dcd6d", "filename": "libgfortran/generated/any_l8.c", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fany_l8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fany_l8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fany_l8.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -115,7 +115,25 @@ any_l8 (gfc_array_l8 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" ANY intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" ANY intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)"}, {"sha": "351eb8a1e6562dea98fb4f4661762c74ef7d74a8", "filename": "libgfortran/generated/count_16_l16.c", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fcount_16_l16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fcount_16_l16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcount_16_l16.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -115,7 +115,25 @@ count_16_l16 (gfc_array_i16 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" COUNT intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" COUNT intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)"}, {"sha": "9f849d8b725609851144fa2a0127551efc032d6e", "filename": "libgfortran/generated/count_16_l4.c", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fcount_16_l4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fcount_16_l4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcount_16_l4.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -115,7 +115,25 @@ count_16_l4 (gfc_array_i16 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" COUNT intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" COUNT intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)"}, {"sha": "90659da0a1775a2f8696e1a98a25fd9a264132f5", "filename": "libgfortran/generated/count_16_l8.c", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fcount_16_l8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fcount_16_l8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcount_16_l8.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -115,7 +115,25 @@ count_16_l8 (gfc_array_i16 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" COUNT intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" COUNT intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)"}, {"sha": "c3b3daad85a518481f317b249af8f06a2892bf6c", "filename": "libgfortran/generated/count_4_l16.c", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fcount_4_l16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fcount_4_l16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcount_4_l16.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -115,7 +115,25 @@ count_4_l16 (gfc_array_i4 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" COUNT intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" COUNT intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)"}, {"sha": "3bfcf179c75a345a4b46cb2937032391ca8caf01", "filename": "libgfortran/generated/count_4_l4.c", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fcount_4_l4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fcount_4_l4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcount_4_l4.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -115,7 +115,25 @@ count_4_l4 (gfc_array_i4 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" COUNT intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" COUNT intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)"}, {"sha": "7debda799bbd9ce68212427170a64663fe65d6e5", "filename": "libgfortran/generated/count_4_l8.c", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fcount_4_l8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fcount_4_l8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcount_4_l8.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -115,7 +115,25 @@ count_4_l8 (gfc_array_i4 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" COUNT intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" COUNT intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)"}, {"sha": "815b79ab65cbf901ddad23347022424093de9bda", "filename": "libgfortran/generated/count_8_l16.c", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fcount_8_l16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fcount_8_l16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcount_8_l16.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -115,7 +115,25 @@ count_8_l16 (gfc_array_i8 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" COUNT intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" COUNT intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)"}, {"sha": "84401ded1e15c3a407a8e037a6caeb74d5921436", "filename": "libgfortran/generated/count_8_l4.c", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fcount_8_l4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fcount_8_l4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcount_8_l4.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -115,7 +115,25 @@ count_8_l4 (gfc_array_i8 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" COUNT intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" COUNT intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)"}, {"sha": "fd26280a550c1e5893c992da6c8fb7d96f7bdf70", "filename": "libgfortran/generated/count_8_l8.c", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fcount_8_l8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fcount_8_l8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcount_8_l8.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -115,7 +115,25 @@ count_8_l8 (gfc_array_i8 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" COUNT intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" COUNT intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)"}, {"sha": "3cd6554a3460f96664558124127362ff09162501", "filename": "libgfortran/generated/maxloc0_16_i1.c", "status": "modified", "additions": 63, "deletions": 14, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc0_16_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc0_16_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_16_i1.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -69,11 +69,22 @@ maxloc0_16_i1 (gfc_array_i16 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MAXLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;\n@@ -182,11 +193,40 @@ mmaxloc0_16_i1 (gfc_array_i16 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank, mask_rank;\n+\t  index_type ret_extent;\n+\t  int n;\n+\t  index_type array_extent, mask_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MAXLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t\n+\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n+\t  if (rank != mask_rank)\n+\t    runtime_error (\"rank of MASK argument in MAXLOC intrnisic\"\n+\t                   \"should be %d, is %d\", rank, mask_rank);\n+\n+\t  for (n=0; n<rank; n++)\n+\t    {\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n@@ -312,11 +352,20 @@ smaxloc0_16_i1 (gfc_array_i16 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;"}, {"sha": "9bfec04301311e808f9b2303a09f7edf83db62e2", "filename": "libgfortran/generated/maxloc0_16_i16.c", "status": "modified", "additions": 63, "deletions": 14, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc0_16_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc0_16_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_16_i16.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -69,11 +69,22 @@ maxloc0_16_i16 (gfc_array_i16 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MAXLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;\n@@ -182,11 +193,40 @@ mmaxloc0_16_i16 (gfc_array_i16 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank, mask_rank;\n+\t  index_type ret_extent;\n+\t  int n;\n+\t  index_type array_extent, mask_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MAXLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t\n+\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n+\t  if (rank != mask_rank)\n+\t    runtime_error (\"rank of MASK argument in MAXLOC intrnisic\"\n+\t                   \"should be %d, is %d\", rank, mask_rank);\n+\n+\t  for (n=0; n<rank; n++)\n+\t    {\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n@@ -312,11 +352,20 @@ smaxloc0_16_i16 (gfc_array_i16 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;"}, {"sha": "b57e78f927468b9733310fd16db8369efe67af68", "filename": "libgfortran/generated/maxloc0_16_i2.c", "status": "modified", "additions": 63, "deletions": 14, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc0_16_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc0_16_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_16_i2.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -69,11 +69,22 @@ maxloc0_16_i2 (gfc_array_i16 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MAXLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;\n@@ -182,11 +193,40 @@ mmaxloc0_16_i2 (gfc_array_i16 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank, mask_rank;\n+\t  index_type ret_extent;\n+\t  int n;\n+\t  index_type array_extent, mask_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MAXLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t\n+\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n+\t  if (rank != mask_rank)\n+\t    runtime_error (\"rank of MASK argument in MAXLOC intrnisic\"\n+\t                   \"should be %d, is %d\", rank, mask_rank);\n+\n+\t  for (n=0; n<rank; n++)\n+\t    {\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n@@ -312,11 +352,20 @@ smaxloc0_16_i2 (gfc_array_i16 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;"}, {"sha": "2e123b6d2959265d723efe7264d49c5784f255f7", "filename": "libgfortran/generated/maxloc0_16_i4.c", "status": "modified", "additions": 63, "deletions": 14, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc0_16_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc0_16_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_16_i4.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -69,11 +69,22 @@ maxloc0_16_i4 (gfc_array_i16 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MAXLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;\n@@ -182,11 +193,40 @@ mmaxloc0_16_i4 (gfc_array_i16 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank, mask_rank;\n+\t  index_type ret_extent;\n+\t  int n;\n+\t  index_type array_extent, mask_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MAXLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t\n+\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n+\t  if (rank != mask_rank)\n+\t    runtime_error (\"rank of MASK argument in MAXLOC intrnisic\"\n+\t                   \"should be %d, is %d\", rank, mask_rank);\n+\n+\t  for (n=0; n<rank; n++)\n+\t    {\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n@@ -312,11 +352,20 @@ smaxloc0_16_i4 (gfc_array_i16 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;"}, {"sha": "cd141a692227dbbe95b69d66bd4e6c0b3902b074", "filename": "libgfortran/generated/maxloc0_16_i8.c", "status": "modified", "additions": 63, "deletions": 14, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc0_16_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc0_16_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_16_i8.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -69,11 +69,22 @@ maxloc0_16_i8 (gfc_array_i16 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MAXLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;\n@@ -182,11 +193,40 @@ mmaxloc0_16_i8 (gfc_array_i16 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank, mask_rank;\n+\t  index_type ret_extent;\n+\t  int n;\n+\t  index_type array_extent, mask_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MAXLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t\n+\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n+\t  if (rank != mask_rank)\n+\t    runtime_error (\"rank of MASK argument in MAXLOC intrnisic\"\n+\t                   \"should be %d, is %d\", rank, mask_rank);\n+\n+\t  for (n=0; n<rank; n++)\n+\t    {\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n@@ -312,11 +352,20 @@ smaxloc0_16_i8 (gfc_array_i16 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;"}, {"sha": "8426d3af81e4a4034e85dcf504c8ff528b5606a4", "filename": "libgfortran/generated/maxloc0_16_r10.c", "status": "modified", "additions": 63, "deletions": 14, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc0_16_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc0_16_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_16_r10.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -69,11 +69,22 @@ maxloc0_16_r10 (gfc_array_i16 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MAXLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;\n@@ -182,11 +193,40 @@ mmaxloc0_16_r10 (gfc_array_i16 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank, mask_rank;\n+\t  index_type ret_extent;\n+\t  int n;\n+\t  index_type array_extent, mask_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MAXLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t\n+\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n+\t  if (rank != mask_rank)\n+\t    runtime_error (\"rank of MASK argument in MAXLOC intrnisic\"\n+\t                   \"should be %d, is %d\", rank, mask_rank);\n+\n+\t  for (n=0; n<rank; n++)\n+\t    {\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n@@ -312,11 +352,20 @@ smaxloc0_16_r10 (gfc_array_i16 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;"}, {"sha": "3244452c601e85d089a438294bfe413d258653f6", "filename": "libgfortran/generated/maxloc0_16_r16.c", "status": "modified", "additions": 63, "deletions": 14, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc0_16_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc0_16_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_16_r16.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -69,11 +69,22 @@ maxloc0_16_r16 (gfc_array_i16 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MAXLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;\n@@ -182,11 +193,40 @@ mmaxloc0_16_r16 (gfc_array_i16 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank, mask_rank;\n+\t  index_type ret_extent;\n+\t  int n;\n+\t  index_type array_extent, mask_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MAXLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t\n+\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n+\t  if (rank != mask_rank)\n+\t    runtime_error (\"rank of MASK argument in MAXLOC intrnisic\"\n+\t                   \"should be %d, is %d\", rank, mask_rank);\n+\n+\t  for (n=0; n<rank; n++)\n+\t    {\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n@@ -312,11 +352,20 @@ smaxloc0_16_r16 (gfc_array_i16 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;"}, {"sha": "8057063339c4f50629248fce78e8a524f62118f8", "filename": "libgfortran/generated/maxloc0_16_r4.c", "status": "modified", "additions": 63, "deletions": 14, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc0_16_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc0_16_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_16_r4.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -69,11 +69,22 @@ maxloc0_16_r4 (gfc_array_i16 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MAXLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;\n@@ -182,11 +193,40 @@ mmaxloc0_16_r4 (gfc_array_i16 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank, mask_rank;\n+\t  index_type ret_extent;\n+\t  int n;\n+\t  index_type array_extent, mask_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MAXLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t\n+\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n+\t  if (rank != mask_rank)\n+\t    runtime_error (\"rank of MASK argument in MAXLOC intrnisic\"\n+\t                   \"should be %d, is %d\", rank, mask_rank);\n+\n+\t  for (n=0; n<rank; n++)\n+\t    {\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n@@ -312,11 +352,20 @@ smaxloc0_16_r4 (gfc_array_i16 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;"}, {"sha": "6c12815a0a11ca593899949469657ff25ab755d5", "filename": "libgfortran/generated/maxloc0_16_r8.c", "status": "modified", "additions": 63, "deletions": 14, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc0_16_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc0_16_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_16_r8.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -69,11 +69,22 @@ maxloc0_16_r8 (gfc_array_i16 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MAXLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;\n@@ -182,11 +193,40 @@ mmaxloc0_16_r8 (gfc_array_i16 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank, mask_rank;\n+\t  index_type ret_extent;\n+\t  int n;\n+\t  index_type array_extent, mask_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MAXLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t\n+\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n+\t  if (rank != mask_rank)\n+\t    runtime_error (\"rank of MASK argument in MAXLOC intrnisic\"\n+\t                   \"should be %d, is %d\", rank, mask_rank);\n+\n+\t  for (n=0; n<rank; n++)\n+\t    {\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n@@ -312,11 +352,20 @@ smaxloc0_16_r8 (gfc_array_i16 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;"}, {"sha": "42c865a6e29bd134b92e04d8e3853ada529294c0", "filename": "libgfortran/generated/maxloc0_4_i1.c", "status": "modified", "additions": 63, "deletions": 14, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc0_4_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc0_4_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_4_i1.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -69,11 +69,22 @@ maxloc0_4_i1 (gfc_array_i4 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MAXLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;\n@@ -182,11 +193,40 @@ mmaxloc0_4_i1 (gfc_array_i4 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank, mask_rank;\n+\t  index_type ret_extent;\n+\t  int n;\n+\t  index_type array_extent, mask_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MAXLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t\n+\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n+\t  if (rank != mask_rank)\n+\t    runtime_error (\"rank of MASK argument in MAXLOC intrnisic\"\n+\t                   \"should be %d, is %d\", rank, mask_rank);\n+\n+\t  for (n=0; n<rank; n++)\n+\t    {\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n@@ -312,11 +352,20 @@ smaxloc0_4_i1 (gfc_array_i4 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;"}, {"sha": "938ceba697470dc9e288a1ae7ead55c52ada2171", "filename": "libgfortran/generated/maxloc0_4_i16.c", "status": "modified", "additions": 63, "deletions": 14, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc0_4_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc0_4_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_4_i16.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -69,11 +69,22 @@ maxloc0_4_i16 (gfc_array_i4 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MAXLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;\n@@ -182,11 +193,40 @@ mmaxloc0_4_i16 (gfc_array_i4 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank, mask_rank;\n+\t  index_type ret_extent;\n+\t  int n;\n+\t  index_type array_extent, mask_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MAXLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t\n+\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n+\t  if (rank != mask_rank)\n+\t    runtime_error (\"rank of MASK argument in MAXLOC intrnisic\"\n+\t                   \"should be %d, is %d\", rank, mask_rank);\n+\n+\t  for (n=0; n<rank; n++)\n+\t    {\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n@@ -312,11 +352,20 @@ smaxloc0_4_i16 (gfc_array_i4 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;"}, {"sha": "809d93821dc56e3c9e958822d7bb0b21e63ffc79", "filename": "libgfortran/generated/maxloc0_4_i2.c", "status": "modified", "additions": 63, "deletions": 14, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc0_4_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc0_4_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_4_i2.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -69,11 +69,22 @@ maxloc0_4_i2 (gfc_array_i4 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MAXLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;\n@@ -182,11 +193,40 @@ mmaxloc0_4_i2 (gfc_array_i4 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank, mask_rank;\n+\t  index_type ret_extent;\n+\t  int n;\n+\t  index_type array_extent, mask_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MAXLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t\n+\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n+\t  if (rank != mask_rank)\n+\t    runtime_error (\"rank of MASK argument in MAXLOC intrnisic\"\n+\t                   \"should be %d, is %d\", rank, mask_rank);\n+\n+\t  for (n=0; n<rank; n++)\n+\t    {\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n@@ -312,11 +352,20 @@ smaxloc0_4_i2 (gfc_array_i4 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;"}, {"sha": "5108cbe1366035dd45eb011a5e0e179032d3942f", "filename": "libgfortran/generated/maxloc0_4_i4.c", "status": "modified", "additions": 63, "deletions": 14, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc0_4_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc0_4_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_4_i4.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -69,11 +69,22 @@ maxloc0_4_i4 (gfc_array_i4 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MAXLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;\n@@ -182,11 +193,40 @@ mmaxloc0_4_i4 (gfc_array_i4 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank, mask_rank;\n+\t  index_type ret_extent;\n+\t  int n;\n+\t  index_type array_extent, mask_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MAXLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t\n+\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n+\t  if (rank != mask_rank)\n+\t    runtime_error (\"rank of MASK argument in MAXLOC intrnisic\"\n+\t                   \"should be %d, is %d\", rank, mask_rank);\n+\n+\t  for (n=0; n<rank; n++)\n+\t    {\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n@@ -312,11 +352,20 @@ smaxloc0_4_i4 (gfc_array_i4 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;"}, {"sha": "987b424d7e16ff748b001798f4e6fd14560075e4", "filename": "libgfortran/generated/maxloc0_4_i8.c", "status": "modified", "additions": 63, "deletions": 14, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc0_4_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc0_4_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_4_i8.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -69,11 +69,22 @@ maxloc0_4_i8 (gfc_array_i4 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MAXLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;\n@@ -182,11 +193,40 @@ mmaxloc0_4_i8 (gfc_array_i4 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank, mask_rank;\n+\t  index_type ret_extent;\n+\t  int n;\n+\t  index_type array_extent, mask_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MAXLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t\n+\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n+\t  if (rank != mask_rank)\n+\t    runtime_error (\"rank of MASK argument in MAXLOC intrnisic\"\n+\t                   \"should be %d, is %d\", rank, mask_rank);\n+\n+\t  for (n=0; n<rank; n++)\n+\t    {\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n@@ -312,11 +352,20 @@ smaxloc0_4_i8 (gfc_array_i4 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;"}, {"sha": "b3101bd6ac8d2cb275d5bef509d397df8ebf1c4d", "filename": "libgfortran/generated/maxloc0_4_r10.c", "status": "modified", "additions": 63, "deletions": 14, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc0_4_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc0_4_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_4_r10.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -69,11 +69,22 @@ maxloc0_4_r10 (gfc_array_i4 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MAXLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;\n@@ -182,11 +193,40 @@ mmaxloc0_4_r10 (gfc_array_i4 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank, mask_rank;\n+\t  index_type ret_extent;\n+\t  int n;\n+\t  index_type array_extent, mask_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MAXLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t\n+\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n+\t  if (rank != mask_rank)\n+\t    runtime_error (\"rank of MASK argument in MAXLOC intrnisic\"\n+\t                   \"should be %d, is %d\", rank, mask_rank);\n+\n+\t  for (n=0; n<rank; n++)\n+\t    {\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n@@ -312,11 +352,20 @@ smaxloc0_4_r10 (gfc_array_i4 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;"}, {"sha": "9b1e5274a3f905e4557d8092f8913fddb3aa5d97", "filename": "libgfortran/generated/maxloc0_4_r16.c", "status": "modified", "additions": 63, "deletions": 14, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc0_4_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc0_4_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_4_r16.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -69,11 +69,22 @@ maxloc0_4_r16 (gfc_array_i4 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MAXLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;\n@@ -182,11 +193,40 @@ mmaxloc0_4_r16 (gfc_array_i4 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank, mask_rank;\n+\t  index_type ret_extent;\n+\t  int n;\n+\t  index_type array_extent, mask_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MAXLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t\n+\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n+\t  if (rank != mask_rank)\n+\t    runtime_error (\"rank of MASK argument in MAXLOC intrnisic\"\n+\t                   \"should be %d, is %d\", rank, mask_rank);\n+\n+\t  for (n=0; n<rank; n++)\n+\t    {\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n@@ -312,11 +352,20 @@ smaxloc0_4_r16 (gfc_array_i4 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;"}, {"sha": "bf4692c26f08fa7ea5e2309c7b662385019e9a51", "filename": "libgfortran/generated/maxloc0_4_r4.c", "status": "modified", "additions": 63, "deletions": 14, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc0_4_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc0_4_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_4_r4.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -69,11 +69,22 @@ maxloc0_4_r4 (gfc_array_i4 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MAXLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;\n@@ -182,11 +193,40 @@ mmaxloc0_4_r4 (gfc_array_i4 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank, mask_rank;\n+\t  index_type ret_extent;\n+\t  int n;\n+\t  index_type array_extent, mask_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MAXLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t\n+\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n+\t  if (rank != mask_rank)\n+\t    runtime_error (\"rank of MASK argument in MAXLOC intrnisic\"\n+\t                   \"should be %d, is %d\", rank, mask_rank);\n+\n+\t  for (n=0; n<rank; n++)\n+\t    {\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n@@ -312,11 +352,20 @@ smaxloc0_4_r4 (gfc_array_i4 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;"}, {"sha": "774a6734c2d21a8934d4cb80f8b48e7b9d43e34b", "filename": "libgfortran/generated/maxloc0_4_r8.c", "status": "modified", "additions": 63, "deletions": 14, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc0_4_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc0_4_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_4_r8.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -69,11 +69,22 @@ maxloc0_4_r8 (gfc_array_i4 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MAXLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;\n@@ -182,11 +193,40 @@ mmaxloc0_4_r8 (gfc_array_i4 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank, mask_rank;\n+\t  index_type ret_extent;\n+\t  int n;\n+\t  index_type array_extent, mask_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MAXLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t\n+\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n+\t  if (rank != mask_rank)\n+\t    runtime_error (\"rank of MASK argument in MAXLOC intrnisic\"\n+\t                   \"should be %d, is %d\", rank, mask_rank);\n+\n+\t  for (n=0; n<rank; n++)\n+\t    {\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n@@ -312,11 +352,20 @@ smaxloc0_4_r8 (gfc_array_i4 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;"}, {"sha": "38890b70dcfb919426157cf072d768a98746ef89", "filename": "libgfortran/generated/maxloc0_8_i1.c", "status": "modified", "additions": 63, "deletions": 14, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc0_8_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc0_8_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_8_i1.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -69,11 +69,22 @@ maxloc0_8_i1 (gfc_array_i8 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MAXLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;\n@@ -182,11 +193,40 @@ mmaxloc0_8_i1 (gfc_array_i8 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank, mask_rank;\n+\t  index_type ret_extent;\n+\t  int n;\n+\t  index_type array_extent, mask_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MAXLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t\n+\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n+\t  if (rank != mask_rank)\n+\t    runtime_error (\"rank of MASK argument in MAXLOC intrnisic\"\n+\t                   \"should be %d, is %d\", rank, mask_rank);\n+\n+\t  for (n=0; n<rank; n++)\n+\t    {\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n@@ -312,11 +352,20 @@ smaxloc0_8_i1 (gfc_array_i8 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;"}, {"sha": "be99a8ca0b10301616fe9104847342c3b3b1f4da", "filename": "libgfortran/generated/maxloc0_8_i16.c", "status": "modified", "additions": 63, "deletions": 14, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc0_8_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc0_8_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_8_i16.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -69,11 +69,22 @@ maxloc0_8_i16 (gfc_array_i8 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MAXLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;\n@@ -182,11 +193,40 @@ mmaxloc0_8_i16 (gfc_array_i8 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank, mask_rank;\n+\t  index_type ret_extent;\n+\t  int n;\n+\t  index_type array_extent, mask_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MAXLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t\n+\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n+\t  if (rank != mask_rank)\n+\t    runtime_error (\"rank of MASK argument in MAXLOC intrnisic\"\n+\t                   \"should be %d, is %d\", rank, mask_rank);\n+\n+\t  for (n=0; n<rank; n++)\n+\t    {\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n@@ -312,11 +352,20 @@ smaxloc0_8_i16 (gfc_array_i8 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;"}, {"sha": "02a5f645e8ec4e1288a8695a8ef0b6177762816d", "filename": "libgfortran/generated/maxloc0_8_i2.c", "status": "modified", "additions": 63, "deletions": 14, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc0_8_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc0_8_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_8_i2.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -69,11 +69,22 @@ maxloc0_8_i2 (gfc_array_i8 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MAXLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;\n@@ -182,11 +193,40 @@ mmaxloc0_8_i2 (gfc_array_i8 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank, mask_rank;\n+\t  index_type ret_extent;\n+\t  int n;\n+\t  index_type array_extent, mask_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MAXLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t\n+\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n+\t  if (rank != mask_rank)\n+\t    runtime_error (\"rank of MASK argument in MAXLOC intrnisic\"\n+\t                   \"should be %d, is %d\", rank, mask_rank);\n+\n+\t  for (n=0; n<rank; n++)\n+\t    {\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n@@ -312,11 +352,20 @@ smaxloc0_8_i2 (gfc_array_i8 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;"}, {"sha": "dca0b768861c3039eca0a9169b5ec928d5b47fa2", "filename": "libgfortran/generated/maxloc0_8_i4.c", "status": "modified", "additions": 63, "deletions": 14, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc0_8_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc0_8_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_8_i4.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -69,11 +69,22 @@ maxloc0_8_i4 (gfc_array_i8 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MAXLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;\n@@ -182,11 +193,40 @@ mmaxloc0_8_i4 (gfc_array_i8 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank, mask_rank;\n+\t  index_type ret_extent;\n+\t  int n;\n+\t  index_type array_extent, mask_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MAXLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t\n+\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n+\t  if (rank != mask_rank)\n+\t    runtime_error (\"rank of MASK argument in MAXLOC intrnisic\"\n+\t                   \"should be %d, is %d\", rank, mask_rank);\n+\n+\t  for (n=0; n<rank; n++)\n+\t    {\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n@@ -312,11 +352,20 @@ smaxloc0_8_i4 (gfc_array_i8 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;"}, {"sha": "d11ba2677f2ba8028aa0e761a0a92d6fa4d295e6", "filename": "libgfortran/generated/maxloc0_8_i8.c", "status": "modified", "additions": 63, "deletions": 14, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc0_8_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc0_8_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_8_i8.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -69,11 +69,22 @@ maxloc0_8_i8 (gfc_array_i8 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MAXLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;\n@@ -182,11 +193,40 @@ mmaxloc0_8_i8 (gfc_array_i8 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank, mask_rank;\n+\t  index_type ret_extent;\n+\t  int n;\n+\t  index_type array_extent, mask_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MAXLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t\n+\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n+\t  if (rank != mask_rank)\n+\t    runtime_error (\"rank of MASK argument in MAXLOC intrnisic\"\n+\t                   \"should be %d, is %d\", rank, mask_rank);\n+\n+\t  for (n=0; n<rank; n++)\n+\t    {\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n@@ -312,11 +352,20 @@ smaxloc0_8_i8 (gfc_array_i8 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;"}, {"sha": "898f1f576736f679b34c18af48c65e3427ea1d09", "filename": "libgfortran/generated/maxloc0_8_r10.c", "status": "modified", "additions": 63, "deletions": 14, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc0_8_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc0_8_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_8_r10.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -69,11 +69,22 @@ maxloc0_8_r10 (gfc_array_i8 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MAXLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;\n@@ -182,11 +193,40 @@ mmaxloc0_8_r10 (gfc_array_i8 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank, mask_rank;\n+\t  index_type ret_extent;\n+\t  int n;\n+\t  index_type array_extent, mask_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MAXLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t\n+\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n+\t  if (rank != mask_rank)\n+\t    runtime_error (\"rank of MASK argument in MAXLOC intrnisic\"\n+\t                   \"should be %d, is %d\", rank, mask_rank);\n+\n+\t  for (n=0; n<rank; n++)\n+\t    {\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n@@ -312,11 +352,20 @@ smaxloc0_8_r10 (gfc_array_i8 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;"}, {"sha": "6dec78a49f96389a4d5cfae73e7213b96d977298", "filename": "libgfortran/generated/maxloc0_8_r16.c", "status": "modified", "additions": 63, "deletions": 14, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc0_8_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc0_8_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_8_r16.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -69,11 +69,22 @@ maxloc0_8_r16 (gfc_array_i8 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MAXLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;\n@@ -182,11 +193,40 @@ mmaxloc0_8_r16 (gfc_array_i8 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank, mask_rank;\n+\t  index_type ret_extent;\n+\t  int n;\n+\t  index_type array_extent, mask_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MAXLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t\n+\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n+\t  if (rank != mask_rank)\n+\t    runtime_error (\"rank of MASK argument in MAXLOC intrnisic\"\n+\t                   \"should be %d, is %d\", rank, mask_rank);\n+\n+\t  for (n=0; n<rank; n++)\n+\t    {\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n@@ -312,11 +352,20 @@ smaxloc0_8_r16 (gfc_array_i8 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;"}, {"sha": "345dbe1a9d160e537235536cd2fc741b136e1e56", "filename": "libgfortran/generated/maxloc0_8_r4.c", "status": "modified", "additions": 63, "deletions": 14, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc0_8_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc0_8_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_8_r4.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -69,11 +69,22 @@ maxloc0_8_r4 (gfc_array_i8 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MAXLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;\n@@ -182,11 +193,40 @@ mmaxloc0_8_r4 (gfc_array_i8 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank, mask_rank;\n+\t  index_type ret_extent;\n+\t  int n;\n+\t  index_type array_extent, mask_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MAXLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t\n+\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n+\t  if (rank != mask_rank)\n+\t    runtime_error (\"rank of MASK argument in MAXLOC intrnisic\"\n+\t                   \"should be %d, is %d\", rank, mask_rank);\n+\n+\t  for (n=0; n<rank; n++)\n+\t    {\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n@@ -312,11 +352,20 @@ smaxloc0_8_r4 (gfc_array_i8 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;"}, {"sha": "bf7020e1a101b641d9c821eda2c9bae5956fbc0c", "filename": "libgfortran/generated/maxloc0_8_r8.c", "status": "modified", "additions": 63, "deletions": 14, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc0_8_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc0_8_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_8_r8.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -69,11 +69,22 @@ maxloc0_8_r8 (gfc_array_i8 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MAXLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;\n@@ -182,11 +193,40 @@ mmaxloc0_8_r8 (gfc_array_i8 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank, mask_rank;\n+\t  index_type ret_extent;\n+\t  int n;\n+\t  index_type array_extent, mask_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MAXLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t\n+\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n+\t  if (rank != mask_rank)\n+\t    runtime_error (\"rank of MASK argument in MAXLOC intrnisic\"\n+\t                   \"should be %d, is %d\", rank, mask_rank);\n+\n+\t  for (n=0; n<rank; n++)\n+\t    {\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n@@ -312,11 +352,20 @@ smaxloc0_8_r8 (gfc_array_i8 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;"}, {"sha": "477eb704a868bd5dabddbfc23d2918254e87f572", "filename": "libgfortran/generated/maxloc1_16_i1.c", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc1_16_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc1_16_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_i1.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -116,7 +116,25 @@ maxloc1_16_i1 (gfc_array_i16 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MAXLOC intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -293,7 +311,35 @@ mmaxloc1_16_i1 (gfc_array_i16 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in MAXLOC intrinsic\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+          for (n=0; n<= rank; n++)\n+            {\n+              index_type mask_extent, array_extent;\n+\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -406,13 +452,21 @@ smaxloc1_16_i1 (gfc_array_i16 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n-    }\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n \n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n+    }\n     dstride = retarray->dim[0].stride;\n     dest = retarray->data;\n "}, {"sha": "e4a2c1b361b9527d6fc555d1c6f85f4d6bae2920", "filename": "libgfortran/generated/maxloc1_16_i16.c", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc1_16_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc1_16_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_i16.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -116,7 +116,25 @@ maxloc1_16_i16 (gfc_array_i16 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MAXLOC intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -293,7 +311,35 @@ mmaxloc1_16_i16 (gfc_array_i16 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in MAXLOC intrinsic\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+          for (n=0; n<= rank; n++)\n+            {\n+              index_type mask_extent, array_extent;\n+\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -406,13 +452,21 @@ smaxloc1_16_i16 (gfc_array_i16 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n-    }\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n \n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n+    }\n     dstride = retarray->dim[0].stride;\n     dest = retarray->data;\n "}, {"sha": "f5d7b587aed231552695fc37f1a37ddcd9e4b645", "filename": "libgfortran/generated/maxloc1_16_i2.c", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc1_16_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc1_16_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_i2.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -116,7 +116,25 @@ maxloc1_16_i2 (gfc_array_i16 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MAXLOC intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -293,7 +311,35 @@ mmaxloc1_16_i2 (gfc_array_i16 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in MAXLOC intrinsic\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+          for (n=0; n<= rank; n++)\n+            {\n+              index_type mask_extent, array_extent;\n+\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -406,13 +452,21 @@ smaxloc1_16_i2 (gfc_array_i16 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n-    }\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n \n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n+    }\n     dstride = retarray->dim[0].stride;\n     dest = retarray->data;\n "}, {"sha": "1fbda541ae3e294571133323224baeffa019135a", "filename": "libgfortran/generated/maxloc1_16_i4.c", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc1_16_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc1_16_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_i4.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -116,7 +116,25 @@ maxloc1_16_i4 (gfc_array_i16 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MAXLOC intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -293,7 +311,35 @@ mmaxloc1_16_i4 (gfc_array_i16 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in MAXLOC intrinsic\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+          for (n=0; n<= rank; n++)\n+            {\n+              index_type mask_extent, array_extent;\n+\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -406,13 +452,21 @@ smaxloc1_16_i4 (gfc_array_i16 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n-    }\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n \n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n+    }\n     dstride = retarray->dim[0].stride;\n     dest = retarray->data;\n "}, {"sha": "59be84cd62c010e834a2c44e18372300a613603c", "filename": "libgfortran/generated/maxloc1_16_i8.c", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc1_16_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc1_16_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_i8.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -116,7 +116,25 @@ maxloc1_16_i8 (gfc_array_i16 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MAXLOC intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -293,7 +311,35 @@ mmaxloc1_16_i8 (gfc_array_i16 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in MAXLOC intrinsic\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+          for (n=0; n<= rank; n++)\n+            {\n+              index_type mask_extent, array_extent;\n+\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -406,13 +452,21 @@ smaxloc1_16_i8 (gfc_array_i16 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n-    }\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n \n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n+    }\n     dstride = retarray->dim[0].stride;\n     dest = retarray->data;\n "}, {"sha": "3a8c8b7a376e6a6842348049261f7a598f29077c", "filename": "libgfortran/generated/maxloc1_16_r10.c", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc1_16_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc1_16_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_r10.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -116,7 +116,25 @@ maxloc1_16_r10 (gfc_array_i16 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MAXLOC intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -293,7 +311,35 @@ mmaxloc1_16_r10 (gfc_array_i16 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in MAXLOC intrinsic\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+          for (n=0; n<= rank; n++)\n+            {\n+              index_type mask_extent, array_extent;\n+\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -406,13 +452,21 @@ smaxloc1_16_r10 (gfc_array_i16 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n-    }\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n \n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n+    }\n     dstride = retarray->dim[0].stride;\n     dest = retarray->data;\n "}, {"sha": "60b97249adae3e32362a104d50f84bb06ee5e782", "filename": "libgfortran/generated/maxloc1_16_r16.c", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc1_16_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc1_16_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_r16.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -116,7 +116,25 @@ maxloc1_16_r16 (gfc_array_i16 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MAXLOC intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -293,7 +311,35 @@ mmaxloc1_16_r16 (gfc_array_i16 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in MAXLOC intrinsic\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+          for (n=0; n<= rank; n++)\n+            {\n+              index_type mask_extent, array_extent;\n+\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -406,13 +452,21 @@ smaxloc1_16_r16 (gfc_array_i16 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n-    }\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n \n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n+    }\n     dstride = retarray->dim[0].stride;\n     dest = retarray->data;\n "}, {"sha": "a36a9d1133c6e7406b9ed35a861d4bc36b847f8e", "filename": "libgfortran/generated/maxloc1_16_r4.c", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc1_16_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc1_16_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_r4.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -116,7 +116,25 @@ maxloc1_16_r4 (gfc_array_i16 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MAXLOC intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -293,7 +311,35 @@ mmaxloc1_16_r4 (gfc_array_i16 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in MAXLOC intrinsic\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+          for (n=0; n<= rank; n++)\n+            {\n+              index_type mask_extent, array_extent;\n+\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -406,13 +452,21 @@ smaxloc1_16_r4 (gfc_array_i16 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n-    }\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n \n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n+    }\n     dstride = retarray->dim[0].stride;\n     dest = retarray->data;\n "}, {"sha": "9c659c0d3a6ada8bc7db2fb04462c747838d9ba4", "filename": "libgfortran/generated/maxloc1_16_r8.c", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc1_16_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc1_16_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_r8.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -116,7 +116,25 @@ maxloc1_16_r8 (gfc_array_i16 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MAXLOC intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -293,7 +311,35 @@ mmaxloc1_16_r8 (gfc_array_i16 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in MAXLOC intrinsic\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+          for (n=0; n<= rank; n++)\n+            {\n+              index_type mask_extent, array_extent;\n+\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -406,13 +452,21 @@ smaxloc1_16_r8 (gfc_array_i16 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n-    }\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n \n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n+    }\n     dstride = retarray->dim[0].stride;\n     dest = retarray->data;\n "}, {"sha": "1d9132888cd1f56e826570a93032c1bd3977c6f7", "filename": "libgfortran/generated/maxloc1_4_i1.c", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc1_4_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc1_4_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_i1.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -116,7 +116,25 @@ maxloc1_4_i1 (gfc_array_i4 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MAXLOC intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -293,7 +311,35 @@ mmaxloc1_4_i1 (gfc_array_i4 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in MAXLOC intrinsic\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+          for (n=0; n<= rank; n++)\n+            {\n+              index_type mask_extent, array_extent;\n+\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -406,13 +452,21 @@ smaxloc1_4_i1 (gfc_array_i4 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n-    }\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n \n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n+    }\n     dstride = retarray->dim[0].stride;\n     dest = retarray->data;\n "}, {"sha": "92a08bef0bd214ba857b7860e512c522694cccb4", "filename": "libgfortran/generated/maxloc1_4_i16.c", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc1_4_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc1_4_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_i16.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -116,7 +116,25 @@ maxloc1_4_i16 (gfc_array_i4 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MAXLOC intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -293,7 +311,35 @@ mmaxloc1_4_i16 (gfc_array_i4 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in MAXLOC intrinsic\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+          for (n=0; n<= rank; n++)\n+            {\n+              index_type mask_extent, array_extent;\n+\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -406,13 +452,21 @@ smaxloc1_4_i16 (gfc_array_i4 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n-    }\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n \n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n+    }\n     dstride = retarray->dim[0].stride;\n     dest = retarray->data;\n "}, {"sha": "b03d90a9592011fa159282ceebf6b9486c9c2c9b", "filename": "libgfortran/generated/maxloc1_4_i2.c", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc1_4_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc1_4_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_i2.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -116,7 +116,25 @@ maxloc1_4_i2 (gfc_array_i4 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MAXLOC intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -293,7 +311,35 @@ mmaxloc1_4_i2 (gfc_array_i4 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in MAXLOC intrinsic\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+          for (n=0; n<= rank; n++)\n+            {\n+              index_type mask_extent, array_extent;\n+\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -406,13 +452,21 @@ smaxloc1_4_i2 (gfc_array_i4 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n-    }\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n \n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n+    }\n     dstride = retarray->dim[0].stride;\n     dest = retarray->data;\n "}, {"sha": "dc90ec29d8da128df22533d2bd07611ba2e53cc3", "filename": "libgfortran/generated/maxloc1_4_i4.c", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc1_4_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc1_4_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_i4.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -116,7 +116,25 @@ maxloc1_4_i4 (gfc_array_i4 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MAXLOC intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -293,7 +311,35 @@ mmaxloc1_4_i4 (gfc_array_i4 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in MAXLOC intrinsic\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+          for (n=0; n<= rank; n++)\n+            {\n+              index_type mask_extent, array_extent;\n+\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -406,13 +452,21 @@ smaxloc1_4_i4 (gfc_array_i4 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n-    }\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n \n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n+    }\n     dstride = retarray->dim[0].stride;\n     dest = retarray->data;\n "}, {"sha": "78da94438cd67d6376e74c3869414871dd0e2e6f", "filename": "libgfortran/generated/maxloc1_4_i8.c", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc1_4_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc1_4_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_i8.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -116,7 +116,25 @@ maxloc1_4_i8 (gfc_array_i4 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MAXLOC intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -293,7 +311,35 @@ mmaxloc1_4_i8 (gfc_array_i4 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in MAXLOC intrinsic\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+          for (n=0; n<= rank; n++)\n+            {\n+              index_type mask_extent, array_extent;\n+\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -406,13 +452,21 @@ smaxloc1_4_i8 (gfc_array_i4 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n-    }\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n \n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n+    }\n     dstride = retarray->dim[0].stride;\n     dest = retarray->data;\n "}, {"sha": "1c83f62f7289f8fe860c1efd08d67a1af2e8ebcd", "filename": "libgfortran/generated/maxloc1_4_r10.c", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc1_4_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc1_4_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_r10.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -116,7 +116,25 @@ maxloc1_4_r10 (gfc_array_i4 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MAXLOC intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -293,7 +311,35 @@ mmaxloc1_4_r10 (gfc_array_i4 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in MAXLOC intrinsic\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+          for (n=0; n<= rank; n++)\n+            {\n+              index_type mask_extent, array_extent;\n+\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -406,13 +452,21 @@ smaxloc1_4_r10 (gfc_array_i4 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n-    }\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n \n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n+    }\n     dstride = retarray->dim[0].stride;\n     dest = retarray->data;\n "}, {"sha": "a31d0ac5afaa1a06a860a6bfa1710ca268a2df13", "filename": "libgfortran/generated/maxloc1_4_r16.c", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc1_4_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc1_4_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_r16.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -116,7 +116,25 @@ maxloc1_4_r16 (gfc_array_i4 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MAXLOC intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -293,7 +311,35 @@ mmaxloc1_4_r16 (gfc_array_i4 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in MAXLOC intrinsic\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+          for (n=0; n<= rank; n++)\n+            {\n+              index_type mask_extent, array_extent;\n+\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -406,13 +452,21 @@ smaxloc1_4_r16 (gfc_array_i4 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n-    }\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n \n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n+    }\n     dstride = retarray->dim[0].stride;\n     dest = retarray->data;\n "}, {"sha": "49d9cd5463bbdccba9cb6dfdd0af059badaf1ca0", "filename": "libgfortran/generated/maxloc1_4_r4.c", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc1_4_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc1_4_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_r4.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -116,7 +116,25 @@ maxloc1_4_r4 (gfc_array_i4 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MAXLOC intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -293,7 +311,35 @@ mmaxloc1_4_r4 (gfc_array_i4 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in MAXLOC intrinsic\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+          for (n=0; n<= rank; n++)\n+            {\n+              index_type mask_extent, array_extent;\n+\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -406,13 +452,21 @@ smaxloc1_4_r4 (gfc_array_i4 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n-    }\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n \n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n+    }\n     dstride = retarray->dim[0].stride;\n     dest = retarray->data;\n "}, {"sha": "822680a494112647dbb748122d3deaa0450daf7b", "filename": "libgfortran/generated/maxloc1_4_r8.c", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc1_4_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc1_4_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_r8.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -116,7 +116,25 @@ maxloc1_4_r8 (gfc_array_i4 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MAXLOC intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -293,7 +311,35 @@ mmaxloc1_4_r8 (gfc_array_i4 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in MAXLOC intrinsic\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+          for (n=0; n<= rank; n++)\n+            {\n+              index_type mask_extent, array_extent;\n+\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -406,13 +452,21 @@ smaxloc1_4_r8 (gfc_array_i4 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n-    }\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n \n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n+    }\n     dstride = retarray->dim[0].stride;\n     dest = retarray->data;\n "}, {"sha": "5c607532dbc147d6b9fc513b1e934a8a7d751ec1", "filename": "libgfortran/generated/maxloc1_8_i1.c", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc1_8_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc1_8_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_i1.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -116,7 +116,25 @@ maxloc1_8_i1 (gfc_array_i8 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MAXLOC intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -293,7 +311,35 @@ mmaxloc1_8_i1 (gfc_array_i8 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in MAXLOC intrinsic\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+          for (n=0; n<= rank; n++)\n+            {\n+              index_type mask_extent, array_extent;\n+\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -406,13 +452,21 @@ smaxloc1_8_i1 (gfc_array_i8 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n-    }\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n \n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n+    }\n     dstride = retarray->dim[0].stride;\n     dest = retarray->data;\n "}, {"sha": "feefc084883e47547788420bf869d0b77f0b4174", "filename": "libgfortran/generated/maxloc1_8_i16.c", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc1_8_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc1_8_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_i16.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -116,7 +116,25 @@ maxloc1_8_i16 (gfc_array_i8 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MAXLOC intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -293,7 +311,35 @@ mmaxloc1_8_i16 (gfc_array_i8 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in MAXLOC intrinsic\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+          for (n=0; n<= rank; n++)\n+            {\n+              index_type mask_extent, array_extent;\n+\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -406,13 +452,21 @@ smaxloc1_8_i16 (gfc_array_i8 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n-    }\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n \n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n+    }\n     dstride = retarray->dim[0].stride;\n     dest = retarray->data;\n "}, {"sha": "8e4868d73080a3cb6bde5705e04c1d3b47ca2904", "filename": "libgfortran/generated/maxloc1_8_i2.c", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc1_8_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc1_8_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_i2.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -116,7 +116,25 @@ maxloc1_8_i2 (gfc_array_i8 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MAXLOC intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -293,7 +311,35 @@ mmaxloc1_8_i2 (gfc_array_i8 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in MAXLOC intrinsic\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+          for (n=0; n<= rank; n++)\n+            {\n+              index_type mask_extent, array_extent;\n+\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -406,13 +452,21 @@ smaxloc1_8_i2 (gfc_array_i8 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n-    }\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n \n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n+    }\n     dstride = retarray->dim[0].stride;\n     dest = retarray->data;\n "}, {"sha": "cb9d14d8d1d7f0cd4bb01780ba2ece54148c373c", "filename": "libgfortran/generated/maxloc1_8_i4.c", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc1_8_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc1_8_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_i4.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -116,7 +116,25 @@ maxloc1_8_i4 (gfc_array_i8 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MAXLOC intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -293,7 +311,35 @@ mmaxloc1_8_i4 (gfc_array_i8 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in MAXLOC intrinsic\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+          for (n=0; n<= rank; n++)\n+            {\n+              index_type mask_extent, array_extent;\n+\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -406,13 +452,21 @@ smaxloc1_8_i4 (gfc_array_i8 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n-    }\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n \n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n+    }\n     dstride = retarray->dim[0].stride;\n     dest = retarray->data;\n "}, {"sha": "8b8f2a969145272297878095a7727aa768267f68", "filename": "libgfortran/generated/maxloc1_8_i8.c", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc1_8_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc1_8_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_i8.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -116,7 +116,25 @@ maxloc1_8_i8 (gfc_array_i8 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MAXLOC intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -293,7 +311,35 @@ mmaxloc1_8_i8 (gfc_array_i8 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in MAXLOC intrinsic\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+          for (n=0; n<= rank; n++)\n+            {\n+              index_type mask_extent, array_extent;\n+\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -406,13 +452,21 @@ smaxloc1_8_i8 (gfc_array_i8 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n-    }\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n \n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n+    }\n     dstride = retarray->dim[0].stride;\n     dest = retarray->data;\n "}, {"sha": "6aa6ec1941c4db40a51f18427a93e17a5bddc08d", "filename": "libgfortran/generated/maxloc1_8_r10.c", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc1_8_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc1_8_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_r10.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -116,7 +116,25 @@ maxloc1_8_r10 (gfc_array_i8 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MAXLOC intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -293,7 +311,35 @@ mmaxloc1_8_r10 (gfc_array_i8 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in MAXLOC intrinsic\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+          for (n=0; n<= rank; n++)\n+            {\n+              index_type mask_extent, array_extent;\n+\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -406,13 +452,21 @@ smaxloc1_8_r10 (gfc_array_i8 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n-    }\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n \n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n+    }\n     dstride = retarray->dim[0].stride;\n     dest = retarray->data;\n "}, {"sha": "59db207cfc00bc677e39d7c6e99b9e8572110ccd", "filename": "libgfortran/generated/maxloc1_8_r16.c", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc1_8_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc1_8_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_r16.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -116,7 +116,25 @@ maxloc1_8_r16 (gfc_array_i8 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MAXLOC intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -293,7 +311,35 @@ mmaxloc1_8_r16 (gfc_array_i8 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in MAXLOC intrinsic\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+          for (n=0; n<= rank; n++)\n+            {\n+              index_type mask_extent, array_extent;\n+\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -406,13 +452,21 @@ smaxloc1_8_r16 (gfc_array_i8 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n-    }\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n \n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n+    }\n     dstride = retarray->dim[0].stride;\n     dest = retarray->data;\n "}, {"sha": "3640a5dea9633ed8ba891e853aea45a771151d09", "filename": "libgfortran/generated/maxloc1_8_r4.c", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc1_8_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc1_8_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_r4.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -116,7 +116,25 @@ maxloc1_8_r4 (gfc_array_i8 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MAXLOC intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -293,7 +311,35 @@ mmaxloc1_8_r4 (gfc_array_i8 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in MAXLOC intrinsic\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+          for (n=0; n<= rank; n++)\n+            {\n+              index_type mask_extent, array_extent;\n+\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -406,13 +452,21 @@ smaxloc1_8_r4 (gfc_array_i8 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n-    }\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n \n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n+    }\n     dstride = retarray->dim[0].stride;\n     dest = retarray->data;\n "}, {"sha": "93c7c78aec743759e7ac74acf5b0e9d8508c5a55", "filename": "libgfortran/generated/maxloc1_8_r8.c", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc1_8_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxloc1_8_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_r8.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -116,7 +116,25 @@ maxloc1_8_r8 (gfc_array_i8 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MAXLOC intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -293,7 +311,35 @@ mmaxloc1_8_r8 (gfc_array_i8 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in MAXLOC intrinsic\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+          for (n=0; n<= rank; n++)\n+            {\n+              index_type mask_extent, array_extent;\n+\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -406,13 +452,21 @@ smaxloc1_8_r8 (gfc_array_i8 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n-    }\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n \n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n+    }\n     dstride = retarray->dim[0].stride;\n     dest = retarray->data;\n "}, {"sha": "5158e2a60cc54e1d0b575f6fc1ef3d796d12dfca", "filename": "libgfortran/generated/maxval_i1.c", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxval_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxval_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_i1.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -115,7 +115,25 @@ maxval_i1 (gfc_array_i1 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MAXVAL intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXVAL intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -287,7 +305,35 @@ mmaxval_i1 (gfc_array_i1 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in MAXVAL intrinsic\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXVAL intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+          for (n=0; n<= rank; n++)\n+            {\n+              index_type mask_extent, array_extent;\n+\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MAXVAL intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -395,13 +441,21 @@ smaxval_i1 (gfc_array_i1 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n-    }\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXVAL intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n \n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n+    }\n     dstride = retarray->dim[0].stride;\n     dest = retarray->data;\n "}, {"sha": "a10c8fa57c9e2270df451e2b5dd8c18abdb3701e", "filename": "libgfortran/generated/maxval_i16.c", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxval_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxval_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_i16.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -115,7 +115,25 @@ maxval_i16 (gfc_array_i16 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MAXVAL intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXVAL intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -287,7 +305,35 @@ mmaxval_i16 (gfc_array_i16 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in MAXVAL intrinsic\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXVAL intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+          for (n=0; n<= rank; n++)\n+            {\n+              index_type mask_extent, array_extent;\n+\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MAXVAL intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -395,13 +441,21 @@ smaxval_i16 (gfc_array_i16 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n-    }\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXVAL intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n \n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n+    }\n     dstride = retarray->dim[0].stride;\n     dest = retarray->data;\n "}, {"sha": "3819e0e01017a5c78ee1e4af085b0cf34deab3c1", "filename": "libgfortran/generated/maxval_i2.c", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxval_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxval_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_i2.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -115,7 +115,25 @@ maxval_i2 (gfc_array_i2 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MAXVAL intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXVAL intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -287,7 +305,35 @@ mmaxval_i2 (gfc_array_i2 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in MAXVAL intrinsic\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXVAL intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+          for (n=0; n<= rank; n++)\n+            {\n+              index_type mask_extent, array_extent;\n+\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MAXVAL intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -395,13 +441,21 @@ smaxval_i2 (gfc_array_i2 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n-    }\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXVAL intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n \n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n+    }\n     dstride = retarray->dim[0].stride;\n     dest = retarray->data;\n "}, {"sha": "1076336a02fb221c9a45fb1422934c0c03c46c9b", "filename": "libgfortran/generated/maxval_i4.c", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxval_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxval_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_i4.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -115,7 +115,25 @@ maxval_i4 (gfc_array_i4 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MAXVAL intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXVAL intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -287,7 +305,35 @@ mmaxval_i4 (gfc_array_i4 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in MAXVAL intrinsic\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXVAL intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+          for (n=0; n<= rank; n++)\n+            {\n+              index_type mask_extent, array_extent;\n+\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MAXVAL intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -395,13 +441,21 @@ smaxval_i4 (gfc_array_i4 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n-    }\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXVAL intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n \n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n+    }\n     dstride = retarray->dim[0].stride;\n     dest = retarray->data;\n "}, {"sha": "f527983097c576e1fbcaa2325dd736b8cf1aef35", "filename": "libgfortran/generated/maxval_i8.c", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxval_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxval_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_i8.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -115,7 +115,25 @@ maxval_i8 (gfc_array_i8 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MAXVAL intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXVAL intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -287,7 +305,35 @@ mmaxval_i8 (gfc_array_i8 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in MAXVAL intrinsic\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXVAL intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+          for (n=0; n<= rank; n++)\n+            {\n+              index_type mask_extent, array_extent;\n+\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MAXVAL intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -395,13 +441,21 @@ smaxval_i8 (gfc_array_i8 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n-    }\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXVAL intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n \n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n+    }\n     dstride = retarray->dim[0].stride;\n     dest = retarray->data;\n "}, {"sha": "fd775c0e4d5a66f796e64eab79ca94a732f887c8", "filename": "libgfortran/generated/maxval_r10.c", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxval_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxval_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_r10.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -115,7 +115,25 @@ maxval_r10 (gfc_array_r10 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MAXVAL intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXVAL intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -287,7 +305,35 @@ mmaxval_r10 (gfc_array_r10 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in MAXVAL intrinsic\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXVAL intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+          for (n=0; n<= rank; n++)\n+            {\n+              index_type mask_extent, array_extent;\n+\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MAXVAL intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -395,13 +441,21 @@ smaxval_r10 (gfc_array_r10 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n-    }\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXVAL intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n \n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n+    }\n     dstride = retarray->dim[0].stride;\n     dest = retarray->data;\n "}, {"sha": "671ce1499f93c86fb8253231758eb1f7696c134e", "filename": "libgfortran/generated/maxval_r16.c", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxval_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxval_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_r16.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -115,7 +115,25 @@ maxval_r16 (gfc_array_r16 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MAXVAL intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXVAL intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -287,7 +305,35 @@ mmaxval_r16 (gfc_array_r16 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in MAXVAL intrinsic\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXVAL intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+          for (n=0; n<= rank; n++)\n+            {\n+              index_type mask_extent, array_extent;\n+\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MAXVAL intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -395,13 +441,21 @@ smaxval_r16 (gfc_array_r16 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n-    }\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXVAL intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n \n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n+    }\n     dstride = retarray->dim[0].stride;\n     dest = retarray->data;\n "}, {"sha": "674142274e923edb3ab589a725691d92d992a36f", "filename": "libgfortran/generated/maxval_r4.c", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxval_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxval_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_r4.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -115,7 +115,25 @@ maxval_r4 (gfc_array_r4 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MAXVAL intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXVAL intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -287,7 +305,35 @@ mmaxval_r4 (gfc_array_r4 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in MAXVAL intrinsic\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXVAL intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+          for (n=0; n<= rank; n++)\n+            {\n+              index_type mask_extent, array_extent;\n+\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MAXVAL intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -395,13 +441,21 @@ smaxval_r4 (gfc_array_r4 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n-    }\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXVAL intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n \n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n+    }\n     dstride = retarray->dim[0].stride;\n     dest = retarray->data;\n "}, {"sha": "136ef20794c08899621fffe74d857e56b0e0b6f4", "filename": "libgfortran/generated/maxval_r8.c", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxval_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fmaxval_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_r8.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -115,7 +115,25 @@ maxval_r8 (gfc_array_r8 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MAXVAL intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXVAL intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -287,7 +305,35 @@ mmaxval_r8 (gfc_array_r8 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in MAXVAL intrinsic\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXVAL intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+          for (n=0; n<= rank; n++)\n+            {\n+              index_type mask_extent, array_extent;\n+\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MAXVAL intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -395,13 +441,21 @@ smaxval_r8 (gfc_array_r8 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n-    }\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MAXVAL intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n \n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n+    }\n     dstride = retarray->dim[0].stride;\n     dest = retarray->data;\n "}, {"sha": "9529997a37473010c84784b3b3b8531bc74feaea", "filename": "libgfortran/generated/minloc0_16_i1.c", "status": "modified", "additions": 63, "deletions": 14, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc0_16_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc0_16_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_16_i1.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -69,11 +69,22 @@ minloc0_16_i1 (gfc_array_i16 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MINLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;\n@@ -182,11 +193,40 @@ mminloc0_16_i1 (gfc_array_i16 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank, mask_rank;\n+\t  index_type ret_extent;\n+\t  int n;\n+\t  index_type array_extent, mask_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MINLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t\n+\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n+\t  if (rank != mask_rank)\n+\t    runtime_error (\"rank of MASK argument in MINLOC intrnisic\"\n+\t                   \"should be %d, is %d\", rank, mask_rank);\n+\n+\t  for (n=0; n<rank; n++)\n+\t    {\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n@@ -312,11 +352,20 @@ sminloc0_16_i1 (gfc_array_i16 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;"}, {"sha": "667bfd8a3491b994b64e7daca589bbce924eba7a", "filename": "libgfortran/generated/minloc0_16_i16.c", "status": "modified", "additions": 63, "deletions": 14, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc0_16_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc0_16_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_16_i16.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -69,11 +69,22 @@ minloc0_16_i16 (gfc_array_i16 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MINLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;\n@@ -182,11 +193,40 @@ mminloc0_16_i16 (gfc_array_i16 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank, mask_rank;\n+\t  index_type ret_extent;\n+\t  int n;\n+\t  index_type array_extent, mask_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MINLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t\n+\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n+\t  if (rank != mask_rank)\n+\t    runtime_error (\"rank of MASK argument in MINLOC intrnisic\"\n+\t                   \"should be %d, is %d\", rank, mask_rank);\n+\n+\t  for (n=0; n<rank; n++)\n+\t    {\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n@@ -312,11 +352,20 @@ sminloc0_16_i16 (gfc_array_i16 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;"}, {"sha": "a5c499410bd82b7fed771d8ee3c50eaf285f384b", "filename": "libgfortran/generated/minloc0_16_i2.c", "status": "modified", "additions": 63, "deletions": 14, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc0_16_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc0_16_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_16_i2.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -69,11 +69,22 @@ minloc0_16_i2 (gfc_array_i16 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MINLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;\n@@ -182,11 +193,40 @@ mminloc0_16_i2 (gfc_array_i16 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank, mask_rank;\n+\t  index_type ret_extent;\n+\t  int n;\n+\t  index_type array_extent, mask_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MINLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t\n+\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n+\t  if (rank != mask_rank)\n+\t    runtime_error (\"rank of MASK argument in MINLOC intrnisic\"\n+\t                   \"should be %d, is %d\", rank, mask_rank);\n+\n+\t  for (n=0; n<rank; n++)\n+\t    {\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n@@ -312,11 +352,20 @@ sminloc0_16_i2 (gfc_array_i16 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;"}, {"sha": "7c9292cddb36e94cef9d1e928dc5243a1ed3e470", "filename": "libgfortran/generated/minloc0_16_i4.c", "status": "modified", "additions": 63, "deletions": 14, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc0_16_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc0_16_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_16_i4.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -69,11 +69,22 @@ minloc0_16_i4 (gfc_array_i16 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MINLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;\n@@ -182,11 +193,40 @@ mminloc0_16_i4 (gfc_array_i16 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank, mask_rank;\n+\t  index_type ret_extent;\n+\t  int n;\n+\t  index_type array_extent, mask_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MINLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t\n+\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n+\t  if (rank != mask_rank)\n+\t    runtime_error (\"rank of MASK argument in MINLOC intrnisic\"\n+\t                   \"should be %d, is %d\", rank, mask_rank);\n+\n+\t  for (n=0; n<rank; n++)\n+\t    {\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n@@ -312,11 +352,20 @@ sminloc0_16_i4 (gfc_array_i16 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;"}, {"sha": "022e49c970786d4552b19a63bfec4b3c75d5cbf3", "filename": "libgfortran/generated/minloc0_16_i8.c", "status": "modified", "additions": 63, "deletions": 14, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc0_16_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc0_16_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_16_i8.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -69,11 +69,22 @@ minloc0_16_i8 (gfc_array_i16 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MINLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;\n@@ -182,11 +193,40 @@ mminloc0_16_i8 (gfc_array_i16 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank, mask_rank;\n+\t  index_type ret_extent;\n+\t  int n;\n+\t  index_type array_extent, mask_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MINLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t\n+\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n+\t  if (rank != mask_rank)\n+\t    runtime_error (\"rank of MASK argument in MINLOC intrnisic\"\n+\t                   \"should be %d, is %d\", rank, mask_rank);\n+\n+\t  for (n=0; n<rank; n++)\n+\t    {\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n@@ -312,11 +352,20 @@ sminloc0_16_i8 (gfc_array_i16 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;"}, {"sha": "a99c5307afcb46ab975b7ad2d471f51324f9660f", "filename": "libgfortran/generated/minloc0_16_r10.c", "status": "modified", "additions": 63, "deletions": 14, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc0_16_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc0_16_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_16_r10.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -69,11 +69,22 @@ minloc0_16_r10 (gfc_array_i16 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MINLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;\n@@ -182,11 +193,40 @@ mminloc0_16_r10 (gfc_array_i16 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank, mask_rank;\n+\t  index_type ret_extent;\n+\t  int n;\n+\t  index_type array_extent, mask_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MINLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t\n+\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n+\t  if (rank != mask_rank)\n+\t    runtime_error (\"rank of MASK argument in MINLOC intrnisic\"\n+\t                   \"should be %d, is %d\", rank, mask_rank);\n+\n+\t  for (n=0; n<rank; n++)\n+\t    {\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n@@ -312,11 +352,20 @@ sminloc0_16_r10 (gfc_array_i16 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;"}, {"sha": "2b2dcaacb23997ad3f8cda79eb9c18149ae5d00a", "filename": "libgfortran/generated/minloc0_16_r16.c", "status": "modified", "additions": 63, "deletions": 14, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc0_16_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc0_16_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_16_r16.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -69,11 +69,22 @@ minloc0_16_r16 (gfc_array_i16 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MINLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;\n@@ -182,11 +193,40 @@ mminloc0_16_r16 (gfc_array_i16 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank, mask_rank;\n+\t  index_type ret_extent;\n+\t  int n;\n+\t  index_type array_extent, mask_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MINLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t\n+\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n+\t  if (rank != mask_rank)\n+\t    runtime_error (\"rank of MASK argument in MINLOC intrnisic\"\n+\t                   \"should be %d, is %d\", rank, mask_rank);\n+\n+\t  for (n=0; n<rank; n++)\n+\t    {\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n@@ -312,11 +352,20 @@ sminloc0_16_r16 (gfc_array_i16 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;"}, {"sha": "f265ae4756121b4ba2b37b442d01cc2272e73387", "filename": "libgfortran/generated/minloc0_16_r4.c", "status": "modified", "additions": 63, "deletions": 14, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc0_16_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc0_16_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_16_r4.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -69,11 +69,22 @@ minloc0_16_r4 (gfc_array_i16 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MINLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;\n@@ -182,11 +193,40 @@ mminloc0_16_r4 (gfc_array_i16 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank, mask_rank;\n+\t  index_type ret_extent;\n+\t  int n;\n+\t  index_type array_extent, mask_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MINLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t\n+\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n+\t  if (rank != mask_rank)\n+\t    runtime_error (\"rank of MASK argument in MINLOC intrnisic\"\n+\t                   \"should be %d, is %d\", rank, mask_rank);\n+\n+\t  for (n=0; n<rank; n++)\n+\t    {\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n@@ -312,11 +352,20 @@ sminloc0_16_r4 (gfc_array_i16 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;"}, {"sha": "59429f22ee92cf2997da24a555c646a04650fbf7", "filename": "libgfortran/generated/minloc0_16_r8.c", "status": "modified", "additions": 63, "deletions": 14, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc0_16_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc0_16_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_16_r8.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -69,11 +69,22 @@ minloc0_16_r8 (gfc_array_i16 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MINLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;\n@@ -182,11 +193,40 @@ mminloc0_16_r8 (gfc_array_i16 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank, mask_rank;\n+\t  index_type ret_extent;\n+\t  int n;\n+\t  index_type array_extent, mask_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MINLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t\n+\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n+\t  if (rank != mask_rank)\n+\t    runtime_error (\"rank of MASK argument in MINLOC intrnisic\"\n+\t                   \"should be %d, is %d\", rank, mask_rank);\n+\n+\t  for (n=0; n<rank; n++)\n+\t    {\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n@@ -312,11 +352,20 @@ sminloc0_16_r8 (gfc_array_i16 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;"}, {"sha": "24463ead318dade37aace4eb638ac930e4e7c918", "filename": "libgfortran/generated/minloc0_4_i1.c", "status": "modified", "additions": 63, "deletions": 14, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc0_4_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc0_4_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_4_i1.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -69,11 +69,22 @@ minloc0_4_i1 (gfc_array_i4 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MINLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;\n@@ -182,11 +193,40 @@ mminloc0_4_i1 (gfc_array_i4 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank, mask_rank;\n+\t  index_type ret_extent;\n+\t  int n;\n+\t  index_type array_extent, mask_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MINLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t\n+\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n+\t  if (rank != mask_rank)\n+\t    runtime_error (\"rank of MASK argument in MINLOC intrnisic\"\n+\t                   \"should be %d, is %d\", rank, mask_rank);\n+\n+\t  for (n=0; n<rank; n++)\n+\t    {\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n@@ -312,11 +352,20 @@ sminloc0_4_i1 (gfc_array_i4 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;"}, {"sha": "ddcbc60eab96887ba97cf30052efc78023f13e37", "filename": "libgfortran/generated/minloc0_4_i16.c", "status": "modified", "additions": 63, "deletions": 14, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc0_4_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc0_4_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_4_i16.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -69,11 +69,22 @@ minloc0_4_i16 (gfc_array_i4 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MINLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;\n@@ -182,11 +193,40 @@ mminloc0_4_i16 (gfc_array_i4 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank, mask_rank;\n+\t  index_type ret_extent;\n+\t  int n;\n+\t  index_type array_extent, mask_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MINLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t\n+\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n+\t  if (rank != mask_rank)\n+\t    runtime_error (\"rank of MASK argument in MINLOC intrnisic\"\n+\t                   \"should be %d, is %d\", rank, mask_rank);\n+\n+\t  for (n=0; n<rank; n++)\n+\t    {\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n@@ -312,11 +352,20 @@ sminloc0_4_i16 (gfc_array_i4 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;"}, {"sha": "60b2c3fcb5799cfee68329511a6841b316eecefc", "filename": "libgfortran/generated/minloc0_4_i2.c", "status": "modified", "additions": 63, "deletions": 14, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc0_4_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc0_4_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_4_i2.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -69,11 +69,22 @@ minloc0_4_i2 (gfc_array_i4 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MINLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;\n@@ -182,11 +193,40 @@ mminloc0_4_i2 (gfc_array_i4 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank, mask_rank;\n+\t  index_type ret_extent;\n+\t  int n;\n+\t  index_type array_extent, mask_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MINLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t\n+\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n+\t  if (rank != mask_rank)\n+\t    runtime_error (\"rank of MASK argument in MINLOC intrnisic\"\n+\t                   \"should be %d, is %d\", rank, mask_rank);\n+\n+\t  for (n=0; n<rank; n++)\n+\t    {\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n@@ -312,11 +352,20 @@ sminloc0_4_i2 (gfc_array_i4 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;"}, {"sha": "6431f38ba5916ad4d0d7169d8599a8bbd2849872", "filename": "libgfortran/generated/minloc0_4_i4.c", "status": "modified", "additions": 63, "deletions": 14, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc0_4_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc0_4_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_4_i4.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -69,11 +69,22 @@ minloc0_4_i4 (gfc_array_i4 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MINLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;\n@@ -182,11 +193,40 @@ mminloc0_4_i4 (gfc_array_i4 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank, mask_rank;\n+\t  index_type ret_extent;\n+\t  int n;\n+\t  index_type array_extent, mask_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MINLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t\n+\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n+\t  if (rank != mask_rank)\n+\t    runtime_error (\"rank of MASK argument in MINLOC intrnisic\"\n+\t                   \"should be %d, is %d\", rank, mask_rank);\n+\n+\t  for (n=0; n<rank; n++)\n+\t    {\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n@@ -312,11 +352,20 @@ sminloc0_4_i4 (gfc_array_i4 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;"}, {"sha": "6ffeac577fc68d5f18c570bf927c6c297c43ccec", "filename": "libgfortran/generated/minloc0_4_i8.c", "status": "modified", "additions": 63, "deletions": 14, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc0_4_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc0_4_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_4_i8.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -69,11 +69,22 @@ minloc0_4_i8 (gfc_array_i4 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MINLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;\n@@ -182,11 +193,40 @@ mminloc0_4_i8 (gfc_array_i4 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank, mask_rank;\n+\t  index_type ret_extent;\n+\t  int n;\n+\t  index_type array_extent, mask_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MINLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t\n+\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n+\t  if (rank != mask_rank)\n+\t    runtime_error (\"rank of MASK argument in MINLOC intrnisic\"\n+\t                   \"should be %d, is %d\", rank, mask_rank);\n+\n+\t  for (n=0; n<rank; n++)\n+\t    {\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n@@ -312,11 +352,20 @@ sminloc0_4_i8 (gfc_array_i4 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;"}, {"sha": "e4f10024c50ed1656127db5a9d02cc455e3c6de6", "filename": "libgfortran/generated/minloc0_4_r10.c", "status": "modified", "additions": 63, "deletions": 14, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc0_4_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc0_4_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_4_r10.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -69,11 +69,22 @@ minloc0_4_r10 (gfc_array_i4 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MINLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;\n@@ -182,11 +193,40 @@ mminloc0_4_r10 (gfc_array_i4 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank, mask_rank;\n+\t  index_type ret_extent;\n+\t  int n;\n+\t  index_type array_extent, mask_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MINLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t\n+\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n+\t  if (rank != mask_rank)\n+\t    runtime_error (\"rank of MASK argument in MINLOC intrnisic\"\n+\t                   \"should be %d, is %d\", rank, mask_rank);\n+\n+\t  for (n=0; n<rank; n++)\n+\t    {\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n@@ -312,11 +352,20 @@ sminloc0_4_r10 (gfc_array_i4 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;"}, {"sha": "0f9fb9804679af61242dfd164fa847266c030e63", "filename": "libgfortran/generated/minloc0_4_r16.c", "status": "modified", "additions": 63, "deletions": 14, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc0_4_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc0_4_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_4_r16.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -69,11 +69,22 @@ minloc0_4_r16 (gfc_array_i4 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MINLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;\n@@ -182,11 +193,40 @@ mminloc0_4_r16 (gfc_array_i4 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank, mask_rank;\n+\t  index_type ret_extent;\n+\t  int n;\n+\t  index_type array_extent, mask_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MINLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t\n+\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n+\t  if (rank != mask_rank)\n+\t    runtime_error (\"rank of MASK argument in MINLOC intrnisic\"\n+\t                   \"should be %d, is %d\", rank, mask_rank);\n+\n+\t  for (n=0; n<rank; n++)\n+\t    {\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n@@ -312,11 +352,20 @@ sminloc0_4_r16 (gfc_array_i4 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;"}, {"sha": "14c63b35e133297b45e7acc9568ff386adf4a232", "filename": "libgfortran/generated/minloc0_4_r4.c", "status": "modified", "additions": 63, "deletions": 14, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc0_4_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc0_4_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_4_r4.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -69,11 +69,22 @@ minloc0_4_r4 (gfc_array_i4 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MINLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;\n@@ -182,11 +193,40 @@ mminloc0_4_r4 (gfc_array_i4 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank, mask_rank;\n+\t  index_type ret_extent;\n+\t  int n;\n+\t  index_type array_extent, mask_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MINLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t\n+\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n+\t  if (rank != mask_rank)\n+\t    runtime_error (\"rank of MASK argument in MINLOC intrnisic\"\n+\t                   \"should be %d, is %d\", rank, mask_rank);\n+\n+\t  for (n=0; n<rank; n++)\n+\t    {\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n@@ -312,11 +352,20 @@ sminloc0_4_r4 (gfc_array_i4 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;"}, {"sha": "168d0ad26211a721bb39d426cde9ea4a52b43a6b", "filename": "libgfortran/generated/minloc0_4_r8.c", "status": "modified", "additions": 63, "deletions": 14, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc0_4_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc0_4_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_4_r8.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -69,11 +69,22 @@ minloc0_4_r8 (gfc_array_i4 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MINLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;\n@@ -182,11 +193,40 @@ mminloc0_4_r8 (gfc_array_i4 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank, mask_rank;\n+\t  index_type ret_extent;\n+\t  int n;\n+\t  index_type array_extent, mask_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MINLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t\n+\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n+\t  if (rank != mask_rank)\n+\t    runtime_error (\"rank of MASK argument in MINLOC intrnisic\"\n+\t                   \"should be %d, is %d\", rank, mask_rank);\n+\n+\t  for (n=0; n<rank; n++)\n+\t    {\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n@@ -312,11 +352,20 @@ sminloc0_4_r8 (gfc_array_i4 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;"}, {"sha": "6dcafbae05de187159bc7b3aa290aab86dfefe5b", "filename": "libgfortran/generated/minloc0_8_i1.c", "status": "modified", "additions": 63, "deletions": 14, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc0_8_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc0_8_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_8_i1.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -69,11 +69,22 @@ minloc0_8_i1 (gfc_array_i8 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MINLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;\n@@ -182,11 +193,40 @@ mminloc0_8_i1 (gfc_array_i8 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank, mask_rank;\n+\t  index_type ret_extent;\n+\t  int n;\n+\t  index_type array_extent, mask_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MINLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t\n+\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n+\t  if (rank != mask_rank)\n+\t    runtime_error (\"rank of MASK argument in MINLOC intrnisic\"\n+\t                   \"should be %d, is %d\", rank, mask_rank);\n+\n+\t  for (n=0; n<rank; n++)\n+\t    {\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n@@ -312,11 +352,20 @@ sminloc0_8_i1 (gfc_array_i8 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;"}, {"sha": "f2afae1e643f968915ef080a1a6cf46ba552f90e", "filename": "libgfortran/generated/minloc0_8_i16.c", "status": "modified", "additions": 63, "deletions": 14, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc0_8_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc0_8_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_8_i16.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -69,11 +69,22 @@ minloc0_8_i16 (gfc_array_i8 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MINLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;\n@@ -182,11 +193,40 @@ mminloc0_8_i16 (gfc_array_i8 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank, mask_rank;\n+\t  index_type ret_extent;\n+\t  int n;\n+\t  index_type array_extent, mask_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MINLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t\n+\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n+\t  if (rank != mask_rank)\n+\t    runtime_error (\"rank of MASK argument in MINLOC intrnisic\"\n+\t                   \"should be %d, is %d\", rank, mask_rank);\n+\n+\t  for (n=0; n<rank; n++)\n+\t    {\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n@@ -312,11 +352,20 @@ sminloc0_8_i16 (gfc_array_i8 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;"}, {"sha": "d0dd13744276de4ef46fc7ce5192b784bf7b80dc", "filename": "libgfortran/generated/minloc0_8_i2.c", "status": "modified", "additions": 63, "deletions": 14, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc0_8_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc0_8_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_8_i2.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -69,11 +69,22 @@ minloc0_8_i2 (gfc_array_i8 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MINLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;\n@@ -182,11 +193,40 @@ mminloc0_8_i2 (gfc_array_i8 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank, mask_rank;\n+\t  index_type ret_extent;\n+\t  int n;\n+\t  index_type array_extent, mask_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MINLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t\n+\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n+\t  if (rank != mask_rank)\n+\t    runtime_error (\"rank of MASK argument in MINLOC intrnisic\"\n+\t                   \"should be %d, is %d\", rank, mask_rank);\n+\n+\t  for (n=0; n<rank; n++)\n+\t    {\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n@@ -312,11 +352,20 @@ sminloc0_8_i2 (gfc_array_i8 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;"}, {"sha": "a4c921acfe3f84217e09b71c9ce142ef28a884bb", "filename": "libgfortran/generated/minloc0_8_i4.c", "status": "modified", "additions": 63, "deletions": 14, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc0_8_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc0_8_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_8_i4.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -69,11 +69,22 @@ minloc0_8_i4 (gfc_array_i8 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MINLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;\n@@ -182,11 +193,40 @@ mminloc0_8_i4 (gfc_array_i8 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank, mask_rank;\n+\t  index_type ret_extent;\n+\t  int n;\n+\t  index_type array_extent, mask_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MINLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t\n+\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n+\t  if (rank != mask_rank)\n+\t    runtime_error (\"rank of MASK argument in MINLOC intrnisic\"\n+\t                   \"should be %d, is %d\", rank, mask_rank);\n+\n+\t  for (n=0; n<rank; n++)\n+\t    {\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n@@ -312,11 +352,20 @@ sminloc0_8_i4 (gfc_array_i8 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;"}, {"sha": "26aa9476cf44b7a52355474471722d846e4848e2", "filename": "libgfortran/generated/minloc0_8_i8.c", "status": "modified", "additions": 63, "deletions": 14, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc0_8_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc0_8_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_8_i8.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -69,11 +69,22 @@ minloc0_8_i8 (gfc_array_i8 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MINLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;\n@@ -182,11 +193,40 @@ mminloc0_8_i8 (gfc_array_i8 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank, mask_rank;\n+\t  index_type ret_extent;\n+\t  int n;\n+\t  index_type array_extent, mask_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MINLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t\n+\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n+\t  if (rank != mask_rank)\n+\t    runtime_error (\"rank of MASK argument in MINLOC intrnisic\"\n+\t                   \"should be %d, is %d\", rank, mask_rank);\n+\n+\t  for (n=0; n<rank; n++)\n+\t    {\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n@@ -312,11 +352,20 @@ sminloc0_8_i8 (gfc_array_i8 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;"}, {"sha": "b1705ebc5fd8a11a3a849104b16f855edd2dd0c3", "filename": "libgfortran/generated/minloc0_8_r10.c", "status": "modified", "additions": 63, "deletions": 14, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc0_8_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc0_8_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_8_r10.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -69,11 +69,22 @@ minloc0_8_r10 (gfc_array_i8 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MINLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;\n@@ -182,11 +193,40 @@ mminloc0_8_r10 (gfc_array_i8 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank, mask_rank;\n+\t  index_type ret_extent;\n+\t  int n;\n+\t  index_type array_extent, mask_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MINLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t\n+\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n+\t  if (rank != mask_rank)\n+\t    runtime_error (\"rank of MASK argument in MINLOC intrnisic\"\n+\t                   \"should be %d, is %d\", rank, mask_rank);\n+\n+\t  for (n=0; n<rank; n++)\n+\t    {\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n@@ -312,11 +352,20 @@ sminloc0_8_r10 (gfc_array_i8 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;"}, {"sha": "84b95baa6a597d2122cf925391a8acd5bca098e4", "filename": "libgfortran/generated/minloc0_8_r16.c", "status": "modified", "additions": 63, "deletions": 14, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc0_8_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc0_8_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_8_r16.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -69,11 +69,22 @@ minloc0_8_r16 (gfc_array_i8 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MINLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;\n@@ -182,11 +193,40 @@ mminloc0_8_r16 (gfc_array_i8 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank, mask_rank;\n+\t  index_type ret_extent;\n+\t  int n;\n+\t  index_type array_extent, mask_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MINLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t\n+\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n+\t  if (rank != mask_rank)\n+\t    runtime_error (\"rank of MASK argument in MINLOC intrnisic\"\n+\t                   \"should be %d, is %d\", rank, mask_rank);\n+\n+\t  for (n=0; n<rank; n++)\n+\t    {\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n@@ -312,11 +352,20 @@ sminloc0_8_r16 (gfc_array_i8 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;"}, {"sha": "d7b8d547ecec184deaff58c837e149c0696796c0", "filename": "libgfortran/generated/minloc0_8_r4.c", "status": "modified", "additions": 63, "deletions": 14, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc0_8_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc0_8_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_8_r4.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -69,11 +69,22 @@ minloc0_8_r4 (gfc_array_i8 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MINLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;\n@@ -182,11 +193,40 @@ mminloc0_8_r4 (gfc_array_i8 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank, mask_rank;\n+\t  index_type ret_extent;\n+\t  int n;\n+\t  index_type array_extent, mask_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MINLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t\n+\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n+\t  if (rank != mask_rank)\n+\t    runtime_error (\"rank of MASK argument in MINLOC intrnisic\"\n+\t                   \"should be %d, is %d\", rank, mask_rank);\n+\n+\t  for (n=0; n<rank; n++)\n+\t    {\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n@@ -312,11 +352,20 @@ sminloc0_8_r4 (gfc_array_i8 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;"}, {"sha": "6ac0bfe1b00eaaff216c68b1c16b00e3d350202d", "filename": "libgfortran/generated/minloc0_8_r8.c", "status": "modified", "additions": 63, "deletions": 14, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc0_8_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc0_8_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_8_r8.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -69,11 +69,22 @@ minloc0_8_r8 (gfc_array_i8 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MINLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;\n@@ -182,11 +193,40 @@ mminloc0_8_r8 (gfc_array_i8 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n-\n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank, mask_rank;\n+\t  index_type ret_extent;\n+\t  int n;\n+\t  index_type array_extent, mask_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" MINLOC intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t\n+\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n+\t  if (rank != mask_rank)\n+\t    runtime_error (\"rank of MASK argument in MINLOC intrnisic\"\n+\t                   \"should be %d, is %d\", rank, mask_rank);\n+\n+\t  for (n=0; n<rank; n++)\n+\t    {\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n@@ -312,11 +352,20 @@ sminloc0_8_r8 (gfc_array_i8 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;"}, {"sha": "c1baf547b4b854607249022de8f6f629e81b327e", "filename": "libgfortran/generated/minloc1_16_i1.c", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc1_16_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc1_16_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_i1.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -116,7 +116,25 @@ minloc1_16_i1 (gfc_array_i16 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MINLOC intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -293,7 +311,35 @@ mminloc1_16_i1 (gfc_array_i16 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in MINLOC intrinsic\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+          for (n=0; n<= rank; n++)\n+            {\n+              index_type mask_extent, array_extent;\n+\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -406,13 +452,21 @@ sminloc1_16_i1 (gfc_array_i16 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n-    }\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n \n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n+    }\n     dstride = retarray->dim[0].stride;\n     dest = retarray->data;\n "}, {"sha": "db992cb4a7cfcd4e15caa893089245f3f38f1743", "filename": "libgfortran/generated/minloc1_16_i16.c", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc1_16_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc1_16_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_i16.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -116,7 +116,25 @@ minloc1_16_i16 (gfc_array_i16 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MINLOC intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -293,7 +311,35 @@ mminloc1_16_i16 (gfc_array_i16 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in MINLOC intrinsic\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+          for (n=0; n<= rank; n++)\n+            {\n+              index_type mask_extent, array_extent;\n+\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -406,13 +452,21 @@ sminloc1_16_i16 (gfc_array_i16 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n-    }\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n \n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n+    }\n     dstride = retarray->dim[0].stride;\n     dest = retarray->data;\n "}, {"sha": "523a4affff4fe55aa4278c3fccc50e7e64d82bfe", "filename": "libgfortran/generated/minloc1_16_i2.c", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc1_16_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc1_16_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_i2.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -116,7 +116,25 @@ minloc1_16_i2 (gfc_array_i16 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MINLOC intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -293,7 +311,35 @@ mminloc1_16_i2 (gfc_array_i16 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in MINLOC intrinsic\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+          for (n=0; n<= rank; n++)\n+            {\n+              index_type mask_extent, array_extent;\n+\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -406,13 +452,21 @@ sminloc1_16_i2 (gfc_array_i16 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n-    }\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n \n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n+    }\n     dstride = retarray->dim[0].stride;\n     dest = retarray->data;\n "}, {"sha": "e8d5fc397c6e5a62699edf8cd63378f2dd5c1891", "filename": "libgfortran/generated/minloc1_16_i4.c", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc1_16_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc1_16_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_i4.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -116,7 +116,25 @@ minloc1_16_i4 (gfc_array_i16 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MINLOC intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -293,7 +311,35 @@ mminloc1_16_i4 (gfc_array_i16 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in MINLOC intrinsic\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+          for (n=0; n<= rank; n++)\n+            {\n+              index_type mask_extent, array_extent;\n+\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -406,13 +452,21 @@ sminloc1_16_i4 (gfc_array_i16 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n-    }\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n \n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n+    }\n     dstride = retarray->dim[0].stride;\n     dest = retarray->data;\n "}, {"sha": "8c3e4e482426e6c12a6b6156ebca9c86e276a671", "filename": "libgfortran/generated/minloc1_16_i8.c", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc1_16_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc1_16_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_i8.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -116,7 +116,25 @@ minloc1_16_i8 (gfc_array_i16 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MINLOC intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -293,7 +311,35 @@ mminloc1_16_i8 (gfc_array_i16 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in MINLOC intrinsic\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+          for (n=0; n<= rank; n++)\n+            {\n+              index_type mask_extent, array_extent;\n+\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -406,13 +452,21 @@ sminloc1_16_i8 (gfc_array_i16 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n-    }\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n \n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n+    }\n     dstride = retarray->dim[0].stride;\n     dest = retarray->data;\n "}, {"sha": "7aa89a947ccc0de945dd4bb590d3674b6925bd4e", "filename": "libgfortran/generated/minloc1_16_r10.c", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc1_16_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc1_16_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_r10.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -116,7 +116,25 @@ minloc1_16_r10 (gfc_array_i16 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MINLOC intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -293,7 +311,35 @@ mminloc1_16_r10 (gfc_array_i16 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in MINLOC intrinsic\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+          for (n=0; n<= rank; n++)\n+            {\n+              index_type mask_extent, array_extent;\n+\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -406,13 +452,21 @@ sminloc1_16_r10 (gfc_array_i16 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n-    }\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n \n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n+    }\n     dstride = retarray->dim[0].stride;\n     dest = retarray->data;\n "}, {"sha": "5b814451d6001ff6f156ae1977a360ebe98dee4f", "filename": "libgfortran/generated/minloc1_16_r16.c", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc1_16_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc1_16_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_r16.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -116,7 +116,25 @@ minloc1_16_r16 (gfc_array_i16 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MINLOC intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -293,7 +311,35 @@ mminloc1_16_r16 (gfc_array_i16 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in MINLOC intrinsic\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+          for (n=0; n<= rank; n++)\n+            {\n+              index_type mask_extent, array_extent;\n+\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -406,13 +452,21 @@ sminloc1_16_r16 (gfc_array_i16 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n-    }\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n \n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n+    }\n     dstride = retarray->dim[0].stride;\n     dest = retarray->data;\n "}, {"sha": "b3c61552ffedc9a368380d5f27e705a1368ad182", "filename": "libgfortran/generated/minloc1_16_r4.c", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc1_16_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc1_16_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_r4.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -116,7 +116,25 @@ minloc1_16_r4 (gfc_array_i16 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MINLOC intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -293,7 +311,35 @@ mminloc1_16_r4 (gfc_array_i16 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in MINLOC intrinsic\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+          for (n=0; n<= rank; n++)\n+            {\n+              index_type mask_extent, array_extent;\n+\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -406,13 +452,21 @@ sminloc1_16_r4 (gfc_array_i16 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n-    }\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n \n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n+    }\n     dstride = retarray->dim[0].stride;\n     dest = retarray->data;\n "}, {"sha": "0a4b1b507776aa8019f1b7bd8e8d00848f276321", "filename": "libgfortran/generated/minloc1_16_r8.c", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc1_16_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc1_16_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_r8.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -116,7 +116,25 @@ minloc1_16_r8 (gfc_array_i16 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MINLOC intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -293,7 +311,35 @@ mminloc1_16_r8 (gfc_array_i16 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in MINLOC intrinsic\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+          for (n=0; n<= rank; n++)\n+            {\n+              index_type mask_extent, array_extent;\n+\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -406,13 +452,21 @@ sminloc1_16_r8 (gfc_array_i16 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n-    }\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n \n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n+    }\n     dstride = retarray->dim[0].stride;\n     dest = retarray->data;\n "}, {"sha": "9cebebe10a033929b5fb2bd91e521023cbf0987c", "filename": "libgfortran/generated/minloc1_4_i1.c", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc1_4_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc1_4_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_i1.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -116,7 +116,25 @@ minloc1_4_i1 (gfc_array_i4 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MINLOC intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -293,7 +311,35 @@ mminloc1_4_i1 (gfc_array_i4 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in MINLOC intrinsic\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+          for (n=0; n<= rank; n++)\n+            {\n+              index_type mask_extent, array_extent;\n+\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -406,13 +452,21 @@ sminloc1_4_i1 (gfc_array_i4 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n-    }\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n \n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n+    }\n     dstride = retarray->dim[0].stride;\n     dest = retarray->data;\n "}, {"sha": "a984a153d380c71b2eddbc624bf1da2f35dd2f5d", "filename": "libgfortran/generated/minloc1_4_i16.c", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc1_4_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc1_4_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_i16.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -116,7 +116,25 @@ minloc1_4_i16 (gfc_array_i4 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MINLOC intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -293,7 +311,35 @@ mminloc1_4_i16 (gfc_array_i4 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in MINLOC intrinsic\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+          for (n=0; n<= rank; n++)\n+            {\n+              index_type mask_extent, array_extent;\n+\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -406,13 +452,21 @@ sminloc1_4_i16 (gfc_array_i4 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n-    }\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n \n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n+    }\n     dstride = retarray->dim[0].stride;\n     dest = retarray->data;\n "}, {"sha": "685f9793b73feef33600f03dbef0eb132e5ea34b", "filename": "libgfortran/generated/minloc1_4_i2.c", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc1_4_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc1_4_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_i2.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -116,7 +116,25 @@ minloc1_4_i2 (gfc_array_i4 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MINLOC intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -293,7 +311,35 @@ mminloc1_4_i2 (gfc_array_i4 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in MINLOC intrinsic\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+          for (n=0; n<= rank; n++)\n+            {\n+              index_type mask_extent, array_extent;\n+\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -406,13 +452,21 @@ sminloc1_4_i2 (gfc_array_i4 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n-    }\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n \n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n+    }\n     dstride = retarray->dim[0].stride;\n     dest = retarray->data;\n "}, {"sha": "f44a631d352bf3ce5cc88654c43e8dc39361bb57", "filename": "libgfortran/generated/minloc1_4_i4.c", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc1_4_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc1_4_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_i4.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -116,7 +116,25 @@ minloc1_4_i4 (gfc_array_i4 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MINLOC intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -293,7 +311,35 @@ mminloc1_4_i4 (gfc_array_i4 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in MINLOC intrinsic\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+          for (n=0; n<= rank; n++)\n+            {\n+              index_type mask_extent, array_extent;\n+\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -406,13 +452,21 @@ sminloc1_4_i4 (gfc_array_i4 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n-    }\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n \n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n+    }\n     dstride = retarray->dim[0].stride;\n     dest = retarray->data;\n "}, {"sha": "f6858c028205368bbe11eb31de1b5696da01dd58", "filename": "libgfortran/generated/minloc1_4_i8.c", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc1_4_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc1_4_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_i8.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -116,7 +116,25 @@ minloc1_4_i8 (gfc_array_i4 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MINLOC intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -293,7 +311,35 @@ mminloc1_4_i8 (gfc_array_i4 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in MINLOC intrinsic\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+          for (n=0; n<= rank; n++)\n+            {\n+              index_type mask_extent, array_extent;\n+\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -406,13 +452,21 @@ sminloc1_4_i8 (gfc_array_i4 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n-    }\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n \n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n+    }\n     dstride = retarray->dim[0].stride;\n     dest = retarray->data;\n "}, {"sha": "8e359fe15193427d1715b1124402c37ffe805622", "filename": "libgfortran/generated/minloc1_4_r10.c", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc1_4_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc1_4_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_r10.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -116,7 +116,25 @@ minloc1_4_r10 (gfc_array_i4 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MINLOC intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -293,7 +311,35 @@ mminloc1_4_r10 (gfc_array_i4 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in MINLOC intrinsic\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+          for (n=0; n<= rank; n++)\n+            {\n+              index_type mask_extent, array_extent;\n+\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -406,13 +452,21 @@ sminloc1_4_r10 (gfc_array_i4 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n-    }\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n \n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n+    }\n     dstride = retarray->dim[0].stride;\n     dest = retarray->data;\n "}, {"sha": "11cb9c8f96271de741b8ab9523f707d7cb00dbd3", "filename": "libgfortran/generated/minloc1_4_r16.c", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc1_4_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc1_4_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_r16.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -116,7 +116,25 @@ minloc1_4_r16 (gfc_array_i4 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MINLOC intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -293,7 +311,35 @@ mminloc1_4_r16 (gfc_array_i4 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in MINLOC intrinsic\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+          for (n=0; n<= rank; n++)\n+            {\n+              index_type mask_extent, array_extent;\n+\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -406,13 +452,21 @@ sminloc1_4_r16 (gfc_array_i4 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n-    }\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n \n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n+    }\n     dstride = retarray->dim[0].stride;\n     dest = retarray->data;\n "}, {"sha": "31aa1f7a621046ce49acc4526cebbd9cd58371f4", "filename": "libgfortran/generated/minloc1_4_r4.c", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc1_4_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc1_4_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_r4.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -116,7 +116,25 @@ minloc1_4_r4 (gfc_array_i4 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MINLOC intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -293,7 +311,35 @@ mminloc1_4_r4 (gfc_array_i4 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in MINLOC intrinsic\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+          for (n=0; n<= rank; n++)\n+            {\n+              index_type mask_extent, array_extent;\n+\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -406,13 +452,21 @@ sminloc1_4_r4 (gfc_array_i4 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n-    }\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n \n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n+    }\n     dstride = retarray->dim[0].stride;\n     dest = retarray->data;\n "}, {"sha": "a7a56b67f897f58e74ca039eee377a4db3e58bc3", "filename": "libgfortran/generated/minloc1_4_r8.c", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc1_4_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc1_4_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_r8.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -116,7 +116,25 @@ minloc1_4_r8 (gfc_array_i4 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MINLOC intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -293,7 +311,35 @@ mminloc1_4_r8 (gfc_array_i4 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in MINLOC intrinsic\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+          for (n=0; n<= rank; n++)\n+            {\n+              index_type mask_extent, array_extent;\n+\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -406,13 +452,21 @@ sminloc1_4_r8 (gfc_array_i4 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n-    }\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n \n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n+    }\n     dstride = retarray->dim[0].stride;\n     dest = retarray->data;\n "}, {"sha": "1fae32b3fb6654ba13e62315fc093152a48de197", "filename": "libgfortran/generated/minloc1_8_i1.c", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc1_8_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc1_8_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_i1.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -116,7 +116,25 @@ minloc1_8_i1 (gfc_array_i8 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MINLOC intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -293,7 +311,35 @@ mminloc1_8_i1 (gfc_array_i8 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in MINLOC intrinsic\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+          for (n=0; n<= rank; n++)\n+            {\n+              index_type mask_extent, array_extent;\n+\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -406,13 +452,21 @@ sminloc1_8_i1 (gfc_array_i8 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n-    }\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n \n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n+    }\n     dstride = retarray->dim[0].stride;\n     dest = retarray->data;\n "}, {"sha": "0d31c944b851f871bc2c9523630e45073ed25a61", "filename": "libgfortran/generated/minloc1_8_i16.c", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc1_8_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc1_8_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_i16.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -116,7 +116,25 @@ minloc1_8_i16 (gfc_array_i8 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MINLOC intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -293,7 +311,35 @@ mminloc1_8_i16 (gfc_array_i8 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in MINLOC intrinsic\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+          for (n=0; n<= rank; n++)\n+            {\n+              index_type mask_extent, array_extent;\n+\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -406,13 +452,21 @@ sminloc1_8_i16 (gfc_array_i8 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n-    }\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n \n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n+    }\n     dstride = retarray->dim[0].stride;\n     dest = retarray->data;\n "}, {"sha": "88655757ddc05387362abbc88ffb0e63f8e82784", "filename": "libgfortran/generated/minloc1_8_i2.c", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc1_8_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc1_8_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_i2.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -116,7 +116,25 @@ minloc1_8_i2 (gfc_array_i8 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MINLOC intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -293,7 +311,35 @@ mminloc1_8_i2 (gfc_array_i8 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in MINLOC intrinsic\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+          for (n=0; n<= rank; n++)\n+            {\n+              index_type mask_extent, array_extent;\n+\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -406,13 +452,21 @@ sminloc1_8_i2 (gfc_array_i8 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n-    }\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n \n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n+    }\n     dstride = retarray->dim[0].stride;\n     dest = retarray->data;\n "}, {"sha": "31ee2385b36d8ea21d6d58108accbd322512bc6f", "filename": "libgfortran/generated/minloc1_8_i4.c", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc1_8_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc1_8_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_i4.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -116,7 +116,25 @@ minloc1_8_i4 (gfc_array_i8 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MINLOC intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -293,7 +311,35 @@ mminloc1_8_i4 (gfc_array_i8 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in MINLOC intrinsic\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+          for (n=0; n<= rank; n++)\n+            {\n+              index_type mask_extent, array_extent;\n+\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -406,13 +452,21 @@ sminloc1_8_i4 (gfc_array_i8 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n-    }\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n \n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n+    }\n     dstride = retarray->dim[0].stride;\n     dest = retarray->data;\n "}, {"sha": "13577aba741ed02ee4554ccbc8834282d3775e8c", "filename": "libgfortran/generated/minloc1_8_i8.c", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc1_8_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc1_8_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_i8.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -116,7 +116,25 @@ minloc1_8_i8 (gfc_array_i8 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MINLOC intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -293,7 +311,35 @@ mminloc1_8_i8 (gfc_array_i8 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in MINLOC intrinsic\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+          for (n=0; n<= rank; n++)\n+            {\n+              index_type mask_extent, array_extent;\n+\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -406,13 +452,21 @@ sminloc1_8_i8 (gfc_array_i8 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n-    }\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n \n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n+    }\n     dstride = retarray->dim[0].stride;\n     dest = retarray->data;\n "}, {"sha": "726aa1c89370bc475db2eb5271596b3b13ebeba6", "filename": "libgfortran/generated/minloc1_8_r10.c", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc1_8_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc1_8_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_r10.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -116,7 +116,25 @@ minloc1_8_r10 (gfc_array_i8 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MINLOC intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -293,7 +311,35 @@ mminloc1_8_r10 (gfc_array_i8 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in MINLOC intrinsic\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+          for (n=0; n<= rank; n++)\n+            {\n+              index_type mask_extent, array_extent;\n+\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -406,13 +452,21 @@ sminloc1_8_r10 (gfc_array_i8 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n-    }\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n \n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n+    }\n     dstride = retarray->dim[0].stride;\n     dest = retarray->data;\n "}, {"sha": "aaf9797856db193531fd4e393e7f4502d0df051a", "filename": "libgfortran/generated/minloc1_8_r16.c", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc1_8_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc1_8_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_r16.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -116,7 +116,25 @@ minloc1_8_r16 (gfc_array_i8 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MINLOC intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -293,7 +311,35 @@ mminloc1_8_r16 (gfc_array_i8 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in MINLOC intrinsic\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+          for (n=0; n<= rank; n++)\n+            {\n+              index_type mask_extent, array_extent;\n+\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -406,13 +452,21 @@ sminloc1_8_r16 (gfc_array_i8 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n-    }\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n \n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n+    }\n     dstride = retarray->dim[0].stride;\n     dest = retarray->data;\n "}, {"sha": "6b0bcec629cff65ad91daabb04478404855d62c0", "filename": "libgfortran/generated/minloc1_8_r4.c", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc1_8_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc1_8_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_r4.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -116,7 +116,25 @@ minloc1_8_r4 (gfc_array_i8 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MINLOC intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -293,7 +311,35 @@ mminloc1_8_r4 (gfc_array_i8 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in MINLOC intrinsic\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+          for (n=0; n<= rank; n++)\n+            {\n+              index_type mask_extent, array_extent;\n+\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -406,13 +452,21 @@ sminloc1_8_r4 (gfc_array_i8 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n-    }\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n \n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n+    }\n     dstride = retarray->dim[0].stride;\n     dest = retarray->data;\n "}, {"sha": "8a8d266393dfb47abf2e639310edc8f5ead5c286", "filename": "libgfortran/generated/minloc1_8_r8.c", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc1_8_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminloc1_8_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_r8.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -116,7 +116,25 @@ minloc1_8_r8 (gfc_array_i8 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MINLOC intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -293,7 +311,35 @@ mminloc1_8_r8 (gfc_array_i8 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in MINLOC intrinsic\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+          for (n=0; n<= rank; n++)\n+            {\n+              index_type mask_extent, array_extent;\n+\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -406,13 +452,21 @@ sminloc1_8_r8 (gfc_array_i8 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n-    }\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n \n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n+    }\n     dstride = retarray->dim[0].stride;\n     dest = retarray->data;\n "}, {"sha": "ef31ba0c8d8f6f8f1d5377cb991092d6a09bf5fe", "filename": "libgfortran/generated/minval_i1.c", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminval_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminval_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_i1.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -115,7 +115,25 @@ minval_i1 (gfc_array_i1 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MINVAL intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINVAL intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -287,7 +305,35 @@ mminval_i1 (gfc_array_i1 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in MINVAL intrinsic\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINVAL intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+          for (n=0; n<= rank; n++)\n+            {\n+              index_type mask_extent, array_extent;\n+\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MINVAL intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -395,13 +441,21 @@ sminval_i1 (gfc_array_i1 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n-    }\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINVAL intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n \n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n+    }\n     dstride = retarray->dim[0].stride;\n     dest = retarray->data;\n "}, {"sha": "8d7bf50c4aed28451c1946bd4efaa1ead40796a8", "filename": "libgfortran/generated/minval_i16.c", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminval_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminval_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_i16.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -115,7 +115,25 @@ minval_i16 (gfc_array_i16 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MINVAL intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINVAL intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -287,7 +305,35 @@ mminval_i16 (gfc_array_i16 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in MINVAL intrinsic\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINVAL intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+          for (n=0; n<= rank; n++)\n+            {\n+              index_type mask_extent, array_extent;\n+\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MINVAL intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -395,13 +441,21 @@ sminval_i16 (gfc_array_i16 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n-    }\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINVAL intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n \n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n+    }\n     dstride = retarray->dim[0].stride;\n     dest = retarray->data;\n "}, {"sha": "c3d63f6482b74b3cd72a771de6acc3cd9e3e50ff", "filename": "libgfortran/generated/minval_i2.c", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminval_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminval_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_i2.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -115,7 +115,25 @@ minval_i2 (gfc_array_i2 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MINVAL intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINVAL intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -287,7 +305,35 @@ mminval_i2 (gfc_array_i2 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in MINVAL intrinsic\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINVAL intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+          for (n=0; n<= rank; n++)\n+            {\n+              index_type mask_extent, array_extent;\n+\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MINVAL intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -395,13 +441,21 @@ sminval_i2 (gfc_array_i2 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n-    }\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINVAL intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n \n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n+    }\n     dstride = retarray->dim[0].stride;\n     dest = retarray->data;\n "}, {"sha": "48ea446db9cbb82203cfde4940b3c9879c381a30", "filename": "libgfortran/generated/minval_i4.c", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminval_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminval_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_i4.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -115,7 +115,25 @@ minval_i4 (gfc_array_i4 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MINVAL intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINVAL intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -287,7 +305,35 @@ mminval_i4 (gfc_array_i4 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in MINVAL intrinsic\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINVAL intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+          for (n=0; n<= rank; n++)\n+            {\n+              index_type mask_extent, array_extent;\n+\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MINVAL intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -395,13 +441,21 @@ sminval_i4 (gfc_array_i4 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n-    }\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINVAL intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n \n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n+    }\n     dstride = retarray->dim[0].stride;\n     dest = retarray->data;\n "}, {"sha": "cd2100a05ace27b1da9aa35050a27007ac7fa865", "filename": "libgfortran/generated/minval_i8.c", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminval_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminval_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_i8.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -115,7 +115,25 @@ minval_i8 (gfc_array_i8 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MINVAL intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINVAL intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -287,7 +305,35 @@ mminval_i8 (gfc_array_i8 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in MINVAL intrinsic\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINVAL intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+          for (n=0; n<= rank; n++)\n+            {\n+              index_type mask_extent, array_extent;\n+\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MINVAL intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -395,13 +441,21 @@ sminval_i8 (gfc_array_i8 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n-    }\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINVAL intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n \n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n+    }\n     dstride = retarray->dim[0].stride;\n     dest = retarray->data;\n "}, {"sha": "10d0302d4ee1d5e44dd2a6ff62ac6b8f41f4acd5", "filename": "libgfortran/generated/minval_r10.c", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminval_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminval_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_r10.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -115,7 +115,25 @@ minval_r10 (gfc_array_r10 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MINVAL intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINVAL intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -287,7 +305,35 @@ mminval_r10 (gfc_array_r10 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in MINVAL intrinsic\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINVAL intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+          for (n=0; n<= rank; n++)\n+            {\n+              index_type mask_extent, array_extent;\n+\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MINVAL intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -395,13 +441,21 @@ sminval_r10 (gfc_array_r10 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n-    }\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINVAL intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n \n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n+    }\n     dstride = retarray->dim[0].stride;\n     dest = retarray->data;\n "}, {"sha": "da6e7963a3a1cffb0d0c7d9629bf0c7d4f4288e5", "filename": "libgfortran/generated/minval_r16.c", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminval_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminval_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_r16.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -115,7 +115,25 @@ minval_r16 (gfc_array_r16 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MINVAL intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINVAL intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -287,7 +305,35 @@ mminval_r16 (gfc_array_r16 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in MINVAL intrinsic\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINVAL intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+          for (n=0; n<= rank; n++)\n+            {\n+              index_type mask_extent, array_extent;\n+\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MINVAL intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -395,13 +441,21 @@ sminval_r16 (gfc_array_r16 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n-    }\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINVAL intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n \n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n+    }\n     dstride = retarray->dim[0].stride;\n     dest = retarray->data;\n "}, {"sha": "745889a813113ea8fc8235e130f23cae8a343466", "filename": "libgfortran/generated/minval_r4.c", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminval_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminval_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_r4.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -115,7 +115,25 @@ minval_r4 (gfc_array_r4 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MINVAL intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINVAL intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -287,7 +305,35 @@ mminval_r4 (gfc_array_r4 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in MINVAL intrinsic\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINVAL intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+          for (n=0; n<= rank; n++)\n+            {\n+              index_type mask_extent, array_extent;\n+\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MINVAL intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -395,13 +441,21 @@ sminval_r4 (gfc_array_r4 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n-    }\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINVAL intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n \n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n+    }\n     dstride = retarray->dim[0].stride;\n     dest = retarray->data;\n "}, {"sha": "1b0fec0174a5f4d650d2629b719deaa169043b07", "filename": "libgfortran/generated/minval_r8.c", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminval_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fminval_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_r8.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -115,7 +115,25 @@ minval_r8 (gfc_array_r8 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MINVAL intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINVAL intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -287,7 +305,35 @@ mminval_r8 (gfc_array_r8 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in MINVAL intrinsic\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINVAL intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+          for (n=0; n<= rank; n++)\n+            {\n+              index_type mask_extent, array_extent;\n+\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" MINVAL intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -395,13 +441,21 @@ sminval_r8 (gfc_array_r8 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n-    }\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in MINVAL intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n \n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n+    }\n     dstride = retarray->dim[0].stride;\n     dest = retarray->data;\n "}, {"sha": "701835f9a43ed992419daa3b1edcd6be22ab4d4f", "filename": "libgfortran/generated/product_c10.c", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fproduct_c10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fproduct_c10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_c10.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -115,7 +115,25 @@ product_c10 (gfc_array_c10 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" PRODUCT intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" PRODUCT intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -286,7 +304,35 @@ mproduct_c10 (gfc_array_c10 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in PRODUCT intrinsic\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" PRODUCT intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+          for (n=0; n<= rank; n++)\n+            {\n+              index_type mask_extent, array_extent;\n+\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" PRODUCT intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -394,13 +440,21 @@ sproduct_c10 (gfc_array_c10 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n-    }\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in PRODUCT intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n \n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n+    }\n     dstride = retarray->dim[0].stride;\n     dest = retarray->data;\n "}, {"sha": "1d58a7687568947565a01a982845ac26e48a3b6e", "filename": "libgfortran/generated/product_c16.c", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fproduct_c16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fproduct_c16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_c16.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -115,7 +115,25 @@ product_c16 (gfc_array_c16 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" PRODUCT intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" PRODUCT intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -286,7 +304,35 @@ mproduct_c16 (gfc_array_c16 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in PRODUCT intrinsic\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" PRODUCT intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+          for (n=0; n<= rank; n++)\n+            {\n+              index_type mask_extent, array_extent;\n+\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" PRODUCT intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -394,13 +440,21 @@ sproduct_c16 (gfc_array_c16 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n-    }\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in PRODUCT intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n \n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n+    }\n     dstride = retarray->dim[0].stride;\n     dest = retarray->data;\n "}, {"sha": "3754fcb5cae75b1e0b9a5656002f0af62ba1a591", "filename": "libgfortran/generated/product_c4.c", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fproduct_c4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fproduct_c4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_c4.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -115,7 +115,25 @@ product_c4 (gfc_array_c4 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" PRODUCT intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" PRODUCT intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -286,7 +304,35 @@ mproduct_c4 (gfc_array_c4 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in PRODUCT intrinsic\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" PRODUCT intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+          for (n=0; n<= rank; n++)\n+            {\n+              index_type mask_extent, array_extent;\n+\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" PRODUCT intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -394,13 +440,21 @@ sproduct_c4 (gfc_array_c4 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n-    }\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in PRODUCT intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n \n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n+    }\n     dstride = retarray->dim[0].stride;\n     dest = retarray->data;\n "}, {"sha": "6312451b794d5212b14653467b01119b31c29066", "filename": "libgfortran/generated/product_c8.c", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fproduct_c8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fproduct_c8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_c8.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -115,7 +115,25 @@ product_c8 (gfc_array_c8 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" PRODUCT intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" PRODUCT intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -286,7 +304,35 @@ mproduct_c8 (gfc_array_c8 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in PRODUCT intrinsic\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" PRODUCT intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+          for (n=0; n<= rank; n++)\n+            {\n+              index_type mask_extent, array_extent;\n+\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" PRODUCT intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -394,13 +440,21 @@ sproduct_c8 (gfc_array_c8 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n-    }\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in PRODUCT intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n \n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n+    }\n     dstride = retarray->dim[0].stride;\n     dest = retarray->data;\n "}, {"sha": "7003129a4f7bcf017000e0d5e5d67a72abef16f2", "filename": "libgfortran/generated/product_i1.c", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fproduct_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fproduct_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_i1.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -115,7 +115,25 @@ product_i1 (gfc_array_i1 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" PRODUCT intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" PRODUCT intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -286,7 +304,35 @@ mproduct_i1 (gfc_array_i1 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in PRODUCT intrinsic\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" PRODUCT intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+          for (n=0; n<= rank; n++)\n+            {\n+              index_type mask_extent, array_extent;\n+\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" PRODUCT intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -394,13 +440,21 @@ sproduct_i1 (gfc_array_i1 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n-    }\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in PRODUCT intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n \n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n+    }\n     dstride = retarray->dim[0].stride;\n     dest = retarray->data;\n "}, {"sha": "3c448082195b2bc94725c142f5ad570eecb55946", "filename": "libgfortran/generated/product_i16.c", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fproduct_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fproduct_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_i16.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -115,7 +115,25 @@ product_i16 (gfc_array_i16 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" PRODUCT intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" PRODUCT intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -286,7 +304,35 @@ mproduct_i16 (gfc_array_i16 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in PRODUCT intrinsic\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" PRODUCT intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+          for (n=0; n<= rank; n++)\n+            {\n+              index_type mask_extent, array_extent;\n+\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" PRODUCT intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -394,13 +440,21 @@ sproduct_i16 (gfc_array_i16 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n-    }\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in PRODUCT intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n \n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n+    }\n     dstride = retarray->dim[0].stride;\n     dest = retarray->data;\n "}, {"sha": "ca57d29dc2078428f09e7ec79e61a7520a644285", "filename": "libgfortran/generated/product_i2.c", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fproduct_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fproduct_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_i2.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -115,7 +115,25 @@ product_i2 (gfc_array_i2 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" PRODUCT intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" PRODUCT intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -286,7 +304,35 @@ mproduct_i2 (gfc_array_i2 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in PRODUCT intrinsic\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" PRODUCT intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+          for (n=0; n<= rank; n++)\n+            {\n+              index_type mask_extent, array_extent;\n+\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" PRODUCT intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -394,13 +440,21 @@ sproduct_i2 (gfc_array_i2 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n-    }\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in PRODUCT intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n \n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n+    }\n     dstride = retarray->dim[0].stride;\n     dest = retarray->data;\n "}, {"sha": "d31eb6e15989f11bad6c96c0d8387207637d5ba8", "filename": "libgfortran/generated/product_i4.c", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fproduct_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fproduct_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_i4.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -115,7 +115,25 @@ product_i4 (gfc_array_i4 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" PRODUCT intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" PRODUCT intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -286,7 +304,35 @@ mproduct_i4 (gfc_array_i4 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in PRODUCT intrinsic\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" PRODUCT intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+          for (n=0; n<= rank; n++)\n+            {\n+              index_type mask_extent, array_extent;\n+\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" PRODUCT intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -394,13 +440,21 @@ sproduct_i4 (gfc_array_i4 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n-    }\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in PRODUCT intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n \n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n+    }\n     dstride = retarray->dim[0].stride;\n     dest = retarray->data;\n "}, {"sha": "8867aaea2fdfc193145628fe998b014e8a2df268", "filename": "libgfortran/generated/product_i8.c", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fproduct_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fproduct_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_i8.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -115,7 +115,25 @@ product_i8 (gfc_array_i8 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" PRODUCT intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" PRODUCT intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -286,7 +304,35 @@ mproduct_i8 (gfc_array_i8 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in PRODUCT intrinsic\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" PRODUCT intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+          for (n=0; n<= rank; n++)\n+            {\n+              index_type mask_extent, array_extent;\n+\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" PRODUCT intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -394,13 +440,21 @@ sproduct_i8 (gfc_array_i8 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n-    }\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in PRODUCT intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n \n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n+    }\n     dstride = retarray->dim[0].stride;\n     dest = retarray->data;\n "}, {"sha": "235b8a664ddd64ffd6373c08013aeed71b209b03", "filename": "libgfortran/generated/product_r10.c", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fproduct_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fproduct_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_r10.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -115,7 +115,25 @@ product_r10 (gfc_array_r10 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" PRODUCT intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" PRODUCT intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -286,7 +304,35 @@ mproduct_r10 (gfc_array_r10 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in PRODUCT intrinsic\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" PRODUCT intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+          for (n=0; n<= rank; n++)\n+            {\n+              index_type mask_extent, array_extent;\n+\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" PRODUCT intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -394,13 +440,21 @@ sproduct_r10 (gfc_array_r10 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n-    }\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in PRODUCT intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n \n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n+    }\n     dstride = retarray->dim[0].stride;\n     dest = retarray->data;\n "}, {"sha": "2f837e303f1ca2494f8575c0e37213a035a3f684", "filename": "libgfortran/generated/product_r16.c", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fproduct_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fproduct_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_r16.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -115,7 +115,25 @@ product_r16 (gfc_array_r16 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" PRODUCT intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" PRODUCT intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -286,7 +304,35 @@ mproduct_r16 (gfc_array_r16 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in PRODUCT intrinsic\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" PRODUCT intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+          for (n=0; n<= rank; n++)\n+            {\n+              index_type mask_extent, array_extent;\n+\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" PRODUCT intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -394,13 +440,21 @@ sproduct_r16 (gfc_array_r16 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n-    }\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in PRODUCT intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n \n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n+    }\n     dstride = retarray->dim[0].stride;\n     dest = retarray->data;\n "}, {"sha": "4e6c3d178ef6ed289b77072185ca7759e9823311", "filename": "libgfortran/generated/product_r4.c", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fproduct_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fproduct_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_r4.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -115,7 +115,25 @@ product_r4 (gfc_array_r4 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" PRODUCT intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" PRODUCT intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -286,7 +304,35 @@ mproduct_r4 (gfc_array_r4 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in PRODUCT intrinsic\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" PRODUCT intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+          for (n=0; n<= rank; n++)\n+            {\n+              index_type mask_extent, array_extent;\n+\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" PRODUCT intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -394,13 +440,21 @@ sproduct_r4 (gfc_array_r4 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n-    }\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in PRODUCT intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n \n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n+    }\n     dstride = retarray->dim[0].stride;\n     dest = retarray->data;\n "}, {"sha": "849d404869d2f10e6c6be9f6f8dee155bcbff51a", "filename": "libgfortran/generated/product_r8.c", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fproduct_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fproduct_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_r8.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -115,7 +115,25 @@ product_r8 (gfc_array_r8 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" PRODUCT intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" PRODUCT intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -286,7 +304,35 @@ mproduct_r8 (gfc_array_r8 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in PRODUCT intrinsic\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" PRODUCT intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+          for (n=0; n<= rank; n++)\n+            {\n+              index_type mask_extent, array_extent;\n+\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" PRODUCT intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -394,13 +440,21 @@ sproduct_r8 (gfc_array_r8 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n-    }\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in PRODUCT intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n \n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n+    }\n     dstride = retarray->dim[0].stride;\n     dest = retarray->data;\n "}, {"sha": "f3da3849808163cdfc91d9273b2ba82e899520bd", "filename": "libgfortran/generated/sum_c10.c", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fsum_c10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fsum_c10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_c10.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -115,7 +115,25 @@ sum_c10 (gfc_array_c10 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" SUM intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" SUM intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -286,7 +304,35 @@ msum_c10 (gfc_array_c10 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in SUM intrinsic\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" SUM intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+          for (n=0; n<= rank; n++)\n+            {\n+              index_type mask_extent, array_extent;\n+\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" SUM intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -394,13 +440,21 @@ ssum_c10 (gfc_array_c10 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n-    }\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in SUM intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n \n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n+    }\n     dstride = retarray->dim[0].stride;\n     dest = retarray->data;\n "}, {"sha": "df79daf313a5d027b0fba0cad126a7c1ccd966f6", "filename": "libgfortran/generated/sum_c16.c", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fsum_c16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fsum_c16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_c16.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -115,7 +115,25 @@ sum_c16 (gfc_array_c16 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" SUM intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" SUM intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -286,7 +304,35 @@ msum_c16 (gfc_array_c16 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in SUM intrinsic\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" SUM intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+          for (n=0; n<= rank; n++)\n+            {\n+              index_type mask_extent, array_extent;\n+\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" SUM intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -394,13 +440,21 @@ ssum_c16 (gfc_array_c16 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n-    }\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in SUM intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n \n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n+    }\n     dstride = retarray->dim[0].stride;\n     dest = retarray->data;\n "}, {"sha": "9ef9e8399f7cef72a05fb4a78e03b7daca25a0c6", "filename": "libgfortran/generated/sum_c4.c", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fsum_c4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fsum_c4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_c4.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -115,7 +115,25 @@ sum_c4 (gfc_array_c4 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" SUM intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" SUM intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -286,7 +304,35 @@ msum_c4 (gfc_array_c4 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in SUM intrinsic\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" SUM intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+          for (n=0; n<= rank; n++)\n+            {\n+              index_type mask_extent, array_extent;\n+\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" SUM intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -394,13 +440,21 @@ ssum_c4 (gfc_array_c4 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n-    }\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in SUM intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n \n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n+    }\n     dstride = retarray->dim[0].stride;\n     dest = retarray->data;\n "}, {"sha": "a7f7392e747598744e9bc5de211d3a14805c27cb", "filename": "libgfortran/generated/sum_c8.c", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fsum_c8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fsum_c8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_c8.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -115,7 +115,25 @@ sum_c8 (gfc_array_c8 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" SUM intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" SUM intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -286,7 +304,35 @@ msum_c8 (gfc_array_c8 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in SUM intrinsic\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" SUM intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+          for (n=0; n<= rank; n++)\n+            {\n+              index_type mask_extent, array_extent;\n+\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" SUM intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -394,13 +440,21 @@ ssum_c8 (gfc_array_c8 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n-    }\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in SUM intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n \n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n+    }\n     dstride = retarray->dim[0].stride;\n     dest = retarray->data;\n "}, {"sha": "8740fb79b5ee374990af7eb520cf530fba0842c7", "filename": "libgfortran/generated/sum_i1.c", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fsum_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fsum_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_i1.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -115,7 +115,25 @@ sum_i1 (gfc_array_i1 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" SUM intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" SUM intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -286,7 +304,35 @@ msum_i1 (gfc_array_i1 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in SUM intrinsic\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" SUM intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+          for (n=0; n<= rank; n++)\n+            {\n+              index_type mask_extent, array_extent;\n+\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" SUM intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -394,13 +440,21 @@ ssum_i1 (gfc_array_i1 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n-    }\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in SUM intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n \n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n+    }\n     dstride = retarray->dim[0].stride;\n     dest = retarray->data;\n "}, {"sha": "6500d178fa4d17c42916ca7080e6f78eb9253aef", "filename": "libgfortran/generated/sum_i16.c", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fsum_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fsum_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_i16.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -115,7 +115,25 @@ sum_i16 (gfc_array_i16 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" SUM intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" SUM intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -286,7 +304,35 @@ msum_i16 (gfc_array_i16 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in SUM intrinsic\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" SUM intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+          for (n=0; n<= rank; n++)\n+            {\n+              index_type mask_extent, array_extent;\n+\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" SUM intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -394,13 +440,21 @@ ssum_i16 (gfc_array_i16 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n-    }\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in SUM intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n \n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n+    }\n     dstride = retarray->dim[0].stride;\n     dest = retarray->data;\n "}, {"sha": "10202c35ac8a909663dd492dd278fa646dcd60d7", "filename": "libgfortran/generated/sum_i2.c", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fsum_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fsum_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_i2.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -115,7 +115,25 @@ sum_i2 (gfc_array_i2 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" SUM intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" SUM intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -286,7 +304,35 @@ msum_i2 (gfc_array_i2 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in SUM intrinsic\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" SUM intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+          for (n=0; n<= rank; n++)\n+            {\n+              index_type mask_extent, array_extent;\n+\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" SUM intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -394,13 +440,21 @@ ssum_i2 (gfc_array_i2 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n-    }\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in SUM intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n \n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n+    }\n     dstride = retarray->dim[0].stride;\n     dest = retarray->data;\n "}, {"sha": "4d0e8a4a963eb0562e2c7484761192b85526fbbc", "filename": "libgfortran/generated/sum_i4.c", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fsum_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fsum_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_i4.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -115,7 +115,25 @@ sum_i4 (gfc_array_i4 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" SUM intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" SUM intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -286,7 +304,35 @@ msum_i4 (gfc_array_i4 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in SUM intrinsic\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" SUM intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+          for (n=0; n<= rank; n++)\n+            {\n+              index_type mask_extent, array_extent;\n+\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" SUM intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -394,13 +440,21 @@ ssum_i4 (gfc_array_i4 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n-    }\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in SUM intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n \n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n+    }\n     dstride = retarray->dim[0].stride;\n     dest = retarray->data;\n "}, {"sha": "8b280a81e0d1cfce08b4f92d4d2672337543e48f", "filename": "libgfortran/generated/sum_i8.c", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fsum_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fsum_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_i8.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -115,7 +115,25 @@ sum_i8 (gfc_array_i8 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" SUM intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" SUM intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -286,7 +304,35 @@ msum_i8 (gfc_array_i8 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in SUM intrinsic\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" SUM intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+          for (n=0; n<= rank; n++)\n+            {\n+              index_type mask_extent, array_extent;\n+\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" SUM intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -394,13 +440,21 @@ ssum_i8 (gfc_array_i8 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n-    }\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in SUM intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n \n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n+    }\n     dstride = retarray->dim[0].stride;\n     dest = retarray->data;\n "}, {"sha": "0fd8775f93ca3b30705487baadb5b8a834727703", "filename": "libgfortran/generated/sum_r10.c", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fsum_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fsum_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_r10.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -115,7 +115,25 @@ sum_r10 (gfc_array_r10 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" SUM intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" SUM intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -286,7 +304,35 @@ msum_r10 (gfc_array_r10 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in SUM intrinsic\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" SUM intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+          for (n=0; n<= rank; n++)\n+            {\n+              index_type mask_extent, array_extent;\n+\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" SUM intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -394,13 +440,21 @@ ssum_r10 (gfc_array_r10 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n-    }\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in SUM intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n \n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n+    }\n     dstride = retarray->dim[0].stride;\n     dest = retarray->data;\n "}, {"sha": "8903b64d8bcf5ee88a5482feef021d1aef90e8e1", "filename": "libgfortran/generated/sum_r16.c", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fsum_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fsum_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_r16.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -115,7 +115,25 @@ sum_r16 (gfc_array_r16 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" SUM intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" SUM intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -286,7 +304,35 @@ msum_r16 (gfc_array_r16 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in SUM intrinsic\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" SUM intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+          for (n=0; n<= rank; n++)\n+            {\n+              index_type mask_extent, array_extent;\n+\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" SUM intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -394,13 +440,21 @@ ssum_r16 (gfc_array_r16 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n-    }\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in SUM intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n \n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n+    }\n     dstride = retarray->dim[0].stride;\n     dest = retarray->data;\n "}, {"sha": "1d3f2d09008e39525ca98fb586e9c0eb7302639b", "filename": "libgfortran/generated/sum_r4.c", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fsum_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fsum_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_r4.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -115,7 +115,25 @@ sum_r4 (gfc_array_r4 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" SUM intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" SUM intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -286,7 +304,35 @@ msum_r4 (gfc_array_r4 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in SUM intrinsic\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" SUM intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+          for (n=0; n<= rank; n++)\n+            {\n+              index_type mask_extent, array_extent;\n+\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" SUM intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -394,13 +440,21 @@ ssum_r4 (gfc_array_r4 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n-    }\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in SUM intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n \n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n+    }\n     dstride = retarray->dim[0].stride;\n     dest = retarray->data;\n "}, {"sha": "d049876d5f2f27a1438141f5db0d933a2d97fee7", "filename": "libgfortran/generated/sum_r8.c", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fsum_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fgenerated%2Fsum_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_r8.c?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -115,7 +115,25 @@ sum_r8 (gfc_array_r8 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" SUM intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" SUM intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -286,7 +304,35 @@ msum_r8 (gfc_array_r8 * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in SUM intrinsic\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" SUM intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+          for (n=0; n<= rank; n++)\n+            {\n+              index_type mask_extent, array_extent;\n+\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" SUM intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -394,13 +440,21 @@ ssum_r8 (gfc_array_r8 * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n-    }\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in SUM intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n \n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n+    }\n     dstride = retarray->dim[0].stride;\n     dest = retarray->data;\n "}, {"sha": "a49d33b9311eff0f703b6ea579c842be0aa6463e", "filename": "libgfortran/m4/iforeach.m4", "status": "modified", "additions": 61, "deletions": 12, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fm4%2Fiforeach.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fm4%2Fiforeach.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fiforeach.m4?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -36,11 +36,22 @@ name`'rtype_qual`_'atype_code (rtype * const restrict retarray,\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in u_name intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" u_name intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;\n@@ -141,11 +152,40 @@ void\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank, mask_rank;\n+\t  index_type ret_extent;\n+\t  int n;\n+\t  index_type array_extent, mask_extent;\n+\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in u_name intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t  if (ret_extent != rank)\n+\t    runtime_error (\"Incorrect extent in return value of\"\n+\t\t\t   \" u_name intrnisic: is %ld, should be %d\",\n+\t\t\t   (long int) ret_extent, rank);\n+\t\n+\t  mask_rank = GFC_DESCRIPTOR_RANK (mask);\n+\t  if (rank != mask_rank)\n+\t    runtime_error (\"rank of MASK argument in u_name intrnisic\"\n+\t                   \"should be %d, is %d\", rank, mask_rank);\n+\n+\t  for (n=0; n<rank; n++)\n+\t    {\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" u_name intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n@@ -270,11 +310,20 @@ void\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in u_name intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n+\n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n     }\n \n   dstride = retarray->dim[0].stride;"}, {"sha": "965fff8acc53cb8beced55b09e024aeba2e985b4", "filename": "libgfortran/m4/ifunction.m4", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fm4%2Fifunction.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fm4%2Fifunction.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fifunction.m4?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -98,7 +98,25 @@ name`'rtype_qual`_'atype_code (rtype * const restrict retarray,\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" u_name intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" u_name intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -269,7 +287,35 @@ void\n   else\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect\");\n+\truntime_error (\"rank of return array incorrect in u_name intrinsic\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" u_name intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+          for (n=0; n<= rank; n++)\n+            {\n+              index_type mask_extent, array_extent;\n+\n+\t      array_extent = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\t      mask_extent = mask->dim[n].ubound + 1 - mask->dim[n].lbound;\n+\t      if (array_extent != mask_extent)\n+\t\truntime_error (\"Incorrect extent in MASK argument of\"\n+\t\t\t       \" u_name intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) mask_extent, (long int) array_extent);\n+\t    }\n+\t}\n     }\n \n   for (n = 0; n < rank; n++)\n@@ -376,13 +422,21 @@ void\n     }\n   else\n     {\n-      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n-\truntime_error (\"rank of return array does not equal 1\");\n+      if (compile_options.bounds_check)\n+\t{\n+\t  int ret_rank;\n+\t  index_type ret_extent;\n \n-      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n-        runtime_error (\"dimension of return array incorrect\");\n-    }\n+\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n+\t  if (ret_rank != 1)\n+\t    runtime_error (\"rank of return array in u_name intrinsic\"\n+\t\t\t   \" should be 1, is %d\", ret_rank);\n \n+\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n+\t    if (ret_extent != rank)\n+\t      runtime_error (\"dimension of return array incorrect\");\n+\t}\n+    }\n     dstride = retarray->dim[0].stride;\n     dest = retarray->data;\n "}, {"sha": "51ee40d049d3b2dd98b62650c722334743f4fe68", "filename": "libgfortran/m4/iparm.m4", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fm4%2Fiparm.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6590f8c8ca86225f6154636029937cd424dbec/libgfortran%2Fm4%2Fiparm.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fiparm.m4?ref=fd6590f8c8ca86225f6154636029937cd424dbec", "patch": "@@ -30,4 +30,6 @@ define(rtype_qual,`_'rtype_kind)dnl\n define(atype_max, atype_name`_HUGE')dnl\n define(atype_min,ifelse(regexp(file, `_\\(.\\)[0-9]*\\.c$', `\\1'),`i',`(-'atype_max`-1)',`-'atype_max))dnl\n define(name, regexp(regexp(file, `[^/]*$', `\\&'), `^\\([^_]*\\)_', `\\1'))dnl\n+define(`upcase', `translit(`$*', `a-z', `A-Z')')dnl\n+define(`u_name',`regexp(upcase(name),`\\([A-Z]*\\)',`\\1')')dnl\n define(rtype_ccode,ifelse(rtype_letter,`i',rtype_kind,rtype_code))dnl"}]}