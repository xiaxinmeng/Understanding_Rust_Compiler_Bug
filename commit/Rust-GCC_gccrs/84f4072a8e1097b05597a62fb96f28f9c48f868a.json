{"sha": "84f4072a8e1097b05597a62fb96f28f9c48f868a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODRmNDA3MmE4ZTEwOTdiMDU1OTdhNjJmYjk2ZjI4ZjljNDhmODY4YQ==", "commit": {"author": {"name": "Javier Miranda", "email": "miranda@adacore.com", "date": "2012-03-07T14:56:40Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-03-07T14:56:40Z"}, "message": "sem_ch3.adb (Analyze_Object_Declaration): If the object declaration has an init expression then stop the analysis of the...\n\n2012-03-07  Javier Miranda  <miranda@adacore.com>\n\n\t* sem_ch3.adb (Analyze_Object_Declaration): If the object\n\tdeclaration has an init expression then stop the analysis of the\n\tobject declaration if the expression which initializes the object\n\tis a call to an inlined function which returns an unconstrained\n\tand has been expanded into a procedure call.\n\t* sem_ch5.adb (Has_Call_Using_Secondary_Stack): Add missing\n\tsupport to handle selected components.\n\t* sem_ch6.ads (Cannot_Inline): Adding parameter Is_Serious plus\n\tdocumentation.\n\t* sem_ch6.adb (Check_And_Build_Body_To_Inline): New\n\tsubprogram which implements the checks required by the\n\tnew rules for frontend inlining and builds the body to inline.\n\t(Analyze_Subprogram_Body_Helper): Move code that\n\tchecks inlining of subprogram that has nested subprogram\n\tto Check_And_Build_Body_To_Inline.  Replace call to\n\tBuild_Body_To_Inline by call to the new subprogram\n\tCheck_And_Build_Body_To_Inline.\n\t(Cannot_Inline): New implementation.\n\t* sem_ch12.adb (Analyze_Package_Instantiation.Must_Inline_Subp):\n\tNew subprogram.\n\t* sem_util.ad[sb] (Must_Inline): New subprogram.\n\t(Returns_Unconstrained_Type): New subprogram.\n\t* sem_res.adb (Resolve_Call): Do not create a transient scope\n\tfor inlined calls.\n\t* inline.ads (Analyzing_Inlined_Bodies): Remove unreferenced variable.\n\t* inline.adb (Analyze_Inlined_Bodies, Initialize): Remove setting\n\tto false the variable Analyzing_Inlined_Bodies.  Fix comments.\n\t* exp_ch4.adb (Expand_N_Allocator): Fix handling of finalization master.\n\t* exp_ch6.ads (List_Inlining_Info): New subprogram.\n\t* exp_ch6.adb (Expand_Call.Do_Inline): New subprogram.\n\t(Expand_Call.Do_Inline_Always): New subprogram.\n\t(In_Unfrozen_Instance): Move the declaration of this subprogram.\n\t(Expand_Inlined_Call.Reset_Dispatching_Calls): New subprogram.\n\t(Expand_Inlined_Call): Adding new support for inlining functions\n\tthat return unconstrained types.\n\t(List_Inlining_Info): New subprogram.\n\t* debug.adb Document flags -gnatd.j and -gnatd.k\n\t* gnat1drv.adb Add call to generate the new listing of inlined\n\tcalls and calls passed to the backend.\n\nFrom-SVN: r185055", "tree": {"sha": "52cd3c2b010767c3a763388a9abbd0153db9e200", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/52cd3c2b010767c3a763388a9abbd0153db9e200"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/84f4072a8e1097b05597a62fb96f28f9c48f868a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84f4072a8e1097b05597a62fb96f28f9c48f868a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/84f4072a8e1097b05597a62fb96f28f9c48f868a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84f4072a8e1097b05597a62fb96f28f9c48f868a/comments", "author": {"login": "miranda-adacore", "id": 54413934, "node_id": "MDQ6VXNlcjU0NDEzOTM0", "avatar_url": "https://avatars.githubusercontent.com/u/54413934?v=4", "gravatar_id": "", "url": "https://api.github.com/users/miranda-adacore", "html_url": "https://github.com/miranda-adacore", "followers_url": "https://api.github.com/users/miranda-adacore/followers", "following_url": "https://api.github.com/users/miranda-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/miranda-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/miranda-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/miranda-adacore/subscriptions", "organizations_url": "https://api.github.com/users/miranda-adacore/orgs", "repos_url": "https://api.github.com/users/miranda-adacore/repos", "events_url": "https://api.github.com/users/miranda-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/miranda-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "844ec03891e1e5d99d7a8da2860a3ebfbfad62c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/844ec03891e1e5d99d7a8da2860a3ebfbfad62c8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/844ec03891e1e5d99d7a8da2860a3ebfbfad62c8"}], "stats": {"total": 2268, "additions": 2148, "deletions": 120}, "files": [{"sha": "41b7b0de96618c9923570547775001980f592058", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84f4072a8e1097b05597a62fb96f28f9c48f868a/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84f4072a8e1097b05597a62fb96f28f9c48f868a/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=84f4072a8e1097b05597a62fb96f28f9c48f868a", "patch": "@@ -1,3 +1,45 @@\n+2012-03-07  Javier Miranda  <miranda@adacore.com>\n+\n+\t* sem_ch3.adb (Analyze_Object_Declaration): If the object\n+\tdeclaration has an init expression then stop the analysis of the\n+\tobject declaration if the expression which initializes the object\n+\tis a call to an inlined function which returns an unconstrained\n+\tand has been expanded into a procedure call.\n+\t* sem_ch5.adb (Has_Call_Using_Secondary_Stack): Add missing\n+\tsupport to handle selected components.\n+\t* sem_ch6.ads (Cannot_Inline): Adding parameter Is_Serious plus\n+\tdocumentation.\n+\t* sem_ch6.adb (Check_And_Build_Body_To_Inline): New\n+\tsubprogram which implements the checks required by the\n+\tnew rules for frontend inlining and builds the body to inline.\n+\t(Analyze_Subprogram_Body_Helper): Move code that\n+\tchecks inlining of subprogram that has nested subprogram\n+\tto Check_And_Build_Body_To_Inline.  Replace call to\n+\tBuild_Body_To_Inline by call to the new subprogram\n+\tCheck_And_Build_Body_To_Inline.\n+\t(Cannot_Inline): New implementation.\n+\t* sem_ch12.adb (Analyze_Package_Instantiation.Must_Inline_Subp):\n+\tNew subprogram.\n+\t* sem_util.ad[sb] (Must_Inline): New subprogram.\n+\t(Returns_Unconstrained_Type): New subprogram.\n+\t* sem_res.adb (Resolve_Call): Do not create a transient scope\n+\tfor inlined calls.\n+\t* inline.ads (Analyzing_Inlined_Bodies): Remove unreferenced variable.\n+\t* inline.adb (Analyze_Inlined_Bodies, Initialize): Remove setting\n+\tto false the variable Analyzing_Inlined_Bodies.  Fix comments.\n+\t* exp_ch4.adb (Expand_N_Allocator): Fix handling of finalization master.\n+\t* exp_ch6.ads (List_Inlining_Info): New subprogram.\n+\t* exp_ch6.adb (Expand_Call.Do_Inline): New subprogram.\n+\t(Expand_Call.Do_Inline_Always): New subprogram.\n+\t(In_Unfrozen_Instance): Move the declaration of this subprogram.\n+\t(Expand_Inlined_Call.Reset_Dispatching_Calls): New subprogram.\n+\t(Expand_Inlined_Call): Adding new support for inlining functions\n+\tthat return unconstrained types.\n+\t(List_Inlining_Info): New subprogram.\n+\t* debug.adb Document flags -gnatd.j and -gnatd.k\n+\t* gnat1drv.adb Add call to generate the new listing of inlined\n+\tcalls and calls passed to the backend.\n+\n 2012-03-07  Robert Dewar  <dewar@adacore.com>\n \n \t* sem_ch5.adb, s-vaflop.adb, s-taprop-vms.adb, exp_ch6.adb,"}, {"sha": "3fd2d64511597337680950bd9037280391ab4888", "filename": "gcc/ada/debug.adb", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84f4072a8e1097b05597a62fb96f28f9c48f868a/gcc%2Fada%2Fdebug.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84f4072a8e1097b05597a62fb96f28f9c48f868a/gcc%2Fada%2Fdebug.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdebug.adb?ref=84f4072a8e1097b05597a62fb96f28f9c48f868a", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -100,8 +100,8 @@ package body Debug is\n    --  d.g  Enable conversion of raise into goto\n    --  d.h\n    --  d.i  Ignore Warnings pragmas\n-   --  d.j\n-   --  d.k\n+   --  d.j  Generate listing of frontend inlined calls\n+   --  d.k  Enable new support for frontend inlining\n    --  d.l  Use Ada 95 semantics for limited function returns\n    --  d.m  For -gnatl, print full source only for main unit\n    --  d.n  Print source file names\n@@ -533,6 +533,13 @@ package body Debug is\n    --       be used in particular to disable Warnings (Off) to check if any of\n    --       these statements are inappropriate.\n \n+   --  d.j  Generate listing of frontend inlined calls and inline calls passed\n+   --       to the backend. This is useful to locate skipped calls that must be\n+   --       inlined by the frontend.\n+\n+   --  d.k  Enable new semantics of frontend inlining.  This is useful to test\n+   --       this new feature in all the platforms.\n+\n    --  d.l  Use Ada 95 semantics for limited function returns. This may be\n    --       used to work around the incompatibility introduced by AI-318-2.\n    --       It is useful only in -gnat05 mode."}, {"sha": "dff4e3e58bc0769baf1bbdd7aa125144272e4f46", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84f4072a8e1097b05597a62fb96f28f9c48f868a/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84f4072a8e1097b05597a62fb96f28f9c48f868a/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=84f4072a8e1097b05597a62fb96f28f9c48f868a", "patch": "@@ -3525,10 +3525,12 @@ package body Exp_Ch4 is\n       --  Processing for anonymous access-to-controlled types. These access\n       --  types receive a special finalization master which appears in the\n       --  declarations of the enclosing semantic unit. This expansion is done\n-      --  now to ensure that any additional types generated by this routine\n-      --  or Expand_Allocator_Expression inherit the proper type attributes.\n+      --  now to ensure that any additional types generated by this routine or\n+      --  Expand_Allocator_Expression inherit the proper type attributes.\n \n-      if Ekind (PtrT) = E_Anonymous_Access_Type\n+      if (Ekind (PtrT) = E_Anonymous_Access_Type\n+            or else\n+              (Is_Itype (PtrT) and then No (Finalization_Master (PtrT))))\n         and then Needs_Finalization (Dtyp)\n       then\n          --  Anonymous access-to-controlled types allocate on the global pool."}, {"sha": "1d43e523e0c9d433a6e4ed65d4ceade9acb40064", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 700, "deletions": 71, "changes": 771, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84f4072a8e1097b05597a62fb96f28f9c48f868a/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84f4072a8e1097b05597a62fb96f28f9c48f868a/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=84f4072a8e1097b05597a62fb96f28f9c48f868a", "patch": "@@ -51,6 +51,7 @@ with Namet;    use Namet;\n with Nlists;   use Nlists;\n with Nmake;    use Nmake;\n with Opt;      use Opt;\n+with Output;   use Output;\n with Restrict; use Restrict;\n with Rident;   use Rident;\n with Rtsfind;  use Rtsfind;\n@@ -69,6 +70,7 @@ with Sem_Res;  use Sem_Res;\n with Sem_SCIL; use Sem_SCIL;\n with Sem_Util; use Sem_Util;\n with Sinfo;    use Sinfo;\n+with Sinput;   use Sinput;\n with Snames;   use Snames;\n with Stand;    use Stand;\n with Targparm; use Targparm;\n@@ -78,6 +80,10 @@ with Validsw;  use Validsw;\n \n package body Exp_Ch6 is\n \n+   Inlined_Calls : Elist_Id := No_Elist;\n+   Backend_Calls : Elist_Id := No_Elist;\n+   --  List of frontend inlined calls and inline calls passed to the backend\n+\n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n@@ -1859,6 +1865,19 @@ package body Exp_Ch6 is\n       --  expression for the value of the actual, EF is the entity for the\n       --  extra formal.\n \n+      procedure Do_Inline (Subp : Entity_Id; Orig_Subp : Entity_Id);\n+      --  Check and inline the body of Subp. Invoked when compiling with\n+      --  optimizations enabled and Subp has pragma inline or inline always.\n+      --  If the subprogram is a renaming, or if it is inherited, then Subp\n+      --  references the renamed entity and Orig_Subp is the entity of the\n+      --  call node N.\n+\n+      procedure Do_Inline_Always (Subp : Entity_Id; Orig_Subp : Entity_Id);\n+      --  Check and inline the body of Subp. Invoked when compiling without\n+      --  optimizations and Subp has pragma inline always. If the subprogram is\n+      --  a renaming, or if it is inherited, then Subp references the renamed\n+      --  entity and Orig_Subp is the entity of the call node N.\n+\n       function Inherited_From_Formal (S : Entity_Id) return Entity_Id;\n       --  Within an instance, a type derived from a non-tagged formal derived\n       --  type inherits from the original parent, not from the actual. The\n@@ -1868,6 +1887,9 @@ package body Exp_Ch6 is\n       --  convoluted tree traversal before setting the proper subprogram to be\n       --  called.\n \n+      function In_Unfrozen_Instance (E : Entity_Id) return Boolean;\n+      --  Return true if E comes from an instance that is not yet frozen\n+\n       function Is_Direct_Deep_Call (Subp : Entity_Id) return Boolean;\n       --  Determine if Subp denotes a non-dispatching call to a Deep routine\n \n@@ -1942,6 +1964,228 @@ package body Exp_Ch6 is\n          end if;\n       end Add_Extra_Actual;\n \n+      ----------------\n+      --  Do_Inline --\n+      ----------------\n+\n+      procedure Do_Inline (Subp : Entity_Id; Orig_Subp : Entity_Id) is\n+         Spec : constant Node_Id := Unit_Declaration_Node (Subp);\n+\n+         procedure Do_Backend_Inline;\n+         --  Check that the call can be safely passed to the backend. If true\n+         --  then register the enclosing unit of Subp to Inlined_Bodies so that\n+         --  the body of Subp can be retrieved and analyzed by the backend.\n+\n+         procedure Register_Backend_Call (N : Node_Id);\n+         --  Append N to the list Backend_Calls\n+\n+         -----------------------\n+         -- Do_Backend_Inline --\n+         -----------------------\n+\n+         procedure Do_Backend_Inline is\n+         begin\n+            --  No extra test needed for init subprograms since we know they\n+            --  are available to the backend!\n+\n+            if Is_Init_Proc (Subp) then\n+               Add_Inlined_Body (Subp);\n+               Register_Backend_Call (Call_Node);\n+\n+            --  Verify that if the body to inline is located in the current\n+            --  unit the inlining does not occur earlier. This avoids\n+            --  order-of-elaboration problems in the back end.\n+\n+            elsif In_Same_Extended_Unit (Call_Node, Subp)\n+              and then Nkind (Spec) = N_Subprogram_Declaration\n+              and then Earlier_In_Extended_Unit\n+                         (Loc, Sloc (Body_To_Inline (Spec)))\n+            then\n+               Error_Msg_NE\n+                 (\"cannot inline& (body not seen yet)?\",\n+                  Call_Node, Subp);\n+\n+            else\n+               declare\n+                  Backend_Inline : Boolean := True;\n+\n+               begin\n+                  --  If we are compiling a package body that is not the\n+                  --  main unit, it must be for inlining/instantiation\n+                  --  purposes, in which case we inline the call to insure\n+                  --  that the same temporaries are generated when compiling\n+                  --  the body by itself. Otherwise link errors can occur.\n+\n+                  --  If the function being called is itself in the main\n+                  --  unit, we cannot inline, because there is a risk of\n+                  --  double elaboration and/or circularity: the inlining\n+                  --  can make visible a private entity in the body of the\n+                  --  main unit, that gigi will see before its sees its\n+                  --  proper definition.\n+\n+                  if not (In_Extended_Main_Code_Unit (Call_Node))\n+                    and then In_Package_Body\n+                  then\n+                     Backend_Inline :=\n+                       not In_Extended_Main_Source_Unit (Subp);\n+                  end if;\n+\n+                  if Backend_Inline then\n+                     Add_Inlined_Body (Subp);\n+                     Register_Backend_Call (Call_Node);\n+                  end if;\n+               end;\n+            end if;\n+         end Do_Backend_Inline;\n+\n+         ---------------------------\n+         -- Register_Backend_Call --\n+         ---------------------------\n+\n+         procedure Register_Backend_Call (N : Node_Id) is\n+         begin\n+            if Backend_Calls = No_Elist then\n+               Backend_Calls := New_Elmt_List;\n+            end if;\n+\n+            Append_Elmt (N, To => Backend_Calls);\n+         end Register_Backend_Call;\n+\n+      --  Start of processing for Do_Inline\n+\n+      begin\n+         --  Verify that the body to inline has already been seen\n+\n+         if No (Spec)\n+           or else Nkind (Spec) /= N_Subprogram_Declaration\n+           or else No (Body_To_Inline (Spec))\n+         then\n+            if Comes_From_Source (Subp)\n+              and then Must_Inline (Subp)\n+            then\n+               Cannot_Inline\n+                 (\"cannot inline& (body not seen yet)?\", Call_Node, Subp);\n+\n+            --  Let the back end handle it\n+\n+            else\n+               Do_Backend_Inline;\n+               return;\n+            end if;\n+\n+         --  If this an inherited function that returns a private type, do not\n+         --  inline if the full view is an unconstrained array, because such\n+         --  calls cannot be inlined.\n+\n+         elsif Present (Orig_Subp)\n+           and then Is_Array_Type (Etype (Orig_Subp))\n+           and then not Is_Constrained (Etype (Orig_Subp))\n+         then\n+            Cannot_Inline\n+              (\"cannot inline& (unconstrained array)?\", Call_Node, Subp);\n+\n+         else\n+            Expand_Inlined_Call (Call_Node, Subp, Orig_Subp);\n+         end if;\n+      end Do_Inline;\n+\n+      ----------------------\n+      -- Do_Inline_Always --\n+      ----------------------\n+\n+      procedure Do_Inline_Always (Subp : Entity_Id; Orig_Subp : Entity_Id) is\n+         Spec    : constant Node_Id := Unit_Declaration_Node (Subp);\n+         Body_Id : Entity_Id;\n+\n+      begin\n+         if No (Spec)\n+           or else Nkind (Spec) /= N_Subprogram_Declaration\n+           or else No (Body_To_Inline (Spec))\n+           or else Serious_Errors_Detected /= 0\n+         then\n+            return;\n+         end if;\n+\n+         Body_Id := Corresponding_Body (Spec);\n+\n+         --  Verify that the body to inline has already been seen\n+\n+         if No (Body_Id)\n+           or else not Analyzed (Body_Id)\n+         then\n+            Set_Is_Inlined (Subp, False);\n+\n+            if Comes_From_Source (Subp) then\n+\n+               --  Report a warning only if the call is located in the unit of\n+               --  the called subprogram; otherwise it is an error.\n+\n+               if not In_Same_Extended_Unit (Call_Node, Subp) then\n+                  Cannot_Inline\n+                    (\"cannot inline& (body not seen yet)\", Call_Node, Subp,\n+                     Is_Serious => True);\n+\n+               elsif In_Open_Scopes (Subp) then\n+\n+                  --  For backward compatibility we generate the same error\n+                  --  or warning of the previous implementation. This will\n+                  --  be changed when we definitely incorporate the new\n+                  --  support ???\n+\n+                  if Front_End_Inlining\n+                    and then Optimization_Level = 0\n+                  then\n+                     Error_Msg_N\n+                       (\"call to recursive subprogram cannot be inlined?\",\n+                        N);\n+\n+                  --  Do not emit error compiling runtime packages\n+\n+                  elsif Is_Predefined_File_Name\n+                    (Unit_File_Name (Get_Source_Unit (Subp)))\n+                  then\n+                     Error_Msg_N\n+                       (\"call to recursive subprogram cannot be inlined?\",\n+                        N);\n+\n+                  else\n+                     Error_Msg_N\n+                       (\"call to recursive subprogram cannot be inlined\",\n+                        N);\n+                  end if;\n+\n+               else\n+                  Cannot_Inline\n+                    (\"cannot inline& (body not seen yet)?\", Call_Node, Subp);\n+               end if;\n+            end if;\n+\n+            return;\n+\n+         --  If this an inherited function that returns a private type, do not\n+         --  inline if the full view is an unconstrained array, because such\n+         --  calls cannot be inlined.\n+\n+         elsif Present (Orig_Subp)\n+           and then Is_Array_Type (Etype (Orig_Subp))\n+           and then not Is_Constrained (Etype (Orig_Subp))\n+         then\n+            Cannot_Inline\n+              (\"cannot inline& (unconstrained array)?\", Call_Node, Subp);\n+\n+         --  If the called subprogram comes from an instance in the same\n+         --  unit, and the instance is not yet frozen, inlining might\n+         --  trigger order-of-elaboration problems.\n+\n+         elsif In_Unfrozen_Instance (Scope (Subp)) then\n+            Cannot_Inline\n+              (\"cannot inline& (unfrozen instance)?\", Call_Node, Subp);\n+\n+         else\n+            Expand_Inlined_Call (Call_Node, Subp, Orig_Subp);\n+         end if;\n+      end Do_Inline_Always;\n+\n       ---------------------------\n       -- Inherited_From_Formal --\n       ---------------------------\n@@ -2041,6 +2285,30 @@ package body Exp_Ch6 is\n          raise Program_Error;\n       end Inherited_From_Formal;\n \n+      --------------------------\n+      -- In_Unfrozen_Instance --\n+      --------------------------\n+\n+      function In_Unfrozen_Instance (E : Entity_Id) return Boolean is\n+         S : Entity_Id := E;\n+\n+      begin\n+         while Present (S)\n+           and then S /= Standard_Standard\n+         loop\n+            if Is_Generic_Instance (S)\n+              and then Present (Freeze_Node (S))\n+              and then not Analyzed (Freeze_Node (S))\n+            then\n+               return True;\n+            end if;\n+\n+            S := Scope (S);\n+         end loop;\n+\n+         return False;\n+      end In_Unfrozen_Instance;\n+\n       -------------------------\n       -- Is_Direct_Deep_Call --\n       -------------------------\n@@ -3431,45 +3699,14 @@ package body Exp_Ch6 is\n             return;\n          end if;\n \n-         if Is_Inlined (Subp) then\n+         --  Handle inlining (old semantics)\n+\n+         if Is_Inlined (Subp) and then not Debug_Flag_Dot_K then\n \n             Inlined_Subprogram : declare\n                Bod         : Node_Id;\n                Must_Inline : Boolean := False;\n                Spec        : constant Node_Id := Unit_Declaration_Node (Subp);\n-               Scop        : constant Entity_Id := Scope (Subp);\n-\n-               function In_Unfrozen_Instance return Boolean;\n-               --  If the subprogram comes from an instance in the same unit,\n-               --  and the instance is not yet frozen, inlining might trigger\n-               --  order-of-elaboration problems in gigi.\n-\n-               --------------------------\n-               -- In_Unfrozen_Instance --\n-               --------------------------\n-\n-               function In_Unfrozen_Instance return Boolean is\n-                  S : Entity_Id;\n-\n-               begin\n-                  S := Scop;\n-                  while Present (S)\n-                    and then S /= Standard_Standard\n-                  loop\n-                     if Is_Generic_Instance (S)\n-                       and then Present (Freeze_Node (S))\n-                       and then not Analyzed (Freeze_Node (S))\n-                     then\n-                        return True;\n-                     end if;\n-\n-                     S := Scope (S);\n-                  end loop;\n-\n-                  return False;\n-               end In_Unfrozen_Instance;\n-\n-            --  Start of processing for Inlined_Subprogram\n \n             begin\n                --  Verify that the body to inline has already been seen, and\n@@ -3495,7 +3732,7 @@ package body Exp_Ch6 is\n                then\n                   Must_Inline := False;\n \n-               elsif In_Unfrozen_Instance then\n+               elsif In_Unfrozen_Instance (Scope (Subp)) then\n                   Must_Inline := False;\n \n                else\n@@ -3549,6 +3786,38 @@ package body Exp_Ch6 is\n                   end if;\n                end if;\n             end Inlined_Subprogram;\n+\n+         --  Handle inlining (new semantics)\n+\n+         elsif Is_Inlined (Subp) then\n+            declare\n+               Spec : constant Node_Id := Unit_Declaration_Node (Subp);\n+\n+            begin\n+               if Optimization_Level > 0 then\n+                  Do_Inline (Subp, Orig_Subp);\n+\n+               elsif Must_Inline (Subp) then\n+                  if In_Extended_Main_Code_Unit (Call_Node)\n+                    and then In_Same_Extended_Unit (Sloc (Spec), Loc)\n+                    and then not Has_Completion (Subp)\n+                  then\n+                     Cannot_Inline\n+                       (\"cannot inline& (body not seen yet)?\",\n+                        Call_Node, Subp);\n+\n+                  else\n+                     Do_Inline_Always (Subp, Orig_Subp);\n+                  end if;\n+               end if;\n+\n+               --  The call may have been inlined or may have been passed to\n+               --  the backend. No further action needed if it was inlined.\n+\n+               if Nkind (N) /= N_Function_Call then\n+                  return;\n+               end if;\n+            end;\n          end if;\n       end if;\n \n@@ -3779,9 +4048,9 @@ package body Exp_Ch6 is\n       Remove_Side_Effects (N);\n    end Expand_Ctrl_Function_Call;\n \n-   --------------------------\n+   -------------------------\n    -- Expand_Inlined_Call --\n-   --------------------------\n+   -------------------------\n \n    procedure Expand_Inlined_Call\n     (N         : Node_Id;\n@@ -3796,7 +4065,6 @@ package body Exp_Ch6 is\n                     Body_To_Inline (Unit_Declaration_Node (Subp));\n \n       Blk      : Node_Id;\n-      Bod      : Node_Id;\n       Decl     : Node_Id;\n       Decls    : constant List_Id := New_List;\n       Exit_Lab : Entity_Id := Empty;\n@@ -3810,7 +4078,7 @@ package body Exp_Ch6 is\n \n       Targ : Node_Id;\n       --  The target of the call. If context is an assignment statement then\n-      --  this is the left-hand side of the assignment. else it is a temporary\n+      --  this is the left-hand side of the assignment; else it is a temporary\n       --  to which the return value is assigned prior to rewriting the call.\n \n       Targ1 : Node_Id;\n@@ -3822,9 +4090,8 @@ package body Exp_Ch6 is\n       Return_Object : Entity_Id := Empty;\n       --  Entity in declaration in an extended_return_statement\n \n-      Is_Unc : constant Boolean :=\n-                 Is_Array_Type (Etype (Subp))\n-                   and then not Is_Constrained (Etype (Subp));\n+      Is_Unc      : Boolean;\n+      Is_Unc_Decl : Boolean;\n       --  If the type returned by the function is unconstrained and the call\n       --  can be inlined, special processing is required.\n \n@@ -3845,6 +4112,12 @@ package body Exp_Ch6 is\n       --  Ada.Tags. If Debug_Generated_Code is true, suppress this change to\n       --  simplify our own development.\n \n+      procedure Reset_Dispatching_Calls (N : Node_Id);\n+      --  In subtree N search for occurrences of dispatching calls that use the\n+      --  Ada 2005 Object.Operation notation and the object is a formal of the\n+      --  inlined subprogram; in all the found occurrences reset the entity\n+      --  associated with Operation.\n+\n       procedure Rewrite_Function_Call (N : Node_Id; Blk : Node_Id);\n       --  If the function body is a single expression, replace call with\n       --  expression, else insert block appropriately.\n@@ -4023,6 +4296,13 @@ package body Exp_Ch6 is\n                   end if;\n \n                   Set_Assignment_OK (Name (Assign));\n+\n+                  if No (Handled_Statement_Sequence (N)) then\n+                     Set_Handled_Statement_Sequence (N,\n+                       Make_Handled_Sequence_Of_Statements (Loc,\n+                         Statements => New_List));\n+                  end if;\n+\n                   Prepend (Assign,\n                     Statements (Handled_Statement_Sequence (N)));\n                end if;\n@@ -4068,6 +4348,43 @@ package body Exp_Ch6 is\n \n       procedure Reset_Slocs is new Traverse_Proc (Process_Sloc);\n \n+      ------------------------------\n+      --  Reset_Dispatching_Calls --\n+      ------------------------------\n+\n+      procedure Reset_Dispatching_Calls (N : Node_Id) is\n+\n+         function Do_Reset (N : Node_Id) return Traverse_Result;\n+\n+         --------------\n+         -- Do_Check --\n+         --------------\n+\n+         function Do_Reset (N : Node_Id) return Traverse_Result is\n+         begin\n+            if Nkind (N) = N_Procedure_Call_Statement\n+              and then Nkind (Name (N)) = N_Selected_Component\n+              and then Nkind (Prefix (Name (N))) = N_Identifier\n+              and then Is_Formal (Entity (Prefix (Name (N))))\n+              and then Is_Dispatching_Operation\n+                         (Entity (Selector_Name (Name (N))))\n+            then\n+               Set_Entity (Selector_Name (Name (N)), Empty);\n+            end if;\n+\n+            return OK;\n+         end Do_Reset;\n+\n+         function Do_Reset_Calls is new Traverse_Func (Do_Reset);\n+\n+         --  Start of processing for Reset_Dispatching_Calls\n+\n+         Dummy : constant Traverse_Result := Do_Reset_Calls (N);\n+         pragma Unreferenced (Dummy);\n+      begin\n+         null;\n+      end Reset_Dispatching_Calls;\n+\n       ---------------------------\n       -- Rewrite_Function_Call --\n       ---------------------------\n@@ -4138,10 +4455,20 @@ package body Exp_Ch6 is\n             end;\n \n          elsif Nkind (Parent (N)) = N_Object_Declaration then\n-            Set_Expression (Parent (N), Empty);\n-            Insert_After (Parent (N), Blk);\n \n-         elsif Is_Unc then\n+            --  A call to a function which returns an unconstrained type\n+            --  found in the expression initializing an object-declaration is\n+            --  expanded into a procedure call which must be added after the\n+            --  object declaration.\n+\n+            if Is_Unc_Decl and then Debug_Flag_Dot_K then\n+               Insert_Action_After (Parent (N), Blk);\n+            else\n+               Set_Expression (Parent (N), Empty);\n+               Insert_After (Parent (N), Blk);\n+            end if;\n+\n+         elsif Is_Unc and then not Debug_Flag_Dot_K then\n             Insert_Before (Parent (N), Blk);\n          end if;\n       end Rewrite_Function_Call;\n@@ -4234,6 +4561,19 @@ package body Exp_Ch6 is\n    --  Start of processing for Expand_Inlined_Call\n \n    begin\n+      --  Initializations for old/new semantics\n+\n+      if not Debug_Flag_Dot_K then\n+         Is_Unc      := Is_Array_Type (Etype (Subp))\n+                          and then not Is_Constrained (Etype (Subp));\n+         Is_Unc_Decl := False;\n+      else\n+         Is_Unc      := Returns_Unconstrained_Type (Subp)\n+                          and then Optimization_Level > 0;\n+         Is_Unc_Decl := Nkind (Parent (N)) = N_Object_Declaration\n+                          and then Is_Unc;\n+      end if;\n+\n       --  Check for an illegal attempt to inline a recursive procedure. If the\n       --  subprogram has parameters this is detected when trying to supply a\n       --  binding for parameters that already have one. For parameterless\n@@ -4258,6 +4598,7 @@ package body Exp_Ch6 is\n         and then\n           Nkind (First (Statements (Handled_Statement_Sequence (Orig_Bod))))\n             = N_Extended_Return_Statement\n+        and then not Debug_Flag_Dot_K\n       then\n          return;\n       end if;\n@@ -4281,39 +4622,152 @@ package body Exp_Ch6 is\n          return;\n       end if;\n \n+      --  Register the call in the list of inlined calls\n+\n+      if Inlined_Calls = No_Elist then\n+         Inlined_Calls := New_Elmt_List;\n+      end if;\n+\n+      Append_Elmt (N, To => Inlined_Calls);\n+\n       --  Use generic machinery to copy body of inlined subprogram, as if it\n       --  were an instantiation, resetting source locations appropriately, so\n       --  that nested inlined calls appear in the main unit.\n \n       Save_Env (Subp, Empty);\n       Set_Copied_Sloc_For_Inlined_Body (N, Defining_Entity (Orig_Bod));\n \n-      Bod := Copy_Generic_Node (Orig_Bod, Empty, Instantiating => True);\n-      Blk :=\n-        Make_Block_Statement (Loc,\n-          Declarations => Declarations (Bod),\n-          Handled_Statement_Sequence => Handled_Statement_Sequence (Bod));\n+      --  Old semantics\n \n-      if No (Declarations (Bod)) then\n-         Set_Declarations (Blk, New_List);\n-      end if;\n+      if not Debug_Flag_Dot_K then\n+         declare\n+            Bod : Node_Id;\n+\n+         begin\n+            Bod := Copy_Generic_Node (Orig_Bod, Empty, Instantiating => True);\n+            Blk :=\n+              Make_Block_Statement (Loc,\n+                Declarations => Declarations (Bod),\n+                Handled_Statement_Sequence =>\n+                  Handled_Statement_Sequence (Bod));\n \n-      --  For the unconstrained case, capture the name of the local variable\n-      --  that holds the result. This must be the first declaration in the\n-      --  block, because its bounds cannot depend on local variables. Otherwise\n-      --  there is no way to declare the result outside of the block. Needless\n-      --  to say, in general the bounds will depend on the actuals in the call.\n+            if No (Declarations (Bod)) then\n+               Set_Declarations (Blk, New_List);\n+            end if;\n \n-      --  If the context is an assignment statement, as is the case for the\n-      --  expansion of an extended return, the left-hand side provides bounds\n-      --  even if the return type is unconstrained.\n+            --  For the unconstrained case, capture the name of the local\n+            --  variable that holds the result. This must be the first\n+            --  declaration in the block, because its bounds cannot depend\n+            --  on local variables. Otherwise there is no way to declare the\n+            --  result outside of the block. Needless to say, in general the\n+            --  bounds will depend on the actuals in the call.\n \n-      if Is_Unc then\n-         if Nkind (Parent (N)) /= N_Assignment_Statement then\n-            Targ1 := Defining_Identifier (First (Declarations (Blk)));\n-         else\n-            Targ1 := Name (Parent (N));\n-         end if;\n+            --  If the context is an assignment statement, as is the case\n+            --  for the expansion of an extended return, the left-hand side\n+            --  provides bounds even if the return type is unconstrained.\n+\n+            if Is_Unc then\n+               declare\n+                  First_Decl : Node_Id;\n+\n+               begin\n+                  First_Decl := First (Declarations (Blk));\n+\n+                  if Nkind (First_Decl) /= N_Object_Declaration then\n+                     return;\n+                  end if;\n+\n+                  if Nkind (Parent (N)) /= N_Assignment_Statement then\n+                     Targ1 := Defining_Identifier (First_Decl);\n+                  else\n+                     Targ1 := Name (Parent (N));\n+                  end if;\n+               end;\n+            end if;\n+         end;\n+\n+      --  New semantics\n+\n+      else\n+         declare\n+            Bod : Node_Id;\n+\n+         begin\n+            --  General case\n+\n+            if not Is_Unc then\n+               Bod :=\n+                 Copy_Generic_Node (Orig_Bod, Empty, Instantiating => True);\n+               Blk :=\n+                 Make_Block_Statement (Loc,\n+                                       Declarations => Declarations (Bod),\n+                                       Handled_Statement_Sequence =>\n+                                         Handled_Statement_Sequence (Bod));\n+\n+            --  Inline a call to a function that returns an unconstrained type.\n+            --  The semantic analyzer checked that frontend-inlined functions\n+            --  returning unconstrained types have no declarations and have\n+            --  a single extended return statement. As part of its processing\n+            --  the function was split in two subprograms: a procedure P and\n+            --  a function F that has a block with a call to procedure P (see\n+            --  Split_Unconstrained_Function).\n+\n+            else\n+               pragma Assert\n+                 (Nkind\n+                    (First\n+                       (Statements (Handled_Statement_Sequence (Orig_Bod))))\n+                  = N_Block_Statement);\n+\n+               declare\n+                  Blk_Stmt    : constant Node_Id :=\n+                    First\n+                      (Statements\n+                           (Handled_Statement_Sequence (Orig_Bod)));\n+                  First_Stmt  : constant Node_Id :=\n+                    First\n+                      (Statements\n+                           (Handled_Statement_Sequence (Blk_Stmt)));\n+                  Second_Stmt : constant Node_Id := Next (First_Stmt);\n+\n+               begin\n+                  pragma Assert\n+                    (Nkind (First_Stmt) = N_Procedure_Call_Statement\n+                       and then Nkind (Second_Stmt) = Sinfo.N_Return_Statement\n+                       and then No (Next (Second_Stmt)));\n+\n+                  Bod :=\n+                    Copy_Generic_Node\n+                      (First\n+                         (Statements (Handled_Statement_Sequence (Orig_Bod))),\n+                       Empty, Instantiating => True);\n+                  Blk := Bod;\n+\n+                  --  Capture the name of the local variable that holds the\n+                  --  result. This must be the first declaration in the block,\n+                  --  because its bounds cannot depend on local variables.\n+                  --  Otherwise there is no way to declare the result outside\n+                  --  of the block. Needless to say, in general the bounds will\n+                  --  depend on the actuals in the call.\n+\n+                  if Nkind (Parent (N)) /= N_Assignment_Statement then\n+                     Targ1 := Defining_Identifier (First (Declarations (Blk)));\n+\n+                  --  If the context is an assignment statement, as is the case\n+                  --  for the expansion of an extended return, the left-hand\n+                  --  side provides bounds even if the return type is\n+                  --  unconstrained.\n+\n+                  else\n+                     Targ1 := Name (Parent (N));\n+                  end if;\n+               end;\n+            end if;\n+\n+            if No (Declarations (Bod)) then\n+               Set_Declarations (Blk, New_List);\n+            end if;\n+         end;\n       end if;\n \n       --  If this is a derived function, establish the proper return type\n@@ -4483,6 +4937,16 @@ package body Exp_Ch6 is\n          then\n             Targ := Defining_Identifier (Parent (N));\n \n+         --  New semantics: In an object declaration avoid an extra copy\n+         --  of the result of a call to an inlined function that returns\n+         --  an unconstrained type\n+\n+         elsif Debug_Flag_Dot_K\n+           and then Nkind (Parent (N)) = N_Object_Declaration\n+           and then Is_Unc\n+         then\n+            Targ := Defining_Identifier (Parent (N));\n+\n          else\n             --  Replace call with temporary and create its declaration\n \n@@ -4523,6 +4987,80 @@ package body Exp_Ch6 is\n \n       Insert_Actions (N, Decls);\n \n+      if Is_Unc_Decl then\n+\n+         --  Special management for inlining a call to a function that returns\n+         --  an unconstrained type and initializes an object declaration: we\n+         --  avoid generating undesired extra calls and goto statements.\n+\n+         --     Given:\n+         --                 function Func (...) return ...\n+         --                 begin\n+         --                    declare\n+         --                       Result : String (1 .. 4);\n+         --                    begin\n+         --                       Proc (Result, ...);\n+         --                       return Result;\n+         --                    end;\n+         --                 end F;\n+\n+         --                 Result : String := Func (...);\n+\n+         --     Replace this object declaration by:\n+\n+         --                 Result : String (1 .. 4);\n+         --                 Proc (Result, ...);\n+\n+         Remove_Homonym (Targ);\n+\n+         Decl :=\n+           Make_Object_Declaration\n+             (Loc,\n+              Defining_Identifier => Targ,\n+              Object_Definition   =>\n+                New_Copy_Tree (Object_Definition (Parent (Targ1))));\n+         Replace_Formals (Decl);\n+         Rewrite (Parent (N), Decl);\n+         Analyze (Parent (N));\n+\n+         --  Avoid spurious warnings since we know that this declaration is\n+         --  referenced by the procedure call.\n+\n+         Set_Never_Set_In_Source (Targ, False);\n+\n+         --  Remove the local declaration of the extended return stmt from the\n+         --  inlined code\n+\n+         Remove (Parent (Targ1));\n+\n+         --  Update the reference to the result (since we have rewriten the\n+         --  object declaration)\n+\n+         declare\n+            Blk_Call_Stmt : Node_Id;\n+\n+         begin\n+            --  Capture the call to the procedure\n+\n+            Blk_Call_Stmt :=\n+              First (Statements (Handled_Statement_Sequence (Blk)));\n+            pragma Assert\n+              (Nkind (Blk_Call_Stmt) = N_Procedure_Call_Statement);\n+\n+            Remove (First (Parameter_Associations (Blk_Call_Stmt)));\n+            Prepend_To (Parameter_Associations (Blk_Call_Stmt),\n+              New_Reference_To (Targ, Loc));\n+         end;\n+\n+         --  Remove the return statement\n+\n+         pragma Assert\n+           (Nkind (Last (Statements (Handled_Statement_Sequence (Blk))))\n+            = Sinfo.N_Return_Statement);\n+\n+         Remove (Last (Statements (Handled_Statement_Sequence (Blk))));\n+      end if;\n+\n       --  Traverse the tree and replace formals with actuals or their thunks.\n       --  Attach block to tree before analysis and rewriting.\n \n@@ -4533,7 +5071,14 @@ package body Exp_Ch6 is\n          Reset_Slocs (Blk);\n       end if;\n \n-      if Present (Exit_Lab) then\n+      if Is_Unc_Decl then\n+\n+         --  No action needed since the return statement has been already\n+         --  removed!\n+\n+         null;\n+\n+      elsif Present (Exit_Lab) then\n \n          --  If the body was a single expression, the single return statement\n          --  and the corresponding label are useless.\n@@ -4564,8 +5109,18 @@ package body Exp_Ch6 is\n          if Is_Predef then\n             declare\n                Style : constant Boolean := Style_Check;\n+\n             begin\n                Style_Check := False;\n+\n+               --  Search for dispatching calls that use the Object.Operation\n+               --  notation using an Object that is a parameter of the inlined\n+               --  function. We reset the decoration of Operation to force\n+               --  the reanalysis of the inlined dispatching call because\n+               --  the actual object has been inlined.\n+\n+               Reset_Dispatching_Calls (Blk);\n+\n                Analyze (Blk, Suppress => All_Checks);\n                Style_Check := Style;\n             end;\n@@ -4583,11 +5138,14 @@ package body Exp_Ch6 is\n       else\n          Rewrite_Function_Call (N, Blk);\n \n+         if Is_Unc_Decl then\n+            null;\n+\n          --  For the unconstrained case, the replacement of the call has been\n          --  made prior to the complete analysis of the generated declarations.\n          --  Propagate the proper type now.\n \n-         if Is_Unc then\n+         elsif Is_Unc then\n             if Nkind (N) = N_Identifier then\n                Set_Etype (N, Etype (Entity (N)));\n             else\n@@ -5566,8 +6124,8 @@ package body Exp_Ch6 is\n       --  Alpha/VMS, no-op everywhere else).\n       --  Comes_From_Source intercepts recursive expansion.\n \n-      if Vax_Float (Etype (N))\n-        and then Nkind (N) = N_Function_Call\n+      if Nkind (N) = N_Function_Call\n+        and then Vax_Float (Etype (N))\n         and then Present (Name (N))\n         and then Present (Entity (Name (N)))\n         and then Has_Foreign_Convention (Entity (Name (N)))\n@@ -8642,4 +9200,75 @@ package body Exp_Ch6 is\n       end if;\n    end Needs_Result_Accessibility_Level;\n \n+   ------------------------\n+   -- List_Inlining_Info --\n+   ------------------------\n+\n+   procedure List_Inlining_Info is\n+      Elmt  : Elmt_Id;\n+      Nod   : Node_Id;\n+      Count : Nat;\n+\n+   begin\n+      if not Debug_Flag_Dot_J then\n+         return;\n+      end if;\n+\n+      --  Generate listing of calls inlined by the frontend\n+\n+      if Present (Inlined_Calls) then\n+         Count := 0;\n+         Elmt  := First_Elmt (Inlined_Calls);\n+         while Present (Elmt) loop\n+            Nod := Node (Elmt);\n+\n+            if In_Extended_Main_Code_Unit (Nod) then\n+               Count := Count + 1;\n+\n+               if Count = 1 then\n+                  Write_Str (\"Listing of frontend inlined calls\");\n+                  Write_Eol;\n+               end if;\n+\n+               Write_Str (\"  \");\n+               Write_Int (Count);\n+               Write_Str (\":\");\n+               Write_Location (Sloc (Nod));\n+               Write_Str (\":\");\n+               Output.Write_Eol;\n+            end if;\n+\n+            Next_Elmt (Elmt);\n+         end loop;\n+      end if;\n+\n+      --  Generate listing of calls passed to the backend\n+\n+      if Present (Backend_Calls) then\n+         Count := 0;\n+\n+         Elmt := First_Elmt (Backend_Calls);\n+         while Present (Elmt) loop\n+            Nod := Node (Elmt);\n+\n+            if In_Extended_Main_Code_Unit (Nod) then\n+               Count := Count + 1;\n+\n+               if Count = 1 then\n+                  Write_Str (\"Listing of inlined calls passed to the backend\");\n+                  Write_Eol;\n+               end if;\n+\n+               Write_Str (\"  \");\n+               Write_Int (Count);\n+               Write_Str (\":\");\n+               Write_Location (Sloc (Nod));\n+               Output.Write_Eol;\n+            end if;\n+\n+            Next_Elmt (Elmt);\n+         end loop;\n+      end if;\n+   end List_Inlining_Info;\n+\n end Exp_Ch6;"}, {"sha": "42ba07d20c28f05e2fb9b8b674c55c0746d7d375", "filename": "gcc/ada/exp_ch6.ads", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84f4072a8e1097b05597a62fb96f28f9c48f868a/gcc%2Fada%2Fexp_ch6.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84f4072a8e1097b05597a62fb96f28f9c48f868a/gcc%2Fada%2Fexp_ch6.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.ads?ref=84f4072a8e1097b05597a62fb96f28f9c48f868a", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -157,6 +157,10 @@ package Exp_Ch6 is\n    --  Predicate to recognize stubbed procedures and null procedures, which\n    --  can be inlined unconditionally in all cases.\n \n+   procedure List_Inlining_Info;\n+   --  Generate listing of calls inlined by the frontend plus listing of\n+   --  calls to inline subprograms passed to the backend.\n+\n    procedure Make_Build_In_Place_Call_In_Allocator\n      (Allocator     : Node_Id;\n       Function_Call : Node_Id);"}, {"sha": "7665c2bd39a3e8a45bf1818ebe5b8becafd98889", "filename": "gcc/ada/gnat1drv.adb", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84f4072a8e1097b05597a62fb96f28f9c48f868a/gcc%2Fada%2Fgnat1drv.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84f4072a8e1097b05597a62fb96f28f9c48f868a/gcc%2Fada%2Fgnat1drv.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat1drv.adb?ref=84f4072a8e1097b05597a62fb96f28f9c48f868a", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,6 +31,7 @@ with Debug;    use Debug;\n with Elists;\n with Errout;   use Errout;\n with Exp_CG;\n+with Exp_Ch6;  use Exp_Ch6;\n with Fmap;\n with Fname;    use Fname;\n with Fname.UF; use Fname.UF;\n@@ -1160,6 +1161,7 @@ begin\n       Errout.Finalize (Last_Call => True);\n       Errout.Output_Messages;\n       List_Rep_Info;\n+      List_Inlining_Info;\n \n       --  Only write the library if the backend did not generate any error\n       --  messages. Otherwise signal errors to the driver program so that"}, {"sha": "473553584dd77a34738e3799ab448c6484f3d3ee", "filename": "gcc/ada/inline.adb", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84f4072a8e1097b05597a62fb96f28f9c48f868a/gcc%2Fada%2Finline.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84f4072a8e1097b05597a62fb96f28f9c48f868a/gcc%2Fada%2Finline.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finline.adb?ref=84f4072a8e1097b05597a62fb96f28f9c48f868a", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -642,11 +642,9 @@ package body Inline is\n          end if;\n       end Is_Ancestor_Of_Main;\n \n-   --  Start of processing for  Analyze_Inlined_Bodies\n+   --  Start of processing for Analyze_Inlined_Bodies\n \n    begin\n-      Analyzing_Inlined_Bodies := False;\n-\n       if Serious_Errors_Detected = 0 then\n          Push_Scope (Standard_Standard);\n \n@@ -669,8 +667,8 @@ package body Inline is\n                Comp_Unit := Parent (Comp_Unit);\n             end loop;\n \n-            --  Load the body, unless it the main unit, or is an instance whose\n-            --  body has already been analyzed.\n+            --  Load the body, unless it is the main unit, or is an instance\n+            --  whose body has already been analyzed.\n \n             if Present (Comp_Unit)\n               and then Comp_Unit /= Cunit (Main_Unit)\n@@ -1035,7 +1033,6 @@ package body Inline is\n \n    procedure Initialize is\n    begin\n-      Analyzing_Inlined_Bodies := False;\n       Pending_Descriptor.Init;\n       Pending_Instantiations.Init;\n       Inlined_Bodies.Init;"}, {"sha": "63c043def68366b32e7825243b6432c467acbb92", "filename": "gcc/ada/inline.ads", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84f4072a8e1097b05597a62fb96f28f9c48f868a/gcc%2Fada%2Finline.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84f4072a8e1097b05597a62fb96f28f9c48f868a/gcc%2Fada%2Finline.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finline.ads?ref=84f4072a8e1097b05597a62fb96f28f9c48f868a", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -110,11 +110,6 @@ package Inline is\n      Table_Increment      => Alloc.Pending_Instantiations_Increment,\n      Table_Name           => \"Pending_Descriptor\");\n \n-   Analyzing_Inlined_Bodies : Boolean;\n-   --  This flag is set False by the call to Initialize, and then is set\n-   --  True by the call to Analyze_Inlined_Bodies. It is used to suppress\n-   --  generation of subprogram descriptors for inlined bodies.\n-\n    -----------------\n    -- Subprograms --\n    -----------------"}, {"sha": "5acd7dc6a3384118dc68a6608cc7adf96677fc32", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 44, "deletions": 1, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84f4072a8e1097b05597a62fb96f28f9c48f868a/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84f4072a8e1097b05597a62fb96f28f9c48f868a/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=84f4072a8e1097b05597a62fb96f28f9c48f868a", "patch": "@@ -25,6 +25,7 @@\n \n with Aspects;  use Aspects;\n with Atree;    use Atree;\n+with Debug;    use Debug;\n with Einfo;    use Einfo;\n with Elists;   use Elists;\n with Errout;   use Errout;\n@@ -3294,6 +3295,11 @@ package body Sem_Ch12 is\n       --  but it is simpler than detecting the need for the body at the point\n       --  of inlining, when the context of the instance is not available.\n \n+      function Must_Inline_Subp return Boolean;\n+      --  If inlining is active and the generic contains inlined subprograms,\n+      --  return True if some of the inlined subprograms must be inlined by\n+      --  the frontend.\n+\n       -----------------------\n       -- Delay_Descriptors --\n       -----------------------\n@@ -3333,6 +3339,34 @@ package body Sem_Ch12 is\n          return False;\n       end Might_Inline_Subp;\n \n+      ----------------------\n+      -- Must_Inline_Subp --\n+      ----------------------\n+\n+      function Must_Inline_Subp return Boolean is\n+         E : Entity_Id;\n+\n+      begin\n+         if not Inline_Processing_Required then\n+            return False;\n+\n+         else\n+            E := First_Entity (Gen_Unit);\n+            while Present (E) loop\n+               if Is_Subprogram (E)\n+                 and then Is_Inlined (E)\n+                 and then Must_Inline (E)\n+               then\n+                  return True;\n+               end if;\n+\n+               Next_Entity (E);\n+            end loop;\n+         end if;\n+\n+         return False;\n+      end Must_Inline_Subp;\n+\n       --  Local declarations\n \n       Vis_Prims_List : Elist_Id := No_Elist;\n@@ -3613,7 +3647,16 @@ package body Sem_Ch12 is\n               and then Might_Inline_Subp\n               and then not Is_Actual_Pack\n             then\n-               if Front_End_Inlining\n+               if not Debug_Flag_Dot_K\n+                 and then Front_End_Inlining\n+                 and then (Is_In_Main_Unit (N)\n+                            or else In_Main_Context (Current_Scope))\n+                 and then Nkind (Parent (N)) /= N_Compilation_Unit\n+               then\n+                  Inline_Now := True;\n+\n+               elsif Debug_Flag_Dot_K\n+                 and then Must_Inline_Subp\n                  and then (Is_In_Main_Unit (N)\n                             or else In_Main_Context (Current_Scope))\n                  and then Nkind (Parent (N)) /= N_Compilation_Unit"}, {"sha": "3e1059f59a3ece6a0c7388286e8cd468c622abf9", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84f4072a8e1097b05597a62fb96f28f9c48f868a/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84f4072a8e1097b05597a62fb96f28f9c48f868a/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=84f4072a8e1097b05597a62fb96f28f9c48f868a", "patch": "@@ -3163,6 +3163,24 @@ package body Sem_Ch3 is\n          Set_Etype (Id, T);\n          Resolve (E, T);\n \n+         --  No further action needed if E is a call to an inlined function\n+         --  which returns an unconstrained type and it has been expanded into\n+         --  a procedure call. In that case N has been replaced by an object\n+         --  declaration without initializing expression and it has been\n+         --  analyzed (see Expand_Inlined_Call).\n+\n+         if Debug_Flag_Dot_K\n+           and then Expander_Active\n+           and then Nkind (E) = N_Function_Call\n+           and then Nkind (Name (E)) in N_Has_Entity\n+           and then Is_Inlined (Entity (Name (E)))\n+           and then not Is_Constrained (Etype (E))\n+           and then Analyzed (N)\n+           and then No (Expression (N))\n+         then\n+            return;\n+         end if;\n+\n          --  If E is null and has been replaced by an N_Raise_Constraint_Error\n          --  node (which was marked already-analyzed), we need to set the type\n          --  to something other than Any_Access in order to keep gigi happy."}, {"sha": "42d7756db00e93df906e1e5dd43dbc7bfb7e9fc3", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84f4072a8e1097b05597a62fb96f28f9c48f868a/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84f4072a8e1097b05597a62fb96f28f9c48f868a/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=84f4072a8e1097b05597a62fb96f28f9c48f868a", "patch": "@@ -1852,7 +1852,13 @@ package body Sem_Ch5 is\n                if Nkind (Nam) = N_Explicit_Dereference then\n                   Subp := Etype (Nam);\n \n-               --  Normal case\n+               --  Call using a selected component notation or Ada 2005 object\n+               --  operation notation\n+\n+               elsif Nkind (Nam) = N_Selected_Component then\n+                  Subp := Entity (Selector_Name (Nam));\n+\n+               --  Common case\n \n                else\n                   Subp := Entity (Nam);"}, {"sha": "10d4a637a79f1cab3cad445b9eb493a1201a5965", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 1243, "deletions": 19, "changes": 1262, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84f4072a8e1097b05597a62fb96f28f9c48f868a/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84f4072a8e1097b05597a62fb96f28f9c48f868a/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=84f4072a8e1097b05597a62fb96f28f9c48f868a", "patch": "@@ -132,6 +132,15 @@ package body Sem_Ch6 is\n    function Can_Override_Operator (Subp : Entity_Id) return Boolean;\n    --  Returns true if Subp can override a predefined operator.\n \n+   procedure Check_And_Build_Body_To_Inline\n+     (N       : Node_Id;\n+      Spec_Id : Entity_Id;\n+      Body_Id : Entity_Id);\n+   --  Spec_Id and Body_Id are the entities of the specification and body of\n+   --  the subprogram body N. If N can be inlined by the frontend (supported\n+   --  cases documented in Check_Body_To_Inline) then build the body-to-inline\n+   --  associated with N and attach it to the declaration node of Spec_Id.\n+\n    procedure Check_Conformance\n      (New_Id                   : Entity_Id;\n       Old_Id                   : Entity_Id;\n@@ -2514,6 +2523,7 @@ package body Sem_Ch6 is\n \n       if Comes_From_Source (Body_Id)\n         and then Serious_Errors_Detected = 0\n+        and then not Debug_Flag_Dot_K\n       then\n          P_Ent := Body_Id;\n          loop\n@@ -2534,6 +2544,8 @@ package body Sem_Ch6 is\n          end loop;\n       end if;\n \n+      --  Look ahead to recognize a pragma inline that appears after the body\n+\n       Check_Inline_Pragma (Spec_Id);\n \n       --  Deal with special case of a fully private operation in the body of\n@@ -2842,14 +2854,31 @@ package body Sem_Ch6 is\n \n       if Nkind (N) = N_Subprogram_Body_Stub then\n          return;\n+      end if;\n \n-      elsif Present (Spec_Id)\n-        and then Expander_Active\n-        and then\n-          (Has_Pragma_Inline_Always (Spec_Id)\n-             or else (Has_Pragma_Inline (Spec_Id) and Front_End_Inlining))\n+      --  Handle frontend inlining. There is no need to prepare us for inlining\n+      --  if we will not generate the code.\n+\n+      --  Old semantics\n+\n+      if not Debug_Flag_Dot_K then\n+         if Present (Spec_Id)\n+           and then Expander_Active\n+           and then\n+             (Has_Pragma_Inline_Always (Spec_Id)\n+                or else (Has_Pragma_Inline (Spec_Id) and Front_End_Inlining))\n+         then\n+            Build_Body_To_Inline (N, Spec_Id);\n+         end if;\n+\n+      --  New semantics\n+\n+      elsif Expander_Active\n+        and then Serious_Errors_Detected = 0\n+        and then Present (Spec_Id)\n+        and then Has_Pragma_Inline (Spec_Id)\n       then\n-         Build_Body_To_Inline (N, Spec_Id);\n+         Check_And_Build_Body_To_Inline (N, Spec_Id, Body_Id);\n       end if;\n \n       --  Ada 2005 (AI-262): In library subprogram bodies, after the analysis\n@@ -4086,29 +4115,1224 @@ package body Sem_Ch6 is\n    -- Cannot_Inline --\n    -------------------\n \n-   procedure Cannot_Inline (Msg : String; N : Node_Id; Subp : Entity_Id) is\n+   procedure Cannot_Inline\n+     (Msg        : String;\n+      N          : Node_Id;\n+      Subp       : Entity_Id;\n+      Is_Serious : Boolean := False) is\n    begin\n-      --  Do not emit warning if this is a predefined unit which is not the\n-      --  main unit. With validity checks enabled, some predefined subprograms\n-      --  may contain nested subprograms and become ineligible for inlining.\n+      pragma Assert (Msg (Msg'Last) = '?');\n \n-      if Is_Predefined_File_Name (Unit_File_Name (Get_Source_Unit (Subp)))\n-        and then not In_Extended_Main_Source_Unit (Subp)\n-      then\n-         null;\n+      --  Old semantics\n+\n+      if not Debug_Flag_Dot_K then\n+\n+         --  Do not emit warning if this is a predefined unit which is not\n+         --  the main unit. With validity checks enabled, some predefined\n+         --  subprograms may contain nested subprograms and become ineligible\n+         --  for inlining.\n+\n+         if Is_Predefined_File_Name (Unit_File_Name (Get_Source_Unit (Subp)))\n+           and then not In_Extended_Main_Source_Unit (Subp)\n+         then\n+            null;\n+\n+         elsif Has_Pragma_Inline_Always (Subp) then\n+\n+            --  Remove last character (question mark) to make this into an\n+            --  error, because the Inline_Always pragma cannot be obeyed.\n+\n+            Error_Msg_NE (Msg (Msg'First .. Msg'Last - 1), N, Subp);\n+\n+         elsif Ineffective_Inline_Warnings then\n+            Error_Msg_NE (Msg, N, Subp);\n+         end if;\n+\n+         return;\n+\n+      --  New semantics\n \n-      elsif Has_Pragma_Inline_Always (Subp) then\n+      elsif Is_Serious then\n \n-         --  Remove last character (question mark) to make this into an error,\n-         --  because the Inline_Always pragma cannot be obeyed.\n+         --  Remove last character (question mark) to make this into an error.\n \n          Error_Msg_NE (Msg (Msg'First .. Msg'Last - 1), N, Subp);\n \n-      elsif Ineffective_Inline_Warnings then\n-         Error_Msg_NE (Msg, N, Subp);\n+      elsif Optimization_Level = 0 then\n+\n+         --  Do not emit warning if this is a predefined unit which is not\n+         --  the main unit. This behavior is currently provided for backward\n+         --  compatibility but it will be removed when we enforce the\n+         --  strictness of the new rules.\n+\n+         if Is_Predefined_File_Name (Unit_File_Name (Get_Source_Unit (Subp)))\n+           and then not In_Extended_Main_Source_Unit (Subp)\n+         then\n+            null;\n+\n+         elsif Has_Pragma_Inline_Always (Subp) then\n+\n+            --  Emit a warning if this is a call to a runtime subprogram\n+            --  which is located inside a generic. Previously this call\n+            --  was silently skipped!\n+\n+            if Is_Generic_Instance (Subp) then\n+               declare\n+                  Gen_P : constant Entity_Id := Generic_Parent (Parent (Subp));\n+               begin\n+                  if Is_Predefined_File_Name\n+                    (Unit_File_Name (Get_Source_Unit (Gen_P)))\n+                  then\n+                     Set_Is_Inlined (Subp, False);\n+                     Error_Msg_NE (Msg, N, Subp);\n+                     return;\n+                  end if;\n+               end;\n+            end if;\n+\n+            --  Remove last character (question mark) to make this into an\n+            --  error, because the Inline_Always pragma cannot be obeyed.\n+\n+            Error_Msg_NE (Msg (Msg'First .. Msg'Last - 1), N, Subp);\n+\n+         else pragma Assert (Front_End_Inlining);\n+            Set_Is_Inlined (Subp, False);\n+\n+            --  When inlining cannot take place we must issue an error.\n+            --  For backward compatibility we still report a warning.\n+\n+            if Ineffective_Inline_Warnings then\n+               Error_Msg_NE (Msg, N, Subp);\n+            end if;\n+         end if;\n+\n+      --  Compiling with optimizations enabled it is too early to report\n+      --  problems since the backend may still perform inlining. In order\n+      --  to report unhandled inlinings the program must be compiled with\n+      --  -Winline and the error is reported by the backend.\n+\n+      else\n+         null;\n       end if;\n    end Cannot_Inline;\n \n+   ------------------------------------\n+   -- Check_And_Build_Body_To_Inline --\n+   ------------------------------------\n+\n+   procedure Check_And_Build_Body_To_Inline\n+     (N       : Node_Id;\n+      Spec_Id : Entity_Id;\n+      Body_Id : Entity_Id)\n+   is\n+      procedure Build_Body_To_Inline (N : Node_Id; Spec_Id : Entity_Id);\n+      --  Use generic machinery to build an unexpanded body for the subprogram.\n+      --  This body is subsequently used for inline expansions at call sites.\n+\n+      function Can_Split_Unconstrained_Function (N : Node_Id) return Boolean;\n+      --  Return true if the function body N has no local declarations and its\n+      --  unique statement is a single extended return statement with a handled\n+      --  statements sequence.\n+\n+      function Check_Body_To_Inline\n+        (N    : Node_Id;\n+         Subp : Entity_Id) return Boolean;\n+      --  N is the N_Subprogram_Body of Subp. Return true if Subp can be\n+      --  inlined by the frontend. These are the rules:\n+      --    * At -O0 use fe inlining when inline_always is specified except if\n+      --      the function returns a controlled type.\n+      --    * At other optimization levels use the fe inlining for both inline\n+      --      and inline_always in the following cases:\n+      --       - function returning a known at compile time constant\n+      --       - function returning a call to an intrinsic function\n+      --       - function returning an unconstrained type (see Can_Split\n+      --         Unconstrained_Function).\n+      --       - function returning a call to a frontend-inlined function\n+      --      Use the back-end mechanism otherwise\n+      --\n+      --  In addition, in the following cases the function cannot be inlined by\n+      --  the frontend:\n+      --    - functions that uses the secondary stack\n+      --    - functions that have declarations of:\n+      --         - Concurrent types\n+      --         - Packages\n+      --         - Instantiations\n+      --         - Subprograms\n+      --    - functions that have some of the following statements:\n+      --         - abort\n+      --         - asynchronous-select\n+      --         - conditional-entry-call\n+      --         - delay-relative\n+      --         - delay-until\n+      --         - selective-accept\n+      --         - timed-entry-call\n+      --    - functions that have exception handlers\n+      --    - functions that have some enclosing body containing instantiations\n+      --      that appear before the corresponding generic body.\n+\n+      procedure Generate_Body_To_Inline\n+        (N              : Node_Id;\n+         Body_To_Inline : out Node_Id);\n+      --  Generate a parameterless duplicate of subprogram body N. Occurrences\n+      --  of pragmas referencing the formals are removed since they have no\n+      --  meaning when the body is inlined and the formals are rewritten (the\n+      --  analysis of the non-inlined body will handle these pragmas properly).\n+      --  A new internal name is associated with Body_To_Inline.\n+\n+      procedure Preanalyze (N : Node_Id);\n+      --  Performs a pre-analysis of node N. During pre-analysis no expansion\n+      --  is carried out for N or its children. For more info on pre-analysis\n+      --  read the spec of Sem.\n+\n+      procedure Split_Unconstrained_Function\n+        (N       : Node_Id;\n+         Spec_Id : Entity_Id);\n+      --  N is an inlined function body that returns an unconstrained type and\n+      --  has a single extended return statement. Split N in two subprograms:\n+      --  a procedure P' and a function F'. The formals of P' duplicate the\n+      --  formals of N plus an extra formal which is used return a value;\n+      --  its body is composed by the declarations and list of statements\n+      --  of the extended return statement of N.\n+\n+      --------------------------\n+      -- Build_Body_To_Inline --\n+      --------------------------\n+\n+      procedure Build_Body_To_Inline (N : Node_Id; Spec_Id : Entity_Id) is\n+         Decl            : constant Node_Id := Unit_Declaration_Node (Spec_Id);\n+         Original_Body   : Node_Id;\n+         Body_To_Analyze : Node_Id;\n+\n+      begin\n+         pragma Assert (Current_Scope = Spec_Id);\n+\n+         --  Within an instance, the body to inline must be treated as a nested\n+         --  generic, so that the proper global references are preserved. We\n+         --  do not do this at the library level, because it is not needed, and\n+         --  furthermore this causes trouble if front end inlining is activated\n+         --  (-gnatN).\n+\n+         if In_Instance\n+           and then Scope (Current_Scope) /= Standard_Standard\n+         then\n+            Save_Env (Scope (Current_Scope), Scope (Current_Scope));\n+         end if;\n+\n+         --  We need to capture references to the formals in order\n+         --  to substitute the actuals at the point of inlining, i.e.\n+         --  instantiation. To treat the formals as globals to the body to\n+         --  inline, we nest it within a dummy parameterless subprogram,\n+         --  declared within the real one.\n+\n+         Generate_Body_To_Inline (N, Original_Body);\n+         Body_To_Analyze := Copy_Generic_Node (Original_Body, Empty, False);\n+\n+         --  Set return type of function, which is also global and does not\n+         --  need to be resolved.\n+\n+         if Ekind (Spec_Id) = E_Function then\n+            Set_Result_Definition (Specification (Body_To_Analyze),\n+              New_Occurrence_Of (Etype (Spec_Id), Sloc (N)));\n+         end if;\n+\n+         if No (Declarations (N)) then\n+            Set_Declarations (N, New_List (Body_To_Analyze));\n+         else\n+            Append_To (Declarations (N), Body_To_Analyze);\n+         end if;\n+\n+         Preanalyze (Body_To_Analyze);\n+\n+         Push_Scope (Defining_Entity (Body_To_Analyze));\n+         Save_Global_References (Original_Body);\n+         End_Scope;\n+         Remove (Body_To_Analyze);\n+\n+         --  Restore environment if previously saved\n+\n+         if In_Instance\n+           and then Scope (Current_Scope) /= Standard_Standard\n+         then\n+            Restore_Env;\n+         end if;\n+\n+         pragma Assert (No (Body_To_Inline (Decl)));\n+         Set_Body_To_Inline (Decl, Original_Body);\n+         Set_Ekind (Defining_Entity (Original_Body), Ekind (Spec_Id));\n+      end Build_Body_To_Inline;\n+\n+      --------------------------\n+      -- Check_Body_To_Inline --\n+      --------------------------\n+\n+      function Check_Body_To_Inline\n+        (N    : Node_Id;\n+         Subp : Entity_Id) return Boolean\n+      is\n+         Max_Size   : constant := 10;\n+         Stat_Count : Integer := 0;\n+\n+         function Has_Excluded_Declaration (Decls : List_Id) return Boolean;\n+         --  Check for declarations that make inlining not worthwhile\n+\n+         function Has_Excluded_Statement   (Stats : List_Id) return Boolean;\n+         --  Check for statements that make inlining not worthwhile: any\n+         --  tasking statement, nested at any level. Keep track of total\n+         --  number of elementary statements, as a measure of acceptable size.\n+\n+         function Has_Pending_Instantiation return Boolean;\n+         --  Return True if some enclosing body contains instantiations that\n+         --  appear before the corresponding generic body.\n+\n+         function Returns_Compile_Time_Constant (N : Node_Id) return Boolean;\n+         --  Return True if all the return statements of the function body N\n+         --  are simple return statements and return a compile time constant\n+\n+         function Returns_Intrinsic_Function_Call (N : Node_Id) return Boolean;\n+         --  Return True if all the return statements of the function body N\n+         --  are simple return statements and return an intrinsic function call\n+\n+         function Uses_Secondary_Stack (N : Node_Id) return Boolean;\n+         --  If the body of the subprogram includes a call that returns an\n+         --  unconstrained type, the secondary stack is involved, and it\n+         --  is not worth inlining.\n+\n+         ------------------------------\n+         -- Has_Excluded_Declaration --\n+         ------------------------------\n+\n+         function Has_Excluded_Declaration (Decls : List_Id) return Boolean is\n+            D : Node_Id;\n+\n+            function Is_Unchecked_Conversion (D : Node_Id) return Boolean;\n+            --  Nested subprograms make a given body ineligible for inlining,\n+            --  but we make an exception for instantiations of unchecked\n+            --  conversion. The body has not been analyzed yet, so check the\n+            --  name, and verify that the visible entity with that name is the\n+            --  predefined unit.\n+\n+            -----------------------------\n+            -- Is_Unchecked_Conversion --\n+            -----------------------------\n+\n+            function Is_Unchecked_Conversion (D : Node_Id) return Boolean is\n+               Id   : constant Node_Id := Name (D);\n+               Conv : Entity_Id;\n+\n+            begin\n+               if Nkind (Id) = N_Identifier\n+                 and then Chars (Id) = Name_Unchecked_Conversion\n+               then\n+                  Conv := Current_Entity (Id);\n+\n+               elsif Nkind_In (Id, N_Selected_Component, N_Expanded_Name)\n+                 and then Chars (Selector_Name (Id))\n+                            = Name_Unchecked_Conversion\n+               then\n+                  Conv := Current_Entity (Selector_Name (Id));\n+               else\n+                  return False;\n+               end if;\n+\n+               return Present (Conv)\n+                 and then Is_Predefined_File_Name\n+                            (Unit_File_Name (Get_Source_Unit (Conv)))\n+                 and then Is_Intrinsic_Subprogram (Conv);\n+            end Is_Unchecked_Conversion;\n+\n+         --  Start of processing for Has_Excluded_Declaration\n+\n+         begin\n+            D := First (Decls);\n+            while Present (D) loop\n+               if (Nkind (D) = N_Function_Instantiation\n+                   and then not Is_Unchecked_Conversion (D))\n+                 or else Nkind_In (D, N_Protected_Type_Declaration,\n+                                   N_Package_Declaration,\n+                                   N_Package_Instantiation,\n+                                   N_Subprogram_Body,\n+                                   N_Procedure_Instantiation,\n+                                   N_Task_Type_Declaration)\n+               then\n+                  Cannot_Inline\n+                    (\"cannot inline & (non-allowed declaration)?\", D, Subp);\n+\n+                  return True;\n+               end if;\n+\n+               Next (D);\n+            end loop;\n+\n+            return False;\n+         end Has_Excluded_Declaration;\n+\n+         ----------------------------\n+         -- Has_Excluded_Statement --\n+         ----------------------------\n+\n+         function Has_Excluded_Statement (Stats : List_Id) return Boolean is\n+            S : Node_Id;\n+            E : Node_Id;\n+\n+         begin\n+            S := First (Stats);\n+            while Present (S) loop\n+               Stat_Count := Stat_Count + 1;\n+\n+               if Nkind_In (S, N_Abort_Statement,\n+                            N_Asynchronous_Select,\n+                            N_Conditional_Entry_Call,\n+                            N_Delay_Relative_Statement,\n+                            N_Delay_Until_Statement,\n+                            N_Selective_Accept,\n+                            N_Timed_Entry_Call)\n+               then\n+                  Cannot_Inline\n+                    (\"cannot inline & (non-allowed statement)?\", S, Subp);\n+                  return True;\n+\n+               elsif Nkind (S) = N_Block_Statement then\n+                  if Present (Declarations (S))\n+                    and then Has_Excluded_Declaration (Declarations (S))\n+                  then\n+                     return True;\n+\n+                  elsif Present (Handled_Statement_Sequence (S)) then\n+                     if Present\n+                       (Exception_Handlers (Handled_Statement_Sequence (S)))\n+                     then\n+                        Cannot_Inline\n+                          (\"cannot inline& (exception handler)?\",\n+                           First (Exception_Handlers\n+                             (Handled_Statement_Sequence (S))),\n+                           Subp);\n+                        return True;\n+\n+                     elsif Has_Excluded_Statement\n+                       (Statements (Handled_Statement_Sequence (S)))\n+                     then\n+                        return True;\n+                     end if;\n+                  end if;\n+\n+               elsif Nkind (S) = N_Case_Statement then\n+                  E := First (Alternatives (S));\n+                  while Present (E) loop\n+                     if Has_Excluded_Statement (Statements (E)) then\n+                        return True;\n+                     end if;\n+\n+                     Next (E);\n+                  end loop;\n+\n+               elsif Nkind (S) = N_If_Statement then\n+                  if Has_Excluded_Statement (Then_Statements (S)) then\n+                     return True;\n+                  end if;\n+\n+                  if Present (Elsif_Parts (S)) then\n+                     E := First (Elsif_Parts (S));\n+                     while Present (E) loop\n+                        if Has_Excluded_Statement (Then_Statements (E)) then\n+                           return True;\n+                        end if;\n+                        Next (E);\n+                     end loop;\n+                  end if;\n+\n+                  if Present (Else_Statements (S))\n+                    and then Has_Excluded_Statement (Else_Statements (S))\n+                  then\n+                     return True;\n+                  end if;\n+\n+               elsif Nkind (S) = N_Loop_Statement\n+                 and then Has_Excluded_Statement (Statements (S))\n+               then\n+                  return True;\n+\n+               elsif Nkind (S) = N_Extended_Return_Statement then\n+                  if Present (Handled_Statement_Sequence (S))\n+                    and then\n+                      Has_Excluded_Statement\n+                        (Statements (Handled_Statement_Sequence (S)))\n+                  then\n+                     return True;\n+\n+                  elsif Present (Handled_Statement_Sequence (S))\n+                    and then\n+                      Present (Exception_Handlers\n+                               (Handled_Statement_Sequence (S)))\n+                  then\n+                     Cannot_Inline\n+                       (\"cannot inline& (exception handler)?\",\n+                        First (Exception_Handlers\n+                          (Handled_Statement_Sequence (S))),\n+                        Subp);\n+                     return True;\n+                  end if;\n+               end if;\n+\n+               Next (S);\n+            end loop;\n+\n+            return False;\n+         end Has_Excluded_Statement;\n+\n+         -------------------------------\n+         -- Has_Pending_Instantiation --\n+         -------------------------------\n+\n+         function Has_Pending_Instantiation return Boolean is\n+            S : Entity_Id;\n+\n+         begin\n+            S := Current_Scope;\n+            while Present (S) loop\n+               if Is_Compilation_Unit (S)\n+                 or else Is_Child_Unit (S)\n+               then\n+                  return False;\n+\n+               elsif Ekind (S) = E_Package\n+                 and then Has_Forward_Instantiation (S)\n+               then\n+                  return True;\n+               end if;\n+\n+               S := Scope (S);\n+            end loop;\n+\n+            return False;\n+         end Has_Pending_Instantiation;\n+\n+         ------------------------------------\n+         --  Returns_Compile_Time_Constant --\n+         ------------------------------------\n+\n+         function Returns_Compile_Time_Constant (N : Node_Id) return Boolean is\n+\n+            function Check_Return (N : Node_Id) return Traverse_Result;\n+\n+            ------------------\n+            -- Check_Return --\n+            ------------------\n+\n+            function Check_Return (N : Node_Id) return Traverse_Result is\n+            begin\n+               if Nkind (N) = N_Extended_Return_Statement then\n+                  return Abandon;\n+\n+               elsif Nkind (N) = N_Simple_Return_Statement then\n+                  if Present (Expression (N)) then\n+                     declare\n+                        Orig_Expr : constant Node_Id :=\n+                          Original_Node (Expression (N));\n+\n+                     begin\n+                        if Nkind_In (Orig_Expr, N_Integer_Literal,\n+                                     N_Real_Literal,\n+                                     N_Character_Literal)\n+                        then\n+                           return OK;\n+\n+                        elsif Is_Entity_Name (Orig_Expr)\n+                          and then Ekind (Entity (Orig_Expr)) = E_Constant\n+                          and then Is_Static_Expression (Orig_Expr)\n+                        then\n+                           return OK;\n+                        else\n+                           return Abandon;\n+                        end if;\n+                     end;\n+\n+                  --  Expression has wrong form\n+\n+                  else\n+                     return Abandon;\n+                  end if;\n+\n+               --  Continue analyzing statements\n+\n+               else\n+                  return OK;\n+               end if;\n+            end Check_Return;\n+\n+            function Check_All_Returns is new Traverse_Func (Check_Return);\n+\n+            --  Start of processing for Returns_Compile_Time_Constant\n+\n+         begin\n+            return Check_All_Returns (N) = OK;\n+         end Returns_Compile_Time_Constant;\n+\n+         --------------------------------------\n+         --  Returns_Intrinsic_Function_Call --\n+         --------------------------------------\n+\n+         function Returns_Intrinsic_Function_Call\n+           (N : Node_Id) return Boolean\n+         is\n+            function Check_Return (N : Node_Id) return Traverse_Result;\n+\n+            ------------------\n+            -- Check_Return --\n+            ------------------\n+\n+            function Check_Return (N : Node_Id) return Traverse_Result is\n+            begin\n+               if Nkind (N) = N_Extended_Return_Statement then\n+                  return Abandon;\n+\n+               elsif Nkind (N) = N_Simple_Return_Statement then\n+                  if Present (Expression (N)) then\n+                     declare\n+                        Orig_Expr : constant Node_Id :=\n+                                      Original_Node (Expression (N));\n+\n+                     begin\n+                        if Nkind (Orig_Expr) in N_Op\n+                          and then Is_Intrinsic_Subprogram (Entity (Orig_Expr))\n+                        then\n+                           return OK;\n+\n+                        elsif Nkind (Orig_Expr) in N_Has_Entity\n+                          and then Present (Entity (Orig_Expr))\n+                          and then Ekind (Entity (Orig_Expr)) = E_Function\n+                          and then Is_Inlined (Entity (Orig_Expr))\n+                        then\n+                           return OK;\n+\n+                        elsif Nkind (Orig_Expr) in N_Has_Entity\n+                          and then Present (Entity (Orig_Expr))\n+                          and then Is_Intrinsic_Subprogram (Entity (Orig_Expr))\n+                        then\n+                           return OK;\n+\n+                        else\n+                           return Abandon;\n+                        end if;\n+                     end;\n+\n+                  --  Expression has wrong form\n+\n+                  else\n+                     return Abandon;\n+                  end if;\n+\n+               --  Continue analyzing statements\n+\n+               else\n+                  return OK;\n+               end if;\n+            end Check_Return;\n+\n+            function Check_All_Returns is new Traverse_Func (Check_Return);\n+\n+         --  Start of processing for Returns_Intrinsic_Function_Call\n+\n+         begin\n+            return Check_All_Returns (N) = OK;\n+         end Returns_Intrinsic_Function_Call;\n+\n+         --------------------------\n+         -- Uses_Secondary_Stack --\n+         --------------------------\n+\n+         function Uses_Secondary_Stack (N : Node_Id) return Boolean is\n+\n+            function Check_Call (N : Node_Id) return Traverse_Result;\n+            --  Look for function calls that return an unconstrained type\n+\n+            ----------------\n+            -- Check_Call --\n+            ----------------\n+\n+            function Check_Call (N : Node_Id) return Traverse_Result is\n+            begin\n+               if Nkind (N) = N_Function_Call\n+                 and then Is_Entity_Name (Name (N))\n+                 and then Is_Composite_Type (Etype (Entity (Name (N))))\n+                 and then not Is_Constrained (Etype (Entity (Name (N))))\n+               then\n+                  Cannot_Inline\n+                    (\"cannot inline & (call returns unconstrained type)?\",\n+                     N, Subp);\n+\n+                  return Abandon;\n+               else\n+                  return OK;\n+               end if;\n+            end Check_Call;\n+\n+            function Check_Calls is new Traverse_Func (Check_Call);\n+\n+         --  Start of processing for Uses_Secondary_Stack\n+\n+         begin\n+            return Check_Calls (N) = Abandon;\n+         end Uses_Secondary_Stack;\n+\n+         --  Local variables\n+\n+         Decl       : constant Node_Id := Unit_Declaration_Node (Spec_Id);\n+         May_Inline : constant Boolean :=\n+                        Has_Pragma_Inline_Always (Spec_Id)\n+                          or else (Has_Pragma_Inline (Spec_Id)\n+                                     and then ((Optimization_Level > 0\n+                                                  and then Ekind (Spec_Id)\n+                                                             = E_Function)\n+                                               or else Front_End_Inlining));\n+         Body_To_Analyze : Node_Id;\n+\n+      --  Start of processing for Check_Body_To_Inline\n+\n+      begin\n+         --  No action needed in stubs since the attribute Body_To_Inline\n+         --  is not available\n+\n+         if Nkind (Decl) = N_Subprogram_Body_Stub then\n+            return False;\n+\n+         --  Cannot build the body to inline if the attribute is already set.\n+         --  This attribute may have been set if this is a subprogram renaming\n+         --  declarations (see Freeze.Build_Renamed_Body).\n+\n+         elsif Present (Body_To_Inline (Decl)) then\n+            return False;\n+\n+         --  No action needed if the subprogram does not fulfill the minimum\n+         --  conditions to be inlined by the frontend\n+\n+         elsif not May_Inline then\n+            return False;\n+         end if;\n+\n+         --  Check excluded declarations\n+\n+         if Present (Declarations (N))\n+           and then Has_Excluded_Declaration (Declarations (N))\n+         then\n+            return False;\n+         end if;\n+\n+         --  Check excluded statements\n+\n+         if Present (Handled_Statement_Sequence (N)) then\n+            if Present\n+                 (Exception_Handlers (Handled_Statement_Sequence (N)))\n+            then\n+               Cannot_Inline\n+                 (\"cannot inline& (exception handler)?\",\n+                  First\n+                    (Exception_Handlers (Handled_Statement_Sequence (N))),\n+                  Subp);\n+\n+               return False;\n+\n+            elsif Has_Excluded_Statement\n+              (Statements (Handled_Statement_Sequence (N)))\n+            then\n+               return False;\n+            end if;\n+         end if;\n+\n+         --  For backward compatibility, compiling under -gnatN we do not\n+         --  inline a subprogram that is too large, unless it is marked\n+         --  Inline_Always. This pragma does not suppress the other checks\n+         --  on inlining (forbidden declarations, handlers, etc).\n+\n+         if Front_End_Inlining\n+           and then not Has_Pragma_Inline_Always (Subp)\n+           and then Stat_Count > Max_Size\n+         then\n+            Cannot_Inline (\"cannot inline& (body too large)?\", N, Subp);\n+            return False;\n+         end if;\n+\n+         --  If some enclosing body contains instantiations that appear before\n+         --  the corresponding generic body, the enclosing body has a freeze\n+         --  node so that it can be elaborated after the generic itself. This\n+         --  might conflict with subsequent inlinings, so that it is unsafe to\n+         --  try to inline in such a case.\n+\n+         if Has_Pending_Instantiation then\n+            Cannot_Inline\n+              (\"cannot inline& (forward instance within enclosing body)?\",\n+               N, Subp);\n+\n+            return False;\n+         end if;\n+\n+         --  Generate and preanalyze the body to inline (needed to perform\n+         --  the rest of the checks)\n+\n+         Generate_Body_To_Inline (N, Body_To_Analyze);\n+\n+         if Ekind (Subp) = E_Function then\n+            Set_Result_Definition (Specification (Body_To_Analyze),\n+              New_Occurrence_Of (Etype (Subp), Sloc (N)));\n+         end if;\n+\n+         --  Nest the body to analyze within the real one\n+\n+         if No (Declarations (N)) then\n+            Set_Declarations (N, New_List (Body_To_Analyze));\n+         else\n+            Append_To (Declarations (N), Body_To_Analyze);\n+         end if;\n+\n+         Preanalyze (Body_To_Analyze);\n+         Remove (Body_To_Analyze);\n+\n+         --  Keep separate checks needed when compiling without optimizations\n+\n+         if Optimization_Level = 0 then\n+\n+            --  Cannot inline functions whose body has a call that returns an\n+            --  unconstrained type since the secondary stack is involved, and\n+            --  it is not worth inlining.\n+\n+            if Uses_Secondary_Stack (Body_To_Analyze) then\n+               return False;\n+\n+            --  Cannot inline functions that return controlled types since\n+            --  controlled actions interfere in complex ways with inlining.\n+\n+            elsif Ekind (Subp) = E_Function\n+              and then Needs_Finalization (Etype (Subp))\n+            then\n+               Cannot_Inline\n+                 (\"cannot inline & (controlled return type)?\", N, Subp);\n+               return False;\n+\n+            elsif Returns_Unconstrained_Type (Subp) then\n+               Cannot_Inline\n+                 (\"cannot inline & (unconstrained return type)?\", N, Subp);\n+               return False;\n+            end if;\n+\n+         --  Compiling with optimizations enabled\n+\n+         else\n+            --  Procedures are never frontend inlined in this case!\n+\n+            if Ekind (Subp) /= E_Function then\n+               return False;\n+\n+            --  Functions returning unconstrained types are tested\n+            --  separately (see Can_Split_Unconstrained_Function).\n+\n+            elsif Returns_Unconstrained_Type (Subp) then\n+               null;\n+\n+            --  Check supported cases\n+\n+            elsif not Returns_Compile_Time_Constant (Body_To_Analyze)\n+              and then Convention (Subp) /= Convention_Intrinsic\n+              and then not Returns_Intrinsic_Function_Call (Body_To_Analyze)\n+            then\n+               return False;\n+            end if;\n+         end if;\n+\n+         return True;\n+      end Check_Body_To_Inline;\n+\n+      --------------------------------------\n+      -- Can_Split_Unconstrained_Function --\n+      --------------------------------------\n+\n+      function Can_Split_Unconstrained_Function (N : Node_Id) return Boolean\n+      is\n+         Ret_Node : constant Node_Id :=\n+                      First (Statements (Handled_Statement_Sequence (N)));\n+         D : Node_Id;\n+\n+      begin\n+         --  No user defined declarations allowed in the function except inside\n+         --  the unique return statement; implicit labels are the only allowed\n+         --  declarations.\n+\n+         if not Is_Empty_List (Declarations (N)) then\n+            D := First (Declarations (N));\n+            while Present (D) loop\n+               if Nkind (D) /= N_Implicit_Label_Declaration then\n+                  return False;\n+               end if;\n+\n+               Next (D);\n+            end loop;\n+         end if;\n+\n+         return Present (Ret_Node)\n+           and then Nkind (Ret_Node) = N_Extended_Return_Statement\n+           and then No (Next (Ret_Node))\n+           and then Present (Handled_Statement_Sequence (Ret_Node));\n+      end Can_Split_Unconstrained_Function;\n+\n+      -----------------------------\n+      -- Generate_Body_To_Inline --\n+      -----------------------------\n+\n+      procedure Generate_Body_To_Inline\n+        (N              : Node_Id;\n+         Body_To_Inline : out Node_Id)\n+      is\n+         procedure Remove_Pragmas (N : Node_Id);\n+         --  Remove occurrences of pragmas that may reference the formals of\n+         --  N. The analysis of the non-inlined body will handle these pragmas\n+         --  properly.\n+\n+         --------------------\n+         -- Remove_Pragmas --\n+         --------------------\n+\n+         procedure Remove_Pragmas (N : Node_Id) is\n+            Decl : Node_Id;\n+            Nxt  : Node_Id;\n+\n+         begin\n+            Decl := First (Declarations (N));\n+            while Present (Decl) loop\n+               Nxt := Next (Decl);\n+\n+               if Nkind (Decl) = N_Pragma\n+                 and then (Pragma_Name (Decl) = Name_Unreferenced\n+                           or else\n+                             Pragma_Name (Decl) = Name_Unmodified)\n+               then\n+                  Remove (Decl);\n+               end if;\n+\n+               Decl := Nxt;\n+            end loop;\n+         end Remove_Pragmas;\n+\n+      --  Start of processing for Generate_Body_To_Inline\n+\n+      begin\n+         --  Within an instance, the body to inline must be treated as a nested\n+         --  generic, so that the proper global references are preserved.\n+\n+         --  Note that we do not do this at the library level, because it\n+         --  is not needed, and furthermore this causes trouble if front\n+         --  end inlining is activated (-gnatN).\n+\n+         if In_Instance\n+           and then Scope (Current_Scope) /= Standard_Standard\n+         then\n+            Body_To_Inline := Copy_Generic_Node (N, Empty, True);\n+         else\n+            Body_To_Inline := Copy_Separate_Tree (N);\n+         end if;\n+\n+         --  A pragma Unreferenced or pragma Unmodified that mentions a formal\n+         --  parameter has no meaning when the body is inlined and the formals\n+         --  are rewritten. Remove it from body to inline. The analysis of the\n+         --  non-inlined body will handle the pragma properly.\n+\n+         Remove_Pragmas (Body_To_Inline);\n+\n+         --  We need to capture references to the formals in order\n+         --  to substitute the actuals at the point of inlining, i.e.\n+         --  instantiation. To treat the formals as globals to the body to\n+         --  inline, we nest it within a dummy parameterless subprogram,\n+         --  declared within the real one.\n+\n+         Set_Parameter_Specifications\n+           (Specification (Body_To_Inline), No_List);\n+\n+         --  A new internal name is associated with Body_To_Inline to avoid\n+         --  conflicts when the non-inlined body N is analyzed.\n+\n+         Set_Defining_Unit_Name (Specification (Body_To_Inline),\n+            Make_Defining_Identifier (Sloc (N), New_Internal_Name ('P')));\n+         Set_Corresponding_Spec (Body_To_Inline, Empty);\n+      end Generate_Body_To_Inline;\n+\n+      ----------------\n+      -- Preanalyze --\n+      ----------------\n+\n+      procedure Preanalyze (N : Node_Id) is\n+         Save_Full_Analysis : constant Boolean := Full_Analysis;\n+\n+      begin\n+         Full_Analysis := False;\n+         Expander_Mode_Save_And_Set (False);\n+\n+         Analyze (N);\n+\n+         Expander_Mode_Restore;\n+         Full_Analysis := Save_Full_Analysis;\n+      end Preanalyze;\n+\n+      ----------------------------------\n+      -- Split_Unconstrained_Function --\n+      ----------------------------------\n+\n+      procedure Split_Unconstrained_Function\n+        (N        : Node_Id;\n+         Spec_Id  : Entity_Id)\n+      is\n+         Loc      : constant Source_Ptr := Sloc (N);\n+         Ret_Node : constant Node_Id :=\n+                      First (Statements (Handled_Statement_Sequence (N)));\n+         Ret_Obj  : constant Node_Id :=\n+                      First (Return_Object_Declarations (Ret_Node));\n+\n+         procedure Build_Procedure\n+           (Proc_Id   : out Entity_Id;\n+            Decl_List : out List_Id);\n+         --  Build a procedure containing the statements found in the extended\n+         --  return statement of the unconstrained function body N.\n+\n+         procedure Build_Procedure\n+           (Proc_Id   : out Entity_Id;\n+            Decl_List : out List_Id)\n+         is\n+            Formal      : Entity_Id;\n+            Formal_List : constant List_Id := New_List;\n+            Proc_Spec   : Node_Id;\n+            Proc_Body   : Node_Id;\n+            Subp_Name   : constant Name_Id := New_Internal_Name ('F');\n+            Body_Decl_List : List_Id := No_List;\n+            Param_Type  : Node_Id;\n+\n+         begin\n+            if Nkind (Object_Definition (Ret_Obj)) = N_Identifier then\n+               Param_Type := New_Copy (Object_Definition (Ret_Obj));\n+            else\n+               Param_Type :=\n+                 New_Copy (Subtype_Mark (Object_Definition (Ret_Obj)));\n+            end if;\n+\n+            Append_To (Formal_List,\n+              Make_Parameter_Specification (Loc,\n+                Defining_Identifier =>\n+                  Make_Defining_Identifier (Loc,\n+                    Chars => Chars (Defining_Identifier (Ret_Obj))),\n+                In_Present  => False,\n+                Out_Present => True,\n+                Null_Exclusion_Present => False,\n+                Parameter_Type => Param_Type));\n+\n+            Formal := First_Formal (Spec_Id);\n+            while Present (Formal) loop\n+               Append_To (Formal_List,\n+                 Make_Parameter_Specification (Loc,\n+                   Defining_Identifier =>\n+                     Make_Defining_Identifier (Sloc (Formal),\n+                       Chars => Chars (Formal)),\n+                   In_Present  => In_Present (Parent (Formal)),\n+                   Out_Present => Out_Present (Parent (Formal)),\n+                   Null_Exclusion_Present =>\n+                     Null_Exclusion_Present (Parent (Formal)),\n+                   Parameter_Type =>\n+                     New_Reference_To (Etype (Formal), Loc),\n+                   Expression =>\n+                     Copy_Separate_Tree (Expression (Parent (Formal)))));\n+\n+               Next_Formal (Formal);\n+            end loop;\n+\n+            Proc_Id :=\n+              Make_Defining_Identifier (Loc, Chars => Subp_Name);\n+\n+            Proc_Spec :=\n+              Make_Procedure_Specification (Loc,\n+                Defining_Unit_Name => Proc_Id,\n+                Parameter_Specifications => Formal_List);\n+\n+            Decl_List := New_List;\n+\n+            Append_To (Decl_List,\n+              Make_Subprogram_Declaration (Loc, Proc_Spec));\n+\n+            --  Can_Convert_Unconstrained_Function checked that the function\n+            --  has no local declarations except implicit label declarations.\n+            --  Copy these declarations to the built procedure.\n+\n+            if Present (Declarations (N)) then\n+               Body_Decl_List := New_List;\n+\n+               declare\n+                  D     : Node_Id;\n+                  New_D : Node_Id;\n+\n+               begin\n+                  D := First (Declarations (N));\n+                  while Present (D) loop\n+                     pragma Assert (Nkind (D) = N_Implicit_Label_Declaration);\n+\n+                     New_D :=\n+                       Make_Implicit_Label_Declaration (Loc,\n+                         Make_Defining_Identifier (Loc,\n+                           Chars => Chars (Defining_Identifier (D))),\n+                         Label_Construct => Empty);\n+                     Append_To (Body_Decl_List, New_D);\n+\n+                     Next (D);\n+                  end loop;\n+               end;\n+            end if;\n+\n+            pragma Assert (Present (Handled_Statement_Sequence (Ret_Node)));\n+\n+            Proc_Body :=\n+              Make_Subprogram_Body (Loc,\n+                Specification => Copy_Separate_Tree (Proc_Spec),\n+                Declarations  => Body_Decl_List,\n+                Handled_Statement_Sequence =>\n+                  Copy_Separate_Tree (Handled_Statement_Sequence (Ret_Node)));\n+\n+            Set_Defining_Unit_Name (Specification (Proc_Body),\n+               Make_Defining_Identifier (Loc, Subp_Name));\n+\n+            Append_To (Decl_List, Proc_Body);\n+         end Build_Procedure;\n+\n+         --  Local variables\n+\n+         New_Obj   : constant Node_Id := Copy_Separate_Tree (Ret_Obj);\n+         Blk_Stmt  : Node_Id;\n+         Proc_Id   : Entity_Id;\n+         Proc_Call : Node_Id;\n+\n+      --  Start of processing for Split_Unconstrained_Function\n+\n+      begin\n+         --  Build the associated procedure, analyze it and insert it before\n+         --  the function body N\n+\n+         declare\n+            Scope     : constant Entity_Id := Current_Scope;\n+            Decl_List : List_Id;\n+         begin\n+            Pop_Scope;\n+            Build_Procedure (Proc_Id, Decl_List);\n+            Insert_Actions (N, Decl_List);\n+            Push_Scope (Scope);\n+         end;\n+\n+         --  Build the call to the generated procedure\n+\n+         declare\n+            Actual_List : constant List_Id := New_List;\n+            Formal      : Entity_Id;\n+\n+         begin\n+            Append_To (Actual_List,\n+              New_Reference_To (Defining_Identifier (New_Obj), Loc));\n+\n+            Formal := First_Formal (Spec_Id);\n+            while Present (Formal) loop\n+               Append_To (Actual_List, New_Reference_To (Formal, Loc));\n+\n+               --  Avoid spurious warning on unreferenced formals\n+\n+               Set_Referenced (Formal);\n+               Next_Formal (Formal);\n+            end loop;\n+\n+            Proc_Call :=\n+              Make_Procedure_Call_Statement (Loc,\n+                Name => New_Reference_To (Proc_Id, Loc),\n+                Parameter_Associations => Actual_List);\n+         end;\n+\n+         --  Generate\n+\n+         --    declare\n+         --       New_Obj : ...\n+         --    begin\n+         --       main_1__F1b (New_Obj, ...);\n+         --       return Obj;\n+         --    end B10b;\n+\n+         Blk_Stmt :=\n+           Make_Block_Statement (Loc,\n+             Declarations => New_List (New_Obj),\n+             Handled_Statement_Sequence =>\n+               Make_Handled_Sequence_Of_Statements (Loc,\n+                 Statements => New_List (\n+\n+                   Proc_Call,\n+\n+                   Make_Simple_Return_Statement (Loc,\n+                     Expression =>\n+                       New_Reference_To\n+                         (Defining_Identifier (New_Obj), Loc)))));\n+\n+         Rewrite (Ret_Node, Blk_Stmt);\n+      end Split_Unconstrained_Function;\n+\n+   --  Start of processing for Check_And_Build_Body_To_Inline\n+\n+   begin\n+      --  Do not inline any subprogram that contains nested subprograms, since\n+      --  the backend inlining circuit seems to generate uninitialized\n+      --  references in this case. We know this happens in the case of front\n+      --  end ZCX support, but it also appears it can happen in other cases as\n+      --  well. The backend often rejects attempts to inline in the case of\n+      --  nested procedures anyway, so little if anything is lost by this.\n+      --  Note that this is test is for the benefit of the back-end. There is\n+      --  a separate test for front-end inlining that also rejects nested\n+      --  subprograms.\n+\n+      --  Do not do this test if errors have been detected, because in some\n+      --  error cases, this code blows up, and we don't need it anyway if\n+      --  there have been errors, since we won't get to the linker anyway.\n+\n+      if Comes_From_Source (Body_Id)\n+        and then (Has_Pragma_Inline_Always (Spec_Id)\n+                    or else Optimization_Level > 0)\n+        and then Serious_Errors_Detected = 0\n+      then\n+         declare\n+            P_Ent : Node_Id;\n+\n+         begin\n+            P_Ent := Body_Id;\n+            loop\n+               P_Ent := Scope (P_Ent);\n+               exit when No (P_Ent) or else P_Ent = Standard_Standard;\n+\n+               if Is_Subprogram (P_Ent) then\n+                  Set_Is_Inlined (P_Ent, False);\n+\n+                  if Comes_From_Source (P_Ent)\n+                    and then Has_Pragma_Inline (P_Ent)\n+                  then\n+                     Cannot_Inline\n+                       (\"cannot inline& (nested subprogram)?\", N, P_Ent,\n+                        Is_Serious => True);\n+                  end if;\n+               end if;\n+            end loop;\n+         end;\n+      end if;\n+\n+      --  Build the body to inline only if really needed!\n+\n+      if Check_Body_To_Inline (N, Spec_Id)\n+        and then Serious_Errors_Detected = 0\n+      then\n+         if Returns_Unconstrained_Type (Spec_Id) then\n+            if Can_Split_Unconstrained_Function (N) then\n+               Split_Unconstrained_Function (N, Spec_Id);\n+               Build_Body_To_Inline (N, Spec_Id);\n+               Set_Is_Inlined (Spec_Id);\n+            end if;\n+         else\n+            Build_Body_To_Inline (N, Spec_Id);\n+            Set_Is_Inlined (Spec_Id);\n+         end if;\n+      end if;\n+   end Check_And_Build_Body_To_Inline;\n+\n    -----------------------\n    -- Check_Conformance --\n    -----------------------"}, {"sha": "7b38792d071c27918f07d21cf34d84453cdabc38", "filename": "gcc/ada/sem_ch6.ads", "status": "modified", "additions": 26, "deletions": 6, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84f4072a8e1097b05597a62fb96f28f9c48f868a/gcc%2Fada%2Fsem_ch6.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84f4072a8e1097b05597a62fb96f28f9c48f868a/gcc%2Fada%2Fsem_ch6.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.ads?ref=84f4072a8e1097b05597a62fb96f28f9c48f868a", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -50,13 +50,33 @@ package Sem_Ch6 is\n    --  and body declarations. Returns the defining entity for the\n    --  specification N.\n \n-   procedure Cannot_Inline (Msg : String; N : Node_Id; Subp : Entity_Id);\n+   procedure Cannot_Inline\n+     (Msg        : String;\n+      N          : Node_Id;\n+      Subp       : Entity_Id;\n+      Is_Serious : Boolean := False);\n    --  This procedure is called if the node N, an instance of a call to\n    --  subprogram Subp, cannot be inlined. Msg is the message to be issued,\n-   --  and has a ? as the last character. If Subp has a pragma Always_Inlined,\n-   --  then an error message is issued (by removing the last character of Msg).\n-   --  If Subp is not Always_Inlined, then a warning is issued if the flag\n-   --  Ineffective_Inline_Warnings is set, and if not, the call has no effect.\n+   --  and has a ? as the last character. Temporarily the behavior of this\n+   --  routine depends on the value of -gnatd.k:\n+   --    * If -gnatd.k is not set (ie. old inlining model) then if Subp has\n+   --      a pragma Always_Inlined, then an error message is issued (by\n+   --      removing the last character of Msg). If Subp is not Always_Inlined,\n+   --      then a warning is issued if the flag Ineffective_Inline_Warnings\n+   --      is set, and if not, the call has no effect.\n+   --    * If -gnatd.k is set (ie. new inlining model) then:\n+   --      - If Is_Serious is true, then an error is reported (by removing the\n+   --        last character of Msg);\n+   --      - otherwise:\n+   --        * Compiling without optimizations if Subp has a pragma\n+   --          Always_Inlined, then an error message is issued; if Subp is\n+   --          not Always_Inlined, then a warning is issued if the flag\n+   --          Ineffective_Inline_Warnings is set, and if not, the call\n+   --          has no effect.\n+   --        * Compiling with optimizations then a warning is issued if\n+   --          the flag Ineffective_Inline_Warnings is set; otherwise the\n+   --          call has no effect since inlining may be performed by the\n+   --          backend.\n \n    procedure Check_Conventions (Typ : Entity_Id);\n    --  Ada 2005 (AI-430): Check that the conventions of all inherited and"}, {"sha": "46a8b1948537ed7b70c528dff804303bd895b7f1", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84f4072a8e1097b05597a62fb96f28f9c48f868a/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84f4072a8e1097b05597a62fb96f28f9c48f868a/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=84f4072a8e1097b05597a62fb96f28f9c48f868a", "patch": "@@ -5611,6 +5611,15 @@ package body Sem_Res is\n         and then Has_Pragma_Inline_Always (Nam)\n         and then Nkind (Unit_Declaration_Node (Nam)) = N_Subprogram_Declaration\n         and then Present (Body_To_Inline (Unit_Declaration_Node (Nam)))\n+        and then not Debug_Flag_Dot_K\n+      then\n+         null;\n+\n+      elsif Is_Inlined (Nam)\n+        and then Has_Pragma_Inline (Nam)\n+        and then Nkind (Unit_Declaration_Node (Nam)) = N_Subprogram_Declaration\n+        and then Present (Body_To_Inline (Unit_Declaration_Node (Nam)))\n+        and then Debug_Flag_Dot_K\n       then\n          null;\n "}, {"sha": "9ce15c5c825cc9f8cce45e7d3987cd84df1bf666", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84f4072a8e1097b05597a62fb96f28f9c48f868a/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84f4072a8e1097b05597a62fb96f28f9c48f868a/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=84f4072a8e1097b05597a62fb96f28f9c48f868a", "patch": "@@ -9389,6 +9389,18 @@ package body Sem_Util is\n       Mark_Allocators (Root_Nod);\n    end Mark_Coextensions;\n \n+   -----------------\n+   -- Must_Inline --\n+   -----------------\n+\n+   function Must_Inline (Subp : Entity_Id) return Boolean is\n+   begin\n+      return Optimization_Level = 0\n+        and then Has_Pragma_Inline (Subp)\n+        and then (Has_Pragma_Inline_Always (Subp)\n+                    or else Front_End_Inlining);\n+   end Must_Inline;\n+\n    ----------------------\n    -- Needs_One_Actual --\n    ----------------------\n@@ -11767,6 +11779,18 @@ package body Sem_Util is\n       Reset_Analyzed (N);\n    end Reset_Analyzed_Flags;\n \n+   --------------------------------\n+   -- Returns_Unconstrained_Type --\n+   --------------------------------\n+\n+   function Returns_Unconstrained_Type (Subp : Entity_Id) return Boolean is\n+   begin\n+      return Ekind (Subp) = E_Function\n+        and then not Is_Scalar_Type (Etype (Subp))\n+        and then not Is_Access_Type (Etype (Subp))\n+        and then not Is_Constrained (Etype (Subp));\n+   end Returns_Unconstrained_Type;\n+\n    ---------------------------\n    -- Safe_To_Capture_Value --\n    ---------------------------"}, {"sha": "2ef728d4246270d1b797e88c0073b0f0a17e0113", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84f4072a8e1097b05597a62fb96f28f9c48f868a/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84f4072a8e1097b05597a62fb96f28f9c48f868a/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=84f4072a8e1097b05597a62fb96f28f9c48f868a", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -1115,6 +1115,9 @@ package Sem_Util is\n    --  to guarantee this in all cases. Note that it is more possible to give\n    --  correct answer if the tree is fully analyzed.\n \n+   function Must_Inline (Subp : Entity_Id) return Boolean;\n+   --  Return true if Subp must be inlined by the frontend\n+\n    function Needs_One_Actual (E : Entity_Id) return Boolean;\n    --  Returns True if a function has defaults for all but its first\n    --  formal. Used in Ada 2005 mode to solve the syntactic ambiguity that\n@@ -1307,6 +1310,9 @@ package Sem_Util is\n    procedure Reset_Analyzed_Flags (N : Node_Id);\n    --  Reset the Analyzed flags in all nodes of the tree whose root is N\n \n+   function Returns_Unconstrained_Type (Subp : Entity_Id) return Boolean;\n+   --  Return true if Subp is a function that returns an unconstrained type\n+\n    function Safe_To_Capture_Value\n      (N    : Node_Id;\n       Ent  : Entity_Id;"}]}