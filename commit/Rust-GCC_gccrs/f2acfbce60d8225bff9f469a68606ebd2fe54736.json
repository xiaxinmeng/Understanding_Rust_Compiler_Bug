{"sha": "f2acfbce60d8225bff9f469a68606ebd2fe54736", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjJhY2ZiY2U2MGQ4MjI1YmZmOWY0NjlhNjg2MDZlYmQyZmU1NDczNg==", "commit": {"author": {"name": "Claire Dross", "email": "dross@adacore.com", "date": "2017-04-27T12:55:29Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-04-27T12:55:29Z"}, "message": "a-cforma.adb, [...] (=): Generic parameter removed to allow the use of regular equality over elements in...\n\n2017-04-27  Claire Dross  <dross@adacore.com>\n\n\t* a-cforma.adb, a-cforma.ads (=): Generic parameter removed to\n\tallow the use of regular equality over elements in contracts.\n\t(Formal_Model): Ghost package containing model functions that\n\tare used in subprogram contracts.\n\t(Current_To_Last): Removed, model functions should be used instead.\n\t(First_To_Previous): Removed, model functions should be used instead.\n\t(Strict_Equal): Removed, model functions should be used instead.\n\t(No_Overlap): Removed, model functions should be used instead.\n\t* a-cofuma.adb, a-cofuma.ads (Enable_Handling_Of_Equivalence)\n\tBoolean generic parameter to disable contracts for equivalence\n\tbetween keys.\n\t(Witness): Create a witness of a key that is used for handling of\n\tequivalence between keys.\n\t(Has_Witness): Check whether a witness is contained in a map.\n\t(W_Get): Get the element associated to a witness.\n\t(Lift_Equivalent_Keys): Removed, equivalence between keys is handled\n\tdirectly.\n\t* a-cofuse.adb, a-cofuse.ads (Enable_Handling_Of_Equivalence)\n\tBoolean generic parameter to disable contracts for equivalence\n\tbetween keys.\n\t* a-cfhama.adb, a-cfhama.ads (Formal_Model.P) Disable handling\n\tof equivalence on functional maps.\n\t* a-cfdlli.adb, a-cfdlli.ads (Formal_Model.P) Disable handling\n\tof equivalence on functional maps.\n\nFrom-SVN: r247328", "tree": {"sha": "859e9ecb7473339706815e066f104967fe02abd9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/859e9ecb7473339706815e066f104967fe02abd9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f2acfbce60d8225bff9f469a68606ebd2fe54736", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2acfbce60d8225bff9f469a68606ebd2fe54736", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f2acfbce60d8225bff9f469a68606ebd2fe54736", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2acfbce60d8225bff9f469a68606ebd2fe54736/comments", "author": {"login": "clairedross", "id": 8180017, "node_id": "MDQ6VXNlcjgxODAwMTc=", "avatar_url": "https://avatars.githubusercontent.com/u/8180017?v=4", "gravatar_id": "", "url": "https://api.github.com/users/clairedross", "html_url": "https://github.com/clairedross", "followers_url": "https://api.github.com/users/clairedross/followers", "following_url": "https://api.github.com/users/clairedross/following{/other_user}", "gists_url": "https://api.github.com/users/clairedross/gists{/gist_id}", "starred_url": "https://api.github.com/users/clairedross/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/clairedross/subscriptions", "organizations_url": "https://api.github.com/users/clairedross/orgs", "repos_url": "https://api.github.com/users/clairedross/repos", "events_url": "https://api.github.com/users/clairedross/events{/privacy}", "received_events_url": "https://api.github.com/users/clairedross/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "12ead254ee6dbb32760593207417ca2ebcc2ef59", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12ead254ee6dbb32760593207417ca2ebcc2ef59", "html_url": "https://github.com/Rust-GCC/gccrs/commit/12ead254ee6dbb32760593207417ca2ebcc2ef59"}], "stats": {"total": 1453, "additions": 1181, "deletions": 272}, "files": [{"sha": "83b6596e5dbf4e9a4632c09412e3f8f170768c72", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2acfbce60d8225bff9f469a68606ebd2fe54736/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2acfbce60d8225bff9f469a68606ebd2fe54736/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=f2acfbce60d8225bff9f469a68606ebd2fe54736", "patch": "@@ -1,3 +1,30 @@\n+2017-04-27  Claire Dross  <dross@adacore.com>\n+\n+\t* a-cforma.adb, a-cforma.ads (=): Generic parameter removed to\n+\tallow the use of regular equality over elements in contracts.\n+\t(Formal_Model): Ghost package containing model functions that\n+\tare used in subprogram contracts.\n+\t(Current_To_Last): Removed, model functions should be used instead.\n+\t(First_To_Previous): Removed, model functions should be used instead.\n+\t(Strict_Equal): Removed, model functions should be used instead.\n+\t(No_Overlap): Removed, model functions should be used instead.\n+\t* a-cofuma.adb, a-cofuma.ads (Enable_Handling_Of_Equivalence)\n+\tBoolean generic parameter to disable contracts for equivalence\n+\tbetween keys.\n+\t(Witness): Create a witness of a key that is used for handling of\n+\tequivalence between keys.\n+\t(Has_Witness): Check whether a witness is contained in a map.\n+\t(W_Get): Get the element associated to a witness.\n+\t(Lift_Equivalent_Keys): Removed, equivalence between keys is handled\n+\tdirectly.\n+\t* a-cofuse.adb, a-cofuse.ads (Enable_Handling_Of_Equivalence)\n+\tBoolean generic parameter to disable contracts for equivalence\n+\tbetween keys.\n+\t* a-cfhama.adb, a-cfhama.ads (Formal_Model.P) Disable handling\n+\tof equivalence on functional maps.\n+\t* a-cfdlli.adb, a-cfdlli.ads (Formal_Model.P) Disable handling\n+\tof equivalence on functional maps.\n+\n 2017-04-27  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* exp_ch9.adb (Expand_Entry_Barrier): Code"}, {"sha": "0bd57bf99fe7a3238093d67e00705c2410fcf94f", "filename": "gcc/ada/a-cfdlli.ads", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2acfbce60d8225bff9f469a68606ebd2fe54736/gcc%2Fada%2Fa-cfdlli.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2acfbce60d8225bff9f469a68606ebd2fe54736/gcc%2Fada%2Fa-cfdlli.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cfdlli.ads?ref=f2acfbce60d8225bff9f469a68606ebd2fe54736", "patch": "@@ -151,9 +151,10 @@ is\n       pragma Annotate (GNATprove, Inline_For_Proof, M_Elements_Swapped);\n \n       package P is new Ada.Containers.Functional_Maps\n-        (Key_Type        => Cursor,\n-         Element_Type    => Positive_Count_Type,\n-         Equivalent_Keys => \"=\");\n+        (Key_Type                       => Cursor,\n+         Element_Type                   => Positive_Count_Type,\n+         Equivalent_Keys                => \"=\",\n+         Enable_Handling_Of_Equivalence => False);\n \n       function \"=\"\n         (Left  : P.Map;"}, {"sha": "533a3bf053d090d9a5adfff3c2aa9b755dd8b8aa", "filename": "gcc/ada/a-cfhama.ads", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2acfbce60d8225bff9f469a68606ebd2fe54736/gcc%2Fada%2Fa-cfhama.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2acfbce60d8225bff9f469a68606ebd2fe54736/gcc%2Fada%2Fa-cfhama.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cfhama.ads?ref=f2acfbce60d8225bff9f469a68606ebd2fe54736", "patch": "@@ -68,7 +68,7 @@ is\n                   Next        => Next,\n                   Has_Element => Has_Element,\n                   Element     => Key),\n-     Default_Initial_Condition => Is_Empty (Map) and Length (Map) = 0;\n+     Default_Initial_Condition => Is_Empty (Map);\n    pragma Preelaborable_Initialization (Map);\n \n    Empty_Map : constant Map;\n@@ -118,9 +118,10 @@ is\n          Right : K.Sequence) return Boolean renames K.\"<=\";\n \n       package P is new Ada.Containers.Functional_Maps\n-        (Key_Type        => Cursor,\n-         Element_Type    => Positive_Count_Type,\n-         Equivalent_Keys => \"=\");\n+        (Key_Type                       => Cursor,\n+         Element_Type                   => Positive_Count_Type,\n+         Equivalent_Keys                => \"=\",\n+         Enable_Handling_Of_Equivalence => False);\n \n       function \"=\"\n         (Left  : P.Map;\n@@ -262,7 +263,7 @@ is\n \n    function Is_Empty (Container : Map) return Boolean with\n      Global => null,\n-     Post   => Is_Empty'Result = M.Is_Empty (Model (Container));\n+     Post   => Is_Empty'Result = (Length (Container) = 0);\n \n    procedure Clear (Container : in out Map) with\n      Global => null,\n@@ -503,6 +504,12 @@ is\n                    Model (Container)'Old,\n                    Key)\n \n+            --  Key is inserted in Container\n+\n+            and K.Get (Keys (Container),\n+                       P.Get (Positions (Container), Find (Container, Key))) =\n+                Key\n+\n             --  Mapping from cursors to keys is preserved\n \n             and Mapping_Preserved"}, {"sha": "c54515bf5793f435bf656cb8cd4b7d1ef6961221", "filename": "gcc/ada/a-cforma.adb", "status": "modified", "additions": 192, "deletions": 131, "changes": 323, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2acfbce60d8225bff9f469a68606ebd2fe54736/gcc%2Fada%2Fa-cforma.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2acfbce60d8225bff9f469a68606ebd2fe54736/gcc%2Fada%2Fa-cforma.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cforma.adb?ref=f2acfbce60d8225bff9f469a68606ebd2fe54736", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2010-2015, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2010-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -324,34 +324,6 @@ is\n       end return;\n    end Copy;\n \n-   ---------------------\n-   -- Current_To_Last --\n-   ---------------------\n-\n-   function Current_To_Last (Container : Map; Current : Cursor) return Map is\n-      Curs : Cursor := First (Container);\n-      C    : Map (Container.Capacity) := Copy (Container, Container.Capacity);\n-      Node : Count_Type;\n-\n-   begin\n-      if Curs = No_Element then\n-         Clear (C);\n-         return C;\n-\n-      elsif Current /= No_Element and not Has_Element (Container, Current) then\n-         raise Constraint_Error;\n-\n-      else\n-         while Curs.Node /= Current.Node loop\n-            Node := Curs.Node;\n-            Delete (C, Curs);\n-            Curs := Next (Container, (Node => Node));\n-         end loop;\n-\n-         return C;\n-      end if;\n-   end Current_To_Last;\n-\n    ------------\n    -- Delete --\n    ------------\n@@ -369,6 +341,7 @@ is\n       Tree_Operations.Delete_Node_Sans_Free (Container,\n                                              Position.Node);\n       Formal_Ordered_Maps.Free (Container, Position.Node);\n+      Position := No_Element;\n    end Delete;\n \n    procedure Delete (Container : in out Map; Key : Key_Type) is\n@@ -520,36 +493,6 @@ is\n       return Container.Nodes (First (Container).Node).Key;\n    end First_Key;\n \n-   -----------------------\n-   -- First_To_Previous --\n-   -----------------------\n-\n-   function First_To_Previous\n-     (Container : Map;\n-      Current   : Cursor) return Map\n-   is\n-      Curs : Cursor := Current;\n-      C    : Map (Container.Capacity) := Copy (Container, Container.Capacity);\n-      Node : Count_Type;\n-\n-   begin\n-      if Curs = No_Element then\n-         return C;\n-\n-      elsif not Has_Element (Container, Curs) then\n-         raise Constraint_Error;\n-\n-      else\n-         while Curs.Node /= 0 loop\n-            Node := Curs.Node;\n-            Delete (C, Curs);\n-            Curs := Next (Container, (Node => Node));\n-         end loop;\n-\n-         return C;\n-      end if;\n-   end First_To_Previous;\n-\n    -----------\n    -- Floor --\n    -----------\n@@ -565,6 +508,196 @@ is\n       return (Node => Node);\n    end Floor;\n \n+   ------------------\n+   -- Formal_Model --\n+   ------------------\n+\n+   package body Formal_Model is\n+\n+      -------------------------\n+      -- K_Bigger_Than_Range --\n+      -------------------------\n+\n+      function K_Bigger_Than_Range\n+        (Container : K.Sequence;\n+         Fst       : Positive_Count_Type;\n+         Lst       : Count_Type;\n+         Key       : Key_Type) return Boolean\n+      is\n+      begin\n+         for I in Fst .. Lst loop\n+            if not (K.Get (Container, I) < Key) then\n+               return False;\n+            end if;\n+         end loop;\n+         return True;\n+      end K_Bigger_Than_Range;\n+\n+      ---------------\n+      -- K_Is_Find --\n+      ---------------\n+\n+      function K_Is_Find\n+        (Container : K.Sequence;\n+         Key       : Key_Type;\n+         Position  : Count_Type) return Boolean\n+      is\n+      begin\n+         for I in 1 .. Position - 1 loop\n+            if Key < K.Get (Container, I) then\n+               return False;\n+            end if;\n+         end loop;\n+\n+         if Position < K.Length (Container) then\n+            for I in Position + 1 .. K.Length (Container) loop\n+               if K.Get (Container, I) < Key then\n+                  return False;\n+               end if;\n+            end loop;\n+         end if;\n+         return True;\n+      end K_Is_Find;\n+\n+      --------------------------\n+      -- K_Smaller_Than_Range --\n+      --------------------------\n+\n+      function K_Smaller_Than_Range\n+        (Container : K.Sequence;\n+         Fst       : Positive_Count_Type;\n+         Lst       : Count_Type;\n+         Key       : Key_Type) return Boolean\n+      is\n+      begin\n+         for I in Fst .. Lst loop\n+            if not (Key < K.Get (Container, I)) then\n+               return False;\n+            end if;\n+         end loop;\n+         return True;\n+      end K_Smaller_Than_Range;\n+\n+      ----------\n+      -- Keys --\n+      ----------\n+\n+      function Keys (Container : Map) return K.Sequence is\n+         Position : Count_Type := Container.First;\n+         R        : K.Sequence;\n+\n+      begin\n+         --  Can't use First, Next or Element here, since they depend on models\n+         --  for their postconditions.\n+\n+         while Position /= 0 loop\n+            R := K.Add (R, Container.Nodes (Position).Key);\n+            Position := Tree_Operations.Next (Container, Position);\n+         end loop;\n+\n+         return R;\n+      end Keys;\n+\n+      ----------------------------\n+      -- Lift_Abstraction_Level --\n+      ----------------------------\n+\n+      procedure Lift_Abstraction_Level (Container : Map) is null;\n+\n+      -----------\n+      -- Model --\n+      -----------\n+\n+      function Model (Container : Map) return M.Map is\n+         Position : Count_Type := Container.First;\n+         R        : M.Map;\n+\n+      begin\n+         --  Can't use First, Next or Element here, since they depend on models\n+         --  for their postconditions.\n+\n+         while Position /= 0 loop\n+            R := M.Add (Container => R,\n+                        New_Key   => Container.Nodes (Position).Key,\n+                        New_Item  => Container.Nodes (Position).Element);\n+            Position := Tree_Operations.Next (Container, Position);\n+         end loop;\n+\n+         return R;\n+      end Model;\n+\n+      -------------------------\n+      -- P_Positions_Shifted --\n+      -------------------------\n+\n+      function P_Positions_Shifted\n+        (Small : P.Map;\n+         Big   : P.Map;\n+         Cut   : Positive_Count_Type;\n+         Count : Count_Type := 1) return Boolean\n+      is\n+      begin\n+         for Cu of Small loop\n+            if not P.Has_Key (Big, Cu) then\n+               return False;\n+            end if;\n+         end loop;\n+\n+         for Cu of Big loop\n+            declare\n+               Pos : constant Positive_Count_Type := P.Get (Big, Cu);\n+\n+            begin\n+               if Pos < Cut then\n+                  if not P.Has_Key (Small, Cu)\n+                    or else Pos /= P.Get (Small, Cu)\n+                  then\n+                     return False;\n+                  end if;\n+\n+               elsif Pos >= Cut + Count then\n+                  if not P.Has_Key (Small, Cu)\n+                    or else Pos /= P.Get (Small, Cu) + Count\n+                  then\n+                     return False;\n+                  end if;\n+\n+               else\n+                  if P.Has_Key (Small, Cu) then\n+                     return False;\n+                  end if;\n+               end if;\n+            end;\n+         end loop;\n+\n+         return True;\n+      end P_Positions_Shifted;\n+\n+      ---------------\n+      -- Positions --\n+      ---------------\n+\n+      function Positions (Container : Map) return P.Map is\n+         I        : Count_Type := 1;\n+         Position : Count_Type := Container.First;\n+         R        : P.Map;\n+\n+      begin\n+         --  Can't use First, Next or Element here, since they depend on models\n+         --  for their postconditions.\n+\n+         while Position /= 0 loop\n+            R := P.Add (R, (Node => Position), I);\n+            pragma Assert (P.Length (R) = I);\n+            Position := Tree_Operations.Next (Container, Position);\n+            I := I + 1;\n+         end loop;\n+\n+         return R;\n+      end Positions;\n+\n+   end Formal_Model;\n+\n    ----------\n    -- Free --\n    ----------\n@@ -864,47 +997,6 @@ is\n       return (Node => Tree_Operations.Next (Container, Position.Node));\n    end Next;\n \n-   -------------\n-   -- Overlap --\n-   -------------\n-\n-   function Overlap (Left, Right : Map) return Boolean is\n-   begin\n-      if Length (Left) = 0 or Length (Right) = 0 then\n-         return False;\n-      end if;\n-\n-      declare\n-         L_Node : Count_Type          := First (Left).Node;\n-         R_Node : Count_Type          := First (Right).Node;\n-         L_Last : constant Count_Type := Next (Left, Last (Left).Node);\n-         R_Last : constant Count_Type := Next (Right, Last (Right).Node);\n-\n-      begin\n-         if Left'Address = Right'Address then\n-            return True;\n-         end if;\n-\n-         loop\n-            if L_Node = L_Last\n-              or else R_Node = R_Last\n-            then\n-               return False;\n-            end if;\n-\n-            if Left.Nodes (L_Node).Key < Right.Nodes (R_Node).Key then\n-               L_Node := Next (Left, L_Node);\n-\n-            elsif Right.Nodes (R_Node).Key < Left.Nodes (L_Node).Key then\n-               R_Node := Next (Right, R_Node);\n-\n-            else\n-               return True;\n-            end if;\n-         end loop;\n-      end;\n-   end Overlap;\n-\n    ------------\n    -- Parent --\n    ------------\n@@ -1042,35 +1134,4 @@ is\n       Node.Right := Right;\n    end Set_Right;\n \n-   ------------------\n-   -- Strict_Equal --\n-   ------------------\n-\n-   function Strict_Equal (Left, Right : Map) return Boolean is\n-      LNode : Count_Type := First (Left).Node;\n-      RNode : Count_Type := First (Right).Node;\n-\n-   begin\n-      if Length (Left) /= Length (Right) then\n-         return False;\n-      end if;\n-\n-      while LNode = RNode loop\n-         if LNode = 0 then\n-            return True;\n-         end if;\n-\n-         if Left.Nodes (LNode).Element /= Right.Nodes (RNode).Element\n-           or else Left.Nodes (LNode).Key /= Right.Nodes (RNode).Key\n-         then\n-            exit;\n-         end if;\n-\n-         LNode := Next (Left, LNode);\n-         RNode := Next (Right, RNode);\n-      end loop;\n-\n-      return False;\n-   end Strict_Equal;\n-\n end Ada.Containers.Formal_Ordered_Maps;"}, {"sha": "7999e2ec3ec7a4e197c6e457b42d4b2197c4c809", "filename": "gcc/ada/a-cforma.ads", "status": "modified", "additions": 849, "deletions": 98, "changes": 947, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2acfbce60d8225bff9f469a68606ebd2fe54736/gcc%2Fada%2Fa-cforma.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2acfbce60d8225bff9f469a68606ebd2fe54736/gcc%2Fada%2Fa-cforma.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cforma.ads?ref=f2acfbce60d8225bff9f469a68606ebd2fe54736", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2004-2015, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -46,93 +46,352 @@\n --    container. The operators \"<\" and \">\" that could not be modified that way\n --    have been removed.\n \n---    There are four new functions:\n-\n---      function Strict_Equal (Left, Right : Map) return Boolean;\n---      function Overlap (Left, Right : Map) return Boolean;\n---      function First_To_Previous  (Container : Map; Current : Cursor)\n---         return Map;\n---      function Current_To_Last (Container : Map; Current : Cursor)\n---         return Map;\n-\n---    See detailed specifications for these subprograms\n+--  Iteration over maps is done using the Iterable aspect, which is SPARK\n+--  compatible. \"For of\" iteration ranges over keys instead of elements.\n \n+with Ada.Containers.Functional_Vectors;\n+with Ada.Containers.Functional_Maps;\n private with Ada.Containers.Red_Black_Trees;\n \n generic\n    type Key_Type is private;\n    type Element_Type is private;\n \n    with function \"<\" (Left, Right : Key_Type) return Boolean is <>;\n-   with function \"=\" (Left, Right : Element_Type) return Boolean is <>;\n \n package Ada.Containers.Formal_Ordered_Maps with\n-  Pure,\n   SPARK_Mode\n is\n-   pragma Annotate (GNATprove, External_Axiomatization);\n    pragma Annotate (CodePeer, Skip_Analysis);\n \n    function Equivalent_Keys (Left, Right : Key_Type) return Boolean with\n-     Global => null;\n+     Global => null,\n+     Post   =>\n+       Equivalent_Keys'Result = (not (Left < Right) and not (Right < Left));\n+   pragma Annotate (GNATprove, Inline_For_Proof, Equivalent_Keys);\n \n    type Map (Capacity : Count_Type) is private with\n      Iterable => (First       => First,\n                   Next        => Next,\n                   Has_Element => Has_Element,\n-                  Element     => Element),\n+                  Element     => Key),\n      Default_Initial_Condition => Is_Empty (Map);\n    pragma Preelaborable_Initialization (Map);\n \n-   type Cursor is private;\n-   pragma Preelaborable_Initialization (Cursor);\n+   type Cursor is record\n+      Node : Count_Type;\n+   end record;\n+\n+   No_Element : constant Cursor := (Node => 0);\n \n    Empty_Map : constant Map;\n \n-   No_Element : constant Cursor;\n+   function Length (Container : Map) return Count_Type with\n+     Global => null,\n+     Post   => Length'Result <= Container.Capacity;\n+\n+   pragma Unevaluated_Use_Of_Old (Allow);\n+\n+   package Formal_Model with Ghost is\n+      subtype Positive_Count_Type is Count_Type range 1 .. Count_Type'Last;\n+\n+      package M is new Ada.Containers.Functional_Maps\n+        (Element_Type    => Element_Type,\n+         Key_Type        => Key_Type,\n+         Equivalent_Keys => Equivalent_Keys);\n+\n+      function \"=\"\n+        (Left  : M.Map;\n+         Right : M.Map) return Boolean renames M.\"=\";\n+\n+      function \"<=\"\n+        (Left  : M.Map;\n+         Right : M.Map) return Boolean renames M.\"<=\";\n+\n+      package K is new Ada.Containers.Functional_Vectors\n+        (Element_Type => Key_Type,\n+         Index_Type   => Positive_Count_Type);\n+\n+      function \"=\"\n+        (Left  : K.Sequence;\n+         Right : K.Sequence) return Boolean renames K.\"=\";\n+\n+      function \"<\"\n+        (Left  : K.Sequence;\n+         Right : K.Sequence) return Boolean renames K.\"<\";\n+\n+      function \"<=\"\n+        (Left  : K.Sequence;\n+         Right : K.Sequence) return Boolean renames K.\"<=\";\n+\n+      function K_Bigger_Than_Range\n+        (Container : K.Sequence;\n+         Fst       : Positive_Count_Type;\n+         Lst       : Count_Type;\n+         Key       : Key_Type) return Boolean\n+      with\n+        Global => null,\n+        Pre    => Lst <= K.Length (Container),\n+        Post   =>\n+          K_Bigger_Than_Range'Result =\n+            (for all I in Fst .. Lst => K.Get (Container, I) < Key);\n+      pragma Annotate (GNATprove, Inline_For_Proof, K_Bigger_Than_Range);\n+\n+      function K_Smaller_Than_Range\n+        (Container : K.Sequence;\n+         Fst       : Positive_Count_Type;\n+         Lst       : Count_Type;\n+         Key       : Key_Type) return Boolean\n+      with\n+        Global => null,\n+        Pre    => Lst <= K.Length (Container),\n+        Post   =>\n+          K_Smaller_Than_Range'Result =\n+            (for all I in Fst .. Lst => Key < K.Get (Container, I));\n+      pragma Annotate (GNATprove, Inline_For_Proof, K_Smaller_Than_Range);\n+\n+      function K_Is_Find\n+        (Container : K.Sequence;\n+         Key       : Key_Type;\n+         Position  : Count_Type) return Boolean\n+      with\n+        Global => null,\n+        Pre    => Position - 1 <= K.Length (Container),\n+        Post   =>\n+          K_Is_Find'Result =\n+\n+            ((if Position > 0 then\n+                K_Bigger_Than_Range (Container, 1, Position - 1, Key))\n+\n+             and (if Position < K.Length (Container) then\n+                    K_Smaller_Than_Range\n+                      (Container,\n+                       Position + 1,\n+                       K.Length (Container),\n+                       Key)));\n+      pragma Annotate (GNATprove, Inline_For_Proof, K_Is_Find);\n+\n+      package P is new Ada.Containers.Functional_Maps\n+        (Key_Type                       => Cursor,\n+         Element_Type                   => Positive_Count_Type,\n+         Equivalent_Keys                => \"=\",\n+         Enable_Handling_Of_Equivalence => False);\n+\n+      function \"=\"\n+        (Left  : P.Map;\n+         Right : P.Map) return Boolean renames P.\"=\";\n+\n+      function \"<=\"\n+        (Left  : P.Map;\n+         Right : P.Map) return Boolean renames P.\"<=\";\n+\n+      function P_Positions_Shifted\n+        (Small : P.Map;\n+         Big   : P.Map;\n+         Cut   : Positive_Count_Type;\n+         Count : Count_Type := 1) return Boolean\n+      with\n+        Global => null,\n+        Post   =>\n+          P_Positions_Shifted'Result =\n+\n+            --  Big contains all cursors of Small\n+\n+            (P.Keys_Included (Small, Big)\n+\n+              --  Cursors located before Cut are not moved, cursors located\n+              --  after are shifted by Count.\n+\n+              and (for all I of Small =>\n+                    (if P.Get (Small, I) < Cut then\n+                        P.Get (Big, I) = P.Get (Small, I)\n+                     else\n+                        P.Get (Big, I) - Count = P.Get (Small, I)))\n+\n+              --  New cursors of Big (if any) are between Cut and Cut - 1 +\n+              --  Count.\n+\n+              and (for all I of Big =>\n+                    P.Has_Key (Small, I)\n+                      or P.Get (Big, I) - Count in Cut - Count  .. Cut - 1));\n+\n+      function Model (Container : Map) return M.Map with\n+      --  The high-level model of a map is a map from keys to elements. Neither\n+      --  cursors nor order of elements are represented in this model. Keys are\n+      --  modeled up to equivalence.\n+\n+        Ghost,\n+        Global => null;\n+\n+      function Keys (Container : Map) return K.Sequence with\n+      --  The Keys sequence represents the underlying list structure of maps\n+      --  that is used for iteration. It stores the actual values of keys in\n+      --  the map. It does not model cursors nor elements.\n+\n+        Ghost,\n+        Global => null,\n+        Post   =>\n+          K.Length (Keys'Result) = Length (Container)\n+\n+            --  It only contains keys contained in Model\n+\n+            and (for all Key of Keys'Result =>\n+                   M.Has_Key (Model (Container), Key))\n+\n+            --  It contains all the keys contained in Model\n+\n+            and\n+              (for all Key of Model (Container) =>\n+                (for some L of Keys'Result => Equivalent_Keys (L, Key)))\n+\n+            --  It is sorted in increasing order\n+\n+            and\n+              (for all I in 1 .. Length (Container) =>\n+                (for all J in 1 .. Length (Container) =>\n+                   (K.Get (Keys'Result, I) < K.Get (Keys'Result, J)) =\n+                   (I < J)));\n+      pragma Annotate (GNATprove, Iterable_For_Proof, \"Model\", Keys);\n+\n+      function Positions (Container : Map) return P.Map with\n+      --  The Positions map is used to model cursors. It only contains valid\n+      --  cursors and maps them to their position in the container.\n+\n+        Ghost,\n+        Global => null,\n+        Post   =>\n+          not P.Has_Key (Positions'Result, No_Element)\n+\n+            --  Positions of cursors are smaller than the container's length.\n+\n+            and then\n+              (for all I of Positions'Result =>\n+                P.Get (Positions'Result, I) in 1 .. Length (Container)\n+\n+            --  No two cursors have the same position. Note that we do not\n+            --  state that there is a cursor in the map for each position, as\n+            --  it is rarely needed.\n+\n+            and then\n+              (for all J of Positions'Result =>\n+                (if P.Get (Positions'Result, I) = P.Get (Positions'Result, J)\n+                  then I = J)));\n+\n+      procedure Lift_Abstraction_Level (Container : Map) with\n+        --  Lift_Abstraction_Level is a ghost procedure that does nothing but\n+        --  assume that we can access the same elements by iterating over\n+        --  positions or cursors.\n+        --  This information is not generally useful except when switching from\n+        --  a low-level, cursor-aware view of a container, to a high-level,\n+        --  position-based view.\n+\n+        Ghost,\n+        Global => null,\n+        Post   =>\n+          (for all Key of Keys (Container) =>\n+            (for some I of Positions (Container) =>\n+              K.Get (Keys (Container), P.Get (Positions (Container), I)) =\n+                Key));\n+\n+      function Contains\n+        (C : M.Map;\n+         K : Key_Type) return Boolean renames M.Has_Key;\n+      --  To improve readability of contracts, we rename the function used to\n+      --  search for a key in the model to Contains.\n+\n+      function Element\n+        (C : M.Map;\n+         K : Key_Type) return Element_Type renames M.Get;\n+      --  To improve readability of contracts, we rename the function used to\n+      --  access an element in the model to Element.\n+   end Formal_Model;\n+   use Formal_Model;\n \n    function \"=\" (Left, Right : Map) return Boolean with\n-     Global => null;\n-\n-   function Length (Container : Map) return Count_Type with\n-     Global => null;\n+     Global => null,\n+     Post   => \"=\"'Result = (Model (Left) = Model (Right));\n \n    function Is_Empty (Container : Map) return Boolean with\n-     Global => null;\n+     Global => null,\n+     Post   => Is_Empty'Result = (Length (Container) = 0);\n \n    procedure Clear (Container : in out Map) with\n-     Global => null;\n+     Global => null,\n+     Post   => Length (Container) = 0 and M.Is_Empty (Model (Container));\n \n    procedure Assign (Target : in out Map; Source : Map) with\n      Global => null,\n-     Pre    => Target.Capacity >= Length (Source);\n+     Pre    => Target.Capacity >= Length (Source),\n+     Post   =>\n+       Model (Target) = Model (Source)\n+         and Keys (Target) = Keys (Source)\n+         and Length (Source) = Length (Target);\n \n    function Copy (Source : Map; Capacity : Count_Type := 0) return Map with\n      Global => null,\n-     Pre    => Capacity = 0 or else Capacity >= Source.Capacity;\n+     Pre    => Capacity = 0 or else Capacity >= Source.Capacity,\n+     Post   =>\n+       Model (Copy'Result) = Model (Source)\n+         and Keys (Copy'Result) = Keys (Source)\n+         and Positions (Copy'Result) = Positions (Source)\n+         and (if Capacity = 0 then\n+                 Copy'Result.Capacity = Source.Capacity\n+              else\n+                 Copy'Result.Capacity = Capacity);\n \n    function Key (Container : Map; Position : Cursor) return Key_Type with\n      Global => null,\n-     Pre    => Has_Element (Container, Position);\n+     Pre    => Has_Element (Container, Position),\n+     Post   =>\n+       Key'Result =\n+         K.Get (Keys (Container), P.Get (Positions (Container), Position));\n+   pragma Annotate (GNATprove, Inline_For_Proof, Key);\n \n    function Element\n      (Container : Map;\n       Position  : Cursor) return Element_Type\n    with\n      Global => null,\n-     Pre    => Has_Element (Container, Position);\n+     Pre    => Has_Element (Container, Position),\n+     Post   =>\n+       Element'Result = Element (Model (Container), Key (Container, Position));\n+   pragma Annotate (GNATprove, Inline_For_Proof, Element);\n \n    procedure Replace_Element\n      (Container : in out Map;\n       Position  : Cursor;\n       New_Item  : Element_Type)\n    with\n      Global => null,\n-     Pre    => Has_Element (Container, Position);\n+     Pre    => Has_Element (Container, Position),\n+     Post   =>\n+\n+       --  Order of keys and cursors is preserved\n+\n+       Keys (Container) = Keys (Container)'Old\n+         and Positions (Container) = Positions (Container)'Old\n+\n+         --  New_Item is now associated with the key at position Position in\n+         --  Container.\n+\n+         and Element (Container, Position) = New_Item\n+\n+         --  Elements associated with other keys are preserved\n+\n+         and M.Same_Keys (Model (Container), Model (Container)'Old)\n+         and M.Elements_Equal_Except\n+               (Model (Container),\n+                Model (Container)'Old,\n+                Key (Container, Position));\n \n    procedure Move (Target : in out Map; Source : in out Map) with\n      Global => null,\n-     Pre    => Target.Capacity >= Length (Source);\n+     Pre    => Target.Capacity >= Length (Source),\n+     Post   =>\n+       Model (Target) = Model (Source)'Old\n+         and Keys (Target) = Keys (Source)'Old\n+         and Length (Source)'Old = Length (Target)\n+         and Length (Source) = 0;\n \n    procedure Insert\n      (Container : in out Map;\n@@ -141,138 +400,636 @@ is\n       Position  : out Cursor;\n       Inserted  : out Boolean)\n    with\n-     Global => null,\n-     Pre    => Length (Container) < Container.Capacity;\n+     Global         => null,\n+     Pre            =>\n+       Length (Container) < Container.Capacity or Contains (Container, Key),\n+     Post           =>\n+       Contains (Container, Key)\n+         and Has_Element (Container, Position)\n+         and Equivalent_Keys\n+               (Formal_Ordered_Maps.Key (Container, Position), Key)\n+         and K_Is_Find\n+               (Keys (Container),\n+                Key,\n+                P.Get (Positions (Container), Position)),\n+     Contract_Cases =>\n+\n+       --  If Key is already in Container, it is not modified and Inserted is\n+       --  set to False.\n+\n+       (Contains (Container, Key) =>\n+          not Inserted\n+            and Model (Container) = Model (Container)'Old\n+            and Keys (Container) = Keys (Container)'Old\n+            and Positions (Container) = Positions (Container)'Old,\n+\n+        --  Otherwise, Key is inserted in Container and Inserted is set to True\n+\n+        others =>\n+          Inserted\n+            and Length (Container) = Length (Container)'Old + 1\n+\n+            --  Key now maps to New_Item\n+\n+            and Formal_Ordered_Maps.Key (Container, Position) = Key\n+            and Element (Model (Container), Key) = New_Item\n+\n+            --  Other mappings are preserved\n+\n+            and Model (Container)'Old <= Model (Container)\n+            and M.Keys_Included_Except\n+                  (Model (Container),\n+                   Model (Container)'Old,\n+                   Key)\n+\n+            --  The keys of Container located before Position are preserved\n+\n+            and K.Range_Equal\n+                  (Left  => Keys (Container)'Old,\n+                   Right => Keys (Container),\n+                   Fst   => 1,\n+                   Lst   => P.Get (Positions (Container), Position) - 1)\n+\n+            --  Other keys are shifted by 1\n+\n+            and K.Range_Shifted\n+                  (Left   => Keys (Container)'Old,\n+                   Right  => Keys (Container),\n+                   Fst    => P.Get (Positions (Container), Position),\n+                   Lst    => Length (Container)'Old,\n+                   Offset => 1)\n+\n+            --  A new cursor has been inserted at position Position in\n+            --  Container.\n+\n+            and P_Positions_Shifted\n+                  (Positions (Container)'Old,\n+                   Positions (Container),\n+                   Cut => P.Get (Positions (Container), Position)));\n \n    procedure Insert\n      (Container : in out Map;\n       Key       : Key_Type;\n       New_Item  : Element_Type)\n    with\n      Global => null,\n-     Pre    => Length (Container) < Container.Capacity\n-                 and then (not Contains (Container, Key));\n+     Pre    =>\n+       Length (Container) < Container.Capacity\n+         and then (not Contains (Container, Key)),\n+     Post   =>\n+       Length (Container) = Length (Container)'Old + 1\n+         and Contains (Container, Key)\n+\n+         --  Key now maps to New_Item\n+\n+         and Formal_Ordered_Maps.Key (Container, Find (Container, Key)) = Key\n+         and Element (Model (Container), Key) = New_Item\n+\n+         --  Other mappings are preserved\n+\n+         and Model (Container)'Old <= Model (Container)\n+         and M.Keys_Included_Except\n+               (Model (Container),\n+                Model (Container)'Old,\n+                Key)\n+\n+         --  The keys of Container located before Key are preserved\n+\n+         and K.Range_Equal\n+               (Left  => Keys (Container)'Old,\n+                Right => Keys (Container),\n+                Fst   => 1,\n+                Lst   =>\n+                  P.Get (Positions (Container), Find (Container, Key)) - 1)\n+\n+         --  Other keys are shifted by 1\n+\n+         and K.Range_Shifted\n+               (Left   => Keys (Container)'Old,\n+                Right  => Keys (Container),\n+                Fst    => P.Get (Positions (Container), Find (Container, Key)),\n+                Lst    => Length (Container)'Old,\n+                Offset => 1)\n+\n+         --  A new cursor has been inserted in Container\n+\n+         and P_Positions_Shifted\n+               (Positions (Container)'Old,\n+                Positions (Container),\n+                Cut => P.Get (Positions (Container), Find (Container, Key)));\n \n    procedure Include\n      (Container : in out Map;\n       Key       : Key_Type;\n       New_Item  : Element_Type)\n    with\n-     Global => null,\n-     Pre    => Length (Container) < Container.Capacity;\n+     Global         => null,\n+     Pre            =>\n+       Length (Container) < Container.Capacity or Contains (Container, Key),\n+     Post           =>\n+       Contains (Container, Key) and Element (Container, Key) = New_Item,\n+     Contract_Cases =>\n+\n+       --  If Key is already in Container, Key is mapped to New_Item\n+\n+       (Contains (Container, Key) =>\n+\n+          --  Cursors are preserved\n+\n+          Positions (Container) = Positions (Container)'Old\n+\n+            --  The key equivalent to Key in Container is replaced by Key\n+\n+            and K.Get\n+                  (Keys (Container),\n+                   P.Get (Positions (Container), Find (Container, Key))) = Key\n+\n+            and K.Equal_Except\n+                  (Keys (Container)'Old,\n+                   Keys (Container),\n+                   P.Get (Positions (Container), Find (Container, Key)))\n+\n+            --  Elements associated with other keys are preserved\n+\n+            and M.Same_Keys (Model (Container), Model (Container)'Old)\n+            and M.Elements_Equal_Except\n+                  (Model (Container),\n+                   Model (Container)'Old,\n+                   Key),\n+\n+        --  Otherwise, Key is inserted in Container\n+\n+        others =>\n+          Length (Container) = Length (Container)'Old + 1\n+\n+            --  Other mappings are preserved\n+\n+            and Model (Container)'Old <= Model (Container)\n+            and M.Keys_Included_Except\n+                  (Model (Container),\n+                   Model (Container)'Old,\n+                   Key)\n+\n+            --  Key is inserted in Container\n+\n+            and K.Get\n+                  (Keys (Container),\n+                   P.Get (Positions (Container), Find (Container, Key))) = Key\n+\n+            --  The keys of Container located before Key are preserved\n+\n+            and K.Range_Equal\n+                  (Left  => Keys (Container)'Old,\n+                   Right => Keys (Container),\n+                   Fst   => 1,\n+                   Lst   =>\n+                     P.Get (Positions (Container), Find (Container, Key)) - 1)\n+\n+            --  Other keys are shifted by 1\n+\n+            and K.Range_Shifted\n+                  (Left   => Keys (Container)'Old,\n+                   Right  => Keys (Container),\n+                   Fst    =>\n+                     P.Get (Positions (Container), Find (Container, Key)),\n+                   Lst    => Length (Container)'Old,\n+                   Offset => 1)\n+\n+            --  A new cursor has been inserted in Container\n+\n+            and P_Positions_Shifted\n+                  (Positions (Container)'Old,\n+                   Positions (Container),\n+                   Cut =>\n+                     P.Get (Positions (Container), Find (Container, Key))));\n \n    procedure Replace\n      (Container : in out Map;\n       Key       : Key_Type;\n       New_Item  : Element_Type)\n    with\n      Global => null,\n-     Pre    => Contains (Container, Key);\n+     Pre    => Contains (Container, Key),\n+     Post  =>\n+\n+       --  Cursors are preserved\n+\n+       Positions (Container) = Positions (Container)'Old\n+\n+         --  The key equivalent to Key in Container is replaced by Key\n+\n+         and K.Get (Keys (Container),\n+                    P.Get (Positions (Container), Find (Container, Key))) = Key\n+         and K.Equal_Except\n+              (Keys (Container)'Old,\n+               Keys (Container),\n+               P.Get (Positions (Container), Find (Container, Key)))\n+\n+         --  New_Item is now associated with the Key in Container\n+\n+         and Element (Model (Container), Key) = New_Item\n+\n+         --  Elements associated with other keys are preserved\n+\n+         and M.Same_Keys (Model (Container), Model (Container)'Old)\n+         and M.Elements_Equal_Except\n+               (Model (Container),\n+                Model (Container)'Old,\n+                Key);\n \n    procedure Exclude (Container : in out Map; Key : Key_Type) with\n-     Global => null;\n+     Global         => null,\n+     Post           => not Contains (Container, Key),\n+     Contract_Cases =>\n+\n+       --  If Key is not in Container, nothing is changed\n+\n+       (not Contains (Container, Key) =>\n+          Model (Container) = Model (Container)'Old\n+            and Keys (Container) = Keys (Container)'Old\n+            and Positions (Container) = Positions (Container)'Old,\n+\n+        --  Otherwise, Key is removed from Container\n+\n+        others =>\n+          Length (Container) = Length (Container)'Old - 1\n+\n+            --  Other mappings are preserved\n+\n+            and Model (Container) <= Model (Container)'Old\n+            and M.Keys_Included_Except\n+                  (Model (Container)'Old,\n+                   Model (Container),\n+                   Key)\n+\n+            --  The keys of Container located before Key are preserved\n+\n+            and K.Range_Equal\n+                  (Left  => Keys (Container)'Old,\n+                   Right => Keys (Container),\n+                   Fst   => 1,\n+                   Lst   =>\n+                     P.Get (Positions (Container), Find (Container, Key))'Old\n+                       - 1)\n+\n+            --  The keys located after Key are shifted by 1\n+\n+            and K.Range_Shifted\n+                  (Left   => Keys (Container),\n+                   Right  => Keys (Container)'Old,\n+                   Fst    =>\n+                     P.Get (Positions (Container), Find (Container, Key))'Old,\n+                   Lst    => Length (Container),\n+                   Offset => 1)\n+\n+            --  A cursor has been removed from Container\n+\n+            and P_Positions_Shifted\n+                  (Positions (Container),\n+                   Positions (Container)'Old,\n+                   Cut   =>\n+                     P.Get\n+                       (Positions (Container), Find (Container, Key))'Old));\n \n    procedure Delete (Container : in out Map; Key : Key_Type) with\n      Global => null,\n-     Pre    => Contains (Container, Key);\n+     Pre    => Contains (Container, Key),\n+     Post   =>\n+       Length (Container) = Length (Container)'Old - 1\n+\n+         --  Key is no longer in Container\n+\n+         and not Contains (Container, Key)\n+\n+         --  Other mappings are preserved\n+\n+         and Model (Container) <= Model (Container)'Old\n+         and M.Keys_Included_Except\n+               (Model (Container)'Old,\n+                Model (Container),\n+                Key)\n+\n+         --  The keys of Container located before Key are preserved\n+\n+         and K.Range_Equal\n+               (Left  => Keys (Container)'Old,\n+                Right => Keys (Container),\n+                Fst   => 1,\n+                Lst   =>\n+                  P.Get (Positions (Container), Find (Container, Key))'Old - 1)\n+\n+         --  The keys located after Key are shifted by 1\n+\n+         and K.Range_Shifted\n+               (Left   => Keys (Container),\n+                Right  => Keys (Container)'Old,\n+                Fst    =>\n+                  P.Get (Positions (Container), Find (Container, Key))'Old,\n+                Lst    => Length (Container),\n+                Offset => 1)\n+\n+         --  A cursor has been removed from Container\n+\n+         and P_Positions_Shifted\n+               (Positions (Container),\n+                Positions (Container)'Old,\n+                Cut   =>\n+                  P.Get (Positions (Container), Find (Container, Key))'Old);\n \n    procedure Delete (Container : in out Map; Position : in out Cursor) with\n      Global => null,\n-     Pre    => Has_Element (Container, Position);\n+     Pre    => Has_Element (Container, Position),\n+     Post   =>\n+       Position = No_Element\n+         and Length (Container) = Length (Container)'Old - 1\n+\n+         --  The key at position Position is no longer in Container\n+\n+         and not Contains (Container, Key (Container, Position)'Old)\n+         and not P.Has_Key (Positions (Container), Position'Old)\n+\n+         --  Other mappings are preserved\n+\n+         and Model (Container) <= Model (Container)'Old\n+         and M.Keys_Included_Except\n+               (Model (Container)'Old,\n+                Model (Container),\n+                Key (Container, Position)'Old)\n+\n+         --  The keys of Container located before Position are preserved.\n+\n+         and K.Range_Equal\n+               (Left  => Keys (Container)'Old,\n+                Right => Keys (Container),\n+                Fst   => 1,\n+                Lst   => P.Get (Positions (Container)'Old, Position'Old) - 1)\n+\n+         --  The keys located after Position are shifted by 1\n+\n+         and K.Range_Shifted\n+               (Left   => Keys (Container),\n+                Right  => Keys (Container)'Old,\n+                Fst    => P.Get (Positions (Container)'Old, Position'Old),\n+                Lst    => Length (Container),\n+                Offset => 1)\n+\n+         --  Position has been removed from Container\n+\n+         and P_Positions_Shifted\n+               (Positions (Container),\n+                Positions (Container)'Old,\n+                Cut   => P.Get (Positions (Container)'Old, Position'Old));\n \n    procedure Delete_First (Container : in out Map) with\n-     Global => null;\n+     Global         => null,\n+     Contract_Cases =>\n+       (Length (Container) = 0 => Length (Container) = 0,\n+        others =>\n+          Length (Container) = Length (Container)'Old - 1\n+\n+            --  The first key has been removed from Container\n+\n+            and not Contains (Container, First_Key (Container)'Old)\n+\n+            --  Other mappings are preserved\n+\n+            and Model (Container) <= Model (Container)'Old\n+            and M.Keys_Included_Except\n+                  (Model (Container)'Old,\n+                   Model (Container),\n+                    First_Key (Container)'Old)\n+\n+            --  Other keys are shifted by 1\n+\n+            and K.Range_Shifted\n+                  (Left   => Keys (Container),\n+                   Right  => Keys (Container)'Old,\n+                   Fst    => 1,\n+                   Lst    => Length (Container),\n+                   Offset => 1)\n+\n+            --  First has been removed from Container\n+\n+            and P_Positions_Shifted\n+                  (Positions (Container),\n+                   Positions (Container)'Old,\n+                   Cut   => 1));\n \n    procedure Delete_Last (Container : in out Map) with\n-     Global => null;\n+     Global         => null,\n+     Contract_Cases =>\n+       (Length (Container) = 0 => Length (Container) = 0,\n+        others =>\n+          Length (Container) = Length (Container)'Old - 1\n+\n+            --  The last key has been removed from Container\n+\n+            and not Contains (Container, Last_Key (Container)'Old)\n+\n+            --  Other mappings are preserved\n+\n+            and Model (Container) <= Model (Container)'Old\n+            and M.Keys_Included_Except\n+                  (Model (Container)'Old,\n+                   Model (Container),\n+                   Last_Key (Container)'Old)\n+\n+            --  Others keys of Container are preserved\n+\n+            and K.Range_Equal\n+                  (Left  => Keys (Container)'Old,\n+                   Right => Keys (Container),\n+                   Fst   => 1,\n+                   Lst   => Length (Container))\n+\n+            --  Last cursor has been removed from Container\n+\n+            and Positions (Container) <= Positions (Container)'Old);\n \n    function First (Container : Map) return Cursor with\n-     Global => null;\n+     Global         => null,\n+     Contract_Cases =>\n+       (Length (Container) = 0 =>\n+          First'Result = No_Element,\n+\n+        others =>\n+          Has_Element (Container, First'Result)\n+            and P.Get (Positions (Container), First'Result) = 1);\n \n    function First_Element (Container : Map) return Element_Type with\n      Global => null,\n-     Pre    => not Is_Empty (Container);\n+     Pre    => not Is_Empty (Container),\n+     Post   =>\n+       First_Element'Result =\n+         Element (Model (Container), First_Key (Container));\n \n    function First_Key (Container : Map) return Key_Type with\n      Global => null,\n-     Pre    => not Is_Empty (Container);\n+     Pre    => not Is_Empty (Container),\n+     Post   =>\n+       First_Key'Result = K.Get (Keys (Container), 1)\n+         and K_Smaller_Than_Range\n+               (Keys (Container), 2, Length (Container), First_Key'Result);\n \n    function Last (Container : Map) return Cursor with\n-     Global => null;\n+     Global         => null,\n+     Contract_Cases =>\n+       (Length (Container) = 0 =>\n+          Last'Result = No_Element,\n+\n+        others =>\n+          Has_Element (Container, Last'Result)\n+            and P.Get (Positions (Container), Last'Result) =\n+                  Length (Container));\n \n    function Last_Element (Container : Map) return Element_Type with\n      Global => null,\n-     Pre    => not Is_Empty (Container);\n+     Pre    => not Is_Empty (Container),\n+     Post   =>\n+       Last_Element'Result = Element (Model (Container), Last_Key (Container));\n \n    function Last_Key (Container : Map) return Key_Type with\n      Global => null,\n-     Pre    => not Is_Empty (Container);\n+     Pre    => not Is_Empty (Container),\n+     Post   =>\n+       Last_Key'Result = K.Get (Keys (Container), Length (Container))\n+         and K_Bigger_Than_Range\n+               (Keys (Container), 1, Length (Container) - 1, Last_Key'Result);\n \n    function Next (Container : Map; Position : Cursor) return Cursor with\n-     Global => null,\n-     Pre    => Has_Element (Container, Position) or else Position = No_Element;\n+     Global         => null,\n+     Pre            =>\n+       Has_Element (Container, Position) or else Position = No_Element,\n+     Contract_Cases =>\n+       (Position = No_Element\n+          or else P.Get (Positions (Container), Position) = Length (Container)\n+        =>\n+          Next'Result = No_Element,\n+\n+        others =>\n+          Has_Element (Container, Next'Result)\n+            and then P.Get (Positions (Container), Next'Result) =\n+                     P.Get (Positions (Container), Position) + 1);\n \n    procedure Next (Container : Map; Position : in out Cursor) with\n-     Global => null,\n-     Pre    => Has_Element (Container, Position) or else Position = No_Element;\n+     Global         => null,\n+     Pre            =>\n+       Has_Element (Container, Position) or else Position = No_Element,\n+     Contract_Cases =>\n+       (Position = No_Element\n+          or else P.Get (Positions (Container), Position) = Length (Container)\n+        =>\n+          Position = No_Element,\n+\n+        others =>\n+          Has_Element (Container, Position)\n+            and then P.Get (Positions (Container), Position) =\n+                     P.Get (Positions (Container), Position'Old) + 1);\n \n    function Previous (Container : Map; Position : Cursor) return Cursor with\n-     Global => null,\n-     Pre    => Has_Element (Container, Position) or else Position = No_Element;\n+     Global         => null,\n+     Pre            =>\n+       Has_Element (Container, Position) or else Position = No_Element,\n+     Contract_Cases =>\n+       (Position = No_Element\n+          or else P.Get (Positions (Container), Position) = 1\n+        =>\n+          Previous'Result = No_Element,\n+\n+        others =>\n+          Has_Element (Container, Previous'Result)\n+            and then P.Get (Positions (Container), Previous'Result) =\n+                     P.Get (Positions (Container), Position) - 1);\n \n    procedure Previous (Container : Map; Position : in out Cursor) with\n-     Global => null,\n-     Pre    => Has_Element (Container, Position) or else Position = No_Element;\n+     Global         => null,\n+     Pre            =>\n+       Has_Element (Container, Position) or else Position = No_Element,\n+     Contract_Cases =>\n+       (Position = No_Element\n+          or else P.Get (Positions (Container), Position) = 1\n+         =>\n+          Position = No_Element,\n+\n+        others =>\n+          Has_Element (Container, Position)\n+            and then P.Get (Positions (Container), Position) =\n+                     P.Get (Positions (Container), Position'Old) - 1);\n \n    function Find (Container : Map; Key : Key_Type) return Cursor with\n-     Global => null;\n+     Global         => null,\n+     Contract_Cases =>\n+\n+       --  If Key is not is not contained in Container, Find returns No_Element\n+\n+       (not Contains (Model (Container), Key) =>\n+          not P.Has_Key (Positions (Container), Find'Result)\n+            and Find'Result = No_Element,\n+\n+        --  Otherwise, Find returns a valid cusror in Container\n+\n+        others =>\n+          P.Has_Key (Positions (Container), Find'Result)\n+\n+            --  The key designated by the result of Find is Key\n+\n+            and Equivalent_Keys\n+                  (Formal_Ordered_Maps.Key (Container, Find'Result), Key)\n+\n+            --  Keys of Container are ordered\n+\n+            and K_Is_Find\n+                  (Keys (Container),\n+                   Key,\n+                   P.Get (Positions (Container),\n+                   Find'Result)));\n \n    function Element (Container : Map; Key : Key_Type) return Element_Type with\n      Global => null,\n-     Pre    => Contains (Container, Key);\n+     Pre    => Contains (Container, Key),\n+     Post   => Element'Result = Element (Model (Container), Key);\n+   pragma Annotate (GNATprove, Inline_For_Proof, Element);\n \n    function Floor (Container : Map; Key : Key_Type) return Cursor with\n-     Global => null;\n+     Global         => null,\n+     Contract_Cases =>\n+       (Length (Container) = 0 or else Key < First_Key (Container) =>\n+          Floor'Result = No_Element,\n+        others =>\n+          Has_Element (Container, Floor'Result)\n+            and not (Key < K.Get (Keys (Container),\n+                                  P.Get (Positions (Container), Floor'Result)))\n+            and K_Is_Find\n+                  (Keys (Container),\n+                   Key,\n+                   P.Get (Positions (Container), Floor'Result)));\n \n    function Ceiling (Container : Map; Key : Key_Type) return Cursor with\n-     Global => null;\n+     Global         => null,\n+     Contract_Cases =>\n+       (Length (Container) = 0 or else Last_Key (Container) < Key =>\n+          Ceiling'Result = No_Element,\n+        others =>\n+          Has_Element (Container, Ceiling'Result)\n+            and\n+              not (K.Get (Keys (Container),\n+                          P.Get (Positions (Container), Ceiling'Result)) < Key)\n+            and K_Is_Find\n+                  (Keys (Container),\n+                   Key,\n+                   P.Get (Positions (Container), Ceiling'Result)));\n \n    function Contains (Container : Map; Key : Key_Type) return Boolean with\n-     Global => null;\n-\n-   function Has_Element (Container : Map; Position : Cursor) return Boolean\n-   with\n-     Global => null;\n-\n-   function Strict_Equal (Left, Right : Map) return Boolean with\n-     Ghost,\n-     Global => null;\n-   --  Strict_Equal returns True if the containers are physically equal, i.e.\n-   --  they are structurally equal (function \"=\" returns True) and that they\n-   --  have the same set of cursors.\n-\n-   function First_To_Previous (Container : Map; Current : Cursor) return Map\n-   with\n-     Ghost,\n      Global => null,\n-     Pre    => Has_Element (Container, Current) or else Current = No_Element;\n+     Post   => Contains'Result = Contains (Model (Container), Key);\n+   pragma Annotate (GNATprove, Inline_For_Proof, Contains);\n \n-   function Current_To_Last (Container : Map; Current : Cursor) return Map\n+   function Has_Element (Container : Map; Position : Cursor) return Boolean\n    with\n-     Ghost,\n      Global => null,\n-     Pre    => Has_Element (Container, Current) or else Current = No_Element;\n-   --  First_To_Previous returns a container containing all elements preceding\n-   --  Current (excluded) in Container. Current_To_Last returns a container\n-   --  containing all elements following Current (included) in Container.\n-   --  These two new functions can be used to express invariant properties in\n-   --  loops which iterate over containers. First_To_Previous returns the part\n-   --  of the container already scanned and Current_To_Last the part not\n-   --  scanned yet.\n-\n-   function Overlap (Left, Right : Map) return Boolean with\n-     Global => null;\n-   --  Overlap returns True if the containers have common keys\n+     Post   =>\n+       Has_Element'Result = P.Has_Key (Positions (Container), Position);\n+   pragma Annotate (GNATprove, Inline_For_Proof, Has_Element);\n \n private\n    pragma SPARK_Mode (Off);\n@@ -300,12 +1057,6 @@ private\n    type Map (Capacity : Count_Type) is\n      new Tree_Types.Tree_Type (Capacity) with null record;\n \n-   type Cursor is record\n-      Node : Node_Access;\n-   end record;\n-\n    Empty_Map : constant Map := (Capacity => 0, others => <>);\n \n-   No_Element : constant Cursor := (Node => 0);\n-\n end Ada.Containers.Formal_Ordered_Maps;"}, {"sha": "487aff469464fb7c7a806a68f6decef55a865ab3", "filename": "gcc/ada/a-cofuma.adb", "status": "modified", "additions": 22, "deletions": 10, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2acfbce60d8225bff9f469a68606ebd2fe54736/gcc%2Fada%2Fa-cofuma.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2acfbce60d8225bff9f469a68606ebd2fe54736/gcc%2Fada%2Fa-cofuma.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cofuma.adb?ref=f2acfbce60d8225bff9f469a68606ebd2fe54736", "patch": "@@ -148,6 +148,13 @@ package body Ada.Containers.Functional_Maps with SPARK_Mode => Off is\n       return Find (Container.Keys, Key) > 0;\n    end Has_Key;\n \n+   -----------------\n+   -- Has_Witness --\n+   -----------------\n+\n+   function Has_Witness (Container : Map; Witness : Count_Type) return Boolean\n+   is (Witness in 1 .. Length (Container.Keys));\n+\n    --------------\n    -- Is_Empty --\n    --------------\n@@ -233,16 +240,6 @@ package body Ada.Containers.Functional_Maps with SPARK_Mode => Off is\n       return Length (Container.Elements);\n    end Length;\n \n-   --------------------------\n-   -- Lift_Equivalent_Keys --\n-   --------------------------\n-\n-   procedure Lift_Equivalent_Keys\n-     (Container : Map;\n-      Left      : Key_Type;\n-      Right     : Key_Type)\n-   is null;\n-\n    ---------------\n    -- Same_Keys --\n    ---------------\n@@ -264,4 +261,19 @@ package body Ada.Containers.Functional_Maps with SPARK_Mode => Off is\n       Elements =>\n         Set (Container.Elements, Find (Container.Keys, Key), New_Item));\n \n+   -----------\n+   -- W_Get --\n+   -----------\n+\n+   function W_Get (Container : Map; Witness : Count_Type) return Element_Type\n+   is\n+     (Get (Container.Elements, Witness));\n+\n+   -------------\n+   -- Witness --\n+   -------------\n+\n+   function Witness (Container : Map; Key : Key_Type) return Count_Type is\n+     (Find (Container.Keys, Key));\n+\n end Ada.Containers.Functional_Maps;"}, {"sha": "2b167b2f39dfc9a36ef1446f5271f73be39633b9", "filename": "gcc/ada/a-cofuma.ads", "status": "modified", "additions": 59, "deletions": 24, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2acfbce60d8225bff9f469a68606ebd2fe54736/gcc%2Fada%2Fa-cofuma.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2acfbce60d8225bff9f469a68606ebd2fe54736/gcc%2Fada%2Fa-cofuma.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cofuma.ads?ref=f2acfbce60d8225bff9f469a68606ebd2fe54736", "patch": "@@ -36,6 +36,10 @@ generic\n    type Key_Type (<>) is private;\n    type Element_Type (<>)  is private;\n    with function Equivalent_Keys (Left, Right : Key_Type) return Boolean;\n+   Enable_Handling_Of_Equivalence : Boolean := True;\n+   --  This constant should only be set to False when no particular handling\n+   --  of equivalence over keys is needed, that is, Equivalent_Keys defines a\n+   --  key uniquely.\n \n package Ada.Containers.Functional_Maps with SPARK_Mode is\n \n@@ -57,38 +61,40 @@ package Ada.Containers.Functional_Maps with SPARK_Mode is\n    -----------------------\n \n    --  Maps are axiomatized using Has_Key and Get, encoding respectively the\n-   --  presence of a key in a map and an accessor to elements associated to its\n-   --  keys. The length of a map is also added to protect Add against overflows\n-   --  but it is not actually modeled.\n+   --  presence of a key in a map and an accessor to elements associated with\n+   --  its keys. The length of a map is also added to protect Add against\n+   --  overflows but it is not actually modeled.\n \n    function Has_Key (Container : Map; Key : Key_Type) return Boolean with\n-     Global => null;\n    --  Return True if Key is present in Container\n \n-   function Get (Container : Map; Key : Key_Type) return Element_Type with\n      Global => null,\n-     Pre    => Has_Key (Container, Key);\n-   --  Return the element associated to Key is present in Container\n+     Post   =>\n+       (if Enable_Handling_Of_Equivalence then\n \n-   function Length (Container : Map) return Count_Type with\n-     Global => null;\n-   --  Return the number of mappings in Container\n+          --  Has_Key returns the same result on all equivalent keys\n \n-   procedure Lift_Equivalent_Keys\n-     (Container : Map;\n-      Left      : Key_Type;\n-      Right     : Key_Type)\n-   --  Lemma function which can be called manually to allow GNATprove to deduce\n-   --  that Has_Key and Get always return the same result on equivalent keys.\n+          (if (for some K of Container => Equivalent_Keys (K, Key)) then\n+             Has_Key'Result));\n+\n+   function Get (Container : Map; Key : Key_Type) return Element_Type with\n+   --  Return the element associated with Key in Container\n \n-   with\n-     Ghost,\n      Global => null,\n-     Pre    => Equivalent_Keys (Left, Right),\n+     Pre    => Has_Key (Container, Key),\n      Post   =>\n-       Has_Key (Container, Left) = Has_Key (Container, Right)\n-         and (if Has_Key (Container, Left) then\n-                 Get (Container, Left) = Get (Container, Right));\n+       (if Enable_Handling_Of_Equivalence then\n+\n+          --  Get returns the same result on all equivalent keys\n+\n+          Get'Result = W_Get (Container, Witness (Container, Key))\n+          and (for all K of Container =>\n+                 (if Equivalent_Keys (K, Key) then\n+                    Witness (Container, Key) = Witness (Container, K))));\n+\n+   function Length (Container : Map) return Count_Type with\n+     Global => null;\n+   --  Return the number of mappings in Container\n \n    ------------------------\n    -- Property Functions --\n@@ -236,8 +242,8 @@ package Ada.Containers.Functional_Maps with SPARK_Mode is\n      (Container : Map;\n       Key       : Key_Type;\n       New_Item  : Element_Type) return Map\n-   --  Returns Container, where the element associated to Key has been replaced\n-   --  by New_Item.\n+   --  Returns Container, where the element associated with Key has been\n+   --  replaced by New_Item.\n \n    with\n      Global => null,\n@@ -248,6 +254,35 @@ package Ada.Containers.Functional_Maps with SPARK_Mode is\n          and Same_Keys (Container, Set'Result)\n          and Elements_Equal_Except (Container, Set'Result, Key);\n \n+   ------------------------------\n+   --  Handling of Equivalence --\n+   ------------------------------\n+\n+   --  These functions are used to specify that Get returns the same value on\n+   --  equivalent keys. They should not be used directly in user code.\n+\n+   function Has_Witness (Container : Map; Witness : Count_Type) return Boolean\n+   with\n+     Ghost,\n+     Global => null;\n+   --  Returns True if there is a key with witness Witness in Container\n+\n+   function Witness (Container : Map; Key : Key_Type) return Count_Type with\n+   --  Returns the witness of Key in Container\n+\n+     Ghost,\n+     Global => null,\n+     Pre    => Has_Key (Container, Key),\n+     Post   => Has_Witness (Container, Witness'Result);\n+\n+   function W_Get (Container : Map; Witness : Count_Type) return Element_Type\n+   with\n+   --  Returns the element associated with a witness in Container\n+\n+     Ghost,\n+     Global => null,\n+     Pre    => Has_Witness (Container, Witness);\n+\n    ---------------------------\n    --  Iteration Primitives --\n    ---------------------------"}, {"sha": "0a998f3d10c73c995c5fe27cdfeb9cf599180f73", "filename": "gcc/ada/a-cofuse.ads", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2acfbce60d8225bff9f469a68606ebd2fe54736/gcc%2Fada%2Fa-cofuse.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2acfbce60d8225bff9f469a68606ebd2fe54736/gcc%2Fada%2Fa-cofuse.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cofuse.ads?ref=f2acfbce60d8225bff9f469a68606ebd2fe54736", "patch": "@@ -37,6 +37,10 @@ generic\n    with function Equivalent_Elements\n      (Left  : Element_Type;\n       Right : Element_Type) return Boolean;\n+   Enable_Handling_Of_Equivalence : Boolean := True;\n+   --  This constant should only be set to False when no particular handling\n+   --  of equivalence over elements is needed, that is, Equivalent_Elements\n+   --  defines an element uniquely.\n \n package Ada.Containers.Functional_Sets with SPARK_Mode is\n \n@@ -49,6 +53,9 @@ package Ada.Containers.Functional_Sets with SPARK_Mode is\n    --  Sets are empty when default initialized.\n    --  \"For in\" quantification over sets should not be used.\n    --  \"For of\" quantification over sets iterates over elements.\n+   --  Note that, for proof, \"for of\" quantification is understood modulo\n+   --  equivalence (quantification includes elements equivalent to elements of\n+   --  the map).\n \n    -----------------------\n    --  Basic operations --\n@@ -59,9 +66,17 @@ package Ada.Containers.Functional_Sets with SPARK_Mode is\n    --  against overflows but it is not actually modeled.\n \n    function Contains (Container : Set; Item : Element_Type) return Boolean with\n-     Global => null;\n    --  Return True if Item is contained in Container\n \n+     Global => null,\n+     Post   =>\n+       (if Enable_Handling_Of_Equivalence then\n+\n+          --  Contains returns the same result on all equivalent elements\n+\n+          (if (for some E of Container => Equivalent_Elements (E, Item)) then\n+             Contains'Result));\n+\n    function Length (Container : Set) return Count_Type with\n      Global => null;\n    --  Return the number of elements in Container"}]}