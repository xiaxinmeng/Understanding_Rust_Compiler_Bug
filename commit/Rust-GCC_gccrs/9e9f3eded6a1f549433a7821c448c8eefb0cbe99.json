{"sha": "9e9f3eded6a1f549433a7821c448c8eefb0cbe99", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWU5ZjNlZGVkNmExZjU0OTQzM2E3ODIxYzQ0OGM4ZWVmYjBjYmU5OQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2001-07-16T00:28:20Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2001-07-16T00:28:20Z"}, "message": "machmode.def (Pmode): Redefine if GENERATOR_FILE.\n\n        * machmode.def (Pmode): Redefine if GENERATOR_FILE.\n        * genrecog.c (maybe_both_true_mode): New.\n        (maybe_both_true_2): Use it.\n        (write_switch): Don't put Pmode in a switch.\n        * rtl.c (mode arrays): Don't explicitly size them.\n\nFrom-SVN: r44029", "tree": {"sha": "3979093e16abc21060c0838e4098170a76535cc1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3979093e16abc21060c0838e4098170a76535cc1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9e9f3eded6a1f549433a7821c448c8eefb0cbe99", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e9f3eded6a1f549433a7821c448c8eefb0cbe99", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e9f3eded6a1f549433a7821c448c8eefb0cbe99", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e9f3eded6a1f549433a7821c448c8eefb0cbe99/comments", "author": null, "committer": null, "parents": [{"sha": "25dfa34d5009fcde9c21fb3956e36c1d13f810f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25dfa34d5009fcde9c21fb3956e36c1d13f810f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/25dfa34d5009fcde9c21fb3956e36c1d13f810f4"}], "stats": {"total": 71, "additions": 58, "deletions": 13}, "files": [{"sha": "5ed36cc51c793d6001a072536275ae5de584c725", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e9f3eded6a1f549433a7821c448c8eefb0cbe99/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e9f3eded6a1f549433a7821c448c8eefb0cbe99/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9e9f3eded6a1f549433a7821c448c8eefb0cbe99", "patch": "@@ -1,3 +1,11 @@\n+2001-07-15  Richard Henderson  <rth@redhat.com>\n+\n+\t* machmode.def (Pmode): Redefine if GENERATOR_FILE.\n+\t* genrecog.c (maybe_both_true_mode): New.\n+\t(maybe_both_true_2): Use it.\n+\t(write_switch): Don't put Pmode in a switch.\n+\t* rtl.c (mode arrays): Don't explicitly size them.\n+\n Sun Jul 15 14:07:36 CEST 2001  Jan Hubicka  <jh@suse.cz>\n \n \t* toplev.c (rest_of_compilation): Fix register_life_up_to_date"}, {"sha": "c3a7fea8549143291338f74a7b0f23e2fe9b28de", "filename": "gcc/genrecog.c", "status": "modified", "additions": 35, "deletions": 2, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e9f3eded6a1f549433a7821c448c8eefb0cbe99/gcc%2Fgenrecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e9f3eded6a1f549433a7821c448c8eefb0cbe99/gcc%2Fgenrecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenrecog.c?ref=9e9f3eded6a1f549433a7821c448c8eefb0cbe99", "patch": "@@ -238,6 +238,8 @@ static void validate_pattern\n static struct decision *add_to_sequence\n   PARAMS ((rtx, struct decision_head *, const char *, enum routine_type, int));\n \n+static int maybe_both_true_mode\n+  PARAMS ((enum machine_mode, enum machine_mode));\n static int maybe_both_true_2\n   PARAMS ((struct decision_test *, struct decision_test *));\n static int maybe_both_true_1\n@@ -1054,6 +1056,29 @@ add_to_sequence (pattern, last, position, insn_type, top)\n   return sub;\n }\n \f\n+/* A subroutine of maybe_both_true; compares two modes.\n+   Returns > 0 for \"definitely both true\" and < 0 for \"maybe both true\".  */\n+\n+static int\n+maybe_both_true_mode (m1, m2)\n+     enum machine_mode m1, m2;\n+{\n+  enum mode_class other_mode_class;\n+\n+  /* Pmode is not a distinct mode.  We do know that it is\n+     either MODE_INT or MODE_PARTIAL_INT though.  */\n+  if (m1 == Pmode)\n+    other_mode_class = GET_MODE_CLASS (m2);\n+  else if (m2 == Pmode)\n+    other_mode_class = GET_MODE_CLASS (m1);\n+  else\n+    return m1 == m2;\n+\n+  return (other_mode_class == MODE_INT\n+\t  || other_mode_class == MODE_PARTIAL_INT\n+\t  ? -1 : 0);\n+}\n+\n /* A subroutine of maybe_both_true; examines only one test.\n    Returns > 0 for \"definitely both true\" and < 0 for \"maybe both true\".  */\n \n@@ -1066,7 +1091,7 @@ maybe_both_true_2 (d1, d2)\n       switch (d1->type)\n \t{\n \tcase DT_mode:\n-\t  return d1->u.mode == d2->u.mode;\n+\t  return maybe_both_true_mode (d1->u.mode, d2->u.mode);\n \n \tcase DT_code:\n \t  return d1->u.code == d2->u.code;\n@@ -1102,7 +1127,7 @@ maybe_both_true_2 (d1, d2)\n \t{\n \t  if (d2->type == DT_mode)\n \t    {\n-\t      if (d1->u.pred.mode != d2->u.mode\n+\t      if (maybe_both_true_mode (d1->u.pred.mode, d2->u.mode) == 0\n \t\t  /* The mode of an address_operand predicate is the\n \t\t     mode of the memory, not the operand.  It can only\n \t\t     be used for testing the predicate, so we must\n@@ -1884,6 +1909,10 @@ write_switch (start, depth)\n \t   || type == DT_elt_one_int\n \t   || type == DT_elt_zero_wide_safe)\n     {\n+      /* Pmode may not be a compile-time constant.  */\n+      if (type == DT_mode && p->tests->u.mode == Pmode)\n+\treturn p;\n+\n       printf (\"  switch (\");\n       switch (type)\n \t{\n@@ -1919,6 +1948,10 @@ write_switch (start, depth)\n \t    if (nodes_identical_1 (p->tests, q->tests))\n \t      goto case_done;\n \n+\t  /* Pmode may not be a compile-time constant.  */\n+\t  if (type == DT_mode && p->tests->u.mode == Pmode)\n+\t    goto case_done;\n+\n \t  if (p != start && p->need_label && needs_label == NULL)\n \t    needs_label = p;\n "}, {"sha": "1c93c0498bfa26ff537e51bb22c0131cd81b6b6d", "filename": "gcc/machmode.def", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e9f3eded6a1f549433a7821c448c8eefb0cbe99/gcc%2Fmachmode.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e9f3eded6a1f549433a7821c448c8eefb0cbe99/gcc%2Fmachmode.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmachmode.def?ref=9e9f3eded6a1f549433a7821c448c8eefb0cbe99", "patch": "@@ -154,7 +154,14 @@ EXTRA_CC_MODES\n #undef CC\n \n /* The symbol Pmode stands for one of the above machine modes (usually SImode).\n-   The tm file specifies which one.  It is not a distinct mode.  */\n+   The tm file specifies which one.  It is not a distinct mode.  Nevertheless,\n+   while processing the md file, we wish to treat as a distinct mode so that \n+   it is preserved intact through to the insn-foo.c files.  This eliminates a\n+   lot of redundancy in ports that support both 32-bit and 64-bit targets.  */\n+#ifdef GENERATOR_FILE\n+#undef Pmode\n+DEF_MACHMODE (Pmode, \"P\", MODE_RANDOM, 0, 0, 0, VOIDmode)\n+#endif\n \n /*\n Local variables:"}, {"sha": "c5dcb26086e70b691cd9df9d493d1bd3d9168709", "filename": "gcc/rtl.c", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e9f3eded6a1f549433a7821c448c8eefb0cbe99/gcc%2Frtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e9f3eded6a1f549433a7821c448c8eefb0cbe99/gcc%2Frtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.c?ref=9e9f3eded6a1f549433a7821c448c8eefb0cbe99", "patch": "@@ -117,11 +117,8 @@ const char * const rtx_name[] = {\n \n #define DEF_MACHMODE(SYM, NAME, CLASS, BITSIZE, SIZE, UNIT, WIDER)  NAME,\n \n-const char * const mode_name[(int) MAX_MACHINE_MODE + 1] = {\n+const char * const mode_name[] = {\n #include \"machmode.def\"\n-  /* Add an extra field to avoid a core dump if someone tries to convert\n-     MAX_MACHINE_MODE to a string.   */\n-  \"\"\n };\n \n #undef DEF_MACHMODE\n@@ -130,7 +127,7 @@ const char * const mode_name[(int) MAX_MACHINE_MODE + 1] = {\n \n #define DEF_MACHMODE(SYM, NAME, CLASS, BITSIZE, SIZE, UNIT, WIDER)  CLASS,\n \n-const enum mode_class mode_class[(int) MAX_MACHINE_MODE] = {\n+const enum mode_class mode_class[] = {\n #include \"machmode.def\"\n };\n \n@@ -141,7 +138,7 @@ const enum mode_class mode_class[(int) MAX_MACHINE_MODE] = {\n \n #define DEF_MACHMODE(SYM, NAME, CLASS, BITSIZE, SIZE, UNIT, WIDER)  BITSIZE,\n \n-const unsigned int mode_bitsize[(int) MAX_MACHINE_MODE] = {\n+const unsigned int mode_bitsize[] = {\n #include \"machmode.def\"\n };\n \n@@ -152,7 +149,7 @@ const unsigned int mode_bitsize[(int) MAX_MACHINE_MODE] = {\n \n #define DEF_MACHMODE(SYM, NAME, CLASS, BITSIZE, SIZE, UNIT, WIDER)  SIZE,\n \n-const unsigned int mode_size[(int) MAX_MACHINE_MODE] = {\n+const unsigned int mode_size[] = {\n #include \"machmode.def\"\n };\n \n@@ -163,7 +160,7 @@ const unsigned int mode_size[(int) MAX_MACHINE_MODE] = {\n \n #define DEF_MACHMODE(SYM, NAME, CLASS, BITSIZE, SIZE, UNIT, WIDER)  UNIT,\n \n-const unsigned int mode_unit_size[(int) MAX_MACHINE_MODE] = {\n+const unsigned int mode_unit_size[] = {\n #include \"machmode.def\"\t\t/* machine modes are documented here */\n };\n \n@@ -176,7 +173,7 @@ const unsigned int mode_unit_size[(int) MAX_MACHINE_MODE] = {\n #define DEF_MACHMODE(SYM, NAME, CLASS, BITSIZE, SIZE, UNIT, WIDER)  \\\n   (unsigned char) WIDER,\n \n-const unsigned char mode_wider_mode[(int) MAX_MACHINE_MODE] = {\n+const unsigned char mode_wider_mode[] = {\n #include \"machmode.def\"\t\t/* machine modes are documented here */\n };\n \n@@ -187,7 +184,7 @@ const unsigned char mode_wider_mode[(int) MAX_MACHINE_MODE] = {\n \n /* Indexed by machine mode, gives mask of significant bits in mode.  */\n \n-const unsigned HOST_WIDE_INT mode_mask_array[(int) MAX_MACHINE_MODE] = {\n+const unsigned HOST_WIDE_INT mode_mask_array[] = {\n #include \"machmode.def\"\n };\n "}]}