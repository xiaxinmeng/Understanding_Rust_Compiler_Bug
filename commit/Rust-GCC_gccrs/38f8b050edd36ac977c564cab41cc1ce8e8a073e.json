{"sha": "38f8b050edd36ac977c564cab41cc1ce8e8a073e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzhmOGIwNTBlZGQzNmFjOTc3YzU2NGNhYjQxY2MxY2U4ZThhMDczZQ==", "commit": {"author": {"name": "Joern Rennecke", "email": "joern.rennecke@embecosm.com", "date": "2010-06-29T18:22:00Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "2010-06-29T18:22:00Z"}, "message": "re PR other/44034 (target hooks are hard to maintain)\n\ngcc:\n\tPR other/44034\n\t* target.def, doc/tm.texi.in, genhooks.c: New files.\n\t* target.h: Instead of defining individual hook members,\n\tdefine DEFHOOKPOD / DEFHOOK / DEFHOOK_UNDOC / HOOKSTRUCT and\n\tinclude target.def.\n\t* target-def.h: Instead of defining individual hook initializers,\n\tinclude target-hooks-def.h.\n\t* df-scan.c, haifa-sched.c, sel-sched.c: Rename targetm members:\n\ttargetm.live_on_entry -> targetm.extra_live_on_entry\n\ttargetm.sched.md_finish ->targetm.sched.finish\n\ttargetm.sched.md_init -> targetm.sched.init\n\ttargetm.sched.md_init_global -> targetm.sched.init_global\n\ttargetm.asm_out.unwind_label -> targetm.asm_out.emit_unwind_label\n\ttargetm.asm_out.except_table_label ->\n\t  targetm.asm_out.emit_except_table_label\n\ttargetm.asm_out.visibility -> targetm.asm_out.assemble_visibility\n\ttargetm.target_help -> targetm.help\n\ttargetm.vectorize.builtin_support_vector_misalignment ->\n\t  targetm.vectorize.support_vector_misalignment\n\ttargetm.file_start_app_off -> targetm.asm_file_start_app_off\n\ttargetm.file_start_file_directive ->\n\t targetm.asm_file_start_file_directive\n\t* dwarf2out.c, opts.c, tree-vect-data-refs.c, except.c: Likewise.\n\t* varasm.c, config/alpha/alpha.c, config/cris/cris.c: Likewise.\n\t* gcc/config/spu/spu.c, config/ia64/ia64.c: Rename target macros:\n\tTARGET_VECTOR_ALIGNMENT_REACHABLE ->\n\t  TARGET_VECTORIZE_VECTOR_ALIGNMENT_REACHABLE\n\tTARGET_SUPPORT_VECTOR_MISALIGNMENT ->\n\t  TARGET_VECTORIZE_SUPPORT_VECTOR_MISALIGNMENT\n\tTARGET_UNWIND_EMIT -> TARGET_ASM_UNWIND_EMIT\n\t* config/rs6000/rs6000.c, config/arm/arm.c: Likewise.\n\t* Makefile.in (TARGET_H): Depend on target.def.\n\t(TARGET_DEF_H): Depend on target-hooks-def.h.\n\t(target-hooks-def.h, tm.texi, s-target-hooks-def-h): New rules.\n\t(s-tm-texi, build/genhooks.o, build/genhooks): Likewise.\n\t* doc/tm.texi: Regenerate.\ngcc/c-family:\n\t* c-common.c: Rename targetm member:\n\ttargetm.enum_va_list -> targetm.enum_va_list_p\ngcc/po:\n\t* EXCLUDES: Add genhooks.c.\nIndex: gcc/doc/tm.texi\n\nFrom-SVN: r161547", "tree": {"sha": "00306b498ac87b11ae440e5a79b7b5301dea1ab1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/00306b498ac87b11ae440e5a79b7b5301dea1ab1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/38f8b050edd36ac977c564cab41cc1ce8e8a073e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38f8b050edd36ac977c564cab41cc1ce8e8a073e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/38f8b050edd36ac977c564cab41cc1ce8e8a073e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38f8b050edd36ac977c564cab41cc1ce8e8a073e/comments", "author": {"login": "amylaar", "id": 1663475, "node_id": "MDQ6VXNlcjE2NjM0NzU=", "avatar_url": "https://avatars.githubusercontent.com/u/1663475?v=4", "gravatar_id": "", "url": "https://api.github.com/users/amylaar", "html_url": "https://github.com/amylaar", "followers_url": "https://api.github.com/users/amylaar/followers", "following_url": "https://api.github.com/users/amylaar/following{/other_user}", "gists_url": "https://api.github.com/users/amylaar/gists{/gist_id}", "starred_url": "https://api.github.com/users/amylaar/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/amylaar/subscriptions", "organizations_url": "https://api.github.com/users/amylaar/orgs", "repos_url": "https://api.github.com/users/amylaar/repos", "events_url": "https://api.github.com/users/amylaar/events{/privacy}", "received_events_url": "https://api.github.com/users/amylaar/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c75c86636fb6e359e0164fb228577ffe70c6d3af", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c75c86636fb6e359e0164fb228577ffe70c6d3af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c75c86636fb6e359e0164fb228577ffe70c6d3af"}], "stats": {"total": 16328, "additions": 14037, "deletions": 2291}, "files": [{"sha": "c743a55b7b1ba2c4efe04de39f2c706c25c47495", "filename": "gcc/ChangeLog", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38f8b050edd36ac977c564cab41cc1ce8e8a073e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38f8b050edd36ac977c564cab41cc1ce8e8a073e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=38f8b050edd36ac977c564cab41cc1ce8e8a073e", "patch": "@@ -1,3 +1,42 @@\n+2010-06-29  Joern Rennecke  <joern.rennecke@embecosm.com>\n+\n+\tPR other/44034\n+\t* target.def, doc/tm.texi.in, genhooks.c: New files.\n+\t* target.h: Instead of defining individual hook members,\n+\tdefine DEFHOOKPOD / DEFHOOK / DEFHOOK_UNDOC / HOOKSTRUCT and\n+\tinclude target.def.\n+\t* target-def.h: Instead of defining individual hook initializers,\n+\tinclude target-hooks-def.h.\n+\t* df-scan.c, haifa-sched.c, sel-sched.c: Rename targetm members:\n+\ttargetm.live_on_entry -> targetm.extra_live_on_entry\n+\ttargetm.sched.md_finish ->targetm.sched.finish\n+\ttargetm.sched.md_init -> targetm.sched.init\n+\ttargetm.sched.md_init_global -> targetm.sched.init_global\n+\ttargetm.asm_out.unwind_label -> targetm.asm_out.emit_unwind_label\n+\ttargetm.asm_out.except_table_label ->\n+\t  targetm.asm_out.emit_except_table_label\n+\ttargetm.asm_out.visibility -> targetm.asm_out.assemble_visibility\n+\ttargetm.target_help -> targetm.help\n+\ttargetm.vectorize.builtin_support_vector_misalignment ->\n+\t  targetm.vectorize.support_vector_misalignment\n+\ttargetm.file_start_app_off -> targetm.asm_file_start_app_off\n+\ttargetm.file_start_file_directive ->\n+\t targetm.asm_file_start_file_directive\n+\t* dwarf2out.c, opts.c, tree-vect-data-refs.c, except.c: Likewise.\n+\t* varasm.c, config/alpha/alpha.c, config/cris/cris.c: Likewise.\n+\t* gcc/config/spu/spu.c, config/ia64/ia64.c: Rename target macros:\n+\tTARGET_VECTOR_ALIGNMENT_REACHABLE ->\n+\t  TARGET_VECTORIZE_VECTOR_ALIGNMENT_REACHABLE\n+\tTARGET_SUPPORT_VECTOR_MISALIGNMENT ->\n+\t  TARGET_VECTORIZE_SUPPORT_VECTOR_MISALIGNMENT\n+\tTARGET_UNWIND_EMIT -> TARGET_ASM_UNWIND_EMIT\n+\t* config/rs6000/rs6000.c, config/arm/arm.c: Likewise.\n+\t* Makefile.in (TARGET_H): Depend on target.def.\n+\t(TARGET_DEF_H): Depend on target-hooks-def.h.\n+\t(target-hooks-def.h, tm.texi, s-target-hooks-def-h): New rules.\n+\t(s-tm-texi, build/genhooks.o, build/genhooks): Likewise.\n+\t* doc/tm.texi: Regenerate.\n+\n 2010-06-29  Nathan Froyd  <froydnj@codesourcery.com>\n \n \tPR bootstrap/44713"}, {"sha": "34ce10185f37a8ab54a5ab119ff64193ccb95ed3", "filename": "gcc/Makefile.in", "status": "modified", "additions": 34, "deletions": 2, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38f8b050edd36ac977c564cab41cc1ce8e8a073e/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38f8b050edd36ac977c564cab41cc1ce8e8a073e/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=38f8b050edd36ac977c564cab41cc1ce8e8a073e", "patch": "@@ -861,12 +861,12 @@ endif\n VEC_H = vec.h statistics.h\n EXCEPT_H = except.h $(HASHTAB_H) vecprim.h vecir.h\n TOPLEV_H = toplev.h $(INPUT_H) bversion.h $(DIAGNOSTIC_CORE_H)\n-TARGET_H = $(TM_H) target.h insn-modes.h\n+TARGET_H = $(TM_H) target.h target.def insn-modes.h\n MACHMODE_H = machmode.h mode-classes.def insn-modes.h\n HOOKS_H = hooks.h $(MACHMODE_H)\n HOSTHOOKS_DEF_H = hosthooks-def.h $(HOOKS_H)\n LANGHOOKS_DEF_H = langhooks-def.h $(HOOKS_H)\n-TARGET_DEF_H = target-def.h $(HOOKS_H) targhooks.h\n+TARGET_DEF_H = target-def.h target-hooks-def.h $(HOOKS_H) targhooks.h\n RTL_BASE_H = rtl.h rtl.def $(MACHMODE_H) reg-notes.def insn-notes.def \\\n   $(INPUT_H) $(REAL_H) statistics.h $(VEC_H) $(FIXED_VALUE_H) alias.h\n FIXED_VALUE_H = fixed-value.h $(MACHMODE_H) double-int.h\n@@ -3674,6 +3674,36 @@ s-constrs-h: $(MD_DEPS) build/genpreds$(build_exeext)\n \t$(SHELL) $(srcdir)/../move-if-change tmp-constrs.h tm-constrs.h\n \t$(STAMP) s-constrs-h\n \n+target-hooks-def.h: s-target-hooks-def-h; @true\n+tm.texi: s-tm-texi; @true\n+\n+s-target-hooks-def-h: build/genhooks$(build_exeext)\n+\t$(RUN_GEN) build/genhooks$(build_exeext) > tmp-target-hooks-def.h\n+\t$(SHELL) $(srcdir)/../move-if-change tmp-target-hooks-def.h \\\n+\t\t\t\t\t     target-hooks-def.h\n+\t$(STAMP) s-target-hooks-def-h\n+\n+# check if someone mistakenly only changed tm.texi.\n+s-tm-texi: $(srcdir)/doc/tm.texi\n+\t\n+s-tm-texi: build/genhooks$(build_exeext) $(srcdir)/doc/tm.texi.in\n+\t$(RUN_GEN) build/genhooks$(build_exeext) \\\n+\t\t\t$(srcdir)/doc/tm.texi.in > tmp-tm.texi\n+\t$(SHELL) $(srcdir)/../move-if-change tmp-tm.texi tm.texi\n+\t@if cmp -s $(srcdir)/doc/tm.texi tm.texi; then \\\n+\t  $(STAMP) $@; \\\n+\telif test $(srcdir)/doc/tm.texi -nt $(srcdir)/doc/tm.texi.in \\\n+\t  && test $(srcdir)/doc/tm.texi -nt $(srcdir)/doc/target.def; then \\\n+\t  echo >&2 ; \\\n+\t  echo You should edit $(srcdir)/doc/tm.texi.in rather than $(srcdir)/doc/tm.texi . >&2 ; \\\n+\t  false; \\\n+\telse \\\n+\t  echo >&2 ; \\\n+\t  echo Verify that you have permission to grant a GFDL license for all >&2 ; \\\n+\t  echo new text in tm.texi, then copy it to $(srcdir)/doc/tm.texi. >&2 ; \\\n+\t  false; \\\n+\tfi\n+\n GTFILES = $(CPP_ID_DATA_H) $(srcdir)/input.h $(srcdir)/coretypes.h \\\n   $(srcdir)/vecprim.h $(srcdir)/vecir.h \\\n   $(host_xm_file_list) \\\n@@ -3852,6 +3882,7 @@ build/genpreds.o : genpreds.c $(RTL_BASE_H) $(BCONFIG_H) $(SYSTEM_H)\t\\\n   coretypes.h $(GTM_H) errors.h $(READ_MD_H) gensupport.h $(OBSTACK_H)\n build/genrecog.o : genrecog.c $(RTL_BASE_H) $(BCONFIG_H) $(SYSTEM_H)\t\\\n   coretypes.h $(GTM_H) errors.h $(READ_MD_H) gensupport.h\n+build/genhooks.o : genhooks.c target.def $(BCONFIG_H) $(SYSTEM_H) errors.h\n \n # Compile the programs that generate insn-* from the machine description.\n # They are compiled with $(COMPILER_FOR_BUILD), and associated libraries,\n@@ -3881,6 +3912,7 @@ build/genautomata$(build_exeext) : BUILD_LIBS += -lm\n \n # These programs are not linked with the MD reader.\n build/gengtype$(build_exeext) : build/gengtype-lex.o build/gengtype-parse.o\n+build/genhooks$(build_exeext) : $(BUILD_ERRORS)\n \n # Generated source files for gengtype.\n gengtype-lex.c : gengtype-lex.l"}, {"sha": "96caffcc6896364172b8f17d059d8acab3512c9d", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38f8b050edd36ac977c564cab41cc1ce8e8a073e/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38f8b050edd36ac977c564cab41cc1ce8e8a073e/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=38f8b050edd36ac977c564cab41cc1ce8e8a073e", "patch": "@@ -1,3 +1,9 @@\n+2010-06-29  Joern Rennecke  <joern.rennecke@embecosm.com>\n+\n+\tPR other/44034\n+\t* c-common.c: Rename targetm member:\n+\ttargetm.enum_va_list -> targetm.enum_va_list_p\n+\n 2010-06-28  Anatoly Sokolov  <aesok@post.ru>\n \n \t* c-common.c (shorten_compare): Adjust call to force_fit_type_double."}, {"sha": "324c28aa1146758b188f6504cb302362408aa1c2", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38f8b050edd36ac977c564cab41cc1ce8e8a073e/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38f8b050edd36ac977c564cab41cc1ce8e8a073e/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=38f8b050edd36ac977c564cab41cc1ce8e8a073e", "patch": "@@ -4906,13 +4906,13 @@ c_common_nodes_and_builtins (void)\n     (build_decl (UNKNOWN_LOCATION,\n \t\t TYPE_DECL, get_identifier (\"__builtin_va_list\"),\n \t\t va_list_type_node));\n-  if (targetm.enum_va_list)\n+  if (targetm.enum_va_list_p)\n     {\n       int l;\n       const char *pname;\n       tree ptype;\n \n-      for (l = 0; targetm.enum_va_list (l, &pname, &ptype); ++l)\n+      for (l = 0; targetm.enum_va_list_p (l, &pname, &ptype); ++l)\n \t{\n \t  lang_hooks.decls.pushdecl\n \t    (build_decl (UNKNOWN_LOCATION,"}, {"sha": "cfa367fb764a17b71428598f5de28747d2e2eb69", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38f8b050edd36ac977c564cab41cc1ce8e8a073e/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38f8b050edd36ac977c564cab41cc1ce8e8a073e/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=38f8b050edd36ac977c564cab41cc1ce8e8a073e", "patch": "@@ -9742,7 +9742,7 @@ alpha_file_start (void)\n   /* If emitting dwarf2 debug information, we cannot generate a .file\n      directive to start the file, as it will conflict with dwarf2out\n      file numbers.  So it's only useful when emitting mdebug output.  */\n-  targetm.file_start_file_directive = (write_symbols == DBX_DEBUG);\n+  targetm.asm_file_start_file_directive = (write_symbols == DBX_DEBUG);\n #endif\n \n   default_file_start ();"}, {"sha": "9cb272c323e5aef0927a70a10c03226bf06191ca", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38f8b050edd36ac977c564cab41cc1ce8e8a073e/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38f8b050edd36ac977c564cab41cc1ce8e8a073e/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=38f8b050edd36ac977c564cab41cc1ce8e8a073e", "patch": "@@ -434,8 +434,8 @@ static const struct attribute_spec arm_attribute_table[] =\n #define TARGET_MUST_PASS_IN_STACK arm_must_pass_in_stack\n \n #ifdef TARGET_UNWIND_INFO\n-#undef TARGET_UNWIND_EMIT\n-#define TARGET_UNWIND_EMIT arm_unwind_emit\n+#undef TARGET_ASM_UNWIND_EMIT\n+#define TARGET_ASM_UNWIND_EMIT arm_unwind_emit\n \n /* EABI unwinding tables use a different format for the typeinfo tables.  */\n #undef TARGET_ASM_TTYPE"}, {"sha": "05736c761651379351f78d16779904f4168bd0dc", "filename": "gcc/config/cris/cris.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38f8b050edd36ac977c564cab41cc1ce8e8a073e/gcc%2Fconfig%2Fcris%2Fcris.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38f8b050edd36ac977c564cab41cc1ce8e8a073e/gcc%2Fconfig%2Fcris%2Fcris.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.c?ref=38f8b050edd36ac977c564cab41cc1ce8e8a073e", "patch": "@@ -2571,8 +2571,8 @@ cris_file_start (void)\n {\n   /* These expressions can vary at run time, so we cannot put\n      them into TARGET_INITIALIZER.  */\n-  targetm.file_start_app_off = !(TARGET_PDEBUG || flag_print_asm_name);\n-  targetm.file_start_file_directive = TARGET_ELF;\n+  targetm.asm_file_start_app_off = !(TARGET_PDEBUG || flag_print_asm_name);\n+  targetm.asm_file_start_file_directive = TARGET_ELF;\n \n   default_file_start ();\n }"}, {"sha": "511ca155ab1615fe52f0e0a79d68def122c2c92f", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38f8b050edd36ac977c564cab41cc1ce8e8a073e/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38f8b050edd36ac977c564cab41cc1ce8e8a073e/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=38f8b050edd36ac977c564cab41cc1ce8e8a073e", "patch": "@@ -510,8 +510,8 @@ static const struct attribute_spec ia64_attribute_table[] =\n #undef TARGET_GIMPLIFY_VA_ARG_EXPR\n #define TARGET_GIMPLIFY_VA_ARG_EXPR ia64_gimplify_va_arg\n \n-#undef TARGET_UNWIND_EMIT\n-#define TARGET_UNWIND_EMIT process_for_unwind_directive\n+#undef TARGET_ASM_UNWIND_EMIT\n+#define TARGET_ASM_UNWIND_EMIT process_for_unwind_directive\n \n #undef TARGET_SCALAR_MODE_SUPPORTED_P\n #define TARGET_SCALAR_MODE_SUPPORTED_P ia64_scalar_mode_supported_p"}, {"sha": "3d893722dda7f981b161382e0c6caf6dcaf2b3c1", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38f8b050edd36ac977c564cab41cc1ce8e8a073e/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38f8b050edd36ac977c564cab41cc1ce8e8a073e/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=38f8b050edd36ac977c564cab41cc1ce8e8a073e", "patch": "@@ -1462,11 +1462,11 @@ static const struct attribute_spec rs6000_attribute_table[] =\n #define TARGET_VECTORIZE_BUILTIN_CONVERSION rs6000_builtin_conversion\n #undef TARGET_VECTORIZE_BUILTIN_VEC_PERM\n #define TARGET_VECTORIZE_BUILTIN_VEC_PERM rs6000_builtin_vec_perm\n-#undef TARGET_SUPPORT_VECTOR_MISALIGNMENT\n-#define TARGET_SUPPORT_VECTOR_MISALIGNMENT\t\t\\\n+#undef TARGET_VECTORIZE_SUPPORT_VECTOR_MISALIGNMENT\n+#define TARGET_VECTORIZE_SUPPORT_VECTOR_MISALIGNMENT\t\t\\\n   rs6000_builtin_support_vector_misalignment\n-#undef TARGET_VECTOR_ALIGNMENT_REACHABLE\n-#define TARGET_VECTOR_ALIGNMENT_REACHABLE rs6000_vector_alignment_reachable\n+#undef TARGET_VECTORIZE_VECTOR_ALIGNMENT_REACHABLE\n+#define TARGET_VECTORIZE_VECTOR_ALIGNMENT_REACHABLE rs6000_vector_alignment_reachable\n \n #undef TARGET_INIT_BUILTINS\n #define TARGET_INIT_BUILTINS rs6000_init_builtins"}, {"sha": "8ae4e6053629da7814b5fe5cb1053e4a13c0aa21", "filename": "gcc/config/spu/spu.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38f8b050edd36ac977c564cab41cc1ce8e8a073e/gcc%2Fconfig%2Fspu%2Fspu.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38f8b050edd36ac977c564cab41cc1ce8e8a073e/gcc%2Fconfig%2Fspu%2Fspu.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.c?ref=38f8b050edd36ac977c564cab41cc1ce8e8a073e", "patch": "@@ -432,8 +432,8 @@ static const struct attribute_spec spu_attribute_table[] =\n #undef TARGET_VECTORIZE_BUILTIN_VECTORIZATION_COST\n #define TARGET_VECTORIZE_BUILTIN_VECTORIZATION_COST spu_builtin_vectorization_cost\n \n-#undef TARGET_VECTOR_ALIGNMENT_REACHABLE\n-#define TARGET_VECTOR_ALIGNMENT_REACHABLE spu_vector_alignment_reachable\n+#undef TARGET_VECTORIZE_VECTOR_ALIGNMENT_REACHABLE\n+#define TARGET_VECTORIZE_VECTOR_ALIGNMENT_REACHABLE spu_vector_alignment_reachable\n \n #undef TARGET_VECTORIZE_BUILTIN_VEC_PERM\n #define TARGET_VECTORIZE_BUILTIN_VEC_PERM spu_builtin_vec_perm"}, {"sha": "b4633abfb10c29efdc2439fcaa73d4f251793c50", "filename": "gcc/df-scan.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38f8b050edd36ac977c564cab41cc1ce8e8a073e/gcc%2Fdf-scan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38f8b050edd36ac977c564cab41cc1ce8e8a073e/gcc%2Fdf-scan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-scan.c?ref=38f8b050edd36ac977c564cab41cc1ce8e8a073e", "patch": "@@ -3922,7 +3922,7 @@ df_get_entry_block_def_set (bitmap entry_block_defs)\n     bitmap_set_bit (entry_block_defs, REGNO (INCOMING_RETURN_ADDR_RTX));\n #endif\n \n-  targetm.live_on_entry (entry_block_defs);\n+  targetm.extra_live_on_entry (entry_block_defs);\n }\n \n "}, {"sha": "be04c38f50b8ec5affbad1abac90317f4c49a7a9", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 8, "deletions": 18, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38f8b050edd36ac977c564cab41cc1ce8e8a073e/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38f8b050edd36ac977c564cab41cc1ce8e8a073e/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=38f8b050edd36ac977c564cab41cc1ce8e8a073e", "patch": "@@ -4425,8 +4425,7 @@ specially by the compiler and was not mentioned in the C code being\n compiled.\n @end defmac\n \n-@deftypefn {Target Hook} rtx TARGET_LIBCALL_VALUE (enum machine_mode\n-@var{mode}, const_rtx @var{fun})\n+@deftypefn {Target Hook} rtx TARGET_LIBCALL_VALUE (enum machine_mode @var{mode}, const_rtx @var{fun})\n Define this hook if the back-end needs to know the name of the libcall\n function in order to determine where the result should be returned.  \n \n@@ -5744,7 +5743,7 @@ return type of the vectorized function shall be of vector type\n @var{vec_type_out} and the argument types should be @var{vec_type_in}.\n @end deftypefn\n \n-@deftypefn {Target Hook} bool TARGET_SUPPORT_VECTOR_MISALIGNMENT (enum machine_mode @var{mode}, const_tree @var{type}, int @var{misalignment}, bool @var{is_packed})\n+@deftypefn {Target Hook} bool TARGET_VECTORIZE_SUPPORT_VECTOR_MISALIGNMENT (enum machine_mode @var{mode}, const_tree @var{type}, int @var{misalignment}, bool @var{is_packed})\n This hook should return true if the target supports misaligned vector\n store/load of a specific factor denoted in the @var{misalignment}\n parameter.  The vector store/load should be of machine mode @var{mode} and\n@@ -8693,7 +8692,7 @@ to be broken up according to function.\n The default is that no label is emitted.\n @end deftypefn\n \n-@deftypefn {Target Hook} void TARGET_UNWIND_EMIT (FILE *@var{stream}, rtx @var{insn})\n+@deftypefn {Target Hook} void TARGET_ASM_UNWIND_EMIT (FILE *@var{stream}, rtx @var{insn})\n This target hook emits assembly directives required to unwind the\n given instruction.  This is only used when TARGET_UNWIND_INFO is set.\n @end deftypefn\n@@ -8757,7 +8756,7 @@ default.\n \n @defmac TARGET_UNWIND_INFO\n Define this macro if your target has ABI specified unwind tables.  Usually\n-these will be output by @code{TARGET_UNWIND_EMIT}.\n+these will be output by @code{TARGET_ASM_UNWIND_EMIT}.\n @end defmac\n \n @deftypevr {Target Hook} bool TARGET_UNWIND_TABLES_DEFAULT\n@@ -9628,9 +9627,7 @@ to perform initial processing of the @samp{dllimport} and\n @end deftypefn\n \n @deftypefn {Target Hook} bool TARGET_VALID_DLLIMPORT_ATTRIBUTE_P (const_tree @var{decl})\n-@var{decl} is a variable or function with @code{__attribute__((dllimport))}\n-specified. Use this hook if the target needs to add extra validation\n-checks to @code{handle_dll_attribute}.\n+@var{decl} is a variable or function with @code{__attribute__((dllimport))} specified.  Use this hook if the target needs to add extra validation checks to @code{handle_dll_attribute}.\n @end deftypefn\n \n @defmac TARGET_DECLSPEC\n@@ -9902,7 +9899,7 @@ This hook should return @code{true} if the element size should be stored in\n array cookies.  The default is to return @code{false}.\n @end deftypefn\n \n-@deftypefn {Target Hook} int TARGET_CXX_IMPORT_EXPORT_CLASS (tree  @var{type}, int @var{import_export})\n+@deftypefn {Target Hook} int TARGET_CXX_IMPORT_EXPORT_CLASS (tree @var{type}, int @var{import_export})\n If defined by a backend this hook allows the decision made to export\n class @var{type} to be overruled.  Upon entry @var{import_export}\n will contain 1 if the class is going to be exported, @minus{}1 if it is going\n@@ -9928,12 +9925,7 @@ method.  The default is to return @code{true}.\n @end deftypefn\n \n @deftypefn {Target Hook} void TARGET_CXX_DETERMINE_CLASS_DATA_VISIBILITY (tree @var{decl})\n-@var{decl} is a virtual table, virtual table table, typeinfo object,\n-or other similar implicit class data object that will be emitted with\n-external linkage in this translation unit.  No ELF visibility has been\n-explicitly specified.  If the target needs to specify a visibility\n-other than that of the containing class, use this hook to set\n-@code{DECL_VISIBILITY} and @code{DECL_VISIBILITY_SPECIFIED}.\n+@var{decl} is a virtual table, virtual table table, typeinfo object, or other similar implicit class data object that will be emitted with external linkage in this translation unit.  No ELF visibility has been explicitly specified.  If the target needs to specify a visibility other than that of the containing class, use this hook to set @code{DECL_VISIBILITY} and @code{DECL_VISIBILITY_SPECIFIED}.\n @end deftypefn\n \n @deftypefn {Target Hook} bool TARGET_CXX_CLASS_DATA_ALWAYS_COMDAT (void)\n@@ -9965,9 +9957,7 @@ unloaded. The default is to return false.\n @end deftypefn\n \n @deftypefn {Target Hook} void TARGET_CXX_ADJUST_CLASS_AT_DEFINITION (tree @var{type})\n-@var{type} is a C++ class (i.e., RECORD_TYPE or UNION_TYPE) that has just been\n-defined.  Use this hook to make adjustments to the class (eg, tweak\n-visibility or perform any other required target modifications).\n+@var{type} is a C++ class (i.e., RECORD_TYPE or UNION_TYPE) that has just been defined.  Use this hook to make adjustments to the class (eg, tweak visibility or perform any other required target modifications).\n @end deftypefn\n \n @node Named Address Spaces"}, {"sha": "3c8c28d81bb9cd9c580563ca77bb8b4326889b38", "filename": "gcc/doc/tm.texi.in", "status": "added", "additions": 11171, "deletions": 0, "changes": 11171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38f8b050edd36ac977c564cab41cc1ce8e8a073e/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38f8b050edd36ac977c564cab41cc1ce8e8a073e/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=38f8b050edd36ac977c564cab41cc1ce8e8a073e"}, {"sha": "2dd8bccb41d441cca0e7c3ee12ad2e7061ae8733", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38f8b050edd36ac977c564cab41cc1ce8e8a073e/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38f8b050edd36ac977c564cab41cc1ce8e8a073e/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=38f8b050edd36ac977c564cab41cc1ce8e8a073e", "patch": "@@ -3463,8 +3463,8 @@ output_fde (dw_fde_ref fde, bool for_eh, bool second,\n   char l1[20], l2[20];\n   dw_cfi_ref cfi;\n \n-  targetm.asm_out.unwind_label (asm_out_file, fde->decl, for_eh,\n-\t\t\t\t/* empty */ 0);\n+  targetm.asm_out.emit_unwind_label (asm_out_file, fde->decl, for_eh,\n+\t\t\t\t     /* empty */ 0);\n   targetm.asm_out.internal_label (asm_out_file, FDE_LABEL,\n \t\t\t\t  for_eh + j);\n   ASM_GENERATE_INTERNAL_LABEL (l1, FDE_AFTER_SIZE_LABEL, for_eh + j);\n@@ -3680,7 +3680,8 @@ output_call_frame_info (int for_eh)\n \telse if (fde_needed_for_eh_p (&fde_table[i]))\n \t  any_eh_needed = true;\n \telse if (TARGET_USES_WEAK_UNWIND_INFO)\n-\t  targetm.asm_out.unwind_label (asm_out_file, fde_table[i].decl, 1, 1);\n+\t  targetm.asm_out.emit_unwind_label (asm_out_file, fde_table[i].decl,\n+\t\t\t\t\t     1, 1);\n \n       if (!any_eh_needed)\n \treturn;"}, {"sha": "419936a483858655540e8fee7641e2a3bb96a2fd", "filename": "gcc/except.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38f8b050edd36ac977c564cab41cc1ce8e8a073e/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38f8b050edd36ac977c564cab41cc1ce8e8a073e/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=38f8b050edd36ac977c564cab41cc1ce8e8a073e", "patch": "@@ -2930,7 +2930,7 @@ output_one_function_exception_table (const char * ARG_UNUSED (fnname),\n #endif\n \n   /* If the target wants a label to begin the table, emit it here.  */\n-  targetm.asm_out.except_table_label (asm_out_file);\n+  targetm.asm_out.emit_except_table_label (asm_out_file);\n \n   have_tt_data = (VEC_length (tree, cfun->eh->ttype_data)\n \t\t  || (targetm.arm_eabi_unwinder"}, {"sha": "66d363387d29618a134ec279e1c527ea5a60bb94", "filename": "gcc/genhooks.c", "status": "added", "additions": 343, "deletions": 0, "changes": 343, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38f8b050edd36ac977c564cab41cc1ce8e8a073e/gcc%2Fgenhooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38f8b050edd36ac977c564cab41cc1ce8e8a073e/gcc%2Fgenhooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenhooks.c?ref=38f8b050edd36ac977c564cab41cc1ce8e8a073e", "patch": "@@ -0,0 +1,343 @@\n+/* Process target.def to create initialization macros definition in\n+   target-hooks-def.h and documentation in target-hooks.texi.\n+   Copyright (C) 2009, 2010 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+#include \"bconfig.h\"\n+#include \"system.h\"\n+#include <string.h>\n+#include \"hashtab.h\"\n+#include \"errors.h\"\n+\n+struct hook_desc { const char *doc, *type, *name, *param, *init; };\n+static struct hook_desc hook_array[] = {\n+#define HOOK_VECTOR_1(NAME, FRAGMENT) \\\n+  { 0, 0, #NAME, 0, 0 },\n+#define DEFHOOKPOD(NAME, DOC, TYPE, INIT) \\\n+  { DOC, #TYPE, HOOK_PREFIX #NAME, 0, #INIT },\n+#define DEFHOOK(NAME, DOC, TYPE, PARAMS, INIT) \\\n+  { DOC, #TYPE, HOOK_PREFIX #NAME, #PARAMS, #INIT },\n+#define DEFHOOK_UNDOC(NAME, DOC, TYPE, PARAMS, INIT) \\\n+  { \"*\", #TYPE, HOOK_PREFIX #NAME, #PARAMS, #INIT },\n+#include \"target.def\"\n+#undef DEFHOOK\n+};\n+\n+/* For each @Fcode in the the first paragraph of the documentation string DOC,\n+   print an @findex directive.  HOOK_NAME is the name of the hook this bit of\n+   documentation pertains to.  */\n+static void\n+emit_findices (const char *doc, const char *hook_name)\n+{\n+  const char *end = strstr (doc, \"\\n\\n\");\n+  const char *fcode;\n+\n+  while ((fcode = strstr (doc, \"@Fcode{\")) && (!end || fcode < end))\n+    {\n+      fcode += strlen (\"@Fcode{\");\n+      doc = strchr (fcode, '}');\n+      if (!doc)\n+\tfatal (\"Malformed @Fcode for hook %s\\n\", hook_name);\n+      printf (\"@findex %.*s\\n\", doc - fcode, fcode);\n+      doc = fcode;\n+    }\n+}\n+\n+/* Return an upper-case copy of IN.  */\n+static char *\n+upstrdup (const char *in)\n+{\n+  char *p, *ret = xstrdup (in);\n+  for (p = ret; *p; p++)\n+    *p = TOUPPER (*p);\n+  return ret;\n+}\n+\n+/* Struct for 'start hooks' which start a sequence of consecutive hooks\n+   that are defined in target.def and to be documented in tm.texi.  */\n+struct s_hook\n+{\n+  char *name;\n+  int pos;\n+};\n+\n+static hashval_t\n+s_hook_hash (const void *p)\n+{\n+  const struct s_hook *s_hook = (const struct s_hook *)p;\n+  return htab_hash_string (s_hook->name);\n+}\n+\n+static int\n+s_hook_eq_p (const void *p1, const void *p2)\n+{\n+  return (strcmp (((const struct s_hook *) p1)->name, \n+\t\t  ((const struct s_hook *) p2)->name) == 0);\n+}\n+\n+/* Read the documentation file with name IN_FNAME, perform substitutions\n+   to incorporate informtion from hook_array, and emit the result on stdout.\n+   Hooks defined with DEFHOOK / DEFHOOKPOD are emitted at the place of a\n+   matching @hook in the input file; if there is no matching @hook, the\n+   hook is emitted after the hook that precedes it in target.def .\n+   Usually, the emitted hook documentation starts with the hook\n+   signature, followed by the string from the doc field.\n+   The documentation is bracketed in @deftypefn / @deftypevr and a matching\n+   @end.\n+   While emitting the doc field, @Fcode is translated to @code, and an\n+   @findex entry is added to the affected paragraph.\n+   If the doc field starts with '*', the leading '*' is stripped, and the doc\n+   field is otherwise emitted unaltered; no function signature/\n+   @deftypefn/deftypevr/@end is emitted.\n+   In particular, a doc field of \"*\" means not to emit any ocumentation for\n+   this target.def / hook_array entry at all (there might be documentation\n+   for this hook in the file named IN_FNAME, though).\n+   A doc field of 0 is used to append the hook signature after the previous\n+   hook's signture, so that one description can be used for a group of hooks.\n+   When the doc field is \"\", @deftypefn/@deftypevr and the hook signature\n+   is emitted, but not the matching @end.  This allows all the free-form\n+   documentation to be placed in IN_FNAME, to work around GPL/GFDL\n+   licensing incompatibility issues.  */\n+static void\n+emit_documentation (const char *in_fname)\n+{\n+  int i, j;\n+  char buf[1000];\n+  htab_t start_hooks = htab_create (99, s_hook_hash, s_hook_eq_p, (htab_del) 0);\n+  FILE *f;\n+  bool found_start = false;\n+\n+  /* Enter all the start hooks in start_hooks.  */\n+  f = fopen (in_fname, \"r\");\n+  if (!f)\n+    {\n+      perror (\"\");\n+      fatal (\"Couldn't open input file\");\n+    }\n+  while (fscanf (f, \"%*[^@]\"), buf[0] = '\\0',\n+\t fscanf (f, \"@%5[^ \\n]\", buf) != EOF)\n+    {\n+      void **p;\n+      struct s_hook *shp;\n+\n+      if (strcmp (buf, \"hook\") != 0)\n+\tcontinue;\n+      buf[0] = '\\0';\n+      fscanf (f, \"%999s\", buf);\n+      shp = XNEW (struct s_hook);\n+      shp->name = upstrdup (buf);\n+      shp->pos = -1;\n+      p = htab_find_slot (start_hooks, shp, INSERT);\n+      if (*p != HTAB_EMPTY_ENTRY)\n+\tfatal (\"Duplicate placement for hook %s\\n\", shp->name);\n+      *(struct s_hook **) p = shp;\n+    }\n+  fclose (f);\n+  /* For each hook in hook_array, if it is a start hook, store its position.  */\n+  for (i = 0; i < (int) (sizeof hook_array / sizeof hook_array[0]); i++)\n+    {\n+      struct s_hook sh, *shp;\n+      void *p;\n+\n+      if (!hook_array[i].doc || strcmp (hook_array[i].doc, \"*\") == 0)\n+\tcontinue;\n+      sh.name = upstrdup (hook_array[i].name);\n+      p = htab_find (start_hooks, &sh);\n+      if (p)\n+\t{\n+\t  shp = (struct s_hook *) p;\n+\t  if (shp->pos >= 0)\n+\t    fatal (\"Duplicate hook %s\\n\", sh.name);\n+\t  shp->pos = i;\n+\t  found_start = true;\n+\t}\n+      else if (!found_start)\n+\tfatal (\"No place specified to document hook %s\\n\", sh.name);\n+      free (sh.name);\n+    }\n+  /* Copy input file to stdout, substituting @hook directives with the\n+     corresponding hook documentation sequences.  */\n+  f = fopen (in_fname, \"r\");\n+  if (!f)\n+    {\n+      perror (\"\");\n+      fatal (\"Couldn't open input file\");\n+    }\n+  for (;;)\n+    {\n+      struct s_hook sh, *shp;\n+      int c = getc (f);\n+      char *name;\n+\n+      if (c == EOF)\n+\tbreak;\n+      if (c != '@')\n+\t{\n+\t  putchar (c);\n+\t  continue;\n+\t}\n+      buf[0] = '\\0';\n+      fscanf (f, \"%5[^ \\n]\", buf);\n+      if (strcmp (buf, \"hook\") != 0)\n+\t{\n+\t  printf (\"@%s\", buf);\n+\t  continue;\n+\t}\n+      fscanf (f, \"%999s\", buf);\n+      sh.name = name = upstrdup (buf);\n+      shp = (struct s_hook *) htab_find (start_hooks, &sh);\n+      if (!shp || shp->pos < 0)\n+\tfatal (\"No documentation for hook %s\\n\", sh.name);\n+      i = shp->pos;\n+      do\n+\t{\n+\t  const char *q, *e;\n+\t  const char *deftype;\n+\t  const char *doc, *fcode, *p_end;\n+\n+\t  /* A leading '*' means to output the documentation string without\n+\t     further processing.  */\n+\t  if (*hook_array[i].doc == '*')\n+\t    printf (\"%s\", hook_array[i].doc + 1);\n+\t  else\n+\t    {\n+\t      if (i != shp->pos)\n+\t\tprintf (\"\\n\\n\");\n+\t      emit_findices (hook_array[i].doc, name);\n+\n+\t      /* Print header.  Function-valued hooks have a parameter list, \n+\t\t unlike POD-valued ones.  */\n+\t      deftype = hook_array[i].param ? \"deftypefn\" : \"deftypevr\";\n+\t      printf (\"@%s {Target Hook} \", deftype);\n+\t      if (strchr (hook_array[i].type, ' '))\n+\t\tprintf (\"{%s}\", hook_array[i].type);\n+\t      else\n+\t\tprintf (\"%s\", hook_array[i].type);\n+\t      printf (\" %s\", name);\n+\t      if (hook_array[i].param)\n+\t\t{\n+\t\t  /* Print the parameter list, with the parameter names\n+\t\t     enclosed in @var{}.  */\n+\t\t  printf (\" \");\n+\t\t  for (q = hook_array[i].param; (e = strpbrk (q, \" *,)\"));\n+\t\t       q = e + 1)\n+\t\t    /* Type names like 'int' are followed by a space, sometimes\n+\t\t       also by '*'.  'void' should appear only in \"(void)\".  */\n+\t\t    if (*e == ' ' || *e == '*' || *q == '(')\n+\t\t      printf (\"%.*s\", e - q + 1, q);\n+\t\t    else\n+\t\t      printf (\"@var{%.*s}%c\", e - q, q, *e);\n+\t\t}\n+\t      /* POD-valued hooks sometimes come in groups with common\n+\t\t documentation.*/\n+\t      for (j = i + 1;\n+\t\t   j < (int) (sizeof hook_array / sizeof hook_array[0])\n+\t\t   && hook_array[j].doc == 0 && hook_array[j].type; j++)\n+\t\t{\n+\t\t  char *namex = upstrdup (hook_array[j].name);\n+\n+\t\t  printf (\"\\n@%sx {Target Hook} {%s} %s\",\n+\t\t\t  deftype, hook_array[j].type, namex);\n+\t\t}\n+\t      if (hook_array[i].doc[0])\n+\t\t{\n+\t\t  printf (\"\\n\");\n+\t\t  /* Print each documentation paragraph in turn.  */\n+\t\t  for (doc = hook_array[i].doc; *doc; doc = p_end)\n+\t\t    {\n+\t\t      /* Find paragraph end.  */\n+\t\t      p_end = strstr (doc, \"\\n\\n\");\n+\t\t      p_end = (p_end ? p_end + 2 : doc + strlen (doc));\n+\t\t      /* Print paragraph, emitting @Fcode as @code.  */\n+\t\t      for (; (fcode = strstr (doc, \"@Fcode{\")) && fcode < p_end;\n+\t\t\t   doc = fcode + 2)\n+\t\t\tprintf (\"%.*s@\", fcode - doc, doc);\n+\t\t      printf (\"%.*s\", p_end - doc, doc);\n+\t\t      /* Emit function indices for next paragraph.  */\n+\t\t      emit_findices (p_end, name);\n+\t\t    }\n+\t\t  printf (\"\\n@end %s\", deftype);\n+\t\t}\n+\t    }\n+\t  if (++i >= (int) (sizeof hook_array / sizeof hook_array[0])\n+\t      || !hook_array[i].doc)\n+\t    break;\n+\t  free (name);\n+\t  sh.name = name = upstrdup (hook_array[i].name);\n+\t}\n+      while (!htab_find (start_hooks, &sh));\n+      free (name);\n+    }\n+}\n+\n+/* Emit #defines to stdout (this will be redirected to generate\n+   target-hook-def.h) which set target hooks initializer macros\n+   to their default values.  */\n+static void\n+emit_init_macros (void)\n+{\n+  int i;\n+  const int MAX_NEST = 2;\n+  int print_nest, nest = 0;\n+\n+  for (print_nest = 0; print_nest <= MAX_NEST; print_nest++)\n+    {\n+      for (i = 0; i < (int) (sizeof hook_array / sizeof hook_array[0]); i++)\n+\t{\n+\t  char *name = upstrdup (hook_array[i].name);\n+\n+\t  if (!hook_array[i].type)\n+\t    {\n+\t      if (*name)\n+\t\t{\n+\t\t  if (nest && nest == print_nest)\n+\t\t    printf (\"    %s, \\\\\\n\", name);\n+\t\t  nest++;\n+\t\t  if (nest > MAX_NEST)\n+\t\t    fatal (\"Unexpected nesting of %s\\n\", name);\n+\t\t  if (nest == print_nest)\n+\t\t    printf (\"\\n#define %s \\\\\\n  { \\\\\\n\", name);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  if (nest == print_nest)\n+\t\t    printf (\"  }\\n\");\n+\t\t  nest--;\n+\t\t}\n+\t      continue;\n+\t    }\n+\t  if (0 == print_nest)\n+\t    {\n+\t      /* Output default definitions of target hooks.  */\n+\t      printf (\"#ifndef %s\\n#define %s %s\\n#endif\\n\",\n+\t\t      name, name, hook_array[i].init);\n+\t    }\n+\t  if (nest == print_nest)\n+\t    printf (\"    %s, \\\\\\n\", name);\n+\t}\n+    }\n+}\n+\n+int\n+main (int argc, char **argv)\n+{\n+  if (argc >= 2)\n+    emit_documentation (argv[1]);\n+  else\n+    emit_init_macros ();\n+  return 0;\n+}"}, {"sha": "a5e1d3ffcf4a2bd6e45dc90f6b6c21eedafd766f", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38f8b050edd36ac977c564cab41cc1ce8e8a073e/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38f8b050edd36ac977c564cab41cc1ce8e8a073e/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=38f8b050edd36ac977c564cab41cc1ce8e8a073e", "patch": "@@ -1798,7 +1798,7 @@ schedule_insn (rtx insn)\n      forward dependencies for INSN anymore.  Nevertheless they are used in\n      heuristics in rank_for_schedule (), early_queue_to_ready () and in\n      some targets (e.g. rs6000).  Thus the earliest place where we *can*\n-     remove dependencies is after targetm.sched.md_finish () call in\n+     remove dependencies is after targetm.sched.finish () call in\n      schedule_block ().  But, on the other side, the safest place to remove\n      dependencies is when we are finishing scheduling entire region.  As we\n      don't generate [many] dependencies during scheduling itself, we won't\n@@ -2808,8 +2808,8 @@ schedule_block (basic_block *target_bb)\n   /* It is used for first cycle multipass scheduling.  */\n   temp_state = alloca (dfa_state_size);\n \n-  if (targetm.sched.md_init)\n-    targetm.sched.md_init (sched_dump, sched_verbose, ready.veclen);\n+  if (targetm.sched.init)\n+    targetm.sched.init (sched_dump, sched_verbose, ready.veclen);\n \n   /* We start inserting insns after PREV_HEAD.  */\n   last_scheduled_insn = prev_head;\n@@ -3283,9 +3283,9 @@ schedule_block (basic_block *target_bb)\n       fix_inter_tick (NEXT_INSN (prev_head), last_scheduled_insn);\n     }\n \n-  if (targetm.sched.md_finish)\n+  if (targetm.sched.finish)\n     {\n-      targetm.sched.md_finish (sched_dump, sched_verbose);\n+      targetm.sched.finish (sched_dump, sched_verbose);\n       /* Target might have added some instructions to the scheduled block\n \t in its md_finish () hook.  These new insns don't have any data\n \t initialized and to identify them we extend h_i_d so that they'll\n@@ -3444,9 +3444,8 @@ sched_init (void)\n \n   regstat_compute_calls_crossed ();\n \n-  if (targetm.sched.md_init_global)\n-    targetm.sched.md_init_global (sched_dump, sched_verbose,\n-\t\t\t\t  get_max_uid () + 1);\n+  if (targetm.sched.init_global)\n+    targetm.sched.init_global (sched_dump, sched_verbose, get_max_uid () + 1);\n \n   if (sched_pressure_p)\n     {\n@@ -3571,8 +3570,8 @@ sched_finish (void)\n     }\n   free (curr_state);\n \n-  if (targetm.sched.md_finish_global)\n-    targetm.sched.md_finish_global (sched_dump, sched_verbose);\n+  if (targetm.sched.finish_global)\n+    targetm.sched.finish_global (sched_dump, sched_verbose);\n \n   end_alias_analysis ();\n "}, {"sha": "07d7a23ae38471947c14c4957afa78aea114a56c", "filename": "gcc/opts.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38f8b050edd36ac977c564cab41cc1ce8e8a073e/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38f8b050edd36ac977c564cab41cc1ce8e8a073e/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=38f8b050edd36ac977c564cab41cc1ce8e8a073e", "patch": "@@ -1473,8 +1473,8 @@ common_handle_option (size_t scode, const char *arg, int value,\n       exit_after_options = true;\n \n       /* Allow the target a chance to give the user some additional information.  */\n-      if (targetm.target_help)\n-\ttargetm.target_help ();\n+      if (targetm.help)\n+\ttargetm.help ();\n       break;\n \n     case OPT_fhelp_:"}, {"sha": "2bd47546476a65eb684dfa42155a86d57b29343e", "filename": "gcc/po/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38f8b050edd36ac977c564cab41cc1ce8e8a073e/gcc%2Fpo%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38f8b050edd36ac977c564cab41cc1ce8e8a073e/gcc%2Fpo%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpo%2FChangeLog?ref=38f8b050edd36ac977c564cab41cc1ce8e8a073e", "patch": "@@ -1,3 +1,8 @@\n+2010-06-29  Joern Rennecke  <joern.rennecke@embecosm.com>\n+\n+\tPR other/44034\n+\t* EXCLUDES: Add genhooks.c.\n+\n 2010-05-01  Joseph Myers  <joseph@codesourcery.com>\n \n \t* sv.po: Update."}, {"sha": "69ab994c94b4aba04b568b978be01e26cd9293fd", "filename": "gcc/po/EXCLUDES", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38f8b050edd36ac977c564cab41cc1ce8e8a073e/gcc%2Fpo%2FEXCLUDES", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38f8b050edd36ac977c564cab41cc1ce8e8a073e/gcc%2Fpo%2FEXCLUDES", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpo%2FEXCLUDES?ref=38f8b050edd36ac977c564cab41cc1ce8e8a073e", "patch": "@@ -74,6 +74,7 @@ genextract.c\n genflags.c\n gengenrtl.c\n gengtype.c\n+genhooks.c\n genmodes.c\n genopinit.c\n genoutput.c"}, {"sha": "7881625299708b83cf930ce43901b25d2cc612de", "filename": "gcc/sel-sched.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38f8b050edd36ac977c564cab41cc1ce8e8a073e/gcc%2Fsel-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38f8b050edd36ac977c564cab41cc1ce8e8a073e/gcc%2Fsel-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched.c?ref=38f8b050edd36ac977c564cab41cc1ce8e8a073e", "patch": "@@ -6863,11 +6863,11 @@ sel_region_init (int rgn)\n   /* Set hooks so that no newly generated insn will go out unnoticed.  */\n   sel_register_cfg_hooks ();\n \n-  /* !!! We call target.sched.md_init () for the whole region, but we invoke\n-     targetm.sched.md_finish () for every ebb.  */\n-  if (targetm.sched.md_init)\n+  /* !!! We call target.sched.init () for the whole region, but we invoke\n+     targetm.sched.finish () for every ebb.  */\n+  if (targetm.sched.init)\n     /* None of the arguments are actually used in any target.  */\n-    targetm.sched.md_init (sched_dump, sched_verbose, -1);\n+    targetm.sched.init (sched_dump, sched_verbose, -1);\n \n   first_emitted_uid = get_max_uid () + 1;\n   preheader_removed = false;\n@@ -6949,11 +6949,11 @@ reset_sched_cycles_in_current_ebb (void)\n   int haifa_clock = 0;\n   insn_t insn;\n \n-  if (targetm.sched.md_init)\n+  if (targetm.sched.init)\n     {\n       /* None of the arguments are actually used in any target.\n \t NB: We should have md_reset () hook for cases like this.  */\n-      targetm.sched.md_init (sched_dump, sched_verbose, -1);\n+      targetm.sched.init (sched_dump, sched_verbose, -1);\n     }\n \n   state_reset (curr_state);\n@@ -7131,14 +7131,14 @@ sel_region_target_finish (bool reset_sched_cycles_p)\n       if (reset_sched_cycles_p)\n \treset_sched_cycles_in_current_ebb ();\n \n-      if (targetm.sched.md_init)\n-\ttargetm.sched.md_init (sched_dump, sched_verbose, -1);\n+      if (targetm.sched.init)\n+\ttargetm.sched.init (sched_dump, sched_verbose, -1);\n \n       put_TImodes ();\n \n-      if (targetm.sched.md_finish)\n+      if (targetm.sched.finish)\n \t{\n-\t  targetm.sched.md_finish (sched_dump, sched_verbose);\n+\t  targetm.sched.finish (sched_dump, sched_verbose);\n \n \t  /* Extend luids so that insns generated by the target will\n \t     get zero luid.  */"}, {"sha": "0aad7ce51a9a7eac3d69bdab43d062c91df0a40b", "filename": "gcc/target-def.h", "status": "modified", "additions": 6, "deletions": 1019, "changes": 1025, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38f8b050edd36ac977c564cab41cc1ce8e8a073e/gcc%2Ftarget-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38f8b050edd36ac977c564cab41cc1ce8e8a073e/gcc%2Ftarget-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-def.h?ref=38f8b050edd36ac977c564cab41cc1ce8e8a073e", "patch": "@@ -20,7 +20,7 @@\n    You are forbidden to forbid anyone else to use, share and improve\n    what you give them.   Help stamp out software-hoarding!  */\n \n-/* See target.h for a description of what this file contains and how to\n+/* See target.def for a description of what this file contains and how to\n    use it.\n \n    We want to have non-NULL default definitions of all hook functions,\n@@ -30,16 +30,6 @@\n    rather than the .c file, then we need to wrap the default\n    definition in a #ifndef, since files include tm.h before this one.  */\n \n-/* Assembler output.  */\n-#ifndef TARGET_ASM_OPEN_PAREN\n-#define TARGET_ASM_OPEN_PAREN \"(\"\n-#endif\n-#ifndef TARGET_ASM_CLOSE_PAREN\n-#define TARGET_ASM_CLOSE_PAREN \")\"\n-#endif\n-\n-#define TARGET_ASM_BYTE_OP \"\\t.byte\\t\"\n-\n #define TARGET_ASM_ALIGNED_HI_OP \"\\t.short\\t\"\n #define TARGET_ASM_ALIGNED_SI_OP \"\\t.long\\t\"\n #define TARGET_ASM_ALIGNED_DI_OP NULL\n@@ -58,69 +48,6 @@\n #define TARGET_ASM_UNALIGNED_TI_OP NULL\n #endif /* OBJECT_FORMAT_ELF */\n \n-#define TARGET_ASM_INTEGER default_assemble_integer\n-\n-#ifndef TARGET_ASM_GLOBALIZE_LABEL\n-#define TARGET_ASM_GLOBALIZE_LABEL default_globalize_label\n-#endif\n-\n-#ifndef TARGET_ASM_GLOBALIZE_DECL_NAME\n-#define TARGET_ASM_GLOBALIZE_DECL_NAME default_globalize_decl_name\n-#endif\n-\n-#ifndef TARGET_ASM_EMIT_UNWIND_LABEL\n-#define TARGET_ASM_EMIT_UNWIND_LABEL default_emit_unwind_label\n-#endif\n-\n-#ifndef TARGET_ASM_EMIT_EXCEPT_TABLE_LABEL\n-#define TARGET_ASM_EMIT_EXCEPT_TABLE_LABEL default_emit_except_table_label\n-#endif\n-\n-#ifndef TARGET_UNWIND_EMIT\n-#define TARGET_UNWIND_EMIT default_unwind_emit\n-#endif\n-\n-#ifndef TARGET_ASM_INTERNAL_LABEL\n-#define TARGET_ASM_INTERNAL_LABEL default_internal_label\n-#endif\n-\n-#ifndef TARGET_ASM_DECLARE_CONSTANT_NAME\n-#define TARGET_ASM_DECLARE_CONSTANT_NAME default_asm_declare_constant_name\n-#endif\n-\n-#ifndef TARGET_ASM_TTYPE\n-#define TARGET_ASM_TTYPE hook_bool_rtx_false\n-#endif\n-\n-#ifndef TARGET_ASM_ASSEMBLE_VISIBILITY\n-#define TARGET_ASM_ASSEMBLE_VISIBILITY default_assemble_visibility\n-#endif\n-\n-#define TARGET_ASM_FUNCTION_PROLOGUE default_function_pro_epilogue\n-#define TARGET_ASM_FUNCTION_EPILOGUE default_function_pro_epilogue\n-#define TARGET_ASM_FUNCTION_END_PROLOGUE no_asm_to_stream\n-#define TARGET_ASM_FUNCTION_BEGIN_EPILOGUE no_asm_to_stream\n-\n-#ifndef TARGET_ASM_RELOC_RW_MASK\n-#define TARGET_ASM_RELOC_RW_MASK default_reloc_rw_mask\n-#endif\n-\n-#ifndef TARGET_ASM_SELECT_SECTION\n-#define TARGET_ASM_SELECT_SECTION default_select_section\n-#endif\n-\n-#ifndef TARGET_ASM_UNIQUE_SECTION\n-#define TARGET_ASM_UNIQUE_SECTION default_unique_section\n-#endif\n-\n-#ifndef TARGET_ASM_FUNCTION_RODATA_SECTION\n-#define TARGET_ASM_FUNCTION_RODATA_SECTION default_function_rodata_section\n-#endif\n-\n-#ifndef TARGET_ASM_SELECT_RTX_SECTION\n-#define TARGET_ASM_SELECT_RTX_SECTION default_select_rtx_section\n-#endif\n-\n #if !defined(TARGET_ASM_CONSTRUCTOR) && !defined(USE_COLLECT2)\n # ifdef CTORS_SECTION_ASM_OP\n #  define TARGET_ASM_CONSTRUCTOR default_ctor_section_asm_out_constructor\n@@ -145,137 +72,25 @@\n # endif\n #endif\n \n-#define TARGET_ASM_OUTPUT_MI_THUNK NULL\n-#define TARGET_ASM_CAN_OUTPUT_MI_THUNK hook_bool_const_tree_hwi_hwi_const_tree_false\n-\n #if !defined(TARGET_HAVE_CTORS_DTORS)\n # if defined(TARGET_ASM_CONSTRUCTOR) && defined(TARGET_ASM_DESTRUCTOR)\n # define TARGET_HAVE_CTORS_DTORS true\n-# else\n-# define TARGET_HAVE_CTORS_DTORS false\n-# define TARGET_ASM_CONSTRUCTOR NULL\n-# define TARGET_ASM_DESTRUCTOR NULL\n # endif\n #endif\n \n-#ifndef TARGET_HAVE_SWITCHABLE_BSS_SECTIONS\n-#define TARGET_HAVE_SWITCHABLE_BSS_SECTIONS false\n-#endif\n-\n-#ifndef TARGET_ASM_INIT_SECTIONS\n-#define TARGET_ASM_INIT_SECTIONS hook_void_void\n-#endif\n-\n #ifdef TARGET_ASM_NAMED_SECTION\n #define TARGET_HAVE_NAMED_SECTIONS true\n-#else\n-#define TARGET_ASM_NAMED_SECTION default_no_named_section\n-#define TARGET_HAVE_NAMED_SECTIONS false\n-#endif\n-\n-#ifndef TARGET_INVALID_WITHIN_DOLOOP\n-#define TARGET_INVALID_WITHIN_DOLOOP default_invalid_within_doloop\n-#endif\n-\n-#ifndef TARGET_VALID_DLLIMPORT_ATTRIBUTE_P\n-#define TARGET_VALID_DLLIMPORT_ATTRIBUTE_P hook_bool_const_tree_true\n-#endif\n-\n-#ifndef TARGET_HAVE_TLS\n-#define TARGET_HAVE_TLS false\n-#endif\n-\n-#ifndef TARGET_HAVE_SRODATA_SECTION\n-#define TARGET_HAVE_SRODATA_SECTION false\n #endif\n \n #ifndef TARGET_TERMINATE_DW2_EH_FRAME_INFO\n #ifdef EH_FRAME_SECTION_NAME\n #define TARGET_TERMINATE_DW2_EH_FRAME_INFO false\n-#else\n-#define TARGET_TERMINATE_DW2_EH_FRAME_INFO true\n-#endif\n-#endif\n-\n-#define TARGET_DWARF_REGISTER_SPAN hook_rtx_rtx_null\n-#define TARGET_INIT_DWARF_REG_SIZES_EXTRA hook_void_tree\n-\n-#ifndef TARGET_ASM_FILE_START\n-#define TARGET_ASM_FILE_START default_file_start\n #endif\n-\n-#ifndef TARGET_ASM_FILE_END\n-#define TARGET_ASM_FILE_END hook_void_void\n-#endif\n-\n-#ifndef TARGET_ASM_LTO_START\n-#define TARGET_ASM_LTO_START hook_void_void\n-#endif\n-\n-#ifndef TARGET_ASM_LTO_END\n-#define TARGET_ASM_LTO_END hook_void_void\n-#endif\n-\n-#ifndef TARGET_ASM_CODE_END\n-#define TARGET_ASM_CODE_END hook_void_void\n-#endif\n-\n-#ifndef TARGET_EXTRA_LIVE_ON_ENTRY\n-#define TARGET_EXTRA_LIVE_ON_ENTRY hook_void_bitmap\n-#endif\n-\n-#ifndef TARGET_ASM_FILE_START_APP_OFF\n-#define TARGET_ASM_FILE_START_APP_OFF false\n-#endif\n-\n-#ifndef TARGET_ASM_FILE_START_FILE_DIRECTIVE\n-#define TARGET_ASM_FILE_START_FILE_DIRECTIVE false\n-#endif\n-\n-#ifndef TARGET_ASM_EXTERNAL_LIBCALL\n-#define TARGET_ASM_EXTERNAL_LIBCALL default_external_libcall\n-#endif\n-\n-#ifndef TARGET_ASM_MARK_DECL_PRESERVED\n-#define TARGET_ASM_MARK_DECL_PRESERVED hook_void_constcharptr\n #endif\n \n-#ifndef TARGET_ASM_OUTPUT_ANCHOR\n-#ifdef ASM_OUTPUT_DEF\n-#define TARGET_ASM_OUTPUT_ANCHOR default_asm_output_anchor\n-#else\n+#if !defined(TARGET_ASM_OUTPUT_ANCHOR) && !defined(ASM_OUTPUT_DEF)\n #define TARGET_ASM_OUTPUT_ANCHOR NULL\n #endif\n-#endif\n-\n-#ifndef TARGET_ASM_OUTPUT_DWARF_DTPREL\n-#define TARGET_ASM_OUTPUT_DWARF_DTPREL NULL\n-#endif\n-\n-#ifndef TARGET_ASM_FINAL_POSTSCAN_INSN\n-#define TARGET_ASM_FINAL_POSTSCAN_INSN NULL\n-#endif\n-\n-#ifndef TARGET_ASM_RECORD_GCC_SWITCHES\n-#define TARGET_ASM_RECORD_GCC_SWITCHES NULL\n-#endif\n-#ifndef TARGET_ASM_RECORD_GCC_SWITCHES_SECTION\n-#define TARGET_ASM_RECORD_GCC_SWITCHES_SECTION \".GCC.command.line\"\n-#endif\n-\n-#define TARGET_ASM_TRAMPOLINE_TEMPLATE NULL\n-\n-#ifndef TARGET_PRINT_OPERAND\n-#define TARGET_PRINT_OPERAND default_print_operand\n-#endif\n-\n-#ifndef TARGET_PRINT_OPERAND_ADDRESS\n-#define TARGET_PRINT_OPERAND_ADDRESS default_print_operand_address\n-#endif\n-\n-#ifndef TARGET_PRINT_OPERAND_PUNCT_VALID_P\n-#define TARGET_PRINT_OPERAND_PUNCT_VALID_P default_print_operand_punct_valid_p\n-#endif\n \n #define TARGET_ASM_ALIGNED_INT_OP\t\t\t\t\\\n \t\t       {TARGET_ASM_ALIGNED_HI_OP,\t\t\\\n@@ -289,843 +104,15 @@\n \t\t\tTARGET_ASM_UNALIGNED_DI_OP,\t\t\\\n \t\t\tTARGET_ASM_UNALIGNED_TI_OP}\n \n-#define TARGET_ASM_OUT {TARGET_ASM_OPEN_PAREN,\t\t\t\\\n-\t\t\tTARGET_ASM_CLOSE_PAREN,\t\t\t\\\n-\t\t\tTARGET_ASM_BYTE_OP,\t\t\t\\\n-\t\t\tTARGET_ASM_ALIGNED_INT_OP,\t\t\\\n-\t\t\tTARGET_ASM_UNALIGNED_INT_OP,\t\t\\\n-\t\t\tTARGET_ASM_INTEGER,\t\t\t\\\n-\t\t\tTARGET_ASM_GLOBALIZE_LABEL,\t\t\\\n-\t\t\tTARGET_ASM_GLOBALIZE_DECL_NAME,\t\t\\\n-                        TARGET_ASM_EMIT_UNWIND_LABEL,           \\\n-\t\t\tTARGET_ASM_EMIT_EXCEPT_TABLE_LABEL,\t\\\n-\t\t\tTARGET_UNWIND_EMIT,\t\t\t\\\n-\t\t\tTARGET_ASM_INTERNAL_LABEL,\t\t\\\n-\t\t\tTARGET_ASM_DECLARE_CONSTANT_NAME,\t\\\n-\t\t\tTARGET_ASM_TTYPE,\t\t\t\\\n-\t\t\tTARGET_ASM_ASSEMBLE_VISIBILITY,\t\t\\\n-\t\t\tTARGET_ASM_FUNCTION_PROLOGUE,\t\t\\\n-\t\t\tTARGET_ASM_FUNCTION_END_PROLOGUE,\t\\\n-\t\t\tTARGET_ASM_FUNCTION_BEGIN_EPILOGUE,\t\\\n-\t\t\tTARGET_ASM_FUNCTION_EPILOGUE,\t\t\\\n-\t\t\tTARGET_ASM_INIT_SECTIONS,\t\t\\\n-\t\t\tTARGET_ASM_NAMED_SECTION,\t\t\\\n-\t\t\tTARGET_ASM_RELOC_RW_MASK,\t\t\\\n-\t\t\tTARGET_ASM_SELECT_SECTION,\t\t\\\n-\t\t\tTARGET_ASM_SELECT_RTX_SECTION,\t\t\\\n-\t\t\tTARGET_ASM_UNIQUE_SECTION,\t\t\\\n-\t\t\tTARGET_ASM_FUNCTION_RODATA_SECTION,\t\\\n-\t\t\tTARGET_ASM_CONSTRUCTOR,\t\t\t\\\n-\t\t\tTARGET_ASM_DESTRUCTOR,                  \\\n-                        TARGET_ASM_OUTPUT_MI_THUNK,             \\\n-                        TARGET_ASM_CAN_OUTPUT_MI_THUNK,         \\\n-                        TARGET_ASM_FILE_START,                  \\\n-                        TARGET_ASM_FILE_END,\t\t\t\\\n-                        TARGET_ASM_LTO_START,\t\t\t\\\n-                        TARGET_ASM_LTO_END,\t\t\t\\\n-                        TARGET_ASM_CODE_END,\t\t\t\\\n-\t\t\tTARGET_ASM_EXTERNAL_LIBCALL,            \\\n-                        TARGET_ASM_MARK_DECL_PRESERVED,\t\t\\\n-\t\t\tTARGET_ASM_RECORD_GCC_SWITCHES,\t\t\\\n-\t\t\tTARGET_ASM_RECORD_GCC_SWITCHES_SECTION,\t\\\n-\t\t\tTARGET_ASM_OUTPUT_ANCHOR,\t\t\\\n-\t\t\tTARGET_ASM_OUTPUT_DWARF_DTPREL,\t\t\\\n-\t\t\tTARGET_ASM_FINAL_POSTSCAN_INSN,\t\t\\\n-\t\t\tTARGET_ASM_TRAMPOLINE_TEMPLATE,\t\t\\\n-\t\t\tTARGET_PRINT_OPERAND,\t\t\t\\\n-\t\t\tTARGET_PRINT_OPERAND_ADDRESS,\t\t\\\n-\t\t\tTARGET_PRINT_OPERAND_PUNCT_VALID_P }\n-\n-/* Scheduler hooks.  All of these default to null pointers, which\n-   haifa-sched.c looks for and handles.  */\n-#define TARGET_SCHED_ADJUST_COST 0\n-#define TARGET_SCHED_ADJUST_PRIORITY 0\n-#define TARGET_SCHED_ISSUE_RATE 0\n-#define TARGET_SCHED_VARIABLE_ISSUE 0\n-#define TARGET_SCHED_INIT 0\n-#define TARGET_SCHED_FINISH 0\n-#define TARGET_SCHED_INIT_GLOBAL 0\n-#define TARGET_SCHED_FINISH_GLOBAL 0\n-#define TARGET_SCHED_REORDER 0\n-#define TARGET_SCHED_REORDER2 0\n-#define TARGET_SCHED_DEPENDENCIES_EVALUATION_HOOK 0\n-#define TARGET_SCHED_INIT_DFA_PRE_CYCLE_INSN 0\n-#define TARGET_SCHED_DFA_PRE_CYCLE_INSN 0\n-#define TARGET_SCHED_INIT_DFA_POST_CYCLE_INSN 0\n-#define TARGET_SCHED_DFA_POST_CYCLE_INSN 0\n-#define TARGET_SCHED_DFA_PRE_ADVANCE_CYCLE 0\n-#define TARGET_SCHED_DFA_POST_ADVANCE_CYCLE 0\n-#define TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD 0\n-#define TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD_GUARD 0\n-#define TARGET_SCHED_DFA_NEW_CYCLE 0\n-#define TARGET_SCHED_IS_COSTLY_DEPENDENCE 0\n-#define TARGET_SCHED_ADJUST_COST_2 0\n-#define TARGET_SCHED_H_I_D_EXTENDED 0\n-#define TARGET_SCHED_ALLOC_SCHED_CONTEXT 0\n-#define TARGET_SCHED_INIT_SCHED_CONTEXT 0\n-#define TARGET_SCHED_SET_SCHED_CONTEXT 0\n-#define TARGET_SCHED_CLEAR_SCHED_CONTEXT 0\n-#define TARGET_SCHED_FREE_SCHED_CONTEXT 0\n-#define TARGET_SCHED_SPECULATE_INSN 0\n-#define TARGET_SCHED_NEEDS_BLOCK_P 0\n-#define TARGET_SCHED_GEN_SPEC_CHECK 0\n-#define TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD_GUARD_SPEC 0\n-#define TARGET_SCHED_SET_SCHED_FLAGS 0\n-#define TARGET_SCHED_GET_INSN_SPEC_DS 0\n-#define TARGET_SCHED_GET_INSN_CHECKED_DS 0\n-#define TARGET_SCHED_SKIP_RTX_P 0\n-#define TARGET_SCHED_SMS_RES_MII 0\n-\n-#define TARGET_SCHED\t\t\t\t\t\t\\\n-  {TARGET_SCHED_ADJUST_COST,\t\t\t\t\t\\\n-   TARGET_SCHED_ADJUST_PRIORITY,\t\t\t\t\\\n-   TARGET_SCHED_ISSUE_RATE,\t\t\t\t\t\\\n-   TARGET_SCHED_VARIABLE_ISSUE,\t\t\t\t\t\\\n-   TARGET_SCHED_INIT,\t\t\t\t\t\t\\\n-   TARGET_SCHED_FINISH,\t\t\t\t\t\t\\\n-   TARGET_SCHED_INIT_GLOBAL,\t\t\t\t\t\\\n-   TARGET_SCHED_FINISH_GLOBAL,\t\t\t\t\t\\\n-   TARGET_SCHED_REORDER,\t\t\t\t\t\\\n-   TARGET_SCHED_REORDER2,\t\t\t\t\t\\\n-   TARGET_SCHED_DEPENDENCIES_EVALUATION_HOOK,\t\t\t\\\n-   TARGET_SCHED_INIT_DFA_PRE_CYCLE_INSN,\t\t\t\\\n-   TARGET_SCHED_DFA_PRE_CYCLE_INSN,\t\t\t\t\\\n-   TARGET_SCHED_INIT_DFA_POST_CYCLE_INSN,\t\t\t\\\n-   TARGET_SCHED_DFA_POST_CYCLE_INSN,\t\t\t        \\\n-   TARGET_SCHED_DFA_PRE_ADVANCE_CYCLE,                          \\\n-   TARGET_SCHED_DFA_POST_ADVANCE_CYCLE,                         \\\n-   TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD,\t\t\\\n-   TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD_GUARD,\t\\\n-   TARGET_SCHED_DFA_NEW_CYCLE,\t\t\t\t\t\\\n-   TARGET_SCHED_IS_COSTLY_DEPENDENCE,                           \\\n-   TARGET_SCHED_ADJUST_COST_2,                                  \\\n-   TARGET_SCHED_H_I_D_EXTENDED,\t\t\t\t\t\\\n-   TARGET_SCHED_ALLOC_SCHED_CONTEXT,                            \\\n-   TARGET_SCHED_INIT_SCHED_CONTEXT,                             \\\n-   TARGET_SCHED_SET_SCHED_CONTEXT,                              \\\n-   TARGET_SCHED_CLEAR_SCHED_CONTEXT,                            \\\n-   TARGET_SCHED_FREE_SCHED_CONTEXT,                             \\\n-   TARGET_SCHED_SPECULATE_INSN,                                 \\\n-   TARGET_SCHED_NEEDS_BLOCK_P,                                  \\\n-   TARGET_SCHED_GEN_SPEC_CHECK,\t\t\t\t        \\\n-   TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD_GUARD_SPEC, \\\n-   TARGET_SCHED_SET_SCHED_FLAGS,                                \\\n-   TARGET_SCHED_GET_INSN_SPEC_DS,                               \\\n-   TARGET_SCHED_GET_INSN_CHECKED_DS,                            \\\n-   TARGET_SCHED_SKIP_RTX_P,\t\t\t\t\t\\\n-   TARGET_SCHED_SMS_RES_MII}\n-\n-#define TARGET_VECTORIZE_BUILTIN_MASK_FOR_LOAD 0\n-#define TARGET_VECTORIZE_BUILTIN_VECTORIZED_FUNCTION \\\n-  default_builtin_vectorized_function\n-#define TARGET_VECTORIZE_BUILTIN_CONVERSION \\\n-  default_builtin_vectorized_conversion\n-#define TARGET_VECTORIZE_BUILTIN_MUL_WIDEN_EVEN 0\n-#define TARGET_VECTORIZE_BUILTIN_MUL_WIDEN_ODD 0\n-#define TARGET_VECTORIZE_BUILTIN_VECTORIZATION_COST \\\n-  default_builtin_vectorization_cost\n-#define TARGET_VECTOR_ALIGNMENT_REACHABLE \\\n-  default_builtin_vector_alignment_reachable\n-#define TARGET_VECTORIZE_BUILTIN_VEC_PERM 0\n-#define TARGET_VECTORIZE_BUILTIN_VEC_PERM_OK \\\n-  hook_bool_tree_tree_true\n-#define TARGET_SUPPORT_VECTOR_MISALIGNMENT \\\n-  default_builtin_support_vector_misalignment\n-\n-\n-#define TARGET_VECTORIZE                                                \\\n-  {\t\t\t\t\t\t\t\t\t\\\n-    TARGET_VECTORIZE_BUILTIN_MASK_FOR_LOAD,\t\t\t\t\\\n-    TARGET_VECTORIZE_BUILTIN_VECTORIZED_FUNCTION,\t\t\t\\\n-    TARGET_VECTORIZE_BUILTIN_CONVERSION,\t\t\t\t\\\n-    TARGET_VECTORIZE_BUILTIN_MUL_WIDEN_EVEN,                            \\\n-    TARGET_VECTORIZE_BUILTIN_MUL_WIDEN_ODD,\t\t\t\t\\\n-    TARGET_VECTORIZE_BUILTIN_VECTORIZATION_COST,\t\t\t\\\n-    TARGET_VECTOR_ALIGNMENT_REACHABLE,                                  \\\n-    TARGET_VECTORIZE_BUILTIN_VEC_PERM,\t\t\t\t\t\\\n-    TARGET_VECTORIZE_BUILTIN_VEC_PERM_OK,\t\t\t\t\\\n-    TARGET_SUPPORT_VECTOR_MISALIGNMENT\t\t\t\t\t\\\n-  }\n-\n-#define TARGET_DEFAULT_TARGET_FLAGS 0\n-\n-#define TARGET_OVERRIDE_OPTIONS_AFTER_CHANGE hook_void_void\n-\n-#define TARGET_HANDLE_OPTION hook_bool_size_t_constcharptr_int_true\n-#define TARGET_HANDLE_OFAST hook_void_void\n-#define TARGET_HELP NULL\n-\n-/* In except.c */\n-#define TARGET_EH_RETURN_FILTER_MODE  default_eh_return_filter_mode\n-\n-/* In libgcc2.c */\n-#define TARGET_LIBGCC_CMP_RETURN_MODE  default_libgcc_cmp_return_mode\n-#define TARGET_LIBGCC_SHIFT_COUNT_MODE default_libgcc_shift_count_mode\n-\n-/* In unwind-generic.h.  */\n-#define TARGET_UNWIND_WORD_MODE default_unwind_word_mode\n-\n-/* In tree.c.  */\n-#define TARGET_MERGE_DECL_ATTRIBUTES merge_decl_attributes\n-#define TARGET_MERGE_TYPE_ATTRIBUTES merge_type_attributes\n-#define TARGET_ATTRIBUTE_TABLE NULL\n-\n-/* In cse.c.  */\n-#define TARGET_ADDRESS_COST default_address_cost\n-#define TARGET_CONST_ANCHOR 0\n-\n-#ifndef TARGET_REGISTER_MOVE_COST\n-#define TARGET_REGISTER_MOVE_COST default_register_move_cost\n-#endif\n-\n-#ifndef TARGET_MEMORY_MOVE_COST\n-#define TARGET_MEMORY_MOVE_COST default_memory_move_cost\n-#endif\n-\n-/* In builtins.c.  */\n-#define TARGET_INIT_BUILTINS hook_void_void\n-#define TARGET_EXPAND_BUILTIN default_expand_builtin\n-#define TARGET_RESOLVE_OVERLOADED_BUILTIN NULL\n-#define TARGET_FOLD_BUILTIN hook_tree_tree_int_treep_bool_null\n-#define TARGET_BUILTIN_DECL NULL\n-\n-/* In tree-ssa-math-opts.c  */\n-#define TARGET_BUILTIN_RECIPROCAL default_builtin_reciprocal\n-\n-/* In varasm.c.  */\n-#ifndef TARGET_SECTION_TYPE_FLAGS\n-#define TARGET_SECTION_TYPE_FLAGS default_section_type_flags\n-#endif\n-\n-#ifndef TARGET_STRIP_NAME_ENCODING\n-#define TARGET_STRIP_NAME_ENCODING default_strip_name_encoding\n-#endif\n-\n-#ifndef TARGET_BINDS_LOCAL_P\n-#define TARGET_BINDS_LOCAL_P default_binds_local_p\n-#endif\n-\n-#ifndef TARGET_SHIFT_TRUNCATION_MASK\n-#define TARGET_SHIFT_TRUNCATION_MASK default_shift_truncation_mask\n-#endif\n-\n-#ifndef TARGET_MIN_DIVISIONS_FOR_RECIP_MUL\n-#define TARGET_MIN_DIVISIONS_FOR_RECIP_MUL default_min_divisions_for_recip_mul\n-#endif\n-\n-#ifndef TARGET_MODE_REP_EXTENDED\n-#define TARGET_MODE_REP_EXTENDED default_mode_rep_extended\n-#endif\n-\n-#ifndef TARGET_VALID_POINTER_MODE\n-#define TARGET_VALID_POINTER_MODE default_valid_pointer_mode\n-#endif\n-\n-#ifndef TARGET_ADDR_SPACE_POINTER_MODE\n-#define TARGET_ADDR_SPACE_POINTER_MODE default_addr_space_pointer_mode\n-#endif\n-\n-#ifndef TARGET_ADDR_SPACE_ADDRESS_MODE\n-#define TARGET_ADDR_SPACE_ADDRESS_MODE default_addr_space_address_mode\n-#endif\n-\n-#ifndef TARGET_ADDR_SPACE_VALID_POINTER_MODE\n-#define TARGET_ADDR_SPACE_VALID_POINTER_MODE \\\n-\tdefault_addr_space_valid_pointer_mode\n-#endif\n-\n-#ifndef TARGET_ADDR_SPACE_LEGITIMATE_ADDRESS_P\n-#define TARGET_ADDR_SPACE_LEGITIMATE_ADDRESS_P \\\n-  default_addr_space_legitimate_address_p\n-#endif\n-\n-#ifndef TARGET_ADDR_SPACE_LEGITIMIZE_ADDRESS\n-#define TARGET_ADDR_SPACE_LEGITIMIZE_ADDRESS \\\n-  default_addr_space_legitimize_address\n-#endif\n-\n-#ifndef TARGET_ADDR_SPACE_SUBSET_P\n-#define TARGET_ADDR_SPACE_SUBSET_P default_addr_space_subset_p\n-#endif\n-\n-#ifndef TARGET_ADDR_SPACE_CONVERT\n-#define TARGET_ADDR_SPACE_CONVERT default_addr_space_convert\n-#endif\n-\n-#define TARGET_ADDR_SPACE_HOOKS\t\t\t\\\n-  {\t\t\t\t\t\t\\\n-    TARGET_ADDR_SPACE_POINTER_MODE,\t\t\\\n-    TARGET_ADDR_SPACE_ADDRESS_MODE,\t\t\\\n-    TARGET_ADDR_SPACE_VALID_POINTER_MODE,\t\\\n-    TARGET_ADDR_SPACE_LEGITIMATE_ADDRESS_P,\t\\\n-    TARGET_ADDR_SPACE_LEGITIMIZE_ADDRESS,\t\\\n-    TARGET_ADDR_SPACE_SUBSET_P,\t\t\t\\\n-    TARGET_ADDR_SPACE_CONVERT,\t\t\t\\\n-  }\n-\n-#ifndef TARGET_SCALAR_MODE_SUPPORTED_P\n-#define TARGET_SCALAR_MODE_SUPPORTED_P default_scalar_mode_supported_p\n-#endif\n-\n-#ifndef TARGET_ENUM_VA_LIST_P\n-#define TARGET_ENUM_VA_LIST_P NULL\n-#endif\n-\n-#ifndef TARGET_DECIMAL_FLOAT_SUPPORTED_P\n-#define TARGET_DECIMAL_FLOAT_SUPPORTED_P default_decimal_float_supported_p\n-#endif\n-\n-#ifndef TARGET_FIXED_POINT_SUPPORTED_P\n-#define TARGET_FIXED_POINT_SUPPORTED_P default_fixed_point_supported_p\n-#endif\n-\n-#ifndef TARGET_VECTOR_MODE_SUPPORTED_P\n-#define TARGET_VECTOR_MODE_SUPPORTED_P hook_bool_mode_false\n-#endif\n-\n-#ifndef TARGET_SMALL_REGISTER_CLASSES_FOR_MODE_P\n-#define TARGET_SMALL_REGISTER_CLASSES_FOR_MODE_P hook_bool_mode_false\n-#endif\n-\n-/* In hooks.c.  */\n-#define TARGET_CANNOT_MODIFY_JUMPS_P hook_bool_void_false\n-#define TARGET_BRANCH_TARGET_REGISTER_CLASS \\\n-  default_branch_target_register_class\n-#define TARGET_BRANCH_TARGET_REGISTER_CALLEE_SAVED hook_bool_bool_false\n-#define TARGET_HAVE_CONDITIONAL_EXECUTION default_have_conditional_execution\n-#define TARGET_LOOP_UNROLL_ADJUST NULL\n-#define TARGET_CANNOT_FORCE_CONST_MEM hook_bool_rtx_false\n-#define TARGET_CANNOT_COPY_INSN_P NULL\n-#define TARGET_COMMUTATIVE_P hook_bool_const_rtx_commutative_p\n-#define TARGET_LEGITIMIZE_ADDRESS default_legitimize_address\n-#define TARGET_DELEGITIMIZE_ADDRESS delegitimize_mem_from_attrs\n-#define TARGET_LEGITIMATE_ADDRESS_P default_legitimate_address_p\n-#define TARGET_USE_BLOCKS_FOR_CONSTANT_P hook_bool_mode_const_rtx_false\n-#define TARGET_MIN_ANCHOR_OFFSET 0\n-#define TARGET_MAX_ANCHOR_OFFSET 0\n-#define TARGET_USE_ANCHORS_FOR_SYMBOL_P default_use_anchors_for_symbol_p\n-#define TARGET_FUNCTION_OK_FOR_SIBCALL hook_bool_tree_tree_false\n-#define TARGET_ATTRIBUTE_TAKES_IDENTIFIER_P hook_bool_const_tree_false\n-#define TARGET_COMP_TYPE_ATTRIBUTES hook_int_const_tree_const_tree_1\n-#ifndef TARGET_SET_DEFAULT_TYPE_ATTRIBUTES\n-#define TARGET_SET_DEFAULT_TYPE_ATTRIBUTES hook_void_tree\n-#endif\n-#define TARGET_INSERT_ATTRIBUTES hook_void_tree_treeptr\n-#define TARGET_FUNCTION_ATTRIBUTE_INLINABLE_P hook_bool_const_tree_false\n-#define TARGET_MS_BITFIELD_LAYOUT_P hook_bool_const_tree_false\n-#define TARGET_ALIGN_ANON_BITFIELD hook_bool_void_false\n-#define TARGET_NARROW_VOLATILE_BITFIELD hook_bool_void_false\n-#define TARGET_RTX_COSTS hook_bool_rtx_int_int_intp_bool_false\n-#define TARGET_MANGLE_TYPE hook_constcharptr_const_tree_null\n-#define TARGET_ALLOCATE_INITIAL_VALUE NULL\n-\n-#define TARGET_UNSPEC_MAY_TRAP_P default_unspec_may_trap_p\n-\n-#ifndef TARGET_SET_CURRENT_FUNCTION\n-#define TARGET_SET_CURRENT_FUNCTION hook_void_tree\n-#endif\n-\n-#ifndef TARGET_INIT_LIBFUNCS\n-#define TARGET_INIT_LIBFUNCS hook_void_void\n-#endif\n-\n-#ifndef TARGET_IN_SMALL_DATA_P\n-#define TARGET_IN_SMALL_DATA_P hook_bool_const_tree_false\n-#endif\n-\n-#ifndef TARGET_MODE_DEPENDENT_ADDRESS_P\n-#define TARGET_MODE_DEPENDENT_ADDRESS_P default_mode_dependent_address_p\n-#endif\n-\n-#ifndef TARGET_MANGLE_DECL_ASSEMBLER_NAME\n-#define TARGET_MANGLE_DECL_ASSEMBLER_NAME default_mangle_decl_assembler_name\n-#endif\n-\n-#ifndef TARGET_ENCODE_SECTION_INFO\n-#define TARGET_ENCODE_SECTION_INFO default_encode_section_info\n-#endif\n-\n-#ifndef TARGET_INVALID_ARG_FOR_UNPROTOTYPED_FN\n-#define TARGET_INVALID_ARG_FOR_UNPROTOTYPED_FN hook_invalid_arg_for_unprototyped_fn\n-#endif\n-\n-#define TARGET_INVALID_CONVERSION hook_constcharptr_const_tree_const_tree_null\n-#define TARGET_INVALID_UNARY_OP hook_constcharptr_int_const_tree_null\n-#define TARGET_INVALID_BINARY_OP hook_constcharptr_int_const_tree_const_tree_null\n-#define TARGET_INVALID_PARAMETER_TYPE hook_constcharptr_const_tree_null\n-#define TARGET_INVALID_RETURN_TYPE hook_constcharptr_const_tree_null\n-#define TARGET_PROMOTED_TYPE hook_tree_const_tree_null\n-#define TARGET_CONVERT_TO_TYPE hook_tree_tree_tree_null\n-\n-#define TARGET_FIXED_CONDITION_CODE_REGS hook_bool_uintp_uintp_false\n-\n-#define TARGET_CC_MODES_COMPATIBLE default_cc_modes_compatible\n-\n-#define TARGET_MACHINE_DEPENDENT_REORG 0\n-\n-#define TARGET_BUILD_BUILTIN_VA_LIST std_build_builtin_va_list\n-#define TARGET_FN_ABI_VA_LIST std_fn_abi_va_list\n-#define TARGET_CANONICAL_VA_LIST_TYPE std_canonical_va_list_type\n-#define TARGET_EXPAND_BUILTIN_VA_START 0\n-\n-#define TARGET_GET_PCH_VALIDITY default_get_pch_validity\n-#define TARGET_PCH_VALID_P default_pch_valid_p\n-#define TARGET_CHECK_PCH_TARGET_FLAGS NULL\n-\n-#define TARGET_DEFAULT_SHORT_ENUMS hook_bool_void_false\n-\n-#define TARGET_BUILTIN_SETJMP_FRAME_VALUE default_builtin_setjmp_frame_value\n-\n-#define TARGET_MD_ASM_CLOBBERS hook_tree_tree_tree_tree_3rd_identity\n-\n-#define TARGET_DWARF_CALLING_CONVENTION hook_int_const_tree_0\n-\n-#define TARGET_DWARF_HANDLE_FRAME_UNSPEC 0\n-\n-#define TARGET_STDARG_OPTIMIZE_HOOK 0\n-\n-#define TARGET_STACK_PROTECT_GUARD  default_stack_protect_guard\n-#define TARGET_STACK_PROTECT_FAIL   default_external_stack_protect_fail\n-\n-#define TARGET_ARM_EABI_UNWINDER false\n-\n-#define TARGET_PROMOTE_FUNCTION_MODE default_promote_function_mode\n-#define TARGET_PROMOTE_PROTOTYPES hook_bool_const_tree_false\n-\n-#define TARGET_STRUCT_VALUE_RTX hook_rtx_tree_int_null\n-#define TARGET_RETURN_IN_MEMORY default_return_in_memory\n-#define TARGET_RETURN_IN_MSB hook_bool_const_tree_false\n-\n-#define TARGET_EXPAND_BUILTIN_SAVEREGS default_expand_builtin_saveregs\n-#define TARGET_SETUP_INCOMING_VARARGS default_setup_incoming_varargs\n-#define TARGET_STRICT_ARGUMENT_NAMING hook_bool_CUMULATIVE_ARGS_false\n-#define TARGET_PRETEND_OUTGOING_VARARGS_NAMED \\\n-  default_pretend_outgoing_varargs_named\n-#define TARGET_SPLIT_COMPLEX_ARG NULL\n-\n-#define TARGET_GIMPLIFY_VA_ARG_EXPR std_gimplify_va_arg_expr\n-#define TARGET_PASS_BY_REFERENCE hook_bool_CUMULATIVE_ARGS_mode_tree_bool_false\n-\n-#define TARGET_RELAXED_ORDERING false\n-\n-#define TARGET_MUST_PASS_IN_STACK must_pass_in_stack_var_size_or_pad\n-#define TARGET_CALLEE_COPIES hook_bool_CUMULATIVE_ARGS_mode_tree_bool_false\n-#define TARGET_ARG_PARTIAL_BYTES hook_int_CUMULATIVE_ARGS_mode_tree_bool_0\n-\n-#ifndef TARGET_FUNCTION_ARG_ADVANCE\n-#define TARGET_FUNCTION_ARG_ADVANCE default_function_arg_advance\n-#endif\n-\n-#ifndef TARGET_FUNCTION_ARG\n-#define TARGET_FUNCTION_ARG default_function_arg\n-#endif\n-\n-#ifndef TARGET_FUNCTION_INCOMING_ARG\n-#ifndef FUNCTION_INCOMING_ARG\n-#define TARGET_FUNCTION_INCOMING_ARG TARGET_FUNCTION_ARG\n-#else\n-#define TARGET_FUNCTION_INCOMING_ARG default_function_incoming_arg\n-#endif\n-#endif\n-\n-#define TARGET_FUNCTION_VALUE default_function_value\n-#define TARGET_LIBCALL_VALUE default_libcall_value\n-#define TARGET_FUNCTION_VALUE_REGNO_P default_function_value_regno_p\n-#define TARGET_INTERNAL_ARG_POINTER default_internal_arg_pointer\n-#define TARGET_UPDATE_STACK_BOUNDARY NULL\n-#define TARGET_GET_DRAP_RTX NULL\n-#define TARGET_ALLOCATE_STACK_SLOTS_FOR_ARGS hook_bool_void_true\n-#define TARGET_STATIC_CHAIN default_static_chain\n-#define TARGET_TRAMPOLINE_INIT default_trampoline_init\n-#define TARGET_TRAMPOLINE_ADJUST_ADDRESS NULL\n-#define TARGET_RETURN_POPS_ARGS default_return_pops_args\n-\n-#define TARGET_CALLS {\t\t\t\t\t\t\\\n-   TARGET_PROMOTE_FUNCTION_MODE,\t\t\t\t\\\n-   TARGET_PROMOTE_PROTOTYPES,\t\t\t\t\t\\\n-   TARGET_STRUCT_VALUE_RTX,\t\t\t\t\t\\\n-   TARGET_RETURN_IN_MEMORY,\t\t\t\t\t\\\n-   TARGET_RETURN_IN_MSB,\t\t\t\t\t\\\n-   TARGET_PASS_BY_REFERENCE,\t\t\t\t\t\\\n-   TARGET_EXPAND_BUILTIN_SAVEREGS,\t\t\t\t\\\n-   TARGET_SETUP_INCOMING_VARARGS,\t\t\t\t\\\n-   TARGET_STRICT_ARGUMENT_NAMING,\t\t\t\t\\\n-   TARGET_PRETEND_OUTGOING_VARARGS_NAMED,\t\t\t\\\n-   TARGET_SPLIT_COMPLEX_ARG,\t\t\t\t\t\\\n-   TARGET_MUST_PASS_IN_STACK,\t\t\t\t\t\\\n-   TARGET_CALLEE_COPIES,\t\t\t\t\t\\\n-   TARGET_ARG_PARTIAL_BYTES,\t\t\t\t\t\\\n-   TARGET_FUNCTION_ARG_ADVANCE,\t\t\t\t\t\\\n-   TARGET_FUNCTION_ARG,\t\t\t\t\t\t\\\n-   TARGET_FUNCTION_INCOMING_ARG,\t\t\t\t\\\n-   TARGET_INVALID_ARG_FOR_UNPROTOTYPED_FN,\t\t\t\\\n-   TARGET_FUNCTION_VALUE,\t\t\t\t\t\\\n-   TARGET_LIBCALL_VALUE,\t\t\t\t\t\\\n-   TARGET_FUNCTION_VALUE_REGNO_P,\t\t\t\t\\\n-   TARGET_INTERNAL_ARG_POINTER,\t\t\t\t\t\\\n-   TARGET_UPDATE_STACK_BOUNDARY,\t\t\t\t\\\n-   TARGET_GET_DRAP_RTX,\t\t\t\t\t\t\\\n-   TARGET_ALLOCATE_STACK_SLOTS_FOR_ARGS,\t\t\t\\\n-   TARGET_STATIC_CHAIN,\t\t\t\t\t\t\\\n-   TARGET_TRAMPOLINE_INIT,\t\t\t\t\t\\\n-   TARGET_TRAMPOLINE_ADJUST_ADDRESS,\t\t\t\t\\\n-   TARGET_RETURN_POPS_ARGS\t\t\t\t\t\\\n-   }\n-\n-#ifndef TARGET_UNWIND_TABLES_DEFAULT\n-#define TARGET_UNWIND_TABLES_DEFAULT false\n-#endif\n-\n-#ifndef TARGET_HANDLE_PRAGMA_EXTERN_PREFIX\n-#define TARGET_HANDLE_PRAGMA_EXTERN_PREFIX 0\n-#endif\n-\n-#ifdef IRA_COVER_CLASSES\n-#define TARGET_IRA_COVER_CLASSES default_ira_cover_classes\n-#else\n+#ifndef IRA_COVER_CLASSES\n #define TARGET_IRA_COVER_CLASSES 0\n #endif\n \n-#ifndef TARGET_SECONDARY_RELOAD\n-#define TARGET_SECONDARY_RELOAD default_secondary_reload\n-#endif\n-\n-#ifndef TARGET_EXPAND_TO_RTL_HOOK\n-#define TARGET_EXPAND_TO_RTL_HOOK hook_void_void\n-#endif\n-\n-#ifndef TARGET_INSTANTIATE_DECLS\n-#define TARGET_INSTANTIATE_DECLS hook_void_void\n-#endif\n-\n-#ifndef TARGET_HARD_REGNO_SCRATCH_OK\n-#define TARGET_HARD_REGNO_SCRATCH_OK default_hard_regno_scratch_ok\n-#endif\n-\n-#ifndef TARGET_CASE_VALUES_THRESHOLD\n-#define TARGET_CASE_VALUES_THRESHOLD default_case_values_threshold\n-#endif\n-\n-#ifndef TARGET_FRAME_POINTER_REQUIRED\n-#define TARGET_FRAME_POINTER_REQUIRED hook_bool_void_false\n-#endif\n-\n-#ifndef TARGET_CAN_ELIMINATE\n-#define TARGET_CAN_ELIMINATE hook_bool_const_int_const_int_true\n-#endif\n-\n-/* C specific.  */\n-#ifndef TARGET_C_MODE_FOR_SUFFIX\n-#define TARGET_C_MODE_FOR_SUFFIX default_mode_for_suffix\n-#endif\n-\n-#define TARGET_C\t\t\t\t\\\n-  {\t\t\t\t\t\t\\\n-    TARGET_C_MODE_FOR_SUFFIX\t\t\t\\\n-  }\n-\n-/* C++ specific.  */\n-#ifndef TARGET_CXX_GUARD_TYPE\n-#define TARGET_CXX_GUARD_TYPE default_cxx_guard_type\n-#endif\n-\n-#ifndef TARGET_CXX_GUARD_MASK_BIT\n-#define TARGET_CXX_GUARD_MASK_BIT hook_bool_void_false\n-#endif\n-\n-#ifndef TARGET_CXX_GET_COOKIE_SIZE\n-#define TARGET_CXX_GET_COOKIE_SIZE default_cxx_get_cookie_size\n-#endif\n-\n-#ifndef TARGET_CXX_COOKIE_HAS_SIZE\n-#define TARGET_CXX_COOKIE_HAS_SIZE hook_bool_void_false\n-#endif\n-\n-#ifndef TARGET_CXX_IMPORT_EXPORT_CLASS\n-#define TARGET_CXX_IMPORT_EXPORT_CLASS NULL\n-#endif\n-\n-#ifndef TARGET_CXX_CDTOR_RETURNS_THIS\n-#define TARGET_CXX_CDTOR_RETURNS_THIS hook_bool_void_false\n-#endif\n-\n-#ifndef TARGET_CXX_KEY_METHOD_MAY_BE_INLINE\n-#define TARGET_CXX_KEY_METHOD_MAY_BE_INLINE hook_bool_void_true\n-#endif\n-\n-#ifndef TARGET_CXX_DETERMINE_CLASS_DATA_VISIBILITY\n-#define TARGET_CXX_DETERMINE_CLASS_DATA_VISIBILITY hook_void_tree\n-#endif\n-\n-#ifndef TARGET_CXX_CLASS_DATA_ALWAYS_COMDAT\n-#define TARGET_CXX_CLASS_DATA_ALWAYS_COMDAT hook_bool_void_true\n-#endif\n-\n-#ifndef TARGET_CXX_LIBRARY_RTTI_COMDAT\n-#define TARGET_CXX_LIBRARY_RTTI_COMDAT hook_bool_void_true\n-#endif\n-\n-#ifndef TARGET_CXX_USE_AEABI_ATEXIT\n-#define TARGET_CXX_USE_AEABI_ATEXIT hook_bool_void_false\n-#endif\n-\n-#ifndef TARGET_CXX_USE_ATEXIT_FOR_CXA_ATEXIT\n-#define TARGET_CXX_USE_ATEXIT_FOR_CXA_ATEXIT hook_bool_void_false\n-#endif\n-\n-#ifndef TARGET_CXX_ADJUST_CLASS_AT_DEFINITION\n-#define TARGET_CXX_ADJUST_CLASS_AT_DEFINITION hook_void_tree\n-#endif\n-\n-#define TARGET_CXX\t\t\t\t\\\n-  {\t\t\t\t\t\t\\\n-    TARGET_CXX_GUARD_TYPE,\t\t\t\\\n-    TARGET_CXX_GUARD_MASK_BIT,\t\t\t\\\n-    TARGET_CXX_GET_COOKIE_SIZE,\t\t\t\\\n-    TARGET_CXX_COOKIE_HAS_SIZE,\t\t\t\\\n-    TARGET_CXX_IMPORT_EXPORT_CLASS,\t\t\\\n-    TARGET_CXX_CDTOR_RETURNS_THIS,\t\t\\\n-    TARGET_CXX_KEY_METHOD_MAY_BE_INLINE,\t\\\n-    TARGET_CXX_DETERMINE_CLASS_DATA_VISIBILITY,\t\\\n-    TARGET_CXX_CLASS_DATA_ALWAYS_COMDAT,        \\\n-    TARGET_CXX_LIBRARY_RTTI_COMDAT,\t        \\\n-    TARGET_CXX_USE_AEABI_ATEXIT,\t\t\\\n-    TARGET_CXX_USE_ATEXIT_FOR_CXA_ATEXIT,\t\\\n-    TARGET_CXX_ADJUST_CLASS_AT_DEFINITION\t\\\n-  }\n-\n-/* EMUTLS specific */\n-#ifndef TARGET_EMUTLS_GET_ADDRESS\n-#define TARGET_EMUTLS_GET_ADDRESS \"__builtin___emutls_get_address\"\n-#endif\n-\n-#ifndef TARGET_EMUTLS_REGISTER_COMMON\n-#define TARGET_EMUTLS_REGISTER_COMMON \"__builtin___emutls_register_common\"\n-#endif\n-\n-#ifndef TARGET_EMUTLS_VAR_SECTION\n-#define TARGET_EMUTLS_VAR_SECTION NULL\n-#endif\n-\n-#ifndef TARGET_EMUTLS_TMPL_SECTION\n-#define TARGET_EMUTLS_TMPL_SECTION NULL\n-#endif\n-\n-#ifndef TARGET_EMUTLS_VAR_PREFIX\n-#define TARGET_EMUTLS_VAR_PREFIX NULL\n-#endif\n-\n-#ifndef TARGET_EMUTLS_TMPL_PREFIX\n-#define TARGET_EMUTLS_TMPL_PREFIX NULL\n-#endif\n-\n-#ifndef TARGET_EMUTLS_VAR_FIELDS\n-#define TARGET_EMUTLS_VAR_FIELDS default_emutls_var_fields\n-#endif\n-\n-#ifndef TARGET_EMUTLS_VAR_INIT\n-#define TARGET_EMUTLS_VAR_INIT default_emutls_var_init\n-#endif\n-\n-#ifndef TARGET_EMUTLS_VAR_ALIGN_FIXED\n-#define TARGET_EMUTLS_VAR_ALIGN_FIXED false\n-#endif\n-\n-#ifndef TARGET_EMUTLS_DEBUG_FORM_TLS_ADDRESS\n-#define TARGET_EMUTLS_DEBUG_FORM_TLS_ADDRESS false\n-#endif\n-\n-#define TARGET_EMUTLS\t\t\t\t\\\n-  {\t\t\t\t\t\t\\\n-    TARGET_EMUTLS_GET_ADDRESS,  \t\t\\\n-    TARGET_EMUTLS_REGISTER_COMMON,  \t\t\\\n-    TARGET_EMUTLS_VAR_SECTION,  \t\t\\\n-    TARGET_EMUTLS_TMPL_SECTION,  \t\t\\\n-    TARGET_EMUTLS_VAR_PREFIX,  \t\t\t\\\n-    TARGET_EMUTLS_TMPL_PREFIX,  \t\t\\\n-    TARGET_EMUTLS_VAR_FIELDS,\t\t\t\\\n-    TARGET_EMUTLS_VAR_INIT,\t\t\t\\\n-    TARGET_EMUTLS_VAR_ALIGN_FIXED,\t\t\\\n-    TARGET_EMUTLS_DEBUG_FORM_TLS_ADDRESS\t\\\n-  }\n-\n-/* Function specific option attribute support.  */\n-#ifndef TARGET_OPTION_VALID_ATTRIBUTE_P\n-#define TARGET_OPTION_VALID_ATTRIBUTE_P \\\n-  default_target_option_valid_attribute_p\n-#endif\n-\n-#ifndef TARGET_OPTION_SAVE\n-#define TARGET_OPTION_SAVE NULL\n-#endif\n-\n-#ifndef TARGET_OPTION_RESTORE\n-#define TARGET_OPTION_RESTORE NULL\n-#endif\n-\n-#ifndef TARGET_OPTION_PRINT\n-#define TARGET_OPTION_PRINT NULL\n-#endif\n-\n-#ifndef TARGET_OPTION_PRAGMA_PARSE\n-#define TARGET_OPTION_PRAGMA_PARSE default_target_option_pragma_parse\n-#endif\n-\n-#ifndef TARGET_OPTION_OVERRIDE\n-#define TARGET_OPTION_OVERRIDE default_target_option_override\n-#endif\n-\n-#ifndef TARGET_CAN_INLINE_P\n-#define TARGET_CAN_INLINE_P default_target_can_inline_p\n+#if !defined (TARGET_FUNCTION_INCOMING_ARG) && !defined (FUNCTION_INCOMING_ARG)\n+#define TARGET_FUNCTION_INCOMING_ARG TARGET_FUNCTION_ARG\n #endif\n \n-#define TARGET_OPTION_HOOKS\t\t\t\\\n-  {\t\t\t\t\t\t\\\n-    TARGET_OPTION_VALID_ATTRIBUTE_P,\t\t\\\n-    TARGET_OPTION_SAVE,\t\t\t\t\\\n-    TARGET_OPTION_RESTORE,\t\t\t\\\n-    TARGET_OPTION_PRINT,\t\t\t\\\n-    TARGET_OPTION_PRAGMA_PARSE,\t\t\t\\\n-    TARGET_OPTION_OVERRIDE,\t\t\t\\\n-    TARGET_CAN_INLINE_P,\t\t\t\\\n-  }\n-\n-/* The whole shebang.  */\n-#define TARGET_INITIALIZER\t\t\t\\\n-{\t\t\t\t\t\t\\\n-  TARGET_ASM_OUT,\t\t\t\t\\\n-  TARGET_SCHED,\t\t\t\t\t\\\n-  TARGET_VECTORIZE,\t\t\t\t\\\n-  TARGET_DEFAULT_TARGET_FLAGS,\t\t\t\\\n-  TARGET_OVERRIDE_OPTIONS_AFTER_CHANGE,\t\t\\\n-  TARGET_HANDLE_OPTION,\t\t\t\t\\\n-  TARGET_HANDLE_OFAST,\t\t\t\t\\\n-  TARGET_HELP,\t\t\t\t\t\\\n-  TARGET_EH_RETURN_FILTER_MODE,\t\t\t\\\n-  TARGET_LIBGCC_CMP_RETURN_MODE,                \\\n-  TARGET_LIBGCC_SHIFT_COUNT_MODE,               \\\n-  TARGET_UNWIND_WORD_MODE,\t\t\t\\\n-  TARGET_MERGE_DECL_ATTRIBUTES,\t\t\t\\\n-  TARGET_MERGE_TYPE_ATTRIBUTES,\t\t\t\\\n-  TARGET_ATTRIBUTE_TABLE,\t\t\t\\\n-  TARGET_ATTRIBUTE_TAKES_IDENTIFIER_P,\t\t\\\n-  TARGET_COMP_TYPE_ATTRIBUTES,\t\t\t\\\n-  TARGET_SET_DEFAULT_TYPE_ATTRIBUTES,\t\t\\\n-  TARGET_INSERT_ATTRIBUTES,\t\t\t\\\n-  TARGET_FUNCTION_ATTRIBUTE_INLINABLE_P,\t\\\n-  TARGET_MS_BITFIELD_LAYOUT_P,\t\t\t\\\n-  TARGET_DECIMAL_FLOAT_SUPPORTED_P,\t\t\\\n-  TARGET_FIXED_POINT_SUPPORTED_P,\t\t\\\n-  TARGET_ALIGN_ANON_BITFIELD,\t\t\t\\\n-  TARGET_NARROW_VOLATILE_BITFIELD,\t\t\\\n-  TARGET_INIT_BUILTINS,\t\t\t\t\\\n-  TARGET_BUILTIN_DECL,\t\t\t\t\\\n-  TARGET_EXPAND_BUILTIN,\t\t\t\\\n-  TARGET_RESOLVE_OVERLOADED_BUILTIN,\t\t\\\n-  TARGET_FOLD_BUILTIN,\t\t\t\t\\\n-  TARGET_BUILTIN_RECIPROCAL,\t\t\t\\\n-  TARGET_MANGLE_TYPE,\t\t\t\t\\\n-  TARGET_INIT_LIBFUNCS,\t\t\t\t\\\n-  TARGET_SECTION_TYPE_FLAGS,\t\t\t\\\n-  TARGET_CANNOT_MODIFY_JUMPS_P,\t\t\t\\\n-  TARGET_BRANCH_TARGET_REGISTER_CLASS,\t\t\\\n-  TARGET_BRANCH_TARGET_REGISTER_CALLEE_SAVED,\t\\\n-  TARGET_HAVE_CONDITIONAL_EXECUTION,\t\t\\\n-  TARGET_LOOP_UNROLL_ADJUST,\t\t\t\\\n-  TARGET_CANNOT_FORCE_CONST_MEM,\t\t\\\n-  TARGET_CANNOT_COPY_INSN_P,\t\t\t\\\n-  TARGET_COMMUTATIVE_P,\t\t\t\t\\\n-  TARGET_MODE_DEPENDENT_ADDRESS_P,\t\t\\\n-  TARGET_LEGITIMIZE_ADDRESS,\t\t\t\\\n-  TARGET_DELEGITIMIZE_ADDRESS,\t\t\t\\\n-  TARGET_LEGITIMATE_ADDRESS_P,\t\t\t\\\n-  TARGET_USE_BLOCKS_FOR_CONSTANT_P,\t\t\\\n-  TARGET_MIN_ANCHOR_OFFSET,\t\t\t\\\n-  TARGET_MAX_ANCHOR_OFFSET,\t\t\t\\\n-  TARGET_USE_ANCHORS_FOR_SYMBOL_P,\t\t\\\n-  TARGET_FUNCTION_OK_FOR_SIBCALL,\t\t\\\n-  TARGET_SET_CURRENT_FUNCTION,\t\t\t\\\n-  TARGET_IN_SMALL_DATA_P,\t\t\t\\\n-  TARGET_BINDS_LOCAL_P,\t\t\t\t\\\n-  TARGET_MANGLE_DECL_ASSEMBLER_NAME,\t\t\\\n-  TARGET_ENCODE_SECTION_INFO,\t\t\t\\\n-  TARGET_STRIP_NAME_ENCODING,\t\t\t\\\n-  TARGET_SHIFT_TRUNCATION_MASK,\t\t\t\\\n-  TARGET_MIN_DIVISIONS_FOR_RECIP_MUL,\t\t\\\n-  TARGET_MODE_REP_EXTENDED,\t\t\t\\\n-  TARGET_VALID_POINTER_MODE,                    \\\n-  TARGET_ADDR_SPACE_HOOKS,\t\t\t\\\n-  TARGET_SCALAR_MODE_SUPPORTED_P,\t\t\\\n-  TARGET_VECTOR_MODE_SUPPORTED_P,               \\\n-  TARGET_REGISTER_MOVE_COST,\t\t\t\\\n-  TARGET_MEMORY_MOVE_COST, \t\t\t\\\n-  TARGET_SMALL_REGISTER_CLASSES_FOR_MODE_P,\t\\\n-  TARGET_RTX_COSTS,\t\t\t\t\\\n-  TARGET_ADDRESS_COST,\t\t\t\t\\\n-  TARGET_ALLOCATE_INITIAL_VALUE,\t\t\\\n-  TARGET_UNSPEC_MAY_TRAP_P,                     \\\n-  TARGET_DWARF_REGISTER_SPAN,                   \\\n-  TARGET_INIT_DWARF_REG_SIZES_EXTRA,\t\t\\\n-  TARGET_FIXED_CONDITION_CODE_REGS,\t\t\\\n-  TARGET_CC_MODES_COMPATIBLE,\t\t\t\\\n-  TARGET_MACHINE_DEPENDENT_REORG,\t\t\\\n-  TARGET_BUILD_BUILTIN_VA_LIST,\t\t\t\\\n-  TARGET_ENUM_VA_LIST_P,\t\t\t\\\n-  TARGET_FN_ABI_VA_LIST,\t\t\t\\\n-  TARGET_CANONICAL_VA_LIST_TYPE,\t\t\\\n-  TARGET_EXPAND_BUILTIN_VA_START,\t\t\\\n-  TARGET_GIMPLIFY_VA_ARG_EXPR,\t\t\t\\\n-  TARGET_GET_PCH_VALIDITY,\t\t\t\\\n-  TARGET_PCH_VALID_P,\t\t\t\t\\\n-  TARGET_CHECK_PCH_TARGET_FLAGS,\t\t\\\n-  TARGET_DEFAULT_SHORT_ENUMS,\t\t\t\\\n-  TARGET_BUILTIN_SETJMP_FRAME_VALUE,\t\t\\\n-  TARGET_MD_ASM_CLOBBERS,\t\t\t\\\n-  TARGET_DWARF_CALLING_CONVENTION,              \\\n-  TARGET_DWARF_HANDLE_FRAME_UNSPEC,\t\t\\\n-  TARGET_STDARG_OPTIMIZE_HOOK,\t\t\t\\\n-  TARGET_STACK_PROTECT_GUARD,\t\t\t\\\n-  TARGET_STACK_PROTECT_FAIL,\t\t\t\\\n-  TARGET_INVALID_WITHIN_DOLOOP,\t\t\t\\\n-  TARGET_VALID_DLLIMPORT_ATTRIBUTE_P,\t\t\\\n-  TARGET_CONST_ANCHOR,\t\t\t\t\\\n-  TARGET_CALLS,\t\t\t\t\t\\\n-  TARGET_INVALID_CONVERSION,\t\t\t\\\n-  TARGET_INVALID_UNARY_OP,\t\t\t\\\n-  TARGET_INVALID_BINARY_OP,\t\t\t\\\n-  TARGET_INVALID_PARAMETER_TYPE,\t\t\\\n-  TARGET_INVALID_RETURN_TYPE,\t\t\t\\\n-  TARGET_PROMOTED_TYPE,\t\t\t\t\\\n-  TARGET_CONVERT_TO_TYPE,\t\t\t\\\n-  TARGET_IRA_COVER_CLASSES,\t\t\t\\\n-  TARGET_SECONDARY_RELOAD,\t\t\t\\\n-  TARGET_EXPAND_TO_RTL_HOOK,\t\t\t\\\n-  TARGET_INSTANTIATE_DECLS,\t\t\t\\\n-  TARGET_HARD_REGNO_SCRATCH_OK,\t\t\t\\\n-  TARGET_CASE_VALUES_THRESHOLD,\t\t\t\\\n-  TARGET_FRAME_POINTER_REQUIRED,\t\t\\\n-  TARGET_CAN_ELIMINATE,\t\t\t\t\\\n-  TARGET_C,\t\t\t\t\t\\\n-  TARGET_CXX,\t\t\t\t\t\\\n-  TARGET_EMUTLS,\t\t\t\t\\\n-  TARGET_OPTION_HOOKS,\t\t\t\t\\\n-  TARGET_EXTRA_LIVE_ON_ENTRY,\t\t\t\\\n-  TARGET_UNWIND_TABLES_DEFAULT,\t\t\t\\\n-  TARGET_HAVE_NAMED_SECTIONS,\t\t\t\\\n-  TARGET_HAVE_SWITCHABLE_BSS_SECTIONS,\t\t\\\n-  TARGET_HAVE_CTORS_DTORS,\t\t\t\\\n-  TARGET_HAVE_TLS,\t\t\t\t\\\n-  TARGET_HAVE_SRODATA_SECTION,\t\t\t\\\n-  TARGET_TERMINATE_DW2_EH_FRAME_INFO,\t\t\\\n-  TARGET_ASM_FILE_START_APP_OFF,\t\t\\\n-  TARGET_ASM_FILE_START_FILE_DIRECTIVE,\t\t\\\n-  TARGET_HANDLE_PRAGMA_EXTERN_PREFIX,\t\t\\\n-  TARGET_RELAXED_ORDERING,\t\t\t\\\n-  TARGET_ARM_EABI_UNWINDER\t\t\t\\\n-}\n-\n-#define TARGET_HANDLE_C_OPTION default_handle_c_option\n-#define TARGETCM_INITIALIZER { TARGET_HANDLE_C_OPTION }\n+#include \"target-hooks-def.h\"\n \n #include \"hooks.h\"\n #include \"targhooks.h\""}, {"sha": "efc412849a29a03db340a1919e151f65ec2c9e7d", "filename": "gcc/target.def", "status": "added", "additions": 2370, "deletions": 0, "changes": 2370, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38f8b050edd36ac977c564cab41cc1ce8e8a073e/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38f8b050edd36ac977c564cab41cc1ce8e8a073e/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=38f8b050edd36ac977c564cab41cc1ce8e8a073e", "patch": "@@ -0,0 +1,2370 @@\n+/* Target hook definitions.\n+   Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010\n+   Free Software Foundation, Inc.\n+\n+   This program is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by the\n+   Free Software Foundation; either version 3, or (at your option) any\n+   later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.\n+\n+   In other words, you are welcome to use, share and improve this program.\n+   You are forbidden to forbid anyone else to use, share and improve\n+   what you give them.   Help stamp out software-hoarding!  */\n+\n+/* The following macros should be provided by the including file:\n+\n+   DEFHOOK(NAME, DOC, TYPE, PARAMS, INIT): Define a function-valued hook.\n+   DEFHOOKPOD(DOC, TYPE, NAME, INIT): Define a piece-of-data 'hook'.  */\n+\n+/* Defaults for optional macros:\n+   DEFHOOKPODX(NAME, TYPE, INIT): Like DEFHOOKPOD, but share documentation\n+   with the previous 'hook'.  */\n+#ifndef DEFHOOKPODX\n+#define DEFHOOKPODX(NAME, TYPE, INIT) DEFHOOKPOD (NAME, 0, TYPE, INIT)\n+#endif\n+   \n+/* HOOKSTRUCT(FRAGMENT): Declarator fragments to encapsulate all the\n+   members into a struct gcc_target, which in turn contains several\n+   sub-structs.  */\n+#ifndef HOOKSTRUCT\n+#define HOOKSTRUCT(FRAGMENT)\n+#endif\n+/* HOOK_VECTOR: Start a struct declaration, which then gets its own initializer.\n+   HOOK_VECTOR_END: Close a struct declaration, providing a member declarator\n+                    name for nested use.  */\n+#ifndef HOOK_VECTOR_1\n+#define HOOK_VECTOR_1(NAME, FRAGMENT) HOOKSTRUCT(FRAGMENT)\n+#endif\n+#define HOOK_VECTOR(INIT_NAME, SNAME) HOOK_VECTOR_1 (INIT_NAME, struct SNAME {)\n+#define HOOK_VECTOR_END(DECL_NAME) HOOK_VECTOR_1(,} DECL_NAME ;)\n+\n+HOOK_VECTOR (TARGET_INITIALIZER, gcc_target)\n+\n+/* FIXME: For pre-existing hooks, we can't place the documentation in the\n+   documentation field here till we get permission from the FSF to include\n+   it in GPLed software - the target hook documentation is so far only\n+   available under the GFDL.  */\n+\n+/* A hook should generally be documented by a string in the DOC parameter,\n+   which should contain texinfo markup.  If the documentation is only available\n+   under the GPL, but not under the GFDL, put it in a comment above the hook\n+   definition.  If the function declaration is available both under GPL and\n+   GFDL, but the documentation is only available under the GFDL, put the\n+   documentaton in tm.texi.in, heading with @hook <hookname> and closing\n+   the paragraph with @end deftypefn / deftypevr as appropriate, and marking\n+   the next autogenerated hook with @hook <hookname>.\n+   In both these cases, leave the DOC string empty, i.e. \"\".\n+   Sometimes, the function declaration itself is only available under the\n+   GPL, and/or for some historic reason it has to be documented differently\n+   than what it is.  In that case, use DEFHOOK_UNDOC to supress auto-generation\n+   of documentation.  DEFHOOK_UNDOC takes a DOC string which it ignores, so\n+   you can put GPLed documentation string there if you have hopes that you\n+   can clear the declaration & documentation for GFDL distribution later,\n+   in which case you can then simply change the DEFHOOK_UNDOC to DEFHOOK\n+   to turn on the autogeneration of the documentation.\n+\n+   A documentation string of \"*\" means not to emit any documentation at all,\n+   and is mainly used internally for DEFHOOK_UNDOC.  It should generally not\n+   be used otherwise, but it has its use for exceptional cases where automatic\n+   documentation is not wanted, and the real documentation is elsewere, like\n+   for TARGET_ASM_{,UN}ALIGNED_INT_OP, which are hooks only for implementation\n+   purposes; they refer to structs, the components of which are documented as\n+   separate hooks TARGET_ASM_{,UN}ALIGNED_[HSDT]I_OP.\n+   A DOC string of 0 is for internal use of DEFHOOKPODX and special table\n+   entries only.  */\n+\n+/* Functions that output assembler for the target.  */\n+#define HOOK_PREFIX \"TARGET_ASM_\"\n+HOOK_VECTOR (TARGET_ASM_OUT, asm_out)\n+\n+/* Opening and closing parentheses for asm expression grouping.  */\n+DEFHOOKPOD\n+(open_paren,\n+ \"\",\n+ const char *, \"(\")\n+DEFHOOKPODX (close_paren, const char *, \")\")\n+\n+/* Assembler instructions for creating various kinds of integer object.  */\n+DEFHOOKPOD\n+(byte_op,\n+ \"\",\n+ const char *, \"\\t.byte\\t\")\n+DEFHOOKPOD (aligned_op, \"*\", struct asm_int_op, TARGET_ASM_ALIGNED_INT_OP)\n+DEFHOOKPOD (unaligned_op, \"*\", struct asm_int_op, TARGET_ASM_UNALIGNED_INT_OP)\n+\n+/* Try to output the assembler code for an integer object whose\n+   value is given by X.  SIZE is the size of the object in bytes and\n+   ALIGNED_P indicates whether it is aligned.  Return true if\n+   successful.  Only handles cases for which BYTE_OP, ALIGNED_OP\n+   and UNALIGNED_OP are NULL.  */\n+DEFHOOK\n+(integer,\n+ \"\",\n+ /* Only handles cases for which BYTE_OP, ALIGNED_OP and UNALIGNED_OP are\n+    NULL.  */\n+ bool, (rtx x, unsigned int size, int aligned_p),\n+ default_assemble_integer)\n+\n+/* Output code that will globalize a label.  */\n+DEFHOOK\n+(globalize_label,\n+ \"\",\n+ void, (FILE *stream, const char *name),\n+ default_globalize_label)\n+\n+/* Output code that will globalize a declaration.  */\n+DEFHOOK\n+(globalize_decl_name,\n+ \"\",\n+ void, (FILE *stream, tree decl), default_globalize_decl_name)\n+\n+/* Output code that will emit a label for unwind info, if this\n+   target requires such labels.  Second argument is the decl the\n+   unwind info is associated with, third is a boolean: true if\n+   this is for exception handling, fourth is a boolean: true if\n+   this is only a placeholder for an omitted FDE.  */\n+DEFHOOK\n+(emit_unwind_label,\n+ \"\",\n+ void, (FILE *stream, tree decl, int for_eh, int empty),\n+ default_emit_unwind_label)\n+\n+/* Output code that will emit a label to divide up the exception table.  */\n+DEFHOOK\n+(emit_except_table_label,\n+ \"\",\n+ void, (FILE *stream),\n+ default_emit_except_table_label)\n+\n+/* Emit any directives required to unwind this instruction.  */\n+DEFHOOK\n+(unwind_emit,\n+ \"\",\n+ void, (FILE *stream, rtx insn),\n+ default_unwind_emit)\n+\n+/* Output an internal label.  */\n+DEFHOOK\n+(internal_label,\n+ \"\",\n+ void, (FILE *stream, const char *prefix, unsigned long labelno),\n+ default_internal_label)\n+\n+/* Output label for the constant.  */\n+/* ??? The documentation uses a different name for the hook argument EXP.  */\n+DEFHOOK_UNDOC\n+(declare_constant_name,\n+ \"\",\n+ void, (FILE *file, const char *name, const_tree exp, HOST_WIDE_INT size),\n+ default_asm_declare_constant_name)\n+\n+/* Emit a ttype table reference to a typeinfo object.  */\n+DEFHOOK\n+(ttype,\n+ \"\",\n+ bool, (rtx sym),\n+ hook_bool_rtx_false)\n+\n+/* Emit an assembler directive to set visibility for the symbol\n+   associated with the tree decl.  */\n+DEFHOOK\n+(assemble_visibility,\n+ \"\",\n+ void, (tree decl, int visibility),\n+ default_assemble_visibility)\n+\n+/* Output the assembler code for entry to a function.  */\n+DEFHOOK\n+(function_prologue,\n+ \"\",\n+ void, (FILE *file, HOST_WIDE_INT size),\n+ default_function_pro_epilogue)\n+\n+/* Output the assembler code for end of prologue.  */\n+DEFHOOK\n+(function_end_prologue,\n+ \"\",\n+ void, (FILE *file),\n+ no_asm_to_stream)\n+\n+/* Output the assembler code for start of epilogue.  */\n+DEFHOOK\n+(function_begin_epilogue,\n+ \"\",\n+ void, (FILE *file),\n+ no_asm_to_stream)\n+\n+/* Output the assembler code for function exit.  */\n+DEFHOOK\n+(function_epilogue,\n+ \"\",\n+ void, (FILE *file, HOST_WIDE_INT size),\n+ default_function_pro_epilogue)\n+\n+/* Initialize target-specific sections.  */\n+DEFHOOK\n+(init_sections,\n+ \"\",\n+ void, (void),\n+ hook_void_void)\n+\n+/* Tell assembler to change to section NAME with attributes FLAGS.\n+   If DECL is non-NULL, it is the VAR_DECL or FUNCTION_DECL with\n+   which this section is associated.  */\n+DEFHOOK\n+(named_section,\n+ \"\",\n+ void, (const char *name, unsigned int flags, tree decl),\n+ default_no_named_section)\n+\n+/* Return a mask describing how relocations should be treated when\n+   selecting sections.  Bit 1 should be set if global relocations\n+   should be placed in a read-write section; bit 0 should be set if\n+   local relocations should be placed in a read-write section.  */\n+DEFHOOK\n+(reloc_rw_mask,\n+ \"\",\n+ int, (void),\n+ default_reloc_rw_mask)\n+\n+ /* Return a section for EXP.  It may be a DECL or a constant.  RELOC\n+    is nonzero if runtime relocations must be applied; bit 1 will be\n+    set if the runtime relocations require non-local name resolution.\n+    ALIGN is the required alignment of the data.  */\n+DEFHOOK\n+(select_section,\n+ \"\",\n+ section *, (tree exp, int reloc, unsigned HOST_WIDE_INT align),\n+ default_select_section)\n+\n+/* Return a section for X.  MODE is X's mode and ALIGN is its\n+   alignment in bits.  */\n+DEFHOOK\n+(select_rtx_section,\n+ \"\",\n+ section *, (enum machine_mode mode, rtx x, unsigned HOST_WIDE_INT align),\n+ default_select_rtx_section)\n+\n+/* Select a unique section name for DECL.  RELOC is the same as\n+   for SELECT_SECTION.  */\n+DEFHOOK\n+(unique_section,\n+ \"\",\n+ void, (tree decl, int reloc),\n+ default_unique_section)\n+\n+/* Return the readonly data section associated with function DECL.  */\n+DEFHOOK\n+(function_rodata_section,\n+ \"\",\n+ section *, (tree decl),\n+ default_function_rodata_section)\n+\n+/* Output a constructor for a symbol with a given priority.  */\n+DEFHOOK\n+(constructor,\n+ \"\",\n+ void, (rtx symbol, int priority), NULL)\n+\n+/* Output a destructor for a symbol with a given priority.  */\n+DEFHOOK\n+(destructor,\n+ \"\",\n+ void, (rtx symbol, int priority), NULL)\n+\n+/* Output the assembler code for a thunk function.  THUNK_DECL is the\n+   declaration for the thunk function itself, FUNCTION is the decl for\n+   the target function.  DELTA is an immediate constant offset to be\n+   added to THIS.  If VCALL_OFFSET is nonzero, the word at\n+   *(*this + vcall_offset) should be added to THIS.  */\n+DEFHOOK\n+(output_mi_thunk,\n+ \"\",\n+ void, (FILE *file, tree thunk_fndecl, HOST_WIDE_INT delta,\n+\tHOST_WIDE_INT vcall_offset, tree function),\n+ NULL)\n+\n+/* Determine whether output_mi_thunk would succeed.  */\n+/* ??? Ideally, this hook would not exist, and success or failure\n+   would be returned from output_mi_thunk directly.  But there's\n+   too much undo-able setup involved in invoking output_mi_thunk.\n+   Could be fixed by making output_mi_thunk emit rtl instead of\n+   text to the output file.  */\n+DEFHOOK\n+(can_output_mi_thunk,\n+ \"\",\n+ bool, (const_tree thunk_fndecl, HOST_WIDE_INT delta,\n+\tHOST_WIDE_INT vcall_offset, const_tree function),\n+ hook_bool_const_tree_hwi_hwi_const_tree_false)\n+\n+/* Output any boilerplate text needed at the beginning of a\n+   translation unit.  */\n+DEFHOOK\n+(file_start,\n+ \"\",\n+ void, (void),\n+ default_file_start)\n+\n+/* Output any boilerplate text needed at the end of a translation unit.  */\n+DEFHOOK\n+(file_end,\n+ \"\",\n+ void, (void),\n+ hook_void_void)\n+\n+/* Output any boilerplate text needed at the beginning of an\n+   LTO output stream.  */\n+DEFHOOK\n+(lto_start,\n+ \"\",\n+ void, (void),\n+ hook_void_void)\n+\n+/* Output any boilerplate text needed at the end of an\n+   LTO output stream.  */\n+DEFHOOK\n+(lto_end,\n+ \"\",\n+ void, (void),\n+ hook_void_void)\n+\n+/* Output any boilerplace text needed at the end of a\n+   translation unit before debug and unwind info is emitted.  */\n+DEFHOOK\n+(code_end,\n+ \"\",\n+ void, (void),\n+ hook_void_void)\n+\n+/* Output an assembler pseudo-op to declare a library function name\n+   external.  */\n+DEFHOOK\n+(external_libcall,\n+ \"\",\n+ void, (rtx symref),\n+ default_external_libcall)\n+\n+/* Output an assembler directive to mark decl live. This instructs\n+   linker to not dead code strip this symbol.  */\n+DEFHOOK\n+(mark_decl_preserved,\n+ \"\",\n+ void, (const char *symbol),\n+ hook_void_constcharptr)\n+\n+/* Output a record of the command line switches that have been passed.  */\n+DEFHOOK\n+(record_gcc_switches,\n+ \"\",\n+ int, (print_switch_type type, const char *text),\n+ NULL)\n+\n+/* The name of the section that the example ELF implementation of\n+   record_gcc_switches will use to store the information.  Target\n+   specific versions of record_gcc_switches may or may not use\n+   this information.  */\n+DEFHOOKPOD\n+(record_gcc_switches_section,\n+ \"\",\n+ const char *, \".GCC.command.line\")\n+\n+/* Output the definition of a section anchor.  */\n+DEFHOOK\n+(output_anchor,\n+ \"\",\n+ void, (rtx x),\n+ default_asm_output_anchor)\n+\n+/* Output a DTP-relative reference to a TLS symbol.  */\n+DEFHOOK\n+(output_dwarf_dtprel,\n+ \"\",\n+ void, (FILE *file, int size, rtx x),\n+ NULL)\n+\n+/* Some target machines need to postscan each insn after it is output.  */\n+DEFHOOK\n+(final_postscan_insn,\n+ \"\",\n+ void, (FILE *file, rtx insn, rtx *opvec, int noperands),\n+ NULL)\n+\n+/* Emit the trampoline template.  This hook may be NULL.  */\n+DEFHOOK\n+(trampoline_template,\n+ \"\",\n+ void, (FILE *f),\n+ NULL)\n+\n+/* ??? The TARGET_PRINT_OPERAND* hooks are part of the asm_out struct,\n+   even though that is not reflected in the macro name to override their\n+   initializers.  */\n+#undef HOOK_PREFIX\n+#define HOOK_PREFIX \"TARGET_\"\n+\n+/* Emit a machine-specific insn operand.  */\n+/* ??? Documenting the argument types for this hook requires a GFDL\n+   license grant.  Also, the documentation documents this as a macro,\n+   not a hook, and uses a different name for the hook argument FILE.  */\n+DEFHOOK_UNDOC\n+(print_operand,\n+ \"\",\n+ void, (FILE *file, rtx x, int code),\n+ default_print_operand)\n+\n+/* Emit a machine-specific memory address.  */\n+/* ??? Documenting the argument types for this hook requires a GFDL\n+   license grant.  Also, the documentation documents this as a macro,\n+   not a hook, and uses different hook argument names.  */\n+DEFHOOK_UNDOC\n+(print_operand_address,\n+ \"\",\n+ void, (FILE *file, rtx addr),\n+ default_print_operand_address)\n+\n+/* Determine whether CODE is a valid punctuation character for the\n+   `print_operand' hook.  */\n+/* ??? Documenting the argument types for this hook requires a GFDL\n+   license grant.  Also, the documentation documents this as a macro,\n+   not a hook.  */\n+DEFHOOK_UNDOC\n+(print_operand_punct_valid_p,\n+ \"\",\n+ bool ,(unsigned char code),\n+ default_print_operand_punct_valid_p)\n+\n+HOOK_VECTOR_END (asm_out)\n+\n+/* Functions relating to instruction scheduling.  All of these\n+   default to null pointers, which haifa-sched.c looks for and handles.  */\n+#undef HOOK_PREFIX\n+#define HOOK_PREFIX \"TARGET_SCHED_\"\n+HOOK_VECTOR (TARGET_SCHED, sched)\n+\n+/* Given the current cost, COST, of an insn, INSN, calculate and\n+   return a new cost based on its relationship to DEP_INSN through\n+   the dependence LINK.  The default is to make no adjustment.  */\n+DEFHOOK\n+(adjust_cost,\n+ \"\",\n+ int, (rtx insn, rtx link, rtx dep_insn, int cost), NULL)\n+\n+/* Adjust the priority of an insn as you see fit.  Returns the new priority.  */\n+DEFHOOK\n+(adjust_priority,\n+ \"\",\n+ int, (rtx insn, int priority), NULL)\n+\n+/* Function which returns the maximum number of insns that can be\n+   scheduled in the same machine cycle.  This must be constant\n+   over an entire compilation.  The default is 1.  */\n+DEFHOOK\n+(issue_rate,\n+ \"\",\n+ int, (void), NULL)\n+\n+/* Calculate how much this insn affects how many more insns we\n+   can emit this cycle.  Default is they all cost the same.  */\n+DEFHOOK\n+(variable_issue,\n+ \"\",\n+ int, (FILE *file, int verbose, rtx insn, int more), NULL)\n+\n+/* Initialize machine-dependent scheduling code.  */\n+DEFHOOK\n+(init,\n+ \"\",\n+ void, (FILE *file, int verbose, int max_ready), NULL)\n+\n+/* Finalize machine-dependent scheduling code.  */\n+DEFHOOK\n+(finish,\n+ \"\",\n+ void, (FILE *file, int verbose), NULL)\n+\n+ /* Initialize machine-dependent function wide scheduling code.  */\n+DEFHOOK\n+(init_global,\n+ \"\",\n+ void, (FILE *file, int verbose, int old_max_uid), NULL)\n+\n+/* Finalize machine-dependent function wide scheduling code.  */\n+DEFHOOK\n+(finish_global,\n+ \"\",\n+ void, (FILE *file, int verbose), NULL)\n+\n+/* Reorder insns in a machine-dependent fashion, in two different\n+       places.  Default does nothing.  */\n+DEFHOOK\n+(reorder,\n+ \"\",\n+ int, (FILE *file, int verbose, rtx *ready, int *n_readyp, int clock), NULL)\n+\n+DEFHOOK\n+(reorder2,\n+ \"\",\n+ int, (FILE *file, int verbose, rtx *ready, int *n_readyp, int clock), NULL)\n+\n+/* The following member value is a pointer to a function called\n+   after evaluation forward dependencies of insns in chain given\n+   by two parameter values (head and tail correspondingly).  */\n+DEFHOOK\n+(dependencies_evaluation_hook,\n+ \"\",\n+ void, (rtx head, rtx tail), NULL)\n+\n+/* The values of the following four members are pointers to functions\n+   used to simplify the automaton descriptions.  dfa_pre_cycle_insn and\n+   dfa_post_cycle_insn give functions returning insns which are used to\n+   change the pipeline hazard recognizer state when the new simulated\n+   processor cycle correspondingly starts and finishes.  The function\n+   defined by init_dfa_pre_cycle_insn and init_dfa_post_cycle_insn are\n+   used to initialize the corresponding insns.  The default values of\n+   the members result in not changing the automaton state when the\n+   new simulated processor cycle correspondingly starts and finishes.  */\n+\n+DEFHOOK\n+(init_dfa_pre_cycle_insn,\n+ \"\",\n+ void, (void), NULL)\n+\n+DEFHOOK\n+(dfa_pre_cycle_insn,\n+ \"\",\n+ rtx, (void), NULL)\n+\n+DEFHOOK\n+(init_dfa_post_cycle_insn,\n+ \"\",\n+ void, (void), NULL)\n+\n+DEFHOOK\n+(dfa_post_cycle_insn,\n+ \"\",\n+ rtx, (void), NULL)\n+\n+/* The values of the following two members are pointers to\n+   functions used to simplify the automaton descriptions.\n+   dfa_pre_advance_cycle and dfa_post_advance_cycle are getting called\n+   immediately before and after cycle is advanced.  */\n+\n+DEFHOOK\n+(dfa_pre_advance_cycle,\n+ \"\",\n+ void, (void), NULL)\n+\n+DEFHOOK\n+(dfa_post_advance_cycle,\n+ \"\",\n+ void, (void), NULL)\n+\n+/* The following member value is a pointer to a function returning value\n+   which defines how many insns in queue `ready' will we try for\n+   multi-pass scheduling.  If the member value is nonzero and the\n+   function returns positive value, the DFA based scheduler will make\n+   multi-pass scheduling for the first cycle.  In other words, we will\n+   try to choose ready insn which permits to start maximum number of\n+   insns on the same cycle.  */\n+DEFHOOK\n+(first_cycle_multipass_dfa_lookahead,\n+ \"\",\n+ int, (void), NULL)\n+\n+/* The following member value is pointer to a function controlling\n+   what insns from the ready insn queue will be considered for the\n+   multipass insn scheduling.  If the hook returns zero for insn\n+   passed as the parameter, the insn will be not chosen to be issued.  */\n+DEFHOOK\n+(first_cycle_multipass_dfa_lookahead_guard,\n+ \"\",\n+ int, (rtx insn), NULL)\n+\n+/* The following member value is pointer to a function called by\n+   the insn scheduler before issuing insn passed as the third\n+   parameter on given cycle.  If the hook returns nonzero, the\n+   insn is not issued on given processors cycle.  Instead of that,\n+   the processor cycle is advanced.  If the value passed through\n+   the last parameter is zero, the insn ready queue is not sorted\n+   on the new cycle start as usually.  The first parameter passes\n+   file for debugging output.  The second one passes the scheduler\n+   verbose level of the debugging output.  The forth and the fifth\n+   parameter values are correspondingly processor cycle on which\n+   the previous insn has been issued and the current processor cycle.  */\n+/* ??? The documentation uses different names for dump_file,\n+   last_sched_cycle and cur_cycle.  */\n+DEFHOOK_UNDOC\n+(dfa_new_cycle,\n+ \"\",\n+ int, (FILE *dump_file, int verbose, rtx insn, int last_sched_cycle,\n+       int cur_cycle, int *sort_p),\n+ NULL)\n+\n+/* The following member value is a pointer to a function called by the\n+   insn scheduler.  It should return true if there exists a dependence\n+   which is considered costly by the target, between the insn\n+   DEP_PRO (&_DEP), and the insn DEP_CON (&_DEP).  The first parameter is\n+   the dep that represents the dependence between the two insns.  The\n+   second argument is the cost of the dependence as estimated by\n+   the scheduler.  The last argument is the distance in cycles\n+   between the already scheduled insn (first parameter) and the\n+   second insn (second parameter).  */\n+DEFHOOK\n+(is_costly_dependence,\n+ \"\",\n+ bool, (struct _dep *_dep, int cost, int distance), NULL)\n+\n+DEFHOOK_UNDOC\n+(adjust_cost_2,\n+ \"Given the current cost, @var{cost}, of an insn, @var{insn}, calculate and\\\n+ return a new cost based on its relationship to @var{dep_insn} through the\\\n+ dependence of weakness @var{dw}.  The default is to make no adjustment.\",\n+ int, (rtx insn, int dep_type1, rtx dep_insn, int cost, int dw), NULL)\n+\n+/* The following member value is a pointer to a function called\n+   by the insn scheduler. This hook is called to notify the backend\n+   that new instructions were emitted.  */\n+DEFHOOK\n+(h_i_d_extended,\n+ \"\",\n+ void, (void), NULL)\n+\n+/* Next 5 functions are for multi-point scheduling.  */\n+\n+/* Allocate memory for scheduler context.  */\n+DEFHOOK\n+(alloc_sched_context,\n+ \"\",\n+ void *, (void), NULL)\n+\n+/* Fills the context from the local machine scheduler context.  */\n+DEFHOOK\n+(init_sched_context,\n+ \"\",\n+ void, (void *tc, bool clean_p), NULL)\n+\n+/* Sets local machine scheduler context to a saved value.  */\n+DEFHOOK\n+(set_sched_context,\n+ \"\",\n+ void, (void *tc), NULL)\n+\n+/* Clears a scheduler context so it becomes like after init.  */\n+DEFHOOK\n+(clear_sched_context,\n+ \"\",\n+ void, (void *tc), NULL)\n+\n+/* Frees the scheduler context.  */\n+DEFHOOK\n+(free_sched_context,\n+ \"\",\n+ void, (void *tc), NULL)\n+\n+/* The following member value is a pointer to a function called\n+   by the insn scheduler.\n+   The first parameter is an instruction, the second parameter is the type\n+   of the requested speculation, and the third parameter is a pointer to the\n+   speculative pattern of the corresponding type (set if return value == 1).\n+   It should return\n+   -1, if there is no pattern, that will satisfy the requested speculation type,\n+   0, if current pattern satisfies the requested speculation type,\n+   1, if pattern of the instruction should be changed to the newly\n+   generated one.  */\n+DEFHOOK\n+(speculate_insn,\n+ \"\",\n+ int, (rtx insn, int request, rtx *new_pat), NULL)\n+\n+/* The following member value is a pointer to a function called\n+   by the insn scheduler.  It should return true if the check instruction\n+   passed as the parameter needs a recovery block.  */\n+DEFHOOK\n+(needs_block_p,\n+ \"\",\n+ bool, (int dep_status), NULL)\n+\n+/* The following member value is a pointer to a function called\n+   by the insn scheduler.  It should return a pattern for the check\n+   instruction.\n+   The first parameter is a speculative instruction, the second parameter\n+   is the label of the corresponding recovery block (or null, if it is a\n+   simple check).  If the mutation of the check is requested (e.g. from\n+   ld.c to chk.a), the third parameter is true - in this case the first\n+   parameter is the previous check.  */\n+DEFHOOK\n+(gen_spec_check,\n+ \"\",\n+ rtx, (rtx insn, rtx label, int mutate_p), NULL)\n+\n+/* The following member value is a pointer to a function controlling\n+   what insns from the ready insn queue will be considered for the\n+   multipass insn scheduling.  If the hook returns zero for the insn\n+   passed as the parameter, the insn will not be chosen to be\n+   issued.  This hook is used to discard speculative instructions,\n+   that stand at the first position of the ready list.  */\n+DEFHOOK\n+(first_cycle_multipass_dfa_lookahead_guard_spec,\n+ \"\",\n+ bool, (const_rtx insn), NULL)\n+\n+/* The following member value is a pointer to a function that provides\n+   information about the speculation capabilities of the target.\n+   The parameter is a pointer to spec_info variable.  */\n+DEFHOOK\n+(set_sched_flags,\n+ \"\",\n+ void, (struct spec_info_def *spec_info), NULL)\n+\n+DEFHOOK_UNDOC\n+(get_insn_spec_ds,\n+ \"Return speculation types of instruction @var{insn}.\",\n+ int, (rtx insn), NULL)\n+\n+DEFHOOK_UNDOC\n+(get_insn_checked_ds,\n+ \"Return speculation types that are checked for instruction @var{insn}\",\n+ int, (rtx insn), NULL)\n+\n+DEFHOOK_UNDOC\n+(skip_rtx_p,\n+ \"Return bool if rtx scanning should just skip current layer and\\\n+ advance to the inner rtxes.\",\n+ bool, (const_rtx x), NULL)\n+\n+/* The following member value is a pointer to a function that provides\n+   information about the target resource-based lower bound which is\n+   used by the swing modulo scheduler.  The parameter is a pointer\n+   to ddg variable.  */\n+DEFHOOK\n+(sms_res_mii,\n+ \"\",\n+ int, (struct ddg *g), NULL)\n+\n+HOOK_VECTOR_END (sched)\n+\n+/* Functions relating to vectorization.  */\n+#undef HOOK_PREFIX\n+#define HOOK_PREFIX \"TARGET_VECTORIZE_\"\n+HOOK_VECTOR (TARGET_VECTORIZE, vectorize)\n+\n+/* The following member value is a pointer to a function called\n+   by the vectorizer, and return the decl of the target builtin\n+   function.  */\n+DEFHOOK\n+(builtin_mask_for_load,\n+ \"\",\n+ tree, (void), NULL)\n+\n+/* Returns a code for builtin that realizes vectorized version of\n+   function, or NULL_TREE if not available.  */\n+DEFHOOK\n+(builtin_vectorized_function,\n+ \"\",\n+ tree, (tree fndecl, tree vec_type_out, tree vec_type_in),\n+ default_builtin_vectorized_function)\n+\n+/* Returns a function declaration for a builtin that realizes the\n+   vector conversion, or NULL_TREE if not available.  */\n+DEFHOOK\n+(builtin_conversion,\n+ \"\",\n+ tree, (unsigned code, tree dest_type, tree src_type),\n+ default_builtin_vectorized_conversion)\n+\n+/* Target builtin that implements vector widening multiplication.\n+   builtin_mul_widen_eve computes the element-by-element products\n+   for the even elements, and builtin_mul_widen_odd computes the\n+   element-by-element products for the odd elements.  */\n+DEFHOOK\n+(builtin_mul_widen_even,\n+ \"\",\n+ tree, (tree x), NULL)\n+\n+DEFHOOK\n+(builtin_mul_widen_odd,\n+ \"\",\n+ tree, (tree x), NULL)\n+\n+/* Cost of different vector/scalar statements in vectorization cost model.  */\n+DEFHOOK\n+(builtin_vectorization_cost,\n+ \"\",\n+ int, (enum vect_cost_for_stmt type_of_cost),\n+ default_builtin_vectorization_cost)\n+\n+/* Return true if vector alignment is reachable (by peeling N\n+   iterations) for the given type.  */\n+DEFHOOK\n+(vector_alignment_reachable,\n+ \"\",\n+ bool, (const_tree type, bool is_packed),\n+ default_builtin_vector_alignment_reachable)\n+\n+/* Target builtin that implements vector permute.  */\n+DEFHOOK\n+(builtin_vec_perm,\n+ \"\",\n+ tree, (tree type, tree *mask_element_type), NULL)\n+\n+/* Return true if a vector created for builtin_vec_perm is valid.  */\n+DEFHOOK\n+(builtin_vec_perm_ok,\n+ \"\",\n+ bool, (tree vec_type, tree mask),\n+ hook_bool_tree_tree_true)\n+\n+/* Return true if the target supports misaligned store/load of a\n+   specific factor denoted in the third parameter.  The last parameter\n+   is true if the access is defined in a packed struct.  */\n+DEFHOOK\n+(support_vector_misalignment,\n+ \"\",\n+ bool,\n+ (enum machine_mode mode, const_tree type, int misalignment, bool is_packed),\n+ default_builtin_support_vector_misalignment)\n+\n+HOOK_VECTOR_END (vectorize)\n+\n+#undef HOOK_PREFIX\n+#define HOOK_PREFIX \"TARGET_\"\n+\n+/* The initial value of target_flags.  */\n+DEFHOOKPOD\n+(default_target_flags,\n+ \"\",\n+ int, 0)\n+\n+/* Allow target specific overriding of option settings after options have\n+  been changed by an attribute or pragma or when it is reset at the\n+  end of the code affected by an attribute or pragma.  */\n+DEFHOOK\n+(override_options_after_change,\n+ \"\",\n+ void, (void),\n+ hook_void_void)\n+\n+/* Handle target switch CODE (an OPT_* value).  ARG is the argument\n+   passed to the switch; it is NULL if no argument was.  VALUE is the\n+   value of ARG if CODE specifies a UInteger option, otherwise it is\n+   1 if the positive form of the switch was used and 0 if the negative\n+   form was.  Return true if the switch was valid.  */\n+DEFHOOK\n+(handle_option,\n+ \"\",\n+ bool, (size_t code, const char *arg, int value),\n+ hook_bool_size_t_constcharptr_int_true)\n+\n+/* ??? Documenting this hook requires a GFDL license grant.  */\n+DEFHOOK_UNDOC\n+(handle_ofast,\n+ \"Handle target-specific parts of specifying -Ofast.\",\n+ void, (void),\n+ hook_void_void)\n+\n+/* Display extra, target specific information in response to a\n+   --target-help switch.  */\n+DEFHOOK\n+(help,\n+ \"\",\n+ void, (void), NULL)\n+\n+DEFHOOK_UNDOC\n+(eh_return_filter_mode,\n+ \"Return machine mode for filter value.\",\n+ enum machine_mode, (void),\n+ default_eh_return_filter_mode)\n+\n+/* Return machine mode for libgcc expanded cmp instructions.  */\n+DEFHOOK\n+(libgcc_cmp_return_mode,\n+ \"\",\n+ enum machine_mode, (void),\n+ default_libgcc_cmp_return_mode)\n+\n+/* Return machine mode for libgcc expanded shift instructions.  */\n+DEFHOOK\n+(libgcc_shift_count_mode,\n+ \"\",\n+ enum machine_mode, (void),\n+ default_libgcc_shift_count_mode)\n+\n+/* Return machine mode to be used for _Unwind_Word type.  */\n+DEFHOOK\n+(unwind_word_mode,\n+ \"\",\n+ enum machine_mode, (void),\n+ default_unwind_word_mode)\n+\n+/* Given two decls, merge their attributes and return the result.  */\n+DEFHOOK\n+(merge_decl_attributes,\n+ \"\",\n+ tree, (tree olddecl, tree newdecl),\n+ merge_decl_attributes)\n+\n+/* Given two types, merge their attributes and return the result.  */\n+DEFHOOK\n+(merge_type_attributes,\n+ \"\",\n+ tree, (tree type1, tree type2),\n+ merge_type_attributes)\n+\n+/* Table of machine attributes and functions to handle them.\n+   Ignored if NULL.  */\n+DEFHOOKPOD\n+(attribute_table,\n+ \"\",\n+ const struct attribute_spec *, NULL)\n+\n+/* Return true iff attribute NAME expects a plain identifier as its first\n+   argument.  */\n+DEFHOOK\n+(attribute_takes_identifier_p,\n+ \"\",\n+ bool, (const_tree name),\n+ hook_bool_const_tree_false)\n+\n+/* Return zero if the attributes on TYPE1 and TYPE2 are incompatible,\n+   one if they are compatible and two if they are nearly compatible\n+   (which causes a warning to be generated).  */\n+DEFHOOK\n+(comp_type_attributes,\n+ \"\",\n+ int, (const_tree type1, const_tree type2),\n+ hook_int_const_tree_const_tree_1)\n+\n+/* Assign default attributes to the newly defined TYPE.  */\n+DEFHOOK\n+(set_default_type_attributes,\n+ \"\",\n+ void, (tree type),\n+ hook_void_tree)\n+\n+/* Insert attributes on the newly created DECL.  */\n+DEFHOOK\n+(insert_attributes,\n+ \"\",\n+ void, (tree node, tree *attr_ptr),\n+ hook_void_tree_treeptr)\n+\n+/* Return true if FNDECL (which has at least one machine attribute)\n+   can be inlined despite its machine attributes, false otherwise.  */\n+DEFHOOK\n+(function_attribute_inlinable_p,\n+ \"\",\n+ bool, (const_tree fndecl),\n+ hook_bool_const_tree_false)\n+\n+/* Return true if bitfields in RECORD_TYPE should follow the\n+   Microsoft Visual C++ bitfield layout rules.  */\n+DEFHOOK\n+(ms_bitfield_layout_p,\n+ \"\",\n+ bool, (const_tree record_type),\n+ hook_bool_const_tree_false)\n+\n+/* True if the target supports decimal floating point.  */\n+DEFHOOK\n+(decimal_float_supported_p,\n+ \"\",\n+ bool, (void),\n+ default_decimal_float_supported_p)\n+\n+/* True if the target supports fixed-point.  */\n+DEFHOOK\n+(fixed_point_supported_p,\n+ \"\",\n+ bool, (void),\n+ default_fixed_point_supported_p)\n+\n+/* Return true if anonymous bitfields affect structure alignment.  */\n+DEFHOOK\n+(align_anon_bitfield,\n+ \"\",\n+ bool, (void),\n+ hook_bool_void_false)\n+\n+/* Return true if volatile bitfields should use the narrowest type possible.\n+   Return false if they should use the container type.  */\n+DEFHOOK\n+(narrow_volatile_bitfield,\n+ \"\",\n+ bool, (void),\n+ hook_bool_void_false)\n+\n+/* Set up target-specific built-in functions.  */\n+DEFHOOK\n+(init_builtins,\n+ \"\",\n+ void, (void),\n+ hook_void_void)\n+\n+/* Initialize (if INITIALIZE_P is true) and return the target-specific\n+   built-in function decl for CODE.\n+   Return NULL if that is not possible.  Return error_mark_node if CODE\n+   is outside of the range of valid target builtin function codes.  */\n+DEFHOOK\n+(builtin_decl,\n+ \"\",\n+ tree, (unsigned code, bool initialize_p), NULL)\n+\n+/* Expand a target-specific builtin.  */\n+DEFHOOK\n+(expand_builtin,\n+ \"\",\n+ rtx,\n+ (tree exp, rtx target, rtx subtarget, enum machine_mode mode, int ignore),\n+ default_expand_builtin)\n+\n+/* Select a replacement for a target-specific builtin.  This is done\n+   *before* regular type checking, and so allows the target to\n+   implement a crude form of function overloading.  The result is a\n+   complete expression that implements the operation.  PARAMS really\n+   has type VEC(tree,gc)*, but we don't want to include tree.h here.  */\n+ /* ??? params is called differently in the documentation, and we can't\n+    fix that because of GPL / GFDL incompatibility.  */\n+DEFHOOK_UNDOC\n+(resolve_overloaded_builtin,\n+ \"\",\n+ tree, (unsigned int /*location_t*/ loc, tree fndecl, void *params), NULL)\n+\n+/* Fold a target-specific builtin.  */\n+/* ??? The documentation uses a different name for nargs.  */\n+DEFHOOK_UNDOC\n+(fold_builtin,\n+ \"\",\n+ tree, (tree fndecl, int nargs, tree *argp, bool ignore),\n+ hook_tree_tree_int_treep_bool_null)\n+\n+/* Returns a code for a target-specific builtin that implements\n+   reciprocal of the function, or NULL_TREE if not available.  */\n+/* ??? The documentation uses a different name for tm_fn.  */\n+DEFHOOK_UNDOC\n+(builtin_reciprocal,\n+ \"\",\n+ tree, (unsigned fn, bool tm_fn, bool sqrt),\n+ default_builtin_reciprocal)\n+\n+/* For a vendor-specific TYPE, return a pointer to a statically-allocated\n+   string containing the C++ mangling for TYPE.  In all other cases, return\n+   NULL.  */\n+DEFHOOK\n+(mangle_type,\n+ \"\",\n+ const char *, (const_tree type),\n+ hook_constcharptr_const_tree_null)\n+\n+/* Make any adjustments to libfunc names needed for this target.  */\n+DEFHOOK\n+(init_libfuncs,\n+ \"\",\n+ void, (void),\n+ hook_void_void)\n+\n+/* Given a decl, a section name, and whether the decl initializer\n+   has relocs, choose attributes for the section.  */\n+/* ??? Should be merged with SELECT_SECTION and UNIQUE_SECTION.  */\n+DEFHOOK\n+(section_type_flags,\n+ \"\",\n+ unsigned int, (tree decl, const char *name, int reloc),\n+ default_section_type_flags)\n+\n+/* True if new jumps cannot be created, to replace existing ones or\n+   not, at the current point in the compilation.  */\n+DEFHOOK\n+(cannot_modify_jumps_p,\n+ \"\",\n+ bool, (void),\n+ hook_bool_void_false)\n+\n+/* Return a register class for which branch target register\n+   optimizations should be applied.  */\n+DEFHOOK\n+(branch_target_register_class,\n+ \"\",\n+ enum reg_class, (void),\n+ default_branch_target_register_class)\n+\n+/* Return true if branch target register optimizations should include\n+   callee-saved registers that are not already live during the current\n+   function.  AFTER_PE_GEN is true if prologues and epilogues have\n+   already been generated.  */\n+DEFHOOK\n+(branch_target_register_callee_saved,\n+ \"\",\n+ bool, (bool after_prologue_epilogue_gen),\n+ hook_bool_bool_false)\n+\n+/* Return true if the target supports conditional execution.  */\n+DEFHOOK\n+(have_conditional_execution,\n+ \"\",\n+ bool, (void),\n+ default_have_conditional_execution)\n+\n+/* Return a new value for loop unroll size.  */\n+DEFHOOK\n+(loop_unroll_adjust,\n+ \"\",\n+ unsigned, (unsigned nunroll, struct loop *loop),\n+ NULL)\n+\n+/* True if the constant X cannot be placed in the constant pool.  */\n+DEFHOOK\n+(cannot_force_const_mem,\n+ \"\",\n+ bool, (rtx x),\n+ hook_bool_rtx_false)\n+\n+DEFHOOK_UNDOC\n+(cannot_copy_insn_p,\n+ \"True if the insn @var{x} cannot be duplicated.\",\n+ bool, (rtx), NULL)\n+\n+/* True if X is considered to be commutative.  */\n+DEFHOOK\n+(commutative_p,\n+ \"\",\n+ bool, (const_rtx x, int outer_code),\n+ hook_bool_const_rtx_commutative_p)\n+\n+/* True if ADDR is an address-expression whose effect depends\n+   on the mode of the memory reference it is used in.  */\n+DEFHOOK\n+(mode_dependent_address_p,\n+ \"\",\n+ bool, (const_rtx addr),\n+ default_mode_dependent_address_p)\n+\n+/* Given an invalid address X for a given machine mode, try machine-specific\n+   ways to make it legitimate.  Return X or an invalid address on failure.  */\n+DEFHOOK\n+(legitimize_address,\n+ \"\",\n+ rtx, (rtx x, rtx oldx, enum machine_mode mode),\n+ default_legitimize_address)\n+\n+/* Given an address RTX, undo the effects of LEGITIMIZE_ADDRESS.  */\n+DEFHOOK\n+(delegitimize_address,\n+ \"\",\n+ rtx, (rtx x),\n+ delegitimize_mem_from_attrs)\n+\n+/* Given an address RTX, say whether it is valid.  */\n+DEFHOOK\n+(legitimate_address_p,\n+ \"\",\n+ bool, (enum machine_mode mode, rtx x, bool strict),\n+ default_legitimate_address_p)\n+\n+/* True if the given constant can be put into an object_block.  */\n+DEFHOOK\n+(use_blocks_for_constant_p,\n+ \"\",\n+ bool, (enum machine_mode mode, const_rtx x),\n+ hook_bool_mode_const_rtx_false)\n+\n+/* The minimum and maximum byte offsets for anchored addresses.  */\n+DEFHOOKPOD\n+(min_anchor_offset,\n+ \"\",\n+ HOST_WIDE_INT, 0)\n+\n+DEFHOOKPOD\n+(max_anchor_offset,\n+ \"\",\n+ HOST_WIDE_INT, 0)\n+\n+/* True if section anchors can be used to access the given symbol.  */\n+DEFHOOK\n+(use_anchors_for_symbol_p,\n+ \"\",\n+ bool, (const_rtx x),\n+ default_use_anchors_for_symbol_p)\n+\n+/* True if it is OK to do sibling call optimization for the specified\n+   call expression EXP.  DECL will be the called function, or NULL if\n+   this is an indirect call.  */\n+DEFHOOK\n+(function_ok_for_sibcall,\n+ \"\",\n+ bool, (tree decl, tree exp),\n+ hook_bool_tree_tree_false)\n+\n+/* Establish appropriate back-end context for processing the function\n+   FNDECL.  The argument might be NULL to indicate processing at top\n+   level, outside of any function scope.  */\n+DEFHOOK\n+(set_current_function,\n+ \"\",\n+ void, (tree decl), hook_void_tree)\n+\n+/* True if EXP should be placed in a \"small data\" section.  */\n+DEFHOOK\n+(in_small_data_p,\n+ \"\",\n+ bool, (const_tree exp),\n+ hook_bool_const_tree_false)\n+\n+/* True if EXP names an object for which name resolution must resolve\n+   to the current executable or shared library.  */\n+DEFHOOK\n+(binds_local_p,\n+ \"\",\n+ bool, (const_tree exp),\n+ default_binds_local_p)\n+\n+/* Modify and return the identifier of a DECL's external name,\n+   originally identified by ID, as required by the target,\n+   (eg, append @nn to windows32 stdcall function names).\n+   The default is to return ID without modification. */\n+DEFHOOK\n+(mangle_decl_assembler_name,\n+ \"\",\n+ tree, (tree decl, tree  id),\n+ default_mangle_decl_assembler_name)\n+\n+/* Do something target-specific to record properties of the DECL into\n+   the associated SYMBOL_REF.  */\n+DEFHOOK\n+(encode_section_info,\n+ \"\",\n+ void, (tree decl, rtx rtl, int new_decl_p),\n+ default_encode_section_info)\n+\n+/* Undo the effects of encode_section_info on the symbol string.  */\n+DEFHOOK\n+(strip_name_encoding,\n+ \"\",\n+ const char *, (const char *name),\n+ default_strip_name_encoding)\n+\n+/* If shift optabs for MODE are known to always truncate the shift count,\n+   return the mask that they apply.  Return 0 otherwise.  */\n+DEFHOOK\n+(shift_truncation_mask,\n+ \"\",\n+ unsigned HOST_WIDE_INT, (enum machine_mode mode),\n+ default_shift_truncation_mask)\n+\n+/* Return the number of divisions in the given MODE that should be present,\n+   so that it is profitable to turn the division into a multiplication by\n+   the reciprocal.  */\n+DEFHOOK\n+(min_divisions_for_recip_mul,\n+ \"\",\n+ unsigned int, (enum machine_mode mode),\n+ default_min_divisions_for_recip_mul)\n+\n+/* If the representation of integral MODE is such that values are\n+   always sign-extended to a wider mode MODE_REP then return\n+   SIGN_EXTEND.  Return UNKNOWN otherwise.  */\n+/* Note that the return type ought to be RTX_CODE, but that's not\n+   necessarily defined at this point.  */\n+DEFHOOK\n+(mode_rep_extended,\n+ \"\",\n+ int, (enum machine_mode mode, enum machine_mode rep_mode),\n+ default_mode_rep_extended)\n+\n+/* True if MODE is valid for a pointer in __attribute__((mode(\"MODE\"))).  */\n+DEFHOOK\n+(valid_pointer_mode,\n+ \"\",\n+ bool, (enum machine_mode mode),\n+ default_valid_pointer_mode)\n+\n+/* Support for named address spaces.  */\n+#undef HOOK_PREFIX\n+#define HOOK_PREFIX \"TARGET_ADDR_SPACE_\"\n+HOOK_VECTOR (TARGET_ADDR_SPACE_HOOKS, addr_space)\n+\n+/* MODE to use for a pointer into another address space.  */\n+DEFHOOK\n+(pointer_mode,\n+ \"\",\n+ enum machine_mode, (addr_space_t address_space),\n+ default_addr_space_pointer_mode)\n+\n+/* MODE to use for an address in another address space.  */\n+DEFHOOK\n+(address_mode,\n+ \"\",\n+ enum machine_mode, (addr_space_t address_space),\n+ default_addr_space_address_mode)\n+\n+/* True if MODE is valid for a pointer in __attribute__((mode(\"MODE\")))\n+   in another address space.  */\n+DEFHOOK\n+(valid_pointer_mode,\n+ \"\",\n+ bool, (enum machine_mode mode, addr_space_t as),\n+ default_addr_space_valid_pointer_mode)\n+\n+/* True if an address is a valid memory address to a given named address\n+   space for a given mode.  */\n+DEFHOOK\n+(legitimate_address_p,\n+ \"\",\n+ bool, (enum machine_mode mode, rtx exp, bool strict, addr_space_t as),\n+ default_addr_space_legitimate_address_p)\n+\n+/* Return an updated address to convert an invalid pointer to a named\n+   address space to a valid one.  If NULL_RTX is returned use machine\n+   independent methods to make the address valid.  */\n+DEFHOOK\n+(legitimize_address,\n+ \"\",\n+ rtx, (rtx x, rtx oldx, enum machine_mode mode, addr_space_t as),\n+ default_addr_space_legitimize_address)\n+\n+/* True if one named address space is a subset of another named address. */\n+DEFHOOK\n+(subset_p,\n+ \"\",\n+ bool, (addr_space_t superset, addr_space_t subset),\n+ default_addr_space_subset_p)\n+\n+/* Function to convert an rtl expression from one address space to another.  */\n+DEFHOOK\n+(convert,\n+ \"\",\n+ rtx, (rtx op, tree from_type, tree to_type),\n+ default_addr_space_convert)\n+\n+HOOK_VECTOR_END (addr_space)\n+\n+#undef HOOK_PREFIX\n+#define HOOK_PREFIX \"TARGET_\"\n+\n+/* True if MODE is valid for the target.  By \"valid\", we mean able to\n+   be manipulated in non-trivial ways.  In particular, this means all\n+   the arithmetic is supported.  */\n+DEFHOOK\n+(scalar_mode_supported_p,\n+ \"\",\n+ bool, (enum machine_mode mode),\n+ default_scalar_mode_supported_p)\n+\n+/* Similarly for vector modes.  \"Supported\" here is less strict.  At\n+   least some operations are supported; need to check optabs or builtins\n+   for further details.  */\n+DEFHOOK\n+(vector_mode_supported_p,\n+ \"\",\n+ bool, (enum machine_mode mode),\n+ hook_bool_mode_false)\n+\n+/* Compute cost of moving data from a register of class FROM to one of\n+   TO, using MODE.  */\n+DEFHOOK\n+(register_move_cost,\n+ \"\",\n+ int, (enum machine_mode mode, enum reg_class from, enum reg_class to),\n+ default_register_move_cost)\n+\n+/* Compute cost of moving registers to/from memory.  */\n+/* ??? Documenting the argument types for this hook requires a GFDL\n+   license grant.  Also, the documentation uses a different name for RCLASS.  */\n+DEFHOOK_UNDOC\n+(memory_move_cost,\n+ \"\",\n+ int, (enum machine_mode mode, enum reg_class rclass, bool in),\n+ default_memory_move_cost)\n+\n+/* True for MODE if the target expects that registers in this mode will\n+   be allocated to registers in a small register class.  The compiler is\n+   allowed to use registers explicitly used in the rtl as spill registers\n+   but it should prevent extending the lifetime of these registers.  */\n+DEFHOOK\n+(small_register_classes_for_mode_p,\n+ \"\",\n+ bool, (enum machine_mode mode),\n+ hook_bool_mode_false)\n+\n+/* Compute a (partial) cost for rtx X.  Return true if the complete\n+   cost has been computed, and false if subexpressions should be\n+   scanned.  In either case, *TOTAL contains the cost result.  */\n+/* Note that CODE and OUTER_CODE ought to be RTX_CODE, but that's\n+   not necessarily defined at this point.  */\n+DEFHOOK\n+(rtx_costs,\n+ \"\",\n+ bool, (rtx x, int code, int outer_code, int *total, bool speed),\n+ hook_bool_rtx_int_int_intp_bool_false)\n+\n+/* Compute the cost of X, used as an address.  Never called with\n+   invalid addresses.  */\n+DEFHOOK\n+(address_cost,\n+ \"\",\n+ int, (rtx address, bool speed),\n+ default_address_cost)\n+\n+/* Return where to allocate pseudo for a given hard register initial value.  */\n+DEFHOOK\n+(allocate_initial_value,\n+ \"\",\n+ rtx, (rtx hard_reg), NULL)\n+\n+/* Return nonzero if evaluating UNSPEC[_VOLATILE] X might cause a trap.\n+   FLAGS has the same meaning as in rtlanal.c: may_trap_p_1.  */\n+DEFHOOK\n+(unspec_may_trap_p,\n+ \"\",\n+ int, (const_rtx x, unsigned flags),\n+ default_unspec_may_trap_p)\n+\n+/* Given a register, this hook should return a parallel of registers\n+   to represent where to find the register pieces.  Define this hook\n+   if the register and its mode are represented in Dwarf in\n+   non-contiguous locations, or if the register should be\n+   represented in more than one register in Dwarf.  Otherwise, this\n+   hook should return NULL_RTX.  */\n+DEFHOOK\n+(dwarf_register_span,\n+ \"\",\n+ rtx, (rtx reg),\n+ hook_rtx_rtx_null)\n+\n+/* If expand_builtin_init_dwarf_reg_sizes needs to fill in table\n+   entries not corresponding directly to registers below\n+   FIRST_PSEUDO_REGISTER, this hook should generate the necessary\n+   code, given the address of the table.  */\n+DEFHOOK\n+(init_dwarf_reg_sizes_extra,\n+ \"\",\n+ void, (tree address),\n+ hook_void_tree)\n+\n+/* Fetch the fixed register(s) which hold condition codes, for\n+   targets where it makes sense to look for duplicate assignments to\n+   the condition codes.  This should return true if there is such a\n+   register, false otherwise.  The arguments should be set to the\n+   fixed register numbers.  Up to two condition code registers are\n+   supported.  If there is only one for this target, the int pointed\n+   at by the second argument should be set to -1.  */\n+DEFHOOK\n+(fixed_condition_code_regs,\n+ \"\",\n+ bool, (unsigned int *p1, unsigned int *p2),\n+ hook_bool_uintp_uintp_false)\n+\n+/* If two condition code modes are compatible, return a condition\n+     code mode which is compatible with both, such that a comparison\n+     done in the returned mode will work for both of the original\n+     modes.  If the condition code modes are not compatible, return\n+     VOIDmode.  */\n+DEFHOOK\n+(cc_modes_compatible,\n+ \"\",\n+ enum machine_mode, (enum machine_mode m1, enum machine_mode m2),\n+ default_cc_modes_compatible)\n+\n+/* Do machine-dependent code transformations.  Called just before\n+     delayed-branch scheduling.  */\n+DEFHOOK\n+(machine_dependent_reorg,\n+ \"\",\n+ void, (void), NULL)\n+\n+/* Create the __builtin_va_list type.  */\n+DEFHOOK\n+(build_builtin_va_list,\n+ \"\",\n+ tree, (void),\n+ std_build_builtin_va_list)\n+\n+/* Enumerate the va list variants.  */\n+/* ??? The documentation gets the type of ptree wrong.  */\n+DEFHOOK_UNDOC\n+(enum_va_list_p,\n+ \"\",\n+ int, (int idx, const char **pname, tree *ptree),\n+ NULL)\n+\n+/* Get the cfun/fndecl calling abi __builtin_va_list type.  */\n+DEFHOOK\n+(fn_abi_va_list,\n+ \"\",\n+ tree, (tree fndecl),\n+ std_fn_abi_va_list)\n+\n+/* Get the __builtin_va_list type dependent on input type.  */\n+DEFHOOK\n+(canonical_va_list_type,\n+ \"\",\n+ tree, (tree type),\n+ std_canonical_va_list_type)\n+\n+/* ??? Documenting this hook requires a GFDL license grant.  */\n+DEFHOOK_UNDOC\n+(expand_builtin_va_start,\n+\"Expand the @code{__builtin_va_start} builtin.\",\n+ void, (tree valist, rtx nextarg), NULL)\n+\n+/* Gimplifies a VA_ARG_EXPR.  */\n+DEFHOOK\n+(gimplify_va_arg_expr,\n+ \"\",\n+ tree, (tree valist, tree type, gimple_seq *pre_p, gimple_seq *post_p),\n+ std_gimplify_va_arg_expr)\n+\n+/* Validity-checking routines for PCH files, target-specific.\n+   get_pch_validity returns a pointer to the data to be stored,\n+   and stores the size in its argument.  pch_valid_p gets the same\n+   information back and returns NULL if the PCH is valid,\n+   or an error message if not.  */\n+DEFHOOK\n+(get_pch_validity,\n+ \"\",\n+ void *, (size_t *sz),\n+ default_get_pch_validity)\n+\n+DEFHOOK\n+(pch_valid_p,\n+ \"\",\n+ const char *, (const void *data, size_t sz),\n+ default_pch_valid_p)\n+\n+/* If nonnull, this function checks whether a PCH file with the\n+   given set of target flags can be used.  It returns NULL if so,\n+   otherwise it returns an error message.  */\n+DEFHOOK\n+(check_pch_target_flags,\n+ \"\",\n+ const char *, (int pch_flags), NULL)\n+\n+/* True if the compiler should give an enum type only as many\n+   bytes as it takes to represent the range of possible values of\n+   that type.  */\n+DEFHOOK\n+(default_short_enums,\n+ \"\",\n+ bool, (void),\n+ hook_bool_void_false)\n+\n+/* This target hook returns an rtx that is used to store the address\n+   of the current frame into the built-in setjmp buffer.  */\n+DEFHOOK\n+(builtin_setjmp_frame_value,\n+ \"\",\n+ rtx, (void),\n+ default_builtin_setjmp_frame_value)\n+\n+/* This target hook should add STRING_CST trees for any hard regs\n+   the port wishes to automatically clobber for an asm.  */\n+DEFHOOK\n+(md_asm_clobbers,\n+ \"\",\n+ tree, (tree outputs, tree inputs, tree clobbers),\n+ hook_tree_tree_tree_tree_3rd_identity)\n+\n+/* This target hook allows the backend to specify a calling convention\n+   in the debug information.  This function actually returns an\n+   enum dwarf_calling_convention, but because of forward declarations\n+   and not wanting to include dwarf2.h everywhere target.h is included\n+   the function is being declared as an int.  */\n+DEFHOOK\n+(dwarf_calling_convention,\n+ \"\",\n+ int, (const_tree function),\n+ hook_int_const_tree_0)\n+\n+/* This target hook allows the backend to emit frame-related insns that\n+   contain UNSPECs or UNSPEC_VOLATILEs.  The call frame debugging info\n+   engine will invoke it on insns of the form\n+     (set (reg) (unspec [...] UNSPEC_INDEX))\n+   and\n+     (set (reg) (unspec_volatile [...] UNSPECV_INDEX))\n+   to let the backend emit the call frame instructions.  */\n+DEFHOOK\n+(dwarf_handle_frame_unspec,\n+ \"\",\n+ void, (const char *label, rtx pattern, int index), NULL)\n+\n+/* ??? Documenting this hook requires a GFDL license grant.  */\n+DEFHOOK_UNDOC\n+(stdarg_optimize_hook,\n+\"Perform architecture specific checking of statements gimplified\\\n+ from @code{VA_ARG_EXPR}.  @var{stmt} is the statement.  Returns true if\\\n+ the statement doesn't need to be checked for @code{va_list} references.\",\n+ bool, (struct stdarg_info *ai, const_gimple stmt), NULL)\n+\n+/* This target hook allows the operating system to override the DECL\n+   that represents the external variable that contains the stack\n+   protection guard variable.  The type of this DECL is ptr_type_node.  */\n+DEFHOOK\n+(stack_protect_guard,\n+ \"\",\n+ tree, (void),\n+ default_stack_protect_guard)\n+\n+/* This target hook allows the operating system to override the CALL_EXPR\n+   that is invoked when a check vs the guard variable fails.  */\n+DEFHOOK\n+(stack_protect_fail,\n+ \"\",\n+ tree, (void),\n+ default_external_stack_protect_fail)\n+\n+/* Returns NULL if target supports the insn within a doloop block,\n+   otherwise it returns an error message.  */\n+DEFHOOK\n+(invalid_within_doloop,\n+ \"\",\n+ const char *, (const_rtx insn),\n+ default_invalid_within_doloop)\n+\n+DEFHOOK\n+(valid_dllimport_attribute_p,\n+\"@var{decl} is a variable or function with @code{__attribute__((dllimport))}\\\n+ specified.  Use this hook if the target needs to add extra validation\\\n+ checks to @code{handle_dll_attribute}.\",\n+ bool, (const_tree decl),\n+ hook_bool_const_tree_true)\n+\n+/* If non-zero, align constant anchors in CSE to a multiple of this\n+   value.  */\n+DEFHOOKPOD\n+(const_anchor,\n+ \"\",\n+ unsigned HOST_WIDE_INT, 0)\n+\n+/* Functions relating to calls - argument passing, returns, etc.  */\n+/* Members of struct call have no special macro prefix.  */\n+HOOK_VECTOR (TARGET_CALLS, calls)\n+\n+DEFHOOK\n+(promote_function_mode,\n+ \"\",\n+ enum machine_mode, (const_tree type, enum machine_mode mode, int *punsignedp,\n+\t\t     const_tree funtype, int for_return),\n+ default_promote_function_mode)\n+\n+DEFHOOK\n+(promote_prototypes,\n+ \"\",\n+ bool, (const_tree fntype),\n+ hook_bool_const_tree_false)\n+\n+DEFHOOK\n+(struct_value_rtx,\n+ \"\",\n+ rtx, (tree fndecl, int incoming),\n+ hook_rtx_tree_int_null)\n+DEFHOOK\n+(return_in_memory,\n+ \"\",\n+ bool, (const_tree type, const_tree fntype),\n+ default_return_in_memory)\n+\n+DEFHOOK\n+(return_in_msb,\n+ \"\",\n+ bool, (const_tree type),\n+ hook_bool_const_tree_false)\n+\n+/* Return true if a parameter must be passed by reference.  TYPE may\n+   be null if this is a libcall.  CA may be null if this query is\n+   from __builtin_va_arg.  */\n+/* ??? The documentation disagrees on the type of 'type'.  */\n+DEFHOOK_UNDOC\n+(pass_by_reference,\n+ \"\",\n+ bool,\n+ (CUMULATIVE_ARGS *cum, enum machine_mode mode, const_tree type, bool named),\n+ hook_bool_CUMULATIVE_ARGS_mode_tree_bool_false)\n+\n+DEFHOOK\n+(expand_builtin_saveregs,\n+ \"\",\n+ rtx, (void),\n+ default_expand_builtin_saveregs)\n+\n+/* Returns pretend_argument_size.  */\n+DEFHOOK\n+(setup_incoming_varargs,\n+ \"\",\n+ void, (CUMULATIVE_ARGS *args_so_far, enum machine_mode mode, tree type,\n+\tint *pretend_args_size, int second_time),\n+ default_setup_incoming_varargs)\n+\n+DEFHOOK\n+(strict_argument_naming,\n+ \"\",\n+ bool, (CUMULATIVE_ARGS *ca),\n+ hook_bool_CUMULATIVE_ARGS_false)\n+\n+/* Returns true if we should use\n+   targetm.calls.setup_incoming_varargs() and/or\n+   targetm.calls.strict_argument_naming().  */\n+DEFHOOK\n+(pretend_outgoing_varargs_named,\n+ \"\",\n+ bool, (CUMULATIVE_ARGS *ca),\n+ default_pretend_outgoing_varargs_named)\n+\n+/* Given a complex type T, return true if a parameter of type T\n+   should be passed as two scalars.  */\n+DEFHOOK\n+(split_complex_arg,\n+ \"\",\n+ bool, (const_tree type), NULL)\n+\n+/* Return true if type T, mode MODE, may not be passed in registers,\n+   but must be passed on the stack.  */\n+/* ??? This predicate should be applied strictly after pass-by-reference.\n+   Need audit to verify that this is the case.  */\n+DEFHOOK\n+(must_pass_in_stack,\n+ \"\",\n+ bool, (enum machine_mode mode, const_tree type),\n+ must_pass_in_stack_var_size_or_pad)\n+\n+/* Return true if type TYPE, mode MODE, which is passed by reference,\n+   should have the object copy generated by the callee rather than\n+   the caller.  It is never called for TYPE requiring constructors.  */\n+DEFHOOK\n+(callee_copies,\n+ \"\",\n+ bool,\n+ (CUMULATIVE_ARGS *cum, enum machine_mode mode, const_tree type, bool named),\n+ hook_bool_CUMULATIVE_ARGS_mode_tree_bool_false)\n+\n+/* Return zero for arguments passed entirely on the stack or entirely\n+   in registers.  If passed in both, return the number of bytes passed\n+   in registers; the balance is therefore passed on the stack.  */\n+DEFHOOK\n+(arg_partial_bytes,\n+ \"\",\n+ int, (CUMULATIVE_ARGS *cum, enum machine_mode mode, tree type, bool named),\n+ hook_int_CUMULATIVE_ARGS_mode_tree_bool_0)\n+\n+/* Update the state in CA to advance past an argument in the\n+   argument list.  The values MODE, TYPE, and NAMED describe that\n+   argument.  */\n+/* ??? tm.texi still only describes the old macro.  */\n+DEFHOOK_UNDOC\n+(function_arg_advance,\n+ \"\",\n+ void,\n+ (CUMULATIVE_ARGS *ca, enum machine_mode mode, const_tree type, bool named),\n+ default_function_arg_advance)\n+\n+/* Return zero if the argument described by the state of CA should\n+   be placed on a stack, or a hard register in which to store the\n+   argument.  The values MODE, TYPE, and NAMED describe that\n+   argument.  */\n+/* ??? tm.texi still only describes the old macro.  */\n+DEFHOOK_UNDOC\n+(function_arg,\n+ \"\",\n+ rtx, (const CUMULATIVE_ARGS *ca, enum machine_mode mode, const_tree type,\n+       bool named),\n+ default_function_arg)\n+\n+/* Likewise, but for machines with register windows.  Return the\n+   location where the argument will appear to the callee.  */\n+/* ??? tm.texi still only describes the old macro.  */\n+DEFHOOK_UNDOC\n+(function_incoming_arg,\n+ \"\",\n+ rtx, (const CUMULATIVE_ARGS *ca, enum machine_mode mode, const_tree type,\n+       bool named),\n+ default_function_incoming_arg)\n+\n+/* Return the diagnostic message string if function without a prototype\n+   is not allowed for this 'val' argument; NULL otherwise. */\n+DEFHOOK\n+(invalid_arg_for_unprototyped_fn,\n+ \"\",\n+ const char *, (const_tree typelist, const_tree funcdecl, const_tree val),\n+ hook_invalid_arg_for_unprototyped_fn)\n+\n+/* Return an rtx for the return value location of the function\n+   specified by FN_DECL_OR_TYPE with a return type of RET_TYPE.  */\n+DEFHOOK\n+(function_value,\n+ \"\",\n+ rtx, (const_tree ret_type, const_tree fn_decl_or_type, bool outgoing),\n+ default_function_value)\n+\n+/* Return the rtx for the result of a libcall of mode MODE,\n+   calling the function FN_NAME.  */\n+DEFHOOK\n+(libcall_value,\n+ \"\",\n+ rtx, (enum machine_mode mode, const_rtx fun),\n+ default_libcall_value)\n+\n+/* Return true if REGNO is a possible register number for\n+   a function value as seen by the caller.  */\n+DEFHOOK\n+(function_value_regno_p,\n+ \"\",\n+ bool, (const unsigned int regno),\n+ default_function_value_regno_p)\n+\n+/* ??? Documenting this hook requires a GFDL license grant.  */\n+DEFHOOK_UNDOC\n+(internal_arg_pointer,\n+\"Return an rtx for the argument pointer incoming to the\\\n+ current function.\",\n+ rtx, (void),\n+ default_internal_arg_pointer)\n+\n+/* Update the current function stack boundary if needed.  */\n+DEFHOOK\n+(update_stack_boundary,\n+ \"\",\n+ void, (void), NULL)\n+\n+/* Handle stack alignment and return an rtx for Dynamic Realign\n+   Argument Pointer if necessary.  */\n+DEFHOOK\n+(get_drap_rtx,\n+ \"\",\n+ rtx, (void), NULL)\n+\n+/* Return true if all function parameters should be spilled to the\n+   stack.  */\n+DEFHOOK\n+(allocate_stack_slots_for_args,\n+ \"\",\n+ bool, (void),\n+ hook_bool_void_true)\n+\n+/* Return an rtx for the static chain for FNDECL.  If INCOMING_P is true,\n+       then it should be for the callee; otherwise for the caller.  */\n+DEFHOOK\n+(static_chain,\n+ \"\",\n+ rtx, (const_tree fndecl, bool incoming_p),\n+ default_static_chain)\n+\n+/* Fill in the trampoline at MEM with a call to FNDECL and a\n+   static chain value of CHAIN.  */\n+DEFHOOK\n+(trampoline_init,\n+ \"\",\n+ void, (rtx m_tramp, tree fndecl, rtx static_chain),\n+ default_trampoline_init)\n+\n+/* Adjust the address of the trampoline in a target-specific way.  */\n+DEFHOOK\n+(trampoline_adjust_address,\n+ \"\",\n+ rtx, (rtx addr), NULL)\n+\n+/* Return the number of bytes of its own arguments that a function\n+   pops on returning, or 0 if the function pops no arguments and the\n+   caller must therefore pop them all after the function returns.  */\n+/* ??? tm.texi has no types for the parameters.  */\n+DEFHOOK_UNDOC\n+(return_pops_args,\n+ \"\",\n+ int, (tree fundecl, tree funtype, int size),\n+ default_return_pops_args)\n+\n+HOOK_VECTOR_END (calls)\n+\n+/* Return the diagnostic message string if conversion from FROMTYPE\n+   to TOTYPE is not allowed, NULL otherwise.  */\n+DEFHOOK\n+(invalid_conversion,\n+ \"\",\n+ const char *, (const_tree fromtype, const_tree totype),\n+ hook_constcharptr_const_tree_const_tree_null)\n+\n+/* Return the diagnostic message string if the unary operation OP is\n+   not permitted on TYPE, NULL otherwise.  */\n+DEFHOOK\n+(invalid_unary_op,\n+ \"\",\n+ const char *, (int op, const_tree type),\n+ hook_constcharptr_int_const_tree_null)\n+\n+/* Return the diagnostic message string if the binary operation OP\n+   is not permitted on TYPE1 and TYPE2, NULL otherwise.  */\n+DEFHOOK\n+(invalid_binary_op,\n+ \"\",\n+ const char *, (int op, const_tree type1, const_tree type2),\n+ hook_constcharptr_int_const_tree_const_tree_null)\n+\n+/* Return the diagnostic message string if TYPE is not valid as a\n+   function parameter type, NULL otherwise.  */\n+DEFHOOK\n+(invalid_parameter_type,\n+ \"\",\n+ const char *, (const_tree type),\n+ hook_constcharptr_const_tree_null)\n+\n+/* Return the diagnostic message string if TYPE is not valid as a\n+   function return type, NULL otherwise.  */\n+DEFHOOK\n+(invalid_return_type,\n+ \"\",\n+ const char *, (const_tree type),\n+ hook_constcharptr_const_tree_null)\n+\n+/* If values of TYPE are promoted to some other type when used in\n+   expressions (analogous to the integer promotions), return that type,\n+   or NULL_TREE otherwise.  */\n+DEFHOOK\n+(promoted_type,\n+ \"\",\n+ tree, (const_tree type),\n+ hook_tree_const_tree_null)\n+\n+/* Convert EXPR to TYPE, if target-specific types with special conversion\n+   rules are involved.  Return the converted expression, or NULL to apply\n+   the standard conversion rules.  */\n+DEFHOOK\n+(convert_to_type,\n+ \"\",\n+ tree, (tree type, tree expr),\n+ hook_tree_tree_tree_null)\n+\n+/* Return the array of IRA cover classes for the current target.  */\n+DEFHOOK\n+(ira_cover_classes,\n+ \"\",\n+ const enum reg_class *, (void),\n+ default_ira_cover_classes)\n+\n+/* Return the class for a secondary reload, and fill in extra information.  */\n+DEFHOOK\n+(secondary_reload,\n+ \"\",\n+ enum reg_class,\n+ (bool in_p, rtx x, enum reg_class reload_class, enum machine_mode reload_mode,\n+  secondary_reload_info *sri),\n+ default_secondary_reload)\n+\n+/* This target hook allows the backend to perform additional\n+   processing while initializing for variable expansion.  */\n+DEFHOOK\n+(expand_to_rtl_hook,\n+ \"\",\n+ void, (void),\n+ hook_void_void)\n+\n+/* This target hook allows the backend to perform additional\n+   instantiations on rtx that are not actually in insns yet,\n+   but will be later.  */\n+DEFHOOK\n+(instantiate_decls,\n+ \"\",\n+ void, (void),\n+ hook_void_void)\n+\n+/* Return true if is OK to use a hard register REGNO as scratch register\n+   in peephole2.  */\n+DEFHOOK\n+(hard_regno_scratch_ok,\n+ \"\",\n+ bool, (unsigned int regno),\n+ default_hard_regno_scratch_ok)\n+\n+/* Return the smallest number of different values for which it is best to\n+   use a jump-table instead of a tree of conditional branches.  */\n+DEFHOOK\n+(case_values_threshold,\n+ \"\",\n+ unsigned int, (void),\n+ default_case_values_threshold)\n+\n+/* Retutn true if a function must have and use a frame pointer.  */\n+DEFHOOK\n+(frame_pointer_required,\n+ \"\",\n+ bool, (void),\n+ hook_bool_void_false)\n+\n+/* Returns true if the compiler is allowed to try to replace register number\n+   from-reg with register number to-reg.  */\n+DEFHOOK\n+(can_eliminate,\n+ \"\",\n+ bool, (const int from_reg, const int to_reg),\n+ hook_bool_const_int_const_int_true)\n+\n+/* Functions specific to the C family of frontends.  */\n+#undef HOOK_PREFIX\n+#define HOOK_PREFIX \"TARGET_C_\"\n+HOOK_VECTOR (TARGET_C, c)\n+\n+/* ??? Documenting this hook requires a GFDL license grant.  */\n+DEFHOOK_UNDOC\n+(mode_for_suffix,\n+\"Return machine mode for non-standard constant literal suffix @var{c},\\\n+ or VOIDmode if non-standard suffixes are unsupported.\",\n+ enum machine_mode, (char c),\n+ default_mode_for_suffix)\n+\n+HOOK_VECTOR_END (c)\n+\n+/* Functions specific to the C++ frontend.  */\n+#undef HOOK_PREFIX\n+#define HOOK_PREFIX \"TARGET_CXX_\"\n+HOOK_VECTOR (TARGET_CXX, cxx)\n+\n+/* Return the integer type used for guard variables.  */\n+DEFHOOK\n+(guard_type,\n+ \"\",\n+ tree, (void),\n+ default_cxx_guard_type)\n+\n+/* Return true if only the low bit of the guard should be tested.  */\n+DEFHOOK\n+(guard_mask_bit,\n+ \"\",\n+ bool, (void),\n+ hook_bool_void_false)\n+\n+/* Returns the size of the array cookie for an array of type.  */\n+DEFHOOK\n+(get_cookie_size,\n+ \"\",\n+ tree, (tree type),\n+ default_cxx_get_cookie_size)\n+\n+/* Returns true if the element size should be stored in the array cookie.  */\n+DEFHOOK\n+(cookie_has_size,\n+ \"\",\n+ bool, (void),\n+ hook_bool_void_false)\n+\n+/* Allows backends to perform additional processing when\n+   deciding if a class should be exported or imported.  */\n+DEFHOOK\n+(import_export_class,\n+ \"\",\n+ int, (tree type, int import_export), NULL)\n+\n+/* Returns true if constructors and destructors return \"this\".  */\n+DEFHOOK\n+(cdtor_returns_this,\n+ \"\",\n+ bool, (void),\n+ hook_bool_void_false)\n+\n+/* Returns true if the key method for a class can be an inline\n+   function, so long as it is not declared inline in the class\n+   itself.  Returning true is the behavior required by the Itanium C++ ABI.  */\n+DEFHOOK\n+(key_method_may_be_inline,\n+ \"\",\n+ bool, (void),\n+ hook_bool_void_true)\n+\n+DEFHOOK\n+(determine_class_data_visibility,\n+\"@var{decl} is a virtual table, virtual table table, typeinfo object,\\\n+ or other similar implicit class data object that will be emitted with\\\n+ external linkage in this translation unit.  No ELF visibility has been\\\n+ explicitly specified.  If the target needs to specify a visibility\\\n+ other than that of the containing class, use this hook to set\\\n+ @code{DECL_VISIBILITY} and @code{DECL_VISIBILITY_SPECIFIED}.\",\n+ void, (tree decl),\n+ hook_void_tree)\n+\n+/* Returns true (the default) if virtual tables and other\n+   similar implicit class data objects are always COMDAT if they\n+   have external linkage.  If this hook returns false, then\n+   class data for classes whose virtual table will be emitted in\n+   only one translation unit will not be COMDAT.  */\n+DEFHOOK\n+(class_data_always_comdat,\n+ \"\",\n+ bool, (void),\n+ hook_bool_void_true)\n+\n+/* Returns true (the default) if the RTTI for the basic types,\n+   which is always defined in the C++ runtime, should be COMDAT;\n+   false if it should not be COMDAT.  */\n+DEFHOOK\n+(library_rtti_comdat,\n+ \"\",\n+ bool, (void),\n+ hook_bool_void_true)\n+\n+/* Returns true if __aeabi_atexit should be used to register static\n+   destructors.  */\n+DEFHOOK\n+(use_aeabi_atexit,\n+ \"\",\n+ bool, (void),\n+ hook_bool_void_false)\n+\n+/* Returns true if target may use atexit in the same manner as\n+   __cxa_atexit  to register static destructors.  */\n+DEFHOOK\n+(use_atexit_for_cxa_atexit,\n+ \"\",\n+ bool, (void),\n+ hook_bool_void_false)\n+\n+DEFHOOK\n+(adjust_class_at_definition,\n+\"@var{type} is a C++ class (i.e., RECORD_TYPE or UNION_TYPE) that has just\\\n+ been defined.  Use this hook to make adjustments to the class (eg, tweak\\\n+ visibility or perform any other required target modifications).\",\n+ void, (tree type),\n+ hook_void_tree)\n+\n+HOOK_VECTOR_END (cxx)\n+\n+/* Functions and data for emulated TLS support.  */\n+#undef HOOK_PREFIX\n+#define HOOK_PREFIX \"TARGET_EMUTLS_\"\n+HOOK_VECTOR (TARGET_EMUTLS, emutls)\n+\n+/* Name of the address and common functions.  */\n+DEFHOOKPOD\n+(get_address,\n+ \"\",\n+ const char *, \"__builtin___emutls_get_address\")\n+\n+DEFHOOKPOD\n+(register_common,\n+ \"\",\n+ const char *, \"__builtin___emutls_register_common\")\n+\n+/* Prefixes for proxy variable and template.  */\n+DEFHOOKPOD\n+(var_section,\n+ \"\",\n+ const char *, NULL)\n+\n+DEFHOOKPOD\n+(tmpl_section,\n+ \"\",\n+ const char *, NULL)\n+\n+/* Prefixes for proxy variable and template.  */\n+DEFHOOKPOD\n+(var_prefix,\n+ \"\",\n+ const char *, NULL)\n+\n+DEFHOOKPOD\n+(tmpl_prefix,\n+ \"\",\n+ const char *, NULL)\n+\n+/* Function to generate field definitions of the proxy variable.  */\n+DEFHOOK\n+(var_fields,\n+ \"\",\n+ tree, (tree type, tree *name),\n+ default_emutls_var_fields)\n+\n+/* Function to initialize a proxy variable.  */\n+DEFHOOK\n+(var_init,\n+ \"\",\n+ tree, (tree var, tree decl, tree tmpl_addr),\n+ default_emutls_var_init)\n+\n+/* Whether we are allowed to alter the usual alignment of the\n+   proxy variable.  */\n+DEFHOOKPOD\n+(var_align_fixed,\n+ \"\",\n+ bool, false)\n+\n+/* Whether we can emit debug information for TLS vars.  */\n+DEFHOOKPOD\n+(debug_form_tls_address,\n+ \"\",\n+ bool, false)\n+\n+HOOK_VECTOR_END (emutls)\n+\n+#undef HOOK_PREFIX\n+#define HOOK_PREFIX \"TARGET_OPTION_\"\n+HOOK_VECTOR (TARGET_OPTION_HOOKS, target_option_hooks)\n+\n+/* Function to validate the attribute((option(...))) strings or NULL.  If\n+   the option is validated, it is assumed that DECL_FUNCTION_SPECIFIC will\n+   be filled in in the function decl node.  */\n+DEFHOOK\n+(valid_attribute_p,\n+ \"\",\n+ bool, (tree fndecl, tree name, tree args, int flags),\n+ default_target_option_valid_attribute_p)\n+\n+/* Function to save any extra target state in the target options structure.  */\n+DEFHOOK\n+(save,\n+ \"\",\n+ void, (struct cl_target_option *ptr), NULL)\n+\n+/* Function to restore any extra target state from the target options\n+   structure.  */\n+DEFHOOK\n+(restore,\n+ \"\",\n+ void, (struct cl_target_option *ptr), NULL)\n+\n+/* Function to print any extra target state from the target options\n+   structure.  */\n+DEFHOOK\n+(print,\n+ \"\",\n+ void, (FILE *file, int indent, struct cl_target_option *ptr), NULL)\n+\n+/* Function to parse arguments to be validated for #pragma option, and to\n+   change the state if the options are valid.  If the first argument is\n+   NULL, the second argument specifies the default options to use.  Return\n+   true if the options are valid, and set the current state.  */\n+/* ??? The documentation disagrees on the signature of this hook.  */\n+DEFHOOK_UNDOC\n+(pragma_parse,\n+ \"\",\n+ bool, (tree args, tree pop_target),\n+ default_target_option_pragma_parse)\n+\n+/* Do option overrides for the target.  */\n+DEFHOOK\n+(override,\n+ \"\",\n+ void, (void),\n+ default_target_option_override)\n+\n+/* Function to determine if one function can inline another function.  */\n+#undef HOOK_PREFIX\n+#define HOOK_PREFIX \"TARGET_\"\n+DEFHOOK\n+(can_inline_p,\n+ \"\",\n+ bool, (tree caller, tree callee),\n+ default_target_can_inline_p)\n+\n+HOOK_VECTOR_END (target_option)\n+\n+/* For targets that need to mark extra registers as live on entry to\n+   the function, they should define this target hook and set their\n+   bits in the bitmap passed in. */\n+DEFHOOK\n+(extra_live_on_entry,\n+ \"\",\n+ void, (bitmap regs),\n+ hook_void_bitmap)\n+\n+/* Leave the boolean fields at the end.  */\n+\n+/* True if unwinding tables should be generated by default.  */\n+DEFHOOKPOD\n+(unwind_tables_default,\n+ \"\",\n+ bool, false)\n+\n+/* True if arbitrary sections are supported.  */\n+DEFHOOKPOD\n+(have_named_sections,\n+ \"\",\n+ bool, false)\n+\n+/* True if we can create zeroed data by switching to a BSS section\n+   and then using ASM_OUTPUT_SKIP to allocate the space.  */\n+DEFHOOKPOD\n+(have_switchable_bss_sections,\n+ \"\",\n+ bool, false)\n+\n+/* True if \"native\" constructors and destructors are supported,\n+   false if we're using collect2 for the job.  */\n+DEFHOOKPOD\n+(have_ctors_dtors,\n+ \"\",\n+ bool, false)\n+\n+/* True if thread-local storage is supported.  */\n+DEFHOOKPOD\n+(have_tls,\n+ \"\",\n+ bool, false)\n+\n+/* True if a small readonly data section is supported.  */\n+DEFHOOKPOD\n+(have_srodata_section,\n+ \"\",\n+ bool, false)\n+\n+/* True if EH frame info sections should be zero-terminated.  */\n+DEFHOOKPOD\n+(terminate_dw2_eh_frame_info,\n+ \"\",\n+ bool, true)\n+\n+/* True if #NO_APP should be emitted at the beginning of assembly output.  */\n+DEFHOOKPOD\n+(asm_file_start_app_off,\n+ \"\",\n+ bool, false)\n+\n+/* True if output_file_directive should be called for main_input_filename\n+   at the beginning of assembly output.  */\n+DEFHOOKPOD\n+(asm_file_start_file_directive,\n+ \"\",\n+ bool, false)\n+\n+DEFHOOKPOD\n+(handle_pragma_extern_prefix,\n+\"True if @code{#pragma extern_prefix} is to be supported.\",\n+ bool, 0)\n+\n+/* True if the target is allowed to reorder memory accesses unless\n+   synchronization is explicitly requested.  */\n+DEFHOOKPOD\n+(relaxed_ordering,\n+ \"\",\n+ bool, false)\n+\n+/* Returns true if we should generate exception tables for use with the\n+   ARM EABI.  The effects the encoding of function exception specifications.  */\n+DEFHOOKPOD\n+(arm_eabi_unwinder,\n+ \"\",\n+ bool, false)\n+\n+/* Leave the boolean fields at the end.  */\n+\n+/* Empty macro arguments are undefined in C90, so use an empty macro.  */\n+#define C90_EMPTY_HACK\n+/* Close the 'struct gcc_target' definition.  */\n+HOOK_VECTOR_END (C90_EMPTY_HACK)\n+\n+HOOK_VECTOR (TARGETCM_INITIALIZER, gcc_targetcm)\n+\n+/* Handle target switch CODE (an OPT_* value).  ARG is the argument\n+   passed to the switch; it is NULL if no argument was.  VALUE is the\n+   value of ARG if CODE specifies a UInteger option, otherwise it is\n+   1 if the positive form of the switch was used and 0 if the negative\n+   form was.  Return true if the switch was valid.  */\n+DEFHOOK\n+(handle_c_option,\n+ \"\",\n+ bool, (size_t code, const char *arg, int value),\n+ default_handle_c_option)\n+\n+HOOK_VECTOR_END (C90_EMPTY_HACK)"}, {"sha": "18d160dbeb23e6611d47a5fecd66b39257beb0d4", "filename": "gcc/target.h", "status": "modified", "additions": 5, "deletions": 1203, "changes": 1208, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38f8b050edd36ac977c564cab41cc1ce8e8a073e/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38f8b050edd36ac977c564cab41cc1ce8e8a073e/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=38f8b050edd36ac977c564cab41cc1ce8e8a073e", "patch": "@@ -128,1213 +128,15 @@ enum vect_cost_for_stmt\n };\n \n /* The target structure.  This holds all the backend hooks.  */\n+#define DEFHOOKPOD(NAME, DOC, TYPE, INIT) TYPE NAME;\n+#define DEFHOOK(NAME, DOC, TYPE, PARAMS, INIT) TYPE (* NAME) PARAMS;\n+#define DEFHOOK_UNDOC DEFHOOK\n+#define HOOKSTRUCT(FRAGMENT) FRAGMENT\n \n-struct gcc_target\n-{\n-  /* Functions that output assembler for the target.  */\n-  struct asm_out\n-  {\n-    /* Opening and closing parentheses for asm expression grouping.  */\n-    const char *open_paren, *close_paren;\n-\n-    /* Assembler instructions for creating various kinds of integer object.  */\n-    const char *byte_op;\n-    struct asm_int_op aligned_op, unaligned_op;\n-\n-    /* Try to output the assembler code for an integer object whose\n-       value is given by X.  SIZE is the size of the object in bytes and\n-       ALIGNED_P indicates whether it is aligned.  Return true if\n-       successful.  Only handles cases for which BYTE_OP, ALIGNED_OP\n-       and UNALIGNED_OP are NULL.  */\n-    bool (* integer) (rtx x, unsigned int size, int aligned_p);\n-\n-    /* Output code that will globalize a label.  */\n-    void (* globalize_label) (FILE *, const char *);\n-\n-    /* Output code that will globalize a declaration.  */\n-    void (* globalize_decl_name) (FILE *, tree);\n-\n-    /* Output code that will emit a label for unwind info, if this\n-       target requires such labels.  Second argument is the decl the\n-       unwind info is associated with, third is a boolean: true if\n-       this is for exception handling, fourth is a boolean: true if\n-       this is only a placeholder for an omitted FDE.  */\n-    void (* unwind_label) (FILE *, tree, int, int);\n-\n-    /* Output code that will emit a label to divide up the exception\n-       table.  */\n-    void (* except_table_label) (FILE *);\n-\n-    /* Emit any directives required to unwind this instruction.  */\n-    void (* unwind_emit) (FILE *, rtx);\n-\n-    /* Output an internal label.  */\n-    void (* internal_label) (FILE *, const char *, unsigned long);\n-\n-    /* Output label for the constant.  */\n-    void (* declare_constant_name) (FILE *, const char *, const_tree, \n-\t\t\t\t    HOST_WIDE_INT);\n-\n-    /* Emit a ttype table reference to a typeinfo object.  */\n-    bool (* ttype) (rtx);\n-\n-    /* Emit an assembler directive to set visibility for the symbol\n-       associated with the tree decl.  */\n-    void (* visibility) (tree, int);\n-\n-    /* Output the assembler code for entry to a function.  */\n-    void (* function_prologue) (FILE *, HOST_WIDE_INT);\n-\n-    /* Output the assembler code for end of prologue.  */\n-    void (* function_end_prologue) (FILE *);\n-\n-    /* Output the assembler code for start of epilogue.  */\n-    void (* function_begin_epilogue) (FILE *);\n-\n-    /* Output the assembler code for function exit.  */\n-    void (* function_epilogue) (FILE *, HOST_WIDE_INT);\n-\n-    /* Initialize target-specific sections.  */\n-    void (* init_sections) (void);\n-\n-    /* Tell assembler to change to section NAME with attributes FLAGS.\n-       If DECL is non-NULL, it is the VAR_DECL or FUNCTION_DECL with\n-       which this section is associated.  */\n-    void (* named_section) (const char *name, unsigned int flags, tree decl);\n-\n-    /* Return a mask describing how relocations should be treated when\n-       selecting sections.  Bit 1 should be set if global relocations\n-       should be placed in a read-write section; bit 0 should be set if\n-       local relocations should be placed in a read-write section.  */\n-    int (*reloc_rw_mask) (void);\n-\n-    /* Return a section for EXP.  It may be a DECL or a constant.  RELOC\n-       is nonzero if runtime relocations must be applied; bit 1 will be\n-       set if the runtime relocations require non-local name resolution.\n-       ALIGN is the required alignment of the data.  */\n-    section *(* select_section) (tree, int, unsigned HOST_WIDE_INT);\n-\n-    /* Return a section for X.  MODE is X's mode and ALIGN is its\n-       alignment in bits.  */\n-    section *(* select_rtx_section) (enum machine_mode, rtx,\n-\t\t\t\t     unsigned HOST_WIDE_INT);\n-\n-    /* Select a unique section name for DECL.  RELOC is the same as\n-       for SELECT_SECTION.  */\n-    void (* unique_section) (tree, int);\n-\n-    /* Return the readonly data section associated with function DECL.  */\n-    section *(* function_rodata_section) (tree);\n-\n-    /* Output a constructor for a symbol with a given priority.  */\n-    void (* constructor) (rtx, int);\n-\n-    /* Output a destructor for a symbol with a given priority.  */\n-    void (* destructor) (rtx, int);\n-\n-    /* Output the assembler code for a thunk function.  THUNK_DECL is the\n-       declaration for the thunk function itself, FUNCTION is the decl for\n-       the target function.  DELTA is an immediate constant offset to be\n-       added to THIS.  If VCALL_OFFSET is nonzero, the word at\n-       *(*this + vcall_offset) should be added to THIS.  */\n-    void (* output_mi_thunk) (FILE *file, tree thunk_decl,\n-\t\t\t      HOST_WIDE_INT delta, HOST_WIDE_INT vcall_offset,\n-\t\t\t      tree function_decl);\n-\n-    /* Determine whether output_mi_thunk would succeed.  */\n-    /* ??? Ideally, this hook would not exist, and success or failure\n-       would be returned from output_mi_thunk directly.  But there's\n-       too much undo-able setup involved in invoking output_mi_thunk.\n-       Could be fixed by making output_mi_thunk emit rtl instead of\n-       text to the output file.  */\n-    bool (* can_output_mi_thunk) (const_tree thunk_decl, HOST_WIDE_INT delta,\n-\t\t\t\t  HOST_WIDE_INT vcall_offset,\n-\t\t\t\t  const_tree function_decl);\n-\n-    /* Output any boilerplate text needed at the beginning of a\n-       translation unit.  */\n-    void (*file_start) (void);\n-\n-    /* Output any boilerplate text needed at the end of a\n-       translation unit.  */\n-    void (*file_end) (void);\n-\n-    /* Output any boilerplate text needed at the beginning of an\n-       LTO output stream.  */\n-    void (*lto_start) (void);\n-\n-    /* Output any boilerplate text needed at the end of an\n-       LTO output stream.  */\n-    void (*lto_end) (void);\n-\n-    /* Output any boilerplace text needed at the end of a\n-       translation unit before debug and unwind info is emitted.  */\n-    void (*code_end) (void);\n-\n-    /* Output an assembler pseudo-op to declare a library function name\n-       external.  */\n-    void (*external_libcall) (rtx);\n-\n-    /* Output an assembler directive to mark decl live. This instructs\n-\tlinker to not dead code strip this symbol.  */\n-    void (*mark_decl_preserved) (const char *);\n-\n-    /* Output a record of the command line switches that have been passed.  */\n-    print_switch_fn_type record_gcc_switches;\n-    /* The name of the section that the example ELF implementation of\n-       record_gcc_switches will use to store the information.  Target\n-       specific versions of record_gcc_switches may or may not use\n-       this information.  */\n-    const char * record_gcc_switches_section;\n-\n-    /* Output the definition of a section anchor.  */\n-    void (*output_anchor) (rtx);\n-\n-    /* Output a DTP-relative reference to a TLS symbol.  */\n-    void (*output_dwarf_dtprel) (FILE *file, int size, rtx x);\n-\n-    /* Some target machines need to postscan each insn after it is output.  */\n-    void (*final_postscan_insn) (FILE *, rtx, rtx *, int);\n-\n-    /* Emit the trampoline template.  This hook may be NULL.  */\n-    void (*trampoline_template) (FILE *);\n-\n-    /* Emit a machine-specific insn operand.  */\n-    void (*print_operand) (FILE *, rtx, int);\n-\n-    /* Emit a machine-specific memory address.  */\n-    void (*print_operand_address) (FILE *, rtx);\n-\n-    /* Determine whether CODE is a valid punctuation character for the\n-       `print_operand' hook.  */\n-    bool (*print_operand_punct_valid_p)(unsigned char code);\n-  } asm_out;\n-\n-  /* Functions relating to instruction scheduling.  */\n-  struct sched\n-  {\n-    /* Given the current cost, COST, of an insn, INSN, calculate and\n-       return a new cost based on its relationship to DEP_INSN through\n-       the dependence LINK.  The default is to make no adjustment.  */\n-    int (* adjust_cost) (rtx insn, rtx link, rtx dep_insn, int cost);\n-\n-    /* Adjust the priority of an insn as you see fit.  Returns the new\n-       priority.  */\n-    int (* adjust_priority) (rtx, int);\n-\n-    /* Function which returns the maximum number of insns that can be\n-       scheduled in the same machine cycle.  This must be constant\n-       over an entire compilation.  The default is 1.  */\n-    int (* issue_rate) (void);\n-\n-    /* Calculate how much this insn affects how many more insns we\n-       can emit this cycle.  Default is they all cost the same.  */\n-    int (* variable_issue) (FILE *, int, rtx, int);\n-\n-    /* Initialize machine-dependent scheduling code.  */\n-    void (* md_init) (FILE *, int, int);\n-\n-    /* Finalize machine-dependent scheduling code.  */\n-    void (* md_finish) (FILE *, int);\n-\n-    /* Initialize machine-dependent function wide scheduling code.  */\n-    void (* md_init_global) (FILE *, int, int);\n-\n-    /* Finalize machine-dependent function wide scheduling code.  */\n-    void (* md_finish_global) (FILE *, int);\n-\n-    /* Reorder insns in a machine-dependent fashion, in two different\n-       places.  Default does nothing.  */\n-    int (* reorder) (FILE *, int, rtx *, int *, int);\n-    int (* reorder2) (FILE *, int, rtx *, int *, int);\n-\n-    /* The following member value is a pointer to a function called\n-       after evaluation forward dependencies of insns in chain given\n-       by two parameter values (head and tail correspondingly).  */\n-    void (* dependencies_evaluation_hook) (rtx, rtx);\n-\n-    /* The values of the following four members are pointers to\n-       functions used to simplify the automaton descriptions.\n-       dfa_pre_cycle_insn and dfa_post_cycle_insn give functions\n-       returning insns which are used to change the pipeline hazard\n-       recognizer state when the new simulated processor cycle\n-       correspondingly starts and finishes.  The function defined by\n-       init_dfa_pre_cycle_insn and init_dfa_post_cycle_insn are used\n-       to initialize the corresponding insns.  The default values of\n-       the members result in not changing the automaton state when\n-       the new simulated processor cycle correspondingly starts and\n-       finishes.  */\n-    void (* init_dfa_pre_cycle_insn) (void);\n-    rtx (* dfa_pre_cycle_insn) (void);\n-    void (* init_dfa_post_cycle_insn) (void);\n-    rtx (* dfa_post_cycle_insn) (void);\n-\n-    /* The values of the following two members are pointers to\n-       functions used to simplify the automaton descriptions.\n-       dfa_pre_advance_cycle and dfa_post_advance_cycle are getting called\n-       immediately before and after cycle is advanced.  */\n-    void (* dfa_pre_advance_cycle) (void);\n-    void (* dfa_post_advance_cycle) (void);\n-\n-    /* The following member value is a pointer to a function returning value\n-       which defines how many insns in queue `ready' will we try for\n-       multi-pass scheduling.  If the member value is nonzero and the\n-       function returns positive value, the DFA based scheduler will make\n-       multi-pass scheduling for the first cycle.  In other words, we will\n-       try to choose ready insn which permits to start maximum number of\n-       insns on the same cycle.  */\n-    int (* first_cycle_multipass_dfa_lookahead) (void);\n-\n-    /* The following member value is pointer to a function controlling\n-       what insns from the ready insn queue will be considered for the\n-       multipass insn scheduling.  If the hook returns zero for insn\n-       passed as the parameter, the insn will be not chosen to be\n-       issued.  */\n-    int (* first_cycle_multipass_dfa_lookahead_guard) (rtx);\n-\n-    /* The following member value is pointer to a function called by\n-       the insn scheduler before issuing insn passed as the third\n-       parameter on given cycle.  If the hook returns nonzero, the\n-       insn is not issued on given processors cycle.  Instead of that,\n-       the processor cycle is advanced.  If the value passed through\n-       the last parameter is zero, the insn ready queue is not sorted\n-       on the new cycle start as usually.  The first parameter passes\n-       file for debugging output.  The second one passes the scheduler\n-       verbose level of the debugging output.  The forth and the fifth\n-       parameter values are correspondingly processor cycle on which\n-       the previous insn has been issued and the current processor\n-       cycle.  */\n-    int (* dfa_new_cycle) (FILE *, int, rtx, int, int, int *);\n-\n-    /* The following member value is a pointer to a function called by the\n-       insn scheduler.  It should return true if there exists a dependence\n-       which is considered costly by the target, between the insn\n-       DEP_PRO (&_DEP), and the insn DEP_CON (&_DEP).  The first parameter is\n-       the dep that represents the dependence between the two insns.  The\n-       second argument is the cost of the dependence as estimated by\n-       the scheduler.  The last argument is the distance in cycles\n-       between the already scheduled insn (first parameter) and the\n-       second insn (second parameter).  */\n-    bool (* is_costly_dependence) (struct _dep *_dep, int, int);\n-\n-    /* Given the current cost, COST, of an insn, INSN, calculate and\n-       return a new cost based on its relationship to DEP_INSN through the\n-       dependence of type DEP_TYPE.  The default is to make no adjustment.  */\n-    int (* adjust_cost_2) (rtx insn, int, rtx dep_insn, int cost, int dw);\n-\n-    /* The following member value is a pointer to a function called\n-       by the insn scheduler. This hook is called to notify the backend\n-       that new instructions were emitted.  */\n-    void (* h_i_d_extended) (void);\n-\n-    /* Next 5 functions are for multi-point scheduling.  */\n-\n-    /* Allocate memory for scheduler context.  */\n-    void *(* alloc_sched_context) (void);\n-\n-    /* Fills the context from the local machine scheduler context.  */\n-    void (* init_sched_context) (void *, bool);\n-\n-    /* Sets local machine scheduler context to a saved value.  */\n-    void (* set_sched_context) (void *);\n-\n-    /* Clears a scheduler context so it becomes like after init.  */\n-    void (* clear_sched_context) (void *);\n-\n-    /* Frees the scheduler context.  */\n-    void (* free_sched_context) (void *);\n-\n-    /* The following member value is a pointer to a function called\n-       by the insn scheduler.\n-       The first parameter is an instruction, the second parameter is the type\n-       of the requested speculation, and the third parameter is a pointer to the\n-       speculative pattern of the corresponding type (set if return value == 1).\n-       It should return\n-       -1, if there is no pattern, that will satisfy the requested speculation\n-       type,\n-       0, if current pattern satisfies the requested speculation type,\n-       1, if pattern of the instruction should be changed to the newly\n-       generated one.  */\n-    int (* speculate_insn) (rtx, int, rtx *);\n-\n-    /* The following member value is a pointer to a function called\n-       by the insn scheduler.  It should return true if the check instruction\n-       passed as the parameter needs a recovery block.  */\n-    bool (* needs_block_p) (int);\n-\n-    /* The following member value is a pointer to a function called\n-       by the insn scheduler.  It should return a pattern for the check\n-       instruction.\n-       The first parameter is a speculative instruction, the second parameter\n-       is the label of the corresponding recovery block (or null, if it is a\n-       simple check).  If the mutation of the check is requested (e.g. from\n-       ld.c to chk.a), the third parameter is true - in this case the first\n-       parameter is the previous check.  */\n-    rtx (* gen_spec_check) (rtx, rtx, int);\n-\n-    /* The following member value is a pointer to a function controlling\n-       what insns from the ready insn queue will be considered for the\n-       multipass insn scheduling.  If the hook returns zero for the insn\n-       passed as the parameter, the insn will not be chosen to be\n-       issued.  This hook is used to discard speculative instructions,\n-       that stand at the first position of the ready list.  */\n-    bool (* first_cycle_multipass_dfa_lookahead_guard_spec) (const_rtx);\n-\n-    /* The following member value is a pointer to a function that provides\n-       information about the speculation capabilities of the target.\n-       The parameter is a pointer to spec_info variable.  */\n-    void (* set_sched_flags) (struct spec_info_def *);\n-\n-    /* Return speculation types of the instruction passed as the parameter.  */\n-    int (* get_insn_spec_ds) (rtx);\n-\n-    /* Return speculation types that are checked for the instruction passed as\n-       the parameter.  */\n-    int (* get_insn_checked_ds) (rtx);\n-\n-    /* Return bool if rtx scanning should just skip current layer and\n-       advance to the inner rtxes.  */\n-    bool (* skip_rtx_p) (const_rtx);\n-\n-    /* The following member value is a pointer to a function that provides\n-       information about the target resource-based lower bound which is\n-       used by the swing modulo scheduler.  The parameter is a pointer\n-       to ddg variable.  */\n-    int (* sms_res_mii) (struct ddg *);\n-  } sched;\n-\n-  /* Functions relating to vectorization.  */\n-  struct vectorize\n-  {\n-    /* The following member value is a pointer to a function called\n-       by the vectorizer, and return the decl of the target builtin\n-       function.  */\n-    tree (* builtin_mask_for_load) (void);\n-\n-    /* Returns a code for builtin that realizes vectorized version of\n-       function, or NULL_TREE if not available.  */\n-    tree (* builtin_vectorized_function) (tree, tree, tree);\n-\n-    /* Returns a function declaration for a builtin that realizes the\n-       vector conversion, or NULL_TREE if not available.  */\n-    tree (* builtin_conversion) (unsigned, tree, tree);\n-\n-    /* Target builtin that implements vector widening multiplication.\n-       builtin_mul_widen_eve computes the element-by-element products\n-       for the even elements, and builtin_mul_widen_odd computes the\n-       element-by-element products for the odd elements.  */\n-    tree (* builtin_mul_widen_even) (tree);\n-    tree (* builtin_mul_widen_odd) (tree);\n-\n-    /* Cost of different vector/scalar statements in vectorization cost\n-       model.  */ \n-    int (* builtin_vectorization_cost) (enum vect_cost_for_stmt);\n-\n-    /* Return true if vector alignment is reachable (by peeling N\n-       iterations) for the given type.  */\n-    bool (* vector_alignment_reachable) (const_tree, bool);\n-\n-    /* Target builtin that implements vector permute.  */\n-    tree (* builtin_vec_perm) (tree, tree*);\n-\n-    /* Return true if a vector created for builtin_vec_perm is valid.  */\n-    bool (* builtin_vec_perm_ok) (tree, tree);\n-\n-    /* Return true if the target supports misaligned store/load of a\n-       specific factor denoted in the third parameter.  The last parameter\n-       is true if the access is defined in a packed struct.  */\n-    bool (* builtin_support_vector_misalignment) (enum machine_mode,\n-                                                  const_tree, int, bool);\n-  } vectorize;\n-\n-  /* The initial value of target_flags.  */\n-  int default_target_flags;\n-\n-  /* Allow target specific overriding of option settings after options have\n-     been changed by an attribute or pragma or when it is reset at the\n-     end of the code affected by an attribute or pragma.  */\n-  void (* override_options_after_change) (void);\n-\n-  /* Handle target switch CODE (an OPT_* value).  ARG is the argument\n-     passed to the switch; it is NULL if no argument was.  VALUE is the\n-     value of ARG if CODE specifies a UInteger option, otherwise it is\n-     1 if the positive form of the switch was used and 0 if the negative\n-     form was.  Return true if the switch was valid.  */\n-  bool (* handle_option) (size_t code, const char *arg, int value);\n-\n-  /* Handle target-specific parts of specifying -Ofast.  */\n-  void (* handle_ofast) (void);\n-\n-  /* Display extra, target specific information in response to a\n-     --target-help switch.  */\n-  void (* target_help) (void);\n-\n-  /* Return machine mode for filter value.  */\n-  enum machine_mode (* eh_return_filter_mode) (void);\n-\n-  /* Return machine mode for libgcc expanded cmp instructions.  */\n-  enum machine_mode (* libgcc_cmp_return_mode) (void);\n-\n-  /* Return machine mode for libgcc expanded shift instructions.  */\n-  enum machine_mode (* libgcc_shift_count_mode) (void);\n-\n-  /* Return machine mode to be used for _Unwind_Word type.  */\n-  enum machine_mode (* unwind_word_mode) (void);\n-\n-  /* Given two decls, merge their attributes and return the result.  */\n-  tree (* merge_decl_attributes) (tree, tree);\n-\n-  /* Given two types, merge their attributes and return the result.  */\n-  tree (* merge_type_attributes) (tree, tree);\n-\n-  /* Table of machine attributes and functions to handle them.\n-     Ignored if NULL.  */\n-  const struct attribute_spec *attribute_table;\n-\n-  /* Return true iff attribute NAME expects a plain identifier as its first\n-     argument.  */\n-  bool (*attribute_takes_identifier_p) (const_tree name);\n-\n-  /* Return zero if the attributes on TYPE1 and TYPE2 are incompatible,\n-     one if they are compatible and two if they are nearly compatible\n-     (which causes a warning to be generated).  */\n-  int (* comp_type_attributes) (const_tree type1, const_tree type2);\n-\n-  /* Assign default attributes to the newly defined TYPE.  */\n-  void (* set_default_type_attributes) (tree type);\n-\n-  /* Insert attributes on the newly created DECL.  */\n-  void (* insert_attributes) (tree decl, tree *attributes);\n-\n-  /* Return true if FNDECL (which has at least one machine attribute)\n-     can be inlined despite its machine attributes, false otherwise.  */\n-  bool (* function_attribute_inlinable_p) (const_tree fndecl);\n-\n-  /* Return true if bitfields in RECORD_TYPE should follow the\n-     Microsoft Visual C++ bitfield layout rules.  */\n-  bool (* ms_bitfield_layout_p) (const_tree record_type);\n-\n-  /* True if the target supports decimal floating point.  */\n-  bool (* decimal_float_supported_p) (void);\n-\n-  /* True if the target supports fixed-point.  */\n-  bool (* fixed_point_supported_p) (void);\n-\n-  /* Return true if anonymous bitfields affect structure alignment.  */\n-  bool (* align_anon_bitfield) (void);\n-\n-  /* Return true if volatile bitfields should use the narrowest type possible.\n-     Return false if they should use the container type.  */\n-  bool (* narrow_volatile_bitfield) (void);\n-\n-  /* Set up target-specific built-in functions.  */\n-  void (* init_builtins) (void);\n-\n-  /* Initialize (if INITIALIZE_P is true) and return the target-specific\n-     built-in function decl for CODE.\n-     Return NULL if that is not possible.  Return error_mark_node if CODE\n-     is outside of the range of valid target builtin function codes.  */\n-  tree (* builtin_decl) (unsigned code, bool initialize_p);\n-\n-  /* Expand a target-specific builtin.  */\n-  rtx (* expand_builtin) (tree exp, rtx target, rtx subtarget,\n-\t\t\t  enum machine_mode mode, int ignore);\n-\n-  /* Select a replacement for a target-specific builtin.  This is done\n-     *before* regular type checking, and so allows the target to\n-     implement a crude form of function overloading.  The result is a\n-     complete expression that implements the operation.  PARAMS really\n-     has type VEC(tree,gc)*, but we don't want to include tree.h\n-     here.  */\n-  tree (*resolve_overloaded_builtin) (unsigned int /*location_t*/,\n-      \t\t\t\t      tree decl, void *params);\n-\n-  /* Fold a target-specific builtin.  */\n-  tree (* fold_builtin) (tree fndecl, int nargs, tree *argp, bool ignore);\n-\n-  /* Returns a code for a target-specific builtin that implements\n-     reciprocal of the function, or NULL_TREE if not available.  */\n-  tree (* builtin_reciprocal) (unsigned, bool, bool);\n-\n-  /* For a vendor-specific TYPE, return a pointer to a statically-allocated\n-     string containing the C++ mangling for TYPE.  In all other cases, return\n-     NULL.  */\n-  const char * (* mangle_type) (const_tree type);\n-\n-  /* Make any adjustments to libfunc names needed for this target.  */\n-  void (* init_libfuncs) (void);\n-\n-  /* Given a decl, a section name, and whether the decl initializer\n-     has relocs, choose attributes for the section.  */\n-  /* ??? Should be merged with SELECT_SECTION and UNIQUE_SECTION.  */\n-  unsigned int (* section_type_flags) (tree, const char *, int);\n-\n-  /* True if new jumps cannot be created, to replace existing ones or\n-     not, at the current point in the compilation.  */\n-  bool (* cannot_modify_jumps_p) (void);\n-\n-  /* Return a register class for which branch target register\n-     optimizations should be applied.  */\n-  enum reg_class (* branch_target_register_class) (void);\n-\n-  /* Return true if branch target register optimizations should include\n-     callee-saved registers that are not already live during the current\n-     function.  AFTER_PE_GEN is true if prologues and epilogues have\n-     already been generated.  */\n-  bool (* branch_target_register_callee_saved) (bool after_pe_gen);\n-\n-  /* Return true if the target supports conditional execution.  */\n-  bool (* have_conditional_execution) (void);\n-\n-  /* Return a new value for loop unroll size.  */\n-  unsigned (* loop_unroll_adjust) (unsigned nunroll, struct loop *loop);\n-\n-  /* True if the constant X cannot be placed in the constant pool.  */\n-  bool (* cannot_force_const_mem) (rtx);\n-\n-  /* True if the insn X cannot be duplicated.  */\n-  bool (* cannot_copy_insn_p) (rtx);\n-\n-  /* True if X is considered to be commutative.  */\n-  bool (* commutative_p) (const_rtx, int);\n-  \n-  /* True if ADDR is an address-expression whose effect depends\n-     on the mode of the memory reference it is used in.  */\n-  bool (* mode_dependent_address_p) (const_rtx addr);\n-\n-  /* Given an invalid address X for a given machine mode, try machine-specific\n-     ways to make it legitimate.  Return X or an invalid address on failure.  */\n-  rtx (* legitimize_address) (rtx, rtx, enum machine_mode);\n-\n-  /* Given an address RTX, undo the effects of LEGITIMIZE_ADDRESS.  */\n-  rtx (* delegitimize_address) (rtx);\n-\n-  /* Given an address RTX, say whether it is valid.  */\n-  bool (* legitimate_address_p) (enum machine_mode, rtx, bool);\n-\n-  /* True if the given constant can be put into an object_block.  */\n-  bool (* use_blocks_for_constant_p) (enum machine_mode, const_rtx);\n-\n-  /* The minimum and maximum byte offsets for anchored addresses.  */\n-  HOST_WIDE_INT min_anchor_offset;\n-  HOST_WIDE_INT max_anchor_offset;\n-\n-  /* True if section anchors can be used to access the given symbol.  */\n-  bool (* use_anchors_for_symbol_p) (const_rtx);\n-\n-  /* True if it is OK to do sibling call optimization for the specified\n-     call expression EXP.  DECL will be the called function, or NULL if\n-     this is an indirect call.  */\n-  bool (*function_ok_for_sibcall) (tree decl, tree exp);\n-\n-  /* Establish appropriate back-end context for processing the function\n-     FNDECL.  The argument might be NULL to indicate processing at top\n-     level, outside of any function scope.  */\n-  void (*set_current_function) (tree fndecl);\n-\n-  /* True if EXP should be placed in a \"small data\" section.  */\n-  bool (* in_small_data_p) (const_tree);\n-\n-  /* True if EXP names an object for which name resolution must resolve\n-     to the current executable or shared library.  */\n-  bool (* binds_local_p) (const_tree);\n-\n-  /* Modify and return the identifier of a DECL's external name,\n-     originally identified by ID, as required by the target,\n-    (eg, append @nn to windows32 stdcall function names).\n-     The default is to return ID without modification. */\n-   tree (* mangle_decl_assembler_name) (tree decl, tree  id);\n-\n-  /* Do something target-specific to record properties of the DECL into\n-     the associated SYMBOL_REF.  */\n-  void (* encode_section_info) (tree, rtx, int);\n-\n-  /* Undo the effects of encode_section_info on the symbol string.  */\n-  const char * (* strip_name_encoding) (const char *);\n-\n-  /* If shift optabs for MODE are known to always truncate the shift count,\n-     return the mask that they apply.  Return 0 otherwise.  */\n-  unsigned HOST_WIDE_INT (* shift_truncation_mask) (enum machine_mode mode);\n-\n-  /* Return the number of divisions in the given MODE that should be present,\n-     so that it is profitable to turn the division into a multiplication by\n-     the reciprocal.  */\n-  unsigned int (* min_divisions_for_recip_mul) (enum machine_mode mode);\n-\n-  /* If the representation of integral MODE is such that values are\n-     always sign-extended to a wider mode MODE_REP then return\n-     SIGN_EXTEND.  Return UNKNOWN otherwise.  */\n-  /* Note that the return type ought to be RTX_CODE, but that's not\n-     necessarily defined at this point.  */\n-  int (* mode_rep_extended) (enum machine_mode mode,\n-\t\t\t     enum machine_mode mode_rep);\n-\n-  /* True if MODE is valid for a pointer in __attribute__((mode(\"MODE\"))).  */\n-  bool (* valid_pointer_mode) (enum machine_mode mode);\n-\n-  /* Support for named address spaces.  */\n-  struct addr_space {\n-    /* MODE to use for a pointer into another address space.  */\n-    enum machine_mode (* pointer_mode) (addr_space_t);\n-\n-    /* MODE to use for an address in another address space.  */\n-    enum machine_mode (* address_mode) (addr_space_t);\n-\n-    /* True if MODE is valid for a pointer in __attribute__((mode(\"MODE\")))\n-       in another address space.  */\n-    bool (* valid_pointer_mode) (enum machine_mode, addr_space_t);\n-\n-    /* True if an address is a valid memory address to a given named address\n-       space for a given mode.  */\n-    bool (* legitimate_address_p) (enum machine_mode, rtx, bool, addr_space_t);\n-\n-    /* Return an updated address to convert an invalid pointer to a named\n-       address space to a valid one.  If NULL_RTX is returned use machine\n-       independent methods to make the address valid.  */\n-    rtx (* legitimize_address) (rtx, rtx, enum machine_mode, addr_space_t);\n-\n-    /* True if one named address space is a subset of another named address. */\n-    bool (* subset_p) (addr_space_t, addr_space_t);\n-\n-    /* Function to convert an rtl expression from one address space to\n-       another.  */\n-    rtx (* convert) (rtx, tree, tree);\n-\n-  } addr_space;\n-\n-  /* True if MODE is valid for the target.  By \"valid\", we mean able to\n-     be manipulated in non-trivial ways.  In particular, this means all\n-     the arithmetic is supported.  */\n-  bool (* scalar_mode_supported_p) (enum machine_mode mode);\n-\n-  /* Similarly for vector modes.  \"Supported\" here is less strict.  At\n-     least some operations are supported; need to check optabs or builtins\n-     for further details.  */\n-  bool (* vector_mode_supported_p) (enum machine_mode mode);\n-\n-  /* Compute cost of moving data from a register of class FROM to one of\n-     TO, using MODE.  */\n-  int (* register_move_cost) (enum machine_mode, enum reg_class,\n-\t\t\t      enum reg_class);\n-\n-  /* Compute cost of moving registers to/from memory.  */\n-  int (* memory_move_cost) (enum machine_mode, enum reg_class, bool);\n-\n-  /* True for MODE if the target expects that registers in this mode will\n-     be allocated to registers in a small register class.  The compiler is\n-     allowed to use registers explicitly used in the rtl as spill registers\n-     but it should prevent extending the lifetime of these registers.  */\n-  bool (* small_register_classes_for_mode_p) (enum machine_mode mode);\n-\n-  /* Compute a (partial) cost for rtx X.  Return true if the complete\n-     cost has been computed, and false if subexpressions should be\n-     scanned.  In either case, *TOTAL contains the cost result.  */\n-  /* Note that CODE and OUTER_CODE ought to be RTX_CODE, but that's\n-     not necessarily defined at this point.  */\n-  bool (* rtx_costs) (rtx x, int code, int outer_code, int *total, bool speed);\n-\n-  /* Compute the cost of X, used as an address.  Never called with\n-     invalid addresses.  */\n-  int (* address_cost) (rtx x, bool speed);\n-\n-  /* Return where to allocate pseudo for a given hard register initial\n-     value.  */\n-  rtx (* allocate_initial_value) (rtx x);\n-\n-  /* Return nonzero if evaluating UNSPEC[_VOLATILE] X might cause a trap.\n-     FLAGS has the same meaning as in rtlanal.c: may_trap_p_1.  */\n-  int (* unspec_may_trap_p) (const_rtx x, unsigned flags);\n-\n-  /* Given a register, this hook should return a parallel of registers\n-     to represent where to find the register pieces.  Define this hook\n-     if the register and its mode are represented in Dwarf in\n-     non-contiguous locations, or if the register should be\n-     represented in more than one register in Dwarf.  Otherwise, this\n-     hook should return NULL_RTX.  */\n-  rtx (* dwarf_register_span) (rtx);\n-\n-  /* If expand_builtin_init_dwarf_reg_sizes needs to fill in table\n-     entries not corresponding directly to registers below\n-     FIRST_PSEUDO_REGISTER, this hook should generate the necessary\n-     code, given the address of the table.  */\n-  void (* init_dwarf_reg_sizes_extra) (tree);\n-\n-  /* Fetch the fixed register(s) which hold condition codes, for\n-     targets where it makes sense to look for duplicate assignments to\n-     the condition codes.  This should return true if there is such a\n-     register, false otherwise.  The arguments should be set to the\n-     fixed register numbers.  Up to two condition code registers are\n-     supported.  If there is only one for this target, the int pointed\n-     at by the second argument should be set to -1.  */\n-  bool (* fixed_condition_code_regs) (unsigned int *, unsigned int *);\n-\n-  /* If two condition code modes are compatible, return a condition\n-     code mode which is compatible with both, such that a comparison\n-     done in the returned mode will work for both of the original\n-     modes.  If the condition code modes are not compatible, return\n-     VOIDmode.  */\n-  enum machine_mode (* cc_modes_compatible) (enum machine_mode,\n-\t\t\t\t\t     enum machine_mode);\n-\n-  /* Do machine-dependent code transformations.  Called just before\n-     delayed-branch scheduling.  */\n-  void (* machine_dependent_reorg) (void);\n-\n-  /* Create the __builtin_va_list type.  */\n-  tree (* build_builtin_va_list) (void);\n-\n-  /* Enumerate the va list variants.  */\n-  int (* enum_va_list) (int, const char **, tree *);\n-\n-  /* Get the cfun/fndecl calling abi __builtin_va_list type.  */\n-  tree (* fn_abi_va_list) (tree);\n-\n-  /* Get the __builtin_va_list type dependent on input type.  */\n-  tree (* canonical_va_list_type) (tree);\n-\n-  /* Expand the __builtin_va_start builtin.  */\n-  void (* expand_builtin_va_start) (tree valist, rtx nextarg);\n-\n-  /* Gimplifies a VA_ARG_EXPR.  */\n-  tree (* gimplify_va_arg_expr) (tree valist, tree type, gimple_seq *pre_p,\n-\t\t\t\t gimple_seq *post_p);\n-\n-  /* Validity-checking routines for PCH files, target-specific.\n-     get_pch_validity returns a pointer to the data to be stored,\n-     and stores the size in its argument.  pch_valid_p gets the same\n-     information back and returns NULL if the PCH is valid,\n-     or an error message if not.\n-  */\n-  void * (* get_pch_validity) (size_t *);\n-  const char * (* pch_valid_p) (const void *, size_t);\n-\n-  /* If nonnull, this function checks whether a PCH file with the\n-     given set of target flags can be used.  It returns NULL if so,\n-     otherwise it returns an error message.  */\n-  const char *(*check_pch_target_flags) (int);\n-\n-  /* True if the compiler should give an enum type only as many\n-     bytes as it takes to represent the range of possible values of\n-     that type.  */\n-  bool (* default_short_enums) (void);\n-\n-  /* This target hook returns an rtx that is used to store the address\n-     of the current frame into the built-in setjmp buffer.  */\n-  rtx (* builtin_setjmp_frame_value) (void);\n-\n-  /* This target hook should add STRING_CST trees for any hard regs\n-     the port wishes to automatically clobber for an asm.  */\n-  tree (* md_asm_clobbers) (tree, tree, tree);\n-\n-  /* This target hook allows the backend to specify a calling convention\n-     in the debug information.  This function actually returns an\n-     enum dwarf_calling_convention, but because of forward declarations\n-     and not wanting to include dwarf2.h everywhere target.h is included\n-     the function is being declared as an int.  */\n-  int (* dwarf_calling_convention) (const_tree);\n-\n-  /* This target hook allows the backend to emit frame-related insns that\n-     contain UNSPECs or UNSPEC_VOLATILEs.  The call frame debugging info\n-     engine will invoke it on insns of the form\n-       (set (reg) (unspec [...] UNSPEC_INDEX))\n-     and\n-       (set (reg) (unspec_volatile [...] UNSPECV_INDEX))\n-     to let the backend emit the call frame instructions.  */\n-  void (* dwarf_handle_frame_unspec) (const char *, rtx, int);\n-\n-  /* Perform architecture specific checking of statements gimplified\n-     from VA_ARG_EXPR.  STMT is the statement.  Returns true if the statement\n-     doesn't need to be checked for va_list references.  */\n-  bool (* stdarg_optimize_hook) (struct stdarg_info *ai, const_gimple stmt);\n-\n-  /* This target hook allows the operating system to override the DECL\n-     that represents the external variable that contains the stack\n-     protection guard variable.  The type of this DECL is ptr_type_node.  */\n-  tree (* stack_protect_guard) (void);\n-\n-  /* This target hook allows the operating system to override the CALL_EXPR\n-     that is invoked when a check vs the guard variable fails.  */\n-  tree (* stack_protect_fail) (void);\n-\n-  /* Returns NULL if target supports the insn within a doloop block,\n-     otherwise it returns an error message.  */\n-  const char * (*invalid_within_doloop) (const_rtx);\n-\n-  /* DECL is a variable or function with __attribute__((dllimport))\n-     specified.  Use this hook if the target needs to add extra validation\n-     checks to  handle_dll_attribute ().  */\n-  bool (* valid_dllimport_attribute_p) (const_tree decl);\n-\n-  /* If non-zero, align constant anchors in CSE to a multiple of this\n-     value.  */\n-  unsigned HOST_WIDE_INT const_anchor;\n-\n-  /* Functions relating to calls - argument passing, returns, etc.  */\n-  struct calls {\n-    enum machine_mode (*promote_function_mode) (const_tree type,\n-\t\t\t\t\t\tenum machine_mode mode,\n-\t\t\t\t\t\tint *punsignedp,\n-\t\t\t\t\t\tconst_tree fntype,\n-\t\t\t\t\t\tint for_return);\n-    bool (*promote_prototypes) (const_tree fntype);\n-    rtx (*struct_value_rtx) (tree fndecl, int incoming);\n-    bool (*return_in_memory) (const_tree type, const_tree fndecl);\n-    bool (*return_in_msb) (const_tree type);\n-\n-    /* Return true if a parameter must be passed by reference.  TYPE may\n-       be null if this is a libcall.  CA may be null if this query is\n-       from __builtin_va_arg.  */\n-    bool (*pass_by_reference) (CUMULATIVE_ARGS *ca, enum machine_mode mode,\n-\t\t\t       const_tree type, bool named_arg);\n-\n-    rtx (*expand_builtin_saveregs) (void);\n-    /* Returns pretend_argument_size.  */\n-    void (*setup_incoming_varargs) (CUMULATIVE_ARGS *ca, enum machine_mode mode,\n-\t\t\t\t    tree type, int *pretend_arg_size,\n-\t\t\t\t    int second_time);\n-    bool (*strict_argument_naming) (CUMULATIVE_ARGS *ca);\n-    /* Returns true if we should use\n-       targetm.calls.setup_incoming_varargs() and/or\n-       targetm.calls.strict_argument_naming().  */\n-    bool (*pretend_outgoing_varargs_named) (CUMULATIVE_ARGS *ca);\n-\n-    /* Given a complex type T, return true if a parameter of type T\n-       should be passed as two scalars.  */\n-    bool (* split_complex_arg) (const_tree type);\n-\n-    /* Return true if type T, mode MODE, may not be passed in registers,\n-       but must be passed on the stack.  */\n-    /* ??? This predicate should be applied strictly after pass-by-reference.\n-       Need audit to verify that this is the case.  */\n-    bool (* must_pass_in_stack) (enum machine_mode mode, const_tree t);\n-\n-    /* Return true if type TYPE, mode MODE, which is passed by reference,\n-       should have the object copy generated by the callee rather than\n-       the caller.  It is never called for TYPE requiring constructors.  */\n-    bool (* callee_copies) (CUMULATIVE_ARGS *ca, enum machine_mode mode,\n-\t\t\t    const_tree type, bool named);\n-\n-    /* Return zero for arguments passed entirely on the stack or entirely\n-       in registers.  If passed in both, return the number of bytes passed\n-       in registers; the balance is therefore passed on the stack.  */\n-    int (* arg_partial_bytes) (CUMULATIVE_ARGS *ca, enum machine_mode mode,\n-\t\t\t       tree type, bool named);\n-\n-    /* Update the state in CA to advance past an argument in the\n-       argument list.  The values MODE, TYPE, and NAMED describe that\n-       argument.  */\n-    void (*function_arg_advance) (CUMULATIVE_ARGS *ca,\n-\t\t\t\t  enum machine_mode mode, const_tree type,\n-\t\t\t\t  bool named);\n-\n-    /* Return zero if the argument described by the state of CA should\n-       be placed on a stack, or a hard register in which to store the\n-       argument.  The values MODE, TYPE, and NAMED describe that\n-       argument.  */\n-    rtx (*function_arg) (const CUMULATIVE_ARGS *ca,\n-\t\t\t enum machine_mode mode, const_tree type, bool named);\n-\n-    /* Likewise, but for machines with register windows.  Return the\n-       location where the argument will appear to the callee.  */\n-    rtx (*function_incoming_arg) (const CUMULATIVE_ARGS *ca,\n-\t\t\t\t  enum machine_mode mode,\n-\t\t\t\t  const_tree type, bool named);\n-\n-    /* Return the diagnostic message string if function without a prototype\n-       is not allowed for this 'val' argument; NULL otherwise. */\n-    const char *(*invalid_arg_for_unprototyped_fn) (const_tree typelist,\n-\t\t\t\t\t     \t    const_tree funcdecl,\n-\t\t\t\t\t\t    const_tree val);\n-\n-    /* Return an rtx for the return value location of the function\n-       specified by FN_DECL_OR_TYPE with a return type of RET_TYPE.  */\n-    rtx (*function_value) (const_tree ret_type, const_tree fn_decl_or_type,\n-\t\t\t   bool outgoing);\n-\n-    /* Return the rtx for the result of a libcall of mode MODE,\n-       calling the function FN_NAME.  */\n-    rtx (*libcall_value) (enum machine_mode, const_rtx);\n-\n-    /* Return true if REGNO is a possible register number for\n-       a function value as seen by the caller.  */\n-    bool (*function_value_regno_p) (const unsigned int);\n-\n-    /* Return an rtx for the argument pointer incoming to the\n-       current function.  */\n-    rtx (*internal_arg_pointer) (void);\n-\n-    /* Update the current function stack boundary if needed.  */\n-    void (*update_stack_boundary) (void);\n-\n-    /* Handle stack alignment and return an rtx for Dynamic Realign\n-       Argument Pointer if necessary.  */\n-    rtx (*get_drap_rtx) (void);\n-\n-    /* Return true if all function parameters should be spilled to the\n-       stack.  */\n-    bool (*allocate_stack_slots_for_args) (void);\n-\n-    /* Return an rtx for the static chain for FNDECL.  If INCOMING_P is true,\n-       then it should be for the callee; otherwise for the caller.  */\n-    rtx (*static_chain) (const_tree fndecl, bool incoming_p);\n-\n-    /* Fill in the trampoline at MEM with a call to FNDECL and a\n-       static chain value of CHAIN.  */\n-    void (*trampoline_init) (rtx mem, tree fndecl, rtx chain);\n-\n-    /* Adjust the address of the trampoline in a target-specific way.  */\n-    rtx (*trampoline_adjust_address) (rtx addr);\n-\n-    /* Return the number of bytes of its own arguments that a function\n-       pops on returning, or 0 if the function pops no arguments and the\n-       caller must therefore pop them all after the function returns.  */\n-    int (*return_pops_args) (tree fundecl, tree funtype, int size);\n-  } calls;\n-\n-  /* Return the diagnostic message string if conversion from FROMTYPE\n-     to TOTYPE is not allowed, NULL otherwise.  */\n-  const char *(*invalid_conversion) (const_tree fromtype, const_tree totype);\n-\n-  /* Return the diagnostic message string if the unary operation OP is\n-     not permitted on TYPE, NULL otherwise.  */\n-  const char *(*invalid_unary_op) (int op, const_tree type);\n-\n-  /* Return the diagnostic message string if the binary operation OP\n-     is not permitted on TYPE1 and TYPE2, NULL otherwise.  */\n-  const char *(*invalid_binary_op) (int op, const_tree type1, const_tree type2);\n-\n-  /* Return the diagnostic message string if TYPE is not valid as a\n-     function parameter type, NULL otherwise.  */\n-  const char *(*invalid_parameter_type) (const_tree type);\n-\n-  /* Return the diagnostic message string if TYPE is not valid as a\n-     function return type, NULL otherwise.  */\n-  const char *(*invalid_return_type) (const_tree type);\n-\n-  /* If values of TYPE are promoted to some other type when used in\n-     expressions (analogous to the integer promotions), return that type,\n-     or NULL_TREE otherwise.  */\n-  tree (*promoted_type) (const_tree type);\n-\n-  /* Convert EXPR to TYPE, if target-specific types with special conversion\n-     rules are involved.  Return the converted expression, or NULL to apply\n-     the standard conversion rules.  */\n-  tree (*convert_to_type) (tree type, tree expr);\n-\n-  /* Return the array of IRA cover classes for the current target.  */\n-  const enum reg_class *(*ira_cover_classes) (void);\n-\n-  /* Return the class for a secondary reload, and fill in extra information.  */\n-  enum reg_class (*secondary_reload) (bool, rtx, enum reg_class,\n-\t\t\t\t      enum machine_mode,\n-\t\t\t\t      secondary_reload_info *);\n-\n-  /* This target hook allows the backend to perform additional\n-     processing while initializing for variable expansion.  */\n-  void (* expand_to_rtl_hook) (void);\n-\n-  /* This target hook allows the backend to perform additional\n-     instantiations on rtx that are not actually in insns yet,\n-     but will be later.  */\n-  void (* instantiate_decls) (void);\n-\n-  /* Return true if is OK to use a hard register REGNO as scratch register\n-     in peephole2.  */\n-  bool (* hard_regno_scratch_ok) (unsigned int regno);\n-\n-  /* Return the smallest number of different values for which it is best to\n-     use a jump-table instead of a tree of conditional branches.  */\n-  unsigned int (* case_values_threshold) (void);\n-\n-  /* Retutn true if a function must have and use a frame pointer.  */\n-  bool (* frame_pointer_required) (void);\n-\n-  /* Returns true if the compiler is allowed to try to replace register number\n-     from-reg with register number to-reg.  */\n-  bool (* can_eliminate) (const int, const int);\n-\n-  /* Functions specific to the C family of frontends.  */\n-  struct c {\n-    /* Return machine mode for non-standard suffix\n-       or VOIDmode if non-standard suffixes are unsupported.  */\n-    enum machine_mode (*mode_for_suffix) (char);\n-  } c;\n-\n-  /* Functions specific to the C++ frontend.  */\n-  struct cxx {\n-    /* Return the integer type used for guard variables.  */\n-    tree (*guard_type) (void);\n-    /* Return true if only the low bit of the guard should be tested.  */\n-    bool (*guard_mask_bit) (void);\n-    /* Returns the size of the array cookie for an array of type.  */\n-    tree (*get_cookie_size) (tree);\n-    /* Returns true if the element size should be stored in the\n-       array cookie.  */\n-    bool (*cookie_has_size) (void);\n-    /* Allows backends to perform additional processing when\n-       deciding if a class should be exported or imported.  */\n-    int (*import_export_class) (tree, int);\n-    /* Returns true if constructors and destructors return \"this\".  */\n-    bool (*cdtor_returns_this) (void);\n-    /* Returns true if the key method for a class can be an inline\n-       function, so long as it is not declared inline in the class\n-       itself.  Returning true is the behavior required by the Itanium\n-       C++ ABI.  */\n-    bool (*key_method_may_be_inline) (void);\n-    /* DECL is a virtual table, virtual table table, typeinfo object,\n-       or other similar implicit class data object that will be\n-       emitted with external linkage in this translation unit.  No ELF\n-       visibility has been explicitly specified.  If the target needs\n-       to specify a visibility other than that of the containing class,\n-       use this hook to set DECL_VISIBILITY and\n-       DECL_VISIBILITY_SPECIFIED.  */\n-    void (*determine_class_data_visibility) (tree decl);\n-    /* Returns true (the default) if virtual tables and other\n-       similar implicit class data objects are always COMDAT if they\n-       have external linkage.  If this hook returns false, then\n-       class data for classes whose virtual table will be emitted in\n-       only one translation unit will not be COMDAT.  */\n-    bool (*class_data_always_comdat) (void);\n-    /* Returns true (the default) if the RTTI for the basic types,\n-       which is always defined in the C++ runtime, should be COMDAT;\n-       false if it should not be COMDAT.  */\n-    bool (*library_rtti_comdat) (void);\n-    /* Returns true if __aeabi_atexit should be used to register static\n-       destructors.  */\n-    bool (*use_aeabi_atexit) (void);\n-    /* Returns true if target may use atexit in the same manner as\n-    __cxa_atexit  to register static destructors.  */\n-    bool (*use_atexit_for_cxa_atexit) (void);\n-    /* TYPE is a C++ class (i.e., RECORD_TYPE or UNION_TYPE) that\n-       has just been defined.  Use this hook to make adjustments to the\n-       class  (eg, tweak visibility or perform any other required\n-       target modifications).  */\n-    void (*adjust_class_at_definition) (tree type);\n-  } cxx;\n-\n-  /* Functions and data for emulated TLS support.  */\n-  struct emutls {\n-    /* Name of the address and common functions.  */\n-    const char *get_address;\n-    const char *register_common;\n-\n-    /* Prefixes for proxy variable and template.  */\n-    const char *var_section;\n-    const char *tmpl_section;\n-\n-    /* Prefixes for proxy variable and template.  */\n-    const char *var_prefix;\n-    const char *tmpl_prefix;\n-\n-    /* Function to generate field definitions of the proxy variable.  */\n-    tree (*var_fields) (tree, tree *);\n-\n-    /* Function to initialize a proxy variable.  */\n-    tree (*var_init) (tree, tree, tree);\n-\n-    /* Whether we are allowed to alter the usual alignment of the\n-       proxy variable.  */\n-    bool var_align_fixed;\n-\n-    /* Whether we can emit debug information for TLS vars.  */\n-    bool debug_form_tls_address;\n-  } emutls;\n-\n-  struct target_option_hooks {\n-    /* Function to validate the attribute((option(...))) strings or NULL.  If\n-       the option is validated, it is assumed that DECL_FUNCTION_SPECIFIC will\n-       be filled in in the function decl node.  */\n-    bool (*valid_attribute_p) (tree, tree, tree, int);\n-\n-    /* Function to save any extra target state in the target options\n-       structure.  */\n-    void (*save) (struct cl_target_option *);\n-\n-    /* Function to restore any extra target state from the target options\n-       structure.  */\n-    void (*restore) (struct cl_target_option *);\n-\n-    /* Function to print any extra target state from the target options\n-       structure.  */\n-    void (*print) (FILE *, int, struct cl_target_option *);\n-\n-    /* Function to parse arguments to be validated for #pragma option, and to\n-       change the state if the options are valid.  If the first argument is\n-       NULL, the second argument specifies the default options to use.  Return\n-       true if the options are valid, and set the current state.  */\n-    bool (*pragma_parse) (tree, tree);\n-\n-     /* Do option overrides for the target.  */\n-     void (*override) (void);\n-\n-    /* Function to determine if one function can inline another function.  */\n-    bool (*can_inline_p) (tree, tree);\n-  } target_option;\n-\n-  /* For targets that need to mark extra registers as live on entry to\n-     the function, they should define this target hook and set their\n-     bits in the bitmap passed in. */\n-  void (*live_on_entry) (bitmap);\n-\n-  /* True if unwinding tables should be generated by default.  */\n-  bool unwind_tables_default;\n-\n-  /* Leave the boolean fields at the end.  */\n-\n-  /* True if arbitrary sections are supported.  */\n-  bool have_named_sections;\n-\n-  /* True if we can create zeroed data by switching to a BSS section\n-     and then using ASM_OUTPUT_SKIP to allocate the space.  */\n-  bool have_switchable_bss_sections;\n-\n-  /* True if \"native\" constructors and destructors are supported,\n-     false if we're using collect2 for the job.  */\n-  bool have_ctors_dtors;\n-\n-  /* True if thread-local storage is supported.  */\n-  bool have_tls;\n-\n-  /* True if a small readonly data section is supported.  */\n-  bool have_srodata_section;\n-\n-  /* True if EH frame info sections should be zero-terminated.  */\n-  bool terminate_dw2_eh_frame_info;\n-\n-  /* True if #NO_APP should be emitted at the beginning of\n-     assembly output.  */\n-  bool file_start_app_off;\n-\n-  /* True if output_file_directive should be called for main_input_filename\n-     at the beginning of assembly output.  */\n-  bool file_start_file_directive;\n-\n-  /* True if #pragma extern_prefix is to be supported.  */\n-  bool handle_pragma_extern_prefix;\n-\n-  /* True if the target is allowed to reorder memory accesses unless\n-     synchronization is explicitly requested.  */\n-  bool relaxed_ordering;\n-\n-  /* Returns true if we should generate exception tables for use with the\n-     ARM EABI.  The effects the encoding of function exception specifications.\n-   */\n-  bool arm_eabi_unwinder;\n-\n-  /* Leave the boolean fields at the end.  */\n-};\n+#include \"target.def\"\n \n extern struct gcc_target targetm;\n \n-struct gcc_targetcm {\n-  /* Handle target switch CODE (an OPT_* value).  ARG is the argument\n-     passed to the switch; it is NULL if no argument was.  VALUE is the\n-     value of ARG if CODE specifies a UInteger option, otherwise it is\n-     1 if the positive form of the switch was used and 0 if the negative\n-     form was.  Return true if the switch was valid.  */\n-  bool (*handle_c_option) (size_t code, const char *arg, int value);\n-};\n-\n /* Each target can provide their own.  */\n extern struct gcc_targetcm targetcm;\n "}, {"sha": "6002b09046339f21ac3d39a21532dc03a0ae7b4f", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38f8b050edd36ac977c564cab41cc1ce8e8a073e/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38f8b050edd36ac977c564cab41cc1ce8e8a073e/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=38f8b050edd36ac977c564cab41cc1ce8e8a073e", "patch": "@@ -3677,8 +3677,8 @@ vect_supportable_dr_alignment (struct data_reference *dr)\n \t}\n \n       if (targetm.vectorize.\n-\t  builtin_support_vector_misalignment (mode, type,\n-\t\t\t\t\t       DR_MISALIGNMENT (dr), is_packed))\n+\t  support_vector_misalignment (mode, type,\n+\t\t\t\t       DR_MISALIGNMENT (dr), is_packed))\n \t/* Can't software pipeline the loads, but can at least do them.  */\n \treturn dr_unaligned_supported;\n     }\n@@ -3696,8 +3696,8 @@ vect_supportable_dr_alignment (struct data_reference *dr)\n \t}\n \n      if (targetm.vectorize.\n-         builtin_support_vector_misalignment (mode, type,\n-\t\t\t\t\t      DR_MISALIGNMENT (dr), is_packed))\n+         support_vector_misalignment (mode, type,\n+\t\t\t\t      DR_MISALIGNMENT (dr), is_packed))\n        return dr_unaligned_supported;\n     }\n "}, {"sha": "f9a9d976b547d23129a65e09abec98d11af8fa54", "filename": "gcc/varasm.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38f8b050edd36ac977c564cab41cc1ce8e8a073e/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38f8b050edd36ac977c564cab41cc1ce8e8a073e/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=38f8b050edd36ac977c564cab41cc1ce8e8a073e", "patch": "@@ -5979,7 +5979,7 @@ maybe_assemble_visibility (tree decl)\n \n   if (vis != VISIBILITY_DEFAULT)\n     {\n-      targetm.asm_out.visibility (decl, vis);\n+      targetm.asm_out.assemble_visibility (decl, vis);\n       return 1;\n     }\n   else\n@@ -6905,11 +6905,11 @@ default_asm_declare_constant_name (FILE *file, const char *name,\n void\n default_file_start (void)\n {\n-  if (targetm.file_start_app_off\n+  if (targetm.asm_file_start_app_off\n       && !(flag_verbose_asm || flag_debug_asm || flag_dump_rtl_in_asm))\n     fputs (ASM_APP_OFF, asm_out_file);\n \n-  if (targetm.file_start_file_directive)\n+  if (targetm.asm_file_start_file_directive)\n     output_file_directive (asm_out_file, main_input_filename);\n }\n "}]}