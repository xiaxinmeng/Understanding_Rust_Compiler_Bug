{"sha": "7debf73d34ceba203a85b5ad381a5dd799cdc788", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2RlYmY3M2QzNGNlYmEyMDNhODViNWFkMzgxYTVkZDc5OWNkYzc4OA==", "commit": {"author": {"name": "Janne Blomqvist", "email": "jb@gcc.gnu.org", "date": "2010-11-09T18:17:35Z"}, "committer": {"name": "Janne Blomqvist", "email": "jb@gcc.gnu.org", "date": "2010-11-09T18:17:35Z"}, "message": "Cache stat values, reduce syscalls\n\nFrom-SVN: r166502", "tree": {"sha": "5f46270611def44ed1e538e6693b2f0521a0d22a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5f46270611def44ed1e538e6693b2f0521a0d22a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7debf73d34ceba203a85b5ad381a5dd799cdc788", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7debf73d34ceba203a85b5ad381a5dd799cdc788", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7debf73d34ceba203a85b5ad381a5dd799cdc788", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7debf73d34ceba203a85b5ad381a5dd799cdc788/comments", "author": null, "committer": null, "parents": [{"sha": "f4a88680ab308f951699bdfb7b181013d434d151", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4a88680ab308f951699bdfb7b181013d434d151", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f4a88680ab308f951699bdfb7b181013d434d151"}], "stats": {"total": 62, "additions": 44, "deletions": 18}, "files": [{"sha": "bfbf01583e02ecb102551cc2a40f231d1053cf17", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7debf73d34ceba203a85b5ad381a5dd799cdc788/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7debf73d34ceba203a85b5ad381a5dd799cdc788/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=7debf73d34ceba203a85b5ad381a5dd799cdc788", "patch": "@@ -1,3 +1,12 @@\n+2010-11-09  Janne Blomqvist  <jb@gcc.gnu.org>\n+\n+\t* io/unix.c (struct unix_stream): Add st_dev and st_ino members.\n+\t(fd_to_stream): Avoid unnecessary lseek() call, test isatty()\n+\tlast. Make a token effort to support block devices.\n+\t(compare_file_filename): Use cached stat values.\n+\t(find_file0): Likewise.\n+\t(find_file): Likewise.\n+\n 2010-11-09  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR libgfortran/46373"}, {"sha": "a384f7bcc37d89e46c7553b6902fbb54112da1a0", "filename": "libgfortran/io/unix.c", "status": "modified", "additions": 35, "deletions": 18, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7debf73d34ceba203a85b5ad381a5dd799cdc788/libgfortran%2Fio%2Funix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7debf73d34ceba203a85b5ad381a5dd799cdc788/libgfortran%2Fio%2Funix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Funix.c?ref=7debf73d34ceba203a85b5ad381a5dd799cdc788", "patch": "@@ -183,7 +183,11 @@ typedef struct\n \n   int ndirty;\t\t\t/* Dirty bytes starting at buffer_offset */\n \n-  int special_file;\t\t/* =1 if the fd refers to a special file */\n+  int special_file;             /* =1 if the fd refers to a special file */\n+\n+  /* Cached stat(2) values.  */\n+  dev_t st_dev;\n+  ino_t st_ino;\n }\n unix_stream;\n \n@@ -940,18 +944,29 @@ fd_to_stream (int fd)\n \n   fstat (fd, &statbuf);\n \n-  if (lseek (fd, 0, SEEK_CUR) == (gfc_offset) -1)\n-    s->file_length = -1;\n-  else\n-    s->file_length = S_ISREG (statbuf.st_mode) ? statbuf.st_size : -1;\n-\n+  s->st_dev = statbuf.st_dev;\n+  s->st_ino = statbuf.st_ino;\n   s->special_file = !S_ISREG (statbuf.st_mode);\n \n-  if (isatty (s->fd) || options.all_unbuffered\n+  if (S_ISREG (statbuf.st_mode))\n+    s->file_length = statbuf.st_size;\n+  else if (S_ISBLK (statbuf.st_mode))\n+    {\n+      /* Hopefully more portable than ioctl(fd, BLKGETSIZE64, &size)?  */\n+      gfc_offset cur = lseek (fd, 0, SEEK_CUR);\n+      s->file_length = lseek (fd, 0, SEEK_END);\n+      lseek (fd, cur, SEEK_SET);\n+    }\n+  else\n+    s->file_length = -1;\n+\n+  if (!(S_ISREG (statbuf.st_mode) || S_ISBLK (statbuf.st_mode))\n+      || options.all_unbuffered\n       ||(options.unbuffered_preconnected && \n          (s->fd == STDIN_FILENO \n           || s->fd == STDOUT_FILENO \n-          || s->fd == STDERR_FILENO)))\n+          || s->fd == STDERR_FILENO))\n+      || isatty (s->fd))\n     raw_init (s);\n   else\n     buf_init (s);\n@@ -1370,9 +1385,9 @@ int\n compare_file_filename (gfc_unit *u, const char *name, int len)\n {\n   char path[PATH_MAX + 1];\n-  gfstat_t st1;\n+  gfstat_t st;\n #ifdef HAVE_WORKING_STAT\n-  gfstat_t st2;\n+  unix_stream *s;\n #else\n # ifdef __MINGW32__\n   uint64_t id1, id2;\n@@ -1385,12 +1400,12 @@ compare_file_filename (gfc_unit *u, const char *name, int len)\n   /* If the filename doesn't exist, then there is no match with the\n    * existing file. */\n \n-  if (stat (path, &st1) < 0)\n+  if (stat (path, &st) < 0)\n     return 0;\n \n #ifdef HAVE_WORKING_STAT\n-  fstat (((unix_stream *) (u->s))->fd, &st2);\n-  return (st1.st_dev == st2.st_dev) && (st1.st_ino == st2.st_ino);\n+  s = (unix_stream *) (u->s);\n+  return (st.st_dev == s->st_dev) && (st.st_ino == s->st_ino);\n #else\n \n # ifdef __MINGW32__\n@@ -1432,10 +1447,12 @@ find_file0 (gfc_unit *u, FIND_FILE0_DECL)\n     return NULL;\n \n #ifdef HAVE_WORKING_STAT\n-  if (u->s != NULL\n-      && fstat (((unix_stream *) u->s)->fd, &st[1]) >= 0 &&\n-      st[0].st_dev == st[1].st_dev && st[0].st_ino == st[1].st_ino)\n-    return u;\n+  if (u->s != NULL)\n+    {\n+      unix_stream *s = (unix_stream *) (u->s);\n+      if (st[0].st_dev == s->st_dev && st[0].st_ino == s->st_ino)\n+\treturn u;\n+    }\n #else\n # ifdef __MINGW32__ \n   if (u->s && ((id1 = id_from_fd (((unix_stream *) u->s)->fd)) || id1))\n@@ -1468,7 +1485,7 @@ gfc_unit *\n find_file (const char *file, gfc_charlen_type file_len)\n {\n   char path[PATH_MAX + 1];\n-  gfstat_t st[2];\n+  gfstat_t st[1];\n   gfc_unit *u;\n #if defined(__MINGW32__) && !HAVE_WORKING_STAT\n   uint64_t id = 0ULL;"}]}