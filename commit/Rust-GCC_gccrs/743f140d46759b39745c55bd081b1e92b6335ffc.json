{"sha": "743f140d46759b39745c55bd081b1e92b6335ffc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzQzZjE0MGQ0Njc1OWIzOTc0NWM1NWJkMDgxYjFlOTJiNjMzNWZmYw==", "commit": {"author": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1998-08-20T16:43:58Z"}, "committer": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1998-08-20T16:43:58Z"}, "message": "Handle new'ing of Java classes.\n\nd\n\tHandle new'ing of Java classes.\n\t* init.c (build_class_classref):  New function.\n\t(build_new_1):  If type is TYPE_FOR_JAVA:  Call _Jv_AllocObject;\n\tconstructor does not return this;  don't need to exception-protect.\n\t* pt.c (lookup_template_class):  Copy TYPE_FOR_JAVA flag.\n\t* decl2.c (acceptable_java_type):  Handle template-derived types.\n\nFrom-SVN: r21879", "tree": {"sha": "3e43247679622880e247c3fa4cc949fd1bc5729e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3e43247679622880e247c3fa4cc949fd1bc5729e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/743f140d46759b39745c55bd081b1e92b6335ffc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/743f140d46759b39745c55bd081b1e92b6335ffc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/743f140d46759b39745c55bd081b1e92b6335ffc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/743f140d46759b39745c55bd081b1e92b6335ffc/comments", "author": null, "committer": null, "parents": [{"sha": "d35897f502c40ab304aca5159831bd9db62e0cff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d35897f502c40ab304aca5159831bd9db62e0cff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d35897f502c40ab304aca5159831bd9db62e0cff"}], "stats": {"total": 69, "additions": 67, "deletions": 2}, "files": [{"sha": "ce61077149366ce83747eeb673600c07714f38bb", "filename": "gcc/cp/init.c", "status": "modified", "additions": 67, "deletions": 2, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/743f140d46759b39745c55bd081b1e92b6335ffc/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/743f140d46759b39745c55bd081b1e92b6335ffc/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=743f140d46759b39745c55bd081b1e92b6335ffc", "patch": "@@ -2145,6 +2145,47 @@ build_new (placement, decl, init, use_global_new)\n   return rval;\n }\n \n+/* If non-NULL, a POINTER_TYPE equivalent to (java::lang::Class*). */\n+\n+static tree jclass_node = NULL_TREE;\n+\n+/* Given a Java class, return a decl for the corresponding java.lang.Class. */\n+\n+tree\n+build_java_class_ref (type)\n+     tree type;\n+{\n+  tree name, class_decl;\n+  static tree CL_prefix = NULL_TREE;\n+  static tree alloc_decl = NULL_TREE;\n+  if (CL_prefix == NULL_TREE)\n+    CL_prefix = get_identifier(\"_CL_\");\n+  if (jclass_node == NULL_TREE)\n+    {\n+      jclass_node = IDENTIFIER_GLOBAL_VALUE (get_identifier(\"jclass\"));\n+      if (jclass_node == NULL_TREE)\n+\tfatal(\"call to Java constructor, while `jclass' undefined\");\n+      jclass_node = TREE_TYPE (jclass_node);\n+    }\n+  name = build_overload_with_type (CL_prefix, type);\n+  class_decl = IDENTIFIER_GLOBAL_VALUE (name);\n+  if (class_decl == NULL_TREE)\n+    {\n+      push_obstacks_nochange ();\n+      end_temporary_allocation ();\n+      class_decl = build_decl (VAR_DECL, name, TREE_TYPE (jclass_node));\n+      TREE_STATIC (class_decl) = 1;\n+      DECL_EXTERNAL (class_decl) = 1;\n+      TREE_PUBLIC (class_decl) = 1;\n+      DECL_ARTIFICIAL (class_decl) = 1;\n+      DECL_IGNORED_P (class_decl) = 1;\n+      pushdecl_top_level (class_decl);\n+      make_decl_rtl (class_decl, NULL_PTR, 1);\n+      pop_obstacks ();\n+    }\n+  return class_decl;\n+}\n+\n /* Called from cplus_expand_expr when expanding a NEW_EXPR.  The return\n    value is immediately handed to expand_expr.  */\n \n@@ -2160,6 +2201,7 @@ build_new_1 (exp)\n   enum tree_code code = NEW_EXPR;\n   int use_cookie, nothrow, check_new;\n   int use_global_new;\n+  int use_java_new = 0;\n \n   placement = TREE_OPERAND (exp, 0);\n   type = TREE_OPERAND (exp, 1);\n@@ -2257,6 +2299,23 @@ build_new_1 (exp)\n \t  return error_mark_node;\n \t}\n     }\n+  else if (! placement && TYPE_FOR_JAVA (true_type))\n+    {\n+      tree name, class_addr, alloc_decl;\n+      tree class_decl = build_java_class_ref (true_type);\n+      tree class_size = size_in_bytes (true_type);\n+      static char alloc_name[] = \"_Jv_AllocObject\";\n+      use_java_new = 1;\n+      alloc_decl = IDENTIFIER_GLOBAL_VALUE (get_identifier (alloc_name));\n+      if (alloc_decl == NULL_TREE)\n+\tfatal(\"call to Java constructor, while `%s' undefined\", alloc_name);\n+      class_addr = build1 (ADDR_EXPR, jclass_node, class_decl);\n+      rval = build_function_call (alloc_decl,\n+\t\t\t\t  tree_cons (NULL_TREE, class_addr,\n+\t\t\t\t\t     build_tree_list (NULL_TREE,\n+\t\t\t\t\t\t\t      class_size)));\n+      rval = cp_convert (build_pointer_type (true_type), rval);\n+    }\n   else\n     {\n       int susp;\n@@ -2297,7 +2356,7 @@ build_new_1 (exp)\n       if (t && TREE_VALUE (t) == NULL_TREE)\n \tnothrow = 1;\n     }\n-  check_new = flag_check_new || nothrow;\n+  check_new = (flag_check_new || nothrow) && ! use_java_new;\n \n   if ((check_new || flag_exceptions) && rval)\n     {\n@@ -2383,6 +2442,8 @@ build_new_1 (exp)\n \t      flags |= LOOKUP_HAS_IN_CHARGE;\n \t    }\n \n+\t  if (use_java_new)\n+\t    rval = save_expr (rval);\n \t  newrval = rval;\n \n \t  if (newrval && TREE_CODE (TREE_TYPE (newrval)) == POINTER_TYPE)\n@@ -2394,6 +2455,10 @@ build_new_1 (exp)\n \t  if (newrval == NULL_TREE || newrval == error_mark_node)\n \t    return error_mark_node;\n \n+\t  /* Java constructors compiled by jc1 do not return this. */\n+\t  if (use_java_new)\n+\t    newrval = build (COMPOUND_EXPR, TREE_TYPE (newrval),\n+\t\t\t     newrval, rval);\n \t  rval = newrval;\n \t  TREE_HAS_CONSTRUCTOR (rval) = 1;\n \t}\n@@ -2405,7 +2470,7 @@ build_new_1 (exp)\n \t an exception and the new-expression does not contain a\n \t new-placement, then the deallocation function is called to free\n \t the memory in which the object was being constructed.  */\n-      if (flag_exceptions && alloc_expr)\n+      if (flag_exceptions && alloc_expr && ! use_java_new)\n \t{\n \t  enum tree_code dcode = has_array ? VEC_DELETE_EXPR : DELETE_EXPR;\n \t  tree cleanup, fn = NULL_TREE;"}]}