{"sha": "61f71b34471e03254cdadd61f1418f425101273f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjFmNzFiMzQ0NzFlMDMyNTRjZGFkZDYxZjE0MThmNDI1MTAxMjczZg==", "commit": {"author": {"name": "DJ Delorie", "email": "dj@redhat.com", "date": "2003-09-04T03:18:05Z"}, "committer": {"name": "DJ Delorie", "email": "dj@gcc.gnu.org", "date": "2003-09-04T03:18:05Z"}, "message": "targhooks.c: New file.\n\n\t* targhooks.c: New file.\n\t* targhooks.h: New file.\n\t* Makefile.in: Add targhooks.o support.\n\t(function.o): Depend on$(TARGET_H).\n\t(stmt.o): Likewise.\n\t(combine.o): Depend on $(TREE_H) and $(TARGET_H).\n\t* builtins.c (apply_args_size, expand_builtin_apply_args_1,\n\texpand_builtin_apply): Convert to calls.struct_value_rtx hook.\n\t(expand_builtin_saveregs): Convert to\n\tcalls.expand_builtin_saveregs hook.\n\t* c-decl.c (start_decl): Handle new calls.promote_prototypes hook\n\there, instead of ...\n\t(get_parm_info) ... here.\n\t(store_parm_decls_oldstyle): Convert to calls.promote_prototypes\n\thook.\n\t(finish_function): Handle calls.promote_prototypes hook here too.\n\t* c-typeck.c (convert_arguments): Convert to\n\tcalls.promote_prototypes hook.\n\t(c_convert_parm_for_inlining): Likewise.\n\t* calls.c (initialize_argument_information): Convert to\n\tcalls.promote_function_args hook.\n\t(expand_call): Convert to calls.struct_value_rtx,\n\tcalls.strict_argument_naming,\n\tcalls.pretend_outgoing_varargs_named, and\n\tcalls.promote_function_return hooks.  Pass fndecl to\n\taggregate_value_p.  Initialize CUMULATIVE_ARGS before calling\n\thooks, so they can use that.\n\t(emit_library_call_value_1): Likewise.\n\t* combine.c (setup_incoming_promotions): Convert to\n\tcalls.promote_function_args hook.\n\t* emit-rtl.c: Convert to calls.struct_value_rtx hook.\n\t* expr.c (expand_assignment): Pass call to aggregate_value_p.\n\t(expand_expr): Likewise.\n\t* expr.h: Remove support for SETUP_INCOMING_VARARGS,\n\tSTRICT_ARGUMENT_NAMING, PRETEND_OUTGOING_VARARGS_NAMED,\n\tRETURN_IN_MEMORY macro defaults.\n\t* final.c (profile_function): Convert to calls.struct_value_rtx\n\thook.\n\t* function.c (aggregate_value_p): Accept function type tree as\n\tsecond parameter; try to deduce fntype from it.  Convert to\n\tcalls.return_in_memory hook.\n\t(assign_parms): Convert to calls.setup_incoming_varargs,\n\tcalls.strict_argument_naming, calls.promote_function_args,\n\tcalls.pretend_outgoing_varargs_named hooks.  Pass fndecl to\n\taggregate_value_p.\n\t(expand_function_start): Likewise.  Convert to\n\tcalls.struct_value_rtx hook.\n\t(expand_function_end): Convert to calls.promote_function_return hook.\n\t(allocate_struct_function): Pass fndecl to aggregate_value_p.\n\t* hard-reg-set.h: Update comments to new hook names.\n\t* integrate.c (expand_inline_function): Pass fndecl to aggregate_value_p.\n\t* reg-stack.c (stack_result): Likewise.\n\t* rtl.h (struct_value_rtx, struct_value_incoming_rtx): Delete.\n\t* stmt.c (expand_value_return): Convert to\n\tcalls.promote_function_return hook.\n\t* target-def.h: Add TARGET_PROMOTE_FUNCTION_ARGS,\n\tTARGET_PROMOTE_FUNCTION_RETURN, TARGET_PROMOTE_PROTOTYPES,\n\tTARGET_STRUCT_VALUE_RTX, TARGET_RETURN_IN_MEMORY,\n\tTARGET_EXPAND_BUILTIN_SAVEREGS, TARGET_SETUP_INCOMING_VARARGS,\n\tTARGET_STRICT_ARGUMENT_NAMING,\n\tTARGET_PRETEND_OUTGOING_VARARGS_NAMED, and TARGET_CALLS.\n\t* target.h: Likewise.\n\t* tree.h (aggregate_value_p): Also takes a tree to deduce function\n\tattributes from (for target hooks).\n\t* doc/tm.texi (PROMOTE_FUNCTION_ARGS, PROMOTE_FUNCTION_RETURN,\n\tPROMOTE_PROTOTYPES, RETURN_IN_MEMORY, STRUCT_VALUE_REGNUM,\n\tSTRUCT_VALUE, STRUCT_VALUE_INCOMING_REGNUM, STRUCT_VALUE_INCOMING,\n\tEXPAND_BUILTIN_SAVEREGS, SETUP_INCOMING_VARARGS,\n\tSTRICT_ARGUMENT_NAMING, PRETEND_OUTGOING_VARARGS_NAMED): Convert\n\tto hooks.\n\n\t* config/alpha/alpha.c (alpha_output_mi_thunk_osf): Pass function\n\tto aggregate_value_p.\n\t* config/arm/arm.c (arm_init_cumulative_args,\n\tarm_output_mi_thunk): Likewise.\n\t* config/i386/i386.c (ix86_return_pops_args, x86_this_parameter):\n\tLikewise.\n\t* config/mips/mips.c (mips_save_reg_p, mips_expand_prologue,\n\tmips_can_use_return_insn): Likewise.\n\t* config/rs6000/rs6000.c (rs6000_output_mi_thunk): Likewise.\n\t* config/s390/s390.c (s390_output_mi_thunk): Likewise.\n\t* config/sparc/sparc.c (sparc_output_mi_thunk): Pass function to\n\taggregate_value_p.\n\t* config/story16/stormy16.c (xstormy16_asm_output_mi_thunk): Pass\n\tfunction to aggregate_value_p.\n\t* objc/objc-act.c (generate_struct_by_value_array): Pass NULL to\n\taggregate_value_p.\n\n\t* config/sh/sh-protos.h (sh_builtin_saveregs): Remove.\n\t(sh_attr_renesas_p, sh_cfun_attr_renesas_p, sh_function_arg,\n\tsh_function_arg_advance, sh_pass_in_reg_p): New.  * config/sh/sh.c\n\t(sh_handle_renesas_attribute, sh_promote_prototypes,\n\tsh_struct_value_rtx, sh_return_in_memory, sh_builtin_saveregs,\n\tsh_setup_incoming_varargs, sh_strict_argument_naming,\n\tsh_pretend_outgoing_varargs_named): New decls.\n\t(targetm): Add new hooks.\n\t(calc_live_regs): Save MACL and MACH if the function has the\n\trenesas attribute.\n\t(sh_expand_prologue): Support renesas attribute.\n\t(sh_builtin_saveregs): Make static.\n\t(sh_build_va_list): Support renesas attribute.\n\t(sh_va_start): Likewise.\n\t(sh_va_arg): Likewise.\n\t(sh_promote_prototypes): New.\n\t(sh_function_arg): New, moved from sh.h.  Support renesas\n\tattribute.\n\t(sh_function_arg_advance): Likewise.\n\t(sh_return_in_memory): Likewise.\n\t(sh_strict_argument_naming): Likewise.\n\t(sh_pretend_outgoing_varargs_named): Likewise.\n\t(sh_struct_value_rtx): New.\n\t(sh_attribute): Add renesas attribute.\n\t(sh_handle_renesas_attribute): New.\n\t(sh_attr_renesas_p, sh_cfun_attr_renesas_p): New.\n\t(sh_ms_bitfield_layout_p): Support renesas attribute also.\n\t(sh_output_mi_thunk): Pass function to aggregate_value_p.  *\n\tconfig/sh/sh.h (TARGET_SWITCHES): Add -mrenesas as an alias for\n\t-mhitachi.\n\t(STRUCT_VALUE_REGNUM, STRUCT_VALUE, RETURN_IN_MEMORY): Moved to\n\ttarget hooks.\n\t(sh_args): Add renesas_abi flag.\n\t(INIT_CUMULATIVE_ARGS): Set it.  Pass fndecl to aggregate_value_p.\n\t(FUNCTION_ARG_ADVANCE, FUNCTION_ARG): Move to sh.c.\n\t(PASS_IN_REG_P): Support renesas attribute.  Pass DF and TF on the\n\tstack for the renesas abi.\n\t(STRICT_ARGUMENT_NAMING, PRETEND_OUTGOING_VARARGS_NAMED,\n\tSETUP_INCOMING_VARARGS, EXPAND_BUILTIN_SAVEREGS,\n\tPROMOTE_PROTOTYPES): Moved to sh.c.  * config/sh/sh.md (call): Set\n\tcall cookie to indicate renesas calls.\n\n\t* decl.c (finish_function): Pass fndecl to aggregate_value_p.\n\n\t* misc.c (default_pass_by_ref): Convert to calls.return_in_memory\n\thook.\n\nFrom-SVN: r71048", "tree": {"sha": "99ad51d803293a4cc8d3ad48596aa725cf1cc596", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/99ad51d803293a4cc8d3ad48596aa725cf1cc596"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/61f71b34471e03254cdadd61f1418f425101273f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61f71b34471e03254cdadd61f1418f425101273f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/61f71b34471e03254cdadd61f1418f425101273f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61f71b34471e03254cdadd61f1418f425101273f/comments", "author": null, "committer": null, "parents": [{"sha": "b885908b11b9952ec25251e56ab7000d9349c163", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b885908b11b9952ec25251e56ab7000d9349c163", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b885908b11b9952ec25251e56ab7000d9349c163"}], "stats": {"total": 1667, "additions": 1112, "deletions": 555}, "files": [{"sha": "62e9d65b6ced50c309a623d3c832858aa49fffab", "filename": "gcc/ChangeLog", "status": "modified", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61f71b34471e03254cdadd61f1418f425101273f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61f71b34471e03254cdadd61f1418f425101273f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=61f71b34471e03254cdadd61f1418f425101273f", "patch": "@@ -1,3 +1,135 @@\n+2003-09-03  DJ Delorie  <dj@redhat.com>\n+\n+\t* targhooks.c: New file.\n+\t* targhooks.h: New file.\n+\t* Makefile.in: Add targhooks.o support.\n+\t(function.o): Depend on$(TARGET_H).\n+\t(stmt.o): Likewise.\n+\t(combine.o): Depend on $(TREE_H) and $(TARGET_H).\n+\t* builtins.c (apply_args_size, expand_builtin_apply_args_1,\n+\texpand_builtin_apply): Convert to calls.struct_value_rtx hook.\n+\t(expand_builtin_saveregs): Convert to\n+\tcalls.expand_builtin_saveregs hook.\n+\t* c-decl.c (start_decl): Handle new calls.promote_prototypes hook\n+\there, instead of ...\n+\t(get_parm_info) ... here.\n+\t(store_parm_decls_oldstyle): Convert to calls.promote_prototypes\n+\thook.\n+\t(finish_function): Handle calls.promote_prototypes hook here too.\n+\t* c-typeck.c (convert_arguments): Convert to\n+\tcalls.promote_prototypes hook.\n+\t(c_convert_parm_for_inlining): Likewise.\n+\t* calls.c (initialize_argument_information): Convert to\n+\tcalls.promote_function_args hook.\n+\t(expand_call): Convert to calls.struct_value_rtx,\n+\tcalls.strict_argument_naming,\n+\tcalls.pretend_outgoing_varargs_named, and\n+\tcalls.promote_function_return hooks.  Pass fndecl to\n+\taggregate_value_p.  Initialize CUMULATIVE_ARGS before calling\n+\thooks, so they can use that.\n+\t(emit_library_call_value_1): Likewise.\n+\t* combine.c (setup_incoming_promotions): Convert to\n+\tcalls.promote_function_args hook.\n+\t* emit-rtl.c: Convert to calls.struct_value_rtx hook.\n+\t* expr.c (expand_assignment): Pass call to aggregate_value_p.\n+\t(expand_expr): Likewise.\n+\t* expr.h: Remove support for SETUP_INCOMING_VARARGS,\n+\tSTRICT_ARGUMENT_NAMING, PRETEND_OUTGOING_VARARGS_NAMED,\n+\tRETURN_IN_MEMORY macro defaults.\n+\t* final.c (profile_function): Convert to calls.struct_value_rtx\n+\thook.\n+\t* function.c (aggregate_value_p): Accept function type tree as\n+\tsecond parameter; try to deduce fntype from it.  Convert to\n+\tcalls.return_in_memory hook.\n+\t(assign_parms): Convert to calls.setup_incoming_varargs,\n+\tcalls.strict_argument_naming, calls.promote_function_args,\n+\tcalls.pretend_outgoing_varargs_named hooks.  Pass fndecl to\n+\taggregate_value_p.\n+\t(expand_function_start): Likewise.  Convert to\n+\tcalls.struct_value_rtx hook.\n+\t(expand_function_end): Convert to calls.promote_function_return hook.\n+\t(allocate_struct_function): Pass fndecl to aggregate_value_p.\n+\t* hard-reg-set.h: Update comments to new hook names.\n+\t* integrate.c (expand_inline_function): Pass fndecl to aggregate_value_p.\n+\t* reg-stack.c (stack_result): Likewise.\n+\t* rtl.h (struct_value_rtx, struct_value_incoming_rtx): Delete.\n+\t* stmt.c (expand_value_return): Convert to\n+\tcalls.promote_function_return hook.\n+\t* target-def.h: Add TARGET_PROMOTE_FUNCTION_ARGS,\n+\tTARGET_PROMOTE_FUNCTION_RETURN, TARGET_PROMOTE_PROTOTYPES,\n+\tTARGET_STRUCT_VALUE_RTX, TARGET_RETURN_IN_MEMORY,\n+\tTARGET_EXPAND_BUILTIN_SAVEREGS, TARGET_SETUP_INCOMING_VARARGS,\n+\tTARGET_STRICT_ARGUMENT_NAMING,\n+\tTARGET_PRETEND_OUTGOING_VARARGS_NAMED, and TARGET_CALLS.\n+\t* target.h: Likewise.\n+\t* tree.h (aggregate_value_p): Also takes a tree to deduce function\n+\tattributes from (for target hooks).\n+\t* doc/tm.texi (PROMOTE_FUNCTION_ARGS, PROMOTE_FUNCTION_RETURN,\n+\tPROMOTE_PROTOTYPES, RETURN_IN_MEMORY, STRUCT_VALUE_REGNUM,\n+\tSTRUCT_VALUE, STRUCT_VALUE_INCOMING_REGNUM, STRUCT_VALUE_INCOMING,\n+\tEXPAND_BUILTIN_SAVEREGS, SETUP_INCOMING_VARARGS,\n+\tSTRICT_ARGUMENT_NAMING, PRETEND_OUTGOING_VARARGS_NAMED): Convert\n+\tto hooks.\n+\t\n+\t* config/alpha/alpha.c (alpha_output_mi_thunk_osf): Pass function\n+\tto aggregate_value_p.\n+\t* config/arm/arm.c (arm_init_cumulative_args,\n+\tarm_output_mi_thunk): Likewise.\n+\t* config/i386/i386.c (ix86_return_pops_args, x86_this_parameter):\n+\tLikewise.\n+\t* config/mips/mips.c (mips_save_reg_p, mips_expand_prologue,\n+\tmips_can_use_return_insn): Likewise.\n+\t* config/rs6000/rs6000.c (rs6000_output_mi_thunk): Likewise.\n+\t* config/s390/s390.c (s390_output_mi_thunk): Likewise.\n+\t* config/sparc/sparc.c (sparc_output_mi_thunk): Pass function to\n+\taggregate_value_p.\n+\t* config/story16/stormy16.c (xstormy16_asm_output_mi_thunk): Pass\n+\tfunction to aggregate_value_p.\n+\t* objc/objc-act.c (generate_struct_by_value_array): Pass NULL to\n+\taggregate_value_p.\n+\t\n+\t* config/sh/sh-protos.h (sh_builtin_saveregs): Remove.\n+\t(sh_attr_renesas_p, sh_cfun_attr_renesas_p, sh_function_arg,\n+\tsh_function_arg_advance, sh_pass_in_reg_p): New.  * config/sh/sh.c\n+\t(sh_handle_renesas_attribute, sh_promote_prototypes,\n+\tsh_struct_value_rtx, sh_return_in_memory, sh_builtin_saveregs,\n+\tsh_setup_incoming_varargs, sh_strict_argument_naming,\n+\tsh_pretend_outgoing_varargs_named): New decls.\n+\t(targetm): Add new hooks.\n+\t(calc_live_regs): Save MACL and MACH if the function has the\n+\trenesas attribute.\n+\t(sh_expand_prologue): Support renesas attribute.\n+\t(sh_builtin_saveregs): Make static.\n+\t(sh_build_va_list): Support renesas attribute.\n+\t(sh_va_start): Likewise.\n+\t(sh_va_arg): Likewise.\n+\t(sh_promote_prototypes): New.\n+\t(sh_function_arg): New, moved from sh.h.  Support renesas\n+\tattribute.\n+\t(sh_function_arg_advance): Likewise.\n+\t(sh_return_in_memory): Likewise.\n+\t(sh_strict_argument_naming): Likewise.\n+\t(sh_pretend_outgoing_varargs_named): Likewise.\n+\t(sh_struct_value_rtx): New.\n+\t(sh_attribute): Add renesas attribute.\n+\t(sh_handle_renesas_attribute): New.\n+\t(sh_attr_renesas_p, sh_cfun_attr_renesas_p): New.\n+\t(sh_ms_bitfield_layout_p): Support renesas attribute also.\n+\t(sh_output_mi_thunk): Pass function to aggregate_value_p.  *\n+\tconfig/sh/sh.h (TARGET_SWITCHES): Add -mrenesas as an alias for\n+\t-mhitachi.\n+\t(STRUCT_VALUE_REGNUM, STRUCT_VALUE, RETURN_IN_MEMORY): Moved to\n+\ttarget hooks.\n+\t(sh_args): Add renesas_abi flag.\n+\t(INIT_CUMULATIVE_ARGS): Set it.  Pass fndecl to aggregate_value_p.\n+\t(FUNCTION_ARG_ADVANCE, FUNCTION_ARG): Move to sh.c.\n+\t(PASS_IN_REG_P): Support renesas attribute.  Pass DF and TF on the\n+\tstack for the renesas abi.\n+\t(STRICT_ARGUMENT_NAMING, PRETEND_OUTGOING_VARARGS_NAMED,\n+\tSETUP_INCOMING_VARARGS, EXPAND_BUILTIN_SAVEREGS,\n+\tPROMOTE_PROTOTYPES): Moved to sh.c.  * config/sh/sh.md (call): Set\n+\tcall cookie to indicate renesas calls.\n+\t\n 2003-09-03  Mostafa Hagog  <mustafa@il.ibm.com>\n \n \t* gcse.c (replace_one_set): New function."}, {"sha": "672e09ac0f056d754892c448a95a9850d0e7a444", "filename": "gcc/Makefile.in", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61f71b34471e03254cdadd61f1418f425101273f/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61f71b34471e03254cdadd61f1418f425101273f/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=61f71b34471e03254cdadd61f1418f425101273f", "patch": "@@ -844,7 +844,7 @@ OBJS-common = \\\n  reload.o reload1.o reorg.o resource.o rtl.o rtlanal.o rtl-error.o\t   \\\n  sbitmap.o sched-deps.o sched-ebb.o sched-rgn.o sched-vis.o sdbout.o\t   \\\n  sibcall.o simplify-rtx.o sreal.o ssa.o ssa-ccp.o ssa-dce.o stmt.o\t   \\\n- stor-layout.o stringpool.o timevar.o toplev.o tracer.o tree.o tree-dump.o \\\n+ stor-layout.o stringpool.o targhooks.o timevar.o toplev.o tracer.o tree.o tree-dump.o \\\n  unroll.o varasm.o varray.o version.o vmsdbgout.o xcoffout.o\t\t   \\\n  alloc-pool.o et-forest.o cfghooks.o bt-load.o pretty-print.o $(GGC) \n \n@@ -1488,6 +1488,9 @@ diagnostic.o : diagnostic.c $(DIAGNOSTIC_H) real.h \\\n opts.o : opts.c opts.h options.h toplev.h $(CONFIG_H) $(SYSTEM_H) \\\n \tcoretypes.h $(TREE_H) $(TM_H) $(LANGHOOKS_H) $(GGC_H) $(RTL_H) \\\n \toutput.h $(DIAGNOSTIC_H) $(TM_P_H) $(INSN_ATTR_H) intl.h\n+targhooks.o : targhooks.c targhooks.h $(CONFIG_H) $(SYSTEM_H) \\\n+\tcoretypes.h $(TREE_H) $(TM_H) $(RTL_H) $(TM_P_H) function.h toplev.h\n+\n toplev.o : toplev.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) $(RTL_H) \\\n    function.h flags.h xcoffout.h input.h $(INSN_ATTR_H) output.h $(DIAGNOSTIC_H) \\\n    debug.h insn-config.h intl.h $(RECOG_H) Makefile toplev.h \\\n@@ -1526,11 +1529,11 @@ varasm.o : varasm.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) $(RTL_\n function.o : function.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) \\\n    flags.h function.h $(EXPR_H) $(OPTABS_H) libfuncs.h $(REGS_H) hard-reg-set.h \\\n    insn-config.h $(RECOG_H) output.h toplev.h except.h $(HASHTAB_H) $(GGC_H) \\\n-   $(TM_P_H) langhooks.h gt-function.h\n+   $(TM_P_H) langhooks.h gt-function.h $(TARGET_H)\n stmt.o : stmt.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) flags.h \\\n    function.h insn-config.h hard-reg-set.h $(EXPR_H) libfuncs.h except.h \\\n    $(LOOP_H) $(RECOG_H) toplev.h output.h varray.h $(GGC_H) $(TM_P_H) \\\n-   langhooks.h $(PREDICT_H) gt-stmt.h $(OPTABS_H)\n+   langhooks.h $(PREDICT_H) gt-stmt.h $(OPTABS_H) $(TARGET_H)\n except.o : except.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) \\\n    flags.h except.h function.h $(EXPR_H) libfuncs.h $(INTEGRATE_H) langhooks.h \\\n    insn-config.h hard-reg-set.h $(BASIC_BLOCK_H) output.h \\\n@@ -1696,7 +1699,7 @@ dominance.o : dominance.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n et-forest.o : et-forest.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) et-forest.h alloc-pool.h\n combine.o : combine.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) flags.h \\\n    function.h insn-config.h $(INSN_ATTR_H) $(REGS_H) $(EXPR_H) \\\n-   $(BASIC_BLOCK_H) $(RECOG_H) real.h hard-reg-set.h toplev.h $(TM_P_H)\n+   $(BASIC_BLOCK_H) $(RECOG_H) real.h hard-reg-set.h toplev.h $(TM_P_H) $(TREE_H) $(TARGET_H)\n regclass.o : regclass.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    hard-reg-set.h flags.h $(BASIC_BLOCK_H) $(REGS_H) insn-config.h $(RECOG_H) reload.h \\\n    real.h toplev.h function.h output.h $(GGC_H) $(TM_P_H) $(EXPR_H) $(TIMEVAR_H)"}, {"sha": "ae7a1de3aeaddbc0a7aef2def3e254602586a2b2", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61f71b34471e03254cdadd61f1418f425101273f/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61f71b34471e03254cdadd61f1418f425101273f/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=61f71b34471e03254cdadd61f1418f425101273f", "patch": "@@ -1,3 +1,8 @@\n+2003-09-03  DJ Delorie  <dj@redhat.com>\n+\n+\t* misc.c (default_pass_by_ref): Convert to calls.return_in_memory\n+\thook.\n+\n 2003-08-30  Zack Weinberg  <zack@codesourcery.com>\n \n \t* Makefile.in: Update substitutions to match changes to"}, {"sha": "f4407e5a35de75e7294775ef04797800ac65566f", "filename": "gcc/ada/misc.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61f71b34471e03254cdadd61f1418f425101273f/gcc%2Fada%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61f71b34471e03254cdadd61f1418f425101273f/gcc%2Fada%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmisc.c?ref=61f71b34471e03254cdadd61f1418f425101273f", "patch": "@@ -7,7 +7,7 @@\n  *                           C Implementation File                          *\n  *                                                                          *\n  *                                                                          *\n- *          Copyright (C) 1992-2002 Free Software Foundation, Inc.          *\n+ *          Copyright (C) 1992-2003 Free Software Foundation, Inc.          *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -796,7 +796,7 @@ default_pass_by_ref (gnu_type)\n \t  || FUNCTION_ARG_PASS_BY_REFERENCE (cum, TYPE_MODE (gnu_type),\n \t\t\t\t\t     gnu_type, 1)\n #endif\n-\t  || RETURN_IN_MEMORY (gnu_type)\n+\t  || targetm.calls.return_in_memory (gnu_type, NULL_TREE)\n \t  || (AGGREGATE_TYPE_P (gnu_type)\n \t      && (! host_integerp (TYPE_SIZE (gnu_type), 1)\n \t\t  || 0 < compare_tree_int (TYPE_SIZE (gnu_type),"}, {"sha": "6fa03503a9e9013dcd7f6faeeda1fd1e114dc454", "filename": "gcc/builtins.c", "status": "modified", "additions": 12, "deletions": 23, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61f71b34471e03254cdadd61f1418f425101273f/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61f71b34471e03254cdadd61f1418f425101273f/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=61f71b34471e03254cdadd61f1418f425101273f", "patch": "@@ -941,7 +941,7 @@ apply_args_size (void)\n \n       /* The second value is the structure value address unless this is\n \t passed as an \"invisible\" first argument.  */\n-      if (struct_value_rtx)\n+      if (targetm.calls.struct_value_rtx (TREE_TYPE (cfun->decl), 0))\n \tsize += GET_MODE_SIZE (Pmode);\n \n       for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n@@ -1116,14 +1116,15 @@ expand_builtin_apply_args_1 (void)\n   rtx registers;\n   int size, align, regno;\n   enum machine_mode mode;\n+  rtx struct_incoming_value = targetm.calls.struct_value_rtx (TREE_TYPE (cfun->decl), 1);\n \n   /* Create a block where the arg-pointer, structure value address,\n      and argument registers can be saved.  */\n   registers = assign_stack_local (BLKmode, apply_args_size (), -1);\n \n   /* Walk past the arg-pointer and structure value address.  */\n   size = GET_MODE_SIZE (Pmode);\n-  if (struct_value_rtx)\n+  if (targetm.calls.struct_value_rtx (TREE_TYPE (cfun->decl), 0))\n     size += GET_MODE_SIZE (Pmode);\n \n   /* Save each register used in calling a function to the block.  */\n@@ -1149,10 +1150,10 @@ expand_builtin_apply_args_1 (void)\n \n   /* Save the structure value address unless this is passed as an\n      \"invisible\" first argument.  */\n-  if (struct_value_incoming_rtx)\n+  if (struct_incoming_value)\n     {\n       emit_move_insn (adjust_address (registers, Pmode, size),\n-\t\t      copy_to_reg (struct_value_incoming_rtx));\n+\t\t      copy_to_reg (struct_incoming_value));\n       size += GET_MODE_SIZE (Pmode);\n     }\n \n@@ -1210,6 +1211,7 @@ expand_builtin_apply (rtx function, rtx arguments, rtx argsize)\n   rtx incoming_args, result, reg, dest, src, call_insn;\n   rtx old_stack_level = 0;\n   rtx call_fusage = 0;\n+  rtx struct_value = targetm.calls.struct_value_rtx (TREE_TYPE (cfun->decl), 0);\n \n #ifdef POINTERS_EXTEND_UNSIGNED\n   if (GET_MODE (arguments) != Pmode)\n@@ -1263,7 +1265,7 @@ expand_builtin_apply (rtx function, rtx arguments, rtx argsize)\n \n   /* Walk past the arg-pointer and structure value address.  */\n   size = GET_MODE_SIZE (Pmode);\n-  if (struct_value_rtx)\n+  if (struct_value)\n     size += GET_MODE_SIZE (Pmode);\n \n   /* Restore each of the registers previously saved.  Make USE insns\n@@ -1283,13 +1285,13 @@ expand_builtin_apply (rtx function, rtx arguments, rtx argsize)\n   /* Restore the structure value address unless this is passed as an\n      \"invisible\" first argument.  */\n   size = GET_MODE_SIZE (Pmode);\n-  if (struct_value_rtx)\n+  if (struct_value)\n     {\n       rtx value = gen_reg_rtx (Pmode);\n       emit_move_insn (value, adjust_address (arguments, Pmode, size));\n-      emit_move_insn (struct_value_rtx, value);\n-      if (GET_CODE (struct_value_rtx) == REG)\n-\tuse_reg (&call_fusage, struct_value_rtx);\n+      emit_move_insn (struct_value, value);\n+      if (GET_CODE (struct_value) == REG)\n+\tuse_reg (&call_fusage, struct_value);\n       size += GET_MODE_SIZE (Pmode);\n     }\n \n@@ -3728,21 +3730,8 @@ expand_builtin_saveregs (void)\n \n   start_sequence ();\n \n-#ifdef EXPAND_BUILTIN_SAVEREGS\n   /* Do whatever the machine needs done in this case.  */\n-  val = EXPAND_BUILTIN_SAVEREGS ();\n-#else\n-  /* ??? We used to try and build up a call to the out of line function,\n-     guessing about what registers needed saving etc.  This became much\n-     harder with __builtin_va_start, since we don't have a tree for a\n-     call to __builtin_saveregs to fall back on.  There was exactly one\n-     port (i860) that used this code, and I'm unconvinced it could actually\n-     handle the general case.  So we no longer try to handle anything\n-     weird and make the backend absorb the evil.  */\n-\n-  error (\"__builtin_saveregs not supported by this target\");\n-  val = const0_rtx;\n-#endif\n+  val = targetm.calls.expand_builtin_saveregs ();\n \n   seq = get_insns ();\n   end_sequence ();"}, {"sha": "f16fe7cd2f606351f8da520ff17b92017184e2f3", "filename": "gcc/c-decl.c", "status": "modified", "additions": 34, "deletions": 5, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61f71b34471e03254cdadd61f1418f425101273f/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61f71b34471e03254cdadd61f1418f425101273f/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=61f71b34471e03254cdadd61f1418f425101273f", "patch": "@@ -2672,6 +2672,26 @@ start_decl (tree declarator, tree declspecs, int initialized, tree attributes)\n   /* Set attributes here so if duplicate decl, will have proper attributes.  */\n   decl_attributes (&decl, attributes, 0);\n \n+  if (TREE_CODE (decl) == FUNCTION_DECL\n+      && targetm.calls.promote_prototypes (TREE_TYPE (decl)))\n+    {\n+      tree ce = declarator;\n+\n+      if (TREE_CODE (ce) == INDIRECT_REF)\n+\tce = TREE_OPERAND (declarator, 0);\n+      if (TREE_CODE (ce) == CALL_EXPR)\n+\t{\n+\t  tree args = TREE_PURPOSE (TREE_OPERAND (ce, 1));\n+\t  for (; args; args = TREE_CHAIN (args))\n+\t    {\n+\t      tree type = TREE_TYPE (args);\n+\t      if (INTEGRAL_TYPE_P (type)\n+\t\t  && TYPE_PRECISION (type) < TYPE_PRECISION (integer_type_node))\n+\t\tDECL_ARG_TYPE (args) = integer_type_node;\n+\t    }\n+\t}\n+    }\n+\n   if (TREE_CODE (decl) == FUNCTION_DECL\n       && DECL_DECLARED_INLINE_P (decl)\n       && DECL_UNINLINABLE (decl)\n@@ -4574,10 +4594,6 @@ get_parm_info (int void_at_end)\n \t declared types.  The back end may override this.  */\n       type = TREE_TYPE (decl);\n       DECL_ARG_TYPE (decl) = type;\n-      if (PROMOTE_PROTOTYPES\n-\t  && INTEGRAL_TYPE_P (type)\n-\t  && TYPE_PRECISION (type) < TYPE_PRECISION (integer_type_node))\n-\tDECL_ARG_TYPE (decl) = integer_type_node;\n \n       /* Check for (..., void, ...) and issue an error.  */\n       if (VOID_TYPE_P (type) && !DECL_NAME (decl) && !gave_void_only_once_err)\n@@ -5899,7 +5915,7 @@ store_parm_decls_oldstyle (void)\n \t\t     useful for argument types like uid_t.  */\n \t\t  DECL_ARG_TYPE (parm) = TREE_TYPE (parm);\n \n-\t\t  if (PROMOTE_PROTOTYPES\n+\t\t  if (targetm.calls.promote_prototypes (TREE_TYPE (current_function_decl))\n \t\t      && INTEGRAL_TYPE_P (TREE_TYPE (parm))\n \t\t      && TYPE_PRECISION (TREE_TYPE (parm))\n \t\t      < TYPE_PRECISION (integer_type_node))\n@@ -6051,6 +6067,19 @@ finish_function ()\n       poplevel (0, 0, 0);\n     }\n \n+  if (TREE_CODE (fndecl) == FUNCTION_DECL\n+      && targetm.calls.promote_prototypes (TREE_TYPE (fndecl)))\n+    {\n+      tree args = DECL_ARGUMENTS (fndecl);\n+      for (; args; args = TREE_CHAIN (args))\n+ \t{\n+ \t  tree type = TREE_TYPE (args);\n+ \t  if (INTEGRAL_TYPE_P (type)\n+ \t      && TYPE_PRECISION (type) < TYPE_PRECISION (integer_type_node))\n+ \t    DECL_ARG_TYPE (args) = integer_type_node;\n+ \t}\n+    }\n+\n   BLOCK_SUPERCONTEXT (DECL_INITIAL (fndecl)) = fndecl;\n \n   /* Must mark the RESULT_DECL as being in this function.  */"}, {"sha": "23e73e8798253fbc51a3f163d9bb5aa47bb5044c", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61f71b34471e03254cdadd61f1418f425101273f/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61f71b34471e03254cdadd61f1418f425101273f/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=61f71b34471e03254cdadd61f1418f425101273f", "patch": "@@ -1866,7 +1866,7 @@ convert_arguments (tree typelist, tree values, tree name, tree fundecl)\n \t\t\t\t\t        (char *) 0, /* arg passing  */\n \t\t\t\t\t\tfundecl, name, parmnum + 1);\n \n-\t      if (PROMOTE_PROTOTYPES\n+\t      if (targetm.calls.promote_prototypes (fundecl ? TREE_TYPE (fundecl) : 0)\n \t\t  && INTEGRAL_TYPE_P (type)\n \t\t  && (TYPE_PRECISION (type) < TYPE_PRECISION (integer_type_node)))\n \t\tparmval = default_conversion (parmval);\n@@ -3615,7 +3615,7 @@ c_convert_parm_for_inlining (tree parm, tree value, tree fn)\n   ret = convert_for_assignment (type, value,\n \t\t\t\t(char *) 0 /* arg passing  */, fn,\n \t\t\t\tDECL_NAME (fn), 0);\n-  if (PROMOTE_PROTOTYPES\n+  if (targetm.calls.promote_prototypes (TREE_TYPE (fn))\n       && INTEGRAL_TYPE_P (type)\n       && (TYPE_PRECISION (type) < TYPE_PRECISION (integer_type_node)))\n     ret = default_conversion (ret);"}, {"sha": "dc3da0a91749720823b3b7d21a066118f6dd027e", "filename": "gcc/calls.c", "status": "modified", "additions": 33, "deletions": 28, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61f71b34471e03254cdadd61f1418f425101273f/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61f71b34471e03254cdadd61f1418f425101273f/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=61f71b34471e03254cdadd61f1418f425101273f", "patch": "@@ -1,5 +1,5 @@\n /* Convert function calls to rtl insns, for GNU C compiler.\n-   Copyright (C) 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998\n+   Copyright (C) 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n    1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -1177,9 +1177,8 @@ initialize_argument_information (int num_actuals ATTRIBUTE_UNUSED,\n       mode = TYPE_MODE (type);\n       unsignedp = TREE_UNSIGNED (type);\n \n-#ifdef PROMOTE_FUNCTION_ARGS\n-      mode = promote_mode (type, mode, &unsignedp, 1);\n-#endif\n+      if (targetm.calls.promote_function_args (fndecl ? TREE_TYPE (fndecl) : 0))\n+\tmode = promote_mode (type, mode, &unsignedp, 1);\n \n       args[i].unsignedp = unsignedp;\n       args[i].mode = mode;\n@@ -2060,6 +2059,7 @@ expand_call (tree exp, rtx target, int ignore)\n   /* Nonzero if called function returns an aggregate in memory PCC style,\n      by returning the address of where to find it.  */\n   int pcc_struct_value = 0;\n+  rtx struct_value = 0;\n \n   /* Number of actual parameters in this call, including struct value addr.  */\n   int num_actuals;\n@@ -2175,6 +2175,8 @@ expand_call (tree exp, rtx target, int ignore)\n   else\n     flags |= flags_from_decl_or_type (TREE_TYPE (TREE_TYPE (p)));\n \n+  struct_value = targetm.calls.struct_value_rtx (fndecl ? TREE_TYPE (fndecl) : 0, 0);\n+\n   /* Warn if this value is an aggregate type,\n      regardless of which calling convention we are using for it.  */\n   if (warn_aggregate_return && AGGREGATE_TYPE_P (TREE_TYPE (exp)))\n@@ -2222,7 +2224,7 @@ expand_call (tree exp, rtx target, int ignore)\n   /* Set up a place to return a structure.  */\n \n   /* Cater to broken compilers.  */\n-  if (aggregate_value_p (exp))\n+  if (aggregate_value_p (exp, fndecl))\n     {\n       /* This call returns a big structure.  */\n       flags &= ~(ECF_CONST | ECF_PURE | ECF_LIBCALL_BLOCK);\n@@ -2316,7 +2318,7 @@ expand_call (tree exp, rtx target, int ignore)\n \n   /* If struct_value_rtx is 0, it means pass the address\n      as if it were an extra parameter.  */\n-  if (structure_value_addr && struct_value_rtx == 0)\n+  if (structure_value_addr && struct_value == 0)\n     {\n       /* If structure_value_addr is a REG other than\n \t virtual_outgoing_args_rtx, we can use always use it.  If it\n@@ -2342,6 +2344,14 @@ expand_call (tree exp, rtx target, int ignore)\n   for (p = actparms, num_actuals = 0; p; p = TREE_CHAIN (p))\n     num_actuals++;\n \n+  /* Start updating where the next arg would go.\n+\n+     On some machines (such as the PA) indirect calls have a difuferent\n+     calling convention than normal calls.  The last argument in\n+     INIT_CUMULATIVE_ARGS tells the backend if this is an indirect call\n+     or not.  */\n+  INIT_CUMULATIVE_ARGS (args_so_far, funtype, NULL_RTX, fndecl);\n+\n   /* Compute number of named args.\n      Normally, don't include the last named arg if anonymous args follow.\n      We do include the last named arg if STRICT_ARGUMENT_NAMING is nonzero.\n@@ -2358,27 +2368,19 @@ expand_call (tree exp, rtx target, int ignore)\n      reliable way to pass unnamed args in registers, so we must force\n      them into memory.  */\n \n-  if ((STRICT_ARGUMENT_NAMING\n-       || ! PRETEND_OUTGOING_VARARGS_NAMED)\n+  if ((targetm.calls.strict_argument_naming (&args_so_far)\n+       || ! targetm.calls.pretend_outgoing_varargs_named (&args_so_far))\n       && type_arg_types != 0)\n     n_named_args\n       = (list_length (type_arg_types)\n \t /* Don't include the last named arg.  */\n-\t - (STRICT_ARGUMENT_NAMING ? 0 : 1)\n+\t - (targetm.calls.strict_argument_naming (&args_so_far) ? 0 : 1)\n \t /* Count the struct value address, if it is passed as a parm.  */\n \t + structure_value_addr_parm);\n   else\n     /* If we know nothing, treat all args as named.  */\n     n_named_args = num_actuals;\n \n-  /* Start updating where the next arg would go.\n-\n-     On some machines (such as the PA) indirect calls have a different\n-     calling convention than normal calls.  The last argument in\n-     INIT_CUMULATIVE_ARGS tells the backend if this is an indirect call\n-     or not.  */\n-  INIT_CUMULATIVE_ARGS (args_so_far, funtype, NULL_RTX, fndecl);\n-\n   /* Make a vector to hold all the information about each arg.  */\n   args = alloca (num_actuals * sizeof (struct arg_data));\n   memset (args, 0, num_actuals * sizeof (struct arg_data));\n@@ -3016,13 +3018,13 @@ expand_call (tree exp, rtx target, int ignore)\n \t    structure_value_addr = convert_memory_address\n \t\t\t\t\t(Pmode, structure_value_addr);\n #endif\n-\t  emit_move_insn (struct_value_rtx,\n+\t  emit_move_insn (struct_value,\n \t\t\t  force_reg (Pmode,\n \t\t\t\t     force_operand (structure_value_addr,\n \t\t\t\t\t\t    NULL_RTX)));\n \n-\t  if (GET_CODE (struct_value_rtx) == REG)\n-\t    use_reg (&call_fusage, struct_value_rtx);\n+\t  if (GET_CODE (struct_value) == REG)\n+\t    use_reg (&call_fusage, struct_value);\n \t}\n \n       funexp = prepare_call_address (funexp, fndecl, &call_fusage,\n@@ -3246,7 +3248,8 @@ expand_call (tree exp, rtx target, int ignore)\n       else\n \ttarget = copy_to_reg (valreg);\n \n-#ifdef PROMOTE_FUNCTION_RETURN\n+      if (targetm.calls.promote_function_return(funtype))\n+\t{\n       /* If we promoted this return value, make the proper SUBREG.  TARGET\n \t might be const0_rtx here, so be careful.  */\n       if (GET_CODE (target) == REG\n@@ -3277,7 +3280,7 @@ expand_call (tree exp, rtx target, int ignore)\n \t  SUBREG_PROMOTED_VAR_P (target) = 1;\n \t  SUBREG_PROMOTED_UNSIGNED_SET (target, unsignedp);\n \t}\n-#endif\n+\t}\n \n       /* If size of args is variable or this was a constructor call for a stack\n \t argument, restore saved stack-pointer value.  */\n@@ -3586,6 +3589,8 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n   int initial_highest_arg_in_use = highest_outgoing_arg_in_use;\n   char *initial_stack_usage_map = stack_usage_map;\n \n+  rtx struct_value = targetm.calls.struct_value_rtx (0, 0);\n+\n #ifdef REG_PARM_STACK_SPACE\n #ifdef MAYBE_REG_PARM_STACK_SPACE\n   reg_parm_stack_space = MAYBE_REG_PARM_STACK_SPACE;\n@@ -3638,7 +3643,7 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n   if (outmode != VOIDmode)\n     {\n       tfom = (*lang_hooks.types.type_for_mode) (outmode, 0);\n-      if (aggregate_value_p (tfom))\n+      if (aggregate_value_p (tfom, 0))\n \t{\n #ifdef PCC_STATIC_STRUCT_RETURN\n \t  rtx pointer_reg\n@@ -3693,7 +3698,7 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n \n   /* If there's a structure value address to be passed,\n      either pass it in the special place, or pass it as an extra argument.  */\n-  if (mem_value && struct_value_rtx == 0 && ! pcc_struct_value)\n+  if (mem_value && struct_value == 0 && ! pcc_struct_value)\n     {\n       rtx addr = XEXP (mem_value, 0);\n       nargs++;\n@@ -4068,14 +4073,14 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n     }\n \n   /* Pass the function the address in which to return a structure value.  */\n-  if (mem_value != 0 && struct_value_rtx != 0 && ! pcc_struct_value)\n+  if (mem_value != 0 && struct_value != 0 && ! pcc_struct_value)\n     {\n-      emit_move_insn (struct_value_rtx,\n+      emit_move_insn (struct_value,\n \t\t      force_reg (Pmode,\n \t\t\t\t force_operand (XEXP (mem_value, 0),\n \t\t\t\t\t\tNULL_RTX)));\n-      if (GET_CODE (struct_value_rtx) == REG)\n-\tuse_reg (&call_fusage, struct_value_rtx);\n+      if (GET_CODE (struct_value) == REG)\n+\tuse_reg (&call_fusage, struct_value);\n     }\n \n   /* Don't allow popping to be deferred, since then"}, {"sha": "26cdf49dc78483ca1fc2498e2677f7b167f16883", "filename": "gcc/combine.c", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61f71b34471e03254cdadd61f1418f425101273f/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61f71b34471e03254cdadd61f1418f425101273f/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=61f71b34471e03254cdadd61f1418f425101273f", "patch": "@@ -75,6 +75,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"coretypes.h\"\n #include \"tm.h\"\n #include \"rtl.h\"\n+#include \"tree.h\"\n #include \"tm_p.h\"\n #include \"flags.h\"\n #include \"regs.h\"\n@@ -88,6 +89,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"recog.h\"\n #include \"real.h\"\n #include \"toplev.h\"\n+#include \"target.h\"\n \n /* It is not safe to use ordinary gen_lowpart in combine.\n    Use gen_lowpart_for_combine instead.  See comments there.  */\n@@ -799,30 +801,31 @@ init_reg_last_arrays (void)\n static void\n setup_incoming_promotions (void)\n {\n-#ifdef PROMOTE_FUNCTION_ARGS\n   unsigned int regno;\n   rtx reg;\n   enum machine_mode mode;\n   int unsignedp;\n   rtx first = get_insns ();\n \n+  if (targetm.calls.promote_function_args (TREE_TYPE (cfun->decl)))\n+    {\n #ifndef OUTGOING_REGNO\n #define OUTGOING_REGNO(N) N\n #endif\n-  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n-    /* Check whether this register can hold an incoming pointer\n-       argument.  FUNCTION_ARG_REGNO_P tests outgoing register\n-       numbers, so translate if necessary due to register windows.  */\n-    if (FUNCTION_ARG_REGNO_P (OUTGOING_REGNO (regno))\n-\t&& (reg = promoted_input_arg (regno, &mode, &unsignedp)) != 0)\n-      {\n-\trecord_value_for_reg\n-\t  (reg, first, gen_rtx_fmt_e ((unsignedp ? ZERO_EXTEND\n-\t\t\t\t       : SIGN_EXTEND),\n-\t\t\t\t      GET_MODE (reg),\n-\t\t\t\t      gen_rtx_CLOBBER (mode, const0_rtx)));\n-      }\n-#endif\n+      for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n+\t/* Check whether this register can hold an incoming pointer\n+\t   argument.  FUNCTION_ARG_REGNO_P tests outgoing register\n+\t   numbers, so translate if necessary due to register windows.  */\n+\tif (FUNCTION_ARG_REGNO_P (OUTGOING_REGNO (regno))\n+\t    && (reg = promoted_input_arg (regno, &mode, &unsignedp)) != 0)\n+\t  {\n+\t    record_value_for_reg\n+\t      (reg, first, gen_rtx_fmt_e ((unsignedp ? ZERO_EXTEND\n+\t\t\t\t\t   : SIGN_EXTEND),\n+\t\t\t\t\t  GET_MODE (reg),\n+\t\t\t\t\t  gen_rtx_CLOBBER (mode, const0_rtx)));\n+\t  }\n+    }\n }\n \f\n /* Called via note_stores.  If X is a pseudo that is narrower than"}, {"sha": "72d01af2f153595d10c2a053274000f5cf4b1a09", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61f71b34471e03254cdadd61f1418f425101273f/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61f71b34471e03254cdadd61f1418f425101273f/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=61f71b34471e03254cdadd61f1418f425101273f", "patch": "@@ -7799,7 +7799,7 @@ alpha_output_mi_thunk_osf (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n \n   /* Find the \"this\" pointer.  If the function returns a structure,\n      the structure return pointer is in $16.  */\n-  if (aggregate_value_p (TREE_TYPE (TREE_TYPE (function))))\n+  if (aggregate_value_p (TREE_TYPE (TREE_TYPE (function)), function))\n     this = gen_rtx_REG (Pmode, 17);\n   else\n     this = gen_rtx_REG (Pmode, 16);"}, {"sha": "5e92b28b79b566a8359bc08639a025edc9ca8ecf", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61f71b34471e03254cdadd61f1418f425101273f/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61f71b34471e03254cdadd61f1418f425101273f/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=61f71b34471e03254cdadd61f1418f425101273f", "patch": "@@ -1968,7 +1968,7 @@ arm_init_cumulative_args (CUMULATIVE_ARGS *pcum, tree fntype,\n \t\t\t  tree fndecl ATTRIBUTE_UNUSED)\n {\n   /* On the ARM, the offset starts at 0.  */\n-  pcum->nregs = ((fntype && aggregate_value_p (TREE_TYPE (fntype))) ? 1 : 0);\n+  pcum->nregs = ((fntype && aggregate_value_p (TREE_TYPE (fntype), fntype)) ? 1 : 0);\n   pcum->iwmmxt_nregs = 0;\n   \n   pcum->call_cookie = CALL_NORMAL;\n@@ -12962,7 +12962,7 @@ arm_output_mi_thunk (FILE *file, tree thunk ATTRIBUTE_UNUSED,\n   int mi_delta = delta;\n   const char *const mi_op = mi_delta < 0 ? \"sub\" : \"add\";\n   int shift = 0;\n-  int this_regno = (aggregate_value_p (TREE_TYPE (TREE_TYPE (function)))\n+  int this_regno = (aggregate_value_p (TREE_TYPE (TREE_TYPE (function)), function)\n                     ? 1 : 0);\n   if (mi_delta < 0)\n     mi_delta = - mi_delta;"}, {"sha": "bccbae9bb3c490f6249fd0cfa072e71181b49765", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61f71b34471e03254cdadd61f1418f425101273f/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61f71b34471e03254cdadd61f1418f425101273f/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=61f71b34471e03254cdadd61f1418f425101273f", "patch": "@@ -1748,7 +1748,7 @@ ix86_return_pops_args (tree fundecl, tree funtype, int size)\n   }\n \n   /* Lose any fake structure return argument if it is passed on the stack.  */\n-  if (aggregate_value_p (TREE_TYPE (funtype))\n+  if (aggregate_value_p (TREE_TYPE (funtype), fundecl)\n       && !TARGET_64BIT)\n     {\n       int nregs = ix86_function_regparm (funtype, fundecl);\n@@ -15150,7 +15150,7 @@ x86_this_parameter (tree function)\n \n   if (TARGET_64BIT)\n     {\n-      int n = aggregate_value_p (TREE_TYPE (type)) != 0;\n+      int n = aggregate_value_p (TREE_TYPE (type), type) != 0;\n       return gen_rtx_REG (DImode, x86_64_int_parameter_registers[n]);\n     }\n \n@@ -15174,7 +15174,7 @@ x86_this_parameter (tree function)\n \t}\n     }\n \n-  if (aggregate_value_p (TREE_TYPE (type)))\n+  if (aggregate_value_p (TREE_TYPE (type), type))\n     return gen_rtx_MEM (SImode, plus_constant (stack_pointer_rtx, 8));\n   else\n     return gen_rtx_MEM (SImode, plus_constant (stack_pointer_rtx, 4));"}, {"sha": "26443223ddc68e386e13e2ccab048bade023113c", "filename": "gcc/config/i960/i960.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61f71b34471e03254cdadd61f1418f425101273f/gcc%2Fconfig%2Fi960%2Fi960.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61f71b34471e03254cdadd61f1418f425101273f/gcc%2Fconfig%2Fi960%2Fi960.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi960%2Fi960.c?ref=61f71b34471e03254cdadd61f1418f425101273f", "patch": "@@ -1086,7 +1086,7 @@ i960_function_name_declare (file, name, fndecl)\n       \n   /* See if caller passes in an address to return value.  */\n \n-  if (aggregate_value_p (DECL_RESULT (fndecl)))\n+  if (aggregate_value_p (DECL_RESULT (fndecl), fndecl))\n     {\n       tail_call_ok = 0;\n       leaf_proc_ok = 0;"}, {"sha": "2787ce11649c6e46c453b6b32688671aecccc76a", "filename": "gcc/config/m68hc11/m68hc11.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61f71b34471e03254cdadd61f1418f425101273f/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61f71b34471e03254cdadd61f1418f425101273f/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c?ref=61f71b34471e03254cdadd61f1418f425101273f", "patch": "@@ -1490,7 +1490,7 @@ m68hc11_init_cumulative_args (cum, fntype, libname)\n \n   ret_type = TREE_TYPE (fntype);\n \n-  if (ret_type && aggregate_value_p (ret_type))\n+  if (ret_type && aggregate_value_p (ret_type, fntype))\n     {\n       cum->words = 1;\n       cum->nregs = 1;"}, {"sha": "7fa4ad80ebdcdd6083d5eb12be491bfb59999930", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61f71b34471e03254cdadd61f1418f425101273f/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61f71b34471e03254cdadd61f1418f425101273f/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=61f71b34471e03254cdadd61f1418f425101273f", "patch": "@@ -5933,7 +5933,7 @@ mips_save_reg_p (unsigned int regno)\n       if (regno == GP_REG_FIRST + 31\n \t  && mips16_hard_float\n \t  && !mips_entry\n-\t  && !aggregate_value_p (return_type)\n+\t  && !aggregate_value_p (return_type, current_function_decl)\n \t  && GET_MODE_CLASS (DECL_MODE (return_type)) == MODE_FLOAT\n \t  && GET_MODE_SIZE (DECL_MODE (return_type)) <= UNITS_PER_FPVALUE)\n \treturn true;\n@@ -6712,7 +6712,7 @@ mips_expand_prologue (void)\n     REGNO (pic_offset_table_rtx) = cfun->machine->global_pointer;\n \n   /* If struct value address is treated as the first argument, make it so.  */\n-  if (aggregate_value_p (DECL_RESULT (fndecl))\n+  if (aggregate_value_p (DECL_RESULT (fndecl), fndecl)\n       && ! current_function_returns_pcc_struct\n       && struct_value_incoming_rtx == 0)\n     {\n@@ -7179,7 +7179,7 @@ mips_can_use_return_insn (void)\n      registers.  */\n   if (TARGET_MIPS16\n       && mips16_hard_float\n-      && ! aggregate_value_p (return_type)\n+      && ! aggregate_value_p (return_type, current_function_decl)\n       && GET_MODE_CLASS (DECL_MODE (return_type)) == MODE_FLOAT\n       && GET_MODE_SIZE (DECL_MODE (return_type)) <= UNITS_PER_FPVALUE)\n     return 0;"}, {"sha": "378170ca79d2a9e8a9b69d3444cbd098923bcda7", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61f71b34471e03254cdadd61f1418f425101273f/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61f71b34471e03254cdadd61f1418f425101273f/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=61f71b34471e03254cdadd61f1418f425101273f", "patch": "@@ -12430,7 +12430,7 @@ rs6000_output_mi_thunk (file, thunk_fndecl, delta, vcall_offset, function)\n \n   /* Find the \"this\" pointer.  If the function returns a structure,\n      the structure return pointer is in r3.  */\n-  if (aggregate_value_p (TREE_TYPE (TREE_TYPE (function))))\n+  if (aggregate_value_p (TREE_TYPE (TREE_TYPE (function)), function))\n     this = gen_rtx_REG (Pmode, 4);\n   else\n     this = gen_rtx_REG (Pmode, 3);"}, {"sha": "7086d5b69325acc6b0be8c39f281520b47f52a51", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61f71b34471e03254cdadd61f1418f425101273f/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61f71b34471e03254cdadd61f1418f425101273f/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=61f71b34471e03254cdadd61f1418f425101273f", "patch": "@@ -6629,7 +6629,7 @@ s390_output_mi_thunk (FILE *file, tree thunk ATTRIBUTE_UNUSED,\n     }\n \n   /* Operand 1 is the 'this' pointer.  */\n-  if (aggregate_value_p (TREE_TYPE (TREE_TYPE (function))))\n+  if (aggregate_value_p (TREE_TYPE (TREE_TYPE (function)), function))\n     op[1] = gen_rtx_REG (Pmode, 3);\n   else\n     op[1] = gen_rtx_REG (Pmode, 2);"}, {"sha": "b87aecd0181b489632102c95f414ff07bcb9a164", "filename": "gcc/config/sh/sh-protos.h", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61f71b34471e03254cdadd61f1418f425101273f/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61f71b34471e03254cdadd61f1418f425101273f/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh-protos.h?ref=61f71b34471e03254cdadd61f1418f425101273f", "patch": "@@ -25,7 +25,6 @@ Boston, MA 02111-1307, USA.  */\n #define GCC_SH_PROTOS_H\n \n #ifdef RTX_CODE\n-extern struct rtx_def *sh_builtin_saveregs PARAMS ((void));\n extern struct rtx_def *prepare_scc_operands PARAMS ((enum rtx_code));\n \n /* Declare functions defined in sh.c and used in templates.  */\n@@ -121,6 +120,8 @@ extern int fldi_ok PARAMS ((void));\n extern int sh_pr_n_sets PARAMS ((void));\n extern int sh_hard_regno_rename_ok PARAMS ((unsigned int, unsigned int));\n extern int sh_cfun_interrupt_handler_p PARAMS ((void));\n+extern int sh_attr_renesas_p PARAMS ((tree));\n+extern int sh_cfun_attr_renesas_p PARAMS ((void));\n extern void sh_initialize_trampoline PARAMS ((rtx, rtx, rtx));\n extern bool sh_cannot_change_mode_class\n \t      PARAMS ((enum machine_mode, enum machine_mode, enum reg_class));\n@@ -138,4 +139,8 @@ extern void sh_pr_nosave_low_regs PARAMS ((struct cpp_reader *));\n extern rtx function_symbol (const char *);\n extern rtx sh_get_pr_initial_val (void);\n \n+extern rtx sh_function_arg (CUMULATIVE_ARGS *, enum machine_mode, tree, int);\n+extern void sh_function_arg_advance (CUMULATIVE_ARGS *, enum machine_mode, tree, int);\n+extern int sh_pass_in_reg_p (CUMULATIVE_ARGS *, enum machine_mode, tree);\n+\n #endif /* ! GCC_SH_PROTOS_H */"}, {"sha": "a266471b063a6ce4cee638876fd75e2bdc1aef93", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 426, "deletions": 10, "changes": 436, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61f71b34471e03254cdadd61f1418f425101273f/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61f71b34471e03254cdadd61f1418f425101273f/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=61f71b34471e03254cdadd61f1418f425101273f", "patch": "@@ -203,6 +203,7 @@ const struct attribute_spec sh_attribute_table[];\n static tree sh_handle_interrupt_handler_attribute PARAMS ((tree *, tree, tree, int, bool *));\n static tree sh_handle_sp_switch_attribute PARAMS ((tree *, tree, tree, int, bool *));\n static tree sh_handle_trap_exit_attribute PARAMS ((tree *, tree, tree, int, bool *));\n+static tree sh_handle_renesas_attribute PARAMS ((tree *, tree, tree, int, bool *));\n static void sh_output_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n static void sh_insert_attributes PARAMS ((tree, tree *));\n static int sh_adjust_cost PARAMS ((rtx, rtx, rtx, int));\n@@ -238,6 +239,15 @@ static int scavenge_reg (HARD_REG_SET *s);\n struct save_schedule_s;\n static struct save_entry_s *sh5_schedule_saves (HARD_REG_SET *,\n \t\t\t\t\t\tstruct save_schedule_s *, int);\n+\n+static bool sh_promote_prototypes PARAMS ((tree));\n+static rtx sh_struct_value_rtx PARAMS ((tree, int));\n+static bool sh_return_in_memory PARAMS ((tree, tree));\n+static rtx sh_builtin_saveregs PARAMS ((void));\n+static void sh_setup_incoming_varargs PARAMS ((CUMULATIVE_ARGS *, enum machine_mode, tree, int *, int));\n+static bool sh_strict_argument_naming PARAMS ((CUMULATIVE_ARGS *));\n+static bool sh_pretend_outgoing_varargs_named PARAMS ((CUMULATIVE_ARGS *));\n+\n \f\n /* Initialize the GCC target structure.  */\n #undef TARGET_ATTRIBUTE_TABLE\n@@ -315,6 +325,27 @@ static struct save_entry_s *sh5_schedule_saves (HARD_REG_SET *,\n #define TARGET_HAVE_TLS true\n #endif\n \n+#undef TARGET_PROMOTE_PROTOTYPES\n+#define TARGET_PROMOTE_PROTOTYPES sh_promote_prototypes\n+#undef TARGET_PROMOTE_FUNCTION_ARGS\n+#define TARGET_PROMOTE_FUNCTION_ARGS sh_promote_prototypes\n+#undef TARGET_PROMOTE_FUNCTION_RETURN\n+#define TARGET_PROMOTE_FUNCTION_RETURN sh_promote_prototypes\n+\n+#undef TARGET_STRUCT_VALUE_RTX\n+#define TARGET_STRUCT_VALUE_RTX sh_struct_value_rtx\n+#undef TARGET_RETURN_IN_MEMORY\n+#define TARGET_RETURN_IN_MEMORY sh_return_in_memory\n+\n+#undef TARGET_EXPAND_BUILTIN_SAVEREGS\n+#define TARGET_EXPAND_BUILTIN_SAVEREGS sh_builtin_saveregs\n+#undef TARGET_SETUP_INCOMING_VARARGS\n+#define TARGET_SETUP_INCOMING_VARARGS sh_setup_incoming_varargs\n+#undef TARGET_STRICT_ARGUMENT_NAMING\n+#define TARGET_STRICT_ARGUMENT_NAMING sh_strict_argument_naming\n+#undef TARGET_PRETEND_OUTGOING_VARARGS_NAMED\n+#define TARGET_PRETEND_OUTGOING_VARARGS_NAMED sh_pretend_outgoing_varargs_named\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n /* Print the operand address in x to the stream.  */\n@@ -4898,7 +4929,11 @@ calc_live_regs (live_regs_mask)\n \t\t && (reg == (int) EH_RETURN_DATA_REGNO (0)\n \t\t     || reg == (int) EH_RETURN_DATA_REGNO (1)\n \t\t     || reg == (int) EH_RETURN_DATA_REGNO (2)\n-\t\t     || reg == (int) EH_RETURN_DATA_REGNO (3)))))\n+\t\t     || reg == (int) EH_RETURN_DATA_REGNO (3)))\n+\t     || ((reg == MACL_REG || reg == MACH_REG)\n+\t\t && regs_ever_live[reg]\n+\t\t && sh_cfun_attr_renesas_p ())\n+\t     ))\n \t{\n \t  SET_HARD_REG_BIT (*live_regs_mask, reg);\n \t  count += GET_MODE_SIZE (REGISTER_NATURAL_MODE (reg));\n@@ -5190,7 +5225,8 @@ sh_expand_prologue ()\n   if (current_function_stdarg)\n     {\n       /* This is not used by the SH2E calling convention  */\n-      if (TARGET_SH1 && ! TARGET_SH2E && ! TARGET_SH5 && ! TARGET_HITACHI)\n+      if (TARGET_SH1 && ! TARGET_SH2E && ! TARGET_SH5\n+\t  && ! (TARGET_HITACHI || sh_cfun_attr_renesas_p ()))\n \t{\n \t  /* Push arg regs as if they'd been provided by caller in stack.  */\n \t  for (i = 0; i < NPARM_REGS(SImode); i++)\n@@ -5822,7 +5858,7 @@ sh_output_function_epilogue (file, size)\n   sp_switch = NULL_RTX;\n }\n \n-rtx\n+static rtx\n sh_builtin_saveregs ()\n {\n   /* First unnamed integer register.  */\n@@ -5972,7 +6008,8 @@ sh_build_va_list ()\n   tree f_next_o, f_next_o_limit, f_next_fp, f_next_fp_limit, f_next_stack;\n   tree record;\n \n-  if (TARGET_SH5 || (! TARGET_SH2E && ! TARGET_SH4) || TARGET_HITACHI)\n+  if (TARGET_SH5 || (! TARGET_SH2E && ! TARGET_SH4)\n+      || TARGET_HITACHI || sh_cfun_attr_renesas_p ())\n     return ptr_type_node;\n \n   record = make_node (RECORD_TYPE);\n@@ -6026,7 +6063,8 @@ sh_va_start (valist, nextarg)\n       return;\n     }\n \n-  if ((! TARGET_SH2E && ! TARGET_SH4) || TARGET_HITACHI)\n+  if ((! TARGET_SH2E && ! TARGET_SH4)\n+      || TARGET_HITACHI || sh_cfun_attr_renesas_p ())\n     {\n       std_expand_builtin_va_start (valist, nextarg);\n       return;\n@@ -6105,7 +6143,8 @@ sh_va_arg (valist, type)\n   if (pass_by_ref)\n     type = build_pointer_type (type);\n \n-  if (! TARGET_SH5 && (TARGET_SH2E || TARGET_SH4) && ! TARGET_HITACHI)\n+  if (! TARGET_SH5 && (TARGET_SH2E || TARGET_SH4)\n+      && ! (TARGET_HITACHI || sh_cfun_attr_renesas_p ()))\n     {\n       tree f_next_o, f_next_o_limit, f_next_fp, f_next_fp_limit, f_next_stack;\n       tree next_o, next_o_limit, next_fp, next_fp_limit, next_stack;\n@@ -6289,6 +6328,343 @@ sh_va_arg (valist, type)\n   return result;\n }\n \n+static bool\n+sh_promote_prototypes (type)\n+     tree type;\n+{\n+  if (TARGET_HITACHI)\n+    return 0;\n+  if (! type)\n+    return 1;\n+  return ! sh_attr_renesas_p (type);\n+}\n+\n+/* Define where to put the arguments to a function.\n+   Value is zero to push the argument on the stack,\n+   or a hard register in which to store the argument.\n+\n+   MODE is the argument's machine mode.\n+   TYPE is the data type of the argument (as a tree).\n+    This is null for libcalls where that information may\n+    not be available.\n+   CUM is a variable of type CUMULATIVE_ARGS which gives info about\n+    the preceding args and about the function being called.\n+   NAMED is nonzero if this argument is a named parameter\n+    (otherwise it is an extra parameter matching an ellipsis).\n+\n+   On SH the first args are normally in registers\n+   and the rest are pushed.  Any arg that starts within the first\n+   NPARM_REGS words is at least partially passed in a register unless\n+   its data type forbids.  */\n+\n+\n+rtx\n+sh_function_arg (ca, mode, type, named)\n+     CUMULATIVE_ARGS *ca;\n+     enum machine_mode mode;\n+     tree type;\n+     int named;\n+{\n+  if (! TARGET_SH5 && mode == VOIDmode)\n+    return GEN_INT (ca->renesas_abi ? 1 : 0);\n+\n+  if (! TARGET_SH5\n+      && PASS_IN_REG_P (*ca, mode, type)\n+      && (named || ! (TARGET_HITACHI || ca->renesas_abi)))\n+    {\n+      int regno;\n+\n+      if (mode == SCmode && TARGET_SH4 && TARGET_LITTLE_ENDIAN\n+\t  && (! FUNCTION_ARG_SCmode_WART || (ROUND_REG (*ca, mode) & 1)))\n+\t{\n+\t  rtx r1 = gen_rtx_EXPR_LIST (VOIDmode,\n+\t\t\t\t      gen_rtx_REG (SFmode,\n+\t\t\t\t\t\t   BASE_ARG_REG (mode)\n+\t\t\t\t\t\t   + (ROUND_REG (*ca, mode) ^ 1)),\n+\t\t\t\t      const0_rtx);\n+\t  rtx r2 = gen_rtx_EXPR_LIST(VOIDmode,\n+\t\t\t\t     gen_rtx_REG (SFmode,\n+\t\t\t\t\t\t  BASE_ARG_REG (mode)\n+\t\t\t\t\t\t  + ((ROUND_REG (*ca, mode) + 1) ^ 1)),\n+\t\t\t\t     GEN_INT (4));\n+\t  return gen_rtx_PARALLEL(SCmode, gen_rtvec(2, r1, r2));\n+\t}\n+\n+     /* If the alignment of a DF value causes an SF register to be\n+\tskipped, we will use that skipped register for the next SF\n+\tvalue.  */\n+      if ((TARGET_HITACHI || ca->renesas_abi)\n+\t  && ca->free_single_fp_reg\n+\t  && mode == SFmode)\n+\treturn gen_rtx_REG (mode, ca->free_single_fp_reg);\n+\n+      regno = (BASE_ARG_REG (mode) + ROUND_REG (*ca, mode))\n+\t       ^ (mode == SFmode && TARGET_SH4\n+\t\t  && TARGET_LITTLE_ENDIAN != 0\n+\t\t  && ! TARGET_HITACHI && ! ca->renesas_abi);\n+      return gen_rtx_REG (mode, regno);\n+\n+    }\n+  \n+  if (TARGET_SH5)\n+    {\n+      if (mode == VOIDmode && TARGET_SHCOMPACT)\n+\treturn GEN_INT (ca->call_cookie);\n+\n+      /* The following test assumes unnamed arguments are promoted to\n+\t DFmode.  */\n+      if (mode == SFmode && ca->free_single_fp_reg)\n+\treturn SH5_PROTOTYPED_FLOAT_ARG (*ca, mode, ca->free_single_fp_reg);\n+\n+      if ((GET_SH_ARG_CLASS (mode) == SH_ARG_FLOAT)\n+\t  && (named || ! ca->prototype_p)\n+\t  && ca->arg_count[(int) SH_ARG_FLOAT] < NPARM_REGS (SFmode))\n+\t{\n+\t  if (! ca->prototype_p && TARGET_SHMEDIA)\n+\t    return SH5_PROTOTYPELESS_FLOAT_ARG (*ca, mode);\n+\n+\t  return SH5_PROTOTYPED_FLOAT_ARG (*ca, mode,\n+\t\t\t\t\t   FIRST_FP_PARM_REG\n+\t\t\t\t\t   + ca->arg_count[(int) SH_ARG_FLOAT]);\n+\t}\n+\n+      if (ca->arg_count[(int) SH_ARG_INT] < NPARM_REGS (SImode)\n+\t  && (! TARGET_SHCOMPACT\n+\t      || (! SHCOMPACT_FORCE_ON_STACK (mode, type)\n+\t\t  && ! SH5_WOULD_BE_PARTIAL_NREGS (*ca, mode,\n+\t\t\t\t\t\t   type, named))))\n+\t{\n+\t  return gen_rtx_REG (mode, (FIRST_PARM_REG\n+\t\t\t\t       + ca->arg_count[(int) SH_ARG_INT]));\n+\t}\n+\n+      return 0;\n+    }\n+\n+  return 0;\n+}\n+ \n+/* Update the data in CUM to advance over an argument\n+   of mode MODE and data type TYPE.\n+   (TYPE is null for libcalls where that information may not be\n+   available.)  */\n+\n+void\n+sh_function_arg_advance (ca, mode, type, named)\n+     CUMULATIVE_ARGS *ca;\n+     enum machine_mode mode;\n+     tree type;\n+     int named;\n+{\n+ if (ca->force_mem)\n+   ca->force_mem = 0;\n+ else if (TARGET_SH5)\n+   {\n+     tree type2 = (ca->byref && type\n+\t\t   ? TREE_TYPE (type)\n+ \t\t   : type);\n+     enum machine_mode mode2 = (ca->byref && type\n+\t\t\t\t? TYPE_MODE (type2)\n+\t\t\t\t: mode);\n+     int dwords = ((ca->byref\n+\t\t    ? ca->byref\n+\t\t    : mode2 == BLKmode\n+\t\t    ? int_size_in_bytes (type2)\n+\t\t    : GET_MODE_SIZE (mode2)) + 7) / 8;\n+     int numregs = MIN (dwords, NPARM_REGS (SImode)\n+\t\t\t- ca->arg_count[(int) SH_ARG_INT]);\n+\n+     if (numregs)\n+       {\n+\t ca->arg_count[(int) SH_ARG_INT] += numregs;\n+\t if (TARGET_SHCOMPACT\n+\t     && SHCOMPACT_FORCE_ON_STACK (mode2, type2))\n+\t   {\n+\t     ca->call_cookie\n+\t       |= CALL_COOKIE_INT_REG (ca->arg_count[(int) SH_ARG_INT]\n+\t\t\t\t       - numregs, 1);\n+\t     /* N.B. We want this also for outgoing.   */\n+\t     ca->stack_regs += numregs;\n+\t   }\n+\t else if (ca->byref)\n+\t   {\n+\t     if (! ca->outgoing)\n+\t       ca->stack_regs += numregs;\n+\t     ca->byref_regs += numregs;\n+\t     ca->byref = 0;\n+\t     do\n+\t       ca->call_cookie\n+\t\t |= CALL_COOKIE_INT_REG (ca->arg_count[(int) SH_ARG_INT]\n+\t\t\t\t\t - numregs, 2);\n+\t     while (--numregs);\n+\t     ca->call_cookie\n+\t       |= CALL_COOKIE_INT_REG (ca->arg_count[(int) SH_ARG_INT]\n+\t\t\t\t       - 1, 1);\n+\t   }\n+\t else if (dwords > numregs)\n+\t   {\n+\t     int pushregs = numregs;\n+\n+\t     if (TARGET_SHCOMPACT)\n+\t       ca->stack_regs += numregs;\n+\t     while (pushregs < NPARM_REGS (SImode) - 1\n+\t\t    && (CALL_COOKIE_INT_REG_GET\n+\t\t\t(ca->call_cookie,\n+\t\t\tNPARM_REGS (SImode) - pushregs)\n+\t\t\t== 1))\n+\t       {\n+\t\t ca->call_cookie\n+\t\t   &= ~ CALL_COOKIE_INT_REG (NPARM_REGS (SImode)\n+\t\t\t\t\t     - pushregs, 1);\n+\t\t pushregs++;\n+\t       }\n+\t     if (numregs == NPARM_REGS (SImode))\n+\t       ca->call_cookie\n+\t\t |= CALL_COOKIE_INT_REG (0, 1)\n+\t\t    | CALL_COOKIE_STACKSEQ (numregs - 1);\n+\t     else\n+\t       ca->call_cookie\n+\t\t |= CALL_COOKIE_STACKSEQ (numregs);\n+\t   }\n+       }\n+     if (GET_SH_ARG_CLASS (mode2) == SH_ARG_FLOAT\n+\t && (named || ! ca->prototype_p))\n+       {\n+\t if (mode2 == SFmode && ca->free_single_fp_reg)\n+\t   ca->free_single_fp_reg = 0;\n+\t else if (ca->arg_count[(int) SH_ARG_FLOAT]\n+ \t\t  < NPARM_REGS (SFmode))\n+\t   {\n+\t     int numfpregs\n+\t       = MIN ((GET_MODE_SIZE (mode2) + 7) / 8 * 2,\n+\t\t      NPARM_REGS (SFmode)\n+\t\t      - ca->arg_count[(int) SH_ARG_FLOAT]);\n+\n+\t     ca->arg_count[(int) SH_ARG_FLOAT] += numfpregs;\n+\n+\t     if (TARGET_SHCOMPACT && ! ca->prototype_p)\n+\t       {\n+\t\t if (ca->outgoing && numregs > 0)\n+\t\t   do\n+\t\t     {\n+\t\t       ca->call_cookie\n+\t\t\t |= (CALL_COOKIE_INT_REG\n+\t\t\t     (ca->arg_count[(int) SH_ARG_INT]\n+\t\t\t      - numregs + ((numfpregs - 2) / 2),\n+\t\t\t      4 + (ca->arg_count[(int) SH_ARG_FLOAT]\n+\t\t\t\t   - numfpregs) / 2));\n+\t\t     }\n+\t\t   while (numfpregs -= 2);\n+\t       }\n+\t     else if (mode2 == SFmode && (named)\n+\t\t      && (ca->arg_count[(int) SH_ARG_FLOAT]\n+\t\t\t  < NPARM_REGS (SFmode)))\n+\t       ca->free_single_fp_reg\n+\t\t = FIRST_FP_PARM_REG - numfpregs\n+\t\t + ca->arg_count[(int) SH_ARG_FLOAT] + 1;\n+\t   }\n+       }\n+     return;\n+   }\n+\n+ if ((TARGET_HITACHI || ca->renesas_abi) && TARGET_FPU_DOUBLE)\n+   {\n+     /* Note that we've used the skipped register.  */\n+     if (mode == SFmode && ca->free_single_fp_reg)\n+       {\n+\t ca->free_single_fp_reg = 0;\n+\t return;\n+       }\n+     /* When we have a DF after an SF, there's an SF register that get\n+\tskipped in order to align the DF value.  We note this skipped\n+\tregister, because the next SF value will use it, and not the\n+\tSF that follows the DF.  */\n+     if (mode == DFmode\n+\t && ROUND_REG (*ca, DFmode) != ROUND_REG (*ca, SFmode))\n+       {\n+\t ca->free_single_fp_reg = (ROUND_REG (*ca, SFmode)\n+\t\t\t\t     + BASE_ARG_REG (mode));\n+       }\n+   }\n+\n+ if (! (TARGET_SH4 || ca->renesas_abi)\n+     || PASS_IN_REG_P (*ca, mode, type))\n+   (ca->arg_count[(int) GET_SH_ARG_CLASS (mode)]\n+    = (ROUND_REG (*ca, mode)\n+       + (mode == BLKmode\n+\t  ? ROUND_ADVANCE (int_size_in_bytes (type))\n+\t  : ROUND_ADVANCE (GET_MODE_SIZE (mode)))));\n+}\n+\n+/* If the structure value address is not passed in a register, define\n+   `STRUCT_VALUE' as an expression returning an RTX for the place\n+   where the address is passed.  If it returns 0, the address is\n+   passed as an \"invisible\" first argument.  */\n+/* The Renesas calling convention doesn't quite fit into this scheme since\n+   the address is passed like an invisible argument, but one that is always\n+   passed in memory.  */\n+static rtx\n+sh_struct_value_rtx (fndecl, incoming)\n+     tree fndecl;\n+     int incoming ATTRIBUTE_UNUSED;\n+{\n+  if (TARGET_HITACHI || sh_attr_renesas_p (fndecl))\n+    return 0;\n+  return gen_rtx_REG (Pmode, 2);\n+}\n+\n+static bool\n+sh_return_in_memory (type, fndecl)\n+     tree type;\n+     tree fndecl;\n+{\n+  if (TARGET_SH5)\n+    {\n+      if (TYPE_MODE (type) == BLKmode)\n+\treturn ((unsigned HOST_WIDE_INT) int_size_in_bytes (type)) > 8;\n+      else\n+\treturn GET_MODE_SIZE (TYPE_MODE (type)) > 8;\n+    }\n+  else\n+    {\n+      return (TYPE_MODE (type) == BLKmode\n+\t      || ((TARGET_HITACHI || sh_attr_renesas_p (fndecl))\n+\t\t  && TREE_CODE (type) == RECORD_TYPE));\n+    }\n+}\n+\n+/* We actually emit the code in sh_expand_prologue.  We used to use\n+   a static variable to flag that we need to emit this code, but that\n+   doesn't when inlining, when functions are deferred and then emitted\n+   later.  Fortunately, we already have two flags that are part of struct\n+   function that tell if a function uses varargs or stdarg.  */\n+static void\n+sh_setup_incoming_varargs (ca, mode, type, pretend_arg_size, second_time)\n+     CUMULATIVE_ARGS *ca ATTRIBUTE_UNUSED;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n+     tree type ATTRIBUTE_UNUSED;\n+     int *pretend_arg_size ATTRIBUTE_UNUSED;\n+     int second_time ATTRIBUTE_UNUSED;\n+{\n+  if (! current_function_stdarg)\n+    abort ();\n+}\n+\n+static bool\n+sh_strict_argument_naming (ca)\n+     CUMULATIVE_ARGS *ca ATTRIBUTE_UNUSED;\n+{\n+  return TARGET_SH5;\n+}\n+\n+static bool\n+sh_pretend_outgoing_varargs_named (ca)\n+     CUMULATIVE_ARGS *ca;\n+{\n+  return ! (TARGET_HITACHI || ca->renesas_abi) && ! TARGET_SH5;\n+}\n+\n+\n /* Define the offset between two registers, one to be eliminated, and\n    the other its replacement, at the start of a routine.  */\n \n@@ -6424,14 +6800,20 @@ sh_insert_attributes (node, attributes)\n    to run on.\n \n    trap_exit -- use a trapa to exit an interrupt function instead of\n-   an rte instruction.  */\n+   an rte instruction.\n+\n+   renesas -- use Renesas calling/layout conventions (functions and\n+   structures).\n+\n+*/\n \n const struct attribute_spec sh_attribute_table[] =\n {\n   /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */\n   { \"interrupt_handler\", 0, 0, true,  false, false, sh_handle_interrupt_handler_attribute },\n   { \"sp_switch\",         1, 1, true,  false, false, sh_handle_sp_switch_attribute },\n   { \"trap_exit\",         1, 1, true,  false, false, sh_handle_trap_exit_attribute },\n+  { \"renesas\",           0, 0, false, true, false, sh_handle_renesas_attribute },\n   { NULL,                0, 0, false, false, false, NULL }\n };\n \n@@ -6537,6 +6919,40 @@ sh_handle_trap_exit_attribute (node, name, args, flags, no_add_attrs)\n   return NULL_TREE;\n }\n \n+static tree\n+sh_handle_renesas_attribute (node, name, args, flags, no_add_attrs)\n+     tree *node ATTRIBUTE_UNUSED;\n+     tree name ATTRIBUTE_UNUSED;\n+     tree args ATTRIBUTE_UNUSED;\n+     int flags ATTRIBUTE_UNUSED;\n+     bool *no_add_attrs ATTRIBUTE_UNUSED;\n+{\n+  return NULL_TREE;\n+}\n+\n+/* True if __attribute__((renesas)) or -mrenesas.  */\n+int\n+sh_attr_renesas_p (td)\n+     tree td;\n+{\n+  if (TARGET_HITACHI)\n+    return 1;\n+  if (td == 0)\n+    return 0;\n+  if (DECL_P (td))\n+    td = TREE_TYPE (td);\n+  return (lookup_attribute (\"renesas\", TYPE_ATTRIBUTES (td))\n+\t  != NULL_TREE);\n+}\n+\n+/* True if __attribute__((renesas)) or -mrenesas, for the current\n+   function.  */\n+int\n+sh_cfun_attr_renesas_p ()\n+{\n+  return sh_attr_renesas_p (current_function_decl);\n+}\n+\n int\n sh_cfun_interrupt_handler_p ()\n {\n@@ -8000,7 +8416,7 @@ static bool\n sh_ms_bitfield_layout_p (record_type)\n      tree record_type ATTRIBUTE_UNUSED;\n {\n-  return TARGET_SH5;\n+  return (TARGET_SH5 || TARGET_HITACHI || sh_attr_renesas_p (record_type));\n }\n \f\n /* \n@@ -8683,10 +9099,10 @@ sh_output_mi_thunk (file, thunk_fndecl, delta, vcall_offset, function)\n      comes first, in which case \"this\" comes second.  */\n   INIT_CUMULATIVE_ARGS (cum, funtype, NULL_RTX, 0);\n #ifndef PCC_STATIC_STRUCT_RETURN\n-  if (aggregate_value_p (TREE_TYPE (TREE_TYPE (function))))\n+  if (aggregate_value_p (TREE_TYPE (TREE_TYPE (function)), function))\n     structure_value_byref = 1;\n #endif /* not PCC_STATIC_STRUCT_RETURN */\n-  if (structure_value_byref && struct_value_rtx == 0)\n+  if (structure_value_byref && sh_struct_value_rtx (function, 0) == 0)\n     { \n       tree ptype = build_pointer_type (TREE_TYPE (funtype));\n "}, {"sha": "a3aa1dd29ae06aff67653e3b9873472f7d3d1ec7", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 18, "deletions": 237, "changes": 255, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61f71b34471e03254cdadd61f1418f425101273f/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61f71b34471e03254cdadd61f1418f425101273f/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=61f71b34471e03254cdadd61f1418f425101273f", "patch": "@@ -319,6 +319,7 @@ extern int target_flags;\n   {\"dalign\",  \tDALIGN_BIT, \"Aligns doubles at 64-bit boundaries\" },\t\t\\\n   {\"fmovd\",  \tFMOVD_BIT, \"\" },\t\t\\\n   {\"hitachi\",\tHITACHI_BIT, \"Follow Renesas (formerly Hitachi) / SuperH calling conventions\" },\t\t\\\n+  {\"renesas\",\tHITACHI_BIT, \"Follow Renesas (formerly Hitachi) / SuperH calling conventions\" },\t\t\\\n   {\"nomacsave\", NOMACSAVE_BIT, \"Mark MAC register as call-clobbered\" },\t\t\\\n   {\"ieee\",  \tIEEE_BIT, \"Increase the IEEE compliance for floating-point code\" },\t\t\t\\\n   {\"isize\", \tISIZE_BIT, \"\" },\t\t\\\n@@ -1126,29 +1127,6 @@ extern char sh_additional_register_names[ADDREGNAMES_SIZE] \\\n /* Register in which the static-chain is passed to a function.  */\n #define STATIC_CHAIN_REGNUM\t(TARGET_SH5 ? 1 : 3)\n \n-/* The register in which a struct value address is passed.  */\n-\n-#define STRUCT_VALUE_REGNUM 2\n-\n-/* If the structure value address is not passed in a register, define\n-   `STRUCT_VALUE' as an expression returning an RTX for the place\n-   where the address is passed.  If it returns 0, the address is\n-   passed as an \"invisible\" first argument.  */\n-\n-/* The Renesas calling convention doesn't quite fit into this scheme since\n-   the address is passed like an invisible argument, but one that is always\n-   passed in memory.  */\n-#define STRUCT_VALUE \\\n-  (TARGET_HITACHI ? 0 : gen_rtx_REG (Pmode, STRUCT_VALUE_REGNUM))\n-\n-#define RETURN_IN_MEMORY(TYPE) \\\n-  (TARGET_SH5 \\\n-   ? ((TYPE_MODE (TYPE) == BLKmode \\\n-       ? (unsigned HOST_WIDE_INT) int_size_in_bytes (TYPE) \\\n-       : GET_MODE_SIZE (TYPE_MODE (TYPE))) > 8) \\\n-   : (TYPE_MODE (TYPE) == BLKmode \\\n-      || (TARGET_HITACHI && TREE_CODE (TYPE) == RECORD_TYPE)))\n-\n /* Don't default to pcc-struct-return, because we have already specified\n    exactly how to return structures in the RETURN_IN_MEMORY macro.  */\n \n@@ -1797,6 +1775,10 @@ struct sh_args {\n #define CALL_COOKIE_INT_REG_GET(COOKIE, REG) \\\n   (((COOKIE) >> CALL_COOKIE_INT_REG_SHIFT (REG)) & ((REG) < 4 ? 7 : 15))\n     long call_cookie;\n+\n+  /* This is set to non-zero when the call in question must use the Renesas ABI,\n+     even without the -mrenesas option.  */\n+    int renesas_abi;\n };\n \n #define CUMULATIVE_ARGS  struct sh_args\n@@ -1839,17 +1821,18 @@ struct sh_args {\n \n    For TARGET_HITACHI, the structure value pointer is passed in memory.  */\n \n-#define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME, INDIRECT) \\\n+#define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME, FNDECL) \\\n   do {\t\t\t\t\t\t\t\t\\\n     (CUM).arg_count[(int) SH_ARG_INT] = 0;\t\t\t\\\n     (CUM).arg_count[(int) SH_ARG_FLOAT] = 0;\t\t\t\\\n+    (CUM).renesas_abi = sh_attr_renesas_p (FNTYPE) ? 1 : 0;\t\\\n     (CUM).force_mem\t\t\t\t\t\t\\\n-      = (TARGET_HITACHI && FNTYPE\t\t\t\t\\\n-\t && aggregate_value_p (TREE_TYPE (FNTYPE)));\t\t\\\n+      = ((TARGET_HITACHI || (CUM).renesas_abi) && (FNTYPE)\t\\\n+\t && aggregate_value_p (TREE_TYPE (FNTYPE), (FNDECL)));\t\\\n     (CUM).prototype_p = (FNTYPE) && TYPE_ARG_TYPES (FNTYPE);\t\\\n     (CUM).arg_count[(int) SH_ARG_INT]\t\t\t\t\\\n       = (TARGET_SH5 && (FNTYPE)\t\t\t\t\t\\\n-\t && aggregate_value_p (TREE_TYPE (FNTYPE)));\t\t\\\n+\t && aggregate_value_p (TREE_TYPE (FNTYPE), (FNDECL)));\t\\\n     (CUM).free_single_fp_reg = 0;\t\t\t\t\\\n     (CUM).outgoing = 1;\t\t\t\t\t\t\\\n     (CUM).stack_regs = 0;\t\t\t\t\t\\\n@@ -1881,136 +1864,23 @@ struct sh_args {\n     INIT_CUMULATIVE_ARGS ((CUM), (FNTYPE), (LIBNAME), 0);\t\\\n     (CUM).outgoing = 0;\t\t\t\t\t\t\\\n   } while (0)\n- \n-/* Update the data in CUM to advance over an argument\n-   of mode MODE and data type TYPE.\n-   (TYPE is null for libcalls where that information may not be\n-   available.)  */\n \n #define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\\\n- if ((CUM).force_mem)\t\t\t\t\t\\\n-   (CUM).force_mem = 0;\t\t\t\t\t\\\n- else if (TARGET_SH5)\t\t\t\t\t\\\n-   {\t\t\t\t\t\t\t\\\n-     tree TYPE_ = ((CUM).byref && (TYPE)\t\t\\\n-\t\t   ? TREE_TYPE (TYPE)\t\t\t\\\n- \t\t   : (TYPE));\t\t\t\t\\\n-     enum machine_mode MODE_ = ((CUM).byref && (TYPE)\t\\\n-\t\t\t\t? TYPE_MODE (TYPE_)\t\\\n-\t\t\t\t: (MODE));\t\t\\\n-     int dwords = (((CUM).byref\t\t\t\t\\\n-\t\t    ? (CUM).byref\t\t\t\\\n-\t\t    : (MODE_) == BLKmode\t\t\\\n-\t\t    ? int_size_in_bytes (TYPE_)\t\t\\\n-\t\t    : GET_MODE_SIZE (MODE_)) + 7) / 8;\t\\\n-     int numregs = MIN (dwords, NPARM_REGS (SImode)\t\\\n-\t\t\t- (CUM).arg_count[(int) SH_ARG_INT]); \\\n-\t\t\t\t\t\t\t\\\n-     if (numregs)\t\t\t\t\t\\\n-       {\t\t\t\t\t\t\\\n-\t (CUM).arg_count[(int) SH_ARG_INT] += numregs;\t\\\n-\t if (TARGET_SHCOMPACT\t\t\t\t\\\n-\t     && SHCOMPACT_FORCE_ON_STACK (MODE_, TYPE_)) \\\n-\t   {\t\t\t\t\t\t\\\n-\t     (CUM).call_cookie \t\t\t\t\\\n-\t       |= CALL_COOKIE_INT_REG (((CUM).arg_count[(int) SH_ARG_INT] \\\n-\t\t\t\t\t- numregs), 1);\t\\\n-\t     /* N.B. We want this also for outgoing.   */\\\n-\t     (CUM).stack_regs += numregs;\t\t\\\n-\t   }\t\t\t\t\t\t\\\n-\t else if ((CUM).byref)\t\t\t\t\\\n-\t   {\t\t\t\t\t\t\\\n-\t     if (! (CUM).outgoing)\t\t\t\\\n-\t       (CUM).stack_regs += numregs;\t\t\\\n-\t     (CUM).byref_regs += numregs;\t\t\\\n-\t     (CUM).byref = 0;\t\t\t\t\\\n-\t     do\t\t\t\t\t\t\\\n-\t       (CUM).call_cookie\t\t\t\\\n-\t\t |= CALL_COOKIE_INT_REG (((CUM).arg_count[(int) SH_ARG_INT] \\\n-\t\t\t\t\t  - numregs), 2); \\\n-\t     while (--numregs);\t\t\t\t\\\n-\t     (CUM).call_cookie\t\t\t\t\\\n-\t       |= CALL_COOKIE_INT_REG (((CUM).arg_count[(int) SH_ARG_INT] \\\n-\t\t\t\t        - 1), 1); \\\n-\t   }\t\t\t\t\t\t\\\n-\t else if (dwords > numregs)\t\t\t\\\n-\t   {\t\t\t\t\t\t\\\n-\t     int pushregs = numregs;\t\t\t\\\n-\t\t\t\t\t\t\t\\\n-\t     if (TARGET_SHCOMPACT)\t\t\t\\\n-\t       (CUM).stack_regs += numregs;\t\t\\\n-\t     while (pushregs < NPARM_REGS (SImode) - 1\t\\\n-\t\t    && (CALL_COOKIE_INT_REG_GET\t\t\\\n-\t\t\t((CUM).call_cookie,\t\t\\\n-\t\t\tNPARM_REGS (SImode) - pushregs) \\\n-\t\t\t== 1))\t\t\t\t\\\n-\t       {\t\t\t\t\t\\\n-\t\t (CUM).call_cookie\t\t\t\\\n-\t\t   &= ~ CALL_COOKIE_INT_REG (NPARM_REGS (SImode) \\\n-\t\t\t\t\t     - pushregs, 1); \\\n-\t\t pushregs++;\t\t\t\t\\\n-\t       }\t\t\t\t\t\\\n-\t     if (numregs == NPARM_REGS (SImode))\t\\\n-\t       (CUM).call_cookie \t\t\t\\\n-\t\t |= CALL_COOKIE_INT_REG (0, 1)\t\t\\\n-\t\t    | CALL_COOKIE_STACKSEQ (numregs - 1); \\\n-\t     else\t\t\t\t\t\\\n-\t       (CUM).call_cookie\t\t\t\\\n-\t\t |= CALL_COOKIE_STACKSEQ (numregs);\t\\\n-\t   }\t\t\t\t\t\t\\\n-       }\t\t\t\t\t\t\\\n-     if (GET_SH_ARG_CLASS (MODE_) == SH_ARG_FLOAT\t\\\n-\t && ((NAMED) || ! (CUM).prototype_p))\t\t\\\n-       {\t\t\t\t\t\t\\\n-\t if ((MODE_) == SFmode && (CUM).free_single_fp_reg) \\\n-\t   (CUM).free_single_fp_reg = 0;\t\t\\\n-\t else if ((CUM).arg_count[(int) SH_ARG_FLOAT]\t\\\n- \t\t  < NPARM_REGS (SFmode))\t\t\\\n-\t   {\t\t\t\t\t        \\\n-\t     int numfpregs\t\t \t\t\\\n-\t       = MIN ((GET_MODE_SIZE (MODE_) + 7) / 8 * 2, \\\n-\t\t      NPARM_REGS (SFmode)\t\t\\\n-\t\t      - (CUM).arg_count[(int) SH_ARG_FLOAT]); \\\n-\t\t \t\t\t\t\t\\\n-\t     (CUM).arg_count[(int) SH_ARG_FLOAT] += numfpregs; \\\n-\t\t\t\t\t\t\t\\\n-\t     if (TARGET_SHCOMPACT && ! (CUM).prototype_p) \\\n-\t       {\t\t\t\t\t\\\n-\t\t if ((CUM).outgoing && numregs > 0)\t\\\n-\t\t   do\t\t\t\t\t\\\n-\t\t     {\t\t\t\t\t\\\n-\t\t       (CUM).call_cookie\t\t\\\n-\t\t\t |= (CALL_COOKIE_INT_REG\t\\\n-\t\t\t     ((CUM).arg_count[(int) SH_ARG_INT] \\\n-\t\t\t      - numregs + ((numfpregs - 2) / 2), \\\n-\t\t\t      4 + ((CUM).arg_count[(int) SH_ARG_FLOAT] \\\n-\t\t\t\t   - numfpregs) / 2));\t\\\n-\t\t     }\t\t\t\t\t\\\n-\t\t   while (numfpregs -= 2);\t\t\\\n-\t       }\t\t\t\t\t\\\n-\t     else if ((MODE_) == SFmode && (NAMED)\t\\\n-\t\t      && ((CUM).arg_count[(int) SH_ARG_FLOAT] \\\n-\t\t\t  < NPARM_REGS (SFmode)))\t\\\n-\t       (CUM).free_single_fp_reg\t\t\t\\\n-\t\t = FIRST_FP_PARM_REG - numfpregs\t\\\n-\t\t + (CUM).arg_count[(int) SH_ARG_FLOAT] + 1; \\\n-\t   }\t\t\t\t\t\t\\\n-       }\t\t\t\t\t\t\\\n-   }\t\t\t\t\t\t\t\\\n- else if (! TARGET_SH4 || PASS_IN_REG_P ((CUM), (MODE), (TYPE))) \\\n-   ((CUM).arg_count[(int) GET_SH_ARG_CLASS (MODE)]\t\\\n-    = (ROUND_REG ((CUM), (MODE))\t\t\t\\\n-       + ((MODE) == BLKmode\t\t\t\t\\\n-\t  ? ROUND_ADVANCE (int_size_in_bytes (TYPE))\t\\\n-\t  : ROUND_ADVANCE (GET_MODE_SIZE (MODE)))))\n+\tsh_function_arg_advance (&(CUM), (MODE), (TYPE), (NAMED))\n+#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED)\t\\\n+\tsh_function_arg (&(CUM), (MODE), (TYPE), (NAMED))\n \n /* Return boolean indicating arg of mode MODE will be passed in a reg.\n    This macro is only used in this file.  */\n \n #define PASS_IN_REG_P(CUM, MODE, TYPE) \\\n   (((TYPE) == 0 \\\n     || (! TREE_ADDRESSABLE ((tree)(TYPE)) \\\n-\t&& (! TARGET_HITACHI || ! AGGREGATE_TYPE_P (TYPE)))) \\\n+\t&& (! (TARGET_HITACHI || (CUM).renesas_abi) \\\n+\t    || ! (AGGREGATE_TYPE_P (TYPE) \\\n+\t\t  || (!TARGET_FPU_ANY \\\n+\t\t      && (GET_MODE_CLASS (MODE) == MODE_FLOAT \\\n+\t\t\t  && GET_MODE_SIZE (MODE) > GET_MODE_SIZE (SFmode))))))) \\\n    && ! (CUM).force_mem \\\n    && (TARGET_SH2E \\\n        ? ((MODE) == BLKmode \\\n@@ -2040,75 +1910,6 @@ struct sh_args {\n    foo (float a, __complex float b); a: fr5 b.real: fr4 b.imag: fr7  */\n #define FUNCTION_ARG_SCmode_WART 1\n \n-/* Define where to put the arguments to a function.\n-   Value is zero to push the argument on the stack,\n-   or a hard register in which to store the argument.\n-\n-   MODE is the argument's machine mode.\n-   TYPE is the data type of the argument (as a tree).\n-    This is null for libcalls where that information may\n-    not be available.\n-   CUM is a variable of type CUMULATIVE_ARGS which gives info about\n-    the preceding args and about the function being called.\n-   NAMED is nonzero if this argument is a named parameter\n-    (otherwise it is an extra parameter matching an ellipsis).\n-\n-   On SH the first args are normally in registers\n-   and the rest are pushed.  Any arg that starts within the first\n-   NPARM_REGS words is at least partially passed in a register unless\n-   its data type forbids.  */\n-\n-#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) \\\n-  ((! TARGET_SH5 \\\n-    && PASS_IN_REG_P ((CUM), (MODE), (TYPE))\t\t\t\t\\\n-    && ((NAMED) || !TARGET_HITACHI))\t\t\t\t\t\\\n-   ? (((MODE) == SCmode && TARGET_SH4 && TARGET_LITTLE_ENDIAN\t\t\\\n-       && (! FUNCTION_ARG_SCmode_WART || (ROUND_REG ((CUM), (MODE)) & 1)))\\\n-      ? (gen_rtx_PARALLEL\t\t\t\t\t\t\\\n-\t (SCmode,\t\t\t\t\t\t\t\\\n-\t  (gen_rtvec\t\t\t\t\t\t\t\\\n-\t   (2, \t\t\t\t\t\t\t\t\\\n-\t    (gen_rtx_EXPR_LIST\t\t\t\t\t\t\\\n-\t     (VOIDmode,\t\t\t\t\t\t\t\\\n-\t      gen_rtx_REG (SFmode,\t\t\t\t\t\\\n-\t\t\t   BASE_ARG_REG (MODE)\t\t\t\t\\\n-\t\t\t   + (ROUND_REG ((CUM), (MODE)) ^ 1)),\t\t\\\n-\t      const0_rtx)),\t\t\t\t\t\t\\\n-\t    (gen_rtx_EXPR_LIST\t\t\t\t\t\t\\\n-\t     (VOIDmode,\t\t\t\t\t\t\t\\\n-\t      gen_rtx_REG (SFmode,\t\t\t\t\t\\\n-\t\t\t   BASE_ARG_REG (MODE)\t\t\t\t\\\n-\t\t\t   + ((ROUND_REG ((CUM), (MODE)) + 1) ^ 1)),\t\\\n-\t      GEN_INT (4)))))))\t\t\t\t\t\t\\\n-      : gen_rtx_REG ((MODE),\t\t\t\t\t\t\\\n-\t\t     ((BASE_ARG_REG (MODE) + ROUND_REG ((CUM), (MODE))) \\\n-\t\t      ^ ((MODE) == SFmode && TARGET_SH4\t\t\t\\\n-\t\t\t && TARGET_LITTLE_ENDIAN != 0))))\t\t\\\n-   : TARGET_SH5\t\t\t\t\t\t\t\t\\\n-   ? ((MODE) == VOIDmode && TARGET_SHCOMPACT\t\t\t\t\\\n-      ? GEN_INT ((CUM).call_cookie)\t\t\t\t\t\\\n-      /* The following test assumes unnamed arguments are promoted to\t\\\n-\t DFmode.  */\t\t\t\t\t\t\t\\\n-      : (MODE) == SFmode && (CUM).free_single_fp_reg\t\t\t\\\n-      ? SH5_PROTOTYPED_FLOAT_ARG ((CUM), (MODE), (CUM).free_single_fp_reg) \\\n-      : (GET_SH_ARG_CLASS (MODE) == SH_ARG_FLOAT\t\t\t\\\n-         && ((NAMED) || ! (CUM).prototype_p)\t\t\t\t\\\n-         && (CUM).arg_count[(int) SH_ARG_FLOAT] < NPARM_REGS (SFmode))\t\\\n-      ? ((! (CUM).prototype_p && TARGET_SHMEDIA)\t\t\t\\\n-\t ? SH5_PROTOTYPELESS_FLOAT_ARG ((CUM), (MODE))\t\t\t\\\n-\t : SH5_PROTOTYPED_FLOAT_ARG ((CUM), (MODE),\t\t\t\\\n-\t\t\t\t     FIRST_FP_PARM_REG\t\t\t\\\n-\t\t\t\t     + (CUM).arg_count[(int) SH_ARG_FLOAT])) \\\n-      : ((CUM).arg_count[(int) SH_ARG_INT] < NPARM_REGS (SImode)\t\\\n-\t && (! TARGET_SHCOMPACT\t\t\t\t\t\t\\\n-\t     || (! SHCOMPACT_FORCE_ON_STACK ((MODE), (TYPE))\t\t\\\n-\t         && ! SH5_WOULD_BE_PARTIAL_NREGS ((CUM), (MODE),\t\\\n-\t\t\t\t\t\t  (TYPE), (NAMED)))))\t\\\n-      ? gen_rtx_REG ((MODE), (FIRST_PARM_REG\t\t\t\t\\\n- \t\t\t      + (CUM).arg_count[(int) SH_ARG_INT]))\t\\\n-      : 0)\t\t\t\t\t\t\t\t\\\n-   : 0)\n-\n /* Whether an argument must be passed by reference.  On SHcompact, we\n    pretend arguments wider than 32-bits that would have been passed in\n    registers are passed by reference, so that an SHmedia trampoline\n@@ -2203,10 +2004,6 @@ struct sh_args {\n \t\t\t\t\t\t\t  (REG)),\t\\\n \t\t\t\t   const0_rtx))))\n \n-#define STRICT_ARGUMENT_NAMING TARGET_SH5\n-\n-#define PRETEND_OUTGOING_VARARGS_NAMED (! TARGET_HITACHI && ! TARGET_SH5)\n-\n /* For an arg passed partly in registers and partly in memory,\n    this is the number of registers used.\n    For args passed entirely in registers or entirely in memory, zero.\n@@ -2238,16 +2035,6 @@ struct sh_args {\n /* Perform any needed actions needed for a function that is receiving a\n    variable number of arguments.  */\n \n-/* We actually emit the code in sh_expand_prologue.  We used to use\n-   a static variable to flag that we need to emit this code, but that\n-   doesn't when inlining, when functions are deferred and then emitted\n-   later.  Fortunately, we already have two flags that are part of struct\n-   function that tell if a function uses varargs or stdarg.  */\n-#define SETUP_INCOMING_VARARGS(ASF, MODE, TYPE, PAS, ST)  do \\\n-  if (! current_function_stdarg) \\\n-    abort (); \\\n-while (0)\n-\n /* Define the `__builtin_va_list' type for the ABI.  */\n #define BUILD_VA_LIST_TYPE(VALIST) \\\n   (VALIST) = sh_build_va_list ()\n@@ -2336,9 +2123,6 @@ while (0)\n #define INCOMING_RETURN_ADDR_RTX \\\n   gen_rtx_REG (Pmode, TARGET_SHMEDIA ? PR_MEDIA_REG : PR_REG)\n \f\n-/* Generate necessary RTL for __builtin_saveregs().  */\n-#define EXPAND_BUILTIN_SAVEREGS() sh_builtin_saveregs ()\n-\f\n /* Addressing modes, and classification of registers for them.  */\n #define HAVE_POST_INCREMENT  TARGET_SH1\n #define HAVE_PRE_DECREMENT   TARGET_SH1\n@@ -2919,9 +2703,6 @@ while (0)\n    but a CALL with constant address is cheap.  */\n /*#define NO_FUNCTION_CSE 1*/\n \n-/* Chars and shorts should be passed as ints.  */\n-#define PROMOTE_PROTOTYPES 1\n-\n /* The machine modes of pointers and functions.  */\n #define Pmode  (TARGET_SHMEDIA64 ? DImode : SImode)\n #define FUNCTION_MODE  Pmode"}, {"sha": "c5c55c76bf2a7978718956abfd15740812171eda", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61f71b34471e03254cdadd61f1418f425101273f/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61f71b34471e03254cdadd61f1418f425101273f/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=61f71b34471e03254cdadd61f1418f425101273f", "patch": "@@ -5869,7 +5869,10 @@\n       DONE;\n     }\n   else\n+  {\n     operands[0] = force_reg (SImode, XEXP (operands[0], 0));\n+    operands[1] = operands[2];\n+  }\n \n   emit_call_insn (gen_calli (operands[0], operands[1]));\n   DONE;"}, {"sha": "84d27d26a34d97db62d514ad8fb8c6e379382a08", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61f71b34471e03254cdadd61f1418f425101273f/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61f71b34471e03254cdadd61f1418f425101273f/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=61f71b34471e03254cdadd61f1418f425101273f", "patch": "@@ -8301,7 +8301,7 @@ sparc_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n \n   /* Find the \"this\" pointer.  Normally in %o0, but in ARCH64 if the function\n      returns a structure, the structure return pointer is there instead.  */\n-  if (TARGET_ARCH64 && aggregate_value_p (TREE_TYPE (TREE_TYPE (function))))\n+  if (TARGET_ARCH64 && aggregate_value_p (TREE_TYPE (TREE_TYPE (function)), function))\n     this = gen_rtx_REG (Pmode, SPARC_INCOMING_INT_ARG_FIRST + 1);\n   else\n     this = gen_rtx_REG (Pmode, SPARC_INCOMING_INT_ARG_FIRST);"}, {"sha": "d493b7ce79767168e73dc878b74cf476ecae6c98", "filename": "gcc/config/stormy16/stormy16.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61f71b34471e03254cdadd61f1418f425101273f/gcc%2Fconfig%2Fstormy16%2Fstormy16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61f71b34471e03254cdadd61f1418f425101273f/gcc%2Fconfig%2Fstormy16%2Fstormy16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fstormy16%2Fstormy16.c?ref=61f71b34471e03254cdadd61f1418f425101273f", "patch": "@@ -1562,7 +1562,7 @@ xstormy16_asm_output_mi_thunk (file, thunk_fndecl, delta,\n   int regnum = FIRST_ARGUMENT_REGISTER;\n   \n   /* There might be a hidden first argument for a returned structure.  */\n-  if (aggregate_value_p (TREE_TYPE (TREE_TYPE (function))))\n+  if (aggregate_value_p (TREE_TYPE (TREE_TYPE (function)), function))\n     regnum += 1;\n   \n   fprintf (file, \"\\tadd %s,#0x%x\\n\", reg_names[regnum], (int) delta & 0xFFFF);"}, {"sha": "dafa9c545a2cdd00fcab4e2c55f75609d4ce6493", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61f71b34471e03254cdadd61f1418f425101273f/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61f71b34471e03254cdadd61f1418f425101273f/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=61f71b34471e03254cdadd61f1418f425101273f", "patch": "@@ -1,3 +1,7 @@\n+2003-09-03  DJ Delorie  <dj@redhat.com>\n+\n+\t* decl.c (finish_function): Pass fndecl to aggregate_value_p.\n+\n 2003-09-03  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/12053"}, {"sha": "1575ec4dbf110625e37abe5a7e08b2c6604e351b", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61f71b34471e03254cdadd61f1418f425101273f/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61f71b34471e03254cdadd61f1418f425101273f/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=61f71b34471e03254cdadd61f1418f425101273f", "patch": "@@ -14118,7 +14118,7 @@ finish_function (int flags)\n       if (r != error_mark_node\n \t  /* This is only worth doing for fns that return in memory--and\n \t     simpler, since we don't have to worry about promoted modes.  */\n-\t  && aggregate_value_p (TREE_TYPE (TREE_TYPE (fndecl)))\n+\t  && aggregate_value_p (TREE_TYPE (TREE_TYPE (fndecl)), fndecl)\n \t  /* Only allow this for variables declared in the outer scope of\n \t     the function so we know that their lifetime always ends with a\n \t     return; see g++.dg/opt/nrv6.C.  We could be more flexible if"}, {"sha": "ef49a688033453a2127fb1db01db11feae4fdc2c", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 87, "deletions": 99, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61f71b34471e03254cdadd61f1418f425101273f/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61f71b34471e03254cdadd61f1418f425101273f/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=61f71b34471e03254cdadd61f1418f425101273f", "patch": "@@ -1058,24 +1058,25 @@ sign-extend the result to 64 bits.  On such machines, set\n Do not define this macro if it would never modify @var{m}.\n @end defmac\n \n-@defmac PROMOTE_FUNCTION_ARGS\n-Define this macro if the promotion described by @code{PROMOTE_MODE}\n-should also be done for outgoing function arguments.\n-@end defmac\n+@deftypefn {Target Hook} bool TARGET_PROMOTE_FUNCTION_ARGS (tree @var{fntype})\n+This target hook should return @code{true} if the promotion described by\n+@code{PROMOTE_MODE} should also be done for outgoing function arguments.\n+@end deftypefn\n \n-@defmac PROMOTE_FUNCTION_RETURN\n-Define this macro if the promotion described by @code{PROMOTE_MODE}\n-should also be done for the return value of functions.\n+@deftypefn {Target Hook} bool TARGET_PROMOTE_FUNCTION_RETURN (tree @var{fntype})\n+This target hook should return @code{true} if the promotion described by\n+@code{PROMOTE_MODE} should also be done for the return value of\n+functions.\n \n-If this macro is defined, @code{FUNCTION_VALUE} must perform the same\n-promotions done by @code{PROMOTE_MODE}.\n-@end defmac\n+If this target hook returns @code{true}, @code{FUNCTION_VALUE} must\n+perform the same promotions done by @code{PROMOTE_MODE}.\n+@end deftypefn\n \n @defmac PROMOTE_FOR_CALL_ONLY\n Define this macro if the promotion described by @code{PROMOTE_MODE}\n should @emph{only} be performed for outgoing function arguments or\n-function return values, as specified by @code{PROMOTE_FUNCTION_ARGS}\n-and @code{PROMOTE_FUNCTION_RETURN}, respectively.\n+function return values, as specified by @code{TARGET_PROMOTE_FUNCTION_ARGS}\n+and @code{TARGET_PROMOTE_FUNCTION_RETURN}, respectively.\n @end defmac\n \n @defmac PARM_BOUNDARY\n@@ -3353,14 +3354,13 @@ The macros in this section control how arguments are passed\n on the stack.  See the following section for other macros that\n control passing certain arguments in registers.\n \n-@defmac PROMOTE_PROTOTYPES\n-A C expression whose value is nonzero if an argument declared in\n-a prototype as an integral type smaller than @code{int} should\n-actually be passed as an @code{int}.  In addition to avoiding\n-errors in certain cases of mismatch, it also makes for better\n-code on certain machines.  If the macro is not defined in target\n-header files, it defaults to 0.\n-@end defmac\n+@deftypefn {Target Hook} bool TARGET_PROMOTE_PROTOTYPES (tree @var{fntype})\n+This target hook returns @code{true} if an argument declared in a\n+prototype as an integral type smaller than @code{int} should actually be\n+passed as an @code{int}.  In addition to avoiding errors in certain\n+cases of mismatch, it also makes for better code on certain machines.\n+The default is to not promote prototypes.\n+@end deftypefn\n \n @defmac PUSH_ARGS\n A C expression.  If nonzero, push insns will be used to pass\n@@ -3819,7 +3819,7 @@ register where the return value is stored.  The value can also be a\n @code{parallel} RTX, if the return value is in multiple places.  See\n @code{FUNCTION_ARG} for an explanation of the @code{parallel} form.\n \n-If @code{PROMOTE_FUNCTION_RETURN} is defined, you must apply the same\n+If @code{TARGET_PROMOTE_FUNCTION_RETURN} is defined, you must apply the same\n promotion rules specified in @code{PROMOTE_MODE} if @var{valtype} is a\n scalar type.\n \n@@ -3910,24 +3910,24 @@ is called the @dfn{structure value address}.\n This section describes how to control returning structure values in\n memory.\n \n-@defmac RETURN_IN_MEMORY (@var{type})\n-A C expression which can inhibit the returning of certain function\n-values in registers, based on the type of value.  A nonzero value says\n-to return the function value in memory, just as large structures are\n-always returned.  Here @var{type} will be a C expression of type\n-@code{tree}, representing the data type of the value.\n+@deftypefn {Target Hook} bool RETURN_IN_MEMORY (tree @var{type}, tree @var{fntype})\n+This target hook should return a nonzero value to say to return the\n+function value in memory, just as large structures are always returned.\n+Here @var{type} will be the data type of the value, and @var{fntype}\n+will be the type of the function doing the returning, or @code{NULL} for\n+libcalls.\n \n Note that values of mode @code{BLKmode} must be explicitly handled\n-by this macro.  Also, the option @option{-fpcc-struct-return}\n+by this function.  Also, the option @option{-fpcc-struct-return}\n takes effect regardless of this macro.  On most systems, it is\n-possible to leave the macro undefined; this causes a default\n+possible to leave the hook undefined; this causes a default\n definition to be used, whose value is the constant 1 for @code{BLKmode}\n values, and 0 otherwise.\n \n-Do not use this macro to indicate that structures and unions should always\n+Do not use this hook to indicate that structures and unions should always\n be returned in memory.  You should instead use @code{DEFAULT_PCC_STRUCT_RETURN}\n to indicate this.\n-@end defmac\n+@end deftypefn\n \n @defmac DEFAULT_PCC_STRUCT_RETURN\n Define this macro to be 1 if all structure and union return values must be\n@@ -3939,36 +3939,23 @@ and union return values are decided by the @code{RETURN_IN_MEMORY} macro.\n If not defined, this defaults to the value 1.\n @end defmac\n \n-@defmac STRUCT_VALUE_REGNUM\n-If the structure value address is passed in a register, then\n-@code{STRUCT_VALUE_REGNUM} should be the number of that register.\n-@end defmac\n-\n-@defmac STRUCT_VALUE\n-If the structure value address is not passed in a register, define\n-@code{STRUCT_VALUE} as an expression returning an RTX for the place\n-where the address is passed.  If it returns 0, the address is passed as\n-an ``invisible'' first argument.\n-@end defmac\n+@deftypefn {Target Hook} rtx TARGET_STRUCT_VALUE_RTX (tree @var{fndecl}, int @var{incoming})\n+This target hook should return the location of the structure value\n+address (normally a @code{mem} or @code{reg}), or 0 if the address is\n+passed as an ``invisible'' first argument.  Note that @var{fndecl} may\n+be @code{NULL}, for libcalls.\n \n-@defmac STRUCT_VALUE_INCOMING_REGNUM\n On some architectures the place where the structure value address\n is found by the called function is not the same place that the\n caller put it.  This can be due to register windows, or it could\n be because the function prologue moves it to a different place.\n+@var{incoming} is @code{true} when the location is needed in\n+the context of the called function, and @code{false} in the context of\n+the caller.\n \n-If the incoming location of the structure value address is in a\n-register, define this macro as the register number.\n-@end defmac\n-\n-@defmac STRUCT_VALUE_INCOMING\n-If the incoming location is not a register, then you should define\n-@code{STRUCT_VALUE_INCOMING} as an expression for an RTX for where the\n-called function should find the value.  If it should find the value on\n-the stack, define this to create a @code{mem} which refers to the frame\n-pointer.  A definition of 0 means that the address is passed as an\n-``invisible'' first argument.\n-@end defmac\n+If @var{incoming} is @code{true} and the address is to be found on the\n+stack, return a @code{mem} which refers to the frame pointer.\n+@end deftypefn\n \n @defmac PCC_STATIC_STRUCT_RETURN\n Define this macro if the usual system convention on the target machine\n@@ -4428,70 +4415,71 @@ interpret the values of @code{__builtin_classify_type}.\n \n These machine description macros help implement varargs:\n \n-@defmac EXPAND_BUILTIN_SAVEREGS ()\n-If defined, is a C expression that produces the machine-specific code\n-for a call to @code{__builtin_saveregs}.  This code will be moved to the\n-very beginning of the function, before any parameter access are made.\n-The return value of this function should be an RTX that contains the\n-value to use as the return of @code{__builtin_saveregs}.\n-@end defmac\n+@deftypefn {Target Hook} rtx TARGET_EXPAND_BUILTIN_SAVEREGS (void)\n+If defined, this hook produces the machine-specific code for a call to\n+@code{__builtin_saveregs}.  This code will be moved to the very\n+beginning of the function, before any parameter access are made.  The\n+return value of this function should be an RTX that contains the value\n+to use as the return of @code{__builtin_saveregs}.\n+@end deftypefn\n \n-@defmac SETUP_INCOMING_VARARGS (@var{args_so_far}, @var{mode}, @var{type}, @var{pretend_args_size}, @var{second_time})\n-This macro offers an alternative to using @code{__builtin_saveregs} and\n-defining the macro @code{EXPAND_BUILTIN_SAVEREGS}.  Use it to store the\n-anonymous register arguments into the stack so that all the arguments\n-appear to have been passed consecutively on the stack.  Once this is\n-done, you can use the standard implementation of varargs that works for\n-machines that pass all their arguments on the stack.\n+@deftypefn {Target Hook} void TARGET_SETUP_INCOMING_VARARGS (CUMULATIVE_ARGS *@var{args_so_far}, enum machine_mode @var{mode}, tree @var{type}, int *@var{pretend_args_size}, int @var{second_time})\n+This target hook offers an alternative to using\n+@code{__builtin_saveregs} and defining the hook\n+@code{TARGET_EXPAND_BUILTIN_SAVEREGS}.  Use it to store the anonymous\n+register arguments into the stack so that all the arguments appear to\n+have been passed consecutively on the stack.  Once this is done, you can\n+use the standard implementation of varargs that works for machines that\n+pass all their arguments on the stack.\n \n-The argument @var{args_so_far} is the @code{CUMULATIVE_ARGS} data\n+The argument @var{args_so_far} points to the @code{CUMULATIVE_ARGS} data\n structure, containing the values that are obtained after processing the\n named arguments.  The arguments @var{mode} and @var{type} describe the\n last named argument---its machine mode and its data type as a tree node.\n \n-The macro implementation should do two things: first, push onto the\n-stack all the argument registers @emph{not} used for the named\n-arguments, and second, store the size of the data thus pushed into the\n-@code{int}-valued variable whose name is supplied as the argument\n-@var{pretend_args_size}.  The value that you store here will serve as\n-additional offset for setting up the stack frame.\n+The target hook should do two things: first, push onto the stack all the\n+argument registers @emph{not} used for the named arguments, and second,\n+store the size of the data thus pushed into the @code{int}-valued\n+variable pointed to by @var{pretend_args_size}.  The value that you\n+store here will serve as additional offset for setting up the stack\n+frame.\n \n Because you must generate code to push the anonymous arguments at\n compile time without knowing their data types,\n-@code{SETUP_INCOMING_VARARGS} is only useful on machines that have just\n-a single category of argument register and use it uniformly for all data\n-types.\n+@code{TARGET_SETUP_INCOMING_VARARGS} is only useful on machines that\n+have just a single category of argument register and use it uniformly\n+for all data types.\n \n If the argument @var{second_time} is nonzero, it means that the\n arguments of the function are being analyzed for the second time.  This\n happens for an inline function, which is not actually compiled until the\n-end of the source file.  The macro @code{SETUP_INCOMING_VARARGS} should\n+end of the source file.  The hook @code{TARGET_SETUP_INCOMING_VARARGS} should\n not generate any instructions in this case.\n-@end defmac\n+@end deftypefn\n \n-@defmac STRICT_ARGUMENT_NAMING\n-Define this macro to be a nonzero value if the location where a function\n+@deftypefn {Target Hook} bool TARGET_STRICT_ARGUMENT_NAMING (CUMULATIVE_ARGS *@var{ca})\n+Define this hook to return @code{true} if the location where a function\n argument is passed depends on whether or not it is a named argument.\n \n-This macro controls how the @var{named} argument to @code{FUNCTION_ARG}\n-is set for varargs and stdarg functions.  If this macro returns a\n-nonzero value, the @var{named} argument is always true for named\n-arguments, and false for unnamed arguments.  If it returns a value of\n-zero, but @code{SETUP_INCOMING_VARARGS} is defined, then all arguments\n-are treated as named.  Otherwise, all named arguments except the last\n-are treated as named.\n+This hook controls how the @var{named} argument to @code{FUNCTION_ARG}\n+is set for varargs and stdarg functions.  If this hook returns\n+@code{true}, the @var{named} argument is always true for named\n+arguments, and false for unnamed arguments.  If it returns @code{false},\n+but @code{TARGET_PRETEND_OUTOGOING_VARARGS_NAMED} returns @code{true},\n+then all arguments are treated as named.  Otherwise, all named arguments\n+except the last are treated as named.\n \n-You need not define this macro if it always returns zero.\n-@end defmac\n+You need not define this hook if it always returns zero.\n+@end deftypefn\n \n-@defmac PRETEND_OUTGOING_VARARGS_NAMED\n+@deftypefn {Target Hook} bool TARGET_PRETEND_OUTGOING_VARARGS_NAMED\n If you need to conditionally change ABIs so that one works with\n-@code{SETUP_INCOMING_VARARGS}, but the other works like neither\n-@code{SETUP_INCOMING_VARARGS} nor @code{STRICT_ARGUMENT_NAMING} was\n-defined, then define this macro to return nonzero if\n-@code{SETUP_INCOMING_VARARGS} is used, zero otherwise.\n-Otherwise, you should not define this macro.\n-@end defmac\n+@code{TARGET_SETUP_INCOMING_VARARGS}, but the other works like neither\n+@code{TARGET_SETUP_INCOMING_VARARGS} nor @code{TARGET_STRICT_ARGUMENT_NAMING} was\n+defined, then define this hook to return @code{true} if\n+@code{SETUP_INCOMING_VARARGS} is used, @code{false} otherwise.\n+Otherwise, you should not define this hook.\n+@end deftypefn\n \n @node Trampolines\n @section Trampolines for Nested Functions"}, {"sha": "0668cfb20e4e39663fd4028d7a66b63f2cb76227", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61f71b34471e03254cdadd61f1418f425101273f/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61f71b34471e03254cdadd61f1418f425101273f/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=61f71b34471e03254cdadd61f1418f425101273f", "patch": "@@ -132,8 +132,6 @@ REAL_VALUE_TYPE dconsthalf;\n \n    In an inline procedure, the stack and frame pointer rtxs may not be\n    used for anything else.  */\n-rtx struct_value_rtx;\t\t/* (REG:Pmode STRUCT_VALUE_REGNUM) */\n-rtx struct_value_incoming_rtx;\t/* (REG:Pmode STRUCT_VALUE_INCOMING_REGNUM) */\n rtx static_chain_rtx;\t\t/* (REG:Pmode STATIC_CHAIN_REGNUM) */\n rtx static_chain_incoming_rtx;\t/* (REG:Pmode STATIC_CHAIN_INCOMING_REGNUM) */\n rtx pic_offset_table_rtx;\t/* (REG:Pmode PIC_OFFSET_TABLE_REGNUM) */\n@@ -5467,23 +5465,6 @@ init_emit_once (int line_numbers)\n     = gen_raw_REG (Pmode, RETURN_ADDRESS_POINTER_REGNUM);\n #endif\n \n-#ifdef STRUCT_VALUE\n-  struct_value_rtx = STRUCT_VALUE;\n-#else\n-  struct_value_rtx = gen_rtx_REG (Pmode, STRUCT_VALUE_REGNUM);\n-#endif\n-\n-#ifdef STRUCT_VALUE_INCOMING\n-  struct_value_incoming_rtx = STRUCT_VALUE_INCOMING;\n-#else\n-#ifdef STRUCT_VALUE_INCOMING_REGNUM\n-  struct_value_incoming_rtx\n-    = gen_rtx_REG (Pmode, STRUCT_VALUE_INCOMING_REGNUM);\n-#else\n-  struct_value_incoming_rtx = struct_value_rtx;\n-#endif\n-#endif\n-\n #ifdef STATIC_CHAIN_REGNUM\n   static_chain_rtx = gen_rtx_REG (Pmode, STATIC_CHAIN_REGNUM);\n "}, {"sha": "eb25fed8a4a5ed8b2412b547ca239f11fa91123b", "filename": "gcc/expr.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61f71b34471e03254cdadd61f1418f425101273f/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61f71b34471e03254cdadd61f1418f425101273f/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=61f71b34471e03254cdadd61f1418f425101273f", "patch": "@@ -4273,7 +4273,7 @@ expand_assignment (tree to, tree from, int want_value)\n      since it might be a promoted variable where the zero- or sign- extension\n      needs to be done.  Handling this in the normal way is safe because no\n      computation is done before the call.  */\n-  if (TREE_CODE (from) == CALL_EXPR && ! aggregate_value_p (from)\n+  if (TREE_CODE (from) == CALL_EXPR && ! aggregate_value_p (from, from)\n       && TREE_CODE (TYPE_SIZE (TREE_TYPE (from))) == INTEGER_CST\n       && ! ((TREE_CODE (to) == VAR_DECL || TREE_CODE (to) == PARM_DECL)\n \t    && GET_CODE (DECL_RTL (to)) == REG))\n@@ -6704,7 +6704,7 @@ expand_expr (tree exp, rtx target, enum machine_mode tmode, enum expand_modifier\n   if (! cse_not_expected && mode != BLKmode && target\n       && (GET_CODE (target) != REG || REGNO (target) < FIRST_PSEUDO_REGISTER)\n       && ! (code == CONSTRUCTOR && GET_MODE_SIZE (mode) > UNITS_PER_WORD)\n-      && ! (code == CALL_EXPR && aggregate_value_p (exp)))\n+      && ! (code == CALL_EXPR && aggregate_value_p (exp, exp)))\n     target = 0;\n \n   switch (code)"}, {"sha": "aa9936e1555fc80e5a29fb9d59b05e73c33d757c", "filename": "gcc/expr.h", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61f71b34471e03254cdadd61f1418f425101273f/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61f71b34471e03254cdadd61f1418f425101273f/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=61f71b34471e03254cdadd61f1418f425101273f", "patch": "@@ -169,35 +169,12 @@ do {\t\t\t\t\t\t\t\\\n tree split_complex_types (tree);\n tree split_complex_values (tree);\n \n-/* Provide a default value for STRICT_ARGUMENT_NAMING.  */\n-#ifndef STRICT_ARGUMENT_NAMING\n-#define STRICT_ARGUMENT_NAMING 0\n-#endif\n-\n-/* Provide a default value for PRETEND_OUTGOING_VARARGS_NAMED.  */\n-#ifdef SETUP_INCOMING_VARARGS\n-#ifndef PRETEND_OUTGOING_VARARGS_NAMED\n-#define PRETEND_OUTGOING_VARARGS_NAMED 1\n-#endif\n-#else\n-/* It is an error to define PRETEND_OUTGOING_VARARGS_NAMED without\n-   defining SETUP_INCOMING_VARARGS.  */\n-#define PRETEND_OUTGOING_VARARGS_NAMED 0\n-#endif\n-\n /* Nonzero if we do not know how to pass TYPE solely in registers.  */\n extern bool default_must_pass_in_stack (enum machine_mode, tree);\n #ifndef MUST_PASS_IN_STACK\n #define MUST_PASS_IN_STACK(MODE,TYPE) default_must_pass_in_stack(MODE, TYPE)\n #endif\n \n-/* Nonzero if type TYPE should be returned in memory.\n-   Most machines can use the following default definition.  */\n-\n-#ifndef RETURN_IN_MEMORY\n-#define RETURN_IN_MEMORY(TYPE) (TYPE_MODE (TYPE) == BLKmode)\n-#endif\n-\n /* Supply a default definition of STACK_SAVEAREA_MODE for emit_stack_save.\n    Normally move_insn, so Pmode stack pointer.  */\n "}, {"sha": "6ee13a604f8e67f3037343fc5c4be267f2ceb814", "filename": "gcc/final.c", "status": "modified", "additions": 7, "deletions": 22, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61f71b34471e03254cdadd61f1418f425101273f/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61f71b34471e03254cdadd61f1418f425101273f/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=61f71b34471e03254cdadd61f1418f425101273f", "patch": "@@ -1418,9 +1418,8 @@ profile_function (FILE *file ATTRIBUTE_UNUSED)\n # define NO_PROFILE_COUNTERS\t0\n #endif\n #if defined(ASM_OUTPUT_REG_PUSH)\n-#if defined(STRUCT_VALUE_INCOMING_REGNUM) || defined(STRUCT_VALUE_REGNUM)\n   int sval = current_function_returns_struct;\n-#endif\n+  rtx svrtx = targetm.calls.struct_value_rtx (TREE_TYPE (current_function_decl), 1);\n #if defined(STATIC_CHAIN_INCOMING_REGNUM) || defined(STATIC_CHAIN_REGNUM)\n   int cxt = current_function_needs_context;\n #endif\n@@ -1437,16 +1436,9 @@ profile_function (FILE *file ATTRIBUTE_UNUSED)\n \n   function_section (current_function_decl);\n \n-#if defined(STRUCT_VALUE_INCOMING_REGNUM) && defined(ASM_OUTPUT_REG_PUSH)\n-  if (sval)\n-    ASM_OUTPUT_REG_PUSH (file, STRUCT_VALUE_INCOMING_REGNUM);\n-#else\n-#if defined(STRUCT_VALUE_REGNUM) && defined(ASM_OUTPUT_REG_PUSH)\n-  if (sval)\n-    {\n-      ASM_OUTPUT_REG_PUSH (file, STRUCT_VALUE_REGNUM);\n-    }\n-#endif\n+#if defined(ASM_OUTPUT_REG_PUSH)\n+  if (sval && GET_CODE (svrtx) == REG)\n+    ASM_OUTPUT_REG_PUSH (file, REGNO (svrtx));\n #endif\n \n #if defined(STATIC_CHAIN_INCOMING_REGNUM) && defined(ASM_OUTPUT_REG_PUSH)\n@@ -1475,16 +1467,9 @@ profile_function (FILE *file ATTRIBUTE_UNUSED)\n #endif\n #endif\n \n-#if defined(STRUCT_VALUE_INCOMING_REGNUM) && defined(ASM_OUTPUT_REG_PUSH)\n-  if (sval)\n-    ASM_OUTPUT_REG_POP (file, STRUCT_VALUE_INCOMING_REGNUM);\n-#else\n-#if defined(STRUCT_VALUE_REGNUM) && defined(ASM_OUTPUT_REG_PUSH)\n-  if (sval)\n-    {\n-      ASM_OUTPUT_REG_POP (file, STRUCT_VALUE_REGNUM);\n-    }\n-#endif\n+#if defined(ASM_OUTPUT_REG_PUSH)\n+  if (sval && GET_CODE (svrtx) == REG)\n+    ASM_OUTPUT_REG_POP (file, REGNO (svrtx));\n #endif\n }\n "}, {"sha": "8227139d256a480cbc2b778f8a5411051ddd0c87", "filename": "gcc/function.c", "status": "modified", "additions": 46, "deletions": 28, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61f71b34471e03254cdadd61f1418f425101273f/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61f71b34471e03254cdadd61f1418f425101273f/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=61f71b34471e03254cdadd61f1418f425101273f", "patch": "@@ -62,6 +62,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"tm_p.h\"\n #include \"integrate.h\"\n #include \"langhooks.h\"\n+#include \"target.h\"\n \n #ifndef TRAMPOLINE_ALIGNMENT\n #define TRAMPOLINE_ALIGNMENT FUNCTION_BOUNDARY\n@@ -4177,16 +4178,37 @@ get_first_nonparm_insn (void)\n    EXP may be a type node or an expression (whose type is tested).  */\n \n int\n-aggregate_value_p (tree exp)\n+aggregate_value_p (tree exp, tree fntype)\n {\n   int i, regno, nregs;\n   rtx reg;\n \n   tree type = (TYPE_P (exp)) ? exp : TREE_TYPE (exp);\n \n+  if (fntype)\n+    switch (TREE_CODE (fntype))\n+      {\n+      case CALL_EXPR:\n+\tfntype = get_callee_fndecl (fntype);\n+\tfntype = fntype ? TREE_TYPE (fntype) : 0;\n+\tbreak;\n+      case FUNCTION_DECL:\n+\tfntype = TREE_TYPE (fntype);\n+\tbreak;\n+      case FUNCTION_TYPE:\n+      case METHOD_TYPE:\n+        break;\n+      case IDENTIFIER_NODE:\n+\tfntype = 0;\n+\tbreak;\n+      default:\n+\t/* We don't expect other rtl types here.  */\n+\tabort();\n+      }\n+\n   if (TREE_CODE (type) == VOID_TYPE)\n     return 0;\n-  if (RETURN_IN_MEMORY (type))\n+  if (targetm.calls.return_in_memory (type, fntype))\n     return 1;\n   /* Types that are TREE_ADDRESSABLE must be constructed in memory,\n      and thus can't be returned in registers.  */\n@@ -4230,9 +4252,7 @@ assign_parms (tree fndecl)\n   /* This is a dummy PARM_DECL that we used for the function result if\n      the function returns a structure.  */\n   tree function_result_decl = 0;\n-#ifdef SETUP_INCOMING_VARARGS\n   int varargs_setup = 0;\n-#endif\n   int reg_parm_stack_space = 0;\n   rtx conversion_insns = 0;\n \n@@ -4265,9 +4285,9 @@ assign_parms (tree fndecl)\n   stack_args_size.var = 0;\n \n   /* If struct value address is treated as the first argument, make it so.  */\n-  if (aggregate_value_p (DECL_RESULT (fndecl))\n+  if (aggregate_value_p (DECL_RESULT (fndecl), fndecl)\n       && ! current_function_returns_pcc_struct\n-      && struct_value_incoming_rtx == 0)\n+      && targetm.calls.struct_value_rtx (TREE_TYPE (fndecl), 1) == 0)\n     {\n       tree type = build_pointer_type (TREE_TYPE (fntype));\n \n@@ -4336,7 +4356,7 @@ assign_parms (tree fndecl)\n       /* Set NAMED_ARG if this arg should be treated as a named arg.  For\n \t most machines, if this is a varargs/stdarg function, then we treat\n \t the last named arg as if it were anonymous too.  */\n-      named_arg = STRICT_ARGUMENT_NAMING ? 1 : ! last_named;\n+      named_arg = targetm.calls.strict_argument_naming (&args_so_far) ? 1 : ! last_named;\n \n       if (TREE_TYPE (parm) == error_mark_node\n \t  /* This can happen after weird syntax errors\n@@ -4401,11 +4421,12 @@ assign_parms (tree fndecl)\n \n       promoted_mode = passed_mode;\n \n-#ifdef PROMOTE_FUNCTION_ARGS\n-      /* Compute the mode in which the arg is actually extended to.  */\n-      unsignedp = TREE_UNSIGNED (passed_type);\n-      promoted_mode = promote_mode (passed_type, promoted_mode, &unsignedp, 1);\n-#endif\n+      if (targetm.calls.promote_function_args (TREE_TYPE (fndecl)))\n+\t{\n+\t  /* Compute the mode in which the arg is actually extended to.  */\n+\t  unsignedp = TREE_UNSIGNED (passed_type);\n+\t  promoted_mode = promote_mode (passed_type, promoted_mode, &unsignedp, 1);\n+\t}\n \n       /* Let machine desc say which reg (if any) the parm arrives in.\n \t 0 means it arrives on the stack.  */\n@@ -4420,7 +4441,6 @@ assign_parms (tree fndecl)\n       if (entry_parm == 0)\n \tpromoted_mode = passed_mode;\n \n-#ifdef SETUP_INCOMING_VARARGS\n       /* If this is the last named parameter, do any required setup for\n \t varargs or stdargs.  We need to know about the case of this being an\n \t addressable type, in which case we skip the registers it\n@@ -4433,11 +4453,11 @@ assign_parms (tree fndecl)\n \t Also, indicate when RTL generation is to be suppressed.  */\n       if (last_named && !varargs_setup)\n \t{\n-\t  SETUP_INCOMING_VARARGS (args_so_far, promoted_mode, passed_type,\n-\t\t\t\t  current_function_pretend_args_size, 0);\n+\t  targetm.calls.setup_incoming_varargs (&args_so_far, promoted_mode,\n+\t\t\t\t\t\t  passed_type,\n+\t\t\t\t\t\t  &current_function_pretend_args_size, 0);\n \t  varargs_setup = 1;\n \t}\n-#endif\n \n       /* Determine parm's home in the stack,\n \t in case it arrives in the stack or we should pretend it did.\n@@ -4457,7 +4477,8 @@ assign_parms (tree fndecl)\n #endif\n       if (!in_regs && !named_arg)\n \t{\n-\t  int pretend_named = PRETEND_OUTGOING_VARARGS_NAMED;\n+\t  int pretend_named =\n+\t    targetm.calls.pretend_outgoing_varargs_named (&args_so_far);\n \t  if (pretend_named)\n \t    {\n #ifdef FUNCTION_INCOMING_ARG\n@@ -5275,8 +5296,6 @@ split_complex_args (tree args)\n    that REGNO is promoted from and whether the promotion was signed or\n    unsigned.  */\n \n-#ifdef PROMOTE_FUNCTION_ARGS\n-\n rtx\n promoted_input_arg (unsigned int regno, enum machine_mode *pmode, int *punsignedp)\n {\n@@ -5304,7 +5323,6 @@ promoted_input_arg (unsigned int regno, enum machine_mode *pmode, int *punsigned\n   return 0;\n }\n \n-#endif\n \f\n /* Compute the size and offset from the start of the stacked arguments for a\n    parm passed in mode PASSED_MODE and with type TYPE.\n@@ -6284,7 +6302,7 @@ allocate_struct_function (tree fndecl)\n   current_function_name = (*lang_hooks.decl_printable_name) (fndecl, 2);\n \n   result = DECL_RESULT (fndecl);\n-  if (aggregate_value_p (result))\n+  if (aggregate_value_p (result, fndecl))\n     {\n #ifdef PCC_STATIC_STRUCT_RETURN\n       current_function_returns_pcc_struct = 1;\n@@ -6515,7 +6533,7 @@ expand_function_start (tree subr, int parms_have_cleanups)\n      before any library calls that assign parms might generate.  */\n \n   /* Decide whether to return the value in memory or in a register.  */\n-  if (aggregate_value_p (DECL_RESULT (subr)))\n+  if (aggregate_value_p (DECL_RESULT (subr), subr))\n     {\n       /* Returning something that won't go in a register.  */\n       rtx value_address = 0;\n@@ -6529,13 +6547,14 @@ expand_function_start (tree subr, int parms_have_cleanups)\n       else\n #endif\n \t{\n+\t  rtx sv = targetm.calls.struct_value_rtx (TREE_TYPE (subr), 1);\n \t  /* Expect to be passed the address of a place to store the value.\n \t     If it is passed as an argument, assign_parms will take care of\n \t     it.  */\n-\t  if (struct_value_incoming_rtx)\n+\t  if (sv)\n \t    {\n \t      value_address = gen_reg_rtx (Pmode);\n-\t      emit_move_insn (value_address, struct_value_incoming_rtx);\n+\t      emit_move_insn (value_address, sv);\n \t    }\n \t}\n       if (value_address)\n@@ -6973,10 +6992,9 @@ expand_function_end (void)\n \t    {\n \t      int unsignedp = TREE_UNSIGNED (TREE_TYPE (decl_result));\n \n-#ifdef PROMOTE_FUNCTION_RETURN\n-\t      promote_mode (TREE_TYPE (decl_result), GET_MODE (decl_rtl),\n-\t\t\t    &unsignedp, 1);\n-#endif\n+\t      if (targetm.calls.promote_function_return (TREE_TYPE (current_function_decl)))\n+\t\tpromote_mode (TREE_TYPE (decl_result), GET_MODE (decl_rtl),\n+\t\t\t      &unsignedp, 1);\n \n \t      convert_move (real_decl_rtl, decl_rtl, unsignedp);\n \t    }"}, {"sha": "a770180e3868c7320c6c850ee1920083af8ba1fb", "filename": "gcc/hard-reg-set.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61f71b34471e03254cdadd61f1418f425101273f/gcc%2Fhard-reg-set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61f71b34471e03254cdadd61f1418f425101273f/gcc%2Fhard-reg-set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhard-reg-set.h?ref=61f71b34471e03254cdadd61f1418f425101273f", "patch": "@@ -1,5 +1,5 @@\n /* Sets (bit vectors) of hard registers, and operations on them.\n-   Copyright (C) 1987, 1992, 1994, 2000 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 1992, 1994, 2000, 2003 Free Software Foundation, Inc.\n \n This file is part of GCC\n \n@@ -418,7 +418,7 @@ extern HARD_REG_SET losing_caller_save_reg_set;\n \n /* Indexed by hard register number, contains 1 for registers that are\n    fixed use -- i.e. in fixed_regs -- or a function value return register\n-   or STRUCT_VALUE_REGNUM or STATIC_CHAIN_REGNUM.  These are the\n+   or TARGET_STRUCT_VALUE_RTX or STATIC_CHAIN_REGNUM.  These are the\n    registers that cannot hold quantities across calls even if we are\n    willing to save and restore them.  */\n "}, {"sha": "f0abe89f3e24c35ec6e196ac7982da6ad80e94f2", "filename": "gcc/integrate.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61f71b34471e03254cdadd61f1418f425101273f/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61f71b34471e03254cdadd61f1418f425101273f/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=61f71b34471e03254cdadd61f1418f425101273f", "patch": "@@ -1028,7 +1028,7 @@ expand_inline_function (tree fndecl, tree parms, rtx target, int ignore,\n       else\n \t{\n \t  if (! structure_value_addr\n-\t      || ! aggregate_value_p (DECL_RESULT (fndecl)))\n+\t      || ! aggregate_value_p (DECL_RESULT (fndecl), fndecl))\n \t    abort ();\n \n \t  /* Pass the function the address in which to return a structure\n@@ -1283,7 +1283,7 @@ expand_inline_function (tree fndecl, tree parms, rtx target, int ignore,\n      out of the temp register into a BLKmode memory object.  */\n   if (target\n       && TYPE_MODE (TREE_TYPE (TREE_TYPE (fndecl))) == BLKmode\n-      && ! aggregate_value_p (TREE_TYPE (TREE_TYPE (fndecl))))\n+      && ! aggregate_value_p (TREE_TYPE (TREE_TYPE (fndecl)), fndecl))\n     target = copy_blkmode_from_reg (0, target, TREE_TYPE (TREE_TYPE (fndecl)));\n \n   if (structure_value_addr)"}, {"sha": "10cc88912fca972e10e7ca2c8b7eb8e2993d1438", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61f71b34471e03254cdadd61f1418f425101273f/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61f71b34471e03254cdadd61f1418f425101273f/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=61f71b34471e03254cdadd61f1418f425101273f", "patch": "@@ -406,7 +406,7 @@ generate_struct_by_value_array ()\n \t}\n       finish_struct (type, field_decl_chain, NULL_TREE);\n  \n-      aggregate_in_mem[i] = aggregate_value_p (type);\n+      aggregate_in_mem[i] = aggregate_value_p (type, 0);\n       if (!aggregate_in_mem[i])\n \tfound = 1;\n     }"}, {"sha": "fd707e21e8305c48330542ea8f8c86e2221334fd", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61f71b34471e03254cdadd61f1418f425101273f/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61f71b34471e03254cdadd61f1418f425101273f/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=61f71b34471e03254cdadd61f1418f425101273f", "patch": "@@ -802,7 +802,7 @@ stack_result (tree decl)\n \n   /* If the value is supposed to be returned in memory, then clearly\n      it is not returned in a stack register.  */\n-  if (aggregate_value_p (DECL_RESULT (decl)))\n+  if (aggregate_value_p (DECL_RESULT (decl), decl))\n     return 0;\n \n   result = DECL_RTL_IF_SET (DECL_RESULT (decl));"}, {"sha": "b7db32adeede874492eaeda0e0734918674b08b7", "filename": "gcc/rtl.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61f71b34471e03254cdadd61f1418f425101273f/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61f71b34471e03254cdadd61f1418f425101273f/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=61f71b34471e03254cdadd61f1418f425101273f", "patch": "@@ -1816,8 +1816,6 @@ extern GTY(()) rtx global_rtl[GR_MAX];\n #define arg_pointer_rtx\t\t(global_rtl[GR_ARG_POINTER])\n \n extern GTY(()) rtx pic_offset_table_rtx;\n-extern GTY(()) rtx struct_value_rtx;\n-extern GTY(()) rtx struct_value_incoming_rtx;\n extern GTY(()) rtx static_chain_rtx;\n extern GTY(()) rtx static_chain_incoming_rtx;\n extern GTY(()) rtx return_address_pointer_rtx;"}, {"sha": "b62f83eccb36b2de1848de5b94c0d55807ac2528", "filename": "gcc/stmt.c", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61f71b34471e03254cdadd61f1418f425101273f/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61f71b34471e03254cdadd61f1418f425101273f/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=61f71b34471e03254cdadd61f1418f425101273f", "patch": "@@ -57,6 +57,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"langhooks.h\"\n #include \"predict.h\"\n #include \"optabs.h\"\n+#include \"target.h\"\n \n /* Assume that case vectors are not pc-relative.  */\n #ifndef CASE_VECTOR_PC_RELATIVE\n@@ -2937,16 +2938,17 @@ expand_value_return (rtx val)\n   if (return_reg != val)\n     {\n       tree type = TREE_TYPE (DECL_RESULT (current_function_decl));\n-#ifdef PROMOTE_FUNCTION_RETURN\n-      int unsignedp = TREE_UNSIGNED (type);\n-      enum machine_mode old_mode\n-\t= DECL_MODE (DECL_RESULT (current_function_decl));\n-      enum machine_mode mode\n-\t= promote_mode (type, old_mode, &unsignedp, 1);\n-\n-      if (mode != old_mode)\n-\tval = convert_modes (mode, old_mode, val, unsignedp);\n-#endif\n+      if (targetm.calls.promote_function_return (TREE_TYPE (current_function_decl)))\n+      {\n+\tint unsignedp = TREE_UNSIGNED (type);\n+\tenum machine_mode old_mode\n+\t  = DECL_MODE (DECL_RESULT (current_function_decl));\n+\tenum machine_mode mode\n+\t  = promote_mode (type, old_mode, &unsignedp, 1);\n+\n+\tif (mode != old_mode)\n+\t  val = convert_modes (mode, old_mode, val, unsignedp);\n+      }\n       if (GET_CODE (return_reg) == PARALLEL)\n \temit_group_load (return_reg, val, type, int_size_in_bytes (type));\n       else"}, {"sha": "d1a856983a54fc4f878137162cea7e2363c0154e", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61f71b34471e03254cdadd61f1418f425101273f/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61f71b34471e03254cdadd61f1418f425101273f/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=61f71b34471e03254cdadd61f1418f425101273f", "patch": "@@ -1093,6 +1093,7 @@ place_field (record_layout_info rli, tree field)\n \t\trli->prev_field = NULL;\n \t    }\n \n+\t  rli->offset_align = tree_low_cst (TYPE_SIZE (type), 0);\n \t  normalize_rli (rli);\n         }\n "}, {"sha": "da6003eff5c717f7d0024635faf5b757cbca39b0", "filename": "gcc/target-def.h", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61f71b34471e03254cdadd61f1418f425101273f/gcc%2Ftarget-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61f71b34471e03254cdadd61f1418f425101273f/gcc%2Ftarget-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-def.h?ref=61f71b34471e03254cdadd61f1418f425101273f", "patch": "@@ -305,6 +305,30 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n \n #define TARGET_MACHINE_DEPENDENT_REORG 0\n \n+#define TARGET_PROMOTE_FUNCTION_ARGS default_promote_function_args\n+#define TARGET_PROMOTE_FUNCTION_RETURN default_promote_function_return\n+#define TARGET_PROMOTE_PROTOTYPES default_promote_prototypes\n+\n+#define TARGET_STRUCT_VALUE_RTX default_struct_value_rtx\n+#define TARGET_RETURN_IN_MEMORY default_return_in_memory\n+\n+#define TARGET_EXPAND_BUILTIN_SAVEREGS default_expand_builtin_saveregs\n+#define TARGET_SETUP_INCOMING_VARARGS default_setup_incoming_varargs\n+#define TARGET_STRICT_ARGUMENT_NAMING default_strict_argument_naming\n+#define TARGET_PRETEND_OUTGOING_VARARGS_NAMED default_pretend_outgoing_varargs_named\n+\n+#define TARGET_CALLS {\t\t\t\t\t\t\\\n+   TARGET_PROMOTE_FUNCTION_ARGS,\t\t\t\t\\\n+   TARGET_PROMOTE_FUNCTION_RETURN,\t\t\t\t\\\n+   TARGET_PROMOTE_PROTOTYPES,\t\t\t\t\t\\\n+   TARGET_STRUCT_VALUE_RTX,\t\t\t\t\t\\\n+   TARGET_RETURN_IN_MEMORY,\t\t\t\t\t\\\n+   TARGET_EXPAND_BUILTIN_SAVEREGS,\t\t\t\t\\\n+   TARGET_SETUP_INCOMING_VARARGS,\t\t\t\t\\\n+   TARGET_STRICT_ARGUMENT_NAMING,\t\t\t\t\\\n+   TARGET_PRETEND_OUTGOING_VARARGS_NAMED,\t\t\t\\\n+   }\n+\n /* The whole shebang.  */\n #define TARGET_INITIALIZER\t\t\t\\\n {\t\t\t\t\t\t\\\n@@ -345,6 +369,8 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n   TARGET_TERMINATE_DW2_EH_FRAME_INFO,\t\t\\\n   TARGET_ASM_FILE_START_APP_OFF,\t\t\\\n   TARGET_ASM_FILE_START_FILE_DIRECTIVE,\t\t\\\n+  TARGET_CALLS,\t\t\t\t\t\\\n }\n \n #include \"hooks.h\"\n+#include \"targhooks.h\""}, {"sha": "3a7ea78af38cd25729125c6cec48d7887b1c762b", "filename": "gcc/target.h", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61f71b34471e03254cdadd61f1418f425101273f/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61f71b34471e03254cdadd61f1418f425101273f/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=61f71b34471e03254cdadd61f1418f425101273f", "patch": "@@ -386,6 +386,23 @@ struct gcc_target\n   /* True if output_file_directive should be called for main_input_filename\n      at the beginning of assembly output.  */\n   bool file_start_file_directive;\n+\n+  /* Functions relating to calls - argument passing, returns, etc.  */\n+  struct calls {\n+    bool (*promote_function_args) (tree fntype);\n+    bool (*promote_function_return) (tree fntype);\n+    bool (*promote_prototypes) (tree fntype);\n+    rtx (*struct_value_rtx) (tree fndecl, int incoming);\n+    bool (*return_in_memory) (tree type, tree fndecl);\n+    rtx (*expand_builtin_saveregs) (void);\n+    /* Returns pretend_argument_size.  */\n+    void (*setup_incoming_varargs) (CUMULATIVE_ARGS *ca, enum machine_mode mode,\n+\t\t\t\t    tree type, int *pretend_arg_size, int second_time);\n+    bool (*strict_argument_naming) (CUMULATIVE_ARGS *ca);\n+    /* Returns true if we should use SETUP_INCOMING_VARARGS and/or\n+       STRICT_ARGUMENT_NAMING. */\n+    bool (*pretend_outgoing_varargs_named) (CUMULATIVE_ARGS *ca);\n+  } calls;\n };\n \n extern struct gcc_target targetm;"}, {"sha": "943c5bd55c0b62a23a5bebf3ed8eefe24288c13a", "filename": "gcc/targhooks.c", "status": "added", "additions": 158, "deletions": 0, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61f71b34471e03254cdadd61f1418f425101273f/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61f71b34471e03254cdadd61f1418f425101273f/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=61f71b34471e03254cdadd61f1418f425101273f", "patch": "@@ -0,0 +1,158 @@\n+/* Default target hook functions.\n+   Copyright (C) 2003 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+02111-1307, USA.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"machmode.h\"\n+#include \"rtl.h\"\n+#include \"tree.h\"\n+#include \"expr.h\"\n+#include \"toplev.h\"\n+#include \"function.h\"\n+#include \"target.h\"\n+#include \"tm_p.h\"\n+#include \"target-def.h\"\n+\n+bool\n+default_promote_function_args (fntype)\n+     tree fntype ATTRIBUTE_UNUSED;\n+{\n+#ifdef PROMOTE_FUNCTION_ARGS\n+  return true;\n+#else\n+  return false;\n+#endif\n+}\n+\n+bool\n+default_promote_function_return (fntype)\n+     tree fntype ATTRIBUTE_UNUSED;\n+{\n+#ifdef PROMOTE_FUNCTION_RETURN\n+  return true;\n+#else\n+  return false;\n+#endif\n+}\n+\n+bool\n+default_promote_prototypes (fntype)\n+     tree fntype ATTRIBUTE_UNUSED;\n+{\n+  if (PROMOTE_PROTOTYPES)\n+    return true;\n+  else\n+    return false;\n+}\n+\n+rtx\n+default_struct_value_rtx (tree fntype ATTRIBUTE_UNUSED, int incoming)\n+{\n+  rtx rv = 0;\n+  if (incoming)\n+    {\n+#ifdef STRUCT_VALUE_INCOMING\n+      rv = STRUCT_VALUE_INCOMING;\n+#else\n+#ifdef STRUCT_VALUE_INCOMING_REGNUM\n+      rv = gen_rtx_REG (Pmode, STRUCT_VALUE_INCOMING_REGNUM);\n+#else\n+#ifdef STRUCT_VALUE\n+      rv = STRUCT_VALUE;\n+#else\n+#ifndef STRUCT_VALUE_REGNUM\n+      abort();\n+#else\n+      rv = gen_rtx_REG (Pmode, STRUCT_VALUE_REGNUM);\n+#endif\n+#endif\n+#endif\n+#endif\n+    }\n+  else\n+    {\n+#ifdef STRUCT_VALUE\n+      rv = STRUCT_VALUE;\n+#else\n+#ifndef STRUCT_VALUE_REGNUM\n+      abort();\n+#else\n+      rv = gen_rtx_REG (Pmode, STRUCT_VALUE_REGNUM);\n+#endif\n+#endif\n+    }\n+  return rv;\n+}\n+\n+bool\n+default_return_in_memory (tree type,\n+\t\t\t  tree fntype ATTRIBUTE_UNUSED)\n+{\n+  return RETURN_IN_MEMORY (type);\n+}\n+\n+rtx\n+default_expand_builtin_saveregs (void)\n+{\n+#ifdef EXPAND_BUILTIN_SAVEREGS\n+  return EXPAND_BUILTIN_SAVEREGS ();\n+#else\n+  error (\"__builtin_saveregs not supported by this target\");\n+  return const0_rtx;\n+#endif\n+}\n+\n+void\n+default_setup_incoming_varargs (CUMULATIVE_ARGS *ca ATTRIBUTE_UNUSED,\n+\t\t\t\tenum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\t\ttree type ATTRIBUTE_UNUSED,\n+\t\t\t\tint *pretend_arg_size ATTRIBUTE_UNUSED,\n+\t\t\t\tint second_time ATTRIBUTE_UNUSED)\n+{\n+#ifdef SETUP_INCOMING_VARARGS\n+  SETUP_INCOMING_VARARGS ((*ca), mode, type, (*pretend_arg_size), second_time);\n+#endif\n+}\n+\n+bool\n+default_strict_argument_naming (CUMULATIVE_ARGS *ca ATTRIBUTE_UNUSED)\n+{\n+#ifdef STRICT_ARGUMENT_NAMING\n+  return STRICT_ARGUMENT_NAMING;\n+#else\n+  return 0;\n+#endif\n+}\n+\n+bool\n+default_pretend_outgoing_varargs_named(CUMULATIVE_ARGS *ca ATTRIBUTE_UNUSED)\n+{\n+#ifdef PRETEND_OUTGOING_VARARGS_NAMED\n+  return PRETEND_OUTGOING_VARARGS_NAMED;\n+#else\n+#ifdef SETUP_INCOMING_VARARGS\n+  return 1;\n+#else\n+  return (targetm.calls.setup_incoming_varargs != default_setup_incoming_varargs);\n+#endif\n+#endif\n+}"}, {"sha": "335134b81b18306b7658721110e2c1655fea67b7", "filename": "gcc/targhooks.h", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61f71b34471e03254cdadd61f1418f425101273f/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61f71b34471e03254cdadd61f1418f425101273f/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=61f71b34471e03254cdadd61f1418f425101273f", "patch": "@@ -0,0 +1,31 @@\n+/* Default target hook functions.\n+   Copyright (C) 2003 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+02111-1307, USA.  */\n+\n+extern bool default_promote_function_args (tree);\n+extern bool default_promote_function_return (tree);\n+extern bool default_promote_prototypes (tree);\n+\n+extern rtx default_struct_value_rtx (tree, int);\n+extern bool default_return_in_memory (tree, tree);\n+\n+extern rtx default_expand_builtin_saveregs (void);\n+extern void default_setup_incoming_varargs (CUMULATIVE_ARGS *, enum machine_mode, tree, int *, int);\n+extern bool default_strict_argument_naming (CUMULATIVE_ARGS *);\n+extern bool default_pretend_outgoing_varargs_named (CUMULATIVE_ARGS *);"}, {"sha": "d742bc3d95b3dca2af81e999b62540d306629642", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61f71b34471e03254cdadd61f1418f425101273f/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61f71b34471e03254cdadd61f1418f425101273f/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=61f71b34471e03254cdadd61f1418f425101273f", "patch": "@@ -2871,7 +2871,7 @@ extern void pop_temp_slots (void);\n extern void push_temp_slots (void);\n extern void preserve_temp_slots (rtx);\n extern void preserve_rtl_expr_temps (tree);\n-extern int aggregate_value_p (tree);\n+extern int aggregate_value_p (tree, tree);\n extern void free_temps_for_rtl_expr (tree);\n extern void instantiate_virtual_regs (tree, rtx);\n extern void unshare_all_rtl (tree, rtx);"}]}