{"sha": "b1b2b511e525b098204c590b0eafa7d36092b7e1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjFiMmI1MTFlNTI1YjA5ODIwNGM1OTBiMGVhZmE3ZDM2MDkyYjdlMQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2017-05-15T08:14:32Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2017-05-15T08:14:32Z"}, "message": "trans.c (gnat_to_gnu): Fix formatting.\n\n\t* gcc-interface/trans.c (gnat_to_gnu) <N_Aggregate>: Fix formatting.\n\t<N_Allocator>: Use properly typed constants.\n\t(extract_values): Move around.\n\t(pos_to_constructor): Minor tweaks.\n\t(Sloc_to_locus): Fix formatting.\n\t* gcc-interface/utils.c (process_deferred_decl_context): Minor tweaks.\n\t* gcc-interface/gigi.h (MARK_VISITED): Remove blank line.\n\t(Gigi_Equivalent_Type): Adjust head comment.\n\t* gcc-interface/decl.c (Gigi_Equivalent_Type): Likewise.\n\nFrom-SVN: r248050", "tree": {"sha": "bcc1d733b4e48add82745d886ea9a58bd46a228d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bcc1d733b4e48add82745d886ea9a58bd46a228d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b1b2b511e525b098204c590b0eafa7d36092b7e1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1b2b511e525b098204c590b0eafa7d36092b7e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b1b2b511e525b098204c590b0eafa7d36092b7e1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1b2b511e525b098204c590b0eafa7d36092b7e1/comments", "author": null, "committer": null, "parents": [{"sha": "04bc3c93bec894ca85bc448b40af42545a280928", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04bc3c93bec894ca85bc448b40af42545a280928", "html_url": "https://github.com/Rust-GCC/gccrs/commit/04bc3c93bec894ca85bc448b40af42545a280928"}], "stats": {"total": 163, "additions": 84, "deletions": 79}, "files": [{"sha": "29d49d96164b54438ea3eeede4855890f299b79d", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1b2b511e525b098204c590b0eafa7d36092b7e1/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1b2b511e525b098204c590b0eafa7d36092b7e1/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=b1b2b511e525b098204c590b0eafa7d36092b7e1", "patch": "@@ -1,3 +1,15 @@\n+2017-05-15  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/trans.c (gnat_to_gnu) <N_Aggregate>: Fix formatting.\n+\t<N_Allocator>: Use properly typed constants.\n+\t(extract_values): Move around.\n+\t(pos_to_constructor): Minor tweaks.\n+\t(Sloc_to_locus): Fix formatting.\n+\t* gcc-interface/utils.c (process_deferred_decl_context): Minor tweaks.\n+\t* gcc-interface/gigi.h (MARK_VISITED): Remove blank line.\n+\t(Gigi_Equivalent_Type): Adjust head comment.\n+\t* gcc-interface/decl.c (Gigi_Equivalent_Type): Likewise.\n+\n 2017-05-15  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Record_Type>: When there"}, {"sha": "dee59c0324cdd6a91a6a69ecf4ea296e187a4566", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1b2b511e525b098204c590b0eafa7d36092b7e1/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1b2b511e525b098204c590b0eafa7d36092b7e1/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=b1b2b511e525b098204c590b0eafa7d36092b7e1", "patch": "@@ -3270,12 +3270,12 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t    }\n \n \t/* If we have a derived untagged type that renames discriminants in\n-\t   the root type, the (stored) discriminants are just a copy of the\n-\t   discriminants of the root type.  This means that any constraints\n-\t   added by the renaming in the derivation are disregarded as far\n-\t   as the layout of the derived type is concerned.  To rescue them,\n-\t   we change the type of the (stored) discriminants to a subtype\n-\t   with the bounds of the type of the visible discriminants.  */\n+\t   the parent type, the (stored) discriminants are just a copy of the\n+\t   discriminants of the parent type.  This means that any constraints\n+\t   added by the renaming in the derivation are disregarded as far as\n+\t   the layout of the derived type is concerned.  To rescue them, we\n+\t   change the type of the (stored) discriminants to a subtype with\n+\t   the bounds of the type of the visible discriminants.  */\n \tif (has_discr\n \t    && !is_extension\n \t    && Stored_Constraint (gnat_entity) != No_Elist)\n@@ -4967,12 +4967,10 @@ finalize_from_limited_with (void)\n     }\n }\n \n-/* Return the equivalent type to be used for GNAT_ENTITY, if it's a\n-   kind of type (such E_Task_Type) that has a different type which Gigi\n-   uses for its representation.  If the type does not have a special type\n-   for its representation, return GNAT_ENTITY.  If a type is supposed to\n-   exist, but does not, abort unless annotating types, in which case\n-   return Empty.  If GNAT_ENTITY is Empty, return Empty.  */\n+/* Return the equivalent type to be used for GNAT_ENTITY, if it's a kind\n+   of type (such E_Task_Type) that has a different type which Gigi uses\n+   for its representation.  If the type does not have a special type for\n+   its representation, return GNAT_ENTITY.  */\n \n Entity_Id\n Gigi_Equivalent_Type (Entity_Id gnat_entity)"}, {"sha": "1fc3448a08380c1047394979ec8635bcff40ff68", "filename": "gcc/ada/gcc-interface/gigi.h", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1b2b511e525b098204c590b0eafa7d36092b7e1/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1b2b511e525b098204c590b0eafa7d36092b7e1/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fgigi.h?ref=b1b2b511e525b098204c590b0eafa7d36092b7e1", "patch": "@@ -88,7 +88,6 @@ extern void mark_visited (tree t);\n \n /* This macro calls the above function but short-circuits the common\n    case of a constant to save time and also checks for NULL.  */\n-\n #define MARK_VISITED(EXP)\t\t\\\n do {\t\t\t\t\t\\\n   if((EXP) && !CONSTANT_CLASS_P (EXP))\t\\\n@@ -98,12 +97,10 @@ do {\t\t\t\t\t\\\n /* Finalize the processing of From_Limited_With incomplete types.  */\n extern void finalize_from_limited_with (void);\n \n-/* Return the equivalent type to be used for GNAT_ENTITY, if it's a\n-   kind of type (such E_Task_Type) that has a different type which Gigi\n-   uses for its representation.  If the type does not have a special type\n-   for its representation, return GNAT_ENTITY.  If a type is supposed to\n-   exist, but does not, abort unless annotating types, in which case\n-   return Empty.   If GNAT_ENTITY is Empty, return Empty.  */\n+/* Return the equivalent type to be used for GNAT_ENTITY, if it's a kind\n+   of type (such E_Task_Type) that has a different type which Gigi uses\n+   for its representation.  If the type does not have a special type for\n+   its representation, return GNAT_ENTITY.  */\n extern Entity_Id Gigi_Equivalent_Type (Entity_Id gnat_entity);\n \n /* Given GNAT_ENTITY, elaborate all expressions that are required to"}, {"sha": "ef0db27c8ca59662b4ad4d47ff125bbc65b1a9d3", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 56, "deletions": 57, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1b2b511e525b098204c590b0eafa7d36092b7e1/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1b2b511e525b098204c590b0eafa7d36092b7e1/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=b1b2b511e525b098204c590b0eafa7d36092b7e1", "patch": "@@ -237,7 +237,6 @@ static tree build_binary_op_trapv (enum tree_code, tree, tree, tree, Node_Id);\n static tree convert_with_check (Entity_Id, tree, bool, bool, bool, Node_Id);\n static bool addressable_p (tree, tree);\n static tree assoc_to_constructor (Entity_Id, Node_Id, tree);\n-static tree extract_values (tree, tree);\n static tree pos_to_constructor (Node_Id, tree, Entity_Id);\n static void validate_unchecked_conversion (Node_Id);\n static tree maybe_implicit_deref (tree);\n@@ -6497,8 +6496,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t  gnu_aggr_type = TYPE_REPRESENTATIVE_ARRAY (gnu_result_type);\n \n \tif (Null_Record_Present (gnat_node))\n-\t  gnu_result = gnat_build_constructor (gnu_aggr_type,\n-\t\t\t\t\t       NULL);\n+\t  gnu_result = gnat_build_constructor (gnu_aggr_type, NULL);\n \n \telse if (TREE_CODE (gnu_aggr_type) == RECORD_TYPE\n \t\t || TREE_CODE (gnu_aggr_type) == UNION_TYPE)\n@@ -6858,7 +6856,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \n     case N_Allocator:\n       {\n-\ttree gnu_init = 0;\n+\ttree gnu_init = NULL_TREE;\n \ttree gnu_type;\n \tbool ignore_init_type = false;\n \n@@ -9658,6 +9656,55 @@ process_type (Entity_Id gnat_entity)\n     }\n }\n \f\n+/* Subroutine of assoc_to_constructor: VALUES is a list of field associations,\n+   some of which are from RECORD_TYPE.  Return a CONSTRUCTOR consisting of the\n+   associations that are from RECORD_TYPE.  If we see an internal record, make\n+   a recursive call to fill it in as well.  */\n+\n+static tree\n+extract_values (tree values, tree record_type)\n+{\n+  vec<constructor_elt, va_gc> *v = NULL;\n+  tree field;\n+\n+  for (field = TYPE_FIELDS (record_type); field; field = DECL_CHAIN (field))\n+    {\n+      tree tem, value = NULL_TREE;\n+\n+      /* _Parent is an internal field, but may have values in the aggregate,\n+\t so check for values first.  */\n+      if ((tem = purpose_member (field, values)))\n+\t{\n+\t  value = TREE_VALUE (tem);\n+\t  TREE_ADDRESSABLE (tem) = 1;\n+\t}\n+\n+      else if (DECL_INTERNAL_P (field))\n+\t{\n+\t  value = extract_values (values, TREE_TYPE (field));\n+\t  if (TREE_CODE (value) == CONSTRUCTOR\n+\t      && vec_safe_is_empty (CONSTRUCTOR_ELTS (value)))\n+\t    value = NULL_TREE;\n+\t}\n+      else\n+\t/* If we have a record subtype, the names will match, but not the\n+\t   actual FIELD_DECLs.  */\n+\tfor (tem = values; tem; tem = TREE_CHAIN (tem))\n+\t  if (DECL_NAME (TREE_PURPOSE (tem)) == DECL_NAME (field))\n+\t    {\n+\t      value = convert (TREE_TYPE (field), TREE_VALUE (tem));\n+\t      TREE_ADDRESSABLE (tem) = 1;\n+\t    }\n+\n+      if (!value)\n+\tcontinue;\n+\n+      CONSTRUCTOR_APPEND_ELT (v, field, value);\n+    }\n+\n+  return gnat_build_constructor (record_type, v);\n+}\n+\n /* GNAT_ENTITY is the type of the resulting constructor, GNAT_ASSOC is the\n    front of the Component_Associations of an N_Aggregate and GNU_TYPE is the\n    GCC type of the corresponding record type.  Return the CONSTRUCTOR.  */\n@@ -9728,11 +9775,12 @@ pos_to_constructor (Node_Id gnat_expr, tree gnu_array_type,\n \t\t    Entity_Id gnat_component_type)\n {\n   tree gnu_index = TYPE_MIN_VALUE (TYPE_DOMAIN (gnu_array_type));\n-  tree gnu_expr;\n   vec<constructor_elt, va_gc> *gnu_expr_vec = NULL;\n \n-  for ( ; Present (gnat_expr); gnat_expr = Next (gnat_expr))\n+  for (; Present (gnat_expr); gnat_expr = Next (gnat_expr))\n     {\n+      tree gnu_expr;\n+\n       /* If the expression is itself an array aggregate then first build the\n \t innermost constructor if it is part of our array (multi-dimensional\n \t case).  */\n@@ -9763,55 +9811,6 @@ pos_to_constructor (Node_Id gnat_expr, tree gnu_array_type,\n   return gnat_build_constructor (gnu_array_type, gnu_expr_vec);\n }\n \f\n-/* Subroutine of assoc_to_constructor: VALUES is a list of field associations,\n-   some of which are from RECORD_TYPE.  Return a CONSTRUCTOR consisting of the\n-   associations that are from RECORD_TYPE.  If we see an internal record, make\n-   a recursive call to fill it in as well.  */\n-\n-static tree\n-extract_values (tree values, tree record_type)\n-{\n-  tree field, tem;\n-  vec<constructor_elt, va_gc> *v = NULL;\n-\n-  for (field = TYPE_FIELDS (record_type); field; field = DECL_CHAIN (field))\n-    {\n-      tree value = 0;\n-\n-      /* _Parent is an internal field, but may have values in the aggregate,\n-\t so check for values first.  */\n-      if ((tem = purpose_member (field, values)))\n-\t{\n-\t  value = TREE_VALUE (tem);\n-\t  TREE_ADDRESSABLE (tem) = 1;\n-\t}\n-\n-      else if (DECL_INTERNAL_P (field))\n-\t{\n-\t  value = extract_values (values, TREE_TYPE (field));\n-\t  if (TREE_CODE (value) == CONSTRUCTOR\n-\t      && vec_safe_is_empty (CONSTRUCTOR_ELTS (value)))\n-\t    value = 0;\n-\t}\n-      else\n-\t/* If we have a record subtype, the names will match, but not the\n-\t   actual FIELD_DECLs.  */\n-\tfor (tem = values; tem; tem = TREE_CHAIN (tem))\n-\t  if (DECL_NAME (TREE_PURPOSE (tem)) == DECL_NAME (field))\n-\t    {\n-\t      value = convert (TREE_TYPE (field), TREE_VALUE (tem));\n-\t      TREE_ADDRESSABLE (tem) = 1;\n-\t    }\n-\n-      if (!value)\n-\tcontinue;\n-\n-      CONSTRUCTOR_APPEND_ELT (v, field, value);\n-    }\n-\n-  return gnat_build_constructor (record_type, v);\n-}\n-\f\n /* Process a N_Validate_Unchecked_Conversion node.  */\n \n static void\n@@ -9915,8 +9914,8 @@ Sloc_to_locus (Source_Ptr Sloc, location_t *locus, bool clear_column)\n     line = 1;\n \n   /* Translate the location.  */\n-  *locus = linemap_position_for_line_and_column (line_table, map,\n-\t\t\t\t\t\t line, column);\n+  *locus\n+    = linemap_position_for_line_and_column (line_table, map, line, column);\n \n   return true;\n }"}, {"sha": "4fabddfe5e11296830be2be78e18c7aaa8c6a609", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1b2b511e525b098204c590b0eafa7d36092b7e1/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1b2b511e525b098204c590b0eafa7d36092b7e1/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=b1b2b511e525b098204c590b0eafa7d36092b7e1", "patch": "@@ -2992,15 +2992,15 @@ process_deferred_decl_context (bool force)\n   struct deferred_decl_context_node **it = &deferred_decl_context_queue;\n   struct deferred_decl_context_node *node;\n \n-  while (*it != NULL)\n+  while (*it)\n     {\n       bool processed = false;\n       tree context = NULL_TREE;\n       Entity_Id gnat_scope;\n \n       node = *it;\n \n-      /* If FORCE, get the innermost elaborated scope. Otherwise, just try to\n+      /* If FORCE, get the innermost elaborated scope.  Otherwise, just try to\n \t get the first scope.  */\n       gnat_scope = node->gnat_scope;\n       while (Present (gnat_scope))\n@@ -3058,7 +3058,6 @@ process_deferred_decl_context (bool force)\n     }\n }\n \n-\n /* Return VALUE scaled by the biggest power-of-2 factor of EXPR.  */\n \n static unsigned int"}]}