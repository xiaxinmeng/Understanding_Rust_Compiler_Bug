{"sha": "678faefcab01f9e9eeb222852675b5a042aaf900", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Njc4ZmFlZmNhYjAxZjllOWVlYjIyMjg1MjY3NWI1YTA0MmFhZjkwMA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-08-14T08:03:26Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-08-14T08:03:26Z"}, "message": "[AArch64] Canonicalise SVE predicate constants\n\nThis patch makes sure that we build all SVE predicate constants as\nVNx16BI before RA, to encourage similar constants to be reused\nbetween modes.  This is also useful for the ACLE, where the single\npredicate type svbool_t is always a VNx16BI.\n\nAlso, and again to encourage reuse, the patch makes us use a .B PTRUE\nfor all ptrue-predicated operations, rather than (for example) using\na .S PTRUE for 32-bit operations and a .D PTRUE for 64-bit operations.\n\nThe only current case in which a .H, .S or .D operation needs to be\npredicated by a \"strict\" .H/.S/.D PTRUE is the PTEST in a conditional\nbranch, which an earlier patch fixed to use an appropriate VNx16BI\nconstant.\n\n2019-08-14  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* config/aarch64/aarch64.c (aarch64_target_reg): New function.\n\t(aarch64_emit_set_immediate): Likewise.\n\t(aarch64_ptrue_reg): Build a VNx16BI constant and then bitcast it.\n\t(aarch64_pfalse_reg): Likewise.\n\t(aarch64_convert_sve_data_to_pred): New function.\n\t(aarch64_sve_move_pred_via_while): Take an optional target register\n\tand the required register mode.\n\t(aarch64_expand_sve_const_pred_1): New function.\n\t(aarch64_expand_sve_const_pred): Likewise.\n\t(aarch64_expand_mov_immediate): Build an all-true predicate\n\tif the significant bits of the immediate are all true.  Use\n\taarch64_expand_sve_const_pred for all compile-time predicate constants.\n\t(aarch64_mov_operand_p): Force predicate constants to be VNx16BI\n\tbefore register allocation.\n\t* config/aarch64/aarch64-sve.md (*vec_duplicate<mode>_reg): Use\n\ta VNx16BI PTRUE when splitting the memory alternative.\n\t(vec_duplicate<mode>): Update accordingly.\n\t(*pred_cmp<cmp_op><mode>): Rename to...\n\t(@aarch64_pred_cmp<cmp_op><mode>): ...this.\n\ngcc/testsuite/\n\t* gcc.target/aarch64/sve/spill_4.c: Expect all ptrues to be .Bs.\n\t* gcc.target/aarch64/sve/single_1.c: Likewise.\n\t* gcc.target/aarch64/sve/single_2.c: Likewise.\n\t* gcc.target/aarch64/sve/single_3.c: Likewise.\n\t* gcc.target/aarch64/sve/single_4.c: Likewise.\n\nFrom-SVN: r274415", "tree": {"sha": "5f22df29617c3ab4990f86df471272e7e32a5f57", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5f22df29617c3ab4990f86df471272e7e32a5f57"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/678faefcab01f9e9eeb222852675b5a042aaf900", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/678faefcab01f9e9eeb222852675b5a042aaf900", "html_url": "https://github.com/Rust-GCC/gccrs/commit/678faefcab01f9e9eeb222852675b5a042aaf900", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/678faefcab01f9e9eeb222852675b5a042aaf900/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "34467289631e29545e14148515ab5f5d0d9e4fa7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34467289631e29545e14148515ab5f5d0d9e4fa7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/34467289631e29545e14148515ab5f5d0d9e4fa7"}], "stats": {"total": 250, "additions": 204, "deletions": 46}, "files": [{"sha": "ec4aaec093645ab2ff62b5428686719e2adc7461", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/678faefcab01f9e9eeb222852675b5a042aaf900/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/678faefcab01f9e9eeb222852675b5a042aaf900/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=678faefcab01f9e9eeb222852675b5a042aaf900", "patch": "@@ -1,3 +1,25 @@\n+2019-08-14  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* config/aarch64/aarch64.c (aarch64_target_reg): New function.\n+\t(aarch64_emit_set_immediate): Likewise.\n+\t(aarch64_ptrue_reg): Build a VNx16BI constant and then bitcast it.\n+\t(aarch64_pfalse_reg): Likewise.\n+\t(aarch64_convert_sve_data_to_pred): New function.\n+\t(aarch64_sve_move_pred_via_while): Take an optional target register\n+\tand the required register mode.\n+\t(aarch64_expand_sve_const_pred_1): New function.\n+\t(aarch64_expand_sve_const_pred): Likewise.\n+\t(aarch64_expand_mov_immediate): Build an all-true predicate\n+\tif the significant bits of the immediate are all true.  Use\n+\taarch64_expand_sve_const_pred for all compile-time predicate constants.\n+\t(aarch64_mov_operand_p): Force predicate constants to be VNx16BI\n+\tbefore register allocation.\n+\t* config/aarch64/aarch64-sve.md (*vec_duplicate<mode>_reg): Use\n+\ta VNx16BI PTRUE when splitting the memory alternative.\n+\t(vec_duplicate<mode>): Update accordingly.\n+\t(*pred_cmp<cmp_op><mode>): Rename to...\n+\t(@aarch64_pred_cmp<cmp_op><mode>): ...this.\n+\n 2019-08-14  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* config/aarch64/aarch64-protos.h (aarch64_ptrue_all): Declare."}, {"sha": "b91d64c726eb179a032d31d10fdda91e56e954c1", "filename": "gcc/config/aarch64/aarch64-sve.md", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/678faefcab01f9e9eeb222852675b5a042aaf900/gcc%2Fconfig%2Faarch64%2Faarch64-sve.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/678faefcab01f9e9eeb222852675b5a042aaf900/gcc%2Fconfig%2Faarch64%2Faarch64-sve.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-sve.md?ref=678faefcab01f9e9eeb222852675b5a042aaf900", "patch": "@@ -846,7 +846,7 @@\n     [(set (match_operand:SVE_ALL 0 \"register_operand\")\n \t  (vec_duplicate:SVE_ALL\n \t    (match_operand:<VEL> 1 \"aarch64_sve_dup_operand\")))\n-     (clobber (scratch:<VPRED>))])]\n+     (clobber (scratch:VNx16BI))])]\n   \"TARGET_SVE\"\n   {\n     if (MEM_P (operands[1]))\n@@ -867,7 +867,7 @@\n   [(set (match_operand:SVE_ALL 0 \"register_operand\" \"=w, w, w\")\n \t(vec_duplicate:SVE_ALL\n \t  (match_operand:<VEL> 1 \"aarch64_sve_dup_operand\" \"r, w, Uty\")))\n-   (clobber (match_scratch:<VPRED> 2 \"=X, X, Upl\"))]\n+   (clobber (match_scratch:VNx16BI 2 \"=X, X, Upl\"))]\n   \"TARGET_SVE\"\n   \"@\n    mov\\t%0.<Vetype>, %<vwcore>1\n@@ -877,9 +877,10 @@\n   [(const_int 0)]\n   {\n     if (GET_CODE (operands[2]) == SCRATCH)\n-      operands[2] = gen_reg_rtx (<VPRED>mode);\n-    emit_move_insn (operands[2], CONSTM1_RTX (<VPRED>mode));\n-    emit_insn (gen_sve_ld1r<mode> (operands[0], operands[2], operands[1],\n+      operands[2] = gen_reg_rtx (VNx16BImode);\n+    emit_move_insn (operands[2], CONSTM1_RTX (VNx16BImode));\n+    rtx gp = gen_lowpart (<VPRED>mode, operands[2]);\n+    emit_insn (gen_sve_ld1r<mode> (operands[0], gp, operands[1],\n \t\t\t\t   CONST0_RTX (<MODE>mode)));\n     DONE;\n   }\n@@ -2971,7 +2972,7 @@\n )\n \n ;; Predicated integer comparisons.\n-(define_insn \"*pred_cmp<cmp_op><mode>\"\n+(define_insn \"@aarch64_pred_cmp<cmp_op><mode>\"\n   [(set (match_operand:<VPRED> 0 \"register_operand\" \"=Upa, Upa\")\n \t(and:<VPRED>\n \t  (SVE_INT_CMP:<VPRED>"}, {"sha": "813d4877dca0b93d946fe0fb7e3231b490942f72", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 160, "deletions": 22, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/678faefcab01f9e9eeb222852675b5a042aaf900/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/678faefcab01f9e9eeb222852675b5a042aaf900/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=678faefcab01f9e9eeb222852675b5a042aaf900", "patch": "@@ -2546,6 +2546,36 @@ aarch64_zero_extend_const_eq (machine_mode xmode, rtx x,\n }\n \t\t\t      \n \n+/* Return TARGET if it is nonnull and a register of mode MODE.\n+   Otherwise, return a fresh register of mode MODE if we can,\n+   or TARGET reinterpreted as MODE if we can't.  */\n+\n+static rtx\n+aarch64_target_reg (rtx target, machine_mode mode)\n+{\n+  if (target && REG_P (target) && GET_MODE (target) == mode)\n+    return target;\n+  if (!can_create_pseudo_p ())\n+    {\n+      gcc_assert (target);\n+      return gen_lowpart (mode, target);\n+    }\n+  return gen_reg_rtx (mode);\n+}\n+\n+/* Return a register that contains the constant in BUILDER, given that\n+   the constant is a legitimate move operand.  Use TARGET as the register\n+   if it is nonnull and convenient.  */\n+\n+static rtx\n+aarch64_emit_set_immediate (rtx target, rtx_vector_builder &builder)\n+{\n+  rtx src = builder.build ();\n+  target = aarch64_target_reg (target, GET_MODE (src));\n+  emit_insn (gen_rtx_SET (target, src));\n+  return target;\n+}\n+\n static rtx\n aarch64_force_temporary (machine_mode mode, rtx x, rtx value)\n {\n@@ -2721,7 +2751,8 @@ rtx\n aarch64_ptrue_reg (machine_mode mode)\n {\n   gcc_assert (GET_MODE_CLASS (mode) == MODE_VECTOR_BOOL);\n-  return force_reg (mode, CONSTM1_RTX (mode));\n+  rtx reg = force_reg (VNx16BImode, CONSTM1_RTX (VNx16BImode));\n+  return gen_lowpart (mode, reg);\n }\n \n /* Return an all-false predicate register of mode MODE.  */\n@@ -2730,7 +2761,26 @@ rtx\n aarch64_pfalse_reg (machine_mode mode)\n {\n   gcc_assert (GET_MODE_CLASS (mode) == MODE_VECTOR_BOOL);\n-  return force_reg (mode, CONST0_RTX (mode));\n+  rtx reg = force_reg (VNx16BImode, CONST0_RTX (VNx16BImode));\n+  return gen_lowpart (mode, reg);\n+}\n+\n+/* Use a comparison to convert integer vector SRC into MODE, which is\n+   the corresponding SVE predicate mode.  Use TARGET for the result\n+   if it's nonnull and convenient.  */\n+\n+static rtx\n+aarch64_convert_sve_data_to_pred (rtx target, machine_mode mode, rtx src)\n+{\n+  machine_mode src_mode = GET_MODE (src);\n+  insn_code icode = code_for_aarch64_pred_cmp (NE, src_mode);\n+  expand_operand ops[4];\n+  create_output_operand (&ops[0], target, mode);\n+  create_input_operand (&ops[1], CONSTM1_RTX (mode), mode);\n+  create_input_operand (&ops[2], src, src_mode);\n+  create_input_operand (&ops[3], CONST0_RTX (src_mode), src_mode);\n+  expand_insn (icode, 4, ops);\n+  return ops[0].value;\n }\n \n /* Return true if we can move VALUE into a register using a single\n@@ -3633,15 +3683,80 @@ aarch64_expand_sve_const_vector (rtx target, rtx src)\n   return target;\n }\n \n-/* Use WHILE to set predicate register DEST so that the first VL bits\n-   are set and the rest are clear.  */\n+/* Use WHILE to set a predicate register of mode MODE in which the first\n+   VL bits are set and the rest are clear.  Use TARGET for the register\n+   if it's nonnull and convenient.  */\n \n-static void\n-aarch64_sve_move_pred_via_while (rtx dest, unsigned int vl)\n+static rtx\n+aarch64_sve_move_pred_via_while (rtx target, machine_mode mode,\n+\t\t\t\t unsigned int vl)\n {\n   rtx limit = force_reg (DImode, gen_int_mode (vl, DImode));\n-  emit_insn (gen_while_ult (DImode, GET_MODE (dest),\n-\t\t\t    dest, const0_rtx, limit));\n+  target = aarch64_target_reg (target, mode);\n+  emit_insn (gen_while_ult (DImode, mode, target, const0_rtx, limit));\n+  return target;\n+}\n+\n+/* Subroutine of aarch64_expand_sve_const_pred.  Try to load the VNx16BI\n+   constant in BUILDER into an SVE predicate register.  Return the register\n+   on success, otherwise return null.  Use TARGET for the register if\n+   nonnull and convenient.  */\n+\n+static rtx\n+aarch64_expand_sve_const_pred_1 (rtx target, rtx_vector_builder &builder)\n+{\n+  if (builder.encoded_nelts () == 1)\n+    /* A PFALSE or a PTRUE .B ALL.  */\n+    return aarch64_emit_set_immediate (target, builder);\n+\n+  unsigned int elt_size = aarch64_widest_sve_pred_elt_size (builder);\n+  if (int vl = aarch64_partial_ptrue_length (builder, elt_size))\n+    {\n+      /* If we can load the constant using PTRUE, use it as-is.  */\n+      machine_mode mode = aarch64_sve_pred_mode (elt_size).require ();\n+      if (aarch64_svpattern_for_vl (mode, vl) != AARCH64_NUM_SVPATTERNS)\n+\treturn aarch64_emit_set_immediate (target, builder);\n+\n+      /* Otherwise use WHILE to set the first VL bits.  */\n+      return aarch64_sve_move_pred_via_while (target, mode, vl);\n+    }\n+\n+  return NULL_RTX;\n+}\n+\n+/* Return an SVE predicate register that contains the VNx16BImode\n+   constant in BUILDER, without going through the move expanders.\n+\n+   The returned register can have whatever mode seems most natural\n+   given the contents of BUILDER.  Use TARGET for the result if\n+   convenient.  */\n+\n+static rtx\n+aarch64_expand_sve_const_pred (rtx target, rtx_vector_builder &builder)\n+{\n+  /* Try loading the constant using pure predicate operations.  */\n+  if (rtx res = aarch64_expand_sve_const_pred_1 (target, builder))\n+    return res;\n+\n+  /* Try forcing the constant to memory.  */\n+  if (builder.full_nelts ().is_constant ())\n+    if (rtx mem = force_const_mem (VNx16BImode, builder.build ()))\n+      {\n+\ttarget = aarch64_target_reg (target, VNx16BImode);\n+\temit_move_insn (target, mem);\n+\treturn target;\n+      }\n+\n+  /* The last resort is to load the constant as an integer and then\n+     compare it against zero.  Use -1 for set bits in order to increase\n+     the changes of using SVE DUPM or an Advanced SIMD byte mask.  */\n+  rtx_vector_builder int_builder (VNx16QImode, builder.npatterns (),\n+\t\t\t\t  builder.nelts_per_pattern ());\n+  for (unsigned int i = 0; i < builder.encoded_nelts (); ++i)\n+    int_builder.quick_push (INTVAL (builder.elt (i))\n+\t\t\t    ? constm1_rtx : const0_rtx);\n+  return aarch64_convert_sve_data_to_pred (target, VNx16BImode,\n+\t\t\t\t\t   int_builder.build ());\n }\n \n /* Set DEST to immediate IMM.  */\n@@ -3770,26 +3885,39 @@ aarch64_expand_mov_immediate (rtx dest, rtx imm)\n \n   if (!CONST_INT_P (imm))\n     {\n+      if (GET_MODE_CLASS (mode) == MODE_VECTOR_BOOL)\n+\t{\n+\t  /* Only the low bit of each .H, .S and .D element is defined,\n+\t     so we can set the upper bits to whatever we like.  If the\n+\t     predicate is all-true in MODE, prefer to set all the undefined\n+\t     bits as well, so that we can share a single .B predicate for\n+\t     all modes.  */\n+\t  if (imm == CONSTM1_RTX (mode))\n+\t    imm = CONSTM1_RTX (VNx16BImode);\n+\n+\t  /* All methods for constructing predicate modes wider than VNx16BI\n+\t     will set the upper bits of each element to zero.  Expose this\n+\t     by moving such constants as a VNx16BI, so that all bits are\n+\t     significant and so that constants for different modes can be\n+\t     shared.  The wider constant will still be available as a\n+\t     REG_EQUAL note.  */\n+\t  rtx_vector_builder builder;\n+\t  if (aarch64_get_sve_pred_bits (builder, imm))\n+\t    {\n+\t      rtx res = aarch64_expand_sve_const_pred (dest, builder);\n+\t      if (dest != res)\n+\t\temit_move_insn (dest, gen_lowpart (mode, res));\n+\t      return;\n+\t    }\n+\t}\n+\n       if (GET_CODE (imm) == HIGH\n \t  || aarch64_simd_valid_immediate (imm, NULL))\n \t{\n \t  emit_insn (gen_rtx_SET (dest, imm));\n \t  return;\n \t}\n \n-      rtx_vector_builder builder;\n-      if (GET_MODE_CLASS (GET_MODE (imm)) == MODE_VECTOR_BOOL\n-\t  && aarch64_get_sve_pred_bits (builder, imm))\n-\t{\n-\t  unsigned int elt_size = aarch64_widest_sve_pred_elt_size (builder);\n-\t  int vl = aarch64_partial_ptrue_length (builder, elt_size);\n-\t  if (vl > 0)\n-\t    {\n-\t      aarch64_sve_move_pred_via_while (dest, vl);\n-\t      return;\n-\t    }\n-\t}\n-\n       if (GET_CODE (imm) == CONST_VECTOR && aarch64_sve_data_mode_p (mode))\n \tif (rtx res = aarch64_expand_sve_const_vector (dest, imm))\n \t  {\n@@ -15178,7 +15306,17 @@ aarch64_mov_operand_p (rtx x, machine_mode mode)\n     return true;\n \n   if (VECTOR_MODE_P (GET_MODE (x)))\n-    return aarch64_simd_valid_immediate (x, NULL);\n+    {\n+      /* Require predicate constants to be VNx16BI before RA, so that we\n+\t force everything to have a canonical form.  */\n+      if (!lra_in_progress\n+\t  && !reload_completed\n+\t  && GET_MODE_CLASS (GET_MODE (x)) == MODE_VECTOR_BOOL\n+\t  && GET_MODE (x) != VNx16BImode)\n+\treturn false;\n+\n+      return aarch64_simd_valid_immediate (x, NULL);\n+    }\n \n   if (GET_CODE (x) == SYMBOL_REF && mode == DImode && CONSTANT_ADDRESS_P (x))\n     return true;"}, {"sha": "a502ffb254f5f2533cf40359e2d904e49bf2a348", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/678faefcab01f9e9eeb222852675b5a042aaf900/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/678faefcab01f9e9eeb222852675b5a042aaf900/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=678faefcab01f9e9eeb222852675b5a042aaf900", "patch": "@@ -1,3 +1,11 @@\n+2019-08-14  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* gcc.target/aarch64/sve/spill_4.c: Expect all ptrues to be .Bs.\n+\t* gcc.target/aarch64/sve/single_1.c: Likewise.\n+\t* gcc.target/aarch64/sve/single_2.c: Likewise.\n+\t* gcc.target/aarch64/sve/single_3.c: Likewise.\n+\t* gcc.target/aarch64/sve/single_4.c: Likewise.\n+\n 2019-08-13  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \tPR fortran/87991"}, {"sha": "d9bb97e12cd41006bfa8a324f5cd1b1c363d690a", "filename": "gcc/testsuite/gcc.target/aarch64/sve/single_1.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/678faefcab01f9e9eeb222852675b5a042aaf900/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fsingle_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/678faefcab01f9e9eeb222852675b5a042aaf900/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fsingle_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fsingle_1.c?ref=678faefcab01f9e9eeb222852675b5a042aaf900", "patch": "@@ -40,10 +40,7 @@ TEST_LOOP (double, 3.0)\n /* { dg-final { scan-assembler-times {\\tfmov\\tz[0-9]+\\.s, #2\\.0e\\+0\\n} 1 } } */\n /* { dg-final { scan-assembler-times {\\tfmov\\tz[0-9]+\\.d, #3\\.0e\\+0\\n} 1 } } */\n \n-/* { dg-final { scan-assembler-times {\\tptrue\\tp[0-7]\\.b, vl32\\n} 2 } } */\n-/* { dg-final { scan-assembler-times {\\tptrue\\tp[0-7]\\.h, vl16\\n} 3 } } */\n-/* { dg-final { scan-assembler-times {\\tptrue\\tp[0-7]\\.s, vl8\\n} 3 } } */\n-/* { dg-final { scan-assembler-times {\\tptrue\\tp[0-7]\\.d, vl4\\n} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tptrue\\tp[0-7]\\.b, vl32\\n} 11 } } */\n \n /* { dg-final { scan-assembler-times {\\tst1b\\tz[0-9]+\\.b,} 2 } } */\n /* { dg-final { scan-assembler-times {\\tst1h\\tz[0-9]+\\.h,} 3 } } */"}, {"sha": "d27eead17e36ea4e1055569a05eeac129708a10b", "filename": "gcc/testsuite/gcc.target/aarch64/sve/single_2.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/678faefcab01f9e9eeb222852675b5a042aaf900/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fsingle_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/678faefcab01f9e9eeb222852675b5a042aaf900/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fsingle_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fsingle_2.c?ref=678faefcab01f9e9eeb222852675b5a042aaf900", "patch": "@@ -16,10 +16,7 @@\n /* { dg-final { scan-assembler-times {\\tfmov\\tz[0-9]+\\.s, #2\\.0e\\+0\\n} 1 } } */\n /* { dg-final { scan-assembler-times {\\tfmov\\tz[0-9]+\\.d, #3\\.0e\\+0\\n} 1 } } */\n \n-/* { dg-final { scan-assembler-times {\\tptrue\\tp[0-7]\\.b, vl64\\n} 2 } } */\n-/* { dg-final { scan-assembler-times {\\tptrue\\tp[0-7]\\.h, vl32\\n} 3 } } */\n-/* { dg-final { scan-assembler-times {\\tptrue\\tp[0-7]\\.s, vl16\\n} 3 } } */\n-/* { dg-final { scan-assembler-times {\\tptrue\\tp[0-7]\\.d, vl8\\n} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tptrue\\tp[0-7]\\.b, vl64\\n} 11 } } */\n \n /* { dg-final { scan-assembler-times {\\tst1b\\tz[0-9]+\\.b,} 2 } } */\n /* { dg-final { scan-assembler-times {\\tst1h\\tz[0-9]+\\.h,} 3 } } */"}, {"sha": "313a72da0670e4c4d03591d34dc9d747ed6e4b16", "filename": "gcc/testsuite/gcc.target/aarch64/sve/single_3.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/678faefcab01f9e9eeb222852675b5a042aaf900/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fsingle_3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/678faefcab01f9e9eeb222852675b5a042aaf900/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fsingle_3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fsingle_3.c?ref=678faefcab01f9e9eeb222852675b5a042aaf900", "patch": "@@ -16,10 +16,7 @@\n /* { dg-final { scan-assembler-times {\\tfmov\\tz[0-9]+\\.s, #2\\.0e\\+0\\n} 1 } } */\n /* { dg-final { scan-assembler-times {\\tfmov\\tz[0-9]+\\.d, #3\\.0e\\+0\\n} 1 } } */\n \n-/* { dg-final { scan-assembler-times {\\tptrue\\tp[0-7]\\.b, vl128\\n} 2 } } */\n-/* { dg-final { scan-assembler-times {\\tptrue\\tp[0-7]\\.h, vl64\\n} 3 } } */\n-/* { dg-final { scan-assembler-times {\\tptrue\\tp[0-7]\\.s, vl32\\n} 3 } } */\n-/* { dg-final { scan-assembler-times {\\tptrue\\tp[0-7]\\.d, vl16\\n} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tptrue\\tp[0-7]\\.b, vl128\\n} 11 } } */\n \n /* { dg-final { scan-assembler-times {\\tst1b\\tz[0-9]+\\.b,} 2 } } */\n /* { dg-final { scan-assembler-times {\\tst1h\\tz[0-9]+\\.h,} 3 } } */"}, {"sha": "4f46654a5ee855be8777c3e3a56a790a9af8f337", "filename": "gcc/testsuite/gcc.target/aarch64/sve/single_4.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/678faefcab01f9e9eeb222852675b5a042aaf900/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fsingle_4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/678faefcab01f9e9eeb222852675b5a042aaf900/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fsingle_4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fsingle_4.c?ref=678faefcab01f9e9eeb222852675b5a042aaf900", "patch": "@@ -16,10 +16,7 @@\n /* { dg-final { scan-assembler-times {\\tfmov\\tz[0-9]+\\.s, #2\\.0e\\+0\\n} 1 } } */\n /* { dg-final { scan-assembler-times {\\tfmov\\tz[0-9]+\\.d, #3\\.0e\\+0\\n} 1 } } */\n \n-/* { dg-final { scan-assembler-times {\\tptrue\\tp[0-7]\\.b, vl256\\n} 2 } } */\n-/* { dg-final { scan-assembler-times {\\tptrue\\tp[0-7]\\.h, vl128\\n} 3 } } */\n-/* { dg-final { scan-assembler-times {\\tptrue\\tp[0-7]\\.s, vl64\\n} 3 } } */\n-/* { dg-final { scan-assembler-times {\\tptrue\\tp[0-7]\\.d, vl32\\n} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tptrue\\tp[0-7]\\.b, vl256\\n} 11 } } */\n \n /* { dg-final { scan-assembler-times {\\tst1b\\tz[0-9]+\\.b,} 2 } } */\n /* { dg-final { scan-assembler-times {\\tst1h\\tz[0-9]+\\.h,} 3 } } */"}, {"sha": "81b3f64529ab849256be29b3bb78220c38886f98", "filename": "gcc/testsuite/gcc.target/aarch64/sve/spill_4.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/678faefcab01f9e9eeb222852675b5a042aaf900/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fspill_4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/678faefcab01f9e9eeb222852675b5a042aaf900/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fspill_4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fspill_4.c?ref=678faefcab01f9e9eeb222852675b5a042aaf900", "patch": "@@ -24,9 +24,10 @@ TEST_LOOP (uint16_t, 0x1234);\n TEST_LOOP (uint32_t, 0x12345);\n TEST_LOOP (uint64_t, 0x123456);\n \n+/* { dg-final { scan-assembler-times {\\tptrue\\tp[0-9]+\\.b,} 6 } } */\n /* { dg-final { scan-assembler-not {\\tptrue\\tp[0-9]+\\.h,} } } */\n-/* { dg-final { scan-assembler-times {\\tptrue\\tp[0-9]+\\.s,} 3 } } */\n-/* { dg-final { scan-assembler-times {\\tptrue\\tp[0-9]+\\.d,} 3 } } */\n+/* { dg-final { scan-assembler-not {\\tptrue\\tp[0-9]+\\.s,} } } */\n+/* { dg-final { scan-assembler-not {\\tptrue\\tp[0-9]+\\.d,} } } */\n /* { dg-final { scan-assembler-times {\\tmov\\tz[0-9]+\\.h, w[0-9]+\\n} 3 } } */\n /* { dg-final { scan-assembler-times {\\tld1rw\\tz[0-9]+\\.s,} 3 } } */\n /* { dg-final { scan-assembler-times {\\tld1rd\\tz[0-9]+\\.d,} 3 } } */"}]}