{"sha": "bf190e8df270025e2d0729858c031eb4ef7d49d2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmYxOTBlOGRmMjcwMDI1ZTJkMDcyOTg1OGMwMzFlYjRlZjdkNDlkMg==", "commit": {"author": {"name": "Lawrence Crowl", "email": "crowl@google.com", "date": "2013-04-23T22:00:12Z"}, "committer": {"name": "Lawrence Crowl", "email": "crowl@gcc.gnu.org", "date": "2013-04-23T22:00:12Z"}, "message": "This patch extracts approved portions of the hash_table patches to the...\n\nThis patch extracts approved portions of the hash_table patches to\nthe cxx-conversion branch for files not under gcc/config.\n\nUpdate various hash tables from htab_t to hash_table.\nModify types and calls to match.\n\n* tree-ssa-coalesce.c'coalesce_list_d.list from htab_t to hash_table.\n\nFold coalesce_pair_map_hash and coalesce_pair_map_eq into new\nstruct coalesce_pair_hasher.\n\nRemoved struct coalesce_pair_iterator, as did not meet the hash_table\niterator interface and it provided no significant code reduction.\nThis leads to a change in the implementation of FOR_EACH_PARTITION_PAIR.\n\n* statistics.c'statistics_hashes\n\nFold hash_statistics_eq into new struct stats_counter_hasher.\n\n* hash-table.h'hash_table\n\nAdd documentation.\nAdd nested class iterator and methods to hash_table.\nAdd FOR_EACH_HASH_TABLE_ELEMENT implemented with those iterators.\nChange uses of FOR_EACH_HTAB_ELEMENT to FOR_EACH_HASH_TABLE_ELEMENT.\n\n* tree-ssa-sccvn.c'vn_tables_s.nary\n\nFold vn_nary_op_hash, vn_nary_op_eq into new struct vn_nary_op_hasher.\nAdd typedef vn_nary_op_table_type.\nAdd typedef vn_nary_op_iterator_type.\n\n* tree-ssa-sccvn.c'vn_tables_s.phis\n\nFold vn_phi_hash, free_phi into new struct vn_phi_hasher.\nAdd typedef vn_phi_table_type.\nAdd typedef vn_phi_iterator_type.\n\n* tree-ssa-sccvn.c'vn_tables_s.references\n\nFold vn_reference_hash, vn_reference_op_eq, free_reference\n  into new struct vn_reference_hasher.\nAdd typedef vn_reference_table_type.\nAdd typedef vn_reference_iterator_type.\n\n* tree-ssa-sccvn.c'constant_value_ids\n\nFold vn_constant_hash, vn_constant_eq into new struct vn_constant_hasher.\n\n* tree-into-ssa.c'var_infos\n\nFold var_info_hash, var_info_eq into new struct var_info_hasher.\n\n* tree-vectorizer.h'_loop_vec_info::peeling_htab\n\n* tree-vectorizer.h\n\nNew struct peel_info_hasher.\n\n* tree-vect-loop.c\n\nUpdate dependent calls and types to match.\n\n* tree-vect-data-refs.c\n\nFold vect_peeling_hash and vect_peeling_hash_eq into struct peel_info_hasher.\n\n* tree-ssa-reassoc.c'undistribute_ops_list::ctable\n\nFold oecount_hash and oecount_eq into new struct oecount_hasher.\n\n* tree-ssa-loop-im.c'memory_accesses.refs\n\nFold memref_hash and memref_eq into new struct mem_ref_hasher.\n\nTested on x86_64.\n\n\nIndex: gcc/ChangeLog\n\n2013-04-23  Lawrence Crowl  <crowl@google.com>\n\n\t* Makefile.in: Update as needed below.\n\n\t* hash-table.h (class hash_table):\n\tCorrect many methods with parameter types compare_type to the correct\n\tvalue_type.  (Correct code was unlikely to notice the change.)\n\t(hash_table::elements_with_deleted) New.\n\t(class hashtable::iterator): New.\n\t(hashtable::begin()): New.\n\t(hashtable::end()): New.\n\t(FOR_EACH_HASH_TABLE_ELEMENT): New.\n\n\t* statistics.c (statistics_hashes):\n\tChange type to hash_table.  Update dependent calls and types.\n\n\t* tree-into-ssa.c (var_infos):\n\tChange type to hash_table.  Update dependent calls and types.\n\n\t* tree-ssa-coalesce.c (struct coalesce_list_d.list):\n\tChange type to hash_table.  Update dependent calls and types.\n\n\t* tree-ssa-loop-im.c (struct mem_ref.refs):\n\tChange type to hash_table.  Update dependent calls and types.\n\n\t* tree-ssa-reassoc.c (undistribute_ops_list::ctable):\n\tChange type to hash_table.  Update dependent calls and types.\n\n\t* tree-ssa-sccvn.c (vn_tables_s::nary):\n\tChange type to hash_table.  Update dependent calls and types.\n\t(vn_tables_s::phis): Likewise.\n\t(vn_tables_s::references): Likewise.\n\n\t* tree-ssa-sccvn.h (vn_nary_op_eq): Update parameter and return types.\n\t(vn_reference_eq): Update parameter and return types.\n\n\t* tree-ssa-structalias.c (pointer_equiv_class_table):\n\tChange type to hash_table.  Update dependent calls and types.\n\t(location_equiv_class_table): Likewise.\n\n\t* tree-vect-data-refs.c: Consequential changes for making\n\tpeeling a hash_table.\n\n\t* tree-vect-loop.c (new_loop_vec_info): Dependent hash_table update.\n\t(destroy_loop_vec_info): Dependent hash_table update.\n\n\t* tree-vectorizer.h (peeling_htab):\n\tChange type to hash_table.  Update dependent calls and types.\n\nFrom-SVN: r198213", "tree": {"sha": "fd9e547e6ac26ffd9c7200538fb2582c9ab2c3dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fd9e547e6ac26ffd9c7200538fb2582c9ab2c3dc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bf190e8df270025e2d0729858c031eb4ef7d49d2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf190e8df270025e2d0729858c031eb4ef7d49d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bf190e8df270025e2d0729858c031eb4ef7d49d2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf190e8df270025e2d0729858c031eb4ef7d49d2/comments", "author": null, "committer": null, "parents": [{"sha": "4a8043c4e02c8c2517424722ba3055a159b93e87", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a8043c4e02c8c2517424722ba3055a159b93e87", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a8043c4e02c8c2517424722ba3055a159b93e87"}], "stats": {"total": 1311, "additions": 806, "deletions": 505}, "files": [{"sha": "f280abea5d4d37a55247268807b79504a410427e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf190e8df270025e2d0729858c031eb4ef7d49d2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf190e8df270025e2d0729858c031eb4ef7d49d2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bf190e8df270025e2d0729858c031eb4ef7d49d2", "patch": "@@ -1,3 +1,52 @@\n+2013-04-23  Lawrence Crowl  <crowl@google.com>\n+\n+\t* Makefile.in: Update as needed below.\n+\n+\t* hash-table.h (class hash_table):\n+\tCorrect many methods with parameter types compare_type to the correct\n+\tvalue_type.  (Correct code was unlikely to notice the change.)\n+\t(hash_table::elements_with_deleted) New.\n+\t(class hashtable::iterator): New.\n+\t(hashtable::begin()): New.\n+\t(hashtable::end()): New.\n+\t(FOR_EACH_HASH_TABLE_ELEMENT): New.\n+\n+\t* statistics.c (statistics_hashes):\n+\tChange type to hash_table.  Update dependent calls and types.\n+\n+\t* tree-into-ssa.c (var_infos):\n+\tChange type to hash_table.  Update dependent calls and types.\n+\n+\t* tree-ssa-coalesce.c (struct coalesce_list_d.list):\n+\tChange type to hash_table.  Update dependent calls and types.\n+\n+\t* tree-ssa-loop-im.c (struct mem_ref.refs):\n+\tChange type to hash_table.  Update dependent calls and types.\n+\n+\t* tree-ssa-reassoc.c (undistribute_ops_list::ctable):\n+\tChange type to hash_table.  Update dependent calls and types.\n+\n+\t* tree-ssa-sccvn.c (vn_tables_s::nary):\n+\tChange type to hash_table.  Update dependent calls and types.\n+\t(vn_tables_s::phis): Likewise.\n+\t(vn_tables_s::references): Likewise.\n+\n+\t* tree-ssa-sccvn.h (vn_nary_op_eq): Update parameter and return types.\n+\t(vn_reference_eq): Update parameter and return types.\n+\n+\t* tree-ssa-structalias.c (pointer_equiv_class_table):\n+\tChange type to hash_table.  Update dependent calls and types.\n+\t(location_equiv_class_table): Likewise.\n+\n+\t* tree-vect-data-refs.c: Consequential changes for making\n+\tpeeling a hash_table.\n+\n+\t* tree-vect-loop.c (new_loop_vec_info): Dependent hash_table update.\n+\t(destroy_loop_vec_info): Dependent hash_table update.\n+\n+\t* tree-vectorizer.h (peeling_htab):\n+\tChange type to hash_table.  Update dependent calls and types.\n+\n 2013-04-23  Shiva Chen  <shiva0217@gmail.com>\n \n         * lra-assigns.c (find_hard_regno_for): Use lra_reg_val_equal_p"}, {"sha": "84d96d29a1e8b2c781385f895d81c5b982e24119", "filename": "gcc/Makefile.in", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf190e8df270025e2d0729858c031eb4ef7d49d2/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf190e8df270025e2d0729858c031eb4ef7d49d2/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=bf190e8df270025e2d0729858c031eb4ef7d49d2", "patch": "@@ -966,7 +966,8 @@ GIMPLE_STREAMER_H = gimple-streamer.h $(LTO_STREAMER_H) $(BASIC_BLOCK_H) \\\n TREE_STREAMER_H = tree-streamer.h $(TREE_H) $(LTO_STREAMER_H) \\\n \t\t  $(STREAMER_HOOKS_H)\n STREAMER_HOOKS_H = streamer-hooks.h $(TREE_H)\n-TREE_VECTORIZER_H = tree-vectorizer.h $(TREE_DATA_REF_H) $(TARGET_H)\n+TREE_VECTORIZER_H = tree-vectorizer.h $(TREE_DATA_REF_H) $(TARGET_H) \\\n+\t$(HASH_TABLE_H)\n IPA_PROP_H = ipa-prop.h $(TREE_H) $(VEC_H) $(CGRAPH_H) $(GIMPLE_H) alloc-pool.h\n IPA_INLINE_H = ipa-inline.h $(IPA_PROP_H)\n GSTAB_H = gstab.h stab.def\n@@ -2255,7 +2256,7 @@ tree-ssa-structalias.o: tree-ssa-structalias.c \\\n    $(SYSTEM_H) $(CONFIG_H) coretypes.h $(TM_H) $(GGC_H) $(OBSTACK_H) $(BITMAP_H) \\\n    $(FLAGS_H) $(TM_P_H) $(BASIC_BLOCK_H) \\\n    $(DIAGNOSTIC_H) $(TREE_H) $(TREE_FLOW_H) $(TREE_INLINE_H) \\\n-   $(GIMPLE_H) $(HASHTAB_H) $(FUNCTION_H) $(CGRAPH_H) \\\n+   $(GIMPLE_H) $(HASH_TABLE_H) $(FUNCTION_H) $(CGRAPH_H) \\\n    $(TREE_PASS_H) alloc-pool.h $(SPLAY_TREE_H) $(PARAMS_H) \\\n    $(CGRAPH_H) $(ALIAS_H) pointer-set.h\n tree-ssa-uninit.o : tree-ssa-uninit.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n@@ -2275,7 +2276,7 @@ tree-into-ssa.o : tree-into-ssa.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    $(TREE_H) $(TM_P_H) $(DIAGNOSTIC_CORE_H) \\\n    $(FUNCTION_H) $(TM_H) coretypes.h \\\n    langhooks.h domwalk.h $(TREE_PASS_H) $(PARAMS_H) $(BASIC_BLOCK_H) \\\n-   $(BITMAP_H) $(CFGLOOP_H) $(FLAGS_H) $(HASHTAB_H) \\\n+   $(BITMAP_H) $(CFGLOOP_H) $(FLAGS_H) $(HASH_TABLE_H) \\\n    $(GIMPLE_H) $(TREE_INLINE_H) $(GIMPLE_PRETTY_PRINT_H)\n tree-ssa-ter.o : tree-ssa-ter.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    $(TREE_H) $(DIAGNOSTIC_H) $(TM_H) coretypes.h $(DUMPFILE_H) \\\n@@ -2374,7 +2375,7 @@ tree-ssa-pre.o : tree-ssa-pre.c $(TREE_FLOW_H) $(CONFIG_H) \\\n tree-ssa-sccvn.o : tree-ssa-sccvn.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(SYSTEM_H) $(TREE_H) $(DIAGNOSTIC_H) \\\n    $(TM_H) coretypes.h $(DUMPFILE_H) $(FLAGS_H) $(CFGLOOP_H) \\\n-   alloc-pool.h $(BASIC_BLOCK_H) $(BITMAP_H) $(HASHTAB_H) $(GIMPLE_H) \\\n+   alloc-pool.h $(BASIC_BLOCK_H) $(BITMAP_H) $(HASH_TABLE_H) $(GIMPLE_H) \\\n    $(TREE_INLINE_H) tree-ssa-propagate.h tree-ssa-sccvn.h \\\n    $(PARAMS_H) $(GIMPLE_PRETTY_PRINT_H) gimple-fold.h\n gimple-ssa-strength-reduction.o : gimple-ssa-strength-reduction.c $(CONFIG_H) \\\n@@ -2509,7 +2510,7 @@ tree-ssa-alias.o : tree-ssa-alias.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    pointer-set.h alloc-pool.h \\\n    $(TREE_PRETTY_PRINT_H)\n tree-ssa-reassoc.o : tree-ssa-reassoc.c $(TREE_FLOW_H) $(CONFIG_H) \\\n-   $(SYSTEM_H) $(TREE_H) $(DIAGNOSTIC_H) \\\n+   $(SYSTEM_H) $(HASH_TABLE_H) $(TREE_H) $(DIAGNOSTIC_H) \\\n    $(TM_H) coretypes.h $(TREE_PASS_H) $(FLAGS_H) \\\n    tree-iterator.h $(BASIC_BLOCK_H) $(GIMPLE_H) $(TREE_INLINE_H) \\\n    $(VEC_H) langhooks.h alloc-pool.h pointer-set.h $(CFGLOOP_H) \\\n@@ -2765,7 +2766,7 @@ function.o : function.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_ERROR_\n    $(TREE_PASS_H) $(DF_H) $(PARAMS_H) bb-reorder.h \\\n    $(COMMON_TARGET_H)\n statistics.o : statistics.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n-   $(TREE_PASS_H) $(TREE_DUMP_H) $(HASHTAB_H) statistics.h $(FUNCTION_H)\n+   $(TREE_PASS_H) $(TREE_DUMP_H) $(HASH_TABLE_H) statistics.h $(FUNCTION_H)\n stmt.o : stmt.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(DUMPFILE_H) $(TM_H) \\\n    $(RTL_H) \\\n    $(TREE_H) $(FLAGS_H) $(FUNCTION_H) insn-config.h hard-reg-set.h $(EXPR_H) \\"}, {"sha": "00637789923ea5a47955990a7787a7428a7a33b5", "filename": "gcc/hash-table.h", "status": "modified", "additions": 193, "deletions": 14, "changes": 207, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf190e8df270025e2d0729858c031eb4ef7d49d2/gcc%2Fhash-table.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf190e8df270025e2d0729858c031eb4ef7d49d2/gcc%2Fhash-table.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhash-table.h?ref=bf190e8df270025e2d0729858c031eb4ef7d49d2", "patch": "@@ -155,6 +155,47 @@ along with GCC; see the file COPYING3.  If not see\n \n       hash_table <pointer_hash <whatever_type>> whatever_type_hash_table;\n \n+\n+   HASH TABLE ITERATORS\n+\n+   The hash table provides standard C++ iterators.  For example, consider a\n+   hash table of some_info.  We wish to consume each element of the table:\n+\n+      extern void consume (some_info *);\n+\n+   We define a convenience typedef and the hash table:\n+\n+      typedef hash_table <some_info_hasher> info_table_type;\n+      info_table_type info_table;\n+\n+   Then we write the loop in typical C++ style:\n+\n+      for (info_table_type::iterator iter = info_table.begin ();\n+           iter != info_table.end ();\n+           ++iter)\n+        if ((*iter).status == INFO_READY)\n+          consume (&*iter);\n+\n+   Or with common sub-expression elimination:\n+\n+      for (info_table_type::iterator iter = info_table.begin ();\n+           iter != info_table.end ();\n+           ++iter)\n+        {\n+          some_info &elem = *iter;\n+          if (elem.status == INFO_READY)\n+            consume (&elem);\n+        }\n+\n+   One can also use a more typical GCC style:\n+\n+      typedef some_info *some_info_p;\n+      some_info *elem_ptr;\n+      info_table_type::iterator iter;\n+      FOR_EACH_HASH_TABLE_ELEMENT (info_table, elem_ptr, some_info_p, iter)\n+        if (elem_ptr->status == INFO_READY)\n+          consume (elem_ptr);\n+\n */\n \n \n@@ -368,6 +409,20 @@ class hash_table\n   typedef typename Descriptor::value_type value_type;\n   typedef typename Descriptor::compare_type compare_type;\n \n+  class iterator\n+  {\n+  public:\n+    inline iterator ();\n+    inline iterator (value_type **, value_type **);\n+    inline value_type &operator * ();\n+    void slide ();\n+    inline iterator &operator ++ ();\n+    inline bool operator != (const iterator &) const;\n+  private:\n+    value_type **slot_;\n+    value_type **limit_;\n+  };\n+\n private:\n   hash_table_control <value_type> *htab;\n \n@@ -379,19 +434,19 @@ class hash_table\n   void create (size_t initial_slots);\n   bool is_created ();\n   void dispose ();\n-  value_type *find (const compare_type *comparable);\n+  value_type *find (const value_type *value);\n   value_type *find_with_hash (const compare_type *comparable, hashval_t hash);\n-  value_type **find_slot (const compare_type *comparable,\n-\t\t\t  enum insert_option insert);\n+  value_type **find_slot (const value_type *value, enum insert_option insert);\n   value_type **find_slot_with_hash (const compare_type *comparable,\n \t\t\t\t    hashval_t hash, enum insert_option insert);\n   void empty ();\n   void clear_slot (value_type **slot);\n-  void remove_elt (const compare_type *comparable);\n+  void remove_elt (const value_type *value);\n   void remove_elt_with_hash (const compare_type *comparable, hashval_t hash);\n-  size_t size();\n-  size_t elements();\n-  double collisions();\n+  size_t size ();\n+  size_t elements ();\n+  size_t elements_with_deleted ();\n+  double collisions ();\n \n   template <typename Argument,\n \t    int (*Callback) (value_type **slot, Argument argument)>\n@@ -400,6 +455,9 @@ class hash_table\n   template <typename Argument,\n \t    int (*Callback) (value_type **slot, Argument argument)>\n   void traverse (Argument argument);\n+\n+  iterator begin();\n+  iterator end();\n };\n \n \n@@ -430,9 +488,9 @@ hash_table <Descriptor, Allocator>::is_created ()\n template <typename Descriptor,\n \t  template <typename Type> class Allocator>\n inline typename Descriptor::value_type *\n-hash_table <Descriptor, Allocator>::find (const compare_type *comparable)\n+hash_table <Descriptor, Allocator>::find (const value_type *value)\n {\n-  return find_with_hash (comparable, Descriptor::hash (comparable));\n+  return find_with_hash (value, Descriptor::hash (value));\n }\n \n \n@@ -442,9 +500,9 @@ template <typename Descriptor,\n \t  template <typename Type> class Allocator>\n inline typename Descriptor::value_type **\n hash_table <Descriptor, Allocator>\n-::find_slot (const compare_type *comparable, enum insert_option insert)\n+::find_slot (const value_type *value, enum insert_option insert)\n {\n-  return find_slot_with_hash (comparable, Descriptor::hash (comparable), insert);\n+  return find_slot_with_hash (value, Descriptor::hash (value), insert);\n }\n \n \n@@ -453,9 +511,9 @@ ::find_slot (const compare_type *comparable, enum insert_option insert)\n template <typename Descriptor,\n \t  template <typename Type> class Allocator>\n inline void\n-hash_table <Descriptor, Allocator>::remove_elt (const compare_type *comparable)\n+hash_table <Descriptor, Allocator>::remove_elt (const value_type *value)\n {\n-  remove_elt_with_hash (comparable, Descriptor::hash (comparable));\n+  remove_elt_with_hash (value, Descriptor::hash (value));\n }\n \n \n@@ -475,12 +533,23 @@ hash_table <Descriptor, Allocator>::size()\n template <typename Descriptor,\n \t  template <typename Type> class Allocator>\n inline size_t\n-hash_table <Descriptor, Allocator>::elements()\n+hash_table <Descriptor, Allocator>::elements ()\n {\n   return htab->n_elements - htab->n_deleted;\n }\n \n \n+/* Return the current number of elements in this hash table. */\n+\n+template <typename Descriptor,\n+\t  template <typename Type> class Allocator>\n+inline size_t\n+hash_table <Descriptor, Allocator>::elements_with_deleted ()\n+{\n+  return htab->n_elements;\n+}\n+\n+\n   /* Return the fraction of fixed collisions during all work with given\n      hash table. */\n \n@@ -881,4 +950,114 @@ hash_table <Descriptor, Allocator>::traverse (Argument argument)\n   traverse_noresize <Argument, Callback> (argument);\n }\n \n+\n+/* Iterator definitions.  */\n+\n+/* The default constructor produces the end value.  */\n+\n+template <typename Descriptor,\n+\t  template <typename Type> class Allocator>\n+inline\n+hash_table <Descriptor, Allocator>::iterator::iterator ()\n+: slot_ (NULL), limit_ (NULL)\n+{\n+}\n+\n+/* The parameterized constructor produces the begin value.  */\n+\n+template <typename Descriptor,\n+\t  template <typename Type> class Allocator>\n+inline\n+hash_table <Descriptor, Allocator>::iterator::iterator\n+   (value_type **slot, value_type **limit)\n+: slot_ (slot), limit_ (limit)\n+{\n+}\n+\n+/* Obtain the element.  */\n+\n+template <typename Descriptor,\n+\t  template <typename Type> class Allocator>\n+inline typename hash_table <Descriptor, Allocator>::value_type &\n+hash_table <Descriptor, Allocator>::iterator::operator * ()\n+{\n+  return **slot_;\n+}\n+\n+/* Slide down the iterator slots until an active entry is found.  */\n+\n+template <typename Descriptor,\n+\t  template <typename Type> class Allocator>\n+void\n+hash_table <Descriptor, Allocator>::iterator::slide ()\n+{\n+  for ( ; slot_ < limit_; ++slot_ )\n+    {\n+      value_type *x = *slot_;\n+      if (x != HTAB_EMPTY_ENTRY && x != HTAB_DELETED_ENTRY)\n+        return;\n+    }\n+  slot_ = NULL;\n+  limit_ = NULL;\n+}\n+\n+/* Bump the iterator.  */\n+\n+template <typename Descriptor,\n+\t  template <typename Type> class Allocator>\n+inline typename hash_table <Descriptor, Allocator>::iterator &\n+hash_table <Descriptor, Allocator>::iterator::operator ++ ()\n+{\n+  ++slot_;\n+  slide ();\n+  return *this;\n+}\n+\n+/* Compare iterators.  */\n+\n+template <typename Descriptor,\n+\t  template <typename Type> class Allocator>\n+inline bool\n+hash_table <Descriptor, Allocator>::iterator::\n+  operator != (const iterator &other) const\n+{\n+  return slot_ != other.slot_ || limit_ != other.limit_;\n+}\n+\n+/* Hash table iterator producers.  */\n+\n+/* The beginning of a hash table iteration.  */\n+\n+template <typename Descriptor,\n+\t  template <typename Type> class Allocator>\n+inline typename hash_table <Descriptor, Allocator>::iterator\n+hash_table <Descriptor, Allocator>::begin ()\n+{\n+  iterator hti (htab->entries, htab->entries + htab->size);\n+  hti.slide ();\n+  return hti;\n+}\n+\n+/* The end of a hash table iteration.  */\n+\n+template <typename Descriptor,\n+\t  template <typename Type> class Allocator>\n+inline typename hash_table <Descriptor, Allocator>::iterator\n+hash_table <Descriptor, Allocator>::end ()\n+{\n+  return iterator ();\n+}\n+\n+/* Iterate through the elements of hash_table HTAB,\n+   using hash_table <....>::iterator ITER,\n+   storing each element in RESULT, which is of type TYPE.\n+\n+   This macro has this form for compatibility with the\n+   FOR_EACH_HTAB_ELEMENT currently defined in tree-flow.h.  */\n+\n+#define FOR_EACH_HASH_TABLE_ELEMENT(HTAB, RESULT, TYPE, ITER) \\\n+  for ((ITER) = (HTAB).begin (); \\\n+       (ITER) != (HTAB).end () ? (RESULT = &*(ITER) , true) : false; \\\n+       ++(ITER))\n+\n #endif /* TYPED_HASHTAB_H */"}, {"sha": "3077cc0c36ce5e7dd8751259054f08be20ad6bdc", "filename": "gcc/statistics.c", "status": "modified", "additions": 59, "deletions": 46, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf190e8df270025e2d0729858c031eb4ef7d49d2/gcc%2Fstatistics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf190e8df270025e2d0729858c031eb4ef7d49d2/gcc%2Fstatistics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstatistics.c?ref=bf190e8df270025e2d0729858c031eb4ef7d49d2", "patch": "@@ -24,7 +24,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-pass.h\"\n #include \"tree-dump.h\"\n #include \"statistics.h\"\n-#include \"hashtab.h\"\n+#include \"hash-table.h\"\n #include \"function.h\"\n \n static int statistics_dump_nr;\n@@ -42,42 +42,52 @@ typedef struct statistics_counter_s {\n   unsigned HOST_WIDE_INT prev_dumped_count;\n } statistics_counter_t;\n \n-/* Array of statistic hashes, indexed by pass id.  */\n-static htab_t *statistics_hashes;\n-static unsigned nr_statistics_hashes;\n+/* Hashtable helpers.  */\n+\n+struct stats_counter_hasher\n+{\n+  typedef statistics_counter_t value_type;\n+  typedef statistics_counter_t compare_type;\n+  static inline hashval_t hash (const value_type *);\n+  static inline bool equal (const value_type *, const compare_type *);\n+  static inline void remove (value_type *);\n+};\n \n /* Hash a statistic counter by its string ID.  */\n \n-static hashval_t\n-hash_statistics_hash (const void *p)\n+inline hashval_t\n+stats_counter_hasher::hash (const value_type *c)\n {\n-  const statistics_counter_t *const c = (const statistics_counter_t *)p;\n   return htab_hash_string (c->id) + c->val;\n }\n \n /* Compare two statistic counters by their string IDs.  */\n \n-static int\n-hash_statistics_eq (const void *p, const void *q)\n+inline bool\n+stats_counter_hasher::equal (const value_type *c1, const compare_type *c2)\n {\n-  const statistics_counter_t *const c1 = (const statistics_counter_t *)p;\n-  const statistics_counter_t *const c2 = (const statistics_counter_t *)q;\n   return c1->val == c2->val && strcmp (c1->id, c2->id) == 0;\n }\n \n /* Free a statistics entry.  */\n \n-static void\n-hash_statistics_free (void *p)\n+inline void\n+stats_counter_hasher::remove (value_type *v)\n {\n-  free (CONST_CAST(char *, ((statistics_counter_t *)p)->id));\n-  free (p);\n+  free (CONST_CAST(char *, v->id));\n+  free (v);\n }\n \n+typedef hash_table <stats_counter_hasher> stats_counter_table_type;\n+\n+/* Array of statistic hashes, indexed by pass id.  */\n+static stats_counter_table_type *statistics_hashes;\n+static unsigned nr_statistics_hashes;\n+\n /* Return the current hashtable to be used for recording or printing\n    statistics.  */\n \n-static htab_t\n+static stats_counter_table_type\n curr_statistics_hash (void)\n {\n   unsigned idx;\n@@ -86,31 +96,32 @@ curr_statistics_hash (void)\n   idx = current_pass->static_pass_number;\n \n   if (idx < nr_statistics_hashes\n-      && statistics_hashes[idx] != NULL)\n+      && statistics_hashes[idx].is_created ())\n     return statistics_hashes[idx];\n \n   if (idx >= nr_statistics_hashes)\n     {\n-      statistics_hashes = XRESIZEVEC (struct htab *, statistics_hashes, idx+1);\n+      statistics_hashes = XRESIZEVEC (stats_counter_table_type,\n+\t\t\t\t      statistics_hashes, idx+1);\n       memset (statistics_hashes + nr_statistics_hashes, 0,\n-\t      (idx + 1 - nr_statistics_hashes) * sizeof (htab_t));\n+\t      (idx + 1 - nr_statistics_hashes)\n+\t      * sizeof (stats_counter_table_type));\n       nr_statistics_hashes = idx + 1;\n     }\n \n-  statistics_hashes[idx] = htab_create (15, hash_statistics_hash,\n-\t\t\t\t\thash_statistics_eq,\n-\t\t\t\t\thash_statistics_free);\n+  statistics_hashes[idx].create (15);\n \n   return statistics_hashes[idx];\n }\n \n /* Helper for statistics_fini_pass.  Print the counter difference\n    since the last dump for the pass dump files.  */\n \n-static int\n-statistics_fini_pass_1 (void **slot, void *data ATTRIBUTE_UNUSED)\n+int\n+statistics_fini_pass_1 (statistics_counter_t **slot,\n+\t\t\tvoid *data ATTRIBUTE_UNUSED)\n {\n-  statistics_counter_t *counter = (statistics_counter_t *)*slot;\n+  statistics_counter_t *counter = *slot;\n   unsigned HOST_WIDE_INT count = counter->count - counter->prev_dumped_count;\n   if (count == 0)\n     return 1;\n@@ -127,10 +138,11 @@ statistics_fini_pass_1 (void **slot, void *data ATTRIBUTE_UNUSED)\n /* Helper for statistics_fini_pass.  Print the counter difference\n    since the last dump for the statistics dump.  */\n \n-static int\n-statistics_fini_pass_2 (void **slot, void *data ATTRIBUTE_UNUSED)\n+int\n+statistics_fini_pass_2 (statistics_counter_t **slot,\n+\t\t\tvoid *data ATTRIBUTE_UNUSED)\n {\n-  statistics_counter_t *counter = (statistics_counter_t *)*slot;\n+  statistics_counter_t *counter = *slot;\n   unsigned HOST_WIDE_INT count = counter->count - counter->prev_dumped_count;\n   if (count == 0)\n     return 1;\n@@ -157,10 +169,11 @@ statistics_fini_pass_2 (void **slot, void *data ATTRIBUTE_UNUSED)\n \n /* Helper for statistics_fini_pass, reset the counters.  */\n \n-static int\n-statistics_fini_pass_3 (void **slot, void *data ATTRIBUTE_UNUSED)\n+int\n+statistics_fini_pass_3 (statistics_counter_t **slot,\n+\t\t\tvoid *data ATTRIBUTE_UNUSED)\n {\n-  statistics_counter_t *counter = (statistics_counter_t *)*slot;\n+  statistics_counter_t *counter = *slot;\n   counter->prev_dumped_count = counter->count;\n   return 1;\n }\n@@ -179,26 +192,25 @@ statistics_fini_pass (void)\n       fprintf (dump_file, \"\\n\");\n       fprintf (dump_file, \"Pass statistics:\\n\");\n       fprintf (dump_file, \"----------------\\n\");\n-      htab_traverse_noresize (curr_statistics_hash (),\n-\t\t\t      statistics_fini_pass_1, NULL);\n+      curr_statistics_hash ()\n+\t.traverse_noresize <void *, statistics_fini_pass_1> (NULL);\n       fprintf (dump_file, \"\\n\");\n     }\n   if (statistics_dump_file\n       && !(statistics_dump_flags & TDF_STATS\n \t   || statistics_dump_flags & TDF_DETAILS))\n-    htab_traverse_noresize (curr_statistics_hash (),\n-\t\t\t    statistics_fini_pass_2, NULL);\n-  htab_traverse_noresize (curr_statistics_hash (),\n-\t\t\t  statistics_fini_pass_3, NULL);\n+    curr_statistics_hash ()\n+      .traverse_noresize <void *, statistics_fini_pass_2> (NULL);\n+  curr_statistics_hash ()\n+    .traverse_noresize <void *, statistics_fini_pass_3> (NULL);\n }\n \n /* Helper for printing summary information.  */\n \n-static int\n-statistics_fini_1 (void **slot, void *data)\n+int\n+statistics_fini_1 (statistics_counter_t **slot, opt_pass *pass)\n {\n-  struct opt_pass *pass = (struct opt_pass *)data;\n-  statistics_counter_t *counter = (statistics_counter_t *)*slot;\n+  statistics_counter_t *counter = *slot;\n   if (counter->count == 0)\n     return 1;\n   if (counter->histogram_p)\n@@ -230,10 +242,11 @@ statistics_fini (void)\n     {\n       unsigned i;\n       for (i = 0; i < nr_statistics_hashes; ++i)\n-\tif (statistics_hashes[i] != NULL\n+\tif (statistics_hashes[i].is_created ()\n \t    && get_pass_for_id (i) != NULL)\n-\t  htab_traverse_noresize (statistics_hashes[i],\n-\t\t\t\t  statistics_fini_1, get_pass_for_id (i));\n+\t  statistics_hashes[i]\n+\t    .traverse_noresize <opt_pass *, statistics_fini_1>\n+\t    (get_pass_for_id (i));\n     }\n \n   dump_end (statistics_dump_nr, statistics_dump_file);\n@@ -261,14 +274,14 @@ statistics_init (void)\n    and HISTOGRAM_P.  */\n \n static statistics_counter_t *\n-lookup_or_add_counter (htab_t hash, const char *id, int val,\n+lookup_or_add_counter (stats_counter_table_type hash, const char *id, int val,\n \t\t       bool histogram_p)\n {\n   statistics_counter_t **counter;\n   statistics_counter_t c;\n   c.id = id;\n   c.val = val;\n-  counter = (statistics_counter_t **) htab_find_slot (hash, &c, INSERT);\n+  counter = hash.find_slot (&c, INSERT);\n   if (!*counter)\n     {\n       *counter = XNEW (struct statistics_counter_s);"}, {"sha": "f028b25b19a0df9562c2faa43d704a0ed60041ec", "filename": "gcc/tree-into-ssa.c", "status": "modified", "additions": 48, "deletions": 46, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf190e8df270025e2d0729858c031eb4ef7d49d2/gcc%2Ftree-into-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf190e8df270025e2d0729858c031eb4ef7d49d2/gcc%2Ftree-into-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-into-ssa.c?ref=bf190e8df270025e2d0729858c031eb4ef7d49d2", "patch": "@@ -33,7 +33,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-flow.h\"\n #include \"gimple.h\"\n #include \"tree-inline.h\"\n-#include \"hashtab.h\"\n+#include \"hash-table.h\"\n #include \"tree-pass.h\"\n #include \"cfgloop.h\"\n #include \"domwalk.h\"\n@@ -160,9 +160,32 @@ struct var_info_d\n typedef struct var_info_d *var_info_p;\n \n \n+/* VAR_INFOS hashtable helpers.  */\n+\n+struct var_info_hasher : typed_free_remove <var_info_d>\n+{\n+  typedef var_info_d value_type;\n+  typedef var_info_d compare_type;\n+  static inline hashval_t hash (const value_type *);\n+  static inline bool equal (const value_type *, const compare_type *);\n+};\n+\n+inline hashval_t\n+var_info_hasher::hash (const value_type *p)\n+{\n+  return DECL_UID (p->var);\n+}\n+\n+inline bool\n+var_info_hasher::equal (const value_type *p1, const compare_type *p2)\n+{\n+  return p1->var == p2->var;\n+}\n+\n+\n /* Each entry in VAR_INFOS contains an element of type STRUCT \n    VAR_INFO_D.  */\n-static htab_t var_infos;\n+static hash_table <var_info_hasher> var_infos;\n \n \n /* Information stored for SSA names.  */\n@@ -340,17 +363,17 @@ static inline var_info_p\n get_var_info (tree decl)\n {\n   struct var_info_d vi;\n-  void **slot;\n+  var_info_d **slot;\n   vi.var = decl;\n-  slot = htab_find_slot_with_hash (var_infos, &vi, DECL_UID (decl), INSERT);\n+  slot = var_infos.find_slot_with_hash (&vi, DECL_UID (decl), INSERT);\n   if (*slot == NULL)\n     {\n       var_info_p v = XCNEW (struct var_info_d);\n       v->var = decl;\n-      *slot = (void *)v;\n+      *slot = v;\n       return v;\n     }\n-  return (var_info_p) *slot;\n+  return *slot;\n }\n \n \n@@ -1044,15 +1067,15 @@ insert_phi_nodes_compare_var_infos (const void *a, const void *b)\n static void\n insert_phi_nodes (bitmap_head *dfs)\n {\n-  htab_iterator hi;\n+  hash_table <var_info_hasher>::iterator hi;\n   unsigned i;\n   var_info_p info;\n   vec<var_info_p> vars;\n \n   timevar_push (TV_TREE_INSERT_PHI_NODES);\n \n-  vars.create (htab_elements (var_infos));\n-  FOR_EACH_HTAB_ELEMENT (var_infos, info, var_info_p, hi)\n+  vars.create (var_infos.elements ());\n+  FOR_EACH_HASH_TABLE_ELEMENT (var_infos, info, var_info_p, hi)\n     if (info->info.need_phi_state != NEED_PHI_STATE_NO)\n       vars.quick_push (info);\n \n@@ -1632,12 +1655,12 @@ debug_tree_ssa (void)\n /* Dump statistics for the hash table HTAB.  */\n \n static void\n-htab_statistics (FILE *file, htab_t htab)\n+htab_statistics (FILE *file, hash_table <var_info_hasher> htab)\n {\n   fprintf (file, \"size %ld, %ld elements, %f collision/search ratio\\n\",\n-\t   (long) htab_size (htab),\n-\t   (long) htab_elements (htab),\n-\t   htab_collisions (htab));\n+\t   (long) htab.size (),\n+\t   (long) htab.elements (),\n+\t   htab.collisions ());\n }\n \n \n@@ -1646,7 +1669,7 @@ htab_statistics (FILE *file, htab_t htab)\n void\n dump_tree_ssa_stats (FILE *file)\n {\n-  if (var_infos)\n+  if (var_infos.is_created ())\n     {\n       fprintf (file, \"\\nHash table statistics:\\n\");\n       fprintf (file, \"    var_infos:   \");\n@@ -1665,29 +1688,12 @@ debug_tree_ssa_stats (void)\n }\n \n \n-/* Hashing and equality functions for VAR_INFOS.  */\n-\n-static hashval_t\n-var_info_hash (const void *p)\n-{\n-  return DECL_UID (((const struct var_info_d *)p)->var);\n-}\n-\n-static int\n-var_info_eq (const void *p1, const void *p2)\n-{\n-  return ((const struct var_info_d *)p1)->var\n-\t == ((const struct var_info_d *)p2)->var;\n-}\n-\n-\n /* Callback for htab_traverse to dump the VAR_INFOS hash table.  */\n \n-static int\n-debug_var_infos_r (void **slot, void *data)\n+int\n+debug_var_infos_r (var_info_d **slot, FILE *file)\n {\n-  FILE *file = (FILE *) data;\n-  struct var_info_d *info = (struct var_info_d *) *slot;\n+  struct var_info_d *info = *slot;\n \n   fprintf (file, \"VAR: \");\n   print_generic_expr (file, info->var, dump_flags);\n@@ -1708,8 +1714,8 @@ void\n dump_var_infos (FILE *file)\n {\n   fprintf (file, \"\\n\\nDefinition and live-in blocks:\\n\\n\");\n-  if (var_infos)\n-    htab_traverse (var_infos, debug_var_infos_r, file);\n+  if (var_infos.is_created ())\n+    var_infos.traverse <FILE *, debug_var_infos_r> (file);\n }\n \n \n@@ -2216,7 +2222,7 @@ rewrite_blocks (basic_block entry, enum rewrite_mode what)\n   if (dump_file && (dump_flags & TDF_STATS))\n     {\n       dump_dfa_stats (dump_file);\n-      if (var_infos)\n+      if (var_infos.is_created ())\n \tdump_tree_ssa_stats (dump_file);\n     }\n \n@@ -2296,9 +2302,8 @@ init_ssa_renamer (void)\n   cfun->gimple_df->in_ssa_p = false;\n \n   /* Allocate memory for the DEF_BLOCKS hash table.  */\n-  gcc_assert (var_infos == NULL);\n-  var_infos = htab_create (vec_safe_length (cfun->local_decls),\n-\t\t\t   var_info_hash, var_info_eq, free);\n+  gcc_assert (!var_infos.is_created ());\n+  var_infos.create (vec_safe_length (cfun->local_decls));\n \n   bitmap_obstack_initialize (&update_ssa_obstack);\n }\n@@ -2309,11 +2314,8 @@ init_ssa_renamer (void)\n static void\n fini_ssa_renamer (void)\n {\n-  if (var_infos)\n-    {\n-      htab_delete (var_infos);\n-      var_infos = NULL;\n-    }\n+  if (var_infos.is_created ())\n+    var_infos.dispose ();\n \n   bitmap_obstack_release (&update_ssa_obstack);\n \n@@ -3189,7 +3191,7 @@ update_ssa (unsigned update_flags)\n     {\n       /* If we rename bare symbols initialize the mapping to\n          auxiliar info we need to keep track of.  */\n-      var_infos = htab_create (47, var_info_hash, var_info_eq, free);\n+      var_infos.create (47);\n \n       /* If we have to rename some symbols from scratch, we need to\n \t start the process at the root of the CFG.  FIXME, it should"}, {"sha": "354b5f182a8bb28cef73d8dffe025fb4ebfb37ae", "filename": "gcc/tree-ssa-coalesce.c", "status": "modified", "additions": 47, "deletions": 83, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf190e8df270025e2d0729858c031eb4ef7d49d2/gcc%2Ftree-ssa-coalesce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf190e8df270025e2d0729858c031eb4ef7d49d2/gcc%2Ftree-ssa-coalesce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-coalesce.c?ref=bf190e8df270025e2d0729858c031eb4ef7d49d2", "patch": "@@ -49,6 +49,41 @@ typedef struct coalesce_pair\n } * coalesce_pair_p;\n typedef const struct coalesce_pair *const_coalesce_pair_p;\n \n+/* Coalesce pair hashtable helpers.  */\n+\n+struct coalesce_pair_hasher : typed_noop_remove <coalesce_pair>\n+{\n+  typedef coalesce_pair value_type;\n+  typedef coalesce_pair compare_type;\n+  static inline hashval_t hash (const value_type *);\n+  static inline bool equal (const value_type *, const compare_type *);\n+};\n+\n+/* Hash function for coalesce list.  Calculate hash for PAIR.   */\n+\n+inline hashval_t\n+coalesce_pair_hasher::hash (const value_type *pair)\n+{\n+  hashval_t a = (hashval_t)(pair->first_element);\n+  hashval_t b = (hashval_t)(pair->second_element);\n+\n+  return b * (b - 1) / 2 + a;\n+}\n+\n+/* Equality function for coalesce list hash table.  Compare PAIR1 and PAIR2,\n+   returning TRUE if the two pairs are equivalent.  */\n+\n+inline bool\n+coalesce_pair_hasher::equal (const value_type *p1, const compare_type *p2)\n+{\n+  return (p1->first_element == p2->first_element\n+\t  && p1->second_element == p2->second_element);\n+}\n+\n+typedef hash_table <coalesce_pair_hasher> coalesce_table_type;\n+typedef coalesce_table_type::iterator coalesce_iterator_type;\n+\n+\n typedef struct cost_one_pair_d\n {\n   int first_element;\n@@ -60,7 +95,7 @@ typedef struct cost_one_pair_d\n \n typedef struct coalesce_list_d\n {\n-  htab_t list;\t\t\t/* Hash table.  */\n+  coalesce_table_type list;\t/* Hash table.  */\n   coalesce_pair_p *sorted;\t/* List when sorted.  */\n   int num_sorted;\t\t/* Number in the sorted list.  */\n   cost_one_pair_p cost_one_list;/* Single use coalesces with cost 1.  */\n@@ -185,34 +220,6 @@ pop_best_coalesce (coalesce_list_p cl, int *p1, int *p2)\n }\n \n \n-#define COALESCE_HASH_FN(R1, R2) ((R2) * ((R2) - 1) / 2 + (R1))\n-\n-/* Hash function for coalesce list.  Calculate hash for PAIR.   */\n-\n-static unsigned int\n-coalesce_pair_map_hash (const void *pair)\n-{\n-  hashval_t a = (hashval_t)(((const_coalesce_pair_p)pair)->first_element);\n-  hashval_t b = (hashval_t)(((const_coalesce_pair_p)pair)->second_element);\n-\n-  return COALESCE_HASH_FN (a,b);\n-}\n-\n-\n-/* Equality function for coalesce list hash table.  Compare PAIR1 and PAIR2,\n-   returning TRUE if the two pairs are equivalent.  */\n-\n-static int\n-coalesce_pair_map_eq (const void *pair1, const void *pair2)\n-{\n-  const_coalesce_pair_p const p1 = (const_coalesce_pair_p) pair1;\n-  const_coalesce_pair_p const p2 = (const_coalesce_pair_p) pair2;\n-\n-  return (p1->first_element == p2->first_element\n-\t  && p1->second_element == p2->second_element);\n-}\n-\n-\n /* Create a new empty coalesce list object and return it.  */\n \n static inline coalesce_list_p\n@@ -225,8 +232,7 @@ create_coalesce_list (void)\n     size = 40;\n \n   list = (coalesce_list_p) xmalloc (sizeof (struct coalesce_list_d));\n-  list->list = htab_create (size, coalesce_pair_map_hash,\n-  \t\t\t    coalesce_pair_map_eq, NULL);\n+  list->list.create (size);\n   list->sorted = NULL;\n   list->num_sorted = 0;\n   list->cost_one_list = NULL;\n@@ -240,7 +246,7 @@ static inline void\n delete_coalesce_list (coalesce_list_p cl)\n {\n   gcc_assert (cl->cost_one_list == NULL);\n-  htab_delete (cl->list);\n+  cl->list.dispose ();\n   free (cl->sorted);\n   gcc_assert (cl->num_sorted == 0);\n   free (cl);\n@@ -255,7 +261,7 @@ static coalesce_pair_p\n find_coalesce_pair (coalesce_list_p cl, int p1, int p2, bool create)\n {\n   struct coalesce_pair p;\n-  void **slot;\n+  coalesce_pair **slot;\n   unsigned int hash;\n \n   /* Normalize so that p1 is the smaller value.  */\n@@ -270,9 +276,8 @@ find_coalesce_pair (coalesce_list_p cl, int p1, int p2, bool create)\n       p.second_element = p2;\n     }\n \n-  hash = coalesce_pair_map_hash (&p);\n-  slot = htab_find_slot_with_hash (cl->list, &p, hash,\n-\t\t\t\t   create ? INSERT : NO_INSERT);\n+  hash = coalesce_pair_hasher::hash (&p);\n+  slot = cl->list.find_slot_with_hash (&p, hash, create ? INSERT : NO_INSERT);\n   if (!slot)\n     return NULL;\n \n@@ -283,7 +288,7 @@ find_coalesce_pair (coalesce_list_p cl, int p1, int p2, bool create)\n       pair->first_element = p.first_element;\n       pair->second_element = p.second_element;\n       pair->cost = 0;\n-      *slot = (void *)pair;\n+      *slot = pair;\n     }\n \n   return (struct coalesce_pair *) *slot;\n@@ -355,56 +360,14 @@ compare_pairs (const void *p1, const void *p2)\n static inline int\n num_coalesce_pairs (coalesce_list_p cl)\n {\n-  return htab_elements (cl->list);\n-}\n-\n-\n-/* Iterator over hash table pairs.  */\n-typedef struct\n-{\n-  htab_iterator hti;\n-} coalesce_pair_iterator;\n-\n-\n-/* Return first partition pair from list CL, initializing iterator ITER.  */\n-\n-static inline coalesce_pair_p\n-first_coalesce_pair (coalesce_list_p cl, coalesce_pair_iterator *iter)\n-{\n-  coalesce_pair_p pair;\n-\n-  pair = (coalesce_pair_p) first_htab_element (&(iter->hti), cl->list);\n-  return pair;\n-}\n-\n-\n-/* Return TRUE if there are no more partitions in for ITER to process.  */\n-\n-static inline bool\n-end_coalesce_pair_p (coalesce_pair_iterator *iter)\n-{\n-  return end_htab_p (&(iter->hti));\n-}\n-\n-\n-/* Return the next partition pair to be visited by ITER.  */\n-\n-static inline coalesce_pair_p\n-next_coalesce_pair (coalesce_pair_iterator *iter)\n-{\n-  coalesce_pair_p pair;\n-\n-  pair = (coalesce_pair_p) next_htab_element (&(iter->hti));\n-  return pair;\n+  return cl->list.elements ();\n }\n \n \n /* Iterate over CL using ITER, returning values in PAIR.  */\n \n #define FOR_EACH_PARTITION_PAIR(PAIR, ITER, CL)\t\t\\\n-  for ((PAIR) = first_coalesce_pair ((CL), &(ITER));\t\\\n-       !end_coalesce_pair_p (&(ITER));\t\t\t\\\n-       (PAIR) = next_coalesce_pair (&(ITER)))\n+  FOR_EACH_HASH_TABLE_ELEMENT ((CL)->list, (PAIR), coalesce_pair_p, (ITER))\n \n \n /* Prepare CL for removal of preferred pairs.  When finished they are sorted\n@@ -415,7 +378,7 @@ sort_coalesce_list (coalesce_list_p cl)\n {\n   unsigned x, num;\n   coalesce_pair_p p;\n-  coalesce_pair_iterator ppi;\n+  coalesce_iterator_type ppi;\n \n   gcc_assert (cl->sorted == NULL);\n \n@@ -461,7 +424,8 @@ static void\n dump_coalesce_list (FILE *f, coalesce_list_p cl)\n {\n   coalesce_pair_p node;\n-  coalesce_pair_iterator ppi;\n+  coalesce_iterator_type ppi;\n+\n   int x;\n   tree var;\n "}, {"sha": "90e4d361e2f7d6fe298ff6660bbdd37a7d41f38e", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 33, "deletions": 29, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf190e8df270025e2d0729858c031eb4ef7d49d2/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf190e8df270025e2d0729858c031eb4ef7d49d2/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=bf190e8df270025e2d0729858c031eb4ef7d49d2", "patch": "@@ -31,7 +31,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"params.h\"\n #include \"tree-pass.h\"\n #include \"flags.h\"\n-#include \"hashtab.h\"\n+#include \"hash-table.h\"\n #include \"tree-affine.h\"\n #include \"pointer-set.h\"\n #include \"tree-ssa-propagate.h\"\n@@ -133,14 +133,40 @@ typedef struct mem_ref\n    and its subloops.  */\n #define LOOP_DEP_BIT(loopnum, storedp) (2 * (loopnum) + (storedp ? 1 : 0))\n \n+/* Mem_ref hashtable helpers.  */\n+\n+struct mem_ref_hasher : typed_noop_remove <mem_ref>\n+{\n+  typedef mem_ref value_type;\n+  typedef tree_node compare_type;\n+  static inline hashval_t hash (const value_type *);\n+  static inline bool equal (const value_type *, const compare_type *);\n+};\n+\n+/* A hash function for struct mem_ref object OBJ.  */\n+\n+inline hashval_t\n+mem_ref_hasher::hash (const value_type *mem)\n+{\n+  return mem->hash;\n+}\n+\n+/* An equality function for struct mem_ref object MEM1 with\n+   memory reference OBJ2.  */\n+\n+inline bool\n+mem_ref_hasher::equal (const value_type *mem1, const compare_type *obj2)\n+{\n+  return operand_equal_p (mem1->mem.ref, (const_tree) obj2, 0);\n+}\n \n \n /* Description of memory accesses in loops.  */\n \n static struct\n {\n   /* The hash table of memory references accessed in loops.  */\n-  htab_t refs;\n+  hash_table <mem_ref_hasher> refs;\n \n   /* The list of memory references.  */\n   vec<mem_ref_p> refs_list;\n@@ -646,7 +672,7 @@ mem_ref_in_stmt (gimple stmt)\n   gcc_assert (!store);\n \n   hash = iterative_hash_expr (*mem, 0);\n-  ref = (mem_ref_p) htab_find_with_hash (memory_accesses.refs, *mem, hash);\n+  ref = memory_accesses.refs.find_with_hash (*mem, hash);\n \n   gcc_assert (ref != NULL);\n   return ref;\n@@ -1411,27 +1437,6 @@ force_move_till (tree ref, tree *index, void *data)\n   return true;\n }\n \n-/* A hash function for struct mem_ref object OBJ.  */\n-\n-static hashval_t\n-memref_hash (const void *obj)\n-{\n-  const struct mem_ref *const mem = (const struct mem_ref *) obj;\n-\n-  return mem->hash;\n-}\n-\n-/* An equality function for struct mem_ref object OBJ1 with\n-   memory reference OBJ2.  */\n-\n-static int\n-memref_eq (const void *obj1, const void *obj2)\n-{\n-  const struct mem_ref *const mem1 = (const struct mem_ref *) obj1;\n-\n-  return operand_equal_p (mem1->mem.ref, (const_tree) obj2, 0);\n-}\n-\n /* A function to free the mem_ref object OBJ.  */\n \n static void\n@@ -1502,7 +1507,7 @@ gather_mem_refs_stmt (struct loop *loop, gimple stmt)\n {\n   tree *mem = NULL;\n   hashval_t hash;\n-  PTR *slot;\n+  mem_ref **slot;\n   mem_ref_p ref;\n   bool is_stored;\n   unsigned id;\n@@ -1526,8 +1531,7 @@ gather_mem_refs_stmt (struct loop *loop, gimple stmt)\n   else\n     {\n       hash = iterative_hash_expr (*mem, 0);\n-      slot = htab_find_slot_with_hash (memory_accesses.refs,\n-\t\t\t\t       *mem, hash, INSERT);\n+      slot = memory_accesses.refs.find_slot_with_hash (*mem, hash, INSERT);\n       if (*slot)\n \t{\n \t  ref = (mem_ref_p) *slot;\n@@ -2553,7 +2557,7 @@ tree_ssa_lim_initialize (void)\n \n   alloc_aux_for_edges (0);\n \n-  memory_accesses.refs = htab_create (100, memref_hash, memref_eq, NULL);\n+  memory_accesses.refs.create (100);\n   memory_accesses.refs_list.create (100);\n   /* Allocate a special, unanalyzable mem-ref with ID zero.  */\n   memory_accesses.refs_list.quick_push\n@@ -2596,7 +2600,7 @@ tree_ssa_lim_finalize (void)\n   bitmap_obstack_release (&lim_bitmap_obstack);\n   pointer_map_destroy (lim_aux_data_map);\n \n-  htab_delete (memory_accesses.refs);\n+  memory_accesses.refs.dispose ();\n \n   FOR_EACH_VEC_ELT (memory_accesses.refs_list, i, ref)\n     memref_free (ref);"}, {"sha": "4fc19cb551eda29a067b2f656903ed6a03e3ff99", "filename": "gcc/tree-ssa-reassoc.c", "status": "modified", "additions": 22, "deletions": 8, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf190e8df270025e2d0729858c031eb4ef7d49d2/gcc%2Ftree-ssa-reassoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf190e8df270025e2d0729858c031eb4ef7d49d2/gcc%2Ftree-ssa-reassoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-reassoc.c?ref=bf190e8df270025e2d0729858c031eb4ef7d49d2", "patch": "@@ -21,6 +21,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"config.h\"\n #include \"system.h\"\n #include \"coretypes.h\"\n+#include \"hash-table.h\"\n #include \"tm.h\"\n #include \"tree.h\"\n #include \"basic-block.h\"\n@@ -943,19 +944,32 @@ typedef struct oecount_s {\n /* The heap for the oecount hashtable and the sorted list of operands.  */\n static vec<oecount> cvec;\n \n+\n+/* Oecount hashtable helpers.  */\n+\n+struct oecount_hasher : typed_noop_remove <void>\n+{\n+  /* Note that this hash table stores integers, not pointers.\n+     So, observe the casting in the member functions.  */\n+  typedef void value_type;\n+  typedef void compare_type;\n+  static inline hashval_t hash (const value_type *);\n+  static inline bool equal (const value_type *, const compare_type *);\n+};\n+\n /* Hash function for oecount.  */\n \n-static hashval_t\n-oecount_hash (const void *p)\n+inline hashval_t\n+oecount_hasher::hash (const value_type *p)\n {\n   const oecount *c = &cvec[(size_t)p - 42];\n   return htab_hash_pointer (c->op) ^ (hashval_t)c->oecode;\n }\n \n /* Comparison function for oecount.  */\n \n-static int\n-oecount_eq (const void *p1, const void *p2)\n+inline bool\n+oecount_hasher::equal (const value_type *p1, const compare_type *p2)\n {\n   const oecount *c1 = &cvec[(size_t)p1 - 42];\n   const oecount *c2 = &cvec[(size_t)p2 - 42];\n@@ -1257,7 +1271,7 @@ undistribute_ops_list (enum tree_code opcode,\n   unsigned nr_candidates, nr_candidates2;\n   sbitmap_iterator sbi0;\n   vec<operand_entry_t> *subops;\n-  htab_t ctable;\n+  hash_table <oecount_hasher> ctable;\n   bool changed = false;\n   int next_oecount_id = 0;\n \n@@ -1305,7 +1319,7 @@ undistribute_ops_list (enum tree_code opcode,\n \n   /* Build linearized sub-operand lists and the counting table.  */\n   cvec.create (0);\n-  ctable = htab_create (15, oecount_hash, oecount_eq, NULL);\n+  ctable.create (15);\n   /* ??? Macro arguments cannot have multi-argument template types in\n      them.  This typedef is needed to workaround that limitation.  */\n   typedef vec<operand_entry_t> vec_operand_entry_t_heap;\n@@ -1332,7 +1346,7 @@ undistribute_ops_list (enum tree_code opcode,\n \t  c.op = oe1->op;\n \t  cvec.safe_push (c);\n \t  idx = cvec.length () + 41;\n-\t  slot = htab_find_slot (ctable, (void *)idx, INSERT);\n+\t  slot = ctable.find_slot ((void *)idx, INSERT);\n \t  if (!*slot)\n \t    {\n \t      *slot = (void *)idx;\n@@ -1344,7 +1358,7 @@ undistribute_ops_list (enum tree_code opcode,\n \t    }\n \t}\n     }\n-  htab_delete (ctable);\n+  ctable.dispose ();\n \n   /* Sort the counting table.  */\n   cvec.qsort (oecount_cmp);"}, {"sha": "07bfdcccb81beb56075db9e133cc6360f38d6bd4", "filename": "gcc/tree-ssa-sccvn.c", "status": "modified", "additions": 245, "deletions": 183, "changes": 428, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf190e8df270025e2d0729858c031eb4ef7d49d2/gcc%2Ftree-ssa-sccvn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf190e8df270025e2d0729858c031eb4ef7d49d2/gcc%2Ftree-ssa-sccvn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.c?ref=bf190e8df270025e2d0729858c031eb4ef7d49d2", "patch": "@@ -29,7 +29,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-flow.h\"\n #include \"gimple.h\"\n #include \"dumpfile.h\"\n-#include \"hashtab.h\"\n+#include \"hash-table.h\"\n #include \"alloc-pool.h\"\n #include \"flags.h\"\n #include \"bitmap.h\"\n@@ -96,19 +96,187 @@ along with GCC; see the file COPYING3.  If not see\n    structure copies.\n */\n \n+\n+/* vn_nary_op hashtable helpers.  */\n+\n+struct vn_nary_op_hasher : typed_noop_remove <vn_nary_op_s>\n+{\n+  typedef vn_nary_op_s value_type;\n+  typedef vn_nary_op_s compare_type;\n+  static inline hashval_t hash (const value_type *);\n+  static inline bool equal (const value_type *, const compare_type *);\n+};\n+\n+/* Return the computed hashcode for nary operation P1.  */\n+\n+inline hashval_t\n+vn_nary_op_hasher::hash (const value_type *vno1)\n+{\n+  return vno1->hashcode;\n+}\n+\n+/* Compare nary operations P1 and P2 and return true if they are\n+   equivalent.  */\n+\n+inline bool\n+vn_nary_op_hasher::equal (const value_type *vno1, const compare_type *vno2)\n+{\n+  return vn_nary_op_eq (vno1, vno2);\n+}\n+\n+typedef hash_table <vn_nary_op_hasher> vn_nary_op_table_type;\n+typedef vn_nary_op_table_type::iterator vn_nary_op_iterator_type;\n+\n+\n+/* vn_phi hashtable helpers.  */\n+\n+static int\n+vn_phi_eq (const_vn_phi_t const vp1, const_vn_phi_t const vp2);\n+\n+struct vn_phi_hasher\n+{ \n+  typedef vn_phi_s value_type;\n+  typedef vn_phi_s compare_type;\n+  static inline hashval_t hash (const value_type *);\n+  static inline bool equal (const value_type *, const compare_type *);\n+  static inline void remove (value_type *);\n+};\n+\n+/* Return the computed hashcode for phi operation P1.  */\n+\n+inline hashval_t\n+vn_phi_hasher::hash (const value_type *vp1)\n+{\n+  return vp1->hashcode;\n+}\n+\n+/* Compare two phi entries for equality, ignoring VN_TOP arguments.  */\n+\n+inline bool\n+vn_phi_hasher::equal (const value_type *vp1, const compare_type *vp2)\n+{\n+  return vn_phi_eq (vp1, vp2);\n+}\n+\n+/* Free a phi operation structure VP.  */\n+\n+inline void\n+vn_phi_hasher::remove (value_type *phi)\n+{\n+  phi->phiargs.release ();\n+}\n+\n+typedef hash_table <vn_phi_hasher> vn_phi_table_type;\n+typedef vn_phi_table_type::iterator vn_phi_iterator_type;\n+\n+\n+/* Compare two reference operands P1 and P2 for equality.  Return true if\n+   they are equal, and false otherwise.  */\n+\n+static int\n+vn_reference_op_eq (const void *p1, const void *p2)\n+{\n+  const_vn_reference_op_t const vro1 = (const_vn_reference_op_t) p1;\n+  const_vn_reference_op_t const vro2 = (const_vn_reference_op_t) p2;\n+\n+  return (vro1->opcode == vro2->opcode\n+\t  /* We do not care for differences in type qualification.  */\n+\t  && (vro1->type == vro2->type\n+\t      || (vro1->type && vro2->type\n+\t\t  && types_compatible_p (TYPE_MAIN_VARIANT (vro1->type),\n+\t\t\t\t\t TYPE_MAIN_VARIANT (vro2->type))))\n+\t  && expressions_equal_p (vro1->op0, vro2->op0)\n+\t  && expressions_equal_p (vro1->op1, vro2->op1)\n+\t  && expressions_equal_p (vro1->op2, vro2->op2));\n+}\n+\n+/* Free a reference operation structure VP.  */\n+\n+static inline void\n+free_reference (vn_reference_s *vr)\n+{\n+  vr->operands.release ();\n+}\n+\n+\n+/* vn_reference hashtable helpers.  */\n+\n+struct vn_reference_hasher\n+{\n+  typedef vn_reference_s value_type;\n+  typedef vn_reference_s compare_type;\n+  static inline hashval_t hash (const value_type *);\n+  static inline bool equal (const value_type *, const compare_type *);\n+  static inline void remove (value_type *);\n+};\n+\n+/* Return the hashcode for a given reference operation P1.  */\n+\n+inline hashval_t\n+vn_reference_hasher::hash (const value_type *vr1)\n+{\n+  return vr1->hashcode;\n+}\n+\n+inline bool\n+vn_reference_hasher::equal (const value_type *v, const compare_type *c)\n+{\n+  return vn_reference_eq (v, c);\n+}\n+\n+inline void\n+vn_reference_hasher::remove (value_type *v)\n+{\n+  free_reference (v);\n+}\n+\n+typedef hash_table <vn_reference_hasher> vn_reference_table_type;\n+typedef vn_reference_table_type::iterator vn_reference_iterator_type;\n+\n+\n /* The set of hashtables and alloc_pool's for their items.  */\n \n typedef struct vn_tables_s\n {\n-  htab_t nary;\n-  htab_t phis;\n-  htab_t references;\n+  vn_nary_op_table_type nary;\n+  vn_phi_table_type phis;\n+  vn_reference_table_type references;\n   struct obstack nary_obstack;\n   alloc_pool phis_pool;\n   alloc_pool references_pool;\n } *vn_tables_t;\n \n-static htab_t constant_to_value_id;\n+\n+/* vn_constant hashtable helpers.  */\n+\n+struct vn_constant_hasher : typed_free_remove <vn_constant_s>\n+{ \n+  typedef vn_constant_s value_type;\n+  typedef vn_constant_s compare_type;\n+  static inline hashval_t hash (const value_type *);\n+  static inline bool equal (const value_type *, const compare_type *);\n+};\n+\n+/* Hash table hash function for vn_constant_t.  */\n+\n+inline hashval_t\n+vn_constant_hasher::hash (const value_type *vc1)\n+{\n+  return vc1->hashcode;\n+}\n+\n+/* Hash table equality function for vn_constant_t.  */\n+\n+inline bool\n+vn_constant_hasher::equal (const value_type *vc1, const compare_type *vc2)\n+{\n+  if (vc1->hashcode != vc2->hashcode)\n+    return false;\n+\n+  return vn_constant_eq_with_type (vc1->constant, vc2->constant);\n+}\n+\n+static hash_table <vn_constant_hasher> constant_to_value_id;\n static bitmap constant_value_ids;\n \n \n@@ -338,62 +506,20 @@ vn_get_stmt_kind (gimple stmt)\n     }\n }\n \n-/* Free a phi operation structure VP.  */\n-\n-static void\n-free_phi (void *vp)\n-{\n-  vn_phi_t phi = (vn_phi_t) vp;\n-  phi->phiargs.release ();\n-}\n-\n-/* Free a reference operation structure VP.  */\n-\n-static void\n-free_reference (void *vp)\n-{\n-  vn_reference_t vr = (vn_reference_t) vp;\n-  vr->operands.release ();\n-}\n-\n-/* Hash table equality function for vn_constant_t.  */\n-\n-static int\n-vn_constant_eq (const void *p1, const void *p2)\n-{\n-  const struct vn_constant_s *vc1 = (const struct vn_constant_s *) p1;\n-  const struct vn_constant_s *vc2 = (const struct vn_constant_s *) p2;\n-\n-  if (vc1->hashcode != vc2->hashcode)\n-    return false;\n-\n-  return vn_constant_eq_with_type (vc1->constant, vc2->constant);\n-}\n-\n-/* Hash table hash function for vn_constant_t.  */\n-\n-static hashval_t\n-vn_constant_hash (const void *p1)\n-{\n-  const struct vn_constant_s *vc1 = (const struct vn_constant_s *) p1;\n-  return vc1->hashcode;\n-}\n-\n /* Lookup a value id for CONSTANT and return it.  If it does not\n    exist returns 0.  */\n \n unsigned int\n get_constant_value_id (tree constant)\n {\n-  void **slot;\n+  vn_constant_s **slot;\n   struct vn_constant_s vc;\n \n   vc.hashcode = vn_hash_constant_with_type (constant);\n   vc.constant = constant;\n-  slot = htab_find_slot_with_hash (constant_to_value_id, &vc,\n-\t\t\t\t   vc.hashcode, NO_INSERT);\n+  slot = constant_to_value_id.find_slot_with_hash (&vc, vc.hashcode, NO_INSERT);\n   if (slot)\n-    return ((vn_constant_t)*slot)->value_id;\n+    return (*slot)->value_id;\n   return 0;\n }\n \n@@ -403,22 +529,21 @@ get_constant_value_id (tree constant)\n unsigned int\n get_or_alloc_constant_value_id (tree constant)\n {\n-  void **slot;\n+  vn_constant_s **slot;\n   struct vn_constant_s vc;\n   vn_constant_t vcp;\n \n   vc.hashcode = vn_hash_constant_with_type (constant);\n   vc.constant = constant;\n-  slot = htab_find_slot_with_hash (constant_to_value_id, &vc,\n-\t\t\t\t   vc.hashcode, INSERT);\n+  slot = constant_to_value_id.find_slot_with_hash (&vc, vc.hashcode, INSERT);\n   if (*slot)\n-    return ((vn_constant_t)*slot)->value_id;\n+    return (*slot)->value_id;\n \n   vcp = XNEW (struct vn_constant_s);\n   vcp->hashcode = vc.hashcode;\n   vcp->constant = constant;\n   vcp->value_id = get_next_value_id ();\n-  *slot = (void *) vcp;\n+  *slot = vcp;\n   bitmap_set_bit (constant_value_ids, vcp->value_id);\n   return vcp->value_id;\n }\n@@ -431,26 +556,6 @@ value_id_constant_p (unsigned int v)\n   return bitmap_bit_p (constant_value_ids, v);\n }\n \n-/* Compare two reference operands P1 and P2 for equality.  Return true if\n-   they are equal, and false otherwise.  */\n-\n-static int\n-vn_reference_op_eq (const void *p1, const void *p2)\n-{\n-  const_vn_reference_op_t const vro1 = (const_vn_reference_op_t) p1;\n-  const_vn_reference_op_t const vro2 = (const_vn_reference_op_t) p2;\n-\n-  return (vro1->opcode == vro2->opcode\n-\t  /* We do not care for differences in type qualification.  */\n-\t  && (vro1->type == vro2->type\n-\t      || (vro1->type && vro2->type\n-\t\t  && types_compatible_p (TYPE_MAIN_VARIANT (vro1->type),\n-\t\t\t\t\t TYPE_MAIN_VARIANT (vro2->type))))\n-\t  && expressions_equal_p (vro1->op0, vro2->op0)\n-\t  && expressions_equal_p (vro1->op1, vro2->op1)\n-\t  && expressions_equal_p (vro1->op2, vro2->op2));\n-}\n-\n /* Compute the hash for a reference operand VRO1.  */\n \n static hashval_t\n@@ -466,15 +571,6 @@ vn_reference_op_compute_hash (const vn_reference_op_t vro1, hashval_t result)\n   return result;\n }\n \n-/* Return the hashcode for a given reference operation P1.  */\n-\n-static hashval_t\n-vn_reference_hash (const void *p1)\n-{\n-  const_vn_reference_t const vr1 = (const_vn_reference_t) p1;\n-  return vr1->hashcode;\n-}\n-\n /* Compute a hash for the reference operation VR1 and return it.  */\n \n hashval_t\n@@ -524,16 +620,14 @@ vn_reference_compute_hash (const vn_reference_t vr1)\n   return result;\n }\n \n-/* Return true if reference operations P1 and P2 are equivalent.  This\n+/* Return true if reference operations VR1 and VR2 are equivalent.  This\n    means they have the same set of operands and vuses.  */\n \n-int\n-vn_reference_eq (const void *p1, const void *p2)\n+bool\n+vn_reference_eq (const_vn_reference_t const vr1, const_vn_reference_t const vr2)\n {\n   unsigned i, j;\n \n-  const_vn_reference_t const vr1 = (const_vn_reference_t) p1;\n-  const_vn_reference_t const vr2 = (const_vn_reference_t) p2;\n   if (vr1->hashcode != vr2->hashcode)\n     return false;\n \n@@ -1346,15 +1440,13 @@ valueize_shared_reference_ops_from_call (gimple call)\n static tree\n vn_reference_lookup_1 (vn_reference_t vr, vn_reference_t *vnresult)\n {\n-  void **slot;\n+  vn_reference_s **slot;\n   hashval_t hash;\n \n   hash = vr->hashcode;\n-  slot = htab_find_slot_with_hash (current_info->references, vr,\n-\t\t\t\t   hash, NO_INSERT);\n+  slot = current_info->references.find_slot_with_hash (vr, hash, NO_INSERT);\n   if (!slot && current_info == optimistic_info)\n-    slot = htab_find_slot_with_hash (valid_info->references, vr,\n-\t\t\t\t     hash, NO_INSERT);\n+    slot = valid_info->references.find_slot_with_hash (vr, hash, NO_INSERT);\n   if (slot)\n     {\n       if (vnresult)\n@@ -1377,7 +1469,7 @@ vn_reference_lookup_2 (ao_ref *op ATTRIBUTE_UNUSED, tree vuse,\n \t\t       unsigned int cnt, void *vr_)\n {\n   vn_reference_t vr = (vn_reference_t)vr_;\n-  void **slot;\n+  vn_reference_s **slot;\n   hashval_t hash;\n \n   /* This bounds the stmt walks we perform on reference lookups\n@@ -1397,11 +1489,9 @@ vn_reference_lookup_2 (ao_ref *op ATTRIBUTE_UNUSED, tree vuse,\n     vr->hashcode = vr->hashcode + SSA_NAME_VERSION (vr->vuse);\n \n   hash = vr->hashcode;\n-  slot = htab_find_slot_with_hash (current_info->references, vr,\n-\t\t\t\t   hash, NO_INSERT);\n+  slot = current_info->references.find_slot_with_hash (vr, hash, NO_INSERT);\n   if (!slot && current_info == optimistic_info)\n-    slot = htab_find_slot_with_hash (valid_info->references, vr,\n-\t\t\t\t     hash, NO_INSERT);\n+    slot = valid_info->references.find_slot_with_hash (vr, hash, NO_INSERT);\n   if (slot)\n     return *slot;\n \n@@ -2004,7 +2094,7 @@ vn_reference_lookup (tree op, tree vuse, vn_lookup_kind kind,\n vn_reference_t\n vn_reference_insert (tree op, tree result, tree vuse, tree vdef)\n {\n-  void **slot;\n+  vn_reference_s **slot;\n   vn_reference_t vr1;\n \n   vr1 = (vn_reference_t) pool_alloc (current_info->references_pool);\n@@ -2020,8 +2110,8 @@ vn_reference_insert (tree op, tree result, tree vuse, tree vdef)\n   vr1->result = TREE_CODE (result) == SSA_NAME ? SSA_VAL (result) : result;\n   vr1->result_vdef = vdef;\n \n-  slot = htab_find_slot_with_hash (current_info->references, vr1, vr1->hashcode,\n-\t\t\t\t   INSERT);\n+  slot = current_info->references.find_slot_with_hash (vr1, vr1->hashcode,\n+\t\t\t\t\t\t       INSERT);\n \n   /* Because we lookup stores using vuses, and value number failures\n      using the vdefs (see visit_reference_op_store for how and why),\n@@ -2049,7 +2139,7 @@ vn_reference_insert_pieces (tree vuse, alias_set_type set, tree type,\n \t\t\t    tree result, unsigned int value_id)\n \n {\n-  void **slot;\n+  vn_reference_s **slot;\n   vn_reference_t vr1;\n \n   vr1 = (vn_reference_t) pool_alloc (current_info->references_pool);\n@@ -2063,8 +2153,8 @@ vn_reference_insert_pieces (tree vuse, alias_set_type set, tree type,\n     result = SSA_VAL (result);\n   vr1->result = result;\n \n-  slot = htab_find_slot_with_hash (current_info->references, vr1, vr1->hashcode,\n-\t\t\t\t   INSERT);\n+  slot = current_info->references.find_slot_with_hash (vr1, vr1->hashcode,\n+\t\t\t\t\t\t       INSERT);\n \n   /* At this point we should have all the things inserted that we have\n      seen before, and we should never try inserting something that\n@@ -2105,23 +2195,12 @@ vn_nary_op_compute_hash (const vn_nary_op_t vno1)\n   return hash;\n }\n \n-/* Return the computed hashcode for nary operation P1.  */\n-\n-static hashval_t\n-vn_nary_op_hash (const void *p1)\n-{\n-  const_vn_nary_op_t const vno1 = (const_vn_nary_op_t) p1;\n-  return vno1->hashcode;\n-}\n-\n-/* Compare nary operations P1 and P2 and return true if they are\n+/* Compare nary operations VNO1 and VNO2 and return true if they are\n    equivalent.  */\n \n-int\n-vn_nary_op_eq (const void *p1, const void *p2)\n+bool\n+vn_nary_op_eq (const_vn_nary_op_t const vno1, const_vn_nary_op_t const vno2)\n {\n-  const_vn_nary_op_t const vno1 = (const_vn_nary_op_t) p1;\n-  const_vn_nary_op_t const vno2 = (const_vn_nary_op_t) p2;\n   unsigned i;\n \n   if (vno1->hashcode != vno2->hashcode)\n@@ -2238,22 +2317,20 @@ init_vn_nary_op_from_stmt (vn_nary_op_t vno, gimple stmt)\n static tree\n vn_nary_op_lookup_1 (vn_nary_op_t vno, vn_nary_op_t *vnresult)\n {\n-  void **slot;\n+  vn_nary_op_s **slot;\n \n   if (vnresult)\n     *vnresult = NULL;\n \n   vno->hashcode = vn_nary_op_compute_hash (vno);\n-  slot = htab_find_slot_with_hash (current_info->nary, vno, vno->hashcode,\n-\t\t\t\t   NO_INSERT);\n+  slot = current_info->nary.find_slot_with_hash (vno, vno->hashcode, NO_INSERT);\n   if (!slot && current_info == optimistic_info)\n-    slot = htab_find_slot_with_hash (valid_info->nary, vno, vno->hashcode,\n-\t\t\t\t     NO_INSERT);\n+    slot = valid_info->nary.find_slot_with_hash (vno, vno->hashcode, NO_INSERT);\n   if (!slot)\n     return NULL_TREE;\n   if (vnresult)\n-    *vnresult = (vn_nary_op_t)*slot;\n-  return ((vn_nary_op_t)*slot)->result;\n+    *vnresult = *slot;\n+  return (*slot)->result;\n }\n \n /* Lookup a n-ary operation by its pieces and return the resulting value\n@@ -2331,14 +2408,15 @@ alloc_vn_nary_op (unsigned int length, tree result, unsigned int value_id)\n    VNO->HASHCODE first.  */\n \n static vn_nary_op_t\n-vn_nary_op_insert_into (vn_nary_op_t vno, htab_t table, bool compute_hash)\n+vn_nary_op_insert_into (vn_nary_op_t vno, vn_nary_op_table_type table,\n+\t\t\tbool compute_hash)\n {\n-  void **slot;\n+  vn_nary_op_s **slot;\n \n   if (compute_hash)\n     vno->hashcode = vn_nary_op_compute_hash (vno);\n \n-  slot = htab_find_slot_with_hash (table, vno, vno->hashcode, INSERT);\n+  slot = table.find_slot_with_hash (vno, vno->hashcode, INSERT);\n   gcc_assert (!*slot);\n \n   *slot = vno;\n@@ -2414,23 +2492,11 @@ vn_phi_compute_hash (vn_phi_t vp1)\n   return result;\n }\n \n-/* Return the computed hashcode for phi operation P1.  */\n-\n-static hashval_t\n-vn_phi_hash (const void *p1)\n-{\n-  const_vn_phi_t const vp1 = (const_vn_phi_t) p1;\n-  return vp1->hashcode;\n-}\n-\n /* Compare two phi entries for equality, ignoring VN_TOP arguments.  */\n \n static int\n-vn_phi_eq (const void *p1, const void *p2)\n+vn_phi_eq (const_vn_phi_t const vp1, const_vn_phi_t const vp2)\n {\n-  const_vn_phi_t const vp1 = (const_vn_phi_t) p1;\n-  const_vn_phi_t const vp2 = (const_vn_phi_t) p2;\n-\n   if (vp1->hashcode != vp2->hashcode)\n     return false;\n \n@@ -2468,7 +2534,7 @@ static vec<tree> shared_lookup_phiargs;\n static tree\n vn_phi_lookup (gimple phi)\n {\n-  void **slot;\n+  vn_phi_s **slot;\n   struct vn_phi_s vp1;\n   unsigned i;\n \n@@ -2485,14 +2551,12 @@ vn_phi_lookup (gimple phi)\n   vp1.phiargs = shared_lookup_phiargs;\n   vp1.block = gimple_bb (phi);\n   vp1.hashcode = vn_phi_compute_hash (&vp1);\n-  slot = htab_find_slot_with_hash (current_info->phis, &vp1, vp1.hashcode,\n-\t\t\t\t   NO_INSERT);\n+  slot = current_info->phis.find_slot_with_hash (&vp1, vp1.hashcode, NO_INSERT);\n   if (!slot && current_info == optimistic_info)\n-    slot = htab_find_slot_with_hash (valid_info->phis, &vp1, vp1.hashcode,\n-\t\t\t\t     NO_INSERT);\n+    slot = valid_info->phis.find_slot_with_hash (&vp1, vp1.hashcode, NO_INSERT);\n   if (!slot)\n     return NULL_TREE;\n-  return ((vn_phi_t)*slot)->result;\n+  return (*slot)->result;\n }\n \n /* Insert PHI into the current hash table with a value number of\n@@ -2501,7 +2565,7 @@ vn_phi_lookup (gimple phi)\n static vn_phi_t\n vn_phi_insert (gimple phi, tree result)\n {\n-  void **slot;\n+  vn_phi_s **slot;\n   vn_phi_t vp1 = (vn_phi_t) pool_alloc (current_info->phis_pool);\n   unsigned i;\n   vec<tree> args = vNULL;\n@@ -2520,8 +2584,7 @@ vn_phi_insert (gimple phi, tree result)\n   vp1->result = result;\n   vp1->hashcode = vn_phi_compute_hash (vp1);\n \n-  slot = htab_find_slot_with_hash (current_info->phis, vp1, vp1->hashcode,\n-\t\t\t\t   INSERT);\n+  slot = current_info->phis.find_slot_with_hash (vp1, vp1->hashcode, INSERT);\n \n   /* Because we iterate over phi operations more than once, it's\n      possible the slot might already exist here, hence no assert.*/\n@@ -2724,7 +2787,7 @@ visit_reference_op_call (tree lhs, gimple stmt)\n     }\n   else\n     {\n-      void **slot;\n+      vn_reference_s **slot;\n       vn_reference_t vr2;\n       if (vdef)\n \tchanged |= set_ssa_val_to (vdef, vdef);\n@@ -2738,8 +2801,8 @@ visit_reference_op_call (tree lhs, gimple stmt)\n       vr2->hashcode = vr1.hashcode;\n       vr2->result = lhs;\n       vr2->result_vdef = vdef;\n-      slot = htab_find_slot_with_hash (current_info->references,\n-\t\t\t\t       vr2, vr2->hashcode, INSERT);\n+      slot = current_info->references.find_slot_with_hash (vr2, vr2->hashcode,\n+\t\t\t\t\t\t\t   INSERT);\n       if (*slot)\n \tfree_reference (*slot);\n       *slot = vr2;\n@@ -3599,10 +3662,10 @@ static void\n copy_phi (vn_phi_t ophi, vn_tables_t info)\n {\n   vn_phi_t phi = (vn_phi_t) pool_alloc (info->phis_pool);\n-  void **slot;\n+  vn_phi_s **slot;\n   memcpy (phi, ophi, sizeof (*phi));\n   ophi->phiargs.create (0);\n-  slot = htab_find_slot_with_hash (info->phis, phi, phi->hashcode, INSERT);\n+  slot = info->phis.find_slot_with_hash (phi, phi->hashcode, INSERT);\n   gcc_assert (!*slot);\n   *slot = phi;\n }\n@@ -3613,12 +3676,11 @@ static void\n copy_reference (vn_reference_t oref, vn_tables_t info)\n {\n   vn_reference_t ref;\n-  void **slot;\n+  vn_reference_s **slot;\n   ref = (vn_reference_t) pool_alloc (info->references_pool);\n   memcpy (ref, oref, sizeof (*ref));\n   oref->operands.create (0);\n-  slot = htab_find_slot_with_hash (info->references, ref, ref->hashcode,\n-\t\t\t\t   INSERT);\n+  slot = info->references.find_slot_with_hash (ref, ref->hashcode, INSERT);\n   if (*slot)\n     free_reference (*slot);\n   *slot = ref;\n@@ -3633,7 +3695,9 @@ process_scc (vec<tree> scc)\n   unsigned int i;\n   unsigned int iterations = 0;\n   bool changed = true;\n-  htab_iterator hi;\n+  vn_nary_op_iterator_type hin;\n+  vn_phi_iterator_type hip;\n+  vn_reference_iterator_type hir;\n   vn_nary_op_t nary;\n   vn_phi_t phi;\n   vn_reference_t ref;\n@@ -3670,9 +3734,9 @@ process_scc (vec<tree> scc)\n       /* As we are value-numbering optimistically we have to\n \t clear the expression tables and the simplified expressions\n \t in each iteration until we converge.  */\n-      htab_empty (optimistic_info->nary);\n-      htab_empty (optimistic_info->phis);\n-      htab_empty (optimistic_info->references);\n+      optimistic_info->nary.empty ();\n+      optimistic_info->phis.empty ();\n+      optimistic_info->references.empty ();\n       obstack_free (&optimistic_info->nary_obstack, NULL);\n       gcc_obstack_init (&optimistic_info->nary_obstack);\n       empty_alloc_pool (optimistic_info->phis_pool);\n@@ -3687,11 +3751,12 @@ process_scc (vec<tree> scc)\n \n   /* Finally, copy the contents of the no longer used optimistic\n      table to the valid table.  */\n-  FOR_EACH_HTAB_ELEMENT (optimistic_info->nary, nary, vn_nary_op_t, hi)\n+  FOR_EACH_HASH_TABLE_ELEMENT (optimistic_info->nary, nary, vn_nary_op_t, hin)\n     copy_nary (nary, valid_info);\n-  FOR_EACH_HTAB_ELEMENT (optimistic_info->phis, phi, vn_phi_t, hi)\n+  FOR_EACH_HASH_TABLE_ELEMENT (optimistic_info->phis, phi, vn_phi_t, hip)\n     copy_phi (phi, valid_info);\n-  FOR_EACH_HTAB_ELEMENT (optimistic_info->references, ref, vn_reference_t, hi)\n+  FOR_EACH_HASH_TABLE_ELEMENT (optimistic_info->references,\n+\t\t\t       ref, vn_reference_t, hir)\n     copy_reference (ref, valid_info);\n \n   current_info = valid_info;\n@@ -3851,10 +3916,9 @@ DFS (tree name)\n static void\n allocate_vn_table (vn_tables_t table)\n {\n-  table->phis = htab_create (23, vn_phi_hash, vn_phi_eq, free_phi);\n-  table->nary = htab_create (23, vn_nary_op_hash, vn_nary_op_eq, NULL);\n-  table->references = htab_create (23, vn_reference_hash, vn_reference_eq,\n-\t\t\t\t   free_reference);\n+  table->phis.create (23);\n+  table->nary.create (23);\n+  table->references.create (23);\n \n   gcc_obstack_init (&table->nary_obstack);\n   table->phis_pool = create_alloc_pool (\"VN phis\",\n@@ -3870,9 +3934,9 @@ allocate_vn_table (vn_tables_t table)\n static void\n free_vn_table (vn_tables_t table)\n {\n-  htab_delete (table->phis);\n-  htab_delete (table->nary);\n-  htab_delete (table->references);\n+  table->phis.dispose ();\n+  table->nary.dispose ();\n+  table->references.dispose ();\n   obstack_free (&table->nary_obstack, NULL);\n   free_alloc_pool (table->phis_pool);\n   free_alloc_pool (table->references_pool);\n@@ -3887,8 +3951,7 @@ init_scc_vn (void)\n \n   calculate_dominance_info (CDI_DOMINATORS);\n   sccstack.create (0);\n-  constant_to_value_id = htab_create (23, vn_constant_hash, vn_constant_eq,\n-\t\t\t\t  free);\n+  constant_to_value_id.create (23);\n \n   constant_value_ids = BITMAP_ALLOC (NULL);\n \n@@ -3944,7 +4007,7 @@ free_scc_vn (void)\n {\n   size_t i;\n \n-  htab_delete (constant_to_value_id);\n+  constant_to_value_id.dispose ();\n   BITMAP_FREE (constant_value_ids);\n   shared_lookup_phiargs.release ();\n   shared_lookup_references.release ();\n@@ -3985,24 +4048,23 @@ set_value_id_for_result (tree result, unsigned int *id)\n static void\n set_hashtable_value_ids (void)\n {\n-  htab_iterator hi;\n+  vn_nary_op_iterator_type hin;\n+  vn_phi_iterator_type hip;\n+  vn_reference_iterator_type hir;\n   vn_nary_op_t vno;\n   vn_reference_t vr;\n   vn_phi_t vp;\n \n   /* Now set the value ids of the things we had put in the hash\n      table.  */\n \n-  FOR_EACH_HTAB_ELEMENT (valid_info->nary,\n-\t\t\t vno, vn_nary_op_t, hi)\n+  FOR_EACH_HASH_TABLE_ELEMENT (valid_info->nary, vno, vn_nary_op_t, hin)\n     set_value_id_for_result (vno->result, &vno->value_id);\n \n-  FOR_EACH_HTAB_ELEMENT (valid_info->phis,\n-\t\t\t vp, vn_phi_t, hi)\n+  FOR_EACH_HASH_TABLE_ELEMENT (valid_info->phis, vp, vn_phi_t, hip)\n     set_value_id_for_result (vp->result, &vp->value_id);\n \n-  FOR_EACH_HTAB_ELEMENT (valid_info->references,\n-\t\t\t vr, vn_reference_t, hi)\n+  FOR_EACH_HASH_TABLE_ELEMENT (valid_info->references, vr, vn_reference_t, hir)\n     set_value_id_for_result (vr->result, &vr->value_id);\n }\n "}, {"sha": "94e3603f7406baaef67191dd5a16dbd90b8873f8", "filename": "gcc/tree-ssa-sccvn.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf190e8df270025e2d0729858c031eb4ef7d49d2/gcc%2Ftree-ssa-sccvn.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf190e8df270025e2d0729858c031eb4ef7d49d2/gcc%2Ftree-ssa-sccvn.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.h?ref=bf190e8df270025e2d0729858c031eb4ef7d49d2", "patch": "@@ -216,10 +216,11 @@ vn_reference_t vn_reference_insert_pieces (tree, alias_set_type, tree,\n \t\t\t\t\t   tree, unsigned int);\n \n hashval_t vn_nary_op_compute_hash (const vn_nary_op_t);\n-int vn_nary_op_eq (const void *, const void *);\n+bool vn_nary_op_eq (const_vn_nary_op_t const vno1,\n+\t\t    const_vn_nary_op_t const vno2);\n bool vn_nary_may_trap (vn_nary_op_t);\n hashval_t vn_reference_compute_hash (const vn_reference_t);\n-int vn_reference_eq (const void *, const void *);\n+bool vn_reference_eq (const_vn_reference_t const, const_vn_reference_t const);\n unsigned int get_max_value_id (void);\n unsigned int get_next_value_id (void);\n unsigned int get_constant_value_id (tree);"}, {"sha": "9eb06f6b09751e47b20065f0ac2694b405cd56f1", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 53, "deletions": 42, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf190e8df270025e2d0729858c031eb4ef7d49d2/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf190e8df270025e2d0729858c031eb4ef7d49d2/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=bf190e8df270025e2d0729858c031eb4ef7d49d2", "patch": "@@ -32,7 +32,7 @@\n #include \"tree-inline.h\"\n #include \"diagnostic-core.h\"\n #include \"gimple.h\"\n-#include \"hashtab.h\"\n+#include \"hash-table.h\"\n #include \"function.h\"\n #include \"cgraph.h\"\n #include \"tree-pass.h\"\n@@ -1862,48 +1862,54 @@ typedef struct equiv_class_label\n } *equiv_class_label_t;\n typedef const struct equiv_class_label *const_equiv_class_label_t;\n \n-/* A hashtable for mapping a bitmap of labels->pointer equivalence\n-   classes.  */\n-static htab_t pointer_equiv_class_table;\n+/* Equiv_class_label hashtable helpers.  */\n \n-/* A hashtable for mapping a bitmap of labels->location equivalence\n-   classes.  */\n-static htab_t location_equiv_class_table;\n+struct equiv_class_hasher : typed_free_remove <equiv_class_label>\n+{\n+  typedef equiv_class_label value_type;\n+  typedef equiv_class_label compare_type;\n+  static inline hashval_t hash (const value_type *);\n+  static inline bool equal (const value_type *, const compare_type *);\n+};\n \n /* Hash function for a equiv_class_label_t */\n \n-static hashval_t\n-equiv_class_label_hash (const void *p)\n+inline hashval_t\n+equiv_class_hasher::hash (const value_type *ecl)\n {\n-  const_equiv_class_label_t const ecl = (const_equiv_class_label_t) p;\n   return ecl->hashcode;\n }\n \n /* Equality function for two equiv_class_label_t's.  */\n \n-static int\n-equiv_class_label_eq (const void *p1, const void *p2)\n+inline bool\n+equiv_class_hasher::equal (const value_type *eql1, const compare_type *eql2)\n {\n-  const_equiv_class_label_t const eql1 = (const_equiv_class_label_t) p1;\n-  const_equiv_class_label_t const eql2 = (const_equiv_class_label_t) p2;\n   return (eql1->hashcode == eql2->hashcode\n \t  && bitmap_equal_p (eql1->labels, eql2->labels));\n }\n \n+/* A hashtable for mapping a bitmap of labels->pointer equivalence\n+   classes.  */\n+static hash_table <equiv_class_hasher> pointer_equiv_class_table;\n+\n+/* A hashtable for mapping a bitmap of labels->location equivalence\n+   classes.  */\n+static hash_table <equiv_class_hasher> location_equiv_class_table;\n+\n /* Lookup a equivalence class in TABLE by the bitmap of LABELS with\n    hash HAS it contains.  Sets *REF_LABELS to the bitmap LABELS\n    is equivalent to.  */\n \n static equiv_class_label *\n-equiv_class_lookup_or_add (htab_t table, bitmap labels)\n+equiv_class_lookup_or_add (hash_table <equiv_class_hasher> table, bitmap labels)\n {\n   equiv_class_label **slot;\n   equiv_class_label ecl;\n \n   ecl.labels = labels;\n   ecl.hashcode = bitmap_hash (labels);\n-  slot = (equiv_class_label **) htab_find_slot_with_hash (table, &ecl,\n-\t\t\t\t\t\t\t  ecl.hashcode, INSERT);\n+  slot = table.find_slot_with_hash (&ecl, ecl.hashcode, INSERT);\n   if (!*slot)\n     {\n       *slot = XNEW (struct equiv_class_label);\n@@ -2222,10 +2228,8 @@ perform_var_substitution (constraint_graph_t graph)\n   struct scc_info *si = init_scc_info (size);\n \n   bitmap_obstack_initialize (&iteration_obstack);\n-  pointer_equiv_class_table = htab_create (511, equiv_class_label_hash,\n-\t\t\t\t\t   equiv_class_label_eq, free);\n-  location_equiv_class_table = htab_create (511, equiv_class_label_hash,\n-\t\t\t\t\t    equiv_class_label_eq, free);\n+  pointer_equiv_class_table.create (511);\n+  location_equiv_class_table.create (511);\n   pointer_equiv_class = 1;\n   location_equiv_class = 1;\n \n@@ -2358,8 +2362,8 @@ free_var_substitution_info (struct scc_info *si)\n   free (graph->points_to);\n   free (graph->eq_rep);\n   sbitmap_free (graph->direct_nodes);\n-  htab_delete (pointer_equiv_class_table);\n-  htab_delete (location_equiv_class_table);\n+  pointer_equiv_class_table.dispose ();\n+  location_equiv_class_table.dispose ();\n   bitmap_obstack_release (&iteration_obstack);\n }\n \n@@ -5900,45 +5904,54 @@ typedef struct shared_bitmap_info\n } *shared_bitmap_info_t;\n typedef const struct shared_bitmap_info *const_shared_bitmap_info_t;\n \n-static htab_t shared_bitmap_table;\n+/* Shared_bitmap hashtable helpers.  */\n+\n+struct shared_bitmap_hasher : typed_free_remove <shared_bitmap_info>\n+{\n+  typedef shared_bitmap_info value_type;\n+  typedef shared_bitmap_info compare_type;\n+  static inline hashval_t hash (const value_type *);\n+  static inline bool equal (const value_type *, const compare_type *);\n+};\n \n /* Hash function for a shared_bitmap_info_t */\n \n-static hashval_t\n-shared_bitmap_hash (const void *p)\n+inline hashval_t\n+shared_bitmap_hasher::hash (const value_type *bi)\n {\n-  const_shared_bitmap_info_t const bi = (const_shared_bitmap_info_t) p;\n   return bi->hashcode;\n }\n \n /* Equality function for two shared_bitmap_info_t's. */\n \n-static int\n-shared_bitmap_eq (const void *p1, const void *p2)\n+inline bool\n+shared_bitmap_hasher::equal (const value_type *sbi1, const compare_type *sbi2)\n {\n-  const_shared_bitmap_info_t const sbi1 = (const_shared_bitmap_info_t) p1;\n-  const_shared_bitmap_info_t const sbi2 = (const_shared_bitmap_info_t) p2;\n   return bitmap_equal_p (sbi1->pt_vars, sbi2->pt_vars);\n }\n \n+/* Shared_bitmap hashtable.  */\n+\n+static hash_table <shared_bitmap_hasher> shared_bitmap_table;\n+\n /* Lookup a bitmap in the shared bitmap hashtable, and return an already\n    existing instance if there is one, NULL otherwise.  */\n \n static bitmap\n shared_bitmap_lookup (bitmap pt_vars)\n {\n-  void **slot;\n+  shared_bitmap_info **slot;\n   struct shared_bitmap_info sbi;\n \n   sbi.pt_vars = pt_vars;\n   sbi.hashcode = bitmap_hash (pt_vars);\n \n-  slot = htab_find_slot_with_hash (shared_bitmap_table, &sbi,\n-\t\t\t\t   sbi.hashcode, NO_INSERT);\n+  slot = shared_bitmap_table.find_slot_with_hash (&sbi, sbi.hashcode,\n+\t\t\t\t\t\t  NO_INSERT);\n   if (!slot)\n     return NULL;\n   else\n-    return ((shared_bitmap_info_t) *slot)->pt_vars;\n+    return (*slot)->pt_vars;\n }\n \n \n@@ -5947,16 +5960,15 @@ shared_bitmap_lookup (bitmap pt_vars)\n static void\n shared_bitmap_add (bitmap pt_vars)\n {\n-  void **slot;\n+  shared_bitmap_info **slot;\n   shared_bitmap_info_t sbi = XNEW (struct shared_bitmap_info);\n \n   sbi->pt_vars = pt_vars;\n   sbi->hashcode = bitmap_hash (pt_vars);\n \n-  slot = htab_find_slot_with_hash (shared_bitmap_table, sbi,\n-\t\t\t\t   sbi->hashcode, INSERT);\n+  slot = shared_bitmap_table.find_slot_with_hash (sbi, sbi->hashcode, INSERT);\n   gcc_assert (!*slot);\n-  *slot = (void *) sbi;\n+  *slot = sbi;\n }\n \n \n@@ -6612,8 +6624,7 @@ init_alias_vars (void)\n   call_stmt_vars = pointer_map_create ();\n \n   memset (&stats, 0, sizeof (stats));\n-  shared_bitmap_table = htab_create (511, shared_bitmap_hash,\n-\t\t\t\t     shared_bitmap_eq, free);\n+  shared_bitmap_table.create (511);\n   init_base_vars ();\n \n   gcc_obstack_init (&fake_var_decl_obstack);\n@@ -6869,7 +6880,7 @@ delete_points_to_sets (void)\n {\n   unsigned int i;\n \n-  htab_delete (shared_bitmap_table);\n+  shared_bitmap_table.dispose ();\n   if (dump_file && (dump_flags & TDF_STATS))\n     fprintf (dump_file, \"Points to sets created:%d\\n\",\n \t     stats.points_to_sets_created);"}, {"sha": "c1b5826ee1274cb90bd10afd3e71822bc86e544e", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 19, "deletions": 42, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf190e8df270025e2d0729858c031eb4ef7d49d2/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf190e8df270025e2d0729858c031eb4ef7d49d2/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=bf190e8df270025e2d0729858c031eb4ef7d49d2", "patch": "@@ -1062,40 +1062,18 @@ vect_get_data_access_cost (struct data_reference *dr,\n }\n \n \n-static hashval_t\n-vect_peeling_hash (const void *elem)\n-{\n-  const struct _vect_peel_info *peel_info;\n-\n-  peel_info = (const struct _vect_peel_info *) elem;\n-  return (hashval_t) peel_info->npeel;\n-}\n-\n-\n-static int\n-vect_peeling_hash_eq (const void *elem1, const void *elem2)\n-{\n-  const struct _vect_peel_info *a, *b;\n-\n-  a = (const struct _vect_peel_info *) elem1;\n-  b = (const struct _vect_peel_info *) elem2;\n-  return (a->npeel == b->npeel);\n-}\n-\n-\n /* Insert DR into peeling hash table with NPEEL as key.  */\n \n static void\n vect_peeling_hash_insert (loop_vec_info loop_vinfo, struct data_reference *dr,\n                           int npeel)\n {\n   struct _vect_peel_info elem, *slot;\n-  void **new_slot;\n+  _vect_peel_info **new_slot;\n   bool supportable_dr_alignment = vect_supportable_dr_alignment (dr, true);\n \n   elem.npeel = npeel;\n-  slot = (vect_peel_info) htab_find (LOOP_VINFO_PEELING_HTAB (loop_vinfo),\n-                                     &elem);\n+  slot = LOOP_VINFO_PEELING_HTAB (loop_vinfo).find (&elem);\n   if (slot)\n     slot->count++;\n   else\n@@ -1104,8 +1082,7 @@ vect_peeling_hash_insert (loop_vec_info loop_vinfo, struct data_reference *dr,\n       slot->npeel = npeel;\n       slot->dr = dr;\n       slot->count = 1;\n-      new_slot = htab_find_slot (LOOP_VINFO_PEELING_HTAB (loop_vinfo), slot,\n-                                 INSERT);\n+      new_slot = LOOP_VINFO_PEELING_HTAB (loop_vinfo).find_slot (slot, INSERT);\n       *new_slot = slot;\n     }\n \n@@ -1117,11 +1094,11 @@ vect_peeling_hash_insert (loop_vec_info loop_vinfo, struct data_reference *dr,\n /* Traverse peeling hash table to find peeling option that aligns maximum\n    number of data accesses.  */\n \n-static int\n-vect_peeling_hash_get_most_frequent (void **slot, void *data)\n+int\n+vect_peeling_hash_get_most_frequent (_vect_peel_info **slot,\n+\t\t\t\t     _vect_peel_extended_info *max)\n {\n-  vect_peel_info elem = (vect_peel_info) *slot;\n-  vect_peel_extended_info max = (vect_peel_extended_info) data;\n+  vect_peel_info elem = *slot;\n \n   if (elem->count > max->peel_info.count\n       || (elem->count == max->peel_info.count\n@@ -1139,11 +1116,11 @@ vect_peeling_hash_get_most_frequent (void **slot, void *data)\n /* Traverse peeling hash table and calculate cost for each peeling option.\n    Find the one with the lowest cost.  */\n \n-static int\n-vect_peeling_hash_get_lowest_cost (void **slot, void *data)\n+int\n+vect_peeling_hash_get_lowest_cost (_vect_peel_info **slot,\n+\t\t\t\t   _vect_peel_extended_info *min)\n {\n-  vect_peel_info elem = (vect_peel_info) *slot;\n-  vect_peel_extended_info min = (vect_peel_extended_info) data;\n+  vect_peel_info elem = *slot;\n   int save_misalignment, dummy;\n   unsigned int inside_cost = 0, outside_cost = 0, i;\n   gimple stmt = DR_STMT (elem->dr);\n@@ -1223,14 +1200,16 @@ vect_peeling_hash_choose_best_peeling (loop_vec_info loop_vinfo,\n      {\n        res.inside_cost = INT_MAX;\n        res.outside_cost = INT_MAX;\n-       htab_traverse (LOOP_VINFO_PEELING_HTAB (loop_vinfo),\n-                      vect_peeling_hash_get_lowest_cost, &res);\n+       LOOP_VINFO_PEELING_HTAB (loop_vinfo)\n+           .traverse <_vect_peel_extended_info *,\n+                      vect_peeling_hash_get_lowest_cost> (&res);\n      }\n    else\n      {\n        res.peel_info.count = 0;\n-       htab_traverse (LOOP_VINFO_PEELING_HTAB (loop_vinfo),\n-                      vect_peeling_hash_get_most_frequent, &res);\n+       LOOP_VINFO_PEELING_HTAB (loop_vinfo)\n+           .traverse <_vect_peel_extended_info *,\n+                      vect_peeling_hash_get_most_frequent> (&res);\n      }\n \n    *npeel = res.peel_info.npeel;\n@@ -1423,10 +1402,8 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \t\t\t\t\t\t    size_zero_node) < 0;\n \n               /* Save info about DR in the hash table.  */\n-              if (!LOOP_VINFO_PEELING_HTAB (loop_vinfo))\n-                LOOP_VINFO_PEELING_HTAB (loop_vinfo) =\n-                           htab_create (1, vect_peeling_hash,\n-                                        vect_peeling_hash_eq, free);\n+              if (!LOOP_VINFO_PEELING_HTAB (loop_vinfo).is_created ())\n+                LOOP_VINFO_PEELING_HTAB (loop_vinfo).create (1);\n \n               vectype = STMT_VINFO_VECTYPE (stmt_info);\n               nelements = TYPE_VECTOR_SUBPARTS (vectype);"}, {"sha": "40eccea550072964654c2cf69764ebba4ff7d3e4", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf190e8df270025e2d0729858c031eb4ef7d49d2/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf190e8df270025e2d0729858c031eb4ef7d49d2/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=bf190e8df270025e2d0729858c031eb4ef7d49d2", "patch": "@@ -879,7 +879,6 @@ new_loop_vec_info (struct loop *loop)\n   LOOP_VINFO_REDUCTION_CHAINS (res).create (10);\n   LOOP_VINFO_SLP_INSTANCES (res).create (10);\n   LOOP_VINFO_SLP_UNROLLING_FACTOR (res) = 1;\n-  LOOP_VINFO_PEELING_HTAB (res) = NULL;\n   LOOP_VINFO_TARGET_COST_DATA (res) = init_cost (loop);\n   LOOP_VINFO_PEELING_FOR_GAPS (res) = false;\n   LOOP_VINFO_OPERANDS_SWAPPED (res) = false;\n@@ -960,8 +959,8 @@ destroy_loop_vec_info (loop_vec_info loop_vinfo, bool clean_stmts)\n   LOOP_VINFO_REDUCTIONS (loop_vinfo).release ();\n   LOOP_VINFO_REDUCTION_CHAINS (loop_vinfo).release ();\n \n-  if (LOOP_VINFO_PEELING_HTAB (loop_vinfo))\n-    htab_delete (LOOP_VINFO_PEELING_HTAB (loop_vinfo));\n+  if (LOOP_VINFO_PEELING_HTAB (loop_vinfo).is_created ())\n+    LOOP_VINFO_PEELING_HTAB (loop_vinfo).dispose ();\n \n   destroy_cost_data (LOOP_VINFO_TARGET_COST_DATA (loop_vinfo));\n "}, {"sha": "85c885654c0dba1d0ea3d8a9dd38040e3db53798", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 26, "deletions": 1, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf190e8df270025e2d0729858c031eb4ef7d49d2/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf190e8df270025e2d0729858c031eb4ef7d49d2/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=bf190e8df270025e2d0729858c031eb4ef7d49d2", "patch": "@@ -23,6 +23,7 @@ along with GCC; see the file COPYING3.  If not see\n \n #include \"tree-data-ref.h\"\n #include \"target.h\"\n+#include \"hash-table.h\"\n \n typedef source_location LOC;\n #define UNKNOWN_LOC UNKNOWN_LOCATION\n@@ -189,6 +190,30 @@ typedef struct _vect_peel_extended_info\n   stmt_vector_for_cost body_cost_vec;\n } *vect_peel_extended_info;\n \n+\n+/* Peeling hashtable helpers.  */\n+\n+struct peel_info_hasher : typed_free_remove <_vect_peel_info>\n+{\n+  typedef _vect_peel_info value_type;\n+  typedef _vect_peel_info compare_type;\n+  static inline hashval_t hash (const value_type *);\n+  static inline bool equal (const value_type *, const compare_type *);\n+};\n+\n+inline hashval_t\n+peel_info_hasher::hash (const value_type *peel_info)\n+{\n+  return (hashval_t) peel_info->npeel;\n+}\n+\n+inline bool\n+peel_info_hasher::equal (const value_type *a, const compare_type *b)\n+{\n+  return (a->npeel == b->npeel);\n+}\n+\n+\n /*-----------------------------------------------------------------*/\n /* Info on vectorized loops.                                       */\n /*-----------------------------------------------------------------*/\n@@ -273,7 +298,7 @@ typedef struct _loop_vec_info {\n   vec<gimple> reduction_chains;\n \n   /* Hash table used to choose the best peeling option.  */\n-  htab_t peeling_htab;\n+  hash_table <peel_info_hasher> peeling_htab;\n \n   /* Cost data used by the target cost model.  */\n   void *target_cost_data;"}]}