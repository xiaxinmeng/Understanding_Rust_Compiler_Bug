{"sha": "2c8f03adb27b15e9e4665dfe24b04f5516ec2ea4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmM4ZjAzYWRiMjdiMTVlOWU0NjY1ZGZlMjRiMDRmNTUxNmVjMmVhNA==", "commit": {"author": {"name": "Bin Cheng", "email": "bin.cheng@arm.com", "date": "2017-05-26T14:04:49Z"}, "committer": {"name": "Bin Cheng", "email": "amker@gcc.gnu.org", "date": "2017-05-26T14:04:49Z"}, "message": "tree-vect-data-refs.c (compare_tree): Rename and move ...\n\n\t* tree-vect-data-refs.c (compare_tree): Rename and move ...\n\t* tree-data-ref.c (data_ref_compare_tree): ... to here.\n\t* tree-data-ref.h (data_ref_compare_tree): New decalaration.\n\t* tree-vect-data-refs.c (dr_group_sort_cmp): Update uses.\n\t(operator==, comp_dr_with_seg_len_pair): Ditto.\n\t(vect_prune_runtime_alias_test_list): Ditto.\n\nFrom-SVN: r248510", "tree": {"sha": "f28edc0a708d226e418d52a449b17479ea069efb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f28edc0a708d226e418d52a449b17479ea069efb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2c8f03adb27b15e9e4665dfe24b04f5516ec2ea4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c8f03adb27b15e9e4665dfe24b04f5516ec2ea4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c8f03adb27b15e9e4665dfe24b04f5516ec2ea4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c8f03adb27b15e9e4665dfe24b04f5516ec2ea4/comments", "author": null, "committer": null, "parents": [{"sha": "b67b23f00d2f9edcc05cc0339199860c2f35b864", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b67b23f00d2f9edcc05cc0339199860c2f35b864", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b67b23f00d2f9edcc05cc0339199860c2f35b864"}], "stats": {"total": 211, "additions": 114, "deletions": 97}, "files": [{"sha": "c7b5e4bede7a768c54fe50ca63b8cbc444537320", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c8f03adb27b15e9e4665dfe24b04f5516ec2ea4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c8f03adb27b15e9e4665dfe24b04f5516ec2ea4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2c8f03adb27b15e9e4665dfe24b04f5516ec2ea4", "patch": "@@ -1,3 +1,12 @@\n+2017-05-26  Bin Cheng  <bin.cheng@arm.com>\n+\n+\t* tree-vect-data-refs.c (compare_tree): Rename and move ...\n+\t* tree-data-ref.c (data_ref_compare_tree): ... to here.\n+\t* tree-data-ref.h (data_ref_compare_tree): New decalaration.\n+\t* tree-vect-data-refs.c (dr_group_sort_cmp): Update uses.\n+\t(operator==, comp_dr_with_seg_len_pair): Ditto.\n+\t(vect_prune_runtime_alias_test_list): Ditto.\n+\n 2017-05-26  Martin Liska  <mliska@suse.cz>\n \n \tPR ipa/80663"}, {"sha": "50f55c765a7f9e7f1b80fcb0b7019e88e9c1f494", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c8f03adb27b15e9e4665dfe24b04f5516ec2ea4/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c8f03adb27b15e9e4665dfe24b04f5516ec2ea4/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=2c8f03adb27b15e9e4665dfe24b04f5516ec2ea4", "patch": "@@ -1107,6 +1107,81 @@ create_data_ref (loop_p nest, loop_p loop, tree memref, gimple *stmt,\n   return dr;\n }\n \n+/*  A helper function computes order between two tree epxressions T1 and T2.\n+    This is used in comparator functions sorting objects based on the order\n+    of tree expressions.  The function returns -1, 0, or 1.  */\n+\n+int\n+data_ref_compare_tree (tree t1, tree t2)\n+{\n+  int i, cmp;\n+  enum tree_code code;\n+  char tclass;\n+\n+  if (t1 == t2)\n+    return 0;\n+  if (t1 == NULL)\n+    return -1;\n+  if (t2 == NULL)\n+    return 1;\n+\n+  STRIP_NOPS (t1);\n+  STRIP_NOPS (t2);\n+\n+  if (TREE_CODE (t1) != TREE_CODE (t2))\n+    return TREE_CODE (t1) < TREE_CODE (t2) ? -1 : 1;\n+\n+  code = TREE_CODE (t1);\n+  switch (code)\n+    {\n+    /* For const values, we can just use hash values for comparisons.  */\n+    case INTEGER_CST:\n+    case REAL_CST:\n+    case FIXED_CST:\n+    case STRING_CST:\n+    case COMPLEX_CST:\n+    case VECTOR_CST:\n+      {\n+\thashval_t h1 = iterative_hash_expr (t1, 0);\n+\thashval_t h2 = iterative_hash_expr (t2, 0);\n+\tif (h1 != h2)\n+\t  return h1 < h2 ? -1 : 1;\n+\tbreak;\n+      }\n+\n+    case SSA_NAME:\n+      cmp = data_ref_compare_tree (SSA_NAME_VAR (t1), SSA_NAME_VAR (t2));\n+      if (cmp != 0)\n+\treturn cmp;\n+\n+      if (SSA_NAME_VERSION (t1) != SSA_NAME_VERSION (t2))\n+\treturn SSA_NAME_VERSION (t1) < SSA_NAME_VERSION (t2) ? -1 : 1;\n+      break;\n+\n+    default:\n+      tclass = TREE_CODE_CLASS (code);\n+\n+      /* For var-decl, we could compare their UIDs.  */\n+      if (tclass == tcc_declaration)\n+\t{\n+\t  if (DECL_UID (t1) != DECL_UID (t2))\n+\t    return DECL_UID (t1) < DECL_UID (t2) ? -1 : 1;\n+\t  break;\n+\t}\n+\n+      /* For expressions with operands, compare their operands recursively.  */\n+      for (i = TREE_OPERAND_LENGTH (t1) - 1; i >= 0; --i)\n+\t{\n+\t  cmp = data_ref_compare_tree (TREE_OPERAND (t1, i),\n+\t\t\t\t       TREE_OPERAND (t2, i));\n+\t  if (cmp != 0)\n+\t    return cmp;\n+\t}\n+    }\n+\n+  return 0;\n+}\n+\n /* Check if OFFSET1 and OFFSET2 (DR_OFFSETs of some data-refs) are identical\n    expressions.  */\n static bool"}, {"sha": "96bc764ed127c45ec0cac5a0883b33521932af9a", "filename": "gcc/tree-data-ref.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c8f03adb27b15e9e4665dfe24b04f5516ec2ea4/gcc%2Ftree-data-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c8f03adb27b15e9e4665dfe24b04f5516ec2ea4/gcc%2Ftree-data-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.h?ref=2c8f03adb27b15e9e4665dfe24b04f5516ec2ea4", "patch": "@@ -342,6 +342,7 @@ extern bool dr_may_alias_p (const struct data_reference *,\n extern bool dr_equal_offsets_p (struct data_reference *,\n                                 struct data_reference *);\n \n+extern int data_ref_compare_tree (tree, tree);\n /* Return true when the base objects of data references A and B are\n    the same memory object.  */\n "}, {"sha": "9f4f207f48e1edb6a56f2331da094fff0218ca6b", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 29, "deletions": 97, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c8f03adb27b15e9e4665dfe24b04f5516ec2ea4/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c8f03adb27b15e9e4665dfe24b04f5516ec2ea4/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=2c8f03adb27b15e9e4665dfe24b04f5516ec2ea4", "patch": "@@ -2574,83 +2574,6 @@ vect_analyze_data_ref_access (struct data_reference *dr)\n   return vect_analyze_group_access (dr);\n }\n \n-\n-\n-/*  A helper function used in the comparator function to sort data\n-    references.  T1 and T2 are two data references to be compared.\n-    The function returns -1, 0, or 1.  */\n-\n-static int\n-compare_tree (tree t1, tree t2)\n-{\n-  int i, cmp;\n-  enum tree_code code;\n-  char tclass;\n-\n-  if (t1 == t2)\n-    return 0;\n-  if (t1 == NULL)\n-    return -1;\n-  if (t2 == NULL)\n-    return 1;\n-\n-  STRIP_NOPS (t1);\n-  STRIP_NOPS (t2);\n-\n-  if (TREE_CODE (t1) != TREE_CODE (t2))\n-    return TREE_CODE (t1) < TREE_CODE (t2) ? -1 : 1;\n-\n-  code = TREE_CODE (t1);\n-  switch (code)\n-    {\n-    /* For const values, we can just use hash values for comparisons.  */\n-    case INTEGER_CST:\n-    case REAL_CST:\n-    case FIXED_CST:\n-    case STRING_CST:\n-    case COMPLEX_CST:\n-    case VECTOR_CST:\n-      {\n-\thashval_t h1 = iterative_hash_expr (t1, 0);\n-\thashval_t h2 = iterative_hash_expr (t2, 0);\n-\tif (h1 != h2)\n-\t  return h1 < h2 ? -1 : 1;\n-\tbreak;\n-      }\n-\n-    case SSA_NAME:\n-      cmp = compare_tree (SSA_NAME_VAR (t1), SSA_NAME_VAR (t2));\n-      if (cmp != 0)\n-\treturn cmp;\n-\n-      if (SSA_NAME_VERSION (t1) != SSA_NAME_VERSION (t2))\n-\treturn SSA_NAME_VERSION (t1) < SSA_NAME_VERSION (t2) ? -1 : 1;\n-      break;\n-\n-    default:\n-      tclass = TREE_CODE_CLASS (code);\n-\n-      /* For var-decl, we could compare their UIDs.  */\n-      if (tclass == tcc_declaration)\n-\t{\n-\t  if (DECL_UID (t1) != DECL_UID (t2))\n-\t    return DECL_UID (t1) < DECL_UID (t2) ? -1 : 1;\n-\t  break;\n-\t}\n-\n-      /* For expressions with operands, compare their operands recursively.  */\n-      for (i = TREE_OPERAND_LENGTH (t1) - 1; i >= 0; --i)\n-\t{\n-\t  cmp = compare_tree (TREE_OPERAND (t1, i), TREE_OPERAND (t2, i));\n-\t  if (cmp != 0)\n-\t    return cmp;\n-\t}\n-    }\n-\n-  return 0;\n-}\n-\n-\n /* Compare two data-references DRA and DRB to group them into chunks\n    suitable for grouping.  */\n \n@@ -2674,15 +2597,16 @@ dr_group_sort_cmp (const void *dra_, const void *drb_)\n   /* Ordering of DRs according to base.  */\n   if (!operand_equal_p (DR_BASE_ADDRESS (dra), DR_BASE_ADDRESS (drb), 0))\n     {\n-      cmp = compare_tree (DR_BASE_ADDRESS (dra), DR_BASE_ADDRESS (drb));\n+      cmp = data_ref_compare_tree (DR_BASE_ADDRESS (dra),\n+\t\t\t\t   DR_BASE_ADDRESS (drb));\n       if (cmp != 0)\n         return cmp;\n     }\n \n   /* And according to DR_OFFSET.  */\n   if (!dr_equal_offsets_p (dra, drb))\n     {\n-      cmp = compare_tree (DR_OFFSET (dra), DR_OFFSET (drb));\n+      cmp = data_ref_compare_tree (DR_OFFSET (dra), DR_OFFSET (drb));\n       if (cmp != 0)\n         return cmp;\n     }\n@@ -2695,16 +2619,16 @@ dr_group_sort_cmp (const void *dra_, const void *drb_)\n   if (!operand_equal_p (TYPE_SIZE_UNIT (TREE_TYPE (DR_REF (dra))),\n \t\t\tTYPE_SIZE_UNIT (TREE_TYPE (DR_REF (drb))), 0))\n     {\n-      cmp = compare_tree (TYPE_SIZE_UNIT (TREE_TYPE (DR_REF (dra))),\n-                          TYPE_SIZE_UNIT (TREE_TYPE (DR_REF (drb))));\n+      cmp = data_ref_compare_tree (TYPE_SIZE_UNIT (TREE_TYPE (DR_REF (dra))),\n+\t\t\t\t   TYPE_SIZE_UNIT (TREE_TYPE (DR_REF (drb))));\n       if (cmp != 0)\n         return cmp;\n     }\n \n   /* And after step.  */\n   if (!operand_equal_p (DR_STEP (dra), DR_STEP (drb), 0))\n     {\n-      cmp = compare_tree (DR_STEP (dra), DR_STEP (drb));\n+      cmp = data_ref_compare_tree (DR_STEP (dra), DR_STEP (drb));\n       if (cmp != 0)\n         return cmp;\n     }\n@@ -2904,9 +2828,9 @@ operator == (const dr_with_seg_len& d1,\n {\n   return operand_equal_p (DR_BASE_ADDRESS (d1.dr),\n \t\t\t  DR_BASE_ADDRESS (d2.dr), 0)\n-\t   && compare_tree (DR_OFFSET (d1.dr), DR_OFFSET (d2.dr)) == 0\n-\t   && compare_tree (DR_INIT (d1.dr), DR_INIT (d2.dr)) == 0\n-\t   && compare_tree (d1.seg_len, d2.seg_len) == 0;\n+\t   && data_ref_compare_tree (DR_OFFSET (d1.dr), DR_OFFSET (d2.dr)) == 0\n+\t   && data_ref_compare_tree (DR_INIT (d1.dr), DR_INIT (d2.dr)) == 0\n+\t   && data_ref_compare_tree (d1.seg_len, d2.seg_len) == 0;\n }\n \n /* Function comp_dr_with_seg_len_pair.\n@@ -2928,23 +2852,29 @@ comp_dr_with_seg_len_pair (const void *pa_, const void *pb_)\n      and step, we don't care the order of those two pairs after sorting.  */\n   int comp_res;\n \n-  if ((comp_res = compare_tree (DR_BASE_ADDRESS (a1.dr),\n-\t\t\t\tDR_BASE_ADDRESS (b1.dr))) != 0)\n+  if ((comp_res = data_ref_compare_tree (DR_BASE_ADDRESS (a1.dr),\n+\t\t\t\t\t DR_BASE_ADDRESS (b1.dr))) != 0)\n     return comp_res;\n-  if ((comp_res = compare_tree (DR_BASE_ADDRESS (a2.dr),\n-\t\t\t\tDR_BASE_ADDRESS (b2.dr))) != 0)\n+  if ((comp_res = data_ref_compare_tree (DR_BASE_ADDRESS (a2.dr),\n+\t\t\t\t\t DR_BASE_ADDRESS (b2.dr))) != 0)\n     return comp_res;\n-  if ((comp_res = compare_tree (DR_STEP (a1.dr), DR_STEP (b1.dr))) != 0)\n+  if ((comp_res = data_ref_compare_tree (DR_STEP (a1.dr),\n+\t\t\t\t\t DR_STEP (b1.dr))) != 0)\n     return comp_res;\n-  if ((comp_res = compare_tree (DR_STEP (a2.dr), DR_STEP (b2.dr))) != 0)\n+  if ((comp_res = data_ref_compare_tree (DR_STEP (a2.dr),\n+\t\t\t\t\t DR_STEP (b2.dr))) != 0)\n     return comp_res;\n-  if ((comp_res = compare_tree (DR_OFFSET (a1.dr), DR_OFFSET (b1.dr))) != 0)\n+  if ((comp_res = data_ref_compare_tree (DR_OFFSET (a1.dr),\n+\t\t\t\t\t DR_OFFSET (b1.dr))) != 0)\n     return comp_res;\n-  if ((comp_res = compare_tree (DR_INIT (a1.dr), DR_INIT (b1.dr))) != 0)\n+  if ((comp_res = data_ref_compare_tree (DR_INIT (a1.dr),\n+\t\t\t\t\t DR_INIT (b1.dr))) != 0)\n     return comp_res;\n-  if ((comp_res = compare_tree (DR_OFFSET (a2.dr), DR_OFFSET (b2.dr))) != 0)\n+  if ((comp_res = data_ref_compare_tree (DR_OFFSET (a2.dr),\n+\t\t\t\t\t DR_OFFSET (b2.dr))) != 0)\n     return comp_res;\n-  if ((comp_res = compare_tree (DR_INIT (a2.dr), DR_INIT (b2.dr))) != 0)\n+  if ((comp_res = data_ref_compare_tree (DR_INIT (a2.dr),\n+\t\t\t\t\t DR_INIT (b2.dr))) != 0)\n     return comp_res;\n \n   return 0;\n@@ -3128,9 +3058,11 @@ vect_prune_runtime_alias_test_list (loop_vec_info loop_vinfo)\n       segment_length_a = vect_vfa_segment_size (dr_a, length_factor);\n       segment_length_b = vect_vfa_segment_size (dr_b, length_factor);\n \n-      comp_res = compare_tree (DR_BASE_ADDRESS (dr_a), DR_BASE_ADDRESS (dr_b));\n+      comp_res = data_ref_compare_tree (DR_BASE_ADDRESS (dr_a),\n+\t\t\t\t\tDR_BASE_ADDRESS (dr_b));\n       if (comp_res == 0)\n-\tcomp_res = compare_tree (DR_OFFSET (dr_a), DR_OFFSET (dr_b));\n+\tcomp_res = data_ref_compare_tree (DR_OFFSET (dr_a),\n+\t\t\t\t\t  DR_OFFSET (dr_b));\n \n       /* Alias is known at compilation time.  */\n       if (comp_res == 0"}]}