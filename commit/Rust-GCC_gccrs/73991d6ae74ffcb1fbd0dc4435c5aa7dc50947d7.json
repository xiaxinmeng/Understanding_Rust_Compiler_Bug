{"sha": "73991d6ae74ffcb1fbd0dc4435c5aa7dc50947d7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzM5OTFkNmFlNzRmZmNiMWZiZDBkYzQ0MzVjNWFhN2RjNTA5NDdkNw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-10-30T11:13:49Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-10-30T11:13:49Z"}, "message": "lcm.c (optimize_mode_switching): Do not rebuild liveness information when no changes has been made.\n\n\t* lcm.c (optimize_mode_switching):  Do not rebuild liveness information\n\twhen no changes has been made.\n\n\t* gcse.c (reg_set_bitmap): Turn into reg_set.\n\t(modify_mem_list_set, canon_modify_mem_list_set)\n\t(clear_modify_mem_tables, free_modify_mem_tables): New.\n\t(gcse_main); Use free_modify_mem_tables.\n\t(free_gcse_mem): Likewise; free the bitmaps.\n\t(alloc_gcse_main): Initialize the bitmaps.\n\t(canon_list_insert): Set canon_modify_mem_list_set.\n\t(record_last_mem_set_info): Likewise; set modify_mem_list_set.\n\t(compute_hash_table): Use clear_modify_mem_tables.\n\t(reset_opr_set_tables): Likewise.\n\t(oprs_not_set_p): reg_set_bitmap is regset.\n\t(mark_set, mark_clobber): Likewise.\n\n\t* df.h (DF_EQUIV_NOTES): New constant.\n\t(df_insn_refs_record): Record uses inside or REG_EQUIV/EQUAL notes\n\twhen asked for.\n\n\t* sched-rgn.c (CHECK_DEAD_NOTES): New constant.\n\t(init_regions, schedule_insns): Conditionalize the checking\n\tcode by CHECK_DEAD_NOTES; avoid multiple calls to update_life_info.\n\nFrom-SVN: r46634", "tree": {"sha": "5aed4d117e8130cabea4a775fc620383c6f0edc9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5aed4d117e8130cabea4a775fc620383c6f0edc9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/73991d6ae74ffcb1fbd0dc4435c5aa7dc50947d7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73991d6ae74ffcb1fbd0dc4435c5aa7dc50947d7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/73991d6ae74ffcb1fbd0dc4435c5aa7dc50947d7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73991d6ae74ffcb1fbd0dc4435c5aa7dc50947d7/comments", "author": null, "committer": null, "parents": [{"sha": "415c055a2acc0449e4c20fe22e703d7173de2629", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/415c055a2acc0449e4c20fe22e703d7173de2629", "html_url": "https://github.com/Rust-GCC/gccrs/commit/415c055a2acc0449e4c20fe22e703d7173de2629"}], "stats": {"total": 265, "additions": 176, "deletions": 89}, "files": [{"sha": "a7e6c7a4d30e2a584a29fb37837e12556cb6fdc3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73991d6ae74ffcb1fbd0dc4435c5aa7dc50947d7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73991d6ae74ffcb1fbd0dc4435c5aa7dc50947d7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=73991d6ae74ffcb1fbd0dc4435c5aa7dc50947d7", "patch": "@@ -1,3 +1,29 @@\n+Tue Oct 30 11:08:11 CET 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* lcm.c (optimize_mode_switching):  Do not rebuild liveness information\n+\twhen no changes has been made.\n+\n+\t* gcse.c (reg_set_bitmap): Turn into reg_set.\n+\t(modify_mem_list_set, canon_modify_mem_list_set)\n+\t(clear_modify_mem_tables, free_modify_mem_tables): New.\n+\t(gcse_main); Use free_modify_mem_tables.\n+\t(free_gcse_mem): Likewise; free the bitmaps.\n+\t(alloc_gcse_main): Initialize the bitmaps.\n+\t(canon_list_insert): Set canon_modify_mem_list_set.\n+\t(record_last_mem_set_info): Likewise; set modify_mem_list_set.\n+\t(compute_hash_table): Use clear_modify_mem_tables.\n+\t(reset_opr_set_tables): Likewise.\n+\t(oprs_not_set_p): reg_set_bitmap is regset.\n+\t(mark_set, mark_clobber): Likewise.\n+\n+\t* df.h (DF_EQUIV_NOTES): New constant.\n+\t(df_insn_refs_record): Record uses inside or REG_EQUIV/EQUAL notes\n+\twhen asked for.\n+\n+\t* sched-rgn.c (CHECK_DEAD_NOTES): New constant.\n+\t(init_regions, schedule_insns): Conditionalize the checking\n+\tcode by CHECK_DEAD_NOTES; avoid multiple calls to update_life_info.\n+\n Tue Oct 30 11:02:31 CET 2001  Jan Hubicka  <jh@suse.cz>\n \n \t* i386.md (movti_rex64 splitter): Fix condition."}, {"sha": "3318d456a558d47838ccc8d8b7843f55750ea169", "filename": "gcc/df.c", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73991d6ae74ffcb1fbd0dc4435c5aa7dc50947d7/gcc%2Fdf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73991d6ae74ffcb1fbd0dc4435c5aa7dc50947d7/gcc%2Fdf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.c?ref=73991d6ae74ffcb1fbd0dc4435c5aa7dc50947d7", "patch": "@@ -1224,8 +1224,25 @@ df_insn_refs_record (df, bb, insn)\n \n   if (INSN_P (insn))\n     {\n+      rtx note;\n+\n       /* Record register defs */\n       df_defs_record (df, PATTERN (insn), bb, insn);\n+\n+      if (df->flags & DF_EQUIV_NOTES)\n+\tfor (note = REG_NOTES (insn); note;\n+\t     note = XEXP (note, 1))\n+\t  {\n+\t    switch (REG_NOTE_KIND (note))\n+\t      {\n+\t\tcase REG_EQUIV:\n+\t\tcase REG_EQUAL:\n+\t\t  df_uses_record (df, &XEXP (note, 0), DF_REF_REG_USE,\n+\t\t\t\t  bb, insn);\n+\t\tdefault:\n+\t\t  break;\n+\t      }\n+\t  }\n       \n       if (GET_CODE (insn) == CALL_INSN)\n \t{"}, {"sha": "395b325d516b2d1c0885a0bacff94d961978926d", "filename": "gcc/df.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73991d6ae74ffcb1fbd0dc4435c5aa7dc50947d7/gcc%2Fdf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73991d6ae74ffcb1fbd0dc4435c5aa7dc50947d7/gcc%2Fdf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.h?ref=73991d6ae74ffcb1fbd0dc4435c5aa7dc50947d7", "patch": "@@ -31,6 +31,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #define DF_RU_CHAIN    128\t/* Reg-use chain.  */\n #define DF_ALL\t       255\n #define DF_HARD_REGS  1024\n+#define DF_EQUIV_NOTES 2048\t/* Mark uses present in EQUIV/EQUAL notes.  */\n \n enum df_ref_type {DF_REF_REG_DEF, DF_REF_REG_USE, DF_REF_REG_MEM_LOAD,\n \t\t  DF_REF_REG_MEM_STORE};"}, {"sha": "a91cfd6836ea2b8823527afca53ed41cccf357fc", "filename": "gcc/gcse.c", "status": "modified", "additions": 51, "deletions": 55, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73991d6ae74ffcb1fbd0dc4435c5aa7dc50947d7/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73991d6ae74ffcb1fbd0dc4435c5aa7dc50947d7/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=73991d6ae74ffcb1fbd0dc4435c5aa7dc50947d7", "patch": "@@ -481,7 +481,7 @@ static struct ls_expr * pre_ldst_mems = NULL;\n /* Bitmap containing one bit for each register in the program.\n    Used when performing GCSE to track which registers have been set since\n    the start of the basic block.  */\n-static sbitmap reg_set_bitmap;\n+static regset reg_set_bitmap;\n \n /* For each block, a bitmap of registers set in the block.\n    This is used by expr_killed_p and compute_transp.\n@@ -493,9 +493,11 @@ static sbitmap *reg_set_in_block;\n /* Array, indexed by basic block number for a list of insns which modify\n    memory within that block.  */\n static rtx * modify_mem_list;\n+bitmap modify_mem_list_set;\n \n /* This array parallels modify_mem_list, but is kept canonicalized.  */\n static rtx * canon_modify_mem_list;\n+bitmap canon_modify_mem_list_set;\n /* Various variables for statistics gathering.  */\n \n /* Memory used in a pass.\n@@ -693,6 +695,8 @@ static void delete_store\t\tPARAMS ((struct ls_expr *,\n \t\t\t\t\t\t basic_block));\n static void free_store_memory\t\tPARAMS ((void));\n static void store_motion\t\tPARAMS ((void));\n+static void clear_modify_mem_tables\tPARAMS ((void));\n+static void free_modify_mem_tables\tPARAMS ((void));\n \f\n /* Entry point for global common subexpression elimination.\n    F is the first instruction in the function.  */\n@@ -825,15 +829,7 @@ gcse_main (f, file)\n \t     basic blocks.  */\n \t  if (changed)\n \t    {\n-\t      int i;\n-\n-\t      for (i = 0; i < orig_bb_count; i++)\n-\t        {\n-\t\t  if (modify_mem_list[i])\n-\t\t    free_INSN_LIST_list (modify_mem_list + i);\n-\t\t  if (canon_modify_mem_list[i])\n-\t\t    free_INSN_LIST_list (canon_modify_mem_list + i); \n-\t\t}\n+\t      free_modify_mem_tables ();\n \t      modify_mem_list\n \t\t= (rtx *) gmalloc (n_basic_blocks * sizeof (rtx *));\n \t      canon_modify_mem_list\n@@ -1016,7 +1012,7 @@ alloc_gcse_mem (f)\n       CUID_INSN (i++) = insn;\n \n   /* Allocate vars to track sets of regs.  */\n-  reg_set_bitmap = (sbitmap) sbitmap_alloc (max_gcse_regno);\n+  reg_set_bitmap = BITMAP_XMALLOC ();\n \n   /* Allocate vars to track sets of regs, memory per block.  */\n   reg_set_in_block = (sbitmap *) sbitmap_vector_alloc (n_basic_blocks,\n@@ -1027,6 +1023,8 @@ alloc_gcse_mem (f)\n   canon_modify_mem_list = (rtx *) gmalloc (n_basic_blocks * sizeof (rtx *));\n   memset ((char *) modify_mem_list, 0, n_basic_blocks * sizeof (rtx *));\n   memset ((char *) canon_modify_mem_list, 0, n_basic_blocks * sizeof (rtx *));\n+  modify_mem_list_set = BITMAP_XMALLOC ();\n+  canon_modify_mem_list_set = BITMAP_XMALLOC ();\n }\n \n /* Free memory allocated by alloc_gcse_mem.  */\n@@ -1037,26 +1035,12 @@ free_gcse_mem ()\n   free (uid_cuid);\n   free (cuid_insn);\n \n-  free (reg_set_bitmap);\n+  BITMAP_XFREE (reg_set_bitmap);\n \n   sbitmap_vector_free (reg_set_in_block);\n-  /* re-Cache any INSN_LIST nodes we have allocated.  */\n-  {\n-    int i;\n-\n-    for (i = 0; i < n_basic_blocks; i++)\n-      {\n-        if (modify_mem_list[i])\n-          free_INSN_LIST_list (modify_mem_list + i);\n-        if (canon_modify_mem_list[i])\n-          free_INSN_LIST_list (canon_modify_mem_list + i);\n-      }\n-\n-    free (modify_mem_list);\n-    free (canon_modify_mem_list);\n-    modify_mem_list = 0;\n-    canon_modify_mem_list = 0;\n-  }\n+  free_modify_mem_tables ();\n+  BITMAP_XFREE (modify_mem_list_set);\n+  BITMAP_XFREE (canon_modify_mem_list_set);\n }\n \n /* Many of the global optimization algorithms work by solving dataflow\n@@ -2403,6 +2387,7 @@ canon_list_insert (dest, unused1, v_insn)\n     alloc_INSN_LIST (dest_addr, canon_modify_mem_list[BLOCK_NUM (insn)]);\n   canon_modify_mem_list[BLOCK_NUM (insn)] = \n     alloc_INSN_LIST (dest, canon_modify_mem_list[BLOCK_NUM (insn)]);\n+  bitmap_set_bit (canon_modify_mem_list_set, BLOCK_NUM (insn));\n }\n \n /* Record memory modification information for INSN.  We do not actually care\n@@ -2417,6 +2402,7 @@ record_last_mem_set_info (insn)\n      everything.  */\n   modify_mem_list[BLOCK_NUM (insn)] = \n     alloc_INSN_LIST (insn, modify_mem_list[BLOCK_NUM (insn)]);\n+  bitmap_set_bit (modify_mem_list_set, BLOCK_NUM (insn));\n \n   if (GET_CODE (insn) == CALL_INSN)\n     {\n@@ -2425,6 +2411,7 @@ record_last_mem_set_info (insn)\n \t need to insert a pair of items, as canon_list_insert does.  */\n       canon_modify_mem_list[BLOCK_NUM (insn)] = \n         alloc_INSN_LIST (insn, canon_modify_mem_list[BLOCK_NUM (insn)]);\n+      bitmap_set_bit (canon_modify_mem_list_set, BLOCK_NUM (insn));\n     }\n   else\n     note_stores (PATTERN (insn), canon_list_insert, (void*)insn );\n@@ -2482,16 +2469,7 @@ compute_hash_table (set_p)\n   sbitmap_vector_zero (reg_set_in_block, n_basic_blocks);\n \n   /* re-Cache any INSN_LIST nodes we have allocated.  */\n-  {\n-    int i;\n-    for (i = 0; i < n_basic_blocks; i++)\n-      {\n-        if (modify_mem_list[i])\n-\t  free_INSN_LIST_list (modify_mem_list + i);\n-        if (canon_modify_mem_list[i])\n-\t  free_INSN_LIST_list (canon_modify_mem_list + i);\n-      }\n-  }\n+  clear_modify_mem_tables ();\n   /* Some working arrays used to track first and last set in each block.  */\n   reg_avail_info = (struct reg_avail_info*)\n     gmalloc (max_gcse_regno * sizeof (struct reg_avail_info));\n@@ -2712,6 +2690,35 @@ next_set (regno, expr)\n   return expr;\n }\n \n+/* Clear canon_modify_mem_list and modify_mem_list tables.  */\n+static void\n+clear_modify_mem_tables ()\n+{\n+  int i;\n+\n+  EXECUTE_IF_SET_IN_BITMAP\n+    (canon_modify_mem_list_set, 0, i,\n+     free_INSN_LIST_list (modify_mem_list + i));\n+  bitmap_clear (canon_modify_mem_list_set);\n+\n+  EXECUTE_IF_SET_IN_BITMAP\n+    (canon_modify_mem_list_set, 0, i,\n+     free_INSN_LIST_list (canon_modify_mem_list + i));\n+  bitmap_clear (modify_mem_list_set);\n+}\n+\n+/* Release memory used by modify_mem_list_set and canon_modify_mem_list_set.  */\n+\n+static void\n+free_modify_mem_tables ()\n+{\n+  clear_modify_mem_tables ();\n+  free (modify_mem_list);\n+  free (canon_modify_mem_list);\n+  modify_mem_list = 0;\n+  canon_modify_mem_list = 0;\n+}\n+\n /* Reset tables used to keep track of what's still available [since the\n    start of the block].  */\n \n@@ -2720,23 +2727,12 @@ reset_opr_set_tables ()\n {\n   /* Maintain a bitmap of which regs have been set since beginning of\n      the block.  */\n-  sbitmap_zero (reg_set_bitmap);\n+  CLEAR_REG_SET (reg_set_bitmap);\n \n   /* Also keep a record of the last instruction to modify memory.\n      For now this is very trivial, we only record whether any memory\n      location has been modified.  */\n-  {\n-    int i;\n-\n-    /* re-Cache any INSN_LIST nodes we have allocated.  */\n-    for (i = 0; i < n_basic_blocks; i++)\n-      {\n-        if (modify_mem_list[i]) \n-\t  free_INSN_LIST_list (modify_mem_list + i);\n-        if (canon_modify_mem_list[i]) \n-\t  free_INSN_LIST_list (canon_modify_mem_list + i);\n-      }\n-  }\n+  clear_modify_mem_tables ();\n }\n \n /* Return non-zero if the operands of X are not set before INSN in\n@@ -2775,7 +2771,7 @@ oprs_not_set_p (x, insn)\n \treturn oprs_not_set_p (XEXP (x, 0), insn);\n \n     case REG:\n-      return ! TEST_BIT (reg_set_bitmap, REGNO (x));\n+      return ! REGNO_REG_SET_P (reg_set_bitmap, REGNO (x));\n \n     default:\n       break;\n@@ -2828,7 +2824,7 @@ mark_set (pat, insn)\n     dest = XEXP (dest, 0);\n \n   if (GET_CODE (dest) == REG)\n-    SET_BIT (reg_set_bitmap, REGNO (dest));\n+    SET_REGNO_REG_SET (reg_set_bitmap, REGNO (dest));\n   else if (GET_CODE (dest) == MEM)\n     record_last_mem_set_info (insn);\n \n@@ -2848,7 +2844,7 @@ mark_clobber (pat, insn)\n     clob = XEXP (clob, 0);\n \n   if (GET_CODE (clob) == REG)\n-    SET_BIT (reg_set_bitmap, REGNO (clob));\n+    SET_REGNO_REG_SET (reg_set_bitmap, REGNO (clob));\n   else\n     record_last_mem_set_info (insn);\n }"}, {"sha": "88e58410d812ee6cf6236f5551d3c9f8818c9660", "filename": "gcc/lcm.c", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73991d6ae74ffcb1fbd0dc4435c5aa7dc50947d7/gcc%2Flcm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73991d6ae74ffcb1fbd0dc4435c5aa7dc50947d7/gcc%2Flcm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flcm.c?ref=73991d6ae74ffcb1fbd0dc4435c5aa7dc50947d7", "patch": "@@ -1029,6 +1029,7 @@ optimize_mode_switching (file)\n   int i, j;\n   int n_entities;\n   int max_num_modes = 0;\n+  bool emited = false;\n \n #ifdef NORMAL_MODE\n   /* Increment n_basic_blocks before allocating bb_info.  */\n@@ -1239,10 +1240,16 @@ optimize_mode_switching (file)\n \t      mode_set = gen_sequence ();\n \t      end_sequence ();\n \n+\t      /* Do not bother to insert empty sequence.  */\n+\t      if (GET_CODE (mode_set) == SEQUENCE\n+\t\t  && !XVECLEN (mode_set, 0))\n+\t\tcontinue;\n+\n \t      /* If this is an abnormal edge, we'll insert at the end\n \t\t of the previous block.  */\n \t      if (eg->flags & EDGE_ABNORMAL)\n \t\t{\n+\t\t  emited = true;\n \t\t  if (GET_CODE (src_bb->end) == JUMP_INSN)\n \t\t    emit_insn_before (mode_set, src_bb->end);\n \t\t  /* It doesn't make sense to switch to normal mode\n@@ -1313,10 +1320,16 @@ optimize_mode_switching (file)\n \t      mode_set = gen_sequence ();\n \t      end_sequence ();\n \n+\t      /* Do not bother to insert empty sequence.  */\n+\t      if (GET_CODE (mode_set) == SEQUENCE\n+\t\t  && !XVECLEN (mode_set, 0))\n+\t\tcontinue;\n+\n \t      /* If this is an abnormal edge, we'll insert at the end of the\n \t\t previous block.  */\n \t      if (eg->flags & EDGE_ABNORMAL)\n \t\t{\n+\t\t  emited = true;\n \t\t  if (GET_CODE (eg->src->end) == JUMP_INSN)\n \t\t    emit_insn_before (mode_set, eg->src->end);\n \t\t  else if (GET_CODE (eg->src->end) == INSN)\n@@ -1349,6 +1362,12 @@ optimize_mode_switching (file)\n \t\t  mode_set = gen_sequence ();\n \t\t  end_sequence ();\n \n+\t\t  /* Do not bother to insert empty sequence.  */\n+\t\t  if (GET_CODE (mode_set) == SEQUENCE\n+\t\t      && !XVECLEN (mode_set, 0))\n+\t\t    continue;\n+\n+\t\t  emited = true;\n \t\t  if (GET_CODE (ptr->insn_ptr) == NOTE\n \t\t      && (NOTE_LINE_NUMBER (ptr->insn_ptr)\n \t\t\t  == NOTE_INSN_BASIC_BLOCK))\n@@ -1376,6 +1395,9 @@ optimize_mode_switching (file)\n   if (need_commit)\n     commit_edge_insertions ();\n \n+  if (!need_commit && !emited)\n+    return 0;\n+\n   /* Ideally we'd figure out what blocks were affected and start from\n      there, but this is enormously complicated by commit_edge_insertions,\n      which would screw up any indicies we'd collected, and also need to"}, {"sha": "56f475162925661e6cad1fbd61bcce1975cbccf1", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73991d6ae74ffcb1fbd0dc4435c5aa7dc50947d7/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73991d6ae74ffcb1fbd0dc4435c5aa7dc50947d7/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=73991d6ae74ffcb1fbd0dc4435c5aa7dc50947d7", "patch": "@@ -442,9 +442,11 @@ reg_to_stack (first, file)\n   /* Ok, floating point instructions exist.  If not optimizing, \n      build the CFG and run life analysis.  */\n   if (!optimize)\n-    find_basic_blocks (first, max_reg_num (), file);\n-  count_or_remove_death_notes (NULL, 1);\n-  life_analysis (first, file, PROP_DEATH_NOTES);\n+    {\n+      find_basic_blocks (first, max_reg_num (), file);\n+      count_or_remove_death_notes (NULL, 1);\n+      life_analysis (first, file, PROP_DEATH_NOTES);\n+    }\n   mark_dfs_back_edges ();\n \n   /* Set up block info for each basic block.  */"}, {"sha": "c443cd7c4f0ff92d555769086ed13842d68a6fc7", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 54, "deletions": 31, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73991d6ae74ffcb1fbd0dc4435c5aa7dc50947d7/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73991d6ae74ffcb1fbd0dc4435c5aa7dc50947d7/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=73991d6ae74ffcb1fbd0dc4435c5aa7dc50947d7", "patch": "@@ -62,6 +62,17 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"recog.h\"\n #include \"sched-int.h\"\n \n+/* Define when we want to do count REG_DEAD notes before and after scheduling\n+   for sanity checking.  We can't do that when conditional execution is used,\n+   as REG_DEAD exist only for unconditional deaths.  */\n+\n+#if !defined (HAVE_conditional_execution) && defined (ENABLE_CHECKING)\n+#define CHECK_DEAD_NOTES 1\n+#else\n+#define CHECK_DEAD_NOTES 0\n+#endif\n+\n+\n #ifdef INSN_SCHEDULING\n /* Some accessor macros for h_i_d members only used within this file.  */\n #define INSN_REF_COUNT(INSN)\t(h_i_d[INSN_UID (INSN)].ref_count)\n@@ -2790,8 +2801,6 @@ init_regions ()\n   block_to_bb = (int *) xmalloc ((n_basic_blocks) * sizeof (int));\n   containing_rgn = (int *) xmalloc ((n_basic_blocks) * sizeof (int));\n \n-  blocks = sbitmap_alloc (n_basic_blocks);\n-\n   /* Compute regions for scheduling.  */\n   if (reload_completed\n       || n_basic_blocks == 1\n@@ -2849,21 +2858,26 @@ init_regions ()\n \t}\n     }\n \n-  deaths_in_region = (int *) xmalloc (sizeof (int) * nr_regions);\n \n-  /* Remove all death notes from the subroutine.  */\n-  for (rgn = 0; rgn < nr_regions; rgn++)\n+  if (CHECK_DEAD_NOTES)\n     {\n-      int b;\n+      blocks = sbitmap_alloc (n_basic_blocks);\n+      deaths_in_region = (int *) xmalloc (sizeof (int) * nr_regions);\n+      /* Remove all death notes from the subroutine.  */\n+      for (rgn = 0; rgn < nr_regions; rgn++)\n+\t{\n+\t  int b;\n \n-      sbitmap_zero (blocks);\n-      for (b = RGN_NR_BLOCKS (rgn) - 1; b >= 0; --b)\n-\tSET_BIT (blocks, rgn_bb_table[RGN_BLOCKS (rgn) + b]);\n+\t  sbitmap_zero (blocks);\n+\t  for (b = RGN_NR_BLOCKS (rgn) - 1; b >= 0; --b)\n+\t    SET_BIT (blocks, rgn_bb_table[RGN_BLOCKS (rgn) + b]);\n \n-      deaths_in_region[rgn] = count_or_remove_death_notes (blocks, 1);\n+\t  deaths_in_region[rgn] = count_or_remove_death_notes (blocks, 1);\n+\t}\n+      sbitmap_free (blocks);\n     }\n-\n-  sbitmap_free (blocks);\n+  else\n+    count_or_remove_death_notes (NULL, 1);\n }\n \n /* The one entry point in this file.  DUMP_FILE is the dump file for\n@@ -2916,39 +2930,50 @@ schedule_insns (dump_file)\n   sbitmap_ones (large_region_blocks);\n \n   blocks = sbitmap_alloc (n_basic_blocks);\n+  sbitmap_zero (blocks);\n \n+  /* Update life information.  For regions consisting of multiple blocks\n+     we've possibly done interblock scheduling that affects global liveness.\n+     For regions consisting of single blocks we need to do only local\n+     liveness.  */\n   for (rgn = 0; rgn < nr_regions; rgn++)\n     if (RGN_NR_BLOCKS (rgn) > 1)\n       any_large_regions = 1;\n     else\n       {\n-\tsbitmap_zero (blocks);\n \tSET_BIT (blocks, rgn_bb_table[RGN_BLOCKS (rgn)]);\n \tRESET_BIT (large_region_blocks, rgn_bb_table[RGN_BLOCKS (rgn)]);\n-\n-\t/* Don't update reg info after reload, since that affects\n-\t   regs_ever_live, which should not change after reload.  */\n-\tupdate_life_info (blocks, UPDATE_LIFE_LOCAL,\n-\t\t\t  (reload_completed ? PROP_DEATH_NOTES\n-\t\t\t   : PROP_DEATH_NOTES | PROP_REG_INFO));\n-\n-#ifndef HAVE_conditional_execution\n-\t/* ??? REG_DEAD notes only exist for unconditional deaths.  We need\n-\t   a count of the conditional plus unconditional deaths for this to\n-\t   work out.  */\n-\t/* In the single block case, the count of registers that died should\n-\t   not have changed during the schedule.  */\n-\tif (count_or_remove_death_notes (blocks, 0) != deaths_in_region[rgn])\n-\t  abort ();\n-#endif\n       }\n \n+  /* Don't update reg info after reload, since that affects\n+     regs_ever_live, which should not change after reload.  */\n+  update_life_info (blocks, UPDATE_LIFE_LOCAL,\n+\t\t    (reload_completed ? PROP_DEATH_NOTES\n+\t\t     : PROP_DEATH_NOTES | PROP_REG_INFO));\n   if (any_large_regions)\n     {\n       update_life_info (large_region_blocks, UPDATE_LIFE_GLOBAL,\n \t\t\tPROP_DEATH_NOTES | PROP_REG_INFO);\n     }\n \n+  if (CHECK_DEAD_NOTES)\n+    {\n+      /* Remove all death notes from the subroutine.  */\n+      for (rgn = 0; rgn < nr_regions; rgn++)\n+\tif (RGN_NR_BLOCKS (rgn) == 1)\n+\t  {\n+\t    int b;\n+\n+\t    sbitmap_zero (blocks);\n+\t    SET_BIT (blocks, rgn_bb_table[RGN_BLOCKS (rgn)]);\n+\n+\t    if (deaths_in_region[rgn]\n+\t\t!= count_or_remove_death_notes (blocks, 0))\n+\t      abort ();\n+\t  }\n+      free (deaths_in_region);\n+    }\n+\n   /* Reposition the prologue and epilogue notes in case we moved the\n      prologue/epilogue insns.  */\n   if (reload_completed)\n@@ -3001,7 +3026,5 @@ schedule_insns (dump_file)\n \n   sbitmap_free (blocks);\n   sbitmap_free (large_region_blocks);\n-\n-  free (deaths_in_region);\n }\n #endif"}]}