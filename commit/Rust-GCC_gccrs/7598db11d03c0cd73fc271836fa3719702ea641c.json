{"sha": "7598db11d03c0cd73fc271836fa3719702ea641c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzU5OGRiMTFkMDNjMGNkNzNmYzI3MTgzNmZhMzcxOTcwMmVhNjQxYw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1997-02-16T12:52:00Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1997-02-16T12:52:00Z"}, "message": "(print_operand): New operand output modifiers d,t,b,B,w.\n\n(simple_memory_operand): Removed.\n(one_bit_set_p, which_bit): Added from C. Nettleton's m1750 config.\n\nFrom-SVN: r13657", "tree": {"sha": "2f1ce0c6b6def16e6343d15d98e1af98b5cb1534", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2f1ce0c6b6def16e6343d15d98e1af98b5cb1534"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7598db11d03c0cd73fc271836fa3719702ea641c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7598db11d03c0cd73fc271836fa3719702ea641c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7598db11d03c0cd73fc271836fa3719702ea641c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7598db11d03c0cd73fc271836fa3719702ea641c/comments", "author": null, "committer": null, "parents": [{"sha": "9af35de0bc54295688fba58476b88e86cce8957a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9af35de0bc54295688fba58476b88e86cce8957a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9af35de0bc54295688fba58476b88e86cce8957a"}], "stats": {"total": 161, "additions": 100, "deletions": 61}, "files": [{"sha": "839df51cd2cfd89189dd139a0d9275591a6662eb", "filename": "gcc/config/1750a/1750a.c", "status": "modified", "additions": 100, "deletions": 61, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7598db11d03c0cd73fc271836fa3719702ea641c/gcc%2Fconfig%2F1750a%2F1750a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7598db11d03c0cd73fc271836fa3719702ea641c/gcc%2Fconfig%2F1750a%2F1750a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2F1750a%2F1750a.c?ref=7598db11d03c0cd73fc271836fa3719702ea641c", "patch": "@@ -331,46 +331,6 @@ b_mode_operand (op)\n   return 0;\n }\n \n-/* predicate needed for adding 1 to mem (short before output) */\n-int\n-simple_memory_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n-{\n-  rtx inner;\n-  if (GET_CODE (op) != MEM)\n-    return 0;\n-  inner = XEXP (op, 0);\n-  switch (GET_CODE (inner))\n-    {\n-    case REG:\n-    case SYMBOL_REF:\n-    case LABEL_REF:\n-      return 1;\n-    case PLUS:\n-      if (GET_CODE (XEXP (inner, 1)) != CONST_INT)\n-        return 0;\n-      inner = (XEXP (inner, 0));\n-      switch (GET_CODE (inner))\n-\t{\n-\tcase REG:\n-\tcase SYMBOL_REF:\n-\tcase LABEL_REF:\n-\t  return 1;\n-\tcase PLUS:\n-\t  if (GET_CODE (XEXP (inner, 1)) != CONST_INT)\n-            return 0;\n-\t  switch (GET_CODE (XEXP (inner, 0)))\n-\t    {\n-\t    case SYMBOL_REF:\n-\t    case LABEL_REF:\n-\t      return 1;\n-\t    }\n-\t}\n-    }\n-  return 0;\n-}\n-\n \n /* Decide whether to output a conditional jump as a \"Jump Conditional\"\n    or as a \"Branch Conditional\": */\n@@ -447,28 +407,62 @@ next_cc_user_is_unsigned (insn)\n \n static int addr_inc;\n \n-/* The PRINT_OPERAND and PRINT_OPERAND_ADDRESS macros have been\n-   made functions: */\n-\n-print_operand (file, x, kode)\n+/* A C compound statement to output to stdio stream STREAM the\n+   assembler syntax for an instruction operand X.  X is an RTL\n+   expression.\n+\n+   CODE is a value that can be used to specify one of several ways\n+   of printing the operand.  It is used when identical operands\n+   must be printed differently depending on the context.  CODE\n+   comes from the `%' specification that was used to request\n+   printing of the operand.  If the specification was just `%DIGIT'\n+   then CODE is 0; if the specification was `%LTR DIGIT' then CODE\n+   is the ASCII code for LTR.\n+\n+   If X is a register, this macro should print the register's name.\n+   The names can be found in an array `reg_names' whose type is\n+   `char *[]'.  `reg_names' is initialized from `REGISTER_NAMES'.\n+\n+   When the machine description has a specification `%PUNCT' (a `%'\n+   followed by a punctuation character), this macro is called with\n+   a null pointer for X and the punctuation character for CODE.\n+\n+   The 1750 specific codes are:\n+   'J' for the negative of a constant\n+   'Q' for printing addresses in B mode syntax\n+   'd' for the second register in a pair\n+   't' for the third register in a triple \n+   'b' for the bit number (using 1750 test bit convention)\n+   'B' for the bit number of the 1's complement (for bit clear)\n+   'w' for int - 16\n+*/\n+\n+print_operand (file, x, letter)\n      FILE *file;\n      rtx x;\n-     enum rtx_code kode;\n+     int letter;\n {\n   switch (GET_CODE (x))\n     {\n     case REG:\n-      fprintf (file, \"%d\", REGNO (x));\n+      if (letter == 'd')\n+\tfprintf (file, \"%d\", REGNO (x) + 1);\n+      else if (letter == 't')\n+\tfprintf (file, \"%d\", REGNO (x) + 2);\n+      else\n+\tfprintf (file, \"%d\", REGNO (x));\n       break;\n+\n     case SYMBOL_REF:\n       fprintf (file, \"%s\", XSTR (x, 0));\n-      if (kode == 'A')\n+      if (letter == 'A')\n \tfprintf (file, \"+1\");\n       break;\n+\n     case LABEL_REF:\n     case CONST:\n     case MEM:\n-      if (kode == 'Q')\n+      if (letter == 'Q')\n \t{\n \t  rtx inner = XEXP (x, 0);\n \t  switch (GET_CODE (inner))\n@@ -486,17 +480,18 @@ print_operand (file, x, kode)\n \t}\n       else\n \t{\n-\t  addr_inc = (kode == 'A' ? 1 : 0);\n+\t  addr_inc = (letter == 'A' ? 1 : 0);\n \t  output_address (XEXP (x, 0));\n \t}\n       break;\n+\n     case CONST_DOUBLE:\n /*    {\n \tdouble value = get_double (x);\n \tchar fltstr[32];\n \tsprintf (fltstr, \"%lf\", value);\n \n-\tif (kode == 'D' || kode == 'E')\n+\tif (letter == 'D' || letter == 'E')\n \t  {\n \t    int i, found = 0;\n \t    for (i = 0; i <= datalbl_ndx; i++)\n@@ -508,15 +503,15 @@ print_operand (file, x, kode)\n \t    if (!found)\n \t      {\n \t\tstrcpy (datalbl[i = ++datalbl_ndx].value, fltstr);\n-\t\tdatalbl[i].name = float_label (kode, value);\n-\t\tdatalbl[i].size = (kode == 'E') ? 3 : 2;\n+\t\tdatalbl[i].name = float_label (letter, value);\n+\t\tdatalbl[i].size = (letter == 'E') ? 3 : 2;\n \t\tcheck_section (Konst);\n \t\tfprintf (file, \"K%s \\tdata%s %s ;p_o\\n\", datalbl[i].name,\n-\t\t\t(kode == 'E' ? \"ef\" : \"f\"), fltstr);\n+\t\t\t(letter == 'E' ? \"ef\" : \"f\"), fltstr);\n \t\tcheck_section (Normal);\n \t      }\n \t  }\n-\telse if (kode == 'F' || kode == 'G')\n+\telse if (letter == 'F' || letter == 'G')\n \t  {\n \t    int i, found = 0;\n \t    for (i = 0; i <= datalbl_ndx; i++)\n@@ -530,11 +525,11 @@ print_operand (file, x, kode)\n \t\tfprintf (stderr,\n \t\t   \"float value %lfnot found upon label reference\\n\", value);\n \t\tstrcpy (datalbl[i = ++datalbl_ndx].value, fltstr);\n-\t\tdatalbl[i].name = float_label (kode, value);\n-\t\tdatalbl[i].size = (kode == 'G') ? 3 : 2;\n+\t\tdatalbl[i].name = float_label (letter, value);\n+\t\tdatalbl[i].size = (letter == 'G') ? 3 : 2;\n \t\tcheck_section (Konst);\n \t\tfprintf (file, \"K%s \\tdata%s %s ;p_o\\n\", datalbl[i].name,\n-\t\t\t(kode == 'G' ? \"ef\" : \"f\"), fltstr);\n+\t\t\t(letter == 'G' ? \"ef\" : \"f\"), fltstr);\n \t\tcheck_section (Normal);\n \t      }\n \t    fprintf (file, \"%s ;P_O 'F'\", datalbl[i].name);\n@@ -545,22 +540,29 @@ print_operand (file, x, kode)\n  */\n       fprintf (file, \"%lf\", get_double (x));\n       break;\n+\n     case CONST_INT:\n-      if (kode == 'J')\n+      if (letter == 'J')\n \tfprintf (file, \"%d\", -INTVAL (x));\n-      else if (INTVAL (x) > 0x7FFF)\n-\tfprintf (file, \"%d  ; range correction (val>0x7FFF) applied\",\n-\t\t INTVAL (x) - 0x10000);\n+      if (letter == 'b')\n+        fprintf (file, \"%d\", which_bit (INTVAL (x)));\n+      else if (letter == 'B')\n+        fprintf (file, \"%d\", which_bit (~INTVAL (x)));\n+      else if (letter == 'w')\n+\tfprintf (file, \"%d\", INTVAL (x) - 16);\n       else\n \tfprintf (file, \"%d\", INTVAL (x));\n       break;\n+\n     case CODE_LABEL:\n       fprintf (file, \"L%d\", XINT (x, 3));\n       break;\n+\n     case CALL:\n       fprintf (file, \"CALL nargs=%d, func is either '%s' or '%s'\",\n        XEXP (x, 1), XSTR (XEXP (XEXP (x, 0), 1), 0), XSTR (XEXP (x, 0), 1));\n       break;\n+\n     case PLUS:\n       {\n \trtx op0 = XEXP (x, 0), op1 = XEXP (x, 1);\n@@ -591,9 +593,11 @@ print_operand (file, x, kode)\n \t  fprintf (file, \"p_o_+: op0code=%d, op1code=%d\", op0code, op1code);\n       }\n       break;\n+\n     default:\n       fprintf (file, \"p_o_UFO code=%d\", GET_CODE (x));\n     }\n+\n   addr_inc = 0;\n }\n \n@@ -708,3 +712,38 @@ print_operand_address (file, addr)\n   addr_inc = 0;\n }\n \n+\n+/*\n+ *  Return non zero if the LS 16 bits of the given value has just one bit set,\n+ *  otherwise return zero. Note this function may be used to detect one\n+ *  bit clear by inverting the param.\n+ */\n+int\n+one_bit_set_p (x)\n+     int x;\n+{\n+  x &= 0xffff; \n+  return x && (x & (x - 1)) == 0;\n+}\n+\n+\n+/*\n+ * Return the number of the least significant bit set, using the  same\n+ * convention for bit numbering as in the MIL-STD-1750 sb instruction.\n+ */\n+int\n+which_bit (x)\n+     int x;\n+{\n+  int b = 15;\n+\n+  while (b > 0 && (x & 1) == 0)\n+    {\n+      b--;\n+      x >>= 1;\n+    }\n+\n+  return b;\n+}\n+\n+"}]}