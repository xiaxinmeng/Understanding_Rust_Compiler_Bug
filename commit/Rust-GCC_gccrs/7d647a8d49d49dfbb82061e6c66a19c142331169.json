{"sha": "7d647a8d49d49dfbb82061e6c66a19c142331169", "node_id": "C_kwDOANBUbNoAKDdkNjQ3YThkNDlkNDlkZmJiODIwNjFlNmM2NmExOWMxNDIzMzExNjk", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2022-09-14T06:01:16Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2022-09-14T15:06:48Z"}, "message": "Pass full range to build_* in range-op-float.cc\n\nThe build_<relop> helper functions in range-op-float.cc take the\nactual value from the operand's endpoint, but this value could be\ndeduced from the operand itself therefore cleaning up the call site.\nThis also reduces the potential of mistakenly passing the wrong bound.\n\nNo functional changes.\n\nRegstrapped on x86-64 Linux, plus I ran selftests for\n-ffinite-math-only.\n\ngcc/ChangeLog:\n\n\t* range-op-float.cc (build_le): Accept frange instead of number.\n\t(build_lt): Same.\n\t(build_ge): Same.\n\t(build_gt): Same.\n\t(foperator_lt::op1_range): Pass full range to build_*.\n\t(foperator_lt::op2_range): Same.\n\t(foperator_le::op1_range): Same.\n\t(foperator_le::op2_range): Same.\n\t(foperator_gt::op1_range): Same.\n\t(foperator_gt::op2_range): Same.\n\t(foperator_ge::op1_range): Same.\n\t(foperator_ge::op2_range): Same.", "tree": {"sha": "99d95f9dfa0e0918c5f2d1488b4cb6bb85712037", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/99d95f9dfa0e0918c5f2d1488b4cb6bb85712037"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7d647a8d49d49dfbb82061e6c66a19c142331169", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d647a8d49d49dfbb82061e6c66a19c142331169", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d647a8d49d49dfbb82061e6c66a19c142331169", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d647a8d49d49dfbb82061e6c66a19c142331169/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4a311a6160b3def190e64ca4a05a03fbcd163598", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a311a6160b3def190e64ca4a05a03fbcd163598", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a311a6160b3def190e64ca4a05a03fbcd163598"}], "stats": {"total": 72, "additions": 36, "deletions": 36}, "files": [{"sha": "8f3e5241313a0f947f902d66bb6cd1a6b3f5e68e", "filename": "gcc/range-op-float.cc", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d647a8d49d49dfbb82061e6c66a19c142331169/gcc%2Frange-op-float.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d647a8d49d49dfbb82061e6c66a19c142331169/gcc%2Frange-op-float.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frange-op-float.cc?ref=7d647a8d49d49dfbb82061e6c66a19c142331169", "patch": "@@ -208,70 +208,70 @@ frange_drop_ninf (frange &r, tree type)\n   r.intersect (tmp);\n }\n \n-// (X <= VAL) produces the range of [-INF, VAL].\n+// Build a range that is <= VAL and store it in R.\n \n static bool\n-build_le (frange &r, tree type, const REAL_VALUE_TYPE &val)\n+build_le (frange &r, tree type, const frange &val)\n {\n-  if (real_isnan (&val))\n+  if (val.known_nan ())\n     {\n       r.set_undefined ();\n       return false;\n     }\n-  r.set (type, dconstninf, val);\n+  r.set (type, dconstninf, val.upper_bound ());\n   return true;\n }\n \n-// (X < VAL) produces the range of [-INF, VAL).\n+// Build a range that is < VAL and store it in R.\n \n static bool\n-build_lt (frange &r, tree type, const REAL_VALUE_TYPE &val)\n+build_lt (frange &r, tree type, const frange &val)\n {\n-  if (real_isnan (&val))\n+  if (val.known_nan ())\n     {\n       r.set_undefined ();\n       return false;\n     }\n   // < -INF is outside the range.\n-  if (real_isinf (&val, 1))\n+  if (real_isinf (&val.upper_bound (), 1))\n     {\n       if (HONOR_NANS (type))\n \tr.set_nan (type);\n       else\n \tr.set_undefined ();\n       return false;\n     }\n-  // Hijack LE because we only support closed intervals.\n-  build_le (r, type, val);\n+  // We only support closed intervals.\n+  r.set (type, dconstninf, val.upper_bound ());\n   return true;\n }\n \n-// (X >= VAL) produces the range of [VAL, +INF].\n+// Build a range that is >= VAL and store it in R.\n \n static bool\n-build_ge (frange &r, tree type, const REAL_VALUE_TYPE &val)\n+build_ge (frange &r, tree type, const frange &val)\n {\n-  if (real_isnan (&val))\n+  if (val.known_nan ())\n     {\n       r.set_undefined ();\n       return false;\n     }\n-  r.set (type, val, dconstinf);\n+  r.set (type, val.lower_bound (), dconstinf);\n   return true;\n }\n \n-// (X > VAL) produces the range of (VAL, +INF].\n+// Build a range that is > VAL and store it in R.\n \n static bool\n-build_gt (frange &r, tree type, const REAL_VALUE_TYPE &val)\n+build_gt (frange &r, tree type, const frange &val)\n {\n-  if (real_isnan (&val))\n+  if (val.known_nan ())\n     {\n       r.set_undefined ();\n       return false;\n     }\n   // > +INF is outside the range.\n-  if (real_isinf (&val, 0))\n+  if (real_isinf (&val.lower_bound (), 0))\n     {\n       if (HONOR_NANS (type))\n \tr.set_nan (type);\n@@ -280,8 +280,8 @@ build_gt (frange &r, tree type, const REAL_VALUE_TYPE &val)\n       return false;\n     }\n \n-  // Hijack GE because we only support closed intervals.\n-  build_ge (r, type, val);\n+  // We only support closed intervals.\n+  r.set (type, val.lower_bound (), dconstinf);\n   return true;\n }\n \n@@ -549,7 +549,7 @@ foperator_lt::op1_range (frange &r,\n   switch (get_bool_state (r, lhs, type))\n     {\n     case BRS_TRUE:\n-      if (build_lt (r, type, op2.upper_bound ()))\n+      if (build_lt (r, type, op2))\n \t{\n \t  r.clear_nan ();\n \t  // x < y implies x is not +INF.\n@@ -558,7 +558,7 @@ foperator_lt::op1_range (frange &r,\n       break;\n \n     case BRS_FALSE:\n-      build_ge (r, type, op2.lower_bound ());\n+      build_ge (r, type, op2);\n       break;\n \n     default:\n@@ -577,7 +577,7 @@ foperator_lt::op2_range (frange &r,\n   switch (get_bool_state (r, lhs, type))\n     {\n     case BRS_TRUE:\n-      if (build_gt (r, type, op1.lower_bound ()))\n+      if (build_gt (r, type, op1))\n \t{\n \t  r.clear_nan ();\n \t  // x < y implies y is not -INF.\n@@ -586,7 +586,7 @@ foperator_lt::op2_range (frange &r,\n       break;\n \n     case BRS_FALSE:\n-      build_le (r, type, op1.upper_bound ());\n+      build_le (r, type, op1);\n       break;\n \n     default:\n@@ -651,12 +651,12 @@ foperator_le::op1_range (frange &r,\n   switch (get_bool_state (r, lhs, type))\n     {\n     case BRS_TRUE:\n-      if (build_le (r, type, op2.upper_bound ()))\n+      if (build_le (r, type, op2))\n \tr.clear_nan ();\n       break;\n \n     case BRS_FALSE:\n-      build_gt (r, type, op2.lower_bound ());\n+      build_gt (r, type, op2);\n       break;\n \n     default:\n@@ -675,12 +675,12 @@ foperator_le::op2_range (frange &r,\n   switch (get_bool_state (r, lhs, type))\n     {\n     case BRS_TRUE:\n-      if (build_ge (r, type, op1.lower_bound ()))\n+      if (build_ge (r, type, op1))\n \tr.clear_nan ();\n       break;\n \n     case BRS_FALSE:\n-      build_lt (r, type, op1.upper_bound ());\n+      build_lt (r, type, op1);\n       break;\n \n     default:\n@@ -745,7 +745,7 @@ foperator_gt::op1_range (frange &r,\n   switch (get_bool_state (r, lhs, type))\n     {\n     case BRS_TRUE:\n-      if (build_gt (r, type, op2.lower_bound ()))\n+      if (build_gt (r, type, op2))\n \t{\n \t  r.clear_nan ();\n \t  // x > y implies x is not -INF.\n@@ -754,7 +754,7 @@ foperator_gt::op1_range (frange &r,\n       break;\n \n     case BRS_FALSE:\n-      build_le (r, type, op2.upper_bound ());\n+      build_le (r, type, op2);\n       break;\n \n     default:\n@@ -773,7 +773,7 @@ foperator_gt::op2_range (frange &r,\n   switch (get_bool_state (r, lhs, type))\n     {\n     case BRS_TRUE:\n-      if (build_lt (r, type, op1.upper_bound ()))\n+      if (build_lt (r, type, op1))\n \t{\n \t  r.clear_nan ();\n \t  // x > y implies y is not +INF.\n@@ -782,7 +782,7 @@ foperator_gt::op2_range (frange &r,\n       break;\n \n     case BRS_FALSE:\n-      build_ge (r, type, op1.lower_bound ());\n+      build_ge (r, type, op1);\n       break;\n \n     default:\n@@ -847,12 +847,12 @@ foperator_ge::op1_range (frange &r,\n   switch (get_bool_state (r, lhs, type))\n     {\n     case BRS_TRUE:\n-      build_ge (r, type, op2.lower_bound ());\n+      build_ge (r, type, op2);\n       r.clear_nan ();\n       break;\n \n     case BRS_FALSE:\n-      build_lt (r, type, op2.upper_bound ());\n+      build_lt (r, type, op2);\n       break;\n \n     default:\n@@ -870,11 +870,11 @@ foperator_ge::op2_range (frange &r, tree type,\n   switch (get_bool_state (r, lhs, type))\n     {\n     case BRS_FALSE:\n-      build_gt (r, type, op1.lower_bound ());\n+      build_gt (r, type, op1);\n       break;\n \n     case BRS_TRUE:\n-      build_le (r, type, op1.upper_bound ());\n+      build_le (r, type, op1);\n       r.clear_nan ();\n       break;\n "}]}