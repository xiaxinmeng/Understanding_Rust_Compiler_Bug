{"sha": "c9c5a8090c58b84c1eb45e39e77eee223f992009", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzljNWE4MDkwYzU4Yjg0YzFlYjQ1ZTM5ZTc3ZWVlMjIzZjk5MjAwOQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-08-14T08:16:04Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-08-14T08:16:04Z"}, "message": "[AArch64] Add a \"GP strictness\" operand to SVE FP unspecs\n\nThis patch makes the SVE unary, binary and ternary FP unspecs\ntake a new \"GP strictness\" operand that indicates whether the\npredicate has to be taken literally, or whether it is valid to\nmake extra lanes active (up to and including using a PTRUE).\n\nThis again is laying the groundwork for the ACLE patterns,\nin which the value can depend on the FP command-line flags.\n\nAt the moment it's only needed for addition, subtraction and\nmultiplication, which have unpredicated forms that can only\nbe used when operating on all lanes is safe.  But in future\nit might be useful for optimising predicate usage.\n\nThe strict mode requires extra alternatives for addition,\nsubtraction and multiplication, but I've left those for the\nmain ACLE patch.\n\n2019-08-14  Richard Sandiford  <richard.sandiford@arm.com>\n\t    Kugan Vivekanandarajah  <kugan.vivekanandarajah@linaro.org>\n\ngcc/\n\t* config/aarch64/aarch64.md (SVE_RELAXED_GP, SVE_STRICT_GP): New\n\tconstants.\n\t* config/aarch64/predicates.md (aarch64_sve_gp_strictness): New\n\tpredicate.\n\t* config/aarch64/aarch64-protos.h (aarch64_sve_pred_dominates_p):\n\tDeclare.\n\t* config/aarch64/aarch64.c (aarch64_sve_pred_dominates_p): New\n\tfunction.\n\t* config/aarch64/aarch64-sve.md: Add a block comment about the\n\thandling of predicated FP operations.\n\t(<SVE_COND_FP_UNARY:optab><SVE_F:mode>2, add<SVE_F:mode>3)\n\t(sub<SVE_F:mode>3, mul<SVE_F:mode>3, div<SVE_F:mode>3)\n\t(<SVE_COND_FP_MAXMIN_PUBLIC:optab><SVE_F:mode>3)\n\t(<SVE_COND_FP_MAXMIN_PUBLIC:maxmin_uns><SVE_F:mode>3)\n\t(<SVE_COND_FP_TERNARY:optab><SVE_F:mode>4): Add an SVE_RELAXED_GP\n\toperand.\n\t(cond_<SVE_COND_FP_BINARY:optab><SVE_F:mode>)\n\t(cond_<SVE_COND_FP_TERNARY:optab><SVE_F:mode>): Add an SVE_STRICT_GP\n\toperand.\n\t(*<SVE_COND_FP_UNARY:optab><SVE_F:mode>2)\n\t(*cond_<SVE_COND_FP_BINARY:optab><SVE_F:mode>_2)\n\t(*cond_<SVE_COND_FP_BINARY:optab><SVE_F:mode>_3)\n\t(*cond_<SVE_COND_FP_BINARY:optab><SVE_F:mode>_any)\n\t(*fabd<SVE_F:mode>3, *div<SVE_F:mode>3)\n\t(*<SVE_COND_FP_MAXMIN_PUBLIC:optab><SVE_F:mode>3)\n\t(*<SVE_COND_FP_TERNARY:optab><SVE_F:mode>4)\n\t(*cond_<SVE_COND_FP_TERNARY:optab><SVE_F:mode>_2)\n\t(*cond_<SVE_COND_FP_TERNARY:optab><SVE_F:mode>_4)\n\t(*cond_<SVE_COND_FP_TERNARY:optab><SVE_F:mode>_any): Match the\n\tstrictness operands.  Use aarch64_sve_pred_dominates_p to check\n\twhether the predicate on the conditional operation is suitable\n\tfor merging.  Split patterns into the canonical equal-predicate form.\n\t(*add<SVE_F:mode>3, *sub<SVE_F:mode>3, *mul<SVE_F:mode>3): Likewise.\n\tRestrict the unpredicated alternatives to SVE_RELAXED_GP.\n\nCo-Authored-By: Kugan Vivekanandarajah <kuganv@linaro.org>\n\nFrom-SVN: r274418", "tree": {"sha": "0b582b31fcbaa8a7494f664504b8280c1a12812b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0b582b31fcbaa8a7494f664504b8280c1a12812b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c9c5a8090c58b84c1eb45e39e77eee223f992009", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9c5a8090c58b84c1eb45e39e77eee223f992009", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c9c5a8090c58b84c1eb45e39e77eee223f992009", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9c5a8090c58b84c1eb45e39e77eee223f992009/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6fe679cc6be7a55832f9b88a8cf0751e8d5eff6e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6fe679cc6be7a55832f9b88a8cf0751e8d5eff6e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6fe679cc6be7a55832f9b88a8cf0751e8d5eff6e"}], "stats": {"total": 283, "additions": 248, "deletions": 35}, "files": [{"sha": "9a918d49896c4c27ff02ee4ed85979cec5c23ead", "filename": "gcc/ChangeLog", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9c5a8090c58b84c1eb45e39e77eee223f992009/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9c5a8090c58b84c1eb45e39e77eee223f992009/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c9c5a8090c58b84c1eb45e39e77eee223f992009", "patch": "@@ -1,3 +1,41 @@\n+2019-08-14  Richard Sandiford  <richard.sandiford@arm.com>\n+\t    Kugan Vivekanandarajah  <kugan.vivekanandarajah@linaro.org>\n+\n+\t* config/aarch64/aarch64.md (SVE_RELAXED_GP, SVE_STRICT_GP): New\n+\tconstants.\n+\t* config/aarch64/predicates.md (aarch64_sve_gp_strictness): New\n+\tpredicate.\n+\t* config/aarch64/aarch64-protos.h (aarch64_sve_pred_dominates_p):\n+\tDeclare.\n+\t* config/aarch64/aarch64.c (aarch64_sve_pred_dominates_p): New\n+\tfunction.\n+\t* config/aarch64/aarch64-sve.md: Add a block comment about the\n+\thandling of predicated FP operations.\n+\t(<SVE_COND_FP_UNARY:optab><SVE_F:mode>2, add<SVE_F:mode>3)\n+\t(sub<SVE_F:mode>3, mul<SVE_F:mode>3, div<SVE_F:mode>3)\n+\t(<SVE_COND_FP_MAXMIN_PUBLIC:optab><SVE_F:mode>3)\n+\t(<SVE_COND_FP_MAXMIN_PUBLIC:maxmin_uns><SVE_F:mode>3)\n+\t(<SVE_COND_FP_TERNARY:optab><SVE_F:mode>4): Add an SVE_RELAXED_GP\n+\toperand.\n+\t(cond_<SVE_COND_FP_BINARY:optab><SVE_F:mode>)\n+\t(cond_<SVE_COND_FP_TERNARY:optab><SVE_F:mode>): Add an SVE_STRICT_GP\n+\toperand.\n+\t(*<SVE_COND_FP_UNARY:optab><SVE_F:mode>2)\n+\t(*cond_<SVE_COND_FP_BINARY:optab><SVE_F:mode>_2)\n+\t(*cond_<SVE_COND_FP_BINARY:optab><SVE_F:mode>_3)\n+\t(*cond_<SVE_COND_FP_BINARY:optab><SVE_F:mode>_any)\n+\t(*fabd<SVE_F:mode>3, *div<SVE_F:mode>3)\n+\t(*<SVE_COND_FP_MAXMIN_PUBLIC:optab><SVE_F:mode>3)\n+\t(*<SVE_COND_FP_TERNARY:optab><SVE_F:mode>4)\n+\t(*cond_<SVE_COND_FP_TERNARY:optab><SVE_F:mode>_2)\n+\t(*cond_<SVE_COND_FP_TERNARY:optab><SVE_F:mode>_4)\n+\t(*cond_<SVE_COND_FP_TERNARY:optab><SVE_F:mode>_any): Match the\n+\tstrictness operands.  Use aarch64_sve_pred_dominates_p to check\n+\twhether the predicate on the conditional operation is suitable\n+\tfor merging.  Split patterns into the canonical equal-predicate form.\n+\t(*add<SVE_F:mode>3, *sub<SVE_F:mode>3, *mul<SVE_F:mode>3): Likewise.\n+\tRestrict the unpredicated alternatives to SVE_RELAXED_GP.\n+\n 2019-08-14  Richard Sandiford  <richard.sandiford@arm.com>\n \t    Kugan Vivekanandarajah  <kugan.vivekanandarajah@linaro.org>\n "}, {"sha": "a4728e77c1d17add6ed81d18d9ef674e63fb5d94", "filename": "gcc/config/aarch64/aarch64-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9c5a8090c58b84c1eb45e39e77eee223f992009/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9c5a8090c58b84c1eb45e39e77eee223f992009/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h?ref=c9c5a8090c58b84c1eb45e39e77eee223f992009", "patch": "@@ -554,6 +554,7 @@ rtx aarch64_ptrue_all (unsigned int);\n void aarch64_expand_mov_immediate (rtx, rtx);\n rtx aarch64_ptrue_reg (machine_mode);\n rtx aarch64_pfalse_reg (machine_mode);\n+bool aarch64_sve_pred_dominates_p (rtx *, rtx);\n void aarch64_emit_sve_pred_move (rtx, rtx, rtx);\n void aarch64_expand_sve_mem_move (rtx, rtx, machine_mode);\n bool aarch64_maybe_expand_sve_subreg_move (rtx, rtx);"}, {"sha": "9fb59024b445cb5ecd2b620696eb8784b195529d", "filename": "gcc/config/aarch64/aarch64-sve.md", "status": "modified", "additions": 174, "deletions": 35, "changes": 209, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9c5a8090c58b84c1eb45e39e77eee223f992009/gcc%2Fconfig%2Faarch64%2Faarch64-sve.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9c5a8090c58b84c1eb45e39e77eee223f992009/gcc%2Fconfig%2Faarch64%2Faarch64-sve.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-sve.md?ref=c9c5a8090c58b84c1eb45e39e77eee223f992009", "patch": "@@ -24,6 +24,7 @@\n ;; == General notes\n ;; ---- Note on the handling of big-endian SVE\n ;; ---- Description of UNSPEC_PTEST\n+;; ---- Note on predicated FP arithmetic patterns and GP \"strictness\"\n ;;\n ;; == Moves\n ;; ---- Moves of single vectors\n@@ -228,6 +229,83 @@\n ;;   SVE_MAYBE_NOT_PTRUE otherwise.\n ;;\n ;; - OP is the predicate we want to test, of the same mode as CAST_GP.\n+;;\n+;; -------------------------------------------------------------------------\n+;; ---- Note on predicated FP arithmetic patterns and GP \"strictness\"\n+;; -------------------------------------------------------------------------\n+;;\n+;; Most SVE floating-point operations are predicated.  We can generate\n+;; them from four sources:\n+;;\n+;; (1) Using normal unpredicated optabs.  In this case we need to create\n+;;     an all-true predicate register to act as the governing predicate\n+;;     for the SVE instruction.  There are no inactive lanes, and thus\n+;;     the values of inactive lanes don't matter.\n+;;\n+;; (2) Using _x ACLE functions.  In this case the function provides a\n+;;     specific predicate and some lanes might be inactive.  However,\n+;;     as for (1), the values of the inactive lanes don't matter.\n+;;\n+;;     The instruction must have the same exception behavior as the\n+;;     function call unless things like command-line flags specifically\n+;;     allow otherwise.  For example, with -ffast-math, it is OK to\n+;;     raise exceptions for inactive lanes, but normally it isn't.\n+;;\n+;; (3) Using cond_* optabs that correspond to IFN_COND_* internal functions.\n+;;     These optabs have a predicate operand that specifies which lanes are\n+;;     active and another operand that provides the values of inactive lanes.\n+;;\n+;; (4) Using _m and _z ACLE functions.  These functions map to the same\n+;;     patterns as (3), with the _z functions setting inactive lanes to zero\n+;;     and the _m functions setting the inactive lanes to one of the function\n+;;     arguments.\n+;;\n+;; So:\n+;;\n+;; - In (1), the predicate is known to be all true and the pattern can use\n+;;   unpredicated operations where available.\n+;;\n+;; - In (2), the predicate might or might not be all true.  The pattern can\n+;;   use unpredicated instructions if the predicate is all-true or if things\n+;;   like command-line flags allow exceptions for inactive lanes.\n+;;\n+;; - (3) and (4) represent a native SVE predicated operation.  Some lanes\n+;;   might be inactive and inactive lanes of the result must have specific\n+;;   values.  There is no scope for using unpredicated instructions (and no\n+;;   reason to want to), so the question about command-line flags doesn't\n+;;   arise.\n+;;\n+;; It would be inaccurate to model (2) as an rtx code like (sqrt ...)\n+;; in combination with a separate predicate operand, e.g.\n+;;\n+;;   (unspec [(match_operand:<VPRED> 1 \"register_operand\" \"Upl\")\n+;;\t      (sqrt:SVE_F 2 \"register_operand\" \"w\")]\n+;;\t     ....)\n+;;\n+;; because (sqrt ...) can raise an exception for any lane, including\n+;; inactive ones.  We therefore need to use an unspec instead.\n+;;\n+;; Also, (2) requires some way of distinguishing the case in which the\n+;; predicate might have inactive lanes and cannot be changed from the\n+;; case in which the predicate has no inactive lanes or can be changed.\n+;; This information is also useful when matching combined FP patterns\n+;; in which the predicates might not be equal.\n+;;\n+;; We therefore model FP operations as an unspec of the form:\n+;;\n+;;   (unspec [pred strictness op0 op1 ...] UNSPEC_COND_<MNEMONIC>)\n+;;\n+;; where:\n+;;\n+;; - PRED is the governing predicate.\n+;;\n+;; - STRICTNESS is a CONST_INT that conceptually has mode SI.  It has the\n+;;   value SVE_STRICT_GP if PRED might have inactive lanes and if those\n+;;   lanes must remain inactive.  It has the value SVE_RELAXED_GP otherwise.\n+;;\n+;; - OP0 OP1 ... are the normal input operands to the operation.\n+;;\n+;; - MNEMONIC is the mnemonic of the associated SVE instruction.\n \n ;; =========================================================================\n ;; == Moves\n@@ -1290,6 +1368,7 @@\n   [(set (match_operand:SVE_F 0 \"register_operand\")\n \t(unspec:SVE_F\n \t  [(match_dup 2)\n+\t   (const_int SVE_RELAXED_GP)\n \t   (match_operand:SVE_F 1 \"register_operand\")]\n \t  SVE_COND_FP_UNARY))]\n   \"TARGET_SVE\"\n@@ -1303,6 +1382,7 @@\n   [(set (match_operand:SVE_F 0 \"register_operand\" \"=w\")\n \t(unspec:SVE_F\n \t  [(match_operand:<VPRED> 1 \"register_operand\" \"Upl\")\n+\t   (match_operand:SI 3 \"aarch64_sve_gp_strictness\")\n \t   (match_operand:SVE_F 2 \"register_operand\" \"w\")]\n \t  SVE_COND_FP_UNARY))]\n   \"TARGET_SVE\"\n@@ -1964,6 +2044,7 @@\n \t  [(match_operand:<VPRED> 1 \"register_operand\")\n \t   (unspec:SVE_F\n \t     [(match_dup 1)\n+\t      (const_int SVE_STRICT_GP)\n \t      (match_operand:SVE_F 2 \"register_operand\")\n \t      (match_operand:SVE_F 3 \"register_operand\")]\n \t     SVE_COND_FP_BINARY)\n@@ -1973,40 +2054,50 @@\n )\n \n ;; Predicated floating-point operations, merging with the first input.\n-(define_insn \"*cond_<optab><mode>_2\"\n+(define_insn_and_rewrite \"*cond_<optab><mode>_2\"\n   [(set (match_operand:SVE_F 0 \"register_operand\" \"=w, ?&w\")\n \t(unspec:SVE_F\n \t  [(match_operand:<VPRED> 1 \"register_operand\" \"Upl, Upl\")\n \t   (unspec:SVE_F\n-\t     [(match_dup 1)\n+\t     [(match_operand 4)\n+\t      (match_operand:SI 5 \"aarch64_sve_gp_strictness\")\n \t      (match_operand:SVE_F 2 \"register_operand\" \"0, w\")\n \t      (match_operand:SVE_F 3 \"register_operand\" \"w, w\")]\n \t     SVE_COND_FP_BINARY)\n \t   (match_dup 2)]\n \t  UNSPEC_SEL))]\n-  \"TARGET_SVE\"\n+  \"TARGET_SVE && aarch64_sve_pred_dominates_p (&operands[4], operands[1])\"\n   \"@\n    <sve_fp_op>\\t%0.<Vetype>, %1/m, %0.<Vetype>, %3.<Vetype>\n    movprfx\\t%0, %2\\;<sve_fp_op>\\t%0.<Vetype>, %1/m, %0.<Vetype>, %3.<Vetype>\"\n+  \"&& !rtx_equal_p (operands[1], operands[4])\"\n+  {\n+    operands[4] = copy_rtx (operands[1]);\n+  }\n   [(set_attr \"movprfx\" \"*,yes\")]\n )\n \n ;; Predicated floating-point operations, merging with the second input.\n-(define_insn \"*cond_<optab><mode>_3\"\n+(define_insn_and_rewrite \"*cond_<optab><mode>_3\"\n   [(set (match_operand:SVE_F 0 \"register_operand\" \"=w, ?&w\")\n \t(unspec:SVE_F\n \t  [(match_operand:<VPRED> 1 \"register_operand\" \"Upl, Upl\")\n \t   (unspec:SVE_F\n-\t     [(match_dup 1)\n+\t     [(match_operand 4)\n+\t      (match_operand:SI 5 \"aarch64_sve_gp_strictness\")\n \t      (match_operand:SVE_F 2 \"register_operand\" \"w, w\")\n \t      (match_operand:SVE_F 3 \"register_operand\" \"0, w\")]\n \t     SVE_COND_FP_BINARY)\n \t   (match_dup 3)]\n \t  UNSPEC_SEL))]\n-  \"TARGET_SVE\"\n+  \"TARGET_SVE && aarch64_sve_pred_dominates_p (&operands[4], operands[1])\"\n   \"@\n    <sve_fp_op_rev>\\t%0.<Vetype>, %1/m, %0.<Vetype>, %2.<Vetype>\n    movprfx\\t%0, %3\\;<sve_fp_op_rev>\\t%0.<Vetype>, %1/m, %0.<Vetype>, %2.<Vetype>\"\n+  \"&& !rtx_equal_p (operands[1], operands[4])\"\n+  {\n+    operands[4] = copy_rtx (operands[1]);\n+  }\n   [(set_attr \"movprfx\" \"*,yes\")]\n )\n \n@@ -2016,28 +2107,37 @@\n \t(unspec:SVE_F\n \t  [(match_operand:<VPRED> 1 \"register_operand\" \"Upl, Upl, Upl, Upl, Upl\")\n \t   (unspec:SVE_F\n-\t     [(match_dup 1)\n+\t     [(match_operand 5)\n+\t      (match_operand:SI 6 \"aarch64_sve_gp_strictness\")\n \t      (match_operand:SVE_F 2 \"register_operand\" \"0, w, w, w, w\")\n \t      (match_operand:SVE_F 3 \"register_operand\" \"w, 0, w, w, w\")]\n \t     SVE_COND_FP_BINARY)\n \t   (match_operand:SVE_F 4 \"aarch64_simd_reg_or_zero\" \"Dz, Dz, Dz, 0, w\")]\n \t  UNSPEC_SEL))]\n   \"TARGET_SVE\n    && !rtx_equal_p (operands[2], operands[4])\n-   && !rtx_equal_p (operands[3], operands[4])\"\n+   && !rtx_equal_p (operands[3], operands[4])\n+   && aarch64_sve_pred_dominates_p (&operands[5], operands[1])\"\n   \"@\n    movprfx\\t%0.<Vetype>, %1/z, %0.<Vetype>\\;<sve_fp_op>\\t%0.<Vetype>, %1/m, %0.<Vetype>, %3.<Vetype>\n    movprfx\\t%0.<Vetype>, %1/z, %0.<Vetype>\\;<sve_fp_op_rev>\\t%0.<Vetype>, %1/m, %0.<Vetype>, %2.<Vetype>\n    movprfx\\t%0.<Vetype>, %1/z, %2.<Vetype>\\;<sve_fp_op>\\t%0.<Vetype>, %1/m, %0.<Vetype>, %3.<Vetype>\n    movprfx\\t%0.<Vetype>, %1/m, %2.<Vetype>\\;<sve_fp_op>\\t%0.<Vetype>, %1/m, %0.<Vetype>, %3.<Vetype>\n    #\"\n-  \"&& reload_completed\n-   && register_operand (operands[4], <MODE>mode)\n-   && !rtx_equal_p (operands[0], operands[4])\"\n+  \"&& 1\"\n   {\n-    emit_insn (gen_vcond_mask_<mode><vpred> (operands[0], operands[2],\n-\t\t\t\t\t     operands[4], operands[1]));\n-    operands[4] = operands[2] = operands[0];\n+    if (reload_completed\n+        && register_operand (operands[4], <MODE>mode)\n+        && !rtx_equal_p (operands[0], operands[4]))\n+      {\n+\temit_insn (gen_vcond_mask_<mode><vpred> (operands[0], operands[2],\n+\t\t\t\t\t\t operands[4], operands[1]));\n+\toperands[4] = operands[2] = operands[0];\n+      }\n+    else if (!rtx_equal_p (operands[1], operands[5]))\n+      operands[5] = copy_rtx (operands[1]);\n+    else\n+      FAIL;\n   }\n   [(set_attr \"movprfx\" \"yes\")]\n )\n@@ -2055,6 +2155,7 @@\n   [(set (match_operand:SVE_F 0 \"register_operand\")\n \t(unspec:SVE_F\n \t  [(match_dup 3)\n+\t   (const_int SVE_RELAXED_GP)\n \t   (match_operand:SVE_F 1 \"register_operand\")\n \t   (match_operand:SVE_F 2 \"aarch64_sve_float_arith_with_sub_operand\")]\n \t  UNSPEC_COND_FADD))]\n@@ -2064,11 +2165,12 @@\n   }\n )\n \n-;; Floating-point addition predicated with a PTRUE.\n+;; Predicated floating-point addition.\n (define_insn_and_split \"*add<mode>3\"\n   [(set (match_operand:SVE_F 0 \"register_operand\" \"=w, w, w\")\n \t(unspec:SVE_F\n \t  [(match_operand:<VPRED> 1 \"register_operand\" \"Upl, Upl, Upl\")\n+\t   (match_operand:SI 4 \"aarch64_sve_gp_strictness\" \"i, i, Z\")\n \t   (match_operand:SVE_F 2 \"register_operand\" \"%0, 0, w\")\n \t   (match_operand:SVE_F 3 \"aarch64_sve_float_arith_with_sub_operand\" \"vsA, vsN, w\")]\n \t  UNSPEC_COND_FADD))]\n@@ -2100,6 +2202,7 @@\n   [(set (match_operand:SVE_F 0 \"register_operand\")\n \t(unspec:SVE_F\n \t  [(match_dup 3)\n+\t   (const_int SVE_RELAXED_GP)\n \t   (match_operand:SVE_F 1 \"aarch64_sve_float_arith_operand\")\n \t   (match_operand:SVE_F 2 \"register_operand\")]\n \t  UNSPEC_COND_FSUB))]\n@@ -2109,11 +2212,12 @@\n   }\n )\n \n-;; Floating-point subtraction predicated with a PTRUE.\n+;; Predicated floating-point subtraction.\n (define_insn_and_split \"*sub<mode>3\"\n   [(set (match_operand:SVE_F 0 \"register_operand\" \"=w, w, w, w\")\n \t(unspec:SVE_F\n \t  [(match_operand:<VPRED> 1 \"register_operand\" \"Upl, Upl, Upl, Upl\")\n+\t   (match_operand:SI 4 \"aarch64_sve_gp_strictness\" \"i, i, i, Z\")\n \t   (match_operand:SVE_F 2 \"aarch64_sve_float_arith_operand\" \"0, 0, vsA, w\")\n \t   (match_operand:SVE_F 3 \"aarch64_sve_float_arith_with_sub_operand\" \"vsA, vsN, 0, w\")]\n \t  UNSPEC_COND_FSUB))]\n@@ -2143,18 +2247,24 @@\n ;; -------------------------------------------------------------------------\n \n ;; Predicated floating-point absolute difference.\n-(define_insn \"*fabd<mode>3\"\n+(define_insn_and_rewrite \"*fabd<mode>3\"\n   [(set (match_operand:SVE_F 0 \"register_operand\" \"=w\")\n \t(unspec:SVE_F\n \t  [(match_operand:<VPRED> 1 \"register_operand\" \"Upl\")\n+\t   (match_operand:SI 4 \"aarch64_sve_gp_strictness\")\n \t   (unspec:SVE_F\n-\t     [(match_dup 1)\n+\t     [(match_operand 5)\n+\t      (match_operand:SI 6 \"aarch64_sve_gp_strictness\")\n \t      (match_operand:SVE_F 2 \"register_operand\" \"0\")\n \t      (match_operand:SVE_F 3 \"register_operand\" \"w\")]\n \t     UNSPEC_COND_FSUB)]\n \t  UNSPEC_COND_FABS))]\n-  \"TARGET_SVE\"\n+  \"TARGET_SVE && aarch64_sve_pred_dominates_p (&operands[5], operands[1])\"\n   \"fabd\\t%0.<Vetype>, %1/m, %2.<Vetype>, %3.<Vetype>\"\n+  \"&& !rtx_equal_p (operands[1], operands[5])\"\n+  {\n+    operands[5] = copy_rtx (operands[1]);\n+  }\n )\n \n ;; -------------------------------------------------------------------------\n@@ -2169,6 +2279,7 @@\n   [(set (match_operand:SVE_F 0 \"register_operand\")\n \t(unspec:SVE_F\n \t  [(match_dup 3)\n+\t   (const_int SVE_RELAXED_GP)\n \t   (match_operand:SVE_F 1 \"register_operand\")\n \t   (match_operand:SVE_F 2 \"aarch64_sve_float_mul_operand\")]\n \t  UNSPEC_COND_FMUL))]\n@@ -2178,11 +2289,12 @@\n   }\n )\n \n-;; Floating-point multiplication predicated with a PTRUE.\n+;; Predicated floating-point multiplication.\n (define_insn_and_split \"*mul<mode>3\"\n   [(set (match_operand:SVE_F 0 \"register_operand\" \"=w, w\")\n \t(unspec:SVE_F\n \t  [(match_operand:<VPRED> 1 \"register_operand\" \"Upl, Upl\")\n+\t   (match_operand:SI 4 \"aarch64_sve_gp_strictness\" \"i, Z\")\n \t   (match_operand:SVE_F 2 \"register_operand\" \"%0, w\")\n \t   (match_operand:SVE_F 3 \"aarch64_sve_float_mul_operand\" \"vsM, w\")]\n \t  UNSPEC_COND_FMUL))]\n@@ -2212,6 +2324,7 @@\n   [(set (match_operand:SVE_F 0 \"register_operand\")\n \t(unspec:SVE_F\n \t  [(match_dup 3)\n+\t   (const_int SVE_RELAXED_GP)\n \t   (match_operand:SVE_F 1 \"register_operand\")\n \t   (match_operand:SVE_F 2 \"register_operand\")]\n \t  UNSPEC_COND_FDIV))]\n@@ -2221,11 +2334,12 @@\n   }\n )\n \n-;; Floating-point division predicated with a PTRUE.\n+;; Predicated floating-point division.\n (define_insn \"*div<mode>3\"\n   [(set (match_operand:SVE_F 0 \"register_operand\" \"=w, w, ?&w\")\n \t(unspec:SVE_F\n \t  [(match_operand:<VPRED> 1 \"register_operand\" \"Upl, Upl, Upl\")\n+\t   (match_operand:SI 4 \"aarch64_sve_gp_strictness\")\n \t   (match_operand:SVE_F 2 \"register_operand\" \"0, w, w\")\n \t   (match_operand:SVE_F 3 \"register_operand\" \"w, 0, w\")]\n \t  UNSPEC_COND_FDIV))]\n@@ -2334,6 +2448,7 @@\n   [(set (match_operand:SVE_F 0 \"register_operand\")\n \t(unspec:SVE_F\n \t  [(match_dup 3)\n+\t   (const_int SVE_RELAXED_GP)\n \t   (match_operand:SVE_F 1 \"register_operand\")\n \t   (match_operand:SVE_F 2 \"register_operand\")]\n \t  SVE_COND_FP_MAXMIN_PUBLIC))]\n@@ -2348,6 +2463,7 @@\n   [(set (match_operand:SVE_F 0 \"register_operand\")\n \t(unspec:SVE_F\n \t  [(match_dup 3)\n+\t   (const_int SVE_RELAXED_GP)\n \t   (match_operand:SVE_F 1 \"register_operand\")\n \t   (match_operand:SVE_F 2 \"register_operand\")]\n \t  SVE_COND_FP_MAXMIN_PUBLIC))]\n@@ -2362,6 +2478,7 @@\n   [(set (match_operand:SVE_F 0 \"register_operand\" \"=w, ?&w\")\n \t(unspec:SVE_F\n \t  [(match_operand:<VPRED> 1 \"register_operand\" \"Upl, Upl\")\n+\t   (match_operand:SI 4 \"aarch64_sve_gp_strictness\")\n \t   (match_operand:SVE_F 2 \"register_operand\" \"%0, w\")\n \t   (match_operand:SVE_F 3 \"register_operand\" \"w, w\")]\n \t  SVE_COND_FP_MAXMIN_PUBLIC))]\n@@ -2612,6 +2729,7 @@\n   [(set (match_operand:SVE_F 0 \"register_operand\")\n \t(unspec:SVE_F\n \t  [(match_dup 4)\n+\t   (const_int SVE_RELAXED_GP)\n \t   (match_operand:SVE_F 1 \"register_operand\")\n \t   (match_operand:SVE_F 2 \"register_operand\")\n \t   (match_operand:SVE_F 3 \"register_operand\")]\n@@ -2627,6 +2745,7 @@\n   [(set (match_operand:SVE_F 0 \"register_operand\" \"=w, w, ?&w\")\n \t(unspec:SVE_F\n \t  [(match_operand:<VPRED> 1 \"register_operand\" \"Upl, Upl, Upl\")\n+\t   (match_operand:SI 5 \"aarch64_sve_gp_strictness\")\n \t   (match_operand:SVE_F 2 \"register_operand\" \"%w, 0, w\")\n \t   (match_operand:SVE_F 3 \"register_operand\" \"w, w, w\")\n \t   (match_operand:SVE_F 4 \"register_operand\" \"0, w, w\")]\n@@ -2646,6 +2765,7 @@\n \t  [(match_operand:<VPRED> 1 \"register_operand\")\n \t   (unspec:SVE_F\n \t     [(match_dup 1)\n+\t      (const_int SVE_STRICT_GP)\n \t      (match_operand:SVE_F 2 \"register_operand\")\n \t      (match_operand:SVE_F 3 \"register_operand\")\n \t      (match_operand:SVE_F 4 \"register_operand\")]\n@@ -2662,43 +2782,53 @@\n \n ;; Predicated floating-point ternary operations, merging with the\n ;; first input.\n-(define_insn \"*cond_<optab><mode>_2\"\n+(define_insn_and_rewrite \"*cond_<optab><mode>_2\"\n   [(set (match_operand:SVE_F 0 \"register_operand\" \"=w, ?&w\")\n \t(unspec:SVE_F\n \t  [(match_operand:<VPRED> 1 \"register_operand\" \"Upl, Upl\")\n \t   (unspec:SVE_F\n-\t     [(match_dup 1)\n+\t     [(match_operand 5)\n+\t      (match_operand:SI 6 \"aarch64_sve_gp_strictness\")\n \t      (match_operand:SVE_F 2 \"register_operand\" \"0, w\")\n \t      (match_operand:SVE_F 3 \"register_operand\" \"w, w\")\n \t      (match_operand:SVE_F 4 \"register_operand\" \"w, w\")]\n \t     SVE_COND_FP_TERNARY)\n \t   (match_dup 2)]\n \t  UNSPEC_SEL))]\n-  \"TARGET_SVE\"\n+  \"TARGET_SVE && aarch64_sve_pred_dominates_p (&operands[5], operands[1])\"\n   \"@\n    <sve_fmad_op>\\t%0.<Vetype>, %1/m, %3.<Vetype>, %4.<Vetype>\n    movprfx\\t%0, %2\\;<sve_fmad_op>\\t%0.<Vetype>, %1/m, %3.<Vetype>, %4.<Vetype>\"\n+  \"&& !rtx_equal_p (operands[1], operands[5])\"\n+  {\n+    operands[5] = copy_rtx (operands[1]);\n+  }\n   [(set_attr \"movprfx\" \"*,yes\")]\n )\n \n ;; Predicated floating-point ternary operations, merging with the\n ;; third input.\n-(define_insn \"*cond_<optab><mode>_4\"\n+(define_insn_and_rewrite \"*cond_<optab><mode>_4\"\n   [(set (match_operand:SVE_F 0 \"register_operand\" \"=w, ?&w\")\n \t(unspec:SVE_F\n \t  [(match_operand:<VPRED> 1 \"register_operand\" \"Upl, Upl\")\n \t   (unspec:SVE_F\n-\t     [(match_dup 1)\n+\t     [(match_operand 5)\n+\t      (match_operand:SI 6 \"aarch64_sve_gp_strictness\")\n \t      (match_operand:SVE_F 2 \"register_operand\" \"w, w\")\n \t      (match_operand:SVE_F 3 \"register_operand\" \"w, w\")\n \t      (match_operand:SVE_F 4 \"register_operand\" \"0, w\")]\n \t     SVE_COND_FP_TERNARY)\n \t   (match_dup 4)]\n \t  UNSPEC_SEL))]\n-  \"TARGET_SVE\"\n+  \"TARGET_SVE && aarch64_sve_pred_dominates_p (&operands[5], operands[1])\"\n   \"@\n    <sve_fmla_op>\\t%0.<Vetype>, %1/m, %2.<Vetype>, %3.<Vetype>\n    movprfx\\t%0, %4\\;<sve_fmla_op>\\t%0.<Vetype>, %1/m, %2.<Vetype>, %3.<Vetype>\"\n+  \"&& !rtx_equal_p (operands[1], operands[5])\"\n+  {\n+    operands[5] = copy_rtx (operands[1]);\n+  }\n   [(set_attr \"movprfx\" \"*,yes\")]\n )\n \n@@ -2709,7 +2839,8 @@\n \t(unspec:SVE_F\n \t  [(match_operand:<VPRED> 1 \"register_operand\" \"Upl, Upl, Upl\")\n \t   (unspec:SVE_F\n-\t     [(match_dup 1)\n+\t     [(match_operand 6)\n+\t      (match_operand:SI 7 \"aarch64_sve_gp_strictness\")\n \t      (match_operand:SVE_F 2 \"register_operand\" \"w, w, w\")\n \t      (match_operand:SVE_F 3 \"register_operand\" \"w, w, w\")\n \t      (match_operand:SVE_F 4 \"register_operand\" \"w, w, w\")]\n@@ -2719,18 +2850,26 @@\n   \"TARGET_SVE\n    && !rtx_equal_p (operands[2], operands[5])\n    && !rtx_equal_p (operands[3], operands[5])\n-   && !rtx_equal_p (operands[4], operands[5])\"\n+   && !rtx_equal_p (operands[4], operands[5])\n+   && aarch64_sve_pred_dominates_p (&operands[6], operands[1])\"\n   \"@\n    movprfx\\t%0.<Vetype>, %1/z, %4.<Vetype>\\;<sve_fmla_op>\\t%0.<Vetype>, %1/m, %2.<Vetype>, %3.<Vetype>\n    movprfx\\t%0.<Vetype>, %1/m, %4.<Vetype>\\;<sve_fmla_op>\\t%0.<Vetype>, %1/m, %2.<Vetype>, %3.<Vetype>\n    #\"\n-  \"&& reload_completed\n-   && !CONSTANT_P (operands[5])\n-   && !rtx_equal_p (operands[0], operands[5])\"\n+  \"&& 1\"\n   {\n-    emit_insn (gen_vcond_mask_<mode><vpred> (operands[0], operands[4],\n-\t\t\t\t\t     operands[5], operands[1]));\n-    operands[5] = operands[4] = operands[0];\n+    if (reload_completed\n+        && register_operand (operands[5], <MODE>mode)\n+        && !rtx_equal_p (operands[0], operands[5]))\n+      {\n+\temit_insn (gen_vcond_mask_<mode><vpred> (operands[0], operands[4],\n+\t\t\t\t\t\t operands[5], operands[1]));\n+\toperands[5] = operands[4] = operands[0];\n+      }\n+    else if (!rtx_equal_p (operands[1], operands[6]))\n+      operands[6] = copy_rtx (operands[1]);\n+    else\n+      FAIL;\n   }\n   [(set_attr \"movprfx\" \"yes\")]\n )"}, {"sha": "6efcb03004a7d7ccde6ffae4cf6bdcf8b8e80aa5", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9c5a8090c58b84c1eb45e39e77eee223f992009/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9c5a8090c58b84c1eb45e39e77eee223f992009/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=c9c5a8090c58b84c1eb45e39e77eee223f992009", "patch": "@@ -2765,6 +2765,24 @@ aarch64_pfalse_reg (machine_mode mode)\n   return gen_lowpart (mode, reg);\n }\n \n+/* Return true if predicate PRED1[0] is true whenever predicate PRED2 is\n+   true, or alternatively if we know that the operation predicated by\n+   PRED1[0] is safe to perform whenever PRED2 is true.  PRED1[1] is a\n+   aarch64_sve_gp_strictness operand that describes the operation\n+   predicated by PRED1[0].  */\n+\n+bool\n+aarch64_sve_pred_dominates_p (rtx *pred1, rtx pred2)\n+{\n+  machine_mode mode = GET_MODE (pred2);\n+  gcc_assert (GET_MODE_CLASS (mode) == MODE_VECTOR_BOOL\n+\t      && mode == GET_MODE (pred1[0])\n+\t      && aarch64_sve_gp_strictness (pred1[1], SImode));\n+  return (pred1[0] == CONSTM1_RTX (mode)\n+\t  || INTVAL (pred1[1]) == SVE_RELAXED_GP\n+\t  || rtx_equal_p (pred1[0], pred2));\n+}\n+\n /* Use a comparison to convert integer vector SRC into MODE, which is\n    the corresponding SVE predicate mode.  Use TARGET for the result\n    if it's nonnull and convenient.  */"}, {"sha": "f910166bfba6f56e26a6fd55b69beba7b1ce7662", "filename": "gcc/config/aarch64/aarch64.md", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9c5a8090c58b84c1eb45e39e77eee223f992009/gcc%2Fconfig%2Faarch64%2Faarch64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9c5a8090c58b84c1eb45e39e77eee223f992009/gcc%2Fconfig%2Faarch64%2Faarch64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.md?ref=c9c5a8090c58b84c1eb45e39e77eee223f992009", "patch": "@@ -268,6 +268,18 @@\n    ; Indicates that the predicate is known to be a PTRUE.\n    (SVE_KNOWN_PTRUE 1)])\n \n+;; These constants are used as a const_int in predicated SVE FP arithmetic\n+;; to indicate whether the operation is allowed to make additional lanes\n+;; active without worrying about the effect on faulting behavior.\n+(define_constants\n+  [; Indicates either that all lanes are active or that the instruction may\n+   ; operate on inactive inputs even if doing so could induce a fault.\n+   (SVE_RELAXED_GP 0)\n+\n+   ; Indicates that some lanes might be inactive and that the instruction\n+   ; must not operate on inactive inputs if doing so could induce a fault.\n+   (SVE_STRICT_GP 1)])\n+\n ;; If further include files are added the defintion of MD_INCLUDES\n ;; must be updated.\n "}, {"sha": "bfbe97db952af899dd1741d5c45a904729c3d206", "filename": "gcc/config/aarch64/predicates.md", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9c5a8090c58b84c1eb45e39e77eee223f992009/gcc%2Fconfig%2Faarch64%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9c5a8090c58b84c1eb45e39e77eee223f992009/gcc%2Fconfig%2Faarch64%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Fpredicates.md?ref=c9c5a8090c58b84c1eb45e39e77eee223f992009", "patch": "@@ -689,6 +689,11 @@\n        (ior (match_test \"INTVAL (op) == SVE_MAYBE_NOT_PTRUE\")\n \t    (match_test \"INTVAL (op) == SVE_KNOWN_PTRUE\"))))\n \n+(define_predicate \"aarch64_sve_gp_strictness\"\n+  (and (match_code \"const_int\")\n+       (ior (match_test \"INTVAL (op) == SVE_RELAXED_GP\")\n+\t    (match_test \"INTVAL (op) == SVE_STRICT_GP\"))))\n+\n (define_predicate \"aarch64_gather_scale_operand_w\"\n   (and (match_code \"const_int\")\n        (match_test \"INTVAL (op) == 1 || INTVAL (op) == 4\")))"}]}