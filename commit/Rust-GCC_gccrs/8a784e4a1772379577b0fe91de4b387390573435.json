{"sha": "8a784e4a1772379577b0fe91de4b387390573435", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGE3ODRlNGExNzcyMzc5NTc3YjBmZTkxZGU0YjM4NzM5MDU3MzQzNQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2004-12-16T11:04:09Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2004-12-16T11:04:09Z"}, "message": "re PR c++/18905 (Strange error: subscripted value is neither array nor pointer)\n\ncp:\n\tPR c++/18905\n\t* cp-tree.h (integral_constant_value): Declare.\n\t* call.c (null_ptr_cst_p): Use integral_constant_value, not\n\tdecl_constant_value.\n\t(convert_like_real): Likewise.\n\t* class.c (check_bitfield_decl): Likewise.\n\t* cvt.c (ocp_convert): Likewise.\n\t(convert): Remove unnecessary decl_constant_value call.\n\t* decl.c (compute_array_index_type): Use integral_constant_value,\n\tnot decl_constant_value.\n\t(build_enumerator): Likewise.\n\t* decl2.c (grokfield): Likewise.\n\t* init.c (decl_constant_value): Simplify.\n\t(integral_constant_value): New.\n\t* pt.c (fold_decl_constant_value): Use integral_constant_value,\n\tremove subsequent check.\n\t(tsubst): Use integral_constant_value, not decl_constant_value.\n\t(tsubst_copy, unify): Likewise.\n\t* typeck.c (decay_conversion): Likewise.\n\t(build_compound_expr): Remove unnecessary decl_constant_value\n\tcalls.\n\t(build_static_cast_1, build_reinterpret_cast_1):\n\t(convert_for_assignment): Remove comment about not calling\n\tdecl_constant_value.\ntestsuite:\n\tPR c++/18905\n\t* g++.dg/template/init4.C: New.\n\t* g++.dg/opt/static3.C: Enable optimizer.\n\nFrom-SVN: r92257", "tree": {"sha": "a82d5b1b25a2b0a52f0c9e6f96bfb4fbbb2d9e1c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a82d5b1b25a2b0a52f0c9e6f96bfb4fbbb2d9e1c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8a784e4a1772379577b0fe91de4b387390573435", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a784e4a1772379577b0fe91de4b387390573435", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a784e4a1772379577b0fe91de4b387390573435", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a784e4a1772379577b0fe91de4b387390573435/comments", "author": null, "committer": null, "parents": [{"sha": "0c0cce420e1ced4cfd4e6daddb91e3f6b548bf29", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c0cce420e1ced4cfd4e6daddb91e3f6b548bf29", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c0cce420e1ced4cfd4e6daddb91e3f6b548bf29"}], "stats": {"total": 222, "additions": 112, "deletions": 110}, "files": [{"sha": "96bb671d1075a5b5ed318656e3f535b3c476348d", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a784e4a1772379577b0fe91de4b387390573435/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a784e4a1772379577b0fe91de4b387390573435/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=8a784e4a1772379577b0fe91de4b387390573435", "patch": "@@ -1,3 +1,30 @@\n+2004-12-16  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\tPR c++/18905\n+\t* cp-tree.h (integral_constant_value): Declare.\n+\t* call.c (null_ptr_cst_p): Use integral_constant_value, not\n+\tdecl_constant_value.\n+\t(convert_like_real): Likewise.\n+\t* class.c (check_bitfield_decl): Likewise.\n+\t* cvt.c (ocp_convert): Likewise.\n+\t(convert): Remove unnecessary decl_constant_value call.\n+\t* decl.c (compute_array_index_type): Use integral_constant_value,\n+\tnot decl_constant_value.\n+\t(build_enumerator): Likewise.\n+\t* decl2.c (grokfield): Likewise.\n+\t* init.c (decl_constant_value): Simplify.\n+\t(integral_constant_value): New.\n+\t* pt.c (fold_decl_constant_value): Use integral_constant_value,\n+\tremove subsequent check.\n+\t(tsubst): Use integral_constant_value, not decl_constant_value.\n+\t(tsubst_copy, unify): Likewise.\n+\t* typeck.c (decay_conversion): Likewise.\n+\t(build_compound_expr): Remove unnecessary decl_constant_value\n+\tcalls.\n+\t(build_static_cast_1, build_reinterpret_cast_1):\n+\t(convert_for_assignment): Remove comment about not calling\n+\tdecl_constant_value.\n+\n 2004-12-15  Kriang Lerdsuwanakij  <lerdsuwa@users.sourceforge.net>\n \n \tPR c++/18825"}, {"sha": "af6f7d8225803e56df8006cdd57c6e962a33c344", "filename": "gcc/cp/call.c", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a784e4a1772379577b0fe91de4b387390573435/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a784e4a1772379577b0fe91de4b387390573435/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=8a784e4a1772379577b0fe91de4b387390573435", "patch": "@@ -428,8 +428,7 @@ null_ptr_cst_p (tree t)\n \n      A null pointer constant is an integral constant expression\n      (_expr.const_) rvalue of integer type that evaluates to zero.  */\n-  if (DECL_INTEGRAL_CONSTANT_VAR_P (t))\n-    t = decl_constant_value (t);\n+  t = integral_constant_value (t);\n   if (t == null_node\n       || (CP_INTEGRAL_TYPE_P (TREE_TYPE (t)) && integer_zerop (t)))\n     return true;\n@@ -4227,12 +4226,11 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n     case ck_identity:\n       if (type_unknown_p (expr))\n \texpr = instantiate_type (totype, expr, tf_error | tf_warning);\n-      /* Convert a non-array constant variable to its underlying value, unless we\n-\t are about to bind it to a reference, in which case we need to\n+      /* Convert a constant to its underlying value, unless we are\n+\t about to bind it to a reference, in which case we need to\n \t leave it as an lvalue.  */\n-      if (inner >= 0\n-\t  && TREE_CODE (TREE_TYPE (expr)) != ARRAY_TYPE)\n-\texpr = decl_constant_value (expr);\n+      if (inner >= 0)\n+\texpr = integral_constant_value (expr);\n       if (convs->check_copy_constructor_p)\n \tcheck_constructor_callable (totype, expr);\n       return expr;"}, {"sha": "9c0a2718f5f618d4699765847f1722c391465cd0", "filename": "gcc/cp/class.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a784e4a1772379577b0fe91de4b387390573435/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a784e4a1772379577b0fe91de4b387390573435/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=8a784e4a1772379577b0fe91de4b387390573435", "patch": "@@ -2613,10 +2613,7 @@ check_bitfield_decl (tree field)\n       STRIP_NOPS (w);\n \n       /* detect invalid field size.  */\n-      if (TREE_CODE (w) == CONST_DECL)\n-\tw = DECL_INITIAL (w);\n-      else\n-\tw = decl_constant_value (w);\n+      w = integral_constant_value (w);\n \n       if (TREE_CODE (w) != INTEGER_CST)\n \t{"}, {"sha": "de3e1a6c8dc9d95d793b6b00479c3388cc424283", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a784e4a1772379577b0fe91de4b387390573435/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a784e4a1772379577b0fe91de4b387390573435/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=8a784e4a1772379577b0fe91de4b387390573435", "patch": "@@ -3917,6 +3917,7 @@ extern tree build_vec_delete\t\t\t(tree, tree, special_function_kind, int);\n extern tree create_temporary_var                (tree);\n extern void initialize_vtbl_ptrs                (tree);\n extern tree build_java_class_ref                (tree);\n+extern tree integral_constant_value \t\t(tree);\n \n /* in lex.c */\n extern void cxx_dup_lang_specific_decl\t\t(tree);"}, {"sha": "2d73ab8569832154e8ce2f93de47af86152053de", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a784e4a1772379577b0fe91de4b387390573435/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a784e4a1772379577b0fe91de4b387390573435/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=8a784e4a1772379577b0fe91de4b387390573435", "patch": "@@ -621,7 +621,7 @@ ocp_convert (tree type, tree expr, int convtype, int flags)\n   complete_type (type);\n   complete_type (TREE_TYPE (expr));\n \n-  e = decl_constant_value (e);\n+  e = integral_constant_value (e);\n \n   if (IS_AGGR_TYPE (type) && (convtype & CONV_FORCE_TEMP)\n       /* Some internal structures (vtable_entry_type, sigtbl_ptr_type)\n@@ -945,10 +945,7 @@ convert (tree type, tree expr)\n   intype = TREE_TYPE (expr);\n \n   if (POINTER_TYPE_P (type) && POINTER_TYPE_P (intype))\n-    {\n-      expr = decl_constant_value (expr);\n-      return fold_if_not_in_template (build_nop (type, expr));\n-    }\n+    return fold_if_not_in_template (build_nop (type, expr));\n \n   return ocp_convert (type, expr, CONV_OLD_CONVERT,\n \t\t      LOOKUP_NORMAL|LOOKUP_NO_CONVERSION);"}, {"sha": "01a3312bfb8b96e293782831bb9371cc3f316691", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a784e4a1772379577b0fe91de4b387390573435/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a784e4a1772379577b0fe91de4b387390573435/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=8a784e4a1772379577b0fe91de4b387390573435", "patch": "@@ -4853,6 +4853,7 @@ cp_finish_decl (tree decl, tree init, tree asmspec_tree, int flags)\n \t  && !DECL_PRETTY_FUNCTION_P (decl)\n \t  && !dependent_type_p (TREE_TYPE (decl)))\n \tmaybe_deduce_size_from_array_init (decl, init);\n+      \n       goto finish_end;\n     }\n \n@@ -6207,7 +6208,7 @@ compute_array_index_type (tree name, tree size)\n   STRIP_TYPE_NOPS (size);\n \n   /* It might be a const variable or enumeration constant.  */\n-  size = decl_constant_value (size);\n+  size = integral_constant_value (size);\n \n   /* Normally, the array-bound will be a constant.  */\n   if (TREE_CODE (size) == INTEGER_CST)\n@@ -9792,7 +9793,7 @@ build_enumerator (tree name, tree value, tree enumtype)\n       /* Validate and default VALUE.  */\n       if (value != NULL_TREE)\n \t{\n-\t  value = decl_constant_value (value);\n+\t  value = integral_constant_value (value);\n \n \t  if (TREE_CODE (value) == INTEGER_CST)\n \t    {"}, {"sha": "231939d638de0a22ba0cc3663d02fb756fc8200d", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a784e4a1772379577b0fe91de4b387390573435/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a784e4a1772379577b0fe91de4b387390573435/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=8a784e4a1772379577b0fe91de4b387390573435", "patch": "@@ -917,12 +917,11 @@ grokfield (const cp_declarator *declarator,\n \n \t  if (!processing_template_decl)\n \t    {\n-\t      if (TREE_CODE (init) == CONST_DECL)\n-\t\tinit = DECL_INITIAL (init);\n-\t      else if (TREE_READONLY_DECL_P (init))\n-\t\tinit = decl_constant_value (init);\n-\t      else if (TREE_CODE (init) == CONSTRUCTOR)\n+\t      if (TREE_CODE (init) == CONSTRUCTOR)\n \t\tinit = digest_init (TREE_TYPE (value), init, (tree *)0);\n+\t      else\n+\t\tinit = integral_constant_value (init);\n+\t      \n \t      if (init != error_mark_node && ! TREE_CONSTANT (init))\n \t\t{\n \t\t  /* We can allow references to things that are effectively"}, {"sha": "90b84eb6a45c2b5dc51a32422f0ac919bc28290a", "filename": "gcc/cp/init.c", "status": "modified", "additions": 33, "deletions": 31, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a784e4a1772379577b0fe91de4b387390573435/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a784e4a1772379577b0fe91de4b387390573435/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=8a784e4a1772379577b0fe91de4b387390573435", "patch": "@@ -1558,46 +1558,48 @@ build_offset_ref (tree type, tree name, bool address_p)\n   return member;\n }\n \n-/* If DECL is a `const' declaration, and its value is a known\n-   constant, then return that value.  */\n+/* If DECL is a CONST_DECL, or a constant VAR_DECL initialized by\n+   constant of integral or enumeration type, then return that value.\n+   These are those variables permitted in constant expressions by\n+   [5.19/1].  FIXME:If we did lazy folding, this could be localized.  */\n \n tree\n-decl_constant_value (tree decl)\n+integral_constant_value (tree decl)\n {\n-  /* When we build a COND_EXPR, we don't know whether it will be used\n-     as an lvalue or as an rvalue.  If it is an lvalue, it's not safe\n-     to replace the second and third operands with their\n-     initializers.  So, we do that here.  */\n-  if (TREE_CODE (decl) == COND_EXPR)\n-    {\n-      tree d1;\n-      tree d2;\n-\n-      d1 = decl_constant_value (TREE_OPERAND (decl, 1));\n-      d2 = decl_constant_value (TREE_OPERAND (decl, 2));\n+  if ((TREE_CODE (decl) == CONST_DECL\n+      || (TREE_CODE (decl) == VAR_DECL\n+\t  /* And so are variables with a 'const' type -- unless they\n+\t     are also 'volatile'.  */\n+\t  && CP_TYPE_CONST_NON_VOLATILE_P (TREE_TYPE (decl))\n+\t  && DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P (decl)))\n+      && DECL_INITIAL (decl)\n+      && DECL_INITIAL (decl) != error_mark_node\n+      && TREE_TYPE (DECL_INITIAL (decl))\n+      && INTEGRAL_OR_ENUMERATION_TYPE_P (TREE_TYPE (decl)))\n+    return DECL_INITIAL (decl);\n+  return decl;\n+}\n \n-      if (d1 != TREE_OPERAND (decl, 1) || d2 != TREE_OPERAND (decl, 2))\n-\treturn build3 (COND_EXPR,\n-\t\t       TREE_TYPE (decl),\n-\t\t       TREE_OPERAND (decl, 0), d1, d2);\n-    }\n+/* A more relaxed version of integral_constant_value, for which type\n+   is not considered.  This is used by the common C/C++ code, and not\n+   directly by the C++ front end.  */\n \n-  if (DECL_P (decl)\n-      && (/* Enumeration constants are constant.  */\n-\t  TREE_CODE (decl) == CONST_DECL\n+tree\n+decl_constant_value (tree decl)\n+{\n+  if ((TREE_CODE (decl) == CONST_DECL\n+      || (TREE_CODE (decl) == VAR_DECL\n \t  /* And so are variables with a 'const' type -- unless they\n-\t     are also 'volatile'.  */\n-\t  || CP_TYPE_CONST_NON_VOLATILE_P (TREE_TYPE (decl)))\n-      && TREE_CODE (decl) != PARM_DECL\n+             are also 'volatile'.  */\n+\t  && CP_TYPE_CONST_NON_VOLATILE_P (TREE_TYPE (decl))))\n       && DECL_INITIAL (decl)\n       && DECL_INITIAL (decl) != error_mark_node\n-      /* This is invalid if initial value is not constant.\n-\t If it has either a function call, a memory reference,\n-\t or a variable, then re-evaluating it could give different results.  */\n-      && TREE_CONSTANT (DECL_INITIAL (decl))\n-      /* Check for cases where this is sub-optimal, even though valid.  */\n-      && TREE_CODE (DECL_INITIAL (decl)) != CONSTRUCTOR)\n+      /* This is invalid if initial value is not constant.  If it has\n+       \t either a function call, a memory reference, or a variable,\n+       \t then re-evaluating it could give different results.  */\n+      && TREE_CONSTANT (DECL_INITIAL (decl)))\n     return DECL_INITIAL (decl);\n+  \n   return decl;\n }\n \f"}, {"sha": "a73f6916f02fd6a694ba3f461d18d9b4ab4568c0", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 9, "deletions": 23, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a784e4a1772379577b0fe91de4b387390573435/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a784e4a1772379577b0fe91de4b387390573435/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=8a784e4a1772379577b0fe91de4b387390573435", "patch": "@@ -3310,37 +3310,23 @@ fold_non_dependent_expr (tree expr)\n    For instance, it could be a VAR_DECL with a constant initializer.\n    Extract the innest constant expression.\n    \n-   This is basically a more powerful version of decl_constant_value, which\n-   can be used also in templates where initializers can maintain a\n-   syntactic rather than semantic form (even if they are non-dependent, for\n-   access-checking purposes).  */\n+   This is basically a more powerful version of\n+   integral_constant_value, which can be used also in templates where\n+   initializers can maintain a syntactic rather than semantic form\n+   (even if they are non-dependent, for access-checking purposes).  */\n \n tree\n fold_decl_constant_value (tree expr)\n {\n   while (true)\n     {\n-      tree const_expr = decl_constant_value (expr);\n-      /* In a template, the initializer for a VAR_DECL may not be\n-\t marked as TREE_CONSTANT, in which case decl_constant_value\n-\t will not return the initializer.  Handle that special case\n-\t here.  */\n-      if (expr == const_expr\n-\t  && TREE_CODE (expr) == VAR_DECL\n-\t  && DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P (expr)\n-\t  && CP_TYPE_CONST_NON_VOLATILE_P (TREE_TYPE (expr))\n-\t  /* DECL_INITIAL can be NULL if we are processing a\n-\t     variable initialized to an expression involving itself.\n-\t     We know it is initialized to a constant -- but not what\n-\t     constant, yet.  */\n-\t  && DECL_INITIAL (expr))\n-\tconst_expr = DECL_INITIAL (expr);\n+      tree const_expr = integral_constant_value (expr);\n       if (expr == const_expr)\n \tbreak;\n       expr = fold_non_dependent_expr (const_expr);\n     }\n \n-    return expr;\n+  return expr;\n }\n \n /* Subroutine of convert_nontype_argument. Converts EXPR to TYPE, which\n@@ -6985,7 +6971,7 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t   in that we want to fold it as much as possible.  */\n \tmax = tsubst_template_arg (omax, args, complain, in_decl);\n \tif (!processing_template_decl)\n-\t  max = decl_constant_value (max);\n+\t  max = integral_constant_value (max);\n \n \tif (integer_zerop (omax))\n \t  {\n@@ -7688,7 +7674,7 @@ tsubst_copy (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t  return t;\n \t/* If ARGS is NULL, then T is known to be non-dependent.  */\n \tif (args == NULL_TREE)\n-\t  return decl_constant_value (t);\n+\t  return integral_constant_value (t);\n \n \t/* Unfortunately, we cannot just call lookup_name here.\n \t   Consider:\n@@ -10316,7 +10302,7 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict)\n     case CONST_DECL:\n       if (DECL_TEMPLATE_PARM_P (parm))\n \treturn unify (tparms, targs, DECL_INITIAL (parm), arg, strict);\n-      if (arg != decl_constant_value (parm)) \n+      if (arg != integral_constant_value (parm)) \n \treturn 1;\n       return 0;\n "}, {"sha": "778e3311b90f14d3db910a27ddea8c6618c0e615", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 4, "deletions": 32, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a784e4a1772379577b0fe91de4b387390573435/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a784e4a1772379577b0fe91de4b387390573435/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=8a784e4a1772379577b0fe91de4b387390573435", "patch": "@@ -1351,20 +1351,9 @@ decay_conversion (tree exp)\n       cxx_incomplete_type_error (exp, TREE_TYPE (exp));\n       return error_mark_node;\n     }\n-  \n-  /* Constants can be used directly unless they're not loadable.  */\n-  if (TREE_CODE (exp) == CONST_DECL)\n-    exp = DECL_INITIAL (exp);\n-  /* Replace a nonvolatile const static variable with its value.  We\n-     don't do this for arrays, though; we want the address of the\n-     first element of the array, not the address of the first element\n-     of its initializing constant.  */\n-  else if (code != ARRAY_TYPE)\n-    {\n-      exp = decl_constant_value (exp);\n-      type = TREE_TYPE (exp);\n-    }\n \n+  exp = integral_constant_value (exp);\n+  \n   /* build_c_cast puts on a NOP_EXPR to make the result not an lvalue.\n      Leave such NOP_EXPRs, since RHS is being used in non-lvalue context.  */\n \n@@ -4450,7 +4439,6 @@ build_x_compound_expr (tree op1, tree op2)\n tree\n build_compound_expr (tree lhs, tree rhs)\n {\n-  lhs = decl_constant_value (lhs);\n   lhs = convert_to_void (lhs, \"left-hand operand of comma\");\n   \n   if (lhs == error_mark_node || rhs == error_mark_node)\n@@ -4666,7 +4654,6 @@ build_static_cast_1 (tree type, tree expr, bool c_cast_p,\n       || (INTEGRAL_OR_ENUMERATION_TYPE_P (type)\n \t  && INTEGRAL_OR_ENUMERATION_TYPE_P (intype)))\n     {\n-      expr = decl_constant_value (expr);\n       expr = ocp_convert (type, expr, CONV_C_CAST, LOOKUP_NORMAL);\n \n       /* Ignore any integer overflow caused by the cast.  */\n@@ -4918,10 +4905,7 @@ build_reinterpret_cast_1 (tree type, tree expr, bool c_cast_p,\n     ;\n   else if ((TYPE_PTRFN_P (type) && TYPE_PTRFN_P (intype))\n \t   || (TYPE_PTRMEMFUNC_P (type) && TYPE_PTRMEMFUNC_P (intype)))\n-    {\n-      expr = decl_constant_value (expr);\n-      return fold_if_not_in_template (build_nop (type, expr));\n-    }\n+    return fold_if_not_in_template (build_nop (type, expr));\n   else if ((TYPE_PTRMEM_P (type) && TYPE_PTRMEM_P (intype))\n \t   || (TYPE_PTROBV_P (type) && TYPE_PTROBV_P (intype)))\n     {\n@@ -4938,7 +4922,7 @@ build_reinterpret_cast_1 (tree type, tree expr, bool c_cast_p,\n \twarning (\"cast from %qT to %qT increases required alignment of \"\n \t\t \"target type\",\n \t\t intype, type);\n-      expr = decl_constant_value (expr);\n+      \n       return fold_if_not_in_template (build_nop (type, expr));\n     }\n   else if ((TYPE_PTRFN_P (type) && TYPE_PTROBV_P (intype))\n@@ -4950,8 +4934,6 @@ build_reinterpret_cast_1 (tree type, tree expr, bool c_cast_p,\n  \t   addresses this issue, but as of 2004/10/26 is still in\n  \t   drafting.  */\n  \twarning (\"ISO C++ forbids casting between pointer-to-function and pointer-to-object\");\n-      \n-      expr = decl_constant_value (expr);\n       return fold_if_not_in_template (build_nop (type, expr));\n     }\n   else if (TREE_CODE (type) == VECTOR_TYPE)\n@@ -5926,16 +5908,6 @@ convert_for_assignment (tree type, tree rhs,\n   if (TREE_CODE (rhs) == CONST_DECL)\n     rhs = DECL_INITIAL (rhs);\n   \n-  /* We do not use decl_constant_value here because of this case:\n-\n-       const char* const s = \"s\";\n- \n-     The conversion rules for a string literal are more lax than for a\n-     variable; in particular, a string literal can be converted to a\n-     \"char *\" but the variable \"s\" cannot be converted in the same\n-     way.  If the conversion is allowed, the optimization should be\n-     performed while creating the converted expression.  */\n-\n   /* [expr.ass]\n \n      The expression is implicitly converted (clause _conv_) to the"}, {"sha": "c9c86f2f7b5c24fe54cea536f23018594b632fec", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a784e4a1772379577b0fe91de4b387390573435/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a784e4a1772379577b0fe91de4b387390573435/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8a784e4a1772379577b0fe91de4b387390573435", "patch": "@@ -1,3 +1,9 @@\n+2004-12-16  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\tPR c++/18905\n+\t* g++.dg/template/init4.C: New.\n+\t* g++.dg/opt/static3.C: Enable optimizer.\n+\n 2004-12-16  Wolfgang Bangerth  <bangerth@dealii.com>\n \n \t* g++.dg/other/complex1.C: New test.\n@@ -45,7 +51,7 @@\n \n 2004-12-15  Nathan Sidwell  <nathan@codesourcery.com>\n \n-\tPR 18981\n+\tPR c++/18981\n \t* g++.dg/template/typename9.C: New test.\n \n 2004-12-14  Mark Mitchell  <mark@codesourcery.com>"}, {"sha": "4f8f7a9ba682f401930f11f46404fb19d8ecb6ba", "filename": "gcc/testsuite/g++.dg/opt/static3.C", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a784e4a1772379577b0fe91de4b387390573435/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fstatic3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a784e4a1772379577b0fe91de4b387390573435/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fstatic3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fstatic3.C?ref=8a784e4a1772379577b0fe91de4b387390573435", "patch": "@@ -1,4 +1,5 @@\n // { dg-do link }\n+// { dg-options \"-O2\" }\n \n class Foo {\n public:"}, {"sha": "78c7c3088593d6ad0058c5f013f91577af85dde8", "filename": "gcc/testsuite/g++.dg/template/init4.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a784e4a1772379577b0fe91de4b387390573435/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Finit4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a784e4a1772379577b0fe91de4b387390573435/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Finit4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Finit4.C?ref=8a784e4a1772379577b0fe91de4b387390573435", "patch": "@@ -0,0 +1,15 @@\n+// { dg-do compile }\n+\n+// Copyright (C) 2004 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 15 Dec 2004 <nathan@codesourcery.com>\n+\n+// PR 18905. bogus error\n+// Origin:  Andrew Pinski  <pinskia@gcc.gnu.org>\n+\n+int f1(char);\n+template <int t>\n+void f(void)\n+{\n+ const char* const suffixes = \"plpv\";\n+ f1(suffixes[t]);\n+}"}]}