{"sha": "682ba3a67b9c3d36ac4603fc3ad1dd10ea024974", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjgyYmEzYTY3YjljM2QzNmFjNDYwM2ZjM2FkMWRkMTBlYTAyNDk3NA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-03-26T00:53:32Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-03-26T00:53:32Z"}, "message": "(expand_expr, case ADDR_EXPR): Return const0_rtx if taking address of\nan ERROR_MARK; also do some minor cleanup.\n\nFrom-SVN: r6908", "tree": {"sha": "06a190130eee4344757e198cc42d63ffd08de659", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/06a190130eee4344757e198cc42d63ffd08de659"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/682ba3a67b9c3d36ac4603fc3ad1dd10ea024974", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/682ba3a67b9c3d36ac4603fc3ad1dd10ea024974", "html_url": "https://github.com/Rust-GCC/gccrs/commit/682ba3a67b9c3d36ac4603fc3ad1dd10ea024974", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/682ba3a67b9c3d36ac4603fc3ad1dd10ea024974/comments", "author": null, "committer": null, "parents": [{"sha": "2b9791d49ffd6d5ac6de0cb63e462c8f8a60b4d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b9791d49ffd6d5ac6de0cb63e462c8f8a60b4d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b9791d49ffd6d5ac6de0cb63e462c8f8a60b4d9"}], "stats": {"total": 13, "additions": 7, "deletions": 6}, "files": [{"sha": "a825d264cace7db46da10d8399999fed7f35ce4d", "filename": "gcc/expr.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/682ba3a67b9c3d36ac4603fc3ad1dd10ea024974/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/682ba3a67b9c3d36ac4603fc3ad1dd10ea024974/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=682ba3a67b9c3d36ac4603fc3ad1dd10ea024974", "patch": "@@ -5790,6 +5790,10 @@ expand_expr (exp, target, tmode, modifier)\n \t  op0 = trampoline_address (TREE_OPERAND (exp, 0));\n \t  op0 = force_operand (op0, target);\n \t}\n+      /* If we are taking the address of something erroneous, just\n+\t return a zero.  */\n+      else if (TREE_CODE (TREE_OPERAND (exp, 0)) == ERROR_MARK)\n+\treturn const0_rtx;\n       else\n \t{\n \t  /* We make sure to pass const0_rtx down if we came in with\n@@ -5801,7 +5805,7 @@ expand_expr (exp, target, tmode, modifier)\n \n \t  /* We would like the object in memory.  If it is a constant,\n \t     we can have it be statically allocated into memory.  For\n-\t     a non-constant (REG or SUBREG), we need to allocate some\n+\t     a non-constant (REG, SUBREG or CONCAT), we need to allocate some\n \t     memory and store the value into it.  */\n \n \t  if (CONSTANT_P (op0))\n@@ -5810,11 +5814,8 @@ expand_expr (exp, target, tmode, modifier)\n \t  else if (GET_CODE (op0) == MEM)\n \t    temp = XEXP (op0, 0);\n \n-\t  /* These cases happen in Fortran.  Is that legitimate?\n-\t     Should Fortran work in another way?\n-\t     Do they happen in C?  */\n-\t  if (GET_CODE (op0) == REG || GET_CODE (op0) == SUBREG\n-\t      || GET_CODE (op0) == CONCAT)\n+\t  else if (GET_CODE (op0) == REG || GET_CODE (op0) == SUBREG\n+\t\t   || GET_CODE (op0) == CONCAT)\n \t    {\n \t      /* If this object is in a register, it must be not\n \t\t be BLKmode. */"}]}