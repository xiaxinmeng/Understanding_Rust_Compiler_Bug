{"sha": "e7c45b6600acfdc0930b980a45a364f77844139a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTdjNDViNjYwMGFjZmRjMDkzMGI5ODBhNDVhMzY0Zjc3ODQ0MTM5YQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-09-14T16:18:55Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-09-14T16:18:55Z"}, "message": "Add gimple_build_vector* helpers\n\nThis patch adds gimple-fold.h equivalents of build_vector and\nbuild_vector_from_val.  Like the other gimple-fold.h routines\nthey always return a valid gimple value and add any new\nstatements to a given gimple_seq.  In combination with later\npatches this reduces the number of force_gimple_operands.\n\n2017-09-14  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* gimple-fold.h (gimple_build_vector_from_val): Declare, and provide\n\tan inline wrapper that provides a location.\n\t(gimple_build_vector): Likewise.\n\t* gimple-fold.c (gimple_build_vector_from_val): New function.\n\t(gimple_build_vector): Likewise.\n\t* tree-vect-loop.c (get_initial_def_for_reduction): Use the new\n\tfunctions to build the initial value.  Always return a gimple value.\n\t(get_initial_defs_for_reduction): Likewise.  Only compute\n\tneutral_vec once.\n\t(vect_create_epilog_for_reduction): Don't call force_gimple_operand or\n\tvect_init_vector on the results from get_initial_def(s)_for_reduction.\n\t(vectorizable_induction): Use gimple_build_vector rather than\n\tvect_init_vector.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r252762", "tree": {"sha": "f07cb487b4874c0bff14e1e55b322fe455c59610", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f07cb487b4874c0bff14e1e55b322fe455c59610"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e7c45b6600acfdc0930b980a45a364f77844139a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7c45b6600acfdc0930b980a45a364f77844139a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e7c45b6600acfdc0930b980a45a364f77844139a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7c45b6600acfdc0930b980a45a364f77844139a/comments", "author": null, "committer": null, "parents": [{"sha": "908a1a166dccefa24ae8b3606f4ce1da944eecb0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/908a1a166dccefa24ae8b3606f4ce1da944eecb0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/908a1a166dccefa24ae8b3606f4ce1da944eecb0"}], "stats": {"total": 241, "additions": 129, "deletions": 112}, "files": [{"sha": "d582e2c2029be2b769566c5b2e67329bd0537529", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7c45b6600acfdc0930b980a45a364f77844139a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7c45b6600acfdc0930b980a45a364f77844139a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e7c45b6600acfdc0930b980a45a364f77844139a", "patch": "@@ -1,3 +1,21 @@\n+2017-09-14  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* gimple-fold.h (gimple_build_vector_from_val): Declare, and provide\n+\tan inline wrapper that provides a location.\n+\t(gimple_build_vector): Likewise.\n+\t* gimple-fold.c (gimple_build_vector_from_val): New function.\n+\t(gimple_build_vector): Likewise.\n+\t* tree-vect-loop.c (get_initial_def_for_reduction): Use the new\n+\tfunctions to build the initial value.  Always return a gimple value.\n+\t(get_initial_defs_for_reduction): Likewise.  Only compute\n+\tneutral_vec once.\n+\t(vect_create_epilog_for_reduction): Don't call force_gimple_operand or\n+\tvect_init_vector on the results from get_initial_def(s)_for_reduction.\n+\t(vectorizable_induction): Use gimple_build_vector rather than\n+\tvect_init_vector.\n+\n 2017-09-14  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "b9e08897f6d81916ce2fb8c4408efbeefb34c337", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7c45b6600acfdc0930b980a45a364f77844139a/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7c45b6600acfdc0930b980a45a364f77844139a/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=e7c45b6600acfdc0930b980a45a364f77844139a", "patch": "@@ -7058,6 +7058,58 @@ gimple_convert_to_ptrofftype (gimple_seq *seq, location_t loc, tree op)\n   return gimple_convert (seq, loc, sizetype, op);\n }\n \n+/* Build a vector of type TYPE in which each element has the value OP.\n+   Return a gimple value for the result, appending any new statements\n+   to SEQ.  */\n+\n+tree\n+gimple_build_vector_from_val (gimple_seq *seq, location_t loc, tree type,\n+\t\t\t      tree op)\n+{\n+  tree res, vec = build_vector_from_val (type, op);\n+  if (is_gimple_val (vec))\n+    return vec;\n+  if (gimple_in_ssa_p (cfun))\n+    res = make_ssa_name (type);\n+  else\n+    res = create_tmp_reg (type);\n+  gimple *stmt = gimple_build_assign (res, vec);\n+  gimple_set_location (stmt, loc);\n+  gimple_seq_add_stmt_without_update (seq, stmt);\n+  return res;\n+}\n+\n+/* Build a vector of type TYPE in which the elements have the values\n+   given by ELTS.  Return a gimple value for the result, appending any\n+   new instructions to SEQ.  */\n+\n+tree\n+gimple_build_vector (gimple_seq *seq, location_t loc, tree type,\n+\t\t     vec<tree> elts)\n+{\n+  unsigned int nelts = elts.length ();\n+  gcc_assert (nelts == TYPE_VECTOR_SUBPARTS (type));\n+  for (unsigned int i = 0; i < nelts; ++i)\n+    if (!TREE_CONSTANT (elts[i]))\n+      {\n+\tvec<constructor_elt, va_gc> *v;\n+\tvec_alloc (v, nelts);\n+\tfor (i = 0; i < nelts; ++i)\n+\t  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, elts[i]);\n+\n+\ttree res;\n+\tif (gimple_in_ssa_p (cfun))\n+\t  res = make_ssa_name (type);\n+\telse\n+\t  res = create_tmp_reg (type);\n+\tgimple *stmt = gimple_build_assign (res, build_constructor (type, v));\n+\tgimple_set_location (stmt, loc);\n+\tgimple_seq_add_stmt_without_update (seq, stmt);\n+\treturn res;\n+      }\n+  return build_vector (type, elts);\n+}\n+\n /* Return true if the result of assignment STMT is known to be non-negative.\n    If the return value is based on the assumption that signed overflow is\n    undefined, set *STRICT_OVERFLOW_P to true; otherwise, don't change"}, {"sha": "ddbc4f0a7c54a909ce29c4c962601a9c076edbaf", "filename": "gcc/gimple-fold.h", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7c45b6600acfdc0930b980a45a364f77844139a/gcc%2Fgimple-fold.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7c45b6600acfdc0930b980a45a364f77844139a/gcc%2Fgimple-fold.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.h?ref=e7c45b6600acfdc0930b980a45a364f77844139a", "patch": "@@ -127,6 +127,21 @@ gimple_convert_to_ptrofftype (gimple_seq *seq, tree op)\n   return gimple_convert_to_ptrofftype (seq, UNKNOWN_LOCATION, op);\n }\n \n+extern tree gimple_build_vector_from_val (gimple_seq *, location_t, tree,\n+\t\t\t\t\t  tree);\n+inline tree\n+gimple_build_vector_from_val (gimple_seq *seq, tree type, tree op)\n+{\n+  return gimple_build_vector_from_val (seq, UNKNOWN_LOCATION, type, op);\n+}\n+\n+extern tree gimple_build_vector (gimple_seq *, location_t, tree, vec<tree>);\n+inline tree\n+gimple_build_vector (gimple_seq *seq, tree type, vec<tree> elts)\n+{\n+  return gimple_build_vector (seq, UNKNOWN_LOCATION, type, elts);\n+}\n+\n extern bool gimple_stmt_nonnegative_warnv_p (gimple *, bool *, int = 0);\n extern bool gimple_stmt_integer_valued_real_p (gimple *, int = 0);\n "}, {"sha": "3fe3034d85b941fbce41950f97d0170d457c5441", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 44, "deletions": 112, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7c45b6600acfdc0930b980a45a364f77844139a/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7c45b6600acfdc0930b980a45a364f77844139a/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=e7c45b6600acfdc0930b980a45a364f77844139a", "patch": "@@ -4044,33 +4044,18 @@ get_initial_def_for_reduction (gimple *stmt, tree init_val,\n         else\n           def_for_init = build_int_cst (scalar_type, int_init_val);\n \n-        /* Create a vector of '0' or '1' except the first element.  */\n-\tauto_vec<tree, 32> elts (nunits);\n-\telts.quick_grow (nunits);\n-        for (i = nunits - 2; i >= 0; --i)\n-\t  elts[i + 1] = def_for_init;\n-\n-        /* Option1: the first element is '0' or '1' as well.  */\n \tif (adjustment_def)\n+\t  /* Option1: the first element is '0' or '1' as well.  */\n+\t  init_def = gimple_build_vector_from_val (&stmts, vectype,\n+\t\t\t\t\t\t   def_for_init);\n+\telse\n \t  {\n-\t    elts[0] = def_for_init;\n-\n-\t    init_def = build_vector (vectype, elts);\n-\t    break;\n-\t  }\n-\n-        /* Option2: the first element is INIT_VAL.  */\n-\telts[0] = init_val;\n-        if (TREE_CONSTANT (init_val))\n-          init_def = build_vector (vectype, elts);\n-        else\n-\t  {\n-\t    vec<constructor_elt, va_gc> *v;\n-\t    vec_alloc (v, nunits);\n-\t    CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, init_val);\n+\t    /* Option2: the first element is INIT_VAL.  */\n+\t    auto_vec<tree, 32> elts (nunits);\n+\t    elts.quick_push (init_val);\n \t    for (i = 1; i < nunits; ++i)\n-\t      CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, elts[i]);\n-\t    init_def = build_constructor (vectype, v);\n+\t      elts.quick_push (def_for_init);\n+\t    init_def = gimple_build_vector (&stmts, vectype, elts);\n \t  }\n       }\n       break;\n@@ -4089,16 +4074,16 @@ get_initial_def_for_reduction (gimple *stmt, tree init_val,\n \t      }\n \t  }\n \tinit_val = gimple_convert (&stmts, TREE_TYPE (vectype), init_val);\n-\tif (! gimple_seq_empty_p (stmts))\n-\t  gsi_insert_seq_on_edge_immediate (loop_preheader_edge (loop), stmts);\n-\tinit_def = build_vector_from_val (vectype, init_val);\n+\tinit_def = gimple_build_vector_from_val (&stmts, vectype, init_val);\n       }\n       break;\n \n     default:\n       gcc_unreachable ();\n     }\n \n+  if (stmts)\n+    gsi_insert_seq_on_edge_immediate (loop_preheader_edge (loop), stmts);\n   return init_def;\n }\n \n@@ -4115,7 +4100,6 @@ get_initial_defs_for_reduction (slp_tree slp_node,\n   gimple *stmt = stmts[0];\n   stmt_vec_info stmt_vinfo = vinfo_for_stmt (stmt);\n   unsigned nunits;\n-  tree vec_cst;\n   unsigned j, number_of_places_left_in_vector;\n   tree vector_type, scalar_type;\n   tree vop;\n@@ -4124,10 +4108,8 @@ get_initial_defs_for_reduction (slp_tree slp_node,\n   unsigned number_of_copies = 1;\n   vec<tree> voprnds;\n   voprnds.create (number_of_vectors);\n-  bool constant_p;\n   tree neutral_op = NULL;\n   struct loop *loop;\n-  gimple_seq ctor_seq = NULL;\n \n   vector_type = STMT_VINFO_VECTYPE (stmt_vinfo);\n   scalar_type = TREE_TYPE (vector_type);\n@@ -4137,6 +4119,7 @@ get_initial_defs_for_reduction (slp_tree slp_node,\n \n   loop = (gimple_bb (stmt))->loop_father;\n   gcc_assert (loop);\n+  edge pe = loop_preheader_edge (loop);\n \n   /* op is the reduction operand of the first stmt already.  */\n   /* For additional copies (see the explanation of NUMBER_OF_COPIES below)\n@@ -4170,8 +4153,7 @@ get_initial_defs_for_reduction (slp_tree slp_node,\n       if (! reduc_chain)\n \tneutral_op = NULL;\n       else\n-\tneutral_op = PHI_ARG_DEF_FROM_EDGE (stmt,\n-\t\t\t\t\t    loop_preheader_edge (loop));\n+\tneutral_op = PHI_ARG_DEF_FROM_EDGE (stmt, pe);\n       break;\n \n     default:\n@@ -4198,7 +4180,6 @@ get_initial_defs_for_reduction (slp_tree slp_node,\n   number_of_copies = nunits * number_of_vectors / group_size;\n \n   number_of_places_left_in_vector = nunits;\n-  constant_p = true;\n   auto_vec<tree, 32> elts (nunits);\n   elts.quick_grow (nunits);\n   for (j = 0; j < number_of_copies; j++)\n@@ -4213,42 +4194,21 @@ get_initial_defs_for_reduction (slp_tree slp_node,\n \t      && neutral_op)\n \t    op = neutral_op;\n \t  else\n-\t    op = PHI_ARG_DEF_FROM_EDGE (stmt,\n-\t\t\t\t\tloop_preheader_edge (loop));\n+\t    op = PHI_ARG_DEF_FROM_EDGE (stmt, pe);\n \n           /* Create 'vect_ = {op0,op1,...,opn}'.  */\n           number_of_places_left_in_vector--;\n \t  elts[number_of_places_left_in_vector] = op;\n-\t  if (!CONSTANT_CLASS_P (op))\n-\t    constant_p = false;\n \n           if (number_of_places_left_in_vector == 0)\n             {\n-\t      if (constant_p)\n-\t\tvec_cst = build_vector (vector_type, elts);\n-\t      else\n-\t\t{\n-\t\t  vec<constructor_elt, va_gc> *v;\n-\t\t  unsigned k;\n-\t\t  vec_alloc (v, nunits);\n-\t\t  for (k = 0; k < nunits; ++k)\n-\t\t    CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, elts[k]);\n-\t\t  vec_cst = build_constructor (vector_type, v);\n-\t\t}\n-\t      tree init;\n-\t      gimple_stmt_iterator gsi;\n-\t      init = vect_init_vector (stmt, vec_cst, vector_type, NULL);\n+\t      gimple_seq ctor_seq = NULL;\n+\t      tree init = gimple_build_vector (&ctor_seq, vector_type, elts);\n \t      if (ctor_seq != NULL)\n-\t\t{\n-\t\t  gsi = gsi_for_stmt (SSA_NAME_DEF_STMT (init));\n-\t\t  gsi_insert_seq_before_without_update (&gsi, ctor_seq,\n-\t\t\t\t\t\t\tGSI_SAME_STMT);\n-\t\t  ctor_seq = NULL;\n-\t\t}\n+\t\tgsi_insert_seq_on_edge_immediate (pe, ctor_seq);\n \t      voprnds.quick_push (init);\n \n               number_of_places_left_in_vector = nunits;\n-\t      constant_p = true;\n             }\n         }\n     }\n@@ -4268,15 +4228,19 @@ get_initial_defs_for_reduction (slp_tree slp_node,\n      group of stmts, NUMBER_OF_VECTORS to be created is greater than\n      NUMBER_OF_SCALARS/NUNITS or NUNITS/NUMBER_OF_SCALARS, and hence we have\n      to replicate the vectors.  */\n+  tree neutral_vec = NULL;\n   while (number_of_vectors > vec_oprnds->length ())\n     {\n-      tree neutral_vec = NULL;\n-\n       if (neutral_op)\n         {\n           if (!neutral_vec)\n-\t    neutral_vec = build_vector_from_val (vector_type, neutral_op);\n-\n+\t    {\n+\t      gimple_seq ctor_seq = NULL;\n+\t      neutral_vec = gimple_build_vector_from_val\n+\t\t(&ctor_seq, vector_type, neutral_op);\n+\t      if (ctor_seq != NULL)\n+\t\tgsi_insert_seq_on_edge_immediate (pe, ctor_seq);\n+\t    }\n           vec_oprnds->quick_push (neutral_vec);\n         }\n       else\n@@ -4455,14 +4419,8 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n   /* Set phi nodes arguments.  */\n   FOR_EACH_VEC_ELT (reduction_phis, i, phi)\n     {\n-      tree vec_init_def, def;\n-      gimple_seq stmts;\n-      vec_init_def = force_gimple_operand (vec_initial_defs[i], &stmts,\n-\t\t\t\t\t   true, NULL_TREE);\n-      if (stmts)\n-\tgsi_insert_seq_on_edge_immediate (loop_preheader_edge (loop), stmts);\n-\n-      def = vect_defs[i];\n+      tree vec_init_def = vec_initial_defs[i];\n+      tree def = vect_defs[i];\n       for (j = 0; j < ncopies; j++)\n         {\n \t  if (j != 0)\n@@ -5405,7 +5363,7 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n                 {\n                   stmt_vec_info use_stmt_vinfo;\n                   stmt_vec_info new_phi_vinfo;\n-                  tree vect_phi_init, preheader_arg, vect_phi_res, init_def;\n+                  tree vect_phi_init, preheader_arg, vect_phi_res;\n                   basic_block bb = gimple_bb (use_stmt);\n \t\t  gimple *use;\n \n@@ -5438,10 +5396,8 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n                   /* Create vs0 - initial def of the double reduction phi.  */\n                   preheader_arg = PHI_ARG_DEF_FROM_EDGE (use_stmt,\n                                              loop_preheader_edge (outer_loop));\n-                  init_def = get_initial_def_for_reduction (stmt,\n-                                                          preheader_arg, NULL);\n-                  vect_phi_init = vect_init_vector (use_stmt, init_def,\n-                                                    vectype, NULL);\n+                  vect_phi_init = get_initial_def_for_reduction\n+\t\t    (stmt, preheader_arg, NULL);\n \n                   /* Update phi node arguments with vs0 and vs2.  */\n                   add_phi_arg (vect_phi, vect_phi_init,\n@@ -6738,36 +6694,21 @@ vectorizable_induction (gimple *phi,\n       for (ivn = 0; ivn < nivs; ++ivn)\n \t{\n \t  auto_vec<tree, 32> elts (nunits);\n-\t  bool constant_p = true;\n+\t  stmts = NULL;\n \t  for (unsigned eltn = 0; eltn < nunits; ++eltn)\n \t    {\n \t      if (ivn*nunits + eltn >= group_size\n \t\t  && (ivn*nunits + eltn) % group_size == 0)\n-\t\t{\n-\t\t  stmts = NULL;\n-\t\t  elt = gimple_build (&stmts, PLUS_EXPR, TREE_TYPE (elt),\n-\t\t\t\t      elt, step_expr);\n-\t\t  if (stmts)\n-\t\t    {\n-\t\t      new_bb = gsi_insert_seq_on_edge_immediate (pe, stmts);\n-\t\t      gcc_assert (!new_bb);\n-\t\t    }\n-\t\t}\n-\t      if (! CONSTANT_CLASS_P (elt))\n-\t\tconstant_p = false;\n+\t\telt = gimple_build (&stmts, PLUS_EXPR, TREE_TYPE (elt),\n+\t\t\t\t    elt, step_expr);\n \t      elts.quick_push (elt);\n \t    }\n-\t  if (constant_p)\n-\t    new_vec = build_vector (vectype, elts);\n-\t  else\n+\t  vec_init = gimple_build_vector (&stmts, vectype, elts);\n+\t  if (stmts)\n \t    {\n-\t      vec<constructor_elt, va_gc> *v;\n-\t      vec_alloc (v, nunits);\n-\t      for (i = 0; i < nunits; ++i)\n-\t\tCONSTRUCTOR_APPEND_ELT (v, NULL_TREE, elts[i]);\n-\t      new_vec = build_constructor (vectype, v);\n+\t      new_bb = gsi_insert_seq_on_edge_immediate (pe, stmts);\n+\t      gcc_assert (!new_bb);\n \t    }\n-\t  vec_init = vect_init_vector (phi, new_vec, vectype, NULL);\n \n \t  /* Create the induction-phi that defines the induction-operand.  */\n \t  vec_dest = vect_get_new_vect_var (vectype, vect_simple_var, \"vec_iv_\");\n@@ -6864,37 +6805,28 @@ vectorizable_induction (gimple *phi,\n     }\n   else\n     {\n-      vec<constructor_elt, va_gc> *v;\n-\n       /* iv_loop is the loop to be vectorized. Create:\n \t vec_init = [X, X+S, X+2*S, X+3*S] (S = step_expr, X = init_expr)  */\n       stmts = NULL;\n       new_name = gimple_convert (&stmts, TREE_TYPE (vectype), init_expr);\n \n-      vec_alloc (v, nunits);\n-      bool constant_p = is_gimple_min_invariant (new_name);\n-      CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, new_name);\n+      auto_vec<tree, 32> elts (nunits);\n+      elts.quick_push (new_name);\n       for (i = 1; i < nunits; i++)\n \t{\n \t  /* Create: new_name_i = new_name + step_expr  */\n \t  new_name = gimple_build (&stmts, PLUS_EXPR, TREE_TYPE (new_name),\n \t\t\t\t   new_name, step_expr);\n-\t  if (!is_gimple_min_invariant (new_name))\n-\t    constant_p = false;\n-\t  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, new_name);\n+\t  elts.quick_push (new_name);\n \t}\n+      /* Create a vector from [new_name_0, new_name_1, ...,\n+\t new_name_nunits-1]  */\n+      vec_init = gimple_build_vector (&stmts, vectype, elts);\n       if (stmts)\n \t{\n \t  new_bb = gsi_insert_seq_on_edge_immediate (pe, stmts);\n \t  gcc_assert (!new_bb);\n \t}\n-\n-      /* Create a vector from [new_name_0, new_name_1, ..., new_name_nunits-1]  */\n-      if (constant_p)\n-\tnew_vec = build_vector_from_ctor (vectype, v);\n-      else\n-\tnew_vec = build_constructor (vectype, v);\n-      vec_init = vect_init_vector (phi, new_vec, vectype, NULL);\n     }\n \n "}]}