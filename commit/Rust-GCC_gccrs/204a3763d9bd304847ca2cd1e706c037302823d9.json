{"sha": "204a3763d9bd304847ca2cd1e706c037302823d9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjA0YTM3NjNkOWJkMzA0ODQ3Y2EyY2QxZTcwNmMwMzczMDI4MjNkOQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2019-09-15T17:29:24Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2019-09-15T17:29:24Z"}, "message": "Change C++ to C comments.\n\nFrom-SVN: r275730", "tree": {"sha": "8cedbeac45aa5e7153629ea2e89299b7591c14f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8cedbeac45aa5e7153629ea2e89299b7591c14f3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/204a3763d9bd304847ca2cd1e706c037302823d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/204a3763d9bd304847ca2cd1e706c037302823d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/204a3763d9bd304847ca2cd1e706c037302823d9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/204a3763d9bd304847ca2cd1e706c037302823d9/comments", "author": null, "committer": null, "parents": [{"sha": "3e0679c8d4e22f00614a52cbd2b33780f3f1a911", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e0679c8d4e22f00614a52cbd2b33780f3f1a911", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3e0679c8d4e22f00614a52cbd2b33780f3f1a911"}], "stats": {"total": 160, "additions": 78, "deletions": 82}, "files": [{"sha": "c7a172cce4ddb2f913f8462863447afe8dd0646b", "filename": "gcc/cp/constraint.cc", "status": "modified", "additions": 63, "deletions": 66, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/204a3763d9bd304847ca2cd1e706c037302823d9/gcc%2Fcp%2Fconstraint.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/204a3763d9bd304847ca2cd1e706c037302823d9/gcc%2Fcp%2Fconstraint.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstraint.cc?ref=204a3763d9bd304847ca2cd1e706c037302823d9", "patch": "@@ -178,27 +178,27 @@ build_variable_check (tree id)\n                     Resolution of qualified concept names\n ---------------------------------------------------------------------------*/\n \n-/* This facility is used to resolve constraint checks from\n-   requirement expressions. A constraint check is a call to\n-   a function template declared with the keyword 'concept'.\n+/* This facility is used to resolve constraint checks from requirement\n+   expressions. A constraint check is a call to a function template declared\n+   with the keyword 'concept'.\n \n-   The result of resolution is a pair (a TREE_LIST) whose value\n-   is the matched declaration, and whose purpose contains the\n-   coerced template arguments that can be substituted into the\n-   call.  */\n+   The result of resolution is a pair (a TREE_LIST) whose value is the\n+   matched declaration, and whose purpose contains the coerced template\n+   arguments that can be substituted into the call.  */\n+\n+/* Given an overload set OVL, try to find a unique definition that can be\n+   instantiated by the template arguments ARGS.\n+\n+   This function is not called for arbitrary call expressions. In particular,\n+   the call expression must be written with explicit template arguments\n+   and no function arguments. For example:\n+\n+        f<T, U>()\n+\n+   If a single match is found, this returns a TREE_LIST whose VALUE\n+   is the constraint function (not the template), and its PURPOSE is\n+   the complete set of arguments substituted into the parameter list.  */\n \n-// Given an overload set OVL, try to find a unique definition that can be\n-// instantiated by the template arguments ARGS.\n-//\n-// This function is not called for arbitrary call expressions. In particular,\n-// the call expression must be written with explicit template arguments\n-// and no function arguments. For example:\n-//\n-//      f<T, U>()\n-//\n-// If a single match is found, this returns a TREE_LIST whose VALUE\n-// is the constraint function (not the template), and its PURPOSE is\n-// the complete set of arguments substituted into the parameter list.\n static tree\n resolve_constraint_check (tree ovl, tree args)\n {\n@@ -211,20 +211,20 @@ resolve_constraint_check (tree ovl, tree args)\n       if (TREE_CODE (tmpl) != TEMPLATE_DECL)\n         continue;\n \n-      // Don't try to deduce checks for non-concepts. We often\n-      // end up trying to resolve constraints in functional casts\n-      // as part of a postfix-expression. We can save time and\n-      // headaches by not instantiating those declarations.\n-      //\n-      // NOTE: This masks a potential error, caused by instantiating\n-      // non-deduced contexts using placeholder arguments.\n+      /* Don't try to deduce checks for non-concepts. We often end up trying\n+         to resolve constraints in functional casts as part of a\n+         postfix-expression. We can save time and headaches by not\n+         instantiating those declarations.\n+\n+         NOTE: This masks a potential error, caused by instantiating\n+         non-deduced contexts using placeholder arguments. */\n       tree fn = DECL_TEMPLATE_RESULT (tmpl);\n       if (DECL_ARGUMENTS (fn))\n         continue;\n       if (!DECL_DECLARED_CONCEPT_P (fn))\n         continue;\n \n-      // Remember the candidate if we can deduce a substitution.\n+      /* Remember the candidate if we can deduce a substitution.  */\n       ++processing_template_decl;\n       tree parms = TREE_VALUE (DECL_TEMPLATE_PARMS (tmpl));\n       if (tree subst = coerce_template_parms (parms, args, tmpl))\n@@ -247,29 +247,30 @@ resolve_constraint_check (tree ovl, tree args)\n   return cands;\n }\n \n-// Determine if the the call expression CALL is a constraint check, and\n-// return the concept declaration and arguments being checked. If CALL\n-// does not denote a constraint check, return NULL.\n+/* Determine if the the call expression CALL is a constraint check, and\n+   return the concept declaration and arguments being checked. If CALL\n+   does not denote a constraint check, return NULL.  */\n+\n tree\n resolve_constraint_check (tree call)\n {\n   gcc_assert (TREE_CODE (call) == CALL_EXPR);\n \n-  // A constraint check must be only a template-id expression. If\n-  // it's a call to a base-link, its function(s) should be a\n-  // template-id expression. If this is not a template-id, then it\n-  // cannot be a concept-check.\n+  /* A constraint check must be only a template-id expression.\n+     If it's a call to a base-link, its function(s) should be a\n+     template-id expression. If this is not a template-id, then\n+     it cannot be a concept-check.  */\n   tree target = CALL_EXPR_FN (call);\n   if (BASELINK_P (target))\n     target = BASELINK_FUNCTIONS (target);\n   if (TREE_CODE (target) != TEMPLATE_ID_EXPR)\n     return NULL_TREE;\n \n-  // Get the overload set and template arguments and try to\n-  // resolve the target.\n+  /* Get the overload set and template arguments and try to\n+     resolve the target.  */\n   tree ovl = TREE_OPERAND (target, 0);\n \n-  /* This is a function call of a variable concept... ill-formed. */\n+  /* This is a function call of a variable concept... ill-formed.  */\n   if (TREE_CODE (ovl) == TEMPLATE_DECL)\n     {\n       error_at (location_of (call),\n@@ -311,14 +312,11 @@ resolve_variable_concept_check (tree id)\n     return error_mark_node;\n }\n \n-\n-/* Given a call expression or template-id expression to\n-  a concept EXPR possibly including a wildcard, deduce\n-  the concept being checked and the prototype parameter.\n-  Returns true if the constraint and prototype can be\n-  deduced and false otherwise.  Note that the CHECK and\n-  PROTO arguments are set to NULL_TREE if this returns\n-  false.  */\n+/* Given a call expression or template-id expression to a concept EXPR\n+   possibly including a wildcard, deduce the concept being checked and\n+   the prototype parameter. Returns true if the constraint and prototype\n+   can be deduced and false otherwise.  Note that the CHECK and PROTO\n+   arguments are set to NULL_TREE if this returns false.  */\n \n bool\n deduce_constrained_parameter (tree expr, tree& check, tree& proto)\n@@ -344,9 +342,9 @@ deduce_constrained_parameter (tree expr, tree& check, tree& proto)\n   return false;\n }\n \n-// Given a call expression or template-id expression to a concept, EXPR,\n-// deduce the concept being checked and return the template arguments.\n-// Returns NULL_TREE if deduction fails.\n+/* Given a call expression or template-id expression to a concept, EXPR,\n+   deduce the concept being checked and return the template arguments.\n+   Returns NULL_TREE if deduction fails.  */\n static tree\n deduce_concept_introduction (tree expr)\n {\n@@ -1099,17 +1097,17 @@ current_template_constraints (void)\n   return build_constraints (tmpl_constr, NULL_TREE);\n }\n \n-// If the recently parsed TYPE declares or defines a template or template\n-// specialization, get its corresponding constraints from the current\n-// template parameters and bind them to TYPE's declaration.\n+/* If the recently parsed TYPE declares or defines a template or\n+   template specialization, get its corresponding constraints from the\n+   current template parameters and bind them to TYPE's declaration.  */\n+\n tree\n associate_classtype_constraints (tree type)\n {\n   if (!type || type == error_mark_node || TREE_CODE (type) != RECORD_TYPE)\n     return type;\n \n-  // An explicit class template specialization has no template\n-  // parameters.\n+  /* An explicit class template specialization has no template parameters.  */\n   if (!current_template_parms)\n     return type;\n \n@@ -1118,10 +1116,10 @@ associate_classtype_constraints (tree type)\n       tree decl = TYPE_STUB_DECL (type);\n       tree ci = current_template_constraints ();\n \n-      // An implicitly instantiated member template declaration already\n-      // has associated constraints. If it is defined outside of its\n-      // class, then we need match these constraints against those of\n-      // original declaration.\n+      /* An implicitly instantiated member template declaration already\n+\t has associated constraints. If it is defined outside of its\n+\t class, then we need match these constraints against those of\n+\t original declaration.  */\n       if (tree orig_ci = get_constraints (decl))\n         {\n           if (!equivalent_constraints (ci, orig_ci))\n@@ -2431,7 +2429,7 @@ constraint_expression_satisfied_p (tree expr, tree args)\n ---------------------------------------------------------------------------*/\n \n /* Finish a requires expression for the given PARMS (possibly\n-   null) and the non-empty sequence of requirements. */\n+   null) and the non-empty sequence of requirements.  */\n tree\n finish_requires_expr (tree parms, tree reqs)\n {\n@@ -2485,21 +2483,20 @@ finish_nested_requirement (tree expr)\n   return build_nt (NESTED_REQ, expr);\n }\n \n-// Check that FN satisfies the structural requirements of a\n-// function concept definition.\n+/* Check that FN satisfies the structural requirements of a\n+   function concept definition.  */\n tree\n check_function_concept (tree fn)\n {\n-  // Check that the function is comprised of only a single\n-  // return statement.\n+  /* Check that the function is comprised of only a return statement.  */\n   tree body = DECL_SAVED_TREE (fn);\n   if (TREE_CODE (body) == BIND_EXPR)\n     body = BIND_EXPR_BODY (body);\n \n-  // Sometimes a function call results in the creation of clean up\n-  // points. Allow these to be preserved in the body of the\n-  // constraint, as we might actually need them for some constexpr\n-  // evaluations.\n+  /* Sometimes a function call results in the creation of clean up\n+     points. Allow these to be preserved in the body of the\n+     constraint, as we might actually need them for some constexpr\n+     evaluations.  */\n   if (TREE_CODE (body) == CLEANUP_POINT_EXPR)\n     body = TREE_OPERAND (body, 0);\n "}, {"sha": "165039ef07c00768a2fc4ac3f05b1ea42ceaaa0c", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/204a3763d9bd304847ca2cd1e706c037302823d9/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/204a3763d9bd304847ca2cd1e706c037302823d9/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=204a3763d9bd304847ca2cd1e706c037302823d9", "patch": "@@ -42033,7 +42033,7 @@ synthesize_implicit_template_parm  (cp_parser *parser, tree constr)\n       non_type = true;\n     }\n \n-  // Attach the constraint to the parm before processing.\n+  /* Attach the constraint to the parm before processing.  */\n   tree node = build_tree_list (NULL_TREE, synth_tmpl_parm);\n   TREE_TYPE (node) = constr;\n   tree new_parm\n@@ -42076,8 +42076,8 @@ synthesize_implicit_template_parm  (cp_parser *parser, tree constr)\n       TREE_VEC_ELT (new_parms, new_parm_idx) = parser->implicit_template_parms;\n     }\n \n-  // If the new parameter was constrained, we need to add that to the\n-  // constraints in the template parameter list.\n+  /* If the new parameter was constrained, we need to add that to the\n+     constraints in the template parameter list.  */\n   if (tree req = TEMPLATE_PARM_CONSTRAINTS (tree_last (new_parm)))\n     {\n       tree reqs = TEMPLATE_PARMS_CONSTRAINTS (current_template_parms);"}, {"sha": "54d28131a0180c06f928de084188a7568858f3eb", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/204a3763d9bd304847ca2cd1e706c037302823d9/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/204a3763d9bd304847ca2cd1e706c037302823d9/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=204a3763d9bd304847ca2cd1e706c037302823d9", "patch": "@@ -2438,7 +2438,7 @@ determine_specialization (tree template_id,\n       tree fn = TREE_VALUE (candidates);\n       *targs_out = copy_node (DECL_TI_ARGS (fn));\n \n-      // Propagate the candidate's constraints to the declaration.\n+      /* Propagate the candidate's constraints to the declaration.  */\n       set_constraints (decl, get_constraints (fn));\n \n       /* DECL is a re-declaration or partial instantiation of a template\n@@ -7789,13 +7789,13 @@ is_compatible_template_arg (tree parm, tree arg)\n \n   tree arg_cons = get_constraints (arg);\n \n-  // If the template parameter is constrained, we need to rewrite its\n-  // constraints in terms of the ARG's template parameters. This ensures\n-  // that all of the template parameter types will have the same depth.\n-  //\n-  // Note that this is only valid when coerce_template_template_parm is\n-  // true for the innermost template parameters of PARM and ARG. In other\n-  // words, because coercion is successful, this conversion will be valid.\n+  /* If the template parameter is constrained, we need to rewrite its\n+     constraints in terms of the ARG's template parameters. This ensures\n+     that all of the template parameter types will have the same depth.\n+\n+     Note that this is only valid when coerce_template_template_parm is\n+     true for the innermost template parameters of PARM and ARG. In other\n+     words, because coercion is successful, this conversion will be valid.  */\n   if (parm_cons)\n     {\n       tree args = template_parms_to_args (DECL_TEMPLATE_PARMS (arg));"}, {"sha": "756324876249f253f35a8143f0a9fa36a6efba7b", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/204a3763d9bd304847ca2cd1e706c037302823d9/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/204a3763d9bd304847ca2cd1e706c037302823d9/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=204a3763d9bd304847ca2cd1e706c037302823d9", "patch": "@@ -3058,8 +3058,8 @@ finish_template_template_parm (tree aggr, tree identifier)\n   DECL_TEMPLATE_RESULT (tmpl) = decl;\n   DECL_ARTIFICIAL (decl) = 1;\n \n-  // Associate the constraints with the underlying declaration,\n-  // not the template.\n+  /* Associate the constraints with the underlying declaration,\n+     not the template.  */\n   tree reqs = TEMPLATE_PARMS_CONSTRAINTS (current_template_parms);\n   tree constr = build_constraints (reqs, NULL_TREE);\n   set_constraints (decl, constr);\n@@ -10075,7 +10075,6 @@ apply_deduced_return_type (tree fco, tree return_type)\n #endif\n       cfun->returns_struct = aggr;\n     }\n-\n }\n \n /* DECL is a local variable or parameter from the surrounding scope of a\n@@ -10132,7 +10131,7 @@ capture_decltype (tree decl)\n static tree\n finish_unary_fold_expr (tree expr, int op, tree_code dir)\n {\n-  // Build a pack expansion (assuming expr has pack type).\n+  /* Build a pack expansion (assuming expr has pack type).  */\n   if (!uses_parameter_packs (expr))\n     {\n       error_at (location_of (expr), \"operand of fold expression has no \"\n@@ -10141,7 +10140,7 @@ finish_unary_fold_expr (tree expr, int op, tree_code dir)\n     }\n   tree pack = make_pack_expansion (expr);\n \n-  // Build the fold expression.\n+  /* Build the fold expression.  */\n   tree code = build_int_cstu (integer_type_node, abs (op));\n   tree fold = build_min_nt_loc (UNKNOWN_LOCATION, dir, code, pack);\n   FOLD_EXPR_MODIFY_P (fold) = (op < 0);"}]}