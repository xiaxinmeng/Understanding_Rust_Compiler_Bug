{"sha": "39cab01994f20e38587d0ef91c9c87f2ef537078", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzljYWIwMTk5NGYyMGUzODU4N2QwZWY5MWM5Yzg3ZjJlZjUzNzA3OA==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2004-07-14T13:50:39Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2004-07-14T13:50:39Z"}, "message": "expmed.c (expand_sdiv_pow2): New function to expand signed division by a positive power of two...\n\n\n\t* expmed.c (expand_sdiv_pow2): New function to expand signed division\n\tby a positive power of two, split out from expand_divmod.  Provide\n\tan alternate implementation when shifts are expensive.  Lower the\n\tthreshold for using a branchless implementation to BRANCH_COST >= 2.\n\t(expand_divmod): Call expand_sdiv_pow2 for suitable divisions.\n\nFrom-SVN: r84686", "tree": {"sha": "5a6881133339e9a39477c6b3d100490239e9ccf2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5a6881133339e9a39477c6b3d100490239e9ccf2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/39cab01994f20e38587d0ef91c9c87f2ef537078", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39cab01994f20e38587d0ef91c9c87f2ef537078", "html_url": "https://github.com/Rust-GCC/gccrs/commit/39cab01994f20e38587d0ef91c9c87f2ef537078", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39cab01994f20e38587d0ef91c9c87f2ef537078/comments", "author": null, "committer": null, "parents": [{"sha": "51a61243e79e7be0543afc0cf1ac7db67a39ce5a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51a61243e79e7be0543afc0cf1ac7db67a39ce5a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/51a61243e79e7be0543afc0cf1ac7db67a39ce5a"}], "stats": {"total": 89, "additions": 57, "deletions": 32}, "files": [{"sha": "c3fe6c0f52d4237e27e402138de35bd567377a51", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39cab01994f20e38587d0ef91c9c87f2ef537078/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39cab01994f20e38587d0ef91c9c87f2ef537078/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=39cab01994f20e38587d0ef91c9c87f2ef537078", "patch": "@@ -1,3 +1,11 @@\n+2004-07-14  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* expmed.c (expand_sdiv_pow2): New function to expand signed division\n+\tby a positive power of two, split out from expand_divmod.  Provide\n+\tan alternate implementation when shifts are expensive.  Lower the\n+\tthreshold for using a branchless implementation to BRANCH_COST >= 2.\n+\t(expand_divmod): Call expand_sdiv_pow2 for suitable divisions.\n+\n 2004-07-14  Paolo Bonzini  <bonzini@gnu.org>\n \n \t* tree-dfa.c (make_rename_temp): *Really* work just"}, {"sha": "d93351da2e7a3e13062308de93a878edf6bd2e29", "filename": "gcc/expmed.c", "status": "modified", "additions": 49, "deletions": 32, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39cab01994f20e38587d0ef91c9c87f2ef537078/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39cab01994f20e38587d0ef91c9c87f2ef537078/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=39cab01994f20e38587d0ef91c9c87f2ef537078", "patch": "@@ -52,6 +52,7 @@ static rtx extract_split_bit_field (rtx, unsigned HOST_WIDE_INT,\n \t\t\t\t    unsigned HOST_WIDE_INT, int);\n static void do_cmp_and_jump (rtx, rtx, enum rtx_code, enum machine_mode, rtx);\n static rtx expand_smod_pow2 (enum machine_mode, rtx, HOST_WIDE_INT);\n+static rtx expand_sdiv_pow2 (enum machine_mode, rtx, HOST_WIDE_INT);\n \n /* Nonzero means divides or modulus operations are relatively cheap for\n    powers of two, so don't use branches; emit the operation instead.\n@@ -3170,6 +3171,53 @@ expand_smod_pow2 (enum machine_mode mode, rtx op0, HOST_WIDE_INT d)\n   emit_label (label);\n   return result;\n }\n+\n+/* Expand signed division of OP0 by a power of two D in mode MODE.\n+   This routine is only called for positive values of D.  */\n+\n+static rtx\n+expand_sdiv_pow2 (enum machine_mode mode, rtx op0, HOST_WIDE_INT d)\n+{\n+  rtx temp, label;\n+  tree shift;\n+  int logd;\n+\n+  logd = floor_log2 (d);\n+  shift = build_int_2 (logd, 0);\n+\n+  if (d == 2 && BRANCH_COST >= 1)\n+    {\n+      temp = gen_reg_rtx (mode);\n+      temp = emit_store_flag (temp, LT, op0, const0_rtx, mode, 0, 1);\n+      temp = expand_binop (mode, add_optab, temp, op0, NULL_RTX,\n+\t\t\t   0, OPTAB_LIB_WIDEN);\n+      return expand_shift (RSHIFT_EXPR, mode, temp, shift, NULL_RTX, 0);\n+    }\n+\n+  if (BRANCH_COST >= 2)\n+    {\n+      int ushift = GET_MODE_BITSIZE (mode) - logd;\n+\n+      temp = gen_reg_rtx (mode);\n+      temp = emit_store_flag (temp, LT, op0, const0_rtx, mode, 0, -1);\n+      if (shift_cost[mode][ushift] > COSTS_N_INSNS (1))\n+\ttemp = expand_binop (mode, and_optab, temp, GEN_INT (d - 1),\n+\t\t\t     NULL_RTX, 0, OPTAB_LIB_WIDEN);\n+      else\n+\ttemp = expand_shift (RSHIFT_EXPR, mode, temp,\n+\t\t\t     build_int_2 (ushift, 0), NULL_RTX, 1);\n+      temp = expand_binop (mode, add_optab, temp, op0, NULL_RTX,\n+\t\t\t   0, OPTAB_LIB_WIDEN);\n+      return expand_shift (RSHIFT_EXPR, mode, temp, shift, NULL_RTX, 0);\n+    }\n+\n+  label = gen_label_rtx ();\n+  temp = copy_to_mode_reg (mode, op0);\n+  do_cmp_and_jump (temp, const0_rtx, GE, mode, label);\n+  expand_inc (temp, GEN_INT (d - 1));\n+  emit_label (label);\n+  return expand_shift (RSHIFT_EXPR, mode, temp, shift, NULL_RTX, 0);\n+}\n \f\n /* Emit the code to divide OP0 by OP1, putting the result in TARGET\n    if that is convenient, and returning where the result is.\n@@ -3582,38 +3630,7 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \t\t\tif (remainder)\n \t\t\t  return gen_lowpart (mode, remainder);\n \t\t      }\n-\t\t    lgup = floor_log2 (abs_d);\n-\t\t    if (BRANCH_COST < 1 || (abs_d != 2 && BRANCH_COST < 3))\n-\t\t      {\n-\t\t\trtx label = gen_label_rtx ();\n-\t\t\trtx t1;\n-\n-\t\t\tt1 = copy_to_mode_reg (compute_mode, op0);\n-\t\t\tdo_cmp_and_jump (t1, const0_rtx, GE,\n-\t\t\t\t\t compute_mode, label);\n-\t\t\texpand_inc (t1, gen_int_mode (abs_d - 1,\n-\t\t\t\t\t\t      compute_mode));\n-\t\t\temit_label (label);\n-\t\t\tquotient = expand_shift (RSHIFT_EXPR, compute_mode, t1,\n-\t\t\t\t\t\t build_int_2 (lgup, 0),\n-\t\t\t\t\t\t tquotient, 0);\n-\t\t      }\n-\t\t    else\n-\t\t      {\n-\t\t\trtx t1, t2, t3;\n-\t\t\tt1 = expand_shift (RSHIFT_EXPR, compute_mode, op0,\n-\t\t\t\t\t   build_int_2 (size - 1, 0),\n-\t\t\t\t\t   NULL_RTX, 0);\n-\t\t\tt2 = expand_shift (RSHIFT_EXPR, compute_mode, t1,\n-\t\t\t\t\t   build_int_2 (size - lgup, 0),\n-\t\t\t\t\t   NULL_RTX, 1);\n-\t\t\tt3 = force_operand (gen_rtx_PLUS (compute_mode,\n-\t\t\t\t\t\t\t  op0, t2),\n-\t\t\t\t\t    NULL_RTX);\n-\t\t\tquotient = expand_shift (RSHIFT_EXPR, compute_mode, t3,\n-\t\t\t\t\t\t build_int_2 (lgup, 0),\n-\t\t\t\t\t\t tquotient, 0);\n-\t\t      }\n+\t\t    quotient = expand_sdiv_pow2 (compute_mode, op0, abs_d);\n \n \t\t    /* We have computed OP0 / abs(OP1).  If OP1 is negative,\n \t\t       negate the quotient.  */"}]}