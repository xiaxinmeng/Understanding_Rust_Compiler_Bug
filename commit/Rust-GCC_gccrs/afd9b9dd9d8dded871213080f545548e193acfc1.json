{"sha": "afd9b9dd9d8dded871213080f545548e193acfc1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWZkOWI5ZGQ5ZDhkZGVkODcxMjEzMDgwZjU0NTU0OGUxOTNhY2ZjMQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2002-12-30T19:02:11Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2002-12-30T19:02:11Z"}, "message": "parse.y: Remove.\n\n\t* parse.y: Remove.\n\t* spew.c: Likewise.\n\t* Make-lang.in (gt-cp-spew.h): Remove.\n\t* cp-tree.h (do_pending_lang_change): Remove.\n\t(do_identifier): Change prototype.\n\t(finish_id_expr): Remove.\n\t* decl.c (lookup_name_real): Remove yylex variable.\n\t* decl2.c (build_expr_from_tree): Adjust call to do_identifier.\n\t* lex.c (init_cpp_parse): Remove.\n\t(reduce_cmp): Likewise.\n\t(token_cmp): Likewise.\n\t(yychar): Likewise.\n\t(lastiddecl): Likewise.\n\t(token_count): Likewise.\n\t(reduce_count): Likewise.\n\t(yyhook): Likewise.\n\t(print_parse_statistics): Likewise.\n\t(do_pending_lang_change): Likewise.\n\t(do_identifier): Remove parsing parameter.\n\t* lex.h (lastiddecl): Remove.\n\t(looking_for_typename): Remove.\n\t(looking_for_template): Likewise.\n\t(pending_lang_change): Likewise.\n\t(yylex): Likewise.\n\t* semantics.c (finish_id_expr): Remove.\n\nFrom-SVN: r60642", "tree": {"sha": "a43933ec640ae0a70ea41b9f0d2e514222c396c1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a43933ec640ae0a70ea41b9f0d2e514222c396c1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/afd9b9dd9d8dded871213080f545548e193acfc1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/afd9b9dd9d8dded871213080f545548e193acfc1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/afd9b9dd9d8dded871213080f545548e193acfc1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/afd9b9dd9d8dded871213080f545548e193acfc1/comments", "author": null, "committer": null, "parents": [{"sha": "a47a68100f94e7c0679ef8ec478a523bbbaced7b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a47a68100f94e7c0679ef8ec478a523bbbaced7b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a47a68100f94e7c0679ef8ec478a523bbbaced7b"}], "stats": {"total": 5990, "additions": 35, "deletions": 5955}, "files": [{"sha": "050ba952a5140a613992284a53325ef7f564f0b6", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afd9b9dd9d8dded871213080f545548e193acfc1/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afd9b9dd9d8dded871213080f545548e193acfc1/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=afd9b9dd9d8dded871213080f545548e193acfc1", "patch": "@@ -10,6 +10,32 @@\n \n 2002-12-30  Mark Mitchell  <mark@codesourcery.com>\n \n+\t* parse.y: Remove.\n+\t* spew.c: Likewise.\n+\t* Make-lang.in (gt-cp-spew.h): Remove.\n+\t* cp-tree.h (do_pending_lang_change): Remove.\n+\t(do_identifier): Change prototype.\n+\t(finish_id_expr): Remove.\n+\t* decl.c (lookup_name_real): Remove yylex variable.\n+\t* decl2.c (build_expr_from_tree): Adjust call to do_identifier.\n+\t* lex.c (init_cpp_parse): Remove.\n+\t(reduce_cmp): Likewise.\n+\t(token_cmp): Likewise.\n+\t(yychar): Likewise.\n+\t(lastiddecl): Likewise.\n+\t(token_count): Likewise.\n+\t(reduce_count): Likewise.\n+\t(yyhook): Likewise.\n+\t(print_parse_statistics): Likewise.\n+\t(do_pending_lang_change): Likewise.\n+\t(do_identifier): Remove parsing parameter.\n+\t* lex.h (lastiddecl): Remove.\n+\t(looking_for_typename): Remove.\n+\t(looking_for_template): Likewise.\n+\t(pending_lang_change): Likewise.\n+\t(yylex): Likewise.\n+\t* semantics.c (finish_id_expr): Remove.\n+\t\n \t* decl.c (grokdeclarator): Diagnost \"extern thread\" and \"static\n \tthread\" correctly.\n "}, {"sha": "7361a2d5a279bed31d557de80a11769400b9a12b", "filename": "gcc/cp/Make-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afd9b9dd9d8dded871213080f545548e193acfc1/gcc%2Fcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afd9b9dd9d8dded871213080f545548e193acfc1/gcc%2Fcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMake-lang.in?ref=afd9b9dd9d8dded871213080f545548e193acfc1", "patch": "@@ -102,7 +102,7 @@ $(srcdir)/cp/cfns.h: $(srcdir)/cp/cfns.gperf\n \t\t$(srcdir)/cp/cfns.gperf > $(srcdir)/cp/cfns.h\n \n gtype-cp.h gt-cp-call.h gt-cp-decl.h gt-cp-decl2.h : s-gtype; @true\n-gt-cp-pt.h gt-cp-repo.h gt-cp-spew.h gt-cp-parser.h : s-gtype; @true\n+gt-cp-pt.h gt-cp-repo.h gt-cp-parser.h : s-gtype; @true\n gt-cp-tree.h : s-gtype; @true\n \n #\f"}, {"sha": "bdc09a6a9f9a8b8d94e81bc0bf8f1fb144bd6cef", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afd9b9dd9d8dded871213080f545548e193acfc1/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afd9b9dd9d8dded871213080f545548e193acfc1/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=afd9b9dd9d8dded871213080f545548e193acfc1", "patch": "@@ -3974,10 +3974,9 @@ extern void snarf_method\t\t\tPARAMS ((tree));\n \n extern void note_got_semicolon\t\t\tPARAMS ((tree));\n extern void note_list_got_semicolon\t\tPARAMS ((tree));\n-extern void do_pending_lang_change\t\tPARAMS ((void));\n extern void see_typename\t\t\tPARAMS ((void));\n extern void unqualified_name_lookup_error       PARAMS ((tree));\n-extern tree do_identifier\t\t\tPARAMS ((tree, int, tree));\n+extern tree do_identifier\t\t\tPARAMS ((tree, tree));\n extern tree do_scoped_id\t\t\tPARAMS ((tree, tree));\n extern tree identifier_typedecl_value\t\tPARAMS ((tree));\n extern tree build_lang_decl\t\t\tPARAMS ((enum tree_code, tree, tree));\n@@ -4198,7 +4197,6 @@ extern tree finish_object_call_expr             PARAMS ((tree, tree, tree));\n extern tree finish_qualified_object_call_expr   PARAMS ((tree, tree, tree));\n extern tree finish_pseudo_destructor_expr       (tree, tree, tree);\n extern tree finish_unary_op_expr                PARAMS ((enum tree_code, tree));\n-extern tree finish_id_expr                      PARAMS ((tree));\n extern tree finish_compound_literal             (tree, tree);\n extern tree finish_fname                        (tree);\n extern void save_type_access_control\t\tPARAMS ((tree));"}, {"sha": "141373e972e9a989aab0eca642725d9a9cb3d971", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afd9b9dd9d8dded871213080f545548e193acfc1/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afd9b9dd9d8dded871213080f545548e193acfc1/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=afd9b9dd9d8dded871213080f545548e193acfc1", "patch": "@@ -6081,7 +6081,6 @@ lookup_name_real (tree name,\n {\n   tree t;\n   tree val = NULL_TREE;\n-  int yylex = 0;\n   int val_is_implicit_typename = 0;\n \n   /* Conversion operators are handled specially because ordinary\n@@ -6144,7 +6143,7 @@ lookup_name_real (tree name,\n       if (binding\n \t  && (!val || !IMPLICIT_TYPENAME_TYPE_DECL_P (binding)))\n \t{\n-\t  if (val_is_implicit_typename && !yylex)\n+\t  if (val_is_implicit_typename)\n \t    warn_about_implicit_typename_lookup (val, binding);\n \t  val = binding;\n \t  val_is_implicit_typename\n@@ -6160,7 +6159,7 @@ lookup_name_real (tree name,\n       t = unqualified_namespace_lookup (name, flags, 0);\n       if (t)\n \t{\n-\t  if (val_is_implicit_typename && !yylex)\n+\t  if (val_is_implicit_typename)\n \t    warn_about_implicit_typename_lookup (val, t);\n \t  val = t;\n \t}"}, {"sha": "6efb9bdd46b519250a3f5b5c403b6ea8092581b0", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afd9b9dd9d8dded871213080f545548e193acfc1/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afd9b9dd9d8dded871213080f545548e193acfc1/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=afd9b9dd9d8dded871213080f545548e193acfc1", "patch": "@@ -2940,7 +2940,7 @@ build_expr_from_tree (t)\n   switch (TREE_CODE (t))\n     {\n     case IDENTIFIER_NODE:\n-      return do_identifier (t, 0, NULL_TREE);\n+      return do_identifier (t, NULL_TREE);\n \n     case LOOKUP_EXPR:\n       if (LOOKUP_EXPR_GLOBAL (t))\n@@ -2950,7 +2950,7 @@ build_expr_from_tree (t)\n \t}\n       else\n \t{\n-\t  t = do_identifier (TREE_OPERAND (t, 0), 0, NULL_TREE);\n+\t  t = do_identifier (TREE_OPERAND (t, 0), NULL_TREE);\n \t  if (TREE_CODE (t) == ALIAS_DECL)\n \t    t = DECL_INITIAL (t);\n \t  return t;\n@@ -3186,7 +3186,7 @@ build_expr_from_tree (t)\n                   || !lookup_member (current_class_type, id, 0, 0)))\n             {\n               /* Do Koenig lookup if there are no class members.  */\n-              name = do_identifier (id, 0, args);\n+              name = do_identifier (id, args);\n             }\n           else if (TREE_CODE (name) == TEMPLATE_ID_EXPR\n \t\t   || ! really_overloaded_fn (name))"}, {"sha": "57115b7260a5abbae82d10779ed893cc68d60596", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 2, "deletions": 144, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afd9b9dd9d8dded871213080f545548e193acfc1/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afd9b9dd9d8dded871213080f545548e193acfc1/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=afd9b9dd9d8dded871213080f545548e193acfc1", "patch": "@@ -47,7 +47,6 @@ Boston, MA 02111-1307, USA.  */\n #endif\n \n static int interface_strcmp PARAMS ((const char *));\n-static int *init_cpp_parse PARAMS ((void));\n static void init_cp_pragma PARAMS ((void));\n \n static tree parse_strconst_pragma PARAMS ((const char *, int));\n@@ -57,12 +56,6 @@ static void handle_pragma_interface PARAMS ((cpp_reader *));\n static void handle_pragma_implementation PARAMS ((cpp_reader *));\n static void handle_pragma_java_exceptions PARAMS ((cpp_reader *));\n \n-#ifdef GATHER_STATISTICS\n-#ifdef REDUCE_LENGTH\n-static int reduce_cmp PARAMS ((int *, int *));\n-static int token_cmp PARAMS ((int *, int *));\n-#endif\n-#endif\n static int is_global PARAMS ((tree));\n static void init_operators PARAMS ((void));\n static void copy_lang_type PARAMS ((tree));\n@@ -76,18 +69,6 @@ static void copy_lang_type PARAMS ((tree));\n \n #include \"cpplib.h\"\n \n-extern int yychar;\t\t/*  the lookahead symbol\t\t*/\n-\n-/* the declaration found for the last IDENTIFIER token read in.  yylex\n-   must look this up to detect typedefs, which get token type\n-   tTYPENAME, so it is left around in case the identifier is not a\n-   typedef but is used in a context which makes it a reference to a\n-   variable.  */\n-tree lastiddecl;\n-\n-/* Array for holding counts of the numbers of tokens seen.  */\n-extern int *token_count;\n-\n /* Functions and data structures for #pragma interface.\n \n    `#pragma implementation' means that the main file being compiled\n@@ -202,20 +183,6 @@ cxx_finish ()\n   c_common_finish ();\n }\n \n-static int *\n-init_cpp_parse ()\n-{\n-#ifdef GATHER_STATISTICS\n-#ifdef REDUCE_LENGTH\n-  reduce_count = (int *) xcalloc (sizeof (int), (REDUCE_LENGTH + 1));\n-  reduce_count += 1;\n-  token_count = (int *) xcalloc (sizeof (int), (TOKEN_LENGTH + 1));\n-  token_count += 1;\n-#endif\n-#endif\n-  return token_count;\n-}\n-\n /* A mapping from tree codes to operator name information.  */\n operator_name_info_t operator_name_info[(int) LAST_CPLUS_TREE_CODE];\n /* Similar, but for assignment operators.  */\n@@ -492,7 +459,6 @@ cxx_init (filename)\n   TREE_TYPE (null_node) = c_common_type_for_size (POINTER_SIZE, 0);\n   ridpointers[RID_NULL] = null_node;\n \n-  token_count = init_cpp_parse ();\n   interface_unknown = 1;\n \n   filename = c_common_init (filename);\n@@ -506,92 +472,6 @@ cxx_init (filename)\n   return filename;\n }\n \f\n-#if defined(GATHER_STATISTICS) && defined(REDUCE_LENGTH)\n-static int *reduce_count;\n-#endif\n-\n-int *token_count;\n-\n-#if 0\n-#define REDUCE_LENGTH ARRAY_SIZE (yyr2)\n-#define TOKEN_LENGTH (256 + ARRAY_SIZE (yytname))\n-#endif\n-\n-#ifdef GATHER_STATISTICS\n-#ifdef REDUCE_LENGTH\n-void\n-yyhook (yyn)\n-     int yyn;\n-{\n-  reduce_count[yyn] += 1;\n-}\n-\n-static int\n-reduce_cmp (p, q)\n-     int *p, *q;\n-{\n-  return reduce_count[*q] - reduce_count[*p];\n-}\n-\n-static int\n-token_cmp (p, q)\n-     int *p, *q;\n-{\n-  return token_count[*q] - token_count[*p];\n-}\n-#endif\n-#endif\n-\n-void\n-print_parse_statistics ()\n-{\n-#ifdef GATHER_STATISTICS\n-#ifdef REDUCE_LENGTH\n-#if YYDEBUG != 0\n-  int i;\n-  int maxlen = REDUCE_LENGTH;\n-  unsigned *sorted;\n-\n-  if (reduce_count[-1] == 0)\n-    return;\n-\n-  if (TOKEN_LENGTH > REDUCE_LENGTH)\n-    maxlen = TOKEN_LENGTH;\n-  sorted = (unsigned *) alloca (sizeof (int) * maxlen);\n-\n-  for (i = 0; i < TOKEN_LENGTH; i++)\n-    sorted[i] = i;\n-  qsort (sorted, TOKEN_LENGTH, sizeof (int), token_cmp);\n-  for (i = 0; i < TOKEN_LENGTH; i++)\n-    {\n-      int idx = sorted[i];\n-      if (token_count[idx] == 0)\n-\tbreak;\n-      if (token_count[idx] < token_count[-1])\n-\tbreak;\n-      fprintf (stderr, \"token %d, `%s', count = %d\\n\",\n-\t       idx, yytname[YYTRANSLATE (idx)], token_count[idx]);\n-    }\n-  fprintf (stderr, \"\\n\");\n-  for (i = 0; i < REDUCE_LENGTH; i++)\n-    sorted[i] = i;\n-  qsort (sorted, REDUCE_LENGTH, sizeof (int), reduce_cmp);\n-  for (i = 0; i < REDUCE_LENGTH; i++)\n-    {\n-      int idx = sorted[i];\n-      if (reduce_count[idx] == 0)\n-\tbreak;\n-      if (reduce_count[idx] < reduce_count[-1])\n-\tbreak;\n-      fprintf (stderr, \"rule %d, line %d, count = %d\\n\",\n-\t       idx, yyrline[idx], reduce_count[idx]);\n-    }\n-  fprintf (stderr, \"\\n\");\n-#endif\n-#endif\n-#endif\n-}\n-\n /* Helper function to load global variables with interface\n    information.  */\n \n@@ -819,15 +699,6 @@ handle_pragma_java_exceptions (dfile)\n   choose_personality_routine (lang_java);\n }\n \n-void\n-do_pending_lang_change ()\n-{\n-  for (; pending_lang_change > 0; --pending_lang_change)\n-    push_lang_context (lang_name_c);\n-  for (; pending_lang_change < 0; ++pending_lang_change)\n-    pop_lang_context ();\n-}\n-\n /* Return true if d is in a global scope.  */\n \n static int\n@@ -884,21 +755,13 @@ unqualified_name_lookup_error (tree name)\n }\n \n tree\n-do_identifier (token, parsing, args)\n+do_identifier (token, args)\n      register tree token;\n-     int parsing;\n      tree args;\n {\n   register tree id;\n-  int lexing = (parsing == 1 || parsing == 3);\n \n-  if (! lexing)\n-    id = lookup_name (token, 0);\n-  else\n-    id = lastiddecl;\n-\n-  if (lexing && id && TREE_DEPRECATED (id))\n-    warn_deprecated_use (id);\n+  id = lookup_name (token, 0);\n \n   /* Do Koenig lookup if appropriate (inside templates we build lookup\n      expressions instead).\n@@ -910,11 +773,6 @@ do_identifier (token, parsing, args)\n   if (args && !current_template_parms && (!id || is_global (id)))\n     id = lookup_arg_dependent (token, id, args);\n \n-  /* Remember that this name has been used in the class definition, as per\n-     [class.scope0] */\n-  if (id && parsing && parsing != 3)\n-    maybe_note_name_used_in_class (token, id);\n-\n   if (id == error_mark_node)\n     {\n       /* lookup_name quietly returns error_mark_node if we're parsing,"}, {"sha": "5a08fd9a0523f02b3be0a8ac90baf694a998a70e", "filename": "gcc/cp/lex.h", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afd9b9dd9d8dded871213080f545548e193acfc1/gcc%2Fcp%2Flex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afd9b9dd9d8dded871213080f545548e193acfc1/gcc%2Fcp%2Flex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.h?ref=afd9b9dd9d8dded871213080f545548e193acfc1", "patch": "@@ -64,20 +64,4 @@ typedef unsigned long RID_BIT_TYPE;\t/* assumed at least 32 bits */\n #define RIDBIT_RESET_ALL(V) do { (V) = 0; } while (0)\n #endif\n \n-/* the declaration found for the last IDENTIFIER token read in.\n-   yylex must look this up to detect typedefs, which get token type TYPENAME,\n-   so it is left around in case the identifier is not a typedef but is\n-   used in a context which makes it a reference to a variable.  */\n-extern GTY(()) tree lastiddecl;\n-\n-/* Back-door communication channel to the lexer.  */\n-extern int looking_for_typename;\n-extern int looking_for_template;\n-\n-/* Pending language change.\n-   Positive is push count, negative is pop count.  */\n-extern int pending_lang_change;\n-\n-extern int yylex PARAMS ((void));\n-\n #endif /* ! GCC_CP_LEX_H */"}, {"sha": "d1f9f4d68b4725e17521a9d2974edc4851bcab5b", "filename": "gcc/cp/parse.y", "status": "removed", "additions": 0, "deletions": 4220, "changes": 4220, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a47a68100f94e7c0679ef8ec478a523bbbaced7b/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a47a68100f94e7c0679ef8ec478a523bbbaced7b/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=a47a68100f94e7c0679ef8ec478a523bbbaced7b"}, {"sha": "cb72800c6e10d1d628150d289b0d327b003bf193", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afd9b9dd9d8dded871213080f545548e193acfc1/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afd9b9dd9d8dded871213080f545548e193acfc1/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=afd9b9dd9d8dded871213080f545548e193acfc1", "patch": "@@ -1550,20 +1550,6 @@ finish_unary_op_expr (code, expr)\n   return result;\n }\n \n-/* Finish an id-expression.  */\n-\n-tree\n-finish_id_expr (expr)\n-     tree expr;\n-{\n-  if (TREE_CODE (expr) == IDENTIFIER_NODE)\n-    expr = do_identifier (expr, 1, NULL_TREE);\n-\n-  if (TREE_TYPE (expr) == error_mark_node)\n-    expr = error_mark_node;\n-  return expr;\n-}\n-\n /* Finish a compound-literal expression.  TYPE is the type to which\n    the INITIALIZER_LIST is being cast.  */\n "}, {"sha": "d50c926b0951424811b82c3eaa59ed9141085e9a", "filename": "gcc/cp/spew.c", "status": "removed", "additions": 0, "deletions": 1551, "changes": 1551, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a47a68100f94e7c0679ef8ec478a523bbbaced7b/gcc%2Fcp%2Fspew.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a47a68100f94e7c0679ef8ec478a523bbbaced7b/gcc%2Fcp%2Fspew.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fspew.c?ref=a47a68100f94e7c0679ef8ec478a523bbbaced7b", "patch": "@@ -1,1551 +0,0 @@\n-/* Type Analyzer for GNU C++.\n-   Copyright (C) 1987, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n-   Hacked... nay, bludgeoned... by Mark Eichin (eichin@cygnus.com)\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-/* This file is the type analyzer for GNU C++.  To debug it, define SPEW_DEBUG\n-   when compiling parse.c and spew.c.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"input.h\"\n-#include \"tree.h\"\n-#include \"cp-tree.h\"\n-#include \"cpplib.h\"\n-#include \"c-pragma.h\"\n-#include \"lex.h\"\n-#include \"flags.h\"\n-#include \"obstack.h\"\n-#include \"toplev.h\"\n-#include \"ggc.h\"\n-#include \"intl.h\"\n-#include \"timevar.h\"\n-\n-#ifdef SPEW_DEBUG\n-#define SPEW_INLINE\n-#else\n-#define SPEW_INLINE inline\n-#endif\n-\n-/* This takes a token stream that hasn't decided much about types and\n-   tries to figure out as much as it can, with excessive lookahead and\n-   backtracking.  */\n-\n-/* fifo of tokens recognized and available to parser.  */\n-struct token GTY(())\n-{\n-  /* The values for YYCHAR will fit in a short.  */\n-  short\t\tyychar;\n-  unsigned int\tlineno;\n-  YYSTYPE GTY ((desc (\"%1.yychar\"))) yylval;\n-};\n-\n-/* Since inline methods can refer to text which has not yet been seen,\n-   we store the text of the method in a structure which is placed in the\n-   DECL_PENDING_INLINE_INFO field of the FUNCTION_DECL.\n-   After parsing the body of the class definition, the FUNCTION_DECL's are\n-   scanned to see which ones have this field set.  Those are then digested\n-   one at a time.\n-\n-   This function's FUNCTION_DECL will have a bit set in its common so\n-   that we know to watch out for it.  */\n-\n-#define TOKEN_CHUNK_SIZE 20\n-struct token_chunk GTY(())\n-{\n-  struct token_chunk *next;\n-  struct token toks[TOKEN_CHUNK_SIZE];\n-};\n-\n-struct unparsed_text GTY(())\n-{\n-  struct unparsed_text *next;\t/* process this one next */\n-  tree decl;\t\t/* associated declaration */\n-  location_t locus;     /* location we got the text from */\n-  int interface;\t/* remembering interface_unknown and interface_only */\n-\n-  struct token_chunk * tokens; /* Start of the token list.  */\n-\n-  struct token_chunk *last_chunk; /* End of the token list.  */\n-  short last_pos;\t/* Number of tokens used in the last chunk of\n-\t\t\t   TOKENS.  */\n-\n-  short cur_pos;\t/* Current token in 'cur_chunk', when rescanning.  */\n-  struct token_chunk *cur_chunk;  /* Current chunk, when rescanning.  */\n-};\n-\n-/* Stack of state saved off when we return to an inline method or\n-   default argument that has been stored for later parsing.  */\n-struct feed GTY(())\n-{\n-  struct unparsed_text *input;\n-  location_t locus;\n-  int yychar;\n-  YYSTYPE GTY ((desc (\"%1.yychar\"))) yylval;\n-  int first_token;\n-  struct obstack GTY ((skip (\"\"))) token_obstack;\n-  struct feed *next;\n-};\n-\n-static GTY(()) struct feed *feed;\n-\n-static SPEW_INLINE void do_aggr PARAMS ((void));\n-static SPEW_INLINE int identifier_type PARAMS ((tree));\n-static void scan_tokens PARAMS ((int));\n-static void feed_defarg PARAMS ((tree));\n-static void finish_defarg PARAMS ((void));\n-static void yylexstring PARAMS ((struct token *));\n-static int read_token PARAMS ((struct token *));\n-\n-static SPEW_INLINE int num_tokens PARAMS ((void));\n-static SPEW_INLINE struct token *nth_token PARAMS ((int));\n-static SPEW_INLINE int next_token PARAMS ((struct token *));\n-static SPEW_INLINE int shift_token PARAMS ((void));\n-static SPEW_INLINE void push_token PARAMS ((struct token *));\n-static SPEW_INLINE void consume_token PARAMS ((void));\n-static SPEW_INLINE int read_process_identifier PARAMS ((YYSTYPE *));\n-\n-static SPEW_INLINE void feed_input PARAMS ((struct unparsed_text *));\n-static SPEW_INLINE struct token * space_for_token\n-  PARAMS ((struct unparsed_text *t));\n-static SPEW_INLINE struct token * remove_last_token\n-  PARAMS ((struct unparsed_text *t));\n-static struct unparsed_text * alloc_unparsed_text\n-  PARAMS ((const location_t *, tree decl, int interface));\n-\n-static void snarf_block PARAMS ((struct unparsed_text *t));\n-static tree snarf_defarg PARAMS ((void));\n-static void snarf_parenthesized_expression (struct unparsed_text *);\n-static int frob_id PARAMS ((int, int, tree *));\n-\n-/* The list of inline functions being held off until we reach the end of\n-   the current class declaration.  */\n-static GTY(()) struct unparsed_text *pending_inlines;\n-static GTY(()) struct unparsed_text *pending_inlines_tail;\n-\n-/* The list of previously-deferred inline functions currently being parsed.\n-   This exists solely to be a GC root.  */\n-static GTY(()) struct unparsed_text *processing_these_inlines;\n-\n-static void begin_parsing_inclass_inline PARAMS ((struct unparsed_text *));\n-\n-#ifdef SPEW_DEBUG\n-int spew_debug = 0;\n-static unsigned int yylex_ctr = 0;\n-\n-static void debug_yychar PARAMS ((int));\n-\n-/* In parse.y: */\n-extern char *debug_yytranslate PARAMS ((int));\n-#endif\n-static enum cpp_ttype last_token;\n-static tree last_token_id;\n-\n-/* From lex.c: */\n-/* the declaration found for the last IDENTIFIER token read in.  yylex\n-   must look this up to detect typedefs, which get token type\n-   tTYPENAME, so it is left around in case the identifier is not a\n-   typedef but is used in a context which makes it a reference to a\n-   variable.  */\n-extern tree lastiddecl;\t\t/* let our brains leak out here too */\n-extern int\tyychar;\t\t/*  the lookahead symbol\t\t*/\n-extern YYSTYPE\tyylval;\t\t/*  the semantic value of the\t\t*/\n-\t\t\t\t/*  lookahead symbol\t\t\t*/\n-/* The token fifo lives in this obstack.  */\n-static struct obstack token_obstack;\n-static int first_token;\n-\n-/* When we see a default argument in a method declaration, we snarf it as\n-   text using snarf_defarg.  When we get up to namespace scope, we then go\n-   through and parse all of them using do_pending_defargs.  Since yacc\n-   parsers are not reentrant, we retain defargs state in these two\n-   variables so that subsequent calls to do_pending_defargs can resume\n-   where the previous call left off. DEFARG_FNS is a tree_list where\n-   the TREE_TYPE is the current_class_type, TREE_VALUE is the FUNCTION_DECL,\n-   and TREE_PURPOSE is the list unprocessed dependent functions.  */\n-\n-/* list of functions with unprocessed defargs */\n-static GTY(()) tree defarg_fns;\n-/* current default parameter */\n-static GTY(()) tree defarg_parm;\n-/* list of unprocessed fns met during current fn.  */\n-static GTY(()) tree defarg_depfns;\n-/* list of fns with circular defargs */\n-static GTY(()) tree defarg_fnsdone;\n-\n-/* Initialize obstacks. Called once, from cxx_init.  */\n-\n-void\n-init_spew ()\n-{\n-  gcc_obstack_init (&token_obstack);\n-}\n-\n-/* Subroutine of read_token.  */\n-static SPEW_INLINE int\n-read_process_identifier (pyylval)\n-     YYSTYPE *pyylval;\n-{\n-  tree id = pyylval->ttype;\n-\n-  if (C_IS_RESERVED_WORD (id))\n-    {\n-      pyylval->ttype = ridpointers[C_RID_CODE (id)];\n-      return C_RID_YYCODE (id);\n-    }\n-\n-  /* Make sure that user does not collide with our internal naming\n-     scheme.  This is not necessary if '.' is used to remove them from\n-     the user's namespace, but is if '$' or double underscores are.  */\n-\n-#if !defined(JOINER) || JOINER == '$'\n-  if (VPTR_NAME_P (id)\n-      || VTABLE_NAME_P (id)\n-      || TEMP_NAME_P (id)\n-      || ANON_AGGRNAME_P (id))\n-     warning (\n-\"identifier name `%s' conflicts with GNU C++ internal naming strategy\",\n-\t      IDENTIFIER_POINTER (id));\n-#endif\n-  return IDENTIFIER;\n-}\n-\n-/* Concatenate strings before returning them to the parser.  This isn't quite\n-   as good as having it done in the lexer, but it's better than nothing.  */\n-\n-static void\n-yylexstring (t)\n-     struct token *t;\n-{\n-  enum cpp_ttype next_type;\n-  tree next;\n-\n-  next_type = c_lex (&next);\n-  if (next_type == CPP_STRING || next_type == CPP_WSTRING)\n-    {\n-      varray_type strings;\n-\n-      VARRAY_TREE_INIT (strings, 32, \"strings\");\n-      VARRAY_PUSH_TREE (strings, t->yylval.ttype);\n-\n-      do\n-\t{\n-\t  VARRAY_PUSH_TREE (strings, next);\n-\t  next_type = c_lex (&next);\n-\t}\n-      while (next_type == CPP_STRING || next_type == CPP_WSTRING);\n-\n-      t->yylval.ttype = combine_strings (strings);\n-      last_token_id = t->yylval.ttype;\n-    }\n-\n-  /* We will have always read one token too many.  */\n-  _cpp_backup_tokens (parse_in, 1);\n-\n-  t->yychar = STRING;\n-}\n-\n-/* Read the next token from the input file.  The token is written into\n-   T, and its type number is returned.  */\n-static int\n-read_token (t)\n-     struct token *t;\n-{\n- retry:\n-\n-  last_token = c_lex (&last_token_id);\n-  t->yylval.ttype = last_token_id;\n-\n-  switch (last_token)\n-    {\n-#define YYCHAR(YY)\tt->yychar = (YY); break;\n-#define YYCODE(C)\tt->yylval.code = (C);\n-\n-    case CPP_EQ:\t\t\t\tYYCHAR('=');\n-    case CPP_NOT:\t\t\t\tYYCHAR('!');\n-    case CPP_GREATER:\tYYCODE(GT_EXPR);\tYYCHAR('>');\n-    case CPP_LESS:\tYYCODE(LT_EXPR);\tYYCHAR('<');\n-    case CPP_PLUS:\tYYCODE(PLUS_EXPR);\tYYCHAR('+');\n-    case CPP_MINUS:\tYYCODE(MINUS_EXPR);\tYYCHAR('-');\n-    case CPP_MULT:\tYYCODE(MULT_EXPR);\tYYCHAR('*');\n-    case CPP_DIV:\tYYCODE(TRUNC_DIV_EXPR);\tYYCHAR('/');\n-    case CPP_MOD:\tYYCODE(TRUNC_MOD_EXPR);\tYYCHAR('%');\n-    case CPP_AND:\tYYCODE(BIT_AND_EXPR);\tYYCHAR('&');\n-    case CPP_OR:\tYYCODE(BIT_IOR_EXPR);\tYYCHAR('|');\n-    case CPP_XOR:\tYYCODE(BIT_XOR_EXPR);\tYYCHAR('^');\n-    case CPP_RSHIFT:\tYYCODE(RSHIFT_EXPR);\tYYCHAR(RSHIFT);\n-    case CPP_LSHIFT:\tYYCODE(LSHIFT_EXPR);\tYYCHAR(LSHIFT);\n-\n-    case CPP_COMPL:\t\t\t\tYYCHAR('~');\n-    case CPP_AND_AND:\t\t\t\tYYCHAR(ANDAND);\n-    case CPP_OR_OR:\t\t\t\tYYCHAR(OROR);\n-    case CPP_QUERY:\t\t\t\tYYCHAR('?');\n-    case CPP_COLON:\t\t\t\tYYCHAR(':');\n-    case CPP_COMMA:\t\t\t\tYYCHAR(',');\n-    case CPP_OPEN_PAREN:\t\t\tYYCHAR('(');\n-    case CPP_CLOSE_PAREN:\t\t\tYYCHAR(')');\n-    case CPP_EQ_EQ:\tYYCODE(EQ_EXPR);\tYYCHAR(EQCOMPARE);\n-    case CPP_NOT_EQ:\tYYCODE(NE_EXPR);\tYYCHAR(EQCOMPARE);\n-    case CPP_GREATER_EQ:YYCODE(GE_EXPR);\tYYCHAR(ARITHCOMPARE);\n-    case CPP_LESS_EQ:\tYYCODE(LE_EXPR);\tYYCHAR(ARITHCOMPARE);\n-\n-    case CPP_PLUS_EQ:\tYYCODE(PLUS_EXPR);\tYYCHAR(ASSIGN);\n-    case CPP_MINUS_EQ:\tYYCODE(MINUS_EXPR);\tYYCHAR(ASSIGN);\n-    case CPP_MULT_EQ:\tYYCODE(MULT_EXPR);\tYYCHAR(ASSIGN);\n-    case CPP_DIV_EQ:\tYYCODE(TRUNC_DIV_EXPR);\tYYCHAR(ASSIGN);\n-    case CPP_MOD_EQ:\tYYCODE(TRUNC_MOD_EXPR);\tYYCHAR(ASSIGN);\n-    case CPP_AND_EQ:\tYYCODE(BIT_AND_EXPR);\tYYCHAR(ASSIGN);\n-    case CPP_OR_EQ:\tYYCODE(BIT_IOR_EXPR);\tYYCHAR(ASSIGN);\n-    case CPP_XOR_EQ:\tYYCODE(BIT_XOR_EXPR);\tYYCHAR(ASSIGN);\n-    case CPP_RSHIFT_EQ:\tYYCODE(RSHIFT_EXPR);\tYYCHAR(ASSIGN);\n-    case CPP_LSHIFT_EQ:\tYYCODE(LSHIFT_EXPR);\tYYCHAR(ASSIGN);\n-\n-    case CPP_OPEN_SQUARE:\t\t\tYYCHAR('[');\n-    case CPP_CLOSE_SQUARE:\t\t\tYYCHAR(']');\n-    case CPP_OPEN_BRACE:\t\t\tYYCHAR('{');\n-    case CPP_CLOSE_BRACE:\t\t\tYYCHAR('}');\n-    case CPP_SEMICOLON:\t\t\t\tYYCHAR(';');\n-    case CPP_ELLIPSIS:\t\t\t\tYYCHAR(ELLIPSIS);\n-\n-    case CPP_PLUS_PLUS:\t\t\t\tYYCHAR(PLUSPLUS);\n-    case CPP_MINUS_MINUS:\t\t\tYYCHAR(MINUSMINUS);\n-    case CPP_DEREF:\t\t\t\tYYCHAR(POINTSAT);\n-    case CPP_DOT:\t\t\t\tYYCHAR('.');\n-\n-    /* These tokens are C++ specific.  */\n-    case CPP_SCOPE:\t\t\t\tYYCHAR(SCOPE);\n-    case CPP_DEREF_STAR: \t\t\tYYCHAR(POINTSAT_STAR);\n-    case CPP_DOT_STAR:\t\t\t\tYYCHAR(DOT_STAR);\n-    case CPP_MIN_EQ:\tYYCODE(MIN_EXPR);\tYYCHAR(ASSIGN);\n-    case CPP_MAX_EQ:\tYYCODE(MAX_EXPR);\tYYCHAR(ASSIGN);\n-    case CPP_MIN:\tYYCODE(MIN_EXPR);\tYYCHAR(MIN_MAX);\n-    case CPP_MAX:\tYYCODE(MAX_EXPR);\tYYCHAR(MIN_MAX);\n-#undef YYCHAR\n-#undef YYCODE\n-\n-    case CPP_EOF:\n-      t->yychar = 0;\n-      break;\n-\n-    case CPP_NAME:\n-      t->yychar = read_process_identifier (&t->yylval);\n-      break;\n-\n-    case CPP_NUMBER:\n-    case CPP_CHAR:\n-    case CPP_WCHAR:\n-      t->yychar = CONSTANT;\n-      break;\n-\n-    case CPP_STRING:\n-    case CPP_WSTRING:\n-      yylexstring (t);\n-      break;\n-\n-    default:\n-      yyerror (\"parse error\");\n-      goto retry;\n-    }\n-\n-  t->lineno = lineno;\n-  return t->yychar;\n-}\n-\n-static void\n-feed_input (input)\n-     struct unparsed_text *input;\n-{\n-  struct feed *f;\n-#if 0\n-  if (feed)\n-    abort ();\n-#endif\n-\n-  f = ggc_alloc (sizeof (struct feed));\n-\n-  input->cur_chunk = input->tokens;\n-  input->cur_pos = 0;\n-\n-#ifdef SPEW_DEBUG\n-  if (spew_debug)\n-    fprintf (stderr, \"\\tfeeding %s:%d [%d tokens]\\n\",\n-\t     input->locus.file, input->locus.line,\n-\t     input->last_pos - input->cur_pos);\n-#endif\n-\n-  f->input = input;\n-  f->locus.file = input_filename;\n-  f->locus.line = lineno;\n-  f->yychar = yychar;\n-  f->yylval = yylval;\n-  f->first_token = first_token;\n-  f->token_obstack = token_obstack;\n-  f->next = feed;\n-\n-  input_filename = input->locus.file;\n-  lineno = input->locus.line;\n-  yychar = YYEMPTY;\n-  yylval.ttype = NULL_TREE;\n-  first_token = 0;\n-  gcc_obstack_init (&token_obstack);\n-  feed = f;\n-}\n-\n-void\n-end_input ()\n-{\n-  struct feed *f = feed;\n-\n-  input_filename = f->locus.file;\n-  lineno = f->locus.line;\n-  yychar = f->yychar;\n-  yylval = f->yylval;\n-  first_token = f->first_token;\n-  obstack_free (&token_obstack, 0);\n-  token_obstack = f->token_obstack;\n-  feed = f->next;\n-\n-#ifdef SPEW_DEBUG\n-  if (spew_debug)\n-    fprintf (stderr, \"\\treturning to %s:%d\\n\", input_filename, lineno);\n-#endif\n-}\n-\n-/* Token queue management.  */\n-\n-/* Return the number of tokens available on the fifo.  */\n-static SPEW_INLINE int\n-num_tokens ()\n-{\n-  return (obstack_object_size (&token_obstack) / sizeof (struct token))\n-    - first_token;\n-}\n-\n-/* Fetch the token N down the line from the head of the fifo.  */\n-\n-static SPEW_INLINE struct token*\n-nth_token (n)\n-     int n;\n-{\n-#ifdef ENABLE_CHECKING\n-  /* could just have this do slurp_ implicitly, but this way is easier\n-     to debug...  */\n-  my_friendly_assert (n >= 0 && n < num_tokens (), 298);\n-#endif\n-  return ((struct token*)obstack_base (&token_obstack)) + n + first_token;\n-}\n-\n-static const struct token Teosi = { END_OF_SAVED_INPUT, 0 UNION_INIT_ZERO };\n-static const struct token Tpad = { EMPTY, 0 UNION_INIT_ZERO };\n-\n-/* Copy the next token into T and return its value.  */\n-static SPEW_INLINE int\n-next_token (t)\n-     struct token *t;\n-{\n-  if (!feed)\n-    return read_token (t);\n-\n-  if (feed->input->cur_chunk != feed->input->last_chunk\n-      || feed->input->cur_pos != feed->input->last_pos)\n-    {\n-      if (feed->input->cur_pos == TOKEN_CHUNK_SIZE)\n-\t{\n-\t  feed->input->cur_chunk = feed->input->cur_chunk->next;\n-\t  feed->input->cur_pos = 0;\n-\t}\n-      memcpy (t, feed->input->cur_chunk->toks + feed->input->cur_pos,\n-\t      sizeof (struct token));\n-      feed->input->cur_pos++;\n-      return t->yychar;\n-    }\n-\n-  return 0;\n-}\n-\n-/* Shift the next token onto the fifo.  */\n-static SPEW_INLINE int\n-shift_token ()\n-{\n-  size_t point = obstack_object_size (&token_obstack);\n-  obstack_blank (&token_obstack, sizeof (struct token));\n-  return next_token ((struct token *) (obstack_base (&token_obstack) + point));\n-}\n-\n-/* Consume the next token out of the fifo.  */\n-\n-static SPEW_INLINE void\n-consume_token ()\n-{\n-  if (num_tokens () == 1)\n-    {\n-      obstack_free (&token_obstack, obstack_base (&token_obstack));\n-      first_token = 0;\n-    }\n-  else\n-    first_token++;\n-}\n-\n-/* Push a token at the head of the queue; it will be the next token read.  */\n-static SPEW_INLINE void\n-push_token (t)\n-     struct token *t;\n-{\n-  if (first_token == 0)  /* We hope this doesn't happen often.  */\n-    {\n-      size_t active = obstack_object_size (&token_obstack);\n-      obstack_blank (&token_obstack, sizeof (struct token));\n-      if (active)\n-\tmemmove (obstack_base (&token_obstack) + sizeof (struct token),\n-\t\t obstack_base (&token_obstack), active);\n-      first_token++;\n-    }\n-  first_token--;\n-  memcpy (nth_token (0), t, sizeof (struct token));\n-}\n-\n-\n-/* Pull in enough tokens that the queue is N long beyond the current\n-   token.  */\n-\n-static void\n-scan_tokens (n)\n-     int n;\n-{\n-  int i;\n-  int num = num_tokens ();\n-  int yychar;\n-\n-  /* First, prune any empty tokens at the end.  */\n-  i = num;\n-  while (i > 0 && nth_token (i - 1)->yychar == EMPTY)\n-    i--;\n-  if (i < num)\n-    {\n-      obstack_blank (&token_obstack, -((num - i) * sizeof (struct token)));\n-      num = i;\n-    }\n-\n-  /* Now, if we already have enough tokens, return.  */\n-  if (num > n)\n-    return;\n-\n-  /* Never read past these characters: they might separate\n-     the current input stream from one we save away later.  */\n-  for (i = 0; i < num; i++)\n-    {\n-      yychar = nth_token (i)->yychar;\n-      if (yychar == '{' || yychar == ':' || yychar == ';')\n-\tgoto pad_tokens;\n-    }\n-\n-  while (num_tokens () <= n)\n-    {\n-      yychar = shift_token ();\n-      if (yychar == '{' || yychar == ':' || yychar == ';')\n-\tgoto pad_tokens;\n-    }\n-  return;\n-\n- pad_tokens:\n-  while (num_tokens () <= n)\n-    obstack_grow (&token_obstack, &Tpad, sizeof (struct token));\n-}\n-\n-int looking_for_typename;\n-int looking_for_template;\n-\n-static int after_friend;\n-static int after_new;\n-static int do_snarf_defarg;\n-\n-tree got_scope;\n-tree got_object;\n-\n-static SPEW_INLINE int\n-identifier_type (decl)\n-     tree decl;\n-{\n-  tree t;\n-\n-  if (TREE_CODE (decl) == TEMPLATE_DECL)\n-    {\n-      if (TREE_CODE (DECL_TEMPLATE_RESULT (decl)) == TYPE_DECL)\n-\treturn PTYPENAME;\n-      else if (looking_for_template)\n-\treturn PFUNCNAME;\n-    }\n-  if (looking_for_template && really_overloaded_fn (decl))\n-    {\n-      /* See through a baselink.  */\n-      if (TREE_CODE (decl) == BASELINK)\n-\tdecl = BASELINK_FUNCTIONS (decl);\n-\n-      for (t = decl; t != NULL_TREE; t = OVL_CHAIN (t))\n-\tif (DECL_FUNCTION_TEMPLATE_P (OVL_FUNCTION (t)))\n-\t  return PFUNCNAME;\n-    }\n-  if (TREE_CODE (decl) == NAMESPACE_DECL)\n-    return NSNAME;\n-  if (TREE_CODE (decl) != TYPE_DECL)\n-    return IDENTIFIER;\n-  if (DECL_ARTIFICIAL (decl) && TREE_TYPE (decl) == current_class_type)\n-    return SELFNAME;\n-\n-  /* A constructor declarator for a template type will get here as an\n-     implicit typename, a TYPENAME_TYPE with a type.  */\n-  t = got_scope;\n-  if (t && TREE_CODE (t) == TYPENAME_TYPE)\n-    t = TREE_TYPE (t);\n-  decl = TREE_TYPE (decl);\n-  if (TREE_CODE (decl) == TYPENAME_TYPE)\n-    decl = TREE_TYPE (decl);\n-  if (t && t == decl)\n-    return SELFNAME;\n-\n-  return tTYPENAME;\n-}\n-\n-/* token[0] == AGGR (struct/union/enum)\n-   Thus, token[1] is either a tTYPENAME or a TYPENAME_DEFN.\n-   If token[2] == '{' or ':' then it's TYPENAME_DEFN.\n-   It's also a definition if it's a forward declaration (as in 'struct Foo;')\n-   which we can tell if token[2] == ';' *and* token[-1] != FRIEND or NEW.  */\n-\n-static SPEW_INLINE void\n-do_aggr ()\n-{\n-  int yc1, yc2;\n-\n-  scan_tokens (2);\n-  yc1 = nth_token (1)->yychar;\n-  if (yc1 != tTYPENAME && yc1 != IDENTIFIER && yc1 != PTYPENAME)\n-    return;\n-  yc2 = nth_token (2)->yychar;\n-  if (yc2 == ';')\n-    {\n-      /* It's a forward declaration iff we were not preceded by\n-         'friend' or `new'.  */\n-      if (after_friend || after_new)\n-\treturn;\n-    }\n-  else if (yc2 != '{' && yc2 != ':')\n-    return;\n-\n-  switch (yc1)\n-    {\n-    case tTYPENAME:\n-      nth_token (1)->yychar = TYPENAME_DEFN;\n-      break;\n-    case PTYPENAME:\n-      nth_token (1)->yychar = PTYPENAME_DEFN;\n-      break;\n-    case IDENTIFIER:\n-      nth_token (1)->yychar = IDENTIFIER_DEFN;\n-      break;\n-    default:\n-      abort ();\n-    }\n-}\n-\n-void\n-see_typename ()\n-{\n-  /* Only types expected, not even namespaces.  */\n-  looking_for_typename = 2;\n-  if (yychar < 0)\n-    if ((yychar = yylex ()) < 0) yychar = 0;\n-  looking_for_typename = 0;\n-  if (yychar == IDENTIFIER)\n-    {\n-      lastiddecl = lookup_name (yylval.ttype, -2);\n-      if (lastiddecl)\n-\tyychar = identifier_type (lastiddecl);\n-    }\n-}\n-\n-int\n-yylex ()\n-{\n-  int yychr;\n-  int old_looking_for_typename = 0;\n-  int just_saw_new = 0;\n-  int just_saw_friend = 0;\n-\n-  timevar_push (TV_LEX);\n-\n- retry:\n-#ifdef SPEW_DEBUG\n-  if (spew_debug)\n-  {\n-    yylex_ctr ++;\n-    fprintf (stderr, \"\\t\\t## %d @%d \", yylex_ctr, lineno);\n-  }\n-#endif\n-\n-  if (do_snarf_defarg)\n-    {\n-      do_snarf_defarg = 0;\n-      yylval.ttype = snarf_defarg ();\n-      yychar = DEFARG;\n-      got_object = NULL_TREE;\n-      timevar_pop (TV_LEX);\n-      return DEFARG;\n-    }\n-\n-  /* if we've got tokens, send them */\n-  else if (num_tokens ())\n-    yychr = nth_token (0)->yychar;\n-  else\n-    yychr = shift_token ();\n-\n-  /* many tokens just need to be returned. At first glance, all we\n-     have to do is send them back up, but some of them are needed to\n-     figure out local context.  */\n-  switch (yychr)\n-    {\n-    case EMPTY:\n-      /* This is a lexical no-op.  */\n-#ifdef SPEW_DEBUG\n-      if (spew_debug)\n-\tdebug_yychar (yychr);\n-#endif\n-      consume_token ();\n-      goto retry;\n-\n-    case '(':\n-      scan_tokens (1);\n-      if (nth_token (1)->yychar == ')')\n-\t{\n-\t  consume_token ();\n-\t  yychr = LEFT_RIGHT;\n-\t}\n-      break;\n-\n-    case IDENTIFIER:\n-    {\n-      int peek;\n-\n-      scan_tokens (1);\n-      peek = nth_token (1)->yychar;\n-      yychr = frob_id (yychr, peek, &nth_token (0)->yylval.ttype);\n-      break;\n-    }\n-    case IDENTIFIER_DEFN:\n-    case tTYPENAME:\n-    case TYPENAME_DEFN:\n-    case PTYPENAME:\n-    case PTYPENAME_DEFN:\n-      /* If we see a SCOPE next, restore the old value.\n-\t Otherwise, we got what we want.  */\n-      looking_for_typename = old_looking_for_typename;\n-      looking_for_template = 0;\n-      break;\n-\n-    case SCSPEC:\n-      if (nth_token (0)->yylval.ttype == ridpointers[RID_EXTERN])\n-\t{\n-\t  scan_tokens (1);\n-\t  if (nth_token (1)->yychar == STRING)\n-\t    {\n-\t      yychr = EXTERN_LANG_STRING;\n-\t      nth_token (1)->yylval.ttype = get_identifier\n-\t\t(TREE_STRING_POINTER (nth_token (1)->yylval.ttype));\n-\t      consume_token ();\n-\t    }\n-\t}\n-      /* do_aggr needs to know if the previous token was `friend'.  */\n-      else if (nth_token (0)->yylval.ttype == ridpointers[RID_FRIEND])\n-\tjust_saw_friend = 1;\n-\n-      break;\n-\n-    case NEW:\n-      /* do_aggr needs to know if the previous token was `new'.  */\n-      just_saw_new = 1;\n-      break;\n-\n-    case TYPESPEC:\n-    case '{':\n-    case ':':\n-    case ';':\n-      /* If this provides a type for us, then revert lexical\n-\t state to standard state.  */\n-      looking_for_typename = 0;\n-      break;\n-\n-    case AGGR:\n-      do_aggr ();\n-      break;\n-\n-    case ENUM:\n-      /* Set this again, in case we are rescanning.  */\n-      looking_for_typename = 2;\n-      break;\n-\n-    default:\n-      break;\n-    }\n-\n-  after_friend = just_saw_friend;\n-  after_new = just_saw_new;\n-\n-  /* class member lookup only applies to the first token after the object\n-     expression, except for explicit destructor calls.  */\n-  if (yychr != '~')\n-    got_object = NULL_TREE;\n-\n-  yychar = yychr;\n-  {\n-    struct token *tok = nth_token (0);\n-\n-    yylval = tok->yylval;\n-    if (tok->lineno)\n-      lineno = tok->lineno;\n-  }\n-\n-#ifdef SPEW_DEBUG\n-  if (spew_debug)\n-    debug_yychar (yychr);\n-#endif\n-  consume_token ();\n-\n-  timevar_pop (TV_LEX);\n-  return yychr;\n-}\n-\n-/* Unget character CH from the input stream.\n-   If RESCAN is nonzero, then we want to `see' this\n-   character as the next input token.  */\n-\n-void\n-yyungetc (ch, rescan)\n-     int ch;\n-     int rescan;\n-{\n-  /* Unget a character from the input stream.  */\n-  if (yychar == YYEMPTY || rescan == 0)\n-    {\n-      struct token fake;\n-\n-      fake.yychar = ch;\n-      fake.yylval.ttype = 0;\n-      fake.lineno = lineno;\n-\n-      push_token (&fake);\n-    }\n-  else\n-    {\n-      yychar = ch;\n-    }\n-}\n-\n-/* Lexer hackery to determine what *IDP really is.  */\n-\n-static int\n-frob_id (yyc, peek, idp)\n-     int yyc;\n-     int peek;\n-     tree *idp;\n-{\n-  tree trrr;\n-  int old_looking_for_typename = 0;\n-\n-  if (peek == SCOPE)\n-    {\n-      /* Don't interfere with the setting from an 'aggr' prefix.  */\n-      old_looking_for_typename = looking_for_typename;\n-      looking_for_typename = 1;\n-    }\n-  else if (peek == '<')\n-    looking_for_template = 1;\n-  trrr = lookup_name (*idp, -2);\n-  if (trrr)\n-    {\n-      yyc = identifier_type (trrr);\n-      switch(yyc)\n-        {\n-          case tTYPENAME:\n-          case SELFNAME:\n-          case NSNAME:\n-          case PTYPENAME:\n-\t    /* If this got special lookup, remember it.  In these\n-\t       cases, we know it can't be a declarator-id.  */\n-            if (got_scope || got_object)\n-              *idp = trrr;\n-            /* FALLTHROUGH */\n-          case PFUNCNAME:\n-          case IDENTIFIER:\n-            lastiddecl = trrr;\n-            break;\n-          default:\n-            abort ();\n-        }\n-    }\n-  else\n-    lastiddecl = NULL_TREE;\n-  got_scope = NULL_TREE;\n-  looking_for_typename = old_looking_for_typename;\n-  looking_for_template = 0;\n-  return yyc;\n-}\n-\n-/* ID is an operator name. Duplicate the hackery in yylex to determine what\n-   it really is.  */\n-\n-tree frob_opname (id)\n-     tree id;\n-{\n-  scan_tokens (0);\n-  frob_id (0, nth_token (0)->yychar, &id);\n-  got_object = NULL_TREE;\n-  return id;\n-}\n-\n-/* Set up the state required to correctly handle the definition of the\n-   inline function whose preparsed state has been saved in PI.  */\n-\n-static void\n-begin_parsing_inclass_inline (pi)\n-     struct unparsed_text *pi;\n-{\n-  tree context;\n-\n-  /* Record that we are processing the chain of inlines starting at\n-     PI for GC.  */\n-  if (cfun)\n-    cp_function_chain->unparsed_inlines = pi;\n-  else\n-    processing_these_inlines = pi;\n-\n-  ggc_collect ();\n-\n-  /* If this is an inline function in a local class, we must make sure\n-     that we save all pertinent information about the function\n-     surrounding the local class.  */\n-  context = decl_function_context (pi->decl);\n-  if (context)\n-    push_function_context_to (context);\n-\n-  feed_input (pi);\n-  interface_unknown = pi->interface == 1;\n-  interface_only  = pi->interface == 0;\n-  DECL_PENDING_INLINE_P (pi->decl) = 0;\n-  DECL_PENDING_INLINE_INFO (pi->decl) = 0;\n-\n-  /* Pass back a handle to the rest of the inline functions, so that they\n-     can be processed later.  */\n-  yychar = PRE_PARSED_FUNCTION_DECL;\n-  yylval.pi = pi;\n-\n-  start_function (NULL_TREE, pi->decl, NULL_TREE,\n-\t\t  (SF_DEFAULT | SF_PRE_PARSED | SF_INCLASS_INLINE));\n-}\n-\n-/* Called from the top level: if there are any pending inlines to\n-   do, set up to process them now.  This function sets up the first function\n-   to be parsed; after it has been, the rule for fndef in parse.y will\n-   call process_next_inline to start working on the next one.  */\n-\n-void\n-do_pending_inlines ()\n-{\n-  /* Oops, we're still dealing with the last batch.  */\n-  if (yychar == PRE_PARSED_FUNCTION_DECL)\n-    return;\n-\n-  if (pending_inlines)\n-    {\n-      /* Clear the chain, so that any inlines nested inside the batch\n-\t we're to process now don't refer to this batch.  See e.g.\n-\t g++.other/lookup6.C.  */\n-      struct unparsed_text *first = pending_inlines;\n-      pending_inlines = pending_inlines_tail = 0;\n-\n-      begin_parsing_inclass_inline (first);\n-    }\n-}\n-\n-/* Called from the fndecl rule in the parser when the function just parsed\n-   was declared using a PRE_PARSED_FUNCTION_DECL (i.e. came from\n-   do_pending_inlines).  */\n-\n-void\n-process_next_inline (i)\n-     struct unparsed_text *i;\n-{\n-  tree decl = i->decl;\n-  tree context = decl_function_context (decl);\n-\n-  if (context)\n-    pop_function_context_from (context);\n-  if (yychar == YYEMPTY)\n-    yychar = yylex ();\n-  if (yychar != END_OF_SAVED_INPUT)\n-    error (\"parse error at end of saved function text\");\n-  end_input ();\n-\n-  i = i->next;\n-  if (i)\n-    begin_parsing_inclass_inline (i);\n-  else\n-    {\n-      if (cfun)\n-\tcp_function_chain->unparsed_inlines = 0;\n-      else\n-\tprocessing_these_inlines = 0;\n-      extract_interface_info ();\n-    }\n-}\n-\f\n-/* Create a new token at the end of the token list in T.  */\n-static SPEW_INLINE struct token *\n-space_for_token (t)\n-     struct unparsed_text *t;\n-{\n-  if (t->last_pos != TOKEN_CHUNK_SIZE)\n-    return t->last_chunk->toks + (t->last_pos++);\n-\n-  t->last_chunk->next = ggc_alloc_cleared (sizeof (*t->last_chunk->next));\n-  t->last_chunk = t->last_chunk->next;\n-  t->last_chunk->next = NULL;\n-\n-  t->last_pos = 1;\n-  return t->last_chunk->toks;\n-}\n-\n-/* Shrink the token list in T by one token.  */\n-static SPEW_INLINE struct token *\n-remove_last_token (t)\n-     struct unparsed_text *t;\n-{\n-  struct token *result = t->last_chunk->toks + t->last_pos - 1;\n-  if (t->last_pos == 0)\n-    abort ();\n-  t->last_pos--;\n-  if (t->last_pos == 0 && t->last_chunk != t->tokens)\n-    {\n-      struct token_chunk *c;\n-      c = t->tokens;\n-      while (c->next != t->last_chunk)\n-\tc = c->next;\n-      c->next = NULL;\n-      t->last_chunk = c;\n-      t->last_pos = ARRAY_SIZE (c->toks);\n-    }\n-  return result;\n-}\n-\n-/* Allocate an 'unparsed_text' structure, ready to use space_for_token.  */\n-static struct unparsed_text *\n-alloc_unparsed_text (locus, decl, interface)\n-     const location_t *locus;\n-     tree decl;\n-     int interface;\n-{\n-  struct unparsed_text *r;\n-  r = ggc_alloc_cleared (sizeof (*r));\n-  r->decl = decl;\n-  r->locus = *locus;\n-  r->interface = interface;\n-  r->tokens = r->last_chunk = ggc_alloc_cleared (sizeof (*r->tokens));\n-  return r;\n-}\n-\n-/* Accumulate the tokens that make up a parenthesized expression in T,\n-   having already read the opening parenthesis.  */\n-\n-static void\n-snarf_parenthesized_expression (struct unparsed_text *t)\n-{\n-  int yyc;\n-  int level = 1;\n-\n-  while (1)\n-    {\n-      yyc = next_token (space_for_token (t));\n-      if (yyc == '(')\n-\t++level;\n-      else if (yyc == ')' && --level == 0)\n-\tbreak;\n-      else if (yyc == 0)\n-\t{\n-\t  error (\"%Hend of file read inside definition\", &t->locus);\n-\t  break;\n-\t}\n-    }\n-}\n-\n-/* Subroutine of snarf_method, deals with actual absorption of the block.  */\n-\n-static void\n-snarf_block (t)\n-     struct unparsed_text *t;\n-{\n-  int blev = 1;\n-  int look_for_semicolon = 0;\n-  int look_for_lbrac = 0;\n-  int look_for_catch = 0;\n-  int yyc;\n-  struct token *current;\n-\n-  if (yychar == '{')\n-    ;\n-  else if (yychar == '=')\n-    look_for_semicolon = 1;\n-  else if (yychar == ':' || yychar == RETURN_KEYWORD || yychar == TRY)\n-    {\n-      if (yychar == TRY)\n-\tlook_for_catch = 1;\n-      look_for_lbrac = 1;\n-      blev = 0;\n-    }\n-  else\n-    yyerror (\"parse error in method specification\");\n-\n-  /* The current token is the first one to be recorded.  */\n-  current = space_for_token (t);\n-  current->yychar = yychar;\n-  current->yylval = yylval;\n-  current->lineno = lineno;\n-\n-  for (;;)\n-    {\n-      yyc = next_token (space_for_token (t));\n-\n-      if (yyc == '{')\n-\t{\n-\t  look_for_lbrac = 0;\n-\t  blev++;\n-\t}\n-      else if (yyc == '}')\n-\t{\n-\t  blev--;\n-\t  if (blev == 0 && !look_for_semicolon)\n-\t    {\n-\t      if (!look_for_catch)\n-\t\tbreak;\n-\n-\t      if (next_token (space_for_token (t)) != CATCH)\n-\t\t{\n-\t\t  push_token (remove_last_token (t));\n-\t\t  break;\n-\t\t}\n-\n-\t      look_for_lbrac = 1;\n-\t    }\n-\t}\n-      else if (yyc == ';')\n-\t{\n-\t  if (look_for_lbrac)\n-\t    {\n-\t      struct token *fake;\n-\n-\t      error (\"function body for constructor missing\");\n-\t      /* fake a { } to avoid further errors */\n-\t      fake = space_for_token (t);\n-\t      fake->yylval.ttype = 0;\n-\t      fake->yychar = '{';\n-\t      fake = space_for_token (t);\n-\t      fake->yylval.ttype = 0;\n-\t      fake->yychar = '}';\n-\t      break;\n-\t    }\n-\t  else if (look_for_semicolon && blev == 0)\n-\t    break;\n-\t}\n-      else if (yyc == '(' && blev == 0)\n-\tsnarf_parenthesized_expression (t);\n-      else if (yyc == 0)\n-\t{\n-\t  error (\"%Hend of file read inside definition\", &t->locus);\n-\t  break;\n-\t}\n-    }\n-}\n-\n-/* This function stores away the text for an inline function that should\n-   be processed later (by do_pending_inlines).  */\n-void\n-snarf_method (decl)\n-     tree decl;\n-{\n-  struct unparsed_text *meth;\n-  location_t starting;\n-  starting.file = input_filename;\n-  starting.line = lineno;\n-\n-  meth = alloc_unparsed_text (&starting, decl, (interface_unknown ? 1\n-\t\t\t\t\t\t: (interface_only ? 0 : 2)));\n-\n-  snarf_block (meth);\n-  /* Add three END_OF_SAVED_INPUT tokens.  We used to provide an\n-     infinite stream of END_OF_SAVED_INPUT tokens -- but that can\n-     cause the compiler to get stuck in an infinite loop when\n-     encountering invalid code.  We need more than one because the\n-     parser sometimes peeks ahead several tokens.  */\n-  memcpy (space_for_token (meth), &Teosi, sizeof (struct token));\n-  memcpy (space_for_token (meth), &Teosi, sizeof (struct token));\n-  memcpy (space_for_token (meth), &Teosi, sizeof (struct token));\n-\n-  /* Happens when we get two declarations of the same function in the\n-     same scope.  */\n-  if (decl == void_type_node\n-      || (current_class_type && TYPE_REDEFINED (current_class_type)))\n-    return;\n-\n-#ifdef SPEW_DEBUG\n-  if (spew_debug)\n-    fprintf (stderr, \"\\tsaved method of %d tokens from %s:%d\\n\",\n-\t     meth->last_pos, starting.file, starting.line);\n-#endif\n-\n-  DECL_PENDING_INLINE_INFO (decl) = meth;\n-  DECL_PENDING_INLINE_P (decl) = 1;\n-\n-  if (pending_inlines_tail)\n-    pending_inlines_tail->next = meth;\n-  else\n-    pending_inlines = meth;\n-  pending_inlines_tail = meth;\n-}\n-\n-/* Consume a no-commas expression - a default argument - and return\n-   a DEFAULT_ARG tree node.  */\n-\n-static tree\n-snarf_defarg ()\n-{\n-  int yyc;\n-  int plev = 0;\n-  struct unparsed_text *buf;\n-  tree arg;\n-  location_t starting;\n-  starting.file = input_filename;\n-  starting.line = lineno;\n-\n-  buf = alloc_unparsed_text (&starting, 0, 0);\n-\n-  for (;;)\n-    {\n-      yyc = next_token (space_for_token (buf));\n-\n-      if (plev <= 0 && (yyc == ')' || yyc == ','))\n-\tbreak;\n-      else if (yyc == '(' || yyc == '[')\n-\t++plev;\n-      else if (yyc == ']' || yyc == ')')\n-\t--plev;\n-      else if (yyc == 0)\n-\t{\n-\t  error (\"%Hend of file read inside default argument\", &starting);\n-\t  goto done;\n-\t}\n-    }\n-\n-  /* Unget the last token.  */\n-  push_token (remove_last_token (buf));\n-  /* Add three END_OF_SAVED_INPUT tokens.  We used to provide an\n-     infinite stream of END_OF_SAVED_INPUT tokens -- but that can\n-     cause the compiler to get stuck in an infinite loop when\n-     encountering invalid code.  We need more than one because the\n-     parser sometimes peeks ahead several tokens.  */\n-  memcpy (space_for_token (buf), &Teosi, sizeof (struct token));\n-  memcpy (space_for_token (buf), &Teosi, sizeof (struct token));\n-  memcpy (space_for_token (buf), &Teosi, sizeof (struct token));\n-\n- done:\n-#ifdef SPEW_DEBUG\n-  if (spew_debug)\n-    fprintf (stderr, \"\\tsaved defarg of %d tokens from %s:%d\\n\",\n-\t     buf->last_pos, starting.file, starting.line);\n-#endif\n-\n-  arg = make_node (DEFAULT_ARG);\n-  DEFARG_POINTER (arg) = (char *)buf;\n-\n-  return arg;\n-}\n-\n-/* Decide whether the default argument we are about to see should be\n-   gobbled up as text for later parsing.  */\n-\n-void\n-maybe_snarf_defarg ()\n-{\n-  if (current_class_type && TYPE_BEING_DEFINED (current_class_type))\n-    do_snarf_defarg = 1;\n-}\n-\n-/* Called from grokfndecl to note a function decl with unparsed default\n-   arguments for later processing.  Also called from grokdeclarator\n-   for function types with unparsed defargs; the call from grokfndecl\n-   will always come second, so we can overwrite the entry from the type.  */\n-\n-void\n-add_defarg_fn (decl)\n-     tree decl;\n-{\n-  if (TREE_CODE (decl) == FUNCTION_DECL)\n-    TREE_VALUE (defarg_fns) = decl;\n-  else\n-    {\n-      defarg_fns = tree_cons (NULL_TREE, decl, defarg_fns);\n-      TREE_TYPE (defarg_fns) = current_class_type;\n-    }\n-}\n-\n-/* Helper for do_pending_defargs.  Starts the parsing of a default arg.  */\n-\n-static void\n-feed_defarg (p)\n-     tree p;\n-{\n-  tree d = TREE_PURPOSE (p);\n-\n-  feed_input ((struct unparsed_text *)DEFARG_POINTER (d));\n-  yychar = DEFARG_MARKER;\n-  yylval.ttype = p;\n-}\n-\n-/* Helper for do_pending_defargs.  Ends the parsing of a default arg.  */\n-\n-static void\n-finish_defarg ()\n-{\n-  if (yychar == YYEMPTY)\n-    yychar = yylex ();\n-  if (yychar != END_OF_SAVED_INPUT)\n-    error (\"parse error at end of saved function text\");\n-\n-  end_input ();\n-}\n-\n-/* Main function for deferred parsing of default arguments.  Called from\n-   the parser.  */\n-\n-void\n-do_pending_defargs ()\n-{\n-  if (defarg_parm)\n-    finish_defarg ();\n-\n-  for (; defarg_fns;)\n-    {\n-      tree current = defarg_fns;\n-\n-      tree defarg_fn = TREE_VALUE (defarg_fns);\n-      if (defarg_parm == NULL_TREE)\n-\t{\n-\t  push_nested_class (TREE_TYPE (defarg_fns), 1);\n-\t  pushlevel (0);\n-\t  if (TREE_CODE (defarg_fn) == FUNCTION_DECL)\n-\t    maybe_begin_member_template_processing (defarg_fn);\n-\n-\t  if (TREE_CODE (defarg_fn) == FUNCTION_DECL)\n-\t    defarg_parm = TYPE_ARG_TYPES (TREE_TYPE (defarg_fn));\n-\t  else\n-\t    defarg_parm = TYPE_ARG_TYPES (defarg_fn);\n-\t}\n-      else\n-\tdefarg_parm = TREE_CHAIN (defarg_parm);\n-\n-      for (; defarg_parm; defarg_parm = TREE_CHAIN (defarg_parm))\n-\tif (!TREE_PURPOSE (defarg_parm)\n-\t    || TREE_CODE (TREE_PURPOSE (defarg_parm)) != DEFAULT_ARG)\n-\t  ;/* OK */\n-\telse if (TREE_PURPOSE (current) == error_mark_node)\n-\t  DEFARG_POINTER (TREE_PURPOSE (defarg_parm)) = NULL;\n-\telse\n-\t  {\n-\t    feed_defarg (defarg_parm);\n-\n-\t    /* Return to the parser, which will process this defarg\n-\t       and call us again.  */\n-\t    return;\n-\t  }\n-\n-      if (TREE_CODE (defarg_fn) == FUNCTION_DECL)\n-\t{\n-\t  maybe_end_member_template_processing ();\n-\t  check_default_args (defarg_fn);\n-\t}\n-\n-      poplevel (0, 0, 0);\n-      pop_nested_class ();\n-\n-      defarg_fns = TREE_CHAIN (defarg_fns);\n-      if (defarg_depfns)\n-        {\n-          /* This function's default args depend on unprocessed default args\n-             of defarg_fns. We will need to reprocess this function, and\n-             check for circular dependencies.  */\n-          tree a, b;\n-\n-          for (a = defarg_depfns, b = TREE_PURPOSE (current); a && b;\n-               a = TREE_CHAIN (a), b = TREE_CHAIN (b))\n-            if (TREE_VALUE (a) != TREE_VALUE (b))\n-              goto different;\n-          if (a || b)\n-            {\n-            different:;\n-              TREE_CHAIN (current) = NULL_TREE;\n-              defarg_fns = chainon (defarg_fns, current);\n-              TREE_PURPOSE (current) = defarg_depfns;\n-            }\n-          else\n-            {\n-              cp_warning_at (\"circular dependency in default args of `%#D'\", defarg_fn);\n-              /* No need to say what else is dependent, as they will be\n-                 picked up in another pass.  */\n-\n-              /* Immediately repeat, but marked so that we break the loop.  */\n-              defarg_fns = current;\n-              TREE_PURPOSE (current) = error_mark_node;\n-            }\n-          defarg_depfns = NULL_TREE;\n-        }\n-      else if (TREE_PURPOSE (current) == error_mark_node)\n-        defarg_fnsdone = tree_cons (NULL_TREE, defarg_fn, defarg_fnsdone);\n-    }\n-}\n-\n-/* After parsing all the default arguments, we must clear any that remain,\n-   which will be part of a circular dependency.  */\n-void\n-done_pending_defargs ()\n-{\n-  for (; defarg_fnsdone; defarg_fnsdone = TREE_CHAIN (defarg_fnsdone))\n-    {\n-      tree fn = TREE_VALUE (defarg_fnsdone);\n-      tree parms;\n-\n-      if (TREE_CODE (fn) == FUNCTION_DECL)\n-        parms = TYPE_ARG_TYPES (TREE_TYPE (fn));\n-      else\n-        parms = TYPE_ARG_TYPES (fn);\n-      for (; parms; parms = TREE_CHAIN (parms))\n-\tif (TREE_PURPOSE (parms)\n-\t    && TREE_CODE (TREE_PURPOSE (parms)) == DEFAULT_ARG)\n-\t  {\n-            my_friendly_assert (!DEFARG_POINTER (TREE_PURPOSE (parms)), 20010107);\n-\t    TREE_PURPOSE (parms) = NULL_TREE;\n-\t  }\n-    }\n-}\n-\n-/* In processing the current default arg, we called FN, but that call\n-   required a default argument of FN, and that had not yet been processed.\n-   Remember FN.  */\n-\n-void\n-unprocessed_defarg_fn (fn)\n-     tree fn;\n-{\n-  defarg_depfns = tree_cons (NULL_TREE, fn, defarg_depfns);\n-}\n-\n-/* Called from the parser to update an element of TYPE_ARG_TYPES for some\n-   FUNCTION_TYPE with the newly parsed version of its default argument, which\n-   was previously digested as text.  */\n-\n-void\n-replace_defarg (arg, init)\n-     tree arg, init;\n-{\n-  if (init == error_mark_node)\n-    TREE_PURPOSE (arg) = error_mark_node;\n-  else\n-    {\n-      if (! processing_template_decl\n-          && ! can_convert_arg (TREE_VALUE (arg), TREE_TYPE (init), init))\n-        pedwarn (\"invalid type `%T' for default argument to `%T'\",\n-  \t    \t    TREE_TYPE (init), TREE_VALUE (arg));\n-      if (!defarg_depfns)\n-        TREE_PURPOSE (arg) = init;\n-    }\n-}\n-\n-#ifdef SPEW_DEBUG\n-/* debug_yychar takes a yychar (token number) value and prints its name.  */\n-\n-static void\n-debug_yychar (yy)\n-     int yy;\n-{\n-  if (yy<256)\n-    fprintf (stderr, \"->%d < %c >\\n\", lineno, yy);\n-  else if (yy == IDENTIFIER || yy == tTYPENAME)\n-    {\n-      const char *id;\n-      if (TREE_CODE (yylval.ttype) == IDENTIFIER_NODE)\n-\tid = IDENTIFIER_POINTER (yylval.ttype);\n-      else if (TREE_CODE_CLASS (TREE_CODE (yylval.ttype)) == 'd')\n-\tid = IDENTIFIER_POINTER (DECL_NAME (yylval.ttype));\n-      else\n-\tid = \"\";\n-      fprintf (stderr, \"->%d <%s `%s'>\\n\", lineno, debug_yytranslate (yy), id);\n-    }\n-  else\n-    fprintf (stderr, \"->%d <%s>\\n\", lineno, debug_yytranslate (yy));\n-}\n-\n-#endif\n-\n-#define NAME(TYPE) cpp_type2name (TYPE)\n-\n-void\n-yyerror (msgid)\n-     const char *msgid;\n-{\n-  const char *string = _(msgid);\n-\n-  if (last_token == CPP_EOF)\n-    error (\"%s at end of input\", string);\n-  else if (last_token == CPP_CHAR || last_token == CPP_WCHAR)\n-    {\n-      unsigned int val = TREE_INT_CST_LOW (yylval.ttype);\n-      const char *const ell = (last_token == CPP_CHAR) ? \"\" : \"L\";\n-      if (val <= UCHAR_MAX && ISGRAPH (val))\n-\terror (\"%s before %s'%c'\", string, ell, val);\n-      else\n-\terror (\"%s before %s'\\\\x%x'\", string, ell, val);\n-    }\n-  else if (last_token == CPP_STRING\n-\t   || last_token == CPP_WSTRING)\n-    error (\"%s before string constant\", string);\n-  else if (last_token == CPP_NUMBER)\n-    error (\"%s before numeric constant\", string);\n-  else if (last_token == CPP_NAME)\n-    {\n-      if (TREE_CODE (last_token_id) == IDENTIFIER_NODE)\n-        error (\"%s before `%s'\", string, IDENTIFIER_POINTER (last_token_id));\n-      else if (ISGRAPH (yychar))\n-        error (\"%s before `%c'\", string, yychar);\n-      else\n-\terror (\"%s before `\\%o'\", string, yychar);\n-    }\n-  else\n-    error (\"%s before `%s' token\", string, NAME (last_token));\n-}\n-\n-#include \"gt-cp-spew.h\""}]}