{"sha": "3837bc7f8694ca43b734a327e3e37030371eeeea", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzgzN2JjN2Y4Njk0Y2E0M2I3MzRhMzI3ZTNlMzcwMzAzNzFlZWVlYQ==", "commit": {"author": {"name": "Matt Heaney", "email": "heaney@adacore.com", "date": "2006-10-31T18:13:22Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2006-10-31T18:13:22Z"}, "message": "a-crbtgo.ads: Commented each subprogram\n\n2006-10-31  Matt Heaney  <heaney@adacore.com>\n\n\t* a-crbtgo.ads: Commented each subprogram\n\n\t* a-crbtgo.adb: Added reference to book from which algorithms were\n\tadapted.\n\n        * a-crbtgk.ads, a-crbtgk.adb (Generic_Insert_Post): pass flag to\n\tindicate which child.\n\t(Generic_Conditional_Insert): changed parameter name from \"Success\" to\n\t\"Inserted\".\n\t(Generic_Unconditional_Insert_With_Hint): improved algorithm\n\n\t* a-coorse.adb (Replace_Element): changed parameter name in call to\n\tconditional insert operation.\n\n\t* a-convec.adb, a-coinve.adb (Insert): removed obsolete comment\n\n\t* a-cohama.adb (Iterate): manipulate busy-bit here, instead of in\n\tGeneric_Iteration\n\n\t* a-ciorse.adb (Replace_Element): changed parameter name in call to\n\tconditional insert operation.\n\n\t* a-cihama.adb (Iterate): manipulate busy-bit here, instead of in\n\tGeneric_Iteration.\n\n\t* a-cidlli.ads, a-cidlli.adb (Splice): Position param is now mode in\n\tinstead of mode inout.\n\n\t* a-chtgop.adb (Adjust): modified comments to reflect current AI-302\n\tdraft\n\t(Generic_Read): preserve existing buckets array if possible\n\t(Generic_Write): don't send buckets array length anymore\n\n\t* a-cdlili.ads, a-cdlili.adb (Splice): Position param is now mode in\n\tinstead of mode inout.\n\n\t* a-cihase.adb (Difference): iterate over smaller of Tgt and Src sets\n\t(Iterate): manipulate busy-bit here, instead of in Generic_Iteration\n\n\t* a-cohase.adb (Difference): iterate over smaller of Tgt and Src sets\n\t(Iterate): manipulate busy-bit here, instead of in Generic_Iteration\n\t(Replace_Element): local operation is now an instantiation\n\n\t* a-chtgke.ads, a-chtgke.adb (Generic_Conditional_Insert): manually\n\tcheck current length.\n\t(Generic_Replace_Element): new operation\n\nFrom-SVN: r118324", "tree": {"sha": "1a5cb845f084a8360d6f2bc2dd674427a1a51b02", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1a5cb845f084a8360d6f2bc2dd674427a1a51b02"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3837bc7f8694ca43b734a327e3e37030371eeeea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3837bc7f8694ca43b734a327e3e37030371eeeea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3837bc7f8694ca43b734a327e3e37030371eeeea", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3837bc7f8694ca43b734a327e3e37030371eeeea/comments", "author": null, "committer": null, "parents": [{"sha": "31a33125871e198b6a7e48310b919fb9c65c4fca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31a33125871e198b6a7e48310b919fb9c65c4fca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/31a33125871e198b6a7e48310b919fb9c65c4fca"}], "stats": {"total": 2261, "additions": 1098, "deletions": 1163}, "files": [{"sha": "611bfb09b5d5a42271ec054b9457f1ab9585411f", "filename": "gcc/ada/a-cdlili.adb", "status": "modified", "additions": 134, "deletions": 111, "changes": 245, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3837bc7f8694ca43b734a327e3e37030371eeeea/gcc%2Fada%2Fa-cdlili.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3837bc7f8694ca43b734a327e3e37030371eeeea/gcc%2Fada%2Fa-cdlili.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cdlili.adb?ref=3837bc7f8694ca43b734a327e3e37030371eeeea", "patch": "@@ -8,10 +8,6 @@\n --                                                                          --\n --          Copyright (C) 2004-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n--- This specification is derived from the Ada Reference Manual for use with --\n--- GNAT. The copyright notice above, and the license provisions that follow --\n--- apply solely to the  contents of the part following the private keyword. --\n---                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n -- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n@@ -156,7 +152,8 @@ package body Ada.Containers.Doubly_Linked_Lists is\n       pragma Assert (Container.Last.Next = null);\n \n       if Container.Busy > 0 then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"attempt to tamper with elements (list is busy)\";\n       end if;\n \n       while Container.Length > 1 loop\n@@ -206,11 +203,13 @@ package body Ada.Containers.Doubly_Linked_Lists is\n \n    begin\n       if Position.Node = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with\n+           \"Position cursor has no element\";\n       end if;\n \n       if Position.Container /= Container'Unrestricted_Access then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"Position cursor designates wrong container\";\n       end if;\n \n       pragma Assert (Vet (Position), \"bad cursor in Delete\");\n@@ -227,7 +226,8 @@ package body Ada.Containers.Doubly_Linked_Lists is\n       end if;\n \n       if Container.Busy > 0 then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"attempt to tamper with elements (list is busy)\";\n       end if;\n \n       for Index in 1 .. Count loop\n@@ -276,7 +276,8 @@ package body Ada.Containers.Doubly_Linked_Lists is\n       end if;\n \n       if Container.Busy > 0 then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"attempt to tamper with elements (list is busy)\";\n       end if;\n \n       for I in 1 .. Count loop\n@@ -313,7 +314,8 @@ package body Ada.Containers.Doubly_Linked_Lists is\n       end if;\n \n       if Container.Busy > 0 then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"attempt to tamper with elements (list is busy)\";\n       end if;\n \n       for I in 1 .. Count loop\n@@ -336,7 +338,8 @@ package body Ada.Containers.Doubly_Linked_Lists is\n    function Element (Position : Cursor) return Element_Type is\n    begin\n       if Position.Node = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with\n+           \"Position cursor has no element\";\n       end if;\n \n       pragma Assert (Vet (Position), \"bad cursor in Element\");\n@@ -361,7 +364,8 @@ package body Ada.Containers.Doubly_Linked_Lists is\n \n       else\n          if Position.Container /= Container'Unrestricted_Access then\n-            raise Program_Error;\n+            raise Program_Error with\n+              \"Position cursor designates wrong container\";\n          end if;\n \n          pragma Assert (Vet (Position), \"bad cursor in Find\");\n@@ -398,7 +402,7 @@ package body Ada.Containers.Doubly_Linked_Lists is\n    function First_Element (Container : List) return Element_Type is\n    begin\n       if Container.First = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"list is empty\";\n       end if;\n \n       return Container.First.Element;\n@@ -451,20 +455,25 @@ package body Ada.Containers.Doubly_Linked_Lists is\n         (Target : in out List;\n          Source : in out List)\n       is\n-         LI : Cursor := First (Target);\n-         RI : Cursor := First (Source);\n+         LI, RI : Cursor;\n \n       begin\n          if Target'Address = Source'Address then\n             return;\n          end if;\n \n-         if Target.Busy > 0\n-           or else Source.Busy > 0\n-         then\n-            raise Program_Error;\n+         if Target.Busy > 0 then\n+            raise Program_Error with\n+              \"attempt to tamper with elements of Target (list is busy)\";\n+         end if;\n+\n+         if Source.Busy > 0 then\n+            raise Program_Error with\n+              \"attempt to tamper with elements of Source (list is busy)\";\n          end if;\n \n+         LI := First (Target);\n+         RI := First (Source);\n          while RI.Node /= null loop\n             pragma Assert (RI.Node.Next = null\n                              or else not (RI.Node.Next.Element <\n@@ -578,7 +587,8 @@ package body Ada.Containers.Doubly_Linked_Lists is\n          pragma Assert (Container.Last.Next = null);\n \n          if Container.Busy > 0 then\n-            raise Program_Error;\n+            raise Program_Error with\n+              \"attempt to tamper with elements (list is busy)\";\n          end if;\n \n          Sort (Front => null, Back => null);\n@@ -615,7 +625,8 @@ package body Ada.Containers.Doubly_Linked_Lists is\n    begin\n       if Before.Container /= null then\n          if Before.Container /= Container'Unrestricted_Access then\n-            raise Program_Error;\n+            raise Program_Error with\n+              \"attempt to tamper with elements (list is busy)\";\n          end if;\n \n          pragma Assert (Vet (Before), \"bad cursor in Insert\");\n@@ -627,11 +638,12 @@ package body Ada.Containers.Doubly_Linked_Lists is\n       end if;\n \n       if Container.Length > Count_Type'Last - Count then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"new length exceeds maximum\";\n       end if;\n \n       if Container.Busy > 0 then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"attempt to tamper with elements (list is busy)\";\n       end if;\n \n       New_Node := new Node_Type'(New_Item, null, null);\n@@ -667,7 +679,8 @@ package body Ada.Containers.Doubly_Linked_Lists is\n    begin\n       if Before.Container /= null then\n          if Before.Container /= Container'Unrestricted_Access then\n-            raise Program_Error;\n+            raise Program_Error with\n+              \"Before cursor designates wrong list\";\n          end if;\n \n          pragma Assert (Vet (Before), \"bad cursor in Insert\");\n@@ -679,11 +692,12 @@ package body Ada.Containers.Doubly_Linked_Lists is\n       end if;\n \n       if Container.Length > Count_Type'Last - Count then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"new length exceeds maximum\";\n       end if;\n \n       if Container.Busy > 0 then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"attempt to tamper with elements (list is busy)\";\n       end if;\n \n       New_Node := new Node_Type;\n@@ -804,7 +818,7 @@ package body Ada.Containers.Doubly_Linked_Lists is\n    function Last_Element (Container : List) return Element_Type is\n    begin\n       if Container.Last = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"list is empty\";\n       end if;\n \n       return Container.Last.Element;\n@@ -833,7 +847,8 @@ package body Ada.Containers.Doubly_Linked_Lists is\n       end if;\n \n       if Source.Busy > 0 then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"attempt to tamper with elements of Source (list is busy)\";\n       end if;\n \n       Clear (Target);\n@@ -854,27 +869,17 @@ package body Ada.Containers.Doubly_Linked_Lists is\n \n    procedure Next (Position : in out Cursor) is\n    begin\n-      pragma Assert (Vet (Position), \"bad cursor in procedure Next\");\n-\n-      if Position.Node = null then\n-         return;\n-      end if;\n-\n-      Position.Node := Position.Node.Next;\n-\n-      if Position.Node = null then\n-         Position.Container := null;\n-      end if;\n+      Position := Next (Position);\n    end Next;\n \n    function Next (Position : Cursor) return Cursor is\n    begin\n-      pragma Assert (Vet (Position), \"bad cursor in function Next\");\n-\n       if Position.Node = null then\n          return No_Element;\n       end if;\n \n+      pragma Assert (Vet (Position), \"bad cursor in Next\");\n+\n       declare\n          Next_Node : constant Node_Access := Position.Node.Next;\n       begin\n@@ -905,27 +910,17 @@ package body Ada.Containers.Doubly_Linked_Lists is\n \n    procedure Previous (Position : in out Cursor) is\n    begin\n-      pragma Assert (Vet (Position), \"bad cursor in procedure Previous\");\n-\n-      if Position.Node = null then\n-         return;\n-      end if;\n-\n-      Position.Node := Position.Node.Prev;\n-\n-      if Position.Node = null then\n-         Position.Container := null;\n-      end if;\n+      Position := Previous (Position);\n    end Previous;\n \n    function Previous (Position : Cursor) return Cursor is\n    begin\n-      pragma Assert (Vet (Position), \"bad cursor in function Previous\");\n-\n       if Position.Node = null then\n          return No_Element;\n       end if;\n \n+      pragma Assert (Vet (Position), \"bad cursor in Previous\");\n+\n       declare\n          Prev_Node : constant Node_Access := Position.Node.Prev;\n       begin\n@@ -947,7 +942,8 @@ package body Ada.Containers.Doubly_Linked_Lists is\n    is\n    begin\n       if Position.Node = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with\n+           \"Position cursor has no element\";\n       end if;\n \n       pragma Assert (Vet (Position), \"bad cursor in Query_Element\");\n@@ -980,7 +976,7 @@ package body Ada.Containers.Doubly_Linked_Lists is\n    ----------\n \n    procedure Read\n-     (Stream : access Root_Stream_Type'Class;\n+     (Stream : not null access Root_Stream_Type'Class;\n       Item   : out List)\n    is\n       N : Count_Type'Base;\n@@ -1028,11 +1024,11 @@ package body Ada.Containers.Doubly_Linked_Lists is\n    end Read;\n \n    procedure Read\n-     (Stream : access Root_Stream_Type'Class;\n+     (Stream : not null access Root_Stream_Type'Class;\n       Item   : out Cursor)\n    is\n    begin\n-      raise Program_Error;\n+      raise Program_Error with \"attempt to stream list cursor\";\n    end Read;\n \n    ---------------------\n@@ -1046,15 +1042,17 @@ package body Ada.Containers.Doubly_Linked_Lists is\n    is\n    begin\n       if Position.Container = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n \n       if Position.Container /= Container'Unchecked_Access then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"Position cursor designates wrong container\";\n       end if;\n \n       if Container.Lock > 0 then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"attempt to tamper with cursors (list is locked)\";\n       end if;\n \n       pragma Assert (Vet (Position), \"bad cursor in Replace_Element\");\n@@ -1121,7 +1119,8 @@ package body Ada.Containers.Doubly_Linked_Lists is\n       pragma Assert (Container.Last.Next = null);\n \n       if Container.Busy > 0 then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"attempt to tamper with elements (list is busy)\";\n       end if;\n \n       Container.First := J;\n@@ -1165,7 +1164,8 @@ package body Ada.Containers.Doubly_Linked_Lists is\n \n       else\n          if Position.Container /= Container'Unrestricted_Access then\n-            raise Program_Error;\n+            raise Program_Error with\n+              \"Position cursor designates wrong container\";\n          end if;\n \n          pragma Assert (Vet (Position), \"bad cursor in Reverse_Find\");\n@@ -1225,7 +1225,8 @@ package body Ada.Containers.Doubly_Linked_Lists is\n    begin\n       if Before.Container /= null then\n          if Before.Container /= Target'Unrestricted_Access then\n-            raise Program_Error;\n+            raise Program_Error with\n+              \"Before cursor designates wrong container\";\n          end if;\n \n          pragma Assert (Vet (Before), \"bad cursor in Splice\");\n@@ -1241,13 +1242,17 @@ package body Ada.Containers.Doubly_Linked_Lists is\n       pragma Assert (Source.Last.Next = null);\n \n       if Target.Length > Count_Type'Last - Source.Length then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"new length exceeds maximum\";\n       end if;\n \n-      if Target.Busy > 0\n-        or else Source.Busy > 0\n-      then\n-         raise Program_Error;\n+      if Target.Busy > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with elements of Target (list is busy)\";\n+      end if;\n+\n+      if Source.Busy > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with elements of Source (list is busy)\";\n       end if;\n \n       if Target.Length = 0 then\n@@ -1294,23 +1299,25 @@ package body Ada.Containers.Doubly_Linked_Lists is\n    procedure Splice\n      (Container : in out List;\n       Before    : Cursor;\n-      Position  : in out Cursor)\n+      Position  : Cursor)\n    is\n    begin\n       if Before.Container /= null then\n          if Before.Container /= Container'Unchecked_Access then\n-            raise Program_Error;\n+            raise Program_Error with\n+              \"Before cursor designates wrong container\";\n          end if;\n \n          pragma Assert (Vet (Before), \"bad Before cursor in Splice\");\n       end if;\n \n       if Position.Node = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n \n       if Position.Container /= Container'Unrestricted_Access then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"Position cursor designates wrong container\";\n       end if;\n \n       pragma Assert (Vet (Position), \"bad Position cursor in Splice\");\n@@ -1324,7 +1331,8 @@ package body Ada.Containers.Doubly_Linked_Lists is\n       pragma Assert (Container.Length >= 2);\n \n       if Container.Busy > 0 then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"attempt to tamper with elements (list is busy)\";\n       end if;\n \n       if Before.Node = null then\n@@ -1404,30 +1412,36 @@ package body Ada.Containers.Doubly_Linked_Lists is\n \n       if Before.Container /= null then\n          if Before.Container /= Target'Unrestricted_Access then\n-            raise Program_Error;\n+            raise Program_Error with\n+              \"Before cursor designates wrong container\";\n          end if;\n \n          pragma Assert (Vet (Before), \"bad Before cursor in Splice\");\n       end if;\n \n       if Position.Node = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n \n       if Position.Container /= Source'Unrestricted_Access then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"Position cursor designates wrong container\";\n       end if;\n \n       pragma Assert (Vet (Position), \"bad Position cursor in Splice\");\n \n       if Target.Length = Count_Type'Last then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"Target is full\";\n       end if;\n \n-      if Target.Busy > 0\n-        or else Source.Busy > 0\n-      then\n-         raise Program_Error;\n+      if Target.Busy > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with elements of Target (list is busy)\";\n+      end if;\n+\n+      if Source.Busy > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with elements of Source (list is busy)\";\n       end if;\n \n       if Position.Node = Source.First then\n@@ -1504,24 +1518,29 @@ package body Ada.Containers.Doubly_Linked_Lists is\n       I, J      : Cursor)\n    is\n    begin\n-      if I.Node = null\n-        or else J.Node = null\n-      then\n-         raise Constraint_Error;\n+      if I.Node = null then\n+         raise Constraint_Error with \"I cursor has no element\";\n       end if;\n \n-      if I.Container /= Container'Unchecked_Access\n-        or else J.Container /= Container'Unchecked_Access\n-      then\n-         raise Program_Error;\n+      if J.Node = null then\n+         raise Constraint_Error with \"J cursor has no element\";\n+      end if;\n+\n+      if I.Container /= Container'Unchecked_Access then\n+         raise Program_Error with \"I cursor designates wrong container\";\n+      end if;\n+\n+      if J.Container /= Container'Unchecked_Access then\n+         raise Program_Error with \"J cursor designates wrong container\";\n       end if;\n \n       if I.Node = J.Node then\n          return;\n       end if;\n \n       if Container.Lock > 0 then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"attempt to tamper with cursors (list is locked)\";\n       end if;\n \n       pragma Assert (Vet (I), \"bad I cursor in Swap\");\n@@ -1548,51 +1567,54 @@ package body Ada.Containers.Doubly_Linked_Lists is\n       I, J      : Cursor)\n    is\n    begin\n-      if I.Node = null\n-        or else J.Node = null\n-      then\n-         raise Constraint_Error;\n+      if I.Node = null then\n+         raise Constraint_Error with \"I cursor has no element\";\n       end if;\n \n-      if I.Container /= Container'Unrestricted_Access\n-        or else I.Container /= J.Container\n-      then\n-         raise Program_Error;\n+      if J.Node = null then\n+         raise Constraint_Error with \"J cursor has no element\";\n+      end if;\n+\n+      if I.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with \"I cursor designates wrong container\";\n+      end if;\n+\n+      if J.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with \"J cursor designates wrong container\";\n       end if;\n \n       if I.Node = J.Node then\n          return;\n       end if;\n \n       if Container.Busy > 0 then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"attempt to tamper with elements (list is busy)\";\n       end if;\n \n       pragma Assert (Vet (I), \"bad I cursor in Swap_Links\");\n       pragma Assert (Vet (J), \"bad J cursor in Swap_Links\");\n \n       declare\n          I_Next : constant Cursor := Next (I);\n-         J_Copy : Cursor := J;\n \n       begin\n          if I_Next = J then\n-            Splice (Container, Before => I, Position => J_Copy);\n+            Splice (Container, Before => I, Position => J);\n \n          else\n             declare\n                J_Next : constant Cursor := Next (J);\n-               I_Copy : Cursor := I;\n \n             begin\n                if J_Next = I then\n-                  Splice (Container, Before => J, Position => I_Copy);\n+                  Splice (Container, Before => J, Position => I);\n \n                else\n                   pragma Assert (Container.Length >= 3);\n \n-                  Splice (Container, Before => I_Next, Position => J_Copy);\n-                  Splice (Container, Before => J_Next, Position => I_Copy);\n+                  Splice (Container, Before => I_Next, Position => J);\n+                  Splice (Container, Before => J_Next, Position => I);\n                end if;\n             end;\n          end if;\n@@ -1610,11 +1632,12 @@ package body Ada.Containers.Doubly_Linked_Lists is\n    is\n    begin\n       if Position.Node = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n \n       if Position.Container /= Container'Unchecked_Access then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"Position cursor designates wrong container\";\n       end if;\n \n       pragma Assert (Vet (Position), \"bad cursor in Update_Element\");\n@@ -1785,7 +1808,7 @@ package body Ada.Containers.Doubly_Linked_Lists is\n    -----------\n \n    procedure Write\n-     (Stream : access Root_Stream_Type'Class;\n+     (Stream : not null access Root_Stream_Type'Class;\n       Item   : List)\n    is\n       Node : Node_Access := Item.First;\n@@ -1800,11 +1823,11 @@ package body Ada.Containers.Doubly_Linked_Lists is\n    end Write;\n \n    procedure Write\n-     (Stream : access Root_Stream_Type'Class;\n+     (Stream : not null access Root_Stream_Type'Class;\n       Item   : Cursor)\n    is\n    begin\n-      raise Program_Error;\n+      raise Program_Error with \"attempt to stream list cursor\";\n    end Write;\n \n end Ada.Containers.Doubly_Linked_Lists;"}, {"sha": "c5d81f78532dc51c2f7df1fcb318157397f77f0a", "filename": "gcc/ada/a-cdlili.ads", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3837bc7f8694ca43b734a327e3e37030371eeeea/gcc%2Fada%2Fa-cdlili.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3837bc7f8694ca43b734a327e3e37030371eeeea/gcc%2Fada%2Fa-cdlili.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cdlili.ads?ref=3837bc7f8694ca43b734a327e3e37030371eeeea", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2004-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -46,8 +46,10 @@ package Ada.Containers.Doubly_Linked_Lists is\n    pragma Preelaborate;\n \n    type List is tagged private;\n+   pragma Preelaborable_Initialization (List);\n \n    type Cursor is private;\n+   pragma Preelaborable_Initialization (Cursor);\n \n    Empty_List : constant List;\n \n@@ -147,7 +149,7 @@ package Ada.Containers.Doubly_Linked_Lists is\n    procedure Splice\n      (Container : in out List;\n       Before    : Cursor;\n-      Position  : in out Cursor);\n+      Position  : Cursor);\n \n    function First (Container : List) return Cursor;\n \n@@ -230,13 +232,13 @@ private\n    use Ada.Streams;\n \n    procedure Read\n-     (Stream : access Root_Stream_Type'Class;\n+     (Stream : not null access Root_Stream_Type'Class;\n       Item   : out List);\n \n    for List'Read use Read;\n \n    procedure Write\n-     (Stream : access Root_Stream_Type'Class;\n+     (Stream : not null access Root_Stream_Type'Class;\n       Item   : List);\n \n    for List'Write use Write;\n@@ -253,13 +255,13 @@ private\n       end record;\n \n    procedure Read\n-     (Stream : access Root_Stream_Type'Class;\n+     (Stream : not null access Root_Stream_Type'Class;\n       Item   : out Cursor);\n \n    for Cursor'Read use Read;\n \n    procedure Write\n-     (Stream : access Root_Stream_Type'Class;\n+     (Stream : not null access Root_Stream_Type'Class;\n       Item   : Cursor);\n \n    for Cursor'Write use Write;"}, {"sha": "ba6ae2376f4e3de6c0cf933c6aa456107ac4b19c", "filename": "gcc/ada/a-chtgke.adb", "status": "modified", "additions": 104, "deletions": 23, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3837bc7f8694ca43b734a327e3e37030371eeeea/gcc%2Fada%2Fa-chtgke.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3837bc7f8694ca43b734a327e3e37030371eeeea/gcc%2Fada%2Fa-chtgke.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-chtgke.adb?ref=3837bc7f8694ca43b734a327e3e37030371eeeea", "patch": "@@ -7,11 +7,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2004-2005, Free Software Foundation, Inc.         --\n---                                                                          --\n--- This specification is derived from the Ada Reference Manual for use with --\n--- GNAT. The copyright notice above, and the license provisions that follow --\n--- apply solely to the  contents of the part following the private keyword. --\n+--          Copyright (C) 2004-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -131,23 +127,21 @@ package body Ada.Containers.Hash_Tables.Generic_Keys is\n       Indx : constant Hash_Type := Index (HT, Key);\n       B    : Node_Access renames HT.Buckets (Indx);\n \n-      subtype Length_Subtype is Count_Type range 0 .. Count_Type'Last - 1;\n-\n    begin\n       if B = null then\n          if HT.Busy > 0 then\n             raise Program_Error;\n          end if;\n \n-         declare\n-            Length : constant Length_Subtype := HT.Length;\n-         begin\n-            Node := New_Node (Next => null);\n-            Inserted := True;\n+         if HT.Length = Count_Type'Last then\n+            raise Constraint_Error;\n+         end if;\n \n-            B := Node;\n-            HT.Length := Length + 1;\n-         end;\n+         Node := New_Node (Next => null);\n+         Inserted := True;\n+\n+         B := Node;\n+         HT.Length := HT.Length + 1;\n \n          return;\n       end if;\n@@ -168,15 +162,15 @@ package body Ada.Containers.Hash_Tables.Generic_Keys is\n          raise Program_Error;\n       end if;\n \n-      declare\n-         Length : constant Length_Subtype := HT.Length;\n-      begin\n-         Node := New_Node (Next => B);\n-         Inserted := True;\n+      if HT.Length = Count_Type'Last then\n+         raise Constraint_Error;\n+      end if;\n \n-         B := Node;\n-         HT.Length := Length + 1;\n-      end;\n+      Node := New_Node (Next => B);\n+      Inserted := True;\n+\n+      B := Node;\n+      HT.Length := HT.Length + 1;\n    end Generic_Conditional_Insert;\n \n    -----------\n@@ -190,4 +184,91 @@ package body Ada.Containers.Hash_Tables.Generic_Keys is\n       return Hash (Key) mod HT.Buckets'Length;\n    end Index;\n \n+   ---------------------\n+   -- Replace_Element --\n+   ---------------------\n+\n+   procedure Generic_Replace_Element\n+     (HT   : in out Hash_Table_Type;\n+      Node : Node_Access;\n+      Key  : Key_Type)\n+   is\n+   begin\n+      pragma Assert (HT.Length > 0);\n+\n+      if Equivalent_Keys (Key, Node) then\n+         pragma Assert (Hash (Key) = Hash (Node));\n+\n+         if HT.Lock > 0 then\n+            raise Program_Error with\n+              \"attempt to tamper with cursors (container is locked)\";\n+         end if;\n+\n+         Assign (Node, Key);\n+         return;\n+      end if;\n+\n+      declare\n+         J : Hash_Type;\n+         K : constant Hash_Type := Index (HT, Key);\n+         B : Node_Access renames HT.Buckets (K);\n+         N : Node_Access := B;\n+         M : Node_Access;\n+\n+      begin\n+         while N /= null loop\n+            if Equivalent_Keys (Key, N) then\n+               raise Program_Error with\n+                 \"attempt to replace existing element\";\n+            end if;\n+\n+            N := Next (N);\n+         end loop;\n+\n+         J := Hash (Node);\n+\n+         if J = K then\n+            if HT.Lock > 0 then\n+               raise Program_Error with\n+                 \"attempt to tamper with cursors (container is locked)\";\n+            end if;\n+\n+            Assign (Node, Key);\n+            return;\n+         end if;\n+\n+         if HT.Busy > 0 then\n+            raise Program_Error with\n+              \"attempt to tamper with elements (container is busy)\";\n+         end if;\n+\n+         Assign (Node, Key);\n+\n+         N := HT.Buckets (J);\n+         pragma Assert (N /= null);\n+\n+         if N = Node then\n+            HT.Buckets (J) := Next (Node);\n+\n+         else\n+            pragma Assert (HT.Length > 1);\n+\n+            loop\n+               M := Next (N);\n+               pragma Assert (M /= null);\n+\n+               if M = Node then\n+                  Set_Next (Node => N, Next => Next (Node));\n+                  exit;\n+               end if;\n+\n+               N := M;\n+            end loop;\n+         end if;\n+\n+         Set_Next (Node => Node, Next => B);\n+         B := Node;\n+      end;\n+   end Generic_Replace_Element;\n+\n end Ada.Containers.Hash_Tables.Generic_Keys;"}, {"sha": "259b0126df22b21ae4291f9baae6c471525686c7", "filename": "gcc/ada/a-chtgke.ads", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3837bc7f8694ca43b734a327e3e37030371eeeea/gcc%2Fada%2Fa-chtgke.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3837bc7f8694ca43b734a327e3e37030371eeeea/gcc%2Fada%2Fa-chtgke.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-chtgke.ads?ref=3837bc7f8694ca43b734a327e3e37030371eeeea", "patch": "@@ -7,7 +7,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2004-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -67,15 +67,22 @@ package Ada.Containers.Hash_Tables.Generic_Keys is\n       Key  : Key_Type;\n       X    : out Node_Access);\n \n-   function Find (HT  : Hash_Table_Type; Key : Key_Type) return Node_Access;\n+   function Find (HT : Hash_Table_Type; Key : Key_Type) return Node_Access;\n \n    generic\n-      with function New_Node\n-        (Next : Node_Access) return Node_Access;\n+      with function New_Node (Next : Node_Access) return Node_Access;\n    procedure Generic_Conditional_Insert\n      (HT       : in out Hash_Table_Type;\n       Key      : Key_Type;\n       Node     : out Node_Access;\n       Inserted : out Boolean);\n \n+   generic\n+      with function Hash (Node : Node_Access) return Hash_Type;\n+      with procedure Assign (Node : Node_Access; Key : Key_Type);\n+   procedure Generic_Replace_Element\n+     (HT   : in out Hash_Table_Type;\n+      Node : Node_Access;\n+      Key  : Key_Type);\n+\n end Ada.Containers.Hash_Tables.Generic_Keys;"}, {"sha": "c22be825a48529a345a6bdf3bac1b9c3fc88f137", "filename": "gcc/ada/a-chtgop.adb", "status": "modified", "additions": 48, "deletions": 141, "changes": 189, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3837bc7f8694ca43b734a327e3e37030371eeeea/gcc%2Fada%2Fa-chtgop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3837bc7f8694ca43b734a327e3e37030371eeeea/gcc%2Fada%2Fa-chtgop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-chtgop.adb?ref=3837bc7f8694ca43b734a327e3e37030371eeeea", "patch": "@@ -7,7 +7,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2004-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -30,8 +30,6 @@\n -- This unit was originally developed by Matthew J Heaney.                  --\n ------------------------------------------------------------------------------\n \n---  This body needs commenting ???\n-\n with Ada.Containers.Prime_Numbers;\n with Ada.Unchecked_Deallocation;\n \n@@ -60,40 +58,15 @@ package body Ada.Containers.Hash_Tables.Generic_Operations is\n          return;\n       end if;\n \n+      --  Technically it isn't necessary to allocate the exact same length\n+      --  buckets array, because our only requirement is that following\n+      --  assignment the source and target containers compare equal (that is,\n+      --  operator \"=\" returns True). We can satisfy this requirement with any\n+      --  hash table length, but we decide here to match the length of the\n+      --  source table. This has the benefit that when iterating, elements of\n+      --  the target are delivered in the exact same order as for the source.\n+\n       HT.Buckets := new Buckets_Type (Src_Buckets'Range);\n-      --  TODO: allocate minimum size req'd.  (See note below.)\n-\n-      --  NOTE: see note below about these comments.\n-      --  Probably we have to duplicate the Size (Src), too, in order\n-      --  to guarantee that\n-\n-      --    Dst := Src;\n-      --    Dst = Src is true\n-\n-      --  The only quirk is that we depend on the hash value of a dst key\n-      --  to be the same as the src key from which it was copied.\n-      --  If we relax the requirement that the hash value must be the\n-      --  same, then of course we can't guarantee that following\n-      --  assignment that Dst = Src is true ???\n-      --\n-      --  NOTE: 17 Apr 2005\n-      --  What I said above is no longer true.  The semantics of (map) equality\n-      --  changed, such that we use key in the left map to look up the\n-      --  equivalent key in the right map, and then compare the elements (using\n-      --  normal equality) of the equivalent keys.  So it doesn't matter that\n-      --  the maps have different capacities (i.e. the hash tables have\n-      --  different lengths), since we just look up the key, irrespective of\n-      --  its map's hash table length.  All the RM says we're required to do\n-      --  it arrange for the target map to \"=\" the source map following an\n-      --  assignment (that is, following an Adjust), so it doesn't matter\n-      --  what the capacity of the target map is.  What I'll probably do is\n-      --  allocate a new hash table that has the minimum size necessary,\n-      --  instead of allocating a new hash table whose size exactly matches\n-      --  that of the source.  (See the assignment that immediately precedes\n-      --  these comments.)  What we really need is a special Assign operation\n-      --  (not unlike what we have already for Vector) that allows the user to\n-      --  choose the capacity of the target.\n-      --  END NOTE.\n \n       for Src_Index in Src_Buckets'Range loop\n          Src_Node := Src_Buckets (Src_Index);\n@@ -102,7 +75,7 @@ package body Ada.Containers.Hash_Tables.Generic_Operations is\n             declare\n                Dst_Node : constant Node_Access := Copy_Node (Src_Node);\n \n-               --   See note above\n+               --  See note above\n \n                pragma Assert (Index (HT, Dst_Node) = Src_Index);\n \n@@ -353,32 +326,20 @@ package body Ada.Containers.Hash_Tables.Generic_Operations is\n    -----------------------\n \n    procedure Generic_Iteration (HT : Hash_Table_Type) is\n-      Busy : Natural renames HT'Unrestricted_Access.all.Busy;\n+      Node : Node_Access;\n \n    begin\n       if HT.Length = 0 then\n          return;\n       end if;\n \n-      Busy := Busy + 1;\n-\n-      declare\n-         Node : Node_Access;\n-      begin\n-         for Indx in HT.Buckets'Range loop\n-            Node := HT.Buckets (Indx);\n-            while Node /= null loop\n-               Process (Node);\n-               Node := Next (Node);\n-            end loop;\n+      for Indx in HT.Buckets'Range loop\n+         Node := HT.Buckets (Indx);\n+         while Node /= null loop\n+            Process (Node);\n+            Node := Next (Node);\n          end loop;\n-      exception\n-         when others =>\n-            Busy := Busy - 1;\n-            raise;\n-      end;\n-\n-      Busy := Busy - 1;\n+      end loop;\n    end Generic_Iteration;\n \n    ------------------\n@@ -389,71 +350,41 @@ package body Ada.Containers.Hash_Tables.Generic_Operations is\n      (Stream : access Root_Stream_Type'Class;\n       HT     : out Hash_Table_Type)\n    is\n-      X, Y : Node_Access;\n-\n-      Last, I : Hash_Type;\n-      N, M    : Count_Type'Base;\n+      N  : Count_Type'Base;\n+      NN : Hash_Type;\n \n    begin\n       Clear (HT);\n \n-      Hash_Type'Read (Stream, Last);\n-\n       Count_Type'Base'Read (Stream, N);\n-      pragma Assert (N >= 0);\n+\n+      if N < 0 then\n+         raise Program_Error;\n+      end if;\n \n       if N = 0 then\n          return;\n       end if;\n \n       if HT.Buckets = null\n-        or else HT.Buckets'Last /= Last\n+        or else HT.Buckets'Length < N\n       then\n          Free (HT.Buckets);\n-         HT.Buckets := new Buckets_Type (0 .. Last);\n+         NN := Prime_Numbers.To_Prime (N);\n+         HT.Buckets := new Buckets_Type (0 .. NN - 1);\n       end if;\n \n-      --  TODO: should we rewrite this algorithm so that it doesn't\n-      --  depend on preserving the exactly length of the hash table\n-      --  array?  We would prefer to not have to (re)allocate a\n-      --  buckets array (the array that HT already has might be large\n-      --  enough), and to not have to stream the count of the number\n-      --  of nodes in each bucket.  The algorithm below is vestigial,\n-      --  as it was written prior to the meeting in Palma, when the\n-      --  semantics of equality were changed (and which obviated the\n-      --  need to preserve the hash table length).\n-\n-      loop\n-         Hash_Type'Read (Stream, I);\n-         pragma Assert (I in HT.Buckets'Range);\n-         pragma Assert (HT.Buckets (I) = null);\n-\n-         Count_Type'Base'Read (Stream, M);\n-         pragma Assert (M >= 1);\n-         pragma Assert (M <= N);\n-\n-         HT.Buckets (I) := New_Node (Stream);\n-         pragma Assert (HT.Buckets (I) /= null);\n-         pragma Assert (Next (HT.Buckets (I)) = null);\n-\n-         Y := HT.Buckets (I);\n+      for J in 1 .. N loop\n+         declare\n+            Node : constant Node_Access := New_Node (Stream);\n+            Indx : constant Hash_Type := Index (HT, Node);\n+            B    : Node_Access renames HT.Buckets (Indx);\n+         begin\n+            Set_Next (Node => Node, Next => B);\n+            B := Node;\n+         end;\n \n          HT.Length := HT.Length + 1;\n-\n-         for J in Count_Type range 2 .. M loop\n-            X := New_Node (Stream);\n-            pragma Assert (X /= null);\n-            pragma Assert (Next (X) = null);\n-\n-            Set_Next (Node => Y, Next => X);\n-            Y := X;\n-\n-            HT.Length := HT.Length + 1;\n-         end loop;\n-\n-         N := N - M;\n-\n-         exit when N = 0;\n       end loop;\n    end Generic_Read;\n \n@@ -465,47 +396,23 @@ package body Ada.Containers.Hash_Tables.Generic_Operations is\n      (Stream : access Root_Stream_Type'Class;\n       HT     : Hash_Table_Type)\n    is\n-      M : Count_Type'Base;\n-      X : Node_Access;\n-\n-   begin\n-      if HT.Buckets = null then\n-         Hash_Type'Write (Stream, 0);\n-      else\n-         Hash_Type'Write (Stream, HT.Buckets'Last);\n-      end if;\n+      procedure Write (Node : Node_Access);\n+      pragma Inline (Write);\n \n-      Count_Type'Base'Write (Stream, HT.Length);\n+      procedure Write is new Generic_Iteration (Write);\n \n-      if HT.Length = 0 then\n-         return;\n-      end if;\n+      -----------\n+      -- Write --\n+      -----------\n \n-      --  TODO: see note in Generic_Read???\n-\n-      for Indx in HT.Buckets'Range loop\n-         X := HT.Buckets (Indx);\n-\n-         if X /= null then\n-            M := 1;\n-            loop\n-               X := Next (X);\n-               exit when X = null;\n-               M := M + 1;\n-            end loop;\n-\n-            Hash_Type'Write (Stream, Indx);\n-            Count_Type'Base'Write (Stream, M);\n-\n-            X := HT.Buckets (Indx);\n-            for J in Count_Type range 1 .. M loop\n-               Write (Stream, X);\n-               X := Next (X);\n-            end loop;\n+      procedure Write (Node : Node_Access) is\n+      begin\n+         Write (Stream, Node);\n+      end Write;\n \n-            pragma Assert (X = null);\n-         end if;\n-      end loop;\n+   begin\n+      Count_Type'Base'Write (Stream, HT.Length);\n+      Write (HT);\n    end Generic_Write;\n \n    -----------"}, {"sha": "cf9cdcfc39d7b6faa51e638b3c7ca848d0cb7201", "filename": "gcc/ada/a-cidlli.adb", "status": "modified", "additions": 151, "deletions": 122, "changes": 273, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3837bc7f8694ca43b734a327e3e37030371eeeea/gcc%2Fada%2Fa-cidlli.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3837bc7f8694ca43b734a327e3e37030371eeeea/gcc%2Fada%2Fa-cidlli.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cidlli.adb?ref=3837bc7f8694ca43b734a327e3e37030371eeeea", "patch": "@@ -9,10 +9,6 @@\n --                                                                          --\n --          Copyright (C) 2004-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n--- This specification is derived from the Ada Reference Manual for use with --\n--- GNAT. The copyright notice above, and the license provisions that follow --\n--- apply solely to the  contents of the part following the private keyword. --\n---                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n -- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n@@ -180,7 +176,8 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n       pragma Assert (Container.Last.Next = null);\n \n       if Container.Busy > 0 then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"attempt to tamper with elements (list is busy)\";\n       end if;\n \n       while Container.Length > 1 loop\n@@ -230,15 +227,18 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n \n    begin\n       if Position.Node = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with\n+           \"Position cursor has no element\";\n       end if;\n \n       if Position.Node.Element = null then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"Position cursor has no element\";\n       end if;\n \n       if Position.Container /= Container'Unrestricted_Access then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"Position cursor designates wrong container\";\n       end if;\n \n       pragma Assert (Vet (Position), \"bad cursor in Delete\");\n@@ -255,7 +255,8 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n       end if;\n \n       if Container.Busy > 0 then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"attempt to tamper with elements (list is busy)\";\n       end if;\n \n       for Index in 1 .. Count loop\n@@ -304,7 +305,8 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n       end if;\n \n       if Container.Busy > 0 then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"attempt to tamper with elements (list is busy)\";\n       end if;\n \n       for I in 1 .. Count loop\n@@ -341,7 +343,8 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n       end if;\n \n       if Container.Busy > 0 then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"attempt to tamper with elements (list is busy)\";\n       end if;\n \n       for I in 1 .. Count loop\n@@ -364,11 +367,13 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n    function Element (Position : Cursor) return Element_Type is\n    begin\n       if Position.Node = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with\n+           \"Position cursor has no element\";\n       end if;\n \n       if Position.Node.Element = null then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"Position cursor has no element\";\n       end if;\n \n       pragma Assert (Vet (Position), \"bad cursor in Element\");\n@@ -397,7 +402,8 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n          end if;\n \n          if Position.Container /= Container'Unrestricted_Access then\n-            raise Program_Error;\n+            raise Program_Error with\n+              \"Position cursor designates wrong container\";\n          end if;\n \n          pragma Assert (Vet (Position), \"bad cursor in Find\");\n@@ -434,7 +440,7 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n    function First_Element (Container : List) return Element_Type is\n    begin\n       if Container.First = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"list is empty\";\n       end if;\n \n       return Container.First.Element.all;\n@@ -497,18 +503,21 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n         (Target : in out List;\n          Source : in out List)\n       is\n-         LI : Cursor;\n-         RI : Cursor;\n+         LI, RI : Cursor;\n \n       begin\n          if Target'Address = Source'Address then\n             return;\n          end if;\n \n-         if Target.Busy > 0\n-           or else Source.Busy > 0\n-         then\n-            raise Program_Error;\n+         if Target.Busy > 0 then\n+            raise Program_Error with\n+              \"attempt to tamper with elements of Target (list is busy)\";\n+         end if;\n+\n+         if Source.Busy > 0 then\n+            raise Program_Error with\n+              \"attempt to tamper with elements of Source (list is busy)\";\n          end if;\n \n          LI := First (Target);\n@@ -624,7 +633,8 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n          pragma Assert (Container.Last.Next = null);\n \n          if Container.Busy > 0 then\n-            raise Program_Error;\n+            raise Program_Error with\n+              \"attempt to tamper with elements (list is busy)\";\n          end if;\n \n          Sort (Front => null, Back => null);\n@@ -661,13 +671,15 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n    begin\n       if Before.Container /= null then\n          if Before.Container /= Container'Unrestricted_Access then\n-            raise Program_Error;\n+            raise Program_Error with\n+              \"attempt to tamper with elements (list is busy)\";\n          end if;\n \n          if Before.Node = null\n            or else Before.Node.Element = null\n          then\n-            raise Program_Error;\n+            raise Program_Error with\n+              \"Before cursor has no element\";\n          end if;\n \n          pragma Assert (Vet (Before), \"bad cursor in Insert\");\n@@ -679,11 +691,12 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n       end if;\n \n       if Container.Length > Count_Type'Last - Count then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"new length exceeds maximum\";\n       end if;\n \n       if Container.Busy > 0 then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"attempt to tamper with elements (list is busy)\";\n       end if;\n \n       declare\n@@ -833,7 +846,7 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n    function Last_Element (Container : List) return Element_Type is\n    begin\n       if Container.Last = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"list is empty\";\n       end if;\n \n       return Container.Last.Element.all;\n@@ -859,7 +872,8 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n       end if;\n \n       if Source.Busy > 0 then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"attempt to tamper with elements of Source (list is busy)\";\n       end if;\n \n       Clear (Target);\n@@ -880,27 +894,17 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n \n    procedure Next (Position : in out Cursor) is\n    begin\n-      pragma Assert (Vet (Position), \"bad cursor in procedure Next\");\n-\n-      if Position.Node = null then\n-         return;\n-      end if;\n-\n-      Position.Node := Position.Node.Next;\n-\n-      if Position.Node = null then\n-         Position.Container := null;\n-      end if;\n+      Position := Next (Position);\n    end Next;\n \n    function Next (Position : Cursor) return Cursor is\n    begin\n-      pragma Assert (Vet (Position), \"bad cursor in function Next\");\n-\n       if Position.Node = null then\n          return No_Element;\n       end if;\n \n+      pragma Assert (Vet (Position), \"bad cursor in Next\");\n+\n       declare\n          Next_Node : constant Node_Access := Position.Node.Next;\n       begin\n@@ -931,27 +935,17 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n \n    procedure Previous (Position : in out Cursor) is\n    begin\n-      pragma Assert (Vet (Position), \"bad cursor in procedure Previous\");\n-\n-      if Position.Node = null then\n-         return;\n-      end if;\n-\n-      Position.Node := Position.Node.Prev;\n-\n-      if Position.Node = null then\n-         Position.Container := null;\n-      end if;\n+      Position := Previous (Position);\n    end Previous;\n \n    function Previous (Position : Cursor) return Cursor is\n    begin\n-      pragma Assert (Vet (Position), \"bad cursor in function Previous\");\n-\n       if Position.Node = null then\n          return No_Element;\n       end if;\n \n+      pragma Assert (Vet (Position), \"bad cursor in Previous\");\n+\n       declare\n          Prev_Node : constant Node_Access := Position.Node.Prev;\n       begin\n@@ -973,11 +967,13 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n    is\n    begin\n       if Position.Node = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with\n+           \"Position cursor has no element\";\n       end if;\n \n       if Position.Node.Element = null then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"Position cursor has no element\";\n       end if;\n \n       pragma Assert (Vet (Position), \"bad cursor in Query_Element\");\n@@ -1010,7 +1006,7 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n    ----------\n \n    procedure Read\n-     (Stream : access Root_Stream_Type'Class;\n+     (Stream : not null access Root_Stream_Type'Class;\n       Item   : out List)\n    is\n       N   : Count_Type'Base;\n@@ -1059,11 +1055,11 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n    end Read;\n \n    procedure Read\n-     (Stream : access Root_Stream_Type'Class;\n+     (Stream : not null access Root_Stream_Type'Class;\n       Item   : out Cursor)\n    is\n    begin\n-      raise Program_Error;\n+      raise Program_Error with \"attempt to stream list cursor\";\n    end Read;\n \n    ---------------------\n@@ -1077,19 +1073,22 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n    is\n    begin\n       if Position.Container = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n \n       if Position.Container /= Container'Unchecked_Access then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"Position cursor designates wrong container\";\n       end if;\n \n-      if Position.Container.Lock > 0 then\n-         raise Program_Error;\n+      if Container.Lock > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with cursors (list is locked)\";\n       end if;\n \n       if Position.Node.Element = null then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"Position cursor has no element\";\n       end if;\n \n       pragma Assert (Vet (Position), \"bad cursor in Replace_Element\");\n@@ -1162,7 +1161,8 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n       pragma Assert (Container.Last.Next = null);\n \n       if Container.Busy > 0 then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"attempt to tamper with elements (list is busy)\";\n       end if;\n \n       Container.First := J;\n@@ -1206,11 +1206,12 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n \n       else\n          if Node.Element = null then\n-            raise Program_Error;\n+            raise Program_Error with \"Position cursor has no element\";\n          end if;\n \n          if Position.Container /= Container'Unrestricted_Access then\n-            raise Program_Error;\n+            raise Program_Error with\n+              \"Position cursor designates wrong container\";\n          end if;\n \n          pragma Assert (Vet (Position), \"bad cursor in Reverse_Find\");\n@@ -1269,13 +1270,15 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n    begin\n       if Before.Container /= null then\n          if Before.Container /= Target'Unrestricted_Access then\n-            raise Program_Error;\n+            raise Program_Error with\n+              \"Before cursor designates wrong container\";\n          end if;\n \n          if Before.Node = null\n            or else Before.Node.Element = null\n          then\n-            raise Program_Error;\n+            raise Program_Error with\n+              \"Before cursor has no element\";\n          end if;\n \n          pragma Assert (Vet (Before), \"bad cursor in Splice\");\n@@ -1291,13 +1294,17 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n       pragma Assert (Source.Last.Next = null);\n \n       if Target.Length > Count_Type'Last - Source.Length then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"new length exceeds maximum\";\n       end if;\n \n-      if Target.Busy > 0\n-        or else Source.Busy > 0\n-      then\n-         raise Program_Error;\n+      if Target.Busy > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with elements of Target (list is busy)\";\n+      end if;\n+\n+      if Source.Busy > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with elements of Source (list is busy)\";\n       end if;\n \n       if Target.Length = 0 then\n@@ -1343,33 +1350,36 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n    procedure Splice\n      (Container : in out List;\n       Before    : Cursor;\n-      Position  : in out Cursor)\n+      Position  : Cursor)\n    is\n    begin\n       if Before.Container /= null then\n          if Before.Container /= Container'Unchecked_Access then\n-            raise Program_Error;\n+            raise Program_Error with\n+              \"Before cursor designates wrong container\";\n          end if;\n \n          if Before.Node = null\n            or else Before.Node.Element = null\n          then\n-            raise Program_Error;\n+            raise Program_Error with\n+              \"Before cursor has no element\";\n          end if;\n \n          pragma Assert (Vet (Before), \"bad Before cursor in Splice\");\n       end if;\n \n       if Position.Node = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n \n       if Position.Node.Element = null then\n-         raise Program_Error;\n+         raise Program_Error with \"Position cursor has no element\";\n       end if;\n \n       if Position.Container /= Container'Unrestricted_Access then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"Position cursor designates wrong container\";\n       end if;\n \n       pragma Assert (Vet (Position), \"bad Position cursor in Splice\");\n@@ -1383,7 +1393,8 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n       pragma Assert (Container.Length >= 2);\n \n       if Container.Busy > 0 then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"attempt to tamper with elements (list is busy)\";\n       end if;\n \n       if Before.Node = null then\n@@ -1463,40 +1474,48 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n \n       if Before.Container /= null then\n          if Before.Container /= Target'Unrestricted_Access then\n-            raise Program_Error;\n+            raise Program_Error with\n+              \"Before cursor designates wrong container\";\n          end if;\n \n          if Before.Node = null\n            or else Before.Node.Element = null\n          then\n-            raise Program_Error;\n+            raise Program_Error with\n+              \"Before cursor has no element\";\n          end if;\n \n          pragma Assert (Vet (Before), \"bad Before cursor in Splice\");\n       end if;\n \n       if Position.Node = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n \n       if Position.Node.Element = null then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"Position cursor has no element\";\n       end if;\n \n       if Position.Container /= Source'Unrestricted_Access then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"Position cursor designates wrong container\";\n       end if;\n \n       pragma Assert (Vet (Position), \"bad Position cursor in Splice\");\n \n       if Target.Length = Count_Type'Last then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"Target is full\";\n       end if;\n \n-      if Target.Busy > 0\n-        or else Source.Busy > 0\n-      then\n-         raise Program_Error;\n+      if Target.Busy > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with elements of Target (list is busy)\";\n+      end if;\n+\n+      if Source.Busy > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with elements of Source (list is busy)\";\n       end if;\n \n       if Position.Node = Source.First then\n@@ -1573,24 +1592,29 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n       I, J      : Cursor)\n    is\n    begin\n-      if I.Node = null\n-        or else J.Node = null\n-      then\n-         raise Constraint_Error;\n+      if I.Node = null then\n+         raise Constraint_Error with \"I cursor has no element\";\n       end if;\n \n-      if I.Container /= Container'Unchecked_Access\n-        or else J.Container /= Container'Unchecked_Access\n-      then\n-         raise Program_Error;\n+      if J.Node = null then\n+         raise Constraint_Error with \"J cursor has no element\";\n+      end if;\n+\n+      if I.Container /= Container'Unchecked_Access then\n+         raise Program_Error with \"I cursor designates wrong container\";\n+      end if;\n+\n+      if J.Container /= Container'Unchecked_Access then\n+         raise Program_Error with \"J cursor designates wrong container\";\n       end if;\n \n       if I.Node = J.Node then\n          return;\n       end if;\n \n       if Container.Lock > 0 then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"attempt to tamper with cursors (list is locked)\";\n       end if;\n \n       pragma Assert (Vet (I), \"bad I cursor in Swap\");\n@@ -1614,51 +1638,54 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n       I, J      : Cursor)\n    is\n    begin\n-      if I.Node = null\n-        or else J.Node = null\n-      then\n-         raise Constraint_Error;\n+      if I.Node = null then\n+         raise Constraint_Error with \"I cursor has no element\";\n       end if;\n \n-      if I.Container /= Container'Unrestricted_Access\n-        or else I.Container /= J.Container\n-      then\n-         raise Program_Error;\n+      if J.Node = null then\n+         raise Constraint_Error with \"J cursor has no element\";\n+      end if;\n+\n+      if I.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with \"I cursor designates wrong container\";\n+      end if;\n+\n+      if J.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with \"J cursor designates wrong container\";\n       end if;\n \n       if I.Node = J.Node then\n          return;\n       end if;\n \n       if Container.Busy > 0 then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"attempt to tamper with elements (list is busy)\";\n       end if;\n \n       pragma Assert (Vet (I), \"bad I cursor in Swap_Links\");\n       pragma Assert (Vet (J), \"bad J cursor in Swap_Links\");\n \n       declare\n          I_Next : constant Cursor := Next (I);\n-         J_Copy : Cursor := J;\n \n       begin\n          if I_Next = J then\n-            Splice (Container, Before => I, Position => J_Copy);\n+            Splice (Container, Before => I, Position => J);\n \n          else\n             declare\n                J_Next : constant Cursor := Next (J);\n-               I_Copy : Cursor := I;\n \n             begin\n                if J_Next = I then\n-                  Splice (Container, Before => J, Position => I_Copy);\n+                  Splice (Container, Before => J, Position => I);\n \n                else\n                   pragma Assert (Container.Length >= 3);\n \n-                  Splice (Container, Before => I_Next, Position => J_Copy);\n-                  Splice (Container, Before => J_Next, Position => I_Copy);\n+                  Splice (Container, Before => I_Next, Position => J);\n+                  Splice (Container, Before => J_Next, Position => I);\n                end if;\n             end;\n          end if;\n@@ -1679,15 +1706,17 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n    is\n    begin\n       if Position.Node = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n \n       if Position.Node.Element = null then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"Position cursor has no element\";\n       end if;\n \n       if Position.Container /= Container'Unchecked_Access then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"Position cursor designates wrong container\";\n       end if;\n \n       pragma Assert (Vet (Position), \"bad cursor in Update_Element\");\n@@ -1862,7 +1891,7 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n    -----------\n \n    procedure Write\n-     (Stream : access Root_Stream_Type'Class;\n+     (Stream : not null access Root_Stream_Type'Class;\n       Item   : List)\n    is\n       Node : Node_Access := Item.First;\n@@ -1871,17 +1900,17 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n       Count_Type'Base'Write (Stream, Item.Length);\n \n       while Node /= null loop\n-         Element_Type'Output (Stream, Node.Element.all);  --  X.all\n+         Element_Type'Output (Stream, Node.Element.all);\n          Node := Node.Next;\n       end loop;\n    end Write;\n \n    procedure Write\n-     (Stream : access Root_Stream_Type'Class;\n+     (Stream : not null access Root_Stream_Type'Class;\n       Item   : Cursor)\n    is\n    begin\n-      raise Program_Error;\n+      raise Program_Error with \"attempt to stream list cursor\";\n    end Write;\n \n end Ada.Containers.Indefinite_Doubly_Linked_Lists;"}, {"sha": "ff354ccf1e28232f320d2b80fc157a8b6cbfae76", "filename": "gcc/ada/a-cidlli.ads", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3837bc7f8694ca43b734a327e3e37030371eeeea/gcc%2Fada%2Fa-cidlli.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3837bc7f8694ca43b734a327e3e37030371eeeea/gcc%2Fada%2Fa-cidlli.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cidlli.ads?ref=3837bc7f8694ca43b734a327e3e37030371eeeea", "patch": "@@ -7,7 +7,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2004-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -47,8 +47,10 @@ package Ada.Containers.Indefinite_Doubly_Linked_Lists is\n    pragma Preelaborate;\n \n    type List is tagged private;\n+   pragma Preelaborable_Initialization (List);\n \n    type Cursor is private;\n+   pragma Preelaborable_Initialization (Cursor);\n \n    Empty_List : constant List;\n \n@@ -138,7 +140,7 @@ package Ada.Containers.Indefinite_Doubly_Linked_Lists is\n    procedure Splice\n      (Container : in out List;\n       Before    : Cursor;\n-      Position  : in out Cursor);\n+      Position  : Cursor);\n \n    function First (Container : List) return Cursor;\n \n@@ -223,13 +225,13 @@ private\n    use Ada.Streams;\n \n    procedure Read\n-     (Stream : access Root_Stream_Type'Class;\n+     (Stream : not null access Root_Stream_Type'Class;\n       Item   : out List);\n \n    for List'Read use Read;\n \n    procedure Write\n-     (Stream : access Root_Stream_Type'Class;\n+     (Stream : not null access Root_Stream_Type'Class;\n       Item   : List);\n \n    for List'Write use Write;\n@@ -246,13 +248,13 @@ private\n       end record;\n \n    procedure Read\n-     (Stream : access Root_Stream_Type'Class;\n+     (Stream : not null access Root_Stream_Type'Class;\n       Item   : out Cursor);\n \n    for Cursor'Read use Read;\n \n    procedure Write\n-     (Stream : access Root_Stream_Type'Class;\n+     (Stream : not null access Root_Stream_Type'Class;\n       Item   : Cursor);\n \n    for Cursor'Write use Write;"}, {"sha": "24ca33bdb2ca4875c7c2843f831ea17cd96ac7d9", "filename": "gcc/ada/a-cihama.adb", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3837bc7f8694ca43b734a327e3e37030371eeeea/gcc%2Fada%2Fa-cihama.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3837bc7f8694ca43b734a327e3e37030371eeeea/gcc%2Fada%2Fa-cihama.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cihama.adb?ref=3837bc7f8694ca43b734a327e3e37030371eeeea", "patch": "@@ -7,11 +7,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2004-2005, Free Software Foundation, Inc.         --\n---                                                                          --\n--- This specification is derived from the Ada Reference Manual for use with --\n--- GNAT. The copyright notice above, and the license provisions that follow --\n--- apply solely to the  contents of the part following the private keyword. --\n+--          Copyright (C) 2004-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -603,7 +599,7 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n       procedure Process_Node (Node : Node_Access);\n       pragma Inline (Process_Node);\n \n-      procedure Iterate is\n+      procedure Local_Iterate is\n          new HT_Ops.Generic_Iteration (Process_Node);\n \n       ------------------\n@@ -615,10 +611,22 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n          Process (Cursor'(Container'Unchecked_Access, Node));\n       end Process_Node;\n \n+      B : Natural renames Container'Unrestricted_Access.HT.Busy;\n+\n    --  Start of processing Iterate\n \n    begin\n-      Iterate (Container.HT);\n+      B := B + 1;\n+\n+      begin\n+         Local_Iterate (Container.HT);\n+      exception\n+         when others =>\n+            B := B - 1;\n+            raise;\n+      end;\n+\n+      B := B - 1;\n    end Iterate;\n \n    ---------"}, {"sha": "1731ea708d10c9c80edddceca507f028d68ac8de", "filename": "gcc/ada/a-cihase.adb", "status": "modified", "additions": 62, "deletions": 153, "changes": 215, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3837bc7f8694ca43b734a327e3e37030371eeeea/gcc%2Fada%2Fa-cihase.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3837bc7f8694ca43b734a327e3e37030371eeeea/gcc%2Fada%2Fa-cihase.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cihase.adb?ref=3837bc7f8694ca43b734a327e3e37030371eeeea", "patch": "@@ -9,10 +9,6 @@\n --                                                                          --\n --          Copyright (C) 2004-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n--- This specification is derived from the Ada Reference Manual for use with --\n--- GNAT. The copyright notice above, and the license provisions that follow --\n--- apply solely to the  contents of the part following the private keyword. --\n---                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n -- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n@@ -52,6 +48,9 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n    -- Local Subprograms --\n    -----------------------\n \n+   procedure Assign (Node : Node_Access; Item : Element_Type);\n+   pragma Inline (Assign);\n+\n    function Copy_Node (Source : Node_Access) return Node_Access;\n    pragma Inline (Copy_Node);\n \n@@ -89,11 +88,6 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n      return Node_Access;\n    pragma Inline (Read_Node);\n \n-   procedure Replace_Element\n-     (HT       : in out Hash_Table_Type;\n-      Node     : Node_Access;\n-      New_Item : Element_Type);\n-\n    procedure Set_Next (Node : Node_Access; Next : Node_Access);\n    pragma Inline (Set_Next);\n \n@@ -138,6 +132,9 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n    procedure Read_Nodes is\n       new HT_Ops.Generic_Read (Read_Node);\n \n+   procedure Replace_Element is\n+      new Element_Keys.Generic_Replace_Element (Hash_Node, Assign);\n+\n    procedure Write_Nodes is\n      new HT_Ops.Generic_Write (Write_Node);\n \n@@ -159,6 +156,17 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n       HT_Ops.Adjust (Container.HT);\n    end Adjust;\n \n+   ------------\n+   -- Assign --\n+   ------------\n+\n+   procedure Assign (Node : Node_Access; Item : Element_Type) is\n+      X : Element_Access := Node.Element;\n+   begin\n+      Node.Element := new Element_Type'(Item);\n+      Free_Element (X);\n+   end Assign;\n+\n    --------------\n    -- Capacity --\n    --------------\n@@ -266,7 +274,7 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n          return;\n       end if;\n \n-      if Source.Length = 0 then\n+      if Source.HT.Length = 0 then\n          return;\n       end if;\n \n@@ -275,24 +283,41 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n            \"attempt to tamper with elements (set is busy)\";\n       end if;\n \n-      --  TODO: This can be written in terms of a loop instead as\n-      --  active-iterator style, sort of like a passive iterator.\n+      if Source.HT.Length < Target.HT.Length then\n+         declare\n+            Src_Node : Node_Access;\n \n-      Tgt_Node := HT_Ops.First (Target.HT);\n-      while Tgt_Node /= null loop\n-         if Is_In (Source.HT, Tgt_Node) then\n-            declare\n-               X : Node_Access := Tgt_Node;\n-            begin\n-               Tgt_Node := HT_Ops.Next (Target.HT, Tgt_Node);\n-               HT_Ops.Delete_Node_Sans_Free (Target.HT, X);\n-               Free (X);\n-            end;\n+         begin\n+            Src_Node := HT_Ops.First (Source.HT);\n+            while Src_Node /= null loop\n+               Tgt_Node := Element_Keys.Find (Target.HT, Src_Node.Element.all);\n \n-         else\n-            Tgt_Node := HT_Ops.Next (Target.HT, Tgt_Node);\n-         end if;\n-      end loop;\n+               if Tgt_Node /= null then\n+                  HT_Ops.Delete_Node_Sans_Free (Target.HT, Tgt_Node);\n+                  Free (Tgt_Node);\n+               end if;\n+\n+               Src_Node := HT_Ops.Next (Source.HT, Src_Node);\n+            end loop;\n+         end;\n+\n+      else\n+         Tgt_Node := HT_Ops.First (Target.HT);\n+         while Tgt_Node /= null loop\n+            if Is_In (Source.HT, Tgt_Node) then\n+               declare\n+                  X : Node_Access := Tgt_Node;\n+               begin\n+                  Tgt_Node := HT_Ops.Next (Target.HT, Tgt_Node);\n+                  HT_Ops.Delete_Node_Sans_Free (Target.HT, X);\n+                  Free (X);\n+               end;\n+\n+            else\n+               Tgt_Node := HT_Ops.Next (Target.HT, Tgt_Node);\n+            end if;\n+         end loop;\n+      end if;\n    end Difference;\n \n    function Difference (Left, Right : Set) return Set is\n@@ -757,15 +782,6 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n            \"attempt to tamper with elements (set is busy)\";\n       end if;\n \n-      --  TODO: optimize this to use an explicit\n-      --  loop instead of an active iterator\n-      --  (similar to how a passive iterator is\n-      --  implemented).\n-      --\n-      --  Another possibility is to test which\n-      --  set is smaller, and iterate over the\n-      --  smaller set.\n-\n       Tgt_Node := HT_Ops.First (Target.HT);\n       while Tgt_Node /= null loop\n          if Is_In (Source.HT, Tgt_Node) then\n@@ -890,9 +906,6 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n          return False;\n       end if;\n \n-      --  TODO: rewrite this to loop in the\n-      --  style of a passive iterator.\n-\n       Subset_Node := HT_Ops.First (Subset.HT);\n       while Subset_Node /= null loop\n          if not Is_In (Of_Set.HT, Subset_Node) then\n@@ -928,15 +941,22 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n          Process (Cursor'(Container'Unrestricted_Access, Node));\n       end Process_Node;\n \n-      HT : Hash_Table_Type renames Container'Unrestricted_Access.all.HT;\n+      B : Natural renames Container'Unrestricted_Access.HT.Busy;\n \n    --  Start of processing for Iterate\n \n    begin\n-      --  TODO: resolve whether HT_Ops.Generic_Iteration should\n-      --  manipulate busy bit.\n+      B := B + 1;\n+\n+      begin\n+         Iterate (Container.HT);\n+      exception\n+         when others =>\n+            B := B - 1;\n+            raise;\n+      end;\n \n-      Iterate (HT);\n+      B := B - 1;\n    end Iterate;\n \n    ------------\n@@ -1141,117 +1161,6 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n    -- Replace_Element --\n    ---------------------\n \n-   procedure Replace_Element\n-     (HT       : in out Hash_Table_Type;\n-      Node     : Node_Access;\n-      New_Item : Element_Type)\n-   is\n-   begin\n-      if Equivalent_Elements (Node.Element.all, New_Item) then\n-         pragma Assert (Hash (Node.Element.all) = Hash (New_Item));\n-\n-         if HT.Lock > 0 then\n-            raise Program_Error with\n-              \"attempt to tamper with cursors (set is locked)\";\n-         end if;\n-\n-         declare\n-            X : Element_Access := Node.Element;\n-         begin\n-            Node.Element := new Element_Type'(New_Item);  --  OK if fails\n-            Free_Element (X);\n-         end;\n-\n-         return;\n-      end if;\n-\n-      if HT.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with elements (set is busy)\";\n-      end if;\n-\n-      HT_Ops.Delete_Node_Sans_Free (HT, Node);\n-\n-      Insert_New_Element : declare\n-         function New_Node (Next : Node_Access) return Node_Access;\n-         pragma Inline (New_Node);\n-\n-         procedure Insert is\n-            new Element_Keys.Generic_Conditional_Insert (New_Node);\n-\n-         ------------------------\n-         -- Insert_New_Element --\n-         ------------------------\n-\n-         function New_Node (Next : Node_Access) return Node_Access is\n-         begin\n-            Node.Element := new Element_Type'(New_Item);  -- OK if fails\n-            Node.Next := Next;\n-            return Node;\n-         end New_Node;\n-\n-         Result   : Node_Access;\n-         Inserted : Boolean;\n-\n-         X : Element_Access := Node.Element;\n-\n-      --  Start of processing for Insert_New_Element\n-\n-      begin\n-         Attempt_Insert : begin\n-            Insert\n-              (HT       => HT,\n-               Key      => New_Item,\n-               Node     => Result,\n-               Inserted => Inserted);\n-         exception\n-            when others =>\n-               Inserted := False;  -- Assignment failed\n-         end Attempt_Insert;\n-\n-         if Inserted then\n-            Free_Element (X);  -- Just propagate if fails\n-            return;\n-         end if;\n-      end Insert_New_Element;\n-\n-      Reinsert_Old_Element :\n-      declare\n-         function New_Node (Next : Node_Access) return Node_Access;\n-         pragma Inline (New_Node);\n-\n-         procedure Insert is\n-            new Element_Keys.Generic_Conditional_Insert (New_Node);\n-\n-         --------------\n-         -- New_Node --\n-         --------------\n-\n-         function New_Node (Next : Node_Access) return Node_Access is\n-         begin\n-            Node.Next := Next;\n-            return Node;\n-         end New_Node;\n-\n-         Result   : Node_Access;\n-         Inserted : Boolean;\n-\n-      --  Start of processing for Reinsert_Old_Element\n-\n-      begin\n-         Insert\n-           (HT       => HT,\n-            Key      => Node.Element.all,\n-            Node     => Result,\n-            Inserted => Inserted);\n-      exception\n-         when others =>\n-            null;\n-      end Reinsert_Old_Element;\n-\n-      raise Program_Error with \"attempt to replace existing element\";\n-   end Replace_Element;\n-\n    procedure Replace_Element\n      (Container : in out Set;\n       Position  : Cursor;"}, {"sha": "adc34abf9505019f05fd0bba6f9c8b32859c12de", "filename": "gcc/ada/a-ciorse.adb", "status": "modified", "additions": 69, "deletions": 94, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3837bc7f8694ca43b734a327e3e37030371eeeea/gcc%2Fada%2Fa-ciorse.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3837bc7f8694ca43b734a327e3e37030371eeeea/gcc%2Fada%2Fa-ciorse.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ciorse.adb?ref=3837bc7f8694ca43b734a327e3e37030371eeeea", "patch": "@@ -7,11 +7,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2004-2005, Free Software Foundation, Inc.         --\n---                                                                          --\n--- This specification is derived from the Ada Reference Manual for use with --\n--- GNAT. The copyright notice above, and the license provisions that follow --\n--- apply solely to the  contents of the part following the private keyword. --\n+--          Copyright (C) 2004-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -1463,121 +1459,100 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n       Node : Node_Access;\n       Item : Element_Type)\n    is\n+      pragma Assert (Node /= null);\n+      pragma Assert (Node.Element /= null);\n+\n+      function New_Node return Node_Access;\n+      pragma Inline (New_Node);\n+\n+      procedure Local_Insert_Post is\n+         new Element_Keys.Generic_Insert_Post (New_Node);\n+\n+      procedure Local_Insert_Sans_Hint is\n+         new Element_Keys.Generic_Conditional_Insert (Local_Insert_Post);\n+\n+      procedure Local_Insert_With_Hint is\n+         new Element_Keys.Generic_Conditional_Insert_With_Hint\n+        (Local_Insert_Post,\n+         Local_Insert_Sans_Hint);\n+\n+      --------------\n+      -- New_Node --\n+      --------------\n+\n+      function New_Node return Node_Access is\n+      begin\n+         Node.Element := new Element_Type'(Item);  -- OK if fails\n+         Node.Color := Red;\n+         Node.Parent := null;\n+         Node.Right := null;\n+         Node.Left := null;\n+\n+         return Node;\n+      end New_Node;\n+\n+      Hint     : Node_Access;\n+      Result   : Node_Access;\n+      Inserted : Boolean;\n+\n+      X : Element_Access := Node.Element;\n+\n+      --  Start of processing for Insert\n+\n    begin\n       if Item < Node.Element.all\n         or else Node.Element.all < Item\n       then\n          null;\n+\n       else\n          if Tree.Lock > 0 then\n             raise Program_Error with\n               \"attempt to tamper with cursors (set is locked)\";\n          end if;\n \n-         declare\n-            X : Element_Access := Node.Element;\n-         begin\n-            Node.Element := new Element_Type'(Item);\n-            Free_Element (X);\n-         end;\n+         Node.Element := new Element_Type'(Item);\n+         Free_Element (X);\n \n          return;\n       end if;\n \n-      Tree_Operations.Delete_Node_Sans_Free (Tree, Node);  -- Checks busy-bit\n-\n-      Insert_New_Item : declare\n-         function New_Node return Node_Access;\n-         pragma Inline (New_Node);\n-\n-         procedure Insert_Post is\n-            new Element_Keys.Generic_Insert_Post (New_Node);\n-\n-         procedure Insert is\n-            new Element_Keys.Generic_Conditional_Insert (Insert_Post);\n-\n-         --------------\n-         -- New_Node --\n-         --------------\n-\n-         function New_Node return Node_Access is\n-         begin\n-            Node.Element := new Element_Type'(Item);  -- OK if fails\n-            Node.Color := Red;\n-            Node.Parent := null;\n-            Node.Right := null;\n-            Node.Left := null;\n-\n-            return Node;\n-         end New_Node;\n+      Hint := Element_Keys.Ceiling (Tree, Item);\n \n-         Result   : Node_Access;\n-         Inserted : Boolean;\n-\n-         X : Element_Access := Node.Element;\n+      if Hint = null then\n+         null;\n \n-      --  Start of processing for Insert_New_Item\n+      elsif Item < Hint.Element.all then\n+         if Hint = Node then\n+            if Tree.Lock > 0 then\n+               raise Program_Error with\n+                 \"attempt to tamper with cursors (set is locked)\";\n+            end if;\n \n-      begin\n-         Attempt_Insert : begin\n-            Insert\n-              (Tree    => Tree,\n-               Key     => Item,\n-               Node    => Result,\n-               Success => Inserted);  --  TODO: change name of formal param\n-         exception\n-            when others =>\n-               Inserted := False;\n-         end Attempt_Insert;\n+            Node.Element := new Element_Type'(Item);\n+            Free_Element (X);\n \n-         if Inserted then\n-            pragma Assert (Result = Node);\n-            Free_Element (X);  -- OK if fails\n             return;\n          end if;\n-      end Insert_New_Item;\n-\n-      Reinsert_Old_Element : declare\n-         function New_Node return Node_Access;\n-         pragma Inline (New_Node);\n-\n-         procedure Insert_Post is\n-            new Element_Keys.Generic_Insert_Post (New_Node);\n-\n-         procedure Insert is\n-            new Element_Keys.Generic_Conditional_Insert (Insert_Post);\n-\n-         --------------\n-         -- New_Node --\n-         --------------\n-\n-         function New_Node return Node_Access is\n-         begin\n-            Node.Color := Red;\n-            Node.Parent := null;\n-            Node.Right := null;\n-            Node.Left := null;\n \n-            return Node;\n-         end New_Node;\n+      else\n+         pragma Assert (not (Hint.Element.all < Item));\n+         raise Program_Error with \"attempt to replace existing element\";\n+      end if;\n \n-         Result   : Node_Access;\n-         Inserted : Boolean;\n+      Tree_Operations.Delete_Node_Sans_Free (Tree, Node);  -- Checks busy-bit\n \n-      --  Start of processing for Reinsert_Old_Element\n+      Local_Insert_With_Hint\n+        (Tree     => Tree,\n+         Position => Hint,\n+         Key      => Item,\n+         Node     => Result,\n+         Inserted => Inserted);\n \n-      begin\n-         Insert\n-           (Tree    => Tree,\n-            Key     => Node.Element.all,\n-            Node    => Result,\n-            Success => Inserted);  --  TODO: change name of formal param\n-      exception\n-         when others =>\n-            null;\n-      end Reinsert_Old_Element;\n+      pragma Assert (Inserted);\n+      pragma Assert (Result = Node);\n \n-      raise Program_Error with \"attempt to replace existing element\";\n+      Free_Element (X);\n    end Replace_Element;\n \n    procedure Replace_Element"}, {"sha": "01058cd2fc661ad627468f611d2d366edb9abe56", "filename": "gcc/ada/a-cohama.adb", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3837bc7f8694ca43b734a327e3e37030371eeeea/gcc%2Fada%2Fa-cohama.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3837bc7f8694ca43b734a327e3e37030371eeeea/gcc%2Fada%2Fa-cohama.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cohama.adb?ref=3837bc7f8694ca43b734a327e3e37030371eeeea", "patch": "@@ -6,11 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2004-2005, Free Software Foundation, Inc.         --\n---                                                                          --\n--- This specification is derived from the Ada Reference Manual for use with --\n--- GNAT. The copyright notice above, and the license provisions that follow --\n--- apply solely to the  contents of the part following the private keyword. --\n+--          Copyright (C) 2004-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -566,10 +562,22 @@ package body Ada.Containers.Hashed_Maps is\n          Process (Cursor'(Container'Unchecked_Access, Node));\n       end Process_Node;\n \n+      B : Natural renames Container'Unrestricted_Access.HT.Busy;\n+\n    --  Start of processing for Iterate\n \n    begin\n-      Local_Iterate (Container.HT);\n+      B := B + 1;\n+\n+      begin\n+         Local_Iterate (Container.HT);\n+      exception\n+         when others =>\n+            B := B - 1;\n+            raise;\n+      end;\n+\n+      B := B - 1;\n    end Iterate;\n \n    ---------"}, {"sha": "0f0552a941df1cac2bb8d46ce2438dced2029126", "filename": "gcc/ada/a-cohase.adb", "status": "modified", "additions": 62, "deletions": 145, "changes": 207, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3837bc7f8694ca43b734a327e3e37030371eeeea/gcc%2Fada%2Fa-cohase.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3837bc7f8694ca43b734a327e3e37030371eeeea/gcc%2Fada%2Fa-cohase.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cohase.adb?ref=3837bc7f8694ca43b734a327e3e37030371eeeea", "patch": "@@ -6,11 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2004-2005, Free Software Foundation, Inc.         --\n---                                                                          --\n--- This specification is derived from the Ada Reference Manual for use with --\n--- GNAT. The copyright notice above, and the license provisions that follow --\n--- apply solely to the  contents of the part following the private keyword. --\n+--          Copyright (C) 2004-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -51,6 +47,9 @@ package body Ada.Containers.Hashed_Sets is\n    -- Local Subprograms --\n    -----------------------\n \n+   procedure Assign (Node : Node_Access; Item : Element_Type);\n+   pragma Inline (Assign);\n+\n    function Copy_Node (Source : Node_Access) return Node_Access;\n    pragma Inline (Copy_Node);\n \n@@ -90,11 +89,6 @@ package body Ada.Containers.Hashed_Sets is\n      return Node_Access;\n    pragma Inline (Read_Node);\n \n-   procedure Replace_Element\n-     (HT       : in out Hash_Table_Type;\n-      Node     : Node_Access;\n-      New_Item : Element_Type);\n-\n    procedure Set_Next (Node : Node_Access; Next : Node_Access);\n    pragma Inline (Set_Next);\n \n@@ -136,6 +130,9 @@ package body Ada.Containers.Hashed_Sets is\n    procedure Read_Nodes is\n       new HT_Ops.Generic_Read (Read_Node);\n \n+   procedure Replace_Element is\n+      new Element_Keys.Generic_Replace_Element (Hash_Node, Assign);\n+\n    procedure Write_Nodes is\n       new HT_Ops.Generic_Write (Write_Node);\n \n@@ -157,6 +154,15 @@ package body Ada.Containers.Hashed_Sets is\n       HT_Ops.Adjust (Container.HT);\n    end Adjust;\n \n+   ------------\n+   -- Assign --\n+   ------------\n+\n+   procedure Assign (Node : Node_Access; Item : Element_Type) is\n+   begin\n+      Node.Element := Item;\n+   end Assign;\n+\n    --------------\n    -- Capacity --\n    --------------\n@@ -264,24 +270,41 @@ package body Ada.Containers.Hashed_Sets is\n            \"attempt to tamper with elements (set is busy)\";\n       end if;\n \n-      --  TODO: This can be written in terms of a loop instead as\n-      --  active-iterator style, sort of like a passive iterator.\n+      if Source.HT.Length < Target.HT.Length then\n+         declare\n+            Src_Node : Node_Access;\n \n-      Tgt_Node := HT_Ops.First (Target.HT);\n-      while Tgt_Node /= null loop\n-         if Is_In (Source.HT, Tgt_Node) then\n-            declare\n-               X : Node_Access := Tgt_Node;\n-            begin\n-               Tgt_Node := HT_Ops.Next (Target.HT, Tgt_Node);\n-               HT_Ops.Delete_Node_Sans_Free (Target.HT, X);\n-               Free (X);\n-            end;\n+         begin\n+            Src_Node := HT_Ops.First (Source.HT);\n+            while Src_Node /= null loop\n+               Tgt_Node := Element_Keys.Find (Target.HT, Src_Node.Element);\n \n-         else\n-            Tgt_Node := HT_Ops.Next (Target.HT, Tgt_Node);\n-         end if;\n-      end loop;\n+               if Tgt_Node /= null then\n+                  HT_Ops.Delete_Node_Sans_Free (Target.HT, Tgt_Node);\n+                  Free (Tgt_Node);\n+               end if;\n+\n+               Src_Node := HT_Ops.Next (Source.HT, Src_Node);\n+            end loop;\n+         end;\n+\n+      else\n+         Tgt_Node := HT_Ops.First (Target.HT);\n+         while Tgt_Node /= null loop\n+            if Is_In (Source.HT, Tgt_Node) then\n+               declare\n+                  X : Node_Access := Tgt_Node;\n+               begin\n+                  Tgt_Node := HT_Ops.Next (Target.HT, Tgt_Node);\n+                  HT_Ops.Delete_Node_Sans_Free (Target.HT, X);\n+                  Free (X);\n+               end;\n+\n+            else\n+               Tgt_Node := HT_Ops.Next (Target.HT, Tgt_Node);\n+            end if;\n+         end loop;\n+      end if;\n    end Difference;\n \n    function Difference (Left, Right : Set) return Set is\n@@ -685,7 +708,7 @@ package body Ada.Containers.Hashed_Sets is\n          return;\n       end if;\n \n-      if Source.Length = 0 then\n+      if Source.HT.Length = 0 then\n          Clear (Target);\n          return;\n       end if;\n@@ -695,15 +718,6 @@ package body Ada.Containers.Hashed_Sets is\n            \"attempt to tamper with elements (set is busy)\";\n       end if;\n \n-      --  TODO: optimize this to use an explicit\n-      --  loop instead of an active iterator\n-      --  (similar to how a passive iterator is\n-      --  implemented).\n-      --\n-      --  Another possibility is to test which\n-      --  set is smaller, and iterate over the\n-      --  smaller set.\n-\n       Tgt_Node := HT_Ops.First (Target.HT);\n       while Tgt_Node /= null loop\n          if Is_In (Source.HT, Tgt_Node) then\n@@ -818,9 +832,6 @@ package body Ada.Containers.Hashed_Sets is\n          return False;\n       end if;\n \n-      --  TODO: rewrite this to loop in the\n-      --  style of a passive iterator.\n-\n       Subset_Node := HT_Ops.First (Subset.HT);\n       while Subset_Node /= null loop\n          if not Is_In (Of_Set.HT, Subset_Node) then\n@@ -855,13 +866,22 @@ package body Ada.Containers.Hashed_Sets is\n          Process (Cursor'(Container'Unrestricted_Access, Node));\n       end Process_Node;\n \n+      B : Natural renames Container'Unrestricted_Access.HT.Busy;\n+\n    --  Start of processing for Iterate\n \n    begin\n-      --  TODO: resolve whether HT_Ops.Generic_Iteration should\n-      --  manipulate busy bit.\n+      B := B + 1;\n+\n+      begin\n+         Iterate (Container.HT);\n+      exception\n+         when others =>\n+            B := B - 1;\n+            raise;\n+      end;\n \n-      Iterate (Container.HT);\n+      B := B - 1;\n    end Iterate;\n \n    ------------\n@@ -1047,109 +1067,6 @@ package body Ada.Containers.Hashed_Sets is\n       Node.Element := New_Item;\n    end Replace;\n \n-   ---------------------\n-   -- Replace_Element --\n-   ---------------------\n-\n-   procedure Replace_Element\n-     (HT       : in out Hash_Table_Type;\n-      Node     : Node_Access;\n-      New_Item : Element_Type)\n-   is\n-   begin\n-      if Equivalent_Elements (Node.Element, New_Item) then\n-         pragma Assert (Hash (Node.Element) = Hash (New_Item));\n-\n-         if HT.Lock > 0 then\n-            raise Program_Error with\n-              \"attempt to tamper with cursors (set is locked)\";\n-         end if;\n-\n-         Node.Element := New_Item;  --  Note that this assignment can fail\n-         return;\n-      end if;\n-\n-      if HT.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with elements (set is busy)\";\n-      end if;\n-\n-      HT_Ops.Delete_Node_Sans_Free (HT, Node);\n-\n-      Insert_New_Element : declare\n-         function New_Node (Next : Node_Access) return Node_Access;\n-         pragma Inline (New_Node);\n-\n-         procedure Local_Insert is\n-            new Element_Keys.Generic_Conditional_Insert (New_Node);\n-\n-         --------------\n-         -- New_Node --\n-         --------------\n-\n-         function New_Node (Next : Node_Access) return Node_Access is\n-         begin\n-            Node.Element := New_Item;  -- Note that this assignment can fail\n-            Node.Next := Next;\n-            return Node;\n-         end New_Node;\n-\n-         Result   : Node_Access;\n-         Inserted : Boolean;\n-\n-      --  Start of processing for Insert_New_Element\n-\n-      begin\n-         Local_Insert\n-           (HT       => HT,\n-            Key      => New_Item,\n-            Node     => Result,\n-            Inserted => Inserted);\n-\n-         if Inserted then\n-            return;\n-         end if;\n-      exception\n-         when others =>\n-            null;   --  Assignment must have failed\n-      end Insert_New_Element;\n-\n-      Reinsert_Old_Element : declare\n-         function New_Node (Next : Node_Access) return Node_Access;\n-         pragma Inline (New_Node);\n-\n-         procedure Local_Insert is\n-            new Element_Keys.Generic_Conditional_Insert (New_Node);\n-\n-         --------------\n-         -- New_Node --\n-         --------------\n-\n-         function New_Node (Next : Node_Access) return Node_Access is\n-         begin\n-            Node.Next := Next;\n-            return Node;\n-         end New_Node;\n-\n-         Result   : Node_Access;\n-         Inserted : Boolean;\n-\n-      --  Start of processing for Reinsert_Old_Element\n-\n-      begin\n-         Local_Insert\n-           (HT       => HT,\n-            Key      => Node.Element,\n-            Node     => Result,\n-            Inserted => Inserted);\n-      exception\n-         when others =>\n-            null;\n-      end Reinsert_Old_Element;\n-\n-      raise Program_Error with \"attempt to replace existing element\";\n-   end Replace_Element;\n-\n    procedure Replace_Element\n      (Container : in out Set;\n       Position  : Cursor;"}, {"sha": "bccd95145f8d7c790c42c2ae8235b40ef2ef4da9", "filename": "gcc/ada/a-coinve.adb", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3837bc7f8694ca43b734a327e3e37030371eeeea/gcc%2Fada%2Fa-coinve.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3837bc7f8694ca43b734a327e3e37030371eeeea/gcc%2Fada%2Fa-coinve.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-coinve.adb?ref=3837bc7f8694ca43b734a327e3e37030371eeeea", "patch": "@@ -8,10 +8,6 @@\n --                                                                          --\n --          Copyright (C) 2004-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n--- This specification is derived from the Ada Reference Manual for use with --\n--- GNAT. The copyright notice above, and the license provisions that follow --\n--- apply solely to the  contents of the part following the private keyword. --\n---                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n -- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n@@ -1052,7 +1048,7 @@ package body Ada.Containers.Indefinite_Vectors is\n          Old_Last_As_Int : constant Int := Int (Container.Last);\n \n       begin\n-         if Old_Last_As_Int > Int'Last - N then  -- see a-convec.adb  ???\n+         if Old_Last_As_Int > Int'Last - N then\n             raise Constraint_Error with \"new length is out of range\";\n          end if;\n \n@@ -1514,7 +1510,7 @@ package body Ada.Containers.Indefinite_Vectors is\n          Old_Last_As_Int : constant Int := Int (Container.Last);\n \n       begin\n-         if Old_Last_As_Int > Int'Last - N then  -- see a-convec.adb  ???\n+         if Old_Last_As_Int > Int'Last - N then\n             raise Constraint_Error with \"new length is out of range\";\n          end if;\n \n@@ -2586,12 +2582,6 @@ package body Ada.Containers.Indefinite_Vectors is\n \n       begin\n          for Indx in Index_Type'First .. Container.Last loop\n-\n-            --  There's another way to do this.  Instead a separate\n-            --  Boolean for each element, you could write a Boolean\n-            --  followed by a count of how many nulls or non-nulls\n-            --  follow in the array.  ???\n-\n             if E (Indx) = null then\n                Boolean'Write (Stream, False);\n             else"}, {"sha": "f08b70416a7196dcdce187da90dfb82950247d84", "filename": "gcc/ada/a-convec.adb", "status": "modified", "additions": 1, "deletions": 33, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3837bc7f8694ca43b734a327e3e37030371eeeea/gcc%2Fada%2Fa-convec.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3837bc7f8694ca43b734a327e3e37030371eeeea/gcc%2Fada%2Fa-convec.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-convec.adb?ref=3837bc7f8694ca43b734a327e3e37030371eeeea", "patch": "@@ -8,10 +8,6 @@\n --                                                                          --\n --          Copyright (C) 2004-2006 Free Software Foundation, Inc.          --\n --                                                                          --\n--- This specification is derived from the Ada Reference Manual for use with --\n--- GNAT. The copyright notice above, and the license provisions that follow --\n--- apply solely to the  contents of the part following the private keyword. --\n---                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n -- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n@@ -799,34 +795,6 @@ package body Ada.Containers.Vectors is\n \n       begin\n          if Old_Last_As_Int > Int'Last - N then\n-\n-            --  ???\n-\n-            --  The purpose of this test is to ensure that the calculation of\n-            --  New_Last_As_Int (see below) doesn't overflow.\n-\n-            --  This isn't quite right, since the only requirements are:\n-            --    V.Last <= Index_Type'Last\n-            --    V.Length <= Count_Type'Last\n-\n-            --  To be strictly correct there's no (explicit) requirement that\n-            --    Old_Last + N <= Int'Last\n-\n-            --  However, there might indeed be an implied requirement, since\n-            --  machine constraints dictate that\n-            --    Index_Type'Last <= Int'Last\n-            --  and so this check is perhaps proper after all.\n-\n-            --  This shouldn't be an issue in practice, since it can only\n-            --  happen when N is very large, or V.Last is near Int'Last.\n-\n-            --  N isn't likely to be large, since there's probably not enough\n-            --  storage.\n-\n-            --  V.Last would only be large if IT'First is very large (and\n-            --  V.Length has some \"normal\" size).  But typically IT'First is\n-            --  either 0 or 1.\n-\n             raise Constraint_Error with \"new length is out of range\";\n          end if;\n \n@@ -1282,7 +1250,7 @@ package body Ada.Containers.Vectors is\n          Old_Last_As_Int : constant Int := Int (Container.Last);\n \n       begin\n-         if Old_Last_As_Int > Int'Last - N then  -- see Insert ???\n+         if Old_Last_As_Int > Int'Last - N then\n             raise Constraint_Error with \"new length is out of range\";\n          end if;\n "}, {"sha": "d407feadfd1d700b220900d00672daeb2dfca825", "filename": "gcc/ada/a-coorse.adb", "status": "modified", "additions": 62, "deletions": 85, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3837bc7f8694ca43b734a327e3e37030371eeeea/gcc%2Fada%2Fa-coorse.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3837bc7f8694ca43b734a327e3e37030371eeeea/gcc%2Fada%2Fa-coorse.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-coorse.adb?ref=3837bc7f8694ca43b734a327e3e37030371eeeea", "patch": "@@ -6,11 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2004-2005, Free Software Foundation, Inc.         --\n---                                                                          --\n--- This specification is derived from the Ada Reference Manual for use with --\n--- GNAT. The copyright notice above, and the license provisions that follow --\n--- apply solely to the  contents of the part following the private keyword. --\n+--          Copyright (C) 2004-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -1375,11 +1371,49 @@ package body Ada.Containers.Ordered_Sets is\n       Node : Node_Access;\n       Item : Element_Type)\n    is\n+      pragma Assert (Node /= null);\n+\n+      function New_Node return Node_Access;\n+      pragma Inline (New_Node);\n+\n+      procedure Local_Insert_Post is\n+         new Element_Keys.Generic_Insert_Post (New_Node);\n+\n+      procedure Local_Insert_Sans_Hint is\n+         new Element_Keys.Generic_Conditional_Insert (Local_Insert_Post);\n+\n+      procedure Local_Insert_With_Hint is\n+         new Element_Keys.Generic_Conditional_Insert_With_Hint\n+        (Local_Insert_Post,\n+         Local_Insert_Sans_Hint);\n+\n+      --------------\n+      -- New_Node --\n+      --------------\n+\n+      function New_Node return Node_Access is\n+      begin\n+         Node.Element := Item;\n+         Node.Color := Red;\n+         Node.Parent := null;\n+         Node.Right := null;\n+         Node.Left := null;\n+\n+         return Node;\n+      end New_Node;\n+\n+      Hint      : Node_Access;\n+      Result    : Node_Access;\n+      Inserted  : Boolean;\n+\n+      --  Start of processing for Insert\n+\n    begin\n       if Item < Node.Element\n         or else Node.Element < Item\n       then\n          null;\n+\n       else\n          if Tree.Lock > 0 then\n             raise Program_Error with\n@@ -1390,95 +1424,38 @@ package body Ada.Containers.Ordered_Sets is\n          return;\n       end if;\n \n-      Tree_Operations.Delete_Node_Sans_Free (Tree, Node);  -- Checks busy-bit\n-\n-      Insert_New_Item : declare\n-         function New_Node return Node_Access;\n-         pragma Inline (New_Node);\n-\n-         procedure Insert_Post is\n-            new Element_Keys.Generic_Insert_Post (New_Node);\n+      Hint := Element_Keys.Ceiling (Tree, Item);\n \n-         procedure Insert is\n-            new Element_Keys.Generic_Conditional_Insert (Insert_Post);\n+      if Hint = null then\n+         null;\n \n-         --------------\n-         -- New_Node --\n-         --------------\n+      elsif Item < Hint.Element then\n+         if Hint = Node then\n+            if Tree.Lock > 0 then\n+               raise Program_Error with\n+                 \"attempt to tamper with cursors (set is locked)\";\n+            end if;\n \n-         function New_Node return Node_Access is\n-         begin\n             Node.Element := Item;\n-            Node.Color := Red;\n-            Node.Parent := null;\n-            Node.Right := null;\n-            Node.Left := null;\n-\n-            return Node;\n-         end New_Node;\n-\n-         Result   : Node_Access;\n-         Inserted : Boolean;\n-\n-      --  Start of processing for Insert_New_Item\n-\n-      begin\n-         Insert\n-           (Tree    => Tree,\n-            Key     => Item,\n-            Node    => Result,\n-            Success => Inserted);  --  TODO: change param name\n-\n-         if Inserted then\n-            pragma Assert (Result = Node);\n             return;\n          end if;\n-      exception\n-         when others =>\n-            null;  -- Assignment must have failed\n-      end Insert_New_Item;\n-\n-      Reinsert_Old_Element : declare\n-         function New_Node return Node_Access;\n-         pragma Inline (New_Node);\n-\n-         procedure Insert_Post is\n-            new Element_Keys.Generic_Insert_Post (New_Node);\n-\n-         procedure Insert is\n-            new Element_Keys.Generic_Conditional_Insert (Insert_Post);\n \n-         --------------\n-         -- New_Node --\n-         --------------\n-\n-         function New_Node return Node_Access is\n-         begin\n-            Node.Color := Red;\n-            Node.Parent := null;\n-            Node.Right := null;\n-            Node.Left := null;\n-\n-            return Node;\n-         end New_Node;\n-\n-         Result   : Node_Access;\n-         Inserted : Boolean;\n-\n-      --  Start of processing for Reinsert_Old_Element\n+      else\n+         pragma Assert (not (Hint.Element < Item));\n+         raise Program_Error with \"attempt to replace existing element\";\n+      end if;\n \n-      begin\n-         Insert\n-           (Tree    => Tree,\n-            Key     => Node.Element,\n-            Node    => Result,\n-            Success => Inserted);  --  TODO: change param name\n-      exception\n-         when others =>\n-            null;  -- Assignment must have failed\n-      end Reinsert_Old_Element;\n+      Tree_Operations.Delete_Node_Sans_Free (Tree, Node);  -- Checks busy-bit\n \n-      raise Program_Error with \"attempt to replace existing element\";\n+      Local_Insert_With_Hint\n+        (Tree     => Tree,\n+         Position => Hint,\n+         Key      => Item,\n+         Node     => Result,\n+         Inserted => Inserted);\n+\n+      pragma Assert (Inserted);\n+      pragma Assert (Result = Node);\n    end Replace_Element;\n \n    procedure Replace_Element"}, {"sha": "f90568d33eca8fef29cc152bb37a05b1a8908c36", "filename": "gcc/ada/a-crbtgk.adb", "status": "modified", "additions": 198, "deletions": 149, "changes": 347, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3837bc7f8694ca43b734a327e3e37030371eeeea/gcc%2Fada%2Fa-crbtgk.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3837bc7f8694ca43b734a327e3e37030371eeeea/gcc%2Fada%2Fa-crbtgk.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-crbtgk.adb?ref=3837bc7f8694ca43b734a327e3e37030371eeeea", "patch": "@@ -7,11 +7,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2004-2005, Free Software Foundation, Inc.         --\n---                                                                          --\n--- This specification is derived from the Ada Reference Manual for use with --\n--- GNAT. The copyright notice above, and the license provisions that follow --\n--- apply solely to the  contents of the part following the private keyword. --\n+--          Copyright (C) 2004-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -44,11 +40,12 @@ package body Ada.Containers.Red_Black_Trees.Generic_Keys is\n \n    --  AKA Lower_Bound\n \n-   function Ceiling (Tree : Tree_Type; Key  : Key_Type) return Node_Access is\n+   function Ceiling (Tree : Tree_Type; Key : Key_Type) return Node_Access is\n       Y : Node_Access;\n-      X : Node_Access := Tree.Root;\n+      X : Node_Access;\n \n    begin\n+      X := Tree.Root;\n       while X /= null loop\n          if Is_Greater_Key_Node (Key, X) then\n             X := Ops.Right (X);\n@@ -67,9 +64,10 @@ package body Ada.Containers.Red_Black_Trees.Generic_Keys is\n \n    function Find (Tree : Tree_Type; Key  : Key_Type) return Node_Access is\n       Y : Node_Access;\n-      X : Node_Access := Tree.Root;\n+      X : Node_Access;\n \n    begin\n+      X := Tree.Root;\n       while X /= null loop\n          if Is_Greater_Key_Node (Key, X) then\n             X := Ops.Right (X);\n@@ -96,9 +94,10 @@ package body Ada.Containers.Red_Black_Trees.Generic_Keys is\n \n    function Floor (Tree : Tree_Type; Key  : Key_Type) return Node_Access is\n       Y : Node_Access;\n-      X : Node_Access := Tree.Root;\n+      X : Node_Access;\n \n    begin\n+      X := Tree.Root;\n       while X /= null loop\n          if Is_Less_Key_Node (Key, X) then\n             X := Ops.Left (X);\n@@ -116,143 +115,189 @@ package body Ada.Containers.Red_Black_Trees.Generic_Keys is\n    --------------------------------\n \n    procedure Generic_Conditional_Insert\n-     (Tree    : in out Tree_Type;\n-      Key     : Key_Type;\n-      Node    : out Node_Access;\n-      Success : out Boolean)\n+     (Tree     : in out Tree_Type;\n+      Key      : Key_Type;\n+      Node     : out Node_Access;\n+      Inserted : out Boolean)\n    is\n       Y : Node_Access := null;\n       X : Node_Access := Tree.Root;\n \n    begin\n-      Success := True;\n+      Inserted := True;\n       while X /= null loop\n          Y := X;\n-         Success := Is_Less_Key_Node (Key, X);\n+         Inserted := Is_Less_Key_Node (Key, X);\n \n-         if Success then\n+         if Inserted then\n             X := Ops.Left (X);\n          else\n             X := Ops.Right (X);\n          end if;\n       end loop;\n \n-      Node := Y;\n+      --  If Inserted is True, then this means either that Tree is\n+      --  empty, or there was a least one node (strictly) greater than\n+      --  Key. Otherwise, it means that Key is equal to or greater than\n+      --  every node.\n \n-      if Success then\n-         if Node = Tree.First then\n-            Insert_Post (Tree, X, Y, Key, Node);\n+      if Inserted then\n+         if Y = Tree.First then\n+            Insert_Post (Tree, Y, True, Node);\n             return;\n          end if;\n \n-         Node := Ops.Previous (Node);\n+         Node := Ops.Previous (Y);\n+\n+      else\n+         Node := Y;\n       end if;\n \n+      --  Here Node has a value that is less than or equal to Key. We\n+      --  now have to resolve whether Key is equal to or greater than\n+      --  Node, which determines whether the insertion succeeds.\n+\n       if Is_Greater_Key_Node (Key, Node) then\n-         Insert_Post (Tree, X, Y, Key, Node);\n-         Success := True;\n+         Insert_Post (Tree, Y, Inserted, Node);\n+         Inserted := True;\n          return;\n       end if;\n \n-      Success := False;\n+      Inserted := False;\n    end Generic_Conditional_Insert;\n \n    ------------------------------------------\n    -- Generic_Conditional_Insert_With_Hint --\n    ------------------------------------------\n \n    procedure Generic_Conditional_Insert_With_Hint\n-     (Tree     : in out Tree_Type;\n-      Position : Node_Access;\n-      Key      : Key_Type;\n-      Node     : out Node_Access;\n-      Success  : out Boolean)\n+     (Tree      : in out Tree_Type;\n+      Position  : Node_Access;\n+      Key       : Key_Type;\n+      Node      : out Node_Access;\n+      Inserted  : out Boolean)\n    is\n    begin\n+      --  The purpose of a hint is to avoid a search from the root of\n+      --  tree. If we have it hint it means we only need to traverse the\n+      --  subtree rooted at the hint to find the nearest neighbor. Note\n+      --  that finding the neighbor means merely walking the tree; this\n+      --  is not a search and the only comparisons that occur are with\n+      --  the hint and its neighbor.\n+\n+      --  If Position is null, this is intepreted to mean that Key is\n+      --  large relative to the nodes in the tree. If the tree is empty,\n+      --  or Key is greater than the last node in the tree, then we're\n+      --  done; otherwise the hint was \"wrong\" and we must search.\n+\n       if Position = null then  -- largest\n-         if Tree.Length > 0\n-           and then Is_Greater_Key_Node (Key, Tree.Last)\n+         if Tree.Last = null\n+           or else Is_Greater_Key_Node (Key, Tree.Last)\n          then\n-            Insert_Post (Tree, null, Tree.Last, Key, Node);\n-            Success := True;\n+            Insert_Post (Tree, Tree.Last, False, Node);\n+            Inserted := True;\n          else\n-            Conditional_Insert_Sans_Hint (Tree, Key, Node, Success);\n+            Conditional_Insert_Sans_Hint (Tree, Key, Node, Inserted);\n          end if;\n \n          return;\n       end if;\n \n       pragma Assert (Tree.Length > 0);\n \n-      if Is_Less_Key_Node (Key, Position) then\n-         if Position = Tree.First then\n-            Insert_Post (Tree, Position, Position, Key, Node);\n-            Success := True;\n-            return;\n-         end if;\n+      --  A hint can either name the node that immediately follows Key,\n+      --  or immediately precedes Key. We first test whether Key is is\n+      --  less than the hint, and if so we compare Key to the node that\n+      --  precedes the hint. If Key is both less than the hint and\n+      --  greater than the hint's preceding neighbor, then we're done;\n+      --  otherwise we must search.\n+\n+      --  Note also that a hint can either be an anterior node or a leaf\n+      --  node. A new node is always inserted at the bottom of the tree\n+      --  (at least prior to rebalancing), becoming the new left or\n+      --  right child of leaf node (which prior to the insertion must\n+      --  necessarily be null, since this is a leaf). If the hint names\n+      --  an anterior node then its neighbor must be a leaf, and so\n+      --  (here) we insert after the neighbor. If the hint names a leaf\n+      --  then its neighbor must be anterior and so we insert before the\n+      --  hint.\n \n+      if Is_Less_Key_Node (Key, Position) then\n          declare\n             Before : constant Node_Access := Ops.Previous (Position);\n \n          begin\n-            if Is_Greater_Key_Node (Key, Before) then\n+            if Before = null then\n+               Insert_Post (Tree, Tree.First, True, Node);\n+               Inserted := True;\n+\n+            elsif Is_Greater_Key_Node (Key, Before) then\n                if Ops.Right (Before) = null then\n-                  Insert_Post (Tree, null, Before, Key, Node);\n+                  Insert_Post (Tree, Before, False, Node);\n                else\n-                  Insert_Post (Tree, Position, Position, Key, Node);\n+                  Insert_Post (Tree, Position, True, Node);\n                end if;\n \n-               Success := True;\n+               Inserted := True;\n \n             else\n-               Conditional_Insert_Sans_Hint (Tree, Key, Node, Success);\n+               Conditional_Insert_Sans_Hint (Tree, Key, Node, Inserted);\n             end if;\n          end;\n \n          return;\n       end if;\n \n-      if Is_Greater_Key_Node (Key, Position) then\n-         if Position = Tree.Last then\n-            Insert_Post (Tree, null, Tree.Last, Key, Node);\n-            Success := True;\n-            return;\n-         end if;\n+      --  We know that Key isn't less than the hint so we try again,\n+      --  this time to see if it's greater than the hint. If so we\n+      --  compare Key to the node that follows the hint. If Key is both\n+      --  greater than the hint and less than the hint's next neighbor,\n+      --  then we're done; otherwise we must search.\n \n+      if Is_Greater_Key_Node (Key, Position) then\n          declare\n             After : constant Node_Access := Ops.Next (Position);\n \n          begin\n-            if Is_Less_Key_Node (Key, After) then\n+            if After = null then\n+               Insert_Post (Tree, Tree.Last, False, Node);\n+               Inserted := True;\n+\n+            elsif Is_Less_Key_Node (Key, After) then\n                if Ops.Right (Position) = null then\n-                  Insert_Post (Tree, null, Position, Key, Node);\n+                  Insert_Post (Tree, Position, False, Node);\n                else\n-                  Insert_Post (Tree, After, After, Key, Node);\n+                  Insert_Post (Tree, After, True, Node);\n                end if;\n \n-               Success := True;\n+               Inserted := True;\n \n             else\n-               Conditional_Insert_Sans_Hint (Tree, Key, Node, Success);\n+               Conditional_Insert_Sans_Hint (Tree, Key, Node, Inserted);\n             end if;\n          end;\n \n          return;\n       end if;\n \n+      --  We know that Key is neither less than the hint nor greater\n+      --  than the hint, and that's the definition of equivalence.\n+      --  There's nothing else we need to do, since a search would just\n+      --  reach the same conclusion.\n+\n       Node := Position;\n-      Success := False;\n+      Inserted := False;\n    end Generic_Conditional_Insert_With_Hint;\n \n    -------------------------\n    -- Generic_Insert_Post --\n    -------------------------\n \n    procedure Generic_Insert_Post\n-     (Tree : in out Tree_Type;\n-      X, Y : Node_Access;\n-      Key  : Key_Type;\n-      Z    : out Node_Access)\n+     (Tree   : in out Tree_Type;\n+      Y      : Node_Access;\n+      Before : Boolean;\n+      Z      : out Node_Access)\n    is\n    begin\n       if Tree.Length = Count_Type'Last then\n@@ -264,50 +309,32 @@ package body Ada.Containers.Red_Black_Trees.Generic_Keys is\n            \"attempt to tamper with cursors (container is busy)\";\n       end if;\n \n-      if Y = null\n-        or else X /= null\n-        or else Is_Less_Key_Node (Key, Y)\n-      then\n-         pragma Assert (Y = null\n-                          or else Ops.Left (Y) = null);\n+      Z := New_Node;\n+      pragma Assert (Z /= null);\n+      pragma Assert (Ops.Color (Z) = Red);\n \n-         --  Delay allocation as long as we can, in order to defend\n-         --  against exceptions propagated by relational operators.\n+      if Y = null then\n+         pragma Assert (Tree.Length = 0);\n+         pragma Assert (Tree.Root = null);\n+         pragma Assert (Tree.First = null);\n+         pragma Assert (Tree.Last = null);\n \n-         Z := New_Node;\n+         Tree.Root := Z;\n+         Tree.First := Z;\n+         Tree.Last := Z;\n \n-         pragma Assert (Z /= null);\n-         pragma Assert (Ops.Color (Z) = Red);\n+      elsif Before then\n+         pragma Assert (Ops.Left (Y) = null);\n \n-         if Y = null then\n-            pragma Assert (Tree.Length = 0);\n-            pragma Assert (Tree.Root = null);\n-            pragma Assert (Tree.First = null);\n-            pragma Assert (Tree.Last = null);\n+         Ops.Set_Left (Y, Z);\n \n-            Tree.Root := Z;\n+         if Y = Tree.First then\n             Tree.First := Z;\n-            Tree.Last := Z;\n-\n-         else\n-            Ops.Set_Left (Y, Z);\n-\n-            if Y = Tree.First then\n-               Tree.First := Z;\n-            end if;\n          end if;\n \n       else\n          pragma Assert (Ops.Right (Y) = null);\n \n-         --  Delay allocation as long as we can, in order to defend\n-         --  against exceptions propagated by relational operators.\n-\n-         Z := New_Node;\n-\n-         pragma Assert (Z /= null);\n-         pragma Assert (Ops.Color (Z) = Red);\n-\n          Ops.Set_Right (Y, Z);\n \n          if Y = Tree.Last then\n@@ -335,8 +362,9 @@ package body Ada.Containers.Red_Black_Trees.Generic_Keys is\n       -------------\n \n       procedure Iterate (Node : Node_Access) is\n-         N : Node_Access := Node;\n+         N : Node_Access;\n       begin\n+         N := Node;\n          while N /= null loop\n             if Is_Less_Key_Node (Key, N) then\n                N := Ops.Left (N);\n@@ -371,8 +399,9 @@ package body Ada.Containers.Red_Black_Trees.Generic_Keys is\n       -------------\n \n       procedure Iterate (Node : Node_Access) is\n-         N : Node_Access := Node;\n+         N : Node_Access;\n       begin\n+         N := Node;\n          while N /= null loop\n             if Is_Less_Key_Node (Key, N) then\n                N := Ops.Left (N);\n@@ -401,21 +430,28 @@ package body Ada.Containers.Red_Black_Trees.Generic_Keys is\n       Key  : Key_Type;\n       Node : out Node_Access)\n    is\n-      Y : Node_Access := null;\n-      X : Node_Access := Tree.Root;\n+      Y : Node_Access;\n+      X : Node_Access;\n+\n+      Before : Boolean;\n \n    begin\n+      Y := null;\n+      Before := False;\n+\n+      X := Tree.Root;\n       while X /= null loop\n          Y := X;\n+         Before := Is_Less_Key_Node (Key, X);\n \n-         if Is_Less_Key_Node (Key, X) then\n+         if Before then\n             X := Ops.Left (X);\n          else\n             X := Ops.Right (X);\n          end if;\n       end loop;\n \n-      Insert_Post (Tree, X, Y, Key, Node);\n+      Insert_Post (Tree, Y, Before, Node);\n    end Generic_Unconditional_Insert;\n \n    --------------------------------------------\n@@ -428,76 +464,88 @@ package body Ada.Containers.Red_Black_Trees.Generic_Keys is\n       Key  : Key_Type;\n       Node : out Node_Access)\n    is\n-      --  TODO: verify this algorithm.  It was (quickly) adapted it from the\n-      --  same algorithm for conditional_with_hint. It may be that the test\n-      --  Key > Hint should be something like a Key >= Hint, to handle the\n-      --  case when Hint is The Last Item of A (Contiguous) sequence of\n-      --  Equivalent Items.  (The Key < Hint Test is probably OK. It is not\n-      --  clear that you can use Key <= Hint, since new items are always\n-      --  inserted last in the sequence of equivalent items.) ???\n-\n    begin\n+      --  There are fewer constraints for an unconditional insertion\n+      --  than for a conditional insertion, since we allow duplicate\n+      --  keys. So instead of having to check (say) whether Key is\n+      --  (strictly) greater than the hint's previous neighbor, here we\n+      --  allow Key to be equal to or greater than the previous node.\n+\n+      --  There is the issue of what to do if Key is equivalent to the\n+      --  hint. Does the new node get inserted before or after the hint?\n+      --  We decide that it gets inserted after the hint, reasoning that\n+      --  this is consistent with behavior for non-hint insertion, which\n+      --  inserts a new node after existing nodes with equivalent keys.\n+\n+      --  First we check whether the hint is null, which is interpreted\n+      --  to mean that Key is large relative to existing nodes.\n+      --  Following our rule above, if Key is equal to or greater than\n+      --  the last node, then we insert the new node immediately after\n+      --  last. (We don't have an operation for testing whether a key is\n+      --  \"equal to or greater than\" a node, so we must say instead \"not\n+      --  less than\", which is equivalent.)\n+\n       if Hint = null then  -- largest\n-         if Tree.Length > 0\n-           and then Is_Greater_Key_Node (Key, Tree.Last)\n-         then\n-            Insert_Post (Tree, null, Tree.Last, Key, Node);\n-         else\n+         if Tree.Last = null then\n+            Insert_Post (Tree, null, False, Node);\n+         elsif Is_Less_Key_Node (Key, Tree.Last) then\n             Unconditional_Insert_Sans_Hint (Tree, Key, Node);\n+         else\n+            Insert_Post (Tree, Tree.Last, False, Node);\n          end if;\n \n          return;\n       end if;\n \n       pragma Assert (Tree.Length > 0);\n \n-      if Is_Less_Key_Node (Key, Hint) then\n-         if Hint = Tree.First then\n-            Insert_Post (Tree, Hint, Hint, Key, Node);\n-            return;\n-         end if;\n+      --  We decide here whether to insert the new node prior to the\n+      --  hint. Key could be equivalent to the hint, so in theory we\n+      --  could write the following test as \"not greater than\" (same as\n+      --  \"less than or equal to\"). If Key were equivalent to the hint,\n+      --  that would mean that the new node gets inserted before an\n+      --  equivalent node. That wouldn't break any container invariants,\n+      --  but our rule above says that new nodes always get inserted\n+      --  after equivalent nodes. So here we test whether Key is both\n+      --  less than the hint and and equal to or greater than the hint's\n+      --  previous neighbor, and if so insert it before the hint.\n \n+      if Is_Less_Key_Node (Key, Hint) then\n          declare\n             Before : constant Node_Access := Ops.Previous (Hint);\n          begin\n-            if Is_Greater_Key_Node (Key, Before) then\n-               if Ops.Right (Before) = null then\n-                  Insert_Post (Tree, null, Before, Key, Node);\n-               else\n-                  Insert_Post (Tree, Hint, Hint, Key, Node);\n-               end if;\n-            else\n+            if Before = null then\n+               Insert_Post (Tree, Hint, True, Node);\n+            elsif Is_Less_Key_Node (Key, Before) then\n                Unconditional_Insert_Sans_Hint (Tree, Key, Node);\n-            end if;\n-         end;\n-\n-         return;\n-      end if;\n-\n-      if Is_Greater_Key_Node (Key, Hint) then\n-         if Hint = Tree.Last then\n-            Insert_Post (Tree, null, Tree.Last, Key, Node);\n-            return;\n-         end if;\n-\n-         declare\n-            After : constant Node_Access := Ops.Next (Hint);\n-         begin\n-            if Is_Less_Key_Node (Key, After) then\n-               if Ops.Right (Hint) = null then\n-                  Insert_Post (Tree, null, Hint, Key, Node);\n-               else\n-                  Insert_Post (Tree, After, After, Key, Node);\n-               end if;\n+            elsif Ops.Right (Before) = null then\n+               Insert_Post (Tree, Before, False, Node);\n             else\n-               Unconditional_Insert_Sans_Hint (Tree, Key, Node);\n+               Insert_Post (Tree, Hint, True, Node);\n             end if;\n          end;\n \n          return;\n       end if;\n \n-      Unconditional_Insert_Sans_Hint (Tree, Key, Node);\n+      --  We know that Key isn't less than the hint, so it must be equal\n+      --  or greater. So we just test whether Key is less than or equal\n+      --  to (same as \"not greater than\") the hint's next neighbor, and\n+      --  if so insert it after the hint.\n+\n+      declare\n+         After : constant Node_Access := Ops.Next (Hint);\n+      begin\n+         if After = null then\n+            Insert_Post (Tree, Hint, False, Node);\n+         elsif Is_Greater_Key_Node (Key, After) then\n+            Unconditional_Insert_Sans_Hint (Tree, Key, Node);\n+         elsif Ops.Right (Hint) = null then\n+            Insert_Post (Tree, Hint, False, Node);\n+         else\n+            Insert_Post (Tree, After, True, Node);\n+         end if;\n+      end;\n    end Generic_Unconditional_Insert_With_Hint;\n \n    -----------------\n@@ -509,9 +557,10 @@ package body Ada.Containers.Red_Black_Trees.Generic_Keys is\n       Key  : Key_Type) return Node_Access\n    is\n       Y : Node_Access;\n-      X : Node_Access := Tree.Root;\n+      X : Node_Access;\n \n    begin\n+      X := Tree.Root;\n       while X /= null loop\n          if Is_Less_Key_Node (Key, X) then\n             Y := X;"}, {"sha": "1e8c4fd9eb2345b14964e83799054902ae5152c1", "filename": "gcc/ada/a-crbtgk.ads", "status": "modified", "additions": 93, "deletions": 34, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3837bc7f8694ca43b734a327e3e37030371eeeea/gcc%2Fada%2Fa-crbtgk.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3837bc7f8694ca43b734a327e3e37030371eeeea/gcc%2Fada%2Fa-crbtgk.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-crbtgk.ads?ref=3837bc7f8694ca43b734a327e3e37030371eeeea", "patch": "@@ -7,13 +7,32 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n--- This specification is adapted from the Ada Reference Manual for use with --\n--- GNAT.  In accordance with the copyright of that document, you can freely --\n--- copy and modify this specification,  provided that if you redistribute a --\n--- modified version,  any changes that you have made are clearly indicated. --\n+--          Copyright (C) 2004-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- This unit was originally developed by Matthew J Heaney.                  --\n ------------------------------------------------------------------------------\n \n+--  Tree_Type is used to implement ordered containers. This package declares\n+--  the tree operations that depend on keys.\n+\n with Ada.Containers.Red_Black_Trees.Generic_Operations;\n \n generic\n@@ -37,42 +56,58 @@ package Ada.Containers.Red_Black_Trees.Generic_Keys is\n    generic\n       with function New_Node return Node_Access;\n    procedure Generic_Insert_Post\n-     (Tree : in out Tree_Type;\n-      X, Y : Node_Access;\n-      Key  : Key_Type;\n-      Z    : out Node_Access);\n+     (Tree   : in out Tree_Type;\n+      Y      : Node_Access;\n+      Before : Boolean;\n+      Z      : out Node_Access);\n+   --  Completes an insertion after the insertion position has been\n+   --  determined. On output Z contains a pointer to the newly inserted\n+   --  node, allocated using New_Node. If Tree is busy then\n+   --  Program_Error is raised. If Y is null, then Tree must be empty.\n+   --  Otherwise Y denotes the insertion position, and Before specifies\n+   --  whether the new node is Y's left (True) or right (False) child.\n \n    generic\n       with procedure Insert_Post\n-        (Tree : in out Tree_Type;\n-         X, Y : Node_Access;\n-         Key  : Key_Type;\n-         Z    : out Node_Access);\n+        (T : in out Tree_Type;\n+         Y : Node_Access;\n+         B : Boolean;\n+         Z : out Node_Access);\n \n    procedure Generic_Conditional_Insert\n-     (Tree    : in out Tree_Type;\n-      Key     : Key_Type;\n-      Node    : out Node_Access;\n-      Success : out Boolean);\n+     (Tree     : in out Tree_Type;\n+      Key      : Key_Type;\n+      Node     : out Node_Access;\n+      Inserted : out Boolean);\n+   --  Inserts a new node in Tree, but only if the tree does not already\n+   --  contain Key. Generic_Conditional_Insert first searches for a key\n+   --  equivalent to Key in Tree. If an equivalent key is found, then on\n+   --  output Node designates the node with that key and Inserted is\n+   --  False; there is no allocation and Tree is not modified. Otherwise\n+   --  Node designates a new node allocated using Insert_Post, and\n+   --  Inserted is True.\n \n    generic\n       with procedure Insert_Post\n-        (Tree : in out Tree_Type;\n-         X, Y : Node_Access;\n-         Key  : Key_Type;\n-         Z    : out Node_Access);\n+        (T : in out Tree_Type;\n+         Y : Node_Access;\n+         B : Boolean;\n+         Z : out Node_Access);\n \n    procedure Generic_Unconditional_Insert\n      (Tree : in out Tree_Type;\n       Key  : Key_Type;\n       Node : out Node_Access);\n+   --  Inserts a new node in Tree. On output Node designates the new\n+   --  node, which is allocated using Insert_Post. The node is inserted\n+   --  immediately after already-existing equivalent keys.\n \n    generic\n       with procedure Insert_Post\n-        (Tree : in out Tree_Type;\n-         X, Y : Node_Access;\n-         Key  : Key_Type;\n-         Z    : out Node_Access);\n+        (T : in out Tree_Type;\n+         Y : Node_Access;\n+         B : Boolean;\n+         Z : out Node_Access);\n \n       with procedure Unconditional_Insert_Sans_Hint\n         (Tree    : in out Tree_Type;\n@@ -84,53 +119,77 @@ package Ada.Containers.Red_Black_Trees.Generic_Keys is\n       Hint : Node_Access;\n       Key  : Key_Type;\n       Node : out Node_Access);\n+   --  Inserts a new node in Tree near position Hint, to avoid having to\n+   --  search from the root for the insertion position. If Hint is null\n+   --  then Generic_Unconditional_Insert_With_Hint attempts to insert\n+   --  the new node after Tree.Last. If Hint is non-null then if Key is\n+   --  less than Hint, it attempts to insert the new node immediately\n+   --  prior to Hint. Otherwise it attempts to insert the node\n+   --  immediately following Hint. We say \"attempts\" above to emphasize\n+   --  that insertions always preserve invariants with respect to key\n+   --  order, even when there's a hint. So if Key can't be inserted\n+   --  immediately near Hint, then the new node is inserted in the\n+   --  normal way, by searching for the correct position starting from\n+   --  the root.\n \n    generic\n       with procedure Insert_Post\n-        (Tree : in out Tree_Type;\n-         X, Y : Node_Access;\n-         Key  : Key_Type;\n-         Z    : out Node_Access);\n+        (T : in out Tree_Type;\n+         Y : Node_Access;\n+         B : Boolean;\n+         Z : out Node_Access);\n \n       with procedure Conditional_Insert_Sans_Hint\n-        (Tree    : in out Tree_Type;\n-         Key     : Key_Type;\n-         Node    : out Node_Access;\n-         Success : out Boolean);\n+        (Tree     : in out Tree_Type;\n+         Key      : Key_Type;\n+         Node     : out Node_Access;\n+         Inserted : out Boolean);\n \n    procedure Generic_Conditional_Insert_With_Hint\n      (Tree     : in out Tree_Type;\n-      Position : Node_Access;\n+      Position : Node_Access;       -- the hint\n       Key      : Key_Type;\n       Node     : out Node_Access;\n-      Success  : out Boolean);\n+      Inserted : out Boolean);\n+   --  Inserts a new node in Tree if the tree does not already contain\n+   --  Key, using Position as a hint about where to insert the new node.\n+   --  See Generic_Unconditional_Insert_With_Hint for more details about\n+   --  hint semantics.\n \n    function Find\n      (Tree : Tree_Type;\n       Key  : Key_Type) return Node_Access;\n+   --  Searches Tree for the smallest node equivalent to Key\n \n    function Ceiling\n      (Tree : Tree_Type;\n       Key  : Key_Type) return Node_Access;\n+   --  Searches Tree for the smallest node equal to or greater than Key\n \n    function Floor\n      (Tree : Tree_Type;\n       Key  : Key_Type) return Node_Access;\n+   --  Searches Tree for the largest node less than or equal to Key\n \n    function Upper_Bound\n      (Tree : Tree_Type;\n       Key  : Key_Type) return Node_Access;\n+   --  Searches Tree for the smallest node greater than Key\n \n    generic\n       with procedure Process (Node : Node_Access);\n    procedure Generic_Iteration\n      (Tree : Tree_Type;\n       Key  : Key_Type);\n+   --  Calls Process for each node in Tree equivalent to Key, in order\n+   --  from earliest in range to latest.\n \n    generic\n       with procedure Process (Node : Node_Access);\n    procedure Generic_Reverse_Iteration\n      (Tree : Tree_Type;\n       Key  : Key_Type);\n+   --  Calls Process for each node in Tree equivalent to Key, but in\n+   --  order from largest in range to earliest.\n \n end Ada.Containers.Red_Black_Trees.Generic_Keys;"}, {"sha": "a9f63942fe1c243670c783736ddaca9aa726c829", "filename": "gcc/ada/a-crbtgo.adb", "status": "modified", "additions": 14, "deletions": 27, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3837bc7f8694ca43b734a327e3e37030371eeeea/gcc%2Fada%2Fa-crbtgo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3837bc7f8694ca43b734a327e3e37030371eeeea/gcc%2Fada%2Fa-crbtgo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-crbtgo.adb?ref=3837bc7f8694ca43b734a327e3e37030371eeeea", "patch": "@@ -9,10 +9,6 @@\n --                                                                          --\n --          Copyright (C) 2004-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n--- This specification is derived from the Ada Reference Manual for use with --\n--- GNAT. The copyright notice above, and the license provisions that follow --\n--- apply solely to the  contents of the part following the private keyword. --\n---                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n -- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n@@ -34,6 +30,13 @@\n -- This unit was originally developed by Matthew J Heaney.                  --\n ------------------------------------------------------------------------------\n \n+--  The references below to \"CLR\" refer to the following book, from which\n+--  several of the algorithms here were adapted:\n+--     Introduction to Algorithms\n+--     by Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest\n+--     Publisher: The MIT Press (June 18, 1990)\n+--     ISBN: 0262031418\n+\n with System;  use type System.Address;\n \n package body Ada.Containers.Red_Black_Trees.Generic_Operations is\n@@ -141,7 +144,7 @@ package body Ada.Containers.Red_Black_Trees.Generic_Operations is\n \n    procedure Delete_Fixup (Tree : in out Tree_Type; Node : Node_Access) is\n \n-      --  CLR p274 ???\n+      --  CLR p274\n \n       X : Node_Access := Node;\n       W : Node_Access;\n@@ -237,7 +240,7 @@ package body Ada.Containers.Red_Black_Trees.Generic_Operations is\n      (Tree : in out Tree_Type;\n       Node : Node_Access)\n    is\n-      --  CLR p273 ???\n+      --  CLR p273\n \n       X, Y : Node_Access;\n \n@@ -804,7 +807,7 @@ package body Ada.Containers.Red_Black_Trees.Generic_Operations is\n \n    procedure Left_Rotate (Tree : in out Tree_Type; X : Node_Access) is\n \n-      --  CLR p266 ???\n+      --  CLR p266\n \n       Y : constant Node_Access := Right (X);\n       pragma Assert (Y /= null);\n@@ -837,7 +840,7 @@ package body Ada.Containers.Red_Black_Trees.Generic_Operations is\n \n    function Max (Node : Node_Access) return Node_Access is\n \n-      --  CLR p248 ???\n+      --  CLR p248\n \n       X : Node_Access := Node;\n       Y : Node_Access;\n@@ -860,7 +863,7 @@ package body Ada.Containers.Red_Black_Trees.Generic_Operations is\n \n    function Min (Node : Node_Access) return Node_Access is\n \n-      --  CLR p248 ???\n+      --  CLR p248\n \n       X : Node_Access := Node;\n       Y : Node_Access;\n@@ -883,7 +886,7 @@ package body Ada.Containers.Red_Black_Trees.Generic_Operations is\n \n    function Next (Node : Node_Access) return Node_Access is\n    begin\n-      --  CLR p249 ???\n+      --  CLR p249\n \n       if Node = null then\n          return null;\n@@ -905,14 +908,6 @@ package body Ada.Containers.Red_Black_Trees.Generic_Operations is\n             Y := Parent (Y);\n          end loop;\n \n-         --  Why is this code commented out ???\n-\n---           if Right (X) /= Y then\n---              return Y;\n---           else\n---              return X;\n---           end if;\n-\n          return Y;\n       end;\n    end Next;\n@@ -943,14 +938,6 @@ package body Ada.Containers.Red_Black_Trees.Generic_Operations is\n             Y := Parent (Y);\n          end loop;\n \n-         --  Why is this code commented out ???\n-\n---           if Left (X) /= Y then\n---              return Y;\n---           else\n---              return X;\n---           end if;\n-\n          return Y;\n       end;\n    end Previous;\n@@ -963,7 +950,7 @@ package body Ada.Containers.Red_Black_Trees.Generic_Operations is\n      (Tree : in out Tree_Type;\n       Node : Node_Access)\n    is\n-      --  CLR p.268 ???\n+      --  CLR p.268\n \n       X : Node_Access := Node;\n       pragma Assert (X /= null);"}, {"sha": "0415f5be2de0347039c58c385b423b8fefba32b1", "filename": "gcc/ada/a-crbtgo.ads", "status": "modified", "additions": 42, "deletions": 5, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3837bc7f8694ca43b734a327e3e37030371eeeea/gcc%2Fada%2Fa-crbtgo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3837bc7f8694ca43b734a327e3e37030371eeeea/gcc%2Fada%2Fa-crbtgo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-crbtgo.ads?ref=3837bc7f8694ca43b734a327e3e37030371eeeea", "patch": "@@ -7,11 +7,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2004-2005, Free Software Foundation, Inc.         --\n---                                                                          --\n--- This specification is derived from the Ada Reference Manual for use with --\n--- GNAT. The copyright notice above, and the license provisions that follow --\n--- apply solely to the  contents of the part following the private keyword. --\n+--          Copyright (C) 2004-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -34,6 +30,9 @@\n -- This unit was originally developed by Matthew J Heaney.                  --\n ------------------------------------------------------------------------------\n \n+--  Tree_Type is used to implement the ordered containers. This package\n+--  declares the tree operations that do not depend on keys.\n+\n with Ada.Streams; use Ada.Streams;\n \n generic\n@@ -53,8 +52,10 @@ package Ada.Containers.Red_Black_Trees.Generic_Operations is\n    pragma Pure;\n \n    function Min (Node : Node_Access) return Node_Access;\n+   --  Returns the smallest-valued node of the subtree rooted at Node\n \n    function Max (Node : Node_Access) return Node_Access;\n+   --  Returns the largest-valued node of the subtree rooted at Node\n \n    --  NOTE: The Check_Invariant operation was used during early\n    --  development of the red-black tree. Now that the tree type\n@@ -64,47 +65,75 @@ package Ada.Containers.Red_Black_Trees.Generic_Operations is\n    --  procedure Check_Invariant (Tree : Tree_Type);\n \n    function Vet (Tree : Tree_Type; Node : Node_Access) return Boolean;\n+   --  Inspects Node to determine (to the extent possible) whether\n+   --  the node is valid; used to detect if the node is dangling.\n \n    function Next (Node : Node_Access) return Node_Access;\n+   --  Returns the smallest node greater than Node\n \n    function Previous (Node : Node_Access) return Node_Access;\n+   --  Returns the largest node less than Node\n \n    generic\n       with function Is_Equal (L, R : Node_Access) return Boolean;\n    function Generic_Equal (Left, Right : Tree_Type) return Boolean;\n+   --  Uses Is_Equal to perform a node-by-node comparison of the\n+   --  Left and Right trees; processing stops as soon as the first\n+   --  non-equal node is found.\n \n    procedure Delete_Node_Sans_Free\n      (Tree : in out Tree_Type;\n       Node : Node_Access);\n+   --  Removes Node from Tree without deallocating the node. If Tree\n+   --  is busy then Program_Error is raised.\n \n    generic\n       with procedure Free (X : in out Node_Access);\n    procedure Generic_Delete_Tree (X : in out Node_Access);\n+   --  Deallocates the tree rooted at X, calling Free on each node\n \n    generic\n       with function Copy_Node (Source : Node_Access) return Node_Access;\n       with procedure Delete_Tree (X : in out Node_Access);\n    function Generic_Copy_Tree (Source_Root : Node_Access) return Node_Access;\n+   --  Copies the tree rooted at Source_Root, using Copy_Node to copy each\n+   --  node of the source tree. If Copy_Node propagates an exception\n+   --  (e.g. Storage_Error), then Delete_Tree is first used to deallocate\n+   --  the target tree, and then the exception is propagated.\n \n    generic\n       with function Copy_Tree (Root : Node_Access) return Node_Access;\n    procedure Generic_Adjust (Tree : in out Tree_Type);\n+   --  Used to implement controlled Adjust. On input to Generic_Adjust, Tree\n+   --  holds a bitwise (shallow) copy of the source tree (as would be the case\n+   --  when controlled Adjust is called). On output, Tree holds its own (deep)\n+   --  copy of the source tree, which is constructed by calling Copy_Tree.\n \n    generic\n       with procedure Delete_Tree (X : in out Node_Access);\n    procedure Generic_Clear (Tree : in out Tree_Type);\n+   --  Clears Tree by deallocating all of its nodes. If Tree is busy then\n+   --  Program_Error is raised.\n \n    generic\n       with procedure Clear (Tree : in out Tree_Type);\n    procedure Generic_Move (Target, Source : in out Tree_Type);\n+   --  Moves the tree belonging to Source onto Target. If Source is busy then\n+   --  Program_Error is raised. Otherwise Target is first cleared (by calling\n+   --  Clear, to deallocate its existing tree), then given the Source tree, and\n+   --  then finally Source is cleared (by setting its pointers to null).\n \n    generic\n       with procedure Process (Node : Node_Access) is <>;\n    procedure Generic_Iteration (Tree : Tree_Type);\n+   --  Calls Process for each node in Tree, in order from smallest-valued\n+   --  node to largest-valued node.\n \n    generic\n       with procedure Process (Node : Node_Access) is <>;\n    procedure Generic_Reverse_Iteration (Tree : Tree_Type);\n+   --  Calls Process for each node in Tree, in order from largest-valued\n+   --  node to smallest-valued node.\n \n    generic\n       with procedure Write_Node\n@@ -113,6 +142,9 @@ package Ada.Containers.Red_Black_Trees.Generic_Operations is\n    procedure Generic_Write\n      (Stream : access Root_Stream_Type'Class;\n       Tree   : Tree_Type);\n+   --  Used to implement stream attribute T'Write. Generic_Write\n+   --  first writes the number of nodes into Stream, then calls\n+   --  Write_Node for each node in Tree.\n \n    generic\n       with procedure Clear (Tree : in out Tree_Type);\n@@ -121,9 +153,14 @@ package Ada.Containers.Red_Black_Trees.Generic_Operations is\n    procedure Generic_Read\n      (Stream : access Root_Stream_Type'Class;\n       Tree   : in out Tree_Type);\n+   --  Used to implement stream attribute T'Read. Generic_Read\n+   --  first clears Tree. It then reads the number of nodes out of\n+   --  Stream, and calls Read_Node for each node in Stream.\n \n    procedure Rebalance_For_Insert\n      (Tree : in out Tree_Type;\n       Node : Node_Access);\n+   --  This rebalances Tree to complete the insertion of Node (which\n+   --  must already be linked in at its proper insertion position).\n \n end Ada.Containers.Red_Black_Trees.Generic_Operations;"}]}