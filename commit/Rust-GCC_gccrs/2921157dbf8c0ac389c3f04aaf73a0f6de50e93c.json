{"sha": "2921157dbf8c0ac389c3f04aaf73a0f6de50e93c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjkyMTE1N2RiZjhjMGFjMzg5YzNmMDRhYWY3M2EwZjZkZTUwZTkzYw==", "commit": {"author": {"name": "Francois-Xavier Coudert", "email": "fxcoudert@gcc.gnu.org", "date": "2010-06-11T19:35:19Z"}, "committer": {"name": "Fran\u00e7ois-Xavier Coudert", "email": "fxcoudert@gcc.gnu.org", "date": "2010-06-11T19:35:19Z"}, "message": "mathbuiltins.def: Add builtins that do not directly correspond to a Fortran intrinsic...\n\n\t* mathbuiltins.def: Add builtins that do not directly correspond\n\tto a Fortran intrinsic, with new macro OTHER_BUILTIN.\n\t* f95-lang.c (gfc_init_builtin_functions): Define OTHER_BUILTIN.\n\t* trans-intrinsic.c (gfc_intrinsic_map_t): Remove\n\tcode_{r,c}{4,8,10,16} fields. Add\n\t{,complex}{float,double,long_double}_built_in fields.\n\t(gfc_intrinsic_map): Adjust definitions of DEFINE_MATH_BUILTIN,\n\tDEFINE_MATH_BUILTIN_C and LIB_FUNCTION accordingly. Add\n\tdefinition of OTHER_BUILTIN.\n\t(real_compnt_info): Remove unused struct.\n\t(builtin_decl_for_precision, builtin_decl_for_float_kind): New\n\tfunctions.\n\t(build_round_expr): Call builtin_decl_for_precision instead of\n\tseries of if-else.\n\t(gfc_conv_intrinsic_aint): Call builtin_decl_for_float_kind\n\tinstead of a switch.\n\t(gfc_build_intrinsic_lib_fndecls): Match\n\t{real,complex}{4,8,10,16}decl into the C-style built_in_decls.\n\t(gfc_get_intrinsic_lib_fndecl): Do not hardcode floating-point\n\tkinds.\n\t(gfc_conv_intrinsic_lib_function): Go through all the extended\n\tgfc_intrinsic_map.\n\t(gfc_trans_same_strlen_check): Call builtin_decl_for_float_kind\n\tinstead of a switch.\n\t(gfc_conv_intrinsic_abs): Likewise.\n\t(gfc_conv_intrinsic_mod): Likewise.\n\t(gfc_conv_intrinsic_sign): Likewise.\n\t(gfc_conv_intrinsic_fraction): Likewise.\n\t(gfc_conv_intrinsic_nearest): Likewise.\n\t(gfc_conv_intrinsic_spacing): Likewise.\n\t(gfc_conv_intrinsic_rrspacing): Likewise.\n\t(gfc_conv_intrinsic_scale): Likewise.\n\t(gfc_conv_intrinsic_set_exponent): Likewise.\n\nFrom-SVN: r160628", "tree": {"sha": "8757faf0742761a2cf2730ea7615a2dda97ab17a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8757faf0742761a2cf2730ea7615a2dda97ab17a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2921157dbf8c0ac389c3f04aaf73a0f6de50e93c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2921157dbf8c0ac389c3f04aaf73a0f6de50e93c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2921157dbf8c0ac389c3f04aaf73a0f6de50e93c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2921157dbf8c0ac389c3f04aaf73a0f6de50e93c/comments", "author": {"login": "fxcoudert", "id": 1980544, "node_id": "MDQ6VXNlcjE5ODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1980544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fxcoudert", "html_url": "https://github.com/fxcoudert", "followers_url": "https://api.github.com/users/fxcoudert/followers", "following_url": "https://api.github.com/users/fxcoudert/following{/other_user}", "gists_url": "https://api.github.com/users/fxcoudert/gists{/gist_id}", "starred_url": "https://api.github.com/users/fxcoudert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fxcoudert/subscriptions", "organizations_url": "https://api.github.com/users/fxcoudert/orgs", "repos_url": "https://api.github.com/users/fxcoudert/repos", "events_url": "https://api.github.com/users/fxcoudert/events{/privacy}", "received_events_url": "https://api.github.com/users/fxcoudert/received_events", "type": "User", "site_admin": false}, "committer": {"login": "fxcoudert", "id": 1980544, "node_id": "MDQ6VXNlcjE5ODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1980544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fxcoudert", "html_url": "https://github.com/fxcoudert", "followers_url": "https://api.github.com/users/fxcoudert/followers", "following_url": "https://api.github.com/users/fxcoudert/following{/other_user}", "gists_url": "https://api.github.com/users/fxcoudert/gists{/gist_id}", "starred_url": "https://api.github.com/users/fxcoudert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fxcoudert/subscriptions", "organizations_url": "https://api.github.com/users/fxcoudert/orgs", "repos_url": "https://api.github.com/users/fxcoudert/repos", "events_url": "https://api.github.com/users/fxcoudert/events{/privacy}", "received_events_url": "https://api.github.com/users/fxcoudert/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ed9955f9285490aae391ffa48d39a1fa637eb1b9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed9955f9285490aae391ffa48d39a1fa637eb1b9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed9955f9285490aae391ffa48d39a1fa637eb1b9"}], "stats": {"total": 560, "additions": 217, "deletions": 343}, "files": [{"sha": "19d0c6df09b81c46a8b76bb562d60fbd17a4e569", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2921157dbf8c0ac389c3f04aaf73a0f6de50e93c/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2921157dbf8c0ac389c3f04aaf73a0f6de50e93c/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=2921157dbf8c0ac389c3f04aaf73a0f6de50e93c", "patch": "@@ -1,3 +1,39 @@\n+2010-06-11  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n+\n+\t* mathbuiltins.def: Add builtins that do not directly correspond\n+\tto a Fortran intrinsic, with new macro OTHER_BUILTIN.\n+\t* f95-lang.c (gfc_init_builtin_functions): Define OTHER_BUILTIN.\n+\t* trans-intrinsic.c (gfc_intrinsic_map_t): Remove\n+\tcode_{r,c}{4,8,10,16} fields. Add\n+\t{,complex}{float,double,long_double}_built_in fields.\n+\t(gfc_intrinsic_map): Adjust definitions of DEFINE_MATH_BUILTIN,\n+\tDEFINE_MATH_BUILTIN_C and LIB_FUNCTION accordingly. Add\n+\tdefinition of OTHER_BUILTIN.\n+\t(real_compnt_info): Remove unused struct.\n+\t(builtin_decl_for_precision, builtin_decl_for_float_kind): New\n+\tfunctions.\n+\t(build_round_expr): Call builtin_decl_for_precision instead of\n+\tseries of if-else.\n+\t(gfc_conv_intrinsic_aint): Call builtin_decl_for_float_kind\n+\tinstead of a switch.\n+\t(gfc_build_intrinsic_lib_fndecls): Match\n+\t{real,complex}{4,8,10,16}decl into the C-style built_in_decls.\n+\t(gfc_get_intrinsic_lib_fndecl): Do not hardcode floating-point\n+\tkinds.\n+\t(gfc_conv_intrinsic_lib_function): Go through all the extended\n+\tgfc_intrinsic_map.\n+\t(gfc_trans_same_strlen_check): Call builtin_decl_for_float_kind\n+\tinstead of a switch.\n+\t(gfc_conv_intrinsic_abs): Likewise.\n+\t(gfc_conv_intrinsic_mod): Likewise.\n+\t(gfc_conv_intrinsic_sign): Likewise.\n+\t(gfc_conv_intrinsic_fraction): Likewise.\n+\t(gfc_conv_intrinsic_nearest): Likewise.\n+\t(gfc_conv_intrinsic_spacing): Likewise.\n+\t(gfc_conv_intrinsic_rrspacing): Likewise.\n+\t(gfc_conv_intrinsic_scale): Likewise.\n+\t(gfc_conv_intrinsic_set_exponent): Likewise.\n+\n 2010-06-11  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/42051"}, {"sha": "a97016a69230f9f0b6b4adaabeeac8130d7f1386", "filename": "gcc/fortran/f95-lang.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2921157dbf8c0ac389c3f04aaf73a0f6de50e93c/gcc%2Ffortran%2Ff95-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2921157dbf8c0ac389c3f04aaf73a0f6de50e93c/gcc%2Ffortran%2Ff95-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ff95-lang.c?ref=2921157dbf8c0ac389c3f04aaf73a0f6de50e93c", "patch": "@@ -753,6 +753,9 @@ gfc_init_builtin_functions (void)\n   func_longdouble_longdoublep_longdoublep =\n     build_function_type_list (void_type_node, ptype, ptype, NULL_TREE);\n \n+/* Non-math builtins are defined manually, so they're not included here.  */\n+#define OTHER_BUILTIN(ID,NAME,TYPE)\n+\n #include \"mathbuiltins.def\"\n \n   gfc_define_builtin (\"__builtin_roundl\", mfunc_longdouble[0], "}, {"sha": "2d6e9677d62156dfb509b4e8bddb3216712a317a", "filename": "gcc/fortran/mathbuiltins.def", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2921157dbf8c0ac389c3f04aaf73a0f6de50e93c/gcc%2Ffortran%2Fmathbuiltins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2921157dbf8c0ac389c3f04aaf73a0f6de50e93c/gcc%2Ffortran%2Fmathbuiltins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmathbuiltins.def?ref=2921157dbf8c0ac389c3f04aaf73a0f6de50e93c", "patch": "@@ -51,3 +51,20 @@ DEFINE_MATH_BUILTIN   (ERFC,  \"erfc\",   0)\n DEFINE_MATH_BUILTIN   (TGAMMA,\"tgamma\", 0)\n DEFINE_MATH_BUILTIN   (LGAMMA,\"lgamma\", 0)\n DEFINE_MATH_BUILTIN   (HYPOT, \"hypot\",  1)\n+\n+/* OTHER_BUILTIN (CODE, NAME, PROTOTYPE_TYPE)\n+   For floating-point builtins that do not directly correspond to a\n+   Fortran intrinsic. This is used to map the different variants (float,\n+   double and long double) and to build the quad-precision decls.  */\n+OTHER_BUILTIN (CABS,      \"cabs\",      cabs)\n+OTHER_BUILTIN (COPYSIGN,  \"copysign\",  2)\n+OTHER_BUILTIN (FABS,      \"fabs\",      1)\n+OTHER_BUILTIN (FMOD,      \"fmod\",      2)\n+OTHER_BUILTIN (FREXP,     \"frexp\",     frexp)\n+OTHER_BUILTIN (HUGE_VAL,  \"huge_val\",  0)\n+OTHER_BUILTIN (LLROUND,   \"llround\",   llround)\n+OTHER_BUILTIN (LROUND,    \"lround\",    lround)\n+OTHER_BUILTIN (NEXTAFTER, \"nextafter\", 2)\n+OTHER_BUILTIN (ROUND,     \"round\",     1)\n+OTHER_BUILTIN (SCALBN,    \"scalbn\",    scalbn)\n+OTHER_BUILTIN (TRUNC,     \"trunc\",     1)"}, {"sha": "8418d2b22af6d897177147d79085167ad25b2d16", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 161, "deletions": 343, "changes": 504, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2921157dbf8c0ac389c3f04aaf73a0f6de50e93c/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2921157dbf8c0ac389c3f04aaf73a0f6de50e93c/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=2921157dbf8c0ac389c3f04aaf73a0f6de50e93c", "patch": "@@ -50,14 +50,12 @@ typedef struct GTY(()) gfc_intrinsic_map_t {\n \n   /* Enum value from the \"language-independent\", aka C-centric, part\n      of gcc, or END_BUILTINS of no such value set.  */\n-  enum built_in_function code_r4;\n-  enum built_in_function code_r8;\n-  enum built_in_function code_r10;\n-  enum built_in_function code_r16;\n-  enum built_in_function code_c4;\n-  enum built_in_function code_c8;\n-  enum built_in_function code_c10;\n-  enum built_in_function code_c16;\n+  enum built_in_function float_built_in;\n+  enum built_in_function double_built_in;\n+  enum built_in_function long_double_built_in;\n+  enum built_in_function complex_float_built_in;\n+  enum built_in_function complex_double_built_in;\n+  enum built_in_function complex_long_double_built_in;\n \n   /* True if the naming pattern is to prepend \"c\" for complex and\n      append \"f\" for kind=4.  False if the naming pattern is to\n@@ -90,28 +88,33 @@ gfc_intrinsic_map_t;\n    except for atan2.  */\n #define DEFINE_MATH_BUILTIN(ID, NAME, ARGTYPE) \\\n   { GFC_ISYM_ ## ID, BUILT_IN_ ## ID ## F, BUILT_IN_ ## ID, \\\n-    BUILT_IN_ ## ID ## L, BUILT_IN_ ## ID ## L, (enum built_in_function) 0, \\\n-    (enum built_in_function) 0, (enum built_in_function) 0, \\\n-    (enum built_in_function) 0, true, false, true, NAME, NULL_TREE, \\\n-    NULL_TREE, NULL_TREE, NULL_TREE, NULL_TREE, NULL_TREE, NULL_TREE, \\\n-    NULL_TREE},\n+    BUILT_IN_ ## ID ## L, END_BUILTINS, END_BUILTINS, END_BUILTINS, \\\n+    true, false, true, NAME, NULL_TREE, NULL_TREE, NULL_TREE, NULL_TREE, \\\n+    NULL_TREE, NULL_TREE, NULL_TREE, NULL_TREE},\n \n #define DEFINE_MATH_BUILTIN_C(ID, NAME, ARGTYPE) \\\n   { GFC_ISYM_ ## ID, BUILT_IN_ ## ID ## F, BUILT_IN_ ## ID, \\\n-    BUILT_IN_ ## ID ## L, BUILT_IN_ ## ID ## L, BUILT_IN_C ## ID ## F, \\\n-    BUILT_IN_C ## ID, BUILT_IN_C ## ID ## L, BUILT_IN_C ## ID ## L, true, \\\n-    true, true, NAME, NULL_TREE, NULL_TREE, NULL_TREE, NULL_TREE, \\\n-    NULL_TREE, NULL_TREE, NULL_TREE, NULL_TREE},\n+    BUILT_IN_ ## ID ## L, BUILT_IN_C ## ID ## F, BUILT_IN_C ## ID, \\\n+    BUILT_IN_C ## ID ## L, true, true, true, NAME, NULL_TREE, NULL_TREE, \\\n+    NULL_TREE, NULL_TREE, NULL_TREE, NULL_TREE, NULL_TREE, NULL_TREE},\n \n #define LIB_FUNCTION(ID, NAME, HAVE_COMPLEX) \\\n-  { GFC_ISYM_ ## ID, END_BUILTINS, END_BUILTINS, END_BUILTINS, END_BUILTINS, \\\n-    END_BUILTINS, END_BUILTINS, END_BUILTINS, END_BUILTINS, \\\n+  { GFC_ISYM_ ## ID, END_BUILTINS, END_BUILTINS, END_BUILTINS, \\\n+    END_BUILTINS, END_BUILTINS, END_BUILTINS, \\\n     false, HAVE_COMPLEX, true, NAME, NULL_TREE, NULL_TREE, NULL_TREE, \\\n     NULL_TREE, NULL_TREE, NULL_TREE, NULL_TREE, NULL_TREE }\n \n+#define OTHER_BUILTIN(ID, NAME, TYPE) \\\n+  { GFC_ISYM_NONE, BUILT_IN_ ## ID ## F, BUILT_IN_ ## ID, \\\n+    BUILT_IN_ ## ID ## L, END_BUILTINS, END_BUILTINS, END_BUILTINS, \\\n+    true, false, true, NAME, NULL_TREE, NULL_TREE, \\\n+    NULL_TREE, NULL_TREE, NULL_TREE, NULL_TREE, NULL_TREE, NULL_TREE},\n+\n static GTY(()) gfc_intrinsic_map_t gfc_intrinsic_map[] =\n {\n-  /* Functions built into gcc itself.  */\n+  /* Functions built into gcc itself (DEFINE_MATH_BUILTIN and\n+     DEFINE_MATH_BUILTIN_C), then the built-ins that don't correspond\n+     to any GFC_ISYM id directly, which use the OTHER_BUILTIN macro.  */\n #include \"mathbuiltins.def\"\n \n   /* Functions in libgfortran.  */\n@@ -121,30 +124,45 @@ static GTY(()) gfc_intrinsic_map_t gfc_intrinsic_map[] =\n   LIB_FUNCTION (NONE, NULL, false)\n \n };\n+#undef OTHER_BUILTIN\n #undef LIB_FUNCTION\n #undef DEFINE_MATH_BUILTIN\n #undef DEFINE_MATH_BUILTIN_C\n \n-/* Structure for storing components of a floating number to be used by\n-   elemental functions to manipulate reals.  */\n-typedef struct\n+\n+enum rounding_mode { RND_ROUND, RND_TRUNC, RND_CEIL, RND_FLOOR };\n+\n+\n+/* Find the correct variant of a given builtin from its argument.  */\n+static tree\n+builtin_decl_for_precision (enum built_in_function base_built_in,\n+\t\t\t    int precision)\n+{\n+  int i = END_BUILTINS;\n+\n+  gfc_intrinsic_map_t *m;\n+  for (m = gfc_intrinsic_map; m->double_built_in != base_built_in ; m++)\n+    ;\n+\n+  if (precision == TYPE_PRECISION (float_type_node))\n+    i = m->float_built_in;\n+  else if (precision == TYPE_PRECISION (double_type_node))\n+    i = m->double_built_in;\n+  else if (precision == TYPE_PRECISION (long_double_type_node))\n+    i = m->long_double_built_in;\n+\n+  return (i == END_BUILTINS ? NULL_TREE : built_in_decls[i]);\n+}\n+\n+\n+static tree\n+builtin_decl_for_float_kind (enum built_in_function double_built_in, int kind)\n {\n-  tree arg;     /* Variable tree to view convert to integer.  */\n-  tree expn;    /* Variable tree to save exponent.  */\n-  tree frac;    /* Variable tree to save fraction.  */\n-  tree smask;   /* Constant tree of sign's mask.  */\n-  tree emask;   /* Constant tree of exponent's mask.  */\n-  tree fmask;   /* Constant tree of fraction's mask.  */\n-  tree edigits; /* Constant tree of the number of exponent bits.  */\n-  tree fdigits; /* Constant tree of the number of fraction bits.  */\n-  tree f1;      /* Constant tree of the f1 defined in the real model.  */\n-  tree bias;    /* Constant tree of the bias of exponent in the memory.  */\n-  tree type;    /* Type tree of arg1.  */\n-  tree mtype;   /* Type tree of integer type. Kind is that of arg1.  */\n+  int i = gfc_validate_kind (BT_REAL, kind, false);\n+  return builtin_decl_for_precision (double_built_in,\n+\t\t\t\t     gfc_real_kinds[i].mode_precision);\n }\n-real_compnt_info;\n \n-enum rounding_mode { RND_ROUND, RND_TRUNC, RND_CEIL, RND_FLOOR };\n \n /* Evaluate the arguments to an intrinsic function.  The value\n    of NARGS may be less than the actual number of arguments in EXPR\n@@ -353,14 +371,10 @@ build_round_expr (tree arg, tree restype)\n     gcc_unreachable ();\n \n   /* Now, depending on the argument type, we choose between intrinsics.  */\n-  if (argprec == TYPE_PRECISION (float_type_node))\n-    fn = built_in_decls[longlong ? BUILT_IN_LLROUNDF : BUILT_IN_LROUNDF];\n-  else if (argprec == TYPE_PRECISION (double_type_node))\n-    fn = built_in_decls[longlong ? BUILT_IN_LLROUND : BUILT_IN_LROUND];\n-  else if (argprec == TYPE_PRECISION (long_double_type_node))\n-    fn = built_in_decls[longlong ? BUILT_IN_LLROUNDL : BUILT_IN_LROUNDL];\n+  if (longlong)\n+    fn = builtin_decl_for_precision (BUILT_IN_LLROUND, argprec);\n   else\n-    gcc_unreachable ();\n+    fn = builtin_decl_for_precision (BUILT_IN_LROUND, argprec);\n \n   return fold_convert (restype, build_call_expr_loc (input_location,\n \t\t\t\t\t\t fn, 1, arg));\n@@ -416,51 +430,24 @@ gfc_conv_intrinsic_aint (gfc_se * se, gfc_expr * expr, enum rounding_mode op)\n   tree arg[2];\n   tree tmp;\n   tree cond;\n+  tree decl;\n   mpfr_t huge;\n   int n, nargs;\n   int kind;\n \n   kind = expr->ts.kind;\n   nargs =  gfc_intrinsic_argument_list_length (expr);\n \n-  n = END_BUILTINS;\n+  decl = NULL_TREE;\n   /* We have builtin functions for some cases.  */\n   switch (op)\n     {\n     case RND_ROUND:\n-      switch (kind)\n-\t{\n-\tcase 4:\n-\t  n = BUILT_IN_ROUNDF;\n-\t  break;\n-\n-\tcase 8:\n-\t  n = BUILT_IN_ROUND;\n-\t  break;\n-\n-\tcase 10:\n-\tcase 16:\n-\t  n = BUILT_IN_ROUNDL;\n-\t  break;\n-\t}\n+      decl = builtin_decl_for_float_kind (BUILT_IN_ROUND, kind);\n       break;\n \n     case RND_TRUNC:\n-      switch (kind)\n-\t{\n-\tcase 4:\n-\t  n = BUILT_IN_TRUNCF;\n-\t  break;\n-\n-\tcase 8:\n-\t  n = BUILT_IN_TRUNC;\n-\t  break;\n-\n-\tcase 10:\n-\tcase 16:\n-\t  n = BUILT_IN_TRUNCL;\n-\t  break;\n-\t}\n+      decl = builtin_decl_for_float_kind (BUILT_IN_TRUNC, kind);\n       break;\n \n     default:\n@@ -472,11 +459,9 @@ gfc_conv_intrinsic_aint (gfc_se * se, gfc_expr * expr, enum rounding_mode op)\n   gfc_conv_intrinsic_function_args (se, expr, arg, nargs);\n \n   /* Use a builtin function if one exists.  */\n-  if (n != END_BUILTINS)\n+  if (decl != NULL_TREE)\n     {\n-      tmp = built_in_decls[n];\n-      se->expr = build_call_expr_loc (input_location,\n-\t\t\t\t  tmp, 1, arg[0]);\n+      se->expr = build_call_expr_loc (input_location, decl, 1, arg[0]);\n       return;\n     }\n \n@@ -580,24 +565,30 @@ gfc_build_intrinsic_lib_fndecls (void)\n   gfc_intrinsic_map_t *m;\n \n   /* Add GCC builtin functions.  */\n-  for (m = gfc_intrinsic_map; m->id != GFC_ISYM_NONE; m++)\n+  for (m = gfc_intrinsic_map;\n+       m->id != GFC_ISYM_NONE || m->double_built_in != END_BUILTINS; m++)\n     {\n-      if (m->code_r4 != END_BUILTINS)\n-\tm->real4_decl = built_in_decls[m->code_r4];\n-      if (m->code_r8 != END_BUILTINS)\n-\tm->real8_decl = built_in_decls[m->code_r8];\n-      if (m->code_r10 != END_BUILTINS)\n-\tm->real10_decl = built_in_decls[m->code_r10];\n-      if (m->code_r16 != END_BUILTINS)\n-\tm->real16_decl = built_in_decls[m->code_r16];\n-      if (m->code_c4 != END_BUILTINS)\n-\tm->complex4_decl = built_in_decls[m->code_c4];\n-      if (m->code_c8 != END_BUILTINS)\n-\tm->complex8_decl = built_in_decls[m->code_c8];\n-      if (m->code_c10 != END_BUILTINS)\n-\tm->complex10_decl = built_in_decls[m->code_c10];\n-      if (m->code_c16 != END_BUILTINS)\n-\tm->complex16_decl = built_in_decls[m->code_c16];\n+      if (m->float_built_in != END_BUILTINS)\n+\tm->real4_decl = built_in_decls[m->float_built_in];\n+      if (m->complex_float_built_in != END_BUILTINS)\n+\tm->complex4_decl = built_in_decls[m->complex_float_built_in];\n+      if (m->double_built_in != END_BUILTINS)\n+\tm->real8_decl = built_in_decls[m->double_built_in];\n+      if (m->complex_double_built_in != END_BUILTINS)\n+\tm->complex8_decl = built_in_decls[m->complex_double_built_in];\n+\n+      /* If real(kind=10) exists, it is always long double.  */\n+      if (m->long_double_built_in != END_BUILTINS)\n+\tm->real10_decl = built_in_decls[m->long_double_built_in];\n+      if (m->complex_long_double_built_in != END_BUILTINS)\n+\tm->complex10_decl = built_in_decls[m->complex_long_double_built_in];\n+\n+      /* For now, we assume that if real(kind=10) exists, it is long double.\n+\t Later, we will deal with __float128 and break this assumption.  */\n+      if (m->long_double_built_in != END_BUILTINS)\n+\tm->real16_decl = built_in_decls[m->long_double_built_in];\n+      if (m->complex_long_double_built_in != END_BUILTINS)\n+\tm->complex16_decl = built_in_decls[m->complex_long_double_built_in];\n     }\n }\n \n@@ -666,18 +657,18 @@ gfc_get_intrinsic_lib_fndecl (gfc_intrinsic_map_t * m, gfc_expr * expr)\n \n   if (m->libm_name)\n     {\n-      if (ts->kind == 4)\n+      int n = gfc_validate_kind (BT_REAL, ts->kind, false);\n+      if (gfc_real_kinds[n].c_float)\n \tsnprintf (name, sizeof (name), \"%s%s%s\",\n-\t\tts->type == BT_COMPLEX ? \"c\" : \"\", m->name, \"f\");\n-      else if (ts->kind == 8)\n+\t\t  ts->type == BT_COMPLEX ? \"c\" : \"\", m->name, \"f\");\n+      else if (gfc_real_kinds[n].c_double)\n \tsnprintf (name, sizeof (name), \"%s%s\",\n-\t\tts->type == BT_COMPLEX ? \"c\" : \"\", m->name);\n+\t\t  ts->type == BT_COMPLEX ? \"c\" : \"\", m->name);\n+      else if (gfc_real_kinds[n].c_long_double)\n+\tsnprintf (name, sizeof (name), \"%s%s%s\",\n+\t\t  ts->type == BT_COMPLEX ? \"c\" : \"\", m->name, \"l\");\n       else\n-\t{\n-\t  gcc_assert (ts->kind == 10 || ts->kind == 16);\n-\t  snprintf (name, sizeof (name), \"%s%s%s\",\n-\t\tts->type == BT_COMPLEX ? \"c\" : \"\", m->name, \"l\");\n-\t}\n+\tgcc_unreachable ();\n     }\n   else\n     {\n@@ -725,7 +716,8 @@ gfc_conv_intrinsic_lib_function (gfc_se * se, gfc_expr * expr)\n \n   id = expr->value.function.isym->id;\n   /* Find the entry for this function.  */\n-  for (m = gfc_intrinsic_map; m->id != GFC_ISYM_NONE; m++)\n+  for (m = gfc_intrinsic_map;\n+       m->id != GFC_ISYM_NONE || m->double_built_in != END_BUILTINS; m++)\n     {\n       if (id == m->id)\n \tbreak;\n@@ -787,31 +779,16 @@ gfc_trans_same_strlen_check (const char* intr_name, locus* where,\n static void\n gfc_conv_intrinsic_exponent (gfc_se *se, gfc_expr *expr)\n {\n-  tree arg, type, res, tmp;\n-  int frexp;\n+  tree arg, type, res, tmp, frexp;\n \n-  switch (expr->value.function.actual->expr->ts.kind)\n-    {\n-    case 4:\n-      frexp = BUILT_IN_FREXPF;\n-      break;\n-    case 8:\n-      frexp = BUILT_IN_FREXP;\n-      break;\n-    case 10:\n-    case 16:\n-      frexp = BUILT_IN_FREXPL;\n-      break;\n-    default:\n-      gcc_unreachable ();\n-    }\n+  frexp = builtin_decl_for_float_kind (BUILT_IN_FREXP,\n+\t\t\t\t       expr->value.function.actual->expr->ts.kind);\n \n   gfc_conv_intrinsic_function_args (se, expr, &arg, 1);\n \n   res = gfc_create_var (integer_type_node, NULL);\n-  tmp = build_call_expr_loc (input_location,\n-\t\t\t built_in_decls[frexp], 2, arg,\n-\t\t\t gfc_build_addr_expr (NULL_TREE, res));\n+  tmp = build_call_expr_loc (input_location, frexp, 2, arg,\n+\t\t\t     gfc_build_addr_expr (NULL_TREE, res));\n   gfc_add_expr_to_block (&se->pre, tmp);\n \n   type = gfc_typenode_for_spec (&expr->ts);\n@@ -991,8 +968,7 @@ gfc_conv_intrinsic_bound (gfc_se * se, gfc_expr * expr, int upper)\n static void\n gfc_conv_intrinsic_abs (gfc_se * se, gfc_expr * expr)\n {\n-  tree arg;\n-  int n;\n+  tree arg, cabs;\n \n   gfc_conv_intrinsic_function_args (se, expr, &arg, 1);\n \n@@ -1004,23 +980,8 @@ gfc_conv_intrinsic_abs (gfc_se * se, gfc_expr * expr)\n       break;\n \n     case BT_COMPLEX:\n-      switch (expr->ts.kind)\n-\t{\n-\tcase 4:\n-\t  n = BUILT_IN_CABSF;\n-\t  break;\n-\tcase 8:\n-\t  n = BUILT_IN_CABS;\n-\t  break;\n-\tcase 10:\n-\tcase 16:\n-\t  n = BUILT_IN_CABSL;\n-\t  break;\n-\tdefault:\n-\t  gcc_unreachable ();\n-\t}\n-      se->expr = build_call_expr_loc (input_location,\n-\t\t\t\t  built_in_decls[n], 1, arg);\n+      cabs = builtin_decl_for_float_kind (BUILT_IN_CABS, expr->ts.kind);\n+      se->expr = build_call_expr_loc (input_location, cabs, 1, arg);\n       break;\n \n     default:\n@@ -1072,6 +1033,7 @@ gfc_conv_intrinsic_mod (gfc_se * se, gfc_expr * expr, int modulo)\n   tree tmp;\n   tree test;\n   tree test2;\n+  tree fmod;\n   mpfr_t huge;\n   int n, ikind;\n   tree args[2];\n@@ -1091,33 +1053,16 @@ gfc_conv_intrinsic_mod (gfc_se * se, gfc_expr * expr, int modulo)\n       break;\n \n     case BT_REAL:\n-      n = END_BUILTINS;\n+      fmod = NULL_TREE;\n       /* Check if we have a builtin fmod.  */\n-      switch (expr->ts.kind)\n-\t{\n-\tcase 4:\n-\t  n = BUILT_IN_FMODF;\n-\t  break;\n-\n-\tcase 8:\n-\t  n = BUILT_IN_FMOD;\n-\t  break;\n-\n-\tcase 10:\n-\tcase 16:\n-\t  n = BUILT_IN_FMODL;\n-\t  break;\n-\n-\tdefault:\n-\t  break;\n-\t}\n+      fmod = builtin_decl_for_float_kind (BUILT_IN_FMOD, expr->ts.kind);\n \n       /* Use it if it exists.  */\n-      if (n != END_BUILTINS)\n+      if (fmod != NULL_TREE)\n \t{\n-  \t  tmp = build_addr (built_in_decls[n], current_function_decl);\n+  \t  tmp = build_addr (fmod, current_function_decl);\n \t  se->expr = build_call_array_loc (input_location,\n-\t\t\t\t       TREE_TYPE (TREE_TYPE (built_in_decls[n])),\n+\t\t\t\t       TREE_TYPE (TREE_TYPE (fmod)),\n                                        tmp, 2, args);\n \t  if (modulo == 0)\n \t    return;\n@@ -1135,7 +1080,7 @@ gfc_conv_intrinsic_mod (gfc_se * se, gfc_expr * expr, int modulo)\n \t  test  = (fmod (arg, arg2) != 0) && ((arg < 0) xor (arg2 < 0))\n \t thereby avoiding another division and retaining the accuracy\n \t of the builtin function.  */\n-      if (n != END_BUILTINS && modulo)\n+      if (fmod != NULL_TREE && modulo)\n \t{\n \t  tree zero = gfc_build_const (type, integer_zero_node);\n \t  tmp = gfc_evaluate_now (se->expr, &se->pre);\n@@ -1232,24 +1177,8 @@ gfc_conv_intrinsic_sign (gfc_se * se, gfc_expr * expr)\n     {\n       tree abs;\n \n-      switch (expr->ts.kind)\n-\t{\n-\tcase 4:\n-\t  tmp = built_in_decls[BUILT_IN_COPYSIGNF];\n-\t  abs = built_in_decls[BUILT_IN_FABSF];\n-\t  break;\n-\tcase 8:\n-\t  tmp = built_in_decls[BUILT_IN_COPYSIGN];\n-\t  abs = built_in_decls[BUILT_IN_FABS];\n-\t  break;\n-\tcase 10:\n-\tcase 16:\n-\t  tmp = built_in_decls[BUILT_IN_COPYSIGNL];\n-\t  abs = built_in_decls[BUILT_IN_FABSL];\n-\t  break;\n-\tdefault:\n-\t  gcc_unreachable ();\n-\t}\n+      tmp = builtin_decl_for_float_kind (BUILT_IN_COPYSIGN, expr->ts.kind);\n+      abs = builtin_decl_for_float_kind (BUILT_IN_FABS, expr->ts.kind);\n \n       /* We explicitly have to ignore the minus sign. We do so by using\n \t result = (arg1 == 0) ? abs(arg0) : copysign(arg0, arg1).  */\n@@ -1264,8 +1193,8 @@ gfc_conv_intrinsic_sign (gfc_se * se, gfc_expr * expr)\n \t\t\t\t  build_call_expr (tmp, 2, args[0], args[1]));\n \t}\n       else\n-        se->expr = build_call_expr_loc (input_location,\n-\t\t\t\t  tmp, 2, args[0], args[1]);\n+        se->expr = build_call_expr_loc (input_location, tmp, 2,\n+\t\t\t\t\targs[0], args[1]);\n       return;\n     }\n \n@@ -3620,32 +3549,16 @@ gfc_conv_intrinsic_merge (gfc_se * se, gfc_expr * expr)\n static void\n gfc_conv_intrinsic_fraction (gfc_se * se, gfc_expr * expr)\n {\n-  tree arg, type, tmp;\n-  int frexp;\n+  tree arg, type, tmp, frexp;\n \n-  switch (expr->ts.kind)\n-    {\n-      case 4:\n-\tfrexp = BUILT_IN_FREXPF;\n-\tbreak;\n-      case 8:\n-\tfrexp = BUILT_IN_FREXP;\n-\tbreak;\n-      case 10:\n-      case 16:\n-\tfrexp = BUILT_IN_FREXPL;\n-\tbreak;\n-      default:\n-\tgcc_unreachable ();\n-    }\n+  frexp = builtin_decl_for_float_kind (BUILT_IN_FREXP, expr->ts.kind);\n \n   type = gfc_typenode_for_spec (&expr->ts);\n   gfc_conv_intrinsic_function_args (se, expr, &arg, 1);\n   tmp = gfc_create_var (integer_type_node, NULL);\n-  se->expr = build_call_expr_loc (input_location,\n-\t\t\t      built_in_decls[frexp], 2,\n-\t\t\t      fold_convert (type, arg),\n-\t\t\t      gfc_build_addr_expr (NULL_TREE, tmp));\n+  se->expr = build_call_expr_loc (input_location, frexp, 2,\n+\t\t\t\t  fold_convert (type, arg),\n+\t\t\t\t  gfc_build_addr_expr (NULL_TREE, tmp));\n   se->expr = fold_convert (type, se->expr);\n }\n \n@@ -3657,41 +3570,19 @@ gfc_conv_intrinsic_fraction (gfc_se * se, gfc_expr * expr)\n static void\n gfc_conv_intrinsic_nearest (gfc_se * se, gfc_expr * expr)\n {\n-  tree args[2], type, tmp;\n-  int nextafter, copysign, huge_val;\n+  tree args[2], type, tmp, nextafter, copysign, huge_val;\n \n-  switch (expr->ts.kind)\n-    {\n-      case 4:\n-\tnextafter = BUILT_IN_NEXTAFTERF;\n-\tcopysign = BUILT_IN_COPYSIGNF;\n-\thuge_val = BUILT_IN_HUGE_VALF;\n-\tbreak;\n-      case 8:\n-\tnextafter = BUILT_IN_NEXTAFTER;\n-\tcopysign = BUILT_IN_COPYSIGN;\n-\thuge_val = BUILT_IN_HUGE_VAL;\n-\tbreak;\n-      case 10:\n-      case 16:\n-\tnextafter = BUILT_IN_NEXTAFTERL;\n-\tcopysign = BUILT_IN_COPYSIGNL;\n-\thuge_val = BUILT_IN_HUGE_VALL;\n-\tbreak;\n-      default:\n-\tgcc_unreachable ();\n-    }\n+  nextafter = builtin_decl_for_float_kind (BUILT_IN_NEXTAFTER, expr->ts.kind);\n+  copysign = builtin_decl_for_float_kind (BUILT_IN_COPYSIGN, expr->ts.kind);\n+  huge_val = builtin_decl_for_float_kind (BUILT_IN_HUGE_VAL, expr->ts.kind);\n \n   type = gfc_typenode_for_spec (&expr->ts);\n   gfc_conv_intrinsic_function_args (se, expr, args, 2);\n-  tmp = build_call_expr_loc (input_location,\n-\t\t\t built_in_decls[copysign], 2,\n-\t\t\t build_call_expr_loc (input_location,\n-\t\t\t\t\t  built_in_decls[huge_val], 0),\n-\t\t\t fold_convert (type, args[1]));\n-  se->expr = build_call_expr_loc (input_location,\n-\t\t\t      built_in_decls[nextafter], 2,\n-\t\t\t      fold_convert (type, args[0]), tmp);\n+  tmp = build_call_expr_loc (input_location, copysign, 2,\n+\t\t\t     build_call_expr_loc (input_location, huge_val, 0),\n+\t\t\t     fold_convert (type, args[1]));\n+  se->expr = build_call_expr_loc (input_location, nextafter, 2,\n+\t\t\t\t  fold_convert (type, args[0]), tmp);\n   se->expr = fold_convert (type, se->expr);\n }\n \n@@ -3717,33 +3608,17 @@ static void\n gfc_conv_intrinsic_spacing (gfc_se * se, gfc_expr * expr)\n {\n   tree arg, type, prec, emin, tiny, res, e;\n-  tree cond, tmp;\n-  int frexp, scalbn, k;\n+  tree cond, tmp, frexp, scalbn;\n+  int k;\n   stmtblock_t block;\n \n   k = gfc_validate_kind (BT_REAL, expr->ts.kind, false);\n   prec = build_int_cst (NULL_TREE, gfc_real_kinds[k].digits);\n   emin = build_int_cst (NULL_TREE, gfc_real_kinds[k].min_exponent - 1);\n   tiny = gfc_conv_mpfr_to_tree (gfc_real_kinds[k].tiny, expr->ts.kind, 0);\n \n-  switch (expr->ts.kind)\n-    {\n-      case 4:\n-\tfrexp = BUILT_IN_FREXPF;\n-\tscalbn = BUILT_IN_SCALBNF;\n-\tbreak;\n-      case 8:\n-\tfrexp = BUILT_IN_FREXP;\n-\tscalbn = BUILT_IN_SCALBN;\n-\tbreak;\n-      case 10:\n-      case 16:\n-\tfrexp = BUILT_IN_FREXPL;\n-\tscalbn = BUILT_IN_SCALBNL;\n-\tbreak;\n-      default:\n-\tgcc_unreachable ();\n-    }\n+  frexp = builtin_decl_for_float_kind (BUILT_IN_FREXP, expr->ts.kind);\n+  scalbn = builtin_decl_for_float_kind (BUILT_IN_SCALBN, expr->ts.kind);\n \n   gfc_conv_intrinsic_function_args (se, expr, &arg, 1);\n   arg = gfc_evaluate_now (arg, &se->pre);\n@@ -3755,17 +3630,15 @@ gfc_conv_intrinsic_spacing (gfc_se * se, gfc_expr * expr)\n \n   /* Build the block for s /= 0.  */\n   gfc_start_block (&block);\n-  tmp = build_call_expr_loc (input_location,\n-\t\t\t built_in_decls[frexp], 2, arg,\n-\t\t\t gfc_build_addr_expr (NULL_TREE, e));\n+  tmp = build_call_expr_loc (input_location, frexp, 2, arg,\n+\t\t\t     gfc_build_addr_expr (NULL_TREE, e));\n   gfc_add_expr_to_block (&block, tmp);\n \n   tmp = fold_build2 (MINUS_EXPR, integer_type_node, e, prec);\n   gfc_add_modify (&block, e, fold_build2 (MAX_EXPR, integer_type_node,\n \t\t\t\t\t  tmp, emin));\n \n-  tmp = build_call_expr_loc (input_location,\n-\t\t\t built_in_decls[scalbn], 2,\n+  tmp = build_call_expr_loc (input_location, scalbn, 2,\n \t\t\t build_real_from_int_cst (type, integer_one_node), e);\n   gfc_add_modify (&block, res, tmp);\n \n@@ -3796,33 +3669,16 @@ gfc_conv_intrinsic_spacing (gfc_se * se, gfc_expr * expr)\n static void\n gfc_conv_intrinsic_rrspacing (gfc_se * se, gfc_expr * expr)\n {\n-  tree arg, type, e, x, cond, stmt, tmp;\n-  int frexp, scalbn, fabs, prec, k;\n+  tree arg, type, e, x, cond, stmt, tmp, frexp, scalbn, fabs;\n+  int prec, k;\n   stmtblock_t block;\n \n   k = gfc_validate_kind (BT_REAL, expr->ts.kind, false);\n   prec = gfc_real_kinds[k].digits;\n-  switch (expr->ts.kind)\n-    {\n-      case 4:\n-\tfrexp = BUILT_IN_FREXPF;\n-\tscalbn = BUILT_IN_SCALBNF;\n-\tfabs = BUILT_IN_FABSF;\n-\tbreak;\n-      case 8:\n-\tfrexp = BUILT_IN_FREXP;\n-\tscalbn = BUILT_IN_SCALBN;\n-\tfabs = BUILT_IN_FABS;\n-\tbreak;\n-      case 10:\n-      case 16:\n-\tfrexp = BUILT_IN_FREXPL;\n-\tscalbn = BUILT_IN_SCALBNL;\n-\tfabs = BUILT_IN_FABSL;\n-\tbreak;\n-      default:\n-\tgcc_unreachable ();\n-    }\n+\n+  frexp = builtin_decl_for_float_kind (BUILT_IN_FREXP, expr->ts.kind);\n+  scalbn = builtin_decl_for_float_kind (BUILT_IN_SCALBN, expr->ts.kind);\n+  fabs = builtin_decl_for_float_kind (BUILT_IN_FABS, expr->ts.kind);\n \n   type = gfc_typenode_for_spec (&expr->ts);\n   gfc_conv_intrinsic_function_args (se, expr, &arg, 1);\n@@ -3831,20 +3687,17 @@ gfc_conv_intrinsic_rrspacing (gfc_se * se, gfc_expr * expr)\n   e = gfc_create_var (integer_type_node, NULL);\n   x = gfc_create_var (type, NULL);\n   gfc_add_modify (&se->pre, x,\n-\t\t  build_call_expr_loc (input_location,\n-\t\t\t\t   built_in_decls[fabs], 1, arg));\n+\t\t  build_call_expr_loc (input_location, fabs, 1, arg));\n \n \n   gfc_start_block (&block);\n-  tmp = build_call_expr_loc (input_location,\n-\t\t\t built_in_decls[frexp], 2, arg,\n-\t\t\t gfc_build_addr_expr (NULL_TREE, e));\n+  tmp = build_call_expr_loc (input_location, frexp, 2, arg,\n+\t\t\t     gfc_build_addr_expr (NULL_TREE, e));\n   gfc_add_expr_to_block (&block, tmp);\n \n   tmp = fold_build2 (MINUS_EXPR, integer_type_node,\n \t\t     build_int_cst (NULL_TREE, prec), e);\n-  tmp = build_call_expr_loc (input_location,\n-\t\t\t built_in_decls[scalbn], 2, x, tmp);\n+  tmp = build_call_expr_loc (input_location, scalbn, 2, x, tmp);\n   gfc_add_modify (&block, x, tmp);\n   stmt = gfc_finish_block (&block);\n \n@@ -3861,31 +3714,15 @@ gfc_conv_intrinsic_rrspacing (gfc_se * se, gfc_expr * expr)\n static void\n gfc_conv_intrinsic_scale (gfc_se * se, gfc_expr * expr)\n {\n-  tree args[2], type;\n-  int scalbn;\n+  tree args[2], type, scalbn;\n \n-  switch (expr->ts.kind)\n-    {\n-      case 4:\n-\tscalbn = BUILT_IN_SCALBNF;\n-\tbreak;\n-      case 8:\n-\tscalbn = BUILT_IN_SCALBN;\n-\tbreak;\n-      case 10:\n-      case 16:\n-\tscalbn = BUILT_IN_SCALBNL;\n-\tbreak;\n-      default:\n-\tgcc_unreachable ();\n-    }\n+  scalbn = builtin_decl_for_float_kind (BUILT_IN_SCALBN, expr->ts.kind);\n \n   type = gfc_typenode_for_spec (&expr->ts);\n   gfc_conv_intrinsic_function_args (se, expr, args, 2);\n-  se->expr = build_call_expr_loc (input_location,\n-\t\t\t      built_in_decls[scalbn], 2,\n-\t\t\t      fold_convert (type, args[0]),\n-\t\t\t      fold_convert (integer_type_node, args[1]));\n+  se->expr = build_call_expr_loc (input_location, scalbn, 2,\n+\t\t\t\t  fold_convert (type, args[0]),\n+\t\t\t\t  fold_convert (integer_type_node, args[1]));\n   se->expr = fold_convert (type, se->expr);\n }\n \n@@ -3895,39 +3732,20 @@ gfc_conv_intrinsic_scale (gfc_se * se, gfc_expr * expr)\n static void\n gfc_conv_intrinsic_set_exponent (gfc_se * se, gfc_expr * expr)\n {\n-  tree args[2], type, tmp;\n-  int frexp, scalbn;\n+  tree args[2], type, tmp, frexp, scalbn;\n \n-  switch (expr->ts.kind)\n-    {\n-      case 4:\n-\tfrexp = BUILT_IN_FREXPF;\n-\tscalbn = BUILT_IN_SCALBNF;\n-\tbreak;\n-      case 8:\n-\tfrexp = BUILT_IN_FREXP;\n-\tscalbn = BUILT_IN_SCALBN;\n-\tbreak;\n-      case 10:\n-      case 16:\n-\tfrexp = BUILT_IN_FREXPL;\n-\tscalbn = BUILT_IN_SCALBNL;\n-\tbreak;\n-      default:\n-\tgcc_unreachable ();\n-    }\n+  frexp = builtin_decl_for_float_kind (BUILT_IN_FREXP, expr->ts.kind);\n+  scalbn = builtin_decl_for_float_kind (BUILT_IN_SCALBN, expr->ts.kind);\n \n   type = gfc_typenode_for_spec (&expr->ts);\n   gfc_conv_intrinsic_function_args (se, expr, args, 2);\n \n   tmp = gfc_create_var (integer_type_node, NULL);\n-  tmp = build_call_expr_loc (input_location,\n-\t\t\t built_in_decls[frexp], 2,\n-\t\t\t fold_convert (type, args[0]),\n-\t\t\t gfc_build_addr_expr (NULL_TREE, tmp));\n-  se->expr = build_call_expr_loc (input_location,\n-\t\t\t      built_in_decls[scalbn], 2, tmp,\n-\t\t\t      fold_convert (integer_type_node, args[1]));\n+  tmp = build_call_expr_loc (input_location, frexp, 2,\n+\t\t\t     fold_convert (type, args[0]),\n+\t\t\t     gfc_build_addr_expr (NULL_TREE, tmp));\n+  se->expr = build_call_expr_loc (input_location, scalbn, 2, tmp,\n+\t\t\t\t  fold_convert (integer_type_node, args[1]));\n   se->expr = fold_convert (type, se->expr);\n }\n "}]}