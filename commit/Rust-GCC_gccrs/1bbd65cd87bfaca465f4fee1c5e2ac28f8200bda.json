{"sha": "1bbd65cd87bfaca465f4fee1c5e2ac28f8200bda", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWJiZDY1Y2Q4N2JmYWNhNDY1ZjRmZWUxYzVlMmFjMjhmODIwMGJkYQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@libertysurf.fr", "date": "2004-03-22T11:59:08Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2004-03-22T11:59:08Z"}, "message": "re PR tree-optimization/14470 ([tree-ssa] trouble with post-increment)\n\n\tPR middle-end/14470\n\t* expr.c (mark_queue): New function.\n\t(emit_insns_enqueued_after_mark): New function replacing\n\temit_queue.  Clear the body of emitted queued insns.\n\t(emit_queue): Call emit_insns_enqueued_after_mark.\n\t(store_expr): Mark the increment queue on entry.  Emit\n\tonly the incrementations queued when expanding the source.\n\nFrom-SVN: r79822", "tree": {"sha": "c6ea3b97c37379d4cfbc40dc996134d5e6fa2293", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c6ea3b97c37379d4cfbc40dc996134d5e6fa2293"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1bbd65cd87bfaca465f4fee1c5e2ac28f8200bda", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1bbd65cd87bfaca465f4fee1c5e2ac28f8200bda", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1bbd65cd87bfaca465f4fee1c5e2ac28f8200bda", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1bbd65cd87bfaca465f4fee1c5e2ac28f8200bda/comments", "author": {"login": "ebotcazou", "id": 48091907, "node_id": "MDQ6VXNlcjQ4MDkxOTA3", "avatar_url": "https://avatars.githubusercontent.com/u/48091907?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ebotcazou", "html_url": "https://github.com/ebotcazou", "followers_url": "https://api.github.com/users/ebotcazou/followers", "following_url": "https://api.github.com/users/ebotcazou/following{/other_user}", "gists_url": "https://api.github.com/users/ebotcazou/gists{/gist_id}", "starred_url": "https://api.github.com/users/ebotcazou/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ebotcazou/subscriptions", "organizations_url": "https://api.github.com/users/ebotcazou/orgs", "repos_url": "https://api.github.com/users/ebotcazou/repos", "events_url": "https://api.github.com/users/ebotcazou/events{/privacy}", "received_events_url": "https://api.github.com/users/ebotcazou/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "aadfde5010ff1ed470b006784cdf32da2f48608e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aadfde5010ff1ed470b006784cdf32da2f48608e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aadfde5010ff1ed470b006784cdf32da2f48608e"}], "stats": {"total": 53, "additions": 47, "deletions": 6}, "files": [{"sha": "8d3238bd8a60de53705e58f83dc44bf7ab766660", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bbd65cd87bfaca465f4fee1c5e2ac28f8200bda/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bbd65cd87bfaca465f4fee1c5e2ac28f8200bda/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1bbd65cd87bfaca465f4fee1c5e2ac28f8200bda", "patch": "@@ -1,3 +1,13 @@\n+2004-03-22  Eric Botcazou  <ebotcazou@libertysurf.fr>\n+\n+\tPR middle-end/14470\n+\t* expr.c (mark_queue): New function.\n+\t(emit_insns_enqueued_after_mark): New function replacing\n+\temit_queue.  Clear the body of emitted queued insns.\n+\t(emit_queue): Call emit_insns_enqueued_after_mark.\n+\t(store_expr): Mark the increment queue on entry.  Emit\n+\tonly the incrementations queued when expanding the source.\n+\n 2004-03-22  Nathanael Nerode  <neroden@gcc.gnu.org>\n \n \t* configure.ac: Allow --disable-coverage-flags (for the future benefit"}, {"sha": "d77b6e5d58730b2f942fbf464edcd0c3030fbe5c", "filename": "gcc/expr.c", "status": "modified", "additions": 37, "deletions": 6, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bbd65cd87bfaca465f4fee1c5e2ac28f8200bda/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bbd65cd87bfaca465f4fee1c5e2ac28f8200bda/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=1bbd65cd87bfaca465f4fee1c5e2ac28f8200bda", "patch": "@@ -466,13 +466,30 @@ queued_subexp_p (rtx x)\n     }\n }\n \n-/* Perform all the pending incrementations.  */\n+/* Retrieve a mark on the queue.  */\n+  \n+static rtx\n+mark_queue (void)\n+{\n+  return pending_chain;\n+}\n \n-void\n-emit_queue (void)\n+/* Perform all the pending incrementations that have been enqueued\n+   after MARK was retrieved.  If MARK is null, perform all the\n+   pending incrementations.  */\n+\n+static void\n+emit_insns_enqueued_after_mark (rtx mark)\n {\n   rtx p;\n-  while ((p = pending_chain))\n+\n+  /* The marked incrementation may have been emitted in the meantime\n+     through a call to emit_queue.  In this case, the mark is not valid\n+     anymore so do nothing.  */\n+  if (mark && ! QUEUED_BODY (mark))\n+    return;\n+\n+  while ((p = pending_chain) != mark)\n     {\n       rtx body = QUEUED_BODY (p);\n \n@@ -499,9 +516,18 @@ emit_queue (void)\n \t  break;\n \t}\n \n+      QUEUED_BODY (p) = 0;\n       pending_chain = QUEUED_NEXT (p);\n     }\n }\n+\n+/* Perform all the pending incrementations.  */\n+\n+void\n+emit_queue (void)\n+{\n+  emit_insns_enqueued_after_mark (NULL_RTX);\n+}\n \f\n /* Copy data from FROM to TO, where the machine modes are not the same.\n    Both modes may be integer, or both may be floating.\n@@ -4003,6 +4029,7 @@ store_expr (tree exp, rtx target, int want_value)\n {\n   rtx temp;\n   rtx alt_rtl = NULL_RTX;\n+  rtx mark = mark_queue ();\n   int dont_return_target = 0;\n   int dont_store_target = 0;\n \n@@ -4214,7 +4241,11 @@ store_expr (tree exp, rtx target, int want_value)\n \t\t\t  temp, TREE_UNSIGNED (TREE_TYPE (exp)));\n \n   /* If value was not generated in the target, store it there.\n-     Convert the value to TARGET's type first if necessary.\n+     Convert the value to TARGET's type first if necessary and emit the\n+     pending incrementations that have been queued when expanding EXP.\n+     Note that we cannot emit the whole queue blindly because this will\n+     effectively disable the POST_INC optimization later.\n+\n      If TEMP and TARGET compare equal according to rtx_equal_p, but\n      one or both of them are volatile memory refs, we have to distinguish\n      two cases:\n@@ -4242,7 +4273,7 @@ store_expr (tree exp, rtx target, int want_value)\n \t bit-initialized.  */\n       && expr_size (exp) != const0_rtx)\n     {\n-      emit_queue();\n+      emit_insns_enqueued_after_mark (mark);\n       target = protect_from_queue (target, 1);\n       temp = protect_from_queue (temp, 0);\n       if (GET_MODE (temp) != GET_MODE (target)"}]}