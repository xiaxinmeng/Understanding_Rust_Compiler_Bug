{"sha": "a8c55cacaf8fa1e90f9e26c467a78081ae152b50", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YThjNTVjYWNhZjhmYTFlOTBmOWUyNmM0NjdhNzgwODFhZTE1MmI1MA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2017-12-15T20:20:00Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2017-12-15T20:20:00Z"}, "message": "re PR c++/80135 (ICE in output_constructor_regular_field, at varasm.c:4968)\n\n\tPR c++/80135\n\tPR c++/81922\n\t* typeck2.c (digest_init_r): Change nested argument type from bool to\n\tint.  Use code instead of TREE_CODE (type) where possible.  If\n\tnested == 2, diagnose initialization of flexible array member with\n\tSTRING_CST.  Pass nested to process_init_constructor.  Formatting fix.\n\t(digest_init, digest_init_flags): Adjust digest_init_r caller.\n\t(massage_init_elt): Add nested argument.  Pass 2 instead of 1 to\n\tdigest_init_r's nested argument if nested is non-zero.\n\t(process_init_constructor_array): Add nested argument.  If nested == 2,\n\tdiagnose initialization of flexible array member with non-empty\n\tbraced enclosed list.  Pass nested to massage_init_elt.\n\t(process_init_constructor_record, process_init_constructor_union): Add\n\tnested argument, pass it to massage_init_elt.\n\t(process_init_constructor): Add nested argument, pass it to\n\tprocess_init_constructor_{array,record,union}.\n\t* init.c (find_field_init): Renamed to ...\n\t(find_flexarray_init): ... this.  Return NULL_TREE if init is\n\terror_mark_node.  Don't look through nested CONSTRUCTORs.\n\t(warn_placement_new_too_small): Adjust caller.\n\n\t* g++.dg/warn/Wplacement-new-size-1.C (fBx1): Initialize nested\n\tflexible array member only with {}.  Add dg-warning.\n\t(fBx2, fBx3): Remove.\n\t* g++.dg/warn/Wplacement-new-size-2.C (fBx1): Initialize nested\n\tflexible array member only with {}.  Add dg-warning.\n\t(fBx2, fBx3): Remove.\n\t* g++.dg/warn/Wplacement-new-size-6.C: New test.\n\t* g++.dg/ext/flexary13.C (main): Remove test for initialization\n\tof nested flexible array member with non-empty initializer.\n\t* g++.dg/ext/flexary25.C: New test.\n\t* g++.dg/ext/flexary26.C: New test.\n\t* g++.dg/ext/flexary27.C: New test.\n\t* g++.dg/parse/pr43765.C: Expect diagnostics about initialization\n\tof nested flexible array member with non-empty initializer.  Expect\n\tC++2A diagnostics about mixing of designated and non-designated\n\tinitializers.\n\nFrom-SVN: r255703", "tree": {"sha": "a45a3326c55217d9cc4a173c3032c72887d3a954", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a45a3326c55217d9cc4a173c3032c72887d3a954"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a8c55cacaf8fa1e90f9e26c467a78081ae152b50", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8c55cacaf8fa1e90f9e26c467a78081ae152b50", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a8c55cacaf8fa1e90f9e26c467a78081ae152b50", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8c55cacaf8fa1e90f9e26c467a78081ae152b50/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e3a661b45e8d9baf96bef773e214f4c41581bc22", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3a661b45e8d9baf96bef773e214f4c41581bc22", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e3a661b45e8d9baf96bef773e214f4c41581bc22"}], "stats": {"total": 339, "additions": 229, "deletions": 110}, "files": [{"sha": "488b9f3f59970472b40d3b72d12fa0c22e667593", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c55cacaf8fa1e90f9e26c467a78081ae152b50/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c55cacaf8fa1e90f9e26c467a78081ae152b50/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=a8c55cacaf8fa1e90f9e26c467a78081ae152b50", "patch": "@@ -1,5 +1,26 @@\n 2017-12-15  Jakub Jelinek  <jakub@redhat.com>\n \n+\tPR c++/80135\n+\tPR c++/81922\n+\t* typeck2.c (digest_init_r): Change nested argument type from bool to\n+\tint.  Use code instead of TREE_CODE (type) where possible.  If\n+\tnested == 2, diagnose initialization of flexible array member with\n+\tSTRING_CST.  Pass nested to process_init_constructor.  Formatting fix.\n+\t(digest_init, digest_init_flags): Adjust digest_init_r caller.\n+\t(massage_init_elt): Add nested argument.  Pass 2 instead of 1 to\n+\tdigest_init_r's nested argument if nested is non-zero.\n+\t(process_init_constructor_array): Add nested argument.  If nested == 2,\n+\tdiagnose initialization of flexible array member with non-empty\n+\tbraced enclosed list.  Pass nested to massage_init_elt.\n+\t(process_init_constructor_record, process_init_constructor_union): Add\n+\tnested argument, pass it to massage_init_elt.\n+\t(process_init_constructor): Add nested argument, pass it to\n+\tprocess_init_constructor_{array,record,union}.\n+\t* init.c (find_field_init): Renamed to ...\n+\t(find_flexarray_init): ... this.  Return NULL_TREE if init is\n+\terror_mark_node.  Don't look through nested CONSTRUCTORs.\n+\t(warn_placement_new_too_small): Adjust caller.\n+\n \tPR c++/83217\n \t* decl.c (cp_finish_decomp): If decl's type is REFERENCE_TYPE,\n \tcall complete_type (TREE_TYPE (type))."}, {"sha": "daa62392857f80a772d594793b89d03748f51f90", "filename": "gcc/cp/init.c", "status": "modified", "additions": 11, "deletions": 16, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c55cacaf8fa1e90f9e26c467a78081ae152b50/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c55cacaf8fa1e90f9e26c467a78081ae152b50/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=a8c55cacaf8fa1e90f9e26c467a78081ae152b50", "patch": "@@ -2453,30 +2453,24 @@ throw_bad_array_new_length (void)\n   return build_cxx_call (fn, 0, NULL, tf_warning_or_error);\n }\n \n-/* Attempt to find the initializer for field T in the initializer INIT,\n-   when non-null.  Returns the initializer when successful and NULL\n-   otherwise.  */\n+/* Attempt to find the initializer for flexible array field T in the\n+   initializer INIT, when non-null.  Returns the initializer when\n+   successful and NULL otherwise.  */\n static tree\n-find_field_init (tree t, tree init)\n+find_flexarray_init (tree t, tree init)\n {\n-  if (!init)\n+  if (!init || init == error_mark_node)\n     return NULL_TREE;\n \n   unsigned HOST_WIDE_INT idx;\n   tree field, elt;\n \n   /* Iterate over all top-level initializer elements.  */\n   FOR_EACH_CONSTRUCTOR_ELT (CONSTRUCTOR_ELTS (init), idx, field, elt)\n-    {\n-      /* If the member T is found, return it.  */\n-      if (field == t)\n-\treturn elt;\n-\n-      /* Otherwise continue and/or recurse into nested initializers.  */\n-      if (TREE_CODE (elt) == CONSTRUCTOR\n-\t  && (init = find_field_init (t, elt)))\n-\treturn init;\n-    }\n+    /* If the member T is found, return it.  */\n+    if (field == t)\n+      return elt;\n+\n   return NULL_TREE;\n }\n \n@@ -2645,7 +2639,8 @@ warn_placement_new_too_small (tree type, tree nelts, tree size, tree oper)\n \t\t extension).  If the array member has been initialized,\n \t\t determine its size from the initializer.  Otherwise,\n \t\t the array size is zero.  */\n-\t      if (tree init = find_field_init (oper, DECL_INITIAL (var_decl)))\n+\t      if (tree init = find_flexarray_init (oper,\n+\t\t\t\t\t\t   DECL_INITIAL (var_decl)))\n \t\tbytes_avail = wi::to_offset (TYPE_SIZE_UNIT (TREE_TYPE (init)));\n \t    }\n \t  else"}, {"sha": "e5bb249b2be6eabafdd6b4de6330c427565fde6b", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 53, "deletions": 34, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c55cacaf8fa1e90f9e26c467a78081ae152b50/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c55cacaf8fa1e90f9e26c467a78081ae152b50/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=a8c55cacaf8fa1e90f9e26c467a78081ae152b50", "patch": "@@ -34,7 +34,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"intl.h\"\n \n static tree\n-process_init_constructor (tree type, tree init, tsubst_flags_t complain);\n+process_init_constructor (tree type, tree init, int nested,\n+\t\t\t  tsubst_flags_t complain);\n \n \n /* Print an error message stemming from an attempt to use\n@@ -996,10 +997,11 @@ check_narrowing (tree type, tree init, tsubst_flags_t complain)\n    For aggregate types, it assumes that reshape_init has already run, thus the\n    initializer will have the right shape (brace elision has been undone).\n \n-   NESTED is true iff we are being called for an element of a CONSTRUCTOR.  */\n+   NESTED is non-zero iff we are being called for an element of a CONSTRUCTOR,\n+   2 iff the element of a CONSTRUCTOR is inside another CONSTRUCTOR.  */\n \n static tree\n-digest_init_r (tree type, tree init, bool nested, int flags,\n+digest_init_r (tree type, tree init, int nested, int flags,\n \t       tsubst_flags_t complain)\n {\n   enum tree_code code = TREE_CODE (type);\n@@ -1011,7 +1013,7 @@ digest_init_r (tree type, tree init, bool nested, int flags,\n \n   /* We must strip the outermost array type when completing the type,\n      because the its bounds might be incomplete at the moment.  */\n-  if (!complete_type_or_maybe_complain (TREE_CODE (type) == ARRAY_TYPE\n+  if (!complete_type_or_maybe_complain (code == ARRAY_TYPE\n \t\t\t\t\t? TREE_TYPE (type) : type, NULL_TREE,\n \t\t\t\t\tcomplain))\n     return error_mark_node;\n@@ -1029,11 +1031,9 @@ digest_init_r (tree type, tree init, bool nested, int flags,\n   if (code == ARRAY_TYPE)\n     {\n       if (nested && !TYPE_DOMAIN (type))\n-\t{\n-\t  /* C++ flexible array members have a null domain.  */\n-\t  pedwarn (loc, OPT_Wpedantic,\n-\t\t   \"initialization of a flexible array member\");\n-\t}\n+\t/* C++ flexible array members have a null domain.  */\n+\tpedwarn (loc, OPT_Wpedantic,\n+\t\t \"initialization of a flexible array member\");\n \n       tree typ1 = TYPE_MAIN_VARIANT (TREE_TYPE (type));\n       if (char_type_p (typ1)\n@@ -1069,6 +1069,14 @@ digest_init_r (tree type, tree init, bool nested, int flags,\n \t\t}\n \t    }\n \n+\t  if (nested == 2 && !TYPE_DOMAIN (type))\n+\t    {\n+\t      if (complain & tf_error)\n+\t\terror_at (loc, \"initialization of flexible array member \"\n+\t\t\t       \"in a nested context\");\n+\t      return error_mark_node;\n+\t    }\n+\n \t  if (type != TREE_TYPE (init)\n \t      && !variably_modified_type_p (type, NULL_TREE))\n \t    {\n@@ -1093,8 +1101,7 @@ digest_init_r (tree type, tree init, bool nested, int flags,\n     }\n \n   /* Handle scalar types (including conversions) and references.  */\n-  if ((TREE_CODE (type) != COMPLEX_TYPE\n-       || BRACE_ENCLOSED_INITIALIZER_P (init))\n+  if ((code != COMPLEX_TYPE || BRACE_ENCLOSED_INITIALIZER_P (init))\n       && (SCALAR_TYPE_P (type) || code == REFERENCE_TYPE))\n     {\n       if (nested)\n@@ -1108,11 +1115,11 @@ digest_init_r (tree type, tree init, bool nested, int flags,\n \n   /* Come here only for aggregates: records, arrays, unions, complex numbers\n      and vectors.  */\n-  gcc_assert (TREE_CODE (type) == ARRAY_TYPE\n+  gcc_assert (code == ARRAY_TYPE\n \t      || VECTOR_TYPE_P (type)\n-\t      || TREE_CODE (type) == RECORD_TYPE\n-\t      || TREE_CODE (type) == UNION_TYPE\n-\t      || TREE_CODE (type) == COMPLEX_TYPE);\n+\t      || code == RECORD_TYPE\n+\t      || code == UNION_TYPE\n+\t      || code == COMPLEX_TYPE);\n \n   /* \"If T is a class type and the initializer list has a single\n      element of type cv U, where U is T or a class derived from T,\n@@ -1132,10 +1139,10 @@ digest_init_r (tree type, tree init, bool nested, int flags,\n \n   if (BRACE_ENCLOSED_INITIALIZER_P (init)\n       && !TYPE_NON_AGGREGATE_CLASS (type))\n-    return process_init_constructor (type, init, complain);\n+    return process_init_constructor (type, init, nested, complain);\n   else\n     {\n-      if (COMPOUND_LITERAL_P (init) && TREE_CODE (type) == ARRAY_TYPE)\n+      if (COMPOUND_LITERAL_P (init) && code == ARRAY_TYPE)\n \t{\n \t  if (complain & tf_error)\n \t    error_at (loc, \"cannot initialize aggregate of type %qT with \"\n@@ -1144,7 +1151,7 @@ digest_init_r (tree type, tree init, bool nested, int flags,\n \t  return error_mark_node;\n \t}\n \n-      if (TREE_CODE (type) == ARRAY_TYPE\n+      if (code == ARRAY_TYPE\n \t  && !BRACE_ENCLOSED_INITIALIZER_P (init))\n \t{\n \t  /* Allow the result of build_array_copy and of\n@@ -1171,13 +1178,13 @@ digest_init_r (tree type, tree init, bool nested, int flags,\n tree\n digest_init (tree type, tree init, tsubst_flags_t complain)\n {\n-  return digest_init_r (type, init, false, LOOKUP_IMPLICIT, complain);\n+  return digest_init_r (type, init, 0, LOOKUP_IMPLICIT, complain);\n }\n \n tree\n digest_init_flags (tree type, tree init, int flags, tsubst_flags_t complain)\n {\n-  return digest_init_r (type, init, false, flags, complain);\n+  return digest_init_r (type, init, 0, flags, complain);\n }\n \n /* Process the initializer INIT for an NSDMI DECL (a FIELD_DECL).  */\n@@ -1230,9 +1237,9 @@ picflag_from_initializer (tree init)\n /* Adjust INIT for going into a CONSTRUCTOR.  */\n \n static tree\n-massage_init_elt (tree type, tree init, tsubst_flags_t complain)\n+massage_init_elt (tree type, tree init, int nested, tsubst_flags_t complain)\n {\n-  init = digest_init_r (type, init, true, LOOKUP_IMPLICIT, complain);\n+  init = digest_init_r (type, init, nested ? 2 : 1, LOOKUP_IMPLICIT, complain);\n   /* Strip a simple TARGET_EXPR when we know this is an initializer.  */\n   if (SIMPLE_TARGET_EXPR_P (init))\n     init = TARGET_EXPR_INITIAL (init);\n@@ -1250,7 +1257,7 @@ massage_init_elt (tree type, tree init, tsubst_flags_t complain)\n    which describe the initializers.  */\n \n static int\n-process_init_constructor_array (tree type, tree init,\n+process_init_constructor_array (tree type, tree init, int nested,\n \t\t\t\ttsubst_flags_t complain)\n {\n   unsigned HOST_WIDE_INT i, len = 0;\n@@ -1273,6 +1280,15 @@ process_init_constructor_array (tree type, tree init,\n \t\t       TYPE_SIGN (TREE_TYPE (domain))).to_uhwi ();\n       else\n \tunbounded = true;  /* Take as many as there are.  */\n+\n+      if (nested == 2 && !domain && !vec_safe_is_empty (v))\n+\t{\n+\t  if (complain & tf_error)\n+\t    error_at (EXPR_LOC_OR_LOC (init, input_location),\n+\t\t      \"initialization of flexible array member \"\n+\t\t      \"in a nested context\");\n+\t  return PICFLAG_ERRONEOUS;\n+\t}\n     }\n   else\n     /* Vectors are like simple fixed-size arrays.  */\n@@ -1301,7 +1317,8 @@ process_init_constructor_array (tree type, tree init,\n       else\n \tce->index = size_int (i);\n       gcc_assert (ce->value);\n-      ce->value = massage_init_elt (TREE_TYPE (type), ce->value, complain);\n+      ce->value\n+\t= massage_init_elt (TREE_TYPE (type), ce->value, nested, complain);\n \n       if (ce->value != error_mark_node)\n \tgcc_assert (same_type_ignoring_top_level_qualifiers_p\n@@ -1323,7 +1340,7 @@ process_init_constructor_array (tree type, tree init,\n \t       we can't rely on the back end to do it for us, so make the\n \t       initialization explicit by list-initializing from T{}.  */\n \t    next = build_constructor (init_list_type_node, NULL);\n-\t    next = massage_init_elt (TREE_TYPE (type), next, complain);\n+\t    next = massage_init_elt (TREE_TYPE (type), next, nested, complain);\n \t    if (initializer_zerop (next))\n \t      /* The default zero-initialization is fine for us; don't\n \t\t add anything to the CONSTRUCTOR.  */\n@@ -1354,7 +1371,7 @@ process_init_constructor_array (tree type, tree init,\n    the initializers.  */\n \n static int\n-process_init_constructor_record (tree type, tree init,\n+process_init_constructor_record (tree type, tree init, int nested,\n \t\t\t\t tsubst_flags_t complain)\n {\n   vec<constructor_elt, va_gc> *v = NULL;\n@@ -1436,7 +1453,7 @@ process_init_constructor_record (tree type, tree init,\n \t  if (ce)\n \t    {\n \t      gcc_assert (ce->value);\n-\t      next = massage_init_elt (type, next, complain);\n+\t      next = massage_init_elt (type, next, nested, complain);\n \t      ++idx;\n \t    }\n \t}\n@@ -1462,7 +1479,7 @@ process_init_constructor_record (tree type, tree init,\n \t     for us, so build up TARGET_EXPRs.  If the type in question is\n \t     a class, just build one up; if it's an array, recurse.  */\n \t  next = build_constructor (init_list_type_node, NULL);\n-\t  next = massage_init_elt (TREE_TYPE (field), next, complain);\n+\t  next = massage_init_elt (TREE_TYPE (field), next, nested, complain);\n \n \t  /* Warn when some struct elements are implicitly initialized.  */\n \t  if ((complain & tf_warning)\n@@ -1576,7 +1593,7 @@ process_init_constructor_record (tree type, tree init,\n    which describe the initializer.  */\n \n static int\n-process_init_constructor_union (tree type, tree init,\n+process_init_constructor_union (tree type, tree init, int nested,\n \t\t\t\ttsubst_flags_t complain)\n {\n   constructor_elt *ce;\n@@ -1662,7 +1679,8 @@ process_init_constructor_union (tree type, tree init,\n     }\n \n   if (ce->value && ce->value != error_mark_node)\n-    ce->value = massage_init_elt (TREE_TYPE (ce->index), ce->value, complain);\n+    ce->value = massage_init_elt (TREE_TYPE (ce->index), ce->value, nested,\n+\t\t\t\t  complain);\n \n   return picflag_from_initializer (ce->value);\n }\n@@ -1682,18 +1700,19 @@ process_init_constructor_union (tree type, tree init,\n    of error.  */\n \n static tree\n-process_init_constructor (tree type, tree init, tsubst_flags_t complain)\n+process_init_constructor (tree type, tree init, int nested,\n+\t\t\t  tsubst_flags_t complain)\n {\n   int flags;\n \n   gcc_assert (BRACE_ENCLOSED_INITIALIZER_P (init));\n \n   if (TREE_CODE (type) == ARRAY_TYPE || VECTOR_TYPE_P (type))\n-    flags = process_init_constructor_array (type, init, complain);\n+    flags = process_init_constructor_array (type, init, nested, complain);\n   else if (TREE_CODE (type) == RECORD_TYPE)\n-    flags = process_init_constructor_record (type, init, complain);\n+    flags = process_init_constructor_record (type, init, nested, complain);\n   else if (TREE_CODE (type) == UNION_TYPE)\n-    flags = process_init_constructor_union (type, init, complain);\n+    flags = process_init_constructor_union (type, init, nested, complain);\n   else\n     gcc_unreachable ();\n "}, {"sha": "e1e29f195fd3ea25cc3fcf0a20bfe5e02660bf59", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c55cacaf8fa1e90f9e26c467a78081ae152b50/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c55cacaf8fa1e90f9e26c467a78081ae152b50/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a8c55cacaf8fa1e90f9e26c467a78081ae152b50", "patch": "@@ -1,5 +1,24 @@\n 2017-12-15  Jakub Jelinek  <jakub@redhat.com>\n \n+\tPR c++/80135\n+\tPR c++/81922\n+\t* g++.dg/warn/Wplacement-new-size-1.C (fBx1): Initialize nested\n+\tflexible array member only with {}.  Add dg-warning.\n+\t(fBx2, fBx3): Remove.\n+\t* g++.dg/warn/Wplacement-new-size-2.C (fBx1): Initialize nested\n+\tflexible array member only with {}.  Add dg-warning.\n+\t(fBx2, fBx3): Remove.\n+\t* g++.dg/warn/Wplacement-new-size-6.C: New test.\n+\t* g++.dg/ext/flexary13.C (main): Remove test for initialization\n+\tof nested flexible array member with non-empty initializer.\n+\t* g++.dg/ext/flexary25.C: New test.\n+\t* g++.dg/ext/flexary26.C: New test.\n+\t* g++.dg/ext/flexary27.C: New test.\n+\t* g++.dg/parse/pr43765.C: Expect diagnostics about initialization\n+\tof nested flexible array member with non-empty initializer.  Expect\n+\tC++2A diagnostics about mixing of designated and non-designated\n+\tinitializers.\n+\n \tPR c++/83217\n \t* g++.dg/cpp1z/decomp33.C: New test.\n "}, {"sha": "f1f4e22a3ffaeab76077947447c67256596b6126", "filename": "gcc/testsuite/g++.dg/ext/flexary13.C", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c55cacaf8fa1e90f9e26c467a78081ae152b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fflexary13.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c55cacaf8fa1e90f9e26c467a78081ae152b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fflexary13.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fflexary13.C?ref=a8c55cacaf8fa1e90f9e26c467a78081ae152b50", "patch": "@@ -55,10 +55,4 @@ int main ()\n       { 1, { 2 } };   // dg-warning \"initialization of a flexible array member\" }\n     ASSERT (s.i == 1 && s.ax.n == 2);\n   }\n-\n-  {\n-    AAx s =\n-      { 1, { 2, { 3 } } };   // dg-warning \"initialization of a flexible array member\" }\n-    ASSERT (s.i == 1 && s.ax.n == 2 && s.ax.a [0] == 3);\n-  }\n }"}, {"sha": "e0582a937c91e46142daf16c65083ca8998e81fc", "filename": "gcc/testsuite/g++.dg/ext/flexary25.C", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c55cacaf8fa1e90f9e26c467a78081ae152b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fflexary25.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c55cacaf8fa1e90f9e26c467a78081ae152b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fflexary25.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fflexary25.C?ref=a8c55cacaf8fa1e90f9e26c467a78081ae152b50", "patch": "@@ -0,0 +1,20 @@\n+// PR c++/81922\n+// { dg-do compile }\n+// { dg-options \"\" }\n+\n+struct S { const char *a; char b[]; };\n+struct T { int a; int b[]; };\n+#if __cplusplus >= 201103L\n+S c[] { \"\", \"\" };\t\t// { dg-error \"initialization of flexible array member in a nested context\" \"\" { target c++11 } }\n+S d[] { \"\", { 0 } };\t\t// { dg-error \"initialization of flexible array member in a nested context\" \"\" { target c++11 } }\n+T e[] { 1, { 2 }, 3, { 4 } };\t// { dg-error \"initialization of flexible array member in a nested context\" \"\" { target c++11 } }\n+T f[] { 1, {}, 3, {} };\n+T g { 1, { 1, 2, 3 } };\n+S h { \"abcd\", \"\" };\n+#endif\n+S i[] = { \"\", \"\", \"\", \"\" };\t// { dg-error \"initialization of flexible array member in a nested context\" }\n+S j[] = { \"\", { 1 }, \"\", { 2, 3 } };\t// { dg-error \"initialization of flexible array member in a nested context\" }\n+T k[] = { 1, { 2 }, 3, { 4 } };\t// { dg-error \"initialization of flexible array member in a nested context\" }\n+T l[] = { 1, {}, 3, {} };\n+T m = { 1, { 1, 2, 3 } };\n+S n = { \"\", \"abcde\" };"}, {"sha": "af1277287aae76e6bc011d17eaa152621fa457f9", "filename": "gcc/testsuite/g++.dg/ext/flexary26.C", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c55cacaf8fa1e90f9e26c467a78081ae152b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fflexary26.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c55cacaf8fa1e90f9e26c467a78081ae152b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fflexary26.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fflexary26.C?ref=a8c55cacaf8fa1e90f9e26c467a78081ae152b50", "patch": "@@ -0,0 +1,26 @@\n+// PR c++/81922\n+// { dg-do compile }\n+// { dg-options \"-Wpedantic\" }\n+\n+struct S { const char *a; char b[]; };\t// { dg-warning \"forbids flexible array member\" }\n+struct T { int a; int b[]; };\t// { dg-warning \"forbids flexible array member\" }\n+#if __cplusplus >= 201103L\n+S c[] { \"\", \"\" };\t\t// { dg-error \"initialization of flexible array member in a nested context\" \"\" { target c++11 } }\n+\t\t\t\t// { dg-warning \"initialization of a flexible array member\" \"\" { target c++11 } .-1 }\n+S d[] { \"\", { 0 } };\t\t// { dg-error \"initialization of flexible array member in a nested context\" \"\" { target c++11 } }\n+\t\t\t\t// { dg-warning \"initialization of a flexible array member\" \"\" { target c++11 } .-1 }\n+T e[] { 1, { 2 }, 3, { 4 } };\t// { dg-error \"initialization of flexible array member in a nested context\" \"\" { target c++11 } }\n+\t\t\t\t// { dg-warning \"initialization of a flexible array member\" \"\" { target c++11 } .-1 }\n+T f[] { 1, {}, 3, {} };\t\t// { dg-warning \"initialization of a flexible array member\" \"\" { target c++11 } }\n+T g { 1, { 1, 2, 3 } };\t\t// { dg-warning \"initialization of a flexible array member\" \"\" { target c++11 } }\n+S h { \"abcd\", \"\" };\t\t// { dg-warning \"initialization of a flexible array member\" \"\" { target c++11 } }\n+#endif\n+S i[] = { \"\", \"\", \"\", \"\" };\t// { dg-error \"initialization of flexible array member in a nested context\" }\n+\t\t\t\t// { dg-warning \"initialization of a flexible array member\" \"\" { target *-*-* } .-1 }\n+S j[] = { \"\", { 1 }, \"\", { 2, 3 } };\t// { dg-error \"initialization of flexible array member in a nested context\" }\n+\t\t\t\t// { dg-warning \"initialization of a flexible array member\" \"\" { target *-*-* } .-1 }\n+T k[] = { 1, { 2 }, 3, { 4 } };\t// { dg-error \"initialization of flexible array member in a nested context\" }\n+\t\t\t\t// { dg-warning \"initialization of a flexible array member\" \"\" { target *-*-* } .-1 }\n+T l[] = { 1, {}, 3, {} };\t// { dg-warning \"initialization of a flexible array member\" }\n+T m = { 1, { 1, 2, 3 } };\t// { dg-warning \"initialization of a flexible array member\" }\n+S n = { \"\", \"abcde\" };\t\t// { dg-warning \"initialization of a flexible array member\" }"}, {"sha": "9dfa9a2b82c9481176bb9eeffe7f9021fec89695", "filename": "gcc/testsuite/g++.dg/ext/flexary27.C", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c55cacaf8fa1e90f9e26c467a78081ae152b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fflexary27.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c55cacaf8fa1e90f9e26c467a78081ae152b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fflexary27.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fflexary27.C?ref=a8c55cacaf8fa1e90f9e26c467a78081ae152b50", "patch": "@@ -0,0 +1,25 @@\n+// PR c++/81922\n+// { dg-do compile }\n+\n+struct S { const char *a; char b[]; };\t// { dg-error \"forbids flexible array member\" }\n+struct T { int a; int b[]; };\t// { dg-error \"forbids flexible array member\" }\n+#if __cplusplus >= 201103L\n+S c[] { \"\", \"\" };\t\t// { dg-error \"initialization of flexible array member in a nested context\" \"\" { target c++11 } }\n+\t\t\t\t// { dg-error \"initialization of a flexible array member\" \"\" { target c++11 } .-1 }\n+S d[] { \"\", { 0 } };\t\t// { dg-error \"initialization of flexible array member in a nested context\" \"\" { target c++11 } }\n+\t\t\t\t// { dg-error \"initialization of a flexible array member\" \"\" { target c++11 } .-1 }\n+T e[] { 1, { 2 }, 3, { 4 } };\t// { dg-error \"initialization of flexible array member in a nested context\" \"\" { target c++11 } }\n+\t\t\t\t// { dg-error \"initialization of a flexible array member\" \"\" { target c++11 } .-1 }\n+T f[] { 1, {}, 3, {} };\t\t// { dg-error \"initialization of a flexible array member\" \"\" { target c++11 } }\n+T g { 1, { 1, 2, 3 } };\t\t// { dg-error \"initialization of a flexible array member\" \"\" { target c++11 } }\n+S h { \"abcd\", \"\" };\t\t// { dg-error \"initialization of a flexible array member\" \"\" { target c++11 } }\n+#endif\n+S i[] = { \"\", \"\", \"\", \"\" };\t// { dg-error \"initialization of flexible array member in a nested context\" }\n+\t\t\t\t// { dg-error \"initialization of a flexible array member\" \"\" { target *-*-* } .-1 }\n+S j[] = { \"\", { 1 }, \"\", { 2, 3 } };\t// { dg-error \"initialization of flexible array member in a nested context\" }\n+\t\t\t\t// { dg-error \"initialization of a flexible array member\" \"\" { target *-*-* } .-1 }\n+T k[] = { 1, { 2 }, 3, { 4 } };\t// { dg-error \"initialization of flexible array member in a nested context\" }\n+\t\t\t\t// { dg-error \"initialization of a flexible array member\" \"\" { target *-*-* } .-1 }\n+T l[] = { 1, {}, 3, {} };\t// { dg-error \"initialization of a flexible array member\" }\n+T m = { 1, { 1, 2, 3 } };\t// { dg-error \"initialization of a flexible array member\" }\n+S n = { \"\", \"abcde\" };\t\t// { dg-error \"initialization of a flexible array member\" }"}, {"sha": "5e60220400731ae6cb69ef1da4d1c5feb3a82adb", "filename": "gcc/testsuite/g++.dg/parse/pr43765.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c55cacaf8fa1e90f9e26c467a78081ae152b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fpr43765.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c55cacaf8fa1e90f9e26c467a78081ae152b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fpr43765.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fpr43765.C?ref=a8c55cacaf8fa1e90f9e26c467a78081ae152b50", "patch": "@@ -10,8 +10,8 @@ const char *temp[] = {\"607\", \"612\", 0};\n \n SomeType vals[] =\n     {\n-        { 0, values : temp, },\n+        { 0, values : temp, },\t // { dg-error \"either all initializer clauses should be designated or none of them should be\" \"\" { target c++2a } }\n         0\n     };   // { dg-error \"GNU-style designated initializer for an array|cannot convert\" }\n // (note the error above is on the wrong line)\n- \n+\t // { dg-error \"initialization of flexible array member in a nested context\" \"\" { target *-*-* } .-2 }"}, {"sha": "716986d46645dffe2b01869787b6e4cf0e482611", "filename": "gcc/testsuite/g++.dg/warn/Wplacement-new-size-1.C", "status": "modified", "additions": 2, "deletions": 26, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c55cacaf8fa1e90f9e26c467a78081ae152b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWplacement-new-size-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c55cacaf8fa1e90f9e26c467a78081ae152b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWplacement-new-size-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWplacement-new-size-1.C?ref=a8c55cacaf8fa1e90f9e26c467a78081ae152b50", "patch": "@@ -82,38 +82,14 @@ void fBx (BAx *pbx, BAx &rbx)\n \n void fBx1 ()\n {\n-  BAx bax1 = { 1, /* Ax = */ { 2, /* a[] = */ { 3 } } };\n+  BAx bax1 = { 1, /* Ax = */ { 2, /* a[] = */ {} } };\n \n-  new (bax1.ax.a) char;\n+  new (bax1.ax.a) char;\t    // { dg-warning \"placement\" }\n   new (bax1.ax.a) char[2];  // { dg-warning \"placement\" }\n   new (bax1.ax.a) Int16;    // { dg-warning \"placement\" }\n   new (bax1.ax.a) Int32;    // { dg-warning \"placement\" }\n }\n \n-void fBx2 ()\n-{\n-  BAx bax2 = { 1, /* Ax = */ { 2, /* a[] = */ { 3, 4 } } };\n-\n-  new (bax2.ax.a) char;\n-  new (bax2.ax.a) char[2];\n-  new (bax2.ax.a) char[3];    // { dg-warning \"placement\" }\n-  new (bax2.ax.a) Int16;\n-  new (bax2.ax.a) char[4];    // { dg-warning \"placement\" }\n-  new (bax2.ax.a) Int32;      // { dg-warning \"placement\" }\n-}\n-\n-void fBx3 ()\n-{\n-  BAx bax2 = { 1, /* Ax = */ { 3, /* a[] = */ { 4, 5, 6 } } };\n-\n-  new (bax2.ax.a) char;\n-  new (bax2.ax.a) char[2];\n-  new (bax2.ax.a) Int16;\n-  new (bax2.ax.a) char[3];\n-  new (bax2.ax.a) char[4];    // { dg-warning \"placement\" }\n-  new (bax2.ax.a) Int32;      // { dg-warning \"placement\" }\n-}\n-\n void fB0 (BA0 *pb0, BA0 &rb0)\n {\n   BA0 ba0;"}, {"sha": "3d470747e24315c12c921c0c0c605ee5ae0e5df9", "filename": "gcc/testsuite/g++.dg/warn/Wplacement-new-size-2.C", "status": "modified", "additions": 2, "deletions": 26, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c55cacaf8fa1e90f9e26c467a78081ae152b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWplacement-new-size-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c55cacaf8fa1e90f9e26c467a78081ae152b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWplacement-new-size-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWplacement-new-size-2.C?ref=a8c55cacaf8fa1e90f9e26c467a78081ae152b50", "patch": "@@ -140,38 +140,14 @@ void fBx (BAx *pbx, BAx &rbx)\n \n void fBx1 ()\n {\n-  BAx bax1 = { 1, /* Ax = */ { 2, /* a[] = */ { 3 } } };\n+  BAx bax1 = { 1, /* Ax = */ { 2, /* a[] = */ {} } };\n \n-  new (bax1.ax.a) char;\n+  new (bax1.ax.a) char;\t      // { dg-warning \"placement\" }\n   new (bax1.ax.a) char[2];    // { dg-warning \"placement\" }\n   new (bax1.ax.a) Int16;      // { dg-warning \"placement\" }\n   new (bax1.ax.a) Int32;      // { dg-warning \"placement\" }\n }\n \n-void fBx2 ()\n-{\n-  BAx bax2 = { 1, /* Ax = */ { 2, /* a[] = */ { 3, 4 } } };\n-\n-  new (bax2.ax.a) char;\n-  new (bax2.ax.a) char[2];\n-  new (bax2.ax.a) char[3];    // { dg-warning \"placement\" }\n-  new (bax2.ax.a) Int16;\n-  new (bax2.ax.a) char[4];    // { dg-warning \"placement\" }\n-  new (bax2.ax.a) Int32;      // { dg-warning \"placement\" }\n-}\n-\n-void fBx3 ()\n-{\n-  BAx bax2 = { 1, /* Ax = */ { 3, /* a[] = */ { 4, 5, 6 } } };\n-\n-  new (bax2.ax.a) char;\n-  new (bax2.ax.a) char[2];\n-  new (bax2.ax.a) Int16;\n-  new (bax2.ax.a) char[3];\n-  new (bax2.ax.a) char[4];    // { dg-warning \"placement\" }\n-  new (bax2.ax.a) Int32;      // { dg-warning \"placement\" }\n-}\n-\n void fB0 (BA0 *pb0, BA0 &rb0)\n {\n   BA0 ba0;"}, {"sha": "06dfb3a0ba0b4d80486539a1c5518f284597ae24", "filename": "gcc/testsuite/g++.dg/warn/Wplacement-new-size-6.C", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c55cacaf8fa1e90f9e26c467a78081ae152b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWplacement-new-size-6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c55cacaf8fa1e90f9e26c467a78081ae152b50/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWplacement-new-size-6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWplacement-new-size-6.C?ref=a8c55cacaf8fa1e90f9e26c467a78081ae152b50", "patch": "@@ -0,0 +1,48 @@\n+// { dg-do compile }\n+// { dg-options \"-Wno-pedantic -Wplacement-new=1\" }\n+\n+typedef __typeof__ (sizeof 0) size_t;\n+\n+void* operator new (size_t, void *p) { return p; }\n+void* operator new[] (size_t, void *p) { return p; }\n+\n+struct Ax { char n, a []; };\n+\n+typedef __INT16_TYPE__ Int16;\n+typedef __INT32_TYPE__ Int32;\n+\n+struct BAx { int i; Ax ax; };\n+\n+void fBx1 ()\n+{\n+  BAx bax1 = { 1, /* Ax = */ { 2, /* a[] = */ { 3 } } };\t// { dg-error \"initialization of flexible array member in a nested context\" }\n+\n+  new (bax1.ax.a) char;     // { dg-warning \"placement\" }\n+  new (bax1.ax.a) char[2];  // { dg-warning \"placement\" }\n+  new (bax1.ax.a) Int16;    // { dg-warning \"placement\" }\n+  new (bax1.ax.a) Int32;    // { dg-warning \"placement\" }\n+}\n+\n+void fBx2 ()\n+{\n+  BAx bax2 = { 1, /* Ax = */ { 2, /* a[] = */ { 3, 4 } } };\t// { dg-error \"initialization of flexible array member in a nested context\" }\n+\n+  new (bax2.ax.a) char;       // { dg-warning \"placement\" }\n+  new (bax2.ax.a) char[2];    // { dg-warning \"placement\" }\n+  new (bax2.ax.a) char[3];    // { dg-warning \"placement\" }\n+  new (bax2.ax.a) Int16;      // { dg-warning \"placement\" }\n+  new (bax2.ax.a) char[4];    // { dg-warning \"placement\" }\n+  new (bax2.ax.a) Int32;      // { dg-warning \"placement\" }\n+}\n+\n+void fBx3 ()\n+{\n+  BAx bax2 = { 1, /* Ax = */ { 3, /* a[] = */ { 4, 5, 6 } } };\t// { dg-error \"initialization of flexible array member in a nested context\" }\n+\n+  new (bax2.ax.a) char;       // { dg-warning \"placement\" }\n+  new (bax2.ax.a) char[2];    // { dg-warning \"placement\" }\n+  new (bax2.ax.a) Int16;      // { dg-warning \"placement\" }\n+  new (bax2.ax.a) char[3];    // { dg-warning \"placement\" }\n+  new (bax2.ax.a) char[4];    // { dg-warning \"placement\" }\n+  new (bax2.ax.a) Int32;      // { dg-warning \"placement\" }\n+}"}]}