{"sha": "b24d94207914fb8695bd7307187a5a0bfcddc8c2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjI0ZDk0MjA3OTE0ZmI4Njk1YmQ3MzA3MTg3YTVhMGJmY2RkYzhjMg==", "commit": {"author": {"name": "Bin Cheng", "email": "bin.cheng@arm.com", "date": "2016-07-21T10:52:13Z"}, "committer": {"name": "Bin Cheng", "email": "amker@gcc.gnu.org", "date": "2016-07-21T10:52:13Z"}, "message": "tree-chrec.c (convert_affine_scev): New parameter.\n\n\t* tree-chrec.c (convert_affine_scev): New parameter.  Pass new arg.\n\t(chrec_convert_1, chrec_convert): Ditto.\n\t* tree-chrec.h (chrec_convert, convert_affine_scev): New parameter.\n\t* tree-scalar-evolution.c (interpret_rhs_expr): Pass new arg.\n\t* tree-vrp.c (adjust_range_with_scev): Ditto.\n\t* tree-ssa-loop-niter.c (idx_infer_loop_bounds): Ditto.\n\t(scev_var_range_cant_overflow): New function.\n\t(scev_probably_wraps_p): New parameter.  Call above function.\n\t* tree-ssa-loop-niter.h (scev_probably_wraps_p): New parameter.\n\n\tgcc/testsuite\n\t* gcc.dg/tree-ssa/scev-15.c: New.\n\nFrom-SVN: r238586", "tree": {"sha": "5395d978a3d736c900e79a29efb655abdb1d10e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5395d978a3d736c900e79a29efb655abdb1d10e6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b24d94207914fb8695bd7307187a5a0bfcddc8c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b24d94207914fb8695bd7307187a5a0bfcddc8c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b24d94207914fb8695bd7307187a5a0bfcddc8c2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b24d94207914fb8695bd7307187a5a0bfcddc8c2/comments", "author": null, "committer": null, "parents": [{"sha": "106d07f8d20542c5a0acad3699843aa26b2ee84f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/106d07f8d20542c5a0acad3699843aa26b2ee84f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/106d07f8d20542c5a0acad3699843aa26b2ee84f"}], "stats": {"total": 200, "additions": 174, "deletions": 26}, "files": [{"sha": "be5662a3a5e8d464e58a05845fcb70c6c34110ef", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b24d94207914fb8695bd7307187a5a0bfcddc8c2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b24d94207914fb8695bd7307187a5a0bfcddc8c2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b24d94207914fb8695bd7307187a5a0bfcddc8c2", "patch": "@@ -1,3 +1,15 @@\n+2016-07-21  Bin Cheng  <bin.cheng@arm.com>\n+\n+\t* tree-chrec.c (convert_affine_scev): New parameter.  Pass new arg.\n+\t(chrec_convert_1, chrec_convert): Ditto.\n+\t* tree-chrec.h (chrec_convert, convert_affine_scev): New parameter.\n+\t* tree-scalar-evolution.c (interpret_rhs_expr): Pass new arg.\n+\t* tree-vrp.c (adjust_range_with_scev): Ditto.\n+\t* tree-ssa-loop-niter.c (idx_infer_loop_bounds): Ditto.\n+\t(scev_var_range_cant_overflow): New function.\n+\t(scev_probably_wraps_p): New parameter.  Call above function.\n+\t* tree-ssa-loop-niter.h (scev_probably_wraps_p): New parameter.\n+\n 2016-07-21  Bin Cheng  <bin.cheng@arm.com>\n \n \t* tree-ssa-loop-niter.c (number_of_iterations_lt_to_ne): Clean up"}, {"sha": "61b6fa900518f52ef97c352e53075b7ae05e6d0a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b24d94207914fb8695bd7307187a5a0bfcddc8c2/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b24d94207914fb8695bd7307187a5a0bfcddc8c2/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b24d94207914fb8695bd7307187a5a0bfcddc8c2", "patch": "@@ -1,3 +1,7 @@\n+2016-07-21  Bin Cheng  <bin.cheng@arm.com>\n+\n+\t* gcc.dg/tree-ssa/scev-15.c: New.\n+\n 2016-07-21  Bin Cheng  <bin.cheng@arm.com>\n \n \t* gcc.dg/vect/vect-mask-store-move-1.c: XFAIL."}, {"sha": "a0d2e595e982f4718a2e2a4ca76ae8a21e7fb6ff", "filename": "gcc/testsuite/gcc.dg/tree-ssa/scev-15.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b24d94207914fb8695bd7307187a5a0bfcddc8c2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fscev-15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b24d94207914fb8695bd7307187a5a0bfcddc8c2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fscev-15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fscev-15.c?ref=b24d94207914fb8695bd7307187a5a0bfcddc8c2", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fdump-tree-ldist\" } */\n+\n+void\n+foo (int *p)\n+{\n+  unsigned short i, j;\n+\n+  for (i = 0; i < 100; i++)\n+    for (j = 1; j < 101; j++)\n+      {\n+\tunsigned int index = 100 * i + j;\n+\tp[index-1] = 0;\n+      }\n+}\n+\n+/* Loop can be transformed into builtin memset since &p[...] is SCEV.  */\n+/* { dg-final { scan-tree-dump \"builtin_memset\" \"ldist\" } } */"}, {"sha": "707a3aa988e2673ee81debca483c9018b66ee36e", "filename": "gcc/tree-chrec.c", "status": "modified", "additions": 23, "deletions": 17, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b24d94207914fb8695bd7307187a5a0bfcddc8c2/gcc%2Ftree-chrec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b24d94207914fb8695bd7307187a5a0bfcddc8c2/gcc%2Ftree-chrec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-chrec.c?ref=b24d94207914fb8695bd7307187a5a0bfcddc8c2", "patch": "@@ -1162,16 +1162,17 @@ nb_vars_in_chrec (tree chrec)\n \n /* Converts BASE and STEP of affine scev to TYPE.  LOOP is the loop whose iv\n    the scev corresponds to.  AT_STMT is the statement at that the scev is\n-   evaluated.  USE_OVERFLOW_SEMANTICS is true if this function should assume that\n-   the rules for overflow of the given language apply (e.g., that signed\n-   arithmetics in C does not overflow) -- i.e., to use them to avoid unnecessary\n-   tests, but also to enforce that the result follows them.  Returns true if the\n-   conversion succeeded, false otherwise.  */\n+   evaluated.  USE_OVERFLOW_SEMANTICS is true if this function should assume\n+   that the rules for overflow of the given language apply (e.g., that signed\n+   arithmetics in C does not overflow) -- i.e., to use them to avoid\n+   unnecessary tests, but also to enforce that the result follows them.\n+   FROM is the source variable converted if it's not NULL.  Returns true if\n+   the conversion succeeded, false otherwise.  */\n \n bool\n convert_affine_scev (struct loop *loop, tree type,\n \t\t     tree *base, tree *step, gimple *at_stmt,\n-\t\t     bool use_overflow_semantics)\n+\t\t     bool use_overflow_semantics, tree from)\n {\n   tree ct = TREE_TYPE (*step);\n   bool enforce_overflow_semantics;\n@@ -1230,7 +1231,7 @@ convert_affine_scev (struct loop *loop, tree type,\n     must_check_rslt_overflow = false;\n \n   if (must_check_src_overflow\n-      && scev_probably_wraps_p (*base, *step, at_stmt, loop,\n+      && scev_probably_wraps_p (from, *base, *step, at_stmt, loop,\n \t\t\t\tuse_overflow_semantics))\n     return false;\n \n@@ -1258,7 +1259,8 @@ convert_affine_scev (struct loop *loop, tree type,\n   if (must_check_rslt_overflow\n       /* Note that in this case we cannot use the fact that signed variables\n \t do not overflow, as this is what we are verifying for the new iv.  */\n-      && scev_probably_wraps_p (new_base, new_step, at_stmt, loop, false))\n+      && scev_probably_wraps_p (NULL_TREE, new_base, new_step,\n+\t\t\t\tat_stmt, loop, false))\n     return false;\n \n   *base = new_base;\n@@ -1288,12 +1290,14 @@ chrec_convert_rhs (tree type, tree chrec, gimple *at_stmt)\n \n    USE_OVERFLOW_SEMANTICS is true if this function should assume that\n    the rules for overflow of the given language apply (e.g., that signed\n-   arithmetics in C does not overflow) -- i.e., to use them to avoid unnecessary\n-   tests, but also to enforce that the result follows them.  */\n+   arithmetics in C does not overflow) -- i.e., to use them to avoid\n+   unnecessary tests, but also to enforce that the result follows them.\n+\n+   FROM is the source variable converted if it's not NULL.  */\n \n static tree\n chrec_convert_1 (tree type, tree chrec, gimple *at_stmt,\n-\t\t bool use_overflow_semantics)\n+\t\t bool use_overflow_semantics, tree from)\n {\n   tree ct, res;\n   tree base, step;\n@@ -1314,7 +1318,7 @@ chrec_convert_1 (tree type, tree chrec, gimple *at_stmt,\n   step = CHREC_RIGHT (chrec);\n \n   if (convert_affine_scev (loop, type, &base, &step, at_stmt,\n-\t\t\t   use_overflow_semantics))\n+\t\t\t   use_overflow_semantics, from))\n     return build_polynomial_chrec (loop->num, base, step);\n \n   /* If we cannot propagate the cast inside the chrec, just keep the cast.  */\n@@ -1347,7 +1351,7 @@ chrec_convert_1 (tree type, tree chrec, gimple *at_stmt,\n \t\t\t\t\t\t  CHREC_LEFT (chrec)),\n \t\t\t\t    fold_convert (utype,\n \t\t\t\t\t\t  CHREC_RIGHT (chrec)));\n-      res = chrec_convert_1 (type, res, at_stmt, use_overflow_semantics);\n+      res = chrec_convert_1 (type, res, at_stmt, use_overflow_semantics, from);\n     }\n   else\n     res = fold_convert (type, chrec);\n@@ -1395,14 +1399,16 @@ chrec_convert_1 (tree type, tree chrec, gimple *at_stmt,\n \n    USE_OVERFLOW_SEMANTICS is true if this function should assume that\n    the rules for overflow of the given language apply (e.g., that signed\n-   arithmetics in C does not overflow) -- i.e., to use them to avoid unnecessary\n-   tests, but also to enforce that the result follows them.  */\n+   arithmetics in C does not overflow) -- i.e., to use them to avoid\n+   unnecessary tests, but also to enforce that the result follows them.\n+\n+   FROM is the source variable converted if it's not NULL.  */\n \n tree\n chrec_convert (tree type, tree chrec, gimple *at_stmt,\n-\t       bool use_overflow_semantics)\n+\t       bool use_overflow_semantics, tree from)\n {\n-  return chrec_convert_1 (type, chrec, at_stmt, use_overflow_semantics);\n+  return chrec_convert_1 (type, chrec, at_stmt, use_overflow_semantics, from);\n }\n \n /* Convert CHREC to TYPE, without regard to signed overflows.  Returns the new"}, {"sha": "877330e92d4cc22bb72d463941b8135fc8e3db21", "filename": "gcc/tree-chrec.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b24d94207914fb8695bd7307187a5a0bfcddc8c2/gcc%2Ftree-chrec.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b24d94207914fb8695bd7307187a5a0bfcddc8c2/gcc%2Ftree-chrec.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-chrec.h?ref=b24d94207914fb8695bd7307187a5a0bfcddc8c2", "patch": "@@ -59,7 +59,7 @@ enum ev_direction scev_direction (const_tree);\n extern tree chrec_fold_plus (tree, tree, tree);\n extern tree chrec_fold_minus (tree, tree, tree);\n extern tree chrec_fold_multiply (tree, tree, tree);\n-extern tree chrec_convert (tree, tree, gimple *, bool = true);\n+extern tree chrec_convert (tree, tree, gimple *, bool = true, tree = NULL);\n extern tree chrec_convert_rhs (tree, tree, gimple *);\n extern tree chrec_convert_aggressive (tree, tree, bool *);\n \n@@ -75,7 +75,7 @@ extern tree reset_evolution_in_loop (unsigned, tree, tree);\n extern tree chrec_merge (tree, tree);\n extern void for_each_scev_op (tree *, bool (*) (tree *, void *), void *);\n extern bool convert_affine_scev (struct loop *, tree, tree *, tree *, gimple *,\n-\t\t\t\t bool);\n+\t\t\t\t bool, tree = NULL);\n \n /* Observers.  */\n extern bool eq_evolutions_p (const_tree, const_tree);"}, {"sha": "7c5cefde068056f65001ee94d9b8c99ff958d1f8", "filename": "gcc/tree-scalar-evolution.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b24d94207914fb8695bd7307187a5a0bfcddc8c2/gcc%2Ftree-scalar-evolution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b24d94207914fb8695bd7307187a5a0bfcddc8c2/gcc%2Ftree-scalar-evolution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.c?ref=b24d94207914fb8695bd7307187a5a0bfcddc8c2", "patch": "@@ -1933,7 +1933,7 @@ interpret_rhs_expr (struct loop *loop, gimple *at_stmt,\n \t}\n       else\n \tchrec1 = analyze_scalar_evolution (loop, rhs1);\n-      res = chrec_convert (type, chrec1, at_stmt);\n+      res = chrec_convert (type, chrec1, at_stmt, true, rhs1);\n       break;\n \n     case BIT_AND_EXPR:"}, {"sha": "3b4d4f31502f6ca35331f9a6fd9e1f4ca5772d9a", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 110, "deletions": 3, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b24d94207914fb8695bd7307187a5a0bfcddc8c2/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b24d94207914fb8695bd7307187a5a0bfcddc8c2/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=b24d94207914fb8695bd7307187a5a0bfcddc8c2", "patch": "@@ -3128,7 +3128,8 @@ idx_infer_loop_bounds (tree base, tree *idx, void *dta)\n   /* If access is not executed on every iteration, we must ensure that overlow\n      may not make the access valid later.  */\n   if (!dominated_by_p (CDI_DOMINATORS, loop->latch, gimple_bb (data->stmt))\n-      && scev_probably_wraps_p (initial_condition_in_loop_num (ev, loop->num),\n+      && scev_probably_wraps_p (NULL_TREE,\n+\t\t\t\tinitial_condition_in_loop_num (ev, loop->num),\n \t\t\t\tstep, data->stmt, loop, true))\n     upper = false;\n \n@@ -4191,6 +4192,104 @@ loop_exits_before_overflow (tree base, tree step,\n   return false;\n }\n \n+/* VAR is scev variable whose evolution part is constant STEP, this function\n+   proves that VAR can't overflow by using value range info.  If VAR's value\n+   range is [MIN, MAX], it can be proven by:\n+     MAX + step doesn't overflow    ; if step > 0\n+   or\n+     MIN + step doesn't underflow   ; if step < 0.\n+\n+   We can only do this if var is computed in every loop iteration, i.e, var's\n+   definition has to dominate loop latch.  Consider below example:\n+\n+     {\n+       unsigned int i;\n+\n+       <bb 3>:\n+\n+       <bb 4>:\n+       # RANGE [0, 4294967294] NONZERO 65535\n+       # i_21 = PHI <0(3), i_18(9)>\n+       if (i_21 != 0)\n+\t goto <bb 6>;\n+       else\n+\t goto <bb 8>;\n+\n+       <bb 6>:\n+       # RANGE [0, 65533] NONZERO 65535\n+       _6 = i_21 + 4294967295;\n+       # RANGE [0, 65533] NONZERO 65535\n+       _7 = (long unsigned int) _6;\n+       # RANGE [0, 524264] NONZERO 524280\n+       _8 = _7 * 8;\n+       # PT = nonlocal escaped\n+       _9 = a_14 + _8;\n+       *_9 = 0;\n+\n+       <bb 8>:\n+       # RANGE [1, 65535] NONZERO 65535\n+       i_18 = i_21 + 1;\n+       if (i_18 >= 65535)\n+\t goto <bb 10>;\n+       else\n+\t goto <bb 9>;\n+\n+       <bb 9>:\n+       goto <bb 4>;\n+\n+       <bb 10>:\n+       return;\n+     }\n+\n+   VAR _6 doesn't overflow only with pre-condition (i_21 != 0), here we\n+   can't use _6 to prove no-overlfow for _7.  In fact, var _7 takes value\n+   sequence (4294967295, 0, 1, ..., 65533) in loop life time, rather than\n+   (4294967295, 4294967296, ...).  */\n+\n+static bool\n+scev_var_range_cant_overflow (tree var, tree step, struct loop *loop)\n+{\n+  tree type;\n+  wide_int minv, maxv, diff, step_wi;\n+  enum value_range_type rtype;\n+\n+  if (TREE_CODE (step) != INTEGER_CST || !INTEGRAL_TYPE_P (TREE_TYPE (var)))\n+    return false;\n+\n+  /* Check if VAR evaluates in every loop iteration.  It's not the case\n+     if VAR is default definition or does not dominate loop's latch.  */\n+  basic_block def_bb = gimple_bb (SSA_NAME_DEF_STMT (var));\n+  if (!def_bb || !dominated_by_p (CDI_DOMINATORS, loop->latch, def_bb))\n+    return false;\n+\n+  rtype = get_range_info (var, &minv, &maxv);\n+  if (rtype != VR_RANGE)\n+    return false;\n+\n+  /* VAR is a scev whose evolution part is STEP and value range info\n+     is [MIN, MAX], we can prove its no-overflowness by conditions:\n+\n+       type_MAX - MAX >= step   ; if step > 0\n+       MIN - type_MIN >= |step| ; if step < 0.\n+\n+     Or VAR must take value outside of value range, which is not true.  */\n+  step_wi = step;\n+  type = TREE_TYPE (var);\n+  if (tree_int_cst_sign_bit (step))\n+    {\n+      diff = lower_bound_in_type (type, type);\n+      diff = minv - diff;\n+      step_wi = - step_wi;\n+    }\n+  else\n+    {\n+      diff = upper_bound_in_type (type, type);\n+      diff = diff - maxv;\n+    }\n+\n+  return (wi::geu_p (diff, step_wi));\n+}\n+\n /* Return false only when the induction variable BASE + STEP * I is\n    known to not overflow: i.e. when the number of iterations is small\n    enough with respect to the step and initial condition in order to\n@@ -4199,10 +4298,13 @@ loop_exits_before_overflow (tree base, tree step,\n \n    USE_OVERFLOW_SEMANTICS is true if this function should assume that\n    the rules for overflow of the given language apply (e.g., that signed\n-   arithmetics in C does not overflow).  */\n+   arithmetics in C does not overflow).\n+\n+   If VAR is a ssa variable, this function also returns false if VAR can\n+   be proven not overflow with value range info.  */\n \n bool\n-scev_probably_wraps_p (tree base, tree step,\n+scev_probably_wraps_p (tree var, tree base, tree step,\n \t\t       gimple *at_stmt, struct loop *loop,\n \t\t       bool use_overflow_semantics)\n {\n@@ -4239,6 +4341,11 @@ scev_probably_wraps_p (tree base, tree step,\n   if (TREE_CODE (step) != INTEGER_CST)\n     return true;\n \n+  /* Check if var can be proven not overflow with value range info.  */\n+  if (var && TREE_CODE (var) == SSA_NAME\n+      && scev_var_range_cant_overflow (var, step, loop))\n+    return false;\n+\n   if (loop_exits_before_overflow (base, step, at_stmt, loop))\n     return false;\n "}, {"sha": "97400cb68846ea5fcd8c9623f84e94fbdb5bad3e", "filename": "gcc/tree-ssa-loop-niter.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b24d94207914fb8695bd7307187a5a0bfcddc8c2/gcc%2Ftree-ssa-loop-niter.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b24d94207914fb8695bd7307187a5a0bfcddc8c2/gcc%2Ftree-ssa-loop-niter.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.h?ref=b24d94207914fb8695bd7307187a5a0bfcddc8c2", "patch": "@@ -49,7 +49,8 @@ extern bool estimated_stmt_executions (struct loop *, widest_int *);\n extern void estimate_numbers_of_iterations (void);\n extern bool stmt_dominates_stmt_p (gimple *, gimple *);\n extern bool nowrap_type_p (tree);\n-extern bool scev_probably_wraps_p (tree, tree, gimple *, struct loop *, bool);\n+extern bool scev_probably_wraps_p (tree, tree, tree, gimple *,\n+\t\t\t\t   struct loop *, bool);\n extern void free_loop_control_ivs (struct loop *);\n extern void free_numbers_of_iterations_estimates_loop (struct loop *);\n extern void free_numbers_of_iterations_estimates (function *);"}, {"sha": "b9ccb73ff798ee9b8d45c7b936d6c6c834f6b888", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b24d94207914fb8695bd7307187a5a0bfcddc8c2/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b24d94207914fb8695bd7307187a5a0bfcddc8c2/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=b24d94207914fb8695bd7307187a5a0bfcddc8c2", "patch": "@@ -4156,8 +4156,8 @@ adjust_range_with_scev (value_range *vr, struct loop *loop,\n \t or decreases,  ... */\n       dir == EV_DIR_UNKNOWN\n       /* ... or if it may wrap.  */\n-      || scev_probably_wraps_p (init, step, stmt, get_chrec_loop (chrec),\n-\t\t\t\ttrue))\n+      || scev_probably_wraps_p (NULL_TREE, init, step, stmt,\n+\t\t\t\tget_chrec_loop (chrec), true))\n     return;\n \n   /* We use TYPE_MIN_VALUE and TYPE_MAX_VALUE here instead of"}]}