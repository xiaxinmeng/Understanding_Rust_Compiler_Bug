{"sha": "2aa3b677b13884a81e93202183802bbe6c8da9fe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmFhM2I2NzdiMTM4ODRhODFlOTMyMDIxODM4MDJiYmU2YzhkYTlmZQ==", "commit": {"author": {"name": "Andreas Schwab", "email": "schwab@linux-m68k.org", "date": "2012-10-06T11:42:13Z"}, "committer": {"name": "Andreas Schwab", "email": "schwab@gcc.gnu.org", "date": "2012-10-06T11:42:13Z"}, "message": "re PR rtl-optimization/54739 (FAIL: gcc.dg/lower-subreg-1.c scan-rtl-dump subreg1 \"Splitting reg\")\n\nPR rtl-optimization/54739\n* config/m68k/m68k.md (anddi3, iordi3, xordi3, one_cmpldi2):\nRemove.\n\nFrom-SVN: r192156", "tree": {"sha": "77a35f05e2182601aee5095e4c28c06d99e7492e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/77a35f05e2182601aee5095e4c28c06d99e7492e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2aa3b677b13884a81e93202183802bbe6c8da9fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2aa3b677b13884a81e93202183802bbe6c8da9fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2aa3b677b13884a81e93202183802bbe6c8da9fe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2aa3b677b13884a81e93202183802bbe6c8da9fe/comments", "author": {"login": "andreas-schwab", "id": 2175493, "node_id": "MDQ6VXNlcjIxNzU0OTM=", "avatar_url": "https://avatars.githubusercontent.com/u/2175493?v=4", "gravatar_id": "", "url": "https://api.github.com/users/andreas-schwab", "html_url": "https://github.com/andreas-schwab", "followers_url": "https://api.github.com/users/andreas-schwab/followers", "following_url": "https://api.github.com/users/andreas-schwab/following{/other_user}", "gists_url": "https://api.github.com/users/andreas-schwab/gists{/gist_id}", "starred_url": "https://api.github.com/users/andreas-schwab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/andreas-schwab/subscriptions", "organizations_url": "https://api.github.com/users/andreas-schwab/orgs", "repos_url": "https://api.github.com/users/andreas-schwab/repos", "events_url": "https://api.github.com/users/andreas-schwab/events{/privacy}", "received_events_url": "https://api.github.com/users/andreas-schwab/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7d11d29699c11ca758857a52003dcb016203eaef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d11d29699c11ca758857a52003dcb016203eaef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d11d29699c11ca758857a52003dcb016203eaef"}], "stats": {"total": 232, "additions": 6, "deletions": 226}, "files": [{"sha": "b44a1fe5c9274b1571c0d534d182f52b41a642c4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2aa3b677b13884a81e93202183802bbe6c8da9fe/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2aa3b677b13884a81e93202183802bbe6c8da9fe/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2aa3b677b13884a81e93202183802bbe6c8da9fe", "patch": "@@ -1,3 +1,9 @@\n+2012-10-06  Andreas Schwab  <schwab@linux-m68k.org>\n+\n+\tPR rtl-optimization/54739\n+\t* config/m68k/m68k.md (anddi3, iordi3, xordi3, one_cmpldi2):\n+\tRemove.\n+\n 2012-10-06  Oleg Endo  <olegendo@gcc.gnu.org>\n \n \tPR target/54760"}, {"sha": "5f67831a8f5f1499d951a62176180a3c90c5e7f6", "filename": "gcc/config/m68k/m68k.md", "status": "modified", "additions": 0, "deletions": 226, "changes": 226, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2aa3b677b13884a81e93202183802bbe6c8da9fe/gcc%2Fconfig%2Fm68k%2Fm68k.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2aa3b677b13884a81e93202183802bbe6c8da9fe/gcc%2Fconfig%2Fm68k%2Fm68k.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.md?ref=2aa3b677b13884a81e93202183802bbe6c8da9fe", "patch": "@@ -3597,72 +3597,6 @@\n \f\n ;; logical-and instructions\n \n-;; \"anddi3\" is mainly here to help combine().\n-(define_insn \"anddi3\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=o,d\")\n-\t(and:DI (match_operand:DI 1 \"general_operand\" \"%0,0\")\n-\t\t(match_operand:DI 2 \"general_operand\" \"dn,don\")))]\n-  \"!TARGET_COLDFIRE\"\n-{\n-  CC_STATUS_INIT;\n-  /* We can get CONST_DOUBLE, but also const1_rtx etc.  */\n-  if (CONSTANT_P (operands[2]))\n-    {\n-      rtx hi, lo;\n-\n-      split_double (operands[2], &hi, &lo);\n-\n-      switch (INTVAL (hi))\n-\t{\n-\t  case 0 :\n-\t    output_asm_insn (\"clr%.l %0\", operands);\n-\t    break;\n-\t  case -1 :\n-\t    break;\n-\t  default :\n-\t    {\n-\t    rtx xoperands[3];\n-\n-\t    xoperands[0] = operands[0];\n-\t    xoperands[2] = hi;\n-\t    output_asm_insn (output_andsi3 (xoperands), xoperands);\n-\t    }\n-\t}\n-      if (GET_CODE (operands[0]) == REG)\n-\toperands[0] = gen_rtx_REG (SImode, REGNO (operands[0]) + 1);\n-      else\n-\toperands[0] = adjust_address (operands[0], SImode, 4);\n-      switch (INTVAL (lo))\n-\t{\n-\t  case 0 :\n-\t    output_asm_insn (\"clr%.l %0\", operands);\n-\t    break;\n-\t  case -1 :\n-\t    break;\n-\t  default :\n-\t    {\n-\t    rtx xoperands[3];\n-\n-\t    xoperands[0] = operands[0];\n-\t    xoperands[2] = lo;\n-\t    output_asm_insn (output_andsi3 (xoperands), xoperands);\n-\t    }\n-\t}\n-      return \"\";\n-    }\n-  if (GET_CODE (operands[0]) != REG)\n-    {\n-      operands[1] = adjust_address (operands[0], SImode, 4);\n-      return \"and%.l %2,%0\\;and%.l %R2,%1\";\n-    }\n-  if (GET_CODE (operands[2]) != REG)\n-    {\n-      operands[1] = adjust_address (operands[2], SImode, 4);\n-      return \"and%.l %2,%0\\;and%.l %1,%R0\";\n-    }\n-  return \"and%.l %2,%0\\;and%.l %R2,%R0\";\n-})\n-\n ;; Prevent AND from being made with sp.  This doesn't exist in the machine\n ;; and reload will cause inefficient code.  Since sp is a FIXED_REG, we\n ;; can't allocate pseudos into it.\n@@ -3780,76 +3714,6 @@\n     return \"or%.w %1,%0\";\n })\n \n-;; \"iordi3\" is mainly here to help combine().\n-(define_insn \"iordi3\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=o,d\")\n-\t(ior:DI (match_operand:DI 1 \"general_operand\" \"%0,0\")\n-\t\t(match_operand:DI 2 \"general_operand\" \"dn,don\")))]\n-  \"!TARGET_COLDFIRE\"\n-{\n-  CC_STATUS_INIT;\n-  /* We can get CONST_DOUBLE, but also const1_rtx etc.  */\n-  if (CONSTANT_P (operands[2]))\n-    {\n-      rtx hi, lo;\n-\n-      split_double (operands[2], &hi, &lo);\n-\n-      switch (INTVAL (hi))\n-\t{\n-\t  case 0 :\n-\t    break;\n-\t  case -1 :\n-\t    /* FIXME : a scratch register would be welcome here if operand[0]\n-\t       is not a register */\n-\t    output_asm_insn (\"move%.l #-1,%0\", operands);\n-\t    break;\n-\t  default :\n-\t    {\n-\t    rtx xoperands[3];\n-\n-\t    xoperands[0] = operands[0];\n-\t    xoperands[2] = hi;\n-\t    output_asm_insn (output_iorsi3 (xoperands), xoperands);\n-\t    }\n-\t}\n-      if (GET_CODE (operands[0]) == REG)\n-\toperands[0] = gen_rtx_REG (SImode, REGNO (operands[0]) + 1);\n-      else\n-\toperands[0] = adjust_address (operands[0], SImode, 4);\n-      switch (INTVAL (lo))\n-\t{\n-\t  case 0 :\n-\t    break;\n-\t  case -1 :\n-\t    /* FIXME : a scratch register would be welcome here if operand[0]\n-\t       is not a register */\n-\t    output_asm_insn (\"move%.l #-1,%0\", operands);\n-\t    break;\n-\t  default :\n-\t    {\n-\t    rtx xoperands[3];\n-\n-\t    xoperands[0] = operands[0];\n-\t    xoperands[2] = lo;\n-\t    output_asm_insn (output_iorsi3 (xoperands), xoperands);\n-\t    }\n-\t}\n-      return \"\";\n-    }\n-  if (GET_CODE (operands[0]) != REG)\n-    {\n-      operands[1] = adjust_address (operands[0], SImode, 4);\n-      return \"or%.l %2,%0\\;or%.l %R2,%1\";\n-    }\n-  if (GET_CODE (operands[2]) != REG)\n-    {\n-      operands[1] = adjust_address (operands[2], SImode, 4);\n-      return \"or%.l %2,%0\\;or%.l %1,%R0\";\n-    }\n-  return \"or%.l %2,%0\\;or%.l %R2,%R0\";\n-})\n-\n (define_expand \"iorsi3\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"\")\n \t(ior:SI (match_operand:SI 1 \"general_operand\" \"\")\n@@ -3957,79 +3821,6 @@\n \f\n ;; xor instructions\n \n-;; \"xordi3\" is mainly here to help combine().\n-(define_insn \"xordi3\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=od\")\n-\t(xor:DI (match_operand:DI 1 \"general_operand\" \"%0\")\n-\t\t(match_operand:DI 2 \"general_operand\" \"dn\")))]\n-  \"!TARGET_COLDFIRE\"\n-{\n-  CC_STATUS_INIT;\n-  /* We can get CONST_DOUBLE, but also const1_rtx etc.  */\n-\n-  if (CONSTANT_P (operands[2]))\n-    {\n-      rtx hi, lo;\n-\n-      split_double (operands[2], &hi, &lo);\n-\n-      switch (INTVAL (hi))\n-\t{\n-\t  case 0 :\n-\t    break;\n-\t  case -1 :\n-\t    output_asm_insn (\"not%.l %0\", operands);\n-\t    break;\n-\t  default :\n-\t    /* FIXME : a scratch register would be welcome here if\n-\t       -128 <= INTVAL (hi) < -1 */\n-\t    {\n-\t    rtx xoperands[3];\n-\n-\t    xoperands[0] = operands[0];\n-\t    xoperands[2] = hi;\n-\t    output_asm_insn (output_xorsi3 (xoperands), xoperands);\n-\t    }\n-\t}\n-      if (GET_CODE (operands[0]) == REG)\n-\toperands[0] = gen_rtx_REG (SImode, REGNO (operands[0]) + 1);\n-      else\n-\toperands[0] = adjust_address (operands[0], SImode, 4);\n-      switch (INTVAL (lo))\n-\t{\n-\t  case 0 :\n-\t    break;\n-\t  case -1 :\n-\t    output_asm_insn (\"not%.l %0\", operands);\n-\t    break;\n-\t  default :\n-\t    /* FIXME : a scratch register would be welcome here if\n-\t       -128 <= INTVAL (lo) < -1 */\n-\t    operands[2] = lo;\n-\t    /* FIXME : this should be merged with xorsi3 */\n-\t    {\n-\t    rtx xoperands[3];\n-\n-\t    xoperands[0] = operands[0];\n-\t    xoperands[2] = lo;\n-\t    output_asm_insn (output_xorsi3 (xoperands), xoperands);\n-\t    }\n-\t}\n-      return \"\";\n-    }\n-  if (GET_CODE (operands[0]) != REG)\n-    {\n-      operands[1] = adjust_address (operands[0], SImode, 4);\n-      return \"eor%.l %2,%0\\;eor%.l %R2,%1\";\n-    }\n-  if (GET_CODE (operands[2]) != REG)\n-    {\n-      operands[1] = adjust_address (operands[2], SImode, 4);\n-      return \"eor%.l %2,%0\\;eor%.l %1,%R0\";\n-    }\n-  return \"eor%.l %2,%0\\;eor%.l %R2,%R0\";\n-})\n-\n (define_expand \"xorsi3\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"\")\n \t(xor:SI (match_operand:SI 1 \"general_operand\" \"\")\n@@ -4498,23 +4289,6 @@\n \f\n ;; one complement instructions\n \n-;; \"one_cmpldi2\" is mainly here to help combine().\n-(define_insn \"one_cmpldi2\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=dm\")\n-\t(not:DI (match_operand:DI 1 \"general_operand\" \"0\")))]\n-  \"!TARGET_COLDFIRE\"\n-{\n-  CC_STATUS_INIT;\n-  if (GET_CODE (operands[0]) == REG)\n-    operands[1] = gen_rtx_REG (SImode, REGNO (operands[0]) + 1);\n-  else if (GET_CODE (XEXP (operands[0], 0)) == POST_INC\n-        || GET_CODE (XEXP (operands[0], 0)) == PRE_DEC)\n-    operands[1] = operands[0];\n-  else\n-    operands[1] = adjust_address (operands[0], SImode, 4);\n-  return \"not%.l %1\\;not%.l %0\";\n-})\n-\n (define_expand \"one_cmplsi2\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"\")\n \t(not:SI (match_operand:SI 1 \"general_operand\" \"\")))]"}]}