{"sha": "79edfde8fb072da763bb08da00ed109a23311f17", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzllZGZkZThmYjA3MmRhNzYzYmIwOGRhMDBlZDEwOWEyMzMxMWYxNw==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2006-03-30T17:47:48Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2006-03-30T17:47:48Z"}, "message": "re PR target/17959 (-mpowerpc64 can cause worse code than without it)\n\n\n\tPR target/17959\n\t* expr.c (emit_group_store):  Optimize group stores into a pseudo\n\tregister by using a paradoxical subreg to initialize the destination\n\tif the first or last member of the group specifies a \"low part\".\n\nFrom-SVN: r112543", "tree": {"sha": "c7abad810156d7ebdc0e5b8f1e87719b1aad993c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c7abad810156d7ebdc0e5b8f1e87719b1aad993c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/79edfde8fb072da763bb08da00ed109a23311f17", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79edfde8fb072da763bb08da00ed109a23311f17", "html_url": "https://github.com/Rust-GCC/gccrs/commit/79edfde8fb072da763bb08da00ed109a23311f17", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79edfde8fb072da763bb08da00ed109a23311f17/comments", "author": null, "committer": null, "parents": [{"sha": "105aa1532e59cf62d7bbfedbcbc414d9a51a02ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/105aa1532e59cf62d7bbfedbcbc414d9a51a02ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/105aa1532e59cf62d7bbfedbcbc414d9a51a02ca"}], "stats": {"total": 62, "additions": 56, "deletions": 6}, "files": [{"sha": "d7410deb62805935b02016effb3e960ff5dcd109", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79edfde8fb072da763bb08da00ed109a23311f17/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79edfde8fb072da763bb08da00ed109a23311f17/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=79edfde8fb072da763bb08da00ed109a23311f17", "patch": "@@ -1,3 +1,10 @@\n+2006-03-30  Roger Sayle  <roger@eyesopen.com>\n+\n+\tPR target/17959\n+\t* expr.c (emit_group_store):  Optimize group stores into a pseudo\n+\tregister by using a paradoxical subreg to initialize the destination\n+\tif the first or last member of the group specifies a \"low part\".\n+\n 2006-03-30  Maxim Kuvyrkov  <mkuvyrkov@ispras.ru>\n \n \tPR target/26734"}, {"sha": "059f082051104b906475ae9f44514732955ca869", "filename": "gcc/expr.c", "status": "modified", "additions": 49, "deletions": 6, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79edfde8fb072da763bb08da00ed109a23311f17/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79edfde8fb072da763bb08da00ed109a23311f17/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=79edfde8fb072da763bb08da00ed109a23311f17", "patch": "@@ -1857,7 +1857,7 @@ void\n emit_group_store (rtx orig_dst, rtx src, tree type ATTRIBUTE_UNUSED, int ssize)\n {\n   rtx *tmps, dst;\n-  int start, i;\n+  int start, finish, i;\n   enum machine_mode m = GET_MODE (orig_dst);\n \n   gcc_assert (GET_CODE (src) == PARALLEL);\n@@ -1883,11 +1883,12 @@ emit_group_store (rtx orig_dst, rtx src, tree type ATTRIBUTE_UNUSED, int ssize)\n     start = 0;\n   else\n     start = 1;\n+  finish = XVECLEN (src, 0);\n \n-  tmps = alloca (sizeof (rtx) * XVECLEN (src, 0));\n+  tmps = alloca (sizeof (rtx) * finish);\n \n   /* Copy the (probable) hard regs into pseudos.  */\n-  for (i = start; i < XVECLEN (src, 0); i++)\n+  for (i = start; i < finish; i++)\n     {\n       rtx reg = XEXP (XVECEXP (src, 0, i), 0);\n       if (!REG_P (reg) || REGNO (reg) < FIRST_PSEUDO_REGISTER)\n@@ -1923,14 +1924,56 @@ emit_group_store (rtx orig_dst, rtx src, tree type ATTRIBUTE_UNUSED, int ssize)\n     }\n   else if (!MEM_P (dst) && GET_CODE (dst) != CONCAT)\n     {\n+      enum machine_mode outer = GET_MODE (dst);\n+      enum machine_mode inner;\n+      unsigned int bytepos;\n+      bool done = false;\n+      rtx temp;\n+\n       if (!REG_P (dst) || REGNO (dst) < FIRST_PSEUDO_REGISTER)\n-\tdst = gen_reg_rtx (GET_MODE (orig_dst));\n+\tdst = gen_reg_rtx (outer);\n+\n       /* Make life a bit easier for combine.  */\n-      emit_move_insn (dst, CONST0_RTX (GET_MODE (orig_dst)));\n+      /* If the first element of the vector is the low part\n+\t of the destination mode, use a paradoxical subreg to\n+\t initialize the destination.  */\n+      if (start < finish)\n+\t{\n+\t  inner = GET_MODE (tmps[start]);\n+\t  bytepos = subreg_lowpart_offset (outer, inner);\n+\t  if (INTVAL (XEXP (XVECEXP (src, 0, start), 1)) == bytepos)\n+\t    {\n+\t      temp = simplify_gen_subreg (outer, tmps[start],\n+\t\t\t\t\t  inner, bytepos);\n+\t      emit_move_insn (dst, temp);\n+\t      done = true;\n+\t      start++;\n+\t    }\n+\t}\n+\n+      /* If the first element wasn't the low part, try the last.  */\n+      if (!done\n+\t  && start < finish - 1)\n+\t{\n+\t  inner = GET_MODE (tmps[finish - 1]);\n+\t  bytepos = subreg_lowpart_offset (outer, inner);\n+\t  if (INTVAL (XEXP (XVECEXP (src, 0, finish - 1), 1)) == bytepos)\n+\t    {\n+\t      temp = simplify_gen_subreg (outer, tmps[finish - 1],\n+\t\t\t\t\t  inner, bytepos);\n+\t      emit_move_insn (dst, temp);\n+\t      done = true;\n+\t      finish--;\n+\t    }\n+\t}\n+\n+      /* Otherwise, simply initialize the result to zero.  */\n+      if (!done)\n+        emit_move_insn (dst, CONST0_RTX (outer));\n     }\n \n   /* Process the pieces.  */\n-  for (i = start; i < XVECLEN (src, 0); i++)\n+  for (i = start; i < finish; i++)\n     {\n       HOST_WIDE_INT bytepos = INTVAL (XEXP (XVECEXP (src, 0, i), 1));\n       enum machine_mode mode = GET_MODE (tmps[i]);"}]}