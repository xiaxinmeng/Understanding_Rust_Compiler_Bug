{"sha": "19fb0b860f5b70c3fa0bbf7ef02afd7b95634231", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTlmYjBiODYwZjViNzBjM2ZhMGJiZjdlZjAyYWZkN2I5NTYzNDIzMQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2010-05-14T18:34:30Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2010-05-14T18:34:30Z"}, "message": "ipa.c (enqueue_cgraph_node): Update comment; do not re-enqueue nodes already in queue.\n\n\n\t* ipa.c (enqueue_cgraph_node): Update comment; do not re-enqueue\n\tnodes already in queue.\n\t(cgraph_remove_unreachable_nodes): Cleanup; fix problem with re-enqueueing\n\tnode.\n\nFrom-SVN: r159405", "tree": {"sha": "17573cbba782a42cbd92a71076e8a1451c89d45a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/17573cbba782a42cbd92a71076e8a1451c89d45a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/19fb0b860f5b70c3fa0bbf7ef02afd7b95634231", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19fb0b860f5b70c3fa0bbf7ef02afd7b95634231", "html_url": "https://github.com/Rust-GCC/gccrs/commit/19fb0b860f5b70c3fa0bbf7ef02afd7b95634231", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19fb0b860f5b70c3fa0bbf7ef02afd7b95634231/comments", "author": null, "committer": null, "parents": [{"sha": "88c04a5de2b5f1256f8bde89bc33c8f67c64383d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88c04a5de2b5f1256f8bde89bc33c8f67c64383d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/88c04a5de2b5f1256f8bde89bc33c8f67c64383d"}], "stats": {"total": 87, "additions": 62, "deletions": 25}, "files": [{"sha": "e803c134535457d03e2a7d25737430efa2b74a01", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19fb0b860f5b70c3fa0bbf7ef02afd7b95634231/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19fb0b860f5b70c3fa0bbf7ef02afd7b95634231/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=19fb0b860f5b70c3fa0bbf7ef02afd7b95634231", "patch": "@@ -1,3 +1,10 @@\n+2010-05-14  Jan Hubicka  <jh@suse.cz>\n+\n+\t* ipa.c (enqueue_cgraph_node): Update comment; do not re-enqueue\n+\tnodes already in queue.\n+\t(cgraph_remove_unreachable_nodes): Cleanup; fix problem with re-enqueueing\n+\tnode.\n+\n 2010-05-14  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR debug/44136"}, {"sha": "1a1aad74928c17fc813ac518bece0d3dc4b9a7c4", "filename": "gcc/ipa.c", "status": "modified", "additions": 55, "deletions": 25, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19fb0b860f5b70c3fa0bbf7ef02afd7b95634231/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19fb0b860f5b70c3fa0bbf7ef02afd7b95634231/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=19fb0b860f5b70c3fa0bbf7ef02afd7b95634231", "patch": "@@ -118,11 +118,24 @@ update_inlined_to_pointer (struct cgraph_node *node, struct cgraph_node *inlined\n       }\n }\n \n-/* Add cgraph NODE to queue starting at FIRST.  */\n+/* Add cgraph NODE to queue starting at FIRST.\n+\n+   The queue is linked via AUX pointers and terminated by pointer to 1.\n+   We enqueue nodes at two occasions: when we find them reachable or when we find\n+   their bodies needed for further clonning.  In the second case we mark them\n+   by pointer to 2 after processing so they are re-queue when they become\n+   reachable.  */\n \n static void\n enqueue_cgraph_node (struct cgraph_node *node, struct cgraph_node **first)\n {\n+  /* Node is still in queue; do nothing.  */\n+  if (node->aux && node->aux != (void *) 2)\n+    return;\n+  /* Node was already processed as unreachable, re-enqueue\n+     only if it became reachable now.  */\n+  if (node->aux == (void *)2 && !node->reachable)\n+    return;\n   node->aux = *first;\n   *first = node;\n }\n@@ -191,7 +204,6 @@ cgraph_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n {\n   struct cgraph_node *first = (struct cgraph_node *) (void *) 1;\n   struct varpool_node *first_varpool = (struct varpool_node *) (void *) 1;\n-  struct cgraph_node *processed = (struct cgraph_node *) (void *) 2;\n   struct cgraph_node *node, *next;\n   struct varpool_node *vnode, *vnext;\n   bool changed = false;\n@@ -204,6 +216,8 @@ cgraph_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n #ifdef ENABLE_CHECKING\n   for (node = cgraph_nodes; node; node = node->next)\n     gcc_assert (!node->aux);\n+  for (vnode = varpool_nodes; vnode; vnode = vnode->next)\n+    gcc_assert (!vnode->aux);\n #endif\n   varpool_reset_queue ();\n   for (node = cgraph_nodes; node; node = node->next)\n@@ -236,7 +250,11 @@ cgraph_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \n   /* Perform reachability analysis.  As a special case do not consider\n      extern inline functions not inlined as live because we won't output\n-     them at all.  */\n+     them at all. \n+\n+     We maintain two worklist, one for cgraph nodes other for varpools and\n+     are finished once both are empty.  */\n+\n   while (first != (struct cgraph_node *) (void *) 1\n   \t || first_varpool != (struct varpool_node *) (void *) 1)\n     {\n@@ -245,8 +263,12 @@ cgraph_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \t  struct cgraph_edge *e;\n \t  node = first;\n \t  first = (struct cgraph_node *) first->aux;\n-\t  node->aux = processed;\n+\t  if (!node->reachable)\n+\t    node->aux = (void *)2;\n \n+\t  /* If we found this node reachable, first mark on the callees\n+\t     reachable too, unless they are direct calls to extern inline functions\n+\t     we decided to not inline.  */\n \t  if (node->reachable)\n \t    for (e = node->callees; e; e = e->next_callee)\n \t      if (!e->callee->reachable\n@@ -255,15 +277,8 @@ cgraph_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \t\t      || (!DECL_EXTERNAL (e->callee->decl))\n \t\t      || before_inlining_p))\n \t\t{\n-\t\t  bool prev_reachable = e->callee->reachable;\n-\t\t  e->callee->reachable |= node->reachable;\n-\t\t  if (!e->callee->aux\n-\t\t      || (e->callee->aux == processed\n-\t\t\t  && prev_reachable != e->callee->reachable))\n-\t\t    {\n-\t\t      e->callee->aux = first;\n-\t\t      first = e->callee;\n-\t\t    }\n+\t\t  e->callee->reachable = true;\n+\t\t  enqueue_cgraph_node (e->callee, &first);\n \t\t}\n \n \t  /* If any function in a comdat group is reachable, force\n@@ -278,9 +293,8 @@ cgraph_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \t\t   next = next->same_comdat_group)\n \t\tif (!next->reachable)\n \t\t  {\n-\t\t    next->aux = first;\n-\t\t    first = next;\n \t\t    next->reachable = true;\n+\t\t    enqueue_cgraph_node (next, &first);\n \t\t  }\n \t    }\n \n@@ -292,7 +306,7 @@ cgraph_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \t    {\n \t      bool noninline = node->clone_of->decl != node->decl;\n \t      node = node->clone_of;\n-\t      if (noninline)\n+\t      if (noninline && !node->reachable && !node->aux)\n \t      \t{\n \t\t  enqueue_cgraph_node (node, &first);\n \t\t  break;\n@@ -306,17 +320,33 @@ cgraph_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \t  first_varpool = (struct varpool_node *)first_varpool->aux;\n \t  vnode->aux = NULL;\n \t  process_references (&vnode->ref_list, &first, &first_varpool, before_inlining_p);\n+\t  /* If any function in a comdat group is reachable, force\n+\t     all other functions in the same comdat group to be\n+\t     also reachable.  */\n+\t  if (vnode->same_comdat_group)\n+\t    {\n+\t      struct varpool_node *next;\n+\t      for (next = vnode->same_comdat_group;\n+\t\t   next != vnode;\n+\t\t   next = next->same_comdat_group)\n+\t\tif (!next->needed)\n+\t\t  {\n+\t\t    varpool_mark_needed_node (next);\n+\t\t    enqueue_varpool_node (next, &first_varpool);\n+\t\t  }\n+\t    }\n \t}\n     }\n \n-  /* Remove unreachable nodes.  Extern inline functions need special care;\n-     Unreachable extern inline functions shall be removed.\n-     Reachable extern inline functions we never inlined shall get their bodies\n-     eliminated.\n-     Reachable extern inline functions we sometimes inlined will be turned into\n-     unanalyzed nodes so they look like for true extern functions to the rest\n-     of code.  Body of such functions is released via remove_node once the\n-     inline clones are eliminated.  */\n+  /* Remove unreachable nodes. \n+\n+     Completely unreachable functions can be fully removed from the callgraph.\n+     Extern inline functions that we decided to not inline need to become unanalyzed nodes of\n+     callgraph (so we still have edges to them).  We remove function body then.\n+\n+     Also we need to care functions that are unreachable but we need to keep them around\n+     for later clonning.  In this case we also turn them to unanalyzed nodes, but\n+     keep the body around.  */\n   for (node = cgraph_nodes; node; node = next)\n     {\n       next = node->next;\n@@ -339,7 +369,7 @@ cgraph_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \n \t      /* See if there is reachable caller.  */\n \t      for (e = node->callers; e; e = e->next_caller)\n-\t\tif (e->caller->aux)\n+\t\tif (e->caller->reachable)\n \t\t  break;\n \n \t      /* If so, we need to keep node in the callgraph.  */"}]}