{"sha": "f207eed69e2421695e240aaf47bf881c09cbdd8a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjIwN2VlZDY5ZTI0MjE2OTVlMjQwYWFmNDdiZjg4MWMwOWNiZGQ4YQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2021-02-24T20:32:23Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2021-02-24T20:46:09Z"}, "message": "c++: Macro location fixes [PR 98718]\n\nThis fixes some issues with macro maps.  We were incorrectly\ncalculating the number of macro expansions in a location span, and I\nhad a workaround that partially covered that up.  Further, while macro\nlocation spans are monotonic, that is not true of ordinary location\nspans.  Thus we need to insert an indirection array when binary\nsearching the latter. (We load ordinary locations before loading\nimports, but macro locations afterwards.  We make sure an import\nlocation is de-macrofied, if needed.)\n\n\tPR c++/98718\n\tgcc/cp/\n\t* module.cc (ool): New indirection vector.\n\t(loc_spans::maybe_propagate): Location is not optional.\n\t(loc_spans::open): Likewise.  Assert monotonically advancing.\n\t(module_for_ordinary_loc): Use ool indirection vector.\n\t(module_state::write_prepare_maps): Do not count empty macro\n\texpansions.  Elide empty spans.\n\t(module_state::write_macro_maps): Skip empty expansions.\n\t(ool_cmp): New qsort comparator.\n\t(module_state::write): Create and destroy ool vector.\n\t(name_pending_imports): Fix dump push/pop.\n\t(preprocess_module): Likewise.  Add more dumping.\n\t(preprocessed_module): Likewise.\n\tlibcpp/\n\t* include/line-map.h\n\t* line-map.c\n\tgcc/testsuite/\n\t* g++.dg/modules/pr98718_a.C: New.\n\t* g++.dg/modules/pr98718_b.C: New.", "tree": {"sha": "2b48019c2e9e59515ebf7d7cd665a9821083de9d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2b48019c2e9e59515ebf7d7cd665a9821083de9d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f207eed69e2421695e240aaf47bf881c09cbdd8a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f207eed69e2421695e240aaf47bf881c09cbdd8a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f207eed69e2421695e240aaf47bf881c09cbdd8a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f207eed69e2421695e240aaf47bf881c09cbdd8a/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9a4eb720b343324f7f8fd2dceed5d0347e5a0153", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a4eb720b343324f7f8fd2dceed5d0347e5a0153", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a4eb720b343324f7f8fd2dceed5d0347e5a0153"}], "stats": {"total": 256, "additions": 180, "deletions": 76}, "files": [{"sha": "e576face0d84ec76178060c2f9aa7e1751ba1da4", "filename": "gcc/cp/module.cc", "status": "modified", "additions": 118, "deletions": 58, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f207eed69e2421695e240aaf47bf881c09cbdd8a/gcc%2Fcp%2Fmodule.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f207eed69e2421695e240aaf47bf881c09cbdd8a/gcc%2Fcp%2Fmodule.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmodule.cc?ref=f207eed69e2421695e240aaf47bf881c09cbdd8a", "patch": "@@ -3363,6 +3363,8 @@ class loc_spans {\n };\n \n static loc_spans spans;\n+/* Indirection to allow bsearching imports by ordinary location.  */\n+static vec<module_state *> *ool;\n \n /********************************************************************/\n /* Data needed by a module during the process of loading.  */\n@@ -13758,25 +13760,21 @@ loc_spans::init (const line_maps *lmaps, const line_map_ordinary *map)\n    interface and we're importing a partition.  */\n \n bool\n-loc_spans::maybe_propagate (module_state *import,\n-\t\t\t    location_t loc = UNKNOWN_LOCATION)\n+loc_spans::maybe_propagate (module_state *import, location_t hwm)\n {\n   bool opened = (module_interface_p () && !module_partition_p ()\n \t\t && import->is_partition ());\n   if (opened)\n-    open (loc);\n+    open (hwm);\n   return opened;\n }\n \n /* Open a new linemap interval.  The just-created ordinary map is the\n    first map of the interval.  */\n \n void\n-loc_spans::open (location_t hwm = UNKNOWN_LOCATION)\n+loc_spans::open (location_t hwm)\n {\n-  if (hwm == UNKNOWN_LOCATION)\n-    hwm = MAP_START_LOCATION (LINEMAPS_LAST_ORDINARY_MAP (line_table));\n-\n   span interval;\n   interval.ordinary.first = interval.ordinary.second = hwm;\n   interval.macro.first = interval.macro.second\n@@ -13786,6 +13784,13 @@ loc_spans::open (location_t hwm = UNKNOWN_LOCATION)\n     && dump (\"Opening span %u ordinary:[%u,... macro:...,%u)\",\n \t     spans->length (), interval.ordinary.first,\n \t     interval.macro.second);\n+  if (spans->length ())\n+    {\n+      /* No overlapping!  */\n+      auto &last = spans->last ();\n+      gcc_checking_assert (interval.ordinary.first >= last.ordinary.second);\n+      gcc_checking_assert (interval.macro.second <= last.macro.first);\n+    }\n   spans->safe_push (interval);\n }\n \n@@ -15547,13 +15552,13 @@ enum loc_kind {\n static const module_state *\n module_for_ordinary_loc (location_t loc)\n {\n-  unsigned pos = 1;\n-  unsigned len = modules->length () - pos;\n+  unsigned pos = 0;\n+  unsigned len = ool->length () - pos;\n \n   while (len)\n     {\n       unsigned half = len / 2;\n-      module_state *probe = (*modules)[pos + half];\n+      module_state *probe = (*ool)[pos + half];\n       if (loc < probe->ordinary_locs.first)\n \tlen = half;\n       else if (loc < probe->ordinary_locs.second)\n@@ -15565,7 +15570,7 @@ module_for_ordinary_loc (location_t loc)\n \t}\n     }\n \n-  return NULL;\n+  return nullptr;\n }\n \n static const module_state *\n@@ -15849,31 +15854,49 @@ module_state::write_prepare_maps (module_state_config *)\n   for (unsigned ix = loc_spans::SPAN_FIRST; ix != spans.length (); ix++)\n     {\n       loc_spans::span &span = spans[ix];\n-      line_map_ordinary const *omap\n-\t= linemap_check_ordinary (linemap_lookup (line_table,\n-\t\t\t\t\t\t  span.ordinary.first));\n-\n-      /* We should exactly match up.  */\n-      gcc_checking_assert (MAP_START_LOCATION (omap) == span.ordinary.first);\n \n-      line_map_ordinary const *fmap = omap;\n-      for (; MAP_START_LOCATION (omap) < span.ordinary.second; omap++)\n+      if (span.ordinary.first != span.ordinary.second)\n \t{\n-\t  /* We should never find a module linemap in an interval.  */\n-\t  gcc_checking_assert (!MAP_MODULE_P (omap));\n+\t  line_map_ordinary const *omap\n+\t    = linemap_check_ordinary (linemap_lookup (line_table,\n+\t\t\t\t\t\t      span.ordinary.first));\n \n-\t  if (max_range < omap->m_range_bits)\n-\t    max_range = omap->m_range_bits;\n-\t}\n+\t  /* We should exactly match up.  */\n+\t  gcc_checking_assert (MAP_START_LOCATION (omap) == span.ordinary.first);\n \n-      unsigned count = omap - fmap;\n-      info.num_maps.first += count;\n+\t  line_map_ordinary const *fmap = omap;\n+\t  for (; MAP_START_LOCATION (omap) < span.ordinary.second; omap++)\n+\t    {\n+\t      /* We should never find a module linemap in an interval.  */\n+\t      gcc_checking_assert (!MAP_MODULE_P (omap));\n+\n+\t      if (max_range < omap->m_range_bits)\n+\t\tmax_range = omap->m_range_bits;\n+\t    }\n+\n+\t  info.num_maps.first += omap - fmap;\n+\t}\n \n       if (span.macro.first != span.macro.second)\n \t{\n-\t  count = linemap_lookup_macro_index (line_table, span.macro.first) + 1;\n-\t  count -= linemap_lookup_macro_index (line_table,\n+\t  /* Iterate over the span's macros, to elide the empty\n+\t     expansions.  */\n+\t  unsigned count = 0;\n+\t  for (unsigned macro\n+\t\t = linemap_lookup_macro_index (line_table,\n \t\t\t\t\t       span.macro.second - 1);\n+\t       macro < LINEMAPS_MACRO_USED (line_table);\n+\t       macro++)\n+\t    {\n+\t      line_map_macro const *mmap\n+\t\t= LINEMAPS_MACRO_MAP_AT (line_table, macro);\n+\t      if (MAP_START_LOCATION (mmap) < span.macro.first)\n+\t\t/* Fallen out of the span.  */\n+\t\tbreak;\n+\n+\t      if (mmap->n_tokens)\n+\t\tcount++;\n+\t    }\n \t  dump (dumper::LOCATION) && dump (\"Span:%u %u macro maps\", ix, count);\n \t  info.num_maps.second += count;\n \t}\n@@ -15901,7 +15924,7 @@ module_state::write_prepare_maps (module_state_config *)\n \n       line_map_ordinary const *omap\n \t= linemap_check_ordinary (linemap_lookup (line_table,\n-\t\t\t\t\t\t  span.ordinary.first));\n+\t\t\t\t\t\t      span.ordinary.first));\n       location_t base = MAP_START_LOCATION (omap);\n \n       /* Preserve the low MAX_RANGE bits of base by incrementing ORD_OFF.  */\n@@ -15916,24 +15939,28 @@ module_state::write_prepare_maps (module_state_config *)\n \t  location_t start_loc = MAP_START_LOCATION (omap);\n \t  unsigned to = start_loc + span.ordinary_delta;\n \t  location_t end_loc = MAP_START_LOCATION (omap + 1);\n-\t  \n-\t  dump () && dump (\"Ordinary span:%u [%u,%u):%u->%d(%u)\", ix, start_loc,\n+\n+\t  dump () && dump (\"Ordinary span:%u [%u,%u):%u->%d(%u)\",\n+\t\t\t   ix, start_loc,\n \t\t\t   end_loc, end_loc - start_loc,\n \t\t\t   span.ordinary_delta, to);\n \n \t  /* There should be no change in the low order bits.  */\n \t  gcc_checking_assert (((start_loc ^ to) & range_mask) == 0);\n \t}\n+\n       /* The ending serialized value.  */\n       ord_off = span.ordinary.second + span.ordinary_delta;\n     }\n \n-  dump () && dump (\"Ordinary hwm:%u macro lwm:%u\", ord_off, mac_off);\n+  dump () && dump (\"Ordinary:%u maps hwm:%u macro:%u maps lwm:%u \",\n+\t\t   info.num_maps.first, ord_off,\n+\t\t   info.num_maps.second, mac_off);\n \n   dump.outdent ();\n \n   info.max_range = max_range;\n-\n+  \n   return info;\n }\n \n@@ -16001,14 +16028,15 @@ module_state::write_ordinary_maps (elf_out *to, location_map_info &info,\n \t  /* We should never find a module linemap in an interval.  */\n \t  gcc_checking_assert (!MAP_MODULE_P (omap));\n \n-\t  /* We expect very few filenames, so just an array.  */\n+\t  /* We expect very few filenames, so just an array.\n+\t     (Not true when headers are still in play :()  */\n \t  for (unsigned jx = filenames.length (); jx--;)\n \t    {\n \t      const char *name = filenames[jx];\n \t      if (0 == strcmp (name, fname))\n \t\t{\n \t\t  /* Reset the linemap's name, because for things like\n-\t\t     preprocessed input we could have multple\n+\t\t     preprocessed input we could have multiple\n \t\t     instances of the same name, and we'd rather not\n \t\t     percolate that.  */\n \t\t  const_cast<line_map_ordinary *> (omap)->to_file = name;\n@@ -16133,27 +16161,24 @@ module_state::write_macro_maps (elf_out *to, location_map_info &info,\n     {\n       loc_spans::span &span = spans[ix];\n       if (span.macro.first == span.macro.second)\n+\t/* Empty span.  */\n \tcontinue;\n \n-      for (unsigned first\n+      for (unsigned macro\n \t     = linemap_lookup_macro_index (line_table, span.macro.second - 1);\n-\t   first < LINEMAPS_MACRO_USED (line_table);\n-\t   first++)\n+\t   macro < LINEMAPS_MACRO_USED (line_table);\n+\t   macro++)\n \t{\n \t  line_map_macro const *mmap\n-\t    = LINEMAPS_MACRO_MAP_AT (line_table, first);\n+\t    = LINEMAPS_MACRO_MAP_AT (line_table, macro);\n \t  location_t start_loc = MAP_START_LOCATION (mmap);\n \t  if (start_loc < span.macro.first)\n+\t    /* Fallen out of the span.  */\n \t    break;\n-\t  if (macro_num == info.num_maps.second)\n-\t    {\n-\t      /* We're ending on an empty macro expansion.  The\n-\t\t preprocessor doesn't prune such things.  */\n-\t      // FIXME:QOI This is an example of the non-pruning of\n-\t      // locations.  See write_prepare_maps.\n-\t      gcc_checking_assert (!mmap->n_tokens);\n-\t      continue;\n-\t    }\n+\n+\t  if (!mmap->n_tokens)\n+\t    /* Empty expansion.  */\n+\t    continue;\n \n \t  sec.u (offset);\n \t  sec.u (mmap->n_tokens);\n@@ -16318,7 +16343,8 @@ module_state::read_macro_maps ()\n   location_t zero = sec.u ();\n   dump () && dump (\"Macro maps:%u zero:%u\", num_macros, zero);\n \n-  bool propagated = spans.maybe_propagate (this);\n+  bool propagated = spans.maybe_propagate (this,\n+\t\t\t\t\t   line_table->highest_location + 1);\n \n   location_t offset = LINEMAPS_MACRO_LOWEST_LOCATION (line_table);\n   slurp->loc_deltas.second = zero - offset;\n@@ -17519,6 +17545,21 @@ module_state::read_config (module_state_config &config)\n   return cfg.end (from ());\n }\n \n+/* Comparator for ordering the Ordered Ordinary Location array.  */\n+\n+static int\n+ool_cmp (const void *a_, const void *b_)\n+{\n+  auto *a = *static_cast<const module_state *const *> (a_);\n+  auto *b = *static_cast<const module_state *const *> (b_);\n+  if (a == b)\n+    return 0;\n+  else if (a->ordinary_locs.first < b->ordinary_locs.second)\n+    return -1;\n+  else\n+    return +1;\n+}\n+\n /* Use ELROND format to record the following sections:\n      qualified-names\t    : binding value(s)\n      MOD_SNAME_PFX.README   : human readable, strings\n@@ -17625,6 +17666,16 @@ module_state::write (elf_out *to, cpp_reader *reader)\n   /* Determine Strongy Connected Components.  */\n   vec<depset *> sccs = table.connect ();\n \n+  vec_alloc (ool, modules->length ());\n+  for (unsigned ix = modules->length (); --ix;)\n+    {\n+      auto *import = (*modules)[ix];\n+      if (import->loadedness > ML_NONE\n+\t  && !(partitions && bitmap_bit_p (partitions, import->mod)))\n+\tool->quick_push (import);\n+    }\n+  ool->qsort (ool_cmp);\n+\n   unsigned crc = 0;\n   module_state_config config;\n   location_map_info map_info = write_prepare_maps (&config);\n@@ -17788,6 +17839,8 @@ module_state::write (elf_out *to, cpp_reader *reader)\n   spaces.release ();\n   sccs.release ();\n \n+  vec_free (ool);\n+\n   /* Human-readable info.  */\n   write_readme (to, reader, config.dialect_str, extensions);\n \n@@ -19299,7 +19352,7 @@ name_pending_imports (cpp_reader *reader, bool at_end)\n \n   timevar_start (TV_MODULE_MAPPER);\n \n-  dump.push (NULL);\n+  auto n = dump.push (NULL);\n   dump () && dump (\"Resolving direct import names\");\n \n   mapper->Cork ();\n@@ -19338,7 +19391,7 @@ name_pending_imports (cpp_reader *reader, bool at_end)\n \t}\n     }\n \n-  dump.pop (0);\n+  dump.pop (n);\n \n   timevar_stop (TV_MODULE_MAPPER);\n }\n@@ -19404,12 +19457,14 @@ preprocess_module (module_state *module, location_t from_loc,\n \n       if (desired == ML_PREPROCESSOR)\n \t{\n-\t  name_pending_imports (reader, false);\n+\t  unsigned n = dump.push (NULL);\n \n-\t  unsigned pre_hwm = 0;\n+\t  dump () && dump (\"Reading %s preprocessor state\", module);\n+\t  name_pending_imports (reader, false);\n \n \t  /* Preserve the state of the line-map.  */\n-\t  pre_hwm = LINEMAPS_ORDINARY_USED (line_table);\n+\t  unsigned pre_hwm = LINEMAPS_ORDINARY_USED (line_table);\n+\n \t  /* We only need to close the span, if we're going to emit a\n \t     CMI.  But that's a little tricky -- our token scanner\n \t     needs to be smarter -- and this isn't much state.\n@@ -19438,18 +19493,17 @@ preprocess_module (module_state *module, location_t from_loc,\n \t  vec_free (pending_imports);\n \n \t  /* Restore the line-map state.  */\n-\t  linemap_module_restore (line_table, pre_hwm);\n-\t  spans.open ();\n+\t  spans.open (linemap_module_restore (line_table, pre_hwm));\n \n \t  /* Now read the preprocessor state of this particular\n \t     import.  */\n-\t  unsigned n = dump.push (module);\n \t  if (module->loadedness == ML_CONFIG\n \t      && module->read_preprocessor (true))\n \t    module->import_macros ();\n-\t  dump.pop (n);\n \n \t  timevar_stop (TV_MODULE_IMPORT);\n+\n+\t  dump.pop (n);\n \t}\n     }\n \n@@ -19464,6 +19518,10 @@ preprocess_module (module_state *module, location_t from_loc,\n void\n preprocessed_module (cpp_reader *reader)\n {\n+  unsigned n = dump.push (NULL);\n+\n+  dump () && dump (\"Completed phase-4 (tokenization) processing\");\n+\n   name_pending_imports (reader, true);\n   vec_free (pending_imports);\n \n@@ -19507,6 +19565,8 @@ preprocessed_module (cpp_reader *reader)\n \t    }\n \t}\n     }\n+\n+  dump.pop (n);\n }\n \n /* VAL is a global tree, add it to the global vec if it is"}, {"sha": "0be5f905ee4b7c327292dba79e115c853b709624", "filename": "gcc/testsuite/g++.dg/modules/pr98718_a.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f207eed69e2421695e240aaf47bf881c09cbdd8a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr98718_a.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f207eed69e2421695e240aaf47bf881c09cbdd8a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr98718_a.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr98718_a.C?ref=f207eed69e2421695e240aaf47bf881c09cbdd8a", "patch": "@@ -0,0 +1,18 @@\n+// PR 98718 ICE with macro location data\n+// { dg-additional-options {-Wno-pedantic -fpreprocessed -fdirectives-only -fdump-lang-module-lineno -fmodules-ts} }\n+module ;\n+\n+# 4 \"inc_a\" 1\n+#define _GLIBCXX_VISIBILITY(V) __attribute__ ((__visibility__ (#V)))\n+\n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+\n+}\n+# 11 \"\" 2\n+\n+export  module  hello:format;\n+// { dg-module-cmi hello:format }\n+\n+// { dg-final { scan-lang-dump { Ordinary:4 maps hwm:[0-9]* macro:1 maps lwm:214[0-9]*} module } }\n+// { dg-final { scan-lang-dump { Span:2 macro:0 _GLIBCXX_VISIBILITY 10/11\\*2 locations } module } }"}, {"sha": "50679c8d82c876189d019262ab5a4807c6f5e63e", "filename": "gcc/testsuite/g++.dg/modules/pr98718_b.C", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f207eed69e2421695e240aaf47bf881c09cbdd8a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr98718_b.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f207eed69e2421695e240aaf47bf881c09cbdd8a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr98718_b.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr98718_b.C?ref=f207eed69e2421695e240aaf47bf881c09cbdd8a", "patch": "@@ -0,0 +1,20 @@\n+// { dg-additional-options {-Wno-pedantic -fpreprocessed -fdirectives-only -fdump-lang-module-lineno-vops -fmodules-ts} }\n+module ;\n+\n+# 4 \"inc_b\" 1\n+#define _GLIBCXX_VISIBILITY(V) __attribute__ ((__visibility__ (#V)))\n+#define _GLIBCXX_BEGIN_NAMESPACE_VERSION \n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+}\n+# 11 \"\" 2\n+\n+export  module  hello;\n+export  import  :format;\n+// { dg-module-cmi hello }\n+\n+// { dg-final { scan-lang-dump {Macro:0 _GLIBCXX_VISIBILITY 10/11\\*2 locations } module } }\n+// { dg-final { scan-lang-dump { Ordinary:8 maps hwm:[0-9]* macro:2 maps lwm:214[0-9]*} module } }\n+// { dg-final { scan-lang-dump { Span:2 macro:0 _GLIBCXX_VISIBILITY 10/11\\*2 locations } module } }\n+// { dg-final { scan-lang-dump { Span:4 macro:1 _GLIBCXX_VISIBILITY 10/11\\*2 locations } module } }"}, {"sha": "40919d088acb3ad4acc6c8f6d5303b82da8ee1db", "filename": "libcpp/include/line-map.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f207eed69e2421695e240aaf47bf881c09cbdd8a/libcpp%2Finclude%2Fline-map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f207eed69e2421695e240aaf47bf881c09cbdd8a/libcpp%2Finclude%2Fline-map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finclude%2Fline-map.h?ref=f207eed69e2421695e240aaf47bf881c09cbdd8a", "patch": "@@ -1136,8 +1136,9 @@ extern location_t linemap_module_loc\n extern void linemap_module_reparent\n   (line_maps *, location_t loc, location_t new_parent);\n \n-/* Restore the linemap state such that the map at LWM-1 continues.  */\n-extern void linemap_module_restore\n+/* Restore the linemap state such that the map at LWM-1 continues.\n+   Return start location of the new map.  */\n+extern unsigned linemap_module_restore\n   (line_maps *, unsigned lwm);\n \n /* Given a logical source location, returns the map which the"}, {"sha": "ccabd51c62fa336cae5add93344aebb0437d2bf5", "filename": "libcpp/line-map.c", "status": "modified", "additions": 21, "deletions": 16, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f207eed69e2421695e240aaf47bf881c09cbdd8a/libcpp%2Fline-map.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f207eed69e2421695e240aaf47bf881c09cbdd8a/libcpp%2Fline-map.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fline-map.c?ref=f207eed69e2421695e240aaf47bf881c09cbdd8a", "patch": "@@ -621,27 +621,32 @@ linemap_module_reparent (line_maps *set, location_t loc, location_t adoptor)\n }\n \n /* A linemap at LWM-1 was interrupted to insert module locations & imports.\n-   Append a new map, continuing the interrupted one.  */\n+   Append a new map, continuing the interrupted one.  Return the start location\n+   of the new map, or 0 if failed (because we ran out of locations.  */\n \n-void\n+unsigned\n linemap_module_restore (line_maps *set, unsigned lwm)\n {\n-  if (lwm && lwm != LINEMAPS_USED (set, false))\n+  linemap_assert (lwm);\n+\n+  const line_map_ordinary *pre_map\n+    = linemap_check_ordinary (LINEMAPS_MAP_AT (set, false, lwm - 1));\n+  unsigned src_line = SOURCE_LINE (pre_map, LAST_SOURCE_LINE_LOCATION (pre_map));\n+  location_t inc_at = pre_map->included_from;\n+  if (const line_map_ordinary *post_map\n+      = (linemap_check_ordinary\n+\t (linemap_add (set, LC_RENAME_VERBATIM,\n+\t\t       ORDINARY_MAP_IN_SYSTEM_HEADER_P (pre_map),\n+\t\t       ORDINARY_MAP_FILE_NAME (pre_map), src_line))))\n     {\n-      const line_map_ordinary *pre_map\n-\t= linemap_check_ordinary (LINEMAPS_MAP_AT (set, false, lwm - 1));\n-      unsigned src_line = SOURCE_LINE (pre_map,\n-\t\t\t\t       LAST_SOURCE_LINE_LOCATION (pre_map));\n-      location_t inc_at = pre_map->included_from;\n-      if (const line_map_ordinary *post_map\n-\t  = (linemap_check_ordinary\n-\t     (linemap_add (set, LC_RENAME_VERBATIM,\n-\t\t\t   ORDINARY_MAP_IN_SYSTEM_HEADER_P (pre_map),\n-\t\t\t   ORDINARY_MAP_FILE_NAME (pre_map), src_line))))\n-\t/* linemap_add will think we were included from the same as\n-\t   the preceeding map.  */\n-\tconst_cast <line_map_ordinary *> (post_map)->included_from = inc_at;\n+      /* linemap_add will think we were included from the same as the preceeding\n+\t map.  */\n+      const_cast <line_map_ordinary *> (post_map)->included_from = inc_at;\n+\n+      return post_map->start_location;\n     }\n+\n+  return 0;\n }\n \n /* Returns TRUE if the line table set tracks token locations across"}]}