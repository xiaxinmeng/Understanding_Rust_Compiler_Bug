{"sha": "10833849b55401a52f2334eb032a70beb688e9fc", "node_id": "C_kwDOANBUbNoAKDEwODMzODQ5YjU1NDAxYTUyZjIzMzRlYjAzMmE3MGJlYjY4OGU5ZmM", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2021-11-30T09:52:29Z"}, "committer": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2021-11-30T09:52:29Z"}, "message": "vect: Support gather loads with SLP\n\nThis patch adds SLP support for IFN_GATHER_LOAD.  Like the SLP\nsupport for IFN_MASK_LOAD, it works by treating only some of the\narguments as child nodes.  Unlike IFN_MASK_LOAD, it requires the\nother arguments (base, scale, and extension type) to be the same\nfor all calls in the group.  It does not require/expect the loads\nto be in a group (which probably wouldn't make sense for gathers).\n\nI was worried about the possible alias effect of moving gathers\naround to be part of the same SLP group.  The patch therefore\nmakes vect_analyze_data_ref_dependence treat gathers and scatters\nas a top-level concern, punting if the accesses aren't completely\nindependent and if the user hasn't told us that a particular\nVF is safe.  I think in practice we already punted in the same\ncircumstances; the idea is just to make it more explicit.\n\ngcc/\n\tPR tree-optimization/102467\n\t* doc/sourcebuild.texi (vect_gather_load_ifn): Document.\n\t* tree-vect-data-refs.c (vect_analyze_data_ref_dependence):\n\tCommonize safelen handling.  Punt for anything involving\n\tgathers and scatters unless safelen says otherwise.\n\t* tree-vect-slp.c (arg1_map): New variable.\n\t(vect_get_operand_map): Handle IFN_GATHER_LOAD.\n\t(vect_build_slp_tree_1): Likewise.\n\t(vect_build_slp_tree_2): Likewise.\n\t(compatible_calls_p): If vect_get_operand_map returns nonnull,\n\tcheck that any skipped arguments are equal.\n\t(vect_slp_analyze_node_operations_1): Tighten reduction check.\n\t* tree-vect-stmts.c (check_load_store_for_partial_vectors): Take\n\tan ncopies argument.\n\t(vect_get_gather_scatter_ops): Take slp_node and ncopies arguments.\n\tHandle SLP nodes.\n\t(vectorizable_store, vectorizable_load): Adjust accordingly.\n\ngcc/testsuite/\n\t* lib/target-supports.exp\n\t(check_effective_target_vect_gather_load_ifn): New target test.\n\t* gcc.dg/vect/vect-gather-1.c: New test.\n\t* gcc.dg/vect/vect-gather-2.c: Likewise.\n\t* gcc.target/aarch64/sve/gather_load_11.c: Likewise.", "tree": {"sha": "a2556da822f071f9f927e85f9f4ecb668bac4d07", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a2556da822f071f9f927e85f9f4ecb668bac4d07"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/10833849b55401a52f2334eb032a70beb688e9fc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10833849b55401a52f2334eb032a70beb688e9fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10833849b55401a52f2334eb032a70beb688e9fc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10833849b55401a52f2334eb032a70beb688e9fc/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6f798618c070e2ca505e39c3fcc0c3ca478ac81b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f798618c070e2ca505e39c3fcc0c3ca478ac81b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f798618c070e2ca505e39c3fcc0c3ca478ac81b"}], "stats": {"total": 274, "additions": 223, "deletions": 51}, "files": [{"sha": "702cd0c53e41a75e0dc47c5bedf61c270e10339b", "filename": "gcc/doc/sourcebuild.texi", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10833849b55401a52f2334eb032a70beb688e9fc/gcc%2Fdoc%2Fsourcebuild.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10833849b55401a52f2334eb032a70beb688e9fc/gcc%2Fdoc%2Fsourcebuild.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fsourcebuild.texi?ref=10833849b55401a52f2334eb032a70beb688e9fc", "patch": "@@ -1639,6 +1639,10 @@ Target supports vector masked loads.\n @item vect_masked_store\n Target supports vector masked stores.\n \n+@item vect_gather_load_ifn\n+Target supports vector gather loads using internal functions\n+(rather than via built-in functions or emulation).\n+\n @item vect_scatter_store\n Target supports vector scatter stores.\n "}, {"sha": "4cee73fc7752681c2f677d3e6fddf7daf6e183eb", "filename": "gcc/testsuite/gcc.dg/vect/vect-gather-1.c", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10833849b55401a52f2334eb032a70beb688e9fc/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-gather-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10833849b55401a52f2334eb032a70beb688e9fc/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-gather-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-gather-1.c?ref=10833849b55401a52f2334eb032a70beb688e9fc", "patch": "@@ -0,0 +1,60 @@\n+#include \"tree-vect.h\"\n+\n+#define N 16\n+\n+void __attribute__((noipa))\n+f (int *restrict y, int *restrict x, int *restrict indices)\n+{\n+  for (int i = 0; i < N; ++i)\n+    {\n+      y[i * 2] = x[indices[i * 2]] + 1;\n+      y[i * 2 + 1] = x[indices[i * 2 + 1]] + 2;\n+    }\n+}\n+\n+int y[N * 2];\n+int x[N * 2] = {\n+  72704, 52152, 51301, 96681,\n+  57937, 60490, 34504, 60944,\n+  42225, 28333, 88336, 74300,\n+  29250, 20484, 38852, 91536,\n+  86917, 63941, 31590, 21998,\n+  22419, 26974, 28668, 13968,\n+  3451, 20247, 44089, 85521,\n+  22871, 87362, 50555, 85939\n+};\n+int indices[N * 2] = {\n+  15, 16, 9, 19,\n+  7, 22, 19, 1,\n+  22, 13, 15, 30,\n+  5, 12, 11, 11,\n+  10, 25, 5, 20,\n+  22, 24, 24, 28,\n+  30, 19, 6, 4,\n+  7, 12, 8, 21\n+};\n+int expected[N * 2] = {\n+  91537, 86919, 28334, 22000,\n+  60945, 28670, 21999, 52154,\n+  28669, 20486, 91537, 50557,\n+  60491, 29252, 74301, 74302,\n+  88337, 20249, 60491, 22421,\n+  28669, 3453, 3452, 22873,\n+  50556, 22000, 34505, 57939,\n+  60945, 29252, 42226, 26976\n+};\n+\n+int\n+main (void)\n+{\n+  check_vect ();\n+\n+  f (y, x, indices);\n+  for (int i = 0; i < 32; ++i)\n+    if (y[i] != expected[i])\n+      __builtin_abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump \"Loop contains only SLP stmts\" vect { target vect_gather_load_ifn } } } */"}, {"sha": "a1f6ba458a97f4bf77466bb30fb5bd76537c5e5c", "filename": "gcc/testsuite/gcc.dg/vect/vect-gather-2.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10833849b55401a52f2334eb032a70beb688e9fc/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-gather-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10833849b55401a52f2334eb032a70beb688e9fc/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-gather-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-gather-2.c?ref=10833849b55401a52f2334eb032a70beb688e9fc", "patch": "@@ -0,0 +1,36 @@\n+/* { dg-do compile } */\n+\n+#define N 16\n+\n+void\n+f1 (int *restrict y, int *restrict x1, int *restrict x2,\n+    int *restrict indices)\n+{\n+  for (int i = 0; i < N; ++i)\n+    {\n+      y[i * 2] = x1[indices[i * 2]] + 1;\n+      y[i * 2 + 1] = x2[indices[i * 2 + 1]] + 2;\n+    }\n+}\n+\n+void\n+f2 (int *restrict y, int *restrict x, int *restrict indices)\n+{\n+  for (int i = 0; i < N; ++i)\n+    {\n+      y[i * 2] = x[indices[i * 2]] + 1;\n+      y[i * 2 + 1] = x[indices[i * 2 + 1] * 2] + 2;\n+    }\n+}\n+\n+void\n+f3 (int *restrict y, int *restrict x, int *restrict indices)\n+{\n+  for (int i = 0; i < N; ++i)\n+    {\n+      y[i * 2] = x[indices[i * 2]] + 1;\n+      y[i * 2 + 1] = x[(unsigned int) indices[i * 2 + 1]] + 2;\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"Loop contains only SLP stmts\" vect { target vect_gather_load_ifn } } } */"}, {"sha": "f6f78c1c8d99fae51edbd956367bacb11ce6697e", "filename": "gcc/testsuite/gcc.target/aarch64/sve/gather_load_11.c", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10833849b55401a52f2334eb032a70beb688e9fc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fgather_load_11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10833849b55401a52f2334eb032a70beb688e9fc/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fgather_load_11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fgather_load_11.c?ref=10833849b55401a52f2334eb032a70beb688e9fc", "patch": "@@ -0,0 +1,49 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fno-vect-cost-model\" } */\n+\n+#include <stdint.h>\n+\n+void\n+f1 (int32_t *restrict y, int32_t *restrict x, int32_t *restrict index)\n+{\n+  for (int i = 0; i < 100; ++i)\n+    {\n+      y[i * 2] = x[index[i * 2]] + 1;\n+      y[i * 2 + 1] = x[index[i * 2 + 1]] + 2;\n+    }\n+}\n+\n+void\n+f2 (int32_t *restrict y, int32_t *restrict x, uint32_t *restrict index)\n+{\n+  for (int i = 0; i < 100; ++i)\n+    {\n+      y[i * 2] = x[index[i * 2]] + 1;\n+      y[i * 2 + 1] = x[index[i * 2 + 1]] + 2;\n+    }\n+}\n+\n+void\n+f3 (int32_t *restrict y, int32_t *restrict x, uint64_t *restrict index)\n+{\n+  for (int i = 0; i < 100; ++i)\n+    {\n+      y[i * 2] = x[index[i * 2]] + 1;\n+      y[i * 2 + 1] = x[index[i * 2 + 1]] + 2;\n+    }\n+}\n+\n+void\n+f4 (int64_t *restrict y, int64_t *restrict x, uint64_t *restrict index)\n+{\n+  for (int i = 0; i < 100; ++i)\n+    {\n+      y[i * 2] = x[index[i * 2]] + 1;\n+      y[i * 2 + 1] = x[index[i * 2 + 1]] + 2;\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-times {\\tld1w\\tz[0-9]+\\.s, p[0-7]/z, \\[x[0-9]+, z[0-9]+\\.s, sxtw #?2\\]} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tld1w\\tz[0-9]+\\.s, p[0-7]/z, \\[x[0-9]+, z[0-9]+\\.s, uxtw #?2\\]} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tld1w\\tz[0-9]+\\.d, p[0-7]/z, \\[x[0-9]+, z[0-9]+\\.d, lsl #?2\\]} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tld1d\\tz[0-9]+\\.d, p[0-7]/z, \\[x[0-9]+, z[0-9]+\\.d, lsl #?3\\]} 1 } } */"}, {"sha": "caa8ab930566f02bb67c89de6d68f7199c937fa7", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10833849b55401a52f2334eb032a70beb688e9fc/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10833849b55401a52f2334eb032a70beb688e9fc/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=10833849b55401a52f2334eb032a70beb688e9fc", "patch": "@@ -7987,6 +7987,12 @@ proc check_effective_target_vect_masked_store { } {\n \t\t   || [istarget amdgcn*-*-*] }]\n }\n \n+# Return 1 if the target supports vector gather loads via internal functions.\n+\n+proc check_effective_target_vect_gather_load_ifn { } {\n+    return [expr { [check_effective_target_aarch64_sve] }]\n+}\n+\n # Return 1 if the target supports vector scatter stores.\n \n proc check_effective_target_vect_scatter_store { } {"}, {"sha": "12a82cd694a823227ec281bb65e19e3894f3bab6", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 30, "deletions": 34, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10833849b55401a52f2334eb032a70beb688e9fc/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10833849b55401a52f2334eb032a70beb688e9fc/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=10833849b55401a52f2334eb032a70beb688e9fc", "patch": "@@ -359,6 +359,20 @@ vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n   lambda_vector dist_v;\n   unsigned int loop_depth;\n \n+  /* If user asserted safelen consecutive iterations can be\n+     executed concurrently, assume independence.  */\n+  auto apply_safelen = [&]()\n+    {\n+      if (loop->safelen >= 2)\n+\t{\n+\t  if ((unsigned int) loop->safelen < *max_vf)\n+\t    *max_vf = loop->safelen;\n+\t  LOOP_VINFO_NO_DATA_DEPENDENCIES (loop_vinfo) = false;\n+\t  return true;\n+\t}\n+      return false;\n+    };\n+\n   /* In loop analysis all data references should be vectorizable.  */\n   if (!STMT_VINFO_VECTORIZABLE (stmtinfo_a)\n       || !STMT_VINFO_VECTORIZABLE (stmtinfo_b))\n@@ -393,26 +407,23 @@ vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n \t\t\t\t get_alias_set (DR_REF (drb))))\n     return opt_result::success ();\n \n+  if (STMT_VINFO_GATHER_SCATTER_P (stmtinfo_a)\n+      || STMT_VINFO_GATHER_SCATTER_P (stmtinfo_b))\n+    {\n+      if (apply_safelen ())\n+\treturn opt_result::success ();\n+\n+      return opt_result::failure_at\n+\t(stmtinfo_a->stmt,\n+\t \"possible alias involving gather/scatter between %T and %T\\n\",\n+\t DR_REF (dra), DR_REF (drb));\n+    }\n+\n   /* Unknown data dependence.  */\n   if (DDR_ARE_DEPENDENT (ddr) == chrec_dont_know)\n     {\n-      /* If user asserted safelen consecutive iterations can be\n-\t executed concurrently, assume independence.  */\n-      if (loop->safelen >= 2)\n-\t{\n-\t  if ((unsigned int) loop->safelen < *max_vf)\n-\t    *max_vf = loop->safelen;\n-\t  LOOP_VINFO_NO_DATA_DEPENDENCIES (loop_vinfo) = false;\n-\t  return opt_result::success ();\n-\t}\n-\n-      if (STMT_VINFO_GATHER_SCATTER_P (stmtinfo_a)\n-\t  || STMT_VINFO_GATHER_SCATTER_P (stmtinfo_b))\n-\treturn opt_result::failure_at\n-\t  (stmtinfo_a->stmt,\n-\t   \"versioning for alias not supported for: \"\n-\t   \"can't determine dependence between %T and %T\\n\",\n-\t   DR_REF (dra), DR_REF (drb));\n+      if (apply_safelen ())\n+\treturn opt_result::success ();\n \n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, stmtinfo_a->stmt,\n@@ -427,23 +438,8 @@ vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n   /* Known data dependence.  */\n   if (DDR_NUM_DIST_VECTS (ddr) == 0)\n     {\n-      /* If user asserted safelen consecutive iterations can be\n-\t executed concurrently, assume independence.  */\n-      if (loop->safelen >= 2)\n-\t{\n-\t  if ((unsigned int) loop->safelen < *max_vf)\n-\t    *max_vf = loop->safelen;\n-\t  LOOP_VINFO_NO_DATA_DEPENDENCIES (loop_vinfo) = false;\n-\t  return opt_result::success ();\n-\t}\n-\n-      if (STMT_VINFO_GATHER_SCATTER_P (stmtinfo_a)\n-\t  || STMT_VINFO_GATHER_SCATTER_P (stmtinfo_b))\n-\treturn opt_result::failure_at\n-\t  (stmtinfo_a->stmt,\n-\t   \"versioning for alias not supported for: \"\n-\t   \"bad dist vector for %T and %T\\n\",\n-\t   DR_REF (dra), DR_REF (drb));\n+      if (apply_safelen ())\n+\treturn opt_result::success ();\n \n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, stmtinfo_a->stmt,"}, {"sha": "40224ad4a14a7f0e6c2b846cf396663cd4496d11", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 24, "deletions": 5, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10833849b55401a52f2334eb032a70beb688e9fc/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10833849b55401a52f2334eb032a70beb688e9fc/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=10833849b55401a52f2334eb032a70beb688e9fc", "patch": "@@ -459,6 +459,7 @@ static const int cond_expr_maps[3][5] = {\n   { 4, -2, -1, 1, 2 },\n   { 4, -1, -2, 2, 1 }\n };\n+static const int arg1_map[] = { 1, 1 };\n static const int arg2_map[] = { 1, 2 };\n \n /* For most SLP statements, there is a one-to-one mapping between\n@@ -490,6 +491,9 @@ vect_get_operand_map (const gimple *stmt, unsigned char swap = 0)\n \t  case IFN_MASK_LOAD:\n \t    return arg2_map;\n \n+\t  case IFN_GATHER_LOAD:\n+\t    return arg1_map;\n+\n \t  default:\n \t    break;\n \t  }\n@@ -825,6 +829,20 @@ compatible_calls_p (gcall *call1, gcall *call2)\n       if (gimple_call_fntype (call1) != gimple_call_fntype (call2))\n \treturn false;\n     }\n+\n+  /* Check that any unvectorized arguments are equal.  */\n+  if (const int *map = vect_get_operand_map (call1))\n+    {\n+      unsigned int nkept = *map++;\n+      unsigned int mapi = 0;\n+      for (unsigned int i = 0; i < nargs; ++i)\n+\tif (mapi < nkept && map[mapi] == int (i))\n+\t  mapi += 1;\n+\telse if (!operand_equal_p (gimple_call_arg (call1, i),\n+\t\t\t\t   gimple_call_arg (call2, i)))\n+\t  return false;\n+    }\n+\n   return true;\n }\n \n@@ -982,7 +1000,7 @@ vect_build_slp_tree_1 (vec_info *vinfo, unsigned char *swap,\n \t  else\n \t    rhs_code = CALL_EXPR;\n \n-\t  if (cfn == CFN_MASK_LOAD)\n+\t  if (cfn == CFN_MASK_LOAD || cfn == CFN_GATHER_LOAD)\n \t    load_p = true;\n \t  else if ((internal_fn_p (cfn)\n \t\t    && !vectorizable_internal_fn_p (as_internal_fn (cfn)))\n@@ -1126,7 +1144,7 @@ vect_build_slp_tree_1 (vec_info *vinfo, unsigned char *swap,\n \t      continue;\n \t    }\n \n-\t  if (!load_p && call_stmt)\n+\t  if (call_stmt && first_stmt_code != CFN_MASK_LOAD)\n \t    {\n \t      if (!compatible_calls_p (as_a <gcall *> (stmts[0]->stmt),\n \t\t\t\t       call_stmt))\n@@ -1211,7 +1229,7 @@ vect_build_slp_tree_1 (vec_info *vinfo, unsigned char *swap,\n         } /* Grouped access.  */\n       else\n \t{\n-\t  if (load_p)\n+\t  if (load_p && rhs_code != CFN_GATHER_LOAD)\n \t    {\n \t      /* Not grouped load.  */\n \t      if (dump_enabled_p ())\n@@ -1692,7 +1710,8 @@ vect_build_slp_tree_2 (vec_info *vinfo, slp_tree node,\n       && DR_IS_READ (STMT_VINFO_DATA_REF (stmt_info)))\n     {\n       if (gcall *stmt = dyn_cast <gcall *> (stmt_info->stmt))\n-\tgcc_assert (gimple_call_internal_p (stmt, IFN_MASK_LOAD));\n+\tgcc_assert (gimple_call_internal_p (stmt, IFN_MASK_LOAD)\n+\t\t    || gimple_call_internal_p (stmt, IFN_GATHER_LOAD));\n       else\n \t{\n \t  *max_nunits = this_max_nunits;\n@@ -4408,7 +4427,7 @@ vect_slp_analyze_node_operations_1 (vec_info *vinfo, slp_tree node,\n      calculated by the recursive call).  Otherwise it is the number of\n      scalar elements in one scalar iteration (DR_GROUP_SIZE) multiplied by\n      VF divided by the number of elements in a vector.  */\n-  if (!STMT_VINFO_GROUPED_ACCESS (stmt_info)\n+  if (!STMT_VINFO_DATA_REF (stmt_info)\n       && REDUC_GROUP_FIRST_ELEMENT (stmt_info))\n     {\n       for (unsigned i = 0; i < SLP_TREE_CHILDREN (node).length (); ++i)"}, {"sha": "06da5a9bc1349653c2bfc3b31fb565dd6a079faa", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10833849b55401a52f2334eb032a70beb688e9fc/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10833849b55401a52f2334eb032a70beb688e9fc/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=10833849b55401a52f2334eb032a70beb688e9fc", "patch": "@@ -1674,6 +1674,7 @@ check_load_store_for_partial_vectors (loop_vec_info loop_vinfo, tree vectype,\n \t\t\t\t      int group_size,\n \t\t\t\t      vect_memory_access_type\n \t\t\t\t      memory_access_type,\n+\t\t\t\t      unsigned int ncopies,\n \t\t\t\t      gather_scatter_info *gs_info,\n \t\t\t\t      tree scalar_mask)\n {\n@@ -1698,7 +1699,6 @@ check_load_store_for_partial_vectors (loop_vec_info loop_vinfo, tree vectype,\n \t  LOOP_VINFO_CAN_USE_PARTIAL_VECTORS_P (loop_vinfo) = false;\n \t  return;\n \t}\n-      unsigned int ncopies = vect_get_num_copies (loop_vinfo, vectype);\n       vect_record_loop_mask (loop_vinfo, masks, ncopies, vectype, scalar_mask);\n       return;\n     }\n@@ -1721,7 +1721,6 @@ check_load_store_for_partial_vectors (loop_vec_info loop_vinfo, tree vectype,\n \t  LOOP_VINFO_CAN_USE_PARTIAL_VECTORS_P (loop_vinfo) = false;\n \t  return;\n \t}\n-      unsigned int ncopies = vect_get_num_copies (loop_vinfo, vectype);\n       vect_record_loop_mask (loop_vinfo, masks, ncopies, vectype, scalar_mask);\n       return;\n     }\n@@ -2963,6 +2962,7 @@ vect_build_gather_load_calls (vec_info *vinfo, stmt_vec_info stmt_info,\n static void\n vect_get_gather_scatter_ops (loop_vec_info loop_vinfo,\n \t\t\t     class loop *loop, stmt_vec_info stmt_info,\n+\t\t\t     slp_tree slp_node, unsigned int ncopies,\n \t\t\t     gather_scatter_info *gs_info,\n \t\t\t     tree *dataref_ptr, vec<tree> *vec_offset)\n {\n@@ -2975,10 +2975,12 @@ vect_get_gather_scatter_ops (loop_vec_info loop_vinfo,\n       new_bb = gsi_insert_seq_on_edge_immediate (pe, stmts);\n       gcc_assert (!new_bb);\n     }\n-  unsigned ncopies = vect_get_num_copies (loop_vinfo, gs_info->offset_vectype);\n-  vect_get_vec_defs_for_operand (loop_vinfo, stmt_info, ncopies,\n-\t\t\t\t gs_info->offset, vec_offset,\n-\t\t\t\t gs_info->offset_vectype);\n+  if (slp_node)\n+    vect_get_slp_defs (SLP_TREE_CHILDREN (slp_node)[0], vec_offset);\n+  else\n+    vect_get_vec_defs_for_operand (loop_vinfo, stmt_info, ncopies,\n+\t\t\t\t   gs_info->offset, vec_offset,\n+\t\t\t\t   gs_info->offset_vectype);\n }\n \n /* Prepare to implement a grouped or strided load or store using\n@@ -7484,7 +7486,7 @@ vectorizable_store (vec_info *vinfo,\n \t  && LOOP_VINFO_CAN_USE_PARTIAL_VECTORS_P (loop_vinfo))\n \tcheck_load_store_for_partial_vectors (loop_vinfo, vectype, vls_type,\n \t\t\t\t\t      group_size, memory_access_type,\n-\t\t\t\t\t      &gs_info, mask);\n+\t\t\t\t\t      ncopies, &gs_info, mask);\n \n       if (slp_node\n \t  && !vect_maybe_update_slp_op_vectype (SLP_TREE_CHILDREN (slp_node)[0],\n@@ -8147,8 +8149,8 @@ vectorizable_store (vec_info *vinfo,\n \t  else if (STMT_VINFO_GATHER_SCATTER_P (stmt_info))\n \t    {\n \t      vect_get_gather_scatter_ops (loop_vinfo, loop, stmt_info,\n-\t\t\t\t\t   &gs_info, &dataref_ptr,\n-\t\t\t\t\t   &vec_offsets);\n+\t\t\t\t\t   slp_node, ncopies, &gs_info,\n+\t\t\t\t\t   &dataref_ptr, &vec_offsets);\n \t      vec_offset = vec_offsets[0];\n \t    }\n \t  else\n@@ -8827,7 +8829,7 @@ vectorizable_load (vec_info *vinfo,\n \t  && LOOP_VINFO_CAN_USE_PARTIAL_VECTORS_P (loop_vinfo))\n \tcheck_load_store_for_partial_vectors (loop_vinfo, vectype, VLS_LOAD,\n \t\t\t\t\t      group_size, memory_access_type,\n-\t\t\t\t\t      &gs_info, mask);\n+\t\t\t\t\t      ncopies, &gs_info, mask);\n \n       if (dump_enabled_p ()\n \t  && memory_access_type != VMAT_ELEMENTWISE\n@@ -9445,8 +9447,8 @@ vectorizable_load (vec_info *vinfo,\n \t  else if (STMT_VINFO_GATHER_SCATTER_P (stmt_info))\n \t    {\n \t      vect_get_gather_scatter_ops (loop_vinfo, loop, stmt_info,\n-\t\t\t\t\t   &gs_info, &dataref_ptr,\n-\t\t\t\t\t   &vec_offsets);\n+\t\t\t\t\t   slp_node, ncopies, &gs_info,\n+\t\t\t\t\t   &dataref_ptr, &vec_offsets);\n \t    }\n \t  else\n \t    dataref_ptr"}]}