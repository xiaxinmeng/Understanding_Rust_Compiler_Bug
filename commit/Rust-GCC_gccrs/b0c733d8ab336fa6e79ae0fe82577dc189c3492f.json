{"sha": "b0c733d8ab336fa6e79ae0fe82577dc189c3492f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjBjNzMzZDhhYjMzNmZhNmU3OWFlMGZlODI1NzdkYzE4OWMzNDkyZg==", "commit": {"author": {"name": "Cary Coutant", "email": "ccoutant@google.com", "date": "2013-07-26T20:14:43Z"}, "committer": {"name": "Cary Coutant", "email": "ccoutant@gcc.gnu.org", "date": "2013-07-26T20:14:43Z"}, "message": "dwarf2out.c (die_checksum_ordered): Don't include template instantiations in signature.\n\ngcc/\n\t* dwarf2out.c (die_checksum_ordered): Don't include template\n\tinstantiations in signature.\n\t(is_template_parameter): New function.\n\t(is_template_instantiation): New function.\n\t(generate_skeleton_bottom_up): Don't include template instantiations\n\tin type unit DIE.\n\t(generate_skeleton): Likewise.\n\t(break_out_comdat_types): Move recursive call to break out nested\n\ttypes earlier.\n\t(prune_unused_types_mark_generic_parms_dies): Call\n\tis_template_parameter.\n\nFrom-SVN: r201275", "tree": {"sha": "16475d5d0684e8e7b50d8f0ca024dfe43326d3b9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/16475d5d0684e8e7b50d8f0ca024dfe43326d3b9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b0c733d8ab336fa6e79ae0fe82577dc189c3492f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0c733d8ab336fa6e79ae0fe82577dc189c3492f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b0c733d8ab336fa6e79ae0fe82577dc189c3492f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0c733d8ab336fa6e79ae0fe82577dc189c3492f/comments", "author": null, "committer": null, "parents": [{"sha": "b5860fd3d10dd3ca71be7e18f158cf2098c0200b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5860fd3d10dd3ca71be7e18f158cf2098c0200b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b5860fd3d10dd3ca71be7e18f158cf2098c0200b"}], "stats": {"total": 119, "additions": 89, "deletions": 30}, "files": [{"sha": "c3b52cd3ce421e3d571d2f9728d013c373abb061", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0c733d8ab336fa6e79ae0fe82577dc189c3492f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0c733d8ab336fa6e79ae0fe82577dc189c3492f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b0c733d8ab336fa6e79ae0fe82577dc189c3492f", "patch": "@@ -1,3 +1,17 @@\n+2013-07-26  Cary Coutant  <ccoutant@google.com>\n+\n+\t* dwarf2out.c (die_checksum_ordered): Don't include template\n+\tinstantiations in signature.\n+\t(is_template_parameter): New function.\n+\t(is_template_instantiation): New function.\n+\t(generate_skeleton_bottom_up): Don't include template instantiations\n+\tin type unit DIE.\n+\t(generate_skeleton): Likewise.\n+\t(break_out_comdat_types): Move recursive call to break out nested\n+\ttypes earlier.\n+\t(prune_unused_types_mark_generic_parms_dies): Call\n+\tis_template_parameter.\n+\n 2013-07-26  Ian Bolton  <ian.bolton@arm.com>\n \n \t* config/aarch64/aarch64.md (neg<mode>2): Offer alternative that"}, {"sha": "66cbfb032e0d9742ef88199a08941f87b8bf5747", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 75, "deletions": 30, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0c733d8ab336fa6e79ae0fe82577dc189c3492f/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0c733d8ab336fa6e79ae0fe82577dc189c3492f/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=b0c733d8ab336fa6e79ae0fe82577dc189c3492f", "patch": "@@ -3023,6 +3023,7 @@ static void compute_section_prefix (dw_die_ref);\n static int is_type_die (dw_die_ref);\n static int is_comdat_die (dw_die_ref);\n static int is_symbol_die (dw_die_ref);\n+static inline bool is_template_instantiation (dw_die_ref);\n static void assign_symbol_names (dw_die_ref);\n static void break_out_includes (dw_die_ref);\n static int is_declaration_die (dw_die_ref);\n@@ -6077,22 +6078,29 @@ die_checksum_ordered (dw_die_ref die, struct md5_ctx *ctx, int *mark)\n   CHECKSUM_ATTR (attrs.at_type);\n   CHECKSUM_ATTR (attrs.at_friend);\n \n-  /* Checksum the child DIEs, except for nested types and member functions.  */\n+  /* Checksum the child DIEs.  */\n   c = die->die_child;\n   if (c) do {\n     dw_attr_ref name_attr;\n \n     c = c->die_sib;\n     name_attr = get_AT (c, DW_AT_name);\n-    if ((is_type_die (c) || c->die_tag == DW_TAG_subprogram)\n-        && name_attr != NULL)\n+    if (is_template_instantiation (c))\n       {\n+\t/* Ignore instantiations of member type and function templates.  */\n+      }\n+    else if (name_attr != NULL\n+\t     && (is_type_die (c) || c->die_tag == DW_TAG_subprogram))\n+      {\n+\t/* Use a shallow checksum for named nested types and member\n+\t   functions.  */\n         CHECKSUM_ULEB128 ('S');\n         CHECKSUM_ULEB128 (c->die_tag);\n         CHECKSUM_STRING (AT_string (name_attr));\n       }\n     else\n       {\n+\t/* Use a deep checksum for other children.  */\n         /* Mark this DIE so it gets processed when unmarking.  */\n         if (c->die_mark == 0)\n           c->die_mark = -1;\n@@ -6505,6 +6513,36 @@ is_class_die (dw_die_ref c)\n                || c->die_tag == DW_TAG_structure_type);\n }\n \n+/* Return non-zero if this DIE is a template parameter.  */\n+\n+static inline bool\n+is_template_parameter (dw_die_ref die)\n+{\n+  switch (die->die_tag)\n+    {\n+    case DW_TAG_template_type_param:\n+    case DW_TAG_template_value_param:\n+    case DW_TAG_GNU_template_template_param:\n+    case DW_TAG_GNU_template_parameter_pack:\n+      return true;\n+    default:\n+      return false;\n+    }\n+}\n+\n+/* Return non-zero if this DIE represents a template instantiation.  */\n+\n+static inline bool\n+is_template_instantiation (dw_die_ref die)\n+{\n+  dw_die_ref c;\n+\n+  if (!is_type_die (die) && die->die_tag != DW_TAG_subprogram)\n+    return false;\n+  FOR_EACH_CHILD (die, c, if (is_template_parameter (c)) return true);\n+  return false;\n+}\n+\n static char *\n gen_internal_sym (const char *prefix)\n {\n@@ -7064,17 +7102,30 @@ generate_skeleton_bottom_up (skeleton_chain_node *parent)\n     node.new_die = NULL;\n     if (is_declaration_die (c))\n       {\n-        /* Clone the existing DIE, move the original to the skeleton\n-           tree (which is in the main CU), and put the clone, with\n-           all the original's children, where the original came from.  */\n-        dw_die_ref clone = clone_die (c);\n-        move_all_children (c, clone);\n-\n-        replace_child (c, clone, prev);\n-        generate_skeleton_ancestor_tree (parent);\n-        add_child_die (parent->new_die, c);\n-        node.new_die = c;\n-        c = clone;\n+\tif (is_template_instantiation (c))\n+\t  {\n+\t    /* Instantiated templates do not need to be cloned into the\n+\t       type unit.  Just move the DIE and its children back to\n+\t       the skeleton tree (in the main CU).  */\n+\t    remove_child_with_prev (c, prev);\n+\t    add_child_die (parent->new_die, c);\n+\t    c = prev;\n+\t  }\n+\telse\n+\t  {\n+\t    /* Clone the existing DIE, move the original to the skeleton\n+\t       tree (which is in the main CU), and put the clone, with\n+\t       all the original's children, where the original came from\n+\t       (which is about to be moved to the type unit).  */\n+\t    dw_die_ref clone = clone_die (c);\n+\t    move_all_children (c, clone);\n+\n+\t    replace_child (c, clone, prev);\n+\t    generate_skeleton_ancestor_tree (parent);\n+\t    add_child_die (parent->new_die, c);\n+\t    node.new_die = c;\n+\t    c = clone;\n+\t  }\n       }\n     generate_skeleton_bottom_up (&node);\n   } while (next != NULL);\n@@ -7092,8 +7143,11 @@ generate_skeleton (dw_die_ref die)\n   node.parent = NULL;\n \n   /* If this type definition is nested inside another type,\n-     always leave at least a declaration in its place.  */\n-  if (die->die_parent != NULL && is_type_die (die->die_parent))\n+     and is not an instantiation of a template, always leave\n+     at least a declaration in its place.  */\n+  if (die->die_parent != NULL\n+      && is_type_die (die->die_parent)\n+      && !is_template_instantiation (die))\n     node.new_die = clone_as_declaration (die);\n \n   generate_skeleton_bottom_up (&node);\n@@ -7168,6 +7222,9 @@ break_out_comdat_types (dw_die_ref die)\n         dw_die_ref replacement;\n \tcomdat_type_node_ref type_node;\n \n+        /* Break out nested types into their own type units.  */\n+        break_out_comdat_types (c);\n+\n         /* Create a new type unit DIE as the root for the new tree, and\n            add it to the list of comdat types.  */\n         unit = new_die (DW_TAG_type_unit, NULL, NULL);\n@@ -7187,9 +7244,6 @@ break_out_comdat_types (dw_die_ref die)\n \treplacement = remove_child_or_replace_with_skeleton (unit, c, prev);\n \ttype_node->skeleton_die = replacement;\n \n-        /* Break out nested types into their own type units.  */\n-        break_out_comdat_types (c);\n-\n         /* Add the DIE to the new compunit.  */\n \tadd_child_die (unit, c);\n \n@@ -22142,17 +22196,8 @@ prune_unused_types_mark_generic_parms_dies (dw_die_ref die)\n   c = die->die_child;\n   do\n     {\n-      switch (c->die_tag)\n-\t{\n-\tcase DW_TAG_template_type_param:\n-\tcase DW_TAG_template_value_param:\n-\tcase DW_TAG_GNU_template_template_param:\n-\tcase DW_TAG_GNU_template_parameter_pack:\n-\t  prune_unused_types_mark (c, 1);\n-\t  break;\n-\tdefault:\n-\t  break;\n-\t}\n+      if (is_template_parameter (c))\n+\tprune_unused_types_mark (c, 1);\n       c = c->die_sib;\n     } while (c && c != die->die_child);\n }"}]}