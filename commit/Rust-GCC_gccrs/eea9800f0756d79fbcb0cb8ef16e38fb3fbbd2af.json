{"sha": "eea9800f0756d79fbcb0cb8ef16e38fb3fbbd2af", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWVhOTgwMGYwNzU2ZDc5ZmJjYjBjYjhlZjE2ZTM4ZmIzZmJiZDJhZg==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2003-01-01T03:16:16Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2003-01-01T03:16:16Z"}, "message": "cp-tree.h (LOOKUP_TEMPLATES_EXPECTED): Remove.\n\n\t* cp-tree.h (LOOKUP_TEMPLATES_EXPECTED): Remove.\n\t(lookup_name_namespace_only): Likewise.\n\t(begin_only_namespace_names): Likewise.\n\t(end_only_namespace_names): Likewise.\n\t* decl.c (only_namespace_names): Remove.\n\t(qualify_lookup): Do not check LOOKUP_TEMPLATES_EXPECTED.\n\t(lookup_name_real): Do not check only_namespace_names.\n\t(lookup_name_namespace_only): Remove.\n\t(begin_only_namespace_names): Likewise.\n\t(end_only_namespace_names): Likewise.\n\t* parser.c (cp_parser_nested_name_specifier_opt): Handle erroneous\n\tnested-name-specifiers more gracefully.\n\t(cp_parser_class_or_namespace_name): Avoid looking up namespace\n\tnames when they cannot possibly appear.\n\t(cp_parser_template_name): Adjust call to cp_parser_lookup_name.\n\t(cp_parser_elaborated_type_specifier): Likewise.\n\t(cp_parser_namespace_name): Only look for namespace names.\n\t(cp_parser_lookup_name): Add is_namespace parameter.\n\t(cp_parser_lookup_name_simple): Adjust call to\n\tcp_parser_lookup_name.\n\n\t* g++.dg/parse/namespace1.C: New test.\n\nFrom-SVN: r60729", "tree": {"sha": "3066b97ea36670263a737d3fe7ba2294700eb811", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3066b97ea36670263a737d3fe7ba2294700eb811"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eea9800f0756d79fbcb0cb8ef16e38fb3fbbd2af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eea9800f0756d79fbcb0cb8ef16e38fb3fbbd2af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eea9800f0756d79fbcb0cb8ef16e38fb3fbbd2af", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eea9800f0756d79fbcb0cb8ef16e38fb3fbbd2af/comments", "author": null, "committer": null, "parents": [{"sha": "79cc29861692f8e55c2bb599315356e1c162dd14", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79cc29861692f8e55c2bb599315356e1c162dd14", "html_url": "https://github.com/Rust-GCC/gccrs/commit/79cc29861692f8e55c2bb599315356e1c162dd14"}], "stats": {"total": 158, "additions": 99, "deletions": 59}, "files": [{"sha": "8fed4792f3fe276b8300b8841043d69870eebfd5", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 25, "deletions": 4, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eea9800f0756d79fbcb0cb8ef16e38fb3fbbd2af/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eea9800f0756d79fbcb0cb8ef16e38fb3fbbd2af/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=eea9800f0756d79fbcb0cb8ef16e38fb3fbbd2af", "patch": "@@ -1,11 +1,32 @@\n-2002-12-31  Neil Booth  <neil@daikokuya.co.uk>\n-\n-\t* .cvsignore: Update.\n-\n 2002-12-31  Mark Mitchell  <mark@codesourcery.com>\n \n+\t* cp-tree.h (LOOKUP_TEMPLATES_EXPECTED): Remove.\n+\t(lookup_name_namespace_only): Likewise.\n+\t(begin_only_namespace_names): Likewise.\n+\t(end_only_namespace_names): Likewise.\n+\t* decl.c (only_namespace_names): Remove.\n+\t(qualify_lookup): Do not check LOOKUP_TEMPLATES_EXPECTED.\n+\t(lookup_name_real): Do not check only_namespace_names.\n+\t(lookup_name_namespace_only): Remove.\n+\t(begin_only_namespace_names): Likewise.\n+\t(end_only_namespace_names): Likewise.\n+\t* parser.c (cp_parser_nested_name_specifier_opt): Handle erroneous\n+\tnested-name-specifiers more gracefully.\n+\t(cp_parser_class_or_namespace_name): Avoid looking up namespace\n+\tnames when they cannot possibly appear.\n+\t(cp_parser_template_name): Adjust call to cp_parser_lookup_name.\n+\t(cp_parser_elaborated_type_specifier): Likewise.\n+\t(cp_parser_namespace_name): Only look for namespace names.\n+\t(cp_parser_lookup_name): Add is_namespace parameter.\n+\t(cp_parser_lookup_name_simple): Adjust call to\n+\tcp_parser_lookup_name.\n+\n \t* parser.c (cp_parser_dependent_type_p): Fix thinko.\n \n+2002-12-31  Neil Booth  <neil@daikokuya.co.uk>\n+\n+\t* .cvsignore: Update.\n+\n 2002-12-31  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* class.c (modify_vtable_entry): Remove unused variable."}, {"sha": "761976757134c3001157ad9653d63aecc12883a4", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eea9800f0756d79fbcb0cb8ef16e38fb3fbbd2af/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eea9800f0756d79fbcb0cb8ef16e38fb3fbbd2af/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=eea9800f0756d79fbcb0cb8ef16e38fb3fbbd2af", "patch": "@@ -3385,9 +3385,7 @@ enum overload_flags { NO_SPECIAL = 0, DTOR_FLAG, OP_FLAG, TYPENAME_FLAG };\n \n    LOOKUP_PREFER_TYPES means not to accept objects, and possibly namespaces.\n    LOOKUP_PREFER_NAMESPACES means not to accept objects, and possibly types.\n-   LOOKUP_PREFER_BOTH means class-or-namespace-name.\n-   LOOKUP_TEMPLATES_EXPECTED means that class templates also count\n-     as types.  */\n+   LOOKUP_PREFER_BOTH means class-or-namespace-name.  */\n \n #define LOOKUP_PROTECT (1)\n #define LOOKUP_COMPLAIN (2)\n@@ -3403,7 +3401,6 @@ enum overload_flags { NO_SPECIAL = 0, DTOR_FLAG, OP_FLAG, TYPENAME_FLAG };\n #define LOOKUP_PREFER_TYPES (2048)\n #define LOOKUP_PREFER_NAMESPACES (4096)\n #define LOOKUP_PREFER_BOTH (6144)\n-#define LOOKUP_TEMPLATES_EXPECTED (8192)\n \n #define LOOKUP_NAMESPACES_ONLY(F)  \\\n   (((F) & LOOKUP_PREFER_NAMESPACES) && !((F) & LOOKUP_PREFER_TYPES))\n@@ -3738,10 +3735,7 @@ extern tree lookup_qualified_name               (tree, tree, bool, int);\n extern tree lookup_name\t\t\t\tPARAMS ((tree, int));\n extern tree lookup_name_current_level\t\tPARAMS ((tree));\n extern tree lookup_type_current_level\t\tPARAMS ((tree));\n-extern tree lookup_name_namespace_only          PARAMS ((tree));\n extern tree lookup_name_real                    (tree, int, int, int, int);\n-extern void begin_only_namespace_names          PARAMS ((void));\n-extern void end_only_namespace_names            PARAMS ((void));\n extern tree namespace_ancestor\t\t\tPARAMS ((tree, tree));\n extern tree unqualified_namespace_lookup\tPARAMS ((tree, int, tree *));\n extern tree check_for_out_of_scope_variable     (tree);"}, {"sha": "aaf426294e1c5f7cc99a85d74ee639758668acf2", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 1, "deletions": 30, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eea9800f0756d79fbcb0cb8ef16e38fb3fbbd2af/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eea9800f0756d79fbcb0cb8ef16e38fb3fbbd2af/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=eea9800f0756d79fbcb0cb8ef16e38fb3fbbd2af", "patch": "@@ -207,9 +207,6 @@ tree cp_global_trees[CPTI_MAX];\n \n static GTY(()) tree global_type_node;\n \n-/* Expect only namespace names now.  */\n-static int only_namespace_names;\n-\n /* Used only for jumps to as-yet undefined labels, since jumps to\n    defined labels can have their validity checked immediately.  */\n \n@@ -5931,10 +5928,7 @@ qualify_lookup (val, flags)\n     return val;\n   if ((flags & LOOKUP_PREFER_NAMESPACES) && TREE_CODE (val) == NAMESPACE_DECL)\n     return val;\n-  if ((flags & LOOKUP_PREFER_TYPES)\n-      && (TREE_CODE (val) == TYPE_DECL\n-\t  || ((flags & LOOKUP_TEMPLATES_EXPECTED)\n-\t      && DECL_CLASS_TEMPLATE_P (val))))\n+  if ((flags & LOOKUP_PREFER_TYPES) && TREE_CODE (val) == TYPE_DECL)\n     return val;\n   if (flags & (LOOKUP_PREFER_NAMESPACES | LOOKUP_PREFER_TYPES))\n     return NULL_TREE;\n@@ -6105,10 +6099,6 @@ lookup_name_real (tree name,\n       return NULL_TREE;\n     }\n \n-  /* Hack: copy flag set by parser, if set. */\n-  if (only_namespace_names)\n-    namespaces_only = 1;\n-\n   flags |= lookup_flags (prefer_type, namespaces_only);\n \n   /* First, look in non-namespace scopes.  */\n@@ -6183,14 +6173,6 @@ lookup_function_nonclass (name, args)\n   return lookup_arg_dependent (name, lookup_name_nonclass (name), args);\n }\n \n-tree\n-lookup_name_namespace_only (name)\n-     tree name;\n-{\n-  /* type-or-namespace, nonclass, namespace_only */\n-  return lookup_name_real (name, 1, 1, 1, LOOKUP_COMPLAIN);\n-}\n-\n tree\n lookup_name (name, prefer_type)\n      tree name;\n@@ -6267,17 +6249,6 @@ lookup_type_current_level (name)\n   return t;\n }\n \n-void\n-begin_only_namespace_names ()\n-{\n-  only_namespace_names = 1;\n-}\n-\n-void\n-end_only_namespace_names ()\n-{\n-  only_namespace_names = 0;\n-}\n \f\n /* Push the declarations of builtin types into the namespace.\n    RID_INDEX is the index of the builtin type"}, {"sha": "9f7973c04d2466e28c2d2151400f0089813ceddb", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 61, "deletions": 18, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eea9800f0756d79fbcb0cb8ef16e38fb3fbbd2af/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eea9800f0756d79fbcb0cb8ef16e38fb3fbbd2af/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=eea9800f0756d79fbcb0cb8ef16e38fb3fbbd2af", "patch": "@@ -1684,7 +1684,7 @@ static void cp_parser_label_declaration\n /* Utility Routines */\n \n static tree cp_parser_lookup_name\n-  PARAMS ((cp_parser *, tree, bool, bool, bool));\n+  PARAMS ((cp_parser *, tree, bool, bool, bool, bool));\n static tree cp_parser_lookup_name_simple\n   PARAMS ((cp_parser *, tree));\n static tree cp_parser_resolve_typename_type\n@@ -3558,6 +3558,15 @@ cp_parser_nested_name_specifier_opt (cp_parser *parser,\n \t\t\t   token->value);\n \t\t  parser->scope = NULL_TREE;\n \t\t  error_p = true;\n+\t\t  /* Treat this as a successful nested-name-specifier\n+\t\t     due to:\n+\n+\t\t     [basic.lookup.qual]\n+\n+\t\t     If the name found is not a class-name (clause\n+\t\t     _class_) or namespace-name (_namespace.def_), the\n+\t\t     program is ill-formed.  */\n+\t\t  success = true;\n \t\t}\n \t      cp_lexer_consume_token (parser->lexer);\n \t    }\n@@ -3663,7 +3672,8 @@ cp_parser_nested_name_specifier (cp_parser *parser,\n    scope.\n \n    Returns the class (TYPE_DECL) or namespace (NAMESPACE_DECL)\n-   specified by the class-or-namespace-name.  */\n+   specified by the class-or-namespace-name.  If neither is found the\n+   ERROR_MARK_NODE is returned.  */\n \n static tree\n cp_parser_class_or_namespace_name (cp_parser *parser, \n@@ -3676,6 +3686,7 @@ cp_parser_class_or_namespace_name (cp_parser *parser,\n   tree saved_qualifying_scope;\n   tree saved_object_scope;\n   tree scope;\n+  bool only_class_p;\n \n   /* If the next token is the `template' keyword, we know that we are\n      looking at a class-name.  */\n@@ -3693,8 +3704,11 @@ cp_parser_class_or_namespace_name (cp_parser *parser,\n   saved_scope = parser->scope;\n   saved_qualifying_scope = parser->qualifying_scope;\n   saved_object_scope = parser->object_scope;\n-  /* Try for a class-name first.  */\n-  cp_parser_parse_tentatively (parser);\n+  /* Try for a class-name first.  If the SAVED_SCOPE is a type, then\n+     there is no need to look for a namespace-name.  */\n+  only_class_p = saved_scope && TYPE_P (saved_scope);\n+  if (!only_class_p)\n+    cp_parser_parse_tentatively (parser);\n   scope = cp_parser_class_name (parser, \n \t\t\t\ttypename_keyword_p,\n \t\t\t\ttemplate_keyword_p,\n@@ -3703,13 +3717,19 @@ cp_parser_class_or_namespace_name (cp_parser *parser,\n \t\t\t\tcheck_dependency_p,\n \t\t\t\t/*class_head_p=*/false);\n   /* If that didn't work, try for a namespace-name.  */\n-  if (!cp_parser_parse_definitely (parser))\n+  if (!only_class_p && !cp_parser_parse_definitely (parser))\n     {\n       /* Restore the saved scope.  */\n       parser->scope = saved_scope;\n       parser->qualifying_scope = saved_qualifying_scope;\n       parser->object_scope = saved_object_scope;\n-      /* Now look for a namespace-name.  */\n+      /* If we are not looking at an identifier followed by the scope\n+\t resolution operator, then this is not part of a\n+\t nested-name-specifier.  (Note that this function is only used\n+\t to parse the components of a nested-name-specifier.)  */\n+      if (cp_lexer_next_token_is_not (parser->lexer, CPP_NAME)\n+\t  || cp_lexer_peek_nth_token (parser->lexer, 2)->type != CPP_SCOPE)\n+\treturn error_mark_node;\n       scope = cp_parser_namespace_name (parser);\n     }\n \n@@ -8225,6 +8245,7 @@ cp_parser_template_name (parser, template_keyword_p, check_dependency_p)\n   decl = cp_parser_lookup_name (parser, identifier,\n \t\t\t\t/*check_access=*/true,\n \t\t\t\t/*is_type=*/false,\n+\t\t\t\t/*is_namespace=*/false,\n \t\t\t\tcheck_dependency_p);\n   decl = maybe_get_template_decl_from_type_decl (decl);\n \n@@ -8966,6 +8987,7 @@ cp_parser_elaborated_type_specifier (parser, is_friend, is_declaration)\n \t  decl = cp_parser_lookup_name (parser, identifier, \n \t\t\t\t\t/*check_access=*/true,\n \t\t\t\t\t/*is_type=*/true,\n+\t\t\t\t\t/*is_namespace=*/false,\n \t\t\t\t\t/*check_dependency=*/true);\n \t  decl = (cp_parser_maybe_treat_template_as_class \n \t\t  (decl, /*tag_name_p=*/is_friend));\n@@ -9193,8 +9215,29 @@ cp_parser_namespace_name (parser)\n   if (identifier == error_mark_node)\n     return error_mark_node;\n \n-  /* Look up the identifier in the currently active scope.  */\n-  namespace_decl = cp_parser_lookup_name_simple (parser, identifier);\n+  /* Look up the identifier in the currently active scope.  Look only\n+     for namespaces, due to:\n+\n+       [basic.lookup.udir]\n+\n+       When looking up a namespace-name in a using-directive or alias\n+       definition, only namespace names are considered.  \n+\n+     And:\n+\n+       [basic.lookup.qual]\n+\n+       During the lookup of a name preceding the :: scope resolution\n+       operator, object, function, and enumerator names are ignored.  \n+\n+     (Note that cp_parser_class_or_namespace_name only calls this\n+     function if the token after the name is the scope resolution\n+     operator.)  */\n+  namespace_decl = cp_parser_lookup_name (parser, identifier,\n+\t\t\t\t\t  /*check_access=*/true,\n+\t\t\t\t\t  /*is_type=*/false,\n+\t\t\t\t\t  /*is_namespace=*/true,\n+\t\t\t\t\t  /*check_dependency=*/true);\n   /* If it's not a namespace, issue an error.  */\n   if (namespace_decl == error_mark_node\n       || TREE_CODE (namespace_decl) != NAMESPACE_DECL)\n@@ -11406,6 +11449,7 @@ cp_parser_class_name (cp_parser *parser,\n \t  decl = cp_parser_lookup_name (parser, identifier, \n \t\t\t\t\tcheck_access_p,\n \t\t\t\t\ttype_p,\n+\t\t\t\t\t/*is_namespace=*/false,\n \t\t\t\t\tcheck_dependency_p);\n \t}\n     }\n@@ -13268,17 +13312,15 @@ cp_parser_label_declaration (parser)\n    If IS_TYPE is TRUE, bindings that do not refer to types are\n    ignored.\n \n+   If IS_NAMESPACE is TRUE, bindings that do not refer to namespaces\n+   are ignored.\n+\n    If CHECK_DEPENDENCY is TRUE, names are not looked up in dependent\n    types.  */\n \n static tree\n-cp_parser_lookup_name (parser, name, check_access, is_type, \n-\t\t       check_dependency)\n-     cp_parser *parser;\n-     tree name;\n-     bool check_access;\n-     bool is_type;\n-     bool check_dependency;\n+cp_parser_lookup_name (cp_parser *parser, tree name, bool check_access, \n+\t\t       bool is_type, bool is_namespace, bool check_dependency)\n {\n   tree decl;\n   tree object_type = parser->context->object_type;\n@@ -13396,7 +13438,7 @@ cp_parser_lookup_name (parser, name, check_access, is_type,\n \t\t\t\t     /*protect=*/0, is_type);\n       /* Look it up in the enclosing context, too.  */\n       decl = lookup_name_real (name, is_type, /*nonclass=*/0, \n-\t\t\t       /*namespaces_only=*/0, \n+\t\t\t       is_namespace,\n \t\t\t       /*flags=*/0);\n       parser->object_scope = object_type;\n       parser->qualifying_scope = NULL_TREE;\n@@ -13406,7 +13448,7 @@ cp_parser_lookup_name (parser, name, check_access, is_type,\n   else\n     {\n       decl = lookup_name_real (name, is_type, /*nonclass=*/0, \n-\t\t\t       /*namespaces_only=*/0, \n+\t\t\t       is_namespace,\n \t\t\t       /*flags=*/0);\n       parser->qualifying_scope = NULL_TREE;\n       parser->object_scope = NULL_TREE;\n@@ -13481,7 +13523,8 @@ cp_parser_lookup_name_simple (parser, name)\n {\n   return cp_parser_lookup_name (parser, name, \n \t\t\t\t/*check_access=*/true,\n-\t\t\t\t/*is_type=*/false, \n+\t\t\t\t/*is_type=*/false,\n+\t\t\t\t/*is_namespace=*/false,\n \t\t\t\t/*check_dependency=*/true);\n }\n "}, {"sha": "4af49305c02d3be33b89b708712e69fabd61e5b8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eea9800f0756d79fbcb0cb8ef16e38fb3fbbd2af/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eea9800f0756d79fbcb0cb8ef16e38fb3fbbd2af/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=eea9800f0756d79fbcb0cb8ef16e38fb3fbbd2af", "patch": "@@ -1,3 +1,7 @@\n+2002-12-31  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* g++.dg/parse/namespace1.C: New test.\n+\t\n 2003-01-01  Neil Booth  <neil@daikokuya.co.uk>\n \n \t* g++.dg/parse/parse4.C: New test."}, {"sha": "7740bce2dc4708d8328d6872634b4d95279fbb35", "filename": "gcc/testsuite/g++.dg/parse/namespace1.C", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eea9800f0756d79fbcb0cb8ef16e38fb3fbbd2af/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fnamespace1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eea9800f0756d79fbcb0cb8ef16e38fb3fbbd2af/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fnamespace1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fnamespace1.C?ref=eea9800f0756d79fbcb0cb8ef16e38fb3fbbd2af", "patch": "@@ -0,0 +1,7 @@\n+namespace foo {\n+void baz(int);\n+}\n+\n+int bar(int foo) {\n+  foo::baz (3);\n+}"}]}