{"sha": "a30187538a72dc5784b02a327a063637c2d20886", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTMwMTg3NTM4YTcyZGM1Nzg0YjAyYTMyN2EwNjM2MzdjMmQyMDg4Ng==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2007-01-05T21:27:16Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2007-01-05T21:27:16Z"}, "message": "trans-expr.c (gfc_trans_assignment_1): New subroutine to scalarize array assignments split out from gfc_trans_assignment.\n\n\n\t* trans-expr.c (gfc_trans_assignment_1): New subroutine to scalarize\n\tarray assignments split out from gfc_trans_assignment.\n\t(gfc_trans_array_copy): New function to implement array to array\n\tcopies via calls to __builtin_memcpy.\n\t(copyable_array_p): New helper function to identify an array of\n\tsimple/POD types, that may be copied/assigned using memcpy.\n\t(gfc_trans_assignment): Use gfc_trans_array_copy to handle simple\n\twhole array assignments considered suitable by copyable_array_p.\n\tInvoke gfc_trans_assignment_1 to perform the fallback scalarization.\n\n\t* gfortran.dg/array_memcpy_1.f90: New test case.\n\t* gfortran.dg/array_memcpy_2.f90: Likewise.\n\nFrom-SVN: r120503", "tree": {"sha": "41943ba20b346abc910f4e4192a3134252f5bbab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/41943ba20b346abc910f4e4192a3134252f5bbab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a30187538a72dc5784b02a327a063637c2d20886", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a30187538a72dc5784b02a327a063637c2d20886", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a30187538a72dc5784b02a327a063637c2d20886", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a30187538a72dc5784b02a327a063637c2d20886/comments", "author": null, "committer": null, "parents": [{"sha": "c573f4d5c6b1ac612911b8b5e77531a233d1cca1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c573f4d5c6b1ac612911b8b5e77531a233d1cca1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c573f4d5c6b1ac612911b8b5e77531a233d1cca1"}], "stats": {"total": 230, "additions": 206, "deletions": 24}, "files": [{"sha": "005d4b3965bc6f75d0fa0ef04155e643658f1907", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a30187538a72dc5784b02a327a063637c2d20886/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a30187538a72dc5784b02a327a063637c2d20886/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=a30187538a72dc5784b02a327a063637c2d20886", "patch": "@@ -1,3 +1,15 @@\n+2007-01-05  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* trans-expr.c (gfc_trans_assignment_1): New subroutine to scalarize\n+\tarray assignments split out from gfc_trans_assignment.\n+\t(gfc_trans_array_copy): New function to implement array to array\n+\tcopies via calls to __builtin_memcpy.\n+\t(copyable_array_p): New helper function to identify an array of\n+\tsimple/POD types, that may be copied/assigned using memcpy.\n+\t(gfc_trans_assignment): Use gfc_trans_array_copy to handle simple\n+\twhole array assignments considered suitable by copyable_array_p.\n+\tInvoke gfc_trans_assignment_1 to perform the fallback scalarization.\n+\n 2007-01-05  Roger Sayle  <roger@eyesopen.com>\n \n \t* trans-array.c (gfc_trans_array_constructor_value): Make the"}, {"sha": "c6ebf3e8b31d9ffdd0075aad6ea7536f870712e6", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 141, "deletions": 24, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a30187538a72dc5784b02a327a063637c2d20886/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a30187538a72dc5784b02a327a063637c2d20886/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=a30187538a72dc5784b02a327a063637c2d20886", "patch": "@@ -3579,11 +3579,76 @@ gfc_trans_zero_assign (gfc_expr * expr)\n   return fold_convert (void_type_node, tmp);\n }\n \n-/* Translate an assignment.  Most of the code is concerned with\n-   setting up the scalarizer.  */\n+/* Try to efficiently translate dst(:) = src(:).  Return NULL if this\n+   can't be done.  EXPR1 is the destination/lhs and EXPR2 is the\n+   source/rhs, both are gfc_full_array_ref_p which have been checked for\n+   dependencies.  */\n \n-tree\n-gfc_trans_assignment (gfc_expr * expr1, gfc_expr * expr2, bool init_flag)\n+static tree\n+gfc_trans_array_copy (gfc_expr * expr1, gfc_expr * expr2)\n+{\n+  tree dst, dlen, dtype;\n+  tree src, slen, stype;\n+  tree tmp, args;\n+\n+  dst = gfc_get_symbol_decl (expr1->symtree->n.sym);\n+  src = gfc_get_symbol_decl (expr2->symtree->n.sym);\n+\n+  dtype = TREE_TYPE (dst);\n+  if (POINTER_TYPE_P (dtype))\n+    dtype = TREE_TYPE (dtype);\n+  stype = TREE_TYPE (src);\n+  if (POINTER_TYPE_P (stype))\n+    stype = TREE_TYPE (stype);\n+\n+  if (!GFC_ARRAY_TYPE_P (dtype) || !GFC_ARRAY_TYPE_P (stype))\n+    return NULL_TREE;\n+\n+  /* Determine the lengths of the arrays.  */\n+  dlen = GFC_TYPE_ARRAY_SIZE (dtype);\n+  if (!dlen || TREE_CODE (dlen) != INTEGER_CST)\n+    return NULL_TREE;\n+  dlen = fold_build2 (MULT_EXPR, gfc_array_index_type, dlen,\n+\t\t      TYPE_SIZE_UNIT (gfc_get_element_type (dtype)));\n+\n+  slen = GFC_TYPE_ARRAY_SIZE (stype);\n+  if (!slen || TREE_CODE (slen) != INTEGER_CST)\n+    return NULL_TREE;\n+  slen = fold_build2 (MULT_EXPR, gfc_array_index_type, slen,\n+\t\t      TYPE_SIZE_UNIT (gfc_get_element_type (stype)));\n+\n+  /* Sanity check that they are the same.  This should always be\n+     the case, as we should already have checked for conformance.  */\n+  if (!tree_int_cst_equal (slen, dlen))\n+    return NULL_TREE;\n+\n+  /* Convert arguments to the correct types.  */\n+  if (!POINTER_TYPE_P (TREE_TYPE (dst)))\n+    dst = gfc_build_addr_expr (pvoid_type_node, dst);\n+  else\n+    dst = fold_convert (pvoid_type_node, dst);\n+\n+  if (!POINTER_TYPE_P (TREE_TYPE (src)))\n+    src = gfc_build_addr_expr (pvoid_type_node, src);\n+  else\n+    src = fold_convert (pvoid_type_node, src);\n+\n+  dlen = fold_convert (size_type_node, dlen);\n+\n+  /* Construct call to __builtin_memcpy.  */\n+  args = build_tree_list (NULL_TREE, dlen);\n+  args = tree_cons (NULL_TREE, src, args);\n+  args = tree_cons (NULL_TREE, dst, args);\n+  tmp = build_function_call_expr (built_in_decls[BUILT_IN_MEMCPY], args);\n+  return fold_convert (void_type_node, tmp);\n+}\n+\n+\n+/* Subroutine of gfc_trans_assignment that actually scalarizes the\n+   assignment.  EXPR1 is the destination/RHS and EXPR2 is the source/LHS.  */\n+\n+static tree\n+gfc_trans_assignment_1 (gfc_expr * expr1, gfc_expr * expr2, bool init_flag)\n {\n   gfc_se lse;\n   gfc_se rse;\n@@ -3596,26 +3661,6 @@ gfc_trans_assignment (gfc_expr * expr1, gfc_expr * expr2, bool init_flag)\n   stmtblock_t body;\n   bool l_is_temp;\n \n-  /* Special case a single function returning an array.  */\n-  if (expr2->expr_type == EXPR_FUNCTION && expr2->rank > 0)\n-    {\n-      tmp = gfc_trans_arrayfunc_assign (expr1, expr2);\n-      if (tmp)\n-\treturn tmp;\n-    }\n-\n-  /* Special case assigning an array to zero.  */\n-  if (expr1->expr_type == EXPR_VARIABLE\n-      && expr1->rank > 0\n-      && expr1->ref\n-      && gfc_full_array_ref_p (expr1->ref)\n-      && is_zero_initializer_p (expr2))\n-    {\n-      tmp = gfc_trans_zero_assign (expr1);\n-      if (tmp)\n-        return tmp;\n-    }\n-\n   /* Assignment of the form lhs = rhs.  */\n   gfc_start_block (&block);\n \n@@ -3751,6 +3796,78 @@ gfc_trans_assignment (gfc_expr * expr1, gfc_expr * expr2, bool init_flag)\n   return gfc_finish_block (&block);\n }\n \n+\n+/* Check whether EXPR, which is an EXPR_VARIABLE, is a copyable array.  */\n+\n+static bool\n+copyable_array_p (gfc_expr * expr)\n+{\n+  /* First check it's an array.  */\n+  if (expr->rank < 1 || !expr->ref)\n+    return false;\n+\n+  /* Next check that it's of a simple enough type.  */\n+  switch (expr->ts.type)\n+    {\n+    case BT_INTEGER:\n+    case BT_REAL:\n+    case BT_COMPLEX:\n+    case BT_LOGICAL:\n+      return true;\n+\n+    default:\n+      break;\n+    }\n+\n+  return false;\n+}\n+\n+/* Translate an assignment.  */\n+\n+tree\n+gfc_trans_assignment (gfc_expr * expr1, gfc_expr * expr2, bool init_flag)\n+{\n+  tree tmp;\n+\n+  /* Special case a single function returning an array.  */\n+  if (expr2->expr_type == EXPR_FUNCTION && expr2->rank > 0)\n+    {\n+      tmp = gfc_trans_arrayfunc_assign (expr1, expr2);\n+      if (tmp)\n+\treturn tmp;\n+    }\n+\n+  /* Special case assigning an array to zero.  */\n+  if (expr1->expr_type == EXPR_VARIABLE\n+      && expr1->rank > 0\n+      && expr1->ref\n+      && gfc_full_array_ref_p (expr1->ref)\n+      && is_zero_initializer_p (expr2))\n+    {\n+      tmp = gfc_trans_zero_assign (expr1);\n+      if (tmp)\n+        return tmp;\n+    }\n+\n+  /* Special case copying one array to another.  */\n+  if (expr1->expr_type == EXPR_VARIABLE\n+      && copyable_array_p (expr1)\n+      && gfc_full_array_ref_p (expr1->ref)\n+      && expr2->expr_type == EXPR_VARIABLE\n+      && copyable_array_p (expr2)\n+      && gfc_full_array_ref_p (expr2->ref)\n+      && gfc_compare_types (&expr1->ts, &expr2->ts)\n+      && !gfc_check_dependency (expr1, expr2, 0))\n+    {\n+      tmp = gfc_trans_array_copy (expr1, expr2);\n+      if (tmp)\n+        return tmp;\n+    }\n+\n+  /* Fallback to the scalarizer to generate explicit loops.  */\n+  return gfc_trans_assignment_1 (expr1, expr2, init_flag);\n+}\n+\n tree\n gfc_trans_init_assign (gfc_code * code)\n {"}, {"sha": "18909655fb5251b6de7d7dd2c81bd7806bc6f38f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a30187538a72dc5784b02a327a063637c2d20886/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a30187538a72dc5784b02a327a063637c2d20886/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a30187538a72dc5784b02a327a063637c2d20886", "patch": "@@ -1,3 +1,8 @@\n+2007-01-05  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* gfortran.dg/array_memcpy_1.f90: New test case.\n+\t* gfortran.dg/array_memcpy_2.f90: Likewise.\n+\n 2007-01-05  Richard Guenther  <rguenther@suse.de>\n \n \tPR middle-end/27826"}, {"sha": "2d2f8f7307309d69e5852956b239eb3166850644", "filename": "gcc/testsuite/gfortran.dg/array_memcpy_1.f90", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a30187538a72dc5784b02a327a063637c2d20886/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_memcpy_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a30187538a72dc5784b02a327a063637c2d20886/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_memcpy_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_memcpy_1.f90?ref=a30187538a72dc5784b02a327a063637c2d20886", "patch": "@@ -0,0 +1,28 @@\n+! { dg-do compile }\n+! { dg-options \"-O2 -fdump-tree-original\" }\n+subroutine testi(a,b)\n+  integer :: a(20)\n+  integer :: b(20)\n+  a = b;\n+end subroutine\n+\n+subroutine testr(a,b)\n+  real :: a(20)\n+  real :: b(20)\n+  a = b;\n+end subroutine\n+\n+subroutine testz(a,b)\n+  complex :: a(20)\n+  complex :: b(20)\n+  a = b;\n+end subroutine\n+\n+subroutine testl(a,b)\n+  logical :: a(20)\n+  logical :: b(20)\n+  a = b;\n+end subroutine\n+\n+! { dg-final { scan-tree-dump-times \"memcpy\" 4 \"original\" } }\n+! { dg-final { cleanup-tree-dump \"original\" } }"}, {"sha": "be8f00d1738dd0b80b7157e03a18d44c65d43393", "filename": "gcc/testsuite/gfortran.dg/array_memcpy_2.f90", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a30187538a72dc5784b02a327a063637c2d20886/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_memcpy_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a30187538a72dc5784b02a327a063637c2d20886/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_memcpy_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_memcpy_2.f90?ref=a30187538a72dc5784b02a327a063637c2d20886", "patch": "@@ -0,0 +1,20 @@\n+! This checks that the \"z = y\" assignment is not considered copyable, as the\n+! array is of a derived type containing allocatable components.  Hence, we\n+! we should expand the scalarized loop, which contains *two* memcpy calls.\n+! { dg-do compile }\n+! { dg-options \"-O2 -fdump-tree-original\" }\n+\n+  type :: a\n+    integer, allocatable :: i(:)\n+  end type a\n+\n+  type :: b\n+    type (a), allocatable :: at(:)\n+  end type b\n+\n+  type(b) :: y(2), z(2)\n+\n+  z = y\n+end\n+! { dg-final { scan-tree-dump-times \"memcpy\" 2 \"original\" } }\n+! { dg-final { cleanup-tree-dump \"original\" } }"}]}