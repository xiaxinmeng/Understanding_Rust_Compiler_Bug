{"sha": "636201978b356a45b8626fc75fc63c8c2747dce5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjM2MjAxOTc4YjM1NmE0NWI4NjI2ZmM3NWZjNjNjOGMyNzQ3ZGNlNQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2014-04-11T18:25:07Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2014-04-11T18:25:07Z"}, "message": "parser.h (struct cp_token): Rename ambiguous_p to error_reported.\n\n\t* parser.h (struct cp_token): Rename ambiguous_p to error_reported.\n\t* parser.c: Adjust.\n\t(cp_lexer_get_preprocessor_token): Always clear it.\n\t(cp_parser_lambda_expression): Use it to avoid duplicate diagnostics.\n\nFrom-SVN: r209315", "tree": {"sha": "6b34df289fc064532af23c0051a77abf3efd7d70", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6b34df289fc064532af23c0051a77abf3efd7d70"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/636201978b356a45b8626fc75fc63c8c2747dce5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/636201978b356a45b8626fc75fc63c8c2747dce5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/636201978b356a45b8626fc75fc63c8c2747dce5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/636201978b356a45b8626fc75fc63c8c2747dce5/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1c982d13138ee4518db10b6fbe02fa32d09ab51e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c982d13138ee4518db10b6fbe02fa32d09ab51e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1c982d13138ee4518db10b6fbe02fa32d09ab51e"}], "stats": {"total": 35, "additions": 22, "deletions": 13}, "files": [{"sha": "bf61ab7564b101041c8111f511daba2a58f202ef", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/636201978b356a45b8626fc75fc63c8c2747dce5/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/636201978b356a45b8626fc75fc63c8c2747dce5/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=636201978b356a45b8626fc75fc63c8c2747dce5", "patch": "@@ -1,5 +1,10 @@\n 2014-04-11  Jason Merrill  <jason@redhat.com>\n \n+\t* parser.h (struct cp_token): Rename ambiguous_p to error_reported.\n+\t* parser.c: Adjust.\n+\t(cp_lexer_get_preprocessor_token): Always clear it.\n+\t(cp_parser_lambda_expression): Use it to avoid duplicate diagnostics.\n+\n \tDR 1467\n \tPR c++/51747\n \t* decl.c (reshape_init_r): Handle a single element of class type."}, {"sha": "bb59e3bcdd19b3d99c06665b85d1ba445434b112", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/636201978b356a45b8626fc75fc63c8c2747dce5/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/636201978b356a45b8626fc75fc63c8c2747dce5/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=636201978b356a45b8626fc75fc63c8c2747dce5", "patch": "@@ -762,6 +762,7 @@ cp_lexer_get_preprocessor_token (cp_lexer *lexer, cp_token *token)\n   token->keyword = RID_MAX;\n   token->pragma_kind = PRAGMA_NONE;\n   token->purged_p = false;\n+  token->error_reported = false;\n \n   /* On some systems, some header files are surrounded by an\n      implicit extern \"C\" block.  Set a flag in the token if it\n@@ -797,7 +798,6 @@ cp_lexer_get_preprocessor_token (cp_lexer *lexer, cp_token *token)\n               C_SET_RID_CODE (token->u.value, RID_MAX);\n             }\n \n-\t  token->ambiguous_p = false;\n \t  token->keyword = RID_MAX;\n \t}\n     }\n@@ -3011,7 +3011,7 @@ cp_parser_parse_and_diagnose_invalid_type_name (cp_parser *parser)\n   if (token->type == CPP_NESTED_NAME_SPECIFIER)\n     {\n       cp_token *next = cp_lexer_peek_nth_token (parser->lexer, 2);\n-      if (next->type == CPP_NAME && next->ambiguous_p)\n+      if (next->type == CPP_NAME && next->error_reported)\n \tgoto out;\n     }\n \n@@ -4535,7 +4535,7 @@ cp_parser_primary_expression (cp_parser *parser,\n \t       we've already issued an error message; there's no reason\n \t       to check again.  */\n \t    if (id_expr_token->type == CPP_NAME\n-\t\t&& id_expr_token->ambiguous_p)\n+\t\t&& id_expr_token->error_reported)\n \t      {\n \t\tcp_parser_simulate_error (parser);\n \t\treturn error_mark_node;\n@@ -5313,7 +5313,7 @@ cp_parser_nested_name_specifier_opt (cp_parser *parser,\n \t      token = cp_lexer_consume_token (parser->lexer);\n \t      if (!error_p)\n \t\t{\n-\t\t  if (!token->ambiguous_p)\n+\t\t  if (!token->error_reported)\n \t\t    {\n \t\t      tree decl;\n \t\t      tree ambiguous_decls;\n@@ -8719,14 +8719,18 @@ cp_parser_lambda_expression (cp_parser* parser)\n   tree lambda_expr = build_lambda_expr ();\n   tree type;\n   bool ok = true;\n+  cp_token *token = cp_lexer_peek_token (parser->lexer);\n \n-  LAMBDA_EXPR_LOCATION (lambda_expr)\n-    = cp_lexer_peek_token (parser->lexer)->location;\n+  LAMBDA_EXPR_LOCATION (lambda_expr) = token->location;\n \n   if (cp_unevaluated_operand)\n     {\n-      error_at (LAMBDA_EXPR_LOCATION (lambda_expr),\n-\t\t\"lambda-expression in unevaluated context\");\n+      if (!token->error_reported)\n+\t{\n+\t  error_at (LAMBDA_EXPR_LOCATION (lambda_expr),\n+\t\t    \"lambda-expression in unevaluated context\");\n+\t  token->error_reported = true;\n+\t}\n       ok = false;\n     }\n \n@@ -19129,7 +19133,7 @@ cp_parser_class_name (cp_parser *parser,\n \n       /* Look for the identifier.  */\n       identifier_token = cp_lexer_peek_token (parser->lexer);\n-      ambiguous_p = identifier_token->ambiguous_p;\n+      ambiguous_p = identifier_token->error_reported;\n       identifier = cp_parser_identifier (parser);\n       /* If the next token isn't an identifier, we are certainly not\n \t looking at a class-name.  */"}, {"sha": "758c6df3c27df7d024213c913e3dfc22df9f354e", "filename": "gcc/cp/parser.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/636201978b356a45b8626fc75fc63c8c2747dce5/gcc%2Fcp%2Fparser.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/636201978b356a45b8626fc75fc63c8c2747dce5/gcc%2Fcp%2Fparser.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.h?ref=636201978b356a45b8626fc75fc63c8c2747dce5", "patch": "@@ -51,10 +51,10 @@ typedef struct GTY (()) cp_token {\n   ENUM_BITFIELD (pragma_kind) pragma_kind : 6;\n   /* True if this token is from a context where it is implicitly extern \"C\" */\n   BOOL_BITFIELD implicit_extern_c : 1;\n-  /* True for a CPP_NAME token that is not a keyword (i.e., for which\n-     KEYWORD is RID_MAX) iff this name was looked up and found to be\n-     ambiguous.  An error has already been reported.  */\n-  BOOL_BITFIELD ambiguous_p : 1;\n+  /* True if an error has already been reported for this token, such as a\n+     CPP_NAME token that is not a keyword (i.e., for which KEYWORD is\n+     RID_MAX) iff this name was looked up and found to be ambiguous.  */\n+  BOOL_BITFIELD error_reported : 1;\n   /* True for a token that has been purged.  If a token is purged,\n      it is no longer a valid token and it should be considered\n      deleted.  */"}]}