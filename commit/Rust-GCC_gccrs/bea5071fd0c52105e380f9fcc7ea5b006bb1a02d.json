{"sha": "bea5071fd0c52105e380f9fcc7ea5b006bb1a02d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmVhNTA3MWZkMGM1MjEwNWUzODBmOWZjYzdlYTViMDA2YmIxYTAyZA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@libertysurf.fr", "date": "2005-05-23T07:09:03Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2005-05-23T07:09:03Z"}, "message": "sparc-protos.h (sparc_expand_move): New prototype.\n\n\t* config/sparc/sparc-protos.h (sparc_expand_move): New prototype.\n\t* config/sparc/sparc.c (sparc_expand_move): New function.\n\t(sparc_emit_set_const64): Rewrite assert condition on entry.\n\t(legitimate_constant_p) <CONST_VECTOR>: New case.\n\t(legitimize_pic_address): Use TARGET_ARCH64 to select the mode.\n\t* config/sparc/sparc.md (movqi, movhi, movsi, movdi, movV32,\n\tmovV64, movtf): Use nonimmediate_operand for the first operand.\n\tRewrite.  Only invoke sparc_expand_move.\n\t* config/sparc/predicates.md (input_operand): Reorder tests.\n\nFrom-SVN: r100077", "tree": {"sha": "66cae35e1944fd55e7eade3ccdbac890dd921cf7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/66cae35e1944fd55e7eade3ccdbac890dd921cf7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bea5071fd0c52105e380f9fcc7ea5b006bb1a02d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bea5071fd0c52105e380f9fcc7ea5b006bb1a02d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bea5071fd0c52105e380f9fcc7ea5b006bb1a02d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bea5071fd0c52105e380f9fcc7ea5b006bb1a02d/comments", "author": {"login": "ebotcazou", "id": 48091907, "node_id": "MDQ6VXNlcjQ4MDkxOTA3", "avatar_url": "https://avatars.githubusercontent.com/u/48091907?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ebotcazou", "html_url": "https://github.com/ebotcazou", "followers_url": "https://api.github.com/users/ebotcazou/followers", "following_url": "https://api.github.com/users/ebotcazou/following{/other_user}", "gists_url": "https://api.github.com/users/ebotcazou/gists{/gist_id}", "starred_url": "https://api.github.com/users/ebotcazou/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ebotcazou/subscriptions", "organizations_url": "https://api.github.com/users/ebotcazou/orgs", "repos_url": "https://api.github.com/users/ebotcazou/repos", "events_url": "https://api.github.com/users/ebotcazou/events{/privacy}", "received_events_url": "https://api.github.com/users/ebotcazou/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7c68fabb7882439c084429ed3b089c8669b15509", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c68fabb7882439c084429ed3b089c8669b15509", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c68fabb7882439c084429ed3b089c8669b15509"}], "stats": {"total": 616, "additions": 181, "deletions": 435}, "files": [{"sha": "c65fdfdbfef709d03ced993f9291fd73b2c11bae", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bea5071fd0c52105e380f9fcc7ea5b006bb1a02d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bea5071fd0c52105e380f9fcc7ea5b006bb1a02d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bea5071fd0c52105e380f9fcc7ea5b006bb1a02d", "patch": "@@ -1,3 +1,15 @@\n+2005-05-23  Eric Botcazou  <ebotcazou@libertysurf.fr>\n+\n+\t* config/sparc/sparc-protos.h (sparc_expand_move): New prototype.\n+\t* config/sparc/sparc.c (sparc_expand_move): New function.\n+\t(sparc_emit_set_const64): Rewrite assert condition on entry.\n+\t(legitimate_constant_p) <CONST_VECTOR>: New case.\n+\t(legitimize_pic_address): Use TARGET_ARCH64 to select the mode.\n+\t* config/sparc/sparc.md (movqi, movhi, movsi, movdi, movV32,\n+\tmovV64, movtf): Use nonimmediate_operand for the first operand.\n+\tRewrite.  Only invoke sparc_expand_move.\n+\t* config/sparc/predicates.md (input_operand): Reorder tests.\n+\n 2005-05-23  Jan Beulich  <jbeulich@novell.com>\n \n \t* gthr-posix.h (__gthread_recursive_mutex_init_function): Add"}, {"sha": "752286cb184d45374945f97a2b3c22b9a960b1fe", "filename": "gcc/config/sparc/predicates.md", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bea5071fd0c52105e380f9fcc7ea5b006bb1a02d/gcc%2Fconfig%2Fsparc%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bea5071fd0c52105e380f9fcc7ea5b006bb1a02d/gcc%2Fconfig%2Fsparc%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fpredicates.md?ref=bea5071fd0c52105e380f9fcc7ea5b006bb1a02d", "patch": "@@ -380,8 +380,10 @@\n   if (mode != VOIDmode && GET_MODE (op) != VOIDmode && mode != GET_MODE (op))\n     return false;\n \n+  mclass = GET_MODE_CLASS (mode);\n+\n   /* Allow any 1-instruction integer constant.  */\n-  if (GET_MODE_CLASS (mode) == MODE_INT\n+  if (mclass == MODE_INT\n       && (small_int_operand (op, mode) || const_high_operand (op, mode)))\n     return true;\n \n@@ -392,16 +394,14 @@\n       && (GET_CODE (op) == CONST_DOUBLE || GET_CODE (op) == CONST_INT))\n     return true;\n \n-  if (register_operand (op, mode))\n-    return true;\n-\n-  mclass = GET_MODE_CLASS (mode);\n   if ((mclass == MODE_FLOAT && GET_CODE (op) == CONST_DOUBLE)\n       || (mclass == MODE_VECTOR_INT && GET_CODE (op) == CONST_VECTOR))\n     return true;\n \n-  /* If this is a SUBREG, look inside so that we handle\n-     paradoxical ones.  */\n+  if (register_operand (op, mode))\n+    return true;\n+\n+  /* If this is a SUBREG, look inside so that we handle paradoxical ones.  */\n   if (GET_CODE (op) == SUBREG)\n     op = SUBREG_REG (op);\n "}, {"sha": "a29bd691509927166af2b3f94d0cde970b5351c0", "filename": "gcc/config/sparc/sparc-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bea5071fd0c52105e380f9fcc7ea5b006bb1a02d/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bea5071fd0c52105e380f9fcc7ea5b006bb1a02d/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h?ref=bea5071fd0c52105e380f9fcc7ea5b006bb1a02d", "patch": "@@ -74,6 +74,7 @@ extern rtx legitimize_pic_address (rtx, enum machine_mode, rtx);\n extern rtx legitimize_tls_address (rtx);\n extern rtx legitimize_address (rtx, rtx, enum machine_mode);\n extern void sparc_defer_case_vector (rtx, rtx, int);\n+extern bool sparc_expand_move (enum machine_mode, rtx *);\n extern void sparc_emit_set_const32 (rtx, rtx);\n extern void sparc_emit_set_const64 (rtx, rtx);\n extern void sparc_emit_set_symbolic_const64 (rtx, rtx, rtx);"}, {"sha": "af920b30734c1032c90caaf0aa660f254ec5ba2c", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 140, "deletions": 23, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bea5071fd0c52105e380f9fcc7ea5b006bb1a02d/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bea5071fd0c52105e380f9fcc7ea5b006bb1a02d/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=bea5071fd0c52105e380f9fcc7ea5b006bb1a02d", "patch": "@@ -801,9 +801,6 @@ v9_regcmp_p (enum rtx_code code)\n \t  || code == LE || code == GT);\n }\n \n-\f\n-/* Operand constraints.  */\n-\n /* Nonzero if OP is a floating point constant which can\n    be loaded into an integer register using a single\n    sethi instruction.  */\n@@ -877,9 +874,127 @@ tls_symbolic_operand (rtx op)\n     return 0;\n   return SYMBOL_REF_TLS_MODEL (op);\n }\n-\f\n-/* We know it can't be done in one insn when we get here,\n-   the movsi expander guarantees this.  */\n+\n+/* Expand a move instruction.  Return true if all work is done.  */\n+\n+bool\n+sparc_expand_move (enum machine_mode mode, rtx *operands)\n+{\n+  /* Handle sets of MEM first.  */\n+  if (GET_CODE (operands[0]) == MEM)\n+    {\n+      /* 0 is a register (or a pair of registers) on SPARC.  */\n+      if (register_or_zero_operand (operands[1], mode))\n+\treturn false;\n+\n+      if (!reload_in_progress)\n+\t{\n+\t  operands[0] = validize_mem (operands[0]);\n+\t  operands[1] = force_reg (mode, operands[1]);\n+\t}\n+    }\n+\n+  /* Fixup TLS cases.  */\n+  if (tls_symbolic_operand (operands [1]))\n+    operands[1] = legitimize_tls_address (operands[1]);\n+\n+  /* Fixup PIC cases.  */\n+  if (flag_pic && CONSTANT_P (operands[1]))\n+    {\n+      if (pic_address_needs_scratch (operands[1]))\n+\toperands[1] = legitimize_pic_address (operands[1], mode, 0);\n+\n+      if (GET_CODE (operands[1]) == LABEL_REF && mode == SImode)\n+\t{\n+\t  emit_insn (gen_movsi_pic_label_ref (operands[0], operands[1]));\n+\t  return true;\n+\t}\n+\n+      if (GET_CODE (operands[1]) == LABEL_REF && mode == DImode)\n+\t{\n+\t  gcc_assert (TARGET_ARCH64);\n+\t  emit_insn (gen_movdi_pic_label_ref (operands[0], operands[1]));\n+\t  return true;\n+\t}\n+\n+      if (symbolic_operand (operands[1], mode))\n+\t{\n+\t  operands[1] = legitimize_pic_address (operands[1],\n+\t\t\t\t\t\tmode,\n+\t\t\t\t\t\t(reload_in_progress ?\n+\t\t\t\t\t\t operands[0] :\n+\t\t\t\t\t\t NULL_RTX));\n+\t  return false;\n+\t}\n+    }\n+\n+  /* If we are trying to toss an integer constant into FP registers,\n+     or loading a FP or vector constant, force it into memory.  */\n+  if (CONSTANT_P (operands[1])\n+      && REG_P (operands[0])\n+      && (SPARC_FP_REG_P (REGNO (operands[0]))\n+\t  || SCALAR_FLOAT_MODE_P (mode)\n+\t  || VECTOR_MODE_P (mode)))\n+    {\n+      /* emit_group_store will send such bogosity to us when it is\n+         not storing directly into memory.  So fix this up to avoid\n+         crashes in output_constant_pool.  */\n+      if (operands [1] == const0_rtx)\n+\toperands[1] = CONST0_RTX (mode);\n+\n+      /* We can clear FP registers if TARGET_VIS, and always other regs.  */\n+      if ((TARGET_VIS || REGNO (operands[0]) < SPARC_FIRST_FP_REG)\n+\t  && const_zero_operand (operands[1], mode))\n+\treturn false;\n+\n+      if (REGNO (operands[0]) < SPARC_FIRST_FP_REG\n+\t  /* We are able to build any SF constant in integer registers\n+\t     with at most 2 instructions.  */\n+\t  && (mode == SFmode\n+\t      /* And any DF constant in integer registers.  */\n+\t      || (mode == DFmode\n+\t\t  && (reload_completed || reload_in_progress))))\n+\treturn false;\n+\n+      operands[1] = force_const_mem (mode, operands[1]);\n+      if (!reload_in_progress)\n+\toperands[1] = validize_mem (operands[1]);\n+      return false;\n+    }\n+\n+  /* Accept non-constants and valid constants unmodified.  */\n+  if (!CONSTANT_P (operands[1])\n+      || GET_CODE (operands[1]) == HIGH\n+      || input_operand (operands[1], mode))\n+    return false;\n+\n+  switch (mode)\n+    {\n+    case QImode:\n+      /* All QImode constants require only one insn, so proceed.  */\n+      break;\n+\n+    case HImode:\n+    case SImode:\n+      sparc_emit_set_const32 (operands[0], operands[1]);\n+      return true;\n+\n+    case DImode:\n+      /* input_operand should have filtered out 32-bit mode.  */\n+      sparc_emit_set_const64 (operands[0], operands[1]);\n+      return true;\n+    \n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  return false;\n+}\n+\n+/* Load OP1, a 32-bit constant, into OP0, a register.\n+   We know it can't be done in one insn when we get\n+   here, the move expander guarantees this.  */\n+\n void\n sparc_emit_set_const32 (rtx op0, rtx op1)\n {\n@@ -918,13 +1033,13 @@ sparc_emit_set_const32 (rtx op0, rtx op1)\n     }\n }\n \n-\f\n /* Load OP1, a symbolic 64-bit constant, into OP0, a DImode register.\n    If TEMP is nonzero, we are forbidden to use any other scratch\n    registers.  Otherwise, we are allowed to generate them as needed.\n \n    Note that TEMP may have TImode if the code model is TARGET_CM_MEDANY\n    or TARGET_CM_EMBMEDANY (see the reload_indi and reload_outdi patterns).  */\n+\n void\n sparc_emit_set_symbolic_const64 (rtx op0, rtx op1, rtx temp)\n {\n@@ -1488,14 +1603,9 @@ sparc_emit_set_const64 (rtx op0, rtx op1)\n   rtx temp = 0;\n \n   /* Sanity check that we know what we are working with.  */\n-  gcc_assert (TARGET_ARCH64);\n-\n-  if (GET_CODE (op0) != SUBREG)\n-    {\n-      gcc_assert (GET_CODE (op0) == REG\n-\t\t  && (REGNO (op0) < SPARC_FIRST_FP_REG\n-\t      \t      || REGNO (op0) > SPARC_LAST_V9_FP_REG));\n-    }\n+  gcc_assert (TARGET_ARCH64\n+\t      && (GET_CODE (op0) == SUBREG\n+\t\t  || (REG_P (op0) && ! SPARC_FP_REG_P (REGNO (op0)))));\n \n   if (reload_in_progress || reload_completed)\n     temp = op0;\n@@ -2626,9 +2736,16 @@ legitimate_constant_p (rtx x)\n       /* Floating point constants are generally not ok.\n \t The only exception is 0.0 in VIS.  */\n       if (TARGET_VIS\n-\t  && (GET_MODE (x) == SFmode\n-\t      || GET_MODE (x) == DFmode\n-\t      || GET_MODE (x) == TFmode)\n+\t  && SCALAR_FLOAT_MODE_P (GET_MODE (x))\n+\t  && const_zero_operand (x, GET_MODE (x)))\n+\treturn true;\n+\n+      return false;\n+\n+    case CONST_VECTOR:\n+      /* Vector constants are generally not ok.\n+\t The only exception is 0 in VIS.  */\n+      if (TARGET_VIS\n \t  && const_zero_operand (x, GET_MODE (x)))\n \treturn true;\n \n@@ -3007,15 +3124,15 @@ legitimize_pic_address (rtx orig, enum machine_mode mode ATTRIBUTE_UNUSED,\n \t     won't get confused into thinking that these two instructions\n \t     are loading in the true address of the symbol.  If in the\n \t     future a PIC rtx exists, that should be used instead.  */\n-\t  if (Pmode == SImode)\n+\t  if (TARGET_ARCH64)\n \t    {\n-\t      emit_insn (gen_movsi_high_pic (temp_reg, orig));\n-\t      emit_insn (gen_movsi_lo_sum_pic (temp_reg, temp_reg, orig));\n+\t      emit_insn (gen_movdi_high_pic (temp_reg, orig));\n+\t      emit_insn (gen_movdi_lo_sum_pic (temp_reg, temp_reg, orig));\n \t    }\n \t  else\n \t    {\n-\t      emit_insn (gen_movdi_high_pic (temp_reg, orig));\n-\t      emit_insn (gen_movdi_lo_sum_pic (temp_reg, temp_reg, orig));\n+\t      emit_insn (gen_movsi_high_pic (temp_reg, orig));\n+\t      emit_insn (gen_movsi_lo_sum_pic (temp_reg, temp_reg, orig));\n \t    }\n \t  address = temp_reg;\n \t}"}, {"sha": "589edb612a4e4a34e4c46b84f5098f85c105a073", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 21, "deletions": 405, "changes": 426, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bea5071fd0c52105e380f9fcc7ea5b006bb1a02d/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bea5071fd0c52105e380f9fcc7ea5b006bb1a02d/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=bea5071fd0c52105e380f9fcc7ea5b006bb1a02d", "patch": "@@ -1723,54 +1723,12 @@\n ;; Integer move instructions\n \n (define_expand \"movqi\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"\")\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"\")\n \t(match_operand:QI 1 \"general_operand\" \"\"))]\n   \"\"\n {\n-  /* Working with CONST_INTs is easier, so convert\n-     a double if needed.  */\n-  if (GET_CODE (operands[1]) == CONST_DOUBLE)\n-    operands[1] = gen_int_mode (CONST_DOUBLE_LOW (operands[1]), QImode);\n-\n-  /* Handle sets of MEM first.  */\n-  if (GET_CODE (operands[0]) == MEM)\n-    {\n-      if (register_or_zero_operand (operands[1], QImode))\n-\tgoto movqi_is_ok;\n-\n-      if (! reload_in_progress)\n-\t{\n-\t  operands[0] = validize_mem (operands[0]);\n-\t  operands[1] = force_reg (QImode, operands[1]);\n-\t}\n-    }\n-\n-  /* Fixup TLS cases.  */\n-  if (tls_symbolic_operand (operands [1]))\n-    operands[1] = legitimize_tls_address (operands[1]);\n-\n-  /* Fixup PIC cases.  */\n-  if (flag_pic)\n-    {\n-      if (CONSTANT_P (operands[1])\n-\t  && pic_address_needs_scratch (operands[1]))\n-\toperands[1] = legitimize_pic_address (operands[1], QImode, 0);\n-\n-      if (symbolic_operand (operands[1], QImode))\n-\t{\n-\t  operands[1] = legitimize_pic_address (operands[1],\n-\t\t\t\t\t\tQImode,\n-\t\t\t\t\t\t(reload_in_progress ?\n-\t\t\t\t\t\t operands[0] :\n-\t\t\t\t\t\t NULL_RTX));\n-\t  goto movqi_is_ok;\n-\t}\n-    }\n-\n-  /* All QI constants require only one insn, so proceed.  */\n-\n- movqi_is_ok:\n-  ;\n+  if (sparc_expand_move (QImode, operands))\n+    DONE;\n })\n \n (define_insn \"*movqi_insn\"\n@@ -1786,62 +1744,12 @@\n    (set_attr \"us3load_type\" \"*,3cycle,*\")])\n \n (define_expand \"movhi\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"\")\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"\")\n \t(match_operand:HI 1 \"general_operand\" \"\"))]\n   \"\"\n {\n-  /* Working with CONST_INTs is easier, so convert\n-     a double if needed.  */\n-  if (GET_CODE (operands[1]) == CONST_DOUBLE)\n-    operands[1] = gen_int_mode (CONST_DOUBLE_LOW (operands[1]), HImode);\n-\n-  /* Handle sets of MEM first.  */\n-  if (GET_CODE (operands[0]) == MEM)\n-    {\n-      if (register_or_zero_operand (operands[1], HImode))\n-\tgoto movhi_is_ok;\n-\n-      if (! reload_in_progress)\n-\t{\n-\t  operands[0] = validize_mem (operands[0]);\n-\t  operands[1] = force_reg (HImode, operands[1]);\n-\t}\n-    }\n-\n-  /* Fixup TLS cases.  */\n-  if (tls_symbolic_operand (operands [1]))\n-    operands[1] = legitimize_tls_address (operands[1]);\n-\n-  /* Fixup PIC cases.  */\n-  if (flag_pic)\n-    {\n-      if (CONSTANT_P (operands[1])\n-\t  && pic_address_needs_scratch (operands[1]))\n-\toperands[1] = legitimize_pic_address (operands[1], HImode, 0);\n-\n-      if (symbolic_operand (operands[1], HImode))\n-\t{\n-\t  operands[1] = legitimize_pic_address (operands[1],\n-\t\t\t\t\t\tHImode,\n-\t\t\t\t\t\t(reload_in_progress ?\n-\t\t\t\t\t\t operands[0] :\n-\t\t\t\t\t\t NULL_RTX));\n-\t  goto movhi_is_ok;\n-\t}\n-    }\n-\n-  /* This makes sure we will not get rematched due to splittage.  */\n-  if (! CONSTANT_P (operands[1]) || input_operand (operands[1], HImode))\n-    ;\n-  else if (GET_CODE (operands[1]) != HIGH\n-\t   && GET_CODE (operands[1]) != LO_SUM)\n-    {\n-      sparc_emit_set_const32 (operands[0], operands[1]);\n-      DONE;\n-    }\n-\n- movhi_is_ok:\n-  ;\n+  if (sparc_expand_move (HImode, operands))\n+    DONE;\n })\n \n (define_insn \"*movhi_insn\"\n@@ -1866,77 +1774,12 @@\n   \"or\\t%1, %2, %0\")\n \n (define_expand \"movsi\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"\")\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"\")\n \t(match_operand:SI 1 \"general_operand\" \"\"))]\n   \"\"\n {\n-  /* Working with CONST_INTs is easier, so convert\n-     a double if needed.  */\n-  if (GET_CODE (operands[1]) == CONST_DOUBLE)\n-    operands[1] = gen_int_mode (CONST_DOUBLE_LOW (operands[1]), SImode);\n-\n-  /* Handle sets of MEM first.  */\n-  if (GET_CODE (operands[0]) == MEM)\n-    {\n-      if (register_or_zero_operand (operands[1], SImode))\n-\tgoto movsi_is_ok;\n-\n-      if (! reload_in_progress)\n-\t{\n-\t  operands[0] = validize_mem (operands[0]);\n-\t  operands[1] = force_reg (SImode, operands[1]);\n-\t}\n-    }\n-\n-  /* Fixup TLS cases.  */\n-  if (tls_symbolic_operand (operands [1]))\n-    operands[1] = legitimize_tls_address (operands[1]);\n-\n-  /* Fixup PIC cases.  */\n-  if (flag_pic)\n-    {\n-      if (CONSTANT_P (operands[1])\n-\t  && pic_address_needs_scratch (operands[1]))\n-\toperands[1] = legitimize_pic_address (operands[1], SImode, 0);\n-\n-      if (GET_CODE (operands[1]) == LABEL_REF)\n-\t{\n-\t  emit_insn (gen_movsi_pic_label_ref (operands[0], operands[1]));\n-\t  DONE;\n-\t}\n-\n-      if (symbolic_operand (operands[1], SImode))\n-\t{\n-\t  operands[1] = legitimize_pic_address (operands[1],\n-\t\t\t\t\t\tSImode,\n-\t\t\t\t\t\t(reload_in_progress ?\n-\t\t\t\t\t\t operands[0] :\n-\t\t\t\t\t\t NULL_RTX));\n-\t  goto movsi_is_ok;\n-\t}\n-    }\n-\n-  /* If we are trying to toss an integer constant into the\n-     FPU registers, force it into memory.  */\n-  if (GET_CODE (operands[0]) == REG\n-      && REGNO (operands[0]) >= SPARC_FIRST_FP_REG\n-      && REGNO (operands[0]) <= SPARC_LAST_V9_FP_REG\n-      && CONSTANT_P (operands[1]))\n-    operands[1] = validize_mem (force_const_mem (GET_MODE (operands[0]),\n-\t\t\t\t\t\t operands[1]));\n-\n-  /* This makes sure we will not get rematched due to splittage.  */\n-  if (! CONSTANT_P (operands[1]) || input_operand (operands[1], SImode))\n-    ;\n-  else if (GET_CODE (operands[1]) != HIGH\n-\t   && GET_CODE (operands[1]) != LO_SUM)\n-    {\n-      sparc_emit_set_const32 (operands[0], operands[1]);\n-      DONE;\n-    }\n-\n- movsi_is_ok:\n-  ;\n+  if (sparc_expand_move (SImode, operands))\n+    DONE;\n })\n \n (define_insn \"*movsi_insn\"\n@@ -2025,85 +1868,12 @@\n   \"or\\t%1, %%lo(%a3-(%a2-.)), %0\")\n \n (define_expand \"movdi\"\n-  [(set (match_operand:DI 0 \"general_operand\" \"\")\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n \t(match_operand:DI 1 \"general_operand\" \"\"))]\n   \"\"\n {\n-  /* Working with CONST_INTs is easier, so convert\n-     a double if needed.  */\n-  if (GET_CODE (operands[1]) == CONST_DOUBLE\n-#if HOST_BITS_PER_WIDE_INT == 32\n-      && ((CONST_DOUBLE_HIGH (operands[1]) == 0\n-\t   && (CONST_DOUBLE_LOW (operands[1]) & 0x80000000) == 0)\n-\t  || (CONST_DOUBLE_HIGH (operands[1]) == (HOST_WIDE_INT) 0xffffffff\n-\t      && (CONST_DOUBLE_LOW (operands[1]) & 0x80000000) != 0))\n-#endif\n-      )\n-    operands[1] = gen_int_mode (CONST_DOUBLE_LOW (operands[1]), DImode);\n-\n-  /* Handle MEM cases first.  */\n-  if (GET_CODE (operands[0]) == MEM)\n-    {\n-      if (register_or_zero_operand (operands[1], DImode))\n-        goto movdi_is_ok;\n-\n-      if (! reload_in_progress)\n-\t{\n-\t  operands[0] = validize_mem (operands[0]);\n-\t  operands[1] = force_reg (DImode, operands[1]);\n-\t}\n-    }\n-\n-  /* Fixup TLS cases.  */\n-  if (tls_symbolic_operand (operands [1]))\n-    operands[1] = legitimize_tls_address (operands[1]);\n-\n-  if (flag_pic)\n-    {\n-      if (CONSTANT_P (operands[1])\n-\t  && pic_address_needs_scratch (operands[1]))\n-\toperands[1] = legitimize_pic_address (operands[1], DImode, 0);\n-\n-      if (GET_CODE (operands[1]) == LABEL_REF)\n-        {\n-          gcc_assert (TARGET_ARCH64);\n-          emit_insn (gen_movdi_pic_label_ref (operands[0], operands[1]));\n-          DONE;\n-        }\n-\n-      if (symbolic_operand (operands[1], DImode))\n-\t{\n-\t  operands[1] = legitimize_pic_address (operands[1],\n-\t\t\t\t\t\tDImode,\n-\t\t\t\t\t\t(reload_in_progress ?\n-\t\t\t\t\t\t operands[0] :\n-\t\t\t\t\t\t NULL_RTX));\n-\t  goto movdi_is_ok;\n-\t}\n-    }\n-\n-  /* If we are trying to toss an integer constant into the\n-     FPU registers, force it into memory.  */\n-  if (GET_CODE (operands[0]) == REG\n-      && REGNO (operands[0]) >= SPARC_FIRST_FP_REG\n-      && REGNO (operands[0]) <= SPARC_LAST_V9_FP_REG\n-      && CONSTANT_P (operands[1]))\n-    operands[1] = validize_mem (force_const_mem (GET_MODE (operands[0]),\n-\t\t\t\t\t\t operands[1]));\n-\n-  /* This makes sure we will not get rematched due to splittage.  */\n-  if (! CONSTANT_P (operands[1]) || input_operand (operands[1], DImode))\n-    ;\n-  else if (TARGET_ARCH64\n-           && GET_CODE (operands[1]) != HIGH\n-           && GET_CODE (operands[1]) != LO_SUM)\n-    {\n-      sparc_emit_set_const64 (operands[0], operands[1]);\n-      DONE;\n-    }\n-\n- movdi_is_ok:\n-  ;\n+  if (sparc_expand_move (DImode, operands))\n+    DONE;\n })\n \n ;; Be careful, fmovd does not exist when !v9.\n@@ -2552,65 +2322,12 @@\n \n ;; Yes, you guessed it right, the former movsf expander.\n (define_expand \"mov<V32:mode>\"\n-  [(set (match_operand:V32 0 \"general_operand\" \"\")\n+  [(set (match_operand:V32 0 \"nonimmediate_operand\" \"\")\n \t(match_operand:V32 1 \"general_operand\" \"\"))]\n   \"<V32:MODE>mode == SFmode || TARGET_VIS\"\n {\n-  /* Force constants into memory.  */\n-  if (GET_CODE (operands[0]) == REG && CONSTANT_P (operands[1]))\n-    {\n-      /* emit_group_store will send such bogosity to us when it is\n-         not storing directly into memory.  So fix this up to avoid\n-         crashes in output_constant_pool.  */\n-      if (operands [1] == const0_rtx)\n-        operands[1] = CONST0_RTX (<V32:MODE>mode);\n-\n-      if ((TARGET_VIS || REGNO (operands[0]) < 32)\n-\t  && const_zero_operand (operands[1], <V32:MODE>mode))\n-\tgoto movsf_is_ok;\n-\n-      /* We are able to build any SF constant in integer registers\n-\t with at most 2 instructions.  */\n-      if (REGNO (operands[0]) < 32\n-\t  && <V32:MODE>mode == SFmode)\n-\tgoto movsf_is_ok;\n-\n-      operands[1] = validize_mem (force_const_mem (GET_MODE (operands[0]),\n-                                                   operands[1]));\n-    }\n-\n-  /* Handle sets of MEM first.  */\n-  if (GET_CODE (operands[0]) == MEM)\n-    {\n-      if (register_or_zero_operand (operands[1], <V32:MODE>mode))\n-\tgoto movsf_is_ok;\n-\n-      if (! reload_in_progress)\n-\t{\n-\t  operands[0] = validize_mem (operands[0]);\n-\t  operands[1] = force_reg (<V32:MODE>mode, operands[1]);\n-\t}\n-    }\n-\n-  /* Fixup PIC cases.  */\n-  if (flag_pic)\n-    {\n-      if (CONSTANT_P (operands[1])\n-\t  && pic_address_needs_scratch (operands[1]))\n-\toperands[1] = legitimize_pic_address (operands[1], <V32:MODE>mode, 0);\n-\n-      if (symbolic_operand (operands[1], <V32:MODE>mode))\n-\t{\n-\t  operands[1] = legitimize_pic_address (operands[1],\n-\t\t\t\t\t\t<V32:MODE>mode,\n-\t\t\t\t\t\t(reload_in_progress ?\n-\t\t\t\t\t\t operands[0] :\n-\t\t\t\t\t\t NULL_RTX));\n-\t}\n-    }\n-\n- movsf_is_ok:\n-  ;\n+  if (sparc_expand_move (<V32:MODE>mode, operands))\n+    DONE;\n })\n \n (define_insn \"*movsf_insn\"\n@@ -2741,65 +2458,12 @@\n \n ;; Yes, you again guessed it right, the former movdf expander.\n (define_expand \"mov<V64:mode>\"\n-  [(set (match_operand:V64 0 \"general_operand\" \"\")\n+  [(set (match_operand:V64 0 \"nonimmediate_operand\" \"\")\n \t(match_operand:V64 1 \"general_operand\" \"\"))]\n   \"<V64:MODE>mode == DFmode || TARGET_VIS\"\n {\n-  /* Force constants into memory.  */\n-  if (GET_CODE (operands[0]) == REG && CONSTANT_P (operands[1]))\n-    {\n-      /* emit_group_store will send such bogosity to us when it is\n-         not storing directly into memory.  So fix this up to avoid\n-         crashes in output_constant_pool.  */\n-      if (operands [1] == const0_rtx)\n-        operands[1] = CONST0_RTX (<V64:MODE>mode);\n-\n-      if ((TARGET_VIS || REGNO (operands[0]) < 32)\n-\t  && const_zero_operand (operands[1], <V64:MODE>mode))\n-\tgoto movdf_is_ok;\n-\n-      /* We are able to build any DF constant in integer registers.  */\n-      if (REGNO (operands[0]) < 32\n-\t  && <V64:MODE>mode == DFmode\n-\t  && (reload_completed || reload_in_progress))\n-\tgoto movdf_is_ok;\n-\n-      operands[1] = validize_mem (force_const_mem (GET_MODE (operands[0]),\n-                                                   operands[1]));\n-    }\n-\n-  /* Handle MEM cases first.  */\n-  if (GET_CODE (operands[0]) == MEM)\n-    {\n-      if (register_or_zero_operand (operands[1], <V64:MODE>mode))\n-\tgoto movdf_is_ok;\n-\n-      if (! reload_in_progress)\n-\t{\n-\t  operands[0] = validize_mem (operands[0]);\n-\t  operands[1] = force_reg (<V64:MODE>mode, operands[1]);\n-\t}\n-    }\n-\n-  /* Fixup PIC cases.  */\n-  if (flag_pic)\n-    {\n-      if (CONSTANT_P (operands[1])\n-\t  && pic_address_needs_scratch (operands[1]))\n-\toperands[1] = legitimize_pic_address (operands[1], <V64:MODE>mode, 0);\n-\n-      if (symbolic_operand (operands[1], <V64:MODE>mode))\n-\t{\n-\t  operands[1] = legitimize_pic_address (operands[1],\n-\t\t\t\t\t\t<V64:MODE>mode,\n-\t\t\t\t\t\t(reload_in_progress ?\n-\t\t\t\t\t\t operands[0] :\n-\t\t\t\t\t\t NULL_RTX));\n-\t}\n-    }\n-\n- movdf_is_ok:\n-  ;\n+  if (sparc_expand_move (<V64:MODE>mode, operands))\n+    DONE;\n })\n \n ;; Be careful, fmovd does not exist when !v9.\n@@ -3137,60 +2801,12 @@\n })\n \n (define_expand \"movtf\"\n-  [(set (match_operand:TF 0 \"general_operand\" \"\")\n+  [(set (match_operand:TF 0 \"nonimmediate_operand\" \"\")\n \t(match_operand:TF 1 \"general_operand\" \"\"))]\n   \"\"\n {\n-  /* Force TFmode constants into memory.  */\n-  if (GET_CODE (operands[0]) == REG\n-      && CONSTANT_P (operands[1]))\n-    {\n-      /* emit_group_store will send such bogosity to us when it is\n-         not storing directly into memory.  So fix this up to avoid\n-         crashes in output_constant_pool.  */\n-      if (operands [1] == const0_rtx)\n-        operands[1] = CONST0_RTX (TFmode);\n-\n-      if (TARGET_VIS && const_zero_operand (operands[1], TFmode))\n-\tgoto movtf_is_ok;\n-\n-      operands[1] = validize_mem (force_const_mem (GET_MODE (operands[0]),\n-                                                   operands[1]));\n-    }\n-\n-  /* Handle MEM cases first, note that only v9 guarantees\n-     full 16-byte alignment for quads.  */\n-  if (GET_CODE (operands[0]) == MEM)\n-    {\n-      if (register_or_zero_operand (operands[1], TFmode))\n-\tgoto movtf_is_ok;\n-\n-      if (! reload_in_progress)\n-\t{\n-\t  operands[0] = validize_mem (operands[0]);\n-\t  operands[1] = force_reg (TFmode, operands[1]);\n-\t}\n-    }\n-\n-  /* Fixup PIC cases.  */\n-  if (flag_pic)\n-    {\n-      if (CONSTANT_P (operands[1])\n-\t  && pic_address_needs_scratch (operands[1]))\n-\toperands[1] = legitimize_pic_address (operands[1], TFmode, 0);\n-\n-      if (symbolic_operand (operands[1], TFmode))\n-\t{\n-\t  operands[1] = legitimize_pic_address (operands[1],\n-\t\t\t\t\t\tTFmode,\n-\t\t\t\t\t\t(reload_in_progress ?\n-\t\t\t\t\t\t operands[0] :\n-\t\t\t\t\t\t NULL_RTX));\n-\t}\n-    }\n-\n- movtf_is_ok:\n-  ;\n+  if (sparc_expand_move (TFmode, operands))\n+    DONE;\n })\n \n (define_insn \"*movtf_insn_sp32\""}]}