{"sha": "3ea36418803795d68331e688cf851eeb22bd3bf6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2VhMzY0MTg4MDM3OTVkNjgzMzFlNjg4Y2Y4NTFlZWIyMmJkM2JmNg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2015-01-20T20:39:52Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2015-01-20T20:39:52Z"}, "message": "re PR sanitizer/64632 (runtime error: member call on address 0x0000004318a8 which does not point to an object of type 'ios_base')\n\n\tPR sanitizer/64632\n\t* ubsan/ubsan_type_hash.cc: Cherry pick upstream r224972.\n\n\t* g++.dg/ubsan/pr64632.C: New test.\n\nFrom-SVN: r219912", "tree": {"sha": "62486ce633b46c7bf8945dc5e7352f4f545b2b55", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/62486ce633b46c7bf8945dc5e7352f4f545b2b55"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3ea36418803795d68331e688cf851eeb22bd3bf6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ea36418803795d68331e688cf851eeb22bd3bf6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ea36418803795d68331e688cf851eeb22bd3bf6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ea36418803795d68331e688cf851eeb22bd3bf6/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "befb1f36a71758c5fd645b1f08b8886e7f5808da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/befb1f36a71758c5fd645b1f08b8886e7f5808da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/befb1f36a71758c5fd645b1f08b8886e7f5808da"}], "stats": {"total": 78, "additions": 52, "deletions": 26}, "files": [{"sha": "ee46288d3736eaec9424b750dbfaf812b1c6e1a6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ea36418803795d68331e688cf851eeb22bd3bf6/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ea36418803795d68331e688cf851eeb22bd3bf6/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3ea36418803795d68331e688cf851eeb22bd3bf6", "patch": "@@ -1,5 +1,8 @@\n 2015-01-20  Jakub Jelinek  <jakub@redhat.com>\n \n+\tPR sanitizer/64632\n+\t* g++.dg/ubsan/pr64632.C: New test.\n+\n \tPR debug/64663\n \t* gcc.dg/pr64663.c: New test.\n "}, {"sha": "0d2a7aa9aef9b206403bb6413916d58b5ada01ee", "filename": "gcc/testsuite/g++.dg/ubsan/pr64632.C", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ea36418803795d68331e688cf851eeb22bd3bf6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fubsan%2Fpr64632.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ea36418803795d68331e688cf851eeb22bd3bf6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fubsan%2Fpr64632.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fubsan%2Fpr64632.C?ref=3ea36418803795d68331e688cf851eeb22bd3bf6", "patch": "@@ -0,0 +1,23 @@\n+// PR sanitizer/64632\n+// { dg-do run }\n+// { dg-options \"-fsanitize=vptr -fno-sanitize-recover=vptr\" }\n+\n+struct S\n+{\n+  S () : a(0) {}\n+  int a;\n+  int f () { return a; }\n+  virtual int v () { return 0; }\n+};\n+\n+struct X : virtual S\n+{\n+  int v () { return 2; }\n+};\n+\n+int\n+main ()\n+{\n+  X x;\n+  return x.f ();\n+}"}, {"sha": "cb0f98c7e834d0819fff255a03793a2ef9ad7e35", "filename": "libsanitizer/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ea36418803795d68331e688cf851eeb22bd3bf6/libsanitizer%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ea36418803795d68331e688cf851eeb22bd3bf6/libsanitizer%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2FChangeLog?ref=3ea36418803795d68331e688cf851eeb22bd3bf6", "patch": "@@ -1,3 +1,8 @@\n+2015-01-20  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR sanitizer/64632\n+\t* ubsan/ubsan_type_hash.cc: Cherry pick upstream r224972.\n+\n 2015-01-19  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR sanitizer/64435"}, {"sha": "d01009426db0632e6427ac24dbcd96bd7bdfa851", "filename": "libsanitizer/ubsan/ubsan_type_hash.cc", "status": "modified", "additions": 21, "deletions": 26, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ea36418803795d68331e688cf851eeb22bd3bf6/libsanitizer%2Fubsan%2Fubsan_type_hash.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ea36418803795d68331e688cf851eeb22bd3bf6/libsanitizer%2Fubsan%2Fubsan_type_hash.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_type_hash.cc?ref=3ea36418803795d68331e688cf851eeb22bd3bf6", "patch": "@@ -113,16 +113,15 @@ __ubsan::__ubsan_vptr_type_cache[__ubsan::VptrTypeCacheSize];\n \n /// \\brief Determine whether \\p Derived has a \\p Base base class subobject at\n /// offset \\p Offset.\n-static bool isDerivedFromAtOffset(sptr Object,\n-                                  const abi::__class_type_info *Derived,\n+static bool isDerivedFromAtOffset(const abi::__class_type_info *Derived,\n                                   const abi::__class_type_info *Base,\n                                   sptr Offset) {\n   if (Derived->__type_name == Base->__type_name)\n     return Offset == 0;\n \n   if (const abi::__si_class_type_info *SI =\n         dynamic_cast<const abi::__si_class_type_info*>(Derived))\n-    return isDerivedFromAtOffset(Object, SI->__base_type, Base, Offset);\n+    return isDerivedFromAtOffset(SI->__base_type, Base, Offset);\n \n   const abi::__vmi_class_type_info *VTI =\n     dynamic_cast<const abi::__vmi_class_type_info*>(Derived);\n@@ -137,13 +136,13 @@ static bool isDerivedFromAtOffset(sptr Object,\n     sptr OffsetHere = VTI->base_info[base].__offset_flags >>\n                       abi::__base_class_type_info::__offset_shift;\n     if (VTI->base_info[base].__offset_flags &\n-          abi::__base_class_type_info::__virtual_mask) {\n-      sptr VTable = *reinterpret_cast<const sptr *>(Object);\n-      OffsetHere = *reinterpret_cast<const sptr *>(VTable + OffsetHere);\n-    }\n-    if (isDerivedFromAtOffset(Object + OffsetHere,\n-                              VTI->base_info[base].__base_type, Base,\n-                              Offset - OffsetHere))\n+          abi::__base_class_type_info::__virtual_mask)\n+      // For now, just punt on virtual bases and say 'yes'.\n+      // FIXME: OffsetHere is the offset in the vtable of the virtual base\n+      //        offset. Read the vbase offset out of the vtable and use it.\n+      return true;\n+    if (isDerivedFromAtOffset(VTI->base_info[base].__base_type,\n+                              Base, Offset - OffsetHere))\n       return true;\n   }\n \n@@ -152,15 +151,14 @@ static bool isDerivedFromAtOffset(sptr Object,\n \n /// \\brief Find the derived-most dynamic base class of \\p Derived at offset\n /// \\p Offset.\n-static const abi::__class_type_info *\n-findBaseAtOffset(sptr Object, const abi::__class_type_info *Derived,\n-                 sptr Offset) {\n+static const abi::__class_type_info *findBaseAtOffset(\n+    const abi::__class_type_info *Derived, sptr Offset) {\n   if (!Offset)\n     return Derived;\n \n   if (const abi::__si_class_type_info *SI =\n         dynamic_cast<const abi::__si_class_type_info*>(Derived))\n-    return findBaseAtOffset(Object, SI->__base_type, Offset);\n+    return findBaseAtOffset(SI->__base_type, Offset);\n \n   const abi::__vmi_class_type_info *VTI =\n     dynamic_cast<const abi::__vmi_class_type_info*>(Derived);\n@@ -172,13 +170,12 @@ findBaseAtOffset(sptr Object, const abi::__class_type_info *Derived,\n     sptr OffsetHere = VTI->base_info[base].__offset_flags >>\n                       abi::__base_class_type_info::__offset_shift;\n     if (VTI->base_info[base].__offset_flags &\n-          abi::__base_class_type_info::__virtual_mask) {\n-      sptr VTable = *reinterpret_cast<const sptr *>(Object);\n-      OffsetHere = *reinterpret_cast<const sptr *>(VTable + OffsetHere);\n-    }\n-    if (const abi::__class_type_info *Base = findBaseAtOffset(\n-            Object + OffsetHere, VTI->base_info[base].__base_type,\n-            Offset - OffsetHere))\n+          abi::__base_class_type_info::__virtual_mask)\n+      // FIXME: Can't handle virtual bases yet.\n+      continue;\n+    if (const abi::__class_type_info *Base =\n+          findBaseAtOffset(VTI->base_info[base].__base_type,\n+                           Offset - OffsetHere))\n       return Base;\n   }\n \n@@ -230,8 +227,7 @@ bool __ubsan::checkDynamicType(void *Object, void *Type, HashValue Hash) {\n     return false;\n \n   abi::__class_type_info *Base = (abi::__class_type_info*)Type;\n-  if (!isDerivedFromAtOffset(reinterpret_cast<sptr>(Object), Derived, Base,\n-                             -Vtable->Offset))\n+  if (!isDerivedFromAtOffset(Derived, Base, -Vtable->Offset))\n     return false;\n \n   // Success. Cache this result.\n@@ -245,9 +241,8 @@ __ubsan::DynamicTypeInfo __ubsan::getDynamicTypeInfo(void *Object) {\n   if (!Vtable)\n     return DynamicTypeInfo(0, 0, 0);\n   const abi::__class_type_info *ObjectType = findBaseAtOffset(\n-      reinterpret_cast<sptr>(Object),\n-      static_cast<const abi::__class_type_info *>(Vtable->TypeInfo),\n-      -Vtable->Offset);\n+    static_cast<const abi::__class_type_info*>(Vtable->TypeInfo),\n+    -Vtable->Offset);\n   return DynamicTypeInfo(Vtable->TypeInfo->__type_name, -Vtable->Offset,\n                          ObjectType ? ObjectType->__type_name : \"<unknown>\");\n }"}]}