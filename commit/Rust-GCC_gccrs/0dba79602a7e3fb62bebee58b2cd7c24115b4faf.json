{"sha": "0dba79602a7e3fb62bebee58b2cd7c24115b4faf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGRiYTc5NjAyYTdlM2ZiNjJiZWJlZTU4YjJjZDdjMjQxMTViNGZhZg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2016-12-21T22:15:59Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2016-12-21T22:15:59Z"}, "message": "re PR bootstrap/78817 (stage2 bootstrap failure in vec.h:1613:5: error: argument 1 null where non-null expected after r243661)\n\n\tPR bootstrap/78817\n\t* tree-pass.h (make_pass_post_ipa_warn): Declare.\n\t* builtins.c (validate_arglist): Adjust get_nonnull_args call.\n\tCheck for NULL pointer argument to nonnull arg here.\n\t(validate_arg): Revert 2016-12-14 changes.\n\t* calls.h (get_nonnull_args): Remove declaration.\n\t* tree-ssa-ccp.c: Include diagnostic-core.h.\n\t(pass_data_post_ipa_warn): New variable.\n\t(pass_post_ipa_warn): New class.\n\t(pass_post_ipa_warn::execute): New method.\n\t(make_pass_post_ipa_warn): New function.\n\t* tree.h (get_nonnull_args): Declare.\n\t* tree.c (get_nonnull_args): New function.\n\t* calls.c (maybe_warn_null_arg): Removed.\n\t(maybe_warn_null_arg): Removed.\n\t(initialize_argument_information): Revert 2016-12-14 changes.\n\t* passes.def: Add pass_post_ipa_warn after first ccp after IPA.\nc-family/\n\t* c-common.c (struct nonnull_arg_ctx): New type.\n\t(check_function_nonnull): Return bool instead of void.  Use\n\tnonnull_arg_ctx as context rather than just location_t.\n\t(check_nonnull_arg): Adjust for the new context type, set\n\twarned_p to true if a warning has been diagnosed.\n\t(check_function_arguments): Return bool instead of void.\n\t* c-common.h (check_function_arguments): Adjust prototype.\nc/\n\t* c-typeck.c (build_function_call_vec): If check_function_arguments\n\treturns true, set TREE_NO_WARNING on CALL_EXPR.\ncp/\n\t* typeck.c (cp_build_function_call_vec): If check_function_arguments\n\treturns true, set TREE_NO_WARNING on CALL_EXPR.\n\t* call.c (build_over_call): Likewise.\n\nFrom-SVN: r243874", "tree": {"sha": "5cf6b631ea6cd0b3f5aca6c10361d66c4b8c572b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5cf6b631ea6cd0b3f5aca6c10361d66c4b8c572b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0dba79602a7e3fb62bebee58b2cd7c24115b4faf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0dba79602a7e3fb62bebee58b2cd7c24115b4faf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0dba79602a7e3fb62bebee58b2cd7c24115b4faf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0dba79602a7e3fb62bebee58b2cd7c24115b4faf/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "bc2a38dff859fcd1ec0aedd8c7d0fb748f2dbede", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc2a38dff859fcd1ec0aedd8c7d0fb748f2dbede", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc2a38dff859fcd1ec0aedd8c7d0fb748f2dbede"}], "stats": {"total": 388, "additions": 262, "deletions": 126}, "files": [{"sha": "e9ce90d530cce97d2e5235d1bf88f0fe0fe66461", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dba79602a7e3fb62bebee58b2cd7c24115b4faf/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dba79602a7e3fb62bebee58b2cd7c24115b4faf/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0dba79602a7e3fb62bebee58b2cd7c24115b4faf", "patch": "@@ -1,3 +1,23 @@\n+2016-12-21  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR bootstrap/78817\n+\t* tree-pass.h (make_pass_post_ipa_warn): Declare.\n+\t* builtins.c (validate_arglist): Adjust get_nonnull_args call.\n+\tCheck for NULL pointer argument to nonnull arg here.\n+\t(validate_arg): Revert 2016-12-14 changes.\n+\t* calls.h (get_nonnull_args): Remove declaration.\n+\t* tree-ssa-ccp.c: Include diagnostic-core.h.\n+\t(pass_data_post_ipa_warn): New variable.\n+\t(pass_post_ipa_warn): New class.\n+\t(pass_post_ipa_warn::execute): New method.\n+\t(make_pass_post_ipa_warn): New function.\n+\t* tree.h (get_nonnull_args): Declare.\n+\t* tree.c (get_nonnull_args): New function.\n+\t* calls.c (maybe_warn_null_arg): Removed.\n+\t(maybe_warn_null_arg): Removed.\n+\t(initialize_argument_information): Revert 2016-12-14 changes.\n+\t* passes.def: Add pass_post_ipa_warn after first ccp after IPA.\n+\n 2016-12-21  Pat Haugen  <pthaugen@us.ibm.com>\n \n \tPR rtl-optimization/11488"}, {"sha": "216d9261b237337867ccb06cdb0723e0b4469d83", "filename": "gcc/builtins.c", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dba79602a7e3fb62bebee58b2cd7c24115b4faf/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dba79602a7e3fb62bebee58b2cd7c24115b4faf/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=0dba79602a7e3fb62bebee58b2cd7c24115b4faf", "patch": "@@ -147,7 +147,7 @@ static tree fold_builtin_classify_type (tree);\n static tree fold_builtin_strlen (location_t, tree, tree);\n static tree fold_builtin_inf (location_t, tree, int);\n static tree rewrite_call_expr (location_t, tree, int, tree, int, ...);\n-static bool validate_arg (const_tree, enum tree_code code, bool = false);\n+static bool validate_arg (const_tree, enum tree_code code);\n static rtx expand_builtin_fabs (tree, rtx, rtx);\n static rtx expand_builtin_signbit (tree, rtx);\n static tree fold_builtin_memcmp (location_t, tree, tree, tree);\n@@ -1050,12 +1050,12 @@ validate_arglist (const_tree callexpr, ...)\n   init_const_call_expr_arg_iterator (callexpr, &iter);\n \n   /* Get a bitmap of pointer argument numbers declared attribute nonnull.  */\n-  bitmap argmap = get_nonnull_args (callexpr);\n+  tree fn = CALL_EXPR_FN (callexpr);\n+  bitmap argmap = get_nonnull_args (TREE_TYPE (TREE_TYPE (fn)));\n \n   for (unsigned argno = 1; ; ++argno)\n     {\n       code = (enum tree_code) va_arg (ap, int);\n-      bool nonnull = false;\n \n       switch (code)\n \t{\n@@ -1072,15 +1072,21 @@ validate_arglist (const_tree callexpr, ...)\n \t  /* The actual argument must be nonnull when either the whole\n \t     called function has been declared nonnull, or when the formal\n \t     argument corresponding to the actual argument has been.  */\n-\t  if (argmap)\n-\t    nonnull = bitmap_empty_p (argmap) || bitmap_bit_p (argmap, argno);\n+\t  if (argmap\n+\t      && (bitmap_empty_p (argmap) || bitmap_bit_p (argmap, argno)))\n+\t    {\n+\t      arg = next_const_call_expr_arg (&iter);\n+\t      if (!validate_arg (arg, code) || integer_zerop (arg))\n+\t\tgoto end;\n+\t      break;\n+\t    }\n \t  /* FALLTHRU */\n \tdefault:\n \t  /* If no parameters remain or the parameter's code does not\n \t     match the specified code, return false.  Otherwise continue\n \t     checking any remaining arguments.  */\n \t  arg = next_const_call_expr_arg (&iter);\n-\t  if (!validate_arg (arg, code, nonnull))\n+\t  if (!validate_arg (arg, code))\n \t    goto end;\n \t  break;\n \t}\n@@ -9134,17 +9140,15 @@ rewrite_call_expr (location_t loc, tree exp, int skip, tree fndecl, int n, ...)\n }\n \n /* Validate a single argument ARG against a tree code CODE representing\n-   a type.  When NONNULL is true consider a pointer argument valid only\n-   if it's non-null.  Return true when argument is valid.  */\n+   a type.  Return true when argument is valid.  */\n \n static bool\n-validate_arg (const_tree arg, enum tree_code code, bool nonnull /*= false*/)\n+validate_arg (const_tree arg, enum tree_code code)\n {\n   if (!arg)\n     return false;\n   else if (code == POINTER_TYPE)\n-    return POINTER_TYPE_P (TREE_TYPE (arg))\n-      && (!nonnull || !integer_zerop (arg));\n+    return POINTER_TYPE_P (TREE_TYPE (arg));\n   else if (code == INTEGER_TYPE)\n     return INTEGRAL_TYPE_P (TREE_TYPE (arg));\n   return code == TREE_CODE (TREE_TYPE (arg));"}, {"sha": "acdedc8e024bb608ac61ecbbdf9385898cfdcb13", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dba79602a7e3fb62bebee58b2cd7c24115b4faf/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dba79602a7e3fb62bebee58b2cd7c24115b4faf/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=0dba79602a7e3fb62bebee58b2cd7c24115b4faf", "patch": "@@ -1,3 +1,14 @@\n+2016-12-21  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR bootstrap/78817\n+\t* c-common.c (struct nonnull_arg_ctx): New type.\n+\t(check_function_nonnull): Return bool instead of void.  Use\n+\tnonnull_arg_ctx as context rather than just location_t.\n+\t(check_nonnull_arg): Adjust for the new context type, set\n+\twarned_p to true if a warning has been diagnosed.\n+\t(check_function_arguments): Return bool instead of void.\n+\t* c-common.h (check_function_arguments): Adjust prototype.\n+\n 2016-12-21  Jason Merrill  <jason@redhat.com>\n \n \t* c.opt (-fnew-ttp-matching): New flag."}, {"sha": "81dc888e9b327b58c6d460bec944b70aab4a4e34", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 31, "deletions": 12, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dba79602a7e3fb62bebee58b2cd7c24115b4faf/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dba79602a7e3fb62bebee58b2cd7c24115b4faf/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=0dba79602a7e3fb62bebee58b2cd7c24115b4faf", "patch": "@@ -5250,19 +5250,29 @@ c_determine_visibility (tree decl)\n   return false;\n }\n \n+/* Data to communicate through check_function_arguments_recurse between\n+   check_function_nonnull and check_nonnull_arg.  */\n+\n+struct nonnull_arg_ctx\n+{\n+  location_t loc;\n+  bool warned_p;\n+};\n+\n /* Check the argument list of a function call for null in argument slots\n    that are marked as requiring a non-null pointer argument.  The NARGS\n-   arguments are passed in the array ARGARRAY.  */\n+   arguments are passed in the array ARGARRAY.  Return true if we have\n+   warned.  */\n \n-static void\n+static bool\n check_function_nonnull (location_t loc, tree attrs, int nargs, tree *argarray)\n {\n   tree a;\n   int i;\n \n   attrs = lookup_attribute (\"nonnull\", attrs);\n   if (attrs == NULL_TREE)\n-    return;\n+    return false;\n \n   a = attrs;\n   /* See if any of the nonnull attributes has no arguments.  If so,\n@@ -5273,9 +5283,10 @@ check_function_nonnull (location_t loc, tree attrs, int nargs, tree *argarray)\n       a = lookup_attribute (\"nonnull\", TREE_CHAIN (a));\n     while (a != NULL_TREE && TREE_VALUE (a) != NULL_TREE);\n \n+  struct nonnull_arg_ctx ctx = { loc, false };\n   if (a != NULL_TREE)\n     for (i = 0; i < nargs; i++)\n-      check_function_arguments_recurse (check_nonnull_arg, &loc, argarray[i],\n+      check_function_arguments_recurse (check_nonnull_arg, &ctx, argarray[i],\n \t\t\t\t\ti + 1);\n   else\n     {\n@@ -5291,10 +5302,11 @@ check_function_nonnull (location_t loc, tree attrs, int nargs, tree *argarray)\n \t    }\n \n \t  if (a != NULL_TREE)\n-\t    check_function_arguments_recurse (check_nonnull_arg, &loc,\n+\t    check_function_arguments_recurse (check_nonnull_arg, &ctx,\n \t\t\t\t\t      argarray[i], i + 1);\n \t}\n     }\n+  return ctx.warned_p;\n }\n \n /* Check that the Nth argument of a function call (counting backwards\n@@ -5379,7 +5391,7 @@ nonnull_check_p (tree args, unsigned HOST_WIDE_INT param_num)\n static void\n check_nonnull_arg (void *ctx, tree param, unsigned HOST_WIDE_INT param_num)\n {\n-  location_t *ploc = (location_t *) ctx;\n+  struct nonnull_arg_ctx *pctx = (struct nonnull_arg_ctx *) ctx;\n \n   /* Just skip checking the argument if it's not a pointer.  This can\n      happen if the \"nonnull\" attribute was given without an operand\n@@ -5391,9 +5403,12 @@ check_nonnull_arg (void *ctx, tree param, unsigned HOST_WIDE_INT param_num)\n   /* When not optimizing diagnose the simple cases of null arguments.\n      When optimization is enabled defer the checking until expansion\n      when more cases can be detected.  */\n-  if (!optimize && integer_zerop (param))\n-    warning_at (*ploc, OPT_Wnonnull, \"null argument where non-null required \"\n-\t\t\"(argument %lu)\", (unsigned long) param_num);\n+  if (integer_zerop (param))\n+    {\n+      warning_at (pctx->loc, OPT_Wnonnull, \"null argument where non-null \"\n+\t\t  \"required (argument %lu)\", (unsigned long) param_num);\n+      pctx->warned_p = true;\n+    }\n }\n \n /* Helper for nonnull attribute handling; fetch the operand number\n@@ -5587,16 +5602,19 @@ attribute_fallthrough_p (tree attr)\n \f\n /* Check for valid arguments being passed to a function with FNTYPE.\n    There are NARGS arguments in the array ARGARRAY.  LOC should be used for\n-   diagnostics.  */\n-void\n+   diagnostics.  Return true if -Wnonnull warning has been diagnosed.  */\n+bool\n check_function_arguments (location_t loc, const_tree fntype, int nargs,\n \t\t\t  tree *argarray)\n {\n+  bool warned_p = false;\n+\n   /* Check for null being passed in a pointer argument that must be\n      non-null.  We also need to do this if format checking is enabled.  */\n \n   if (warn_nonnull)\n-    check_function_nonnull (loc, TYPE_ATTRIBUTES (fntype), nargs, argarray);\n+    warned_p = check_function_nonnull (loc, TYPE_ATTRIBUTES (fntype),\n+\t\t\t\t       nargs, argarray);\n \n   /* Check for errors in format strings.  */\n \n@@ -5605,6 +5623,7 @@ check_function_arguments (location_t loc, const_tree fntype, int nargs,\n \n   if (warn_format)\n     check_function_sentinel (fntype, nargs, argarray);\n+  return warned_p;\n }\n \n /* Generic argument checking recursion routine.  PARAM is the argument to"}, {"sha": "b9131e3e9581935a801f53ec34d6bf5dda814a88", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dba79602a7e3fb62bebee58b2cd7c24115b4faf/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dba79602a7e3fb62bebee58b2cd7c24115b4faf/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=0dba79602a7e3fb62bebee58b2cd7c24115b4faf", "patch": "@@ -804,7 +804,7 @@ extern const char *fname_as_string (int);\n extern tree fname_decl (location_t, unsigned, tree);\n \n extern int check_user_alignment (const_tree, bool);\n-extern void check_function_arguments (location_t loc, const_tree, int, tree *);\n+extern bool check_function_arguments (location_t loc, const_tree, int, tree *);\n extern void check_function_arguments_recurse (void (*)\n \t\t\t\t\t      (void *, tree,\n \t\t\t\t\t       unsigned HOST_WIDE_INT),"}, {"sha": "7a5e741189081b9defd6e76503501b0612855b78", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dba79602a7e3fb62bebee58b2cd7c24115b4faf/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dba79602a7e3fb62bebee58b2cd7c24115b4faf/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=0dba79602a7e3fb62bebee58b2cd7c24115b4faf", "patch": "@@ -1,5 +1,9 @@\n 2016-12-21  Jakub Jelinek  <jakub@redhat.com>\n \n+\tPR bootstrap/78817\n+\t* c-typeck.c (build_function_call_vec): If check_function_arguments\n+\treturns true, set TREE_NO_WARNING on CALL_EXPR.\n+\n \tPR c/77767\n \t* c-decl.c (grokdeclarator): If *expr is non-NULL, append expression\n \tto *expr instead of overwriting it."}, {"sha": "a269682d4ed98da960139d8e0c47d698ae7720b2", "filename": "gcc/c/c-typeck.c", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dba79602a7e3fb62bebee58b2cd7c24115b4faf/gcc%2Fc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dba79602a7e3fb62bebee58b2cd7c24115b4faf/gcc%2Fc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.c?ref=0dba79602a7e3fb62bebee58b2cd7c24115b4faf", "patch": "@@ -3110,15 +3110,15 @@ build_function_call_vec (location_t loc, vec<location_t> arg_loc,\n     return error_mark_node;\n \n   /* Check that the arguments to the function are valid.  */\n-  check_function_arguments (loc, fntype, nargs, argarray);\n+  bool warned_p = check_function_arguments (loc, fntype, nargs, argarray);\n \n   if (name != NULL_TREE\n       && !strncmp (IDENTIFIER_POINTER (name), \"__builtin_\", 10))\n     {\n       if (require_constant_value)\n-\tresult =\n-\t  fold_build_call_array_initializer_loc (loc, TREE_TYPE (fntype),\n-\t\t\t\t\t\t function, nargs, argarray);\n+\tresult\n+\t  = fold_build_call_array_initializer_loc (loc, TREE_TYPE (fntype),\n+\t\t\t\t\t\t   function, nargs, argarray);\n       else\n \tresult = fold_build_call_array_loc (loc, TREE_TYPE (fntype),\n \t\t\t\t\t    function, nargs, argarray);\n@@ -3129,6 +3129,10 @@ build_function_call_vec (location_t loc, vec<location_t> arg_loc,\n   else\n     result = build_call_array_loc (loc, TREE_TYPE (fntype),\n \t\t\t\t   function, nargs, argarray);\n+  /* If -Wnonnull warning has been diagnosed, avoid diagnosing it again\n+     later.  */\n+  if (warned_p && TREE_CODE (result) == CALL_EXPR)\n+    TREE_NO_WARNING (result) = 1;\n \n   /* In this improbable scenario, a nested function returns a VM type.\n      Create a TARGET_EXPR so that the call always has a LHS, much as"}, {"sha": "bc3cbd599fc321a5422a2a7b214952eb14aded71", "filename": "gcc/calls.c", "status": "modified", "additions": 0, "deletions": 95, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dba79602a7e3fb62bebee58b2cd7c24115b4faf/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dba79602a7e3fb62bebee58b2cd7c24115b4faf/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=0dba79602a7e3fb62bebee58b2cd7c24115b4faf", "patch": "@@ -1501,91 +1501,6 @@ maybe_complain_about_tail_call (tree call_expr, const char *reason)\n   error_at (EXPR_LOCATION (call_expr), \"cannot tail-call: %s\", reason);\n }\n \n-/* Return a bitmap with a bit set corresponding to each argument in\n-   a function call expression CALLEXPR declared with attribute nonnull,\n-   or null if none of the function's argument are nonnull.  The caller\n-   must free the bitmap.  */\n-\n-bitmap\n-get_nonnull_args (const_tree callexpr)\n-{\n-  tree fn = CALL_EXPR_FN (callexpr);\n-  if (!fn || TREE_CODE (fn) != ADDR_EXPR)\n-    return NULL;\n-\n-  tree fndecl = TREE_OPERAND (fn, 0);\n-  tree fntype = TREE_TYPE (fndecl);\n-  tree attrs = TYPE_ATTRIBUTES (fntype);\n-  if (!attrs)\n-    return NULL;\n-\n-  bitmap argmap = NULL;\n-\n-  /* A function declaration can specify multiple attribute nonnull,\n-     each with zero or more arguments.  The loop below creates a bitmap\n-     representing a union of all the arguments.  An empty (but non-null)\n-     bitmap means that all arguments have been declaraed nonnull.  */\n-  for ( ; attrs; attrs = TREE_CHAIN (attrs))\n-    {\n-      attrs = lookup_attribute (\"nonnull\", attrs);\n-      if (!attrs)\n-\tbreak;\n-\n-      if (!argmap)\n-\targmap = BITMAP_ALLOC (NULL);\n-\n-      if (!TREE_VALUE (attrs))\n-\t{\n-\t  /* Clear the bitmap in case a previous attribute nonnull\n-\t     set it and this one overrides it for all arguments.  */\n-\t  bitmap_clear (argmap);\n-\t  return argmap;\n-\t}\n-\n-      /* Iterate over the indices of the format arguments declared nonnull\n-\t and set a bit for each.  */\n-      for (tree idx = TREE_VALUE (attrs); idx; idx = TREE_CHAIN (idx))\n-\t{\n-\t  unsigned int val = TREE_INT_CST_LOW (TREE_VALUE (idx)) - 1;\n-\t  bitmap_set_bit (argmap, val);\n-\t}\n-    }\n-\n-  return argmap;\n-}\n-\n-/* In a call EXP to a function FNDECL some of whose arguments may have\n-   been declared with attribute nonnull as described by NONNULLARGS,\n-   check actual argument ARG at the zero-based position ARGPOS for\n-   equality to null and issue a warning if it is not expected to be.  */\n-\n-static void\n-maybe_warn_null_arg (tree fndecl, tree exp, tree arg,\n-\t\t     unsigned argpos, bitmap nonnullargs)\n-{\n-  if (!optimize\n-      || !nonnullargs\n-      || TREE_CODE (TREE_TYPE (arg)) != POINTER_TYPE\n-      || !integer_zerop (arg)\n-      || (!bitmap_empty_p (nonnullargs)\n-\t  && !bitmap_bit_p (nonnullargs, argpos)))\n-    return;\n-\n-  ++argpos;\n-\n-  location_t exploc EXPR_LOCATION (exp);\n-\n-  if (warning_at (exploc, OPT_Wnonnull,\n-\t\t  \"argument %u null where non-null expected\", argpos))\n-    {\n-      if (DECL_IS_BUILTIN (fndecl))\n-\tinform (exploc, \"in a call to built-in function %qD\", fndecl);\n-      else\n-\tinform (DECL_SOURCE_LOCATION (fndecl),\n-\t\t\"in a call to function %qD declared here\", fndecl);\n-    }\n-}\n-\n /* Fill in ARGS_SIZE and ARGS array based on the parameters found in\n    CALL_EXPR EXP.\n \n@@ -1769,9 +1684,6 @@ initialize_argument_information (int num_actuals ATTRIBUTE_UNUSED,\n   /* Array for up to the two attribute alloc_size arguments.  */\n   tree alloc_args[] = { NULL_TREE, NULL_TREE };\n \n-  /* Get a bitmap of pointer argument numbers declared attribute nonnull.  */\n-  bitmap nonnullargs = get_nonnull_args (exp);\n-\n   /* I counts args in order (to be) pushed; ARGPOS counts in order written.  */\n   for (argpos = 0; argpos < num_actuals; i--, argpos++)\n     {\n@@ -2003,11 +1915,6 @@ initialize_argument_information (int num_actuals ATTRIBUTE_UNUSED,\n       if (args[i].locate.size.var)\n \tADD_PARM_SIZE (*args_size, args[i].locate.size.var);\n \n-      /* Check pointer argument for equality to NULL that is being passed\n-\t to arguments declared with attribute nonnull and warn.  */\n-      maybe_warn_null_arg (fndecl, exp, args[i].tree_value, argpos,\n-\t\t\t   nonnullargs);\n-\n       /* Increment ARGS_SO_FAR, which has info about which arg-registers\n \t have been used, etc.  */\n \n@@ -2028,8 +1935,6 @@ initialize_argument_information (int num_actuals ATTRIBUTE_UNUSED,\n \t alloc_size.  */\n       maybe_warn_alloc_args_overflow (fndecl, exp, alloc_args, alloc_idx);\n     }\n-\n-  BITMAP_FREE (nonnullargs);\n }\n \n /* Update ARGS_SIZE to contain the total size for the argument block."}, {"sha": "3b0726345afb98430d380531b1c8bb757c67f61d", "filename": "gcc/calls.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dba79602a7e3fb62bebee58b2cd7c24115b4faf/gcc%2Fcalls.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dba79602a7e3fb62bebee58b2cd7c24115b4faf/gcc%2Fcalls.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.h?ref=0dba79602a7e3fb62bebee58b2cd7c24115b4faf", "patch": "@@ -38,6 +38,5 @@ extern bool pass_by_reference (CUMULATIVE_ARGS *, machine_mode,\n extern bool reference_callee_copied (CUMULATIVE_ARGS *, machine_mode,\n \t\t\t\t     tree, bool);\n extern void maybe_warn_alloc_args_overflow (tree, tree, tree[2], int[2]);\n-extern bitmap get_nonnull_args (const_tree);\n \n #endif // GCC_CALLS_H"}, {"sha": "e493fd1fa52be44a68489a8dbbb72359b6ce83b1", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dba79602a7e3fb62bebee58b2cd7c24115b4faf/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dba79602a7e3fb62bebee58b2cd7c24115b4faf/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=0dba79602a7e3fb62bebee58b2cd7c24115b4faf", "patch": "@@ -1,5 +1,10 @@\n 2016-12-21  Jakub Jelinek  <jakub@redhat.com>\n \n+\tPR bootstrap/78817\n+\t* typeck.c (cp_build_function_call_vec): If check_function_arguments\n+\treturns true, set TREE_NO_WARNING on CALL_EXPR.\n+\t* call.c (build_over_call): Likewise.\n+\n \tPR c++/77830\n \t* constexpr.c (cxx_eval_array_reference): Perform out of bounds\n \tverification even if lval is true, just allow one past the last"}, {"sha": "894f98e5752f62c95de93d6a7bbbadb40f03d5f6", "filename": "gcc/cp/call.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dba79602a7e3fb62bebee58b2cd7c24115b4faf/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dba79602a7e3fb62bebee58b2cd7c24115b4faf/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=0dba79602a7e3fb62bebee58b2cd7c24115b4faf", "patch": "@@ -7881,14 +7881,16 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n      nonnull are disabled.  Just in case that at least one of them is active\n      the check_function_arguments function might warn about something.  */\n \n+  bool warned_p = false;\n   if (warn_nonnull || warn_format || warn_suggest_attribute_format)\n     {\n       tree *fargs = (!nargs ? argarray\n \t\t\t    : (tree *) alloca (nargs * sizeof (tree)));\n       for (j = 0; j < nargs; j++)\n \tfargs[j] = maybe_constant_value (argarray[j]);\n \n-      check_function_arguments (input_location, TREE_TYPE (fn), nargs, fargs);\n+      warned_p = check_function_arguments (input_location, TREE_TYPE (fn),\n+\t\t\t\t\t   nargs, fargs);\n     }\n \n   if (DECL_INHERITED_CTOR (fn))\n@@ -8107,6 +8109,12 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n       /* build_new_op_1 will clear this when appropriate.  */\n       CALL_EXPR_ORDERED_ARGS (c) = true;\n     }\n+  if (warned_p)\n+    {\n+      tree c = extract_call_expr (call);\n+      if (TREE_CODE (c) == CALL_EXPR)\n+\tTREE_NO_WARNING (c) = 1;\n+    }\n   return call;\n }\n "}, {"sha": "21282c7f048fa75c3feae50b62acd6154f94a789", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dba79602a7e3fb62bebee58b2cd7c24115b4faf/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dba79602a7e3fb62bebee58b2cd7c24115b4faf/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=0dba79602a7e3fb62bebee58b2cd7c24115b4faf", "patch": "@@ -3654,10 +3654,18 @@ cp_build_function_call_vec (tree function, vec<tree, va_gc> **params,\n \n   /* Check for errors in format strings and inappropriately\n      null parameters.  */\n-  check_function_arguments (input_location, fntype, nargs, argarray);\n+  bool warned_p = check_function_arguments (input_location, fntype,\n+\t\t\t\t\t    nargs, argarray);\n \n   ret = build_cxx_call (function, nargs, argarray, complain);\n \n+  if (warned_p)\n+    {\n+      tree c = extract_call_expr (ret);\n+      if (TREE_CODE (c) == CALL_EXPR)\n+\tTREE_NO_WARNING (c) = 1;\n+    }\n+\n   if (allocated != NULL)\n     release_tree_vector (allocated);\n "}, {"sha": "99ae3f4c9ceb4189d40c0b624bff761507ff0331", "filename": "gcc/passes.def", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dba79602a7e3fb62bebee58b2cd7c24115b4faf/gcc%2Fpasses.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dba79602a7e3fb62bebee58b2cd7c24115b4faf/gcc%2Fpasses.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.def?ref=0dba79602a7e3fb62bebee58b2cd7c24115b4faf", "patch": "@@ -193,6 +193,7 @@ along with GCC; see the file COPYING3.  If not see\n \t They ensure memory accesses are not indirect wherever possible.  */\n       NEXT_PASS (pass_strip_predict_hints);\n       NEXT_PASS (pass_ccp, true /* nonzero_p */);\n+      NEXT_PASS (pass_post_ipa_warn);\n       /* After CCP we rewrite no longer addressed locals into SSA\n \t form if possible.  */\n       NEXT_PASS (pass_complete_unrolli);\n@@ -360,6 +361,7 @@ along with GCC; see the file COPYING3.  If not see\n       NEXT_PASS (pass_lower_vector_ssa);\n       /* Perform simple scalar cleanup which is constant/copy propagation.  */\n       NEXT_PASS (pass_ccp, true /* nonzero_p */);\n+      NEXT_PASS (pass_post_ipa_warn);\n       NEXT_PASS (pass_object_sizes);\n       /* Fold remaining builtins.  */\n       NEXT_PASS (pass_fold_builtins);"}, {"sha": "6a8bcc5c6556c682286a9923980419b424a8d1e3", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dba79602a7e3fb62bebee58b2cd7c24115b4faf/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dba79602a7e3fb62bebee58b2cd7c24115b4faf/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=0dba79602a7e3fb62bebee58b2cd7c24115b4faf", "patch": "@@ -422,6 +422,7 @@ extern gimple_opt_pass *make_pass_omp_device_lower (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_object_sizes (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_strlen (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_fold_builtins (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_post_ipa_warn (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_stdarg (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_early_warn_uninitialized (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_late_warn_uninitialized (gcc::context *ctxt);"}, {"sha": "24a9fc1248781e338b6aae901e49d2ffb74d0ec2", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dba79602a7e3fb62bebee58b2cd7c24115b4faf/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dba79602a7e3fb62bebee58b2cd7c24115b4faf/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=0dba79602a7e3fb62bebee58b2cd7c24115b4faf", "patch": "@@ -144,6 +144,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"optabs-query.h\"\n #include \"tree-ssa-ccp.h\"\n #include \"tree-dfa.h\"\n+#include \"diagnostic-core.h\"\n \n /* Possible lattice values.  */\n typedef enum\n@@ -3316,3 +3317,97 @@ make_pass_fold_builtins (gcc::context *ctxt)\n {\n   return new pass_fold_builtins (ctxt);\n }\n+\n+/* A simple pass that emits some warnings post IPA.  */\n+\n+namespace {\n+\n+const pass_data pass_data_post_ipa_warn =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"post_ipa_warn\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  TV_NONE, /* tv_id */\n+  ( PROP_cfg | PROP_ssa ), /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n+};\n+\n+class pass_post_ipa_warn : public gimple_opt_pass\n+{\n+public:\n+  pass_post_ipa_warn (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_post_ipa_warn, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  opt_pass * clone () { return new pass_post_ipa_warn (m_ctxt); }\n+  virtual bool gate (function *) { return warn_nonnull != 0; }\n+  virtual unsigned int execute (function *);\n+\n+}; // class pass_fold_builtins\n+\n+unsigned int\n+pass_post_ipa_warn::execute (function *fun)\n+{\n+  basic_block bb;\n+\n+  FOR_EACH_BB_FN (bb, fun)\n+    {\n+      gimple_stmt_iterator gsi;\n+      for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+\t{\n+\t  gimple *stmt = gsi_stmt (gsi);\n+\t  if (!is_gimple_call (stmt) || gimple_no_warning_p (stmt))\n+\t    continue;\n+\n+\t  if (warn_nonnull)\n+\t    {\n+\t      bitmap nonnullargs\n+\t\t= get_nonnull_args (gimple_call_fntype (stmt));\n+\t      if (nonnullargs)\n+\t\t{\n+\t\t  for (unsigned i = 0; i < gimple_call_num_args (stmt); i++)\n+\t\t    {\n+\t\t      tree arg = gimple_call_arg (stmt, i);\n+\t\t      if (TREE_CODE (TREE_TYPE (arg)) != POINTER_TYPE)\n+\t\t\tcontinue;\n+\t\t      if (!integer_zerop (arg))\n+\t\t\tcontinue;\n+\t\t      if (!bitmap_empty_p (nonnullargs)\n+\t\t\t  && !bitmap_bit_p (nonnullargs, i))\n+\t\t\tcontinue;\n+\n+\t\t      location_t loc = gimple_location (stmt);\n+\t\t      if (warning_at (loc, OPT_Wnonnull,\n+\t\t\t\t      \"argument %u null where non-null \"\n+\t\t\t\t      \"expected\", i + 1))\n+\t\t\t{\n+\t\t\t  tree fndecl = gimple_call_fndecl (stmt);\n+\t\t\t  if (fndecl && DECL_IS_BUILTIN (fndecl))\n+\t\t\t    inform (loc, \"in a call to built-in function %qD\",\n+\t\t\t\t    fndecl);\n+\t\t\t  else if (fndecl)\n+\t\t\t    inform (DECL_SOURCE_LOCATION (fndecl),\n+\t\t\t\t    \"in a call to function %qD declared here\",\n+\t\t\t\t    fndecl);\n+\n+\t\t\t}\n+\t\t    }\n+\t\t  BITMAP_FREE (nonnullargs);\n+\t\t}\n+\t    }\n+\t}\n+    }\n+  return 0;\n+}\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_post_ipa_warn (gcc::context *ctxt)\n+{\n+  return new pass_post_ipa_warn (ctxt);\n+}"}, {"sha": "3a6e6d10787a6497e759ea37ee327dfa380c20ee", "filename": "gcc/tree.c", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dba79602a7e3fb62bebee58b2cd7c24115b4faf/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dba79602a7e3fb62bebee58b2cd7c24115b4faf/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=0dba79602a7e3fb62bebee58b2cd7c24115b4faf", "patch": "@@ -14313,6 +14313,56 @@ combined_fn_name (combined_fn fn)\n     return internal_fn_name (as_internal_fn (fn));\n }\n \n+/* Return a bitmap with a bit set corresponding to each argument in\n+   a function call type FNTYPE declared with attribute nonnull,\n+   or null if none of the function's argument are nonnull.  The caller\n+   must free the bitmap.  */\n+\n+bitmap\n+get_nonnull_args (const_tree fntype)\n+{\n+  if (fntype == NULL_TREE)\n+    return NULL;\n+\n+  tree attrs = TYPE_ATTRIBUTES (fntype);\n+  if (!attrs)\n+    return NULL;\n+\n+  bitmap argmap = NULL;\n+\n+  /* A function declaration can specify multiple attribute nonnull,\n+     each with zero or more arguments.  The loop below creates a bitmap\n+     representing a union of all the arguments.  An empty (but non-null)\n+     bitmap means that all arguments have been declaraed nonnull.  */\n+  for ( ; attrs; attrs = TREE_CHAIN (attrs))\n+    {\n+      attrs = lookup_attribute (\"nonnull\", attrs);\n+      if (!attrs)\n+\tbreak;\n+\n+      if (!argmap)\n+\targmap = BITMAP_ALLOC (NULL);\n+\n+      if (!TREE_VALUE (attrs))\n+\t{\n+\t  /* Clear the bitmap in case a previous attribute nonnull\n+\t     set it and this one overrides it for all arguments.  */\n+\t  bitmap_clear (argmap);\n+\t  return argmap;\n+\t}\n+\n+      /* Iterate over the indices of the format arguments declared nonnull\n+\t and set a bit for each.  */\n+      for (tree idx = TREE_VALUE (attrs); idx; idx = TREE_CHAIN (idx))\n+\t{\n+\t  unsigned int val = TREE_INT_CST_LOW (TREE_VALUE (idx)) - 1;\n+\t  bitmap_set_bit (argmap, val);\n+\t}\n+    }\n+\n+  return argmap;\n+}\n+\n #if CHECKING_P\n \n namespace selftest {"}, {"sha": "e3192027575cdb1dbd834c589c6d7a9b8af53b3e", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dba79602a7e3fb62bebee58b2cd7c24115b4faf/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dba79602a7e3fb62bebee58b2cd7c24115b4faf/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=0dba79602a7e3fb62bebee58b2cd7c24115b4faf", "patch": "@@ -4855,6 +4855,7 @@ extern void DEBUG_FUNCTION verify_type (const_tree t);\n extern bool gimple_canonical_types_compatible_p (const_tree, const_tree,\n \t\t\t\t\t\t bool trust_type_canonical = true);\n extern bool type_with_interoperable_signedness (const_tree);\n+extern bitmap get_nonnull_args (const_tree);\n \n /* Return simplified tree code of type that is used for canonical type\n    merging.  */"}]}