{"sha": "f61a2c7da855928032ffe9293483c5c9584f7ceb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjYxYTJjN2RhODU1OTI4MDMyZmZlOTI5MzQ4M2M1Yzk1ODRmN2NlYg==", "commit": {"author": {"name": "Andreas Krebbel", "email": "krebbel1@de.ibm.com", "date": "2006-02-03T07:52:57Z"}, "committer": {"name": "Andreas Krebbel", "email": "krebbel@gcc.gnu.org", "date": "2006-02-03T07:52:57Z"}, "message": "re PR target/25864 (Enable IBM long double format in 32-bit PowerPC Linux)\n\n2006-02-03  Andreas Krebbel  <krebbel1@de.ibm.com>\n            Ulrich Weigand  <uweigand@de.ibm.com>\n\n\tPR target/25864\n\t* config/s390/2084.md (\"x_fsimptf\", \"x_fmultf\", \"x_fdivtf\",\n\t\"x_floadtf\", \"x_ftrunctf\", \"x_ftruncdf\"): New insn reservations.\n\t* config/s390/fixdfdi.h (__fixunstfdi, __fixtfdi): New functions.\n\t* config/s390/s390.c (struct processor_costs): Add mxbr, sqxbr, dxbr \n\tand dxr fields.\n\t(z900_cost, z990_cost, z9_109_cost): Values for the new fields added.\n\t(s390_rtx_costs): Use the new fields to calculate rtx costs.\n\t(s390_secondary_input_reload_class, s390_secondary_output_reload_class):\n\tDefine secondary reloads for TFmode moves.\n\t(constant_modes): Add TFmode.\n\t(NR_C_MODES): Set to 8.\n\t* config/s390/s390.h (TARGET_CPU_CPP_BUILTINS): Add __LONG_DOUBLE_128__\n\tbuiltin define.\n\t(LONG_DOUBLE_TYPE_SIZE): Set to 128 or 64.\n\t(LIBGCC2_LONG_DOUBLE_TYPE_SIZE, WIDEST_HARDWARE_FP_SIZE): Define.\n\t(HARD_REGNO_NREGS, HARD_REGNO_MODE_OK, CLASS_MAX_NREGS, \n\tCANNOT_CHANGE_MODE_CLASS): Consider TFmode.\n\t* config/s390/s390.md (\"type\" attribute): Add fsimptf, floadtf, fmultf, \n\tfdivtf, fsqrttf, ftrunctf, ftruncdf as possible values.\n\t(FPR mode macro): Add TFmode.\n\t(DSF mode macro): New.\n\t(<de>, <dee> mode attributes): Removed.\n\t(<xde>, <xdee>, <RRe>, <RXe>, <Rf> mode attributes): New.\n\t(\"*cmp<mode>_ccs_0\", \"*cmp<mode>_ccs_0_ibm\", \"*cmp<mode>_ccs\", \n\t\"*cmp<mode>_ccs_ibm\", \"fix_trunc<FPR:mode><GPR:mode>2_ieee\", \n\t\"floatdi<mode>2\", \"floatsi<mode>2_ieee\", \"*add<mode>3\", \n\t\"*add<mode>3_cc\", \"*add<mode>3_cconly\", \"*add<mode>3_ibm\", \n\t\"*sub<mode>3\", \"*sub<mode>3_cc\", \"*sub<mode>3_cconly\", \n\t\"*sub<mode>3_ibm\", \"*mul<mode>3_ibm\", \"*fmadd<mode>\", \"*fmsub<mode>\",\n\t\"*div<mode>3\", \"*div<mode>3_ibm\", \"*neg<mode>2_cc\", \n\t\"*neg<mode>2_cconly\", \"*neg<mode>2\", \"*neg<mode>2_ibm\", \n\t\"*abs<mode>2_cc\", \"*abs<mode>2_cconly\", \"*abs<mode>2\",\n\t\"*abs<mode>2_ibm\", \"*negabs<mode>2_cc\", \"*negabs<mode>2_cconly\", \n\t\"*negabs<mode>2\", \"sqrt<mode>2\"):\n\tChanged <de> to <xde>. R constraint replaced by <Rf>.\n\t(\"*mul<mode>3\"): Changed <dee> to <xdee>. R constraint replaced by \n\t<Rf>.\n\t(\"fix_trunc<FPR:mode>di2\"): 'FPR:' removed.\n        (\"*fmadd<mode>\", \"*fmsub<mode>\"): FPR mode replaced by DSF.\n\t(\"*movtf_64\", \"*movtf_31\"): New insn definitions followed by 5 \n\tsplitters.\n\t(\"movtf\", \"reload_outtf\", \"reload_intf\", \"trunctfdf2\", \"trunctfsf2\", \n\t\"extenddftf2\", \"extendsftf2\"): New expanders.\n\t(\"*trunctfdf2_ieee\", \"*trunctfdf2_ibm\", \"*trunctfsf2_ieee\", \n\t\"*trunctfsf2_ibm\", \"*extenddftf2_ieee\", \"*extenddftf2_ibm\",\n\t\"*extendsftf2_ieee\", \"*extendsftf2_ibm\"): New insn patterns.\n\t* config/s390/s390.opt (mlong-double-128, mlong-double-64):\n\tNew options.\n\t* config/s390/t-crtstuff (TARGET_LIBGCC2_CFLAGS): Macro defined.\n\t* config/s390/libgcc-glibc.ver (__divtc3, __multc3, __powitf2, \n\t__fixtfti, __fixunstfti, __floattitf, __fixtfdi, __fixunstfdi,\n\t__floatditf): Add a GCC_4.1.0 symbol version tag.\n\t* doc/invoke.texi (-mlong-double-128, -mlong-double-64): Document\n\tthe new options.\n\n\n\nCo-Authored-By: Ulrich Weigand <uweigand@de.ibm.com>\n\nFrom-SVN: r110539", "tree": {"sha": "b31e68702d10601b2097570d3a555e1dcca9925c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b31e68702d10601b2097570d3a555e1dcca9925c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f61a2c7da855928032ffe9293483c5c9584f7ceb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f61a2c7da855928032ffe9293483c5c9584f7ceb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f61a2c7da855928032ffe9293483c5c9584f7ceb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f61a2c7da855928032ffe9293483c5c9584f7ceb/comments", "author": null, "committer": null, "parents": [{"sha": "010ef110910a241c2391032540b37179e1dc4630", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/010ef110910a241c2391032540b37179e1dc4630", "html_url": "https://github.com/Rust-GCC/gccrs/commit/010ef110910a241c2391032540b37179e1dc4630"}], "stats": {"total": 941, "additions": 794, "deletions": 147}, "files": [{"sha": "2a8be97e73566dacadf5ec44a1a9379fb84fe21c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f61a2c7da855928032ffe9293483c5c9584f7ceb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f61a2c7da855928032ffe9293483c5c9584f7ceb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f61a2c7da855928032ffe9293483c5c9584f7ceb", "patch": "@@ -1,3 +1,62 @@\n+2006-02-03  Andreas Krebbel  <krebbel1@de.ibm.com>\n+            Ulrich Weigand  <uweigand@de.ibm.com>\n+\n+\tPR target/25864\n+\t* config/s390/2084.md (\"x_fsimptf\", \"x_fmultf\", \"x_fdivtf\",\n+\t\"x_floadtf\", \"x_ftrunctf\", \"x_ftruncdf\"): New insn reservations.\n+\t* config/s390/fixdfdi.h (__fixunstfdi, __fixtfdi): New functions.\n+\t* config/s390/s390.c (struct processor_costs): Add mxbr, sqxbr, dxbr \n+\tand dxr fields.\n+\t(z900_cost, z990_cost, z9_109_cost): Values for the new fields added.\n+\t(s390_rtx_costs): Use the new fields to calculate rtx costs.\n+\t(s390_secondary_input_reload_class, s390_secondary_output_reload_class):\n+\tDefine secondary reloads for TFmode moves.\n+\t(constant_modes): Add TFmode.\n+\t(NR_C_MODES): Set to 8.\n+\t* config/s390/s390.h (TARGET_CPU_CPP_BUILTINS): Add __LONG_DOUBLE_128__\n+\tbuiltin define.\n+\t(LONG_DOUBLE_TYPE_SIZE): Set to 128 or 64.\n+\t(LIBGCC2_LONG_DOUBLE_TYPE_SIZE, WIDEST_HARDWARE_FP_SIZE): Define.\n+\t(HARD_REGNO_NREGS, HARD_REGNO_MODE_OK, CLASS_MAX_NREGS, \n+\tCANNOT_CHANGE_MODE_CLASS): Consider TFmode.\n+\t* config/s390/s390.md (\"type\" attribute): Add fsimptf, floadtf, fmultf, \n+\tfdivtf, fsqrttf, ftrunctf, ftruncdf as possible values.\n+\t(FPR mode macro): Add TFmode.\n+\t(DSF mode macro): New.\n+\t(<de>, <dee> mode attributes): Removed.\n+\t(<xde>, <xdee>, <RRe>, <RXe>, <Rf> mode attributes): New.\n+\t(\"*cmp<mode>_ccs_0\", \"*cmp<mode>_ccs_0_ibm\", \"*cmp<mode>_ccs\", \n+\t\"*cmp<mode>_ccs_ibm\", \"fix_trunc<FPR:mode><GPR:mode>2_ieee\", \n+\t\"floatdi<mode>2\", \"floatsi<mode>2_ieee\", \"*add<mode>3\", \n+\t\"*add<mode>3_cc\", \"*add<mode>3_cconly\", \"*add<mode>3_ibm\", \n+\t\"*sub<mode>3\", \"*sub<mode>3_cc\", \"*sub<mode>3_cconly\", \n+\t\"*sub<mode>3_ibm\", \"*mul<mode>3_ibm\", \"*fmadd<mode>\", \"*fmsub<mode>\",\n+\t\"*div<mode>3\", \"*div<mode>3_ibm\", \"*neg<mode>2_cc\", \n+\t\"*neg<mode>2_cconly\", \"*neg<mode>2\", \"*neg<mode>2_ibm\", \n+\t\"*abs<mode>2_cc\", \"*abs<mode>2_cconly\", \"*abs<mode>2\",\n+\t\"*abs<mode>2_ibm\", \"*negabs<mode>2_cc\", \"*negabs<mode>2_cconly\", \n+\t\"*negabs<mode>2\", \"sqrt<mode>2\"):\n+\tChanged <de> to <xde>. R constraint replaced by <Rf>.\n+\t(\"*mul<mode>3\"): Changed <dee> to <xdee>. R constraint replaced by \n+\t<Rf>.\n+\t(\"fix_trunc<FPR:mode>di2\"): 'FPR:' removed.\n+        (\"*fmadd<mode>\", \"*fmsub<mode>\"): FPR mode replaced by DSF.\n+\t(\"*movtf_64\", \"*movtf_31\"): New insn definitions followed by 5 \n+\tsplitters.\n+\t(\"movtf\", \"reload_outtf\", \"reload_intf\", \"trunctfdf2\", \"trunctfsf2\", \n+\t\"extenddftf2\", \"extendsftf2\"): New expanders.\n+\t(\"*trunctfdf2_ieee\", \"*trunctfdf2_ibm\", \"*trunctfsf2_ieee\", \n+\t\"*trunctfsf2_ibm\", \"*extenddftf2_ieee\", \"*extenddftf2_ibm\",\n+\t\"*extendsftf2_ieee\", \"*extendsftf2_ibm\"): New insn patterns.\n+\t* config/s390/s390.opt (mlong-double-128, mlong-double-64):\n+\tNew options.\n+\t* config/s390/t-crtstuff (TARGET_LIBGCC2_CFLAGS): Macro defined.\n+\t* config/s390/libgcc-glibc.ver (__divtc3, __multc3, __powitf2, \n+\t__fixtfti, __fixunstfti, __floattitf, __fixtfdi, __fixunstfdi,\n+\t__floatditf): Add a GCC_4.1.0 symbol version tag.\n+\t* doc/invoke.texi (-mlong-double-128, -mlong-double-64): Document\n+\tthe new options.\n+\n 2006-02-02  Andrew Pinski  <pinskia@physics.uc.edu>\n \n \tPR target/25377"}, {"sha": "3a4479a293745c9770b38276fb09b48eed588f1e", "filename": "gcc/config/s390/2084.md", "status": "modified", "additions": 40, "deletions": 4, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f61a2c7da855928032ffe9293483c5c9584f7ceb/gcc%2Fconfig%2Fs390%2F2084.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f61a2c7da855928032ffe9293483c5c9584f7ceb/gcc%2Fconfig%2Fs390%2F2084.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2F2084.md?ref=f61a2c7da855928032ffe9293483c5c9584f7ceb", "patch": "@@ -1,5 +1,5 @@\n ;; Scheduling description for z990 (cpu 2084).\n-;;   Copyright (C) 2003,2004, 2005 Free Software Foundation, Inc.\n+;;   Copyright (C) 2003, 2004, 2005, 2006 Free Software Foundation, Inc.\n ;;   Contributed by Hartmut Penner (hpenner@de.ibm.com) and\n ;;                  Ulrich Weigand (uweigand@de.ibm.com).\n \n@@ -161,6 +161,11 @@\n ;; Floating point insns\n ;;\n \n+(define_insn_reservation \"x_fsimptf\" 7 \n+  (and (eq_attr \"cpu\" \"z990,z9_109\")\n+       (eq_attr \"type\" \"fsimptf\"))\n+  \"x_e1_t*2,x-wr-fp\") \n+\n (define_insn_reservation \"x_fsimpdf\" 6 \n   (and (eq_attr \"cpu\" \"z990,z9_109\")\n        (eq_attr \"type\" \"fsimpdf,fmuldf\"))\n@@ -171,6 +176,18 @@\n        (eq_attr \"type\" \"fsimpsf,fmulsf\"))\n   \"x_e1_t,x-wr-fp\") \n \n+\n+(define_insn_reservation \"x_fmultf\" 33\n+  (and (eq_attr \"cpu\" \"z990,z9_109\")\n+       (eq_attr \"type\" \"fmultf\"))\n+  \"x_e1_t*27,x-wr-fp\") \n+\n+\n+(define_insn_reservation \"x_fdivtf\" 82\n+  (and (eq_attr \"cpu\" \"z990,z9_109\")\n+       (eq_attr \"type\" \"fdivtf,fsqrttf\"))\n+  \"x_e1_t*76,x-wr-fp\") \n+\n (define_insn_reservation \"x_fdivdf\" 36\n   (and (eq_attr \"cpu\" \"z990,z9_109\")\n        (eq_attr \"type\" \"fdivdf,fsqrtdf\"))\n@@ -181,6 +198,12 @@\n        (eq_attr \"type\" \"fdivsf,fsqrtsf\"))\n   \"x_e1_t*30,x-wr-fp\") \n \n+\n+(define_insn_reservation \"x_floadtf\" 6 \n+  (and (eq_attr \"cpu\" \"z990,z9_109\")\n+       (eq_attr \"type\" \"floadtf\"))\n+  \"x_e1_t,x-wr-fp\") \n+\n (define_insn_reservation \"x_floaddf\" 6 \n   (and (eq_attr \"cpu\" \"z990,z9_109\")\n        (eq_attr \"type\" \"floaddf\"))\n@@ -191,6 +214,7 @@\n        (eq_attr \"type\" \"floadsf\"))\n   \"x_e1_t,x-wr-fp\") \n \n+\n (define_insn_reservation \"x_fstoredf\" 1 \n   (and (eq_attr \"cpu\" \"z990,z9_109\")\n        (eq_attr \"type\" \"fstoredf\"))\n@@ -201,6 +225,18 @@\n        (eq_attr \"type\" \"fstoresf\"))\n   \"x_e1_t,x-wr-fp\") \n \n+\n+(define_insn_reservation \"x_ftrunctf\" 16\n+  (and (eq_attr \"cpu\" \"z990,z9_109\")\n+       (eq_attr \"type\" \"ftrunctf\"))\n+  \"x_e1_t*10,x-wr-fp\") \n+\n+(define_insn_reservation \"x_ftruncdf\" 11\n+  (and (eq_attr \"cpu\" \"z990,z9_109\")\n+       (eq_attr \"type\" \"ftruncdf\"))\n+  \"x_e1_t*5,x-wr-fp\") \n+\n+\n (define_insn_reservation \"x_ftoi\" 1 \n   (and (eq_attr \"cpu\" \"z990,z9_109\")\n        (eq_attr \"type\" \"ftoi\"))\n@@ -234,7 +270,7 @@\n \t         \"s390_agen_dep_p\")\n \n (define_bypass 9 \"x_int,x_agen,x_lr\" \n-                 \"x_floaddf, x_floadsf, x_fstoredf, x_fstoresf,\\\n+                 \"x_floadtf, x_floaddf, x_floadsf, x_fstoredf, x_fstoresf,\\\n \t\t  x_fsimpdf, x_fsimpsf, x_fdivdf, x_fdivsf\"\n \t         \"s390_agen_dep_p\")\n ;;\n@@ -247,7 +283,7 @@\n \t         \"s390_agen_dep_p\")\n \n (define_bypass 5 \"x_load\"\n-                 \"x_floaddf, x_floadsf, x_fstoredf, x_fstoresf,\\\n+                 \"x_floadtf, x_floaddf, x_floadsf, x_fstoredf, x_fstoresf,\\\n \t\t  x_fsimpdf, x_fsimpsf, x_fdivdf, x_fdivsf\"\n \t         \"s390_agen_dep_p\")\n \n@@ -261,7 +297,7 @@\n \t         \"s390_agen_dep_p\")\n \n (define_bypass 5 \"x_larl, x_la\"\n-                 \"x_floaddf, x_floadsf, x_fstoredf, x_fstoresf,\\\n+                 \"x_floadtf, x_floaddf, x_floadsf, x_fstoredf, x_fstoresf,\\\n \t\t  x_fsimpdf, x_fsimpsf, x_fdivdf, x_fdivsf\"\n \t         \"s390_agen_dep_p\")\n "}, {"sha": "fd12243a381dfd3349bf90e2a52e7394935a0304", "filename": "gcc/config/s390/fixdfdi.h", "status": "modified", "additions": 150, "deletions": 1, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f61a2c7da855928032ffe9293483c5c9584f7ceb/gcc%2Fconfig%2Fs390%2Ffixdfdi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f61a2c7da855928032ffe9293483c5c9584f7ceb/gcc%2Fconfig%2Fs390%2Ffixdfdi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Ffixdfdi.h?ref=f61a2c7da855928032ffe9293483c5c9584f7ceb", "patch": "@@ -20,6 +20,156 @@ along with GCC; see the file COPYING.  If not, write to the Free\n Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n 02110-1301, USA.  */\n \n+#ifdef L_fixunstfdi\n+\n+#define EXPD(fp)\t   (((fp.l.i[0]) >> 16) & 0x7FFF)\n+#define EXPONENT_BIAS\t   16383\n+#define MANTISSA_BITS      112\n+#define PRECISION          (MANTISSA_BITS + 1)\n+#define SIGNBIT\t\t   0x80000000\n+#define SIGND(fp)\t   ((fp.l.i[0]) & SIGNBIT)\n+#define MANTD_HIGH_LL(fp)  ((fp.ll[0] & HIGH_LL_FRAC_MASK) | HIGH_LL_UNIT_BIT)\n+#define MANTD_LOW_LL(fp)   (fp.ll[1])\n+#define FRACD_ZERO_P(fp)   (!fp.ll[1] && !(fp.ll[0] & HIGH_LL_FRAC_MASK))\n+#define HIGH_LL_FRAC_BITS  48\n+#define HIGH_LL_UNIT_BIT   ((UDItype_x)1 << HIGH_LL_FRAC_BITS)\n+#define HIGH_LL_FRAC_MASK  (HIGH_LL_UNIT_BIT - 1)\n+\n+typedef int DItype_x __attribute__ ((mode (DI)));\n+typedef unsigned int UDItype_x __attribute__ ((mode (DI)));\n+typedef int SItype_x __attribute__ ((mode (SI)));\n+typedef unsigned int USItype_x __attribute__ ((mode (SI)));\n+\n+union double_long {\n+  long double d;\n+  struct {\n+      SItype_x i[4]; /* 32 bit parts: 0 upper ... 3 lowest */\n+    } l;\n+  UDItype_x ll[2];   /* 64 bit parts: 0 upper, 1 lower */\n+};\n+\n+UDItype_x __fixunstfdi (long double a1);\n+\n+/* convert double to unsigned int */\n+UDItype_x\n+__fixunstfdi (long double a1)\n+{\n+    register union double_long dl1;\n+    register int exp;\n+    register UDItype_x l;\n+\n+    dl1.d = a1;\n+\n+    /* +/- 0, denormalized, negative */\n+    if (!EXPD (dl1) || SIGND(dl1))\n+      return 0;\n+\n+    /* The exponent - considered the binary point at the right end of \n+       the mantissa.  */\n+    exp = EXPD (dl1) - EXPONENT_BIAS - MANTISSA_BITS;\n+\n+    /* number < 1: If the mantissa would need to be right-shifted more bits than\n+       its size (plus the implied one bit on the left) the result would be \n+       zero.  */\n+    if (exp <= -PRECISION)\n+      return 0;\n+\n+    /* NaN: All exponent bits set and a non-zero fraction.  */\n+    if ((EXPD(dl1) == 0x7fff) && !FRACD_ZERO_P (dl1))\n+      return 0x0ULL;\n+\n+    /* If the upper ll part of the mantissa isn't\n+       zeroed out after shifting the number would be to large.  */\n+    if (exp >= -HIGH_LL_FRAC_BITS)\n+      return 0xFFFFFFFFFFFFFFFFULL;\n+\n+    exp += HIGH_LL_FRAC_BITS + 1;\n+\n+    l = MANTD_LOW_LL (dl1) >> (HIGH_LL_FRAC_BITS + 1)\n+        | MANTD_HIGH_LL (dl1) << (64 - (HIGH_LL_FRAC_BITS + 1));\n+\n+    return l >> -exp;\n+}\n+#define __fixunstfdi ___fixunstfdi\n+#endif\n+#undef L_fixunstfdi\n+\n+#ifdef L_fixtfdi\n+#define EXPD(fp)\t   (((fp.l.i[0]) >> 16) & 0x7FFF)\n+#define EXPONENT_BIAS\t   16383\n+#define MANTISSA_BITS      112\n+#define PRECISION          (MANTISSA_BITS + 1)\n+#define SIGNBIT\t\t   0x80000000\n+#define SIGND(fp)\t   ((fp.l.i[0]) & SIGNBIT)\n+#define MANTD_HIGH_LL(fp)  ((fp.ll[0] & HIGH_LL_FRAC_MASK) | HIGH_LL_UNIT_BIT)\n+#define MANTD_LOW_LL(fp)   (fp.ll[1])\n+#define FRACD_ZERO_P(fp)   (!fp.ll[1] && !(fp.ll[0] & HIGH_LL_FRAC_MASK))\n+#define HIGH_LL_FRAC_BITS  48\n+#define HIGH_LL_UNIT_BIT   ((UDItype_x)1 << HIGH_LL_FRAC_BITS)\n+#define HIGH_LL_FRAC_MASK  (HIGH_LL_UNIT_BIT - 1)\n+\n+typedef int DItype_x __attribute__ ((mode (DI)));\n+typedef unsigned int UDItype_x __attribute__ ((mode (DI)));\n+typedef int SItype_x __attribute__ ((mode (SI)));\n+typedef unsigned int USItype_x __attribute__ ((mode (SI)));\n+\n+union double_long {\n+  long double d;\n+  struct {\n+      SItype_x i[4]; /* 32 bit parts: 0 upper ... 3 lowest */\n+    } l;\n+  DItype_x ll[2];   /* 64 bit parts: 0 upper, 1 lower */\n+};\n+\n+DItype_x __fixtfdi (long double a1);\n+\n+/* convert double to unsigned int */\n+DItype_x\n+__fixtfdi (long double a1)\n+{\n+    register union double_long dl1;\n+    register int exp;\n+    register UDItype_x l;\n+\n+    dl1.d = a1;\n+\n+    /* +/- 0, denormalized */\n+    if (!EXPD (dl1))\n+      return 0;\n+\n+    /* The exponent - considered the binary point at the right end of \n+       the mantissa.  */\n+    exp = EXPD (dl1) - EXPONENT_BIAS - MANTISSA_BITS;\n+\n+    /* number < 1: If the mantissa would need to be right-shifted more bits than\n+       its size the result would be zero.  */\n+    if (exp <= -PRECISION)\n+      return 0;\n+\n+    /* NaN: All exponent bits set and a non-zero fraction.  */\n+    if ((EXPD(dl1) == 0x7fff) && !FRACD_ZERO_P (dl1))\n+      return 0x8000000000000000ULL;\n+\n+    /* If the upper ll part of the mantissa isn't\n+       zeroed out after shifting the number would be to large.  */\n+    if (exp >= -HIGH_LL_FRAC_BITS)\n+      {\n+\tl = (long long)1 << 63; /* long int min */\n+\treturn SIGND (dl1) ? l : l - 1;\n+      }\n+\n+    /* The extra bit is needed for the sign bit.  */\n+    exp += HIGH_LL_FRAC_BITS + 1;\n+\n+    l = MANTD_LOW_LL (dl1) >> (HIGH_LL_FRAC_BITS + 1)\n+        | MANTD_HIGH_LL (dl1) << (64 - (HIGH_LL_FRAC_BITS + 1));\n+\n+    return SIGND (dl1) ? -(l >> -exp) : l >> -exp;\n+}\n+#define __fixtfdi ___fixtfdi\n+#endif\n+#undef L_fixtfdi\n+\n #ifdef L_fixunsdfdi\n #define EXPD(fp)\t(((fp.l.upper) >> 20) & 0x7FF)\n #define EXCESSD\t\t1022\n@@ -305,4 +455,3 @@ __fixsfdi (float a1)\n #define __fixsfdi ___fixsfdi\n #endif\n #undef L_fixsfdi\n-"}, {"sha": "e9413d0fff1e6d12762a90bd77c7584d6c231edc", "filename": "gcc/config/s390/libgcc-glibc.ver", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f61a2c7da855928032ffe9293483c5c9584f7ceb/gcc%2Fconfig%2Fs390%2Flibgcc-glibc.ver", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f61a2c7da855928032ffe9293483c5c9584f7ceb/gcc%2Fconfig%2Fs390%2Flibgcc-glibc.ver", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Flibgcc-glibc.ver?ref=f61a2c7da855928032ffe9293483c5c9584f7ceb", "patch": "@@ -39,3 +39,36 @@ GLIBC_2.2 {\n }\n %endif\n \n+# With GCC 4.1.0 long double 128 bit support was introduced. The\n+# following symbols coming from libgcc are enabled when -mlong-double-128\n+# is specified. These lines make the symbols to get a @@GCC_4.1.0 attached.\n+\n+%exclude {\n+  __divtc3\n+  __multc3\n+  __powitf2\n+  __fixtfti\n+  __fixunstfti\n+  __floattitf\n+\n+  __fixtfdi\n+  __fixunstfdi\n+  __floatditf\n+}\n+\n+GCC_4.1.0 {\n+  __divtc3\n+  __multc3\n+  __powitf2\n+\n+%ifdef __s390x__\n+  __fixtfti\n+  __fixunstfti\n+  __floattitf\n+\n+%else\n+  __fixtfdi\n+  __fixunstfdi\n+  __floatditf\n+%endif\n+}"}, {"sha": "dfefaca21fcf383e21cef29aef22f047f4660a6b", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 51, "deletions": 5, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f61a2c7da855928032ffe9293483c5c9584f7ceb/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f61a2c7da855928032ffe9293483c5c9584f7ceb/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=f61a2c7da855928032ffe9293483c5c9584f7ceb", "patch": "@@ -1,5 +1,5 @@\n /* Subroutines used for code generation on IBM S/390 and zSeries\n-   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005\n+   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006\n    Free Software Foundation, Inc.\n    Contributed by Hartmut Penner (hpenner@de.ibm.com) and\n                   Ulrich Weigand (uweigand@de.ibm.com).\n@@ -71,13 +71,17 @@ struct processor_costs\n   const int msgr;     /* cost of an MSGR instruction.  */\n   const int msr;      /* cost of an MSR instruction.  */\n   const int mult_df;  /* cost of multiplication in DFmode.  */\n+  const int mxbr;\n   /* square root */\n+  const int sqxbr;    /* cost of square root in TFmode.  */\n   const int sqdbr;    /* cost of square root in DFmode.  */\n   const int sqebr;    /* cost of square root in SFmode.  */\n   /* multiply and add */\n   const int madbr;    /* cost of multiply and add in DFmode.  */\n   const int maebr;    /* cost of multiply and add in SFmode.  */\n   /* division */\n+  const int dxbr;\n+  const int dxr;\n   const int ddbr;\n   const int ddr;\n   const int debr;\n@@ -107,10 +111,14 @@ struct processor_costs z900_cost =\n   COSTS_N_INSNS (10),    /* MSGR  */\n   COSTS_N_INSNS (4),     /* MSR   */\n   COSTS_N_INSNS (7),     /* multiplication in DFmode */\n+  COSTS_N_INSNS (13),    /* MXBR */\n+  COSTS_N_INSNS (136),   /* SQXBR */\n   COSTS_N_INSNS (44),    /* SQDBR */\n   COSTS_N_INSNS (35),    /* SQEBR */\n   COSTS_N_INSNS (18),    /* MADBR */\n   COSTS_N_INSNS (13),    /* MAEBR */\n+  COSTS_N_INSNS (134),   /* DXBR */\n+  COSTS_N_INSNS (135),   /* DXR */\n   COSTS_N_INSNS (30),    /* DDBR */\n   COSTS_N_INSNS (30),    /* DDR  */\n   COSTS_N_INSNS (27),    /* DEBR */\n@@ -138,10 +146,14 @@ struct processor_costs z990_cost =\n   COSTS_N_INSNS (4),     /* MSGR  */\n   COSTS_N_INSNS (4),     /* MSR   */\n   COSTS_N_INSNS (1),     /* multiplication in DFmode */\n+  COSTS_N_INSNS (28),    /* MXBR */\n+  COSTS_N_INSNS (130),   /* SQXBR */\n   COSTS_N_INSNS (66),    /* SQDBR */\n   COSTS_N_INSNS (38),    /* SQEBR */\n   COSTS_N_INSNS (1),     /* MADBR */\n   COSTS_N_INSNS (1),     /* MAEBR */\n+  COSTS_N_INSNS (60),    /* DXBR */\n+  COSTS_N_INSNS (72),    /* DXR */\n   COSTS_N_INSNS (40),    /* DDBR */\n   COSTS_N_INSNS (44),    /* DDR  */\n   COSTS_N_INSNS (26),    /* DDBR */\n@@ -169,10 +181,14 @@ struct processor_costs z9_109_cost =\n   COSTS_N_INSNS (4),     /* MSGR  */\n   COSTS_N_INSNS (4),     /* MSR   */\n   COSTS_N_INSNS (1),     /* multiplication in DFmode */\n+  COSTS_N_INSNS (28),    /* MXBR */\n+  COSTS_N_INSNS (130),   /* SQXBR */\n   COSTS_N_INSNS (66),    /* SQDBR */\n   COSTS_N_INSNS (38),    /* SQEBR */\n   COSTS_N_INSNS (1),     /* MADBR */\n   COSTS_N_INSNS (1),     /* MAEBR */\n+  COSTS_N_INSNS (60),    /* DXBR */\n+  COSTS_N_INSNS (72),    /* DXR */\n   COSTS_N_INSNS (40),    /* DDBR */\n   COSTS_N_INSNS (37),    /* DDR  */\n   COSTS_N_INSNS (26),    /* DDBR */\n@@ -2159,6 +2175,9 @@ s390_rtx_costs (rtx x, int code, int outer_code, int *total)\n \tcase DFmode:\n \t  *total = s390_cost->mult_df;\n \t  break;\n+\tcase TFmode:\n+\t  *total = s390_cost->mxbr;\n+\t  break;\n \tdefault:\n \t  return false;\n \t}\n@@ -2209,13 +2228,22 @@ s390_rtx_costs (rtx x, int code, int outer_code, int *total)\n \t  else /* TARGET_IBM_FLOAT */\n \t    *total = s390_cost->ddr;\n \t}\n+      else if (GET_MODE (x) == TFmode)\n+\t{\n+\t  if (TARGET_IEEE_FLOAT)\n+\t    *total = s390_cost->dxbr;\n+\t  else /* TARGET_IBM_FLOAT */\n+\t    *total = s390_cost->dxr;\n+\t}\n       return false;\n \n     case SQRT:\n       if (GET_MODE (x) == SFmode)\n \t*total = s390_cost->sqebr;\n-      else /* DFmode */\n+      else if (GET_MODE (x) == DFmode)\n \t*total = s390_cost->sqdbr;\n+      else /* TFmode */\n+\t*total = s390_cost->sqxbr;\n       return false;\n \n     case SIGN_EXTEND:\n@@ -2570,6 +2598,15 @@ s390_secondary_input_reload_class (enum reg_class class,\n   if (s390_plus_operand (in, mode))\n     return ADDR_REGS;\n \n+  if (reg_classes_intersect_p (FP_REGS, class)\n+      && mode == TFmode\n+      && GET_CODE (in) == MEM\n+      && GET_CODE (XEXP (in, 0)) == PLUS\n+      && GET_CODE (XEXP (XEXP (in, 0), 1)) == CONST_INT\n+      && !DISP_IN_RANGE (INTVAL (XEXP (XEXP (in, 0), 1))\n+\t\t\t + GET_MODE_SIZE (mode) - 1))\n+    return ADDR_REGS;\n+\n   if (reg_classes_intersect_p (CC_REGS, class))\n     return GENERAL_REGS;\n \n@@ -2586,7 +2623,7 @@ enum reg_class\n s390_secondary_output_reload_class (enum reg_class class,\n \t\t\t\t    enum machine_mode mode, rtx out)\n {\n-  if ((TARGET_64BIT ? mode == TImode\n+  if ((TARGET_64BIT ? (mode == TImode || mode == TFmode)\n                     : (mode == DImode || mode == DFmode))\n       && reg_classes_intersect_p (GENERAL_REGS, class)\n       && GET_CODE (out) == MEM\n@@ -2597,6 +2634,15 @@ s390_secondary_output_reload_class (enum reg_class class,\n \t\t\t + GET_MODE_SIZE (mode) - 1))\n     return ADDR_REGS;\n \n+  if (reg_classes_intersect_p (FP_REGS, class)\n+      && mode == TFmode\n+      && GET_CODE (out) == MEM\n+      && GET_CODE (XEXP (out, 0)) == PLUS\n+      && GET_CODE (XEXP (XEXP (out, 0), 1)) == CONST_INT\n+      && !DISP_IN_RANGE (INTVAL (XEXP (XEXP (out, 0), 1))\n+\t\t\t + GET_MODE_SIZE (mode) - 1))\n+    return ADDR_REGS;\n+\n   if (reg_classes_intersect_p (CC_REGS, class))\n     return GENERAL_REGS;\n \n@@ -5169,10 +5215,10 @@ replace_ltrel_base (rtx *x)\n /* We keep a list of constants which we have to add to internal\n    constant tables in the middle of large functions.  */\n \n-#define NR_C_MODES 7\n+#define NR_C_MODES 8\n enum machine_mode constant_modes[NR_C_MODES] =\n {\n-  TImode,\n+  TFmode, TImode,\n   DFmode, DImode,\n   SFmode, SImode,\n   HImode,"}, {"sha": "1a61158ba0416aa4847a300c919e30823ff94255", "filename": "gcc/config/s390/s390.h", "status": "modified", "additions": 35, "deletions": 13, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f61a2c7da855928032ffe9293483c5c9584f7ceb/gcc%2Fconfig%2Fs390%2Fs390.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f61a2c7da855928032ffe9293483c5c9584f7ceb/gcc%2Fconfig%2Fs390%2Fs390.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.h?ref=f61a2c7da855928032ffe9293483c5c9584f7ceb", "patch": "@@ -1,5 +1,5 @@\n /* Definitions of target machine for GNU compiler, for IBM S/390\n-   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005\n+   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006\n    Free Software Foundation, Inc.\n    Contributed by Hartmut Penner (hpenner@de.ibm.com) and\n                   Ulrich Weigand (uweigand@de.ibm.com).\n@@ -93,6 +93,8 @@ extern enum processor_flags s390_arch_flags;\n       builtin_define (\"__s390__\");\t\t\t\\\n       if (TARGET_64BIT)\t\t\t\t\t\\\n         builtin_define (\"__s390x__\");\t\t\t\\\n+      if (TARGET_LONG_DOUBLE_128)\t\t\t\\\n+        builtin_define (\"__LONG_DOUBLE_128__\");\t\t\\\n     }\t\t\t\t\t\t\t\\\n   while (0)\n \n@@ -216,7 +218,18 @@ if (INTEGRAL_MODE_P (MODE) &&\t        \t    \t\\\n #define LONG_LONG_TYPE_SIZE 64\n #define FLOAT_TYPE_SIZE 32\n #define DOUBLE_TYPE_SIZE 64\n-#define LONG_DOUBLE_TYPE_SIZE 64  /* ??? Should support extended format.  */\n+#define LONG_DOUBLE_TYPE_SIZE (TARGET_LONG_DOUBLE_128 ? 128 : 64)\n+\n+/* Define this to set long double type size to use in libgcc2.c, which can\n+   not depend on target_flags.  */\n+#ifdef __LONG_DOUBLE_128__\n+#define LIBGCC2_LONG_DOUBLE_TYPE_SIZE 128\n+#else\n+#define LIBGCC2_LONG_DOUBLE_TYPE_SIZE 64\n+#endif\n+\n+/* Work around target_flags dependency in ada/targtyps.c.  */\n+#define WIDEST_HARDWARE_FP_SIZE 64\n \n /* We use \"unsigned char\" as default.  */\n #define DEFAULT_SIGNED_CHAR 0\n@@ -334,28 +347,34 @@ if (INTEGRAL_MODE_P (MODE) &&\t        \t    \t\\\n    Floating point modes <= word size fit into any FPR or GPR.\n    Floating point modes > word size (i.e. DFmode on 32-bit) fit\n    into any FPR, or an even-odd GPR pair.\n+   TFmode fits only into an even-odd FPR pair.\n \n    Complex floating point modes fit either into two FPRs, or into\n    successive GPRs (again starting with an even number).\n+   TCmode fits only into two successive even-odd FPR pairs.\n \n    Condition code modes fit only into the CC register.  */\n \n #define HARD_REGNO_NREGS(REGNO, MODE)                           \\\n   (FP_REGNO_P(REGNO)?                                           \\\n-    (GET_MODE_CLASS(MODE) == MODE_COMPLEX_FLOAT ? 2 : 1) :      \\\n+   (GET_MODE_CLASS(MODE) == MODE_COMPLEX_FLOAT ?                \\\n+    2 * ((GET_MODE_SIZE(MODE) / 2 + 8 - 1) / 8) : \t\t\\\n+    ((GET_MODE_SIZE(MODE) + 8 - 1) / 8)) :\t\t\t\\\n    GENERAL_REGNO_P(REGNO)?                                      \\\n     ((GET_MODE_SIZE(MODE)+UNITS_PER_WORD-1) / UNITS_PER_WORD) : \\\n    ACCESS_REGNO_P(REGNO)?\t\t\t\t\t\\\n-    ((GET_MODE_SIZE(MODE)+4-1) / 4) : \t\t\t\t\\\n+    ((GET_MODE_SIZE(MODE) + 4 - 1) / 4) : \t\t\t\\\n    1)\n \n #define HARD_REGNO_MODE_OK(REGNO, MODE)                             \\\n   (FP_REGNO_P(REGNO)?                                               \\\n-   ((MODE) == SImode || (MODE) == DImode ||                         \\\n-    GET_MODE_CLASS(MODE) == MODE_FLOAT ||                           \\\n-    GET_MODE_CLASS(MODE) == MODE_COMPLEX_FLOAT) :                   \\\n+   (((MODE) == SImode || (MODE) == DImode                           \\\n+     || GET_MODE_CLASS(MODE) == MODE_FLOAT                          \\\n+     || GET_MODE_CLASS(MODE) == MODE_COMPLEX_FLOAT)                 \\\n+    && (HARD_REGNO_NREGS(REGNO, MODE) == 1 || !((REGNO) & 1))) :    \\\n    GENERAL_REGNO_P(REGNO)?                                          \\\n-    (HARD_REGNO_NREGS(REGNO, MODE) == 1 || !((REGNO) & 1)) :        \\\n+   ((HARD_REGNO_NREGS(REGNO, MODE) == 1 || !((REGNO) & 1))\t    \\\n+    && (((MODE) != TFmode && (MODE) != TCmode) || TARGET_64BIT)) :  \\\n    CC_REGNO_P(REGNO)?                                               \\\n      GET_MODE_CLASS (MODE) == MODE_CC :                             \\\n    FRAME_REGNO_P(REGNO)?                                            \\\n@@ -376,7 +395,9 @@ if (INTEGRAL_MODE_P (MODE) &&\t        \t    \t\\\n    in a register of class CLASS.  */\n #define CLASS_MAX_NREGS(CLASS, MODE)   \t\t\t\t\t\\\n      ((CLASS) == FP_REGS ? \t\t\t\t\t\t\\\n-      (GET_MODE_CLASS (MODE) == MODE_COMPLEX_FLOAT ? 2 : 1) :  \t\t\\\n+      (GET_MODE_CLASS(MODE) == MODE_COMPLEX_FLOAT ?                     \\\n+       2 * (GET_MODE_SIZE (MODE) / 2 + 8 - 1) / 8 :\t\t        \\\n+       (GET_MODE_SIZE (MODE) + 8 - 1) / 8) :\t\t\t\t\\\n       (CLASS) == ACCESS_REGS ?\t\t\t\t\t\t\\\n       (GET_MODE_SIZE (MODE) + 4 - 1) / 4 :\t\t\t\t\\\n       (GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n@@ -386,10 +407,11 @@ if (INTEGRAL_MODE_P (MODE) &&\t        \t    \t\\\n    cannot use SUBREGs to switch between modes in FP registers.\n    Likewise for access registers, since they have only half the\n    word size on 64-bit.  */\n-#define CANNOT_CHANGE_MODE_CLASS(FROM, TO, CLASS)\t\t\\\n-  (GET_MODE_SIZE (FROM) != GET_MODE_SIZE (TO)\t\t\t\\\n-   ? reg_classes_intersect_p (FP_REGS, CLASS)\t\t\t\\\n-     || reg_classes_intersect_p (ACCESS_REGS, CLASS) : 0)\n+#define CANNOT_CHANGE_MODE_CLASS(FROM, TO, CLASS)\t\t        \\\n+  (GET_MODE_SIZE (FROM) != GET_MODE_SIZE (TO)\t\t\t        \\\n+   ? ((reg_classes_intersect_p (FP_REGS, CLASS)\t\t\t\t\\\n+       && (GET_MODE_SIZE (FROM) < 8 || GET_MODE_SIZE (TO) < 8))\t\t\\\n+      || reg_classes_intersect_p (ACCESS_REGS, CLASS)) : 0)\n \n /* Register classes.  */\n "}, {"sha": "0f3e562be20a09cb45cd204947857e45d93e9533", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 406, "deletions": 121, "changes": 527, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f61a2c7da855928032ffe9293483c5c9584f7ceb/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f61a2c7da855928032ffe9293483c5c9584f7ceb/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=f61a2c7da855928032ffe9293483c5c9584f7ceb", "patch": "@@ -1,5 +1,5 @@\n ;;- Machine description for GNU compiler -- S/390 / zSeries version.\n-;;  Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005\n+;;  Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006\n ;;  Free Software Foundation, Inc.\n ;;  Contributed by Hartmut Penner (hpenner@de.ibm.com) and\n ;;                 Ulrich Weigand (uweigand@de.ibm.com).\n@@ -199,11 +199,11 @@\n (define_attr \"type\" \"none,integer,load,lr,la,larl,lm,stm,\n \t             cs,vs,store,sem,idiv,\n                      imulhi,imulsi,imuldi,\n-\t\t     branch,jsr,fsimpdf,fsimpsf,\n-\t\t     floaddf,floadsf,fstoredf,fstoresf,\n-\t\t     fmuldf,fmulsf,fdivdf,fdivsf,\n-\t\t     ftoi,itof,fsqrtdf,fsqrtsf,\n-                     other\"\n+\t\t     branch,jsr,fsimptf,fsimpdf,fsimpsf,\n+\t\t     floadtf,floaddf,floadsf,fstoredf,fstoresf,\n+\t\t     fmultf,fmuldf,fmulsf,fdivtf,fdivdf,fdivsf,\n+\t\t     ftoi,itof,fsqrttf,fsqrtdf,fsqrtsf,\n+                     ftrunctf,ftruncdf,other\"\n   (cond [(eq_attr \"op_type\" \"NN\")  (const_string \"other\")\n          (eq_attr \"op_type\" \"SS\")  (const_string \"cs\")]\n     (const_string \"integer\")))\n@@ -248,9 +248,10 @@\n \n ;; Macros\n \n-;; This mode macro allows DF and SF patterns to be generated from the\n+;; This mode macro allows floating point patterns to be generated from the\n ;; same template.\n-(define_mode_macro FPR     [DF SF])\n+(define_mode_macro FPR [TF DF SF])\n+(define_mode_macro DSF [DF SF])\n \n ;; These mode macros allow 31-bit and 64-bit TDSI patterns to be generated\n ;; from the same template.\n@@ -291,13 +292,22 @@\n \t\t\t  (plus \"add\") (minus \"sub\") (mult \"nand\")])\n \n \n-;; In FPR templates, a string like \"lt<de>br\" will expand to \"ltdbr\" in DFmode\n-;; and \"ltebr\" in SFmode.\n-(define_mode_attr de [(DF \"d\") (SF \"e\")])\n+;; In FPR templates, a string like \"lt<de>br\" will expand to \"ltxbr\" in TFmode,\n+;; \"ltdbr\" in DFmode, and \"ltebr\" in SFmode.\n+(define_mode_attr xde [(TF \"x\") (DF \"d\") (SF \"e\")])\n \n-;; In FPR templates, a string like \"m<dee>br\" will expand to \"mdbr\" in DFmode\n-;; and \"meebr\" in SFmode.  This is needed for the 'mul<mode>3' pattern. \n-(define_mode_attr dee [(DF \"d\") (SF \"ee\")])\n+;; In FPR templates, a string like \"m<dee>br\" will expand to \"mxbr\" in TFmode,\n+;; \"mdbr\" in DFmode, and \"meebr\" in SFmode.\n+(define_mode_attr xdee [(TF \"x\") (DF \"d\") (SF \"ee\")])\n+\n+;; In FPR templates, \"<RRe>\" will expand to \"RRE\" in TFmode and \"RR\" otherwise.\n+;; Likewise for \"<RXe>\".\n+(define_mode_attr RRe [(TF \"RRE\") (DF \"RR\") (SF \"RR\")])\n+(define_mode_attr RXe [(TF \"RXE\") (DF \"RX\") (SF \"RX\")])\n+\n+;; In FPR templates, \"<Rf>\" will expand to \"f\" in TFmode and \"R\" otherwise.\n+;; This is used to disable the memory alternative in TFmode patterns.\n+(define_mode_attr Rf [(TF \"f\") (DF \"R\") (SF \"R\")])\n \n ;; In GPR and P templates, a constraint like \"<d0>\" will expand to \"d\" in DImode\n ;; and \"0\" in SImode. This allows to combine instructions of which the 31bit\n@@ -769,7 +779,7 @@\n         (compare (match_operand:FPR 0 \"register_operand\" \"f\")\n                  (match_operand:FPR 1 \"const0_operand\" \"\")))]\n   \"s390_match_ccmode(insn, CCSmode) && TARGET_HARD_FLOAT && TARGET_IEEE_FLOAT\"\n-  \"lt<de>br\\t%0,%0\"\n+  \"lt<xde>br\\t%0,%0\"\n    [(set_attr \"op_type\" \"RRE\")\n     (set_attr \"type\"  \"fsimp<mode>\")])\n \n@@ -778,30 +788,30 @@\n         (compare (match_operand:FPR 0 \"register_operand\" \"f\")\n                  (match_operand:FPR 1 \"const0_operand\" \"\")))]\n   \"s390_match_ccmode(insn, CCSmode) && TARGET_HARD_FLOAT && TARGET_IBM_FLOAT\"\n-  \"lt<de>r\\t%0,%0\"\n-   [(set_attr \"op_type\" \"RR\")\n+  \"lt<xde>r\\t%0,%0\"\n+   [(set_attr \"op_type\" \"<RRe>\")\n     (set_attr \"type\"  \"fsimp<mode>\")])\n \n (define_insn \"*cmp<mode>_ccs\"\n   [(set (reg CC_REGNUM)\n         (compare (match_operand:FPR 0 \"register_operand\" \"f,f\")\n-                 (match_operand:FPR 1 \"general_operand\" \"f,R\")))]\n+                 (match_operand:FPR 1 \"general_operand\" \"f,<Rf>\")))]\n   \"s390_match_ccmode(insn, CCSmode) && TARGET_HARD_FLOAT && TARGET_IEEE_FLOAT\"\n   \"@\n-   c<de>br\\t%0,%1\n-   c<de>b\\t%0,%1\"\n+   c<xde>br\\t%0,%1\n+   c<xde>b\\t%0,%1\"\n    [(set_attr \"op_type\" \"RRE,RXE\")\n     (set_attr \"type\"  \"fsimp<mode>\")])\n \n (define_insn \"*cmp<mode>_ccs_ibm\"\n   [(set (reg CC_REGNUM)\n         (compare (match_operand:FPR 0 \"register_operand\" \"f,f\")\n-                 (match_operand:FPR 1 \"general_operand\" \"f,R\")))]\n+                 (match_operand:FPR 1 \"general_operand\" \"f,<Rf>\")))]\n   \"s390_match_ccmode(insn, CCSmode) && TARGET_HARD_FLOAT && TARGET_IBM_FLOAT\"\n   \"@\n-   c<de>r\\t%0,%1\n-   c<de>\\t%0,%1\"\n-   [(set_attr \"op_type\" \"RR,RX\")\n+   c<xde>r\\t%0,%1\n+   c<xde>\\t%0,%1\"\n+   [(set_attr \"op_type\" \"<RRe>,<RXe>\")\n     (set_attr \"type\"  \"fsimp<mode>\")])\n \n \n@@ -1435,6 +1445,149 @@\n   [(set_attr \"op_type\" \"RR,RX,RXY,RRE\")\n    (set_attr \"type\" \"lr,load,load,*\")])\n \n+;\n+; movtf instruction pattern(s).\n+;\n+\n+(define_expand \"movtf\"\n+  [(set (match_operand:TF 0 \"nonimmediate_operand\" \"\")\n+        (match_operand:TF 1 \"general_operand\"       \"\"))]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"*movtf_64\"\n+  [(set (match_operand:TF 0 \"nonimmediate_operand\" \"=f,f,f,o,d,QS,d,o,Q\")\n+        (match_operand:TF 1 \"general_operand\"       \"G,f,o,f,QS,d,dm,d,Q\"))]\n+  \"TARGET_64BIT\"\n+  \"@\n+   lzxr\\t%0\n+   lxr\\t%0,%1\n+   #\n+   #\n+   lmg\\t%0,%N0,%S1\n+   stmg\\t%1,%N1,%S0\n+   #\n+   #\n+   #\"\n+  [(set_attr \"op_type\" \"RRE,RRE,*,*,RSY,RSY,*,*,*\")\n+   (set_attr \"type\"    \"fsimptf,fsimptf,*,*,lm,stm,*,*,*\")])\n+\n+(define_insn \"*movtf_31\"\n+  [(set (match_operand:TF 0 \"nonimmediate_operand\" \"=f,f,f,o,Q\")\n+        (match_operand:TF 1 \"general_operand\"       \"G,f,o,f,Q\"))]\n+  \"!TARGET_64BIT\"\n+  \"@\n+   lzxr\\t%0\n+   lxr\\t%0,%1\n+   #\n+   #\n+   #\"\n+  [(set_attr \"op_type\" \"RRE,RRE,*,*,*\")\n+   (set_attr \"type\"    \"fsimptf,fsimptf,*,*,*\")])\n+\n+; TFmode in GPRs splitters\n+\n+(define_split\n+  [(set (match_operand:TF 0 \"nonimmediate_operand\" \"\")\n+        (match_operand:TF 1 \"general_operand\" \"\"))]\n+  \"TARGET_64BIT && reload_completed\n+   && s390_split_ok_p (operands[0], operands[1], TFmode, 0)\"\n+  [(set (match_dup 2) (match_dup 4))\n+   (set (match_dup 3) (match_dup 5))]\n+{\n+  operands[2] = operand_subword (operands[0], 0, 0, TFmode);\n+  operands[3] = operand_subword (operands[0], 1, 0, TFmode);\n+  operands[4] = operand_subword (operands[1], 0, 0, TFmode);\n+  operands[5] = operand_subword (operands[1], 1, 0, TFmode);\n+})\n+\n+(define_split\n+  [(set (match_operand:TF 0 \"nonimmediate_operand\" \"\")\n+        (match_operand:TF 1 \"general_operand\" \"\"))]\n+  \"TARGET_64BIT && reload_completed\n+   && s390_split_ok_p (operands[0], operands[1], TFmode, 1)\"\n+  [(set (match_dup 2) (match_dup 4))\n+   (set (match_dup 3) (match_dup 5))]\n+{\n+  operands[2] = operand_subword (operands[0], 1, 0, TFmode);\n+  operands[3] = operand_subword (operands[0], 0, 0, TFmode);\n+  operands[4] = operand_subword (operands[1], 1, 0, TFmode);\n+  operands[5] = operand_subword (operands[1], 0, 0, TFmode);\n+})\n+\n+(define_split\n+  [(set (match_operand:TF 0 \"register_operand\" \"\")\n+        (match_operand:TF 1 \"memory_operand\" \"\"))]\n+  \"TARGET_64BIT && reload_completed\n+   && !FP_REG_P (operands[0])\n+   && !s_operand (operands[1], VOIDmode)\"\n+  [(set (match_dup 0) (match_dup 1))]\n+{\n+  rtx addr = operand_subword (operands[0], 1, 0, DFmode);\n+  s390_load_address (addr, XEXP (operands[1], 0));\n+  operands[1] = replace_equiv_address (operands[1], addr);\n+})\n+\n+; TFmode in FPRs splitters\n+\n+(define_split\n+  [(set (match_operand:TF 0 \"register_operand\" \"\")\n+        (match_operand:TF 1 \"memory_operand\" \"\"))]\n+  \"reload_completed && offsettable_memref_p (operands[1]) \n+   && FP_REG_P (operands[0])\"\n+  [(set (match_dup 2) (match_dup 4))\n+   (set (match_dup 3) (match_dup 5))]\n+{\n+  operands[2] = simplify_gen_subreg (DFmode, operands[0], TFmode, 0);\n+  operands[3] = simplify_gen_subreg (DFmode, operands[0], TFmode, 8);\n+  operands[4] = adjust_address_nv (operands[1], DFmode, 0);\n+  operands[5] = adjust_address_nv (operands[1], DFmode, 8);\n+})\n+\n+(define_split\n+  [(set (match_operand:TF 0 \"memory_operand\" \"\")\n+        (match_operand:TF 1 \"register_operand\" \"\"))]\n+  \"reload_completed && offsettable_memref_p (operands[0])\n+   && FP_REG_P (operands[1])\"\n+  [(set (match_dup 2) (match_dup 4))\n+   (set (match_dup 3) (match_dup 5))]\n+{\n+  operands[2] = adjust_address_nv (operands[0], DFmode, 0);\n+  operands[3] = adjust_address_nv (operands[0], DFmode, 8);\n+  operands[4] = simplify_gen_subreg (DFmode, operands[1], TFmode, 0);\n+  operands[5] = simplify_gen_subreg (DFmode, operands[1], TFmode, 8);\n+})\n+\n+(define_expand \"reload_outtf\"\n+  [(parallel [(match_operand:TF 0 \"\" \"\")\n+              (match_operand:TF 1 \"register_operand\" \"f\")\n+              (match_operand:SI 2 \"register_operand\" \"=&a\")])]\n+  \"\"\n+{\n+  rtx addr = gen_lowpart (Pmode, operands[2]);\n+\n+  gcc_assert (MEM_P (operands[0]));\n+  s390_load_address (addr, find_replacement (&XEXP (operands[0], 0)));\n+  operands[0] = replace_equiv_address (operands[0], addr);\n+  emit_move_insn (operands[0], operands[1]);\n+  DONE;\n+})\n+\n+(define_expand \"reload_intf\"\n+  [(parallel [(match_operand:TF 0 \"register_operand\" \"=f\")\n+              (match_operand:TF 1 \"\" \"\")\n+              (match_operand:SI 2 \"register_operand\" \"=&a\")])]\n+  \"\"\n+{\n+  rtx addr = gen_lowpart (Pmode, operands[2]);\n+ \n+  gcc_assert (MEM_P (operands[1]));\n+  s390_load_address (addr, find_replacement (&XEXP (operands[1], 0)));\n+  operands[1] = replace_equiv_address (operands[1], addr);\n+  emit_move_insn (operands[0], operands[1]);\n+  DONE;\n+})\n+\n ;\n ; movdf instruction pattern(s).\n ;\n@@ -2972,13 +3125,13 @@\n   DONE;\n })\n \n-(define_expand \"fix_trunc<FPR:mode>di2\"\n+(define_expand \"fix_trunc<mode>di2\"\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n-        (fix:DI (match_operand:FPR 1 \"nonimmediate_operand\" \"\")))]\n+        (fix:DI (match_operand:DSF 1 \"nonimmediate_operand\" \"\")))]\n   \"TARGET_64BIT && TARGET_HARD_FLOAT && TARGET_IEEE_FLOAT\"\n {\n-  operands[1] = force_reg (<FPR:MODE>mode, operands[1]);\n-  emit_insn (gen_fix_trunc<FPR:mode>di2_ieee (operands[0], operands[1],\n+  operands[1] = force_reg (<MODE>mode, operands[1]);\n+  emit_insn (gen_fix_trunc<mode>di2_ieee (operands[0], operands[1],\n       GEN_INT(5)));\n   DONE;\n })\n@@ -2989,10 +3142,22 @@\n    (unspec:GPR [(match_operand:GPR 2 \"immediate_operand\" \"K\")] UNSPEC_ROUND)\n    (clobber (reg:CC CC_REGNUM))]\n   \"TARGET_HARD_FLOAT && TARGET_IEEE_FLOAT\"\n-  \"c<GPR:gf><FPR:de>br\\t%0,%h2,%1\"\n+  \"c<GPR:gf><FPR:xde>br\\t%0,%h2,%1\"\n   [(set_attr \"op_type\" \"RRE\")\n    (set_attr \"type\"    \"ftoi\")])\n \n+;\n+; fix_trunctf(si|di)2 instruction pattern(s).\n+;\n+\n+(define_expand \"fix_trunctf<mode>2\"\n+  [(parallel [(set (match_operand:GPR 0 \"register_operand\" \"\")\n+\t\t   (fix:GPR (match_operand:TF 1 \"register_operand\" \"\")))\n+\t      (unspec:GPR [(const_int 5)] UNSPEC_ROUND)\n+\t      (clobber (reg:CC CC_REGNUM))])]\n+  \"TARGET_HARD_FLOAT && TARGET_IEEE_FLOAT\"\n+  \"\")\n+\n ;\n ; fix_truncdfsi2 instruction pattern(s).\n ;\n@@ -3066,21 +3231,36 @@\n })\n \n ;\n-; floatdi(df|sf)2 instruction pattern(s).\n+; float(si|di)(tf|df|sf)2 instruction pattern(s).\n ;\n \n (define_insn \"floatdi<mode>2\"\n   [(set (match_operand:FPR 0 \"register_operand\" \"=f\")\n         (float:FPR (match_operand:DI 1 \"register_operand\" \"d\")))]\n   \"TARGET_64BIT && TARGET_HARD_FLOAT && TARGET_IEEE_FLOAT\"\n-  \"c<de>gbr\\t%0,%1\"\n+  \"c<xde>gbr\\t%0,%1\"\n   [(set_attr \"op_type\" \"RRE\")\n    (set_attr \"type\"    \"itof\" )])\n \n+(define_insn \"floatsi<mode>2_ieee\"\n+  [(set (match_operand:FPR 0 \"register_operand\" \"=f\")\n+        (float:FPR (match_operand:SI 1 \"register_operand\" \"d\")))]\n+  \"TARGET_HARD_FLOAT && TARGET_IEEE_FLOAT\"\n+  \"c<xde>fbr\\t%0,%1\"\n+  [(set_attr \"op_type\" \"RRE\")\n+   (set_attr \"type\"   \"itof\" )])\n+\n+\n ;\n-; floatsidf2 instruction pattern(s).\n+; floatsi(tf|df)2 instruction pattern(s).\n ;\n \n+(define_expand \"floatsitf2\"\n+  [(set (match_operand:TF 0 \"register_operand\" \"\")\n+        (float:TF (match_operand:SI 1 \"register_operand\" \"\")))]\n+  \"TARGET_HARD_FLOAT && TARGET_IEEE_FLOAT\"\n+  \"\")\n+\n (define_expand \"floatsidf2\"\n   [(set (match_operand:DF 0 \"register_operand\" \"\")\n         (float:DF (match_operand:SI 1 \"register_operand\" \"\")))]\n@@ -3098,14 +3278,6 @@\n     }\n })\n \n-(define_insn \"floatsidf2_ieee\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n-        (float:DF (match_operand:SI 1 \"register_operand\" \"d\")))]\n-  \"TARGET_HARD_FLOAT && TARGET_IEEE_FLOAT\"\n-  \"cdfbr\\t%0,%1\"\n-  [(set_attr \"op_type\" \"RRE\")\n-   (set_attr \"type\"   \"itof\" )])\n-\n (define_insn \"floatsidf2_ibm\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n         (float:DF (match_operand:SI 1 \"register_operand\" \"d\")))\n@@ -3141,14 +3313,6 @@\n     }\n })\n \n-(define_insn \"floatsisf2_ieee\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n-        (float:SF (match_operand:SI 1 \"register_operand\" \"d\")))]\n-  \"TARGET_HARD_FLOAT && TARGET_IEEE_FLOAT\"\n-  \"cefbr\\t%0,%1\"\n-  [(set_attr \"op_type\" \"RRE\")\n-   (set_attr \"type\"    \"itof\" )])\n-\n ;\n ; truncdfsf2 instruction pattern(s).\n ;\n@@ -3164,7 +3328,8 @@\n         (float_truncate:SF (match_operand:DF 1 \"register_operand\" \"f\")))]\n   \"TARGET_HARD_FLOAT && TARGET_IEEE_FLOAT\"\n   \"ledbr\\t%0,%1\"\n-  [(set_attr \"op_type\"  \"RRE\")])\n+  [(set_attr \"op_type\"  \"RRE\")\n+   (set_attr \"type\"   \"ftruncdf\")])\n \n (define_insn \"truncdfsf2_ibm\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=f,f\")\n@@ -3176,6 +3341,66 @@\n   [(set_attr \"op_type\"  \"RR,RX\")\n    (set_attr \"type\"   \"floadsf\")])\n \n+;\n+; trunctfdf2 instruction pattern(s).\n+;\n+\n+(define_expand \"trunctfdf2\"\n+  [(parallel \n+    [(set (match_operand:DF 0 \"register_operand\" \"\")\n+\t  (float_truncate:DF (match_operand:TF 1 \"register_operand\" \"\")))\n+     (clobber (match_scratch:TF 2 \"=f\"))])]\n+  \"TARGET_HARD_FLOAT\"\n+  \"\")\n+\n+(define_insn \"*trunctfdf2_ieee\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n+        (float_truncate:DF (match_operand:TF 1 \"register_operand\" \"f\")))\n+   (clobber (match_scratch:TF 2 \"=f\"))]\n+  \"TARGET_HARD_FLOAT && TARGET_IEEE_FLOAT\"\n+  \"ldxbr\\t%2,%1\\;ldr\\t%0,%2\"\n+  [(set_attr \"length\" \"6\")\n+   (set_attr \"type\"   \"ftrunctf\")])   \n+\n+(define_insn \"*trunctfdf2_ibm\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n+        (float_truncate:DF (match_operand:TF 1 \"register_operand\" \"f\")))\n+   (clobber (match_scratch:TF 2 \"=f\"))]\n+  \"TARGET_HARD_FLOAT && TARGET_IBM_FLOAT\"\n+  \"ldxr\\t%2,%1\\;ldr\\t%0,%2\"\n+  [(set_attr \"length\"  \"4\")\n+   (set_attr \"type\"   \"ftrunctf\")])\n+\n+;\n+; trunctfsf2 instruction pattern(s).\n+;\n+\n+(define_expand \"trunctfsf2\"\n+  [(parallel \n+    [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n+\t  (float_truncate:SF (match_operand:TF 1 \"register_operand\" \"f\")))\n+     (clobber (match_scratch:TF 2 \"=f\"))])]\n+  \"TARGET_HARD_FLOAT\"\n+  \"\")\n+\n+(define_insn \"*trunctfsf2_ieee\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n+        (float_truncate:SF (match_operand:TF 1 \"register_operand\" \"f\")))\n+   (clobber (match_scratch:TF 2 \"=f\"))]\n+  \"TARGET_HARD_FLOAT && TARGET_IEEE_FLOAT\"\n+  \"lexbr\\t%2,%1\\;ler\\t%0,%2\"\n+  [(set_attr \"length\"  \"6\")\n+   (set_attr \"type\"   \"ftrunctf\")])\n+\n+(define_insn \"*trunctfsf2_ibm\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n+        (float_truncate:SF (match_operand:TF 1 \"register_operand\" \"f\")))\n+   (clobber (match_scratch:TF 2 \"=f\"))]\n+  \"TARGET_HARD_FLOAT && TARGET_IBM_FLOAT\"\n+  \"lexr\\t%2,%1\\;ler\\t%0,%2\"\n+  [(set_attr \"length\"  \"6\")\n+   (set_attr \"type\"   \"ftrunctf\")])\n+\n ;\n ; extendsfdf2 instruction pattern(s).\n ;\n@@ -3200,7 +3425,7 @@\n    ldebr\\t%0,%1\n    ldeb\\t%0,%1\"\n   [(set_attr \"op_type\"  \"RRE,RXE\")\n-   (set_attr \"type\"   \"floadsf\")])\n+   (set_attr \"type\"   \"fsimpsf, floadsf\")])\n \n (define_insn \"extendsfdf2_ibm\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=f,f\")\n@@ -3213,6 +3438,66 @@\n   [(set_attr \"length\"   \"4,6\")\n    (set_attr \"type\"     \"floadsf\")])\n \n+;\n+; extenddftf2 instruction pattern(s).\n+;\n+\n+(define_expand \"extenddftf2\"\n+  [(set (match_operand:TF 0 \"register_operand\" \"\")\n+        (float_extend:TF (match_operand:DF 1 \"nonimmediate_operand\" \"\")))]\n+  \"TARGET_HARD_FLOAT\"\n+  \"\")\n+\n+(define_insn \"*extenddftf2_ieee\"\n+  [(set (match_operand:TF 0 \"register_operand\" \"=f,f\")\n+        (float_extend:TF (match_operand:DF 1 \"nonimmediate_operand\" \"f,R\")))]\n+  \"TARGET_HARD_FLOAT && TARGET_IEEE_FLOAT\"\n+  \"@\n+   lxdbr\\t%0,%1\n+   lxdb\\t%0,%1\"\n+  [(set_attr \"op_type\"  \"RRE,RXE\")\n+   (set_attr \"type\"   \"fsimptf, floadtf\")])\n+\n+(define_insn \"*extenddftf2_ibm\"\n+  [(set (match_operand:TF 0 \"register_operand\" \"=f,f\")\n+        (float_extend:TF (match_operand:DF 1 \"nonimmediate_operand\" \"f,R\")))]\n+  \"TARGET_HARD_FLOAT && TARGET_IBM_FLOAT\"\n+  \"@\n+   lxdr\\t%0,%1\n+   lxd\\t%0,%1\"\n+  [(set_attr \"op_type\"  \"RRE,RXE\")\n+   (set_attr \"type\"   \"fsimptf, floadtf\")])\n+\n+;\n+; extendsftf2 instruction pattern(s).\n+;\n+\n+(define_expand \"extendsftf2\"\n+  [(set (match_operand:TF 0 \"register_operand\" \"\")\n+        (float_extend:TF (match_operand:SF 1 \"nonimmediate_operand\" \"\")))]\n+  \"TARGET_HARD_FLOAT\"\n+  \"\")\n+\n+(define_insn \"*extendsftf2_ieee\"\n+  [(set (match_operand:TF 0 \"register_operand\" \"=f,f\")\n+        (float_extend:TF (match_operand:SF 1 \"nonimmediate_operand\" \"f,R\")))]\n+  \"TARGET_HARD_FLOAT && TARGET_IEEE_FLOAT\"\n+  \"@\n+   lxebr\\t%0,%1\n+   lxeb\\t%0,%1\"\n+  [(set_attr \"op_type\"  \"RRE,RXE\")\n+   (set_attr \"type\"   \"fsimptf, floadtf\")])\n+\n+(define_insn \"*extendsftf2_ibm\"\n+  [(set (match_operand:TF 0 \"register_operand\" \"=f,f\")\n+        (float_extend:TF (match_operand:SF 1 \"nonimmediate_operand\" \"f,R\")))]\n+  \"TARGET_HARD_FLOAT && TARGET_IBM_FLOAT\"\n+  \"@\n+   lxer\\t%0,%1\n+   lxe\\t%0,%1\"\n+  [(set_attr \"op_type\"  \"RRE,RXE\")\n+   (set_attr \"type\"   \"fsimptf, floadtf\")])\n+\n \n ;;\n ;; ARITHMETIC OPERATIONS\n@@ -3535,60 +3820,60 @@\n   [(parallel\n     [(set (match_operand:FPR 0 \"register_operand\" \"=f,f\")\n           (plus:FPR (match_operand:FPR 1 \"nonimmediate_operand\" \"%0,0\")\n-                    (match_operand:FPR 2 \"general_operand\" \"f,R\")))\n+                    (match_operand:FPR 2 \"general_operand\" \"f,<Rf>\")))\n      (clobber (reg:CC CC_REGNUM))])]\n   \"TARGET_HARD_FLOAT\"\n   \"\")\n \n (define_insn \"*add<mode>3\"\n   [(set (match_operand:FPR 0 \"register_operand\" \"=f,f\")\n         (plus:FPR (match_operand:FPR 1 \"nonimmediate_operand\" \"%0,0\")\n-                  (match_operand:FPR 2 \"general_operand\" \"f,R\")))\n+                  (match_operand:FPR 2 \"general_operand\" \"f,<Rf>\")))\n    (clobber (reg:CC CC_REGNUM))]\n   \"TARGET_HARD_FLOAT && TARGET_IEEE_FLOAT\"\n   \"@\n-   a<de>br\\t%0,%2\n-   a<de>b\\t%0,%2\"\n+   a<xde>br\\t%0,%2\n+   a<xde>b\\t%0,%2\"\n   [(set_attr \"op_type\"  \"RRE,RXE\")\n    (set_attr \"type\"     \"fsimp<mode>\")])\n \n (define_insn \"*add<mode>3_cc\"\n   [(set (reg CC_REGNUM)\n \t(compare (plus:FPR (match_operand:FPR 1 \"nonimmediate_operand\" \"%0,0\")\n-\t\t\t   (match_operand:FPR 2 \"general_operand\" \"f,R\"))\n+\t\t\t   (match_operand:FPR 2 \"general_operand\" \"f,<Rf>\"))\n \t\t (match_operand:FPR 3 \"const0_operand\" \"\")))\n    (set (match_operand:FPR 0 \"register_operand\" \"=f,f\")\n \t(plus:FPR (match_dup 1) (match_dup 2)))]\n   \"s390_match_ccmode (insn, CCSmode) && TARGET_HARD_FLOAT && TARGET_IEEE_FLOAT\"\n   \"@\n-   a<de>br\\t%0,%2\n-   a<de>b\\t%0,%2\"\n+   a<xde>br\\t%0,%2\n+   a<xde>b\\t%0,%2\"\n   [(set_attr \"op_type\"  \"RRE,RXE\")\n    (set_attr \"type\"     \"fsimp<mode>\")])\n \n (define_insn \"*add<mode>3_cconly\"\n   [(set (reg CC_REGNUM)\n \t(compare (plus:FPR (match_operand:FPR 1 \"nonimmediate_operand\" \"%0,0\")\n-\t\t\t   (match_operand:FPR 2 \"general_operand\" \"f,R\"))\n+\t\t\t   (match_operand:FPR 2 \"general_operand\" \"f,<Rf>\"))\n \t\t (match_operand:FPR 3 \"const0_operand\" \"\")))\n    (clobber (match_scratch:FPR 0 \"=f,f\"))]\n   \"s390_match_ccmode (insn, CCSmode) && TARGET_HARD_FLOAT && TARGET_IEEE_FLOAT\"\n   \"@\n-   a<de>br\\t%0,%2\n-   a<de>b\\t%0,%2\"\n+   a<xde>br\\t%0,%2\n+   a<xde>b\\t%0,%2\"\n   [(set_attr \"op_type\"  \"RRE,RXE\")\n    (set_attr \"type\"     \"fsimp<mode>\")])\n \n (define_insn \"*add<mode>3_ibm\"\n   [(set (match_operand:FPR 0 \"register_operand\" \"=f,f\")\n         (plus:FPR (match_operand:FPR 1 \"nonimmediate_operand\" \"%0,0\")\n-                  (match_operand:FPR 2 \"general_operand\" \"f,R\")))\n+                  (match_operand:FPR 2 \"general_operand\" \"f,<Rf>\")))\n    (clobber (reg:CC CC_REGNUM))]\n   \"TARGET_HARD_FLOAT && TARGET_IBM_FLOAT\"\n   \"@\n-   a<de>r\\t%0,%2\n-   a<de>\\t%0,%2\"\n-  [(set_attr \"op_type\"  \"RR,RX\")\n+   a<xde>r\\t%0,%2\n+   a<xde>\\t%0,%2\"\n+  [(set_attr \"op_type\"  \"<RRe>,<RXe>\")\n    (set_attr \"type\"     \"fsimp<mode>\")])\n \n \n@@ -3875,52 +4160,52 @@\n (define_insn \"*sub<mode>3\"\n   [(set (match_operand:FPR 0 \"register_operand\" \"=f,f\")\n         (minus:FPR (match_operand:FPR 1 \"register_operand\" \"0,0\")\n-                   (match_operand:FPR 2 \"general_operand\" \"f,R\")))\n+                   (match_operand:FPR 2 \"general_operand\" \"f,<Rf>\")))\n    (clobber (reg:CC CC_REGNUM))]\n   \"TARGET_HARD_FLOAT && TARGET_IEEE_FLOAT\"\n   \"@\n-   s<de>br\\t%0,%2\n-   s<de>b\\t%0,%2\"\n+   s<xde>br\\t%0,%2\n+   s<xde>b\\t%0,%2\"\n   [(set_attr \"op_type\"  \"RRE,RXE\")\n    (set_attr \"type\"     \"fsimp<mode>\")])\n \n (define_insn \"*sub<mode>3_cc\"\n   [(set (reg CC_REGNUM)\n \t(compare (minus:FPR (match_operand:FPR 1 \"nonimmediate_operand\" \"0,0\")\n-\t\t\t    (match_operand:FPR 2 \"general_operand\" \"f,R\"))\n+\t\t\t    (match_operand:FPR 2 \"general_operand\" \"f,<Rf>\"))\n \t\t (match_operand:FPR 3 \"const0_operand\" \"\")))\n    (set (match_operand:FPR 0 \"register_operand\" \"=f,f\")\n \t(minus:FPR (match_dup 1) (match_dup 2)))]\n   \"s390_match_ccmode (insn, CCSmode) && TARGET_HARD_FLOAT && TARGET_IEEE_FLOAT\"\n   \"@\n-   s<de>br\\t%0,%2\n-   s<de>b\\t%0,%2\"\n+   s<xde>br\\t%0,%2\n+   s<xde>b\\t%0,%2\"\n   [(set_attr \"op_type\"  \"RRE,RXE\")\n    (set_attr \"type\"     \"fsimp<mode>\")])\n \n (define_insn \"*sub<mode>3_cconly\"\n   [(set (reg CC_REGNUM)\n \t(compare (minus:FPR (match_operand:FPR 1 \"nonimmediate_operand\" \"0,0\")\n-\t\t\t    (match_operand:FPR 2 \"general_operand\" \"f,R\"))\n+\t\t\t    (match_operand:FPR 2 \"general_operand\" \"f,<Rf>\"))\n \t\t (match_operand:FPR 3 \"const0_operand\" \"\")))\n    (clobber (match_scratch:FPR 0 \"=f,f\"))]\n   \"s390_match_ccmode (insn, CCSmode) && TARGET_HARD_FLOAT && TARGET_IEEE_FLOAT\"\n   \"@\n-   s<de>br\\t%0,%2\n-   s<de>b\\t%0,%2\"\n+   s<xde>br\\t%0,%2\n+   s<xde>b\\t%0,%2\"\n   [(set_attr \"op_type\"  \"RRE,RXE\")\n    (set_attr \"type\"     \"fsimp<mode>\")])\n \n (define_insn \"*sub<mode>3_ibm\"\n   [(set (match_operand:FPR 0 \"register_operand\" \"=f,f\")\n         (minus:FPR (match_operand:FPR 1 \"register_operand\" \"0,0\")\n-                   (match_operand:FPR 2 \"general_operand\" \"f,R\")))\n+                   (match_operand:FPR 2 \"general_operand\" \"f,<Rf>\")))\n    (clobber (reg:CC CC_REGNUM))]\n   \"TARGET_HARD_FLOAT && TARGET_IBM_FLOAT\"\n   \"@\n-   s<de>r\\t%0,%2\n-   s<de>\\t%0,%2\"\n-  [(set_attr \"op_type\"  \"RR,RX\")\n+   s<xde>r\\t%0,%2\n+   s<xde>\\t%0,%2\"\n+  [(set_attr \"op_type\"  \"<RRe>,<RXe>\")\n    (set_attr \"type\"     \"fsimp<mode>\")])\n \n \n@@ -4168,53 +4453,53 @@\n (define_expand \"mul<mode>3\"\n   [(set (match_operand:FPR 0 \"register_operand\" \"=f,f\")\n         (mult:FPR (match_operand:FPR 1 \"nonimmediate_operand\" \"%0,0\")\n-                  (match_operand:FPR 2 \"general_operand\" \"f,R\")))]\n+                  (match_operand:FPR 2 \"general_operand\" \"f,<Rf>\")))]\n   \"TARGET_HARD_FLOAT\"\n   \"\")\n \n (define_insn \"*mul<mode>3\"\n   [(set (match_operand:FPR 0 \"register_operand\" \"=f,f\")\n         (mult:FPR (match_operand:FPR 1 \"nonimmediate_operand\" \"%0,0\")\n-                  (match_operand:FPR 2 \"general_operand\" \"f,R\")))]\n+                  (match_operand:FPR 2 \"general_operand\" \"f,<Rf>\")))]\n   \"TARGET_HARD_FLOAT && TARGET_IEEE_FLOAT\"\n   \"@\n-   m<dee>br\\t%0,%2\n-   m<dee>b\\t%0,%2\"\n+   m<xdee>br\\t%0,%2\n+   m<xdee>b\\t%0,%2\"\n   [(set_attr \"op_type\"  \"RRE,RXE\")\n    (set_attr \"type\"     \"fmul<mode>\")])\n \n (define_insn \"*mul<mode>3_ibm\"\n   [(set (match_operand:FPR 0 \"register_operand\" \"=f,f\")\n         (mult:FPR (match_operand:FPR 1 \"nonimmediate_operand\" \"%0,0\")\n-                  (match_operand:FPR 2 \"general_operand\" \"f,R\")))]\n+                  (match_operand:FPR 2 \"general_operand\" \"f,<Rf>\")))]\n   \"TARGET_HARD_FLOAT && TARGET_IBM_FLOAT\"\n   \"@\n-   m<de>r\\t%0,%2\n-   m<de>\\t%0,%2\"\n-  [(set_attr \"op_type\"  \"RR,RX\")\n+   m<xde>r\\t%0,%2\n+   m<xde>\\t%0,%2\"\n+  [(set_attr \"op_type\"  \"<RRe>,<RXe>\")\n    (set_attr \"type\"     \"fmul<mode>\")])\n \n (define_insn \"*fmadd<mode>\"\n-  [(set (match_operand:FPR 0 \"register_operand\" \"=f,f\")\n-\t(plus:FPR (mult:FPR (match_operand:FPR 1 \"register_operand\" \"%f,f\")\n-\t\t\t   (match_operand:FPR 2 \"nonimmediate_operand\"  \"f,R\"))\n-\t\t (match_operand:FPR 3 \"register_operand\" \"0,0\")))]\n+  [(set (match_operand:DSF 0 \"register_operand\" \"=f,f\")\n+\t(plus:DSF (mult:DSF (match_operand:DSF 1 \"register_operand\" \"%f,f\")\n+\t\t\t    (match_operand:DSF 2 \"nonimmediate_operand\"  \"f,R\"))\n+\t\t (match_operand:DSF 3 \"register_operand\" \"0,0\")))]\n   \"TARGET_HARD_FLOAT && TARGET_IEEE_FLOAT && TARGET_FUSED_MADD\"\n   \"@\n-   ma<de>br\\t%0,%1,%2\n-   ma<de>b\\t%0,%1,%2\"\n+   ma<xde>br\\t%0,%1,%2\n+   ma<xde>b\\t%0,%1,%2\"\n   [(set_attr \"op_type\"  \"RRE,RXE\")\n    (set_attr \"type\"     \"fmul<mode>\")])\n \n (define_insn \"*fmsub<mode>\"\n-  [(set (match_operand:FPR 0 \"register_operand\" \"=f,f\")\n-\t(minus:FPR (mult:FPR (match_operand:FPR 1 \"register_operand\" \"f,f\")\n-\t\t\t    (match_operand:FPR 2 \"nonimmediate_operand\"  \"f,R\"))\n-\t\t (match_operand:FPR 3 \"register_operand\" \"0,0\")))]\n+  [(set (match_operand:DSF 0 \"register_operand\" \"=f,f\")\n+\t(minus:DSF (mult:DSF (match_operand:DSF 1 \"register_operand\" \"f,f\")\n+\t\t\t     (match_operand:DSF 2 \"nonimmediate_operand\"  \"f,R\"))\n+\t\t (match_operand:DSF 3 \"register_operand\" \"0,0\")))]\n   \"TARGET_HARD_FLOAT && TARGET_IEEE_FLOAT && TARGET_FUSED_MADD\"\n   \"@\n-   ms<de>br\\t%0,%1,%2\n-   ms<de>b\\t%0,%1,%2\"\n+   ms<xde>br\\t%0,%1,%2\n+   ms<xde>b\\t%0,%1,%2\"\n   [(set_attr \"op_type\"  \"RRE,RXE\")\n    (set_attr \"type\"     \"fmul<mode>\")])\n \n@@ -4661,30 +4946,30 @@\n (define_expand \"div<mode>3\"\n   [(set (match_operand:FPR 0 \"register_operand\" \"=f,f\")\n         (div:FPR (match_operand:FPR 1 \"register_operand\" \"0,0\")\n-                 (match_operand:FPR 2 \"general_operand\" \"f,R\")))]\n+                 (match_operand:FPR 2 \"general_operand\" \"f,<Rf>\")))]\n   \"TARGET_HARD_FLOAT\"\n   \"\")\n \n (define_insn \"*div<mode>3\"\n   [(set (match_operand:FPR 0 \"register_operand\" \"=f,f\")\n         (div:FPR (match_operand:FPR 1 \"register_operand\" \"0,0\")\n-                 (match_operand:FPR 2 \"general_operand\" \"f,R\")))]\n+                 (match_operand:FPR 2 \"general_operand\" \"f,<Rf>\")))]\n   \"TARGET_HARD_FLOAT && TARGET_IEEE_FLOAT\"\n   \"@\n-   d<de>br\\t%0,%2\n-   d<de>b\\t%0,%2\"\n+   d<xde>br\\t%0,%2\n+   d<xde>b\\t%0,%2\"\n   [(set_attr \"op_type\"  \"RRE,RXE\")\n    (set_attr \"type\"     \"fdiv<mode>\")])\n \n (define_insn \"*div<mode>3_ibm\"\n   [(set (match_operand:FPR 0 \"register_operand\" \"=f,f\")\n         (div:FPR (match_operand:FPR 1 \"register_operand\" \"0,0\")\n-                 (match_operand:FPR 2 \"general_operand\" \"f,R\")))]\n+                 (match_operand:FPR 2 \"general_operand\" \"f,<Rf>\")))]\n   \"TARGET_HARD_FLOAT && TARGET_IBM_FLOAT\"\n   \"@\n-   d<de>r\\t%0,%2\n-   d<de>\\t%0,%2\"\n-  [(set_attr \"op_type\"  \"RR,RX\")\n+   d<xde>r\\t%0,%2\n+   d<xde>\\t%0,%2\"\n+  [(set_attr \"op_type\"  \"<RRe>,<RXe>\")\n    (set_attr \"type\"     \"fdiv<mode>\")])\n \n \n@@ -5667,7 +5952,7 @@\n    (set (match_operand:FPR 0 \"register_operand\" \"=f\")\n         (neg:FPR (match_dup 1)))]\n   \"s390_match_ccmode (insn, CCSmode) && TARGET_HARD_FLOAT && TARGET_IEEE_FLOAT\"\n-  \"lc<de>br\\t%0,%1\"\n+  \"lc<xde>br\\t%0,%1\"\n   [(set_attr \"op_type\"  \"RRE\")\n    (set_attr \"type\"     \"fsimp<mode>\")])\n   \n@@ -5677,7 +5962,7 @@\n                  (match_operand:FPR 2 \"const0_operand\" \"\")))\n    (clobber (match_scratch:FPR 0 \"=f\"))]\n   \"s390_match_ccmode (insn, CCSmode) && TARGET_HARD_FLOAT && TARGET_IEEE_FLOAT\"\n-  \"lc<de>br\\t%0,%1\"\n+  \"lc<xde>br\\t%0,%1\"\n   [(set_attr \"op_type\"  \"RRE\")\n    (set_attr \"type\"     \"fsimp<mode>\")])\n   \n@@ -5686,7 +5971,7 @@\n         (neg:FPR (match_operand:FPR 1 \"register_operand\" \"f\")))\n    (clobber (reg:CC CC_REGNUM))]\n   \"TARGET_HARD_FLOAT && TARGET_IEEE_FLOAT\"\n-  \"lc<de>br\\t%0,%1\"\n+  \"lc<xde>br\\t%0,%1\"\n   [(set_attr \"op_type\"  \"RRE\")\n    (set_attr \"type\"     \"fsimp<mode>\")])\n \n@@ -5695,8 +5980,8 @@\n         (neg:FPR (match_operand:FPR 1 \"register_operand\" \"f\")))\n    (clobber (reg:CC CC_REGNUM))]\n   \"TARGET_HARD_FLOAT && TARGET_IBM_FLOAT\"\n-  \"lc<de>r\\t%0,%1\"\n-  [(set_attr \"op_type\"  \"RR\")\n+  \"lc<xde>r\\t%0,%1\"\n+  [(set_attr \"op_type\"  \"<RRe>\")\n    (set_attr \"type\"     \"fsimp<mode>\")])\n \n \n@@ -5774,7 +6059,7 @@\n    (set (match_operand:FPR 0 \"register_operand\" \"=f\")\n         (abs:FPR (match_dup 1)))]\n   \"s390_match_ccmode (insn, CCSmode) && TARGET_HARD_FLOAT && TARGET_IEEE_FLOAT\"\n-  \"lp<de>br\\t%0,%1\"\n+  \"lp<xde>br\\t%0,%1\"\n   [(set_attr \"op_type\"  \"RRE\")\n    (set_attr \"type\"     \"fsimp<mode>\")])\n   \n@@ -5784,7 +6069,7 @@\n                  (match_operand:FPR 2 \"const0_operand\" \"\")))\n    (clobber (match_scratch:FPR 0 \"=f\"))]\n   \"s390_match_ccmode (insn, CCSmode) && TARGET_HARD_FLOAT && TARGET_IEEE_FLOAT\"\n-  \"lp<de>br\\t%0,%1\"\n+  \"lp<xde>br\\t%0,%1\"\n   [(set_attr \"op_type\"  \"RRE\")\n    (set_attr \"type\"     \"fsimp<mode>\")])\n   \n@@ -5793,7 +6078,7 @@\n         (abs:FPR (match_operand:FPR 1 \"register_operand\" \"f\")))\n    (clobber (reg:CC CC_REGNUM))]\n   \"TARGET_HARD_FLOAT && TARGET_IEEE_FLOAT\"\n-  \"lp<de>br\\t%0,%1\"\n+  \"lp<xde>br\\t%0,%1\"\n   [(set_attr \"op_type\"  \"RRE\")\n    (set_attr \"type\"     \"fsimp<mode>\")])\n \n@@ -5802,8 +6087,8 @@\n         (abs:FPR (match_operand:FPR 1 \"register_operand\" \"f\")))\n    (clobber (reg:CC CC_REGNUM))]\n   \"TARGET_HARD_FLOAT && TARGET_IBM_FLOAT\"\n-  \"lp<de>r\\t%0,%1\"\n-  [(set_attr \"op_type\"  \"RR\")\n+  \"lp<xde>r\\t%0,%1\"\n+  [(set_attr \"op_type\"  \"<RRe>\")\n    (set_attr \"type\"     \"fsimp<mode>\")])\n \n ;;\n@@ -5873,7 +6158,7 @@\n    (set (match_operand:FPR 0 \"register_operand\" \"=f\")\n         (neg:FPR (abs:FPR (match_dup 1))))]\n   \"s390_match_ccmode (insn, CCSmode) && TARGET_HARD_FLOAT && TARGET_IEEE_FLOAT\"\n-  \"ln<de>br\\t%0,%1\"\n+  \"ln<xde>br\\t%0,%1\"\n   [(set_attr \"op_type\"  \"RRE\")\n    (set_attr \"type\"     \"fsimp<mode>\")])\n   \n@@ -5883,7 +6168,7 @@\n                  (match_operand:FPR 2 \"const0_operand\" \"\")))\n    (clobber (match_scratch:FPR 0 \"=f\"))]\n   \"s390_match_ccmode (insn, CCSmode) && TARGET_HARD_FLOAT && TARGET_IEEE_FLOAT\"\n-  \"ln<de>br\\t%0,%1\"\n+  \"ln<xde>br\\t%0,%1\"\n   [(set_attr \"op_type\"  \"RRE\")\n    (set_attr \"type\"     \"fsimp<mode>\")])\n   \n@@ -5892,7 +6177,7 @@\n         (neg:FPR (abs:FPR (match_operand:FPR 1 \"register_operand\" \"f\"))))\n    (clobber (reg:CC CC_REGNUM))]\n   \"TARGET_HARD_FLOAT && TARGET_IEEE_FLOAT\"\n-  \"ln<de>br\\t%0,%1\"\n+  \"ln<xde>br\\t%0,%1\"\n   [(set_attr \"op_type\"  \"RRE\")\n    (set_attr \"type\"     \"fsimp<mode>\")])\n \n@@ -5906,11 +6191,11 @@\n \n (define_insn \"sqrt<mode>2\"\n   [(set (match_operand:FPR 0 \"register_operand\" \"=f,f\")\n-\t(sqrt:FPR (match_operand:FPR 1 \"general_operand\" \"f,R\")))]\n+\t(sqrt:FPR (match_operand:FPR 1 \"general_operand\" \"f,<Rf>\")))]\n   \"TARGET_HARD_FLOAT && TARGET_IEEE_FLOAT\"\n   \"@\n-   sq<de>br\\t%0,%1\n-   sq<de>b\\t%0,%1\"\n+   sq<xde>br\\t%0,%1\n+   sq<xde>b\\t%0,%1\"\n   [(set_attr \"op_type\" \"RRE,RXE\")\n    (set_attr \"type\" \"fsqrt<mode>\")])\n "}, {"sha": "21ef4f31065ba45dec60c518e36bcd79bbf5b616", "filename": "gcc/config/s390/s390.opt", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f61a2c7da855928032ffe9293483c5c9584f7ceb/gcc%2Fconfig%2Fs390%2Fs390.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f61a2c7da855928032ffe9293483c5c9584f7ceb/gcc%2Fconfig%2Fs390%2Fs390.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.opt?ref=f61a2c7da855928032ffe9293483c5c9584f7ceb", "patch": "@@ -1,6 +1,6 @@\n ; Options for the S/390 / zSeries port of the compiler.\n \n-; Copyright (C) 2005 Free Software Foundation, Inc.\n+; Copyright (C) 2005, 2006 Free Software Foundation, Inc.\n ;\n ; This file is part of GCC.\n ;\n@@ -51,6 +51,14 @@ mhard-float\n Target Report RejectNegative Mask(HARD_FLOAT)\n Use hardware fp\n \n+mlong-double-128\n+Target Report RejectNegative Mask(LONG_DOUBLE_128)\n+Use 128-bit long double\n+\n+mlong-double-64\n+Target Report RejectNegative InverseMask(LONG_DOUBLE_128)\n+Use 64-bit long double\n+\n mpacked-stack\n Target Report Mask(PACKED_STACK)\n Use packed stack layout"}, {"sha": "39b0eba6b979bc77f5513f7b579a01b01d1f9865", "filename": "gcc/config/s390/t-crtstuff", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f61a2c7da855928032ffe9293483c5c9584f7ceb/gcc%2Fconfig%2Fs390%2Ft-crtstuff", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f61a2c7da855928032ffe9293483c5c9584f7ceb/gcc%2Fconfig%2Fs390%2Ft-crtstuff", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Ft-crtstuff?ref=f61a2c7da855928032ffe9293483c5c9584f7ceb", "patch": "@@ -2,3 +2,4 @@\n # because then __FRAME_END__ might not be the last thing in .eh_frame\n # section.\n CRTSTUFF_T_CFLAGS = -fno-asynchronous-unwind-tables\n+TARGET_LIBGCC2_CFLAGS += -mlong-double-128"}, {"sha": "b4927d9f890029e3d9c25e854f54993daa7fb631", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f61a2c7da855928032ffe9293483c5c9584f7ceb/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f61a2c7da855928032ffe9293483c5c9584f7ceb/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=f61a2c7da855928032ffe9293483c5c9584f7ceb", "patch": "@@ -674,8 +674,8 @@ See RS/6000 and PowerPC Options.\n \n @emph{S/390 and zSeries Options}\n @gccoptlist{-mtune=@var{cpu-type}  -march=@var{cpu-type} @gol\n--mhard-float  -msoft-float  -mbackchain  -mno-backchain @gol\n--mpacked-stack  -mno-packed-stack @gol\n+-mhard-float  -msoft-float -mlong-double-64 -mlong-double-128 @gol\n+-mbackchain  -mno-backchain -mpacked-stack  -mno-packed-stack @gol\n -msmall-exec  -mno-small-exec  -mmvcle -mno-mvcle @gol\n -m64  -m31  -mdebug  -mno-debug  -mesa  -mzarch @gol\n -mtpf-trace -mno-tpf-trace  -mfused-madd  -mno-fused-madd @gol\n@@ -11711,6 +11711,14 @@ functions in @file{libgcc.a} will be used to perform floating-point\n operations.  When @option{-mhard-float} is specified, the compiler\n generates IEEE floating-point instructions.  This is the default.\n \n+@item -mlong-double-64\n+@itemx -mlong-double-128\n+@opindex mlong-double-64\n+@opindex mlong-double-128\n+These switches control the size of @code{long double} type. A size\n+of 64bit makes the @code{long double} type equivalent to the @code{double}\n+type. This is the default.\n+\n @item -mbackchain\n @itemx -mno-backchain\n @opindex mbackchain"}]}