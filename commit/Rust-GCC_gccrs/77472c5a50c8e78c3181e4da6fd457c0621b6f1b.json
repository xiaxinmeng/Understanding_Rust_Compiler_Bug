{"sha": "77472c5a50c8e78c3181e4da6fd457c0621b6f1b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Nzc0NzJjNWE1MGM4ZTc4YzMxODFlNGRhNmZkNDU3YzA2MjFiNmYxYg==", "commit": {"author": {"name": "Tom Wood", "email": "wood@gnu.org", "date": "1992-08-25T19:20:27Z"}, "committer": {"name": "Tom Wood", "email": "wood@gnu.org", "date": "1992-08-25T19:20:27Z"}, "message": "(delete_computation): Derived from delete_jump.\n\n(delete_jump): Use delete_computation.\n\nFrom-SVN: r1944", "tree": {"sha": "085ce6a2bee51cf8b6d99677b3fe4ec47e059d0b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/085ce6a2bee51cf8b6d99677b3fe4ec47e059d0b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/77472c5a50c8e78c3181e4da6fd457c0621b6f1b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77472c5a50c8e78c3181e4da6fd457c0621b6f1b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/77472c5a50c8e78c3181e4da6fd457c0621b6f1b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77472c5a50c8e78c3181e4da6fd457c0621b6f1b/comments", "author": null, "committer": null, "parents": [{"sha": "cdd8c058e92bf351e40e41ac0e2f51ba86bc1c31", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cdd8c058e92bf351e40e41ac0e2f51ba86bc1c31", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cdd8c058e92bf351e40e41ac0e2f51ba86bc1c31"}], "stats": {"total": 149, "additions": 81, "deletions": 68}, "files": [{"sha": "db1e5ef086fc205162daa165e635530f4f879479", "filename": "gcc/jump.c", "status": "modified", "additions": 81, "deletions": 68, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77472c5a50c8e78c3181e4da6fd457c0621b6f1b/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77472c5a50c8e78c3181e4da6fd457c0621b6f1b/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=77472c5a50c8e78c3181e4da6fd457c0621b6f1b", "patch": "@@ -108,6 +108,7 @@ void redirect_tablejump ();\n static int delete_labelref_insn ();\n static void mark_jump_label ();\n void delete_jump ();\n+void delete_computation ();\n static void delete_from_jump_chain ();\n static int tension_vector_labels ();\n static void find_cross_jump ();\n@@ -2820,13 +2821,12 @@ delete_jump (insn)\n      rtx insn;\n {\n   register rtx x = PATTERN (insn);\n-  register rtx prev;\n \n   if (GET_CODE (x) == SET\n       && GET_CODE (SET_DEST (x)) == PC)\n     {\n-      prev = prev_nonnote_insn (insn);\n #ifdef HAVE_cc0\n+      rtx prev = prev_nonnote_insn (insn);\n       /* We assume that at this stage\n \t CC's are always set explicitly\n \t and always immediately before the jump that\n@@ -2844,87 +2844,100 @@ delete_jump (insn)\n \t    REG_NOTES (prev) = gen_rtx (EXPR_LIST, REG_UNUSED,\n \t\t\t\t\tcc0_rtx, REG_NOTES (prev));\n \t}\n-#else\n-      {\n-\trtx note;\n+#endif\n+      /* Now delete the jump insn itself.  */\n+      delete_computation (insn);\n+    }\n+}\n \n-\t/* If we are running before flow.c, we need do nothing since flow.c\n-\t   will delete the set of the condition code if it is dead.  We also\n-\t   can't know if the register being used as the condition code is\n-\t   dead or not at this point.\n+/* Delete INSN and recursively delete insns that compute values used only\n+   by INSN.  This uses the REG_DEAD notes computed during flow analysis.\n+   If we are running before flow.c, we need do nothing since flow.c will\n+   delete dead code.  We also can't know if the registers being used are\n+   dead or not at this point.\n \n-\t   Otherwise, look at all our REG_DEAD notes.  If a previous insn\n-\t   does nothing other than set a register that dies in this jump,\n-\t   we can delete the insn.  */\n+   Otherwise, look at all our REG_DEAD notes.  If a previous insn does\n+   nothing other than set a register that dies in this insn, we can delete\n+   that insn as well.  */\n \n-\tfor (note = REG_NOTES (insn); note; note = XEXP (note, 1))\n-\t  {\n-\t    rtx our_prev;\n+void\n+delete_computation (insn)\n+     rtx insn;\n+{\n+#ifndef HAVE_cc0\n+  rtx note, next;\n \n-\t    if (REG_NOTE_KIND (note) != REG_DEAD\n-\t\t/* Verify that the REG_NOTE has a legal value.  */\n-\t\t|| GET_CODE (XEXP (note, 0)) != REG)\n-\t      continue;\n+  for (note = REG_NOTES (insn); note; note = next)\n+    {\n+      rtx our_prev;\n \n-\t    for (our_prev = prev_nonnote_insn (insn);\n-\t\t our_prev && GET_CODE (our_prev) == INSN;\n-\t\t our_prev = prev_nonnote_insn (our_prev))\n-\t      {\n-\t\t/* If we reach a SEQUENCE, it is too complex to try to\n-\t\t   do anything with it, so give up.  */\n-\t\tif (GET_CODE (PATTERN (our_prev)) == SEQUENCE)\n-\t\t  break;\n+      next = XEXP (note, 1);\n \n-\t\tif (GET_CODE (PATTERN (our_prev)) == USE\n-\t\t    && GET_CODE (XEXP (PATTERN (our_prev), 0)) == INSN)\n-\t\t  /* reorg creates USEs that look like this.  We leave them\n-\t\t     alone because reorg needs them for its own purposes.  */\n-\t\t  break;\n+      if (REG_NOTE_KIND (note) != REG_DEAD\n+\t  /* Verify that the REG_NOTE is legitimate.  */\n+\t  || GET_CODE (XEXP (note, 0)) != REG)\n+\tcontinue;\n \n-\t\tif (reg_set_p (XEXP (note, 0), PATTERN (our_prev)))\n-\t\t  {\n-\t\t    if (FIND_REG_INC_NOTE (our_prev, NULL_RTX))\n-\t\t      break;\n+      for (our_prev = prev_nonnote_insn (insn);\n+\t   our_prev && GET_CODE (our_prev) == INSN;\n+\t   our_prev = prev_nonnote_insn (our_prev))\n+\t{\n+\t  /* If we reach a SEQUENCE, it is too complex to try to\n+\t     do anything with it, so give up.  */\n+\t  if (GET_CODE (PATTERN (our_prev)) == SEQUENCE)\n+\t    break;\n \n-\t\t    if (GET_CODE (PATTERN (our_prev)) == PARALLEL)\n-\t\t      {\n-\t\t\t/* If we find a SET of something else, we can't\n-\t\t\t   delete the insn.  */\n+\t  if (GET_CODE (PATTERN (our_prev)) == USE\n+\t      && GET_CODE (XEXP (PATTERN (our_prev), 0)) == INSN)\n+\t    /* reorg creates USEs that look like this.  We leave them\n+\t       alone because reorg needs them for its own purposes.  */\n+\t    break;\n \n-\t\t\tint i;\n+\t  if (reg_set_p (XEXP (note, 0), PATTERN (our_prev)))\n+\t    {\n+\t      if (FIND_REG_INC_NOTE (our_prev, NULL_RTX))\n+\t\tbreak;\n \n-\t\t\tfor (i = 0; i < XVECLEN (PATTERN (our_prev), 0); i++)\n-\t\t\t  {\n-\t\t\t    rtx part = XVECEXP (PATTERN (our_prev), 0, i);\n+\t      if (GET_CODE (PATTERN (our_prev)) == PARALLEL)\n+\t\t{\n+\t\t  /* If we find a SET of something else, we can't\n+\t\t     delete the insn.  */\n \n-\t\t\t    if (GET_CODE (part) == SET\n-\t\t\t\t&& SET_DEST (part) != XEXP (note, 0))\n-\t\t\t      break;\n-\t\t\t  }\n+\t\t  int i;\n \n-\t\t\tif (i == XVECLEN (PATTERN (our_prev), 0))\n-\t\t\t  delete_insn (our_prev);\n-\t\t      }\n-\t\t    else if (GET_CODE (PATTERN (our_prev)) == SET\n-\t\t\t     && SET_DEST (PATTERN (our_prev)) == XEXP (note, 0))\n-\t\t      delete_insn (our_prev);\n+\t\t  for (i = 0; i < XVECLEN (PATTERN (our_prev), 0); i++)\n+\t\t    {\n+\t\t      rtx part = XVECEXP (PATTERN (our_prev), 0, i);\n \n-\t\t    break;\n-\t\t  }\n+\t\t      if (GET_CODE (part) == SET\n+\t\t\t  && SET_DEST (part) != XEXP (note, 0))\n+\t\t\tbreak;\n+\t\t    }\n \n-\t\t/* If OUR_PREV references the register that dies here,\n-\t\t   it is an additional use.  Hence any prior SET isn't\n-\t\t   dead.  */\n-\t\tif (reg_overlap_mentioned_p (XEXP (note, 0),\n-\t\t\t\t\t     PATTERN (our_prev)))\n-\t\t  break;\n-\t      }\n-\t  }\n-      }\n-#endif\n-      /* Now delete the jump insn itself.  */\n-      delete_insn (insn);\n+\t\t  if (i == XVECLEN (PATTERN (our_prev), 0))\n+\t\t    delete_computation (our_prev);\n+\t\t}\n+\t      else if (GET_CODE (PATTERN (our_prev)) == SET\n+\t\t       && SET_DEST (PATTERN (our_prev)) == XEXP (note, 0))\n+\t\tdelete_computation (our_prev);\n+\n+\t      break;\n+\t    }\n+\n+\t  /* If OUR_PREV references the register that dies here, it is an\n+\t     additional use.  Hence any prior SET isn't dead.  However, this\n+\t     insn becomes the new place for the REG_DEAD note.  */\n+\t  if (reg_overlap_mentioned_p (XEXP (note, 0),\n+\t\t\t\t       PATTERN (our_prev)))\n+\t    {\n+\t      XEXP (note, 1) = REG_NOTES (our_prev);\n+\t      REG_NOTES (our_prev) = note;\n+\t      break;\n+\t    }\n+\t}\n     }\n+#endif /* Don't HAVE_cc0 */\n+  delete_insn (insn);\n }\n \f\n /* Delete insn INSN from the chain of insns and update label ref counts."}]}