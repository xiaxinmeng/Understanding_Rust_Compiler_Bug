{"sha": "bfaa08b7ba1b00bbcc00bb76735c6b3547f5830f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmZhYTA4YjdiYTFiMDBiYmNjMDBiYjc2NzM1YzZiMzU0N2Y1ODMwZg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-01-13T18:01:34Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-01-13T18:01:34Z"}, "message": "Add support for SVE gather loads\n\nThis patch adds support for SVE gather loads.  It uses the basically\nthe same analysis code as the AVX gather support, but after that\nthere are two major differences:\n\n- It uses new internal functions rather than target built-ins.\n  The interface is:\n\n     IFN_GATHER_LOAD (base, offsets scale)\n     IFN_MASK_GATHER_LOAD (base, offsets scale, mask)\n\n  which should be reasonably generic.  One of the advantages of\n  using internal functions is that other passes can understand what\n  the functions do, but a more immediate advantage is that we can\n  query the underlying target pattern to see which scales it supports.\n\n- It uses pattern recognition to convert the offset to the right width,\n  if it was originally narrower than that.  This avoids having to do\n  a widening operation as part of the gather expansion itself.\n\n2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* doc/md.texi (gather_load@var{m}): Document.\n\t(mask_gather_load@var{m}): Likewise.\n\t* genopinit.c (main): Add supports_vec_gather_load and\n\tsupports_vec_gather_load_cached to target_optabs.\n\t* optabs-tree.c (init_tree_optimization_optabs): Use\n\tggc_cleared_alloc to allocate target_optabs.\n\t* optabs.def (gather_load_optab, mask_gather_laod_optab): New optabs.\n\t* internal-fn.def (GATHER_LOAD, MASK_GATHER_LOAD): New internal\n\tfunctions.\n\t* internal-fn.h (internal_load_fn_p): Declare.\n\t(internal_gather_scatter_fn_p): Likewise.\n\t(internal_fn_mask_index): Likewise.\n\t(internal_gather_scatter_fn_supported_p): Likewise.\n\t* internal-fn.c (gather_load_direct): New macro.\n\t(expand_gather_load_optab_fn): New function.\n\t(direct_gather_load_optab_supported_p): New macro.\n\t(direct_internal_fn_optab): New function.\n\t(internal_load_fn_p): Likewise.\n\t(internal_gather_scatter_fn_p): Likewise.\n\t(internal_fn_mask_index): Likewise.\n\t(internal_gather_scatter_fn_supported_p): Likewise.\n\t* optabs-query.c (supports_at_least_one_mode_p): New function.\n\t(supports_vec_gather_load_p): Likewise.\n\t* optabs-query.h (supports_vec_gather_load_p): Declare.\n\t* tree-vectorizer.h (gather_scatter_info): Add ifn, element_type\n\tand memory_type field.\n\t(NUM_PATTERNS): Bump to 15.\n\t* tree-vect-data-refs.c: Include internal-fn.h.\n\t(vect_gather_scatter_fn_p): New function.\n\t(vect_describe_gather_scatter_call): Likewise.\n\t(vect_check_gather_scatter): Try using internal functions for\n\tgather loads.  Recognize existing calls to a gather load function.\n\t(vect_analyze_data_refs): Consider using gather loads if\n\tsupports_vec_gather_load_p.\n\t* tree-vect-patterns.c (vect_get_load_store_mask): New function.\n\t(vect_get_gather_scatter_offset_type): Likewise.\n\t(vect_convert_mask_for_vectype): Likewise.\n\t(vect_add_conversion_to_patterm): Likewise.\n\t(vect_try_gather_scatter_pattern): Likewise.\n\t(vect_recog_gather_scatter_pattern): New pattern recognizer.\n\t(vect_vect_recog_func_ptrs): Add it.\n\t* tree-vect-stmts.c (exist_non_indexing_operands_for_use_p): Use\n\tinternal_fn_mask_index and internal_gather_scatter_fn_p.\n\t(check_load_store_masking): Take the gather_scatter_info as an\n\targument and handle gather loads.\n\t(vect_get_gather_scatter_ops): New function.\n\t(vectorizable_call): Check internal_load_fn_p.\n\t(vectorizable_load): Likewise.  Handle gather load internal\n\tfunctions.\n\t(vectorizable_store): Update call to check_load_store_masking.\n\t* config/aarch64/aarch64.md (UNSPEC_LD1_GATHER): New unspec.\n\t* config/aarch64/iterators.md (SVE_S, SVE_D): New mode iterators.\n\t* config/aarch64/predicates.md (aarch64_gather_scale_operand_w)\n\t(aarch64_gather_scale_operand_d): New predicates.\n\t* config/aarch64/aarch64-sve.md (gather_load<mode>): New expander.\n\t(mask_gather_load<mode>): New insns.\n\ngcc/testsuite/\n\t* gcc.target/aarch64/sve/gather_load_1.c: New test.\n\t* gcc.target/aarch64/sve/gather_load_2.c: Likewise.\n\t* gcc.target/aarch64/sve/gather_load_3.c: Likewise.\n\t* gcc.target/aarch64/sve/gather_load_4.c: Likewise.\n\t* gcc.target/aarch64/sve/gather_load_5.c: Likewise.\n\t* gcc.target/aarch64/sve/gather_load_6.c: Likewise.\n\t* gcc.target/aarch64/sve/gather_load_7.c: Likewise.\n\t* gcc.target/aarch64/sve/mask_gather_load_1.c: Likewise.\n\t* gcc.target/aarch64/sve/mask_gather_load_2.c: Likewise.\n\t* gcc.target/aarch64/sve/mask_gather_load_3.c: Likewise.\n\t* gcc.target/aarch64/sve/mask_gather_load_4.c: Likewise.\n\t* gcc.target/aarch64/sve/mask_gather_load_5.c: Likewise.\n\t* gcc.target/aarch64/sve/mask_gather_load_6.c: Likewise.\n\t* gcc.target/aarch64/sve/mask_gather_load_7.c: Likewise.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r256640", "tree": {"sha": "6fe04d13cf93a02e0cafba41edbff553c1e4de54", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6fe04d13cf93a02e0cafba41edbff553c1e4de54"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bfaa08b7ba1b00bbcc00bb76735c6b3547f5830f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bfaa08b7ba1b00bbcc00bb76735c6b3547f5830f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bfaa08b7ba1b00bbcc00bb76735c6b3547f5830f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bfaa08b7ba1b00bbcc00bb76735c6b3547f5830f/comments", "author": null, "committer": null, "parents": [{"sha": "b781a135a06fc1805c072778d7513df09a32171d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b781a135a06fc1805c072778d7513df09a32171d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b781a135a06fc1805c072778d7513df09a32171d"}], "stats": {"total": 1308, "additions": 1265, "deletions": 43}, "files": [{"sha": "8c808374bbc8184ec3263f8d0bce663d82857214", "filename": "gcc/ChangeLog", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfaa08b7ba1b00bbcc00bb76735c6b3547f5830f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfaa08b7ba1b00bbcc00bb76735c6b3547f5830f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bfaa08b7ba1b00bbcc00bb76735c6b3547f5830f", "patch": "@@ -1,3 +1,64 @@\n+2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* doc/md.texi (gather_load@var{m}): Document.\n+\t(mask_gather_load@var{m}): Likewise.\n+\t* genopinit.c (main): Add supports_vec_gather_load and\n+\tsupports_vec_gather_load_cached to target_optabs.\n+\t* optabs-tree.c (init_tree_optimization_optabs): Use\n+\tggc_cleared_alloc to allocate target_optabs.\n+\t* optabs.def (gather_load_optab, mask_gather_laod_optab): New optabs.\n+\t* internal-fn.def (GATHER_LOAD, MASK_GATHER_LOAD): New internal\n+\tfunctions.\n+\t* internal-fn.h (internal_load_fn_p): Declare.\n+\t(internal_gather_scatter_fn_p): Likewise.\n+\t(internal_fn_mask_index): Likewise.\n+\t(internal_gather_scatter_fn_supported_p): Likewise.\n+\t* internal-fn.c (gather_load_direct): New macro.\n+\t(expand_gather_load_optab_fn): New function.\n+\t(direct_gather_load_optab_supported_p): New macro.\n+\t(direct_internal_fn_optab): New function.\n+\t(internal_load_fn_p): Likewise.\n+\t(internal_gather_scatter_fn_p): Likewise.\n+\t(internal_fn_mask_index): Likewise.\n+\t(internal_gather_scatter_fn_supported_p): Likewise.\n+\t* optabs-query.c (supports_at_least_one_mode_p): New function.\n+\t(supports_vec_gather_load_p): Likewise.\n+\t* optabs-query.h (supports_vec_gather_load_p): Declare.\n+\t* tree-vectorizer.h (gather_scatter_info): Add ifn, element_type\n+\tand memory_type field.\n+\t(NUM_PATTERNS): Bump to 15.\n+\t* tree-vect-data-refs.c: Include internal-fn.h.\n+\t(vect_gather_scatter_fn_p): New function.\n+\t(vect_describe_gather_scatter_call): Likewise.\n+\t(vect_check_gather_scatter): Try using internal functions for\n+\tgather loads.  Recognize existing calls to a gather load function.\n+\t(vect_analyze_data_refs): Consider using gather loads if\n+\tsupports_vec_gather_load_p.\n+\t* tree-vect-patterns.c (vect_get_load_store_mask): New function.\n+\t(vect_get_gather_scatter_offset_type): Likewise.\n+\t(vect_convert_mask_for_vectype): Likewise.\n+\t(vect_add_conversion_to_patterm): Likewise.\n+\t(vect_try_gather_scatter_pattern): Likewise.\n+\t(vect_recog_gather_scatter_pattern): New pattern recognizer.\n+\t(vect_vect_recog_func_ptrs): Add it.\n+\t* tree-vect-stmts.c (exist_non_indexing_operands_for_use_p): Use\n+\tinternal_fn_mask_index and internal_gather_scatter_fn_p.\n+\t(check_load_store_masking): Take the gather_scatter_info as an\n+\targument and handle gather loads.\n+\t(vect_get_gather_scatter_ops): New function.\n+\t(vectorizable_call): Check internal_load_fn_p.\n+\t(vectorizable_load): Likewise.  Handle gather load internal\n+\tfunctions.\n+\t(vectorizable_store): Update call to check_load_store_masking.\n+\t* config/aarch64/aarch64.md (UNSPEC_LD1_GATHER): New unspec.\n+\t* config/aarch64/iterators.md (SVE_S, SVE_D): New mode iterators.\n+\t* config/aarch64/predicates.md (aarch64_gather_scale_operand_w)\n+\t(aarch64_gather_scale_operand_d): New predicates.\n+\t* config/aarch64/aarch64-sve.md (gather_load<mode>): New expander.\n+\t(mask_gather_load<mode>): New insns.\n+\n 2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "04ea25c0a87dd85c5199015a73ecb98b59a0edd3", "filename": "gcc/config/aarch64/aarch64-sve.md", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfaa08b7ba1b00bbcc00bb76735c6b3547f5830f/gcc%2Fconfig%2Faarch64%2Faarch64-sve.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfaa08b7ba1b00bbcc00bb76735c6b3547f5830f/gcc%2Fconfig%2Faarch64%2Faarch64-sve.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-sve.md?ref=bfaa08b7ba1b00bbcc00bb76735c6b3547f5830f", "patch": "@@ -189,6 +189,63 @@\n   \"st1<Vesize>\\t%1.<Vetype>, %2, %0\"\n )\n \n+;; Unpredicated gather loads.\n+(define_expand \"gather_load<mode>\"\n+  [(set (match_operand:SVE_SD 0 \"register_operand\")\n+\t(unspec:SVE_SD\n+\t  [(match_dup 5)\n+\t   (match_operand:DI 1 \"aarch64_reg_or_zero\")\n+\t   (match_operand:<V_INT_EQUIV> 2 \"register_operand\")\n+\t   (match_operand:DI 3 \"const_int_operand\")\n+\t   (match_operand:DI 4 \"aarch64_gather_scale_operand_<Vesize>\")\n+\t   (mem:BLK (scratch))]\n+\t  UNSPEC_LD1_GATHER))]\n+  \"TARGET_SVE\"\n+  {\n+    operands[5] = force_reg (<VPRED>mode, CONSTM1_RTX (<VPRED>mode));\n+  }\n+)\n+\n+;; Predicated gather loads for 32-bit elements.  Operand 3 is true for\n+;; unsigned extension and false for signed extension.\n+(define_insn \"mask_gather_load<mode>\"\n+  [(set (match_operand:SVE_S 0 \"register_operand\" \"=w, w, w, w, w\")\n+\t(unspec:SVE_S\n+\t  [(match_operand:<VPRED> 5 \"register_operand\" \"Upl, Upl, Upl, Upl, Upl\")\n+\t   (match_operand:DI 1 \"aarch64_reg_or_zero\" \"Z, rk, rk, rk, rk\")\n+\t   (match_operand:<V_INT_EQUIV> 2 \"register_operand\" \"w, w, w, w, w\")\n+\t   (match_operand:DI 3 \"const_int_operand\" \"i, Z, Ui1, Z, Ui1\")\n+\t   (match_operand:DI 4 \"aarch64_gather_scale_operand_w\" \"Ui1, Ui1, Ui1, i, i\")\n+\t   (mem:BLK (scratch))]\n+\t  UNSPEC_LD1_GATHER))]\n+  \"TARGET_SVE\"\n+  \"@\n+   ld1w\\t%0.s, %5/z, [%2.s]\n+   ld1w\\t%0.s, %5/z, [%1, %2.s, sxtw]\n+   ld1w\\t%0.s, %5/z, [%1, %2.s, uxtw]\n+   ld1w\\t%0.s, %5/z, [%1, %2.s, sxtw %p4]\n+   ld1w\\t%0.s, %5/z, [%1, %2.s, uxtw %p4]\"\n+)\n+\n+;; Predicated gather loads for 64-bit elements.  The value of operand 3\n+;; doesn't matter in this case.\n+(define_insn \"mask_gather_load<mode>\"\n+  [(set (match_operand:SVE_D 0 \"register_operand\" \"=w, w, w\")\n+\t(unspec:SVE_D\n+\t  [(match_operand:<VPRED> 5 \"register_operand\" \"Upl, Upl, Upl\")\n+\t   (match_operand:DI 1 \"aarch64_reg_or_zero\" \"Z, rk, rk\")\n+\t   (match_operand:<V_INT_EQUIV> 2 \"register_operand\" \"w, w, w\")\n+\t   (match_operand:DI 3 \"const_int_operand\")\n+\t   (match_operand:DI 4 \"aarch64_gather_scale_operand_d\" \"Ui1, Ui1, i\")\n+\t   (mem:BLK (scratch))]\n+\t  UNSPEC_LD1_GATHER))]\n+  \"TARGET_SVE\"\n+  \"@\n+   ld1d\\t%0.d, %5/z, [%2.d]\n+   ld1d\\t%0.d, %5/z, [%1, %2.d]\n+   ld1d\\t%0.d, %5/z, [%1, %2.d, lsl %p4]\"\n+)\n+\n ;; SVE structure moves.\n (define_expand \"mov<mode>\"\n   [(set (match_operand:SVE_STRUCT 0 \"nonimmediate_operand\")"}, {"sha": "455e04d46233d613f3c3e520d2b906ce5f1dc755", "filename": "gcc/config/aarch64/aarch64.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfaa08b7ba1b00bbcc00bb76735c6b3547f5830f/gcc%2Fconfig%2Faarch64%2Faarch64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfaa08b7ba1b00bbcc00bb76735c6b3547f5830f/gcc%2Fconfig%2Faarch64%2Faarch64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.md?ref=bfaa08b7ba1b00bbcc00bb76735c6b3547f5830f", "patch": "@@ -152,6 +152,7 @@\n     UNSPEC_LD1_SVE\n     UNSPEC_ST1_SVE\n     UNSPEC_LD1RQ\n+    UNSPEC_LD1_GATHER\n     UNSPEC_MERGE_PTRUE\n     UNSPEC_PTEST_PTRUE\n     UNSPEC_UNPACKSHI"}, {"sha": "9c1c9dabdd9ca50802ffa21efe6d11314f6503d6", "filename": "gcc/config/aarch64/iterators.md", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfaa08b7ba1b00bbcc00bb76735c6b3547f5830f/gcc%2Fconfig%2Faarch64%2Fiterators.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfaa08b7ba1b00bbcc00bb76735c6b3547f5830f/gcc%2Fconfig%2Faarch64%2Fiterators.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Fiterators.md?ref=bfaa08b7ba1b00bbcc00bb76735c6b3547f5830f", "patch": "@@ -276,6 +276,12 @@\n ;; All SVE vector modes that have 32-bit or 64-bit elements.\n (define_mode_iterator SVE_SD [VNx4SI VNx2DI VNx4SF VNx2DF])\n \n+;; All SVE vector modes that have 32-bit elements.\n+(define_mode_iterator SVE_S [VNx4SI VNx4SF])\n+\n+;; All SVE vector modes that have 64-bit elements.\n+(define_mode_iterator SVE_D [VNx2DI VNx2DF])\n+\n ;; All SVE integer vector modes that have 32-bit or 64-bit elements.\n (define_mode_iterator SVE_SDI [VNx4SI VNx2DI])\n "}, {"sha": "0df1a4d324c329848cbb447372dc7712eb34840e", "filename": "gcc/config/aarch64/predicates.md", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfaa08b7ba1b00bbcc00bb76735c6b3547f5830f/gcc%2Fconfig%2Faarch64%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfaa08b7ba1b00bbcc00bb76735c6b3547f5830f/gcc%2Fconfig%2Faarch64%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Fpredicates.md?ref=bfaa08b7ba1b00bbcc00bb76735c6b3547f5830f", "patch": "@@ -610,3 +610,11 @@\n (define_predicate \"aarch64_sve_vec_perm_operand\"\n   (ior (match_operand 0 \"register_operand\")\n        (match_operand 0 \"aarch64_constant_vector_operand\")))\n+\n+(define_predicate \"aarch64_gather_scale_operand_w\"\n+  (and (match_code \"const_int\")\n+       (match_test \"INTVAL (op) == 1 || INTVAL (op) == 4\")))\n+\n+(define_predicate \"aarch64_gather_scale_operand_d\"\n+  (and (match_code \"const_int\")\n+       (match_test \"INTVAL (op) == 1 || INTVAL (op) == 8\")))"}, {"sha": "245fa90e6d14d13aca3abf8c1f87599276a77b04", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfaa08b7ba1b00bbcc00bb76735c6b3547f5830f/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfaa08b7ba1b00bbcc00bb76735c6b3547f5830f/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=bfaa08b7ba1b00bbcc00bb76735c6b3547f5830f", "patch": "@@ -4908,6 +4908,35 @@ for (j = 0; j < GET_MODE_NUNITS (@var{n}); j++)\n \n This pattern is not allowed to @code{FAIL}.\n \n+@cindex @code{gather_load@var{m}} instruction pattern\n+@item @samp{gather_load@var{m}}\n+Load several separate memory locations into a vector of mode @var{m}.\n+Operand 1 is a scalar base address and operand 2 is a vector of\n+offsets from that base.  Operand 0 is a destination vector with the\n+same number of elements as the offset.  For each element index @var{i}:\n+\n+@itemize @bullet\n+@item\n+extend the offset element @var{i} to address width, using zero\n+extension if operand 3 is 1 and sign extension if operand 3 is zero;\n+@item\n+multiply the extended offset by operand 4;\n+@item\n+add the result to the base; and\n+@item\n+load the value at that address into element @var{i} of operand 0.\n+@end itemize\n+\n+The value of operand 3 does not matter if the offsets are already\n+address width.\n+\n+@cindex @code{mask_gather_load@var{m}} instruction pattern\n+@item @samp{mask_gather_load@var{m}}\n+Like @samp{gather_load@var{m}}, but takes an extra mask operand as\n+operand 5.  Bit @var{i} of the mask is set if element @var{i}\n+of the result should be loaded from memory and clear if element @var{i}\n+of the result should be set to zero.\n+\n @cindex @code{vec_set@var{m}} instruction pattern\n @item @samp{vec_set@var{m}}\n Set given field in the vector value.  Operand 0 is the vector to modify,"}, {"sha": "dd4e3aa03905b7e60dec332630a3c8a2abd87758", "filename": "gcc/genopinit.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfaa08b7ba1b00bbcc00bb76735c6b3547f5830f/gcc%2Fgenopinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfaa08b7ba1b00bbcc00bb76735c6b3547f5830f/gcc%2Fgenopinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenopinit.c?ref=bfaa08b7ba1b00bbcc00bb76735c6b3547f5830f", "patch": "@@ -234,6 +234,11 @@ main (int argc, const char **argv)\n \t   \"struct target_optabs {\\n\"\n \t   \"  /* Patterns that are used by optabs that are enabled for this target.  */\\n\"\n \t   \"  bool pat_enable[NUM_OPTAB_PATTERNS];\\n\"\n+\t   \"\\n\"\n+\t   \"  /* Cache if the target supports vec_gather_load for at least one vector\\n\"\n+\t   \"     mode.  */\\n\"\n+\t   \"  bool supports_vec_gather_load;\\n\"\n+\t   \"  bool supports_vec_gather_load_cached;\\n\"\n \t   \"};\\n\"\n \t   \"extern void init_all_optabs (struct target_optabs *);\\n\"\n \t   \"\\n\""}, {"sha": "8cf5b79c0289c1741ff5a5c9a40b0cb12e4cf96d", "filename": "gcc/internal-fn.c", "status": "modified", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfaa08b7ba1b00bbcc00bb76735c6b3547f5830f/gcc%2Finternal-fn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfaa08b7ba1b00bbcc00bb76735c6b3547f5830f/gcc%2Finternal-fn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.c?ref=bfaa08b7ba1b00bbcc00bb76735c6b3547f5830f", "patch": "@@ -83,6 +83,7 @@ init_internal_fns ()\n #define mask_load_direct { -1, 2, false }\n #define load_lanes_direct { -1, -1, false }\n #define mask_load_lanes_direct { -1, -1, false }\n+#define gather_load_direct { -1, -1, false }\n #define mask_store_direct { 3, 2, false }\n #define store_lanes_direct { 0, 0, false }\n #define mask_store_lanes_direct { 0, 0, false }\n@@ -2729,6 +2730,38 @@ expand_LAUNDER (internal_fn, gcall *call)\n   expand_assignment (lhs, gimple_call_arg (call, 0), false);\n }\n \n+/* Expand {MASK_,}GATHER_LOAD call CALL using optab OPTAB.  */\n+\n+static void\n+expand_gather_load_optab_fn (internal_fn, gcall *stmt, direct_optab optab)\n+{\n+  tree lhs = gimple_call_lhs (stmt);\n+  tree base = gimple_call_arg (stmt, 0);\n+  tree offset = gimple_call_arg (stmt, 1);\n+  tree scale = gimple_call_arg (stmt, 2);\n+\n+  rtx lhs_rtx = expand_expr (lhs, NULL_RTX, VOIDmode, EXPAND_WRITE);\n+  rtx base_rtx = expand_normal (base);\n+  rtx offset_rtx = expand_normal (offset);\n+  HOST_WIDE_INT scale_int = tree_to_shwi (scale);\n+\n+  int i = 0;\n+  struct expand_operand ops[6];\n+  create_output_operand (&ops[i++], lhs_rtx, TYPE_MODE (TREE_TYPE (lhs)));\n+  create_address_operand (&ops[i++], base_rtx);\n+  create_input_operand (&ops[i++], offset_rtx, TYPE_MODE (TREE_TYPE (offset)));\n+  create_integer_operand (&ops[i++], TYPE_UNSIGNED (TREE_TYPE (offset)));\n+  create_integer_operand (&ops[i++], scale_int);\n+  if (optab == mask_gather_load_optab)\n+    {\n+      tree mask = gimple_call_arg (stmt, 3);\n+      rtx mask_rtx = expand_normal (mask);\n+      create_input_operand (&ops[i++], mask_rtx, TYPE_MODE (TREE_TYPE (mask)));\n+    }\n+  insn_code icode = direct_optab_handler (optab, TYPE_MODE (TREE_TYPE (lhs)));\n+  expand_insn (icode, i, ops);\n+}\n+\n /* Expand DIVMOD() using:\n  a) optab handler for udivmod/sdivmod if it is available.\n  b) If optab_handler doesn't exist, generate call to\n@@ -2979,6 +3012,7 @@ multi_vector_optab_supported_p (convert_optab optab, tree_pair types,\n #define direct_mask_load_optab_supported_p direct_optab_supported_p\n #define direct_load_lanes_optab_supported_p multi_vector_optab_supported_p\n #define direct_mask_load_lanes_optab_supported_p multi_vector_optab_supported_p\n+#define direct_gather_load_optab_supported_p direct_optab_supported_p\n #define direct_mask_store_optab_supported_p direct_optab_supported_p\n #define direct_store_lanes_optab_supported_p multi_vector_optab_supported_p\n #define direct_mask_store_lanes_optab_supported_p multi_vector_optab_supported_p\n@@ -3010,6 +3044,25 @@ direct_internal_fn_optab (internal_fn fn, tree_pair types)\n   gcc_unreachable ();\n }\n \n+/* Return the optab used by internal function FN.  */\n+\n+static optab\n+direct_internal_fn_optab (internal_fn fn)\n+{\n+  switch (fn)\n+    {\n+#define DEF_INTERNAL_FN(CODE, FLAGS, FNSPEC) \\\n+    case IFN_##CODE: break;\n+#define DEF_INTERNAL_OPTAB_FN(CODE, FLAGS, OPTAB, TYPE) \\\n+    case IFN_##CODE: return OPTAB##_optab;\n+#include \"internal-fn.def\"\n+\n+    case IFN_LAST:\n+      break;\n+    }\n+  gcc_unreachable ();\n+}\n+\n /* Return true if FN is supported for the types in TYPES when the\n    optimization type is OPT_TYPE.  The types are those associated with\n    the \"type0\" and \"type1\" fields of FN's direct_internal_fn_info\n@@ -3130,6 +3183,87 @@ get_conditional_internal_fn (tree_code code)\n     }\n }\n \n+/* Return true if IFN is some form of load from memory.  */\n+\n+bool\n+internal_load_fn_p (internal_fn fn)\n+{\n+  switch (fn)\n+    {\n+    case IFN_MASK_LOAD:\n+    case IFN_LOAD_LANES:\n+    case IFN_MASK_LOAD_LANES:\n+    case IFN_GATHER_LOAD:\n+    case IFN_MASK_GATHER_LOAD:\n+      return true;\n+\n+    default:\n+      return false;\n+    }\n+}\n+\n+/* Return true if IFN is some form of gather load or scatter store.  */\n+\n+bool\n+internal_gather_scatter_fn_p (internal_fn fn)\n+{\n+  switch (fn)\n+    {\n+    case IFN_GATHER_LOAD:\n+    case IFN_MASK_GATHER_LOAD:\n+      return true;\n+\n+    default:\n+      return false;\n+    }\n+}\n+\n+/* If FN takes a vector mask argument, return the index of that argument,\n+   otherwise return -1.  */\n+\n+int\n+internal_fn_mask_index (internal_fn fn)\n+{\n+  switch (fn)\n+    {\n+    case IFN_MASK_LOAD:\n+    case IFN_MASK_LOAD_LANES:\n+    case IFN_MASK_STORE:\n+    case IFN_MASK_STORE_LANES:\n+      return 2;\n+\n+    case IFN_MASK_GATHER_LOAD:\n+      return 3;\n+\n+    default:\n+      return -1;\n+    }\n+}\n+\n+/* Return true if the target supports gather load or scatter store function\n+   IFN.  For loads, VECTOR_TYPE is the vector type of the load result,\n+   while for stores it is the vector type of the stored data argument.\n+   MEMORY_ELEMENT_TYPE is the type of the memory elements being loaded\n+   or stored.  OFFSET_SIGN is the sign of the offset argument, which is\n+   only relevant when the offset is narrower than an address.  SCALE is\n+   the amount by which the offset should be multiplied *after* it has\n+   been extended to address width.  */\n+\n+bool\n+internal_gather_scatter_fn_supported_p (internal_fn ifn, tree vector_type,\n+\t\t\t\t\ttree memory_element_type,\n+\t\t\t\t\tsignop offset_sign, int scale)\n+{\n+  if (!tree_int_cst_equal (TYPE_SIZE (TREE_TYPE (vector_type)),\n+\t\t\t   TYPE_SIZE (memory_element_type)))\n+    return false;\n+  optab optab = direct_internal_fn_optab (ifn);\n+  insn_code icode = direct_optab_handler (optab, TYPE_MODE (vector_type));\n+  return (icode != CODE_FOR_nothing\n+\t  && insn_operand_matches (icode, 3, GEN_INT (offset_sign == UNSIGNED))\n+\t  && insn_operand_matches (icode, 4, GEN_INT (scale)));\n+}\n+\n /* Expand STMT as though it were a call to internal function FN.  */\n \n void"}, {"sha": "db81b83eb5b4120a65f1260f2a5583e81784bedd", "filename": "gcc/internal-fn.def", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfaa08b7ba1b00bbcc00bb76735c6b3547f5830f/gcc%2Finternal-fn.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfaa08b7ba1b00bbcc00bb76735c6b3547f5830f/gcc%2Finternal-fn.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.def?ref=bfaa08b7ba1b00bbcc00bb76735c6b3547f5830f", "patch": "@@ -48,6 +48,7 @@ along with GCC; see the file COPYING3.  If not see\n    - mask_load: currently just maskload\n    - load_lanes: currently just vec_load_lanes\n    - mask_load_lanes: currently just vec_mask_load_lanes\n+   - gather_load: used for {mask_,}gather_load\n \n    - mask_store: currently just maskstore\n    - store_lanes: currently just vec_store_lanes\n@@ -118,6 +119,10 @@ DEF_INTERNAL_OPTAB_FN (LOAD_LANES, ECF_CONST, vec_load_lanes, load_lanes)\n DEF_INTERNAL_OPTAB_FN (MASK_LOAD_LANES, ECF_PURE,\n \t\t       vec_mask_load_lanes, mask_load_lanes)\n \n+DEF_INTERNAL_OPTAB_FN (GATHER_LOAD, ECF_PURE, gather_load, gather_load)\n+DEF_INTERNAL_OPTAB_FN (MASK_GATHER_LOAD, ECF_PURE,\n+\t\t       mask_gather_load, gather_load)\n+\n DEF_INTERNAL_OPTAB_FN (MASK_STORE, 0, maskstore, mask_store)\n DEF_INTERNAL_OPTAB_FN (STORE_LANES, ECF_CONST, vec_store_lanes, store_lanes)\n DEF_INTERNAL_OPTAB_FN (MASK_STORE_LANES, 0,"}, {"sha": "c536d1ff5cb6ae26732e152e578472ab7eeb3aee", "filename": "gcc/internal-fn.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfaa08b7ba1b00bbcc00bb76735c6b3547f5830f/gcc%2Finternal-fn.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfaa08b7ba1b00bbcc00bb76735c6b3547f5830f/gcc%2Finternal-fn.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.h?ref=bfaa08b7ba1b00bbcc00bb76735c6b3547f5830f", "patch": "@@ -192,6 +192,12 @@ extern bool set_edom_supported_p (void);\n \n extern internal_fn get_conditional_internal_fn (tree_code);\n \n+extern bool internal_load_fn_p (internal_fn);\n+extern bool internal_gather_scatter_fn_p (internal_fn);\n+extern int internal_fn_mask_index (internal_fn);\n+extern bool internal_gather_scatter_fn_supported_p (internal_fn, tree,\n+\t\t\t\t\t\t    tree, signop, int);\n+\n extern void expand_internal_call (gcall *);\n extern void expand_internal_call (internal_fn, gcall *);\n extern void expand_PHI (internal_fn, gcall *);"}, {"sha": "b5c7a76e67e415a4ae23a0991547a7ddae51b957", "filename": "gcc/optabs-query.c", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfaa08b7ba1b00bbcc00bb76735c6b3547f5830f/gcc%2Foptabs-query.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfaa08b7ba1b00bbcc00bb76735c6b3547f5830f/gcc%2Foptabs-query.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs-query.c?ref=bfaa08b7ba1b00bbcc00bb76735c6b3547f5830f", "patch": "@@ -682,3 +682,32 @@ lshift_cheap_p (bool speed_p)\n \n   return cheap[speed_p];\n }\n+\n+/* Return true if optab OP supports at least one mode.  */\n+\n+static bool\n+supports_at_least_one_mode_p (optab op)\n+{\n+  for (int i = 0; i < NUM_MACHINE_MODES; ++i)\n+    if (direct_optab_handler (op, (machine_mode) i) != CODE_FOR_nothing)\n+      return true;\n+\n+  return false;\n+}\n+\n+/* Return true if vec_gather_load is available for at least one vector\n+   mode.  */\n+\n+bool\n+supports_vec_gather_load_p ()\n+{\n+  if (this_fn_optabs->supports_vec_gather_load_cached)\n+    return this_fn_optabs->supports_vec_gather_load;\n+\n+  this_fn_optabs->supports_vec_gather_load_cached = true;\n+\n+  this_fn_optabs->supports_vec_gather_load\n+    = supports_at_least_one_mode_p (gather_load_optab);\n+\n+  return this_fn_optabs->supports_vec_gather_load;\n+}"}, {"sha": "2b02d07b1be98a37d736ea1bf928f0e91939f353", "filename": "gcc/optabs-query.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfaa08b7ba1b00bbcc00bb76735c6b3547f5830f/gcc%2Foptabs-query.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfaa08b7ba1b00bbcc00bb76735c6b3547f5830f/gcc%2Foptabs-query.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs-query.h?ref=bfaa08b7ba1b00bbcc00bb76735c6b3547f5830f", "patch": "@@ -191,6 +191,7 @@ bool can_compare_and_swap_p (machine_mode, bool);\n bool can_atomic_exchange_p (machine_mode, bool);\n bool can_atomic_load_p (machine_mode);\n bool lshift_cheap_p (bool);\n+bool supports_vec_gather_load_p ();\n \n /* Version of find_widening_optab_handler_and_mode that operates on\n    specific mode types.  */"}, {"sha": "71e172c4900a28c793cdfc1c32e07d08d6656d60", "filename": "gcc/optabs-tree.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfaa08b7ba1b00bbcc00bb76735c6b3547f5830f/gcc%2Foptabs-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfaa08b7ba1b00bbcc00bb76735c6b3547f5830f/gcc%2Foptabs-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs-tree.c?ref=bfaa08b7ba1b00bbcc00bb76735c6b3547f5830f", "patch": "@@ -358,7 +358,7 @@ init_tree_optimization_optabs (tree optnode)\n   if (tmp_optabs)\n     memset (tmp_optabs, 0, sizeof (struct target_optabs));\n   else\n-    tmp_optabs = ggc_alloc<target_optabs> ();\n+    tmp_optabs = ggc_cleared_alloc<target_optabs> ();\n \n   /* Generate a new set of optabs into tmp_optabs.  */\n   init_all_optabs (tmp_optabs);"}, {"sha": "532cf9789ba2dd3652ba69ba0719de2abccbfe19", "filename": "gcc/optabs.def", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfaa08b7ba1b00bbcc00bb76735c6b3547f5830f/gcc%2Foptabs.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfaa08b7ba1b00bbcc00bb76735c6b3547f5830f/gcc%2Foptabs.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.def?ref=bfaa08b7ba1b00bbcc00bb76735c6b3547f5830f", "patch": "@@ -384,6 +384,9 @@ OPTAB_D (atomic_xor_optab, \"atomic_xor$I$a\")\n OPTAB_D (get_thread_pointer_optab, \"get_thread_pointer$I$a\")\n OPTAB_D (set_thread_pointer_optab, \"set_thread_pointer$I$a\")\n \n+OPTAB_D (gather_load_optab, \"gather_load$a\")\n+OPTAB_D (mask_gather_load_optab, \"mask_gather_load$a\")\n+\n OPTAB_DC (vec_duplicate_optab, \"vec_duplicate$a\", VEC_DUPLICATE)\n OPTAB_DC (vec_series_optab, \"vec_series$a\", VEC_SERIES)\n OPTAB_D (vec_shl_insert_optab, \"vec_shl_insert_$a\")"}, {"sha": "78e5f4c5ababa4049c6c0d76e4bc89f23e83fad1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfaa08b7ba1b00bbcc00bb76735c6b3547f5830f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfaa08b7ba1b00bbcc00bb76735c6b3547f5830f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=bfaa08b7ba1b00bbcc00bb76735c6b3547f5830f", "patch": "@@ -1,3 +1,22 @@\n+2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* gcc.target/aarch64/sve/gather_load_1.c: New test.\n+\t* gcc.target/aarch64/sve/gather_load_2.c: Likewise.\n+\t* gcc.target/aarch64/sve/gather_load_3.c: Likewise.\n+\t* gcc.target/aarch64/sve/gather_load_4.c: Likewise.\n+\t* gcc.target/aarch64/sve/gather_load_5.c: Likewise.\n+\t* gcc.target/aarch64/sve/gather_load_6.c: Likewise.\n+\t* gcc.target/aarch64/sve/gather_load_7.c: Likewise.\n+\t* gcc.target/aarch64/sve/mask_gather_load_1.c: Likewise.\n+\t* gcc.target/aarch64/sve/mask_gather_load_2.c: Likewise.\n+\t* gcc.target/aarch64/sve/mask_gather_load_3.c: Likewise.\n+\t* gcc.target/aarch64/sve/mask_gather_load_4.c: Likewise.\n+\t* gcc.target/aarch64/sve/mask_gather_load_5.c: Likewise.\n+\t* gcc.target/aarch64/sve/mask_gather_load_6.c: Likewise.\n+\t* gcc.target/aarch64/sve/mask_gather_load_7.c: Likewise.\n+\n 2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "33f1629250fece33f5155c5419b465a31cb30c5e", "filename": "gcc/testsuite/gcc.target/aarch64/sve/gather_load_1.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfaa08b7ba1b00bbcc00bb76735c6b3547f5830f/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fgather_load_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfaa08b7ba1b00bbcc00bb76735c6b3547f5830f/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fgather_load_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fgather_load_1.c?ref=bfaa08b7ba1b00bbcc00bb76735c6b3547f5830f", "patch": "@@ -0,0 +1,32 @@\n+/* { dg-do assemble { target aarch64_asm_sve_ok } } */\n+/* { dg-options \"-O2 -ftree-vectorize --save-temps\" } */\n+\n+#include <stdint.h>\n+\n+#ifndef INDEX32\n+#define INDEX32 int32_t\n+#define INDEX64 int64_t\n+#endif\n+\n+/* Invoked 18 times for each data size.  */\n+#define TEST_LOOP(DATA_TYPE, BITS)\t\t\t\t\t\\\n+  void __attribute__ ((noinline, noclone))\t\t\t\t\\\n+  f_##DATA_TYPE (DATA_TYPE *restrict dest, DATA_TYPE *restrict src,\t\\\n+\t\t INDEX##BITS *indices, int n)\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    for (int i = 9; i < n; ++i)\t\t\t\t\t\t\\\n+      dest[i] += src[indices[i]];\t\t\t\t\t\\\n+  }\n+\n+#define TEST_ALL(T)\t\t\t\t\\\n+  T (int32_t, 32)\t\t\t\t\\\n+  T (uint32_t, 32)\t\t\t\t\\\n+  T (float, 32)\t\t\t\t\t\\\n+  T (int64_t, 64)\t\t\t\t\\\n+  T (uint64_t, 64)\t\t\t\t\\\n+  T (double, 64)\n+\n+TEST_ALL (TEST_LOOP)\n+\n+/* { dg-final { scan-assembler-times {\\tld1w\\tz[0-9]+\\.s, p[0-7]/z, \\[x[0-9]+, z[0-9]+.s, sxtw 2\\]\\n} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tld1d\\tz[0-9]+\\.d, p[0-7]/z, \\[x[0-9]+, z[0-9]+.d, lsl 3\\]\\n} 3 } } */"}, {"sha": "e3fb2a9007baa158494c7eb51466a5121afab9e2", "filename": "gcc/testsuite/gcc.target/aarch64/sve/gather_load_2.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfaa08b7ba1b00bbcc00bb76735c6b3547f5830f/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fgather_load_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfaa08b7ba1b00bbcc00bb76735c6b3547f5830f/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fgather_load_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fgather_load_2.c?ref=bfaa08b7ba1b00bbcc00bb76735c6b3547f5830f", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-do assemble { target aarch64_asm_sve_ok } } */\n+/* { dg-options \"-O2 -ftree-vectorize --save-temps\" } */\n+\n+#define INDEX32 uint32_t\n+#define INDEX64 uint64_t\n+\n+#include \"gather_load_1.c\"\n+\n+/* { dg-final { scan-assembler-times {\\tld1w\\tz[0-9]+\\.s, p[0-7]/z, \\[x[0-9]+, z[0-9]+.s, uxtw 2\\]\\n} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tld1d\\tz[0-9]+\\.d, p[0-7]/z, \\[x[0-9]+, z[0-9]+.d, lsl 3\\]\\n} 3 } } */"}, {"sha": "54af507de4486196975fb9c7b26a4c3f1b6ad5d5", "filename": "gcc/testsuite/gcc.target/aarch64/sve/gather_load_3.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfaa08b7ba1b00bbcc00bb76735c6b3547f5830f/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fgather_load_3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfaa08b7ba1b00bbcc00bb76735c6b3547f5830f/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fgather_load_3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fgather_load_3.c?ref=bfaa08b7ba1b00bbcc00bb76735c6b3547f5830f", "patch": "@@ -0,0 +1,32 @@\n+/* { dg-do assemble { target aarch64_asm_sve_ok } } */\n+/* { dg-options \"-O2 -ftree-vectorize --save-temps\" } */\n+\n+#include <stdint.h>\n+\n+#ifndef INDEX32\n+#define INDEX32 int32_t\n+#define INDEX64 int64_t\n+#endif\n+\n+/* Invoked 18 times for each data size.  */\n+#define TEST_LOOP(DATA_TYPE, BITS)\t\t\t\t\t\\\n+  void __attribute__ ((noinline, noclone))\t\t\t\t\\\n+  f_##DATA_TYPE (DATA_TYPE *restrict dest, DATA_TYPE *restrict src,\t\\\n+\t\t INDEX##BITS *indices, int n)\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    for (int i = 9; i < n; ++i)\t\t\t\t\t\t\\\n+      dest[i] += *(DATA_TYPE *) ((char *) src + indices[i]);\t\t\\\n+  }\n+\n+#define TEST_ALL(T)\t\t\t\t\\\n+  T (int32_t, 32)\t\t\t\t\\\n+  T (uint32_t, 32)\t\t\t\t\\\n+  T (float, 32)\t\t\t\t\t\\\n+  T (int64_t, 64)\t\t\t\t\\\n+  T (uint64_t, 64)\t\t\t\t\\\n+  T (double, 64)\n+\n+TEST_ALL (TEST_LOOP)\n+\n+/* { dg-final { scan-assembler-times {\\tld1w\\tz[0-9]+\\.s, p[0-7]/z, \\[x[0-9]+, z[0-9]+.s, sxtw\\]\\n} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tld1d\\tz[0-9]+\\.d, p[0-7]/z, \\[x[0-9]+, z[0-9]+.d\\]\\n} 3 } } */"}, {"sha": "3e2c83111a5be12e7346e9481d6d2237ee3bfeea", "filename": "gcc/testsuite/gcc.target/aarch64/sve/gather_load_4.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfaa08b7ba1b00bbcc00bb76735c6b3547f5830f/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fgather_load_4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfaa08b7ba1b00bbcc00bb76735c6b3547f5830f/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fgather_load_4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fgather_load_4.c?ref=bfaa08b7ba1b00bbcc00bb76735c6b3547f5830f", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-do assemble { target aarch64_asm_sve_ok } } */\n+/* { dg-options \"-O2 -ftree-vectorize --save-temps\" } */\n+\n+#define INDEX32 uint32_t\n+#define INDEX64 uint64_t\n+\n+#include \"gather_load_3.c\"\n+\n+/* { dg-final { scan-assembler-times {\\tld1w\\tz[0-9]+\\.s, p[0-7]/z, \\[x[0-9]+, z[0-9]+.s, uxtw\\]\\n} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tld1d\\tz[0-9]+\\.d, p[0-7]/z, \\[x[0-9]+, z[0-9]+.d\\]\\n} 3 } } */"}, {"sha": "b22a80ab83b5b80c183eda5f4b4b49a26bef3146", "filename": "gcc/testsuite/gcc.target/aarch64/sve/gather_load_5.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfaa08b7ba1b00bbcc00bb76735c6b3547f5830f/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fgather_load_5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfaa08b7ba1b00bbcc00bb76735c6b3547f5830f/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fgather_load_5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fgather_load_5.c?ref=bfaa08b7ba1b00bbcc00bb76735c6b3547f5830f", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do assemble { target aarch64_asm_sve_ok } } */\n+/* { dg-options \"-O2 -ftree-vectorize --save-temps\" } */\n+\n+#include <stdint.h>\n+\n+/* Invoked 18 times for each data size.  */\n+#define TEST_LOOP(DATA_TYPE)\t\t\t\t\t\t\\\n+  void __attribute__ ((noinline, noclone))\t\t\t\t\\\n+  f_##DATA_TYPE (DATA_TYPE *restrict dest, DATA_TYPE *restrict *src,\t\\\n+\t\t int n)\t\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    for (int i = 9; i < n; ++i)\t\t\t\t\t\t\\\n+      dest[i] += *src[i];\t\t\t\t\t\t\\\n+  }\n+\n+#define TEST_ALL(T)\t\t\t\t\\\n+  T (int64_t)\t\t\t\t\t\\\n+  T (uint64_t)\t\t\t\t\t\\\n+  T (double)\n+\n+TEST_ALL (TEST_LOOP)\n+\n+/* { dg-final { scan-assembler-times {\\tld1d\\tz[0-9]+\\.d, p[0-7]/z, \\[z[0-9]+.d\\]\\n} 3 } } */"}, {"sha": "8445be423f0e105092560e1842e1d0df52309ce7", "filename": "gcc/testsuite/gcc.target/aarch64/sve/gather_load_6.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfaa08b7ba1b00bbcc00bb76735c6b3547f5830f/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fgather_load_6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfaa08b7ba1b00bbcc00bb76735c6b3547f5830f/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fgather_load_6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fgather_load_6.c?ref=bfaa08b7ba1b00bbcc00bb76735c6b3547f5830f", "patch": "@@ -0,0 +1,36 @@\n+/* { dg-do assemble { target aarch64_asm_sve_ok } } */\n+/* { dg-options \"-O2 -ftree-vectorize -fwrapv --save-temps\" } */\n+\n+#include <stdint.h>\n+\n+#ifndef INDEX32\n+#define INDEX16 int16_t\n+#define INDEX32 int32_t\n+#endif\n+\n+/* Invoked 18 times for each data size.  */\n+#define TEST_LOOP(DATA_TYPE, BITS)\t\t\t\t\t\\\n+  void __attribute__ ((noinline, noclone))\t\t\t\t\\\n+  f_##DATA_TYPE (DATA_TYPE *restrict dest, DATA_TYPE *restrict src,\t\\\n+\t\t INDEX##BITS *indices, INDEX##BITS mask, int n)\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    for (int i = 9; i < n; ++i)\t\t\t\t\t\t\\\n+      dest[i] = src[(INDEX##BITS) (indices[i] | mask)];\t\t\t\\\n+  }\n+\n+#define TEST_ALL(T)\t\t\t\t\\\n+  T (int32_t, 16)\t\t\t\t\\\n+  T (uint32_t, 16)\t\t\t\t\\\n+  T (float, 16)\t\t\t\t\t\\\n+  T (int64_t, 32)\t\t\t\t\\\n+  T (uint64_t, 32)\t\t\t\t\\\n+  T (double, 32)\n+\n+TEST_ALL (TEST_LOOP)\n+\n+/* { dg-final { scan-assembler-times {\\tsunpkhi\\tz[0-9]+\\.s, z[0-9]+\\.h\\n} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tsunpklo\\tz[0-9]+\\.s, z[0-9]+\\.h\\n} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tsunpkhi\\tz[0-9]+\\.d, z[0-9]+\\.s\\n} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tsunpklo\\tz[0-9]+\\.d, z[0-9]+\\.s\\n} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tld1w\\tz[0-9]+\\.s, p[0-7]/z, \\[x[0-9]+, z[0-9]+.s, sxtw 2\\]\\n} 6 } } */\n+/* { dg-final { scan-assembler-times {\\tld1d\\tz[0-9]+\\.d, p[0-7]/z, \\[x[0-9]+, z[0-9]+.d, lsl 3\\]\\n} 6 } } */"}, {"sha": "f5ae9309edf9020ecf5ca39a6035f3005087e8e2", "filename": "gcc/testsuite/gcc.target/aarch64/sve/gather_load_7.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfaa08b7ba1b00bbcc00bb76735c6b3547f5830f/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fgather_load_7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfaa08b7ba1b00bbcc00bb76735c6b3547f5830f/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fgather_load_7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fgather_load_7.c?ref=bfaa08b7ba1b00bbcc00bb76735c6b3547f5830f", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do assemble { target aarch64_asm_sve_ok } } */\n+/* { dg-options \"-O2 -ftree-vectorize --save-temps\" } */\n+\n+#define INDEX16 uint16_t\n+#define INDEX32 uint32_t\n+\n+#include \"gather_load_6.c\"\n+\n+/* { dg-final { scan-assembler-times {\\tuunpkhi\\tz[0-9]+\\.s, z[0-9]+\\.h\\n} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tuunpklo\\tz[0-9]+\\.s, z[0-9]+\\.h\\n} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tuunpkhi\\tz[0-9]+\\.d, z[0-9]+\\.s\\n} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tuunpklo\\tz[0-9]+\\.d, z[0-9]+\\.s\\n} 3 } } */\n+/* Either extension type is OK here.  */\n+/* { dg-final { scan-assembler-times {\\tld1w\\tz[0-9]+\\.s, p[0-7]/z, \\[x[0-9]+, z[0-9]+.s, [us]xtw 2\\]\\n} 6 } } */\n+/* { dg-final { scan-assembler-times {\\tld1d\\tz[0-9]+\\.d, p[0-7]/z, \\[x[0-9]+, z[0-9]+.d, lsl 3\\]\\n} 6 } } */"}, {"sha": "15f863fde2022c952822351ae4820e8435f5e3b7", "filename": "gcc/testsuite/gcc.target/aarch64/sve/mask_gather_load_1.c", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfaa08b7ba1b00bbcc00bb76735c6b3547f5830f/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fmask_gather_load_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfaa08b7ba1b00bbcc00bb76735c6b3547f5830f/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fmask_gather_load_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fmask_gather_load_1.c?ref=bfaa08b7ba1b00bbcc00bb76735c6b3547f5830f", "patch": "@@ -0,0 +1,52 @@\n+/* { dg-do assemble { target aarch64_asm_sve_ok } } */\n+/* { dg-options \"-O2 -ftree-vectorize -ffast-math --save-temps\" } */\n+\n+#include <stdint.h>\n+\n+#ifndef INDEX32\n+#define INDEX32 int32_t\n+#define INDEX64 int64_t\n+#endif\n+\n+#define TEST_LOOP(DATA_TYPE, CMP_TYPE, BITS)\t\t\t\t\\\n+  void\t\t\t\t\t\t\t\t\t\\\n+  f_##DATA_TYPE##_##CMP_TYPE\t\t\t\t\t\t\\\n+    (DATA_TYPE *restrict dest, DATA_TYPE *restrict src,\t\t\t\\\n+     CMP_TYPE *cmp1, CMP_TYPE *cmp2, INDEX##BITS *indices, int n)\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    for (int i = 0; i < n; ++i)\t\t\t\t\t\t\\\n+      if (cmp1[i] == cmp2[i])\t\t\t\t\t\t\\\n+\tdest[i] += src[indices[i]];\t\t\t\t\t\\\n+  }\n+\n+#define TEST32(T, DATA_TYPE)\t\t\\\n+  T (DATA_TYPE, int32_t, 32)\t\t\\\n+  T (DATA_TYPE, uint32_t, 32)\t\t\\\n+  T (DATA_TYPE, float, 32)\n+\n+#define TEST64(T, DATA_TYPE)\t\t\\\n+  T (DATA_TYPE, int64_t, 64)\t\t\\\n+  T (DATA_TYPE, uint64_t, 64)\t\t\\\n+  T (DATA_TYPE, double, 64)\n+\n+#define TEST_ALL(T)\t\t\t\\\n+  TEST32 (T, int32_t)\t\t\t\\\n+  TEST32 (T, uint32_t)\t\t\t\\\n+  TEST32 (T, float)\t\t\t\\\n+  TEST64 (T, int64_t)\t\t\t\\\n+  TEST64 (T, uint64_t)\t\t\t\\\n+  TEST64 (T, double)\n+\n+TEST_ALL (TEST_LOOP)\n+\n+/* { dg-final { scan-assembler-times {\\tld1w\\tz[0-9]+\\.s, p[0-7]/z, \\[x[0-9]+, x[0-9]+, lsl 2\\]\\n} 36 } } */\n+/* { dg-final { scan-assembler-times {\\tcmpeq\\tp[0-7]\\.s, p[0-7]/z, z[0-9]+\\.s, z[0-9]+\\.s\\n} 6 } } */\n+/* { dg-final { scan-assembler-times {\\tfcmeq\\tp[0-7]\\.s, p[0-7]/z, z[0-9]+\\.s, z[0-9]+\\.s\\n} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tld1w\\tz[0-9]+\\.s, p[0-7]/z, \\[x[0-9]+, z[0-9]+\\.s, sxtw 2\\]\\n} 9 } } */\n+/* { dg-final { scan-assembler-times {\\tst1w\\tz[0-9]+\\.s, p[0-7], \\[x[0-9]+, x[0-9]+, lsl 2\\]\\n} 9 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tld1d\\tz[0-9]+\\.d, p[0-7]/z, \\[x[0-9]+, x[0-9]+, lsl 3\\]\\n} 36 } } */\n+/* { dg-final { scan-assembler-times {\\tcmpeq\\tp[0-7]\\.d, p[0-7]/z, z[0-9]+\\.d, z[0-9]+\\.d\\n} 6 } } */\n+/* { dg-final { scan-assembler-times {\\tfcmeq\\tp[0-7]\\.d, p[0-7]/z, z[0-9]+\\.d, z[0-9]+\\.d\\n} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tld1d\\tz[0-9]+\\.d, p[0-7]/z, \\[x[0-9]+, z[0-9]+\\.d, lsl 3\\]\\n} 9 } } */\n+/* { dg-final { scan-assembler-times {\\tst1d\\tz[0-9]+\\.d, p[0-7], \\[x[0-9]+, x[0-9]+, lsl 3\\]\\n} 9 } } */"}, {"sha": "9fa60092a63851fcd9dfdb0ac5d881fcf7cc404d", "filename": "gcc/testsuite/gcc.target/aarch64/sve/mask_gather_load_2.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfaa08b7ba1b00bbcc00bb76735c6b3547f5830f/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fmask_gather_load_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfaa08b7ba1b00bbcc00bb76735c6b3547f5830f/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fmask_gather_load_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fmask_gather_load_2.c?ref=bfaa08b7ba1b00bbcc00bb76735c6b3547f5830f", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do assemble { target aarch64_asm_sve_ok } } */\n+/* { dg-options \"-O2 -ftree-vectorize -ffast-math --save-temps\" } */\n+\n+#define INDEX32 uint32_t\n+#define INDEX64 uint64_t\n+\n+#include \"mask_gather_load_1.c\"\n+\n+/* { dg-final { scan-assembler-times {\\tld1w\\tz[0-9]+\\.s, p[0-7]/z, \\[x[0-9]+, x[0-9]+, lsl 2\\]\\n} 36 } } */\n+/* { dg-final { scan-assembler-times {\\tcmpeq\\tp[0-7]\\.s, p[0-7]/z, z[0-9]+\\.s, z[0-9]+\\.s\\n} 6 } } */\n+/* { dg-final { scan-assembler-times {\\tfcmeq\\tp[0-7]\\.s, p[0-7]/z, z[0-9]+\\.s, z[0-9]+\\.s\\n} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tld1w\\tz[0-9]+\\.s, p[0-7]/z, \\[x[0-9]+, z[0-9]+\\.s, uxtw 2\\]\\n} 9 } } */\n+/* { dg-final { scan-assembler-times {\\tst1w\\tz[0-9]+\\.s, p[0-7], \\[x[0-9]+, x[0-9]+, lsl 2\\]\\n} 9 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tld1d\\tz[0-9]+\\.d, p[0-7]/z, \\[x[0-9]+, x[0-9]+, lsl 3\\]\\n} 36 } } */\n+/* { dg-final { scan-assembler-times {\\tcmpeq\\tp[0-7]\\.d, p[0-7]/z, z[0-9]+\\.d, z[0-9]+\\.d\\n} 6 } } */\n+/* { dg-final { scan-assembler-times {\\tfcmeq\\tp[0-7]\\.d, p[0-7]/z, z[0-9]+\\.d, z[0-9]+\\.d\\n} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tld1d\\tz[0-9]+\\.d, p[0-7]/z, \\[x[0-9]+, z[0-9]+\\.d, lsl 3\\]\\n} 9 } } */\n+/* { dg-final { scan-assembler-times {\\tst1d\\tz[0-9]+\\.d, p[0-7], \\[x[0-9]+, x[0-9]+, lsl 3\\]\\n} 9 } } */"}, {"sha": "90ad6aedd2009a7976a9f2ed752a4b65ac74d2e2", "filename": "gcc/testsuite/gcc.target/aarch64/sve/mask_gather_load_3.c", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfaa08b7ba1b00bbcc00bb76735c6b3547f5830f/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fmask_gather_load_3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfaa08b7ba1b00bbcc00bb76735c6b3547f5830f/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fmask_gather_load_3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fmask_gather_load_3.c?ref=bfaa08b7ba1b00bbcc00bb76735c6b3547f5830f", "patch": "@@ -0,0 +1,52 @@\n+/* { dg-do assemble { target aarch64_asm_sve_ok } } */\n+/* { dg-options \"-O2 -ftree-vectorize -ffast-math --save-temps\" } */\n+\n+#include <stdint.h>\n+\n+#ifndef INDEX32\n+#define INDEX32 int32_t\n+#define INDEX64 int64_t\n+#endif\n+\n+#define TEST_LOOP(DATA_TYPE, CMP_TYPE, BITS)\t\t\t\t\\\n+  void\t\t\t\t\t\t\t\t\t\\\n+  f_##DATA_TYPE##_##CMP_TYPE\t\t\t\t\t\t\\\n+    (DATA_TYPE *restrict dest, DATA_TYPE *restrict src,\t\t\t\\\n+     CMP_TYPE *cmp1, CMP_TYPE *cmp2, INDEX##BITS *indices, int n)\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    for (int i = 0; i < n; ++i)\t\t\t\t\t\t\\\n+      if (cmp1[i] == cmp2[i])\t\t\t\t\t\t\\\n+\tdest[i] += *(DATA_TYPE *) ((char *) src + indices[i]);\t\t\\\n+  }\n+\n+#define TEST32(T, DATA_TYPE)\t\t\\\n+  T (DATA_TYPE, int32_t, 32)\t\t\\\n+  T (DATA_TYPE, uint32_t, 32)\t\t\\\n+  T (DATA_TYPE, float, 32)\n+\n+#define TEST64(T, DATA_TYPE)\t\t\\\n+  T (DATA_TYPE, int64_t, 64)\t\t\\\n+  T (DATA_TYPE, uint64_t, 64)\t\t\\\n+  T (DATA_TYPE, double, 64)\n+\n+#define TEST_ALL(T)\t\t\t\\\n+  TEST32 (T, int32_t)\t\t\t\\\n+  TEST32 (T, uint32_t)\t\t\t\\\n+  TEST32 (T, float)\t\t\t\\\n+  TEST64 (T, int64_t)\t\t\t\\\n+  TEST64 (T, uint64_t)\t\t\t\\\n+  TEST64 (T, double)\n+\n+TEST_ALL (TEST_LOOP)\n+\n+/* { dg-final { scan-assembler-times {\\tld1w\\tz[0-9]+\\.s, p[0-7]/z, \\[x[0-9]+, x[0-9]+, lsl 2\\]\\n} 36 } } */\n+/* { dg-final { scan-assembler-times {\\tcmpeq\\tp[0-7]\\.s, p[0-7]/z, z[0-9]+\\.s, z[0-9]+\\.s\\n} 6 } } */\n+/* { dg-final { scan-assembler-times {\\tfcmeq\\tp[0-7]\\.s, p[0-7]/z, z[0-9]+\\.s, z[0-9]+\\.s\\n} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tld1w\\tz[0-9]+\\.s, p[0-7]/z, \\[x[0-9]+, z[0-9]+\\.s, sxtw\\]\\n} 9 } } */\n+/* { dg-final { scan-assembler-times {\\tst1w\\tz[0-9]+\\.s, p[0-7], \\[x[0-9]+, x[0-9]+, lsl 2\\]\\n} 9 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tld1d\\tz[0-9]+\\.d, p[0-7]/z, \\[x[0-9]+, x[0-9]+, lsl 3\\]\\n} 36 } } */\n+/* { dg-final { scan-assembler-times {\\tcmpeq\\tp[0-7]\\.d, p[0-7]/z, z[0-9]+\\.d, z[0-9]+\\.d\\n} 6 } } */\n+/* { dg-final { scan-assembler-times {\\tfcmeq\\tp[0-7]\\.d, p[0-7]/z, z[0-9]+\\.d, z[0-9]+\\.d\\n} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tld1d\\tz[0-9]+\\.d, p[0-7]/z, \\[x[0-9]+, z[0-9]+\\.d\\]\\n} 9 } } */\n+/* { dg-final { scan-assembler-times {\\tst1d\\tz[0-9]+\\.d, p[0-7], \\[x[0-9]+, x[0-9]+, lsl 3\\]\\n} 9 } } */"}, {"sha": "1c8390a5004d9cb2f7956e45ffa2b219475c1c94", "filename": "gcc/testsuite/gcc.target/aarch64/sve/mask_gather_load_4.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfaa08b7ba1b00bbcc00bb76735c6b3547f5830f/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fmask_gather_load_4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfaa08b7ba1b00bbcc00bb76735c6b3547f5830f/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fmask_gather_load_4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fmask_gather_load_4.c?ref=bfaa08b7ba1b00bbcc00bb76735c6b3547f5830f", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do assemble { target aarch64_asm_sve_ok } } */\n+/* { dg-options \"-O2 -ftree-vectorize -ffast-math --save-temps\" } */\n+\n+#define INDEX32 uint32_t\n+#define INDEX64 uint64_t\n+\n+#include \"mask_gather_load_3.c\"\n+\n+/* { dg-final { scan-assembler-times {\\tld1w\\tz[0-9]+\\.s, p[0-7]/z, \\[x[0-9]+, x[0-9]+, lsl 2\\]\\n} 36 } } */\n+/* { dg-final { scan-assembler-times {\\tcmpeq\\tp[0-7]\\.s, p[0-7]/z, z[0-9]+\\.s, z[0-9]+\\.s\\n} 6 } } */\n+/* { dg-final { scan-assembler-times {\\tfcmeq\\tp[0-7]\\.s, p[0-7]/z, z[0-9]+\\.s, z[0-9]+\\.s\\n} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tld1w\\tz[0-9]+\\.s, p[0-7]/z, \\[x[0-9]+, z[0-9]+\\.s, uxtw\\]\\n} 9 } } */\n+/* { dg-final { scan-assembler-times {\\tst1w\\tz[0-9]+\\.s, p[0-7], \\[x[0-9]+, x[0-9]+, lsl 2\\]\\n} 9 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tld1d\\tz[0-9]+\\.d, p[0-7]/z, \\[x[0-9]+, x[0-9]+, lsl 3\\]\\n} 36 } } */\n+/* { dg-final { scan-assembler-times {\\tcmpeq\\tp[0-7]\\.d, p[0-7]/z, z[0-9]+\\.d, z[0-9]+\\.d\\n} 6 } } */\n+/* { dg-final { scan-assembler-times {\\tfcmeq\\tp[0-7]\\.d, p[0-7]/z, z[0-9]+\\.d, z[0-9]+\\.d\\n} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tld1d\\tz[0-9]+\\.d, p[0-7]/z, \\[x[0-9]+, z[0-9]+\\.d\\]\\n} 9 } } */\n+/* { dg-final { scan-assembler-times {\\tst1d\\tz[0-9]+\\.d, p[0-7], \\[x[0-9]+, x[0-9]+, lsl 3\\]\\n} 9 } } */"}, {"sha": "60a93f1e42b6eb20a970ddff303a761a2a445909", "filename": "gcc/testsuite/gcc.target/aarch64/sve/mask_gather_load_5.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfaa08b7ba1b00bbcc00bb76735c6b3547f5830f/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fmask_gather_load_5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfaa08b7ba1b00bbcc00bb76735c6b3547f5830f/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fmask_gather_load_5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fmask_gather_load_5.c?ref=bfaa08b7ba1b00bbcc00bb76735c6b3547f5830f", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-do assemble { target aarch64_asm_sve_ok } } */\n+/* { dg-options \"-O2 -ftree-vectorize -ffast-math --save-temps\" } */\n+\n+#include <stdint.h>\n+\n+#ifndef INDEX32\n+#define INDEX32 int32_t\n+#define INDEX64 int64_t\n+#endif\n+\n+#define TEST_LOOP(DATA_TYPE, CMP_TYPE)\t\t\t\t\t\\\n+  void\t\t\t\t\t\t\t\t\t\\\n+  f_##DATA_TYPE##_##CMP_TYPE\t\t\t\t\t\t\\\n+    (DATA_TYPE *restrict dest, DATA_TYPE *restrict *restrict src,\t\\\n+     CMP_TYPE *cmp1, CMP_TYPE *cmp2, int n)\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    for (int i = 0; i < n; ++i)\t\t\t\t\t\t\\\n+      if (cmp1[i] == cmp2[i])\t\t\t\t\t\t\\\n+\tdest[i] += *src[i];\t\t\t\t\t\t\\\n+  }\n+\n+#define TEST_TYPE(T, DATA_TYPE)\t\t\\\n+  T (DATA_TYPE, int64_t)\t\t\\\n+  T (DATA_TYPE, uint64_t)\t\t\\\n+  T (DATA_TYPE, double)\n+\n+#define TEST_ALL(T)\t\t\t\\\n+  TEST_TYPE (T, int64_t)\t\t\\\n+  TEST_TYPE (T, uint64_t)\t\t\\\n+  TEST_TYPE (T, double)\n+\n+TEST_ALL (TEST_LOOP)\n+\n+/* { dg-final { scan-assembler-times {\\tld1d\\tz[0-9]+\\.d, p[0-7]/z, \\[x[0-9]+, x[0-9]+, lsl 3\\]\\n} 36 } } */\n+/* { dg-final { scan-assembler-times {\\tcmpeq\\tp[0-7]\\.d, p[0-7]/z, z[0-9]+\\.d, z[0-9]+\\.d\\n} 6 } } */\n+/* { dg-final { scan-assembler-times {\\tfcmeq\\tp[0-7]\\.d, p[0-7]/z, z[0-9]+\\.d, z[0-9]+\\.d\\n} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tld1d\\tz[0-9]+\\.d, p[0-7]/z, \\[z[0-9]+\\.d\\]\\n} 9 } } */\n+/* { dg-final { scan-assembler-times {\\tst1d\\tz[0-9]+\\.d, p[0-7], \\[x[0-9]+, x[0-9]+, lsl 3\\]\\n} 9 } } */"}, {"sha": "ff01431dc6dfc7ef1138748b061601624a92c0c1", "filename": "gcc/testsuite/gcc.target/aarch64/sve/mask_gather_load_6.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfaa08b7ba1b00bbcc00bb76735c6b3547f5830f/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fmask_gather_load_6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfaa08b7ba1b00bbcc00bb76735c6b3547f5830f/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fmask_gather_load_6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fmask_gather_load_6.c?ref=bfaa08b7ba1b00bbcc00bb76735c6b3547f5830f", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-do assemble { target aarch64_asm_sve_ok } } */\n+/* { dg-options \"-O2 -ftree-vectorize -ffast-math --save-temps\" } */\n+\n+#include <stdint.h>\n+\n+#define TEST_LOOP(DATA_TYPE, CMP_TYPE, INDEX_TYPE)\t\t\t\\\n+  void\t\t\t\t\t\t\t\t\t\\\n+  f_##DATA_TYPE##_##CMP_TYPE##_##INDEX_TYPE\t\t\t\t\\\n+    (DATA_TYPE *restrict dest, DATA_TYPE *restrict src,\t\t\t\\\n+     CMP_TYPE *cmp1, CMP_TYPE *cmp2, INDEX_TYPE *indices, int n)\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    for (int i = 0; i < n; ++i)\t\t\t\t\t\t\\\n+      if (cmp1[i] == cmp2[i])\t\t\t\t\t\t\\\n+\tdest[i] += src[indices[i]];\t\t\t\t\t\\\n+  }\n+\n+#define TEST32(T, DATA_TYPE)\t\t\t\\\n+  T (DATA_TYPE, int64_t, int32_t)\t\t\\\n+  T (DATA_TYPE, uint64_t, int32_t)\t\t\\\n+  T (DATA_TYPE, double, int32_t)\t\t\\\n+  T (DATA_TYPE, int64_t, uint32_t)\t\t\\\n+  T (DATA_TYPE, uint64_t, uint32_t)\t\t\\\n+  T (DATA_TYPE, double, uint32_t)\n+\n+#define TEST_ALL(T)\t\t\t\\\n+  TEST32 (T, int32_t)\t\t\t\\\n+  TEST32 (T, uint32_t)\t\t\t\\\n+  TEST32 (T, float)\n+\n+TEST_ALL (TEST_LOOP)\n+\n+/* { dg-final { scan-assembler-times {\\tld1d\\tz[0-9]+\\.d, p[0-7]/z, \\[x[0-9]+, x[0-9]+, lsl 3\\]\\n} 72 } } */\n+/* { dg-final { scan-assembler-times {\\tcmpeq\\tp[0-7]\\.d, p[0-7]/z, z[0-9]+\\.d, z[0-9]+\\.d\\n} 24 } } */\n+/* { dg-final { scan-assembler-times {\\tfcmeq\\tp[0-7]\\.d, p[0-7]/z, z[0-9]+\\.d, z[0-9]+\\.d\\n} 12 } } */\n+/* { dg-final { scan-assembler-times {\\tld1w\\tz[0-9]+\\.s, p[0-7]/z, \\[x[0-9]+, x[0-9]+, lsl 2\\]\\n} 36 } } */\n+/* { dg-final { scan-assembler-times {\\tld1w\\tz[0-9]+\\.s, p[0-7]/z, \\[x[0-9]+, z[0-9]+\\.s, sxtw 2\\]\\n} 9 } } */\n+/* { dg-final { scan-assembler-times {\\tld1w\\tz[0-9]+\\.s, p[0-7]/z, \\[x[0-9]+, z[0-9]+\\.s, uxtw 2\\]\\n} 9 } } */\n+/* { dg-final { scan-assembler-times {\\tst1w\\tz[0-9]+\\.s, p[0-7], \\[x[0-9]+, x[0-9]+, lsl 2\\]\\n} 18 } } */"}, {"sha": "cd2661ef3a5da863661f90a0eac62bea876d789c", "filename": "gcc/testsuite/gcc.target/aarch64/sve/mask_gather_load_7.c", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfaa08b7ba1b00bbcc00bb76735c6b3547f5830f/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fmask_gather_load_7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfaa08b7ba1b00bbcc00bb76735c6b3547f5830f/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fmask_gather_load_7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fmask_gather_load_7.c?ref=bfaa08b7ba1b00bbcc00bb76735c6b3547f5830f", "patch": "@@ -0,0 +1,53 @@\n+/* { dg-do assemble { target aarch64_asm_sve_ok } } */\n+/* { dg-options \"-O2 -ftree-vectorize -ffast-math --save-temps\" } */\n+\n+#include <stdint.h>\n+\n+#define TEST_LOOP(DATA_TYPE, CMP_TYPE, INDEX_TYPE)\t\t\t\\\n+  void\t\t\t\t\t\t\t\t\t\\\n+  f_##DATA_TYPE##_##CMP_TYPE##_##INDEX_TYPE\t\t\t\t\\\n+    (DATA_TYPE *restrict dest, DATA_TYPE *restrict src,\t\t\t\\\n+     CMP_TYPE *cmp1, CMP_TYPE *cmp2, INDEX_TYPE *indices, int n)\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    for (int i = 0; i < n; ++i)\t\t\t\t\t\t\\\n+      if (cmp1[i] == cmp2[i])\t\t\t\t\t\t\\\n+\tdest[i] += src[indices[i]];\t\t\t\t\t\\\n+  }\n+\n+#define TEST32(T, DATA_TYPE)\t\t\t\\\n+  T (DATA_TYPE, int16_t, int32_t)\t\t\\\n+  T (DATA_TYPE, uint16_t, int32_t)\t\t\\\n+  T (DATA_TYPE, _Float16, int32_t)\t\t\\\n+  T (DATA_TYPE, int16_t, uint32_t)\t\t\\\n+  T (DATA_TYPE, uint16_t, uint32_t)\t\t\\\n+  T (DATA_TYPE, _Float16, uint32_t)\n+\n+#define TEST64(T, DATA_TYPE)\t\t\t\\\n+  T (DATA_TYPE, int32_t, int64_t)\t\t\\\n+  T (DATA_TYPE, uint32_t, int64_t)\t\t\\\n+  T (DATA_TYPE, float, int64_t)\t\t\t\\\n+  T (DATA_TYPE, int32_t, uint64_t)\t\t\\\n+  T (DATA_TYPE, uint32_t, uint64_t)\t\t\\\n+  T (DATA_TYPE, float, uint64_t)\n+\n+#define TEST_ALL(T)\t\t\t\\\n+  TEST32 (T, int32_t)\t\t\t\\\n+  TEST32 (T, uint32_t)\t\t\t\\\n+  TEST32 (T, float)\t\t\t\\\n+  TEST64 (T, int64_t)\t\t\t\\\n+  TEST64 (T, uint64_t)\t\t\t\\\n+  TEST64 (T, double)\n+\n+TEST_ALL (TEST_LOOP)\n+\n+/* { dg-final { scan-assembler-times {\\tld1h\\tz[0-9]+\\.h, p[0-7]/z, \\[x[0-9]+, x[0-9]+, lsl 1\\]\\n} 36 } } */\n+/* { dg-final { scan-assembler-times {\\tcmpeq\\tp[0-7]\\.h, p[0-7]/z, z[0-9]+\\.h, z[0-9]+\\.h\\n} 12 } } */\n+/* { dg-final { scan-assembler-times {\\tfcmeq\\tp[0-7]\\.h, p[0-7]/z, z[0-9]+\\.h, z[0-9]+\\.h\\n} 6 } } */\n+/* { dg-final { scan-assembler-times {\\tld1w\\tz[0-9]+\\.s, p[0-7]/z, \\[x[0-9]+, z[0-9]+\\.s, sxtw 2\\]\\n} 18 } } */\n+/* { dg-final { scan-assembler-times {\\tld1w\\tz[0-9]+\\.s, p[0-7]/z, \\[x[0-9]+, z[0-9]+\\.s, uxtw 2\\]\\n} 18 } } */\n+\n+/* Also used for the TEST32 indices.  */\n+/* { dg-final { scan-assembler-times {\\tld1w\\tz[0-9]+\\.s, p[0-7]/z, \\[x[0-9]+, x[0-9]+, lsl 2\\]\\n} 72 } } */\n+/* { dg-final { scan-assembler-times {\\tcmpeq\\tp[0-7]\\.s, p[0-7]/z, z[0-9]+\\.s, z[0-9]+\\.s\\n} 12 } } */\n+/* { dg-final { scan-assembler-times {\\tfcmeq\\tp[0-7]\\.s, p[0-7]/z, z[0-9]+\\.s, z[0-9]+\\.s\\n} 6 } } */\n+/* { dg-final { scan-assembler-times {\\tld1d\\tz[0-9]+\\.d, p[0-7]/z, \\[x[0-9]+, z[0-9]+\\.d, lsl 3\\]\\n} 36 } } */"}, {"sha": "f79be863194cb02038691fba5f6f707d1494d366", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 139, "deletions": 14, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfaa08b7ba1b00bbcc00bb76735c6b3547f5830f/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfaa08b7ba1b00bbcc00bb76735c6b3547f5830f/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=bfaa08b7ba1b00bbcc00bb76735c6b3547f5830f", "patch": "@@ -53,6 +53,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-cfg.h\"\n #include \"tree-hash-traits.h\"\n #include \"vec-perm-indices.h\"\n+#include \"internal-fn.h\"\n \n /* Return true if load- or store-lanes optab OPTAB is implemented for\n    COUNT vectors of type VECTYPE.  NAME is the name of OPTAB.  */\n@@ -3300,6 +3301,74 @@ vect_prune_runtime_alias_test_list (loop_vec_info loop_vinfo)\n   return true;\n }\n \n+/* Check whether we can use an internal function for a gather load\n+   or scatter store.  READ_P is true for loads and false for stores.\n+   MASKED_P is true if the load or store is conditional.  MEMORY_TYPE is\n+   the type of the memory elements being loaded or stored.  OFFSET_BITS\n+   is the number of bits in each scalar offset and OFFSET_SIGN is the\n+   sign of the offset.  SCALE is the amount by which the offset should\n+   be multiplied *after* it has been converted to address width.\n+\n+   Return true if the function is supported, storing the function\n+   id in *IFN_OUT and the type of a vector element in *ELEMENT_TYPE_OUT.  */\n+\n+static bool\n+vect_gather_scatter_fn_p (bool read_p, bool masked_p, tree vectype,\n+\t\t\t  tree memory_type, unsigned int offset_bits,\n+\t\t\t  signop offset_sign, int scale,\n+\t\t\t  internal_fn *ifn_out, tree *element_type_out)\n+{\n+  unsigned int memory_bits = tree_to_uhwi (TYPE_SIZE (memory_type));\n+  unsigned int element_bits = tree_to_uhwi (TYPE_SIZE (TREE_TYPE (vectype)));\n+  if (offset_bits > element_bits)\n+    /* Internal functions require the offset to be the same width as\n+       the vector elements.  We can extend narrower offsets, but it isn't\n+       safe to truncate wider offsets.  */\n+    return false;\n+\n+  if (element_bits != memory_bits)\n+    /* For now the vector elements must be the same width as the\n+       memory elements.  */\n+    return false;\n+\n+  /* Work out which function we need.  */\n+  internal_fn ifn;\n+  if (read_p)\n+    ifn = masked_p ? IFN_MASK_GATHER_LOAD : IFN_GATHER_LOAD;\n+  else\n+    return false;\n+\n+  /* Test whether the target supports this combination.  */\n+  if (!internal_gather_scatter_fn_supported_p (ifn, vectype, memory_type,\n+\t\t\t\t\t       offset_sign, scale))\n+    return false;\n+\n+  *ifn_out = ifn;\n+  *element_type_out = TREE_TYPE (vectype);\n+  return true;\n+}\n+\n+/* CALL is a call to an internal gather load or scatter store function.\n+   Describe the operation in INFO.  */\n+\n+static void\n+vect_describe_gather_scatter_call (gcall *call, gather_scatter_info *info)\n+{\n+  stmt_vec_info stmt_info = vinfo_for_stmt (call);\n+  tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n+  data_reference *dr = STMT_VINFO_DATA_REF (stmt_info);\n+\n+  info->ifn = gimple_call_internal_fn (call);\n+  info->decl = NULL_TREE;\n+  info->base = gimple_call_arg (call, 0);\n+  info->offset = gimple_call_arg (call, 1);\n+  info->offset_dt = vect_unknown_def_type;\n+  info->offset_vectype = NULL_TREE;\n+  info->scale = TREE_INT_CST_LOW (gimple_call_arg (call, 2));\n+  info->element_type = TREE_TYPE (vectype);\n+  info->memory_type = TREE_TYPE (DR_REF (dr));\n+}\n+\n /* Return true if a non-affine read or write in STMT is suitable for a\n    gather load or scatter store.  Describe the operation in *INFO if so.  */\n \n@@ -3313,17 +3382,38 @@ vect_check_gather_scatter (gimple *stmt, loop_vec_info loop_vinfo,\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   struct data_reference *dr = STMT_VINFO_DATA_REF (stmt_info);\n   tree offtype = NULL_TREE;\n-  tree decl, base, off;\n+  tree decl = NULL_TREE, base, off;\n+  tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n+  tree memory_type = TREE_TYPE (DR_REF (dr));\n   machine_mode pmode;\n   int punsignedp, reversep, pvolatilep = 0;\n+  internal_fn ifn;\n+  tree element_type;\n+  bool masked_p = false;\n+\n+  /* See whether this is already a call to a gather/scatter internal function.\n+     If not, see whether it's a masked load or store.  */\n+  gcall *call = dyn_cast <gcall *> (stmt);\n+  if (call && gimple_call_internal_p (call))\n+    {\n+      ifn = gimple_call_internal_fn (stmt);\n+      if (internal_gather_scatter_fn_p (ifn))\n+\t{\n+\t  vect_describe_gather_scatter_call (call, info);\n+\t  return true;\n+\t}\n+      masked_p = (ifn == IFN_MASK_LOAD || ifn == IFN_MASK_STORE);\n+    }\n+\n+  /* True if we should aim to use internal functions rather than\n+     built-in functions.  */\n+  bool use_ifn_p = (DR_IS_READ (dr)\n+\t\t    && supports_vec_gather_load_p ());\n \n   base = DR_REF (dr);\n   /* For masked loads/stores, DR_REF (dr) is an artificial MEM_REF,\n      see if we can use the def stmt of the address.  */\n-  if (is_gimple_call (stmt)\n-      && gimple_call_internal_p (stmt)\n-      && (gimple_call_internal_fn (stmt) == IFN_MASK_LOAD\n-\t  || gimple_call_internal_fn (stmt) == IFN_MASK_STORE)\n+  if (masked_p\n       && TREE_CODE (base) == MEM_REF\n       && TREE_CODE (TREE_OPERAND (base, 0)) == SSA_NAME\n       && integer_zerop (TREE_OPERAND (base, 1))\n@@ -3454,7 +3544,17 @@ vect_check_gather_scatter (gimple *stmt, loop_vec_info loop_vinfo,\n \tcase MULT_EXPR:\n \t  if (scale == 1 && tree_fits_shwi_p (op1))\n \t    {\n-\t      scale = tree_to_shwi (op1);\n+\t      int new_scale = tree_to_shwi (op1);\n+\t      /* Only treat this as a scaling operation if the target\n+\t\t supports it.  */\n+\t      if (use_ifn_p\n+\t\t  && !vect_gather_scatter_fn_p (DR_IS_READ (dr), masked_p,\n+\t\t\t\t\t\tvectype, memory_type, 1,\n+\t\t\t\t\t\tTYPE_SIGN (TREE_TYPE (op0)),\n+\t\t\t\t\t\tnew_scale, &ifn,\n+\t\t\t\t\t\t&element_type))\n+\t\tbreak;\n+\t      scale = new_scale;\n \t      off = op0;\n \t      continue;\n \t    }\n@@ -3472,6 +3572,15 @@ vect_check_gather_scatter (gimple *stmt, loop_vec_info loop_vinfo,\n \t      off = op0;\n \t      continue;\n \t    }\n+\n+\t  /* The internal functions need the offset to be the same width\n+\t     as the elements of VECTYPE.  Don't include operations that\n+\t     cast the offset from that width to a different width.  */\n+\t  if (use_ifn_p\n+\t      && (int_size_in_bytes (TREE_TYPE (vectype))\n+\t\t  == int_size_in_bytes (TREE_TYPE (off))))\n+\t    break;\n+\n \t  if (TYPE_PRECISION (TREE_TYPE (op0))\n \t      < TYPE_PRECISION (TREE_TYPE (off)))\n \t    {\n@@ -3496,22 +3605,37 @@ vect_check_gather_scatter (gimple *stmt, loop_vec_info loop_vinfo,\n   if (offtype == NULL_TREE)\n     offtype = TREE_TYPE (off);\n \n-  if (DR_IS_READ (dr))\n-    decl = targetm.vectorize.builtin_gather (STMT_VINFO_VECTYPE (stmt_info),\n-\t\t\t\t\t     offtype, scale);\n+  if (use_ifn_p)\n+    {\n+      if (!vect_gather_scatter_fn_p (DR_IS_READ (dr), masked_p, vectype,\n+\t\t\t\t     memory_type, TYPE_PRECISION (offtype),\n+\t\t\t\t     TYPE_SIGN (offtype), scale, &ifn,\n+\t\t\t\t     &element_type))\n+\treturn false;\n+    }\n   else\n-    decl = targetm.vectorize.builtin_scatter (STMT_VINFO_VECTYPE (stmt_info),\n-\t\t\t\t\t      offtype, scale);\n+    {\n+      if (DR_IS_READ (dr))\n+\tdecl = targetm.vectorize.builtin_gather (vectype, offtype, scale);\n+      else\n+\tdecl = targetm.vectorize.builtin_scatter (vectype, offtype, scale);\n \n-  if (decl == NULL_TREE)\n-    return false;\n+      if (!decl)\n+\treturn false;\n+\n+      ifn = IFN_LAST;\n+      element_type = TREE_TYPE (vectype);\n+    }\n \n+  info->ifn = ifn;\n   info->decl = decl;\n   info->base = base;\n   info->offset = off;\n   info->offset_dt = vect_unknown_def_type;\n   info->offset_vectype = NULL_TREE;\n   info->scale = scale;\n+  info->element_type = element_type;\n+  info->memory_type = memory_type;\n   return true;\n }\n \n@@ -3592,7 +3716,8 @@ vect_analyze_data_refs (vec_info *vinfo, poly_uint64 *min_vf)\n \t  bool maybe_gather\n \t    = DR_IS_READ (dr)\n \t      && !TREE_THIS_VOLATILE (DR_REF (dr))\n-\t      && targetm.vectorize.builtin_gather != NULL;\n+\t      && (targetm.vectorize.builtin_gather != NULL\n+\t\t  || supports_vec_gather_load_p ());\n \t  bool maybe_scatter\n \t    = DR_IS_WRITE (dr)\n \t      && !TREE_THIS_VOLATILE (DR_REF (dr))"}, {"sha": "f4b1b3e1ce92f82f0cbc4222357821cbd54d5dc9", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 203, "deletions": 0, "changes": 203, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfaa08b7ba1b00bbcc00bb76735c6b3547f5830f/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfaa08b7ba1b00bbcc00bb76735c6b3547f5830f/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=bfaa08b7ba1b00bbcc00bb76735c6b3547f5830f", "patch": "@@ -69,6 +69,8 @@ static gimple *vect_recog_mixed_size_cond_pattern (vec<gimple *> *,\n \t\t\t\t\t\t  tree *, tree *);\n static gimple *vect_recog_bool_pattern (vec<gimple *> *, tree *, tree *);\n static gimple *vect_recog_mask_conversion_pattern (vec<gimple *> *, tree *, tree *);\n+static gimple *vect_recog_gather_scatter_pattern (vec<gimple *> *, tree *,\n+\t\t\t\t\t\t  tree *);\n \n struct vect_recog_func\n {\n@@ -93,6 +95,10 @@ static vect_recog_func vect_vect_recog_func_ptrs[NUM_PATTERNS] = {\n       {\tvect_recog_mult_pattern, \"mult\" },\n       {\tvect_recog_mixed_size_cond_pattern, \"mixed_size_cond\" },\n       {\tvect_recog_bool_pattern, \"bool\" },\n+      /* This must come before mask conversion, and includes the parts\n+\t of mask conversion that are needed for gather and scatter\n+\t internal functions.  */\n+      { vect_recog_gather_scatter_pattern, \"gather_scatter\" },\n       {\tvect_recog_mask_conversion_pattern, \"mask_conversion\" }\n };\n \n@@ -4117,6 +4123,203 @@ vect_recog_mask_conversion_pattern (vec<gimple *> *stmts, tree *type_in,\n   return pattern_stmt;\n }\n \n+/* STMT is a load or store.  If the load or store is conditional, return\n+   the boolean condition under which it occurs, otherwise return null.  */\n+\n+static tree\n+vect_get_load_store_mask (gimple *stmt)\n+{\n+  if (gassign *def_assign = dyn_cast <gassign *> (stmt))\n+    {\n+      gcc_assert (gimple_assign_single_p (def_assign));\n+      return NULL_TREE;\n+    }\n+\n+  if (gcall *def_call = dyn_cast <gcall *> (stmt))\n+    {\n+      internal_fn ifn = gimple_call_internal_fn (def_call);\n+      int mask_index = internal_fn_mask_index (ifn);\n+      return gimple_call_arg (def_call, mask_index);\n+    }\n+\n+  gcc_unreachable ();\n+}\n+\n+/* Return the scalar offset type that an internal gather/scatter function\n+   should use.  GS_INFO describes the gather/scatter operation.  */\n+\n+static tree\n+vect_get_gather_scatter_offset_type (gather_scatter_info *gs_info)\n+{\n+  tree offset_type = TREE_TYPE (gs_info->offset);\n+  unsigned int element_bits = tree_to_uhwi (TYPE_SIZE (gs_info->element_type));\n+\n+  /* Enforced by vect_check_gather_scatter.  */\n+  unsigned int offset_bits = TYPE_PRECISION (offset_type);\n+  gcc_assert (element_bits >= offset_bits);\n+\n+  /* If the offset is narrower than the elements, extend it according\n+     to its sign.  */\n+  if (element_bits > offset_bits)\n+    return build_nonstandard_integer_type (element_bits,\n+\t\t\t\t\t   TYPE_UNSIGNED (offset_type));\n+\n+  return offset_type;\n+}\n+\n+/* Return MASK if MASK is suitable for masking an operation on vectors\n+   of type VECTYPE, otherwise convert it into such a form and return\n+   the result.  Associate any conversion statements with STMT_INFO's\n+   pattern.  */\n+\n+static tree\n+vect_convert_mask_for_vectype (tree mask, tree vectype,\n+\t\t\t       stmt_vec_info stmt_info, vec_info *vinfo)\n+{\n+  tree mask_type = search_type_for_mask (mask, vinfo);\n+  if (mask_type)\n+    {\n+      tree mask_vectype = get_mask_type_for_scalar_type (mask_type);\n+      if (mask_vectype\n+\t  && maybe_ne (TYPE_VECTOR_SUBPARTS (vectype),\n+\t\t       TYPE_VECTOR_SUBPARTS (mask_vectype)))\n+\tmask = build_mask_conversion (mask, vectype, stmt_info, vinfo);\n+    }\n+  return mask;\n+}\n+\n+/* Return the equivalent of:\n+\n+     fold_convert (TYPE, VALUE)\n+\n+   with the expectation that the operation will be vectorized.\n+   If new statements are needed, add them as pattern statements\n+   to STMT_INFO.  */\n+\n+static tree\n+vect_add_conversion_to_patterm (tree type, tree value,\n+\t\t\t\tstmt_vec_info stmt_info,\n+\t\t\t\tvec_info *vinfo)\n+{\n+  if (useless_type_conversion_p (type, TREE_TYPE (value)))\n+    return value;\n+\n+  tree new_value = vect_recog_temp_ssa_var (type, NULL);\n+  gassign *conversion = gimple_build_assign (new_value, CONVERT_EXPR, value);\n+  stmt_vec_info new_stmt_info = new_stmt_vec_info (conversion, vinfo);\n+  set_vinfo_for_stmt (conversion, new_stmt_info);\n+  STMT_VINFO_VECTYPE (new_stmt_info) = get_vectype_for_scalar_type (type);\n+  append_pattern_def_seq (stmt_info, conversion);\n+  return new_value;\n+}\n+\n+/* Try to convert STMT into a call to a gather load or scatter store\n+   internal function.  Return the final statement on success and set\n+   *TYPE_IN and *TYPE_OUT to the vector type being loaded or stored.\n+\n+   This function only handles gathers and scatters that were recognized\n+   as such from the outset (indicated by STMT_VINFO_GATHER_SCATTER_P).  */\n+\n+static gimple *\n+vect_try_gather_scatter_pattern (gimple *stmt, stmt_vec_info last_stmt_info,\n+\t\t\t\t tree *type_in, tree *type_out)\n+{\n+  /* Currently we only support this for loop vectorization.  */\n+  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+  loop_vec_info loop_vinfo = dyn_cast <loop_vec_info> (stmt_info->vinfo);\n+  if (!loop_vinfo)\n+    return NULL;\n+\n+  /* Make sure that we're looking at a gather load or scatter store.  */\n+  data_reference *dr = STMT_VINFO_DATA_REF (stmt_info);\n+  if (!dr || !STMT_VINFO_GATHER_SCATTER_P (stmt_info))\n+    return NULL;\n+\n+  /* Reject stores for now.  */\n+  if (!DR_IS_READ (dr))\n+    return NULL;\n+\n+  /* Get the boolean that controls whether the load or store happens.\n+     This is null if the operation is unconditional.  */\n+  tree mask = vect_get_load_store_mask (stmt);\n+\n+  /* Make sure that the target supports an appropriate internal\n+     function for the gather/scatter operation.  */\n+  gather_scatter_info gs_info;\n+  if (!vect_check_gather_scatter (stmt, loop_vinfo, &gs_info)\n+      || gs_info.decl)\n+    return NULL;\n+\n+  /* Convert the mask to the right form.  */\n+  tree gs_vectype = get_vectype_for_scalar_type (gs_info.element_type);\n+  if (mask)\n+    mask = vect_convert_mask_for_vectype (mask, gs_vectype, last_stmt_info,\n+\t\t\t\t\t  loop_vinfo);\n+\n+  /* Get the invariant base and non-invariant offset, converting the\n+     latter to the same width as the vector elements.  */\n+  tree base = gs_info.base;\n+  tree offset_type = vect_get_gather_scatter_offset_type (&gs_info);\n+  tree offset = vect_add_conversion_to_patterm (offset_type, gs_info.offset,\n+\t\t\t\t\t\tlast_stmt_info, loop_vinfo);\n+\n+  /* Build the new pattern statement.  */\n+  tree scale = size_int (gs_info.scale);\n+  gcall *pattern_stmt;\n+  if (DR_IS_READ (dr))\n+    {\n+      if (mask != NULL)\n+\tpattern_stmt = gimple_build_call_internal (gs_info.ifn, 4, base,\n+\t\t\t\t\t\t   offset, scale, mask);\n+      else\n+\tpattern_stmt = gimple_build_call_internal (gs_info.ifn, 3, base,\n+\t\t\t\t\t\t   offset, scale);\n+      tree load_lhs = vect_recog_temp_ssa_var (gs_info.element_type, NULL);\n+      gimple_call_set_lhs (pattern_stmt, load_lhs);\n+    }\n+  else\n+    /* Not yet supported.  */\n+    gcc_unreachable ();\n+  gimple_call_set_nothrow (pattern_stmt, true);\n+\n+  /* Copy across relevant vectorization info and associate DR with the\n+     new pattern statement instead of the original statement.  */\n+  stmt_vec_info pattern_stmt_info = new_stmt_vec_info (pattern_stmt,\n+\t\t\t\t\t\t       loop_vinfo);\n+  set_vinfo_for_stmt (pattern_stmt, pattern_stmt_info);\n+  STMT_VINFO_DATA_REF (pattern_stmt_info) = dr;\n+  STMT_VINFO_DR_WRT_VEC_LOOP (pattern_stmt_info)\n+    = STMT_VINFO_DR_WRT_VEC_LOOP (stmt_info);\n+  STMT_VINFO_GATHER_SCATTER_P (pattern_stmt_info)\n+    = STMT_VINFO_GATHER_SCATTER_P (stmt_info);\n+  DR_STMT (dr) = pattern_stmt;\n+\n+  tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n+  *type_out = vectype;\n+  *type_in = vectype;\n+\n+  if (dump_enabled_p ())\n+    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t     \"gather/scatter pattern detected:\\n\");\n+\n+  return pattern_stmt;\n+}\n+\n+/* Pattern wrapper around vect_try_gather_scatter_pattern.  */\n+\n+static gimple *\n+vect_recog_gather_scatter_pattern (vec<gimple *> *stmts, tree *type_in,\n+\t\t\t\t   tree *type_out)\n+{\n+  gimple *last_stmt = stmts->pop ();\n+  stmt_vec_info last_stmt_info = vinfo_for_stmt (last_stmt);\n+  gimple *pattern_stmt = vect_try_gather_scatter_pattern (last_stmt,\n+\t\t\t\t\t\t\t  last_stmt_info,\n+\t\t\t\t\t\t\t  type_in, type_out);\n+  if (pattern_stmt)\n+    stmts->safe_push (last_stmt);\n+  return pattern_stmt;\n+}\n \n /* Mark statements that are involved in a pattern.  */\n "}, {"sha": "a308d801082c1ece2d4cf645326eec78297f73f8", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 116, "deletions": 26, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfaa08b7ba1b00bbcc00bb76735c6b3547f5830f/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfaa08b7ba1b00bbcc00bb76735c6b3547f5830f/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=bfaa08b7ba1b00bbcc00bb76735c6b3547f5830f", "patch": "@@ -391,21 +391,19 @@ exist_non_indexing_operands_for_use_p (tree use, gimple *stmt)\n     {\n       if (is_gimple_call (stmt)\n \t  && gimple_call_internal_p (stmt))\n-\tswitch (gimple_call_internal_fn (stmt))\n-\t  {\n-\t  case IFN_MASK_STORE:\n-\t    operand = gimple_call_arg (stmt, 3);\n-\t    if (operand == use)\n-\t      return true;\n-\t    /* FALLTHRU */\n-\t  case IFN_MASK_LOAD:\n-\t    operand = gimple_call_arg (stmt, 2);\n-\t    if (operand == use)\n-\t      return true;\n-\t    break;\n-\t  default:\n-\t    break;\n-\t  }\n+\t{\n+\t  internal_fn ifn = gimple_call_internal_fn (stmt);\n+\t  int mask_index = internal_fn_mask_index (ifn);\n+\t  if (mask_index >= 0\n+\t      && use == gimple_call_arg (stmt, mask_index))\n+\t    return true;\n+\t  if (internal_gather_scatter_fn_p (ifn)\n+\t      && use == gimple_call_arg (stmt, 1))\n+\t    return true;\n+\t  if (ifn == IFN_MASK_STORE\n+\t      && use == gimple_call_arg (stmt, 3))\n+\t    return true;\n+\t}\n       return false;\n     }\n \n@@ -1727,14 +1725,17 @@ static tree permute_vec_elements (tree, tree, tree, gimple *,\n    is the type of the vector being loaded or stored.  MEMORY_ACCESS_TYPE\n    says how the load or store is going to be implemented and GROUP_SIZE\n    is the number of load or store statements in the containing group.\n+   If the access is a gather load or scatter store, GS_INFO describes\n+   its arguments.\n \n    Clear LOOP_VINFO_CAN_FULLY_MASK_P if a fully-masked loop is not\n    supported, otherwise record the required mask types.  */\n \n static void\n check_load_store_masking (loop_vec_info loop_vinfo, tree vectype,\n \t\t\t  vec_load_store_type vls_type, int group_size,\n-\t\t\t  vect_memory_access_type memory_access_type)\n+\t\t\t  vect_memory_access_type memory_access_type,\n+\t\t\t  gather_scatter_info *gs_info)\n {\n   /* Invariant loads need no special support.  */\n   if (memory_access_type == VMAT_INVARIANT)\n@@ -1762,6 +1763,29 @@ check_load_store_masking (loop_vec_info loop_vinfo, tree vectype,\n       return;\n     }\n \n+  if (memory_access_type == VMAT_GATHER_SCATTER)\n+    {\n+      gcc_assert (is_load);\n+      tree offset_type = TREE_TYPE (gs_info->offset);\n+      if (!internal_gather_scatter_fn_supported_p (IFN_MASK_GATHER_LOAD,\n+\t\t\t\t\t\t   vectype,\n+\t\t\t\t\t\t   gs_info->memory_type,\n+\t\t\t\t\t\t   TYPE_SIGN (offset_type),\n+\t\t\t\t\t\t   gs_info->scale))\n+\t{\n+\t  if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t     \"can't use a fully-masked loop because the\"\n+\t\t\t     \" target doesn't have an appropriate masked\"\n+\t\t\t     \" gather load instruction.\\n\");\n+\t  LOOP_VINFO_CAN_FULLY_MASK_P (loop_vinfo) = false;\n+\t  return;\n+\t}\n+      unsigned int ncopies = vect_get_num_copies (loop_vinfo, vectype);\n+      vect_record_loop_mask (loop_vinfo, masks, ncopies, vectype);\n+      return;\n+    }\n+\n   if (memory_access_type != VMAT_CONTIGUOUS\n       && memory_access_type != VMAT_CONTIGUOUS_PERMUTE)\n     {\n@@ -2563,6 +2587,31 @@ vect_build_gather_load_calls (gimple *stmt, gimple_stmt_iterator *gsi,\n     }\n }\n \n+/* Prepare the base and offset in GS_INFO for vectorization.\n+   Set *DATAREF_PTR to the loop-invariant base address and *VEC_OFFSET\n+   to the vectorized offset argument for the first copy of STMT.  STMT\n+   is the statement described by GS_INFO and LOOP is the containing loop.  */\n+\n+static void\n+vect_get_gather_scatter_ops (struct loop *loop, gimple *stmt,\n+\t\t\t     gather_scatter_info *gs_info,\n+\t\t\t     tree *dataref_ptr, tree *vec_offset)\n+{\n+  gimple_seq stmts = NULL;\n+  *dataref_ptr = force_gimple_operand (gs_info->base, &stmts, true, NULL_TREE);\n+  if (stmts != NULL)\n+    {\n+      basic_block new_bb;\n+      edge pe = loop_preheader_edge (loop);\n+      new_bb = gsi_insert_seq_on_edge_immediate (pe, stmts);\n+      gcc_assert (!new_bb);\n+    }\n+  tree offset_type = TREE_TYPE (gs_info->offset);\n+  tree offset_vectype = get_vectype_for_scalar_type (offset_type);\n+  *vec_offset = vect_get_vec_def_for_operand (gs_info->offset, stmt,\n+\t\t\t\t\t      offset_vectype);\n+}\n+\n /* Check and perform vectorization of BUILT_IN_BSWAP{16,32,64}.  */\n \n static bool\n@@ -2751,7 +2800,7 @@ vectorizable_call (gimple *gs, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n     return false;\n \n   if (gimple_call_internal_p (stmt)\n-      && (gimple_call_internal_fn (stmt) == IFN_MASK_LOAD\n+      && (internal_load_fn_p (gimple_call_internal_fn (stmt))\n \t  || gimple_call_internal_fn (stmt) == IFN_MASK_STORE))\n     /* Handled by vectorizable_load and vectorizable_store.  */\n     return false;\n@@ -5951,7 +6000,7 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n       if (loop_vinfo\n \t  && LOOP_VINFO_CAN_FULLY_MASK_P (loop_vinfo))\n \tcheck_load_store_masking (loop_vinfo, vectype, vls_type, group_size,\n-\t\t\t\t  memory_access_type);\n+\t\t\t\t  memory_access_type, &gs_info);\n \n       STMT_VINFO_TYPE (stmt_info) = store_vec_info_type;\n       /* The SLP costs are calculated during SLP analysis.  */\n@@ -6932,7 +6981,11 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n   else\n     {\n       gcall *call = dyn_cast <gcall *> (stmt);\n-      if (!call || !gimple_call_internal_p (call, IFN_MASK_LOAD))\n+      if (!call || !gimple_call_internal_p (call))\n+\treturn false;\n+\n+      internal_fn ifn = gimple_call_internal_fn (call);\n+      if (!internal_load_fn_p (ifn))\n \treturn false;\n \n       scalar_dest = gimple_call_lhs (call);\n@@ -6947,9 +7000,13 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t  return false;\n \t}\n \n-      mask = gimple_call_arg (call, 2);\n-      if (!vect_check_load_store_mask (stmt, mask, &mask_vectype))\n-\treturn false;\n+      int mask_index = internal_fn_mask_index (ifn);\n+      if (mask_index >= 0)\n+\t{\n+\t  mask = gimple_call_arg (call, mask_index);\n+\t  if (!vect_check_load_store_mask (stmt, mask, &mask_vectype))\n+\t    return false;\n+\t}\n     }\n \n   if (!STMT_VINFO_DATA_REF (stmt_info))\n@@ -7073,7 +7130,7 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t\t\t\t\t     TYPE_MODE (mask_vectype), true))\n \t    return false;\n \t}\n-      else if (memory_access_type == VMAT_GATHER_SCATTER)\n+      else if (memory_access_type == VMAT_GATHER_SCATTER && gs_info.decl)\n \t{\n \t  tree arglist = TYPE_ARG_TYPES (TREE_TYPE (gs_info.decl));\n \t  tree masktype\n@@ -7087,7 +7144,8 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t      return false;\n \t    }\n \t}\n-      else if (memory_access_type != VMAT_LOAD_STORE_LANES)\n+      else if (memory_access_type != VMAT_LOAD_STORE_LANES\n+\t       && memory_access_type != VMAT_GATHER_SCATTER)\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -7104,7 +7162,7 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n       if (loop_vinfo\n \t  && LOOP_VINFO_CAN_FULLY_MASK_P (loop_vinfo))\n \tcheck_load_store_masking (loop_vinfo, vectype, VLS_LOAD, group_size,\n-\t\t\t\t  memory_access_type);\n+\t\t\t\t  memory_access_type, &gs_info);\n \n       STMT_VINFO_TYPE (stmt_info) = load_vec_info_type;\n       /* The SLP costs are calculated during SLP analysis.  */\n@@ -7126,7 +7184,7 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \n   ensure_base_align (dr);\n \n-  if (memory_access_type == VMAT_GATHER_SCATTER)\n+  if (memory_access_type == VMAT_GATHER_SCATTER && gs_info.decl)\n     {\n       vect_build_gather_load_calls (stmt, gsi, vec_stmt, &gs_info, mask);\n       return true;\n@@ -7571,6 +7629,7 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n     aggr_type = vectype;\n \n   tree vec_mask = NULL_TREE;\n+  tree vec_offset = NULL_TREE;\n   prev_stmt_info = NULL;\n   poly_uint64 group_elt = 0;\n   vec_loop_masks *masks = &LOOP_VINFO_MASKS (loop_vinfo);\n@@ -7613,6 +7672,12 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t      dataref_ptr = bump_vector_ptr (dataref_ptr, ptr_incr, gsi,\n \t\t\t\t\t     stmt, diff);\n \t    }\n+\t  else if (STMT_VINFO_GATHER_SCATTER_P (stmt_info))\n+\t    {\n+\t      vect_get_gather_scatter_ops (loop, stmt, &gs_info,\n+\t\t\t\t\t   &dataref_ptr, &vec_offset);\n+\t      inv_p = false;\n+\t    }\n \t  else\n \t    dataref_ptr\n \t      = vect_create_data_ref_ptr (first_stmt, aggr_type, at_loop,\n@@ -7628,6 +7693,13 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t  if (dataref_offset)\n \t    dataref_offset = int_const_binop (PLUS_EXPR, dataref_offset,\n \t\t\t\t\t      TYPE_SIZE_UNIT (aggr_type));\n+\t  else if (STMT_VINFO_GATHER_SCATTER_P (stmt_info))\n+\t    {\n+\t      gimple *def_stmt;\n+\t      vect_def_type dt;\n+\t      vect_is_simple_use (vec_offset, loop_vinfo, &def_stmt, &dt);\n+\t      vec_offset = vect_get_vec_def_for_stmt_copy (dt, vec_offset);\n+\t    }\n \t  else\n \t    dataref_ptr = bump_vector_ptr (dataref_ptr, ptr_incr, gsi, stmt,\n \t\t\t\t\t   TYPE_SIZE_UNIT (aggr_type));\n@@ -7716,6 +7788,24 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t\t  {\n \t\t    unsigned int align, misalign;\n \n+\t\t    if (memory_access_type == VMAT_GATHER_SCATTER)\n+\t\t      {\n+\t\t\ttree scale = size_int (gs_info.scale);\n+\t\t\tgcall *call;\n+\t\t\tif (masked_loop_p)\n+\t\t\t  call = gimple_build_call_internal\n+\t\t\t    (IFN_MASK_GATHER_LOAD, 4, dataref_ptr,\n+\t\t\t     vec_offset, scale, final_mask);\n+\t\t\telse\n+\t\t\t  call = gimple_build_call_internal\n+\t\t\t    (IFN_GATHER_LOAD, 3, dataref_ptr,\n+\t\t\t     vec_offset, scale);\n+\t\t\tgimple_call_set_nothrow (call, true);\n+\t\t\tnew_stmt = call;\n+\t\t\tdata_ref = NULL_TREE;\n+\t\t\tbreak;\n+\t\t      }\n+\n \t\t    align = DR_TARGET_ALIGNMENT (dr);\n \t\t    if (alignment_support_scheme == dr_aligned)\n \t\t      {"}, {"sha": "a9ccdfd11367ba6fe2f6725ff82aadd288604c63", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfaa08b7ba1b00bbcc00bb76735c6b3547f5830f/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfaa08b7ba1b00bbcc00bb76735c6b3547f5830f/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=bfaa08b7ba1b00bbcc00bb76735c6b3547f5830f", "patch": "@@ -844,7 +844,12 @@ typedef struct _stmt_vec_info {\n \n /* Information about a gather/scatter call.  */\n struct gather_scatter_info {\n-  /* The FUNCTION_DECL for the built-in gather/scatter function.  */\n+  /* The internal function to use for the gather/scatter operation,\n+     or IFN_LAST if a built-in function should be used instead.  */\n+  internal_fn ifn;\n+\n+  /* The FUNCTION_DECL for the built-in gather/scatter function,\n+     or null if an internal function should be used instead.  */\n   tree decl;\n \n   /* The loop-invariant base value.  */\n@@ -862,6 +867,12 @@ struct gather_scatter_info {\n \n   /* The type of the vectorized offset.  */\n   tree offset_vectype;\n+\n+  /* The type of the scalar elements after loading or before storing.  */\n+  tree element_type;\n+\n+  /* The type of the scalar elements being loaded or stored.  */\n+  tree memory_type;\n };\n \n /* Access Functions.  */\n@@ -1533,7 +1544,7 @@ extern void duplicate_and_interleave (gimple_seq *, tree, vec<tree>,\n    Additional pattern recognition functions can (and will) be added\n    in the future.  */\n typedef gimple *(* vect_recog_func_ptr) (vec<gimple *> *, tree *, tree *);\n-#define NUM_PATTERNS 14\n+#define NUM_PATTERNS 15\n void vect_pattern_recog (vec_info *);\n \n /* In tree-vectorizer.c.  */"}]}