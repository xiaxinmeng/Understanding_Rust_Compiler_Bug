{"sha": "88ca1146aa66e3526c58468f1da16174fdc84c54", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODhjYTExNDZhYTY2ZTM1MjZjNTg0NjhmMWRhMTYxNzRmZGM4NGM1NA==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2009-10-14T18:39:45Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2009-10-14T18:39:45Z"}, "message": "gimple.c (gtc_ob): New global.\n\n2009-10-14  Richard Guenther  <rguenther@suse.de>\n\n\t* gimple.c (gtc_ob): New global.\n\t(struct type_pair_d): Replace pointers with type UIDs.\n\t(type_pair_hash): Adjust.\n\t(type_pair_eq): Likewise.\n\t(lookup_type_pair): Likewise.  Allocate from an obstack.\n\t(gimple_force_type_merge): Adjust.\n\t(gimple_types_compatible_p): Likewise.\n\t(free_gimple_type_tables): Free the obstack.\n\nFrom-SVN: r152776", "tree": {"sha": "b6002d111b4e1d8083bf800bf3164b9501f35a06", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b6002d111b4e1d8083bf800bf3164b9501f35a06"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/88ca1146aa66e3526c58468f1da16174fdc84c54", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88ca1146aa66e3526c58468f1da16174fdc84c54", "html_url": "https://github.com/Rust-GCC/gccrs/commit/88ca1146aa66e3526c58468f1da16174fdc84c54", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88ca1146aa66e3526c58468f1da16174fdc84c54/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0f66d09c1eac08fb47d63d9c165f37b7dd1b14b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f66d09c1eac08fb47d63d9c165f37b7dd1b14b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f66d09c1eac08fb47d63d9c165f37b7dd1b14b8"}], "stats": {"total": 46, "additions": 31, "deletions": 15}, "files": [{"sha": "43850188f5bd4339dc3ff089073ecfd3fc0b0195", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88ca1146aa66e3526c58468f1da16174fdc84c54/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88ca1146aa66e3526c58468f1da16174fdc84c54/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=88ca1146aa66e3526c58468f1da16174fdc84c54", "patch": "@@ -1,3 +1,14 @@\n+2009-10-14  Richard Guenther  <rguenther@suse.de>\n+\n+\t* gimple.c (gtc_ob): New global.\n+\t(struct type_pair_d): Replace pointers with type UIDs.\n+\t(type_pair_hash): Adjust.\n+\t(type_pair_eq): Likewise.\n+\t(lookup_type_pair): Likewise.  Allocate from an obstack.\n+\t(gimple_force_type_merge): Adjust.\n+\t(gimple_types_compatible_p): Likewise.\n+\t(free_gimple_type_tables): Free the obstack.\n+\n 2009-10-14  Jakub Jelinek  <jakub@redhat.com>\n \n \t* tree-parloops.c (separate_decls_in_region_debug_bind): Drop debug"}, {"sha": "519b41cb9f0d9c293fe701f3acc3a4ab5b88ba7d", "filename": "gcc/gimple.c", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88ca1146aa66e3526c58468f1da16174fdc84c54/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88ca1146aa66e3526c58468f1da16174fdc84c54/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=88ca1146aa66e3526c58468f1da16174fdc84c54", "patch": "@@ -46,6 +46,7 @@ static struct pointer_map_t *type_hash_cache;\n \n /* Global type comparison cache.  */\n static htab_t gtc_visited;\n+static struct obstack gtc_ob;\n \n /* All the tuples have their operand vector (if present) at the very bottom\n    of the structure.  Therefore, the offset required to find the\n@@ -3025,8 +3026,8 @@ static hashval_t gimple_type_hash (const void *);\n    infinite recursion due to self-referential types.  */\n struct type_pair_d\n {\n-  tree t1;\n-  tree t2;\n+  unsigned int uid1;\n+  unsigned int uid2;\n   int same_p;\n };\n typedef struct type_pair_d *type_pair_t;\n@@ -3037,8 +3038,8 @@ static hashval_t\n type_pair_hash (const void *p)\n {\n   const struct type_pair_d *pair = (const struct type_pair_d *) p;\n-  hashval_t val1 = iterative_hash_hashval_t (htab_hash_pointer (pair->t1), 0);\n-  hashval_t val2 = iterative_hash_hashval_t (htab_hash_pointer (pair->t2), 0);\n+  hashval_t val1 = pair->uid1;\n+  hashval_t val2 = pair->uid2;\n   return (iterative_hash_hashval_t (val2, val1)\n \t  ^ iterative_hash_hashval_t (val1, val2));\n }\n@@ -3050,34 +3051,37 @@ type_pair_eq (const void *p1, const void *p2)\n {\n   const struct type_pair_d *pair1 = (const struct type_pair_d *) p1;\n   const struct type_pair_d *pair2 = (const struct type_pair_d *) p2;\n-  return ((pair1->t1 == pair2->t1 && pair1->t2 == pair2->t2)\n-\t  || (pair1->t1 == pair2->t2 && pair1->t2 == pair2->t1));\n+  return ((pair1->uid1 == pair2->uid1 && pair1->uid2 == pair2->uid2)\n+\t  || (pair1->uid1 == pair2->uid2 && pair1->uid2 == pair2->uid1));\n }\n \n /* Lookup the pair of types T1 and T2 in *VISITED_P.  Insert a new\n    entry if none existed.  */\n \n static type_pair_t\n-lookup_type_pair (tree t1, tree t2, htab_t *visited_p)\n+lookup_type_pair (tree t1, tree t2, htab_t *visited_p, struct obstack *ob_p)\n {\n   struct type_pair_d pair;\n   type_pair_t p;\n   void **slot;\n \n   if (*visited_p == NULL)\n-    *visited_p = htab_create (251, type_pair_hash, type_pair_eq, free);\n+    {\n+      *visited_p = htab_create (251, type_pair_hash, type_pair_eq, NULL);\n+      gcc_obstack_init (ob_p);\n+    }\n \n-  pair.t1 = t1;\n-  pair.t2 = t2;\n+  pair.uid1 = TYPE_UID (t1);\n+  pair.uid2 = TYPE_UID (t2);\n   slot = htab_find_slot (*visited_p, &pair, INSERT);\n \n   if (*slot)\n     p = *((type_pair_t *) slot);\n   else\n     {\n-      p = XNEW (struct type_pair_d);\n-      p->t1 = t1;\n-      p->t2 = t2;\n+      p = XOBNEW (ob_p, struct type_pair_d);\n+      p->uid1 = TYPE_UID (t1);\n+      p->uid2 = TYPE_UID (t2);\n       p->same_p = -2;\n       *slot = (void *) p;\n     }\n@@ -3110,7 +3114,7 @@ gimple_force_type_merge (tree t1, tree t2)\n \n   /* Adjust cached comparison results for T1 and T2 to make sure\n      they now compare compatible.  */\n-  p = lookup_type_pair (t1, t2, &gtc_visited);\n+  p = lookup_type_pair (t1, t2, &gtc_visited, &gtc_ob);\n   p->same_p = 1;\n }\n \n@@ -3220,7 +3224,7 @@ gimple_types_compatible_p (tree t1, tree t2)\n \n   /* If we've visited this type pair before (in the case of aggregates\n      with self-referential types), and we made a decision, return it.  */\n-  p = lookup_type_pair (t1, t2, &gtc_visited);\n+  p = lookup_type_pair (t1, t2, &gtc_visited, &gtc_ob);\n   if (p->same_p == 0 || p->same_p == 1)\n     {\n       /* We have already decided whether T1 and T2 are the\n@@ -3917,6 +3921,7 @@ free_gimple_type_tables (void)\n   if (gtc_visited)\n     {\n       htab_delete (gtc_visited);\n+      obstack_free (&gtc_ob, NULL);\n       gtc_visited = NULL;\n     }\n }"}]}