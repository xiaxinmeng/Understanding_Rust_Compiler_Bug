{"sha": "b4345a57d828a55b70d6e5f5f4294c97c6acf304", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjQzNDVhNTdkODI4YTU1YjcwZDZlNWY1ZjQyOTRjOTdjNmFjZjMwNA==", "commit": {"author": {"name": "Jeroen Frijters", "email": "jeroen@frijters.net", "date": "2004-11-24T11:11:46Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2004-11-24T11:11:46Z"}, "message": "2004-11-24  Jeroen Frijters  <address@bogus.example.com>\n\n\t* java/nio/DirectByteBufferImpl.java\n\t(ReadOnly): New inner subclass.\n\t(ReadWrite): New inner subclass.\n\t(owner): Made final and private.\n\t(address): Made final.\n\t(DirectByteBufferImpl(int)): New constructor.\n\t(DirectByteBufferImpl(Object,RawData,int,int,int)): New constructor.\n\t(DirectByteBufferImpl(Object,RawData,int,int,int,boolean)): Removed.\n\t(allocate): Modified to instantiate ReadWrite subclass.\n\t(finalize): Fixed to only free the buffer, if we own it.\n\t(put): Removed read-only check.\n\t(slice, duplicate): Modified to instantiate appropriate subclass.\n\t(isReadOnly): Removed.\n\t* java/nio/MappedByteBufferImpl.java\n\t(slice, duplicate): Modified to instantiate appropriate\n\tDirectByteBufferImpl subclass.\n\nFrom-SVN: r91147", "tree": {"sha": "d8acf142a0fcbab0fee8a725ea47393e31d71943", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d8acf142a0fcbab0fee8a725ea47393e31d71943"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b4345a57d828a55b70d6e5f5f4294c97c6acf304", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4345a57d828a55b70d6e5f5f4294c97c6acf304", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b4345a57d828a55b70d6e5f5f4294c97c6acf304", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4345a57d828a55b70d6e5f5f4294c97c6acf304/comments", "author": {"login": "jfrijters", "id": 2994393, "node_id": "MDQ6VXNlcjI5OTQzOTM=", "avatar_url": "https://avatars.githubusercontent.com/u/2994393?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jfrijters", "html_url": "https://github.com/jfrijters", "followers_url": "https://api.github.com/users/jfrijters/followers", "following_url": "https://api.github.com/users/jfrijters/following{/other_user}", "gists_url": "https://api.github.com/users/jfrijters/gists{/gist_id}", "starred_url": "https://api.github.com/users/jfrijters/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jfrijters/subscriptions", "organizations_url": "https://api.github.com/users/jfrijters/orgs", "repos_url": "https://api.github.com/users/jfrijters/repos", "events_url": "https://api.github.com/users/jfrijters/events{/privacy}", "received_events_url": "https://api.github.com/users/jfrijters/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "11dde1bb18eaf7a6981bc5e7e46cc7d945d55182", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11dde1bb18eaf7a6981bc5e7e46cc7d945d55182", "html_url": "https://github.com/Rust-GCC/gccrs/commit/11dde1bb18eaf7a6981bc5e7e46cc7d945d55182"}], "stats": {"total": 161, "additions": 124, "deletions": 37}, "files": [{"sha": "b4fe15df019fe1b26648417eed1b39489f1e8f64", "filename": "libjava/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4345a57d828a55b70d6e5f5f4294c97c6acf304/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4345a57d828a55b70d6e5f5f4294c97c6acf304/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=b4345a57d828a55b70d6e5f5f4294c97c6acf304", "patch": "@@ -1,3 +1,22 @@\n+2004-11-24  Jeroen Frijters  <address@bogus.example.com>\n+\n+\t* java/nio/DirectByteBufferImpl.java\n+\t(ReadOnly): New inner subclass.\n+\t(ReadWrite): New inner subclass.\n+\t(owner): Made final and private.\n+\t(address): Made final.\n+\t(DirectByteBufferImpl(int)): New constructor.\n+\t(DirectByteBufferImpl(Object,RawData,int,int,int)): New constructor.\n+\t(DirectByteBufferImpl(Object,RawData,int,int,int,boolean)): Removed.\n+\t(allocate): Modified to instantiate ReadWrite subclass.\n+\t(finalize): Fixed to only free the buffer, if we own it.\n+\t(put): Removed read-only check.\n+\t(slice, duplicate): Modified to instantiate appropriate subclass.\n+\t(isReadOnly): Removed.\n+\t* java/nio/MappedByteBufferImpl.java\n+\t(slice, duplicate): Modified to instantiate appropriate\n+\tDirectByteBufferImpl subclass.\n+\n 2004-11-24  Michael Koch  <konqueror@gmx.de>\n \n \t* gnu/java/nio/NIOServerSocket.java: Added email to @author tag."}, {"sha": "ab8cd6f79737edc6b16a4c3b52f3b3c54ee8a4d8", "filename": "libjava/java/nio/DirectByteBufferImpl.java", "status": "modified", "additions": 90, "deletions": 32, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4345a57d828a55b70d6e5f5f4294c97c6acf304/libjava%2Fjava%2Fnio%2FDirectByteBufferImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4345a57d828a55b70d6e5f5f4294c97c6acf304/libjava%2Fjava%2Fnio%2FDirectByteBufferImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnio%2FDirectByteBufferImpl.java?ref=b4345a57d828a55b70d6e5f5f4294c97c6acf304", "patch": "@@ -40,41 +40,96 @@\n \n import gnu.gcj.RawData;\n \n-final class DirectByteBufferImpl extends ByteBuffer\n+abstract class DirectByteBufferImpl extends ByteBuffer\n {\n-  /** Used by MappedByteBufferImpl and when slicing to prevent premature GC. */\n-  protected Object owner;\n-\n-  RawData address;\n-  private boolean readOnly;\n-\n-  public DirectByteBufferImpl(RawData address, long len)\n-  {\n-    this(null, address, (int) len, (int) len, 0, false);\n-  }\n-  \n-  public DirectByteBufferImpl(Object owner, RawData address,\n-\t\t\t      int capacity, int limit,\n-\t\t\t      int position, boolean readOnly)\n+  /** The owner is used to keep alive the object that actually owns the\n+    * memory. There are three possibilities:\n+    *  1) owner == this: We allocated the memory and we should free it,\n+    *                    but *only* in finalize (if we've been sliced\n+    *                    other objects will also have access to the\n+    *                    memory).\n+    *  2) owner == null: The byte buffer was created thru\n+    *                    JNI.NewDirectByteBuffer. The JNI code is\n+    *                    responsible for freeing the memory.\n+    *  3) owner == some other object: The other object allocated the\n+    *                                 memory and should free it.\n+    */\n+  private final Object owner;\n+  final RawData address;\n+\n+  final static class ReadOnly extends DirectByteBufferImpl\n+  {\n+    ReadOnly(Object owner, RawData address,\n+\t     int capacity, int limit,\n+\t     int position)\n+    {\n+      super(owner, address, capacity, limit, position);\n+    }\n+\n+    public ByteBuffer put(byte value)\n+    {\n+      throw new ReadOnlyBufferException ();\n+    }\n+\n+    public ByteBuffer put(int index, byte value)\n+    {\n+      throw new ReadOnlyBufferException ();\n+    }\n+\n+    public boolean isReadOnly()\n+    {\n+      return true;\n+    }\n+  }\n+\n+  final static class ReadWrite extends DirectByteBufferImpl\n+  {\n+    ReadWrite(int capacity)\n+    {\n+      super(capacity);\n+    }\n+\n+    ReadWrite(Object owner, RawData address,\n+\t      int capacity, int limit,\n+\t      int position)\n+    {\n+      super(owner, address, capacity, limit, position);\n+    }\n+\n+    public boolean isReadOnly()\n+    {\n+      return false;\n+    }\n+  }\n+\n+  DirectByteBufferImpl(int capacity)\n+  {\n+    super(capacity, capacity, 0, -1);\n+    this.owner = this;\n+    this.address = VMDirectByteBuffer.allocate(capacity);\n+  }\n+\n+  DirectByteBufferImpl(Object owner, RawData address,\n+\t\t       int capacity, int limit,\n+\t\t       int position)\n   {\n     super(capacity, limit, position, -1);\n-    this.address = address;\n-    this.readOnly = readOnly;\n     this.owner = owner;\n+    this.address = address;\n   }\n \n   /**\n    * Allocates a new direct byte buffer.\n    */ \n   public static ByteBuffer allocate(int capacity)\n   {\n-    return new DirectByteBufferImpl(VMDirectByteBuffer.allocate(capacity),\n-\t\t\t\t    capacity);\n+    return new DirectByteBufferImpl.ReadWrite(capacity);\n   }\n \n   protected void finalize() throws Throwable\n   {\n-    VMDirectByteBuffer.free(address);\n+    if (owner == this)\n+        VMDirectByteBuffer.free(address);\n   }\n   \n   public byte get()\n@@ -108,7 +163,6 @@ public ByteBuffer get(byte[] dst, int offset, int length)\n \n   public ByteBuffer put(byte value)\n   {\n-    checkIfReadOnly();\n     checkForOverflow();\n \n     int pos = position();\n@@ -119,7 +173,6 @@ public ByteBuffer put(byte value)\n   \n   public ByteBuffer put(int index, byte value)\n   {\n-    checkIfReadOnly();\n     checkIndex(index);\n \n     VMDirectByteBuffer.put(address, index, value);\n@@ -147,9 +200,14 @@ public ByteBuffer compact()\n   public ByteBuffer slice()\n   {\n     int rem = remaining();\n-    return new DirectByteBufferImpl\n+    if (isReadOnly())\n+        return new DirectByteBufferImpl.ReadOnly\n+      (owner, VMDirectByteBuffer.adjustAddress(address, position()),\n+       rem, rem, 0);\n+    else\n+        return new DirectByteBufferImpl.ReadWrite\n       (owner, VMDirectByteBuffer.adjustAddress(address, position()),\n-       rem, rem, 0, isReadOnly());\n+       rem, rem, 0);\n   }\n \n   private ByteBuffer duplicate(boolean readOnly)\n@@ -158,9 +216,14 @@ private ByteBuffer duplicate(boolean readOnly)\n     reset();\n     int mark = position();\n     position(pos);\n-    DirectByteBufferImpl result\n-      = new DirectByteBufferImpl(owner, address, capacity(), limit(),\n-\t\t\t\t pos, readOnly);\n+    DirectByteBufferImpl result;\n+    if (readOnly)\n+        result = new DirectByteBufferImpl.ReadOnly(owner, address, capacity(),\n+                                                   limit(), pos);\n+    else\n+        result = new DirectByteBufferImpl.ReadWrite(owner, address, capacity(),\n+                                                    limit(), pos);\n+\n     if (mark != pos)\n       {\n \tresult.position(mark);\n@@ -180,11 +243,6 @@ public ByteBuffer asReadOnlyBuffer()\n     return duplicate(true);\n   }\n \n-  public boolean isReadOnly()\n-  {\n-    return readOnly;\n-  }\n-\n   public boolean isDirect()\n   {\n     return true;"}, {"sha": "bc8ee80d5cdb71dd0412a4c86546a7f936adf1b3", "filename": "libjava/java/nio/MappedByteBufferImpl.java", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4345a57d828a55b70d6e5f5f4294c97c6acf304/libjava%2Fjava%2Fnio%2FMappedByteBufferImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4345a57d828a55b70d6e5f5f4294c97c6acf304/libjava%2Fjava%2Fnio%2FMappedByteBufferImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnio%2FMappedByteBufferImpl.java?ref=b4345a57d828a55b70d6e5f5f4294c97c6acf304", "patch": "@@ -138,9 +138,14 @@ public boolean isDirect()\n   public ByteBuffer slice()\n   {\n     int rem = remaining();\n-    return new DirectByteBufferImpl\n+    if (isReadOnly())\n+        return new DirectByteBufferImpl.ReadOnly\n       (this, VMDirectByteBuffer.adjustAddress(address, position()),\n-       rem, rem, 0, isReadOnly());\n+       rem, rem, 0);\n+    else\n+        return new DirectByteBufferImpl.ReadWrite\n+      (this, VMDirectByteBuffer.adjustAddress(address, position()),\n+       rem, rem, 0);\n   }\n \n   private ByteBuffer duplicate(boolean readOnly)\n@@ -149,9 +154,14 @@ private ByteBuffer duplicate(boolean readOnly)\n     reset();\n     int mark = position();\n     position(pos);\n-    DirectByteBufferImpl result\n-      = new DirectByteBufferImpl(this, address, capacity(), limit(),\n-\t\t\t\t pos, readOnly);\n+    DirectByteBufferImpl result;\n+    if (readOnly)\n+        result = new DirectByteBufferImpl.ReadOnly(this, address, capacity(),\n+                                                   limit(), pos);\n+    else\n+        result = new DirectByteBufferImpl.ReadWrite(this, address, capacity(),\n+                                                    limit(), pos);\n+\n     if (mark != pos)\n       {\n \tresult.position(mark);"}]}