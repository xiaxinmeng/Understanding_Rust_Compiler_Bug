{"sha": "32ff12435e068632cc28b1521b087e019ecf6717", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzJmZjEyNDM1ZTA2ODYzMmNjMjhiMTUyMWIwODdlMDE5ZWNmNjcxNw==", "commit": {"author": {"name": "Dorit Nuzman", "email": "dorit@il.ibm.com", "date": "2008-08-14T12:47:56Z"}, "committer": {"name": "Dorit Nuzman", "email": "dorit@gcc.gnu.org", "date": "2008-08-14T12:47:56Z"}, "message": "tree-vect-transform.c (vect_create_epilog_for_reduction): Takes an additional argument.\n\n2008-08-14  Dorit Nuzman  <dorit@il.ibm.com>\n\n        * tree-vect-transform.c (vect_create_epilog_for_reduction): Takes an\n        additional argument. Support reduction when duplication is needed due\n        to data-types of different sizes in the loop.\n        (get_initial_def_for_induction): Fix printout.\n        (vect_get_vec_def_for_stmt_copy): Support case where the\n        vec_stmt_for_operand is a phi node.\n        (vectorizable_reduction): Support reduction when duplication is needed\n        due to data-types of different sizes in the loop.\n        (vectorizable_call): Remove restriction to not vectorize in case we\n        have data-types of different sizes in the loop.\n        (vectorizable_conversion): Likewise.\n        (vectorizable_operation): Likewise.\n        (vectorizable_type_demotion): Likewise.\n        (vectorizable_type_promotion): Likewise.\n        (vectorizable_induction): Add restriction to not vectorize in case\n        we have data-types of different sizes in the loop.\n\nFrom-SVN: r139096", "tree": {"sha": "2bb300d5bbf5621f6ab3e5ec9a6887537147abf9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2bb300d5bbf5621f6ab3e5ec9a6887537147abf9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/32ff12435e068632cc28b1521b087e019ecf6717", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32ff12435e068632cc28b1521b087e019ecf6717", "html_url": "https://github.com/Rust-GCC/gccrs/commit/32ff12435e068632cc28b1521b087e019ecf6717", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32ff12435e068632cc28b1521b087e019ecf6717/comments", "author": null, "committer": null, "parents": [{"sha": "ed6fa12929896f7771ce9e1f5bef380001d74af7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed6fa12929896f7771ce9e1f5bef380001d74af7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed6fa12929896f7771ce9e1f5bef380001d74af7"}], "stats": {"total": 312, "additions": 194, "deletions": 118}, "files": [{"sha": "77796d5674e8a2c6db39abfc73c345be46e55399", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32ff12435e068632cc28b1521b087e019ecf6717/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32ff12435e068632cc28b1521b087e019ecf6717/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=32ff12435e068632cc28b1521b087e019ecf6717", "patch": "@@ -1,3 +1,22 @@\n+2008-08-14  Dorit Nuzman  <dorit@il.ibm.com>\n+\n+\t* tree-vect-transform.c (vect_create_epilog_for_reduction): Takes an\n+\tadditional argument. Support reduction when duplication is needed due\n+\tto data-types of different sizes in the loop.\n+\t(get_initial_def_for_induction): Fix printout.\n+\t(vect_get_vec_def_for_stmt_copy): Support case where the\n+\tvec_stmt_for_operand is a phi node.\n+\t(vectorizable_reduction): Support reduction when duplication is needed \n+\tdue to data-types of different sizes in the loop.\n+\t(vectorizable_call): Remove restriction to not vectorize in case we \n+\thave data-types of different sizes in the loop.\n+\t(vectorizable_conversion): Likewise.\n+\t(vectorizable_operation): Likewise.\n+\t(vectorizable_type_demotion): Likewise.\n+\t(vectorizable_type_promotion): Likewise.\n+\t(vectorizable_induction): Add restriction to not vectorize in case \n+\twe have data-types of different sizes in the loop.\n+\n 2008-08-14  Christophe Saout  <christophe@saout.de>\n \t    Uros Bizjak  <ubizjak@gmail.com>\n "}, {"sha": "095d0a6450e1bc1529590d2800ea4f243dc32845", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32ff12435e068632cc28b1521b087e019ecf6717/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32ff12435e068632cc28b1521b087e019ecf6717/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=32ff12435e068632cc28b1521b087e019ecf6717", "patch": "@@ -1,3 +1,14 @@\n+2008-08-14  Dorit Nuzman  <dorit@il.ibm.com>\n+\n+\t* gcc.dg/vect/vect-outer-4g.c: Change loop bound.\n+\t* gcc.dg/vect/vect-outer-4k.c: Likewise.\n+\t* gcc.dg/vect/vect-outer-4l.c: Likewise.\n+\t* gcc.dg/vect/vect-outer-4f.c: Likewise.\n+\t* gcc.dg/vect/vect-outer-4a.c: Vectorizable. Remove obsolete comment.\n+\t* gcc.dg/vect/vect-outer-4i.c: Likewise.\n+\t* gcc.dg/vect/vect-outer-4b.c: Likewise.\n+\t* gcc.dg/vect/vect-outer-4j.c: Likewise.\n+\n 2008-08-14  Uros Bizjak  <ubizjak@gmail.com>\n \n \tPR target/37101"}, {"sha": "d7bcc9a2e8c49a826499a4ce2e72365e35c3c3d1", "filename": "gcc/testsuite/gcc.dg/vect/vect-outer-4a.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32ff12435e068632cc28b1521b087e019ecf6717/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-4a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32ff12435e068632cc28b1521b087e019ecf6717/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-4a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-4a.c?ref=32ff12435e068632cc28b1521b087e019ecf6717", "patch": "@@ -6,8 +6,7 @@ signed short in[N+M];\n signed short coeff[M];\n signed short out[N];\n \n-/* Outer-loop vectorization.\n-   Currently not vectorized because of multiple-data-types in the inner-loop.  */\n+/* Outer-loop vectorization. */\n \n void\n foo (){\n@@ -23,9 +22,5 @@ foo (){\n   }\n }\n \n-/* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED\" 1 \"vect\" { xfail *-*-* } } } */\n-/* FORNOW. not vectorized until we support 0-stride acceses like coeff[j]. should be:\n-   { scan-tree-dump-not \"multiple types in nested loop.\" \"vect\" { xfail *-*-* } } } */\n-\n-/* { dg-final { scan-tree-dump-times \"zero step in outer loop.\" 1  \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED\" 1 \"vect\" { target { vect_widen_mult_hi_to_si && vect_pack_trunc } } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "407315a8dc305e4c262dc9bcd0fea0caa0b49462", "filename": "gcc/testsuite/gcc.dg/vect/vect-outer-4b.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32ff12435e068632cc28b1521b087e019ecf6717/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-4b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32ff12435e068632cc28b1521b087e019ecf6717/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-4b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-4b.c?ref=32ff12435e068632cc28b1521b087e019ecf6717", "patch": "@@ -6,8 +6,7 @@ signed short in[N+M];\n signed short coeff[M];\n int out[N];\n \n-/* Outer-loop vectorization.\n-   Currently not vectorized because of multiple-data-types in the inner-loop.  */\n+/* Outer-loop vectorization. */\n \n void\n foo (){\n@@ -23,9 +22,5 @@ foo (){\n   }\n }\n \n-/* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED\" 1 \"vect\" { xfail *-*-* } } } */\n-/* FORNOW. not vectorized until we support 0-stride acceses like coeff[j]. should be:\n-   { scan-tree-dump-not \"multiple types in nested loop.\" \"vect\" { xfail *-*-* } } } */\n-\n-/* { dg-final { scan-tree-dump-times \"zero step in outer loop.\" 1  \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED\" 1 \"vect\" { target vect_widen_mult_hi_to_si } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "88d6b7abccd22745d0460bc20d47ca589485b667", "filename": "gcc/testsuite/gcc.dg/vect/vect-outer-4f.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32ff12435e068632cc28b1521b087e019ecf6717/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-4f.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32ff12435e068632cc28b1521b087e019ecf6717/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-4f.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-4f.c?ref=32ff12435e068632cc28b1521b087e019ecf6717", "patch": "@@ -2,7 +2,7 @@\n #include <stdarg.h>\n #include \"tree-vect.h\"\n \n-#define N 40\n+#define N 96\n #define M 128\n unsigned short in[N+M];\n unsigned int out[N];"}, {"sha": "88d6b7abccd22745d0460bc20d47ca589485b667", "filename": "gcc/testsuite/gcc.dg/vect/vect-outer-4g.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32ff12435e068632cc28b1521b087e019ecf6717/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-4g.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32ff12435e068632cc28b1521b087e019ecf6717/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-4g.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-4g.c?ref=32ff12435e068632cc28b1521b087e019ecf6717", "patch": "@@ -2,7 +2,7 @@\n #include <stdarg.h>\n #include \"tree-vect.h\"\n \n-#define N 40\n+#define N 96\n #define M 128\n unsigned short in[N+M];\n unsigned int out[N];"}, {"sha": "a244ac20ac25458e23707da98577ad546936c792", "filename": "gcc/testsuite/gcc.dg/vect/vect-outer-4i.c", "status": "modified", "additions": 25, "deletions": 4, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32ff12435e068632cc28b1521b087e019ecf6717/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-4i.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32ff12435e068632cc28b1521b087e019ecf6717/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-4i.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-4i.c?ref=32ff12435e068632cc28b1521b087e019ecf6717", "patch": "@@ -1,13 +1,17 @@\n-/* { dg-do compile } */\n+/* { dg-require-effective-target vect_int } */\n \n-#define N 40\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 96\n #define M 128\n unsigned char in[N+M];\n unsigned short out[N];\n \n /* Outer-loop vectorization. */\n-/* Not vectorized due to multiple-types in the inner-loop.  */\n+/* Multiple-types in the inner-loop.  */\n \n+__attribute__ ((noinline))\n unsigned short\n foo (){\n   int i,j;\n@@ -24,5 +28,22 @@ foo (){\n   return s;\n }\n \n-/* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED\" 1 \"vect\" { xfail *-*-* } } } */\n+int main (void)\n+{\n+  check_vect ();\n+  int i;\n+  unsigned short s;\n+\n+  for (i = 0; i < N+M; i++)\n+    in[i] = (unsigned char)i;\n+\n+  s = foo ();\n+\n+  if (s != 34048)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED\" 1 \"vect\" { target vect_unpack } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "db8f61c5e374a6c3496ebeabbafb5efc14a3e4a8", "filename": "gcc/testsuite/gcc.dg/vect/vect-outer-4j.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32ff12435e068632cc28b1521b087e019ecf6717/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-4j.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32ff12435e068632cc28b1521b087e019ecf6717/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-4j.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-4j.c?ref=32ff12435e068632cc28b1521b087e019ecf6717", "patch": "@@ -1,12 +1,11 @@\n /* { dg-do compile } */\n \n-#define N 40\n+#define N 96\n #define M 128\n unsigned char in[N+M];\n unsigned short out[N];\n \n /* Outer-loop vectorization. */\n-/* Not vectorized due to multiple-types in the inner-loop.  */\n \n void\n foo (){\n@@ -22,5 +21,5 @@ foo (){\n   }\n }\n \n-/* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED\" 1 \"vect\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED\" 1 \"vect\" { target vect_unpack } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "88d6b7abccd22745d0460bc20d47ca589485b667", "filename": "gcc/testsuite/gcc.dg/vect/vect-outer-4k.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32ff12435e068632cc28b1521b087e019ecf6717/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-4k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32ff12435e068632cc28b1521b087e019ecf6717/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-4k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-4k.c?ref=32ff12435e068632cc28b1521b087e019ecf6717", "patch": "@@ -2,7 +2,7 @@\n #include <stdarg.h>\n #include \"tree-vect.h\"\n \n-#define N 40\n+#define N 96\n #define M 128\n unsigned short in[N+M];\n unsigned int out[N];"}, {"sha": "88d6b7abccd22745d0460bc20d47ca589485b667", "filename": "gcc/testsuite/gcc.dg/vect/vect-outer-4l.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32ff12435e068632cc28b1521b087e019ecf6717/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-4l.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32ff12435e068632cc28b1521b087e019ecf6717/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-4l.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-4l.c?ref=32ff12435e068632cc28b1521b087e019ecf6717", "patch": "@@ -2,7 +2,7 @@\n #include <stdarg.h>\n #include \"tree-vect.h\"\n \n-#define N 40\n+#define N 96\n #define M 128\n unsigned short in[N+M];\n unsigned int out[N];"}, {"sha": "eb370775cbadf7d2c4436a8954f3c0bb7eeced64", "filename": "gcc/tree-vect-transform.c", "status": "modified", "additions": 129, "deletions": 93, "changes": 222, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32ff12435e068632cc28b1521b087e019ecf6717/gcc%2Ftree-vect-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32ff12435e068632cc28b1521b087e019ecf6717/gcc%2Ftree-vect-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-transform.c?ref=32ff12435e068632cc28b1521b087e019ecf6717", "patch": "@@ -59,8 +59,8 @@ static tree vect_init_vector (gimple, tree, tree, gimple_stmt_iterator *);\n static void vect_finish_stmt_generation \n   (gimple stmt, gimple vec_stmt, gimple_stmt_iterator *);\n static bool vect_is_simple_cond (tree, loop_vec_info); \n-static void vect_create_epilog_for_reduction (tree, gimple, enum tree_code,\n-\t\t\t\t\t      gimple);\n+static void vect_create_epilog_for_reduction \n+  (tree, gimple, int, enum tree_code, gimple);\n static tree get_initial_def_for_reduction (gimple, tree, tree *);\n \n /* Utility function dealing with loop peeling (not peeling itself).  */\n@@ -1824,7 +1824,7 @@ get_initial_def_for_induction (gimple iv_phi)\n \n   if (vect_print_dump_info (REPORT_DETAILS))\n     {\n-      fprintf (vect_dump, \"transform induction: created def-use cycle:\");\n+      fprintf (vect_dump, \"transform induction: created def-use cycle: \");\n       print_gimple_stmt (vect_dump, induction_phi, 0, TDF_SLIM);\n       fprintf (vect_dump, \"\\n\");\n       print_gimple_stmt (vect_dump, SSA_NAME_DEF_STMT (vec_def), 0, TDF_SLIM);\n@@ -2056,6 +2056,10 @@ vect_get_vec_def_for_stmt_copy (enum vect_def_type dt, tree vec_oprnd)\n   vec_stmt_for_operand = STMT_VINFO_RELATED_STMT (def_stmt_info);\n   gcc_assert (vec_stmt_for_operand);\n   vec_oprnd = gimple_get_lhs (vec_stmt_for_operand);\n+  if (gimple_code (vec_stmt_for_operand) == GIMPLE_PHI)\n+    vec_oprnd = PHI_RESULT (vec_stmt_for_operand);\n+  else\n+    vec_oprnd = gimple_get_lhs (vec_stmt_for_operand);\n   return vec_oprnd;\n }\n \n@@ -2251,6 +2255,11 @@ get_initial_def_for_reduction (gimple stmt, tree init_val, tree *adjustment_def)\n   \n    VECT_DEF is a vector of partial results. \n    REDUC_CODE is the tree-code for the epilog reduction.\n+   NCOPIES is > 1 in case the vectorization factor (VF) is bigger than the\n+     number of elements that we can fit in a vectype (nunits). In this case\n+     we have to generate more than one vector stmt - i.e - we need to \"unroll\"\n+     the vector stmt by a factor VF/nunits.  For more details see documentation\n+     in vectorizable_operation.\n    STMT is the scalar reduction stmt that is being vectorized.\n    REDUCTION_PHI is the phi-node that carries the reduction computation.\n \n@@ -2294,18 +2303,20 @@ get_initial_def_for_reduction (gimple stmt, tree init_val, tree *adjustment_def)\n \n static void\n vect_create_epilog_for_reduction (tree vect_def, gimple stmt,\n+\t\t\t\t  int ncopies,\n \t\t\t\t  enum tree_code reduc_code,\n \t\t\t\t  gimple reduction_phi)\n {\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+  stmt_vec_info prev_phi_info;\n   tree vectype;\n   enum machine_mode mode;\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   basic_block exit_bb;\n   tree scalar_dest;\n   tree scalar_type;\n-  gimple new_phi;\n+  gimple new_phi = NULL, phi;\n   gimple_stmt_iterator exit_gsi;\n   tree vec_dest;\n   tree new_temp = NULL_TREE;\n@@ -2316,7 +2327,7 @@ vect_create_epilog_for_reduction (tree vect_def, gimple stmt,\n   tree bitsize, bitpos, bytesize; \n   enum tree_code code = gimple_assign_rhs_code (stmt);\n   tree adjustment_def;\n-  tree vec_initial_def;\n+  tree vec_initial_def, def;\n   tree orig_name;\n   imm_use_iterator imm_iter;\n   use_operand_p use_p;\n@@ -2326,7 +2337,8 @@ vect_create_epilog_for_reduction (tree vect_def, gimple stmt,\n   gimple use_stmt;\n   bool nested_in_vect_loop = false;\n   VEC(gimple,heap) *phis = NULL;\n-  int i;\n+  enum vect_def_type dt = vect_unknown_def_type;\n+  int j, i;\n   \n   if (nested_in_vect_loop_p (loop, stmt))\n     {\n@@ -2356,25 +2368,34 @@ vect_create_epilog_for_reduction (tree vect_def, gimple stmt,\n \n   /*** 1. Create the reduction def-use cycle  ***/\n   \n-  /* 1.1 set the loop-entry arg of the reduction-phi:  */\n   /* For the case of reduction, vect_get_vec_def_for_operand returns\n      the scalar def before the loop, that defines the initial value\n      of the reduction variable.  */\n   vec_initial_def = vect_get_vec_def_for_operand (reduction_op, stmt,\n \t\t\t\t\t\t  &adjustment_def);\n-  add_phi_arg (reduction_phi, vec_initial_def, loop_preheader_edge (loop));\n-\n-  /* 1.2 set the loop-latch arg for the reduction-phi:  */\n-  add_phi_arg (reduction_phi, vect_def, loop_latch_edge (loop));\n \n-  if (vect_print_dump_info (REPORT_DETAILS))\n+  phi = reduction_phi;\n+  def = vect_def;\n+  for (j = 0; j < ncopies; j++)\n     {\n-      fprintf (vect_dump, \"transform reduction: created def-use cycle:\");\n-      print_gimple_stmt (vect_dump, reduction_phi, 0, TDF_SLIM);\n-      fprintf (vect_dump, \"\\n\");\n-      print_gimple_stmt (vect_dump, SSA_NAME_DEF_STMT (vect_def), 0, TDF_SLIM);\n-    }\n+      /* 1.1 set the loop-entry arg of the reduction-phi:  */\n+      add_phi_arg (phi, vec_initial_def, loop_preheader_edge (loop));\n+\n+      /* 1.2 set the loop-latch arg for the reduction-phi:  */\n+      if (j > 0)\n+        def = vect_get_vec_def_for_stmt_copy (dt, def);\n+      add_phi_arg (phi, def, loop_latch_edge (loop));\n \n+      if (vect_print_dump_info (REPORT_DETAILS))\n+\t{\n+\t  fprintf (vect_dump, \"transform reduction: created def-use cycle: \");\n+\t  print_gimple_stmt (vect_dump, phi, 0, TDF_SLIM);\n+\t  fprintf (vect_dump, \"\\n\");\n+\t  print_gimple_stmt (vect_dump, SSA_NAME_DEF_STMT (def), 0, TDF_SLIM);\n+\t}\n+\n+      phi = STMT_VINFO_RELATED_STMT (vinfo_for_stmt (phi));\n+    }\n \n   /*** 2. Create epilog code\n \t  The reduction epilog code operates across the elements of the vector\n@@ -2398,7 +2419,7 @@ vect_create_epilog_for_reduction (tree vect_def, gimple stmt,\n           s_out3 = extract_field <v_out2, 0>    # step 2\n           s_out4 = adjust_result <s_out3>       # step 3\n \n-          (step 3 is optional, and step2 1 and 2 may be combined).\n+          (step 3 is optional, and steps 1 and 2 may be combined).\n           Lastly, the uses of s_out0 are replaced by s_out4.\n \n \t  ***/\n@@ -2407,8 +2428,22 @@ vect_create_epilog_for_reduction (tree vect_def, gimple stmt,\n         v_out1 = phi <v_loop>  */\n \n   exit_bb = single_exit (loop)->dest;\n-  new_phi = create_phi_node (SSA_NAME_VAR (vect_def), exit_bb);\n-  SET_PHI_ARG_DEF (new_phi, single_exit (loop)->dest_idx, vect_def);\n+  def = vect_def;\n+  prev_phi_info = NULL;\n+  for (j = 0; j < ncopies; j++)\n+    {\n+      phi = create_phi_node (SSA_NAME_VAR (vect_def), exit_bb);\n+      set_vinfo_for_stmt (phi, new_stmt_vec_info (phi, loop_vinfo));\n+      if (j == 0)\n+\tnew_phi = phi;\n+      else\n+\t{\n+\t  def = vect_get_vec_def_for_stmt_copy (dt, def);\n+\t  STMT_VINFO_RELATED_STMT (prev_phi_info) = phi;\n+\t}\n+      SET_PHI_ARG_DEF (phi, single_exit (loop)->dest_idx, def);\n+      prev_phi_info = vinfo_for_stmt (phi);\n+    }\n   exit_gsi = gsi_after_labels (exit_bb);\n \n   /* 2.2 Get the relevant tree-code to use in the epilog for schemes 2,3 \n@@ -2449,6 +2484,9 @@ vect_create_epilog_for_reduction (tree vect_def, gimple stmt,\n   if (nested_in_vect_loop)\n     goto vect_finalize_reduction;\n \n+  /* FORNOW */\n+  gcc_assert (ncopies = 1);\n+\n   /* 2.3 Create the reduction code, using one of the three schemes described\n          above.  */\n \n@@ -2664,15 +2702,19 @@ vect_create_epilog_for_reduction (tree vect_def, gimple stmt,\n \t{\n \t  stmt_vec_info stmt_vinfo = vinfo_for_stmt (exit_phi);\n \n-\t  /* FORNOW. Currently not supporting the case that an inner-loop reduction\n-\t     is not used in the outer-loop (but only outside the outer-loop).  */\n+\t  /* FORNOW. Currently not supporting the case that an inner-loop\n+\t     reduction is not used in the outer-loop (but only outside the\n+\t     outer-loop).  */\n \t  gcc_assert (STMT_VINFO_RELEVANT_P (stmt_vinfo) \n \t\t      && !STMT_VINFO_LIVE_P (stmt_vinfo));\n \n-\t  epilog_stmt = adjustment_def ? epilog_stmt :  new_phi;\n+\t  epilog_stmt = adjustment_def ? epilog_stmt : new_phi;\n \t  STMT_VINFO_VEC_STMT (stmt_vinfo) = epilog_stmt;\n-\t  set_vinfo_for_stmt (epilog_stmt,\n+\t  set_vinfo_for_stmt (epilog_stmt, \n \t\t\t      new_stmt_vec_info (epilog_stmt, loop_vinfo));\n+\t  if (adjustment_def)\n+\t    STMT_VINFO_RELATED_STMT (vinfo_for_stmt (epilog_stmt)) =\n+\t\tSTMT_VINFO_RELATED_STMT (vinfo_for_stmt (new_phi));\n \t  continue;\n \t}\n \n@@ -2745,7 +2787,7 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n   tree def;\n   gimple def_stmt;\n   enum vect_def_type dt;\n-  gimple new_phi;\n+  gimple new_phi = NULL;\n   tree scalar_type;\n   bool is_simple_use;\n   gimple orig_stmt;\n@@ -2754,23 +2796,17 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n   int i;\n   int nunits = TYPE_VECTOR_SUBPARTS (vectype);\n   int ncopies = LOOP_VINFO_VECT_FACTOR (loop_vinfo) / nunits;\n-  stmt_vec_info prev_stmt_info;\n+  int epilog_copies;\n+  stmt_vec_info prev_stmt_info, prev_phi_info;\n+  gimple first_phi = NULL;\n+  bool single_defuse_cycle = false;\n   tree reduc_def;\n   gimple new_stmt = NULL;\n   int j;\n   tree ops[3];\n \n   if (nested_in_vect_loop_p (loop, stmt))\n-    {\n-      loop = loop->inner;\n-      /* FORNOW. This restriction should be relaxed.  */\n-      if (ncopies > 1)\n-\t{\n-\t  if (vect_print_dump_info (REPORT_DETAILS))\n-\t    fprintf (vect_dump, \"multiple types in nested loop.\");\n-\t  return false;\n-\t}\n-    }\n+    loop = loop->inner;\n \n   gcc_assert (ncopies >= 1);\n \n@@ -3004,18 +3040,52 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n   /* Create the destination vector  */\n   vec_dest = vect_create_destination_var (scalar_dest, vectype);\n \n-  /* Create the reduction-phi that defines the reduction-operand.  */\n-  new_phi = create_phi_node (vec_dest, loop->header);\n-\n   /* In case the vectorization factor (VF) is bigger than the number\n      of elements that we can fit in a vectype (nunits), we have to generate\n      more than one vector stmt - i.e - we need to \"unroll\" the\n      vector stmt by a factor VF/nunits.  For more details see documentation\n      in vectorizable_operation.  */\n \n+  /* If the reduction is used in an outer loop we need to generate\n+     VF intermediate results, like so (e.g. for ncopies=2):\n+\tr0 = phi (init, r0)\n+\tr1 = phi (init, r1)\n+\tr0 = x0 + r0;\n+        r1 = x1 + r1;\n+    (i.e. we generate VF results in 2 registers).\n+    In this case we have a separate def-use cycle for each copy, and therefore\n+    for each copy we get the vector def for the reduction variable from the\n+    respective phi node created for this copy.\n+\n+    Otherwise (the reduction is unused in the loop nest), we can combine\n+    together intermediate results, like so (e.g. for ncopies=2):\n+\tr = phi (init, r)\n+\tr = x0 + r;\n+\tr = x1 + r;\n+   (i.e. we generate VF/2 results in a single register).\n+   In this case for each copy we get the vector def for the reduction variable\n+   from the vectorized reduction operation generated in the previous iteration.\n+  */\n+\n+  if (STMT_VINFO_RELEVANT (stmt_info) == vect_unused_in_loop)\n+    {\n+      single_defuse_cycle = true;\n+      epilog_copies = 1;\n+    }\n+  else\n+    epilog_copies = ncopies;\n+\n   prev_stmt_info = NULL;\n+  prev_phi_info = NULL;\n   for (j = 0; j < ncopies; j++)\n     {\n+      if (j == 0 || !single_defuse_cycle)\n+\t{\n+\t  /* Create the reduction-phi that defines the reduction-operand.  */\n+\t  new_phi = create_phi_node (vec_dest, loop->header);\n+\t  set_vinfo_for_stmt (new_phi, new_stmt_vec_info (new_phi, loop_vinfo));\n+\t}\n+\n       /* Handle uses.  */\n       if (j == 0)\n         {\n@@ -3027,6 +3097,7 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n \n           /* Get the vector def for the reduction variable from the phi node */\n           reduc_def = PHI_RESULT (new_phi);\n+\t  first_phi = new_phi;\n         }\n       else\n         {\n@@ -3035,9 +3106,12 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n           if (op_type == ternary_op)\n             loop_vec_def1 = vect_get_vec_def_for_stmt_copy (dt, loop_vec_def1);\n \n-          /* Get the vector def for the reduction variable from the vectorized\n-             reduction operation generated in the previous iteration (j-1)  */\n-\t  reduc_def = gimple_assign_lhs (new_stmt);\n+\t  if (single_defuse_cycle)\n+\t    reduc_def = gimple_assign_lhs (new_stmt);\n+\t  else\n+\t    reduc_def = PHI_RESULT (new_phi);\n+\n+\t  STMT_VINFO_RELATED_STMT (prev_phi_info) = new_phi;\n         }\n \n       /* Arguments are ready. create the new vector stmt.  */\n@@ -3056,11 +3130,15 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n       else\n \tSTMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt;\n       prev_stmt_info = vinfo_for_stmt (new_stmt);\n+      prev_phi_info = vinfo_for_stmt (new_phi);\n     }\n \n   /* Finalize the reduction-phi (set it's arguments) and create the\n      epilog reduction code.  */\n-  vect_create_epilog_for_reduction (new_temp, stmt, epilog_reduc_code, new_phi);\n+  if (!single_defuse_cycle)\n+    new_temp = gimple_assign_lhs (*vec_stmt);\n+  vect_create_epilog_for_reduction (new_temp, stmt, epilog_copies,\n+\t\t\t\t    epilog_reduc_code, first_phi);\n   return true;\n }\n \n@@ -3108,7 +3186,6 @@ vectorizable_call (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt)\n   int nunits_in;\n   int nunits_out;\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n-  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   tree fndecl, new_temp, def, rhs_type, lhs_type;\n   gimple def_stmt;\n   enum vect_def_type dt[2] = {vect_unknown_def_type, vect_unknown_def_type};\n@@ -3212,14 +3289,6 @@ vectorizable_call (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt)\n      needs to be generated.  */\n   gcc_assert (ncopies >= 1);\n \n-  /* FORNOW. This restriction should be relaxed.  */\n-  if (nested_in_vect_loop_p (loop, stmt) && ncopies > 1)\n-    {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-      fprintf (vect_dump, \"multiple types in nested loop.\");\n-      return false;\n-    }\n-\n   if (!vec_stmt) /* transformation not required.  */\n     {\n       STMT_VINFO_TYPE (stmt_info) = call_vec_info_type;\n@@ -3234,14 +3303,6 @@ vectorizable_call (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt)\n   if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"transform operation.\");\n \n-  /* FORNOW. This restriction should be relaxed.  */\n-  if (nested_in_vect_loop_p (loop, stmt) && ncopies > 1)\n-    {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-        fprintf (vect_dump, \"multiple types in nested loop.\");\n-      return false;\n-    }\n-\n   /* Handle def.  */\n   scalar_dest = gimple_call_lhs (stmt);\n   vec_dest = vect_create_destination_var (scalar_dest, vectype_out);\n@@ -3436,7 +3497,6 @@ vectorizable_conversion (gimple stmt, gimple_stmt_iterator *gsi,\n   tree vec_oprnd0 = NULL_TREE, vec_oprnd1 = NULL_TREE;\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n-  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   enum tree_code code, code1 = ERROR_MARK, code2 = ERROR_MARK;\n   tree decl1 = NULL_TREE, decl2 = NULL_TREE;\n   tree new_temp;\n@@ -3527,14 +3587,6 @@ vectorizable_conversion (gimple stmt, gimple_stmt_iterator *gsi,\n      needs to be generated.  */\n   gcc_assert (ncopies >= 1);\n \n-  /* FORNOW. This restriction should be relaxed.  */\n-  if (nested_in_vect_loop_p (loop, stmt) && ncopies > 1)\n-    {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-      fprintf (vect_dump, \"multiple types in nested loop.\");\n-      return false;\n-    }\n-\n   /* Check the operands of the operation.  */\n   if (!vect_is_simple_use (op0, loop_vinfo, &def_stmt, &def, &dt[0]))\n     {\n@@ -3847,11 +3899,19 @@ vectorizable_induction (gimple phi, gimple_stmt_iterator *gsi ATTRIBUTE_UNUSED,\n   stmt_vec_info stmt_info = vinfo_for_stmt (phi);\n   tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n+  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   int nunits = TYPE_VECTOR_SUBPARTS (vectype);\n   int ncopies = LOOP_VINFO_VECT_FACTOR (loop_vinfo) / nunits;\n   tree vec_def;\n \n   gcc_assert (ncopies >= 1);\n+  /* FORNOW. This restriction should be relaxed.  */\n+  if (nested_in_vect_loop_p (loop, phi) && ncopies > 1)\n+    {\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+        fprintf (vect_dump, \"multiple types in nested loop.\");\n+      return false;\n+    }\n \n   if (!STMT_VINFO_RELEVANT_P (stmt_info))\n     return false;\n@@ -3903,7 +3963,6 @@ vectorizable_operation (gimple stmt, gimple_stmt_iterator *gsi,\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n-  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   enum tree_code code;\n   enum machine_mode vec_mode;\n   tree new_temp;\n@@ -3932,13 +3991,6 @@ vectorizable_operation (gimple stmt, gimple_stmt_iterator *gsi,\n   if (slp_node)\n     ncopies = 1;\n   gcc_assert (ncopies >= 1);\n-  /* FORNOW. This restriction should be relaxed.  */\n-  if (nested_in_vect_loop_p (loop, stmt) && ncopies > 1)\n-    {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-        fprintf (vect_dump, \"multiple types in nested loop.\");\n-      return false;\n-    }\n \n   if (!STMT_VINFO_RELEVANT_P (stmt_info))\n     return false;\n@@ -4257,7 +4309,6 @@ vectorizable_type_demotion (gimple stmt, gimple_stmt_iterator *gsi,\n   tree vec_oprnd0=NULL, vec_oprnd1=NULL;\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n-  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   enum tree_code code, code1 = ERROR_MARK;\n   tree new_temp;\n   tree def;\n@@ -4310,13 +4361,6 @@ vectorizable_type_demotion (gimple stmt, gimple_stmt_iterator *gsi,\n \n   ncopies = LOOP_VINFO_VECT_FACTOR (loop_vinfo) / nunits_out;\n   gcc_assert (ncopies >= 1);\n-  /* FORNOW. This restriction should be relaxed.  */\n-  if (nested_in_vect_loop_p (loop, stmt) && ncopies > 1)\n-    {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-        fprintf (vect_dump, \"multiple types in nested loop.\");\n-      return false;\n-    }\n \n   if (! ((INTEGRAL_TYPE_P (TREE_TYPE (scalar_dest))\n \t  && INTEGRAL_TYPE_P (TREE_TYPE (op0)))\n@@ -4458,7 +4502,6 @@ vectorizable_type_promotion (gimple stmt, gimple_stmt_iterator *gsi,\n   tree vec_oprnd0=NULL, vec_oprnd1=NULL;\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n-  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   enum tree_code code, code1 = ERROR_MARK, code2 = ERROR_MARK;\n   tree decl1 = NULL_TREE, decl2 = NULL_TREE;\n   int op_type; \n@@ -4511,13 +4554,6 @@ vectorizable_type_promotion (gimple stmt, gimple_stmt_iterator *gsi,\n \n   ncopies = LOOP_VINFO_VECT_FACTOR (loop_vinfo) / nunits_in;\n   gcc_assert (ncopies >= 1);\n-  /* FORNOW. This restriction should be relaxed.  */\n-  if (nested_in_vect_loop_p (loop, stmt) && ncopies > 1)\n-    {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-        fprintf (vect_dump, \"multiple types in nested loop.\");\n-      return false;\n-    }\n \n   if (! ((INTEGRAL_TYPE_P (TREE_TYPE (scalar_dest))\n \t  && INTEGRAL_TYPE_P (TREE_TYPE (op0)))"}]}