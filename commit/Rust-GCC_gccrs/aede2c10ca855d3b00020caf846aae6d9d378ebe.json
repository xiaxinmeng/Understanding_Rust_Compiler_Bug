{"sha": "aede2c10ca855d3b00020caf846aae6d9d378ebe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWVkZTJjMTBjYTg1NWQzYjAwMDIwY2FmODQ2YWFlNmQ5ZDM3OGViZQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2014-05-24T22:00:14Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2014-05-24T22:00:14Z"}, "message": "tree-core.h (tree_decl_with_vis): Replace comdat_group by symtab_node pointer.\n\n\t* tree-core.h (tree_decl_with_vis): Replace comdat_group by\n\tsymtab_node pointer.\n\t* tree.c (copy_node_stat): Be sure tonot copy\n\tsymtab_node pointer.\n\t(find_decls_types_r): Do not walk COMDAT_GROUP.\n\t* tree.h (DECL_COMDAT_GROUP): Revamp to use decl_comdat_group.\n\t* varasm.c (make_decl_one_only): Use set_comdat_group;\n\tcreate node if needed.\n\t* ipa-inline-transform.c (save_inline_function_body): Update\n\tway we decl->symtab mapping.\n\t* symtab.c (symtab_hash, hash_node, eq_node\n\tsymtab_insert_node_to_hashtable): Remove.\n\t(symtab_register_node): Update.\n\t(symtab_unregister_node): Update.\n\t(symtab_get_node): Reimplement as inline function.\n\t(symtab_add_to_same_comdat_group): Update.\n\t(symtab_dissolve_same_comdat_group_list): Update.\n\t(dump_symtab_base): Update.\n\t(verify_symtab_base): Update.\n\t(symtab_make_decl_local): Update.\n\t(fixup_same_cpp_alias_visibility): Update.\n\t(symtab_nonoverwritable_alias): Update.\n\t* cgraphclones.c (set_new_clone_decl_and_node_flags): Update.\n\t* ipa.c (update_visibility_by_resolution_info): UPdate.\n\t* bb-reorder.c: Include cgraph.h\n\t* lto-streamer-out.c (DFS_write_tree_body, hash_tree): Do not deal\n\twith comdat groups.\n\t* ipa-comdats.c (set_comdat_group, ipa_comdats): Update.\n\t* cgraph.c (cgraph_get_create_node): Update.\n\t* cgraph.h (struct symtab_node): Add get_comdat_group, set_comdat_group\n\tand comdat_group_.\n\t(symtab_get_node): Make inline.\n\t(symtab_insert_node_to_hashtable): Remove.\n\t(symtab_can_be_discarded): Update.\n\t(decl_comdat_group): New function.\n\t* tree-streamer-in.c (lto_input_ts_decl_with_vis_tree_pointers): Update.\n\t* lto-cgraph.c (lto_output_node, lto_output_varpool_node): Stream out\n\tcomdat group name.\n\t(read_comdat_group): New function.\n\t(input_node, input_varpool_node): Use it.\n\t* trans-mem.c (ipa_tm_create_version_alias): Update code creating\n\tcomdat groups.\n\t* mips.c (mips_start_unique_function): Likewise.\n\t(ix86_code_end): Likewise.\n\t(rs6000_code_end): Likweise.\n\t* tree-streamer-out.c (DECL_COMDAT_GROUP): Do not stream\n\tcomdat group.\n\n\t* lto-symtab.c (lto_symtab_merge_symbols): Update code setting\n\tsymtab pointer.\n\t* lto.c (compare_tree_sccs_1): Do not compare comdat groups.\n\n\t* optmize.c (maybe_thunk_body): Use set_comdat_group.\n\t(maybe_clone_body): Likewise.\n\t* decl.c (duplicate_decls): Update code duplicating comdat group;\n\tdo not copy symtab pointer; before freeing newdecl remove it\n\tfrom symtab.\n\t* decl2.c (constrain_visibility): Use set_comdat_group.\n\n\t* c-decl.c (merge_decls): Preserve symtab node pointers.\n\t(duplicate_decls): Free new decl.\n\nFrom-SVN: r210901", "tree": {"sha": "12ca2f5d9d68edce3aad0e13eb2c2fb693d94c86", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/12ca2f5d9d68edce3aad0e13eb2c2fb693d94c86"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aede2c10ca855d3b00020caf846aae6d9d378ebe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aede2c10ca855d3b00020caf846aae6d9d378ebe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aede2c10ca855d3b00020caf846aae6d9d378ebe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aede2c10ca855d3b00020caf846aae6d9d378ebe/comments", "author": null, "committer": null, "parents": [{"sha": "f3de79d43a924e3984ab3299ac7a38f5a4aabdf5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3de79d43a924e3984ab3299ac7a38f5a4aabdf5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f3de79d43a924e3984ab3299ac7a38f5a4aabdf5"}], "stats": {"total": 525, "additions": 350, "deletions": 175}, "files": [{"sha": "09f014a759103722b61d7ddcc6b6982eff5744ed", "filename": "gcc/ChangeLog", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aede2c10ca855d3b00020caf846aae6d9d378ebe/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aede2c10ca855d3b00020caf846aae6d9d378ebe/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=aede2c10ca855d3b00020caf846aae6d9d378ebe", "patch": "@@ -1,3 +1,53 @@\n+2014-05-23  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* tree-core.h (tree_decl_with_vis): Replace comdat_group by\n+\tsymtab_node pointer.\n+\t* tree.c (copy_node_stat): Be sure tonot copy\n+\tsymtab_node pointer.\n+\t(find_decls_types_r): Do not walk COMDAT_GROUP.\n+\t* tree.h (DECL_COMDAT_GROUP): Revamp to use decl_comdat_group.\n+\t* varasm.c (make_decl_one_only): Use set_comdat_group;\n+\tcreate node if needed.\n+\t* ipa-inline-transform.c (save_inline_function_body): Update\n+\tway we decl->symtab mapping.\n+\t* symtab.c (symtab_hash, hash_node, eq_node\n+\tsymtab_insert_node_to_hashtable): Remove.\n+\t(symtab_register_node): Update.\n+\t(symtab_unregister_node): Update.\n+\t(symtab_get_node): Reimplement as inline function.\n+\t(symtab_add_to_same_comdat_group): Update.\n+\t(symtab_dissolve_same_comdat_group_list): Update.\n+\t(dump_symtab_base): Update.\n+\t(verify_symtab_base): Update.\n+\t(symtab_make_decl_local): Update.\n+\t(fixup_same_cpp_alias_visibility): Update.\n+\t(symtab_nonoverwritable_alias): Update.\n+\t* cgraphclones.c (set_new_clone_decl_and_node_flags): Update.\n+\t* ipa.c (update_visibility_by_resolution_info): UPdate.\n+\t* bb-reorder.c: Include cgraph.h\n+\t* lto-streamer-out.c (DFS_write_tree_body, hash_tree): Do not deal\n+\twith comdat groups.\n+\t* ipa-comdats.c (set_comdat_group, ipa_comdats): Update.\n+\t* cgraph.c (cgraph_get_create_node): Update.\n+\t* cgraph.h (struct symtab_node): Add get_comdat_group, set_comdat_group\n+\tand comdat_group_.\n+\t(symtab_get_node): Make inline.\n+\t(symtab_insert_node_to_hashtable): Remove.\n+\t(symtab_can_be_discarded): Update.\n+\t(decl_comdat_group): New function.\n+\t* tree-streamer-in.c (lto_input_ts_decl_with_vis_tree_pointers): Update.\n+\t* lto-cgraph.c (lto_output_node, lto_output_varpool_node): Stream out\n+\tcomdat group name.\n+\t(read_comdat_group): New function.\n+\t(input_node, input_varpool_node): Use it.\n+\t* trans-mem.c (ipa_tm_create_version_alias): Update code creating\n+\tcomdat groups.\n+\t* mips.c (mips_start_unique_function): Likewise.\n+\t(ix86_code_end): Likewise.\n+\t(rs6000_code_end): Likweise.\n+\t* tree-streamer-out.c (DECL_COMDAT_GROUP): Do not stream\n+\tcomdat group.\n+\n 2014-05-23  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* gengtype-state.c (fatal_reading_state): Bring offline."}, {"sha": "61b0caba8b8c84bd620fff08be4b6b1f41ec90ee", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aede2c10ca855d3b00020caf846aae6d9d378ebe/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aede2c10ca855d3b00020caf846aae6d9d378ebe/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=aede2c10ca855d3b00020caf846aae6d9d378ebe", "patch": "@@ -99,6 +99,7 @@\n #include \"tree-pass.h\"\n #include \"df.h\"\n #include \"bb-reorder.h\"\n+#include \"cgraph.h\"\n #include \"except.h\"\n \n /* The number of rounds.  In most cases there will only be 4 rounds, but"}, {"sha": "dc4a653d50877f04b2616383d7a07653e6f829b2", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aede2c10ca855d3b00020caf846aae6d9d378ebe/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aede2c10ca855d3b00020caf846aae6d9d378ebe/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=aede2c10ca855d3b00020caf846aae6d9d378ebe", "patch": "@@ -1,3 +1,8 @@\n+2014-05-23  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* c-decl.c (merge_decls): Preserve symtab node pointers.\n+\t(duplicate_decls): Free new decl.\n+\n 2014-05-23  Thomas Schwinge  <thomas@codesourcery.com>\n \n \t* c-typeck.c (c_finish_omp_clauses): Remove duplicated variable"}, {"sha": "e8e6bd2b221962b57c2d6d2c154b960bc63fb0e9", "filename": "gcc/c/c-decl.c", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aede2c10ca855d3b00020caf846aae6d9d378ebe/gcc%2Fc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aede2c10ca855d3b00020caf846aae6d9d378ebe/gcc%2Fc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-decl.c?ref=aede2c10ca855d3b00020caf846aae6d9d378ebe", "patch": "@@ -2507,8 +2507,18 @@ merge_decls (tree newdecl, tree olddecl, tree newtype, tree oldtype)\n     switch (TREE_CODE (olddecl))\n       {\n       case FUNCTION_DECL:\n-      case FIELD_DECL:\n       case VAR_DECL:\n+\t{\n+\t  struct symtab_node *snode = olddecl->decl_with_vis.symtab_node;\n+\n+\t  memcpy ((char *) olddecl + sizeof (struct tree_decl_common),\n+\t\t  (char *) newdecl + sizeof (struct tree_decl_common),\n+\t\t  tree_code_size (TREE_CODE (olddecl)) - sizeof (struct tree_decl_common));\n+\t  olddecl->decl_with_vis.symtab_node = snode;\n+\t  break;\n+\t}\n+\n+      case FIELD_DECL:\n       case PARM_DECL:\n       case LABEL_DECL:\n       case RESULT_DECL:\n@@ -2561,6 +2571,9 @@ duplicate_decls (tree newdecl, tree olddecl)\n     }\n \n   merge_decls (newdecl, olddecl, newtype, oldtype);\n+\n+  /* The NEWDECL will no longer be needed.  */\n+  ggc_free (newdecl);\n   return true;\n }\n "}, {"sha": "ff65b86a56781c03a0d76479c79542f1ed8d60cb", "filename": "gcc/cgraph.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aede2c10ca855d3b00020caf846aae6d9d378ebe/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aede2c10ca855d3b00020caf846aae6d9d378ebe/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=aede2c10ca855d3b00020caf846aae6d9d378ebe", "patch": "@@ -565,7 +565,7 @@ cgraph_get_create_node (tree decl)\n       first_clone->clone_of = node;\n       node->clones = first_clone;\n       symtab_prevail_in_asm_name_hash (node);\n-      symtab_insert_node_to_hashtable (node);\n+      node->decl->decl_with_vis.symtab_node = node;\n       if (dump_file)\n \tfprintf (dump_file, \"Introduced new external node \"\n \t\t \"(%s/%i) and turned into root of the clone tree.\\n\",\n@@ -2267,6 +2267,7 @@ cgraph_make_node_local_1 (struct cgraph_node *node, void *data ATTRIBUTE_UNUSED)\n       node->externally_visible = false;\n       node->forced_by_abi = false;\n       node->local.local = true;\n+      node->set_comdat_group (NULL);\n       node->unique_name = (node->resolution == LDPR_PREVAILING_DEF_IRONLY\n \t\t\t\t  || node->resolution == LDPR_PREVAILING_DEF_IRONLY_EXP);\n       node->resolution = LDPR_PREVAILING_DEF_IRONLY;"}, {"sha": "cfb2d4850fd3acb558dd83c2fb17b07ce24111e3", "filename": "gcc/cgraph.h", "status": "modified", "additions": 49, "deletions": 4, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aede2c10ca855d3b00020caf846aae6d9d378ebe/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aede2c10ca855d3b00020caf846aae6d9d378ebe/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=aede2c10ca855d3b00020caf846aae6d9d378ebe", "patch": "@@ -141,6 +141,18 @@ class GTY((desc (\"%h.type\"), tag (\"SYMTAB_SYMBOL\"),\n   /* Circular list of nodes in the same comdat group if non-NULL.  */\n   symtab_node *same_comdat_group;\n \n+  /* Return comdat group.  */\n+  tree get_comdat_group ()\n+    {\n+      return comdat_group_;\n+    }\n+\n+  /* Set comdat group.  */\n+  void set_comdat_group (tree group)\n+    {\n+      comdat_group_ = group;\n+    }\n+\n   /* Vectors of referring and referenced entities.  */\n   struct ipa_ref_list ref_list;\n \n@@ -153,6 +165,9 @@ class GTY((desc (\"%h.type\"), tag (\"SYMTAB_SYMBOL\"),\n   struct lto_file_decl_data * lto_file_data;\n \n   PTR GTY ((skip)) aux;\n+\n+  /* Comdat group the symbol is in.  Can be private if GGC allowed that.  */\n+  tree comdat_group_;\n };\n \n enum availability\n@@ -727,9 +742,7 @@ void symtab_register_node (symtab_node *);\n void symtab_unregister_node (symtab_node *);\n void symtab_remove_from_same_comdat_group (symtab_node *);\n void symtab_remove_node (symtab_node *);\n-symtab_node *symtab_get_node (const_tree);\n symtab_node *symtab_node_for_asm (const_tree asmname);\n-void symtab_insert_node_to_hashtable (symtab_node *);\n void symtab_add_to_same_comdat_group (symtab_node *, symtab_node *);\n void symtab_dissolve_same_comdat_group_list (symtab_node *node);\n void dump_symtab (FILE *);\n@@ -989,6 +1002,28 @@ void varpool_remove_initializer (varpool_node *);\n /* In cgraph.c */\n extern void change_decl_assembler_name (tree, tree);\n \n+/* Return symbol table node associated with DECL, if any,\n+   and NULL otherwise.  */\n+\n+static inline symtab_node *\n+symtab_get_node (const_tree decl)\n+{\n+#ifdef ENABLE_CHECKING\n+  /* Check that we are called for sane type of object - functions\n+     and static or external variables.  */\n+  gcc_checking_assert (TREE_CODE (decl) == FUNCTION_DECL\n+\t\t       || (TREE_CODE (decl) == VAR_DECL\n+\t\t\t   && (TREE_STATIC (decl) || DECL_EXTERNAL (decl)\n+\t\t\t       || in_lto_p)));\n+  /* Check that the mapping is sane - perhaps this check can go away,\n+     but at the moment frontends tends to corrupt the mapping by calling\n+     memcpy/memset on the tree nodes.  */\n+  gcc_checking_assert (!decl->decl_with_vis.symtab_node\n+\t\t       || decl->decl_with_vis.symtab_node->decl == decl);\n+#endif\n+  return decl->decl_with_vis.symtab_node;\n+}\n+\n /* Return callgraph node for given symbol and check it is a function. */\n static inline struct cgraph_node *\n cgraph (symtab_node *node)\n@@ -1548,7 +1583,7 @@ static inline bool\n symtab_can_be_discarded (symtab_node *node)\n {\n   return (DECL_EXTERNAL (node->decl)\n-\t  || (DECL_ONE_ONLY (node->decl)\n+\t  || (node->get_comdat_group ()\n \t      && node->resolution != LDPR_PREVAILING_DEF\n \t      && node->resolution != LDPR_PREVAILING_DEF_IRONLY\n \t      && node->resolution != LDPR_PREVAILING_DEF_IRONLY_EXP));\n@@ -1580,6 +1615,16 @@ symtab_in_same_comdat_p (symtab_node *one, symtab_node *two)\n \ttwo = cn->global.inlined_to;\n     }\n \n-  return DECL_COMDAT_GROUP (one->decl) == DECL_COMDAT_GROUP (two->decl);\n+  return one->get_comdat_group () == two->get_comdat_group ();\n+}\n+\n+/* Return comdat group of DECL.  */\n+static inline tree\n+decl_comdat_group (tree node)\n+{\n+  struct symtab_node *snode = symtab_get_node (node);\n+  if (!snode)\n+    return NULL;\n+  return snode->get_comdat_group ();\n }\n #endif  /* GCC_CGRAPH_H  */"}, {"sha": "4387b99f3af0fc8c58fe01a90706dab5e50716af", "filename": "gcc/cgraphclones.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aede2c10ca855d3b00020caf846aae6d9d378ebe/gcc%2Fcgraphclones.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aede2c10ca855d3b00020caf846aae6d9d378ebe/gcc%2Fcgraphclones.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphclones.c?ref=aede2c10ca855d3b00020caf846aae6d9d378ebe", "patch": "@@ -283,7 +283,6 @@ static void\n set_new_clone_decl_and_node_flags (cgraph_node *new_node)\n {\n   DECL_EXTERNAL (new_node->decl) = 0;\n-  DECL_COMDAT_GROUP (new_node->decl) = 0;\n   TREE_PUBLIC (new_node->decl) = 0;\n   DECL_COMDAT (new_node->decl) = 0;\n   DECL_WEAK (new_node->decl) = 0;\n@@ -558,7 +557,7 @@ cgraph_create_virtual_clone (struct cgraph_node *old_node,\n      that is not weak also.\n      ??? We cannot use COMDAT linkage because there is no\n      ABI support for this.  */\n-  if (DECL_COMDAT_GROUP (old_decl))\n+  if (old_node->get_comdat_group ())\n     DECL_SECTION_NAME (new_node->decl) = NULL;\n   set_new_clone_decl_and_node_flags (new_node);\n   new_node->clone.tree_map = tree_map;"}, {"sha": "3bd364bbaac33b7242973bcfcc8a58e086d616db", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aede2c10ca855d3b00020caf846aae6d9d378ebe/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aede2c10ca855d3b00020caf846aae6d9d378ebe/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=aede2c10ca855d3b00020caf846aae6d9d378ebe", "patch": "@@ -499,7 +499,7 @@ cgraph_add_new_function (tree fndecl, bool lowered)\n \tbreak;\n       case CGRAPH_STATE_CONSTRUCTION:\n \t/* Just enqueue function to be processed at nearest occurrence.  */\n-\tnode = cgraph_create_node (fndecl);\n+\tnode = cgraph_get_create_node (fndecl);\n \tif (lowered)\n \t  node->lowered = true;\n \tif (!cgraph_new_nodes)"}, {"sha": "0bde73241f9db04b2edac047090835d902ccfe4e", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aede2c10ca855d3b00020caf846aae6d9d378ebe/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aede2c10ca855d3b00020caf846aae6d9d378ebe/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=aede2c10ca855d3b00020caf846aae6d9d378ebe", "patch": "@@ -9183,7 +9183,7 @@ ix86_code_end (void)\n #endif\n       if (USE_HIDDEN_LINKONCE)\n \t{\n-\t  DECL_COMDAT_GROUP (decl) = DECL_ASSEMBLER_NAME (decl);\n+\t  cgraph_create_node (decl)->set_comdat_group (DECL_ASSEMBLER_NAME (decl));\n \n \t  targetm.asm_out.unique_section (decl, 0);\n \t  switch_to_section (get_named_section (decl, NULL, 0));"}, {"sha": "eefcfd24521bb0f4c1609ae504c5dbccc2742e91", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aede2c10ca855d3b00020caf846aae6d9d378ebe/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aede2c10ca855d3b00020caf846aae6d9d378ebe/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=aede2c10ca855d3b00020caf846aae6d9d378ebe", "patch": "@@ -6275,7 +6275,7 @@ mips_start_unique_function (const char *name)\n   TREE_PUBLIC (decl) = 1;\n   TREE_STATIC (decl) = 1;\n \n-  DECL_COMDAT_GROUP (decl) = DECL_ASSEMBLER_NAME (decl);\n+  cgraph_create_node (decl)->set_comdat_group (DECL_ASSEMBLER_NAME (decl));\n \n   targetm.asm_out.unique_section (decl, 0);\n   switch_to_section (get_named_section (decl, NULL, 0));"}, {"sha": "b4305dff3019ccaf0c6f6865d7e04fc4dc2c483e", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aede2c10ca855d3b00020caf846aae6d9d378ebe/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aede2c10ca855d3b00020caf846aae6d9d378ebe/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=aede2c10ca855d3b00020caf846aae6d9d378ebe", "patch": "@@ -32331,7 +32331,7 @@ rs6000_code_end (void)\n #if RS6000_WEAK\n   if (USE_HIDDEN_LINKONCE)\n     {\n-      DECL_COMDAT_GROUP (decl) = DECL_ASSEMBLER_NAME (decl);\n+      cgraph_create_node (decl)->set_comdat_group (DECL_ASSEMBLER_NAME (decl));\n       targetm.asm_out.unique_section (decl, 0);\n       switch_to_section (get_named_section (decl, NULL, 0));\n       DECL_WEAK (decl) = 1;"}, {"sha": "66eebc440a2983b2f69282188d56197f61e8d338", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aede2c10ca855d3b00020caf846aae6d9d378ebe/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aede2c10ca855d3b00020caf846aae6d9d378ebe/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=aede2c10ca855d3b00020caf846aae6d9d378ebe", "patch": "@@ -1,3 +1,12 @@\n+2014-05-23  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* optmize.c (maybe_thunk_body): Use set_comdat_group.\n+\t(maybe_clone_body): Likewise.\n+\t* decl.c (duplicate_decls): Update code duplicating comdat group;\n+\tdo not copy symtab pointer; before freeing newdecl remove it\n+\tfrom symtab.\n+\t* decl2.c (constrain_visibility): Use set_comdat_group.\n+\n 2014-05-23  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* rtti.c: Include tm_p.h"}, {"sha": "9e97ff854ce446b37e7a378ce6dd3e2ce1413039", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 39, "deletions": 3, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aede2c10ca855d3b00020caf846aae6d9d378ebe/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aede2c10ca855d3b00020caf846aae6d9d378ebe/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=aede2c10ca855d3b00020caf846aae6d9d378ebe", "patch": "@@ -2065,8 +2065,17 @@ duplicate_decls (tree newdecl, tree olddecl, bool newdecl_is_friend)\n   /* Merge the storage class information.  */\n   merge_weak (newdecl, olddecl);\n \n-  if (DECL_ONE_ONLY (olddecl))\n-    DECL_COMDAT_GROUP (newdecl) = DECL_COMDAT_GROUP (olddecl);\n+  if ((TREE_CODE (olddecl) == FUNCTION_DECL || TREE_CODE (olddecl) == VAR_DECL)\n+      && (DECL_EXTERNAL (olddecl) || TREE_PUBLIC (olddecl) || TREE_STATIC (olddecl))\n+      && DECL_ONE_ONLY (olddecl))\n+    {\n+      struct symtab_node *symbol;\n+      if (TREE_CODE (olddecl) == FUNCTION_DECL)\n+\tsymbol = cgraph_get_create_node (newdecl);\n+      else\n+\tsymbol = varpool_node_for_decl (newdecl);\n+      symbol->set_comdat_group (symtab_get_node (olddecl)->get_comdat_group ());\n+    }\n \n   DECL_DEFER_OUTPUT (newdecl) |= DECL_DEFER_OUTPUT (olddecl);\n   TREE_PUBLIC (newdecl) = TREE_PUBLIC (olddecl);\n@@ -2376,6 +2385,7 @@ duplicate_decls (tree newdecl, tree olddecl, bool newdecl_is_friend)\n   if (TREE_CODE (newdecl) == FUNCTION_DECL)\n     {\n       int function_size;\n+      struct symtab_node *snode = symtab_get_node (olddecl);\n \n       function_size = sizeof (struct tree_decl_common);\n \n@@ -2386,6 +2396,10 @@ duplicate_decls (tree newdecl, tree olddecl, bool newdecl_is_friend)\n       memcpy ((char *) olddecl + sizeof (struct tree_decl_common),\n \t      (char *) newdecl + sizeof (struct tree_decl_common),\n \t      sizeof (struct tree_function_decl) - sizeof (struct tree_decl_common));\n+\n+      /* Preserve symtab node mapping.  */\n+      olddecl->decl_with_vis.symtab_node = snode;\n+\n       if (new_template_info)\n \t/* If newdecl is a template instantiation, it is possible that\n \t   the following sequence of events has occurred:\n@@ -2415,6 +2429,7 @@ duplicate_decls (tree newdecl, tree olddecl, bool newdecl_is_friend)\n   else\n     {\n       size_t size = tree_code_size (TREE_CODE (olddecl));\n+\n       memcpy ((char *) olddecl + sizeof (struct tree_common),\n \t      (char *) newdecl + sizeof (struct tree_common),\n \t      sizeof (struct tree_decl_common) - sizeof (struct tree_common));\n@@ -2428,10 +2443,17 @@ duplicate_decls (tree newdecl, tree olddecl, bool newdecl_is_friend)\n \tcase TYPE_DECL:\n \tcase CONST_DECL:\n \t  {\n+            struct symtab_node *snode = NULL;\n+\n+            if (TREE_CODE (olddecl) == VAR_DECL\n+\t\t&& (TREE_STATIC (olddecl) || TREE_PUBLIC (olddecl) || DECL_EXTERNAL (olddecl)))\n+\t      snode = symtab_get_node (olddecl);\n \t    memcpy ((char *) olddecl + sizeof (struct tree_decl_common),\n \t\t    (char *) newdecl + sizeof (struct tree_decl_common),\n \t\t    size - sizeof (struct tree_decl_common)\n \t\t    + TREE_CODE_LENGTH (TREE_CODE (newdecl)) * sizeof (char *));\n+            if (TREE_CODE (olddecl) == VAR_DECL)\n+\t      olddecl->decl_with_vis.symtab_node = snode;\n \t  }\n \t  break;\n \tdefault:\n@@ -2466,7 +2488,21 @@ duplicate_decls (tree newdecl, tree olddecl, bool newdecl_is_friend)\n \n   /* The NEWDECL will no longer be needed.  Because every out-of-class\n      declaration of a member results in a call to duplicate_decls,\n-     freeing these nodes represents in a significant savings.  */\n+     freeing these nodes represents in a significant savings.\n+\n+     Before releasing the node, be sore to remove function from symbol\n+     table that might have been inserted there to record comdat group.\n+     Be sure to however do not free DECL_STRUCT_FUNCTION becuase this\n+     structure is shared in between newdecl and oldecl.  */\n+  if (TREE_CODE (newdecl) == FUNCTION_DECL)\n+    DECL_STRUCT_FUNCTION (newdecl) = NULL;\n+  if (TREE_CODE (newdecl) == FUNCTION_DECL\n+      || TREE_CODE (newdecl) == VAR_DECL)\n+    {\n+      struct symtab_node *snode = symtab_get_node (newdecl);\n+      if (snode)\n+\tsymtab_remove_node (snode);\n+    }\n   ggc_free (newdecl);\n \n   return olddecl;"}, {"sha": "de3499904d38bafbee99f4a3aaa98b37a3b73d20", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aede2c10ca855d3b00020caf846aae6d9d378ebe/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aede2c10ca855d3b00020caf846aae6d9d378ebe/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=aede2c10ca855d3b00020caf846aae6d9d378ebe", "patch": "@@ -2093,7 +2093,14 @@ constrain_visibility (tree decl, int visibility, bool tmpl)\n \t  TREE_PUBLIC (decl) = 0;\n \t  DECL_WEAK (decl) = 0;\n \t  DECL_COMMON (decl) = 0;\n-\t  DECL_COMDAT_GROUP (decl) = NULL_TREE;\n+\t  if (TREE_CODE (decl) == FUNCTION_DECL\n+\t      || TREE_CODE (decl) == VAR_DECL)\n+\t    {\n+\t      struct symtab_node *snode = symtab_get_node (decl);\n+\n+\t      if (snode)\n+\t        snode->set_comdat_group (NULL);\n+\t    }\n \t  DECL_INTERFACE_KNOWN (decl) = 1;\n \t  if (DECL_LANG_SPECIFIC (decl))\n \t    DECL_NOT_REALLY_EXTERN (decl) = 1;"}, {"sha": "a58565cd8fda890d14396c887303b5a99864bfba", "filename": "gcc/cp/optimize.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aede2c10ca855d3b00020caf846aae6d9d378ebe/gcc%2Fcp%2Foptimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aede2c10ca855d3b00020caf846aae6d9d378ebe/gcc%2Fcp%2Foptimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Foptimize.c?ref=aede2c10ca855d3b00020caf846aae6d9d378ebe", "patch": "@@ -285,7 +285,7 @@ maybe_thunk_body (tree fn, bool force)\n   else if (HAVE_COMDAT_GROUP)\n     {\n       tree comdat_group = cdtor_comdat_group (fns[1], fns[0]);\n-      DECL_COMDAT_GROUP (fns[0]) = comdat_group;\n+      cgraph_get_create_node (fns[0])->set_comdat_group (comdat_group);\n       symtab_add_to_same_comdat_group (cgraph_get_create_node (fns[1]),\n \t\t\t\t       cgraph_get_create_node (fns[0]));\n       symtab_add_to_same_comdat_group (symtab_get_node (fn),\n@@ -473,7 +473,7 @@ maybe_clone_body (tree fn)\n \t name of fn was corrupted by write_mangled_name by adding *INTERNAL*\n \t to it. By doing so, it also corrupted the comdat group. */\n       if (DECL_ONE_ONLY (fn))\n-\tDECL_COMDAT_GROUP (clone) = cxx_comdat_group (clone);\n+\tcgraph_get_create_node (clone)->set_comdat_group (cxx_comdat_group (clone));\n       DECL_SECTION_NAME (clone) = DECL_SECTION_NAME (fn);\n       DECL_USE_TEMPLATE (clone) = DECL_USE_TEMPLATE (fn);\n       DECL_EXTERNAL (clone) = DECL_EXTERNAL (fn);\n@@ -550,7 +550,7 @@ maybe_clone_body (tree fn)\n \t\t into the same, *[CD]5* comdat group instead of\n \t\t *[CD][12]*.  */\n \t      comdat_group = cdtor_comdat_group (fns[1], fns[0]);\n-\t      DECL_COMDAT_GROUP (fns[0]) = comdat_group;\n+\t      cgraph_get_create_node (fns[0])->set_comdat_group (comdat_group);\n \t      symtab_add_to_same_comdat_group (symtab_get_node (clone),\n \t\t\t\t\t       symtab_get_node (fns[0]));\n \t    }"}, {"sha": "41e27fd42ab431ee97b517a929f62996a7831f8e", "filename": "gcc/ipa-comdats.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aede2c10ca855d3b00020caf846aae6d9d378ebe/gcc%2Fipa-comdats.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aede2c10ca855d3b00020caf846aae6d9d378ebe/gcc%2Fipa-comdats.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-comdats.c?ref=aede2c10ca855d3b00020caf846aae6d9d378ebe", "patch": "@@ -202,8 +202,8 @@ set_comdat_group (symtab_node *symbol,\n {\n   symtab_node *head = (symtab_node *)head_p;\n \n-  gcc_assert (!DECL_COMDAT_GROUP (symbol->decl));\n-  DECL_COMDAT_GROUP (symbol->decl) = DECL_COMDAT_GROUP (head->decl);\n+  gcc_assert (!symbol->get_comdat_group ());\n+  symbol->set_comdat_group (head->get_comdat_group ());\n   symtab_add_to_same_comdat_group (symbol, head);\n   return false;\n }\n@@ -218,6 +218,7 @@ ipa_comdats (void)\n   symtab_node *symbol;\n   bool comdat_group_seen = false;\n   symtab_node *first = (symtab_node *) (void *) 1;\n+  tree group;\n \n   /* Start the dataflow by assigning comdat group to symbols that are in comdat\n      groups already.  All other externally visible symbols must stay, we use\n@@ -226,10 +227,10 @@ ipa_comdats (void)\n   FOR_EACH_DEFINED_SYMBOL (symbol)\n     if (!symtab_real_symbol_p (symbol))\n       ;\n-    else if (DECL_COMDAT_GROUP (symbol->decl))\n+    else if ((group = symbol->get_comdat_group ()) != NULL)\n       {\n-        *map.insert (symbol) = DECL_COMDAT_GROUP (symbol->decl);\n-        *comdat_head_map.insert (DECL_COMDAT_GROUP (symbol->decl)) = symbol;\n+        *map.insert (symbol) = group;\n+        *comdat_head_map.insert (group) = symbol;\n \tcomdat_group_seen = true;\n \n \t/* Mark the symbol so we won't waste time visiting it for dataflow.  */\n@@ -313,7 +314,7 @@ ipa_comdats (void)\n   FOR_EACH_DEFINED_SYMBOL (symbol)\n     {\n       symbol->aux = NULL; \n-      if (!DECL_COMDAT_GROUP (symbol->decl)\n+      if (!symbol->get_comdat_group ()\n \t  && !symbol->alias\n \t  && symtab_real_symbol_p (symbol))\n \t{"}, {"sha": "4cfd87b101505c1f8a53e8252be655b189560d02", "filename": "gcc/ipa-inline-transform.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aede2c10ca855d3b00020caf846aae6d9d378ebe/gcc%2Fipa-inline-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aede2c10ca855d3b00020caf846aae6d9d378ebe/gcc%2Fipa-inline-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-transform.c?ref=aede2c10ca855d3b00020caf846aae6d9d378ebe", "patch": "@@ -341,7 +341,7 @@ save_inline_function_body (struct cgraph_node *node)\n   /* first_clone will be turned into real function.  */\n   first_clone = node->clones;\n   first_clone->decl = copy_node (node->decl);\n-  symtab_insert_node_to_hashtable (first_clone);\n+  first_clone->decl->decl_with_vis.symtab_node = first_clone;\n   gcc_assert (first_clone == cgraph_get_node (first_clone->decl));\n \n   /* Now reshape the clone tree, so all other clones descends from"}, {"sha": "b0cc6d5887a74ef75ada142c142026edf2b2e99f", "filename": "gcc/ipa.c", "status": "modified", "additions": 28, "deletions": 7, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aede2c10ca855d3b00020caf846aae6d9d378ebe/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aede2c10ca855d3b00020caf846aae6d9d378ebe/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=aede2c10ca855d3b00020caf846aae6d9d378ebe", "patch": "@@ -1021,13 +1021,13 @@ update_visibility_by_resolution_info (symtab_node * node)\n     for (symtab_node *next = node->same_comdat_group;\n \t next != node; next = next->same_comdat_group)\n       {\n-\tDECL_COMDAT_GROUP (next->decl) = NULL;\n+\tnext->set_comdat_group (NULL);\n \tDECL_WEAK (next->decl) = false;\n \tif (next->externally_visible\n \t    && !define)\n \t  DECL_EXTERNAL (next->decl) = true;\n       }\n-  DECL_COMDAT_GROUP (node->decl) = NULL;\n+  node->set_comdat_group (NULL);\n   DECL_WEAK (node->decl) = false;\n   if (!define)\n     DECL_EXTERNAL (node->decl) = true;\n@@ -1135,18 +1135,21 @@ function_and_variable_visibility (bool whole_program)\n \t\t     next != node;\n \t\t     next = next->same_comdat_group)\n \t\t{\n+\t\t  next->set_comdat_group (NULL);\n \t\t  symtab_make_decl_local (next->decl);\n \t\t  next->unique_name = ((next->resolution == LDPR_PREVAILING_DEF_IRONLY\n \t\t\t\t\t|| next->unique_name\n \t\t\t\t\t|| next->resolution == LDPR_PREVAILING_DEF_IRONLY_EXP)\n-\t\t\t\t\t&& TREE_PUBLIC (next->decl));\n+\t\t\t\t       && TREE_PUBLIC (next->decl));\n \t\t}\n \t      /* cgraph_externally_visible_p has already checked all other nodes\n \t         in the group and they will all be made local.  We need to\n \t         dissolve the group at once so that the predicate does not\n \t         segfault though. */\n \t      symtab_dissolve_same_comdat_group_list (node);\n \t    }\n+\t  if (TREE_PUBLIC (node->decl))\n+\t    node->set_comdat_group (NULL);\n \t  symtab_make_decl_local (node->decl);\n \t}\n \n@@ -1163,8 +1166,7 @@ function_and_variable_visibility (bool whole_program)\n \t    {\n \t      gcc_checking_assert (DECL_COMDAT (node->decl)\n \t\t\t\t   == DECL_COMDAT (decl_node->decl));\n-\t      gcc_checking_assert (DECL_COMDAT_GROUP (node->decl)\n-\t\t\t\t   == DECL_COMDAT_GROUP (decl_node->decl));\n+\t      gcc_checking_assert (symtab_in_same_comdat_p (node, decl_node));\n \t      gcc_checking_assert (node->same_comdat_group);\n \t    }\n \t  node->forced_by_abi = decl_node->forced_by_abi;\n@@ -1254,9 +1256,28 @@ function_and_variable_visibility (bool whole_program)\n \t  vnode->unique_name = ((vnode->resolution == LDPR_PREVAILING_DEF_IRONLY\n \t\t\t\t       || vnode->resolution == LDPR_PREVAILING_DEF_IRONLY_EXP)\n \t\t\t\t       && TREE_PUBLIC (vnode->decl));\n+\t  if (vnode->same_comdat_group && TREE_PUBLIC (vnode->decl))\n+\t    {\n+\t      symtab_node *next = vnode;\n+\n+\t      /* Set all members of comdat group local.  */\n+\t      if (vnode->same_comdat_group)\n+\t\tfor (next = vnode->same_comdat_group;\n+\t\t     next != vnode;\n+\t\t     next = next->same_comdat_group)\n+\t\t{\n+\t\t  next->set_comdat_group (NULL);\n+\t\t  symtab_make_decl_local (next->decl);\n+\t\t  next->unique_name = ((next->resolution == LDPR_PREVAILING_DEF_IRONLY\n+\t\t\t\t\t|| next->unique_name\n+\t\t\t\t\t|| next->resolution == LDPR_PREVAILING_DEF_IRONLY_EXP)\n+\t\t\t\t       && TREE_PUBLIC (next->decl));\n+\t\t}\n+\t      symtab_dissolve_same_comdat_group_list (vnode);\n+\t    }\n+\t  if (TREE_PUBLIC (vnode->decl))\n+\t    vnode->set_comdat_group (NULL);\n \t  symtab_make_decl_local (vnode->decl);\n-\t  if (vnode->same_comdat_group)\n-\t    symtab_dissolve_same_comdat_group_list (vnode);\n \t  vnode->resolution = LDPR_PREVAILING_DEF_IRONLY;\n \t}\n       update_visibility_by_resolution_info (vnode);"}, {"sha": "4f8d5b701ff9a34d0b7029f8ed3621fda93b3f23", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 79, "deletions": 20, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aede2c10ca855d3b00020caf846aae6d9d378ebe/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aede2c10ca855d3b00020caf846aae6d9d378ebe/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=aede2c10ca855d3b00020caf846aae6d9d378ebe", "patch": "@@ -395,6 +395,8 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n   ipa_opt_pass_d *pass;\n   int i;\n   bool alias_p;\n+  const char *comdat;\n+  tree group;\n \n   boundary_p = !lto_symtab_encoder_in_partition_p (encoder, node);\n \n@@ -478,15 +480,24 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n       streamer_write_hwi_stream (ob->main_stream, ref);\n     }\n \n-  if (node->same_comdat_group && !boundary_p)\n+  group = node->get_comdat_group ();\n+  if (group)\n+    comdat = IDENTIFIER_POINTER (group);\n+  else\n+    comdat = \"\";\n+  lto_output_data_stream (ob->main_stream, comdat, strlen (comdat) + 1);\n+  if (group)\n     {\n-      ref = lto_symtab_encoder_lookup (encoder,\n-\t\t\t\t       node->same_comdat_group);\n-      gcc_assert (ref != LCC_NOT_FOUND);\n+      if (node->same_comdat_group && !boundary_p)\n+\t{\n+\t  ref = lto_symtab_encoder_lookup (encoder,\n+\t\t\t\t\t   node->same_comdat_group);\n+\t  gcc_assert (ref != LCC_NOT_FOUND);\n+\t}\n+      else\n+\tref = LCC_NOT_FOUND;\n+      streamer_write_hwi_stream (ob->main_stream, ref);\n     }\n-  else\n-    ref = LCC_NOT_FOUND;\n-  streamer_write_hwi_stream (ob->main_stream, ref);\n \n   streamer_write_hwi_stream (ob->main_stream, node->tp_first_run);\n \n@@ -551,6 +562,8 @@ lto_output_varpool_node (struct lto_simple_output_block *ob, varpool_node *node,\n   struct bitpack_d bp;\n   int ref;\n   bool alias_p;\n+  const char *comdat;\n+  tree group;\n \n   streamer_write_enum (ob->main_stream, LTO_symtab_tags, LTO_symtab_last_tag,\n \t\t       LTO_symtab_variable);\n@@ -587,15 +600,24 @@ lto_output_varpool_node (struct lto_simple_output_block *ob, varpool_node *node,\n \t  /* in_other_partition.  */\n     }\n   streamer_write_bitpack (&bp);\n-  if (node->same_comdat_group && !boundary_p)\n+  group = node->get_comdat_group ();\n+  if (group)\n+    comdat = IDENTIFIER_POINTER (group);\n+  else\n+    comdat = \"\";\n+  lto_output_data_stream (ob->main_stream, comdat, strlen (comdat) + 1);\n+  if (group)\n     {\n-      ref = lto_symtab_encoder_lookup (encoder,\n-\t\t\t\t       node->same_comdat_group);\n-      gcc_assert (ref != LCC_NOT_FOUND);\n+      if (node->same_comdat_group && !boundary_p)\n+\t{\n+\t  ref = lto_symtab_encoder_lookup (encoder,\n+\t\t\t\t\t   node->same_comdat_group);\n+\t  gcc_assert (ref != LCC_NOT_FOUND);\n+\t}\n+      else\n+\tref = LCC_NOT_FOUND;\n+      streamer_write_hwi_stream (ob->main_stream, ref);\n     }\n-  else\n-    ref = LCC_NOT_FOUND;\n-  streamer_write_hwi_stream (ob->main_stream, ref);\n   streamer_write_enum (ob->main_stream, ld_plugin_symbol_resolution,\n \t\t       LDPR_NUM_KNOWN, node->resolution);\n }\n@@ -946,6 +968,26 @@ output_symtab (void)\n   output_refs (encoder);\n }\n \n+/* Return COMDAT_GROUP encoded in IB as a plain string.  */\n+\n+static tree\n+read_comdat_group (struct lto_input_block *ib)\n+{\n+  unsigned int len = strnlen (ib->data + ib->p, ib->len - ib->p - 1);\n+  tree group;\n+\n+  if (ib->data[ib->p + len])\n+    lto_section_overrun (ib);\n+  if (!len)\n+    {\n+      ib->p++;\n+      return NULL;\n+    }\n+  group = get_identifier (ib->data + ib->p);\n+  ib->p += len + 1;\n+  return group;\n+}\n+\n /* Overwrite the information in NODE based on FILE_DATA, TAG, FLAGS,\n    STACK_SIZE, SELF_TIME and SELF_SIZE.  This is called either to initialize\n    NODE or to replace the values in it, for instance because the first\n@@ -1034,6 +1076,7 @@ input_node (struct lto_file_decl_data *file_data,\n   int clone_ref;\n   int order;\n   int i, count;\n+  tree group;\n \n   order = streamer_read_hwi (ib) + order_base;\n   clone_ref = streamer_read_hwi (ib);\n@@ -1079,7 +1122,9 @@ input_node (struct lto_file_decl_data *file_data,\n   if (tag == LTO_symtab_analyzed_node)\n     ref = streamer_read_hwi (ib);\n \n-  ref2 = streamer_read_hwi (ib);\n+  group = read_comdat_group (ib);\n+  if (group)\n+    ref2 = streamer_read_hwi (ib);\n \n   /* Make sure that we have not read this node before.  Nodes that\n      have already been read will have their tag stored in the 'aux'\n@@ -1098,8 +1143,14 @@ input_node (struct lto_file_decl_data *file_data,\n   /* Store a reference for now, and fix up later to be a pointer.  */\n   node->global.inlined_to = (cgraph_node_ptr) (intptr_t) ref;\n \n-  /* Store a reference for now, and fix up later to be a pointer.  */\n-  node->same_comdat_group = (symtab_node *) (intptr_t) ref2;\n+  if (group)\n+    {\n+      node->set_comdat_group (group);\n+      /* Store a reference for now, and fix up later to be a pointer.  */\n+      node->same_comdat_group = (symtab_node *) (intptr_t) ref2;\n+    }\n+  else\n+    node->same_comdat_group = (symtab_node *) (intptr_t) LCC_NOT_FOUND;\n \n   if (node->thunk.thunk_p)\n     {\n@@ -1131,6 +1182,7 @@ input_varpool_node (struct lto_file_decl_data *file_data,\n   struct bitpack_d bp;\n   int ref = LCC_NOT_FOUND;\n   int order;\n+  tree group;\n \n   order = streamer_read_hwi (ib) + order_base;\n   decl_index = streamer_read_uhwi (ib);\n@@ -1168,9 +1220,16 @@ input_varpool_node (struct lto_file_decl_data *file_data,\n     }\n   if (node->alias && !node->analyzed && node->weakref)\n     node->alias_target = get_alias_symbol (node->decl);\n-  ref = streamer_read_hwi (ib);\n-  /* Store a reference for now, and fix up later to be a pointer.  */\n-  node->same_comdat_group = (symtab_node *) (intptr_t) ref;\n+  group = read_comdat_group (ib);\n+  if (group)\n+    {\n+      node->set_comdat_group (group);\n+      ref = streamer_read_hwi (ib);\n+      /* Store a reference for now, and fix up later to be a pointer.  */\n+      node->same_comdat_group = (symtab_node *) (intptr_t) ref;\n+    }\n+  else\n+    node->same_comdat_group = (symtab_node *) (intptr_t) LCC_NOT_FOUND;\n   node->resolution = streamer_read_enum (ib, ld_plugin_symbol_resolution,\n \t\t\t\t\t        LDPR_NUM_KNOWN);\n   gcc_assert (flag_ltrans"}, {"sha": "79f667649fe0178bd842b8528814d928a5fac97a", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aede2c10ca855d3b00020caf846aae6d9d378ebe/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aede2c10ca855d3b00020caf846aae6d9d378ebe/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=aede2c10ca855d3b00020caf846aae6d9d378ebe", "patch": "@@ -535,7 +535,6 @@ DFS_write_tree_body (struct output_block *ob,\n       if (DECL_ASSEMBLER_NAME_SET_P (expr))\n \tDFS_follow_tree_edge (DECL_ASSEMBLER_NAME (expr));\n       DFS_follow_tree_edge (DECL_SECTION_NAME (expr));\n-      DFS_follow_tree_edge (DECL_COMDAT_GROUP (expr));\n     }\n \n   if (CODE_CONTAINS_STRUCT (code, TS_FIELD_DECL))\n@@ -974,7 +973,6 @@ hash_tree (struct streamer_tree_cache_d *cache, tree t)\n       if (DECL_ASSEMBLER_NAME_SET_P (t))\n \tvisit (DECL_ASSEMBLER_NAME (t));\n       visit (DECL_SECTION_NAME (t));\n-      visit (DECL_COMDAT_GROUP (t));\n     }\n \n   if (CODE_CONTAINS_STRUCT (code, TS_FIELD_DECL))"}, {"sha": "f4a226b66b2a1b97f99c7ffec08a9a66d1e39057", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aede2c10ca855d3b00020caf846aae6d9d378ebe/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aede2c10ca855d3b00020caf846aae6d9d378ebe/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=aede2c10ca855d3b00020caf846aae6d9d378ebe", "patch": "@@ -1,3 +1,9 @@\n+2014-05-23  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* lto-symtab.c (lto_symtab_merge_symbols): Update code setting\n+\tsymtab pointer.\n+\t* lto.c (compare_tree_sccs_1): Do not compare comdat groups.\n+\n 2014-05-22  Thomas Schwinge  <thomas@codesourcery.com>\n \n \t* lto-lang.c (DEF_FUNCTION_TYPE_0, DEF_FUNCTION_TYPE_6)"}, {"sha": "7f48c5e9a8ea79bc9c99f91c0d49672d1972e6d0", "filename": "gcc/lto/lto-symtab.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aede2c10ca855d3b00020caf846aae6d9d378ebe/gcc%2Flto%2Flto-symtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aede2c10ca855d3b00020caf846aae6d9d378ebe/gcc%2Flto%2Flto-symtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-symtab.c?ref=aede2c10ca855d3b00020caf846aae6d9d378ebe", "patch": "@@ -644,7 +644,7 @@ lto_symtab_merge_symbols (void)\n \t\t       && cnode2 != cnode)\n \t\tcgraph_remove_node (cnode2);\n \n-\t      symtab_insert_node_to_hashtable (node);\n+\t      node->decl->decl_with_vis.symtab_node = node;\n \t    }\n \t}\n     }"}, {"sha": "e5cdfc1cf3ea6440cc98eb814816c9628d8e4160", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aede2c10ca855d3b00020caf846aae6d9d378ebe/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aede2c10ca855d3b00020caf846aae6d9d378ebe/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=aede2c10ca855d3b00020caf846aae6d9d378ebe", "patch": "@@ -1530,7 +1530,6 @@ compare_tree_sccs_1 (tree t1, tree t2, tree **map)\n \tcompare_tree_edges (DECL_ASSEMBLER_NAME (t1),\n \t\t\t    DECL_ASSEMBLER_NAME (t2));\n       compare_tree_edges (DECL_SECTION_NAME (t1), DECL_SECTION_NAME (t2));\n-      compare_tree_edges (DECL_COMDAT_GROUP (t1), DECL_COMDAT_GROUP (t2));\n     }\n \n   if (CODE_CONTAINS_STRUCT (code, TS_FIELD_DECL))"}, {"sha": "301f7e3bef801166dc3afa90604c8d54d038052f", "filename": "gcc/symtab.c", "status": "modified", "additions": 24, "deletions": 108, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aede2c10ca855d3b00020caf846aae6d9d378ebe/gcc%2Fsymtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aede2c10ca855d3b00020caf846aae6d9d378ebe/gcc%2Fsymtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsymtab.c?ref=aede2c10ca855d3b00020caf846aae6d9d378ebe", "patch": "@@ -57,8 +57,6 @@ const char * const ld_plugin_symbol_resolution_names[]=\n   \"prevailing_def_ironly_exp\"\n };\n \n-/* Hash table used to convert declarations into nodes.  */\n-static GTY((param_is (symtab_node))) htab_t symtab_hash;\n /* Hash table used to convert assembler names into nodes.  */\n static GTY((param_is (symtab_node))) htab_t assembler_name_hash;\n \n@@ -70,26 +68,6 @@ symtab_node *symtab_nodes;\n    them, to support -fno-toplevel-reorder.  */\n int symtab_order;\n \n-/* Returns a hash code for P.  */\n-\n-static hashval_t\n-hash_node (const void *p)\n-{\n-  const symtab_node *n = (const symtab_node *) p;\n-  return (hashval_t) DECL_UID (n->decl);\n-}\n-\n-\n-/* Returns nonzero if P1 and P2 are equal.  */\n-\n-static int\n-eq_node (const void *p1, const void *p2)\n-{\n-  const symtab_node *n1 = (const symtab_node *) p1;\n-  const symtab_node *n2 = (const symtab_node *) p2;\n-  return DECL_UID (n1->decl) == DECL_UID (n2->decl);\n-}\n-\n /* Hash asmnames ignoring the user specified marks.  */\n \n static hashval_t\n@@ -282,21 +260,14 @@ symtab_prevail_in_asm_name_hash (symtab_node *node)\n void\n symtab_register_node (symtab_node *node)\n {\n-  struct symtab_node key;\n-  symtab_node **slot;\n-\n   node->next = symtab_nodes;\n   node->previous = NULL;\n   if (symtab_nodes)\n     symtab_nodes->previous = node;\n   symtab_nodes = node;\n \n-  if (!symtab_hash)\n-    symtab_hash = htab_create_ggc (10, hash_node, eq_node, NULL);\n-  key.decl = node->decl;\n-  slot = (symtab_node **) htab_find_slot (symtab_hash, &key, INSERT);\n-  if (*slot == NULL)\n-    *slot = node;\n+  if (!node->decl->decl_with_vis.symtab_node)\n+    node->decl->decl_with_vis.symtab_node = node;\n \n   ipa_empty_ref_list (&node->ref_list);\n \n@@ -307,22 +278,6 @@ symtab_register_node (symtab_node *node)\n   insert_to_assembler_name_hash (node, false);\n }\n \n-/* Make NODE to be the one symtab hash is pointing to.  Used when reshaping tree\n-   of inline clones.  */\n-\n-void\n-symtab_insert_node_to_hashtable (symtab_node *node)\n-{\n-  struct symtab_node key;\n-  symtab_node **slot;\n-\n-  if (!symtab_hash)\n-    symtab_hash = htab_create_ggc (10, hash_node, eq_node, NULL);\n-  key.decl = node->decl;\n-  slot = (symtab_node **) htab_find_slot (symtab_hash, &key, INSERT);\n-  *slot = node;\n-}\n-\n /* Remove NODE from same comdat group.   */\n \n void\n@@ -349,7 +304,6 @@ symtab_remove_from_same_comdat_group (symtab_node *node)\n void\n symtab_unregister_node (symtab_node *node)\n {\n-  void **slot;\n   ipa_remove_all_references (&node->ref_list);\n   ipa_remove_all_referring (&node->ref_list);\n \n@@ -364,55 +318,20 @@ symtab_unregister_node (symtab_node *node)\n   node->next = NULL;\n   node->previous = NULL;\n \n-  slot = htab_find_slot (symtab_hash, node, NO_INSERT);\n-\n   /* During LTO symtab merging we temporarily corrupt decl to symtab node\n      hash.  */\n-  gcc_assert ((slot && *slot) || in_lto_p);\n-  if (slot && *slot && *slot == node)\n+  gcc_assert (node->decl->decl_with_vis.symtab_node || in_lto_p);\n+  if (node->decl->decl_with_vis.symtab_node == node)\n     {\n       symtab_node *replacement_node = NULL;\n       if (cgraph_node *cnode = dyn_cast <cgraph_node *> (node))\n \treplacement_node = cgraph_find_replacement_node (cnode);\n-      if (!replacement_node)\n-\thtab_clear_slot (symtab_hash, slot);\n-      else\n-\t*slot = replacement_node;\n+      node->decl->decl_with_vis.symtab_node = replacement_node;\n     }\n   if (!is_a <varpool_node *> (node) || !DECL_HARD_REGISTER (node->decl))\n     unlink_from_assembler_name_hash (node, false);\n }\n \n-/* Return symbol table node associated with DECL, if any,\n-   and NULL otherwise.  */\n-\n-symtab_node *\n-symtab_get_node (const_tree decl)\n-{\n-  symtab_node **slot;\n-  struct symtab_node key;\n-\n-#ifdef ENABLE_CHECKING\n-  /* Check that we are called for sane type of object - functions\n-     and static or external variables.  */\n-  gcc_checking_assert (TREE_CODE (decl) == FUNCTION_DECL\n-\t\t       || (TREE_CODE (decl) == VAR_DECL\n-\t\t\t   && (TREE_STATIC (decl) || DECL_EXTERNAL (decl)\n-\t\t\t       || in_lto_p)));\n-#endif\n-\n-  if (!symtab_hash)\n-    return NULL;\n-\n-  key.decl = CONST_CAST2 (tree, const_tree, decl);\n-\n-  slot = (symtab_node **) htab_find_slot (symtab_hash, &key,\n-\t\t\t\t\t NO_INSERT);\n-\n-  if (slot)\n-    return *slot;\n-  return NULL;\n-}\n \n /* Remove symtab NODE from the symbol table.  */\n \n@@ -513,11 +432,11 @@ void\n symtab_add_to_same_comdat_group (symtab_node *new_node,\n \t\t\t\t symtab_node *old_node)\n {\n-  gcc_assert (DECL_COMDAT_GROUP (old_node->decl));\n+  gcc_assert (old_node->get_comdat_group ());\n   gcc_assert (!new_node->same_comdat_group);\n   gcc_assert (new_node != old_node);\n \n-  DECL_COMDAT_GROUP (new_node->decl) = DECL_COMDAT_GROUP (old_node->decl);\n+  new_node->set_comdat_group (old_node->get_comdat_group ());\n   new_node->same_comdat_group = old_node;\n   if (!old_node->same_comdat_group)\n     old_node->same_comdat_group = new_node;\n@@ -546,10 +465,10 @@ symtab_dissolve_same_comdat_group_list (symtab_node *node)\n     {\n       next = n->same_comdat_group;\n       n->same_comdat_group = NULL;\n-      /* Clear DECL_COMDAT_GROUP for comdat locals, since\n+      /* Clear comdat_group for comdat locals, since\n          make_decl_local doesn't.  */\n       if (!TREE_PUBLIC (n->decl))\n-\tDECL_COMDAT_GROUP (n->decl) = NULL_TREE;\n+\tn->set_comdat_group (NULL);\n       n = next;\n     }\n   while (n != node);\n@@ -639,9 +558,9 @@ dump_symtab_base (FILE *f, symtab_node *node)\n     fprintf (f, \" dll_import\");\n   if (DECL_COMDAT (node->decl))\n     fprintf (f, \" comdat\");\n-  if (DECL_COMDAT_GROUP (node->decl))\n+  if (node->get_comdat_group ())\n     fprintf (f, \" comdat_group:%s\",\n-\t     IDENTIFIER_POINTER (DECL_COMDAT_GROUP (node->decl)));\n+\t     IDENTIFIER_POINTER (node->get_comdat_group ()));\n   if (DECL_ONE_ONLY (node->decl))\n     fprintf (f, \" one_only\");\n   if (DECL_SECTION_NAME (node->decl))\n@@ -766,7 +685,7 @@ verify_symtab_base (symtab_node *node)\n       hashed_node = symtab_get_node (node->decl);\n       if (!hashed_node)\n \t{\n-\t  error (\"node not found in symtab decl hashtable\");\n+\t  error (\"node not found node->decl->decl_with_vis.symtab_node\");\n \t  error_found = true;\n \t}\n       if (hashed_node != node\n@@ -775,7 +694,7 @@ verify_symtab_base (symtab_node *node)\n \t      || dyn_cast <cgraph_node *> (node)->clone_of->decl\n \t\t != node->decl))\n \t{\n-\t  error (\"node differs from symtab decl hashtable\");\n+\t  error (\"node differs from node->decl->decl_with_vis.symtab_node\");\n \t  error_found = true;\n \t}\n     }\n@@ -832,12 +751,12 @@ verify_symtab_base (symtab_node *node)\n     {\n       symtab_node *n = node->same_comdat_group;\n \n-      if (!DECL_COMDAT_GROUP (n->decl))\n+      if (!n->get_comdat_group ())\n \t{\n-\t  error (\"node is in same_comdat_group list but has no DECL_COMDAT_GROUP\");\n+\t  error (\"node is in same_comdat_group list but has no comdat_group\");\n \t  error_found = true;\n \t}\n-      if (DECL_COMDAT_GROUP (n->decl) != DECL_COMDAT_GROUP (node->same_comdat_group->decl))\n+      if (n->get_comdat_group () != node->get_comdat_group ())\n \t{\n \t  error (\"same_comdat_group list across different groups\");\n \t  error_found = true;\n@@ -950,20 +869,19 @@ symtab_make_decl_local (tree decl)\n {\n   rtx rtl, symbol;\n \n-  /* Avoid clearing DECL_COMDAT_GROUP on comdat-local decls.  */\n+  /* Avoid clearing comdat_groups on comdat-local decls.  */\n   if (TREE_PUBLIC (decl) == 0)\n     return;\n \n   if (TREE_CODE (decl) == VAR_DECL)\n     DECL_COMMON (decl) = 0;\n   else gcc_assert (TREE_CODE (decl) == FUNCTION_DECL);\n \n-  if (DECL_COMDAT_GROUP (decl) || DECL_COMDAT (decl))\n+  if (DECL_COMDAT (decl))\n     {\n       DECL_SECTION_NAME (decl) = 0;\n       DECL_COMDAT (decl) = 0;\n     }\n-  DECL_COMDAT_GROUP (decl) = 0;\n   DECL_WEAK (decl) = 0;\n   DECL_EXTERNAL (decl) = 0;\n   DECL_VISIBILITY_SPECIFIED (decl) = 0;\n@@ -1097,11 +1015,13 @@ fixup_same_cpp_alias_visibility (symtab_node *node, symtab_node *target)\n   DECL_VIRTUAL_P (node->decl) = DECL_VIRTUAL_P (target->decl);\n   if (TREE_PUBLIC (node->decl))\n     {\n+      tree group;\n+\n       DECL_EXTERNAL (node->decl) = DECL_EXTERNAL (target->decl);\n       DECL_COMDAT (node->decl) = DECL_COMDAT (target->decl);\n-      DECL_COMDAT_GROUP (node->decl)\n-\t = DECL_COMDAT_GROUP (target->decl);\n-      if (DECL_COMDAT_GROUP (target->decl)\n+      group = target->get_comdat_group ();\n+      node->set_comdat_group (group);\n+      if (group\n \t  && !node->same_comdat_group)\n \tsymtab_add_to_same_comdat_group (node, target);\n     }\n@@ -1231,9 +1151,6 @@ symtab_nonoverwritable_alias (symtab_node *node)\n \n   /* Update the properties.  */\n   DECL_EXTERNAL (new_decl) = 0;\n-  if (DECL_COMDAT_GROUP (node->decl))\n-    DECL_SECTION_NAME (new_decl) = NULL;\n-  DECL_COMDAT_GROUP (new_decl) = 0;\n   TREE_PUBLIC (new_decl) = 0;\n   DECL_COMDAT (new_decl) = 0;\n   DECL_WEAK (new_decl) = 0;\n@@ -1246,8 +1163,7 @@ symtab_nonoverwritable_alias (symtab_node *node)\n \t\t\t\t (new_decl, node->decl);\n     }\n   else\n-    new_node = varpool_create_variable_alias (new_decl,\n-\t\t\t\t\t\t\t    node->decl);\n+    new_node = varpool_create_variable_alias (new_decl, node->decl);\n   symtab_resolve_alias (new_node, node);  \n   gcc_assert (decl_binds_to_current_def_p (new_decl));\n   return new_node;"}, {"sha": "a0903e451570ff2ca72077bf86cf01d9dd66dcfb", "filename": "gcc/trans-mem.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aede2c10ca855d3b00020caf846aae6d9d378ebe/gcc%2Ftrans-mem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aede2c10ca855d3b00020caf846aae6d9d378ebe/gcc%2Ftrans-mem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftrans-mem.c?ref=aede2c10ca855d3b00020caf846aae6d9d378ebe", "patch": "@@ -4852,7 +4852,7 @@ ipa_tm_create_version_alias (struct cgraph_node *node, void *data)\n \n   /* Perform the same remapping to the comdat group.  */\n   if (DECL_ONE_ONLY (new_decl))\n-    DECL_COMDAT_GROUP (new_decl) = tm_mangle (DECL_COMDAT_GROUP (old_decl));\n+    varpool_get_node (new_decl)->set_comdat_group (tm_mangle (DECL_COMDAT_GROUP (old_decl)));\n \n   new_node = cgraph_same_body_alias (NULL, new_decl, info->new_decl);\n   new_node->tm_clone = true;\n@@ -4892,7 +4892,7 @@ ipa_tm_create_version (struct cgraph_node *old_node)\n \n   /* Perform the same remapping to the comdat group.  */\n   if (DECL_ONE_ONLY (new_decl))\n-    DECL_COMDAT_GROUP (new_decl) = tm_mangle (DECL_COMDAT_GROUP (old_decl));\n+    varpool_get_node (new_decl)->set_comdat_group (tm_mangle (DECL_COMDAT_GROUP (old_decl)));\n \n   gcc_assert (!old_node->ipa_transforms_to_apply.exists ());\n   new_node = cgraph_copy_node_for_versioning (old_node, new_decl, vNULL, NULL);"}, {"sha": "ebe584939f7231b0159f92f64c3862380330c08a", "filename": "gcc/tree-core.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aede2c10ca855d3b00020caf846aae6d9d378ebe/gcc%2Ftree-core.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aede2c10ca855d3b00020caf846aae6d9d378ebe/gcc%2Ftree-core.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-core.h?ref=aede2c10ca855d3b00020caf846aae6d9d378ebe", "patch": "@@ -1442,7 +1442,7 @@ struct GTY(()) tree_decl_with_vis {\n  struct tree_decl_with_rtl common;\n  tree assembler_name;\n  tree section_name;\n- tree comdat_group;\n+ struct symtab_node *symtab_node;\n \n  /* Belong to VAR_DECL exclusively.  */\n  unsigned defer_output : 1;"}, {"sha": "3338e327dc4e43fbd45be080907e72d095e2fa28", "filename": "gcc/tree-streamer-in.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aede2c10ca855d3b00020caf846aae6d9d378ebe/gcc%2Ftree-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aede2c10ca855d3b00020caf846aae6d9d378ebe/gcc%2Ftree-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-streamer-in.c?ref=aede2c10ca855d3b00020caf846aae6d9d378ebe", "patch": "@@ -760,7 +760,6 @@ lto_input_ts_decl_with_vis_tree_pointers (struct lto_input_block *ib,\n     }\n \n   DECL_SECTION_NAME (expr) = stream_read_tree (ib, data_in);\n-  DECL_COMDAT_GROUP (expr) = stream_read_tree (ib, data_in);\n }\n \n "}, {"sha": "6fb808e4fa0c16c439b74191a6f3fac6ab08340a", "filename": "gcc/tree-streamer-out.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aede2c10ca855d3b00020caf846aae6d9d378ebe/gcc%2Ftree-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aede2c10ca855d3b00020caf846aae6d9d378ebe/gcc%2Ftree-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-streamer-out.c?ref=aede2c10ca855d3b00020caf846aae6d9d378ebe", "patch": "@@ -662,7 +662,6 @@ write_ts_decl_with_vis_tree_pointers (struct output_block *ob, tree expr,\n     stream_write_tree (ob, NULL_TREE, false);\n \n   stream_write_tree (ob, DECL_SECTION_NAME (expr), ref_p);\n-  stream_write_tree (ob, DECL_COMDAT_GROUP (expr), ref_p);\n }\n \n "}, {"sha": "8456317011595142f1bf83eb32d28d0d147cc0c9", "filename": "gcc/tree.c", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aede2c10ca855d3b00020caf846aae6d9d378ebe/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aede2c10ca855d3b00020caf846aae6d9d378ebe/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=aede2c10ca855d3b00020caf846aae6d9d378ebe", "patch": "@@ -972,14 +972,20 @@ copy_node_stat (tree node MEM_STAT_DECL)\n \t}\n       /* DECL_DEBUG_EXPR is copied explicitely by callers.  */\n       if (TREE_CODE (node) == VAR_DECL)\n-\tDECL_HAS_DEBUG_EXPR_P (t) = 0;\n+\t{\n+\t  DECL_HAS_DEBUG_EXPR_P (t) = 0;\n+\t  t->decl_with_vis.symtab_node = NULL;\n+\t}\n       if (TREE_CODE (node) == VAR_DECL && DECL_HAS_INIT_PRIORITY_P (node))\n \t{\n \t  SET_DECL_INIT_PRIORITY (t, DECL_INIT_PRIORITY (node));\n \t  DECL_HAS_INIT_PRIORITY_P (t) = 1;\n \t}\n       if (TREE_CODE (node) == FUNCTION_DECL)\n-\tDECL_STRUCT_FUNCTION (t) = NULL;\n+\t{\n+\t  DECL_STRUCT_FUNCTION (t) = NULL;\n+\t  t->decl_with_vis.symtab_node = NULL;\n+\t}\n     }\n   else if (TREE_CODE_CLASS (code) == tcc_type)\n     {\n@@ -5238,7 +5244,6 @@ find_decls_types_r (tree *tp, int *ws, void *data)\n       else if (TREE_CODE (t) == VAR_DECL)\n \t{\n \t  fld_worklist_push (DECL_SECTION_NAME (t), fld);\n-\t  fld_worklist_push (DECL_COMDAT_GROUP (t), fld);\n \t}\n \n       if ((TREE_CODE (t) == VAR_DECL || TREE_CODE (t) == PARM_DECL)"}, {"sha": "7aeb288fc8a03b8ec0181344d9ca10d744625feb", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aede2c10ca855d3b00020caf846aae6d9d378ebe/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aede2c10ca855d3b00020caf846aae6d9d378ebe/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=aede2c10ca855d3b00020caf846aae6d9d378ebe", "patch": "@@ -2323,7 +2323,7 @@ extern void decl_value_expr_insert (tree, tree);\n   (DECL_WITH_VIS_CHECK (NODE)->decl_with_vis.comdat_flag)\n \n #define DECL_COMDAT_GROUP(NODE) \\\n-  (DECL_WITH_VIS_CHECK (NODE)->decl_with_vis.comdat_group)\n+  decl_comdat_group (NODE)\n \n /* Used in TREE_PUBLIC decls to indicate that copies of this DECL in\n    multiple translation units should be merged.  */"}, {"sha": "d72d11e7bdc34f2c9fdd434cfe1106479938f999", "filename": "gcc/varasm.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aede2c10ca855d3b00020caf846aae6d9d378ebe/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aede2c10ca855d3b00020caf846aae6d9d378ebe/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=aede2c10ca855d3b00020caf846aae6d9d378ebe", "patch": "@@ -5919,17 +5919,23 @@ supports_one_only (void)\n void\n make_decl_one_only (tree decl, tree comdat_group)\n {\n+  struct symtab_node *symbol;\n   gcc_assert (TREE_CODE (decl) == VAR_DECL\n \t      || TREE_CODE (decl) == FUNCTION_DECL);\n \n   TREE_PUBLIC (decl) = 1;\n \n+  if (TREE_CODE (decl) == VAR_DECL)\n+    symbol = varpool_node_for_decl (decl);\n+  else\n+    symbol = cgraph_get_create_node (decl);\n+\n   if (SUPPORTS_ONE_ONLY)\n     {\n #ifdef MAKE_DECL_ONE_ONLY\n       MAKE_DECL_ONE_ONLY (decl);\n #endif\n-      DECL_COMDAT_GROUP (decl) = comdat_group;\n+      symbol->set_comdat_group (comdat_group);\n     }\n   else if (TREE_CODE (decl) == VAR_DECL\n       && (DECL_INITIAL (decl) == 0 || DECL_INITIAL (decl) == error_mark_node))"}]}