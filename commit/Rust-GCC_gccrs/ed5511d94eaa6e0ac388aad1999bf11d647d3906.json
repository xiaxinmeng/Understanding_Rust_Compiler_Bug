{"sha": "ed5511d94eaa6e0ac388aad1999bf11d647d3906", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWQ1NTExZDk0ZWFhNmUwYWMzODhhYWQxOTk5YmYxMWQ2NDdkMzkwNg==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-09-10T10:19:47Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-09-10T10:19:47Z"}, "message": "cp-tree.h (language_function): Rename expanding_p to x_expanding_p.\n\n\t* cp-tree.h (language_function): Rename expanding_p to\n\tx_expanding_p.  Rename named_label_uses to x_named_label_uses.\n\t(expanding_p): Adjust accordingly.\n\t(TREE_VIA_PRIVATE): Fix typo in comment.\n\t(DECL_REFERENCE_SLOT): Remove.\n\t(SET_DECL_REFERENCE_SLOT): Likewise.\n\t* decl.c (named_label_uses): Adjust. Remove chicken comment.\n\t(push_overloaded_decl): Don't truncate the chain of bindings when\n\tadding an overloaded function.\n\t(grok_reference_init): Don't use DECL_REFERENCE_SLOT.\n\t(initialize_local_var): Fix typo in comment.\n\t(store_parm_decls): Don't set DECL_REFERENCE_SLOT.  Tidy up.\n\t* decl2.c (start_objects): Make the fact that we are expanding\n\tthe generated function right away explicit.\n\t(start_static_storage_duration_function): Likewise.\n\t(finish_file): Fix typo in comment.\n\t* init.c (build_vec_init): Correct bugs in handling cleanups.\n\t* semantics.c (maybe_convert_cond): New function.\n\t(FINISH_COND): Always store the condition, even if there's\n\ta declaration.\n\t(finish_if_stmt_cond): Use maybe_convert_cond.\n\t(finish_while_stmt_cond): Likewise.\n\t(finish_do_stmt): Likewise.\n\t(finish_for_cond): Likewise.\n\t(expand_cond): Adjust.\n\nFrom-SVN: r29265", "tree": {"sha": "1f179ea59cdecac15997a4696555b7f93716193d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1f179ea59cdecac15997a4696555b7f93716193d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ed5511d94eaa6e0ac388aad1999bf11d647d3906", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed5511d94eaa6e0ac388aad1999bf11d647d3906", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed5511d94eaa6e0ac388aad1999bf11d647d3906", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed5511d94eaa6e0ac388aad1999bf11d647d3906/comments", "author": null, "committer": null, "parents": [{"sha": "efa8eda3b85969a5da8fde4c9655547a98bbe6b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/efa8eda3b85969a5da8fde4c9655547a98bbe6b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/efa8eda3b85969a5da8fde4c9655547a98bbe6b7"}], "stats": {"total": 196, "additions": 106, "deletions": 90}, "files": [{"sha": "b242b3e67b10420a9685c0e7aff5941d0e479191", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed5511d94eaa6e0ac388aad1999bf11d647d3906/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed5511d94eaa6e0ac388aad1999bf11d647d3906/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=ed5511d94eaa6e0ac388aad1999bf11d647d3906", "patch": "@@ -1,5 +1,31 @@\n 1999-09-10  Mark Mitchell  <mark@codesourcery.com>\n \n+\t* cp-tree.h (language_function): Rename expanding_p to\n+\tx_expanding_p.  Rename named_label_uses to x_named_label_uses.\n+\t(expanding_p): Adjust accordingly.\n+\t(TREE_VIA_PRIVATE): Fix typo in comment.\n+\t(DECL_REFERENCE_SLOT): Remove.\n+\t(SET_DECL_REFERENCE_SLOT): Likewise.\n+\t* decl.c (named_label_uses): Adjust. Remove chicken comment.\n+\t(push_overloaded_decl): Don't truncate the chain of bindings when\n+\tadding an overloaded function.\n+\t(grok_reference_init): Don't use DECL_REFERENCE_SLOT.\n+\t(initialize_local_var): Fix typo in comment.\n+\t(store_parm_decls): Don't set DECL_REFERENCE_SLOT.  Tidy up.\n+\t* decl2.c (start_objects): Make the fact that we are expanding\n+\tthe generated function right away explicit.\n+\t(start_static_storage_duration_function): Likewise.\n+\t(finish_file): Fix typo in comment.\n+\t* init.c (build_vec_init): Correct bugs in handling cleanups.\n+\t* semantics.c (maybe_convert_cond): New function.\n+\t(FINISH_COND): Always store the condition, even if there's\n+\ta declaration.\n+\t(finish_if_stmt_cond): Use maybe_convert_cond.\n+\t(finish_while_stmt_cond): Likewise.\n+\t(finish_do_stmt): Likewise.\n+\t(finish_for_cond): Likewise.\n+\t(expand_cond): Adjust.\n+\t\n \t* cp-tree.h (FN_TRY_BLOCK_P): New macro.\n \t* init.c (perform_member_init): Remove obstack machinations.\n \t(expand_cleanup_for_base): Likewise."}, {"sha": "74ef7af849e3af819c1b59d0d14e243364c4ebc7", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed5511d94eaa6e0ac388aad1999bf11d647d3906/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed5511d94eaa6e0ac388aad1999bf11d647d3906/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=ed5511d94eaa6e0ac388aad1999bf11d647d3906", "patch": "@@ -634,10 +634,10 @@ struct language_function\n   int temp_name_counter;\n   int static_labelno;\n   int in_function_try_handler;\n-  int expanding_p;\n+  int x_expanding_p;\n   int stmts_are_full_exprs_p; \n \n-  struct named_label_list *named_label_uses;\n+  struct named_label_list *x_named_label_uses;\n   struct binding_level *bindings;\n };\n \n@@ -719,7 +719,7 @@ struct language_function\n    When this is zero, we just accumulate tree structure, without\n    interacting with the back end.  */\n \n-#define expanding_p cp_function_chain->expanding_p\n+#define expanding_p cp_function_chain->x_expanding_p\n \n /* Non-zero if we should treat statements as full expressions.  In\n    particular, this variable is no-zero if at the end of a statement\n@@ -1384,7 +1384,7 @@ struct lang_type\n \n    We use TREE_VIA_PROTECTED and TREE_VIA_PUBLIC, but private\n    inheritance is indicated by the absence of the other two flags, not\n-   by TREE_VIAR_PRIVATE, which is unused.\n+   by TREE_VIA_PRIVATE, which is unused.\n \n    The TREE_CHAIN is for scratch space in search.c.  */\n \n@@ -2185,11 +2185,6 @@ extern int flag_new_for_scope;\n    protected_access_node will appear in the DECL_ACCESS for the node.  */\n #define DECL_ACCESS(NODE) (DECL_LANG_SPECIFIC(NODE)->decl_flags.access)\n \n-/* C++: all of these are overloaded!\n-   These apply to PARM_DECLs and VAR_DECLs.  */\n-#define DECL_REFERENCE_SLOT(NODE) ((tree)(NODE)->decl.arguments)\n-#define SET_DECL_REFERENCE_SLOT(NODE,VAL) ((NODE)->decl.arguments=VAL)\n-\n /* Accessor macros for C++ template decl nodes.  */\n \n /* The DECL_TEMPLATE_PARMS are a list.  The TREE_PURPOSE of each node"}, {"sha": "273f455f4db8cac2efa1b65a0781df1c60b67df3", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 17, "deletions": 59, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed5511d94eaa6e0ac388aad1999bf11d647d3906/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed5511d94eaa6e0ac388aad1999bf11d647d3906/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=ed5511d94eaa6e0ac388aad1999bf11d647d3906", "patch": "@@ -338,24 +338,10 @@ struct named_label_list\n   struct named_label_list *next;\n };\n \n-/* A list (chain of TREE_LIST nodes) of named label uses.\n-   The TREE_PURPOSE field is the list of variables defined\n-   in the label's scope defined at the point of use.\n-   The TREE_VALUE field is the LABEL_DECL used.\n-   The TREE_TYPE field holds `current_binding_level' at the\n-   point of the label's use.\n+/* Used only for jumps to as-yet undefined labels, since jumps to\n+   defined labels can have their validity checked by stmt.c.  */\n \n-   BWAHAHAAHAHahhahahahaah.  No, no, no, said the little chicken.\n-\n-   Look at the pretty struct named_label_list. See the pretty struct\n-   with the pretty named fields that describe what they do. See the\n-   pretty lack of gratuitous casts. Notice the code got a lot cleaner.\n-\n-   Used only for jumps to as-yet undefined labels, since\n-   jumps to defined labels can have their validity checked\n-   by stmt.c.  */\n-\n-#define named_label_uses cp_function_chain->named_label_uses\n+#define named_label_uses cp_function_chain->x_named_label_uses\n \n /* A list of objects which have constructors or destructors\n    which reside in the global scope.  The decl is stored in\n@@ -4529,7 +4515,8 @@ push_overloaded_decl (decl, flags)\n \t\t  TREE_VALUE (*d) = new_binding;\n \t\telse\n \t\t  /* Build a TREE_LIST to wrap the OVERLOAD.  */\n-\t\t  *d = build_tree_list (NULL_TREE, new_binding);\n+\t\t  *d = tree_cons (NULL_TREE, new_binding, \n+\t\t\t\t  TREE_CHAIN (*d));\n \n \t\t/* And update the CPLUS_BINDING node.  */\n \t\tBINDING_VALUE (IDENTIFIER_BINDING (name))\n@@ -7118,19 +7105,14 @@ grok_reference_init (decl, type, init)\n       if ((DECL_LANG_SPECIFIC (decl) == 0\n \t   || DECL_IN_AGGR_P (decl) == 0)\n \t  && ! DECL_THIS_EXTERN (decl))\n-\t{\n-\t  cp_error (\"`%D' declared as reference but not initialized\", decl);\n-\t  if (TREE_CODE (decl) == VAR_DECL)\n-\t    SET_DECL_REFERENCE_SLOT (decl, error_mark_node);\n-\t}\n+\tcp_error (\"`%D' declared as reference but not initialized\", decl);\n       return;\n     }\n \n   if (init == error_mark_node)\n     return;\n \n-  if (TREE_CODE (type) == REFERENCE_TYPE\n-      && TREE_CODE (init) == CONSTRUCTOR)\n+  if (TREE_CODE (init) == CONSTRUCTOR)\n     {\n       cp_error (\"ANSI C++ forbids use of initializer list to initialize reference `%D'\", decl);\n       return;\n@@ -7154,7 +7136,7 @@ grok_reference_init (decl, type, init)\n      LOOKUP_SPECULATIVELY|LOOKUP_NORMAL|DIRECT_BIND, decl);\n \n   if (tmp == error_mark_node)\n-    goto fail;\n+    return;\n   else if (tmp != NULL_TREE)\n     {\n       init = tmp;\n@@ -7163,28 +7145,20 @@ grok_reference_init (decl, type, init)\n   else\n     {\n       cp_error (\"cannot initialize `%T' from `%T'\", type, TREE_TYPE (init));\n-      goto fail;\n+      return;\n     }\n \n   /* ?? Can this be optimized in some cases to\n      hand back the DECL_INITIAL slot??  */\n   if (TYPE_SIZE (TREE_TYPE (type)))\n-    {\n-      init = convert_from_reference (decl);\n-      SET_DECL_REFERENCE_SLOT (decl, init);\n-    }\n+    init = convert_from_reference (decl);\n \n   if (TREE_STATIC (decl) && ! TREE_CONSTANT (DECL_INITIAL (decl)))\n     {\n       expand_static_init (decl, DECL_INITIAL (decl));\n       DECL_INITIAL (decl) = NULL_TREE;\n     }\n   return;\n-\n- fail:\n-  if (TREE_CODE (decl) == VAR_DECL)\n-    SET_DECL_REFERENCE_SLOT (decl, error_mark_node);\n-  return;\n }\n \n /* Fill in DECL_INITIAL with some magical value to prevent expand_decl from\n@@ -7686,7 +7660,7 @@ maybe_inject_for_scope_var (decl)\n     }\n }\n \n-/* Generate code to initialized DECL (a local variable).  */\n+/* Generate code to initialize DECL (a local variable).  */\n \n void\n initialize_local_var (decl, init, flags)\n@@ -13342,26 +13316,7 @@ store_parm_decls ()\n \t      else if (TREE_CODE (TREE_TYPE (parm)) == VOID_TYPE)\n \t\tcp_error (\"parameter `%D' declared void\", parm);\n \t      else\n-\t\t{\n-\t\t  /* Now fill in DECL_REFERENCE_SLOT for any of the parm decls.\n-\t\t     A parameter is assumed not to have any side effects.\n-\t\t     If this should change for any reason, then this\n-\t\t     will have to wrap the bashed reference type in a save_expr.\n-\t\t     \n-\t\t     Also, if the parameter type is declared to be an X\n-\t\t     and there is an X(X&) constructor, we cannot lay it\n-\t\t     into the stack (any more), so we make this parameter\n-\t\t     look like it is really of reference type.  Functions\n-\t\t     which pass parameters to this function will know to\n-\t\t     create a temporary in their frame, and pass a reference\n-\t\t     to that.  */\n-\n-\t\t  if (TREE_CODE (TREE_TYPE (parm)) == REFERENCE_TYPE\n-\t\t      && TYPE_SIZE (TREE_TYPE (TREE_TYPE (parm))))\n-\t\t    SET_DECL_REFERENCE_SLOT (parm, convert_from_reference (parm));\n-\n-\t\t  pushdecl (parm);\n-\t\t}\n+\t\tpushdecl (parm);\n \t      if (! building_stmt_tree ()\n \t\t  && (cleanup = maybe_build_cleanup (parm), cleanup))\n \t\t{\n@@ -13418,9 +13373,12 @@ store_parm_decls ()\n      should not be called before the parm can be used.  */\n   if (cleanups && !building_stmt_tree ())\n     {\n-      for (cleanups = nreverse (cleanups); cleanups; cleanups = TREE_CHAIN (cleanups))\n+      for (cleanups = nreverse (cleanups); \n+\t   cleanups; \n+\t   cleanups = TREE_CHAIN (cleanups))\n \t{\n-\t  if (! expand_decl_cleanup (TREE_PURPOSE (cleanups), TREE_VALUE (cleanups)))\n+\t  if (! expand_decl_cleanup (TREE_PURPOSE (cleanups), \n+\t\t\t\t     TREE_VALUE (cleanups)))\n \t    cp_error (\"parser lost in parsing declaration of `%D'\",\n \t\t      TREE_PURPOSE (cleanups));\n \t}"}, {"sha": "8eed4521334bfdae61c91b650f16b7c285244d5a", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed5511d94eaa6e0ac388aad1999bf11d647d3906/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed5511d94eaa6e0ac388aad1999bf11d647d3906/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=ed5511d94eaa6e0ac388aad1999bf11d647d3906", "patch": "@@ -2819,7 +2819,7 @@ start_objects (method_type, initp)\n   start_function (void_list_node,\n \t\t  make_call_declarator (fnname, void_list_node, NULL_TREE,\n \t\t\t\t\tNULL_TREE),\n-\t\t  NULL_TREE, SF_DEFAULT);\n+\t\t  NULL_TREE, SF_DEFAULT | SF_EXPAND);\n \n #if defined(ASM_OUTPUT_CONSTRUCTOR) && defined(ASM_OUTPUT_DESTRUCTOR)\n   /* It can be a static function as long as collect2 does not have\n@@ -3008,7 +3008,7 @@ start_static_storage_duration_function ()\n   start_function (/*specs=*/NULL_TREE, \n \t\t  ssdf_decl,\n \t\t  /*attrs=*/NULL_TREE,\n-\t\t  SF_DEFAULT | SF_PRE_PARSED);\n+\t\t  SF_PRE_PARSED | SF_EXPAND);\n \n   /* Set up the scope of the outermost block in the function.  */\n   store_parm_decls ();\n@@ -3640,7 +3640,7 @@ finish_file ()\n   finish_repo ();\n \n   /* The entire file is now complete.  If requested, dump everything\n-     file.   */\n+     to a file.   */\n   if (flag_dump_translation_unit)\n     dump_node_to_file (global_namespace, flag_dump_translation_unit);\n "}, {"sha": "46e207b1d88d31cd03ddc49b3f3034f451f2d8c2", "filename": "gcc/cp/init.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed5511d94eaa6e0ac388aad1999bf11d647d3906/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed5511d94eaa6e0ac388aad1999bf11d647d3906/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=ed5511d94eaa6e0ac388aad1999bf11d647d3906", "patch": "@@ -2732,6 +2732,7 @@ build_vec_init (decl, base, maxindex, init, from_array)\n   tree compound_stmt;\n   int destroy_temps;\n   tree try_block = NULL_TREE;\n+  tree try_body;\n   int num_initialized_elts = 0;\n \n   maxindex = cp_convert (ptrdiff_type_node, maxindex);\n@@ -2796,7 +2797,10 @@ build_vec_init (decl, base, maxindex, init, from_array)\n   /* Protect the entire array initialization so that we can destroy\n      the partially constructed array if an exception is thrown.  */\n   if (flag_exceptions && TYPE_NEEDS_DESTRUCTOR (type))\n-    try_block = begin_try_block ();\n+    {\n+      try_block = begin_try_block ();\n+      try_body = begin_compound_stmt (/*has_no_scope=*/1);\n+    }\n \n   if (init != NULL_TREE && TREE_CODE (init) == CONSTRUCTOR\n       && (!decl || same_type_p (TREE_TYPE (init), TREE_TYPE (decl))))\n@@ -2991,18 +2995,15 @@ build_vec_init (decl, base, maxindex, init, from_array)\n     {\n       tree e;\n \n-      /* Because CLEANUP will not be processed until later, it must go\n-\t on the temporary obstack.  */\n-      push_obstacks_nochange ();\n-      resume_temporary_allocation ();\n+      finish_compound_stmt (/*has_no_scope=*/1, try_body);\n+      finish_cleanup_try_block (try_block);\n       e = build_vec_delete_1 (rval,\n \t\t\t      build_binary_op (MINUS_EXPR, maxindex, \n \t\t\t\t\t       iterator),\n \t\t\t      type,\n \t\t\t      /*auto_delete_vec=*/integer_zero_node,\n \t\t\t      /*auto_delete=*/integer_zero_node,\n \t\t\t      /*use_global_delete=*/0);\n-      pop_obstacks ();\n       finish_cleanup (e, try_block);\n     }\n "}, {"sha": "eaa5354b9c7c56c2800f99f73917249d30ccc1fa", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 49, "deletions": 13, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed5511d94eaa6e0ac388aad1999bf11d647d3906/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed5511d94eaa6e0ac388aad1999bf11d647d3906/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=ed5511d94eaa6e0ac388aad1999bf11d647d3906", "patch": "@@ -45,6 +45,7 @@ static void do_pushlevel PROTO((void));\n static tree do_poplevel PROTO((void));\n static void finish_expr_stmt_real PROTO((tree, int));\n static tree expand_cond PROTO((tree));\n+static tree maybe_convert_cond PROTO((tree));\n \n /* When parsing a template, LAST_TREE contains the last statement\n    parsed.  These are chained together through the TREE_CHAIN field,\n@@ -61,12 +62,19 @@ static tree expand_cond PROTO((tree));\n \n /* Finish processing the COND, the SUBSTMT condition for STMT.  */\n \n-#define FINISH_COND(cond, stmt, substmt) \t\\\n-  do {\t\t\t\t\t\t\\\n-    if (last_tree != stmt)\t\t\t\\\n-      RECHAIN_STMTS (stmt, substmt);\t        \\\n-    else\t\t\t\t\t\\\n-      substmt = cond;\t\t\t\t\\\n+#define FINISH_COND(cond, stmt, substmt) \t\t\\\n+  do {\t\t\t\t\t\t\t\\\n+    if (last_tree != stmt)\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\\\n+        RECHAIN_STMTS (stmt, substmt);\t                \\\n+        if (!processing_template_decl)                  \\\n+          {                                             \\\n+\t    cond = build_tree_list (substmt, cond);     \\\n+\t    substmt = cond;                             \\\n+          }                                             \\\n+      }\t\t\t\t\t\t\t\\\n+    else\t\t\t\t\t\t\\\n+      substmt = cond;\t\t\t\t\t\\\n   } while (0)\n   \n /* T is a statement.  Add it to the statement-tree.  */\n@@ -84,6 +92,26 @@ add_tree (t)\n     STMT_IS_FULL_EXPR_P (last_tree) = stmts_are_full_exprs_p;\n }\n \n+/* COND is the condition-expression for an if, while, etc.,\n+   statement.  Convert it to a boolean value, if appropriate.  */\n+\n+static tree\n+maybe_convert_cond (cond)\n+     tree cond;\n+{\n+  /* Empty conditions remain empty.  */\n+  if (!cond)\n+    return NULL_TREE;\n+\n+  /* Wait until we instantiate templates before doing conversion.  */\n+  if (processing_template_decl)\n+    return cond;\n+\n+  /* Do the conversion.  */\n+  cond = convert_from_reference (cond);\n+  return condition_conversion (cond);\n+}\n+\n /* Finish an expression-statement, whose EXPRESSION is as indicated.\n    If ASSIGNED_THIS is non-zero, then this statement just assigned to\n    the `this' pointer.  */\n@@ -171,12 +199,14 @@ finish_if_stmt_cond (cond, if_stmt)\n      tree cond;\n      tree if_stmt;\n {\n+  cond = maybe_convert_cond (cond);\n+\n   if (building_stmt_tree ())\n     FINISH_COND (cond, if_stmt, IF_COND (if_stmt));\n   else\n     {\n       emit_line_note (input_filename, lineno);\n-      expand_start_cond (condition_conversion (cond), 0);\n+      expand_start_cond (cond, 0);\n     }\n }\n \n@@ -263,12 +293,14 @@ finish_while_stmt_cond (cond, while_stmt)\n      tree cond;\n      tree while_stmt;\n {\n+  cond = maybe_convert_cond (cond);\n+\n   if (building_stmt_tree ())\n     FINISH_COND (cond, while_stmt, WHILE_COND (while_stmt));\n   else\n     {\n       emit_line_note (input_filename, lineno);\n-      expand_exit_loop_if_false (0, condition_conversion (cond));\n+      expand_exit_loop_if_false (0, cond);\n     }\n \n   /* If COND wasn't a declaration, clear out the\n@@ -337,12 +369,14 @@ finish_do_stmt (cond, do_stmt)\n      tree cond;\n      tree do_stmt;\n {\n+  cond = maybe_convert_cond (cond);\n+\n   if (building_stmt_tree ())\n     DO_COND (do_stmt) = cond;\n   else\n     {\n       emit_line_note (input_filename, lineno);\n-      expand_exit_loop_if_false (0, condition_conversion (cond));\n+      expand_exit_loop_if_false (0, cond);\n       expand_end_loop ();\n     }\n \n@@ -423,13 +457,15 @@ finish_for_cond (cond, for_stmt)\n      tree cond;\n      tree for_stmt;\n {\n+  cond = maybe_convert_cond (cond);\n+\n   if (building_stmt_tree ())\n     FINISH_COND (cond, for_stmt, FOR_COND (for_stmt));\n   else\n     {\n       emit_line_note (input_filename, lineno);\n       if (cond)\n-\texpand_exit_loop_if_false (0, condition_conversion (cond));\n+\texpand_exit_loop_if_false (0, cond);\n     }\n   \n   /* If the cond wasn't a declaration, clear out the\n@@ -2038,10 +2074,10 @@ static tree\n expand_cond (t)\n      tree t;\n {\n-  if (t && TREE_CODE (t) == DECL_STMT)\n+  if (t && TREE_CODE (t) == TREE_LIST)\n     {\n-      expand_stmt (t);\n-      return convert_from_reference (DECL_STMT_DECL (t));\n+      expand_stmt (TREE_PURPOSE (t));\n+      return TREE_VALUE (t);\n     }\n   else \n     return t;"}]}