{"sha": "a2b4c1882337d1a051ef667449a1a6ca061e58f1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTJiNGMxODgyMzM3ZDFhMDUxZWY2Njc0NDlhMWE2Y2EwNjFlNThmMQ==", "commit": {"author": {"name": "Kugan Vivekanandarajah", "email": "kuganv@linaro.org", "date": "2016-11-13T22:04:36Z"}, "committer": {"name": "Kugan Vivekanandarajah", "email": "kugan@gcc.gnu.org", "date": "2016-11-13T22:04:36Z"}, "message": "pr78268.C: New test.\n\ngcc/testsuite/ChangeLog:\n\n2016-11-13  Kugan Vivekanandarajah  <kuganv@linaro.org>\n\n\t* g++.dg/torture/pr78268.C: New test.\n\ngcc/ChangeLog:\n\n2016-11-13  Kugan Vivekanandarajah  <kuganv@linaro.org>\n\n\t* ipa-cp.c (ipa_get_jf_pass_through_result): Skip unary expressions.\n\t(propagate_vr_accross_jump_function): Handle unary expressions.\n\t* ipa-prop.c (ipa_set_jf_unary_pass_through): New.\n\t(load_from_param_1): New.\n\t(load_from_unmodified_param): Factor common part into load_from_param_1.\n\t(load_from_param): New.\n\t(compute_complex_assign_jump_func): Handle unary expressions.\n\t(update_jump_functions_after_inlining): Likewise.\n\t(ipa_write_jump_function): Likewise.\n\t(ipa_read_jump_function): Likewise.\n\nFrom-SVN: r242368", "tree": {"sha": "f6281d01578dfbb65bac6d07db2ad5854b01fc8f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f6281d01578dfbb65bac6d07db2ad5854b01fc8f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a2b4c1882337d1a051ef667449a1a6ca061e58f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2b4c1882337d1a051ef667449a1a6ca061e58f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a2b4c1882337d1a051ef667449a1a6ca061e58f1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2b4c1882337d1a051ef667449a1a6ca061e58f1/comments", "author": null, "committer": null, "parents": [{"sha": "1701800580852987a23d00c45c3e0d1c30b095da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1701800580852987a23d00c45c3e0d1c30b095da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1701800580852987a23d00c45c3e0d1c30b095da"}], "stats": {"total": 176, "additions": 156, "deletions": 20}, "files": [{"sha": "ed44d9cecf7bf9be7d4b041560fbb918460024d1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b4c1882337d1a051ef667449a1a6ca061e58f1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b4c1882337d1a051ef667449a1a6ca061e58f1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a2b4c1882337d1a051ef667449a1a6ca061e58f1", "patch": "@@ -1,3 +1,16 @@\n+2016-11-13  Kugan Vivekanandarajah  <kuganv@linaro.org>\n+\n+\t* ipa-cp.c (ipa_get_jf_pass_through_result): Skip unary expressions.\n+\t(propagate_vr_accross_jump_function): Handle unary expressions.\n+\t* ipa-prop.c (ipa_set_jf_unary_pass_through): New.\n+\t(load_from_param_1): New.\n+\t(load_from_unmodified_param): Factor common part into load_from_param_1.\n+\t(load_from_param): New.\n+\t(compute_complex_assign_jump_func): Handle unary expressions.\n+\t(update_jump_functions_after_inlining): Likewise.\n+\t(ipa_write_jump_function): Likewise.\n+\t(ipa_read_jump_function): Likewise.\n+\n 2016-11-13  Prathamesh Kulkarni  <prathamesh.kulkarni@linaro.org>\n \n \tPR c/35503"}, {"sha": "2ec671ffff6b3c2cef62957608d275100a5977d3", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 33, "deletions": 8, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b4c1882337d1a051ef667449a1a6ca061e58f1/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b4c1882337d1a051ef667449a1a6ca061e58f1/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=a2b4c1882337d1a051ef667449a1a6ca061e58f1", "patch": "@@ -1219,13 +1219,19 @@ ipa_get_jf_pass_through_result (struct ipa_jump_func *jfunc, tree input)\n     return NULL_TREE;\n \n   if (TREE_CODE_CLASS (ipa_get_jf_pass_through_operation (jfunc))\n-      == tcc_comparison)\n-    restype = boolean_type_node;\n+      == tcc_unary)\n+    res = fold_unary (ipa_get_jf_pass_through_operation (jfunc),\n+\t\t      TREE_TYPE (input), input);\n   else\n-    restype = TREE_TYPE (input);\n-  res = fold_binary (ipa_get_jf_pass_through_operation (jfunc), restype,\n-\t\t     input, ipa_get_jf_pass_through_operand (jfunc));\n-\n+    {\n+      if (TREE_CODE_CLASS (ipa_get_jf_pass_through_operation (jfunc))\n+\t  == tcc_comparison)\n+\trestype = boolean_type_node;\n+      else\n+\trestype = TREE_TYPE (input);\n+      res = fold_binary (ipa_get_jf_pass_through_operation (jfunc), restype,\n+\t\t\t input, ipa_get_jf_pass_through_operand (jfunc));\n+    }\n   if (res && !is_gimple_ip_invariant (res))\n     return NULL_TREE;\n \n@@ -1857,13 +1863,32 @@ propagate_vr_accross_jump_function (cgraph_edge *cs,\n   if (jfunc->type == IPA_JF_PASS_THROUGH)\n     {\n       struct ipa_node_params *caller_info = IPA_NODE_REF (cs->caller);\n-      if (dest_lat->bottom_p ())\n-\treturn false;\n       int src_idx = ipa_get_jf_pass_through_formal_id (jfunc);\n       src_lats = ipa_get_parm_lattices (caller_info, src_idx);\n \n       if (ipa_get_jf_pass_through_operation (jfunc) == NOP_EXPR)\n \treturn dest_lat->meet_with (src_lats->m_value_range);\n+      else if (param_type\n+\t       && (TREE_CODE_CLASS (ipa_get_jf_pass_through_operation (jfunc))\n+\t\t   == tcc_unary))\n+\t{\n+\t  value_range vr;\n+\t  memset (&vr, 0, sizeof (vr));\n+\t  tree operand_type = ipa_get_type (caller_info, src_idx);\n+\t  enum tree_code operation = ipa_get_jf_pass_through_operation (jfunc);\n+\n+\t  if (src_lats->m_value_range.bottom_p ())\n+\t    return dest_lat->set_to_bottom ();\n+\n+\t  extract_range_from_unary_expr (&vr,\n+\t\t\t\t\t operation,\n+\t\t\t\t\t param_type,\n+\t\t\t\t\t &src_lats->m_value_range.m_vr,\n+\t\t\t\t\t operand_type);\n+\t  if (vr.type == VR_RANGE\n+\t      || vr.type == VR_ANTI_RANGE)\n+\t    return dest_lat->meet_with (&vr);\n+\t}\n     }\n   else if (jfunc->type == IPA_JF_CONST)\n     {"}, {"sha": "6321fddb02c86738e3d0326d49d105f8529af766", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 81, "deletions": 12, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b4c1882337d1a051ef667449a1a6ca061e58f1/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b4c1882337d1a051ef667449a1a6ca061e58f1/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=a2b4c1882337d1a051ef667449a1a6ca061e58f1", "patch": "@@ -446,6 +446,18 @@ ipa_set_jf_simple_pass_through (struct ipa_jump_func *jfunc, int formal_id,\n   jfunc->value.pass_through.agg_preserved = agg_preserved;\n }\n \n+/* Set JFUNC to be an unary pass through jump function.  */\n+\n+static void\n+ipa_set_jf_unary_pass_through (struct ipa_jump_func *jfunc, int formal_id,\n+\t\t\t       enum tree_code operation)\n+{\n+  jfunc->type = IPA_JF_PASS_THROUGH;\n+  jfunc->value.pass_through.operand = NULL_TREE;\n+  jfunc->value.pass_through.formal_id = formal_id;\n+  jfunc->value.pass_through.operation = operation;\n+  jfunc->value.pass_through.agg_preserved = false;\n+}\n /* Set JFUNC to be an arithmetic pass through jump function.  */\n \n static void\n@@ -849,21 +861,19 @@ parm_preserved_before_stmt_p (struct ipa_func_body_info *fbi, int index,\n   return !modified;\n }\n \n-/* If STMT is an assignment that loads a value from an parameter declaration,\n-   return the index of the parameter in ipa_node_params which has not been\n-   modified.  Otherwise return -1.  */\n+/* Main worker for load_from_unmodified_param and load_from_param.\n+   If STMT is an assignment that loads a value from an parameter declaration,\n+   return the index of the parameter in ipa_node_params.  Otherwise return -1.  */\n \n static int\n-load_from_unmodified_param (struct ipa_func_body_info *fbi,\n-\t\t\t    vec<ipa_param_descriptor> descriptors,\n-\t\t\t    gimple *stmt)\n+load_from_param_1 (struct ipa_func_body_info *fbi,\n+\t\t   vec<ipa_param_descriptor> descriptors,\n+\t\t   gimple *stmt)\n {\n   int index;\n   tree op1;\n \n-  if (!gimple_assign_single_p (stmt))\n-    return -1;\n-\n+  gcc_checking_assert (is_gimple_assign (stmt));\n   op1 = gimple_assign_rhs1 (stmt);\n   if (TREE_CODE (op1) != PARM_DECL)\n     return -1;\n@@ -876,6 +886,40 @@ load_from_unmodified_param (struct ipa_func_body_info *fbi,\n   return index;\n }\n \n+/* If STMT is an assignment that loads a value from an parameter declaration,\n+   return the index of the parameter in ipa_node_params which has not been\n+   modified.  Otherwise return -1.  */\n+\n+static int\n+load_from_unmodified_param (struct ipa_func_body_info *fbi,\n+\t\t\t    vec<ipa_param_descriptor> descriptors,\n+\t\t\t    gimple *stmt)\n+{\n+  if (!gimple_assign_single_p (stmt))\n+    return -1;\n+\n+  return load_from_param_1 (fbi, descriptors, stmt);\n+}\n+\n+/* If STMT is an assignment that loads a value from an parameter declaration,\n+   return the index of the parameter in ipa_node_params.  Otherwise return -1.  */\n+\n+static int\n+load_from_param (struct ipa_func_body_info *fbi,\n+\t\t vec<ipa_param_descriptor> descriptors,\n+\t\t gimple *stmt)\n+{\n+  if (!is_gimple_assign (stmt))\n+    return -1;\n+\n+  enum tree_code rhs_code = gimple_assign_rhs_code (stmt);\n+  if ((get_gimple_rhs_class (rhs_code) != GIMPLE_SINGLE_RHS)\n+      && (get_gimple_rhs_class (rhs_code) != GIMPLE_UNARY_RHS))\n+    return -1;\n+\n+  return load_from_param_1 (fbi, descriptors, stmt);\n+}\n+\n /* Return true if memory reference REF (which must be a load through parameter\n    with INDEX) loads data that are known to be unmodified in this function\n    before reaching statement STMT.  */\n@@ -1109,6 +1153,7 @@ compute_complex_assign_jump_func (struct ipa_func_body_info *fbi,\n   tree op1, tc_ssa, base, ssa;\n   bool reverse;\n   int index;\n+  gimple *stmt2 = stmt;\n \n   op1 = gimple_assign_rhs1 (stmt);\n \n@@ -1117,13 +1162,16 @@ compute_complex_assign_jump_func (struct ipa_func_body_info *fbi,\n       if (SSA_NAME_IS_DEFAULT_DEF (op1))\n \tindex = ipa_get_param_decl_index (info, SSA_NAME_VAR (op1));\n       else\n-\tindex = load_from_unmodified_param (fbi, info->descriptors,\n-\t\t\t\t\t    SSA_NAME_DEF_STMT (op1));\n+\t{\n+\t  index = load_from_param (fbi, info->descriptors,\n+\t\t\t\t   SSA_NAME_DEF_STMT (op1));\n+\t  stmt2 = SSA_NAME_DEF_STMT (op1);\n+\t}\n       tc_ssa = op1;\n     }\n   else\n     {\n-      index = load_from_unmodified_param (fbi, info->descriptors, stmt);\n+      index = load_from_param (fbi, info->descriptors, stmt);\n       tc_ssa = gimple_assign_lhs (stmt);\n     }\n \n@@ -1147,6 +1195,11 @@ compute_complex_assign_jump_func (struct ipa_func_body_info *fbi,\n \t  bool agg_p = parm_ref_data_pass_through_p (fbi, index, call, tc_ssa);\n \t  ipa_set_jf_simple_pass_through (jfunc, index, agg_p);\n \t}\n+      else if (is_gimple_assign (stmt2)\n+\t       && (gimple_expr_code (stmt2) != NOP_EXPR)\n+\t       && (TREE_CODE_CLASS (gimple_expr_code (stmt2)) == tcc_unary))\n+\tipa_set_jf_unary_pass_through (jfunc, index,\n+\t\t\t\t       gimple_assign_rhs_code (stmt2));\n       return;\n     }\n \n@@ -2518,6 +2571,12 @@ update_jump_functions_after_inlining (struct cgraph_edge *cs,\n \t      dst->value.ancestor.agg_preserved &=\n \t\tsrc->value.pass_through.agg_preserved;\n \t    }\n+\t  else if (src->type == IPA_JF_PASS_THROUGH\n+\t\t   && TREE_CODE_CLASS (src->value.pass_through.operation) == tcc_unary)\n+\t    {\n+\t      dst->value.ancestor.formal_id = src->value.pass_through.formal_id;\n+\t      dst->value.ancestor.agg_preserved = false;\n+\t    }\n \t  else if (src->type == IPA_JF_ANCESTOR)\n \t    {\n \t      dst->value.ancestor.formal_id = src->value.ancestor.formal_id;\n@@ -2583,6 +2642,8 @@ update_jump_functions_after_inlining (struct cgraph_edge *cs,\n \t\t\t  && ipa_get_jf_pass_through_agg_preserved (src);\n \t\t\tipa_set_jf_simple_pass_through (dst, formal_id, agg_p);\n \t\t      }\n+\t\t    else if (TREE_CODE_CLASS (operation) == tcc_unary)\n+\t\t      ipa_set_jf_unary_pass_through (dst, formal_id, operation);\n \t\t    else\n \t\t      {\n \t\t\ttree operand = ipa_get_jf_pass_through_operand (src);\n@@ -4666,6 +4727,9 @@ ipa_write_jump_function (struct output_block *ob,\n \t  bp_pack_value (&bp, jump_func->value.pass_through.agg_preserved, 1);\n \t  streamer_write_bitpack (&bp);\n \t}\n+      else if (TREE_CODE_CLASS (jump_func->value.pass_through.operation)\n+\t       == tcc_unary)\n+\tstreamer_write_uhwi (ob, jump_func->value.pass_through.formal_id);\n       else\n \t{\n \t  stream_write_tree (ob, jump_func->value.pass_through.operand, true);\n@@ -4745,6 +4809,11 @@ ipa_read_jump_function (struct lto_input_block *ib,\n \t  bool agg_preserved = bp_unpack_value (&bp, 1);\n \t  ipa_set_jf_simple_pass_through (jump_func, formal_id, agg_preserved);\n \t}\n+      else if (TREE_CODE_CLASS (operation) == tcc_unary)\n+\t{\n+\t  int formal_id =  streamer_read_uhwi (ib);\n+\t  ipa_set_jf_unary_pass_through (jump_func, formal_id, operation);\n+\t}\n       else\n \t{\n \t  tree operand = stream_read_tree (ib, data_in);"}, {"sha": "5757bb4ca894e2f4249c27696006ca4902e58b47", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b4c1882337d1a051ef667449a1a6ca061e58f1/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b4c1882337d1a051ef667449a1a6ca061e58f1/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a2b4c1882337d1a051ef667449a1a6ca061e58f1", "patch": "@@ -1,3 +1,7 @@\n+2016-11-13  Kugan Vivekanandarajah  <kuganv@linaro.org>\n+\n+\t* g++.dg/torture/pr78268.C: New test.\n+\n 2016-11-13  Prathamesh Kulkarni  <prathamesh.kulkarni@linaro.org>\n \n \tPR c/35503"}, {"sha": "ef4547c1159a6a564ef546b608f59262d5684023", "filename": "gcc/testsuite/g++.dg/torture/pr78268.C", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b4c1882337d1a051ef667449a1a6ca061e58f1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr78268.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b4c1882337d1a051ef667449a1a6ca061e58f1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr78268.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr78268.C?ref=a2b4c1882337d1a051ef667449a1a6ca061e58f1", "patch": "@@ -0,0 +1,25 @@\n+// { dg-do compile }\n+typedef enum {} nsresult;\n+\n+struct A {\n+      virtual nsresult m_fn1(bool);\n+};\n+\n+struct B {\n+      A *operator[](int);\n+};\n+\n+struct C {\n+      nsresult m_fn2(bool);\n+        bool m_fn3(bool);\n+\t  B mDataSources;\n+};\n+nsresult C::m_fn2(bool p1)\n+{\n+  m_fn3(!p1);\n+}\n+\n+bool C::m_fn3(bool p1)\n+{\n+  mDataSources[0]->m_fn1(p1);\n+}"}]}