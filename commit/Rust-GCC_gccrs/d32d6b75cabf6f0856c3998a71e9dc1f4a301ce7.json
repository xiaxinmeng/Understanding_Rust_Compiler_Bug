{"sha": "d32d6b75cabf6f0856c3998a71e9dc1f4a301ce7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDMyZDZiNzVjYWJmNmYwODU2YzM5OThhNzFlOWRjMWY0YTMwMWNlNw==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@gmail.com", "date": "2012-07-24T05:55:50Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2012-07-24T05:55:50Z"}, "message": "re PR target/53914 (poor code generated for offset addressing on ppc32)\n\n\tPR target/53914\n\tPR target/54009\n\t* config/rs6000/constraints.md (Y): Use mem_operand_gpr.\n\t* config/rs6000/predicates.md (word_offset_memref_operand): Delete.\n\tAdjust all rs6000_legitimate_offset_address_p calls.\n\t* config/rs6000/rs6000-protos.h (mem_operand_gpr): Declare.\n\t(rs6000_secondary_reload_gpr): Declare.\n\t(rs6000_legitimate_offset_address_p): Update prototype.\n\t(rs6000_offsettable_memref_p): Delete.\n\t(rs6000_secondary_reload_ppc64): Delete.\n\t* config/rs6000/rs6000.c (address_offset): New function.\n\t(mem_operand_gpr): Likewise.\n\t(rs6000_legitimate_offset_address_p): Add worst_case param.  When\n\tnot worst_case assume class of regs with least restrictive offsets.\n\tAdjust all calls.\n\t(legitimate_lo_sum_address_p): Simplify register mode tests.\n\t(rs6000_legitimize_address): Likewise.  Assume best case offset\n\taddressing.  Combine ELF and MACHO lo_sum code.\n\t(rs6000_mode_dependent_address): Correct offset addressing limits.\n\t(rs6000_offsettable_memref_p): Make static, add reg_mode param.\n\tUse reg_mode to help rs6000_legitimate_offset_address_p.\n\t(rs6000_secondary_reload): Use address_offset.  Handle 32-bit multi\n\tgpr load/store when offset too large.\n\t(rs6000_secondary_reload_gpr): Renamed rs6000_secondary_reload_ppc64.\n\t(rs6000_split_multireg_move): Adjust rs6000_offsettable_memref_p calls.\n\t* config/rs6000/rs6000.md (movdf_hardfloat32): Use 'Y' constraint\n\tfor gpr load/store.  Order alternatives as r->Y,Y->r,r->r and\n\td->m,m->d,d->d.  Correct size of gpr load/store.\n\t(movdf_softfloat32): Use 'Y' constraint for gpr load/store.  Order\n\talternatives.\n\t(movti_ppc64): Likewise.\n\t(movdi_internal32): Likewise.  Also disparage fprs.\n\t(movdi_mfpgpr, movdi_internal64): Likewise.\n\t(movtf_internal): Use 'm' for fpr load/store.  Order alternatives.\n\t(movtf_softfloat): Order alternatives.\n\t(extenddftf2_internal): Use 'm' and 'Y' for store.\n\t(movti_power, movti_string): Use 'Y' for gpr load/store.  Order.\n\t(stack_protect_setdi, stack_protect_testdi): Likewise.\n\t(movdf_hardfloat64_mfpgpr, movdf_hardfloat64): Order alternatives.\n\t(movdf_softfloat64): Likewise.\n\t(reload_<mode>_store): Adjust reload_di_store to provide\n\treload_si_store as well.\n\t(reload_<mode>_load): Likewise.\n\nFrom-SVN: r189801", "tree": {"sha": "a2188e306ef985cd99411f93ac4e447b3007777e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a2188e306ef985cd99411f93ac4e447b3007777e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d32d6b75cabf6f0856c3998a71e9dc1f4a301ce7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d32d6b75cabf6f0856c3998a71e9dc1f4a301ce7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d32d6b75cabf6f0856c3998a71e9dc1f4a301ce7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d32d6b75cabf6f0856c3998a71e9dc1f4a301ce7/comments", "author": {"login": "amodra", "id": 6006325, "node_id": "MDQ6VXNlcjYwMDYzMjU=", "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4", "gravatar_id": "", "url": "https://api.github.com/users/amodra", "html_url": "https://github.com/amodra", "followers_url": "https://api.github.com/users/amodra/followers", "following_url": "https://api.github.com/users/amodra/following{/other_user}", "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}", "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/amodra/subscriptions", "organizations_url": "https://api.github.com/users/amodra/orgs", "repos_url": "https://api.github.com/users/amodra/repos", "events_url": "https://api.github.com/users/amodra/events{/privacy}", "received_events_url": "https://api.github.com/users/amodra/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "71922d523d7ca6373eec021d2d9578ec38e37faf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71922d523d7ca6373eec021d2d9578ec38e37faf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/71922d523d7ca6373eec021d2d9578ec38e37faf"}], "stats": {"total": 544, "additions": 319, "deletions": 225}, "files": [{"sha": "7404a62a354634778a5c1de916718ac672316553", "filename": "gcc/ChangeLog", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d32d6b75cabf6f0856c3998a71e9dc1f4a301ce7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d32d6b75cabf6f0856c3998a71e9dc1f4a301ce7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d32d6b75cabf6f0856c3998a71e9dc1f4a301ce7", "patch": "@@ -1,3 +1,49 @@\n+2012-07-24  Alan Modra  <amodra@gmail.com>\n+\n+\tPR target/53914\n+\tPR target/54009\n+\t* config/rs6000/constraints.md (Y): Use mem_operand_gpr.\n+\t* config/rs6000/predicates.md (word_offset_memref_operand): Delete.\n+\tAdjust all rs6000_legitimate_offset_address_p calls.\n+\t* config/rs6000/rs6000-protos.h (mem_operand_gpr): Declare.\n+\t(rs6000_secondary_reload_gpr): Declare.\n+\t(rs6000_legitimate_offset_address_p): Update prototype.\n+\t(rs6000_offsettable_memref_p): Delete.\n+\t(rs6000_secondary_reload_ppc64): Delete.\n+\t* config/rs6000/rs6000.c (address_offset): New function.\n+\t(mem_operand_gpr): Likewise.\n+\t(rs6000_legitimate_offset_address_p): Add worst_case param.  When\n+\tnot worst_case assume class of regs with least restrictive offsets.\n+\tAdjust all calls.\n+\t(legitimate_lo_sum_address_p): Simplify register mode tests.\n+\t(rs6000_legitimize_address): Likewise.  Assume best case offset\n+\taddressing.  Combine ELF and MACHO lo_sum code.\n+\t(rs6000_mode_dependent_address): Correct offset addressing limits.\n+\t(rs6000_offsettable_memref_p): Make static, add reg_mode param.\n+\tUse reg_mode to help rs6000_legitimate_offset_address_p.\n+\t(rs6000_secondary_reload): Use address_offset.  Handle 32-bit multi\n+\tgpr load/store when offset too large.\n+\t(rs6000_secondary_reload_gpr): Renamed rs6000_secondary_reload_ppc64.\n+\t(rs6000_split_multireg_move): Adjust rs6000_offsettable_memref_p calls.\n+\t* config/rs6000/rs6000.md (movdf_hardfloat32): Use 'Y' constraint\n+\tfor gpr load/store.  Order alternatives as r->Y,Y->r,r->r and\n+\td->m,m->d,d->d.  Correct size of gpr load/store.\n+\t(movdf_softfloat32): Use 'Y' constraint for gpr load/store.  Order\n+\talternatives.\n+\t(movti_ppc64): Likewise.\n+\t(movdi_internal32): Likewise.  Also disparage fprs.\n+\t(movdi_mfpgpr, movdi_internal64): Likewise.\n+\t(movtf_internal): Use 'm' for fpr load/store.  Order alternatives.\n+\t(movtf_softfloat): Order alternatives.\n+\t(extenddftf2_internal): Use 'm' and 'Y' for store.\n+\t(movti_power, movti_string): Use 'Y' for gpr load/store.  Order.\n+\t(stack_protect_setdi, stack_protect_testdi): Likewise.\n+\t(movdf_hardfloat64_mfpgpr, movdf_hardfloat64): Order alternatives.\n+\t(movdf_softfloat64): Likewise.\n+\t(reload_<mode>_store): Adjust reload_di_store to provide\n+\treload_si_store as well.\n+\t(reload_<mode>_load): Likewise.\n+\n 2012-07-23  Oleg Endo  <olegendo@gcc.gnu.org>\n \n \tPR target/51244"}, {"sha": "e53320e0f5a4a5e97f7d36821a26d08df13ff4f3", "filename": "gcc/config/rs6000/constraints.md", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d32d6b75cabf6f0856c3998a71e9dc1f4a301ce7/gcc%2Fconfig%2Frs6000%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d32d6b75cabf6f0856c3998a71e9dc1f4a301ce7/gcc%2Fconfig%2Frs6000%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fconstraints.md?ref=d32d6b75cabf6f0856c3998a71e9dc1f4a301ce7", "patch": "@@ -150,8 +150,9 @@ to use @samp{m} or @samp{es} in @code{asm} statements)\"\n        (match_test \"GET_CODE (XEXP (op, 0)) == REG\")))\n \n (define_memory_constraint \"Y\"\n-  \"Indexed or word-aligned displacement memory operand\"\n-  (match_operand 0 \"word_offset_memref_operand\"))\n+  \"memory operand for 8 byte and 16 byte gpr load/store\"\n+  (and (match_code \"mem\")\n+       (match_operand 0 \"mem_operand_gpr\")))\n \n (define_memory_constraint \"Z\"\n   \"Memory operand that is an indexed or indirect from a register (it is"}, {"sha": "f29d0918f58fdd5a979a649aa508a24ef1928aec", "filename": "gcc/config/rs6000/predicates.md", "status": "modified", "additions": 6, "deletions": 28, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d32d6b75cabf6f0856c3998a71e9dc1f4a301ce7/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d32d6b75cabf6f0856c3998a71e9dc1f4a301ce7/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fpredicates.md?ref=d32d6b75cabf6f0856c3998a71e9dc1f4a301ce7", "patch": "@@ -432,29 +432,6 @@\n   (and (match_operand 0 \"memory_operand\")\n        (match_test \"offsettable_nonstrict_memref_p (op)\")))\n \n-;; Return 1 if the operand is a memory operand with an address divisible by 4\n-(define_predicate \"word_offset_memref_operand\"\n-  (match_operand 0 \"memory_operand\")\n-{\n-  /* Address inside MEM.  */\n-  op = XEXP (op, 0);\n-\n-  /* Extract address from auto-inc/dec.  */\n-  if (GET_CODE (op) == PRE_INC\n-      || GET_CODE (op) == PRE_DEC)\n-    op = XEXP (op, 0);\n-  else if (GET_CODE (op) == PRE_MODIFY)\n-    op = XEXP (op, 1);\n-  else if (GET_CODE (op) == LO_SUM\n-\t   && GET_CODE (XEXP (op, 0)) == REG\n-\t   && GET_CODE (XEXP (op, 1)) == CONST)\n-    op = XEXP (XEXP (op, 1), 0);\n-\n-  return (GET_CODE (op) != PLUS\n-\t  || GET_CODE (XEXP (op, 1)) != CONST_INT\n-\t  || INTVAL (XEXP (op, 1)) % 4 == 0);\n-})\n-\n ;; Return 1 if the operand is an indexed or indirect memory operand.\n (define_predicate \"indexed_or_indirect_operand\"\n   (match_code \"mem\")\n@@ -892,7 +869,8 @@\n   return input_operand (op, mode);\n })\n \n-;; Return true if OP is an invalid SUBREG operation on the e500.\n+;; Return true if OP is a non-immediate operand and not an invalid\n+;; SUBREG operation on the e500.\n (define_predicate \"rs6000_nonimmediate_operand\"\n   (match_code \"reg,subreg,mem\")\n {\n@@ -1325,7 +1303,7 @@\n       if (base_regno == 0)\n \treturn 0;\n     }\n-  else if (rs6000_legitimate_offset_address_p (SImode, src_addr, 0))\n+  else if (rs6000_legitimate_offset_address_p (SImode, src_addr, false, false))\n     {\n       offset = INTVAL (XEXP (src_addr, 1));\n       base_regno = REGNO (XEXP (src_addr, 0));\n@@ -1353,7 +1331,7 @@\n \t  newoffset = 0;\n \t  addr_reg = newaddr;\n \t}\n-      else if (rs6000_legitimate_offset_address_p (SImode, newaddr, 0))\n+      else if (rs6000_legitimate_offset_address_p (SImode, newaddr, false, false))\n \t{\n \t  addr_reg = XEXP (newaddr, 0);\n \t  newoffset = INTVAL (XEXP (newaddr, 1));\n@@ -1400,7 +1378,7 @@\n       if (base_regno == 0)\n \treturn 0;\n     }\n-  else if (rs6000_legitimate_offset_address_p (SImode, dest_addr, 0))\n+  else if (rs6000_legitimate_offset_address_p (SImode, dest_addr, false, false))\n     {\n       offset = INTVAL (XEXP (dest_addr, 1));\n       base_regno = REGNO (XEXP (dest_addr, 0));\n@@ -1428,7 +1406,7 @@\n \t  newoffset = 0;\n \t  addr_reg = newaddr;\n \t}\n-      else if (rs6000_legitimate_offset_address_p (SImode, newaddr, 0))\n+      else if (rs6000_legitimate_offset_address_p (SImode, newaddr, false, false))\n \t{\n \t  addr_reg = XEXP (newaddr, 0);\n \t  newoffset = INTVAL (XEXP (newaddr, 1));"}, {"sha": "09c1e0ecf229bd369fc727875c6cb11ab1c7d959", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d32d6b75cabf6f0856c3998a71e9dc1f4a301ce7/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d32d6b75cabf6f0856c3998a71e9dc1f4a301ce7/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=d32d6b75cabf6f0856c3998a71e9dc1f4a301ce7", "patch": "@@ -38,6 +38,7 @@ extern bool macho_lo_sum_memory_operand (rtx, enum machine_mode);\n extern int num_insns_constant (rtx, enum machine_mode);\n extern int num_insns_constant_wide (HOST_WIDE_INT);\n extern int small_data_operand (rtx, enum machine_mode);\n+extern bool mem_operand_gpr (rtx, enum machine_mode);\n extern bool toc_relative_expr_p (const_rtx, bool);\n extern bool invalid_e500_subreg (rtx, enum machine_mode);\n extern void validate_condition_mode (enum rtx_code, enum machine_mode);\n@@ -83,7 +84,7 @@ extern bool (*rs6000_cannot_change_mode_class_ptr) (enum machine_mode,\n \t\t\t\t\t\t    enum machine_mode,\n \t\t\t\t\t\t    enum reg_class);\n extern void rs6000_secondary_reload_inner (rtx, rtx, rtx, bool);\n-extern void rs6000_secondary_reload_ppc64 (rtx, rtx, rtx, bool);\n+extern void rs6000_secondary_reload_gpr (rtx, rtx, rtx, bool);\n extern int paired_emit_vector_cond_expr (rtx, rtx, rtx,\n                                          rtx, rtx, rtx);\n extern void paired_expand_vector_move (rtx operands[]);\n@@ -121,9 +122,9 @@ extern void rs6000_emit_move (rtx, rtx, enum machine_mode);\n extern rtx rs6000_secondary_memory_needed_rtx (enum machine_mode);\n extern rtx (*rs6000_legitimize_reload_address_ptr) (rtx, enum machine_mode,\n \t\t\t\t\t\t    int, int, int, int *);\n-extern bool rs6000_legitimate_offset_address_p (enum machine_mode, rtx, int);\n+extern bool rs6000_legitimate_offset_address_p (enum machine_mode, rtx,\n+\t\t\t\t\t\tbool, bool);\n extern rtx rs6000_find_base_term (rtx);\n-extern bool rs6000_offsettable_memref_p (rtx);\n extern rtx rs6000_return_addr (int, rtx);\n extern void rs6000_output_symbol_ref (FILE*, rtx);\n extern HOST_WIDE_INT rs6000_initial_elimination_offset (int, int);"}, {"sha": "bd6a4170dd6a8a414e3e7a8b094e4bf773616154", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 177, "deletions": 109, "changes": 286, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d32d6b75cabf6f0856c3998a71e9dc1f4a301ce7/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d32d6b75cabf6f0856c3998a71e9dc1f4a301ce7/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=d32d6b75cabf6f0856c3998a71e9dc1f4a301ce7", "patch": "@@ -5017,6 +5017,64 @@ gpr_or_gpr_p (rtx op0, rtx op1)\n \t  || (REG_P (op1) && INT_REGNO_P (REGNO (op1))));\n }\n \n+/* Given an address, return a constant offset term if one exists.  */\n+\n+static rtx\n+address_offset (rtx op)\n+{\n+  if (GET_CODE (op) == PRE_INC\n+      || GET_CODE (op) == PRE_DEC)\n+    op = XEXP (op, 0);\n+  else if (GET_CODE (op) == PRE_MODIFY\n+\t   || GET_CODE (op) == LO_SUM)\n+    op = XEXP (op, 1);\n+\n+  if (GET_CODE (op) == CONST)\n+    op = XEXP (op, 0);\n+\n+  if (GET_CODE (op) == PLUS)\n+    op = XEXP (op, 1);\n+\n+  if (CONST_INT_P (op))\n+    return op;\n+\n+  return NULL_RTX;\n+}\n+\n+/* Return true if the MEM operand is a memory operand suitable for use\n+   with a (full width, possibly multiple) gpr load/store.  On\n+   powerpc64 this means the offset must be divisible by 4.\n+   Implements 'Y' constraint.\n+\n+   Accept direct, indexed, offset, lo_sum and tocref.  Since this is\n+   a constraint function we know the operand has satisfied a suitable\n+   memory predicate.  Also accept some odd rtl generated by reload\n+   (see rs6000_legitimize_reload_address for various forms).  It is\n+   important that reload rtl be accepted by appropriate constraints\n+   but not by the operand predicate.\n+\n+   Offsetting a lo_sum should not be allowed, except where we know by\n+   alignment that a 32k boundary is not crossed, but see the ???\n+   comment in rs6000_legitimize_reload_address.  */\n+\n+bool\n+mem_operand_gpr (rtx op, enum machine_mode mode)\n+{\n+  unsigned HOST_WIDE_INT offset;\n+  int extra;\n+\n+  op = address_offset (XEXP (op, 0));\n+  if (op == NULL_RTX)\n+    return true;\n+\n+  offset = INTVAL (op);\n+  extra = GET_MODE_SIZE (mode) - UNITS_PER_WORD;\n+  if (extra < 0)\n+    extra = 0;\n+  else if (TARGET_POWERPC64 && (offset & 3) != 0)\n+    return false;\n+  return offset + 0x8000 < 0x10000u - extra;\n+}\n \f\n /* Subroutines of rs6000_legitimize_address and rs6000_legitimate_address_p.  */\n \n@@ -5234,13 +5292,15 @@ legitimate_small_data_p (enum machine_mode mode, rtx x)\n #define SPE_CONST_OFFSET_OK(x) (((x) & ~0xf8) == 0)\n \n bool\n-rs6000_legitimate_offset_address_p (enum machine_mode mode, rtx x, int strict)\n+rs6000_legitimate_offset_address_p (enum machine_mode mode, rtx x,\n+\t\t\t\t    bool strict, bool worst_case)\n {\n-  unsigned HOST_WIDE_INT offset, extra;\n+  unsigned HOST_WIDE_INT offset;\n+  unsigned int extra;\n \n   if (GET_CODE (x) != PLUS)\n     return false;\n-  if (GET_CODE (XEXP (x, 0)) != REG)\n+  if (!REG_P (XEXP (x, 0)))\n     return false;\n   if (!INT_REG_OK_FOR_BASE_P (XEXP (x, 0), strict))\n     return false;\n@@ -5263,14 +5323,6 @@ rs6000_legitimate_offset_address_p (enum machine_mode mode, rtx x, int strict)\n       return SPE_CONST_OFFSET_OK (offset);\n \n     case DFmode:\n-      if (TARGET_E500_DOUBLE)\n-\treturn SPE_CONST_OFFSET_OK (offset);\n-\n-      /* If we are using VSX scalar loads, restrict ourselves to reg+reg\n-\t addressing.  */\n-      if (VECTOR_MEM_VSX_P (DFmode))\n-\treturn false;\n-\n     case DDmode:\n     case DImode:\n       /* On e500v2, we may have:\n@@ -5281,25 +5333,33 @@ rs6000_legitimate_offset_address_p (enum machine_mode mode, rtx x, int strict)\n       if (TARGET_E500_DOUBLE)\n \treturn SPE_CONST_OFFSET_OK (offset);\n \n-      if (mode == DFmode || mode == DDmode || !TARGET_POWERPC64)\n+      /* If we are using VSX scalar loads, restrict ourselves to reg+reg\n+\t addressing.  */\n+      if (mode == DFmode && VECTOR_MEM_VSX_P (DFmode))\n+\treturn false;\n+\n+      if (!worst_case)\n+\tbreak;\n+      if (!TARGET_POWERPC64)\n \textra = 4;\n       else if (offset & 3)\n \treturn false;\n       break;\n \n     case TFmode:\n+    case TDmode:\n+    case TImode:\n       if (TARGET_E500_DOUBLE)\n \treturn (SPE_CONST_OFFSET_OK (offset)\n \t\t&& SPE_CONST_OFFSET_OK (offset + 8));\n \n-    case TDmode:\n-    case TImode:\n-      if (mode == TFmode || mode == TDmode || !TARGET_POWERPC64)\n+      extra = 8;\n+      if (!worst_case)\n+\tbreak;\n+      if (!TARGET_POWERPC64)\n \textra = 12;\n       else if (offset & 3)\n \treturn false;\n-      else\n-\textra = 8;\n       break;\n \n     default:\n@@ -5379,9 +5439,7 @@ legitimate_lo_sum_address_p (enum machine_mode mode, rtx x, int strict)\n   if (!INT_REG_OK_FOR_BASE_P (XEXP (x, 0), strict))\n     return false;\n   /* Restrict addressing for DI because of our SUBREG hackery.  */\n-  if (TARGET_E500_DOUBLE && (mode == DFmode || mode == TFmode\n-\t\t\t     || mode == DDmode || mode == TDmode\n-\t\t\t     || mode == DImode))\n+  if (TARGET_E500_DOUBLE && GET_MODE_SIZE (mode) > UNITS_PER_WORD)\n     return false;\n   x = XEXP (x, 1);\n \n@@ -5393,10 +5451,10 @@ legitimate_lo_sum_address_p (enum machine_mode mode, rtx x, int strict)\n \treturn false;\n       if (GET_MODE_NUNITS (mode) != 1)\n \treturn false;\n-      if (GET_MODE_BITSIZE (mode) > 64\n-\t  || (GET_MODE_BITSIZE (mode) > 32 && !TARGET_POWERPC64\n-\t      && !(TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT\n-\t\t   && (mode == DFmode || mode == DDmode))))\n+      if (GET_MODE_SIZE (mode) > UNITS_PER_WORD\n+\t  && !(/* ??? Assume floating point reg based on mode?  */\n+\t       TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT\n+\t       && (mode == DFmode || mode == DDmode)))\n \treturn false;\n \n       return CONSTANT_P (x);\n@@ -5431,7 +5489,7 @@ static rtx\n rs6000_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n \t\t\t   enum machine_mode mode)\n {\n-  unsigned int extra = 0;\n+  unsigned int extra;\n \n   if (!reg_offset_addressing_ok_p (mode))\n     {\n@@ -5458,22 +5516,18 @@ rs6000_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n \treturn rs6000_legitimize_tls_address (x, model);\n     }\n \n+  extra = 0;\n   switch (mode)\n     {\n-    case DFmode:\n-    case DDmode:\n-      extra = 4;\n-      break;\n-    case DImode:\n-      if (!TARGET_POWERPC64)\n-\textra = 4;\n-      break;\n     case TFmode:\n     case TDmode:\n-      extra = 12;\n-      break;\n     case TImode:\n-      extra = TARGET_POWERPC64 ? 8 : 12;\n+      /* As in legitimate_offset_address_p we do not assume\n+\t worst-case.  The mode here is just a hint as to the registers\n+\t used.  A TImode is usually in gprs, but may actually be in\n+\t fprs.  Leave worst-case scenario for reload to handle via\n+\t insn constraints.  */\n+      extra = 8;\n       break;\n     default:\n       break;\n@@ -5484,13 +5538,8 @@ rs6000_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n       && GET_CODE (XEXP (x, 1)) == CONST_INT\n       && ((unsigned HOST_WIDE_INT) (INTVAL (XEXP (x, 1)) + 0x8000)\n \t  >= 0x10000 - extra)\n-      && !((TARGET_POWERPC64\n-\t    && (mode == DImode || mode == TImode)\n-\t    && (INTVAL (XEXP (x, 1)) & 3) != 0)\n-\t   || SPE_VECTOR_MODE (mode)\n-\t   || (TARGET_E500_DOUBLE && (mode == DFmode || mode == TFmode\n-\t\t\t\t      || mode == DImode || mode == DDmode\n-\t\t\t\t      || mode == TDmode))))\n+      && !(SPE_VECTOR_MODE (mode)\n+\t   || (TARGET_E500_DOUBLE && GET_MODE_SIZE (mode) > UNITS_PER_WORD)))\n     {\n       HOST_WIDE_INT high_int, low_int;\n       rtx sum;\n@@ -5506,23 +5555,17 @@ rs6000_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n \t   && GET_CODE (XEXP (x, 0)) == REG\n \t   && GET_CODE (XEXP (x, 1)) != CONST_INT\n \t   && GET_MODE_NUNITS (mode) == 1\n-\t   && ((TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT)\n-\t       || TARGET_POWERPC64\n-\t       || ((mode != DImode && mode != DFmode && mode != DDmode)\n-\t\t   || (TARGET_E500_DOUBLE && mode != DDmode)))\n-\t   && (TARGET_POWERPC64 || mode != DImode)\n-\t   && !avoiding_indexed_address_p (mode)\n-\t   && mode != TImode\n-\t   && mode != TFmode\n-\t   && mode != TDmode)\n+\t   && (GET_MODE_SIZE (mode) <= UNITS_PER_WORD\n+\t       || (/* ??? Assume floating point reg based on mode?  */\n+\t\t   (TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT)\n+\t\t   && (mode == DFmode || mode == DDmode)))\n+\t   && !avoiding_indexed_address_p (mode))\n     {\n       return gen_rtx_PLUS (Pmode, XEXP (x, 0),\n \t\t\t   force_reg (Pmode, force_operand (XEXP (x, 1), 0)));\n     }\n   else if (SPE_VECTOR_MODE (mode)\n-\t   || (TARGET_E500_DOUBLE && (mode == DFmode || mode == TFmode\n-\t\t\t\t      || mode == DDmode || mode == TDmode\n-\t\t\t\t      || mode == DImode)))\n+\t   || (TARGET_E500_DOUBLE && GET_MODE_SIZE (mode) > UNITS_PER_WORD))\n     {\n       if (mode == DImode)\n \treturn x;\n@@ -5555,38 +5598,28 @@ rs6000_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n \n       return force_reg (Pmode, x);\n     }\n-  else if (TARGET_ELF\n+  else if ((TARGET_ELF\n+#if TARGET_MACHO\n+\t    || !MACHO_DYNAMIC_NO_PIC_P\n+#endif\n+\t    )\n \t   && TARGET_32BIT\n \t   && TARGET_NO_TOC\n \t   && ! flag_pic\n \t   && GET_CODE (x) != CONST_INT\n \t   && GET_CODE (x) != CONST_DOUBLE\n \t   && CONSTANT_P (x)\n \t   && GET_MODE_NUNITS (mode) == 1\n-\t   && (GET_MODE_BITSIZE (mode) <= 32\n-\t       || ((TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT)\n+\t   && (GET_MODE_SIZE (mode) <= UNITS_PER_WORD\n+\t       || (/* ??? Assume floating point reg based on mode?  */\n+\t\t   (TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT)\n \t\t   && (mode == DFmode || mode == DDmode))))\n     {\n       rtx reg = gen_reg_rtx (Pmode);\n-      emit_insn (gen_elf_high (reg, x));\n-      return gen_rtx_LO_SUM (Pmode, reg, x);\n-    }\n-  else if (TARGET_MACHO && TARGET_32BIT && TARGET_NO_TOC\n-\t   && ! flag_pic\n-#if TARGET_MACHO\n-\t   && ! MACHO_DYNAMIC_NO_PIC_P\n-#endif\n-\t   && GET_CODE (x) != CONST_INT\n-\t   && GET_CODE (x) != CONST_DOUBLE\n-\t   && CONSTANT_P (x)\n-\t   && GET_MODE_NUNITS (mode) == 1\n-\t   && ((TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT)\n-\t       || (mode != DFmode && mode != DDmode))\n-\t   && mode != DImode\n-\t   && mode != TImode)\n-    {\n-      rtx reg = gen_reg_rtx (Pmode);\n-      emit_insn (gen_macho_high (reg, x));\n+      if (TARGET_ELF)\n+\temit_insn (gen_elf_high (reg, x));\n+      else\n+\temit_insn (gen_macho_high (reg, x));\n       return gen_rtx_LO_SUM (Pmode, reg, x);\n     }\n   else if (TARGET_TOC\n@@ -6177,7 +6210,18 @@ rs6000_legitimize_reload_address (rtx x, enum machine_mode mode,\n #endif\n       /* Don't do this for TFmode or TDmode, since the result isn't offsettable.\n \t The same goes for DImode without 64-bit gprs and DFmode and DDmode\n-\t without fprs.  */\n+\t without fprs.\n+\t ??? Assume floating point reg based on mode?  This assumption is\n+\t violated by eg. powerpc-linux -m32 compile of gcc.dg/pr28796-2.c\n+\t where reload ends up doing a DFmode load of a constant from\n+\t mem using two gprs.  Unfortunately, at this point reload\n+\t hasn't yet selected regs so poking around in reload data\n+\t won't help and even if we could figure out the regs reliably,\n+\t we'd still want to allow this transformation when the mem is\n+\t naturally aligned.  Since we say the address is good here, we\n+\t can't disable offsets from LO_SUMs in mem_operand_gpr.\n+\t FIXME: Allow offset from lo_sum for other modes too, when\n+\t mem is sufficiently aligned.  */\n       && mode != TFmode\n       && mode != TDmode\n       && (mode != DImode || TARGET_POWERPC64)\n@@ -6327,7 +6371,7 @@ rs6000_legitimate_address_p (enum machine_mode mode, rtx x, bool reg_ok_strict)\n \t  || XEXP (x, 0) == arg_pointer_rtx)\n       && GET_CODE (XEXP (x, 1)) == CONST_INT)\n     return 1;\n-  if (rs6000_legitimate_offset_address_p (mode, x, reg_ok_strict))\n+  if (rs6000_legitimate_offset_address_p (mode, x, reg_ok_strict, false))\n     return 1;\n   if (mode != TImode\n       && mode != TFmode\n@@ -6355,7 +6399,8 @@ rs6000_legitimate_address_p (enum machine_mode mode, rtx x, bool reg_ok_strict)\n \t   && (mode == DFmode || mode == DDmode || mode == DImode))\n       && TARGET_UPDATE\n       && legitimate_indirect_address_p (XEXP (x, 0), reg_ok_strict)\n-      && (rs6000_legitimate_offset_address_p (mode, XEXP (x, 1), reg_ok_strict)\n+      && (rs6000_legitimate_offset_address_p (mode, XEXP (x, 1),\n+\t\t\t\t\t      reg_ok_strict, false)\n \t  || (!avoiding_indexed_address_p (mode)\n \t      && legitimate_indexed_address_p (XEXP (x, 1), reg_ok_strict)))\n       && rtx_equal_p (XEXP (XEXP (x, 1), 0), XEXP (x, 0)))\n@@ -6419,7 +6464,7 @@ rs6000_mode_dependent_address (const_rtx addr)\n \t  && GET_CODE (XEXP (addr, 1)) == CONST_INT)\n \t{\n \t  unsigned HOST_WIDE_INT val = INTVAL (XEXP (addr, 1));\n-\t  return val + 12 + 0x8000 >= 0x10000;\n+\t  return val + 0x8000 >= 0x10000 - (TARGET_POWERPC64 ? 8 : 12);\n \t}\n       break;\n \n@@ -6489,23 +6534,30 @@ rs6000_find_base_term (rtx op)\n \n    in 32-bit mode, that the recog predicate rejects.  */\n \n-bool\n-rs6000_offsettable_memref_p (rtx op)\n+static bool\n+rs6000_offsettable_memref_p (rtx op, enum machine_mode reg_mode)\n {\n+  bool worst_case;\n+\n   if (!MEM_P (op))\n     return false;\n \n   /* First mimic offsettable_memref_p.  */\n-  if (offsettable_address_p (1, GET_MODE (op), XEXP (op, 0)))\n+  if (offsettable_address_p (true, GET_MODE (op), XEXP (op, 0)))\n     return true;\n \n   /* offsettable_address_p invokes rs6000_mode_dependent_address, but\n      the latter predicate knows nothing about the mode of the memory\n      reference and, therefore, assumes that it is the largest supported\n      mode (TFmode).  As a consequence, legitimate offsettable memory\n      references are rejected.  rs6000_legitimate_offset_address_p contains\n-     the correct logic for the PLUS case of rs6000_mode_dependent_address.  */\n-  return rs6000_legitimate_offset_address_p (GET_MODE (op), XEXP (op, 0), 1);\n+     the correct logic for the PLUS case of rs6000_mode_dependent_address,\n+     at least with a little bit of help here given that we know the\n+     actual registers used.  */\n+  worst_case = ((TARGET_POWERPC64 && GET_MODE_CLASS (reg_mode) == MODE_INT)\n+\t\t|| GET_MODE_SIZE (reg_mode) == 4);\n+  return rs6000_legitimate_offset_address_p (GET_MODE (op), XEXP (op, 0),\n+\t\t\t\t\t     true, worst_case);\n }\n \n /* Change register usage conditional on target flags.  */\n@@ -13516,7 +13568,8 @@ rs6000_secondary_reload (bool in_p,\n \t  if (rclass == GENERAL_REGS || rclass == BASE_REGS)\n \t    {\n \t      if (!legitimate_indirect_address_p (addr, false)\n-\t\t  && !rs6000_legitimate_offset_address_p (TImode, addr, false))\n+\t\t  && !rs6000_legitimate_offset_address_p (TImode, addr,\n+\t\t\t\t\t\t\t  false, true))\n \t\t{\n \t\t  sri->icode = icode;\n \t\t  /* account for splitting the loads, and converting the\n@@ -13589,18 +13642,9 @@ rs6000_secondary_reload (bool in_p,\n \t   && MEM_P (x)\n \t   && GET_MODE_SIZE (GET_MODE (x)) >= UNITS_PER_WORD)\n     {\n-      rtx addr = XEXP (x, 0);\n+      rtx off = address_offset (XEXP (x, 0));\n \n-      if (GET_CODE (addr) == PRE_MODIFY)\n-\taddr = XEXP (addr, 1);\n-      else if (GET_CODE (addr) == LO_SUM\n-\t       && GET_CODE (XEXP (addr, 0)) == REG\n-\t       && GET_CODE (XEXP (addr, 1)) == CONST)\n-\taddr = XEXP (XEXP (addr, 1), 0);\n-\n-      if (GET_CODE (addr) == PLUS\n-\t  && GET_CODE (XEXP (addr, 1)) == CONST_INT\n-\t  && (INTVAL (XEXP (addr, 1)) & 3) != 0)\n+      if (off != NULL_RTX && (INTVAL (off) & 3) != 0)\n \t{\n \t  if (in_p)\n \t    sri->icode = CODE_FOR_reload_di_load;\n@@ -13612,6 +13656,27 @@ rs6000_secondary_reload (bool in_p,\n       else\n \tdefault_p = true;\n     }\n+  else if (!TARGET_POWERPC64\n+\t   && rs6000_reload_register_type (rclass) == GPR_REGISTER_TYPE\n+\t   && MEM_P (x)\n+\t   && GET_MODE_SIZE (GET_MODE (x)) > UNITS_PER_WORD)\n+    {\n+      rtx off = address_offset (XEXP (x, 0));\n+\n+      if (off != NULL_RTX\n+\t  && ((unsigned HOST_WIDE_INT) INTVAL (off) + 0x8000\n+\t      >= 0x1000u - (GET_MODE_SIZE (GET_MODE (x)) - UNITS_PER_WORD)))\n+\t{\n+\t  if (in_p)\n+\t    sri->icode = CODE_FOR_reload_si_load;\n+\t  else\n+\t    sri->icode = CODE_FOR_reload_si_store;\n+\t  sri->extra_cost = 2;\n+\t  ret = NO_REGS;\n+\t}\n+      else\n+\tdefault_p = true;\n+    }\n   else\n     default_p = true;\n \n@@ -13700,8 +13765,9 @@ rs6000_secondary_reload_inner (rtx reg, rtx mem, rtx scratch, bool store_p)\n \t}\n \n       if (GET_CODE (addr) == PLUS\n-\t  && (!rs6000_legitimate_offset_address_p (TImode, addr, false)\n-\t      || and_op2 != NULL_RTX))\n+\t  && (and_op2 != NULL_RTX\n+\t      || !rs6000_legitimate_offset_address_p (TImode, addr,\n+\t\t\t\t\t\t      false, true)))\n \t{\n \t  addr_op1 = XEXP (addr, 0);\n \t  addr_op2 = XEXP (addr, 1);\n@@ -13733,7 +13799,8 @@ rs6000_secondary_reload_inner (rtx reg, rtx mem, rtx scratch, bool store_p)\n \t  scratch_or_premodify = scratch;\n \t}\n       else if (!legitimate_indirect_address_p (addr, false)\n-\t       && !rs6000_legitimate_offset_address_p (TImode, addr, false))\n+\t       && !rs6000_legitimate_offset_address_p (TImode, addr,\n+\t\t\t\t\t\t       false, true))\n \t{\n \t  if (TARGET_DEBUG_ADDR)\n \t    {\n@@ -13792,7 +13859,7 @@ rs6000_secondary_reload_inner (rtx reg, rtx mem, rtx scratch, bool store_p)\n \t      && GET_MODE_SIZE (mode) == 8\n \t      && and_op2 == NULL_RTX\n \t      && scratch_or_premodify == scratch\n-\t      && rs6000_legitimate_offset_address_p (mode, addr, false)))\n+\t      && rs6000_legitimate_offset_address_p (mode, addr, false, false)))\n \t;\n \n       else if (GET_CODE (addr) == PLUS)\n@@ -13901,10 +13968,11 @@ rs6000_secondary_reload_inner (rtx reg, rtx mem, rtx scratch, bool store_p)\n }\n \n /* Convert reloads involving 64-bit gprs and misaligned offset\n-   addressing to use indirect addressing.  */\n+   addressing, or multiple 32-bit gprs and offsets that are too large,\n+   to use indirect addressing.  */\n \n void\n-rs6000_secondary_reload_ppc64 (rtx reg, rtx mem, rtx scratch, bool store_p)\n+rs6000_secondary_reload_gpr (rtx reg, rtx mem, rtx scratch, bool store_p)\n {\n   int regno = true_regnum (reg);\n   enum reg_class rclass;\n@@ -13913,7 +13981,7 @@ rs6000_secondary_reload_ppc64 (rtx reg, rtx mem, rtx scratch, bool store_p)\n \n   if (TARGET_DEBUG_ADDR)\n     {\n-      fprintf (stderr, \"\\nrs6000_secondary_reload_ppc64, type = %s\\n\",\n+      fprintf (stderr, \"\\nrs6000_secondary_reload_gpr, type = %s\\n\",\n \t       store_p ? \"store\" : \"load\");\n       fprintf (stderr, \"reg:\\n\");\n       debug_rtx (reg);\n@@ -16993,7 +17061,7 @@ rs6000_split_multireg_move (rtx dst, rtx src)\n \t      emit_insn (gen_add3_insn (breg, breg, delta_rtx));\n \t      src = replace_equiv_address (src, breg);\n \t    }\n-\t  else if (! rs6000_offsettable_memref_p (src))\n+\t  else if (! rs6000_offsettable_memref_p (src, reg_mode))\n \t    {\n \t      if (GET_CODE (XEXP (src, 0)) == PRE_MODIFY)\n \t\t{\n@@ -17059,7 +17127,7 @@ rs6000_split_multireg_move (rtx dst, rtx src)\n \t\temit_insn (gen_add3_insn (breg, breg, delta_rtx));\n \t      dst = replace_equiv_address (dst, breg);\n \t    }\n-\t  else if (!rs6000_offsettable_memref_p (dst)\n+\t  else if (!rs6000_offsettable_memref_p (dst, reg_mode)\n \t\t   && GET_CODE (XEXP (dst, 0)) != LO_SUM)\n \t    {\n \t      if (GET_CODE (XEXP (dst, 0)) == PRE_MODIFY)\n@@ -17097,7 +17165,7 @@ rs6000_split_multireg_move (rtx dst, rtx src)\n \t\t}\n \t    }\n \t  else if (GET_CODE (XEXP (dst, 0)) != LO_SUM)\n-\t    gcc_assert (rs6000_offsettable_memref_p (dst));\n+\t    gcc_assert (rs6000_offsettable_memref_p (dst, reg_mode));\n \t}\n \n       for (i = 0; i < nregs; i++)\n@@ -27935,7 +28003,7 @@ rs6000_allocate_stack_temp (enum machine_mode mode,\n   if (!legitimate_indirect_address_p (addr, strict_p))\n     {\n       if (offsettable_p\n-\t  && !rs6000_legitimate_offset_address_p (mode, addr, strict_p))\n+\t  && !rs6000_legitimate_offset_address_p (mode, addr, strict_p, true))\n \tstack = replace_equiv_address (stack, copy_addr_to_reg (addr));\n \n       else if (reg_reg_p && !legitimate_indexed_address_p (addr, strict_p))"}, {"sha": "7f7f5adc9061ccbc8486851c697687ae72c82175", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 83, "deletions": 83, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d32d6b75cabf6f0856c3998a71e9dc1f4a301ce7/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d32d6b75cabf6f0856c3998a71e9dc1f4a301ce7/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=d32d6b75cabf6f0856c3998a71e9dc1f4a301ce7", "patch": "@@ -9659,15 +9659,12 @@\n #endif\n }\")\n \n-;; Don't have reload use general registers to load a constant.  First,\n-;; it might not work if the output operand is the equivalent of\n-;; a non-offsettable memref, but also it is less efficient than loading\n-;; the constant into an FP register, since it will probably be used there.\n-;; The \"??\" is a kludge until we can figure out a more reasonable way\n-;; of handling these non-offsettable values.\n+;; Don't have reload use general registers to load a constant.  It is\n+;; less efficient than loading the constant into an FP register, since\n+;; it will probably be used there.\n (define_insn \"*movdf_hardfloat32\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=!r,??r,m,ws,?wa,ws,?wa,Z,?Z,d,d,m,wa,!r,!r,!r\")\n-\t(match_operand:DF 1 \"input_operand\" \"r,m,r,ws,wa,Z,Z,ws,wa,d,m,d,j,G,H,F\"))]\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=Y,r,!r,ws,?wa,ws,?wa,Z,?Z,m,d,d,wa,!r,!r,!r\")\n+\t(match_operand:DF 1 \"input_operand\" \"r,Y,r,ws,wa,Z,Z,ws,wa,d,m,d,j,G,H,F\"))]\n   \"! TARGET_POWERPC64 && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT \n    && (gpc_reg_operand (operands[0], DFmode)\n        || gpc_reg_operand (operands[1], DFmode))\"\n@@ -9691,11 +9688,11 @@\n     case 8:\n       return \\\"stxsd%U0x %x1,%y0\\\";\n     case 9:\n-      return \\\"fmr %0,%1\\\";\n+      return \\\"stfd%U0%X0 %1,%0\\\";\n     case 10:\n       return \\\"lfd%U1%X1 %0,%1\\\";\n     case 11:\n-      return \\\"stfd%U0%X0 %1,%0\\\";\n+      return \\\"fmr %0,%1\\\";\n     case 12:\n       return \\\"xxlxor %x0,%x0,%x0\\\";\n     case 13:\n@@ -9704,46 +9701,47 @@\n       return \\\"#\\\";\n     }\n }\"\n-  [(set_attr \"type\" \"two,load,store,fp,fp,fpload,fpload,fpstore,fpstore,fp,fpload,fpstore,vecsimple,*,*,*\")\n-   (set_attr \"length\" \"8,16,16,4,4,4,4,4,4,4,4,4,4,8,12,16\")])\n+  [(set_attr \"type\" \"store,load,two,fp,fp,fpload,fpload,fpstore,fpstore,fpstore,fpload,fp,vecsimple,*,*,*\")\n+   (set_attr \"length\" \"8,8,8,4,4,4,4,4,4,4,4,4,4,8,12,16\")])\n \n (define_insn \"*movdf_softfloat32\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=r,r,m,r,r,r\")\n-\t(match_operand:DF 1 \"input_operand\" \"r,m,r,G,H,F\"))]\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=Y,r,r,r,r,r\")\n+\t(match_operand:DF 1 \"input_operand\" \"r,Y,r,G,H,F\"))]\n   \"! TARGET_POWERPC64 \n    && ((TARGET_FPRS && TARGET_SINGLE_FLOAT) \n        || TARGET_SOFT_FLOAT || TARGET_E500_SINGLE)\n    && (gpc_reg_operand (operands[0], DFmode)\n        || gpc_reg_operand (operands[1], DFmode))\"\n   \"#\"\n-  [(set_attr \"type\" \"two,load,store,*,*,*\")\n+  [(set_attr \"type\" \"store,load,two,*,*,*\")\n    (set_attr \"length\" \"8,8,8,8,12,16\")])\n \n ;; Reload patterns to support gpr load/store with misaligned mem.\n-(define_expand \"reload_di_store\"\n+;; and multiple gpr load/store at offset >= 0xfffc\n+(define_expand \"reload_<mode>_store\"\n   [(parallel [(match_operand 0 \"memory_operand\" \"=m\")\n               (match_operand 1 \"gpc_reg_operand\" \"r\")\n-              (match_operand:DI 2 \"register_operand\" \"=&b\")])]\n-  \"TARGET_POWERPC64\"\n+              (match_operand:GPR 2 \"register_operand\" \"=&b\")])]\n+  \"\"\n {\n-  rs6000_secondary_reload_ppc64 (operands[1], operands[0], operands[2], true);\n+  rs6000_secondary_reload_gpr (operands[1], operands[0], operands[2], true);\n   DONE;\n })\n \n-(define_expand \"reload_di_load\"\n+(define_expand \"reload_<mode>_load\"\n   [(parallel [(match_operand 0 \"gpc_reg_operand\" \"=r\")\n               (match_operand 1 \"memory_operand\" \"m\")\n-              (match_operand:DI 2 \"register_operand\" \"=b\")])]\n-  \"TARGET_POWERPC64\"\n+              (match_operand:GPR 2 \"register_operand\" \"=b\")])]\n+  \"\"\n {\n-  rs6000_secondary_reload_ppc64 (operands[0], operands[1], operands[2], false);\n+  rs6000_secondary_reload_gpr (operands[0], operands[1], operands[2], false);\n   DONE;\n })\n \n ; ld/std require word-aligned displacements -> 'Y' constraint.\n ; List Y->r and r->Y before r->r for reload.\n (define_insn \"*movdf_hardfloat64_mfpgpr\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=Y,r,!r,ws,?wa,ws,?wa,Z,?Z,d,d,m,wa,*c*l,!r,*h,!r,!r,!r,r,d\")\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=Y,r,!r,ws,?wa,ws,?wa,Z,?Z,m,d,d,wa,*c*l,!r,*h,!r,!r,!r,r,d\")\n \t(match_operand:DF 1 \"input_operand\" \"r,Y,r,ws,?wa,Z,Z,ws,wa,d,m,d,j,r,h,0,G,H,F,d,r\"))]\n   \"TARGET_POWERPC64 && TARGET_MFPGPR && TARGET_HARD_FLOAT && TARGET_FPRS \n    && TARGET_DOUBLE_FLOAT\n@@ -9759,9 +9757,9 @@\n    lxsd%U1x %x0,%y1\n    stxsd%U0x %x1,%y0\n    stxsd%U0x %x1,%y0\n-   fmr %0,%1\n-   lfd%U1%X1 %0,%1\n    stfd%U0%X0 %1,%0\n+   lfd%U1%X1 %0,%1\n+   fmr %0,%1\n    xxlxor %x0,%x0,%x0\n    mt%0 %1\n    mf%1 %0\n@@ -9771,13 +9769,13 @@\n    #\n    mftgpr %0,%1\n    mffgpr %0,%1\"\n-  [(set_attr \"type\" \"store,load,*,fp,fp,fpload,fpload,fpstore,fpstore,fp,fpload,fpstore,vecsimple,mtjmpr,mfjmpr,*,*,*,*,mftgpr,mffgpr\")\n+  [(set_attr \"type\" \"store,load,*,fp,fp,fpload,fpload,fpstore,fpstore,fpstore,fpload,fp,vecsimple,mtjmpr,mfjmpr,*,*,*,*,mftgpr,mffgpr\")\n    (set_attr \"length\" \"4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,8,12,16,4,4\")])\n \n ; ld/std require word-aligned displacements -> 'Y' constraint.\n ; List Y->r and r->Y before r->r for reload.\n (define_insn \"*movdf_hardfloat64\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=Y,r,!r,ws,?wa,ws,?wa,Z,?Z,d,d,m,wa,*c*l,!r,*h,!r,!r,!r\")\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=Y,r,!r,ws,?wa,ws,?wa,Z,?Z,m,d,d,wa,*c*l,!r,*h,!r,!r,!r\")\n \t(match_operand:DF 1 \"input_operand\" \"r,Y,r,ws,wa,Z,Z,ws,wa,d,m,d,j,r,h,0,G,H,F\"))]\n   \"TARGET_POWERPC64 && !TARGET_MFPGPR && TARGET_HARD_FLOAT && TARGET_FPRS \n    && TARGET_DOUBLE_FLOAT\n@@ -9793,36 +9791,36 @@\n    lxsd%U1x %x0,%y1\n    stxsd%U0x %x1,%y0\n    stxsd%U0x %x1,%y0\n-   fmr %0,%1\n-   lfd%U1%X1 %0,%1\n    stfd%U0%X0 %1,%0\n+   lfd%U1%X1 %0,%1\n+   fmr %0,%1\n    xxlxor %x0,%x0,%x0\n    mt%0 %1\n    mf%1 %0\n    {cror 0,0,0|nop}\n    #\n    #\n    #\"\n-  [(set_attr \"type\" \"store,load,*,fp,fp,fpload,fpload,fpstore,fpstore,fp,fpload,fpstore,vecsimple,mtjmpr,mfjmpr,*,*,*,*\")\n+  [(set_attr \"type\" \"store,load,*,fp,fp,fpload,fpload,fpstore,fpstore,fpstore,fpload,fp,vecsimple,mtjmpr,mfjmpr,*,*,*,*\")\n    (set_attr \"length\" \"4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,8,12,16\")])\n \n (define_insn \"*movdf_softfloat64\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=r,Y,r,cl,r,r,r,r,*h\")\n-\t(match_operand:DF 1 \"input_operand\" \"Y,r,r,r,h,G,H,F,0\"))]\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=Y,r,r,cl,r,r,r,r,*h\")\n+\t(match_operand:DF 1 \"input_operand\" \"r,Y,r,r,h,G,H,F,0\"))]\n   \"TARGET_POWERPC64 && (TARGET_SOFT_FLOAT || !TARGET_FPRS)\n    && (gpc_reg_operand (operands[0], DFmode)\n        || gpc_reg_operand (operands[1], DFmode))\"\n   \"@\n-   ld%U1%X1 %0,%1\n    std%U0%X0 %1,%0\n+   ld%U1%X1 %0,%1\n    mr %0,%1\n    mt%0 %1\n    mf%1 %0\n    #\n    #\n    #\n    {cror 0,0,0|nop}\"\n-  [(set_attr \"type\" \"load,store,*,mtjmpr,mfjmpr,*,*,*,*\")\n+  [(set_attr \"type\" \"store,load,*,mtjmpr,mfjmpr,*,*,*,*\")\n    (set_attr \"length\" \"4,4,4,4,4,8,12,16,4\")])\n \f\n (define_expand \"movtf\"\n@@ -9831,12 +9829,12 @@\n   \"!TARGET_IEEEQUAD && TARGET_LONG_DOUBLE_128\"\n   \"{ rs6000_emit_move (operands[0], operands[1], TFmode); DONE; }\")\n \n-; It's important to list the o->f and f->o moves before f->f because\n-; otherwise reload, given m->f, will try to pick f->f and reload it,\n-; which doesn't make progress.  Likewise r->Y must be before r->r.\n+;; It's important to list Y->r and r->Y before r->r because otherwise\n+;; reload, given m->r, will try to pick r->r and reload it, which\n+;; doesn't make progress.\n (define_insn_and_split \"*movtf_internal\"\n-  [(set (match_operand:TF 0 \"nonimmediate_operand\" \"=o,d,d,r,Y,r\")\n-\t(match_operand:TF 1 \"input_operand\"         \"d,o,d,YGHF,r,r\"))]\n+  [(set (match_operand:TF 0 \"nonimmediate_operand\" \"=m,d,d,Y,r,r\")\n+\t(match_operand:TF 1 \"input_operand\" \"d,m,d,r,YGHF,r\"))]\n   \"!TARGET_IEEEQUAD\n    && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_LONG_DOUBLE_128\n    && (gpc_reg_operand (operands[0], TFmode)\n@@ -9848,8 +9846,8 @@\n   [(set_attr \"length\" \"8,8,8,20,20,16\")])\n \n (define_insn_and_split \"*movtf_softfloat\"\n-  [(set (match_operand:TF 0 \"rs6000_nonimmediate_operand\" \"=r,Y,r\")\n-\t(match_operand:TF 1 \"input_operand\"         \"YGHF,r,r\"))]\n+  [(set (match_operand:TF 0 \"rs6000_nonimmediate_operand\" \"=Y,r,r\")\n+\t(match_operand:TF 1 \"input_operand\"         \"r,YGHF,r\"))]\n   \"!TARGET_IEEEQUAD\n    && (TARGET_SOFT_FLOAT || !TARGET_FPRS) && TARGET_LONG_DOUBLE_128\n    && (gpc_reg_operand (operands[0], TFmode)\n@@ -9890,9 +9888,9 @@\n })\n \n (define_insn_and_split \"*extenddftf2_internal\"\n-  [(set (match_operand:TF 0 \"nonimmediate_operand\" \"=o,d,&d,r\")\n-       (float_extend:TF (match_operand:DF 1 \"input_operand\" \"dr,md,md,rmGHF\")))\n-   (use (match_operand:DF 2 \"zero_reg_mem_operand\" \"rd,m,d,n\"))]\n+  [(set (match_operand:TF 0 \"nonimmediate_operand\" \"=m,Y,d,&d,r\")\n+       (float_extend:TF (match_operand:DF 1 \"input_operand\" \"d,r,md,md,rmGHF\")))\n+   (use (match_operand:DF 2 \"zero_reg_mem_operand\" \"d,r,m,d,n\"))]\n   \"!TARGET_IEEEQUAD\n    && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT \n    && TARGET_LONG_DOUBLE_128\"\n@@ -10145,24 +10143,26 @@\n ;; Next come the multi-word integer load and store and the load and store\n ;; multiple insns.\n \n-; List r->r after r->\"o<>\", otherwise reload will try to reload a\n-; non-offsettable address by using r->r which won't make progress.\n+;; List r->r after r->Y, otherwise reload will try to reload a\n+;; non-offsettable address by using r->r which won't make progress.\n+;; Use of fprs is disparaged slightly otherwise reload prefers to reload\n+;; a gpr into a fpr instead of reloading an invalid 'Y' address\n (define_insn \"*movdi_internal32\"\n-  [(set (match_operand:DI 0 \"rs6000_nonimmediate_operand\" \"=o<>,r,r,*d,*d,m,r,?wa\")\n-\t(match_operand:DI 1 \"input_operand\" \"r,r,m,d,m,d,IJKnGHF,O\"))]\n+  [(set (match_operand:DI 0 \"rs6000_nonimmediate_operand\" \"=Y,r,r,?m,?*d,?*d,r,?wa\")\n+\t(match_operand:DI 1 \"input_operand\" \"r,Y,r,d,m,d,IJKnGHF,O\"))]\n   \"! TARGET_POWERPC64\n    && (gpc_reg_operand (operands[0], DImode)\n        || gpc_reg_operand (operands[1], DImode))\"\n   \"@\n    #\n    #\n    #\n-   fmr %0,%1\n-   lfd%U1%X1 %0,%1\n    stfd%U0%X0 %1,%0\n+   lfd%U1%X1 %0,%1\n+   fmr %0,%1\n    #\n    xxlxor %x0,%x0,%x0\"\n-  [(set_attr \"type\" \"load,*,store,fp,fpload,fpstore,*,vecsimple\")])\n+  [(set_attr \"type\" \"store,load,*,fpstore,fpload,fp,*,vecsimple\")])\n \n (define_split\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n@@ -10195,50 +10195,50 @@\n { rs6000_split_multireg_move (operands[0], operands[1]); DONE; })\n \n (define_insn \"*movdi_mfpgpr\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,r,m,r,r,r,*d,*d,m,r,*h,*h,r,*d\")\n-\t(match_operand:DI 1 \"input_operand\" \"r,m,r,I,L,nF,d,m,d,*h,r,0,*d,r\"))]\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=Y,r,r,r,r,r,?m,?*d,?*d,r,*h,*h,r,?*d\")\n+\t(match_operand:DI 1 \"input_operand\" \"r,Y,r,I,L,nF,d,m,d,*h,r,0,*d,r\"))]\n   \"TARGET_POWERPC64 && TARGET_MFPGPR && TARGET_HARD_FLOAT && TARGET_FPRS\n    && (gpc_reg_operand (operands[0], DImode)\n        || gpc_reg_operand (operands[1], DImode))\"\n   \"@\n-   mr %0,%1\n-   ld%U1%X1 %0,%1\n    std%U0%X0 %1,%0\n+   ld%U1%X1 %0,%1\n+   mr %0,%1\n    li %0,%1\n    lis %0,%v1\n    #\n-   fmr %0,%1\n-   lfd%U1%X1 %0,%1\n    stfd%U0%X0 %1,%0\n+   lfd%U1%X1 %0,%1\n+   fmr %0,%1\n    mf%1 %0\n    mt%0 %1\n    {cror 0,0,0|nop}\n    mftgpr %0,%1\n    mffgpr %0,%1\"\n-  [(set_attr \"type\" \"*,load,store,*,*,*,fp,fpload,fpstore,mfjmpr,mtjmpr,*,mftgpr,mffgpr\")\n+  [(set_attr \"type\" \"store,load,*,*,*,*,fpstore,fpload,fp,mfjmpr,mtjmpr,*,mftgpr,mffgpr\")\n    (set_attr \"length\" \"4,4,4,4,4,20,4,4,4,4,4,4,4,4\")])\n \n (define_insn \"*movdi_internal64\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,r,m,r,r,r,*d,*d,m,r,*h,*h,?wa\")\n-\t(match_operand:DI 1 \"input_operand\" \"r,m,r,I,L,nF,d,m,d,*h,r,0,O\"))]\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=Y,r,r,r,r,r,?m,?*d,?*d,r,*h,*h,?wa\")\n+\t(match_operand:DI 1 \"input_operand\" \"r,Y,r,I,L,nF,d,m,d,*h,r,0,O\"))]\n   \"TARGET_POWERPC64 && (!TARGET_MFPGPR || !TARGET_HARD_FLOAT || !TARGET_FPRS)\n    && (gpc_reg_operand (operands[0], DImode)\n        || gpc_reg_operand (operands[1], DImode))\"\n   \"@\n-   mr %0,%1\n-   ld%U1%X1 %0,%1\n    std%U0%X0 %1,%0\n+   ld%U1%X1 %0,%1\n+   mr %0,%1\n    li %0,%1\n    lis %0,%v1\n    #\n-   fmr %0,%1\n-   lfd%U1%X1 %0,%1\n    stfd%U0%X0 %1,%0\n+   lfd%U1%X1 %0,%1\n+   fmr %0,%1\n    mf%1 %0\n    mt%0 %1\n    {cror 0,0,0|nop}\n    xxlxor %x0,%x0,%x0\"\n-  [(set_attr \"type\" \"*,load,store,*,*,*,fp,fpload,fpstore,mfjmpr,mtjmpr,*,vecsimple\")\n+  [(set_attr \"type\" \"store,load,*,*,*,*,fpstore,fpload,fp,mfjmpr,mtjmpr,*,vecsimple\")\n    (set_attr \"length\" \"4,4,4,4,4,20,4,4,4,4,4,4,4\")])\n \n ;; immediate value valid for a single instruction hiding in a const_double\n@@ -10313,8 +10313,8 @@\n ;; giving the SCRATCH mq.\n \n (define_insn \"*movti_power\"\n-  [(set (match_operand:TI 0 \"reg_or_mem_operand\" \"=Q,m,????r,????r,????r,r\")\n-\t(match_operand:TI 1 \"input_operand\" \"r,r,r,Q,m,n\"))\n+  [(set (match_operand:TI 0 \"reg_or_mem_operand\" \"=Q,Y,????r,????r,????r,r\")\n+\t(match_operand:TI 1 \"input_operand\" \"r,r,Q,Y,r,n\"))\n    (clobber (match_scratch:SI 2 \"=q,q#X,X,X,X,X\"))]\n   \"TARGET_POWER && ! TARGET_POWERPC64\n    && (gpc_reg_operand (operands[0], TImode) || gpc_reg_operand (operands[1], TImode))\"\n@@ -10329,25 +10329,25 @@\n       if (TARGET_STRING)\n         return \\\"{stsi|stswi} %1,%P0,16\\\";\n     case 1:\n-    case 2:\n       return \\\"#\\\";\n-    case 3:\n+    case 2:\n       /* If the address is not used in the output, we can use lsi.  Otherwise,\n \t fall through to generating four loads.  */\n       if (TARGET_STRING\n \t  && ! reg_overlap_mentioned_p (operands[0], operands[1]))\n \treturn \\\"{lsi|lswi} %0,%P1,16\\\";\n       /* ... fall through ...  */\n+    case 3:\n     case 4:\n     case 5:\n       return \\\"#\\\";\n     }\n }\"\n-  [(set_attr \"type\" \"store,store,*,load,load,*\")])\n+  [(set_attr \"type\" \"store,store,load,load,*,*\")])\n \n (define_insn \"*movti_string\"\n-  [(set (match_operand:TI 0 \"reg_or_mem_operand\" \"=Q,o<>,????r,????r,????r,r\")\n-\t(match_operand:TI 1 \"input_operand\" \"r,r,r,Q,m,n\"))]\n+  [(set (match_operand:TI 0 \"reg_or_mem_operand\" \"=Q,Y,????r,????r,????r,r\")\n+\t(match_operand:TI 1 \"input_operand\" \"r,r,Q,Y,r,n\"))]\n   \"! TARGET_POWER && ! TARGET_POWERPC64\n    && (gpc_reg_operand (operands[0], TImode) || gpc_reg_operand (operands[1], TImode))\"\n   \"*\n@@ -10360,33 +10360,33 @@\n       if (TARGET_STRING)\n         return \\\"{stsi|stswi} %1,%P0,16\\\";\n     case 1:\n-    case 2:\n       return \\\"#\\\";\n-    case 3:\n+    case 2:\n       /* If the address is not used in the output, we can use lsi.  Otherwise,\n \t fall through to generating four loads.  */\n       if (TARGET_STRING\n           && ! reg_overlap_mentioned_p (operands[0], operands[1]))\n \treturn \\\"{lsi|lswi} %0,%P1,16\\\";\n       /* ... fall through ...  */\n+    case 3:\n     case 4:\n     case 5:\n       return \\\"#\\\";\n     }\n }\"\n-  [(set_attr \"type\" \"store_ux,store_ux,*,load_ux,load_ux,*\")\n+  [(set_attr \"type\" \"store_ux,store_ux,load_ux,load_ux,*,*\")\n    (set (attr \"cell_micro\") (if_then_else (match_test \"TARGET_STRING\")\n    \t\t\t                  (const_string \"always\")\n \t\t\t\t\t  (const_string \"conditional\")))])\n \n (define_insn \"*movti_ppc64\"\n-  [(set (match_operand:TI 0 \"nonimmediate_operand\" \"=r,o<>,r\")\n-\t(match_operand:TI 1 \"input_operand\" \"r,r,m\"))]\n+  [(set (match_operand:TI 0 \"nonimmediate_operand\" \"=Y,r,r\")\n+\t(match_operand:TI 1 \"input_operand\" \"r,Y,r\"))]\n   \"(TARGET_POWERPC64 && (gpc_reg_operand (operands[0], TImode)\n     || gpc_reg_operand (operands[1], TImode)))\n    && VECTOR_MEM_NONE_P (TImode)\"\n   \"#\"\n-  [(set_attr \"type\" \"*,store,load\")])\n+  [(set_attr \"type\" \"store,load,*\")])\n \n (define_split\n   [(set (match_operand:TI 0 \"gpc_reg_operand\" \"\")\n@@ -13215,8 +13215,8 @@\n    (set_attr \"length\" \"12\")])\n \n (define_insn \"stack_protect_setdi\"\n-  [(set (match_operand:DI 0 \"memory_operand\" \"=m\")\n-\t(unspec:DI [(match_operand:DI 1 \"memory_operand\" \"m\")] UNSPEC_SP_SET))\n+  [(set (match_operand:DI 0 \"memory_operand\" \"=Y\")\n+\t(unspec:DI [(match_operand:DI 1 \"memory_operand\" \"Y\")] UNSPEC_SP_SET))\n    (set (match_scratch:DI 2 \"=&r\") (const_int 0))]\n   \"TARGET_64BIT\"\n   \"ld%U1%X1 %2,%1\\;std%U0%X0 %2,%0\\;{lil|li} %2,0\"\n@@ -13257,8 +13257,8 @@\n \n (define_insn \"stack_protect_testdi\"\n   [(set (match_operand:CCEQ 0 \"cc_reg_operand\" \"=x,?y\")\n-        (unspec:CCEQ [(match_operand:DI 1 \"memory_operand\" \"m,m\")\n-\t\t      (match_operand:DI 2 \"memory_operand\" \"m,m\")]\n+        (unspec:CCEQ [(match_operand:DI 1 \"memory_operand\" \"Y,Y\")\n+\t\t      (match_operand:DI 2 \"memory_operand\" \"Y,Y\")]\n \t\t     UNSPEC_SP_TEST))\n    (set (match_scratch:DI 4 \"=r,r\") (const_int 0))\n    (clobber (match_scratch:DI 3 \"=&r,&r\"))]"}]}