{"sha": "18ae7f63994e175638eacd0c626a017f648c7436", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MThhZTdmNjM5OTRlMTc1NjM4ZWFjZDBjNjI2YTAxN2Y2NDhjNzQzNg==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2001-05-12T10:37:48Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2001-05-12T10:37:48Z"}, "message": "Reverted Geoff Keating's 2001-05-03's patch.\n\nFrom-SVN: r41988", "tree": {"sha": "e842bdffad01a761829f0825c82412f3366de806", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e842bdffad01a761829f0825c82412f3366de806"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/18ae7f63994e175638eacd0c626a017f648c7436", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18ae7f63994e175638eacd0c626a017f648c7436", "html_url": "https://github.com/Rust-GCC/gccrs/commit/18ae7f63994e175638eacd0c626a017f648c7436", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18ae7f63994e175638eacd0c626a017f648c7436/comments", "author": null, "committer": null, "parents": [{"sha": "a45b480e68feedbc8550124adbff2f11c66c4ceb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a45b480e68feedbc8550124adbff2f11c66c4ceb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a45b480e68feedbc8550124adbff2f11c66c4ceb"}], "stats": {"total": 146, "additions": 61, "deletions": 85}, "files": [{"sha": "d15bad5565cfaa91e88d071625de66cfff516403", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18ae7f63994e175638eacd0c626a017f648c7436/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18ae7f63994e175638eacd0c626a017f648c7436/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=18ae7f63994e175638eacd0c626a017f648c7436", "patch": "@@ -1,3 +1,7 @@\n+2001-05-11  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\tReverted Geoff Keating's 2001-05-03's patch.\n+\n 2001-05-11  Ira Ruben\t<ira@apple.com>\n \n \t* cp/cp-tree.h (C_EXP_ORIGINAL_CODE): Delete; declared in c-common.h."}, {"sha": "7e22edc46a9d8d6658ac2e74ba7c5746e6f855cf", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 40, "deletions": 24, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18ae7f63994e175638eacd0c626a017f648c7436/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18ae7f63994e175638eacd0c626a017f648c7436/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=18ae7f63994e175638eacd0c626a017f648c7436", "patch": "@@ -607,7 +607,6 @@ enum cp_tree_index\n     CPTI_NELTS_IDENTIFIER,\n     CPTI_THIS_IDENTIFIER,\n     CPTI_PFN_IDENTIFIER,\n-    CPTI_PFN_VFLAG_IDENTIFIER,\n     CPTI_PFN_OR_DELTA2_IDENTIFIER,\n     CPTI_VPTR_IDENTIFIER,\n     CPTI_STD_IDENTIFIER,\n@@ -732,7 +731,6 @@ extern tree cp_global_trees[CPTI_MAX];\n #define nelts_identifier                cp_global_trees[CPTI_NELTS_IDENTIFIER]\n #define this_identifier                 cp_global_trees[CPTI_THIS_IDENTIFIER]\n #define pfn_identifier                  cp_global_trees[CPTI_PFN_IDENTIFIER]\n-#define pfn_vflag_identifier            cp_global_trees[CPTI_PFN_VFLAG_IDENTIFIER]\n #define pfn_or_delta2_identifier        cp_global_trees[CPTI_PFN_OR_DELTA2_IDENTIFIER]\n #define vptr_identifier                 cp_global_trees[CPTI_VPTR_IDENTIFIER]\n /* The name of the std namespace.  */\n@@ -2616,27 +2614,29 @@ extern int flag_new_for_scope;\n /* A pointer-to-function member type looks like:\n \n    struct {\n-     __P __pfn;\n-     ptrdiff_t __delta;\n+     short __delta;\n+     short __index;\n+     union {\n+       P __pfn;\n+       short __delta2;\n+     } __pfn_or_delta2;\n    };\n \n-   where P is either a POINTER_TYPE to a METHOD_TYPE appropriate for\n-   the pointer to member, or one plus twice the index into the vtable;\n-   the two cases are distinguished by looking at the least significant\n-   bit of P.  When FUNCTION_BOUNDARY is less than 16 (and so it might\n-   happen that the function pointer might naturally have the low bit\n-   set), the type is instead\n+   where P is a POINTER_TYPE to a METHOD_TYPE appropriate for the\n+   pointer to member.  The fields are used as follows:\n \n-   struct {\n-     __P __pfn;\n-     ptrdiff_t __delta;\n-     char __vflag;\n-   };\n+     If __INDEX is -1, then the function to call is non-virtual, and\n+     is located at the address given by __PFN.\n \n-   and __pfn is a pointer to a method when __vflag is zero.\n+     If __INDEX is zero, then this a NULL pointer-to-member.\n \n-   In all cases, the value to use for the THIS parameter is the\n-   address of the object plus __DELTA / 2 .\n+     Otherwise, the function to call is virtual.  Then, __DELTA2 gives\n+     the offset from an instance of the object to the virtual function\n+     table, and __INDEX - 1 is the index into the vtable to use to\n+     find the function.\n+\n+     The value to use for the THIS parameter is the address of the\n+     object plus __DELTA.\n \n    For example, given:\n \n@@ -2653,9 +2653,27 @@ extern int flag_new_for_scope;\n \n    the pointer-to-member for `&S::f' looks like:\n \n-     { &f__2B2, 4, 0 };\n+     { 4, -1, { &f__2B2 } };\n+\n+   The `4' means that given an `S*' you have to add 4 bytes to get to\n+   the address of the `B2*'.  Then, the -1 indicates that this is a\n+   non-virtual function.  Of course, `&f__2B2' is the name of that\n+   function.\n+\n+   (Of course, the exact values may differ depending on the mangling\n+   scheme, sizes of types, and such.).\n+\n+   Under the new ABI, we do:\n+\n+     struct {\n+       __P __pfn;\n+       ptrdiff_t __delta;\n+     };\n \n-*/\n+   (We don't need DELTA2, because the vtable is always the first thing\n+   in the object.)  If the function is virtual, then PFN is one plus\n+   twice the index into the vtable; otherwise, it is just a pointer to\n+   the function.  */\n \n /* Get the POINTER_TYPE to the METHOD_TYPE associated with this\n    pointer to member function.  TYPE_PTRMEMFUNC_P _must_ be true,\n@@ -4445,10 +4463,8 @@ extern int cp_type_quals                        PARAMS ((tree));\n extern int cp_has_mutable_p                     PARAMS ((tree));\n extern int at_least_as_qualified_p              PARAMS ((tree, tree));\n extern int more_qualified_p                     PARAMS ((tree, tree));\n-extern tree build_ptrmemfunc1                   PARAMS ((tree, tree, tree, \n-\t\t\t\t\t\t\t tree));\n-extern void expand_ptrmemfunc_cst               PARAMS ((tree, tree *, \n-\t\t\t\t\t\t\t tree *, tree *));\n+extern tree build_ptrmemfunc1                   PARAMS ((tree, tree, tree));\n+extern void expand_ptrmemfunc_cst               PARAMS ((tree, tree *, tree *));\n extern tree pfn_from_ptrmemfunc                 PARAMS ((tree));\n extern tree type_after_usual_arithmetic_conversions PARAMS ((tree, tree));\n extern tree composite_pointer_type              PARAMS ((tree, tree, tree, tree,"}, {"sha": "54d84f47ddda508fb29d81914cf46df7f0f9cc6c", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18ae7f63994e175638eacd0c626a017f648c7436/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18ae7f63994e175638eacd0c626a017f648c7436/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=18ae7f63994e175638eacd0c626a017f648c7436", "patch": "@@ -6303,7 +6303,6 @@ initialize_predefined_identifiers ()\n     { \"nelts\", &nelts_identifier, 0 },\n     { THIS_NAME, &this_identifier, 0 },\n     { VTABLE_PFN_NAME, &pfn_identifier, 0 },\n-    { \"__vflag\", &pfn_vflag_identifier, 0 },\n     { \"__pfn_or_delta2\", &pfn_or_delta2_identifier, 0 },\n     { \"_vptr\", &vptr_identifier, 0 },\n     { \"__vtt_parm\", &vtt_parm_identifier, 0 },\n@@ -9157,14 +9156,7 @@ build_ptrmemfunc_type (type)\n   fields[0] = build_decl (FIELD_DECL, pfn_identifier, type);\n   fields[1] = build_decl (FIELD_DECL, delta_identifier,\n \t\t\t  delta_type_node);\n-  if (FUNCTION_BOUNDARY < 16)\n-    {\n-      fields[2] = build_decl (FIELD_DECL, pfn_vflag_identifier,\n-\t\t\t      char_type_node);\n-      finish_builtin_type (t, \"__ptrmemfunc_type\", fields, 2, ptr_type_node);\n-    } else {\n-      finish_builtin_type (t, \"__ptrmemfunc_type\", fields, 1, ptr_type_node);\n-    }\n+  finish_builtin_type (t, \"__ptrmemfunc_type\", fields, 1, ptr_type_node);\n \n   /* Zap out the name so that the back-end will give us the debugging\n      information for this anonymous RECORD_TYPE.  */"}, {"sha": "6855160fc19070c66b8a7352f8b759c838ff6abc", "filename": "gcc/cp/expr.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18ae7f63994e175638eacd0c626a017f648c7436/gcc%2Fcp%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18ae7f63994e175638eacd0c626a017f648c7436/gcc%2Fcp%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexpr.c?ref=18ae7f63994e175638eacd0c626a017f648c7436", "patch": "@@ -62,10 +62,9 @@ cplus_expand_constant (cst)\n \t  {\n \t    tree delta;\n \t    tree pfn;\n-\t    tree flag;\n \n-\t    expand_ptrmemfunc_cst (cst, &delta, &pfn, &flag);\n-\t    cst = build_ptrmemfunc1 (type, delta, pfn, flag);\n+\t    expand_ptrmemfunc_cst (cst, &delta, &pfn);\n+\t    cst = build_ptrmemfunc1 (type, delta, pfn);\n \t  }\n       }\n       break;"}, {"sha": "440955df232aab9622e4e9ca205282fafeff5f94", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 14, "deletions": 49, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18ae7f63994e175638eacd0c626a017f648c7436/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18ae7f63994e175638eacd0c626a017f648c7436/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=18ae7f63994e175638eacd0c626a017f648c7436", "patch": "@@ -2909,22 +2909,9 @@ get_member_function_from_ptrfunc (instance_ptrptr, function)\n       idx = cp_build_binary_op (TRUNC_DIV_EXPR, \n \t\t\t\tbuild1 (NOP_EXPR, vtable_index_type, e3),\n \t\t\t\tTYPE_SIZE_UNIT (vtable_entry_type));\n-      if (FUNCTION_BOUNDARY < 16)\n-\t{\n-\t  tree delta;\n-\t  tree pfn;\n-\t  if (TREE_CODE (function) == PTRMEM_CST)\n-\t    expand_ptrmemfunc_cst (function, &delta, &pfn, &e1);\n-\t  else\n-\t    e1 = build_component_ref (function, pfn_vflag_identifier, \n-\t\t\t\t\t NULL_TREE, 0);\n-\t}\n-      else\n-\t{\n-\t  e1 = cp_build_binary_op (BIT_AND_EXPR,\n-\t\t\t\t   build1 (NOP_EXPR, vtable_index_type, e3),\n-\t\t\t\t   integer_one_node);\n-\t}\n+      e1 = cp_build_binary_op (BIT_AND_EXPR,\n+\t\t\t       build1 (NOP_EXPR, vtable_index_type, e3),\n+\t\t\t       integer_one_node);\n \n       vtbl = convert_pointer_to (ptr_type_node, instance);\n       delta = cp_convert (ptrdiff_type_node,\n@@ -6008,34 +5995,23 @@ get_delta_difference (from, to, force)\n    the other components as specified.  */\n \n tree\n-build_ptrmemfunc1 (type, delta, pfn, flag)\n-     tree type, delta, pfn, flag;\n+build_ptrmemfunc1 (type, delta, pfn)\n+     tree type, delta, pfn;\n {\n   tree u = NULL_TREE;\n   tree delta_field;\n   tree pfn_field;\n-  tree vflag_field;\n \n   /* Pull the FIELD_DECLs out of the type.  */\n   pfn_field = TYPE_FIELDS (type);\n   delta_field = TREE_CHAIN (pfn_field);\n-  vflag_field = TREE_CHAIN (delta_field);  /* NULL if no such field.  */\n \n   /* Make sure DELTA has the type we want.  */\n   delta = convert_and_check (delta_type_node, delta);\n \n   /* Finish creating the initializer.  */\n-  if (FUNCTION_BOUNDARY < 16)\n-    {\n-      u = tree_cons (pfn_field, pfn,\n-\t\t     tree_cons (delta_field, delta,\n-\t\t\t\tbuild_tree_list (vflag_field, flag)));\n-    }\n-  else\n-    {\n-      u = tree_cons (pfn_field, pfn,\n-\t\t     build_tree_list (delta_field, delta));\n-    }\n+  u = tree_cons (pfn_field, pfn,\n+\t\t build_tree_list (delta_field, delta));\n   u = build (CONSTRUCTOR, type, NULL_TREE, u);\n   TREE_CONSTANT (u) = TREE_CONSTANT (pfn) && TREE_CONSTANT (delta);\n   TREE_STATIC (u) = (TREE_CONSTANT (u)\n@@ -6071,7 +6047,6 @@ build_ptrmemfunc (type, pfn, force)\n     {\n       tree delta = NULL_TREE;\n       tree npfn = NULL_TREE;\n-      tree flag = NULL_TREE;\n       tree n;\n \n       if (!force \n@@ -6100,21 +6075,18 @@ build_ptrmemfunc (type, pfn, force)\n \n       /* Obtain the function pointer and the current DELTA.  */\n       if (TREE_CODE (pfn) == PTRMEM_CST)\n-\texpand_ptrmemfunc_cst (pfn, &delta, &npfn, &flag);\n+\texpand_ptrmemfunc_cst (pfn, &delta, &npfn);\n       else\n \t{\n \t  npfn = build_component_ref (pfn, pfn_identifier, NULL_TREE, 0);\n \t  delta = build_component_ref (pfn, delta_identifier, NULL_TREE, 0);\n-\t  if (FUNCTION_BOUNDARY < 16)\n-\t    flag = build_component_ref (pfn, pfn_vflag_identifier, \n-\t\t\t\t\tNULL_TREE, 0);\n \t}\n \n       /* Under the new ABI, the conversion is easy.  Just adjust\n \t the DELTA field.  */\n       delta = cp_convert (ptrdiff_type_node, delta);\n       delta = cp_build_binary_op (PLUS_EXPR, delta, n);\n-      return build_ptrmemfunc1 (to_type, delta, npfn, flag);\n+      return build_ptrmemfunc1 (to_type, delta, npfn);\n     }\n \n   /* Handle null pointer to member function conversions.  */\n@@ -6123,8 +6095,7 @@ build_ptrmemfunc (type, pfn, force)\n       pfn = build_c_cast (type, integer_zero_node);\n       return build_ptrmemfunc1 (to_type,\n \t\t\t\tinteger_zero_node, \n-\t\t\t\tpfn,\n-\t\t\t\tinteger_zero_node);\n+\t\t\t\tpfn);\n     }\n \n   if (type_unknown_p (pfn))\n@@ -6135,19 +6106,18 @@ build_ptrmemfunc (type, pfn, force)\n   return make_ptrmem_cst (to_type, fn);\n }\n \n-/* Return the DELTA, PFN, and FLAG values for the PTRMEM_CST\n+/* Return the DELTA, IDX, PFN, and DELTA2 values for the PTRMEM_CST\n    given by CST.\n \n    ??? There is no consistency as to the types returned for the above\n    values.  Some code acts as if its a sizetype and some as if its\n    integer_type_node.  */\n \n void\n-expand_ptrmemfunc_cst (cst, delta, pfn, flag)\n+expand_ptrmemfunc_cst (cst, delta, pfn)\n      tree cst;\n      tree *delta;\n      tree *pfn;\n-     tree *flag;\n {\n   tree type = TREE_TYPE (cst);\n   tree fn = PTRMEM_CST_MEMBER (cst);\n@@ -6165,10 +6135,7 @@ expand_ptrmemfunc_cst (cst, delta, pfn, flag)\n   *delta = get_delta_difference (fn_class, ptr_class, /*force=*/0);\n \n   if (!DECL_VIRTUAL_P (fn))\n-    {\n-      *pfn = convert (TYPE_PTRMEMFUNC_FN_TYPE (type), build_addr_func (fn));\n-      *flag = integer_zero_node;\n-    }\n+    *pfn = convert (TYPE_PTRMEMFUNC_FN_TYPE (type), build_addr_func (fn));\n   else\n     {\n       /* If we're dealing with a virtual function, we have to adjust 'this'\n@@ -6188,7 +6155,6 @@ expand_ptrmemfunc_cst (cst, delta, pfn, flag)\n \t\t\t  integer_one_node));\n       *pfn = fold (build1 (NOP_EXPR, TYPE_PTRMEMFUNC_FN_TYPE (type),\n \t\t\t   *pfn));\n-      *flag = integer_one_node;\n     }\n }\n \n@@ -6203,9 +6169,8 @@ pfn_from_ptrmemfunc (t)\n     {\n       tree delta;\n       tree pfn;\n-      tree flag;\n       \n-      expand_ptrmemfunc_cst (t, &delta, &pfn, &flag);\n+      expand_ptrmemfunc_cst (t, &delta, &pfn);\n       if (pfn)\n \treturn pfn;\n     }"}]}