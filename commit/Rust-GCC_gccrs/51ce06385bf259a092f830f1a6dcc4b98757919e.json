{"sha": "51ce06385bf259a092f830f1a6dcc4b98757919e", "node_id": "C_kwDOANBUbNoAKDUxY2UwNjM4NWJmMjU5YTA5MmY4MzBmMWE2ZGNjNGI5ODc1NzkxOWU", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2022-09-01T14:34:55Z"}, "committer": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2022-09-22T18:48:12Z"}, "message": "Create gimple_range_op_handler in a new source file.\n\nRange-ops is meant to be IL independent.  Some gimple processing has\nbe placed in range-ops, and some is located in gori.  Split it all into\na file and isolate it in a new class gimple_range_op_handler.\n\n\t* Makefile.in (OBJS): Add gimple-range-op.o.\n\t* gimple-range-edge.cc (gimple_outgoing_range_stmt_p): Use\n\tgimple_range_op_handler.\n\t* gimple-range-fold.cc (gimple_range_base_of_assignment): Move\n\tto a method in gimple_range_op_handler.\n\t(gimple_range_operand1): Ditto.\n\t(gimple_range_operand2): Ditto.\n\t(fold_using_range::fold_stmt): Use gimple_range_op_handler.\n\t(fold_using_range::range_of_range_op): Ditto.\n\t(fold_using_range::relation_fold_and_or): Ditto.\n\t(fur_source::register_outgoing_edges): Ditto.\n\t(gimple_range_ssa_names): Relocate to gimple-range-op.cc.\n\t* gimple-range-fold.h: Adjust prototypes.\n\t* gimple-range-gori.cc (gimple_range_calc_op1): Move\n\tto a method in gimple_range_op_handler.\n\t(gimple_range_calc_op2): Ditto.\n\t(gori_compute::compute_operand_range): Use\n\tgimple_range_op_handler.\n\t(gori_compute::compute_logical_operands): Ditto.\n\t(compute_operand1_range): Ditto.\n\t(gori_compute::compute_operand2_range): Ditto.\n\t(gori_compute::compute_operand1_and_operand2_range): Ditto.\n\t* gimple-range-gori.h: Adjust protoypes.\n\t* gimple-range-op.cc: New.  Supply gimple_range_op_handler methods.\n\t* gimple-range-op.h: New.  Supply gimple_range_op_handler class.\n\t* gimple-range.cc (gimple_ranger::prefill_name): Use\n\tgimple_range_op_handler.\n\t(gimple_ranger::prefill_stmt_dependencies): Ditto.\n\t* gimple-range.h: Include gimple-range-op.h.\n\t* range-op.cc (range_op_handler::range_op_handler): Adjust and\n\tremove gimple * parameter option.\n\t* range-op.h: Adjust prototypes.", "tree": {"sha": "f7ea0f2f2b93e69910b98cb38c1a32d2367cf4d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f7ea0f2f2b93e69910b98cb38c1a32d2367cf4d1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/51ce06385bf259a092f830f1a6dcc4b98757919e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51ce06385bf259a092f830f1a6dcc4b98757919e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/51ce06385bf259a092f830f1a6dcc4b98757919e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51ce06385bf259a092f830f1a6dcc4b98757919e/comments", "author": null, "committer": null, "parents": [{"sha": "24c473a14d3cbe6fc44997122b532cb9406497cb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24c473a14d3cbe6fc44997122b532cb9406497cb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/24c473a14d3cbe6fc44997122b532cb9406497cb"}], "stats": {"total": 679, "additions": 386, "deletions": 293}, "files": [{"sha": "59b67d994415fb7ee5f8f2f8fa61bf30536e4069", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51ce06385bf259a092f830f1a6dcc4b98757919e/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51ce06385bf259a092f830f1a6dcc4b98757919e/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=51ce06385bf259a092f830f1a6dcc4b98757919e", "patch": "@@ -1416,6 +1416,7 @@ OBJS = \\\n \tgimple-range-fold.o \\\n \tgimple-range-gori.o \\\n \tgimple-range-infer.o \\\n+\tgimple-range-op.o \\\n \tgimple-range-trace.o \\\n \tgimple-ssa-backprop.o \\\n \tgimple-ssa-isolate-paths.o \\"}, {"sha": "95deadffc55dfa84efffb0eeff64d4ba6c987841", "filename": "gcc/gimple-range-edge.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51ce06385bf259a092f830f1a6dcc4b98757919e/gcc%2Fgimple-range-edge.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51ce06385bf259a092f830f1a6dcc4b98757919e/gcc%2Fgimple-range-edge.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-edge.cc?ref=51ce06385bf259a092f830f1a6dcc4b98757919e", "patch": "@@ -43,7 +43,7 @@ gimple_outgoing_range_stmt_p (basic_block bb)\n   if (!gsi_end_p (gsi))\n     {\n       gimple *s = gsi_stmt (gsi);\n-      if (is_a<gcond *> (s) && range_op_handler (s))\n+      if (is_a<gcond *> (s) && gimple_range_op_handler::supported_p (s))\n \treturn gsi_stmt (gsi);\n       if (is_a <gswitch *> (s))\n \treturn gsi_stmt (gsi);"}, {"sha": "addf3e7f2549fba8ed314b50cf7f91315bd086b2", "filename": "gcc/gimple-range-fold.cc", "status": "modified", "additions": 28, "deletions": 125, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51ce06385bf259a092f830f1a6dcc4b98757919e/gcc%2Fgimple-range-fold.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51ce06385bf259a092f830f1a6dcc4b98757919e/gcc%2Fgimple-range-fold.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-fold.cc?ref=51ce06385bf259a092f830f1a6dcc4b98757919e", "patch": "@@ -42,7 +42,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"vr-values.h\"\n #include \"range.h\"\n #include \"value-query.h\"\n-#include \"range-op.h\"\n+#include \"gimple-range-op.h\"\n #include \"gimple-range.h\"\n // Construct a fur_source, and set the m_query field.\n \n@@ -463,73 +463,6 @@ gimple_range_adjustment (vrange &res, const gimple *stmt)\n     }\n }\n \n-// Return the base of the RHS of an assignment.\n-\n-static tree\n-gimple_range_base_of_assignment (const gimple *stmt)\n-{\n-  gcc_checking_assert (gimple_code (stmt) == GIMPLE_ASSIGN);\n-  tree op1 = gimple_assign_rhs1 (stmt);\n-  if (gimple_assign_rhs_code (stmt) == ADDR_EXPR)\n-    return get_base_address (TREE_OPERAND (op1, 0));\n-  return op1;\n-}\n-\n-// Return the first operand of this statement if it is a valid operand\n-// supported by ranges, otherwise return NULL_TREE.  Special case is\n-// &(SSA_NAME expr), return the SSA_NAME instead of the ADDR expr.\n-\n-tree\n-gimple_range_operand1 (const gimple *stmt)\n-{\n-  gcc_checking_assert (range_op_handler (stmt));\n-\n-  switch (gimple_code (stmt))\n-    {\n-      case GIMPLE_COND:\n-\treturn gimple_cond_lhs (stmt);\n-      case GIMPLE_ASSIGN:\n-\t{\n-\t  tree base = gimple_range_base_of_assignment (stmt);\n-\t  if (base && TREE_CODE (base) == MEM_REF)\n-\t    {\n-\t      // If the base address is an SSA_NAME, we return it\n-\t      // here.  This allows processing of the range of that\n-\t      // name, while the rest of the expression is simply\n-\t      // ignored.  The code in range_ops will see the\n-\t      // ADDR_EXPR and do the right thing.\n-\t      tree ssa = TREE_OPERAND (base, 0);\n-\t      if (TREE_CODE (ssa) == SSA_NAME)\n-\t\treturn ssa;\n-\t    }\n-\t  return base;\n-\t}\n-      default:\n-\tbreak;\n-    }\n-  return NULL;\n-}\n-\n-// Return the second operand of statement STMT, otherwise return NULL_TREE.\n-\n-tree\n-gimple_range_operand2 (const gimple *stmt)\n-{\n-  gcc_checking_assert (range_op_handler (stmt));\n-\n-  switch (gimple_code (stmt))\n-    {\n-    case GIMPLE_COND:\n-      return gimple_cond_rhs (stmt);\n-    case GIMPLE_ASSIGN:\n-      if (gimple_num_ops (stmt) >= 3)\n-\treturn gimple_assign_rhs2 (stmt);\n-    default:\n-      break;\n-    }\n-  return NULL_TREE;\n-}\n-\n // Calculate a range for statement S and return it in R. If NAME is provided it\n // represents the SSA_NAME on the LHS of the statement. It is only required\n // if there is more than one lhs/output.  If a range cannot\n@@ -551,8 +484,9 @@ fold_using_range::fold_stmt (vrange &r, gimple *s, fur_source &src, tree name)\n       && gimple_assign_rhs_code (s) == ADDR_EXPR)\n     return range_of_address (as_a <irange> (r), s, src);\n \n-  if (range_op_handler (s))\n-    res = range_of_range_op (r, s, src);\n+  gimple_range_op_handler handler (s);\n+  if (handler)\n+    res = range_of_range_op (r, handler, src);\n   else if (is_a<gphi *>(s))\n     res = range_of_phi (r, as_a<gphi *> (s), src);\n   else if (is_a<gcall *>(s))\n@@ -587,17 +521,19 @@ fold_using_range::fold_stmt (vrange &r, gimple *s, fur_source &src, tree name)\n // If a range cannot be calculated, return false.\n \n bool\n-fold_using_range::range_of_range_op (vrange &r, gimple *s, fur_source &src)\n+fold_using_range::range_of_range_op (vrange &r,\n+\t\t\t\t     gimple_range_op_handler &handler,\n+\t\t\t\t     fur_source &src)\n {\n+  gcc_checking_assert (handler);\n+  gimple *s = handler.stmt ();\n   tree type = gimple_range_type (s);\n   if (!type)\n     return false;\n-  range_op_handler handler (s);\n-  gcc_checking_assert (handler);\n \n-  tree lhs = gimple_get_lhs (s);\n-  tree op1 = gimple_range_operand1 (s);\n-  tree op2 = gimple_range_operand2 (s);\n+  tree lhs = handler.lhs ();\n+  tree op1 = handler.operand1 ();\n+  tree op2 = handler.operand2 ();\n   Value_Range range1 (TREE_TYPE (op1));\n   Value_Range range2 (op2 ? TREE_TYPE (op2) : TREE_TYPE (op1));\n \n@@ -1430,9 +1366,10 @@ fold_using_range::relation_fold_and_or (irange& lhs_range, gimple *s,\n   else if (code != BIT_IOR_EXPR && code != TRUTH_OR_EXPR)\n     return;\n \n-  tree lhs = gimple_get_lhs (s);\n-  tree ssa1 = gimple_range_ssa_p (gimple_range_operand1 (s));\n-  tree ssa2 = gimple_range_ssa_p (gimple_range_operand2 (s));\n+  gimple_range_op_handler handler (s);\n+  tree lhs = handler.lhs ();\n+  tree ssa1 = gimple_range_ssa_p (handler.operand1 ());\n+  tree ssa2 = gimple_range_ssa_p (handler.operand2 ());\n \n   // Deal with || and && only when there is a full set of symbolics.\n   if (!lhs || !ssa1 || !ssa2\n@@ -1448,18 +1385,18 @@ fold_using_range::relation_fold_and_or (irange& lhs_range, gimple *s,\n   gimple *ssa1_stmt = SSA_NAME_DEF_STMT (ssa1);\n   gimple *ssa2_stmt = SSA_NAME_DEF_STMT (ssa2);\n \n-  range_op_handler handler1 (SSA_NAME_DEF_STMT (ssa1));\n-  range_op_handler handler2 (SSA_NAME_DEF_STMT (ssa2));\n+  gimple_range_op_handler handler1 (ssa1_stmt);\n+  gimple_range_op_handler handler2 (ssa2_stmt);\n \n   // If either handler is not present, no relation can be found.\n   if (!handler1 || !handler2)\n     return;\n \n   // Both stmts will need to have 2 ssa names in the stmt.\n-  tree ssa1_dep1 = gimple_range_ssa_p (gimple_range_operand1 (ssa1_stmt));\n-  tree ssa1_dep2 = gimple_range_ssa_p (gimple_range_operand2 (ssa1_stmt));\n-  tree ssa2_dep1 = gimple_range_ssa_p (gimple_range_operand1 (ssa2_stmt));\n-  tree ssa2_dep2 = gimple_range_ssa_p (gimple_range_operand2 (ssa2_stmt));\n+  tree ssa1_dep1 = gimple_range_ssa_p (handler1.operand1 ());\n+  tree ssa1_dep2 = gimple_range_ssa_p (handler1.operand2 ());\n+  tree ssa2_dep1 = gimple_range_ssa_p (handler2.operand1 ());\n+  tree ssa2_dep2 = gimple_range_ssa_p (handler2.operand2 ());\n \n   if (!ssa1_dep1 || !ssa1_dep2 || !ssa2_dep1 || !ssa2_dep2)\n     return;\n@@ -1516,7 +1453,7 @@ fur_source::register_outgoing_edges (gcond *s, irange &lhs_range, edge e0, edge\n   tree name;\n   basic_block bb = gimple_bb (s);\n \n-  range_op_handler handler (s);\n+  gimple_range_op_handler handler (s);\n   if (!handler)\n     return;\n \n@@ -1529,7 +1466,6 @@ fur_source::register_outgoing_edges (gcond *s, irange &lhs_range, edge e0, edge\n \te0 = NULL;\n     }\n \n-\n   if (e1)\n     {\n       // If this edge is never taken, ignore it.\n@@ -1544,8 +1480,8 @@ fur_source::register_outgoing_edges (gcond *s, irange &lhs_range, edge e0, edge\n \n   // First, register the gcond itself.  This will catch statements like\n   // if (a_2 < b_5)\n-  tree ssa1 = gimple_range_ssa_p (gimple_range_operand1 (s));\n-  tree ssa2 = gimple_range_ssa_p (gimple_range_operand2 (s));\n+  tree ssa1 = gimple_range_ssa_p (handler.operand1 ());\n+  tree ssa2 = gimple_range_ssa_p (handler.operand2 ());\n   if (ssa1 && ssa2)\n     {\n       if (e0)\n@@ -1575,11 +1511,11 @@ fur_source::register_outgoing_edges (gcond *s, irange &lhs_range, edge e0, edge\n       if (TREE_CODE (TREE_TYPE (name)) != BOOLEAN_TYPE)\n \tcontinue;\n       gimple *stmt = SSA_NAME_DEF_STMT (name);\n-      range_op_handler handler (stmt);\n+      gimple_range_op_handler handler (stmt);\n       if (!handler)\n \tcontinue;\n-      tree ssa1 = gimple_range_ssa_p (gimple_range_operand1 (stmt));\n-      tree ssa2 = gimple_range_ssa_p (gimple_range_operand2 (stmt));\n+      tree ssa1 = gimple_range_ssa_p (handler.operand1 ());\n+      tree ssa2 = gimple_range_ssa_p (handler.operand2 ());\n       Value_Range r (TREE_TYPE (name));\n       if (ssa1 && ssa2)\n \t{\n@@ -1600,36 +1536,3 @@ fur_source::register_outgoing_edges (gcond *s, irange &lhs_range, edge e0, edge\n \t}\n     }\n }\n-\n-// Given stmt S, fill VEC, up to VEC_SIZE elements, with relevant ssa-names\n-// on the statement.  For efficiency, it is an error to not pass in enough\n-// elements for the vector.  Return the number of ssa-names.\n-\n-unsigned\n-gimple_range_ssa_names (tree *vec, unsigned vec_size, gimple *stmt)\n-{\n-  tree ssa;\n-  int count = 0;\n-\n-  if (range_op_handler (stmt))\n-    {\n-      gcc_checking_assert (vec_size >= 2);\n-      if ((ssa = gimple_range_ssa_p (gimple_range_operand1 (stmt))))\n-\tvec[count++] = ssa;\n-      if ((ssa = gimple_range_ssa_p (gimple_range_operand2 (stmt))))\n-\tvec[count++] = ssa;\n-    }\n-  else if (is_a<gassign *> (stmt)\n-\t   && gimple_assign_rhs_code (stmt) == COND_EXPR)\n-    {\n-      gcc_checking_assert (vec_size >= 3);\n-      gassign *st = as_a<gassign *> (stmt);\n-      if ((ssa = gimple_range_ssa_p (gimple_assign_rhs1 (st))))\n-\tvec[count++] = ssa;\n-      if ((ssa = gimple_range_ssa_p (gimple_assign_rhs2 (st))))\n-\tvec[count++] = ssa;\n-      if ((ssa = gimple_range_ssa_p (gimple_assign_rhs3 (st))))\n-\tvec[count++] = ssa;\n-    }\n-  return count;\n-}"}, {"sha": "ce18c66b8e722bfb7e1fcea38256651e0d2bfb1a", "filename": "gcc/gimple-range-fold.h", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51ce06385bf259a092f830f1a6dcc4b98757919e/gcc%2Fgimple-range-fold.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51ce06385bf259a092f830f1a6dcc4b98757919e/gcc%2Fgimple-range-fold.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-fold.h?ref=51ce06385bf259a092f830f1a6dcc4b98757919e", "patch": "@@ -96,15 +96,6 @@ range_compatible_p (tree type1, tree type2)\n \t  && TYPE_SIGN (type1) == TYPE_SIGN (type2));\n }\n \n-extern tree gimple_range_operand1 (const gimple *s);\n-extern tree gimple_range_operand2 (const gimple *s);\n-\n-// Given stmt S, fill VEC, up to VEC_SIZE elements, with relevant ssa-names\n-// on the statement.  For efficiency, it is an error to not pass in enough\n-// elements for the vector.  Return the number of ssa-names.\n-\n-unsigned gimple_range_ssa_names (tree *vec, unsigned vec_size, gimple *stmt);\n-\n // Source of all operands for fold_using_range and gori_compute.\n // It abstracts out the source of an operand so it can come from a stmt or\n // and edge or anywhere a derived class of fur_source wants.\n@@ -169,7 +160,8 @@ class fold_using_range\n   bool fold_stmt (vrange &r, gimple *s, class fur_source &src,\n \t\t  tree name = NULL_TREE);\n protected:\n-  bool range_of_range_op (vrange &r, gimple *s, fur_source &src);\n+  bool range_of_range_op (vrange &r, gimple_range_op_handler &handler,\n+\t\t\t  fur_source &src);\n   bool range_of_call (vrange &r, gcall *call, fur_source &src);\n   bool range_of_cond_expr (vrange &r, gassign* cond, fur_source &src);\n   bool range_of_address (irange &r, gimple *s, fur_source &src);"}, {"sha": "40b2f2f6ae9f1ee3ef9abe970ee30248ec49d558", "filename": "gcc/gimple-range-gori.cc", "status": "modified", "additions": 33, "deletions": 101, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51ce06385bf259a092f830f1a6dcc4b98757919e/gcc%2Fgimple-range-gori.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51ce06385bf259a092f830f1a6dcc4b98757919e/gcc%2Fgimple-range-gori.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-gori.cc?ref=51ce06385bf259a092f830f1a6dcc4b98757919e", "patch": "@@ -29,83 +29,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimple-pretty-print.h\"\n #include \"gimple-range.h\"\n \n-// Calculate what we can determine of the range of this unary\n-// statement's operand if the lhs of the expression has the range\n-// LHS_RANGE.  Return false if nothing can be determined.\n-\n-bool\n-gimple_range_calc_op1 (vrange &r, const gimple *stmt, const vrange &lhs_range)\n-{\n-  gcc_checking_assert (gimple_num_ops (stmt) < 3);\n-  // Give up on empty ranges.\n-  if (lhs_range.undefined_p ())\n-    return false;\n-\n-  // Unary operations require the type of the first operand in the\n-  // second range position.\n-  tree type = TREE_TYPE (gimple_range_operand1 (stmt));\n-  Value_Range type_range (type);\n-  type_range.set_varying (type);\n-  return range_op_handler (stmt).op1_range (r, type, lhs_range, type_range);\n-}\n-\n-// Calculate what we can determine of the range of this statement's\n-// first operand if the lhs of the expression has the range LHS_RANGE\n-// and the second operand has the range OP2_RANGE.  Return false if\n-// nothing can be determined.\n-\n-bool\n-gimple_range_calc_op1 (vrange &r, const gimple *stmt,\n-\t\t       const vrange &lhs_range, const vrange &op2_range)\n-{\n-  // Give up on empty ranges.\n-  if (lhs_range.undefined_p ())\n-    return false;\n-\n-  // Unary operation are allowed to pass a range in for second operand\n-  // as there are often additional restrictions beyond the type which\n-  // can be imposed.  See operator_cast::op1_range().\n-  tree type = TREE_TYPE (gimple_range_operand1 (stmt));\n-  // If op2 is undefined, solve as if it is varying.\n-  if (op2_range.undefined_p ())\n-    {\n-      // This is sometimes invoked on single operand stmts.\n-      if (gimple_num_ops (stmt) < 3)\n-\treturn false;\n-      tree op2_type = TREE_TYPE (gimple_range_operand2 (stmt));\n-      Value_Range trange (op2_type);\n-      trange.set_varying (op2_type);\n-      return range_op_handler (stmt).op1_range (r, type, lhs_range, trange);\n-    }\n-  return range_op_handler (stmt).op1_range (r, type, lhs_range, op2_range);\n-}\n-\n-// Calculate what we can determine of the range of this statement's\n-// second operand if the lhs of the expression has the range LHS_RANGE\n-// and the first operand has the range OP1_RANGE.  Return false if\n-// nothing can be determined.\n-\n-bool\n-gimple_range_calc_op2 (vrange &r, const gimple *stmt,\n-\t\t       const vrange &lhs_range, const vrange &op1_range)\n-{\n-  // Give up on empty ranges.\n-  if (lhs_range.undefined_p ())\n-    return false;\n-\n-  tree type = TREE_TYPE (gimple_range_operand2 (stmt));\n-  // If op1 is undefined, solve as if it is varying.\n-  if (op1_range.undefined_p ())\n-    {\n-      tree op1_type = TREE_TYPE (gimple_range_operand1 (stmt));\n-      Value_Range trange (op1_type);\n-      trange.set_varying (op1_type);\n-      return range_op_handler (stmt).op2_range (r, type, lhs_range, trange);\n-    }\n-  return range_op_handler (stmt).op2_range (r, type, lhs_range,\n-\t\t\t\t\t    op1_range);\n-}\n-\n // Return TRUE if GS is a logical && or || expression.\n \n static inline bool\n@@ -695,17 +618,18 @@ gori_compute::compute_operand_range (vrange &r, gimple *stmt,\n   if (is_a<gswitch *> (stmt))\n     return compute_operand_range_switch (r, as_a<gswitch *> (stmt), lhs, name,\n \t\t\t\t\t src);\n-  if (!range_op_handler (stmt))\n+  gimple_range_op_handler handler (stmt);\n+  if (!handler)\n     return false;\n \n-  tree op1 = gimple_range_ssa_p (gimple_range_operand1 (stmt));\n-  tree op2 = gimple_range_ssa_p (gimple_range_operand2 (stmt));\n+  tree op1 = gimple_range_ssa_p (handler.operand1 ());\n+  tree op2 = gimple_range_ssa_p (handler.operand2 ());\n \n   // Handle end of lookup first.\n   if (op1 == name)\n-    return compute_operand1_range (r, stmt, lhs, name, src);\n+    return compute_operand1_range (r, handler, lhs, name, src);\n   if (op2 == name)\n-    return compute_operand2_range (r, stmt, lhs, name, src);\n+    return compute_operand2_range (r, handler, lhs, name, src);\n \n   // NAME is not in this stmt, but one of the names in it ought to be\n   // derived from it.\n@@ -733,10 +657,10 @@ gori_compute::compute_operand_range (vrange &r, gimple *stmt,\n       tree type = TREE_TYPE (name);\n       Value_Range op1_trange (type), op1_frange (type);\n       Value_Range op2_trange (type), op2_frange (type);\n-      compute_logical_operands (op1_trange, op1_frange, stmt,\n+      compute_logical_operands (op1_trange, op1_frange, handler,\n \t\t\t\tas_a <irange> (lhs),\n \t\t\t\tname, src, op1, op1_in_chain);\n-      compute_logical_operands (op2_trange, op2_frange, stmt,\n+      compute_logical_operands (op2_trange, op2_frange, handler,\n \t\t\t\tas_a <irange> (lhs),\n \t\t\t\tname, src, op2, op2_in_chain);\n       res = logical_combine (r,\n@@ -748,11 +672,11 @@ gori_compute::compute_operand_range (vrange &r, gimple *stmt,\n     }\n   // Follow the appropriate operands now.\n   else if (op1_in_chain && op2_in_chain)\n-    res = compute_operand1_and_operand2_range (r, stmt, lhs, name, src);\n+    res = compute_operand1_and_operand2_range (r, handler, lhs, name, src);\n   else if (op1_in_chain)\n-    res = compute_operand1_range (r, stmt, lhs, name, src);\n+    res = compute_operand1_range (r, handler, lhs, name, src);\n   else if (op2_in_chain)\n-    res = compute_operand2_range (r, stmt, lhs, name, src);\n+    res = compute_operand2_range (r, handler, lhs, name, src);\n   else\n     gcc_unreachable ();\n \n@@ -944,13 +868,14 @@ gori_compute::logical_combine (vrange &r, enum tree_code code,\n \n void\n gori_compute::compute_logical_operands (vrange &true_range, vrange &false_range,\n-\t\t\t\t\tgimple *stmt,\n+\t\t\t\t\tgimple_range_op_handler &handler,\n \t\t\t\t\tconst irange &lhs,\n \t\t\t\t\ttree name, fur_source &src,\n \t\t\t\t\ttree op, bool op_in_chain)\n {\n+  gimple *stmt = handler.stmt ();\n   gimple *src_stmt = gimple_range_ssa_p (op) ? SSA_NAME_DEF_STMT (op) : NULL;\n-  if (!op_in_chain || !src_stmt || chain_import_p (gimple_get_lhs (stmt), op))\n+  if (!op_in_chain || !src_stmt || chain_import_p (handler.lhs (), op))\n     {\n       // If op is not in the def chain, or defined in this block,\n       // use its known value on entry to the block.\n@@ -999,12 +924,15 @@ gori_compute::compute_logical_operands (vrange &true_range, vrange &false_range,\n // R, or false if no range could be calculated.\n \n bool\n-gori_compute::compute_operand1_range (vrange &r, gimple *stmt,\n+gori_compute::compute_operand1_range (vrange &r,\n+\t\t\t\t      gimple_range_op_handler &handler,\n \t\t\t\t      const vrange &lhs, tree name,\n \t\t\t\t      fur_source &src)\n {\n-  tree op1 = gimple_range_operand1 (stmt);\n-  tree op2 = gimple_range_operand2 (stmt);\n+  gimple *stmt = handler.stmt ();\n+  tree op1 = handler.operand1 ();\n+  tree op2 = handler.operand2 ();\n+\n   Value_Range op1_range (TREE_TYPE (op1));\n   Value_Range tmp (TREE_TYPE (op1));\n   Value_Range op2_range (op2 ? TREE_TYPE (op2) : TREE_TYPE (op1));\n@@ -1016,15 +944,15 @@ gori_compute::compute_operand1_range (vrange &r, gimple *stmt,\n   if (op2)\n     {\n       src.get_operand (op2_range, op2);\n-      if (!gimple_range_calc_op1 (tmp, stmt, lhs, op2_range))\n+      if (!handler.calc_op1 (tmp, lhs, op2_range))\n \treturn false;\n     }\n   else\n     {\n       // We pass op1_range to the unary operation.  Nomally it's a\n       // hidden range_for_type parameter, but sometimes having the\n       // actual range can result in better information.\n-      if (!gimple_range_calc_op1 (tmp, stmt, lhs, op1_range))\n+      if (!handler.calc_op1 (tmp, lhs, op1_range))\n \treturn false;\n     }\n \n@@ -1079,12 +1007,15 @@ gori_compute::compute_operand1_range (vrange &r, gimple *stmt,\n // R, or false if no range could be calculated.\n \n bool\n-gori_compute::compute_operand2_range (vrange &r, gimple *stmt,\n+gori_compute::compute_operand2_range (vrange &r,\n+\t\t\t\t      gimple_range_op_handler &handler,\n \t\t\t\t      const vrange &lhs, tree name,\n \t\t\t\t      fur_source &src)\n {\n-  tree op1 = gimple_range_operand1 (stmt);\n-  tree op2 = gimple_range_operand2 (stmt);\n+  gimple *stmt = handler.stmt ();\n+  tree op1 = handler.operand1 ();\n+  tree op2 = handler.operand2 ();\n+\n   Value_Range op1_range (TREE_TYPE (op1));\n   Value_Range op2_range (TREE_TYPE (op2));\n   Value_Range tmp (TREE_TYPE (op2));\n@@ -1093,7 +1024,7 @@ gori_compute::compute_operand2_range (vrange &r, gimple *stmt,\n   src.get_operand (op2_range, op2);\n \n   // Intersect with range for op2 based on lhs and op1.\n-  if (!gimple_range_calc_op2 (tmp, stmt, lhs, op1_range))\n+  if (!handler.calc_op2 (tmp, lhs, op1_range))\n     return false;\n \n   unsigned idx;\n@@ -1148,7 +1079,8 @@ gori_compute::compute_operand2_range (vrange &r, gimple *stmt,\n \n bool\n gori_compute::compute_operand1_and_operand2_range (vrange &r,\n-\t\t\t\t\t\t   gimple *stmt,\n+\t\t\t\t\t\t   gimple_range_op_handler\n+\t\t\t\t\t\t\t\t     &handler,\n \t\t\t\t\t\t   const vrange &lhs,\n \t\t\t\t\t\t   tree name,\n \t\t\t\t\t\t   fur_source &src)\n@@ -1157,11 +1089,11 @@ gori_compute::compute_operand1_and_operand2_range (vrange &r,\n \n   // Calculate a good a range for op2.  Since op1 == op2, this will\n   // have already included whatever the actual range of name is.\n-  if (!compute_operand2_range (op_range, stmt, lhs, name, src))\n+  if (!compute_operand2_range (op_range, handler, lhs, name, src))\n     return false;\n \n   // Now get the range thru op1.\n-  if (!compute_operand1_range (r, stmt, lhs, name, src))\n+  if (!compute_operand1_range (r, handler, lhs, name, src))\n     return false;\n \n   // Both operands have to be simultaneously true, so perform an intersection."}, {"sha": "0c776ef853f749806270afafd00a4a3d19ae86ae", "filename": "gcc/gimple-range-gori.h", "status": "modified", "additions": 9, "deletions": 18, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51ce06385bf259a092f830f1a6dcc4b98757919e/gcc%2Fgimple-range-gori.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51ce06385bf259a092f830f1a6dcc4b98757919e/gcc%2Fgimple-range-gori.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-gori.h?ref=51ce06385bf259a092f830f1a6dcc4b98757919e", "patch": "@@ -170,17 +170,18 @@ class gori_compute : public gori_map\n \t\t\t      tree name, class fur_source &src);\n   bool compute_operand_range_switch (vrange &r, gswitch *s, const vrange &lhs,\n \t\t\t\t     tree name, fur_source &src);\n-  bool compute_operand1_range (vrange &r, gimple *stmt, const vrange &lhs,\n-\t\t\t       tree name, fur_source &src);\n-  bool compute_operand2_range (vrange &r, gimple *stmt, const vrange &lhs,\n-\t\t\t       tree name, fur_source &src);\n-  bool compute_operand1_and_operand2_range (vrange &r, gimple *stmt,\n+  bool compute_operand1_range (vrange &r, gimple_range_op_handler &handler,\n+\t\t\t       const vrange &lhs, tree name, fur_source &src);\n+  bool compute_operand2_range (vrange &r, gimple_range_op_handler &handler,\n+\t\t\t       const vrange &lhs, tree name, fur_source &src);\n+  bool compute_operand1_and_operand2_range (vrange &r,\n+\t\t\t\t\t    gimple_range_op_handler &handler,\n \t\t\t\t\t    const vrange &lhs, tree name,\n \t\t\t\t\t    fur_source &src);\n   void compute_logical_operands (vrange &true_range, vrange &false_range,\n-\t\t\t\t gimple *stmt, const irange &lhs,\n-\t\t\t\t tree name, fur_source &src, tree op,\n-\t\t\t\t bool op_in_chain);\n+\t\t\t\t gimple_range_op_handler &handler,\n+\t\t\t\t const irange &lhs, tree name, fur_source &src,\n+\t\t\t\t tree op, bool op_in_chain);\n   bool logical_combine (vrange &r, enum tree_code code, const irange &lhs,\n \t\t\tconst vrange &op1_true, const vrange &op1_false,\n \t\t\tconst vrange &op2_true, const vrange &op2_false);\n@@ -192,16 +193,6 @@ class gori_compute : public gori_map\n   int m_not_executable_flag;\n };\n \n-// These routines provide a GIMPLE interface to the range-ops code.\n-extern bool gimple_range_calc_op1 (vrange &r, const gimple *s,\n-\t\t\t\t   const vrange &lhs_range);\n-extern bool gimple_range_calc_op1 (vrange &r, const gimple *s,\n-\t\t\t\t   const vrange &lhs_range,\n-\t\t\t\t   const vrange &op2_range);\n-extern bool gimple_range_calc_op2 (vrange &r, const gimple *s,\n-\t\t\t\t   const vrange &lhs_range,\n-\t\t\t\t   const vrange &op1_range);\n-\n // For each name that is an import into BB's exports..\n #define FOR_EACH_GORI_IMPORT_NAME(gori, bb, name)\t\t\t\\\n   for (gori_export_iterator iter ((gori).imports ((bb)));\t\\"}, {"sha": "f03125a0fc58115124e9ccfb6bdc1f4c6ee19f62", "filename": "gcc/gimple-range-op.cc", "status": "added", "additions": 245, "deletions": 0, "changes": 245, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51ce06385bf259a092f830f1a6dcc4b98757919e/gcc%2Fgimple-range-op.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51ce06385bf259a092f830f1a6dcc4b98757919e/gcc%2Fgimple-range-op.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-op.cc?ref=51ce06385bf259a092f830f1a6dcc4b98757919e", "patch": "@@ -0,0 +1,245 @@\n+/* Code for GIMPLE range op related routines.\n+   Copyright (C) 2019-2022 Free Software Foundation, Inc.\n+   Contributed by Andrew MacLeod <amacleod@redhat.com>\n+   and Aldy Hernandez <aldyh@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"backend.h\"\n+#include \"insn-codes.h\"\n+#include \"tree.h\"\n+#include \"gimple.h\"\n+#include \"ssa.h\"\n+#include \"gimple-pretty-print.h\"\n+#include \"optabs-tree.h\"\n+#include \"gimple-iterator.h\"\n+#include \"gimple-fold.h\"\n+#include \"wide-int.h\"\n+#include \"fold-const.h\"\n+#include \"case-cfn-macros.h\"\n+#include \"omp-general.h\"\n+#include \"cfgloop.h\"\n+#include \"tree-ssa-loop.h\"\n+#include \"tree-scalar-evolution.h\"\n+#include \"langhooks.h\"\n+#include \"vr-values.h\"\n+#include \"range.h\"\n+#include \"value-query.h\"\n+#include \"gimple-range.h\"\n+\n+// Given stmt S, fill VEC, up to VEC_SIZE elements, with relevant ssa-names\n+// on the statement.  For efficiency, it is an error to not pass in enough\n+// elements for the vector.  Return the number of ssa-names.\n+\n+unsigned\n+gimple_range_ssa_names (tree *vec, unsigned vec_size, gimple *stmt)\n+{\n+  tree ssa;\n+  int count = 0;\n+\n+  gimple_range_op_handler handler (stmt);\n+  if (handler)\n+    {\n+      gcc_checking_assert (vec_size >= 2);\n+      if ((ssa = gimple_range_ssa_p (handler.operand1 ())))\n+\tvec[count++] = ssa;\n+      if ((ssa = gimple_range_ssa_p (handler.operand2 ())))\n+\tvec[count++] = ssa;\n+    }\n+  else if (is_a<gassign *> (stmt)\n+\t   && gimple_assign_rhs_code (stmt) == COND_EXPR)\n+    {\n+      gcc_checking_assert (vec_size >= 3);\n+      gassign *st = as_a<gassign *> (stmt);\n+      if ((ssa = gimple_range_ssa_p (gimple_assign_rhs1 (st))))\n+\tvec[count++] = ssa;\n+      if ((ssa = gimple_range_ssa_p (gimple_assign_rhs2 (st))))\n+\tvec[count++] = ssa;\n+      if ((ssa = gimple_range_ssa_p (gimple_assign_rhs3 (st))))\n+\tvec[count++] = ssa;\n+    }\n+  return count;\n+}\n+\n+// Return the base of the RHS of an assignment.\n+\n+static tree\n+gimple_range_base_of_assignment (const gimple *stmt)\n+{\n+  gcc_checking_assert (gimple_code (stmt) == GIMPLE_ASSIGN);\n+  tree op1 = gimple_assign_rhs1 (stmt);\n+  if (gimple_assign_rhs_code (stmt) == ADDR_EXPR)\n+    return get_base_address (TREE_OPERAND (op1, 0));\n+  return op1;\n+}\n+\n+// If statement is supported by range-ops, set the CODE and return the TYPE.\n+\n+static tree\n+get_code_and_type (gimple *s, enum tree_code &code)\n+{\n+  tree type = NULL_TREE;\n+  code = NOP_EXPR;\n+\n+  if (const gassign *ass = dyn_cast<const gassign *> (s))\n+    {\n+      code = gimple_assign_rhs_code (ass);\n+      // The LHS of a comparison is always an int, so we must look at\n+      // the operands.\n+      if (TREE_CODE_CLASS (code) == tcc_comparison)\n+\ttype = TREE_TYPE (gimple_assign_rhs1 (ass));\n+      else\n+\ttype = TREE_TYPE (gimple_assign_lhs (ass));\n+    }\n+  else if (const gcond *cond = dyn_cast<const gcond *> (s))\n+    {\n+      code = gimple_cond_code (cond);\n+      type = TREE_TYPE (gimple_cond_lhs (cond));\n+    }\n+  return type;\n+}\n+\n+// If statement S has a supported range_op handler return TRUE.\n+\n+bool\n+gimple_range_op_handler::supported_p (gimple *s)\n+{\n+  enum tree_code code;\n+  tree type = get_code_and_type (s, code);\n+  return (type && range_op_handler (code, type));\n+}\n+\n+// Construct a handler object for statement S.\n+\n+gimple_range_op_handler::gimple_range_op_handler (gimple *s)\n+{\n+  enum tree_code code;\n+  tree type = get_code_and_type (s, code);\n+  m_stmt = s;\n+  if (type)\n+    set_op_handler (code, type);\n+\n+  if (m_valid)\n+    switch (gimple_code (m_stmt))\n+      {\n+\tcase GIMPLE_COND:\n+\t  m_op1 = gimple_cond_lhs (m_stmt);\n+\t  m_op2 = gimple_cond_rhs (m_stmt);\n+\t  break;\n+\tcase GIMPLE_ASSIGN:\n+\t  m_op1 = gimple_range_base_of_assignment (m_stmt);\n+\t  if (m_op1 && TREE_CODE (m_op1) == MEM_REF)\n+\t    {\n+\t      // If the base address is an SSA_NAME, we return it\n+\t      // here.  This allows processing of the range of that\n+\t      // name, while the rest of the expression is simply\n+\t      // ignored.  The code in range_ops will see the\n+\t      // ADDR_EXPR and do the right thing.\n+\t      tree ssa = TREE_OPERAND (m_op1, 0);\n+\t      if (TREE_CODE (ssa) == SSA_NAME)\n+\t\tm_op1 = ssa;\n+\t    }\n+\t  if (gimple_num_ops (m_stmt) >= 3)\n+\t    m_op2 = gimple_assign_rhs2 (m_stmt);\n+\t  else\n+\t    m_op2 = NULL_TREE;\n+\t  break;\n+\tdefault:\n+\t  m_op1 = NULL_TREE;\n+\t  m_op2 = NULL_TREE;\n+\t  break;\n+      }\n+}\n+\n+// Calculate what we can determine of the range of this unary\n+// statement's operand if the lhs of the expression has the range\n+// LHS_RANGE.  Return false if nothing can be determined.\n+\n+bool\n+gimple_range_op_handler::calc_op1 (vrange &r, const vrange &lhs_range)\n+{\n+  gcc_checking_assert (gimple_num_ops (m_stmt) < 3);\n+  // Give up on empty ranges.\n+  if (lhs_range.undefined_p ())\n+    return false;\n+\n+  // Unary operations require the type of the first operand in the\n+  // second range position.\n+  tree type = TREE_TYPE (operand1 ());\n+  Value_Range type_range (type);\n+  type_range.set_varying (type);\n+  return op1_range (r, type, lhs_range, type_range);\n+}\n+\n+// Calculate what we can determine of the range of this statement's\n+// first operand if the lhs of the expression has the range LHS_RANGE\n+// and the second operand has the range OP2_RANGE.  Return false if\n+// nothing can be determined.\n+\n+bool\n+gimple_range_op_handler::calc_op1 (vrange &r, const vrange &lhs_range,\n+\t\t\t\t   const vrange &op2_range)\n+{\n+  // Give up on empty ranges.\n+  if (lhs_range.undefined_p ())\n+    return false;\n+\n+  // Unary operation are allowed to pass a range in for second operand\n+  // as there are often additional restrictions beyond the type which\n+  // can be imposed.  See operator_cast::op1_range().\n+  tree type = TREE_TYPE (operand1 ());\n+  // If op2 is undefined, solve as if it is varying.\n+  if (op2_range.undefined_p ())\n+    {\n+      // This is sometimes invoked on single operand stmts.\n+      if (gimple_num_ops (m_stmt) < 3)\n+\treturn false;\n+      tree op2_type = TREE_TYPE (operand2 ());\n+      Value_Range trange (op2_type);\n+      trange.set_varying (op2_type);\n+      return op1_range (r, type, lhs_range, trange);\n+    }\n+  return op1_range (r, type, lhs_range, op2_range);\n+}\n+\n+// Calculate what we can determine of the range of this statement's\n+// second operand if the lhs of the expression has the range LHS_RANGE\n+// and the first operand has the range OP1_RANGE.  Return false if\n+// nothing can be determined.\n+\n+bool\n+gimple_range_op_handler::calc_op2 (vrange &r, const vrange &lhs_range,\n+\t\t\t\t   const vrange &op1_range)\n+{\n+  // Give up on empty ranges.\n+  if (lhs_range.undefined_p ())\n+    return false;\n+\n+  tree type = TREE_TYPE (operand2 ());\n+  // If op1 is undefined, solve as if it is varying.\n+  if (op1_range.undefined_p ())\n+    {\n+      tree op1_type = TREE_TYPE (operand1 ());\n+      Value_Range trange (op1_type);\n+      trange.set_varying (op1_type);\n+      return op2_range (r, type, lhs_range, trange);\n+    }\n+  return op2_range (r, type, lhs_range, op1_range);\n+}"}, {"sha": "8bc0a8fbe114ad04e703abaad867864a1559b8d7", "filename": "gcc/gimple-range-op.h", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51ce06385bf259a092f830f1a6dcc4b98757919e/gcc%2Fgimple-range-op.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51ce06385bf259a092f830f1a6dcc4b98757919e/gcc%2Fgimple-range-op.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-op.h?ref=51ce06385bf259a092f830f1a6dcc4b98757919e", "patch": "@@ -0,0 +1,51 @@\n+/* Header file for the GIMPLE range-op interface.\n+   Copyright (C) 2022 Free Software Foundation, Inc.\n+   Contributed by Andrew MacLeod <amacleod@redhat.com>\n+   and Aldy Hernandez <aldyh@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_GIMPLE_RANGE_OP_H\n+#define GCC_GIMPLE_RANGE_OP_H\n+\n+#include \"range-op.h\"\n+\n+\n+class gimple_range_op_handler : public range_op_handler\n+{\n+public:\n+  static bool supported_p (gimple *s);\n+  gimple_range_op_handler (gimple *s);\n+  inline gimple *stmt () const { return m_stmt; }\n+  inline tree lhs () const { return gimple_get_lhs (m_stmt); }\n+  tree operand1 () const { gcc_checking_assert (m_valid); return m_op1; }\n+  tree operand2 () const { gcc_checking_assert (m_valid); return m_op2; }\n+  bool calc_op1 (vrange &r, const vrange &lhs_range);\n+  bool calc_op1 (vrange &r, const vrange &lhs_range, const vrange &op2_range);\n+  bool calc_op2 (vrange &r, const vrange &lhs_range, const vrange &op1_range);\n+private:\n+  gimple *m_stmt;\n+  tree m_op1, m_op2;\n+};\n+\n+// Given stmt S, fill VEC, up to VEC_SIZE elements, with relevant ssa-names\n+// on the statement.  For efficiency, it is an error to not pass in enough\n+// elements for the vector.  Return the number of ssa-names.\n+\n+unsigned gimple_range_ssa_names (tree *vec, unsigned vec_size, gimple *stmt);\n+\n+#endif // GCC_GIMPLE_RANGE_OP_H"}, {"sha": "d67d6499c780637abe7027deb5db27082661193e", "filename": "gcc/gimple-range.cc", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51ce06385bf259a092f830f1a6dcc4b98757919e/gcc%2Fgimple-range.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51ce06385bf259a092f830f1a6dcc4b98757919e/gcc%2Fgimple-range.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range.cc?ref=51ce06385bf259a092f830f1a6dcc4b98757919e", "patch": "@@ -341,7 +341,7 @@ gimple_ranger::prefill_name (vrange &r, tree name)\n   if (!gimple_range_ssa_p (name))\n     return;\n   gimple *stmt = SSA_NAME_DEF_STMT (name);\n-  if (!range_op_handler (stmt) && !is_a<gphi *> (stmt))\n+  if (!gimple_range_op_handler::supported_p (stmt) && !is_a<gphi *> (stmt))\n     return;\n \n   bool current;\n@@ -364,7 +364,7 @@ gimple_ranger::prefill_stmt_dependencies (tree ssa)\n   gcc_checking_assert (stmt && gimple_bb (stmt));\n \n   // Only pre-process range-ops and phis.\n-  if (!range_op_handler (stmt) && !is_a<gphi *> (stmt))\n+  if (!gimple_range_op_handler::supported_p (stmt) && !is_a<gphi *> (stmt))\n     return;\n \n   // Mark where on the stack we are starting.\n@@ -422,14 +422,15 @@ gimple_ranger::prefill_stmt_dependencies (tree ssa)\n \t}\n       else\n \t{\n-\t  gcc_checking_assert (range_op_handler (stmt));\n-\t  tree op = gimple_range_operand2 (stmt);\n+\t  gimple_range_op_handler handler (stmt);\n+\t  gcc_checking_assert (handler);\n+\t  tree op = handler.operand2 ();\n \t  if (op)\n \t    {\n \t      Value_Range r (TREE_TYPE (op));\n \t      prefill_name (r, op);\n \t    }\n-\t  op = gimple_range_operand1 (stmt);\n+\t  op = handler.operand1 ();\n \t  if (op)\n \t    {\n \t      Value_Range r (TREE_TYPE (op));"}, {"sha": "8b2ff5685e5160a089b323b9e262acc649db23ed", "filename": "gcc/gimple-range.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51ce06385bf259a092f830f1a6dcc4b98757919e/gcc%2Fgimple-range.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51ce06385bf259a092f830f1a6dcc4b98757919e/gcc%2Fgimple-range.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range.h?ref=51ce06385bf259a092f830f1a6dcc4b98757919e", "patch": "@@ -24,7 +24,7 @@ along with GCC; see the file COPYING3.  If not see\n \n #include \"range.h\"\n #include \"value-query.h\"\n-#include \"range-op.h\"\n+#include \"gimple-range-op.h\"\n #include \"gimple-range-trace.h\"\n #include \"gimple-range-edge.h\"\n #include \"gimple-range-fold.h\""}, {"sha": "9ae42b8331ff549d948b160654fd03ef1c189875", "filename": "gcc/range-op.cc", "status": "modified", "additions": 7, "deletions": 30, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51ce06385bf259a092f830f1a6dcc4b98757919e/gcc%2Frange-op.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51ce06385bf259a092f830f1a6dcc4b98757919e/gcc%2Frange-op.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frange-op.cc?ref=51ce06385bf259a092f830f1a6dcc4b98757919e", "patch": "@@ -4182,42 +4182,19 @@ range_op_handler::set_op_handler (tree_code code, tree type)\n     }\n }\n \n-range_op_handler::range_op_handler (tree_code code, tree type)\n+range_op_handler::range_op_handler ()\n {\n-  set_op_handler (code, type);\n+  m_int = NULL;\n+  m_float = NULL;\n+  m_valid = false;\n }\n \n-range_op_handler::range_op_handler (const gimple *s)\n+range_op_handler::range_op_handler (tree_code code, tree type)\n {\n-  tree_code code = NOP_EXPR;\n-  tree type = NULL_TREE;\n-\n-  if (const gassign *ass = dyn_cast<const gassign *> (s))\n-    {\n-      code = gimple_assign_rhs_code (ass);\n-      // The LHS of a comparison is always an int, so we must look at\n-      // the operands.\n-      if (TREE_CODE_CLASS (code) == tcc_comparison)\n-\ttype = TREE_TYPE (gimple_assign_rhs1 (ass));\n-      else\n-\ttype = TREE_TYPE (gimple_assign_lhs (ass));\n-    }\n-  else if (const gcond *cond = dyn_cast<const gcond *> (s))\n-    {\n-      code = gimple_cond_code (cond);\n-      type = TREE_TYPE (gimple_cond_lhs (cond));\n-    }\n-\n-  if (!type)\n-    {\n-      m_int = NULL;\n-      m_float = NULL;\n-      m_valid = false;\n-    }\n-  else\n-    set_op_handler (code, type);\n+  set_op_handler (code, type);\n }\n \n+\n bool\n range_op_handler::fold_range (vrange &r, tree type,\n \t\t\t      const vrange &lh,"}, {"sha": "b4b5101a9e0c86147a716f42ee798a28b112fc31", "filename": "gcc/range-op.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51ce06385bf259a092f830f1a6dcc4b98757919e/gcc%2Frange-op.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51ce06385bf259a092f830f1a6dcc4b98757919e/gcc%2Frange-op.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frange-op.h?ref=51ce06385bf259a092f830f1a6dcc4b98757919e", "patch": "@@ -160,8 +160,8 @@ class range_operator_float\n class range_op_handler\n {\n public:\n+  range_op_handler ();\n   range_op_handler (enum tree_code code, tree type);\n-  range_op_handler (const gimple *s);\n   inline operator bool () const { return m_valid; }\n \n   bool fold_range (vrange &r, tree type,\n@@ -185,7 +185,7 @@ class range_op_handler\n \t\t\t\t  const vrange &op2,\n \t\t\t\t  relation_kind = VREL_VARYING) const;\n   relation_kind op1_op2_relation (const vrange &lhs) const;\n-private:\n+protected:\n   void set_op_handler (enum tree_code code, tree type);\n   bool m_valid;\n   range_operator *m_int;"}]}