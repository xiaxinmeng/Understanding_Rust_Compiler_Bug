{"sha": "42a98b43bbd3faf452545871daa49d155dfd03e2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDJhOThiNDNiYmQzZmFmNDUyNTQ1ODcxZGFhNDlkMTU1ZGZkMDNlMg==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2018-07-03T14:47:11Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2018-07-03T14:47:11Z"}, "message": "Reorg line_map data structures for better packing.\n\n\t* include/line-map.h (enum lc_reason): Add LC_HWM.\n\t(LINE_MAP_MAX_LOCATION): Define here.\n\t(struct line_map): Move reason field to line_map_ordinary.  Adjust\n\tGTY tagging.\n\t(struct line_map_ordinary): Reorder fields for less padding.\n\t(struct line_map_macro): Likewise.\n\t(MAP_ORDINARY_P): New.\n\t(linemap_check_ordinary, linemap_check_macro): Adjust.\n\t* line-map.c (LINE_MAP_MAX_SOURCE_LOCATION): Delete.\n\t(new_linemap): Take start_location, not reason.  Adjust.\n\t(linemap_add, linemap_enter_macro): Adjust.\n\t(linemap_line_start): Likewise.\n\t(linemap_macro_expansion_map_p): Use MAP_ORDINARY_P.\n\t(linemap_macro_loc_to_spelling_point): Likewise.\n\t(linemap_macro_loc_to_def_point): Likewise.\n\t(linemap_dump): Likewise.\n\nFrom-SVN: r262348", "tree": {"sha": "4fd357077b47dfab63779852ccc2674c47b4d94c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4fd357077b47dfab63779852ccc2674c47b4d94c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/42a98b43bbd3faf452545871daa49d155dfd03e2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42a98b43bbd3faf452545871daa49d155dfd03e2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/42a98b43bbd3faf452545871daa49d155dfd03e2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42a98b43bbd3faf452545871daa49d155dfd03e2/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "42addb5adfbe872a7dd086db04df3f517a61f1e8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42addb5adfbe872a7dd086db04df3f517a61f1e8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/42addb5adfbe872a7dd086db04df3f517a61f1e8"}], "stats": {"total": 207, "additions": 123, "deletions": 84}, "files": [{"sha": "7412800afc719864ab33d83c0b73523d03b5954f", "filename": "libcpp/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42a98b43bbd3faf452545871daa49d155dfd03e2/libcpp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42a98b43bbd3faf452545871daa49d155dfd03e2/libcpp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2FChangeLog?ref=42a98b43bbd3faf452545871daa49d155dfd03e2", "patch": "@@ -1,3 +1,23 @@\n+2018-07-03  Nathan Sidwell  <nathan@acm.org>\n+\n+\tReorg line_map data structures for better packing.\n+\t* include/line-map.h (enum lc_reason): Add LC_HWM.\n+\t(LINE_MAP_MAX_LOCATION): Define here.\n+\t(struct line_map): Move reason field to line_map_ordinary.  Adjust\n+\tGTY tagging.\n+\t(struct line_map_ordinary): Reorder fields for less padding.\n+\t(struct line_map_macro): Likewise.\n+\t(MAP_ORDINARY_P): New.\n+\t(linemap_check_ordinary, linemap_check_macro): Adjust.\n+\t* line-map.c (LINE_MAP_MAX_SOURCE_LOCATION): Delete.\n+\t(new_linemap): Take start_location, not reason.  Adjust.\n+\t(linemap_add, linemap_enter_macro): Adjust.\n+\t(linemap_line_start): Likewise.\n+\t(linemap_macro_expansion_map_p): Use MAP_ORDINARY_P.\n+\t(linemap_macro_loc_to_spelling_point): Likewise.\n+\t(linemap_macro_loc_to_def_point): Likewise.\n+\t(linemap_dump): Likewise.\n+\n 2018-05-23  Jason Merrill  <jason@redhat.com>\n \n \t* system.h: #include <new> earlier."}, {"sha": "ba1750d3cf1bb3535bd1837dcf01cd2033be6cc1", "filename": "libcpp/include/line-map.h", "status": "modified", "additions": 52, "deletions": 20, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42a98b43bbd3faf452545871daa49d155dfd03e2/libcpp%2Finclude%2Fline-map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42a98b43bbd3faf452545871daa49d155dfd03e2/libcpp%2Finclude%2Fline-map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finclude%2Fline-map.h?ref=42a98b43bbd3faf452545871daa49d155dfd03e2", "patch": "@@ -74,8 +74,9 @@ enum lc_reason\n   LC_LEAVE,\n   LC_RENAME,\n   LC_RENAME_VERBATIM,\n-  LC_ENTER_MACRO\n+  LC_ENTER_MACRO,\n   /* FIXME: add support for stringize and paste.  */\n+  LC_HWM /* High Water Mark.  */\n };\n \n /* The typedef \"source_location\" is a key within the location database,\n@@ -168,7 +169,7 @@ enum lc_reason\n              |   Beyond this point, ordinary linemaps have 0 bits per column:\n              |   each increment of the value corresponds to a new source line.\n              |\n-  0x70000000 | LINE_MAP_MAX_SOURCE_LOCATION\n+  0x70000000 | LINE_MAP_MAX_LOCATION\n              |   Beyond the point, we give up on ordinary maps; attempts to\n              |   create locations in them lead to UNKNOWN_LOCATION (0).\n              |\n@@ -307,6 +308,9 @@ const source_location LINE_MAP_MAX_LOCATION_WITH_PACKED_RANGES = 0x50000000;\n      gcc.dg/plugin/location-overflow-test-*.c.  */\n const source_location LINE_MAP_MAX_LOCATION_WITH_COLS = 0x60000000;\n \n+/* Highest possible source location encoded within an ordinary map.  */\n+const source_location LINE_MAP_MAX_LOCATION = 0x70000000;\n+\n /* A range of source locations.\n \n    Ranges are closed:\n@@ -377,11 +381,13 @@ typedef size_t (*line_map_round_alloc_size_func) (size_t);\n    location of the expansion point of PLUS. That location is mapped in\n    the map that is active right before the location of the invocation\n    of PLUS.  */\n-struct GTY((tag (\"0\"), desc (\"%h.reason == LC_ENTER_MACRO ? 2 : 1\"))) line_map {\n+\n+/* This contains GTY mark-up to support precompiled headers.\n+   line_map is an abstract class, only derived objects exist.  */\n+struct GTY((tag (\"0\"), desc (\"MAP_ORDINARY_P (&%h) ? 1 : 2\"))) line_map {\n   source_location start_location;\n \n-  /* The reason for creation of this line map.  */\n-  ENUM_BITFIELD (lc_reason) reason : CHAR_BIT;\n+  /* Size and alignment is (usually) 4 bytes.  */\n };\n \n /* An ordinary line map encodes physical source locations. Those\n@@ -397,13 +403,12 @@ struct GTY((tag (\"0\"), desc (\"%h.reason == LC_ENTER_MACRO ? 2 : 1\"))) line_map {\n \n    The highest possible source location is MAX_SOURCE_LOCATION.  */\n struct GTY((tag (\"1\"))) line_map_ordinary : public line_map {\n-  const char *to_file;\n-  linenum_type to_line;\n+  /* Base class is 4 bytes.  */\n \n-  /* An index into the set that gives the line mapping at whose end\n-     the current one was included.  File(s) at the bottom of the\n-     include stack have this set to -1.  */\n-  int included_from;\n+  /* 4 bytes of integers, each 1 byte for easy extraction/insertion.  */\n+\n+  /* The reason for creation of this line map.  */\n+  ENUM_BITFIELD (lc_reason) reason : 8;\n \n   /* SYSP is one for a system header, two for a C system header file\n      that therefore needs to be extern \"C\" protected in C++, and zero\n@@ -429,6 +434,18 @@ struct GTY((tag (\"1\"))) line_map_ordinary : public line_map {\n      |                         |    (e.g. 7)           |   (e.g. 5)        |\n      +-------------------------+-----------------------+-------------------+ */\n   unsigned int m_range_bits : 8;\n+\n+  /* Pointer alignment boundary on both 32 and 64-bit systems.  */\n+\n+  const char *to_file;\n+  linenum_type to_line;\n+\n+  /* An index into the set that gives the line mapping at whose end\n+     the current one was included.  File(s) at the bottom of the\n+     include stack have this set to -1.  */\n+  int included_from;\n+\n+  /* Size is 20 or 24 bytes, no padding  */\n };\n \n /* This is the highest possible source location encoded within an\n@@ -443,15 +460,20 @@ struct cpp_hashnode;\n    The offset from START_LOCATION is used to index into\n    MACRO_LOCATIONS; this holds the original location of the token.  */\n struct GTY((tag (\"2\"))) line_map_macro : public line_map {\n-  /* The cpp macro which expansion gave birth to this macro map.  */\n-  struct cpp_hashnode * GTY ((nested_ptr (union tree_node,\n-\t\t\t\t   \"%h ? CPP_HASHNODE (GCC_IDENT_TO_HT_IDENT (%h)) : NULL\",\n-\t\t\t\t   \"%h ? HT_IDENT_TO_GCC_IDENT (HT_NODE (%h)) : NULL\")))\n-    macro;\n+  /* Base is 4 bytes.  */\n \n   /* The number of tokens inside the replacement-list of MACRO.  */\n   unsigned int n_tokens;\n \n+  /* Pointer alignment boundary.  */\n+\n+  /* The cpp macro whose expansion gave birth to this macro map.  */\n+  struct cpp_hashnode *\n+    GTY ((nested_ptr (union tree_node,\n+\t\t      \"%h ? CPP_HASHNODE (GCC_IDENT_TO_HT_IDENT (%h)) : NULL\",\n+\t\t      \"%h ? HT_IDENT_TO_GCC_IDENT (HT_NODE (%h)) : NULL\")))\n+    macro;\n+\n   /* This array of location is actually an array of pairs of\n      locations. The elements inside it thus look like:\n \n@@ -513,6 +535,8 @@ struct GTY((tag (\"2\"))) line_map_macro : public line_map {\n      could have been either a macro or an ordinary map, depending on\n      if we are in a nested expansion context not.  */\n   source_location expansion;\n+\n+  /* Size is 20 or 32 (4 bytes padding on 64-bit).  */\n };\n \n #if CHECKING_P && (GCC_VERSION >= 2007)\n@@ -540,6 +564,14 @@ struct GTY((tag (\"2\"))) line_map_macro : public line_map {\n #define linemap_assert_fails(EXPR) (! (EXPR))\n #endif\n \n+/* Categorize line map kinds.  */\n+\n+inline bool\n+MAP_ORDINARY_P (const line_map *map)\n+{\n+  return map->start_location < LINE_MAP_MAX_LOCATION;\n+}\n+\n /* Return TRUE if MAP encodes locations coming from a macro\n    replacement-list at macro expansion point.  */\n bool\n@@ -552,7 +584,7 @@ linemap_macro_expansion_map_p (const struct line_map *);\n inline line_map_ordinary *\n linemap_check_ordinary (struct line_map *map)\n {\n-  linemap_assert (!linemap_macro_expansion_map_p (map));\n+  linemap_assert (MAP_ORDINARY_P (map));\n   return (line_map_ordinary *)map;\n }\n \n@@ -563,7 +595,7 @@ linemap_check_ordinary (struct line_map *map)\n inline const line_map_ordinary *\n linemap_check_ordinary (const struct line_map *map)\n {\n-  linemap_assert (!linemap_macro_expansion_map_p (map));\n+  linemap_assert (MAP_ORDINARY_P (map));\n   return (const line_map_ordinary *)map;\n }\n \n@@ -572,7 +604,7 @@ linemap_check_ordinary (const struct line_map *map)\n \n inline line_map_macro *linemap_check_macro (line_map *map)\n {\n-  linemap_assert (linemap_macro_expansion_map_p (map));\n+  linemap_assert (!MAP_ORDINARY_P (map));\n   return (line_map_macro *)map;\n }\n \n@@ -582,7 +614,7 @@ inline line_map_macro *linemap_check_macro (line_map *map)\n inline const line_map_macro *\n linemap_check_macro (const line_map *map)\n {\n-  linemap_assert (linemap_macro_expansion_map_p (map));\n+  linemap_assert (!MAP_ORDINARY_P (map));\n   return (const line_map_macro *)map;\n }\n "}, {"sha": "105102268cca6d193bfc09695d95e34863cfe1ac", "filename": "libcpp/line-map.c", "status": "modified", "additions": 51, "deletions": 64, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42a98b43bbd3faf452545871daa49d155dfd03e2/libcpp%2Fline-map.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42a98b43bbd3faf452545871daa49d155dfd03e2/libcpp%2Fline-map.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fline-map.c?ref=42a98b43bbd3faf452545871daa49d155dfd03e2", "patch": "@@ -26,10 +26,6 @@ along with this program; see the file COPYING3.  If not see\n #include \"internal.h\"\n #include \"hashtab.h\"\n \n-/* Highest possible source location encoded within an ordinary or\n-   macro map.  */\n-const source_location LINE_MAP_MAX_SOURCE_LOCATION = 0x70000000;\n-\n static void trace_include (const struct line_maps *, const line_map_ordinary *);\n static const line_map_ordinary * linemap_ordinary_map_lookup (struct line_maps *,\n \t\t\t\t\t\t\t      source_location);\n@@ -378,13 +374,10 @@ linemap_check_files_exited (struct line_maps *set)\n    macro maps are allocated in different memory location.  */\n \n static struct line_map *\n-new_linemap (struct line_maps *set,\n-\t     enum lc_reason reason)\n+new_linemap (struct line_maps *set,  source_location start_location)\n {\n-  /* Depending on this variable, a macro map would be allocated in a\n-     different memory location than an ordinary map.  */\n-  bool macro_map_p = (reason == LC_ENTER_MACRO);\n   struct line_map *result;\n+  bool macro_map_p = start_location >= LINE_MAP_MAX_LOCATION;\n \n   if (LINEMAPS_USED (set, macro_map_p) == LINEMAPS_ALLOCATED (set, macro_map_p))\n     {\n@@ -455,9 +448,10 @@ new_linemap (struct line_maps *set,\n \tresult = &set->info_ordinary.maps[LINEMAPS_USED (set, macro_map_p)];\n     }\n \n+  result->start_location = start_location;\n+\n   LINEMAPS_USED (set, macro_map_p)++;\n \n-  result->reason = reason;\n   return result;\n }\n \n@@ -492,9 +486,9 @@ linemap_add (struct line_maps *set, enum lc_reason reason,\n   else\n     start_location = set->highest_location + 1;\n \n-  linemap_assert (!(LINEMAPS_ORDINARY_USED (set)\n-\t\t    && (start_location\n-\t\t\t< MAP_START_LOCATION (LINEMAPS_LAST_ORDINARY_MAP (set)))));\n+  linemap_assert (!LINEMAPS_ORDINARY_USED (set)\n+\t\t  || (start_location\n+\t\t      >= MAP_START_LOCATION (LINEMAPS_LAST_ORDINARY_MAP (set))));\n \n   /* When we enter the file for the first time reason cannot be\n      LC_RENAME.  */\n@@ -510,7 +504,9 @@ linemap_add (struct line_maps *set, enum lc_reason reason,\n     }\n \n   linemap_assert (reason != LC_ENTER_MACRO);\n-  line_map_ordinary *map = linemap_check_ordinary (new_linemap (set, reason));\n+  line_map_ordinary *map\n+    = linemap_check_ordinary (new_linemap (set, start_location));\n+  map->reason = reason;\n \n   if (to_file && *to_file == '\\0' && reason != LC_RENAME_VERBATIM)\n     to_file = \"<stdin>\";\n@@ -545,7 +541,6 @@ linemap_add (struct line_maps *set, enum lc_reason reason,\n     }\n \n   map->sysp = sysp;\n-  map->start_location = start_location;\n   map->to_file = to_file;\n   map->to_line = to_line;\n   LINEMAPS_ORDINARY_CACHE (set) = LINEMAPS_ORDINARY_USED (set) - 1;\n@@ -626,14 +621,12 @@ linemap_enter_macro (struct line_maps *set, struct cpp_hashnode *macro_node,\n \n   start_location = LINEMAPS_MACRO_LOWEST_LOCATION (set) - num_tokens;\n \n-  if (start_location <= set->highest_line\n-      || start_location > LINEMAPS_MACRO_LOWEST_LOCATION (set))\n+  if (start_location < LINE_MAP_MAX_LOCATION)\n     /* We ran out of macro map space.   */\n     return NULL;\n \n-  map = linemap_check_macro (new_linemap (set, LC_ENTER_MACRO));\n+  map = linemap_check_macro (new_linemap (set, start_location));\n \n-  map->start_location = start_location;\n   map->macro = macro_node;\n   map->n_tokens = num_tokens;\n   map->macro_locations\n@@ -718,7 +711,7 @@ linemap_line_start (struct line_maps *set, linenum_type to_line,\n       || (highest > LINE_MAP_MAX_LOCATION_WITH_PACKED_RANGES\n \t  && map->m_range_bits > 0)\n       || (highest > LINE_MAP_MAX_LOCATION_WITH_COLS\n-\t  && (set->max_column_hint || highest >= LINE_MAP_MAX_SOURCE_LOCATION)))\n+\t  && (set->max_column_hint || highest >= LINE_MAP_MAX_LOCATION)))\n     add_map = true;\n   else\n     max_column_hint = set->max_column_hint;\n@@ -735,7 +728,7 @@ linemap_line_start (struct line_maps *set, linenum_type to_line,\n \t  max_column_hint = 0;\n \t  column_bits = 0;\n \t  range_bits = 0;\n-\t  if (highest > LINE_MAP_MAX_SOURCE_LOCATION)\n+\t  if (highest >= LINE_MAP_MAX_LOCATION)\n \t    return 0;\n \t}\n       else\n@@ -773,7 +766,7 @@ linemap_line_start (struct line_maps *set, linenum_type to_line,\n \n   /* Locations of ordinary tokens are always lower than locations of\n      macro tokens.  */\n-  if (r >= LINEMAPS_MACRO_LOWEST_LOCATION (set))\n+  if (r >= LINE_MAP_MAX_LOCATION)\n     return 0;\n \n   set->highest_line = r;\n@@ -1049,9 +1042,7 @@ linemap_macro_map_lookup (struct line_maps *set, source_location line)\n bool\n linemap_macro_expansion_map_p (const struct line_map *map)\n {\n-  if (!map)\n-    return false;\n-  return (map->reason == LC_ENTER_MACRO);\n+  return map && !MAP_ORDINARY_P (map);\n }\n \n /* If LOCATION is the locus of a token in a replacement-list of a\n@@ -1253,12 +1244,7 @@ linemap_location_from_macro_expansion_p (const struct line_maps *set,\n     location = set->location_adhoc_data_map.data[location\n \t\t\t\t\t\t & MAX_SOURCE_LOCATION].locus;\n \n-  linemap_assert (location <= MAX_SOURCE_LOCATION\n-\t\t  && (set->highest_location\n-\t\t      < LINEMAPS_MACRO_LOWEST_LOCATION (set)));\n-  if (set == NULL)\n-    return false;\n-  return (location > set->highest_location);\n+  return location >= LINE_MAP_MAX_LOCATION;\n }\n \n /* Given two virtual locations *LOC0 and *LOC1, return the first\n@@ -1403,23 +1389,22 @@ linemap_macro_loc_to_spelling_point (struct line_maps *set,\n \t\t\t\t     source_location location,\n \t\t\t\t     const line_map_ordinary **original_map)\n {\n-  struct line_map *map;\n   linemap_assert (set && location >= RESERVED_LOCATION_COUNT);\n \n   while (true)\n     {\n-      map = const_cast <line_map *> (linemap_lookup (set, location));\n-      if (!linemap_macro_expansion_map_p (map))\n-\tbreak;\n+      const struct line_map *map = linemap_lookup (set, location);\n+      if (!map || MAP_ORDINARY_P (map))\n+\t{\n+\t  if (original_map)\n+\t    *original_map = (const line_map_ordinary *)map;\n+\t  break;\n+\t}\n \n-      location\n-\t= linemap_macro_map_loc_unwind_toward_spelling\n-\t    (set, linemap_check_macro (map),\n-\t     location);\n+      location = linemap_macro_map_loc_unwind_toward_spelling\n+\t(set, linemap_check_macro (map), location);\n     }\n \n-  if (original_map)\n-    *original_map = linemap_check_ordinary (map);\n   return location;\n }\n \n@@ -1438,29 +1423,26 @@ linemap_macro_loc_to_def_point (struct line_maps *set,\n \t\t\t\tsource_location location,\n \t\t\t\tconst line_map_ordinary **original_map)\n {\n-  struct line_map *map;\n-\n   linemap_assert (set && location >= RESERVED_LOCATION_COUNT);\n \n-  while (true)\n+  for (;;)\n     {\n-      source_location caret_loc;\n-      if (IS_ADHOC_LOC (location))\n-\tcaret_loc = get_location_from_adhoc_loc (set, location);\n-      else\n-\tcaret_loc = location;\n+      source_location caret_loc = location;\n+      if (IS_ADHOC_LOC (caret_loc))\n+\tcaret_loc = get_location_from_adhoc_loc (set, caret_loc);\n \n-      map = const_cast <line_map *> (linemap_lookup (set, caret_loc));\n-      if (!linemap_macro_expansion_map_p (map))\n-\tbreak;\n+      const line_map *map = linemap_lookup (set, caret_loc);\n+      if (!map || MAP_ORDINARY_P (map))\n+\t{\n+\t  if (original_map)\n+\t    *original_map = (const line_map_ordinary *)map;\n+\t  break;\n+\t}\n \n-      location =\n-\tlinemap_macro_map_loc_to_def_point (linemap_check_macro (map),\n-\t\t\t\t\t    caret_loc);\n+      location = linemap_macro_map_loc_to_def_point\n+\t(linemap_check_macro (map), caret_loc);\n     }\n \n-  if (original_map)\n-    *original_map = linemap_check_ordinary (map);\n   return location;\n }\n \n@@ -1770,24 +1752,29 @@ linemap_expand_location (struct line_maps *set,\n void\n linemap_dump (FILE *stream, struct line_maps *set, unsigned ix, bool is_macro)\n {\n-  const char *lc_reasons_v[LC_ENTER_MACRO + 1]\n+  const char *const lc_reasons_v[LC_HWM]\n       = { \"LC_ENTER\", \"LC_LEAVE\", \"LC_RENAME\", \"LC_RENAME_VERBATIM\",\n \t  \"LC_ENTER_MACRO\" };\n-  const char *reason;\n   const line_map *map;\n+  unsigned reason;\n \n   if (stream == NULL)\n     stream = stderr;\n \n   if (!is_macro)\n-    map = LINEMAPS_ORDINARY_MAP_AT (set, ix);\n+    {\n+      map = LINEMAPS_ORDINARY_MAP_AT (set, ix);\n+      reason = linemap_check_ordinary (map)->reason;\n+    }\n   else\n-    map = LINEMAPS_MACRO_MAP_AT (set, ix);\n-\n-  reason = (map->reason <= LC_ENTER_MACRO) ? lc_reasons_v[map->reason] : \"???\";\n+    {\n+      map = LINEMAPS_MACRO_MAP_AT (set, ix);\n+      reason = LC_ENTER_MACRO;\n+    }\n \n   fprintf (stream, \"Map #%u [%p] - LOC: %u - REASON: %s - SYSP: %s\\n\",\n-\t   ix, (void *) map, map->start_location, reason,\n+\t   ix, (void *) map, map->start_location,\n+\t   reason < LC_HWM ? lc_reasons_v[reason] : \"???\",\n \t   ((!is_macro\n \t     && ORDINARY_MAP_IN_SYSTEM_HEADER_P (linemap_check_ordinary (map)))\n \t    ? \"yes\" : \"no\"));"}]}