{"sha": "a3fb781d4b341c0d50ef1b92cd3e8734e673ef18", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTNmYjc4MWQ0YjM0MWMwZDUwZWYxYjkyY2QzZTg3MzRlNjczZWYxOA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-09-02T12:48:10Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-09-06T06:03:49Z"}, "message": "tree-optimization/102176 - locally compute participating SLP stmts\n\nThis performs local re-computation of participating scalar stmts\nin BB vectorization subgraphs to allow precise computation of\nliveness of scalar stmts after vectorization and thus precise\ncosting.  This treats all extern defs as live but continues\nto optimistically handle scalar defs that we think we can handle\nby lane-extraction even though that can still fail late during\ncode-generation.\n\n2021-09-02  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/102176\n\t* tree-vect-slp.c (vect_slp_gather_vectorized_scalar_stmts):\n\tNew function.\n\t(vect_bb_slp_scalar_cost): Use the computed set of\n\tvectorized scalar stmts instead of relying on the out-of-date\n\tand not accurate PURE_SLP_STMT.\n\t(vect_bb_vectorization_profitable_p): Compute the set\n\tof vectorized scalar stmts.", "tree": {"sha": "552cda965df112d69e56cf81100899d9a499f5b9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/552cda965df112d69e56cf81100899d9a499f5b9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a3fb781d4b341c0d50ef1b92cd3e8734e673ef18", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3fb781d4b341c0d50ef1b92cd3e8734e673ef18", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a3fb781d4b341c0d50ef1b92cd3e8734e673ef18", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3fb781d4b341c0d50ef1b92cd3e8734e673ef18/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "66bba4dc263d42b6a2254b68fe8706302071f880", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66bba4dc263d42b6a2254b68fe8706302071f880", "html_url": "https://github.com/Rust-GCC/gccrs/commit/66bba4dc263d42b6a2254b68fe8706302071f880"}], "stats": {"total": 69, "additions": 64, "deletions": 5}, "files": [{"sha": "024a1c38a2342246d7891db1de5f1d6e6458d5dd", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 64, "deletions": 5, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3fb781d4b341c0d50ef1b92cd3e8734e673ef18/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3fb781d4b341c0d50ef1b92cd3e8734e673ef18/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=a3fb781d4b341c0d50ef1b92cd3e8734e673ef18", "patch": "@@ -5104,6 +5104,42 @@ vect_bb_partition_graph (bb_vec_info bb_vinfo)\n     }\n }\n \n+/* Compute the set of scalar stmts participating in internal and external\n+   nodes.  */\n+\n+static void\n+vect_slp_gather_vectorized_scalar_stmts (vec_info *vinfo, slp_tree node,\n+\t\t\t\t\t hash_set<slp_tree> &visited,\n+\t\t\t\t\t hash_set<stmt_vec_info> &vstmts,\n+\t\t\t\t\t hash_set<stmt_vec_info> &estmts)\n+{\n+  int i;\n+  stmt_vec_info stmt_info;\n+  slp_tree child;\n+\n+  if (visited.add (node))\n+    return;\n+\n+  if (SLP_TREE_DEF_TYPE (node) == vect_internal_def)\n+    {\n+      FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (node), i, stmt_info)\n+\tvstmts.add (stmt_info);\n+\n+      FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), i, child)\n+\tif (child)\n+\t  vect_slp_gather_vectorized_scalar_stmts (vinfo, child, visited,\n+\t\t\t\t\t\t   vstmts, estmts);\n+    }\n+  else\n+    for (tree def : SLP_TREE_SCALAR_OPS (node))\n+      {\n+\tstmt_vec_info def_stmt = vinfo->lookup_def (def);\n+\tif (def_stmt)\n+\t  estmts.add (def_stmt);\n+      }\n+}\n+\n+\n /* Compute the scalar cost of the SLP node NODE and its children\n    and return it.  Do not account defs that are marked in LIFE and\n    update LIFE according to uses of NODE.  */\n@@ -5112,6 +5148,7 @@ static void\n vect_bb_slp_scalar_cost (vec_info *vinfo,\n \t\t\t slp_tree node, vec<bool, va_heap> *life,\n \t\t\t stmt_vector_for_cost *cost_vec,\n+\t\t\t hash_set<stmt_vec_info> &vectorized_scalar_stmts,\n \t\t\t hash_set<slp_tree> &visited)\n {\n   unsigned i;\n@@ -5148,8 +5185,7 @@ vect_bb_slp_scalar_cost (vec_info *vinfo,\n \t\t  {\n \t\t    stmt_vec_info use_stmt_info = vinfo->lookup_stmt (use_stmt);\n \t\t    if (!use_stmt_info\n-\t\t\t|| !PURE_SLP_STMT\n-\t\t\t      (vect_stmt_to_vectorize (use_stmt_info)))\n+\t\t\t|| !vectorized_scalar_stmts.contains (use_stmt_info))\n \t\t      {\n \t\t\t(*life)[i] = true;\n \t\t\tbreak;\n@@ -5212,7 +5248,7 @@ vect_bb_slp_scalar_cost (vec_info *vinfo,\n \t      subtree_life.safe_splice (*life);\n \t    }\n \t  vect_bb_slp_scalar_cost (vinfo, child, &subtree_life, cost_vec,\n-\t\t\t\t   visited);\n+\t\t\t\t   vectorized_scalar_stmts, visited);\n \t  subtree_life.truncate (0);\n \t}\n     }\n@@ -5254,11 +5290,33 @@ vect_bb_vectorization_profitable_p (bb_vec_info bb_vinfo,\n \t\t\t      SLP_INSTANCE_TREE (instance), visited);\n     }\n \n+  /* Compute the set of scalar stmts we know will go away 'locally' when\n+     vectorizing.  This used to be tracked with just PURE_SLP_STMT but that's\n+     not accurate for nodes promoted extern late or for scalar stmts that\n+     are used both in extern defs and in vectorized defs.  */\n+  hash_set<stmt_vec_info> vectorized_scalar_stmts;\n+  hash_set<stmt_vec_info> scalar_stmts_in_externs;\n+  hash_set<slp_tree> visited;\n+  FOR_EACH_VEC_ELT (slp_instances, i, instance)\n+    {\n+      vect_slp_gather_vectorized_scalar_stmts (bb_vinfo,\n+\t\t\t\t\t       SLP_INSTANCE_TREE (instance),\n+\t\t\t\t\t       visited,\n+\t\t\t\t\t       vectorized_scalar_stmts,\n+\t\t\t\t\t       scalar_stmts_in_externs);\n+      for (stmt_vec_info rstmt : SLP_INSTANCE_ROOT_STMTS (instance))\n+\tvectorized_scalar_stmts.add (rstmt);\n+    }\n+  /* Scalar stmts used as defs in external nodes need to be preseved, so\n+     remove them from vectorized_scalar_stmts.  */\n+  for (stmt_vec_info stmt : scalar_stmts_in_externs)\n+    vectorized_scalar_stmts.remove (stmt);\n+\n   /* Calculate scalar cost and sum the cost for the vector stmts\n      previously collected.  */\n   stmt_vector_for_cost scalar_costs = vNULL;\n   stmt_vector_for_cost vector_costs = vNULL;\n-  hash_set<slp_tree> visited;\n+  visited.empty ();\n   FOR_EACH_VEC_ELT (slp_instances, i, instance)\n     {\n       auto_vec<bool, 20> life;\n@@ -5271,7 +5329,8 @@ vect_bb_vectorization_profitable_p (bb_vec_info bb_vinfo,\n \t\t\t  SLP_INSTANCE_ROOT_STMTS (instance)[0], 0, vect_body);\n       vect_bb_slp_scalar_cost (bb_vinfo,\n \t\t\t       SLP_INSTANCE_TREE (instance),\n-\t\t\t       &life, &scalar_costs, visited);\n+\t\t\t       &life, &scalar_costs, vectorized_scalar_stmts,\n+\t\t\t       visited);\n       vector_costs.safe_splice (instance->cost_vec);\n       instance->cost_vec.release ();\n     }"}]}