{"sha": "b7f592fc5d0770f7cebe2d45843538b37077175c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjdmNTkyZmM1ZDA3NzBmN2NlYmUyZDQ1ODQzNTM4YjM3MDc3MTc1Yw==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2017-11-29T13:22:44Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2017-11-29T13:22:44Z"}, "message": "[PATCH] complex type canonicalization\n\n\nhttps://gcc.gnu.org/ml/gcc-patches/2017-11/msg02453.html\n\tPR c++/83817\n\t* tree.c (build_complex_type): Fix canonicalization.  Only fill in\n\ttype if it is new.\n\n\tPR c++/83187\n\t* g++.dg/opt/pr83187.C: New.\n\nFrom-SVN: r255231", "tree": {"sha": "e93b3900066167507691eaf08ec9e34857ed8fd2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e93b3900066167507691eaf08ec9e34857ed8fd2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b7f592fc5d0770f7cebe2d45843538b37077175c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7f592fc5d0770f7cebe2d45843538b37077175c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b7f592fc5d0770f7cebe2d45843538b37077175c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7f592fc5d0770f7cebe2d45843538b37077175c/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e69a816d8f323ba1f2660480da8e73ef3b30780d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e69a816d8f323ba1f2660480da8e73ef3b30780d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e69a816d8f323ba1f2660480da8e73ef3b30780d"}], "stats": {"total": 136, "additions": 90, "deletions": 46}, "files": [{"sha": "d0efe6f98cfa96934c93e0d7417ea9f292e0a531", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7f592fc5d0770f7cebe2d45843538b37077175c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7f592fc5d0770f7cebe2d45843538b37077175c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b7f592fc5d0770f7cebe2d45843538b37077175c", "patch": "@@ -1,3 +1,9 @@\n+2017-11-29  Nathan Sidwell  <nathan@acm.org>\n+\n+\tPR c++/83817\n+\t* tree.c (build_complex_type): Fix canonicalization.  Only fill in\n+\ttype if it is new.\n+\n 2017-11-29  Wilco Dijkstra  <wdijkstr@arm.com>\n \n \t* config/aarch64/aarch64.c (aarch64_print_operand): Add new"}, {"sha": "3b90be1b7b22af67850c7d66121c8c70bbe79c21", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7f592fc5d0770f7cebe2d45843538b37077175c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7f592fc5d0770f7cebe2d45843538b37077175c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b7f592fc5d0770f7cebe2d45843538b37077175c", "patch": "@@ -1,3 +1,8 @@\n+2017-11-29  Nathan Sidwell  <nathan@acm.org>\n+\n+\tPR c++/83187\n+\t* g++.dg/opt/pr83187.C: New.\n+\n 2017-11-29  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR middle-end/83185"}, {"sha": "632d64b18e8bb5c1f1f83e901beea1cd33532cc3", "filename": "gcc/testsuite/g++.dg/opt/pr83187.C", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7f592fc5d0770f7cebe2d45843538b37077175c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fpr83187.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7f592fc5d0770f7cebe2d45843538b37077175c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fpr83187.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fpr83187.C?ref=b7f592fc5d0770f7cebe2d45843538b37077175c", "patch": "@@ -0,0 +1,32 @@\n+// { dg-do compile { target c++11 } }\n+// { dg-additional-options \"-O1 -Wno-pedantic\" }\n+// PR c++/83187 ICE in get_alias_set due to canonical type confusion.\n+\n+extern \"C\" {\n+  double cos (double);\n+  double sin (double);\n+}\n+\n+template <typename> class COMPLEX;\n+\n+template <>\n+struct COMPLEX<double>\n+{\n+  COMPLEX(double r, double i);\n+\n+  __complex__ mem;\n+};\n+\n+COMPLEX<double>::COMPLEX (double r, double i)\n+  : mem {r, i} {}\n+\n+typedef double dbl_t;\n+\n+dbl_t var;\n+\n+void foo (COMPLEX<double> *ptr)\n+{\n+  const dbl_t unused = var;\n+\n+  *ptr = COMPLEX<double> (cos (var), sin (var));\n+}"}, {"sha": "5416866a644a42686a0fdf46d5684b554f7c9f36", "filename": "gcc/tree.c", "status": "modified", "additions": 47, "deletions": 46, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7f592fc5d0770f7cebe2d45843538b37077175c/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7f592fc5d0770f7cebe2d45843538b37077175c/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=b7f592fc5d0770f7cebe2d45843538b37077175c", "patch": "@@ -8083,65 +8083,66 @@ build_offset_type (tree basetype, tree type)\n tree\n build_complex_type (tree component_type, bool named)\n {\n-  tree t;\n-\n   gcc_assert (INTEGRAL_TYPE_P (component_type)\n \t      || SCALAR_FLOAT_TYPE_P (component_type)\n \t      || FIXED_POINT_TYPE_P (component_type));\n \n   /* Make a node of the sort we want.  */\n-  t = make_node (COMPLEX_TYPE);\n+  tree probe = make_node (COMPLEX_TYPE);\n \n-  TREE_TYPE (t) = TYPE_MAIN_VARIANT (component_type);\n+  TREE_TYPE (probe) = TYPE_MAIN_VARIANT (component_type);\n \n   /* If we already have such a type, use the old one.  */\n-  hashval_t hash = type_hash_canon_hash (t);\n-  t = type_hash_canon (hash, t);\n-\n-  if (!COMPLETE_TYPE_P (t))\n-    layout_type (t);\n+  hashval_t hash = type_hash_canon_hash (probe);\n+  tree t = type_hash_canon (hash, probe);\n \n-  if (TYPE_CANONICAL (t) == t)\n+  if (t == probe)\n     {\n-      if (TYPE_STRUCTURAL_EQUALITY_P (component_type))\n+      /* We created a new type.  The hash insertion will have laid\n+\t out the type.  We need to check the canonicalization and\n+\t maybe set the name.  */\n+      gcc_checking_assert (COMPLETE_TYPE_P (t)\n+\t\t\t   && !TYPE_NAME (t)\n+\t\t\t   && TYPE_CANONICAL (t) == t);\n+\n+      if (TYPE_STRUCTURAL_EQUALITY_P (TREE_TYPE (t)))\n \tSET_TYPE_STRUCTURAL_EQUALITY (t);\n-      else if (TYPE_CANONICAL (component_type) != component_type)\n+      else if (TYPE_CANONICAL (TREE_TYPE (t)) != TREE_TYPE (t))\n \tTYPE_CANONICAL (t)\n-\t  = build_complex_type (TYPE_CANONICAL (component_type), named);\n-    }\n-\n-  /* We need to create a name, since complex is a fundamental type.  */\n-  if (!TYPE_NAME (t) && named)\n-    {\n-      const char *name;\n-      if (component_type == char_type_node)\n-\tname = \"complex char\";\n-      else if (component_type == signed_char_type_node)\n-\tname = \"complex signed char\";\n-      else if (component_type == unsigned_char_type_node)\n-\tname = \"complex unsigned char\";\n-      else if (component_type == short_integer_type_node)\n-\tname = \"complex short int\";\n-      else if (component_type == short_unsigned_type_node)\n-\tname = \"complex short unsigned int\";\n-      else if (component_type == integer_type_node)\n-\tname = \"complex int\";\n-      else if (component_type == unsigned_type_node)\n-\tname = \"complex unsigned int\";\n-      else if (component_type == long_integer_type_node)\n-\tname = \"complex long int\";\n-      else if (component_type == long_unsigned_type_node)\n-\tname = \"complex long unsigned int\";\n-      else if (component_type == long_long_integer_type_node)\n-\tname = \"complex long long int\";\n-      else if (component_type == long_long_unsigned_type_node)\n-\tname = \"complex long long unsigned int\";\n-      else\n-\tname = 0;\n+\t  = build_complex_type (TYPE_CANONICAL (TREE_TYPE (t)), named);\n \n-      if (name != 0)\n-\tTYPE_NAME (t) = build_decl (UNKNOWN_LOCATION, TYPE_DECL,\n-\t    \t\t\t    get_identifier (name), t);\n+      /* We need to create a name, since complex is a fundamental type.  */\n+      if (named)\n+\t{\n+\t  const char *name = NULL;\n+\n+\t  if (TREE_TYPE (t) == char_type_node)\n+\t    name = \"complex char\";\n+\t  else if (TREE_TYPE (t) == signed_char_type_node)\n+\t    name = \"complex signed char\";\n+\t  else if (TREE_TYPE (t) == unsigned_char_type_node)\n+\t    name = \"complex unsigned char\";\n+\t  else if (TREE_TYPE (t) == short_integer_type_node)\n+\t    name = \"complex short int\";\n+\t  else if (TREE_TYPE (t) == short_unsigned_type_node)\n+\t    name = \"complex short unsigned int\";\n+\t  else if (TREE_TYPE (t) == integer_type_node)\n+\t    name = \"complex int\";\n+\t  else if (TREE_TYPE (t) == unsigned_type_node)\n+\t    name = \"complex unsigned int\";\n+\t  else if (TREE_TYPE (t) == long_integer_type_node)\n+\t    name = \"complex long int\";\n+\t  else if (TREE_TYPE (t) == long_unsigned_type_node)\n+\t    name = \"complex long unsigned int\";\n+\t  else if (TREE_TYPE (t) == long_long_integer_type_node)\n+\t    name = \"complex long long int\";\n+\t  else if (TREE_TYPE (t) == long_long_unsigned_type_node)\n+\t    name = \"complex long long unsigned int\";\n+\n+\t  if (name != NULL)\n+\t    TYPE_NAME (t) = build_decl (UNKNOWN_LOCATION, TYPE_DECL,\n+\t\t\t\t\tget_identifier (name), t);\n+\t}\n     }\n \n   return build_qualified_type (t, TYPE_QUALS (component_type));"}]}