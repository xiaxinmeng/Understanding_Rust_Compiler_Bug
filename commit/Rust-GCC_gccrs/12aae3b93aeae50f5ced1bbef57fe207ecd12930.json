{"sha": "12aae3b93aeae50f5ced1bbef57fe207ecd12930", "node_id": "C_kwDOANBUbNoAKDEyYWFlM2I5M2FlYWU1MGY1Y2VkMWJiZWY1N2ZlMjA3ZWNkMTI5MzA", "commit": {"author": {"name": "Tamar Christina", "email": "tamar.christina@arm.com", "date": "2022-02-07T12:54:42Z"}, "committer": {"name": "Tamar Christina", "email": "tamar.christina@arm.com", "date": "2022-02-07T12:56:37Z"}, "message": "AArch32: correct dot-product RTL patterns.\n\nThe previous fix for this problem was wrong due to a subtle difference between\nwhere NEON expects the RMW values and where intrinsics expects them.\n\nThe insn pattern is modeled after the intrinsics and so needs an expand for\nthe vectorizer optab to switch the RTL.\n\nHowever operand[3] is not expected to be written to so the current pattern is\nbogus.\n\nInstead we use the expand to shuffle around the RTL.\n\nThe vectorizer expects operands[3] and operands[0] to be\nthe same but the aarch64 intrinsics expanders expect operands[0] and\noperands[1] to be the same.\n\nThis also fixes some issues with big-endian, each dot product performs 4 8-byte\nmultiplications.  However compared to AArch64 we don't enter lanes in GCC\nlane indexed in AArch32 aside from loads/stores.  This means no lane remappings\nare done in arm-builtins.c and so none should be done at the instruction side.\n\nThere are some other instructions that need inspections as I think there are\nmore incorrect ones.\n\nThird there was a bug in the ACLE specication for dot product which has now been\nfixed[1].  This means some intrinsics were missing and are added by this patch.\n\nBootstrapped and regtested on arm-none-linux-gnueabihf and no issues.\n\nOk for master? and active branches after some stew?\n\n[1] https://github.com/ARM-software/acle/releases/tag/r2021Q3\n\ngcc/ChangeLog:\n\n\t* config/arm/arm_neon.h (vdot_laneq_u32, vdotq_laneq_u32,\n\tvdot_laneq_s32, vdotq_laneq_s32): New.\n\t* config/arm/arm_neon_builtins.def (sdot_laneq, udot_laneq): New.\n\t* config/arm/neon.md (neon_<sup>dot<vsi2qi>): New.\n\t(<sup>dot_prod<vsi2qi>): Re-order rtl.\n\t(neon_<sup>dot_lane<vsi2qi>): Fix rtl order and endiannes.\n\t(neon_<sup>dot_laneq<vsi2qi>): New.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.target/arm/simd/vdot-compile.c: Add new cases.\n\t* gcc.target/arm/simd/vdot-exec.c: Likewise.", "tree": {"sha": "ef60abe0688fe7e9f66ea5c6ecf21ebe83cc9742", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ef60abe0688fe7e9f66ea5c6ecf21ebe83cc9742"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/12aae3b93aeae50f5ced1bbef57fe207ecd12930", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12aae3b93aeae50f5ced1bbef57fe207ecd12930", "html_url": "https://github.com/Rust-GCC/gccrs/commit/12aae3b93aeae50f5ced1bbef57fe207ecd12930", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12aae3b93aeae50f5ced1bbef57fe207ecd12930/comments", "author": {"login": "TamarChristinaArm", "id": 48126768, "node_id": "MDQ6VXNlcjQ4MTI2NzY4", "avatar_url": "https://avatars.githubusercontent.com/u/48126768?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TamarChristinaArm", "html_url": "https://github.com/TamarChristinaArm", "followers_url": "https://api.github.com/users/TamarChristinaArm/followers", "following_url": "https://api.github.com/users/TamarChristinaArm/following{/other_user}", "gists_url": "https://api.github.com/users/TamarChristinaArm/gists{/gist_id}", "starred_url": "https://api.github.com/users/TamarChristinaArm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TamarChristinaArm/subscriptions", "organizations_url": "https://api.github.com/users/TamarChristinaArm/orgs", "repos_url": "https://api.github.com/users/TamarChristinaArm/repos", "events_url": "https://api.github.com/users/TamarChristinaArm/events{/privacy}", "received_events_url": "https://api.github.com/users/TamarChristinaArm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TamarChristinaArm", "id": 48126768, "node_id": "MDQ6VXNlcjQ4MTI2NzY4", "avatar_url": "https://avatars.githubusercontent.com/u/48126768?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TamarChristinaArm", "html_url": "https://github.com/TamarChristinaArm", "followers_url": "https://api.github.com/users/TamarChristinaArm/followers", "following_url": "https://api.github.com/users/TamarChristinaArm/following{/other_user}", "gists_url": "https://api.github.com/users/TamarChristinaArm/gists{/gist_id}", "starred_url": "https://api.github.com/users/TamarChristinaArm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TamarChristinaArm/subscriptions", "organizations_url": "https://api.github.com/users/TamarChristinaArm/orgs", "repos_url": "https://api.github.com/users/TamarChristinaArm/repos", "events_url": "https://api.github.com/users/TamarChristinaArm/events{/privacy}", "received_events_url": "https://api.github.com/users/TamarChristinaArm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "db95441cf5399aabc46ca83df19f7290c3e23cb1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db95441cf5399aabc46ca83df19f7290c3e23cb1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db95441cf5399aabc46ca83df19f7290c3e23cb1"}], "stats": {"total": 206, "additions": 145, "deletions": 61}, "files": [{"sha": "fdfea33cf7323881e74dec4969f1569b03dc184a", "filename": "gcc/config/arm/arm_neon.h", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12aae3b93aeae50f5ced1bbef57fe207ecd12930/gcc%2Fconfig%2Farm%2Farm_neon.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12aae3b93aeae50f5ced1bbef57fe207ecd12930/gcc%2Fconfig%2Farm%2Farm_neon.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm_neon.h?ref=12aae3b93aeae50f5ced1bbef57fe207ecd12930", "patch": "@@ -18243,6 +18243,35 @@ vdotq_lane_s32 (int32x4_t __r, int8x16_t __a, int8x8_t __b, const int __index)\n   return __builtin_neon_sdot_lanev16qi (__r, __a, __b, __index);\n }\n \n+__extension__ extern __inline uint32x2_t\n+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n+vdot_laneq_u32 (uint32x2_t __r, uint8x8_t __a, uint8x16_t __b, const int __index)\n+{\n+  return __builtin_neon_udot_laneqv8qi_uuuus (__r, __a, __b, __index);\n+}\n+\n+__extension__ extern __inline uint32x4_t\n+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n+vdotq_laneq_u32 (uint32x4_t __r, uint8x16_t __a, uint8x16_t __b,\n+\t\tconst int __index)\n+{\n+  return __builtin_neon_udot_laneqv16qi_uuuus (__r, __a, __b, __index);\n+}\n+\n+__extension__ extern __inline int32x2_t\n+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n+vdot_laneq_s32 (int32x2_t __r, int8x8_t __a, int8x16_t __b, const int __index)\n+{\n+  return __builtin_neon_sdot_laneqv8qi (__r, __a, __b, __index);\n+}\n+\n+__extension__ extern __inline int32x4_t\n+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n+vdotq_laneq_s32 (int32x4_t __r, int8x16_t __a, int8x16_t __b, const int __index)\n+{\n+  return __builtin_neon_sdot_laneqv16qi (__r, __a, __b, __index);\n+}\n+\n #pragma GCC pop_options\n #endif\n "}, {"sha": "c29ae3a265bf822d71438c19a506d16842e15966", "filename": "gcc/config/arm/arm_neon_builtins.def", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12aae3b93aeae50f5ced1bbef57fe207ecd12930/gcc%2Fconfig%2Farm%2Farm_neon_builtins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12aae3b93aeae50f5ced1bbef57fe207ecd12930/gcc%2Fconfig%2Farm%2Farm_neon_builtins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm_neon_builtins.def?ref=12aae3b93aeae50f5ced1bbef57fe207ecd12930", "patch": "@@ -342,6 +342,8 @@ VAR2 (TERNOP, sdot, v8qi, v16qi)\n VAR2 (UTERNOP, udot, v8qi, v16qi)\n VAR2 (MAC_LANE, sdot_lane, v8qi, v16qi)\n VAR2 (UMAC_LANE, udot_lane, v8qi, v16qi)\n+VAR2 (MAC_LANE, sdot_laneq, v8qi, v16qi)\n+VAR2 (UMAC_LANE, udot_laneq, v8qi, v16qi)\n \n VAR1 (USTERNOP, usdot, v8qi)\n VAR2 (USMAC_LANE_QUADTUP, usdot_lane, v8qi, v16qi)"}, {"sha": "4a8987b49d55935159c75e2339088e6f47ca7ee8", "filename": "gcc/config/arm/neon.md", "status": "modified", "additions": 70, "deletions": 55, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12aae3b93aeae50f5ced1bbef57fe207ecd12930/gcc%2Fconfig%2Farm%2Fneon.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12aae3b93aeae50f5ced1bbef57fe207ecd12930/gcc%2Fconfig%2Farm%2Fneon.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fneon.md?ref=12aae3b93aeae50f5ced1bbef57fe207ecd12930", "patch": "@@ -2866,20 +2866,49 @@\n })\n \n \n-;; These instructions map to the __builtins for the Dot Product operations.\n-(define_insn \"neon_<sup>dot<vsi2qi>\"\n+;; These map to the auto-vectorizer Dot Product optab.\n+;; The auto-vectorizer expects a dot product builtin that also does an\n+;; accumulation into the provided register.\n+;; Given the following pattern\n+;;\n+;; for (i=0; i<len; i++) {\n+;;     c = a[i] * b[i];\n+;;     r += c;\n+;; }\n+;; return result;\n+;;\n+;; This can be auto-vectorized to\n+;; r  = a[0]*b[0] + a[1]*b[1] + a[2]*b[2] + a[3]*b[3];\n+;;\n+;; given enough iterations.  However the vectorizer can keep unrolling the loop\n+;; r += a[4]*b[4] + a[5]*b[5] + a[6]*b[6] + a[7]*b[7];\n+;; r += a[8]*b[8] + a[9]*b[9] + a[10]*b[10] + a[11]*b[11];\n+;; ...\n+;;\n+;; and so the vectorizer provides r, in which the result has to be accumulated.\n+(define_insn \"<sup>dot_prod<vsi2qi>\"\n   [(set (match_operand:VCVTI 0 \"register_operand\" \"=w\")\n-\t(plus:VCVTI (match_operand:VCVTI 1 \"register_operand\" \"0\")\n-\t\t    (unspec:VCVTI [(match_operand:<VSI2QI> 2\n-\t\t\t\t\t\t\t\"register_operand\" \"w\")\n-\t\t\t\t   (match_operand:<VSI2QI> 3\n-\t\t\t\t\t\t\t\"register_operand\" \"w\")]\n-\t\tDOTPROD)))]\n+\t(plus:VCVTI\n+\t  (unspec:VCVTI [(match_operand:<VSI2QI> 1 \"register_operand\" \"w\")\n+\t\t\t (match_operand:<VSI2QI> 2 \"register_operand\" \"w\")]\n+\t\t\t DOTPROD)\n+\t  (match_operand:VCVTI 3 \"register_operand\" \"0\")))]\n   \"TARGET_DOTPROD\"\n-  \"v<sup>dot.<opsuffix>\\\\t%<V_reg>0, %<V_reg>2, %<V_reg>3\"\n+  \"v<sup>dot.<opsuffix>\\\\t%<V_reg>0, %<V_reg>1, %<V_reg>2\"\n   [(set_attr \"type\" \"neon_dot<q>\")]\n )\n \n+;; These instructions map to the __builtins for the Dot Product operations\n+(define_expand \"neon_<sup>dot<vsi2qi>\"\n+  [(set (match_operand:VCVTI 0 \"register_operand\" \"=w\")\n+\t(plus:VCVTI\n+\t  (unspec:VCVTI [(match_operand:<VSI2QI> 2 \"register_operand\")\n+\t\t\t (match_operand:<VSI2QI> 3 \"register_operand\")]\n+\t\t\t DOTPROD)\n+\t  (match_operand:VCVTI 1 \"register_operand\")))]\n+  \"TARGET_DOTPROD\"\n+)\n+\n ;; These instructions map to the __builtins for the Dot Product operations.\n (define_insn \"neon_usdot<vsi2qi>\"\n   [(set (match_operand:VCVTI 0 \"register_operand\" \"=w\")\n@@ -2898,17 +2927,40 @@\n ;; indexed operations.\n (define_insn \"neon_<sup>dot_lane<vsi2qi>\"\n   [(set (match_operand:VCVTI 0 \"register_operand\" \"=w\")\n-\t(plus:VCVTI (match_operand:VCVTI 1 \"register_operand\" \"0\")\n-\t\t    (unspec:VCVTI [(match_operand:<VSI2QI> 2\n-\t\t\t\t\t\t\t\"register_operand\" \"w\")\n-\t\t\t\t   (match_operand:V8QI 3 \"register_operand\" \"t\")\n-\t\t\t\t   (match_operand:SI 4 \"immediate_operand\" \"i\")]\n-\t\tDOTPROD)))]\n+\t(plus:VCVTI\n+\t  (unspec:VCVTI [(match_operand:<VSI2QI> 2 \"register_operand\" \"w\")\n+\t\t\t (match_operand:V8QI 3 \"register_operand\" \"t\")\n+\t\t\t (match_operand:SI 4 \"immediate_operand\" \"i\")]\n+\t\t\t DOTPROD)\n+\t  (match_operand:VCVTI 1 \"register_operand\" \"0\")))]\n+  \"TARGET_DOTPROD\"\n+  \"v<sup>dot.<opsuffix>\\\\t%<V_reg>0, %<V_reg>2, %P3[%c4]\";\n+  [(set_attr \"type\" \"neon_dot<q>\")]\n+)\n+\n+;; These instructions map to the __builtins for the Dot Product\n+;; indexed operations.\n+(define_insn \"neon_<sup>dot_laneq<vsi2qi>\"\n+  [(set (match_operand:VCVTI 0 \"register_operand\" \"=w\")\n+\t(plus:VCVTI\n+\t  (unspec:VCVTI [(match_operand:<VSI2QI> 2 \"register_operand\" \"w\")\n+\t\t\t (match_operand:V16QI 3 \"register_operand\" \"t\")\n+\t\t\t (match_operand:SI 4 \"immediate_operand\" \"i\")]\n+\t\t\t DOTPROD)\n+\t  (match_operand:VCVTI 1 \"register_operand\" \"0\")))]\n   \"TARGET_DOTPROD\"\n   {\n-    operands[4]\n-      = GEN_INT (NEON_ENDIAN_LANE_N (V8QImode, INTVAL (operands[4])));\n-    return \"v<sup>dot.<opsuffix>\\\\t%<V_reg>0, %<V_reg>2, %P3[%c4]\";\n+    int lane = INTVAL (operands[4]);\n+    if (lane > GET_MODE_NUNITS (V2SImode) - 1)\n+      {\n+\toperands[4] = GEN_INT (lane - GET_MODE_NUNITS (V2SImode));\n+\treturn \"v<sup>dot.<opsuffix>\\\\t%<V_reg>0, %<V_reg>2, %f3[%c4]\";\n+      }\n+    else\n+      {\n+\toperands[4] = GEN_INT (lane);\n+\treturn \"v<sup>dot.<opsuffix>\\\\t%<V_reg>0, %<V_reg>2, %e3[%c4]\";\n+      }\n   }\n   [(set_attr \"type\" \"neon_dot<q>\")]\n )\n@@ -2932,43 +2984,6 @@\n   [(set_attr \"type\" \"neon_dot<q>\")]\n )\n \n-;; These expands map to the Dot Product optab the vectorizer checks for.\n-;; The auto-vectorizer expects a dot product builtin that also does an\n-;; accumulation into the provided register.\n-;; Given the following pattern\n-;;\n-;; for (i=0; i<len; i++) {\n-;;     c = a[i] * b[i];\n-;;     r += c;\n-;; }\n-;; return result;\n-;;\n-;; This can be auto-vectorized to\n-;; r  = a[0]*b[0] + a[1]*b[1] + a[2]*b[2] + a[3]*b[3];\n-;;\n-;; given enough iterations.  However the vectorizer can keep unrolling the loop\n-;; r += a[4]*b[4] + a[5]*b[5] + a[6]*b[6] + a[7]*b[7];\n-;; r += a[8]*b[8] + a[9]*b[9] + a[10]*b[10] + a[11]*b[11];\n-;; ...\n-;;\n-;; and so the vectorizer provides r, in which the result has to be accumulated.\n-(define_expand \"<sup>dot_prod<vsi2qi>\"\n-  [(set (match_operand:VCVTI 0 \"register_operand\")\n-\t(plus:VCVTI (unspec:VCVTI [(match_operand:<VSI2QI> 1\n-\t\t\t\t\t\t\t\"register_operand\")\n-\t\t\t\t   (match_operand:<VSI2QI> 2\n-\t\t\t\t\t\t\t\"register_operand\")]\n-\t\t     DOTPROD)\n-\t\t    (match_operand:VCVTI 3 \"register_operand\")))]\n-  \"TARGET_DOTPROD\"\n-{\n-  emit_insn (\n-    gen_neon_<sup>dot<vsi2qi> (operands[3], operands[3], operands[1],\n-\t\t\t\t operands[2]));\n-  emit_insn (gen_rtx_SET (operands[0], operands[3]));\n-  DONE;\n-})\n-\n ;; Auto-vectorizer pattern for usdot\n (define_expand \"usdot_prod<vsi2qi>\"\n   [(set (match_operand:VCVTI 0 \"register_operand\")"}, {"sha": "d3541e829a44fa07972096a02226adea1d26f09d", "filename": "gcc/testsuite/gcc.target/arm/simd/vdot-compile.c", "status": "modified", "additions": 23, "deletions": 3, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12aae3b93aeae50f5ced1bbef57fe207ecd12930/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fsimd%2Fvdot-compile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12aae3b93aeae50f5ced1bbef57fe207ecd12930/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fsimd%2Fvdot-compile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fsimd%2Fvdot-compile.c?ref=12aae3b93aeae50f5ced1bbef57fe207ecd12930", "patch": "@@ -49,8 +49,28 @@ int32x4_t sfooq_lane (int32x4_t r, int8x16_t x, int8x8_t y)\n   return vdotq_lane_s32 (r, x, y, 0);\n }\n \n-/* { dg-final { scan-assembler-times {v[us]dot\\.[us]8\\td[0-9]+, d[0-9]+, d[0-9]+} 4 } } */\n+int32x2_t sfoo_laneq1 (int32x2_t r, int8x8_t x, int8x16_t y)\n+{\n+  return vdot_laneq_s32 (r, x, y, 0);\n+}\n+\n+int32x4_t sfooq_lane1 (int32x4_t r, int8x16_t x, int8x16_t y)\n+{\n+  return vdotq_laneq_s32 (r, x, y, 0);\n+}\n+\n+int32x2_t sfoo_laneq2 (int32x2_t r, int8x8_t x, int8x16_t y)\n+{\n+  return vdot_laneq_s32 (r, x, y, 2);\n+}\n+\n+int32x4_t sfooq_lane2 (int32x4_t r, int8x16_t x, int8x16_t y)\n+{\n+  return vdotq_laneq_s32 (r, x, y, 2);\n+}\n+\n+/* { dg-final { scan-assembler-times {v[us]dot\\.[us]8\\td[0-9]+, d[0-9]+, d[0-9]+} 6 } } */\n /* { dg-final { scan-assembler-times {v[us]dot\\.[us]8\\tq[0-9]+, q[0-9]+, q[0-9]+} 2 } } */\n-/* { dg-final { scan-assembler-times {v[us]dot\\.[us]8\\td[0-9]+, d[0-9]+, d[0-9]+\\[#?[0-9]\\]} 2 } } */\n-/* { dg-final { scan-assembler-times {v[us]dot\\.[us]8\\tq[0-9]+, q[0-9]+, d[0-9]+\\[#?[0-9]\\]} 2 } } */\n+/* { dg-final { scan-assembler-times {v[us]dot\\.[us]8\\td[0-9]+, d[0-9]+, d[0-9]+\\[#?[0-9]\\]} 4 } } */\n+/* { dg-final { scan-assembler-times {v[us]dot\\.[us]8\\tq[0-9]+, q[0-9]+, d[0-9]+\\[#?[0-9]\\]} 4 } } */\n "}, {"sha": "89a196ea17c48d086601a3c936a67d146a21b623", "filename": "gcc/testsuite/gcc.target/arm/simd/vdot-exec.c", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12aae3b93aeae50f5ced1bbef57fe207ecd12930/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fsimd%2Fvdot-exec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12aae3b93aeae50f5ced1bbef57fe207ecd12930/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fsimd%2Fvdot-exec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fsimd%2Fvdot-exec.c?ref=12aae3b93aeae50f5ced1bbef57fe207ecd12930", "patch": "@@ -10,7 +10,7 @@ extern void abort();\n #if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__\n # define ORDER(x, y) y\n #else\n-# define ORDER(x, y) x - y\n+# define ORDER(x, y) (x - y)\n #endif\n \n #define P(n1,n2) n1,n1,n1,n1,n2,n2,n2,n2\n@@ -33,7 +33,20 @@ extern void abort();\n \tt3 f##_##rx1 = {0};\t\t\t    \\\n \tf##_##rx1 =  f (f##_##rx1, f##_##x, f##_##y, ORDER (1, 1));  \\\n \tif (f##_##rx1[0] != n3 || f##_##rx1[1] != n4)   \\\n-\t  abort (); \\\n+\t  abort ();\n+\n+#define P2(n1,n2) n1,n1,n1,n1,n2,n2,n2,n2,n1,n1,n1,n1,n2,n2,n2,n2\n+#define TEST_LANEQ(t1, t2, t3, f, r1, r2, n1, n2, n3, n4) \\\n+\tARR(f, x, t1, r1);\t\t    \\\n+\tARR(f, y, t2, r2);\t\t    \\\n+\tt3 f##_##rx = {0};\t\t    \\\n+\tf##_##rx = f (f##_##rx, f##_##x, f##_##y, ORDER (3, 2));  \\\n+\tif (f##_##rx[0] != n1 || f##_##rx[1] != n2)   \\\n+\t  abort ();\t\t\t\t    \\\n+\tt3 f##_##rx1 = {0};\t\t\t    \\\n+\tf##_##rx1 =  f (f##_##rx1, f##_##x, f##_##y, ORDER (3, 3));  \\\n+\tif (f##_##rx1[0] != n3 || f##_##rx1[1] != n4)   \\\n+\t  abort ();\n \n int\n main()\n@@ -45,11 +58,16 @@ main()\n   TEST (int8x16_t, int8x16_t, int32x4_t, vdotq_s32, P(1,2), P(-2,-3), -8, -24);\n \n   TEST_LANE (uint8x8_t, uint8x8_t, uint32x2_t, vdot_lane_u32, P(1,2), P(2,3), 8, 16, 12, 24);\n-\n   TEST_LANE (int8x8_t, int8x8_t, int32x2_t, vdot_lane_s32, P(1,2), P(-2,-3), -8, -16, -12, -24);\n \n   TEST_LANE (uint8x16_t, uint8x8_t, uint32x4_t, vdotq_lane_u32, P(1,2), P(2,3), 8, 16, 12, 24);\n   TEST_LANE (int8x16_t, int8x8_t, int32x4_t, vdotq_lane_s32, P(1,2), P(-2,-3), -8, -16, -12, -24);\n \n+  TEST_LANEQ (uint8x8_t, uint8x16_t, uint32x2_t, vdot_laneq_u32, P(1,2), P2(2,3), 8, 16, 12, 24);\n+  TEST_LANEQ (int8x8_t, int8x16_t, int32x2_t, vdot_laneq_s32, P(1,2), P2(-2,-3), -8, -16, -12, -24);\n+\n+  TEST_LANEQ (uint8x16_t, uint8x16_t, uint32x4_t, vdotq_laneq_u32, P2(1,2), P2(2,3), 8, 16, 12, 24);\n+  TEST_LANEQ (int8x16_t, int8x16_t, int32x4_t, vdotq_laneq_s32, P2(1,2), P2(-2,-3), -8, -16, -12, -24);\n+\n   return 0;\n }"}]}