{"sha": "d69cf005d0df53b9ebcd3eaf0c1e2740d5b36f1c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDY5Y2YwMDVkMGRmNTNiOWViY2QzZWFmMGMxZTI3NDBkNWIzNmYxYw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-10-04T13:59:18Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-10-04T13:59:18Z"}, "message": "[multiple changes]\n\n2010-10-04  Robert Dewar  <dewar@adacore.com>\n\n\t* exp_cg.adb: Minor reformatting.\n\n2010-10-04  Javier Miranda  <miranda@adacore.com>\n\n\t* exp_cg.adb (Expand_N_Assignment_Statement): Restore tag check when\n\tthe target object is an interface.\n\t* sem_disp.adb (Propagate_Tag): If the controlling argument is an\n\tinterface type then we generate an implicit conversion to force\n\tdisplacement of the pointer to the object to reference the secondary\n\tdispatch table associated with the interface.\n\n2010-10-04  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_ch13.adb (Analyze_Enumeration_Representation_Clause): Set\n\tEnumeration_Rep_Expr to point to the literal, not the identifier.\n\t(Analyze_Enumeration_Representation_Clause): Improve error message for\n\tsize too small for enum rep value\n\t(Analyze_Enumeration_Representation_Clause): Fix size test to use proper\n\tsize (RM_Size, not Esize).\n\nFrom-SVN: r164939", "tree": {"sha": "c898b07342d6c0021f6b3c1addd069381f36bee7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c898b07342d6c0021f6b3c1addd069381f36bee7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d69cf005d0df53b9ebcd3eaf0c1e2740d5b36f1c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d69cf005d0df53b9ebcd3eaf0c1e2740d5b36f1c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d69cf005d0df53b9ebcd3eaf0c1e2740d5b36f1c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d69cf005d0df53b9ebcd3eaf0c1e2740d5b36f1c/comments", "author": null, "committer": null, "parents": [{"sha": "f5d96d00381bbdf2f14e03e89966de624c2f293b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5d96d00381bbdf2f14e03e89966de624c2f293b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f5d96d00381bbdf2f14e03e89966de624c2f293b"}], "stats": {"total": 105, "additions": 83, "deletions": 22}, "files": [{"sha": "1d33f866a1dd74f1a923ecb268c051c7ab823073", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d69cf005d0df53b9ebcd3eaf0c1e2740d5b36f1c/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d69cf005d0df53b9ebcd3eaf0c1e2740d5b36f1c/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=d69cf005d0df53b9ebcd3eaf0c1e2740d5b36f1c", "patch": "@@ -1,3 +1,21 @@\n+2010-10-04  Javier Miranda  <miranda@adacore.com>\n+\n+\t* exp_cg.adb (Expand_N_Assignment_Statement): Restore tag check when\n+\tthe target object is an interface.\n+\t* sem_disp.adb (Propagate_Tag): If the controlling argument is an\n+\tinterface type then we generate an implicit conversion to force\n+\tdisplacement of the pointer to the object to reference the secondary\n+\tdispatch table associated with the interface.\n+\n+2010-10-04  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_ch13.adb (Analyze_Enumeration_Representation_Clause): Set\n+\tEnumeration_Rep_Expr to point to the literal, not the identifier.\n+\t(Analyze_Enumeration_Representation_Clause): Improve error message for\n+\tsize too small for enum rep value\n+\t(Analyze_Enumeration_Representation_Clause): Fix size test to use proper\n+\tsize (RM_Size, not Esize).\n+\n 2010-10-04  Robert Dewar  <dewar@adacore.com>\n \n \t* s-taprop-vxworks.adb, sem_res.adb: Minor reformatting."}, {"sha": "4aa7b0b6397bad7c72dd7e616b87359a87fc5eac", "filename": "gcc/ada/exp_cg.adb", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d69cf005d0df53b9ebcd3eaf0c1e2740d5b36f1c/gcc%2Fada%2Fexp_cg.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d69cf005d0df53b9ebcd3eaf0c1e2740d5b36f1c/gcc%2Fada%2Fexp_cg.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_cg.adb?ref=d69cf005d0df53b9ebcd3eaf0c1e2740d5b36f1c", "patch": "@@ -409,6 +409,7 @@ package body Exp_CG is\n       Nul   : constant Character := Character'First;\n       Line  : String (Str'First .. Str'Last + 1);\n       Errno : Integer;\n+\n    begin\n       --  Add the null character to the string as required by fputs\n \n@@ -583,9 +584,9 @@ package body Exp_CG is\n \n          if Present (Interface_Alias (Prim))\n            or else\n-            (Present (Alias (Prim))\n-               and then Find_Dispatching_Type (Prim)\n-                          /= Find_Dispatching_Type (Alias (Prim)))\n+             (Present (Alias (Prim))\n+               and then Find_Dispatching_Type (Prim) /=\n+                        Find_Dispatching_Type (Alias (Prim)))\n          then\n             goto Continue;\n          end if;\n@@ -641,8 +642,8 @@ package body Exp_CG is\n                   Int_Alias := Interface_Alias (Prim_Op);\n \n                   if Present (Int_Alias)\n-                    and then not Is_Ancestor\n-                                   (Find_Dispatching_Type (Int_Alias), Typ)\n+                    and then\n+                      not Is_Ancestor (Find_Dispatching_Type (Int_Alias), Typ)\n                     and then (Alias (Prim_Op)) = Prim\n                   then\n                      Write_Char (',');"}, {"sha": "fb1888da4578bbeb3c7b435ed8ef71b432ace8b5", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d69cf005d0df53b9ebcd3eaf0c1e2740d5b36f1c/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d69cf005d0df53b9ebcd3eaf0c1e2740d5b36f1c/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=d69cf005d0df53b9ebcd3eaf0c1e2740d5b36f1c", "patch": "@@ -1956,12 +1956,6 @@ package body Exp_Ch5 is\n                   if Is_Class_Wide_Type (Typ)\n                     and then Is_Tagged_Type (Typ)\n                     and then Is_Tagged_Type (Underlying_Type (Etype (Rhs)))\n-\n-                    --   Do not generate a tag check when the target object is\n-                    --   an interface since the expression of the right hand\n-                    --   side must only cover the interface.\n-\n-                    and then not Is_Interface (Typ)\n                   then\n                      Append_To (L,\n                        Make_Raise_Constraint_Error (Loc,"}, {"sha": "ef46ad7eb83fd9de6512af81a1f8cacefde25e10", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 30, "deletions": 10, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d69cf005d0df53b9ebcd3eaf0c1e2740d5b36f1c/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d69cf005d0df53b9ebcd3eaf0c1e2740d5b36f1c/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=d69cf005d0df53b9ebcd3eaf0c1e2740d5b36f1c", "patch": "@@ -2098,10 +2098,16 @@ package body Sem_Ch13 is\n       Val      : Uint;\n       Err      : Boolean := False;\n \n-      Lo  : constant Uint := Expr_Value (Type_Low_Bound (Universal_Integer));\n-      Hi  : constant Uint := Expr_Value (Type_High_Bound (Universal_Integer));\n+      Lo : constant Uint := Expr_Value (Type_Low_Bound (Universal_Integer));\n+      Hi : constant Uint := Expr_Value (Type_High_Bound (Universal_Integer));\n+      --  Allowed range of universal integer (= allowed range of enum lit vals)\n+\n       Min : Uint;\n       Max : Uint;\n+      --  Minimum and maximum values of entries\n+\n+      Max_Node : Node_Id;\n+      --  Pointer to node for literal providing max value\n \n    begin\n       if Ignore_Rep_Clauses then\n@@ -2260,7 +2266,7 @@ package body Sem_Ch13 is\n                         Err := True;\n                      end if;\n \n-                     Set_Enumeration_Rep_Expr (Elit, Choice);\n+                     Set_Enumeration_Rep_Expr (Elit, Expression (Assoc));\n \n                      Expr := Expression (Assoc);\n                      Val := Static_Integer (Expr);\n@@ -2306,15 +2312,16 @@ package body Sem_Ch13 is\n                   if Max /= No_Uint and then Val <= Max then\n                      Error_Msg_NE\n                        (\"enumeration value for& not ordered!\",\n-                                       Enumeration_Rep_Expr (Elit), Elit);\n+                        Enumeration_Rep_Expr (Elit), Elit);\n                   end if;\n \n+                  Max_Node := Enumeration_Rep_Expr (Elit);\n                   Max := Val;\n                end if;\n \n-               --  If there is at least one literal whose representation\n-               --  is not equal to the Pos value, then note that this\n-               --  enumeration type has a non-standard representation.\n+               --  If there is at least one literal whose representation is not\n+               --  equal to the Pos value, then note that this enumeration type\n+               --  has a non-standard representation.\n \n                if Val /= Enumeration_Pos (Elit) then\n                   Set_Has_Non_Standard_Rep (Base_Type (Enumtype));\n@@ -2331,15 +2338,28 @@ package body Sem_Ch13 is\n \n          begin\n             if Has_Size_Clause (Enumtype) then\n-               if Esize (Enumtype) >= Minsize then\n+\n+               --  All OK, if size is OK now\n+\n+               if RM_Size (Enumtype) >= Minsize then\n                   null;\n \n                else\n+                  --  Try if we can get by with biasing\n+\n                   Minsize :=\n                     UI_From_Int (Minimum_Size (Enumtype, Biased => True));\n \n-                  if Esize (Enumtype) < Minsize then\n-                     Error_Msg_N (\"previously given size is too small\", N);\n+                  --  Error message if even biasing does not work\n+\n+                  if RM_Size (Enumtype) < Minsize then\n+                     Error_Msg_Uint_1 := RM_Size (Enumtype);\n+                     Error_Msg_Uint_2 := Max;\n+                     Error_Msg_N\n+                       (\"previously given size (^) is too small \"\n+                        & \"for this value (^)\", Max_Node);\n+\n+                  --  If biasing worked, indicate that we now have biased rep\n \n                   else\n                      Set_Has_Biased_Representation (Enumtype);"}, {"sha": "f40df26b59a93c02eaa15ed86bbbd9b972ad9817", "filename": "gcc/ada/sem_disp.adb", "status": "modified", "additions": 29, "deletions": 1, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d69cf005d0df53b9ebcd3eaf0c1e2740d5b36f1c/gcc%2Fada%2Fsem_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d69cf005d0df53b9ebcd3eaf0c1e2740d5b36f1c/gcc%2Fada%2Fsem_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_disp.adb?ref=d69cf005d0df53b9ebcd3eaf0c1e2740d5b36f1c", "patch": "@@ -1959,7 +1959,35 @@ package body Sem_Disp is\n       --  and would have to undo any expansion to an indirect call.\n \n       if Tagged_Type_Expansion then\n-         Expand_Dispatching_Call (Call_Node);\n+         declare\n+            Call_Typ : constant Entity_Id := Etype (Call_Node);\n+\n+         begin\n+            Expand_Dispatching_Call (Call_Node);\n+\n+            --  If the controlling argument is an interface type and the type\n+            --  of Call_Node differs then we must add an implicit conversion to\n+            --  force displacement of the pointer to the object to reference\n+            --  the secondary dispatch table of the interface.\n+\n+            if Is_Interface (Etype (Control))\n+              and then Etype (Control) /= Call_Typ\n+            then\n+               --  Cannot use Convert_To because the previous call to\n+               --  Expand_Dispatching_Call leaves decorated the Call_Node\n+               --  with the type of Control.\n+\n+               Rewrite (Call_Node,\n+                 Make_Type_Conversion (Sloc (Call_Node),\n+                   Subtype_Mark =>\n+                     New_Occurrence_Of (Etype (Control), Sloc (Call_Node)),\n+                   Expression => Relocate_Node (Call_Node)));\n+               Set_Etype (Call_Node, Etype (Control));\n+               Set_Analyzed (Call_Node);\n+\n+               Expand_Interface_Conversion (Call_Node, Is_Static => False);\n+            end if;\n+         end;\n \n       --  Expansion of a dispatching call results in an indirect call, which in\n       --  turn causes current values to be killed (see Resolve_Call), so on VM"}]}