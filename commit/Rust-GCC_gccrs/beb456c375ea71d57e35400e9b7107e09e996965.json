{"sha": "beb456c375ea71d57e35400e9b7107e09e996965", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmViNDU2YzM3NWVhNzFkNTdlMzU0MDBlOWI3MTA3ZTA5ZTk5Njk2NQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2018-07-31T14:23:57Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-07-31T14:23:57Z"}, "message": "[26/46] Make more use of dyn_cast in tree-vect*\n\nIf we use stmt_vec_infos to represent statements in the vectoriser,\nit's then more natural to use dyn_cast when processing the statement\nas an assignment, call, etc.  This patch does that in a few more places.\n\n2018-07-31  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* tree-vect-data-refs.c (vect_check_gather_scatter): Pass the\n\tgcall rather than the generic gimple stmt to gimple_call_internal_fn.\n\t(vect_get_smallest_scalar_type, can_group_stmts_p): Use dyn_cast\n\tto get gassigns and gcalls, rather than operating on generc gimple\n\tstmts.\n\t* tree-vect-stmts.c (exist_non_indexing_operands_for_use_p)\n\t(vect_mark_stmts_to_be_vectorized, vectorizable_store)\n\t(vectorizable_load, vect_analyze_stmt): Likewise.\n\t* tree-vect-loop.c (vectorizable_reduction): Likewise gphi.\n\nFrom-SVN: r263141", "tree": {"sha": "c6abc11910ddc42f2e70b359901386fc2adcb87b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c6abc11910ddc42f2e70b359901386fc2adcb87b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/beb456c375ea71d57e35400e9b7107e09e996965", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/beb456c375ea71d57e35400e9b7107e09e996965", "html_url": "https://github.com/Rust-GCC/gccrs/commit/beb456c375ea71d57e35400e9b7107e09e996965", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/beb456c375ea71d57e35400e9b7107e09e996965/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "95c68311b61f6bbb013d0eb2e4403f01c76bf622", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95c68311b61f6bbb013d0eb2e4403f01c76bf622", "html_url": "https://github.com/Rust-GCC/gccrs/commit/95c68311b61f6bbb013d0eb2e4403f01c76bf622"}], "stats": {"total": 112, "additions": 64, "deletions": 48}, "files": [{"sha": "b5390574241508caeb4f3a3aa0f33ea9f5adf51b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/beb456c375ea71d57e35400e9b7107e09e996965/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/beb456c375ea71d57e35400e9b7107e09e996965/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=beb456c375ea71d57e35400e9b7107e09e996965", "patch": "@@ -1,3 +1,15 @@\n+2018-07-31  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* tree-vect-data-refs.c (vect_check_gather_scatter): Pass the\n+\tgcall rather than the generic gimple stmt to gimple_call_internal_fn.\n+\t(vect_get_smallest_scalar_type, can_group_stmts_p): Use dyn_cast\n+\tto get gassigns and gcalls, rather than operating on generc gimple\n+\tstmts.\n+\t* tree-vect-stmts.c (exist_non_indexing_operands_for_use_p)\n+\t(vect_mark_stmts_to_be_vectorized, vectorizable_store)\n+\t(vectorizable_load, vect_analyze_stmt): Likewise.\n+\t* tree-vect-loop.c (vectorizable_reduction): Likewise gphi.\n+\n 2018-07-31  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* tree-vectorizer.h (get_earlier_stmt, get_later_stmt): Take and"}, {"sha": "7cf9014a974fa6e3dad74630f8eed166e2cd226f", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/beb456c375ea71d57e35400e9b7107e09e996965/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/beb456c375ea71d57e35400e9b7107e09e996965/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=beb456c375ea71d57e35400e9b7107e09e996965", "patch": "@@ -130,15 +130,16 @@ vect_get_smallest_scalar_type (gimple *stmt, HOST_WIDE_INT *lhs_size_unit,\n \n   lhs = rhs = TREE_INT_CST_LOW (TYPE_SIZE_UNIT (scalar_type));\n \n-  if (is_gimple_assign (stmt)\n-      && (gimple_assign_cast_p (stmt)\n-          || gimple_assign_rhs_code (stmt) == DOT_PROD_EXPR\n-          || gimple_assign_rhs_code (stmt) == WIDEN_SUM_EXPR\n-          || gimple_assign_rhs_code (stmt) == WIDEN_MULT_EXPR\n-          || gimple_assign_rhs_code (stmt) == WIDEN_LSHIFT_EXPR\n-          || gimple_assign_rhs_code (stmt) == FLOAT_EXPR))\n+  gassign *assign = dyn_cast <gassign *> (stmt);\n+  if (assign\n+      && (gimple_assign_cast_p (assign)\n+\t  || gimple_assign_rhs_code (assign) == DOT_PROD_EXPR\n+\t  || gimple_assign_rhs_code (assign) == WIDEN_SUM_EXPR\n+\t  || gimple_assign_rhs_code (assign) == WIDEN_MULT_EXPR\n+\t  || gimple_assign_rhs_code (assign) == WIDEN_LSHIFT_EXPR\n+\t  || gimple_assign_rhs_code (assign) == FLOAT_EXPR))\n     {\n-      tree rhs_type = TREE_TYPE (gimple_assign_rhs1 (stmt));\n+      tree rhs_type = TREE_TYPE (gimple_assign_rhs1 (assign));\n \n       rhs = TREE_INT_CST_LOW (TYPE_SIZE_UNIT (rhs_type));\n       if (rhs < lhs)\n@@ -2850,21 +2851,23 @@ can_group_stmts_p (gimple *stmt1, gimple *stmt2)\n   if (gimple_assign_single_p (stmt1))\n     return gimple_assign_single_p (stmt2);\n \n-  if (is_gimple_call (stmt1) && gimple_call_internal_p (stmt1))\n+  gcall *call1 = dyn_cast <gcall *> (stmt1);\n+  if (call1 && gimple_call_internal_p (call1))\n     {\n       /* Check for two masked loads or two masked stores.  */\n-      if (!is_gimple_call (stmt2) || !gimple_call_internal_p (stmt2))\n+      gcall *call2 = dyn_cast <gcall *> (stmt2);\n+      if (!call2 || !gimple_call_internal_p (call2))\n \treturn false;\n-      internal_fn ifn = gimple_call_internal_fn (stmt1);\n+      internal_fn ifn = gimple_call_internal_fn (call1);\n       if (ifn != IFN_MASK_LOAD && ifn != IFN_MASK_STORE)\n \treturn false;\n-      if (ifn != gimple_call_internal_fn (stmt2))\n+      if (ifn != gimple_call_internal_fn (call2))\n \treturn false;\n \n       /* Check that the masks are the same.  Cope with casts of masks,\n \t like those created by build_mask_conversion.  */\n-      tree mask1 = gimple_call_arg (stmt1, 2);\n-      tree mask2 = gimple_call_arg (stmt2, 2);\n+      tree mask1 = gimple_call_arg (call1, 2);\n+      tree mask2 = gimple_call_arg (call2, 2);\n       if (!operand_equal_p (mask1, mask2, 0))\n \t{\n \t  mask1 = strip_conversion (mask1);\n@@ -3665,7 +3668,7 @@ vect_check_gather_scatter (gimple *stmt, loop_vec_info loop_vinfo,\n   gcall *call = dyn_cast <gcall *> (stmt);\n   if (call && gimple_call_internal_p (call))\n     {\n-      ifn = gimple_call_internal_fn (stmt);\n+      ifn = gimple_call_internal_fn (call);\n       if (internal_gather_scatter_fn_p (ifn))\n \t{\n \t  vect_describe_gather_scatter_call (call, info);"}, {"sha": "caa1c6b872539d24c0a682f0ed62b39390447a87", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/beb456c375ea71d57e35400e9b7107e09e996965/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/beb456c375ea71d57e35400e9b7107e09e996965/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=beb456c375ea71d57e35400e9b7107e09e996965", "patch": "@@ -6109,9 +6109,9 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n     gcc_assert (slp_node\n \t\t&& REDUC_GROUP_FIRST_ELEMENT (stmt_info) == stmt_info);\n \n-  if (gimple_code (stmt) == GIMPLE_PHI)\n+  if (gphi *phi = dyn_cast <gphi *> (stmt))\n     {\n-      tree phi_result = gimple_phi_result (stmt);\n+      tree phi_result = gimple_phi_result (phi);\n       /* Analysis is fully done on the reduction stmt invocation.  */\n       if (! vec_stmt)\n \t{\n@@ -6141,7 +6141,7 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n       for (unsigned k = 1; k < gimple_num_ops (reduc_stmt); ++k)\n \t{\n \t  tree op = gimple_op (reduc_stmt, k);\n-\t  if (op == gimple_phi_result (stmt))\n+\t  if (op == phi_result)\n \t    continue;\n \t  if (k == 1\n \t      && gimple_assign_rhs_code (reduc_stmt) == COND_EXPR)"}, {"sha": "d72dbcbe8c7cde4523907094d768eae18a2a6d73", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 31, "deletions": 30, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/beb456c375ea71d57e35400e9b7107e09e996965/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/beb456c375ea71d57e35400e9b7107e09e996965/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=beb456c375ea71d57e35400e9b7107e09e996965", "patch": "@@ -389,30 +389,31 @@ exist_non_indexing_operands_for_use_p (tree use, gimple *stmt)\n      Therefore, all we need to check is if STMT falls into the\n      first case, and whether var corresponds to USE.  */\n \n-  if (!gimple_assign_copy_p (stmt))\n+  gassign *assign = dyn_cast <gassign *> (stmt);\n+  if (!assign || !gimple_assign_copy_p (assign))\n     {\n-      if (is_gimple_call (stmt)\n-\t  && gimple_call_internal_p (stmt))\n+      gcall *call = dyn_cast <gcall *> (stmt);\n+      if (call && gimple_call_internal_p (call))\n \t{\n-\t  internal_fn ifn = gimple_call_internal_fn (stmt);\n+\t  internal_fn ifn = gimple_call_internal_fn (call);\n \t  int mask_index = internal_fn_mask_index (ifn);\n \t  if (mask_index >= 0\n-\t      && use == gimple_call_arg (stmt, mask_index))\n+\t      && use == gimple_call_arg (call, mask_index))\n \t    return true;\n \t  int stored_value_index = internal_fn_stored_value_index (ifn);\n \t  if (stored_value_index >= 0\n-\t      && use == gimple_call_arg (stmt, stored_value_index))\n+\t      && use == gimple_call_arg (call, stored_value_index))\n \t    return true;\n \t  if (internal_gather_scatter_fn_p (ifn)\n-\t      && use == gimple_call_arg (stmt, 1))\n+\t      && use == gimple_call_arg (call, 1))\n \t    return true;\n \t}\n       return false;\n     }\n \n-  if (TREE_CODE (gimple_assign_lhs (stmt)) == SSA_NAME)\n+  if (TREE_CODE (gimple_assign_lhs (assign)) == SSA_NAME)\n     return false;\n-  operand = gimple_assign_rhs1 (stmt);\n+  operand = gimple_assign_rhs1 (assign);\n   if (TREE_CODE (operand) != SSA_NAME)\n     return false;\n \n@@ -739,10 +740,10 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n           /* Pattern statements are not inserted into the code, so\n              FOR_EACH_PHI_OR_STMT_USE optimizes their operands out, and we\n              have to scan the RHS or function arguments instead.  */\n-          if (is_gimple_assign (stmt))\n-            {\n-\t      enum tree_code rhs_code = gimple_assign_rhs_code (stmt);\n-\t      tree op = gimple_assign_rhs1 (stmt);\n+\t  if (gassign *assign = dyn_cast <gassign *> (stmt))\n+\t    {\n+\t      enum tree_code rhs_code = gimple_assign_rhs_code (assign);\n+\t      tree op = gimple_assign_rhs1 (assign);\n \n \t      i = 1;\n \t      if (rhs_code == COND_EXPR && COMPARISON_CLASS_P (op))\n@@ -754,25 +755,25 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n \t\t    return false;\n \t\t  i = 2;\n \t\t}\n-\t      for (; i < gimple_num_ops (stmt); i++)\n-                {\n-\t\t  op = gimple_op (stmt, i);\n+\t      for (; i < gimple_num_ops (assign); i++)\n+\t\t{\n+\t\t  op = gimple_op (assign, i);\n                   if (TREE_CODE (op) == SSA_NAME\n \t\t      && !process_use (stmt, op, loop_vinfo, relevant,\n \t\t\t\t       &worklist, false))\n                     return false;\n                  }\n             }\n-          else if (is_gimple_call (stmt))\n-            {\n-              for (i = 0; i < gimple_call_num_args (stmt); i++)\n-                {\n-                  tree arg = gimple_call_arg (stmt, i);\n+\t  else if (gcall *call = dyn_cast <gcall *> (stmt))\n+\t    {\n+\t      for (i = 0; i < gimple_call_num_args (call); i++)\n+\t\t{\n+\t\t  tree arg = gimple_call_arg (call, i);\n \t\t  if (!process_use (stmt, arg, loop_vinfo, relevant,\n \t\t\t\t    &worklist, false))\n                     return false;\n-                }\n-            }\n+\t\t}\n+\t    }\n         }\n       else\n         FOR_EACH_PHI_OR_STMT_USE (use_p, stmt, iter, SSA_OP_USE)\n@@ -6274,9 +6275,9 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi,\n   /* Is vectorizable store? */\n \n   tree mask = NULL_TREE, mask_vectype = NULL_TREE;\n-  if (is_gimple_assign (stmt))\n+  if (gassign *assign = dyn_cast <gassign *> (stmt))\n     {\n-      tree scalar_dest = gimple_assign_lhs (stmt);\n+      tree scalar_dest = gimple_assign_lhs (assign);\n       if (TREE_CODE (scalar_dest) == VIEW_CONVERT_EXPR\n \t  && is_pattern_stmt_p (stmt_info))\n \tscalar_dest = TREE_OPERAND (scalar_dest, 0);\n@@ -7445,13 +7446,13 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi,\n     return false;\n \n   tree mask = NULL_TREE, mask_vectype = NULL_TREE;\n-  if (is_gimple_assign (stmt))\n+  if (gassign *assign = dyn_cast <gassign *> (stmt))\n     {\n-      scalar_dest = gimple_assign_lhs (stmt);\n+      scalar_dest = gimple_assign_lhs (assign);\n       if (TREE_CODE (scalar_dest) != SSA_NAME)\n \treturn false;\n \n-      tree_code code = gimple_assign_rhs_code (stmt);\n+      tree_code code = gimple_assign_rhs_code (assign);\n       if (code != ARRAY_REF\n \t  && code != BIT_FIELD_REF\n \t  && code != INDIRECT_REF\n@@ -9557,9 +9558,9 @@ vect_analyze_stmt (gimple *stmt, bool *need_to_vectorize, slp_tree node,\n   if (STMT_VINFO_RELEVANT_P (stmt_info))\n     {\n       gcc_assert (!VECTOR_MODE_P (TYPE_MODE (gimple_expr_type (stmt))));\n+      gcall *call = dyn_cast <gcall *> (stmt);\n       gcc_assert (STMT_VINFO_VECTYPE (stmt_info)\n-\t\t  || (is_gimple_call (stmt)\n-\t\t      && gimple_call_lhs (stmt) == NULL_TREE));\n+\t\t  || (call && gimple_call_lhs (call) == NULL_TREE));\n       *need_to_vectorize = true;\n     }\n "}]}