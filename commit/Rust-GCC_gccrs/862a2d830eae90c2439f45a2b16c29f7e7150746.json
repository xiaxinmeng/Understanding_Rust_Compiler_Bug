{"sha": "862a2d830eae90c2439f45a2b16c29f7e7150746", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODYyYTJkODMwZWFlOTBjMjQzOWY0NWEyYjE2YzI5ZjdlNzE1MDc0Ng==", "commit": {"author": {"name": "Ulrich Weigand", "email": "uweigand@de.ibm.com", "date": "2002-10-24T17:07:11Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2002-10-24T17:07:11Z"}, "message": "s390.h: Rework comments...\n\n\t* config/s390/s390.h: Rework comments; re-sort target macro definitions\n\taccording to the sequence they are defined in the manual.\n\t(POINTER_BOUNDARY): Remove.\n\nFrom-SVN: r58495", "tree": {"sha": "12e4364f1d8ad2b5e53c8e8dc3765d89a20e5579", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/12e4364f1d8ad2b5e53c8e8dc3765d89a20e5579"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/862a2d830eae90c2439f45a2b16c29f7e7150746", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/862a2d830eae90c2439f45a2b16c29f7e7150746", "html_url": "https://github.com/Rust-GCC/gccrs/commit/862a2d830eae90c2439f45a2b16c29f7e7150746", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/862a2d830eae90c2439f45a2b16c29f7e7150746/comments", "author": null, "committer": null, "parents": [{"sha": "489eda6518baecf4c6b9c7a2e2283cd2a361791b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/489eda6518baecf4c6b9c7a2e2283cd2a361791b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/489eda6518baecf4c6b9c7a2e2283cd2a361791b"}], "stats": {"total": 1143, "additions": 418, "deletions": 725}, "files": [{"sha": "ff4ed20e3bc0a6918172a44b5a8efba94a72d0fc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/862a2d830eae90c2439f45a2b16c29f7e7150746/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/862a2d830eae90c2439f45a2b16c29f7e7150746/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=862a2d830eae90c2439f45a2b16c29f7e7150746", "patch": "@@ -1,3 +1,9 @@\n+2002-10-24  Ulrich Weigand  <uweigand@de.ibm.com>\n+\n+\t* config/s390/s390.h: Rework comments; re-sort target macro definitions \n+\taccording to the sequence they are defined in the manual.\n+\t(POINTER_BOUNDARY): Remove.\n+\n 2002-10-24  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* config/h8300/h8300.c (round_frame_size): Replace 8 with"}, {"sha": "009f8a4bcf9992c24c8fff2306fe84e97f7a6285", "filename": "gcc/config/s390/s390.h", "status": "modified", "additions": 412, "deletions": 725, "changes": 1137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/862a2d830eae90c2439f45a2b16c29f7e7150746/gcc%2Fconfig%2Fs390%2Fs390.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/862a2d830eae90c2439f45a2b16c29f7e7150746/gcc%2Fconfig%2Fs390%2Fs390.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.h?ref=862a2d830eae90c2439f45a2b16c29f7e7150746", "patch": "@@ -29,14 +29,23 @@ Boston, MA 02111-1307, USA.  */\n #endif\n \n \n-extern int flag_pic; \n+/* Run-time target specification.  */\n \n-/* Run-time compilation parameters selecting different hardware subsets.  */\n+/* Target CPU builtins.  */\n+#define TARGET_CPU_CPP_BUILTINS()\t\t\t\\\n+  do\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      builtin_assert (\"cpu=s390\");\t\t\t\\\n+      builtin_assert (\"machine=s390\");\t\t\t\\\n+      builtin_define (\"__s390__\");\t\t\t\\\n+      if (TARGET_64BIT)\t\t\t\t\t\\\n+        builtin_define (\"__s390x__\");\t\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+  while (0)\n \n+/* Optional target features.  */\n extern int target_flags;\n \n-/* Target macros checked at runtime of compiler.  */\n-\n #define TARGET_HARD_FLOAT          (target_flags & 1)\n #define TARGET_SOFT_FLOAT          (!(target_flags & 1))\n #define TARGET_BACKCHAIN           (target_flags & 2)\n@@ -51,18 +60,10 @@ extern int target_flags;\n \n #ifdef DEFAULT_TARGET_64BIT\n #define TARGET_DEFAULT             0x13\n-#define TARGET_VERSION fprintf (stderr, \" (zSeries)\");\n #else\n #define TARGET_DEFAULT             0x3\n-#define TARGET_VERSION fprintf (stderr, \" (S/390)\");\n #endif\n \n-\n-/* Macro to define tables used to set the flags.  This is a list in braces\n-   of pairs in braces, each pair being { \"NAME\", VALUE }\n-   where VALUE is the bits to set or minus the bits to clear.\n-   An empty string NAME is used to identify the default VALUE.  */\n-\n #define TARGET_SWITCHES           \t\t       \t\t       \\\n { { \"hard-float\",    1, N_(\"Use hardware fp\")},         \t\t       \\\n   { \"soft-float\",   -1, N_(\"Don't use hardware fp\")},\t      \t       \\\n@@ -78,152 +79,118 @@ extern int target_flags;\n   { \"no-mvcle\",    -32, N_(\"mvc&ex\")},                                  \\\n   { \"\", TARGET_DEFAULT, 0 } }\n \n-/* Define this to change the optimizations performed by default.  */\n-#define OPTIMIZATION_OPTIONS(LEVEL, SIZE) optimization_options(LEVEL, SIZE)\n+/* Target version string.  Overridden by the OS header.  */\n+#ifdef DEFAULT_TARGET_64BIT\n+#define TARGET_VERSION fprintf (stderr, \" (zSeries)\");\n+#else\n+#define TARGET_VERSION fprintf (stderr, \" (S/390)\");\n+#endif\n \n-/* Sometimes certain combinations of command options do not make sense\n-   on a particular target machine.  You can define a macro\n-   `OVERRIDE_OPTIONS' to take account of this.  This macro, if\n-   defined, is executed once just after all the command options have\n-   been parsed.  */\n+/* Hooks to override options.  */\n+#define OPTIMIZATION_OPTIONS(LEVEL, SIZE) optimization_options(LEVEL, SIZE)\n #define OVERRIDE_OPTIONS override_options ()\n \n-/* Target CPU builtins.  */\n-#define TARGET_CPU_CPP_BUILTINS()\t\t\t\\\n-  do\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\\\n-      builtin_assert (\"cpu=s390\");\t\t\t\\\n-      builtin_assert (\"machine=s390\");\t\t\t\\\n-      builtin_define (\"__s390__\");\t\t\t\\\n-      if (TARGET_64BIT)\t\t\t\t\t\\\n-        builtin_define (\"__s390x__\");\t\t\t\\\n-    }\t\t\t\t\t\t\t\\\n-  while (0)\n-\n-/* The amount of space used for outgoing arguments.  */\n+/* Frame pointer is not used for debugging.  */\n+#define CAN_DEBUG_WITHOUT_FP\n \n-extern int current_function_outgoing_args_size;\n \n /* Target machine storage layout.  */\n \n-/* Define this if most significant bit is lowest numbered in instructions\n-   that operate on numbered bit-fields.  */\n-\n+/* Everything is big-endian.  */\n #define BITS_BIG_ENDIAN 1\n-\n-/* Define this if most significant byte of a word is the lowest numbered.  */\n-\n #define BYTES_BIG_ENDIAN 1\n-\n-/* Define this if MS word of a multiword is the lowest numbered.  */\n-\n #define WORDS_BIG_ENDIAN 1\n \n-#define MAX_BITS_PER_WORD 64\n-\n /* Width of a word, in units (bytes).  */\n-\n #define UNITS_PER_WORD (TARGET_64BIT ? 8 : 4)\n #define MIN_UNITS_PER_WORD 4\n+#define MAX_BITS_PER_WORD 64\n \n-/* A C expression for the size in bits of the type `short' on the\n-   target machine.  If you don't define this, the default is half a\n-   word.  (If this would be less than one storage unit, it is\n-   rounded up to one unit.)  */\n-#define SHORT_TYPE_SIZE 16\n-\n-/* A C expression for the size in bits of the type `int' on the\n-   target machine.  If you don't define this, the default is one\n-   word.  */\n-#define INT_TYPE_SIZE 32\n-\n-/* A C expression for the size in bits of the type `long' on the\n-   target machine.  If you don't define this, the default is one\n-   word.  */\n-#define LONG_TYPE_SIZE (TARGET_64BIT ? 64 : 32)\n-#define MAX_LONG_TYPE_SIZE 64\n-\n-/* A C expression for the size in bits of the type `long long' on the\n-   target machine.  If you don't define this, the default is two\n-   words.  */\n-#define LONG_LONG_TYPE_SIZE 64\n-\n-/* Right now we only support two floating point formats, the \n-   32 and 64 bit ieee formats.  */\n-\n-#define FLOAT_TYPE_SIZE 32\n-#define DOUBLE_TYPE_SIZE 64\n-#define LONG_DOUBLE_TYPE_SIZE 64\n-\n-/* Define this macro if it is advisable to hold scalars in registers\n-   in a wider mode than that declared by the program.  In such cases,\n-   the value is constrained to be within the bounds of the declared\n-   type, but kept valid in the wider mode.  The signedness of the\n-   extension may differ from that of the type.  */\n+/* Function arguments and return values are promoted to word size.  */\n+#define PROMOTE_FUNCTION_ARGS\n+#define PROMOTE_FUNCTION_RETURN\n+#define PROMOTE_FOR_CALL_ONLY\n \n #define PROMOTE_MODE(MODE, UNSIGNEDP, TYPE)\t\t\\\n if (INTEGRAL_MODE_P (MODE) &&\t        \t    \t\\\n     GET_MODE_SIZE (MODE) < UNITS_PER_WORD) { \t\t\\\n   (MODE) = Pmode;\t\t\t\t\t\\\n \t  }\n \n-/* Defining PROMOTE_FUNCTION_ARGS eliminates some unnecessary zero/sign\n-   extensions applied to char/short functions arguments.  Defining\n-   PROMOTE_FUNCTION_RETURN does the same for function returns.  */\n-\n-#define PROMOTE_FUNCTION_ARGS\n-#define PROMOTE_FUNCTION_RETURN\n-#define PROMOTE_FOR_CALL_ONLY\n-\n-/* Allocation boundary (in *bits*) for storing pointers in memory.  */\n-\n-#define POINTER_BOUNDARY 32\n-\n /* Allocation boundary (in *bits*) for storing arguments in argument list.  */\n-\n #define PARM_BOUNDARY (TARGET_64BIT ? 64 : 32)\n \n /* Boundary (in *bits*) on which stack pointer should be aligned.  */\n-\n #define STACK_BOUNDARY 64\n \n /* Allocation boundary (in *bits*) for the code of a function.  */\n-\n #define FUNCTION_BOUNDARY 32\n \n /* There is no point aligning anything to a rounder boundary than this.  */\n-\n #define BIGGEST_ALIGNMENT 64\n \n /* Alignment of field after `int : 0' in a structure.  */\n-\n #define EMPTY_FIELD_BOUNDARY 32\n \n /* Alignment on even addresses for LARL instruction.  */\n-\n #define CONSTANT_ALIGNMENT(EXP, ALIGN) (ALIGN) < 16 ? 16 : (ALIGN)\n-\n #define DATA_ALIGNMENT(TYPE, ALIGN) (ALIGN) < 16 ? 16 : (ALIGN)\n \n-/* Define this if move instructions will actually fail to work when given\n-   unaligned data.  */\n-\n+/* Alignment is not required by the hardware.  */\n #define STRICT_ALIGNMENT 0\n \n+/* Mode of stack savearea.\n+   FUNCTION is VOIDmode because calling convention maintains SP.\n+   BLOCK needs Pmode for SP.\n+   NONLOCAL needs twice Pmode to maintain both backchain and SP.  */\n+#define STACK_SAVEAREA_MODE(LEVEL)      \\\n+  (LEVEL == SAVE_FUNCTION ? VOIDmode    \\\n+  : LEVEL == SAVE_NONLOCAL ? (TARGET_64BIT ? TImode : DImode) : Pmode)\n+\n /* Define target floating point format.  */\n #define TARGET_FLOAT_FORMAT \\\n-\t(TARGET_IEEE_FLOAT? IEEE_FLOAT_FORMAT : IBM_FLOAT_FORMAT)\n+  (TARGET_IEEE_FLOAT? IEEE_FLOAT_FORMAT : IBM_FLOAT_FORMAT)\n \n-/* Define if special allocation order desired.  */\n \n-#define REG_ALLOC_ORDER                                         \\\n-{  1, 2, 3, 4, 5, 0, 14, 13, 12, 11, 10, 9, 8, 7, 6,            \\\n-   16, 17, 18, 19, 20, 21, 22, 23,                              \\\n-   24, 25, 26, 27, 28, 29, 30, 31,                              \\\n-   15, 32, 33, 34 }\n+/* Type layout.  */\n \n-/* Standard register usage.  */\n+/* Sizes in bits of the source language data types.  */\n+#define SHORT_TYPE_SIZE 16\n+#define INT_TYPE_SIZE 32\n+#define LONG_TYPE_SIZE (TARGET_64BIT ? 64 : 32)\n+#define MAX_LONG_TYPE_SIZE 64\n+#define LONG_LONG_TYPE_SIZE 64\n+#define FLOAT_TYPE_SIZE 32\n+#define DOUBLE_TYPE_SIZE 64\n+#define LONG_DOUBLE_TYPE_SIZE 64  /* ??? Should support extended format.  */\n+\n+/* We use \"unsigned char\" as default.  */\n+#define DEFAULT_SIGNED_CHAR 0\n+\n+\n+/* Register usage.  */\n+\n+/* We have 16 general purpose registers (registers 0-15),\n+   and 16 floating point registers (registers 16-31).\n+   (On non-IEEE machines, we have only 4 fp registers.)\n+ \n+   Amongst the general purpose registers, some are used\n+   for specific purposes:\n+   GPR 11: Hard frame pointer (if needed)\n+   GPR 12: Global offset table pointer (if needed)\n+   GPR 13: Literal pool base register\n+   GPR 14: Return address register\n+   GPR 15: Stack pointer\n  \n+   Registers 32-34 are 'fake' hard registers that do not\n+   correspond to actual hardware:\n+   Reg 32: Argument pointer\n+   Reg 33: Condition code\n+   Reg 34: Frame pointer  */\n+\n+#define FIRST_PSEUDO_REGISTER 35\n+\n+/* Standard register usage.  */\n #define GENERAL_REGNO_P(N)\t((int)(N) >= 0 && (N) < 16)\n #define ADDR_REGNO_P(N)\t\t((N) >= 1 && (N) < 16)\n #define FP_REGNO_P(N)\t\t((N) >= 16 && (N) < (TARGET_IEEE_FLOAT? 32 : 20))\n@@ -234,35 +201,23 @@ if (INTEGRAL_MODE_P (MODE) &&\t        \t    \t\\\n #define FP_REG_P(X)\t\t(REG_P (X) && FP_REGNO_P (REGNO (X)))\n #define CC_REG_P(X)\t\t(REG_P (X) && CC_REGNO_P (REGNO (X)))\n \n-/* Number of actual hardware registers.  The hardware registers are\n-   assigned numbers for the compiler from 0 to just below\n-   FIRST_PSEUDO_REGISTER.\n-   All registers that the compiler knows about must be given numbers,\n-   even those that are not normally considered general registers.\n-   For the 390, we give the data registers numbers 0-15,\n-   and the floating point registers numbers 16-19.\n-   G5 and following have 16 IEEE floating point register,\n-   which get numbers 16-31.  */\n-\n-#define FIRST_PSEUDO_REGISTER 35\n-\n-/* Number of hardware registers that go into the DWARF-2 unwind info.\n-   If not defined, equals FIRST_PSEUDO_REGISTER.  */\n+#define BASE_REGISTER 13\n+#define RETURN_REGNUM 14\n+#define CC_REGNUM 33\n \n-#define DWARF_FRAME_REGISTERS 34\n+/* Set up fixed registers and calling convention:\n \n-/* The following register have a fix usage\n-   GPR 12: GOT register points to the GOT, setup in prologue,\n-           GOT contains pointer to variables in shared libraries \n-   GPR 13: Base register setup in prologue to point to the\n-           literal table of each function\n-   GPR 14: Return registers holds the return address\n-   GPR 15: Stack pointer */\n+   GPRs 0-5 are always call-clobbered,\n+   GPRs 6-15 are always call-saved.\n+   GPR 12 is fixed if used as GOT pointer.\n+   GPR 13 is always fixed (as literal pool pointer).\n+   GPR 14 is always fixed (as return address).\n+   GPR 15 is always fixed (as stack pointer).\n+   The 'fake' hard registers are call-clobbered and fixed.\n \n-#define PIC_OFFSET_TABLE_REGNUM (flag_pic ? 12 : INVALID_REGNUM)\n-#define BASE_REGISTER 13\n-#define RETURN_REGNUM 14\n-#define STACK_POINTER_REGNUM 15\n+   On 31-bit, FPRs 18-19 are call-clobbered;\n+   on 64-bit, FPRs 24-31 are call-clobbered.\n+   The remaining FPRs are call-saved.  */\n \n #define FIXED_REGISTERS\t\t\t\t\\\n { 0, 0, 0, 0, \t\t\t\t\t\\\n@@ -275,12 +230,6 @@ if (INTEGRAL_MODE_P (MODE) &&\t        \t    \t\\\n   0, 0, 0, 0, \t\t\t\t\t\\\n   1, 1, 1 }\n \n-/* 1 for registers not available across function calls.  These must include\n-   the FIXED_REGISTERS and also any registers that can be used without being\n-   saved.\n-   The latter must include the registers where values are returned\n-   and the register where structure-value addresses are passed.  */\n-\n #define CALL_USED_REGISTERS\t\t\t\\\n { 1, 1, 1, 1, \t\t\t\t\t\\\n   1, 1, 0, 0, \t\t\t\t\t\\\n@@ -292,10 +241,6 @@ if (INTEGRAL_MODE_P (MODE) &&\t        \t    \t\\\n   1, 1, 1, 1, \t\t\t\t\t\\\n   1, 1, 1 }\n \n-/* Like `CALL_USED_REGISTERS' except this macro doesn't require that\n-   the entire set of `FIXED_REGISTERS' be included.\n-   (`CALL_USED_REGISTERS' must be a superset of `FIXED_REGISTERS').  */\n-\n #define CALL_REALLY_USED_REGISTERS\t\t\\\n { 1, 1, 1, 1, \t\t\t\t\t\\\n   1, 1, 0, 0, \t\t\t\t\t\\\n@@ -307,8 +252,6 @@ if (INTEGRAL_MODE_P (MODE) &&\t        \t    \t\\\n   1, 1, 1, 1, \t\t\t\t\t\\\n   1, 1, 1 }\n \n-/* Macro to conditionally modify fixed_regs/call_used_regs.  */\n-\n #define CONDITIONAL_REGISTER_USAGE\t\t\t\t\\\n do\t\t\t\t\t\t\t\t\\\n   {\t\t\t\t\t\t\t\t\\\n@@ -331,33 +274,29 @@ do\t\t\t\t\t\t\t\t\\\n       }\t\t\t\t\t\t\t\t\\\n  } while (0)\n \n-/* The following register have a special usage\n-   GPR 11: Frame pointer if needed to point to automatic variables. \n-   GPR 32: In functions with more the 5 args this register\n-           points to that arguments, it is always eliminated\n-\t   with stack- or frame-pointer. \n-   GPR 33: Condition code 'register' */\n-\n-#define HARD_FRAME_POINTER_REGNUM 11\n-#define FRAME_POINTER_REGNUM 34\n-\n-#define ARG_POINTER_REGNUM 32\n-\n-#define CC_REGNUM 33\n-\n-/* We use the register %r0 to pass the static chain to a nested function.\n-  \n-   Note: It is assumed that this register is call-clobbered!\n-         We can't use any of the function-argument registers either,\n-         and register 1 is needed by the trampoline code, so we have\n-         no other choice but using this one ...  */\n+/* Preferred register allocation order.  */\n+#define REG_ALLOC_ORDER                                         \\\n+{  1, 2, 3, 4, 5, 0, 14, 13, 12, 11, 10, 9, 8, 7, 6,            \\\n+   16, 17, 18, 19, 20, 21, 22, 23,                              \\\n+   24, 25, 26, 27, 28, 29, 30, 31,                              \\\n+   15, 32, 33, 34 }\n \n-#define STATIC_CHAIN_REGNUM 0\n \n-/* Return number of consecutive hard regs needed starting at reg REGNO\n-   to hold something of mode MODE.\n-   This is ordinarily the length in words of a value of mode MODE\n-   but can be less for certain modes in special long registers.  */\n+/* Fitting values into registers.  */\n+ \n+/* Integer modes <= word size fit into any GPR.\n+   Integer modes > word size fit into successive GPRs, starting with\n+   an even-numbered register.\n+   SImode and DImode fit into FPRs as well.\n+ \n+   Floating point modes <= word size fit into any FPR or GPR.\n+   Floating point modes > word size (i.e. DFmode on 32-bit) fit\n+   into any FPR, or an even-odd GPR pair.\n+ \n+   Complex floating point modes fit either into two FPRs, or into\n+   successive GPRs (again starting with an even number).\n+ \n+   Condition code modes fit only into the CC register.  */\n \n #define HARD_REGNO_NREGS(REGNO, MODE)                           \\\n   (FP_REGNO_P(REGNO)?                                           \\\n@@ -366,11 +305,6 @@ do\t\t\t\t\t\t\t\t\\\n     ((GET_MODE_SIZE(MODE)+UNITS_PER_WORD-1) / UNITS_PER_WORD) : \\\n    1)\n \n-/* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.\n-   The gprs can hold QI, HI, SI, SF, DF, SC and DC.\n-   Even gprs can hold DI.\n-   The floating point registers can hold DF, SF, DC and SC.  */\n-\n #define HARD_REGNO_MODE_OK(REGNO, MODE)                             \\\n   (FP_REGNO_P(REGNO)?                                               \\\n    ((MODE) == SImode || (MODE) == DImode ||                         \\\n@@ -382,103 +316,56 @@ do\t\t\t\t\t\t\t\t\\\n      GET_MODE_CLASS (MODE) == MODE_CC :                             \\\n    0)\n \n-/* Value is 1 if it is a good idea to tie two pseudo registers when one has\n-   mode MODE1 and one has mode MODE2.\n-   If HARD_REGNO_MODE_OK could produce different values for MODE1 and MODE2,\n-   for any hard reg, then this must be 0 for correct output.  */\n-\n #define MODES_TIEABLE_P(MODE1, MODE2)\t\t\\\n    (((MODE1) == SFmode || (MODE1) == DFmode)\t\\\n    == ((MODE2) == SFmode || (MODE2) == DFmode))\n \n-/* If defined, gives a class of registers that cannot be used as the\n-   operand of a SUBREG that changes the mode of the object illegally.  */\n+/* Maximum number of registers to represent a value of mode MODE\n+   in a register of class CLASS.  */\n+#define CLASS_MAX_NREGS(CLASS, MODE)   \t\t\t\t\t\\\n+     ((CLASS) == FP_REGS ? \t\t\t\t\t\t\\\n+      (GET_MODE_CLASS (MODE) == MODE_COMPLEX_FLOAT ? 2 : 1) :  \t\t\\\n+      (GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n \n+/* If a 4-byte value is loaded into a FPR, it is placed into the\n+   *upper* half of the register, not the lower.  Therefore, we\n+   cannot use SUBREGs to switch between modes in FP registers.  */\n #define CLASS_CANNOT_CHANGE_MODE FP_REGS\n-\n-/* Defines illegal mode changes for CLASS_CANNOT_CHANGE_MODE.  */\n-\n #define CLASS_CANNOT_CHANGE_MODE_P(FROM,TO) \\\n   (GET_MODE_SIZE (FROM) != GET_MODE_SIZE (TO))\n \n-/* This is an array of structures.  Each structure initializes one pair\n-   of eliminable registers.  The \"from\" register number is given first,\n-   followed by \"to\".  Eliminations of the same \"from\" register are listed\n-   in order of preference.  */\n \n-#define ELIMINABLE_REGS\t\t\t\t        \\\n-{{ FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM},\t        \\\n- { FRAME_POINTER_REGNUM, HARD_FRAME_POINTER_REGNUM},    \\\n- { ARG_POINTER_REGNUM, STACK_POINTER_REGNUM},\t        \\\n- { ARG_POINTER_REGNUM, HARD_FRAME_POINTER_REGNUM}}  \n-\n-#define CAN_ELIMINATE(FROM, TO) (1)\n-\n-#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET) \t\t\t  \\\n-{ if ((FROM) == FRAME_POINTER_REGNUM && (TO) == STACK_POINTER_REGNUM) \t  \\\n-  { (OFFSET) = 0; }     \t\t\t\t\t\t  \\\n-  else  if ((FROM) == FRAME_POINTER_REGNUM                                \\\n-\t    && (TO) == HARD_FRAME_POINTER_REGNUM)                \t  \\\n-  { (OFFSET) = 0; }     \t\t\t\t\t\t  \\\n-  else if ((FROM) == ARG_POINTER_REGNUM                                   \\\n-            && (TO) == HARD_FRAME_POINTER_REGNUM)                         \\\n-  { (OFFSET) = s390_arg_frame_offset (); }     \t\t\t\t  \\\n-  else if ((FROM) == ARG_POINTER_REGNUM && (TO) == STACK_POINTER_REGNUM)  \\\n-  { (OFFSET) = s390_arg_frame_offset (); }     \t\t\t\t  \\\n-  else\t\t\t\t\t\t\t\t\t  \\\n-    abort();\t\t\t\t\t\t\t\t  \\\n-}\n-\n-#define CAN_DEBUG_WITHOUT_FP\n-\n-/* Value should be nonzero if functions must have frame pointers.\n-   Zero means the frame pointer need not be set up (and parms may be\n-   accessed via the stack pointer) in functions that seem suitable.\n-   This is computed in `reload', in reload1.c.  */\n-\n-#define FRAME_POINTER_REQUIRED 0\n-\n-/* Define the classes of registers for register constraints in the\n-   machine description.  Also define ranges of constants.\n-  \n-   One of the classes must always be named ALL_REGS and include all hard regs.\n-   If there is more than one class, another class must be named NO_REGS\n-   and contain no registers.\n+/* Register classes.  */\n+ \n+/* We use the following register classes:\n+   GENERAL_REGS     All general purpose registers\n+   ADDR_REGS        All general purpose registers except %r0\n+                    (These registers can be used in address generation)\n+   FP_REGS          All floating point registers\n+ \n+   GENERAL_FP_REGS  Union of GENERAL_REGS and FP_REGS\n+   ADDR_FP_REGS     Union of ADDR_REGS and FP_REGS\n+ \n+   NO_REGS          No registers\n+   ALL_REGS         All registers\n  \n-   The name GENERAL_REGS must be the name of a class (or an alias for\n-   another name such as ALL_REGS).  This is the class of registers\n-   that is allowed by \"g\" or \"r\" in a register constraint.\n-   Also, registers outside this class are allocated only when\n-   instructions express preferences for them.\n-  \n-   The classes must be numbered in nondecreasing order; that is,\n-   a larger-numbered class must never be contained completely\n-   in a smaller-numbered class.\n-  \n-   For any two classes, it is very desirable that there be another\n-   class that represents their union.  */\n-\n-/*#define SMALL_REGISTER_CLASSES 1*/\n+   Note that the 'fake' frame pointer and argument pointer registers\n+   are included amongst the address registers here.  The condition\n+   code register is only included in ALL_REGS.  */\n \n enum reg_class\n {\n   NO_REGS, ADDR_REGS, GENERAL_REGS,\n   FP_REGS, ADDR_FP_REGS, GENERAL_FP_REGS,\n   ALL_REGS, LIM_REG_CLASSES\n };\n-\n #define N_REG_CLASSES (int) LIM_REG_CLASSES\n \n-/* Give names of register classes as strings for dump file.  */\n-\n #define REG_CLASS_NAMES                                                 \\\n { \"NO_REGS\", \"ADDR_REGS\", \"GENERAL_REGS\", \t\t\t\t\\\n   \"FP_REGS\", \"ADDR_FP_REGS\", \"GENERAL_FP_REGS\", \"ALL_REGS\" }\n \n-/* Define which registers fit in which classes.  This is an initializer for\n-   a vector of HARD_REG_SET of length N_REG_CLASSES.\n-   G5 and latter have 16 register and support IEEE floating point operations.  */\n-\n+/* Class -> register mapping.  */\n #define REG_CLASS_CONTENTS \\\n {\t\t\t\t       \t\t\t\\\n   { 0x00000000, 0x00000000 },\t/* NO_REGS */\t\t\\\n@@ -490,107 +377,97 @@ enum reg_class\n   { 0xffffffff, 0x00000007 },\t/* ALL_REGS */\t\t\\\n }\n \n+/* Register -> class mapping.  */\n+extern const enum reg_class regclass_map[FIRST_PSEUDO_REGISTER];\n+#define REGNO_REG_CLASS(REGNO) (regclass_map[REGNO])\n \n-/* The same information, inverted:\n-   Return the class number of the smallest class containing\n-   reg number REGNO.  This could be a conditional expression\n-   or could index an array.  */\n+/* ADDR_REGS can be used as base or index register.  */\n+#define INDEX_REG_CLASS ADDR_REGS\n+#define BASE_REG_CLASS ADDR_REGS\n \n-#define REGNO_REG_CLASS(REGNO) (regclass_map[REGNO])\n+/* Check whether REGNO is a hard register of the suitable class\n+   or a pseudo register currently allocated to one such.  */\n+#define REGNO_OK_FOR_INDEX_P(REGNO)\t\t\t\t\t\\\n+    (((REGNO) < FIRST_PSEUDO_REGISTER \t\t\t\t\t\\\n+     && REGNO_REG_CLASS ((REGNO)) == ADDR_REGS) \t\t\t\\\n+    || (reg_renumber[REGNO] > 0 && reg_renumber[REGNO] < 16))\n+#define REGNO_OK_FOR_BASE_P(REGNO) REGNO_OK_FOR_INDEX_P (REGNO)\n \n-extern const enum reg_class regclass_map[FIRST_PSEUDO_REGISTER]; /* smalled class containing REGNO   */\n \n-/* The class value for index registers, and the one for base regs.  */\n+/* Given an rtx X being reloaded into a reg required to be in class CLASS,\n+   return the class of reg to actually use.  */\n+#define PREFERRED_RELOAD_CLASS(X, CLASS)\t\\\n+  s390_preferred_reload_class ((X), (CLASS))\n \n-#define INDEX_REG_CLASS ADDR_REGS\n-#define BASE_REG_CLASS ADDR_REGS\n+/* We need a secondary reload when loading a PLUS which is\n+   not a valid operand for LOAD ADDRESS.  */\n+#define SECONDARY_INPUT_RELOAD_CLASS(CLASS, MODE, IN)\t\\\n+  s390_secondary_input_reload_class ((CLASS), (MODE), (IN))\n \n-/* Get reg_class from a letter such as appears in the machine description.  */\n+/* We need secondary memory to move data between GPRs and FPRs.  */\n+#define SECONDARY_MEMORY_NEEDED(CLASS1, CLASS2, MODE) \\\n+ ((CLASS1) != (CLASS2) && ((CLASS1) == FP_REGS || (CLASS2) == FP_REGS))\n+\n+/* Get_secondary_mem widens its argument to BITS_PER_WORD which loses on 64bit\n+   because the movsi and movsf patterns don't handle r/f moves.  */\n+#define SECONDARY_MEMORY_NEEDED_MODE(MODE)\t\t\\\n+ (GET_MODE_BITSIZE (MODE) < 32\t\t\t\t\\\n+  ? mode_for_size (32, GET_MODE_CLASS (MODE), 0)\t\\\n+  : MODE)\n+\n+\n+/* Define various machine-dependent constraint letters.  */\n \n #define REG_CLASS_FROM_LETTER(C)                                        \\\n   ((C) == 'a' ? ADDR_REGS :                                             \\\n    (C) == 'd' ? GENERAL_REGS :                                          \\\n    (C) == 'f' ? FP_REGS : NO_REGS)\n \n-/* The letters I, J, K, L and M in a register constraint string can be used\n-   to stand for particular ranges of immediate operands.\n-   This macro defines what the ranges are.\n-   C is the letter, and VALUE is a constant value.\n-   Return 1 if VALUE is in the range specified by C.  */\n-\n #define CONST_OK_FOR_LETTER_P(VALUE, C)                                 \\\n   ((C) == 'I' ? (unsigned long) (VALUE) < 256 :                         \\\n    (C) == 'J' ? (unsigned long) (VALUE) < 4096 :                        \\\n    (C) == 'K' ? (VALUE) >= -32768 && (VALUE) < 32768 :                  \\\n    (C) == 'L' ? (unsigned long) (VALUE) < 65536 : 0)\n \n-/* Similar, but for floating constants, and defining letters G and H.\n-   Here VALUE is the CONST_DOUBLE rtx itself.  */\n-\n #define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C)  1\n \n-/* 'Q' means a memory-reference for a S-type operand.  */\n-\n #define EXTRA_CONSTRAINT(OP, C)                               \t\\\n      ((C) == 'Q' ?  q_constraint (OP) : \t\t\t\\\n       (C) == 'S' ?  larl_operand (OP, GET_MODE (OP)) : 0)\n \n #define EXTRA_MEMORY_CONSTRAINT(C) ((C) == 'Q')\n \n-/* Given an rtx X being reloaded into a reg required to be in class CLASS,\n-   return the class of reg to actually use.  In general this is just CLASS;\n-   but on some machines in some cases it is preferable to use a more\n-   restrictive class.  */\n-\n-#define PREFERRED_RELOAD_CLASS(X, CLASS)\t\\\n-\ts390_preferred_reload_class ((X), (CLASS))\n-\n-/* Return the maximum number of consecutive registers needed to represent\n-   mode MODE in a register of class CLASS.  */\n-\n-#define CLASS_MAX_NREGS(CLASS, MODE)   \t\t\t\t\t\\\n-     ((CLASS) == FP_REGS ? \t\t\t\t\t\t\\\n-      (GET_MODE_CLASS (MODE) == MODE_COMPLEX_FLOAT ? 2 : 1) :  \t\t\\\n-      (GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n \n-/* We need a secondary reload when loading a PLUS which is \n-   not a valid operand for LOAD ADDRESS.  */\n-\n-#define SECONDARY_INPUT_RELOAD_CLASS(CLASS, MODE, IN)\t\\\n-\ts390_secondary_input_reload_class ((CLASS), (MODE), (IN))\n-\n-/* If we are copying between FP registers and anything else, we need a memory\n-   location.  */\n-\n-#define SECONDARY_MEMORY_NEEDED(CLASS1, CLASS2, MODE) \\\n- ((CLASS1) != (CLASS2) && ((CLASS1) == FP_REGS || (CLASS2) == FP_REGS))\n+/* Stack layout and calling conventions.  */\n+ \n+/* Our stack grows from higher to lower addresses.  However, local variables\n+   are accessed by positive offsets, and function arguments are stored at\n+   increasing addresses.  */\n+#define STACK_GROWS_DOWNWARD\n+/* #undef FRAME_GROWS_DOWNWARD */\n+/* #undef ARGS_GROW_DOWNWARD */\n \n-/* Get_secondary_mem widens its argument to BITS_PER_WORD which loses on 64bit\n-   because the movsi and movsf patterns don't handle r/f moves.  */\n-\n-#define SECONDARY_MEMORY_NEEDED_MODE(MODE)\t\t\\\n- (GET_MODE_BITSIZE (MODE) < 32\t\t\t\t\\\n-  ? mode_for_size (32, GET_MODE_CLASS (MODE), 0)\t\\\n-  : MODE)\n+/* The basic stack layout looks like this: the stack pointer points\n+   to the register save area for called functions.  Above that area\n+   is the location to place outgoing arguments.  Above those follow\n+   dynamic allocations (alloca), and finally the local variables.  */\n \n+/* Offset from stack-pointer to first location of outgoing args.  */\n+#define STACK_POINTER_OFFSET (TARGET_64BIT ? 160 : 96)\n \n-/* A C expression whose value is nonzero if pseudos that have been\n-   assigned to registers of class CLASS would likely be spilled\n-   because registers of CLASS are needed for spill registers.\n+/* Offset within stack frame to start allocating local variables at.  */\n+extern int current_function_outgoing_args_size;\n+#define STARTING_FRAME_OFFSET \\\n+     (STACK_POINTER_OFFSET + current_function_outgoing_args_size)\n \n-   The default value of this macro returns 1 if CLASS has exactly one\n-   register and zero otherwise.  On most machines, this default\n-   should be used.  Only define this macro to some other expression\n-   if pseudo allocated by `local-alloc.c' end up in memory because\n-   their hard registers were needed for spill registers.  If this\n-   macro returns nonzero for those classes, those pseudos will only\n-   be allocated by `global.c', which knows how to reallocate the\n-   pseudo to another register.  If there would not be another\n-   register available for reallocation, you should not change the\n-   definition of this macro since the only effect of such a\n-   definition would be to slow down register allocation.  */\n+/* Offset from the stack pointer register to an item dynamically\n+   allocated on the stack, e.g., by `alloca'.  */\n+#define STACK_DYNAMIC_OFFSET(FUNDECL) (STARTING_FRAME_OFFSET)\n \n-/* Stack layout; function entry, exit and calling.  */\n+/* Offset of first parameter from the argument pointer register value.\n+   We have a fake argument pointer register that points directly to\n+   the argument area.  */\n+#define FIRST_PARM_OFFSET(FNDECL) 0\n \n /* The return address of the current frame is retrieved \n    from the initial value of register RETURN_REGNUM.\n@@ -604,23 +481,15 @@ extern const enum reg_class regclass_map[FIRST_PSEUDO_REGISTER]; /* smalled clas\n #define RETURN_ADDR_RTX(COUNT, FRAME)\t\t\t\t\t\t\\\n   s390_return_addr_rtx ((COUNT), DYNAMIC_CHAIN_ADDRESS ((FRAME)))\n \n-/* The following macros will turn on dwarf2 exception hndling\n-   Other code location for this exception handling are \n-   in s390.md (eh_return insn) and in linux.c in the prologue.  */\n-\n-#define INCOMING_RETURN_ADDR_RTX  gen_rtx_REG (Pmode, RETURN_REGNUM)\n-\n-/* We have 31 bit mode.  */\n-\n+/* In 31-bit mode, we need to mask off the high bit of return addresses.  */\n #define MASK_RETURN_ADDR (TARGET_64BIT ? GEN_INT (-1) : GEN_INT (0x7fffffff))\n \n-/* The offset from the incoming value of %sp to the top of the stack frame\n-   for the current function.  */\n \n+/* Exception handling.  */\n+ \n+/* Describe calling conventions for DWARF-2 exception handling.  */\n+#define INCOMING_RETURN_ADDR_RTX  gen_rtx_REG (Pmode, RETURN_REGNUM)\n #define INCOMING_FRAME_SP_OFFSET STACK_POINTER_OFFSET\n-\n-/* Location, from where return address to load.  */\n-\n #define DWARF_FRAME_RETURN_COLUMN  14\n \n /* Describe how we implement __builtin_eh_return.  */\n@@ -630,161 +499,97 @@ extern const enum reg_class regclass_map[FIRST_PSEUDO_REGISTER]; /* smalled clas\n   gen_rtx_MEM (Pmode, plus_constant (arg_pointer_rtx, \\\n                                      TARGET_64BIT? -48 : -40))\n \n-/* Define this if pushing a word on the stack makes the stack pointer a\n-   smaller address.  */\n \n-#define STACK_GROWS_DOWNWARD\n+/* Frame registers.  */\n \n-/* Define this if the nominal address of the stack frame is at the\n-   high-address end of the local variables; that is, each additional local\n-   variable allocated goes at a more negative offset in the frame.  */\n+#define STACK_POINTER_REGNUM 15\n+#define FRAME_POINTER_REGNUM 34\n+#define HARD_FRAME_POINTER_REGNUM 11\n+#define ARG_POINTER_REGNUM 32\n \n-/* #define FRAME_GROWS_DOWNWARD   */\n+/* The static chain must be call-clobbered, but not used for \n+   function argument passing.  As register 1 is clobbered by \n+   the trampoline code, we only have one option.  */\n+#define STATIC_CHAIN_REGNUM 0\n \n-/* Offset from stack-pointer to first location of outgoing args.  */\n+/* Number of hardware registers that go into the DWARF-2 unwind info.\n+   To avoid ABI incompatibility, this number must not change even as\n+   'fake' hard registers are added or removed.  */\n+#define DWARF_FRAME_REGISTERS 34\n \n-#define STACK_POINTER_OFFSET (TARGET_64BIT ? 160 : 96)\n \n-/* Offset within stack frame to start allocating local variables at.\n-   If FRAME_GROWS_DOWNWARD, this is the offset to the END of the\n-   first local allocated.  Otherwise, it is the offset to the BEGINNING\n-   of the first local allocated.  */\n+/* Frame pointer and argument pointer elimination.  */\n \n-#define STARTING_FRAME_OFFSET \\\n-     (STACK_POINTER_OFFSET + current_function_outgoing_args_size)\n+#define FRAME_POINTER_REQUIRED 0\n \n #define INITIAL_FRAME_POINTER_OFFSET(DEPTH) (DEPTH) = 0\n \n-/* If we generate an insn to push BYTES bytes, this says how many the stack\n-   pointer really advances by.  On S/390, we have no push instruction.  */\n-\n-/* #define PUSH_ROUNDING(BYTES) */\n-\n-/* Accumulate the outgoing argument count so we can request the right\n-   DSA size and determine stack offset.  */\n-\n-#define ACCUMULATE_OUTGOING_ARGS 1\n-\n-/* Offset from the stack pointer register to an item dynamically\n-   allocated on the stack, e.g., by `alloca'.\n-\n-   The default value for this macro is `STACK_POINTER_OFFSET' plus the\n-   length of the outgoing arguments.  The default is correct for most\n-   machines.  See `function.c' for details.  */\n-#define STACK_DYNAMIC_OFFSET(FUNDECL) (STARTING_FRAME_OFFSET)\n+#define ELIMINABLE_REGS\t\t\t\t        \\\n+{{ FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM},\t        \\\n+ { FRAME_POINTER_REGNUM, HARD_FRAME_POINTER_REGNUM},    \\\n+ { ARG_POINTER_REGNUM, STACK_POINTER_REGNUM},\t        \\\n+ { ARG_POINTER_REGNUM, HARD_FRAME_POINTER_REGNUM}}  \n \n-/* Offset of first parameter from the argument pointer register value. \n-   On the S/390, we define the argument pointer to the start of the fixed\n-   area.  */\n-#define FIRST_PARM_OFFSET(FNDECL) 0\n+#define CAN_ELIMINATE(FROM, TO) (1)\n \n-/* Define this if stack space is still allocated for a parameter passed\n-   in a register.  The value is the number of bytes allocated to this\n-   area.  */\n-/* #define REG_PARM_STACK_SPACE(FNDECL)    32 */\n+#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET) \t\t\t  \\\n+{ if ((FROM) == FRAME_POINTER_REGNUM && (TO) == STACK_POINTER_REGNUM) \t  \\\n+  { (OFFSET) = 0; }     \t\t\t\t\t\t  \\\n+  else  if ((FROM) == FRAME_POINTER_REGNUM                                \\\n+\t    && (TO) == HARD_FRAME_POINTER_REGNUM)                \t  \\\n+  { (OFFSET) = 0; }     \t\t\t\t\t\t  \\\n+  else if ((FROM) == ARG_POINTER_REGNUM                                   \\\n+            && (TO) == HARD_FRAME_POINTER_REGNUM)                         \\\n+  { (OFFSET) = s390_arg_frame_offset (); }     \t\t\t\t  \\\n+  else if ((FROM) == ARG_POINTER_REGNUM && (TO) == STACK_POINTER_REGNUM)  \\\n+  { (OFFSET) = s390_arg_frame_offset (); }     \t\t\t\t  \\\n+  else\t\t\t\t\t\t\t\t\t  \\\n+    abort();\t\t\t\t\t\t\t\t  \\\n+}\n \n-/* Define this if the above stack space is to be considered part of the\n-   space allocated by the caller.  */\n-/* #define OUTGOING_REG_PARM_STACK_SPACE */\n \n-/* 1 if N is a possible register number for function argument passing.\n-   On S390, general registers 2 - 6 and floating point register 0 and 2\n-   are used in this way.  */\n+/* Stack arguments.  */\n+ \n+/* We need current_function_outgoing_args to be valid.  */\n+#define ACCUMULATE_OUTGOING_ARGS 1\n \n-#define FUNCTION_ARG_REGNO_P(N) (((N) >=2 && (N) <7) || \\\n-                                 (N) == 16 || (N) == 17)\n+/* Return doesn't modify the stack.  */\n+#define RETURN_POPS_ARGS(FUNDECL, FUNTYPE, SIZE) 0\n \n-/* Define a data type for recording info about an argument list during\n-   the scan of that argument list.  This data type should hold all\n-   necessary information about the function itself and about the args\n-   processed so far, enough to enable macros such as FUNCTION_ARG to\n-   determine where the next arg should go.  */\n \n+/* Register arguments.  */\n+ \n typedef struct s390_arg_structure\n {\n   int gprs;\t\t\t/* gpr so far */\n   int fprs;\t\t\t/* fpr so far */\n }\n CUMULATIVE_ARGS;\n \n-\n-/* Initialize a variable CUM of type CUMULATIVE_ARGS for a call to\n-   a function whose data type is FNTYPE.\n-   For a library call, FNTYPE is 0.  */\n-\n #define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME, NN) \\\n   ((CUM).gprs=0, (CUM).fprs=0)\n \n-/* Update the data in CUM to advance over an argument of mode MODE and\n-   data type TYPE.  (TYPE is null for libcalls where that information\n-   may not be available.) */\n-\n #define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)                    \\\n   s390_function_arg_advance (&CUM, MODE, TYPE, NAMED)\n \n-/* Define where to put the arguments to a function.  Value is zero to push\n-   the argument on the stack, or a hard register in which to store the\n-   argument.  */\n-\n #define FUNCTION_ARG(CUM, MODE, TYPE, NAMED)   \\\n   s390_function_arg (&CUM, MODE, TYPE, NAMED)\n \n-/* Define where to expect the arguments of a function.  Value is zero, if\n-   the argument is on the stack, or a hard register in which the argument\n-   is stored. It is the same like FUNCTION_ARG, except for unnamed args\n-   That means, that all in case of varargs used, the arguments are expected\n-   from the stack. \n-   S/390 has already space on the stack for args coming in registers, \n-   they are pushed in prologue, if needed.  */  \n-\n-\n-/* Define the `__builtin_va_list' type.  */\n-\n-#define BUILD_VA_LIST_TYPE(VALIST) \\\n-  (VALIST) = s390_build_va_list ()\n-\n-/* Implement `va_start' for varargs and stdarg.  */\n-\n-#define EXPAND_BUILTIN_VA_START(valist, nextarg) \\\n-  s390_va_start (valist, nextarg)\n-\n-/* Implement `va_arg'.  */\n-\n-#define EXPAND_BUILTIN_VA_ARG(valist, type) \\\n-  s390_va_arg (valist, type)\n-\n-/* For an arg passed partly in registers and partly in memory, this is the\n-   number of registers used.  For args passed entirely in registers or\n-   entirely in memory, zero.  */\n-\n-#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) 0\n-\n-\n-/* Define if returning from a function call automatically pops the\n-   arguments described by the number-of-args field in the call.  */\n-\n-#define RETURN_POPS_ARGS(FUNDECL, FUNTYPE, SIZE) 0\n-\n-\n-/* Define how to find the value returned by a function.  VALTYPE is the\n-   data type of the value (as a tree).\n-   If the precise function being called is known, FUNC is its FUNCTION_DECL;\n-   otherwise, FUNC is 15.  */\n-\n-#define RET_REG(MODE) ((GET_MODE_CLASS (MODE) == MODE_INT       \\\n-                       || TARGET_SOFT_FLOAT ) ? 2 : 16)\n-\n-\n-/* for structs the address is passed, and the Callee makes a\n-   copy, only if needed */\n-\n #define FUNCTION_ARG_PASS_BY_REFERENCE(CUM, MODE, TYPE, NAMED) \\\n   s390_function_arg_pass_by_reference (MODE, TYPE)\n \n+#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) 0\n+\n+/* Arguments can be placed in general registers 2 to 6,\n+   or in floating point registers 0 and 2.  */\n+#define FUNCTION_ARG_REGNO_P(N) (((N) >=2 && (N) <7) || \\\n+                                 (N) == 16 || (N) == 17)\n \n-/* Register 2 (and 3) for integral values\n-   or floating point register 0 (and 2) for fp values are used.  */\n \n+/* Scalar return values.  */\n+ \n+/* We return scalars in general purpose register 2 for integral values,\n+   and floating point register 0 for fp values.  */\n #define FUNCTION_VALUE(VALTYPE, FUNC)\t\t\t\t\\\n   gen_rtx_REG ((INTEGRAL_TYPE_P (VALTYPE)\t\t\t\\\n \t\t&& TYPE_PRECISION (VALTYPE) < BITS_PER_WORD)\t\\\n@@ -794,112 +599,77 @@ CUMULATIVE_ARGS;\n \n /* Define how to find the value returned by a library function assuming\n    the value has mode MODE.  */\n-\n+#define RET_REG(MODE) ((GET_MODE_CLASS (MODE) == MODE_INT       \\\n+                       || TARGET_SOFT_FLOAT ) ? 2 : 16)\n #define LIBCALL_VALUE(MODE)  gen_rtx (REG, MODE, RET_REG (MODE))\n \n-/* 1 if N is a possible register number for a function value.  */\n-\n+/* Only gpr 2 and fpr 0 are ever used as return registers.  */\n #define FUNCTION_VALUE_REGNO_P(N) ((N) == 2 || (N) == 16)\n \n+\n+/* Aggregate return values.  */\n+\n /* The definition of this macro implies that there are cases where\n    a scalar value cannot be returned in registers.  */\n-\n #define RETURN_IN_MEMORY(type)       \t\t\t\t\\\n   (TYPE_MODE (type) == BLKmode || \t\t\t\t\\\n    GET_MODE_CLASS (TYPE_MODE (type)) == MODE_COMPLEX_INT  ||\t\\\n    GET_MODE_CLASS (TYPE_MODE (type)) == MODE_COMPLEX_FLOAT)\n \n-/* Mode of stack savearea.\n-   FUNCTION is VOIDmode because calling convention maintains SP.\n-   BLOCK needs Pmode for SP.\n-   NONLOCAL needs twice Pmode to maintain both backchain and SP.  */\n-\n-#define STACK_SAVEAREA_MODE(LEVEL)      \\\n-  (LEVEL == SAVE_FUNCTION ? VOIDmode    \\\n-  : LEVEL == SAVE_NONLOCAL ? (TARGET_64BIT ? TImode : DImode) : Pmode)\n-\n /* Structure value address is passed as invisible first argument (gpr 2).  */\n-\n #define STRUCT_VALUE 0\n \n-/* This macro definition sets up a default value for `main' to return.  */\n \n-#define DEFAULT_MAIN_RETURN  c_expand_return (integer_zero_node)\n-\n-/* Length in units of the trampoline for entering a nested function.  */\n-\n-#define TRAMPOLINE_SIZE (TARGET_64BIT ? 36 : 20)\n-\n-/* Initialize the dynamic part of trampoline.  */\n-\n-#define INITIALIZE_TRAMPOLINE(ADDR, FNADDR, CXT)                       \\\n-   s390_initialize_trampoline ((ADDR), (FNADDR), (CXT))\n-\n-/* Template for constant part of trampoline.  */\n+/* Function entry and exit.  */\n+ \n+/* When returning from a function, the stack pointer does not matter.  */\n+#define EXIT_IGNORE_STACK       1\n \n-#define TRAMPOLINE_TEMPLATE(FILE)                                       \\\n-   s390_trampoline_template (FILE)\n \n-/* Output assembler code to FILE to increment profiler label # LABELNO\n-   for profiling a function entry.  */\n+/* Profiling.  */\n \n #define FUNCTION_PROFILER(FILE, LABELNO) \t\t\t\\\n-\ts390_function_profiler ((FILE), ((LABELNO)))\n+  s390_function_profiler ((FILE), ((LABELNO)))\n \n #define PROFILE_BEFORE_PROLOGUE 1\n \n-/* Define EXIT_IGNORE_STACK if, when returning from a function, the stack\n-   pointer does not matter (provided there is a frame pointer).  */\n \n-#define EXIT_IGNORE_STACK       1\n-\n-/* Addressing modes, and classification of registers for them.  */\n+/* Implementing the varargs macros.  */\n \n-/* #define HAVE_POST_INCREMENT */\n-/* #define HAVE_POST_DECREMENT */\n+#define BUILD_VA_LIST_TYPE(VALIST) \\\n+  (VALIST) = s390_build_va_list ()\n \n-/* #define HAVE_PRE_DECREMENT */\n-/* #define HAVE_PRE_INCREMENT */\n+#define EXPAND_BUILTIN_VA_START(valist, nextarg) \\\n+  s390_va_start (valist, nextarg)\n \n-/* These assume that REGNO is a hard or pseudo reg number.  They give\n-   nonzero only if REGNO is a hard reg of the suitable class or a pseudo\n-   reg currently allocated to a suitable hard reg.\n-   These definitions are NOT overridden anywhere.  */\n+#define EXPAND_BUILTIN_VA_ARG(valist, type) \\\n+  s390_va_arg (valist, type)\n \n-#define REGNO_OK_FOR_INDEX_P(REGNO)\t\t\t\t\t\\\n-    (((REGNO) < FIRST_PSEUDO_REGISTER \t\t\t\t\t\\\n-     && REGNO_REG_CLASS ((REGNO)) == ADDR_REGS) \t\t\t\\\n-    || (reg_renumber[REGNO] > 0 && reg_renumber[REGNO] < 16))\n \n-#define REGNO_OK_FOR_BASE_P(REGNO) REGNO_OK_FOR_INDEX_P (REGNO)\n+/* Trampolines for nested functions.  */\n \n-/* Maximum number of registers that can appear in a valid memory address.  */\n+#define TRAMPOLINE_SIZE (TARGET_64BIT ? 36 : 20)\n \n-#define MAX_REGS_PER_ADDRESS 2\n+#define INITIALIZE_TRAMPOLINE(ADDR, FNADDR, CXT)                       \\\n+   s390_initialize_trampoline ((ADDR), (FNADDR), (CXT))\n \n-/* Recognize any constant value that is a valid address.  */\n+#define TRAMPOLINE_TEMPLATE(FILE)                                       \\\n+   s390_trampoline_template (FILE)\n \n-#define CONSTANT_ADDRESS_P(X) 0\n \n-#define SYMBOLIC_CONST(X)       \\\n-(GET_CODE (X) == SYMBOL_REF                                             \\\n- || GET_CODE (X) == LABEL_REF                                           \\\n- || (GET_CODE (X) == CONST && symbolic_reference_mentioned_p (X)))\n+/* Library calls.  */\n+ \n+/* We should use memcpy, not bcopy.  */\n+#define TARGET_MEM_FUNCTIONS\n \n-/* General operand is everything except SYMBOL_REF, CONST and CONST_DOUBLE\n-   they have to be forced to constant pool\n-   CONST_INT have to be forced into constant pool, if greater than\n-   64k. Depending on the insn they have to be force into constant pool\n-   for smaller value; in this case we have to work with nonimmediate operand.  */\n \n-#define LEGITIMATE_PIC_OPERAND_P(X)  \\\n-      legitimate_pic_operand_p (X)\n+/* Addressing modes, and classification of registers for them.  */\n \n-/* Nonzero if the constant value X is a legitimate general operand.\n-   It is given that X satisfies CONSTANT_P or is a CONST_DOUBLE.  */\n+/* Recognize any constant value that is a valid address.  */\n+#define CONSTANT_ADDRESS_P(X) 0\n \n-#define LEGITIMATE_CONSTANT_P(X) \\\n-     legitimate_constant_p (X)\n+/* Maximum number of registers that can appear in a valid memory address.  */\n+#define MAX_REGS_PER_ADDRESS 2\n \n /* The macros REG_OK_FOR..._P assume that the arg is a REG rtx and check\n    its validity for a certain class.  We have two alternate definitions\n@@ -912,32 +682,19 @@ CUMULATIVE_ARGS;\n    Some source files that are used after register allocation\n    need to be strict.  */\n \n-/* \n- * Nonzero if X is a hard reg that can be used as an index or if it is\n- * a pseudo reg.  \n- */\n-\n #define REG_OK_FOR_INDEX_NONSTRICT_P(X)   \t\\\n ((GET_MODE (X) == Pmode) &&\t\t\t\\\n  ((REGNO (X) >= FIRST_PSEUDO_REGISTER) \t\t\\\n   || REGNO_REG_CLASS (REGNO (X)) == ADDR_REGS))  \n \n-/* Nonzero if X is a hard reg that can be used as a base reg or if it is\n-   a pseudo reg.  */\n-\n #define REG_OK_FOR_BASE_NONSTRICT_P(X)    REG_OK_FOR_INDEX_NONSTRICT_P (X)\n \n-/* Nonzero if X is a hard reg that can be used as an index.  */\n-\n #define REG_OK_FOR_INDEX_STRICT_P(X) \t\t\t\t\\\n ((GET_MODE (X) == Pmode) && (REGNO_OK_FOR_INDEX_P (REGNO (X))))\n \n-/* Nonzero if X is a hard reg that can be used as a base reg.  */\n-\n #define REG_OK_FOR_BASE_STRICT_P(X)\t\t\t\t\\\n ((GET_MODE (X) == Pmode) && (REGNO_OK_FOR_BASE_P (REGNO (X))))\n \n-\n #ifndef REG_OK_STRICT\n #define REG_OK_FOR_INDEX_P(X)  REG_OK_FOR_INDEX_NONSTRICT_P(X)\n #define REG_OK_FOR_BASE_P(X)   REG_OK_FOR_BASE_NONSTRICT_P(X)\n@@ -946,15 +703,13 @@ CUMULATIVE_ARGS;\n #define REG_OK_FOR_BASE_P(X)   REG_OK_FOR_BASE_STRICT_P(X)\n #endif\n \n+/* S/390 has no mode dependent addresses.  */\n+#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR, LABEL)\n \n /* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression that is a\n    valid memory address for an instruction.\n    The MODE argument is the machine mode for the MEM expression\n-   that wants to use this address.\n-\n-   The other macros defined here are used only in GO_IF_LEGITIMATE_ADDRESS,\n-   except for CONSTANT_ADDRESS_P which is actually machine-independent.  */\n-\n+   that wants to use this address.  */\n #ifdef REG_OK_STRICT\n #define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)                         \\\n {                                                                       \\\n@@ -969,102 +724,41 @@ CUMULATIVE_ARGS;\n }\n #endif\n \n-\n-/* S/390 has no mode dependent addresses.  */\n-\n-#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR, LABEL)\n-\n /* Try machine-dependent ways of modifying an illegitimate address\n    to be legitimate.  If we find one, return the new, valid address.\n    This macro is used in only one place: `memory_address' in explow.c.  */\n-\n #define LEGITIMIZE_ADDRESS(X, OLDX, MODE, WIN)                          \\\n {                                                                       \\\n   (X) = legitimize_address (X, OLDX, MODE);                             \\\n   if (memory_address_p (MODE, X))                                       \\\n     goto WIN;                                                           \\\n }\n \n-/* Specify the machine mode that this machine uses for the index in the\n-   tablejump instruction.  */\n-\n-#define CASE_VECTOR_MODE (TARGET_64BIT ? DImode : SImode)\n-\n-/* Define this if the tablejump instruction expects the table to contain\n-   offsets from the address of the table.\n-   Do not define this if the table should contain absolute addresses.  */\n-\n-/* #define CASE_VECTOR_PC_RELATIVE */\n-\n-/* Load from integral MODE < SI from memory into register makes sign_extend\n-   or zero_extend  \n-   In our case sign_extension happens for Halfwords, other no extension.  */\n-\n-#define LOAD_EXTEND_OP(MODE) \t\t\t\t\t\\\n-(TARGET_64BIT ? ((MODE) == QImode ? ZERO_EXTEND :               \\\n-                 (MODE) == HImode ? SIGN_EXTEND : NIL)          \\\n-              : ((MODE) == HImode ? SIGN_EXTEND : NIL))\n-\n-/* Define this if fixuns_trunc is the same as fix_trunc.  */\n-\n-/* #define FIXUNS_TRUNC_LIKE_FIX_TRUNC */\n-\n-/* We use \"unsigned char\" as default.  */\n-\n-#define DEFAULT_SIGNED_CHAR 0\n-\n-/* The maximum number of bytes that a single instruction can move quickly\n-   between memory and registers or between two memory locations. */\n-\n-#define MOVE_MAX (TARGET_64BIT ? 16 : 8)\n-#define MAX_MOVE_MAX 16\n-\n-/* Determine whether to use move_by_pieces or block move insn.  */\n-\n-#define MOVE_BY_PIECES_P(SIZE, ALIGN)\t\t\\\n-  ( (SIZE) == 1 || (SIZE) == 2 || (SIZE) == 4\t\\\n-    || (TARGET_64BIT && (SIZE) == 8) )\n-\n-/* Determine whether to use clear_by_pieces or block clear insn.  */\n-\n-#define CLEAR_BY_PIECES_P(SIZE, ALIGN)\t\t\\\n-  ( (SIZE) == 1 || (SIZE) == 2 || (SIZE) == 4\t\\\n-    || (TARGET_64BIT && (SIZE) == 8) )\n-\n-/* Nonzero if access to memory by bytes is slow and undesirable.  */\n-\n-#define SLOW_BYTE_ACCESS 1\n-\n-/* Define if shifts truncate the shift count which implies one can omit\n-   a sign-extension or zero-extension of a shift count.  */\n-\n-/* #define SHIFT_COUNT_TRUNCATED */\n-\n-/* Value is 1 if truncating an integer of INPREC bits to OUTPREC bits\n-   is done just by pretending it is already truncated.  */\n-\n-#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC)  1\n-\n-/* We assume that the store-condition-codes instructions store 0 for false\n-   and some other value for true.  This is the value stored for true.  */\n-\n-/* #define STORE_FLAG_VALUE -1 */\n-\n-/* Don't perform CSE on function addresses.  */\n+/* Nonzero if the constant value X is a legitimate general operand.\n+   It is given that X satisfies CONSTANT_P or is a CONST_DOUBLE.  */\n+#define LEGITIMATE_CONSTANT_P(X) \\\n+     legitimate_constant_p (X)\n \n-#define NO_FUNCTION_CSE\n+/* Helper macro for s390.c and s390.md to check for symbolic constants.  */\n+#define SYMBOLIC_CONST(X)       \\\n+(GET_CODE (X) == SYMBOL_REF                                             \\\n+ || GET_CODE (X) == LABEL_REF                                           \\\n+ || (GET_CODE (X) == CONST && symbolic_reference_mentioned_p (X)))\n \n-/* Specify the machine mode that pointers have.\n-   After generation of rtl, the compiler makes no further distinction\n-   between pointers and any other objects of this machine mode.  */\n \n-#define Pmode ((enum machine_mode) (TARGET_64BIT ? DImode : SImode))\n+/* Condition codes.  */\n \n-/* A function address in a call instruction is a byte address (for\n-   indexing purposes) so give the MEM rtx a byte's mode.  */\n+/* Given a comparison code (EQ, NE, etc.) and the first operand of a COMPARE,\n+   return the mode to be used for the comparison.  */\n+#define SELECT_CC_MODE(OP, X, Y) s390_select_ccmode ((OP), (X), (Y))\n+ \n+/* Define the information needed to generate branch and scc insns.  This is\n+   stored from the compare operation.  Note that we can't use \"rtx\" here\n+   since it hasn't been defined!  */\n+extern struct rtx_def *s390_compare_op0, *s390_compare_op1;\n \n-#define FUNCTION_MODE QImode\n \n+/* Relative costs of operations.  */\n \n /* A part of a C `switch' statement that describes the relative costs\n    of constant RTL expressions.  It must contain `case' labels for\n@@ -1085,7 +779,6 @@ CUMULATIVE_ARGS;\n    than a short. Because of that we give an addition of greater\n    constants a cost of 3 (reload1.c 10096).  */\n \n-\n #define CONST_COSTS(RTX, CODE, OUTER_CODE)                      \\\n   case CONST:                                                   \\\n     if ((GET_CODE (XEXP (RTX, 0)) == MINUS) &&                  \\\n@@ -1107,10 +800,7 @@ CUMULATIVE_ARGS;\n    instruction is.  In writing this macro, you can use the construct\n    `COSTS_N_INSNS (N)' to specify a cost equal to N fast\n    instructions.  OUTER_CODE is the code of the expression in which X\n-   is contained.\n-\n-   This macro is optional; do not define it if the default cost\n-   assumptions are adequate for the target machine.  */\n+   is contained.  */\n \n #define RTX_COSTS(X, CODE, OUTER_CODE)                                  \\\n   case ASHIFT:                                                          \\\n@@ -1138,86 +828,78 @@ CUMULATIVE_ARGS;\n \n /* An expression giving the cost of an addressing mode that contains\n    ADDRESS.  If not defined, the cost is computed from the ADDRESS\n-   expression and the `CONST_COSTS' values.\n-\n-   For most CISC machines, the default cost is a good approximation\n-   of the true cost of the addressing mode.  However, on RISC\n-   machines, all instructions normally have the same length and\n-   execution time.  Hence all addresses will have equal costs.\n-\n-   In cases where more than one form of an address is known, the form\n-   with the lowest cost will be used.  If multiple forms have the\n-   same, lowest, cost, the one that is the most complex will be used.\n-\n-   For example, suppose an address that is equal to the sum of a\n-   register and a constant is used twice in the same basic block.\n-   When this macro is not defined, the address will be computed in a\n-   register and memory references will be indirect through that\n-   register.  On machines where the cost of the addressing mode\n-   containing the sum is no higher than that of a simple indirect\n-   reference, this will produce an additional instruction and\n-   possibly require an additional register.  Proper specification of\n-   this macro eliminates this overhead for such machines.\n-\n-   Similar use of this macro is made in strength reduction of loops.\n-\n-   ADDRESS need not be valid as an address.  In such a case, the cost\n-   is not relevant and can be any value; invalid addresses need not be\n-   assigned a different cost.\n-\n-   On machines where an address involving more than one register is as\n-   cheap as an address computation involving only one register,\n-   defining `ADDRESS_COST' to reflect this can cause two registers to\n-   be live over a region of code where only one would have been if\n-   `ADDRESS_COST' were not defined in that manner.  This effect should\n-   be considered in the definition of this macro.  Equivalent costs\n-   should probably only be given to addresses with different numbers\n-   of registers on machines with lots of registers.\n-\n-   This macro will normally either not be defined or be defined as a\n-   constant.  */\n-\n+   expression and the `CONST_COSTS' values.  */\n #define ADDRESS_COST(RTX) s390_address_cost ((RTX))\n \n /* On s390, copy between fprs and gprs is expensive.  */\n-\n #define REGISTER_MOVE_COST(MODE, CLASS1, CLASS2)                        \\\n   ((   (   reg_classes_intersect_p ((CLASS1), GENERAL_REGS)\t\t\\\n         && reg_classes_intersect_p ((CLASS2), FP_REGS))\t\t\t\\\n     || (   reg_classes_intersect_p ((CLASS1), FP_REGS)\t\t\t\\\n         && reg_classes_intersect_p ((CLASS2), GENERAL_REGS))) ? 10 : 1)\n \n-\n /* A C expression for the cost of moving data of mode M between a\n    register and memory.  A value of 2 is the default; this cost is\n-   relative to those in `REGISTER_MOVE_COST'.\n-\n-   If moving between registers and memory is more expensive than\n-   between two registers, you should define this macro to express the\n-   relative cost.  */\n-\n+   relative to those in `REGISTER_MOVE_COST'.  */\n #define MEMORY_MOVE_COST(M, C, I) 1\n \n /* A C expression for the cost of a branch instruction.  A value of 1\n    is the default; other values are interpreted relative to that.  */\n-\n #define BRANCH_COST 1\n \n-/* Given a comparison code (EQ, NE, etc.) and the first operand of a COMPARE,\n-   return the mode to be used for the comparison.  */\n- \n-#define SELECT_CC_MODE(OP, X, Y) s390_select_ccmode ((OP), (X), (Y))\n- \n- \n-/* Define the information needed to generate branch and scc insns.  This is\n-   stored from the compare operation.  Note that we can't use \"rtx\" here\n-   since it hasn't been defined!  */\n- \n-extern struct rtx_def *s390_compare_op0, *s390_compare_op1;\n+/* Nonzero if access to memory by bytes is slow and undesirable.  */\n+#define SLOW_BYTE_ACCESS 1\n+\n+/* The maximum number of bytes that a single instruction can move quickly\n+   between memory and registers or between two memory locations. */\n+#define MOVE_MAX (TARGET_64BIT ? 16 : 8)\n+#define MAX_MOVE_MAX 16\n \n-/* implicit call of memcpy, not bcopy   */\n+/* Determine whether to use move_by_pieces or block move insn.  */\n+#define MOVE_BY_PIECES_P(SIZE, ALIGN)\t\t\\\n+  ( (SIZE) == 1 || (SIZE) == 2 || (SIZE) == 4\t\\\n+    || (TARGET_64BIT && (SIZE) == 8) )\n+\n+/* Determine whether to use clear_by_pieces or block clear insn.  */\n+#define CLEAR_BY_PIECES_P(SIZE, ALIGN)\t\t\\\n+  ( (SIZE) == 1 || (SIZE) == 2 || (SIZE) == 4\t\\\n+    || (TARGET_64BIT && (SIZE) == 8) )\n+\n+/* Don't perform CSE on function addresses.  */\n+#define NO_FUNCTION_CSE\n+\n+\n+/* Sections.  */\n+\n+/* Output before read-only data.  */\n+#define TEXT_SECTION_ASM_OP \".text\"\n+\n+/* Output before writable (initialized) data.  */\n+#define DATA_SECTION_ASM_OP \".data\"\n+\n+/* Output before writable (uninitialized) data.  */\n+#define BSS_SECTION_ASM_OP \".bss\"\n+\n+/* S/390 constant pool breaks the devices in crtstuff.c to control section\n+   in where code resides.  We have to write it as asm code.  */\n+#ifndef __s390x__\n+#define CRT_CALL_STATIC_FUNCTION(SECTION_OP, FUNC) \\\n+    asm (SECTION_OP \"\\n\\\n+\tbras\\t%r2,1f\\n\\\n+0:\t.long\\t\" USER_LABEL_PREFIX #FUNC \" - 0b\\n\\\n+1:\tl\\t%r3,0(%r2)\\n\\\n+\tbas\\t%r14,0(%r3,%r2)\\n\\\n+\t.previous\");\n+#endif\n \n-#define TARGET_MEM_FUNCTIONS\n+\n+/* Position independent code.  */\n+\n+extern int flag_pic; \n+\n+#define PIC_OFFSET_TABLE_REGNUM (flag_pic ? 12 : INVALID_REGNUM)\n+\n+#define LEGITIMATE_PIC_OPERAND_P(X)  legitimate_pic_operand_p (X)\n \n \n /* Assembler file format.  */\n@@ -1250,6 +932,10 @@ extern struct rtx_def *s390_compare_op0, *s390_compare_op1;\n /* The LOCAL_LABEL_PREFIX variable is used by dbxelf.h.  */\n #define LOCAL_LABEL_PREFIX \".\"\n \n+/* Either simplify a location expression, or return the original.  */\n+#define ASM_SIMPLIFY_DWARF_ADDR(X) \\\n+  s390_simplify_dwarf_addr (X)\n+\n /* How to refer to registers in assembler output.  This sequence is\n    indexed by compiler's hard-register-number (see above).  */\n #define REGISTER_NAMES\t\t\t\t\t\t\t\\\n@@ -1260,10 +946,6 @@ extern struct rtx_def *s390_compare_op0, *s390_compare_op1;\n   \"%ap\",  \"%cc\",  \"%fp\"\t\t\t\t\t\t\t\\\n }\n \n-/* Either simplify a location expression, or return the original.  */\n-#define ASM_SIMPLIFY_DWARF_ADDR(X) \\\n-  s390_simplify_dwarf_addr (X)\n-\n /* Print operand X (an rtx) in assembler syntax to file FILE.  */\n #define PRINT_OPERAND(FILE, X, CODE) print_operand (FILE, X, CODE)\n #define PRINT_OPERAND_ADDRESS(FILE, ADDR) print_operand_address (FILE, ADDR)\n@@ -1292,44 +974,6 @@ do {\t\t\t\t\t\t\t\t\t\\\n } while (0)\n \n \n-/* Define the codes that are matched by predicates in aux-output.c.  */\n-\n-#define PREDICATE_CODES\t\t\t\t\t\t\t\\\n-  {\"s_operand\",       { SUBREG, MEM }},\t\t\t\t\t\\\n-  {\"s_imm_operand\",   { CONST_INT, CONST_DOUBLE, SUBREG, MEM }},\t\\\n-  {\"bras_sym_operand\",{ SYMBOL_REF, CONST }},\t\t\t\t\\\n-  {\"larl_operand\",    { SYMBOL_REF, CONST, CONST_INT, CONST_DOUBLE }},\t\\\n-  {\"load_multiple_operation\", {PARALLEL}},\t\t\t        \\\n-  {\"store_multiple_operation\", {PARALLEL}},\t\t\t        \\\n-  {\"const0_operand\",  { CONST_INT, CONST_DOUBLE }},\t\t\t\\\n-  {\"consttable_operand\", { SYMBOL_REF, LABEL_REF, CONST, \t\t\\\n-\t\t\t   CONST_INT, CONST_DOUBLE }},\t\t\t\\\n-  {\"s390_plus_operand\", { PLUS }},\n-\n-\n-/* Sections.  */\n-\n-/* Output before read-only data.  */\n-#define TEXT_SECTION_ASM_OP \".text\"\n-\n-/* Output before writable (initialized) data.  */\n-#define DATA_SECTION_ASM_OP \".data\"\n-\n-/* Output before writable (uninitialized) data.  */\n-#define BSS_SECTION_ASM_OP \".bss\"\n-\n-/* S/390 constant pool breaks the devices in crtstuff.c to control section\n-   in where code resides.  We have to write it as asm code.  */\n-#ifndef __s390x__\n-#define CRT_CALL_STATIC_FUNCTION(SECTION_OP, FUNC) \\\n-    asm (SECTION_OP \"\\n\\\n-\tbras\\t%r2,1f\\n\\\n-0:\t.long\\t\" USER_LABEL_PREFIX #FUNC \" - 0b\\n\\\n-1:\tl\\t%r3,0(%r2)\\n\\\n-\tbas\\t%r14,0(%r3,%r2)\\n\\\n-\t.previous\");\n-#endif\n-\n /* Constant Pool for all symbols operands which are changed with\n    force_const_mem during insn generation (expand_insn).  */\n \n@@ -1389,11 +1033,54 @@ extern int s390_nr_constants;\n   goto WIN;\t\t\t\t\t\t\t\t    \\\n }\n \n+\n+/* Miscellaneous parameters.  */\n+\n+/* Define the codes that are matched by predicates in aux-output.c.  */\n+#define PREDICATE_CODES\t\t\t\t\t\t\t\\\n+  {\"s_operand\",       { SUBREG, MEM }},\t\t\t\t\t\\\n+  {\"s_imm_operand\",   { CONST_INT, CONST_DOUBLE, SUBREG, MEM }},\t\\\n+  {\"bras_sym_operand\",{ SYMBOL_REF, CONST }},\t\t\t\t\\\n+  {\"larl_operand\",    { SYMBOL_REF, CONST, CONST_INT, CONST_DOUBLE }},\t\\\n+  {\"load_multiple_operation\", {PARALLEL}},\t\t\t        \\\n+  {\"store_multiple_operation\", {PARALLEL}},\t\t\t        \\\n+  {\"const0_operand\",  { CONST_INT, CONST_DOUBLE }},\t\t\t\\\n+  {\"consttable_operand\", { SYMBOL_REF, LABEL_REF, CONST, \t\t\\\n+\t\t\t   CONST_INT, CONST_DOUBLE }},\t\t\t\\\n+  {\"s390_plus_operand\", { PLUS }},\n+\n+/* Specify the machine mode that this machine uses for the index in the\n+   tablejump instruction.  */\n+#define CASE_VECTOR_MODE (TARGET_64BIT ? DImode : SImode)\n+\n+/* Load from integral MODE < SI from memory into register makes sign_extend\n+   or zero_extend  \n+   In our case sign_extension happens for Halfwords, other no extension.  */\n+#define LOAD_EXTEND_OP(MODE) \t\t\t\t\t\\\n+(TARGET_64BIT ? ((MODE) == QImode ? ZERO_EXTEND :               \\\n+                 (MODE) == HImode ? SIGN_EXTEND : NIL)          \\\n+              : ((MODE) == HImode ? SIGN_EXTEND : NIL))\n+\n+/* Value is 1 if truncating an integer of INPREC bits to OUTPREC bits\n+   is done just by pretending it is already truncated.  */\n+#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC)  1\n+\n+/* Specify the machine mode that pointers have.\n+   After generation of rtl, the compiler makes no further distinction\n+   between pointers and any other objects of this machine mode.  */\n+#define Pmode ((enum machine_mode) (TARGET_64BIT ? DImode : SImode))\n+\n+/* A function address in a call instruction is a byte address (for\n+   indexing purposes) so give the MEM rtx a byte's mode.  */\n+#define FUNCTION_MODE QImode\n+\n+/* This macro definition sets up a default value for `main' to return.  */\n+#define DEFAULT_MAIN_RETURN  c_expand_return (integer_zero_node)\n+\n /* In rare cases, correct code generation requires extra machine dependent\n    processing between the second jump optimization pass and delayed branch\n    scheduling.  On those machines, define this macro as a C statement to act on\n    the code starting at INSN.  */\n- \n #define MACHINE_DEPENDENT_REORG(INSN) s390_machine_dependent_reorg (INSN)\n \n #endif "}]}