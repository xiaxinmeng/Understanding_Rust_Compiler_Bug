{"sha": "a827daa06b2335bb93c09c5a8753725f40a76ef4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTgyN2RhYTA2YjIzMzViYjkzYzA5YzVhODc1MzcyNWY0MGE3NmVmNA==", "commit": {"author": {"name": "Paolo Carlini", "email": "pcarlini@suse.de", "date": "2003-12-22T11:00:43Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2003-12-22T11:00:43Z"}, "message": "locale_facets.tcc (num_get::_M_extract_int, [...]): According to 22.2.2.1.2...\n\n2003-12-22  Paolo Carlini  <pcarlini@suse.de>\n\n\t* include/bits/locale_facets.tcc (num_get::_M_extract_int,\n\tnum_get::_M_extract_float): According to 22.2.2.1.2, p8-9,\n\tfirst look for decimal_point and thousands_sep, when parsing\n\tsign, leading zeros (and 0, Ox, 0X for integer types) too.\n\t* testsuite/22_locale/num_get/get/char/12.cc: New.\n\t* testsuite/22_locale/num_get/get/wchar_t/12.cc: Likewise.\n\n\t* testsuite/22_locale/num_get/get/char/11.cc: Add a comment.\n\t* testsuite/22_locale/num_get/get/wchar_t/11.cc: Likewise.\n\nFrom-SVN: r74932", "tree": {"sha": "60a1fed9a0230867f41beb5c113006bf26cde6d8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/60a1fed9a0230867f41beb5c113006bf26cde6d8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a827daa06b2335bb93c09c5a8753725f40a76ef4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a827daa06b2335bb93c09c5a8753725f40a76ef4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a827daa06b2335bb93c09c5a8753725f40a76ef4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a827daa06b2335bb93c09c5a8753725f40a76ef4/comments", "author": null, "committer": null, "parents": [{"sha": "9e62871ee9f5f2ed5ee3c4651ef2123388a82028", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e62871ee9f5f2ed5ee3c4651ef2123388a82028", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e62871ee9f5f2ed5ee3c4651ef2123388a82028"}], "stats": {"total": 430, "additions": 391, "deletions": 39}, "files": [{"sha": "d8ca538327a409eeca927dced1f7802746de5f42", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a827daa06b2335bb93c09c5a8753725f40a76ef4/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a827daa06b2335bb93c09c5a8753725f40a76ef4/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=a827daa06b2335bb93c09c5a8753725f40a76ef4", "patch": "@@ -1,3 +1,15 @@\n+2003-12-22  Paolo Carlini  <pcarlini@suse.de>\n+\n+\t* include/bits/locale_facets.tcc (num_get::_M_extract_int,\n+\tnum_get::_M_extract_float): According to 22.2.2.1.2, p8-9,\n+\tfirst look for decimal_point and thousands_sep, when parsing\n+\tsign, leading zeros (and 0, Ox, 0X for integer types) too.\n+\t* testsuite/22_locale/num_get/get/char/12.cc: New.\n+\t* testsuite/22_locale/num_get/get/wchar_t/12.cc: Likewise.\n+\n+\t* testsuite/22_locale/num_get/get/char/11.cc: Add a comment.\n+\t* testsuite/22_locale/num_get/get/wchar_t/11.cc: Likewise.\n+\t\n 2003-12-20  Jason Merrill  <jason@redhat.com>\n \n \t* config/cpu/powerpc/atomicity.h: Fix oversight in previous"}, {"sha": "265c1437ebae111a47cc9b649fdd475bcdbbeb10", "filename": "libstdc++-v3/include/bits/locale_facets.tcc", "status": "modified", "additions": 57, "deletions": 39, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a827daa06b2335bb93c09c5a8753725f40a76ef4/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a827daa06b2335bb93c09c5a8753725f40a76ef4/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.tcc?ref=a827daa06b2335bb93c09c5a8753725f40a76ef4", "patch": "@@ -163,29 +163,44 @@ namespace std\n       const __cache_type* __lc = __uc(__loc);\n       const _CharT* __lit = __lc->_M_atoms_in;\n \n+      // True if a mantissa is found.\n+      bool __found_mantissa = false;\n+\n       // First check for sign.\n       if (__beg != __end)\n \t{\n \t  const char_type __c = *__beg;\n \t  const bool __plus = __traits_type::eq(__c, __lit[_S_iplus]);\n-\t  if (__plus || __traits_type::eq(__c, __lit[_S_iminus]))\n+\t  if ((__plus || __traits_type::eq(__c, __lit[_S_iminus]))\n+\t      && !__traits_type::eq(__c, __lc->_M_decimal_point)\n+\t      && (!__lc->_M_use_grouping\n+\t\t  || !__traits_type::eq(__c, __lc->_M_thousands_sep)))\n \t    {\n \t      __xtrc += __plus ? _S_atoms_in[_S_iplus]\n \t\t               : _S_atoms_in[_S_iminus];\n \t      ++__beg;\n \t    }\n \t}\n \t  \n-      // Next, look for a zero...\n-      bool __found_mantissa = false;\n-      if (__beg != __end && __traits_type::eq(*__beg, __lit[_S_izero]))\n+      // Next, look for leading zeros.\n+      while (__beg != __end)\n \t{\n-\t  __xtrc += _S_atoms_in[_S_izero];\n-\t  __found_mantissa = true;\n-\t  ++__beg;\n-\t  // ... and skip the additional ones.\n-\t  for (; __beg != __end\n-\t\t && __traits_type::eq(*__beg, __lit[_S_izero]); ++__beg);\n+\t  const char_type __c = *__beg;\n+\t  if (__traits_type::eq(__c, __lc->_M_decimal_point)\n+\t      || (__lc->_M_use_grouping \n+\t\t  && __traits_type::eq(__c, __lc->_M_thousands_sep)))\n+\t    break;\n+\t  else if (__traits_type::eq(__c, __lit[_S_izero]))\n+\t    {\n+\t      if (!__found_mantissa)\n+\t\t{\n+\t\t  __xtrc += _S_atoms_in[_S_izero];\n+\t\t  __found_mantissa = true;\n+\t\t}\n+\t      ++__beg;\n+\t    }\n+\t  else\n+\t    break;\n \t}\n \n       // Only need acceptable digits for floating point numbers.\n@@ -307,48 +322,51 @@ namespace std\n \t// First check for sign.\n \tbool __negative = false;\n \tif (__beg != __end)\n-\t  {\n+\t  { \n+\t    const char_type __c = *__beg;\n \t    if (numeric_limits<_ValueT>::is_signed)\n-\t      __negative = __traits_type::eq(*__beg, __lit[_S_iminus]);\n-\t    if (__negative || __traits_type::eq(*__beg, __lit[_S_iplus]))\n+\t      __negative = __traits_type::eq(__c, __lit[_S_iminus]);\n+\t    if ((__negative || __traits_type::eq(__c, __lit[_S_iplus]))\n+\t\t&& !__traits_type::eq(__c, __lc->_M_decimal_point)\n+\t\t&& (!__lc->_M_use_grouping\n+\t\t    || !__traits_type::eq(__c, __lc->_M_thousands_sep)))\n \t      ++__beg;\n \t  }\n \n \t// Next, look for leading zeros and check required digits\n \t// for base formats.\n-\tif (__beg != __end && __traits_type::eq(*__beg, __lit[_S_izero]))\n+\twhile (__beg != __end)\n \t  {\n-\t    __found_num = true;\n-\t    ++__beg;\n-\t    if (__builtin_expect(__base == 10, true))\n+\t    const char_type __c = *__beg;\n+\t    if (__traits_type::eq(__c, __lc->_M_decimal_point)\n+\t\t|| (__lc->_M_use_grouping\n+\t\t    && __traits_type::eq(__c, __lc->_M_thousands_sep)))\n+\t      break;\n+\t    else if (__traits_type::eq(__c, __lit[_S_izero])\n+\t\t     && (!__found_num || __base == 10))\n \t      {\n-\t\t// Skip the additional zeros.\n-\t\tfor (; __beg != __end\n-\t\t       && __traits_type::eq(*__beg, __lit[_S_izero]); ++__beg);\n-\t\t\n-\t\t// Check required digits.\n-\t\tif (__beg != __end && __basefield == 0)\n-\t\t  {\t  \n-\t\t    const bool __x = __traits_type::eq(*__beg, __lit[_S_ix]);\n-\t\t    if (__x || __traits_type::eq(*__beg, __lit[_S_iX]))\n-\t\t      {\n-\t\t\t__base = 16;\n-\t\t\t++__beg;\n-\t\t\t__found_num = false;\n-\t\t      }\n-\t\t    else\n-\t\t      __base = 8;\n-\t\t  }\t      \n+\t\t__found_num = true;\n+\t\t++__beg;\n \t      }\n-\t    else if (__base == 16 && __beg != __end)\n+\t    else if (__found_num)\n \t      {\n-\t\tconst bool __x = __traits_type::eq(*__beg, __lit[_S_ix]);\n-\t\tif (__x || __traits_type::eq(*__beg, __lit[_S_iX]))\n+\t\tif (__traits_type::eq(__c, __lit[_S_ix])\n+\t\t    || __traits_type::eq(__c, __lit[_S_iX]))\n \t\t  {\n-\t\t    ++__beg;\n-\t\t    __found_num = false;\n+\t\t    if (__basefield == 0)\n+\t\t      __base = 16;\n+\t\t    if (__base == 16)\n+\t\t      {\n+\t\t\t__found_num = false;\n+\t\t\t++__beg;\n+\t\t      }\n \t\t  }\n+\t\telse if (__basefield == 0)\n+\t\t  __base = 8;\n+\t\tbreak;\n \t      }\n+\t    else\n+\t      break;\n \t  }\n \n \t// At this point, base is determined. If not hex, only allow"}, {"sha": "138f10d0a0c5752e4f34189483be7e062227a1b6", "filename": "libstdc++-v3/testsuite/22_locale/num_get/get/char/11.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a827daa06b2335bb93c09c5a8753725f40a76ef4/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fnum_get%2Fget%2Fchar%2F11.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a827daa06b2335bb93c09c5a8753725f40a76ef4/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fnum_get%2Fget%2Fchar%2F11.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fnum_get%2Fget%2Fchar%2F11.cc?ref=a827daa06b2335bb93c09c5a8753725f40a76ef4", "patch": "@@ -29,6 +29,7 @@ struct Punct: std::numpunct<char>\n   char do_decimal_point() const { return '4'; }\n };\n \n+// http://gcc.gnu.org/ml/libstdc++/2003-12/msg00201.html\n void test01()\n {\n   using namespace std;"}, {"sha": "1898867086f4281f736701cf7ab54ddd6f90f33c", "filename": "libstdc++-v3/testsuite/22_locale/num_get/get/char/12.cc", "status": "added", "additions": 160, "deletions": 0, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a827daa06b2335bb93c09c5a8753725f40a76ef4/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fnum_get%2Fget%2Fchar%2F12.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a827daa06b2335bb93c09c5a8753725f40a76ef4/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fnum_get%2Fget%2Fchar%2F12.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fnum_get%2Fget%2Fchar%2F12.cc?ref=a827daa06b2335bb93c09c5a8753725f40a76ef4", "patch": "@@ -0,0 +1,160 @@\n+// 2003-12-22  Paolo Carlini  <pcarlini@suse.de>\n+\n+// Copyright (C) 2003 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 22.2.2.1.1  num_get members\n+\n+#include <locale>\n+#include <sstream>\n+#include <testsuite_hooks.h>\n+\n+struct Punct1: std::numpunct<char>\n+{\n+  std::string do_grouping() const { return \"\\1\"; }\n+  char do_thousands_sep() const { return '+'; }\n+  char do_decimal_point() const { return 'x'; }\n+};\n+\n+struct Punct2: std::numpunct<char>\n+{\n+  std::string do_grouping() const { return \"\\1\"; }\n+  char do_thousands_sep() const { return 'X'; }\n+  char do_decimal_point() const { return '-'; }\n+};\n+\n+// http://gcc.gnu.org/ml/libstdc++/2003-12/msg00201.html\n+void test01()\n+{\n+  using namespace std;\n+  typedef istreambuf_iterator<char> iterator_type;\n+  \n+  bool test __attribute__((unused)) = true;\n+\n+  istringstream iss1, iss2;\n+  iss1.imbue(locale(iss1.getloc(), static_cast<numpunct<char>*>(new Punct1)));\n+  iss2.imbue(locale(iss2.getloc(), static_cast<numpunct<char>*>(new Punct2)));\n+  const num_get<char>& ng1 = use_facet<num_get<char> >(iss1.getloc()); \n+  const num_get<char>& ng2 = use_facet<num_get<char> >(iss2.getloc()); \n+\n+  ios_base::iostate err = ios_base::goodbit;\n+  iterator_type end;\n+  long l = 1l;\n+  long l1 = 0l;\n+  long l2 = 10l;\n+  long l3 = 1l;\n+  long l4 = 63l;\n+  double d = 0.0;\n+  double d1 = .4;  \n+  double d2 = .1;\n+\n+  iss1.str(\"+3\");\n+  err = ios_base::goodbit;\n+  end = ng1.get(iss1.rdbuf(), 0, iss1, err, l);\n+  VERIFY( err == ios_base::failbit );\n+  VERIFY( *end == '+' );\n+\n+  iss1.str(\"0x1\");\n+  iss1.clear();\n+  err = ios_base::goodbit;\n+  end = ng1.get(iss1.rdbuf(), 0, iss1, err, l);\n+  VERIFY( err == ios_base::goodbit );\n+  VERIFY( *end == 'x' );\n+  VERIFY( l == l1 );\n+\n+  iss1.str(\"0Xa\");\n+  iss1.clear();\n+  iss1.unsetf(ios::basefield);\n+  err = ios_base::goodbit;\n+  end = ng1.get(iss1.rdbuf(), 0, iss1, err, l);\n+  VERIFY( err == ios_base::eofbit );\n+  VERIFY( l == l2 );\n+\n+  iss1.str(\"0xa\");\n+  iss1.clear();\n+  err = ios_base::goodbit;\n+  end = ng1.get(iss1.rdbuf(), 0, iss1, err, l);\n+  VERIFY( err == ios_base::goodbit );\n+  VERIFY( *end == 'x' );\n+  VERIFY( l == l1 );  \n+\n+  iss1.str(\"+5\");\n+  iss1.clear();\n+  err = ios_base::goodbit;\n+  end = ng1.get(iss1.rdbuf(), 0, iss1, err, d);\n+  VERIFY( err == ios_base::failbit );\n+  VERIFY( *end == '+' );\n+\n+  iss1.str(\"x4\");\n+  iss1.clear();\n+  err = ios_base::goodbit;\n+  end = ng1.get(iss1.rdbuf(), 0, iss1, err, d);\n+  VERIFY( err == ios_base::eofbit );\n+  VERIFY( d == d1 );\n+\n+  iss2.str(\"0001-\");\n+  err = ios_base::goodbit;\n+  end = ng2.get(iss2.rdbuf(), 0, iss2, err, l);\n+  VERIFY( err == ios_base::goodbit );\n+  VERIFY( *end == '-' );\n+  VERIFY( l == l3 );\n+\n+  iss2.str(\"-2\");\n+  iss2.clear();\n+  err = ios_base::goodbit;\n+  end = ng2.get(iss2.rdbuf(), 0, iss2, err, l);\n+  VERIFY( err == ios_base::failbit );\n+  VERIFY( *end == '-' );\n+\n+  iss2.str(\"0X1\");\n+  iss2.clear();\n+  iss2.unsetf(ios::basefield);\n+  err = ios_base::goodbit;\n+  end = ng2.get(iss2.rdbuf(), 0, iss2, err, l);\n+  VERIFY( err == ios_base::failbit );\n+  VERIFY( *end == 'X' );\n+\n+  iss2.str(\"000778\");\n+  iss2.clear();\n+  err = ios_base::goodbit;\n+  end = ng2.get(iss2.rdbuf(), 0, iss2, err, l);\n+  VERIFY( err == ios_base::goodbit );\n+  VERIFY( *end == '8' );\n+  VERIFY( l == l4 );\n+\n+  iss2.str(\"00X\");\n+  iss2.clear();\n+  err = ios_base::goodbit;\n+  end = ng2.get(iss2.rdbuf(), 0, iss2, err, d);\n+  VERIFY( err == ios_base::failbit );\n+  VERIFY( *end == 'X' );\n+\n+  iss2.str(\"-1\");\n+  iss2.clear();\n+  err = ios_base::goodbit;\n+  end = ng2.get(iss2.rdbuf(), 0, iss2, err, d);\n+  VERIFY( err == ios_base::eofbit );\n+  VERIFY( d == d2 );  \n+}\n+\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "d478209f49dec6055477c8b2fb6b0016ba7d23f5", "filename": "libstdc++-v3/testsuite/22_locale/num_get/get/wchar_t/11.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a827daa06b2335bb93c09c5a8753725f40a76ef4/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fnum_get%2Fget%2Fwchar_t%2F11.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a827daa06b2335bb93c09c5a8753725f40a76ef4/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fnum_get%2Fget%2Fwchar_t%2F11.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fnum_get%2Fget%2Fwchar_t%2F11.cc?ref=a827daa06b2335bb93c09c5a8753725f40a76ef4", "patch": "@@ -29,6 +29,7 @@ struct Punct: std::numpunct<wchar_t>\n   wchar_t do_decimal_point() const { return L'4'; }\n };\n \n+// http://gcc.gnu.org/ml/libstdc++/2003-12/msg00201.html\n void test01()\n {\n   using namespace std;"}, {"sha": "fa9cb15973c317589962fb3cf63673d9b58b692b", "filename": "libstdc++-v3/testsuite/22_locale/num_get/get/wchar_t/12.cc", "status": "added", "additions": 160, "deletions": 0, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a827daa06b2335bb93c09c5a8753725f40a76ef4/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fnum_get%2Fget%2Fwchar_t%2F12.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a827daa06b2335bb93c09c5a8753725f40a76ef4/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fnum_get%2Fget%2Fwchar_t%2F12.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fnum_get%2Fget%2Fwchar_t%2F12.cc?ref=a827daa06b2335bb93c09c5a8753725f40a76ef4", "patch": "@@ -0,0 +1,160 @@\n+// 2003-12-22  Paolo Carlini  <pcarlini@suse.de>\n+\n+// Copyright (C) 2003 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 22.2.2.1.1  num_get members\n+\n+#include <locale>\n+#include <sstream>\n+#include <testsuite_hooks.h>\n+\n+struct Punct1: std::numpunct<wchar_t>\n+{\n+  std::string do_grouping() const { return \"\\1\"; }\n+  wchar_t do_thousands_sep() const { return L'+'; }\n+  wchar_t do_decimal_point() const { return L'x'; }\n+};\n+\n+struct Punct2: std::numpunct<wchar_t>\n+{\n+  std::string do_grouping() const { return \"\\1\"; }\n+  wchar_t do_thousands_sep() const { return L'X'; }\n+  wchar_t do_decimal_point() const { return L'-'; }\n+};\n+\n+// http://gcc.gnu.org/ml/libstdc++/2003-12/msg00201.html\n+void test01()\n+{\n+  using namespace std;\n+  typedef istreambuf_iterator<wchar_t> iterator_type;\n+  \n+  bool test __attribute__((unused)) = true;\n+\n+  wistringstream iss1, iss2;\n+  iss1.imbue(locale(iss1.getloc(), static_cast<numpunct<wchar_t>*>(new Punct1)));\n+  iss2.imbue(locale(iss2.getloc(), static_cast<numpunct<wchar_t>*>(new Punct2)));\n+  const num_get<wchar_t>& ng1 = use_facet<num_get<wchar_t> >(iss1.getloc()); \n+  const num_get<wchar_t>& ng2 = use_facet<num_get<wchar_t> >(iss2.getloc()); \n+\n+  ios_base::iostate err = ios_base::goodbit;\n+  iterator_type end;\n+  long l = 1l;\n+  long l1 = 0l;\n+  long l2 = 10l;\n+  long l3 = 1l;\n+  long l4 = 63l;\n+  double d = 0.0;\n+  double d1 = .4;  \n+  double d2 = .1;\n+\n+  iss1.str(L\"+3\");\n+  err = ios_base::goodbit;\n+  end = ng1.get(iss1.rdbuf(), 0, iss1, err, l);\n+  VERIFY( err == ios_base::failbit );\n+  VERIFY( *end == L'+' );\n+\n+  iss1.str(L\"0x1\");\n+  iss1.clear();\n+  err = ios_base::goodbit;\n+  end = ng1.get(iss1.rdbuf(), 0, iss1, err, l);\n+  VERIFY( err == ios_base::goodbit );\n+  VERIFY( *end == L'x' );\n+  VERIFY( l == l1 );\n+\n+  iss1.str(L\"0Xa\");\n+  iss1.clear();\n+  iss1.unsetf(ios::basefield);\n+  err = ios_base::goodbit;\n+  end = ng1.get(iss1.rdbuf(), 0, iss1, err, l);\n+  VERIFY( err == ios_base::eofbit );\n+  VERIFY( l == l2 );\n+\n+  iss1.str(L\"0xa\");\n+  iss1.clear();\n+  err = ios_base::goodbit;\n+  end = ng1.get(iss1.rdbuf(), 0, iss1, err, l);\n+  VERIFY( err == ios_base::goodbit );\n+  VERIFY( *end == L'x' );\n+  VERIFY( l == l1 );  \n+\n+  iss1.str(L\"+5\");\n+  iss1.clear();\n+  err = ios_base::goodbit;\n+  end = ng1.get(iss1.rdbuf(), 0, iss1, err, d);\n+  VERIFY( err == ios_base::failbit );\n+  VERIFY( *end == L'+' );\n+\n+  iss1.str(L\"x4\");\n+  iss1.clear();\n+  err = ios_base::goodbit;\n+  end = ng1.get(iss1.rdbuf(), 0, iss1, err, d);\n+  VERIFY( err == ios_base::eofbit );\n+  VERIFY( d == d1 );\n+\n+  iss2.str(L\"0001-\");\n+  err = ios_base::goodbit;\n+  end = ng2.get(iss2.rdbuf(), 0, iss2, err, l);\n+  VERIFY( err == ios_base::goodbit );\n+  VERIFY( *end == L'-' );\n+  VERIFY( l == l3 );\n+\n+  iss2.str(L\"-2\");\n+  iss2.clear();\n+  err = ios_base::goodbit;\n+  end = ng2.get(iss2.rdbuf(), 0, iss2, err, l);\n+  VERIFY( err == ios_base::failbit );\n+  VERIFY( *end == L'-' );\n+\n+  iss2.str(L\"0X1\");\n+  iss2.clear();\n+  iss2.unsetf(ios::basefield);\n+  err = ios_base::goodbit;\n+  end = ng2.get(iss2.rdbuf(), 0, iss2, err, l);\n+  VERIFY( err == ios_base::failbit );\n+  VERIFY( *end == L'X' );\n+\n+  iss2.str(L\"000778\");\n+  iss2.clear();\n+  err = ios_base::goodbit;\n+  end = ng2.get(iss2.rdbuf(), 0, iss2, err, l);\n+  VERIFY( err == ios_base::goodbit );\n+  VERIFY( *end == L'8' );\n+  VERIFY( l == l4 );\n+\n+  iss2.str(L\"00X\");\n+  iss2.clear();\n+  err = ios_base::goodbit;\n+  end = ng2.get(iss2.rdbuf(), 0, iss2, err, d);\n+  VERIFY( err == ios_base::failbit );\n+  VERIFY( *end == L'X' );\n+\n+  iss2.str(L\"-1\");\n+  iss2.clear();\n+  err = ios_base::goodbit;\n+  end = ng2.get(iss2.rdbuf(), 0, iss2, err, d);\n+  VERIFY( err == ios_base::eofbit );\n+  VERIFY( d == d2 );  \n+}\n+\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}]}