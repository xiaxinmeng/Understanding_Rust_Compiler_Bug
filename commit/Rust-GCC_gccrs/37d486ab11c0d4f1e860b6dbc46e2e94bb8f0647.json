{"sha": "37d486ab11c0d4f1e860b6dbc46e2e94bb8f0647", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzdkNDg2YWIxMWMwZDRmMWU4NjBiNmRiYzQ2ZTJlOTRiYjhmMDY0Nw==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2015-07-24T08:25:41Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2015-07-24T08:25:41Z"}, "message": "gimple-fold.c (replace_stmt_with_simplification): Special-case valueizing call operands.\n\n2015-07-24  Richard Biener  <rguenther@suse.de>\n\n\t* gimple-fold.c (replace_stmt_with_simplification): Special-case\n\tvalueizing call operands.\n\t* gimple-match-head.c (maybe_push_res_to_seq): Take\n\tnumber of call arguments from ops array.\n\t(do_valueize): New function.\n\t(gimple_simplify): Return true if valueization changed\n\tany operand even if the result didn't simplify further.\n\nFrom-SVN: r226139", "tree": {"sha": "762fcfff7fe872d4458ad5bab5afaf8c962e9a5b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/762fcfff7fe872d4458ad5bab5afaf8c962e9a5b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/37d486ab11c0d4f1e860b6dbc46e2e94bb8f0647", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37d486ab11c0d4f1e860b6dbc46e2e94bb8f0647", "html_url": "https://github.com/Rust-GCC/gccrs/commit/37d486ab11c0d4f1e860b6dbc46e2e94bb8f0647", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37d486ab11c0d4f1e860b6dbc46e2e94bb8f0647/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "74b7ec8c45c8db5df69e7a9894e6306e1d631a58", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74b7ec8c45c8db5df69e7a9894e6306e1d631a58", "html_url": "https://github.com/Rust-GCC/gccrs/commit/74b7ec8c45c8db5df69e7a9894e6306e1d631a58"}], "stats": {"total": 256, "additions": 104, "deletions": 152}, "files": [{"sha": "47f7237d224ff7d51b2c80a27aa65a1085610c4e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37d486ab11c0d4f1e860b6dbc46e2e94bb8f0647/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37d486ab11c0d4f1e860b6dbc46e2e94bb8f0647/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=37d486ab11c0d4f1e860b6dbc46e2e94bb8f0647", "patch": "@@ -1,3 +1,13 @@\n+2015-07-24  Richard Biener  <rguenther@suse.de>\n+\n+\t* gimple-fold.c (replace_stmt_with_simplification): Special-case\n+\tvalueizing call operands.\n+\t* gimple-match-head.c (maybe_push_res_to_seq): Take\n+\tnumber of call arguments from ops array.\n+\t(do_valueize): New function.\n+\t(gimple_simplify): Return true if valueization changed\n+\tany operand even if the result didn't simplify further.\n+\n 2015-07-24  Naveen H.S  <Naveen.Hurugalawadi@caviumnetworks.com>\n \n \tPR middle-end/25530"}, {"sha": "64f27917e6152c763294d401ed9d6a877b57e73f", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37d486ab11c0d4f1e860b6dbc46e2e94bb8f0647/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37d486ab11c0d4f1e860b6dbc46e2e94bb8f0647/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=37d486ab11c0d4f1e860b6dbc46e2e94bb8f0647", "patch": "@@ -3398,6 +3398,19 @@ replace_stmt_with_simplification (gimple_stmt_iterator *gsi,\n \t  return true;\n \t}\n     }\n+  else if (rcode.is_fn_code ()\n+\t   && gimple_call_builtin_p (stmt, rcode))\n+    {\n+      unsigned i;\n+      for (i = 0; i < gimple_call_num_args (stmt); ++i)\n+\t{\n+\t  gcc_assert (ops[i] != NULL_TREE);\n+\t  gimple_call_set_arg (stmt, i, ops[i]);\n+\t}\n+      if (i < 3)\n+\tgcc_assert (ops[i] == NULL_TREE);\n+      return true;\n+    }\n   else if (!inplace)\n     {\n       if (gimple_has_lhs (stmt))"}, {"sha": "ca7acdfb4a427b5b3db8d123b46ae9ebd3f0f802", "filename": "gcc/gimple-match-head.c", "status": "modified", "additions": 81, "deletions": 152, "changes": 233, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37d486ab11c0d4f1e860b6dbc46e2e94bb8f0647/gcc%2Fgimple-match-head.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37d486ab11c0d4f1e860b6dbc46e2e94bb8f0647/gcc%2Fgimple-match-head.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-match-head.c?ref=37d486ab11c0d4f1e860b6dbc46e2e94bb8f0647", "patch": "@@ -338,19 +338,18 @@ maybe_push_res_to_seq (code_helper rcode, tree type, tree *ops,\n       tree decl = builtin_decl_implicit (rcode);\n       if (!decl)\n \treturn NULL_TREE;\n-      unsigned nargs = type_num_arguments (TREE_TYPE (decl));\n-      gcc_assert (nargs <= 3);\n       /* Play safe and do not allow abnormals to be mentioned in\n          newly created statements.  */\n-      if ((TREE_CODE (ops[0]) == SSA_NAME\n-\t   && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (ops[0]))\n-\t  || (nargs >= 2\n-\t      && TREE_CODE (ops[1]) == SSA_NAME\n-\t      && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (ops[1]))\n-\t  || (nargs == 3\n-\t      && TREE_CODE (ops[2]) == SSA_NAME\n-\t      && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (ops[2])))\n-\treturn NULL_TREE;\n+      unsigned nargs;\n+      for (nargs = 0; nargs < 3; ++nargs)\n+\t{\n+\t  if (!ops[nargs])\n+\t    break;\n+\t  if (TREE_CODE (ops[nargs]) == SSA_NAME\n+\t      && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (ops[nargs]))\n+\t    return NULL_TREE;\n+\t}\n+      gcc_assert (nargs != 0);\n       if (!res)\n \tres = make_ssa_name (type);\n       gimple new_stmt = gimple_build_call (decl, nargs, ops[0], ops[1], ops[2]);\n@@ -563,6 +562,23 @@ gimple_simplify (enum built_in_function fn, tree type,\n   return maybe_push_res_to_seq (rcode, type, ops, seq);\n }\n \n+/* Helper for gimple_simplify valueizing OP using VALUEIZE and setting\n+   VALUEIZED to true if valueization changed OP.  */\n+\n+static inline tree\n+do_valueize (tree op, tree (*valueize)(tree), bool &valueized)\n+{\n+  if (valueize && TREE_CODE (op) == SSA_NAME)\n+    {\n+      tree tem = valueize (op);\n+      if (tem && tem != op)\n+\t{\n+\t  op = tem;\n+\t  valueized = true;\n+\t}\n+    }\n+  return op;\n+}\n \n /* The main STMT based simplification entry.  It is used by the fold_stmt\n    and the fold_stmt_to_constant APIs.  */\n@@ -587,31 +603,25 @@ gimple_simplify (gimple stmt,\n \t\t|| code == VIEW_CONVERT_EXPR)\n \t      {\n \t\ttree op0 = TREE_OPERAND (gimple_assign_rhs1 (stmt), 0);\n-\t\tif (top_valueize && TREE_CODE (op0) == SSA_NAME)\n-\t\t  {\n-\t\t    tree tem = top_valueize (op0);\n-\t\t    if (tem)\n-\t\t      op0 = tem;\n-\t\t  }\n+\t\tbool valueized = false;\n+\t\top0 = do_valueize (op0, top_valueize, valueized);\n \t\t*rcode = code;\n \t\tops[0] = op0;\n-\t\treturn gimple_resimplify1 (seq, rcode, type, ops, valueize);\n+\t\treturn (gimple_resimplify1 (seq, rcode, type, ops, valueize)\n+\t\t\t|| valueized);\n \t      }\n \t    else if (code == BIT_FIELD_REF)\n \t      {\n \t\ttree rhs1 = gimple_assign_rhs1 (stmt);\n \t\ttree op0 = TREE_OPERAND (rhs1, 0);\n-\t\tif (top_valueize && TREE_CODE (op0) == SSA_NAME)\n-\t\t  {\n-\t\t    tree tem = top_valueize (op0);\n-\t\t    if (tem)\n-\t\t      op0 = tem;\n-\t\t  }\n+\t\tbool valueized = false;\n+\t\top0 = do_valueize (op0, top_valueize, valueized);\n \t\t*rcode = code;\n \t\tops[0] = op0;\n \t\tops[1] = TREE_OPERAND (rhs1, 1);\n \t\tops[2] = TREE_OPERAND (rhs1, 2);\n-\t\treturn gimple_resimplify3 (seq, rcode, type, ops, valueize);\n+\t\treturn (gimple_resimplify3 (seq, rcode, type, ops, valueize)\n+\t\t\t|| valueized);\n \t      }\n \t    else if (code == SSA_NAME\n \t\t     && top_valueize)\n@@ -628,65 +638,41 @@ gimple_simplify (gimple stmt,\n \t  case GIMPLE_UNARY_RHS:\n \t    {\n \t      tree rhs1 = gimple_assign_rhs1 (stmt);\n-\t      if (top_valueize && TREE_CODE (rhs1) == SSA_NAME)\n-\t\t{\n-\t\t  tree tem = top_valueize (rhs1);\n-\t\t  if (tem)\n-\t\t    rhs1 = tem;\n-\t\t}\n+\t      bool valueized = false;\n+\t      rhs1 = do_valueize (rhs1, top_valueize, valueized);\n \t      *rcode = code;\n \t      ops[0] = rhs1;\n-\t      return gimple_resimplify1 (seq, rcode, type, ops, valueize);\n+\t      return (gimple_resimplify1 (seq, rcode, type, ops, valueize)\n+\t\t      || valueized);\n \t    }\n \t  case GIMPLE_BINARY_RHS:\n \t    {\n \t      tree rhs1 = gimple_assign_rhs1 (stmt);\n-\t      if (top_valueize && TREE_CODE (rhs1) == SSA_NAME)\n-\t\t{\n-\t\t  tree tem = top_valueize (rhs1);\n-\t\t  if (tem)\n-\t\t    rhs1 = tem;\n-\t\t}\n \t      tree rhs2 = gimple_assign_rhs2 (stmt);\n-\t      if (top_valueize && TREE_CODE (rhs2) == SSA_NAME)\n-\t\t{\n-\t\t  tree tem = top_valueize (rhs2);\n-\t\t  if (tem)\n-\t\t    rhs2 = tem;\n-\t\t}\n+\t      bool valueized = false;\n+\t      rhs1 = do_valueize (rhs1, top_valueize, valueized);\n+\t      rhs2 = do_valueize (rhs2, top_valueize, valueized);\n \t      *rcode = code;\n \t      ops[0] = rhs1;\n \t      ops[1] = rhs2;\n-\t      return gimple_resimplify2 (seq, rcode, type, ops, valueize);\n+\t      return (gimple_resimplify2 (seq, rcode, type, ops, valueize)\n+\t\t      || valueized);\n \t    }\n \t  case GIMPLE_TERNARY_RHS:\n \t    {\n \t      tree rhs1 = gimple_assign_rhs1 (stmt);\n-\t      if (top_valueize && TREE_CODE (rhs1) == SSA_NAME)\n-\t\t{\n-\t\t  tree tem = top_valueize (rhs1);\n-\t\t  if (tem)\n-\t\t    rhs1 = tem;\n-\t\t}\n \t      tree rhs2 = gimple_assign_rhs2 (stmt);\n-\t      if (top_valueize && TREE_CODE (rhs2) == SSA_NAME)\n-\t\t{\n-\t\t  tree tem = top_valueize (rhs2);\n-\t\t  if (tem)\n-\t\t    rhs2 = tem;\n-\t\t}\n \t      tree rhs3 = gimple_assign_rhs3 (stmt);\n-\t      if (top_valueize && TREE_CODE (rhs3) == SSA_NAME)\n-\t\t{\n-\t\t  tree tem = top_valueize (rhs3);\n-\t\t  if (tem)\n-\t\t    rhs3 = tem;\n-\t\t}\n+\t      bool valueized = false;\n+\t      rhs1 = do_valueize (rhs1, top_valueize, valueized);\n+\t      rhs2 = do_valueize (rhs2, top_valueize, valueized);\n+\t      rhs3 = do_valueize (rhs3, top_valueize, valueized);\n \t      *rcode = code;\n \t      ops[0] = rhs1;\n \t      ops[1] = rhs2;\n \t      ops[2] = rhs3;\n-\t      return gimple_resimplify3 (seq, rcode, type, ops, valueize);\n+\t      return (gimple_resimplify3 (seq, rcode, type, ops, valueize)\n+\t\t      || valueized);\n \t    }\n \t  default:\n \t    gcc_unreachable ();\n@@ -696,120 +682,63 @@ gimple_simplify (gimple stmt,\n \n     case GIMPLE_CALL:\n       /* ???  This way we can't simplify calls with side-effects.  */\n-      if (gimple_call_lhs (stmt) != NULL_TREE)\n+      if (gimple_call_lhs (stmt) != NULL_TREE\n+\t  && gimple_call_num_args (stmt) >= 1\n+\t  && gimple_call_num_args (stmt) <= 3)\n \t{\n \t  tree fn = gimple_call_fn (stmt);\n \t  /* ???  Internal function support missing.  */\n \t  if (!fn)\n \t    return false;\n-\t  if (top_valueize && TREE_CODE (fn) == SSA_NAME)\n-\t    {\n-\t      tree tem = top_valueize (fn);\n-\t      if (tem)\n-\t\tfn = tem;\n-\t    }\n-\t  if (!fn\n-\t      || TREE_CODE (fn) != ADDR_EXPR\n-\t      || TREE_CODE (TREE_OPERAND (fn, 0)) != FUNCTION_DECL\n-\t      || DECL_BUILT_IN_CLASS (TREE_OPERAND (fn, 0)) != BUILT_IN_NORMAL\n-\t      || !builtin_decl_implicit (DECL_FUNCTION_CODE (TREE_OPERAND (fn, 0)))\n-\t      || !gimple_builtin_call_types_compatible_p (stmt,\n-\t\t\t\t\t\t\t  TREE_OPERAND (fn, 0)))\n+\t  bool valueized = false;\n+\t  fn = do_valueize (fn, top_valueize, valueized);\n+\t  if (TREE_CODE (fn) != ADDR_EXPR\n+\t      || TREE_CODE (TREE_OPERAND (fn, 0)) != FUNCTION_DECL)\n \t    return false;\n \n \t  tree decl = TREE_OPERAND (fn, 0);\n+\t  if (DECL_BUILT_IN_CLASS (decl) != BUILT_IN_NORMAL\n+\t      || !builtin_decl_implicit (DECL_FUNCTION_CODE (decl))\n+\t      || !gimple_builtin_call_types_compatible_p (stmt, decl))\n+\t    return false;\n+\n \t  tree type = TREE_TYPE (gimple_call_lhs (stmt));\n+\t  *rcode = DECL_FUNCTION_CODE (decl);\n+\t  for (unsigned i = 0; i < gimple_call_num_args (stmt); ++i)\n+\t    {\n+\t      tree arg = gimple_call_arg (stmt, i);\n+\t      ops[i] = do_valueize (arg, top_valueize, valueized);\n+\t    }\n \t  switch (gimple_call_num_args (stmt))\n \t    {\n \t    case 1:\n-\t      {\n-\t\ttree arg1 = gimple_call_arg (stmt, 0);\n-\t\tif (top_valueize && TREE_CODE (arg1) == SSA_NAME)\n-\t\t  {\n-\t\t    tree tem = top_valueize (arg1);\n-\t\t    if (tem)\n-\t\t      arg1 = tem;\n-\t\t  }\n-\t\t*rcode = DECL_FUNCTION_CODE (decl);\n-\t\tops[0] = arg1;\n-\t\treturn gimple_resimplify1 (seq, rcode, type, ops, valueize);\n-\t      }\n+\t      return (gimple_resimplify1 (seq, rcode, type, ops, valueize)\n+\t\t      || valueized);\n \t    case 2:\n-\t      {\n-\t\ttree arg1 = gimple_call_arg (stmt, 0);\n-\t\tif (top_valueize && TREE_CODE (arg1) == SSA_NAME)\n-\t\t  {\n-\t\t    tree tem = top_valueize (arg1);\n-\t\t    if (tem)\n-\t\t      arg1 = tem;\n-\t\t  }\n-\t\ttree arg2 = gimple_call_arg (stmt, 1);\n-\t\tif (top_valueize && TREE_CODE (arg2) == SSA_NAME)\n-\t\t  {\n-\t\t    tree tem = top_valueize (arg2);\n-\t\t    if (tem)\n-\t\t      arg2 = tem;\n-\t\t  }\n-\t\t*rcode = DECL_FUNCTION_CODE (decl);\n-\t\tops[0] = arg1;\n-\t\tops[1] = arg2;\n-\t\treturn gimple_resimplify2 (seq, rcode, type, ops, valueize);\n-\t      }\n+\t      return (gimple_resimplify2 (seq, rcode, type, ops, valueize)\n+\t\t      || valueized);\n \t    case 3:\n-\t      {\n-\t\ttree arg1 = gimple_call_arg (stmt, 0);\n-\t\tif (top_valueize && TREE_CODE (arg1) == SSA_NAME)\n-\t\t  {\n-\t\t    tree tem = top_valueize (arg1);\n-\t\t    if (tem)\n-\t\t      arg1 = tem;\n-\t\t  }\n-\t\ttree arg2 = gimple_call_arg (stmt, 1);\n-\t\tif (top_valueize && TREE_CODE (arg2) == SSA_NAME)\n-\t\t  {\n-\t\t    tree tem = top_valueize (arg2);\n-\t\t    if (tem)\n-\t\t      arg2 = tem;\n-\t\t  }\n-\t\ttree arg3 = gimple_call_arg (stmt, 2);\n-\t\tif (top_valueize && TREE_CODE (arg3) == SSA_NAME)\n-\t\t  {\n-\t\t    tree tem = top_valueize (arg3);\n-\t\t    if (tem)\n-\t\t      arg3 = tem;\n-\t\t  }\n-\t\t*rcode = DECL_FUNCTION_CODE (decl);\n-\t\tops[0] = arg1;\n-\t\tops[1] = arg2;\n-\t\tops[2] = arg3;\n-\t\treturn gimple_resimplify3 (seq, rcode, type, ops, valueize);\n-\t      }\n+\t      return (gimple_resimplify3 (seq, rcode, type, ops, valueize)\n+\t\t      || valueized);\n \t    default:\n-\t      return false;\n+\t     gcc_unreachable ();\n \t    }\n \t}\n       break;\n \n     case GIMPLE_COND:\n       {\n \ttree lhs = gimple_cond_lhs (stmt);\n-\tif (top_valueize && TREE_CODE (lhs) == SSA_NAME)\n-\t  {\n-\t    tree tem = top_valueize (lhs);\n-\t    if (tem)\n-\t      lhs = tem;\n-\t  }\n \ttree rhs = gimple_cond_rhs (stmt);\n-\tif (top_valueize && TREE_CODE (rhs) == SSA_NAME)\n-\t  {\n-\t    tree tem = top_valueize (rhs);\n-\t    if (tem)\n-\t      rhs = tem;\n-\t  }\n+\tbool valueized = false;\n+\tlhs = do_valueize (lhs, top_valueize, valueized);\n+\trhs = do_valueize (rhs, top_valueize, valueized);\n \t*rcode = gimple_cond_code (stmt);\n \tops[0] = lhs;\n \tops[1] = rhs;\n-        return gimple_resimplify2 (seq, rcode, boolean_type_node, ops, valueize);\n+        return (gimple_resimplify2 (seq, rcode,\n+\t\t\t\t    boolean_type_node, ops, valueize)\n+\t\t|| valueized);\n       }\n \n     default:"}]}