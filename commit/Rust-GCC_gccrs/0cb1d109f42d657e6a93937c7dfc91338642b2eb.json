{"sha": "0cb1d109f42d657e6a93937c7dfc91338642b2eb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGNiMWQxMDlmNDJkNjU3ZTZhOTM5MzdjN2RmYzkxMzM4NjQyYjJlYg==", "commit": {"author": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1996-10-17T15:33:52Z"}, "committer": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1996-10-17T15:33:52Z"}, "message": "expr.c (do_jump): Conditionalize cleanups for the COND_EXPR case...\n\n\t* expr.c (do_jump): Conditionalize cleanups for the COND_EXPR case,\n \tsimilarly to the way TRUTH_ANDIF_EXPR and TRUTH_ORIF_EXPR are\n \thandled.\n\nFrom-SVN: r12974", "tree": {"sha": "fed8f88856226256a0dc968320870a494a8bf22c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fed8f88856226256a0dc968320870a494a8bf22c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0cb1d109f42d657e6a93937c7dfc91338642b2eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0cb1d109f42d657e6a93937c7dfc91338642b2eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0cb1d109f42d657e6a93937c7dfc91338642b2eb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0cb1d109f42d657e6a93937c7dfc91338642b2eb/comments", "author": null, "committer": null, "parents": [{"sha": "74d1fb5aa1436f58794932ff3203990a36dfa7b5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74d1fb5aa1436f58794932ff3203990a36dfa7b5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/74d1fb5aa1436f58794932ff3203990a36dfa7b5"}], "stats": {"total": 70, "additions": 70, "deletions": 0}, "files": [{"sha": "0cee6f780570657a61e29f42ce560b627268d167", "filename": "gcc/expr.c", "status": "modified", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cb1d109f42d657e6a93937c7dfc91338642b2eb/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cb1d109f42d657e6a93937c7dfc91338642b2eb/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=0cb1d109f42d657e6a93937c7dfc91338642b2eb", "patch": "@@ -10178,20 +10178,90 @@ do_jump (exp, if_false_label, if_true_label)\n \n       else\n \t{\n+\t  rtx seq1, seq2;\n+\t  tree cleanups_left_side, cleanups_right_side, old_cleanups;\n+\n \t  register rtx label1 = gen_label_rtx ();\n \t  drop_through_label = gen_label_rtx ();\n+\n \t  do_jump (TREE_OPERAND (exp, 0), label1, NULL_RTX);\n+\n+\t  /* We need to save the cleanups for the lhs and rhs separately. \n+\t     Keep track of the cleanups seen before the lhs. */\n+\t  old_cleanups = cleanups_this_call;\n+\t  start_sequence ();\n \t  /* Now the THEN-expression.  */\n \t  do_jump (TREE_OPERAND (exp, 1),\n \t\t   if_false_label ? if_false_label : drop_through_label,\n \t\t   if_true_label ? if_true_label : drop_through_label);\n \t  /* In case the do_jump just above never jumps.  */\n \t  do_pending_stack_adjust ();\n \t  emit_label (label1);\n+\t  seq1 = get_insns ();\n+\t  /* Now grab the cleanups for the lhs. */\n+\t  cleanups_left_side = defer_cleanups_to (old_cleanups);\n+\t  end_sequence ();\n+\n+\t  /* And keep track of where we start before the rhs. */\n+\t  old_cleanups = cleanups_this_call;\n+\t  start_sequence ();\n \t  /* Now the ELSE-expression.  */\n \t  do_jump (TREE_OPERAND (exp, 2),\n \t\t   if_false_label ? if_false_label : drop_through_label,\n \t\t   if_true_label ? if_true_label : drop_through_label);\n+\t  seq2 = get_insns ();\n+\t  /* Grab the cleanups for the rhs. */\n+\t  cleanups_right_side = defer_cleanups_to (old_cleanups);\n+\t  end_sequence ();\n+\n+\t  if (cleanups_left_side || cleanups_right_side)\n+\t    {\n+\t      /* Make the cleanups for the THEN and ELSE clauses\n+\t\t conditional based on which half is executed. */\n+\t      rtx flag = gen_reg_rtx (word_mode);\n+\t      tree new_cleanups;\n+\t      tree cond;\n+\n+\t      /* Set the flag to 0 so that we know we executed the lhs. */\n+\t      emit_move_insn (flag, const0_rtx);\n+\t      emit_insns (seq1);\n+\n+\t      /* Set the flag to 1 so that we know we executed the rhs. */\n+\t      emit_move_insn (flag, const1_rtx);\n+\t      emit_insns (seq2);\n+\n+\t      /* Make sure the cleanup lives on the function_obstack. */\n+\t      push_obstacks_nochange ();\n+\t      resume_temporary_allocation ();\n+\n+\t      /* Now, build up a COND_EXPR that tests the value of the\n+\t\t flag, and then either do the cleanups for the lhs or the\n+\t\t rhs. */\n+\t      cond = make_node (RTL_EXPR);\n+\t      TREE_TYPE (cond) = integer_type_node;\n+\t      RTL_EXPR_RTL (cond) = flag;\n+\t      RTL_EXPR_SEQUENCE (cond) = NULL_RTX;\n+\t      cond = save_expr (cond);\n+\t      \n+\t      new_cleanups = build (COND_EXPR, void_type_node,\n+\t\t\t\t    truthvalue_conversion (cond),\n+\t\t\t\t    cleanups_right_side, cleanups_left_side);\n+\t      new_cleanups = fold (new_cleanups);\n+\n+\t      pop_obstacks ();\n+\n+\t      /* Now add in the conditionalized cleanups.  */\n+\t      cleanups_this_call\n+\t\t= tree_cons (NULL_TREE, new_cleanups, cleanups_this_call);\n+\t      expand_eh_region_start ();\n+\t    }\n+\t  else \n+\t    {\n+\t      /* No cleanups were needed, so emit the two sequences\n+\t\t directly. */\n+\t      emit_insns (seq1);\n+\t      emit_insns (seq2);\n+\t    }\n \t}\n       break;\n "}]}