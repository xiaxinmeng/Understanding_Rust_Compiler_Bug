{"sha": "62acc72a957b561462a436fcb2d6caac5b363190", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjJhY2M3MmE5NTdiNTYxNDYyYTQzNmZjYjJkNmNhYWM1YjM2MzE5MA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2021-07-21T06:50:20Z"}, "committer": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2021-07-21T06:50:20Z"}, "message": "unroll: Avoid unnecessary tail loops for constant niters\n\nunroll and jam can decide to unroll the outer loop of a nest like:\n\n  for (int j = 0; j < n; ++j)\n    for (int i = 0; i < n; ++i)\n      x[i] += __builtin_expf (y[j][i]);\n\nIt then uses a tail loop to handle any left-over iterations.\n\nHowever, the code is structured so that this tail loop is always used.\nIf n is a multiple of the unroll factor UF, the final UF iterations will\nuse the tail loop rather than the unrolled loop.\n\n\u201cFixing\u201d that for variable loop counts would mean introducing another\nruntime test: a branch around the tail loop if there are no more\niterations.  There's at least an argument that the overhead of doing\nthat test might not pay for itself.\n\nBut we use this structure even if the iteration count is provably\na multiple of UF at compile time.  E.g. with s/n/100/ and an\nunroll factor of 2, the first 98 iterations use the unrolled loop\nand the final 2 iterations use the original loop.\n\nThis patch makes the unroller avoid a tail loop in that case.\nThe end result seemed easier to follow if variables were declared\nat the point of initialisation, so that it's more obvious which\nones are meaningful even when there's no tail loop.\n\ngcc/\n\t* tree-ssa-loop-manip.c (determine_exit_conditions): Return a null\n\texit condition if no tail loop is needed, and if the original exit\n\tcondition should therefore be kept as-is.\n\t(tree_transform_and_unroll_loop): Handle that case here too.\n\ngcc/testsuite/\n\t* gcc.dg/unroll-9.c: New test/", "tree": {"sha": "071989b049849ee479de44719db3ecc36276eff0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/071989b049849ee479de44719db3ecc36276eff0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/62acc72a957b561462a436fcb2d6caac5b363190", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62acc72a957b561462a436fcb2d6caac5b363190", "html_url": "https://github.com/Rust-GCC/gccrs/commit/62acc72a957b561462a436fcb2d6caac5b363190", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62acc72a957b561462a436fcb2d6caac5b363190/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2d9588bac5ac9e2ed778f3c7eae9ebf7bf258b44", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d9588bac5ac9e2ed778f3c7eae9ebf7bf258b44", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2d9588bac5ac9e2ed778f3c7eae9ebf7bf258b44"}], "stats": {"total": 318, "additions": 176, "deletions": 142}, "files": [{"sha": "2d65ec3691dae215552025cfc02a965d013a8572", "filename": "gcc/testsuite/gcc.dg/unroll-9.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62acc72a957b561462a436fcb2d6caac5b363190/gcc%2Ftestsuite%2Fgcc.dg%2Funroll-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62acc72a957b561462a436fcb2d6caac5b363190/gcc%2Ftestsuite%2Fgcc.dg%2Funroll-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Funroll-9.c?ref=62acc72a957b561462a436fcb2d6caac5b363190", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-options \"-O3 -fdump-tree-unrolljam -fno-math-errno\" } */\n+\n+void\n+f (float *restrict x, float y[100][100])\n+{\n+  for (int j = 0; j < 100; ++j)\n+    for (int i = 0; i < 100; ++i)\n+      x[i] += __builtin_expf (y[j][i]);\n+}\n+\n+/* The loop should be unrolled 2 times, without a tail loop.  */\n+/* { dg-final { scan-tree-dump-times \"__builtin_expf\" 2 \"unrolljam\" } } */"}, {"sha": "41f9872ca108222059ae126d392de67aafb4d031", "filename": "gcc/tree-ssa-loop-manip.c", "status": "modified", "additions": 164, "deletions": 142, "changes": 306, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62acc72a957b561462a436fcb2d6caac5b363190/gcc%2Ftree-ssa-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62acc72a957b561462a436fcb2d6caac5b363190/gcc%2Ftree-ssa-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-manip.c?ref=62acc72a957b561462a436fcb2d6caac5b363190", "patch": "@@ -997,8 +997,10 @@ can_unroll_loop_p (class loop *loop, unsigned factor,\n /* Determines the conditions that control execution of LOOP unrolled FACTOR\n    times.  DESC is number of iterations of LOOP.  ENTER_COND is set to\n    condition that must be true if the main loop can be entered.\n+   If the loop does not always iterate an exact multiple of FACTOR times,\n    EXIT_BASE, EXIT_STEP, EXIT_CMP and EXIT_BOUND are set to values describing\n-   how the exit from the unrolled loop should be controlled.  */\n+   how the exit from the unrolled loop should be controlled.  Otherwise,\n+   the trees are set to null and EXIT_CMP is set to ERROR_MARK.  */\n \n static void\n determine_exit_conditions (class loop *loop, class tree_niter_desc *desc,\n@@ -1079,6 +1081,16 @@ determine_exit_conditions (class loop *loop, class tree_niter_desc *desc,\n   assum = fold_build2 (cmp, boolean_type_node, base, bound);\n   cond = fold_build2 (TRUTH_AND_EXPR, boolean_type_node, assum, cond);\n \n+  if (integer_nonzerop (cond)\n+      && integer_zerop (desc->may_be_zero))\n+    {\n+      /* Convert the latch count to an iteration count.  */\n+      tree niter = fold_build2 (PLUS_EXPR, type, desc->niter,\n+\t\t\t\tbuild_one_cst (type));\n+      if (multiple_of_p (type, niter, bigstep))\n+\treturn;\n+    }\n+\n   cond = force_gimple_operand (unshare_expr (cond), &stmts, false, NULL_TREE);\n   if (stmts)\n     gsi_insert_seq_on_edge_immediate (loop_preheader_edge (loop), stmts);\n@@ -1234,137 +1246,138 @@ tree_transform_and_unroll_loop (class loop *loop, unsigned factor,\n \t\t\t\ttransform_callback transform,\n \t\t\t\tvoid *data)\n {\n-  gcond *exit_if;\n-  tree ctr_before, ctr_after;\n-  tree enter_main_cond, exit_base, exit_step, exit_bound;\n-  enum tree_code exit_cmp;\n-  gphi *phi_old_loop, *phi_new_loop, *phi_rest;\n-  gphi_iterator psi_old_loop, psi_new_loop;\n-  tree init, next, new_init;\n-  class loop *new_loop;\n-  basic_block rest, exit_bb;\n-  edge old_entry, new_entry, old_latch, precond_edge, new_exit;\n-  edge new_nonexit, e;\n-  gimple_stmt_iterator bsi;\n-  use_operand_p op;\n-  bool ok;\n-  unsigned i;\n-  profile_probability prob, prob_entry, scale_unrolled;\n-  profile_count freq_e, freq_h;\n   gcov_type new_est_niter = niter_for_unrolled_loop (loop, factor);\n   unsigned irr = loop_preheader_edge (loop)->flags & EDGE_IRREDUCIBLE_LOOP;\n-  auto_vec<edge> to_remove;\n \n+  enum tree_code exit_cmp;\n+  tree enter_main_cond, exit_base, exit_step, exit_bound;\n   determine_exit_conditions (loop, desc, factor,\n \t\t\t     &enter_main_cond, &exit_base, &exit_step,\n \t\t\t     &exit_cmp, &exit_bound);\n+  bool single_loop_p = !exit_base;\n \n   /* Let us assume that the unrolled loop is quite likely to be entered.  */\n+  profile_probability prob_entry;\n   if (integer_nonzerop (enter_main_cond))\n     prob_entry = profile_probability::always ();\n   else\n     prob_entry = profile_probability::guessed_always ()\n \t\t\t.apply_scale (PROB_UNROLLED_LOOP_ENTERED, 100);\n \n-  /* The values for scales should keep profile consistent, and somewhat close\n-     to correct.\n-\n-     TODO: The current value of SCALE_REST makes it appear that the loop that\n-     is created by splitting the remaining iterations of the unrolled loop is\n-     executed the same number of times as the original loop, and with the same\n-     frequencies, which is obviously wrong.  This does not appear to cause\n-     problems, so we do not bother with fixing it for now.  To make the profile\n-     correct, we would need to change the probability of the exit edge of the\n-     loop, and recompute the distribution of frequencies in its body because\n-     of this change (scale the frequencies of blocks before and after the exit\n-     by appropriate factors).  */\n-  scale_unrolled = prob_entry;\n-\n-  new_loop = loop_version (loop, enter_main_cond, NULL, prob_entry,\n-\t\t\t   prob_entry.invert (), scale_unrolled,\n-\t\t\t   profile_probability::guessed_always (),\n-\t\t\t   true);\n-  gcc_assert (new_loop != NULL);\n-  update_ssa (TODO_update_ssa);\n-\n-  /* Prepare the cfg and update the phi nodes.  Move the loop exit to the\n-     loop latch (and make its condition dummy, for the moment).  */\n-  rest = loop_preheader_edge (new_loop)->src;\n-  precond_edge = single_pred_edge (rest);\n-  split_edge (loop_latch_edge (loop));\n-  exit_bb = single_pred (loop->latch);\n-\n-  /* Since the exit edge will be removed, the frequency of all the blocks\n-     in the loop that are dominated by it must be scaled by\n-     1 / (1 - exit->probability).  */\n-  if (exit->probability.initialized_p ())\n-    scale_dominated_blocks_in_loop (loop, exit->src,\n-\t\t\t\t    /* We are scaling up here so probability\n-\t\t\t\t       does not fit.  */\n-\t\t\t\t    loop->header->count,\n-\t\t\t\t    loop->header->count\n-\t\t\t\t    - loop->header->count.apply_probability\n-\t\t\t\t\t (exit->probability));\n-\n-  bsi = gsi_last_bb (exit_bb);\n-  exit_if = gimple_build_cond (EQ_EXPR, integer_zero_node,\n-\t\t\t       integer_zero_node,\n-\t\t\t       NULL_TREE, NULL_TREE);\n-\n-  gsi_insert_after (&bsi, exit_if, GSI_NEW_STMT);\n-  new_exit = make_edge (exit_bb, rest, EDGE_FALSE_VALUE | irr);\n-  rescan_loop_exit (new_exit, true, false);\n-\n-  /* Set the probability of new exit to the same of the old one.  Fix\n-     the frequency of the latch block, by scaling it back by\n-     1 - exit->probability.  */\n-  new_exit->probability = exit->probability;\n-  new_nonexit = single_pred_edge (loop->latch);\n-  new_nonexit->probability = exit->probability.invert ();\n-  new_nonexit->flags = EDGE_TRUE_VALUE;\n-  if (new_nonexit->probability.initialized_p ())\n-    scale_bbs_frequencies (&loop->latch, 1, new_nonexit->probability);\n-\n-  old_entry = loop_preheader_edge (loop);\n-  new_entry = loop_preheader_edge (new_loop);\n-  old_latch = loop_latch_edge (loop);\n-  for (psi_old_loop = gsi_start_phis (loop->header),\n-       psi_new_loop = gsi_start_phis (new_loop->header);\n-       !gsi_end_p (psi_old_loop);\n-       gsi_next (&psi_old_loop), gsi_next (&psi_new_loop))\n+  gcond *exit_if = nullptr;\n+  class loop *new_loop = nullptr;\n+  basic_block rest;\n+  edge new_exit;\n+  if (!single_loop_p)\n     {\n-      phi_old_loop = psi_old_loop.phi ();\n-      phi_new_loop = psi_new_loop.phi ();\n-\n-      init = PHI_ARG_DEF_FROM_EDGE (phi_old_loop, old_entry);\n-      op = PHI_ARG_DEF_PTR_FROM_EDGE (phi_new_loop, new_entry);\n-      gcc_assert (operand_equal_for_phi_arg_p (init, USE_FROM_PTR (op)));\n-      next = PHI_ARG_DEF_FROM_EDGE (phi_old_loop, old_latch);\n-\n-      /* Prefer using original variable as a base for the new ssa name.\n-\t This is necessary for virtual ops, and useful in order to avoid\n-\t losing debug info for real ops.  */\n-      if (TREE_CODE (next) == SSA_NAME\n-\t  && useless_type_conversion_p (TREE_TYPE (next),\n-\t\t\t\t\tTREE_TYPE (init)))\n-\tnew_init = copy_ssa_name (next);\n-      else if (TREE_CODE (init) == SSA_NAME\n-\t       && useless_type_conversion_p (TREE_TYPE (init),\n-\t\t\t\t\t     TREE_TYPE (next)))\n-\tnew_init = copy_ssa_name (init);\n-      else if (useless_type_conversion_p (TREE_TYPE (next), TREE_TYPE (init)))\n-\tnew_init = make_temp_ssa_name (TREE_TYPE (next), NULL, \"unrinittmp\");\n-      else\n-\tnew_init = make_temp_ssa_name (TREE_TYPE (init), NULL, \"unrinittmp\");\n+      /* The values for scales should keep profile consistent, and somewhat\n+\t close to correct.\n+\n+\t TODO: The current value of SCALE_REST makes it appear that the loop\n+\t that is created by splitting the remaining iterations of the unrolled\n+\t loop is executed the same number of times as the original loop, and\n+\t with the same frequencies, which is obviously wrong.  This does not\n+\t appear to cause problems, so we do not bother with fixing it for now.\n+\t To make the profile correct, we would need to change the probability\n+\t of the exit edge of the loop, and recompute the distribution of\n+\t frequencies in its body because of this change (scale the frequencies\n+\t of blocks before and after the exit by appropriate factors).  */\n+      profile_probability scale_unrolled = prob_entry;\n+      new_loop = loop_version (loop, enter_main_cond, NULL, prob_entry,\n+\t\t\t       prob_entry.invert (), scale_unrolled,\n+\t\t\t       profile_probability::guessed_always (),\n+\t\t\t       true);\n+      gcc_assert (new_loop != NULL);\n+      update_ssa (TODO_update_ssa);\n+\n+      /* Prepare the cfg and update the phi nodes.  Move the loop exit to the\n+\t loop latch (and make its condition dummy, for the moment).  */\n+      rest = loop_preheader_edge (new_loop)->src;\n+      edge precond_edge = single_pred_edge (rest);\n+      split_edge (loop_latch_edge (loop));\n+      basic_block exit_bb = single_pred (loop->latch);\n+\n+      /* Since the exit edge will be removed, the frequency of all the blocks\n+\t in the loop that are dominated by it must be scaled by\n+\t 1 / (1 - exit->probability).  */\n+      if (exit->probability.initialized_p ())\n+\tscale_dominated_blocks_in_loop (loop, exit->src,\n+\t\t\t\t\t/* We are scaling up here so\n+\t\t\t\t\t   probability does not fit.  */\n+\t\t\t\t\tloop->header->count,\n+\t\t\t\t\tloop->header->count\n+\t\t\t\t\t- loop->header->count.apply_probability\n+\t\t\t\t\t    (exit->probability));\n+\n+      gimple_stmt_iterator bsi = gsi_last_bb (exit_bb);\n+      exit_if = gimple_build_cond (EQ_EXPR, integer_zero_node,\n+\t\t\t\t   integer_zero_node,\n+\t\t\t\t   NULL_TREE, NULL_TREE);\n+\n+      gsi_insert_after (&bsi, exit_if, GSI_NEW_STMT);\n+      new_exit = make_edge (exit_bb, rest, EDGE_FALSE_VALUE | irr);\n+      rescan_loop_exit (new_exit, true, false);\n+\n+      /* Set the probability of new exit to the same of the old one.  Fix\n+\t the frequency of the latch block, by scaling it back by\n+\t 1 - exit->probability.  */\n+      new_exit->probability = exit->probability;\n+      edge new_nonexit = single_pred_edge (loop->latch);\n+      new_nonexit->probability = exit->probability.invert ();\n+      new_nonexit->flags = EDGE_TRUE_VALUE;\n+      if (new_nonexit->probability.initialized_p ())\n+\tscale_bbs_frequencies (&loop->latch, 1, new_nonexit->probability);\n+\n+      edge old_entry = loop_preheader_edge (loop);\n+      edge new_entry = loop_preheader_edge (new_loop);\n+      edge old_latch = loop_latch_edge (loop);\n+      for (gphi_iterator psi_old_loop = gsi_start_phis (loop->header),\n+\t     psi_new_loop = gsi_start_phis (new_loop->header);\n+\t   !gsi_end_p (psi_old_loop);\n+\t   gsi_next (&psi_old_loop), gsi_next (&psi_new_loop))\n+\t{\n+\t  gphi *phi_old_loop = psi_old_loop.phi ();\n+\t  gphi *phi_new_loop = psi_new_loop.phi ();\n+\n+\t  tree init = PHI_ARG_DEF_FROM_EDGE (phi_old_loop, old_entry);\n+\t  use_operand_p op\n+\t    = PHI_ARG_DEF_PTR_FROM_EDGE (phi_new_loop, new_entry);\n+\t  gcc_assert (operand_equal_for_phi_arg_p (init, USE_FROM_PTR (op)));\n+\t  tree next = PHI_ARG_DEF_FROM_EDGE (phi_old_loop, old_latch);\n+\n+\t  /* Prefer using original variable as a base for the new ssa name.\n+\t     This is necessary for virtual ops, and useful in order to avoid\n+\t     losing debug info for real ops.  */\n+\t  tree new_init;\n+\t  if (TREE_CODE (next) == SSA_NAME\n+\t      && useless_type_conversion_p (TREE_TYPE (next),\n+\t\t\t\t\t    TREE_TYPE (init)))\n+\t    new_init = copy_ssa_name (next);\n+\t  else if (TREE_CODE (init) == SSA_NAME\n+\t\t   && useless_type_conversion_p (TREE_TYPE (init),\n+\t\t\t\t\t\t TREE_TYPE (next)))\n+\t    new_init = copy_ssa_name (init);\n+\t  else if (useless_type_conversion_p (TREE_TYPE (next),\n+\t\t\t\t\t      TREE_TYPE (init)))\n+\t    new_init = make_temp_ssa_name (TREE_TYPE (next), NULL,\n+\t\t\t\t\t   \"unrinittmp\");\n+\t  else\n+\t    new_init = make_temp_ssa_name (TREE_TYPE (init), NULL,\n+\t\t\t\t\t   \"unrinittmp\");\n \n-      phi_rest = create_phi_node (new_init, rest);\n+\t  gphi *phi_rest = create_phi_node (new_init, rest);\n+\t  add_phi_arg (phi_rest, init, precond_edge, UNKNOWN_LOCATION);\n+\t  add_phi_arg (phi_rest, next, new_exit, UNKNOWN_LOCATION);\n+\t  SET_USE (op, new_init);\n+\t}\n \n-      add_phi_arg (phi_rest, init, precond_edge, UNKNOWN_LOCATION);\n-      add_phi_arg (phi_rest, next, new_exit, UNKNOWN_LOCATION);\n-      SET_USE (op, new_init);\n+      remove_path (exit);\n+    }\n+  else\n+    {\n+      new_exit = exit;\n+      rest = exit->dest;\n     }\n-\n-  remove_path (exit);\n \n   /* Transform the loop.  */\n   if (transform)\n@@ -1376,57 +1389,66 @@ tree_transform_and_unroll_loop (class loop *loop, unsigned factor,\n   bitmap_ones (wont_exit);\n   bitmap_clear_bit (wont_exit, factor - 1);\n \n-  ok = gimple_duplicate_loop_to_header_edge\n+  auto_vec<edge> to_remove;\n+  bool ok = gimple_duplicate_loop_to_header_edge\n \t  (loop, loop_latch_edge (loop), factor - 1,\n \t   wont_exit, new_exit, &to_remove, DLTHE_FLAG_UPDATE_FREQ);\n   gcc_assert (ok);\n \n-  FOR_EACH_VEC_ELT (to_remove, i, e)\n+  for (edge e : to_remove)\n     {\n       ok = remove_path (e);\n       gcc_assert (ok);\n     }\n   update_ssa (TODO_update_ssa);\n \n-  /* Ensure that the frequencies in the loop match the new estimated\n-     number of iterations, and change the probability of the new\n-     exit edge.  */\n-\n-  freq_h = loop->header->count;\n-  freq_e = (loop_preheader_edge (loop))->count ();\n-  if (freq_h.nonzero_p ())\n+  if (!single_loop_p)\n     {\n-      /* Avoid dropping loop body profile counter to 0 because of zero count\n-\t in loop's preheader.  */\n-      if (freq_h.nonzero_p () && !(freq_e == profile_count::zero ()))\n-        freq_e = freq_e.force_nonzero ();\n-      scale_loop_frequencies (loop, freq_e.probability_in (freq_h));\n+      /* Ensure that the frequencies in the loop match the new estimated\n+\t number of iterations, and change the probability of the new\n+\t exit edge.  */\n+\n+      profile_count freq_h = loop->header->count;\n+      profile_count freq_e = (loop_preheader_edge (loop))->count ();\n+      if (freq_h.nonzero_p ())\n+\t{\n+\t  /* Avoid dropping loop body profile counter to 0 because of zero\n+\t     count in loop's preheader.  */\n+\t  if (freq_h.nonzero_p () && !(freq_e == profile_count::zero ()))\n+\t    freq_e = freq_e.force_nonzero ();\n+\t  scale_loop_frequencies (loop, freq_e.probability_in (freq_h));\n+\t}\n     }\n \n-  exit_bb = single_pred (loop->latch);\n+  basic_block exit_bb = single_pred (loop->latch);\n   new_exit = find_edge (exit_bb, rest);\n   new_exit->probability = profile_probability::always ()\n \t\t\t\t.apply_scale (1, new_est_niter + 1);\n \n-  rest->count += new_exit->count ();\n+  if (!single_loop_p)\n+    rest->count += new_exit->count ();\n \n-  new_nonexit = single_pred_edge (loop->latch);\n-  prob = new_nonexit->probability;\n+  edge new_nonexit = single_pred_edge (loop->latch);\n+  profile_probability prob = new_nonexit->probability;\n   new_nonexit->probability = new_exit->probability.invert ();\n   prob = new_nonexit->probability / prob;\n   if (prob.initialized_p ())\n     scale_bbs_frequencies (&loop->latch, 1, prob);\n \n-  /* Finally create the new counter for number of iterations and add the new\n-     exit instruction.  */\n-  bsi = gsi_last_nondebug_bb (exit_bb);\n-  exit_if = as_a <gcond *> (gsi_stmt (bsi));\n-  create_iv (exit_base, exit_step, NULL_TREE, loop,\n-\t     &bsi, false, &ctr_before, &ctr_after);\n-  gimple_cond_set_code (exit_if, exit_cmp);\n-  gimple_cond_set_lhs (exit_if, ctr_after);\n-  gimple_cond_set_rhs (exit_if, exit_bound);\n-  update_stmt (exit_if);\n+  if (!single_loop_p)\n+    {\n+      /* Finally create the new counter for number of iterations and add\n+\t the new exit instruction.  */\n+      tree ctr_before, ctr_after;\n+      gimple_stmt_iterator bsi = gsi_last_nondebug_bb (exit_bb);\n+      exit_if = as_a <gcond *> (gsi_stmt (bsi));\n+      create_iv (exit_base, exit_step, NULL_TREE, loop,\n+\t\t &bsi, false, &ctr_before, &ctr_after);\n+      gimple_cond_set_code (exit_if, exit_cmp);\n+      gimple_cond_set_lhs (exit_if, ctr_after);\n+      gimple_cond_set_rhs (exit_if, exit_bound);\n+      update_stmt (exit_if);\n+    }\n \n   checking_verify_flow_info ();\n   checking_verify_loop_structure ();"}]}