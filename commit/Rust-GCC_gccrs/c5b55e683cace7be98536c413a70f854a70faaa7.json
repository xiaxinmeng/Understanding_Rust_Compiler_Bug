{"sha": "c5b55e683cace7be98536c413a70f854a70faaa7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzViNTVlNjgzY2FjZTdiZTk4NTM2YzQxM2E3MGY4NTRhNzBmYWFhNw==", "commit": {"author": {"name": "Piotr Trojanek", "email": "trojanek@adacore.com", "date": "2020-03-17T13:16:28Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-06-11T09:53:44Z"}, "message": "[Ada] Move duplicated routines for building itypes to Sem_Util\n\n2020-06-11  Piotr Trojanek  <trojanek@adacore.com>\n\ngcc/ada/\n\n\t* sem_aggr.adb (Build_Constrained_Itype): Move to Sem_Util.\n\t* sem_ch3.adb (Build_Subtype, Inherit_Predicate_Flags): Move...\n\t* sem_util.adb (Build_Subtype): Here.  Add parameters for\n\treferences to objects previously declared in enclosing scopes.\n\t(Inherit_Predicate_Flags): And here, because it is called by\n\tBuild_Subtype.\n\t* sem_util.ads (Build_Overriding_Spec): Reorder alphabetically.\n\t(Build_Subtype): Moved from Sem_Ch3; comments updated.\n\t(Build_Constrained_Itype): Moved from Sem_Aggr; comments\n\tupdated.", "tree": {"sha": "cf0c02c04ef34d4f11d43489c9e7bc57f6f26afc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cf0c02c04ef34d4f11d43489c9e7bc57f6f26afc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c5b55e683cace7be98536c413a70f854a70faaa7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5b55e683cace7be98536c413a70f854a70faaa7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c5b55e683cace7be98536c413a70f854a70faaa7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5b55e683cace7be98536c413a70f854a70faaa7/comments", "author": {"login": "ptroja", "id": 161602, "node_id": "MDQ6VXNlcjE2MTYwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/161602?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ptroja", "html_url": "https://github.com/ptroja", "followers_url": "https://api.github.com/users/ptroja/followers", "following_url": "https://api.github.com/users/ptroja/following{/other_user}", "gists_url": "https://api.github.com/users/ptroja/gists{/gist_id}", "starred_url": "https://api.github.com/users/ptroja/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ptroja/subscriptions", "organizations_url": "https://api.github.com/users/ptroja/orgs", "repos_url": "https://api.github.com/users/ptroja/repos", "events_url": "https://api.github.com/users/ptroja/events{/privacy}", "received_events_url": "https://api.github.com/users/ptroja/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "38f44fd6af098d4d09bcf91039b4ce989b0d0791", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38f44fd6af098d4d09bcf91039b4ce989b0d0791", "html_url": "https://github.com/Rust-GCC/gccrs/commit/38f44fd6af098d4d09bcf91039b4ce989b0d0791"}], "stats": {"total": 444, "additions": 231, "deletions": 213}, "files": [{"sha": "b80810dffad1d20506b2251e384e19c31c87e557", "filename": "gcc/ada/sem_aggr.adb", "status": "modified", "additions": 0, "deletions": 95, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b55e683cace7be98536c413a70f854a70faaa7/gcc%2Fada%2Fsem_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b55e683cace7be98536c413a70f854a70faaa7/gcc%2Fada%2Fsem_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aggr.adb?ref=c5b55e683cace7be98536c413a70f854a70faaa7", "patch": "@@ -3313,29 +3313,6 @@ package body Sem_Aggr is\n       --  part of the enclosing aggregate. Assoc_List provides the discriminant\n       --  associations of the current type or of some enclosing record.\n \n-      procedure Build_Constrained_Itype\n-        (N              : Node_Id;\n-         Typ            : Entity_Id;\n-         New_Assoc_List : List_Id);\n-      --  Build a constrained itype for the newly created record aggregate N\n-      --  and set it as a type of N. The itype will have Typ as its base type\n-      --  and will be constrained by the values of discriminants from the\n-      --  component association list New_Assoc_List.\n-\n-      --  ??? This code used to be pretty much a copy of Sem_Ch3.Build_Subtype,\n-      --  but now those two routines behave differently for types with unknown\n-      --  discriminants. They should really be exported in sem_util or some\n-      --  such and used in sem_ch3 and here rather than have a copy of the\n-      --  code which is a maintenance nightmare.\n-\n-      --  ??? Performance WARNING. The current implementation creates a new\n-      --  itype for all aggregates whose base type is discriminated. This means\n-      --  that for record aggregates nested inside an array aggregate we will\n-      --  create a new itype for each record aggregate if the array component\n-      --  type has discriminants. For large aggregates this may be a problem.\n-      --  What should be done in this case is to reuse itypes as much as\n-      --  possible.\n-\n       function Discriminant_Present (Input_Discr : Entity_Id) return Boolean;\n       --  If aggregate N is a regular aggregate this routine will return True.\n       --  Otherwise, if N is an extension aggregate, then Input_Discr denotes\n@@ -3495,78 +3472,6 @@ package body Sem_Aggr is\n          end loop;\n       end Add_Discriminant_Values;\n \n-      -----------------------------\n-      -- Build_Constrained_Itype --\n-      -----------------------------\n-\n-      procedure Build_Constrained_Itype\n-        (N              : Node_Id;\n-         Typ            : Entity_Id;\n-         New_Assoc_List : List_Id)\n-      is\n-         Constrs     : constant List_Id    := New_List;\n-         Loc         : constant Source_Ptr := Sloc (N);\n-         Def_Id      : Entity_Id;\n-         Indic       : Node_Id;\n-         New_Assoc   : Node_Id;\n-         Subtyp_Decl : Node_Id;\n-\n-      begin\n-         New_Assoc := First (New_Assoc_List);\n-         while Present (New_Assoc) loop\n-\n-            --  There is exactly one choice in the component association (and\n-            --  it is either a discriminant, a component or the others clause).\n-            pragma Assert (List_Length (Choices (New_Assoc)) = 1);\n-\n-            --  Duplicate expression for the discriminant and put it on the\n-            --  list of constraints for the itype declaration.\n-\n-            if Is_Entity_Name (First (Choices (New_Assoc)))\n-              and then\n-                Ekind (Entity (First (Choices (New_Assoc)))) = E_Discriminant\n-            then\n-               Append_To (Constrs, Duplicate_Subexpr (Expression (New_Assoc)));\n-            end if;\n-\n-            Next (New_Assoc);\n-         end loop;\n-\n-         if Has_Unknown_Discriminants (Typ)\n-           and then Present (Underlying_Record_View (Typ))\n-         then\n-            Indic :=\n-              Make_Subtype_Indication (Loc,\n-                Subtype_Mark =>\n-                  New_Occurrence_Of (Underlying_Record_View (Typ), Loc),\n-                Constraint   =>\n-                  Make_Index_Or_Discriminant_Constraint (Loc,\n-                    Constraints => Constrs));\n-         else\n-            Indic :=\n-              Make_Subtype_Indication (Loc,\n-                Subtype_Mark =>\n-                  New_Occurrence_Of (Base_Type (Typ), Loc),\n-                Constraint   =>\n-                  Make_Index_Or_Discriminant_Constraint (Loc,\n-                    Constraints => Constrs));\n-         end if;\n-\n-         Def_Id := Create_Itype (Ekind (Typ), N);\n-\n-         Subtyp_Decl :=\n-           Make_Subtype_Declaration (Loc,\n-             Defining_Identifier => Def_Id,\n-             Subtype_Indication  => Indic);\n-         Set_Parent (Subtyp_Decl, Parent (N));\n-\n-         --  Itypes must be analyzed with checks off (see itypes.ads)\n-\n-         Analyze (Subtyp_Decl, Suppress => All_Checks);\n-\n-         Set_Etype (N, Def_Id);\n-      end Build_Constrained_Itype;\n-\n       --------------------------\n       -- Discriminant_Present --\n       --------------------------"}, {"sha": "026bcefdba370daef166c1ea68edb0c4b79d8d4c", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 2, "deletions": 110, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b55e683cace7be98536c413a70f854a70faaa7/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b55e683cace7be98536c413a70f854a70faaa7/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=c5b55e683cace7be98536c413a70f854a70faaa7", "patch": "@@ -563,10 +563,6 @@ package body Sem_Ch3 is\n    --  copying the record declaration for the derived base. In the tagged case\n    --  the value returned is irrelevant.\n \n-   procedure Inherit_Predicate_Flags (Subt, Par : Entity_Id);\n-   --  Propagate static and dynamic predicate flags from a parent to the\n-   --  subtype in a subtype declaration with and without constraints.\n-\n    function Is_EVF_Procedure (Subp : Entity_Id) return Boolean;\n    --  Subsidiary to Check_Abstract_Overriding and Derive_Subprogram.\n    --  Determine whether subprogram Subp is a procedure subject to pragma\n@@ -13078,10 +13074,6 @@ package body Sem_Ch3 is\n       --  Ditto for access types. Makes use of previous two functions, to\n       --  constrain designated type.\n \n-      function Build_Subtype (T : Entity_Id; C : List_Id) return Entity_Id;\n-      --  T is an array or discriminated type, C is a list of constraints\n-      --  that apply to T. This routine builds the constrained subtype.\n-\n       function Is_Discriminant (Expr : Node_Id) return Boolean;\n       --  Returns True if Expr is a discriminant\n \n@@ -13229,7 +13221,7 @@ package body Sem_Ch3 is\n                Next_Index (Old_Index);\n             end loop;\n \n-            return Build_Subtype (Old_Type, Constr_List);\n+            return Build_Subtype (Related_Node, Loc, Old_Type, Constr_List);\n \n          else\n             return Old_Type;\n@@ -13294,81 +13286,13 @@ package body Sem_Ch3 is\n                Next_Elmt (Old_Constraint);\n             end loop;\n \n-            return Build_Subtype (Old_Type, Constr_List);\n+            return Build_Subtype (Related_Node, Loc, Old_Type, Constr_List);\n \n          else\n             return Old_Type;\n          end if;\n       end Build_Constrained_Discriminated_Type;\n \n-      -------------------\n-      -- Build_Subtype --\n-      -------------------\n-\n-      function Build_Subtype (T : Entity_Id; C : List_Id) return Entity_Id is\n-         Indic       : Node_Id;\n-         Subtyp_Decl : Node_Id;\n-         Def_Id      : Entity_Id;\n-         Btyp        : Entity_Id := Base_Type (T);\n-\n-      begin\n-         --  The Related_Node better be here or else we won't be able to\n-         --  attach new itypes to a node in the tree.\n-\n-         pragma Assert (Present (Related_Node));\n-\n-         --  If the view of the component's type is incomplete or private\n-         --  with unknown discriminants, then the constraint must be applied\n-         --  to the full type.\n-\n-         if Has_Unknown_Discriminants (Btyp)\n-           and then Present (Underlying_Type (Btyp))\n-         then\n-            Btyp := Underlying_Type (Btyp);\n-         end if;\n-\n-         Indic :=\n-           Make_Subtype_Indication (Loc,\n-             Subtype_Mark => New_Occurrence_Of (Btyp, Loc),\n-             Constraint   => Make_Index_Or_Discriminant_Constraint (Loc, C));\n-\n-         Def_Id := Create_Itype (Ekind (T), Related_Node);\n-\n-         Subtyp_Decl :=\n-           Make_Subtype_Declaration (Loc,\n-             Defining_Identifier => Def_Id,\n-             Subtype_Indication  => Indic);\n-\n-         Set_Parent (Subtyp_Decl, Parent (Related_Node));\n-\n-         --  Itypes must be analyzed with checks off (see package Itypes)\n-\n-         Analyze (Subtyp_Decl, Suppress => All_Checks);\n-\n-         if Is_Itype (Def_Id) and then Has_Predicates (T) then\n-            Inherit_Predicate_Flags (Def_Id, T);\n-\n-            --  Indicate where the predicate function may be found\n-\n-            if Is_Itype (T) then\n-               if Present (Predicate_Function (Def_Id)) then\n-                  null;\n-\n-               elsif Present (Predicate_Function (T)) then\n-                  Set_Predicate_Function (Def_Id, Predicate_Function (T));\n-\n-               else\n-                  Set_Predicated_Parent (Def_Id, Predicated_Parent (T));\n-               end if;\n-\n-            elsif No (Predicate_Function (Def_Id)) then\n-               Set_Predicated_Parent (Def_Id, T);\n-            end if;\n-         end if;\n-\n-         return Def_Id;\n-      end Build_Subtype;\n-\n       ---------------------\n       -- Get_Discr_Value --\n       ---------------------\n@@ -18483,38 +18407,6 @@ package body Sem_Ch3 is\n       return Assoc_List;\n    end Inherit_Components;\n \n-   -----------------------------\n-   -- Inherit_Predicate_Flags --\n-   -----------------------------\n-\n-   procedure Inherit_Predicate_Flags (Subt, Par : Entity_Id) is\n-   begin\n-      if Present (Predicate_Function (Subt)) then\n-         return;\n-      end if;\n-\n-      Set_Has_Predicates (Subt, Has_Predicates (Par));\n-      Set_Has_Static_Predicate_Aspect\n-        (Subt, Has_Static_Predicate_Aspect (Par));\n-      Set_Has_Dynamic_Predicate_Aspect\n-        (Subt, Has_Dynamic_Predicate_Aspect (Par));\n-\n-      --  A named subtype does not inherit the predicate function of its\n-      --  parent but an itype declared for a loop index needs the discrete\n-      --  predicate information of its parent to execute the loop properly.\n-      --  A non-discrete type may has a static predicate (for example True)\n-      --  but has no static_discrete_predicate.\n-\n-      if Is_Itype (Subt) and then Present (Predicate_Function (Par)) then\n-         Set_Subprograms_For_Type (Subt, Subprograms_For_Type (Par));\n-\n-         if Has_Static_Predicate (Par) and then Is_Discrete_Type (Par) then\n-            Set_Static_Discrete_Predicate\n-              (Subt, Static_Discrete_Predicate (Par));\n-         end if;\n-      end if;\n-   end Inherit_Predicate_Flags;\n-\n    ----------------------\n    -- Is_EVF_Procedure --\n    ----------------------"}, {"sha": "d1c63abc9d4d1f649ffac7e20b35f8bc9786aa9a", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 180, "deletions": 0, "changes": 180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b55e683cace7be98536c413a70f854a70faaa7/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b55e683cace7be98536c413a70f854a70faaa7/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=c5b55e683cace7be98536c413a70f854a70faaa7", "patch": "@@ -36,6 +36,7 @@ with Exp_Ch11; use Exp_Ch11;\n with Exp_Util; use Exp_Util;\n with Fname;    use Fname;\n with Freeze;   use Freeze;\n+with Itypes;   use Itypes;\n with Lib;      use Lib;\n with Lib.Xref; use Lib.Xref;\n with Namet.Sp; use Namet.Sp;\n@@ -1683,6 +1684,78 @@ package body Sem_Util is\n       return Decl;\n    end Build_Component_Subtype;\n \n+   -----------------------------\n+   -- Build_Constrained_Itype --\n+   -----------------------------\n+\n+   procedure Build_Constrained_Itype\n+     (N              : Node_Id;\n+      Typ            : Entity_Id;\n+      New_Assoc_List : List_Id)\n+   is\n+      Constrs     : constant List_Id    := New_List;\n+      Loc         : constant Source_Ptr := Sloc (N);\n+      Def_Id      : Entity_Id;\n+      Indic       : Node_Id;\n+      New_Assoc   : Node_Id;\n+      Subtyp_Decl : Node_Id;\n+\n+   begin\n+      New_Assoc := First (New_Assoc_List);\n+      while Present (New_Assoc) loop\n+\n+         --  There is exactly one choice in the component association (and\n+         --  it is either a discriminant, a component or the others clause).\n+         pragma Assert (List_Length (Choices (New_Assoc)) = 1);\n+\n+         --  Duplicate expression for the discriminant and put it on the\n+         --  list of constraints for the itype declaration.\n+\n+         if Is_Entity_Name (First (Choices (New_Assoc)))\n+           and then\n+             Ekind (Entity (First (Choices (New_Assoc)))) = E_Discriminant\n+         then\n+            Append_To (Constrs, Duplicate_Subexpr (Expression (New_Assoc)));\n+         end if;\n+\n+         Next (New_Assoc);\n+      end loop;\n+\n+      if Has_Unknown_Discriminants (Typ)\n+        and then Present (Underlying_Record_View (Typ))\n+      then\n+         Indic :=\n+           Make_Subtype_Indication (Loc,\n+             Subtype_Mark =>\n+               New_Occurrence_Of (Underlying_Record_View (Typ), Loc),\n+             Constraint   =>\n+               Make_Index_Or_Discriminant_Constraint (Loc,\n+                 Constraints => Constrs));\n+      else\n+         Indic :=\n+           Make_Subtype_Indication (Loc,\n+             Subtype_Mark =>\n+               New_Occurrence_Of (Base_Type (Typ), Loc),\n+             Constraint   =>\n+               Make_Index_Or_Discriminant_Constraint (Loc,\n+                 Constraints => Constrs));\n+      end if;\n+\n+      Def_Id := Create_Itype (Ekind (Typ), N);\n+\n+      Subtyp_Decl :=\n+        Make_Subtype_Declaration (Loc,\n+          Defining_Identifier => Def_Id,\n+          Subtype_Indication  => Indic);\n+      Set_Parent (Subtyp_Decl, Parent (N));\n+\n+      --  Itypes must be analyzed with checks off (see itypes.ads)\n+\n+      Analyze (Subtyp_Decl, Suppress => All_Checks);\n+\n+      Set_Etype (N, Def_Id);\n+   end Build_Constrained_Itype;\n+\n    ---------------------------\n    -- Build_Default_Subtype --\n    ---------------------------\n@@ -2120,6 +2193,81 @@ package body Sem_Util is\n       return New_Spec;\n    end Build_Overriding_Spec;\n \n+   -------------------\n+   -- Build_Subtype --\n+   -------------------\n+\n+   function Build_Subtype\n+     (Related_Node : Node_Id;\n+      Loc          : Source_Ptr;\n+      Typ          : Entity_Id;\n+      Constraints  : List_Id)\n+      return Entity_Id\n+   is\n+      Indic       : Node_Id;\n+      Subtyp_Decl : Node_Id;\n+      Def_Id      : Entity_Id;\n+      Btyp        : Entity_Id := Base_Type (Typ);\n+\n+   begin\n+      --  The Related_Node better be here or else we won't be able to\n+      --  attach new itypes to a node in the tree.\n+\n+      pragma Assert (Present (Related_Node));\n+\n+      --  If the view of the component's type is incomplete or private\n+      --  with unknown discriminants, then the constraint must be applied\n+      --  to the full type.\n+\n+      if Has_Unknown_Discriminants (Btyp)\n+        and then Present (Underlying_Type (Btyp))\n+      then\n+         Btyp := Underlying_Type (Btyp);\n+      end if;\n+\n+      Indic :=\n+        Make_Subtype_Indication (Loc,\n+          Subtype_Mark => New_Occurrence_Of (Btyp, Loc),\n+          Constraint   =>\n+            Make_Index_Or_Discriminant_Constraint (Loc, Constraints));\n+\n+      Def_Id := Create_Itype (Ekind (Typ), Related_Node);\n+\n+      Subtyp_Decl :=\n+        Make_Subtype_Declaration (Loc,\n+          Defining_Identifier => Def_Id,\n+          Subtype_Indication  => Indic);\n+\n+      Set_Parent (Subtyp_Decl, Parent (Related_Node));\n+\n+      --  Itypes must be analyzed with checks off (see package Itypes)\n+\n+      Analyze (Subtyp_Decl, Suppress => All_Checks);\n+\n+      if Is_Itype (Def_Id) and then Has_Predicates (Typ) then\n+         Inherit_Predicate_Flags (Def_Id, Typ);\n+\n+         --  Indicate where the predicate function may be found\n+\n+         if Is_Itype (Typ) then\n+            if Present (Predicate_Function (Def_Id)) then\n+               null;\n+\n+            elsif Present (Predicate_Function (Typ)) then\n+               Set_Predicate_Function (Def_Id, Predicate_Function (Typ));\n+\n+            else\n+               Set_Predicated_Parent (Def_Id, Predicated_Parent (Typ));\n+            end if;\n+\n+         elsif No (Predicate_Function (Def_Id)) then\n+            Set_Predicated_Parent (Def_Id, Typ);\n+         end if;\n+      end if;\n+\n+      return Def_Id;\n+   end Build_Subtype;\n+\n    -----------------------------------\n    -- Cannot_Raise_Constraint_Error --\n    -----------------------------------\n@@ -13236,6 +13384,38 @@ package body Sem_Util is\n       return Off * (Expr_Value (Exp) - Expr_Value (Low_Bound ((Ind))));\n    end Indexed_Component_Bit_Offset;\n \n+   -----------------------------\n+   -- Inherit_Predicate_Flags --\n+   -----------------------------\n+\n+   procedure Inherit_Predicate_Flags (Subt, Par : Entity_Id) is\n+   begin\n+      if Present (Predicate_Function (Subt)) then\n+         return;\n+      end if;\n+\n+      Set_Has_Predicates (Subt, Has_Predicates (Par));\n+      Set_Has_Static_Predicate_Aspect\n+        (Subt, Has_Static_Predicate_Aspect (Par));\n+      Set_Has_Dynamic_Predicate_Aspect\n+        (Subt, Has_Dynamic_Predicate_Aspect (Par));\n+\n+      --  A named subtype does not inherit the predicate function of its\n+      --  parent but an itype declared for a loop index needs the discrete\n+      --  predicate information of its parent to execute the loop properly.\n+      --  A non-discrete type may has a static predicate (for example True)\n+      --  but has no static_discrete_predicate.\n+\n+      if Is_Itype (Subt) and then Present (Predicate_Function (Par)) then\n+         Set_Subprograms_For_Type (Subt, Subprograms_For_Type (Par));\n+\n+         if Has_Static_Predicate (Par) and then Is_Discrete_Type (Par) then\n+            Set_Static_Discrete_Predicate\n+              (Subt, Static_Discrete_Predicate (Par));\n+         end if;\n+      end if;\n+   end Inherit_Predicate_Flags;\n+\n    ----------------------------\n    -- Inherit_Rep_Item_Chain --\n    ----------------------------"}, {"sha": "07619fcde36df234b84c3ddaf4cd4d98e051900e", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 49, "deletions": 8, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b55e683cace7be98536c413a70f854a70faaa7/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b55e683cace7be98536c413a70f854a70faaa7/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=c5b55e683cace7be98536c413a70f854a70faaa7", "patch": "@@ -273,6 +273,27 @@ package Sem_Util is\n    --  through a type-specific wrapper for all inherited subprograms that\n    --  may have a modified condition.\n \n+   procedure Build_Constrained_Itype\n+     (N              : Node_Id;\n+      Typ            : Entity_Id;\n+      New_Assoc_List : List_Id);\n+   --  Build a constrained itype for the newly created record aggregate N and\n+   --  set it as a type of N. The itype will have Typ as its base type and\n+   --  will be constrained by the values of discriminants from the component\n+   --  association list New_Assoc_List.\n+\n+   --  ??? This code used to be pretty much a copy of Build_Subtype, but now\n+   --  those two routines behave differently for types with unknown\n+   --  discriminants. They are both exported in from this package in the hope\n+   --  to eventually unify them (a not duplicate them even more until then).\n+\n+   --  ??? Performance WARNING. The current implementation creates a new itype\n+   --  for all aggregates whose base type is discriminated. This means that\n+   --  for record aggregates nested inside an array aggregate we will create\n+   --  a new itype for each record aggregate if the array component type has\n+   --  discriminants. For large aggregates this may be a problem. What should\n+   --  be done in this case is to reuse itypes as much as possible.\n+\n    function Build_Default_Subtype\n      (T : Entity_Id;\n       N : Node_Id) return Entity_Id;\n@@ -291,14 +312,6 @@ package Sem_Util is\n    --  the compilation unit, and install it in the Elaboration_Entity field\n    --  of Spec_Id, the entity for the compilation unit.\n \n-   function Build_Overriding_Spec\n-     (Op  : Node_Id;\n-      Typ : Entity_Id) return Node_Id;\n-   --  Build a subprogram specification for the wrapper of an inherited\n-   --  operation with a modified pre- or postcondition (See AI12-0113).\n-   --  Op is the parent operation, and Typ is the descendant type that\n-   --  inherits the operation.\n-\n    procedure Build_Explicit_Dereference\n      (Expr : Node_Id;\n       Disc : Entity_Id);\n@@ -308,6 +321,30 @@ package Sem_Util is\n    --  loaded with both interpretations, and the dereference interpretation\n    --  carries the name of the reference discriminant.\n \n+   function Build_Overriding_Spec\n+     (Op  : Node_Id;\n+      Typ : Entity_Id) return Node_Id;\n+   --  Build a subprogram specification for the wrapper of an inherited\n+   --  operation with a modified pre- or postcondition (See AI12-0113).\n+   --  Op is the parent operation, and Typ is the descendant type that\n+   --  inherits the operation.\n+\n+   function Build_Subtype\n+     (Related_Node : Node_Id;\n+      Loc          : Source_Ptr;\n+      Typ          : Entity_Id;\n+      Constraints  : List_Id)\n+      return Entity_Id;\n+   --  Typ is an array or discriminated type, Constraints is a list of\n+   --  constraints that apply to Typ. This routine builds the constrained\n+   --  subtype using Loc as the source location and attached this subtype\n+   --  declaration to Related_Node. The returned subtype inherits predicates\n+   --  from Typ.\n+\n+   --  ??? The routine is mostly a duplicate of Build_Constrained_Itype, so be\n+   --  careful which of the two better suits your needs (and certainly do not\n+   --  duplicate their code).\n+\n    function Cannot_Raise_Constraint_Error (Expr : Node_Id) return Boolean;\n    --  Returns True if the expression cannot possibly raise Constraint_Error.\n    --  The response is conservative in the sense that a result of False does\n@@ -1485,6 +1522,10 @@ package Sem_Util is\n    --  either the value is not yet known before back-end processing or it is\n    --  not known at compile time after back-end processing.\n \n+   procedure Inherit_Predicate_Flags (Subt, Par : Entity_Id);\n+   --  Propagate static and dynamic predicate flags from a parent to the\n+   --  subtype in a subtype declaration with and without constraints.\n+\n    procedure Inherit_Rep_Item_Chain (Typ : Entity_Id; From_Typ : Entity_Id);\n    --  Inherit the rep item chain of type From_Typ without clobbering any\n    --  existing rep items on Typ's chain. Typ is the destination type."}]}