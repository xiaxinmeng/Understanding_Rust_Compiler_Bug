{"sha": "10acaf4db9f8b54bd55fb7a6f5b6bb39a91fb9b8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTBhY2FmNGRiOWY4YjU0YmQ1NWZiN2E2ZjViNmJiMzlhOTFmYjliOA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2019-07-31T18:50:00Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2019-07-31T18:50:00Z"}, "message": "PR c++/90538 - multiple expansions of capture packs\n\nPreviously, with init-capture the type of the closure field was a\nDECLTYPE_TYPE of the initializer.  But since each time we tsubst a lambda we\nget a different lambda, that meant that if the initializer is a lambda, we'd\nend up with different closure types in the field and initializer after\nsubstitution (PR 87322).  We dealt with this by remembering the lambda\ninstantiation within each pack expansion element, using\nlocal_specialization_stack to separate the elements.  But that broke this\ntestcase, because it lost lambda capture proxies that also use\nlocal_specializations.\n\nSo, this patch removes the local_specializations changes from that patch and\nfixes 87322 differently, by giving init-capture fields 'auto' type and doing\ndeduction later.  There's a bit of a kludge to get the right number of\nfields by pretending that 'auto...' uses the parameter packs from the\ninitializer, but it does the trick.\n\n\t* cp-tree.h (DECLTYPE_FOR_INIT_CAPTURE): Remove.\n\t* lambda.c (add_capture): Copy parameter packs from init.\n\t(lambda_capture_field_type): Always use auto for init-capture.\n\t* pt.c (uses_parameter_packs): Return tree.\n\t(tsubst) [DECLTYPE_TYPE]: Remove init-capture handling.\n\t(gen_elem_of_pack_expansion_instantiation): Don't push\n\tlocal_specialization_stack.\n\t(prepend_one_capture): New.\n\t(tsubst_lambda_expr): Use it.  Don't touch local_specializations.\n\t(do_auto_deduction): Avoid redundant error.\n\nFrom-SVN: r273944", "tree": {"sha": "d87b3e8faad065950a5e60c3ced44c3a27fada8c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d87b3e8faad065950a5e60c3ced44c3a27fada8c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/10acaf4db9f8b54bd55fb7a6f5b6bb39a91fb9b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10acaf4db9f8b54bd55fb7a6f5b6bb39a91fb9b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10acaf4db9f8b54bd55fb7a6f5b6bb39a91fb9b8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10acaf4db9f8b54bd55fb7a6f5b6bb39a91fb9b8/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "fc79fc4966060222486458e6b310203e4e8527a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc79fc4966060222486458e6b310203e4e8527a1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc79fc4966060222486458e6b310203e4e8527a1"}], "stats": {"total": 144, "additions": 91, "deletions": 53}, "files": [{"sha": "e30cc6d8d771b0fa4aff49a665f3d48d45cd106c", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10acaf4db9f8b54bd55fb7a6f5b6bb39a91fb9b8/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10acaf4db9f8b54bd55fb7a6f5b6bb39a91fb9b8/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=10acaf4db9f8b54bd55fb7a6f5b6bb39a91fb9b8", "patch": "@@ -1,5 +1,17 @@\n 2019-07-31  Jason Merrill  <jason@redhat.com>\n \n+\tPR c++/90538 - multiple expansions of capture packs\n+\t* cp-tree.h (DECLTYPE_FOR_INIT_CAPTURE): Remove.\n+\t* lambda.c (add_capture): Copy parameter packs from init.\n+\t(lambda_capture_field_type): Always use auto for init-capture.\n+\t* pt.c (uses_parameter_packs): Return tree.\n+\t(tsubst) [DECLTYPE_TYPE]: Remove init-capture handling.\n+\t(gen_elem_of_pack_expansion_instantiation): Don't push\n+\tlocal_specialization_stack.\n+\t(prepend_one_capture): New.\n+\t(tsubst_lambda_expr): Use it.  Don't touch local_specializations.\n+\t(do_auto_deduction): Avoid redundant error.\n+\n \tFix copy_node of TEMPLATE_INFO.\n \t* cp-tree.h (struct tree_template_info): Use tree_base instead of\n \ttree_common.  Add tmpl and args fields."}, {"sha": "c6a1eff9ce1d7e29948a381e987ea2fd33891dc7", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10acaf4db9f8b54bd55fb7a6f5b6bb39a91fb9b8/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10acaf4db9f8b54bd55fb7a6f5b6bb39a91fb9b8/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=10acaf4db9f8b54bd55fb7a6f5b6bb39a91fb9b8", "patch": "@@ -423,7 +423,6 @@ extern GTY(()) tree cp_global_trees[CPTI_MAX];\n       LAMBDA_EXPR_MUTABLE_P (in LAMBDA_EXPR)\n       DECL_FINAL_P (in FUNCTION_DECL)\n       QUALIFIED_NAME_IS_TEMPLATE (in SCOPE_REF)\n-      DECLTYPE_FOR_INIT_CAPTURE (in DECLTYPE_TYPE)\n       CONSTRUCTOR_IS_DEPENDENT (in CONSTRUCTOR)\n       TINFO_USED_TEMPLATE_ID (in TEMPLATE_INFO)\n       PACK_EXPANSION_SIZEOF_P (in *_PACK_EXPANSION)\n@@ -4484,12 +4483,10 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n   (DECLTYPE_TYPE_CHECK (NODE))->type_common.string_flag\n \n /* These flags indicate that we want different semantics from normal\n-   decltype: lambda capture just drops references, init capture\n-   uses auto semantics, lambda proxies look through implicit dereference.  */\n+   decltype: lambda capture just drops references,\n+   lambda proxies look through implicit dereference.  */\n #define DECLTYPE_FOR_LAMBDA_CAPTURE(NODE) \\\n   TREE_LANG_FLAG_0 (DECLTYPE_TYPE_CHECK (NODE))\n-#define DECLTYPE_FOR_INIT_CAPTURE(NODE) \\\n-  TREE_LANG_FLAG_1 (DECLTYPE_TYPE_CHECK (NODE))\n #define DECLTYPE_FOR_LAMBDA_PROXY(NODE) \\\n   TREE_LANG_FLAG_2 (DECLTYPE_TYPE_CHECK (NODE))\n #define DECLTYPE_FOR_REF_CAPTURE(NODE) \\\n@@ -6794,7 +6791,7 @@ extern bool maybe_instantiate_noexcept\t\t(tree, tsubst_flags_t = tf_warning_or_er\n extern tree instantiate_decl\t\t\t(tree, bool, bool);\n extern int comp_template_parms\t\t\t(const_tree, const_tree);\n extern bool builtin_pack_fn_p\t\t\t(tree);\n-extern bool uses_parameter_packs                (tree);\n+extern tree uses_parameter_packs                (tree);\n extern bool template_parameter_pack_p           (const_tree);\n extern bool function_parameter_pack_p\t\t(const_tree);\n extern bool function_parameter_expanded_from_pack_p (tree, tree);"}, {"sha": "c4fed1682692d878bfbcfb820e77e11ef9cd8305", "filename": "gcc/cp/lambda.c", "status": "modified", "additions": 19, "deletions": 11, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10acaf4db9f8b54bd55fb7a6f5b6bb39a91fb9b8/gcc%2Fcp%2Flambda.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10acaf4db9f8b54bd55fb7a6f5b6bb39a91fb9b8/gcc%2Fcp%2Flambda.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flambda.c?ref=10acaf4db9f8b54bd55fb7a6f5b6bb39a91fb9b8", "patch": "@@ -213,16 +213,7 @@ lambda_capture_field_type (tree expr, bool explicit_init_p,\n   tree type;\n   bool is_this = is_this_parameter (tree_strip_nop_conversions (expr));\n \n-  if (!is_this && type_dependent_expression_p (expr))\n-    {\n-      type = cxx_make_type (DECLTYPE_TYPE);\n-      DECLTYPE_TYPE_EXPR (type) = expr;\n-      DECLTYPE_FOR_LAMBDA_CAPTURE (type) = true;\n-      DECLTYPE_FOR_INIT_CAPTURE (type) = explicit_init_p;\n-      DECLTYPE_FOR_REF_CAPTURE (type) = by_reference_p;\n-      SET_TYPE_STRUCTURAL_EQUALITY (type);\n-    }\n-  else if (!is_this && explicit_init_p)\n+  if (!is_this && explicit_init_p)\n     {\n       tree auto_node = make_auto ();\n       \n@@ -233,6 +224,14 @@ lambda_capture_field_type (tree expr, bool explicit_init_p,\n \ttype = build_reference_type (type);\n       type = do_auto_deduction (type, expr, auto_node);\n     }\n+  else if (!is_this && type_dependent_expression_p (expr))\n+    {\n+      type = cxx_make_type (DECLTYPE_TYPE);\n+      DECLTYPE_TYPE_EXPR (type) = expr;\n+      DECLTYPE_FOR_LAMBDA_CAPTURE (type) = true;\n+      DECLTYPE_FOR_REF_CAPTURE (type) = by_reference_p;\n+      SET_TYPE_STRUCTURAL_EQUALITY (type);\n+    }\n   else\n     {\n       type = non_reference (unlowered_expr_type (expr));\n@@ -594,7 +593,16 @@ add_capture (tree lambda, tree id, tree orig_init, bool by_reference_p,\n   name = get_identifier (buf);\n \n   if (variadic)\n-    type = make_pack_expansion (type);\n+    {\n+      type = make_pack_expansion (type);\n+      if (explicit_init_p)\n+\t/* With an explicit initializer 'type' is auto, which isn't really a\n+\t   parameter pack in this context.  We will want as many fields as we\n+\t   have elements in the expansion of the initializer, so use its packs\n+\t   instead.  */\n+\tPACK_EXPANSION_PARAMETER_PACKS (type)\n+\t  = uses_parameter_packs (initializer);\n+    }\n \n   /* Make member variable.  */\n   member = build_decl (input_location, FIELD_DECL, name, type);"}, {"sha": "91a46745447609aebca91f1ca6d4b058038ab112", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 39, "deletions": 34, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10acaf4db9f8b54bd55fb7a6f5b6bb39a91fb9b8/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10acaf4db9f8b54bd55fb7a6f5b6bb39a91fb9b8/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=10acaf4db9f8b54bd55fb7a6f5b6bb39a91fb9b8", "patch": "@@ -3872,7 +3872,7 @@ find_parameter_packs_r (tree *tp, int *walk_subtrees, void* data)\n }\n \n /* Determines if the expression or type T uses any parameter packs.  */\n-bool\n+tree\n uses_parameter_packs (tree t)\n {\n   tree parameter_packs = NULL_TREE;\n@@ -3882,7 +3882,7 @@ uses_parameter_packs (tree t)\n   ppd.type_pack_expansion_p = false;\n   cp_walk_tree (&t, &find_parameter_packs_r, &ppd, ppd.visited);\n   delete ppd.visited;\n-  return parameter_packs != NULL_TREE;\n+  return parameter_packs;\n }\n \n /* Turn ARG, which may be an expression, type, or a TREE_LIST\n@@ -11764,10 +11764,6 @@ gen_elem_of_pack_expansion_instantiation (tree pattern,\n       ARGUMENT_PACK_SELECT_INDEX (aps) = index;\n     }\n \n-  // Any local specialization bindings arising from this substitution\n-  // cannot be reused for a different INDEX.\n-  local_specialization_stack lss (lss_copy);\n-\n   /* Substitute into the PATTERN with the (possibly altered)\n      arguments.  */\n   if (pattern == in_decl)\n@@ -15139,24 +15135,12 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t\t\t\t      /*function_p*/false,\n \t\t\t\t      /*integral_constant_expression*/false);\n \n-\tif (DECLTYPE_FOR_INIT_CAPTURE (t))\n-\t  {\n-\t    if (type == NULL_TREE)\n-\t      {\n-\t\tif (complain & tf_error)\n-\t\t  error (\"empty initializer in lambda init-capture\");\n-\t\ttype = error_mark_node;\n-\t      }\n-\t    else if (TREE_CODE (type) == TREE_LIST)\n-\t      type = build_x_compound_expr_from_list (type, ELK_INIT, complain);\n-\t  }\n-\n \t--cp_unevaluated_operand;\n \t--c_inhibit_evaluation_warnings;\n \n \tif (DECLTYPE_FOR_LAMBDA_CAPTURE (t))\n \t  type = lambda_capture_field_type (type,\n-\t\t\t\t\t    DECLTYPE_FOR_INIT_CAPTURE (t),\n+\t\t\t\t\t    false /*explicit_init*/,\n \t\t\t\t\t    DECLTYPE_FOR_REF_CAPTURE (t));\n \telse if (DECLTYPE_FOR_LAMBDA_PROXY (t))\n \t  type = lambda_proxy_type (type);\n@@ -18023,6 +18007,33 @@ tsubst_non_call_postfix_expression (tree t, tree args,\n   return t;\n }\n \n+/* Subroutine of tsubst_lambda_expr: add the FIELD/INIT capture pair to the\n+   LAMBDA_EXPR_CAPTURE_LIST passed in LIST.  Do deduction for a previously\n+   dependent init-capture.  */\n+\n+static void\n+prepend_one_capture (tree field, tree init, tree &list,\n+\t\t     tsubst_flags_t complain)\n+{\n+  if (tree auto_node = type_uses_auto (TREE_TYPE (field)))\n+    {\n+      tree type = NULL_TREE;\n+      if (!init)\n+\t{\n+\t  if (complain & tf_error)\n+\t    error (\"empty initializer in lambda init-capture\");\n+\t  init = error_mark_node;\n+\t}\n+      else if (TREE_CODE (init) == TREE_LIST)\n+\tinit = build_x_compound_expr_from_list (init, ELK_INIT, complain);\n+      if (!type)\n+\ttype = do_auto_deduction (TREE_TYPE (field), init, auto_node, complain);\n+      TREE_TYPE (field) = type;\n+      cp_apply_type_quals_to_decl (cp_type_quals (type), field);\n+    }\n+  list = tree_cons (field, init, list);\n+}\n+\n /* T is a LAMBDA_EXPR.  Generate a new LAMBDA_EXPR for the current\n    instantiation context.  Instantiating a pack expansion containing a lambda\n    might result in multiple lambdas all based on the same lambda in the\n@@ -18034,17 +18045,8 @@ tsubst_lambda_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n   tree oldfn = lambda_function (t);\n   in_decl = oldfn;\n \n-  /* If we have already specialized this lambda expr, reuse it.  See\n-     PR c++/87322.  */\n-  if (local_specializations)\n-    if (tree r = retrieve_local_specialization (t))\n-      return r;\n-\n   tree r = build_lambda_expr ();\n \n-  if (local_specializations)\n-    register_local_specialization (r, t);\n-\n   LAMBDA_EXPR_LOCATION (r)\n     = LAMBDA_EXPR_LOCATION (t);\n   LAMBDA_EXPR_DEFAULT_CAPTURE_MODE (r)\n@@ -18097,15 +18099,15 @@ tsubst_lambda_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t  gcc_assert (TREE_CODE (init) == TREE_VEC\n \t\t      && TREE_VEC_LENGTH (init) == len);\n \t  for (int i = 0; i < len; ++i)\n-\t    LAMBDA_EXPR_CAPTURE_LIST (r)\n-\t      = tree_cons (TREE_VEC_ELT (field, i),\n-\t\t\t   TREE_VEC_ELT (init, i),\n-\t\t\t   LAMBDA_EXPR_CAPTURE_LIST (r));\n+\t    prepend_one_capture (TREE_VEC_ELT (field, i),\n+\t\t\t\t TREE_VEC_ELT (init, i),\n+\t\t\t\t LAMBDA_EXPR_CAPTURE_LIST (r),\n+\t\t\t\t complain);\n \t}\n       else\n \t{\n-\t  LAMBDA_EXPR_CAPTURE_LIST (r)\n-\t    = tree_cons (field, init, LAMBDA_EXPR_CAPTURE_LIST (r));\n+\t  prepend_one_capture (field, init, LAMBDA_EXPR_CAPTURE_LIST (r),\n+\t\t\t       complain);\n \n \t  if (id_equal (DECL_NAME (field), \"__this\"))\n \t    LAMBDA_EXPR_THIS_CAPTURE (r) = field;\n@@ -27602,6 +27604,9 @@ do_auto_deduction (tree type, tree init, tree auto_node,\n     }\n   else\n     {\n+      if (error_operand_p (init))\n+\treturn error_mark_node;\n+\n       tree parms = build_tree_list (NULL_TREE, type);\n       tree tparms;\n "}, {"sha": "8c5085cf0f1049ead9b6eb7c28db5e6a2a8dacd3", "filename": "gcc/testsuite/g++.dg/cpp0x/lambda/lambda-variadic9.C", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10acaf4db9f8b54bd55fb7a6f5b6bb39a91fb9b8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-variadic9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10acaf4db9f8b54bd55fb7a6f5b6bb39a91fb9b8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-variadic9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-variadic9.C?ref=10acaf4db9f8b54bd55fb7a6f5b6bb39a91fb9b8", "patch": "@@ -0,0 +1,16 @@\n+// PR c++/90538\n+// { dg-do compile { target c++11 } }\n+\n+template <class... Ts>\n+void f(Ts... ts)\n+{\n+  [=]{\n+    f(ts...);\n+    f(ts...);\n+  }();\n+}\n+\n+void g()\n+{\n+  f(1);\n+}"}, {"sha": "6afaee577f2326e08c7c3a75833fb9b5a3003c0b", "filename": "gcc/testsuite/g++.dg/cpp0x/range-for19.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10acaf4db9f8b54bd55fb7a6f5b6bb39a91fb9b8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frange-for19.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10acaf4db9f8b54bd55fb7a6f5b6bb39a91fb9b8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frange-for19.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frange-for19.C?ref=10acaf4db9f8b54bd55fb7a6f5b6bb39a91fb9b8", "patch": "@@ -5,6 +5,6 @@\n int main()\n {\n   auto a;        // { dg-error \"no initializer\" }\n-  for(auto i: a) // { dg-error \"deduce\" }\n+  for(auto i: a)\n     ;\n }"}, {"sha": "6b4ed347eeea113284aca978004ac7e62723f109", "filename": "gcc/testsuite/g++.dg/cpp1y/lambda-init16.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10acaf4db9f8b54bd55fb7a6f5b6bb39a91fb9b8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Flambda-init16.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10acaf4db9f8b54bd55fb7a6f5b6bb39a91fb9b8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Flambda-init16.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Flambda-init16.C?ref=10acaf4db9f8b54bd55fb7a6f5b6bb39a91fb9b8", "patch": "@@ -3,7 +3,7 @@\n \n template < class T = int > void f (T)\n {\n-  auto g = [&a = f] () {};  // { dg-error \"invalid initialization\" }\n+  auto g = [&a = f] () {};  // { dg-error \"auto\" }\n }\n \n int main ()"}]}