{"sha": "307193b82cecb8ab79cf8880d642e1a3acb9c9f6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzA3MTkzYjgyY2VjYjhhYjc5Y2Y4ODgwZDY0MmUxYTNhY2I5YzlmNg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2018-06-27T02:59:44Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2018-06-27T02:59:44Z"}, "message": "PR c++/86320 - memory-hog with std::array of pair\n\n\t* typeck2.c (process_init_constructor_array): Only compute a\n\tconstant initializer once.\n\nIn this PR, we have a large std::array of pairs.  Since the C array is\nwrapped in a class we don't go to build_vec_init, so we end up with\ndigest_init wanting to build up the element initializer for each element of\nthe array.\n\nIn the more general case, like 80272, we have a data structure problem: we\ndon't currently have a good way of expressing the same dynamic\ninitialization of many elements within a CONSTRUCTOR.  RANGE_EXPR probably\nought to work, but will need more work at genericize or gimplify time.\n\nBut in this case, the initialization for each element reduces to constant\n0, so we don't even need to add anything to the CONSTRUCTOR.  We just need\nto realize that if the initializer for one element is 0, the others will be\nas well, and we don't need to iterate over the whole array.\n\nFor the trunk, I also use a RANGE_EXPR to handle constant initialization by\na value other than 0.\n\nvoid foo ()\n{\n  std::array<std::pair<int, int>, 1024 * 1024> arr {};\n}\n\nFrom-SVN: r262173", "tree": {"sha": "e8ecb61a6f283f91fee98716062463538c3c38f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e8ecb61a6f283f91fee98716062463538c3c38f0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/307193b82cecb8ab79cf8880d642e1a3acb9c9f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/307193b82cecb8ab79cf8880d642e1a3acb9c9f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/307193b82cecb8ab79cf8880d642e1a3acb9c9f6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/307193b82cecb8ab79cf8880d642e1a3acb9c9f6/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6147a53a9cb946ab08acb0177cff29a40aee937b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6147a53a9cb946ab08acb0177cff29a40aee937b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6147a53a9cb946ab08acb0177cff29a40aee937b"}], "stats": {"total": 20, "additions": 19, "deletions": 1}, "files": [{"sha": "90d1545d7344f839ab406fb4e52ed02eb68b884e", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/307193b82cecb8ab79cf8880d642e1a3acb9c9f6/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/307193b82cecb8ab79cf8880d642e1a3acb9c9f6/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=307193b82cecb8ab79cf8880d642e1a3acb9c9f6", "patch": "@@ -1,5 +1,9 @@\n 2018-06-26  Jason Merrill  <jason@redhat.com>\n \n+\tPR c++/86320 - memory-hog with std::array of pair\n+\t* typeck2.c (process_init_constructor_array): Only compute a\n+\tconstant initializer once.\n+\n \tPR c++/80290 - memory-hog with std::pair.\n \t* pt.c (fn_type_unification): Add convs parameter.\n \t(check_non_deducible_conversion): Remember conversion."}, {"sha": "91aa5a62856d13517cb5f4d07d1427eb87895b89", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/307193b82cecb8ab79cf8880d642e1a3acb9c9f6/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/307193b82cecb8ab79cf8880d642e1a3acb9c9f6/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=307193b82cecb8ab79cf8880d642e1a3acb9c9f6", "patch": "@@ -1365,8 +1365,22 @@ process_init_constructor_array (tree type, tree init, int nested,\n \tif (next)\n \t  {\n \t    flags |= picflag_from_initializer (next);\n-\t    CONSTRUCTOR_APPEND_ELT (v, size_int (i), next);\n+\t    if (len > i+1\n+\t\t&& (initializer_constant_valid_p (next, TREE_TYPE (next))\n+\t\t    == null_pointer_node))\n+\t      {\n+\t\ttree range = build2 (RANGE_EXPR, size_type_node,\n+\t\t\t\t     build_int_cst (size_type_node, i),\n+\t\t\t\t     build_int_cst (size_type_node, len - 1));\n+\t\tCONSTRUCTOR_APPEND_ELT (v, range, next);\n+\t\tbreak;\n+\t      }\n+\t    else\n+\t      CONSTRUCTOR_APPEND_ELT (v, size_int (i), next);\n \t  }\n+\telse\n+\t  /* Don't bother checking all the other elements.  */\n+\t  break;\n       }\n \n   CONSTRUCTOR_ELTS (init) = v;"}]}