{"sha": "79f57d5cb070bb02ea0a34b5f42658d6659b19a8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzlmNTdkNWNiMDcwYmIwMmVhMGEzNGI1ZjQyNjU4ZDY2NTliMTlhOA==", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2020-12-18T03:18:07Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2020-12-18T03:18:07Z"}, "message": "c++: Diagnose self-recursive satisfaction\n\nThis patch further extends the satisfaction_cache class to diagnose\nself-recursive satisfaction.\n\ngcc/cp/ChangeLog:\n\n\t* constraint.cc (sat_entry::evaluating): New member.\n\t(satisfaction_cache::get): If entry->evaluating, diagnose\n\tself-recursive satisfaction.  Otherwise, set entry->evaluating\n\tif we're not reusing a cached satisfaction result.\n\t(satisfaction_cache::save): Clear entry->evaluating.\n\t(satisfy_atom): Set up diagnosing_failed_constraint before the\n\tfirst call to get().\n\ngcc/testsuite/ChangeLog:\n\n\tPR c++/96840\n\t* g++.dg/cpp2a/concepts-pr88395.C: Adjust to expect the\n\tself-recursive satisfaction to get directly diagnosed.\n\t* g++.dg/cpp2a/concepts-recursive-sat2.C: Likewise.\n\t* g++.dg/cpp2a/concepts-recursive-sat4.C: New test.", "tree": {"sha": "b7dba72ed8e157d1c7895c62e038be36cba7a903", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b7dba72ed8e157d1c7895c62e038be36cba7a903"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/79f57d5cb070bb02ea0a34b5f42658d6659b19a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79f57d5cb070bb02ea0a34b5f42658d6659b19a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/79f57d5cb070bb02ea0a34b5f42658d6659b19a8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79f57d5cb070bb02ea0a34b5f42658d6659b19a8/comments", "author": null, "committer": null, "parents": [{"sha": "20f292863f6ed230335c443893d4db664a8140d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20f292863f6ed230335c443893d4db664a8140d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/20f292863f6ed230335c443893d4db664a8140d0"}], "stats": {"total": 66, "additions": 49, "deletions": 17}, "files": [{"sha": "40e499bbbd12d530f58826c1e02ffb31e95cc12f", "filename": "gcc/cp/constraint.cc", "status": "modified", "additions": 31, "deletions": 8, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79f57d5cb070bb02ea0a34b5f42658d6659b19a8/gcc%2Fcp%2Fconstraint.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79f57d5cb070bb02ea0a34b5f42658d6659b19a8/gcc%2Fcp%2Fconstraint.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstraint.cc?ref=79f57d5cb070bb02ea0a34b5f42658d6659b19a8", "patch": "@@ -2428,6 +2428,11 @@ struct GTY((for_user)) sat_entry\n      We don't always want to do so, in order to avoid emitting duplicate\n      diagnostics in some cases.  */\n   bool diagnose_instability;\n+\n+  /* True if we're in the middle of computing this satisfaction result.\n+     Used during both quiet and noisy satisfaction to detect self-recursive\n+     satisfaction.  */\n+  bool evaluating;\n };\n \n struct sat_hasher : ggc_ptr_hash<sat_entry>\n@@ -2572,6 +2577,7 @@ ::satisfaction_cache (tree atom, tree args, sat_info info)\n \t   mapping, we set this flag (in satisfy_atom) only if substitution\n \t   into its mapping previously failed.  */\n \tentry->diagnose_instability = true;\n+      entry->evaluating = false;\n       *slot = entry;\n     }\n   else\n@@ -2590,9 +2596,23 @@ satisfaction_cache::get ()\n   if (!entry)\n     return NULL_TREE;\n \n-  if (info.noisy () || entry->maybe_unstable)\n-    /* We're recomputing the satisfaction result from scratch.  */\n-    return NULL_TREE;\n+  if (entry->evaluating)\n+    {\n+      /* If we get here, it means satisfaction is self-recursive.  */\n+      gcc_checking_assert (!entry->result);\n+      if (info.noisy ())\n+\terror_at (EXPR_LOCATION (ATOMIC_CONSTR_EXPR (entry->atom)),\n+\t\t  \"satisfaction of atomic constraint %qE depends on itself\",\n+\t\t  entry->atom);\n+      return error_mark_node;\n+    }\n+\n+  if (info.noisy () || entry->maybe_unstable || !entry->result)\n+    {\n+      /* We're computing the satisfaction result from scratch.  */\n+      entry->evaluating = true;\n+      return NULL_TREE;\n+    }\n   else\n     return entry->result;\n }\n@@ -2607,6 +2627,9 @@ satisfaction_cache::save (tree result)\n   if (!entry)\n     return result;\n \n+  gcc_checking_assert (entry->evaluating);\n+  entry->evaluating = false;\n+\n   if (entry->result && result != entry->result)\n     {\n       if (info.quiet ())\n@@ -2856,18 +2879,18 @@ static void diagnose_atomic_constraint (tree, tree, tree, subst_info);\n static tree\n satisfy_atom (tree t, tree args, sat_info info)\n {\n+  /* In case there is a diagnostic, we want to establish the context\n+     prior to printing errors.  If no errors occur, this context is\n+     removed before returning.  */\n+  diagnosing_failed_constraint failure (t, args, info.noisy ());\n+\n   satisfaction_cache cache (t, args, info);\n   if (tree r = cache.get ())\n     return r;\n \n   /* Perform substitution quietly.  */\n   subst_info quiet (tf_none, NULL_TREE);\n \n-  /* In case there is a diagnostic, we want to establish the context\n-     prior to printing errors.  If no errors occur, this context is\n-     removed before returning.  */\n-  diagnosing_failed_constraint failure (t, args, info.noisy ());\n-\n   /* Instantiate the parameter mapping.  */\n   tree map = tsubst_parameter_mapping (ATOMIC_CONSTR_MAP (t), args, quiet);\n   if (map == error_mark_node)"}, {"sha": "e1792e19005c636ccda85fa725dbea4fdcc9d318", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-pr88395.C", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79f57d5cb070bb02ea0a34b5f42658d6659b19a8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr88395.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79f57d5cb070bb02ea0a34b5f42658d6659b19a8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr88395.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr88395.C?ref=79f57d5cb070bb02ea0a34b5f42658d6659b19a8", "patch": "@@ -1,9 +1,9 @@\n // { dg-do compile { target c++20 } }\n \n template <class T, class U>\n-concept Concept2 = requires (T t, U u)\n+concept Concept2 = requires (T t, U u) // { dg-error \"depends on itself\" }\n {\n-    t += u; // { dg-error \"template instantiation depth\" }\n+    t += u;\n };\n \n template <class T>\n@@ -17,7 +17,5 @@ struct S\n \n constexpr S operator * (S a, S b)\n {\n-    return a += b;\n+    return a += b; // { dg-error \"no match\" }\n }\n-\n-// { dg-prune-output \"compilation terminated\" }"}, {"sha": "9bc96f58979dc4c3c065ef3425d6751e0f67c41c", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-recursive-sat2.C", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79f57d5cb070bb02ea0a34b5f42658d6659b19a8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-recursive-sat2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79f57d5cb070bb02ea0a34b5f42658d6659b19a8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-recursive-sat2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-recursive-sat2.C?ref=79f57d5cb070bb02ea0a34b5f42658d6659b19a8", "patch": "@@ -1,15 +1,13 @@\n // { dg-do compile { target c++20 } }\n \n template<typename T>\n-concept Fooable = requires(T t) { foo(t); }; // { dg-error \"template instantiation depth\" }\n+concept Fooable = requires(T t) { foo(t); }; // { dg-error \"depends on itself\" }\n \n template<Fooable T>\n void foo(T t) { }\n \n void test()\n {\n   struct S {} s;\n-  foo(s);\n+  foo(s); // { dg-error \"no match\" }\n }\n-\n-// { dg-prune-output \"compilation terminated\" }"}, {"sha": "18d126e05ea4cee9cfa74088265c526621bf13fe", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-recursive-sat4.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79f57d5cb070bb02ea0a34b5f42658d6659b19a8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-recursive-sat4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79f57d5cb070bb02ea0a34b5f42658d6659b19a8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-recursive-sat4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-recursive-sat4.C?ref=79f57d5cb070bb02ea0a34b5f42658d6659b19a8", "patch": "@@ -0,0 +1,13 @@\n+// PR c++/96840\n+// { dg-do compile { target c++20 } }\n+\n+template <class T, class U> concept C = requires(T t, U u) { t * u; };\n+// { dg-message \"required for the satisfaction of 'C<T, Rep>' .with T = Int<int>; Rep = int.\" \"\" { target *-*-* } .-1 }\n+// { dg-error \"depends on itself\" \"\" { target *-*-* } .-2 }\n+\n+template <class Rep> struct Int {\n+  template <class T> requires C<T, Rep> friend void operator*(T, Int) { }\n+  template <class T> requires C<T, Rep> friend void operator*(Int, T) { }\n+};\n+\n+void f() { 0 * Int<int>{}; }"}]}