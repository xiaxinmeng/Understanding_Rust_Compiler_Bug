{"sha": "737053d61e42154666df468ddc9caacfd173eaab", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzM3MDUzZDYxZTQyMTU0NjY2ZGY0NjhkZGM5Y2FhY2ZkMTczZWFhYg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2007-04-06T09:41:07Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-04-06T09:41:07Z"}, "message": "utils.c (update_pointer_to): Make a copy of the couple of FIELD_DECLs when...\n\n2007-04-06  Eric Botcazou <botcazou@adacore.com>\n\t    Olivier Hainque  <hainque@adacore.com>\n\n\t* utils.c (update_pointer_to): Make a copy of the couple of FIELD_DECLs\n\twhen updating the contents of the old pointer to an unconstrained array.\n\t(end_subprog_body): Set error_gnat_node to Empty.\n\t(write_record_type_debug_info): Do not be unduly sparing with our bytes.\n\t(unchecked_convert): For subtype to base type conversions, require that\n\tthe source be a subtype if it is an integer type.\n\t(builtin_decls): New global, vector of available builtin functions.\n\t(gnat_pushdecl): Add global builtin function declaration nodes to the\n\tbuiltin_decls list.\n\t(gnat_install_builtins): Adjust comments.\n\t(builtin_function): Set DECL_BUILTIN_CLASS and DECL_FUNCTION_CODE before\n\tcalling gnat_pushdecl, so that it knows when it handed a builtin\n\tfunction declaration node.\n\t(builtin_decl_for): Search the builtin_decls list.\n\nFrom-SVN: r123609", "tree": {"sha": "d5b9f4634beaa53267b817a00ef21437ac8b97f8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d5b9f4634beaa53267b817a00ef21437ac8b97f8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/737053d61e42154666df468ddc9caacfd173eaab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/737053d61e42154666df468ddc9caacfd173eaab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/737053d61e42154666df468ddc9caacfd173eaab", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/737053d61e42154666df468ddc9caacfd173eaab/comments", "author": null, "committer": null, "parents": [{"sha": "3ce5f966ad256483220ae2d3ecbe9b0e1383fabd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ce5f966ad256483220ae2d3ecbe9b0e1383fabd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ce5f966ad256483220ae2d3ecbe9b0e1383fabd"}], "stats": {"total": 210, "additions": 144, "deletions": 66}, "files": [{"sha": "527ac449dd3cf20705639e1bbe283587e860c944", "filename": "gcc/ada/utils.c", "status": "modified", "additions": 144, "deletions": 66, "changes": 210, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/737053d61e42154666df468ddc9caacfd173eaab/gcc%2Fada%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/737053d61e42154666df468ddc9caacfd173eaab/gcc%2Fada%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils.c?ref=737053d61e42154666df468ddc9caacfd173eaab", "patch": "@@ -150,6 +150,9 @@ static GTY((deletable)) struct gnat_binding_level *free_binding_level;\n /* An array of global declarations.  */\n static GTY(()) VEC (tree,gc) *global_decls;\n \n+/* An array of builtin declarations.  */\n+static GTY(()) VEC (tree,gc) *builtin_decls;\n+\n /* An array of global renaming pointers.  */\n static GTY(()) VEC (tree,gc) *global_renaming_pointers;\n \n@@ -441,14 +444,20 @@ gnat_pushdecl (tree decl, Node_Id gnat_node)\n \n   /* Put the declaration on the list.  The list of declarations is in reverse\n      order. The list will be reversed later.  Put global variables in the\n-     globals list. Don't put TYPE_DECLs for UNCONSTRAINED_ARRAY_TYPE into the\n-     list, as they will cause trouble with the debugger and aren't needed\n+     globals list and builtin functions in a dedicated list to speed up\n+     further lookups.  Don't put TYPE_DECLs for UNCONSTRAINED_ARRAY_TYPE into\n+     the list, as they will cause trouble with the debugger and aren't needed\n      anyway.  */\n   if (TREE_CODE (decl) != TYPE_DECL\n       || TREE_CODE (TREE_TYPE (decl)) != UNCONSTRAINED_ARRAY_TYPE)\n     {\n       if (global_bindings_p ())\n-\tVEC_safe_push (tree, gc, global_decls, decl);\n+\t{\n+\t  VEC_safe_push (tree, gc, global_decls, decl);\n+\n+\t  if (TREE_CODE (decl) == FUNCTION_DECL && DECL_BUILT_IN (decl))\n+\t    VEC_safe_push (tree, gc, builtin_decls, decl);\n+\t}\n       else\n \t{\n \t  TREE_CHAIN (decl) = BLOCK_VARS (current_binding_level->block);\n@@ -521,12 +530,12 @@ gnat_init_decl_processing (void)\n   gnat_install_builtins ();\n }\n \n-/* Install the builtin functions the middle-end needs.  */\n+/* Install the builtin functions we might need.  */\n \n static void\n gnat_install_builtins ()\n {\n-  /* Builtins used by generic optimizers.  */\n+  /* Builtins used by generic middle-end optimizers.  */\n   build_common_builtin_nodes ();\n \n   /* Target specific builtins, such as the AltiVec family on ppc.  */\n@@ -1020,7 +1029,30 @@ write_record_type_debug_info (tree record_type)\n \t  if (!pos && TREE_CODE (curpos) == MULT_EXPR\n \t      && TREE_CODE (TREE_OPERAND (curpos, 1)) == INTEGER_CST)\n \t    {\n-\t      align = TREE_INT_CST_LOW (TREE_OPERAND (curpos, 1));\n+\t      /* An offset which is a bit-and operation with a negative\n+\t\t power of 2 means an alignment corresponding to this power\n+\t\t of 2.  */\n+\t      tree offset = TREE_OPERAND (curpos, 0);\n+\n+\t      /* Strip off any conversions.  */\n+\t      while (TREE_CODE (offset) == NON_LVALUE_EXPR\n+\t\t     || TREE_CODE (offset) == NOP_EXPR\n+\t\t     || TREE_CODE (offset) == CONVERT_EXPR)\n+\t\toffset = TREE_OPERAND (offset, 0);\n+\n+\t      if (TREE_CODE (offset) == BIT_AND_EXPR)\n+\t\t{\n+\t\t  int p = exact_log2\n+\t\t    (- TREE_INT_CST_LOW (TREE_OPERAND (offset, 1)));\n+\n+\t\t  if (p < 0)\n+\t\t    p = 1;\n+\n+\t\t  align = p * TREE_INT_CST_LOW (TREE_OPERAND (curpos, 1));\n+\t\t}\n+\t      else\n+\t\talign = TREE_INT_CST_LOW (TREE_OPERAND (curpos, 1));\n+\n \t      pos = compute_related_constant (curpos,\n \t\t\t\t\t      round_up (last_pos, align));\n \t    }\n@@ -1061,16 +1093,10 @@ write_record_type_debug_info (tree record_type)\n \t      var = true;\n \t    }\n \n-\t  /* The heuristics above might get the alignment wrong.\n-\t     Adjust the obvious case where align is smaller than the\n-\t     alignments necessary for objects of field_type. */\n-\t  if (align < TYPE_ALIGN(field_type))\n-\t    align = TYPE_ALIGN(field_type);\n-\n \t  /* Make a new field name, if necessary.  */\n \t  if (var || align != 0)\n \t    {\n-\t      char suffix[6];\n+\t      char suffix[16];\n \n \t      if (align != 0)\n \t\tsprintf (suffix, \"XV%c%u\", var ? 'L' : 'A',\n@@ -1103,10 +1129,10 @@ write_record_type_debug_info (tree record_type)\n       TYPE_FIELDS (new_record_type)\n \t= nreverse (TYPE_FIELDS (new_record_type));\n \n-      rest_of_type_compilation (new_record_type, global_bindings_p ());\n+      rest_of_type_compilation (new_record_type, true);\n     }\n \n-  rest_of_type_compilation (record_type, global_bindings_p ());\n+  rest_of_type_compilation (record_type, true);\n }\n \n /* Utility function of above to merge LAST_SIZE, the previous size of a record\n@@ -2098,6 +2124,9 @@ end_subprog_body (tree body)\n   current_function_decl = DECL_CONTEXT (fndecl);\n   cfun = NULL;\n \n+  /* We cannot track the location of errors past this point.  */\n+  error_gnat_node = Empty;\n+\n   /* If we're only annotating types, don't actually compile this function.  */\n   if (type_annotate_only)\n     return;\n@@ -2924,43 +2953,44 @@ update_pointer_to (tree old_type, tree new_type)\n   else\n     {\n       tree new_obj_rec = TYPE_OBJECT_RECORD_TYPE (new_type);\n-      tree ptr_temp_type;\n-      tree new_ref;\n-      tree var;\n+      tree fields = TYPE_FIELDS (TYPE_POINTER_TO (new_type));\n+      tree new_fields, ptr_temp_type, new_ref, bounds, var;\n \n-      SET_DECL_ORIGINAL_FIELD (TYPE_FIELDS (ptr),\n-\t\t\t       TYPE_FIELDS (TYPE_POINTER_TO (new_type)));\n+      /* Replace contents of old pointer with those of new pointer.  */\n+      new_fields = copy_node (fields);\n+      TREE_CHAIN (new_fields) = copy_node (TREE_CHAIN (fields));\n+\n+      SET_DECL_ORIGINAL_FIELD (TYPE_FIELDS (ptr), new_fields);\n       SET_DECL_ORIGINAL_FIELD (TREE_CHAIN (TYPE_FIELDS (ptr)),\n-\t\t\t       TREE_CHAIN (TYPE_FIELDS\n-\t\t\t\t\t   (TYPE_POINTER_TO (new_type))));\n+\t\t\t       TREE_CHAIN (new_fields));\n \n-      TYPE_FIELDS (ptr) = TYPE_FIELDS (TYPE_POINTER_TO (new_type));\n-      DECL_CONTEXT (TYPE_FIELDS (ptr)) = ptr;\n-      DECL_CONTEXT (TREE_CHAIN (TYPE_FIELDS (ptr))) = ptr;\n+      TYPE_FIELDS (ptr) = new_fields;\n+      DECL_CONTEXT (new_fields) = ptr;\n+      DECL_CONTEXT (TREE_CHAIN (new_fields)) = ptr;\n \n-      /* Rework the PLACEHOLDER_EXPR inside the reference to the\n-\t template bounds.\n+      /* Rework the PLACEHOLDER_EXPR inside the reference to the template\n+\t bounds and update the pointers to them.\n \n \t ??? This is now the only use of gnat_substitute_in_type, which\n \t is now a very \"heavy\" routine to do this, so it should be replaced\n \t at some point.  */\n-      ptr_temp_type = TREE_TYPE (TREE_CHAIN (TYPE_FIELDS (ptr)));\n+      bounds = TREE_TYPE (TREE_TYPE (new_fields));\n+      ptr_temp_type = TREE_TYPE (TREE_CHAIN (new_fields));\n       new_ref = build3 (COMPONENT_REF, ptr_temp_type,\n \t\t\tbuild0 (PLACEHOLDER_EXPR, ptr),\n-\t\t\tTREE_CHAIN (TYPE_FIELDS (ptr)), NULL_TREE);\n-\n-      update_pointer_to\n-\t(TREE_TYPE (TREE_TYPE (TYPE_FIELDS (ptr))),\n-\t gnat_substitute_in_type (TREE_TYPE (TREE_TYPE (TYPE_FIELDS (ptr))),\n-\t\t\t\t  TREE_CHAIN (TYPE_FIELDS (ptr)), new_ref));\n+\t\t\tTREE_CHAIN (new_fields), NULL_TREE);\n+      update_pointer_to (bounds,\n+\t\t\t gnat_substitute_in_type (bounds,\n+\t\t\t\t\t\t  TREE_CHAIN (fields),\n+\t\t\t\t\t\t  new_ref));\n \n       for (var = TYPE_MAIN_VARIANT (ptr); var; var = TYPE_NEXT_VARIANT (var))\n \t{\n \t  SET_TYPE_UNCONSTRAINED_ARRAY (var, new_type);\n \n \t  /* This may seem a bit gross, in particular wrt DECL_CONTEXT, but\n \t     actually is in keeping with what build_qualified_type does.  */\n-\t  TYPE_FIELDS (var) = TYPE_FIELDS (ptr);\n+\t  TYPE_FIELDS (var) = new_fields;\n \t}\n \n       TYPE_POINTER_TO (new_type) = TYPE_REFERENCE_TO (new_type)\n@@ -2974,11 +3004,11 @@ update_pointer_to (tree old_type, tree new_type)\n \n       TREE_TYPE (TYPE_FIELDS (new_obj_rec)) = TREE_TYPE (ptr_temp_type);\n       TREE_TYPE (TREE_CHAIN (TYPE_FIELDS (new_obj_rec)))\n-\t= TREE_TYPE (TREE_TYPE (TYPE_FIELDS (ptr)));\n+\t= TREE_TYPE (TREE_TYPE (new_fields));\n       DECL_SIZE (TREE_CHAIN (TYPE_FIELDS (new_obj_rec)))\n-\t= TYPE_SIZE (TREE_TYPE (TREE_TYPE (TYPE_FIELDS (ptr))));\n+\t= TYPE_SIZE (TREE_TYPE (TREE_TYPE (new_fields)));\n       DECL_SIZE_UNIT (TREE_CHAIN (TYPE_FIELDS (new_obj_rec)))\n-\t= TYPE_SIZE_UNIT (TREE_TYPE (TREE_TYPE (TYPE_FIELDS (ptr))));\n+\t= TYPE_SIZE_UNIT (TREE_TYPE (TREE_TYPE (new_fields)));\n \n       TYPE_SIZE (new_obj_rec)\n \t= size_binop (PLUS_EXPR,\n@@ -3096,29 +3126,18 @@ convert (tree type, tree expr)\n   if (type == etype)\n     return expr;\n \n-  /* If the input type has padding, remove it by doing a component reference\n-     to the field.  If the output type has padding, make a constructor\n-     to build the record.  If both input and output have padding and are\n-     of variable size, do this as an unchecked conversion.  */\n+  /* If both input and output have padding and are of variable size, do this\n+     as an unchecked conversion.  Likewise if one is a mere variant of the\n+     other, so we avoid a pointless unpad/repad sequence.  */\n   else if (ecode == RECORD_TYPE && code == RECORD_TYPE\n-      && TYPE_IS_PADDING_P (type) && TYPE_IS_PADDING_P (etype)\n-      && (!TREE_CONSTANT (TYPE_SIZE (type))\n-\t  || !TREE_CONSTANT (TYPE_SIZE (etype))))\n+\t   && TYPE_IS_PADDING_P (type) && TYPE_IS_PADDING_P (etype)\n+\t   && (!TREE_CONSTANT (TYPE_SIZE (type))\n+\t       || !TREE_CONSTANT (TYPE_SIZE (etype))\n+\t       || TYPE_MAIN_VARIANT (type) == TYPE_MAIN_VARIANT (etype)))\n     ;\n-  else if (ecode == RECORD_TYPE && TYPE_IS_PADDING_P (etype))\n-    {\n-      /* If we have just converted to this padded type, just get\n-\t the inner expression.  */\n-      if (TREE_CODE (expr) == CONSTRUCTOR\n-\t  && !VEC_empty (constructor_elt, CONSTRUCTOR_ELTS (expr))\n-\t  && VEC_index (constructor_elt, CONSTRUCTOR_ELTS (expr), 0)->index\n-\t     == TYPE_FIELDS (etype))\n-\treturn VEC_index (constructor_elt, CONSTRUCTOR_ELTS (expr), 0)->value;\n-      else\n-\treturn convert (type,\n-\t\t\tbuild_component_ref (expr, NULL_TREE,\n-\t\t\t\t\t     TYPE_FIELDS (etype), false));\n-    }\n+\n+  /* If the output type has padding, make a constructor to build the\n+     record.  */\n   else if (code == RECORD_TYPE && TYPE_IS_PADDING_P (type))\n     {\n       /* If we previously converted from another type and our type is\n@@ -3154,6 +3173,31 @@ convert (tree type, tree expr)\n \t\t\t\t\tNULL_TREE));\n     }\n \n+  /* If the input type has padding, remove it and convert to the output type.\n+     The conditions ordering is arranged to ensure that the output type is not\n+     a padding type here, as it is not clear whether the conversion would\n+     always be correct if this was to happen.  */\n+  else if (ecode == RECORD_TYPE && TYPE_IS_PADDING_P (etype))\n+    {\n+      tree unpadded;\n+\n+      /* If we have just converted to this padded type, just get the\n+\t inner expression.  */\n+      if (TREE_CODE (expr) == CONSTRUCTOR\n+\t  && !VEC_empty (constructor_elt, CONSTRUCTOR_ELTS (expr))\n+\t  && VEC_index (constructor_elt, CONSTRUCTOR_ELTS (expr), 0)->index\n+\t     == TYPE_FIELDS (etype))\n+\tunpadded\n+\t  = VEC_index (constructor_elt, CONSTRUCTOR_ELTS (expr), 0)->value;\n+\n+      /* Otherwise, build an explicit component reference.  */\n+      else\n+\tunpadded\n+\t  = build_component_ref (expr, NULL_TREE, TYPE_FIELDS (etype), false);\n+\n+      return convert (type, unpadded);\n+    }\n+\n   /* If the input is a biased type, adjust first.  */\n   if (ecode == INTEGER_TYPE && TYPE_BIASED_REPRESENTATION_P (etype))\n     return convert (type, fold_build2 (PLUS_EXPR, TREE_TYPE (etype),\n@@ -3549,6 +3593,7 @@ unchecked_convert (tree type, tree expr, bool notrunc_p)\n       || TREE_CODE (type) == UNCONSTRAINED_ARRAY_TYPE)\n     {\n       tree rtype = type;\n+      bool final_unchecked = false;\n \n       if (TREE_CODE (etype) == INTEGER_TYPE\n \t  && TYPE_BIASED_REPRESENTATION_P (etype))\n@@ -3568,9 +3613,37 @@ unchecked_convert (tree type, tree expr, bool notrunc_p)\n \t  TYPE_MAIN_VARIANT (rtype) = rtype;\n \t}\n \n+      /* We have another special case.  If we are unchecked converting subtype\n+\t into a base type, we need to ensure that VRP doesn't propagate range\n+\t information since this conversion may be done precisely to validate\n+\t that the object is within the range it is supposed to have.  */\n+      else if (TREE_CODE (type) == INTEGER_TYPE && !TREE_TYPE (type)\n+\t       && ((TREE_CODE (etype) == INTEGER_TYPE && TREE_TYPE (etype))\n+\t\t   || TREE_CODE (etype) == ENUMERAL_TYPE\n+\t\t   || TREE_CODE (etype) == BOOLEAN_TYPE))\n+\t{\n+\t  /* ??? The pattern to be \"preserved\" by the middle-end and the\n+\t     optimizers is a VIEW_CONVERT_EXPR between a pair of different\n+\t     \"base\" types (integer types without TREE_TYPE).  But this may\n+\t     raise addressability/aliasing issues because VIEW_CONVERT_EXPR\n+\t     gets gimplified as an lvalue, thus causing the address of its\n+\t     operand to be taken if it is deemed addressable and not already\n+\t     in GIMPLE form.  */\n+\t  rtype = gnat_type_for_mode (TYPE_MODE (type), TYPE_UNSIGNED (type));\n+\n+\t  if (rtype == type)\n+\t    {\n+\t      rtype = copy_type (rtype);\n+\t      TYPE_MAIN_VARIANT (rtype) = rtype;\n+\t    }\n+\n+\t  final_unchecked = true;\n+\t}\n+\n       expr = convert (rtype, expr);\n       if (type != rtype)\n-\texpr = build1 (NOP_EXPR, type, expr);\n+\texpr = build1 (final_unchecked ? VIEW_CONVERT_EXPR : NOP_EXPR,\n+\t\t       type, expr);\n     }\n \n   /* If we are converting TO an integral type whose precision is not the\n@@ -3684,14 +3757,19 @@ unchecked_convert (tree type, tree expr, bool notrunc_p)\n   return expr;\n }\n \f\n-/* Search the chain of currently reachable declarations for a builtin\n-   FUNCTION_DECL node corresponding to function NAME (an IDENTIFIER_NODE).\n-   Return the first node found, if any, or NULL_TREE otherwise.  */\n+/* Search the chain of currently available builtin declarations for a node\n+   corresponding to function NAME (an IDENTIFIER_NODE).  Return the first node\n+   found, if any, or NULL_TREE otherwise.  */\n tree\n-builtin_decl_for (tree name __attribute__ ((unused)))\n+builtin_decl_for (tree name)\n {\n-  /* ??? not clear yet how to implement this function in tree-ssa, so\n-     return NULL_TREE for now */\n+  unsigned i;\n+  tree decl;\n+\n+  for (i = 0; VEC_iterate(tree, builtin_decls, i, decl); i++)\n+    if (DECL_NAME (decl) == name)\n+      return decl;\n+\n   return NULL_TREE;\n }\n "}]}