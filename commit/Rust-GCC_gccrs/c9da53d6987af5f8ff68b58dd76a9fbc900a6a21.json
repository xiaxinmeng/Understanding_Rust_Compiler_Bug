{"sha": "c9da53d6987af5f8ff68b58dd76a9fbc900a6a21", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzlkYTUzZDY5ODdhZjVmOGZmNjhiNThkZDc2YTlmYmM5MDBhNmEyMQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2020-09-24T06:28:09Z"}, "committer": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2020-09-24T06:28:09Z"}, "message": "Fix memory allocations in ipa-modref.\n\nPair ggc_delete with ggc_alloc_no_dtor.  I copy same scheme as used by Martin\nin ipa-fnsummary, that is creating a static member function create_ggc hidding\nthe ugly bits and using it in ipa-modref.c.\n\nI also noticed that modref-tree leaks memory on destruction/collapse method and\nfixed that.\n\nBootstrapped/regtested x86_64-linux.\n\ngcc/ChangeLog:\n\n2020-09-24  Jan Hubicka  <hubicka@ucw.cz>\n\n\t* ipa-modref-tree.h (modref_base::collapse): Release memory.\n\t(modref_tree::create_ggc): New member function.\n\t(modref_tree::colapse): Release memory.\n\t(modref_tree::~modref_tree): New destructor.\n\t* ipa-modref.c (modref_summaries::create_ggc): New function.\n\t(analyze_function): Use create_ggc.\n\t(modref_summaries::duplicate): Likewise.\n\t(read_modref_records): Likewise.\n\t(modref_read): Likewise.", "tree": {"sha": "e0bed9ee6fe0d60237cdb71cbae19944289b800a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e0bed9ee6fe0d60237cdb71cbae19944289b800a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c9da53d6987af5f8ff68b58dd76a9fbc900a6a21", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9da53d6987af5f8ff68b58dd76a9fbc900a6a21", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c9da53d6987af5f8ff68b58dd76a9fbc900a6a21", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9da53d6987af5f8ff68b58dd76a9fbc900a6a21/comments", "author": null, "committer": null, "parents": [{"sha": "2d5fb576bdda843da47aea2e025bb5d45e883827", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d5fb576bdda843da47aea2e025bb5d45e883827", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2d5fb576bdda843da47aea2e025bb5d45e883827"}], "stats": {"total": 107, "additions": 65, "deletions": 42}, "files": [{"sha": "82e959a7d46590c3cc273a49a8000a1a6492b6ff", "filename": "gcc/ipa-modref-tree.h", "status": "modified", "additions": 34, "deletions": 2, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9da53d6987af5f8ff68b58dd76a9fbc900a6a21/gcc%2Fipa-modref-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9da53d6987af5f8ff68b58dd76a9fbc900a6a21/gcc%2Fipa-modref-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref-tree.h?ref=c9da53d6987af5f8ff68b58dd76a9fbc900a6a21", "patch": "@@ -95,7 +95,15 @@ struct GTY((user)) modref_base_node\n \n   void collapse ()\n   {\n-    vec_free (refs);\n+    size_t i;\n+    modref_ref_node <T> *r;\n+\n+    if (refs)\n+      {\n+\tFOR_EACH_VEC_SAFE_ELT (refs, i, r)\n+\t  ggc_free (r);\n+\tvec_free (refs);\n+      }\n     refs = NULL;\n     every_ref = true;\n   }\n@@ -214,12 +222,36 @@ struct GTY((user)) modref_tree\n     return NULL;\n   }\n \n+  /* Return ggc allocated instance.  We explicitly call destructors via\n+     ggc_delete and do not want finalizers to be registered and\n+     called at the garbage collection time.  */\n+  static modref_tree<T> *create_ggc (size_t max_bases, size_t max_refs)\n+  {\n+    return new (ggc_alloc_no_dtor<modref_tree<T>> ())\n+\t modref_tree<T> (max_bases, max_refs);\n+  }\n+\n   void collapse ()\n   {\n-    vec_free (bases);\n+    size_t i;\n+    modref_base_node <T> *n;\n+\n+    if (bases)\n+      {\n+\tFOR_EACH_VEC_SAFE_ELT (bases, i, n)\n+\t  {\n+\t    n->collapse ();\n+\t    ggc_free (n);\n+\t  }\n+\tvec_free (bases);\n+      }\n     bases = NULL;\n     every_base = true;\n   }\n+  ~modref_tree ()\n+  {\n+    collapse ();\n+  }\n };\n \n void modref_c_tests ();"}, {"sha": "43545c1fb09b5d2de360463cd2904b2086943099", "filename": "gcc/ipa-modref.c", "status": "modified", "additions": 31, "deletions": 40, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9da53d6987af5f8ff68b58dd76a9fbc900a6a21/gcc%2Fipa-modref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9da53d6987af5f8ff68b58dd76a9fbc900a6a21/gcc%2Fipa-modref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref.c?ref=c9da53d6987af5f8ff68b58dd76a9fbc900a6a21", "patch": "@@ -84,6 +84,11 @@ class GTY((user)) modref_summaries\n      ipa-modref pass execution needs to be analyzed in IPA mode while all\n      other insertions leads to normal analysis.  */\n   bool ipa;\n+  static modref_summaries *create_ggc (symbol_table *symtab)\n+  {\n+    return new (ggc_alloc_no_dtor<modref_summaries> ())\n+\t     modref_summaries (symtab);\n+  }\n };\n \n /* Global variable holding all modref summaries.  */\n@@ -608,8 +613,7 @@ analyze_function (function *f, bool ipa)\n \n   /* Initialize the summary.  */\n   if (!summaries)\n-    summaries = new (ggc_alloc <modref_summaries> ())\n-\t\t     modref_summaries (symtab);\n+    summaries = modref_summaries::create_ggc (symtab);\n   else /* Remove existing summary if we are re-running the pass.  */\n     summaries->remove (cgraph_node::get (f->decl));\n \n@@ -633,28 +637,22 @@ analyze_function (function *f, bool ipa)\n   if (nolto)\n     {\n       gcc_assert (!summary->loads);\n-      summary->loads\n-\t = new (ggc_alloc <modref_tree<alias_set_type> > ())\n-\t\tmodref_records (param_modref_max_bases,\n-\t\t\t\tparam_modref_max_refs);\n+      summary->loads = modref_records::create_ggc (param_modref_max_bases,\n+\t\t\t\t\t\t   param_modref_max_refs);\n       gcc_assert (!summary->stores);\n-      summary->stores\n-\t = new (ggc_alloc <modref_tree<alias_set_type> > ())\n-\t\tmodref_records (param_modref_max_bases,\n-\t\t\t\tparam_modref_max_refs);\n+      summary->stores = modref_records::create_ggc (param_modref_max_bases,\n+\t\t\t\t\t\t    param_modref_max_refs);\n     }\n   if (lto)\n     {\n       gcc_assert (!summary->loads_lto);\n-      summary->loads_lto\n-\t = new (ggc_alloc <modref_tree<tree> > ())\n-\t\tmodref_records_lto (param_modref_max_bases,\n-\t\t\t\t    param_modref_max_refs);\n+      summary->loads_lto = modref_records_lto::create_ggc\n+\t\t\t\t (param_modref_max_bases,\n+\t\t\t\t  param_modref_max_refs);\n       gcc_assert (!summary->stores_lto);\n-      summary->stores_lto\n-\t = new (ggc_alloc <modref_tree<tree> > ())\n-\t\tmodref_records_lto (param_modref_max_bases,\n-\t\t\t\t    param_modref_max_refs);\n+      summary->stores_lto = modref_records_lto::create_ggc\n+\t\t\t\t (param_modref_max_bases,\n+\t\t\t\t  param_modref_max_refs);\n     }\n   summary->finished = false;\n   int ecf_flags = flags_from_decl_or_type (current_function_decl);\n@@ -730,34 +728,30 @@ modref_summaries::duplicate (cgraph_node *, cgraph_node *,\n   dst_data->finished = src_data->finished;\n   if (src_data->stores)\n     {\n-      dst_data->stores = new (ggc_alloc <modref_tree<alias_set_type> > ())\n-\t\t\t      modref_records\n-\t\t\t\t (src_data->stores->max_bases,\n-\t\t\t\t  src_data->stores->max_refs);\n+      dst_data->stores = modref_records::create_ggc\n+\t\t\t    (src_data->stores->max_bases,\n+\t\t\t     src_data->stores->max_refs);\n       dst_data->stores->merge (src_data->stores);\n     }\n   if (src_data->loads)\n     {\n-      dst_data->loads = new (ggc_alloc <modref_tree<alias_set_type> > ())\n-\t\t\t     modref_records\n-\t\t\t\t(src_data->loads->max_bases,\n-\t\t\t\t src_data->loads->max_refs);\n+      dst_data->loads = modref_records::create_ggc\n+\t\t\t    (src_data->loads->max_bases,\n+\t\t\t     src_data->loads->max_refs);\n       dst_data->loads->merge (src_data->loads);\n     }\n   if (src_data->stores_lto)\n     {\n-      dst_data->stores_lto = new (ggc_alloc <modref_tree<tree> > ())\n-\t\t\t\t  modref_records_lto\n-\t\t\t\t    (src_data->stores_lto->max_bases,\n-\t\t\t\t     src_data->stores_lto->max_refs);\n+      dst_data->stores_lto = modref_records_lto::create_ggc\n+\t\t\t    (src_data->stores_lto->max_bases,\n+\t\t\t     src_data->stores_lto->max_refs);\n       dst_data->stores_lto->merge (src_data->stores_lto);\n     }\n   if (src_data->loads_lto)\n     {\n-      dst_data->loads_lto = new (ggc_alloc <modref_tree<tree> > ())\n-\t\t\t\t  modref_records_lto\n-\t\t\t\t    (src_data->stores_lto->max_bases,\n-\t\t\t\t     src_data->stores_lto->max_refs);\n+      dst_data->loads_lto = modref_records_lto::create_ggc\n+\t\t\t    (src_data->loads_lto->max_bases,\n+\t\t\t     src_data->loads_lto->max_refs);\n       dst_data->loads_lto->merge (src_data->loads_lto);\n     }\n }\n@@ -838,11 +832,9 @@ read_modref_records (lto_input_block *ib, struct data_in *data_in,\n   /* Decide whether we want to turn LTO data types to non-LTO (i.e. when\n      LTO re-streaming is not going to happen).  */\n   if (flag_wpa || flag_incremental_link == INCREMENTAL_LINK_LTO)\n-    *lto_ret = new (ggc_alloc <modref_records_lto> ()) modref_records_lto\n-\t\t\t      (max_bases, max_refs);\n+    *lto_ret = modref_records_lto::create_ggc (max_bases, max_refs);\n   else\n-    *nolto_ret = new (ggc_alloc <modref_records> ()) modref_records\n-\t\t\t      (max_bases, max_refs);\n+    *nolto_ret = modref_records::create_ggc (max_bases, max_refs);\n \n   size_t every_base = streamer_read_uhwi (ib);\n   size_t nbase = streamer_read_uhwi (ib);\n@@ -1048,8 +1040,7 @@ modref_read (void)\n   unsigned int j = 0;\n \n   if (!summaries)\n-    summaries = new (ggc_alloc <modref_summaries> ())\n-\t\t     modref_summaries (symtab);\n+    summaries = modref_summaries::create_ggc (symtab);\n   ((modref_summaries *)summaries)->ipa = true;\n \n   while ((file_data = file_data_vec[j++]))"}]}