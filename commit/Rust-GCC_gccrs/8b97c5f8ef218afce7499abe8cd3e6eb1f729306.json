{"sha": "8b97c5f8ef218afce7499abe8cd3e6eb1f729306", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGI5N2M1ZjhlZjIxOGFmY2U3NDk5YWJlOGNkM2U2ZWIxZjcyOTMwNg==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@wolery.cumb.org", "date": "2000-09-07T22:24:34Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2000-09-07T22:24:34Z"}, "message": "c-pragma.h: Define HANDLE_GENERIC_PRAGMAS if REGISTER_TARGET_PRAGMAS is defined.\n\n\t* c-pragma.h: Define HANDLE_GENERIC_PRAGMAS if\n\tREGISTER_TARGET_PRAGMAS is defined.  Duplicate some\n\tdefinitions from cpplib.h.\n\t* cpplib.h: Don't typedef struct cpp_reader if c-pragma.h has\n\talready done it.\n\t* tm.texi: Document HANDLE_PRAGMA as no longer supported.  Add\n\tdocumentation for REGISTER_TARGET_PRAGMAS.\n\n\t* c-lex.c: Include cpplib.h before c-pragma.h.  Define a\n\tdefault-pragma callback to implement -Wunknown-pragmas if\n\tUSE_CPPLIB.\n\t* c-parse.in: Move all includes to top of file.\n\t* c-pragma.c: Include cpplib.h before c-pragma.h.  Include\n\ttm_p.h.\n\t(dispatch_pragma): Put the namespace in the -Wunknown-pragmas\n\twarning.\n\t(init_pragma): If REGISTER_TARGET_PRAGMAS is defined, call it.\n\n\t* arm.h, arm-protos.h, arm.c,\n\t  c4x.h, c4x-protos.h, c4x.c,\n\t  h8300.h, h8300-protos.h, h8300.c,\n\t  i370.h, i370-protos.h, i370.c,\n\t  i960.h, i960-protos.h, i960.c,\n\t  sh.h, sh-protos.h, sh.c,\n\t  v850.h, v850-protos.h, v850.c: Convert HANDLE_PRAGMA-based\n\tpragmata scheme to use REGISTER_TARGET_PRAGMAS instead.\n\n\t* d30v.h: Don't mention HANDLE_PRAGMA in comment.  Add\n\tmultiple include guard.\n\t* i370.md (untyped_call): Use GEN_CALL.\n\t(umodsi3): Remove unused variable.\n\t* sh/elf.h: Don't undef HANDLE_SYSV_PRAGMA.\n\t* v850.c (output_move_single, output_move_double): Constify\n\treturn value.\n\t(print_operand): Constify a char *.\n\t* v850.h (struct small_memory_info): Constify name member.\n\nFrom-SVN: r36249", "tree": {"sha": "a9b9cd034b9b3c1cc173cb5e609c95a9d4411d72", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a9b9cd034b9b3c1cc173cb5e609c95a9d4411d72"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8b97c5f8ef218afce7499abe8cd3e6eb1f729306", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b97c5f8ef218afce7499abe8cd3e6eb1f729306", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b97c5f8ef218afce7499abe8cd3e6eb1f729306", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b97c5f8ef218afce7499abe8cd3e6eb1f729306/comments", "author": null, "committer": null, "parents": [{"sha": "1898584f04c8d512f9ed50de977cc266fc2a3b15", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1898584f04c8d512f9ed50de977cc266fc2a3b15", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1898584f04c8d512f9ed50de977cc266fc2a3b15"}], "stats": {"total": 1384, "additions": 704, "deletions": 680}, "files": [{"sha": "628f6c78e9fc338aa6c8a9997c3c89278e557772", "filename": "gcc/ChangeLog", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b97c5f8ef218afce7499abe8cd3e6eb1f729306/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b97c5f8ef218afce7499abe8cd3e6eb1f729306/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8b97c5f8ef218afce7499abe8cd3e6eb1f729306", "patch": "@@ -1,3 +1,42 @@\n+2000-09-07  Zack Weinberg  <zack@wolery.cumb.org>\n+\n+\t* c-pragma.h: Define HANDLE_GENERIC_PRAGMAS if\n+\tREGISTER_TARGET_PRAGMAS is defined.  Duplicate some\n+\tdefinitions from cpplib.h.\n+\t* cpplib.h: Don't typedef struct cpp_reader if c-pragma.h has\n+\talready done it.\n+\t* tm.texi: Document HANDLE_PRAGMA as no longer supported.  Add\n+\tdocumentation for REGISTER_TARGET_PRAGMAS.\n+\n+\t* c-lex.c: Include cpplib.h before c-pragma.h.  Define a\n+\tdefault-pragma callback to implement -Wunknown-pragmas if\n+\tUSE_CPPLIB.\n+\t* c-parse.in: Move all includes to top of file.\n+\t* c-pragma.c: Include cpplib.h before c-pragma.h.  Include\n+\ttm_p.h.\n+\t(dispatch_pragma): Put the namespace in the -Wunknown-pragmas\n+\twarning.\n+\t(init_pragma): If REGISTER_TARGET_PRAGMAS is defined, call it.\n+\n+\t* arm.h, arm-protos.h, arm.c,\n+\t  c4x.h, c4x-protos.h, c4x.c,\n+\t  h8300.h, h8300-protos.h, h8300.c,\n+\t  i370.h, i370-protos.h, i370.c,\n+\t  i960.h, i960-protos.h, i960.c,\n+\t  sh.h, sh-protos.h, sh.c, \n+\t  v850.h, v850-protos.h, v850.c: Convert HANDLE_PRAGMA-based\n+\tpragmata scheme to use REGISTER_TARGET_PRAGMAS instead.\n+\n+\t* d30v.h: Don't mention HANDLE_PRAGMA in comment.  Add\n+\tmultiple include guard.\n+\t* i370.md (untyped_call): Use GEN_CALL.\n+\t(umodsi3): Remove unused variable.\n+\t* sh/elf.h: Don't undef HANDLE_SYSV_PRAGMA.\n+\t* v850.c (output_move_single, output_move_double): Constify\n+\treturn value.\n+\t(print_operand): Constify a char *.\n+\t* v850.h (struct small_memory_info): Constify name member.\n+\n 2000-09-07  Kazu Hirata  <kazu@hxi.com>\n \n \t* config/h8300.h: Fix comment typos."}, {"sha": "63ae9ba6676643429f757958552ee91de661e753", "filename": "gcc/c-lex.c", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b97c5f8ef218afce7499abe8cd3e6eb1f729306/gcc%2Fc-lex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b97c5f8ef218afce7499abe8cd3e6eb1f729306/gcc%2Fc-lex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lex.c?ref=8b97c5f8ef218afce7499abe8cd3e6eb1f729306", "patch": "@@ -30,6 +30,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"c-tree.h\"\n #include \"flags.h\"\n #include \"timevar.h\"\n+#include \"cpplib.h\"\n #include \"c-pragma.h\"\n #include \"toplev.h\"\n #include \"intl.h\"\n@@ -52,8 +53,6 @@ Boston, MA 02111-1307, USA.  */\n #define GET_ENVIRONMENT(ENV_VALUE,ENV_NAME) ((ENV_VALUE) = getenv (ENV_NAME))\n #endif\n \n-#include \"cpplib.h\"\n-\n #if USE_CPPLIB\n extern cpp_reader  parse_in;\n #else\n@@ -162,6 +161,7 @@ static void cb_ident\t\tPARAMS ((cpp_reader *, const unsigned char *,\n static void cb_enter_file\tPARAMS ((cpp_reader *));\n static void cb_leave_file\tPARAMS ((cpp_reader *));\n static void cb_rename_file\tPARAMS ((cpp_reader *));\n+static void cb_def_pragma\tPARAMS ((cpp_reader *));\n #endif\n \n \f\n@@ -210,6 +210,7 @@ init_c_lex (filename)\n   parse_in.cb.enter_file = cb_enter_file;\n   parse_in.cb.leave_file = cb_leave_file;\n   parse_in.cb.rename_file = cb_rename_file;\n+  parse_in.cb.def_pragma = cb_def_pragma;\n \n   /* Make sure parse_in.digraphs matches flag_digraphs.  */\n   CPP_OPTION (&parse_in, digraphs) = flag_digraphs;\n@@ -777,6 +778,27 @@ cb_rename_file (pfile)\n   /* Hook for C++.  */\n   extract_interface_info ();\n }\n+\n+static void\n+cb_def_pragma (pfile)\n+     cpp_reader *pfile;\n+{\n+  /* Issue a warning message if we have been asked to do so.  Ignore\n+     unknown pragmas in system headers unless an explicit\n+     -Wunknown-pragmas has been given. */\n+  if (warn_unknown_pragmas > in_system_header)\n+    {\n+      const unsigned char *space, *name;\n+      const cpp_token *t = pfile->first_directive_token + 2;\n+\n+      space = t[0].val.node->name;\n+      name  = t[1].type == CPP_NAME ? t[1].val.node->name : 0;\n+      if (name)\n+\twarning (\"ignoring #pragma %s %s\", space, name);\n+      else\n+\twarning (\"ignoring #pragma %s\", space);\n+    }\n+}\n #endif /* USE_CPPLIB */\n \n /* Parse a '\\uNNNN' or '\\UNNNNNNNN' sequence."}, {"sha": "5ef738672f77f5c29a82b43e4fc08ed2ea06b3e2", "filename": "gcc/c-parse.in", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b97c5f8ef218afce7499abe8cd3e6eb1f729306/gcc%2Fc-parse.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b97c5f8ef218afce7499abe8cd3e6eb1f729306/gcc%2Fc-parse.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parse.in?ref=8b97c5f8ef218afce7499abe8cd3e6eb1f729306", "patch": "@@ -41,6 +41,9 @@ end ifc\n #include <setjmp.h>\n #include \"tree.h\"\n #include \"input.h\"\n+#include \"cpplib.h\"\n+#include \"intl.h\"\n+#include \"timevar.h\"\n #include \"c-lex.h\"\n #include \"c-tree.h\"\n #include \"c-pragma.h\"\n@@ -2797,9 +2800,6 @@ end ifobjc\n \n /* yylex() is a thin wrapper around c_lex(), all it does is translate\n    cpplib.h's token codes into yacc's token codes.  */\n-#include \"cpplib.h\"\n-#include \"intl.h\"\n-#include \"timevar.h\"\n \n static enum cpp_ttype last_token;\n #if USE_CPPLIB"}, {"sha": "820720d9706ff8ecc3f011cde79c2d82917feb57", "filename": "gcc/c-pragma.c", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b97c5f8ef218afce7499abe8cd3e6eb1f729306/gcc%2Fc-pragma.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b97c5f8ef218afce7499abe8cd3e6eb1f729306/gcc%2Fc-pragma.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pragma.c?ref=8b97c5f8ef218afce7499abe8cd3e6eb1f729306", "patch": "@@ -24,12 +24,13 @@ Boston, MA 02111-1307, USA.  */\n #include \"tree.h\"\n #include \"function.h\"\n #include \"defaults.h\"\n+#include \"cpplib.h\"\n #include \"c-pragma.h\"\n #include \"flags.h\"\n #include \"toplev.h\"\n #include \"ggc.h\"\n #include \"c-lex.h\"\n-#include \"cpplib.h\"\n+#include \"tm_p.h\"\n \n #ifdef HANDLE_GENERIC_PRAGMAS\n \n@@ -383,7 +384,7 @@ dispatch_pragma ()\n   enum cpp_ttype t;\n   tree x;\n   const struct pragma_entry *p;\n-  const char *name;\n+  const char *name, *space = 0;\n   size_t len;\n \n   p = pragmas;\n@@ -407,6 +408,7 @@ dispatch_pragma ()\n \t{\n \t  if (p->isnspace)\n \t    {\n+\t      space = p->name;\n \t      p = p->u.space;\n \t      goto new_space;\n \t    }\n@@ -420,10 +422,15 @@ dispatch_pragma ()\n     }\n \n   /* Issue a warning message if we have been asked to do so.  Ignore\n-     unknown pragmas in system header file unless an explcit\n+     unknown pragmas in system headers unless an explicit\n      -Wunknown-pragmas has been given. */\n   if (warn_unknown_pragmas > in_system_header)\n-    warning (\"ignoring pragma %s\", name);\n+    {\n+      if (space)\n+\twarning (\"ignoring #pragma %s %s\", space, name);\n+      else\n+\twarning (\"ignoring #pragma %s\", name);\n+    }\n }\n \n #endif\n@@ -444,6 +451,10 @@ init_pragma ()\n   cpp_register_pragma (pfile, 0, \"weak\", handle_pragma_weak);\n #endif\n \n+#ifdef REGISTER_TARGET_PRAGMAS\n+  REGISTER_TARGET_PRAGMAS (pfile);\n+#endif\n+\n #ifdef HANDLE_PRAGMA_PACK_PUSH_POP\n   ggc_add_root (&alignment_stack, 1, sizeof(alignment_stack),\n \t\tmark_align_stack);"}, {"sha": "d669d9d734fc1824455d5465006b0c89e4039ddf", "filename": "gcc/c-pragma.h", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b97c5f8ef218afce7499abe8cd3e6eb1f729306/gcc%2Fc-pragma.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b97c5f8ef218afce7499abe8cd3e6eb1f729306/gcc%2Fc-pragma.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pragma.h?ref=8b97c5f8ef218afce7499abe8cd3e6eb1f729306", "patch": "@@ -62,7 +62,8 @@ extern int add_weak PARAMS ((const char *, const char *));\n    parsing is to be done.  The code in GCC's generic C source files\n    will only look for the definition of this constant.  They will\n    ignore definitions of HANDLE_PRAGMA_PACK and so on.  */\n-#if defined HANDLE_PRAGMA_PACK || defined HANDLE_PRAGMA_WEAK\n+#if defined HANDLE_PRAGMA_PACK || defined HANDLE_PRAGMA_WEAK \\\n+    || defined REGISTER_TARGET_PRAGMAS\n #define HANDLE_GENERIC_PRAGMAS\n #endif\n \n@@ -77,4 +78,15 @@ extern void dispatch_pragma PARAMS ((void));\n # define init_pragma()\n #endif\n \n+/* Duplicate prototypes for the register_pragma stuff and the typedef for\n+   cpp_reader, to avoid dragging cpplib.h in almost everywhere... */\n+#ifndef __GCC_CPPLIB__\n+typedef struct cpp_reader cpp_reader;\n+\n+extern void cpp_register_pragma PARAMS ((cpp_reader *,\n+\t\t\t\t\t const char *, const char *,\n+\t\t\t\t\t void (*) PARAMS ((cpp_reader *))));\n+extern void cpp_register_pragma_space PARAMS ((cpp_reader *, const char *));\n+#endif\n+\n #endif /* _C_PRAGMA_H */"}, {"sha": "bc05fa76a97f196950350aae0654618fb5610b39", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b97c5f8ef218afce7499abe8cd3e6eb1f729306/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b97c5f8ef218afce7499abe8cd3e6eb1f729306/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=8b97c5f8ef218afce7499abe8cd3e6eb1f729306", "patch": "@@ -20,11 +20,12 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n+#ifndef GCC_ARM_PROTOS_H\n+#define GCC_ARM_PROTOS_H\n+\n extern void   arm_override_options\tPARAMS ((void));\n extern int    use_return_insn\t\tPARAMS ((int));\n extern int    arm_regno_class \t\tPARAMS ((int));\n-extern int    arm_process_pragma\tPARAMS ((int (*)(void), void (*) (int),\n-\t\t\t\t\t\tchar *));\n extern void   arm_finalize_pic\t\tPARAMS ((void));\n extern int    arm_volatile_func\t\tPARAMS ((void));\n extern const char * arm_output_epilogue\tPARAMS ((int));\n@@ -194,3 +195,11 @@ extern int  arm_dllimport_p \t\tPARAMS ((tree));\n extern void arm_mark_dllexport \t\tPARAMS ((tree));\n extern void arm_mark_dllimport \t\tPARAMS ((tree));\n #endif\n+\n+#ifdef _C_PRAGMA_H  /* included from code that cares about pragmas */\n+extern void arm_pr_long_calls\t\tPARAMS ((cpp_reader *));\n+extern void arm_pr_no_long_calls\tPARAMS ((cpp_reader *));\n+extern void arm_pr_long_calls_off\tPARAMS ((cpp_reader *));\n+#endif\n+\n+#endif /* GCC_ARM_PROTOS_H */"}, {"sha": "035ff147307472a2beeb1d39a57c5218f6e49dec", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 22, "deletions": 21, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b97c5f8ef218afce7499abe8cd3e6eb1f729306/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b97c5f8ef218afce7499abe8cd3e6eb1f729306/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=8b97c5f8ef218afce7499abe8cd3e6eb1f729306", "patch": "@@ -25,7 +25,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"system.h\"\n #include \"rtl.h\"\n #include \"tree.h\"\n-#include \"tm_p.h\"\n+#include \"tm.h\"\n #include \"regs.h\"\n #include \"hard-reg-set.h\"\n #include \"real.h\"\n@@ -42,6 +42,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"recog.h\"\n #include \"ggc.h\"\n #include \"except.h\"\n+#include \"c-pragma.h\"\n #include \"tm_p.h\"\n \n /* Forward definitions of types.  */\n@@ -1613,27 +1614,27 @@ typedef enum\n \n static arm_pragma_enum arm_pragma_long_calls = OFF;\n \n-/* Handle pragmas for compatibility with Intel's compilers.\n-   FIXME: This is incomplete, since it does not handle all\n-   the pragmas that the Intel compilers understand.  */\n-int\n-arm_process_pragma (p_getc, p_ungetc, pname)\n-     int (*  p_getc)   PARAMS ((void)) ATTRIBUTE_UNUSED;\n-     void (* p_ungetc) PARAMS ((int))  ATTRIBUTE_UNUSED;\n-     char *  pname;\n-{\n-  /* Should be pragma 'far' or equivalent for callx/balx here.  */\n-  if (strcmp (pname, \"long_calls\") == 0)\n-    arm_pragma_long_calls = LONG;\n-  else if (strcmp (pname, \"no_long_calls\") == 0)\n-    arm_pragma_long_calls = SHORT;\n-  else if (strcmp (pname, \"long_calls_off\") == 0)\n-    arm_pragma_long_calls = OFF;\n-  else\n-    return 0;\n-  \n-  return 1;\n+void\n+arm_pr_long_calls (pfile)\n+     cpp_reader *pfile ATTRIBUTE_UNUSED;\n+{\n+  arm_pragma_long_calls = LONG;\n }\n+\n+void\n+arm_pr_no_long_calls (pfile)\n+     cpp_reader *pfile ATTRIBUTE_UNUSED;\n+{\n+  arm_pragma_long_calls = SHORT;\n+}\n+\n+void\n+arm_pr_long_calls_off (pfile)\n+     cpp_reader *pfile ATTRIBUTE_UNUSED;\n+{\n+  arm_pragma_long_calls = OFF;\n+}\n+\n \f\n /* Return nonzero if IDENTIFIER with arguments ARGS is a valid machine specific\n    attribute for TYPE.  The attributes in ATTRIBUTES have previously been"}, {"sha": "4f2692a7ccfcb991ff981f134b53e346c785f1df", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b97c5f8ef218afce7499abe8cd3e6eb1f729306/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b97c5f8ef218afce7499abe8cd3e6eb1f729306/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=8b97c5f8ef218afce7499abe8cd3e6eb1f729306", "patch": "@@ -2488,8 +2488,12 @@ extern int making_const_table;\n   arm_set_default_type_attributes (TYPE)\n \n /* Handle pragmas for compatibility with Intel's compilers.  */\n-#define HANDLE_PRAGMA(GET, UNGET, NAME) arm_process_pragma (GET, UNGET, NAME)\n-\f\n+#define REGISTER_TARGET_PRAGMAS(PFILE) do { \\\n+  cpp_register_pragma (PFILE, 0, \"long_calls\", arm_pr_long_calls); \\\n+  cpp_register_pragma (PFILE, 0, \"no_long_calls\", arm_pr_no_long_calls); \\\n+  cpp_register_pragma (PFILE, 0, \"long_calls_off\", arm_pr_long_calls_off); \\\n+} while (0)\n+\n /* Condition code information. */\n /* Given a comparison code (EQ, NE, etc.) and the first operand of a COMPARE,\n    return the mode to be used for the comparison. "}, {"sha": "a9fb5e6bde29ec89c7ea2ee654011fceb6c19dfd", "filename": "gcc/config/c4x/c4x-protos.h", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b97c5f8ef218afce7499abe8cd3e6eb1f729306/gcc%2Fconfig%2Fc4x%2Fc4x-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b97c5f8ef218afce7499abe8cd3e6eb1f729306/gcc%2Fconfig%2Fc4x%2Fc4x-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x-protos.h?ref=8b97c5f8ef218afce7499abe8cd3e6eb1f729306", "patch": "@@ -22,6 +22,9 @@\n    the Free Software Foundation, 59 Temple Place - Suite 330,\n    Boston, MA 02111-1307, USA.  */\n \n+#ifndef GCC_C4X_PROTOS_H\n+#define GCC_C4X_PROTOS_H\n+\n extern void c4x_override_options PARAMS ((void));\n \n extern void c4x_optimization_options PARAMS ((int, int));\n@@ -290,3 +293,14 @@ extern enum machine_mode c4x_caller_save_map[];\n \n extern int c4x_rpts_cycles;\t        /* Max cycles for RPTS.  */\n extern int c4x_cpu_version;\t\t/* Cpu version C30/31/32/40/44.  */\n+\n+#ifdef _C_PRAGMA_H\n+extern void c4x_pr_CODE_SECTION\t\tPARAMS ((cpp_reader *));\n+extern void c4x_pr_DATA_SECTION\t\tPARAMS ((cpp_reader *));\n+extern void c4x_pr_FUNC_IS_PURE\t\tPARAMS ((cpp_reader *));\n+extern void c4x_pr_FUNC_NEVER_RETURNS\tPARAMS ((cpp_reader *));\n+extern void c4x_pr_INTERRUPT\t\tPARAMS ((cpp_reader *));\n+extern void c4x_pr_ignored\t\tPARAMS ((cpp_reader *));\n+#endif\n+\n+#endif"}, {"sha": "d6881b5c223905a6559fe40f5dac2c4124a76c1b", "filename": "gcc/config/c4x/c4x.c", "status": "modified", "additions": 103, "deletions": 110, "changes": 213, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b97c5f8ef218afce7499abe8cd3e6eb1f729306/gcc%2Fconfig%2Fc4x%2Fc4x.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b97c5f8ef218afce7499abe8cd3e6eb1f729306/gcc%2Fconfig%2Fc4x%2Fc4x.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.c?ref=8b97c5f8ef218afce7499abe8cd3e6eb1f729306", "patch": "@@ -45,6 +45,9 @@\n #include \"recog.h\"\n #include \"c-tree.h\"\n #include \"ggc.h\"\n+#include \"cpplib.h\"\n+#include \"c-lex.h\"\n+#include \"c-pragma.h\"\n #include \"c4x-protos.h\"\n \n rtx smulhi3_libfunc;\n@@ -182,6 +185,7 @@ static int c4x_valid_operands PARAMS ((enum rtx_code, rtx *,\n static int c4x_arn_reg_operand PARAMS ((rtx, enum machine_mode, unsigned int));\n static int c4x_arn_mem_operand PARAMS ((rtx, enum machine_mode, unsigned int));\n static void c4x_check_attribute PARAMS ((const char *, tree, tree, tree *));\n+static int c4x_parse_pragma PARAMS ((const char *, tree *, tree *));\n \n /* Called to register all of our global variables with the garbage\n    collector.  */\n@@ -287,7 +291,7 @@ c4x_override_options ()\n \n void\n c4x_optimization_options (level, size)\n-     int level;\n+     int level ATTRIBUTE_UNUSED;\n      int size ATTRIBUTE_UNUSED;\n {\n   /* Scheduling before register allocation can screw up global\n@@ -4383,123 +4387,112 @@ c4x_operand_subword (op, i, validate_address, mode)\n \n    */\n \n-int\n-c4x_handle_pragma (p_getc, p_ungetc, pname)\n-     int (* p_getc) PARAMS ((void));\n-     void (* p_ungetc) PARAMS ((int)) ATTRIBUTE_UNUSED;\n-     char *pname;\n+/* Parse a C4x pragma, of the form ( function [, \"section\"] ) \\n.\n+   FUNC is loaded with the IDENTIFIER_NODE of the function, SECT with\n+   the STRING_CST node of the string.  If SECT is null, then this\n+   pragma doesn't take a section string.  Returns 0 for a good pragma,\n+   -1 for a malformed pragma.  */\n+#define BAD(msgid, arg) do { warning (msgid, arg); return -1; } while (0)\n+\n+static int\n+c4x_parse_pragma (name, func, sect)\n+     const char *name;\n+     tree *func;\n+     tree *sect;\n {\n-  int i;\n-  int c;\n-  int namesize;\n-  char *name;\n-  tree func;\n-  tree sect = NULL_TREE;\n-  tree new;\n+  tree f, s, x;\n \n-  c = p_getc ();\n-  while (c == ' ' || c == '\\t') c = p_getc ();\n-  if (c != '(')\n-    return 0;\n+  if (c_lex (&x) != CPP_OPEN_PAREN)\n+    BAD (\"missing '(' after '#pragma %s' - ignored\", name);\n \n-  c = p_getc ();\n-  while (c == ' ' || c == '\\t') c = p_getc ();\n-  if (! (ISALPHA(c) || c == '_' || c == '$' || c == '@'))\n-    return 0;\n+  if (c_lex (&f) != CPP_NAME)\n+    BAD (\"missing function name in '#pragma %s' - ignored\", name);\n \n-  i = 0;\n-  namesize = 16;\n-  name = xmalloc (namesize);\n-  while (ISALNUM (c) || c == '_' || c == '$' || c == '@')\n-    {\n-      if (i >= namesize-1)\n-\t{\n-\t  namesize += 16;\n-\t  name = xrealloc (name, namesize);\n-\t}\n-      name[i++] = c;\n-      c = p_getc ();\n-    }\n-  name[i] = 0;\n-  func = get_identifier (name);\n-  free (name);\n-  \n-  if (strcmp (pname, \"CODE_SECTION\") == 0\n-      || strcmp (pname, \"DATA_SECTION\") == 0)\n+  if (sect)\n     {\n-      while (c == ' ' || c == '\\t') c = p_getc ();\n-      if (c != ',')\n-        return 0;\n-\n-      c = p_getc ();\n-      while (c == ' ' || c == '\\t') c = p_getc ();\n-      if (c != '\"')\n-        return 0;\n-\n-      i = 0;\n-      namesize = 16;\n-      name = xmalloc (namesize);\n-      c = p_getc ();\n-      while (c != '\"' && c != '\\n' && c != '\\r' && c != EOF)\n-        {\n-          if (i >= namesize-1)\n-\t    {\n-\t      namesize += 16;\n-\t      name = xrealloc (name, namesize);\n-\t    }\n-          name[i++] = c;\n-          c = p_getc ();\n-        }\n-      name[i] = 0;\n-      sect = build_string (i, name);\n-      free (name);\n-      sect = build_tree_list (NULL_TREE, sect);\n-      \n-      if (c != '\"')\n-        return 0;\n-      c = p_getc ();\n+      if (c_lex (&x) != CPP_COMMA)\n+\tBAD (\"malformed '#pragma %s' - ignored\", name);\n+      if (c_lex (&s) != CPP_STRING)\n+\tBAD (\"missing section name in '#pragma %s' - ignored\", name);\n+      *sect = s;\n     }\n-  while (c == ' ' || c == '\\t') c = p_getc ();\n-  if (c != ')')\n-    return 0;\n-  \n-  new = build_tree_list (func, sect);\n-  if (strcmp (pname, \"CODE_SECTION\") == 0)\n-    code_tree = chainon (code_tree, new);\n-  \n-  else if (strcmp (pname, \"DATA_SECTION\") == 0)\n-    data_tree = chainon (data_tree, new);\n-  \n-  else if (strcmp (pname, \"FUNC_CANNOT_INLINE\") == 0)\n-      ; /* Ignore.  */\n-  \n-  else if (strcmp (pname, \"FUNC_EXT_CALLED\") == 0)\n-      ; /* Ignore.  */\n-  \n-  else if (strcmp (pname, \"FUNC_IS_PURE\") == 0)\n-     pure_tree = chainon (pure_tree, new);\n-  \n-  else if (strcmp (pname, \"FUNC_IS_SYSTEM\") == 0)\n-      ; /* Ignore.  */\n-  \n-  else if (strcmp (pname, \"FUNC_NEVER_RETURNS\") == 0)\n-    noreturn_tree = chainon (noreturn_tree, new);\n-  \n-  else if (strcmp (pname, \"FUNC_NO_GLOBAL_ASG\") == 0)\n-      ; /* Ignore.  */\n-  \n-  else if (strcmp (pname, \"FUNC_NO_IND_ASG\") == 0)\n-      ; /* Ignore.  */\n-  \n-  else if (strcmp (pname, \"INTERRUPT\") == 0)\n-    interrupt_tree = chainon (interrupt_tree, new);\n-  \n-  else\n-    return 0;\n-  \n-  return 1;\n+\n+  if (c_lex (&x) != CPP_CLOSE_PAREN)\n+    BAD (\"missing ')' for '#pragma %s' - ignored\", name);\n+\n+  if (c_lex (&x) != CPP_EOF)\n+    warning (\"junk at end of '#pragma %s'\", name);\n+\n+  *func = f;\n+  return 0;\n }\n \n+void\n+c4x_pr_CODE_SECTION (pfile)\n+     cpp_reader *pfile ATTRIBUTE_UNUSED;\n+{\n+  tree func, sect;\n+\n+  if (c4x_parse_pragma (\"CODE_SECTION\", &func, &sect))\n+    return;\n+  code_tree = chainon (code_tree,\n+\t\t       build_tree_list (func,\n+\t\t\t\t\tbuild_tree_list (NULL_TREE, sect)));\n+}\n+\n+void\n+c4x_pr_DATA_SECTION (pfile)\n+     cpp_reader *pfile ATTRIBUTE_UNUSED;\n+{\n+  tree func, sect;\n+\n+  if (c4x_parse_pragma (\"DATA_SECTION\", &func, &sect))\n+    return;\n+  data_tree = chainon (data_tree,\n+\t\t       build_tree_list (func,\n+\t\t\t\t\tbuild_tree_list (NULL_TREE, sect)));\n+}\n+\n+void\n+c4x_pr_FUNC_IS_PURE (pfile)\n+     cpp_reader *pfile ATTRIBUTE_UNUSED;\n+{\n+  tree func;\n+\n+  if (c4x_parse_pragma (\"FUNC_IS_PURE\", &func, 0))\n+    return;\n+  pure_tree = chainon (pure_tree, build_tree_list (func, NULL_TREE));\n+}\n+\n+void\n+c4x_pr_FUNC_NEVER_RETURNS (pfile)\n+     cpp_reader *pfile ATTRIBUTE_UNUSED;\n+{\n+  tree func;\n+\n+  if (c4x_parse_pragma (\"FUNC_NEVER_RETURNS\", &func, 0))\n+    return;\n+  noreturn_tree = chainon (noreturn_tree, build_tree_list (func, NULL_TREE));\n+}\n+\n+void\n+c4x_pr_INTERRUPT (pfile)\n+     cpp_reader *pfile ATTRIBUTE_UNUSED;\n+{\n+  tree func;\n+\n+  if (c4x_parse_pragma (\"INTERRUPT\", &func, 0))\n+    return;\n+  interrupt_tree = chainon (interrupt_tree, build_tree_list (func, NULL_TREE));\n+}\n+\n+/* Used for FUNC_CANNOT_INLINE, FUNC_EXT_CALLED, FUNC_IS_SYSTEM,\n+   FUNC_NO_GLOBAL_ASG, and FUNC_NO_IND_ASG.  */\n+void\n+c4x_pr_ignored (pfile)\n+     cpp_reader *pfile ATTRIBUTE_UNUSED;\n+{\n+}\n \n struct name_list\n {"}, {"sha": "8390b38b5863384e7016982246f846b72a3bdeb8", "filename": "gcc/config/c4x/c4x.h", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b97c5f8ef218afce7499abe8cd3e6eb1f729306/gcc%2Fconfig%2Fc4x%2Fc4x.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b97c5f8ef218afce7499abe8cd3e6eb1f729306/gcc%2Fconfig%2Fc4x%2Fc4x.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.h?ref=8b97c5f8ef218afce7499abe8cd3e6eb1f729306", "patch": "@@ -2372,14 +2372,20 @@ asm_fprintf (FILE, \"%s%d:\\n\", PREFIX, NUM)\n \n #define PRINT_OPERAND_ADDRESS(FILE, X) c4x_print_operand_address(FILE, X)\n \n-/* Define this macro if you want to implement any pragmas.  If defined, it\n-   should be a C expression to be executed when #pragma is seen.  The\n-   argument STREAM is the stdio input stream from which the source\n-   text can be read.  CH is the first character after the #pragma.  The\n-   result of the expression is the terminating character found\n-   (newline or EOF).  */\n-#define HANDLE_PRAGMA(GETC, UNGETC, NAME) \\\n-  c4x_handle_pragma (GETC, UNGETC, NAME)\n+/* C4x specific pragmas.  */\n+#define REGISTER_TARGET_PRAGMAS(PFILE) do {\t\t\t\t\\\n+  cpp_register_pragma (PFILE, 0, \"CODE_SECTION\", c4x_pr_CODE_SECTION);\t\\\n+  cpp_register_pragma (PFILE, 0, \"DATA_SECTION\", c4x_pr_DATA_SECTION);\t\\\n+  cpp_register_pragma (PFILE, 0, \"FUNC_CANNOT_INLINE\", c4x_pr_ignored);\t\\\n+  cpp_register_pragma (PFILE, 0, \"FUNC_EXT_CALLED\", c4x_pr_ignored);\t\\\n+  cpp_register_pragma (PFILE, 0, \"FUNC_IS_PURE\", c4x_pr_FUNC_IS_PURE);\t\\\n+  cpp_register_pragma (PFILE, 0, \"FUNC_IS_SYSTEM\", c4x_pr_ignored);\t\\\n+  cpp_register_pragma (PFILE, 0, \"FUNC_NEVER_RETURNS\",\t\t\t\\\n+\t\t       c4x_pr_FUNC_NEVER_RETURNS);\t\t\t\\\n+  cpp_register_pragma (PFILE, 0, \"FUNC_NO_GLOBAL_ASG\", c4x_pr_ignored);\t\\\n+  cpp_register_pragma (PFILE, 0, \"FUNC_NO_IND_ASG\", c4x_pr_ignored);\t\\\n+  cpp_register_pragma (PFILE, 0, \"INTERRUPT\", c4x_pr_INTERRUPT);\t\\\n+} while (0)\n \n #define SET_DEFAULT_DECL_ATTRIBUTES(DECL, ATTRIBUTES) \\\n   c4x_set_default_attributes (DECL, &ATTRIBUTES)"}, {"sha": "9a4d2a4c1120e9f27db3a4ec7b3c063b92605b98", "filename": "gcc/config/d30v/d30v.h", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b97c5f8ef218afce7499abe8cd3e6eb1f729306/gcc%2Fconfig%2Fd30v%2Fd30v.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b97c5f8ef218afce7499abe8cd3e6eb1f729306/gcc%2Fconfig%2Fd30v%2Fd30v.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fd30v%2Fd30v.h?ref=8b97c5f8ef218afce7499abe8cd3e6eb1f729306", "patch": "@@ -19,6 +19,8 @@\n    the Free Software Foundation, 59 Temple Place - Suite 330,\n    Boston, MA 02111-1307, USA.  */\n \n+#ifndef GCC_D30V_H\n+\n /* D30V specific macros */\n \n /* Align an address */\n@@ -5955,15 +5957,6 @@ fprintf (STREAM, \"\\t.word .L%d\\n\", VALUE)\n    is to pretend that the file's contents are enclosed in `extern \"C\" {...}'.  */\n /* #define NO_IMPLICIT_EXTERN_C */\n \n-/* Define this macro if you want to implement any pragmas.  If defined, it\n-   should be a C statement to be executed when `#pragma' is seen.  The argument\n-   STREAM is the stdio input stream from which the source text can be read.\n-\n-   It is generally a bad idea to implement new uses of `#pragma'.  The only\n-   reason to define this macro is for compatibility with other compilers that\n-   do support `#pragma' for the sake of any user programs which already use it.  */\n-/* #define HANDLE_PRAGMA(STREAM) */\n-\n /* Define this macro to handle System V style pragmas (particularly #pack).\n \n    Defined in svr4.h.  */\n@@ -6081,3 +6074,5 @@ extern const char *d30v_cond_exec_string;\n \n /* Indicate how many instructions can be issued at the same time.  */\n #define ISSUE_RATE 2\n+\n+#endif /* GCC_D30V_H */"}, {"sha": "1535b29c6f2e05816c7f096307d94d1f137dcacf", "filename": "gcc/config/h8300/h8300-protos.h", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b97c5f8ef218afce7499abe8cd3e6eb1f729306/gcc%2Fconfig%2Fh8300%2Fh8300-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b97c5f8ef218afce7499abe8cd3e6eb1f729306/gcc%2Fconfig%2Fh8300%2Fh8300-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300-protos.h?ref=8b97c5f8ef218afce7499abe8cd3e6eb1f729306", "patch": "@@ -21,6 +21,9 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n+#ifndef GCC_H8300_PROTOS_H\n+#define GCC_H8300_PROTOS_H\n+\n /* Declarations for functions used in insn-output.c.  */\n #ifdef RTX_CODE\n extern const char *emit_a_shift PARAMS ((rtx, rtx *));\n@@ -66,7 +69,6 @@ extern int h8300_tiny_data_p PARAMS ((tree));\n extern void h8300_encode_label PARAMS ((tree));\n #endif /* TREE_CODE */\n \n-extern int handle_pragma PARAMS ((int (*)(void), void (*)(int), const char *));\n extern void h8300_init_once PARAMS ((void));\n extern void function_prologue PARAMS ((FILE *, int));\n extern void function_epilogue PARAMS ((FILE *, int));\n@@ -75,3 +77,10 @@ extern void asm_file_end PARAMS ((FILE *));\n extern int ok_for_bclr PARAMS ((HOST_WIDE_INT));\n extern int small_power_of_two PARAMS ((HOST_WIDE_INT));\n extern int initial_offset PARAMS ((int, int));\n+\n+#ifdef _C_PRAGMA_H\n+extern void h8300_pr_interrupt PARAMS ((cpp_reader *));\n+extern void h8300_pr_saveall PARAMS ((cpp_reader *));\n+#endif\n+\n+#endif /* GCC_H8300_PROTOS_H */"}, {"sha": "1ecda26af58c9d9fbad83b2ae53f2f72ae87dbf8", "filename": "gcc/config/h8300/h8300.c", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b97c5f8ef218afce7499abe8cd3e6eb1f729306/gcc%2Fconfig%2Fh8300%2Fh8300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b97c5f8ef218afce7499abe8cd3e6eb1f729306/gcc%2Fconfig%2Fh8300%2Fh8300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.c?ref=8b97c5f8ef218afce7499abe8cd3e6eb1f729306", "patch": "@@ -39,6 +39,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"function.h\"\n #include \"obstack.h\"\n #include \"toplev.h\"\n+#include \"c-pragma.h\"\n #include \"tm_p.h\"\n \n /* Forward declarations.  */\n@@ -730,22 +731,20 @@ eq_operator (x, mode)\n    an rte instruction rather than an rts.  A pointer to a function\n    with this attribute may be safely used in an interrupt vector.  */\n \n-int\n-handle_pragma (p_getc, p_ungetc, pname)\n-     int (* ATTRIBUTE_UNUSED p_getc) PARAMS ((void));\n-     void (* ATTRIBUTE_UNUSED p_ungetc) PARAMS ((int));\n-     const char *pname;\n+void\n+h8300_pr_interrupt (pfile)\n+     cpp_reader *pfile ATTRIBUTE_UNUSED;\n {\n-  int retval = 0;\n-\n-  if (strcmp (pname, \"interrupt\") == 0)\n-    interrupt_handler = retval = 1;\n-  else if (strcmp (pname, \"saveall\") == 0)\n-    pragma_saveall = retval = 1;\n+  interrupt_handler = 1;\n+}\n \n-  return retval;\n+void\n+h8300_pr_saveall (pfile)\n+     cpp_reader *pfile ATTRIBUTE_UNUSED;\n+{\n+  pragma_saveall = 1;\n }\n-\f\n+\n /* If the next arg with MODE and TYPE is to be passed in a register, return\n    the rtx to represent where it is passed.  CUM represents the state after\n    the last argument.  NAMED is not used.  */"}, {"sha": "55af2e297e1577eb9ed722c29e0321b02c9b74be", "filename": "gcc/config/h8300/h8300.h", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b97c5f8ef218afce7499abe8cd3e6eb1f729306/gcc%2Fconfig%2Fh8300%2Fh8300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b97c5f8ef218afce7499abe8cd3e6eb1f729306/gcc%2Fconfig%2Fh8300%2Fh8300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.h?ref=8b97c5f8ef218afce7499abe8cd3e6eb1f729306", "patch": "@@ -22,6 +22,9 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n+#ifndef GCC_H8300_H\n+#define GCC_H8300_H\n+\n /* Which CPU to compile for.\n    We use int for CPU_TYPE to avoid lots of casts.  */\n #if 0 /* defined in insn-attr.h, here for documentation */\n@@ -1410,18 +1413,11 @@ do { char dstr[30];\t\t\t\t\t\\\n \n #define PRINT_OPERAND_ADDRESS(FILE, ADDR) print_operand_address (FILE, ADDR)\n \n-/* Define this macro if you want to implement any pragmas.  If defined, it\n-   should be a C expression to be executed when #pragma is seen.  The\n-   argument GETC is a function which will return the next character in the\n-   input stream, or EOF if no characters are left.  The argument UNGETC is\n-   a function which will push a character back into the input stream.  The\n-   argument NAME is the word following #pragma in the input stream.  The input\n-   stream pointer will be pointing just beyond the end of this word.  The\n-   expression should return true if it handled the pragma, false otherwise.\n-   The input stream should be left undistrubed if false is returned, otherwise\n-   it should be pointing at the last character after the end of the pragma\n-   (newline or end-of-file).  */\n-#define HANDLE_PRAGMA(GETC, UNGETC, NAME) handle_pragma (GETC, UNGETC, NAME)\n+/* H8300 specific pragmas.  */\n+#define REGISTER_TARGET_PRAGMAS(PFILE) do {\t\t\t\t\\\n+  cpp_register_pragma (PFILE, 0, \"saveall\", h8300_pr_saveall);\t\t\\\n+  cpp_register_pragma (PFILE, 0, \"interrupt\", h8300_pr_interrupt);\t\\\n+} while (0)\n \n #define FINAL_PRESCAN_INSN(insn, operand, nop) final_prescan_insn (insn, operand,nop)\n \n@@ -1454,3 +1450,5 @@ do { char dstr[30];\t\t\t\t\t\\\n   } while (0)\n \n #define MOVE_RATIO 3\n+\n+#endif /* GCC_H8300_H */"}, {"sha": "7ee1d3ff6e1b116bc1f0f8592608de492dcda647", "filename": "gcc/config/i370/i370-protos.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b97c5f8ef218afce7499abe8cd3e6eb1f729306/gcc%2Fconfig%2Fi370%2Fi370-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b97c5f8ef218afce7499abe8cd3e6eb1f729306/gcc%2Fconfig%2Fi370%2Fi370-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi370%2Fi370-protos.h?ref=8b97c5f8ef218afce7499abe8cd3e6eb1f729306", "patch": "@@ -21,6 +21,9 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n+#ifndef GCC_I370_PROTOS_H\n+#define GCC_I370_PROTOS_H\n+\n #ifdef RTX_CODE\n extern int i370_branch_dest PARAMS ((rtx));\n extern int i370_branch_length PARAMS ((rtx));\n@@ -46,3 +49,9 @@ extern int mvs_check_alias PARAMS ((const char *, char *));\n extern void i370_function_prolog PARAMS ((FILE *, int));\n extern void check_label_emit PARAMS ((void));\n extern void mvs_free_label_list PARAMS ((void));\n+\n+#ifdef _C_PRAGMA_H\n+extern void i370_pr_map PARAMS ((cpp_reader *));\n+#endif\n+\n+#endif"}, {"sha": "73a78803e336430b9fa38353fe68bea3a8f045ce", "filename": "gcc/config/i370/i370.c", "status": "modified", "additions": 32, "deletions": 103, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b97c5f8ef218afce7499abe8cd3e6eb1f729306/gcc%2Fconfig%2Fi370%2Fi370.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b97c5f8ef218afce7499abe8cd3e6eb1f729306/gcc%2Fconfig%2Fi370%2Fi370.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi370%2Fi370.c?ref=8b97c5f8ef218afce7499abe8cd3e6eb1f729306", "patch": "@@ -38,6 +38,9 @@ Boston, MA 02111-1307, USA.  */\n #include \"flags.h\"\n #include \"recog.h\"\n #include \"toplev.h\"\n+#include \"cpplib.h\"\n+#include \"c-pragma.h\"\n+#include \"c-lex.h\"\n #include \"tm_p.h\"\n \n extern FILE *asm_out_file;\n@@ -862,6 +865,17 @@ mvs_add_alias (realname, aliasname, emitted)\n   alias_node_t *ap;\n \n   ap = (alias_node_t *) xmalloc (sizeof (alias_node_t));\n+  if (strlen (realname) > MAX_LONG_LABEL_SIZE)\n+    {\n+      warning (\"real name is too long - alias ignored\");\n+      return;\n+    }\n+  if (strlen (aliasname) > MAX_MVS_LABEL_SIZE)\n+    {\n+      warning (\"alias name is too long - alias ignored\");\n+      return;\n+    }\n+      \n   strcpy (ap->real_name, realname);\n   strcpy (ap->alias_name, aliasname);\n   ap->alias_emitted = emitted;\n@@ -1005,116 +1019,31 @@ mvs_check_alias (realname, aliasname)\n   return 0;\n }\n \n-/* Called from check_newline via the macro HANDLE_PRAGMA.\n-   p_getc is a pointer to get character routine.\n-   p_ungetc is a pointer to un-get character routine.\n-   pname is the pointer to the name of the pragma to process.\n-   The result is 1 if the pragma was handled.  */\n+/* #pragma map (name, alias) -\n+   In this implementation both name and alias are required to be\n+   identifiers.  The older code seemed to be more permissive.  Can\n+   anyone clarify?  */\n \n-int\n-handle_pragma (p_getc, p_ungetc, pname)\n-     int (* p_getc) PARAMS ((void));\n-     void (* p_ungetc) PARAMS ((int));\n-     const char *pname;\n+void\n+i370_pr_map (pfile)\n+     cpp_reader *pfile ATTRIBUTE_UNUSED;\n {\n-  int retval = 0;\n-  register int c;\n+  tree name, alias, x;\n \n-  if (strcmp (pname, \"map\") == 0)\n+  if (c_lex (&x)        == CPP_OPEN_PAREN\n+      && c_lex (&name)  == CPP_NAME\n+      && c_lex (&x)     == CPP_COMMA\n+      && c_lex (&alias) == CPP_NAME\n+      && c_lex (&x)     == CPP_CLOSE_PAREN)\n     {\n-      char realname[MAX_LONG_LABEL_SIZE + 1];\n-      char aliasname[MAX_MVS_LABEL_SIZE + 1];\n-      char *s;\n+      if (c_lex (&x) != CPP_EOF)\n+\twarning (\"junk at end of #pragma map\");\n \n-      do {\n-\tc = p_getc ();\n-      } while (c == ' ' || c == '\\t');\n-\n-      if (c == '(')\n-        {\n-\t  s = realname;\n-\t  do {\n-\t    c = p_getc ();\n-\t  } while (c == ' ' || c == '\\t');\n-\t  if (c == '\\n')\n-\t    goto PRAGMA_WARNING;\n-\t  do {\n-\t    *s++ = c;\n-\t    c = p_getc ();\n-\t  } while (ISALNUM(c) || c == '_');\n-\t  if (c == '\\n')\n-\t    goto PRAGMA_WARNING;\n-\t  *s = 0;\n-\n-\t  if (c == ' ' || c == '\\t')\n-\t    do {\n-\t      c = p_getc ();\n-\t    } while (c == ' ' || c == '\\t');\n-\t  \n-\t  if (c == ',')\n-\t    {\n-\t      do {\n-\t        c = p_getc ();\n-\t      } while (c == ' ' || c == '\\t');\n-\t      if (c == '\"')\n-\t        {\n-\t          s = aliasname;\n-\t          c = p_getc ();\n-\t          do {\n-\t            if (c == '\\\\')\n-\t              {\n-\t                int d = 0;\n-\t                do {\n-\t                  c = p_getc ();\n-\t                  if (c >= '0' && c <= '7')\n-\t                      d = (d << 3) | (c - '0');\n-\t                } while (c >= '0' && c <= '7');\n-\t                p_ungetc (c);\n-\t                c = d;\n-\t                if (d < 1 || d > 255)\n-\t\t\t  warning (\"Escape value out of range\");\n-#ifndef HOST_EBCDIC\n-                        c = ebcasc[c];\n-#endif\n-\t              }\n-\t            *s++ = c;\n-\t            c = p_getc ();\n-\t            if (ISSPACE(c) || c == ')')\n-\t              goto PRAGMA_WARNING;\n-\t          } while (c != '\"');\n-\t          *s = 0;\n-\t\t  if (strlen (aliasname) > MAX_MVS_LABEL_SIZE)\n-\t\t    {\n-\t\t      warning (\"#pragma map alias is too long, truncated\");\n-\t\t      aliasname[MAX_MVS_LABEL_SIZE] = '\\0';\n-\t\t    }\n-\t\t  do {\n-\t\t    c = p_getc ();\n-\t\t  } while (c == ' ' || c == '\\t');\n-\t\t  if (c == ')')\n-\t\t    {\n-\t              mvs_add_alias (realname, aliasname, 1);\n-\t\t      retval = 1;\n-\t\t    }\n-\t          else\n-\t            goto PRAGMA_WARNING;\n-\t        }\n-\t      else\n-\t        goto PRAGMA_WARNING;\n-\t    }\n-\t  else\n-\t    goto PRAGMA_WARNING;\n-\t  \n-        }\n-      else\n-        {\n-\t PRAGMA_WARNING:\n-\t  warning (\"#pragma map options are missing or incorrect\");\n-        }\n-      \n+      mvs_add_alias (IDENTIFIER_POINTER (name), IDENTIFIER_POINTER (alias), 1);\n+      return;\n     }\n \n-  return retval;\n+  warning (\"malformed #pragma map, ignored\");\n }\n \n /* defines and functions specific to the HLASM assembler */"}, {"sha": "b733283050817ce7f9e4a6c826782c39efd7ade6", "filename": "gcc/config/i370/i370.h", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b97c5f8ef218afce7499abe8cd3e6eb1f729306/gcc%2Fconfig%2Fi370%2Fi370.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b97c5f8ef218afce7499abe8cd3e6eb1f729306/gcc%2Fconfig%2Fi370%2Fi370.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi370%2Fi370.h?ref=8b97c5f8ef218afce7499abe8cd3e6eb1f729306", "patch": "@@ -147,14 +147,9 @@ extern int mvs_function_name_length;\n #endif\n \n #ifdef TARGET_HLASM\n-/* Define this macro if you want to implement any pragmas.  If defined, it\n-   is a C expression to be executed when #pragma is seen.  The\n-   argument FILE is the stdio input stream from which the source\n-   text can be read.  CH is the first character after the #pragma.  The\n-   result of the expression is the terminating character found\n-   (newline or EOF).  */\n-#define HANDLE_PRAGMA(GETC, UNGETC, NAME) \\\n-  handle_pragma ((GETC), (UNGETC), (NAME))\n+/* HLASM requires #pragma map.  */\n+#define REGISTER_TARGET_PRAGMAS(PFILE) \\\n+  cpp_register_pragma (PFILE, 0, \"map\", i370_pr_map)\n #endif /* TARGET_HLASM */\n \n /* Define maximum length of page minus page escape overhead.  */"}, {"sha": "14bc9488f6753cabca4dfbb316337a01bf4a93e7", "filename": "gcc/config/i370/i370.md", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b97c5f8ef218afce7499abe8cd3e6eb1f729306/gcc%2Fconfig%2Fi370%2Fi370.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b97c5f8ef218afce7499abe8cd3e6eb1f729306/gcc%2Fconfig%2Fi370%2Fi370.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi370%2Fi370.md?ref=8b97c5f8ef218afce7499abe8cd3e6eb1f729306", "patch": "@@ -2714,7 +2714,6 @@ check_label_emit ();\n {\n   rtx dr = gen_reg_rtx (DImode);\n   rtx dr_0 = gen_rtx_SUBREG (SImode, dr, 0);\n-  rtx dr_1 = gen_rtx_SUBREG (SImode, dr, 1);\n \n   emit_insn (gen_rtx_SET (VOIDmode, dr_0, operands[1]));\n \n@@ -4717,7 +4716,7 @@ check_label_emit ();\n {\n   int i;\n \n-  emit_call_insn (gen_call (operands[0], const0_rtx, const0_rtx, const0_rtx));\n+  emit_call_insn (GEN_CALL (operands[0], const0_rtx, const0_rtx, const0_rtx));\n \n   for (i = 0; i < XVECLEN (operands[2], 0); i++)\n     {"}, {"sha": "130dddeefe400d35734441dc75bd21551b3ffb2c", "filename": "gcc/config/i960/i960-protos.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b97c5f8ef218afce7499abe8cd3e6eb1f729306/gcc%2Fconfig%2Fi960%2Fi960-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b97c5f8ef218afce7499abe8cd3e6eb1f729306/gcc%2Fconfig%2Fi960%2Fi960-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi960%2Fi960-protos.h?ref=8b97c5f8ef218afce7499abe8cd3e6eb1f729306", "patch": "@@ -22,6 +22,9 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n+#ifndef GCC_I960_PROTOS_H\n+#define GCC_I960_PROTOS_H\n+\n #ifdef RTX_CODE\n extern struct rtx_def *legitimize_address PARAMS ((rtx, rtx, enum machine_mode));\n /* Define the function that build the compare insn for scc and bcc.  */\n@@ -102,3 +105,10 @@ extern void i960_function_prologue PARAMS ((FILE *, unsigned int));\n extern void output_function_profiler PARAMS ((FILE *, int));\n extern void i960_function_epilogue PARAMS ((FILE *, unsigned int));\n extern void i960_scan_opcode PARAMS ((const char *));\n+\n+#ifdef _C_PRAGMA_H\n+extern void i960_pr_align PARAMS ((cpp_reader *));\n+extern void i960_pr_noalign PARAMS ((cpp_reader *));\n+#endif\n+\n+#endif /* i960-protos.h */"}, {"sha": "21753a207b2c59882330c4e7d8e5ae25447acc0f", "filename": "gcc/config/i960/i960.c", "status": "modified", "additions": 83, "deletions": 35, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b97c5f8ef218afce7499abe8cd3e6eb1f729306/gcc%2Fconfig%2Fi960%2Fi960.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b97c5f8ef218afce7499abe8cd3e6eb1f729306/gcc%2Fconfig%2Fi960%2Fi960.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi960%2Fi960.c?ref=8b97c5f8ef218afce7499abe8cd3e6eb1f729306", "patch": "@@ -42,6 +42,9 @@ Boston, MA 02111-1307, USA.  */\n #include \"function.h\"\n #include \"recog.h\"\n #include \"toplev.h\"\n+#include \"cpplib.h\"\n+#include \"c-pragma.h\"\n+#include \"c-lex.h\"\n #include \"tm_p.h\"\n \n /* Save the operands last given to a compare for use when we\n@@ -88,8 +91,86 @@ static int ret_label = 0;\n \n /* Handle pragmas for compatibility with Intel's compilers.  */\n \n-/* ??? This is incomplete, since it does not handle all pragmas that the\n-   intel compilers understand.  */\n+/* NOTE: ic960 R3.0 pragma align definition:\n+\n+   #pragma align [(size)] | (identifier=size[,...])\n+   #pragma noalign [(identifier)[,...]]\n+     \n+   (all parens are optional)\n+     \n+   - size is [1,2,4,8,16]\n+   - noalign means size==1\n+   - applies only to component elements of a struct (and union?)\n+   - identifier applies to structure tag (only)\n+   - missing identifier means next struct\n+     \n+   - alignment rules for bitfields need more investigation.\n+\n+   This implementation only handles the case of no identifiers.  */\n+\n+void\n+i960_pr_align (pfile)\n+     cpp_reader *pfile ATTRIBUTE_UNUSED;\n+{\n+  tree number;\n+  enum cpp_ttype type;\n+  int align;\n+\n+  type = c_lex (&number);\n+  if (type == CPP_OPEN_PAREN)\n+    type = c_lex (&number);\n+  if (type == CPP_NAME)\n+    {\n+      warning (\"sorry, not implemented: #pragma align NAME=SIZE\");\n+      return;\n+    }\n+  if (type != CPP_NUMBER)\n+    {\n+      warning (\"malformed #pragma align - ignored\");\n+      return;\n+    }\n+\n+  align = TREE_INT_CST_LOW (number);\n+  switch (align)\n+    {\n+    case 0:\n+      /* Return to last alignment.  */\n+      align = i960_last_maxbitalignment / 8;\n+      /* Fall through.  */\n+    case 16:\n+    case 8:\n+    case 4:\n+    case 2:\n+    case 1:\n+      i960_last_maxbitalignment = i960_maxbitalignment;\n+      i960_maxbitalignment = align * 8;\n+      break;\n+      \n+    default:\n+      /* Silently ignore bad values.  */\n+      break;\n+    }\n+}\n+\n+void\n+i960_pr_noalign (pfile)\n+     cpp_reader *pfile ATTRIBUTE_UNUSED;\n+{\n+  enum cpp_ttype type;\n+  tree number;\n+\n+  type = c_lex (&number);\n+  if (type == CPP_OPEN_PAREN)\n+    type = c_lex (&number);\n+  if (type == CPP_NAME)\n+    {\n+      warning (\"sorry, not implemented: #pragma noalign NAME\");\n+      return;\n+    }\n+\n+  i960_last_maxbitalignment = i960_maxbitalignment;\n+  i960_maxbitalignment = 8;\n+}\n \n int\n process_pragma (p_getc, p_ungetc, pname)\n@@ -132,40 +213,7 @@ process_pragma (p_getc, p_ungetc, pname)\n \n   align = atoi (buf);\n \n-  switch (align)\n-    {\n-    case 0:\n-      /* Return to last alignment.  */\n-      align = i960_last_maxbitalignment / 8;\n-      /* Fall through.  */\n-    case 16:\n-    case 8:\n-    case 4:\n-    case 2:\n-    case 1:\n-      i960_last_maxbitalignment = i960_maxbitalignment;\n-      i960_maxbitalignment = align * 8;\n-      break;\n-      \n-    default:\n-      /* Silently ignore bad values.  */\n-      break;\n-    }\n   \n-  /* NOTE: ic960 R3.0 pragma align definition:\n-     \n-     #pragma align [(size)] | (identifier=size[,...])\n-     #pragma noalign [(identifier)[,...]]\n-     \n-     (all parens are optional)\n-     \n-     - size is [1,2,4,8,16]\n-     - noalign means size==1\n-     - applies only to component elements of a struct (and union?)\n-     - identifier applies to structure tag (only)\n-     - missing identifier means next struct\n-     \n-     - alignment rules for bitfields need more investigation  */\n   \n   return 1;\n }"}, {"sha": "c741ba45263b60ac9c06f15d03f540a74cb98b30", "filename": "gcc/config/i960/i960.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b97c5f8ef218afce7499abe8cd3e6eb1f729306/gcc%2Fconfig%2Fi960%2Fi960.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b97c5f8ef218afce7499abe8cd3e6eb1f729306/gcc%2Fconfig%2Fi960%2Fi960.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi960%2Fi960.h?ref=8b97c5f8ef218afce7499abe8cd3e6eb1f729306", "patch": "@@ -131,7 +131,10 @@ Boston, MA 02111-1307, USA.  */\n   fprintf (asm_out_file, \"\\t.type\\t0x%x;\", A)\n \n /* Handle pragmas for compatibility with Intel's compilers.  */\n-#define HANDLE_PRAGMA(GET, UNGET, NAME) process_pragma (GET, UNGET, NAME)\n+#define REGISTER_TARGET_PRAGMAS(PFILE) do {\t\t\t\\\n+  cpp_register_pragma (PFILE, 0, \"align\", i960_pr_align);\t\\\n+  cpp_register_pragma (PFILE, 0, \"noalign\", i960_pr_noalign);\t\\\n+} while (0)\n \n /* Run-time compilation parameters selecting different hardware subsets.  */\n "}, {"sha": "435aff17cf771d36c3a5e068804d53ef2a9104a0", "filename": "gcc/config/sh/elf.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b97c5f8ef218afce7499abe8cd3e6eb1f729306/gcc%2Fconfig%2Fsh%2Felf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b97c5f8ef218afce7499abe8cd3e6eb1f729306/gcc%2Fconfig%2Fsh%2Felf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Felf.h?ref=8b97c5f8ef218afce7499abe8cd3e6eb1f729306", "patch": "@@ -112,10 +112,6 @@ do {\t\t\t\t\t\t\t\t\t\\\n   fprintf ((FILE), \"\\t.stabs \\\"\\\",%d,0,0,Letext\\nLetext:\\n\", N_SO);\t\\\n } while (0)\n \n-/* HANDLE_SYSV_PRAGMA (defined by svr4.h) takes precedence over HANDLE_PRAGMA.\n-   We want to use the HANDLE_PRAGMA from sh.h.  */\n-#undef HANDLE_SYSV_PRAGMA\n-\n #undef STARTFILE_SPEC\n #define STARTFILE_SPEC \\\n   \"%{!shared: crt1.o%s} crti.o%s \\"}, {"sha": "e62edf4dba0371b032e25b71ec0d98abd4fdcd72", "filename": "gcc/config/sh/sh-protos.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b97c5f8ef218afce7499abe8cd3e6eb1f729306/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b97c5f8ef218afce7499abe8cd3e6eb1f729306/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh-protos.h?ref=8b97c5f8ef218afce7499abe8cd3e6eb1f729306", "patch": "@@ -21,6 +21,9 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n+#ifndef GCC_SH_PROTOS_H\n+#define GCC_SH_PROTOS_H\n+\n #ifdef RTX_CODE\n extern struct rtx_def *sh_builtin_saveregs PARAMS ((void));\n extern struct rtx_def *prepare_scc_operands PARAMS ((enum rtx_code));\n@@ -122,3 +125,11 @@ extern int fldi_ok PARAMS ((void));\n #ifdef HARD_CONST\n extern void fpscr_set_from_mem PARAMS ((int, HARD_REG_SET));\n #endif\n+\n+#ifdef _C_PRAGMA_H\n+extern void sh_pr_interrupt PARAMS ((cpp_reader *));\n+extern void sh_pr_trapa PARAMS ((cpp_reader *));\n+extern void sh_pr_nosave_low_regs PARAMS ((cpp_reader *));\n+#endif\n+\n+#endif /* sh-protos.h */"}, {"sha": "158e66f317748bcab7489db24306278d6db8e1c3", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b97c5f8ef218afce7499abe8cd3e6eb1f729306/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b97c5f8ef218afce7499abe8cd3e6eb1f729306/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=8b97c5f8ef218afce7499abe8cd3e6eb1f729306", "patch": "@@ -36,6 +36,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"insn-attr.h\"\n #include \"toplev.h\"\n #include \"recog.h\"\n+#include \"c-pragma.h\"\n #include \"tm_p.h\"\n \n int code_for_indirect_jump_scratch = CODE_FOR_indirect_jump_scratch;\n@@ -4443,22 +4444,25 @@ initial_elimination_offset (from, to)\n /* Handle machine specific pragmas to be semi-compatible with Hitachi\n    compiler.  */\n \n-int\n-sh_handle_pragma (p_getc, p_ungetc, pname)\n-     int (*  p_getc)   PARAMS ((void)) ATTRIBUTE_UNUSED;\n-     void (* p_ungetc) PARAMS ((int)) ATTRIBUTE_UNUSED;\n-     const char * pname;\n+void\n+sh_pr_interrupt (pfile)\n+     cpp_reader *pfile ATTRIBUTE_UNUSED;\n {\n-  int retval = 0;\n+  pragma_interrupt = 1;\n+}\n \n-  if (strcmp (pname, \"interrupt\") == 0)\n-    pragma_interrupt = retval = 1;\n-  else if (strcmp (pname, \"trapa\") == 0)\n-    pragma_interrupt = pragma_trapa = retval = 1;\n-  else if (strcmp (pname, \"nosave_low_regs\") == 0)\n-    pragma_nosave_low_regs = retval = 1;\n+void\n+sh_pr_trapa (pfile)\n+     cpp_reader *pfile ATTRIBUTE_UNUSED;\n+{\n+  pragma_interrupt = pragma_trapa = 1;\n+}\n \n-  return retval;\n+void\n+sh_pr_nosave_low_regs (pfile)\n+     cpp_reader *pfile ATTRIBUTE_UNUSED;\n+{\n+  pragma_nosave_low_regs = 1;\n }\n \n /* Generate 'handle_interrupt' attribute for decls */"}, {"sha": "1fab69f74dc36829b3fd93fbb7e36f50dd9663c1", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b97c5f8ef218afce7499abe8cd3e6eb1f729306/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b97c5f8ef218afce7499abe8cd3e6eb1f729306/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=8b97c5f8ef218afce7499abe8cd3e6eb1f729306", "patch": "@@ -21,6 +21,8 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n+#ifndef GCC_SH_H\n+#define GCC_SH_H\n \n #define TARGET_VERSION \\\n   fputs (\" (Hitachi SH)\", stderr);\n@@ -2185,10 +2187,12 @@ extern enum mdep_reorg_phase_e mdep_reorg_phase;\n \n #define TARGET_MEM_FUNCTIONS\n \n-/* Define this macro if you want to implement any pragmas.  If defined, it\n-   is a C expression whose value is 1 if the pragma was handled by the\n-   macro, zero otherwise.  */\n-#define HANDLE_PRAGMA(GETC, UNGETC, NODE) sh_handle_pragma (GETC, UNGETC, NODE)\n+/* Handle Hitachi compiler's pragmas.  */\n+#define REGISTER_TARGET_PRAGMAS(PFILE) do {\t\t\t\t    \\\n+  cpp_register_pragma (PFILE, 0, \"interrupt\", sh_pr_interrupt);\t\t    \\\n+  cpp_register_pragma (PFILE, 0, \"trapa\", sh_pr_trapa);\t\t\t    \\\n+  cpp_register_pragma (PFILE, 0, \"nosave_low_regs\", sh_pr_nosave_low_regs); \\\n+} while (0)\n \n /* Set when processing a function with pragma interrupt turned on.  */\n \n@@ -2369,3 +2373,5 @@ do {\t\t\t\t\t\t\t\t\t\\\n 0:\t.p2align 2\\n\\\n 1:\t.long\t\" USER_LABEL_PREFIX #func \" - 0b\\n\\\n 2:\")\n+\n+#endif /* sh.h */"}, {"sha": "03be1346ebb0e6620dde5e60d072520d6ba057e2", "filename": "gcc/config/v850/v850-protos.h", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b97c5f8ef218afce7499abe8cd3e6eb1f729306/gcc%2Fconfig%2Fv850%2Fv850-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b97c5f8ef218afce7499abe8cd3e6eb1f729306/gcc%2Fconfig%2Fv850%2Fv850-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850-protos.h?ref=8b97c5f8ef218afce7499abe8cd3e6eb1f729306", "patch": "@@ -20,6 +20,9 @@ Boston, MA 02111-1307, USA.  */\n \n /* Function prototypes that cannot exist in v850.h due to dependency\n    compilcations.  */\n+#ifndef GCC_V850_PROTOS_H\n+#define GCC_V850_PROTOS_H\n+\n #define Mmode enum machine_mode\n \n extern void   expand_prologue               PARAMS ((void));\n@@ -41,8 +44,8 @@ extern int    compute_frame_size            PARAMS ((int, long *));\n extern void   print_operand                 PARAMS ((FILE *, rtx, int ));\n extern void   print_operand_address         PARAMS ((FILE *, rtx));\n extern int    const_costs                   PARAMS ((rtx, enum rtx_code));\n-extern char * output_move_double            PARAMS ((rtx *));\n-extern char * output_move_single            PARAMS ((rtx *));\n+extern const char *output_move_double       PARAMS ((rtx *));\n+extern const char *output_move_single       PARAMS ((rtx *));\n extern void   v850_reorg                    PARAMS ((rtx));\n extern void   notice_update_cc              PARAMS ((rtx, rtx));\n extern char * construct_save_jarl           PARAMS ((rtx));\n@@ -80,5 +83,17 @@ extern int    function_arg_partial_nregs    PARAMS ((CUMULATIVE_ARGS *, Mmode, t\n #endif\n #endif\n \n+#ifdef _C_PRAGMA_H\n+extern void ghs_pragma_section\t\t    PARAMS ((cpp_reader *));\n+extern void ghs_pragma_interrupt\t    PARAMS ((cpp_reader *));\n+extern void ghs_pragma_starttda\t\t    PARAMS ((cpp_reader *));\n+extern void ghs_pragma_startsda\t\t    PARAMS ((cpp_reader *));\n+extern void ghs_pragma_startzda\t\t    PARAMS ((cpp_reader *));\n+extern void ghs_pragma_endtda\t\t    PARAMS ((cpp_reader *));\n+extern void ghs_pragma_endsda\t\t    PARAMS ((cpp_reader *));\n+extern void ghs_pragma_endzda\t\t    PARAMS ((cpp_reader *));\n+#endif\n+\n #undef  Mmode\n \n+#endif /* v850-protos.h */"}, {"sha": "e4365e042c8a754f5771baa8ff4eb993360260d6", "filename": "gcc/config/v850/v850.c", "status": "modified", "additions": 138, "deletions": 277, "changes": 415, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b97c5f8ef218afce7499abe8cd3e6eb1f729306/gcc%2Fconfig%2Fv850%2Fv850.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b97c5f8ef218afce7499abe8cd3e6eb1f729306/gcc%2Fconfig%2Fv850%2Fv850.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.c?ref=8b97c5f8ef218afce7499abe8cd3e6eb1f729306", "patch": "@@ -37,7 +37,10 @@ Boston, MA 02111-1307, USA.  */\n #include \"function.h\"\n #include \"obstack.h\"\n #include \"toplev.h\"\n-#include \"v850-protos.h\"\n+#include \"cpplib.h\"\n+#include \"c-lex.h\"\n+#include \"c-pragma.h\"\n+#include \"tm_p.h\"\n \n #ifndef streq\n #define streq(a,b) (strcmp (a, b) == 0)\n@@ -50,7 +53,6 @@ static int  const_costs_int        PARAMS ((HOST_WIDE_INT, int));\n static void substitute_ep_register PARAMS ((rtx, rtx, int, int, rtx *, rtx *));\n static int  push_data_area         PARAMS ((v850_data_area));\n static int  pop_data_area          PARAMS ((v850_data_area));\n-static int  parse_ghs_pragma_token PARAMS ((char *));\n static int  ep_memory_offset       PARAMS ((enum machine_mode, int));\n static int  mark_current_function_as_interrupt PARAMS ((void));\n static void v850_set_data_area     PARAMS ((tree, v850_data_area));\n@@ -441,7 +443,7 @@ print_operand (file, x, code)\n     case 'Q':\n       if (special_symbolref_operand (x, VOIDmode))\n         {\n-          char* name;\n+          const char *name;\n \n \t  if (GET_CODE (x) == SYMBOL_REF)\n \t    name = XSTR (x, 0);\n@@ -667,7 +669,7 @@ print_operand_address (file, addr)\n /* Return appropriate code to load up a 1, 2, or 4 integer/floating\n    point value.  */\n \n-char *\n+const char *\n output_move_single (operands)\n      rtx *operands;\n {\n@@ -759,7 +761,7 @@ output_move_single (operands)\n /* Return appropriate code to load up an 8 byte integer or\n    floating point value */\n \n-char *\n+const char *\n output_move_double (operands)\n     rtx *operands;\n {\n@@ -2726,292 +2728,151 @@ mark_current_function_as_interrupt ()\n     (name, NULL_TREE, current_function_decl, NULL_TREE);\n }\n \n-/* Parse STRING as part of a GHS pragma.\n-   Returns 0 if the pragma has been parsed and there was a problem,\n-   non-zero in all other cases.  */\n-static int\n-parse_ghs_pragma_token (string)\n-     char * string;\n+/* Support for GHS pragmata.  */\n+\n+void\n+ghs_pragma_section (pfile)\n+     cpp_reader *pfile ATTRIBUTE_UNUSED;\n {\n-  static enum v850_pragma_state state = V850_PS_START;\n-  static enum v850_pragma_type  type  = V850_PT_UNKNOWN;\n-  static v850_data_area         data_area = DATA_AREA_NORMAL;\n-  static char *                 data_area_name;\n-  static enum GHS_section_kind  GHS_section_kind = GHS_SECTION_KIND_DEFAULT;\n-\n-  /* If the string is NULL then we have reached the end of the\n-     #pragma construct.  Make sure that we are in an end state, and\n-     then implement the pragma's directive.  */\n-  if (string == NULL)\n-    {\n-      int ret_val = 1;\n-      \n-      if (state != V850_PS_SHOULD_BE_DONE\n-\t  && state != V850_PS_MAYBE_COMMA\n-\t  && state != V850_PS_MAYBE_SECTION_NAME)\n-\t{\n-\t  if (state != V850_PS_BAD)\n-\t    warning (\"Incomplete #pragma ghs\");\n+  int repeat;\n+\n+  /* #pragma ghs section [name = alias [, name = alias [, ...]]] */\n+  do {\n+    tree x;\n+    enum cpp_ttype type;\n+    const char *sect, *alias;\n+    enum GHS_section_kind kind;\n+\n+    type = c_lex (&x);\n+    if (type == CPP_EOF && !repeat)\n+      goto reset;\n+    else if (type == CPP_NAME)\n+      sect = IDENTIFIER_POINTER (x);\n+    else\n+      goto bad;\n+    repeat = 0;\n+\n+    if (c_lex (&x) != CPP_EQ)\n+      goto bad;\n+    if (c_lex (&x) != CPP_NAME)\n+      goto bad;\n+    alias = IDENTIFIER_POINTER (x);\n+\n+    type = c_lex (&x);\n+    if (type == CPP_COMMA)\n+      repeat = 1;\n+    else if (type != CPP_EOF)\n+      warning (\"junk at end of #pragma ghs section\");\n+\n+    if      (streq (sect, \"data\"))    kind = GHS_SECTION_KIND_DATA;\n+    else if (streq (sect, \"text\"))    kind = GHS_SECTION_KIND_TEXT;\n+    else if (streq (sect, \"rodata\"))  kind = GHS_SECTION_KIND_RODATA;\n+    else if (streq (sect, \"const\"))   kind = GHS_SECTION_KIND_RODATA;\n+    else if (streq (sect, \"rosdata\")) kind = GHS_SECTION_KIND_ROSDATA;\n+    else if (streq (sect, \"rozdata\")) kind = GHS_SECTION_KIND_ROZDATA;\n+    else if (streq (sect, \"sdata\"))   kind = GHS_SECTION_KIND_SDATA;\n+    else if (streq (sect, \"tdata\"))   kind = GHS_SECTION_KIND_TDATA;\n+    else if (streq (sect, \"zdata\"))   kind = GHS_SECTION_KIND_ZDATA;\n+    /* According to GHS beta documentation, the following should not be\n+       allowed!  */\n+    else if (streq (sect, \"bss\"))     kind = GHS_SECTION_KIND_BSS;\n+    else if (streq (sect, \"zbss\"))    kind = GHS_SECTION_KIND_ZDATA;\n+    else\n+      {\n+\twarning (\"unrecognised section name \\\"%s\\\"\", sect);\n+\treturn;\n+      }\n \n-\t  ret_val = 0;\n-\t}\n-      else switch (type)\n-\t{\n-\tcase V850_PT_UNKNOWN:\n-\t  warning (\"Nothing follows #pragma ghs\");\n-\t  ret_val = 0;\n-\t  break;\n-\t  \n-\tcase V850_PT_INTERRUPT:\n-\t  ret_val = mark_current_function_as_interrupt ();\n-\t  break;\n-\t  \n-\tcase V850_PT_SECTION:\n-\t  /* If a section kind has not been specified, then reset\n-\t     all section names back to their defaults.  */\n-\t  if (GHS_section_kind == GHS_SECTION_KIND_DEFAULT)\n-\t    {\n-\t      int i;\n-\t      \n-\t      for (i = COUNT_OF_GHS_SECTION_KINDS; i--;)\n-\t\tGHS_current_section_names [i] = NULL;\n-\t    }\n-\t  /* If a section has been specified, then this will be handled\n-\t     by check_default_section_name ().  */\n-\t  break;\n-\t  \n-\tcase V850_PT_START_SECTION:\n-\t  ret_val = push_data_area (data_area);\n-\t  break;\n-\t  \n-\tcase V850_PT_END_SECTION:\n-\t  ret_val = pop_data_area (data_area);\n-\t  break;\n-\t}\n+    if (streq (alias, \"default\"))\n+      GHS_current_section_names [kind] = NULL;\n+    else\n+      GHS_current_section_names [kind] =\n+\tbuild_string (strlen (alias) + 1, alias);\n \n-      state = V850_PS_START;\n-      type  = V850_PT_UNKNOWN;\n-      \n-      return ret_val;\n-    }\n-  \n-  switch (state)\n-    {\n-    case V850_PS_START:\n-      data_area = DATA_AREA_NORMAL;\n-      data_area_name = NULL;\n-      \n-      if (streq (string, \"interrupt\"))\n-\t{\n-\t  type = V850_PT_INTERRUPT;\n-\t  state = V850_PS_SHOULD_BE_DONE;\n-\t}\n-      else if (streq (string, \"section\"))\n-\t{\n-\t  type = V850_PT_SECTION;\n-\t  state = V850_PS_MAYBE_SECTION_NAME;\n-\t  GHS_section_kind = GHS_SECTION_KIND_DEFAULT;\n-\t}\n-      else if (streq (string, \"starttda\"))\n-\t{\n-\t  type = V850_PT_START_SECTION;\n-\t  state = V850_PS_SHOULD_BE_DONE;\n-\t  data_area = DATA_AREA_TDA;\n-\t}\n-      else if (streq (string, \"endtda\"))\n-\t{\n-\t  type = V850_PT_END_SECTION;\n-\t  state = V850_PS_SHOULD_BE_DONE;\n-\t  data_area = DATA_AREA_TDA;\n-\t}\n-      else if (streq (string, \"startsda\"))\n-\t{\n-\t  type = V850_PT_START_SECTION;\n-\t  state = V850_PS_SHOULD_BE_DONE;\n-\t  data_area = DATA_AREA_SDA;\n-\t}\n-      else if (streq (string, \"endsda\"))\n-\t{\n-\t  type = V850_PT_END_SECTION;\n-\t  state = V850_PS_SHOULD_BE_DONE;\n-\t  data_area = DATA_AREA_SDA;\n-\t}\n-      else if (streq (string, \"startzda\"))\n-\t{\n-\t  type = V850_PT_START_SECTION;\n-\t  state = V850_PS_SHOULD_BE_DONE;\n-\t  data_area = DATA_AREA_ZDA;\n-\t}\n-      else if (streq (string, \"endzda\"))\n-\t{\n-\t  type = V850_PT_END_SECTION;\n-\t  state = V850_PS_SHOULD_BE_DONE;\n-\t  data_area = DATA_AREA_ZDA;\n-\t}\n-      else\n-\t{\n-\t  warning (\"Unrecognised GHS pragma: '%s'\\n\", string);\n-\t  state = V850_PS_BAD;\n-\t}\n-      break;\n-      \n-    case V850_PS_SHOULD_BE_DONE:\n-      warning (\"Extra text after valid #pragma: '%s'\", string);\n-      state = V850_PS_BAD;\n-      break;\n-      \n-    case V850_PS_BAD:\n-      /* Ignore tokens in a pragma that has been diagnosed as being corrupt. */\n-      break;\n+  } while (repeat);\n+  return;\n \n-    case V850_PS_MAYBE_SECTION_NAME:\n-      state = V850_PS_EXPECTING_EQUALS;\n-      \n-           if (streq (string, \"data\"))\t  GHS_section_kind = GHS_SECTION_KIND_DATA;\n-      else if (streq (string, \"text\"))\t  GHS_section_kind = GHS_SECTION_KIND_TEXT;\n-      else if (streq (string, \"rodata\"))  GHS_section_kind = GHS_SECTION_KIND_RODATA;\n-      else if (streq (string, \"const\"))\t  GHS_section_kind = GHS_SECTION_KIND_RODATA;\n-      else if (streq (string, \"rosdata\")) GHS_section_kind = GHS_SECTION_KIND_ROSDATA;\n-      else if (streq (string, \"rozdata\")) GHS_section_kind = GHS_SECTION_KIND_ROZDATA;\n-      else if (streq (string, \"sdata\"))\t  GHS_section_kind = GHS_SECTION_KIND_SDATA;\n-      else if (streq (string, \"tdata\"))\t  GHS_section_kind = GHS_SECTION_KIND_TDATA;\n-      else if (streq (string, \"zdata\"))\t  GHS_section_kind = GHS_SECTION_KIND_ZDATA;\n-      /* According to GHS beta documentation, the following should not be allowed!  */\n-      else if (streq (string, \"bss\"))\t  GHS_section_kind = GHS_SECTION_KIND_BSS;\n-      else if (streq (string, \"zbss\"))\t  GHS_section_kind = GHS_SECTION_KIND_ZDATA;\n-      else\n-\t{\n-\t  warning (\"Unrecognised section name '%s' in GHS section pragma\",\n-\t\t   string);\n-\t  state = V850_PS_BAD;\n-\t}\n-      break;\n+ bad:\n+  warning (\"malformed #pragma ghs section\");\n+  return;\n \n-    case V850_PS_EXPECTING_EQUALS:\n-      if (streq (string, \"=\"))\n-\tstate = V850_PS_EXPECTING_SECTION_ALIAS;\n-      else\n-\t{\n-\t  warning (\"Missing '=' in GHS section pragma\");\n-\t  state = V850_PS_BAD;\n-\t}\n-      break;\n-      \n-    case V850_PS_EXPECTING_SECTION_ALIAS:\n-      if (streq (string, \"default\"))\n-\tGHS_current_section_names [GHS_section_kind] = NULL;\n-      else\n-\tGHS_current_section_names [GHS_section_kind] =\n-\t  build_string (strlen (string) + 1, string);\n-      \n-      state = V850_PS_MAYBE_COMMA;\n-      break;\n-      \n-    case V850_PS_MAYBE_COMMA:\n-      if (streq (string, \",\"))\n-\tstate = V850_PS_MAYBE_SECTION_NAME;\n-      else\n-\t{\n-\t  warning\n-\t    (\"Malformed GHS section pragma: found '%s' instead of a comma\",\n-\t     string);\n-\t  state = V850_PS_BAD;\n-\t}\n-      break;\n-    }\n-  \n-  return 1;\n+ reset:\n+  /* #pragma ghs section \\n: Reset all section names back to their defaults.  */\n+  {\n+    int i;\n+    for (i = COUNT_OF_GHS_SECTION_KINDS; i--;)\n+      GHS_current_section_names [i] = NULL;\n+  }\n }\n \n-/* Handle the parsing of an entire GHS pragma.  */\n-int\n-v850_handle_pragma (p_getc, p_ungetc, name)\n-     int (*  p_getc) PARAMS ((void));\n-     void (* p_ungetc) PARAMS ((int));\n-     char *  name;\n+void\n+ghs_pragma_interrupt (pfile)\n+     cpp_reader *pfile ATTRIBUTE_UNUSED;\n {\n-  /* Parse characters in the input stream until:\n-\n-   * end of line\n-   * end of file\n-   * a complete GHS pragma has been parsed\n-   * a corrupted GHS pragma has been parsed\n-   * an unknown pragma is encountered.\n-\n-   If an unknown pragma is encountered, we must return with\n-   the input stream in the same state as upon entry to this function.\n-   \n-   The first token in the input stream has already been parsed\n-   for us, and is passed as 'name'.  */\n-  \n-  if (! streq (name, \"ghs\"))\n-    return 0;\n-\n-  /* We now know that we are parsing a GHS pragma, so we do\n-     not need to preserve the original input stream state.  */\n-  for (;;)\n-    {\n-      static char buffer [128];\n-      int         c;\n-      char *      buff;\n-      \n-      /* Skip white space.  */\n-      do\n-\tc = p_getc ();\n-      while (c == ' ' || c == '\\t');\n-      \n-      p_ungetc (c);\n-      \n-      if (c == '\\n' || c == EOF || c == '\\r')\n-\treturn parse_ghs_pragma_token (NULL);\n+  tree x;\n+  if (c_lex (&x) != CPP_EOF)\n+    warning (\"junk at end of #pragma ghs interrupt\");\n+  mark_current_function_as_interrupt ();\n+}\n \n-      /* Read next word.  We have to do the parsing ourselves, rather\n-\t than calling yylex() because we can be built with front ends\n-\t that do not provide such functions.  */\n-      buff = buffer;\n-      * buff ++ = (c = p_getc ());\n+void\n+ghs_pragma_starttda (pfile)\n+     cpp_reader *pfile ATTRIBUTE_UNUSED;\n+{\n+  tree x;\n+  if (c_lex (&x) != CPP_EOF)\n+    warning (\"junk at end of #pragma ghs starttda\");\n+  push_data_area (DATA_AREA_TDA);\n+}\n \n-      switch (c)\n-\t{\n-\tcase ',':\n-\tcase '=':\n-\t  * buff ++ = (c = p_getc ());\n-\t  break;\n-\t  \n-\tcase '\"':\n-\t  /* Skip opening double parenthesis.  */\n-\t  -- buff;\n-\n-\t  /* Read string.  */\n-\t  do\n-\t    * buff ++ = (c = p_getc ());\n-\t  while (c != EOF && (ISALNUM (c) || c == '_' || c == '.' || c == ' ')\n-\t\t && (buff < buffer + 126));\n-\t  \n-\t  if (c != '\"')\n-\t    warning (\"Missing trailing \\\" in #pragma ghs\");\n-\t  else\n-\t    c = p_getc ();\n-\t  break;\n+void\n+ghs_pragma_startsda (pfile)\n+     cpp_reader *pfile ATTRIBUTE_UNUSED;\n+{\n+  tree x;\n+  if (c_lex (&x) != CPP_EOF)\n+    warning (\"junk at end of #pragma ghs startsda\");\n+  push_data_area (DATA_AREA_SDA);\n+}\n \n-\tdefault:\n-\t  while (c != EOF && (ISALNUM (c) || c == '_' || c == '.')\n-\t\t && (buff < buffer + 126))\n-\t    * buff ++ = (c = p_getc ());\n-\t  break;\n-\t}\n+void\n+ghs_pragma_startzda (pfile)\n+     cpp_reader *pfile ATTRIBUTE_UNUSED;\n+{\n+  tree x;\n+  if (c_lex (&x) != CPP_EOF)\n+    warning (\"junk at end of #pragma ghs startzda\");\n+  push_data_area (DATA_AREA_ZDA);\n+}\n \n-      p_ungetc (c);\n+void\n+ghs_pragma_endtda (pfile)\n+     cpp_reader *pfile ATTRIBUTE_UNUSED;\n+{\n+  tree x;\n+  if (c_lex (&x) != CPP_EOF)\n+    warning (\"junk at end of #pragma ghs endtda\");\n+  pop_data_area (DATA_AREA_TDA);\n+}\n \n-      /* If nothing was read then terminate the parsing.  */\n-      if (buff == buffer + 1)\n-\treturn parse_ghs_pragma_token (NULL);\n+void\n+ghs_pragma_endsda (pfile)\n+     cpp_reader *pfile ATTRIBUTE_UNUSED;\n+{\n+  tree x;\n+  if (c_lex (&x) != CPP_EOF)\n+    warning (\"junk at end of #pragma ghs endsda\");\n+  pop_data_area (DATA_AREA_SDA);\n+}\n \n-      /* Parse and continue.  */\n-      * -- buff = 0;\n-      \n-      parse_ghs_pragma_token (buffer);\n-    }\n+void\n+ghs_pragma_endzda (pfile)\n+     cpp_reader *pfile ATTRIBUTE_UNUSED;\n+{\n+  tree x;\n+  if (c_lex (&x) != CPP_EOF)\n+    warning (\"junk at end of #pragma ghs endzda\");\n+  pop_data_area (DATA_AREA_ZDA);\n }\n \n /* Add data area to the given declaration if a ghs data area pragma is"}, {"sha": "dfe4b20e4c18a0faf0a40151bf48c0c44b411c3e", "filename": "gcc/config/v850/v850.h", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b97c5f8ef218afce7499abe8cd3e6eb1f729306/gcc%2Fconfig%2Fv850%2Fv850.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b97c5f8ef218afce7499abe8cd3e6eb1f729306/gcc%2Fconfig%2Fv850%2Fv850.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.h?ref=8b97c5f8ef218afce7499abe8cd3e6eb1f729306", "patch": "@@ -19,6 +19,9 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n+#ifndef GCC_V850_H\n+#define GCC_V850_H\n+\n #include \"svr4.h\"\t/* Automatically does #undef CPP_PREDEFINES */\n \n /* These are defiend in svr4.h but we want to override them.  */\n@@ -138,7 +141,7 @@ extern int target_flags;\n \n /* Information about the various small memory areas.  */\n struct small_memory_info {\n-  char *name;\n+  const char *name;\n   const char *value;\n   long max;\n   long physical_max;\n@@ -1505,27 +1508,17 @@ do { char dstr[30];\t\t\t\t\t\\\n      v850_set_default_decl_attr (decl)\n \n /* Tell compiler we want to support GHS pragmas */\n-#define HANDLE_PRAGMA(get, unget, name) v850_handle_pragma (get, unget, name)\n-\n-enum v850_pragma_state\n-{\n-  V850_PS_START,\n-  V850_PS_SHOULD_BE_DONE,\n-  V850_PS_BAD,\n-  V850_PS_MAYBE_SECTION_NAME,\n-  V850_PS_EXPECTING_EQUALS,\n-  V850_PS_EXPECTING_SECTION_ALIAS,\n-  V850_PS_MAYBE_COMMA\n-};\n-\n-enum v850_pragma_type\n-{\n-  V850_PT_UNKNOWN,\n-  V850_PT_INTERRUPT,\n-  V850_PT_SECTION,\n-  V850_PT_START_SECTION,\n-  V850_PT_END_SECTION\n-};\n+#define REGISTER_TARGET_PRAGMAS(PFILE) do {\t\t\t\t  \\\n+  cpp_register_pragma_space (PFILE, \"ghs\");\t\t\t\t  \\\n+  cpp_register_pragma (PFILE, \"ghs\", \"interrupt\", ghs_pragma_interrupt);  \\\n+  cpp_register_pragma (PFILE, \"ghs\", \"section\",   ghs_pragma_section);    \\\n+  cpp_register_pragma (PFILE, \"ghs\", \"starttda\",  ghs_pragma_starttda);   \\\n+  cpp_register_pragma (PFILE, \"ghs\", \"startsda\",  ghs_pragma_startsda);   \\\n+  cpp_register_pragma (PFILE, \"ghs\", \"startzda\",  ghs_pragma_startzda);   \\\n+  cpp_register_pragma (PFILE, \"ghs\", \"endtda\",    ghs_pragma_endtda);\t  \\\n+  cpp_register_pragma (PFILE, \"ghs\", \"endsda\",    ghs_pragma_endsda);\t  \\\n+  cpp_register_pragma (PFILE, \"ghs\", \"endzda\",    ghs_pragma_endzda);\t  \\\n+} while (0)\n \n /* enum GHS_SECTION_KIND is an enumeration of the kinds of sections that\n    can appear in the \"ghs section\" pragma.  These names are used to index\n@@ -1621,3 +1614,4 @@ enum GHS_section_kind\n { \"register_is_ok_for_epilogue\",{ REG }},\t\t\t\t\\\n { \"not_power_of_two_operand\",\t{ CONST_INT }},\n   \n+#endif /* v850.h */"}, {"sha": "75f038f842f0e08dee7270cac7f84ef9253cf239", "filename": "gcc/cpplib.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b97c5f8ef218afce7499abe8cd3e6eb1f729306/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b97c5f8ef218afce7499abe8cd3e6eb1f729306/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=8b97c5f8ef218afce7499abe8cd3e6eb1f729306", "patch": "@@ -28,7 +28,10 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n extern \"C\" {\n #endif\n \n+/* For complex reasons, cpp_reader is also typedefed in c-pragma.h.  */\n+#ifndef _C_PRAGMA_H\n typedef struct cpp_reader cpp_reader;\n+#endif\n typedef struct cpp_buffer cpp_buffer;\n typedef struct cpp_options cpp_options;\n typedef struct cpp_printer cpp_printer;"}, {"sha": "41ce0ee0e034d18a45e7569b1cfd935e18871f2f", "filename": "gcc/tm.texi", "status": "modified", "additions": 50, "deletions": 21, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b97c5f8ef218afce7499abe8cd3e6eb1f729306/gcc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b97c5f8ef218afce7499abe8cd3e6eb1f729306/gcc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftm.texi?ref=8b97c5f8ef218afce7499abe8cd3e6eb1f729306", "patch": "@@ -7774,33 +7774,62 @@ C++, which is to pretend that the file's contents are enclosed in\n @samp{extern \"C\" @{@dots{}@}}.\n \n @findex HANDLE_PRAGMA\n+@item HANDLE_PRAGMA (@var{getc}, @var{ungetc}, @var{name})\n+This macro is no longer supported.  You must use\n+@code{REGISTER_TARGET_PRAGMAS} instead.\n+\n+@findex REGISTER_TARGET_PRAGMAS\n @findex #pragma\n @findex pragma\n-@item HANDLE_PRAGMA (@var{getc}, @var{ungetc}, @var{name})\n-Define this macro if you want to implement any pragmas.  If defined, it\n-is a C expression whose value is 1 if the pragma was handled by the\n-macro, zero otherwise.  The argument @var{getc} is a function of type\n-@samp{int (*)(void)} which will return the next character in the input\n-stream, or EOF if no characters are left.  The argument @var{ungetc} is\n-a function of type @samp{void (*)(int)} which will push a character back\n-into the input stream.  The argument @var{name} is the word following\n-#pragma in the input stream.  The input stream pointer will be pointing\n-just beyond the end of this word.  The input stream should be left\n-undistrubed if the expression returns zero, otherwise it should be\n-pointing at the next character after the end of the pragma.  Any\n-characters remaining on the line will be ignored.\n-\n-It is generally a bad idea to implement new uses of @code{#pragma}.  The\n-only reason to define this macro is for compatibility with other\n-compilers that do support @code{#pragma} for the sake of any user\n-programs which already use it.\n+@item REGISTER_TARGET_PRAGMAS (@var{pfile})\n+Define this macro if you want to implement any target-specific pragmas.\n+If defined, it is a C expression which makes a series of calls to the\n+@code{cpp_register_pragma} and/or @code{cpp_register_pragma_space}\n+functions.  The @var{pfile} argument is the first argument to supply to\n+these functions.  The macro may also do setup required for the pragmas.\n+\n+The primary reason to define this macro is to provide compatibility with\n+other compilers for the same target.  In general, we discourage\n+definition of target-specific pragmas for GCC.\n \n If the pragma can be implemented by atttributes then the macro\n @samp{INSERT_ATTRIBUTES} might be a useful one to define as well.\n \n-Note: older versions of this macro only had two arguments: @var{stream}\n-and @var{token}.  The macro was changed in order to allow it to work\n-when gcc is built both with and without a cpp library.\n+Preprocessor macros that appear on pragma lines are not expanded.  All\n+@samp{#pragma} directives that do not match any registered pragma are\n+silently ignored, unless the user specifies @samp{-Wunknown-pragmas}.\n+\n+@deftypefun void cpp_register_pragma (cpp_reader *@var{pfile}, const char *@var{space}, const char *@var{name}, void (*@var{callback}) (cpp_reader *))\n+\n+Each call to @code{cpp_register_pragma} establishes one pragma.  The\n+@var{callback} routine will be called when the preprocessor encounters a\n+pragma of the form\n+\n+@smallexample\n+#pragma [@var{space}] @var{name} @dots{}\n+@end smallexample\n+\n+@var{space} must have been the subject of a previous call to\n+@code{cpp_register_pragma_space}, or else be a null pointer.  The\n+callback routine receives @var{pfile} as its first argument, but must\n+not use it for anything (this may change in the future).  It may read\n+any text after the @var{name} by making calls to @code{c_lex}.  Text\n+which is not read by the callback will be silently ignored.\n+\n+Note that both @var{space} and @var{name} are case sensitive.\n+\n+For an example use of this routine, see @file{c4x.h} and the callback\n+routines defined in @file{c4x.c}.\n+@end deftypefun\n+\n+@deftypefun void cpp_register_pragma_space (cpp_reader *@var{pfile}, const char *@var{space})\n+This routine establishes a namespace for pragmas, which will be\n+registered by subsequent calls to @code{cpp_register_pragma}.  For\n+example, pragmas defined by the C standard are in the @samp{STDC}\n+namespace, and pragmas specific to GCC are in the @samp{GCC} namespace.\n+\n+For an example use of this routine in a target header, see @file{v850.h}.\n+@end deftypefun\n \n @findex HANDLE_SYSV_PRAGMA\n @findex #pragma"}]}