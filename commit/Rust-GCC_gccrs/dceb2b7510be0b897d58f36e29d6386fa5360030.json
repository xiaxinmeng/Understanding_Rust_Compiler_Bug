{"sha": "dceb2b7510be0b897d58f36e29d6386fa5360030", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGNlYjJiNzUxMGJlMGI4OTdkNThmMzZlMjlkNjM4NmZhNTM2MDAzMA==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@redhat.com", "date": "2002-05-21T23:11:57Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2002-05-21T23:11:57Z"}, "message": "genautomata.c (reserv_sets_hash_value): Define hash_value as set_el_t.\n\n2002-05-21  Vladimir Makarov  <vmakarov@redhat.com>\n\n\t* genautomata.c (reserv_sets_hash_value): Define hash_value as\n\tset_el_t.  Transform the hash value into unsigned.\n\t(output_cycle_reservs): Fix bug with output of repeated `nothing'.\n\t(transform_3): Add code to process `(A,B)+(D,E)'.\n\nFrom-SVN: r53709", "tree": {"sha": "0b41491ed78feeaabc33adc16b9cb15258b34b27", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0b41491ed78feeaabc33adc16b9cb15258b34b27"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dceb2b7510be0b897d58f36e29d6386fa5360030", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dceb2b7510be0b897d58f36e29d6386fa5360030", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dceb2b7510be0b897d58f36e29d6386fa5360030", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dceb2b7510be0b897d58f36e29d6386fa5360030/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "159d596446f8366f682b46db9d89a5473bbec279", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/159d596446f8366f682b46db9d89a5473bbec279", "html_url": "https://github.com/Rust-GCC/gccrs/commit/159d596446f8366f682b46db9d89a5473bbec279"}], "stats": {"total": 134, "additions": 95, "deletions": 39}, "files": [{"sha": "15ba56be975f1a2a13267f28e792f9826394a068", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dceb2b7510be0b897d58f36e29d6386fa5360030/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dceb2b7510be0b897d58f36e29d6386fa5360030/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dceb2b7510be0b897d58f36e29d6386fa5360030", "patch": "@@ -1,3 +1,10 @@\n+2002-05-21  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\t* genautomata.c (reserv_sets_hash_value): Define hash_value as\n+\tset_el_t.  Transform the hash value into unsigned.\n+\t(output_cycle_reservs): Fix bug with output of repeated `nothing'.\n+\t(transform_3): Add code to process `(A,B)+(D,E)'.\n+\n 2002-05-21  NIIBE Yutaka  <gniibe@m17n.org>\n \n \t* reload1.c (do_output_reload): Run delete_output_reload"}, {"sha": "faf631d3d3b424b04583044fd4d4198349cb6df1", "filename": "gcc/genautomata.c", "status": "modified", "additions": 88, "deletions": 39, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dceb2b7510be0b897d58f36e29d6386fa5360030/gcc%2Fgenautomata.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dceb2b7510be0b897d58f36e29d6386fa5360030/gcc%2Fgenautomata.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenautomata.c?ref=dceb2b7510be0b897d58f36e29d6386fa5360030", "patch": "@@ -3391,21 +3391,34 @@ static unsigned\n reserv_sets_hash_value (reservs)\n      reserv_sets_t reservs;\n {\n-  unsigned int hash_value;\n-  int reservs_num;\n+  set_el_t hash_value;\n+  unsigned result;\n+  int reservs_num, i;\n   set_el_t *reserv_ptr;\n \n   hash_value = 0;\n   reservs_num = els_in_reservs;\n   reserv_ptr = reservs;\n+  i = 0;\n   while (reservs_num != 0)\n     {\n       reservs_num--;\n-      hash_value = ((hash_value >> (sizeof (unsigned) - 1) * CHAR_BIT)\n-                    | (hash_value << CHAR_BIT)) + *reserv_ptr;\n+      hash_value += ((*reserv_ptr >> i)\n+\t\t     | (*reserv_ptr << (sizeof (set_el_t) * CHAR_BIT - i)));\n+      i++;\n+      if (i == sizeof (set_el_t) * CHAR_BIT)\n+\ti = 0;\n       reserv_ptr++;\n     }\n-  return hash_value;\n+  if (sizeof (set_el_t) < sizeof (unsigned))\n+    return hash_value;\n+  result = 0;\n+  for (i = sizeof (set_el_t); i > 0; i -= sizeof (unsigned))\n+    {\n+      result += (unsigned) hash_value;\n+      hash_value >>= sizeof (unsigned) * CHAR_BIT;\n+    }\n+  return result;\n }\n \n /* Comparison of given reservation sets.  */\n@@ -3638,12 +3651,10 @@ output_cycle_reservs (f, reservs, start_cycle, repetition_num)\n     fprintf (f, NOTHING_NAME);\n   if (repetition_num <= 0)\n     abort ();\n-  if (reserved_units_num != 0 && repetition_num != 1)\n-    {\n-      if (reserved_units_num > 1)\n-        fprintf (f, \")\");\n-      fprintf (f, \"*%d\", repetition_num);\n-    }\n+  if (reserved_units_num > 1)\n+    fprintf (f, \")\");\n+  if (repetition_num != 1)\n+    fprintf (f, \"*%d\", repetition_num);\n }\n \n /* The function outputs string representation of units reservation in\n@@ -4638,7 +4649,8 @@ transform_2 (regexp)\n /* The function makes transformations\n    ...,A|B|...,C,... -> (...,A,C,...)|(...,B,C,...)|...\n    ...+(A|B|...)+C+... -> (...+A+C+...)|(...+B+C+...)|...\n-   ...+(A,B,...)+C+... -> (...+A+C+...),B,...  */\n+   ...+(A,B,...)+C+... -> (...+A+C+...),B,...\n+   ...+(A,B,...)+(C,D,...) -> (A+C),(B+D),...  */\n static regexp_t\n transform_3 (regexp)\n      regexp_t regexp;\n@@ -4695,9 +4707,9 @@ transform_3 (regexp)\n   else if (regexp->mode == rm_allof)\n     {\n       regexp_t oneof, seq;\n-      int oneof_index, seq_index;\n+      int oneof_index, max_seq_length, allof_length;\n       regexp_t result;\n-      regexp_t allof;\n+      regexp_t allof, allof_op;\n       int i, j;\n \n       for (i = 0; i < regexp->regexp.allof.regexps_num; i++)\n@@ -4740,42 +4752,79 @@ transform_3 (regexp)\n \t  regexp_transformed_p = 1;\n \t  regexp = result;\n \t}\n+      max_seq_length = 0;\n       for (i = 0; i < regexp->regexp.allof.regexps_num; i++)\n \tif (regexp->regexp.allof.regexps [i]->mode == rm_sequence)\n \t  {\n-\t    seq_index = i;\n \t    seq = regexp->regexp.allof.regexps [i];\n+\t    if (max_seq_length < seq->regexp.sequence.regexps_num)\n+\t      max_seq_length = seq->regexp.sequence.regexps_num;\n+\t  }\n+\telse if (regexp->regexp.allof.regexps [i]->mode != rm_unit)\n+\t  {\n+\t    max_seq_length = 0;\n \t    break;\n \t  }\n-      if (i < regexp->regexp.allof.regexps_num)\n+      if (max_seq_length != 0)\n \t{\n-\t  if (seq->regexp.sequence.regexps_num <= 1\n-\t      || regexp->regexp.allof.regexps_num <= 1)\n+\t  if (max_seq_length == 1 || regexp->regexp.allof.regexps_num <= 1)\n \t    abort ();\n \t  result = create_node (sizeof (struct regexp)\n-\t\t\t\t+ sizeof (regexp_t)\n-\t\t\t\t* (seq->regexp.sequence.regexps_num - 1));\n+\t\t\t\t+ sizeof (regexp_t) * (max_seq_length - 1));\n \t  result->mode = rm_sequence;\n \t  result->pos = regexp->pos;\n-\t  result->regexp.sequence.regexps_num\n-\t    = seq->regexp.sequence.regexps_num;\n-\t  allof = create_node (sizeof (struct regexp)\n-\t\t\t       + sizeof (regexp_t)\n-\t\t\t       * (regexp->regexp.allof.regexps_num - 1));\n-\t  allof->mode = rm_allof;\n-\t  allof->pos = regexp->pos;\n-\t  allof->regexp.allof.regexps_num = regexp->regexp.allof.regexps_num;\n-\t  result->regexp.sequence.regexps [0] = allof;\n-\t  for (j = 0; j < allof->regexp.allof.regexps_num; j++)\n-\t    if (j != seq_index)\n-\t      allof->regexp.allof.regexps [j]\n-\t\t= copy_insn_regexp (regexp->regexp.allof.regexps [j]);\n-\t    else\n-\t      allof->regexp.allof.regexps [j]\n-\t\t= copy_insn_regexp (seq->regexp.sequence.regexps [0]);\n-\t  for (i = 1; i < result->regexp.sequence.regexps_num; i++)\n-\t    result->regexp.sequence.regexps [i]\n-\t      = copy_insn_regexp (seq->regexp.sequence.regexps [i]);\n+\t  result->regexp.sequence.regexps_num = max_seq_length;\n+\t  for (i = 0; i < max_seq_length; i++)\n+\t    {\n+\t      allof_length = 0;\n+\t      for (j = 0; j < regexp->regexp.allof.regexps_num; j++)\n+\t\tif (regexp->regexp.allof.regexps [j]->mode == rm_sequence\n+\t\t    && (i < (regexp->regexp.allof.regexps [j]\n+\t\t\t     ->regexp.sequence.regexps_num)))\n+\t\t  {\n+\t\t    allof_op = (regexp->regexp.allof.regexps [j]\n+\t\t\t\t->regexp.sequence.regexps [i]);\n+\t\t    allof_length++;\n+\t\t  }\n+\t\telse if (i == 0\n+\t\t\t && regexp->regexp.allof.regexps [j]->mode == rm_unit)\n+\t\t  {\n+\t\t    allof_op = regexp->regexp.allof.regexps [j];\n+\t\t    allof_length++;\n+\t\t  }\n+\t      if (allof_length == 1)\n+\t\tresult->regexp.sequence.regexps [i] = allof_op;\n+\t      else\n+\t\t{\n+\t\t  allof = create_node (sizeof (struct regexp)\n+\t\t\t\t       + sizeof (regexp_t)\n+\t\t\t\t       * (allof_length - 1));\n+\t\t  allof->mode = rm_allof;\n+\t\t  allof->pos = regexp->pos;\n+\t\t  allof->regexp.allof.regexps_num = allof_length;\n+\t\t  result->regexp.sequence.regexps [i] = allof;\n+\t\t  allof_length = 0;\n+\t\t  for (j = 0; j < regexp->regexp.allof.regexps_num; j++)\n+\t\t    if (regexp->regexp.allof.regexps [j]->mode == rm_sequence\n+\t\t\t&& (i < (regexp->regexp.allof.regexps [j]\n+\t\t\t\t ->regexp.sequence.regexps_num)))\n+\t\t      {\n+\t\t\tallof_op = (regexp->regexp.allof.regexps [j]\n+\t\t\t\t    ->regexp.sequence.regexps [i]);\n+\t\t\tallof->regexp.allof.regexps [allof_length] = allof_op;\n+\t\t\t\n+\t\t\tallof_length++;\n+\t\t      }\n+\t\t    else if (i == 0\n+\t\t\t     && (regexp->regexp.allof.regexps [j]->mode\n+\t\t\t\t == rm_unit))\n+\t\t      {\n+\t\t\tallof_op = regexp->regexp.allof.regexps [j];\n+\t\t\tallof->regexp.allof.regexps [allof_length] = allof_op;\n+\t\t\tallof_length++;\n+\t\t      }\n+\t\t}\n+\t    }\n \t  regexp_transformed_p = 1;\n \t  regexp = result;\n \t}"}]}