{"sha": "0e48b5a21ba89dd535e99bb1704110a5a9ff0287", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGU0OGI1YTIxYmE4OWRkNTM1ZTk5YmIxNzA0MTEwYTVhOWZmMDI4Nw==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-01-29T03:42:48Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-01-29T03:42:48Z"}, "message": "Initial revision\n\nFrom-SVN: r247", "tree": {"sha": "ba662b106b34cf46c3e90cce5da0990c2543dc2a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ba662b106b34cf46c3e90cce5da0990c2543dc2a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0e48b5a21ba89dd535e99bb1704110a5a9ff0287", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e48b5a21ba89dd535e99bb1704110a5a9ff0287", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e48b5a21ba89dd535e99bb1704110a5a9ff0287", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e48b5a21ba89dd535e99bb1704110a5a9ff0287/comments", "author": null, "committer": null, "parents": [{"sha": "231ddcb73423479b1644e7422ab008afa9e1ef51", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/231ddcb73423479b1644e7422ab008afa9e1ef51", "html_url": "https://github.com/Rust-GCC/gccrs/commit/231ddcb73423479b1644e7422ab008afa9e1ef51"}], "stats": {"total": 397, "additions": 397, "deletions": 0}, "files": [{"sha": "968f74488e3369c141c2ba64a8e1df0e16de8740", "filename": "gcc/c-convert.c", "status": "added", "additions": 397, "deletions": 0, "changes": 397, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e48b5a21ba89dd535e99bb1704110a5a9ff0287/gcc%2Fc-convert.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e48b5a21ba89dd535e99bb1704110a5a9ff0287/gcc%2Fc-convert.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-convert.c?ref=0e48b5a21ba89dd535e99bb1704110a5a9ff0287", "patch": "@@ -0,0 +1,397 @@\n+/* Language-level data type conversion for GNU C.\n+   Copyright (C) 1987, 1988, 1991 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+\n+/* This file contains the functions for converting C expressions\n+   to different data types.  The only entry point is `convert'.\n+   Every language front end must have a `convert' function\n+   but what kind of conversions it does will depend on the language.  */\n+\n+#include \"config.h\"\n+#include \"tree.h\"\n+#include \"flags.h\"\n+\n+/* Change of width--truncation and extension of integers or reals--\n+   is represented with NOP_EXPR.  Proper functioning of many things\n+   assumes that no other conversions can be NOP_EXPRs.\n+\n+   Conversion between integer and pointer is represented with CONVERT_EXPR.\n+   Converting integer to real uses FLOAT_EXPR\n+   and real to integer uses FIX_TRUNC_EXPR.\n+\n+   Here is a list of all the functions that assume that widening and\n+   narrowing is always done with a NOP_EXPR:\n+     In c-convert.c, convert_to_integer.\n+     In c-typeck.c, build_binary_op (boolean ops), and truthvalue_conversion.\n+     In expr.c: expand_expr, for operands of a MULT_EXPR.\n+     In fold-const.c: fold.\n+     In tree.c: get_narrower and get_unwidened.  */\n+\f\n+/* Subroutines of `convert'.  */\n+\n+static tree\n+convert_to_pointer (type, expr)\n+     tree type, expr;\n+{\n+  register tree intype = TREE_TYPE (expr);\n+  register enum tree_code form = TREE_CODE (intype);\n+  \n+  if (integer_zerop (expr))\n+    {\n+      if (type == TREE_TYPE (null_pointer_node))\n+\treturn null_pointer_node;\n+      expr = build_int_2 (0, 0);\n+      TREE_TYPE (expr) = type;\n+      return expr;\n+    }\n+\n+  if (form == POINTER_TYPE)\n+    return build1 (NOP_EXPR, type, expr);\n+\n+\n+  if (form == INTEGER_TYPE || form == ENUMERAL_TYPE)\n+    {\n+      if (type_precision (intype) == POINTER_SIZE)\n+\treturn build1 (CONVERT_EXPR, type, expr);\n+      expr = convert (type_for_size (POINTER_SIZE, 0), expr);\n+      if (TYPE_MODE (TREE_TYPE (expr)) != TYPE_MODE (type))\n+\t/* There is supposed to be some integral type\n+\t   that is the same width as a pointer.  */\n+\tabort ();\n+      return convert_to_pointer (type, expr);\n+    }\n+\n+  error (\"cannot convert to a pointer type\");\n+\n+  return null_pointer_node;\n+}\n+\n+static tree\n+convert_to_real (type, expr)\n+     tree type, expr;\n+{\n+  register enum tree_code form = TREE_CODE (TREE_TYPE (expr));\n+\n+  if (form == REAL_TYPE)\n+    return build1 (flag_float_store ? CONVERT_EXPR : NOP_EXPR,\n+\t\t   type, expr);\n+\n+  if (form == INTEGER_TYPE || form == ENUMERAL_TYPE)\n+    return build1 (FLOAT_EXPR, type, expr);\n+\n+  if (form == POINTER_TYPE)\n+    error (\"pointer value used where a float was expected\");\n+  else\n+    error (\"aggregate value used where a float was expected\");\n+\n+  {\n+    register tree tem = make_node (REAL_CST);\n+    TREE_TYPE (tem) = type;\n+    TREE_REAL_CST (tem) = REAL_VALUE_ATOF (\"0.0\");\n+    return tem;\n+  }\n+}\n+\f\n+/* The result of this is always supposed to be a newly created tree node\n+   not in use in any existing structure.  */\n+\n+static tree\n+convert_to_integer (type, expr)\n+     tree type, expr;\n+{\n+  register tree intype = TREE_TYPE (expr);\n+  register enum tree_code form = TREE_CODE (intype);\n+\n+  if (form == POINTER_TYPE)\n+    {\n+      if (integer_zerop (expr))\n+\texpr = integer_zero_node;\n+      else\n+\texpr = fold (build1 (CONVERT_EXPR,\n+\t\t\t     type_for_size (POINTER_SIZE, 0), expr));\n+      intype = TREE_TYPE (expr);\n+      form = TREE_CODE (intype);\n+      if (intype == type)\n+\treturn expr;\n+    }\n+\n+  if (form == INTEGER_TYPE || form == ENUMERAL_TYPE)\n+    {\n+      register unsigned outprec = TYPE_PRECISION (type);\n+      register unsigned inprec = TYPE_PRECISION (intype);\n+      register enum tree_code ex_form = TREE_CODE (expr);\n+\n+      if (outprec >= inprec)\n+\treturn build1 (NOP_EXPR, type, expr);\n+\n+/* Here detect when we can distribute the truncation down past some arithmetic.\n+   For example, if adding two longs and converting to an int,\n+   we can equally well convert both to ints and then add.\n+   For the operations handled here, such truncation distribution\n+   is always safe.\n+   It is desirable in these cases:\n+   1) when truncating down to full-word from a larger size\n+   2) when truncating takes no work.\n+   3) when at least one operand of the arithmetic has been extended\n+   (as by C's default conversions).  In this case we need two conversions\n+   if we do the arithmetic as already requested, so we might as well\n+   truncate both and then combine.  Perhaps that way we need only one.\n+\n+   Note that in general we cannot do the arithmetic in a type\n+   shorter than the desired result of conversion, even if the operands\n+   are both extended from a shorter type, because they might overflow\n+   if combined in that type.  The exceptions to this--the times when\n+   two narrow values can be combined in their narrow type even to\n+   make a wider result--are handled by \"shorten\" in build_binary_op.  */\n+\n+      switch (ex_form)\n+\t{\n+\tcase RSHIFT_EXPR:\n+\t  /* We can pass truncation down through right shifting\n+\t     when the shift count is a negative constant.  */\n+\t  if (TREE_CODE (TREE_OPERAND (expr, 1)) != INTEGER_CST\n+\t      || TREE_INT_CST_LOW (TREE_OPERAND (expr, 1)) > 0)\n+\t    break;\n+\t  goto trunc1;\n+\n+\tcase LSHIFT_EXPR:\n+\t  /* We can pass truncation down through left shifting\n+\t     when the shift count is a positive constant.  */\n+\t  if (TREE_CODE (TREE_OPERAND (expr, 1)) != INTEGER_CST\n+\t      || TREE_INT_CST_LOW (TREE_OPERAND (expr, 1)) < 0)\n+\t    break;\n+\t  /* In this case, shifting is like multiplication.  */\n+\t  goto trunc1;\n+\n+\tcase MAX_EXPR:\n+\tcase MIN_EXPR:\n+\tcase MULT_EXPR:\n+\t  {\n+\t    tree arg0 = get_unwidened (TREE_OPERAND (expr, 0), type);\n+\t    tree arg1 = get_unwidened (TREE_OPERAND (expr, 1), type);\n+\n+\t    /* Don't distribute unless the output precision is at least as big\n+\t       as the actual inputs.  Otherwise, the comparison of the\n+\t       truncated values will be wrong.  */\n+\t    if (outprec >= TYPE_PRECISION (TREE_TYPE (arg0))\n+\t\t&& outprec >= TYPE_PRECISION (TREE_TYPE (arg1))\n+\t\t/* If signedness of arg0 and arg1 don't match,\n+\t\t   we can't necessarily find a type to compare them in.  */\n+\t\t&& (TREE_UNSIGNED (TREE_TYPE (arg0))\n+\t\t    == TREE_UNSIGNED (TREE_TYPE (arg1))))\n+\t      goto trunc1;\n+\t    break;\n+\t  }\n+\n+\tcase PLUS_EXPR:\n+\tcase MINUS_EXPR:\n+\tcase BIT_AND_EXPR:\n+\tcase BIT_IOR_EXPR:\n+\tcase BIT_XOR_EXPR:\n+\tcase BIT_ANDTC_EXPR:\n+\ttrunc1:\n+\t  {\n+\t    tree arg0 = get_unwidened (TREE_OPERAND (expr, 0), type);\n+\t    tree arg1 = get_unwidened (TREE_OPERAND (expr, 1), type);\n+\n+\t    if (outprec >= BITS_PER_WORD\n+\t\t|| TRULY_NOOP_TRUNCATION (outprec, inprec)\n+\t\t|| inprec > TYPE_PRECISION (TREE_TYPE (arg0))\n+\t\t|| inprec > TYPE_PRECISION (TREE_TYPE (arg1)))\n+\t      {\n+\t\t/* Do the arithmetic in type TYPEX,\n+\t\t   then convert result to TYPE.  */\n+\t\tregister tree typex = type;\n+\n+\t\t/* Can't do arithmetic in enumeral types\n+\t\t   so use an integer type that will hold the values.  */\n+\t\tif (TREE_CODE (typex) == ENUMERAL_TYPE)\n+\t\t  typex = type_for_size (TYPE_PRECISION (typex),\n+\t\t\t\t\t TREE_UNSIGNED (typex));\n+\n+\t\t/* But now perhaps TYPEX is as wide as INPREC.\n+\t\t   In that case, do nothing special here.\n+\t\t   (Otherwise would recurse infinitely in convert.  */\n+\t\tif (TYPE_PRECISION (typex) != inprec)\n+\t\t  {\n+\t\t    /* Don't do unsigned arithmetic where signed was wanted,\n+\t\t       or vice versa.\n+\t\t       Exception: if either of the original operands were\n+\t\t       unsigned then can safely do the work as unsigned.\n+\t\t       And we may need to do it as unsigned\n+\t\t       if we truncate to the original size.  */\n+\t\t    typex = ((TREE_UNSIGNED (TREE_TYPE (expr))\n+\t\t\t      || TREE_UNSIGNED (TREE_TYPE (arg0))\n+\t\t\t      || TREE_UNSIGNED (TREE_TYPE (arg1)))\n+\t\t\t     ? unsigned_type (typex) : signed_type (typex));\n+\t\t    return convert (type,\n+\t\t\t\t    build_binary_op (ex_form,\n+\t\t\t\t\t\t     convert (typex, arg0),\n+\t\t\t\t\t\t     convert (typex, arg1),\n+\t\t\t\t\t\t     0));\n+\t\t  }\n+\t      }\n+\t  }\n+\t  break;\n+\n+\tcase EQ_EXPR:\n+\tcase NE_EXPR:\n+\tcase GT_EXPR:\n+\tcase GE_EXPR:\n+\tcase LT_EXPR:\n+\tcase LE_EXPR:\n+\tcase TRUTH_AND_EXPR:\n+\tcase TRUTH_ANDIF_EXPR:\n+\tcase TRUTH_OR_EXPR:\n+\tcase TRUTH_ORIF_EXPR:\n+\tcase TRUTH_NOT_EXPR:\n+\t  /* If we want result of comparison converted to a byte,\n+\t     we can just regard it as a byte, since it is 0 or 1.  */\n+\t  TREE_TYPE (expr) = type;\n+\t  return expr;\n+\n+\tcase NEGATE_EXPR:\n+\tcase BIT_NOT_EXPR:\n+\tcase ABS_EXPR:\n+\t  {\n+\t    register tree typex = type;\n+\n+\t    /* Can't do arithmetic in enumeral types\n+\t       so use an integer type that will hold the values.  */\n+\t    if (TREE_CODE (typex) == ENUMERAL_TYPE)\n+\t      typex = type_for_size (TYPE_PRECISION (typex),\n+\t\t\t\t     TREE_UNSIGNED (typex));\n+\n+\t    /* But now perhaps TYPEX is as wide as INPREC.\n+\t       In that case, do nothing special here.\n+\t       (Otherwise would recurse infinitely in convert.  */\n+\t    if (TYPE_PRECISION (typex) != inprec)\n+\t      {\n+\t\t/* Don't do unsigned arithmetic where signed was wanted,\n+\t\t   or vice versa.  */\n+\t\ttypex = (TREE_UNSIGNED (TREE_TYPE (expr))\n+\t\t\t ? unsigned_type (typex) : signed_type (typex));\n+\t\treturn convert (type,\n+\t\t\t\tbuild_unary_op (ex_form,\n+\t\t\t\t\t\tconvert (typex, TREE_OPERAND (expr, 0)),\n+\t\t\t\t\t\t1));\n+\t      }\n+\t  }\n+\n+\tcase NOP_EXPR:\n+\t  /* If truncating after truncating, might as well do all at once.\n+\t     If truncating after extending, we may get rid of wasted work.  */\n+\t  return convert (type, get_unwidened (TREE_OPERAND (expr, 0), type));\n+\n+\tcase COND_EXPR:\n+\t  /* Can treat the two alternative values like the operands\n+\t     of an arithmetic expression.  */\n+\t  {\n+\t    tree arg1 = get_unwidened (TREE_OPERAND (expr, 1), type);\n+\t    tree arg2 = get_unwidened (TREE_OPERAND (expr, 2), type);\n+\n+\t    if (outprec >= BITS_PER_WORD\n+\t\t|| TRULY_NOOP_TRUNCATION (outprec, inprec)\n+\t\t|| inprec > TYPE_PRECISION (TREE_TYPE (arg1))\n+\t\t|| inprec > TYPE_PRECISION (TREE_TYPE (arg2)))\n+\t      {\n+\t\t/* Do the arithmetic in type TYPEX,\n+\t\t   then convert result to TYPE.  */\n+\t\tregister tree typex = type;\n+\n+\t\t/* Can't do arithmetic in enumeral types\n+\t\t   so use an integer type that will hold the values.  */\n+\t\tif (TREE_CODE (typex) == ENUMERAL_TYPE)\n+\t\t  typex = type_for_size (TYPE_PRECISION (typex),\n+\t\t\t\t\t TREE_UNSIGNED (typex));\n+\n+\t\t/* But now perhaps TYPEX is as wide as INPREC.\n+\t\t   In that case, do nothing special here.\n+\t\t   (Otherwise would recurse infinitely in convert.  */\n+\t\tif (TYPE_PRECISION (typex) != inprec)\n+\t\t  {\n+\t\t    /* Don't do unsigned arithmetic where signed was wanted,\n+\t\t       or vice versa.  */\n+\t\t    typex = (TREE_UNSIGNED (TREE_TYPE (expr))\n+\t\t\t     ? unsigned_type (typex) : signed_type (typex));\n+\t\t    return convert (type,\n+\t\t\t\t    fold (build (COND_EXPR, typex,\n+\t\t\t\t\t\t TREE_OPERAND (expr, 0),\n+\t\t\t\t\t\t convert (typex, arg1),\n+\t\t\t\t\t\t convert (typex, arg2))));\n+\t\t  }\n+\t      }\n+\t  }\n+\t}\n+\n+      return build1 (NOP_EXPR, type, expr);\n+    }\n+\n+  if (form == REAL_TYPE)\n+    return build1 (FIX_TRUNC_EXPR, type, expr);\n+\n+  error (\"aggregate value used where an integer was expected\");\n+\n+  {\n+    register tree tem = build_int_2 (0, 0);\n+    TREE_TYPE (tem) = type;\n+    return tem;\n+  }\n+}\n+\f\n+/* Create an expression whose value is that of EXPR,\n+   converted to type TYPE.  The TREE_TYPE of the value\n+   is always TYPE.  This function implements all reasonable\n+   conversions; callers should filter out those that are\n+   not permitted by the language being compiled.  */\n+\n+tree\n+convert (type, expr)\n+     tree type, expr;\n+{\n+  register tree e = expr;\n+  register enum tree_code code = TREE_CODE (type);\n+\n+  if (type == TREE_TYPE (expr) || TREE_CODE (expr) == ERROR_MARK)\n+    return expr;\n+  if (TREE_CODE (TREE_TYPE (expr)) == ERROR_MARK)\n+    return error_mark_node;\n+  if (TREE_CODE (TREE_TYPE (expr)) == VOID_TYPE)\n+    {\n+      error (\"void value not ignored as it ought to be\");\n+      return error_mark_node;\n+    }\n+  if (code == VOID_TYPE)\n+    return build1 (CONVERT_EXPR, type, e);\n+#if 0\n+  /* This is incorrect.  A truncation can't be stripped this way.\n+     Extensions will be stripped by the use of get_unwidened.  */\n+  if (TREE_CODE (expr) == NOP_EXPR)\n+    return convert (type, TREE_OPERAND (expr, 0));\n+#endif\n+  if (code == INTEGER_TYPE || code == ENUMERAL_TYPE)\n+    return fold (convert_to_integer (type, e));\n+  if (code == POINTER_TYPE)\n+    return fold (convert_to_pointer (type, e));\n+  if (code == REAL_TYPE)\n+    return fold (convert_to_real (type, e));\n+\n+  error (\"conversion to non-scalar type requested\");\n+  return error_mark_node;\n+}"}]}