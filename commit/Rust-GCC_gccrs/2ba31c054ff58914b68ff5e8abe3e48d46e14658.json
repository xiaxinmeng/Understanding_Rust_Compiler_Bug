{"sha": "2ba31c054ff58914b68ff5e8abe3e48d46e14658", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmJhMzFjMDU0ZmY1ODkxNGI2OGZmNWU4YWJlM2U0OGQ0NmUxNDY1OA==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2012-08-14T15:59:41Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2012-08-14T15:59:41Z"}, "message": "dominance.c (init_dom_info): Use gcc_checking_assert, not gcc_assert.\n\n\t* dominance.c (init_dom_info): Use gcc_checking_assert, not gcc_assert.\n\t(dom_convert_dir_to_idx, compute_dom_fast_query,\n\tget_immediate_dominator, set_immediate_dominator, get_dominated_by,\n\tredirect_immediate_dominators, nearest_common_dominator,\n\t(dominated_by_p, bb_dom_dfs_in, bb_dom_dfs_out, recompute_dominator,\n\titerate_fix_dominators, add_to_dominance_info,\n\tdelete_from_dominance_info): Likewise.\n\nFrom-SVN: r190389", "tree": {"sha": "f9ee6d8a7575d70e545b5d53a2afac73302c22fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f9ee6d8a7575d70e545b5d53a2afac73302c22fa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2ba31c054ff58914b68ff5e8abe3e48d46e14658", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ba31c054ff58914b68ff5e8abe3e48d46e14658", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ba31c054ff58914b68ff5e8abe3e48d46e14658", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ba31c054ff58914b68ff5e8abe3e48d46e14658/comments", "author": null, "committer": null, "parents": [{"sha": "56b88c0f7a9d700e404422f0f40c64095cd7a883", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56b88c0f7a9d700e404422f0f40c64095cd7a883", "html_url": "https://github.com/Rust-GCC/gccrs/commit/56b88c0f7a9d700e404422f0f40c64095cd7a883"}], "stats": {"total": 40, "additions": 24, "deletions": 16}, "files": [{"sha": "f94cbc990167a9a26326c06ca9bad9c0fb04e48d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ba31c054ff58914b68ff5e8abe3e48d46e14658/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ba31c054ff58914b68ff5e8abe3e48d46e14658/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2ba31c054ff58914b68ff5e8abe3e48d46e14658", "patch": "@@ -1,3 +1,13 @@\n+2012-08-14  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\t* dominance.c (init_dom_info): Use gcc_checking_assert, not gcc_assert.\n+\t(dom_convert_dir_to_idx, compute_dom_fast_query,\n+\tget_immediate_dominator, set_immediate_dominator, get_dominated_by,\n+\tredirect_immediate_dominators, nearest_common_dominator,\n+\t(dominated_by_p, bb_dom_dfs_in, bb_dom_dfs_out, recompute_dominator,\n+\titerate_fix_dominators, add_to_dominance_info,\n+\tdelete_from_dominance_info): Likewise.\n+\n 2012-08-14  Richard Guenther  <rguenther@suse.de>\n \n \t* cfgexpand.c (expand_used_vars): Use virtual_operand_p."}, {"sha": "10a58cd8a2a47081b3146c9c61fc35f5b28c355f", "filename": "gcc/dominance.c", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ba31c054ff58914b68ff5e8abe3e48d46e14658/gcc%2Fdominance.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ba31c054ff58914b68ff5e8abe3e48d46e14658/gcc%2Fdominance.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdominance.c?ref=2ba31c054ff58914b68ff5e8abe3e48d46e14658", "patch": "@@ -191,7 +191,7 @@ init_dom_info (struct dom_info *di, enum cdi_direction dir)\n static unsigned int\n dom_convert_dir_to_idx (enum cdi_direction dir)\n {\n-  gcc_assert (dir == CDI_DOMINATORS || dir == CDI_POST_DOMINATORS);\n+  gcc_checking_assert (dir == CDI_DOMINATORS || dir == CDI_POST_DOMINATORS);\n   return dir - 1;\n }\n \n@@ -613,7 +613,7 @@ compute_dom_fast_query (enum cdi_direction dir)\n   basic_block bb;\n   unsigned int dir_index = dom_convert_dir_to_idx (dir);\n \n-  gcc_assert (dom_info_available_p (dir));\n+  gcc_checking_assert (dom_info_available_p (dir));\n \n   if (dom_computed[dir_index] == DOM_OK)\n     return;\n@@ -702,7 +702,7 @@ get_immediate_dominator (enum cdi_direction dir, basic_block bb)\n   unsigned int dir_index = dom_convert_dir_to_idx (dir);\n   struct et_node *node = bb->dom[dir_index];\n \n-  gcc_assert (dom_computed[dir_index]);\n+  gcc_checking_assert (dom_computed[dir_index]);\n \n   if (!node->father)\n     return NULL;\n@@ -719,7 +719,7 @@ set_immediate_dominator (enum cdi_direction dir, basic_block bb,\n   unsigned int dir_index = dom_convert_dir_to_idx (dir);\n   struct et_node *node = bb->dom[dir_index];\n \n-  gcc_assert (dom_computed[dir_index]);\n+  gcc_checking_assert (dom_computed[dir_index]);\n \n   if (node->father)\n     {\n@@ -744,7 +744,7 @@ get_dominated_by (enum cdi_direction dir, basic_block bb)\n   struct et_node *node = bb->dom[dir_index], *son = node->son, *ason;\n   VEC (basic_block, heap) *bbs = NULL;\n \n-  gcc_assert (dom_computed[dir_index]);\n+  gcc_checking_assert (dom_computed[dir_index]);\n \n   if (!son)\n     return NULL;\n@@ -836,7 +836,7 @@ redirect_immediate_dominators (enum cdi_direction dir, basic_block bb,\n   bb_node = bb->dom[dir_index];\n   to_node = to->dom[dir_index];\n \n-  gcc_assert (dom_computed[dir_index]);\n+  gcc_checking_assert (dom_computed[dir_index]);\n \n   if (!bb_node->son)\n     return;\n@@ -859,7 +859,7 @@ nearest_common_dominator (enum cdi_direction dir, basic_block bb1, basic_block b\n {\n   unsigned int dir_index = dom_convert_dir_to_idx (dir);\n \n-  gcc_assert (dom_computed[dir_index]);\n+  gcc_checking_assert (dom_computed[dir_index]);\n \n   if (!bb1)\n     return bb2;\n@@ -971,7 +971,7 @@ dominated_by_p (enum cdi_direction dir, const_basic_block bb1, const_basic_block\n   unsigned int dir_index = dom_convert_dir_to_idx (dir);\n   struct et_node *n1 = bb1->dom[dir_index], *n2 = bb2->dom[dir_index];\n \n-  gcc_assert (dom_computed[dir_index]);\n+  gcc_checking_assert (dom_computed[dir_index]);\n \n   if (dom_computed[dir_index] == DOM_OK)\n     return (n1->dfs_num_in >= n2->dfs_num_in\n@@ -988,7 +988,7 @@ bb_dom_dfs_in (enum cdi_direction dir, basic_block bb)\n   unsigned int dir_index = dom_convert_dir_to_idx (dir);\n   struct et_node *n = bb->dom[dir_index];\n \n-  gcc_assert (dom_computed[dir_index] == DOM_OK);\n+  gcc_checking_assert (dom_computed[dir_index] == DOM_OK);\n   return n->dfs_num_in;\n }\n \n@@ -1000,7 +1000,7 @@ bb_dom_dfs_out (enum cdi_direction dir, basic_block bb)\n   unsigned int dir_index = dom_convert_dir_to_idx (dir);\n   struct et_node *n = bb->dom[dir_index];\n \n-  gcc_assert (dom_computed[dir_index] == DOM_OK);\n+  gcc_checking_assert (dom_computed[dir_index] == DOM_OK);\n   return n->dfs_num_out;\n }\n \n@@ -1054,7 +1054,7 @@ recompute_dominator (enum cdi_direction dir, basic_block bb)\n   edge e;\n   edge_iterator ei;\n \n-  gcc_assert (dom_computed[dir_index]);\n+  gcc_checking_assert (dom_computed[dir_index]);\n \n   if (dir == CDI_DOMINATORS)\n     {\n@@ -1254,8 +1254,7 @@ iterate_fix_dominators (enum cdi_direction dir, VEC (basic_block, heap) *bbs,\n      problems would be unused, untested, and almost surely buggy.  We keep\n      the DIR argument for consistency with the rest of the dominator analysis\n      interface.  */\n-  gcc_assert (dir == CDI_DOMINATORS);\n-  gcc_assert (dom_computed[dir_index]);\n+  gcc_checking_assert (dir == CDI_DOMINATORS && dom_computed[dir_index]);\n \n   /* The algorithm we use takes inspiration from the following papers, although\n      the details are quite different from any of them:\n@@ -1401,8 +1400,7 @@ add_to_dominance_info (enum cdi_direction dir, basic_block bb)\n {\n   unsigned int dir_index = dom_convert_dir_to_idx (dir);\n \n-  gcc_assert (dom_computed[dir_index]);\n-  gcc_assert (!bb->dom[dir_index]);\n+  gcc_checking_assert (dom_computed[dir_index] && !bb->dom[dir_index]);\n \n   n_bbs_in_dom_tree[dir_index]++;\n \n@@ -1417,7 +1415,7 @@ delete_from_dominance_info (enum cdi_direction dir, basic_block bb)\n {\n   unsigned int dir_index = dom_convert_dir_to_idx (dir);\n \n-  gcc_assert (dom_computed[dir_index]);\n+  gcc_checking_assert (dom_computed[dir_index]);\n \n   et_free_tree (bb->dom[dir_index]);\n   bb->dom[dir_index] = NULL;"}]}