{"sha": "5d5be7bfb56358feed3fd137d4e3994fcf17f543", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWQ1YmU3YmZiNTYzNThmZWVkM2ZkMTM3ZDRlMzk5NGZjZjE3ZjU0Mw==", "commit": {"author": {"name": "Julian Brown", "email": "julian@codesourcery.com", "date": "2019-12-20T01:20:27Z"}, "committer": {"name": "Julian Brown", "email": "jules@gcc.gnu.org", "date": "2019-12-20T01:20:27Z"}, "message": "OpenACC 2.6 deep copy: attach/detach API routines\n\n\tlibgomp/\n\t* libgomp.h (struct splay_tree_aux): Add attach_count field.\n\t(gomp_attach_pointer, gomp_detach_pointer): Add prototypes.\n\t* libgomp.map (OACC_2.6): New section. Add acc_attach,\n\tacc_attach_async, acc_detach, acc_detach_async, acc_detach_finalize,\n\tacc_detach_finalize_async.\n\t* oacc-mem.c (acc_attach_async, acc_attach, goacc_detach_internal,\n\tacc_detach, acc_detach_async, acc_detach_finalize,\n\tacc_detach_finalize_async): New functions.\n\t* openacc.h (acc_attach, acc_attach_async, acc_detach,\n\t(acc_detach_async, acc_detach_finalize, acc_detach_finalize_async): Add\n\tprototypes.\n\t* target.c (gomp_attach_pointer, gomp_detach_pointer): New functions.\n\t(gomp_remove_var_internal): Free attachment counts if present.\n\t* testsuite/libgomp.oacc-c-c++-common/deep-copy-3.c: New test.\n\t* testsuite/libgomp.oacc-c-c++-common/deep-copy-5.c: New test.\n\nCo-Authored-By: Thomas Schwinge <thomas@codesourcery.com>\n\nFrom-SVN: r279624", "tree": {"sha": "81fe9c37b82fc1954b0968cc392dcf97af1280c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/81fe9c37b82fc1954b0968cc392dcf97af1280c0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5d5be7bfb56358feed3fd137d4e3994fcf17f543", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d5be7bfb56358feed3fd137d4e3994fcf17f543", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d5be7bfb56358feed3fd137d4e3994fcf17f543", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d5be7bfb56358feed3fd137d4e3994fcf17f543/comments", "author": {"login": "jtb20", "id": 6094880, "node_id": "MDQ6VXNlcjYwOTQ4ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/6094880?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jtb20", "html_url": "https://github.com/jtb20", "followers_url": "https://api.github.com/users/jtb20/followers", "following_url": "https://api.github.com/users/jtb20/following{/other_user}", "gists_url": "https://api.github.com/users/jtb20/gists{/gist_id}", "starred_url": "https://api.github.com/users/jtb20/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jtb20/subscriptions", "organizations_url": "https://api.github.com/users/jtb20/orgs", "repos_url": "https://api.github.com/users/jtb20/repos", "events_url": "https://api.github.com/users/jtb20/events{/privacy}", "received_events_url": "https://api.github.com/users/jtb20/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4d83edf7efa2b4a4a46646640519bc2cd61c351c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d83edf7efa2b4a4a46646640519bc2cd61c351c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d83edf7efa2b4a4a46646640519bc2cd61c351c"}], "stats": {"total": 374, "additions": 374, "deletions": 0}, "files": [{"sha": "90e4fd1e2acbbad30a90f008896df156ffe9ba0b", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d5be7bfb56358feed3fd137d4e3994fcf17f543/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d5be7bfb56358feed3fd137d4e3994fcf17f543/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=5d5be7bfb56358feed3fd137d4e3994fcf17f543", "patch": "@@ -1,3 +1,22 @@\n+2019-12-19  Julian Brown  <julian@codesourcery.com>\n+\t    Thomas Schwinge  <thomas@codesourcery.com>\n+\n+\t* libgomp.h (struct splay_tree_aux): Add attach_count field.\n+\t(gomp_attach_pointer, gomp_detach_pointer): Add prototypes.\n+\t* libgomp.map (OACC_2.6): New section. Add acc_attach,\n+\tacc_attach_async, acc_detach, acc_detach_async, acc_detach_finalize,\n+\tacc_detach_finalize_async.\n+\t* oacc-mem.c (acc_attach_async, acc_attach, goacc_detach_internal,\n+\tacc_detach, acc_detach_async, acc_detach_finalize,\n+\tacc_detach_finalize_async): New functions.\n+\t* openacc.h (acc_attach, acc_attach_async, acc_detach,\n+\t(acc_detach_async, acc_detach_finalize, acc_detach_finalize_async): Add\n+\tprototypes.\n+\t* target.c (gomp_attach_pointer, gomp_detach_pointer): New functions.\n+\t(gomp_remove_var_internal): Free attachment counts if present.\n+\t* testsuite/libgomp.oacc-c-c++-common/deep-copy-3.c: New test.\n+\t* testsuite/libgomp.oacc-c-c++-common/deep-copy-5.c: New test.\n+\n 2019-12-19  Julian Brown  <julian@codesourcery.com>\n \t    Cesar Philippidis  <cesar@codesourcery.com>\n "}, {"sha": "4da1a9e2590d9709b4ddf73da4486d626242aaf5", "filename": "libgomp/libgomp.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d5be7bfb56358feed3fd137d4e3994fcf17f543/libgomp%2Flibgomp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d5be7bfb56358feed3fd137d4e3994fcf17f543/libgomp%2Flibgomp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp.h?ref=5d5be7bfb56358feed3fd137d4e3994fcf17f543", "patch": "@@ -994,6 +994,9 @@ struct target_mem_desc {\n struct splay_tree_aux {\n   /* Pointer to the original mapping of \"omp declare target link\" object.  */\n   splay_tree_key link_key;\n+  /* For a block with attached pointers, the attachment counters for each.\n+     Only used for OpenACC.  */\n+  uintptr_t *attach_count;\n };\n \n struct splay_tree_key_s {\n@@ -1158,6 +1161,13 @@ extern void gomp_copy_dev2host (struct gomp_device_descr *,\n \t\t\t\tstruct goacc_asyncqueue *, void *, const void *,\n \t\t\t\tsize_t);\n extern uintptr_t gomp_map_val (struct target_mem_desc *, void **, size_t);\n+extern void gomp_attach_pointer (struct gomp_device_descr *,\n+\t\t\t\t struct goacc_asyncqueue *, splay_tree,\n+\t\t\t\t splay_tree_key, uintptr_t, size_t,\n+\t\t\t\t struct gomp_coalesce_buf *);\n+extern void gomp_detach_pointer (struct gomp_device_descr *,\n+\t\t\t\t struct goacc_asyncqueue *, splay_tree_key,\n+\t\t\t\t uintptr_t, bool, struct gomp_coalesce_buf *);\n \n extern struct target_mem_desc *gomp_map_vars (struct gomp_device_descr *,\n \t\t\t\t\t      size_t, void **, void **,"}, {"sha": "63276f7d29be81e93b803e71defe0c36fd351246", "filename": "libgomp/libgomp.map", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d5be7bfb56358feed3fd137d4e3994fcf17f543/libgomp%2Flibgomp.map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d5be7bfb56358feed3fd137d4e3994fcf17f543/libgomp%2Flibgomp.map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp.map?ref=5d5be7bfb56358feed3fd137d4e3994fcf17f543", "patch": "@@ -484,6 +484,16 @@ OACC_2.5.1 {\n \tacc_register_library;\n } OACC_2.5;\n \n+OACC_2.6 {\n+  global:\n+\tacc_attach;\n+\tacc_attach_async;\n+\tacc_detach;\n+\tacc_detach_async;\n+\tacc_detach_finalize;\n+\tacc_detach_finalize_async;\n+} OACC_2.5.1;\n+\n GOACC_2.0 {\n   global:\n \tGOACC_data_end;"}, {"sha": "4fcb62ec386731855de34876e13d8c82619c0e02", "filename": "libgomp/oacc-mem.c", "status": "modified", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d5be7bfb56358feed3fd137d4e3994fcf17f543/libgomp%2Foacc-mem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d5be7bfb56358feed3fd137d4e3994fcf17f543/libgomp%2Foacc-mem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Foacc-mem.c?ref=5d5be7bfb56358feed3fd137d4e3994fcf17f543", "patch": "@@ -867,6 +867,90 @@ acc_update_self_async (void *h, size_t s, int async)\n   update_dev_host (0, h, s, async);\n }\n \n+void\n+acc_attach_async (void **hostaddr, int async)\n+{\n+  struct goacc_thread *thr = goacc_thread ();\n+  struct gomp_device_descr *acc_dev = thr->dev;\n+  goacc_aq aq = get_goacc_asyncqueue (async);\n+\n+  struct splay_tree_key_s cur_node;\n+  splay_tree_key n;\n+\n+  if (thr->dev->capabilities & GOMP_OFFLOAD_CAP_SHARED_MEM)\n+    return;\n+\n+  gomp_mutex_lock (&acc_dev->lock);\n+\n+  cur_node.host_start = (uintptr_t) hostaddr;\n+  cur_node.host_end = cur_node.host_start + sizeof (void *);\n+  n = splay_tree_lookup (&acc_dev->mem_map, &cur_node);\n+\n+  if (n == NULL)\n+    gomp_fatal (\"struct not mapped for acc_attach\");\n+\n+  gomp_attach_pointer (acc_dev, aq, &acc_dev->mem_map, n, (uintptr_t) hostaddr,\n+\t\t       0, NULL);\n+\n+  gomp_mutex_unlock (&acc_dev->lock);\n+}\n+\n+void\n+acc_attach (void **hostaddr)\n+{\n+  acc_attach_async (hostaddr, acc_async_sync);\n+}\n+\n+static void\n+goacc_detach_internal (void **hostaddr, int async, bool finalize)\n+{\n+  struct goacc_thread *thr = goacc_thread ();\n+  struct gomp_device_descr *acc_dev = thr->dev;\n+  struct splay_tree_key_s cur_node;\n+  splay_tree_key n;\n+  struct goacc_asyncqueue *aq = get_goacc_asyncqueue (async);\n+\n+  if (thr->dev->capabilities & GOMP_OFFLOAD_CAP_SHARED_MEM)\n+    return;\n+\n+  gomp_mutex_lock (&acc_dev->lock);\n+\n+  cur_node.host_start = (uintptr_t) hostaddr;\n+  cur_node.host_end = cur_node.host_start + sizeof (void *);\n+  n = splay_tree_lookup (&acc_dev->mem_map, &cur_node);\n+\n+  if (n == NULL)\n+    gomp_fatal (\"struct not mapped for acc_detach\");\n+\n+  gomp_detach_pointer (acc_dev, aq, n, (uintptr_t) hostaddr, finalize, NULL);\n+\n+  gomp_mutex_unlock (&acc_dev->lock);\n+}\n+\n+void\n+acc_detach (void **hostaddr)\n+{\n+  goacc_detach_internal (hostaddr, acc_async_sync, false);\n+}\n+\n+void\n+acc_detach_async (void **hostaddr, int async)\n+{\n+  goacc_detach_internal (hostaddr, async, false);\n+}\n+\n+void\n+acc_detach_finalize (void **hostaddr)\n+{\n+  goacc_detach_internal (hostaddr, acc_async_sync, true);\n+}\n+\n+void\n+acc_detach_finalize_async (void **hostaddr, int async)\n+{\n+  goacc_detach_internal (hostaddr, async, true);\n+}\n+\n /* Some types of (pointer) variables use several consecutive mappings, which\n    must be treated as a group for enter/exit data directives.  This function\n    returns the last mapping in such a group (inclusive), or POS for singleton"}, {"sha": "d2e5c101f7f6f11d483e37e753075e47ca2f95e0", "filename": "libgomp/openacc.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d5be7bfb56358feed3fd137d4e3994fcf17f543/libgomp%2Fopenacc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d5be7bfb56358feed3fd137d4e3994fcf17f543/libgomp%2Fopenacc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fopenacc.h?ref=5d5be7bfb56358feed3fd137d4e3994fcf17f543", "patch": "@@ -109,12 +109,18 @@ void *acc_hostptr (void *) __GOACC_NOTHROW;\n int acc_is_present (void *, size_t) __GOACC_NOTHROW;\n void acc_memcpy_to_device (void *, void *, size_t) __GOACC_NOTHROW;\n void acc_memcpy_from_device (void *, void *, size_t) __GOACC_NOTHROW;\n+void acc_attach (void **) __GOACC_NOTHROW;\n+void acc_attach_async (void **, int) __GOACC_NOTHROW;\n+void acc_detach (void **) __GOACC_NOTHROW;\n+void acc_detach_async (void **, int) __GOACC_NOTHROW;\n \n /* Finalize versions of copyout/delete functions, specified in OpenACC 2.5.  */\n void acc_copyout_finalize (void *, size_t) __GOACC_NOTHROW;\n void acc_copyout_finalize_async (void *, size_t, int) __GOACC_NOTHROW;\n void acc_delete_finalize (void *, size_t) __GOACC_NOTHROW;\n void acc_delete_finalize_async (void *, size_t, int) __GOACC_NOTHROW;\n+void acc_detach_finalize (void **) __GOACC_NOTHROW;\n+void acc_detach_finalize_async (void **, int) __GOACC_NOTHROW;\n \n /* Async functions, specified in OpenACC 2.5.  */\n void acc_copyin_async (void *, size_t, int) __GOACC_NOTHROW;"}, {"sha": "13f304cf97ea3300c1b5601d2557a439122943cb", "filename": "libgomp/target.c", "status": "modified", "additions": 130, "deletions": 0, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d5be7bfb56358feed3fd137d4e3994fcf17f543/libgomp%2Ftarget.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d5be7bfb56358feed3fd137d4e3994fcf17f543/libgomp%2Ftarget.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftarget.c?ref=5d5be7bfb56358feed3fd137d4e3994fcf17f543", "patch": "@@ -493,6 +493,134 @@ gomp_map_fields_existing (struct target_mem_desc *tgt,\n \t      (void *) cur_node.host_end);\n }\n \n+attribute_hidden void\n+gomp_attach_pointer (struct gomp_device_descr *devicep,\n+\t\t     struct goacc_asyncqueue *aq, splay_tree mem_map,\n+\t\t     splay_tree_key n, uintptr_t attach_to, size_t bias,\n+\t\t     struct gomp_coalesce_buf *cbufp)\n+{\n+  struct splay_tree_key_s s;\n+  size_t size, idx;\n+\n+  if (n == NULL)\n+    {\n+      gomp_mutex_unlock (&devicep->lock);\n+      gomp_fatal (\"enclosing struct not mapped for attach\");\n+    }\n+\n+  size = (n->host_end - n->host_start + sizeof (void *) - 1) / sizeof (void *);\n+  /* We might have a pointer in a packed struct: however we cannot have more\n+     than one such pointer in each pointer-sized portion of the struct, so\n+     this is safe.  */\n+  idx = (attach_to - n->host_start) / sizeof (void *);\n+\n+  if (!n->aux)\n+    n->aux = gomp_malloc_cleared (sizeof (struct splay_tree_aux));\n+\n+  if (!n->aux->attach_count)\n+    n->aux->attach_count\n+      = gomp_malloc_cleared (sizeof (*n->aux->attach_count) * size);\n+\n+  if (n->aux->attach_count[idx] < UINTPTR_MAX)\n+    n->aux->attach_count[idx]++;\n+  else\n+    {\n+      gomp_mutex_unlock (&devicep->lock);\n+      gomp_fatal (\"attach count overflow\");\n+    }\n+\n+  if (n->aux->attach_count[idx] == 1)\n+    {\n+      uintptr_t devptr = n->tgt->tgt_start + n->tgt_offset + attach_to\n+\t\t\t - n->host_start;\n+      uintptr_t target = (uintptr_t) *(void **) attach_to;\n+      splay_tree_key tn;\n+      uintptr_t data;\n+\n+      if ((void *) target == NULL)\n+\t{\n+\t  gomp_mutex_unlock (&devicep->lock);\n+\t  gomp_fatal (\"attempt to attach null pointer\");\n+\t}\n+\n+      s.host_start = target + bias;\n+      s.host_end = s.host_start + 1;\n+      tn = splay_tree_lookup (mem_map, &s);\n+\n+      if (!tn)\n+\t{\n+\t  gomp_mutex_unlock (&devicep->lock);\n+\t  gomp_fatal (\"pointer target not mapped for attach\");\n+\t}\n+\n+      data = tn->tgt->tgt_start + tn->tgt_offset + target - tn->host_start;\n+\n+      gomp_debug (1,\n+\t\t  \"%s: attaching host %p, target %p (struct base %p) to %p\\n\",\n+\t\t  __FUNCTION__, (void *) attach_to, (void *) devptr,\n+\t\t  (void *) (n->tgt->tgt_start + n->tgt_offset), (void *) data);\n+\n+      gomp_copy_host2dev (devicep, aq, (void *) devptr, (void *) &data,\n+\t\t\t  sizeof (void *), cbufp);\n+    }\n+  else\n+    gomp_debug (1, \"%s: attach count for %p -> %u\\n\", __FUNCTION__,\n+\t\t(void *) attach_to, (int) n->aux->attach_count[idx]);\n+}\n+\n+attribute_hidden void\n+gomp_detach_pointer (struct gomp_device_descr *devicep,\n+\t\t     struct goacc_asyncqueue *aq, splay_tree_key n,\n+\t\t     uintptr_t detach_from, bool finalize,\n+\t\t     struct gomp_coalesce_buf *cbufp)\n+{\n+  size_t idx;\n+\n+  if (n == NULL)\n+    {\n+      gomp_mutex_unlock (&devicep->lock);\n+      gomp_fatal (\"enclosing struct not mapped for detach\");\n+    }\n+\n+  idx = (detach_from - n->host_start) / sizeof (void *);\n+\n+  if (!n->aux || !n->aux->attach_count)\n+    {\n+      gomp_mutex_unlock (&devicep->lock);\n+      gomp_fatal (\"no attachment counters for struct\");\n+    }\n+\n+  if (finalize)\n+    n->aux->attach_count[idx] = 1;\n+\n+  if (n->aux->attach_count[idx] == 0)\n+    {\n+      gomp_mutex_unlock (&devicep->lock);\n+      gomp_fatal (\"attach count underflow\");\n+    }\n+  else\n+    n->aux->attach_count[idx]--;\n+\n+  if (n->aux->attach_count[idx] == 0)\n+    {\n+      uintptr_t devptr = n->tgt->tgt_start + n->tgt_offset + detach_from\n+\t\t\t - n->host_start;\n+      uintptr_t target = (uintptr_t) *(void **) detach_from;\n+\n+      gomp_debug (1,\n+\t\t  \"%s: detaching host %p, target %p (struct base %p) to %p\\n\",\n+\t\t  __FUNCTION__, (void *) detach_from, (void *) devptr,\n+\t\t  (void *) (n->tgt->tgt_start + n->tgt_offset),\n+\t\t  (void *) target);\n+\n+      gomp_copy_host2dev (devicep, aq, (void *) devptr, (void *) &target,\n+\t\t\t  sizeof (void *), cbufp);\n+    }\n+  else\n+    gomp_debug (1, \"%s: attach count for %p -> %u\\n\", __FUNCTION__,\n+\t\t(void *) detach_from, (int) n->aux->attach_count[idx]);\n+}\n+\n attribute_hidden uintptr_t\n gomp_map_val (struct target_mem_desc *tgt, void **hostaddrs, size_t i)\n {\n@@ -1191,6 +1319,8 @@ gomp_remove_var_internal (struct gomp_device_descr *devicep, splay_tree_key k,\n       if (k->aux->link_key)\n \tsplay_tree_insert (&devicep->mem_map,\n \t\t\t   (splay_tree_node) k->aux->link_key);\n+      if (k->aux->attach_count)\n+\tfree (k->aux->attach_count);\n       free (k->aux);\n       k->aux = NULL;\n     }"}, {"sha": "cec764bd3e7f96a152b1d6d7138a3b8c72cd999b", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/deep-copy-3.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d5be7bfb56358feed3fd137d4e3994fcf17f543/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fdeep-copy-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d5be7bfb56358feed3fd137d4e3994fcf17f543/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fdeep-copy-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fdeep-copy-3.c?ref=5d5be7bfb56358feed3fd137d4e3994fcf17f543", "patch": "@@ -0,0 +1,34 @@\n+#include <assert.h>\n+#include <stdlib.h>\n+#include <openacc.h>\n+\n+int\n+main ()\n+{\n+  int n = 100, i;\n+  int *a = (int *) malloc (sizeof (int) * n);\n+  int *b;\n+\n+  for (i = 0; i < n; i++)\n+    a[i] = i+1;\n+\n+#pragma acc enter data copyin(a[:n]) create(b)\n+\n+  b = a;\n+  acc_attach ((void **)&b);\n+\n+#pragma acc parallel loop present (b[:n])\n+  for (i = 0; i < n; i++)\n+    b[i] = i+1;\n+\n+  acc_detach ((void **)&b);\n+\n+#pragma acc exit data copyout(a[:n], b)\n+\n+  for (i = 0; i < 10; i++)\n+    assert (a[i] == b[i]);\n+\n+  free (a);\n+\n+  return 0;\n+}"}, {"sha": "89cafbb62abbf2d4467ca03dbfb1684d9858d54e", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/deep-copy-5.c", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d5be7bfb56358feed3fd137d4e3994fcf17f543/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fdeep-copy-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d5be7bfb56358feed3fd137d4e3994fcf17f543/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fdeep-copy-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fdeep-copy-5.c?ref=5d5be7bfb56358feed3fd137d4e3994fcf17f543", "patch": "@@ -0,0 +1,81 @@\n+#include <assert.h>\n+#include <stdlib.h>\n+#include <openacc.h>\n+\n+struct node\n+{\n+  struct node *next;\n+  int val;\n+};\n+\n+int\n+sum_nodes (struct node *head)\n+{\n+  int i = 0, sum = 0;\n+\n+#pragma acc parallel reduction(+:sum) present(head[:1])\n+  {\n+    for (; head != NULL; head = head->next)\n+      sum += head->val;\n+  }\n+\n+  return sum;\n+}\n+\n+void\n+insert (struct node *head, int val)\n+{\n+  struct node *n = (struct node *) malloc (sizeof (struct node));\n+\n+  if (head->next)\n+    acc_detach ((void **) &head->next);\n+\n+  n->val = val;\n+  n->next = head->next;\n+  head->next = n;\n+\n+  acc_copyin (n, sizeof (struct node));\n+  acc_attach((void **) &head->next);\n+\n+  if (n->next)\n+    acc_attach ((void **) &n->next);\n+}\n+\n+void\n+destroy (struct node *head)\n+{\n+  while (head->next != NULL)\n+    {\n+      acc_detach ((void **) &head->next);\n+      struct node * n = head->next;\n+      head->next = n->next;\n+      if (n->next)\n+\tacc_detach ((void **) &n->next);\n+\n+      acc_delete (n, sizeof (struct node));\n+      if (head->next)\n+\tacc_attach((void **) &head->next);\n+\n+      free (n);\n+    }\n+}\n+\n+int\n+main ()\n+{\n+  struct node list = { .next = NULL, .val = 0 };\n+  int i;\n+\n+  acc_copyin (&list, sizeof (struct node));\n+\n+  for (i = 0; i < 10; i++)\n+    insert (&list, 2);\n+\n+  assert (sum_nodes (&list) == 10 * 2);\n+\n+  destroy (&list);\n+\n+  acc_delete (&list, sizeof (struct node));\n+\n+  return 0;\n+}"}]}