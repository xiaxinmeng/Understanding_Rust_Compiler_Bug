{"sha": "bd5ed03ae9217ae903131e7345cf4ef7e6ba3437", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmQ1ZWQwM2FlOTIxN2FlOTAzMTMxZTczNDVjZjRlZjdlNmJhMzQzNw==", "commit": {"author": {"name": "Javier Miranda", "email": "miranda@adacore.com", "date": "2019-08-19T08:36:39Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2019-08-19T08:36:39Z"}, "message": "[Ada] Buffer reading overflow in dispatch table initialization\n\nFor tagged types not defined at library level that derive from library\nlevel tagged types the compiler may generate code to initialize their\ndispatch table of predefined primitives copying from the parent type\ndata stored in memory after the dispatch table of the parent; that is,\nat runtime the initialization of dispatch tables overflows reading the\nparent dispatch table.\n\nThis problem does not affect the execution of the program since the\ntarget dispatch table always has enough space to store the extra data,\nand after such copy the compiler generates code to complete the\ninitialization of the dispatch table.\n\nThe following test must compile and execute without errors.\n\npackage pkg_a is\n   type Root is tagged null record;\nend pkg_a;\n\nwith pkg_a;\nprocedure main is\n   type Derived is new pkg_a.Root with null record;  -- Test\nbegin\n   null;\nend main;\n\nCommand: gnatmake -q main -fsanitize=address; ./main\n\n2019-08-19  Javier Miranda  <miranda@adacore.com>\n\ngcc/ada/\n\n\tPR ada/65696\n\t* exp_atag.ads, exp_atag.adb (Build_Inherit_Predefined_Prims):\n\tAdding formal to specify how many predefined primitives are\n\tinherited from the parent type.\n\t* exp_disp.adb (Number_Of_Predefined_Prims): New subprogram.\n\t(Make_Secondary_DT): Compute the number of predefined primitives\n\tof all tagged types (including tagged types not defined at\n\tlibrary level).  Previously we unconditionally relied on the\n\tMax_Predef_Prims constant value when building the dispatch\n\ttables of tagged types not defined at library level (thus\n\tconsuming more memory for their dispatch tables than required).\n\t(Make_DT): Compute the number of predefined primitives that must\n\tbe inherited from their parent type when building the dispatch\n\ttables of tagged types not defined at library level. Previously\n\twe unconditionally relied on the Max_Predef_Prims constant value\n\twhen building the dispatch tables of tagged types not defined at\n\tlibrary level (thus copying more data than required from the\n\tparent type).\n\nFrom-SVN: r274654", "tree": {"sha": "beaad7e2b6cc694abe29fb54496c70219eec31dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/beaad7e2b6cc694abe29fb54496c70219eec31dc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bd5ed03ae9217ae903131e7345cf4ef7e6ba3437", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd5ed03ae9217ae903131e7345cf4ef7e6ba3437", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd5ed03ae9217ae903131e7345cf4ef7e6ba3437", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd5ed03ae9217ae903131e7345cf4ef7e6ba3437/comments", "author": {"login": "miranda-adacore", "id": 54413934, "node_id": "MDQ6VXNlcjU0NDEzOTM0", "avatar_url": "https://avatars.githubusercontent.com/u/54413934?v=4", "gravatar_id": "", "url": "https://api.github.com/users/miranda-adacore", "html_url": "https://github.com/miranda-adacore", "followers_url": "https://api.github.com/users/miranda-adacore/followers", "following_url": "https://api.github.com/users/miranda-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/miranda-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/miranda-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/miranda-adacore/subscriptions", "organizations_url": "https://api.github.com/users/miranda-adacore/orgs", "repos_url": "https://api.github.com/users/miranda-adacore/repos", "events_url": "https://api.github.com/users/miranda-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/miranda-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d403cfad2f90edf5fd8d8f6040177487ae9e167a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d403cfad2f90edf5fd8d8f6040177487ae9e167a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d403cfad2f90edf5fd8d8f6040177487ae9e167a"}], "stats": {"total": 268, "additions": 142, "deletions": 126}, "files": [{"sha": "f1930632fedaa8f3f81c013fcb24d4c40b429871", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd5ed03ae9217ae903131e7345cf4ef7e6ba3437/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd5ed03ae9217ae903131e7345cf4ef7e6ba3437/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=bd5ed03ae9217ae903131e7345cf4ef7e6ba3437", "patch": "@@ -1,3 +1,24 @@\n+2019-08-19  Javier Miranda  <miranda@adacore.com>\n+\n+\tPR ada/65696\n+\t* exp_atag.ads, exp_atag.adb (Build_Inherit_Predefined_Prims):\n+\tAdding formal to specify how many predefined primitives are\n+\tinherited from the parent type.\n+\t* exp_disp.adb (Number_Of_Predefined_Prims): New subprogram.\n+\t(Make_Secondary_DT): Compute the number of predefined primitives\n+\tof all tagged types (including tagged types not defined at\n+\tlibrary level).  Previously we unconditionally relied on the\n+\tMax_Predef_Prims constant value when building the dispatch\n+\ttables of tagged types not defined at library level (thus\n+\tconsuming more memory for their dispatch tables than required).\n+\t(Make_DT): Compute the number of predefined primitives that must\n+\tbe inherited from their parent type when building the dispatch\n+\ttables of tagged types not defined at library level. Previously\n+\twe unconditionally relied on the Max_Predef_Prims constant value\n+\twhen building the dispatch tables of tagged types not defined at\n+\tlibrary level (thus copying more data than required from the\n+\tparent type).\n+\n 2019-08-19  Bob Duff  <duff@adacore.com>\n \n \t* sem_ch13.adb (Record_Hole_Check): Procedure to check for holes"}, {"sha": "db1833cafc5a936d3f7c06e989399fd5fbbe3125", "filename": "gcc/ada/exp_atag.adb", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd5ed03ae9217ae903131e7345cf4ef7e6ba3437/gcc%2Fada%2Fexp_atag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd5ed03ae9217ae903131e7345cf4ef7e6ba3437/gcc%2Fada%2Fexp_atag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_atag.adb?ref=bd5ed03ae9217ae903131e7345cf4ef7e6ba3437", "patch": "@@ -742,9 +742,10 @@ package body Exp_Atag is\n    ------------------------------------\n \n    function Build_Inherit_Predefined_Prims\n-     (Loc          : Source_Ptr;\n-      Old_Tag_Node : Node_Id;\n-      New_Tag_Node : Node_Id) return Node_Id\n+     (Loc              : Source_Ptr;\n+      Old_Tag_Node     : Node_Id;\n+      New_Tag_Node     : Node_Id;\n+      Num_Predef_Prims : Int) return Node_Id\n    is\n    begin\n       return\n@@ -759,7 +760,7 @@ package body Exp_Atag is\n                         New_Tag_Node)))),\n               Discrete_Range => Make_Range (Loc,\n                 Make_Integer_Literal (Loc, Uint_1),\n-                New_Occurrence_Of (RTE (RE_Max_Predef_Prims), Loc))),\n+                Make_Integer_Literal (Loc, Num_Predef_Prims))),\n \n           Expression =>\n             Make_Slice (Loc,\n@@ -772,7 +773,7 @@ package body Exp_Atag is\n               Discrete_Range =>\n                 Make_Range (Loc,\n                   Make_Integer_Literal (Loc, 1),\n-                  New_Occurrence_Of (RTE (RE_Max_Predef_Prims), Loc))));\n+                  Make_Integer_Literal (Loc, Num_Predef_Prims))));\n    end Build_Inherit_Predefined_Prims;\n \n    -------------------------"}, {"sha": "e8d5e629ada1bf38bb2361ed931a23b50f5d1546", "filename": "gcc/ada/exp_atag.ads", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd5ed03ae9217ae903131e7345cf4ef7e6ba3437/gcc%2Fada%2Fexp_atag.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd5ed03ae9217ae903131e7345cf4ef7e6ba3437/gcc%2Fada%2Fexp_atag.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_atag.ads?ref=bd5ed03ae9217ae903131e7345cf4ef7e6ba3437", "patch": "@@ -109,9 +109,10 @@ package Exp_Atag is\n    --  generated code handles primary and secondary dispatch tables of Typ.\n \n    function Build_Inherit_Predefined_Prims\n-     (Loc          : Source_Ptr;\n-      Old_Tag_Node : Node_Id;\n-      New_Tag_Node : Node_Id) return Node_Id;\n+     (Loc              : Source_Ptr;\n+      Old_Tag_Node     : Node_Id;\n+      New_Tag_Node     : Node_Id;\n+      Num_Predef_Prims : Int) return Node_Id;\n    --  Build code that inherits the predefined primitives of the parent.\n    --\n    --  Generates: Predefined_DT (New_T).D (All_Predefined_Prims) :="}, {"sha": "35fc4849203dd32e9eecf9b8e2cbf99a3e57bd79", "filename": "gcc/ada/exp_disp.adb", "status": "modified", "additions": 111, "deletions": 118, "changes": 229, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd5ed03ae9217ae903131e7345cf4ef7e6ba3437/gcc%2Fada%2Fexp_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd5ed03ae9217ae903131e7345cf4ef7e6ba3437/gcc%2Fada%2Fexp_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.adb?ref=bd5ed03ae9217ae903131e7345cf4ef7e6ba3437", "patch": "@@ -3817,6 +3817,9 @@ package body Exp_Disp is\n       --  this secondary dispatch table by Make_Tags when its unique external\n       --  name was generated.\n \n+      function Number_Of_Predefined_Prims (Typ : Entity_Id) return Nat;\n+      --  Returns the number of predefined primitives of Typ\n+\n       ------------------------------\n       -- Check_Premature_Freezing --\n       ------------------------------\n@@ -3970,12 +3973,10 @@ package body Exp_Disp is\n          DT_Constr_List     : List_Id;\n          DT_Aggr_List       : List_Id;\n          Empty_DT           : Boolean := False;\n-         Nb_Predef_Prims    : Nat := 0;\n          Nb_Prim            : Nat;\n          New_Node           : Node_Id;\n          OSD                : Entity_Id;\n          OSD_Aggr_List      : List_Id;\n-         Pos                : Nat;\n          Prim               : Entity_Id;\n          Prim_Elmt          : Elmt_Id;\n          Prim_Ops_Aggr_List : List_Id;\n@@ -4022,38 +4023,12 @@ package body Exp_Disp is\n          --                     predef-prim-op-thunk-n'address);\n          --   for Predef_Prims'Alignment use Address'Alignment\n \n-         --  Stage 1: Calculate the number of predefined primitives\n-\n-         if not Building_Static_DT (Typ) then\n-            Nb_Predef_Prims := Max_Predef_Prims;\n-         else\n-            Prim_Elmt := First_Elmt (Primitive_Operations (Typ));\n-            while Present (Prim_Elmt) loop\n-               Prim := Node (Prim_Elmt);\n-\n-               if Is_Predefined_Dispatching_Operation (Prim)\n-                 and then not Is_Abstract_Subprogram (Prim)\n-               then\n-                  Pos := UI_To_Int (DT_Position (Prim));\n-\n-                  if Pos > Nb_Predef_Prims then\n-                     Nb_Predef_Prims := Pos;\n-                  end if;\n-               end if;\n-\n-               Next_Elmt (Prim_Elmt);\n-            end loop;\n-         end if;\n-\n-         if Generate_SCIL then\n-            Nb_Predef_Prims := 0;\n-         end if;\n-\n-         --  Stage 2: Create the thunks associated with the predefined\n-         --  primitives and save their entity to fill the aggregate.\n+         --  Create the thunks associated with the predefined primitives and\n+         --  save their entity to fill the aggregate.\n \n          declare\n-            Prim_Table : array (Nat range 1 .. Nb_Predef_Prims) of Entity_Id;\n+            Nb_P_Prims : constant Nat := Number_Of_Predefined_Prims (Typ);\n+            Prim_Table : array (Nat range 1 .. Nb_P_Prims) of Entity_Id;\n             Decl       : Node_Id;\n             Thunk_Id   : Entity_Id;\n             Thunk_Code : Node_Id;\n@@ -4525,6 +4500,44 @@ package body Exp_Disp is\n          Append_Elmt (Iface_DT, DT_Decl);\n       end Make_Secondary_DT;\n \n+      --------------------------------\n+      -- Number_Of_Predefined_Prims --\n+      --------------------------------\n+\n+      function Number_Of_Predefined_Prims (Typ : Entity_Id) return Nat is\n+         Nb_Predef_Prims : Nat := 0;\n+\n+      begin\n+         if not Generate_SCIL then\n+            declare\n+               Prim      : Entity_Id;\n+               Prim_Elmt : Elmt_Id;\n+               Pos       : Nat;\n+\n+            begin\n+               Prim_Elmt := First_Elmt (Primitive_Operations (Typ));\n+               while Present (Prim_Elmt) loop\n+                  Prim := Node (Prim_Elmt);\n+\n+                  if Is_Predefined_Dispatching_Operation (Prim)\n+                    and then not Is_Abstract_Subprogram (Prim)\n+                  then\n+                     Pos := UI_To_Int (DT_Position (Prim));\n+\n+                     if Pos > Nb_Predef_Prims then\n+                        Nb_Predef_Prims := Pos;\n+                     end if;\n+                  end if;\n+\n+                  Next_Elmt (Prim_Elmt);\n+               end loop;\n+            end;\n+         end if;\n+\n+         pragma Assert (Nb_Predef_Prims <= Max_Predef_Prims);\n+         return Nb_Predef_Prims;\n+      end Number_Of_Predefined_Prims;\n+\n       --  Local variables\n \n       Elab_Code : constant List_Id := New_List;\n@@ -4584,7 +4597,6 @@ package body Exp_Disp is\n       I_Depth            : Nat := 0;\n       Iface_Table_Node   : Node_Id;\n       Name_ITable        : Name_Id;\n-      Nb_Predef_Prims    : Nat := 0;\n       Nb_Prim            : Nat := 0;\n       New_Node           : Node_Id;\n       Num_Ifaces         : Nat := 0;\n@@ -5924,112 +5936,85 @@ package body Exp_Disp is\n \n       else\n          declare\n-            Pos : Nat;\n+            Nb_P_Prims : constant Nat := Number_Of_Predefined_Prims (Typ);\n+            Prim_Table : array (Nat range 1 .. Nb_P_Prims) of Entity_Id;\n+            Decl       : Node_Id;\n+            E          : Entity_Id;\n \n          begin\n-            if not Building_Static_DT (Typ) then\n-               Nb_Predef_Prims := Max_Predef_Prims;\n+            Prim_Ops_Aggr_List := New_List;\n+            Prim_Table := (others => Empty);\n \n-            else\n-               Prim_Elmt := First_Elmt (Primitive_Operations (Typ));\n+            if Building_Static_DT (Typ) then\n+               Prim_Elmt  := First_Elmt (Primitive_Operations (Typ));\n                while Present (Prim_Elmt) loop\n                   Prim := Node (Prim_Elmt);\n \n                   if Is_Predefined_Dispatching_Operation (Prim)\n                     and then not Is_Abstract_Subprogram (Prim)\n+                    and then not Is_Eliminated (Prim)\n+                    and then not Generate_SCIL\n+                    and then not Present (Prim_Table\n+                                           (UI_To_Int (DT_Position (Prim))))\n                   then\n-                     Pos := UI_To_Int (DT_Position (Prim));\n-\n-                     if Pos > Nb_Predef_Prims then\n-                        Nb_Predef_Prims := Pos;\n-                     end if;\n+                     E := Ultimate_Alias (Prim);\n+                     pragma Assert (not Is_Abstract_Subprogram (E));\n+                     Prim_Table (UI_To_Int (DT_Position (Prim))) := E;\n                   end if;\n \n                   Next_Elmt (Prim_Elmt);\n                end loop;\n             end if;\n \n-            declare\n-               Prim_Table : array\n-                              (Nat range 1 .. Nb_Predef_Prims) of Entity_Id;\n-               Decl       : Node_Id;\n-               E          : Entity_Id;\n-\n-            begin\n-               Prim_Ops_Aggr_List := New_List;\n-\n-               Prim_Table := (others => Empty);\n-\n-               if Building_Static_DT (Typ) then\n-                  Prim_Elmt  := First_Elmt (Primitive_Operations (Typ));\n-                  while Present (Prim_Elmt) loop\n-                     Prim := Node (Prim_Elmt);\n-\n-                     if Is_Predefined_Dispatching_Operation (Prim)\n-                       and then not Is_Abstract_Subprogram (Prim)\n-                       and then not Is_Eliminated (Prim)\n-                       and then not Present (Prim_Table\n-                                              (UI_To_Int (DT_Position (Prim))))\n-                     then\n-                        E := Ultimate_Alias (Prim);\n-                        pragma Assert (not Is_Abstract_Subprogram (E));\n-                        Prim_Table (UI_To_Int (DT_Position (Prim))) := E;\n-                     end if;\n-\n-                     Next_Elmt (Prim_Elmt);\n-                  end loop;\n+            for J in Prim_Table'Range loop\n+               if Present (Prim_Table (J)) then\n+                  New_Node :=\n+                    Unchecked_Convert_To (RTE (RE_Prim_Ptr),\n+                      Make_Attribute_Reference (Loc,\n+                        Prefix         =>\n+                          New_Occurrence_Of (Prim_Table (J), Loc),\n+                        Attribute_Name => Name_Unrestricted_Access));\n+               else\n+                  New_Node := Make_Null (Loc);\n                end if;\n \n-               for J in Prim_Table'Range loop\n-                  if Present (Prim_Table (J)) then\n-                     New_Node :=\n-                       Unchecked_Convert_To (RTE (RE_Prim_Ptr),\n-                         Make_Attribute_Reference (Loc,\n-                           Prefix         =>\n-                             New_Occurrence_Of (Prim_Table (J), Loc),\n-                           Attribute_Name => Name_Unrestricted_Access));\n-                  else\n-                     New_Node := Make_Null (Loc);\n-                  end if;\n-\n-                  Append_To (Prim_Ops_Aggr_List, New_Node);\n-               end loop;\n+               Append_To (Prim_Ops_Aggr_List, New_Node);\n+            end loop;\n \n-               New_Node :=\n-                 Make_Aggregate (Loc,\n-                   Expressions => Prim_Ops_Aggr_List);\n+            New_Node :=\n+              Make_Aggregate (Loc,\n+                Expressions => Prim_Ops_Aggr_List);\n \n-               Decl :=\n-                 Make_Subtype_Declaration (Loc,\n-                   Defining_Identifier => Make_Temporary (Loc, 'S'),\n-                   Subtype_Indication  =>\n-                     New_Occurrence_Of (RTE (RE_Address_Array), Loc));\n+            Decl :=\n+              Make_Subtype_Declaration (Loc,\n+                Defining_Identifier => Make_Temporary (Loc, 'S'),\n+                Subtype_Indication  =>\n+                  New_Occurrence_Of (RTE (RE_Address_Array), Loc));\n \n-               Append_To (Result, Decl);\n+            Append_To (Result, Decl);\n \n-               Append_To (Result,\n-                 Make_Object_Declaration (Loc,\n-                   Defining_Identifier => Predef_Prims,\n-                   Aliased_Present     => True,\n-                   Constant_Present    => Building_Static_DT (Typ),\n-                   Object_Definition   =>\n-                     New_Occurrence_Of (Defining_Identifier (Decl), Loc),\n-                   Expression => New_Node));\n+            Append_To (Result,\n+              Make_Object_Declaration (Loc,\n+                Defining_Identifier => Predef_Prims,\n+                Aliased_Present     => True,\n+                Constant_Present    => Building_Static_DT (Typ),\n+                Object_Definition   =>\n+                  New_Occurrence_Of (Defining_Identifier (Decl), Loc),\n+                Expression => New_Node));\n \n-               --  Remember aggregates initializing dispatch tables\n+            --  Remember aggregates initializing dispatch tables\n \n-               Append_Elmt (New_Node, DT_Aggr);\n+            Append_Elmt (New_Node, DT_Aggr);\n \n-               Append_To (Result,\n-                 Make_Attribute_Definition_Clause (Loc,\n-                   Name       => New_Occurrence_Of (Predef_Prims, Loc),\n-                   Chars      => Name_Alignment,\n-                   Expression =>\n-                     Make_Attribute_Reference (Loc,\n-                       Prefix         =>\n-                         New_Occurrence_Of (RTE (RE_Integer_Address), Loc),\n-                       Attribute_Name => Name_Alignment)));\n-            end;\n+            Append_To (Result,\n+              Make_Attribute_Definition_Clause (Loc,\n+                Name       => New_Occurrence_Of (Predef_Prims, Loc),\n+                Chars      => Name_Alignment,\n+                Expression =>\n+                  Make_Attribute_Reference (Loc,\n+                    Prefix         =>\n+                      New_Occurrence_Of (RTE (RE_Integer_Address), Loc),\n+                    Attribute_Name => Name_Alignment)));\n          end;\n \n          --  Stage 1: Initialize the discriminant and the record components\n@@ -6301,7 +6286,9 @@ package body Exp_Disp is\n                           (Node\n                             (Next_Elmt\n                               (First_Elmt\n-                                (Access_Disp_Table (Typ)))), Loc)));\n+                                (Access_Disp_Table (Typ)))), Loc),\n+                      Num_Predef_Prims =>\n+                        Number_Of_Predefined_Prims (Parent_Typ)));\n \n                   if Nb_Prims /= 0 then\n                      Append_To (Elab_Code,\n@@ -6390,7 +6377,10 @@ package body Exp_Disp is\n                                           Unchecked_Convert_To (RTE (RE_Tag),\n                                             New_Occurrence_Of\n                                               (Node (Next_Elmt (Sec_DT_Typ)),\n-                                               Loc))));\n+                                               Loc)),\n+                                        Num_Predef_Prims =>\n+                                          Number_Of_Predefined_Prims\n+                                            (Parent_Typ)));\n \n                                     if Num_Prims /= 0 then\n                                        Append_To (Elab_Code,\n@@ -6436,7 +6426,10 @@ package body Exp_Disp is\n                                           Unchecked_Convert_To (RTE (RE_Tag),\n                                             New_Occurrence_Of\n                                               (Node (Next_Elmt (Sec_DT_Typ)),\n-                                               Loc))));\n+                                               Loc)),\n+                                        Num_Predef_Prims =>\n+                                          Number_Of_Predefined_Prims\n+                                            (Parent_Typ)));\n \n                                     if Num_Prims /= 0 then\n                                        Append_To (Elab_Code,"}]}