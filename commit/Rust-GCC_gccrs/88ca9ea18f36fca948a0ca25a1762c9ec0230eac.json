{"sha": "88ca9ea18f36fca948a0ca25a1762c9ec0230eac", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODhjYTllYTE4ZjM2ZmNhOTQ4YTBjYTI1YTE3NjJjOWVjMDIzMGVhYw==", "commit": {"author": {"name": "Bill Schmidt", "email": "wschmidt@linux.vnet.ibm.com", "date": "2012-08-08T01:35:22Z"}, "committer": {"name": "William Schmidt", "email": "wschmidt@gcc.gnu.org", "date": "2012-08-08T01:35:22Z"}, "message": "gimple-ssa-strength-reduction.c (struct incr_info_d): New struct.\n\ngcc:\n\n2012-08-07  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n\n\t* gimple-ssa-strength-reduction.c (struct incr_info_d): New struct.\n\t(incr_vec): New static var.\n\t(incr_vec_len): Likewise.\n\t(address_arithmetic_p): Likewise.\n\t(stmt_cost): Remove dead assignment.\n\t(dump_incr_vec): New function.\n\t(cand_abs_increment): Likewise.\n\t(lazy_create_slsr_reg): Likewise.\n\t(incr_vec_index): Likewise.\n\t(count_candidates): Likewise.\n\t(record_increment): Likewise.\n\t(record_increments): Likewise.\n\t(unreplaced_cand_in_tree): Likewise.\n\t(optimize_cands_for_speed_p): Likewise.\n\t(lowest_cost_path): Likewise.\n\t(total_savings): Likewise.\n\t(analyze_increments): Likewise.\n\t(ncd_for_two_cands): Likewise.\n\t(nearest_common_dominator_for_cands): Likewise.\n\t(profitable_increment_p): Likewise.\n\t(insert_initializers): Likewise.\n\t(introduce_cast_before_cand): Likewise.\n\t(replace_rhs_if_not_dup): Likewise.\n\t(replace_one_candidate): Likewise.\n\t(replace_profitable_candidates): Likewise.\n\t(analyze_candidates_and_replace): Handle candidates with SSA-name\n\tstrides.\n\ngcc/testsuite:\n\n2012-08-07  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n\n\t* gcc.dg/tree-ssa/slsr-5.c: New.\n\t* gcc.dg/tree-ssa/slsr-6.c: New.\n\t* gcc.dg/tree-ssa/slsr-7.c: New.\n\t* gcc.dg/tree-ssa/slsr-8.c: New.\n\t* gcc.dg/tree-ssa/slsr-9.c: New.\n\t* gcc.dg/tree-ssa/slsr-10.c: New.\n\t* gcc.dg/tree-ssa/slsr-11.c: New.\n\t* gcc.dg/tree-ssa/slsr-12.c: New.\n\t* gcc.dg/tree-ssa/slsr-13.c: New.\n\t* gcc.dg/tree-ssa/slsr-14.c: New.\n\t* gcc.dg/tree-ssa/slsr-15.c: New.\n\t* gcc.dg/tree-ssa/slsr-16.c: New.\n\t* gcc.dg/tree-ssa/slsr-17.c: New.\n\t* gcc.dg/tree-ssa/slsr-18.c: New.\n\t* gcc.dg/tree-ssa/slsr-19.c: New.\n\t* gcc.dg/tree-ssa/slsr-20.c: New.\n\t* gcc.dg/tree-ssa/slsr-21.c: New.\n\t* gcc.dg/tree-ssa/slsr-22.c: New.\n\t* gcc.dg/tree-ssa/slsr-23.c: New.\n\t* gcc.dg/tree-ssa/slsr-24.c: New.\n\t* gcc.dg/tree-ssa/slsr-25.c: New.\n\t* gcc.dg/tree-ssa/slsr-26.c: New.\n\t* gcc.dg/tree-ssa/slsr-30.c: New.\n\t* gcc.dg/tree-ssa/slsr-31.c: New.\n\nFrom-SVN: r190220", "tree": {"sha": "d45c5c5a3cf1a03d2c0b98092a02c83996e0a606", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d45c5c5a3cf1a03d2c0b98092a02c83996e0a606"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/88ca9ea18f36fca948a0ca25a1762c9ec0230eac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88ca9ea18f36fca948a0ca25a1762c9ec0230eac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/88ca9ea18f36fca948a0ca25a1762c9ec0230eac", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88ca9ea18f36fca948a0ca25a1762c9ec0230eac/comments", "author": {"login": "wschmidt-ibm", "id": 5520937, "node_id": "MDQ6VXNlcjU1MjA5Mzc=", "avatar_url": "https://avatars.githubusercontent.com/u/5520937?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wschmidt-ibm", "html_url": "https://github.com/wschmidt-ibm", "followers_url": "https://api.github.com/users/wschmidt-ibm/followers", "following_url": "https://api.github.com/users/wschmidt-ibm/following{/other_user}", "gists_url": "https://api.github.com/users/wschmidt-ibm/gists{/gist_id}", "starred_url": "https://api.github.com/users/wschmidt-ibm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wschmidt-ibm/subscriptions", "organizations_url": "https://api.github.com/users/wschmidt-ibm/orgs", "repos_url": "https://api.github.com/users/wschmidt-ibm/repos", "events_url": "https://api.github.com/users/wschmidt-ibm/events{/privacy}", "received_events_url": "https://api.github.com/users/wschmidt-ibm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "02044923b7c2f88e0db823e713d3c2fe508d8048", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02044923b7c2f88e0db823e713d3c2fe508d8048", "html_url": "https://github.com/Rust-GCC/gccrs/commit/02044923b7c2f88e0db823e713d3c2fe508d8048"}], "stats": {"total": 1605, "additions": 1597, "deletions": 8}, "files": [{"sha": "33f692f2034a243c7993b19f0fa5ddf1bb733d64", "filename": "gcc/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88ca9ea18f36fca948a0ca25a1762c9ec0230eac/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88ca9ea18f36fca948a0ca25a1762c9ec0230eac/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=88ca9ea18f36fca948a0ca25a1762c9ec0230eac", "patch": "@@ -1,3 +1,33 @@\n+2012-08-07  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n+\n+\t* gimple-ssa-strength-reduction.c (struct incr_info_d): New struct.\n+\t(incr_vec): New static var.\n+\t(incr_vec_len): Likewise.\n+\t(address_arithmetic_p): Likewise.\n+\t(stmt_cost): Remove dead assignment.\n+\t(dump_incr_vec): New function.\n+\t(cand_abs_increment): Likewise.\n+\t(lazy_create_slsr_reg): Likewise.\n+\t(incr_vec_index): Likewise.\n+\t(count_candidates): Likewise.\n+\t(record_increment): Likewise.\n+\t(record_increments): Likewise.\n+\t(unreplaced_cand_in_tree): Likewise.\n+\t(optimize_cands_for_speed_p): Likewise.\n+\t(lowest_cost_path): Likewise.\n+\t(total_savings): Likewise.\n+\t(analyze_increments): Likewise.\n+\t(ncd_for_two_cands): Likewise.\n+\t(nearest_common_dominator_for_cands): Likewise.\n+\t(profitable_increment_p): Likewise.\n+\t(insert_initializers): Likewise.\n+\t(introduce_cast_before_cand): Likewise.\n+\t(replace_rhs_if_not_dup): Likewise.\n+\t(replace_one_candidate): Likewise.\n+\t(replace_profitable_candidates): Likewise.\n+\t(analyze_candidates_and_replace): Handle candidates with SSA-name\n+\tstrides.\n+\n 2012-08-07  Steven Bosscher  <steven@gcc.gnu.org>\n \n \t* cfg.c (debug_bb): Do not set TDF_BLOCKS."}, {"sha": "ccc361e900a5c156fb075f7a1ebdb088a7e8b28f", "filename": "gcc/gimple-ssa-strength-reduction.c", "status": "modified", "additions": 894, "deletions": 8, "changes": 902, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88ca9ea18f36fca948a0ca25a1762c9ec0230eac/gcc%2Fgimple-ssa-strength-reduction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88ca9ea18f36fca948a0ca25a1762c9ec0230eac/gcc%2Fgimple-ssa-strength-reduction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-strength-reduction.c?ref=88ca9ea18f36fca948a0ca25a1762c9ec0230eac", "patch": "@@ -30,8 +30,7 @@ along with GCC; see the file COPYING3.  If not see\n    1) Explicit multiplies, known constant multipliers, no\n       conditional increments. (complete)\n    2) Explicit multiplies, unknown constant multipliers,\n-      no conditional increments. (data gathering complete,\n-      replacements pending)\n+      no conditional increments. (complete)\n    3) Implicit multiplies in addressing expressions. (complete)\n    4) Explicit multiplies, conditional increments. (pending)\n \n@@ -235,6 +234,41 @@ struct cand_chain_d\n typedef struct cand_chain_d cand_chain, *cand_chain_t;\n typedef const struct cand_chain_d *const_cand_chain_t;\n \n+/* Information about a unique \"increment\" associated with candidates\n+   having an SSA name for a stride.  An increment is the difference\n+   between the index of the candidate and the index of its basis,\n+   i.e., (i - i') as discussed in the module commentary.\n+\n+   When we are not going to generate address arithmetic we treat\n+   increments that differ only in sign as the same, allowing sharing\n+   of the cost of initializers.  The absolute value of the increment\n+   is stored in the incr_info.  */\n+\n+struct incr_info_d\n+{\n+  /* The increment that relates a candidate to its basis.  */\n+  double_int incr;\n+\n+  /* How many times the increment occurs in the candidate tree.  */\n+  unsigned count;\n+\n+  /* Cost of replacing candidates using this increment.  Negative and\n+     zero costs indicate replacement should be performed.  */\n+  int cost;\n+\n+  /* If this increment is profitable but is not -1, 0, or 1, it requires\n+     an initializer T_0 = stride * incr to be found or introduced in the\n+     nearest common dominator of all candidates.  This field holds T_0\n+     for subsequent use.  */\n+  tree initializer;\n+\n+  /* If the initializer was found to already exist, this is the block\n+     where it was found.  */\n+  basic_block init_bb;\n+};\n+\n+typedef struct incr_info_d incr_info, *incr_info_t;\n+\n /* Candidates are maintained in a vector.  If candidate X dominates\n    candidate Y, then X appears before Y in the vector; but the\n    converse does not necessarily hold.  */\n@@ -259,6 +293,16 @@ static htab_t base_cand_map;\n \n /* Obstack for candidate chains.  */\n static struct obstack chain_obstack;\n+\n+/* An array INCR_VEC of incr_infos is used during analysis of related\n+   candidates having an SSA name for a stride.  INCR_VEC_LEN describes\n+   its current length.  */\n+static incr_info_t incr_vec;\n+static unsigned incr_vec_len;\n+\n+/* For a chain of candidates with unknown stride, indicates whether or not\n+   we must generate pointer arithmetic when replacing statements.  */\n+static bool address_arithmetic_p;\n \f\n /* Produce a pointer to the IDX'th candidate in the candidate vector.  */\n \n@@ -421,7 +465,6 @@ stmt_cost (gimple gs, bool speed)\n     case PLUS_EXPR:\n     case POINTER_PLUS_EXPR:\n     case MINUS_EXPR:\n-      rhs2 = gimple_assign_rhs2 (gs);\n       return add_cost (speed, lhs_mode);\n \n     case NEGATE_EXPR:\n@@ -1407,6 +1450,30 @@ dump_cand_chains (void)\n   htab_traverse_noresize (base_cand_map, base_cand_dump_callback, NULL);\n   fputs (\"\\n\", dump_file);\n }\n+\n+/* Dump the increment vector for debug.  */\n+\n+static void\n+dump_incr_vec (void)\n+{\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      unsigned i;\n+\n+      fprintf (dump_file, \"\\nIncrement vector:\\n\\n\");\n+  \n+      for (i = 0; i < incr_vec_len; i++)\n+\t{\n+\t  fprintf (dump_file, \"%3d  increment:   \", i);\n+\t  dump_double_int (dump_file, incr_vec[i].incr, false);\n+\t  fprintf (dump_file, \"\\n     count:       %d\", incr_vec[i].count);\n+\t  fprintf (dump_file, \"\\n     cost:        %d\", incr_vec[i].cost);\n+\t  fputs (\"\\n     initializer: \", dump_file);\n+\t  print_generic_expr (dump_file, incr_vec[i].initializer, 0);\n+\t  fputs (\"\\n\\n\", dump_file);\n+\t}\n+    }\n+}\n \f\n /* Recursive helper for unconditional_cands_with_known_stride_p.\n    Returns TRUE iff C, its siblings, and its dependents are all\n@@ -1508,6 +1575,32 @@ cand_increment (slsr_cand_t c)\n   return double_int_sub (c->index, basis->index);\n }\n \n+/* Calculate the increment required for candidate C relative to\n+   its basis.  If we aren't going to generate pointer arithmetic\n+   for this candidate, return the absolute value of that increment\n+   instead.  */\n+\n+static inline double_int\n+cand_abs_increment (slsr_cand_t c)\n+{\n+  double_int increment = cand_increment (c);\n+\n+  if (!address_arithmetic_p && double_int_negative_p (increment))\n+    increment = double_int_neg (increment);\n+\n+  return increment;\n+}\n+\n+/* If *VAR is NULL or is not of a compatible type with TYPE, create a\n+   new temporary reg of type TYPE and store it in *VAR.  */\n+\n+static inline void\n+lazy_create_slsr_reg (tree *var, tree type)\n+{\n+  if (!*var || !types_compatible_p (TREE_TYPE (*var), type))\n+    *var = create_tmp_reg (type, \"slsr\");\n+}\n+\n /* Return TRUE iff candidate C has already been replaced under\n    another interpretation.  */\n \n@@ -1630,6 +1723,764 @@ replace_dependents (slsr_cand_t c)\n     replace_dependents (lookup_cand (c->dependent));\n }\n \f\n+/* Return the index in the increment vector of the given INCREMENT.  */\n+\n+static inline unsigned\n+incr_vec_index (double_int increment)\n+{\n+  unsigned i;\n+  \n+  for (i = 0;\n+       i < incr_vec_len && !double_int_equal_p (increment, incr_vec[i].incr);\n+       i++)\n+    ;\n+\n+  gcc_assert (i < incr_vec_len);\n+  return i;\n+}\n+\n+/* Count the number of candidates in the tree rooted at C that have\n+   not already been replaced under other interpretations.  */\n+\n+static unsigned\n+count_candidates (slsr_cand_t c)\n+{\n+  unsigned count = cand_already_replaced (c) ? 0 : 1;\n+\n+  if (c->sibling)\n+    count += count_candidates (lookup_cand (c->sibling));\n+\n+  if (c->dependent)\n+    count += count_candidates (lookup_cand (c->dependent));\n+\n+  return count;\n+}\n+\n+/* Increase the count of INCREMENT by one in the increment vector.\n+   INCREMENT is associated with candidate C.  If an initializer\n+   T_0 = stride * I is provided by a candidate that dominates all\n+   candidates with the same increment, also record T_0 for subsequent use.  */\n+\n+static void\n+record_increment (slsr_cand_t c, double_int increment)\n+{\n+  bool found = false;\n+  unsigned i;\n+\n+  /* Treat increments that differ only in sign as identical so as to\n+     share initializers, unless we are generating pointer arithmetic.  */\n+  if (!address_arithmetic_p && double_int_negative_p (increment))\n+    increment = double_int_neg (increment);\n+\n+  for (i = 0; i < incr_vec_len; i++)\n+    {\n+      if (double_int_equal_p (incr_vec[i].incr, increment))\n+\t{\n+\t  incr_vec[i].count++;\n+\t  found = true;\n+\n+\t  /* If we previously recorded an initializer that doesn't\n+\t     dominate this candidate, it's not going to be useful to\n+\t     us after all.  */\n+\t  if (incr_vec[i].initializer\n+\t      && !dominated_by_p (CDI_DOMINATORS,\n+\t\t\t\t  gimple_bb (c->cand_stmt),\n+\t\t\t\t  incr_vec[i].init_bb))\n+\t    {\n+\t      incr_vec[i].initializer = NULL_TREE;\n+\t      incr_vec[i].init_bb = NULL;\n+\t    }\n+\t  \n+\t  break;\n+\t}\n+    }\n+\n+  if (!found)\n+    {\n+      /* The first time we see an increment, create the entry for it.\n+\t If this is the root candidate which doesn't have a basis, set\n+\t the count to zero.  We're only processing it so it can possibly\n+\t provide an initializer for other candidates.  */\n+      incr_vec[incr_vec_len].incr = increment;\n+      incr_vec[incr_vec_len].count = c->basis ? 1 : 0;\n+      incr_vec[incr_vec_len].cost = COST_INFINITE;\n+      \n+      /* Optimistically record the first occurrence of this increment\n+\t as providing an initializer (if it does); we will revise this\n+\t opinion later if it doesn't dominate all other occurrences.\n+         Exception:  increments of -1, 0, 1 never need initializers.  */\n+      if (c->kind == CAND_ADD\n+\t  && double_int_equal_p (c->index, increment)\n+\t  && (double_int_scmp (increment, double_int_one) > 0\n+\t      || double_int_scmp (increment, double_int_minus_one) < 0))\n+\t{\n+\t  tree t0;\n+\t  tree rhs1 = gimple_assign_rhs1 (c->cand_stmt);\n+\t  tree rhs2 = gimple_assign_rhs2 (c->cand_stmt);\n+\t  if (operand_equal_p (rhs1, c->base_expr, 0))\n+\t    t0 = rhs2;\n+\t  else\n+\t    t0 = rhs1;\n+\t  if (SSA_NAME_DEF_STMT (t0) && gimple_bb (SSA_NAME_DEF_STMT (t0)))\n+\t    {\n+\t      incr_vec[incr_vec_len].initializer = t0;\n+\t      incr_vec[incr_vec_len++].init_bb\n+\t\t= gimple_bb (SSA_NAME_DEF_STMT (t0));\n+\t    }\n+\t  else\n+\t    {\n+\t      incr_vec[incr_vec_len].initializer = NULL_TREE;\n+\t      incr_vec[incr_vec_len++].init_bb = NULL;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  incr_vec[incr_vec_len].initializer = NULL_TREE;\n+\t  incr_vec[incr_vec_len++].init_bb = NULL;\n+\t}\n+    }\n+}\n+\n+/* Determine how many times each unique increment occurs in the set\n+   of candidates rooted at C's parent, recording the data in the\n+   increment vector.  For each unique increment I, if an initializer\n+   T_0 = stride * I is provided by a candidate that dominates all\n+   candidates with the same increment, also record T_0 for subsequent\n+   use.  */\n+\n+static void\n+record_increments (slsr_cand_t c)\n+{\n+  if (!cand_already_replaced (c))\n+    record_increment (c, cand_increment (c));\n+\n+  if (c->sibling)\n+    record_increments (lookup_cand (c->sibling));\n+\n+  if (c->dependent)\n+    record_increments (lookup_cand (c->dependent));\n+}\n+\n+/* Return the first candidate in the tree rooted at C that has not\n+   already been replaced, favoring siblings over dependents.  */\n+\n+static slsr_cand_t\n+unreplaced_cand_in_tree (slsr_cand_t c)\n+{\n+  if (!cand_already_replaced (c))\n+    return c;\n+\n+  if (c->sibling)\n+    {\n+      slsr_cand_t sib = unreplaced_cand_in_tree (lookup_cand (c->sibling));\n+      if (sib)\n+\treturn sib;\n+    }\n+\n+  if (c->dependent)\n+    {\n+      slsr_cand_t dep = unreplaced_cand_in_tree (lookup_cand (c->dependent));\n+      if (dep)\n+\treturn dep;\n+    }\n+\n+  return NULL;\n+}\n+\n+/* Return TRUE if the candidates in the tree rooted at C should be\n+   optimized for speed, else FALSE.  We estimate this based on the block\n+   containing the most dominant candidate in the tree that has not yet\n+   been replaced.  */\n+\n+static bool\n+optimize_cands_for_speed_p (slsr_cand_t c)\n+{\n+  slsr_cand_t c2 = unreplaced_cand_in_tree (c);\n+  gcc_assert (c2);\n+  return optimize_bb_for_speed_p (gimple_bb (c2->cand_stmt));\n+}\n+\n+/* Add COST_IN to the lowest cost of any dependent path starting at\n+   candidate C or any of its siblings, counting only candidates along\n+   such paths with increment INCR.  Assume that replacing a candidate\n+   reduces cost by REPL_SAVINGS.  Also account for savings from any\n+   statements that would go dead.  */\n+\n+static int\n+lowest_cost_path (int cost_in, int repl_savings, slsr_cand_t c, double_int incr)\n+{\n+  int local_cost, sib_cost;\n+  double_int cand_incr = cand_abs_increment (c);\n+\n+  if (cand_already_replaced (c))\n+    local_cost = cost_in;\n+  else if (double_int_equal_p (incr, cand_incr))\n+    local_cost = cost_in - repl_savings - c->dead_savings;\n+  else\n+    local_cost = cost_in - c->dead_savings;\n+\n+  if (c->dependent)\n+    local_cost = lowest_cost_path (local_cost, repl_savings, \n+\t\t\t\t   lookup_cand (c->dependent), incr);\n+\n+  if (c->sibling)\n+    {\n+      sib_cost = lowest_cost_path (cost_in, repl_savings,\n+\t\t\t\t   lookup_cand (c->sibling), incr);\n+      local_cost = MIN (local_cost, sib_cost);\n+    }\n+\n+  return local_cost;\n+}\n+\n+/* Compute the total savings that would accrue from all replacements\n+   in the candidate tree rooted at C, counting only candidates with\n+   increment INCR.  Assume that replacing a candidate reduces cost\n+   by REPL_SAVINGS.  Also account for savings from statements that\n+   would go dead.  */\n+\n+static int\n+total_savings (int repl_savings, slsr_cand_t c, double_int incr)\n+{\n+  int savings = 0;\n+  double_int cand_incr = cand_abs_increment (c);\n+\n+  if (double_int_equal_p (incr, cand_incr)\n+      && !cand_already_replaced (c))\n+    savings += repl_savings + c->dead_savings;\n+\n+  if (c->dependent)\n+    savings += total_savings (repl_savings, lookup_cand (c->dependent), incr);\n+\n+  if (c->sibling)\n+    savings += total_savings (repl_savings, lookup_cand (c->sibling), incr);\n+\n+  return savings;\n+}\n+\n+/* Use target-specific costs to determine and record which increments\n+   in the current candidate tree are profitable to replace, assuming\n+   MODE and SPEED.  FIRST_DEP is the first dependent of the root of\n+   the candidate tree.\n+\n+   One slight limitation here is that we don't account for the possible\n+   introduction of casts in some cases.  See replace_one_candidate for\n+   the cases where these are introduced.  This should probably be cleaned\n+   up sometime.  */\n+\n+static void\n+analyze_increments (slsr_cand_t first_dep, enum machine_mode mode, bool speed)\n+{\n+  unsigned i;\n+\n+  for (i = 0; i < incr_vec_len; i++)\n+    {\n+      HOST_WIDE_INT incr = double_int_to_shwi (incr_vec[i].incr);\n+\n+      /* If somehow this increment is bigger than a HWI, we won't\n+\t be optimizing candidates that use it.  And if the increment\n+\t has a count of zero, nothing will be done with it.  */\n+      if (!double_int_fits_in_shwi_p (incr_vec[i].incr)\n+\t  || !incr_vec[i].count)\n+\tincr_vec[i].cost = COST_INFINITE;\n+\n+      /* Increments of 0, 1, and -1 are always profitable to replace,\n+\t because they always replace a multiply or add with an add or\n+\t copy, and may cause one or more existing instructions to go\n+\t dead.  Exception:  -1 can't be assumed to be profitable for\n+\t pointer addition.  */\n+      else if (incr == 0\n+\t       || incr == 1\n+\t       || (incr == -1\n+\t\t   && (gimple_assign_rhs_code (first_dep->cand_stmt)\n+\t\t       != POINTER_PLUS_EXPR)))\n+\tincr_vec[i].cost = COST_NEUTRAL;\n+      \n+      /* For any other increment, if this is a multiply candidate, we\n+\t must introduce a temporary T and initialize it with\n+\t T_0 = stride * increment.  When optimizing for speed, walk the\n+\t candidate tree to calculate the best cost reduction along any\n+\t path; if it offsets the fixed cost of inserting the initializer,\n+\t replacing the increment is profitable.  When optimizing for\n+         size, instead calculate the total cost reduction from replacing\n+\t all candidates with this increment.  */\n+      else if (first_dep->kind == CAND_MULT)\n+\t{\n+\t  int cost = mult_by_coeff_cost (incr, mode, speed);\n+\t  int repl_savings = mul_cost (speed, mode) - add_cost (speed, mode);\n+\t  if (speed)\n+\t    cost = lowest_cost_path (cost, repl_savings, first_dep,\n+\t\t\t\t     incr_vec[i].incr);\n+\t  else\n+\t    cost -= total_savings (repl_savings, first_dep, incr_vec[i].incr);\n+\n+\t  incr_vec[i].cost = cost;\n+\t}\n+\n+      /* If this is an add candidate, the initializer may already\n+\t exist, so only calculate the cost of the initializer if it\n+\t doesn't.  We are replacing one add with another here, so the\n+\t known replacement savings is zero.  We will account for removal\n+\t of dead instructions in lowest_cost_path or total_savings.  */\n+      else\n+\t{\n+\t  int cost = 0;\n+\t  if (!incr_vec[i].initializer)\n+\t    cost = mult_by_coeff_cost (incr, mode, speed);\n+\n+\t  if (speed)\n+\t    cost = lowest_cost_path (cost, 0, first_dep, incr_vec[i].incr);\n+\t  else\n+\t    cost -= total_savings (0, first_dep, incr_vec[i].incr);\n+\n+\t  incr_vec[i].cost = cost;\n+\t}\n+    }\n+}\n+\n+/* Return the nearest common dominator of BB1 and BB2.  If the blocks\n+   are identical, return the earlier of C1 and C2 in *WHERE.  Otherwise,\n+   if the NCD matches BB1, return C1 in *WHERE; if the NCD matches BB2,\n+   return C2 in *WHERE; and if the NCD matches neither, return NULL in\n+   *WHERE.  Note: It is possible for one of C1 and C2 to be NULL.  */\n+\n+static basic_block\n+ncd_for_two_cands (basic_block bb1, basic_block bb2,\n+\t\t   slsr_cand_t c1, slsr_cand_t c2, slsr_cand_t *where)\n+{\n+  basic_block ncd;\n+\n+  if (!bb1)\n+    {\n+      *where = c2;\n+      return bb2;\n+    }\n+\n+  if (!bb2)\n+    {\n+      *where = c1;\n+      return bb1;\n+    }\n+\n+  ncd = nearest_common_dominator (CDI_DOMINATORS, bb1, bb2);\n+      \n+  /* If both candidates are in the same block, the earlier\n+     candidate wins.  */\n+  if (bb1 == ncd && bb2 == ncd)\n+    {\n+      if (!c1 || (c2 && c2->cand_num < c1->cand_num))\n+\t*where = c2;\n+      else\n+\t*where = c1;\n+    }\n+\n+  /* Otherwise, if one of them produced a candidate in the\n+     dominator, that one wins.  */\n+  else if (bb1 == ncd)\n+    *where = c1;\n+\n+  else if (bb2 == ncd)\n+    *where = c2;\n+\n+  /* If neither matches the dominator, neither wins.  */\n+  else\n+    *where = NULL;\n+\n+  return ncd;\n+}\n+\n+/* Consider all candidates in the tree rooted at C for which INCR\n+   represents the required increment of C relative to its basis.\n+   Find and return the basic block that most nearly dominates all\n+   such candidates.  If the returned block contains one or more of\n+   the candidates, return the earliest candidate in the block in\n+   *WHERE.  */\n+\n+static basic_block\n+nearest_common_dominator_for_cands (slsr_cand_t c, double_int incr,\n+\t\t\t\t    slsr_cand_t *where)\n+{\n+  basic_block sib_ncd = NULL, dep_ncd = NULL, this_ncd = NULL, ncd;\n+  slsr_cand_t sib_where = NULL, dep_where = NULL, this_where = NULL, new_where;\n+  double_int cand_incr;\n+\n+  /* First find the NCD of all siblings and dependents.  */\n+  if (c->sibling)\n+    sib_ncd = nearest_common_dominator_for_cands (lookup_cand (c->sibling),\n+\t\t\t\t\t\t  incr, &sib_where);\n+  if (c->dependent)\n+    dep_ncd = nearest_common_dominator_for_cands (lookup_cand (c->dependent),\n+\t\t\t\t\t\t  incr, &dep_where);\n+  if (!sib_ncd && !dep_ncd)\n+    {\n+      new_where = NULL;\n+      ncd = NULL;\n+    }\n+  else if (sib_ncd && !dep_ncd)\n+    {\n+      new_where = sib_where;\n+      ncd = sib_ncd;\n+    }\n+  else if (dep_ncd && !sib_ncd)\n+    {\n+      new_where = dep_where;\n+      ncd = dep_ncd;\n+    }\n+  else\n+    ncd = ncd_for_two_cands (sib_ncd, dep_ncd, sib_where,\n+\t\t\t     dep_where, &new_where);\n+\n+  /* If the candidate's increment doesn't match the one we're interested\n+     in, then the result depends only on siblings and dependents.  */\n+  cand_incr = cand_abs_increment (c);\n+\n+  if (!double_int_equal_p (cand_incr, incr) || cand_already_replaced (c))\n+    {\n+      *where = new_where;\n+      return ncd;\n+    }\n+\n+  /* Otherwise, compare this candidate with the result from all siblings\n+     and dependents.  */\n+  this_where = c;\n+  this_ncd = gimple_bb (c->cand_stmt);\n+  ncd = ncd_for_two_cands (ncd, this_ncd, new_where, this_where, where);\n+\n+  return ncd;\n+}\n+\n+/* Return TRUE if the increment indexed by INDEX is profitable to replace.  */\n+\n+static inline bool\n+profitable_increment_p (unsigned index)\n+{\n+  return (incr_vec[index].cost <= COST_NEUTRAL);\n+}\n+\n+/* For each profitable increment in the increment vector not equal to\n+   0 or 1 (or -1, for non-pointer arithmetic), find the nearest common\n+   dominator of all statements in the candidate chain rooted at C\n+   that require that increment, and insert an initializer\n+   T_0 = stride * increment at that location.  Record T_0 with the\n+   increment record.  */\n+\n+static void\n+insert_initializers (slsr_cand_t c)\n+{\n+  unsigned i;\n+  tree new_var = NULL_TREE;\n+\n+  for (i = 0; i < incr_vec_len; i++)\n+    {\n+      basic_block bb;\n+      slsr_cand_t where = NULL;\n+      gimple init_stmt;\n+      tree stride_type, new_name, incr_tree;\n+      double_int incr = incr_vec[i].incr;\n+\n+      if (!profitable_increment_p (i)\n+\t  || double_int_one_p (incr)\n+\t  || (double_int_minus_one_p (incr)\n+\t      && gimple_assign_rhs_code (c->cand_stmt) != POINTER_PLUS_EXPR)\n+\t  || double_int_zero_p (incr))\n+\tcontinue;\n+\n+      /* We may have already identified an existing initializer that\n+\t will suffice.  */\n+      if (incr_vec[i].initializer)\n+\t{\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    {\n+\t      fputs (\"Using existing initializer: \", dump_file);\n+\t      print_gimple_stmt (dump_file,\n+\t\t\t\t SSA_NAME_DEF_STMT (incr_vec[i].initializer),\n+\t\t\t\t 0, 0);\n+\t    }\n+\t  continue;\n+\t}\n+\n+      /* Find the block that most closely dominates all candidates\n+\t with this increment.  If there is at least one candidate in\n+\t that block, the earliest one will be returned in WHERE.  */\n+      bb = nearest_common_dominator_for_cands (c, incr, &where);\n+\n+      /* Create a new SSA name to hold the initializer's value.  */\n+      stride_type = TREE_TYPE (c->stride);\n+      lazy_create_slsr_reg (&new_var, stride_type);\n+      new_name = make_ssa_name (new_var, NULL);\n+      incr_vec[i].initializer = new_name;\n+\n+      /* Create the initializer and insert it in the latest possible\n+\t dominating position.  */\n+      incr_tree = double_int_to_tree (stride_type, incr);\n+      init_stmt = gimple_build_assign_with_ops (MULT_EXPR, new_name,\n+\t\t\t\t\t\tc->stride, incr_tree);\n+      if (where)\n+\t{\n+\t  gimple_stmt_iterator gsi = gsi_for_stmt (where->cand_stmt);\n+\t  gsi_insert_before (&gsi, init_stmt, GSI_SAME_STMT);\n+\t  gimple_set_location (init_stmt, gimple_location (where->cand_stmt));\n+\t}\n+      else\n+\t{\n+\t  gimple_stmt_iterator gsi = gsi_last_bb (bb);\n+\t  gimple basis_stmt = lookup_cand (c->basis)->cand_stmt;\n+\n+\t  if (!gsi_end_p (gsi) && is_ctrl_stmt (gsi_stmt (gsi)))\n+\t    gsi_insert_before (&gsi, init_stmt, GSI_SAME_STMT);\n+\t  else\n+\t    gsi_insert_after (&gsi, init_stmt, GSI_SAME_STMT);\n+\n+\t  gimple_set_location (init_stmt, gimple_location (basis_stmt));\n+\t}\n+\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  fputs (\"Inserting initializer: \", dump_file);\n+\t  print_gimple_stmt (dump_file, init_stmt, 0, 0);\n+\t}\n+    }\n+}\n+\n+/* Create a NOP_EXPR that copies FROM_EXPR into a new SSA name of\n+   type TO_TYPE, and insert it in front of the statement represented\n+   by candidate C.  Use *NEW_VAR to create the new SSA name.  Return\n+   the new SSA name.  */\n+\n+static tree\n+introduce_cast_before_cand (slsr_cand_t c, tree to_type,\n+\t\t\t    tree from_expr, tree *new_var)\n+{\n+  tree cast_lhs;\n+  gimple cast_stmt;\n+  gimple_stmt_iterator gsi = gsi_for_stmt (c->cand_stmt);\n+\n+  lazy_create_slsr_reg (new_var, to_type);\n+  cast_lhs = make_ssa_name (*new_var, NULL);\n+  cast_stmt = gimple_build_assign_with_ops (NOP_EXPR, cast_lhs,\n+\t\t\t\t\t    from_expr, NULL_TREE);\n+  gimple_set_location (cast_stmt, gimple_location (c->cand_stmt));\n+  gsi_insert_before (&gsi, cast_stmt, GSI_SAME_STMT);\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fputs (\"  Inserting: \", dump_file);\n+      print_gimple_stmt (dump_file, cast_stmt, 0, 0);\n+    }\n+\n+  return cast_lhs;\n+}\n+\n+/* Replace the RHS of the statement represented by candidate C with \n+   NEW_CODE, NEW_RHS1, and NEW_RHS2, provided that to do so doesn't\n+   leave C unchanged or just interchange its operands.  The original\n+   operation and operands are in OLD_CODE, OLD_RHS1, and OLD_RHS2.\n+   If the replacement was made and we are doing a details dump,\n+   return the revised statement, else NULL.  */\n+\n+static gimple\n+replace_rhs_if_not_dup (enum tree_code new_code, tree new_rhs1, tree new_rhs2,\n+\t\t\tenum tree_code old_code, tree old_rhs1, tree old_rhs2,\n+\t\t\tslsr_cand_t c)\n+{\n+  if (new_code != old_code\n+      || ((!operand_equal_p (new_rhs1, old_rhs1, 0)\n+\t   || !operand_equal_p (new_rhs2, old_rhs2, 0))\n+\t  && (!operand_equal_p (new_rhs1, old_rhs2, 0)\n+\t      || !operand_equal_p (new_rhs2, old_rhs1, 0))))\n+    {\n+      gimple_stmt_iterator gsi = gsi_for_stmt (c->cand_stmt);\n+      gimple_assign_set_rhs_with_ops (&gsi, new_code, new_rhs1, new_rhs2);\n+      update_stmt (gsi_stmt (gsi));\n+\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\treturn gsi_stmt (gsi);\n+    }\n+\n+  else if (dump_file && (dump_flags & TDF_DETAILS))\n+    fputs (\"  (duplicate, not actually replacing)\\n\", dump_file);\n+\n+  return NULL;\n+}\n+\n+/* Strength-reduce the statement represented by candidate C by replacing\n+   it with an equivalent addition or subtraction.  I is the index into\n+   the increment vector identifying C's increment.  NEW_VAR is used to\n+   create a new SSA name if a cast needs to be introduced.  BASIS_NAME\n+   is the rhs1 to use in creating the add/subtract.  */\n+\n+static void\n+replace_one_candidate (slsr_cand_t c, unsigned i, tree *new_var,\n+\t\t       tree basis_name)\n+{\n+  gimple stmt_to_print = NULL;\n+  tree orig_rhs1, orig_rhs2;\n+  tree rhs2;\n+  enum tree_code orig_code, repl_code;\n+  double_int cand_incr;\n+\n+  orig_code = gimple_assign_rhs_code (c->cand_stmt);\n+  orig_rhs1 = gimple_assign_rhs1 (c->cand_stmt);\n+  orig_rhs2 = gimple_assign_rhs2 (c->cand_stmt);\n+  cand_incr = cand_increment (c);\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fputs (\"Replacing: \", dump_file);\n+      print_gimple_stmt (dump_file, c->cand_stmt, 0, 0);\n+      stmt_to_print = c->cand_stmt;\n+    }\n+\n+  if (address_arithmetic_p)\n+    repl_code = POINTER_PLUS_EXPR;\n+  else\n+    repl_code = PLUS_EXPR;\n+\n+  /* If the increment has an initializer T_0, replace the candidate\n+     statement with an add of the basis name and the initializer.  */\n+  if (incr_vec[i].initializer)\n+    {\n+      tree init_type = TREE_TYPE (incr_vec[i].initializer);\n+      tree orig_type = TREE_TYPE (orig_rhs2);\n+\n+      if (types_compatible_p (orig_type, init_type))\n+\trhs2 = incr_vec[i].initializer;\n+      else\n+\trhs2 = introduce_cast_before_cand (c, orig_type,\n+\t\t\t\t\t   incr_vec[i].initializer,\n+\t\t\t\t\t   new_var);\n+\n+      if (!double_int_equal_p (incr_vec[i].incr, cand_incr))\n+\t{\n+\t  gcc_assert (repl_code == PLUS_EXPR);\n+\t  repl_code = MINUS_EXPR;\n+\t}\n+\n+      stmt_to_print = replace_rhs_if_not_dup (repl_code, basis_name, rhs2,\n+\t\t\t\t\t      orig_code, orig_rhs1, orig_rhs2,\n+\t\t\t\t\t      c);\n+    }\n+\n+  /* Otherwise, the increment is one of -1, 0, and 1.  Replace\n+     with a subtract of the stride from the basis name, a copy\n+     from the basis name, or an add of the stride to the basis\n+     name, respectively.  It may be necessary to introduce a\n+     cast (or reuse an existing cast).  */\n+  else if (double_int_one_p (cand_incr))\n+    {\n+      tree stride_type = TREE_TYPE (c->stride);\n+      tree orig_type = TREE_TYPE (orig_rhs2);\n+      \n+      if (types_compatible_p (orig_type, stride_type))\n+\trhs2 = c->stride;\n+      else\n+\trhs2 = introduce_cast_before_cand (c, orig_type, c->stride, new_var);\n+      \n+      stmt_to_print = replace_rhs_if_not_dup (repl_code, basis_name, rhs2,\n+\t\t\t\t\t      orig_code, orig_rhs1, orig_rhs2,\n+\t\t\t\t\t      c);\n+    }\n+\n+  else if (double_int_minus_one_p (cand_incr))\n+    {\n+      tree stride_type = TREE_TYPE (c->stride);\n+      tree orig_type = TREE_TYPE (orig_rhs2);\n+      gcc_assert (repl_code != POINTER_PLUS_EXPR);\n+      \n+      if (types_compatible_p (orig_type, stride_type))\n+\trhs2 = c->stride;\n+      else\n+\trhs2 = introduce_cast_before_cand (c, orig_type, c->stride, new_var);\n+      \n+      if (orig_code != MINUS_EXPR\n+\t  || !operand_equal_p (basis_name, orig_rhs1, 0)\n+\t  || !operand_equal_p (rhs2, orig_rhs2, 0))\n+\t{\n+\t  gimple_stmt_iterator gsi = gsi_for_stmt (c->cand_stmt);\n+\t  gimple_assign_set_rhs_with_ops (&gsi, MINUS_EXPR, basis_name, rhs2);\n+\t  update_stmt (gsi_stmt (gsi));\n+\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    stmt_to_print = gsi_stmt (gsi);\n+\t}\n+      else if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfputs (\"  (duplicate, not actually replacing)\\n\", dump_file);\n+    }\n+\n+  else if (double_int_zero_p (cand_incr))\n+    {\n+      tree lhs = gimple_assign_lhs (c->cand_stmt);\n+      tree lhs_type = TREE_TYPE (lhs);\n+      tree basis_type = TREE_TYPE (basis_name);\n+      \n+      if (types_compatible_p (lhs_type, basis_type))\n+\t{\n+\t  gimple copy_stmt = gimple_build_assign (lhs, basis_name);\n+\t  gimple_stmt_iterator gsi = gsi_for_stmt (c->cand_stmt);\n+\t  gimple_set_location (copy_stmt, gimple_location (c->cand_stmt));\n+\t  gsi_replace (&gsi, copy_stmt, false);\n+\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    stmt_to_print = copy_stmt;\n+\t}\n+      else\n+\t{\n+\t  gimple_stmt_iterator gsi = gsi_for_stmt (c->cand_stmt);\n+\t  gimple cast_stmt = gimple_build_assign_with_ops (NOP_EXPR, lhs,\n+\t\t\t\t\t\t\t   basis_name,\n+\t\t\t\t\t\t\t   NULL_TREE);\n+\t  gimple_set_location (cast_stmt, gimple_location (c->cand_stmt));\n+\t  gsi_replace (&gsi, cast_stmt, false);\n+\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    stmt_to_print = cast_stmt;\n+\t}\n+    }\n+  else\n+    gcc_unreachable ();\n+  \n+  if (dump_file && (dump_flags & TDF_DETAILS) && stmt_to_print)\n+    {\n+      fputs (\"With: \", dump_file);\n+      print_gimple_stmt (dump_file, stmt_to_print, 0, 0);\n+      fputs (\"\\n\", dump_file);\n+    }\n+}\n+\n+/* For each candidate in the tree rooted at C, replace it with\n+   an increment if such has been shown to be profitable.  */\n+\n+static void\n+replace_profitable_candidates (slsr_cand_t c)\n+{\n+  if (!cand_already_replaced (c))\n+    {\n+      double_int increment = cand_abs_increment (c);\n+      tree new_var = NULL;\n+      enum tree_code orig_code = gimple_assign_rhs_code (c->cand_stmt);\n+      unsigned i;\n+\n+      i = incr_vec_index (increment);\n+\n+      /* Only process profitable increments.  Nothing useful can be done\n+\t to a cast or copy.  */\n+      if (profitable_increment_p (i) \n+\t  && orig_code != MODIFY_EXPR\n+\t  && orig_code != NOP_EXPR)\n+\t{\n+\t  slsr_cand_t basis = lookup_cand (c->basis);\n+\t  tree basis_name = gimple_assign_lhs (basis->cand_stmt);\n+\t  replace_one_candidate (c, i, &new_var, basis_name);\n+\t}\n+    }\n+\n+  if (c->sibling)\n+    replace_profitable_candidates (lookup_cand (c->sibling));\n+\n+  if (c->dependent)\n+    replace_profitable_candidates (lookup_cand (c->dependent));\n+}\n+\f\n /* Analyze costs of related candidates in the candidate vector,\n    and make beneficial replacements.  */\n \n@@ -1670,11 +2521,46 @@ analyze_candidates_and_replace (void)\n       else if (unconditional_cands_with_known_stride_p (c))\n \treplace_dependents (first_dep);\n \n-      /* TODO:  When the stride is an SSA name, it may still be\n-\t profitable to replace some or all of the dependent\n-\t candidates, depending on whether the introduced increments\n-\t can be reused, or are less expensive to calculate than\n-\t the replaced statements.  */\n+      /* When the stride is an SSA name, it may still be profitable\n+\t to replace some or all of the dependent candidates, depending\n+\t on whether the introduced increments can be reused, or are\n+\t less expensive to calculate than the replaced statements.  */\n+      else\n+\t{\n+\t  unsigned length;\n+\t  enum machine_mode mode;\n+\t  bool speed;\n+\n+\t  /* Determine whether we'll be generating pointer arithmetic\n+\t     when replacing candidates.  */\n+\t  address_arithmetic_p = (c->kind == CAND_ADD\n+\t\t\t\t  && POINTER_TYPE_P (TREE_TYPE (c->base_expr)));\n+\n+\t  /* If all candidates have already been replaced under other\n+\t     interpretations, nothing remains to be done.  */\n+\t  length = count_candidates (c);\n+\t  if (!length)\n+\t    continue;\n+\n+\t  /* Construct an array of increments for this candidate chain.  */\n+\t  incr_vec = XNEWVEC (incr_info, length);\n+\t  incr_vec_len = 0;\n+\t  record_increments (c);\n+\n+\t  /* Determine which increments are profitable to replace.  */\n+\t  mode = TYPE_MODE (TREE_TYPE (gimple_assign_lhs (c->cand_stmt)));\n+\t  speed = optimize_cands_for_speed_p (c);\n+\t  analyze_increments (first_dep, mode, speed);\n+\n+\t  /* Insert initializers of the form T_0 = stride * increment\n+\t     for use in profitable replacements.  */\n+\t  insert_initializers (first_dep);\n+\t  dump_incr_vec ();\n+\n+\t  /* Perform the replacements.  */\n+\t  replace_profitable_candidates (first_dep);\n+\t  free (incr_vec);\n+\t}\n \n       /* TODO:  When conditional increments occur so that a \n \t candidate is dependent upon a phi-basis, the cost of"}, {"sha": "171a16ecf4a81c491e0e4fc9f985a82f515484ea", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88ca9ea18f36fca948a0ca25a1762c9ec0230eac/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88ca9ea18f36fca948a0ca25a1762c9ec0230eac/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=88ca9ea18f36fca948a0ca25a1762c9ec0230eac", "patch": "@@ -1,3 +1,30 @@\n+2012-08-07  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n+\n+\t* gcc.dg/tree-ssa/slsr-5.c: New.\n+\t* gcc.dg/tree-ssa/slsr-6.c: New.\n+\t* gcc.dg/tree-ssa/slsr-7.c: New.\n+\t* gcc.dg/tree-ssa/slsr-8.c: New.\n+\t* gcc.dg/tree-ssa/slsr-9.c: New.\n+\t* gcc.dg/tree-ssa/slsr-10.c: New.\n+\t* gcc.dg/tree-ssa/slsr-11.c: New.\n+\t* gcc.dg/tree-ssa/slsr-12.c: New.\n+\t* gcc.dg/tree-ssa/slsr-13.c: New.\n+\t* gcc.dg/tree-ssa/slsr-14.c: New.\n+\t* gcc.dg/tree-ssa/slsr-15.c: New.\n+\t* gcc.dg/tree-ssa/slsr-16.c: New.\n+\t* gcc.dg/tree-ssa/slsr-17.c: New.\n+\t* gcc.dg/tree-ssa/slsr-18.c: New.\n+\t* gcc.dg/tree-ssa/slsr-19.c: New.\n+\t* gcc.dg/tree-ssa/slsr-20.c: New.\n+\t* gcc.dg/tree-ssa/slsr-21.c: New.\n+\t* gcc.dg/tree-ssa/slsr-22.c: New.\n+\t* gcc.dg/tree-ssa/slsr-23.c: New.\n+\t* gcc.dg/tree-ssa/slsr-24.c: New.\n+\t* gcc.dg/tree-ssa/slsr-25.c: New.\n+\t* gcc.dg/tree-ssa/slsr-26.c: New.\n+\t* gcc.dg/tree-ssa/slsr-30.c: New.\n+\t* gcc.dg/tree-ssa/slsr-31.c: New.\n+\n 2012-08-07  Steven Bosscher  <steven@gcc.gnu.org>\n \n \t* gcc.dg/tree-prof/update-loopch.c: Ask for dump with blocks info."}, {"sha": "f131dae3b48fc5ce335a2e875d23d84f6c26ba27", "filename": "gcc/testsuite/gcc.dg/tree-ssa/slsr-10.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88ca9ea18f36fca948a0ca25a1762c9ec0230eac/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88ca9ea18f36fca948a0ca25a1762c9ec0230eac/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-10.c?ref=88ca9ea18f36fca948a0ca25a1762c9ec0230eac", "patch": "@@ -0,0 +1,23 @@\n+/* Verify straight-line strength reduction for simple integer addition\n+   with stride reversed on 1st and 3rd instances.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fdump-tree-optimized\" } */\n+\n+int\n+f (int s, int c)\n+{\n+  int a1, a2, a3, x1, x2, x3, x;\n+\n+  a1 = 2 * s;\n+  x1 = a1 + c;\n+  a2 = 4 * s;\n+  x2 = c + a2;\n+  a3 = 6 * s;\n+  x3 = a3 + c;\n+  x = x1 + x2 + x3;\n+  return x;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \" \\\\* \" 1 \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "6f77d518574c10ef1e3848535731dc83661b26da", "filename": "gcc/testsuite/gcc.dg/tree-ssa/slsr-11.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88ca9ea18f36fca948a0ca25a1762c9ec0230eac/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88ca9ea18f36fca948a0ca25a1762c9ec0230eac/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-11.c?ref=88ca9ea18f36fca948a0ca25a1762c9ec0230eac", "patch": "@@ -0,0 +1,24 @@\n+/* Verify straight-line strength reduction for simple integer addition\n+   with casts thrown in.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fdump-tree-optimized\" } */\n+\n+long\n+f (int s, long c)\n+{\n+  int a1, a2, a3;\n+  long x1, x2, x3, x;\n+\n+  a1 = 2 * s;\n+  x1 = c + a1;\n+  a2 = 4 * s;\n+  x2 = c + a2;\n+  a3 = 6 * s;\n+  x3 = c + a3;\n+  x = x1 + x2 + x3;\n+  return x;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \" \\\\* \" 1 \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "558b3594e74480773105a0717c64f80594539f58", "filename": "gcc/testsuite/gcc.dg/tree-ssa/slsr-12.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88ca9ea18f36fca948a0ca25a1762c9ec0230eac/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88ca9ea18f36fca948a0ca25a1762c9ec0230eac/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-12.c?ref=88ca9ea18f36fca948a0ca25a1762c9ec0230eac", "patch": "@@ -0,0 +1,30 @@\n+/* Verify that no straight-line strength reduction occurs across sibling\n+   blocks.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fdump-tree-optimized\" } */\n+\n+int\n+f (int s, int c)\n+{\n+  int a1, a2, a3, x1, x2, x3, x;\n+\n+  if (c > 0)\n+    {\n+      a1 = 2 * s;\n+      x1 = c + a1;\n+    }\n+  else\n+    {\n+      a1 = 4 * s;\n+      x1 = c + a1;\n+    }\n+\n+  a2 = 6 * s;\n+  x2 = c + a2;\n+  x = x1 + x2;\n+  return x;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \" \\\\* \" 3 \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "5cdfb9d37a2f6b542c244582e98fd3af678ef271", "filename": "gcc/testsuite/gcc.dg/tree-ssa/slsr-13.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88ca9ea18f36fca948a0ca25a1762c9ec0230eac/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88ca9ea18f36fca948a0ca25a1762c9ec0230eac/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-13.c?ref=88ca9ea18f36fca948a0ca25a1762c9ec0230eac", "patch": "@@ -0,0 +1,25 @@\n+/* x2 and x3 will be strength-reduced based on the same statement\n+   but with different variables as the stride.  Note that they will\n+   be strength-reduced by introducing an initializer 4*s which is\n+   cheaper than 5*s; similar for 4*c and 5*c.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fdump-tree-optimized\" } */\n+\n+int\n+f (int s, int c)\n+{\n+  int a2, a3, x1, x2, x3, x;\n+\n+  x1 = c + s;\n+  a2 = 5 * s;\n+  x2 = c + a2;\n+  a3 = 5 * c;\n+  x3 = s + a3;\n+  x = x1 + x2 + x3;\n+  return x;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \" \\\\* 4\" 2 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \" \\\\* 5\" 0 \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "19413454944aaf9c708a40b63b1bd5e2961ea076", "filename": "gcc/testsuite/gcc.dg/tree-ssa/slsr-14.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88ca9ea18f36fca948a0ca25a1762c9ec0230eac/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88ca9ea18f36fca948a0ca25a1762c9ec0230eac/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-14.c?ref=88ca9ea18f36fca948a0ca25a1762c9ec0230eac", "patch": "@@ -0,0 +1,32 @@\n+/* Straight-line strength reduction control flow variation.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fdump-tree-optimized\" } */\n+\n+int\n+f (int n, int c, int s)\n+{\n+  int a1, a2, x, x1, x2, x3, x4;\n+\n+  a1 = 2 * s;\n+\n+  if (n > 64)\n+    {\n+      x1 = c + a1;\n+      a2 = 4 * s;\n+      x2 = c + a2;\n+      x = x1 + x2;\n+    }\n+  else\n+    {\n+      x3 = c + a1;\n+      a2 = 4 * s;\n+      x4 = c + a2;\n+      x = x4 / x3;\n+    }\n+\n+  return x;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \" \\\\* \" 1 \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "98d2df870403bc07f92835bb8fe7f86c67a7afff", "filename": "gcc/testsuite/gcc.dg/tree-ssa/slsr-15.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88ca9ea18f36fca948a0ca25a1762c9ec0230eac/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88ca9ea18f36fca948a0ca25a1762c9ec0230eac/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-15.c?ref=88ca9ea18f36fca948a0ca25a1762c9ec0230eac", "patch": "@@ -0,0 +1,27 @@\n+/* Straight-line strength reduction control flow variation.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fdump-tree-optimized\" } */\n+\n+int \n+f (int n, int c, int s)\n+{\n+  int a, x1, x2, x3;\n+\n+  x1 = x2 = x3 = c;\n+\n+  if (n > 64)\n+    {\n+      a = 2 * s;\n+      x1 = c + a;\n+      a = 4 * s;\n+      x2 = c + a;\n+      a = 6 * s;\n+      x3 = c + a;\n+    }\n+\n+  return x1 + x2 + x3;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \" \\\\* \" 1 \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "5fe0175cb9e816ac123c920b1a4771f39c42478d", "filename": "gcc/testsuite/gcc.dg/tree-ssa/slsr-16.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88ca9ea18f36fca948a0ca25a1762c9ec0230eac/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88ca9ea18f36fca948a0ca25a1762c9ec0230eac/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-16.c?ref=88ca9ea18f36fca948a0ca25a1762c9ec0230eac", "patch": "@@ -0,0 +1,28 @@\n+/* Straight-line strength reduction control flow variation.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fdump-tree-optimized\" } */\n+\n+int\n+f (int n, int c, int s)\n+{\n+  int a2, a3, a4, x1, x2, x3, x4;\n+\n+  x1 = c + s;\n+  a2 = 3 * s;\n+  x2 = c + a2;\n+  x3 = x4 = c;\n+\n+  if (n > 64)\n+    {\n+      a3 = 5 * s;\n+      x3 = c + a3;\n+      a4 = 7 * s;\n+      x4 = c + a4;\n+    }\n+\n+  return x1 + x2 + x3 + x4;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \" \\\\* \" 1 \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "3da203c205e5809a9cdbb3465148586c96576c78", "filename": "gcc/testsuite/gcc.dg/tree-ssa/slsr-17.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88ca9ea18f36fca948a0ca25a1762c9ec0230eac/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88ca9ea18f36fca948a0ca25a1762c9ec0230eac/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-17.c?ref=88ca9ea18f36fca948a0ca25a1762c9ec0230eac", "patch": "@@ -0,0 +1,31 @@\n+/* Straight-line strength reduction control flow variation with incr = 1.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fdump-tree-optimized\" } */\n+\n+int\n+f (int n, int c, int s)\n+{\n+  int a2, a3, a4, x1, x2, x3, x4;\n+\n+  x1 = c + s;\n+  x2 = x3 = x4 = c;\n+\n+  if (n > 64)\n+    {\n+      a2 = 2 * s;\n+      x2 = c + a2;\n+      a3 = 3 * s;\n+      x3 = c + a3;\n+    }\n+  else\n+    {\n+      a4 = 2 * s;\n+      x4 = c + a4;\n+    }\n+\n+  return x1 + x2 + x3 + x4;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \" \\\\* \" 0 \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "b8d368ea4b0cfe40043715c7f81121d28e55b4da", "filename": "gcc/testsuite/gcc.dg/tree-ssa/slsr-18.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88ca9ea18f36fca948a0ca25a1762c9ec0230eac/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-18.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88ca9ea18f36fca948a0ca25a1762c9ec0230eac/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-18.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-18.c?ref=88ca9ea18f36fca948a0ca25a1762c9ec0230eac", "patch": "@@ -0,0 +1,32 @@\n+/* Straight-line strength reduction control flow variation with incr = -1.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fdump-tree-optimized\" } */\n+\n+int\n+f (int n, int c, int s)\n+{\n+  int a1, a2, a3, a4, x1, x2, x3, x4;\n+\n+  a1 = 4 * s;\n+  x1 = c + a1;\n+  x2 = x3 = x4 = c;\n+\n+  if (n > 64)\n+    {\n+      a2 = 3 * s;\n+      x2 = c + a2;\n+      a3 = 2 * s;\n+      x3 = c + a3;\n+    }\n+  else\n+    {\n+      a4 = 3 * s;\n+      x4 = c + a4;\n+    }\n+\n+  return x1 + x2 + x3 + x4;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \" \\\\* \" 1 \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "c92730f40d509574e37fd68ab92e0aeae0327331", "filename": "gcc/testsuite/gcc.dg/tree-ssa/slsr-19.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88ca9ea18f36fca948a0ca25a1762c9ec0230eac/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-19.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88ca9ea18f36fca948a0ca25a1762c9ec0230eac/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-19.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-19.c?ref=88ca9ea18f36fca948a0ca25a1762c9ec0230eac", "patch": "@@ -0,0 +1,22 @@\n+/* Verify straight-line strength reduction for multiply candidates\n+   with stride in RHS1 position.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fdump-tree-optimized\" } */\n+\n+int\n+f (int c, int s)\n+{\n+  int x1, x2, y1, y2;\n+\n+  y1 = c + 2;\n+  x1 = s * y1;\n+  y2 = y1 + 2;\n+  x2 = s * y2;\n+  return x1 + x2;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \" \\\\* y\" 1 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \" \\\\* 2\" 1 \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */\n+"}, {"sha": "cf3e1b3a0e78d22691db80dc1121bf910ed89b30", "filename": "gcc/testsuite/gcc.dg/tree-ssa/slsr-20.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88ca9ea18f36fca948a0ca25a1762c9ec0230eac/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-20.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88ca9ea18f36fca948a0ca25a1762c9ec0230eac/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-20.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-20.c?ref=88ca9ea18f36fca948a0ca25a1762c9ec0230eac", "patch": "@@ -0,0 +1,21 @@\n+/* Verify straight-line strength reduction for multiply candidates\n+   with stride in inconsistent positions.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fdump-tree-optimized\" } */\n+\n+int\n+f (int c, int s)\n+{\n+  int x1, x2, y1, y2;\n+\n+  y1 = c + 2;\n+  x1 = y1 * s;\n+  y2 = y1 + 2;\n+  x2 = s * y2;\n+  return x1 + x2;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \" \\\\* s\" 1 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \" \\\\* 2\" 1 \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "c32afb2aac0fc03b6854be96f31e66c839d6b2a8", "filename": "gcc/testsuite/gcc.dg/tree-ssa/slsr-21.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88ca9ea18f36fca948a0ca25a1762c9ec0230eac/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-21.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88ca9ea18f36fca948a0ca25a1762c9ec0230eac/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-21.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-21.c?ref=88ca9ea18f36fca948a0ca25a1762c9ec0230eac", "patch": "@@ -0,0 +1,32 @@\n+/* Verify straight-line strength reduction for multiply candidates\n+   with variable stride and control flow.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fdump-tree-optimized\" } */\n+\n+int\n+f (int n, int x, int stride)\n+{\n+  int a, x1, x2, x3;\n+\n+  a = x * stride;\n+\n+  if (n > 64)\n+    {\n+      x1 = x + 3;\n+      a += x1 * stride;\n+      x2 = x1 + 3;\n+      a += x2 * stride;\n+    }\n+  else\n+    {\n+      x3 = x + 3;\n+      a += x3 * stride;\n+    }\n+\n+  return a;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \" \\\\* stride\" 1 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \" \\\\* 3\" 1 \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "6e56d9bb45164b1ce037b13c919f6f51c1011b32", "filename": "gcc/testsuite/gcc.dg/tree-ssa/slsr-22.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88ca9ea18f36fca948a0ca25a1762c9ec0230eac/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-22.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88ca9ea18f36fca948a0ca25a1762c9ec0230eac/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-22.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-22.c?ref=88ca9ea18f36fca948a0ca25a1762c9ec0230eac", "patch": "@@ -0,0 +1,29 @@\n+/* Verify straight-line strength reduction for multiply candidates\n+   with variable stride and control flow.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fdump-tree-optimized\" } */\n+\n+int\n+f (int n, int x, int stride)\n+{\n+  int a, x1, x2, x3;\n+\n+  a = x * stride;\n+\n+  if (n > 64)\n+    {\n+      x1 = x + 3;\n+      a += x1 * stride;\n+      x2 = x1 + 3;\n+      a += x2 * stride;\n+      x3 = x2 + 3;\n+      a += x3 * stride;\n+    }\n+\n+  return a;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \" \\\\* stride\" 1 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \" \\\\* 3\" 1 \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "88bd087de30dc98b3af4af5b276ebef76f888241", "filename": "gcc/testsuite/gcc.dg/tree-ssa/slsr-23.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88ca9ea18f36fca948a0ca25a1762c9ec0230eac/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-23.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88ca9ea18f36fca948a0ca25a1762c9ec0230eac/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-23.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-23.c?ref=88ca9ea18f36fca948a0ca25a1762c9ec0230eac", "patch": "@@ -0,0 +1,29 @@\n+/* Verify straight-line strength reduction for multiply candidates\n+   with variable stride and control flow.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fdump-tree-optimized\" } */\n+\n+int \n+f (int n, int x, int stride)\n+{\n+  int a, x1, x2, x3;\n+\n+  a = x * stride;\n+  x1 = x + 3;\n+  a += x1 * stride;\n+\n+  if (n > 64)\n+    {\n+      x2 = x1 + 3;\n+      a += x2 * stride;\n+      x3 = x2 + 3;\n+      a += x3 * stride;\n+    }\n+\n+  return a;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \" \\\\* stride\" 1 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \" \\\\* 3\" 1 \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "04e093be540704d7c5d8d3aa29a286deec75bbb6", "filename": "gcc/testsuite/gcc.dg/tree-ssa/slsr-24.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88ca9ea18f36fca948a0ca25a1762c9ec0230eac/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-24.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88ca9ea18f36fca948a0ca25a1762c9ec0230eac/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-24.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-24.c?ref=88ca9ea18f36fca948a0ca25a1762c9ec0230eac", "patch": "@@ -0,0 +1,31 @@\n+/* Verify straight-line strength reduction for multiply candidates\n+   with variable stride and control flow, increment = 1.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fdump-tree-optimized\" } */\n+\n+int\n+f (int n, int x, int stride)\n+{\n+  int a, x1, x2, x3;\n+\n+  a = x * stride;\n+\n+  if (n > 64)\n+    {\n+      x1 = x + 1;\n+      a += x1 * stride;\n+      x2 = x1 + 1;\n+      a += x2 * stride;\n+    }\n+  else\n+    {\n+      x3 = x + 1;\n+      a += x3 * stride;\n+    }\n+\n+  return a;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \" \\\\* \" 1 \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "9e16e0476cdec6f23b190fb0658dd83e5c17fb53", "filename": "gcc/testsuite/gcc.dg/tree-ssa/slsr-25.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88ca9ea18f36fca948a0ca25a1762c9ec0230eac/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-25.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88ca9ea18f36fca948a0ca25a1762c9ec0230eac/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-25.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-25.c?ref=88ca9ea18f36fca948a0ca25a1762c9ec0230eac", "patch": "@@ -0,0 +1,31 @@\n+/* Verify straight-line strength reduction for multiply candidates\n+   with variable stride and control flow, increment = -1.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fdump-tree-optimized\" } */\n+\n+int \n+f (int n, int x, int stride)\n+{\n+  int a, x1, x2, x3;\n+\n+  a = x * stride;\n+\n+  if (n > 64)\n+    {\n+      x1 = x - 1;\n+      a += x1 * stride;\n+      x2 = x1 - 1;\n+      a += x2 * stride;\n+    }\n+  else\n+    {\n+      x3 = x - 1;\n+      a += x3 * stride;\n+    }\n+\n+  return a;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \" \\\\* \" 1 \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "c333e00bb62cb7a94eab9585df1e0ce2324ff904", "filename": "gcc/testsuite/gcc.dg/tree-ssa/slsr-26.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88ca9ea18f36fca948a0ca25a1762c9ec0230eac/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-26.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88ca9ea18f36fca948a0ca25a1762c9ec0230eac/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-26.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-26.c?ref=88ca9ea18f36fca948a0ca25a1762c9ec0230eac", "patch": "@@ -0,0 +1,32 @@\n+/* Verify straight-line strength reduction for multiply candidates\n+   with variable stride and control flow, increment = -3.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fdump-tree-optimized\" } */\n+\n+int\n+f (int n, int x, int stride)\n+{\n+  int a, x1, x2, x3;\n+\n+  a = x * stride;\n+\n+  if (n > 64)\n+    {\n+      x1 = x - 3;\n+      a += x1 * stride;\n+      x2 = x1 - 3;\n+      a += x2 * stride;\n+    }\n+  else\n+    {\n+      x3 = x - 3;\n+      a += x3 * stride;\n+    }\n+\n+  return a;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \" \\\\* stride\" 1 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \" \\\\* 3\" 1 \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "fbd68979f6a7bc867aa11bd5f630b33d40105623", "filename": "gcc/testsuite/gcc.dg/tree-ssa/slsr-30.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88ca9ea18f36fca948a0ca25a1762c9ec0230eac/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-30.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88ca9ea18f36fca948a0ca25a1762c9ec0230eac/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-30.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-30.c?ref=88ca9ea18f36fca948a0ca25a1762c9ec0230eac", "patch": "@@ -0,0 +1,25 @@\n+/* Verify straight-line strength reduction fails for simple integer addition\n+   with casts thrown in when -fwrapv is used.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fdump-tree-dom2 -fwrapv\" } */\n+/* { dg-skip-if \"\" { ilp32 } { \"-m32\" } { \"\" } } */\n+\n+long\n+f (int s, long c)\n+{\n+  int a1, a2, a3;\n+  long x1, x2, x3, x;\n+\n+  a1 = 2 * s;\n+  x1 = c + a1;\n+  a2 = 4 * s;\n+  x2 = c + a2;\n+  a3 = 6 * s;\n+  x3 = c + a3;\n+  x = x1 + x2 + x3;\n+  return x;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \" \\\\* \" 3 \"dom2\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "edf31294a2e8a7d2364b05b703ef4eed1993cf78", "filename": "gcc/testsuite/gcc.dg/tree-ssa/slsr-31.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88ca9ea18f36fca948a0ca25a1762c9ec0230eac/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-31.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88ca9ea18f36fca948a0ca25a1762c9ec0230eac/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-31.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-31.c?ref=88ca9ea18f36fca948a0ca25a1762c9ec0230eac", "patch": "@@ -0,0 +1,27 @@\n+/* Verify straight-line strength reduction for add candidates in\n+   which the stride is unknown and increments appear that differ\n+   only in sign.  Verify the increments are shared.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fdump-tree-optimized\" } */\n+\n+int\n+f (int s, int c)\n+{\n+  int a1, a2, a3, a4, x1, x2, x3, x4, x;\n+\n+  a1 = 2 * s;\n+  x1 = c + a1;\n+  a2 = 4 * s;  /* incr = +2  */\n+  x2 = c + a2;\n+  a3 = 7 * s;\n+  x3 = c + a3;\n+  a4 = 5 * s;  /* incr = -2  */\n+  x4 = c + a4;\n+  x = x1 + x2 + x3 + x4;\n+  return x;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \" \\\\* 2\" 1 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \" \\\\* -2\" 0 \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "8612febc4e1094b87ec52fb6e34b6a89912bcc83", "filename": "gcc/testsuite/gcc.dg/tree-ssa/slsr-5.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88ca9ea18f36fca948a0ca25a1762c9ec0230eac/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88ca9ea18f36fca948a0ca25a1762c9ec0230eac/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-5.c?ref=88ca9ea18f36fca948a0ca25a1762c9ec0230eac", "patch": "@@ -0,0 +1,22 @@\n+/* Verify straight-line strength reduction for simple add candidates.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fdump-tree-optimized\" } */\n+\n+int\n+f (int s, int c)\n+{\n+  int a1, a2, a3, x1, x2, x3, x;\n+\n+  a1 = 2 * s;\n+  x1 = c + a1;\n+  a2 = 4 * s;\n+  x2 = c + a2;\n+  a3 = 6 * s;\n+  x3 = c + a3;\n+  x = x1 + x2 + x3;\n+  return x;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \" \\\\* \" 1 \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "56b167731c4b1916cbab490c2f80a7b13cdd3f99", "filename": "gcc/testsuite/gcc.dg/tree-ssa/slsr-6.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88ca9ea18f36fca948a0ca25a1762c9ec0230eac/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88ca9ea18f36fca948a0ca25a1762c9ec0230eac/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-6.c?ref=88ca9ea18f36fca948a0ca25a1762c9ec0230eac", "patch": "@@ -0,0 +1,25 @@\n+/* Verify straight-line strength reduction for simple add candidates,\n+   pointer version.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fdump-tree-optimized\" } */\n+\n+void\n+f (int s, char *c, char *x1, char *x2, char *x3)\n+{\n+  int a1, a2, a3;\n+\n+  a1 = 2 * s;\n+  x1 = c + a1;\n+  *x1 = 1;\n+  a2 = 4 * s;\n+  x2 = c + a2;\n+  *x2 = 2;\n+  a3 = 6 * s;\n+  x3 = c + a3;\n+  *x3 = 3;\n+}\n+\n+/* There will be four ' * ' instances for the parms, one in the code.  */\n+/* { dg-final { scan-tree-dump-times \" \\\\* \" 5 \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "ace755f07ab8bb8875338e732b2a22ab163cf937", "filename": "gcc/testsuite/gcc.dg/tree-ssa/slsr-7.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88ca9ea18f36fca948a0ca25a1762c9ec0230eac/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88ca9ea18f36fca948a0ca25a1762c9ec0230eac/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-7.c?ref=88ca9ea18f36fca948a0ca25a1762c9ec0230eac", "patch": "@@ -0,0 +1,22 @@\n+/* Verify straight-line strength reduction for simple integer subtraction.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fdump-tree-optimized\" } */\n+\n+int\n+f (int s, int c)\n+{\n+  int a1, a2, a3, x1, x2, x3, x;\n+\n+  a1 = 2 * s;\n+  x1 = c - a1;\n+  a2 = 4 * s;\n+  x2 = c - a2;\n+  a3 = 6 * s;\n+  x3 = c - a3;\n+  x = x1 + x2 + x3;\n+  return x;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \" \\\\* \" 1 \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "b03c52c33603a8a895a85a063fbe3cd456b4c1f4", "filename": "gcc/testsuite/gcc.dg/tree-ssa/slsr-8.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88ca9ea18f36fca948a0ca25a1762c9ec0230eac/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88ca9ea18f36fca948a0ca25a1762c9ec0230eac/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-8.c?ref=88ca9ea18f36fca948a0ca25a1762c9ec0230eac", "patch": "@@ -0,0 +1,23 @@\n+/* Verify straight-line strength reduction for simple pointer subtraction.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fdump-tree-optimized\" } */\n+\n+int*\n+f (int s, int *c)\n+{\n+  int a1, a2, a3, *x1, *x2, *x3;\n+\n+  a1 = 2 * s;\n+  x1 = c - a1;\n+  a2 = 4 * s;\n+  x2 = c - a2;\n+  a3 = 6 * s;\n+  x3 = c - a3;\n+  return x1 ? x2 : x3;\n+}\n+\n+/* There are 2 ' * ' instances in the decls (since \"int * x3;\" is\n+   optimized out), 1 parm, 2 in the code.  */\n+/* { dg-final { scan-tree-dump-times \" \\\\* \" 5 \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "3a388731ee13f70a58919dd6b40814b6b139d25c", "filename": "gcc/testsuite/gcc.dg/tree-ssa/slsr-9.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88ca9ea18f36fca948a0ca25a1762c9ec0230eac/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88ca9ea18f36fca948a0ca25a1762c9ec0230eac/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-9.c?ref=88ca9ea18f36fca948a0ca25a1762c9ec0230eac", "patch": "@@ -0,0 +1,23 @@\n+/* Verify straight-line strength reduction for simple integer addition\n+   with stride reversed.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fdump-tree-optimized\" } */\n+\n+int\n+f (int s, int c)\n+{\n+  int a1, a2, a3, x1, x2, x3, x;\n+\n+  a1 = 2 * s;\n+  x1 = a1 + c;\n+  a2 = 4 * s;\n+  x2 = a2 + c;\n+  a3 = 6 * s;\n+  x3 = a3 + c;\n+  x = x1 + x2 + x3;\n+  return x;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \" \\\\* \" 1 \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}]}