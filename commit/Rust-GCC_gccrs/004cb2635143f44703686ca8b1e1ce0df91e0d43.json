{"sha": "004cb2635143f44703686ca8b1e1ce0df91e0d43", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDA0Y2IyNjM1MTQzZjQ0NzAzNjg2Y2E4YjFlMWNlMGRmOTFlMGQ0Mw==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.demon.co.uk", "date": "2002-05-17T20:16:48Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2002-05-17T20:16:48Z"}, "message": "Makefile.in: Update for cpptrad.c.\n\n\t* Makefile.in: Update for cpptrad.c.\n\t* cpphash.h (struct cpp_buffer): New members for buffer\n\toverlays.\n\t(struct cpp_reader): New members for traditional output.\n\t(_cpp_read_logical_line, _cpp_overlay_buffer): New.\n\t* cppinit.c (cpp_create_reader): Set trad_line.\n\t(cpp_destroy): Free trad_out_base if used.\n\t(cpp_read_main_file): Overlay an empty buffer if traditional.\n\t(cpp_finish_options): Don't do builtins.\n\t(COMMAND_LINE_OPTIONS): Add -traditional-cpp.\n\t(cpp_handle_option): Handle it.\n\t* cpplex.c (continue_after_nul): New.\n\t(_cpp_lex_direct): Use handle_nul.\n\t* cpplib.h (struct cpp_options): New traditional option.\n\t* cpptrad.c: New file.\n\nFrom-SVN: r53568", "tree": {"sha": "06c8cca4d252c4189a9e560a900afba199add8fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/06c8cca4d252c4189a9e560a900afba199add8fc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/004cb2635143f44703686ca8b1e1ce0df91e0d43", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/004cb2635143f44703686ca8b1e1ce0df91e0d43", "html_url": "https://github.com/Rust-GCC/gccrs/commit/004cb2635143f44703686ca8b1e1ce0df91e0d43", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/004cb2635143f44703686ca8b1e1ce0df91e0d43/comments", "author": null, "committer": null, "parents": [{"sha": "bdcae02bc40594b8e41e7aff7a4b309d41be59c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bdcae02bc40594b8e41e7aff7a4b309d41be59c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bdcae02bc40594b8e41e7aff7a4b309d41be59c0"}], "stats": {"total": 441, "additions": 413, "deletions": 28}, "files": [{"sha": "afadd9db08c95e3013f248868b3c3c01935d1156", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/004cb2635143f44703686ca8b1e1ce0df91e0d43/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/004cb2635143f44703686ca8b1e1ce0df91e0d43/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=004cb2635143f44703686ca8b1e1ce0df91e0d43", "patch": "@@ -1,3 +1,21 @@\n+2002-05-17  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+\t* Makefile.in: Update for cpptrad.c.\n+\t* cpphash.h (struct cpp_buffer): New members for buffer\n+\toverlays.\n+\t(struct cpp_reader): New members for traditional output.\n+\t(_cpp_read_logical_line, _cpp_overlay_buffer): New.\n+\t* cppinit.c (cpp_create_reader): Set trad_line.\n+\t(cpp_destroy): Free trad_out_base if used.\n+\t(cpp_read_main_file): Overlay an empty buffer if traditional.\n+\t(cpp_finish_options): Don't do builtins.\n+\t(COMMAND_LINE_OPTIONS): Add -traditional-cpp.\n+\t(cpp_handle_option): Handle it.\n+\t* cpplex.c (continue_after_nul): New.\n+\t(_cpp_lex_direct): Use handle_nul.\n+\t* cpplib.h (struct cpp_options): New traditional option.\n+\t* cpptrad.c: New file.\n+\n 2002-05-17  Neil Booth  <neil@daikokuya.demon.co.uk>\n \n \t* c-common.c (c_common_init_options): Use C89 for Objective-C,"}, {"sha": "7c3f961dbf53096b72c7ae9d994c3598579be7f6", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/004cb2635143f44703686ca8b1e1ce0df91e0d43/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/004cb2635143f44703686ca8b1e1ce0df91e0d43/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=004cb2635143f44703686ca8b1e1ce0df91e0d43", "patch": "@@ -1993,7 +1993,7 @@ PREPROCESSOR_DEFINES = \\\n   -DCROSS_INCLUDE_DIR=\\\"$(gcc_tooldir)/sys-include\\\" \\\n   -DTOOL_INCLUDE_DIR=\\\"$(gcc_tooldir)/include\\\"\n \n-LIBCPP_OBJS =\tcpplib.o cpplex.o cppmacro.o cppexp.o cppfiles.o \\\n+LIBCPP_OBJS =\tcpplib.o cpplex.o cppmacro.o cppexp.o cppfiles.o cpptrad.o \\\n \t\tcpphash.o cpperror.o cppinit.o cppdefault.o cppmain.o \\\n \t\thashtable.o line-map.o mkdeps.o prefix.o version.o mbchar.o\n \n@@ -2015,6 +2015,7 @@ cpplex.o:   cpplex.c   $(CONFIG_H) $(LIBCPP_DEPS) mbchar.h\n cppmacro.o: cppmacro.c $(CONFIG_H) $(LIBCPP_DEPS)\n cpplib.o:   cpplib.c   $(CONFIG_H) $(LIBCPP_DEPS)\n cpphash.o:  cpphash.c  $(CONFIG_H) $(LIBCPP_DEPS)\n+cpptrad.o:  cpptrad.c  $(CONFIG_H) $(LIBCPP_DEPS)\n cppfiles.o: cppfiles.c $(CONFIG_H) $(LIBCPP_DEPS) $(SPLAY_TREE_H) mkdeps.h\n cppinit.o:  cppinit.c  $(CONFIG_H) $(LIBCPP_DEPS) cppdefault.h \\\n \t\tmkdeps.h prefix.h version.h"}, {"sha": "dcbb4fc1ae622a66428983b43939e8b31c465755", "filename": "gcc/cpphash.h", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/004cb2635143f44703686ca8b1e1ce0df91e0d43/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/004cb2635143f44703686ca8b1e1ce0df91e0d43/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=004cb2635143f44703686ca8b1e1ce0df91e0d43", "patch": "@@ -245,6 +245,9 @@ struct cpp_buffer\n   /* The directory of the this buffer's file.  Its NAME member is not\n      allocated, so we don't need to worry about freeing it.  */\n   struct search_path dir;\n+\n+  /* Used for buffer overlays by cpptrad.c.  */\n+  const uchar *saved_cur, *saved_rlimit, *saved_line_base;\n };\n \n /* A cpp_reader encapsulates the \"state\" of a pre-processor run.\n@@ -355,6 +358,11 @@ struct cpp_reader\n \n   /* Whether cpplib owns the hashtable.  */\n   unsigned char our_hashtable;\n+\n+  /* Traditional preprocessing output buffer.  */\n+  uchar *trad_out_base, *trad_out_limit;\n+  uchar *trad_out_cur;\n+  unsigned int trad_line;\n };\n \n /* Character classes.  Based on the more primitive macros in safe-ctype.h.\n@@ -447,6 +455,11 @@ extern void _cpp_do_file_change PARAMS ((cpp_reader *, enum lc_reason,\n \t\t\t\t\t unsigned int, unsigned int));\n extern void _cpp_pop_buffer PARAMS ((cpp_reader *));\n \n+/* In cpptrad.c.  */\n+extern bool _cpp_read_logical_line_trad PARAMS ((cpp_reader *));\n+extern void _cpp_overlay_buffer PARAMS ((cpp_reader *pfile, const uchar *,\n+\t\t\t\t\t size_t));\n+\n /* Utility routines and macros.  */\n #define DSC(str) (const uchar *)str, sizeof str - 1\n #define xnew(T)\t\t(T *) xmalloc (sizeof(T))"}, {"sha": "c7d51b765e9ee4bd675afe6b7d1079fc6b112616", "filename": "gcc/cppinit.c", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/004cb2635143f44703686ca8b1e1ce0df91e0d43/gcc%2Fcppinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/004cb2635143f44703686ca8b1e1ce0df91e0d43/gcc%2Fcppinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppinit.c?ref=004cb2635143f44703686ca8b1e1ce0df91e0d43", "patch": "@@ -510,7 +510,7 @@ cpp_create_reader (lang)\n   /* Initialise the line map.  Start at logical line 1, so we can use\n      a line number of zero for special states.  */\n   init_line_maps (&pfile->line_maps);\n-  pfile->line = 1;\n+  pfile->trad_line = pfile->line = 1;\n \n   /* Initialize lexer state.  */\n   pfile->state.save_comments = ! CPP_OPTION (pfile, discard_comments);\n@@ -565,6 +565,9 @@ cpp_destroy (pfile)\n   while (CPP_BUFFER (pfile) != NULL)\n     _cpp_pop_buffer (pfile);\n \n+  if (pfile->trad_out_base)\n+    free (pfile->trad_out_base);\n+\n   if (pfile->macro_buffer)\n     {\n       free ((PTR) pfile->macro_buffer);\n@@ -950,6 +953,9 @@ cpp_read_main_file (pfile, fname, table)\n      of the front ends.  */\n   if (CPP_OPTION (pfile, preprocessed))\n     read_original_filename (pfile);\n+  /* Overlay an empty buffer to seed traditional preprocessing.  */\n+  else if (CPP_OPTION (pfile, traditional))\n+    _cpp_overlay_buffer (pfile, U\"\", 0);\n \n   return pfile->map->to_file;\n }\n@@ -998,10 +1004,12 @@ cpp_finish_options (pfile)\n       struct pending_option *p;\n \n       _cpp_do_file_change (pfile, LC_RENAME, _(\"<built-in>\"), 1, 0);\n-      init_builtins (pfile);\n+      if (!CPP_OPTION (pfile, traditional) /* REMOVEME */)\n+\tinit_builtins (pfile);\n       _cpp_do_file_change (pfile, LC_RENAME, _(\"<command line>\"), 1, 0);\n-      for (p = CPP_OPTION (pfile, pending)->directive_head; p; p = p->next)\n-\t(*p->handler) (pfile, p->arg);\n+      if (!CPP_OPTION (pfile, traditional) /* REMOVEME */)\n+\tfor (p = CPP_OPTION (pfile, pending)->directive_head; p; p = p->next)\n+\t  (*p->handler) (pfile, p->arg);\n \n       /* Scan -imacros files after -D, -U, but before -include.\n \t pfile->next_include_file is NULL, so _cpp_pop_buffer does not\n@@ -1195,6 +1203,7 @@ new_pending_directive (pend, text, handler)\n   DEF_OPT(\"std=iso9899:199409\",       0,      OPT_std_iso9899_199409)         \\\n   DEF_OPT(\"std=iso9899:1999\",         0,      OPT_std_iso9899_1999)           \\\n   DEF_OPT(\"std=iso9899:199x\",         0,      OPT_std_iso9899_199x)           \\\n+  DEF_OPT(\"traditional-cpp\",\t      0,      OPT_traditional_cpp)            \\\n   DEF_OPT(\"trigraphs\",                0,      OPT_trigraphs)                  \\\n   DEF_OPT(\"v\",                        0,      OPT_v)                          \\\n   DEF_OPT(\"version\",                  0,      OPT_version)                    \\\n@@ -1444,6 +1453,9 @@ cpp_handle_option (pfile, argc, argv, ignore)\n \tcase OPT_remap:\n \t  CPP_OPTION (pfile, remap) = 1;\n \t  break;\n+\tcase OPT_traditional_cpp:\n+\t  CPP_OPTION (pfile, traditional) = 1;\n+\t  break;\n \tcase OPT_iprefix:\n \t  CPP_OPTION (pfile, include_prefix) = arg;\n \t  CPP_OPTION (pfile, include_prefix_len) = strlen (arg);"}, {"sha": "44ca1d869499ec51e0263de1e624f226bbe9d361", "filename": "gcc/cpplex.c", "status": "modified", "additions": 46, "deletions": 23, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/004cb2635143f44703686ca8b1e1ce0df91e0d43/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/004cb2635143f44703686ca8b1e1ce0df91e0d43/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=004cb2635143f44703686ca8b1e1ce0df91e0d43", "patch": "@@ -78,6 +78,7 @@ static void parse_string PARAMS ((cpp_reader *, cpp_token *, cppchar_t));\n static bool trigraph_p PARAMS ((cpp_reader *));\n static void save_comment PARAMS ((cpp_reader *, cpp_token *, const uchar *,\n \t\t\t\t  cppchar_t));\n+static bool continue_after_nul PARAMS ((cpp_reader *));\n static int name_p PARAMS ((cpp_reader *, const cpp_string *));\n static int maybe_read_ucs PARAMS ((cpp_reader *, const unsigned char **,\n \t\t\t\t   const unsigned char *, cppchar_t *));\n@@ -877,6 +878,48 @@ _cpp_lex_token (pfile)\n   return result;\n }\n \n+/* A NUL terminates the current buffer.  For ISO preprocessing this is\n+   EOF, but for traditional preprocessing it indicates we need a line\n+   refill.  Returns TRUE to continue preprocessing a new buffer, FALSE\n+   to return a CPP_EOF to the caller.  */\n+static bool\n+continue_after_nul (pfile)\n+     cpp_reader *pfile;\n+{\n+  cpp_buffer *buffer = pfile->buffer;\n+  bool more = false;\n+  \n+  buffer->saved_flags = BOL;\n+  if (CPP_OPTION (pfile, traditional))\n+    more = _cpp_read_logical_line_trad (pfile);\n+  else\n+    {\n+      /* Stop parsing arguments with a CPP_EOF.  When we finally come\n+\t back here, do the work of popping the buffer.  */\n+      if (!pfile->state.parsing_args)\n+\t{\n+\t  if (buffer->cur != buffer->line_base)\n+\t    {\n+\t      /* Non-empty files should end in a newline.  Don't warn\n+\t\t for command line and _Pragma buffers.  */\n+\t      if (!buffer->from_stage3)\n+\t\tcpp_error (pfile, DL_PEDWARN, \"no newline at end of file\");\n+\t      handle_newline (pfile);\n+\t    }\n+\n+\t  /* Similarly, finish an in-progress directive with CPP_EOF\n+\t     before popping the buffer.  */\n+\t  if (!pfile->state.in_directive && buffer->prev)\n+\t    {\n+\t      more = !buffer->return_at_eof;\n+\t      _cpp_pop_buffer (pfile);\n+\t    }\n+\t}\n+    }\n+\n+  return more;\n+}\n+\n #define IF_NEXT_IS(CHAR, THEN_TYPE, ELSE_TYPE)\t\\\n   do {\t\t\t\t\t\t\\\n     if (get_effective_char (pfile) == CHAR)\t\\\n@@ -927,30 +970,10 @@ _cpp_lex_direct (pfile)\n       if (skip_whitespace (pfile, c))\n \tgoto skipped_white;\n \n-      /* EOF.  */\n+      /* End of buffer.  */\n       buffer->cur--;\n-      buffer->saved_flags = BOL;\n-      if (!pfile->state.parsing_args)\n-\t{\n-\t  if (buffer->cur != buffer->line_base)\n-\t    {\n-\t      /* Non-empty files should end in a newline.  Don't warn\n-\t\t for command line and _Pragma buffers.  */\n-\t      if (!buffer->from_stage3)\n-\t\tcpp_error (pfile, DL_PEDWARN, \"no newline at end of file\");\n-\t      handle_newline (pfile);\n-\t    }\n-\n-\t  /* Don't pop the last buffer.  */\n-\t  if (!pfile->state.in_directive && buffer->prev)\n-\t    {\n-\t      unsigned char stop = buffer->return_at_eof;\n-\n-\t      _cpp_pop_buffer (pfile);\n-\t      if (!stop)\n-\t\tgoto fresh_line;\n-\t    }\n-\t}\n+      if (continue_after_nul (pfile))\n+\tgoto fresh_line;\n       result->type = CPP_EOF;\n       break;\n "}, {"sha": "982d0f14eae2affc2027554d15fe3b51a7d7c422", "filename": "gcc/cpplib.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/004cb2635143f44703686ca8b1e1ce0df91e0d43/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/004cb2635143f44703686ca8b1e1ce0df91e0d43/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=004cb2635143f44703686ca8b1e1ce0df91e0d43", "patch": "@@ -387,6 +387,9 @@ struct cpp_options\n      parsing; drivers might want to continue printing help.  */\n   unsigned char help_only;\n \n+  /* True for traditional preprocessing.  */\n+  unsigned char traditional;\n+\n   /* Target-specific features set by the front end or client.  */\n \n   /* Precision for target CPP arithmetic, target characters, target"}, {"sha": "a6178e326d60d8a65f35d8b0d414c67fa5246273", "filename": "gcc/cpptrad.c", "status": "added", "additions": 315, "deletions": 0, "changes": 315, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/004cb2635143f44703686ca8b1e1ce0df91e0d43/gcc%2Fcpptrad.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/004cb2635143f44703686ca8b1e1ce0df91e0d43/gcc%2Fcpptrad.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpptrad.c?ref=004cb2635143f44703686ca8b1e1ce0df91e0d43", "patch": "@@ -0,0 +1,315 @@\n+/* CPP Library - traditional lexical analysis and macro expansion.\n+   Copyright (C) 2002 Free Software Foundation, Inc.\n+   Contributed by Neil Booth, May 2002\n+\n+This program is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 2, or (at your option) any\n+later version.\n+\n+This program is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with this program; if not, write to the Free Software\n+Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"cpplib.h\"\n+#include \"cpphash.h\"\n+\n+/* Lexing TODO: Handle -Wcomment, -C, maybe -CC, and space in escaped\n+   newlines.  Stop cpplex.c from recognizing comments, trigraphs and\n+   directives during its lexing pass.  */\n+\n+static const uchar *handle_newline PARAMS ((cpp_reader *, const uchar *));\n+static const uchar *skip_escaped_newlines PARAMS ((cpp_reader *,\n+\t\t\t\t\t\t   const uchar *));\n+static cpp_hashnode *lex_identifier PARAMS ((cpp_reader *, const uchar *));\n+static const uchar *skip_comment PARAMS ((cpp_reader *, const uchar *));\n+static void scan_out_logical_line PARAMS ((cpp_reader *pfile));\n+static void check_output_buffer PARAMS ((cpp_reader *, size_t));\n+static void restore_buff PARAMS ((cpp_reader *));\n+\n+/* Ensures we have N bytes' space in the output buffer, and\n+   reallocates it if not.  */\n+static void\n+check_output_buffer (pfile, n)\n+     cpp_reader *pfile;\n+     size_t n;\n+{\n+  if (n > (size_t) (pfile->trad_out_limit - pfile->trad_out_cur))\n+    {\n+      size_t size = pfile->trad_out_cur - pfile->trad_out_base;\n+      size_t new_size = (size + n) * 3 / 2;\n+\n+      pfile->trad_out_base\n+\t= (uchar *) xrealloc (pfile->trad_out_base, new_size);\n+      pfile->trad_out_limit = pfile->trad_out_base + new_size;\n+      pfile->trad_out_cur = pfile->trad_out_base + size;\n+    }\n+}\n+\n+/* To be called whenever a newline character is encountered in the\n+   input file, at CUR.  Handles DOS, MAC and Unix ends of line, and\n+   returns the character after the newline sequence.  */\n+static const uchar *\n+handle_newline (pfile, cur)\n+     cpp_reader *pfile;\n+     const uchar *cur;\n+{\n+  pfile->line++;\n+  if (cur[0] + cur[1] == '\\r' + '\\n')\n+    cur++;\n+  return cur + 1;\n+}\n+\n+/* CUR points to any character in the buffer, not necessarily a\n+   backslash.  Advances CUR until all escaped newlines are skipped,\n+   and returns the new position.  */\n+static const uchar *\n+skip_escaped_newlines (pfile, cur)\n+     cpp_reader *pfile;\n+     const uchar *cur;\n+{\n+  while (*cur == '\\\\' && is_vspace (cur[1]))\n+    cur = handle_newline (pfile, cur + 1);\n+\n+  return cur;\n+}\n+\n+/* CUR points to the character after the asterisk introducing a\n+   comment.  Returns the position after the comment.  */\n+static const uchar *\n+skip_comment (pfile, cur)\n+     cpp_reader *pfile;\n+     const uchar *cur;\n+{\n+  unsigned int from_line = pfile->line;\n+\n+  for (;;)\n+    {\n+      unsigned int c = *cur++;\n+      if (c == '*')\n+\t{\n+\t  cur = skip_escaped_newlines (pfile, cur);\n+\t  if (*cur == '/')\n+\t    {\n+\t      cur++;\n+\t      break;\n+\t    }\n+\t}\n+      else if (is_vspace (c))\n+\tcur = handle_newline (pfile, cur - 1);\n+      else if (c == '\\0' && cur - 1 == pfile->buffer->rlimit)\n+\t{\n+\t  cur--;\n+\t  cpp_error_with_line (pfile, DL_ERROR, from_line, 0,\n+\t\t\t       \"unterminated comment\");\n+\t  break;\n+\t}\n+    }\n+\n+  return cur;\n+}\n+\n+/* Lexes and outputs an identifier starting at CUR, which is assumed\n+   to point to a valid first character of an identifier.  Returns\n+   the hashnode, and updates trad_out_cur.  */\n+static cpp_hashnode *\n+lex_identifier (pfile, cur)\n+     cpp_reader *pfile;\n+     const uchar *cur;\n+{\n+  size_t len;\n+  uchar *out = pfile->trad_out_cur;\n+\n+  do\n+    {\n+      do\n+\t*out++ = *cur++;\n+      while (ISIDNUM (*cur));\n+      cur = skip_escaped_newlines (pfile, cur);\n+    }\n+  while (ISIDNUM (*cur));\n+\n+  pfile->buffer->cur = cur;\n+  len = out - pfile->trad_out_cur;\n+  pfile->trad_out_cur = out;\n+  return (cpp_hashnode *) ht_lookup (pfile->hash_table, pfile->trad_out_cur,\n+\t\t\t\t     len, HT_ALLOC);\n+}\n+\n+/* Overlays the true file buffer temporarily with text of length LEN\n+   starting at START.  The true buffer is restored upon calling\n+   restore_buff().  */\n+void\n+_cpp_overlay_buffer (pfile, start, len)\n+     cpp_reader *pfile;\n+     const uchar *start;\n+     size_t len;\n+{\n+  cpp_buffer *buffer = pfile->buffer;\n+\n+  buffer->saved_cur = buffer->cur;\n+  buffer->saved_rlimit = buffer->rlimit;\n+  buffer->saved_line_base = buffer->line_base;\n+\n+  buffer->cur = start;\n+  buffer->line_base = start;\n+  buffer->rlimit = start + len;\n+}\n+\n+/* Restores a buffer overlaid by _cpp_overlay_buffer().  */\n+static void\n+restore_buff (pfile)\n+     cpp_reader *pfile;\n+{\n+  cpp_buffer *buffer = pfile->buffer;\n+\n+  buffer->cur = buffer->saved_cur;\n+  buffer->rlimit = buffer->saved_rlimit;\n+  buffer->line_base = buffer->saved_line_base;\n+}\n+\n+/* Reads a logical line into the output buffer.  Returns TRUE if there\n+   is more text left in the buffer.  */\n+bool\n+_cpp_read_logical_line_trad (pfile)\n+     cpp_reader *pfile;\n+{\n+  cpp_buffer *buffer;\n+  unsigned int first_line;\n+\n+  restore_buff (pfile);\n+\n+  first_line = pfile->line = pfile->trad_line;\n+\n+  buffer = pfile->buffer;\n+  if (buffer->cur == buffer->rlimit)\n+    {\n+      bool stop = true;\n+\n+      /* Don't pop the last buffer.  */\n+      if (buffer->prev)\n+\t{\n+\t  stop = buffer->return_at_eof;\n+\t  _cpp_pop_buffer (pfile);\n+\t}\n+\n+      if (stop)\n+\treturn false;\n+    }\n+\n+  pfile->trad_out_cur = pfile->trad_out_base;\n+  scan_out_logical_line (pfile);\n+  pfile->trad_line = pfile->line;\n+  pfile->line = first_line;\n+  _cpp_overlay_buffer (pfile, pfile->trad_out_base,\n+\t\t       pfile->trad_out_cur - pfile->trad_out_base);\n+  return true;\n+}\n+\n+/* Copies the next logical line in the current buffer to the output\n+   buffer.  The output is guaranteed to terminate with a NUL\n+   character.  */\n+static void\n+scan_out_logical_line (pfile)\n+     cpp_reader *pfile;\n+{\n+  cpp_buffer *buffer = pfile->buffer;\n+  const uchar *cur = buffer->cur;\n+  unsigned int c, quote = 0;\n+  uchar *out;\n+\n+  check_output_buffer (pfile, buffer->rlimit - cur);\n+  out = pfile->trad_out_cur;\n+\n+  for (;;)\n+    {\n+      c = *cur++;\n+      *out++ = c;\n+\n+      /* There are only a few entities we need to catch: comments,\n+\t identifiers, newlines, escaped newlines, # and '\\0'.  */\n+      switch (c)\n+\t{\n+\tcase '\\0':\n+\t  if (cur - 1 != buffer->rlimit)\n+\t    break;\n+\t  cur--;\n+\t  if (!buffer->from_stage3)\n+\t    cpp_error (pfile, DL_PEDWARN, \"no newline at end of file\");\n+\t  pfile->line++;\n+\t  if (0)\n+\t    {\n+\t    case '\\r': case '\\n':\n+\t      cur = handle_newline (pfile, cur - 1);\n+\t    }\n+\t  out[-1] = '\\n';\n+\t  out[0] = '\\0';\n+\t  buffer->cur = cur;\n+\t  pfile->trad_out_cur = out;\n+\t  return;\n+\n+\tcase '\"':\n+\tcase '\\'':\n+\t  if (c == quote)\n+\t    quote = 0;\n+\t  else if (!quote)\n+\t    quote = c;\n+\t  break;\n+\n+\tcase '\\\\':\n+\t  if (is_vspace (*cur))\n+\t    out--, cur = skip_escaped_newlines (pfile, cur - 1);\n+\t  else\n+\t    {\n+\t      /* Skip escaped quotes here, it's easier than above, but\n+\t\t take care to first skip escaped newlines.  */\n+\t      cur = skip_escaped_newlines (pfile, cur);\n+\t      if (*cur == '\\\\' || *cur == '\"' || *cur == '\\'')\n+\t\t*out++ = *cur++;\n+\t    }\n+\t  break;\n+\n+\tcase '/':\n+\t  /* Traditional CPP does not recognize comments within\n+\t     literals.  */\n+\t  if (!quote)\n+\t    {\n+\t      cur = skip_escaped_newlines (pfile, cur);\n+\t      if (*cur == '*')\n+\t\tout--, cur = skip_comment (pfile, cur + 1);\n+\t    }\n+\t  break;\n+\n+\tcase '_':\n+\tcase 'a': case 'b': case 'c': case 'd': case 'e': case 'f':\n+\tcase 'g': case 'h': case 'i': case 'j': case 'k': case 'l':\n+\tcase 'm': case 'n': case 'o': case 'p': case 'q': case 'r':\n+\tcase 's': case 't': case 'u': case 'v': case 'w': case 'x':\n+\tcase 'y': case 'z':\n+\tcase 'A': case 'B': case 'C': case 'D': case 'E': case 'F':\n+\tcase 'G': case 'H': case 'I': case 'J': case 'K': case 'L':\n+\tcase 'M': case 'N': case 'O': case 'P': case 'Q': case 'R':\n+\tcase 'S': case 'T': case 'U': case 'V': case 'W': case 'X':\n+\tcase 'Y': case 'Z':\n+\t  {\n+\t    cpp_hashnode *node;\n+\n+\t    pfile->trad_out_cur = --out;\n+\t    node = lex_identifier (pfile, cur - 1);\n+\t    out = pfile->trad_out_cur;\n+\t    cur = buffer->cur;\n+\t  }\n+\t  break;\n+\n+\tdefault:\n+\t  break;\n+\t}\n+    }\n+}"}]}