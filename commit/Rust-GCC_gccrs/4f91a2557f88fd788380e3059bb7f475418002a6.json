{"sha": "4f91a2557f88fd788380e3059bb7f475418002a6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGY5MWEyNTU3Zjg4ZmQ3ODgzODBlMzA1OWJiN2Y0NzU0MTgwMDJhNg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-06-21T13:11:41Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-06-21T13:11:41Z"}, "message": "[multiple changes]\n\n2009-06-21  Ed Falis  <falis@adacore.com>\n\n\t* env.c (__gnat_environ): return NULL for vThreads - unimplemented\n\n2009-06-21  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* einfo.ads: Update comments.\n\n2009-06-21  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sem_disp.adb (Check_Direct_Call): New routine. Dispatching calls\n\twhere the controlling formal is of private class-wide type whose\n\tcompletion is a synchronized type can be converted into direct calls.\n\n2009-06-21  Vincent Celier  <celier@adacore.com>\n\n\t* gnatcmd.adb (Check_Files): When all sources of the project are to be\n\tindicated to gnatcheck, gnatpp or gnatmetric, always specify the list\n\tof sources using -files=, so that the distinction can be made by the\n\ttool of a call with no source (to display the usage) from a call with\n\ta project file that contains no source.\n\n2009-06-21  Jerome Lambourg  <lambourg@adacore.com>\n\n\t* exp_ch3.adb (Build_Array_Init_Proc): Do not build the init proc in\n\tcase of VM convention arrays.\n\nFrom-SVN: r148763", "tree": {"sha": "87c0a4e21c018577dc730113e375474d9d50f886", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/87c0a4e21c018577dc730113e375474d9d50f886"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4f91a2557f88fd788380e3059bb7f475418002a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f91a2557f88fd788380e3059bb7f475418002a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4f91a2557f88fd788380e3059bb7f475418002a6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f91a2557f88fd788380e3059bb7f475418002a6/comments", "author": null, "committer": null, "parents": [{"sha": "c64c5552f1cd91d9f8c70ae876ab6071433972b5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c64c5552f1cd91d9f8c70ae876ab6071433972b5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c64c5552f1cd91d9f8c70ae876ab6071433972b5"}], "stats": {"total": 223, "additions": 154, "deletions": 69}, "files": [{"sha": "46a610ac01c97aa3f3ec0c9721a30bd620857f7c", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f91a2557f88fd788380e3059bb7f475418002a6/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f91a2557f88fd788380e3059bb7f475418002a6/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=4f91a2557f88fd788380e3059bb7f475418002a6", "patch": "@@ -1,3 +1,30 @@\n+2009-06-21  Ed Falis  <falis@adacore.com>\n+\n+\t* env.c (__gnat_environ): return NULL for vThreads - unimplemented\n+\n+2009-06-21  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* einfo.ads: Update comments.\n+\n+2009-06-21  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_disp.adb (Check_Direct_Call): New routine. Dispatching calls\n+\twhere the controlling formal is of private class-wide type whose\n+\tcompletion is a synchronized type can be converted into direct calls.\n+\n+2009-06-21  Vincent Celier  <celier@adacore.com>\n+\n+\t* gnatcmd.adb (Check_Files): When all sources of the project are to be\n+\tindicated to gnatcheck, gnatpp or gnatmetric, always specify the list\n+\tof sources using -files=, so that the distinction can be made by the\n+\ttool of a call with no source (to display the usage) from a call with\n+\ta project file that contains no source.\n+\n+2009-06-21  Jerome Lambourg  <lambourg@adacore.com>\n+\n+\t* exp_ch3.adb (Build_Array_Init_Proc): Do not build the init proc in\n+\tcase of VM convention arrays.\n+\n 2009-06-20  Robert Dewar  <dewar@adacore.com>\n \n \t* a-nudira.adb: Minor reformatting"}, {"sha": "29eea5ecce5d592ab6ca402a8ff9e5c49d3310b6", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f91a2557f88fd788380e3059bb7f475418002a6/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f91a2557f88fd788380e3059bb7f475418002a6/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=4f91a2557f88fd788380e3059bb7f475418002a6", "patch": "@@ -239,9 +239,12 @@ package Einfo is\n --  The RM_Size field keeps track of the RM Size as needed in these\n --  three situations.\n \n---  For types other than discrete and fixed-point types, the Object_Size\n---  and Value_Size are the same (and equivalent to the RM attribute Size).\n---  Only Size may be specified for such types.\n+--  For elementary types other than discrete and fixed-point types, the\n+--  Object_Size and Value_Size are the same (and equivalent to the RM\n+--  attribute Size).  Only Size may be specified for such types.\n+\n+--  For composite types, Object_Size and Value_Size are computed from their\n+--  respective value for the type of each element as well as the layout.\n \n --  All size attributes are stored as Uint values. Negative values are used to\n --  reference GCC expressions for the case of non-static sizes, as explained"}, {"sha": "bcb8bdb9a80d6c3ac1eac255714f828eac5a3e76", "filename": "gcc/ada/env.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f91a2557f88fd788380e3059bb7f475418002a6/gcc%2Fada%2Fenv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f91a2557f88fd788380e3059bb7f475418002a6/gcc%2Fada%2Fenv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fenv.c?ref=4f91a2557f88fd788380e3059bb7f475418002a6", "patch": "@@ -190,7 +190,7 @@ __gnat_setenv (char *name, char *value)\n char **\n __gnat_environ (void)\n {\n-#if defined (VMS) || defined (RTX)\n+#if defined (VMS) || defined (RTX) || defined (VTHREADS)\n   /* Not implemented */\n   return NULL;\n #elif defined (__APPLE__)"}, {"sha": "c0cf131c565c7a3a13fe10055bb93181081d1940", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f91a2557f88fd788380e3059bb7f475418002a6/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f91a2557f88fd788380e3059bb7f475418002a6/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=4f91a2557f88fd788380e3059bb7f475418002a6", "patch": "@@ -641,10 +641,13 @@ package body Exp_Ch3 is\n \n       --    1. Initialization is suppressed for the type\n       --    2. The type is a value type, in the CIL sense.\n-      --    3. An initialization already exists for the base type\n+      --    3. The type has CIL/JVM convention.\n+      --    4. An initialization already exists for the base type\n \n       if Suppress_Init_Proc (A_Type)\n         or else Is_Value_Type (Comp_Type)\n+        or else Convention (A_Type) = Convention_CIL\n+        or else Convention (A_Type) = Convention_Java\n         or else Present (Base_Init_Proc (A_Type))\n       then\n          return;"}, {"sha": "9e335d1b5df422ec362a83ed5108ee7096f29e98", "filename": "gcc/ada/gnatcmd.adb", "status": "modified", "additions": 48, "deletions": 64, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f91a2557f88fd788380e3059bb7f475418002a6/gcc%2Fada%2Fgnatcmd.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f91a2557f88fd788380e3059bb7f475418002a6/gcc%2Fada%2Fgnatcmd.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatcmd.adb?ref=4f91a2557f88fd788380e3059bb7f475418002a6", "patch": "@@ -71,12 +71,9 @@ procedure GNATCmd is\n    --  an old fashioned project file. -p cannot be used in conjunction\n    --  with -P.\n \n-   Max_Files_On_The_Command_Line : constant := 30; --  Arbitrary\n-\n-   Temp_File_Name : String_Access := null;\n+   Temp_File_Name : Path_Name_Type := No_Path;\n    --  The name of the temporary text file to put a list of source/object\n-   --  files to pass to a tool, when there are more than\n-   --  Max_Files_On_The_Command_Line files.\n+   --  files to pass to a tool.\n \n    ASIS_Main : String_Access := null;\n    --  Main for commands Check, Metric and Pretty, when -U is used\n@@ -311,6 +308,9 @@ procedure GNATCmd is\n       Add_Sources : Boolean := True;\n       Unit_Data   : Prj.Unit_Data;\n       Subunit     : Boolean := False;\n+      FD          : File_Descriptor := Invalid_FD;\n+      Status      : Integer;\n+      Success     : Boolean;\n \n    begin\n       --  Check if there is at least one argument that is not a switch\n@@ -326,8 +326,22 @@ procedure GNATCmd is\n       --  of the main project.\n \n       if Add_Sources then\n+\n+         --  For gnatcheck, gnatpp and gnatmetric , create a temporary file and\n+         --  put the list of sources in it.\n+\n+         if The_Command = Check\n+            or else The_Command = Pretty\n+            or else The_Command = Metric\n+         then\n+            Tempdir.Create_Temp_File (FD, Temp_File_Name);\n+            Last_Switches.Increment_Last;\n+            Last_Switches.Table (Last_Switches.Last) :=\n+              new String'(\"-files=\" & Get_Name_String (Temp_File_Name));\n+\n+         end if;\n+\n          declare\n-            Current_Last : constant Integer := Last_Switches.Last;\n             Proj         : Project_List;\n \n          begin\n@@ -572,70 +586,40 @@ procedure GNATCmd is\n                        and then Unit_Data.File_Names (Kind).Name /= No_File\n                        and then Unit_Data.File_Names (Kind).Path.Name /= Slash\n                      then\n-                        Last_Switches.Increment_Last;\n-                        Last_Switches.Table (Last_Switches.Last) :=\n-                          new String'\n-                            (Get_Name_String\n-                               (Unit_Data.File_Names\n-                                  (Kind).Path.Display_Name));\n-                     end if;\n-                  end loop;\n-               end if;\n-            end loop;\n-\n-            --  If the list of files is too long, create a temporary text file\n-            --  that lists these files, and pass this temp file to gnatcheck,\n-            --  gnatpp or gnatmetric using switch -files=.\n-\n-            if Last_Switches.Last - Current_Last >\n-              Max_Files_On_The_Command_Line\n-            then\n-               declare\n-                  Temp_File_FD : File_Descriptor;\n-                  Buffer       : String (1 .. 1_000);\n-                  Len          : Natural;\n-                  OK           : Boolean := True;\n+                        Get_Name_String\n+                          (Unit_Data.File_Names\n+                             (Kind).Path.Display_Name);\n \n-               begin\n-                  Create_Temp_File (Temp_File_FD, Temp_File_Name);\n+                        if FD /= Invalid_FD then\n+                           Name_Len := Name_Len + 1;\n+                           Name_Buffer (Name_Len) := ASCII.LF;\n+                           Status :=\n+                             Write (FD, Name_Buffer (1)'Address, Name_Len);\n \n-                  if Temp_File_Name /= null then\n-                     for Index in Current_Last + 1 ..\n-                       Last_Switches.Last\n-                     loop\n-                        Len := Last_Switches.Table (Index)'Length;\n-                        Buffer (1 .. Len) := Last_Switches.Table (Index).all;\n-                        Len := Len + 1;\n-                        Buffer (Len) := ASCII.LF;\n-                        Buffer (Len + 1) := ASCII.NUL;\n-                        OK :=\n-                          Write (Temp_File_FD,\n-                                 Buffer (1)'Address,\n-                                 Len) = Len;\n-                        exit when not OK;\n-                     end loop;\n+                           if Status /= Name_Len then\n+                              Osint.Fail (\"disk full\");\n+                           end if;\n \n-                     if OK then\n-                        Close (Temp_File_FD, OK);\n-                     else\n-                        Close (Temp_File_FD, OK);\n-                        OK := False;\n+                        else\n+                           Last_Switches.Increment_Last;\n+                           Last_Switches.Table (Last_Switches.Last) :=\n+                             new String'\n+                               (Get_Name_String\n+                                    (Unit_Data.File_Names\n+                                         (Kind).Path.Display_Name));\n+                        end if;\n                      end if;\n+                  end loop;\n \n-                     --  If there were any problem creating the temp file, then\n-                     --  pass the list of files.\n-\n-                     if OK then\n-\n-                        --  Replace list of files with -files=<temp file name>\n+                  if FD /= Invalid_FD then\n+                     Close (FD, Success);\n \n-                        Last_Switches.Set_Last (Current_Last + 1);\n-                        Last_Switches.Table (Last_Switches.Last) :=\n-                          new String'(\"-files=\" & Temp_File_Name.all);\n+                     if not Success then\n+                        Osint.Fail (\"disk full\");\n                      end if;\n                   end if;\n-               end;\n-            end if;\n+               end if;\n+            end loop;\n          end;\n       end if;\n    end Check_Files;\n@@ -752,8 +736,8 @@ procedure GNATCmd is\n       --  If a temporary text file that contains a list of files for a tool\n       --  has been created, delete this temporary file.\n \n-      if Temp_File_Name /= null then\n-         Delete_File (Temp_File_Name.all, Success);\n+      if Temp_File_Name /= No_Path then\n+         Delete_File (Get_Name_String (Temp_File_Name), Success);\n       end if;\n    end Delete_Temp_Config_Files;\n "}, {"sha": "9a0f878aa8a433c7833f38a116adb5876345740b", "filename": "gcc/ada/sem_disp.adb", "status": "modified", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f91a2557f88fd788380e3059bb7f475418002a6/gcc%2Fada%2Fsem_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f91a2557f88fd788380e3059bb7f475418002a6/gcc%2Fada%2Fsem_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_disp.adb?ref=4f91a2557f88fd788380e3059bb7f475418002a6", "patch": "@@ -301,11 +301,74 @@ package body Sem_Disp is\n       --  If a controlling formal has a statically tagged actual, the tag of\n       --  this actual is to be used for any tag-indeterminate actual.\n \n+      procedure Check_Direct_Call;\n+      --  In the case when the controlling actual is a class-wide type whose\n+      --  root type's completion is a task or protected type, the call is in\n+      --  fact direct. This routine detects the above case and modifies the\n+      --  call accordingly.\n+\n       procedure Check_Dispatching_Context;\n       --  If the call is tag-indeterminate and the entity being called is\n       --  abstract, verify that the context is a call that will eventually\n       --  provide a tag for dispatching, or has provided one already.\n \n+      -----------------------\n+      -- Check_Direct_Call --\n+      -----------------------\n+\n+      procedure Check_Direct_Call is\n+         Typ : Entity_Id := Etype (Control);\n+\n+      begin\n+         if Is_Class_Wide_Type (Typ) then\n+            Typ := Root_Type (Typ);\n+         end if;\n+\n+         --  Detect whether the controlling type is a private type completed\n+         --  by a task or protected type.\n+\n+         if Is_Private_Type (Typ)\n+           and then Present (Full_View (Typ))\n+           and then Is_Concurrent_Type (Full_View (Typ))\n+           and then Present (Corresponding_Record_Type (Full_View (Typ)))\n+         then\n+            Typ := Corresponding_Record_Type (Full_View (Typ));\n+\n+            --  The concurrent record's list of primitives should contain a\n+            --  wrapper for the entity of the call, retrieve it.\n+\n+            declare\n+               Prim          : Entity_Id;\n+               Prim_Elmt     : Elmt_Id;\n+               Wrapper_Found : Boolean := False;\n+\n+            begin\n+               Prim_Elmt := First_Elmt (Primitive_Operations (Typ));\n+               while Present (Prim_Elmt) loop\n+                  Prim := Node (Prim_Elmt);\n+\n+                  if Is_Primitive_Wrapper (Prim)\n+                    and then Wrapped_Entity (Prim) = Subp_Entity\n+                  then\n+                     Wrapper_Found := True;\n+                     exit;\n+                  end if;\n+\n+                  Next_Elmt (Prim_Elmt);\n+               end loop;\n+\n+               --  A primitive declared between two views should have a\n+               --  corresponding wrapper.\n+\n+               pragma Assert (Wrapper_Found);\n+\n+               --  Modify the call by setting the proper entity\n+\n+               Set_Entity (Name (N), Prim);\n+            end;\n+         end if;\n+      end Check_Direct_Call;\n+\n       -------------------------------\n       -- Check_Dispatching_Context --\n       -------------------------------\n@@ -484,6 +547,11 @@ package body Sem_Disp is\n             Set_Controlling_Argument (N, Control);\n             Check_Restriction (No_Dispatching_Calls, N);\n \n+            --  The dispatching call may need to be converted into a direct\n+            --  call in certain cases.\n+\n+            Check_Direct_Call;\n+\n          --  If there is a statically tagged actual and a tag-indeterminate\n          --  call to a function of the ancestor (such as that provided by a\n          --  default), then treat this as a dispatching call and propagate"}]}