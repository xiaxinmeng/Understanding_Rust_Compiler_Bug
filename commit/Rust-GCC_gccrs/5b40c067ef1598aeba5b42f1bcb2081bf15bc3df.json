{"sha": "5b40c067ef1598aeba5b42f1bcb2081bf15bc3df", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWI0MGMwNjdlZjE1OThhZWJhNWI0MmYxYmNiMjA4MWJmMTViYzNkZg==", "commit": {"author": {"name": "Tristan Gingold", "email": "gingold@adacore.com", "date": "2010-01-11T11:38:35Z"}, "committer": {"name": "Tristan Gingold", "email": "gingold@gcc.gnu.org", "date": "2010-01-11T11:38:35Z"}, "message": "demangle.h (ada_demangle): Add prototype.\n\ninclude/\n2010-01-11  Tristan Gingold  <gingold@adacore.com>\n\n\t* demangle.h (ada_demangle): Add prototype.\n\nlibiberty/\n2010-01-11  Tristan Gingold  <gingold@adacore.com>\n\n\t* cplus-dem.c (ada_demangle): Remove prototype.\n\t(grow_vect): Removed.\n\t(ada_demangle): Rewritten.\n\t(cplus_demangle): Fix indentation.\n\t* testsuite/demangle-expected: Add tests for Ada.\n\nFrom-SVN: r155804", "tree": {"sha": "e9141376caf9e1df607447776b1ab61a3d73fcbd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e9141376caf9e1df607447776b1ab61a3d73fcbd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5b40c067ef1598aeba5b42f1bcb2081bf15bc3df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b40c067ef1598aeba5b42f1bcb2081bf15bc3df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b40c067ef1598aeba5b42f1bcb2081bf15bc3df", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b40c067ef1598aeba5b42f1bcb2081bf15bc3df/comments", "author": {"login": "gingold-adacore", "id": 16334725, "node_id": "MDQ6VXNlcjE2MzM0NzI1", "avatar_url": "https://avatars.githubusercontent.com/u/16334725?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gingold-adacore", "html_url": "https://github.com/gingold-adacore", "followers_url": "https://api.github.com/users/gingold-adacore/followers", "following_url": "https://api.github.com/users/gingold-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/gingold-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/gingold-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gingold-adacore/subscriptions", "organizations_url": "https://api.github.com/users/gingold-adacore/orgs", "repos_url": "https://api.github.com/users/gingold-adacore/repos", "events_url": "https://api.github.com/users/gingold-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/gingold-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f3f623aeaf3ff99606e326d2955359e7f583470a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3f623aeaf3ff99606e326d2955359e7f583470a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f3f623aeaf3ff99606e326d2955359e7f583470a"}], "stats": {"total": 387, "additions": 279, "deletions": 108}, "files": [{"sha": "106d8b959c307f9951ccc9b5dcc101826f1d0881", "filename": "include/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b40c067ef1598aeba5b42f1bcb2081bf15bc3df/include%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b40c067ef1598aeba5b42f1bcb2081bf15bc3df/include%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2FChangeLog?ref=5b40c067ef1598aeba5b42f1bcb2081bf15bc3df", "patch": "@@ -1,3 +1,7 @@\n+2010-01-11  Tristan Gingold  <gingold@adacore.com>\n+\n+\t* demangle.h (ada_demangle): Add prototype.\n+\n 2010-01-05  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \tPR bootstrap/41771"}, {"sha": "2ab27602be15d26fbce3659888b517a9d75622c1", "filename": "include/demangle.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b40c067ef1598aeba5b42f1bcb2081bf15bc3df/include%2Fdemangle.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b40c067ef1598aeba5b42f1bcb2081bf15bc3df/include%2Fdemangle.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Fdemangle.h?ref=5b40c067ef1598aeba5b42f1bcb2081bf15bc3df", "patch": "@@ -160,6 +160,9 @@ java_demangle_v3_callback (const char *mangled,\n extern char*\n java_demangle_v3 (const char *mangled);\n \n+char *\n+ada_demangle (const char *mangled, int options);\n+\n enum gnu_v3_ctor_kinds {\n   gnu_v3_complete_object_ctor = 1,\n   gnu_v3_base_object_ctor,"}, {"sha": "6d30823569a1e41cb4f81a7b9030cd8e8b37ac35", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b40c067ef1598aeba5b42f1bcb2081bf15bc3df/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b40c067ef1598aeba5b42f1bcb2081bf15bc3df/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=5b40c067ef1598aeba5b42f1bcb2081bf15bc3df", "patch": "@@ -1,3 +1,11 @@\n+2010-01-11  Tristan Gingold  <gingold@adacore.com>\n+\n+\t* cplus-dem.c (ada_demangle): Remove prototype.\n+\t(grow_vect): Removed.\n+\t(ada_demangle): Rewritten.\n+\t(cplus_demangle): Fix indentation.\n+\t* testsuite/demangle-expected: Add tests for Ada.\n+\n 2010-01-09  Ian Lance Taylor  <iant@google.com>\n \n \tPR other/42230"}, {"sha": "f20a5ef9d84fada95f06458e0e6fdeb05ce85667", "filename": "libiberty/cplus-dem.c", "status": "modified", "additions": 169, "deletions": 108, "changes": 277, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b40c067ef1598aeba5b42f1bcb2081bf15bc3df/libiberty%2Fcplus-dem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b40c067ef1598aeba5b42f1bcb2081bf15bc3df/libiberty%2Fcplus-dem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fcplus-dem.c?ref=5b40c067ef1598aeba5b42f1bcb2081bf15bc3df", "patch": "@@ -62,8 +62,6 @@ void * realloc ();\n \n #include \"libiberty.h\"\n \n-static char *ada_demangle (const char *, int);\n-\n #define min(X,Y) (((X) < (Y)) ? (X) : (Y))\n \n /* A value at least one greater than the maximum number of characters\n@@ -478,8 +476,6 @@ demangle_arm_hp_template (struct work_stuff *, const char **, int, string *);\n static void\n recursively_demangle (struct work_stuff *, const char **, string *, int);\n \n-static void grow_vect (char **, size_t *, size_t, int);\n-\n /* Translate count to integer, consuming tokens in the process.\n    Conversion terminates on the first non-digit character.\n \n@@ -872,129 +868,194 @@ cplus_demangle (const char *mangled, int options)\n     }\n \n   if (GNAT_DEMANGLING)\n-    return ada_demangle(mangled,options);\n+    return ada_demangle (mangled, options);\n \n   ret = internal_cplus_demangle (work, mangled);\n   squangle_mop_up (work);\n   return (ret);\n }\n \n+/* Demangle ada names.  The encoding is documented in gcc/ada/exp_dbug.ads.  */\n \n-/* Assuming *OLD_VECT points to an array of *SIZE objects of size\n-   ELEMENT_SIZE, grow it to contain at least MIN_SIZE objects,\n-   updating *OLD_VECT and *SIZE as necessary.  */\n-\n-static void\n-grow_vect (char **old_vect, size_t *size, size_t min_size, int element_size)\n-{\n-  if (*size < min_size)\n-    {\n-      *size *= 2;\n-      if (*size < min_size)\n-\t*size = min_size;\n-      *old_vect = XRESIZEVAR (char, *old_vect, *size * element_size);\n-    }\n-}\n-\n-/* Demangle ada names:\n-   1. Discard final __{DIGIT}+ or ${DIGIT}+\n-   2. Convert other instances of embedded \"__\" to `.'.\n-   3. Discard leading _ada_.\n-   4. Remove everything after first ___ if it is followed by 'X'.\n-   5. Put symbols that should be suppressed in <...> brackets.\n-   The resulting string is valid until the next call of ada_demangle.  */\n-\n-static char *\n+char *\n ada_demangle (const char *mangled, int option ATTRIBUTE_UNUSED)\n {\n-  int i, j;\n   int len0;\n   const char* p;\n-  char *demangled = NULL;\n-  int changed;\n-  size_t demangled_size = 0;\n+  char *d;\n+  char *demangled;\n   \n-  changed = 0;\n-\n+  /* Discard leading _ada_, which is used for library level subprograms.  */\n   if (strncmp (mangled, \"_ada_\", 5) == 0)\n-    {\n-      mangled += 5;\n-      changed = 1;\n-    }\n-  \n-  if (mangled[0] == '_' || mangled[0] == '<')\n-    goto Suppress;\n+    mangled += 5;\n+\n+  /* All ada unit names are lower-case.  */\n+  if (!ISLOWER (mangled[0]))\n+    goto unknown;\n+\n+  /* Most of the demangling will trivially remove chars.  Operator names\n+     may add one char but because they are always preceeded by '__' which is\n+     replaced by '.', they eventually never expand the size.  '___elabs' and\n+     '___elabb' add only 2 chars, but they occur only once.  */\n+  len0 = strlen (mangled) + 2 + 1;\n+  demangled = XNEWVEC (char, len0);\n   \n-  p = strstr (mangled, \"___\");\n-  if (p == NULL)\n-    len0 = strlen (mangled);\n-  else\n+  d = demangled;\n+  p = mangled;\n+  while (1)\n     {\n-      if (p[3] == 'X')\n-\t{\n-\t  len0 = p - mangled;\n-\t  changed = 1;\n-\t}\n+      /* Convert name, which is always lower-case.  */\n+      if (ISLOWER (*p))\n+        {\n+          do\n+            *d++ = *p++;\n+          while (ISLOWER(*p) || ISDIGIT (*p)\n+                 || (p[0] == '_' && (ISLOWER (p[1]) || ISDIGIT (p[1]))));\n+        }\n+      else if (p[0] == 'O')\n+        {\n+          static const char * const operators[][2] =\n+            {{\"Oabs\", \"abs\"},  {\"Oand\", \"and\"},    {\"Omod\", \"mod\"},\n+             {\"Onot\", \"not\"},  {\"Oor\", \"or\"},      {\"Orem\", \"rem\"},\n+             {\"Oxor\", \"xor\"},  {\"Oeq\", \"=\"},       {\"One\", \"/=\"},\n+             {\"Olt\", \"<\"},     {\"Ole\", \"<=\"},      {\"Ogt\", \">\"},\n+             {\"Oge\", \">=\"},    {\"Oadd\", \"+\"},      {\"Osubtract\", \"-\"},\n+             {\"Oconcat\", \"&\"}, {\"Omultiply\", \"*\"}, {\"Odivide\", \"/\"},\n+             {\"Oexpon\", \"**\"}, {NULL, NULL}};\n+          int k;\n+\n+          for (k = 0; operators[k][0]; k++)\n+            {\n+              int l = strlen (operators[k][0]);\n+              if (!strncmp (p, operators[k][0], l))\n+                {\n+                  p += l;\n+                  l = strlen (operators[k][1]);\n+                  *d++ = '\"';\n+                  memcpy (d, operators[k][1], l);\n+                  d += l;\n+                  *d++ = '\"';\n+                  break;\n+                }\n+            }\n+          /* Operator not found.  */\n+          if (!operators[k][0])\n+            goto unknown;\n+        }\n       else\n-\tgoto Suppress;\n-    }\n-  \n-  /* Make demangled big enough for possible expansion by operator name.  */\n-  grow_vect (&demangled,\n-\t     &demangled_size,  2 * len0 + 1,\n-\t     sizeof (char));\n-  \n-  if (ISDIGIT ((unsigned char) mangled[len0 - 1])) {\n-    for (i = len0 - 2; i >= 0 && ISDIGIT ((unsigned char) mangled[i]); i -= 1)\n-      ;\n-    if (i > 1 && mangled[i] == '_' && mangled[i - 1] == '_')\n-      {\n-\tlen0 = i - 1;\n-\tchanged = 1;\n-      }\n-    else if (mangled[i] == '$')\n-      {\n-\tlen0 = i;\n-\tchanged = 1;\n-      }\n-  }\n-  \n-  for (i = 0, j = 0; i < len0 && ! ISALPHA ((unsigned char)mangled[i]);\n-       i += 1, j += 1)\n-    demangled[j] = mangled[i];\n-  \n-  while (i < len0)\n-    {\n-      if (i < len0 - 2 && mangled[i] == '_' && mangled[i + 1] == '_')\n-\t{\n-\t  demangled[j] = '.';\n-\t  changed = 1;\n-\t  i += 2; j += 1;\n-\t}\n+        {\n+          /* Not a GNAT encoding.  */\n+          goto unknown;\n+        }\n+\n+      if (p[0] == '_')\n+        {\n+          /* Separator.  */\n+          if (p[1] == '_')\n+            {\n+              /* Standard separator.  Handled first.  */\n+              p += 2;\n+              if (ISDIGIT (*p))\n+                {\n+                  /* Overloading.  */\n+                  do\n+                    p++;\n+                  while (ISDIGIT (*p) || (p[0] == '_' && ISDIGIT (p[1])));\n+                }\n+              else if (*p == '_' && !strcmp (p + 1, \"elabb\"))\n+                {\n+                  memcpy (d, \"'Elab_Body\", 10);\n+                  d += 10;\n+                  break;\n+                }\n+              else if (*p == '_' && !strcmp (p + 1, \"elabs\"))\n+                {\n+                  memcpy (d, \"'Elab_Spec\", 10);\n+                  d += 10;\n+                  break;\n+                }\n+              else\n+                {\n+                  *d++ = '.';\n+                  continue;\n+                }\n+            }\n+          else if (p[1] == 'B' || p[1] == 'E')\n+            {\n+              /* Entry Body or barrier Evaluation.  */\n+              p += 2;\n+              while (ISDIGIT (*p))\n+                p++;\n+              if (p[0] == 's' && p[1] == 0)\n+                break;\n+              else\n+                goto unknown;\n+            }\n+          else\n+            goto unknown;\n+        }\n+\n+      if (p[0] == 'T' && p[1] == 'K')\n+        {\n+          if (p[2] == 'B' && p[3] == 0)\n+            {\n+              /* Subprogram for task body.  */\n+              break;\n+            }\n+          else if (p[2] == '_' && p[3] == '_')\n+            {\n+              /* Inner declarations in a task.  */\n+              p += 4;\n+              *d++ = '.';\n+              continue;\n+            }\n+          else\n+            goto unknown;\n+        }\n+      if ((p[0] == 'P' || p[0] == 'N') && p[1] == 0)\n+        {\n+          /* Protected type subprogram.  */\n+          break;\n+        }\n+      if (p[0] == 'E' && p[1] == 0)\n+        {\n+          /* Exception name.  */\n+          goto unknown;\n+        }\n+      if (*p == 'N' || *p == 'S')\n+        {\n+          /* Enumerated type name table.  */\n+          goto unknown;\n+        }\n+      if (p[0] == 'X')\n+        {\n+          /* Body nested.  */\n+          if (p[1] == 'n' || p[1] == 'b')\n+            p += 2;\n+          else if (p[1] == 0)\n+            p++;\n+        }\n+      if (p[0] == '.' && ISDIGIT (p[1]))\n+        {\n+          /* Nested subprogram.  */\n+          p += 2;\n+          while (ISDIGIT (*p))\n+            p++;\n+        }\n+      if (*p == 0)\n+        {\n+          /* End of mangled name.  */\n+          break;\n+        }\n       else\n-\t{\n-\t  demangled[j] = mangled[i];\n-\t  i += 1;  j += 1;\n-\t}\n+        goto unknown;\n     }\n-  demangled[j] = '\\000';\n-  \n-  for (i = 0; demangled[i] != '\\0'; i += 1)\n-    if (ISUPPER ((unsigned char)demangled[i]) || demangled[i] == ' ')\n-      goto Suppress;\n+  *d = 0;\n+  return demangled;\n \n-  if (! changed)\n-    {\n-      free (demangled);\n-      return NULL;\n-    }\n-  else\n-    return demangled;\n-  \n- Suppress:\n-  grow_vect (&demangled,\n-\t     &demangled_size,  strlen (mangled) + 3,\n-\t     sizeof (char));\n+ unknown:\n+  len0 = strlen (mangled);\n+  demangled = XNEWVEC (char, len0 + 3);\n \n   if (mangled[0] == '<')\n      strcpy (demangled, mangled);"}, {"sha": "c201a9832711cfe021486c79cba935fc34a584a6", "filename": "libiberty/testsuite/demangle-expected", "status": "modified", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b40c067ef1598aeba5b42f1bcb2081bf15bc3df/libiberty%2Ftestsuite%2Fdemangle-expected", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b40c067ef1598aeba5b42f1bcb2081bf15bc3df/libiberty%2Ftestsuite%2Fdemangle-expected", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Ftestsuite%2Fdemangle-expected?ref=5b40c067ef1598aeba5b42f1bcb2081bf15bc3df", "patch": "@@ -3926,3 +3926,98 @@ S<int>::x::{lambda()#3}::operator()() const\n --format=gnu-v3\n _Z1fN1SUt_E\n f(S::{unnamed type#1})\n+#\n+# Ada (GNAT) tests.\n+#\n+# Simple test.\n+--format=gnat\n+yz__qrs\n+yz.qrs\n+# Operator\n+--format=gnat\n+oper__Oadd\n+oper.\"+\"\n+# Overloaded subprogram.\n+--format=gnat\n+yz__qrs__2\n+yz.qrs\n+# Nested subprogram.\n+--format=gnat\n+yz__qrs__tuv.1661\n+yz.qrs.tuv\n+# Nested and overloaded subprograms.\n+--format=gnat\n+yz__qrs__tuv__2_1.1667\n+yz.qrs.tuv\n+--format=gnat\n+yz__qrs__tuv__2_2.1670\n+yz.qrs.tuv\n+--format=gnat\n+yz__qrs__tuv__2_3.1674\n+yz.qrs.tuv\n+# Elaborated flag (not demangled)\n+--format=gnat\n+x_E\n+<x_E>\n+# Nested package\n+--format=gnat\n+x__m1\n+x.m1\n+--format=gnat\n+x__m3\n+x.m3\n+--format=gnat\n+x__y__m2X\n+x.y.m2\n+--format=gnat\n+x__y__z__rXb\n+x.y.z.r\n+# Child package\n+--format=gnat\n+x__y__j\n+x.y.j\n+# Library level\n+--format=gnat\n+_ada_x__m3\n+x.m3\n+# Package body elaborator\n+--format=gnat\n+p___elabb\n+p'Elab_Body\n+# Package spec elaborator\n+--format=gnat\n+p___elabs\n+p'Elab_Spec\n+# Task body\n+--format=gnat\n+p__taskobjTKB\n+p.taskobj\n+# Task subprogram\n+--format=gnat\n+p__taskobjTK__f1.2330\n+p.taskobj.f1\n+# Protected types subprograms\n+--format=gnat\n+prot__lock__getN\n+prot.lock.get\n+--format=gnat\n+prot__lock__getP\n+prot.lock.get\n+--format=gnat\n+prot__lock__get__sub.2590\n+prot.lock.get.sub\n+--format=gnat\n+prot__lock__setN\n+prot.lock.set\n+--format=gnat\n+prot__lock__setP\n+prot.lock.set\n+# Protected type entries\n+--format=gnat\n+prot__lock__update_B7s\n+prot.lock.update\n+--format=gnat\n+prot__lock__update_E6s\n+prot.lock.update\n+\n+"}]}