{"sha": "015782a5aea37b0cd80b5f1888988d5c79398b81", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDE1NzgyYTVhZWEzN2IwY2Q4MGI1ZjE4ODg5ODhkNWM3OTM5OGI4MQ==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2016-03-11T21:07:31Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2016-03-11T21:07:31Z"}, "message": "re PR tree-optimization/64058 (Performance degradation after r216304)\n\n\tPR tree-optimization/64058\n\t* tree-ssa-coalesce.c (struct coalesce_pair): Add new field INDEX.\n\t(num_coalesce_pairs): Move up earlier in file.\n\t(find_coalesce_pair): Initialize the INDEX field for each pair\n\tdiscovered.\n\t(compare_pairs): No longer sort on the elements in each pair.\n\tInstead break ties with the index of the coalesce pair.\n\nFrom-SVN: r234149", "tree": {"sha": "7d12dc602ab2bed2136b0f19bde0c604b603a58c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7d12dc602ab2bed2136b0f19bde0c604b603a58c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/015782a5aea37b0cd80b5f1888988d5c79398b81", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/015782a5aea37b0cd80b5f1888988d5c79398b81", "html_url": "https://github.com/Rust-GCC/gccrs/commit/015782a5aea37b0cd80b5f1888988d5c79398b81", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/015782a5aea37b0cd80b5f1888988d5c79398b81/comments", "author": null, "committer": null, "parents": [{"sha": "3edc5da4a6b61d9184f1211037ab669897d1eef2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3edc5da4a6b61d9184f1211037ab669897d1eef2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3edc5da4a6b61d9184f1211037ab669897d1eef2"}], "stats": {"total": 44, "additions": 26, "deletions": 18}, "files": [{"sha": "f3a73515480c236b6bb4938ce4fcf1103de49aa4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/015782a5aea37b0cd80b5f1888988d5c79398b81/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/015782a5aea37b0cd80b5f1888988d5c79398b81/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=015782a5aea37b0cd80b5f1888988d5c79398b81", "patch": "@@ -1,3 +1,13 @@\n+2016-03-11  Jeff Law  <law@redhat.com>\n+\n+\tPR tree-optimization/64058\n+\t* tree-ssa-coalesce.c (struct coalesce_pair): Add new field INDEX.\n+\t(num_coalesce_pairs): Move up earlier in file.\n+\t(find_coalesce_pair): Initialize the INDEX field for each pair\n+\tdiscovered.\n+\t(compare_pairs): No longer sort on the elements in each pair.\n+\tInstead break ties with the index of the coalesce pair.\n+\n 2016-03-11  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \tPR target/70002"}, {"sha": "e49876eac3349374a3cd9240ad27a5652d783a82", "filename": "gcc/tree-ssa-coalesce.c", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/015782a5aea37b0cd80b5f1888988d5c79398b81/gcc%2Ftree-ssa-coalesce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/015782a5aea37b0cd80b5f1888988d5c79398b81/gcc%2Ftree-ssa-coalesce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-coalesce.c?ref=015782a5aea37b0cd80b5f1888988d5c79398b81", "patch": "@@ -50,6 +50,11 @@ struct coalesce_pair\n   int first_element;\n   int second_element;\n   int cost;\n+\n+  /* The order in which coalescing pairs are discovered is recorded in this\n+     field, which is used as the final tie breaker when sorting coalesce\n+     pairs.  */\n+  int index;\n };\n \n /* Coalesce pair hashtable helpers.  */\n@@ -254,6 +259,13 @@ delete_coalesce_list (coalesce_list *cl)\n   free (cl);\n }\n \n+/* Return the number of unique coalesce pairs in CL.  */\n+\n+static inline int\n+num_coalesce_pairs (coalesce_list *cl)\n+{\n+  return cl->list->elements ();\n+}\n \n /* Find a matching coalesce pair object in CL for the pair P1 and P2.  If\n    one isn't found, return NULL if CREATE is false, otherwise create a new\n@@ -290,6 +302,7 @@ find_coalesce_pair (coalesce_list *cl, int p1, int p2, bool create)\n       pair->first_element = p.first_element;\n       pair->second_element = p.second_element;\n       pair->cost = 0;\n+      pair->index = num_coalesce_pairs (cl);\n       *slot = pair;\n     }\n \n@@ -343,29 +356,14 @@ compare_pairs (const void *p1, const void *p2)\n   int result;\n \n   result = (* pp1)->cost - (* pp2)->cost;\n-  /* Since qsort does not guarantee stability we use the elements\n-     as a secondary key.  This provides us with independence from\n-     the host's implementation of the sorting algorithm.  */\n+  /* And if everything else is equal, then sort based on which\n+     coalesce pair was found first.  */\n   if (result == 0)\n-    {\n-      result = (* pp2)->first_element - (* pp1)->first_element;\n-      if (result == 0)\n-\tresult = (* pp2)->second_element - (* pp1)->second_element;\n-    }\n+    result = (*pp2)->index - (*pp1)->index;\n \n   return result;\n }\n \n-\n-/* Return the number of unique coalesce pairs in CL.  */\n-\n-static inline int\n-num_coalesce_pairs (coalesce_list *cl)\n-{\n-  return cl->list->elements ();\n-}\n-\n-\n /* Iterate over CL using ITER, returning values in PAIR.  */\n \n #define FOR_EACH_PARTITION_PAIR(PAIR, ITER, CL)\t\t\\"}]}