{"sha": "ce0ab8fb46f07b0bde56aa31e46d57b81379fde3", "node_id": "C_kwDOANBUbNoAKGNlMGFiOGZiNDZmMDdiMGJkZTU2YWEzMWU0NmQ1N2I4MTM3OWZkZTM", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2020-03-05T20:50:45Z"}, "committer": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2022-01-07T00:23:16Z"}, "message": "c++: temporary lifetime with aggregate init [PR94041]\n\nIn C++98 the lifetime of temporaries in aggregate initialization was\nunclear, but C++11 DR201 clarified that only temporaries created for\ndefault-initialization of an array element with no corresponding\ninitializer-clause are destroyed immediately; all others persist until the\nend of the full-expression.\n\nBut we never implemented that, and continued treating individual element\ninitializations as full-expressions, such as in my patch for PR50866 in\nr180442.  This blocked my attempted fix for PR66139, which extended the use\nof split_nonconstant_init, and thus the bug, to aggregate initialization of\ntemporaries within an expression.\n\nThe longer temporary lifetime creates further EH region overlap problems\nlike the ones that wrap_temporary_cleanups addresses: in aggr7.C, we start\nout with a normal nesting of\n\nA1\n c.b1\n   A2\n    c.b2\n     ...\n   ~A2\n~A1\n\nwhere on the way in, throwing from one of the inits will clean up from the\nprevious inits.  But once c.b2 is initialized, throwing from ~A2 must not\nclean up c.b1; instead it needs to clean up c.  So as in build_new_1, we\ndeal with this by guarding the B cleanups with flags that are cleared once c\nis fully constructed; throwing from one of the ~A still hits that region,\nbut does not call ~B.  And then wrap_temporary_cleanups deals with calling\n~C, but we need to tell it not to wrap the subobject cleanups.\n\nThe change from expressing the subobject cleanups with CLEANUP_STMT to\nTARGET_EXPR was also necessary because we need them to collate with the ~A\nin gimplify_cleanup_point_expr; the CLEANUP_STMT representation only worked\nwith treating subobject initializations as full-expressions.\n\n\tPR c++/94041\n\ngcc/cp/ChangeLog:\n\n\t* decl.c (check_initializer): Remove obsolete comment.\n\t(wrap_cleanups_r): Don't wrap CLEANUP_EH_ONLY.\n\t(initialize_local_var): Change assert to test.\n\t* typeck2.c (maybe_push_temp_cleanup): New.\n\t(split_nonconstant_init_1): Use it.\n\t(split_nonconstant_init): Clear cleanup flags.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/init/aggr7-eh.C: New test.\n\t* g++.dg/cpp0x/initlist122.C: Also test aggregate variable.", "tree": {"sha": "bdb5e8757231f734c284db6f3fac886a127b78c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bdb5e8757231f734c284db6f3fac886a127b78c7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ce0ab8fb46f07b0bde56aa31e46d57b81379fde3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce0ab8fb46f07b0bde56aa31e46d57b81379fde3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce0ab8fb46f07b0bde56aa31e46d57b81379fde3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce0ab8fb46f07b0bde56aa31e46d57b81379fde3/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e948436eab818c527dd60b0ef939c4f42fbe8ba4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e948436eab818c527dd60b0ef939c4f42fbe8ba4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e948436eab818c527dd60b0ef939c4f42fbe8ba4"}], "stats": {"total": 141, "additions": 121, "deletions": 20}, "files": [{"sha": "9f759ceb1c8b37ae21df498eb79961bfd7263137", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce0ab8fb46f07b0bde56aa31e46d57b81379fde3/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce0ab8fb46f07b0bde56aa31e46d57b81379fde3/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=ce0ab8fb46f07b0bde56aa31e46d57b81379fde3", "patch": "@@ -7257,11 +7257,6 @@ check_initializer (tree decl, tree init, int flags, vec<tree, va_gc> **cleanups)\n \n       if (init && TREE_CODE (init) != TREE_VEC)\n \t{\n-\t  /* In aggregate initialization of a variable, each element\n-\t     initialization is a full-expression because there is no\n-\t     enclosing expression.  */\n-\t  gcc_assert (stmts_are_full_exprs_p ());\n-\n \t  init_code = store_init_value (decl, init, cleanups, flags);\n \n \t  if (DECL_INITIAL (decl)\n@@ -7428,7 +7423,8 @@ wrap_cleanups_r (tree *stmt_p, int *walk_subtrees, void *data)\n       tree guard = (tree)data;\n       tree tcleanup = TARGET_EXPR_CLEANUP (*stmt_p);\n \n-      if (tcleanup && !expr_noexcept_p (tcleanup, tf_none))\n+      if (tcleanup && !CLEANUP_EH_ONLY (*stmt_p)\n+\t  && !expr_noexcept_p (tcleanup, tf_none))\n \t{\n \t  tcleanup = build2 (TRY_CATCH_EXPR, void_type_node, tcleanup, guard);\n \t  /* Tell honor_protect_cleanup_actions to handle this as a separate\n@@ -7500,11 +7496,11 @@ initialize_local_var (tree decl, tree init)\n     {\n       tree rinit = (TREE_CODE (init) == INIT_EXPR\n \t\t    ? TREE_OPERAND (init, 1) : NULL_TREE);\n-      if (rinit && !TREE_SIDE_EFFECTS (rinit))\n+      if (rinit && !TREE_SIDE_EFFECTS (rinit)\n+\t  && TREE_OPERAND (init, 0) == decl)\n \t{\n \t  /* Stick simple initializers in DECL_INITIAL so that\n \t     -Wno-init-self works (c++/34772).  */\n-\t  gcc_assert (TREE_OPERAND (init, 0) == decl);\n \t  DECL_INITIAL (decl) = rinit;\n \n \t  if (warn_init_self && TYPE_REF_P (type))"}, {"sha": "54b1d0da1291e1828320ceddf9da4f878fa1d5bb", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 45, "deletions": 10, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce0ab8fb46f07b0bde56aa31e46d57b81379fde3/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce0ab8fb46f07b0bde56aa31e46d57b81379fde3/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=ce0ab8fb46f07b0bde56aa31e46d57b81379fde3", "patch": "@@ -459,13 +459,34 @@ cxx_incomplete_type_error (location_t loc, const_tree value, const_tree type)\n }\n \n \f\n+/* We've just initialized subobject SUB; also insert a TARGET_EXPR with an\n+   EH-only cleanup for SUB.  Because of EH region nesting issues, we need to\n+   make the cleanup conditional on a flag that we will clear once the object is\n+   fully initialized, so push a new flag onto FLAGS.  */\n+\n+static void\n+maybe_push_temp_cleanup (tree sub, vec<tree,va_gc> **flags)\n+{\n+  if (tree cleanup\n+      = cxx_maybe_build_cleanup (sub, tf_warning_or_error))\n+    {\n+      tree tx = get_target_expr (boolean_true_node);\n+      tree flag = TARGET_EXPR_SLOT (tx);\n+      CLEANUP_EH_ONLY (tx) = true;\n+      TARGET_EXPR_CLEANUP (tx) = build3 (COND_EXPR, void_type_node,\n+\t\t\t\t\t flag, cleanup, void_node);\n+      add_stmt (tx);\n+      vec_safe_push (*flags, flag);\n+    }\n+}\n+\n /* The recursive part of split_nonconstant_init.  DEST is an lvalue\n    expression to which INIT should be assigned.  INIT is a CONSTRUCTOR.\n    Return true if the whole of the value was initialized by the\n    generated statements.  */\n \n static bool\n-split_nonconstant_init_1 (tree dest, tree init, bool nested)\n+split_nonconstant_init_1 (tree dest, tree init, bool nested, vec<tree,va_gc> **flags)\n {\n   unsigned HOST_WIDE_INT idx, tidx = HOST_WIDE_INT_M1U;\n   tree field_index, value;\n@@ -501,9 +522,7 @@ split_nonconstant_init_1 (tree dest, tree init, bool nested)\n \t  if (nested)\n \t    /* Also clean up the whole array if something later in an enclosing\n \t       init-list throws.  */\n-\t    if (tree cleanup = cxx_maybe_build_cleanup (dest,\n-\t\t\t\t\t\t\ttf_warning_or_error))\n-\t    finish_eh_cleanup (cleanup);\n+\t    maybe_push_temp_cleanup (dest, flags);\n \t  return true;\n \t}\n       /* FALLTHRU */\n@@ -533,7 +552,7 @@ split_nonconstant_init_1 (tree dest, tree init, bool nested)\n \t\tsub = build3 (COMPONENT_REF, inner_type, dest, field_index,\n \t\t\t      NULL_TREE);\n \n-\t      if (!split_nonconstant_init_1 (sub, value, true)\n+\t      if (!split_nonconstant_init_1 (sub, value, true, flags)\n \t\t      /* For flexible array member with initializer we\n \t\t\t can't remove the initializer, because only the\n \t\t\t initializer determines how many elements the\n@@ -616,11 +635,8 @@ split_nonconstant_init_1 (tree dest, tree init, bool nested)\n \t\t      code = build2 (INIT_EXPR, inner_type, sub, value);\n \t\t    }\n \t\t  code = build_stmt (input_location, EXPR_STMT, code);\n-\t\t  code = maybe_cleanup_point_expr_void (code);\n \t\t  add_stmt (code);\n-\t\t  if (tree cleanup\n-\t\t      = cxx_maybe_build_cleanup (sub, tf_warning_or_error))\n-\t\t    finish_eh_cleanup (cleanup);\n+\t\t  maybe_push_temp_cleanup (sub, flags);\n \t\t}\n \n \t      num_split_elts++;\n@@ -687,10 +703,29 @@ split_nonconstant_init (tree dest, tree init)\n     init = TARGET_EXPR_INITIAL (init);\n   if (TREE_CODE (init) == CONSTRUCTOR)\n     {\n+      /* Subobject initializers are not full-expressions.  */\n+      auto fe = (make_temp_override\n+\t\t (current_stmt_tree ()->stmts_are_full_exprs_p, 0));\n+\n       init = cp_fully_fold_init (init);\n       code = push_stmt_list ();\n-      if (split_nonconstant_init_1 (dest, init, false))\n+\n+      /* Collect flags for disabling subobject cleanups once the complete\n+\t object is fully constructed.  */\n+      vec<tree, va_gc> *flags = make_tree_vector ();\n+\n+      if (split_nonconstant_init_1 (dest, init, false, &flags))\n \tinit = NULL_TREE;\n+\n+      for (tree f : flags)\n+\t{\n+\t  /* See maybe_push_temp_cleanup.  */\n+\t  tree d = f;\n+\t  tree i = boolean_false_node;\n+\t  add_stmt (build2 (MODIFY_EXPR, TREE_TYPE (d), d, i));\n+\t}\n+      release_tree_vector (flags);\n+\n       code = pop_stmt_list (code);\n       if (VAR_P (dest) && !is_local_temp (dest))\n \t{"}, {"sha": "81953a44e12d877b9f819f7167f8535280bec859", "filename": "gcc/testsuite/g++.dg/cpp0x/initlist122.C", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce0ab8fb46f07b0bde56aa31e46d57b81379fde3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finitlist122.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce0ab8fb46f07b0bde56aa31e46d57b81379fde3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finitlist122.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finitlist122.C?ref=ce0ab8fb46f07b0bde56aa31e46d57b81379fde3", "patch": "@@ -6,11 +6,19 @@ struct Temp { ~Temp() { gone = true; } };\n struct A{ A() {}; A(const Temp&) noexcept {};  };\n struct B{ ~B() {}; };\n struct Pair{ A a; B b; };\n-\n void foo(const Pair&) noexcept { if (gone) __builtin_abort(); }\n \n+B bar() { if (gone) __builtin_abort(); return {}; }\n+\n int main()\n {\n-  foo({A(Temp{}), B()});\n+  Pair p{A(Temp{}), bar()};\n+\n+  if (!gone) __builtin_abort ();\n+\n+  gone = false;\n+\n+  foo({A(Temp{})});\n+\n   if (!gone) __builtin_abort ();\n }"}, {"sha": "db45e15d9af70074d17e12712434362b227e6c23", "filename": "gcc/testsuite/g++.dg/init/aggr7-eh.C", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce0ab8fb46f07b0bde56aa31e46d57b81379fde3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Faggr7-eh.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce0ab8fb46f07b0bde56aa31e46d57b81379fde3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Faggr7-eh.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Faggr7-eh.C?ref=ce0ab8fb46f07b0bde56aa31e46d57b81379fde3", "patch": "@@ -0,0 +1,62 @@\n+// PR c++/50866, adjusted\n+// { dg-do run }\n+\n+#if __cplusplus > 201100L\n+#define THROWING noexcept(false)\n+#else\n+#define THROWING\n+#endif\n+\n+extern \"C\" void abort ();\n+\n+int a;\n+int d = -1;\n+struct A {\n+  A() { ++a; }\n+  A(const A&);\n+  ~A() THROWING {\n+    --a;\n+    if (a == d)\n+      throw (short)a;\n+  }\n+};\n+int b;\n+int t;\n+struct B {\n+  B(const char *, const A& = A())\n+  {\n+    if (b == t)\n+      throw b;\n+    ++b;\n+    if (a != b) abort ();\n+  }\n+  B(const B&);\n+  ~B()\n+  {\n+    --b;\n+  }\n+};\n+struct C {\n+  B b1, b2, b3;\n+};\n+void f()\n+{\n+  try\n+    {\n+      C c = { \"a\",\"b\",\"c\" };\n+      if (a != 0) abort ();\n+      if (b != 3) abort ();\n+    }\n+  catch (int i) { }\n+  catch (short s) { }\n+  if (a != 0) abort ();\n+  if (b != 0) abort ();\n+}\n+\n+int main()\n+{\n+  for (t = 0; t <= 3; ++t)\n+    f();\n+  for (d = 0; d <= 2; ++d)\n+    f();\n+}"}]}