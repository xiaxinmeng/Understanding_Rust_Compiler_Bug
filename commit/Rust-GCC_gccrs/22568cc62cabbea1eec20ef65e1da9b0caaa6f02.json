{"sha": "22568cc62cabbea1eec20ef65e1da9b0caaa6f02", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjI1NjhjYzYyY2FiYmVhMWVlYzIwZWY2NWUxZGE5YjBjYWFhNmYwMg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2006-12-04T10:26:00Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2006-12-04T10:26:00Z"}, "message": "re PR middle-end/29947 (OpenMP parallel for fails for reversed loop range)\n\n\tPR libgomp/29947\n\t* omp-low.c (expand_omp_for_static_nochunk,\n\texpand_omp_for_static_chunk): Do all arithmetics in signed rather than\n\tunsigned type.\n\n\t* loop.c (gomp_loop_init): Make parameters signed.  Set ws->end to\n\tstart if there shouldn't be any loop iterations.\n\t(gomp_loop_ordered_static_start): Remove start == end test.\n\t* testsuite/libgomp.c/pr29947-1.c: New test.\n\t* testsuite/libgomp.c/pr29947-2.c: New test.\n\nFrom-SVN: r119485", "tree": {"sha": "f94786a4fcf50b6049962a9a01cc79e07e724e65", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f94786a4fcf50b6049962a9a01cc79e07e724e65"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/22568cc62cabbea1eec20ef65e1da9b0caaa6f02", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22568cc62cabbea1eec20ef65e1da9b0caaa6f02", "html_url": "https://github.com/Rust-GCC/gccrs/commit/22568cc62cabbea1eec20ef65e1da9b0caaa6f02", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22568cc62cabbea1eec20ef65e1da9b0caaa6f02/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d3c673c74acfcc0202b0013677ef280e76fffb72", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3c673c74acfcc0202b0013677ef280e76fffb72", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d3c673c74acfcc0202b0013677ef280e76fffb72"}], "stats": {"total": 732, "additions": 699, "deletions": 33}, "files": [{"sha": "8b65b1630d7cd0b15b730c70c40da119e25fb8ef", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22568cc62cabbea1eec20ef65e1da9b0caaa6f02/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22568cc62cabbea1eec20ef65e1da9b0caaa6f02/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=22568cc62cabbea1eec20ef65e1da9b0caaa6f02", "patch": "@@ -1,5 +1,10 @@\n 2006-12-04  Jakub Jelinek  <jakub@redhat.com>\n \n+\tPR libgomp/29947\n+\t* omp-low.c (expand_omp_for_static_nochunk,\n+\texpand_omp_for_static_chunk): Do all arithmetics in signed rather than\n+\tunsigned type.\n+\n \tPR middle-end/29965\n \t* omp-low.c (determine_parallel_type): Don't try to optimize combined\n \tparallels if region->exit or region->inner->exit is NULL."}, {"sha": "f58ee1f1b6f6a0bb8cd8eaacd9590128a85e62e4", "filename": "gcc/omp-low.c", "status": "modified", "additions": 24, "deletions": 26, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22568cc62cabbea1eec20ef65e1da9b0caaa6f02/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22568cc62cabbea1eec20ef65e1da9b0caaa6f02/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=22568cc62cabbea1eec20ef65e1da9b0caaa6f02", "patch": "@@ -2771,13 +2771,12 @@ expand_omp_for_static_nochunk (struct omp_region *region,\n \t\t\t       struct omp_for_data *fd)\n {\n   tree l0, l1, l2, n, q, s0, e0, e, t, nthreads, threadid;\n-  tree type, utype, list;\n+  tree type, list;\n   basic_block entry_bb, exit_bb, seq_start_bb, body_bb, cont_bb;\n   basic_block fin_bb;\n   block_stmt_iterator si;\n \n   type = TREE_TYPE (fd->v);\n-  utype = lang_hooks.types.unsigned_type (type);\n \n   entry_bb = region->entry;\n   seq_start_bb = create_empty_bb (entry_bb);\n@@ -2795,12 +2794,12 @@ expand_omp_for_static_nochunk (struct omp_region *region,\n \n   t = built_in_decls[BUILT_IN_OMP_GET_NUM_THREADS];\n   t = build_function_call_expr (t, NULL);\n-  t = fold_convert (utype, t);\n+  t = fold_convert (type, t);\n   nthreads = get_formal_tmp_var (t, &list);\n   \n   t = built_in_decls[BUILT_IN_OMP_GET_THREAD_NUM];\n   t = build_function_call_expr (t, NULL);\n-  t = fold_convert (utype, t);\n+  t = fold_convert (type, t);\n   threadid = get_formal_tmp_var (t, &list);\n \n   fd->n1 = fold_convert (type, fd->n1);\n@@ -2820,25 +2819,25 @@ expand_omp_for_static_nochunk (struct omp_region *region,\n   t = fold_build2 (PLUS_EXPR, type, t, fd->n2);\n   t = fold_build2 (MINUS_EXPR, type, t, fd->n1);\n   t = fold_build2 (TRUNC_DIV_EXPR, type, t, fd->step);\n-  t = fold_convert (utype, t);\n+  t = fold_convert (type, t);\n   if (is_gimple_val (t))\n     n = t;\n   else\n     n = get_formal_tmp_var (t, &list);\n \n-  t = build2 (TRUNC_DIV_EXPR, utype, n, nthreads);\n+  t = build2 (TRUNC_DIV_EXPR, type, n, nthreads);\n   q = get_formal_tmp_var (t, &list);\n \n-  t = build2 (MULT_EXPR, utype, q, nthreads);\n-  t = build2 (NE_EXPR, utype, t, n);\n-  t = build2 (PLUS_EXPR, utype, q, t);\n+  t = build2 (MULT_EXPR, type, q, nthreads);\n+  t = build2 (NE_EXPR, type, t, n);\n+  t = build2 (PLUS_EXPR, type, q, t);\n   q = get_formal_tmp_var (t, &list);\n \n-  t = build2 (MULT_EXPR, utype, q, threadid);\n+  t = build2 (MULT_EXPR, type, q, threadid);\n   s0 = get_formal_tmp_var (t, &list);\n \n-  t = build2 (PLUS_EXPR, utype, s0, q);\n-  t = build2 (MIN_EXPR, utype, t, n);\n+  t = build2 (PLUS_EXPR, type, s0, q);\n+  t = build2 (MIN_EXPR, type, t, n);\n   e0 = get_formal_tmp_var (t, &list);\n \n   t = build2 (GE_EXPR, boolean_type_node, s0, e0);\n@@ -2944,14 +2943,13 @@ expand_omp_for_static_chunk (struct omp_region *region, struct omp_for_data *fd)\n {\n   tree l0, l1, l2, l3, l4, n, s0, e0, e, t;\n   tree trip, nthreads, threadid;\n-  tree type, utype;\n+  tree type;\n   basic_block entry_bb, exit_bb, body_bb, seq_start_bb, iter_part_bb;\n   basic_block trip_update_bb, cont_bb, fin_bb;\n   tree list;\n   block_stmt_iterator si;\n \n   type = TREE_TYPE (fd->v);\n-  utype = lang_hooks.types.unsigned_type (type);\n \n   entry_bb = region->entry;\n   iter_part_bb = create_empty_bb (entry_bb);\n@@ -2973,12 +2971,12 @@ expand_omp_for_static_chunk (struct omp_region *region, struct omp_for_data *fd)\n \n   t = built_in_decls[BUILT_IN_OMP_GET_NUM_THREADS];\n   t = build_function_call_expr (t, NULL);\n-  t = fold_convert (utype, t);\n+  t = fold_convert (type, t);\n   nthreads = get_formal_tmp_var (t, &list);\n   \n   t = built_in_decls[BUILT_IN_OMP_GET_THREAD_NUM];\n   t = build_function_call_expr (t, NULL);\n-  t = fold_convert (utype, t);\n+  t = fold_convert (type, t);\n   threadid = get_formal_tmp_var (t, &list);\n \n   fd->n1 = fold_convert (type, fd->n1);\n@@ -2993,7 +2991,7 @@ expand_omp_for_static_chunk (struct omp_region *region, struct omp_for_data *fd)\n   if (!is_gimple_val (fd->step))\n     fd->step = get_formal_tmp_var (fd->step, &list);\n \n-  fd->chunk_size = fold_convert (utype, fd->chunk_size);\n+  fd->chunk_size = fold_convert (type, fd->chunk_size);\n   if (!is_gimple_val (fd->chunk_size))\n     fd->chunk_size = get_formal_tmp_var (fd->chunk_size, &list);\n \n@@ -3002,13 +3000,13 @@ expand_omp_for_static_chunk (struct omp_region *region, struct omp_for_data *fd)\n   t = fold_build2 (PLUS_EXPR, type, t, fd->n2);\n   t = fold_build2 (MINUS_EXPR, type, t, fd->n1);\n   t = fold_build2 (TRUNC_DIV_EXPR, type, t, fd->step);\n-  t = fold_convert (utype, t);\n+  t = fold_convert (type, t);\n   if (is_gimple_val (t))\n     n = t;\n   else\n     n = get_formal_tmp_var (t, &list);\n \n-  t = build_int_cst (utype, 0);\n+  t = build_int_cst (type, 0);\n   trip = get_initialized_tmp_var (t, &list, NULL);\n \n   si = bsi_last (entry_bb);\n@@ -3019,13 +3017,13 @@ expand_omp_for_static_chunk (struct omp_region *region, struct omp_for_data *fd)\n   /* Iteration space partitioning goes in ITER_PART_BB.  */\n   list = alloc_stmt_list ();\n \n-  t = build2 (MULT_EXPR, utype, trip, nthreads);\n-  t = build2 (PLUS_EXPR, utype, t, threadid);\n-  t = build2 (MULT_EXPR, utype, t, fd->chunk_size);\n+  t = build2 (MULT_EXPR, type, trip, nthreads);\n+  t = build2 (PLUS_EXPR, type, t, threadid);\n+  t = build2 (MULT_EXPR, type, t, fd->chunk_size);\n   s0 = get_formal_tmp_var (t, &list);\n \n-  t = build2 (PLUS_EXPR, utype, s0, fd->chunk_size);\n-  t = build2 (MIN_EXPR, utype, t, n);\n+  t = build2 (PLUS_EXPR, type, s0, fd->chunk_size);\n+  t = build2 (MIN_EXPR, type, t, n);\n   e0 = get_formal_tmp_var (t, &list);\n \n   t = build2 (LT_EXPR, boolean_type_node, s0, n);\n@@ -3075,8 +3073,8 @@ expand_omp_for_static_chunk (struct omp_region *region, struct omp_for_data *fd)\n   /* Trip update code goes into TRIP_UPDATE_BB.  */\n   list = alloc_stmt_list ();\n \n-  t = build_int_cst (utype, 1);\n-  t = build2 (PLUS_EXPR, utype, trip, t);\n+  t = build_int_cst (type, 1);\n+  t = build2 (PLUS_EXPR, type, trip, t);\n   t = build2 (MODIFY_EXPR, void_type_node, trip, t);\n   gimplify_and_add (t, &list);\n "}, {"sha": "7d6cce68a9834e16d94d753ec67982d3bfb92b6d", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22568cc62cabbea1eec20ef65e1da9b0caaa6f02/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22568cc62cabbea1eec20ef65e1da9b0caaa6f02/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=22568cc62cabbea1eec20ef65e1da9b0caaa6f02", "patch": "@@ -1,3 +1,12 @@\n+2006-12-04  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR libgomp/29947\n+\t* loop.c (gomp_loop_init): Make parameters signed.  Set ws->end to\n+\tstart if there shouldn't be any loop iterations.\n+\t(gomp_loop_ordered_static_start): Remove start == end test.\n+\t* testsuite/libgomp.c/pr29947-1.c: New test.\n+\t* testsuite/libgomp.c/pr29947-2.c: New test.\n+\n 2006-12-02  Eric Botcazou  <ebotcazou@libertysurf.fr>\n \n \t* configure.tgt: Force initial-exec TLS model on Linux only."}, {"sha": "58fd9a8af2837806b39b1d80cf5b0d8a4fdf1a27", "filename": "libgomp/loop.c", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22568cc62cabbea1eec20ef65e1da9b0caaa6f02/libgomp%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22568cc62cabbea1eec20ef65e1da9b0caaa6f02/libgomp%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Floop.c?ref=22568cc62cabbea1eec20ef65e1da9b0caaa6f02", "patch": "@@ -34,13 +34,14 @@\n /* Initialize the given work share construct from the given arguments.  */\n \n static inline void\n-gomp_loop_init (struct gomp_work_share *ws, unsigned long start,\n-\t\tunsigned long end, unsigned long incr,\n-\t\tenum gomp_schedule_type sched, unsigned long chunk_size)\n+gomp_loop_init (struct gomp_work_share *ws, long start, long end, long incr,\n+\t\tenum gomp_schedule_type sched, long chunk_size)\n {\n   ws->sched = sched;\n   ws->chunk_size = chunk_size;\n-  ws->end = end;\n+  /* Canonicalize loops that have zero iterations to ->next == ->end.  */\n+  ws->end = ((incr > 0 && start > end) || (incr < 0 && start < end))\n+\t    ? start : end;\n   ws->incr = incr;\n   ws->next = start;\n }\n@@ -148,9 +149,6 @@ gomp_loop_ordered_static_start (long start, long end, long incr,\n {\n   struct gomp_thread *thr = gomp_thread ();\n \n-  if (start == end)\n-    return false;\n-\n   if (gomp_work_share_start (true))\n     {\n       gomp_loop_init (thr->ts.work_share, start, end, incr,"}, {"sha": "78b40ac5ae5a9f126a65e258192858a7581949a5", "filename": "libgomp/testsuite/libgomp.c/pr29947-1.c", "status": "added", "additions": 328, "deletions": 0, "changes": 328, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22568cc62cabbea1eec20ef65e1da9b0caaa6f02/libgomp%2Ftestsuite%2Flibgomp.c%2Fpr29947-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22568cc62cabbea1eec20ef65e1da9b0caaa6f02/libgomp%2Ftestsuite%2Flibgomp.c%2Fpr29947-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fpr29947-1.c?ref=22568cc62cabbea1eec20ef65e1da9b0caaa6f02", "patch": "@@ -0,0 +1,328 @@\n+/* PR libgomp/29947 */\n+/* { dg-options \"-O2 -fopenmp\" } */\n+/* { dg-do run } */\n+\n+extern void abort (void);\n+\n+int cnt;\n+\n+void\n+test1 (long j1, long k1, long j2, long k2)\n+{\n+  long i, e = 0, c = 0;\n+#pragma omp parallel reduction (+:e,c)\n+  {\n+#pragma omp for schedule (dynamic)\n+    for (i = j1; i <= k1; ++i)\n+      {\n+\tif (i < j2 || i > k2)\n+\t  ++e;\n+\t++c;\n+      }\n+#pragma omp atomic\n+    ++cnt;\n+  }\n+  if (e || (c != j2 > k2 ? 0 : k2 - j2 + 1))\n+    abort ();\n+}\n+\n+void\n+test2 (long j1, long k1, long j2, long k2)\n+{\n+  long i, e = 0, c = 0;\n+#pragma omp parallel reduction (+:e,c)\n+  {\n+#pragma omp for schedule (dynamic)\n+    for (i = k1; i >= j1; --i)\n+      {\n+\tif (i < j2 || i > k2)\n+\t  ++e;\n+\t++c;\n+      }\n+#pragma omp atomic\n+    ++cnt;\n+  }\n+  if (e || (c != j2 > k2 ? 0 : k2 - j2 + 1))\n+    abort ();\n+}\n+\n+void\n+test3 (long j1, long k1, long j2, long k2)\n+{\n+  long i, e = 0, c = 0;\n+#pragma omp parallel reduction (+:e,c)\n+  {\n+#pragma omp for schedule (guided)\n+    for (i = j1; i <= k1; ++i)\n+      {\n+\tif (i < j2 || i > k2)\n+\t  ++e;\n+\t++c;\n+      }\n+#pragma omp atomic\n+    ++cnt;\n+  }\n+  if (e || (c != j2 > k2 ? 0 : k2 - j2 + 1))\n+    abort ();\n+}\n+\n+void\n+test4 (long j1, long k1, long j2, long k2)\n+{\n+  long i, e = 0, c = 0;\n+#pragma omp parallel reduction (+:e,c)\n+  {\n+#pragma omp for schedule (guided)\n+    for (i = k1; i >= j1; --i)\n+      {\n+\tif (i < j2 || i > k2)\n+\t  ++e;\n+\t++c;\n+      }\n+#pragma omp atomic\n+    ++cnt;\n+  }\n+  if (e || (c != j2 > k2 ? 0 : k2 - j2 + 1))\n+    abort ();\n+}\n+\n+void\n+test5 (long j1, long k1, long j2, long k2)\n+{\n+  long i, e = 0, c = 0;\n+#pragma omp parallel reduction (+:e,c)\n+  {\n+#pragma omp for schedule (dynamic) ordered\n+    for (i = j1; i <= k1; ++i)\n+      {\n+\tif (i < j2 || i > k2)\n+\t  ++e;\n+#pragma omp ordered\n+\t++c;\n+      }\n+#pragma omp atomic\n+    ++cnt;\n+  }\n+  if (e || (c != j2 > k2 ? 0 : k2 - j2 + 1))\n+    abort ();\n+}\n+\n+void\n+test6 (long j1, long k1, long j2, long k2)\n+{\n+  long i, e = 0, c = 0;\n+#pragma omp parallel reduction (+:e,c)\n+  {\n+#pragma omp for schedule (dynamic) ordered\n+    for (i = k1; i >= j1; --i)\n+      {\n+\tif (i < j2 || i > k2)\n+\t  ++e;\n+#pragma omp ordered\n+\t++c;\n+      }\n+#pragma omp atomic\n+    ++cnt;\n+  }\n+  if (e || (c != j2 > k2 ? 0 : k2 - j2 + 1))\n+    abort ();\n+}\n+\n+void\n+test7 (long j1, long k1, long j2, long k2)\n+{\n+  long i, e = 0, c = 0;\n+#pragma omp parallel reduction (+:e,c)\n+  {\n+#pragma omp for schedule (guided) ordered\n+    for (i = j1; i <= k1; ++i)\n+      {\n+\tif (i < j2 || i > k2)\n+\t  ++e;\n+#pragma omp ordered\n+\t++c;\n+      }\n+#pragma omp atomic\n+    ++cnt;\n+  }\n+  if (e || (c != j2 > k2 ? 0 : k2 - j2 + 1))\n+    abort ();\n+}\n+\n+void\n+test8 (long j1, long k1, long j2, long k2)\n+{\n+  long i, e = 0, c = 0;\n+#pragma omp parallel reduction (+:e,c)\n+  {\n+#pragma omp for schedule (guided) ordered\n+    for (i = k1; i >= j1; --i)\n+      {\n+\tif (i < j2 || i > k2)\n+\t  ++e;\n+#pragma omp ordered\n+\t++c;\n+      }\n+#pragma omp atomic\n+    ++cnt;\n+  }\n+  if (e || (c != j2 > k2 ? 0 : k2 - j2 + 1))\n+    abort ();\n+}\n+\n+void\n+test9 (long j1, long k1, long j2, long k2)\n+{\n+  long i, e = 0, c = 0;\n+#pragma omp parallel for reduction (+:e,c) schedule (dynamic)\n+  for (i = j1; i <= k1; ++i)\n+    {\n+      if (i < j2 || i > k2)\n+\t++e;\n+      ++c;\n+    }\n+  if (e || (c != j2 > k2 ? 0 : k2 - j2 + 1))\n+    abort ();\n+}\n+\n+void\n+test10 (long j1, long k1, long j2, long k2)\n+{\n+  long i, e = 0, c = 0;\n+#pragma omp parallel for reduction (+:e,c) schedule (dynamic)\n+  for (i = k1; i >= j1; --i)\n+    {\n+      if (i < j2 || i > k2)\n+\t++e;\n+      ++c;\n+    }\n+  if (e || (c != j2 > k2 ? 0 : k2 - j2 + 1))\n+    abort ();\n+}\n+\n+void\n+test11 (long j1, long k1, long j2, long k2)\n+{\n+  long i, e = 0, c = 0;\n+#pragma omp parallel for reduction (+:e,c) schedule (guided)\n+  for (i = j1; i <= k1; ++i)\n+    {\n+      if (i < j2 || i > k2)\n+\t++e;\n+      ++c;\n+    }\n+  if (e || (c != j2 > k2 ? 0 : k2 - j2 + 1))\n+    abort ();\n+}\n+\n+void\n+test12 (long j1, long k1, long j2, long k2)\n+{\n+  long i, e = 0, c = 0;\n+#pragma omp parallel for reduction (+:e,c) schedule (guided)\n+  for (i = k1; i >= j1; --i)\n+    {\n+      if (i < j2 || i > k2)\n+\t++e;\n+      ++c;\n+    }\n+  if (e || (c != j2 > k2 ? 0 : k2 - j2 + 1))\n+    abort ();\n+}\n+\n+void\n+test13 (long j1, long k1, long j2, long k2)\n+{\n+  long i, e = 0, c = 0;\n+#pragma omp parallel for reduction (+:e,c) schedule (dynamic) ordered\n+  for (i = j1; i <= k1; ++i)\n+    {\n+      if (i < j2 || i > k2)\n+\t++e;\n+#pragma omp ordered\n+      ++c;\n+    }\n+  if (e || (c != j2 > k2 ? 0 : k2 - j2 + 1))\n+    abort ();\n+}\n+\n+void\n+test14 (long j1, long k1, long j2, long k2)\n+{\n+  long i, e = 0, c = 0;\n+#pragma omp parallel for reduction (+:e,c) schedule (dynamic) ordered\n+  for (i = k1; i >= j1; --i)\n+    {\n+      if (i < j2 || i > k2)\n+\t++e;\n+#pragma omp ordered\n+      ++c;\n+    }\n+  if (e || (c != j2 > k2 ? 0 : k2 - j2 + 1))\n+    abort ();\n+}\n+\n+void\n+test15 (long j1, long k1, long j2, long k2)\n+{\n+  long i, e = 0, c = 0;\n+#pragma omp parallel for reduction (+:e,c) schedule (guided) ordered\n+  for (i = j1; i <= k1; ++i)\n+    {\n+      if (i < j2 || i > k2)\n+\t++e;\n+#pragma omp ordered\n+      ++c;\n+    }\n+  if (e || (c != j2 > k2 ? 0 : k2 - j2 + 1))\n+    abort ();\n+}\n+\n+void\n+test16 (long j1, long k1, long j2, long k2)\n+{\n+  long i, e = 0, c = 0;\n+#pragma omp parallel for reduction (+:e,c) schedule (guided) ordered\n+  for (i = k1; i >= j1; --i)\n+    {\n+      if (i < j2 || i > k2)\n+\t++e;\n+#pragma omp ordered\n+      ++c;\n+    }\n+  if (e || (c != j2 > k2 ? 0 : k2 - j2 + 1))\n+    abort ();\n+}\n+\n+int\n+__attribute__((noinline))\n+test (long j1, long k1, long j2, long k2)\n+{\n+  test1 (j1, k1, j2, k2);\n+  test2 (j1, k1, j2, k2);\n+  test3 (j1, k1, j2, k2);\n+  test4 (j1, k1, j2, k2);\n+  test5 (j1, k1, j2, k2);\n+  test6 (j1, k1, j2, k2);\n+  test7 (j1, k1, j2, k2);\n+  test8 (j1, k1, j2, k2);\n+  test9 (j1, k1, j2, k2);\n+  test10 (j1, k1, j2, k2);\n+  test11 (j1, k1, j2, k2);\n+  test12 (j1, k1, j2, k2);\n+  test13 (j1, k1, j2, k2);\n+  test14 (j1, k1, j2, k2);\n+  test15 (j1, k1, j2, k2);\n+  test16 (j1, k1, j2, k2);\n+  return cnt;\n+}\n+\n+int\n+main (void)\n+{\n+  test (1, 5, 1, 5);\n+  test (5, 5, 5, 5);\n+  test (5, 4, 5, 4);\n+  test (5, 1, 5, 1);\n+  return 0;\n+}"}, {"sha": "231cd5d272171913e69662003bcc94c3815bd520", "filename": "libgomp/testsuite/libgomp.c/pr29947-2.c", "status": "added", "additions": 328, "deletions": 0, "changes": 328, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22568cc62cabbea1eec20ef65e1da9b0caaa6f02/libgomp%2Ftestsuite%2Flibgomp.c%2Fpr29947-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22568cc62cabbea1eec20ef65e1da9b0caaa6f02/libgomp%2Ftestsuite%2Flibgomp.c%2Fpr29947-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fpr29947-2.c?ref=22568cc62cabbea1eec20ef65e1da9b0caaa6f02", "patch": "@@ -0,0 +1,328 @@\n+/* PR libgomp/29947 */\n+/* { dg-options \"-O2 -fopenmp\" } */\n+/* { dg-do run } */\n+\n+extern void abort (void);\n+\n+int cnt;\n+\n+void\n+test1 (long j1, long k1, long j2, long k2)\n+{\n+  long i, e = 0, c = 0;\n+#pragma omp parallel reduction (+:e,c)\n+  {\n+#pragma omp for schedule (static)\n+    for (i = j1; i <= k1; ++i)\n+      {\n+\tif (i < j2 || i > k2)\n+\t  ++e;\n+\t++c;\n+      }\n+#pragma omp atomic\n+    ++cnt;\n+  }\n+  if (e || (c != j2 > k2 ? 0 : k2 - j2 + 1))\n+    abort ();\n+}\n+\n+void\n+test2 (long j1, long k1, long j2, long k2)\n+{\n+  long i, e = 0, c = 0;\n+#pragma omp parallel reduction (+:e,c)\n+  {\n+#pragma omp for schedule (static)\n+    for (i = k1; i >= j1; --i)\n+      {\n+\tif (i < j2 || i > k2)\n+\t  ++e;\n+\t++c;\n+      }\n+#pragma omp atomic\n+    ++cnt;\n+  }\n+  if (e || (c != j2 > k2 ? 0 : k2 - j2 + 1))\n+    abort ();\n+}\n+\n+void\n+test3 (long j1, long k1, long j2, long k2)\n+{\n+  long i, e = 0, c = 0;\n+#pragma omp parallel reduction (+:e,c)\n+  {\n+#pragma omp for schedule (static, 1)\n+    for (i = j1; i <= k1; ++i)\n+      {\n+\tif (i < j2 || i > k2)\n+\t  ++e;\n+\t++c;\n+      }\n+#pragma omp atomic\n+    ++cnt;\n+  }\n+  if (e || (c != j2 > k2 ? 0 : k2 - j2 + 1))\n+    abort ();\n+}\n+\n+void\n+test4 (long j1, long k1, long j2, long k2)\n+{\n+  long i, e = 0, c = 0;\n+#pragma omp parallel reduction (+:e,c)\n+  {\n+#pragma omp for schedule (static, 1)\n+    for (i = k1; i >= j1; --i)\n+      {\n+\tif (i < j2 || i > k2)\n+\t  ++e;\n+\t++c;\n+      }\n+#pragma omp atomic\n+    ++cnt;\n+  }\n+  if (e || (c != j2 > k2 ? 0 : k2 - j2 + 1))\n+    abort ();\n+}\n+\n+void\n+test5 (long j1, long k1, long j2, long k2)\n+{\n+  long i, e = 0, c = 0;\n+#pragma omp parallel reduction (+:e,c)\n+  {\n+#pragma omp for schedule (static) ordered\n+    for (i = j1; i <= k1; ++i)\n+      {\n+\tif (i < j2 || i > k2)\n+\t  ++e;\n+#pragma omp ordered\n+\t++c;\n+      }\n+#pragma omp atomic\n+    ++cnt;\n+  }\n+  if (e || (c != j2 > k2 ? 0 : k2 - j2 + 1))\n+    abort ();\n+}\n+\n+void\n+test6 (long j1, long k1, long j2, long k2)\n+{\n+  long i, e = 0, c = 0;\n+#pragma omp parallel reduction (+:e,c)\n+  {\n+#pragma omp for schedule (static) ordered\n+    for (i = k1; i >= j1; --i)\n+      {\n+\tif (i < j2 || i > k2)\n+\t  ++e;\n+#pragma omp ordered\n+\t++c;\n+      }\n+#pragma omp atomic\n+    ++cnt;\n+  }\n+  if (e || (c != j2 > k2 ? 0 : k2 - j2 + 1))\n+    abort ();\n+}\n+\n+void\n+test7 (long j1, long k1, long j2, long k2)\n+{\n+  long i, e = 0, c = 0;\n+#pragma omp parallel reduction (+:e,c)\n+  {\n+#pragma omp for schedule (static, 1) ordered\n+    for (i = j1; i <= k1; ++i)\n+      {\n+\tif (i < j2 || i > k2)\n+\t  ++e;\n+#pragma omp ordered\n+\t++c;\n+      }\n+#pragma omp atomic\n+    ++cnt;\n+  }\n+  if (e || (c != j2 > k2 ? 0 : k2 - j2 + 1))\n+    abort ();\n+}\n+\n+void\n+test8 (long j1, long k1, long j2, long k2)\n+{\n+  long i, e = 0, c = 0;\n+#pragma omp parallel reduction (+:e,c)\n+  {\n+#pragma omp for schedule (static, 1) ordered\n+    for (i = k1; i >= j1; --i)\n+      {\n+\tif (i < j2 || i > k2)\n+\t  ++e;\n+#pragma omp ordered\n+\t++c;\n+      }\n+#pragma omp atomic\n+    ++cnt;\n+  }\n+  if (e || (c != j2 > k2 ? 0 : k2 - j2 + 1))\n+    abort ();\n+}\n+\n+void\n+test9 (long j1, long k1, long j2, long k2)\n+{\n+  long i, e = 0, c = 0;\n+#pragma omp parallel for reduction (+:e,c) schedule (static)\n+  for (i = j1; i <= k1; ++i)\n+    {\n+      if (i < j2 || i > k2)\n+\t++e;\n+      ++c;\n+    }\n+  if (e || (c != j2 > k2 ? 0 : k2 - j2 + 1))\n+    abort ();\n+}\n+\n+void\n+test10 (long j1, long k1, long j2, long k2)\n+{\n+  long i, e = 0, c = 0;\n+#pragma omp parallel for reduction (+:e,c) schedule (static)\n+  for (i = k1; i >= j1; --i)\n+    {\n+      if (i < j2 || i > k2)\n+\t++e;\n+      ++c;\n+    }\n+  if (e || (c != j2 > k2 ? 0 : k2 - j2 + 1))\n+    abort ();\n+}\n+\n+void\n+test11 (long j1, long k1, long j2, long k2)\n+{\n+  long i, e = 0, c = 0;\n+#pragma omp parallel for reduction (+:e,c) schedule (static, 1)\n+  for (i = j1; i <= k1; ++i)\n+    {\n+      if (i < j2 || i > k2)\n+\t++e;\n+      ++c;\n+    }\n+  if (e || (c != j2 > k2 ? 0 : k2 - j2 + 1))\n+    abort ();\n+}\n+\n+void\n+test12 (long j1, long k1, long j2, long k2)\n+{\n+  long i, e = 0, c = 0;\n+#pragma omp parallel for reduction (+:e,c) schedule (static, 1)\n+  for (i = k1; i >= j1; --i)\n+    {\n+      if (i < j2 || i > k2)\n+\t++e;\n+      ++c;\n+    }\n+  if (e || (c != j2 > k2 ? 0 : k2 - j2 + 1))\n+    abort ();\n+}\n+\n+void\n+test13 (long j1, long k1, long j2, long k2)\n+{\n+  long i, e = 0, c = 0;\n+#pragma omp parallel for reduction (+:e,c) schedule (static) ordered\n+  for (i = j1; i <= k1; ++i)\n+    {\n+      if (i < j2 || i > k2)\n+\t++e;\n+#pragma omp ordered\n+      ++c;\n+    }\n+  if (e || (c != j2 > k2 ? 0 : k2 - j2 + 1))\n+    abort ();\n+}\n+\n+void\n+test14 (long j1, long k1, long j2, long k2)\n+{\n+  long i, e = 0, c = 0;\n+#pragma omp parallel for reduction (+:e,c) schedule (static) ordered\n+  for (i = k1; i >= j1; --i)\n+    {\n+      if (i < j2 || i > k2)\n+\t++e;\n+#pragma omp ordered\n+      ++c;\n+    }\n+  if (e || (c != j2 > k2 ? 0 : k2 - j2 + 1))\n+    abort ();\n+}\n+\n+void\n+test15 (long j1, long k1, long j2, long k2)\n+{\n+  long i, e = 0, c = 0;\n+#pragma omp parallel for reduction (+:e,c) schedule (static, 1) ordered\n+  for (i = j1; i <= k1; ++i)\n+    {\n+      if (i < j2 || i > k2)\n+\t++e;\n+#pragma omp ordered\n+      ++c;\n+    }\n+  if (e || (c != j2 > k2 ? 0 : k2 - j2 + 1))\n+    abort ();\n+}\n+\n+void\n+test16 (long j1, long k1, long j2, long k2)\n+{\n+  long i, e = 0, c = 0;\n+#pragma omp parallel for reduction (+:e,c) schedule (static, 1) ordered\n+  for (i = k1; i >= j1; --i)\n+    {\n+      if (i < j2 || i > k2)\n+\t++e;\n+#pragma omp ordered\n+      ++c;\n+    }\n+  if (e || (c != j2 > k2 ? 0 : k2 - j2 + 1))\n+    abort ();\n+}\n+\n+int\n+__attribute__((noinline))\n+test (long j1, long k1, long j2, long k2)\n+{\n+  test1 (j1, k1, j2, k2);\n+  test2 (j1, k1, j2, k2);\n+  test3 (j1, k1, j2, k2);\n+  test4 (j1, k1, j2, k2);\n+  test5 (j1, k1, j2, k2);\n+  test6 (j1, k1, j2, k2);\n+  test7 (j1, k1, j2, k2);\n+  test8 (j1, k1, j2, k2);\n+  test9 (j1, k1, j2, k2);\n+  test10 (j1, k1, j2, k2);\n+  test11 (j1, k1, j2, k2);\n+  test12 (j1, k1, j2, k2);\n+  test13 (j1, k1, j2, k2);\n+  test14 (j1, k1, j2, k2);\n+  test15 (j1, k1, j2, k2);\n+  test16 (j1, k1, j2, k2);\n+  return cnt;\n+}\n+\n+int\n+main (void)\n+{\n+  test (1, 5, 1, 5);\n+  test (5, 5, 5, 5);\n+  test (5, 4, 5, 4);\n+  test (5, 1, 5, 1);\n+  return 0;\n+}"}]}