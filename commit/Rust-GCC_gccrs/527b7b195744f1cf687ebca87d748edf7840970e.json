{"sha": "527b7b195744f1cf687ebca87d748edf7840970e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTI3YjdiMTk1NzQ0ZjFjZjY4N2ViY2E4N2Q3NDhlZGY3ODQwOTcwZQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2017-09-06T11:17:54Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2017-09-06T11:17:54Z"}, "message": "name-lookup.h (lookup_fnfields_slot_nolazy, [...]): Rename to ...\n\n\t* name-lookup.h (lookup_fnfields_slot_nolazy,\n\tlookup_fnfields_slot): Rename to ...\n\t(get_class_binding_direct, get_class_binding): ... here.\n\t* name-lookup.c (lookup_fnfields_slot_nolazy,\n\tlookup_fnfields_slot): Rename to ...\n\t(get_class_binding_direct, get_class_binding): ... here.\n\t* cp-tree.h (CLASSTYPE_CONSTRUCTORS, CLASSTYPE_DESTRUCTOR): Adjust.\n\t* call.c (build_user_type_conversion_1): Adjust.\n\t(has_trivial_copy_assign_p): Adjust.\n\t(has_trivial_copy_p): Adjust.\n\t* class.c (get_basefndecls) Adjust.\n\t(vbase_has_user_provided_move_assign) Adjust.\n\t(classtype_has_move_assign_or_move_ctor_p): Adjust.\n\t(type_build_ctor_call, type_build_dtor_call): Adjust.\n\t* decl.c (register_dtor_fn): Adjust.\n\t* decl2.c (check_classfn): Adjust.\n\t* pt.c (retrieve_specialization): Adjust.\n\t(check_explicit_specialization): Adjust.\n\t(do_class_deduction): Adjust.\n\t* search.c (lookup_field_r): Adjust.\n\t(look_for_overrides_here, lookup_conversions_r): Adjust.\n\t* semantics.c (classtype_has_nothrow_assign_or_copy_p): Adjust.\n\t* tree.c (type_has_nontrivial_copy_init): Adjust.\n\t* method.c (lazily_declare_fn): Adjust comment.\n\nFrom-SVN: r251780", "tree": {"sha": "bacd9c22d85bd36b8a497d12f60d0d0ea8e16a15", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bacd9c22d85bd36b8a497d12f60d0d0ea8e16a15"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/527b7b195744f1cf687ebca87d748edf7840970e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/527b7b195744f1cf687ebca87d748edf7840970e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/527b7b195744f1cf687ebca87d748edf7840970e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/527b7b195744f1cf687ebca87d748edf7840970e/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b276ab7a45afb2181df553fcf064d1fc80a1a450", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b276ab7a45afb2181df553fcf064d1fc80a1a450", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b276ab7a45afb2181df553fcf064d1fc80a1a450"}], "stats": {"total": 133, "additions": 74, "deletions": 59}, "files": [{"sha": "b9fab9153a9b47ce7a3249bda8ad0a3d1787694d", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/527b7b195744f1cf687ebca87d748edf7840970e/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/527b7b195744f1cf687ebca87d748edf7840970e/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=527b7b195744f1cf687ebca87d748edf7840970e", "patch": "@@ -1,3 +1,30 @@\n+2017-09-06  Nathan Sidwell  <nathan@acm.org>\n+\n+\t* name-lookup.h (lookup_fnfields_slot_nolazy,\n+\tlookup_fnfields_slot): Rename to ...\n+\t(get_class_binding_direct, get_class_binding): ... here.\n+\t* name-lookup.c (lookup_fnfields_slot_nolazy,\n+\tlookup_fnfields_slot): Rename to ...\n+\t(get_class_binding_direct, get_class_binding): ... here.\n+\t* cp-tree.h (CLASSTYPE_CONSTRUCTORS, CLASSTYPE_DESTRUCTOR): Adjust.\n+\t* call.c (build_user_type_conversion_1): Adjust.\n+\t(has_trivial_copy_assign_p): Adjust.\n+\t(has_trivial_copy_p): Adjust.\n+\t* class.c (get_basefndecls) Adjust.\n+\t(vbase_has_user_provided_move_assign) Adjust.\n+\t(classtype_has_move_assign_or_move_ctor_p): Adjust.\n+\t(type_build_ctor_call, type_build_dtor_call): Adjust.\n+\t* decl.c (register_dtor_fn): Adjust.\n+\t* decl2.c (check_classfn): Adjust.\n+\t* pt.c (retrieve_specialization): Adjust.\n+\t(check_explicit_specialization): Adjust.\n+\t(do_class_deduction): Adjust.\n+\t* search.c (lookup_field_r): Adjust.\n+\t(look_for_overrides_here, lookup_conversions_r): Adjust.\n+\t* semantics.c (classtype_has_nothrow_assign_or_copy_p): Adjust.\n+\t* tree.c (type_has_nontrivial_copy_init): Adjust.\n+\t* method.c (lazily_declare_fn): Adjust comment.\n+\n 2017-09-05  Nathan Sidwell  <nathan@acm.org>\n \n \t* name-lookup.c (do_class_using_decl): Elide read-once temps."}, {"sha": "88af0d31446d511f49c407c0017dd33d2fe84d26", "filename": "gcc/cp/call.c", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/527b7b195744f1cf687ebca87d748edf7840970e/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/527b7b195744f1cf687ebca87d748edf7840970e/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=527b7b195744f1cf687ebca87d748edf7840970e", "patch": "@@ -3738,7 +3738,7 @@ build_user_type_conversion_1 (tree totype, tree expr, int flags,\n   if (CLASS_TYPE_P (totype))\n     /* Use lookup_fnfields_slot instead of lookup_fnfields to avoid\n        creating a garbage BASELINK; constructors can't be inherited.  */\n-    ctors = lookup_fnfields_slot (totype, complete_ctor_identifier);\n+    ctors = get_class_binding (totype, complete_ctor_identifier);\n \n   /* FIXME P0135 doesn't say what to do in C++17 about list-initialization from\n      a single element.  For now, let's handle constructors as before and also\n@@ -8243,9 +8243,7 @@ first_non_public_field (tree type)\n static bool\n has_trivial_copy_assign_p (tree type, bool access, bool *hasassign)\n {\n-  tree fns = cp_assignment_operator_id (NOP_EXPR);\n-  fns = lookup_fnfields_slot (type, fns);\n-\n+  tree fns = get_class_binding (type, cp_assignment_operator_id (NOP_EXPR));\n   bool all_trivial = true;\n \n   /* Iterate over overloads of the assignment operator, checking\n@@ -8294,8 +8292,7 @@ has_trivial_copy_assign_p (tree type, bool access, bool *hasassign)\n static bool\n has_trivial_copy_p (tree type, bool access, bool hasctor[2])\n {\n-  tree fns = lookup_fnfields_slot (type, complete_ctor_identifier);\n-\n+  tree fns = get_class_binding (type, complete_ctor_identifier);\n   bool all_trivial = true;\n \n   for (ovl_iterator oi (fns); oi; ++oi)"}, {"sha": "908edc4f4902563099ef839a37ca1758ac12e1b6", "filename": "gcc/cp/class.c", "status": "modified", "additions": 10, "deletions": 15, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/527b7b195744f1cf687ebca87d748edf7840970e/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/527b7b195744f1cf687ebca87d748edf7840970e/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=527b7b195744f1cf687ebca87d748edf7840970e", "patch": "@@ -2745,7 +2745,7 @@ get_basefndecls (tree name, tree t, vec<tree> *base_fndecls)\n   bool found_decls = false;\n \n   /* Find virtual functions in T with the indicated NAME.  */\n-  for (ovl_iterator iter (lookup_fnfields_slot (t, name)); iter; ++iter)\n+  for (ovl_iterator iter (get_class_binding (t, name)); iter; ++iter)\n     {\n       tree method = *iter;\n \n@@ -5034,14 +5034,12 @@ bool\n vbase_has_user_provided_move_assign (tree type)\n {\n   /* Does the type itself have a user-provided move assignment operator?  */\n-  for (ovl_iterator iter (lookup_fnfields_slot_nolazy\n-\t\t\t  (type, cp_assignment_operator_id (NOP_EXPR)));\n-       iter; ++iter)\n-    {\n-      tree fn = *iter;\n-      if (move_fn_p (fn) && user_provided_p (fn))\n+  if (!CLASSTYPE_LAZY_MOVE_ASSIGN (type))\n+    for (ovl_iterator iter (get_class_binding_direct\n+\t\t\t    (type, cp_assignment_operator_id (NOP_EXPR)));\n+\t iter; ++iter)\n+      if (!DECL_ARTIFICIAL (*iter) && move_fn_p (*iter))\n \treturn true;\n-    }\n \n   /* Do any of its bases?  */\n   tree binfo = TYPE_BINFO (type);\n@@ -5180,13 +5178,12 @@ classtype_has_move_assign_or_move_ctor_p (tree t, bool user_p)\n \t\t  && !CLASSTYPE_LAZY_MOVE_ASSIGN (t)));\n \n   if (!CLASSTYPE_LAZY_MOVE_CTOR (t))\n-    for (ovl_iterator iter (lookup_fnfields_slot_nolazy (t, ctor_identifier));\n-\t iter; ++iter)\n+    for (ovl_iterator iter (CLASSTYPE_CONSTRUCTORS (t)); iter; ++iter)\n       if ((!user_p || !DECL_ARTIFICIAL (*iter)) && move_fn_p (*iter))\n \treturn true;\n \n   if (!CLASSTYPE_LAZY_MOVE_ASSIGN (t))\n-    for (ovl_iterator iter (lookup_fnfields_slot_nolazy\n+    for (ovl_iterator iter (get_class_binding_direct\n \t\t\t    (t, cp_assignment_operator_id (NOP_EXPR)));\n \t iter; ++iter)\n       if ((!user_p || !DECL_ARTIFICIAL (*iter)) && move_fn_p (*iter))\n@@ -5220,8 +5217,7 @@ type_build_ctor_call (tree t)\n     return false;\n   /* A user-declared constructor might be private, and a constructor might\n      be trivial but deleted.  */\n-  for (ovl_iterator iter\n-\t (lookup_fnfields_slot (inner, complete_ctor_identifier));\n+  for (ovl_iterator iter (get_class_binding (inner, complete_ctor_identifier));\n        iter; ++iter)\n     {\n       tree fn = *iter;\n@@ -5248,8 +5244,7 @@ type_build_dtor_call (tree t)\n     return false;\n   /* A user-declared destructor might be private, and a destructor might\n      be trivial but deleted.  */\n-  for (ovl_iterator iter\n-\t (lookup_fnfields_slot (inner, complete_dtor_identifier));\n+  for (ovl_iterator iter (get_class_binding (inner, complete_dtor_identifier));\n        iter; ++iter)\n     {\n       tree fn = *iter;"}, {"sha": "20fa03915c55c05626b730b6e30f7cfdb2f04deb", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/527b7b195744f1cf687ebca87d748edf7840970e/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/527b7b195744f1cf687ebca87d748edf7840970e/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=527b7b195744f1cf687ebca87d748edf7840970e", "patch": "@@ -216,7 +216,7 @@ extern GTY(()) tree cp_global_trees[CPTI_MAX];\n    example:\n \n      tree ovlid = cp_assignment_operator_id (NOP_EXPR);\n-     tree overloads = lookup_fnfields_slot (type, ovlid);\n+     tree overloads = get_class_binding (type, ovlid);\n      for (ovl_iterator it (overloads); it; ++it) { ... }\n \n    iterates over the set of implicitly and explicitly defined overloads\n@@ -2152,14 +2152,14 @@ struct GTY(()) lang_type {\n /* A FUNCTION_DECL or OVERLOAD for the constructors for NODE.  These\n    are the constructors that take an in-charge parameter.  */\n #define CLASSTYPE_CONSTRUCTORS(NODE) \\\n-  (lookup_fnfields_slot_nolazy (NODE, ctor_identifier))\n+  (get_class_binding_direct (NODE, ctor_identifier))\n \n /* A FUNCTION_DECL for the destructor for NODE.  This is the\n    destructors that take an in-charge parameter.  If\n    CLASSTYPE_LAZY_DESTRUCTOR is true, then this entry will be NULL\n    until the destructor is created with lazily_declare_fn.  */\n #define CLASSTYPE_DESTRUCTOR(NODE) \\\n-  (lookup_fnfields_slot_nolazy (NODE, dtor_identifier))\n+  (get_class_binding_direct (NODE, dtor_identifier))\n \n /* A dictionary of the nested user-defined-types (class-types, or enums)\n    found within this class.  This table includes nested member class"}, {"sha": "655445b9c8e110d0a9cd1a24835912ab71fe4741", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/527b7b195744f1cf687ebca87d748edf7840970e/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/527b7b195744f1cf687ebca87d748edf7840970e/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=527b7b195744f1cf687ebca87d748edf7840970e", "patch": "@@ -7857,7 +7857,7 @@ register_dtor_fn (tree decl)\n   use_dtor = ob_parm && CLASS_TYPE_P (type);\n   if (use_dtor)\n     {\n-      cleanup = lookup_fnfields_slot (type, complete_dtor_identifier);\n+      cleanup = get_class_binding (type, complete_dtor_identifier);\n \n       /* Make sure it is accessible.  */\n       perform_or_defer_access_check (TYPE_BINFO (type), cleanup, cleanup,"}, {"sha": "d950a851cb9fc7708519bfe4239ff1890d5a6fb2", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/527b7b195744f1cf687ebca87d748edf7840970e/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/527b7b195744f1cf687ebca87d748edf7840970e/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=527b7b195744f1cf687ebca87d748edf7840970e", "patch": "@@ -606,7 +606,7 @@ check_classfn (tree ctype, tree function, tree template_parms)\n      resolving within the scope of CTYPE.  */\n   tree pushed_scope = push_scope (ctype);\n   tree matched = NULL_TREE;\n-  tree fns = lookup_fnfields_slot (ctype, DECL_NAME (function));\n+  tree fns = get_class_binding (ctype, DECL_NAME (function));\n   \n   for (ovl_iterator iter (fns); !matched && iter; ++iter)\n     {\n@@ -664,7 +664,7 @@ check_classfn (tree ctype, tree function, tree template_parms)\n       else\n \t{\n \t  if (DECL_CONV_FN_P (function))\n-\t    fns = lookup_fnfields_slot (ctype, conv_op_identifier);\n+\t    fns = get_class_binding (ctype, conv_op_identifier);\n \n \t  error_at (DECL_SOURCE_LOCATION (function),\n \t\t    \"no declaration matches %q#D\", function);"}, {"sha": "b83a6f2d10dd2ba851a4a9225e2f77088baf67b0", "filename": "gcc/cp/method.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/527b7b195744f1cf687ebca87d748edf7840970e/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/527b7b195744f1cf687ebca87d748edf7840970e/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=527b7b195744f1cf687ebca87d748edf7840970e", "patch": "@@ -2408,7 +2408,7 @@ lazily_declare_fn (special_function_kind sfk, tree type)\n       || sfk == sfk_copy_assignment)\n     check_for_override (fn, type);\n \n-  /* Add it to CLASSTYPE_METHOD_VEC.  */\n+  /* Add it to the class  */\n   bool added = add_method (type, fn, false);\n   gcc_assert (added);\n "}, {"sha": "81635fffdcf0a581abe3eb78ac60645364ab6342", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/527b7b195744f1cf687ebca87d748edf7840970e/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/527b7b195744f1cf687ebca87d748edf7840970e/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=527b7b195744f1cf687ebca87d748edf7840970e", "patch": "@@ -1118,7 +1118,7 @@ extract_conversion_operator (tree fns, tree type)\n    member functions.  */\n \n tree\n-lookup_fnfields_slot_nolazy (tree type, tree name)\n+get_class_binding_direct (tree type, tree name)\n {\n   vec<tree, va_gc> *method_vec = CLASSTYPE_METHOD_VEC (type);\n   if (!method_vec)\n@@ -1285,7 +1285,7 @@ lookup_field_1 (tree type, tree name, bool want_type)\n    the method vector with name NAME.  Lazily create ctors etc.  */\n \n tree\n-lookup_fnfields_slot (tree type, tree name)\n+get_class_binding (tree type, tree name)\n {\n   type = complete_type (type);\n \n@@ -1314,7 +1314,7 @@ lookup_fnfields_slot (tree type, tree name)\n \t}\n     }\n \n-  return lookup_fnfields_slot_nolazy (type, name);\n+  return get_class_binding_direct (type, name);\n }\n \n /* Find the slot containing overloads called 'NAME'.  If there is no"}, {"sha": "0051bfcced9369ec1c0b6eea7bc75dbd40d25711", "filename": "gcc/cp/name-lookup.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/527b7b195744f1cf687ebca87d748edf7840970e/gcc%2Fcp%2Fname-lookup.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/527b7b195744f1cf687ebca87d748edf7840970e/gcc%2Fcp%2Fname-lookup.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.h?ref=527b7b195744f1cf687ebca87d748edf7840970e", "patch": "@@ -320,8 +320,8 @@ extern void do_namespace_alias (tree, tree);\n extern tree do_class_using_decl (tree, tree);\n extern tree lookup_arg_dependent (tree, tree, vec<tree, va_gc> *);\n extern tree lookup_field_1\t\t\t(tree, tree, bool);\n-extern tree lookup_fnfields_slot\t\t(tree, tree);\n-extern tree lookup_fnfields_slot_nolazy\t\t(tree, tree);\n+extern tree get_class_binding_direct (tree, tree);\n+extern tree get_class_binding (tree, tree);\n extern tree *get_method_slot (tree klass, tree name);\n extern void resort_type_method_vec (void *, void *,\n \t\t\t\t    gt_pointer_operator, void *);"}, {"sha": "eb27f6a040286537bf2febff8872d7993bfee37e", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 14, "deletions": 17, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/527b7b195744f1cf687ebca87d748edf7840970e/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/527b7b195744f1cf687ebca87d748edf7840970e/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=527b7b195744f1cf687ebca87d748edf7840970e", "patch": "@@ -1216,7 +1216,7 @@ retrieve_specialization (tree tmpl, tree args, hashval_t hash)\n \treturn NULL_TREE;\n \n       /* Find the instance of TMPL.  */\n-      tree fns = lookup_fnfields_slot (class_specialization, DECL_NAME (tmpl));\n+      tree fns = get_class_binding (class_specialization, DECL_NAME (tmpl));\n       for (ovl_iterator iter (fns); iter; ++iter)\n \t{\n \t  tree fn = *iter;\n@@ -2915,9 +2915,8 @@ check_explicit_specialization (tree declarator,\n \t     `operator int' which will be a specialization of\n \t     `operator T'.  Grab all the conversion operators, and\n \t     then select from them.  */\n-\t  tree fns = lookup_fnfields_slot_nolazy (ctype,\n-\t\t\t\t\t\t  IDENTIFIER_CONV_OP_P (name)\n-\t\t\t\t\t\t  ? conv_op_identifier : name);\n+\t  tree fns = get_class_binding (ctype, IDENTIFIER_CONV_OP_P (name)\n+\t\t\t\t      ? conv_op_identifier : name);\n \n \t  if (fns == NULL_TREE)\n \t    {\n@@ -25648,20 +25647,18 @@ do_class_deduction (tree ptype, tree tmpl, tree init, int flags,\n     }\n \n   bool saw_ctor = false;\n-  if (CLASSTYPE_METHOD_VEC (type))\n-    // FIXME cache artificial deduction guides\n-    for (ovl_iterator iter (CLASSTYPE_CONSTRUCTORS (type));\n-\t iter; ++iter)\n-      {\n-\ttree guide = build_deduction_guide (*iter, outer_args, complain);\n-\tif ((flags & LOOKUP_ONLYCONVERTING)\n-\t    && DECL_NONCONVERTING_P (STRIP_TEMPLATE (guide)))\n-\t  elided = true;\n-\telse\n-\t  cands = lookup_add (guide, cands);\n+  // FIXME cache artificial deduction guides\n+  for (ovl_iterator iter (CLASSTYPE_CONSTRUCTORS (type)); iter; ++iter)\n+    {\n+      tree guide = build_deduction_guide (*iter, outer_args, complain);\n+      if ((flags & LOOKUP_ONLYCONVERTING)\n+\t  && DECL_NONCONVERTING_P (STRIP_TEMPLATE (guide)))\n+\telided = true;\n+      else\n+\tcands = lookup_add (guide, cands);\n \n-\tsaw_ctor = true;\n-      }\n+      saw_ctor = true;\n+    }\n \n   tree call = error_mark_node;\n "}, {"sha": "38be467b7c6fc555541a78a9db0a85f82b434688", "filename": "gcc/cp/search.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/527b7b195744f1cf687ebca87d748edf7840970e/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/527b7b195744f1cf687ebca87d748edf7840970e/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=527b7b195744f1cf687ebca87d748edf7840970e", "patch": "@@ -978,7 +978,7 @@ lookup_field_r (tree binfo, void *data)\n      member with the same name, and if there's a function and a type\n      with the same name, the type is hidden by the function.  */\n   if (!lfi->want_type)\n-    nval = lookup_fnfields_slot (type, lfi->name);\n+    nval = get_class_binding (type, lfi->name);\n \n   if (!nval)\n     /* Look for a data member or type.  */\n@@ -2048,7 +2048,7 @@ look_for_overrides (tree type, tree fndecl)\n tree\n look_for_overrides_here (tree type, tree fndecl)\n {\n-  tree ovl = lookup_fnfields_slot (type, DECL_NAME (fndecl));\n+  tree ovl = get_class_binding (type, DECL_NAME (fndecl));\n \n   for (ovl_iterator iter (ovl); iter; ++iter)\n     {\n@@ -2370,8 +2370,7 @@ lookup_conversions_r (tree binfo, int virtual_depth, int virtualness,\n     virtual_depth++;\n \n   /* First, locate the unhidden ones at this level.  */\n-  tree conv = lookup_fnfields_slot_nolazy (BINFO_TYPE (binfo),\n-\t\t\t\t\t   conv_op_identifier);\n+  if (tree conv = get_class_binding (BINFO_TYPE (binfo), conv_op_identifier))\n   for (ovl_iterator iter (conv); iter; ++iter)\n     {\n       tree fn = *iter;"}, {"sha": "4f4c17f853d5f5c86eaebd86a34f24a332e923f7", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/527b7b195744f1cf687ebca87d748edf7840970e/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/527b7b195744f1cf687ebca87d748edf7840970e/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=527b7b195744f1cf687ebca87d748edf7840970e", "patch": "@@ -9009,10 +9009,10 @@ classtype_has_nothrow_assign_or_copy_p (tree type, bool assign_p)\n {\n   tree fns = NULL_TREE;\n \n-  if (assign_p)\n-    fns = lookup_fnfields_slot (type, cp_assignment_operator_id (NOP_EXPR));\n-  else if (TYPE_HAS_COPY_CTOR (type))\n-    fns = lookup_fnfields_slot (type, ctor_identifier);\n+  if (assign_p || TYPE_HAS_COPY_CTOR (type))\n+    fns = get_class_binding (type,\n+\t\t\t     assign_p ? cp_assignment_operator_id (NOP_EXPR)\n+\t\t\t     : ctor_identifier);\n \n   bool saw_copy = false;\n   for (ovl_iterator iter (fns); iter; ++iter)"}, {"sha": "12c31fb83420534d1083b9684ea7b249a1f5bac3", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/527b7b195744f1cf687ebca87d748edf7840970e/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/527b7b195744f1cf687ebca87d748edf7840970e/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=527b7b195744f1cf687ebca87d748edf7840970e", "patch": "@@ -3988,7 +3988,7 @@ type_has_nontrivial_copy_init (const_tree type)\n \t    saw_non_deleted = true;\n \t}\n \n-      if (!saw_non_deleted && CLASSTYPE_METHOD_VEC (t))\n+      if (!saw_non_deleted)\n \tfor (ovl_iterator iter (CLASSTYPE_CONSTRUCTORS (t)); iter; ++iter)\n \t  {\n \t    tree fn = *iter;"}]}