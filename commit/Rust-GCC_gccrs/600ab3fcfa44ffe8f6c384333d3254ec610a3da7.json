{"sha": "600ab3fcfa44ffe8f6c384333d3254ec610a3da7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjAwYWIzZmNmYTQ0ZmZlOGY2YzM4NDMzM2QzMjU0ZWM2MTBhM2RhNw==", "commit": {"author": {"name": "Richard Sandiford", "email": "rdsandiford@googlemail.com", "date": "2010-06-10T20:23:13Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2010-06-10T20:23:13Z"}, "message": "Makefile.in (build/genmddeps.o): Depend on $(READ_MD_H).\n\ngcc/\n\t* Makefile.in (build/genmddeps.o): Depend on $(READ_MD_H).\n\t* genmddeps.c: Include read-md.h.\n\t(main): Call init_rtx_reader_args instead of init_md_reader_args.\n\t* genattr.c (main): Likewise.\n\t* genattrtab.c (main): Likewise.\n\t* genautomata.c (main): Likewise.\n\t* gencodes.c (main): Likewise.\n\t* genconditions.c (main): Likewise.\n\t* genconfig.c (main): Likewise.\n\t* genconstants.c (main): Likewise.\n\t* genemit.c (main): Likewise.\n\t* genextract.c (main): Likewise.\n\t* genflags.c (main): Likewise.\n\t* genopinit.c (main): Likewise.\n\t* genoutput.c (main): Likewise.\n\t* genpeep.c (main): Likewise.\n\t* genrecog.c (main): Likewise.\n\t* genpreds.c (main): Likewise.\n\t* gensupport.h (in_fname): Move to read-md.h.\n\t(init_md_reader_args_cb): Rename to...\n\t(init_rtx_reader_args_cb): ...this and return a bool.\n\t(init_md_reader_args): Rename to...\n\t(init_rtx_reader_args): ...this and return a bool.\n\t(include_callback): Move to read-md.h.\n\t* gensupport.c (in_fname, include_callback, base_dir, max_include_len)\n\t(file_name_list, first_dir_md_include): Move to read-md.c\n\t(first_bracket_include): Delete unused variable.\n\t(last_dir_md_include): Move to read-md.c.\n\t(process_include): Delete, moving code to read-md.c:handle_include.\n\t(process_rtx): Don't handle INCLUDE.\n\t(save_string): Delete.\n\t(rtx_handle_directive): New function.\n\t(init_md_reader_args_cb): Rename to...\n\t(init_rtx_reader_args_cb): ...this and return a boolean success value.\n\tUse read_md_args.\n\t(init_md_reader_args): Rename to...\n\t(init_rtx_reader_args): ...this and return a boolean success value.\n\t* rtl.def (INCLUDE): Delete.\n\t* rtl.h (read_rtx): Remove \"int *\" argument.  Add \"const char *\"\n\targument.\n\t* read-rtl.c (read_conditions): Don't gobble ')' here.\n\t(read_mapping): Likewise.\n\t(read_rtx): Remove LINENO argument.  Add RTX_NAME argument.\n\tHandle top-level non-rtx constructs here rather than in read_rtx_1.\n\tStore the whole queue in *X.  Remove call to init_md_reader.\n\t(read_rtx_1): Rename to...\n\t(read_rtx_code): ...this.  Call read_nested_rtx to read subrtxes.\n\tDon't handle top-level non-rtx constructs here.  Don't handle (nil)\n\there.\n\t(read_nested_rtx): New function.  Handle (nil) here rather than\n\tin read_rtx_code.\n\t(read_rtx_variadic): Call read_nested_rtx to read subrtxes.  Don't\n\tgobble ')' here.\n\t* read-md.h (directive_handler_t): New type.\n\t(in_fname, include_callback): Moved from read-md.h.\n\t(read_constants, init_md_reader): Delete.\n\t(read_md_files): Declare.\n\t* read-md.c (file_name_list, in_fname, base_dir, first_dir_md_include)\n\t(last_dir_md_include_ptr, include_callback, max_include_len): Moved\n\tfrom gensupport.c.\n\t(read_constants): Rename to...\n\t(handle_constants): ...this.  Don't gobble ')' here.\n\t(handle_include, handle_file, handle_toplevel_file)\n\t(parse_include): New functions, mostly taken from gensupport.c.\n\t(init_md_reader): Subsume into...\n\t(read_md_files): ...this new function.\n\nFrom-SVN: r160577", "tree": {"sha": "ddccdb1d54755ea510a879f9da33552415587e38", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ddccdb1d54755ea510a879f9da33552415587e38"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/600ab3fcfa44ffe8f6c384333d3254ec610a3da7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/600ab3fcfa44ffe8f6c384333d3254ec610a3da7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/600ab3fcfa44ffe8f6c384333d3254ec610a3da7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/600ab3fcfa44ffe8f6c384333d3254ec610a3da7/comments", "author": {"login": "rsandifo", "id": 4235983, "node_id": "MDQ6VXNlcjQyMzU5ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4235983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo", "html_url": "https://github.com/rsandifo", "followers_url": "https://api.github.com/users/rsandifo/followers", "following_url": "https://api.github.com/users/rsandifo/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo/orgs", "repos_url": "https://api.github.com/users/rsandifo/repos", "events_url": "https://api.github.com/users/rsandifo/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7f7c467fed603c8ad387e731d99ad889e7f2a501", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f7c467fed603c8ad387e731d99ad889e7f2a501", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7f7c467fed603c8ad387e731d99ad889e7f2a501"}], "stats": {"total": 898, "additions": 490, "deletions": 408}, "files": [{"sha": "e697a5293874c0bbe7daf880da56107521735fac", "filename": "gcc/ChangeLog", "status": "modified", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600ab3fcfa44ffe8f6c384333d3254ec610a3da7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600ab3fcfa44ffe8f6c384333d3254ec610a3da7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=600ab3fcfa44ffe8f6c384333d3254ec610a3da7", "patch": "@@ -1,3 +1,72 @@\n+2010-06-10  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* Makefile.in (build/genmddeps.o): Depend on $(READ_MD_H).\n+\t* genmddeps.c: Include read-md.h.\n+\t(main): Call init_rtx_reader_args instead of init_md_reader_args.\n+\t* genattr.c (main): Likewise.\n+\t* genattrtab.c (main): Likewise.\n+\t* genautomata.c (main): Likewise.\n+\t* gencodes.c (main): Likewise.\n+\t* genconditions.c (main): Likewise.\n+\t* genconfig.c (main): Likewise.\n+\t* genconstants.c (main): Likewise.\n+\t* genemit.c (main): Likewise.\n+\t* genextract.c (main): Likewise.\n+\t* genflags.c (main): Likewise.\n+\t* genopinit.c (main): Likewise.\n+\t* genoutput.c (main): Likewise.\n+\t* genpeep.c (main): Likewise.\n+\t* genrecog.c (main): Likewise.\n+\t* genpreds.c (main): Likewise.\n+\t* gensupport.h (in_fname): Move to read-md.h.\n+\t(init_md_reader_args_cb): Rename to...\n+\t(init_rtx_reader_args_cb): ...this and return a bool.\n+\t(init_md_reader_args): Rename to...\n+\t(init_rtx_reader_args): ...this and return a bool.\n+\t(include_callback): Move to read-md.h.\n+\t* gensupport.c (in_fname, include_callback, base_dir, max_include_len)\n+\t(file_name_list, first_dir_md_include): Move to read-md.c\n+\t(first_bracket_include): Delete unused variable.\n+\t(last_dir_md_include): Move to read-md.c.\n+\t(process_include): Delete, moving code to read-md.c:handle_include.\n+\t(process_rtx): Don't handle INCLUDE.\n+\t(save_string): Delete.\n+\t(rtx_handle_directive): New function.\n+\t(init_md_reader_args_cb): Rename to...\n+\t(init_rtx_reader_args_cb): ...this and return a boolean success value.\n+\tUse read_md_args.\n+\t(init_md_reader_args): Rename to...\n+\t(init_rtx_reader_args): ...this and return a boolean success value.\n+\t* rtl.def (INCLUDE): Delete.\n+\t* rtl.h (read_rtx): Remove \"int *\" argument.  Add \"const char *\"\n+\targument.\n+\t* read-rtl.c (read_conditions): Don't gobble ')' here.\n+\t(read_mapping): Likewise.\n+\t(read_rtx): Remove LINENO argument.  Add RTX_NAME argument.\n+\tHandle top-level non-rtx constructs here rather than in read_rtx_1.\n+\tStore the whole queue in *X.  Remove call to init_md_reader.\n+\t(read_rtx_1): Rename to...\n+\t(read_rtx_code): ...this.  Call read_nested_rtx to read subrtxes.\n+\tDon't handle top-level non-rtx constructs here.  Don't handle (nil)\n+\there.\n+\t(read_nested_rtx): New function.  Handle (nil) here rather than\n+\tin read_rtx_code.\n+\t(read_rtx_variadic): Call read_nested_rtx to read subrtxes.  Don't\n+\tgobble ')' here.\n+\t* read-md.h (directive_handler_t): New type.\n+\t(in_fname, include_callback): Moved from read-md.h.\n+\t(read_constants, init_md_reader): Delete.\n+\t(read_md_files): Declare.\n+\t* read-md.c (file_name_list, in_fname, base_dir, first_dir_md_include)\n+\t(last_dir_md_include_ptr, include_callback, max_include_len): Moved\n+\tfrom gensupport.c.\n+\t(read_constants): Rename to...\n+\t(handle_constants): ...this.  Don't gobble ')' here.\n+\t(handle_include, handle_file, handle_toplevel_file)\n+\t(parse_include): New functions, mostly taken from gensupport.c.\n+\t(init_md_reader): Subsume into...\n+\t(read_md_files): ...this new function.\n+\n 2010-06-10  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \t* read-md.h (read_char): Increment read_md_lineno after reading '\\n'."}, {"sha": "84f332ff5972ba6795815e0ebaf5974b389d2428", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600ab3fcfa44ffe8f6c384333d3254ec610a3da7/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600ab3fcfa44ffe8f6c384333d3254ec610a3da7/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=600ab3fcfa44ffe8f6c384333d3254ec610a3da7", "patch": "@@ -3829,7 +3829,7 @@ build/gengtype-parse.o : gengtype-parse.c gengtype.h $(BCONFIG_H)\t\\\n build/gengtype.o : gengtype.c $(BCONFIG_H) $(SYSTEM_H) gengtype.h \t\\\n   rtl.def insn-notes.def errors.h double-int.h $(HASHTAB_H)\n build/genmddeps.o: genmddeps.c $(BCONFIG_H) $(SYSTEM_H) coretypes.h\t\\\n-  $(GTM_H) $(RTL_BASE_H) errors.h gensupport.h\n+  $(GTM_H) $(RTL_BASE_H) errors.h $(READ_MD_H) gensupport.h\n build/genmodes.o : genmodes.c $(BCONFIG_H) $(SYSTEM_H) errors.h\t\t\\\n   $(HASHTAB_H) machmode.def $(extra_modes_file)\n build/genopinit.o : genopinit.c $(RTL_BASE_H) $(BCONFIG_H) $(SYSTEM_H)\t\\"}, {"sha": "84399b8a677e298eba599e3205e13875a5dd1e44", "filename": "gcc/genattr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600ab3fcfa44ffe8f6c384333d3254ec610a3da7/gcc%2Fgenattr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600ab3fcfa44ffe8f6c384333d3254ec610a3da7/gcc%2Fgenattr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattr.c?ref=600ab3fcfa44ffe8f6c384333d3254ec610a3da7", "patch": "@@ -98,7 +98,7 @@ main (int argc, char **argv)\n \n   progname = \"genattr\";\n \n-  if (init_md_reader_args (argc, argv) != SUCCESS_EXIT_CODE)\n+  if (!init_rtx_reader_args (argc, argv))\n     return (FATAL_EXIT_CODE);\n \n   puts (\"/* Generated automatically by the program `genattr'\");"}, {"sha": "ac5c75e45d0df394397e4b86463b68ab70f8571c", "filename": "gcc/genattrtab.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600ab3fcfa44ffe8f6c384333d3254ec610a3da7/gcc%2Fgenattrtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600ab3fcfa44ffe8f6c384333d3254ec610a3da7/gcc%2Fgenattrtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.c?ref=600ab3fcfa44ffe8f6c384333d3254ec610a3da7", "patch": "@@ -4417,7 +4417,7 @@ main (int argc, char **argv)\n \n   progname = \"genattrtab\";\n \n-  if (init_md_reader_args (argc, argv) != SUCCESS_EXIT_CODE)\n+  if (!init_rtx_reader_args (argc, argv))\n     return (FATAL_EXIT_CODE);\n \n   obstack_init (hash_obstack);"}, {"sha": "a268aa053da9abbc3e060ba3658efde2e007b16b", "filename": "gcc/genautomata.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600ab3fcfa44ffe8f6c384333d3254ec610a3da7/gcc%2Fgenautomata.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600ab3fcfa44ffe8f6c384333d3254ec610a3da7/gcc%2Fgenautomata.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenautomata.c?ref=600ab3fcfa44ffe8f6c384333d3254ec610a3da7", "patch": "@@ -9467,7 +9467,7 @@ main (int argc, char **argv)\n \n   progname = \"genautomata\";\n \n-  if (init_md_reader_args (argc, argv) != SUCCESS_EXIT_CODE)\n+  if (!init_rtx_reader_args (argc, argv))\n     return (FATAL_EXIT_CODE);\n \n   initiate_automaton_gen (argc, argv);"}, {"sha": "4c59f8392b5ba0f3e641431cd684fe6dd0831794", "filename": "gcc/gencodes.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600ab3fcfa44ffe8f6c384333d3254ec610a3da7/gcc%2Fgencodes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600ab3fcfa44ffe8f6c384333d3254ec610a3da7/gcc%2Fgencodes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgencodes.c?ref=600ab3fcfa44ffe8f6c384333d3254ec610a3da7", "patch": "@@ -58,7 +58,7 @@ main (int argc, char **argv)\n      direct references to CODE_FOR_xxx in C code.  */\n   insn_elision = 0;\n \n-  if (init_md_reader_args (argc, argv) != SUCCESS_EXIT_CODE)\n+  if (!init_rtx_reader_args (argc, argv))\n     return (FATAL_EXIT_CODE);\n \n   puts (\"\\"}, {"sha": "2d93c3470d6d6b7607cbb3bae2ba7364c89f86a2", "filename": "gcc/genconditions.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600ab3fcfa44ffe8f6c384333d3254ec610a3da7/gcc%2Fgenconditions.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600ab3fcfa44ffe8f6c384333d3254ec610a3da7/gcc%2Fgenconditions.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenconditions.c?ref=600ab3fcfa44ffe8f6c384333d3254ec610a3da7", "patch": "@@ -214,7 +214,7 @@ main (int argc, char **argv)\n \n   progname = \"genconditions\";\n \n-  if (init_md_reader_args (argc, argv) != SUCCESS_EXIT_CODE)\n+  if (!init_rtx_reader_args (argc, argv))\n     return (FATAL_EXIT_CODE);\n \n   /* Read the machine description.  */"}, {"sha": "027c92e50dc5dd3538ac4ca69b88e9aa0cc22dde", "filename": "gcc/genconfig.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600ab3fcfa44ffe8f6c384333d3254ec610a3da7/gcc%2Fgenconfig.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600ab3fcfa44ffe8f6c384333d3254ec610a3da7/gcc%2Fgenconfig.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenconfig.c?ref=600ab3fcfa44ffe8f6c384333d3254ec610a3da7", "patch": "@@ -264,7 +264,7 @@ main (int argc, char **argv)\n \n   progname = \"genconfig\";\n \n-  if (init_md_reader_args (argc, argv) != SUCCESS_EXIT_CODE)\n+  if (!init_rtx_reader_args (argc, argv))\n     return (FATAL_EXIT_CODE);\n \n   puts (\"/* Generated automatically by the program `genconfig'\");"}, {"sha": "e5f083a36fd370c60abfb5acd4d3955fea014cd8", "filename": "gcc/genconstants.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600ab3fcfa44ffe8f6c384333d3254ec610a3da7/gcc%2Fgenconstants.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600ab3fcfa44ffe8f6c384333d3254ec610a3da7/gcc%2Fgenconstants.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenconstants.c?ref=600ab3fcfa44ffe8f6c384333d3254ec610a3da7", "patch": "@@ -52,7 +52,7 @@ main (int argc, char **argv)\n {\n   progname = \"genconstants\";\n \n-  if (init_md_reader_args (argc, argv) != SUCCESS_EXIT_CODE)\n+  if (!init_rtx_reader_args (argc, argv))\n     return (FATAL_EXIT_CODE);\n \n   /* Initializing the MD reader has the side effect of loading up"}, {"sha": "98ec42fe0c352ac06b2b5deaa66afab07d47c64d", "filename": "gcc/genemit.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600ab3fcfa44ffe8f6c384333d3254ec610a3da7/gcc%2Fgenemit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600ab3fcfa44ffe8f6c384333d3254ec610a3da7/gcc%2Fgenemit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenemit.c?ref=600ab3fcfa44ffe8f6c384333d3254ec610a3da7", "patch": "@@ -833,7 +833,7 @@ main (int argc, char **argv)\n \n   progname = \"genemit\";\n \n-  if (init_md_reader_args (argc, argv) != SUCCESS_EXIT_CODE)\n+  if (!init_rtx_reader_args (argc, argv))\n     return (FATAL_EXIT_CODE);\n \n   /* Assign sequential codes to all entries in the machine description"}, {"sha": "2bf9779f381f13a2d22d31953104ab624a8e5904", "filename": "gcc/genextract.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600ab3fcfa44ffe8f6c384333d3254ec610a3da7/gcc%2Fgenextract.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600ab3fcfa44ffe8f6c384333d3254ec610a3da7/gcc%2Fgenextract.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenextract.c?ref=600ab3fcfa44ffe8f6c384333d3254ec610a3da7", "patch": "@@ -410,7 +410,7 @@ main (int argc, char **argv)\n \n   progname = \"genextract\";\n \n-  if (init_md_reader_args (argc, argv) != SUCCESS_EXIT_CODE)\n+  if (!init_rtx_reader_args (argc, argv))\n     return (FATAL_EXIT_CODE);\n \n   /* Read the machine description.  */"}, {"sha": "f3cffe8746da159f0b2441ffe7f30c7a662e4ce1", "filename": "gcc/genflags.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600ab3fcfa44ffe8f6c384333d3254ec610a3da7/gcc%2Fgenflags.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600ab3fcfa44ffe8f6c384333d3254ec610a3da7/gcc%2Fgenflags.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenflags.c?ref=600ab3fcfa44ffe8f6c384333d3254ec610a3da7", "patch": "@@ -262,7 +262,7 @@ main (int argc, char **argv)\n      direct calls to their generators in C code.  */\n   insn_elision = 0;\n \n-  if (init_md_reader_args (argc, argv) != SUCCESS_EXIT_CODE)\n+  if (!init_rtx_reader_args (argc, argv))\n     return (FATAL_EXIT_CODE);\n \n   puts (\"/* Generated automatically by the program `genflags'\");"}, {"sha": "f9fdacb4a9581c807c624af276b61f8183080515", "filename": "gcc/genmddeps.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600ab3fcfa44ffe8f6c384333d3254ec610a3da7/gcc%2Fgenmddeps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600ab3fcfa44ffe8f6c384333d3254ec610a3da7/gcc%2Fgenmddeps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenmddeps.c?ref=600ab3fcfa44ffe8f6c384333d3254ec610a3da7", "patch": "@@ -20,8 +20,9 @@\n #include \"coretypes.h\"\n #include \"tm.h\"\n #include \"rtl.h\"\n-#include \"gensupport.h\"\n #include \"errors.h\"\n+#include \"read-md.h\"\n+#include \"gensupport.h\"\n \n \n struct filedep\n@@ -49,7 +50,7 @@ main (int argc, char **argv)\n   progname = \"genmddeps\";\n   include_callback = add_filedep;\n \n-  if (init_md_reader_args (argc, argv) != SUCCESS_EXIT_CODE)\n+  if (!init_rtx_reader_args (argc, argv))\n     return (FATAL_EXIT_CODE);\n \n   *last = NULL;"}, {"sha": "d0ec274842a449789a536fc4de72693876e41a10", "filename": "gcc/genopinit.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600ab3fcfa44ffe8f6c384333d3254ec610a3da7/gcc%2Fgenopinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600ab3fcfa44ffe8f6c384333d3254ec610a3da7/gcc%2Fgenopinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenopinit.c?ref=600ab3fcfa44ffe8f6c384333d3254ec610a3da7", "patch": "@@ -472,7 +472,7 @@ main (int argc, char **argv)\n \n   progname = \"genopinit\";\n \n-  if (init_md_reader_args (argc, argv) != SUCCESS_EXIT_CODE)\n+  if (!init_rtx_reader_args (argc, argv))\n     return (FATAL_EXIT_CODE);\n \n   printf (\"/* Generated automatically by the program `genopinit'\\n\\"}, {"sha": "a8ab275bff986d8f21c3434886d33b8abc75b457", "filename": "gcc/genoutput.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600ab3fcfa44ffe8f6c384333d3254ec610a3da7/gcc%2Fgenoutput.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600ab3fcfa44ffe8f6c384333d3254ec610a3da7/gcc%2Fgenoutput.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenoutput.c?ref=600ab3fcfa44ffe8f6c384333d3254ec610a3da7", "patch": "@@ -1002,7 +1002,7 @@ main (int argc, char **argv)\n \n   progname = \"genoutput\";\n \n-  if (init_md_reader_args (argc, argv) != SUCCESS_EXIT_CODE)\n+  if (!init_rtx_reader_args (argc, argv))\n     return (FATAL_EXIT_CODE);\n \n   output_prologue ();"}, {"sha": "b129f94b02066bfc6a6d517da23742410ef5ab85", "filename": "gcc/genpeep.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600ab3fcfa44ffe8f6c384333d3254ec610a3da7/gcc%2Fgenpeep.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600ab3fcfa44ffe8f6c384333d3254ec610a3da7/gcc%2Fgenpeep.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenpeep.c?ref=600ab3fcfa44ffe8f6c384333d3254ec610a3da7", "patch": "@@ -358,7 +358,7 @@ main (int argc, char **argv)\n \n   progname = \"genpeep\";\n \n-  if (init_md_reader_args (argc, argv) != SUCCESS_EXIT_CODE)\n+  if (!init_rtx_reader_args (argc, argv))\n     return (FATAL_EXIT_CODE);\n \n   printf (\"/* Generated automatically by the program `genpeep'\\n\\"}, {"sha": "c69647042c725f35cd1dcd9b1cab6c0ef9b40cf9", "filename": "gcc/genpreds.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600ab3fcfa44ffe8f6c384333d3254ec610a3da7/gcc%2Fgenpreds.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600ab3fcfa44ffe8f6c384333d3254ec610a3da7/gcc%2Fgenpreds.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenpreds.c?ref=600ab3fcfa44ffe8f6c384333d3254ec610a3da7", "patch": "@@ -1393,7 +1393,7 @@ main (int argc, char **argv)\n   progname = argv[0];\n   if (argc <= 1)\n     fatal (\"no input file name\");\n-  if (init_md_reader_args_cb (argc, argv, parse_option) != SUCCESS_EXIT_CODE)\n+  if (!init_rtx_reader_args_cb (argc, argv, parse_option))\n     return FATAL_EXIT_CODE;\n \n   while ((defn = read_md_rtx (&pattern_lineno, &next_insn_code)) != 0)"}, {"sha": "26c2a95bbc524af78476fe9db7380a277e5ed239", "filename": "gcc/genrecog.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600ab3fcfa44ffe8f6c384333d3254ec610a3da7/gcc%2Fgenrecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600ab3fcfa44ffe8f6c384333d3254ec610a3da7/gcc%2Fgenrecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenrecog.c?ref=600ab3fcfa44ffe8f6c384333d3254ec610a3da7", "patch": "@@ -2708,7 +2708,7 @@ main (int argc, char **argv)\n   memset (&split_tree, 0, sizeof split_tree);\n   memset (&peephole2_tree, 0, sizeof peephole2_tree);\n \n-  if (init_md_reader_args (argc, argv) != SUCCESS_EXIT_CODE)\n+  if (!init_rtx_reader_args (argc, argv))\n     return (FATAL_EXIT_CODE);\n \n   next_insn_code = 0;"}, {"sha": "1389658609c34d305eedf5a83ccdaf4a30d3ca92", "filename": "gcc/gensupport.c", "status": "modified", "additions": 16, "deletions": 248, "changes": 264, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600ab3fcfa44ffe8f6c384333d3254ec610a3da7/gcc%2Fgensupport.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600ab3fcfa44ffe8f6c384333d3254ec610a3da7/gcc%2Fgensupport.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgensupport.c?ref=600ab3fcfa44ffe8f6c384333d3254ec610a3da7", "patch": "@@ -35,12 +35,6 @@ int target_flags;\n \n int insn_elision = 1;\n \n-const char *in_fname;\n-\n-/* This callback will be invoked whenever an rtl include directive is\n-   processed.  To be used for creation of the dependency file.  */\n-void (*include_callback) (const char *);\n-\n static struct obstack obstack;\n struct obstack *rtl_obstack = &obstack;\n \n@@ -52,8 +46,6 @@ static const char *predicable_false;\n \n static htab_t condition_table;\n \n-static char *base_dir = NULL;\n-\n /* We initially queue all patterns, process the define_insn and\n    define_cond_exec patterns, then return them one at a time.  */\n \n@@ -82,22 +74,6 @@ static struct queue_elem **other_tail = &other_queue;\n static struct queue_elem *queue_pattern (rtx, struct queue_elem ***,\n \t\t\t\t\t const char *, int);\n \n-/* Current maximum length of directory names in the search path\n-   for include files.  (Altered as we get more of them.)  */\n-\n-size_t max_include_len;\n-\n-struct file_name_list\n-  {\n-    struct file_name_list *next;\n-    const char *fname;\n-  };\n-\n-struct file_name_list *first_dir_md_include = 0;  /* First dir to search */\n-        /* First dir to search for <file> */\n-struct file_name_list *first_bracket_include = 0;\n-struct file_name_list *last_dir_md_include = 0;        /* Last in chain */\n-\n static void remove_constraints (rtx);\n static void process_rtx (rtx, int);\n \n@@ -114,8 +90,6 @@ static const char *alter_output_for_insn (struct queue_elem *,\n \t\t\t\t\t  int, int);\n static void process_one_cond_exec (struct queue_elem *);\n static void process_define_cond_exec (void);\n-static void process_include (rtx, int);\n-static char *save_string (const char *, int);\n static void init_predicate_table (void);\n static void record_insn_name (int, const char *);\n \f\n@@ -183,76 +157,6 @@ remove_constraints (rtx part)\n       }\n }\n \n-/* Process an include file assuming that it lives in gcc/config/{target}/\n-   if the include looks like (include \"file\").  */\n-\n-static void\n-process_include (rtx desc, int lineno)\n-{\n-  const char *filename = XSTR (desc, 0);\n-  const char *old_filename;\n-  int old_lineno;\n-  char *pathname;\n-  FILE *input_file, *old_file;\n-\n-  /* If specified file name is absolute, skip the include stack.  */\n-  if (! IS_ABSOLUTE_PATH (filename))\n-    {\n-      struct file_name_list *stackp;\n-\n-      /* Search directory path, trying to open the file.  */\n-      for (stackp = first_dir_md_include; stackp; stackp = stackp->next)\n-\t{\n-\t  static const char sep[2] = { DIR_SEPARATOR, '\\0' };\n-\n-\t  pathname = concat (stackp->fname, sep, filename, NULL);\n-\t  input_file = fopen (pathname, \"r\");\n-\t  if (input_file != NULL)\n-\t    goto success;\n-\t  free (pathname);\n-\t}\n-    }\n-\n-  if (base_dir)\n-    pathname = concat (base_dir, filename, NULL);\n-  else\n-    pathname = xstrdup (filename);\n-  input_file = fopen (pathname, \"r\");\n-  if (input_file == NULL)\n-    {\n-      free (pathname);\n-      error_with_line (lineno, \"include file `%s' not found\", filename);\n-      return;\n-    }\n- success:\n-\n-  /* Save old cursor; setup new for the new file.  Note that \"lineno\" the\n-     argument to this function is the beginning of the include statement,\n-     while read_md_lineno has already been advanced.  */\n-  old_file = read_md_file;\n-  old_filename = read_md_filename;\n-  old_lineno = read_md_lineno;\n-  read_md_file = input_file;\n-  read_md_filename = pathname;\n-  read_md_lineno = 1;\n-\n-  if (include_callback)\n-    include_callback (pathname);\n-\n-  /* Read the entire file.  */\n-  while (read_rtx (&desc, &lineno))\n-    process_rtx (desc, lineno);\n-\n-  /* Do not free pathname.  It is attached to the various rtx queue\n-     elements.  */\n-\n-  read_md_file = old_file;\n-  read_md_filename = old_filename;\n-  read_md_lineno = old_lineno;\n-\n-  fclose (input_file);\n-}\n-\n /* Process a top level rtx in some way, queuing as appropriate.  */\n \n static void\n@@ -281,10 +185,6 @@ process_rtx (rtx desc, int lineno)\n       queue_pattern (desc, &define_pred_tail, read_md_filename, lineno);\n       break;\n \n-    case INCLUDE:\n-      process_include (desc, lineno);\n-      break;\n-\n     case DEFINE_INSN_AND_SPLIT:\n       {\n \tconst char *split_cond;\n@@ -868,178 +768,46 @@ process_define_cond_exec (void)\n   for (elem = define_cond_exec_queue; elem ; elem = elem->next)\n     process_one_cond_exec (elem);\n }\n+\f\n+/* A read_md_files callback for reading an rtx.  */\n \n-static char *\n-save_string (const char *s, int len)\n+static void\n+rtx_handle_directive (int lineno, const char *rtx_name)\n {\n-  char *result = XNEWVEC (char, len + 1);\n+  rtx queue, x;\n \n-  memcpy (result, s, len);\n-  result[len] = 0;\n-  return result;\n+  if (read_rtx (rtx_name, &queue))\n+    for (x = queue; x; x = XEXP (x, 1))\n+      process_rtx (XEXP (x, 0), lineno);\n }\n \n-\f\n /* The entry point for initializing the reader.  */\n \n-int\n-init_md_reader_args_cb (int argc, char **argv, bool (*parse_opt)(const char *))\n+bool\n+init_rtx_reader_args_cb (int argc, char **argv,\n+\t\t\t bool (*parse_opt) (const char *))\n {\n-  int c, i, lineno;\n-  char *lastsl;\n-  rtx desc;\n-  bool no_more_options;\n-  bool already_read_stdin;\n-\n-  /* Unlock the stdio streams.  */\n-  unlock_std_streams ();\n-\n-  /* First we loop over all the options.  */\n-  for (i = 1; i < argc; i++)\n-    {\n-      if (argv[i][0] != '-')\n-\tcontinue;\n-\n-      c = argv[i][1];\n-      switch (c)\n-\t{\n-\tcase 'I':\t\t/* Add directory to path for includes.  */\n-\t  {\n-\t    struct file_name_list *dirtmp;\n-\n-\t    dirtmp = XNEW (struct file_name_list);\n-\t    dirtmp->next = 0;\t/* New one goes on the end */\n-\t    if (first_dir_md_include == 0)\n-\t      first_dir_md_include = dirtmp;\n-\t    else\n-\t      last_dir_md_include->next = dirtmp;\n-\t    last_dir_md_include = dirtmp;\t/* Tail follows the last one */\n-\t    if (argv[i][1] == 'I' && argv[i][2] != 0)\n-\t      dirtmp->fname = argv[i] + 2;\n-\t    else if (i + 1 == argc)\n-\t      fatal (\"directory name missing after -I option\");\n-\t    else\n-\t      dirtmp->fname = argv[++i];\n-\t    if (strlen (dirtmp->fname) > max_include_len)\n-\t      max_include_len = strlen (dirtmp->fname);\n-\t  }\n-\t  break;\n-\n-\tcase '\\0':\n-\t  /* An argument consisting of exactly one dash is a request to\n-\t     read stdin.  This will be handled in the second loop.  */\n-\t  continue;\n-\n-\tcase '-':\n-\t  /* An argument consisting of just two dashes causes option\n-\t     parsing to cease.  */\n-\t  if (argv[i][2] == '\\0')\n-\t    goto stop_parsing_options;\n-\n-\tdefault:\n-\t  /* The program may have provided a callback so it can\n-\t     accept its own options.  */\n-\t  if (parse_opt && parse_opt (argv[i]))\n-\t    break;\n-\n-\t  fatal (\"invalid option `%s'\", argv[i]);\n-\t}\n-    }\n-\n- stop_parsing_options:\n-\n   /* Prepare to read input.  */\n   condition_table = htab_create (500, hash_c_test, cmp_c_test, NULL);\n   init_predicate_table ();\n   obstack_init (rtl_obstack);\n   sequence_num = 0;\n-  no_more_options = false;\n-  already_read_stdin = false;\n-\n \n-  /* Now loop over all input files.  */\n-  for (i = 1; i < argc; i++)\n-    {\n-      if (argv[i][0] == '-')\n-\t{\n-\t  if (argv[i][1] == '\\0')\n-\t    {\n-\t      /* Read stdin.  */\n-\t      if (already_read_stdin)\n-\t\tfatal (\"cannot read standard input twice\");\n-\n-\t      base_dir = NULL;\n-\t      read_md_file = stdin;\n-\t      read_md_filename = in_fname = \"<stdin>\";\n-\t      read_md_lineno = 1;\n-\t      already_read_stdin = true;\n-\n-\t      while (read_rtx (&desc, &lineno))\n-\t\tprocess_rtx (desc, lineno);\n-\t      fclose (read_md_file);\n-\t      continue;\n-\t    }\n-\t  else if (argv[i][1] == '-' && argv[i][2] == '\\0')\n-\t    {\n-\t      /* No further arguments are to be treated as options.  */\n-\t      no_more_options = true;\n-\t      continue;\n-\t    }\n-\t  else if (!no_more_options)\n-\t    continue;\n-\t}\n-\n-      /* If we get here we are looking at a non-option argument, i.e.\n-\t a file to be processed.  */\n-\n-      in_fname = argv[i];\n-      lastsl = strrchr (in_fname, '/');\n-      if (lastsl != NULL)\n-\tbase_dir = save_string (in_fname, lastsl - in_fname + 1 );\n-      else\n-\tbase_dir = NULL;\n-\n-      read_md_file = fopen (in_fname, \"r\");\n-      if (read_md_file == 0)\n-\t{\n-\t  perror (in_fname);\n-\t  return FATAL_EXIT_CODE;\n-\t}\n-      read_md_filename = in_fname;\n-      read_md_lineno = 1;\n-\n-      while (read_rtx (&desc, &lineno))\n-\tprocess_rtx (desc, lineno);\n-      fclose (read_md_file);\n-    }\n-\n-  /* If we get to this point without having seen any files to process,\n-     read standard input now.  */\n-  if (!in_fname)\n-    {\n-      base_dir = NULL;\n-      read_md_file = stdin;\n-      read_md_filename = in_fname = \"<stdin>\";\n-      read_md_lineno = 1;\n-\n-      while (read_rtx (&desc, &lineno))\n-\tprocess_rtx (desc, lineno);\n-      fclose (read_md_file);\n-    }\n+  read_md_files (argc, argv, parse_opt, rtx_handle_directive);\n \n   /* Process define_cond_exec patterns.  */\n   if (define_cond_exec_queue != NULL)\n     process_define_cond_exec ();\n \n-  return have_error ? FATAL_EXIT_CODE : SUCCESS_EXIT_CODE;\n+  return !have_error;\n }\n \n /* Programs that don't have their own options can use this entry point\n    instead.  */\n-int\n-init_md_reader_args (int argc, char **argv)\n+bool\n+init_rtx_reader_args (int argc, char **argv)\n {\n-  return init_md_reader_args_cb (argc, argv, 0);\n+  return init_rtx_reader_args_cb (argc, argv, 0);\n }\n \f\n /* The entry point for reading a single rtx from an md file.  */"}, {"sha": "f2fcce56ea3f30af53069b41eaadc738a789225a", "filename": "gcc/gensupport.h", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600ab3fcfa44ffe8f6c384333d3254ec610a3da7/gcc%2Fgensupport.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600ab3fcfa44ffe8f6c384333d3254ec610a3da7/gcc%2Fgensupport.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgensupport.h?ref=600ab3fcfa44ffe8f6c384333d3254ec610a3da7", "patch": "@@ -23,10 +23,9 @@ along with GCC; see the file COPYING3.  If not see\n \n struct obstack;\n extern struct obstack *rtl_obstack;\n-extern const char *in_fname;\n \n-extern int init_md_reader_args_cb (int, char **, bool (*)(const char *));\n-extern int init_md_reader_args (int, char **);\n+extern bool init_rtx_reader_args_cb (int, char **, bool (*)(const char *));\n+extern bool init_rtx_reader_args (int, char **);\n extern rtx read_md_rtx (int *, int *);\n \n /* Set this to 0 to disable automatic elision of insn patterns which\n@@ -84,8 +83,4 @@ extern void add_predicate (struct pred_data *);\n \n #define FOR_ALL_PREDICATES(p) for (p = first_predicate; p; p = p->next)\n \n-/* This callback will be invoked whenever an rtl include directive is\n-   processed.  To be used for creation of the dependency file.  */\n-extern void (*include_callback) (const char *);\n-\n #endif /* GCC_GENSUPPORT_H */"}, {"sha": "0071e28b471f6af75366b4b8bbd5a02a4932094c", "filename": "gcc/read-md.c", "status": "modified", "additions": 283, "deletions": 8, "changes": 291, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600ab3fcfa44ffe8f6c384333d3254ec610a3da7/gcc%2Fread-md.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600ab3fcfa44ffe8f6c384333d3254ec610a3da7/gcc%2Fread-md.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fread-md.c?ref=600ab3fcfa44ffe8f6c384333d3254ec610a3da7", "patch": "@@ -34,6 +34,12 @@ struct ptr_loc {\n   int lineno;\n };\n \n+/* A singly-linked list of filenames.  */\n+struct file_name_list {\n+  struct file_name_list *next;\n+  const char *fname;\n+};\n+\n /* Obstack used for allocating MD strings.  */\n struct obstack string_obstack;\n \n@@ -62,10 +68,32 @@ const char *read_md_filename;\n /* The current line number in READ_MD_FILE.  */\n int read_md_lineno;\n \n+/* The name of the toplevel file that indirectly included READ_MD_FILE.  */\n+const char *in_fname;\n+\n+/* The directory part of IN_FNAME.  NULL if IN_FNAME is a bare filename.  */\n+static char *base_dir;\n+\n+/* The first directory to search.  */\n+static struct file_name_list *first_dir_md_include;\n+\n+/* A pointer to the null terminator of the md include chain.  */\n+static struct file_name_list **last_dir_md_include_ptr = &first_dir_md_include;\n+\n+/* This callback will be invoked whenever an md include directive is\n+   processed.  To be used for creation of the dependency file.  */\n+void (*include_callback) (const char *);\n+\n+/* The current maximum length of directory names in the search path\n+   for include files.  (Altered as we get more of them.)  */\n+static size_t max_include_len;\n+\n /* A table of md_constant structures, hashed by name.  Null if no\n    constant expansion should occur.  */\n static htab_t md_constants;\n \n+static void handle_file (directive_handler_t);\n+\n /* Given an object that starts with a char * name field, return a hash\n    code for its name.  */\n \n@@ -597,8 +625,8 @@ scan_comma_elt (const char **pstr)\n /* Process a define_constants directive, starting with the optional space\n    after the \"define_constants\".  */\n \n-void\n-read_constants (void)\n+static void\n+handle_constants (void)\n {\n   int c;\n   htab_t defs;\n@@ -648,9 +676,6 @@ read_constants (void)\n \tfatal_expected_char (')', c);\n     }\n   md_constants = defs;\n-  c = read_skip_spaces ();\n-  if (c != ')')\n-    fatal_expected_char (')', c);\n }\n \n /* For every constant definition, call CALLBACK with two arguments:\n@@ -664,14 +689,264 @@ traverse_md_constants (htab_trav callback, void *info)\n     htab_traverse (md_constants, callback, info);\n }\n \n-/* Initialize this file's static data.  */\n+/* Process an \"include\" directive, starting with the optional space\n+   after the \"include\".  Read in the file and use HANDLE_DIRECTIVE\n+   to process each unknown directive.  LINENO is the line number on\n+   which the \"include\" occured.  */\n \n-void\n-init_md_reader (void)\n+static void\n+handle_include (int lineno, directive_handler_t handle_directive)\n {\n+  const char *filename;\n+  const char *old_filename;\n+  int old_lineno;\n+  char *pathname;\n+  FILE *input_file, *old_file;\n+\n+  filename = read_string (false);\n+  input_file = NULL;\n+\n+  /* If the specified file name is absolute, skip the include stack.  */\n+  if (!IS_ABSOLUTE_PATH (filename))\n+    {\n+      struct file_name_list *stackp;\n+\n+      /* Search the directory path, trying to open the file.  */\n+      for (stackp = first_dir_md_include; stackp; stackp = stackp->next)\n+\t{\n+\t  static const char sep[2] = { DIR_SEPARATOR, '\\0' };\n+\n+\t  pathname = concat (stackp->fname, sep, filename, NULL);\n+\t  input_file = fopen (pathname, \"r\");\n+\t  if (input_file != NULL)\n+\t    break;\n+\t  free (pathname);\n+\t}\n+    }\n+\n+  /* If we haven't managed to open the file yet, try combining the\n+     filename with BASE_DIR.  */\n+  if (input_file == NULL)\n+    {\n+      if (base_dir)\n+\tpathname = concat (base_dir, filename, NULL);\n+      else\n+\tpathname = xstrdup (filename);\n+      input_file = fopen (pathname, \"r\");\n+    }\n+\n+  if (input_file == NULL)\n+    {\n+      free (pathname);\n+      error_with_line (lineno, \"include file `%s' not found\", filename);\n+      return;\n+    }\n+\n+  /* Save the old cursor.  Note that the LINENO argument to this\n+     function is the beginning of the include statement, while\n+     read_md_lineno has already been advanced.  */\n+  old_file = read_md_file;\n+  old_filename = read_md_filename;\n+  old_lineno = read_md_lineno;\n+\n+  if (include_callback)\n+    include_callback (pathname);\n+\n+  read_md_file = input_file;\n+  read_md_filename = pathname;\n+  handle_file (handle_directive);\n+\n+  /* Restore the old cursor.  */\n+  read_md_file = old_file;\n+  read_md_filename = old_filename;\n+  read_md_lineno = old_lineno;\n+\n+  /* Do not free the pathname.  It is attached to the various rtx\n+     queue elements.  */\n+}\n+\n+/* Process the current file, assuming that read_md_file and\n+   read_md_filename are valid.  Use HANDLE_DIRECTIVE to handle\n+   unknown directives.  */\n+\n+static void\n+handle_file (directive_handler_t handle_directive)\n+{\n+  struct md_name directive;\n+  int c, lineno;\n+\n+  read_md_lineno = 1;\n+  while ((c = read_skip_spaces ()) != EOF)\n+    {\n+      lineno = read_md_lineno;\n+      if (c != '(')\n+\tfatal_expected_char ('(', c);\n+\n+      read_name (&directive);\n+      if (strcmp (directive.string, \"define_constants\") == 0)\n+\thandle_constants ();\n+      else if (strcmp (directive.string, \"include\") == 0)\n+\thandle_include (lineno, handle_directive);\n+      else\n+\thandle_directive (lineno, directive.string);\n+\n+      c = read_skip_spaces ();\n+      if (c != ')')\n+\tfatal_expected_char (')', c);\n+    }\n+  fclose (read_md_file);\n+}\n+\n+/* Like handle_file, but for top-level files.  Set up in_fname and\n+   base_dir accordingly.  */\n+\n+static void\n+handle_toplevel_file (directive_handler_t handle_directive)\n+{\n+  char *lastsl;\n+\n+  in_fname = read_md_filename;\n+  lastsl = strrchr (in_fname, '/');\n+  if (lastsl != NULL)\n+    base_dir = xstrndup (in_fname, lastsl - in_fname + 1);\n+  else\n+    base_dir = NULL;\n+\n+  handle_file (handle_directive);\n+}\n+\n+/* Parse a -I option with argument ARG.  */\n+\n+static void\n+parse_include (const char *arg)\n+{\n+  struct file_name_list *dirtmp;\n+\n+  dirtmp = XNEW (struct file_name_list);\n+  dirtmp->next = 0;\n+  dirtmp->fname = arg;\n+  *last_dir_md_include_ptr = dirtmp;\n+  last_dir_md_include_ptr = &dirtmp->next;\n+  if (strlen (dirtmp->fname) > max_include_len)\n+    max_include_len = strlen (dirtmp->fname);\n+}\n+\n+/* The main routine for reading .md files.  Try to process all the .md\n+   files specified on the command line and return true if no error occured.\n+\n+   ARGC and ARGV are the arguments to main.\n+\n+   PARSE_OPT, if nonnull, is passed all unknown command-line arguments.\n+   It should return true if it recognizes the argument or false if a\n+   generic error should be reported.\n+\n+   The parser calls HANDLE_DIRECTIVE for each unknown directive.\n+   See the comment above the directive_handler_t definition for\n+   details about the callback's interface.  */\n+\n+bool\n+read_md_files (int argc, char **argv, bool (*parse_opt) (const char *),\n+\t       directive_handler_t handle_directive)\n+{\n+  int i;\n+  bool no_more_options;\n+  bool already_read_stdin;\n+  int num_files;\n+\n+  /* Initialize global data.  */\n   obstack_init (&string_obstack);\n   ptr_locs = htab_create (161, leading_ptr_hash, leading_ptr_eq_p, 0);\n   obstack_init (&ptr_loc_obstack);\n   joined_conditions = htab_create (161, leading_ptr_hash, leading_ptr_eq_p, 0);\n   obstack_init (&joined_conditions_obstack);\n+\n+  /* Unlock the stdio streams.  */\n+  unlock_std_streams ();\n+\n+  /* First we loop over all the options.  */\n+  for (i = 1; i < argc; i++)\n+    if (argv[i][0] == '-')\n+      {\n+\t/* An argument consisting of exactly one dash is a request to\n+\t   read stdin.  This will be handled in the second loop.  */\n+\tif (argv[i][1] == '\\0')\n+\t  continue;\n+\n+\t/* An argument consisting of just two dashes causes option\n+\t   parsing to cease.  */\n+\tif (argv[i][1] == '-' && argv[i][2] == '\\0')\n+\t  break;\n+\n+\tif (argv[i][1] == 'I')\n+\t  {\n+\t    if (argv[i][2] != '\\0')\n+\t      parse_include (argv[i] + 2);\n+\t    else if (++i < argc)\n+\t      parse_include (argv[i]);\n+\t    else\n+\t      fatal (\"directory name missing after -I option\");\n+\t    continue;\n+\t  }\n+\n+\t/* The program may have provided a callback so it can\n+\t   accept its own options.  */\n+\tif (parse_opt && parse_opt (argv[i]))\n+\t  continue;\n+\n+\tfatal (\"invalid option `%s'\", argv[i]);\n+      }\n+\n+  /* Now loop over all input files.  */\n+  num_files = 0;\n+  no_more_options = false;\n+  already_read_stdin = false;\n+  for (i = 1; i < argc; i++)\n+    {\n+      if (argv[i][0] == '-')\n+\t{\n+\t  if (argv[i][1] == '\\0')\n+\t    {\n+\t      /* Read stdin.  */\n+\t      if (already_read_stdin)\n+\t\tfatal (\"cannot read standard input twice\");\n+\n+\t      read_md_file = stdin;\n+\t      read_md_filename = \"<stdin>\";\n+\t      handle_toplevel_file (handle_directive);\n+\t      already_read_stdin = true;\n+\t      continue;\n+\t    }\n+\t  else if (argv[i][1] == '-' && argv[i][2] == '\\0')\n+\t    {\n+\t      /* No further arguments are to be treated as options.  */\n+\t      no_more_options = true;\n+\t      continue;\n+\t    }\n+\t  else if (!no_more_options)\n+\t    continue;\n+\t}\n+\n+      /* If we get here we are looking at a non-option argument, i.e.\n+\t a file to be processed.  */\n+      read_md_filename = argv[i];\n+      read_md_file = fopen (read_md_filename, \"r\");\n+      if (read_md_file == 0)\n+\t{\n+\t  perror (read_md_filename);\n+\t  return false;\n+\t}\n+      handle_toplevel_file (handle_directive);\n+      num_files++;\n+    }\n+\n+  /* If we get to this point without having seen any files to process,\n+     read the standard input now.  */\n+  if (num_files == 0 && !already_read_stdin)\n+    {\n+      read_md_file = stdin;\n+      read_md_filename = \"<stdin>\";\n+      handle_toplevel_file (handle_directive);\n+    }\n+\n+  return !have_error;\n }"}, {"sha": "bb83468f53706bb721255cabf7ffb8311cd8ed4a", "filename": "gcc/read-md.h", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600ab3fcfa44ffe8f6c384333d3254ec610a3da7/gcc%2Fread-md.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600ab3fcfa44ffe8f6c384333d3254ec610a3da7/gcc%2Fread-md.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fread-md.h?ref=600ab3fcfa44ffe8f6c384333d3254ec610a3da7", "patch": "@@ -41,10 +41,18 @@ struct md_constant {\n   char *value;\n };\n \n+/* A callback that handles a single .md-file directive, up to but not\n+   including the closing ')'.  It takes two arguments: the line number on\n+   which the directive started, and the name of the directive.  The next\n+   unread character is the optional space after the directive name.  */\n+typedef void (*directive_handler_t) (int, const char *);\n+\n+extern const char *in_fname;\n extern FILE *read_md_file;\n extern int read_md_lineno;\n extern const char *read_md_filename;\n extern struct obstack string_obstack;\n+extern void (*include_callback) (const char *);\n \n /* Read the next character from the MD file.  */\n \n@@ -86,6 +94,6 @@ extern char *read_quoted_string (void);\n extern char *read_string (int);\n extern int n_comma_elts (const char *);\n extern const char *scan_comma_elt (const char **);\n-extern void read_constants (void);\n extern void traverse_md_constants (htab_trav, void *);\n-extern void init_md_reader (void);\n+extern bool read_md_files (int, char **, bool (*) (const char *),\n+\t\t\t   directive_handler_t);"}, {"sha": "d49cbdabf7a3aa4ee4dfe8a78b78f1404ff5eedf", "filename": "gcc/read-rtl.c", "status": "modified", "additions": 90, "deletions": 121, "changes": 211, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600ab3fcfa44ffe8f6c384333d3254ec610a3da7/gcc%2Fread-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600ab3fcfa44ffe8f6c384333d3254ec610a3da7/gcc%2Fread-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fread-rtl.c?ref=600ab3fcfa44ffe8f6c384333d3254ec610a3da7", "patch": "@@ -117,7 +117,8 @@ static void validate_const_int (const char *);\n static int find_iterator (struct iterator_group *, const char *);\n static struct mapping *read_mapping (struct iterator_group *, htab_t);\n static void check_code_iterator (struct mapping *);\n-static rtx read_rtx_1 (struct map_value **);\n+static rtx read_rtx_code (const char *, struct map_value **);\n+static rtx read_nested_rtx (struct map_value **);\n static rtx read_rtx_variadic (struct map_value **, rtx);\n \n /* The mode and code iterator structures.  */\n@@ -691,9 +692,6 @@ read_conditions (void)\n \n       add_c_test (expr, value);\n     }\n-  c = read_skip_spaces ();\n-  if (c != ')')\n-    fatal_expected_char (')', c);\n }\n \n static void\n@@ -785,10 +783,6 @@ read_mapping (struct iterator_group *group, htab_t table)\n     }\n   while (c != ']');\n \n-  c = read_skip_spaces ();\n-  if (c != ')')\n-    fatal_expected_char (')', c);\n-\n   return m;\n }\n \n@@ -812,74 +806,76 @@ check_code_iterator (struct mapping *iterator)\n   bellwether_codes[iterator->index] = bellwether;\n }\n \n-/* Read an rtx in printed representation from the MD file and store\n-   its core representation in *X.  Also store the line number of the\n-   opening '(' in *LINENO.  Return true on success or false if the\n-   end of file has been reached.\n-\n-   read_rtx is not used in the compiler proper, but rather in\n-   the utilities gen*.c that construct C code from machine descriptions.  */\n+/* Read an rtx-related declaration from the MD file, given that it\n+   starts with directive name RTX_NAME.  Return true if it expands to\n+   one or more rtxes (as defined by rtx.def).  When returning true,\n+   store the list of rtxes as an EXPR_LIST in *X.  */\n \n bool\n-read_rtx (rtx *x, int *lineno)\n+read_rtx (const char *rtx_name, rtx *x)\n {\n-  static rtx queue_head, queue_next;\n-  static int queue_lineno;\n-  int c;\n+  static rtx queue_head;\n+  struct map_value *mode_maps;\n+  struct iterator_traverse_data mtd;\n \n   /* Do one-time initialization.  */\n   if (queue_head == 0)\n     {\n-      init_md_reader ();\n       initialize_iterators ();\n       queue_head = rtx_alloc (EXPR_LIST);\n     }\n \n-  if (queue_next == 0)\n+  /* Handle various rtx-related declarations that aren't themselves\n+     encoded as rtxes.  */\n+  if (strcmp (rtx_name, \"define_conditions\") == 0)\n     {\n-      struct map_value *mode_maps;\n-      struct iterator_traverse_data mtd;\n-      rtx from_file;\n-\n-      c = read_skip_spaces ();\n-      if (c == EOF)\n-\treturn false;\n-      unread_char (c);\n-\n-      queue_lineno = read_md_lineno;\n-      mode_maps = 0;\n-      from_file = read_rtx_1 (&mode_maps);\n-      if (from_file == 0)\n-\treturn false;  /* This confuses a top level (nil) with end of\n-\t\t\t  file, but a top level (nil) would have\n-\t\t\t  crashed our caller anyway.  */\n-\n-      queue_next = queue_head;\n-      XEXP (queue_next, 0) = from_file;\n-      XEXP (queue_next, 1) = 0;\n-\n-      mtd.queue = queue_next;\n-      mtd.mode_maps = mode_maps;\n-      mtd.unknown_mode_attr = mode_maps ? mode_maps->string : NULL;\n-      htab_traverse (modes.iterators, apply_iterator_traverse, &mtd);\n-      htab_traverse (codes.iterators, apply_iterator_traverse, &mtd);\n-      if (mtd.unknown_mode_attr)\n-\tfatal_with_file_and_line (\"undefined attribute '%s' used for mode\",\n-\t\t\t\t  mtd.unknown_mode_attr);\n+      read_conditions ();\n+      return false;\n     }\n+  if (strcmp (rtx_name, \"define_mode_attr\") == 0)\n+    {\n+      read_mapping (&modes, modes.attrs);\n+      return false;\n+    }\n+  if (strcmp (rtx_name, \"define_mode_iterator\") == 0)\n+    {\n+      read_mapping (&modes, modes.iterators);\n+      return false;\n+    }\n+  if (strcmp (rtx_name, \"define_code_attr\") == 0)\n+    {\n+      read_mapping (&codes, codes.attrs);\n+      return false;\n+    }\n+  if (strcmp (rtx_name, \"define_code_iterator\") == 0)\n+    {\n+      check_code_iterator (read_mapping (&codes, codes.iterators));\n+      return false;\n+    }\n+\n+  mode_maps = 0;\n+  XEXP (queue_head, 0) = read_rtx_code (rtx_name, &mode_maps);\n+  XEXP (queue_head, 1) = 0;\n \n-  *x = XEXP (queue_next, 0);\n-  *lineno = queue_lineno;\n-  queue_next = XEXP (queue_next, 1);\n+  mtd.queue = queue_head;\n+  mtd.mode_maps = mode_maps;\n+  mtd.unknown_mode_attr = mode_maps ? mode_maps->string : NULL;\n+  htab_traverse (modes.iterators, apply_iterator_traverse, &mtd);\n+  htab_traverse (codes.iterators, apply_iterator_traverse, &mtd);\n+  if (mtd.unknown_mode_attr)\n+    fatal_with_file_and_line (\"undefined attribute '%s' used for mode\",\n+\t\t\t      mtd.unknown_mode_attr);\n \n+  *x = queue_head;\n   return true;\n }\n \n-/* Subroutine of read_rtx that reads one construct from the MD file but\n-   doesn't apply any iterators.  */\n+/* Subroutine of read_rtx and read_nested_rtx.  CODE_NAME is the name of\n+   either an rtx code or a code iterator.  Parse the rest of the rtx and\n+   return it.  MODE_MAPS is as for iterator_traverse_data.  */\n \n static rtx\n-read_rtx_1 (struct map_value **mode_maps)\n+read_rtx_code (const char *code_name, struct map_value **mode_maps)\n {\n   int i;\n   RTX_CODE real_code, bellwether_code;\n@@ -897,55 +893,7 @@ read_rtx_1 (struct map_value **mode_maps)\n       rtx value;\t\t/* Value of this node.  */\n     };\n \n- again:\n-  c = read_skip_spaces (); /* Should be open paren.  */\n-\n-  if (c == EOF)\n-    return 0;\n-\n-  if (c != '(')\n-    fatal_expected_char ('(', c);\n-\n-  read_name (&name);\n-  if (strcmp (name.string, \"nil\") == 0)\n-    {\n-      /* (nil) stands for an expression that isn't there.  */\n-      c = read_skip_spaces ();\n-      if (c != ')')\n-\tfatal_expected_char (')', c);\n-      return 0;\n-    }\n-  if (strcmp (name.string, \"define_constants\") == 0)\n-    {\n-      read_constants ();\n-      goto again;\n-    }\n-  if (strcmp (name.string, \"define_conditions\") == 0)\n-    {\n-      read_conditions ();\n-      goto again;\n-    }\n-  if (strcmp (name.string, \"define_mode_attr\") == 0)\n-    {\n-      read_mapping (&modes, modes.attrs);\n-      goto again;\n-    }\n-  if (strcmp (name.string, \"define_mode_iterator\") == 0)\n-    {\n-      read_mapping (&modes, modes.iterators);\n-      goto again;\n-    }\n-  if (strcmp (name.string, \"define_code_attr\") == 0)\n-    {\n-      read_mapping (&codes, codes.attrs);\n-      goto again;\n-    }\n-  if (strcmp (name.string, \"define_code_iterator\") == 0)\n-    {\n-      check_code_iterator (read_mapping (&codes, codes.iterators));\n-      goto again;\n-    }\n-  real_code = (enum rtx_code) find_iterator (&codes, name.string);\n+  real_code = (enum rtx_code) find_iterator (&codes, code_name);\n   bellwether_code = BELLWETHER_CODE (real_code);\n \n   /* If we end up with an insn expression then we free this space below.  */\n@@ -983,7 +931,7 @@ read_rtx_1 (struct map_value **mode_maps)\n \n       case 'e':\n       case 'u':\n-\tXEXP (return_rtx, i) = read_rtx_1 (mode_maps);\n+\tXEXP (return_rtx, i) = read_nested_rtx (mode_maps);\n \tbreak;\n \n       case 'V':\n@@ -1017,7 +965,7 @@ read_rtx_1 (struct map_value **mode_maps)\n \t\tfatal_expected_char (']', c);\n \t      unread_char (c);\n \t      list_counter++;\n-\t      obstack_ptr_grow (&vector_stack, read_rtx_1 (mode_maps));\n+\t      obstack_ptr_grow (&vector_stack, read_nested_rtx (mode_maps));\n \t    }\n \t  if (list_counter > 0)\n \t    {\n@@ -1121,17 +1069,41 @@ read_rtx_1 (struct map_value **mode_maps)\n \tgcc_unreachable ();\n       }\n \n+  c = read_skip_spaces ();\n+  /* Syntactic sugar for AND and IOR, allowing Lisp-like\n+     arbitrary number of arguments for them.  */\n+  if (c == '('\n+      && (GET_CODE (return_rtx) == AND\n+\t  || GET_CODE (return_rtx) == IOR))\n+    return read_rtx_variadic (mode_maps, return_rtx);\n+\n+  unread_char (c);\n+  return return_rtx;\n+}\n+\n+/* Read a nested rtx construct from the MD file and return it.\n+   MODE_MAPS is as for iterator_traverse_data.  */\n+\n+static rtx\n+read_nested_rtx (struct map_value **mode_maps)\n+{\n+  struct md_name name;\n+  int c;\n+  rtx return_rtx;\n+\n+  c = read_skip_spaces ();\n+  if (c != '(')\n+    fatal_expected_char ('(', c);\n+\n+  read_name (&name);\n+  if (strcmp (name.string, \"nil\") == 0)\n+    return_rtx = NULL;\n+  else\n+    return_rtx = read_rtx_code (name.string, mode_maps);\n+\n   c = read_skip_spaces ();\n   if (c != ')')\n-    {\n-      /* Syntactic sugar for AND and IOR, allowing Lisp-like\n-\t arbitrary number of arguments for them.  */\n-      if (c == '(' && (GET_CODE (return_rtx) == AND\n-\t\t       || GET_CODE (return_rtx) == IOR))\n-\treturn read_rtx_variadic (mode_maps, return_rtx);\n-      else\n-\tfatal_expected_char (')', c);\n-    }\n+    fatal_expected_char (')', c);\n \n   return return_rtx;\n }\n@@ -1156,16 +1128,13 @@ read_rtx_variadic (struct map_value **mode_maps, rtx form)\n       PUT_MODE (q, GET_MODE (p));\n \n       XEXP (q, 0) = XEXP (p, 1);\n-      XEXP (q, 1) = read_rtx_1 (mode_maps);\n+      XEXP (q, 1) = read_nested_rtx (mode_maps);\n \n       XEXP (p, 1) = q;\n       p = q;\n       c = read_skip_spaces ();\n     }\n   while (c == '(');\n-\n-  if (c != ')')\n-    fatal_expected_char (')', c);\n-\n+  unread_char (c);\n   return form;\n }"}, {"sha": "8464d32e7f9b67f94a406ed3d70b873b149b5986", "filename": "gcc/rtl.def", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600ab3fcfa44ffe8f6c384333d3254ec610a3da7/gcc%2Frtl.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600ab3fcfa44ffe8f6c384333d3254ec610a3da7/gcc%2Frtl.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.def?ref=600ab3fcfa44ffe8f6c384333d3254ec610a3da7", "patch": "@@ -715,9 +715,6 @@ DEF_RTL_EXPR(VAR_LOCATION, \"var_location\", \"tei\", RTX_EXTRA)\n    descriptions.  */\n #ifdef GENERATOR_FILE\n \n-/* Include a secondary machine-description file at this point.  */\n-DEF_RTL_EXPR(INCLUDE, \"include\", \"s\", RTX_EXTRA)\n-\n /* Pattern-matching operators:  */\n \n /* Use the function named by the second arg (the string)"}, {"sha": "6be88d16ed3753241749612c5021065ea2243f57", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600ab3fcfa44ffe8f6c384333d3254ec610a3da7/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600ab3fcfa44ffe8f6c384333d3254ec610a3da7/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=600ab3fcfa44ffe8f6c384333d3254ec610a3da7", "patch": "@@ -2357,7 +2357,7 @@ extern void init_varasm_once (void);\n extern rtx make_debug_expr_from_rtl (const_rtx);\n \n /* In read-rtl.c */\n-extern bool read_rtx (rtx *, int *);\n+extern bool read_rtx (const char *, rtx *);\n \n /* In alias.c */\n extern rtx canon_rtx (rtx);"}]}