{"sha": "8a95f4e86791d06494bd5fc8b0da29b9651530fb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGE5NWY0ZTg2NzkxZDA2NDk0YmQ1ZmM4YjBkYTI5Yjk2NTE1MzBmYg==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2010-06-17T09:57:32Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-06-17T09:57:32Z"}, "message": "sem_intr.adb, [...]: Minor reformatting.\n\n2010-06-17  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_intr.adb, sem_prag.adb, sem_res.adb, sem_type.adb, sem_util.adb,\n\tsem_warn.adb, sem_eval.adb: Minor reformatting.  Use Ekind_In.\n\t(Set_Slice_Subtype): Explicitly freeze the slice's itype at the point\n\twhere the slice's actions are inserted.\n\t(Decompose_Expr): Account for possible rewriting of slice bounds\n\tresulting from side effects suppression caused by the above freezing,\n\tso that folding of bounds is preserved by such rewriting.\n\n2010-06-17  Robert Dewar  <dewar@adacore.com>\n\n\t* einfo.ads, einfo.adb (Get_Record_Representation_Clause): New function.\n\t* freeze.adb (Freeze_Record_Type): Add call to\n\tCheck_Record_Representation_Clause.\n\t* sem_ch13.adb (Check_Record_Representation_Clause): New function\n\t(Analyze_Record_Representation_Clause): Split out overlap code into this\n\tnew function.\n\t(Check_Component_Overlap): Moved inside\n\tCheck_Record_Representation_Clause.\n\t* sem_ch13.ads (Check_Record_Representation_Clause): New function.\n\nFrom-SVN: r160892", "tree": {"sha": "ffaf92cdf6f090cddfad2f2f57c2f05d9ad2a9c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ffaf92cdf6f090cddfad2f2f57c2f05d9ad2a9c8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8a95f4e86791d06494bd5fc8b0da29b9651530fb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a95f4e86791d06494bd5fc8b0da29b9651530fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a95f4e86791d06494bd5fc8b0da29b9651530fb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a95f4e86791d06494bd5fc8b0da29b9651530fb/comments", "author": null, "committer": null, "parents": [{"sha": "e1b871e93c547d7fe50bc5c30fb18c1bd3ba16da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1b871e93c547d7fe50bc5c30fb18c1bd3ba16da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e1b871e93c547d7fe50bc5c30fb18c1bd3ba16da"}], "stats": {"total": 1995, "additions": 1112, "deletions": 883}, "files": [{"sha": "33e1f43d3ce4f7345793d2d2c90f311b1bcb0faf", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a95f4e86791d06494bd5fc8b0da29b9651530fb/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a95f4e86791d06494bd5fc8b0da29b9651530fb/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=8a95f4e86791d06494bd5fc8b0da29b9651530fb", "patch": "@@ -1,3 +1,25 @@\n+2010-06-17  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_intr.adb, sem_prag.adb, sem_res.adb, sem_type.adb, sem_util.adb,\n+\tsem_warn.adb, sem_eval.adb: Minor reformatting.  Use Ekind_In.\n+\t(Set_Slice_Subtype): Explicitly freeze the slice's itype at the point\n+\twhere the slice's actions are inserted.\n+\t(Decompose_Expr): Account for possible rewriting of slice bounds\n+\tresulting from side effects suppression caused by the above freezing,\n+\tso that folding of bounds is preserved by such rewriting.\n+\n+2010-06-17  Robert Dewar  <dewar@adacore.com>\n+\n+\t* einfo.ads, einfo.adb (Get_Record_Representation_Clause): New function.\n+\t* freeze.adb (Freeze_Record_Type): Add call to\n+\tCheck_Record_Representation_Clause.\n+\t* sem_ch13.adb (Check_Record_Representation_Clause): New function\n+\t(Analyze_Record_Representation_Clause): Split out overlap code into this\n+\tnew function.\n+\t(Check_Component_Overlap): Moved inside\n+\tCheck_Record_Representation_Clause.\n+\t* sem_ch13.ads (Check_Record_Representation_Clause): New function.\n+\n 2010-06-17  Robert Dewar  <dewar@adacore.com>\n \n \t* back_end.adb, sem_res.adb, switch-c.adb, sem_scil.adb: Minor"}, {"sha": "da4ed3819295b20626cc561cb14c3e3950507b52", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a95f4e86791d06494bd5fc8b0da29b9651530fb/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a95f4e86791d06494bd5fc8b0da29b9651530fb/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=8a95f4e86791d06494bd5fc8b0da29b9651530fb", "patch": "@@ -5760,6 +5760,26 @@ package body Einfo is\n       end if;\n    end Get_Full_View;\n \n+   --------------------------------------\n+   -- Get_Record_Representation_Clause --\n+   --------------------------------------\n+\n+   function Get_Record_Representation_Clause (E : Entity_Id) return Node_Id is\n+      N : Node_Id;\n+\n+   begin\n+      N := First_Rep_Item (E);\n+      while Present (N) loop\n+         if Nkind (N) = N_Record_Representation_Clause then\n+            return N;\n+         end if;\n+\n+         Next_Rep_Item (N);\n+      end loop;\n+\n+      return Empty;\n+   end Get_Record_Representation_Clause;\n+\n    --------------------\n    -- Get_Rep_Pragma --\n    --------------------"}, {"sha": "99c7141052067188368d01b80a0765622327fe66", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a95f4e86791d06494bd5fc8b0da29b9651530fb/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a95f4e86791d06494bd5fc8b0da29b9651530fb/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=8a95f4e86791d06494bd5fc8b0da29b9651530fb", "patch": "@@ -6767,6 +6767,11 @@ package Einfo is\n    --  value returned is the N_Attribute_Definition_Clause node, otherwise\n    --  Empty is returned.\n \n+   function Get_Record_Representation_Clause (E : Entity_Id) return Node_Id;\n+   --  Searches the Rep_Item chain for a given entyt E, for a record\n+   --  representation clause, and if found, returns it. Returns Empty\n+   --  if no such clause is found.\n+\n    function Get_Rep_Pragma (E : Entity_Id; Nam : Name_Id) return Node_Id;\n    --  Searches the Rep_Item chain for the given entity E, for an instance\n    --  a representation pragma with the given name Nam. If found then the"}, {"sha": "0f126cf555819c3fb63cfe4e272bd3950d19d9a7", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 19, "deletions": 125, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a95f4e86791d06494bd5fc8b0da29b9651530fb/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a95f4e86791d06494bd5fc8b0da29b9651530fb/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=8a95f4e86791d06494bd5fc8b0da29b9651530fb", "patch": "@@ -1776,7 +1776,7 @@ package body Freeze is\n          Prev := Empty;\n          while Present (Comp) loop\n \n-            --  First handle the (real) component case\n+            --  First handle the component case\n \n             if Ekind (Comp) = E_Component\n               or else Ekind (Comp) = E_Discriminant\n@@ -1847,129 +1847,12 @@ package body Freeze is\n                            Component_Name (Component_Clause (Comp)));\n                      end if;\n                   end if;\n-\n-                  --  If component clause is present, then deal with the non-\n-                  --  default bit order case for Ada 95 mode. The required\n-                  --  processing for Ada 2005 mode is handled separately after\n-                  --  processing all components.\n-\n-                  --  We only do this processing for the base type, and in\n-                  --  fact that's important, since otherwise if there are\n-                  --  record subtypes, we could reverse the bits once for\n-                  --  each subtype, which would be incorrect.\n-\n-                  if Present (CC)\n-                    and then Reverse_Bit_Order (Rec)\n-                    and then Ekind (E) = E_Record_Type\n-                    and then Ada_Version <= Ada_95\n-                  then\n-                     declare\n-                        CFB : constant Uint    := Component_Bit_Offset (Comp);\n-                        CSZ : constant Uint    := Esize (Comp);\n-                        CLC : constant Node_Id := Component_Clause (Comp);\n-                        Pos : constant Node_Id := Position (CLC);\n-                        FB  : constant Node_Id := First_Bit (CLC);\n-\n-                        Storage_Unit_Offset : constant Uint :=\n-                                                CFB / System_Storage_Unit;\n-\n-                        Start_Bit : constant Uint :=\n-                                      CFB mod System_Storage_Unit;\n-\n-                     begin\n-                        --  Cases where field goes over storage unit boundary\n-\n-                        if Start_Bit + CSZ > System_Storage_Unit then\n-\n-                           --  Allow multi-byte field but generate warning\n-\n-                           if Start_Bit mod System_Storage_Unit = 0\n-                             and then CSZ mod System_Storage_Unit = 0\n-                           then\n-                              Error_Msg_N\n-                                (\"multi-byte field specified with non-standard\"\n-                                 & \" Bit_Order?\", CLC);\n-\n-                              if Bytes_Big_Endian then\n-                                 Error_Msg_N\n-                                   (\"bytes are not reversed \"\n-                                    & \"(component is big-endian)?\", CLC);\n-                              else\n-                                 Error_Msg_N\n-                                   (\"bytes are not reversed \"\n-                                    & \"(component is little-endian)?\", CLC);\n-                              end if;\n-\n-                           --  Do not allow non-contiguous field\n-\n-                           else\n-                              Error_Msg_N\n-                                (\"attempt to specify non-contiguous field \"\n-                                 & \"not permitted\", CLC);\n-                              Error_Msg_N\n-                                (\"\\caused by non-standard Bit_Order \"\n-                                 & \"specified\", CLC);\n-                              Error_Msg_N\n-                                (\"\\consider possibility of using \"\n-                                 & \"Ada 2005 mode here\", CLC);\n-                           end if;\n-\n-                        --  Case where field fits in one storage unit\n-\n-                        else\n-                           --  Give warning if suspicious component clause\n-\n-                           if Intval (FB) >= System_Storage_Unit\n-                             and then Warn_On_Reverse_Bit_Order\n-                           then\n-                              Error_Msg_N\n-                                (\"?Bit_Order clause does not affect \" &\n-                                 \"byte ordering\", Pos);\n-                              Error_Msg_Uint_1 :=\n-                                Intval (Pos) + Intval (FB) /\n-                                  System_Storage_Unit;\n-                              Error_Msg_N\n-                                (\"?position normalized to ^ before bit \" &\n-                                 \"order interpreted\", Pos);\n-                           end if;\n-\n-                           --  Here is where we fix up the Component_Bit_Offset\n-                           --  value to account for the reverse bit order.\n-                           --  Some examples of what needs to be done are:\n-\n-                           --    First_Bit .. Last_Bit     Component_Bit_Offset\n-                           --      old          new          old       new\n-\n-                           --     0 .. 0       7 .. 7         0         7\n-                           --     0 .. 1       6 .. 7         0         6\n-                           --     0 .. 2       5 .. 7         0         5\n-                           --     0 .. 7       0 .. 7         0         4\n-\n-                           --     1 .. 1       6 .. 6         1         6\n-                           --     1 .. 4       3 .. 6         1         3\n-                           --     4 .. 7       0 .. 3         4         0\n-\n-                           --  The general rule is that the first bit is\n-                           --  is obtained by subtracting the old ending bit\n-                           --  from storage_unit - 1.\n-\n-                           Set_Component_Bit_Offset\n-                             (Comp,\n-                              (Storage_Unit_Offset * System_Storage_Unit) +\n-                                (System_Storage_Unit - 1) -\n-                                  (Start_Bit + CSZ - 1));\n-\n-                           Set_Normalized_First_Bit\n-                             (Comp,\n-                                Component_Bit_Offset (Comp) mod\n-                                  System_Storage_Unit);\n-                        end if;\n-                     end;\n-                  end if;\n                end;\n             end if;\n \n-            --  Gather data for possible Implicit_Packing later\n+            --  Gather data for possible Implicit_Packing later. Note that at\n+            --  this stage we might be dealing with a real component, or with\n+            --  an implicit subtype declaration.\n \n             if not Is_Scalar_Type (Etype (Comp)) then\n                All_Scalar_Components := False;\n@@ -2118,7 +2001,7 @@ package body Freeze is\n             Next_Entity (Comp);\n          end loop;\n \n-         --  Deal with pragma Bit_Order\n+         --  Deal with pragma Bit_Order setting non-standard bit order\n \n          if Reverse_Bit_Order (Rec) and then Base_Type (Rec) = Rec then\n             if not Placed_Component then\n@@ -2129,14 +2012,25 @@ package body Freeze is\n                Error_Msg_N\n                  (\"\\?since no component clauses were specified\", ADC);\n \n-            --  Here is where we do Ada 2005 processing for bit order (the Ada\n-            --  95 case was already taken care of above).\n+            --  Here is where we do the processing for reversed bit order\n \n-            elsif Ada_Version >= Ada_05 then\n+            else\n                Adjust_Record_For_Reverse_Bit_Order (Rec);\n             end if;\n          end if;\n \n+         --  Complete error checking on record representation clause (e.g.\n+         --  overlap of components). This is called after adjusting the\n+         --  record for reverse bit order.\n+\n+         declare\n+            RRC : constant Node_Id := Get_Record_Representation_Clause (Rec);\n+         begin\n+            if Present (RRC) then\n+               Check_Record_Representation_Clause (RRC);\n+            end if;\n+         end;\n+\n          --  Set OK_To_Reorder_Components depending on debug flags\n \n          if Rec = Base_Type (Rec)"}, {"sha": "7e2fe5fdf263c67ead865ee1b0da8d7c74672f51", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 944, "deletions": 650, "changes": 1594, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a95f4e86791d06494bd5fc8b0da29b9651530fb/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a95f4e86791d06494bd5fc8b0da29b9651530fb/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=8a95f4e86791d06494bd5fc8b0da29b9651530fb", "patch": "@@ -73,10 +73,6 @@ package body Sem_Ch13 is\n    --  inherited from a derived type that is no longer appropriate for the\n    --  new Esize value. In this case, we reset the Alignment to unknown.\n \n-   procedure Check_Component_Overlap (C1_Ent, C2_Ent : Entity_Id);\n-   --  Given two entities for record components or discriminants, checks\n-   --  if they have overlapping component clauses and issues errors if so.\n-\n    function Get_Alignment_Value (Expr : Node_Id) return Uint;\n    --  Given the expression for an alignment value, returns the corresponding\n    --  Uint value. If the value is inappropriate, then error messages are\n@@ -180,265 +176,421 @@ package body Sem_Ch13 is\n    -----------------------------------------\n \n    procedure Adjust_Record_For_Reverse_Bit_Order (R : Entity_Id) is\n-      Max_Machine_Scalar_Size : constant Uint :=\n-                                  UI_From_Int\n-                                    (Standard_Long_Long_Integer_Size);\n-      --  We use this as the maximum machine scalar size in the sense of AI-133\n-\n-      Num_CC : Natural;\n-      Comp   : Entity_Id;\n-      SSU    : constant Uint := UI_From_Int (System_Storage_Unit);\n+      Comp : Node_Id;\n+      CC   : Node_Id;\n \n    begin\n-      --  This first loop through components does two things. First it deals\n-      --  with the case of components with component clauses whose length is\n-      --  greater than the maximum machine scalar size (either accepting them\n-      --  or rejecting as needed). Second, it counts the number of components\n-      --  with component clauses whose length does not exceed this maximum for\n-      --  later processing.\n-\n-      Num_CC := 0;\n-      Comp   := First_Component_Or_Discriminant (R);\n-      while Present (Comp) loop\n-         declare\n-            CC : constant Node_Id := Component_Clause (Comp);\n+      --  Processing depends on version of Ada\n \n-         begin\n-            if Present (CC) then\n-               declare\n-                  Fbit : constant Uint := Static_Integer (First_Bit (CC));\n+      case Ada_Version is\n \n-               begin\n-                  --  Case of component with size > max machine scalar\n+         --  For Ada 95, we just renumber bits within a storage unit. We do\n+         --  the same for Ada 83 mode, since we recognize pragma Bit_Order\n+         --  in Ada 83, and are free to add this extension.\n \n-                  if Esize (Comp) > Max_Machine_Scalar_Size then\n+         when Ada_83 | Ada_95 =>\n+            Comp := First_Component_Or_Discriminant (R);\n+            while Present (Comp) loop\n+               CC := Component_Clause (Comp);\n \n-                     --  Must begin on byte boundary\n+               --  If component clause is present, then deal with the non-\n+               --  default bit order case for Ada 95 mode.\n \n-                     if Fbit mod SSU /= 0 then\n-                        Error_Msg_N\n-                          (\"illegal first bit value for reverse bit order\",\n-                           First_Bit (CC));\n-                        Error_Msg_Uint_1 := SSU;\n-                        Error_Msg_Uint_2 := Max_Machine_Scalar_Size;\n+               --  We only do this processing for the base type, and in\n+               --  fact that's important, since otherwise if there are\n+               --  record subtypes, we could reverse the bits once for\n+               --  each subtype, which would be incorrect.\n \n-                        Error_Msg_N\n-                          (\"\\must be a multiple of ^ if size greater than ^\",\n-                           First_Bit (CC));\n+               if Present (CC)\n+                 and then Ekind (R) = E_Record_Type\n+               then\n+                  declare\n+                     CFB : constant Uint    := Component_Bit_Offset (Comp);\n+                     CSZ : constant Uint    := Esize (Comp);\n+                     CLC : constant Node_Id := Component_Clause (Comp);\n+                     Pos : constant Node_Id := Position (CLC);\n+                     FB  : constant Node_Id := First_Bit (CLC);\n \n-                     --  Must end on byte boundary\n+                     Storage_Unit_Offset : constant Uint :=\n+                                             CFB / System_Storage_Unit;\n \n-                     elsif Esize (Comp) mod SSU /= 0 then\n-                        Error_Msg_N\n-                          (\"illegal last bit value for reverse bit order\",\n-                           Last_Bit (CC));\n-                        Error_Msg_Uint_1 := SSU;\n-                        Error_Msg_Uint_2 := Max_Machine_Scalar_Size;\n+                     Start_Bit : constant Uint :=\n+                                   CFB mod System_Storage_Unit;\n \n-                        Error_Msg_N\n-                          (\"\\must be a multiple of ^ if size greater than ^\",\n-                           Last_Bit (CC));\n+                  begin\n+                     --  Cases where field goes over storage unit boundary\n \n-                     --  OK, give warning if enabled\n+                     if Start_Bit + CSZ > System_Storage_Unit then\n \n-                     elsif Warn_On_Reverse_Bit_Order then\n-                        Error_Msg_N\n-                          (\"multi-byte field specified with non-standard\"\n-                           & \" Bit_Order?\", CC);\n+                        --  Allow multi-byte field but generate warning\n \n-                        if Bytes_Big_Endian then\n+                        if Start_Bit mod System_Storage_Unit = 0\n+                          and then CSZ mod System_Storage_Unit = 0\n+                        then\n                            Error_Msg_N\n-                             (\"\\bytes are not reversed \"\n-                              & \"(component is big-endian)?\", CC);\n+                             (\"multi-byte field specified with non-standard\"\n+                              & \" Bit_Order?\", CLC);\n+\n+                           if Bytes_Big_Endian then\n+                              Error_Msg_N\n+                                (\"bytes are not reversed \"\n+                                 & \"(component is big-endian)?\", CLC);\n+                           else\n+                              Error_Msg_N\n+                                (\"bytes are not reversed \"\n+                                 & \"(component is little-endian)?\", CLC);\n+                           end if;\n+\n+                           --  Do not allow non-contiguous field\n+\n                         else\n                            Error_Msg_N\n-                             (\"\\bytes are not reversed \"\n-                              & \"(component is little-endian)?\", CC);\n+                             (\"attempt to specify non-contiguous field \"\n+                              & \"not permitted\", CLC);\n+                           Error_Msg_N\n+                             (\"\\caused by non-standard Bit_Order \"\n+                              & \"specified\", CLC);\n+                           Error_Msg_N\n+                             (\"\\consider possibility of using \"\n+                              & \"Ada 2005 mode here\", CLC);\n                         end if;\n-                     end if;\n \n-                     --  Case where size is not greater than max machine\n-                     --  scalar. For now, we just count these.\n+                        --  Case where field fits in one storage unit\n \n-                  else\n-                     Num_CC := Num_CC + 1;\n-                  end if;\n-               end;\n-            end if;\n-         end;\n+                     else\n+                        --  Give warning if suspicious component clause\n \n-         Next_Component_Or_Discriminant (Comp);\n-      end loop;\n+                        if Intval (FB) >= System_Storage_Unit\n+                          and then Warn_On_Reverse_Bit_Order\n+                        then\n+                           Error_Msg_N\n+                             (\"?Bit_Order clause does not affect \" &\n+                              \"byte ordering\", Pos);\n+                           Error_Msg_Uint_1 :=\n+                             Intval (Pos) + Intval (FB) /\n+                             System_Storage_Unit;\n+                           Error_Msg_N\n+                             (\"?position normalized to ^ before bit \" &\n+                              \"order interpreted\", Pos);\n+                        end if;\n \n-      --  We need to sort the component clauses on the basis of the Position\n-      --  values in the clause, so we can group clauses with the same Position.\n-      --  together to determine the relevant machine scalar size.\n+                        --  Here is where we fix up the Component_Bit_Offset\n+                        --  value to account for the reverse bit order.\n+                        --  Some examples of what needs to be done are:\n \n-      declare\n-         Comps : array (0 .. Num_CC) of Entity_Id;\n-         --  Array to collect component and discriminant entities. The data\n-         --  starts at index 1, the 0'th entry is for the sort routine.\n+                        --    First_Bit .. Last_Bit     Component_Bit_Offset\n+                        --      old          new          old       new\n \n-         function CP_Lt (Op1, Op2 : Natural) return Boolean;\n-         --  Compare routine for Sort\n+                        --     0 .. 0       7 .. 7         0         7\n+                        --     0 .. 1       6 .. 7         0         6\n+                        --     0 .. 2       5 .. 7         0         5\n+                        --     0 .. 7       0 .. 7         0         4\n \n-         procedure CP_Move (From : Natural; To : Natural);\n-         --  Move routine for Sort\n+                        --     1 .. 1       6 .. 6         1         6\n+                        --     1 .. 4       3 .. 6         1         3\n+                        --     4 .. 7       0 .. 3         4         0\n \n-         package Sorting is new GNAT.Heap_Sort_G (CP_Move, CP_Lt);\n+                        --  The general rule is that the first bit is\n+                        --  is obtained by subtracting the old ending bit\n+                        --  from storage_unit - 1.\n \n-         Start : Natural;\n-         Stop  : Natural;\n-         --  Start and stop positions in component list of set of components\n-         --  with the same starting position (that constitute components in\n-         --  a single machine scalar).\n+                        Set_Component_Bit_Offset\n+                          (Comp,\n+                           (Storage_Unit_Offset * System_Storage_Unit) +\n+                             (System_Storage_Unit - 1) -\n+                             (Start_Bit + CSZ - 1));\n \n-         MaxL : Uint;\n-         --  Maximum last bit value of any component in this set\n+                        Set_Normalized_First_Bit\n+                          (Comp,\n+                           Component_Bit_Offset (Comp) mod\n+                             System_Storage_Unit);\n+                     end if;\n+                  end;\n+               end if;\n \n-         MSS : Uint;\n-         --  Corresponding machine scalar size\n+               Next_Component_Or_Discriminant (Comp);\n+            end loop;\n \n-         -----------\n-         -- CP_Lt --\n-         -----------\n+         --  For Ada 2005, we do machine scalar processing, as fully described\n+         --  In AI-133. This involves gathering all components which start at\n+         --  the same byte offset and processing them together\n \n-         function CP_Lt (Op1, Op2 : Natural) return Boolean is\n-         begin\n-            return Position (Component_Clause (Comps (Op1))) <\n-                   Position (Component_Clause (Comps (Op2)));\n-         end CP_Lt;\n+         when Ada_05 =>\n+            declare\n+               Max_Machine_Scalar_Size : constant Uint :=\n+                                           UI_From_Int\n+                                             (Standard_Long_Long_Integer_Size);\n+            --  We use this as the maximum machine scalar size\n \n-         -------------\n-         -- CP_Move --\n-         -------------\n+               Num_CC : Natural;\n+               SSU    : constant Uint := UI_From_Int (System_Storage_Unit);\n \n-         procedure CP_Move (From : Natural; To : Natural) is\n-         begin\n-            Comps (To) := Comps (From);\n-         end CP_Move;\n+            begin\n+               --  This first loop through components does two things. First it\n+               --  deals with the case of components with component clauses\n+               --  whose length is greater than the maximum machine scalar size\n+               --  (either accepting them or rejecting as needed). Second, it\n+               --  counts the number of components with component clauses whose\n+               --  length does not exceed this maximum for later processing.\n+\n+               Num_CC := 0;\n+               Comp   := First_Component_Or_Discriminant (R);\n+               while Present (Comp) loop\n+                  CC := Component_Clause (Comp);\n \n-      begin\n-         --  Collect the component clauses\n+                  if Present (CC) then\n+                     declare\n+                        Fbit : constant Uint :=\n+                                 Static_Integer (First_Bit (CC));\n \n-         Num_CC := 0;\n-         Comp   := First_Component_Or_Discriminant (R);\n-         while Present (Comp) loop\n-            if Present (Component_Clause (Comp))\n-              and then Esize (Comp) <= Max_Machine_Scalar_Size\n-            then\n-               Num_CC := Num_CC + 1;\n-               Comps (Num_CC) := Comp;\n-            end if;\n+                     begin\n+                        --  Case of component with size > max machine scalar\n+\n+                        if Esize (Comp) > Max_Machine_Scalar_Size then\n+\n+                           --  Must begin on byte boundary\n+\n+                           if Fbit mod SSU /= 0 then\n+                              Error_Msg_N\n+                                (\"illegal first bit value for \"\n+                                 & \"reverse bit order\",\n+                                 First_Bit (CC));\n+                              Error_Msg_Uint_1 := SSU;\n+                              Error_Msg_Uint_2 := Max_Machine_Scalar_Size;\n+\n+                              Error_Msg_N\n+                                (\"\\must be a multiple of ^ \"\n+                                 & \"if size greater than ^\",\n+                                 First_Bit (CC));\n+\n+                              --  Must end on byte boundary\n+\n+                           elsif Esize (Comp) mod SSU /= 0 then\n+                              Error_Msg_N\n+                                (\"illegal last bit value for \"\n+                                 & \"reverse bit order\",\n+                                 Last_Bit (CC));\n+                              Error_Msg_Uint_1 := SSU;\n+                              Error_Msg_Uint_2 := Max_Machine_Scalar_Size;\n+\n+                              Error_Msg_N\n+                                (\"\\must be a multiple of ^ if size \"\n+                                 & \"greater than ^\",\n+                                 Last_Bit (CC));\n+\n+                              --  OK, give warning if enabled\n+\n+                           elsif Warn_On_Reverse_Bit_Order then\n+                              Error_Msg_N\n+                                (\"multi-byte field specified with \"\n+                                 & \"  non-standard Bit_Order?\", CC);\n+\n+                              if Bytes_Big_Endian then\n+                                 Error_Msg_N\n+                                   (\"\\bytes are not reversed \"\n+                                    & \"(component is big-endian)?\", CC);\n+                              else\n+                                 Error_Msg_N\n+                                   (\"\\bytes are not reversed \"\n+                                    & \"(component is little-endian)?\", CC);\n+                              end if;\n+                           end if;\n \n-            Next_Component_Or_Discriminant (Comp);\n-         end loop;\n+                           --  Case where size is not greater than max machine\n+                           --  scalar. For now, we just count these.\n \n-         --  Sort by ascending position number\n-\n-         Sorting.Sort (Num_CC);\n-\n-         --  We now have all the components whose size does not exceed the max\n-         --  machine scalar value, sorted by starting position. In this loop\n-         --  we gather groups of clauses starting at the same position, to\n-         --  process them in accordance with Ada 2005 AI-133.\n-\n-         Stop := 0;\n-         while Stop < Num_CC loop\n-            Start := Stop + 1;\n-            Stop  := Start;\n-            MaxL  :=\n-              Static_Integer (Last_Bit (Component_Clause (Comps (Start))));\n-            while Stop < Num_CC loop\n-               if Static_Integer\n-                    (Position (Component_Clause (Comps (Stop + 1)))) =\n-                  Static_Integer\n-                    (Position (Component_Clause (Comps (Stop))))\n-               then\n-                  Stop := Stop + 1;\n-                  MaxL :=\n-                    UI_Max\n-                      (MaxL,\n-                       Static_Integer\n-                         (Last_Bit (Component_Clause (Comps (Stop)))));\n-               else\n-                  exit;\n-               end if;\n-            end loop;\n+                        else\n+                           Num_CC := Num_CC + 1;\n+                        end if;\n+                     end;\n+                  end if;\n \n-            --  Now we have a group of component clauses from Start to Stop\n-            --  whose positions are identical, and MaxL is the maximum last bit\n-            --  value of any of these components.\n+                  Next_Component_Or_Discriminant (Comp);\n+               end loop;\n \n-            --  We need to determine the corresponding machine scalar size.\n-            --  This loop assumes that machine scalar sizes are even, and that\n-            --  each possible machine scalar has twice as many bits as the\n-            --  next smaller one.\n+               --  We need to sort the component clauses on the basis of the\n+               --  Position values in the clause, so we can group clauses with\n+               --  the same Position. together to determine the relevant\n+               --  machine scalar size.\n \n-            MSS := Max_Machine_Scalar_Size;\n-            while MSS mod 2 = 0\n-              and then (MSS / 2) >= SSU\n-              and then (MSS / 2) > MaxL\n-            loop\n-               MSS := MSS / 2;\n-            end loop;\n+               Sort_CC : declare\n+                  Comps : array (0 .. Num_CC) of Entity_Id;\n+                  --  Array to collect component and discriminant entities. The\n+                  --  data starts at index 1, the 0'th entry is for the sort\n+                  --  routine.\n \n-            --  Here is where we fix up the Component_Bit_Offset value to\n-            --  account for the reverse bit order. Some examples of what needs\n-            --  to be done for the case of a machine scalar size of 8 are:\n+                  function CP_Lt (Op1, Op2 : Natural) return Boolean;\n+                  --  Compare routine for Sort\n \n-            --    First_Bit .. Last_Bit     Component_Bit_Offset\n-            --      old          new          old       new\n+                  procedure CP_Move (From : Natural; To : Natural);\n+                  --  Move routine for Sort\n \n-            --     0 .. 0       7 .. 7         0         7\n-            --     0 .. 1       6 .. 7         0         6\n-            --     0 .. 2       5 .. 7         0         5\n-            --     0 .. 7       0 .. 7         0         4\n+                  package Sorting is new GNAT.Heap_Sort_G (CP_Move, CP_Lt);\n \n-            --     1 .. 1       6 .. 6         1         6\n-            --     1 .. 4       3 .. 6         1         3\n-            --     4 .. 7       0 .. 3         4         0\n+                  Start : Natural;\n+                  Stop  : Natural;\n+                  --  Start and stop positions in component list of set of\n+                  --  components with the same starting position (that\n+                  --  constitute components in a single machine scalar).\n \n-            --  The general rule is that the first bit is obtained by\n-            --  subtracting the old ending bit from machine scalar size - 1.\n+                  MaxL  : Uint;\n+                  --  Maximum last bit value of any component in this set\n \n-            for C in Start .. Stop loop\n-               declare\n-                  Comp : constant Entity_Id := Comps (C);\n-                  CC   : constant Node_Id   := Component_Clause (Comp);\n-                  LB   : constant Uint := Static_Integer (Last_Bit (CC));\n-                  NFB  : constant Uint := MSS - Uint_1 - LB;\n-                  NLB  : constant Uint := NFB + Esize (Comp) - 1;\n-                  Pos  : constant Uint := Static_Integer (Position (CC));\n+                  MSS   : Uint;\n+                  --  Corresponding machine scalar size\n+\n+                  -----------\n+                  -- CP_Lt --\n+                  -----------\n+\n+                  function CP_Lt (Op1, Op2 : Natural) return Boolean is\n+                  begin\n+                     return Position (Component_Clause (Comps (Op1))) <\n+                            Position (Component_Clause (Comps (Op2)));\n+                  end CP_Lt;\n+\n+                  -------------\n+                  -- CP_Move --\n+                  -------------\n+\n+                  procedure CP_Move (From : Natural; To : Natural) is\n+                  begin\n+                     Comps (To) := Comps (From);\n+                  end CP_Move;\n+\n+               --  Start of processing for Sort_CC\n \n                begin\n-                  if Warn_On_Reverse_Bit_Order then\n-                     Error_Msg_Uint_1 := MSS;\n-                     Error_Msg_N\n-                       (\"info: reverse bit order in machine \" &\n-                       \"scalar of length^?\", First_Bit (CC));\n-                     Error_Msg_Uint_1 := NFB;\n-                     Error_Msg_Uint_2 := NLB;\n+                  --  Collect the component clauses\n \n-                     if Bytes_Big_Endian then\n-                        Error_Msg_NE\n-                          (\"?\\info: big-endian range for \"\n-                           & \"component & is ^ .. ^\",\n-                           First_Bit (CC), Comp);\n-                     else\n-                        Error_Msg_NE\n-                          (\"?\\info: little-endian range \"\n-                           & \"for component & is ^ .. ^\",\n-                           First_Bit (CC), Comp);\n+                  Num_CC := 0;\n+                  Comp   := First_Component_Or_Discriminant (R);\n+                  while Present (Comp) loop\n+                     if Present (Component_Clause (Comp))\n+                       and then Esize (Comp) <= Max_Machine_Scalar_Size\n+                     then\n+                        Num_CC := Num_CC + 1;\n+                        Comps (Num_CC) := Comp;\n                      end if;\n-                  end if;\n \n-                  Set_Component_Bit_Offset (Comp, Pos * SSU + NFB);\n-                  Set_Normalized_First_Bit (Comp, NFB mod SSU);\n-               end;\n-            end loop;\n-         end loop;\n-      end;\n+                     Next_Component_Or_Discriminant (Comp);\n+                  end loop;\n+\n+                  --  Sort by ascending position number\n+\n+                  Sorting.Sort (Num_CC);\n+\n+                  --  We now have all the components whose size does not exceed\n+                  --  the max machine scalar value, sorted by starting\n+                  --  position. In this loop we gather groups of clauses\n+                  --  starting at the same position, to process them in\n+                  --  accordance with Ada 2005 AI-133.\n+\n+                  Stop := 0;\n+                  while Stop < Num_CC loop\n+                     Start := Stop + 1;\n+                     Stop  := Start;\n+                     MaxL  :=\n+                       Static_Integer\n+                         (Last_Bit (Component_Clause (Comps (Start))));\n+                     while Stop < Num_CC loop\n+                        if Static_Integer\n+                             (Position (Component_Clause (Comps (Stop + 1)))) =\n+                           Static_Integer\n+                             (Position (Component_Clause (Comps (Stop))))\n+                        then\n+                           Stop := Stop + 1;\n+                           MaxL :=\n+                             UI_Max\n+                               (MaxL,\n+                                Static_Integer\n+                                  (Last_Bit\n+                                     (Component_Clause (Comps (Stop)))));\n+                        else\n+                           exit;\n+                        end if;\n+                     end loop;\n+\n+                     --  Now we have a group of component clauses from Start to\n+                     --  Stop whose positions are identical, and MaxL is the\n+                     --  maximum last bit value of any of these components.\n+\n+                     --  We need to determine the corresponding machine scalar\n+                     --  size. This loop assumes that machine scalar sizes are\n+                     --  even, and that each possible machine scalar has twice\n+                     --  as many bits as the next smaller one.\n+\n+                     MSS := Max_Machine_Scalar_Size;\n+                     while MSS mod 2 = 0\n+                       and then (MSS / 2) >= SSU\n+                       and then (MSS / 2) > MaxL\n+                     loop\n+                        MSS := MSS / 2;\n+                     end loop;\n+\n+                     --  Here is where we fix up the Component_Bit_Offset value\n+                     --  to account for the reverse bit order. Some examples of\n+                     --  what needs to be done for the case of a machine scalar\n+                     --  size of 8 are:\n+\n+                     --    First_Bit .. Last_Bit     Component_Bit_Offset\n+                     --      old          new          old       new\n+\n+                     --     0 .. 0       7 .. 7         0         7\n+                     --     0 .. 1       6 .. 7         0         6\n+                     --     0 .. 2       5 .. 7         0         5\n+                     --     0 .. 7       0 .. 7         0         4\n+\n+                     --     1 .. 1       6 .. 6         1         6\n+                     --     1 .. 4       3 .. 6         1         3\n+                     --     4 .. 7       0 .. 3         4         0\n+\n+                     --  The general rule is that the first bit is obtained by\n+                     --  subtracting the old ending bit from machine scalar\n+                     --  size - 1.\n+\n+                     for C in Start .. Stop loop\n+                        declare\n+                           Comp : constant Entity_Id := Comps (C);\n+                           CC   : constant Node_Id   :=\n+                                    Component_Clause (Comp);\n+                           LB   : constant Uint :=\n+                                    Static_Integer (Last_Bit (CC));\n+                           NFB  : constant Uint := MSS - Uint_1 - LB;\n+                           NLB  : constant Uint := NFB + Esize (Comp) - 1;\n+                           Pos  : constant Uint :=\n+                                    Static_Integer (Position (CC));\n+\n+                        begin\n+                           if Warn_On_Reverse_Bit_Order then\n+                              Error_Msg_Uint_1 := MSS;\n+                              Error_Msg_N\n+                                (\"info: reverse bit order in machine \" &\n+                                 \"scalar of length^?\", First_Bit (CC));\n+                              Error_Msg_Uint_1 := NFB;\n+                              Error_Msg_Uint_2 := NLB;\n+\n+                              if Bytes_Big_Endian then\n+                                 Error_Msg_NE\n+                                   (\"?\\info: big-endian range for \"\n+                                    & \"component & is ^ .. ^\",\n+                                    First_Bit (CC), Comp);\n+                              else\n+                                 Error_Msg_NE\n+                                   (\"?\\info: little-endian range \"\n+                                    & \"for component & is ^ .. ^\",\n+                                    First_Bit (CC), Comp);\n+                              end if;\n+                           end if;\n+\n+                           Set_Component_Bit_Offset (Comp, Pos * SSU + NFB);\n+                           Set_Normalized_First_Bit (Comp, NFB mod SSU);\n+                        end;\n+                     end loop;\n+                  end loop;\n+               end Sort_CC;\n+            end;\n+      end case;\n    end Adjust_Record_For_Reverse_Bit_Order;\n \n    --------------------------------------\n@@ -2233,45 +2385,25 @@ package body Sem_Ch13 is\n    -- Analyze_Record_Representation_Clause --\n    ------------------------------------------\n \n+   --  Note: we check as much as we can here, but we can't do any checks\n+   --  based on the position values (e.g. overlap checks) until freeze time\n+   --  because especially in Ada 2005 (machine scalar mode), the processing\n+   --  for non-standard bit order can substantially change the positions.\n+   --  See procedure Check_Record_Representation_Clause (called from Freeze)\n+   --  for the remainder of this processing.\n+\n    procedure Analyze_Record_Representation_Clause (N : Node_Id) is\n-      Loc     : constant Source_Ptr := Sloc (N);\n       Ident   : constant Node_Id    := Identifier (N);\n       Rectype : Entity_Id;\n-      Fent    : Entity_Id;\n       CC      : Node_Id;\n       Posit   : Uint;\n       Fbit    : Uint;\n       Lbit    : Uint;\n       Hbit    : Uint := Uint_0;\n       Comp    : Entity_Id;\n       Ocomp   : Entity_Id;\n-      Pcomp   : Entity_Id;\n       Biased  : Boolean;\n \n-      Max_Bit_So_Far : Uint;\n-      --  Records the maximum bit position so far. If all field positions\n-      --  are monotonically increasing, then we can skip the circuit for\n-      --  checking for overlap, since no overlap is possible.\n-\n-      Tagged_Parent : Entity_Id := Empty;\n-      --  This is set in the case of a derived tagged type for which we have\n-      --  Is_Fully_Repped_Tagged_Type True (indicating that all components are\n-      --  positioned by record representation clauses). In this case we must\n-      --  check for overlap between components of this tagged type, and the\n-      --  components of its parent. Tagged_Parent will point to this parent\n-      --  type. For all other cases Tagged_Parent is left set to Empty.\n-\n-      Parent_Last_Bit : Uint;\n-      --  Relevant only if Tagged_Parent is set, Parent_Last_Bit indicates the\n-      --  last bit position for any field in the parent type. We only need to\n-      --  check overlap for fields starting below this point.\n-\n-      Overlap_Check_Required : Boolean;\n-      --  Used to keep track of whether or not an overlap check is required\n-\n-      Ccount : Natural := 0;\n-      --  Number of component clauses in record rep clause\n-\n       CR_Pragma : Node_Id := Empty;\n       --  Points to N_Pragma node if Complete_Representation pragma present\n \n@@ -2386,36 +2518,6 @@ package body Sem_Ch13 is\n          end loop;\n       end if;\n \n-      --  See if we have a fully repped derived tagged type\n-\n-      declare\n-         PS : constant Entity_Id := Parent_Subtype (Rectype);\n-\n-      begin\n-         if Present (PS) and then Is_Fully_Repped_Tagged_Type (PS) then\n-            Tagged_Parent := PS;\n-\n-            --  Find maximum bit of any component of the parent type\n-\n-            Parent_Last_Bit := UI_From_Int (System_Address_Size - 1);\n-            Pcomp := First_Entity (Tagged_Parent);\n-            while Present (Pcomp) loop\n-               if Ekind_In (Pcomp, E_Discriminant, E_Component) then\n-                  if Component_Bit_Offset (Pcomp) /= No_Uint\n-                    and then Known_Static_Esize (Pcomp)\n-                  then\n-                     Parent_Last_Bit :=\n-                       UI_Max\n-                         (Parent_Last_Bit,\n-                          Component_Bit_Offset (Pcomp) + Esize (Pcomp) - 1);\n-                  end if;\n-\n-                  Next_Entity (Pcomp);\n-               end if;\n-            end loop;\n-         end if;\n-      end;\n-\n       --  All done if no component clauses\n \n       CC := First (Component_Clauses (N));\n@@ -2424,51 +2526,12 @@ package body Sem_Ch13 is\n          return;\n       end if;\n \n-      --  If a tag is present, then create a component clause that places it\n-      --  at the start of the record (otherwise gigi may place it after other\n-      --  fields that have rep clauses).\n-\n-      Fent := First_Entity (Rectype);\n-\n-      if Nkind (Fent) = N_Defining_Identifier\n-        and then Chars (Fent) = Name_uTag\n-      then\n-         Set_Component_Bit_Offset    (Fent, Uint_0);\n-         Set_Normalized_Position     (Fent, Uint_0);\n-         Set_Normalized_First_Bit    (Fent, Uint_0);\n-         Set_Normalized_Position_Max (Fent, Uint_0);\n-         Init_Esize                  (Fent, System_Address_Size);\n-\n-         Set_Component_Clause (Fent,\n-           Make_Component_Clause (Loc,\n-             Component_Name =>\n-               Make_Identifier (Loc,\n-                 Chars => Name_uTag),\n-\n-             Position  =>\n-               Make_Integer_Literal (Loc,\n-                 Intval => Uint_0),\n-\n-             First_Bit =>\n-               Make_Integer_Literal (Loc,\n-                 Intval => Uint_0),\n-\n-             Last_Bit  =>\n-               Make_Integer_Literal (Loc,\n-                 UI_From_Int (System_Address_Size))));\n-\n-         Ccount := Ccount + 1;\n-      end if;\n-\n       --  A representation like this applies to the base type\n \n       Set_Has_Record_Rep_Clause (Base_Type (Rectype));\n       Set_Has_Non_Standard_Rep  (Base_Type (Rectype));\n       Set_Has_Specified_Layout  (Base_Type (Rectype));\n \n-      Max_Bit_So_Far := Uint_Minus_1;\n-      Overlap_Check_Required := False;\n-\n       --  Process the component clauses\n \n       while Present (CC) loop\n@@ -2487,7 +2550,6 @@ package body Sem_Ch13 is\n          --  Processing for real component clause\n \n          else\n-            Ccount := Ccount + 1;\n             Posit := Static_Integer (Position  (CC));\n             Fbit  := Static_Integer (First_Bit (CC));\n             Lbit  := Static_Integer (Last_Bit  (CC));\n@@ -2596,12 +2658,6 @@ package body Sem_Ch13 is\n                      Fbit := Fbit + UI_From_Int (SSU) * Posit;\n                      Lbit := Lbit + UI_From_Int (SSU) * Posit;\n \n-                     if Fbit <= Max_Bit_So_Far then\n-                        Overlap_Check_Required := True;\n-                     else\n-                        Max_Bit_So_Far := Lbit;\n-                     end if;\n-\n                      if Has_Size_Clause (Rectype)\n                        and then Esize (Rectype) <= Lbit\n                      then\n@@ -2615,17 +2671,6 @@ package body Sem_Ch13 is\n                         Set_Normalized_First_Bit (Comp, Fbit mod SSU);\n                         Set_Normalized_Position  (Comp, Fbit / SSU);\n \n-                        Set_Normalized_Position_Max\n-                          (Fent, Normalized_Position (Fent));\n-\n-                        if Is_Tagged_Type (Rectype)\n-                          and then Fbit < System_Address_Size\n-                        then\n-                           Error_Msg_NE\n-                             (\"component overlaps tag field of&\",\n-                              Component_Name (CC), Rectype);\n-                        end if;\n-\n                         --  This information is also set in the corresponding\n                         --  component of the base type, found by accessing the\n                         --  Original_Record_Component link if it is present.\n@@ -2668,27 +2713,6 @@ package body Sem_Ch13 is\n                            Error_Msg_N (\"component size is negative\", CC);\n                         end if;\n                      end if;\n-\n-                     --  If OK component size, check parent type overlap if\n-                     --  this component might overlap a parent field.\n-\n-                     if Present (Tagged_Parent)\n-                       and then Fbit <= Parent_Last_Bit\n-                     then\n-                        Pcomp := First_Entity (Tagged_Parent);\n-                        while Present (Pcomp) loop\n-                           if (Ekind (Pcomp) = E_Discriminant\n-                                or else\n-                               Ekind (Pcomp) = E_Component)\n-                             and then not Is_Tag (Pcomp)\n-                             and then Chars (Pcomp) /= Name_uParent\n-                           then\n-                              Check_Component_Overlap (Comp, Pcomp);\n-                           end if;\n-\n-                           Next_Entity (Pcomp);\n-                        end loop;\n-                     end if;\n                   end if;\n                end if;\n             end if;\n@@ -2697,266 +2721,20 @@ package body Sem_Ch13 is\n          Next (CC);\n       end loop;\n \n-      --  Now that we have processed all the component clauses, check for\n-      --  overlap. We have to leave this till last, since the components can\n-      --  appear in any arbitrary order in the representation clause.\n+      --  Check missing components if Complete_Representation pragma appeared\n \n-      --  We do not need this check if all specified ranges were monotonic,\n-      --  as recorded by Overlap_Check_Required being False at this stage.\n+      if Present (CR_Pragma) then\n+         Comp := First_Component_Or_Discriminant (Rectype);\n+         while Present (Comp) loop\n+            if No (Component_Clause (Comp)) then\n+               Error_Msg_NE\n+                 (\"missing component clause for &\", CR_Pragma, Comp);\n+            end if;\n \n-      --  This first section checks if there are any overlapping entries at\n-      --  all. It does this by sorting all entries and then seeing if there are\n-      --  any overlaps. If there are none, then that is decisive, but if there\n-      --  are overlaps, they may still be OK (they may result from fields in\n-      --  different variants).\n+            Next_Component_Or_Discriminant (Comp);\n+         end loop;\n \n-      if Overlap_Check_Required then\n-         Overlap_Check1 : declare\n-\n-            OC_Fbit : array (0 .. Ccount) of Uint;\n-            --  First-bit values for component clauses, the value is the offset\n-            --  of the first bit of the field from start of record. The zero\n-            --  entry is for use in sorting.\n-\n-            OC_Lbit : array (0 .. Ccount) of Uint;\n-            --  Last-bit values for component clauses, the value is the offset\n-            --  of the last bit of the field from start of record. The zero\n-            --  entry is for use in sorting.\n-\n-            OC_Count : Natural := 0;\n-            --  Count of entries in OC_Fbit and OC_Lbit\n-\n-            function OC_Lt (Op1, Op2 : Natural) return Boolean;\n-            --  Compare routine for Sort\n-\n-            procedure OC_Move (From : Natural; To : Natural);\n-            --  Move routine for Sort\n-\n-            package Sorting is new GNAT.Heap_Sort_G (OC_Move, OC_Lt);\n-\n-            -----------\n-            -- OC_Lt --\n-            -----------\n-\n-            function OC_Lt (Op1, Op2 : Natural) return Boolean is\n-            begin\n-               return OC_Fbit (Op1) < OC_Fbit (Op2);\n-            end OC_Lt;\n-\n-            -------------\n-            -- OC_Move --\n-            -------------\n-\n-            procedure OC_Move (From : Natural; To : Natural) is\n-            begin\n-               OC_Fbit (To) := OC_Fbit (From);\n-               OC_Lbit (To) := OC_Lbit (From);\n-            end OC_Move;\n-\n-         --  Start of processing for Overlap_Check\n-\n-         begin\n-            CC := First (Component_Clauses (N));\n-            while Present (CC) loop\n-               if Nkind (CC) /= N_Pragma then\n-                  Posit := Static_Integer (Position  (CC));\n-                  Fbit  := Static_Integer (First_Bit (CC));\n-                  Lbit  := Static_Integer (Last_Bit  (CC));\n-\n-                  if Posit /= No_Uint\n-                    and then Fbit /= No_Uint\n-                    and then Lbit /= No_Uint\n-                  then\n-                     OC_Count := OC_Count + 1;\n-                     Posit := Posit * SSU;\n-                     OC_Fbit (OC_Count) := Fbit + Posit;\n-                     OC_Lbit (OC_Count) := Lbit + Posit;\n-                  end if;\n-               end if;\n-\n-               Next (CC);\n-            end loop;\n-\n-            Sorting.Sort (OC_Count);\n-\n-            Overlap_Check_Required := False;\n-            for J in 1 .. OC_Count - 1 loop\n-               if OC_Lbit (J) >= OC_Fbit (J + 1) then\n-                  Overlap_Check_Required := True;\n-                  exit;\n-               end if;\n-            end loop;\n-         end Overlap_Check1;\n-      end if;\n-\n-      --  If Overlap_Check_Required is still True, then we have to do the full\n-      --  scale overlap check, since we have at least two fields that do\n-      --  overlap, and we need to know if that is OK since they are in\n-      --  different variant, or whether we have a definite problem.\n-\n-      if Overlap_Check_Required then\n-         Overlap_Check2 : declare\n-            C1_Ent, C2_Ent : Entity_Id;\n-            --  Entities of components being checked for overlap\n-\n-            Clist : Node_Id;\n-            --  Component_List node whose Component_Items are being checked\n-\n-            Citem : Node_Id;\n-            --  Component declaration for component being checked\n-\n-         begin\n-            C1_Ent := First_Entity (Base_Type (Rectype));\n-\n-            --  Loop through all components in record. For each component check\n-            --  for overlap with any of the preceding elements on the component\n-            --  list containing the component and also, if the component is in\n-            --  a variant, check against components outside the case structure.\n-            --  This latter test is repeated recursively up the variant tree.\n-\n-            Main_Component_Loop : while Present (C1_Ent) loop\n-               if not Ekind_In (C1_Ent, E_Component, E_Discriminant) then\n-                  goto Continue_Main_Component_Loop;\n-               end if;\n-\n-               --  Skip overlap check if entity has no declaration node. This\n-               --  happens with discriminants in constrained derived types.\n-               --  Probably we are missing some checks as a result, but that\n-               --  does not seem terribly serious ???\n-\n-               if No (Declaration_Node (C1_Ent)) then\n-                  goto Continue_Main_Component_Loop;\n-               end if;\n-\n-               Clist := Parent (List_Containing (Declaration_Node (C1_Ent)));\n-\n-               --  Loop through component lists that need checking. Check the\n-               --  current component list and all lists in variants above us.\n-\n-               Component_List_Loop : loop\n-\n-                  --  If derived type definition, go to full declaration\n-                  --  If at outer level, check discriminants if there are any.\n-\n-                  if Nkind (Clist) = N_Derived_Type_Definition then\n-                     Clist := Parent (Clist);\n-                  end if;\n-\n-                  --  Outer level of record definition, check discriminants\n-\n-                  if Nkind_In (Clist, N_Full_Type_Declaration,\n-                                      N_Private_Type_Declaration)\n-                  then\n-                     if Has_Discriminants (Defining_Identifier (Clist)) then\n-                        C2_Ent :=\n-                          First_Discriminant (Defining_Identifier (Clist));\n-                        while Present (C2_Ent) loop\n-                           exit when C1_Ent = C2_Ent;\n-                           Check_Component_Overlap (C1_Ent, C2_Ent);\n-                           Next_Discriminant (C2_Ent);\n-                        end loop;\n-                     end if;\n-\n-                  --  Record extension case\n-\n-                  elsif Nkind (Clist) = N_Derived_Type_Definition then\n-                     Clist := Empty;\n-\n-                  --  Otherwise check one component list\n-\n-                  else\n-                     Citem := First (Component_Items (Clist));\n-\n-                     while Present (Citem) loop\n-                        if Nkind (Citem) = N_Component_Declaration then\n-                           C2_Ent := Defining_Identifier (Citem);\n-                           exit when C1_Ent = C2_Ent;\n-                           Check_Component_Overlap (C1_Ent, C2_Ent);\n-                        end if;\n-\n-                        Next (Citem);\n-                     end loop;\n-                  end if;\n-\n-                  --  Check for variants above us (the parent of the Clist can\n-                  --  be a variant, in which case its parent is a variant part,\n-                  --  and the parent of the variant part is a component list\n-                  --  whose components must all be checked against the current\n-                  --  component for overlap).\n-\n-                  if Nkind (Parent (Clist)) = N_Variant then\n-                     Clist := Parent (Parent (Parent (Clist)));\n-\n-                  --  Check for possible discriminant part in record, this is\n-                  --  treated essentially as another level in the recursion.\n-                  --  For this case the parent of the component list is the\n-                  --  record definition, and its parent is the full type\n-                  --  declaration containing the discriminant specifications.\n-\n-                  elsif Nkind (Parent (Clist)) = N_Record_Definition then\n-                     Clist := Parent (Parent ((Clist)));\n-\n-                  --  If neither of these two cases, we are at the top of\n-                  --  the tree.\n-\n-                  else\n-                     exit Component_List_Loop;\n-                  end if;\n-               end loop Component_List_Loop;\n-\n-               <<Continue_Main_Component_Loop>>\n-                  Next_Entity (C1_Ent);\n-\n-            end loop Main_Component_Loop;\n-         end Overlap_Check2;\n-      end if;\n-\n-      --  For records that have component clauses for all components, and whose\n-      --  size is less than or equal to 32, we need to know the size in the\n-      --  front end to activate possible packed array processing where the\n-      --  component type is a record.\n-\n-      --  At this stage Hbit + 1 represents the first unused bit from all the\n-      --  component clauses processed, so if the component clauses are\n-      --  complete, then this is the length of the record.\n-\n-      --  For records longer than System.Storage_Unit, and for those where not\n-      --  all components have component clauses, the back end determines the\n-      --  length (it may for example be appropriate to round up the size\n-      --  to some convenient boundary, based on alignment considerations, etc).\n-\n-      if Unknown_RM_Size (Rectype) and then Hbit + 1 <= 32 then\n-\n-         --  Nothing to do if at least one component has no component clause\n-\n-         Comp := First_Component_Or_Discriminant (Rectype);\n-         while Present (Comp) loop\n-            exit when No (Component_Clause (Comp));\n-            Next_Component_Or_Discriminant (Comp);\n-         end loop;\n-\n-         --  If we fall out of loop, all components have component clauses\n-         --  and so we can set the size to the maximum value.\n-\n-         if No (Comp) then\n-            Set_RM_Size (Rectype, Hbit + 1);\n-         end if;\n-      end if;\n-\n-      --  Check missing components if Complete_Representation pragma appeared\n-\n-      if Present (CR_Pragma) then\n-         Comp := First_Component_Or_Discriminant (Rectype);\n-         while Present (Comp) loop\n-            if No (Component_Clause (Comp)) then\n-               Error_Msg_NE\n-                 (\"missing component clause for &\", CR_Pragma, Comp);\n-            end if;\n-\n-            Next_Component_Or_Discriminant (Comp);\n-         end loop;\n-\n-      --  If no Complete_Representation pragma, warn if missing components\n+         --  If no Complete_Representation pragma, warn if missing components\n \n       elsif Warn_On_Unrepped_Components then\n          declare\n@@ -2994,8 +2772,8 @@ package body Sem_Ch13 is\n                     and then Comes_From_Source (Comp)\n                     and then Present (Underlying_Type (Etype (Comp)))\n                     and then (Is_Scalar_Type (Underlying_Type (Etype (Comp)))\n-                                or else Size_Known_At_Compile_Time\n-                                             (Underlying_Type (Etype (Comp))))\n+                               or else Size_Known_At_Compile_Time\n+                                         (Underlying_Type (Etype (Comp))))\n                     and then not Has_Warnings_Off (Rectype)\n                   then\n                      Error_Msg_Sloc := Sloc (Comp);\n@@ -3011,50 +2789,6 @@ package body Sem_Ch13 is\n       end if;\n    end Analyze_Record_Representation_Clause;\n \n-   -----------------------------\n-   -- Check_Component_Overlap --\n-   -----------------------------\n-\n-   procedure Check_Component_Overlap (C1_Ent, C2_Ent : Entity_Id) is\n-   begin\n-      if Present (Component_Clause (C1_Ent))\n-        and then Present (Component_Clause (C2_Ent))\n-      then\n-         --  Exclude odd case where we have two tag fields in the same record,\n-         --  both at location zero. This seems a bit strange, but it seems to\n-         --  happen in some circumstances ???\n-\n-         if Chars (C1_Ent) = Name_uTag\n-           and then Chars (C2_Ent) = Name_uTag\n-         then\n-            return;\n-         end if;\n-\n-         --  Here we check if the two fields overlap\n-\n-         declare\n-            S1 : constant Uint := Component_Bit_Offset (C1_Ent);\n-            S2 : constant Uint := Component_Bit_Offset (C2_Ent);\n-            E1 : constant Uint := S1 + Esize (C1_Ent);\n-            E2 : constant Uint := S2 + Esize (C2_Ent);\n-\n-         begin\n-            if E2 <= S1 or else E1 <= S2 then\n-               null;\n-            else\n-               Error_Msg_Node_2 :=\n-                 Component_Name (Component_Clause (C2_Ent));\n-               Error_Msg_Sloc := Sloc (Error_Msg_Node_2);\n-               Error_Msg_Node_1 :=\n-                 Component_Name (Component_Clause (C1_Ent));\n-               Error_Msg_N\n-                 (\"component& overlaps & #\",\n-                  Component_Name (Component_Clause (C1_Ent)));\n-            end if;\n-         end;\n-      end if;\n-   end Check_Component_Overlap;\n-\n    -----------------------------------\n    -- Check_Constant_Address_Clause --\n    -----------------------------------\n@@ -3401,6 +3135,566 @@ package body Sem_Ch13 is\n       Check_Expr_Constants (Expr);\n    end Check_Constant_Address_Clause;\n \n+   ----------------------------------------\n+   -- Check_Record_Representation_Clause --\n+   ----------------------------------------\n+\n+   procedure Check_Record_Representation_Clause (N : Node_Id) is\n+      Loc     : constant Source_Ptr := Sloc (N);\n+      Ident   : constant Node_Id    := Identifier (N);\n+      Rectype : Entity_Id;\n+      Fent    : Entity_Id;\n+      CC      : Node_Id;\n+      Fbit    : Uint;\n+      Lbit    : Uint;\n+      Hbit    : Uint := Uint_0;\n+      Comp    : Entity_Id;\n+      Pcomp   : Entity_Id;\n+\n+      Max_Bit_So_Far : Uint;\n+      --  Records the maximum bit position so far. If all field positions\n+      --  are monotonically increasing, then we can skip the circuit for\n+      --  checking for overlap, since no overlap is possible.\n+\n+      Tagged_Parent : Entity_Id := Empty;\n+      --  This is set in the case of a derived tagged type for which we have\n+      --  Is_Fully_Repped_Tagged_Type True (indicating that all components are\n+      --  positioned by record representation clauses). In this case we must\n+      --  check for overlap between components of this tagged type, and the\n+      --  components of its parent. Tagged_Parent will point to this parent\n+      --  type. For all other cases Tagged_Parent is left set to Empty.\n+\n+      Parent_Last_Bit : Uint;\n+      --  Relevant only if Tagged_Parent is set, Parent_Last_Bit indicates the\n+      --  last bit position for any field in the parent type. We only need to\n+      --  check overlap for fields starting below this point.\n+\n+      Overlap_Check_Required : Boolean;\n+      --  Used to keep track of whether or not an overlap check is required\n+\n+      Ccount : Natural := 0;\n+      --  Number of component clauses in record rep clause\n+\n+      procedure Check_Component_Overlap (C1_Ent, C2_Ent : Entity_Id);\n+      --  Given two entities for record components or discriminants, checks\n+      --  if they have overlapping component clauses and issues errors if so.\n+\n+      procedure Find_Component;\n+      --  Finds component entity corresponding to current component clause (in\n+      --  CC), and sets Comp to the entity, and Fbit/Lbit to the zero origin\n+      --  start/stop bits for the field. If there is no matching component or\n+      --  if the matching component does not have a component clause, then\n+      --  that's an error and Comp is set to Empty, but no error message is\n+      --  issued, since the message was already given. Comp is also set to\n+      --  Empty if the current \"component clause\" is in fact a pragma.\n+\n+      -----------------------------\n+      -- Check_Component_Overlap --\n+      -----------------------------\n+\n+      procedure Check_Component_Overlap (C1_Ent, C2_Ent : Entity_Id) is\n+         CC1 : constant Node_Id := Component_Clause (C1_Ent);\n+         CC2 : constant Node_Id := Component_Clause (C2_Ent);\n+      begin\n+         if Present (CC1) and then Present (CC2) then\n+\n+            --  Exclude odd case where we have two tag fields in the same\n+            --  record, both at location zero. This seems a bit strange, but\n+            --  it seems to happen in some circumstances, perhaps on an error.\n+\n+            if Chars (C1_Ent) = Name_uTag\n+                 and then\n+               Chars (C2_Ent) = Name_uTag\n+            then\n+               return;\n+            end if;\n+\n+            --  Here we check if the two fields overlap\n+\n+            declare\n+               S1 : constant Uint := Component_Bit_Offset (C1_Ent);\n+               S2 : constant Uint := Component_Bit_Offset (C2_Ent);\n+               E1 : constant Uint := S1 + Esize (C1_Ent);\n+               E2 : constant Uint := S2 + Esize (C2_Ent);\n+\n+            begin\n+               if E2 <= S1 or else E1 <= S2 then\n+                  null;\n+               else\n+                  Error_Msg_Node_2 := Component_Name (CC2);\n+                  Error_Msg_Sloc := Sloc (Error_Msg_Node_2);\n+                  Error_Msg_Node_1 := Component_Name (CC1);\n+                  Error_Msg_N\n+                    (\"component& overlaps & #\", Component_Name (CC1));\n+               end if;\n+            end;\n+         end if;\n+      end Check_Component_Overlap;\n+\n+      --------------------\n+      -- Find_Component --\n+      --------------------\n+\n+      procedure Find_Component is\n+\n+         procedure Search_Component (R : Entity_Id);\n+         --  Search components of R for a match. If found, Comp is set.\n+\n+         ----------------------\n+         -- Search_Component --\n+         ----------------------\n+\n+         procedure Search_Component (R : Entity_Id) is\n+         begin\n+            Comp := First_Component_Or_Discriminant (R);\n+            while Present (Comp) loop\n+\n+               --  Ignore error of attribute name for component name (we\n+               --  already gave an error message for this, so no need to\n+               --  complain here)\n+\n+               if Nkind (Component_Name (CC)) = N_Attribute_Reference then\n+                  null;\n+               else\n+                  exit when Chars (Comp) = Chars (Component_Name (CC));\n+               end if;\n+\n+               Next_Component_Or_Discriminant (Comp);\n+            end loop;\n+         end Search_Component;\n+\n+      --  Start of processing for Find_Component\n+\n+      begin\n+         --  Return with Comp set to Empty if we have a pragma\n+\n+         if Nkind (CC) = N_Pragma then\n+            Comp := Empty;\n+            return;\n+         end if;\n+\n+         --  Search current record for matching component\n+\n+         Search_Component (Rectype);\n+\n+         --  If not found, maybe component of base type that is absent from\n+         --  statically constrained first subtype.\n+\n+         if No (Comp) then\n+            Search_Component (Base_Type (Rectype));\n+         end if;\n+\n+         --  If no component, or the component does not reference the component\n+         --  clause in question, then there was some previous error for which\n+         --  we already gave a message, so just return with Comp Empty.\n+\n+         if No (Comp)\n+           or else Component_Clause (Comp) /= CC\n+         then\n+            Comp := Empty;\n+\n+         --  Normal case where we have a component clause\n+\n+         else\n+            Fbit := Component_Bit_Offset (Comp);\n+            Lbit := Fbit + Esize (Comp) - 1;\n+         end if;\n+      end Find_Component;\n+\n+   --  Start of processing for Check_Record_Representation_Clause\n+\n+   begin\n+      Find_Type (Ident);\n+      Rectype := Entity (Ident);\n+\n+      if Rectype = Any_Type then\n+         return;\n+      else\n+         Rectype := Underlying_Type (Rectype);\n+      end if;\n+\n+      --  See if we have a fully repped derived tagged type\n+\n+      declare\n+         PS : constant Entity_Id := Parent_Subtype (Rectype);\n+\n+      begin\n+         if Present (PS) and then Is_Fully_Repped_Tagged_Type (PS) then\n+            Tagged_Parent := PS;\n+\n+            --  Find maximum bit of any component of the parent type\n+\n+            Parent_Last_Bit := UI_From_Int (System_Address_Size - 1);\n+            Pcomp := First_Entity (Tagged_Parent);\n+            while Present (Pcomp) loop\n+               if Ekind_In (Pcomp, E_Discriminant, E_Component) then\n+                  if Component_Bit_Offset (Pcomp) /= No_Uint\n+                    and then Known_Static_Esize (Pcomp)\n+                  then\n+                     Parent_Last_Bit :=\n+                       UI_Max\n+                         (Parent_Last_Bit,\n+                          Component_Bit_Offset (Pcomp) + Esize (Pcomp) - 1);\n+                  end if;\n+\n+                  Next_Entity (Pcomp);\n+               end if;\n+            end loop;\n+         end if;\n+      end;\n+\n+      --  All done if no component clauses\n+\n+      CC := First (Component_Clauses (N));\n+\n+      if No (CC) then\n+         return;\n+      end if;\n+\n+      --  If a tag is present, then create a component clause that places it\n+      --  at the start of the record (otherwise gigi may place it after other\n+      --  fields that have rep clauses).\n+\n+      Fent := First_Entity (Rectype);\n+\n+      if Nkind (Fent) = N_Defining_Identifier\n+        and then Chars (Fent) = Name_uTag\n+      then\n+         Set_Component_Bit_Offset    (Fent, Uint_0);\n+         Set_Normalized_Position     (Fent, Uint_0);\n+         Set_Normalized_First_Bit    (Fent, Uint_0);\n+         Set_Normalized_Position_Max (Fent, Uint_0);\n+         Init_Esize                  (Fent, System_Address_Size);\n+\n+         Set_Component_Clause (Fent,\n+           Make_Component_Clause (Loc,\n+             Component_Name =>\n+               Make_Identifier (Loc,\n+                 Chars => Name_uTag),\n+\n+             Position  =>\n+               Make_Integer_Literal (Loc,\n+                 Intval => Uint_0),\n+\n+             First_Bit =>\n+               Make_Integer_Literal (Loc,\n+                 Intval => Uint_0),\n+\n+             Last_Bit  =>\n+               Make_Integer_Literal (Loc,\n+                 UI_From_Int (System_Address_Size))));\n+\n+         Ccount := Ccount + 1;\n+      end if;\n+\n+      Max_Bit_So_Far := Uint_Minus_1;\n+      Overlap_Check_Required := False;\n+\n+      --  Process the component clauses\n+\n+      while Present (CC) loop\n+         Find_Component;\n+\n+         if Present (Comp) then\n+            Ccount := Ccount + 1;\n+\n+            if Fbit <= Max_Bit_So_Far then\n+               Overlap_Check_Required := True;\n+            else\n+               Max_Bit_So_Far := Lbit;\n+            end if;\n+\n+            --  Check bit position out of range of specified size\n+\n+            if Has_Size_Clause (Rectype)\n+              and then Esize (Rectype) <= Lbit\n+            then\n+               Error_Msg_N\n+                 (\"bit number out of range of specified size\",\n+                  Last_Bit (CC));\n+\n+               --  Check for overlap with tag field\n+\n+            else\n+               if Is_Tagged_Type (Rectype)\n+                 and then Fbit < System_Address_Size\n+               then\n+                  Error_Msg_NE\n+                    (\"component overlaps tag field of&\",\n+                     Component_Name (CC), Rectype);\n+               end if;\n+\n+               if Hbit < Lbit then\n+                  Hbit := Lbit;\n+               end if;\n+            end if;\n+\n+            --  Check parent overlap if component might overlap parent field\n+\n+            if Present (Tagged_Parent)\n+              and then Fbit <= Parent_Last_Bit\n+            then\n+               Pcomp := First_Component_Or_Discriminant (Tagged_Parent);\n+               while Present (Pcomp) loop\n+                  if not Is_Tag (Pcomp)\n+                    and then Chars (Pcomp) /= Name_uParent\n+                  then\n+                     Check_Component_Overlap (Comp, Pcomp);\n+                  end if;\n+\n+                  Next_Component_Or_Discriminant (Pcomp);\n+               end loop;\n+            end if;\n+         end if;\n+\n+         Next (CC);\n+      end loop;\n+\n+      --  Now that we have processed all the component clauses, check for\n+      --  overlap. We have to leave this till last, since the components can\n+      --  appear in any arbitrary order in the representation clause.\n+\n+      --  We do not need this check if all specified ranges were monotonic,\n+      --  as recorded by Overlap_Check_Required being False at this stage.\n+\n+      --  This first section checks if there are any overlapping entries at\n+      --  all. It does this by sorting all entries and then seeing if there are\n+      --  any overlaps. If there are none, then that is decisive, but if there\n+      --  are overlaps, they may still be OK (they may result from fields in\n+      --  different variants).\n+\n+      if Overlap_Check_Required then\n+         Overlap_Check1 : declare\n+\n+            OC_Fbit : array (0 .. Ccount) of Uint;\n+            --  First-bit values for component clauses, the value is the offset\n+            --  of the first bit of the field from start of record. The zero\n+            --  entry is for use in sorting.\n+\n+            OC_Lbit : array (0 .. Ccount) of Uint;\n+            --  Last-bit values for component clauses, the value is the offset\n+            --  of the last bit of the field from start of record. The zero\n+            --  entry is for use in sorting.\n+\n+            OC_Count : Natural := 0;\n+            --  Count of entries in OC_Fbit and OC_Lbit\n+\n+            function OC_Lt (Op1, Op2 : Natural) return Boolean;\n+            --  Compare routine for Sort\n+\n+            procedure OC_Move (From : Natural; To : Natural);\n+            --  Move routine for Sort\n+\n+            package Sorting is new GNAT.Heap_Sort_G (OC_Move, OC_Lt);\n+\n+            -----------\n+            -- OC_Lt --\n+            -----------\n+\n+            function OC_Lt (Op1, Op2 : Natural) return Boolean is\n+            begin\n+               return OC_Fbit (Op1) < OC_Fbit (Op2);\n+            end OC_Lt;\n+\n+            -------------\n+            -- OC_Move --\n+            -------------\n+\n+            procedure OC_Move (From : Natural; To : Natural) is\n+            begin\n+               OC_Fbit (To) := OC_Fbit (From);\n+               OC_Lbit (To) := OC_Lbit (From);\n+            end OC_Move;\n+\n+            --  Start of processing for Overlap_Check\n+\n+         begin\n+            CC := First (Component_Clauses (N));\n+            while Present (CC) loop\n+\n+               --  Exclude component clause already marked in error\n+\n+               if not Error_Posted (CC) then\n+                  Find_Component;\n+\n+                  if Present (Comp) then\n+                     OC_Count := OC_Count + 1;\n+                     OC_Fbit (OC_Count) := Fbit;\n+                     OC_Lbit (OC_Count) := Lbit;\n+                  end if;\n+               end if;\n+\n+               Next (CC);\n+            end loop;\n+\n+            Sorting.Sort (OC_Count);\n+\n+            Overlap_Check_Required := False;\n+            for J in 1 .. OC_Count - 1 loop\n+               if OC_Lbit (J) >= OC_Fbit (J + 1) then\n+                  Overlap_Check_Required := True;\n+                  exit;\n+               end if;\n+            end loop;\n+         end Overlap_Check1;\n+      end if;\n+\n+      --  If Overlap_Check_Required is still True, then we have to do the full\n+      --  scale overlap check, since we have at least two fields that do\n+      --  overlap, and we need to know if that is OK since they are in\n+      --  different variant, or whether we have a definite problem.\n+\n+      if Overlap_Check_Required then\n+         Overlap_Check2 : declare\n+            C1_Ent, C2_Ent : Entity_Id;\n+            --  Entities of components being checked for overlap\n+\n+            Clist : Node_Id;\n+            --  Component_List node whose Component_Items are being checked\n+\n+            Citem : Node_Id;\n+            --  Component declaration for component being checked\n+\n+         begin\n+            C1_Ent := First_Entity (Base_Type (Rectype));\n+\n+            --  Loop through all components in record. For each component check\n+            --  for overlap with any of the preceding elements on the component\n+            --  list containing the component and also, if the component is in\n+            --  a variant, check against components outside the case structure.\n+            --  This latter test is repeated recursively up the variant tree.\n+\n+            Main_Component_Loop : while Present (C1_Ent) loop\n+               if not Ekind_In (C1_Ent, E_Component, E_Discriminant) then\n+                  goto Continue_Main_Component_Loop;\n+               end if;\n+\n+               --  Skip overlap check if entity has no declaration node. This\n+               --  happens with discriminants in constrained derived types.\n+               --  Probably we are missing some checks as a result, but that\n+               --  does not seem terribly serious ???\n+\n+               if No (Declaration_Node (C1_Ent)) then\n+                  goto Continue_Main_Component_Loop;\n+               end if;\n+\n+               Clist := Parent (List_Containing (Declaration_Node (C1_Ent)));\n+\n+               --  Loop through component lists that need checking. Check the\n+               --  current component list and all lists in variants above us.\n+\n+               Component_List_Loop : loop\n+\n+                  --  If derived type definition, go to full declaration\n+                  --  If at outer level, check discriminants if there are any.\n+\n+                  if Nkind (Clist) = N_Derived_Type_Definition then\n+                     Clist := Parent (Clist);\n+                  end if;\n+\n+                  --  Outer level of record definition, check discriminants\n+\n+                  if Nkind_In (Clist, N_Full_Type_Declaration,\n+                               N_Private_Type_Declaration)\n+                  then\n+                     if Has_Discriminants (Defining_Identifier (Clist)) then\n+                        C2_Ent :=\n+                          First_Discriminant (Defining_Identifier (Clist));\n+                        while Present (C2_Ent) loop\n+                           exit when C1_Ent = C2_Ent;\n+                           Check_Component_Overlap (C1_Ent, C2_Ent);\n+                           Next_Discriminant (C2_Ent);\n+                        end loop;\n+                     end if;\n+\n+                     --  Record extension case\n+\n+                  elsif Nkind (Clist) = N_Derived_Type_Definition then\n+                     Clist := Empty;\n+\n+                     --  Otherwise check one component list\n+\n+                  else\n+                     Citem := First (Component_Items (Clist));\n+\n+                     while Present (Citem) loop\n+                        if Nkind (Citem) = N_Component_Declaration then\n+                           C2_Ent := Defining_Identifier (Citem);\n+                           exit when C1_Ent = C2_Ent;\n+                           Check_Component_Overlap (C1_Ent, C2_Ent);\n+                        end if;\n+\n+                        Next (Citem);\n+                     end loop;\n+                  end if;\n+\n+                  --  Check for variants above us (the parent of the Clist can\n+                  --  be a variant, in which case its parent is a variant part,\n+                  --  and the parent of the variant part is a component list\n+                  --  whose components must all be checked against the current\n+                  --  component for overlap).\n+\n+                  if Nkind (Parent (Clist)) = N_Variant then\n+                     Clist := Parent (Parent (Parent (Clist)));\n+\n+                     --  Check for possible discriminant part in record, this\n+                     --  is treated essentially as another level in the\n+                     --  recursion. For this case the parent of the component\n+                     --  list is the record definition, and its parent is the\n+                     --  full type declaration containing the discriminant\n+                     --  specifications.\n+\n+                  elsif Nkind (Parent (Clist)) = N_Record_Definition then\n+                     Clist := Parent (Parent ((Clist)));\n+\n+                     --  If neither of these two cases, we are at the top of\n+                     --  the tree.\n+\n+                  else\n+                     exit Component_List_Loop;\n+                  end if;\n+               end loop Component_List_Loop;\n+\n+               <<Continue_Main_Component_Loop>>\n+               Next_Entity (C1_Ent);\n+\n+            end loop Main_Component_Loop;\n+         end Overlap_Check2;\n+      end if;\n+\n+      --  For records that have component clauses for all components, and whose\n+      --  size is less than or equal to 32, we need to know the size in the\n+      --  front end to activate possible packed array processing where the\n+      --  component type is a record.\n+\n+      --  At this stage Hbit + 1 represents the first unused bit from all the\n+      --  component clauses processed, so if the component clauses are\n+      --  complete, then this is the length of the record.\n+\n+      --  For records longer than System.Storage_Unit, and for those where not\n+      --  all components have component clauses, the back end determines the\n+      --  length (it may for example be appropriate to round up the size\n+      --  to some convenient boundary, based on alignment considerations, etc).\n+\n+      if Unknown_RM_Size (Rectype) and then Hbit + 1 <= 32 then\n+\n+         --  Nothing to do if at least one component has no component clause\n+\n+         Comp := First_Component_Or_Discriminant (Rectype);\n+         while Present (Comp) loop\n+            exit when No (Component_Clause (Comp));\n+            Next_Component_Or_Discriminant (Comp);\n+         end loop;\n+\n+         --  If we fall out of loop, all components have component clauses\n+         --  and so we can set the size to the maximum value.\n+\n+         if No (Comp) then\n+            Set_RM_Size (Rectype, Hbit + 1);\n+         end if;\n+      end if;\n+   end Check_Record_Representation_Clause;\n+\n    ----------------\n    -- Check_Size --\n    ----------------"}, {"sha": "b95eed60a922843b617383d890bac80a3fe89773", "filename": "gcc/ada/sem_ch13.ads", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a95f4e86791d06494bd5fc8b0da29b9651530fb/gcc%2Fada%2Fsem_ch13.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a95f4e86791d06494bd5fc8b0da29b9651530fb/gcc%2Fada%2Fsem_ch13.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.ads?ref=8a95f4e86791d06494bd5fc8b0da29b9651530fb", "patch": "@@ -38,9 +38,17 @@ package Sem_Ch13 is\n    procedure Adjust_Record_For_Reverse_Bit_Order (R : Entity_Id);\n    --  Called from Freeze where R is a record entity for which reverse bit\n    --  order is specified and there is at least one component clause. Adjusts\n-   --  component positions according to Ada 2005 AI-133. Note that this is only\n-   --  called in Ada 2005 mode. The Ada 95 handling for bit order is entirely\n-   --  contained in Freeze.\n+   --  component positions according to either Ada 95 or Ada 2005 (AI-133).\n+\n+   procedure Check_Record_Representation_Clause (N : Node_Id);\n+   --  This procedure completes the analysis of a record representation clause\n+   --  N. It is called at freeze time after adjustment of component clause bit\n+   --  positions for possible non-standard bit order. In the case of Ada 2005\n+   --  (machine scalar) mode, this adjustment can make substantial changes, so\n+   --  some checks, in particular for component overlaps cannot be done at the\n+   --  time the record representation clause is first seen, but must be delayed\n+   --  till freeze time, and in particular is called after calling the above\n+   --  procedure for adjusting record bit positions for reverse bit order.\n \n    procedure Initialize;\n    --  Initialize internal tables for new compilation"}, {"sha": "c16ef140fddec375e0b115cc195229f13f30d155", "filename": "gcc/ada/sem_eval.adb", "status": "modified", "additions": 28, "deletions": 6, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a95f4e86791d06494bd5fc8b0da29b9651530fb/gcc%2Fada%2Fsem_eval.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a95f4e86791d06494bd5fc8b0da29b9651530fb/gcc%2Fada%2Fsem_eval.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_eval.adb?ref=8a95f4e86791d06494bd5fc8b0da29b9651530fb", "patch": "@@ -2534,9 +2534,9 @@ package body Sem_Eval is\n    -- Eval_Relational_Op --\n    ------------------------\n \n-   --  Relational operations are static functions, so the result is static\n-   --  if both operands are static (RM 4.9(7), 4.9(20)), except that for\n-   --  strings, the result is never static, even if the operands are.\n+   --  Relational operations are static functions, so the result is static if\n+   --  both operands are static (RM 4.9(7), 4.9(20)), except that for strings,\n+   --  the result is never static, even if the operands are.\n \n    procedure Eval_Relational_Op (N : Node_Id) is\n       Left   : constant Node_Id   := Left_Opnd (N);\n@@ -2650,17 +2650,37 @@ package body Sem_Eval is\n                      if Nkind (Expr) = N_Op_Add\n                        and then Compile_Time_Known_Value (Right_Opnd (Expr))\n                      then\n-                        Exp := Left_Opnd (Expr);\n+                        Exp  := Left_Opnd (Expr);\n                         Cons := Expr_Value (Right_Opnd (Expr));\n \n                      elsif Nkind (Expr) = N_Op_Subtract\n                        and then Compile_Time_Known_Value (Right_Opnd (Expr))\n                      then\n-                        Exp := Left_Opnd (Expr);\n+                        Exp  := Left_Opnd (Expr);\n                         Cons := -Expr_Value (Right_Opnd (Expr));\n \n+                     --  If the bound is a constant created to remove side\n+                     --  effects, recover original expression to see if it has\n+                     --  one of the recognizable forms.\n+\n+                     elsif Nkind (Expr) = N_Identifier\n+                       and then not Comes_From_Source (Entity (Expr))\n+                       and then Ekind (Entity (Expr)) = E_Constant\n+                       and then\n+                         Nkind (Parent (Entity (Expr))) = N_Object_Declaration\n+                     then\n+                        Exp := Expression (Parent (Entity (Expr)));\n+                        Decompose_Expr (Exp, Ent, Kind, Cons);\n+\n+                        --  If original expression includes an entity, create a\n+                        --  reference to it for use below.\n+\n+                        if Present (Ent) then\n+                           Exp := New_Occurrence_Of (Ent, Sloc (Ent));\n+                        end if;\n+\n                      else\n-                        Exp := Expr;\n+                        Exp  := Expr;\n                         Cons := Uint_0;\n                      end if;\n \n@@ -2669,8 +2689,10 @@ package body Sem_Eval is\n                      if Nkind (Exp) = N_Attribute_Reference then\n                         if Attribute_Name (Exp) = Name_First then\n                            Kind := 'F';\n+\n                         elsif Attribute_Name (Exp) = Name_Last then\n                            Kind := 'L';\n+\n                         else\n                            Ent := Empty;\n                            return;"}, {"sha": "2fb09993c7cb0df6062861f5f89244d9f0e30420", "filename": "gcc/ada/sem_intr.adb", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a95f4e86791d06494bd5fc8b0da29b9651530fb/gcc%2Fada%2Fsem_intr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a95f4e86791d06494bd5fc8b0da29b9651530fb/gcc%2Fada%2Fsem_intr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_intr.adb?ref=8a95f4e86791d06494bd5fc8b0da29b9651530fb", "patch": "@@ -73,9 +73,7 @@ package body Sem_Intr is\n \n    procedure Check_Exception_Function (E : Entity_Id; N : Node_Id) is\n    begin\n-      if Ekind (E) /= E_Function\n-        and then Ekind (E) /= E_Generic_Function\n-      then\n+      if not Ekind_In (E, E_Function, E_Generic_Function) then\n          Errint\n            (\"intrinsic exception subprogram must be a function\", E, N);\n \n@@ -374,9 +372,7 @@ package body Sem_Intr is\n       Ptyp2 : Node_Id;\n \n    begin\n-      if Ekind (E) /= E_Function\n-        and then Ekind (E) /= E_Generic_Function\n-      then\n+      if not Ekind_In (E, E_Function, E_Generic_Function) then\n          Errint (\"intrinsic shift subprogram must be a function\", E, N);\n          return;\n       end if;"}, {"sha": "29c706721da63b0d0ecd4cc37956bd1d3ef58e12", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 11, "deletions": 21, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a95f4e86791d06494bd5fc8b0da29b9651530fb/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a95f4e86791d06494bd5fc8b0da29b9651530fb/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=8a95f4e86791d06494bd5fc8b0da29b9651530fb", "patch": "@@ -1846,7 +1846,8 @@ package body Sem_Prag is\n             Proc := Entity (Name);\n \n             if Ekind (Proc) /= E_Procedure\n-                 or else Present (First_Formal (Proc)) then\n+              or else Present (First_Formal (Proc))\n+            then\n                Error_Pragma_Arg\n                  (\"argument of pragma% must be parameterless procedure\", Arg);\n             end if;\n@@ -2516,10 +2517,7 @@ package body Sem_Prag is\n \n          --  Check that we are not applying this to a named constant\n \n-         if Ekind (E) = E_Named_Integer\n-              or else\n-            Ekind (E) = E_Named_Real\n-         then\n+         if Ekind_In (E, E_Named_Integer, E_Named_Real) then\n             Error_Msg_Name_1 := Pname;\n             Error_Msg_N\n               (\"cannot apply pragma% to named constant!\",\n@@ -2756,9 +2754,7 @@ package body Sem_Prag is\n          Process_Extended_Import_Export_Internal_Arg (Arg_Internal);\n          Def_Id := Entity (Arg_Internal);\n \n-         if Ekind (Def_Id) /= E_Constant\n-           and then Ekind (Def_Id) /= E_Variable\n-         then\n+         if not Ekind_In (Def_Id, E_Constant, E_Variable) then\n             Error_Pragma_Arg\n               (\"pragma% must designate an object\", Arg_Internal);\n          end if;\n@@ -3368,10 +3364,8 @@ package body Sem_Prag is\n          Kill_Size_Check_Code (Def_Id);\n          Note_Possible_Modification (Expression (Arg2), Sure => False);\n \n-         if Ekind (Def_Id) = E_Variable\n-              or else\n-            Ekind (Def_Id) = E_Constant\n-         then\n+         if Ekind_In (Def_Id, E_Variable, E_Constant) then\n+\n             --  We do not permit Import to apply to a renaming declaration\n \n             if Present (Renamed_Object (Def_Id)) then\n@@ -9131,9 +9125,7 @@ package body Sem_Prag is\n                while Present (E)\n                  and then Scope (E) = Current_Scope\n                loop\n-                  if Ekind (E) = E_Procedure\n-                    or else Ekind (E) = E_Generic_Procedure\n-                  then\n+                  if Ekind_In (E, E_Procedure, E_Generic_Procedure) then\n                      Set_No_Return (E);\n \n                      --  Set flag on any alias as well\n@@ -10291,9 +10283,7 @@ package body Sem_Prag is\n \n             Def_Id := Entity (Internal);\n \n-            if Ekind (Def_Id) /= E_Constant\n-              and then Ekind (Def_Id) /= E_Variable\n-            then\n+            if not Ekind_In (Def_Id, E_Constant, E_Variable) then\n                Error_Pragma_Arg\n                  (\"pragma% must designate an object\", Internal);\n             end if;\n@@ -10459,9 +10449,9 @@ package body Sem_Prag is\n                loop\n                   Def_Id := Get_Base_Subprogram (E);\n \n-                  if Ekind (Def_Id) /= E_Function\n-                    and then Ekind (Def_Id) /= E_Generic_Function\n-                    and then Ekind (Def_Id) /= E_Operator\n+                  if not Ekind_In (Def_Id, E_Function,\n+                                           E_Generic_Function,\n+                                           E_Operator)\n                   then\n                      Error_Pragma_Arg\n                        (\"pragma% requires a function name\", Arg1);"}, {"sha": "ef5e3adf45fec65700b581c4befd8f16f5ce0b92", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 29, "deletions": 26, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a95f4e86791d06494bd5fc8b0da29b9651530fb/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a95f4e86791d06494bd5fc8b0da29b9651530fb/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=8a95f4e86791d06494bd5fc8b0da29b9651530fb", "patch": "@@ -3534,9 +3534,7 @@ package body Sem_Res is\n             --  might not be done in the In Out case since Gigi does not do\n             --  any analysis. More thought required about this ???\n \n-            if Ekind (F) = E_In_Parameter\n-              or else Ekind (F) = E_In_Out_Parameter\n-            then\n+            if Ekind_In (F, E_In_Parameter, E_In_Out_Parameter) then\n                if Is_Scalar_Type (Etype (A)) then\n                   Apply_Scalar_Range_Check (A, F_Typ);\n \n@@ -3582,9 +3580,7 @@ package body Sem_Res is\n                end if;\n             end if;\n \n-            if Ekind (F) = E_Out_Parameter\n-              or else Ekind (F) = E_In_Out_Parameter\n-            then\n+            if Ekind_In (F, E_Out_Parameter, E_In_Out_Parameter) then\n                if Nkind (A) = N_Type_Conversion then\n                   if Is_Scalar_Type (A_Typ) then\n                      Apply_Scalar_Range_Check\n@@ -6163,9 +6159,7 @@ package body Sem_Res is\n       Resolve_Actuals (N, Nam);\n       Generate_Reference (Nam, Entry_Name);\n \n-      if Ekind (Nam) = E_Entry\n-        or else Ekind (Nam) = E_Entry_Family\n-      then\n+      if Ekind_In (Nam, E_Entry, E_Entry_Family) then\n          Check_Potentially_Blocking_Operation (N);\n       end if;\n \n@@ -8559,9 +8553,7 @@ package body Sem_Res is\n \n                --  Handle subtypes\n \n-               if Ekind (Opnd) = E_Protected_Subtype\n-                 or else Ekind (Opnd) = E_Task_Subtype\n-               then\n+               if Ekind_In (Opnd, E_Protected_Subtype, E_Task_Subtype) then\n                   Opnd := Etype (Opnd);\n                end if;\n \n@@ -8954,19 +8946,20 @@ package body Sem_Res is\n \n          Index_Subtype := Create_Itype (Subtype_Kind (Ekind (Index_Type)), N);\n \n-         Set_Scalar_Range (Index_Subtype, Drange);\n+         --  Take a new copy of Drange (where bounds have been rewritten to\n+         --  reference side-effect-vree names). Using a separate tree ensures\n+         --  that further expansion (e.g while rewriting a slice assignment\n+         --  into a FOR loop) does not attempt to remove side effects on the\n+         --  bounds again (which would cause the bounds in the index subtype\n+         --  definition to refer to temporaries before they are defined) (the\n+         --  reason is that some names are considered side effect free here\n+         --  for the subtype, but not in the context of a loop iteration\n+         --  scheme).\n+\n+         Set_Scalar_Range (Index_Subtype, New_Copy_Tree (Drange));\n          Set_Etype        (Index_Subtype, Index_Type);\n          Set_Size_Info    (Index_Subtype, Index_Type);\n          Set_RM_Size      (Index_Subtype, RM_Size (Index_Type));\n-\n-         --  Now replace the discrete range in the slice with a reference to\n-         --  its index subtype. This ensures that further expansion (e.g\n-         --  while rewriting a slice assignment into a FOR loop) does not\n-         --  attempt to remove side effects on the bounds again (which would\n-         --  cause the bounds in the index subtype definition to refer to\n-         --  temporaries before they are defined).\n-\n-         Set_Discrete_Range (N, New_Copy_Tree (Drange));\n       end if;\n \n       Slice_Subtype := Create_Itype (E_Array_Subtype, N);\n@@ -8979,15 +8972,26 @@ package body Sem_Res is\n       Set_Etype          (Slice_Subtype, Base_Type (Etype (N)));\n       Set_Is_Constrained (Slice_Subtype, True);\n \n+      Check_Compile_Time_Size (Slice_Subtype);\n+\n       --  The Etype of the existing Slice node is reset to this slice subtype.\n       --  Its bounds are obtained from its first index.\n \n       Set_Etype (N, Slice_Subtype);\n \n-      --  Always freeze subtype. This ensures that the slice subtype is\n-      --  elaborated in the scope of the expression.\n+      --  For packed slice subtypes, freeze immediately. Otherwise insert an\n+      --  itype reference in the slice's actions so that the itype is frozen\n+      --  at the proper place in the tree (i.e. at the point where actions\n+      --  for the slice are analyzed). Note that this is different from\n+      --  freezing the itype immediately, which might be premature (e.g. if\n+      --  the slice is within a transient scope).\n+\n+      if Is_Packed (Slice_Subtype) and not In_Spec_Expression then\n+         Freeze_Itype (Slice_Subtype, N);\n \n-      Freeze_Itype (Slice_Subtype, N);\n+      else\n+         Ensure_Defined (Typ => Slice_Subtype, N => N);\n+      end if;\n    end Set_Slice_Subtype;\n \n    --------------------------------\n@@ -9732,7 +9736,6 @@ package body Sem_Res is\n             elsif Ekind (Opnd_Type) = E_Anonymous_Access_Type\n               and then not Is_Local_Anonymous_Access (Opnd_Type)\n             then\n-\n                --  When the operand is a selected access discriminant the check\n                --  needs to be made against the level of the object denoted by\n                --  the prefix of the selected name (Object_Access_Level handles"}, {"sha": "d999cc29054e9be24d42fc34001356eeb77ec193", "filename": "gcc/ada/sem_type.adb", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a95f4e86791d06494bd5fc8b0da29b9651530fb/gcc%2Fada%2Fsem_type.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a95f4e86791d06494bd5fc8b0da29b9651530fb/gcc%2Fada%2Fsem_type.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_type.adb?ref=8a95f4e86791d06494bd5fc8b0da29b9651530fb", "patch": "@@ -362,7 +362,6 @@ package body Sem_Type is\n       --  performed, given that the operator was visible in the generic.\n \n       if Ekind (E) = E_Operator then\n-\n          if Present (Opnd_Type) then\n             Vis_Type := Opnd_Type;\n          else\n@@ -803,8 +802,8 @@ package body Sem_Type is\n       then\n          return True;\n \n-      --  The context may be class wide, and a class-wide type is\n-      --  compatible with any member of the class.\n+      --  The context may be class wide, and a class-wide type is compatible\n+      --  with any member of the class.\n \n       elsif Is_Class_Wide_Type (T1)\n         and then Is_Ancestor (Root_Type (T1), T2)\n@@ -997,9 +996,7 @@ package body Sem_Type is\n       --  imposed by context.\n \n       elsif Ekind (T2) = E_Access_Attribute_Type\n-        and then (Ekind (BT1) = E_General_Access_Type\n-                    or else\n-                  Ekind (BT1) = E_Access_Type)\n+        and then Ekind_In (BT1, E_General_Access_Type, E_Access_Type)\n         and then Covers (Designated_Type (T1), Designated_Type (T2))\n       then\n          --  If the target type is a RACW type while the source is an access\n@@ -1677,9 +1674,8 @@ package body Sem_Type is\n       elsif Nkind (Parent (N)) = N_Object_Renaming_Declaration\n         and then Present (Access_Definition (Parent (N)))\n       then\n-         if Ekind (It1.Typ) = E_Anonymous_Access_Type\n-              or else\n-            Ekind (It1.Typ) = E_Anonymous_Access_Subprogram_Type\n+         if Ekind_In (It1.Typ, E_Anonymous_Access_Type,\n+                               E_Anonymous_Access_Subprogram_Type)\n          then\n             if Ekind (It2.Typ) = Ekind (It1.Typ) then\n \n@@ -1691,9 +1687,8 @@ package body Sem_Type is\n                return It1;\n             end if;\n \n-         elsif Ekind (It2.Typ) = E_Anonymous_Access_Type\n-                 or else\n-               Ekind (It2.Typ) = E_Anonymous_Access_Subprogram_Type\n+         elsif Ekind_In (It2.Typ, E_Anonymous_Access_Type,\n+                                  E_Anonymous_Access_Subprogram_Type)\n          then\n             return It2;\n \n@@ -1880,8 +1875,8 @@ package body Sem_Type is\n \n                   if Ekind (Etype (Opnd)) = E_Anonymous_Access_Type\n                     and then\n-                     List_Containing (Parent (Designated_Type (Etype (Opnd))))\n-                       = List_Containing (Unit_Declaration_Node (User_Subp))\n+                      List_Containing (Parent (Designated_Type (Etype (Opnd))))\n+                        = List_Containing (Unit_Declaration_Node (User_Subp))\n                   then\n                      if It2.Nam = Predef_Subp then\n                         return It1;"}, {"sha": "867ae0ac5377fb58b941d5d7edba48ef9114f291", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 8, "deletions": 25, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a95f4e86791d06494bd5fc8b0da29b9651530fb/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a95f4e86791d06494bd5fc8b0da29b9651530fb/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=8a95f4e86791d06494bd5fc8b0da29b9651530fb", "patch": "@@ -2817,9 +2817,7 @@ package body Sem_Util is\n                --  Avoid cascaded messages with duplicate components in\n                --  derived types.\n \n-               if Ekind (E) = E_Component\n-                 or else Ekind (E) = E_Discriminant\n-               then\n+               if Ekind_In (E, E_Component, E_Discriminant) then\n                   return;\n                end if;\n             end if;\n@@ -2854,9 +2852,7 @@ package body Sem_Util is\n       --  midst of inheriting components in a derived record definition.\n       --  Preserve their Ekind and Etype.\n \n-      if Ekind (Def_Id) = E_Discriminant\n-        or else Ekind (Def_Id) = E_Component\n-      then\n+      if Ekind_In (Def_Id, E_Discriminant, E_Component) then\n          null;\n \n       --  If a type is already set, leave it alone (happens whey a type\n@@ -2876,8 +2872,7 @@ package body Sem_Util is\n       --  Inherited discriminants and components in derived record types are\n       --  immediately visible. Itypes are not.\n \n-      if Ekind (Def_Id) = E_Discriminant\n-        or else Ekind (Def_Id) = E_Component\n+      if Ekind_In (Def_Id, E_Discriminant, E_Component)\n         or else (No (Corresponding_Remote_Type (Def_Id))\n                  and then not Is_Itype (Def_Id))\n       then\n@@ -4848,10 +4843,8 @@ package body Sem_Util is\n \n             --  We are interested only in components and discriminants\n \n-            if Ekind (Ent) = E_Component\n-                or else\n-               Ekind (Ent) = E_Discriminant\n-            then\n+            if Ekind_In (Ent, E_Component, E_Discriminant) then\n+\n                --  Get default expression if any. If there is no declaration\n                --  node, it means we have an internal entity. The parent and\n                --  tag fields are examples of such entities. For these cases,\n@@ -6376,10 +6369,7 @@ package body Sem_Util is\n             Ent : constant Entity_Id := Entity (Expr);\n             Sub : constant Entity_Id := Enclosing_Subprogram (Ent);\n          begin\n-            if Ekind (Ent) /= E_Variable\n-                 and then\n-               Ekind (Ent) /= E_In_Out_Parameter\n-            then\n+            if not Ekind_In (Ent, E_Variable, E_In_Out_Parameter) then\n                return False;\n             else\n                return Present (Sub) and then Sub = Current_Subprogram;\n@@ -8658,9 +8648,7 @@ package body Sem_Util is\n          --  If a record subtype is simply copied, the entity list will be\n          --  shared. Thus cloned_Subtype must be set to indicate the sharing.\n \n-         if Ekind (Old_Itype) = E_Record_Subtype\n-           or else Ekind (Old_Itype) = E_Class_Wide_Subtype\n-         then\n+         if Ekind_In (Old_Itype, E_Record_Subtype, E_Class_Wide_Subtype) then\n             Set_Cloned_Subtype (New_Itype, Old_Itype);\n          end if;\n \n@@ -10151,12 +10139,7 @@ package body Sem_Util is\n          while R_Scope /= Standard_Standard loop\n             exit when R_Scope = E_Scope;\n \n-            if Ekind (R_Scope) /= E_Package\n-                  and then\n-                Ekind (R_Scope) /= E_Block\n-                  and then\n-                Ekind (R_Scope) /= E_Loop\n-            then\n+            if not Ekind_In (R_Scope, E_Package, E_Block, E_Loop) then\n                return False;\n             else\n                R_Scope := Scope (R_Scope);"}, {"sha": "0e00f5181bca003584507fc1aeb0150a681ce908", "filename": "gcc/ada/sem_warn.adb", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a95f4e86791d06494bd5fc8b0da29b9651530fb/gcc%2Fada%2Fsem_warn.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a95f4e86791d06494bd5fc8b0da29b9651530fb/gcc%2Fada%2Fsem_warn.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_warn.adb?ref=8a95f4e86791d06494bd5fc8b0da29b9651530fb", "patch": "@@ -1027,9 +1027,8 @@ package body Sem_Warn is\n             --  we exclude protected types, too complicated to worry about.\n \n             if Ekind (E1) = E_Variable\n-                 or else\n-                ((Ekind (E1) = E_Out_Parameter\n-                    or else Ekind (E1) = E_In_Out_Parameter)\n+              or else\n+                (Ekind_In (E1, E_Out_Parameter, E_In_Out_Parameter)\n                   and then not Is_Protected_Type (Current_Scope))\n             then\n                --  Case of an unassigned variable\n@@ -1345,7 +1344,7 @@ package body Sem_Warn is\n                               while Present (Comp) loop\n                                  if Ekind (Comp) = E_Component\n                                    and then Nkind (Parent (Comp)) =\n-                                   N_Component_Declaration\n+                                              N_Component_Declaration\n                                    and then No (Expression (Parent (Comp)))\n                                  then\n                                     Error_Msg_Node_2 := Comp;\n@@ -2883,9 +2882,7 @@ package body Sem_Warn is\n \n       --  Reference to obsolescent component\n \n-      elsif Ekind (E) = E_Component\n-        or else Ekind (E) = E_Discriminant\n-      then\n+      elsif Ekind_In (E, E_Component, E_Discriminant) then\n          Error_Msg_NE\n            (\"?reference to obsolescent component& declared#\", N, E);\n "}]}