{"sha": "52e14b96bd537b5431c577213c14db4686397d71", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTJlMTRiOTZiZDUzN2I1NDMxYzU3NzIxM2MxNGRiNDY4NjM5N2Q3MQ==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2017-05-18T19:34:13Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2017-05-18T19:34:13Z"}, "message": "re PR target/80510 (Optimize Power7/power8 Altivec load/stores)\n\n[gcc]\n2017-05-18  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\tPR target/80510\n\t* config/rs6000/predicates.md (simple_offsettable_mem_operand):\n\tNew predicate.\n\n\t* config/rs6000/rs6000.md (ALTIVEC_DFORM): New iterator.\n\t(define_peephole2 for Altivec d-form load): Add peepholes to catch\n\tcases where the register allocator uses a move and an offsettable\n\tmemory operation to/from a FPR register on ISA 2.06/2.07.\n\t(define_peephole2 for Altivec d-form store): Likewise.\n\n[gcc/testsuite]\n2017-05-18  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\tPR target/80510\n\t* gcc.target/powerpc/pr80510-1.c: New test.\n\t* gcc.target/powerpc/pr80510-2.c: Likewise.\n\nFrom-SVN: r248254", "tree": {"sha": "3fdb1db7c15c1b1ec369836778fa8f0997dceae2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3fdb1db7c15c1b1ec369836778fa8f0997dceae2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/52e14b96bd537b5431c577213c14db4686397d71", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52e14b96bd537b5431c577213c14db4686397d71", "html_url": "https://github.com/Rust-GCC/gccrs/commit/52e14b96bd537b5431c577213c14db4686397d71", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52e14b96bd537b5431c577213c14db4686397d71/comments", "author": null, "committer": null, "parents": [{"sha": "4287da829c9697c58131666447bf8f707bd8b635", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4287da829c9697c58131666447bf8f707bd8b635", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4287da829c9697c58131666447bf8f707bd8b635"}], "stats": {"total": 538, "additions": 538, "deletions": 0}, "files": [{"sha": "7ed62bcc793e69303a674b4c930f97b02758f6b6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52e14b96bd537b5431c577213c14db4686397d71/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52e14b96bd537b5431c577213c14db4686397d71/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=52e14b96bd537b5431c577213c14db4686397d71", "patch": "@@ -1,3 +1,15 @@\n+2017-05-18  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\tPR target/80510\n+\t* config/rs6000/predicates.md (simple_offsettable_mem_operand):\n+\tNew predicate.\n+\n+\t* config/rs6000/rs6000.md (ALTIVEC_DFORM): New iterator.\n+\t(define_peephole2 for Altivec d-form load): Add peepholes to catch\n+\tcases where the register allocator uses a move and an offsettable\n+\tmemory operation to/from a FPR register on ISA 2.06/2.07.\n+\t(define_peephole2 for Altivec d-form store): Likewise.\n+\n 2017-05-18  Uros Bizjak  <ubizjak@gmail.com>\n \n \tPR target/80799"}, {"sha": "0d816e5e6d976ac8fb3d6eac5e2177237d7e39ae", "filename": "gcc/config/rs6000/predicates.md", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52e14b96bd537b5431c577213c14db4686397d71/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52e14b96bd537b5431c577213c14db4686397d71/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fpredicates.md?ref=52e14b96bd537b5431c577213c14db4686397d71", "patch": "@@ -847,6 +847,22 @@\n   (and (match_operand 0 \"memory_operand\")\n        (match_test \"offsettable_nonstrict_memref_p (op)\")))\n \n+;; Return 1 if the operand is a simple offsettable memory operand\n+;; that does not include pre-increment, post-increment, etc.\n+(define_predicate \"simple_offsettable_mem_operand\"\n+  (match_operand 0 \"offsettable_mem_operand\")\n+{\n+  rtx addr = XEXP (op, 0);\n+\n+  if (GET_CODE (addr) != PLUS && GET_CODE (addr) != LO_SUM)\n+    return 0;\n+\n+  if (!CONSTANT_P (XEXP (addr, 1)))\n+    return 0;\n+\n+  return base_reg_operand (XEXP (addr, 0), Pmode);\n+})\n+\n ;; Return 1 if the operand is suitable for load/store quad memory.\n ;; This predicate only checks for non-atomic loads/stores (not lqarx/stqcx).\n (define_predicate \"quad_memory_operand\""}, {"sha": "26baaaf1524106764fe171355ef95c2f2bcd98dc", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52e14b96bd537b5431c577213c14db4686397d71/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52e14b96bd537b5431c577213c14db4686397d71/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=52e14b96bd537b5431c577213c14db4686397d71", "patch": "@@ -701,6 +701,11 @@\n (define_code_attr     SMINMAX\t[(smin \"SMIN\")\n \t\t\t\t (smax \"SMAX\")])\n \n+;; Iterator to optimize the following cases:\n+;;\tD-form load to FPR register & move to Altivec register\n+;;\tMove Altivec register to FPR register and store\n+(define_mode_iterator ALTIVEC_DFORM [DI DF SF])\n+\n \f\n ;; Start with fixed-point load and store insns.  Here we put only the more\n ;; complex forms.  Basic data transfer is done later.\n@@ -14075,6 +14080,82 @@\n   [(set_attr \"type\" \"two\")\n    (set_attr \"length\" \"8\")])\n \n+\f\n+;; Optimize cases where we want to do a D-form load (register+offset) on\n+;; ISA 2.06/2.07 to an Altivec register, and the register allocator\n+;; has generated:\n+;;\tLFD 0,32(3)\n+;;\tXXLOR 32,0,0\n+;;\n+;; and we change this to:\n+;;\tLI 0,32\n+;;\tLXSDX 32,3,9\n+\n+(define_peephole2\n+  [(match_scratch:DI 0 \"b\")\n+   (set (match_operand:ALTIVEC_DFORM 1 \"fpr_reg_operand\")\n+\t(match_operand:ALTIVEC_DFORM 2 \"simple_offsettable_mem_operand\"))\n+   (set (match_operand:ALTIVEC_DFORM 3 \"altivec_register_operand\")\n+\t(match_dup 1))]\n+  \"TARGET_VSX && TARGET_POWERPC64 && TARGET_UPPER_REGS_<MODE>\n+   && !TARGET_P9_DFORM_SCALAR && peep2_reg_dead_p (2, operands[1])\"\n+  [(set (match_dup 0)\n+\t(match_dup 4))\n+   (set (match_dup 3)\n+\t(match_dup 5))]\n+{\n+  rtx tmp_reg = operands[0];\n+  rtx mem = operands[2];\n+  rtx addr = XEXP (mem, 0);\n+  rtx add_op0, add_op1, new_addr;\n+\n+  gcc_assert (GET_CODE (addr) == PLUS || GET_CODE (addr) == LO_SUM);\n+  add_op0 = XEXP (addr, 0);\n+  add_op1 = XEXP (addr, 1);\n+  gcc_assert (REG_P (add_op0));\n+  new_addr = gen_rtx_PLUS (DImode, add_op0, tmp_reg);\n+\n+  operands[4] = add_op1;\n+  operands[5] = change_address (mem, <MODE>mode, new_addr);\n+})\n+\n+;; Optimize cases were want to do a D-form store on ISA 2.06/2.07 from an\n+;; Altivec register, and the register allocator has generated:\n+;;\tXXLOR 0,32,32\n+;;\tSTFD 0,32(3)\n+;;\n+;; and we change this to:\n+;;\tLI 0,32\n+;;\tSTXSDX 32,3,9\n+\n+(define_peephole2\n+  [(match_scratch:DI 0 \"b\")\n+   (set (match_operand:ALTIVEC_DFORM 1 \"fpr_reg_operand\")\n+\t(match_operand:ALTIVEC_DFORM 2 \"altivec_register_operand\"))\n+   (set (match_operand:ALTIVEC_DFORM 3 \"simple_offsettable_mem_operand\")\n+\t(match_dup 1))]\n+  \"TARGET_VSX && TARGET_POWERPC64 && TARGET_UPPER_REGS_<MODE>\n+   && !TARGET_P9_DFORM_SCALAR && peep2_reg_dead_p (2, operands[1])\"\n+  [(set (match_dup 0)\n+\t(match_dup 4))\n+   (set (match_dup 5)\n+\t(match_dup 2))]\n+{\n+  rtx tmp_reg = operands[0];\n+  rtx mem = operands[3];\n+  rtx addr = XEXP (mem, 0);\n+  rtx add_op0, add_op1, new_addr;\n+\n+  gcc_assert (GET_CODE (addr) == PLUS || GET_CODE (addr) == LO_SUM);\n+  add_op0 = XEXP (addr, 0);\n+  add_op1 = XEXP (addr, 1);\n+  gcc_assert (REG_P (add_op0));\n+  new_addr = gen_rtx_PLUS (DImode, add_op0, tmp_reg);\n+\n+  operands[4] = add_op1;\n+  operands[5] = change_address (mem, <MODE>mode, new_addr);\n+})\n+   \n \f\n ;; Miscellaneous ISA 2.06 (power7) instructions\n (define_insn \"addg6s\""}, {"sha": "c785b02e21134d5e9bf3ad991b0a60fc686bea44", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52e14b96bd537b5431c577213c14db4686397d71/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52e14b96bd537b5431c577213c14db4686397d71/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=52e14b96bd537b5431c577213c14db4686397d71", "patch": "@@ -1,3 +1,9 @@\n+2017-05-18  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\tPR target/80510\n+\t* gcc.target/powerpc/pr80510-1.c: New test.\n+\t* gcc.target/powerpc/pr80510-2.c: Likewise.\n+\n 2017-05-18  Eric Gallager  <egall@gwmail.gwu.edu>\n \n \t* gcc.dg/pragma-diag-7.c: New test."}, {"sha": "8bff3ce15c3e48fd6f7c4014f5c5854c9b5255b8", "filename": "gcc/testsuite/gcc.target/powerpc/pr80510-1.c", "status": "added", "additions": 211, "deletions": 0, "changes": 211, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52e14b96bd537b5431c577213c14db4686397d71/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr80510-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52e14b96bd537b5431c577213c14db4686397d71/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr80510-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr80510-1.c?ref=52e14b96bd537b5431c577213c14db4686397d71", "patch": "@@ -0,0 +1,211 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target powerpc_vsx_ok } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power7\" } } */\n+/* { dg-options \"-mcpu=power7 -O2\" } */\n+\n+/* Make sure that STXSDX is generated for double scalars in Altivec registers\n+   on power7 instead of moving the value to a FPR register and doing a X-FORM\n+   store.  */\n+\n+#ifndef TYPE\n+#define TYPE double\n+#endif\n+\n+#ifndef TYPE_IN\n+#define TYPE_IN TYPE\n+#endif\n+\n+#ifndef TYPE_OUT\n+#define TYPE_OUT TYPE\n+#endif\n+\n+#ifndef ITYPE\n+#define ITYPE long\n+#endif\n+\n+#ifdef DO_CALL\n+extern ITYPE get_bits (ITYPE);\n+\n+#else\n+#define get_bits(X) (X)\n+#endif\n+\n+void test (ITYPE *bits, ITYPE n, TYPE one, TYPE_IN *p, TYPE_OUT *q)\n+{\n+  TYPE x_00 = p[ 0];\n+  TYPE x_01 = p[ 1];\n+  TYPE x_02 = p[ 2];\n+  TYPE x_03 = p[ 3];\n+  TYPE x_04 = p[ 4];\n+  TYPE x_05 = p[ 5];\n+  TYPE x_06 = p[ 6];\n+  TYPE x_07 = p[ 7];\n+  TYPE x_08 = p[ 8];\n+  TYPE x_09 = p[ 9];\n+\n+  TYPE x_10 = p[10];\n+  TYPE x_11 = p[11];\n+  TYPE x_12 = p[12];\n+  TYPE x_13 = p[13];\n+  TYPE x_14 = p[14];\n+  TYPE x_15 = p[15];\n+  TYPE x_16 = p[16];\n+  TYPE x_17 = p[17];\n+  TYPE x_18 = p[18];\n+  TYPE x_19 = p[19];\n+\n+  TYPE x_20 = p[20];\n+  TYPE x_21 = p[21];\n+  TYPE x_22 = p[22];\n+  TYPE x_23 = p[23];\n+  TYPE x_24 = p[24];\n+  TYPE x_25 = p[25];\n+  TYPE x_26 = p[26];\n+  TYPE x_27 = p[27];\n+  TYPE x_28 = p[28];\n+  TYPE x_29 = p[29];\n+\n+  TYPE x_30 = p[30];\n+  TYPE x_31 = p[31];\n+  TYPE x_32 = p[32];\n+  TYPE x_33 = p[33];\n+  TYPE x_34 = p[34];\n+  TYPE x_35 = p[35];\n+  TYPE x_36 = p[36];\n+  TYPE x_37 = p[37];\n+  TYPE x_38 = p[38];\n+  TYPE x_39 = p[39];\n+\n+  TYPE x_40 = p[40];\n+  TYPE x_41 = p[41];\n+  TYPE x_42 = p[42];\n+  TYPE x_43 = p[43];\n+  TYPE x_44 = p[44];\n+  TYPE x_45 = p[45];\n+  TYPE x_46 = p[46];\n+  TYPE x_47 = p[47];\n+  TYPE x_48 = p[48];\n+  TYPE x_49 = p[49];\n+\n+  ITYPE i;\n+\n+  for (i = 0; i < n; i++)\n+    {\n+      ITYPE bit = get_bits (bits[i]);\n+\n+      if ((bit & ((ITYPE)1) << \t0) != 0) x_00 += one;\n+      if ((bit & ((ITYPE)1) << \t1) != 0) x_01 += one;\n+      if ((bit & ((ITYPE)1) << \t2) != 0) x_02 += one;\n+      if ((bit & ((ITYPE)1) << \t3) != 0) x_03 += one;\n+      if ((bit & ((ITYPE)1) << \t4) != 0) x_04 += one;\n+      if ((bit & ((ITYPE)1) << \t5) != 0) x_05 += one;\n+      if ((bit & ((ITYPE)1) << \t6) != 0) x_06 += one;\n+      if ((bit & ((ITYPE)1) << \t7) != 0) x_07 += one;\n+      if ((bit & ((ITYPE)1) << \t8) != 0) x_08 += one;\n+      if ((bit & ((ITYPE)1) << \t9) != 0) x_09 += one;\n+\n+      if ((bit & ((ITYPE)1) << 10) != 0) x_10 += one;\n+      if ((bit & ((ITYPE)1) << 11) != 0) x_11 += one;\n+      if ((bit & ((ITYPE)1) << 12) != 0) x_12 += one;\n+      if ((bit & ((ITYPE)1) << 13) != 0) x_13 += one;\n+      if ((bit & ((ITYPE)1) << 14) != 0) x_14 += one;\n+      if ((bit & ((ITYPE)1) << 15) != 0) x_15 += one;\n+      if ((bit & ((ITYPE)1) << 16) != 0) x_16 += one;\n+      if ((bit & ((ITYPE)1) << 17) != 0) x_17 += one;\n+      if ((bit & ((ITYPE)1) << 18) != 0) x_18 += one;\n+      if ((bit & ((ITYPE)1) << 19) != 0) x_19 += one;\n+\n+      if ((bit & ((ITYPE)1) << 20) != 0) x_20 += one;\n+      if ((bit & ((ITYPE)1) << 21) != 0) x_21 += one;\n+      if ((bit & ((ITYPE)1) << 22) != 0) x_22 += one;\n+      if ((bit & ((ITYPE)1) << 23) != 0) x_23 += one;\n+      if ((bit & ((ITYPE)1) << 24) != 0) x_24 += one;\n+      if ((bit & ((ITYPE)1) << 25) != 0) x_25 += one;\n+      if ((bit & ((ITYPE)1) << 26) != 0) x_26 += one;\n+      if ((bit & ((ITYPE)1) << 27) != 0) x_27 += one;\n+      if ((bit & ((ITYPE)1) << 28) != 0) x_28 += one;\n+      if ((bit & ((ITYPE)1) << 29) != 0) x_29 += one;\n+\n+      if ((bit & ((ITYPE)1) << 30) != 0) x_30 += one;\n+      if ((bit & ((ITYPE)1) << 31) != 0) x_31 += one;\n+      if ((bit & ((ITYPE)1) << 32) != 0) x_32 += one;\n+      if ((bit & ((ITYPE)1) << 33) != 0) x_33 += one;\n+      if ((bit & ((ITYPE)1) << 34) != 0) x_34 += one;\n+      if ((bit & ((ITYPE)1) << 35) != 0) x_35 += one;\n+      if ((bit & ((ITYPE)1) << 36) != 0) x_36 += one;\n+      if ((bit & ((ITYPE)1) << 37) != 0) x_37 += one;\n+      if ((bit & ((ITYPE)1) << 38) != 0) x_38 += one;\n+      if ((bit & ((ITYPE)1) << 39) != 0) x_39 += one;\n+\n+      if ((bit & ((ITYPE)1) << 40) != 0) x_40 += one;\n+      if ((bit & ((ITYPE)1) << 41) != 0) x_41 += one;\n+      if ((bit & ((ITYPE)1) << 42) != 0) x_42 += one;\n+      if ((bit & ((ITYPE)1) << 43) != 0) x_43 += one;\n+      if ((bit & ((ITYPE)1) << 44) != 0) x_44 += one;\n+      if ((bit & ((ITYPE)1) << 45) != 0) x_45 += one;\n+      if ((bit & ((ITYPE)1) << 46) != 0) x_46 += one;\n+      if ((bit & ((ITYPE)1) << 47) != 0) x_47 += one;\n+      if ((bit & ((ITYPE)1) << 48) != 0) x_48 += one;\n+      if ((bit & ((ITYPE)1) << 49) != 0) x_49 += one;\n+    }\n+\n+  q[ 0] = x_00;\n+  q[ 1] = x_01;\n+  q[ 2] = x_02;\n+  q[ 3] = x_03;\n+  q[ 4] = x_04;\n+  q[ 5] = x_05;\n+  q[ 6] = x_06;\n+  q[ 7] = x_07;\n+  q[ 8] = x_08;\n+  q[ 9] = x_09;\n+\n+  q[10] = x_10;\n+  q[11] = x_11;\n+  q[12] = x_12;\n+  q[13] = x_13;\n+  q[14] = x_14;\n+  q[15] = x_15;\n+  q[16] = x_16;\n+  q[17] = x_17;\n+  q[18] = x_18;\n+  q[19] = x_19;\n+\n+  q[20] = x_20;\n+  q[21] = x_21;\n+  q[22] = x_22;\n+  q[23] = x_23;\n+  q[24] = x_24;\n+  q[25] = x_25;\n+  q[26] = x_26;\n+  q[27] = x_27;\n+  q[28] = x_28;\n+  q[29] = x_29;\n+\n+  q[30] = x_30;\n+  q[31] = x_31;\n+  q[32] = x_32;\n+  q[33] = x_33;\n+  q[34] = x_34;\n+  q[35] = x_35;\n+  q[36] = x_36;\n+  q[37] = x_37;\n+  q[38] = x_38;\n+  q[39] = x_39;\n+\n+  q[40] = x_40;\n+  q[41] = x_41;\n+  q[42] = x_42;\n+  q[43] = x_43;\n+  q[44] = x_44;\n+  q[45] = x_45;\n+  q[46] = x_46;\n+  q[47] = x_47;\n+  q[48] = x_48;\n+  q[49] = x_49;\n+}\n+\n+/* { dg-final { scan-assembler     {\\mxsadddp\\M} } } */\n+/* { dg-final { scan-assembler     {\\mstxsdx\\M}  } } */\n+/* { dg-final { scan-assembler-not {\\mmfvsrd\\M}  } } */"}, {"sha": "2f7107b8782d1519e945c3df0c36ba48c5ba6cac", "filename": "gcc/testsuite/gcc.target/powerpc/pr80510-2.c", "status": "added", "additions": 212, "deletions": 0, "changes": 212, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52e14b96bd537b5431c577213c14db4686397d71/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr80510-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52e14b96bd537b5431c577213c14db4686397d71/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr80510-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr80510-2.c?ref=52e14b96bd537b5431c577213c14db4686397d71", "patch": "@@ -0,0 +1,212 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target powerpc_p8vector_ok } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } } */\n+/* { dg-options \"-mcpu=power8 -O2\" } */\n+\n+/* Make sure that STXSSPX is generated for float scalars in Altivec registers\n+   on power7 instead of moving the value to a FPR register and doing a X-FORM\n+   store.  */\n+\n+#ifndef TYPE\n+#define TYPE float\n+#endif\n+\n+#ifndef TYPE_IN\n+#define TYPE_IN TYPE\n+#endif\n+\n+#ifndef TYPE_OUT\n+#define TYPE_OUT TYPE\n+#endif\n+\n+#ifndef ITYPE\n+#define ITYPE long\n+#endif\n+\n+#ifdef DO_CALL\n+extern ITYPE get_bits (ITYPE);\n+\n+#else\n+#define get_bits(X) (X)\n+#endif\n+\n+void test (ITYPE *bits, ITYPE n, TYPE one, TYPE_IN *p, TYPE_OUT *q)\n+{\n+  TYPE x_00 = p[ 0];\n+  TYPE x_01 = p[ 1];\n+  TYPE x_02 = p[ 2];\n+  TYPE x_03 = p[ 3];\n+  TYPE x_04 = p[ 4];\n+  TYPE x_05 = p[ 5];\n+  TYPE x_06 = p[ 6];\n+  TYPE x_07 = p[ 7];\n+  TYPE x_08 = p[ 8];\n+  TYPE x_09 = p[ 9];\n+\n+  TYPE x_10 = p[10];\n+  TYPE x_11 = p[11];\n+  TYPE x_12 = p[12];\n+  TYPE x_13 = p[13];\n+  TYPE x_14 = p[14];\n+  TYPE x_15 = p[15];\n+  TYPE x_16 = p[16];\n+  TYPE x_17 = p[17];\n+  TYPE x_18 = p[18];\n+  TYPE x_19 = p[19];\n+\n+  TYPE x_20 = p[20];\n+  TYPE x_21 = p[21];\n+  TYPE x_22 = p[22];\n+  TYPE x_23 = p[23];\n+  TYPE x_24 = p[24];\n+  TYPE x_25 = p[25];\n+  TYPE x_26 = p[26];\n+  TYPE x_27 = p[27];\n+  TYPE x_28 = p[28];\n+  TYPE x_29 = p[29];\n+\n+  TYPE x_30 = p[30];\n+  TYPE x_31 = p[31];\n+  TYPE x_32 = p[32];\n+  TYPE x_33 = p[33];\n+  TYPE x_34 = p[34];\n+  TYPE x_35 = p[35];\n+  TYPE x_36 = p[36];\n+  TYPE x_37 = p[37];\n+  TYPE x_38 = p[38];\n+  TYPE x_39 = p[39];\n+\n+  TYPE x_40 = p[40];\n+  TYPE x_41 = p[41];\n+  TYPE x_42 = p[42];\n+  TYPE x_43 = p[43];\n+  TYPE x_44 = p[44];\n+  TYPE x_45 = p[45];\n+  TYPE x_46 = p[46];\n+  TYPE x_47 = p[47];\n+  TYPE x_48 = p[48];\n+  TYPE x_49 = p[49];\n+\n+  ITYPE i;\n+\n+  for (i = 0; i < n; i++)\n+    {\n+      ITYPE bit = get_bits (bits[i]);\n+\n+      if ((bit & ((ITYPE)1) << \t0) != 0) x_00 += one;\n+      if ((bit & ((ITYPE)1) << \t1) != 0) x_01 += one;\n+      if ((bit & ((ITYPE)1) << \t2) != 0) x_02 += one;\n+      if ((bit & ((ITYPE)1) << \t3) != 0) x_03 += one;\n+      if ((bit & ((ITYPE)1) << \t4) != 0) x_04 += one;\n+      if ((bit & ((ITYPE)1) << \t5) != 0) x_05 += one;\n+      if ((bit & ((ITYPE)1) << \t6) != 0) x_06 += one;\n+      if ((bit & ((ITYPE)1) << \t7) != 0) x_07 += one;\n+      if ((bit & ((ITYPE)1) << \t8) != 0) x_08 += one;\n+      if ((bit & ((ITYPE)1) << \t9) != 0) x_09 += one;\n+\n+      if ((bit & ((ITYPE)1) << 10) != 0) x_10 += one;\n+      if ((bit & ((ITYPE)1) << 11) != 0) x_11 += one;\n+      if ((bit & ((ITYPE)1) << 12) != 0) x_12 += one;\n+      if ((bit & ((ITYPE)1) << 13) != 0) x_13 += one;\n+      if ((bit & ((ITYPE)1) << 14) != 0) x_14 += one;\n+      if ((bit & ((ITYPE)1) << 15) != 0) x_15 += one;\n+      if ((bit & ((ITYPE)1) << 16) != 0) x_16 += one;\n+      if ((bit & ((ITYPE)1) << 17) != 0) x_17 += one;\n+      if ((bit & ((ITYPE)1) << 18) != 0) x_18 += one;\n+      if ((bit & ((ITYPE)1) << 19) != 0) x_19 += one;\n+\n+      if ((bit & ((ITYPE)1) << 20) != 0) x_20 += one;\n+      if ((bit & ((ITYPE)1) << 21) != 0) x_21 += one;\n+      if ((bit & ((ITYPE)1) << 22) != 0) x_22 += one;\n+      if ((bit & ((ITYPE)1) << 23) != 0) x_23 += one;\n+      if ((bit & ((ITYPE)1) << 24) != 0) x_24 += one;\n+      if ((bit & ((ITYPE)1) << 25) != 0) x_25 += one;\n+      if ((bit & ((ITYPE)1) << 26) != 0) x_26 += one;\n+      if ((bit & ((ITYPE)1) << 27) != 0) x_27 += one;\n+      if ((bit & ((ITYPE)1) << 28) != 0) x_28 += one;\n+      if ((bit & ((ITYPE)1) << 29) != 0) x_29 += one;\n+\n+      if ((bit & ((ITYPE)1) << 30) != 0) x_30 += one;\n+      if ((bit & ((ITYPE)1) << 31) != 0) x_31 += one;\n+      if ((bit & ((ITYPE)1) << 32) != 0) x_32 += one;\n+      if ((bit & ((ITYPE)1) << 33) != 0) x_33 += one;\n+      if ((bit & ((ITYPE)1) << 34) != 0) x_34 += one;\n+      if ((bit & ((ITYPE)1) << 35) != 0) x_35 += one;\n+      if ((bit & ((ITYPE)1) << 36) != 0) x_36 += one;\n+      if ((bit & ((ITYPE)1) << 37) != 0) x_37 += one;\n+      if ((bit & ((ITYPE)1) << 38) != 0) x_38 += one;\n+      if ((bit & ((ITYPE)1) << 39) != 0) x_39 += one;\n+\n+      if ((bit & ((ITYPE)1) << 40) != 0) x_40 += one;\n+      if ((bit & ((ITYPE)1) << 41) != 0) x_41 += one;\n+      if ((bit & ((ITYPE)1) << 42) != 0) x_42 += one;\n+      if ((bit & ((ITYPE)1) << 43) != 0) x_43 += one;\n+      if ((bit & ((ITYPE)1) << 44) != 0) x_44 += one;\n+      if ((bit & ((ITYPE)1) << 45) != 0) x_45 += one;\n+      if ((bit & ((ITYPE)1) << 46) != 0) x_46 += one;\n+      if ((bit & ((ITYPE)1) << 47) != 0) x_47 += one;\n+      if ((bit & ((ITYPE)1) << 48) != 0) x_48 += one;\n+      if ((bit & ((ITYPE)1) << 49) != 0) x_49 += one;\n+    }\n+\n+  q[ 0] = x_00;\n+  q[ 1] = x_01;\n+  q[ 2] = x_02;\n+  q[ 3] = x_03;\n+  q[ 4] = x_04;\n+  q[ 5] = x_05;\n+  q[ 6] = x_06;\n+  q[ 7] = x_07;\n+  q[ 8] = x_08;\n+  q[ 9] = x_09;\n+\n+  q[10] = x_10;\n+  q[11] = x_11;\n+  q[12] = x_12;\n+  q[13] = x_13;\n+  q[14] = x_14;\n+  q[15] = x_15;\n+  q[16] = x_16;\n+  q[17] = x_17;\n+  q[18] = x_18;\n+  q[19] = x_19;\n+\n+  q[20] = x_20;\n+  q[21] = x_21;\n+  q[22] = x_22;\n+  q[23] = x_23;\n+  q[24] = x_24;\n+  q[25] = x_25;\n+  q[26] = x_26;\n+  q[27] = x_27;\n+  q[28] = x_28;\n+  q[29] = x_29;\n+\n+  q[30] = x_30;\n+  q[31] = x_31;\n+  q[32] = x_32;\n+  q[33] = x_33;\n+  q[34] = x_34;\n+  q[35] = x_35;\n+  q[36] = x_36;\n+  q[37] = x_37;\n+  q[38] = x_38;\n+  q[39] = x_39;\n+\n+  q[40] = x_40;\n+  q[41] = x_41;\n+  q[42] = x_42;\n+  q[43] = x_43;\n+  q[44] = x_44;\n+  q[45] = x_45;\n+  q[46] = x_46;\n+  q[47] = x_47;\n+  q[48] = x_48;\n+  q[49] = x_49;\n+}\n+\n+/* { dg-final { scan-assembler     {\\mxsaddsp\\M} } } */\n+/* { dg-final { scan-assembler     {\\mstxsspx\\M} } } */\n+/* { dg-final { scan-assembler-not {\\mmfvsrd\\M}  } } */\n+/* { dg-final { scan-assembler-not {\\mmfvsrwz\\M} } } */"}]}