{"sha": "17fd0700509e4263ae27080a2edd80a9e256514e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTdmZDA3MDA1MDllNDI2M2FlMjcwODBhMmVkZDgwYTllMjU2NTE0ZQ==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-01-16T19:12:09Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-01-16T19:12:09Z"}, "message": "Initial revision\n\nFrom-SVN: r196", "tree": {"sha": "750ef51f1df1cd8ac1c1a8eb409fb46bc006a258", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/750ef51f1df1cd8ac1c1a8eb409fb46bc006a258"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/17fd0700509e4263ae27080a2edd80a9e256514e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17fd0700509e4263ae27080a2edd80a9e256514e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/17fd0700509e4263ae27080a2edd80a9e256514e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17fd0700509e4263ae27080a2edd80a9e256514e/comments", "author": null, "committer": null, "parents": [{"sha": "a56060e3c893b0e595ff1e50736e73209abd5065", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a56060e3c893b0e595ff1e50736e73209abd5065", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a56060e3c893b0e595ff1e50736e73209abd5065"}], "stats": {"total": 364, "additions": 364, "deletions": 0}, "files": [{"sha": "44680e06f57427239efbea7fe5ec3ca26c5c037a", "filename": "gcc/config/i860/sysv4.h", "status": "added", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17fd0700509e4263ae27080a2edd80a9e256514e/gcc%2Fconfig%2Fi860%2Fsysv4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17fd0700509e4263ae27080a2edd80a9e256514e/gcc%2Fconfig%2Fi860%2Fsysv4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi860%2Fsysv4.h?ref=17fd0700509e4263ae27080a2edd80a9e256514e", "patch": "@@ -0,0 +1,131 @@\n+/* Target definitions for GNU compiler for Intel 80860 running System V.4\n+   Copyright (C) 1991 Free Software Foundation, Inc.\n+\n+   Written by Ron Guilmette (rfg@ncd.com).\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#include \"i860.h\"\n+#include \"svr4.h\"\n+\n+#undef TARGET_VERSION\n+#define TARGET_VERSION fprintf (stderr, \" (i860 System V Release 4)\");\n+\n+/* Provide a set of pre-definitions and pre-assertions appropriate for\n+   the i860 running svr4.  Note that the symbol `__SVR4__' MUST BE\n+   DEFINED!  It is needed so that the va_list struct in va-i860.h\n+   will get correctly defined for the svr4 (ABI compliant) case rather\n+   than for the previous (svr3, svr2, ...) case.  It also needs to be\n+   defined so that the correct (svr4) version of __builtin_saveregs\n+   will be selected when we are building gnulib2.c.\n+   __svr4__ is our extension.  */\n+\n+#define CPP_PREDEFINES \\\n+  \"-Di860 -Dunix -DSVR4 -D__svr4__ -Asystem(unix) -Acpu(i860) -Amachine(i860)\"\n+\n+/* The prefix to be used in assembler output for all names of registers.\n+   This string gets prepended to all i860 register names (svr4 only).  */\n+\n+#define I860_REG_PREFIX\t\"%\"\n+\n+#define ASM_COMMENT_START \"#\"\n+\n+#undef TYPE_OPERAND_FMT\n+#define TYPE_OPERAND_FMT      \"\\\"%s\\\"\"\n+\n+#define DBX_REGISTER_NUMBER(REGNO) (REGNO)\n+\n+/* The following macro definition overrides the one in i860.h\n+   because the svr4 i860 assembler requires a different syntax\n+   for getting parts of constant/relocatable values.  */\n+\n+#undef PRINT_OPERAND_PART\n+#define PRINT_OPERAND_PART(FILE, X, PART_CODE)\t\t\t\t\\\n+  do { fprintf (FILE, \"[\");\t\t\t\t\t\t\\\n+\toutput_address (X);\t\t\t\t\t\t\\\n+\tfprintf (FILE, \"]@%s\", PART_CODE);\t\t\t\t\\\n+  } while (0)\n+\n+#undef ASM_FILE_START\n+#define ASM_FILE_START(FILE)\t\t\t\t\t\t\\\n+  do {\toutput_file_directive (FILE, main_input_filename);\t\t\\\n+\tfprintf (FILE, \"\\t.version\\t\\\"01.01\\\"\\n\");\t\t\t\\\n+  } while (0)\n+\n+/* Output the special word the svr4 SDB wants to see just before\n+   the first word of each function's prologue code.  */\n+\n+extern char *current_function_original_name;\n+\n+/* This special macro is used to output a magic word just before the\n+   first word of each function.  On some versions of UNIX running on\n+   the i860, this word can be any word that looks like a NOP, however\n+   under svr4, this neds to be an `shr r0,r0,r0' instruction in which\n+   the normally unused low-order bits contain the length of the function\n+   prologue code (in bytes).  This is needed to make the svr4 SDB debugger\n+   happy.  */\n+\n+#undef ASM_OUTPUT_FUNCTION_PREFIX\n+#define ASM_OUTPUT_FUNCTION_PREFIX(FILE, FNNAME)\t\t\t\\\n+  do {\tASM_OUTPUT_ALIGN (FILE, 2);\t\t\t\t\t\\\n+  \tfprintf ((FILE), \"\\t.long\\t.ep.\");\t\t\t\t\\\n+\tassemble_name (FILE, FNNAME);\t\t\t\t\t\\\n+\tfprintf (FILE, \"-\");\t\t\t\t\t\t\\\n+\tassemble_name (FILE, FNNAME);\t\t\t\t\t\\\n+\tfprintf (FILE, \"+0xc8000000\\n\");\t\t\t\t\\\n+\tcurrent_function_original_name = (FNNAME);\t\t\t\\\n+  } while (0)\n+\n+/* Output the special label that must go just after each function's\n+   prologue code to support svr4 SDB.  */\n+\n+#define ASM_OUTPUT_PROLOGUE_SUFFIX(FILE)\t\t\t\t\\\n+  do {\tfprintf (FILE, \".ep.\");\t\t\t\t\t\t\\\n+\tassemble_name (FILE, current_function_original_name);\t\t\\\n+\tfprintf (FILE, \":\\n\");\t\t\t\t\t\t\\\n+  } while (0)\n+\n+#undef CTORS_SECTION_ASM_OP\n+#define CTORS_SECTION_ASM_OP\t\"\\t.section\\t.ctors,\\\"a\\\",\\\"progbits\\\"\\n\"\n+#undef DTORS_SECTION_ASM_OP\n+#define DTORS_SECTION_ASM_OP\t\"\\t.section\\t.dtors,\\\"a\\\",\\\"progbits\\\"\\n\"\n+\n+/* Add definitions to support the .tdesc section as specified in the svr4\n+   ABI for the i860.  */\n+\n+#define TDESC_SECTION_ASM_OP    \"\\t.section\\t.tdesc\"\n+\n+#undef EXTRA_SECTIONS\n+#define EXTRA_SECTIONS in_const, in_ctors, in_dtors, in_tdesc\n+\n+#undef EXTRA_SECTION_FUNCTIONS\n+#define EXTRA_SECTION_FUNCTIONS\t\t\t\t\t\t\\\n+  CONST_SECTION_FUNCTION\t\t\t\t\t\t\\\n+  CTORS_SECTION_FUNCTION\t\t\t\t\t\t\\\n+  DTORS_SECTION_FUNCTION\t\t\t\t\t\t\\\n+  TDESC_SECTION_FUNCTION\n+\n+#define TDESC_SECTION_FUNCTION\t\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\t\t\\\n+tdesc_section ()\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (in_section != in_tdesc)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"%s\\n\", TDESC_SECTION_ASM_OP);\t\t\\\n+      in_section = in_tdesc;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}"}, {"sha": "c9efdcb1f062a517fff229a583c3206d6f56dd48", "filename": "gcc/config/m68k/m68kv4.h", "status": "added", "additions": 184, "deletions": 0, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17fd0700509e4263ae27080a2edd80a9e256514e/gcc%2Fconfig%2Fm68k%2Fm68kv4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17fd0700509e4263ae27080a2edd80a9e256514e/gcc%2Fconfig%2Fm68k%2Fm68kv4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68kv4.h?ref=17fd0700509e4263ae27080a2edd80a9e256514e", "patch": "@@ -0,0 +1,184 @@\n+/* Target definitions for GNU compiler for mc680x0 running System V.4\n+   Copyright (C) 1991 Free Software Foundation, Inc.\n+\n+   Written by Ron Guilmette (rfg@ncd.com) and Fred Fish (fnf@cygnus.com).\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+/* Use SGS_* macros to control compilation in m68k.md */\n+\n+#define SGS_SWAP_W\t\t/* Use swap.w rather than just plain swap */\n+#define SGS_SWITCH_TABLES\t/* Different switch table handling */\n+\n+#include \"m68ksgs.h\"\t\t/* The m68k/SVR4 assembler is SGS based */\n+#include \"svr4.h\"\t\t/* Pick up the generic SVR4 macros */\n+\n+/* See m68k.h.  7 means 68020 with 68881.  */\n+\n+#ifndef TARGET_DEFAULT\n+#define\tTARGET_DEFAULT (5 /*68020*/ + 2 /*68881*/)\n+#endif\n+\n+/*  Override the definition of NO_DOLLAR_IN_LABEL in svr4.h, for special\n+    g++ assembler names.  When this is defined, g++ uses embedded '.'\n+    characters and some m68k assemblers have problems with this.  The\n+    chances are much greater that any particular assembler will permit\n+    embedded '$' characters. */\n+\n+#undef NO_DOLLAR_IN_LABEL\n+\n+/* Define PCC_STATIC_STRUCT_RETURN if the convention on the target machine\n+   is to use the nonreentrant technique for returning structure and union\n+   values, as commonly implemented by the AT&T Portable C Compiler (PCC).\n+   When defined, the gcc option -fpcc-struct-return can be used to cause\n+   this form to be generated.  When undefined, the option does nothing.\n+   For m68k SVR4, the convention is to use a reentrant technique compatible\n+   with the gcc default, so override the definition of this macro in m68k.h */\n+\n+#undef PCC_STATIC_STRUCT_RETURN\n+\n+/* Provide a set of pre-definitions and pre-assertions appropriate for\n+   the m68k running svr4.  __svr4__ is our extension.  */\n+\n+#define CPP_PREDEFINES \\\n+  \"-Dm68k -Dunix -D__svr4__ -Asystem(unix) -Acpu(m68k) -Amachine(m68k)\"\n+\n+/* Test to see if the target includes a 68881 by default, and use CPP_SPEC\n+   to control whether or not __HAVE_68881__ is defined by default or not.\n+   If a 68881 is the default, gcc will use inline 68881 instructions, by\n+   predefining __HAVE_68881__, unless -msoft-float is specified.\n+   If a 68881 is not the default, gcc will only define __HAVE_68881__ if\n+   -m68881 is specified. */\n+\n+#if TARGET_DEFAULT & 2\n+#define CPP_SPEC \"%{!msoft-float:-D__HAVE_68881__}\"\n+#else\n+#define CPP_SPEC \"%{m68881:-D__HAVE_68881__}\"\n+#endif\n+\n+/* Output assembler code to FILE to increment profiler label # LABELNO\n+   for profiling a function entry.  We override the definition in m68k.h\n+   and match the way the native m68k/SVR4 compiler does profiling, with the\n+   address of the profile counter in a1, not a0, and using bsr rather\n+   than jsr. */\n+\n+#undef FUNCTION_PROFILER\n+#define FUNCTION_PROFILER(FILE, LABELNO)\t\t\t\t\\\n+  asm_fprintf ((FILE), \"\\tlea.l\\t(%LLP%d,%Rpc),%Ra1\\n\\tbsr\\t_mcount\\n\", \\\n+\t       (LABELNO))\n+\n+/* Local common symbols are declared to the assembler with \".lcomm\" rather\n+   than \".bss\", so override the definition in svr4.h */\n+\n+#undef BSS_ASM_OP\n+#define BSS_ASM_OP\t\"\\t.lcomm\"\n+\n+/* Register in which address to store a structure value is passed to a\n+   function.  The default in m68k.h is a1.  For m68k/SVR4 it is a0. */\n+\n+#undef STRUCT_VALUE_REGNUM\n+#define STRUCT_VALUE_REGNUM 8\n+\n+#define ASM_COMMENT_START \"#\"\n+\n+#undef TYPE_OPERAND_FMT\n+#define TYPE_OPERAND_FMT      \"@%s\"\n+\n+/* Define how the m68k registers should be numbered for Dwarf output.\n+   The numbering provided here should be compatible with the native\n+   SVR4 SDB debugger in the m68k/SVR4 reference port, where d0-d7\n+   are 0-7, a0-a8 are 8-15, and fp0-fp7 are 16-23. */\n+\n+#define DBX_REGISTER_NUMBER(REGNO) (REGNO)\n+\n+/* The ASM_OUTPUT_SKIP macro is first defined in m68k.h, using \".skip\".\n+   It is then overridden by m68ksgs.h to use \".space\", and again by svr4.h\n+   to use \".zero\".  The m68k/SVR4 assembler uses \".space\", so repeat the\n+   definition from m68ksgs.h here.  Note that ASM_NO_SKIP_IN_TEXT is\n+   defined in m68ksgs.h, so we don't have to repeat it here. */\n+\n+#undef ASM_OUTPUT_SKIP\n+#define ASM_OUTPUT_SKIP(FILE,SIZE)  \\\n+  fprintf (FILE, \"%s %u\\n\", SPACE_ASM_OP, (SIZE))\n+\n+/* 1 if N is a possible register number for a function value.\n+   For m68k/SVR4 allow d0, a0, or fp0 as return registers, for integral,\n+   pointer, or floating types, respectively. Reject fp0 if not using a\n+   68881 coprocessor. */\n+\n+#undef FUNCTION_VALUE_REGNO_P\n+#define FUNCTION_VALUE_REGNO_P(N) \\\n+  ((N) == 0 || (N) == 8 || (TARGET_68881 && (N) == 16))\n+\n+/* Define how to generate (in the callee) the output value of a function\n+   and how to find (in the caller) the value returned by a function.  VALTYPE\n+   is the data type of the value (as a tree).  If the precise function being\n+   called is known, FUNC is its FUNCTION_DECL; otherwise, FUNC is 0.\n+   For m68k/SVR4 generate the result in d0, a0, or fp0 as appropriate. */\n+   \n+#undef FUNCTION_VALUE\n+#define FUNCTION_VALUE(VALTYPE, FUNC)\t\t\t\t\t\\\n+  (TREE_CODE (VALTYPE) == REAL_TYPE && TARGET_68881\t\t\t\\\n+   ? gen_rtx (REG, TYPE_MODE (VALTYPE), 16)\t\t\t\t\\\n+   : (TREE_CODE (VALTYPE) == POINTER_TYPE\t\t\t\t\\\n+      ? gen_rtx (REG, TYPE_MODE (VALTYPE), 8)\t\t\t\t\\\n+      : gen_rtx (REG, TYPE_MODE (VALTYPE), 0)))\n+\n+/* For compatibility with the large body of existing code which does not\n+   always properly declare external functions returning pointer types, the\n+   m68k/SVR4 convention is to copy the value returned for pointer functions\n+   from a0 to d0 in the function epilogue, so that callers that have\n+   neglected to properly declare the callee can still find the correct return\n+   value. */\n+\n+extern int current_function_returns_pointer;\n+#define FUNCTION_EXTRA_EPILOGUE(FILE, SIZE)\t\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  if ((current_function_returns_pointer) && \t\t\t\t\\\n+      ! find_equiv_reg (0, get_last_insn (), 0, 0, 0, 8, Pmode))\t\\\n+    asm_fprintf (FILE, \"\\tmov.l %Ra0,%Rd0\\n\");\t\t\t\t\\\n+} while (0);\n+\n+/* Define how to find the value returned by a library function assuming the\n+   value has mode MODE.\n+   For m68k/SVR4 look for integer values in d0, pointer values in d0\n+   (returned in both d0 and a0), and floating values in fp0. */\n+\n+#undef LIBCALL_VALUE\n+#define LIBCALL_VALUE(MODE)\t\t\t\t\t\t\\\n+  (((MODE) == SFmode || (MODE) == DFmode) && TARGET_68881\t\t\\\n+   ? gen_rtx (REG, (MODE), 16)\t\t\t\t\t\t\\\n+   : gen_rtx (REG, (MODE), 0))\n+\n+/* Boundary (in *bits*) on which stack pointer should be aligned.\n+   The m68k/SVR4 convention is to keep the stack pointer longword aligned. */\n+ \n+#undef STACK_BOUNDARY\n+#define STACK_BOUNDARY 32\n+\n+/* Alignment of field after `int : 0' in a structure.\n+   For m68k/SVR4, this is the next longword boundary. */\n+\n+#undef EMPTY_FIELD_BOUNDARY\n+#define EMPTY_FIELD_BOUNDARY 32\n+\n+/* No data type wants to be aligned rounder than this.\n+   For m68k/SVR4, some types (doubles for example) are aligned on 8 byte\n+   boundaries */\n+\t\n+#undef BIGGEST_ALIGNMENT\n+#define BIGGEST_ALIGNMENT 64"}, {"sha": "f87784df45601d0cc56f95dbdcaf46f3a55a1cb8", "filename": "gcc/config/sparc/sysv4.h", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17fd0700509e4263ae27080a2edd80a9e256514e/gcc%2Fconfig%2Fsparc%2Fsysv4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17fd0700509e4263ae27080a2edd80a9e256514e/gcc%2Fconfig%2Fsparc%2Fsysv4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsysv4.h?ref=17fd0700509e4263ae27080a2edd80a9e256514e", "patch": "@@ -0,0 +1,49 @@\n+/* Target definitions for GNU compiler for Sparc running System V.4\n+   Copyright (C) 1991 Free Software Foundation, Inc.\n+\n+   Written by Ron Guilmette (rfg@ncd.com).\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#include \"sparc.h\"\n+#include \"svr4.h\"\n+\n+/* Provide a set of pre-definitions and pre-assertions appropriate for\n+   the sparc running svr4.  __svr4__ is our extension.  */\n+\n+#define CPP_PREDEFINES \\\n+  \"-Dsparc -Dunix -D__svr4__ -Asystem(unix) -Acpu(sparc) -Amachine(sparc)\"\n+\n+#define ASM_COMMENT_START \"!\"\n+\n+#undef TYPE_OPERAND_FMT\n+#define TYPE_OPERAND_FMT      \"#%s\"\n+\n+/* Define how the sparc registers should be numbered for Dwarf output.\n+   The numbering provided here should be compatible with the native\n+   svr4 SDB debugger in the sparc/svr4 reference port.  */\n+\n+#define DBX_REGISTER_NUMBER(REGNO)\t\t\t\t\t\\\n+  ((REGNO) < 32) ? (REGNO) : ((REGNO) + 8))\n+\n+/* A pair of defines for the set of pseudo-ops used to switch to the\n+   .ctors and .dtors sections.  Note that on the sparc, all user-defined\n+   sections have the \"progbits\" attribute by default, so we don't even\n+   specify it here.  */\n+\n+#define CTORS_SECTION_ASM_OP    \"\\t.section\\t.ctors,\\\"a\\\"\"\n+#define DTORS_SECTION_ASM_OP    \"\\t.section\\t.dtors,\\\"a\\\"\""}]}