{"sha": "8daa1407f25ea782a2e9fd35d6a30807cabfecc9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGRhYTE0MDdmMjVlYTc4MmEyZTlmZDM1ZDZhMzA4MDdjYWJmZWNjOQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2011-11-04T14:10:01Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-11-04T14:10:01Z"}, "message": "gnat_ugn.texi (Performance Considerations): New sub-section.\n\n2011-11-04  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* gnat_ugn.texi (Performance Considerations) <Vectorization\n\tof loops>: New sub-section.  <Other Optimization Switches>:\n\tMinor tweak.\n\nFrom-SVN: r180956", "tree": {"sha": "0a8b105bf6136e79d93083539465c006e1262c92", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0a8b105bf6136e79d93083539465c006e1262c92"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8daa1407f25ea782a2e9fd35d6a30807cabfecc9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8daa1407f25ea782a2e9fd35d6a30807cabfecc9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8daa1407f25ea782a2e9fd35d6a30807cabfecc9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8daa1407f25ea782a2e9fd35d6a30807cabfecc9/comments", "author": null, "committer": null, "parents": [{"sha": "1adaea169e06627aa8482d1afebf178a3ca67edf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1adaea169e06627aa8482d1afebf178a3ca67edf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1adaea169e06627aa8482d1afebf178a3ca67edf"}], "stats": {"total": 106, "additions": 102, "deletions": 4}, "files": [{"sha": "1da914346dd66eb4e9c72b2b32cbfc4d4e4ee5a8", "filename": "gcc/ada/gnat_ugn.texi", "status": "modified", "additions": 102, "deletions": 4, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8daa1407f25ea782a2e9fd35d6a30807cabfecc9/gcc%2Fada%2Fgnat_ugn.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8daa1407f25ea782a2e9fd35d6a30807cabfecc9/gcc%2Fada%2Fgnat_ugn.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_ugn.texi?ref=8daa1407f25ea782a2e9fd35d6a30807cabfecc9", "patch": "@@ -337,6 +337,7 @@ Performance Considerations\n * Optimization Levels::\n * Debugging Optimized Code::\n * Inlining of Subprograms::\n+* Vectorization of loops::\n * Other Optimization Switches::\n * Optimization and Strict Aliasing::\n @ifset vms\n@@ -10150,6 +10151,7 @@ some guidelines on debugging optimized code.\n * Optimization Levels::\n * Debugging Optimized Code::\n * Inlining of Subprograms::\n+* Vectorization of loops::\n * Other Optimization Switches::\n * Optimization and Strict Aliasing::\n \n@@ -10595,17 +10597,113 @@ that you should not automatically assume that @option{-O3} is better than\n @option{-O2}, and indeed you should use @option{-O3} only if tests show that\n it actually improves performance.\n \n+@node Vectorization of loops\n+@subsection Vectorization of loops\n+@cindex Optimization Switches\n+\n+You can take advantage of the auto-vectorizer present in the @command{gcc}\n+back end to vectorize loops with GNAT.  The corresponding command line switch\n+is @option{-ftree-vectorize} but, as it is enabled by default at @option{-O3}\n+and other aggressive optimizations helpful for vectorization also are enabled\n+by default at this level, using @option{-O3} directly is recommended.\n+\n+You also need to make sure that the target architecture features a supported\n+SIMD instruction set.  For example, for the x86 architecture, you should at\n+least specify @option{-msse2} to get significant vectorization (but you don't\n+need to specify it for x86-64 as it is part of the base 64-bit architecture).\n+Similarly, for the PowerPC architecture, you should specify @option{-maltivec}.\n+\n+The preferred loop form for vectorization is the @code{for} iteration scheme.\n+Loops with a @code{while} iteration scheme can also be vectorized if they are\n+very simple, but the vectorizer will quickly give up otherwise.  With either\n+iteration scheme, the flow of control must be straight, in particular no\n+@code{exit} statement may appear in the loop body.  The loop may however\n+contain a single nested loop, if it can be vectorized when considered alone:\n+\n+@smallexample @c ada\n+@cartouche\n+   A : array (1..4, 1..4) of Long_Float;\n+   S : array (1..4) of Long_Float;\n+\n+   procedure Sum is\n+   begin\n+      for I in A'Range(1) loop\n+         for J in A'Range(2) loop\n+            S (I) := S (I) + A (I, J);\n+         end loop;\n+      end loop;\n+   end Sum;\n+@end cartouche\n+@end smallexample\n+\n+The vectorizable operations depend on the targeted SIMD instruction set, but\n+the adding and some of the multiplying operators are generally supported, as\n+well as the logical operators for modular types.  Note that, in the former\n+case, enabling overflow checks, for example with @option{-gnato}, totally\n+disables vectorization.  The other checks are not supposed to have the same\n+definitive effect, although compiling with @option{-gnatp} might well reveal\n+cases where some checks do thwart vectorization.\n+\n+Type conversions may also prevent vectorization if they involve semantics that\n+are not directly supported by the code generator or the SIMD instruction set.\n+A typical example is direct conversion from floating-point to integer types.\n+The solution in this case is to use the following idiom:\n+\n+@smallexample @c ada\n+   Integer (S'Truncation (F))\n+@end smallexample\n+\n+@noindent\n+if @code{S} is the subtype of floating-point object @code{F}.\n+\n+In most cases, the vectorizable loops are loops that iterate over arrays.\n+All kinds of array types are supported, i.e. constrained array types with\n+static bounds:\n+\n+@smallexample @c ada\n+   type Array_Type is array (1 .. 4) of Long_Float;\n+@end smallexample\n+\n+@noindent\n+constrained array types with dynamic bounds:\n+\n+@smallexample @c ada\n+   type Array_Type is array (1 .. Q.N) of Long_Float;\n+\n+   type Array_Type is array (Q.K .. 4) of Long_Float;\n+\n+   type Array_Type is array (Q.K .. Q.N) of Long_Float;\n+@end smallexample\n+\n+@noindent\n+or unconstrained array types:\n+\n+@smallexample @c ada\n+  type Array_Type is array (Positive range <>) of Long_Float;\n+@end smallexample\n+\n+@noindent\n+The quality of the generated code decreases when the dynamic aspect of the\n+array type increases, the worst code being generated for unconstrained array\n+types.  This is so because, the less information the compiler has about the\n+bounds of the array, the more fallback code it needs to generate in order to\n+fix things up at run time.\n+\n+You can obtain information about the vectorization performed by the compiler\n+by specifying @option{-ftree-vectorizer-verbose=N}.  For more details of\n+this switch, see @ref{Debugging Options,,Options for Debugging Your Program\n+or GCC, gcc, Using the GNU Compiler Collection (GCC)}.\n+\n @node Other Optimization Switches\n @subsection Other Optimization Switches\n @cindex Optimization Switches\n \n Since @code{GNAT} uses the @command{gcc} back end, all the specialized\n @command{gcc} optimization switches are potentially usable. These switches\n have not been extensively tested with GNAT but can generally be expected\n-to work. Examples of switches in this category are\n-@option{-funroll-loops} and\n-the various target-specific @option{-m} options (in particular, it has been\n-observed that @option{-march=pentium4} can significantly improve performance\n+to work. Examples of switches in this category are @option{-funroll-loops}\n+and the various target-specific @option{-m} options (in particular, it has\n+been observed that @option{-march=xxx} can significantly improve performance\n on appropriate machines). For full details of these switches, see\n @ref{Submodel Options,, Hardware Models and Configurations, gcc, Using\n the GNU Compiler Collection (GCC)}."}]}