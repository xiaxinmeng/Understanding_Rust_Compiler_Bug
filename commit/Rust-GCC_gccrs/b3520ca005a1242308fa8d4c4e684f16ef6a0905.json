{"sha": "b3520ca005a1242308fa8d4c4e684f16ef6a0905", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjM1MjBjYTAwNWExMjQyMzA4ZmE4ZDRjNGU2ODRmMTZlZjZhMDkwNQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-04-24T10:22:43Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-04-24T10:22:43Z"}, "message": "[multiple changes]\n\n2009-04-24  Tristan Gingold  <gingold@adacore.com>\n\n\t* s-osinte-darwin.adb, s-osinte-darwin.ads: lwp_self now returns the\n\tmach thread id.\n\n2009-04-24  Emmanuel Briot  <briot@adacore.com>\n\n\t* prj-env.adb, prj-env.ads (Body_Path_Name_Of, Spec_Path_Name_Of,\n\tPath_Name_Of_Library_Unit_Body): rEmove unused subprograms.\n\t(For_All_Imported_Projects): new procedure\n\t(For_All_Source_Dirs, For_All_Object_Dirs): Rewritten based on the\n\tabove rather than duplicating code.\n\nFrom-SVN: r146692", "tree": {"sha": "87a03c6046635cad57010072842233d2ea80adbf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/87a03c6046635cad57010072842233d2ea80adbf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b3520ca005a1242308fa8d4c4e684f16ef6a0905", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3520ca005a1242308fa8d4c4e684f16ef6a0905", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b3520ca005a1242308fa8d4c4e684f16ef6a0905", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3520ca005a1242308fa8d4c4e684f16ef6a0905/comments", "author": null, "committer": null, "parents": [{"sha": "5d07d0cfa86e9985f850fe41c46681f8f53eac71", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d07d0cfa86e9985f850fe41c46681f8f53eac71", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d07d0cfa86e9985f850fe41c46681f8f53eac71"}], "stats": {"total": 553, "additions": 116, "deletions": 437}, "files": [{"sha": "ce28114bb5d6e8aeca5fbf5acbd76d2b3a0ea738", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3520ca005a1242308fa8d4c4e684f16ef6a0905/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3520ca005a1242308fa8d4c4e684f16ef6a0905/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=b3520ca005a1242308fa8d4c4e684f16ef6a0905", "patch": "@@ -1,3 +1,16 @@\n+2009-04-24  Tristan Gingold  <gingold@adacore.com>\n+\n+\t* s-osinte-darwin.adb, s-osinte-darwin.ads: lwp_self now returns the\n+\tmach thread id.\n+\n+2009-04-24  Emmanuel Briot  <briot@adacore.com>\n+\n+\t* prj-env.adb, prj-env.ads (Body_Path_Name_Of, Spec_Path_Name_Of,\n+\tPath_Name_Of_Library_Unit_Body): rEmove unused subprograms.\n+\t(For_All_Imported_Projects): new procedure\n+\t(For_All_Source_Dirs, For_All_Object_Dirs): Rewritten based on the\n+\tabove rather than duplicating code.\n+\n 2009-04-24  Emmanuel Briot  <briot@adacore.com>\n \n \t* prj-proc.adb, prj.adb, prj.ads, prj-nmsc.adb, prj-env.adb"}, {"sha": "7b9b83e4ae663fcf17aca591d9a07482d2d1e25f", "filename": "gcc/ada/prj-env.adb", "status": "modified", "additions": 80, "deletions": 427, "changes": 507, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3520ca005a1242308fa8d4c4e684f16ef6a0905/gcc%2Fada%2Fprj-env.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3520ca005a1242308fa8d4c4e684f16ef6a0905/gcc%2Fada%2Fprj-env.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-env.adb?ref=b3520ca005a1242308fa8d4c4e684f16ef6a0905", "patch": "@@ -60,22 +60,20 @@ package body Prj.Env is\n    Default_Naming    : constant Naming_Id := Naming_Table.First;\n    Fill_Mapping_File : Boolean := True;\n \n+   package Project_Boolean_Htable is new Simple_HTable\n+     (Header_Num => Header_Num,\n+      Element    => Boolean,\n+      No_Element => False,\n+      Key        => Project_Id,\n+      Hash       => Hash,\n+      Equal      => \"=\");\n+   --  A table that associates a project to a boolean. This is used to detect\n+   --  whether a project was already processed for instance.\n+\n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n \n-   function Body_Path_Name_Of\n-     (Unit    : Unit_Index;\n-      In_Tree : Project_Tree_Ref) return String;\n-   --  Returns the path name of the body of a unit.\n-   --  Compute it first, if necessary.\n-\n-   function Spec_Path_Name_Of\n-     (Unit    : Unit_Index;\n-      In_Tree : Project_Tree_Ref) return String;\n-   --  Returns the path name of the spec of a unit.\n-   --  Compute it first, if necessary.\n-\n    procedure Add_To_Path\n      (Source_Dirs : String_List_Id;\n       In_Tree     : Project_Tree_Ref);\n@@ -504,69 +502,6 @@ package body Prj.Env is\n       end loop;\n    end Add_To_Source_Path;\n \n-   -----------------------\n-   -- Body_Path_Name_Of --\n-   -----------------------\n-\n-   function Body_Path_Name_Of\n-     (Unit    : Unit_Index;\n-      In_Tree : Project_Tree_Ref) return String\n-   is\n-      Data : Unit_Data := In_Tree.Units.Table (Unit);\n-\n-   begin\n-      --  If we don't know the path name of the body of this unit,\n-      --  we compute it, and we store it.\n-\n-      if Data.File_Names (Body_Part).Path = No_Path_Information then\n-         declare\n-            Current_Source : String_List_Id :=\n-              In_Tree.Projects.Table\n-                (Data.File_Names (Body_Part).Project).Ada_Sources;\n-            Path : GNAT.OS_Lib.String_Access;\n-\n-         begin\n-            --  By default, put the file name\n-\n-            Data.File_Names (Body_Part).Path.Name :=\n-              Path_Name_Type (Data.File_Names (Body_Part).Name);\n-\n-            --  For each source directory\n-\n-            while Current_Source /= Nil_String loop\n-               Path :=\n-                 Locate_Regular_File\n-                   (Namet.Get_Name_String\n-                      (Data.File_Names (Body_Part).Name),\n-                    Namet.Get_Name_String\n-                      (In_Tree.String_Elements.Table\n-                         (Current_Source).Value));\n-\n-               --  If the file is in this directory, then we store the path,\n-               --  and we are done.\n-\n-               if Path /= null then\n-                  Name_Len := Path'Length;\n-                  Name_Buffer (1 .. Name_Len) := Path.all;\n-                  Data.File_Names (Body_Part).Path.Name := Name_Enter;\n-                  exit;\n-\n-               else\n-                  Current_Source :=\n-                    In_Tree.String_Elements.Table\n-                      (Current_Source).Next;\n-               end if;\n-            end loop;\n-\n-            In_Tree.Units.Table (Unit) := Data;\n-         end;\n-      end if;\n-\n-      --  Returned the stored value\n-\n-      return Namet.Get_Name_String (Data.File_Names (Body_Part).Path.Name);\n-   end Body_Path_Name_Of;\n-\n    ------------------------\n    -- Contains_ALI_Files --\n    ------------------------\n@@ -1527,104 +1462,80 @@ package body Prj.Env is\n       return \"\";\n    end File_Name_Of_Library_Unit_Body;\n \n-   -------------------------\n-   -- For_All_Object_Dirs --\n-   -------------------------\n+   -------------------------------\n+   -- For_All_Imported_Projects --\n+   -------------------------------\n \n-   procedure For_All_Object_Dirs\n+   procedure For_All_Imported_Projects\n      (Project : Project_Id;\n       In_Tree : Project_Tree_Ref)\n    is\n-      Seen : Project_List := Empty_Project_List;\n+      use Project_Boolean_Htable;\n+      Seen : Project_Boolean_Htable.Instance := Project_Boolean_Htable.Nil;\n \n-      procedure Add (Project : Project_Id);\n-      --  Process a project. Remember the processes visited to avoid processing\n-      --  a project twice. Recursively process an eventual extended project,\n-      --  and all imported projects.\n+      procedure Recurse (Prj : Project_Id);\n+      --  Process Prj recursively\n \n-      ---------\n-      -- Add --\n-      ---------\n+      -------------\n+      -- Recurse --\n+      -------------\n \n-      procedure Add (Project : Project_Id) is\n-         Data : constant Project_Data :=\n-                  In_Tree.Projects.Table (Project);\n+      procedure Recurse (Prj : Project_Id) is\n+         Data : Project_Data renames In_Tree.Projects.Table (Prj);\n          List : Project_List := Data.Imported_Projects;\n-\n       begin\n-         --  If the list of visited project is empty, then\n-         --  for sure we never visited this project.\n+         if not Get (Seen, Prj) then\n+            Set (Seen, Prj, True);\n \n-         if Seen = Empty_Project_List then\n-            Project_List_Table.Increment_Last (In_Tree.Project_Lists);\n-            Seen := Project_List_Table.Last (In_Tree.Project_Lists);\n-            In_Tree.Project_Lists.Table (Seen) :=\n-              (Project => Project, Next => Empty_Project_List);\n+            Action (Prj);\n \n-         else\n-            --  Check if the project is in the list\n+            --  If we are extending a project, visit it\n \n-            declare\n-               Current : Project_List := Seen;\n+            if Data.Extends /= No_Project then\n+               Recurse (Data.Extends);\n+            end if;\n \n-            begin\n-               loop\n-                  --  If it is, then there is nothing else to do\n+            --  And visit all imported projects\n \n-                  if In_Tree.Project_Lists.Table\n-                                           (Current).Project = Project\n-                  then\n-                     return;\n-                  end if;\n+            while List /= Empty_Project_List loop\n+               Recurse (In_Tree.Project_Lists.Table (List).Project);\n+               List := In_Tree.Project_Lists.Table (List).Next;\n+            end loop;\n+         end if;\n+      end Recurse;\n \n-                  exit when\n-                    In_Tree.Project_Lists.Table (Current).Next =\n-                      Empty_Project_List;\n-                  Current :=\n-                    In_Tree.Project_Lists.Table (Current).Next;\n-               end loop;\n+   begin\n+      Recurse (Project);\n+      Reset (Seen);\n+   end For_All_Imported_Projects;\n \n-               --  This project has never been visited, add it\n-               --  to the list.\n+   -------------------------\n+   -- For_All_Object_Dirs --\n+   -------------------------\n \n-               Project_List_Table.Increment_Last\n-                 (In_Tree.Project_Lists);\n-               In_Tree.Project_Lists.Table (Current).Next :=\n-                 Project_List_Table.Last (In_Tree.Project_Lists);\n-               In_Tree.Project_Lists.Table\n-                 (Project_List_Table.Last\n-                    (In_Tree.Project_Lists)) :=\n-                 (Project => Project, Next => Empty_Project_List);\n-            end;\n-         end if;\n+   procedure For_All_Object_Dirs\n+     (Project : Project_Id;\n+      In_Tree : Project_Tree_Ref)\n+   is\n+      procedure For_Project (Prj : Project_Id);\n+      --  Get all object directories of Prj\n \n-         --  If there is an object directory, call Action with its name\n+      -----------------\n+      -- For_Project --\n+      -----------------\n \n+      procedure For_Project (Prj : Project_Id) is\n+         Data : Project_Data renames In_Tree.Projects.Table (Prj);\n+      begin\n          if Data.Object_Directory /= No_Path_Information then\n             Get_Name_String (Data.Object_Directory.Display_Name);\n             Action (Name_Buffer (1 .. Name_Len));\n          end if;\n+      end For_Project;\n \n-         --  If we are extending a project, visit it\n-\n-         if Data.Extends /= No_Project then\n-            Add (Data.Extends);\n-         end if;\n-\n-         --  And visit all imported projects\n-\n-         while List /= Empty_Project_List loop\n-            Add (In_Tree.Project_Lists.Table (List).Project);\n-            List := In_Tree.Project_Lists.Table (List).Next;\n-         end loop;\n-      end Add;\n-\n-   --  Start of processing for For_All_Object_Dirs\n-\n+      procedure Get_Object_Dirs is new For_All_Imported_Projects (For_Project);\n    begin\n-      --  Visit this project, and its imported projects, recursively\n-\n-      Add (Project);\n+      Get_Object_Dirs (Project, In_Tree);\n    end For_All_Object_Dirs;\n \n    -------------------------\n@@ -1635,110 +1546,33 @@ package body Prj.Env is\n      (Project : Project_Id;\n       In_Tree : Project_Tree_Ref)\n    is\n-      Seen : Project_List := Empty_Project_List;\n+      procedure For_Project (Prj : Project_Id);\n+      --  Get all object directories of Prj\n \n-      procedure Add (Project : Project_Id);\n-      --  Process a project. Remember the processes visited to avoid processing\n-      --  a project twice. Recursively process an eventual extended project,\n-      --  and all imported projects.\n-\n-      ---------\n-      -- Add --\n-      ---------\n-\n-      procedure Add (Project : Project_Id) is\n-         Data : constant Project_Data :=\n-                  In_Tree.Projects.Table (Project);\n-         List : Project_List := Data.Imported_Projects;\n+      -----------------\n+      -- For_Project --\n+      -----------------\n \n+      procedure For_Project (Prj : Project_Id) is\n+         Data       : Project_Data renames In_Tree.Projects.Table (Prj);\n+         Current    : String_List_Id := Data.Source_Dirs;\n+         The_String : String_Element;\n       begin\n-         --  If the list of visited project is empty, then for sure we never\n-         --  visited this project.\n-\n-         if Seen = Empty_Project_List then\n-            Project_List_Table.Increment_Last\n-              (In_Tree.Project_Lists);\n-            Seen := Project_List_Table.Last\n-                                         (In_Tree.Project_Lists);\n-            In_Tree.Project_Lists.Table (Seen) :=\n-              (Project => Project, Next => Empty_Project_List);\n-\n-         else\n-            --  Check if the project is in the list\n-\n-            declare\n-               Current : Project_List := Seen;\n-\n-            begin\n-               loop\n-                  --  If it is, then there is nothing else to do\n-\n-                  if In_Tree.Project_Lists.Table\n-                                           (Current).Project = Project\n-                  then\n-                     return;\n-                  end if;\n-\n-                  exit when\n-                    In_Tree.Project_Lists.Table (Current).Next =\n-                      Empty_Project_List;\n-                  Current :=\n-                    In_Tree.Project_Lists.Table (Current).Next;\n-               end loop;\n-\n-               --  This project has never been visited, add it to the list\n-\n-               Project_List_Table.Increment_Last\n-                 (In_Tree.Project_Lists);\n-               In_Tree.Project_Lists.Table (Current).Next :=\n-                 Project_List_Table.Last (In_Tree.Project_Lists);\n-               In_Tree.Project_Lists.Table\n-                 (Project_List_Table.Last\n-                    (In_Tree.Project_Lists)) :=\n-                 (Project => Project, Next => Empty_Project_List);\n-            end;\n-         end if;\n-\n-         declare\n-            Current    : String_List_Id := Data.Source_Dirs;\n-            The_String : String_Element;\n-\n-         begin\n-            --  If there are Ada sources, call action with the name of every\n-            --  source directory.\n-\n-            if\n-              In_Tree.Projects.Table (Project).Ada_Sources /= Nil_String\n-            then\n-               while Current /= Nil_String loop\n-                  The_String :=\n-                    In_Tree.String_Elements.Table (Current);\n-                  Action (Get_Name_String (The_String.Display_Value));\n-                  Current := The_String.Next;\n-               end loop;\n-            end if;\n-         end;\n-\n-         --  If we are extending a project, visit it\n-\n-         if Data.Extends /= No_Project then\n-            Add (Data.Extends);\n+         --  If there are Ada sources, call action with the name of every\n+         --  source directory.\n+\n+         if In_Tree.Projects.Table (Project).Ada_Sources_Present then\n+            while Current /= Nil_String loop\n+               The_String := In_Tree.String_Elements.Table (Current);\n+               Action (Get_Name_String (The_String.Display_Value));\n+               Current := The_String.Next;\n+            end loop;\n          end if;\n+      end For_Project;\n \n-         --  And visit all imported projects\n-\n-         while List /= Empty_Project_List loop\n-            Add (In_Tree.Project_Lists.Table (List).Project);\n-            List := In_Tree.Project_Lists.Table (List).Next;\n-         end loop;\n-      end Add;\n-\n-   --  Start of processing for For_All_Source_Dirs\n-\n+      procedure Get_Source_Dirs is new For_All_Imported_Projects (For_Project);\n    begin\n-      --  Visit this project, and its imported projects recursively\n-\n-      Add (Project);\n+      Get_Source_Dirs (Project, In_Tree);\n    end For_All_Source_Dirs;\n \n    -------------------\n@@ -1839,139 +1673,6 @@ package body Prj.Env is\n       Current_Object_Path_File := No_Path;\n    end Initialize;\n \n-   ------------------------------------\n-   -- Path_Name_Of_Library_Unit_Body --\n-   ------------------------------------\n-\n-   --  Could use some comments in the body here ???\n-\n-   function Path_Name_Of_Library_Unit_Body\n-     (Name    : String;\n-      Project : Project_Id;\n-      In_Tree : Project_Tree_Ref) return String\n-   is\n-      Data          : constant Project_Data :=\n-                        In_Tree.Projects.Table (Project);\n-      Original_Name : String := Name;\n-\n-      Extended_Spec_Name : String :=\n-                             Name &\n-                             Spec_Suffix_Of (In_Tree, \"ada\", Data.Naming);\n-      Extended_Body_Name : String :=\n-                             Name &\n-                             Body_Suffix_Of (In_Tree, \"ada\", Data.Naming);\n-\n-      First   : Unit_Index := Unit_Table.First;\n-      Current : Unit_Index;\n-      Unit    : Unit_Data;\n-\n-   begin\n-      Canonical_Case_File_Name (Original_Name);\n-      Canonical_Case_File_Name (Extended_Spec_Name);\n-      Canonical_Case_File_Name (Extended_Body_Name);\n-\n-      if Current_Verbosity = High then\n-         Write_Str  (\"Looking for path name of \"\"\");\n-         Write_Str  (Name);\n-         Write_Char ('\"');\n-         Write_Eol;\n-         Write_Str  (\"   Extended Spec Name = \"\"\");\n-         Write_Str  (Extended_Spec_Name);\n-         Write_Char ('\"');\n-         Write_Eol;\n-         Write_Str  (\"   Extended Body Name = \"\"\");\n-         Write_Str  (Extended_Body_Name);\n-         Write_Char ('\"');\n-         Write_Eol;\n-      end if;\n-\n-      while First <= Unit_Table.Last (In_Tree.Units)\n-        and then In_Tree.Units.Table\n-                   (First).File_Names (Body_Part).Project /= Project\n-      loop\n-         First := First + 1;\n-      end loop;\n-\n-      Current := First;\n-      while Current <= Unit_Table.Last (In_Tree.Units) loop\n-         Unit := In_Tree.Units.Table (Current);\n-\n-         if Unit.File_Names (Body_Part).Project = Project\n-           and then Unit.File_Names (Body_Part).Name /= No_File\n-         then\n-            declare\n-               Current_Name : constant String :=\n-                 Namet.Get_Name_String (Unit.File_Names (Body_Part).Name);\n-            begin\n-               if Current_Verbosity = High then\n-                  Write_Str  (\"   Comparing with \"\"\");\n-                  Write_Str  (Current_Name);\n-                  Write_Char ('\"');\n-                  Write_Eol;\n-               end if;\n-\n-               if Current_Name = Original_Name then\n-                  if Current_Verbosity = High then\n-                     Write_Line (\"   OK\");\n-                  end if;\n-\n-                  return Body_Path_Name_Of (Current, In_Tree);\n-\n-               elsif Current_Name = Extended_Body_Name then\n-                  if Current_Verbosity = High then\n-                     Write_Line (\"   OK\");\n-                  end if;\n-\n-                  return Body_Path_Name_Of (Current, In_Tree);\n-\n-               else\n-                  if Current_Verbosity = High then\n-                     Write_Line (\"   not good\");\n-                  end if;\n-               end if;\n-            end;\n-\n-         elsif Unit.File_Names (Specification).Name /= No_File then\n-            declare\n-               Current_Name : constant String :=\n-                                Namet.Get_Name_String\n-                                  (Unit.File_Names (Specification).Name);\n-\n-            begin\n-               if Current_Verbosity = High then\n-                  Write_Str  (\"   Comparing with \"\"\");\n-                  Write_Str  (Current_Name);\n-                  Write_Char ('\"');\n-                  Write_Eol;\n-               end if;\n-\n-               if Current_Name = Original_Name then\n-                  if Current_Verbosity = High then\n-                     Write_Line (\"   OK\");\n-                  end if;\n-\n-                  return Spec_Path_Name_Of (Current, In_Tree);\n-\n-               elsif Current_Name = Extended_Spec_Name then\n-                  if Current_Verbosity = High then\n-                     Write_Line (\"   OK\");\n-                  end if;\n-\n-                  return Spec_Path_Name_Of (Current, In_Tree);\n-\n-               else\n-                  if Current_Verbosity = High then\n-                     Write_Line (\"   not good\");\n-                  end if;\n-               end if;\n-            end;\n-         end if;\n-         Current := Current + 1;\n-      end loop;\n-\n-      return \"\";\n-   end Path_Name_Of_Library_Unit_Body;\n-\n    -------------------\n    -- Print_Sources --\n    -------------------\n@@ -2455,54 +2156,6 @@ package body Prj.Env is\n       end if;\n    end Set_Path_File_Var;\n \n-   -----------------------\n-   -- Spec_Path_Name_Of --\n-   -----------------------\n-\n-   function Spec_Path_Name_Of\n-     (Unit : Unit_Index; In_Tree : Project_Tree_Ref) return String\n-   is\n-      Data : Unit_Data := In_Tree.Units.Table (Unit);\n-\n-   begin\n-      if Data.File_Names (Specification).Path.Name = No_Path then\n-         declare\n-            Current_Source : String_List_Id :=\n-              In_Tree.Projects.Table\n-                (Data.File_Names (Specification).Project).Ada_Sources;\n-            Path : GNAT.OS_Lib.String_Access;\n-\n-         begin\n-            Data.File_Names (Specification).Path.Name :=\n-              Path_Name_Type (Data.File_Names (Specification).Name);\n-\n-            while Current_Source /= Nil_String loop\n-               Path := Locate_Regular_File\n-                 (Namet.Get_Name_String\n-                  (Data.File_Names (Specification).Name),\n-                  Namet.Get_Name_String\n-                    (In_Tree.String_Elements.Table\n-                       (Current_Source).Value));\n-\n-               if Path /= null then\n-                  Name_Len := Path'Length;\n-                  Name_Buffer (1 .. Name_Len) := Path.all;\n-                  Data.File_Names (Specification).Path.Name := Name_Enter;\n-                  exit;\n-               else\n-                  Current_Source :=\n-                    In_Tree.String_Elements.Table\n-                      (Current_Source).Next;\n-               end if;\n-            end loop;\n-\n-            In_Tree.Units.Table (Unit) := Data;\n-         end;\n-      end if;\n-\n-      return Namet.Get_Name_String (Data.File_Names (Specification).Path.Name);\n-   end Spec_Path_Name_Of;\n-\n    ---------------------------\n    -- Ultimate_Extension_Of --\n    ---------------------------"}, {"sha": "989f4e76e3c5d4b2092ca9d41fc67e0fd5556d2e", "filename": "gcc/ada/prj-env.ads", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3520ca005a1242308fa8d4c4e684f16ef6a0905/gcc%2Fada%2Fprj-env.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3520ca005a1242308fa8d4c4e684f16ef6a0905/gcc%2Fada%2Fprj-env.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-env.ads?ref=b3520ca005a1242308fa8d4c4e684f16ef6a0905", "patch": "@@ -118,12 +118,6 @@ package Prj.Env is\n    procedure Delete_All_Path_Files (In_Tree : Project_Tree_Ref);\n    --  Delete all temporary path files that have been created by Set_Ada_Paths\n \n-   function Path_Name_Of_Library_Unit_Body\n-     (Name    : String;\n-      Project : Project_Id;\n-      In_Tree : Project_Tree_Ref) return String;\n-   --  Returns the path of a library unit\n-\n    function File_Name_Of_Library_Unit_Body\n      (Name              : String;\n       Project           : Project_Id;\n@@ -167,6 +161,8 @@ package Prj.Env is\n       In_Tree : Project_Tree_Ref);\n    --  Iterate through all the source directories of a project, including those\n    --  of imported or modified projects.\n+   --  Only returns those directories that potentially contain Ada sources (ie\n+   --  ignore projects that have no Ada sources\n \n    generic\n       with procedure Action (Path : String);\n@@ -176,4 +172,11 @@ package Prj.Env is\n    --  Iterate through all the object directories of a project, including\n    --  those of imported or modified projects.\n \n+   generic\n+      with procedure Action (Project : Project_Id);\n+   procedure For_All_Imported_Projects\n+     (Project : Project_Id;\n+      In_Tree : Project_Tree_Ref);\n+   --  Execute Action for Project and all imported or extended projects\n+\n end Prj.Env;"}, {"sha": "f3b8958119a8efebea5cf9638fab3bda6f56efd1", "filename": "gcc/ada/s-osinte-darwin.adb", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3520ca005a1242308fa8d4c4e684f16ef6a0905/gcc%2Fada%2Fs-osinte-darwin.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3520ca005a1242308fa8d4c4e684f16ef6a0905/gcc%2Fada%2Fs-osinte-darwin.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-osinte-darwin.adb?ref=b3520ca005a1242308fa8d4c4e684f16ef6a0905", "patch": "@@ -149,6 +149,18 @@ package body System.OS_Interface is\n       return 0;\n    end sched_yield;\n \n+   --------------\n+   -- lwp_self --\n+   --------------\n+\n+   function lwp_self return Address is\n+      function pthread_mach_thread_np (thread : pthread_t) return Address;\n+      pragma Import (C, pthread_mach_thread_np, \"pthread_mach_thread_np\");\n+\n+   begin\n+      return pthread_mach_thread_np (pthread_self);\n+   end lwp_self;\n+\n    ------------------\n    -- pthread_init --\n    ------------------"}, {"sha": "b62b2c108e6d977827bdc3e7967ec6a200b8dc34", "filename": "gcc/ada/s-osinte-darwin.ads", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3520ca005a1242308fa8d4c4e684f16ef6a0905/gcc%2Fada%2Fs-osinte-darwin.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3520ca005a1242308fa8d4c4e684f16ef6a0905/gcc%2Fada%2Fs-osinte-darwin.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-osinte-darwin.ads?ref=b3520ca005a1242308fa8d4c4e684f16ef6a0905", "patch": "@@ -236,10 +236,8 @@ package System.OS_Interface is\n    ---------\n \n    function lwp_self return System.Address;\n-   pragma Import (C, lwp_self, \"pthread_self\");\n-   --  lwp_self does not exist on this thread library, revert to pthread_self\n-   --  which is the closest approximation (with getpid). This function is\n-   --  needed to share 7staprop.adb across POSIX-like targets.\n+   --  Return the mach thread bound to the current thread.  The value is not\n+   --  used by the run-time library but made available to debuggers.\n \n    -------------\n    -- Threads --"}]}