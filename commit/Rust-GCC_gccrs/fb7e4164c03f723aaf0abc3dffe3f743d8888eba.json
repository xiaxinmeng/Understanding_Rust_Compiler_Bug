{"sha": "fb7e4164c03f723aaf0abc3dffe3f743d8888eba", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmI3ZTQxNjRjMDNmNzIzYWFmMGFiYzNkZmZlM2Y3NDNkODg4OGViYQ==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@bigpond.net.au", "date": "2004-02-07T03:06:46Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2004-02-07T03:06:46Z"}, "message": "t-linux64 (LIB2FUNCS_EXTRA): Add darwin-ldouble.c.\n\n\t* config/rs6000/t-linux64 (LIB2FUNCS_EXTRA): Add darwin-ldouble.c.\n\t(SHLIB_MAPFILES): Add libgcc-ppc64.ver.\n\t(SHLIB_MKMAP_OPTS): Delete.\n\t(TARGET_LIBGCC2_CFLAGS): Add -specs.\n\t(bispecs): Add rule.\n\t* config/rs6000/libgcc-ppc64.ver: New file.\n\t* config/rs6000/ppc64-fp.c (__fixtfdi, __floatditf): New functions.\n\t(__floatdidf, __floatdisf): Optimize multiply.\n\t(__fixunstfdi): New function.\n\t* config/rs6000/rs6000.c (rs6000_complex_function_value): Allow for\n\treal and imag parts larger than one register.\n\t(function_arg): Correct type of reg used when fp arg split partially\n\tto stack.\n\t* config/rs6000/darwin-ldouble.c: Protect with #if !_SOFT_FLOAT\n\tand __MACH__ or __powerpc64__.\n\nFrom-SVN: r77440", "tree": {"sha": "528dfa87534bd4e0e301d8ec7b35a3eabc6f7670", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/528dfa87534bd4e0e301d8ec7b35a3eabc6f7670"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fb7e4164c03f723aaf0abc3dffe3f743d8888eba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb7e4164c03f723aaf0abc3dffe3f743d8888eba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fb7e4164c03f723aaf0abc3dffe3f743d8888eba", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb7e4164c03f723aaf0abc3dffe3f743d8888eba/comments", "author": null, "committer": null, "parents": [{"sha": "254878eaddab86eae9ec232baedfdc4103cf7ef9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/254878eaddab86eae9ec232baedfdc4103cf7ef9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/254878eaddab86eae9ec232baedfdc4103cf7ef9"}], "stats": {"total": 114, "additions": 100, "deletions": 14}, "files": [{"sha": "d4d04ff07c738e6334e7db48f1b593948d9b095e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb7e4164c03f723aaf0abc3dffe3f743d8888eba/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb7e4164c03f723aaf0abc3dffe3f743d8888eba/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fb7e4164c03f723aaf0abc3dffe3f743d8888eba", "patch": "@@ -1,3 +1,21 @@\n+2004-02-07  Alan Modra  <amodra@bigpond.net.au>\n+\n+\t* config/rs6000/t-linux64 (LIB2FUNCS_EXTRA): Add darwin-ldouble.c.\n+\t(SHLIB_MAPFILES): Add libgcc-ppc64.ver.\n+\t(SHLIB_MKMAP_OPTS): Delete.\n+\t(TARGET_LIBGCC2_CFLAGS): Add -specs.\n+\t(bispecs): Add rule.\n+\t* config/rs6000/libgcc-ppc64.ver: New file.\n+\t* config/rs6000/ppc64-fp.c (__fixtfdi, __floatditf): New functions.\n+\t(__floatdidf, __floatdisf): Optimize multiply.\n+\t(__fixunstfdi): New function.\n+\t* config/rs6000/rs6000.c (rs6000_complex_function_value): Allow for\n+\treal and imag parts larger than one register.\n+\t(function_arg): Correct type of reg used when fp arg split partially\n+\tto stack.\n+\t* config/rs6000/darwin-ldouble.c: Protect with #if !_SOFT_FLOAT\n+\tand __MACH__ or __powerpc64__.\n+\n 2004-02-06  Roger Sayle  <roger@eyesopen.com>\n \t    Ulrich Weigand  <uweigand@de.ibm.com>\n "}, {"sha": "e3dc5627445864901ab036481f6d16715b46336d", "filename": "gcc/config/rs6000/darwin-ldouble.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb7e4164c03f723aaf0abc3dffe3f743d8888eba/gcc%2Fconfig%2Frs6000%2Fdarwin-ldouble.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb7e4164c03f723aaf0abc3dffe3f743d8888eba/gcc%2Fconfig%2Frs6000%2Fdarwin-ldouble.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fdarwin-ldouble.c?ref=fb7e4164c03f723aaf0abc3dffe3f743d8888eba", "patch": "@@ -48,6 +48,8 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n    This code currently assumes big-endian.  */\n \n+#if !_SOFT_FLOAT && (defined (__MACH__) || defined (__powerpc64__))\n+\n #define fabs(x) __builtin_fabs(x)\n \n #define unlikely(x) __builtin_expect ((x), 0)\n@@ -199,3 +201,5 @@ _xlqdiv (double a, double b, double c, double d)\n   z.dval[1] = (t - u) + tau;\n   return z.ldval;\n }\n+\n+#endif"}, {"sha": "116d5e73fa079583d0dfad1f474fb1a0947346e7", "filename": "gcc/config/rs6000/libgcc-ppc64.ver", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb7e4164c03f723aaf0abc3dffe3f743d8888eba/gcc%2Fconfig%2Frs6000%2Flibgcc-ppc64.ver", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb7e4164c03f723aaf0abc3dffe3f743d8888eba/gcc%2Fconfig%2Frs6000%2Flibgcc-ppc64.ver", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Flibgcc-ppc64.ver?ref=fb7e4164c03f723aaf0abc3dffe3f743d8888eba", "patch": "@@ -0,0 +1,7 @@\n+GCC_3.4 {\n+  # long double support\n+  _xlqadd\n+  _xlqsub\n+  _xlqmul\n+  _xlqdiv\n+}"}, {"sha": "c736d9ad7c86867522d76e6cdb478d61aacc85c3", "filename": "gcc/config/rs6000/ppc64-fp.c", "status": "modified", "additions": 49, "deletions": 4, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb7e4164c03f723aaf0abc3dffe3f743d8888eba/gcc%2Fconfig%2Frs6000%2Fppc64-fp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb7e4164c03f723aaf0abc3dffe3f743d8888eba/gcc%2Fconfig%2Frs6000%2Fppc64-fp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fppc64-fp.c?ref=fb7e4164c03f723aaf0abc3dffe3f743d8888eba", "patch": "@@ -33,16 +33,27 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #if defined(__powerpc64__)\n #include \"config/fp-bit.h\"\n \n+extern DItype __fixtfdi (TFtype);\n extern DItype __fixdfdi (DFtype);\n extern DItype __fixsfdi (SFtype);\n extern USItype __fixunsdfsi (DFtype);\n extern USItype __fixunssfsi (SFtype);\n+extern TFtype __floatditf (DItype);\n extern DFtype __floatdidf (DItype);\n extern SFtype __floatdisf (DItype);\n+extern DItype __fixunstfdi (TFtype);\n \n static DItype local_fixunssfdi (SFtype);\n static DItype local_fixunsdfdi (DFtype);\n \n+DItype\n+__fixtfdi (TFtype a)\n+{\n+  if (a < 0)\n+    return - __fixunstfdi (-a);\n+  return __fixunstfdi (a);\n+}\n+\n DItype\n __fixdfdi (DFtype a)\n {\n@@ -77,14 +88,25 @@ __fixunssfsi (SFtype a)\n   return (SItype) a;\n }\n \n+TFtype\n+__floatditf (DItype u)\n+{\n+  DFtype dh, dl;\n+\n+  dh = (SItype) (u >> (sizeof (SItype) * 8));\n+  dh *= 2.0 * (((UDItype) 1) << ((sizeof (SItype) * 8) - 1));\n+  dl = (USItype) (u & ((((UDItype) 1) << (sizeof (SItype) * 8)) - 1));\n+\n+  return (TFtype) dh + (TFtype) dl;\n+}\n+\n DFtype\n __floatdidf (DItype u)\n {\n   DFtype d;\n \n   d = (SItype) (u >> (sizeof (SItype) * 8));\n-  d *= (((UDItype) 1) << ((sizeof (SItype) * 8) / 2));\n-  d *= (((UDItype) 1) << ((sizeof (SItype) * 8) / 2));\n+  d *= 2.0 * (((UDItype) 1) << ((sizeof (SItype) * 8) - 1));\n   d += (USItype) (u & ((((UDItype) 1) << (sizeof (SItype) * 8)) - 1));\n \n   return d;\n@@ -109,13 +131,36 @@ __floatdisf (DItype u)\n         }\n     }\n   f = (SItype) (u >> (sizeof (SItype) * 8));\n-  f *= (((UDItype) 1) << ((sizeof (SItype) * 8) / 2));\n-  f *= (((UDItype) 1) << ((sizeof (SItype) * 8) / 2));\n+  f *= 2.0 * (((UDItype) 1) << ((sizeof (SItype) * 8) - 1));\n   f += (USItype) (u & ((((UDItype) 1) << (sizeof (SItype) * 8)) - 1));\n \n   return (SFtype) f;\n }\n \n+DItype\n+__fixunstfdi (TFtype a)\n+{\n+  if (a < 0)\n+    return 0;\n+\n+  /* Compute high word of result, as a flonum.  */\n+  const TFtype b = (a / (((UDItype) 1) << (sizeof (SItype) * 8)));\n+  /* Convert that to fixed (but not to DItype!),\n+     and shift it into the high word.  */\n+  UDItype v = (USItype) b;\n+  v <<= (sizeof (SItype) * 8);\n+  /* Remove high part from the TFtype, leaving the low part as flonum.  */\n+  a -= (TFtype) v;\n+  /* Convert that to fixed (but not to DItype!) and add it in.\n+     Sometimes A comes out negative.  This is significant, since\n+     A has more bits than a long int does.  */\n+  if (a < 0)\n+    v -= (USItype) (-a);\n+  else\n+    v += (USItype) a;\n+  return v;\n+}\n+\n /* This version is needed to prevent recursion; fixunsdfdi in libgcc\n    calls fixdfdi, which in turn calls calls fixunsdfdi.  */\n "}, {"sha": "9cacc88f70011a5cf21329b5fe168d65422cc07c", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb7e4164c03f723aaf0abc3dffe3f743d8888eba/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb7e4164c03f723aaf0abc3dffe3f743d8888eba/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=fb7e4164c03f723aaf0abc3dffe3f743d8888eba", "patch": "@@ -4417,7 +4417,7 @@ function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \t\t\t\t    /* If this is partially on the stack, then\n \t\t\t\t       we only include the portion actually\n \t\t\t\t       in registers here.  */\n-\t\t\t\t    ? gen_rtx_REG (SImode,\n+\t\t\t\t    ? gen_rtx_REG (Pmode,\n \t\t\t\t\t       GP_ARG_MIN_REG + align_words)\n \t\t\t\t    : gen_rtx_REG (mode,\n \t\t\t\t\t       GP_ARG_MIN_REG + align_words))),\n@@ -15726,6 +15726,7 @@ rs6000_complex_function_value (enum machine_mode mode)\n   unsigned int regno;\n   rtx r1, r2;\n   enum machine_mode inner = GET_MODE_INNER (mode);\n+  unsigned int inner_bytes = GET_MODE_SIZE (inner);\n \n   if (FLOAT_MODE_P (mode))\n     regno = FP_ARG_RETURN;\n@@ -15734,15 +15735,17 @@ rs6000_complex_function_value (enum machine_mode mode)\n       regno = GP_ARG_RETURN;\n \n       /* 32-bit is OK since it'll go in r3/r4.  */\n-      if (TARGET_32BIT\n-\t  && GET_MODE_BITSIZE (inner) >= 32)\n+      if (TARGET_32BIT && inner_bytes >= 4)\n \treturn gen_rtx_REG (mode, regno);\n     }\n \n+  if (inner_bytes >= 8)\n+    return gen_rtx_REG (mode, regno);\n+\n   r1 = gen_rtx_EXPR_LIST (inner, gen_rtx_REG (inner, regno),\n \t\t\t  const0_rtx);\n   r2 = gen_rtx_EXPR_LIST (inner, gen_rtx_REG (inner, regno + 1),\n-\t\t\t  GEN_INT (GET_MODE_UNIT_SIZE (inner)));\n+\t\t\t  GEN_INT (inner_bytes));\n   return gen_rtx_PARALLEL (mode, gen_rtvec (2, r1, r2));\n }\n "}, {"sha": "0e86f5f26ff0dbddc412eb352da2b7c466e3c769", "filename": "gcc/config/rs6000/t-linux64", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb7e4164c03f723aaf0abc3dffe3f743d8888eba/gcc%2Fconfig%2Frs6000%2Ft-linux64", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb7e4164c03f723aaf0abc3dffe3f743d8888eba/gcc%2Fconfig%2Frs6000%2Ft-linux64", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Ft-linux64?ref=fb7e4164c03f723aaf0abc3dffe3f743d8888eba", "patch": "@@ -1,8 +1,12 @@\n-# These functions are needed for soft-float on powerpc64-linux.\n-LIB2FUNCS_EXTRA = tramp.S $(srcdir)/config/rs6000/ppc64-fp.c\n \n-# Modify the shared lib version file\n-SHLIB_MKMAP_OPTS = -v dotsyms=1\n+#rs6000/t-linux64\n+\n+LIB2FUNCS_EXTRA = tramp.S $(srcdir)/config/rs6000/ppc64-fp.c \\\n+\t$(srcdir)/config/rs6000/darwin-ldouble.c\n+\n+TARGET_LIBGCC2_CFLAGS = -mno-minimal-toc -fPIC -specs=bispecs\n+\n+SHLIB_MAPFILES += $(srcdir)/config/rs6000/libgcc-ppc64.ver\n \n MULTILIB_OPTIONS        = m64/m32 msoft-float\n MULTILIB_DIRNAMES       = 64 32 nof\n@@ -12,8 +16,6 @@ MULTILIB_EXCLUSIONS     = m64/!m32/msoft-float\n MULTILIB_OSDIRNAMES\t= ../lib64 ../lib nof\n MULTILIB_MATCHES        = $(MULTILIB_MATCHES_FLOAT)\n \n-TARGET_LIBGCC2_CFLAGS = -mno-minimal-toc -fPIC\n-\n # We want fine grained libraries, so use the new code to build the\n # floating point emulation libraries.\n # fp-bit is only to be used by 32-bit multilibs\n@@ -30,3 +32,10 @@ fp-bit32.c: $(srcdir)/config/fp-bit.c\n \t  echo '#define FLOAT'; \\\n \t  cat $(srcdir)/config/fp-bit.c; \\\n \t  echo '#endif' ) > fp-bit32.c\n+\n+# Hack to use -mlong-double-128 just for compiling 64 bit libgcc\n+mklibgcc: bispecs\n+\n+bispecs: specs\n+\tsed -e '/cc1_options/{ n; s/$$/ %{!m32:-mlong-double-128}/; }' < specs > $@\n+"}]}