{"sha": "0bca51f080dfff5e943b1f1775d874a73bbc441a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGJjYTUxZjA4MGRmZmY1ZTk0M2IxZjE3NzVkODc0YTczYmJjNDQxYQ==", "commit": {"author": {"name": "Diego Novillo", "email": "dnovillo@redhat.com", "date": "2005-04-09T01:37:54Z"}, "committer": {"name": "Diego Novillo", "email": "dnovillo@gcc.gnu.org", "date": "2005-04-09T01:37:54Z"}, "message": "backport: copy-prop, incremental SSA updating of FUD chains and newly exposed symbols.\n\n\n\tMerge from tree-cleanup-branch: VRP, store CCP, store\n\t    copy-prop, incremental SSA updating of FUD chains and\n\t    newly exposed symbols.\n\n\t* Makefile.in (tree-ssa-copy.o): Depend on tree-ssa-propagate.h.\n\t(OBJS-common): Add tree-vrp.o.\n\t(tree-vrp.o): New rule.\n\t* basic-block.h (nearest_common_dominator_for_set): Declare.\n\t* common.opt (ftree-store-ccp): New flag.\n\t(ftree-copy-prop): New flag.\n\t(ftree-vrp): New flag.\n\t(ftree-store-copy-prop): New flag.\n\t* dominance.c (nearest_common_dominator_for_set): New.\n\t* domwalk.c (walk_dominator_tree): Only traverse\n\tstatements in blocks marked in walk_data->interesting_blocks.\n\t* domwalk.h (struct dom_walk_data): Add field interesting_blocks.\n\t* fold-const.c (fold): Handle ASSERT_EXPR.\n\t* opts.c (decode_options): Set flag_tree_copy_prop at -O1.\n\tSet flag_tree_store_ccp, flag_tree_store_copy_prop and\n\tflag_tree_vrp at -O2.\n\t* timevar.def (TV_TREE_VRP): Define.\n\t(TV_TREE_COPY_PROP): Define.\n\t(TV_TREE_STORE_COPY_PROP): Define.\n\t(TV_TREE_SSA_INCREMENTAL): Define.\n\t(TV_TREE_STORE_CCP): Define.\n\t* tree-cfg.c (tree_can_merge_blocks_p): Remove reference\n\tto kill_redundant_phi_nodes from comment.\n\t(verify_expr): Handle ASSERT_EXPR.\n\t* tree-dfa.c (mark_new_vars_to_rename): Remove second\n\targument.  Update all users.\n\t(mark_call_clobbered_vars_to_rename): Remove.  Update all\n\tusers.\n\t* tree-flow-inline.h (unmodifiable_var_p): New.\n\t* tree-flow.h (enum value_range_type): Declare.\n\t(struct value_range_def): Declare.\n\t(value_range): Declare.\n\t(remove_all_phi_nodes_for): Remove.  Update all users.\n\t(find_phi_node_for): Declare.\n\t(add_type_alias): Declare.\n\t(count_uses_and_derefs): Declare.\n\t(kill_redundant_phi_nodes): Remove.\n\t(rewrite_into_ssa): Remove.\n\t(rewrite_def_def_chains): Remove.\n\t(update_ssa, register_new_name_mapping, create_new_def_for,\n\tneed_ssa_update_p, name_registered_for_update_p,\n\trelease_ssa_name_after_update_ssa, dump_repl_tbl,\n\tdebug_repl_tbl, dump_names_replaced_by,\n\tdebug_names_replaced_by, mark_sym_for_renaming,\n\tmark_set_for_renaming, get_current_def, set_current_def,\n\tget_value_range, dump_value_range, debug_value_range,\n\tdump_all_value_ranges, debug_all_value_ranges,\n\texpr_computes_nonzero, loop_depth_of_name,\n\tunmodifiable_var_p): Declare.\n\t* tree-gimple.c (is_gimple_formal_tmp_rhs): Handle\n\tASSERT_EXPR.\n\t* tree-into-ssa.c (block_defs_stack): Update comment.\n\t(old_ssa_names, new_ssa_names, old_virtual_ssa_names,\n\tsyms_to_rename, names_to_release, repl_tbl,\n\tneed_to_initialize_update_ssa_p, need_to_update_vops_p,\n\tneed_to_replace_names_p): New locals.\n\t(NAME_SETS_GROWTH_FACTOR): Define.\n\t(struct repl_map_d): Declare.\n\t(struct mark_def_sites_global_data): Add field\n\tinteresting_blocks.\n\t(enum rewrite_mode): Declare.\n\t(REGISTER_DEFS_IN_THIS_STMT): Define.\n\t(compute_global_livein): Use last_basic_block instead of\n\tn_basic_blocks.\n\t(set_def_block): Remove last argument.  Update all callers.\n\t(prepare_use_operand_for_rename): Remove.  Update all callers.\n\t(prepare_def_operand_for_rename): Remove.  Update all callers.\n\t(symbol_marked_for_renaming): New.\n\t(is_old_name): New.\n\t(is_new_name): New.\n\t(repl_map_hash): New.\n\t(repl_map_eq): New.\n\t(repl_map_free): New.\n\t(names_replaced_by): New.\n\t(add_to_repl_tbl): New.\n\t(add_new_name_mapping): New.\n\t(mark_def_sites): Assume that all the operands in the\n\tstatement are in normal form.\n\t(find_idf): Assert that the block in the stack is valid.\n\t(get_default_def_for): New.\n\t(insert_phi_nodes_for): Add new argument 'update_p'.\n\tAdd documentation.\n\tIf update_p is true, add a new mapping between the LHS of\n\teach new PHI and the name that it replaces.\n\t(insert_phi_nodes_1): Only call find_idf if needed.\n\t(get_reaching_def): Call get_default_def_for.\n\t(rewrite_operand): Remove.\n\t(rewrite_stmt): Do nothing if REGISTER_DEFS_IN_THIS_STMT\n\tand REWRITE_THIS_STMT are false.\n\tAssume that all the operands in the statement are in\n\tnormal form.\n\t(rewrite_add_phi_arguments): Don't use PHI_REWRITTEN.\n\t(rewrite_virtual_phi_arguments): Remove.\n\t(invalidate_name_tags): Remove.\n\t(register_new_update_single, register_new_update_set,\n\trewrite_update_init_block, replace_use,\n\trewrite_update_fini_block, rewrite_update_stmt,\n\trewrite_update_phi_arguments): New.\n\trewrite_blocks): Remove argument 'fix_virtual_phis'.\n\tAdd arguments 'entry', 'what' and 'blocks'.\n\tInitialize the dominator walker according to 'what' and\n\t'blocks'.\n\tStart the dominator walk at 'entry'.\n\t(mark_def_site_blocks): Add argument 'interesting_blocks'.\n\tUse it to configure the dominator walker.\n\t(rewrite_into_ssa): Remove argument 'all'.\n\tMake internal.\n\t(rewrite_all_into_ssa): Remove.\n\t(rewrite_def_def_chains): Remove.\n\t(mark_def_interesting, mark_use_interesting,\n\tprepare_phi_args_for_update, prepare_block_for_update,\n\tprepare_def_site_for, prepare_def_sites,\n\tdump_names_replaced_by, debug_names_replaced_by,\n\tdump_repl_tbl, debug_repl_tbl, init_update_ssa,\n\tdelete_update_ssa, create_new_def_for,\n\tregister_new_name_mapping, mark_sym_for_renaming,\n\tmark_set_for_renaming, need_ssa_update_p,\n\tname_registered_for_update_p, ssa_names_to_replace,\n\trelease_ssa_name_after_update_ssa,\n\tinsert_updated_phi_nodes_for, update_ssa): New.\n\t* tree-loop-linear.c (linear_transform_loops): Call\n\tupdate_ssa instead of rewrite_into_ssa.\n\t* tree-optimize.c (vars_to_rename): Remove.\n\tUpdate all users.\n\t(init_tree_optimization_passes): Replace\n\tpass_redundant_phi with pass_copy_prop.\n\tAdd pass_vrp.\n\tReplace pass_ccp with pass_store_ccp.\n\tAdd pass_store_copy_prop after pass_store_ccp.\n\t(execute_todo): If the TODO_ flags don't include updating\n\tthe SSA form, assert that it does not need to be updated.\n\tCall update_ssa instead of rewrite_into_ssa and\n\trewrite_def_def_chains.\n\tIf TODO_verify_loops is set, call verify_loop_closed_ssa.\n\t(tree_rest_of_compilation):\n\t* tree-pass.h (TODO_dump_func, TODO_ggc_collect,\n\tTODO_verify_ssa, TODO_verify_flow, TODO_verify_stmts,\n\tTODO_cleanup_cfg): Renumber.\n\t(TODO_verify_loops, TODO_update_ssa,\n\tTODO_update_ssa_no_phi, TODO_update_ssa_full_phi,\n\tTODO_update_ssa_only_virtuals): Define.\n\t(pass_copy_prop, pass_store_ccp, pass_store_copy_prop, pass_vrp):\n\tDeclare.\n\t* tree-phinodes.c (make_phi_node): Update documentation.\n\t(remove_all_phi_nodes_for): Remove.\n\t(find_phi_node_for): New.\n\t* tree-pretty-print.c (dump_generic_node): Handle ASSERT_EXPR.\n\t* tree-scalar-evolution.c (follow_ssa_edge_in_rhs): Likewise.\n\t(interpret_rhs_modify_expr): Likewise.\n\t* tree-sra.c (decide_instantiations): Mark all symbols in\n\tSRA_CANDIDATES for renaming.\n\t(mark_all_v_defs_1): Rename from mark_all_v_defs.\n\t(mark_all_v_defs): New function.  Update all users to call it\n\twith the whole list of scalarized statements, not just the\n\tfirst one.\n\t* tree-ssa-alias.c (count_ptr_derefs): Make extern.\n\t(compute_flow_insensitive_aliasing): If the tag is\n\tunmodifiable and the variable isn't or vice-versa, don't\n\tmake them alias of each other.\n\t(setup_pointers_and_addressables): If the type tag for\n\tVAR is about to change, mark the old one for renaming.\n\t(add_type_alias): New.\n\t* tree-ssa-ccp.c: Document SSA-CCP and STORE-CCP.\n\t(ccp_lattice_t): Rename from latticevalue.\n\t(value): Remove.  Update all users.\n\t(const_val): New local variable.\n\t(do_store_ccp): New local variable.\n\t(dump_lattice_value): Handle UNINITIALIZED.\n\t(debug_lattice_value): New.\n\t(get_default_value): Re-write.\n\t(set_lattice_value): Re-write.\n\t(def_to_varying): Remove.  Update all users.\n\t(likely_value): Return VARYING for statements that make\n\tstores when STORE_CCP is false.\n\tReturn VARYING for any statement other than MODIFY_EXPR,\n\tCOND_EXPR and SWITCH_EXPR.\n\t(ccp_initialize): Re-write.\n\t(replace_uses_in, replace_vuse_in, substitute_and_fold):\n\tMove to tree-ssa-propagate.c.\n\t(ccp_lattice_meet): Handle memory stores when\n\tDO_STORE_CCP is true.\n\t(ccp_visit_phi_node): Likewise.\n\t(ccp_fold): Likewise.\n\t(evaluate_stmt): Likewise.\n\t(visit_assignment): Likewise.\n\t(ccp_visit_stmt): Likewise.\n\t(execute_ssa_ccp): Add argument 'store_ccp'.  Copy it\n\tinto DO_STORE_CCP.\n\t(do_ssa_ccp): New.\n\t(pass_ccp): Use it.\n\t(do_ssa_store_ccp): New.\n\t(gate_store_ccp): New.\n\t(pass_store_ccp): Declare.\n\t* tree-ssa-copy.c: Include tree-ssa-propagate.h.\n\t(may_propagate_copy): Reformat.\n\tDon't abort if ORIG is a virtual and DEST isn't.\n\tIf NEW does not have alias information but DEST does,\n\tcopy it.\n\t(copy_of, cached_last_copy_of, do_store_copy_prop, enum\n\tcopy_prop_kind, which_copy_prop): Declare.\n\t(stmt_may_generate_copy, get_copy_of_val,\n\tget_last_copy_of, set_copy_of_val, dump_copy_of,\n\tcopy_prop_visit_assignment, copy_prop_visit_cond_stmt,\n\tcopy_prop_visit_stmt, copy_prop_visit_phi_node,\n\tinit_copy_prop, fini_copy_prop, execute_copy_prop,\n\tgate_copy_prop, do_copy_prop, gate_store_copy_prop,\n\tstore_copy_prop): New.\n\t(pass_copy_prop, pass_store_copy_prop): Declare.\n\t* tree-ssa-dom.c (struct opt_stats_d): Add fields\n\t'num_const_prop' and 'num_copy_prop'.\n\t(cprop_operand): Update them.\n\t(dump_dominator_optimization_stats): Dump them.\n\t(tree_ssa_dominator_optimize): Call update_ssa instead of\n\trewrite_into_ssa.\n\t(loop_depth_of_name): Declare extern.\n\t(simplify_cond_and_lookup_avail_expr): Guard against NULL\n\tvalues for LOW or HIGH.\n\t(cprop_into_successor_phis): Only propagate if NEW != ORIG.\n\t(record_equivalences_from_stmt): Call expr_computes_nonzero.\n\t(cprop_operand): Only propagate if VAL != OP.\n\t* tree-ssa-dse.c (dse_optimize_stmt): Mark symbols in removed\n\tstatement for renaming.\n\t* tree-ssa-loop-im.c (move_computations): Call update_ssa.\n\t* tree-ssa-loop-ivopts.c (rewrite_address_base): Call\n\tadd_type_alias if necessary.\n\tCall mark_new_vars_to_rename.\n\t(tree_ssa_iv_optimize): If new symbols need to be renamed,\n\tmark every statement updated, call update_ssa and\n\trewrite_into_loop_closed_ssa.\n\t* tree-ssa-loop-manip.c (add_exit_phis): Do not remove DEF_BB\n\tfrom LIVEIN if VAR is a virtual.\n\t* tree-ssa-loop.c (tree_loop_optimizer_init): Call update_ssa.\n\t* tree-ssa-operands.c (get_expr_operands): Handle ASSERT_EXPR.\n\t(get_call_expr_operands): Reformat statement.\n\t(add_stmt_operand): Don't create V_MAY_DEFs for read-only\n\tsymbols.\n\t* tree-ssa-propagate.c (ssa_prop_init): Initialize\n\tSSA_NAME_VALUE for every name.\n\t(first_vdef, stmt_makes_single_load, stmt_makes_single_store,\n\tget_value_loaded_by): New.\n\t(replace_uses_in, replace_vuses_in, replace_phi_args_in,\n\tsubstitute_and_fold): Move from tree-ssa-ccp.c.\n\t* tree-ssa-propagate.h (struct prop_value_d, prop_value_t,\n\tfirst_vdef, stmt_makes_single_load, stmt_makes_single_store,\n\tget_value_loaded_by, replace_uses_in, substitute_and_fold):\n\tDeclare.\n\t* tree-ssa.c (verify_use): Fix error message.\n\t(propagate_into_addr, replace_immediate_uses, get_eq_name,\n\tcheck_phi_redundancy, kill_redundant_phi_nodes,\n\tpass_redundant_phi): Remove.  Update all users.\n\t* tree-vect-transform.c (vect_create_data_ref_ptr): Call\n\tadd_type_alias, if necessary.\n\t* tree-vectorizer.h (struct _stmt_vect_info): Update\n\tdocumentation for field 'memtag'.\n\t* tree-vrp.c: New file.\n\t* tree.def (ASSERT_EXPR): Define.\n\t* tree.h (ASSERT_EXPR_VAR): Define.\n\t(ASSERT_EXPR_COND): Define.\n\t(SSA_NAME_VALUE_RANGE): Define.\n\t(struct tree_ssa_name): Add field 'value_range'.\n\t(PHI_REWRITTEN): Remove.\n\t(struct tree_phi_node): Remove field 'rewritten'.\n\t* doc/invoke.texi (-fdump-tree-storeccp, -ftree-copy-prop,\n\t-ftree-store-copy-prop): Document.\n\t* doc/tree-ssa.texi: Remove broken link to McCAT's compiler.\n\tDocument usage of update_ssa.\n\ntestsuite/ChangeLog\n\n\t* g++.dg/tree-ssa/pr18178.C: New test.\n\t* gcc.c-torture/execute/20030216-1.x: Ignore at -O1.\n\t* gcc.c-torture/execute/20041019-1.c: New test.\n\t* gcc.dg/tree-ssa/20041008-1.c: New test.\n\t* gcc.dg/tree-ssa/ssa-ccp-12.c: New test.\n\t* gcc.dg/tree-ssa/20030731-2.c: Update to use -fdump-tree-store_ccp.\n\t* gcc.dg/tree-ssa/20030917-1.c: Likewise.\n\t* gcc.dg/tree-ssa/20030917-3.c: Likewise.\n\t* gcc.dg/tree-ssa/20040721-1.c: Likewise.\n\t* gcc.dg/tree-ssa/ssa-ccp-1.c: Likewise.\n\t* gcc.dg/tree-ssa/ssa-ccp-2.c: Likewise.\n\t* gcc.dg/tree-ssa/ssa-ccp-3.c: Likewise.\n\t* gcc.dg/tree-ssa/ssa-ccp-7.c: Likewise.\n\t* gcc.dg/tree-ssa/ssa-ccp-9.c: Likewise.\n\nFrom-SVN: r97884", "tree": {"sha": "271cffc60ad6d382edfc47d6caf78c333019cfca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/271cffc60ad6d382edfc47d6caf78c333019cfca"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0bca51f080dfff5e943b1f1775d874a73bbc441a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0bca51f080dfff5e943b1f1775d874a73bbc441a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0bca51f080dfff5e943b1f1775d874a73bbc441a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0bca51f080dfff5e943b1f1775d874a73bbc441a/comments", "author": null, "committer": null, "parents": [{"sha": "45f9480e292e10312914733dd31d1030f4e089af", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45f9480e292e10312914733dd31d1030f4e089af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/45f9480e292e10312914733dd31d1030f4e089af"}], "stats": {"total": 8921, "additions": 7313, "deletions": 1608}, "files": [{"sha": "6b7192f1b21b9684955adbbddfe408133e850e31", "filename": "gcc/ChangeLog", "status": "modified", "additions": 273, "deletions": 0, "changes": 273, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0bca51f080dfff5e943b1f1775d874a73bbc441a", "patch": "@@ -1,3 +1,276 @@\n+2005-04-08  Diego Novillo  <dnovillo@redhat.com>\n+\n+\tMerge from tree-cleanup-branch: VRP, store CCP, store\n+\t    copy-prop, incremental SSA updating of FUD chains and\n+\t    newly exposed symbols.\n+\n+\t* Makefile.in (tree-ssa-copy.o): Depend on tree-ssa-propagate.h.\n+\t(OBJS-common): Add tree-vrp.o.\n+\t(tree-vrp.o): New rule.\n+\t* basic-block.h (nearest_common_dominator_for_set): Declare.\n+\t* common.opt (ftree-store-ccp): New flag.\n+\t(ftree-copy-prop): New flag.\n+\t(ftree-vrp): New flag.\n+\t(ftree-store-copy-prop): New flag.\n+\t* dominance.c (nearest_common_dominator_for_set): New.\n+\t* domwalk.c (walk_dominator_tree): Only traverse\n+\tstatements in blocks marked in walk_data->interesting_blocks.\n+\t* domwalk.h (struct dom_walk_data): Add field interesting_blocks.\n+\t* fold-const.c (fold): Handle ASSERT_EXPR.\n+\t* opts.c (decode_options): Set flag_tree_copy_prop at -O1.\n+\tSet flag_tree_store_ccp, flag_tree_store_copy_prop and\n+\tflag_tree_vrp at -O2.\n+\t* timevar.def (TV_TREE_VRP): Define.\n+\t(TV_TREE_COPY_PROP): Define.\n+\t(TV_TREE_STORE_COPY_PROP): Define.\n+\t(TV_TREE_SSA_INCREMENTAL): Define.\n+\t(TV_TREE_STORE_CCP): Define.\n+\t* tree-cfg.c (tree_can_merge_blocks_p): Remove reference\n+\tto kill_redundant_phi_nodes from comment.\n+\t(verify_expr): Handle ASSERT_EXPR.\n+\t* tree-dfa.c (mark_new_vars_to_rename): Remove second\n+\targument.  Update all users.\n+\t(mark_call_clobbered_vars_to_rename): Remove.  Update all\n+\tusers.\n+\t* tree-flow-inline.h (unmodifiable_var_p): New.\n+\t* tree-flow.h (enum value_range_type): Declare.\n+\t(struct value_range_def): Declare.\n+\t(value_range): Declare.\n+\t(remove_all_phi_nodes_for): Remove.  Update all users.\n+\t(find_phi_node_for): Declare.\n+\t(add_type_alias): Declare.\n+\t(count_uses_and_derefs): Declare.\n+\t(kill_redundant_phi_nodes): Remove.\n+\t(rewrite_into_ssa): Remove.\n+\t(rewrite_def_def_chains): Remove.\n+\t(update_ssa, register_new_name_mapping, create_new_def_for,\n+\tneed_ssa_update_p, name_registered_for_update_p,\n+\trelease_ssa_name_after_update_ssa, dump_repl_tbl,\n+\tdebug_repl_tbl, dump_names_replaced_by,\n+\tdebug_names_replaced_by, mark_sym_for_renaming,\n+\tmark_set_for_renaming, get_current_def, set_current_def,\n+\tget_value_range, dump_value_range, debug_value_range,\n+\tdump_all_value_ranges, debug_all_value_ranges,\n+\texpr_computes_nonzero, loop_depth_of_name,\n+\tunmodifiable_var_p): Declare.\n+\t* tree-gimple.c (is_gimple_formal_tmp_rhs): Handle\n+\tASSERT_EXPR.\n+\t* tree-into-ssa.c (block_defs_stack): Update comment.\n+\t(old_ssa_names, new_ssa_names, old_virtual_ssa_names,\n+\tsyms_to_rename, names_to_release, repl_tbl,\n+\tneed_to_initialize_update_ssa_p, need_to_update_vops_p,\n+\tneed_to_replace_names_p): New locals.\n+\t(NAME_SETS_GROWTH_FACTOR): Define.\n+\t(struct repl_map_d): Declare.\n+\t(struct mark_def_sites_global_data): Add field\n+\tinteresting_blocks.\n+\t(enum rewrite_mode): Declare.\n+\t(REGISTER_DEFS_IN_THIS_STMT): Define.\n+\t(compute_global_livein): Use last_basic_block instead of\n+\tn_basic_blocks.\n+\t(set_def_block): Remove last argument.  Update all callers.\n+\t(prepare_use_operand_for_rename): Remove.  Update all callers.\n+\t(prepare_def_operand_for_rename): Remove.  Update all callers.\n+\t(symbol_marked_for_renaming): New.\n+\t(is_old_name): New.\n+\t(is_new_name): New.\n+\t(repl_map_hash): New.\n+\t(repl_map_eq): New.\n+\t(repl_map_free): New.\n+\t(names_replaced_by): New.\n+\t(add_to_repl_tbl): New.\n+\t(add_new_name_mapping): New.\n+\t(mark_def_sites): Assume that all the operands in the\n+\tstatement are in normal form.\n+\t(find_idf): Assert that the block in the stack is valid.\n+\t(get_default_def_for): New.\n+\t(insert_phi_nodes_for): Add new argument 'update_p'.\n+\tAdd documentation.\n+\tIf update_p is true, add a new mapping between the LHS of\n+\teach new PHI and the name that it replaces.\n+\t(insert_phi_nodes_1): Only call find_idf if needed.\n+\t(get_reaching_def): Call get_default_def_for.\n+\t(rewrite_operand): Remove.\n+\t(rewrite_stmt): Do nothing if REGISTER_DEFS_IN_THIS_STMT\n+\tand REWRITE_THIS_STMT are false.\n+\tAssume that all the operands in the statement are in\n+\tnormal form.\n+\t(rewrite_add_phi_arguments): Don't use PHI_REWRITTEN.\n+\t(rewrite_virtual_phi_arguments): Remove.\n+\t(invalidate_name_tags): Remove.\n+\t(register_new_update_single, register_new_update_set,\n+\trewrite_update_init_block, replace_use,\n+\trewrite_update_fini_block, rewrite_update_stmt,\n+\trewrite_update_phi_arguments): New.\n+\trewrite_blocks): Remove argument 'fix_virtual_phis'.\n+\tAdd arguments 'entry', 'what' and 'blocks'.\n+\tInitialize the dominator walker according to 'what' and\n+\t'blocks'.\n+\tStart the dominator walk at 'entry'.\n+\t(mark_def_site_blocks): Add argument 'interesting_blocks'.\n+\tUse it to configure the dominator walker.\n+\t(rewrite_into_ssa): Remove argument 'all'.\n+\tMake internal.\n+\t(rewrite_all_into_ssa): Remove.\n+\t(rewrite_def_def_chains): Remove.\n+\t(mark_def_interesting, mark_use_interesting,\n+\tprepare_phi_args_for_update, prepare_block_for_update,\n+\tprepare_def_site_for, prepare_def_sites,\n+\tdump_names_replaced_by, debug_names_replaced_by,\n+\tdump_repl_tbl, debug_repl_tbl, init_update_ssa,\n+\tdelete_update_ssa, create_new_def_for,\n+\tregister_new_name_mapping, mark_sym_for_renaming,\n+\tmark_set_for_renaming, need_ssa_update_p,\n+\tname_registered_for_update_p, ssa_names_to_replace,\n+\trelease_ssa_name_after_update_ssa,\n+\tinsert_updated_phi_nodes_for, update_ssa): New.\n+\t* tree-loop-linear.c (linear_transform_loops): Call\n+\tupdate_ssa instead of rewrite_into_ssa.\n+\t* tree-optimize.c (vars_to_rename): Remove.\n+\tUpdate all users.\n+\t(init_tree_optimization_passes): Replace\n+\tpass_redundant_phi with pass_copy_prop.\n+\tAdd pass_vrp.\n+\tReplace pass_ccp with pass_store_ccp.\n+\tAdd pass_store_copy_prop after pass_store_ccp.\n+\t(execute_todo): If the TODO_ flags don't include updating\n+\tthe SSA form, assert that it does not need to be updated.\n+\tCall update_ssa instead of rewrite_into_ssa and\n+\trewrite_def_def_chains.\n+\tIf TODO_verify_loops is set, call verify_loop_closed_ssa.\n+\t(tree_rest_of_compilation):\n+\t* tree-pass.h (TODO_dump_func, TODO_ggc_collect,\n+\tTODO_verify_ssa, TODO_verify_flow, TODO_verify_stmts,\n+\tTODO_cleanup_cfg): Renumber.\n+\t(TODO_verify_loops, TODO_update_ssa,\n+\tTODO_update_ssa_no_phi, TODO_update_ssa_full_phi,\n+\tTODO_update_ssa_only_virtuals): Define.\n+\t(pass_copy_prop, pass_store_ccp, pass_store_copy_prop, pass_vrp):\n+\tDeclare.\n+\t* tree-phinodes.c (make_phi_node): Update documentation.\n+\t(remove_all_phi_nodes_for): Remove.\n+\t(find_phi_node_for): New.\n+\t* tree-pretty-print.c (dump_generic_node): Handle ASSERT_EXPR.\n+\t* tree-scalar-evolution.c (follow_ssa_edge_in_rhs): Likewise.\n+\t(interpret_rhs_modify_expr): Likewise.\n+\t* tree-sra.c (decide_instantiations): Mark all symbols in\n+\tSRA_CANDIDATES for renaming.\n+\t(mark_all_v_defs_1): Rename from mark_all_v_defs.\n+\t(mark_all_v_defs): New function.  Update all users to call it \n+\twith the whole list of scalarized statements, not just the\n+\tfirst one.\n+\t* tree-ssa-alias.c (count_ptr_derefs): Make extern.\n+\t(compute_flow_insensitive_aliasing): If the tag is\n+\tunmodifiable and the variable isn't or vice-versa, don't\n+\tmake them alias of each other.\n+\t(setup_pointers_and_addressables): If the type tag for\n+\tVAR is about to change, mark the old one for renaming.\n+\t(add_type_alias): New.\n+\t* tree-ssa-ccp.c: Document SSA-CCP and STORE-CCP.\n+\t(ccp_lattice_t): Rename from latticevalue.\n+\t(value): Remove.  Update all users.\n+\t(const_val): New local variable.\n+\t(do_store_ccp): New local variable.\n+\t(dump_lattice_value): Handle UNINITIALIZED.\n+\t(debug_lattice_value): New.\n+\t(get_default_value): Re-write.\n+\t(set_lattice_value): Re-write.\n+\t(def_to_varying): Remove.  Update all users.\n+\t(likely_value): Return VARYING for statements that make\n+\tstores when STORE_CCP is false.\n+\tReturn VARYING for any statement other than MODIFY_EXPR,\n+\tCOND_EXPR and SWITCH_EXPR.\n+\t(ccp_initialize): Re-write.\n+\t(replace_uses_in, replace_vuse_in, substitute_and_fold):\n+\tMove to tree-ssa-propagate.c.\n+\t(ccp_lattice_meet): Handle memory stores when\n+\tDO_STORE_CCP is true.\n+\t(ccp_visit_phi_node): Likewise.\n+\t(ccp_fold): Likewise.\n+\t(evaluate_stmt): Likewise.\n+\t(visit_assignment): Likewise.\n+\t(ccp_visit_stmt): Likewise.\n+\t(execute_ssa_ccp): Add argument 'store_ccp'.  Copy it\n+\tinto DO_STORE_CCP.\n+\t(do_ssa_ccp): New.\n+\t(pass_ccp): Use it.\n+\t(do_ssa_store_ccp): New.\n+\t(gate_store_ccp): New.\n+\t(pass_store_ccp): Declare.\n+\t* tree-ssa-copy.c: Include tree-ssa-propagate.h.\n+\t(may_propagate_copy): Reformat.\n+\tDon't abort if ORIG is a virtual and DEST isn't.\n+\tIf NEW does not have alias information but DEST does,\n+\tcopy it.\n+\t(copy_of, cached_last_copy_of, do_store_copy_prop, enum\n+\tcopy_prop_kind, which_copy_prop): Declare.\n+\t(stmt_may_generate_copy, get_copy_of_val,\n+\tget_last_copy_of, set_copy_of_val, dump_copy_of,\n+\tcopy_prop_visit_assignment, copy_prop_visit_cond_stmt,\n+\tcopy_prop_visit_stmt, copy_prop_visit_phi_node,\n+\tinit_copy_prop, fini_copy_prop, execute_copy_prop,\n+\tgate_copy_prop, do_copy_prop, gate_store_copy_prop,\n+\tstore_copy_prop): New.\n+\t(pass_copy_prop, pass_store_copy_prop): Declare.\n+\t* tree-ssa-dom.c (struct opt_stats_d): Add fields\n+\t'num_const_prop' and 'num_copy_prop'.\n+\t(cprop_operand): Update them.\n+\t(dump_dominator_optimization_stats): Dump them.\n+\t(tree_ssa_dominator_optimize): Call update_ssa instead of\n+\trewrite_into_ssa.\n+\t(loop_depth_of_name): Declare extern.\n+\t(simplify_cond_and_lookup_avail_expr): Guard against NULL\n+\tvalues for LOW or HIGH.\n+\t(cprop_into_successor_phis): Only propagate if NEW != ORIG.\n+\t(record_equivalences_from_stmt): Call expr_computes_nonzero.\n+\t(cprop_operand): Only propagate if VAL != OP.\n+\t* tree-ssa-dse.c (dse_optimize_stmt): Mark symbols in removed\n+\tstatement for renaming.\n+\t* tree-ssa-loop-im.c (move_computations): Call update_ssa.\n+\t* tree-ssa-loop-ivopts.c (rewrite_address_base): Call\n+\tadd_type_alias if necessary.\n+\tCall mark_new_vars_to_rename.\n+\t(tree_ssa_iv_optimize): If new symbols need to be renamed,\n+\tmark every statement updated, call update_ssa and\n+\trewrite_into_loop_closed_ssa.\n+\t* tree-ssa-loop-manip.c (add_exit_phis): Do not remove DEF_BB\n+\tfrom LIVEIN if VAR is a virtual.\n+\t* tree-ssa-loop.c (tree_loop_optimizer_init): Call update_ssa.\n+\t* tree-ssa-operands.c (get_expr_operands): Handle ASSERT_EXPR.\n+\t(get_call_expr_operands): Reformat statement.\n+\t(add_stmt_operand): Don't create V_MAY_DEFs for read-only\n+\tsymbols.\n+\t* tree-ssa-propagate.c (ssa_prop_init): Initialize\n+\tSSA_NAME_VALUE for every name.\n+\t(first_vdef, stmt_makes_single_load, stmt_makes_single_store,\n+\tget_value_loaded_by): New.\n+\t(replace_uses_in, replace_vuses_in, replace_phi_args_in,\n+\tsubstitute_and_fold): Move from tree-ssa-ccp.c.\n+\t* tree-ssa-propagate.h (struct prop_value_d, prop_value_t,\n+\tfirst_vdef, stmt_makes_single_load, stmt_makes_single_store,\n+\tget_value_loaded_by, replace_uses_in, substitute_and_fold):\n+\tDeclare.\n+\t* tree-ssa.c (verify_use): Fix error message.\n+\t(propagate_into_addr, replace_immediate_uses, get_eq_name,\n+\tcheck_phi_redundancy, kill_redundant_phi_nodes,\n+\tpass_redundant_phi): Remove.  Update all users.\n+\t* tree-vect-transform.c (vect_create_data_ref_ptr): Call\n+\tadd_type_alias, if necessary.\n+\t* tree-vectorizer.h (struct _stmt_vect_info): Update\n+\tdocumentation for field 'memtag'.\n+\t* tree-vrp.c: New file.\n+\t* tree.def (ASSERT_EXPR): Define.\n+\t* tree.h (ASSERT_EXPR_VAR): Define.\n+\t(ASSERT_EXPR_COND): Define.\n+\t(SSA_NAME_VALUE_RANGE): Define.\n+\t(struct tree_ssa_name): Add field 'value_range'.\n+\t(PHI_REWRITTEN): Remove.\n+\t(struct tree_phi_node): Remove field 'rewritten'.\n+\t* doc/invoke.texi (-fdump-tree-storeccp, -ftree-copy-prop,\n+\t-ftree-store-copy-prop): Document.\n+\t* doc/tree-ssa.texi: Remove broken link to McCAT's compiler.\n+\tDocument usage of update_ssa.\n+\n 2005-04-08  David Edelsohn  <edelsohn@gnu.org>\n \n \tPR target/20814"}, {"sha": "f115e5d97b23dc9d5f16d02951192b8862fc6e6e", "filename": "gcc/Makefile.in", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=0bca51f080dfff5e943b1f1775d874a73bbc441a", "patch": "@@ -958,7 +958,8 @@ OBJS-common = \\\n  varasm.o varray.o vec.o version.o vmsdbgout.o xcoffout.o alloc-pool.o\t   \\\n  et-forest.o cfghooks.o bt-load.o pretty-print.o $(GGC) web.o passes.o\t   \\\n  rtl-profile.o tree-profile.o rtlhooks.o cfgexpand.o lambda-mat.o          \\\n- lambda-trans.o\tlambda-code.o tree-loop-linear.o tree-ssa-sink.o\n+ lambda-trans.o lambda-code.o tree-loop-linear.o tree-ssa-sink.o           \\\n+ tree-vrp.o\n \n OBJS-md = $(out_object_file)\n OBJS-archive = $(EXTRA_OBJS) $(host_hook_obj) tree-inline.o\t\t   \\\n@@ -1654,7 +1655,7 @@ tree-nrv.o : tree-nrv.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n tree-ssa-copy.o : tree-ssa-copy.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) $(GGC_H) output.h diagnostic.h \\\n    errors.h function.h $(TIMEVAR_H) $(TM_H) coretypes.h $(TREE_DUMP_H) \\\n-   $(BASIC_BLOCK_H) tree-pass.h langhooks.h\n+   $(BASIC_BLOCK_H) tree-pass.h langhooks.h tree-ssa-propagate.h\n tree-ssa-propagate.o : tree-ssa-propagate.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(SYSTEM_H) $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) $(GGC_H) output.h \\\n    diagnostic.h errors.h function.h $(TIMEVAR_H) $(TM_H) coretypes.h \\\n@@ -1691,6 +1692,10 @@ tree-ssa-pre.o : tree-ssa-pre.c $(TREE_FLOW_H) $(CONFIG_H) \\\n tree-vn.o : tree-vn.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(GGC_H) \\\n    $(TREE_H) $(TREE_FLOW_H) $(HASHTAB_H) langhooks.h tree-pass.h \\\n    $(TREE_DUMP_H) diagnostic.h\n+tree-vrp.o : tree-vrp.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n+   $(TREE_FLOW_H) tree-pass.h $(TREE_DUMP_H) diagnostic.h $(GGC_H) \\\n+   $(BASIC_BLOCK_H) tree-ssa-propagate.h $(FLAGS_H) $(TREE_DUMP_H) \\\n+   $(CFGLOOP_H) tree-scalar-evolution.h tree-chrec.h\n tree-cfg.o : tree-cfg.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) $(GGC_H) $(FLAGS_H) output.h \\\n    diagnostic.h errors.h function.h $(TIMEVAR_H) $(TM_H) coretypes.h \\"}, {"sha": "0fa8ce55e833a378e72488fb55e002adf9a835c5", "filename": "gcc/basic-block.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=0bca51f080dfff5e943b1f1775d874a73bbc441a", "patch": "@@ -896,6 +896,8 @@ extern void calculate_dominance_info (enum cdi_direction);\n extern void free_dominance_info (enum cdi_direction);\n extern basic_block nearest_common_dominator (enum cdi_direction,\n \t\t\t\t\t     basic_block, basic_block);\n+extern basic_block nearest_common_dominator_for_set (enum cdi_direction, \n+\t\t\t\t\t\t     bitmap);\n extern void set_immediate_dominator (enum cdi_direction, basic_block,\n \t\t\t\t     basic_block);\n extern basic_block get_immediate_dominator (enum cdi_direction, basic_block);"}, {"sha": "b75785c5087481fbd4103bed8931750fd3679cb0", "filename": "gcc/common.opt", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=0bca51f080dfff5e943b1f1775d874a73bbc441a", "patch": "@@ -828,6 +828,10 @@ ftree-ccp\n Common Report Var(flag_tree_ccp)\n Enable SSA-CCP optimization on trees\n \n+ftree-store-ccp\n+Common Report Var(flag_tree_store_ccp)\n+Enable SSA-CCP optimization for stores and loads\n+\n ftree-ch\n Common Report Var(flag_tree_ch)\n Enable loop header copying on trees\n@@ -840,6 +844,14 @@ ftree-copyrename\n Common Report Var(flag_tree_copyrename)\n Replace SSA temporaries with better names in copies.\n \n+ftree-copy-prop\n+Common Report Var(flag_tree_copy_prop)\n+Enable copy propagation on trees\n+\n+ftree-store-copy-prop\n+Common Report Var(flag_tree_store_copy_prop)\n+Enable copy propagation for stores and loads\n+\n ftree-dce\n Common Report Var(flag_tree_dce)\n Enable SSA dead code elimination optimization on trees\n@@ -896,6 +908,10 @@ ftree-lrs\n Common Report Var(flag_tree_live_range_split)\n Perform live range splitting during the SSA->normal pass.\n \n+ftree-vrp\n+Common Report Var(flag_tree_vrp) Init(0)\n+Perform Value Range Propagation on trees\n+\n funit-at-a-time\n Common Report Var(flag_unit_at_a_time)\n Compile whole compilation unit at a time"}, {"sha": "8a1cfbb73ad5b121090db99bde7181b54e440860", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 37, "deletions": 2, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=0bca51f080dfff5e943b1f1775d874a73bbc441a", "patch": "@@ -269,6 +269,7 @@ Objective-C and Objective-C++ Dialects}.\n -fdump-tree-salias @gol\n -fdump-tree-fre@r{[}-@var{n}@r{]} @gol\n -ftree-vectorizer-verbose=@var{n} @gol\n+-fdump-tree-storeccp@r{[}-@var{n}@r{]} @gol\n -feliminate-dwarf2-dups -feliminate-unused-debug-types @gol\n -feliminate-unused-debug-symbols -fmem-report -fprofile-arcs -ftree-based-profiling @gol\n -frandom-seed=@var{string} -fsched-verbose=@var{n} @gol\n@@ -324,6 +325,7 @@ Objective-C and Objective-C++ Dialects}.\n -ftree-dominator-opts -ftree-dse -ftree-copyrename -ftree-sink @gol\n -ftree-ch -ftree-sra -ftree-ter -ftree-lrs -ftree-fre -ftree-vectorize @gol\n -ftree-salias -fweb @gol\n+-ftree-copy-prop -ftree-store-ccp -ftree-store-copy-prop @gol\n --param @var{name}=@var{value}\n -O  -O0  -O1  -O2  -O3  -Os}\n \n@@ -3879,6 +3881,11 @@ appending @file{.alias} to the source file name.\n Dump each function after CCP@.  The file name is made by appending\n @file{.ccp} to the source file name.\n \n+@item storeccp\n+@opindex fdump-tree-storeccp\n+Dump each function after STORE-CCP.  The file name is made by appending\n+@file{.storeccp} to the source file name.\n+\n @item pre\n @opindex fdump-tree-pre\n Dump trees after partial redundancy elimination.  The file name is made\n@@ -3889,6 +3896,16 @@ by appending @file{.pre} to the source file name.\n Dump trees after full redundancy elimination.  The file name is made\n by appending @file{.fre} to the source file name.\n \n+@item copyprop\n+@opindex fdump-tree-copyprop\n+Dump trees after copy propagation.  The file name is made\n+by appending @file{.copyprop} to the source file name.\n+\n+@item store_copyprop\n+@opindex fdump-tree-store_copyprop\n+Dump trees after store copy-propagation.  The file name is made\n+by appending @file{.store_copyprop} to the source file name.\n+\n @item dce\n @opindex fdump-tree-dce\n Dump each function after dead code elimination.  The file name is made by\n@@ -4745,6 +4762,17 @@ that are computed on all paths leading to the redundant computation.\n This analysis faster than PRE, though it exposes fewer redundancies.\n This flag is enabled by default at @option{-O} and higher.\n \n+@item -ftree-copy-prop\n+Perform copy propagation on trees.  This pass eliminates unnecessary\n+copy operations.  This flag is enabled by default at @option{-O} and\n+higher.\n+\n+@item -ftree-store-copy-prop\n+Perform copy propagation of memory loads and stores.  This pass\n+eliminates unnecessary copy operations in memory references\n+(structures, global variables, arrays, etc).  This flag is enabled by\n+default at @option{-O2} and higher.\n+\n @item -ftree-salias\n Perform structural alias analysis on trees.  This flag\n is enabled by default at @option{-O} and higher.\n@@ -4754,8 +4782,15 @@ Perform forward store motion  on trees.  This flag is\n enabled by default at @option{-O} and higher.\n \n @item -ftree-ccp\n-Perform sparse conditional constant propagation (CCP) on trees.  This flag\n-is enabled by default at @option{-O} and higher.\n+Perform sparse conditional constant propagation (CCP) on trees.  This\n+pass only operates on local scalar variables and is enabled by default\n+at @option{-O} and higher.\n+\n+@item -ftree-store-ccp\n+Perform sparse conditional constant propagation (CCP) on trees.  This\n+pass operates on both local scalar variables and memory stores and\n+loads (global variables, structures, arrays, etc).  This flag is\n+enabled by default at @option{-O2} and higher.\n \n @item -ftree-dce\n Perform dead code elimination (DCE) on trees.  This flag is enabled by"}, {"sha": "d4cf83825c55d7063b89da0130643086daee4919", "filename": "gcc/doc/tree-ssa.texi", "status": "modified", "additions": 121, "deletions": 11, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Fdoc%2Ftree-ssa.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Fdoc%2Ftree-ssa.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftree-ssa.texi?ref=0bca51f080dfff5e943b1f1775d874a73bbc441a", "patch": "@@ -83,8 +83,7 @@ perfectly happy to take it as input and spit out GIMPLE@.\n \n GIMPLE is a simplified subset of GENERIC for use in optimization.  The\n particular subset chosen (and the name) was heavily influenced by the\n-SIMPLE IL used by the McCAT compiler project at McGill University\n-(@uref{http://www-acaps.cs.mcgill.ca/info/McCAT/McCAT.html}),\n+SIMPLE IL used by the McCAT compiler project at McGill University,\n though we have made some different choices.  For one thing, SIMPLE\n doesn't support @code{goto}; a production compiler can't afford that\n kind of restriction.\n@@ -1111,18 +1110,129 @@ Returns the @code{SSA_NAME} for the @var{i}th argument of @var{phi}.\n \n \n @subsection Preserving the SSA form\n-@findex vars_to_rename\n+@findex update_ssa\n @cindex preserving SSA form\n Some optimization passes make changes to the function that\n invalidate the SSA property.  This can happen when a pass has\n-added new variables or changed the program so that variables that\n-were previously aliased aren't anymore.\n-\n-Whenever something like this happens, the affected variables must\n-be renamed into SSA form again.  To do this, you should mark the\n-new variables in the global bitmap @code{vars_to_rename}.  Once\n-your pass has finished, the pass manager will invoke the SSA\n-renamer to put the program into SSA once more.\n+added new symbols or changed the program so that variables that\n+were previously aliased aren't anymore.  Whenever something like this\n+happens, the affected symbols must be renamed into SSA form again.  \n+Transformations that emit new code or replicate existing statements\n+will also need to update the SSA form@.\n+\n+Since GCC implements two different SSA forms for register and virtual\n+variables, keeping the SSA form up to date depends on whether you are\n+updating register or virtual names.  In both cases, the general idea\n+behind incremental SSA updates is similar: when new SSA names are\n+created, they typically are meant to replace other existing names in\n+the program@.\n+\n+For instance, given the following code:\n+\n+@smallexample\n+     1\tL0:\n+     2\tx_1 = PHI (0, x_5)\n+     3\tif (x_1 < 10)\n+     4\t  if (x_1 > 7)\n+     5\t    y_2 = 0\n+     6\t  else\n+     7\t    y_3 = x_1 + x_7\n+     8\t  endif\n+     9\t  x_5 = x_1 + 1\n+     10   goto L0;\n+     11\tendif\n+@end smallexample\n+\n+Suppose that we insert new names @code{x_10} and @code{x_11} (lines\n+@code{4} and @code{8})@.\n+\n+@smallexample\n+     1\tL0:\n+     2\tx_1 = PHI (0, x_5)\n+     3\tif (x_1 < 10)\n+     4\t  x_10 = ...\n+     5\t  if (x_1 > 7)\n+     6\t    y_2 = 0\n+     7\t  else\n+     8\t    x_11 = ...\n+     9\t    y_3 = x_1 + x_7\n+     10\t  endif\n+     11\t  x_5 = x_1 + 1\n+     12\t  goto L0;\n+     13\tendif\n+@end smallexample\n+\n+We want to replace all the uses of @code{x_1} with the new definitions\n+of @code{x_10} and @code{x_11}.  Note that the only uses that should\n+be replaced are those at lines @code{5}, @code{9} and @code{11}.\n+Also, the use of @code{x_7} at line @code{9} should @emph{not} be\n+replaced (this is why we cannot just mark symbol @code{x} for\n+renaming)@.\n+\n+Additionally, we may need to insert a PHI node at line @code{11}\n+because that is a merge point for @code{x_10} and @code{x_11}.  So the\n+use of @code{x_1} at line @code{11} will be replaced with the new PHI\n+node.  The insertion of PHI nodes is optional.  They are not strictly\n+necessary to preserve the SSA form, and depending on what the caller\n+inserted, they may not even be useful for the optimizers@.\n+\n+Updating the SSA form is a two step process.  First, the pass has to\n+identify which names need to be updated and/or which symbols need to\n+be renamed into SSA form for the first time.  When new names are\n+introduced to replace existing names in the program, the mapping\n+between the old and the new names are registered by calling\n+@code{register_new_name_mapping} (note that if your pass creates new\n+code by duplicating basic blocks, the call to @code{tree_duplicate_bb}\n+will set up the necessary mappings automatically).  On the other hand,\n+if your pass exposes a new symbol that should be put in SSA form for\n+the first time, the new symbol should be registered with\n+@code{mark_sym_for_renaming}.\n+\n+After the replacement mappings have been registered and new symbols\n+marked for renaming, a call to @code{update_ssa} makes the registered\n+changes.  This can be done with an explicit call or by creating\n+@code{TODO} flags in the @code{tree_opt_pass} structure for your pass.\n+There are several @code{TODO} flags that control the behaviour of\n+@code{update_ssa}:\n+\n+@itemize @bullet\n+@item @code{TODO_update_ssa}.  Update the SSA form inserting PHI nodes\n+      for newly exposed symbols and virtual names marked for updating.\n+      When updating real names, only insert PHI nodes for a real name\n+      @code{O_j} in blocks reached by all the new and old definitions for\n+      @code{O_j}.  If the iterated dominance frontier for @code{O_j}\n+      is not pruned, we may end up inserting PHI nodes in blocks that\n+      have one or more edges with no incoming definition for\n+      @code{O_j}.  This would lead to uninitialized warnings for\n+      @code{O_j}'s symbol@.\n+\n+@item @code{TODO_update_ssa_no_phi}.  Update the SSA form without\n+      inserting any new PHI nodes at all.  This is used by passes that\n+      have either inserted all the PHI nodes themselves or passes that\n+      need only to patch use-def and def-def chains for virtuals\n+      (e.g., DCE)@.\n+\n+\n+@item @code{TODO_update_ssa_full_phi}.  Insert PHI nodes everywhere\n+      they are needed.  No prunning of the IDF is done.  This is used\n+      by passes that need the PHI nodes for @code{O_j} even if it\n+      means that some arguments will come from the default definition\n+      of @code{O_j}'s symbol (e.g., @code{pass_linear_transform})@.\n+\n+      WARNING: If you need to use this flag, chances are that your\n+      pass may be doing something wrong.  Inserting PHI nodes for an\n+      old name where not all edges carry a new replacement may lead to\n+      silent codegen errors or spurious uninitialized warnings@.\n+\n+@item @code{TODO_update_ssa_only_virtuals}.  Passes that update the\n+      SSA form on their own may want to delegate the updating of\n+      virtual names to the generic updater.  Since FUD chains are\n+      easier to maintain, this simplifies the work they need to do.\n+      NOTE: If this flag is used, any OLD->NEW mappings for real names\n+      are explicitly destroyed and only the symbols marked for\n+      renaming are processed@.\n+@end itemize\n+\n \n @subsection Examining @code{SSA_NAME} nodes\n @cindex examining SSA_NAMEs"}, {"sha": "b07f6c23da4a8295cdfaae79815b936f1702e753", "filename": "gcc/dominance.c", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Fdominance.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Fdominance.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdominance.c?ref=0bca51f080dfff5e943b1f1775d874a73bbc441a", "patch": "@@ -797,6 +797,27 @@ nearest_common_dominator (enum cdi_direction dir, basic_block bb1, basic_block b\n   return et_nca (bb1->dom[dir], bb2->dom[dir])->data;\n }\n \n+\n+/* Find the nearest common dominator for the basic blocks in BLOCKS,\n+   using dominance direction DIR.  */\n+\n+basic_block\n+nearest_common_dominator_for_set (enum cdi_direction dir, bitmap blocks)\n+{\n+  unsigned i, first;\n+  bitmap_iterator bi;\n+  basic_block dom;\n+  \n+  first = bitmap_first_set_bit (blocks);\n+  dom = BASIC_BLOCK (first);\n+  EXECUTE_IF_SET_IN_BITMAP (blocks, 0, i, bi)\n+    if (dom != BASIC_BLOCK (i))\n+      dom = nearest_common_dominator (dir, dom, BASIC_BLOCK (i));\n+\n+  return dom;\n+}\n+\n+\n /* Return TRUE in case BB1 is dominated by BB2.  */\n bool\n dominated_by_p (enum cdi_direction dir, basic_block bb1, basic_block bb2)"}, {"sha": "87c841b9ffa09bc3e55390f7dfe265abbe20439c", "filename": "gcc/domwalk.c", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Fdomwalk.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Fdomwalk.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdomwalk.c?ref=0bca51f080dfff5e943b1f1775d874a73bbc441a", "patch": "@@ -145,6 +145,14 @@ walk_dominator_tree (struct dom_walk_data *walk_data, basic_block bb)\n   void *bd = NULL;\n   basic_block dest;\n   block_stmt_iterator bsi;\n+  bool is_interesting;\n+\n+  /* If block BB is not interesting to the caller, then none of the\n+     callbacks that walk the statements in BB are going to be\n+     executed.  */\n+  is_interesting = bb->index < 0\n+\t\t   || walk_data->interesting_blocks == NULL\n+\t\t   || TEST_BIT (walk_data->interesting_blocks, bb->index);\n \n   /* Callback to initialize the local data structure.  */\n   if (walk_data->initialize_block_local_data)\n@@ -179,7 +187,7 @@ walk_dominator_tree (struct dom_walk_data *walk_data, basic_block bb)\n     (*walk_data->before_dom_children_before_stmts) (walk_data, bb);\n \n   /* Statement walk before walking dominator children.  */\n-  if (walk_data->before_dom_children_walk_stmts)\n+  if (is_interesting && walk_data->before_dom_children_walk_stmts)\n     {\n       if (walk_data->walk_stmts_backward)\n \tfor (bsi = bsi_last (bb); !bsi_end_p (bsi); bsi_prev (&bsi))\n@@ -211,7 +219,7 @@ walk_dominator_tree (struct dom_walk_data *walk_data, basic_block bb)\n     (*walk_data->after_dom_children_before_stmts) (walk_data, bb);\n \n   /* Statement walk after walking dominator children.  */\n-  if (walk_data->after_dom_children_walk_stmts)\n+  if (is_interesting && walk_data->after_dom_children_walk_stmts)\n     {\n       if (walk_data->walk_stmts_backward)\n \tfor (bsi = bsi_last (bb); !bsi_end_p (bsi); bsi_prev (&bsi))"}, {"sha": "44ea39676e98a9da7c60d1acd8d5233b2f38c532", "filename": "gcc/domwalk.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Fdomwalk.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Fdomwalk.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdomwalk.h?ref=0bca51f080dfff5e943b1f1775d874a73bbc441a", "patch": "@@ -105,6 +105,14 @@ struct dom_walk_data\n \n   /* Stack of available block local structures.  */\n   varray_type free_block_data;\n+\n+  /* Interesting blocks to process.  If this field is not NULL, this\n+     set is used to determine which blocks to walk.  If we encounter\n+     block I in the dominator traversal, but block I is not present in\n+     INTERESTING_BLOCKS, then none of the callback functions are\n+     invoked on it.  This is useful when a particular traversal wants\n+     to filter out non-interesting blocks from the dominator tree.  */\n+  sbitmap interesting_blocks;\n };\n \n void walk_dominator_tree (struct dom_walk_data *, basic_block);"}, {"sha": "6a84630bb6009effc7bf2c232e718bea8f1566dc", "filename": "gcc/fold-const.c", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=0bca51f080dfff5e943b1f1775d874a73bbc441a", "patch": "@@ -10005,6 +10005,21 @@ fold (tree expr)\n     case CONST_DECL:\n       return fold (DECL_INITIAL (t));\n \n+    case ASSERT_EXPR:\n+      {\n+\t/* Given ASSERT_EXPR <Y, COND>, return Y if COND can be folded\n+\t   to boolean_true_node.  If COND folds to boolean_false_node,\n+\t   return ASSERT_EXPR <Y, 0>.  Otherwise, return the original\n+\t   expression.  */\n+\ttree c = fold (ASSERT_EXPR_COND (t));\n+\tif (c == boolean_true_node)\n+\t  return ASSERT_EXPR_VAR (t);\n+\telse if (c == boolean_false_node)\n+\t  return build (ASSERT_EXPR, TREE_TYPE (t), ASSERT_EXPR_VAR (t), c);\n+\telse\n+\t  return t;\n+      }\n+\n     default:\n       return t;\n     } /* switch (code) */"}, {"sha": "70a9b22ac5b6b460a2cc444c32278a12c9b1f20d", "filename": "gcc/opts.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=0bca51f080dfff5e943b1f1775d874a73bbc441a", "patch": "@@ -524,6 +524,7 @@ decode_options (unsigned int argc, const char **argv)\n       flag_tree_sra = 1;\n       flag_tree_copyrename = 1;\n       flag_tree_fre = 1;\n+      flag_tree_copy_prop = 1;\n       flag_tree_sink = 1;\n       flag_tree_salias = 1;\n \n@@ -562,6 +563,9 @@ decode_options (unsigned int argc, const char **argv)\n       flag_reorder_blocks = 1;\n       flag_reorder_functions = 1;\n       flag_unit_at_a_time = 1;\n+      flag_tree_store_ccp = 1;\n+      flag_tree_store_copy_prop = 1;\n+      flag_tree_vrp = 1;\n \n       if (!optimize_size)\n \t{"}, {"sha": "f6f8cefcdaf6a9f07827c53056892e732a74a2f8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0bca51f080dfff5e943b1f1775d874a73bbc441a", "patch": "@@ -1,3 +1,20 @@\n+2005-04-08  Diego Novillo  <dnovillo@redhat.com>\n+\n+\t* g++.dg/tree-ssa/pr18178.C: New test.\n+\t* gcc.c-torture/execute/20030216-1.x: Ignore at -O1.\n+\t* gcc.c-torture/execute/20041019-1.c: New test.\n+\t* gcc.dg/tree-ssa/20041008-1.c: New test.\n+\t* gcc.dg/tree-ssa/ssa-ccp-12.c: New test.\n+\t* gcc.dg/tree-ssa/20030731-2.c: Update to use -fdump-tree-store_ccp.\n+\t* gcc.dg/tree-ssa/20030917-1.c: Likewise.\n+\t* gcc.dg/tree-ssa/20030917-3.c: Likewise.\n+\t* gcc.dg/tree-ssa/20040721-1.c: Likewise.\n+\t* gcc.dg/tree-ssa/ssa-ccp-1.c: Likewise.\n+\t* gcc.dg/tree-ssa/ssa-ccp-2.c: Likewise.\n+\t* gcc.dg/tree-ssa/ssa-ccp-3.c: Likewise.\n+\t* gcc.dg/tree-ssa/ssa-ccp-7.c: Likewise.\n+\t* gcc.dg/tree-ssa/ssa-ccp-9.c: Likewise.\n+\n 2005-04-09  Hans-Peter Nilsson  <hp@axis.com>\n \n \tPR rtl-optimization/20466"}, {"sha": "fd1777ad013c2d24765645d4e01fc790f104b32e", "filename": "gcc/testsuite/g++.dg/tree-ssa/pr18178.C", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr18178.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr18178.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr18178.C?ref=0bca51f080dfff5e943b1f1775d874a73bbc441a", "patch": "@@ -0,0 +1,46 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-vrp\" } */\n+\n+// Define this to see it work.\n+// #define WORK_WORK_WORK\n+\n+#define THIRD\n+\n+#ifdef THIRD\n+#define FIRST  i < 0 || \n+#define ORIG int\n+#define CAST\n+#else\n+\n+#define FIRST\n+#ifdef WORK_WORK_WORK\n+#define ORIG unsigned int\n+#define CAST\n+#else\n+#define ORIG int\n+#define CAST (unsigned)\n+#endif // WORK_WORK_WORK\n+\n+#endif // THIRD\n+\n+struct array\n+{\n+  const ORIG len;\n+  int *data;\n+};\n+\n+extern void call (ORIG);\n+\n+void doit (array *a)\n+{\n+  for (ORIG i = 0; i < a->len; ++i)\n+    {\n+      if (FIRST  CAST (i) >= CAST (a->len))\n+\tthrow 5;\n+      call (a->data[i]);\n+    }\n+}\n+\n+/* VRP should remove all but 1 if() in the loop.  */\n+\n+/* { dg-final { scan-tree-dump-times \"if \" 1 \"vrp\"} } */"}, {"sha": "a0e03e379dfdb4cbe80d86755f3ee5c2d2a49baf", "filename": "gcc/testsuite/gcc.c-torture/execute/20030216-1.x", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20030216-1.x", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20030216-1.x", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20030216-1.x?ref=0bca51f080dfff5e943b1f1775d874a73bbc441a", "patch": "@@ -0,0 +1,12 @@\n+# This test requires constant propagation of loads and stores to be\n+# enabled.  This is only guaranteed at -O2 and higher.  Do not run\n+# at -O1.\n+\n+set torture_eval_before_compile {\n+  if {[string match {*-O1*} \"$option\"]} {\n+    continue\n+  }\n+}\n+\n+return 0\n+"}, {"sha": "3c56b31e9ceb919a1d6ce4f7fdd433882e2bde78", "filename": "gcc/testsuite/gcc.c-torture/execute/20041019-1.c", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20041019-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20041019-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20041019-1.c?ref=0bca51f080dfff5e943b1f1775d874a73bbc441a", "patch": "@@ -0,0 +1,52 @@\n+test_store_ccp (int i)\n+{\n+  int *p, a, b, c;\n+\n+  if (i < 5)\n+    p = &a;\n+  else if (i > 8)\n+    p = &b;\n+  else\n+    p = &c;\n+\n+  *p = 10;\n+  b = 3;\n+\n+  /* STORE-CCP was wrongfully propagating 10 into *p.  */\n+  return *p + 2;\n+}\n+\n+\n+test_store_copy_prop (int i)\n+{\n+  int *p, a, b, c;\n+\n+  if (i < 5)\n+    p = &a;\n+  else if (i > 8)\n+    p = &b;\n+  else\n+    p = &c;\n+\n+  *p = i;\n+  b = i + 1;\n+\n+  /* STORE-COPY-PROP was wrongfully propagating i into *p.  */\n+  return *p;\n+}\n+\n+\n+main()\n+{\n+  int x;\n+  \n+  x = test_store_ccp (10);\n+  if (x == 12)\n+    abort ();\n+  \n+  x = test_store_copy_prop (9);\n+  if (x == 9)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "9b205813caf97faca55f295d1d62c1ba2f93e9e5", "filename": "gcc/testsuite/gcc.dg/tree-ssa/20030731-2.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20030731-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20030731-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20030731-2.c?ref=0bca51f080dfff5e943b1f1775d874a73bbc441a", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O1 -fdump-tree-ccp\" } */\n+/* { dg-options \"-O1 -fdump-tree-store_ccp\" } */\n   \n \n bar (int i, int partial, int args_addr)\n@@ -13,5 +13,5 @@ bar (int i, int partial, int args_addr)\n \n /* There should be only one IF conditional since the first does nothing\n    useful.  */\n-/* { dg-final { scan-tree-dump-times \"if \" 1 \"ccp\"} } */\n-/* { dg-final { cleanup-tree-dump \"ccp\" } } */\n+/* { dg-final { scan-tree-dump-times \"if \" 1 \"store_ccp\"} } */\n+/* { dg-final { cleanup-tree-dump \"store_ccp\" } } */"}, {"sha": "b7a5450619cd5461da58f14e9965e78583804db3", "filename": "gcc/testsuite/gcc.dg/tree-ssa/20030917-1.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20030917-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20030917-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20030917-1.c?ref=0bca51f080dfff5e943b1f1775d874a73bbc441a", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O1 -fdump-tree-ccp\" } */\n+/* { dg-options \"-O1 -fdump-tree-store_ccp\" } */\n   \n \n extern int board[];\n@@ -15,5 +15,5 @@ findbestextension (int blah, int blah2)\n }\n \n /* The argument to \"foo\" should be a variable, not a constant.  */\n-/* { dg-final { scan-tree-dump-times \"foo .defval\" 1 \"ccp\"} } */\n-/* { dg-final { cleanup-tree-dump \"ccp\" } } */\n+/* { dg-final { scan-tree-dump-times \"foo .defval\" 1 \"store_ccp\"} } */\n+/* { dg-final { cleanup-tree-dump \"store_ccp\" } } */"}, {"sha": "24201469069e6d13d2d1ffff9c018eb7ecab8102", "filename": "gcc/testsuite/gcc.dg/tree-ssa/20030917-3.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20030917-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20030917-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20030917-3.c?ref=0bca51f080dfff5e943b1f1775d874a73bbc441a", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O1 -fno-tree-dominator-opts -fdump-tree-ccp\" } */\n+/* { dg-options \"-O1 -fno-tree-dominator-opts -fdump-tree-store_ccp\" } */\n \n extern int printf (const char *, ...); \n \n@@ -20,5 +20,5 @@ main ()\n \n \n /* The argument to \"printf\" should be a constant, not a variable.  */\n-/* { dg-final { scan-tree-dump-times \"printf.*, 0\" 1 \"ccp\"} } */\n-/* { dg-final { cleanup-tree-dump \"ccp\" } } */\n+/* { dg-final { scan-tree-dump-times \"printf.*, 0\" 1 \"store_ccp\"} } */\n+/* { dg-final { cleanup-tree-dump \"store_ccp\" } } */"}, {"sha": "4df313c7bc14da025e859fea01a71908b59bbb3d", "filename": "gcc/testsuite/gcc.dg/tree-ssa/20040721-1.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20040721-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20040721-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20040721-1.c?ref=0bca51f080dfff5e943b1f1775d874a73bbc441a", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O1 -fdump-tree-ccp-vops\" } */\n+/* { dg-options \"-O2 -fdump-tree-store_ccp-vops\" } */\n \n /* Test to check whether global variables are being\n    constant propagated. */\n@@ -24,5 +24,5 @@ main ()\n }\n \n /* There should be no G on the RHS of an assignment. */\n-/* { dg-final { scan-tree-dump-times \"= G;\" 0 \"ccp\"} } */\n-/* { dg-final { cleanup-tree-dump \"ccp\" } } */\n+/* { dg-final { scan-tree-dump-times \"= G;\" 0 \"store_ccp\"} } */\n+/* { dg-final { cleanup-tree-dump \"store_ccp\" } } */"}, {"sha": "ca24427b65c6ea6747bbc5aee3e761656d56aaba", "filename": "gcc/testsuite/gcc.dg/tree-ssa/20041008-1.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20041008-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20041008-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20041008-1.c?ref=0bca51f080dfff5e943b1f1775d874a73bbc441a", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-do run } */ \n+/* { dg-options \"-O2\" } */\n+\n+struct A {\n+    int x;\n+    int y;\n+};\n+\n+baz (struct A *a)\n+{\n+  a->x = 3;\n+  a->y = 2;\n+}\n+\n+foo (int i)\n+{\n+  struct A a;\n+\n+  /* Make sure we can't scalarize 'a'.  */\n+  baz (&a);\n+\n+  if (i > 10)\n+    a.x = i;\n+  else\n+    a.x = i;\n+\n+  /* Copy propagation should prove that this predicate is always false.  */\n+  if (a.x != i)\n+    link_error ();\n+\n+  return a.x;\n+}\n+\n+main ()\n+{\n+  foo (30);\n+  return 0;\n+}"}, {"sha": "259d12ac6839b9391baaaa742e7c3ab4f1971dc7", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-ccp-1.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ccp-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ccp-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ccp-1.c?ref=0bca51f080dfff5e943b1f1775d874a73bbc441a", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */ \n-/* { dg-options \"-O1 -fdump-tree-ccp\" } */\n+/* { dg-options \"-O1 -fdump-tree-store_ccp\" } */\n \n extern void link_error (void);\n \n@@ -71,5 +71,5 @@ void test11111 (int p, int q, int r)\n \n /* There should be not link_error calls, if there is any the\n    optimization has failed */\n-/* { dg-final { scan-tree-dump-times \"link_error\" 0 \"ccp\"} } */\n-/* { dg-final { cleanup-tree-dump \"ccp\" } } */\n+/* { dg-final { scan-tree-dump-times \"link_error\" 0 \"store_ccp\"} } */\n+/* { dg-final { cleanup-tree-dump \"store_ccp\" } } */"}, {"sha": "8ee9eb8d0e4b7c49e8cd820876869ac2e48ac86c", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-ccp-12.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ccp-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ccp-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ccp-12.c?ref=0bca51f080dfff5e943b1f1775d874a73bbc441a", "patch": "@@ -0,0 +1,32 @@\n+/* { dg-do run } */ \n+/* { dg-options \"-O2\" } */\n+\n+struct A\n+{\n+  int a;\n+  int b;\n+};\n+\n+struct A a;\n+const int B = 42;\n+\n+void foo (int i)\n+{\n+  if (i > 10)\n+    a.a = 42;\n+  else\n+    {\n+      a.b = 21;\n+      a.a = a.b + 21;\n+    }\n+\n+  /* This should be folded to 'if (0)' as a.a and B are both 42.  */\n+  if (a.a != B)\n+    link_error ();\n+}\n+\n+main ()\n+{\n+  foo (3);\n+  return 0;\n+}"}, {"sha": "5f614f08212defc229dfde0f3a5b3c82171545d7", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-ccp-2.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ccp-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ccp-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ccp-2.c?ref=0bca51f080dfff5e943b1f1775d874a73bbc441a", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */ \n-/* { dg-options \"-O1 -fdump-tree-ccp\" } */\n+/* { dg-options \"-O1 -fdump-tree-store_ccp\" } */\n \n extern void link_error (void);\n \n@@ -168,5 +168,5 @@ int test99999 (void)\n \n /* There should be not link_error calls, if there is any the\n    optimization has failed */\n-/* { dg-final { scan-tree-dump-times \"link_error\" 0 \"ccp\"} } */\n-/* { dg-final { cleanup-tree-dump \"ccp\" } } */\n+/* { dg-final { scan-tree-dump-times \"link_error\" 0 \"store_ccp\"} } */\n+/* { dg-final { cleanup-tree-dump \"store_ccp\" } } */"}, {"sha": "d978511c281dae1403fd88c55220f88d69a71b51", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-ccp-3.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ccp-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ccp-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ccp-3.c?ref=0bca51f080dfff5e943b1f1775d874a73bbc441a", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O1 -fdump-tree-ccp\" } */\n+/* { dg-options \"-O1 -fdump-tree-store_ccp\" } */\n \n extern void link_error (void);\n \n@@ -131,5 +131,5 @@ int* test666 (int * __restrict__ rp1, int * __restrict__ rp2, int *p1)\n    optimization has failed */\n /* ??? While we indeed don't handle some of these, a couple of the\n    restrict tests are incorrect.  */\n-/* { dg-final { scan-tree-dump-times \"link_error\" 0 \"ccp\" { xfail *-*-* } } } */\n-/* { dg-final { cleanup-tree-dump \"ccp\" } } */\n+/* { dg-final { scan-tree-dump-times \"link_error\" 0 \"store_ccp\" { xfail *-*-* } } } */\n+/* { dg-final { cleanup-tree-dump \"store_ccp\" } } */"}, {"sha": "7f20f062ddb2a6d0c8c0ce37577ee0df60c06418", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-ccp-7.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ccp-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ccp-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ccp-7.c?ref=0bca51f080dfff5e943b1f1775d874a73bbc441a", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O1 -fdump-tree-ccp\" } */\n+/* { dg-options \"-O1 -fdump-tree-store_ccp\" } */\n \n extern void link_error (void);\n \n@@ -23,5 +23,5 @@ int test7 (int a)\n \n /* There should be not link_error calls, if there is any the\n    optimization has failed */\n-/* { dg-final { scan-tree-dump-times \"link_error\" 0 \"ccp\"} } */\n-/* { dg-final { cleanup-tree-dump \"ccp\" } } */\n+/* { dg-final { scan-tree-dump-times \"link_error\" 0 \"store_ccp\"} } */\n+/* { dg-final { cleanup-tree-dump \"store_ccp\" } } */"}, {"sha": "1508ff06eecd155eeb7662e0d89b78d392933d50", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-ccp-9.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ccp-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ccp-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ccp-9.c?ref=0bca51f080dfff5e943b1f1775d874a73bbc441a", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O1 -fdump-tree-ccp\" } */\n+/* { dg-options \"-O1 -fdump-tree-store_ccp\" } */\n \n /* Check that cprop works for assignments to array elements and structs.  */\n \n@@ -51,5 +51,5 @@ test99999 (int *arr, int j)\n \n /* There should be no link_error calls, if there is any, the\n    optimization has failed */\n-/* { dg-final { scan-tree-dump-times \"link_error\" 0 \"ccp\"} } */\n-/* { dg-final { cleanup-tree-dump \"ccp\" } } */\n+/* { dg-final { scan-tree-dump-times \"link_error\" 0 \"store_ccp\"} } */\n+/* { dg-final { cleanup-tree-dump \"store_ccp\" } } */"}, {"sha": "b8d94083a08ea501746193b5b797598ceaa7c5f2", "filename": "gcc/timevar.def", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftimevar.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftimevar.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.def?ref=0bca51f080dfff5e943b1f1775d874a73bbc441a", "patch": "@@ -65,15 +65,20 @@ DEFTIMEVAR (TV_TREE_GIMPLIFY\t     , \"tree gimplify\")\n DEFTIMEVAR (TV_TREE_EH\t\t     , \"tree eh\")\n DEFTIMEVAR (TV_TREE_CFG\t\t     , \"tree CFG construction\")\n DEFTIMEVAR (TV_TREE_CLEANUP_CFG\t     , \"tree CFG cleanup\")\n+DEFTIMEVAR (TV_TREE_VRP              , \"tree VRP\")\n+DEFTIMEVAR (TV_TREE_COPY_PROP        , \"tree copy propagation\")\n+DEFTIMEVAR (TV_TREE_STORE_COPY_PROP  , \"tree store copy propagation\")\n DEFTIMEVAR (TV_FIND_REFERENCED_VARS  , \"tree find referenced vars\")\n DEFTIMEVAR (TV_TREE_PTA\t\t     , \"tree PTA\")\n DEFTIMEVAR (TV_TREE_MAY_ALIAS        , \"tree alias analysis\")\n DEFTIMEVAR (TV_TREE_INSERT_PHI_NODES , \"tree PHI insertion\")\n DEFTIMEVAR (TV_TREE_SSA_REWRITE_BLOCKS, \"tree SSA rewrite\")\n DEFTIMEVAR (TV_TREE_SSA_OTHER\t     , \"tree SSA other\")\n+DEFTIMEVAR (TV_TREE_SSA_INCREMENTAL  , \"tree SSA incremental\")\n DEFTIMEVAR (TV_TREE_OPS\t             , \"tree operand scan\")\n DEFTIMEVAR (TV_TREE_SSA_DOMINATOR_OPTS   , \"dominator optimization\")\n DEFTIMEVAR (TV_TREE_SRA              , \"tree SRA\")\n+DEFTIMEVAR (TV_TREE_STORE_CCP\t     , \"tree STORE-CCP\")\n DEFTIMEVAR (TV_TREE_CCP\t\t     , \"tree CCP\")\n DEFTIMEVAR (TV_TREE_SPLIT_EDGES      , \"tree split crit edges\")\n DEFTIMEVAR (TV_TREE_PRE\t\t     , \"tree PRE\")"}, {"sha": "38d8215d03c861dbd1a7d6d3c5dfd8297b2d500c", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=0bca51f080dfff5e943b1f1775d874a73bbc441a", "patch": "@@ -1282,8 +1282,7 @@ tree_can_merge_blocks_p (basic_block a, basic_block b)\n       && DECL_NONLOCAL (LABEL_EXPR_LABEL (stmt)))\n     return false;\n \n-  /* There may be no phi nodes at the start of b.  Most of these degenerate\n-     phi nodes should be cleaned up by kill_redundant_phi_nodes.  */\n+  /* There may be no PHI nodes at the start of B.  */\n   if (phi_nodes (b))\n     return false;\n \n@@ -3428,6 +3427,15 @@ verify_expr (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n \t}\n       break;\n \n+    case ASSERT_EXPR:\n+      x = fold (ASSERT_EXPR_COND (t));\n+      if (x == boolean_false_node)\n+\t{\n+\t  error (\"ASSERT_EXPR with an always-false condition\");\n+\t  return *tp;\n+\t}\n+      break;\n+\n     case MODIFY_EXPR:\n       x = TREE_OPERAND (t, 0);\n       if (TREE_CODE (x) == BIT_FIELD_REF"}, {"sha": "74e746578cd6115acba191d489a5b250d316cf6c", "filename": "gcc/tree-complex.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftree-complex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftree-complex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-complex.c?ref=0bca51f080dfff5e943b1f1775d874a73bbc441a", "patch": "@@ -1023,7 +1023,7 @@ struct tree_opt_pass pass_lower_vector_ssa =\n   0,\t\t\t\t\t/* properties_provided */\n   0,\t\t\t\t\t/* properties_destroyed */\n   0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_dump_func | TODO_rename_vars\t/* todo_flags_finish */\n+  TODO_dump_func | TODO_update_ssa\t/* todo_flags_finish */\n     | TODO_ggc_collect | TODO_verify_ssa\n     | TODO_verify_stmts | TODO_verify_flow,\n   0\t\t\t\t\t/* letter */"}, {"sha": "c923cdad7fc771f601486f22d4c76741e3e908cf", "filename": "gcc/tree-dfa.c", "status": "modified", "additions": 15, "deletions": 27, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftree-dfa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftree-dfa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dfa.c?ref=0bca51f080dfff5e943b1f1775d874a73bbc441a", "patch": "@@ -215,8 +215,9 @@ make_rename_temp (tree type, const char *prefix)\n   if (referenced_vars)\n     {\n       add_referenced_tmp_var (t);\n-      bitmap_set_bit (vars_to_rename, var_ann (t)->uid);\n+      mark_sym_for_renaming (t);\n     }\n+\n   return t;\n }\n \n@@ -617,11 +618,11 @@ add_referenced_tmp_var (tree var)\n }\n \n \n-/* Add all the non-SSA variables found in STMT's operands to the bitmap\n-   VARS_TO_RENAME.  */\n+/* Mark all the non-SSA variables found in STMT's operands to be\n+   processed by update_ssa.  */\n \n void\n-mark_new_vars_to_rename (tree stmt, bitmap vars_to_rename)\n+mark_new_vars_to_rename (tree stmt)\n {\n   ssa_op_iter iter;\n   tree val;\n@@ -660,13 +661,11 @@ mark_new_vars_to_rename (tree stmt, bitmap vars_to_rename)\n   v_must_defs_after = NUM_V_MUST_DEFS (STMT_V_MUST_DEF_OPS (stmt));\n \n   FOR_EACH_SSA_TREE_OPERAND (val, stmt, iter, SSA_OP_ALL_OPERANDS)\n-    {\n-      if (DECL_P (val))\n-\t{\n-\t  found_exposed_symbol = true;\n-\t  bitmap_set_bit (vars_to_rename, var_ann (val)->uid);\n-\t}\n-    }\n+    if (DECL_P (val))\n+      {\n+\tfound_exposed_symbol = true;\n+\tmark_sym_for_renaming (val);\n+      }\n \n   /* If we found any newly exposed symbols, or if there are fewer VDEF\n      operands in the statement, add the variables we had set in\n@@ -676,7 +675,7 @@ mark_new_vars_to_rename (tree stmt, bitmap vars_to_rename)\n   if (found_exposed_symbol\n       || v_may_defs_before > v_may_defs_after\n       || v_must_defs_before > v_must_defs_after)\n-    bitmap_ior_into (vars_to_rename, vars_in_vops_to_rename);\n+    mark_set_for_renaming (vars_in_vops_to_rename);\n \n   BITMAP_FREE (vars_in_vops_to_rename);\n }\n@@ -691,7 +690,10 @@ find_new_referenced_vars_1 (tree *tp, int *walk_subtrees,\n   tree t = *tp;\n \n   if (TREE_CODE (t) == VAR_DECL && !var_ann (t))\n-    add_referenced_tmp_var (t);\n+    {\n+      add_referenced_tmp_var (t);\n+      mark_sym_for_renaming (t);\n+    }\n \n   if (IS_TYPE_OR_DECL_P (t))\n     *walk_subtrees = 0;\n@@ -706,20 +708,6 @@ find_new_referenced_vars (tree *stmt_p)\n }\n \n \n-/* Mark all call-clobbered variables for renaming.  */\n-\n-void\n-mark_call_clobbered_vars_to_rename (void)\n-{\n-  unsigned i;\n-  bitmap_iterator bi;\n-  EXECUTE_IF_SET_IN_BITMAP (call_clobbered_vars, 0, i, bi)\n-    {\n-      tree var = referenced_var (i);\n-      bitmap_set_bit (vars_to_rename, var_ann (var)->uid);\n-    }\n-}\n-\n /* If REF is a COMPONENT_REF for a structure that can have sub-variables, and\n    we know where REF is accessing, return the variable in REF that has the\n    sub-variables.  If the return value is not NULL, POFFSET will be the"}, {"sha": "993c1ded320e8a57ba921dd6a40bf7f7c5dbe764", "filename": "gcc/tree-flow-inline.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftree-flow-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftree-flow-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow-inline.h?ref=0bca51f080dfff5e943b1f1775d874a73bbc441a", "patch": "@@ -1176,6 +1176,17 @@ op_iter_init_maydef (ssa_op_iter *ptr, tree stmt, use_operand_p *use,\n   op_iter_next_maydef (use, def, ptr);\n }\n \n+/* Return true if VAR cannot be modified by the program.  */\n+\n+static inline bool\n+unmodifiable_var_p (tree var)\n+{\n+  if (TREE_CODE (var) == SSA_NAME)\n+    var = SSA_NAME_VAR (var);\n+  return TREE_READONLY (var) && (TREE_STATIC (var) || DECL_EXTERNAL (var));\n+}\n+\n+\n /* Initialize iterator PTR to the operands in STMT.  Return the first operands\n    in KILL and DEF.  */\n static inline void"}, {"sha": "eaaa32dc42625b3baefbee4591537735d5dd9b51", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 55, "deletions": 6, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=0bca51f080dfff5e943b1f1775d874a73bbc441a", "patch": "@@ -80,6 +80,34 @@ struct ptr_info_def GTY(())\n };\n \n \n+/* Types of value ranges.  */\n+enum value_range_type { VR_UNDEFINED, VR_RANGE, VR_ANTI_RANGE, VR_VARYING };\n+\n+\n+/* Ranges of values that can be associated with an SSA_NAME after VRP\n+   has executed.  */\n+struct value_range_def GTY(())\n+{\n+  /* Lattice value represented by this range.  */\n+  enum value_range_type type;\n+\n+  /* Minimum and maximum values represented by this range.  These\n+     values are _CST nodes that should be interpreted as follows:\n+\n+     \t- If TYPE == VR_UNDEFINED then MIN and MAX must be NULL.\n+\n+\t- If TYPE == VR_RANGE then MIN holds the minimum value and\n+\t  MAX holds the maximum value of the range [MIN, MAX].\n+\n+\t- If TYPE == ANTI_RANGE the variable is known to NOT\n+\t  take any values in the range [MIN, MAX].  */\n+  tree min;\n+  tree max;\n+};\n+\n+typedef struct value_range_def value_range;\n+\n+\n /*---------------------------------------------------------------------------\n \t\t   Tree annotations stored in tree_common.ann\n ---------------------------------------------------------------------------*/\n@@ -534,7 +562,7 @@ extern tree create_phi_node (tree, basic_block);\n extern void add_phi_arg (tree, tree, edge);\n extern void remove_phi_args (edge);\n extern void remove_phi_node (tree, tree);\n-extern void remove_all_phi_nodes_for (bitmap);\n+extern tree find_phi_node_for (basic_block, tree, tree *);\n extern tree phi_reverse (tree);\n extern void dump_dfa_stats (FILE *);\n extern void debug_dfa_stats (void);\n@@ -544,9 +572,8 @@ extern void dump_variable (FILE *, tree);\n extern void debug_variable (tree);\n extern tree get_virtual_var (tree);\n extern void add_referenced_tmp_var (tree);\n-extern void mark_new_vars_to_rename (tree, bitmap);\n+extern void mark_new_vars_to_rename (tree);\n extern void find_new_referenced_vars (tree *);\n-void mark_call_clobbered_vars_to_rename (void);\n \n extern tree make_rename_temp (tree, const char *);\n \n@@ -568,6 +595,8 @@ extern void dump_points_to_info_for (FILE *, tree);\n extern void debug_points_to_info_for (tree);\n extern bool may_be_aliased (tree);\n extern struct ptr_info_def *get_ptr_info (tree);\n+extern void add_type_alias (tree, tree);\n+extern void count_uses_and_derefs (tree, tree, unsigned *, unsigned *, bool *);\n static inline subvar_t get_subvars_for_var (tree);\n static inline bool ref_contains_array_ref (tree);\n extern tree okay_component_ref_for_subvars (tree, HOST_WIDE_INT *,\n@@ -596,24 +625,43 @@ extern void verify_ssa (bool);\n extern void delete_tree_ssa (void);\n extern void register_new_def (tree, VEC (tree_on_heap) **);\n extern void walk_use_def_chains (tree, walk_use_def_chains_fn, void *, bool);\n-extern void kill_redundant_phi_nodes (void);\n extern bool stmt_references_memory_p (tree);\n \n /* In tree-into-ssa.c  */\n-extern void rewrite_into_ssa (bool);\n extern void rewrite_ssa_into_ssa (void);\n-extern void rewrite_def_def_chains (void);\n \n+void update_ssa (unsigned);\n+void register_new_name_mapping (tree, tree);\n+tree create_new_def_for (tree, tree, def_operand_p);\n+bool need_ssa_update_p (void);\n+bool name_registered_for_update_p (tree);\n+bitmap ssa_names_to_replace (void);\n+void release_ssa_name_after_update_ssa (tree name);\n+void dump_repl_tbl (FILE *);\n+void debug_repl_tbl (void);\n+void dump_names_replaced_by (FILE *, tree);\n+void debug_names_replaced_by (tree);\n void compute_global_livein (bitmap, bitmap);\n tree duplicate_ssa_name (tree, tree);\n+void mark_sym_for_renaming (tree);\n+void mark_set_for_renaming (bitmap);\n \n /* In tree-ssa-ccp.c  */\n bool fold_stmt (tree *);\n tree widen_bitfield (tree, tree, tree);\n \n+/* In tree-vrp.c  */\n+value_range *get_value_range (tree);\n+void dump_value_range (FILE *, value_range *);\n+void debug_value_range (value_range *);\n+void dump_all_value_ranges (FILE *);\n+void debug_all_value_ranges (void);\n+bool expr_computes_nonzero (tree);\n+\n /* In tree-ssa-dom.c  */\n extern void dump_dominator_optimization_stats (FILE *);\n extern void debug_dominator_optimization_stats (void);\n+int loop_depth_of_name (tree);\n \n /* In tree-ssa-copy.c  */\n extern void propagate_value (use_operand_p, tree);\n@@ -711,6 +759,7 @@ extern enum move_pos movement_possibility (tree);\n static inline bool is_call_clobbered (tree);\n static inline void mark_call_clobbered (tree);\n static inline void set_is_used (tree);\n+static inline bool unmodifiable_var_p (tree);\n \n /* In tree-eh.c  */\n extern void make_eh_edges (tree);"}, {"sha": "e723b47217785948664b37756061f8a850318cd1", "filename": "gcc/tree-gimple.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftree-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftree-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-gimple.c?ref=0bca51f080dfff5e943b1f1775d874a73bbc441a", "patch": "@@ -73,6 +73,7 @@ is_gimple_formal_tmp_rhs (tree t)\n     case COMPLEX_CST:\n     case VECTOR_CST:\n     case OBJ_TYPE_REF:\n+    case ASSERT_EXPR:\n       return true;\n \n     default:"}, {"sha": "e63dc669df29df87a332b2e60c8cf47d2281a9f7", "filename": "gcc/tree-if-conv.c", "status": "modified", "additions": 30, "deletions": 21, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftree-if-conv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftree-if-conv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-if-conv.c?ref=0bca51f080dfff5e943b1f1775d874a73bbc441a", "patch": "@@ -117,7 +117,8 @@ static void add_to_predicate_list (basic_block, tree);\n static tree add_to_dst_predicate_list (struct loop * loop, basic_block, tree, tree,\n \t\t\t\t       block_stmt_iterator *);\n static void clean_predicate_lists (struct loop *loop);\n-static basic_block find_phi_replacement_condition (basic_block, tree *,\n+static basic_block find_phi_replacement_condition (struct loop *loop,\n+\t\t\t\t\t\t   basic_block, tree *,\n \t\t\t\t\t\t   block_stmt_iterator *);\n static void replace_phi_with_cond_modify_expr (tree, tree, basic_block,\n                                                block_stmt_iterator *);\n@@ -677,7 +678,8 @@ clean_predicate_lists (struct loop *loop)\n    whose phi arguments are selected when cond is true.  */\n \n static basic_block\n-find_phi_replacement_condition (basic_block bb, tree *cond,\n+find_phi_replacement_condition (struct loop *loop, \n+\t\t\t\tbasic_block bb, tree *cond,\n                                 block_stmt_iterator *bsi)\n {\n   edge e;\n@@ -702,12 +704,22 @@ find_phi_replacement_condition (basic_block bb, tree *cond,\n   tmp_cond = p1->aux;\n   if (TREE_CODE (tmp_cond) == TRUTH_NOT_EXPR)\n     {\n-      *cond  = p2->aux;\n+      /* If p2 is loop->header than its aux field does not have useful\n+\t info. Instead use !(cond) where cond is p1's aux field.  */\n+      if (p2 == loop->header)\n+\t*cond = invert_truthvalue (unshare_expr (p1->aux));\n+      else\n+\t*cond  = p2->aux;\n       true_bb = p2;\n     }\n   else\n     {\n-      *cond  = p1->aux;\n+      /* If p1 is loop->header than its aux field does not have useful\n+\t info. Instead use !(cond) where cond is p2's aux field.  */\n+      if (p1 == loop->header)\n+\t*cond = invert_truthvalue (unshare_expr (p2->aux));\n+      else\n+\t*cond  = p1->aux;\n       true_bb = p1;\n     }\n \n@@ -828,7 +840,7 @@ process_phi_nodes (struct loop *loop)\n       /* BB has two predecessors. Using predecessor's aux field, set\n \t appropriate condition for the PHI node replacement.  */\n       if (phi)\n-\ttrue_bb = find_phi_replacement_condition (bb, &cond, &bsi);\n+\ttrue_bb = find_phi_replacement_condition (loop, bb, &cond, &bsi);\n \n       while (phi)\n \t{\n@@ -1113,20 +1125,17 @@ gate_tree_if_conversion (void)\n \n struct tree_opt_pass pass_if_conversion =\n {\n-  \"ifcvt\",                           /* name */\n-  gate_tree_if_conversion,           /* gate */\n-  main_tree_if_conversion,           /* execute */\n-  NULL,                              /* sub */\n-  NULL,                              /* next */\n-  0,                                 /* static_pass_number */\n-  0,                                 /* tv_id */\n-  PROP_cfg | PROP_ssa | PROP_alias,  /* properties_required */\n-  0,                                 /* properties_provided */\n-  0,                                 /* properties_destroyed */\n-  TODO_dump_func,                    /* todo_flags_start */\n-  TODO_dump_func\n-    | TODO_verify_ssa\n-    | TODO_verify_stmts\n-    | TODO_verify_flow,              /* todo_flags_finish */\n-  0\t\t\t\t     /* letter */\n+  \"ifcvt\",\t\t\t\t/* name */\n+  gate_tree_if_conversion,\t\t/* gate */\n+  main_tree_if_conversion,\t\t/* execute */\n+  NULL,\t\t\t\t\t/* sub */\n+  NULL,\t\t\t\t\t/* next */\n+  0,\t\t\t\t\t/* static_pass_number */\n+  0,\t\t\t\t\t/* tv_id */\n+  PROP_cfg | PROP_ssa | PROP_alias,\t/* properties_required */\n+  0,\t\t\t\t\t/* properties_provided */\n+  0,\t\t\t\t\t/* properties_destroyed */\n+  0,\t\t\t\t\t/* todo_flags_start */\n+  TODO_dump_func | TODO_verify_loops,\t/* todo_flags_finish */\n+  0\t\t\t\t\t/* letter */\n };"}, {"sha": "f15b5ef48adb0a3567ea2154d540149d25844a37", "filename": "gcc/tree-into-ssa.c", "status": "modified", "additions": 1823, "deletions": 363, "changes": 2186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftree-into-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftree-into-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-into-ssa.c?ref=0bca51f080dfff5e943b1f1775d874a73bbc441a", "patch": "@@ -84,50 +84,95 @@ struct def_blocks_d\n static htab_t def_blocks;\n \n /* Stack of trees used to restore the global currdefs to its original\n-   state after completing rewriting of a block and its dominator children.\n+   state after completing rewriting of a block and its dominator\n+   children.  Its elements have the following properties:\n \n-   This vector is used in two contexts.  The first is rewriting of _DECL\n-   nodes into SSA_NAMEs.  In that context its elements have the\n-   following properties:\n+   - An SSA_NAME indicates that the current definition of the\n+     underlying variable should be set to the given SSA_NAME.\n \n-     An SSA_NAME indicates that the current definition of the underlying\n-     variable should be set to the given SSA_NAME.\n+   - A _DECL node indicates that the underlying variable has no\n+     current definition.\n \n-     A _DECL node indicates that the underlying variable has no current\n-     definition.\n+   - A NULL node is used to mark the last node associated with the\n+     current block.\n \n-     A NULL node is used to mark the last node associated with the\n-     current block. \n-\n-   This vector is also used when rewriting an SSA_NAME which has multiple\n-   definition sites into multiple SSA_NAMEs.  In that context entries come\n-   in pairs.\n-\n-     The top entry is an SSA_NAME and the top-1 entry is the\n-     current value for that SSA_NAME. \n-\n-     A NULL node at the top entry is used to mark the last node associated\n-     with the current block.  */\n+   - A NULL node at the top entry is used to mark the last node\n+     associated with the current block.  */\n static VEC(tree_on_heap) *block_defs_stack;\n \n /* Basic block vectors used in this file ought to be allocated in the heap.  */\n DEF_VEC_MALLOC_P(int);\n \n+/* Set of existing SSA names being replaced by update_ssa.  */\n+static sbitmap old_ssa_names;\n+\n+/* Set of new SSA names being added by update_ssa.  Note that both\n+   NEW_SSA_NAMES and OLD_SSA_NAMES are dense bitmaps because most of\n+   the operations done on them are presence tests.  */\n+static sbitmap new_ssa_names;\n+\n+/* Set of virtual SSA names to be updated.  Since virtuals are always\n+   in FUD chain form, these names are not used as a mapping mechanism\n+   like OLD_SSA_NAMES and NEW_SSA_NAMES.  Instead, the names in this\n+   set are used by ssa_names_to_replace to inform its caller which\n+   names are going to be updated.  */\n+static bitmap old_virtual_ssa_names;\n+\n+/* Symbols whose SSA form needs to be updated or created for the first\n+   time.  */\n+static bitmap syms_to_rename;\n+\n+/* Set of SSA names that have been marked to be released after they\n+   were registered in the replacement table.  They will be finally\n+   released after we finish updating the SSA web.  */\n+static bitmap names_to_release;\n+\n+/* Growth factor for NEW_SSA_NAMES and OLD_SSA_NAMES.  These sets need\n+   to grow as the callers to register_new_name_mapping will typically\n+   create new names on the fly.  FIXME.  Currently set to 1/3 to avoid\n+   frequent reallocations but still need to find a reasonable growth\n+   strategy.  */\n+#define NAME_SETS_GROWTH_FACTOR\t(MAX (3, num_ssa_names / 3))\n+\n+/* Tuple used to represent replacement mappings.  */\n+struct repl_map_d\n+{\n+  tree name;\n+  bitmap set;\n+};\n+\n+/* NEW -> OLD_SET replacement table.  If we are replacing several\n+   existing SSA names O_1, O_2, ..., O_j with a new name N_i,\n+   then REPL_TBL[N_i] = { O_1, O_2, ..., O_j }.  */\n+static htab_t repl_tbl;\n+\n+/* true if register_new_name_mapping needs to initialize the data\n+   structures needed by update_ssa.  */\n+static bool need_to_initialize_update_ssa_p = true;\n+\n+/* true if update_ssa needs to update virtual operands.  */\n+static bool need_to_update_vops_p = false;\n+\n+/* true if update_ssa is replacing existing SSA names.  */\n+static bool need_to_replace_names_p = false;\n+\n /* Global data to attach to the main dominator walk structure.  */\n struct mark_def_sites_global_data\n {\n-  /* This sbitmap contains the variables which are set before they\n-     are used in a basic block.  We keep it as a global variable\n-     solely to avoid the overhead of allocating and deallocating\n-     the bitmap.  */\n+  /* This bitmap contains the variables which are set before they\n+     are used in a basic block.  */\n   bitmap kills;\n \n   /* Bitmap of names to rename.  */\n   sbitmap names_to_rename;\n+\n+  /* Set of blocks that mark_def_sites deems interesting for the\n+     renamer to process.  */\n+  sbitmap interesting_blocks;\n };\n \n \n-/* Information stored for ssa names.  */\n+/* Information stored for SSA names.  */\n struct ssa_name_info\n {\n   /* This field indicates whether or not the variable may need PHI nodes.\n@@ -140,11 +185,36 @@ struct ssa_name_info\n };\n \n \n+/* The main entry point to the SSA renamer (rewrite_blocks) may be\n+   called several times to do different, but related, tasks.\n+   Initially, we need it to rename the whole program into SSA form.\n+   At other times, we may need it to only rename into SSA newly\n+   exposed symbols.  Finally, we can also call it to incrementally fix\n+   an already built SSA web.  */\n+enum rewrite_mode {\n+    /* Convert the whole function into SSA form.  */\n+    REWRITE_ALL,\n+\n+    /* Incrementally update the SSA web by replacing existing SSA\n+       names with new ones.  See update_ssa for details.  */\n+    REWRITE_UPDATE\n+};\n+\n+\n /* Use TREE_VISITED to keep track of which statements we want to\n    rename.  When renaming a subset of the variables, not all\n    statements will be processed.  This is decided in mark_def_sites.  */\n #define REWRITE_THIS_STMT(T)\tTREE_VISITED (T)\n \n+/* Use the unsigned flag to keep track of which statements we want to\n+   visit when marking new definition sites.  This is slightly\n+   different than REWRITE_THIS_STMT: it's used by update_ssa to\n+   distinguish statements that need to have both uses and defs\n+   processed from those that only need to have their defs processed.\n+   Statements that define new SSA names only need to have their defs\n+   registered, but they don't need to have their uses renamed.  */\n+#define REGISTER_DEFS_IN_THIS_STMT(T)\t(T)->common.unsigned_flag\n+\n \n /* Get the information associated with NAME.  */\n \n@@ -222,7 +292,7 @@ compute_global_livein (bitmap livein, bitmap def_blocks)\n   bitmap_iterator bi;\n \n   tos = worklist\n-    = (basic_block *) xmalloc (sizeof (basic_block) * (n_basic_blocks + 1));\n+    = (basic_block *) xmalloc (sizeof (basic_block) * (last_basic_block + 1));\n \n   EXECUTE_IF_SET_IN_BITMAP (livein, 0, i, bi)\n     {\n@@ -288,18 +358,14 @@ get_def_blocks_for (tree var)\n \n \n /* Mark block BB as the definition site for variable VAR.  PHI_P is true if\n-   VAR is defined by a PHI node.  IS_UPDATE is true if the caller is\n-   updating an existing SSA form.  */\n+   VAR is defined by a PHI node.  */\n \n static void\n-set_def_block (tree var, basic_block bb, bool phi_p, bool is_update)\n+set_def_block (tree var, basic_block bb, bool phi_p)\n {\n   struct def_blocks_d *db_p;\n   enum need_phi_state state;\n \n-  if (!is_update && TREE_CODE (var) == SSA_NAME)\n-    var = SSA_NAME_VAR (var);\n-\n   state = get_phi_state (var);\n   db_p = get_def_blocks_for (var);\n \n@@ -360,50 +426,170 @@ set_livein_block (tree var, basic_block bb)\n }\n \n \n-/* If the use operand pointed to by OP_P needs to be renamed, then strip away \n-   any SSA_NAME wrapping the operand, set *UID_P to the underlying variable's \n-   uid, and return true.  Otherwise return false.  If the operand was an \n-   SSA_NAME, change it to the stripped name.  */\n+/* Return true if symbol SYM is marked for renaming.  */\n \n-static bool\n-prepare_use_operand_for_rename (use_operand_p op_p, size_t *uid_p)\n+static inline bool\n+symbol_marked_for_renaming (tree sym)\n {\n-  tree use = USE_FROM_PTR (op_p);\n-  tree var = (TREE_CODE (use) != SSA_NAME) ? use : SSA_NAME_VAR (use);\n-  *uid_p = var_ann (var)->uid;\n+  gcc_assert (DECL_P (sym));\n+  return bitmap_bit_p (syms_to_rename, var_ann (sym)->uid);\n+}\n+\n+\n+/* Return true if NAME is in OLD_SSA_NAMES.  */\n \n-  /* Ignore variables that don't need to be renamed.  */\n-  if (vars_to_rename && !bitmap_bit_p (vars_to_rename, *uid_p))\n+static inline bool\n+is_old_name (tree name)\n+{\n+  if (!need_to_replace_names_p)\n     return false;\n \n-  /* The variable needs to be renamed.  If this is a use which already\n-     has an SSA_NAME, then strip it off.\n+  return TEST_BIT (old_ssa_names, SSA_NAME_VERSION (name));\n+}\n+\n+\n+/* Return true if NAME is in NEW_SSA_NAMES.  */\n \n-     By not throwing away SSA_NAMEs on assignments, we avoid a lot of \n-     useless churn of SSA_NAMEs without having to overly complicate the\n-     renamer.  */\n-  if (TREE_CODE (use) == SSA_NAME)\n-    SET_USE (op_p, var);\n+static inline bool\n+is_new_name (tree name)\n+{\n+  if (!need_to_replace_names_p)\n+    return false;\n \n-  return true;\n+  return TEST_BIT (new_ssa_names, SSA_NAME_VERSION (name));\n }\n \n \n-/* If the def variable DEF needs to be renamed, then strip away any SSA_NAME \n-   wrapping the operand, set *UID_P to the underlying variable's uid and return\n-   true.  Otherwise return false.  */\n+/* Hashing and equality functions for REPL_TBL.  */\n \n-static bool\n-prepare_def_operand_for_rename (tree def, size_t *uid_p)\n+static hashval_t\n+repl_map_hash (const void *p)\n {\n-  tree var = (TREE_CODE (def) != SSA_NAME) ? def : SSA_NAME_VAR (def);\n-  *uid_p = var_ann (var)->uid;\n+  return htab_hash_pointer ((const void *)((const struct repl_map_d *)p)->name);\n+}\n \n-  /* Ignore variables that don't need to be renamed.  */\n-  if (vars_to_rename && !bitmap_bit_p (vars_to_rename, *uid_p))\n-    return false;\n+static int\n+repl_map_eq (const void *p1, const void *p2)\n+{\n+  return ((const struct repl_map_d *)p1)->name\n+\t == ((const struct repl_map_d *)p2)->name;\n+}\n+\n+static void\n+repl_map_free (void *p)\n+{\n+  BITMAP_FREE (((struct repl_map_d *)p)->set);\n+  free (p);\n+}\n+\n+\n+/* Return the names replaced by NEW (i.e., REPL_TBL[NEW].SET).  */\n+\n+static inline bitmap\n+names_replaced_by (tree new)\n+{\n+  struct repl_map_d m;\n+  void **slot;\n+\n+  m.name = new;\n+  slot = htab_find_slot (repl_tbl, (void *) &m, NO_INSERT);\n+\n+  /* If N was not registered in the replacement table, return NULL.  */\n+  if (slot == NULL || *slot == NULL)\n+    return NULL;\n+\n+  return ((struct repl_map_d *) *slot)->set;\n+}\n+\n+\n+/* Add OLD to REPL_TBL[NEW].SET.  */\n+\n+static inline void\n+add_to_repl_tbl (tree new, tree old)\n+{\n+  struct repl_map_d m, *mp;\n+  void **slot;\n+\n+  m.name = new;\n+  slot = htab_find_slot (repl_tbl, (void *) &m, INSERT);\n+  if (*slot == NULL)\n+    {\n+      mp = xmalloc (sizeof (*mp));\n+      mp->name = new;\n+      mp->set = BITMAP_ALLOC (NULL);\n+      *slot = (void *) mp;\n+    }\n+  else\n+    mp = (struct repl_map_d *) *slot;\n+\n+  bitmap_set_bit (mp->set, SSA_NAME_VERSION (old));\n+}\n+\n+\n+/* Add a new mapping NEW -> OLD REPL_TBL.  Every entry N_i in REPL_TBL\n+   represents the set of names O_1 ... O_j replaced by N_i.  This is\n+   used by update_ssa and its helpers to introduce new SSA names in an\n+   already formed SSA web.  */\n+\n+static void\n+add_new_name_mapping (tree new, tree old)\n+{\n+  timevar_push (TV_TREE_SSA_INCREMENTAL);\n+\n+  /* We may need to grow NEW_SSA_NAMES and OLD_SSA_NAMES because our\n+     caller may have created new names since the set was created.  */\n+  if (new_ssa_names->n_bits <= num_ssa_names - 1)\n+    {\n+      unsigned int new_sz = num_ssa_names + NAME_SETS_GROWTH_FACTOR;\n+      new_ssa_names = sbitmap_resize (new_ssa_names, new_sz, 0);\n+      old_ssa_names = sbitmap_resize (old_ssa_names, new_sz, 0);\n+    }\n+\n+  /* We don't need to keep replacement mappings for virtual names.\n+     Since these names are kept in FUD-chain form, we need to traverse\n+     the CFG from ENTRY to repair FUD chains.  */\n+  if (!is_gimple_reg (new))\n+    {\n+      tree sym;\n+\n+      gcc_assert (!is_gimple_reg (old));\n+\n+      if (DECL_P (old))\n+\tsym = new;\n+      else\n+\t{\n+\t  sym = SSA_NAME_VAR (old);\n+\t  bitmap_set_bit (old_virtual_ssa_names, SSA_NAME_VERSION (old));\n+\t}\n+\n+      mark_sym_for_renaming (sym);\n+      need_to_update_vops_p = true;\n+\n+      timevar_pop (TV_TREE_SSA_INCREMENTAL);\n+\n+      return;\n+    }\n+\n+  /* Assume that OLD and NEW are different GIMPLE register names.  */\n+  gcc_assert (new != old && is_gimple_reg (old));\n+\n+  /* Update the REPL_TBL table.  */\n+  add_to_repl_tbl (new, old);\n \n-  return true;\n+  /* If OLD had already been registered as a new name, then all the\n+     names that OLD replaces should also be replaced by NEW.  */\n+  if (is_new_name (old))\n+    bitmap_ior_into (names_replaced_by (new), names_replaced_by (old));\n+\n+  /* Register NEW and OLD in NEW_SSA_NAMES and OLD_SSA_NAMES,\n+     respectively.  */\n+  SET_BIT (new_ssa_names, SSA_NAME_VERSION (new));\n+  SET_BIT (old_ssa_names, SSA_NAME_VERSION (old));\n+\n+  /* Indicate that we are going to be replacing existing names.  */\n+  need_to_replace_names_p = true;\n+\n+  timevar_pop (TV_TREE_SSA_INCREMENTAL);\n }\n \n \n@@ -429,31 +615,27 @@ mark_def_sites (struct dom_walk_data *walk_data,\n {\n   struct mark_def_sites_global_data *gd = walk_data->global_data;\n   bitmap kills = gd->kills;\n-  size_t uid;\n   tree stmt, def;\n   use_operand_p use_p;\n   def_operand_p def_p;\n   ssa_op_iter iter;\n \n-  /* Mark all the blocks that have definitions for each variable in the\n-     VARS_TO_RENAME bitmap.  */\n   stmt = bsi_stmt (bsi);\n   update_stmt_if_modified (stmt);\n \n+  REGISTER_DEFS_IN_THIS_STMT (stmt) = 0;\n   REWRITE_THIS_STMT (stmt) = 0;\n \n   /* If a variable is used before being set, then the variable is live\n      across a block boundary, so mark it live-on-entry to BB.  */\n-\n   FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter,\n \t\t\t    SSA_OP_USE | SSA_OP_VUSE | SSA_OP_VMUSTDEFKILL)\n     {\n-      if (prepare_use_operand_for_rename (use_p, &uid))\n-\t{\n-\t  REWRITE_THIS_STMT (stmt) = 1;\n-\t  if (!bitmap_bit_p (kills, uid))\n-\t    set_livein_block (USE_FROM_PTR (use_p), bb);\n-\t}\n+      tree sym = USE_FROM_PTR (use_p);\n+      gcc_assert (DECL_P (sym));\n+      if (!bitmap_bit_p (kills, var_ann (sym)->uid))\n+\tset_livein_block (sym, bb);\n+      REWRITE_THIS_STMT (stmt) = 1;\n     }\n   \n   /* Note that virtual definitions are irrelevant for computing KILLS\n@@ -463,29 +645,27 @@ mark_def_sites (struct dom_walk_data *walk_data,\n      live-on-entry.  */\n   FOR_EACH_SSA_MAYDEF_OPERAND (def_p, use_p, stmt, iter)\n     {\n-      if (prepare_use_operand_for_rename (use_p, &uid))\n-\t{\n-\t  /* If we do not already have an SSA_NAME for our destination,\n-\t     then set the destination to the source.  */\n-\t  if (TREE_CODE (DEF_FROM_PTR (def_p)) != SSA_NAME)\n-\t    SET_DEF (def_p, USE_FROM_PTR (use_p));\n-\t    \n-          set_livein_block (USE_FROM_PTR (use_p), bb);\n-\t  set_def_block (DEF_FROM_PTR (def_p), bb, false, false);\n-\t  REWRITE_THIS_STMT (stmt) = 1;\n-\t}\n+      tree sym = USE_FROM_PTR (use_p);\n+      gcc_assert (DECL_P (sym));\n+      set_livein_block (sym, bb);\n+      set_def_block (sym, bb, false);\n+      REGISTER_DEFS_IN_THIS_STMT (stmt) = 1;\n+      REWRITE_THIS_STMT (stmt) = 1;\n     }\n \n   /* Now process the defs and must-defs made by this statement.  */\n   FOR_EACH_SSA_TREE_OPERAND (def, stmt, iter, SSA_OP_DEF | SSA_OP_VMUSTDEF)\n     {\n-      if (prepare_def_operand_for_rename (def, &uid))\n-\t{\n-\t  set_def_block (def, bb, false, false);\n-\t  bitmap_set_bit (kills, uid);\n-\t  REWRITE_THIS_STMT (stmt) = 1;\n-\t}\n+      gcc_assert (DECL_P (def));\n+      set_def_block (def, bb, false);\n+      bitmap_set_bit (kills, var_ann (def)->uid);\n+      REGISTER_DEFS_IN_THIS_STMT (stmt) = 1;\n     }\n+\n+  /* If we found the statement interesting then also mark the block BB\n+     as interesting.  */\n+  if (REWRITE_THIS_STMT (stmt) || REGISTER_DEFS_IN_THIS_STMT (stmt))\n+    SET_BIT (gd->interesting_blocks, bb->index);\n }\n \n \n@@ -525,9 +705,16 @@ find_idf (bitmap def_blocks, bitmap *dfs)\n   while (VEC_length (int, work_stack) > 0)\n     {\n       bb_index = VEC_pop (int, work_stack);\n-      \n+\n+      /* Since the registration of NEW -> OLD name mappings is done\n+\t separately from the call to update_ssa, when updating the SSA\n+\t form, the basic blocks where new and/or old names are defined\n+\t may have disappeared by CFG cleanup calls.  In this case,\n+\t we may pull a non-existing block from the work stack.  */\n+      gcc_assert (bb_index < (unsigned) last_basic_block);\n+\n       EXECUTE_IF_AND_COMPL_IN_BITMAP (dfs[bb_index], phi_insertion_points,\n-\t\t\t\t      0, bb_index, bi)\n+\t                              0, bb_index, bi)\n \t{\n \t  /* Use a safe push because if there is a definition of VAR\n \t     in every basic block, then WORK_STACK may eventually have\n@@ -556,11 +743,36 @@ find_def_blocks_for (tree var)\n }\n \n \n+/* Retrieve or create a default definition for symbol SYM.  */\n+\n+static inline tree\n+get_default_def_for (tree sym)\n+{\n+  tree ddef = default_def (sym);\n+\n+  if (ddef == NULL_TREE)\n+    {\n+      ddef = make_ssa_name (sym, build_empty_stmt ());\n+      set_default_def (sym, ddef);\n+    }\n+\n+  return ddef;\n+}\n+\n+\n /* Insert PHI nodes for variable VAR using the iterated dominance\n-   frontier given in PHI_INSERTION_POINTS.  */\n+   frontier given in PHI_INSERTION_POINTS.  If UPDATE_P is true, this\n+   function assumes that the caller is incrementally updating the SSA\n+   form, in which case (1) VAR is assumed to be an SSA name, (2) a new\n+   SSA name is created for VAR's symbol, and, (3) all the arguments\n+   for the newly created PHI node are set to VAR.\n+\n+   PHI_INSERTION_POINTS is updated to reflect nodes that already had a\n+   PHI node for VAR.  On exit, only the nodes that received a PHI node\n+   for VAR will be present in PHI_INSERTION_POINTS.  */\n \n static void\n-insert_phi_nodes_for (tree var, bitmap phi_insertion_points)\n+insert_phi_nodes_for (tree var, bitmap phi_insertion_points, bool update_p)\n {\n   unsigned bb_index;\n   edge e;\n@@ -570,6 +782,7 @@ insert_phi_nodes_for (tree var, bitmap phi_insertion_points)\n   struct def_blocks_d *def_map;\n \n   def_map = find_def_blocks_for (var);\n+  gcc_assert (def_map);\n \n   /* Remove the blocks where we already have PHI nodes for VAR.  */\n   bitmap_and_compl_into (phi_insertion_points, def_map->phi_blocks);\n@@ -585,13 +798,36 @@ insert_phi_nodes_for (tree var, bitmap phi_insertion_points)\n       bb = BASIC_BLOCK (bb_index);\n       phi = create_phi_node (var, bb);\n \n-      /* If we are rewriting SSA names, add also the PHI arguments.  */\n       if (TREE_CODE (var) == SSA_NAME)\n \t{\n \t  edge_iterator ei;\n+\n+\t  /* FIXME.  After removing rewrite_ssa_into_ssa, change this\n+\t     if() to gcc_assert().  */\n+\t  if (update_p)\n+\t    {\n+\t      /* If we are rewriting SSA names, create the LHS of the\n+\t\t PHI node by duplicating VAR.  This is useful in the\n+\t\t case of pointers, to also duplicate pointer\n+\t\t attributes (alias information, in particular).  */\n+\t      tree new_lhs = duplicate_ssa_name (var, phi);\n+\t      SET_PHI_RESULT (phi, new_lhs);\n+\t      add_new_name_mapping (new_lhs, var);\n+\t    }\n+\n+\t  /* Add VAR to every argument slot of PHI.  We need VAR in\n+\t     every argument so that rewrite_update_phi_arguments knows\n+\t     which name is this PHI node replacing.  If VAR is a\n+\t     symbol marked for renaming, this is not necessary, the\n+\t     renamer will use the symbol on the LHS to get its\n+\t     reaching definition.  */\n \t  FOR_EACH_EDGE (e, ei, bb->preds)\n \t    add_phi_arg (phi, var, e);\n \t}\n+\n+      /* Mark this PHI node as interesting for update_ssa.  */\n+      REGISTER_DEFS_IN_THIS_STMT (phi) = 1;\n+      REWRITE_THIS_STMT (phi) = 1;\n     }\n }\n \n@@ -609,12 +845,12 @@ insert_phi_nodes_1 (tree var, bitmap *dfs)\n   if (def_map == NULL)\n     return;\n \n-  idf = find_idf (def_map->def_blocks, dfs);\n-\n   if (get_phi_state (var) != NEED_PHI_STATE_NO)\n-    insert_phi_nodes_for (var, idf);\n-\n-  BITMAP_FREE (idf);\n+    {\n+      idf = find_idf (def_map->def_blocks, dfs);\n+      insert_phi_nodes_for (var, idf, false);\n+      BITMAP_FREE (idf);\n+    }\n }\n \n \n@@ -630,25 +866,17 @@ static void\n insert_phi_nodes (bitmap *dfs, bitmap names_to_rename)\n {\n   unsigned i;\n-  bitmap_iterator bi;\n \n   timevar_push (TV_TREE_INSERT_PHI_NODES);\n \n-  /* Iterate over all variables in VARS_TO_RENAME.  For each variable, add\n-     to the work list all the blocks that have a definition for the\n-     variable.  PHI nodes will be added to the dominance frontier blocks of\n-     each definition block.  */\n   if (names_to_rename)\n     {\n+      bitmap_iterator bi;\n+\n       EXECUTE_IF_SET_IN_BITMAP (names_to_rename, 0, i, bi)\n \tif (ssa_name (i))\n \t  insert_phi_nodes_1 (ssa_name (i), dfs);\n     }\n-  else if (vars_to_rename)\n-    {\n-      EXECUTE_IF_SET_IN_BITMAP (vars_to_rename, 0, i, bi)\n-\tinsert_phi_nodes_1 (referenced_var (i), dfs);\n-    }\n   else\n     {\n       for (i = 0; i < num_referenced_vars; i++)\n@@ -757,57 +985,23 @@ rewrite_initialize_block (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n static tree\n get_reaching_def (tree var)\n {\n-  tree default_d, currdef_var, avar;\n+  tree currdef_var, avar;\n   \n   /* Lookup the current reaching definition for VAR.  */\n-  default_d = NULL_TREE;\n   currdef_var = get_current_def (var);\n \n   /* If there is no reaching definition for VAR, create and register a\n      default definition for it (if needed).  */\n   if (currdef_var == NULL_TREE)\n     {\n-      if (TREE_CODE (var) == SSA_NAME)\n-\tavar = SSA_NAME_VAR (var);\n-      else\n-\tavar = var;\n-\n-      default_d = default_def (avar);\n-      if (default_d == NULL_TREE)\n-\t{\n-\t  default_d = make_ssa_name (avar, build_empty_stmt ());\n-\t  set_default_def (avar, default_d);\n-\t}\n-      set_current_def (var, default_d);\n+      avar = DECL_P (var) ? var : SSA_NAME_VAR (var);\n+      currdef_var = get_default_def_for (avar);\n+      set_current_def (var, currdef_var);\n     }\n \n   /* Return the current reaching definition for VAR, or the default\n      definition, if we had to create one.  */\n-  return (currdef_var) ? currdef_var : default_d;\n-}\n-\n-\n-/* Replace the operand pointed by OP_P with its immediate reaching\n-   definition.  */\n-\n-static inline void\n-rewrite_operand (use_operand_p op_p)\n-{\n-  tree var = USE_FROM_PTR (op_p);\n-  if (TREE_CODE (var) != SSA_NAME)\n-    SET_USE (op_p, get_reaching_def (var));\n-  else\n-    {\n-#if defined ENABLE_CHECKING\n-      /* If we get to this point, VAR is an SSA_NAME.  If VAR's symbol\n-\t was marked for renaming, make sure that its reaching\n-\t definition is VAR itself.  Otherwise, something has gone\n-\t wrong.  */\n-      tree sym = SSA_NAME_VAR (var);\n-      if (bitmap_bit_p (vars_to_rename, var_ann (sym)->uid))\n-\tgcc_assert (var == get_reaching_def (SSA_NAME_VAR (var)));\n-#endif\n-    }\n+  return currdef_var;\n }\n \n \n@@ -829,7 +1023,7 @@ rewrite_stmt (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n \n   /* If mark_def_sites decided that we don't need to rewrite this\n      statement, ignore it.  */\n-  if (!REWRITE_THIS_STMT (stmt))\n+  if (!REWRITE_THIS_STMT (stmt) && !REGISTER_DEFS_IN_THIS_STMT (stmt))\n     return;\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -839,22 +1033,25 @@ rewrite_stmt (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n       fprintf (dump_file, \"\\n\");\n     }\n \n-  get_stmt_operands (stmt);\n-\n   /* Step 1.  Rewrite USES and VUSES in the statement.  */\n-  FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter, SSA_OP_ALL_USES | SSA_OP_ALL_KILLS)\n-    rewrite_operand (use_p);\n+  if (REWRITE_THIS_STMT (stmt))\n+    FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter,\n+\t                      SSA_OP_ALL_USES|SSA_OP_ALL_KILLS)\n+      {\n+\ttree var = USE_FROM_PTR (use_p);\n+\tgcc_assert (DECL_P (var));\n+\tSET_USE (use_p, get_reaching_def (var));\n+      }\n \n   /* Step 2.  Register the statement's DEF and VDEF operands.  */\n-  FOR_EACH_SSA_DEF_OPERAND (def_p, stmt, iter, SSA_OP_ALL_DEFS)\n-    {\n-      if (TREE_CODE (DEF_FROM_PTR (def_p)) != SSA_NAME)\n-\tSET_DEF (def_p, make_ssa_name (DEF_FROM_PTR (def_p), stmt));\n-\n-      /* FIXME: We shouldn't be registering new defs if the variable\n-\t doesn't need to be renamed.  */\n-      register_new_def (DEF_FROM_PTR (def_p), &block_defs_stack);\n-    }\n+  if (REGISTER_DEFS_IN_THIS_STMT (stmt))\n+    FOR_EACH_SSA_DEF_OPERAND (def_p, stmt, iter, SSA_OP_ALL_DEFS)\n+      {\n+\ttree var = DEF_FROM_PTR (def_p);\n+\tgcc_assert (DECL_P (var));\n+\tSET_DEF (def_p, make_ssa_name (var, stmt));\n+\tregister_new_def (DEF_FROM_PTR (def_p), &block_defs_stack);\n+      }\n }\n \n \n@@ -877,57 +1074,13 @@ rewrite_add_phi_arguments (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n       for (phi = phi_nodes (e->dest); phi; phi = PHI_CHAIN (phi))\n \t{\n \t  tree currdef;\n-\n-\t  /* If this PHI node has already been rewritten, then there is\n-\t     nothing to do for this PHI or any following PHIs since we\n-\t     always add new PHI nodes at the start of the PHI chain.  */\n-\t  if (PHI_REWRITTEN (phi))\n-\t    break;\n-\n \t  currdef = get_reaching_def (SSA_NAME_VAR (PHI_RESULT (phi)));\n \t  add_phi_arg (phi, currdef, e);\n \t}\n     }\n }\n \n \n-/*  Rewrite existing virtual PHI arguments so that they have the correct\n-    reaching definitions.  BB is the basic block whose successors contain the\n-    PHI nodes we want to add arguments for.  */\n-\n-static void\n-rewrite_virtual_phi_arguments (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n-\t\t\t       basic_block bb)\n-{\n-  edge e;\n-  use_operand_p op;\n-  edge_iterator ei;\n-\n-  FOR_EACH_EDGE (e, ei, bb->succs)\n-    {\n-      tree phi;\n-\n-      if (e->dest == EXIT_BLOCK_PTR)\n-\tcontinue;\n-\n-      for (phi = phi_nodes (e->dest); phi; phi = PHI_CHAIN (phi))\n-\t{\n-\t  tree result = PHI_RESULT (phi);\n-\t  op = PHI_ARG_DEF_PTR_FROM_EDGE (phi, e);\n-\t  \n-\t  if (is_gimple_reg (result) \n-\t      || !bitmap_bit_p (vars_to_rename, \n-\t\t\t\tvar_ann (SSA_NAME_VAR (result))->uid))\n-\t    continue;\n-\n-\t  SET_USE (op, get_reaching_def (SSA_NAME_VAR (result)));\n-\t  if (e->flags & EDGE_ABNORMAL)\n-\t    SSA_NAME_OCCURS_IN_ABNORMAL_PHI (USE_FROM_PTR (op)) = 1;\n-\t}\n-    }\n-}\n-\n-\n /* Called after visiting basic block BB.  Restore CURRDEFS to its\n    original value.  */\n \n@@ -1084,115 +1237,402 @@ debug_def_blocks (void)\n }\n \n \n-/* If a variable V in VARS_TO_RENAME is a pointer, the renaming\n-   process will cause us to lose the name memory tags that may have\n-   been associated with the various SSA_NAMEs of V.  This means that\n-   the variables aliased to those name tags also need to be renamed\n-   again.\n+/* Register NEW_NAME to be the new reaching definition for OLD_NAME.  */\n \n-   FIXME 1- We should either have a better scheme for renaming\n-\t    pointers that doesn't lose name tags or re-run alias\n-\t    analysis to recover points-to information.\n+static inline void\n+register_new_update_single (tree new_name, tree old_name)\n+{\n+  tree currdef = get_current_def (old_name);\n \n-\t 2- Currently we just invalidate *all* the name tags.  This\n-\t    should be more selective.  */\n+  /* Push the current reaching definition into *BLOCK_DEFS_P.\n+     This stack is later used by the dominator tree callbacks to\n+     restore the reaching definitions for all the variables\n+     defined in the block after a recursive visit to all its\n+     immediately dominated blocks.  */\n+  VEC_safe_push (tree_on_heap, block_defs_stack, currdef);\n+  VEC_safe_push (tree_on_heap, block_defs_stack, old_name);\n \n-static void\n-invalidate_name_tags (bitmap vars_to_rename)\n-{\n-  unsigned i;\n-  bool rename_name_tags_p;\n-  bitmap_iterator bi;\n+  /* Set the current reaching definition for OLD_NAME to be\n+     NEW_NAME.  */\n+  set_current_def (old_name, new_name);\n+}\n \n-  rename_name_tags_p = false;\n-  EXECUTE_IF_SET_IN_BITMAP (vars_to_rename, 0, i, bi)\n-    {\n-      if (POINTER_TYPE_P (TREE_TYPE (referenced_var (i))))\n-\t{\n-\t  rename_name_tags_p = true;\n-\t  break;\n-\t}\n-    }\n \n-  if (rename_name_tags_p)\n-    for (i = 0; i < num_referenced_vars; i++)\n-      {\n-\tvar_ann_t ann = var_ann (referenced_var (i));\n+/* Register NEW_NAME to be the new reaching definition for all the\n+   names in OLD_NAMES.  Used by the incremental SSA update routines to\n+   replace old SSA names with new ones.  */\n \n-\tif (ann->mem_tag_kind == NAME_TAG)\n-\t  {\n-\t    size_t j;\n-\t    varray_type may_aliases = ann->may_aliases;\n+static inline void\n+register_new_update_set (tree new_name, bitmap old_names)\n+{\n+  bitmap_iterator bi;\n+  unsigned i;\n \n-\t    bitmap_set_bit (vars_to_rename, ann->uid);\n-\t    if (ann->may_aliases)\n-\t      for (j = 0; j < VARRAY_ACTIVE_SIZE (may_aliases); j++)\n-\t\t{\n-\t\t  tree var = VARRAY_TREE (may_aliases, j);\n-\t\t  bitmap_set_bit (vars_to_rename, var_ann (var)->uid);\n-\t\t}\n-\t  }\n-      }\n+  EXECUTE_IF_SET_IN_BITMAP (old_names, 0, i, bi)\n+    register_new_update_single (new_name, ssa_name (i));\n }\n \n \n-/* Rewrite the actual blocks, statements, and PHI arguments, to be in SSA\n-   form.  FIX_VIRTUAL_PHIS is true if we should only be fixing up virtual\n-   PHI arguments, instead of adding new PHI arguments for just added PHI\n-   nodes.  */\n+/* Initialization of block data structures for the incremental SSA\n+   update pass.  Create a block local stack of reaching definitions\n+   for new SSA names produced in this block (BLOCK_DEFS).  Register\n+   new definitions for every PHI node in the block.  */\n \n static void\n-rewrite_blocks (bool fix_virtual_phis)\n+rewrite_update_init_block (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n+\t\t           basic_block bb)\n {\n-  struct dom_walk_data walk_data;\n-  \n-  /* Rewrite all the basic blocks in the program.  */\n-  timevar_push (TV_TREE_SSA_REWRITE_BLOCKS);\n-\n-  /* Setup callbacks for the generic dominator tree walker.  */\n-  walk_data.walk_stmts_backward = false;\n-  walk_data.dom_direction = CDI_DOMINATORS;\n-  walk_data.initialize_block_local_data = NULL;\n-  walk_data.before_dom_children_before_stmts = rewrite_initialize_block;\n-  walk_data.before_dom_children_walk_stmts = rewrite_stmt;\n-  walk_data.before_dom_children_after_stmts = NULL;\n-  if (!fix_virtual_phis)\n-    walk_data.before_dom_children_after_stmts = rewrite_add_phi_arguments;\n-  else\n-    walk_data.before_dom_children_after_stmts = rewrite_virtual_phi_arguments;\n-  \n-  walk_data.after_dom_children_before_stmts =  NULL;\n-  walk_data.after_dom_children_walk_stmts =  NULL;\n-  walk_data.after_dom_children_after_stmts =  rewrite_finalize_block;\n-  walk_data.global_data = NULL;\n-  walk_data.block_local_data_size = 0;\n-\n-  block_defs_stack = VEC_alloc (tree_on_heap, 10);\n+  edge e;\n+  edge_iterator ei;\n+  tree phi;\n+  bool is_abnormal_phi;\n \n-  /* Initialize the dominator walker.  */\n-  init_walk_dominator_tree (&walk_data);\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \"\\n\\nRegistering new PHI nodes in block #%d\\n\\n\",\n+\t     bb->index);\n \n-  /* Recursively walk the dominator tree rewriting each statement in\n-     each basic block.  */\n-  walk_dominator_tree (&walk_data, ENTRY_BLOCK_PTR);\n+  /* Mark the unwind point for this block.  */\n+  VEC_safe_push (tree_on_heap, block_defs_stack, NULL_TREE);\n \n-  /* Finalize the dominator walker.  */\n-  fini_walk_dominator_tree (&walk_data);\n+  /* Mark the LHS if any of the arguments flows through an abnormal\n+     edge.  */\n+  is_abnormal_phi = false;\n+  FOR_EACH_EDGE (e, ei, bb->preds)\n+    if (e->flags & EDGE_ABNORMAL)\n+      {\n+\tis_abnormal_phi = true;\n+\tbreak;\n+      }\n \n-  /* Debugging dumps.  */\n-  if (dump_file && (dump_flags & TDF_STATS))\n+  /* If any of the PHI nodes is a replacement for a name in\n+     OLD_SSA_NAMES or it's one of the names in NEW_SSA_NAMES, then\n+     register it as a new definition for its corresponding name.  Also\n+     register definitions for names whose underlying symbols are\n+     marked for renaming.  */\n+  for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n     {\n-      dump_dfa_stats (dump_file);\n-      dump_tree_ssa_stats (dump_file);\n-    }\n+      tree lhs, lhs_sym;\n \n-  htab_delete (def_blocks);\n-  def_blocks = NULL;\n-  \n-  VEC_free (tree_on_heap, block_defs_stack);\n-  block_defs_stack = NULL;\n+      if (!REGISTER_DEFS_IN_THIS_STMT (phi))\n+\tcontinue;\n+      \n+      lhs = PHI_RESULT (phi);\n+      lhs_sym = SSA_NAME_VAR (lhs);\n \n-  timevar_pop (TV_TREE_SSA_REWRITE_BLOCKS);\n+      if (symbol_marked_for_renaming (lhs_sym))\n+\tregister_new_update_single (lhs, lhs_sym);\n+      else\n+\t{\n+\t  /* If LHS is a new name, register a new definition for all\n+\t     the names replaced by LHS.  */\n+\t  if (is_new_name (lhs))\n+\t    register_new_update_set (lhs, names_replaced_by (lhs));\n+\t  \n+\t  /* If LHS is an OLD name, register it as a new definition\n+\t     for itself.  */\n+\t  if (is_old_name (lhs))\n+\t    register_new_update_single (lhs, lhs);\n+\t}\n+\n+      if (is_abnormal_phi)\n+\tSSA_NAME_OCCURS_IN_ABNORMAL_PHI (lhs) = 1;\n+    }\n+}\n+\n+\n+/* Replace the operand pointed by USE_P with USE's current reaching\n+   definition.  */\n+\n+static inline void\n+replace_use (use_operand_p use_p, tree use)\n+{\n+  tree rdef = get_reaching_def (use);\n+  if (rdef != use)\n+    SET_USE (use_p, rdef);\n+}\n+\n+\n+/* Called after visiting block BB.  Unwind BLOCK_DEFS_STACK to restore\n+   the current reaching definition of every name re-written in BB to\n+   the original reaching definition before visiting BB.  This\n+   unwinding must be done in the opposite order to what is done in\n+   register_new_update_set.  */\n+\n+static void\n+rewrite_update_fini_block (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n+\t\t\t   basic_block bb ATTRIBUTE_UNUSED)\n+{\n+  while (VEC_length (tree_on_heap, block_defs_stack) > 0)\n+    {\n+      tree var = VEC_pop (tree_on_heap, block_defs_stack);\n+      tree saved_def;\n+      \n+      /* NULL indicates the unwind stop point for this block (see\n+\t rewrite_update_init_block).  */\n+      if (var == NULL)\n+\treturn;\n+\n+      saved_def = VEC_pop (tree_on_heap, block_defs_stack);\n+      set_current_def (var, saved_def);\n+    }\n+}\n+\n+\n+/* Update every variable used in the statement pointed-to by SI.  The\n+   statement is assumed to be in SSA form already.  Names in\n+   OLD_SSA_NAMES used by SI will be updated to their current reaching\n+   definition.  Names in OLD_SSA_NAMES or NEW_SSA_NAMES defined by SI\n+   will be registered as a new definition for their corresponding name\n+   in OLD_SSA_NAMES.  */\n+\n+static void\n+rewrite_update_stmt (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n+\t\t     basic_block bb ATTRIBUTE_UNUSED,\n+\t\t     block_stmt_iterator si)\n+{\n+  stmt_ann_t ann;\n+  tree stmt;\n+  use_operand_p use_p;\n+  def_operand_p def_p;\n+  ssa_op_iter iter;\n+\n+  stmt = bsi_stmt (si);\n+  ann = stmt_ann (stmt);\n+\n+  /* Only update marked statements.  */\n+  if (!REWRITE_THIS_STMT (stmt) && !REGISTER_DEFS_IN_THIS_STMT (stmt))\n+    return;\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"Updating SSA information for statement \");\n+      print_generic_stmt (dump_file, stmt, TDF_SLIM);\n+      fprintf (dump_file, \"\\n\");\n+    }\n+\n+  /* Rewrite USES included in OLD_SSA_NAMES and USES whose underlying\n+     symbol is marked for renaming.  */\n+  if (REWRITE_THIS_STMT (stmt))\n+    {\n+      FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter, SSA_OP_USE)\n+\t{\n+\t  tree use = USE_FROM_PTR (use_p);\n+\t  tree sym = DECL_P (use) ? use : SSA_NAME_VAR (use);\n+\n+\t  if (symbol_marked_for_renaming (sym))\n+\t    replace_use (use_p, sym);\n+\t  else if (is_old_name (use))\n+\t    replace_use (use_p, use);\n+\t}\n+\n+      if (need_to_update_vops_p)\n+\tFOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter,\n+\t\t\t\t  SSA_OP_VIRTUAL_USES | SSA_OP_VIRTUAL_KILLS)\n+\t  {\n+\t    tree use = USE_FROM_PTR (use_p);\n+\t    tree sym = DECL_P (use) ? use : SSA_NAME_VAR (use);\n+\n+\t    if (symbol_marked_for_renaming (sym))\n+\t      replace_use (use_p, sym);\n+\t  }\n+    }\n+\n+  /* Register definitions of names in NEW_SSA_NAMES and OLD_SSA_NAMES.\n+     Also register definitions for names whose underlying symbol is\n+     marked for renaming.  */\n+  if (REGISTER_DEFS_IN_THIS_STMT (stmt))\n+    {\n+      FOR_EACH_SSA_DEF_OPERAND (def_p, stmt, iter, SSA_OP_DEF)\n+\t{\n+\t  tree def = DEF_FROM_PTR (def_p);\n+\t  tree sym = DECL_P (def) ? def : SSA_NAME_VAR (def);\n+\n+\t  /* If DEF is a naked symbol that needs renaming, create a\n+\t     new name for it.  */\n+\t  if (symbol_marked_for_renaming (sym))\n+\t    {\n+\t      if (DECL_P (def))\n+\t\t{\n+\t\t  def = make_ssa_name (def, stmt);\n+\t\t  SET_DEF (def_p, def);\n+\t\t}\n+\n+\t      register_new_update_single (def, sym);\n+\t    }\n+\t  else\n+\t    {\n+\t      /* If DEF is a new name, register it as a new definition\n+\t\t for all the names replaced by DEF.  */\n+\t      if (is_new_name (def))\n+\t\tregister_new_update_set (def, names_replaced_by (def));\n+\n+\t      /* If DEF is an old name, register DEF as a new\n+\t\t definition for itself.  */\n+\t      if (is_old_name (def))\n+\t\tregister_new_update_single (def, def);\n+\t    }\n+\t}\n+\n+      if (need_to_update_vops_p)\n+\tFOR_EACH_SSA_DEF_OPERAND (def_p, stmt, iter, SSA_OP_VIRTUAL_DEFS)\n+\t  {\n+\t    tree def = DEF_FROM_PTR (def_p);\n+\t    tree sym = DECL_P (def) ? def : SSA_NAME_VAR (def);\n+\n+\t    if (symbol_marked_for_renaming (sym))\n+\t      {\n+\t\tif (DECL_P (def))\n+\t\t  {\n+\t\t    def = make_ssa_name (def, stmt);\n+\t\t    SET_DEF (def_p, def);\n+\t\t  }\n+\n+\t\tregister_new_update_single (def, sym);\n+\t      }\n+\t  }\n+    }\n+}\n+\n+\n+/* Visit all the successor blocks of BB looking for PHI nodes.  For\n+   every PHI node found, check if any of its arguments is in\n+   OLD_SSA_NAMES.  If so, and if the argument has a current reaching\n+   definition, replace it.  */\n+\n+static void\n+rewrite_update_phi_arguments (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n+\t\t\t      basic_block bb)\n+{\n+  edge e;\n+  edge_iterator ei;\n+\n+  FOR_EACH_EDGE (e, ei, bb->succs)\n+    {\n+      tree phi;\n+\n+      for (phi = phi_nodes (e->dest); phi; phi = PHI_CHAIN (phi))\n+\t{\n+\t  tree arg;\n+\t  use_operand_p arg_p;\n+\n+\t  /* Skip PHI nodes that are not marked for rewrite.  */\n+\t  if (!REWRITE_THIS_STMT (phi))\n+\t    continue;\n+\n+\t  arg_p = PHI_ARG_DEF_PTR_FROM_EDGE (phi, e);\n+\t  arg = USE_FROM_PTR (arg_p);\n+\n+\t  if (arg && !DECL_P (arg) && TREE_CODE (arg) != SSA_NAME)\n+\t    continue;\n+\n+\t  if (arg == NULL_TREE)\n+\t    {\n+\t      /* When updating a PHI node for a recently introduced\n+\t\t symbol we may find NULL arguments.  That's why we\n+\t\t take the symbol from the LHS of the PHI node.  */\n+\t      replace_use (arg_p, SSA_NAME_VAR (PHI_RESULT (phi)));\n+\t    }\n+\t  else\n+\t    {\n+\t      tree sym = DECL_P (arg) ? arg : SSA_NAME_VAR (arg);\n+\n+\t      if (symbol_marked_for_renaming (sym))\n+\t\treplace_use (arg_p, sym);\n+\t      else if (is_old_name (arg))\n+\t\treplace_use (arg_p, arg);\n+\t    }\n+\n+\t  if (e->flags & EDGE_ABNORMAL)\n+\t    SSA_NAME_OCCURS_IN_ABNORMAL_PHI (USE_FROM_PTR (arg_p)) = 1;\n+\t}\n+    }\n+}\n+\n+\n+/* Rewrite the actual blocks, statements, and PHI arguments, to be in SSA\n+   form.  \n+\n+   ENTRY indicates the block where to start.  Every block dominated by\n+      ENTRY will be rewritten.\n+\n+   WHAT indicates what actions will be taken by the renamer (see enum\n+      rewrite_mode).\n+\n+   BLOCKS are the set of interesting blocks for the dominator walker\n+      to process.  If this set is NULL, then all the nodes dominated\n+      by ENTRY are walked.  Otherwise, blocks dominated by ENTRY that\n+      are not present in BLOCKS are ignored.  */\n+\n+static void\n+rewrite_blocks (basic_block entry, enum rewrite_mode what, sbitmap blocks)\n+{\n+  struct dom_walk_data walk_data;\n+  \n+  /* Rewrite all the basic blocks in the program.  */\n+  timevar_push (TV_TREE_SSA_REWRITE_BLOCKS);\n+\n+  /* Setup callbacks for the generic dominator tree walker.  */\n+  memset (&walk_data, 0, sizeof (walk_data));\n+\n+  walk_data.dom_direction = CDI_DOMINATORS;\n+  walk_data.interesting_blocks = blocks;\n+\n+  if (what == REWRITE_UPDATE)\n+    walk_data.before_dom_children_before_stmts = rewrite_update_init_block;\n+  else\n+    walk_data.before_dom_children_before_stmts = rewrite_initialize_block;\n+\n+  if (what == REWRITE_ALL)\n+    walk_data.before_dom_children_walk_stmts = rewrite_stmt;\n+  else if (what == REWRITE_UPDATE)\n+    walk_data.before_dom_children_walk_stmts = rewrite_update_stmt;\n+  else\n+    gcc_unreachable ();\n+\n+  if (what == REWRITE_ALL)\n+    walk_data.before_dom_children_after_stmts = rewrite_add_phi_arguments;\n+  else if (what == REWRITE_UPDATE)\n+    walk_data.before_dom_children_after_stmts = rewrite_update_phi_arguments;\n+  else\n+    gcc_unreachable ();\n+  \n+  if (what == REWRITE_ALL)\n+    walk_data.after_dom_children_after_stmts =  rewrite_finalize_block;\n+  else if (what == REWRITE_UPDATE)\n+    walk_data.after_dom_children_after_stmts = rewrite_update_fini_block;\n+  else\n+    gcc_unreachable ();\n+\n+  block_defs_stack = VEC_alloc (tree_on_heap, 10);\n+\n+  /* Initialize the dominator walker.  */\n+  init_walk_dominator_tree (&walk_data);\n+\n+  /* Recursively walk the dominator tree rewriting each statement in\n+     each basic block.  */\n+  walk_dominator_tree (&walk_data, entry);\n+\n+  /* Finalize the dominator walker.  */\n+  fini_walk_dominator_tree (&walk_data);\n+\n+  /* Debugging dumps.  */\n+  if (dump_file && (dump_flags & TDF_STATS))\n+    {\n+      dump_dfa_stats (dump_file);\n+      if (def_blocks)\n+\tdump_tree_ssa_stats (dump_file);\n+    }\n+\n+  if (def_blocks)\n+    {\n+      htab_delete (def_blocks);\n+      def_blocks = NULL;\n+    }\n+  \n+  VEC_free (tree_on_heap, block_defs_stack);\n+  block_defs_stack = NULL;\n+\n+  timevar_pop (TV_TREE_SSA_REWRITE_BLOCKS);\n }\n \n \n@@ -1209,11 +1649,15 @@ mark_def_sites_initialize_block (struct dom_walk_data *walk_data,\n }\n \n \n-/* Mark the definition site blocks for each variable, so that we know where\n-   the variable is actually live.  */\n+/* Mark the definition site blocks for each variable, so that we know\n+   where the variable is actually live.\n+\n+   INTERESTING_BLOCKS will be filled in with all the blocks that\n+      should be processed by the renamer.  It is assumed to be\n+      initialized and zeroed by the caller.  */\n \n-static void \n-mark_def_site_blocks (void)\n+static void\n+mark_def_site_blocks (sbitmap interesting_blocks)\n {\n   size_t i;\n   struct dom_walk_data walk_data;\n@@ -1226,9 +1670,6 @@ mark_def_site_blocks (void)\n   for (i = 0; i < num_referenced_vars; i++)\n     set_current_def (referenced_var (i), NULL_TREE);\n \n-  /* Ensure that the dominance information is OK.  */\n-  calculate_dominance_info (CDI_DOMINATORS);\n-\n   /* Setup callbacks for the generic dominator tree walker to find and\n      mark definition sites.  */\n   walk_data.walk_stmts_backward = false;\n@@ -1240,11 +1681,16 @@ mark_def_site_blocks (void)\n   walk_data.after_dom_children_before_stmts =  NULL;\n   walk_data.after_dom_children_walk_stmts =  NULL;\n   walk_data.after_dom_children_after_stmts =  NULL;\n+  walk_data.interesting_blocks = NULL;\n \n   /* Notice that this bitmap is indexed using variable UIDs, so it must be\n      large enough to accommodate all the variables referenced in the\n      function, not just the ones we are renaming.  */\n   mark_def_sites_global_data.kills = BITMAP_ALLOC (NULL);\n+\n+  /* Create the set of interesting blocks that will be filled by\n+     mark_def_sites.  */\n+  mark_def_sites_global_data.interesting_blocks = interesting_blocks;\n   walk_data.global_data = &mark_def_sites_global_data;\n \n   /* We do not have any local data.  */\n@@ -1265,96 +1711,73 @@ mark_def_site_blocks (void)\n \n \n /* Main entry point into the SSA builder.  The renaming process\n-   proceeds in five main phases:\n-\n-   1- If VARS_TO_RENAME has any entries, any existing PHI nodes for\n-      those variables are removed from the flow graph so that they can\n-      be computed again.\n+   proceeds in four main phases:\n \n-   2- Compute dominance frontier, needed to insert PHI nodes and\n-      rename the function in dominator tree order.\n+   1- Compute dominance frontier and immediate dominators, needed to\n+      insert PHI nodes and rename the function in dominator tree\n+      order.\n \n-   3- Find and mark all the blocks that define variables\n+   2- Find and mark all the blocks that define variables\n       (mark_def_site_blocks).\n \n-   4- Insert PHI nodes at dominance frontiers (insert_phi_nodes).\n+   3- Insert PHI nodes at dominance frontiers (insert_phi_nodes).\n \n-   5- Rename all the blocks (rewrite_blocks) and statements in the program.\n+   4- Rename all the blocks (rewrite_blocks) and statements in the program.\n \n    Steps 3 and 5 are done using the dominator tree walker\n-   (walk_dominator_tree).\n+   (walk_dominator_tree).  */\n \n-   ALL is true if all variables should be renamed (otherwise just those\n-   mentioned in vars_to_rename are taken into account).  */\n-\n-void\n-rewrite_into_ssa (bool all)\n+static void\n+rewrite_into_ssa (void)\n {\n   bitmap *dfs;\n   basic_block bb;\n-  bitmap old_vars_to_rename = vars_to_rename;\n+  sbitmap interesting_blocks;\n   \n   timevar_push (TV_TREE_SSA_OTHER);\n \n-  if (all)\n-    vars_to_rename = NULL;\n-  else\n-    {\n-      /* Initialize the array of variables to rename.  */\n-      gcc_assert (vars_to_rename);\n-\n-      if (bitmap_empty_p (vars_to_rename))\n-\t{\n-\t  timevar_pop (TV_TREE_SSA_OTHER);\n-\t  return;\n-\t}\n-      \n-      invalidate_name_tags (vars_to_rename);\n-\n-      /* Now remove all the existing PHI nodes (if any) for the variables\n-\t that we are about to rename into SSA.  */\n-      remove_all_phi_nodes_for (vars_to_rename);\n-    }\n+  /* Initialize operand data structures.  */\n+  init_ssa_operands ();\n \n-  mark_def_site_blocks ();\n+  /* Initialize the set of interesting blocks.  The callback\n+     mark_def_sites will add to this set those blocks that the renamer\n+     should process.  */\n+  interesting_blocks = sbitmap_alloc (last_basic_block);\n+  sbitmap_zero (interesting_blocks);\n \n   /* Initialize dominance frontier.  */\n   dfs = (bitmap *) xmalloc (last_basic_block * sizeof (bitmap *));\n   FOR_EACH_BB (bb)\n     dfs[bb->index] = BITMAP_ALLOC (NULL);\n \n-  /* Compute dominance frontiers.  */\n+  /* 1- Compute dominance frontiers.  */\n+  calculate_dominance_info (CDI_DOMINATORS);\n   compute_dominance_frontiers (dfs);\n \n-  /* Insert PHI nodes at dominance frontiers of definition blocks.  */\n+  /* 2- Find and mark definition sites.  */\n+  mark_def_site_blocks (interesting_blocks);\n+\n+  /* 3- Insert PHI nodes at dominance frontiers of definition blocks.  */\n   insert_phi_nodes (dfs, NULL);\n \n-  rewrite_blocks (false);\n+  /* 4- Rename all the blocks.  */\n+  rewrite_blocks (ENTRY_BLOCK_PTR, REWRITE_ALL, interesting_blocks);\n \n   /* Free allocated memory.  */\n   FOR_EACH_BB (bb)\n     BITMAP_FREE (dfs[bb->index]);\n   free (dfs);\n+  sbitmap_free (interesting_blocks);\n \n-  vars_to_rename = old_vars_to_rename;\n   timevar_pop (TV_TREE_SSA_OTHER);\n }\n \n \n-/* Rewrites all variables into SSA.  */\n-\n-static void\n-rewrite_all_into_ssa (void)\n-{\n-  init_ssa_operands ();\n-  rewrite_into_ssa (true);\n-}\n-\n struct tree_opt_pass pass_build_ssa = \n {\n   \"ssa\",\t\t\t\t/* name */\n   NULL,\t\t\t\t\t/* gate */\n-  rewrite_all_into_ssa,\t\t\t/* execute */\n+  rewrite_into_ssa,\t\t\t/* execute */\n   NULL,\t\t\t\t\t/* sub */\n   NULL,\t\t\t\t\t/* next */\n   0,\t\t\t\t\t/* static_pass_number */\n@@ -1368,19 +1791,1054 @@ struct tree_opt_pass pass_build_ssa =\n };\n \n \n-/* Rewrite the def-def chains of virtual operands so that they have\n-   the correct reaching definitions.  */\n+/* Mark the definition of VAR at STMT and BB as interesting for the\n+   renamer.  BLOCKS is the set of blocks that need updating.  */\n \n-void\n-rewrite_def_def_chains (void)\n+static void\n+mark_def_interesting (tree var, tree stmt, basic_block bb, bitmap blocks,\n+\t\t      bool insert_phi_p)\n {\n-  /* Ensure that the dominance information is OK.  */\n-  calculate_dominance_info (CDI_DOMINATORS);\n-  mark_def_site_blocks ();\n-  rewrite_blocks (true);\n+  REGISTER_DEFS_IN_THIS_STMT (stmt) = 1;\n+  bitmap_set_bit (blocks, bb->index);\n+\n+  if (insert_phi_p)\n+    {\n+      bool is_phi_p = TREE_CODE (stmt) == PHI_NODE;\n+\n+#if defined ENABLE_CHECKING\n+      /* If VAR is a virtual, then it had better be a symbol.\n+\t Virtuals are in FUD-chain form, so we are interested in the\n+\t definition and use sites of the symbol, not the individual\n+\t SSA names.  */\n+      if (!is_gimple_reg (var))\n+\tgcc_assert (DECL_P (var));\n+#endif\n+\n+      set_def_block (var, bb, is_phi_p);\n+\n+      /* If VAR is an SSA name in NEW_SSA_NAMES, this is a definition\n+\t site for both itself and all the old names replaced by it.  */\n+      if (TREE_CODE (var) == SSA_NAME && is_new_name (var))\n+\t{\n+\t  bitmap_iterator bi;\n+\t  unsigned i;\n+\t  bitmap set = names_replaced_by (var);\n+\t  if (set)\n+\t    EXECUTE_IF_SET_IN_BITMAP (set, 0, i, bi)\n+\t      set_def_block (ssa_name (i), bb, is_phi_p);\n+\t}\n+    }\n+}\n+\n+\n+/* Mark the use of VAR at STMT and BB as interesting for the\n+   renamer.  INSERT_PHI_P is true if we are going to insert new PHI\n+   nodes.  BLOCKS is the set of blocks that need updating.  */\n+\n+static inline void\n+mark_use_interesting (tree var, tree stmt, basic_block bb, bitmap blocks,\n+\t\t      bool insert_phi_p)\n+{\n+  REWRITE_THIS_STMT (stmt) = 1;\n+  bitmap_set_bit (blocks, bb->index);\n+\n+  /* If VAR has not been defined in BB, then it is live-on-entry\n+     to BB.  Note that we cannot just use the block holding VAR's\n+     definition because if VAR is one of the names in OLD_SSA_NAMES,\n+     it will have several definitions (itself and all the names that\n+     replace it).  */\n+  if (insert_phi_p)\n+    {\n+      struct def_blocks_d *db_p;\n+\n+#if defined ENABLE_CHECKING\n+      /* If VAR is a virtual, then it had better be a symbol.\n+\t Virtuals are in FUD-chain form, so we are interested in the\n+\t definition and use sites of the symbol, not the individual\n+\t SSA names.  */\n+      if (!is_gimple_reg (var))\n+\tgcc_assert (DECL_P (var));\n+#endif\n+\n+      db_p = get_def_blocks_for (var);\n+      if (!bitmap_bit_p (db_p->def_blocks, bb->index))\n+\tset_livein_block (var, bb);\n+    }\n }\n \n \n+/* If any of the arguments of PHI is in OLD_SSA_NAMES, mark PHI to\n+   be rewritten.  BB is the block where PHI resides, BLOCKS is the\n+   region to be renamed and INSERT_PHI_P is true if the updating\n+   process should insert new PHI nodes.  */\n+\n+static void\n+prepare_phi_args_for_update (tree phi, basic_block bb, bitmap blocks,\n+                             bool insert_phi_p)\n+{\n+  int i;\n+\n+  for (i = 0; i < PHI_NUM_ARGS (phi); i++)\n+    {\n+      tree arg = PHI_ARG_DEF (phi, i);\n+\n+      if (TREE_CODE (arg) == SSA_NAME && is_old_name (arg))\n+\t{\n+\t  /* Mark this use of ARG interesting for the renamer.  Notice\n+\t     that we explicitly call mark_use_interesting with\n+\t     INSERT_PHI_P == false.\n+\n+\t     This is to avoid marking ARG as live-in in this block BB.\n+\t     If we were to mark ARG live-in to BB, then ARG would be\n+\t     considered live-in through ALL incoming edges to BB which\n+\t     is not what we want.  Since we are updating the SSA form\n+\t     for ARG, we don't really know what other names of ARG are\n+\t     coming in through other edges into BB.\n+\n+\t     If we considered ARG live-in at BB, then the PHI\n+\t     placement algorithm may try to insert PHI nodes in blocks\n+\t     that are not only unnecessary but also the renamer would\n+\t     not know how to fill in.  */\n+\t  mark_use_interesting (arg, phi, bb, blocks, false);\n+\n+\t  /* As discussed above, we only want to mark ARG live-in\n+\t     through the edge corresponding to its slot inside the PHI\n+\t     argument list.  So, we look for the block BB1 where ARG is\n+\t     flowing through.  If BB1 does not contain a definition of\n+\t     ARG, then consider ARG live-in at BB1.  */\n+\t  if (insert_phi_p)\n+\t    {\n+\t      edge e = PHI_ARG_EDGE (phi, i);\n+\t      basic_block bb1 = e->src;\n+\t      struct def_blocks_d *db = get_def_blocks_for (arg);\n+\n+\t      if (!bitmap_bit_p (db->def_blocks, bb1->index))\n+\t\tset_livein_block (arg, bb1);\n+\t    }\n+\t}\n+    }\n+}\n+\n+\n+/* Do a dominator walk starting at BB processing statements that\n+   reference variables in OLD_SSA_NAMES and NEW_SSA_NAMES.\n+\n+   1- Mark in BLOCKS the defining block of every name N in\n+      NEW_SSA_NAMES.\n+\n+   2- Mark in BLOCKS the defining block of every name O in\n+      OLD_SSA_NAMES.\n+\n+   3- For every statement or PHI node that uses a name O in\n+      OLD_SSA_NAMES.  If INSERT_PHI_P is true, mark those uses as live\n+      in the corresponding block.  This is later used by the PHI\n+      placement algorithm to make PHI pruning decisions.\n+\n+   If VISIT_DOM_P is true, all the dominator children of BB are also\n+   visited.\n+\n+   FIXME.  This process is slower than necessary.  Once we have\n+   immediate uses merged in, we should be able to just visit the\n+   immediate uses of all the names that we are about to replace,\n+   instead of visiting the whole block.  */\n+\n+static void\n+prepare_block_for_update (basic_block bb, bool insert_phi_p,\n+                          bitmap blocks, bool visit_dom_p)\n+{\n+  basic_block son;\n+  block_stmt_iterator si;\n+  tree phi;\n+\n+  /* Process PHI nodes marking interesting those that define or use\n+     the names that we are interested in.  */\n+  for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n+    {\n+      tree lhs_sym, lhs = PHI_RESULT (phi);\n+\n+      REWRITE_THIS_STMT (phi) = 0;\n+      REGISTER_DEFS_IN_THIS_STMT (phi) = 0;\n+\n+      /* Ignore virtual PHIs if we are not updating virtual operands.\n+\t Note that even if NEED_TO_REPLACE_NAMES_P is false, we need\n+\t to process real PHIs because we may be rewriting GIMPLE regs\n+\t into SSA for the first time.  Therefore, we cannot do a\n+\t similar shortcut for real PHIs.  */\n+      if (!need_to_update_vops_p && !is_gimple_reg (lhs))\n+\tcontinue;\n+\n+      lhs_sym = DECL_P (lhs) ? lhs : SSA_NAME_VAR (lhs);\n+\n+      if (symbol_marked_for_renaming (lhs_sym))\n+\t{\n+\t  /* If the LHS is a virtual symbol marked for renaming, then\n+\t     we don't need to scan the argument list.  Since virtual\n+\t     operands are in FUD-chain form, all the arguments of this\n+\t     PHI must be the same symbol as the LHS.  So, we just need\n+\t     to mark this site as both an interesting use and an\n+\t     interesting def for the symbol.  */\n+\t  mark_use_interesting (lhs_sym, phi, bb, blocks, insert_phi_p);\n+\t  mark_def_interesting (lhs_sym, phi, bb, blocks, insert_phi_p);\n+\t}\n+      else if (need_to_replace_names_p)\n+\t{\n+\t  /* If the LHS is in OLD_SSA_NAMES or NEW_SSA_NAMES, this is\n+\t     a definition site for it.  */\n+\t  if (is_old_name (lhs) || is_new_name (lhs))\n+\t    mark_def_interesting (lhs, phi, bb, blocks, insert_phi_p);\n+\n+\t  prepare_phi_args_for_update (phi, bb, blocks, insert_phi_p);\n+\t}\n+    }\n+\n+  /* Process the statements.  */\n+  for (si = bsi_start (bb); !bsi_end_p (si); bsi_next (&si))\n+    {\n+      tree stmt;\n+      ssa_op_iter i;\n+      use_operand_p use_p;\n+      def_operand_p def_p;\n+      \n+      stmt = bsi_stmt (si);\n+\n+      REWRITE_THIS_STMT (stmt) = 0;\n+      REGISTER_DEFS_IN_THIS_STMT (stmt) = 0;\n+\n+      /* Note, even if NEED_TO_REPLACE_NAMES_P is false, we need to\n+\t scan real uses and defs, as we may be renaming a GIMPLE\n+\t register for the first time.  */\n+      FOR_EACH_SSA_USE_OPERAND (use_p, stmt, i, SSA_OP_USE)\n+\t{\n+\t  tree use = USE_FROM_PTR (use_p);\n+\t  tree sym = DECL_P (use) ? use : SSA_NAME_VAR (use);\n+\t  if (symbol_marked_for_renaming (sym) || is_old_name (use))\n+\t    mark_use_interesting (use, stmt, bb, blocks, insert_phi_p);\n+\t}\n+\n+      FOR_EACH_SSA_DEF_OPERAND (def_p, stmt, i, SSA_OP_DEF)\n+\t{\n+\t  tree def = DEF_FROM_PTR (def_p);\n+\t  tree sym = DECL_P (def) ? def : SSA_NAME_VAR (def);\n+\n+\t  if (symbol_marked_for_renaming (sym)\n+\t      || is_new_name (def)\n+\t      || is_old_name (def))\n+\t    mark_def_interesting (def, stmt, bb, blocks, insert_phi_p);\n+\t}\n+\n+      /* If we don't need to update virtual operands, continue to the\n+\t next statement.  */\n+      if (!need_to_update_vops_p)\n+\tcontinue;\n+\n+      /* For every interesting N_i = V_MAY_DEF <N_j> and\n+\t N_i = V_MUST_DEF <N_j>, mark the statement as interesting.\n+\t Notice that N_j may in fact be a naked symbol (if this\n+\t statement is the result of basic block duplication). The\n+\t rename process will later fill in the appropriate reaching\n+\t definition for the symbol.  */\n+      FOR_EACH_SSA_DEF_OPERAND (def_p, stmt, i, SSA_OP_VIRTUAL_DEFS)\n+\t{\n+\t  tree def = DEF_FROM_PTR (def_p);\n+\t  tree sym = DECL_P (def) ? def : SSA_NAME_VAR (def);\n+\n+\t  if (symbol_marked_for_renaming (sym))\n+\t    {\n+\t      mark_use_interesting (sym, stmt, bb, blocks, insert_phi_p);\n+\t      mark_def_interesting (sym, stmt, bb, blocks, insert_phi_p);\n+\t    }\n+\t}\n+\n+      /* Similarly, for V_USE <N_i>.  */\n+      FOR_EACH_SSA_USE_OPERAND (use_p, stmt, i, SSA_OP_VUSE)\n+\t{\n+\t  tree use = USE_FROM_PTR (use_p);\n+\t  tree sym = DECL_P (use) ? use : SSA_NAME_VAR (use);\n+\n+\t  if (symbol_marked_for_renaming (sym))\n+\t    mark_use_interesting (sym, stmt, bb, blocks, insert_phi_p);\n+\t}\n+    }\n+\n+  /* Now visit all the blocks dominated by BB.  */\n+  if (visit_dom_p)\n+    for (son = first_dom_son (CDI_DOMINATORS, bb);\n+\t son;\n+\t son = next_dom_son (CDI_DOMINATORS, son))\n+      prepare_block_for_update (son, insert_phi_p, blocks, true);\n+}\n+\n+\n+/* Helper for prepare_def_sites.  Mark the definition site for NAME as\n+   interesting.  BLOCKS and INSERT_PHI_P are as in prepare_def_sites.  */\n+\n+static void\n+prepare_def_site_for (tree name, bitmap blocks, bool insert_phi_p)\n+{\n+  tree stmt;\n+  basic_block bb;\n+\n+  gcc_assert (name && is_gimple_reg (name));\n+  gcc_assert (names_to_release == NULL\n+\t      || !bitmap_bit_p (names_to_release, SSA_NAME_VERSION (name)));\n+\n+  stmt = SSA_NAME_DEF_STMT (name);\n+  bb = bb_for_stmt (stmt);\n+  if (bb)\n+    {\n+      gcc_assert (bb->index < last_basic_block);\n+      mark_def_interesting (name, stmt, bb, blocks, insert_phi_p);\n+    }\n+}\n+\n+\n+/* Mark definition sites of names in NEW_SSA_NAMES and OLD_SSA_NAMES.\n+   Add each definition block to BLOCKS.  INSERT_PHI_P is true if the\n+   caller wants to insert PHI nodes for newly created names.  */\n+\n+static void\n+prepare_def_sites (bitmap blocks, bool insert_phi_p)\n+{\n+  unsigned i;\n+  bitmap_iterator bi;\n+\n+  /* If a name N from NEW_SSA_NAMES is also marked to be released,\n+     remove it from NEW_SSA_NAMES so that we don't try to visit its\n+     defining basic block (which most likely doesn't exist).  Notice\n+     that we cannot do the same with names in OLD_SSA_NAMES because we\n+     want to replace existing instances.  */\n+  if (names_to_release)\n+    EXECUTE_IF_SET_IN_BITMAP (names_to_release, 0, i, bi)\n+      RESET_BIT (new_ssa_names, i);\n+\n+  /* If an old name is in NAMES_TO_RELEASE, we cannot remove it from\n+     OLD_SSA_NAMES, but we have to ignore its definition site.  */\n+  EXECUTE_IF_SET_IN_SBITMAP (old_ssa_names, 0, i,\n+    if (names_to_release == NULL || !bitmap_bit_p (names_to_release, i))\n+      prepare_def_site_for (ssa_name (i), blocks, insert_phi_p));\n+\n+  EXECUTE_IF_SET_IN_SBITMAP (new_ssa_names, 0, i,\n+    prepare_def_site_for (ssa_name (i), blocks, insert_phi_p));\n+}\n+\n+\n+/* Dump all the names replaced by NAME to FILE.  */\n+\n+void\n+dump_names_replaced_by (FILE *file, tree name)\n+{\n+  unsigned i;\n+  bitmap old_set;\n+  bitmap_iterator bi;\n+\n+  print_generic_expr (file, name, 0);\n+  fprintf (file, \" -> { \");\n+\n+  old_set = names_replaced_by (name);\n+  EXECUTE_IF_SET_IN_BITMAP (old_set, 0, i, bi)\n+    {\n+      print_generic_expr (file, ssa_name (i), 0);\n+      fprintf (file, \" \");\n+    }\n+\n+  fprintf (file, \"}\\n\");\n+}\n+\n+\n+/* Dump all the names replaced by NAME to stderr.  */\n+\n+void\n+debug_names_replaced_by (tree name)\n+{\n+  dump_names_replaced_by (stderr, name);\n+}\n+\n+\n+/* Dump the SSA name replacement table to FILE.  */\n+\n+void\n+dump_repl_tbl (FILE *file)\n+{\n+  unsigned i;\n+  bitmap_iterator bi;\n+\n+  if (!need_ssa_update_p ())\n+    return;\n+\n+  if (new_ssa_names && sbitmap_first_set_bit (new_ssa_names) >= 0)\n+    {\n+      fprintf (file, \"\\nSSA replacement table\\n\");\n+      fprintf (file, \"N_i -> { O_1 ... O_j } means that N_i replaces \"\n+\t             \"O_1, ..., O_j\\n\\n\");\n+\n+      EXECUTE_IF_SET_IN_SBITMAP (new_ssa_names, 0, i,\n+\tdump_names_replaced_by (file, ssa_name (i)));\n+    }\n+\n+  if (syms_to_rename && !bitmap_empty_p (syms_to_rename))\n+    {\n+      fprintf (file, \"\\n\\nSymbols to be put in SSA form\\n\\n\");\n+      EXECUTE_IF_SET_IN_BITMAP (syms_to_rename, 0, i, bi)\n+\t{\n+\t  print_generic_expr (file, referenced_var (i), 0);\n+\t  fprintf (file, \" \");\n+\t}\n+    }\n+\n+  if (old_virtual_ssa_names && !bitmap_empty_p (old_virtual_ssa_names))\n+    {\n+      fprintf (file, \"\\n\\nVirtual SSA names to be updated\\n\\n\");\n+      EXECUTE_IF_SET_IN_BITMAP (old_virtual_ssa_names, 0, i, bi)\n+\t{\n+\t  print_generic_expr (file, ssa_name (i), 0);\n+\t  fprintf (file, \" \");\n+\t}\n+    }\n+\n+  if (names_to_release && !bitmap_empty_p (names_to_release))\n+    {\n+      fprintf (file, \"\\n\\nSSA names to release after updating the SSA web\\n\\n\");\n+      EXECUTE_IF_SET_IN_BITMAP (names_to_release, 0, i, bi)\n+\t{\n+\t  print_generic_expr (file, ssa_name (i), 0);\n+\t  fprintf (file, \" \");\n+\t}\n+    }\n+\n+  fprintf (file, \"\\n\\n\");\n+}\n+\n+\n+/* Dump the SSA name replacement table to stderr.  */\n+\n+void\n+debug_repl_tbl (void)\n+{\n+  dump_repl_tbl (stderr);\n+}\n+\n+\n+/* Initialize data structures used for incremental SSA updates.  */\n+\n+static void\n+init_update_ssa (void)\n+{\n+  /* Reserve 1/3 more than the current number of names.  The calls to\n+     add_new_name_mapping are typically done after creating new SSA\n+     names, so we'll need to reallocate these arrays.  */\n+  old_ssa_names = sbitmap_alloc (num_ssa_names + NAME_SETS_GROWTH_FACTOR);\n+  sbitmap_zero (old_ssa_names);\n+\n+  new_ssa_names = sbitmap_alloc (num_ssa_names + NAME_SETS_GROWTH_FACTOR);\n+  sbitmap_zero (new_ssa_names);\n+\n+  repl_tbl = htab_create (20, repl_map_hash, repl_map_eq, repl_map_free);\n+  need_to_initialize_update_ssa_p = false;\n+  need_to_update_vops_p = false;\n+  need_to_replace_names_p = false;\n+  syms_to_rename = BITMAP_ALLOC (NULL);\n+  old_virtual_ssa_names = BITMAP_ALLOC (NULL);\n+  names_to_release = NULL;\n+}\n+\n+\n+/* Deallocate data structures used for incremental SSA updates.  */\n+\n+static void\n+delete_update_ssa (void)\n+{\n+  unsigned i;\n+  bitmap_iterator bi;\n+\n+  sbitmap_free (old_ssa_names);\n+  old_ssa_names = NULL;\n+\n+  sbitmap_free (new_ssa_names);\n+  new_ssa_names = NULL;\n+\n+  htab_delete (repl_tbl);\n+  repl_tbl = NULL;\n+\n+  need_to_initialize_update_ssa_p = true;\n+  need_to_update_vops_p = false;\n+  need_to_replace_names_p = false;\n+  BITMAP_FREE (syms_to_rename);\n+  BITMAP_FREE (old_virtual_ssa_names);\n+\n+  if (names_to_release)\n+    {\n+      EXECUTE_IF_SET_IN_BITMAP (names_to_release, 0, i, bi)\n+\trelease_ssa_name (ssa_name (i));\n+      BITMAP_FREE (names_to_release);\n+    }\n+\n+  for (i = 1; i < num_ssa_names; i++)\n+    {\n+      tree n = ssa_name (i);\n+\n+      if (n)\n+\t{\n+\t  free (SSA_NAME_AUX (n));\n+\t  SSA_NAME_AUX (n) = NULL;\n+\t}\n+    }\n+\n+  /* Unmark all the names we may have protected from being released in\n+     insert_updated_phi_nodes_for.  */\n+  unmark_all_for_rewrite ();\n+}\n+\n+\n+/* Create a new name for OLD_NAME in statement STMT and replace the\n+   operand pointed to by DEF_P with the newly created name.  Return\n+   the new name and register the replacement mapping <NEW, OLD> in\n+   update_ssa's tables.  */\n+\n+tree\n+create_new_def_for (tree old_name, tree stmt, def_operand_p def)\n+{\n+  tree new_name = duplicate_ssa_name (old_name, stmt);\n+\n+  SET_DEF (def, new_name);\n+\n+  if (TREE_CODE (stmt) == PHI_NODE)\n+    {\n+      edge e;\n+      edge_iterator ei;\n+      basic_block bb = bb_for_stmt (stmt);\n+\n+      /* If needed, mark NEW_NAME as occurring in an abnormal PHI node. */\n+      FOR_EACH_EDGE (e, ei, bb->preds)\n+\tif (e->flags & EDGE_ABNORMAL)\n+\t  {\n+\t    SSA_NAME_OCCURS_IN_ABNORMAL_PHI (new_name) = 1;\n+\t    break;\n+\t  }\n+    }\n+\n+  register_new_name_mapping (new_name, old_name);\n+\n+  /* For the benefit of passes that will be updating the SSA form on\n+     their own, set the current reaching definition of OLD_NAME to be\n+     NEW_NAME.  */\n+  set_current_def (old_name, new_name);\n+\n+  return new_name;\n+}\n+\n+\n+/* Register name NEW to be a replacement for name OLD.  This function\n+   must be called for every replacement that should be performed by\n+   update_ssa.  */\n+\n+void\n+register_new_name_mapping (tree new, tree old)\n+{\n+  if (need_to_initialize_update_ssa_p)\n+    init_update_ssa ();\n+\n+  add_new_name_mapping (new, old);\n+}\n+\n+\n+/* Register symbol SYM to be renamed by update_ssa.  */\n+\n+void\n+mark_sym_for_renaming (tree sym)\n+{\n+  if (need_to_initialize_update_ssa_p)\n+    init_update_ssa ();\n+\n+  bitmap_set_bit (syms_to_rename, var_ann (sym)->uid);\n+\n+  if (!is_gimple_reg (sym))\n+    need_to_update_vops_p = true;\n+}\n+\n+\n+/* Register all the symbols in SET to be renamed by update_ssa.  */\n+\n+void\n+mark_set_for_renaming (bitmap set)\n+{\n+  bitmap_iterator bi;\n+  unsigned i;\n+\n+  if (need_to_initialize_update_ssa_p)\n+    init_update_ssa ();\n+\n+  bitmap_ior_into (syms_to_rename, set);\n+\n+  EXECUTE_IF_SET_IN_BITMAP (set, 0, i, bi)\n+    if (!is_gimple_reg (referenced_var (i)))\n+      {\n+\tneed_to_update_vops_p = true;\n+\tbreak;\n+      }\n+}\n+\n+\n+/* Return true if there is any work to be done by update_ssa.  */\n+\n+bool\n+need_ssa_update_p (void)\n+{\n+  return syms_to_rename || old_ssa_names || new_ssa_names;\n+}\n+\n+\n+/* Return true if name N has been registered in the replacement table.  */\n+\n+bool\n+name_registered_for_update_p (tree n)\n+{\n+  if (!need_ssa_update_p ())\n+    return false;\n+\n+  return is_new_name (n)\n+         || is_old_name (n)\n+\t || symbol_marked_for_renaming (SSA_NAME_VAR (n));\n+}\n+\n+\n+/* Return the set of all the SSA names marked to be replaced.  */\n+\n+bitmap\n+ssa_names_to_replace (void)\n+{\n+  unsigned i;\n+  bitmap ret;\n+  \n+  ret = BITMAP_ALLOC (NULL);\n+  EXECUTE_IF_SET_IN_SBITMAP (old_ssa_names, 0, i,\n+    bitmap_set_bit (ret, i));\n+\n+  bitmap_ior_into (ret, old_virtual_ssa_names);\n+\n+  return ret;\n+}\n+\n+\n+/* Mark NAME to be released after update_ssa has finished.  */\n+\n+void\n+release_ssa_name_after_update_ssa (tree name)\n+{\n+  gcc_assert (!need_to_initialize_update_ssa_p);\n+\n+  if (names_to_release == NULL)\n+    names_to_release = BITMAP_ALLOC (NULL);\n+\n+  bitmap_set_bit (names_to_release, SSA_NAME_VERSION (name));\n+}\n+\n+\n+/* Insert new PHI nodes to replace VAR.  DFS contains dominance\n+   frontier information.  BLOCKS is the set of blocks to be updated.\n+\n+   This is slightly different than the regular PHI insertion\n+   algorithm.  The value of UPDATE_FLAGS controls how PHI nodes for\n+   real names (i.e., GIMPLE registers) are inserted:\n+ \n+   - If UPDATE_FLAGS == TODO_update_ssa, we are only interested in PHI\n+     nodes inside the region affected by the block that defines VAR\n+     and the blocks that define all its replacements.  All these\n+     definition blocks have been gathered by prepare_block_for_update\n+     and they are stored in DEF_BLOCKS[VAR]->DEF_BLOCKS.\n+\n+     First, we compute the entry point to the region (ENTRY).  This is\n+     given by the nearest common dominator to all the definition\n+     blocks. When computing the iterated dominance frontier (IDF), any\n+     block not strictly dominated by ENTRY is ignored.\n+\n+     We then call the standard PHI insertion algorithm with the pruned\n+     IDF.\n+\n+   - If UPDATE_FLAGS == TODO_update_ssa_full_phi, the IDF for real\n+     names is not pruned.  PHI nodes are inserted at every IDF block.  */\n+\n+static void\n+insert_updated_phi_nodes_for (tree var, bitmap *dfs, bitmap blocks,\n+                              unsigned update_flags)\n+{\n+  basic_block entry;\n+  struct def_blocks_d *db;\n+  bitmap idf, pruned_idf;\n+  bitmap_iterator bi;\n+  unsigned i;\n+\n+#if defined ENABLE_CHECKING\n+  if (TREE_CODE (var) == SSA_NAME)\n+    gcc_assert (is_old_name (var));\n+  else\n+    gcc_assert (symbol_marked_for_renaming (var));\n+#endif\n+\n+  /* Get all the definition sites for VAR.  */\n+  db = find_def_blocks_for (var);\n+\n+  /* No need to do anything if there were no definitions to VAR.  */\n+  if (db == NULL || bitmap_empty_p (db->def_blocks))\n+    return;\n+\n+  /* Compute the initial iterated dominance frontier.  */\n+  idf = find_idf (db->def_blocks, dfs);\n+  pruned_idf = BITMAP_ALLOC (NULL);\n+\n+  if (TREE_CODE (var) == SSA_NAME)\n+    {\n+      if (update_flags == TODO_update_ssa)\n+\t{\n+\t  /* If doing regular SSA updates for GIMPLE registers, we are\n+\t     only interested in IDF blocks dominated by the nearest\n+\t     common dominator of all the definition blocks.  */\n+\t  entry = nearest_common_dominator_for_set (CDI_DOMINATORS,\n+\t\t\t\t\t\t    db->def_blocks);\n+\n+\t  if (entry != ENTRY_BLOCK_PTR)\n+\t    EXECUTE_IF_SET_IN_BITMAP (idf, 0, i, bi)\n+\t      if (BASIC_BLOCK (i) != entry\n+\t\t  && dominated_by_p (CDI_DOMINATORS, BASIC_BLOCK (i), entry))\n+\t\tbitmap_set_bit (pruned_idf, i);\n+\t}\n+      else\n+\t{\n+\t  /* Otherwise, do not prune the IDF for VAR.  */\n+\t  gcc_assert (update_flags == TODO_update_ssa_full_phi);\n+\t  bitmap_copy (pruned_idf, idf);\n+\t}\n+    }\n+  else\n+    {\n+      /* Otherwise, VAR is a symbol that needs to be put into SSA form\n+\t for the first time, so we need to compute the full IDF for\n+\t it.  */\n+      bitmap_copy (pruned_idf, idf);\n+\n+      /* There may already be PHI nodes for VAR in the flowgraph.\n+\t Some of them are no longer necessary.  PRUNED_IDF is\n+\t the set of blocks that need PHI nodes for VAR and\n+\t DB.PHI_BLOCKS is the set of blocks that already contain a PHI\n+\t node for VAR.  Therefore, the set DB.PHI_BLOCKS - PRUNED_IDF\n+\t gives us the set of blocks that contain PHI nodes which are\n+\t no longer needed.  */\n+      if (!bitmap_empty_p (db->phi_blocks) && !bitmap_empty_p (pruned_idf))\n+\tEXECUTE_IF_AND_COMPL_IN_BITMAP (db->phi_blocks, pruned_idf, 0, i, bi)\n+\t  {\n+\t    tree phi, prev;\n+\t    unsigned ver;\n+\n+\t    phi = find_phi_node_for (BASIC_BLOCK (i), var, &prev);\n+\t    \n+\t    /* Protect the name on PHI's LHS from being released into\n+\t       the SSA name free list.  Since we have still not\n+\t       updated the SSA form of the program, there may be\n+\t       instances of PHI's LHS in the IL.  */\n+\t    ver = SSA_NAME_VERSION (PHI_RESULT (phi));\n+\t    mark_for_rewrite (PHI_RESULT (phi));\n+\t    release_ssa_name_after_update_ssa (PHI_RESULT (phi));\n+\t    remove_phi_node (phi, prev);\n+\t  }\n+    }\n+\n+  if (!bitmap_empty_p (pruned_idf))\n+    {\n+      /* Make sure that PRUNED_IDF blocks and all their feeding blocks\n+\t are included in the region to be updated.  The feeding blocks\n+\t are important to guarantee that the PHI arguments are renamed\n+\t properly.  */\n+      bitmap_ior_into (blocks, pruned_idf);\n+      EXECUTE_IF_SET_IN_BITMAP (pruned_idf, 0, i, bi)\n+\t{\n+\t  edge e;\n+\t  edge_iterator ei;\n+\t  basic_block bb = BASIC_BLOCK (i);\n+\n+\t  FOR_EACH_EDGE (e, ei, bb->preds)\n+\t    if (e->src->index >= 0)\n+\t      bitmap_set_bit (blocks, e->src->index);\n+\t}\n+\n+      insert_phi_nodes_for (var, pruned_idf, true);\n+    }\n+\n+  BITMAP_FREE (pruned_idf);\n+  BITMAP_FREE (idf);\n+}\n+\n+\n+/* Given a set of newly created SSA names (NEW_SSA_NAMES) and a set of\n+   existing SSA names (OLD_SSA_NAMES), update the SSA form so that:\n+\n+   1- The names in OLD_SSA_NAMES dominated by the definitions of\n+      NEW_SSA_NAMES are all re-written to be reached by the\n+      appropriate definition from NEW_SSA_NAMES.\n+\n+   2- If needed, new PHI nodes are added to the iterated dominance\n+      frontier of the blocks where each of NEW_SSA_NAMES are defined.\n+\n+   The mapping between OLD_SSA_NAMES and NEW_SSA_NAMES is setup by\n+   calling register_new_name_mapping for every pair of names that the\n+   caller wants to replace.\n+\n+   The caller identifies the new names that have been inserted and the\n+   names that need to be replaced by calling register_new_name_mapping\n+   for every pair <NEW, OLD>.  Note that the function assumes that the\n+   new names have already been inserted in the IL.\n+\n+   For instance, given the following code:\n+\n+     1\tL0:\n+     2\tx_1 = PHI (0, x_5)\n+     3\tif (x_1 < 10)\n+     4\t  if (x_1 > 7)\n+     5\t    y_2 = 0\n+     6\t  else\n+     7\t    y_3 = x_1 + x_7\n+     8\t  endif\n+     9\t  x_5 = x_1 + 1\n+     10   goto L0;\n+     11\tendif\n+\n+   Suppose that we insert new names x_10 and x_11 (lines 4 and 8).\n+\n+     1\tL0:\n+     2\tx_1 = PHI (0, x_5)\n+     3\tif (x_1 < 10)\n+     4\t  x_10 = ...\n+     5\t  if (x_1 > 7)\n+     6\t    y_2 = 0\n+     7\t  else\n+     8\t    x_11 = ...\n+     9\t    y_3 = x_1 + x_7\n+     10\t  endif\n+     11\t  x_5 = x_1 + 1\n+     12\t  goto L0;\n+     13\tendif\n+\n+   We want to replace all the uses of x_1 with the new definitions of\n+   x_10 and x_11.  Note that the only uses that should be replaced are\n+   those at lines 5, 9 and 11.  Also, the use of x_7 at line 9 should\n+   *not* be replaced (this is why we cannot just mark symbol 'x' for\n+   renaming).\n+\n+   Additionally, we may need to insert a PHI node at line 11 because\n+   that is a merge point for x_10 and x_11.  So the use of x_1 at line\n+   11 will be replaced with the new PHI node.  The insertion of PHI\n+   nodes is optional.  They are not strictly necessary to preserve the\n+   SSA form, and depending on what the caller inserted, they may not\n+   even be useful for the optimizers.  UPDATE_FLAGS controls various\n+   aspects of how update_ssa operates, see the documentation for\n+   TODO_update_ssa*.  */\n+\n+void\n+update_ssa (unsigned update_flags)\n+{\n+  bitmap *dfs, blocks;\n+  basic_block bb, start_bb;\n+  bitmap_iterator bi;\n+  unsigned i;\n+  sbitmap tmp;\n+  bool insert_phi_p;\n+\n+  if (!need_ssa_update_p ())\n+    return;\n+\n+  timevar_push (TV_TREE_SSA_INCREMENTAL);\n+\n+  /* Ensure that the dominance information is up-to-date.  */\n+  calculate_dominance_info (CDI_DOMINATORS);\n+\n+  /* Only one update flag should be set.  */\n+  gcc_assert (update_flags == TODO_update_ssa\n+              || update_flags == TODO_update_ssa_no_phi\n+\t      || update_flags == TODO_update_ssa_full_phi\n+\t      || update_flags == TODO_update_ssa_only_virtuals);\n+\n+  /* If we only need to update virtuals, remove all the mappings for\n+     real names before proceeding.  */\n+  if (update_flags == TODO_update_ssa_only_virtuals)\n+    {\n+      sbitmap_zero (old_ssa_names);\n+      sbitmap_zero (new_ssa_names);\n+      htab_empty (repl_tbl);\n+      need_to_replace_names_p = false;\n+    }\n+\n+  if (update_flags == TODO_update_ssa\n+      || update_flags == TODO_update_ssa_full_phi\n+      || update_flags == TODO_update_ssa_only_virtuals)\n+    insert_phi_p = true;\n+  else\n+    insert_phi_p = false;\n+\n+  if (insert_phi_p)\n+    {\n+      /* If the caller requested PHI nodes to be added, compute\n+\t dominance frontiers and initialize live-in information data\n+\t structures (DEF_BLOCKS).  */\n+      dfs = (bitmap *) xmalloc (last_basic_block * sizeof (bitmap *));\n+      FOR_EACH_BB (bb)\n+\tdfs[bb->index] = BITMAP_ALLOC (NULL);\n+      compute_dominance_frontiers (dfs);\n+\n+      /* For each SSA name N, the DEF_BLOCKS table describes where the\n+\t name is defined, which blocks have PHI nodes for N, and which\n+\t blocks have uses of N (i.e., N is live-on-entry in those\n+\t blocks).  */\n+      def_blocks = htab_create (num_ssa_names, def_blocks_hash,\n+\t\t\t\tdef_blocks_eq, def_blocks_free);\n+    }\n+  else\n+    {\n+      dfs = NULL;\n+      def_blocks = NULL;\n+    }\n+\n+  blocks = BITMAP_ALLOC (NULL);\n+\n+  /* Determine the CFG region that we are going to update.  First add\n+     all the blocks that define each of the names in NEW_SSA_NAMES\n+     and OLD_SSA_NAMES.  */\n+  prepare_def_sites (blocks, insert_phi_p);\n+\n+  /* Next, determine the nearest common dominator START_BB for all the\n+     blocks in the region.  */\n+  if (!bitmap_empty_p (syms_to_rename) || bitmap_empty_p (blocks))\n+    {\n+      /* If the region to update is seemingly empty, or if we have to\n+\t rename some symbols from scratch, we need to start the\n+\t process at the root of the CFG.\n+\n+\t FIXME, it should be possible to determine the nearest block\n+\t that had a definition for each of the symbols that are marked\n+\t for updating.  For now this seems more work than it's worth.  */\n+      start_bb = ENTRY_BLOCK_PTR;\n+    }\n+  else\n+    start_bb = nearest_common_dominator_for_set (CDI_DOMINATORS, blocks);\n+\n+  /* Traverse all the blocks dominated by START_BB.  Mark interesting\n+     blocks and statements and set local live-in information for the\n+     PHI placement heuristics.  */\n+  prepare_block_for_update (start_bb, insert_phi_p, blocks, true);\n+\n+  /* If are going to insert PHI nodes, blocks in the dominance\n+     frontier of START_BB may be affected.  Note that we don't need to\n+     visit the dominator children of blocks in the dominance frontier\n+     of START_BB.  None of the changes inside this region can affect\n+     blocks on the outside.  */\n+  if (insert_phi_p && start_bb->index >= 0)\n+    EXECUTE_IF_SET_IN_BITMAP (dfs[start_bb->index], 0, i, bi)\n+      prepare_block_for_update (BASIC_BLOCK (i), insert_phi_p,\n+\t\t\t\tblocks, false);\n+\n+  /* If requested, insert PHI nodes at the iterated dominance frontier\n+     of every block making new definitions for names in OLD_SSA_NAMES\n+     and for symbols in SYMS_TO_RENAME.  */\n+  if (insert_phi_p)\n+    {\n+      if (sbitmap_first_set_bit (old_ssa_names) >= 0)\n+\t{\n+\t  /* insert_update_phi_nodes_for will call\n+\t     add_new_name_mapping when inserting new PHI nodes, so the\n+\t     set OLD_SSA_NAMES will grow while we are traversing it\n+\t     (but it will not gain any new members).  Copy\n+\t     OLD_SSA_NAMES to a temporary for traversal.  */\n+\t  sbitmap tmp = sbitmap_alloc (old_ssa_names->n_bits);\n+\t  sbitmap_copy (tmp, old_ssa_names);\n+\t  EXECUTE_IF_SET_IN_SBITMAP (tmp, 0, i,\n+\t    insert_updated_phi_nodes_for (ssa_name (i), dfs, blocks,\n+\t                                  update_flags));\n+\t  sbitmap_free (tmp);\n+\t}\n+\n+      EXECUTE_IF_SET_IN_BITMAP (syms_to_rename, 0, i, bi)\n+\tinsert_updated_phi_nodes_for (referenced_var (i), dfs, blocks,\n+\t                              update_flags);\n+\n+      /* Insertion of PHI nodes may have added blocks to the region.\n+\t We need to re-compute START_BB to include the newly added\n+\t blocks.  */\n+      if (start_bb != ENTRY_BLOCK_PTR)\n+\tstart_bb = nearest_common_dominator_for_set (CDI_DOMINATORS, blocks);\n+    }\n+\n+  /* Reset the current definition for name and symbol before renaming\n+     the sub-graph.  */\n+  if (update_flags == TODO_update_ssa_full_phi)\n+    {\n+      /* If we are not prunning the IDF for new PHI nodes, set the\n+\t current name of every GIMPLE register to NULL.  This way, PHI\n+\t arguments coming from edges with uninitialized values will be\n+\t renamed to use the symbol's default definition.  */\n+      EXECUTE_IF_SET_IN_SBITMAP (old_ssa_names, 0, i,\n+\tset_current_def (ssa_name (i), NULL_TREE));\n+    }\n+  else\n+    {\n+      /* Otherwise, set each old name to be its current reaching\n+\t definition.  */\n+      EXECUTE_IF_SET_IN_SBITMAP (old_ssa_names, 0, i,\n+\tset_current_def (ssa_name (i), NULL_TREE));\n+    }\n+\n+  EXECUTE_IF_SET_IN_BITMAP (syms_to_rename, 0, i, bi)\n+    set_current_def (referenced_var (i), NULL_TREE);\n+\n+  /* Now start the renaming process at START_BB.  */\n+  tmp = sbitmap_alloc (last_basic_block);\n+  sbitmap_zero (tmp);\n+  EXECUTE_IF_SET_IN_BITMAP (blocks, 0, i, bi)\n+    SET_BIT (tmp, i);\n+\n+  rewrite_blocks (start_bb, REWRITE_UPDATE, tmp);\n+\n+  sbitmap_free (tmp);\n+\n+  /* Debugging dumps.  */\n+  if (dump_file)\n+    {\n+      int c;\n+      unsigned i;\n+\n+      dump_repl_tbl (dump_file);\n+\n+      fprintf (dump_file, \"Incremental SSA update started at block: %d\\n\\n\",\n+\t       start_bb->index);\n+\n+      c = 0;\n+      EXECUTE_IF_SET_IN_BITMAP (blocks, 0, i, bi)\n+\tc++;\n+      fprintf (dump_file, \"Number of blocks in CFG: %d\\n\", last_basic_block);\n+      fprintf (dump_file, \"Number of blocks to update: %d (%3.0f%%)\\n\\n\",\n+\t       c, PERCENT (c, last_basic_block));\n+\n+      if (dump_flags & TDF_DETAILS)\n+\t{\n+\t  fprintf (dump_file, \"Affected blocks: \");\n+\t  EXECUTE_IF_SET_IN_BITMAP (blocks, 0, i, bi)\n+\t    fprintf (dump_file, \"%u \", i);\n+\t  fprintf (dump_file, \"\\n\");\n+\t}\n+\n+      fprintf (dump_file, \"\\n\\n\");\n+    }\n+\n+  /* Free allocated memory.  */\n+  if (insert_phi_p)\n+    {\n+      FOR_EACH_BB (bb)\n+\tBITMAP_FREE (dfs[bb->index]);\n+      free (dfs);\n+    }\n+\n+  BITMAP_FREE (blocks);\n+  delete_update_ssa ();\n+\n+  timevar_pop (TV_TREE_SSA_INCREMENTAL);\n+}\n+\n \n /*---------------------------------------------------------------------------\n     Functions to fix a program in invalid SSA form into valid SSA\n@@ -1605,7 +3063,7 @@ ssa_mark_def_sites (struct dom_walk_data *walk_data,\n \n       if (TEST_BIT (gd->names_to_rename, def_uid))\n \t{\n-\t  set_def_block (def, bb, false, true);\n+\t  set_def_block (def, bb, false);\n \t  bitmap_set_bit (kills, def_uid);\n \t}\n     }\n@@ -1634,7 +3092,7 @@ ssa_mark_def_sites_initialize_block (struct dom_walk_data *walk_data,\n       if (!TEST_BIT (gd->names_to_rename, def_uid))\n \tcontinue;\n \n-      set_def_block (def, bb, true, true);\n+      set_def_block (def, bb, true);\n       bitmap_set_bit (kills, def_uid);\n     }\n }\n@@ -1714,6 +3172,7 @@ rewrite_ssa_into_ssa (void)\n      mark definition sites.  */\n   walk_data.walk_stmts_backward = false;\n   walk_data.dom_direction = CDI_DOMINATORS;\n+  walk_data.interesting_blocks = NULL;\n   walk_data.initialize_block_local_data = NULL;\n   walk_data.before_dom_children_before_stmts\n \t  = ssa_mark_def_sites_initialize_block;\n@@ -1761,6 +3220,7 @@ rewrite_ssa_into_ssa (void)\n   /* Setup callbacks for the generic dominator tree walker.  */\n   walk_data.walk_stmts_backward = false;\n   walk_data.dom_direction = CDI_DOMINATORS;\n+  walk_data.interesting_blocks = NULL;\n   walk_data.initialize_block_local_data = NULL;\n   walk_data.before_dom_children_before_stmts = ssa_rewrite_initialize_block;\n   walk_data.before_dom_children_walk_stmts = ssa_rewrite_stmt;"}, {"sha": "f2bd75d3766bf126be8267d3ce85edf93f65ff96", "filename": "gcc/tree-loop-linear.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftree-loop-linear.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftree-loop-linear.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-linear.c?ref=0bca51f080dfff5e943b1f1775d874a73bbc441a", "patch": "@@ -371,9 +371,6 @@ linear_transform_loops (struct loops *loops)\n       free_data_refs (datarefs);\n     }\n   scev_reset ();\n-  rewrite_into_ssa (false);\n+  update_ssa (TODO_update_ssa);\n   rewrite_into_loop_closed_ssa (NULL);\n-#ifdef ENABLE_CHECKING\n-  verify_loop_closed_ssa ();\n-#endif\n }"}, {"sha": "34ed9794367140148df7aad25f98a8d7389b0b8c", "filename": "gcc/tree-optimize.c", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftree-optimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftree-optimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-optimize.c?ref=0bca51f080dfff5e943b1f1775d874a73bbc441a", "patch": "@@ -52,7 +52,6 @@ Boston, MA 02111-1307, USA.  */\n \n /* Global variables used to communicate with passes.  */\n int dump_flags;\n-bitmap vars_to_rename;\n bool in_gimple_form;\n \n /* The root of the compilation pass tree, once constructed.  */\n@@ -355,8 +354,9 @@ init_tree_optimization_passes (void)\n   NEXT_PASS (pass_early_warn_uninitialized);\n   NEXT_PASS (pass_dce);\n   NEXT_PASS (pass_dominator);\n-  NEXT_PASS (pass_redundant_phi);\n+  NEXT_PASS (pass_copy_prop);\n   NEXT_PASS (pass_dce);\n+  NEXT_PASS (pass_vrp);\n   NEXT_PASS (pass_merge_phi);\n   NEXT_PASS (pass_forwprop);\n   NEXT_PASS (pass_phiopt);\n@@ -371,14 +371,14 @@ init_tree_optimization_passes (void)\n   NEXT_PASS (pass_may_alias);\n   NEXT_PASS (pass_rename_ssa_copies);\n   NEXT_PASS (pass_dominator);\n-  NEXT_PASS (pass_redundant_phi);\n+  NEXT_PASS (pass_copy_prop);\n   NEXT_PASS (pass_dce);\n   NEXT_PASS (pass_dse);\n   NEXT_PASS (pass_may_alias);\n   NEXT_PASS (pass_forwprop);\n   NEXT_PASS (pass_phiopt);\n-  NEXT_PASS (pass_ccp);\n-  NEXT_PASS (pass_redundant_phi);\n+  NEXT_PASS (pass_store_ccp);\n+  NEXT_PASS (pass_store_copy_prop);\n   NEXT_PASS (pass_fold_builtins);\n   /* FIXME: May alias should a TODO but for 4.0.0,\n      we add may_alias right after fold builtins\n@@ -389,7 +389,7 @@ init_tree_optimization_passes (void)\n   NEXT_PASS (pass_sink_code);\n   NEXT_PASS (pass_loop);\n   NEXT_PASS (pass_dominator);\n-  NEXT_PASS (pass_redundant_phi);\n+  NEXT_PASS (pass_copy_prop);\n   /* FIXME: If DCE is not run before checking for uninitialized uses,\n      we may get false warnings (e.g., testsuite/gcc.dg/uninit-5.c).\n      However, this also causes us to misdiagnose cases that should be\n@@ -415,6 +415,7 @@ init_tree_optimization_passes (void)\n \n   p = &pass_loop.sub;\n   NEXT_PASS (pass_loop_init);\n+  NEXT_PASS (pass_copy_prop);\n   NEXT_PASS (pass_lim);\n   NEXT_PASS (pass_unswitch);\n   NEXT_PASS (pass_record_bounds);\n@@ -443,15 +444,15 @@ execute_todo (struct tree_opt_pass *pass, unsigned int flags, bool use_required)\n   int properties \n     = use_required ? pass->properties_required : pass->properties_provided;\n \n-  if (flags & TODO_rename_vars)\n-    {\n-      rewrite_into_ssa (false);\n-      bitmap_clear (vars_to_rename);\n-    }\n-  if (flags & TODO_fix_def_def_chains)\n+#if defined ENABLE_CHECKING\n+  if (need_ssa_update_p ())\n+    gcc_assert (flags & TODO_update_ssa_any);\n+#endif\n+\n+  if (flags & TODO_update_ssa_any)\n     {\n-      rewrite_def_def_chains ();\n-      bitmap_clear (vars_to_rename);\n+      unsigned update_flags = flags & TODO_update_ssa_any;\n+      update_ssa (update_flags);\n     }\n \n   if (flags & TODO_cleanup_cfg)\n@@ -482,15 +483,16 @@ execute_todo (struct tree_opt_pass *pass, unsigned int flags, bool use_required)\n       ggc_collect ();\n     }\n \n-#ifdef ENABLE_CHECKING\n+#if defined ENABLE_CHECKING\n   if ((pass->properties_required & PROP_ssa)\n       && !(pass->properties_destroyed & PROP_ssa))\n-    verify_ssa  (true);\n-\n+    verify_ssa (true);\n   if (flags & TODO_verify_flow)\n     verify_flow_info ();\n   if (flags & TODO_verify_stmts)\n     verify_stmts ();\n+  if (flags & TODO_verify_loops)\n+    verify_loop_closed_ssa ();\n #endif\n }\n \n@@ -687,8 +689,6 @@ tree_rest_of_compilation (tree fndecl)\n   bitmap_obstack_initialize (NULL);\n   bitmap_obstack_initialize (&reg_obstack); /* FIXME, only at RTL generation*/\n   \n-  vars_to_rename = BITMAP_ALLOC (NULL);\n-  \n   /* Perform all tree transforms and optimizations.  */\n   execute_pass_list (all_passes);\n   "}, {"sha": "f2e4cb2953080d93c04b93744e9e7c2df15ec978", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 54, "deletions": 11, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=0bca51f080dfff5e943b1f1775d874a73bbc441a", "patch": "@@ -28,8 +28,6 @@ extern FILE *dump_file;\n extern int dump_flags;\n extern const char *dump_file_name;\n \n-extern struct bitmap_head_def *vars_to_rename;\n-\n /* Return the dump_file_info for the given phase.  */\n extern struct dump_file_info *get_dump_file_info (enum tree_dump_index);\n \n@@ -101,19 +99,60 @@ struct dump_file_info\n   (PROP_gimple_any | PROP_gimple_lcf | PROP_gimple_leh)\n \n /* To-do flags.  */\n-#define TODO_dump_func\t\t(1 << 0)\t/* pass doesn't dump itself */\n-#define TODO_rename_vars\t(1 << 1)\t/* rewrite new vars to ssa */\n-#define TODO_ggc_collect\t(1 << 2)\t/* run the collector */\n-#define TODO_verify_ssa\t\t(1 << 3)\n-#define TODO_verify_flow\t(1 << 4)\n-#define TODO_verify_stmts\t(1 << 5)\n-#define TODO_fix_def_def_chains (1 << 6)        /* rewrite def-def chains  */\n-#define TODO_cleanup_cfg        (1 << 7)        /* cleanup the cfg.  */\n+#define TODO_dump_func\t\t\t(1 << 0)\n+#define TODO_ggc_collect\t\t(1 << 1)\n+#define TODO_verify_ssa\t\t\t(1 << 2) \n+#define TODO_verify_flow\t\t(1 << 3)\n+#define TODO_verify_stmts\t\t(1 << 4)\n+#define TODO_cleanup_cfg        \t(1 << 5)\n+#define TODO_verify_loops\t\t(1 << 6)\n+\n+/* To-do flags for calls to update_ssa.  */\n+\n+/* Update the SSA form inserting PHI nodes for newly exposed symbols\n+   and virtual names marked for updating.  When updating real names,\n+   only insert PHI nodes for a real name O_j in blocks reached by all\n+   the new and old definitions for O_j.  If the iterated dominance\n+   frontier for O_j is not pruned, we may end up inserting PHI nodes\n+   in blocks that have one or more edges with no incoming definition\n+   for O_j.  This would lead to uninitialized warnings for O_j's\n+   symbol.  */\n+#define TODO_update_ssa\t\t\t(1 << 7)\n+\n+/* Update the SSA form without inserting any new PHI nodes at all.\n+   This is used by passes that have either inserted all the PHI nodes\n+   themselves or passes that need only to patch use-def and def-def\n+   chains for virtuals (e.g., DCE).  */\n+#define TODO_update_ssa_no_phi\t\t(1 << 8)\n+\n+/* Insert PHI nodes everywhere they are needed.  No prunning of the\n+   IDF is done.  This is used by passes that need the PHI nodes for\n+   O_j even if it means that some arguments will come from the default\n+   definition of O_j's symbol (e.g., pass_linear_transform).\n+   \n+   WARNING: If you need to use this flag, chances are that your pass\n+   may be doing something wrong.  Inserting PHI nodes for an old name\n+   where not all edges carry a new replacement may lead to silent\n+   codegen errors or spurious uninitialized warnings.  */\n+#define TODO_update_ssa_full_phi\t(1 << 9)\n+\n+/* Passes that update the SSA form on their own may want to delegate\n+   the updating of virtual names to the generic updater.  Since FUD\n+   chains are easier to maintain, this simplifies the work they need\n+   to do.  NOTE: If this flag is used, any OLD->NEW mappings for real\n+   names are explicitly destroyed and only the symbols marked for\n+   renaming are processed.  */\n+#define TODO_update_ssa_only_virtuals\t(1 << 10)\n+\n+#define TODO_update_ssa_any\t\t\\\n+    (TODO_update_ssa\t\t\t\\\n+     | TODO_update_ssa_no_phi\t\t\\\n+     | TODO_update_ssa_full_phi\t\t\\\n+     | TODO_update_ssa_only_virtuals)\n \n #define TODO_verify_all \\\n   (TODO_verify_ssa | TODO_verify_flow | TODO_verify_stmts)\n \n-\n extern struct tree_opt_pass pass_mudflap_1;\n extern struct tree_opt_pass pass_mudflap_2;\n extern struct tree_opt_pass pass_remove_useless_stmts;\n@@ -167,6 +206,10 @@ extern struct tree_opt_pass pass_rest_of_compilation;\n extern struct tree_opt_pass pass_sink_code;\n extern struct tree_opt_pass pass_fre;\n extern struct tree_opt_pass pass_linear_transform;\n+extern struct tree_opt_pass pass_copy_prop;\n+extern struct tree_opt_pass pass_store_ccp;\n+extern struct tree_opt_pass pass_store_copy_prop;\n+extern struct tree_opt_pass pass_vrp;\n extern struct tree_opt_pass pass_create_structure_vars;\n \n #endif /* GCC_TREE_PASS_H */"}, {"sha": "929480f80c03cfe393cbeee7ca8896faf10c2bd2", "filename": "gcc/tree-phinodes.c", "status": "modified", "additions": 18, "deletions": 49, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftree-phinodes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftree-phinodes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-phinodes.c?ref=0bca51f080dfff5e943b1f1775d874a73bbc441a", "patch": "@@ -197,10 +197,8 @@ ideal_phi_node_len (int len)\n   return new_len;\n }\n \n-/* Return a PHI node for variable VAR defined in statement STMT.\n-   STMT may be an empty statement for artificial references (e.g., default\n-   definitions created when a variable is used without a preceding\n-   definition).  */\n+\n+/* Return a PHI node with LEN argument slots for variable VAR.  */\n \n static tree\n make_phi_node (tree var, int len)\n@@ -468,58 +466,30 @@ remove_phi_node (tree phi, tree prev)\n }\n \n \n-/* Remove all the PHI nodes for variables in the VARS bitmap.  */\n+/* Find the first PHI node P in basic block BB for symbol SYM.  If\n+   PREV_P is given, the PHI node preceding P is stored in *PREV_P.  */\n \n-void\n-remove_all_phi_nodes_for (bitmap vars)\n+tree\n+find_phi_node_for (basic_block bb, tree sym, tree *prev_p)\n {\n-  basic_block bb;\n-\n-  FOR_EACH_BB (bb)\n-    {\n-      /* Build a new PHI list for BB without variables in VARS.  */\n-      tree phi, new_phi_list, next;\n-      tree *lastp = &new_phi_list;\n+  tree phi;\n \n-      for (phi = phi_nodes (bb); phi; phi = next)\n-\t{\n-\t  tree var = SSA_NAME_VAR (PHI_RESULT (phi));\n-\n-\t  next = PHI_CHAIN (phi);\n-\t  /* Only add PHI nodes for variables not in VARS.  */\n-\t  if (!bitmap_bit_p (vars, var_ann (var)->uid))\n-\t    {\n-\t      /* If we're not removing this PHI node, then it must have\n-\t\t been rewritten by a previous call into the SSA rewriter.\n-\t\t Note that fact in PHI_REWRITTEN.  */\n-\t      PHI_REWRITTEN (phi) = 1;\n-\n-\t      *lastp = phi;\n-\t      lastp = &PHI_CHAIN (phi);\n-\t    }\n-\t  else\n-\t    {\n-\t      /* If we are deleting the PHI node, then we should release the\n-\t\t SSA_NAME node so that it can be reused.  */\n-\t      release_phi_node (phi);\n-\t      release_ssa_name (PHI_RESULT (phi));\n-\t    }\n-\t}\n+  if (prev_p)\n+    *prev_p = NULL_TREE;\n \n-      /* Make sure the last node in the new list has no successors.  */\n-      *lastp = NULL;\n-      bb_ann (bb)->phi_nodes = new_phi_list;\n+  for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n+    {\n+      if (SSA_NAME_VAR (PHI_RESULT (phi)) == sym)\n+\treturn phi;\n \n-#if defined ENABLE_CHECKING\n-      for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n-\t{\n-\t  tree var = SSA_NAME_VAR (PHI_RESULT (phi));\n-\t  gcc_assert (!bitmap_bit_p (vars, var_ann (var)->uid));\n-\t}\n-#endif\n+      if (prev_p)\n+\t*prev_p = phi;\n     }\n+\n+  return NULL_TREE;\n }\n \n+\n /* Reverse the order of PHI nodes in the chain PHI.\n    Return the new head of the chain (old last PHI node).  */\n \n@@ -537,4 +507,3 @@ phi_reverse (tree phi)\n }\n \n #include \"gt-tree-phinodes.h\"\n-"}, {"sha": "598cc907819b3afc18fbeab62a0d6650d9276ce8", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=0bca51f080dfff5e943b1f1775d874a73bbc441a", "patch": "@@ -1430,6 +1430,14 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n       pp_printf (buffer, \"VH.%d\", VALUE_HANDLE_ID (node));\n       break;\n \n+    case ASSERT_EXPR:\n+      pp_string (buffer, \"ASSERT_EXPR <\");\n+      dump_generic_node (buffer, ASSERT_EXPR_VAR (node), spc, flags, false);\n+      pp_string (buffer, \", \");\n+      dump_generic_node (buffer, ASSERT_EXPR_COND (node), spc, flags, false);\n+      pp_string (buffer, \">\");\n+      break;\n+\n     case SCEV_KNOWN:\n       pp_string (buffer, \"scev_known\");\n       break;"}, {"sha": "ffead4903b778513c918fad890ec09d0154871bd", "filename": "gcc/tree-scalar-evolution.c", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftree-scalar-evolution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftree-scalar-evolution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.c?ref=0bca51f080dfff5e943b1f1775d874a73bbc441a", "patch": "@@ -1065,8 +1065,8 @@ follow_ssa_edge_in_rhs (struct loop *loop,\n      - an INTEGER_CST,\n      - a PLUS_EXPR, \n      - a MINUS_EXPR,\n-     - other cases are not yet handled. \n-  */\n+     - an ASSERT_EXPR,\n+     - other cases are not yet handled.  */\n   switch (TREE_CODE (rhs))\n     {\n     case NOP_EXPR:\n@@ -1247,6 +1247,20 @@ follow_ssa_edge_in_rhs (struct loop *loop,\n       \n       break;\n \n+    case ASSERT_EXPR:\n+      {\n+\t/* This assignment is of the form: \"a_1 = ASSERT_EXPR <a_2, ...>\"\n+\t   It must be handled as a copy assignment of the form a_1 = a_2.  */\n+\ttree op0 = ASSERT_EXPR_VAR (rhs);\n+\tif (TREE_CODE (op0) == SSA_NAME)\n+\t  res = follow_ssa_edge (loop, SSA_NAME_DEF_STMT (op0),\n+\t\t\t\t halting_phi, evolution_of_loop);\n+\telse\n+\t  res = false;\n+\tbreak;\n+      }\n+\n+\n     default:\n       res = false;\n       break;\n@@ -1701,6 +1715,11 @@ interpret_rhs_modify_expr (struct loop *loop,\n     case SSA_NAME:\n       res = chrec_convert (type, analyze_scalar_evolution (loop, opnd1));\n       break;\n+\n+    case ASSERT_EXPR:\n+      opnd10 = ASSERT_EXPR_VAR (opnd1);\n+      res = chrec_convert (type, analyze_scalar_evolution (loop, opnd10));\n+      break;\n       \n     case NOP_EXPR:\n     case CONVERT_EXPR:"}, {"sha": "1ca629fe5d079d3755e3eeefa9124859243644e3", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 38, "deletions": 9, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=0bca51f080dfff5e943b1f1775d874a73bbc441a", "patch": "@@ -1428,6 +1428,8 @@ decide_instantiations (void)\n     }\n   bitmap_clear (&done_head);\n \n+  mark_set_for_renaming (sra_candidates);\n+\n   if (dump_file)\n     fputc ('\\n', dump_file);\n }\n@@ -1439,7 +1441,7 @@ decide_instantiations (void)\n    renaming. This becomes necessary when we modify all of a non-scalar.  */\n \n static void\n-mark_all_v_defs (tree stmt)\n+mark_all_v_defs_1 (tree stmt)\n {\n   tree sym;\n   ssa_op_iter iter;\n@@ -1450,10 +1452,28 @@ mark_all_v_defs (tree stmt)\n     {\n       if (TREE_CODE (sym) == SSA_NAME)\n \tsym = SSA_NAME_VAR (sym);\n-      bitmap_set_bit (vars_to_rename, var_ann (sym)->uid);\n+      mark_sym_for_renaming (sym);\n+    }\n+}\n+\n+\n+/* Mark all the variables in virtual operands in all the statements in\n+   LIST for renaming.  */\n+\n+static void\n+mark_all_v_defs (tree list)\n+{\n+  if (TREE_CODE (list) != STATEMENT_LIST)\n+    mark_all_v_defs_1 (list);\n+  else\n+    {\n+      tree_stmt_iterator i;\n+      for (i = tsi_start (list); !tsi_end_p (i); tsi_next (&i))\n+\tmark_all_v_defs_1 (tsi_stmt (i));\n     }\n }\n \n+\n /* Build a single level component reference to ELT rooted at BASE.  */\n \n static tree\n@@ -1706,7 +1726,7 @@ generate_element_init (struct sra_elt *elt, tree init, tree *list_p)\n \n       new = num_referenced_vars;\n       for (j = old; j < new; ++j)\n-\tbitmap_set_bit (vars_to_rename, j);\n+\tmark_sym_for_renaming (referenced_var (j));\n     }\n \n   return ret;\n@@ -1820,7 +1840,7 @@ scalarize_use (struct sra_elt *elt, tree *expr_p, block_stmt_iterator *bsi,\n       generate_copy_inout (elt, is_output, generate_element_ref (elt), &list);\n       if (list == NULL)\n \treturn;\n-      mark_all_v_defs (expr_first (list));\n+      mark_all_v_defs (list);\n       if (is_output)\n \tsra_insert_after (bsi, list);\n       else\n@@ -1865,15 +1885,18 @@ scalarize_copy (struct sra_elt *lhs_elt, struct sra_elt *rhs_elt,\n \t\t\t   generate_element_ref (rhs_elt), &list);\n       if (list)\n \t{\n-\t  mark_all_v_defs (expr_first (list));\n+\t  mark_all_v_defs (list);\n \t  sra_insert_before (bsi, list);\n \t}\n \n       list = NULL;\n       generate_copy_inout (lhs_elt, true,\n \t\t\t   generate_element_ref (lhs_elt), &list);\n       if (list)\n-\tsra_insert_after (bsi, list);\n+\t{\n+\t  mark_all_v_defs (list);\n+\t  sra_insert_after (bsi, list);\n+\t}\n     }\n   else\n     {\n@@ -1887,6 +1910,7 @@ scalarize_copy (struct sra_elt *lhs_elt, struct sra_elt *rhs_elt,\n       list = NULL;\n       generate_element_copy (lhs_elt, rhs_elt, &list);\n       gcc_assert (list);\n+      mark_all_v_defs (list);\n       sra_replace (bsi, list);\n     }\n }\n@@ -1936,7 +1960,7 @@ scalarize_init (struct sra_elt *lhs_elt, tree rhs, block_stmt_iterator *bsi)\n \t exposes constants to later optimizations.  */\n       if (list)\n \t{\n-\t  mark_all_v_defs (expr_first (list));\n+\t  mark_all_v_defs (list);\n \t  sra_insert_after (bsi, list);\n \t}\n     }\n@@ -1946,6 +1970,7 @@ scalarize_init (struct sra_elt *lhs_elt, tree rhs, block_stmt_iterator *bsi)\n \t replaces the original structure assignment.  */\n       gcc_assert (list);\n       mark_all_v_defs (bsi_stmt (*bsi));\n+      mark_all_v_defs (list);\n       sra_replace (bsi, list);\n     }\n }\n@@ -1996,6 +2021,7 @@ scalarize_ldst (struct sra_elt *elt, tree other,\n \n       mark_all_v_defs (stmt);\n       generate_copy_inout (elt, is_output, other, &list);\n+      mark_all_v_defs (list);\n       gcc_assert (list);\n \n       /* Preserve EH semantics.  */\n@@ -2051,7 +2077,10 @@ scalarize_parms (void)\n     }\n \n   if (list)\n-    insert_edge_copies (list, ENTRY_BLOCK_PTR);\n+    {\n+      insert_edge_copies (list, ENTRY_BLOCK_PTR);\n+      mark_all_v_defs (list);\n+    }\n }\n \n /* Entry point to phase 4.  Update the function to match replacements.  */\n@@ -2154,7 +2183,7 @@ struct tree_opt_pass pass_sra =\n   0,\t\t\t\t\t/* properties_provided */\n   0,\t\t\t\t\t/* properties_destroyed */\n   0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_dump_func | TODO_rename_vars\n+  TODO_dump_func | TODO_update_ssa\n     | TODO_ggc_collect | TODO_verify_ssa,  /* todo_flags_finish */\n   0\t\t\t\t\t/* letter */\n };"}, {"sha": "de39ed128f4acac6c25fb26494974c73de97742e", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 104, "deletions": 17, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=0bca51f080dfff5e943b1f1775d874a73bbc441a", "patch": "@@ -371,7 +371,7 @@ struct tree_opt_pass pass_may_alias =\n   PROP_alias,\t\t\t\t/* properties_provided */\n   0,\t\t\t\t\t/* properties_destroyed */\n   0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_dump_func | TODO_rename_vars\n+  TODO_dump_func | TODO_update_ssa\n     | TODO_ggc_collect | TODO_verify_ssa\n     | TODO_verify_stmts, \t\t/* todo_flags_finish */\n   0\t\t\t\t\t/* letter */\n@@ -407,7 +407,7 @@ count_ptr_derefs (tree *tp, int *walk_subtrees ATTRIBUTE_UNUSED, void *data)\n    *NUM_DEREFS_P respectively.  *IS_STORE_P is set to 'true' if at\n    least one of those dereferences is a store operation.  */\n \n-static void\n+void\n count_uses_and_derefs (tree ptr, tree stmt, unsigned *num_uses_p,\n \t\t       unsigned *num_derefs_p, bool *is_store)\n {\n@@ -770,7 +770,7 @@ compute_points_to_and_addr_escape (struct alias_info *ai)\n \t  /* Mark variables in V_MAY_DEF operands as being written to.  */\n \t  FOR_EACH_SSA_TREE_OPERAND (op, stmt, iter, SSA_OP_VIRTUAL_DEFS)\n \t    {\n-\t      tree var = SSA_NAME_VAR (op);\n+\t      tree var = DECL_P (op) ? op : SSA_NAME_VAR (op);\n \t      var_ann_t ann = var_ann (var);\n \t      bitmap_set_bit (ai->written_vars, ann->uid);\n \t    }\n@@ -855,7 +855,7 @@ create_name_tags (struct alias_info *ai)\n \t     needs to be removed from the IL, so we mark it for\n \t     renaming.  */\n \t  if (old_name_tag && old_name_tag != pi->name_mem_tag)\n-\t    bitmap_set_bit (vars_to_rename, var_ann (old_name_tag)->uid);\n+\t    mark_sym_for_renaming (old_name_tag);\n \t}\n       else if (pi->pt_malloc)\n \t{\n@@ -875,7 +875,7 @@ create_name_tags (struct alias_info *ai)\n \t  |= TREE_THIS_VOLATILE (TREE_TYPE (TREE_TYPE (ptr)));\n \n       /* Mark the new name tag for renaming.  */\n-      bitmap_set_bit (vars_to_rename, var_ann (pi->name_mem_tag)->uid);\n+      mark_sym_for_renaming (pi->name_mem_tag);\n     }\n }\n \n@@ -1000,7 +1000,11 @@ compute_flow_insensitive_aliasing (struct alias_info *ai)\n \t\t\t || bitmap_bit_p (ai->written_vars, v_ann->uid);\n \t  if (!tag_stored_p && !var_stored_p)\n \t    continue;\n-\t     \n+\n+\t  if ((unmodifiable_var_p (tag) && !unmodifiable_var_p (var))\n+\t      || (unmodifiable_var_p (var) && !unmodifiable_var_p (tag)))\n+\t    continue;\n+\n \t  if (may_alias_p (p_map->var, p_map->set, var, v_map->set))\n \t    {\n \t      subvar_t svars;\n@@ -1449,9 +1453,10 @@ setup_pointers_and_addressables (struct alias_info *ai)\n \t      && !is_global_var (var))\n \t    {\n \t      bool okay_to_mark = true;\n+\n \t      /* Since VAR is now a regular GIMPLE register, we will need\n \t\t to rename VAR into SSA afterwards.  */\n-\t      bitmap_set_bit (vars_to_rename, v_ann->uid);\n+\t      mark_sym_for_renaming (var);\n \n \t      if (var_can_have_subvars (var)\n \t\t  && (svars = get_subvars_for_var (var)))\n@@ -1463,15 +1468,15 @@ setup_pointers_and_addressables (struct alias_info *ai)\n \t\t      var_ann_t svann = var_ann (sv->var);\n \t\t      if (bitmap_bit_p (ai->addresses_needed, svann->uid))\n \t\t\tokay_to_mark = false;\n-\t\t      bitmap_set_bit (vars_to_rename, svann->uid);\n+\t\t      mark_sym_for_renaming (sv->var);\n \t\t    }\n \t\t}\n+\n \t      /* The address of VAR is not needed, remove the\n \t\t addressable bit, so that it can be optimized as a\n \t\t regular variable.  */\n \t      if (okay_to_mark)\n \t\tmark_non_addressable (var);\n-\n \t    }\n \t  else\n \t    {\n@@ -1496,7 +1501,7 @@ setup_pointers_and_addressables (struct alias_info *ai)\n       if (may_be_aliased (var))\n \t{\n \t  create_alias_map_for (var, ai);\n-\t  bitmap_set_bit (vars_to_rename, var_ann (var)->uid);\t  \n+\t  mark_sym_for_renaming (var);\n \t}\n \n       /* Add pointer variables that have been dereferenced to the POINTERS\n@@ -1519,7 +1524,13 @@ setup_pointers_and_addressables (struct alias_info *ai)\n \t\t afterwards. Note that we cannot do this inside\n \t\t get_tmt_for because aliasing may run multiple times\n \t\t and we only create type tags the first time.  */\n-\t      bitmap_set_bit (vars_to_rename, t_ann->uid);\n+\t      mark_sym_for_renaming (tag);\n+\n+\t      /* Similarly, if pointer VAR used to have another type\n+\t\t tag, we will need to process it in the renamer to\n+\t\t remove the stale virtual operands.  */\n+\t      if (v_ann->type_mem_tag)\n+\t\tmark_sym_for_renaming (v_ann->type_mem_tag);\n \n \t      /* Associate the tag with pointer VAR.  */\n \t      v_ann->type_mem_tag = tag;\n@@ -1555,7 +1566,7 @@ setup_pointers_and_addressables (struct alias_info *ai)\n \t      tree tag = ann->type_mem_tag;\n \t      if (tag)\n \t\t{\n-\t\t  bitmap_set_bit (vars_to_rename, var_ann (tag)->uid);\n+\t\t  mark_sym_for_renaming (tag);\n \t\t  ann->type_mem_tag = NULL_TREE;\n \t\t}\n \t    }\n@@ -1661,11 +1672,11 @@ maybe_create_global_var (struct alias_info *ai)\n \t    {\n \t      subvar_t sv;\n \t      for (sv = svars; sv; sv = sv->next)\n-\t\tbitmap_set_bit (vars_to_rename, var_ann (sv->var)->uid);\n+\t\tmark_sym_for_renaming (sv->var);\n \t    }\n \t}\n       \n-      bitmap_set_bit (vars_to_rename, var_ann (var)->uid);\n+      mark_sym_for_renaming (var);\n     }\n }\n \n@@ -1802,7 +1813,7 @@ set_pt_anything (tree ptr)\n      disassociated from PTR.  */\n   if (pi->name_mem_tag)\n     {\n-      bitmap_set_bit (vars_to_rename, var_ann (pi->name_mem_tag)->uid);\n+      mark_sym_for_renaming (pi->name_mem_tag);\n       pi->name_mem_tag = NULL_TREE;\n     }\n }\n@@ -2358,7 +2369,7 @@ create_global_var (void)\n   TREE_ADDRESSABLE (global_var) = 0;\n \n   add_referenced_tmp_var (global_var);\n-  bitmap_set_bit (vars_to_rename, var_ann (global_var)->uid);\n+  mark_sym_for_renaming (global_var);\n }\n \n \n@@ -2673,6 +2684,83 @@ may_be_aliased (tree var)\n   return true;\n }\n \n+\n+/* Add VAR to the list of may-aliases of PTR's type tag.  If PTR\n+   doesn't already have a type tag, create one.  */\n+\n+void\n+add_type_alias (tree ptr, tree var)\n+{\n+  varray_type aliases;\n+  tree tag;\n+  var_ann_t ann = var_ann (ptr);\n+\n+  if (ann->type_mem_tag == NULL_TREE)\n+    {\n+      size_t i;\n+      tree q = NULL_TREE;\n+      tree tag_type = TREE_TYPE (TREE_TYPE (ptr));\n+      HOST_WIDE_INT tag_set = get_alias_set (tag_type);\n+\n+      /* PTR doesn't have a type tag, create a new one and add VAR to\n+\t the new tag's alias set.\n+\n+\t FIXME, This is slower than necessary.  We need to determine\n+\t whether there is another pointer Q with the same alias set as\n+\t PTR.  This could be sped up by having type tags associated\n+\t with types.  */\n+      for (i = 0; i < num_referenced_vars; i++)\n+\t{\n+\t  q = referenced_var (i);\n+\n+\t  if (POINTER_TYPE_P (TREE_TYPE (q))\n+\t      && tag_set == get_alias_set (TREE_TYPE (TREE_TYPE (q))))\n+\t    {\n+\t      /* Found another pointer Q with the same alias set as\n+\t\t the PTR's pointed-to type.  If Q has a type tag, use\n+\t\t it.  Otherwise, create a new memory tag for PTR.  */\n+\t      var_ann_t ann1 = var_ann (q);\n+\t      if (ann1->type_mem_tag)\n+\t\tann->type_mem_tag = ann1->type_mem_tag;\n+\t      else\n+\t\tann->type_mem_tag = create_memory_tag (tag_type, true);\n+\t      goto found_tag;\n+\t    }\n+\t}\n+\n+      /* Couldn't find any other pointer with a type tag we could use.\n+\t Create a new memory tag for PTR.  */\n+      ann->type_mem_tag = create_memory_tag (tag_type, true);\n+    }\n+\n+found_tag:\n+  /* If VAR is not already PTR's type tag, add it to the may-alias set\n+     for PTR's type tag.  */\n+  gcc_assert (var_ann (var)->type_mem_tag == NOT_A_TAG);\n+  tag = ann->type_mem_tag;\n+  add_may_alias (tag, var);\n+\n+  /* TAG and its set of aliases need to be marked for renaming.  */\n+  mark_sym_for_renaming (tag);\n+  if ((aliases = var_ann (tag)->may_aliases) != NULL)\n+    {\n+      size_t i;\n+      for (i = 0; i < VARRAY_ACTIVE_SIZE (aliases); i++)\n+\tmark_sym_for_renaming (VARRAY_TREE (aliases, i));\n+    }\n+\n+  /* If we had grouped aliases, VAR may have aliases of its own.  Mark\n+     them for renaming as well.  Other statements referencing the\n+     aliases of VAR will need to be updated.  */\n+  if ((aliases = var_ann (var)->may_aliases) != NULL)\n+    {\n+      size_t i;\n+      for (i = 0; i < VARRAY_ACTIVE_SIZE (aliases); i++)\n+\tmark_sym_for_renaming (VARRAY_TREE (aliases, i));\n+    }\n+}\n+\n+\n /* This structure is simply used during pushing fields onto the fieldstack\n    to track the offset of the field, since bitpos_of_field gives it relative\n    to its immediate containing type, and we want it relative to the ultimate\n@@ -3168,4 +3256,3 @@ struct tree_opt_pass pass_create_structure_vars =\n   TODO_dump_func,\t /* todo_flags_finish */\n   0\t\t\t /* letter */\n };\n-"}, {"sha": "443d8dca87982dee289d4398448361da4d5d0291", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 630, "deletions": 548, "changes": 1178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=0bca51f080dfff5e943b1f1775d874a73bbc441a", "patch": "@@ -21,7 +21,161 @@ along with GCC; see the file COPYING.  If not, write to the Free\n Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n 02111-1307, USA.  */\n \n-/* Conditional constant propagation.\n+/* Conditional constant propagation (CCP) is based on the SSA\n+   propagation engine (tree-ssa-propagate.c).  Constant assignments of\n+   the form VAR = CST are propagated from the assignments into uses of\n+   VAR, which in turn may generate new constants.  The simulation uses\n+   a four level lattice to keep track of constant values associated\n+   with SSA names.  Given an SSA name V_i, it may take one of the\n+   following values:\n+\n+   \tUNINITIALIZED\t->  This is the default starting value.  V_i\n+\t\t\t    has not been processed yet.\n+\n+\tUNDEFINED\t->  V_i is a local variable whose definition\n+\t\t\t    has not been processed yet.  Therefore we\n+\t\t\t    don't yet know if its value is a constant\n+\t\t\t    or not.\n+\n+\tCONSTANT\t->  V_i has been found to hold a constant\n+\t\t\t    value C.\n+\n+\tVARYING\t\t->  V_i cannot take a constant value, or if it\n+\t\t\t    does, it is not possible to determine it\n+\t\t\t    at compile time.\n+\n+   The core of SSA-CCP is in ccp_visit_stmt and ccp_visit_phi_node:\n+\n+   1- In ccp_visit_stmt, we are interested in assignments whose RHS\n+      evaluates into a constant and conditional jumps whose predicate\n+      evaluates into a boolean true or false.  When an assignment of\n+      the form V_i = CONST is found, V_i's lattice value is set to\n+      CONSTANT and CONST is associated with it.  This causes the\n+      propagation engine to add all the SSA edges coming out the\n+      assignment into the worklists, so that statements that use V_i\n+      can be visited.\n+\n+      If the statement is a conditional with a constant predicate, we\n+      mark the outgoing edges as executable or not executable\n+      depending on the predicate's value.  This is then used when\n+      visiting PHI nodes to know when a PHI argument can be ignored.\n+      \n+\n+   2- In ccp_visit_phi_node, if all the PHI arguments evaluate to the\n+      same constant C, then the LHS of the PHI is set to C.  This\n+      evaluation is known as the \"meet operation\".  Since one of the\n+      goals of this evaluation is to optimistically return constant\n+      values as often as possible, it uses two main short cuts:\n+\n+      - If an argument is flowing in through a non-executable edge, it\n+\tis ignored.  This is useful in cases like this:\n+\n+\t\t\tif (PRED)\n+\t\t\t  a_9 = 3;\n+\t\t\telse\n+\t\t\t  a_10 = 100;\n+\t\t\ta_11 = PHI (a_9, a_10)\n+\n+\tIf PRED is known to always evaluate to false, then we can\n+\tassume that a_11 will always take its value from a_10, meaning\n+\tthat instead of consider it VARYING (a_9 and a_10 have\n+\tdifferent values), we can consider it CONSTANT 100.\n+\n+      - If an argument has an UNDEFINED value, then it does not affect\n+\tthe outcome of the meet operation.  If a variable V_i has an\n+\tUNDEFINED value, it means that either its defining statement\n+\thasn't been visited yet or V_i has no defining statement, in\n+\twhich case the original symbol 'V' is being used\n+\tuninitialized.  Since 'V' is a local variable, the compiler\n+\tmay assume any initial value for it.\n+\n+\n+   After propagation, every variable V_i that ends up with a lattice\n+   value of CONSTANT will have the associated constant value in the\n+   array CONST_VAL[i].VALUE.  That is fed into substitute_and_fold for\n+   final substitution and folding.\n+\n+\n+   Constant propagation in stores and loads (STORE-CCP)\n+   ----------------------------------------------------\n+\n+   While CCP has all the logic to propagate constants in GIMPLE\n+   registers, it is missing the ability to associate constants with\n+   stores and loads (i.e., pointer dereferences, structures and\n+   global/aliased variables).  We don't keep loads and stores in\n+   SSA, but we do build a factored use-def web for them (in the\n+   virtual operands).\n+\n+   For instance, consider the following code fragment:\n+\n+\t  struct A a;\n+\t  const int B = 42;\n+\n+\t  void foo (int i)\n+\t  {\n+\t    if (i > 10)\n+\t      a.a = 42;\n+\t    else\n+\t      {\n+\t\ta.b = 21;\n+\t\ta.a = a.b + 21;\n+\t      }\n+\n+\t    if (a.a != B)\n+\t      never_executed ();\n+\t  }\n+\n+   We should be able to deduce that the predicate 'a.a != B' is always\n+   false.  To achieve this, we associate constant values to the SSA\n+   names in the V_MAY_DEF and V_MUST_DEF operands for each store.\n+   Additionally, since we also glob partial loads/stores with the base\n+   symbol, we also keep track of the memory reference where the\n+   constant value was stored (in the MEM_REF field of PROP_VALUE_T).\n+   For instance,\n+\n+        # a_5 = V_MAY_DEF <a_4>\n+        a.a = 2;\n+\n+        # VUSE <a_5>\n+        x_3 = a.b;\n+\n+   In the example above, CCP will associate value '2' with 'a_5', but\n+   it would be wrong to replace the load from 'a.b' with '2', because\n+   '2' had been stored into a.a.\n+\n+   To support STORE-CCP, it is necessary to add a new value to the\n+   constant propagation lattice.  When evaluating a load for a memory\n+   reference we can no longer assume a value of UNDEFINED if we\n+   haven't seen a preceding store to the same memory location.\n+   Consider, for instance global variables:\n+\n+   \tint A;\n+\n+   \tfoo (int i)\n+  \t{\n+\t  if (i_3 > 10)\n+\t    A_4 = 3;\n+          # A_5 = PHI (A_4, A_2);\n+\n+\t  # VUSE <A_5>\n+\t  A.0_6 = A;\n+\n+\t  return A.0_6;\n+\t}\n+\n+   The value of A_2 cannot be assumed to be UNDEFINED, as it may have\n+   been defined outside of foo.  If we were to assume it UNDEFINED, we\n+   would erroneously optimize the above into 'return 3;'.  Therefore,\n+   when doing STORE-CCP, we introduce a fifth lattice value\n+   (UNKNOWN_VAL), which overrides any other value when computing the\n+   meet operation in PHI nodes.\n+\n+   Though STORE-CCP is not too expensive, it does have to do more work\n+   than regular CCP, so it is only enabled at -O2.  Both regular CCP\n+   and STORE-CCP use the exact same algorithm.  The only distinction\n+   is that when doing STORE-CCP, the boolean variable DO_STORE_CCP is\n+   set to true.  This affects the evaluation of statements and PHI\n+   nodes.\n \n    References:\n \n@@ -65,27 +219,29 @@ typedef enum\n   UNKNOWN_VAL,\n   CONSTANT,\n   VARYING\n-} latticevalue;\n+} ccp_lattice_t;\n \n-/* Main structure for CCP.  Contains the lattice value and, if it's a\n-    constant, the constant value.  */\n-typedef struct\n-{\n-  latticevalue lattice_val;\n-  tree const_val;\n-} value;\n+/* Array of propagated constant values.  After propagation,\n+   CONST_VAL[I].VALUE holds the constant value for SSA_NAME(I).  If\n+   the constant is held in an SSA name representing a memory store\n+   (i.e., a V_MAY_DEF or V_MUST_DEF), CONST_VAL[I].MEM_REF will\n+   contain the actual memory reference used to store (i.e., the LHS of\n+   the assignment doing the store).  */\n+prop_value_t *const_val;\n \n-/* This is used to track the current value of each variable.  */\n-static value *value_vector;\n+/* True if we are also propagating constants in stores and loads.  */\n+static bool do_store_ccp;\n \n-\n-/* Dump lattice value VAL to file OUTF prefixed by PREFIX.  */\n+/* Dump constant propagation value VAL to file OUTF prefixed by PREFIX.  */\n \n static void\n-dump_lattice_value (FILE *outf, const char *prefix, value val)\n+dump_lattice_value (FILE *outf, const char *prefix, prop_value_t val)\n {\n   switch (val.lattice_val)\n     {\n+    case UNINITIALIZED:\n+      fprintf (outf, \"%sUNINITIALIZED\", prefix);\n+      break;\n     case UNDEFINED:\n       fprintf (outf, \"%sUNDEFINED\", prefix);\n       break;\n@@ -97,177 +253,181 @@ dump_lattice_value (FILE *outf, const char *prefix, value val)\n       break;\n     case CONSTANT:\n       fprintf (outf, \"%sCONSTANT \", prefix);\n-      print_generic_expr (outf, val.const_val, dump_flags);\n+      print_generic_expr (outf, val.value, dump_flags);\n       break;\n     default:\n       gcc_unreachable ();\n     }\n }\n \n \n-/* Return a default value for variable VAR using the following rules:\n+/* Print lattice value VAL to stderr.  */\n+\n+void debug_lattice_value (prop_value_t val);\n+\n+void\n+debug_lattice_value (prop_value_t val)\n+{\n+  dump_lattice_value (stderr, \"\", val);\n+  fprintf (stderr, \"\\n\");\n+}\n \n-   1- Function arguments are considered VARYING.\n-   \n-   2- Global and static variables that are declared constant are\n-      considered CONSTANT.\n \n-   3- Any other virtually defined variable is considered UNKNOWN_VAL.\n+/* Compute a default value for variable VAR and store it in the\n+   CONST_VAL array.  The following rules are used to get default\n+   values:\n \n-   4- Any other value is considered UNDEFINED.  This is useful when\n+   1- Global and static variables that are declared constant are\n+      considered CONSTANT.\n+\n+   2- Any other value is considered UNDEFINED.  This is useful when\n       considering PHI nodes.  PHI arguments that are undefined do not\n       change the constant value of the PHI node, which allows for more\n-      constants to be propagated.  */\n+      constants to be propagated.\n \n-static value\n-get_default_value (tree var)\n-{\n-  value val;\n-  tree sym;\n+   3- If SSA_NAME_VALUE is set and it is a constant, its value is\n+      used.\n \n-  if (TREE_CODE (var) == SSA_NAME)\n-    sym = SSA_NAME_VAR (var);\n-  else\n-    {\n-      gcc_assert (DECL_P (var));\n-      sym = var;\n-    }\n+   4- Variables defined by statements other than assignments and PHI\n+      nodes are considered VARYING.\n \n-  val.lattice_val = UNDEFINED;\n-  val.const_val = NULL_TREE;\n+   5- Variables that are not GIMPLE registers are considered\n+      UNKNOWN_VAL, which is really a stronger version of UNDEFINED.\n+      It's used to avoid the short circuit evaluation implied by\n+      UNDEFINED in ccp_lattice_meet.  */\n \n-  if (TREE_CODE (var) == SSA_NAME\n-      && SSA_NAME_VALUE (var)\n-      && is_gimple_min_invariant (SSA_NAME_VALUE (var)))\n-    {\n-      val.lattice_val = CONSTANT;\n-      val.const_val = SSA_NAME_VALUE (var);\n-    }\n-  else if (TREE_CODE (sym) == PARM_DECL || TREE_THIS_VOLATILE (sym))\n+static prop_value_t\n+get_default_value (tree var)\n+{\n+  tree sym = SSA_NAME_VAR (var);\n+  prop_value_t val = { UNINITIALIZED, NULL_TREE, NULL_TREE };\n+\n+  if (!do_store_ccp && !is_gimple_reg (var))\n     {\n-      /* Function arguments and volatile variables are considered VARYING.  */\n+      /* Short circuit for regular CCP.  We are not interested in any\n+\t non-register when DO_STORE_CCP is false.  */\n       val.lattice_val = VARYING;\n     }\n-  else if (TREE_STATIC (sym))\n+  else if (SSA_NAME_VALUE (var)\n+\t   && is_gimple_min_invariant (SSA_NAME_VALUE (var)))\n     {\n-      /* Globals and static variables are considered UNKNOWN_VAL,\n-         unless they are declared 'const'.  */\n-      if (TREE_READONLY (sym)\n-\t  && DECL_INITIAL (sym)\n-\t  && is_gimple_min_invariant (DECL_INITIAL (sym)))\n-\t{\n-\t  val.lattice_val = CONSTANT;\n-\t  val.const_val = DECL_INITIAL (sym);\n-\t}\n-      else\n-        {\n-          val.const_val = NULL_TREE;\n-\t  val.lattice_val = UNKNOWN_VAL;\n-\t}\n+      val.lattice_val = CONSTANT;\n+      val.value = SSA_NAME_VALUE (var);\n     }\n-  else if (!is_gimple_reg (sym))\n+  else if (TREE_STATIC (sym)\n+\t   && TREE_READONLY (sym)\n+\t   && DECL_INITIAL (sym)\n+\t   && is_gimple_min_invariant (DECL_INITIAL (sym)))\n     {\n-      val.const_val = NULL_TREE;\n-      val.lattice_val = UNKNOWN_VAL;\n+      /* Globals and static variables declared 'const' take their\n+\t initial value.  */\n+      val.lattice_val = CONSTANT;\n+      val.value = DECL_INITIAL (sym);\n+      val.mem_ref = sym;\n     }\n   else\n     {\n-      enum tree_code code;\n       tree stmt = SSA_NAME_DEF_STMT (var);\n \n-      if (!IS_EMPTY_STMT (stmt))\n-        {\n-\t  code = TREE_CODE (stmt);\n-\t  if (code != MODIFY_EXPR && code != PHI_NODE)\n+      if (IS_EMPTY_STMT (stmt))\n+\t{\n+\t  /* Variables defined by an empty statement are those used\n+\t     before being initialized.  If VAR is a local variable, we\n+\t     can assume initially that it is UNDEFINED.  If we are\n+\t     doing STORE-CCP, function arguments and non-register\n+\t     variables are initially UNKNOWN_VAL, because we cannot\n+\t     discard the value incoming from outside of this function\n+\t     (see ccp_lattice_meet for details).  */\n+\t  if (is_gimple_reg (sym) && TREE_CODE (sym) != PARM_DECL)\n+\t    val.lattice_val = UNDEFINED;\n+\t  else if (do_store_ccp)\n+\t    val.lattice_val = UNKNOWN_VAL;\n+\t  else\n \t    val.lattice_val = VARYING;\n \t}\n+      else if (TREE_CODE (stmt) == MODIFY_EXPR\n+\t       || TREE_CODE (stmt) == PHI_NODE)\n+\t{\n+\t  /* Any other variable defined by an assignment or a PHI node\n+\t     is considered UNDEFINED (or UNKNOWN_VAL if VAR is not a\n+\t     GIMPLE register).  */\n+\t  val.lattice_val = is_gimple_reg (sym) ? UNDEFINED : UNKNOWN_VAL;\n+\t}\n+      else\n+\t{\n+\t  /* Otherwise, VAR will never take on a constant value.  */\n+\t  val.lattice_val = VARYING;\n+\t}\n     }\n \n   return val;\n }\n \n-/* Get the constant value associated with variable VAR.  */\n-\n-static value *\n-get_value (tree var)\n-{\n-  value *val;\n \n-  gcc_assert (TREE_CODE (var) == SSA_NAME);\n+/* Get the constant value associated with variable VAR.  If\n+   MAY_USE_DEFAULT_P is true, call get_default_value on variables that\n+   have the lattice value UNINITIALIZED.  */\n \n-  val = &value_vector[SSA_NAME_VERSION (var)];\n-  if (val->lattice_val == UNINITIALIZED)\n+static prop_value_t *\n+get_value (tree var, bool may_use_default_p)\n+{\n+  prop_value_t *val = &const_val[SSA_NAME_VERSION (var)];\n+  if (may_use_default_p && val->lattice_val == UNINITIALIZED)\n     *val = get_default_value (var);\n \n   return val;\n }\n \n \n-/* Set the lattice value for variable VAR to VAL.  Return true if VAL\n-   is different from VAR's previous value.  */\n+/* Set the value for variable VAR to NEW_VAL.  Return true if the new\n+   value is different from VAR's previous value.  */\n \n static bool\n-set_lattice_value (tree var, value val)\n+set_lattice_value (tree var, prop_value_t new_val)\n {\n-  value *old = get_value (var);\n-\n-  if (val.lattice_val == UNDEFINED)\n-    {\n-      /* CONSTANT->UNDEFINED is never a valid state transition.  */\n-      gcc_assert (old->lattice_val != CONSTANT);\n-\t\n-      /* UNKNOWN_VAL->UNDEFINED is never a valid state transition.  */\n-      gcc_assert (old->lattice_val != UNKNOWN_VAL);\n-\n-      /* VARYING->UNDEFINED is generally not a valid state transition,\n-\t except for values which are initialized to VARYING.  */\n-      gcc_assert (old->lattice_val != VARYING\n-\t\t  || get_default_value (var).lattice_val == VARYING);\n-    }\n-  else if (val.lattice_val == CONSTANT)\n-    /* VARYING -> CONSTANT is an invalid state transition, except\n-\tfor objects which start off in a VARYING state.  */\n-    gcc_assert (old->lattice_val != VARYING\n-\t\t|| get_default_value (var).lattice_val == VARYING);\n-\n-  /* If the constant for VAR has changed, then this VAR is really varying.  */\n-  if (old->lattice_val == CONSTANT\n-      && val.lattice_val == CONSTANT\n-      && !simple_cst_equal (old->const_val, val.const_val))\n-    {\n-      val.lattice_val = VARYING;\n-      val.const_val = NULL_TREE;\n-    }\n-\n-  if (old->lattice_val != val.lattice_val)\n+  prop_value_t *old_val = get_value (var, false);\n+\n+  /* Lattice transitions must always be monotonically increasing in\n+     value.  We allow two exceptions:\n+     \n+     1- If *OLD_VAL and NEW_VAL are the same, return false to\n+\tinform the caller that this was a non-transition.\n+\n+     2- If we are doing store-ccp (i.e., DOING_STORE_CCP is true),\n+\tallow CONSTANT->UNKNOWN_VAL.  The UNKNOWN_VAL state is a\n+\tspecial type of UNDEFINED state which prevents the short\n+\tcircuit evaluation of PHI arguments (see ccp_visit_phi_node\n+\tand ccp_lattice_meet).  */\n+  gcc_assert (old_val->lattice_val <= new_val.lattice_val\n+              || (old_val->lattice_val == new_val.lattice_val\n+\t\t  && old_val->value == new_val.value\n+\t\t  && old_val->mem_ref == new_val.mem_ref)\n+\t      || (do_store_ccp\n+\t\t  && old_val->lattice_val == CONSTANT\n+\t\t  && new_val.lattice_val == UNKNOWN_VAL));\n+\n+  if (old_val->lattice_val != new_val.lattice_val)\n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \t{\n-\t  dump_lattice_value (dump_file, \"Lattice value changed to \", val);\n-\t  fprintf (dump_file, \".  Adding definition to SSA edges.\\n\");\n+\t  dump_lattice_value (dump_file, \"Lattice value changed to \", new_val);\n+\t  fprintf (dump_file, \".  %sdding SSA edges to worklist.\\n\",\n+\t           new_val.lattice_val != UNDEFINED ? \"A\" : \"Not a\");\n \t}\n \n-      *old = val;\n-      return true;\n+      *old_val = new_val;\n+\n+      /* Transitions UNINITIALIZED -> UNDEFINED are never interesting\n+\t for propagation purposes.  In these cases return false to\n+\t avoid doing useless work.  */\n+      return (new_val.lattice_val != UNDEFINED);\n     }\n \n   return false;\n }\n \n \n-/* Set the lattice value for the variable VAR to VARYING.  */\n-\n-static void\n-def_to_varying (tree var)\n-{\n-  value val;\n-  val.lattice_val = VARYING;\n-  val.const_val = NULL_TREE;\n-  set_lattice_value (var, val);\n-}\n-\n-\n-/* Return the likely latticevalue for STMT.\n+/* Return the likely CCP lattice value for STMT.\n \n    If STMT has no operands, then return CONSTANT.\n \n@@ -277,57 +437,71 @@ def_to_varying (tree var)\n \n    Else return VARYING.  */\n \n-static latticevalue\n+static ccp_lattice_t\n likely_value (tree stmt)\n {\n-  vuse_optype vuses;\n-  int found_constant = 0;\n+  bool found_constant;\n   stmt_ann_t ann;\n   tree use;\n   ssa_op_iter iter;\n \n-  /* If the statement makes aliased loads or has volatile operands, it\n-     won't fold to a constant value.  */\n   ann = stmt_ann (stmt);\n-  if (ann->makes_aliased_loads || ann->has_volatile_ops)\n+\n+  /* If the statement has volatile operands, it won't fold to a\n+     constant value.  */\n+  if (ann->has_volatile_ops)\n+    return VARYING;\n+\n+  /* If we are not doing store-ccp, statements with loads\n+     and/or stores will never fold into a constant.  */\n+  if (!do_store_ccp\n+      && (ann->makes_aliased_stores\n+\t  || ann->makes_aliased_loads\n+\t  || NUM_VUSES (VUSE_OPS (ann)) > 0\n+\t  || NUM_V_MAY_DEFS (V_MAY_DEF_OPS (ann)) > 0\n+\t  || NUM_V_MUST_DEFS (V_MUST_DEF_OPS (ann)) > 0))\n     return VARYING;\n \n-  /* A CALL_EXPR is assumed to be varying.  This may be overly conservative,\n-     in the presence of const and pure calls.  */\n+\n+  /* A CALL_EXPR is assumed to be varying.  NOTE: This may be overly\n+     conservative, in the presence of const and pure calls.  */\n   if (get_call_expr_in (stmt) != NULL_TREE)\n     return VARYING;\n \n+  /* Anything other than assignments and conditional jumps are not\n+     interesting for CCP.  */\n+  if (TREE_CODE (stmt) != MODIFY_EXPR\n+      && TREE_CODE (stmt) != COND_EXPR\n+      && TREE_CODE (stmt) != SWITCH_EXPR)\n+    return VARYING;\n+\n   get_stmt_operands (stmt);\n \n-  FOR_EACH_SSA_TREE_OPERAND (use, stmt, iter, SSA_OP_USE)\n+  found_constant = false;\n+  FOR_EACH_SSA_TREE_OPERAND (use, stmt, iter, SSA_OP_USE|SSA_OP_VUSE)\n     {\n-      value *val = get_value (use);\n+      prop_value_t *val = get_value (use, true);\n \n-      if (val->lattice_val == UNDEFINED)\n-\treturn UNDEFINED;\n+      if (val->lattice_val == VARYING)\n+\treturn VARYING;\n \n-      if (val->lattice_val == CONSTANT)\n-\tfound_constant = 1;\n-    }\n-    \n-  vuses = VUSE_OPS (ann);\n-  \n-  if (NUM_VUSES (vuses))\n-    {\n-      tree vuse = VUSE_OP (vuses, 0);\n-      value *val = get_value (vuse);\n-      \n       if (val->lattice_val == UNKNOWN_VAL)\n-        return UNKNOWN_VAL;\n-\t\n-      /* There should be no VUSE operands that are UNDEFINED.  */\n-      gcc_assert (val->lattice_val != UNDEFINED);\n-\t\n+\t{\n+\t  /* UNKNOWN_VAL is invalid when not doing STORE-CCP.  */\n+\t  gcc_assert (do_store_ccp);\n+\t  return UNKNOWN_VAL;\n+\t}\n+\n       if (val->lattice_val == CONSTANT)\n-\tfound_constant = 1;\n+\tfound_constant = true;\n     }\n \n-  return ((found_constant || (!USE_OPS (ann) && !vuses)) ? CONSTANT : VARYING);\n+  if (found_constant\n+      || NUM_USES (USE_OPS (ann)) == 0\n+      || NUM_VUSES (VUSE_OPS (ann)) == 0)\n+    return CONSTANT;\n+\n+  return UNDEFINED;\n }\n \n \n@@ -337,367 +511,202 @@ static void\n ccp_initialize (void)\n {\n   basic_block bb;\n-  sbitmap is_may_def;\n \n-  value_vector = (value *) xmalloc (num_ssa_names * sizeof (value));\n-  memset (value_vector, 0, num_ssa_names * sizeof (value));\n-\n-  /* Set of SSA_NAMEs that are defined by a V_MAY_DEF.  */\n-  is_may_def = sbitmap_alloc (num_ssa_names);\n-  sbitmap_zero (is_may_def);\n+  const_val = xmalloc (num_ssa_names * sizeof (*const_val));\n+  memset (const_val, 0, num_ssa_names * sizeof (*const_val));\n \n   /* Initialize simulation flags for PHI nodes and statements.  */\n   FOR_EACH_BB (bb)\n     {\n       block_stmt_iterator i;\n \n-      /* Mark all V_MAY_DEF operands VARYING.  */\n       for (i = bsi_start (bb); !bsi_end_p (i); bsi_next (&i))\n         {\n \t  bool is_varying = false;\n \t  tree stmt = bsi_stmt (i);\n-\t  ssa_op_iter iter;\n-\t  tree def;\n \n \t  get_stmt_operands (stmt);\n \n-\t  /* Get the default value for each DEF and V_MUST_DEF.  */\n-\t  FOR_EACH_SSA_TREE_OPERAND (def, stmt, iter, \n-\t\t\t\t     (SSA_OP_DEF | SSA_OP_VMUSTDEF))\n-\t    {\n-\t      if (get_value (def)->lattice_val == VARYING)\n-\t\tis_varying = true;\n-\t    }\n+\t  if (likely_value (stmt) == VARYING)\n \n-\t  /* Mark all V_MAY_DEF operands VARYING.  */\n-\t  FOR_EACH_SSA_TREE_OPERAND (def, stmt, iter, SSA_OP_VMAYDEF)\n \t    {\n-\t      get_value (def)->lattice_val = VARYING;\n-\t      SET_BIT (is_may_def, SSA_NAME_VERSION (def));\n+\t      tree def;\n+\t      ssa_op_iter iter;\n+\n+\t      /* If the statement will not produce a constant, mark\n+\t\t all its outputs VARYING.  */\n+\t      FOR_EACH_SSA_TREE_OPERAND (def, stmt, iter, SSA_OP_ALL_DEFS)\n+\t\tget_value (def, false)->lattice_val = VARYING;\n+\n+\t      /* Never mark conditional jumps with DONT_SIMULATE_AGAIN,\n+\t\t otherwise the propagator will never add the outgoing\n+\t\t control edges.  */\n+\t      if (TREE_CODE (stmt) != COND_EXPR\n+\t\t  && TREE_CODE (stmt) != SWITCH_EXPR)\n+\t\tis_varying = true;\n \t    }\n \n-\t  /* Statements other than MODIFY_EXPR, COND_EXPR and\n-\t     SWITCH_EXPR are not interesting for constant propagation.\n-\t     Mark them VARYING.  */\n-\t  if (TREE_CODE (stmt) != MODIFY_EXPR\n-\t      && TREE_CODE (stmt) != COND_EXPR\n-\t      && TREE_CODE (stmt) != SWITCH_EXPR)\n-\t    is_varying = true;\n-\n \t  DONT_SIMULATE_AGAIN (stmt) = is_varying;\n \t}\n     }\n \n   /* Now process PHI nodes.  */\n   FOR_EACH_BB (bb)\n     {\n-      tree phi, var;\n-      int x;\n+      tree phi;\n \n       for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n \t{\n-\t  value *val = get_value (PHI_RESULT (phi));\n+\t  int i;\n+\t  tree arg;\n+\t  prop_value_t *val = get_value (PHI_RESULT (phi), false);\n \n-\t  for (x = 0; x < PHI_NUM_ARGS (phi); x++)\n+\t  for (i = 0; i < PHI_NUM_ARGS (phi); i++)\n \t    {\n-\t      var = PHI_ARG_DEF (phi, x);\n+\t      arg = PHI_ARG_DEF (phi, i);\n \n-\t      /* If one argument has a V_MAY_DEF, the result is\n-\t\t VARYING.  */\n-\t      if (TREE_CODE (var) == SSA_NAME)\n+\t      if (TREE_CODE (arg) == SSA_NAME\n+\t\t  && get_value (arg, false)->lattice_val == VARYING)\n \t\t{\n-\t\t  if (TEST_BIT (is_may_def, SSA_NAME_VERSION (var)))\n-\t\t    {\n-\t\t      val->lattice_val = VARYING;\n-\t\t      SET_BIT (is_may_def, SSA_NAME_VERSION (PHI_RESULT (phi)));\n-\t\t      break;\n-\t\t    }\n+\t\t  val->lattice_val = VARYING;\n+\t\t  break;\n \t\t}\n \t    }\n \n \t  DONT_SIMULATE_AGAIN (phi) = (val->lattice_val == VARYING);\n \t}\n     }\n-\n-  sbitmap_free (is_may_def);\n }\n \n \n-/* Replace USE references in statement STMT with their immediate reaching\n-   definition.  Return true if at least one reference was replaced.  If\n-   REPLACED_ADDRESSES_P is given, it will be set to true if an address\n-   constant was replaced.  */\n-\n-static bool\n-replace_uses_in (tree stmt, bool *replaced_addresses_p)\n-{\n-  bool replaced = false;\n-  use_operand_p use;\n-  ssa_op_iter iter;\n+/* Do final substitution of propagated values, cleanup the flowgraph and\n+   free allocated storage.  */\n \n-  if (replaced_addresses_p)\n-    *replaced_addresses_p = false;\n-\n-  get_stmt_operands (stmt);\n-\n-  FOR_EACH_SSA_USE_OPERAND (use, stmt, iter, SSA_OP_USE)\n-    {\n-      tree tuse = USE_FROM_PTR (use);\n-      value *val = get_value (tuse);\n-\n-      if (val->lattice_val != CONSTANT)\n-\tcontinue;\n-\n-      if (TREE_CODE (stmt) == ASM_EXPR\n-\t  && !may_propagate_copy_into_asm (tuse))\n-\tcontinue;\n-\n-      SET_USE (use, val->const_val);\n-\n-      replaced = true;\n-      if (POINTER_TYPE_P (TREE_TYPE (tuse)) && replaced_addresses_p)\n-\t*replaced_addresses_p = true;\n-    }\n-\n-  return replaced;\n-}\n-\n-\n-/* Replace the VUSE references in statement STMT with its immediate reaching\n-   definition.  Return true if the reference was replaced.  If\n-   REPLACED_ADDRESSES_P is given, it will be set to true if an address\n-   constant was replaced.  */\n-\n-static bool\n-replace_vuse_in (tree stmt, bool *replaced_addresses_p)\n+static void\n+ccp_finalize (void)\n {\n-  bool replaced = false;\n-  vuse_optype vuses;\n-  use_operand_p vuse;\n-  value *val;\n-\n-  if (replaced_addresses_p)\n-    *replaced_addresses_p = false;\n-\n-  get_stmt_operands (stmt);\n-\n-  vuses = STMT_VUSE_OPS (stmt);\n-\n-  if (NUM_VUSES (vuses) != 1)\n-    return false;\n-\n-  vuse = VUSE_OP_PTR (vuses, 0);\n-  val = get_value (USE_FROM_PTR (vuse));\n-\n-  if (val->lattice_val == CONSTANT\n-      && TREE_CODE (stmt) == MODIFY_EXPR\n-      && DECL_P (TREE_OPERAND (stmt, 1))\n-      && TREE_OPERAND (stmt, 1) == SSA_NAME_VAR (USE_FROM_PTR (vuse)))\n-    {\n-      TREE_OPERAND (stmt, 1) = val->const_val;\n-      replaced = true;\n-      if (POINTER_TYPE_P (TREE_TYPE (USE_FROM_PTR (vuse))) \n-          && replaced_addresses_p)\n-        *replaced_addresses_p = true;\n-    }\n+  /* Perform substitutions based on the known constant values.  */\n+  substitute_and_fold (const_val);\n \n-  return replaced;\n+  free (const_val);\n }\n \n \n-/* Perform final substitution and folding.  After this pass the program\n-   should still be in SSA form.  */\n+/* Compute the meet operator between *VAL1 and *VAL2.  Store the result\n+   in VAL1.\n+\n+   \t\tany  M UNDEFINED   = any\n+\t\tany  M UNKNOWN_VAL = UNKNOWN_VAL\n+\t\tany  M VARYING     = VARYING\n+\t\tCi   M Cj\t   = Ci\t\tif (i == j)\n+\t\tCi   M Cj\t   = VARYING\tif (i != j)\n+\n+   Lattice values UNKNOWN_VAL and UNDEFINED are similar but have\n+   different semantics at PHI nodes.  Both values imply that we don't\n+   know whether the variable is constant or not.  However, UNKNOWN_VAL\n+   values override all others.  For instance, suppose that A is a\n+   global variable:\n+\n+\t\t+------+\n+\t\t|      |\n+\t\t|     / \\\n+\t\t|    /   \\\n+\t\t|   |  A_1 = 4\n+\t\t|    \\   /\n+\t\t|     \\ /    \n+\t\t| A_3 = PHI (A_2, A_1)\n+\t\t| ... = A_3\n+\t\t|    |\n+\t\t+----+\n+\n+   If the edge into A_2 is not executable, the first visit to A_3 will\n+   yield the constant 4.  But the second visit to A_3 will be with A_2\n+   in state UNKNOWN_VAL.  We can no longer conclude that A_3 is 4\n+   because A_2 may have been set in another function.  If we had used\n+   the lattice value UNDEFINED, we would have had wrongly concluded\n+   that A_3 is 4.  */\n+   \n \n static void\n-substitute_and_fold (void)\n+ccp_lattice_meet (prop_value_t *val1, prop_value_t *val2)\n {\n-  basic_block bb;\n-  unsigned int i;\n-\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    fprintf (dump_file,\n-\t     \"\\nSubstituing constants and folding statements\\n\\n\");\n-\n-  /* Substitute constants in every statement of every basic block.  */\n-  FOR_EACH_BB (bb)\n+  if (val1->lattice_val == UNDEFINED)\n     {\n-      block_stmt_iterator i;\n-      tree phi;\n-\n-      /* Propagate our known constants into PHI nodes.  */\n-      for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n-\t{\n-\t  int i;\n-\n-\t  for (i = 0; i < PHI_NUM_ARGS (phi); i++)\n-\t    {\n-\t      value *new_val;\n-\t      use_operand_p orig_p = PHI_ARG_DEF_PTR (phi, i);\n-\t      tree orig = USE_FROM_PTR (orig_p);\n-\n-\t      if (! SSA_VAR_P (orig))\n-\t\tbreak;\n-\n-\t      new_val = get_value (orig);\n-\t      if (new_val->lattice_val == CONSTANT\n-\t\t  && may_propagate_copy (orig, new_val->const_val))\n-\t\tSET_USE (orig_p, new_val->const_val);\n-\t    }\n-\t}\n-\n-      for (i = bsi_start (bb); !bsi_end_p (i); bsi_next (&i))\n-\t{\n-          bool replaced_address;\n-\t  tree stmt = bsi_stmt (i);\n-\n-\t  /* Skip statements that have been folded already.  */\n-\t  if (stmt_modified_p (stmt) || !is_exec_stmt (stmt))\n-\t    continue;\n-\n-\t  /* Replace the statement with its folded version and mark it\n-\t     folded.  */\n-\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    {\n-\t      fprintf (dump_file, \"Line %d: replaced \", get_lineno (stmt));\n-\t      print_generic_stmt (dump_file, stmt, TDF_SLIM);\n-\t    }\n-\n-\t  if (replace_uses_in (stmt, &replaced_address)\n-\t      || replace_vuse_in (stmt, &replaced_address))\n-\t    {\n-\t      bool changed = fold_stmt (bsi_stmt_ptr (i));\n-\t      stmt = bsi_stmt(i);\n-\n-\t      /* If we folded a builtin function, we'll likely\n-\t\t need to rename VDEFs.  */\n-\t      if (replaced_address || changed)\n-\t\tmark_new_vars_to_rename (stmt, vars_to_rename);\n-\n-              /* If we cleaned up EH information from the statement,\n-                 remove EH edges.  */\n-\t      if (maybe_clean_eh_stmt (stmt))\n-\t\ttree_purge_dead_eh_edges (bb);\n-\n-\t      update_stmt (stmt);\n-\t    }\n-\n-\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    {\n-\t      fprintf (dump_file, \" with \");\n-\t      print_generic_stmt (dump_file, stmt, TDF_SLIM);\n-\t      fprintf (dump_file, \"\\n\");\n-\t    }\n-\t}\n+      /* UNDEFINED M any = any   */\n+      *val1 = *val2;\n     }\n-\n-  /* And transfer what we learned from VALUE_VECTOR into the\n-     SSA_NAMEs themselves.  This probably isn't terribly important\n-     since we probably constant propagated the values to their\n-     use sites above.  */\n-  for (i = 0; i < num_ssa_names; i++)\n+  else if (val2->lattice_val == UNDEFINED)\n     {\n-      tree name = ssa_name (i);\n-      value *value;\n-\n-      if (!name)\n-\tcontinue;\n-\n-      value = get_value (name);\n-      if (value->lattice_val == CONSTANT\n-          && is_gimple_reg (name)\n-\t  && is_gimple_min_invariant (value->const_val))\n-\tSSA_NAME_VALUE (name) = value->const_val;\n+      /* any M UNDEFINED = any\n+         Nothing to do.  VAL1 already contains the value we want.  */\n+      ;\n     }\n-}\n-\n-\n-/* Free allocated storage.  */\n-\n-static void\n-ccp_finalize (void)\n-{\n-  /* Perform substitutions based on the known constant values.  */\n-  substitute_and_fold ();\n-\n-  free (value_vector);\n-}\n-\n-\n-\n-/* Compute the meet operator between VAL1 and VAL2:\n-\n-   \t\tany  M UNDEFINED     = any\n-\t\tany  M VARYING       = VARYING\n-\t\tany  M UNKNOWN_VAL   = UNKNOWN_VAL\n-\t\tCi   M Cj\t     = Ci\tif (i == j)\n-\t\tCi   M Cj\t     = VARYING\tif (i != j)  */\n-static value\n-ccp_lattice_meet (value val1, value val2)\n-{\n-  value result;\n-\n-  /* any M UNDEFINED = any.  */\n-  if (val1.lattice_val == UNDEFINED)\n-    return val2;\n-  else if (val2.lattice_val == UNDEFINED)\n-    return val1;\n-\n-  /* any M VARYING = VARYING.  */\n-  if (val1.lattice_val == VARYING || val2.lattice_val == VARYING)\n+  else if (val1->lattice_val == UNKNOWN_VAL\n+           || val2->lattice_val == UNKNOWN_VAL)\n     {\n-      result.lattice_val = VARYING;\n-      result.const_val = NULL_TREE;\n-      return result;\n-    }\n+      /* UNKNOWN_VAL values are invalid if we are not doing STORE-CCP.  */\n+      gcc_assert (do_store_ccp);\n \n-  /* any M UNKNOWN_VAL = UNKNOWN_VAL.  */\n-  if (val1.lattice_val == UNKNOWN_VAL \n-      || val2.lattice_val == UNKNOWN_VAL)\n+      /* any M UNKNOWN_VAL = UNKNOWN_VAL.  */\n+      val1->lattice_val = UNKNOWN_VAL;\n+      val1->value = NULL_TREE;\n+      val1->mem_ref = NULL_TREE;\n+    }\n+  else if (val1->lattice_val == VARYING\n+           || val2->lattice_val == VARYING)\n     {\n-      result.lattice_val = UNKNOWN_VAL;\n-      result.const_val = NULL_TREE;\n-      return result;\n+      /* any M VARYING = VARYING.  */\n+      val1->lattice_val = VARYING;\n+      val1->value = NULL_TREE;\n+      val1->mem_ref = NULL_TREE;\n     }\n-\n-  /* Ci M Cj = Ci\tif (i == j)\n-     Ci M Cj = VARYING\tif (i != j)  */\n-  if (simple_cst_equal (val1.const_val, val2.const_val) == 1)\n+  else if (val1->lattice_val == CONSTANT\n+\t   && val2->lattice_val == CONSTANT\n+\t   && simple_cst_equal (val1->value, val2->value) == 1\n+\t   && (!do_store_ccp\n+\t       || simple_cst_equal (val1->mem_ref, val2->mem_ref) == 1))\n     {\n-      result.lattice_val = CONSTANT;\n-      result.const_val = val1.const_val;\n+      /* Ci M Cj = Ci\t\tif (i == j)\n+\t Ci M Cj = VARYING\tif (i != j)\n+\n+         If these two values come from memory stores, make sure that\n+\t they come from the same memory reference.  */\n+      val1->lattice_val = CONSTANT;\n+      val1->value = val1->value;\n+      val1->mem_ref = val1->mem_ref;\n     }\n   else\n     {\n-      result.lattice_val = VARYING;\n-      result.const_val = NULL_TREE;\n+      /* Any other combination is VARYING.  */\n+      val1->lattice_val = VARYING;\n+      val1->value = NULL_TREE;\n+      val1->mem_ref = NULL_TREE;\n     }\n-\n-  return result;\n }\n \n \n /* Loop through the PHI_NODE's parameters for BLOCK and compare their\n    lattice values to determine PHI_NODE's lattice value.  The value of a\n-   PHI node is determined calling ccp_lattice_meet() with all the arguments\n+   PHI node is determined calling ccp_lattice_meet with all the arguments\n    of the PHI node that are incoming via executable edges.  */\n \n static enum ssa_prop_result\n ccp_visit_phi_node (tree phi)\n {\n-  value new_val, *old_val;\n   int i;\n+  prop_value_t *old_val, new_val;\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n       fprintf (dump_file, \"\\nVisiting PHI node: \");\n       print_generic_expr (dump_file, phi, dump_flags);\n     }\n \n-  old_val = get_value (PHI_RESULT (phi));\n+  old_val = get_value (PHI_RESULT (phi), false);\n   switch (old_val->lattice_val)\n     {\n     case VARYING:\n-      return SSA_PROP_NOT_INTERESTING;\n+      return SSA_PROP_VARYING;\n \n     case CONSTANT:\n       new_val = *old_val;\n@@ -710,14 +719,15 @@ ccp_visit_phi_node (tree phi)\n \t UNDEFINED.  If the PHI node's old value was UNKNOWN_VAL and\n \t the new value is UNDEFINED, then we prevent the invalid\n \t transition by not calling set_lattice_value.  */\n-      new_val.lattice_val = UNDEFINED;\n-      new_val.const_val = NULL_TREE;\n-      break;\n+      gcc_assert (do_store_ccp);\n+\n+      /* FALLTHRU  */\n \n     case UNDEFINED:\n     case UNINITIALIZED:\n       new_val.lattice_val = UNDEFINED;\n-      new_val.const_val = NULL_TREE;\n+      new_val.value = NULL_TREE;\n+      new_val.mem_ref = NULL_TREE;\n       break;\n \n     default:\n@@ -726,7 +736,8 @@ ccp_visit_phi_node (tree phi)\n \n   for (i = 0; i < PHI_NUM_ARGS (phi); i++)\n     {\n-      /* Compute the meet operator over all the PHI arguments.  */\n+      /* Compute the meet operator over all the PHI arguments flowing\n+\t through executable edges.  */\n       edge e = PHI_ARG_EDGE (phi, i);\n \n       if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -741,25 +752,25 @@ ccp_visit_phi_node (tree phi)\n \t the existing value of the PHI node and the current PHI argument.  */\n       if (e->flags & EDGE_EXECUTABLE)\n \t{\n-\t  tree rdef = PHI_ARG_DEF (phi, i);\n-\t  value *rdef_val, val;\n+\t  tree arg = PHI_ARG_DEF (phi, i);\n+\t  prop_value_t arg_val;\n \n-\t  if (is_gimple_min_invariant (rdef))\n+\t  if (is_gimple_min_invariant (arg))\n \t    {\n-\t      val.lattice_val = CONSTANT;\n-\t      val.const_val = rdef;\n-\t      rdef_val = &val;\n+\t      arg_val.lattice_val = CONSTANT;\n+\t      arg_val.value = arg;\n+\t      arg_val.mem_ref = NULL_TREE;\n \t    }\n \t  else\n-\t    rdef_val = get_value (rdef);\n+\t    arg_val = *(get_value (arg, true));\n \n-\t  new_val = ccp_lattice_meet (new_val, *rdef_val);\n+\t  ccp_lattice_meet (&new_val, &arg_val);\n \n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t    {\n \t      fprintf (dump_file, \"\\t\");\n-\t      print_generic_expr (dump_file, rdef, dump_flags);\n-\t      dump_lattice_value (dump_file, \"\\tValue: \", *rdef_val);\n+\t      print_generic_expr (dump_file, arg, dump_flags);\n+\t      dump_lattice_value (dump_file, \"\\tValue: \", arg_val);\n \t      fprintf (dump_file, \"\\n\");\n \t    }\n \n@@ -775,7 +786,8 @@ ccp_visit_phi_node (tree phi)\n     }\n \n   /* Check for an invalid change from UNKNOWN_VAL to UNDEFINED.  */\n-  if (old_val->lattice_val == UNKNOWN_VAL\n+  if (do_store_ccp\n+      && old_val->lattice_val == UNKNOWN_VAL\n       && new_val.lattice_val == UNDEFINED)\n     return SSA_PROP_NOT_INTERESTING;\n \n@@ -808,18 +820,23 @@ ccp_fold (tree stmt)\n   enum tree_code code = TREE_CODE (rhs);\n   enum tree_code_class kind = TREE_CODE_CLASS (code);\n   tree retval = NULL_TREE;\n-  vuse_optype vuses;\n-  \n-  vuses = STMT_VUSE_OPS (stmt);\n \n-  /* If the RHS is just a variable, then that variable must now have\n-     a constant value that we can return directly.  */\n   if (TREE_CODE (rhs) == SSA_NAME)\n-    return get_value (rhs)->const_val;\n-  else if (DECL_P (rhs) \n-           && NUM_VUSES (vuses) == 1\n-           && rhs == SSA_NAME_VAR (VUSE_OP (vuses, 0)))\n-    return get_value (VUSE_OP (vuses, 0))->const_val;\n+    {\n+      /* If the RHS is an SSA_NAME, return its known constant value,\n+\t if any.  */\n+      return get_value (rhs, true)->value;\n+    }\n+  else if (do_store_ccp && stmt_makes_single_load (stmt))\n+    {\n+      /* If the RHS is a memory load, see if the VUSEs associated with\n+\t it are a valid constant for that memory load.  */\n+      prop_value_t *val = get_value_loaded_by (stmt, const_val);\n+      if (val && simple_cst_equal (val->mem_ref, rhs) == 1)\n+\treturn val->value;\n+      else\n+\treturn NULL_TREE;\n+    }\n \n   /* Unary operators.  Note that we know the single operand must\n      be a constant.  So this should almost always return a\n@@ -832,9 +849,9 @@ ccp_fold (tree stmt)\n       /* Simplify the operand down to a constant.  */\n       if (TREE_CODE (op0) == SSA_NAME)\n \t{\n-\t  value *val = get_value (op0);\n+\t  prop_value_t *val = get_value (op0, true);\n \t  if (val->lattice_val == CONSTANT)\n-\t    op0 = get_value (op0)->const_val;\n+\t    op0 = get_value (op0, true)->value;\n \t}\n \n       retval = fold_unary_to_constant (code, TREE_TYPE (rhs), op0);\n@@ -876,16 +893,16 @@ ccp_fold (tree stmt)\n       /* Simplify the operands down to constants when appropriate.  */\n       if (TREE_CODE (op0) == SSA_NAME)\n \t{\n-\t  value *val = get_value (op0);\n+\t  prop_value_t *val = get_value (op0, true);\n \t  if (val->lattice_val == CONSTANT)\n-\t    op0 = val->const_val;\n+\t    op0 = val->value;\n \t}\n \n       if (TREE_CODE (op1) == SSA_NAME)\n \t{\n-\t  value *val = get_value (op1);\n+\t  prop_value_t *val = get_value (op1, true);\n \t  if (val->lattice_val == CONSTANT)\n-\t    op1 = val->const_val;\n+\t    op1 = val->value;\n \t}\n \n       retval = fold_binary_to_constant (code, TREE_TYPE (rhs), op0, op1);\n@@ -934,7 +951,7 @@ ccp_fold (tree stmt)\n \t    orig[i] = USE_OP (uses, i);\n \n \t  /* Substitute operands with their values and try to fold.  */\n-\t  replace_uses_in (stmt, NULL);\n+\t  replace_uses_in (stmt, NULL, const_val);\n \t  fndecl = get_callee_fndecl (rhs);\n \t  arglist = TREE_OPERAND (rhs, 1);\n \t  retval = fold_builtin (fndecl, arglist, false);\n@@ -959,12 +976,14 @@ ccp_fold (tree stmt)\n \n /* Evaluate statement STMT.  */\n \n-static value\n+static prop_value_t\n evaluate_stmt (tree stmt)\n {\n-  value val;\n+  prop_value_t val;\n   tree simplified;\n-  latticevalue likelyvalue = likely_value (stmt);\n+  ccp_lattice_t likelyvalue = likely_value (stmt);\n+\n+  val.mem_ref = NULL_TREE;\n \n   /* If the statement is likely to have a CONSTANT result, then try\n      to fold the statement to determine the constant value.  */\n@@ -983,67 +1002,54 @@ evaluate_stmt (tree stmt)\n     {\n       /* The statement produced a constant value.  */\n       val.lattice_val = CONSTANT;\n-      val.const_val = simplified;\n+      val.value = simplified;\n     }\n   else\n     {\n       /* The statement produced a nonconstant value.  If the statement\n-         had undefined or virtual operands, then the result of the \n-\t statement should be undefined or virtual respectively.  \n-\t Else the result of the statement is VARYING.  */\n-      val.lattice_val = (likelyvalue == UNDEFINED ? UNDEFINED : VARYING);\n-      val.lattice_val = (likelyvalue == UNKNOWN_VAL \n-                           ? UNKNOWN_VAL : val.lattice_val);\n-      val.const_val = NULL_TREE;\n+\t had UNDEFINED operands, then the result of the statement\n+\t should be UNDEFINED.  Otherwise, the statement is VARYING.  */\n+      val.lattice_val = (likelyvalue == UNDEFINED) ? UNDEFINED : VARYING;\n+      val.value = NULL_TREE;\n     }\n \n   return val;\n }\n \n \n /* Visit the assignment statement STMT.  Set the value of its LHS to the\n-   value computed by the RHS and store LHS in *OUTPUT_P.  */\n+   value computed by the RHS and store LHS in *OUTPUT_P.  If STMT\n+   creates virtual definitions, set the value of each new name to that\n+   of the RHS (if we can derive a constant out of the RHS).  */\n \n static enum ssa_prop_result\n visit_assignment (tree stmt, tree *output_p)\n {\n-  value val;\n+  prop_value_t val;\n   tree lhs, rhs;\n-  vuse_optype vuses;\n-  v_must_def_optype v_must_defs;\n+  enum ssa_prop_result retval;\n \n   lhs = TREE_OPERAND (stmt, 0);\n   rhs = TREE_OPERAND (stmt, 1);\n-  vuses = STMT_VUSE_OPS (stmt);\n-  v_must_defs = STMT_V_MUST_DEF_OPS (stmt);\n-\n-  gcc_assert (NUM_V_MAY_DEFS (STMT_V_MAY_DEF_OPS (stmt)) == 0);\n-  gcc_assert (NUM_V_MUST_DEFS (v_must_defs) == 1\n-\t      || TREE_CODE (lhs) == SSA_NAME);\n-\n-  /* We require the SSA version number of the lhs for the value_vector.\n-     Make sure we have it.  */\n-  if (TREE_CODE (lhs) != SSA_NAME)\n-    {\n-      /* If we make it here, then stmt only has one definition:\n-         a V_MUST_DEF.  */\n-      lhs = V_MUST_DEF_RESULT (v_must_defs, 0);\n-    }\n \n   if (TREE_CODE (rhs) == SSA_NAME)\n     {\n       /* For a simple copy operation, we copy the lattice values.  */\n-      value *nval = get_value (rhs);\n+      prop_value_t *nval = get_value (rhs, true);\n       val = *nval;\n     }\n-  else if (DECL_P (rhs) \n-           && NUM_VUSES (vuses) == 1\n-           && rhs == SSA_NAME_VAR (VUSE_OP (vuses, 0)))\n+  else if (do_store_ccp && stmt_makes_single_load (stmt))\n     {\n-      /* Same as above, but the rhs is not a gimple register and yet\n-        has a known VUSE.  */\n-      value *nval = get_value (VUSE_OP (vuses, 0));\n-      val = *nval;\n+      /* Same as above, but the RHS is not a gimple register and yet\n+         has a known VUSE.  If STMT is loading from the same memory\n+\t location that created the SSA_NAMEs for the virtual operands,\n+\t we can propagate the value on the RHS.  */\n+      prop_value_t *nval = get_value_loaded_by (stmt, const_val);\n+\n+      if (nval && simple_cst_equal (nval->mem_ref, rhs) == 1)\n+\tval = *nval;\n+      else\n+\tval = evaluate_stmt (stmt);\n     }\n   else\n     /* Evaluate the statement.  */\n@@ -1063,52 +1069,89 @@ visit_assignment (tree stmt, tree *output_p)\n       {\n \ttree w = fold (build1 (VIEW_CONVERT_EXPR,\n \t\t\t       TREE_TYPE (TREE_OPERAND (orig_lhs, 0)),\n-\t\t\t       val.const_val));\n+\t\t\t       val.value));\n \n \torig_lhs = TREE_OPERAND (orig_lhs, 1);\n \tif (w && is_gimple_min_invariant (w))\n-\t  val.const_val = w;\n+\t  val.value = w;\n \telse\n \t  {\n \t    val.lattice_val = VARYING;\n-\t    val.const_val = NULL;\n+\t    val.value = NULL;\n \t  }\n       }\n \n     if (val.lattice_val == CONSTANT\n \t&& TREE_CODE (orig_lhs) == COMPONENT_REF\n \t&& DECL_BIT_FIELD (TREE_OPERAND (orig_lhs, 1)))\n       {\n-\ttree w = widen_bitfield (val.const_val, TREE_OPERAND (orig_lhs, 1),\n+\ttree w = widen_bitfield (val.value, TREE_OPERAND (orig_lhs, 1),\n \t\t\t\t orig_lhs);\n \n \tif (w && is_gimple_min_invariant (w))\n-\t  val.const_val = w;\n+\t  val.value = w;\n \telse\n \t  {\n \t    val.lattice_val = VARYING;\n-\t    val.const_val = NULL;\n+\t    val.value = NULL_TREE;\n+\t    val.mem_ref = NULL_TREE;\n \t  }\n       }\n   }\n \n-  /* If LHS is not a gimple register, then it cannot take on an\n-     UNDEFINED value.  */\n-  if (!is_gimple_reg (SSA_NAME_VAR (lhs)) \n-      && val.lattice_val == UNDEFINED)\n-    val.lattice_val = UNKNOWN_VAL;      \n+  retval = SSA_PROP_NOT_INTERESTING;\n \n   /* Set the lattice value of the statement's output.  */\n-  if (set_lattice_value (lhs, val))\n+  if (TREE_CODE (lhs) == SSA_NAME)\n     {\n-      *output_p = lhs;\n-      if (val.lattice_val == VARYING)\n-\treturn SSA_PROP_VARYING;\n-      else\n-\treturn SSA_PROP_INTERESTING;\n+      /* If STMT is an assignment to an SSA_NAME, we only have one\n+\t value to set.  */\n+      if (set_lattice_value (lhs, val))\n+\t{\n+\t  *output_p = lhs;\n+\t  if (val.lattice_val == VARYING)\n+\t    retval = SSA_PROP_VARYING;\n+\t  else\n+\t    retval = SSA_PROP_INTERESTING;\n+\t}\n     }\n-  else\n-    return SSA_PROP_NOT_INTERESTING;\n+  else if (do_store_ccp && stmt_makes_single_store (stmt))\n+    {\n+      /* Otherwise, set the names in V_MAY_DEF/V_MUST_DEF operands\n+\t to the new constant value and mark the LHS as the memory\n+\t reference associated with VAL.  */\n+      ssa_op_iter i;\n+      tree vdef;\n+      bool changed;\n+\n+      /* Stores cannot take on an UNDEFINED value.  */\n+      if (val.lattice_val == UNDEFINED)\n+\tval.lattice_val = UNKNOWN_VAL;      \n+\n+      /* Mark VAL as stored in the LHS of this assignment.  */\n+      val.mem_ref = lhs;\n+\n+      /* Set the value of every VDEF to VAL.  */\n+      changed = false;\n+      FOR_EACH_SSA_TREE_OPERAND (vdef, stmt, i, SSA_OP_VIRTUAL_DEFS)\n+\tchanged |= set_lattice_value (vdef, val);\n+      \n+      /* Note that for propagation purposes, we are only interested in\n+\t visiting statements that load the exact same memory reference\n+\t stored here.  Those statements will have the exact same list\n+\t of virtual uses, so it is enough to set the output of this\n+\t statement to be its first virtual definition.  */\n+      *output_p = first_vdef (stmt);\n+      if (changed)\n+\t{\n+\t  if (val.lattice_val == VARYING)\n+\t    retval = SSA_PROP_VARYING;\n+\t  else \n+\t    retval = SSA_PROP_INTERESTING;\n+\t}\n+    }\n+\n+  return retval;\n }\n \n \n@@ -1119,7 +1162,7 @@ visit_assignment (tree stmt, tree *output_p)\n static enum ssa_prop_result\n visit_cond_stmt (tree stmt, edge *taken_edge_p)\n {\n-  value val;\n+  prop_value_t val;\n   basic_block block;\n \n   block = bb_for_stmt (stmt);\n@@ -1129,7 +1172,7 @@ visit_cond_stmt (tree stmt, edge *taken_edge_p)\n      to the worklist.  If no single edge can be determined statically,\n      return SSA_PROP_VARYING to feed all the outgoing edges to the\n      propagation engine.  */\n-  *taken_edge_p = val.const_val ? find_taken_edge (block, val.const_val) : 0;\n+  *taken_edge_p = val.value ? find_taken_edge (block, val.value) : 0;\n   if (*taken_edge_p)\n     return SSA_PROP_INTERESTING;\n   else\n@@ -1157,19 +1200,16 @@ ccp_visit_stmt (tree stmt, edge *taken_edge_p, tree *output_p)\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n-      fprintf (dump_file, \"\\nVisiting statement: \");\n-      print_generic_stmt (dump_file, stmt, TDF_SLIM);\n+      fprintf (dump_file, \"\\nVisiting statement:\\n\");\n+      print_generic_stmt (dump_file, stmt, dump_flags);\n       fprintf (dump_file, \"\\n\");\n     }\n \n   ann = stmt_ann (stmt);\n \n   v_must_defs = V_MUST_DEF_OPS (ann);\n   v_may_defs = V_MAY_DEF_OPS (ann);\n-  if (TREE_CODE (stmt) == MODIFY_EXPR\n-      && NUM_V_MAY_DEFS (v_may_defs) == 0\n-      && (NUM_V_MUST_DEFS (v_must_defs) == 1\n-          || TREE_CODE (TREE_OPERAND (stmt, 0)) == SSA_NAME))\n+  if (TREE_CODE (stmt) == MODIFY_EXPR)\n     {\n       /* If the statement is an assignment that produces a single\n \t output value, evaluate its RHS to see if the lattice value of\n@@ -1191,30 +1231,35 @@ ccp_visit_stmt (tree stmt, edge *taken_edge_p, tree *output_p)\n   /* Definitions made by statements other than assignments to\n      SSA_NAMEs represent unknown modifications to their outputs.\n      Mark them VARYING.  */\n-  FOR_EACH_SSA_TREE_OPERAND (def, stmt, iter, SSA_OP_DEF)\n-    def_to_varying (def);\n-\n-  /* Mark all V_MAY_DEF operands VARYING.  */\n-  FOR_EACH_SSA_TREE_OPERAND (def, stmt, iter, SSA_OP_VMAYDEF)\n-    def_to_varying (def);\n+  FOR_EACH_SSA_TREE_OPERAND (def, stmt, iter, SSA_OP_ALL_DEFS)\n+    {\n+      prop_value_t v = { VARYING, NULL_TREE, NULL_TREE };\n+      set_lattice_value (def, v);\n+    }\n \n   return SSA_PROP_VARYING;\n }\n \n \n-/* Main entry point for SSA Conditional Constant Propagation.\n-\n-   [ DESCRIBE MAIN ALGORITHM HERE ]  */\n+/* Main entry point for SSA Conditional Constant Propagation.  */\n \n static void\n-execute_ssa_ccp (void)\n+execute_ssa_ccp (bool store_ccp)\n {\n+  do_store_ccp = store_ccp;\n   ccp_initialize ();\n   ssa_propagate (ccp_visit_stmt, ccp_visit_phi_node);\n   ccp_finalize ();\n }\n \n \n+static void\n+do_ssa_ccp (void)\n+{\n+  execute_ssa_ccp (false);\n+}\n+\n+\n static bool\n gate_ccp (void)\n {\n@@ -1226,7 +1271,7 @@ struct tree_opt_pass pass_ccp =\n {\n   \"ccp\",\t\t\t\t/* name */\n   gate_ccp,\t\t\t\t/* gate */\n-  execute_ssa_ccp,\t\t\t/* execute */\n+  do_ssa_ccp,\t\t\t\t/* execute */\n   NULL,\t\t\t\t\t/* sub */\n   NULL,\t\t\t\t\t/* next */\n   0,\t\t\t\t\t/* static_pass_number */\n@@ -1235,13 +1280,50 @@ struct tree_opt_pass pass_ccp =\n   0,\t\t\t\t\t/* properties_provided */\n   0,\t\t\t\t\t/* properties_destroyed */\n   0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_cleanup_cfg | TODO_dump_func | TODO_rename_vars\n+  TODO_cleanup_cfg | TODO_dump_func | TODO_update_ssa\n     | TODO_ggc_collect | TODO_verify_ssa\n     | TODO_verify_stmts,\t\t/* todo_flags_finish */\n   0\t\t\t\t\t/* letter */\n };\n \n \n+static void\n+do_ssa_store_ccp (void)\n+{\n+  /* If STORE-CCP is not enabled, we just run regular CCP.  */\n+  execute_ssa_ccp (flag_tree_store_ccp != 0);\n+}\n+\n+static bool\n+gate_store_ccp (void)\n+{\n+  /* STORE-CCP is enabled only with -ftree-store-ccp, but when\n+     -fno-tree-store-ccp is specified, we should run regular CCP.\n+     That's why the pass is enabled with either flag.  */\n+  return flag_tree_store_ccp != 0 || flag_tree_ccp != 0;\n+}\n+\n+\n+struct tree_opt_pass pass_store_ccp = \n+{\n+  \"store_ccp\",\t\t\t\t/* name */\n+  gate_store_ccp,\t\t\t/* gate */\n+  do_ssa_store_ccp,\t\t\t/* execute */\n+  NULL,\t\t\t\t\t/* sub */\n+  NULL,\t\t\t\t\t/* next */\n+  0,\t\t\t\t\t/* static_pass_number */\n+  TV_TREE_STORE_CCP,\t\t\t/* tv_id */\n+  PROP_cfg | PROP_ssa | PROP_alias,\t/* properties_required */\n+  0,\t\t\t\t\t/* properties_provided */\n+  0,\t\t\t\t\t/* properties_destroyed */\n+  0,\t\t\t\t\t/* todo_flags_start */\n+  TODO_dump_func | TODO_update_ssa\n+    | TODO_ggc_collect | TODO_verify_ssa\n+    | TODO_cleanup_cfg\n+    | TODO_verify_stmts,\t\t/* todo_flags_finish */\n+  0\t\t\t\t\t/* letter */\n+};\n+\n /* Given a constant value VAL for bitfield FIELD, and a destination\n    variable VAR, return VAL appropriately widened to fit into VAR.  If\n    FIELD is wider than HOST_WIDE_INT, NULL is returned.  */\n@@ -2132,7 +2214,7 @@ convert_to_gimple_builtin (block_stmt_iterator *si_p, tree expr)\n   for (ti = tsi_start (stmts); !tsi_end_p (ti); tsi_next (&ti))\n     {\n       find_new_referenced_vars (tsi_stmt_ptr (ti));\n-      mark_new_vars_to_rename (tsi_stmt (ti), vars_to_rename);\n+      mark_new_vars_to_rename (tsi_stmt (ti));\n     }\n \n   if (EXPR_HAS_LOCATION (stmt))\n@@ -2233,6 +2315,6 @@ struct tree_opt_pass pass_fold_builtins =\n   0,\t\t\t\t\t/* todo_flags_start */\n   TODO_dump_func\n     | TODO_verify_ssa\n-    | TODO_rename_vars,\t\t\t/* todo_flags_finish */\n+    | TODO_update_ssa,\t\t\t/* todo_flags_finish */\n   0\t\t\t\t\t/* letter */\n };"}, {"sha": "baca99c061cb6da6cc859bfde87458f9ee724cf1", "filename": "gcc/tree-ssa-copy.c", "status": "modified", "additions": 811, "deletions": 40, "changes": 851, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftree-ssa-copy.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftree-ssa-copy.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-copy.c?ref=0bca51f080dfff5e943b1f1775d874a73bbc441a", "patch": "@@ -1,4 +1,4 @@\n-/* Const/copy propagation and SSA_NAME replacement support routines.\n+/* Copy propagation and SSA_NAME replacement support routines.\n    Copyright (C) 2004, 2005 Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -37,11 +37,13 @@ Boston, MA 02111-1307, USA.  */\n #include \"tree-dump.h\"\n #include \"tree-flow.h\"\n #include \"tree-pass.h\"\n+#include \"tree-ssa-propagate.h\"\n #include \"langhooks.h\"\n \n-/* This file provides a handful of interfaces for performing const/copy\n-   propagation and simple expression replacement which keep variable\n-   annotations up-to-date.\n+/* This file implements the copy propagation pass and provides a\n+   handful of interfaces for performing const/copy propagation and\n+   simple expression replacement which keep variable annotations\n+   up-to-date.\n \n    We require that for any copy operation where the RHS and LHS have\n    a non-null memory tag the memory tag be the same.   It is OK\n@@ -54,7 +56,6 @@ Boston, MA 02111-1307, USA.  */\n    replacements of one SSA_NAME with a different SSA_NAME to use the\n    APIs defined in this file.  */\n \n-\n /* Return true if we may propagate ORIG into DEST, false otherwise.  */\n \n bool\n@@ -103,8 +104,10 @@ may_propagate_copy (tree dest, tree orig)\n      I think that GIMPLE should emit the appropriate type-casts.  For the\n      time being, blocking copy-propagation in these cases is the safe thing\n      to do.  */\n-  if (TREE_CODE (dest) == SSA_NAME && TREE_CODE (orig) == SSA_NAME\n-      && POINTER_TYPE_P (type_d) && POINTER_TYPE_P (type_o))\n+  if (TREE_CODE (dest) == SSA_NAME\n+      && TREE_CODE (orig) == SSA_NAME\n+      && POINTER_TYPE_P (type_d)\n+      && POINTER_TYPE_P (type_o))\n     {\n       tree mt_dest = var_ann (SSA_NAME_VAR (dest))->type_mem_tag;\n       tree mt_orig = var_ann (SSA_NAME_VAR (orig))->type_mem_tag;\n@@ -123,17 +126,9 @@ may_propagate_copy (tree dest, tree orig)\n     {\n       /* If both operands are SSA_NAMEs referring to virtual operands, then\n \t we can always propagate.  */\n-      if (TREE_CODE (orig) == SSA_NAME)\n-\t{\n-\t  if (!is_gimple_reg (orig))\n-\t    return true;\n-\n-#ifdef ENABLE_CHECKING\n-\t  /* If we have one real and one virtual operand, then something has\n-\t     gone terribly wrong.  */\n-\t  gcc_assert (!is_gimple_reg (orig));\n-#endif\n-\t}\n+      if (TREE_CODE (orig) == SSA_NAME\n+\t  && !is_gimple_reg (orig))\n+\treturn true;\n \n       /* We have a \"copy\" from something like a constant into a virtual\n \t operand.  Reject these.  */\n@@ -202,30 +197,33 @@ merge_alias_info (tree orig, tree new)\n   else\n     gcc_assert (new_ann->type_mem_tag == orig_ann->type_mem_tag);\n \n-#if defined ENABLE_CHECKING\n-  {\n-    struct ptr_info_def *orig_ptr_info = SSA_NAME_PTR_INFO (orig);\n-    struct ptr_info_def *new_ptr_info = SSA_NAME_PTR_INFO (new);\n-\n-    if (orig_ptr_info\n-\t&& new_ptr_info\n-\t&& orig_ptr_info->name_mem_tag\n-\t&& new_ptr_info->name_mem_tag\n-\t&& orig_ptr_info->pt_vars\n-\t&& new_ptr_info->pt_vars)\n+  /* Synchronize the name tags.  If NEW did not have a name tag, get\n+     it from ORIG.  This happens when NEW is a compiler generated\n+     temporary which still hasn't had its points-to information filled\n+     in.  */\n+  if (SSA_NAME_PTR_INFO (orig))\n     {\n-      /* Note that pointer NEW may actually have a different set of\n-\t pointed-to variables.  However, since NEW is being\n-\t copy-propagated into ORIG, it must always be true that the\n-\t pointed-to set for pointer NEW is the same, or a subset, of\n-\t the pointed-to set for pointer ORIG.  If this isn't the case,\n-\t we shouldn't have been able to do the propagation of NEW into\n-\t ORIG.  */\n-      gcc_assert (bitmap_intersect_p (new_ptr_info->pt_vars,\n-\t\t\t\t      orig_ptr_info->pt_vars));\n+      struct ptr_info_def *orig_ptr_info = SSA_NAME_PTR_INFO (orig);\n+      struct ptr_info_def *new_ptr_info = SSA_NAME_PTR_INFO (new);\n+\n+      if (new_ptr_info == NULL)\n+\tduplicate_ssa_name_ptr_info (new, orig_ptr_info);\n+      else if (orig_ptr_info->name_mem_tag\n+\t       && new_ptr_info->name_mem_tag\n+\t       && orig_ptr_info->pt_vars\n+\t       && new_ptr_info->pt_vars)\n+\t{\n+\t  /* Note that pointer NEW may actually have a different set\n+\t     of pointed-to variables.  However, since NEW is being\n+\t     copy-propagated into ORIG, it must always be true that\n+\t     the pointed-to set for pointer NEW is the same, or a\n+\t     subset, of the pointed-to set for pointer ORIG.  If this\n+\t     isn't the case, we shouldn't have been able to do the\n+\t     propagation of NEW into ORIG.  */\n+\t  gcc_assert (bitmap_intersect_p (new_ptr_info->pt_vars,\n+\t\torig_ptr_info->pt_vars));\n+\t}\n     }\n-  }\n-#endif\n }   \n \n \n@@ -310,3 +308,776 @@ replace_exp (use_operand_p op_p, tree val)\n {\n   replace_exp_1 (op_p, val, false);\n }\n+\n+\n+/*---------------------------------------------------------------------------\n+\t\t\t\tCopy propagation\n+---------------------------------------------------------------------------*/\n+/* During propagation, we keep chains of variables that are copies of\n+   one another.  If variable X_i is a copy of X_j and X_j is a copy of\n+   X_k, COPY_OF will contain:\n+\n+   \tCOPY_OF[i].VALUE = X_j\n+\tCOPY_OF[j].VALUE = X_k\n+\tCOPY_OF[k].VALUE = X_k\n+\n+   After propagation, the copy-of value for each variable X_i is\n+   converted into the final value by walking the copy-of chains and\n+   updating COPY_OF[i].VALUE to be the last element of the chain.  */\n+static prop_value_t *copy_of;\n+\n+/* Used in set_copy_of_val to determine if the last link of a copy-of\n+   chain has changed.  */\n+static tree *cached_last_copy_of;\n+\n+/* True if we are doing copy propagation on loads and stores.  */\n+static bool do_store_copy_prop;\n+\n+\n+/* Return true if this statement may generate a useful copy.  */\n+\n+static bool\n+stmt_may_generate_copy (tree stmt)\n+{\n+  tree lhs, rhs;\n+  stmt_ann_t ann;\n+\n+  if (TREE_CODE (stmt) == PHI_NODE)\n+    return !SSA_NAME_OCCURS_IN_ABNORMAL_PHI (PHI_RESULT (stmt));\n+\n+  if (TREE_CODE (stmt) != MODIFY_EXPR)\n+    return false;\n+\n+  lhs = TREE_OPERAND (stmt, 0);\n+  rhs = TREE_OPERAND (stmt, 1);\n+  ann = stmt_ann (stmt);\n+\n+  /* If the statement has volatile operands, it won't generate a\n+     useful copy.  */\n+  if (ann->has_volatile_ops)\n+    return false;\n+\n+  /* If we are not doing store copy-prop, statements with loads and/or\n+     stores will never generate a useful copy.  */\n+  if (!do_store_copy_prop\n+      && (NUM_VUSES (VUSE_OPS (ann)) > 0\n+\t  || NUM_V_MAY_DEFS (V_MAY_DEF_OPS (ann)) > 0\n+\t  || NUM_V_MUST_DEFS (V_MUST_DEF_OPS (ann)) > 0))\n+    return false;\n+\n+  /* Otherwise, the only statements that generate useful copies are\n+     assignments whose RHS is just an SSA name that doesn't flow\n+     through abnormal edges.  */\n+  return TREE_CODE (rhs) == SSA_NAME && !SSA_NAME_OCCURS_IN_ABNORMAL_PHI (rhs);\n+}\n+\n+\n+/* Return the copy-of value for VAR.  */\n+\n+static inline prop_value_t *\n+get_copy_of_val (tree var)\n+{\n+  prop_value_t *val = &copy_of[SSA_NAME_VERSION (var)];\n+\n+  if (val->value == NULL_TREE\n+      && !stmt_may_generate_copy (SSA_NAME_DEF_STMT (var)))\n+    {\n+      /* If the variable will never generate a useful copy relation,\n+\t make it its own copy.  */\n+      val->value = var;\n+      val->mem_ref = NULL_TREE;\n+    }\n+\n+  return val;\n+}\n+\n+\n+/* Return last link in the copy-of chain for VAR.  */\n+\n+static tree\n+get_last_copy_of (tree var)\n+{\n+  tree last;\n+  int i;\n+\n+  /* Traverse COPY_OF starting at VAR until we get to the last\n+     link in the chain.  Since it is possible to have cycles in PHI\n+     nodes, the copy-of chain may also contain cycles.\n+     \n+     To avoid infinite loops and to avoid traversing lengthy copy-of\n+     chains, we artificially limit the maximum number of chains we are\n+     willing to traverse.\n+\n+     The value 5 was taken from a compiler and runtime library\n+     bootstrap and a mixture of C and C++ code from various sources.\n+     More than 82% of all copy-of chains were shorter than 5 links.  */\n+#define LIMIT\t5\n+\n+  last = var;\n+  for (i = 0; i < LIMIT; i++)\n+    {\n+      tree copy = copy_of[SSA_NAME_VERSION (last)].value;\n+      if (copy == NULL_TREE || copy == last)\n+\tbreak;\n+      last = copy;\n+    }\n+\n+  /* If we have reached the limit, then we are either in a copy-of\n+     cycle or the copy-of chain is too long.  In this case, just\n+     return VAR so that it is not considered a copy of anything.  */\n+  return (i < LIMIT ? last : var);\n+}\n+\n+\n+/* Set FIRST to be the first variable in the copy-of chain for DEST.\n+   If DEST's copy-of value or its copy-of chain have changed, return\n+   true.\n+\n+   MEM_REF is the memory reference where FIRST is stored.  This is\n+   used when DEST is a non-register and we are copy propagating loads\n+   and stores.  */\n+\n+static inline bool\n+set_copy_of_val (tree dest, tree first, tree mem_ref)\n+{\n+  unsigned int dest_ver = SSA_NAME_VERSION (dest);\n+  tree old_first, old_last, new_last;\n+  \n+  /* Set FIRST to be the first link in COPY_OF[DEST].  If that\n+     changed, return true.  */\n+  old_first = copy_of[dest_ver].value;\n+  copy_of[dest_ver].value = first;\n+  copy_of[dest_ver].mem_ref = mem_ref;\n+\n+  if (old_first != first)\n+    return true;\n+\n+  /* If FIRST and OLD_FIRST are the same, we need to check whether the\n+     copy-of chain starting at FIRST ends in a different variable.  If\n+     the copy-of chain starting at FIRST ends up in a different\n+     variable than the last cached value we had for DEST, then return\n+     true because DEST is now a copy of a different variable.\n+\n+     This test is necessary because even though the first link in the\n+     copy-of chain may not have changed, if any of the variables in\n+     the copy-of chain changed its final value, DEST will now be the\n+     copy of a different variable, so we have to do another round of\n+     propagation for everything that depends on DEST.  */\n+  old_last = cached_last_copy_of[dest_ver];\n+  new_last = get_last_copy_of (dest);\n+  cached_last_copy_of[dest_ver] = new_last;\n+\n+  return (old_last != new_last);\n+}\n+\n+\n+/* Dump the copy-of value for variable VAR to DUMP_FILE.  */\n+\n+static void\n+dump_copy_of (FILE *dump_file, tree var)\n+{\n+  tree val;\n+\n+  print_generic_expr (dump_file, var, dump_flags);\n+\n+  if (TREE_CODE (var) != SSA_NAME)\n+    return;\n+\n+  fprintf (dump_file, \" copy-of chain: \");\n+\n+  val = var;\n+  print_generic_expr (dump_file, val, 0);\n+  fprintf (dump_file, \" \");\n+  while (copy_of[SSA_NAME_VERSION (val)].value\n+         && copy_of[SSA_NAME_VERSION (val)].value != val)\n+    {\n+      fprintf (dump_file, \"-> \");\n+      val = copy_of[SSA_NAME_VERSION (val)].value;\n+      print_generic_expr (dump_file, val, 0);\n+      fprintf (dump_file, \" \");\n+    }\n+\n+  val = get_copy_of_val (var)->value;\n+  if (val == NULL_TREE)\n+    fprintf (dump_file, \"[UNDEFINED]\");\n+  else if (val != var)\n+    fprintf (dump_file, \"[COPY]\");\n+  else\n+    fprintf (dump_file, \"[NOT A COPY]\");\n+}\n+\n+\n+/* Evaluate the RHS of STMT.  If it produces a valid copy, set the LHS\n+   value and store the LHS into *RESULT_P.  If STMT generates more\n+   than one name (i.e., STMT is an aliased store), it is enough to\n+   store the first name in the V_MAY_DEF list into *RESULT_P.  After\n+   all, the names generated will be VUSEd in the same statements.  */\n+\n+static enum ssa_prop_result\n+copy_prop_visit_assignment (tree stmt, tree *result_p)\n+{\n+  tree lhs, rhs;\n+  prop_value_t *rhs_val;\n+\n+  lhs = TREE_OPERAND (stmt, 0);\n+  rhs = TREE_OPERAND (stmt, 1);\n+\n+  gcc_assert (TREE_CODE (rhs) == SSA_NAME);\n+\n+  rhs_val = get_copy_of_val (rhs);\n+\n+  if (TREE_CODE (lhs) == SSA_NAME)\n+    {\n+      /* Straight copy between two SSA names.  First, make sure that\n+\t we can propagate the RHS into uses of LHS.  */\n+      if (!may_propagate_copy (lhs, rhs))\n+\treturn SSA_PROP_VARYING;\n+\n+      /* Avoid copy propagation from an inner into an outer loop.\n+\t Otherwise, this may move loop variant variables outside of\n+\t their loops and prevent coalescing opportunities.  If the\n+\t value was loop invariant, it will be hoisted by LICM and\n+\t exposed for copy propagation.  */\n+      if (loop_depth_of_name (rhs) > loop_depth_of_name (lhs))\n+\treturn SSA_PROP_VARYING;\n+\n+      /* Notice that in the case of assignments, we make the LHS be a\n+\t copy of RHS's value, not of RHS itself.  This avoids keeping\n+\t unnecessary copy-of chains (assignments cannot be in a cycle\n+\t like PHI nodes), speeding up the propagation process.\n+\t This is different from what we do in copy_prop_visit_phi_node. \n+\t In those cases, we are interested in the copy-of chains.  */\n+      *result_p = lhs;\n+      if (set_copy_of_val (*result_p, rhs_val->value, rhs_val->mem_ref))\n+\treturn SSA_PROP_INTERESTING;\n+      else\n+\treturn SSA_PROP_NOT_INTERESTING;\n+    }\n+  else if (stmt_makes_single_store (stmt))\n+    {\n+      /* Otherwise, set the names in V_MAY_DEF/V_MUST_DEF operands\n+\t to be a copy of RHS.  */\n+      ssa_op_iter i;\n+      tree vdef;\n+      bool changed;\n+\n+      /* This should only be executed when doing store copy-prop.  */\n+      gcc_assert (do_store_copy_prop);\n+\n+      /* Set the value of every VDEF to RHS_VAL.  */\n+      changed = false;\n+      FOR_EACH_SSA_TREE_OPERAND (vdef, stmt, i, SSA_OP_VIRTUAL_DEFS)\n+\tchanged |= set_copy_of_val (vdef, rhs_val->value, lhs);\n+      \n+      /* Note that for propagation purposes, we are only interested in\n+\t visiting statements that load the exact same memory reference\n+\t stored here.  Those statements will have the exact same list\n+\t of virtual uses, so it is enough to set the output of this\n+\t statement to be its first virtual definition.  */\n+      *result_p = first_vdef (stmt);\n+\n+      if (changed)\n+\treturn SSA_PROP_INTERESTING;\n+      else\n+\treturn SSA_PROP_NOT_INTERESTING;\n+    }\n+\n+\n+  return SSA_PROP_VARYING;\n+}\n+\n+\n+/* Visit the COND_EXPR STMT.  Return SSA_PROP_INTERESTING\n+   if it can determine which edge will be taken.  Otherwise, return\n+   SSA_PROP_VARYING.  */\n+\n+static enum ssa_prop_result\n+copy_prop_visit_cond_stmt (tree stmt, edge *taken_edge_p)\n+{\n+  enum ssa_prop_result retval;\n+  tree cond;\n+  use_optype uses;\n+\n+  cond = COND_EXPR_COND (stmt);\n+  uses = STMT_USE_OPS (stmt);\n+  retval = SSA_PROP_VARYING;\n+\n+  /* The only conditionals that we may be able to compute statically\n+     are predicates involving at least one SSA_NAME.  */\n+  if (TREE_CODE_CLASS (TREE_CODE (cond)) == tcc_comparison\n+      && NUM_USES (uses) >= 1)\n+    {\n+      unsigned i;\n+      tree *orig;\n+\n+      /* Save the original operands.  */\n+      orig = xmalloc (sizeof (tree) * NUM_USES (uses));\n+      for (i = 0; i < NUM_USES (uses); i++)\n+\t{\n+\t  orig[i] = USE_OP (uses, i);\n+\t  SET_USE_OP (uses, i, get_last_copy_of (USE_OP (uses, i)));\n+\t}\n+\n+      /* See if we can determine the predicate's value.  */\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  fprintf (dump_file, \"Trying to determine truth value of \");\n+\t  fprintf (dump_file, \"predicate \");\n+\t  print_generic_stmt (dump_file, cond, 0);\n+\t}\n+\n+      *taken_edge_p = find_taken_edge (bb_for_stmt (stmt), cond);\n+      if (*taken_edge_p)\n+\tretval = SSA_PROP_INTERESTING;\n+\n+      /* Restore the original operands.  */\n+      for (i = 0; i < NUM_USES (uses); i++)\n+\tSET_USE_OP (uses, i, orig[i]);\n+      free (orig);\n+    }\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS) && *taken_edge_p)\n+    fprintf (dump_file, \"\\nConditional will always take edge %d->%d\\n\",\n+\t     (*taken_edge_p)->src->index, (*taken_edge_p)->dest->index);\n+\n+  return retval;\n+}\n+\n+\n+/* Evaluate statement STMT.  If the statement produces a new output\n+   value, return SSA_PROP_INTERESTING and store the SSA_NAME holding\n+   the new value in *RESULT_P.\n+\n+   If STMT is a conditional branch and we can determine its truth\n+   value, set *TAKEN_EDGE_P accordingly.\n+\n+   If the new value produced by STMT is varying, return\n+   SSA_PROP_VARYING.  */\n+\n+static enum ssa_prop_result\n+copy_prop_visit_stmt (tree stmt, edge *taken_edge_p, tree *result_p)\n+{\n+  stmt_ann_t ann;\n+  enum ssa_prop_result retval;\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"\\nVisiting statement:\\n\");\n+      print_generic_stmt (dump_file, stmt, dump_flags);\n+      fprintf (dump_file, \"\\n\");\n+    }\n+\n+  ann = stmt_ann (stmt);\n+\n+  if (TREE_CODE (stmt) == MODIFY_EXPR\n+      && TREE_CODE (TREE_OPERAND (stmt, 1)) == SSA_NAME\n+      && (do_store_copy_prop\n+\t  || TREE_CODE (TREE_OPERAND (stmt, 0)) == SSA_NAME))\n+    {\n+      /* If the statement is a copy assignment, evaluate its RHS to\n+\t see if the lattice value of its output has changed.  */\n+      retval = copy_prop_visit_assignment (stmt, result_p);\n+    }\n+  else if (TREE_CODE (stmt) == COND_EXPR)\n+    {\n+      /* See if we can determine which edge goes out of a conditional\n+\t jump.  */\n+      retval = copy_prop_visit_cond_stmt (stmt, taken_edge_p);\n+    }\n+  else\n+    retval = SSA_PROP_VARYING;\n+\n+  if (retval == SSA_PROP_VARYING)\n+    {\n+      tree def;\n+      ssa_op_iter i;\n+\n+      /* Any other kind of statement is not interesting for constant\n+\t propagation and, therefore, not worth simulating.  */\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \"No interesting values produced.\\n\");\n+\n+      /* The assignment is not a copy operation.  Don't visit this\n+\t statement again and mark all the definitions in the statement\n+\t to be copies of nothing.  */\n+      FOR_EACH_SSA_TREE_OPERAND (def, stmt, i, SSA_OP_ALL_DEFS)\n+\tset_copy_of_val (def, def, NULL_TREE);\n+    }\n+\n+  return retval;\n+}\n+\n+\n+/* Visit PHI node PHI.  If all the arguments produce the same value,\n+   set it to be the value of the LHS of PHI.  */\n+\n+static enum ssa_prop_result\n+copy_prop_visit_phi_node (tree phi)\n+{\n+  enum ssa_prop_result retval;\n+  int i;\n+  tree lhs;\n+  prop_value_t phi_val = { 0, NULL_TREE, NULL_TREE };\n+\n+  lhs = PHI_RESULT (phi);\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"\\nVisiting PHI node: \");\n+      print_generic_expr (dump_file, phi, dump_flags);\n+      fprintf (dump_file, \"\\n\\n\");\n+    }\n+\n+  for (i = 0; i < PHI_NUM_ARGS (phi); i++)\n+    {\n+      prop_value_t *arg_val;\n+      tree arg = PHI_ARG_DEF (phi, i);\n+      edge e = PHI_ARG_EDGE (phi, i);\n+\n+      /* We don't care about values flowing through non-executable\n+\t edges.  */\n+      if (!(e->flags & EDGE_EXECUTABLE))\n+\tcontinue;\n+\n+      /* Constants in the argument list never generate a useful copy.\n+\t Similarly, names that flow through abnormal edges cannot be\n+\t used to derive copies.  */\n+      if (TREE_CODE (arg) != SSA_NAME || SSA_NAME_OCCURS_IN_ABNORMAL_PHI (arg))\n+\t{\n+\t  phi_val.value = lhs;\n+\t  break;\n+\t}\n+\n+      /* Avoid copy propagation from an inner into an outer loop.\n+\t Otherwise, this may move loop variant variables outside of\n+\t their loops and prevent coalescing opportunities.  If the\n+\t value was loop invariant, it will be hoisted by LICM and\n+\t exposed for copy propagation.  */\n+      if (loop_depth_of_name (arg) > loop_depth_of_name (lhs))\n+\t{\n+\t  phi_val.value = lhs;\n+\t  break;\n+\t}\n+\n+      /* If the LHS appears in the argument list, ignore it.  It is\n+\t irrelevant as a copy.  */\n+      if (arg == lhs || get_last_copy_of (arg) == lhs)\n+\tcontinue;\n+\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  fprintf (dump_file, \"\\tArgument #%d: \", i);\n+\t  dump_copy_of (dump_file, arg);\n+\t  fprintf (dump_file, \"\\n\");\n+\t}\n+\n+      arg_val = get_copy_of_val (arg);\n+\n+      /* If the LHS didn't have a value yet, make it a copy of the\n+\t first argument we find.  Notice that while we make the LHS be\n+\t a copy of the argument itself, we take the memory reference\n+\t from the argument's value so that we can compare it to the\n+\t memory reference of all the other arguments.  */\n+      if (phi_val.value == NULL_TREE)\n+\t{\n+\t  phi_val.value = arg;\n+\t  phi_val.mem_ref = arg_val->mem_ref;\n+\t  continue;\n+\t}\n+\n+      /* If PHI_VAL and ARG don't have a common copy-of chain, then\n+\t this PHI node cannot be a copy operation.  Also, if we are\n+\t copy propagating stores and these two arguments came from\n+\t different memory references, they cannot be considered\n+\t copies.  */\n+      if (get_last_copy_of (phi_val.value) != get_last_copy_of (arg)\n+\t  || (do_store_copy_prop\n+\t      && phi_val.mem_ref\n+\t      && arg_val->mem_ref\n+\t      && simple_cst_equal (phi_val.mem_ref, arg_val->mem_ref) != 1))\n+\t{\n+\t  phi_val.value = lhs;\n+\t  break;\n+\t}\n+    }\n+\n+  if (phi_val.value && set_copy_of_val (lhs, phi_val.value, phi_val.mem_ref))\n+    retval = (phi_val.value != lhs) ? SSA_PROP_INTERESTING : SSA_PROP_VARYING;\n+  else\n+    retval = SSA_PROP_NOT_INTERESTING;\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"\\nPHI node \");\n+      dump_copy_of (dump_file, lhs);\n+      fprintf (dump_file, \"\\nTelling the propagator to \");\n+      if (retval == SSA_PROP_INTERESTING)\n+\tfprintf (dump_file, \"add SSA edges out of this PHI and continue.\");\n+      else if (retval == SSA_PROP_VARYING)\n+\tfprintf (dump_file, \"add SSA edges out of this PHI and never visit again.\");\n+      else\n+\tfprintf (dump_file, \"do nothing with SSA edges and keep iterating.\");\n+      fprintf (dump_file, \"\\n\\n\");\n+    }\n+\n+  return retval;\n+}\n+\n+\n+/* Initialize structures used for copy propagation.  */\n+\n+static void\n+init_copy_prop (void)\n+{\n+  basic_block bb;\n+\n+  copy_of = xmalloc (num_ssa_names * sizeof (*copy_of));\n+  memset (copy_of, 0, num_ssa_names * sizeof (*copy_of));\n+\n+  cached_last_copy_of = xmalloc (num_ssa_names * sizeof (*cached_last_copy_of));\n+  memset (cached_last_copy_of, 0, num_ssa_names * sizeof (*cached_last_copy_of));\n+\n+  FOR_EACH_BB (bb)\n+    {\n+      block_stmt_iterator si;\n+      tree phi;\n+\n+      for (si = bsi_start (bb); !bsi_end_p (si); bsi_next (&si))\n+\t{\n+\t  tree stmt = bsi_stmt (si);\n+\n+\t  /* The only statements that we care about are those that may\n+\t     generate useful copies.  We also need to mark conditional\n+\t     jumps so that their outgoing edges are added to the work\n+\t     lists of the propagator.  */\n+\t  if (stmt_ends_bb_p (stmt))\n+\t    DONT_SIMULATE_AGAIN (stmt) = false;\n+\t  else if (stmt_may_generate_copy (stmt))\n+\t    DONT_SIMULATE_AGAIN (stmt) = false;\n+\t  else\n+\t    {\n+\t      tree def;\n+\t      ssa_op_iter iter;\n+\n+\t      /* No need to simulate this statement anymore.  */\n+\t      DONT_SIMULATE_AGAIN (stmt) = true;\n+\n+\t      /* Mark all the outputs of this statement as not being\n+\t\t the copy of anything.  */\n+\t      FOR_EACH_SSA_TREE_OPERAND (def, stmt, iter, SSA_OP_ALL_DEFS)\n+\t\tset_copy_of_val (def, def, NULL_TREE);\n+\t    }\n+\t}\n+\n+      for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n+\tDONT_SIMULATE_AGAIN (phi) = false;\n+    }\n+}\n+\n+\n+/* Deallocate memory used in copy propagation and do final\n+   substitution.  */\n+\n+static void\n+fini_copy_prop (void)\n+{\n+  size_t i;\n+  \n+  /* Set the final copy-of value for each variable by traversing the\n+     copy-of chains.  */\n+  for (i = 1; i < num_ssa_names; i++)\n+    {\n+      tree var = ssa_name (i);\n+      if (var && copy_of[i].value && copy_of[i].value != var)\n+\tcopy_of[i].value = get_last_copy_of (var);\n+    }\n+\n+  substitute_and_fold (copy_of);\n+\n+  free (copy_of);\n+}\n+\n+\n+/* Main entry point to the copy propagator.  The algorithm propagates\n+   the value COPY-OF using ssa_propagate.  For every variable X_i,\n+   COPY-OF(X_i) indicates which variable is X_i created from.  The\n+   following example shows how the algorithm proceeds at a high level:\n+\n+\t    1\ta_24 = x_1\n+\t    2\ta_2 = PHI <a_24, x_1>\n+\t    3\ta_5 = PHI <a_2>\n+\t    4\tx_1 = PHI <x_298, a_5, a_2>\n+\n+   The end result should be that a_2, a_5, a_24 and x_1 are a copy of\n+   x_298.  Propagation proceeds as follows.\n+\n+   Visit #1: a_24 is copy-of x_1.  Value changed.\n+   Visit #2: a_2 is copy-of x_1.  Value changed.\n+   Visit #3: a_5 is copy-of x_1.  Value changed.\n+   Visit #4: x_1 is copy-of x_298.  Value changed.\n+   Visit #1: a_24 is copy-of x_298.  Value changed.\n+   Visit #2: a_2 is copy-of x_298.  Value changed.\n+   Visit #3: a_5 is copy-of x_298.  Value changed.\n+   Visit #4: x_1 is copy-of x_298.  Stable state reached.\n+   \n+   When visiting PHI nodes, we only consider arguments that flow\n+   through edges marked executable by the propagation engine.  So,\n+   when visiting statement #2 for the first time, we will only look at\n+   the first argument (a_24) and optimistically assume that its value\n+   is the copy of a_24 (x_1).\n+\n+   The problem with this approach is that it may fail to discover copy\n+   relations in PHI cycles.  Instead of propagating copy-of\n+   values, we actually propagate copy-of chains.  For instance:\n+\n+   \t\tA_3 = B_1;\n+\t\tC_9 = A_3;\n+\t\tD_4 = C_9;\n+\t\tX_i = D_4;\n+\n+   In this code fragment, COPY-OF (X_i) = { D_4, C_9, A_3, B_1 }.\n+   Obviously, we are only really interested in the last value of the\n+   chain, however the propagator needs to access the copy-of chain\n+   when visiting PHI nodes.\n+\n+   To represent the copy-of chain, we use the array COPY_CHAINS, which\n+   holds the first link in the copy-of chain for every variable.\n+   If variable X_i is a copy of X_j, which in turn is a copy of X_k,\n+   the array will contain:\n+\n+\t\tCOPY_CHAINS[i] = X_j\n+\t\tCOPY_CHAINS[j] = X_k\n+\t\tCOPY_CHAINS[k] = X_k\n+\n+   Keeping copy-of chains instead of copy-of values directly becomes\n+   important when visiting PHI nodes.  Suppose that we had the\n+   following PHI cycle, such that x_52 is already considered a copy of\n+   x_53:\n+\n+\t    1\tx_54 = PHI <x_53, x_52>\n+\t    2\tx_53 = PHI <x_898, x_54>\n+   \n+   Visit #1: x_54 is copy-of x_53 (because x_52 is copy-of x_53)\n+   Visit #2: x_53 is copy-of x_898 (because x_54 is a copy of x_53,\n+\t\t\t\t    so it is considered irrelevant\n+\t\t\t\t    as a copy).\n+   Visit #1: x_54 is copy-of nothing (x_53 is a copy-of x_898 and\n+\t\t\t\t      x_52 is a copy of x_53, so\n+\t\t\t\t      they don't match)\n+   Visit #2: x_53 is copy-of nothing\n+\n+   This problem is avoided by keeping a chain of copies, instead of\n+   the final copy-of value.  Propagation will now only keep the first\n+   element of a variable's copy-of chain.  When visiting PHI nodes,\n+   arguments are considered equal if their copy-of chains end in the\n+   same variable.  So, as long as their copy-of chains overlap, we\n+   know that they will be a copy of the same variable, regardless of\n+   which variable that may be).\n+   \n+   Propagation would then proceed as follows (the notation a -> b\n+   means that a is a copy-of b):\n+\n+   Visit #1: x_54 = PHI <x_53, x_52>\n+\t\tx_53 -> x_53\n+\t\tx_52 -> x_53\n+\t\tResult: x_54 -> x_53.  Value changed.  Add SSA edges.\n+\n+   Visit #1: x_53 = PHI <x_898, x_54>\n+   \t\tx_898 -> x_898\n+\t\tx_54 -> x_53\n+\t\tResult: x_53 -> x_898.  Value changed.  Add SSA edges.\n+\n+   Visit #2: x_54 = PHI <x_53, x_52>\n+   \t\tx_53 -> x_898\n+\t\tx_52 -> x_53 -> x_898\n+\t\tResult: x_54 -> x_898.  Value changed.  Add SSA edges.\n+\n+   Visit #2: x_53 = PHI <x_898, x_54>\n+   \t\tx_898 -> x_898\n+\t\tx_54 -> x_898\n+\t\tResult: x_53 -> x_898.  Value didn't change.  Stable state\n+\n+   Once the propagator stabilizes, we end up with the desired result\n+   x_53 and x_54 are both copies of x_898.  */\n+\n+static void\n+execute_copy_prop (bool store_copy_prop)\n+{\n+  do_store_copy_prop = store_copy_prop;\n+  init_copy_prop ();\n+  ssa_propagate (copy_prop_visit_stmt, copy_prop_visit_phi_node);\n+  fini_copy_prop ();\n+}\n+\n+\n+static bool\n+gate_copy_prop (void)\n+{\n+  return flag_tree_copy_prop != 0;\n+}\n+\n+static void\n+do_copy_prop (void)\n+{\n+  execute_copy_prop (false);\n+}\n+\n+struct tree_opt_pass pass_copy_prop =\n+{\n+  \"copyprop\",\t\t\t\t/* name */\n+  gate_copy_prop,\t\t\t/* gate */\n+  do_copy_prop,\t\t\t\t/* execute */\n+  NULL,\t\t\t\t\t/* sub */\n+  NULL,\t\t\t\t\t/* next */\n+  0,\t\t\t\t\t/* static_pass_number */\n+  TV_TREE_COPY_PROP,\t\t\t/* tv_id */\n+  PROP_ssa | PROP_alias | PROP_cfg,\t/* properties_required */\n+  0,\t\t\t\t\t/* properties_provided */\n+  0,\t\t\t\t\t/* properties_destroyed */\n+  0,\t\t\t\t\t/* todo_flags_start */\n+  TODO_cleanup_cfg\n+    | TODO_dump_func\n+    | TODO_ggc_collect\n+    | TODO_verify_ssa\n+    | TODO_update_ssa,\t\t\t/* todo_flags_finish */\n+  0\t\t\t\t\t/* letter */\n+};\n+\n+\n+static bool\n+gate_store_copy_prop (void)\n+{\n+  /* STORE-COPY-PROP is enabled only with -ftree-store-copy-prop, but\n+     when -fno-tree-store-copy-prop is specified, we should run\n+     regular COPY-PROP. That's why the pass is enabled with either\n+     flag.  */\n+  return flag_tree_store_copy_prop != 0 || flag_tree_copy_prop != 0;\n+}\n+\n+static void\n+store_copy_prop (void)\n+{\n+  /* If STORE-COPY-PROP is not enabled, we just run regular COPY-PROP.  */\n+  execute_copy_prop (flag_tree_store_copy_prop != 0);\n+}\n+\n+struct tree_opt_pass pass_store_copy_prop =\n+{\n+  \"store_copyprop\",\t\t\t/* name */\n+  gate_store_copy_prop,\t\t\t/* gate */\n+  store_copy_prop,\t\t\t/* execute */\n+  NULL,\t\t\t\t\t/* sub */\n+  NULL,\t\t\t\t\t/* next */\n+  0,\t\t\t\t\t/* static_pass_number */\n+  TV_TREE_STORE_COPY_PROP,\t\t/* tv_id */\n+  PROP_ssa | PROP_alias | PROP_cfg,\t/* properties_required */\n+  0,\t\t\t\t\t/* properties_provided */\n+  0,\t\t\t\t\t/* properties_destroyed */\n+  0,\t\t\t\t\t/* todo_flags_start */\n+  TODO_dump_func\n+    | TODO_cleanup_cfg\n+    | TODO_ggc_collect\n+    | TODO_verify_ssa\n+    | TODO_update_ssa,\t\t\t/* todo_flags_finish */\n+  0\t\t\t\t\t/* letter */\n+};"}, {"sha": "582de359dd74db3511f5f2694f1161fc0eb7d2e5", "filename": "gcc/tree-ssa-dce.c", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftree-ssa-dce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftree-ssa-dce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dce.c?ref=0bca51f080dfff5e943b1f1775d874a73bbc441a", "patch": "@@ -779,8 +779,7 @@ remove_dead_stmt (block_stmt_iterator *i, basic_block bb)\n \t\t\t    SSA_OP_VIRTUAL_DEFS | SSA_OP_VIRTUAL_KILLS)\n     {\n       tree def = DEF_FROM_PTR (def_p);\n-      bitmap_set_bit (vars_to_rename,\n-\t\t      var_ann (SSA_NAME_VAR (def))->uid);\n+      mark_sym_for_renaming (SSA_NAME_VAR (def));\n     }\n   bsi_remove (i);  \n   release_defs (t); \n@@ -942,7 +941,11 @@ struct tree_opt_pass pass_dce =\n   0,\t\t\t\t\t/* properties_provided */\n   0,\t\t\t\t\t/* properties_destroyed */\n   0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_dump_func | TODO_fix_def_def_chains | TODO_cleanup_cfg | TODO_ggc_collect | TODO_verify_ssa,\t/* todo_flags_finish */\n+  TODO_dump_func \n+    | TODO_update_ssa_no_phi \n+    | TODO_cleanup_cfg\n+    | TODO_ggc_collect\n+    | TODO_verify_ssa,\t\t\t/* todo_flags_finish */\n   0\t\t\t\t\t/* letter */\n };\n \n@@ -959,8 +962,12 @@ struct tree_opt_pass pass_cd_dce =\n   0,\t\t\t\t\t/* properties_provided */\n   0,\t\t\t\t\t/* properties_destroyed */\n   0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_dump_func | TODO_fix_def_def_chains | TODO_cleanup_cfg | TODO_ggc_collect | TODO_verify_ssa | TODO_verify_flow,\n-\t\t\t\t\t/* todo_flags_finish */\n+  TODO_dump_func\n+    | TODO_update_ssa_no_phi\n+    | TODO_cleanup_cfg\n+    | TODO_ggc_collect\n+    | TODO_verify_ssa\n+    | TODO_verify_flow,\t\t\t/* todo_flags_finish */\n   0\t\t\t\t\t/* letter */\n };\n "}, {"sha": "1d4f9b0b1c20d731beb64addcb50af89b394bc4f", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 27, "deletions": 35, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=0bca51f080dfff5e943b1f1775d874a73bbc441a", "patch": "@@ -174,6 +174,8 @@ struct opt_stats_d\n   long num_stmts;\n   long num_exprs_considered;\n   long num_re;\n+  long num_const_prop;\n+  long num_copy_prop;\n };\n \n static struct opt_stats_d opt_stats;\n@@ -299,6 +301,7 @@ static edge single_incoming_edge_ignoring_loop_edges (basic_block);\n static void restore_nonzero_vars_to_original_value (void);\n static inline bool unsafe_associative_fp_binop (tree);\n \n+\n /* Local version of fold that doesn't introduce cruft.  */\n \n static tree\n@@ -403,6 +406,7 @@ tree_ssa_dominator_optimize (void)\n      structure.  */\n   walk_data.global_data = NULL;\n   walk_data.block_local_data_size = 0;\n+  walk_data.interesting_blocks = NULL;\n \n   /* Now initialize the dominator walker.  */\n   init_walk_dominator_tree (&walk_data);\n@@ -442,11 +446,7 @@ tree_ssa_dominator_optimize (void)\n \t interactions between rewriting of _DECL nodes into SSA form\n \t and rewriting SSA_NAME nodes into SSA form after block\n \t duplication and CFG manipulation.  */\n-      if (!bitmap_empty_p (vars_to_rename))\n-\t{\n-\t  rewrite_into_ssa (false);\n-\t  bitmap_clear (vars_to_rename);\n-\t}\n+      update_ssa (TODO_update_ssa);\n \n       free_all_edge_infos ();\n \n@@ -572,7 +572,8 @@ struct tree_opt_pass pass_dominator =\n   0,\t\t\t\t\t/* properties_provided */\n   0,\t\t\t\t\t/* properties_destroyed */\n   0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_dump_func | TODO_rename_vars\n+  TODO_dump_func\n+    | TODO_update_ssa\n     | TODO_verify_ssa,\t\t\t/* todo_flags_finish */\n   0\t\t\t\t\t/* letter */\n };\n@@ -1200,7 +1201,7 @@ dom_opt_finalize_block (struct dom_walk_data *walk_data, basic_block bb)\n \tbreak;\n \n       VEC_pop (tree_on_heap, stmts_to_rescan);\n-      mark_new_vars_to_rename (stmt, vars_to_rename);\n+      mark_new_vars_to_rename (stmt);\n     }\n }\n \n@@ -1386,6 +1387,10 @@ dump_dominator_optimization_stats (FILE *file)\n   fprintf (file, \"    Redundant expressions eliminated:         %6ld (%.0f%%)\\n\",\n \t   opt_stats.num_re, PERCENT (opt_stats.num_re,\n \t\t\t\t      n_exprs));\n+  fprintf (file, \"    Constants propagated:                     %6ld\\n\",\n+\t   opt_stats.num_const_prop);\n+  fprintf (file, \"    Copies propagated:                        %6ld\\n\",\n+\t   opt_stats.num_copy_prop);\n \n   fprintf (file, \"\\nHash table statistics:\\n\");\n \n@@ -1600,7 +1605,7 @@ record_const_or_copy_1 (tree x, tree y, tree prev_x)\n    will be relatively correct, and as more passes are taught to keep loop info\n    up to date, the result will become more and more accurate.  */\n \n-static int\n+int\n loop_depth_of_name (tree x)\n {\n   tree defstmt;\n@@ -2229,9 +2234,9 @@ simplify_cond_and_lookup_avail_expr (tree stmt,\n \t\t     Similarly the high value for the merged range is the\n \t\t     minimum of the previous high value and the high value of\n \t\t     this record.  */\n-\t\t  low = (tree_int_cst_compare (low, tmp_low) == 1\n+\t\t  low = (low && tree_int_cst_compare (low, tmp_low) == 1\n \t\t\t ? low : tmp_low);\n-\t\t  high = (tree_int_cst_compare (high, tmp_high) == -1\n+\t\t  high = (high && tree_int_cst_compare (high, tmp_high) == -1\n \t\t\t  ? high : tmp_high);\n \t\t}\n \n@@ -2424,12 +2429,11 @@ cprop_into_successor_phis (basic_block bb, bitmap nonzero_vars)\n \t     ORIG_P with its value in our constant/copy table.  */\n \t  new = SSA_NAME_VALUE (orig);\n \t  if (new\n+\t      && new != orig\n \t      && (TREE_CODE (new) == SSA_NAME\n \t\t  || is_gimple_min_invariant (new))\n \t      && may_propagate_copy (orig, new))\n-\t    {\n-\t      propagate_value (orig_p, new);\n-\t    }\n+\t    propagate_value (orig_p, new);\n \t}\n     }\n }\n@@ -2624,7 +2628,6 @@ static void\n propagate_to_outgoing_edges (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n \t\t\t     basic_block bb)\n {\n-  \n   record_edge_info (bb);\n   cprop_into_successor_phis (bb, nonzero_vars);\n }\n@@ -2756,24 +2759,7 @@ record_equivalences_from_stmt (tree stmt,\n \t      || is_gimple_min_invariant (rhs)))\n \tSSA_NAME_VALUE (lhs) = rhs;\n \n-      /* alloca never returns zero and the address of a non-weak symbol\n-\t is never zero.  NOP_EXPRs and CONVERT_EXPRs can be completely\n-\t stripped as they do not affect this equivalence.  */\n-      while (TREE_CODE (rhs) == NOP_EXPR\n-\t     || TREE_CODE (rhs) == CONVERT_EXPR)\n-        rhs = TREE_OPERAND (rhs, 0);\n-\n-      if (alloca_call_p (rhs)\n-          || (TREE_CODE (rhs) == ADDR_EXPR\n-\t      && DECL_P (TREE_OPERAND (rhs, 0))\n-\t      && ! DECL_WEAK (TREE_OPERAND (rhs, 0))))\n-\trecord_var_is_nonzero (lhs);\n-\n-      /* IOR of any value with a nonzero value will result in a nonzero\n-\t value.  Even if we do not know the exact result recording that\n-\t the result is nonzero is worth the effort.  */\n-      if (TREE_CODE (rhs) == BIT_IOR_EXPR\n-\t  && integer_nonzerop (TREE_OPERAND (rhs, 1)))\n+      if (expr_computes_nonzero (rhs))\n \trecord_var_is_nonzero (lhs);\n     }\n \n@@ -2875,7 +2861,7 @@ cprop_operand (tree stmt, use_operand_p op_p)\n      copy of some other variable, use the value or copy stored in\n      CONST_AND_COPIES.  */\n   val = SSA_NAME_VALUE (op);\n-  if (val && TREE_CODE (val) != VALUE_HANDLE)\n+  if (val && val != op && TREE_CODE (val) != VALUE_HANDLE)\n     {\n       tree op_type, val_type;\n \n@@ -2885,8 +2871,9 @@ cprop_operand (tree stmt, use_operand_p op_p)\n \t statement.  Also only allow the new value to be an SSA_NAME\n \t for propagation into virtual operands.  */\n       if (!is_gimple_reg (op)\n-\t  && (get_virtual_var (val) != get_virtual_var (op)\n-\t      || TREE_CODE (val) != SSA_NAME))\n+\t  && (TREE_CODE (val) != SSA_NAME\n+\t      || is_gimple_reg (val)\n+\t      || get_virtual_var (val) != get_virtual_var (op)))\n \treturn false;\n \n       /* Do not replace hard register operands in asm statements.  */\n@@ -2952,6 +2939,11 @@ cprop_operand (tree stmt, use_operand_p op_p)\n \t      && is_gimple_min_invariant (val)))\n \tmay_have_exposed_new_symbols = true;\n \n+      if (TREE_CODE (val) != SSA_NAME)\n+\topt_stats.num_const_prop++;\n+      else\n+\topt_stats.num_copy_prop++;\n+\n       propagate_value (op_p, val);\n \n       /* And note that we modified this statement.  This is now"}, {"sha": "4d929e1331b507543df4efa6736f442e320ec900", "filename": "gcc/tree-ssa-dse.c", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftree-ssa-dse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftree-ssa-dse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dse.c?ref=0bca51f080dfff5e943b1f1775d874a73bbc441a", "patch": "@@ -251,6 +251,9 @@ dse_optimize_stmt (struct dom_walk_data *walk_data,\n \t  && operand_equal_p (TREE_OPERAND (stmt, 0),\n \t\t\t      TREE_OPERAND (use_stmt, 0), 0))\n \t{\n+\t  tree def;\n+\t  ssa_op_iter iter;\n+\n \t  /* Make sure we propagate the ABNORMAL bit setting.  */\n \t  if (SSA_NAME_OCCURS_IN_ABNORMAL_PHI (USE_FROM_PTR (first_use_p)))\n \t    SSA_NAME_OCCURS_IN_ABNORMAL_PHI (usevar) = 1;\n@@ -267,6 +270,12 @@ dse_optimize_stmt (struct dom_walk_data *walk_data,\n \t  /* Remove the dead store.  */\n \t  bsi_remove (&bsi);\n \n+\t  /* The virtual defs for the dead statement will need to be\n+\t     updated.  Since these names are going to disappear,\n+\t     FUD chains for uses downstream need to be updated.  */\n+\t  FOR_EACH_SSA_TREE_OPERAND (def, stmt, iter, SSA_OP_VIRTUAL_DEFS)\n+\t    mark_sym_for_renaming (SSA_NAME_VAR (def));\n+\n \t  /* And release any SSA_NAMEs set in this statement back to the\n \t     SSA_NAME manager.  */\n \t  release_defs (stmt);\n@@ -347,6 +356,7 @@ tree_ssa_dse (void)\n   walk_data.after_dom_children_before_stmts = NULL;\n   walk_data.after_dom_children_walk_stmts = NULL;\n   walk_data.after_dom_children_after_stmts = dse_finalize_block;\n+  walk_data.interesting_blocks = NULL;\n \n   walk_data.block_local_data_size = sizeof (struct dse_block_local_data);\n \n@@ -384,12 +394,15 @@ struct tree_opt_pass pass_dse = {\n   NULL,\t\t\t\t/* next */\n   0,\t\t\t\t/* static_pass_number */\n   TV_TREE_DSE,\t\t\t/* tv_id */\n-  PROP_cfg | PROP_ssa\n+  PROP_cfg\n+    | PROP_ssa\n     | PROP_alias,\t\t/* properties_required */\n   0,\t\t\t\t/* properties_provided */\n   0,\t\t\t\t/* properties_destroyed */\n   0,\t\t\t\t/* todo_flags_start */\n-  TODO_dump_func | TODO_ggc_collect\t/* todo_flags_finish */\n-  | TODO_verify_ssa,\n-  0\t\t\t\t\t/* letter */\n+  TODO_dump_func\n+    | TODO_ggc_collect\n+    | TODO_update_ssa\n+    | TODO_verify_ssa,\t\t/* todo_flags_finish */\n+  0\t\t\t\t/* letter */\n };"}, {"sha": "c465e2e15d4081ca8557bb5b73ed6cdca33ab6a5", "filename": "gcc/tree-ssa-loop-ch.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftree-ssa-loop-ch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftree-ssa-loop-ch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ch.c?ref=0bca51f080dfff5e943b1f1775d874a73bbc441a", "patch": "@@ -237,10 +237,6 @@ copy_loop_headers (void)\n   free (bbs);\n   free (copied_bbs);\n \n-#ifdef ENABLE_CHECKING\n-  verify_loop_closed_ssa ();\n-#endif\n-\n   loop_optimizer_finalize (loops, NULL);\n }\n "}, {"sha": "a0c45821cdb0e701db993e709e11ab84dee7057a", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=0bca51f080dfff5e943b1f1775d874a73bbc441a", "patch": "@@ -720,15 +720,14 @@ move_computations (void)\n   fini_walk_dominator_tree (&walk_data);\n \n   loop_commit_inserts ();\n-  rewrite_into_ssa (false);\n-  if (!bitmap_empty_p (vars_to_rename))\n-    {\n-      /* The rewrite of ssa names may cause violation of loop closed ssa\n-\t form invariants.  TODO -- avoid these rewrites completely.\n-\t Information in virtual phi nodes is sufficient for it.  */\n-      rewrite_into_loop_closed_ssa (NULL);\n-    }\n-  bitmap_clear (vars_to_rename);\n+\n+  if (need_ssa_update_p ())\n+    update_ssa (TODO_update_ssa);\n+\n+  /* The movement of LI code may cause violation of loop closed SSA\n+     form invariants.  TODO -- avoid these rewrites completely.\n+     Information in virtual phi nodes is sufficient for it.  */\n+  rewrite_into_loop_closed_ssa (NULL);\n }\n \n /* Checks whether the statement defining variable *INDEX can be hoisted\n@@ -1096,10 +1095,7 @@ rewrite_mem_refs (tree tmp_var, struct mem_ref *mem_refs)\n   for (; mem_refs; mem_refs = mem_refs->next)\n     {\n       FOR_EACH_SSA_TREE_OPERAND (var, mem_refs->stmt, iter, SSA_OP_ALL_VIRTUALS)\n-\t{\n-\t  var = SSA_NAME_VAR (var);\n-\t  bitmap_set_bit (vars_to_rename, var_ann (var)->uid);\n-\t}\n+\tmark_sym_for_renaming (SSA_NAME_VAR (var));\n \n       *mem_refs->ref = tmp_var;\n       update_stmt (mem_refs->stmt);"}, {"sha": "6dbb451fadf7eec1dfcb7e5e0324de5d33091f88", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 36, "deletions": 17, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=0bca51f080dfff5e943b1f1775d874a73bbc441a", "patch": "@@ -4810,7 +4810,7 @@ unshare_and_remove_ssa_names (tree ref)\n static void\n rewrite_address_base (block_stmt_iterator *bsi, tree *op, tree with)\n {\n-  tree bvar, var, new_var, new_name, copy, name;\n+  tree bvar, var, new_name, copy, name;\n   tree orig;\n \n   var = bvar = get_base_address (*op);\n@@ -4832,24 +4832,27 @@ rewrite_address_base (block_stmt_iterator *bsi, tree *op, tree with)\n   else\n     goto do_rewrite;\n     \n-  if (var_ann (var)->type_mem_tag)\n-    var = var_ann (var)->type_mem_tag;\n-\n   /* We need to add a memory tag for the variable.  But we do not want\n      to add it to the temporary used for the computations, since this leads\n      to problems in redundancy elimination when there are common parts\n      in two computations referring to the different arrays.  So we copy\n      the variable to a new temporary.  */\n   copy = build2 (MODIFY_EXPR, void_type_node, NULL_TREE, with);\n+\n   if (name)\n     new_name = duplicate_ssa_name (name, copy);\n   else\n     {\n-      new_var = create_tmp_var (TREE_TYPE (with), \"ruatmp\");\n-      add_referenced_tmp_var (new_var);\n-      var_ann (new_var)->type_mem_tag = var;\n-      new_name = make_ssa_name (new_var, copy);\n+      tree tag = var_ann (var)->type_mem_tag;\n+      tree new_ptr = create_tmp_var (TREE_TYPE (with), \"ruatmp\");\n+      add_referenced_tmp_var (new_ptr);\n+      if (tag)\n+\tvar_ann (new_ptr)->type_mem_tag = tag;\n+      else\n+\tadd_type_alias (new_ptr, var);\n+      new_name = make_ssa_name (new_ptr, copy);\n     }\n+\n   TREE_OPERAND (copy, 0) = new_name;\n   update_stmt (copy);\n   bsi_insert_before (bsi, copy, BSI_SAME_STMT);\n@@ -4870,6 +4873,10 @@ rewrite_address_base (block_stmt_iterator *bsi, tree *op, tree with)\n \n   /* Record the original reference, for purposes of alias analysis.  */\n   REF_ORIGINAL (*op) = orig;\n+\n+  /* Virtual operands in the original statement may have to be renamed\n+     because of the replacement.  */\n+  mark_new_vars_to_rename (bsi_stmt (*bsi));\n }\n \n /* Rewrites USE (address that is an iv) using candidate CAND.  */\n@@ -5377,11 +5384,6 @@ tree_ssa_iv_optimize (struct loops *loops)\n   while (loop->inner)\n     loop = loop->inner;\n \n-#ifdef ENABLE_CHECKING\n-  verify_loop_closed_ssa ();\n-  verify_stmts ();\n-#endif\n-\n   /* Scan the loops, inner ones first.  */\n   while (loop != loops->tree_root)\n     {\n@@ -5400,10 +5402,27 @@ tree_ssa_iv_optimize (struct loops *loops)\n \tloop = loop->outer;\n     }\n \n-#ifdef ENABLE_CHECKING\n-  verify_loop_closed_ssa ();\n-  verify_stmts ();\n-#endif\n+  /* FIXME.  IV opts introduces new aliases and call-clobbered\n+     variables, which need to be renamed.  However, when we call the\n+     renamer, not all statements will be scanned for operands.  In\n+     particular, the newly introduced aliases may appear in statements\n+     that are considered \"unmodified\", so the renamer will not get a\n+     chance to rename those operands.\n+\n+     Work around this problem by forcing an operand re-scan on every\n+     statement.  This will not be necessary once the new operand\n+     scanner is implemented.  */\n+  if (need_ssa_update_p ())\n+    {\n+      basic_block bb;\n+      block_stmt_iterator si;\n+      FOR_EACH_BB (bb)\n+\tfor (si = bsi_start (bb); !bsi_end_p (si); bsi_next (&si))\n+\t  update_stmt (bsi_stmt (si));\n+\n+      update_ssa (TODO_update_ssa);\n+    }\n \n+  rewrite_into_loop_closed_ssa (NULL);\n   tree_ssa_iv_optimize_finalize (loops, &data);\n }"}, {"sha": "fbb45ad3b01ad50fcf1fd27ecd8eadbab0e17577", "filename": "gcc/tree-ssa-loop-manip.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftree-ssa-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftree-ssa-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-manip.c?ref=0bca51f080dfff5e943b1f1775d874a73bbc441a", "patch": "@@ -157,7 +157,10 @@ add_exit_phis_var (tree var, bitmap livein, bitmap exits)\n   basic_block def_bb = bb_for_stmt (SSA_NAME_DEF_STMT (var));\n   bitmap_iterator bi;\n \n-  bitmap_clear_bit (livein, def_bb->index);\n+  if (is_gimple_reg (var))\n+    bitmap_clear_bit (livein, def_bb->index);\n+  else\n+    bitmap_set_bit (livein, def_bb->index);\n \n   def = BITMAP_ALLOC (NULL);\n   bitmap_set_bit (def, def_bb->index);"}, {"sha": "03c3249fe2e56dbe0da9005041d334939003b236", "filename": "gcc/tree-ssa-loop.c", "status": "modified", "additions": 9, "deletions": 24, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftree-ssa-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftree-ssa-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop.c?ref=0bca51f080dfff5e943b1f1775d874a73bbc441a", "patch": "@@ -53,17 +53,8 @@ tree_loop_optimizer_init (FILE *dump)\n   if (!loops)\n     return NULL;\n \n-  /* Creation of preheaders may create redundant phi nodes if the loop is\n-     entered by more than one edge, but the initial value of the induction\n-     variable is the same on all of them.  */\n-  kill_redundant_phi_nodes ();\n-  rewrite_into_ssa (false);\n-  bitmap_clear (vars_to_rename);\n-\n+  update_ssa (TODO_update_ssa);\n   rewrite_into_loop_closed_ssa (NULL);\n-#ifdef ENABLE_CHECKING\n-  verify_loop_closed_ssa ();\n-#endif\n \n   return loops;\n }\n@@ -121,7 +112,7 @@ struct tree_opt_pass pass_loop_init =\n   0,\t\t\t\t\t/* properties_provided */\n   0,\t\t\t\t\t/* properties_destroyed */\n   0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_dump_func,\t\t\t/* todo_flags_finish */\n+  TODO_dump_func | TODO_verify_loops,\t/* todo_flags_finish */\n   0\t\t\t\t\t/* letter */\n };\n \n@@ -155,7 +146,7 @@ struct tree_opt_pass pass_lim =\n   0,\t\t\t\t\t/* properties_provided */\n   0,\t\t\t\t\t/* properties_destroyed */\n   0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_dump_func,                \t/* todo_flags_finish */\n+  TODO_dump_func | TODO_verify_loops,\t/* todo_flags_finish */\n   0\t\t\t\t\t/* letter */\n };\n \n@@ -189,7 +180,7 @@ struct tree_opt_pass pass_unswitch =\n   0,\t\t\t\t\t/* properties_provided */\n   0,\t\t\t\t\t/* properties_destroyed */\n   0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_dump_func,                \t/* todo_flags_finish */\n+  TODO_dump_func | TODO_verify_loops,\t/* todo_flags_finish */\n   0\t\t\t\t\t/* letter */\n };\n \n@@ -201,7 +192,6 @@ tree_vectorize (void)\n   if (!current_loops)\n     return;\n \n-  bitmap_clear (vars_to_rename);\n   vectorize_loops (current_loops);\n }\n \n@@ -224,7 +214,7 @@ struct tree_opt_pass pass_vectorize =\n   0,                                    /* properties_provided */\n   0,                                    /* properties_destroyed */\n   0,                                    /* todo_flags_start */\n-  TODO_dump_func,\t\t\t/* todo_flags_finish */\n+  TODO_dump_func | TODO_update_ssa,\t/* todo_flags_finish */\n   0\t\t\t\t\t/* letter */\n };\n \n@@ -259,7 +249,7 @@ struct tree_opt_pass pass_linear_transform =\n   0,\t\t\t\t\t/* properties_provided */\n   0,\t\t\t\t\t/* properties_destroyed */\n   0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_dump_func,                \t/* todo_flags_finish */\n+  TODO_dump_func | TODO_verify_loops,\t/* todo_flags_finish */\n   0\t\t\t\t        /* letter */\t\n };\n \n@@ -293,7 +283,7 @@ struct tree_opt_pass pass_iv_canon =\n   0,\t\t\t\t\t/* properties_provided */\n   0,\t\t\t\t\t/* properties_destroyed */\n   0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_dump_func,                \t/* todo_flags_finish */\n+  TODO_dump_func | TODO_verify_loops,\t/* todo_flags_finish */\n   0\t\t\t\t\t/* letter */\n };\n \n@@ -356,7 +346,7 @@ struct tree_opt_pass pass_complete_unroll =\n   0,\t\t\t\t\t/* properties_provided */\n   0,\t\t\t\t\t/* properties_destroyed */\n   0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_dump_func,                \t/* todo_flags_finish */\n+  TODO_dump_func | TODO_verify_loops,\t/* todo_flags_finish */\n   0\t\t\t\t\t/* letter */\n };\n \n@@ -390,7 +380,7 @@ struct tree_opt_pass pass_iv_optimize =\n   0,\t\t\t\t\t/* properties_provided */\n   0,\t\t\t\t\t/* properties_destroyed */\n   0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_dump_func,                \t/* todo_flags_finish */\n+  TODO_dump_func | TODO_verify_loops,\t/* todo_flags_finish */\n   0\t\t\t\t\t/* letter */\n };\n \n@@ -402,10 +392,6 @@ tree_ssa_loop_done (void)\n   if (!current_loops)\n     return;\n \n-#ifdef ENABLE_CHECKING\n-  verify_loop_closed_ssa ();\n-#endif\n-\n   free_numbers_of_iterations_estimates (current_loops);\n   scev_finalize ();\n   loop_optimizer_finalize (current_loops,\n@@ -429,4 +415,3 @@ struct tree_opt_pass pass_loop_done =\n   TODO_cleanup_cfg | TODO_dump_func,\t/* todo_flags_finish */\n   0\t\t\t\t\t/* letter */\n };\n-"}, {"sha": "62bb8c9192a5140548a8d4d665d811dc50aa6bf5", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 42, "deletions": 6, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=0bca51f080dfff5e943b1f1775d874a73bbc441a", "patch": "@@ -1452,6 +1452,7 @@ get_expr_operands (tree stmt, tree *expr_p, int flags)\n     case TRUTH_XOR_EXPR:\n     case COMPOUND_EXPR:\n     case OBJ_TYPE_REF:\n+    case ASSERT_EXPR:\n     do_binary:\n       {\n \ttree op0 = TREE_OPERAND (expr, 0);\n@@ -1735,7 +1736,7 @@ get_call_expr_operands (tree stmt, tree expr)\n       && !bitmap_empty_p (call_clobbered_vars)\n       && !(call_flags & ECF_NOVOPS))\n     {\n-      /* A 'pure' or a 'const' functions never call clobber anything. \n+      /* A 'pure' or a 'const' function never call-clobbers anything. \n \t A 'noreturn' function might, but since we don't return anyway \n \t there is no point in recording that.  */ \n       if (TREE_SIDE_EFFECTS (expr)\n@@ -1798,6 +1799,24 @@ add_stmt_operand (tree *var_p, stmt_ann_t s_ann, int flags)\n   if (TREE_THIS_VOLATILE (sym) && s_ann)\n     s_ann->has_volatile_ops = true;\n \n+  /* If the variable cannot be modified and this is a V_MAY_DEF change\n+     it into a VUSE.  This happens when read-only variables are marked\n+     call-clobbered and/or aliased to writeable variables.  So we only\n+     check that this only happens on stores, and not writes to GIMPLE\n+     registers.\n+     \n+     FIXME: The C++ FE is emitting assignments in the IL stream for\n+     read-only globals.  This is wrong, but for the time being disable\n+     this transformation on V_MUST_DEF operands (otherwise, we\n+     mis-optimize SPEC2000's eon).  */\n+  if ((flags & opf_is_def)\n+      && !(flags & opf_kill_def)\n+      && unmodifiable_var_p (var))\n+    {\n+      gcc_assert (!is_real_op);\n+      flags &= ~opf_is_def;\n+    }\n+\n   if (is_real_op)\n     {\n       /* The variable is a GIMPLE register.  Add it to real operands.  */\n@@ -1858,17 +1877,35 @@ add_stmt_operand (tree *var_p, stmt_ann_t s_ann, int flags)\n \n \t  if (flags & opf_is_def)\n \t    {\n+\t      bool added_may_defs_p = false;\n+\n \t      /* If the variable is also an alias tag, add a virtual\n \t\t operand for it, otherwise we will miss representing\n \t\t references to the members of the variable's alias set.\n \t\t This fixes the bug in gcc.c-torture/execute/20020503-1.c.  */\n \t      if (v_ann->is_alias_tag)\n-\t\tappend_v_may_def (var);\n+\t\t{\n+\t\t  added_may_defs_p = true;\n+\t\t  append_v_may_def (var);\n+\t\t}\n \n \t      for (i = 0; i < VARRAY_ACTIVE_SIZE (aliases); i++)\n-\t\tappend_v_may_def (VARRAY_TREE (aliases, i));\n+\t\t{\n+\t\t  /* While VAR may be modifiable, some of its aliases\n+\t\t     may not be.  If that's the case, we don't really\n+\t\t     need to add them a V_MAY_DEF for them.  */\n+\t\t  tree alias = VARRAY_TREE (aliases, i);\n+\n+\t\t  if (unmodifiable_var_p (alias))\n+\t\t    append_vuse (alias);\n+\t\t  else\n+\t\t    {\n+\t\t      append_v_may_def (alias);\n+\t\t      added_may_defs_p = true;\n+\t\t    }\n+\t\t}\n \n-\t      if (s_ann)\n+\t      if (s_ann && added_may_defs_p)\n \t\ts_ann->makes_aliased_stores = 1;\n \t    }\n \t  else\n@@ -2000,8 +2037,7 @@ add_call_clobber_ops (tree stmt)\n   EXECUTE_IF_SET_IN_BITMAP (call_clobbered_vars, 0, i, bi)\n     {\n       tree var = referenced_var (i);\n-      if (TREE_READONLY (var)\n-\t  && (TREE_STATIC (var) || DECL_EXTERNAL (var)))\n+      if (unmodifiable_var_p (var))\n \tadd_stmt_operand (&var, &empty_ann, opf_none);\n       else\n \tadd_stmt_operand (&var, &empty_ann, opf_is_def);"}, {"sha": "e9db4c0ae2fe93e095ec9f3352b5e9408ba2c084", "filename": "gcc/tree-ssa-phiopt.c", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftree-ssa-phiopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftree-ssa-phiopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiopt.c?ref=0bca51f080dfff5e943b1f1775d874a73bbc441a", "patch": "@@ -964,8 +964,12 @@ struct tree_opt_pass pass_phiopt =\n   0,\t\t\t\t\t/* properties_provided */\n   0,\t\t\t\t\t/* properties_destroyed */\n   0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_cleanup_cfg | TODO_dump_func | TODO_ggc_collect\t/* todo_flags_finish */\n-    | TODO_verify_ssa | TODO_rename_vars\n-    | TODO_verify_flow | TODO_verify_stmts,\n+  TODO_cleanup_cfg\n+    | TODO_dump_func\n+    | TODO_ggc_collect\n+    | TODO_verify_ssa\n+    | TODO_update_ssa\n+    | TODO_verify_flow\n+    | TODO_verify_stmts,\t\t/* todo_flags_finish */\n   0\t\t\t\t\t/* letter */\n };"}, {"sha": "a4c764aacef0250cda9a7973da5ca9a5b137363d", "filename": "gcc/tree-ssa-propagate.c", "status": "modified", "additions": 413, "deletions": 2, "changes": 415, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftree-ssa-propagate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftree-ssa-propagate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-propagate.c?ref=0bca51f080dfff5e943b1f1775d874a73bbc441a", "patch": "@@ -1,5 +1,5 @@\n /* Generic SSA value propagation engine.\n-   Copyright (C) 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.\n+   Copyright (C) 2004, 2005 Free Software Foundation, Inc.\n    Contributed by Diego Novillo <dnovillo@redhat.com>\n \n    This file is part of GCC.\n@@ -459,6 +459,7 @@ ssa_prop_init (void)\n   edge e;\n   edge_iterator ei;\n   basic_block bb;\n+  size_t i;\n \n   /* Worklists of SSA edges.  */\n   interesting_ssa_edges = VEC_alloc (tree, 20);\n@@ -475,7 +476,12 @@ ssa_prop_init (void)\n \n   VARRAY_BB_INIT (cfg_blocks, 20, \"cfg_blocks\");\n \n-  /* Initially assume that every edge in the CFG is not executable\n+  /* Initialize the values for every SSA_NAME.  */\n+  for (i = 1; i < num_ssa_names; i++)\n+    if (ssa_name (i))\n+      SSA_NAME_VALUE (ssa_name (i)) = NULL_TREE;\n+\n+  /* Initially assume that every edge in the CFG is not executable.\n      (including the edges coming out of ENTRY_BLOCK_PTR).  */\n   FOR_ALL_BB (bb)\n     {\n@@ -666,4 +672,409 @@ ssa_propagate (ssa_prop_visit_stmt_fn visit_stmt,\n   ssa_prop_fini ();\n }\n \n+\n+/* Return the first V_MAY_DEF or V_MUST_DEF operand for STMT.  */\n+\n+tree\n+first_vdef (tree stmt)\n+{\n+  if (NUM_V_MAY_DEFS (STMT_V_MAY_DEF_OPS (stmt)) > 0)\n+    return V_MAY_DEF_RESULT (STMT_V_MAY_DEF_OPS (stmt), 0);\n+  else if (NUM_V_MUST_DEFS (STMT_V_MUST_DEF_OPS (stmt)) > 0)\n+    return V_MUST_DEF_RESULT (STMT_V_MUST_DEF_OPS (stmt), 0);\n+  else\n+    gcc_unreachable ();\n+}\n+\n+\n+/* Return true if STMT is of the form 'LHS = mem_ref', where 'mem_ref'\n+   is a non-volatile pointer dereference, a structure reference or a\n+   reference to a single _DECL.  Ignore volatile memory references\n+   because they are not interesting for the optimizers.  */\n+\n+bool\n+stmt_makes_single_load (tree stmt)\n+{\n+  tree rhs;\n+\n+  if (TREE_CODE (stmt) != MODIFY_EXPR)\n+    return false;\n+\n+  if (NUM_V_MAY_DEFS (STMT_V_MAY_DEF_OPS (stmt)) == 0\n+      && NUM_VUSES (STMT_VUSE_OPS (stmt)) == 0)\n+    return false;\n+\n+  rhs = TREE_OPERAND (stmt, 1);\n+  STRIP_NOPS (rhs);\n+\n+  return (!TREE_THIS_VOLATILE (rhs)\n+\t  && (DECL_P (rhs)\n+\t      || TREE_CODE_CLASS (TREE_CODE (rhs)) == tcc_reference));\n+}\n+\n+\n+/* Return true if STMT is of the form 'mem_ref = RHS', where 'mem_ref'\n+   is a non-volatile pointer dereference, a structure reference or a\n+   reference to a single _DECL.  Ignore volatile memory references\n+   because they are not interesting for the optimizers.  */\n+\n+bool\n+stmt_makes_single_store (tree stmt)\n+{\n+  tree lhs;\n+\n+  if (TREE_CODE (stmt) != MODIFY_EXPR)\n+    return false;\n+\n+  if (NUM_V_MAY_DEFS (STMT_V_MAY_DEF_OPS (stmt)) == 0\n+      && NUM_V_MUST_DEFS (STMT_V_MUST_DEF_OPS (stmt)) == 0)\n+    return false;\n+\n+  lhs = TREE_OPERAND (stmt, 0);\n+  STRIP_NOPS (lhs);\n+\n+  return (!TREE_THIS_VOLATILE (lhs)\n+          && (DECL_P (lhs)\n+\t      || TREE_CODE_CLASS (TREE_CODE (lhs)) == tcc_reference));\n+}\n+\n+\n+/* If STMT makes a single memory load and all the virtual use operands\n+   have the same value in array VALUES, return it.  Otherwise, return\n+   NULL.  */\n+\n+prop_value_t *\n+get_value_loaded_by (tree stmt, prop_value_t *values)\n+{\n+  ssa_op_iter i;\n+  tree vuse;\n+  prop_value_t *prev_val = NULL;\n+  prop_value_t *val = NULL;\n+\n+  FOR_EACH_SSA_TREE_OPERAND (vuse, stmt, i, SSA_OP_VIRTUAL_USES)\n+    {\n+      val = &values[SSA_NAME_VERSION (vuse)];\n+      if (prev_val && prev_val->value != val->value)\n+\treturn NULL;\n+      prev_val = val;\n+    }\n+\n+  return val;\n+}\n+\n+\n+/* Propagation statistics.  */\n+struct prop_stats_d\n+{\n+  long num_const_prop;\n+  long num_copy_prop;\n+};\n+\n+static struct prop_stats_d prop_stats;\n+\n+/* Replace USE references in statement STMT with the values stored in\n+   PROP_VALUE. Return true if at least one reference was replaced.  If\n+   REPLACED_ADDRESSES_P is given, it will be set to true if an address\n+   constant was replaced.  */\n+\n+bool\n+replace_uses_in (tree stmt, bool *replaced_addresses_p,\n+\t\t prop_value_t *prop_value)\n+{\n+  bool replaced = false;\n+  use_operand_p use;\n+  ssa_op_iter iter;\n+\n+  FOR_EACH_SSA_USE_OPERAND (use, stmt, iter, SSA_OP_USE)\n+    {\n+      tree tuse = USE_FROM_PTR (use);\n+      tree val = prop_value[SSA_NAME_VERSION (tuse)].value;\n+\n+      if (val == tuse || val == NULL_TREE)\n+\tcontinue;\n+\n+      if (TREE_CODE (stmt) == ASM_EXPR\n+\t  && !may_propagate_copy_into_asm (tuse))\n+\tcontinue;\n+\n+      if (!may_propagate_copy (tuse, val))\n+\tcontinue;\n+\n+      if (TREE_CODE (val) != SSA_NAME)\n+\tprop_stats.num_const_prop++;\n+      else\n+\tprop_stats.num_copy_prop++;\n+\n+      propagate_value (use, val);\n+\n+      replaced = true;\n+      if (POINTER_TYPE_P (TREE_TYPE (tuse)) && replaced_addresses_p)\n+\t*replaced_addresses_p = true;\n+    }\n+\n+  return replaced;\n+}\n+\n+\n+/* Replace the VUSE references in statement STMT with the values\n+   stored in PROP_VALUE.  Return true if a reference was replaced.  If\n+   REPLACED_ADDRESSES_P is given, it will be set to true if an address\n+   constant was replaced.\n+\n+   Replacing VUSE operands is slightly more complex than replacing\n+   regular USEs.  We are only interested in two types of replacements\n+   here:\n+   \n+   1- If the value to be replaced is a constant or an SSA name for a\n+      GIMPLE register, then we are making a copy/constant propagation\n+      from a memory store.  For instance,\n+\n+      \t# a_3 = V_MAY_DEF <a_2>\n+\ta.b = x_1;\n+\t...\n+ \t# VUSE <a_3>\n+\ty_4 = a.b;\n+\n+      This replacement is only possible iff STMT is an assignment\n+      whose RHS is identical to the LHS of the statement that created\n+      the VUSE(s) that we are replacing.  Otherwise, we may do the\n+      wrong replacement:\n+\n+      \t# a_3 = V_MAY_DEF <a_2>\n+\t# b_5 = V_MAY_DEF <b_4>\n+\t*p = 10;\n+\t...\n+\t# VUSE <b_5>\n+\tx_8 = b;\n+\n+      Even though 'b_5' acquires the value '10' during propagation,\n+      there is no way for the propagator to tell whether the\n+      replacement is correct in every reached use, because values are\n+      computed at definition sites.  Therefore, when doing final\n+      substitution of propagated values, we have to check each use\n+      site.  Since the RHS of STMT ('b') is different from the LHS of\n+      the originating statement ('*p'), we cannot replace 'b' with\n+      '10'.\n+\n+      Similarly, when merging values from PHI node arguments,\n+      propagators need to take care not to merge the same values\n+      stored in different locations:\n+\n+     \t\tif (...)\n+\t\t  # a_3 = V_MAY_DEF <a_2>\n+\t\t  a.b = 3;\n+\t\telse\n+\t\t  # a_4 = V_MAY_DEF <a_2>\n+\t\t  a.c = 3;\n+\t\t# a_5 = PHI <a_3, a_4>\n+\n+      It would be wrong to propagate '3' into 'a_5' because that\n+      operation merges two stores to different memory locations.\n+\n+\n+   2- If the value to be replaced is an SSA name for a virtual\n+      register, then we simply replace each VUSE operand with its\n+      value from PROP_VALUE.  This is the same replacement done by\n+      replace_uses_in.  */\n+\n+static bool\n+replace_vuses_in (tree stmt, bool *replaced_addresses_p,\n+                  prop_value_t *prop_value)\n+{\n+  bool replaced = false;\n+  ssa_op_iter iter;\n+  use_operand_p vuse;\n+\n+  if (stmt_makes_single_load (stmt))\n+    {\n+      /* If STMT is an assignment whose RHS is a single memory load,\n+\t see if we are trying to propagate a constant or a GIMPLE\n+\t register (case #1 above).  */\n+      prop_value_t *val = get_value_loaded_by (stmt, prop_value);\n+      tree rhs = TREE_OPERAND (stmt, 1);\n+\n+      if (val\n+\t  && val->value\n+\t  && (is_gimple_reg (val->value)\n+\t      || is_gimple_min_invariant (val->value))\n+\t  && simple_cst_equal (rhs, val->mem_ref) == 1)\n+\n+\t{\n+\t  /* If we are replacing a constant address, inform our\n+\t     caller.  */\n+\t  if (TREE_CODE (val->value) != SSA_NAME\n+\t      && POINTER_TYPE_P (TREE_TYPE (TREE_OPERAND (stmt, 1)))\n+\t      && replaced_addresses_p)\n+\t    *replaced_addresses_p = true;\n+\n+\t  /* We can only perform the substitution if the load is done\n+\t     from the same memory location as the original store.\n+\t     Since we already know that there are no intervening\n+\t     stores between DEF_STMT and STMT, we only need to check\n+\t     that the RHS of STMT is the same as the memory reference\n+\t     propagated together with the value.  */\n+\t  TREE_OPERAND (stmt, 1) = val->value;\n+\n+\t  if (TREE_CODE (val->value) != SSA_NAME)\n+\t    prop_stats.num_const_prop++;\n+\t  else\n+\t    prop_stats.num_copy_prop++;\n+\n+\t  /* Since we have replaced the whole RHS of STMT, there\n+\t     is no point in checking the other VUSEs, as they will\n+\t     all have the same value.  */\n+\t  return true;\n+\t}\n+    }\n+\n+  /* Otherwise, the values for every VUSE operand must be other\n+     SSA_NAMEs that can be propagated into STMT.  */\n+  FOR_EACH_SSA_USE_OPERAND (vuse, stmt, iter, SSA_OP_VIRTUAL_USES)\n+    {\n+      tree var = USE_FROM_PTR (vuse);\n+      tree val = prop_value[SSA_NAME_VERSION (var)].value;\n+\n+      if (val == NULL_TREE || var == val)\n+\tcontinue;\n+\n+      /* Constants and copies propagated between real and virtual\n+\t operands are only possible in the cases handled above.  They\n+\t should be ignored in any other context.  */\n+      if (is_gimple_min_invariant (val) || is_gimple_reg (val))\n+\tcontinue;\n+\n+      propagate_value (vuse, val);\n+      prop_stats.num_copy_prop++;\n+      replaced = true;\n+    }\n+\n+  return replaced;\n+}\n+\n+\n+/* Replace propagated values into all the arguments for PHI using the\n+   values from PROP_VALUE.  */\n+\n+static void\n+replace_phi_args_in (tree phi, prop_value_t *prop_value)\n+{\n+  int i;\n+\n+  for (i = 0; i < PHI_NUM_ARGS (phi); i++)\n+    {\n+      tree arg = PHI_ARG_DEF (phi, i);\n+\n+      if (TREE_CODE (arg) == SSA_NAME)\n+\t{\n+\t  tree val = prop_value[SSA_NAME_VERSION (arg)].value;\n+\n+\t  if (val && val != arg && may_propagate_copy (arg, val))\n+\t    {\n+\t      if (TREE_CODE (val) != SSA_NAME)\n+\t\tprop_stats.num_const_prop++;\n+\t      else\n+\t\tprop_stats.num_copy_prop++;\n+\n+\t      propagate_value (PHI_ARG_DEF_PTR (phi, i), val);\n+\n+\t      /* If we propagated a copy and this argument flows\n+\t\t through an abnormal edge, update the replacement\n+\t\t accordingly.  */\n+\t      if (TREE_CODE (val) == SSA_NAME\n+\t\t  && PHI_ARG_EDGE (phi, i)->flags & EDGE_ABNORMAL)\n+\t\tSSA_NAME_OCCURS_IN_ABNORMAL_PHI (val) = 1;\n+\t    }\n+\t}\n+    }\n+}\n+\n+\n+/* Perform final substitution and folding of propagated values.  */\n+\n+void\n+substitute_and_fold (prop_value_t *prop_value)\n+{\n+  basic_block bb;\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file,\n+\t     \"\\nSubstituing values and folding statements\\n\\n\");\n+\n+  memset (&prop_stats, 0, sizeof (prop_stats));\n+\n+  /* Substitute values in every statement of every basic block.  */\n+  FOR_EACH_BB (bb)\n+    {\n+      block_stmt_iterator i;\n+      tree phi;\n+\n+      /* Propagate our known values into PHI nodes.  */\n+      for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n+\t{\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    {\n+\t      fprintf (dump_file, \"Replaced \");\n+\t      print_generic_stmt (dump_file, phi, TDF_SLIM);\n+\t    }\n+\n+\t  replace_phi_args_in (phi, prop_value);\n+\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    {\n+\t      fprintf (dump_file, \" with \");\n+\t      print_generic_stmt (dump_file, phi, TDF_SLIM);\n+\t      fprintf (dump_file, \"\\n\");\n+\t    }\n+\t}\n+\n+      for (i = bsi_start (bb); !bsi_end_p (i); bsi_next (&i))\n+\t{\n+          bool replaced_address, did_replace;\n+\t  tree stmt = bsi_stmt (i);\n+\n+\t  get_stmt_operands (stmt);\n+\n+\t  /* Replace the statement with its folded version and mark it\n+\t     folded.  */\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    {\n+\t      fprintf (dump_file, \"Replaced \");\n+\t      print_generic_stmt (dump_file, stmt, TDF_SLIM);\n+\t    }\n+\n+\t  replaced_address = false;\n+\t  did_replace = replace_uses_in (stmt, &replaced_address, prop_value);\n+\t  did_replace |= replace_vuses_in (stmt, &replaced_address, prop_value);\n+\t  if (did_replace)\n+\t    {\n+\t      fold_stmt (bsi_stmt_ptr (i));\n+\t      stmt = bsi_stmt(i);\n+\n+\t      /* If we folded a builtin function, we'll likely\n+\t\t need to rename VDEFs.  */\n+\t      mark_new_vars_to_rename (stmt);\n+\n+              /* If we cleaned up EH information from the statement,\n+                 remove EH edges.  */\n+\t      if (maybe_clean_eh_stmt (stmt))\n+\t\ttree_purge_dead_eh_edges (bb);\n+\t    }\n+\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    {\n+\t      fprintf (dump_file, \" with \");\n+\t      print_generic_stmt (dump_file, stmt, TDF_SLIM);\n+\t      fprintf (dump_file, \"\\n\");\n+\t    }\n+\t}\n+    }\n+\n+  if (dump_file && (dump_flags & TDF_STATS))\n+    {\n+      fprintf (dump_file, \"Constants propagated: %6ld\\n\",\n+\t       prop_stats.num_const_prop);\n+      fprintf (dump_file, \"Copies propagated:    %6ld\\n\",\n+\t       prop_stats.num_copy_prop);\n+    }\n+}\n #include \"gt-tree-ssa-propagate.h\""}, {"sha": "f0124f45204a9b7f5955656d0564c3319111a00d", "filename": "gcc/tree-ssa-propagate.h", "status": "modified", "additions": 32, "deletions": 2, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftree-ssa-propagate.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftree-ssa-propagate.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-propagate.h?ref=0bca51f080dfff5e943b1f1775d874a73bbc441a", "patch": "@@ -1,6 +1,6 @@\n /* Data structures and function declarations for the SSA value propagation\n    engine.\n-   Copyright (C) 2001, 2003, 2004 Free Software Foundation, Inc.\n+   Copyright (C) 2004, 2005 Free Software Foundation, Inc.\n    Contributed by Diego Novillo <dnovillo@redhat.com>\n \n This file is part of GCC.\n@@ -30,7 +30,6 @@ Boston, MA 02111-1307, USA.  */\n /* Lattice values used for propagation purposes.  Specific instances\n    of a propagation engine must return these values from the statement\n    and PHI visit functions to direct the engine.  */\n-\n enum ssa_prop_result {\n     /* The statement produces nothing of interest.  No edges will be\n        added to the work lists.  */\n@@ -51,12 +50,43 @@ enum ssa_prop_result {\n };\n \n \n+struct prop_value_d {\n+    /* Lattice value.  Each propagator is free to define its own\n+       lattice and this field is only meaningful while propagating.\n+       It will not be used by substitute_and_fold.  */\n+    unsigned lattice_val;\n+\n+    /* Propagated value.  */\n+    tree value;\n+\n+    /* If this value is held in an SSA name for a non-register\n+       variable, this field holds the actual memory reference\n+       associated with this value.  This field is taken from \n+       the LHS of the assignment that generated the associated SSA\n+       name.  However, in the case of PHI nodes, this field is copied\n+       from the PHI arguments (assuming that all the arguments have\n+       the same memory reference).  See replace_vuses_in for a more\n+       detailed description.  */\n+    tree mem_ref;\n+};\n+\n+typedef struct prop_value_d prop_value_t;\n+\n+\n /* Call-back functions used by the value propagation engine.  */\n typedef enum ssa_prop_result (*ssa_prop_visit_stmt_fn) (tree, edge *, tree *);\n typedef enum ssa_prop_result (*ssa_prop_visit_phi_fn) (tree);\n \n+\n+/* In tree-ssa-propagate.c  */\n void ssa_propagate (ssa_prop_visit_stmt_fn, ssa_prop_visit_phi_fn);\n tree get_rhs (tree);\n bool set_rhs (tree *, tree);\n+tree first_vdef (tree);\n+bool stmt_makes_single_load (tree);\n+bool stmt_makes_single_store (tree);\n+prop_value_t *get_value_loaded_by (tree, prop_value_t *);\n+bool replace_uses_in (tree, bool *, prop_value_t *);\n+void substitute_and_fold (prop_value_t *);\n \n #endif /* _TREE_SSA_PROPAGATE_H  */"}, {"sha": "a315d0d47735f57196091c3d198fe6a43ac028f7", "filename": "gcc/tree-ssa-sink.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftree-ssa-sink.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftree-ssa-sink.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sink.c?ref=0bca51f080dfff5e943b1f1775d874a73bbc441a", "patch": "@@ -584,6 +584,9 @@ struct tree_opt_pass pass_sink_code =\n   0,\t\t\t\t\t/* properties_provided */\n   0,\t\t\t\t\t/* properties_destroyed */\n   0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_rename_vars | TODO_dump_func | TODO_ggc_collect | TODO_verify_ssa, /* todo_flags_finish */\n+  TODO_update_ssa \n+    | TODO_dump_func\n+    | TODO_ggc_collect\n+    | TODO_verify_ssa,\t\t\t/* todo_flags_finish */\n   0\t\t\t\t\t/* letter */\n };"}, {"sha": "93b5480576389d11f468661f572b0cc5e1d231d9", "filename": "gcc/tree-ssa.c", "status": "modified", "additions": 1, "deletions": 314, "changes": 315, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftree-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftree-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.c?ref=0bca51f080dfff5e943b1f1775d874a73bbc441a", "patch": "@@ -285,7 +285,7 @@ verify_use (basic_block bb, basic_block def_bb, use_operand_p use_p,\n     {\n       fprintf (stderr, \"for SSA_NAME: \");\n       print_generic_expr (stderr, ssa_name, TDF_VOPS);\n-      fprintf (stderr, \"in statement:\\n\");\n+      fprintf (stderr, \" in statement:\\n\");\n       print_generic_stmt (stderr, stmt, TDF_VOPS);\n     }\n \n@@ -1028,319 +1028,6 @@ walk_use_def_chains (tree var, walk_use_def_chains_fn fn, void *data,\n     }\n }\n \n-\n-/* Replaces VAR with REPL in memory reference expression *X in\n-   statement STMT at use location USE_P.  Return TRUE if Anything was done.  */\n-\n-static bool\n-propagate_into_addr (tree stmt, use_operand_p use_p, tree *x, tree repl)\n-{\n-  tree new_var, ass_stmt, addr_var;\n-  basic_block bb;\n-  block_stmt_iterator bsi;\n-\n-  /* There is nothing special to handle in the other cases.  */\n-  if (TREE_CODE (repl) != ADDR_EXPR)\n-    return false;\n-  addr_var = TREE_OPERAND (repl, 0);\n-\n-  while (handled_component_p (*x)\n-\t || TREE_CODE (*x) == REALPART_EXPR\n-\t || TREE_CODE (*x) == IMAGPART_EXPR)\n-    x = &TREE_OPERAND (*x, 0);\n-\n-  /* Heres a hack but since KRPhinodes is going away soon, Im not going to \n-     sweat it.  */\n-  if (TREE_CODE (*x) != INDIRECT_REF\n-      || &(TREE_OPERAND (*x, 0)) != use_p->use)  /* HACK ALERT. */\n-    return false;\n-\n-  if (TREE_TYPE (*x) == TREE_TYPE (addr_var))\n-    {\n-      *x = addr_var;\n-      mark_new_vars_to_rename (stmt, vars_to_rename);\n-      return true;\n-    }\n-\n-\n-  /* Frontends sometimes produce expressions like *&a instead of a[0].\n-     Create a temporary variable to handle this case.  */\n-  ass_stmt = build2 (MODIFY_EXPR, void_type_node, NULL_TREE, repl);\n-  new_var = duplicate_ssa_name (USE_FROM_PTR (use_p), ass_stmt);\n-  TREE_OPERAND (*x, 0) = new_var;\n-  TREE_OPERAND (ass_stmt, 0) = new_var;\n-\n-  bb = bb_for_stmt (stmt);\n-  tree_block_label (bb);\n-  bsi = bsi_after_labels (bb);\n-  bsi_insert_after (&bsi, ass_stmt, BSI_NEW_STMT);\n-\n-  mark_new_vars_to_rename (stmt, vars_to_rename);\n-  return true;\n-}\n-\n-/* Replaces immediate uses of VAR by REPL.  */\n-\n-static void\n-replace_immediate_uses (tree var, tree repl)\n-{\n-  tree stmt;\n-  bool mark_new_vars;\n-  use_operand_p imm_use;\n-  imm_use_iterator imm_iter;\n-\n-  FOR_EACH_IMM_USE_SAFE (imm_use, imm_iter, var)\n-    {\n-      stmt = USE_STMT (imm_use);\n-\n-      if (TREE_CODE (stmt) == PHI_NODE)\n-\t{\n-\t  int index = PHI_ARG_INDEX_FROM_USE (imm_use);\n-#ifdef ENABLE_CHECKING\n-\t  gcc_assert (&(PHI_ARG_IMM_USE_NODE (stmt, index)) == imm_use);\n-#endif\n-\t    SET_USE (imm_use, repl);\n-\t  if (TREE_CODE (repl) == SSA_NAME\n-\t      && PHI_ARG_EDGE (stmt, index)->flags & EDGE_ABNORMAL)\n-\t    SSA_NAME_OCCURS_IN_ABNORMAL_PHI (repl) = 1;\n-\t  continue;\n-\t}\n-\n-      gcc_assert (!stmt_modified_p (stmt));\n-\n-      mark_new_vars = false;\n-      if (is_gimple_reg (SSA_NAME_VAR (var)))\n-\t{\n-\t  bool propagated = false;\n-\t  if (TREE_CODE (stmt) == MODIFY_EXPR)\n-\t    {\n-\t      if (TREE_CODE (repl) == ADDR_EXPR)\n-\t\t{\n-\t\t  propagated =\n-\t\t    propagate_into_addr (stmt, imm_use, &TREE_OPERAND (stmt, 0),\n-\t\t\t\t\t repl);\n-\t\t  if (!propagated)\n-\t\t    propagated =\n-\t\t      propagate_into_addr (stmt, imm_use,\n-\t\t\t\t\t   &TREE_OPERAND (stmt, 1), repl);\n-\t\t}\n-\t    }\n-\t  if (!propagated)\n-\t    propagate_value (imm_use, repl);\n-\t  mark_new_vars = POINTER_TYPE_P (TREE_TYPE (repl));\n-\t}\n-      else\n-        propagate_value (imm_use, repl);\n-\n-      /* FIXME.  If REPL is a constant, we need to fold STMT.\n-\t However, fold_stmt wants a pointer to the statement, because\n-\t it may happen that it needs to replace the whole statement\n-\t with a new expression.  Since the current def-use machinery\n-\t does not return pointers to statements, we call fold_stmt\n-\t with the address of a local temporary, if that call changes\n-\t the temporary then we fallback on looking for a proper\n-\t pointer to STMT by scanning STMT's basic block.\n-\n-\t Note that all this will become unnecessary soon.  This\n-\t pass is being replaced with a proper copy propagation pass\n-\t for 4.1 (dnovillo, 2004-09-17).  */\n-      if (TREE_CODE (repl) != SSA_NAME)\n-\t{\n-\t  tree tmp = stmt;\n-\t  fold_stmt (&tmp);\n-          mark_new_vars = true;\n-\t  if (tmp != stmt)\n-\t    {\n-\t      block_stmt_iterator si = bsi_for_stmt (stmt);\n-\t      mark_new_vars_to_rename (tmp, vars_to_rename);\n-\t      bsi_replace (&si, tmp, true);\n-\t      stmt = bsi_stmt (si);\n-\t    }\n-\t}\n-\n-      /* If REPL is a pointer, it may have different memory tags associated\n-\t with it.  For instance, VAR may have had a name tag while REPL\n-\t only had a type tag.  In these cases, the virtual operands (if\n-\t any) in the statement will refer to different symbols which need\n-\t to be renamed.  */\n-      if (mark_new_vars)\n-\tmark_new_vars_to_rename (stmt, vars_to_rename);\n-      else\n-\tupdate_stmt (stmt);\n-    }\n-\n-}\n-\n-/* Gets the value VAR is equivalent to according to EQ_TO.  */\n-\n-static tree\n-get_eq_name (tree *eq_to, tree var)\n-{\n-  unsigned ver;\n-  tree val = var;\n-\n-  while (TREE_CODE (val) == SSA_NAME)\n-    {\n-      ver = SSA_NAME_VERSION (val);\n-      if (!eq_to[ver])\n-\tbreak;\n-\n-      val = eq_to[ver];\n-    }\n-\n-  while (TREE_CODE (var) == SSA_NAME)\n-    {\n-      ver = SSA_NAME_VERSION (var);\n-      if (!eq_to[ver])\n-\tbreak;\n-\n-      var = eq_to[ver];\n-      eq_to[ver] = val;\n-    }\n-\n-  return val;\n-}\n-\n-/* Checks whether phi node PHI is redundant and if it is, records the ssa name\n-   its result is redundant to to EQ_TO array.  */\n-\n-static void\n-check_phi_redundancy (tree phi, tree *eq_to)\n-{\n-  tree val = NULL_TREE, def, res = PHI_RESULT (phi), stmt;\n-  unsigned i, ver = SSA_NAME_VERSION (res);\n-  imm_use_iterator imm_iter;\n-  use_operand_p use_p;\n-\n-  /* It is unlikely that such large phi node would be redundant.  */\n-  if (PHI_NUM_ARGS (phi) > 16)\n-    return;\n-\n-  for (i = 0; i < (unsigned) PHI_NUM_ARGS (phi); i++)\n-    {\n-      def = PHI_ARG_DEF (phi, i);\n-\n-      if (TREE_CODE (def) == SSA_NAME)\n-\t{\n-\t  def = get_eq_name (eq_to, def);\n-\t  if (def == res)\n-\t    continue;\n-\t}\n-\n-      if (val\n-\t  && !operand_equal_for_phi_arg_p (val, def))\n-\treturn;\n-\n-      val = def;\n-    }\n-\n-  /* At least one of the arguments should not be equal to the result, or\n-     something strange is happening.  */\n-  gcc_assert (val);\n-\n-  if (get_eq_name (eq_to, res) == val)\n-    return;\n-\n-  if (!may_propagate_copy (res, val))\n-    return;\n-\n-  eq_to[ver] = val;\n-\n-  FOR_EACH_IMM_USE_FAST (use_p, imm_iter, res)\n-    {\n-      stmt = USE_STMT (use_p);\n-      if (TREE_CODE (stmt) == PHI_NODE)\n-\tcheck_phi_redundancy (stmt, eq_to);\n-    }\n-}\n-\n-/* Removes redundant phi nodes.\n-\n-   A redundant PHI node is a PHI node where all of its PHI arguments\n-   are the same value, excluding any PHI arguments which are the same\n-   as the PHI result.\n-\n-   A redundant PHI node is effectively a copy, so we forward copy propagate\n-   which removes all uses of the destination of the PHI node then\n-   finally we delete the redundant PHI node.\n-\n-   Note that if we can not copy propagate the PHI node, then the PHI\n-   will not be removed.  Thus we do not have to worry about dependencies\n-   between PHIs and the problems serializing PHIs into copies creates. \n-   \n-   The most important effect of this pass is to remove degenerate PHI\n-   nodes created by removing unreachable code.  */\n-\n-void\n-kill_redundant_phi_nodes (void)\n-{\n-  tree *eq_to;\n-  unsigned i, old_num_ssa_names;\n-  basic_block bb;\n-  tree phi, repl, stmt;\n-\n-  /* The EQ_TO[VER] holds the value by that the ssa name VER should be\n-     replaced.  If EQ_TO[VER] is ssa name and it is decided to replace it by\n-     other value, it may be necessary to follow the chain till the final value.\n-     We perform path shortening (replacing the entries of the EQ_TO array with\n-     heads of these chains) whenever we access the field to prevent quadratic\n-     complexity (probably would not occur in practice anyway, but let us play\n-     it safe).  */\n-  eq_to = xcalloc (num_ssa_names, sizeof (tree));\n-\n-  old_num_ssa_names = num_ssa_names;\n-\n-  FOR_EACH_BB (bb)\n-    {\n-      for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n-\tcheck_phi_redundancy (phi, eq_to);\n-    }\n-\n-  /* Now propagate the values.  */\n-  for (i = 0; i < old_num_ssa_names; i++)\n-    {\n-      if (!ssa_name (i))\n-\tcontinue;\n-\n-      repl = get_eq_name (eq_to, ssa_name (i));\n-      if (repl != ssa_name (i))\n-\treplace_immediate_uses (ssa_name (i), repl);\n-    }\n-\n-  /* And remove the dead phis.  */\n-  for (i = 0; i < old_num_ssa_names; i++)\n-    {\n-      if (!ssa_name (i))\n-\tcontinue;\n-\n-      repl = get_eq_name (eq_to, ssa_name (i));\n-      if (repl != ssa_name (i))\n-\t{\n-\t  stmt = SSA_NAME_DEF_STMT (ssa_name (i));\n-\t  remove_phi_node (stmt, NULL_TREE);\n-\t}\n-    }\n-\n-  free (eq_to);\n-}\n-\n-struct tree_opt_pass pass_redundant_phi =\n-{\n-  \"redphi\",\t\t\t\t/* name */\n-  NULL,\t\t\t\t\t/* gate */\n-  kill_redundant_phi_nodes,\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_TREE_REDPHI,\t\t\t/* tv_id */\n-  PROP_cfg | PROP_ssa | PROP_alias,\t/* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_dump_func | TODO_rename_vars \n-    | TODO_ggc_collect | TODO_verify_ssa, /* todo_flags_finish */\n-  0\t\t\t\t\t/* letter */\n-};\n \f\n /* Emit warnings for uninitialized variables.  This is done in two passes.\n "}, {"sha": "0d14c13143bc402b03e26913f843ad608a781cf5", "filename": "gcc/tree-vect-transform.c", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftree-vect-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftree-vect-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-transform.c?ref=0bca51f080dfff5e943b1f1775d874a73bbc441a", "patch": "@@ -349,9 +349,18 @@ vect_create_data_ref_ptr (tree stmt, block_stmt_iterator *bsi, tree offset,\n   \n   tag = STMT_VINFO_MEMTAG (stmt_info);\n   gcc_assert (tag);\n-  get_var_ann (vect_ptr)->type_mem_tag = tag;\n-  get_var_ann (vect_ptr)->subvars = STMT_VINFO_SUBVARS (stmt_info);\n \n+  /* If the memory tag of the original reference was not a type tag or\n+     if the pointed-to type of VECT_PTR has an alias set number\n+     different than TAG's, then we need to create a new type tag for\n+     VECT_PTR and add TAG to its alias set.  */\n+  if (var_ann (tag)->mem_tag_kind == NOT_A_TAG\n+      || get_alias_set (tag) != get_alias_set (TREE_TYPE (vect_ptr_type)))\n+    add_type_alias (vect_ptr, tag);\n+  else\n+    var_ann (vect_ptr)->type_mem_tag = tag;\n+  \n+  var_ann (vect_ptr)->subvars = STMT_VINFO_SUBVARS (stmt_info);\n \n   /** (3) Calculate the initial address the vector-pointer, and set\n           the vector-pointer to point to it before the loop:  **/"}, {"sha": "63dd2d201d2e5ba030e61d40d160a6fd3761a32d", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=0bca51f080dfff5e943b1f1775d874a73bbc441a", "patch": "@@ -1836,10 +1836,6 @@ vectorize_loops (struct loops *loops)\n       return;\n     }\n \n-#ifdef ENABLE_CHECKING\n-  verify_loop_closed_ssa ();\n-#endif\n-\n   /*  ----------- Analyze loops. -----------  */\n \n   /* If some loop was duplicated, it gets bigger number "}, {"sha": "a38edd0785f016bad38c319c7499e55be6226b4a", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=0bca51f080dfff5e943b1f1775d874a73bbc441a", "patch": "@@ -176,7 +176,11 @@ typedef struct _stmt_vec_info {\n   /* Information about the data-ref (access function, etc).  */\n   struct data_reference *data_ref_info;\n \n-  /* Aliasing information.  */\n+  /* Aliasing information.  This field represents the symbol that\n+     should be aliased by a pointer holding the address of this data\n+     reference.  If the original data reference was a pointer\n+     dereference, then this field contains the memory tag that should\n+     be used by the new vector-pointer.  */\n   tree memtag;\n   struct ptr_info_def *ptr_info;\n   subvar_t subvars;"}, {"sha": "e4adcfaf8d1eb5e06d25451de32c29a129a98de4", "filename": "gcc/tree-vrp.c", "status": "added", "additions": 2265, "deletions": 0, "changes": 2265, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=0bca51f080dfff5e943b1f1775d874a73bbc441a", "patch": "@@ -0,0 +1,2265 @@\n+/* Support routines for Value Range Propagation (VRP).\n+   Copyright (C) 2005 Free Software Foundation, Inc.\n+   Contributed by Diego Novillo <dnovillo@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"ggc.h\"\n+#include \"flags.h\"\n+#include \"tree.h\"\n+#include \"basic-block.h\"\n+#include \"tree-flow.h\"\n+#include \"tree-pass.h\"\n+#include \"tree-dump.h\"\n+#include \"timevar.h\"\n+#include \"diagnostic.h\"\n+#include \"cfgloop.h\"\n+#include \"tree-scalar-evolution.h\"\n+#include \"tree-ssa-propagate.h\"\n+#include \"tree-chrec.h\"\n+\n+/* Set of SSA names found during the dominator traversal of a\n+   sub-graph in maybe_add_assert_expr_on_edges.  */\n+static sbitmap found;\n+\n+/* Loop structure of the program.  Used to analyze scalar evolutions\n+   inside adjust_range_with_scev.  */\n+static struct loops *cfg_loops;\n+\n+/* Local functions.  */\n+static int compare_values (tree val1, tree val2);\n+\n+/* Given a conditional predicate COND that has WHICH as one of its\n+   operands, return the other operand.  No error checking is done.\n+   This helper assumes that COND is a comparison and WHICH is one of\n+   its operands.  */\n+\n+static inline tree\n+get_opposite_operand (tree cond, tree which)\n+{\n+  if (TREE_OPERAND (cond, 0) == which)\n+    return TREE_OPERAND (cond, 1);\n+  else\n+    return TREE_OPERAND (cond, 0);\n+}\n+\n+\n+/* Given a comparison code, return its opposite.  Note that this is *not*\n+   the same as inverting its truth value (invert_tree_comparison).  Here we\n+   just want to literally flip the comparison around.\n+   \n+   So, '<' gets '>', '<=' gets '>='.  Both '==' and '!=' are returned\n+   unchanged.  */\n+\n+static enum tree_code\n+opposite_comparison (enum tree_code code)\n+{\n+  switch (code)\n+    {\n+    case EQ_EXPR:\n+    case NE_EXPR:\n+    case ORDERED_EXPR:\n+    case UNORDERED_EXPR:\n+    case LTGT_EXPR:\n+    case UNEQ_EXPR:\n+      return code;\n+    case GT_EXPR:\n+      return LT_EXPR;\n+    case GE_EXPR:\n+      return LE_EXPR;\n+    case LT_EXPR:\n+      return GT_EXPR;\n+    case LE_EXPR:\n+      return GE_EXPR;\n+    case UNGT_EXPR:\n+      return UNLT_EXPR;\n+    case UNGE_EXPR:\n+      return UNLE_EXPR;\n+    case UNLT_EXPR:\n+      return UNGT_EXPR;\n+    case UNLE_EXPR:\n+      return UNGE_EXPR;\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+\n+/* Set value range VR to {T, MIN, MAX}.  */\n+\n+static inline void\n+set_value_range (value_range *vr, enum value_range_type t, tree min, tree max)\n+{\n+#if defined ENABLE_CHECKING\n+  if (t == VR_RANGE || t == VR_ANTI_RANGE)\n+    {\n+      int cmp;\n+\n+      gcc_assert (min && max);\n+\n+      if (INTEGRAL_TYPE_P (TREE_TYPE (min)) && t == VR_ANTI_RANGE)\n+\tgcc_assert (min != TYPE_MIN_VALUE (TREE_TYPE (min))\n+\t\t    || max != TYPE_MAX_VALUE (TREE_TYPE (max)));\n+\n+      cmp = compare_values (min, max);\n+      gcc_assert (cmp == 0 || cmp == -1 || cmp == -2);\n+    }\n+#endif\n+\n+  if (t == VR_RANGE\n+      && INTEGRAL_TYPE_P (TREE_TYPE (min))\n+      && min == TYPE_MIN_VALUE (TREE_TYPE (min))\n+      && max == TYPE_MAX_VALUE (TREE_TYPE (max)))\n+    {\n+      /* Ranges that cover all the possible values for the type decay\n+\t to VARYING.  */\n+      vr->type = VR_VARYING;\n+      vr->min = NULL_TREE;\n+      vr->max = NULL_TREE;\n+      return;\n+    }\n+\n+  vr->type = t;\n+  vr->min = min;\n+  vr->max = max;\n+}\n+\n+\n+/* Similar to set_value_range but return true if any field of VR\n+   changed from its previous value.  */\n+\n+static inline bool\n+update_value_range (value_range *vr, enum value_range_type t, tree min,\n+\t\t    tree max)\n+{\n+  bool is_new = vr->type != t || vr->min != min || vr->max != max;\n+  if (is_new)\n+    set_value_range (vr, t, min, max);\n+\n+  return is_new;\n+}\n+\n+\n+/* Return value range information for VAR.  Create an empty range if\n+   none existed.  */\n+\n+value_range *\n+get_value_range (tree var)\n+{\n+  value_range *vr;\n+  tree sym;\n+\n+  vr = SSA_NAME_VALUE_RANGE (var);\n+  if (vr)\n+    return vr;\n+\n+  /* Create a default value range.  */\n+  vr = ggc_alloc (sizeof (*vr));\n+  memset ((void *) vr, 0, sizeof (*vr));\n+  SSA_NAME_VALUE_RANGE (var) = vr;\n+\n+  /* If VAR is a default definition for a PARM_DECL, then we have to\n+     assume a VARYING range for it.  */\n+  sym = SSA_NAME_VAR (var);\n+  if (TREE_CODE (sym) == PARM_DECL && var == var_ann (sym)->default_def)\n+    set_value_range (vr, VR_VARYING, NULL_TREE, NULL_TREE);\n+\n+  return vr;\n+}\n+\n+\n+/* Return true if value range VR involves at least one symbol.  */\n+\n+static inline bool\n+symbolic_range_p (value_range *vr)\n+{\n+  return (!is_gimple_min_invariant (vr->min)\n+          || !is_gimple_min_invariant (vr->max));\n+}\n+\n+\n+/* Return true if EXPR computes a non-zero value.  */\n+\n+bool\n+expr_computes_nonzero (tree expr)\n+{\n+  /* Type casts won't change anything, so just strip it.  */\n+  STRIP_NOPS (expr);\n+\n+  /* Calling alloca, guarantees that the value is non-NULL.  */\n+  if (alloca_call_p (expr))\n+    return true;\n+\n+  /* The address of a non-weak symbol is never NULL, unless the user\n+     has requested not to remove NULL pointer checks.  */\n+  if (flag_delete_null_pointer_checks\n+      && TREE_CODE (expr) == ADDR_EXPR\n+      && DECL_P (TREE_OPERAND (expr, 0))\n+      && !DECL_WEAK (TREE_OPERAND (expr, 0)))\n+    return true;\n+\n+  /* IOR of any value with a nonzero value will result in a nonzero\n+     value.  */\n+  if (TREE_CODE (expr) == BIT_IOR_EXPR\n+      && integer_nonzerop (TREE_OPERAND (expr, 1)))\n+    return true;\n+\n+  return false;\n+}\n+\n+\n+/* Return true if VR is ~[0, 0].  */\n+\n+static inline bool\n+range_is_nonnull (value_range *vr)\n+{\n+  return vr->type == VR_ANTI_RANGE\n+\t && integer_zerop (vr->min)\n+\t && integer_zerop (vr->max);\n+}\n+\n+\n+/* Return true if VR is [0, 0].  */\n+\n+static inline bool\n+range_is_null (value_range *vr)\n+{\n+  return vr->type == VR_RANGE\n+\t && integer_zerop (vr->min)\n+\t && integer_zerop (vr->max);\n+}\n+\n+\n+/* Set value range VR to a non-NULL range of type TYPE.  */\n+\n+static void\n+set_value_range_to_nonnull (value_range *vr, tree type)\n+{\n+  tree zero = build_int_cst (type, 0);\n+  set_value_range (vr, VR_ANTI_RANGE, zero, zero);\n+}\n+\n+\n+/* Set value range VR to a NULL range of type TYPE.  */\n+\n+static void\n+set_value_range_to_null (value_range *vr, tree type)\n+{\n+  tree zero = build_int_cst (type, 0);\n+  set_value_range (vr, VR_RANGE, zero, zero);\n+}\n+\n+\n+/* Compare two values VAL1 and VAL2.  Return\n+   \n+   \t-2 if VAL1 and VAL2 cannot be compared at compile-time,\n+   \t-1 if VAL1 < VAL2,\n+   \t 0 if VAL1 == VAL2,\n+\t+1 if VAL1 > VAL2, and\n+\t+2 if VAL1 != VAL2\n+\n+   This is similar to tree_int_cst_compare but supports pointer values\n+   and values that cannot be compared at compile time.  */\n+\n+static int\n+compare_values (tree val1, tree val2)\n+{\n+  if (val1 == val2)\n+    return 0;\n+\n+  /* Do some limited symbolic comparisons.  */\n+  if (!POINTER_TYPE_P (TREE_TYPE (val1)))\n+    {\n+      /* We can determine some comparisons against +INF and -INF even\n+\t if the other value is an expression.  */\n+      if (val1 == TYPE_MAX_VALUE (TREE_TYPE (val1))\n+\t  && TREE_CODE (val2) == MINUS_EXPR)\n+\t{\n+\t  /* +INF > NAME - CST.  */\n+\t  return 1;\n+\t}\n+      else if (val1 == TYPE_MIN_VALUE (TREE_TYPE (val1))\n+\t       && TREE_CODE (val2) == PLUS_EXPR)\n+\t{\n+\t  /* -INF < NAME + CST.  */\n+\t  return -1;\n+\t}\n+      else if (TREE_CODE (val1) == MINUS_EXPR\n+\t       && val2 == TYPE_MAX_VALUE (TREE_TYPE (val2)))\n+\t{\n+\t  /* NAME - CST < +INF.  */\n+\t  return -1;\n+\t}\n+      else if (TREE_CODE (val1) == PLUS_EXPR\n+\t       && val2 == TYPE_MIN_VALUE (TREE_TYPE (val2)))\n+\t{\n+\t  /* NAME + CST > -INF.  */\n+\t  return 1;\n+\t}\n+    }\n+\n+  if ((TREE_CODE (val1) == SSA_NAME\n+       || TREE_CODE (val1) == PLUS_EXPR\n+       || TREE_CODE (val1) == MINUS_EXPR)\n+      && (TREE_CODE (val2) == SSA_NAME\n+\t  || TREE_CODE (val2) == PLUS_EXPR\n+\t  || TREE_CODE (val2) == MINUS_EXPR))\n+    {\n+      tree n1, c1, n2, c2;\n+  \n+      /* If VAL1 and VAL2 are of the form 'NAME [+-] CST' or 'NAME',\n+\t return -1 or +1 accordingly.  If VAL1 and VAL2 don't use the\n+\t same name, return -2.  */\n+      if (TREE_CODE (val1) == SSA_NAME)\n+\t{\n+\t  n1 = val1;\n+\t  c1 = NULL_TREE;\n+\t}\n+      else\n+\t{\n+\t  n1 = TREE_OPERAND (val1, 0);\n+\t  c1 = TREE_OPERAND (val1, 1);\n+\t}\n+\n+      if (TREE_CODE (val2) == SSA_NAME)\n+\t{\n+\t  n2 = val2;\n+\t  c2 = NULL_TREE;\n+\t}\n+      else\n+\t{\n+\t  n2 = TREE_OPERAND (val2, 0);\n+\t  c2 = TREE_OPERAND (val2, 1);\n+\t}\n+\n+      /* Both values must use the same name.  */\n+      if (n1 != n2)\n+\treturn -2;\n+\n+      if (TREE_CODE (val1) == SSA_NAME)\n+\t{\n+\t  if (TREE_CODE (val2) == SSA_NAME)\n+\t    /* NAME == NAME  */\n+\t    return 0;\n+\t  else if (TREE_CODE (val2) == PLUS_EXPR)\n+\t    /* NAME < NAME + CST  */\n+\t    return -1;\n+\t  else if (TREE_CODE (val2) == MINUS_EXPR)\n+\t    /* NAME > NAME - CST  */\n+\t    return 1;\n+\t}\n+      else if (TREE_CODE (val1) == PLUS_EXPR)\n+\t{\n+\t  if (TREE_CODE (val2) == SSA_NAME)\n+\t    /* NAME + CST > NAME  */\n+\t    return 1;\n+\t  else if (TREE_CODE (val2) == PLUS_EXPR)\n+\t    /* NAME + CST1 > NAME + CST2, if CST1 > CST2  */\n+\t    return compare_values (c1, c2);\n+\t  else if (TREE_CODE (val2) == MINUS_EXPR)\n+\t    /* NAME + CST1 > NAME - CST2  */\n+\t    return 1;\n+\t}\n+      else if (TREE_CODE (val1) == MINUS_EXPR)\n+\t{\n+\t  if (TREE_CODE (val2) == SSA_NAME)\n+\t    /* NAME - CST < NAME  */\n+\t    return -1;\n+\t  else if (TREE_CODE (val2) == PLUS_EXPR)\n+\t    /* NAME - CST1 < NAME + CST2  */\n+\t    return -1;\n+\t  else if (TREE_CODE (val2) == MINUS_EXPR)\n+\t    /* NAME - CST1 > NAME - CST2, if CST1 < CST2.  Notice that\n+\t       C1 and C2 are swapped in the call to compare_values.  */\n+\t    return compare_values (c2, c1);\n+\t}\n+\n+      gcc_unreachable ();\n+    }\n+\n+  /* We cannot compare non-constants.  */\n+  if (!is_gimple_min_invariant (val1) || !is_gimple_min_invariant (val2))\n+    return -2;\n+\n+  if (!POINTER_TYPE_P (TREE_TYPE (val1)))\n+    return tree_int_cst_compare (val1, val2);\n+  else\n+    {\n+      tree t;\n+\n+      /* First see if VAL1 and VAL2 are not the same.  */\n+      if (val1 == val2 || operand_equal_p (val1, val2, 0))\n+\treturn 0;\n+      \n+      /* If VAL1 is a lower address than VAL2, return -1.  */\n+      t = fold (build2 (LT_EXPR, TREE_TYPE (val1), val1, val2));\n+      if (t == boolean_true_node)\n+\treturn -1;\n+\n+      /* If VAL1 is a higher address than VAL2, return +1.  */\n+      t = fold (build2 (GT_EXPR, TREE_TYPE (val1), val1, val2));\n+      if (t == boolean_true_node)\n+\treturn 1;\n+\n+      /* If VAL1 is different than VAL2, return +2.  */\n+      t = fold (build2 (NE_EXPR, TREE_TYPE (val1), val1, val2));\n+      if (t == boolean_true_node)\n+\treturn 2;\n+\n+      return -2;\n+    }\n+}\n+\n+\n+/* Return 1 if VAL is inside value range VR (VR->MIN <= VAL <= VR->MAX),\n+          0 if VAL is not inside VR,\n+\t -2 if we cannot tell either way.  */\n+\n+static inline int\n+value_inside_range (tree val, value_range *vr)\n+{\n+  int cmp1, cmp2;\n+\n+  cmp1 = compare_values (val, vr->min);\n+  if (cmp1 == -2 || cmp1 == 2)\n+    return -2;\n+\n+  cmp2 = compare_values (val, vr->max);\n+  if (cmp2 == -2 || cmp2 == 2)\n+    return -2;\n+\n+  return (cmp1 == 0 || cmp1 == 1) && (cmp2 == -1 || cmp2 == 0);\n+}\n+\n+\n+/* Return true if value ranges VR0 and VR1 have a non-empty\n+   intersection.  */\n+\n+static inline bool\n+value_ranges_intersect_p (value_range *vr0, value_range *vr1)\n+{\n+  return (value_inside_range (vr1->min, vr0) == 1\n+\t  || value_inside_range (vr1->max, vr0) == 1\n+\t  || value_inside_range (vr0->min, vr1) == 1\n+\t  || value_inside_range (vr0->max, vr1) == 1);\n+}\n+\n+\n+/* Extract value range information from an ASSERT_EXPR EXPR and store\n+   it in *VR_P.  */\n+\n+static void\n+extract_range_from_assert (value_range *vr_p, tree expr)\n+{\n+  tree var, cond, limit, type;\n+  value_range *var_vr;\n+\n+  var = ASSERT_EXPR_VAR (expr);\n+  cond = ASSERT_EXPR_COND (expr);\n+\n+  gcc_assert (TREE_CODE_CLASS (TREE_CODE (cond)) == tcc_comparison);\n+\n+  /* Find VAR in the ASSERT_EXPR conditional.  */\n+  limit = get_opposite_operand (cond, var);\n+  type = TREE_TYPE (limit);\n+\n+  gcc_assert (limit != var);\n+\n+  /* For pointer arithmetic, we only keep track of anti-ranges\n+     (NE_EXPR).  Notice that we don't need to handle EQ_EXPR in these\n+     cases because assertions with equalities are never generated.\n+     The assert pass generates straight assignments in those cases.  */\n+  if (POINTER_TYPE_P (type) && TREE_CODE (cond) != NE_EXPR)\n+    {\n+      set_value_range (vr_p, VR_VARYING, NULL_TREE, NULL_TREE);\n+      return;\n+    }\n+\n+  if (TREE_CODE (cond) == NE_EXPR)\n+    set_value_range (vr_p, VR_ANTI_RANGE, limit, limit);\n+  else if (TREE_CODE (cond) == LE_EXPR)\n+    set_value_range (vr_p, VR_RANGE, TYPE_MIN_VALUE (type), limit);\n+  else if (TREE_CODE (cond) == LT_EXPR)\n+    {\n+      tree one = build_int_cst (type, 1);\n+      set_value_range (vr_p, VR_RANGE, TYPE_MIN_VALUE (type),\n+\t\t       fold (build (MINUS_EXPR, type, limit, one)));\n+    }\n+  else if (TREE_CODE (cond) == GE_EXPR)\n+    set_value_range (vr_p, VR_RANGE, limit, TYPE_MAX_VALUE (type));\n+  else if (TREE_CODE (cond) == GT_EXPR)\n+    {\n+      tree one = build_int_cst (type, 1);\n+      set_value_range (vr_p, VR_RANGE,\n+\t\t       fold (build (PLUS_EXPR, type, limit, one)),\n+\t\t       TYPE_MAX_VALUE (type));\n+    }\n+  else\n+    gcc_unreachable ();\n+\n+  /* If VAR already has a known range and the two ranges have a\n+     non-empty intersection, we can refine the resulting range.\n+     Since the assert expression creates an equivalency and at the\n+     same time it asserts a predicate, we can take the intersection of\n+     the two ranges to get better precision.  */\n+  var_vr = get_value_range (var);\n+  if (var_vr->type == VR_RANGE\n+      && vr_p->type == VR_RANGE\n+      && value_ranges_intersect_p (var_vr, vr_p))\n+    {\n+      tree min, max;\n+\n+      /* Use the larger of the two minimums.  */\n+      if (compare_values (vr_p->min, var_vr->min) == -1)\n+\tmin = var_vr->min;\n+      else\n+\tmin = vr_p->min;\n+\n+      /* Use the smaller of the two maximums.  */\n+      if (compare_values (vr_p->max, var_vr->max) == 1)\n+\tmax = var_vr->max;\n+      else\n+\tmax = vr_p->max;\n+\n+      set_value_range (vr_p, vr_p->type, min, max);\n+    }\n+}\n+\n+\n+/* Extract range information from SSA name VAR and store it in VR.  If\n+   VAR has an interesting range, use it.  Otherwise, create the\n+   range [VAR, VAR] and return it.  This is useful in situations where\n+   we may have conditionals testing values of VARYING names.  For\n+   instance,\n+\n+   \tx_3 = y_5;\n+\tif (x_3 > y_5)\n+\t  ...\n+\n+    Even if y_5 is deemed VARYING, we can determine that x_3 > y_5 is\n+    always false.  */\n+\n+static void\n+extract_range_from_ssa_name (value_range *vr, tree var)\n+{\n+  value_range *var_vr = get_value_range (var);\n+\n+  if (var_vr->type != VR_UNDEFINED && var_vr->type != VR_VARYING)\n+    *vr = *var_vr;\n+  else\n+    set_value_range (vr, VR_RANGE, var, var);\n+}\n+\n+\n+/* Extract range information from a binary expression EXPR based on\n+   the ranges of each of its operands and the expression code.  */\n+\n+static void\n+extract_range_from_binary_expr (value_range *vr, tree expr)\n+{\n+  enum tree_code code = TREE_CODE (expr);\n+  tree op0, op1, min, max;\n+  value_range vr0, vr1;\n+  int cmp;\n+\n+  /* Not all binary expressions can be applied to ranges in a\n+     meaningful way.  Handle only arithmetic operations.  */\n+  if (code != PLUS_EXPR\n+      && code != MINUS_EXPR\n+      && code != MULT_EXPR\n+      && code != TRUNC_DIV_EXPR\n+      && code != FLOOR_DIV_EXPR\n+      && code != CEIL_DIV_EXPR\n+      && code != EXACT_DIV_EXPR\n+      && code != ROUND_DIV_EXPR\n+      && code != MIN_EXPR\n+      && code != MAX_EXPR)\n+    {\n+      set_value_range (vr, VR_VARYING, NULL_TREE, NULL_TREE);\n+      return;\n+    }\n+\n+  /* Get value ranges for each operand.  For constant operands, create\n+     a new value range with the operand to simplify processing.  */\n+  op0 = TREE_OPERAND (expr, 0);\n+  if (TREE_CODE (op0) == SSA_NAME)\n+    vr0 = *(get_value_range (op0));\n+  else\n+    {\n+      if (is_gimple_min_invariant (op0))\n+\tset_value_range (&vr0, VR_RANGE, op0, op0);\n+      else\n+\tset_value_range (&vr0, VR_VARYING, NULL_TREE, NULL_TREE);\n+    }\n+\n+  op1 = TREE_OPERAND (expr, 1);\n+  if (TREE_CODE (op1) == SSA_NAME)\n+    vr1 = *(get_value_range (op1));\n+  else\n+    {\n+      if (is_gimple_min_invariant (op1))\n+\tset_value_range (&vr1, VR_RANGE, op1, op1);\n+      else\n+\tset_value_range (&vr1, VR_VARYING, 0, 0);\n+    }\n+\n+  /* If either range is UNDEFINED, so is the result.  */\n+  if (vr0.type == VR_UNDEFINED || vr1.type == VR_UNDEFINED)\n+    {\n+      set_value_range (vr, VR_UNDEFINED, NULL_TREE, NULL_TREE);\n+      return;\n+    }\n+\n+  /* If either range is VARYING, so is the result.  */\n+  if (vr0.type == VR_VARYING || vr1.type == VR_VARYING)\n+    {\n+      set_value_range (vr, VR_VARYING, NULL_TREE, NULL_TREE);\n+      return;\n+    }\n+\n+  /* If the ranges are of different types, the result is VARYING.  */\n+  if (vr0.type != vr1.type)\n+    {\n+      set_value_range (vr, VR_VARYING, NULL_TREE, NULL_TREE);\n+      return;\n+    }\n+\n+  /* TODO.  Refuse to do any symbolic range operations for now.  */\n+  if (symbolic_range_p (&vr0) || symbolic_range_p (&vr1))\n+    {\n+      set_value_range (vr, VR_VARYING, NULL_TREE, NULL_TREE);\n+      return;\n+    }\n+\n+  /* Now evaluate the expression to determine the new range.  */\n+  if (POINTER_TYPE_P (TREE_TYPE (expr))\n+      || POINTER_TYPE_P (TREE_TYPE (op0))\n+      || POINTER_TYPE_P (TREE_TYPE (op1)))\n+    {\n+      /* For pointer types, we are really only interested in asserting\n+\t whether the expression evaluates to non-NULL.  FIXME.  We\n+\t used to gcc_assert (code == PLUS_EXPR || code == MINUS_EXPR),\n+\t but ivopts is generating expressions with pointer\n+\t multiplication in them.  */\n+      if (code == PLUS_EXPR)\n+\t{\n+\t  /* Assume that pointers can never wrap around.  FIXME, Is\n+\t     this always safe?  */\n+\t  tree zero = build_int_cst (TREE_TYPE (expr), 0);\n+\t  set_value_range (vr, VR_ANTI_RANGE, zero, zero);\n+\t}\n+      else\n+\t{\n+\t  /* Subtracting from a pointer, may yield 0, so just drop the\n+\t     resulting range to varying.  */\n+\t  set_value_range (vr, VR_VARYING, NULL_TREE, NULL_TREE);\n+\t}\n+\n+      return;\n+    }\n+\n+  /* For integer ranges, apply the operation to each end of the\n+     range and see what we end up with.  */\n+  if (code == PLUS_EXPR\n+      || code == MULT_EXPR\n+      || code == MIN_EXPR\n+      || code == MAX_EXPR)\n+    {\n+      /* For operations that make the resulting range directly\n+\t proportional to the original ranges, apply the operation to\n+\t the same end of each range.  */\n+      min = int_const_binop (code, vr0.min, vr1.min, 0);\n+      max = int_const_binop (code, vr0.max, vr1.max, 0);\n+    }\n+  else\n+    {\n+      /* For operations that make the resulting range inversely\n+\t proportional to the original ranges (-, /), apply the\n+\t operation to the opposite ends of each range.  */\n+      min = int_const_binop (code, vr0.min, vr1.max, 0);\n+      max = int_const_binop (code, vr0.max, vr1.min, 0);\n+    }\n+\n+  cmp = compare_values (min, max);\n+  if (cmp == -2 || cmp == 1)\n+    {\n+      /* If the new range has its limits swapped around (MIN > MAX),\n+\t then the operation caused one of them to wrap around, mark\n+\t the new range VARYING.  */\n+      set_value_range (vr, VR_VARYING, NULL_TREE, NULL_TREE);\n+    }\n+  else\n+    set_value_range (vr, vr0.type, min, max);\n+}\n+\n+\n+/* Extract range information from a unary expression EXPR based on\n+   the range of its operand and the expression code.  */\n+\n+static void\n+extract_range_from_unary_expr (value_range *vr, tree expr)\n+{\n+  enum tree_code code = TREE_CODE (expr);\n+  tree min, max, op0;\n+  value_range vr0;\n+  int cmp;\n+\n+  /* Get value ranges for the operand.  For constant operands, create\n+     a new value range with the operand to simplify processing.  */\n+  op0 = TREE_OPERAND (expr, 0);\n+  if (TREE_CODE (op0) == SSA_NAME)\n+    vr0 = *(get_value_range (op0));\n+  else\n+    {\n+      if (is_gimple_min_invariant (op0))\n+\tset_value_range (&vr0, VR_RANGE, op0, op0);\n+      else\n+\tset_value_range (&vr0, VR_VARYING, NULL_TREE, NULL_TREE);\n+    }\n+\n+  /* If VR0 is UNDEFINED, so is the result.  */\n+  if (vr0.type == VR_UNDEFINED)\n+    {\n+      set_value_range (vr, VR_UNDEFINED, NULL_TREE, NULL_TREE);\n+      return;\n+    }\n+\n+  /* If VR0 is VARYING, so is the result.  */\n+  if (vr0.type == VR_VARYING)\n+    {\n+      set_value_range (vr, VR_VARYING, NULL_TREE, NULL_TREE);\n+      return;\n+    }\n+\n+  /* TODO.  Refuse to do any symbolic range operations for now.  */\n+  if (symbolic_range_p (&vr0))\n+    {\n+      set_value_range (vr, VR_VARYING, NULL_TREE, NULL_TREE);\n+      return;\n+    }\n+\n+  /* If the operand is neither a pointer nor an integral type, set the\n+     range to VARYING.  TODO, we may set the range to non-zero.  */\n+  if (!INTEGRAL_TYPE_P (TREE_TYPE (op0))\n+      && !POINTER_TYPE_P (TREE_TYPE (op0)))\n+    {\n+      set_value_range (vr, VR_VARYING, NULL_TREE, NULL_TREE);\n+      return;\n+    }\n+\n+  /* If the expression involves pointers, we are only interested in\n+     determining if it evaluates to NULL [0, 0] or non-NULL (~[0, 0]).  */\n+  if (POINTER_TYPE_P (TREE_TYPE (expr)) || POINTER_TYPE_P (TREE_TYPE (op0)))\n+    {\n+      if (range_is_nonnull (&vr0) || expr_computes_nonzero (expr))\n+\tset_value_range_to_nonnull (vr, TREE_TYPE (expr));\n+      else if (range_is_null (&vr0))\n+\tset_value_range_to_null (vr, TREE_TYPE (expr));\n+      else\n+\tset_value_range (vr, VR_VARYING, NULL_TREE, NULL_TREE);\n+\n+      return;\n+    }\n+\n+  /* Handle unary expressions on integer ranges.  */\n+  if ((code == NOP_EXPR || code == CONVERT_EXPR)\n+      && (TYPE_SIZE (TREE_TYPE (vr0.min)) != TYPE_SIZE (TREE_TYPE (expr))))\n+    {\n+      /* When converting types of different sizes, set the result to\n+\t VARYING.  Things like sign extensions and precision loss may\n+\t change the range.  For instance, if x_3 is of type 'long long\n+\t int' and 'y_5 = (unsigned short) x_3', if x_3 is ~[0, 0], it\n+\t is impossible to know at compile time whether y_5 will be\n+\t ~[0, 0].  */\n+      set_value_range (vr, VR_VARYING, NULL_TREE, NULL_TREE);\n+      return;\n+    }\n+\n+  /* Apply the operation to each end of the range and see what we end\n+     up with.  */\n+  min = fold_unary_to_constant (code, TREE_TYPE (expr), vr0.min);\n+  max = fold_unary_to_constant (code, TREE_TYPE (expr), vr0.max);\n+\n+  cmp = compare_values (min, max);\n+  if (cmp == -2 || cmp == 1)\n+    {\n+      /* If the new range has its limits swapped around (MIN > MAX),\n+\t then the operation caused one of them to wrap around, mark\n+\t the new range VARYING.  */\n+      set_value_range (vr, VR_VARYING, NULL_TREE, NULL_TREE);\n+    }\n+  else\n+    set_value_range (vr, vr0.type, min, max);\n+}\n+\n+\n+/* Try to compute a useful range out of expression EXPR and store it\n+   in *VR_P.  */\n+\n+static void\n+extract_range_from_expr (value_range *vr, tree expr)\n+{\n+  enum tree_code code = TREE_CODE (expr);\n+\n+  if (code == ASSERT_EXPR)\n+    extract_range_from_assert (vr, expr);\n+  else if (code == SSA_NAME)\n+    extract_range_from_ssa_name (vr, expr);\n+  else if (TREE_CODE_CLASS (code) == tcc_binary)\n+    extract_range_from_binary_expr (vr, expr);\n+  else if (TREE_CODE_CLASS (code) == tcc_unary)\n+    extract_range_from_unary_expr (vr, expr);\n+  else if (expr_computes_nonzero (expr))\n+    set_value_range_to_nonnull (vr, TREE_TYPE (expr));\n+  else\n+    set_value_range (vr, VR_VARYING, NULL_TREE, NULL_TREE);\n+}\n+\n+\n+/* Given a range VR, a loop L and a variable VAR, determine whether it\n+   would be profitable to adjust VR using scalar evolution information\n+   for VAR.  If so, update VR with the new limits.  */\n+\n+static void\n+adjust_range_with_scev (value_range *vr, struct loop *l, tree var)\n+{\n+  tree init, step, chrec;\n+  bool init_is_max;\n+\n+  /* TODO.  Don't adjust anti-ranges.  An anti-range may provide\n+     better opportunities than a regular range, but I'm not sure.  */\n+  if (vr->type == VR_ANTI_RANGE)\n+    return;\n+\n+  chrec = analyze_scalar_evolution (l, var);\n+  if (TREE_CODE (chrec) != POLYNOMIAL_CHREC)\n+    return;\n+\n+  init = CHREC_LEFT (chrec);\n+  step = CHREC_RIGHT (chrec);\n+\n+  /* If STEP is symbolic, we can't know whether INIT will be the\n+     minimum or maximum value in the range.  */\n+  if (!is_gimple_min_invariant (step))\n+    return;\n+\n+  /* FIXME.  When dealing with unsigned types,\n+     analyze_scalar_evolution sets STEP to very large unsigned values\n+     when the evolution goes backwards.  This confuses this analysis\n+     because we think that INIT is the smallest value that the range\n+     can take, instead of the largest.  Ignore these chrecs for now.  */\n+  if (INTEGRAL_TYPE_P (TREE_TYPE (step)) && TYPE_UNSIGNED (TREE_TYPE (step)))\n+    return;\n+\n+  /* If STEP is negative, then INIT is the maximum value the range\n+     will take.  Otherwise, INIT is the minimum value.  */\n+  init_is_max = (tree_int_cst_sgn (step) < 0);\n+\n+  if (!POINTER_TYPE_P (TREE_TYPE (init))\n+      && (vr->type == VR_VARYING || vr->type == VR_UNDEFINED))\n+    {\n+      /* For VARYING or UNDEFINED ranges, just about anything we get\n+\t from scalar evolutions should be better.  */\n+      if (init_is_max)\n+\tset_value_range (vr, VR_RANGE, TYPE_MIN_VALUE (TREE_TYPE (init)), init);\n+      else\n+\tset_value_range (vr, VR_RANGE, init, TYPE_MAX_VALUE (TREE_TYPE (init)));\n+    }\n+  else if (vr->type == VR_RANGE)\n+    {\n+      if (init_is_max)\n+\t{\n+\t  /* INIT is the maximum value.  If INIT is lower than\n+\t     VR->MAX, set VR->MAX to INIT.  */\n+\t  if (compare_values (init, vr->max) == -1)\n+\t    set_value_range (vr, VR_RANGE, vr->min, init);\n+\t}\n+      else\n+\t{\n+\t  /* If INIT is bigger than VR->MIN, set VR->MIN to INIT.  */\n+\t  if (compare_values (init, vr->min) == 1)\n+\t    set_value_range (vr, VR_RANGE, init, vr->max);\n+\t}\n+    }\n+}\n+\n+\n+/* Given two numeric value ranges VR0, VR1 and a comparison code COMP:\n+   \n+   - Return BOOLEAN_TRUE_NODE if VR0 COMP VR1 always returns true for all the\n+     values in the ranges.\n+\n+   - Return BOOLEAN_FALSE_NODE if the comparison always returns false.\n+\n+   - Return NULL_TREE if it is not always possible to determine the value of\n+     the comparison.  */\n+\n+static tree\n+compare_ranges (enum tree_code comp, value_range *vr0, value_range *vr1)\n+{\n+  /* VARYING or UNDEFINED ranges cannot be compared.  */\n+  if (vr0->type == VR_VARYING\n+      || vr0->type == VR_UNDEFINED\n+      || vr1->type == VR_VARYING\n+      || vr1->type == VR_UNDEFINED)\n+    return NULL_TREE;\n+\n+  /* Anti-ranges need to be handled separately.  */\n+  if (vr0->type == VR_ANTI_RANGE || vr1->type == VR_ANTI_RANGE)\n+    {\n+      /* If both are anti-ranges, then we cannot compute any\n+\t comparison.  */\n+      if (vr0->type == VR_ANTI_RANGE && vr1->type == VR_ANTI_RANGE)\n+\treturn NULL_TREE;\n+\n+      /* These comparisons are never statically computable.  */\n+      if (comp == GT_EXPR\n+\t  || comp == GE_EXPR\n+\t  || comp == LT_EXPR\n+\t  || comp == LE_EXPR)\n+\treturn NULL_TREE;\n+\n+      /* Equality can be computed only between a range and an\n+\t anti-range.  ~[VAL1, VAL2] == [VAL1, VAL2] is always false.  */\n+      if (vr0->type == VR_RANGE)\n+\t{\n+\t  /* To simplify processing, make VR0 the anti-range.  */\n+\t  value_range *tmp = vr0;\n+\t  vr0 = vr1;\n+\t  vr1 = tmp;\n+\t}\n+\n+      gcc_assert (comp == NE_EXPR || comp == EQ_EXPR);\n+\n+      if (compare_values (vr0->min, vr1->min) == 0\n+\t  && compare_values (vr0->max, vr1->max) == 0)\n+\treturn (comp == NE_EXPR) ? boolean_true_node : boolean_false_node;\n+\n+      return NULL_TREE;\n+    }\n+\n+  /* Simplify processing.  If COMP is GT_EXPR or GE_EXPR, switch the\n+     operands around and change the comparison code.  */\n+  if (comp == GT_EXPR || comp == GE_EXPR)\n+    {\n+      value_range *tmp;\n+      comp = (comp == GT_EXPR) ? LT_EXPR : LE_EXPR;\n+      tmp = vr0;\n+      vr0 = vr1;\n+      vr1 = tmp;\n+    }\n+\n+  if (comp == EQ_EXPR)\n+    {\n+      /* Equality may only be computed if both ranges represent\n+\t exactly one value.  */\n+      if (compare_values (vr0->min, vr0->max) == 0\n+\t  && compare_values (vr1->min, vr1->max) == 0)\n+\t{\n+\t  int cmp_min = compare_values (vr0->min, vr1->min);\n+\t  int cmp_max = compare_values (vr0->max, vr1->max);\n+\t  if (cmp_min == 0 && cmp_max == 0)\n+\t    return boolean_true_node;\n+\t  else if (cmp_min != -2 && cmp_max != -2)\n+\t    return boolean_false_node;\n+\t}\n+\n+      return NULL_TREE;\n+    }\n+  else if (comp == NE_EXPR)\n+    {\n+      int cmp1, cmp2;\n+\n+      /* If VR0 is completely to the left or completely to the right\n+\t of VR1, they are always different.  Notice that we need to\n+\t make sure that both comparisons yield similar results to\n+\t avoid comparing values that cannot be compared at\n+\t compile-time.  */\n+      cmp1 = compare_values (vr0->max, vr1->min);\n+      cmp2 = compare_values (vr0->min, vr1->max);\n+      if ((cmp1 == -1 && cmp2 == -1) || (cmp1 == 1 && cmp2 == 1))\n+\treturn boolean_true_node;\n+\n+      /* If VR0 and VR1 represent a single value and are identical,\n+\t return false.  */\n+      else if (compare_values (vr0->min, vr0->max) == 0\n+\t       && compare_values (vr1->min, vr1->max) == 0\n+\t       && compare_values (vr0->min, vr1->min) == 0\n+\t       && compare_values (vr0->max, vr1->max) == 0)\n+\treturn boolean_false_node;\n+\n+      /* Otherwise, they may or may not be different.  */\n+      else\n+\treturn NULL_TREE;\n+    }\n+  else if (comp == LT_EXPR || comp == LE_EXPR)\n+    {\n+      int tst;\n+\n+      /* If VR0 is to the left of VR1, return true.  */\n+      tst = compare_values (vr0->max, vr1->min);\n+      if ((comp == LT_EXPR && tst == -1)\n+\t  || (comp == LE_EXPR && (tst == -1 || tst == 0)))\n+\treturn boolean_true_node;\n+\n+      /* If VR0 is to the right of VR1, return false.  */\n+      tst = compare_values (vr0->min, vr1->max);\n+      if ((comp == LT_EXPR && (tst == 0 || tst == 1))\n+\t  || (comp == LE_EXPR && tst == 1))\n+\treturn boolean_false_node;\n+\n+      /* Otherwise, we don't know.  */\n+      return NULL_TREE;\n+    }\n+    \n+  gcc_unreachable ();\n+}\n+\n+\n+/* Given a value range VR, a value VAL and a comparison code COMP, return\n+   BOOLEAN_TRUE_NODE if VR COMP VR1 always returns true for all the\n+   values in VR.  Return BOOLEAN_FALSE_NODE if the comparison\n+   always returns false.  Return NULL_TREE if it is not always\n+   possible to determine the value of the comparison.  */\n+\n+static tree\n+compare_range_with_value (enum tree_code comp, value_range *vr, tree val)\n+{\n+  if (vr->type == VR_VARYING || vr->type == VR_UNDEFINED)\n+    return NULL_TREE;\n+\n+  /* Anti-ranges need to be handled separately.  */\n+  if (vr->type == VR_ANTI_RANGE)\n+    {\n+      /* For anti-ranges, the only predicates that we can compute at\n+\t compile time are equality and inequality.  */\n+      if (comp == GT_EXPR\n+\t  || comp == GE_EXPR\n+\t  || comp == LT_EXPR\n+\t  || comp == LE_EXPR)\n+\treturn NULL_TREE;\n+\n+      /* ~[VAL, VAL] == VAL is always false.  */\n+      if (compare_values (vr->min, val) == 0\n+\t  && compare_values (vr->max, val) == 0)\n+\treturn (comp == NE_EXPR) ? boolean_true_node : boolean_false_node;\n+\n+      return NULL_TREE;\n+    }\n+\n+  if (comp == EQ_EXPR)\n+    {\n+      /* EQ_EXPR may only be computed if VR represents exactly\n+\t one value.  */\n+      if (compare_values (vr->min, vr->max) == 0)\n+\t{\n+\t  int cmp = compare_values (vr->min, val);\n+\t  if (cmp == 0)\n+\t    return boolean_true_node;\n+\t  else if (cmp == -1 || cmp == 1 || cmp == 2)\n+\t    return boolean_false_node;\n+\t}\n+\n+      return NULL_TREE;\n+    }\n+  else if (comp == NE_EXPR)\n+    {\n+      /* If VAL is not inside VR, then they are always different.  */\n+      if (compare_values (vr->max, val) == -1\n+\t  || compare_values (vr->min, val) == 1)\n+\treturn boolean_true_node;\n+\n+      /* If VR represents exactly one value equal to VAL, then return\n+\t false.  */\n+      if (compare_values (vr->min, vr->max) == 0\n+\t  && compare_values (vr->min, val) == 0)\n+\treturn boolean_false_node;\n+\n+      /* Otherwise, they may or may not be different.  */\n+      return NULL_TREE;\n+    }\n+  else if (comp == LT_EXPR || comp == LE_EXPR)\n+    {\n+      int tst;\n+\n+      /* If VR is to the left of VAL, return true.  */\n+      tst = compare_values (vr->max, val);\n+      if ((comp == LT_EXPR && tst == -1)\n+\t  || (comp == LE_EXPR && (tst == -1 || tst == 0)))\n+\treturn boolean_true_node;\n+\n+      /* If VR is to the right of VAL, return false.  */\n+      tst = compare_values (vr->min, val);\n+      if ((comp == LT_EXPR && (tst == 0 || tst == 1))\n+\t  || (comp == LE_EXPR && tst == 1))\n+\treturn boolean_false_node;\n+\n+      /* Otherwise, we don't know.  */\n+      return NULL_TREE;\n+    }\n+  else if (comp == GT_EXPR || comp == GE_EXPR)\n+    {\n+      int tst;\n+\n+      /* If VR is to the right of VAL, return true.  */\n+      tst = compare_values (vr->min, val);\n+      if ((comp == GT_EXPR && tst == 1)\n+\t  || (comp == GE_EXPR && (tst == 0 || tst == 1)))\n+\treturn boolean_true_node;\n+\n+      /* If VR is to the left of VAL, return false.  */\n+      tst = compare_values (vr->max, val);\n+      if ((comp == GT_EXPR && (tst == -1 || tst == 0))\n+\t  || (comp == GE_EXPR && tst == -1))\n+\treturn boolean_false_node;\n+\n+      /* Otherwise, we don't know.  */\n+      return NULL_TREE;\n+    }\n+\n+  gcc_unreachable ();\n+}\n+\n+\n+/* Debugging dumps.  */\n+\n+void\n+dump_value_range (FILE *file, value_range *vr)\n+{\n+  if (vr == NULL)\n+    fprintf (file, \"[]\");\n+  else if (vr->type == VR_UNDEFINED)\n+    fprintf (file, \"UNDEFINED\");\n+  else if (vr->type == VR_RANGE || vr->type == VR_ANTI_RANGE)\n+    {\n+      fprintf (file, \"%s[\", (vr->type == VR_ANTI_RANGE) ? \"~\" : \"\");\n+      print_generic_expr (file, vr->min, 0);\n+      fprintf (file, \", \");\n+      print_generic_expr (file, vr->max, 0);\n+      fprintf (file, \"]\");\n+    }\n+  else if (vr->type == VR_VARYING)\n+    fprintf (file, \"VARYING\");\n+  else\n+    fprintf (file, \"INVALID RANGE\");\n+}\n+\n+\n+/* Dump value range VR to stderr.  */\n+\n+void\n+debug_value_range (value_range *vr)\n+{\n+  dump_value_range (stderr, vr);\n+}\n+\n+\n+/* Dump value ranges of all SSA_NAMEs to FILE.  */\n+\n+void\n+dump_all_value_ranges (FILE *file)\n+{\n+  size_t i;\n+\n+  for (i = 0; i < num_ssa_names; i++)\n+    {\n+      tree var = ssa_name (i);\n+      if (var && SSA_NAME_VALUE_RANGE (var))\n+\t{\n+\t  print_generic_expr (file, var, 0);\n+\t  fprintf (file, \": \");\n+\t  dump_value_range (file, SSA_NAME_VALUE_RANGE (var));\n+\t  fprintf (file, \"\\n\");\n+\t}\n+    }\n+\n+  fprintf (file, \"\\n\");\n+}\n+\n+\n+/* Dump all value ranges to stderr.  */\n+\n+void\n+debug_all_value_ranges (void)\n+{\n+  dump_all_value_ranges (stderr);\n+}\n+\n+\n+/*---------------------------------------------------------------------------\n+\t\t\t    Value Range Propagation\n+---------------------------------------------------------------------------*/\n+\n+/* Given a COND_EXPR COND of the form 'V OP W', and an SSA name V,\n+   create a new SSA name N and return the assertion assignment\n+   'V = ASSERT_EXPR <V, V OP W>'.  */\n+\n+static tree\n+build_assert_expr_for (tree cond, tree v)\n+{\n+  tree n, assertion;\n+\n+  gcc_assert (TREE_CODE (v) == SSA_NAME);\n+  n = duplicate_ssa_name (v, NULL_TREE);\n+\n+  if (TREE_CODE_CLASS (TREE_CODE (cond)) == tcc_comparison)\n+    {\n+      /* Build N = ASSERT_EXPR <V, COND>.  As a special case, if the\n+\t conditional is an EQ_EXPR (V == Z), just build the assignment\n+\t N = Z.  */\n+      if (TREE_CODE (cond) == EQ_EXPR)\n+\t{\n+\t  tree other = get_opposite_operand (cond, v);\n+\t  assertion = build (MODIFY_EXPR, TREE_TYPE (v), n, other);\n+\t}\n+      else\n+\tassertion = build (MODIFY_EXPR, TREE_TYPE (v), n,\n+\t                   build (ASSERT_EXPR, TREE_TYPE (v), v, cond));\n+    }\n+  else if (TREE_CODE (cond) == TRUTH_NOT_EXPR)\n+    {\n+      /* Given !V, build the assignment N = false.  */\n+      tree op0 = TREE_OPERAND (cond, 0);\n+      gcc_assert (op0 == v);\n+      assertion = build (MODIFY_EXPR, TREE_TYPE (v), n, boolean_false_node);\n+    }\n+  else if (TREE_CODE (cond) == SSA_NAME)\n+    {\n+      /* Given V, build the assignment N = true.  */\n+      gcc_assert (v == cond);\n+      assertion = build (MODIFY_EXPR, TREE_TYPE (v), n, boolean_true_node);\n+    }\n+  else\n+    gcc_unreachable ();\n+\n+  SSA_NAME_DEF_STMT (n) = assertion;\n+\n+  /* The new ASSERT_EXPR, creates a new SSA name that replaces the\n+     operand of the ASSERT_EXPR. Register the new name and the old one\n+     in the replacement table so that we can fix the SSA web after\n+     adding all the ASSERT_EXPRs.  */\n+  register_new_name_mapping (n, v);\n+\n+  return assertion;\n+}\n+\n+\n+/* Return false if EXPR is a predicate expression involving floating\n+   point values.  */\n+\n+static inline bool\n+fp_predicate (tree expr)\n+{\n+  return TREE_CODE_CLASS (TREE_CODE (expr)) == tcc_comparison\n+         && FLOAT_TYPE_P (TREE_TYPE (TREE_OPERAND (expr, 0)));\n+}\n+\n+\n+/* Return an expression predicate that represents the range of values\n+   that can be taken by operand OP after STMT executes.  */\n+\n+static tree\n+infer_value_range (tree stmt, tree op)\n+{\n+  if (POINTER_TYPE_P (TREE_TYPE (op)))\n+    {\n+      bool is_store;\n+      unsigned num_uses, num_derefs;\n+\n+      count_uses_and_derefs (op, stmt, &num_uses, &num_derefs, &is_store);\n+      if (num_derefs > 0 && flag_delete_null_pointer_checks)\n+\t{\n+\t  /* We can only assume that a pointer dereference will yield\n+\t     non-NULL if -fdelete-null-pointer-checks is enabled.  */\n+\t  tree null = build_int_cst (TREE_TYPE (op), 0);\n+\t  tree t = build (NE_EXPR, boolean_type_node, op, null);\n+\t  return t;\n+\t}\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+\n+/* Return true if OP is the result of an ASSERT_EXPR that tests the\n+   same condition as COND.  */\n+\n+static bool\n+has_assert_expr (tree op, tree cond)\n+{\n+  tree def_stmt = SSA_NAME_DEF_STMT (op);\n+  tree assert_expr, other_cond, other_op;\n+\n+  /* If OP was not generated by an ASSERT_EXPR, return false.  */\n+  if (TREE_CODE (def_stmt) != MODIFY_EXPR\n+      || TREE_CODE (TREE_OPERAND (def_stmt, 1)) != ASSERT_EXPR)\n+    return false;\n+\n+  assert_expr = TREE_OPERAND (def_stmt, 1);\n+  other_cond = ASSERT_EXPR_COND (assert_expr);\n+  other_op = ASSERT_EXPR_VAR (assert_expr);\n+\n+  if (TREE_CODE (cond) == TREE_CODE (other_cond))\n+    {\n+      tree t1, t2;\n+\n+      /* If COND is not a comparison predicate, something is wrong.  */\n+      gcc_assert (TREE_CODE_CLASS (TREE_CODE (cond)) == tcc_comparison);\n+\n+      /* Note that we only need to compare against one of the operands\n+\t of OTHER_COND.  \n+\t \n+\t Suppose that we are about to insert the assertion ASSERT_EXPR\n+\t <x_4, x_4 != 0> and the defining statement for x_4 is x_4 =\n+\t ASSERT_EXPR <x_3, x_3 != 0>.\n+\n+\t In this case, we don't really want to insert a new\n+\t ASSERT_EXPR for x_4 because that would be redundant.  We\n+\t already know that x_4 is not 0.  So, when comparing the\n+\t conditionals 'x_3 != 0' and 'x_4 != 0', we don't want to\n+\t compare x_3 and x_4, we just want to compare the predicate's\n+\t code (!=) and the other operand (0).  */\n+      if (TREE_OPERAND (cond, 0) == op)\n+\tt1 = TREE_OPERAND (cond, 1);\n+      else\n+\tt1 = TREE_OPERAND (cond, 0);\n+\n+      if (TREE_OPERAND (other_cond, 0) == other_op)\n+\tt2 = TREE_OPERAND (other_cond, 1);\n+      else\n+\tt2 = TREE_OPERAND (other_cond, 0);\n+\n+      return (t1 == t2 || operand_equal_p (t1, t2, 0));\n+    }\n+\n+  return false;\n+}\n+\n+\n+/* Traverse all the statements in block BB looking for used variables.\n+   Variables used in BB are added to bitmap FOUND.  The algorithm\n+   works in three main parts:\n+\n+   1- For every statement S in BB, all the variables used by S are\n+      added to bitmap FOUND.\n+\n+   2- If statement S uses an operand N in a way that exposes a known\n+      value range for N, then if N was not already generated by an\n+      ASSERT_EXPR, create a new ASSERT_EXPR for N.  For instance, if N\n+      is a pointer and the statement dereferences it, we can assume\n+      that N is not NULL.\n+\n+   3- COND_EXPRs are a special case of #2.  We can derive range\n+      information from the predicate but need to insert different\n+      ASSERT_EXPRs for each of the sub-graphs rooted at the\n+      conditional block.  If the last statement of BB is a conditional\n+      expression of the form 'X op Y', then\n+\n+      a) Remove X and Y from the set FOUND.\n+\n+      b) If the conditional dominates its THEN_CLAUSE sub-graph,\n+\t recurse into it.  On return, if X and/or Y are marked in\n+\t FOUND, then an ASSERT_EXPR is added for the corresponding\n+\t variable.\n+\n+      c) Repeat step (b) on the ELSE_CLAUSE.\n+\n+      d) Mark X and Y in FOUND.\n+\n+   3- If BB does not end in a conditional expression, then we recurse\n+      into BB's dominator children.\n+   \n+   At the end of the recursive traversal, ASSERT_EXPRs will have been\n+   added to the edges of COND_EXPR blocks that have sub-graphs using\n+   one or both predicate operands.  For instance,\n+\n+   \tif (a == 9)\n+\t  b = a;\n+\telse\n+\t  b = c + 1;\n+\n+   In this case, an assertion on the THEN clause is useful to\n+   determine that 'a' is always 9 on that edge.  However, an assertion\n+   on the ELSE clause would be unnecessary.\n+\n+   On exit from this function, all the names created by the newly\n+   inserted ASSERT_EXPRs need to be added to the SSA web by rewriting\n+   the SSA names that they replace.\n+   \n+   TODO.  Handle SWITCH_EXPR.  */\n+\n+static bool\n+maybe_add_assert_expr (basic_block bb)\n+{\n+  block_stmt_iterator si;\n+  tree last;\n+  bool added;\n+  use_optype uses;\n+\n+  /* Step 1.  Mark all the SSA names used in BB in bitmap FOUND.  */\n+  added = false;\n+  last = NULL_TREE;\n+  for (si = bsi_start (bb); !bsi_end_p (si); bsi_next (&si))\n+    {\n+      tree stmt, op;\n+      ssa_op_iter i;\n+      \n+      stmt = bsi_stmt (si);\n+      get_stmt_operands (stmt);\n+\n+      /* Mark all the SSA names used by STMT in bitmap FOUND.  If STMT\n+\t is inside the sub-graph of a conditional block, when we\n+\t return from this recursive walk, our parent will use the\n+\t FOUND bitset to determine if one of the operands it was\n+\t looking for was present in the sub-graph.  */\n+      FOR_EACH_SSA_TREE_OPERAND (op, stmt, i, SSA_OP_USE)\n+\t{\n+\t  tree cond;\n+\n+\t  SET_BIT (found, SSA_NAME_VERSION (op));\n+\n+\t  cond = infer_value_range (stmt, op);\n+\t  if (!cond)\n+\t    continue;\n+\n+\t  /* Step 3.  If OP is used in such a way that we can infer a\n+\t     value range for it, create a new ASSERT_EXPR for OP\n+\t     (unless OP already has an ASSERT_EXPR).  */\n+\t  gcc_assert (!is_ctrl_stmt (stmt));\n+\n+\t  if (has_assert_expr (op, cond))\n+\t    continue;\n+\n+\t  if (!stmt_ends_bb_p (stmt))\n+\t    {\n+\t      /* If STMT does not end the block, we can insert the new\n+\t\t assertion right after it.  */\n+\t      tree t = build_assert_expr_for (cond, op);\n+\t      bsi_insert_after (&si, t, BSI_NEW_STMT);\n+\t      added = true;\n+\t    }\n+\t  else\n+\t    {\n+\t      /* STMT must be the last statement in BB.  We can only\n+\t\t insert new assertions on the non-abnormal edge out of\n+\t\t BB.  Note that since STMT is not control flow, there\n+\t\t may only be one non-abnormal edge out of BB.  */\n+\t      edge_iterator ei;\n+\t      edge e;\n+\n+\t      FOR_EACH_EDGE (e, ei, bb->succs)\n+\t\tif (!(e->flags & EDGE_ABNORMAL))\n+\t\t  {\n+\t\t    tree t = build_assert_expr_for (cond, op);\n+\t\t    bsi_insert_on_edge (e, t);\n+\t\t    added = true;\n+\t\t    break;\n+\t\t  }\n+\t    }\n+\t}\n+\n+      /* Remember the last statement of the block.  */\n+      last = stmt;\n+    }\n+\n+  /* Step 3.  If BB's last statement is a conditional expression\n+     involving integer operands, recurse into each of the sub-graphs\n+     rooted at BB to determine if we need to add ASSERT_EXPRs.\n+     Notice that we only care about the first operand of the\n+     conditional.  Adding assertions for both operands may actually \n+     hinder VRP.  FIXME, add example.  */\n+  if (last\n+      && TREE_CODE (last) == COND_EXPR\n+      && !fp_predicate (COND_EXPR_COND (last))\n+      && NUM_USES (uses = STMT_USE_OPS (last)) > 0)\n+    {\n+      edge e;\n+      edge_iterator ei;\n+      tree op, cond;\n+      \n+      cond = COND_EXPR_COND (last);\n+\n+      /* Remove the COND_EXPR operand from the FOUND bitmap.\n+\t Otherwise, when we finish traversing each of the sub-graphs,\n+\t we won't know whether the variables were found in the\n+\t sub-graphs or if they had been found in a block upstream from\n+\t BB.  */\n+      op = USE_OP (uses, 0);\n+      RESET_BIT (found, SSA_NAME_VERSION (op));\n+\n+      /* Look for uses of the operands in each of the sub-graphs\n+\t rooted at BB.  We need to check each of the outgoing edges\n+\t separately, so that we know what kind of ASSERT_EXPR to\n+\t insert.  */\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n+\t{\n+\t  /* If BB strictly dominates the sub-graph at E->DEST,\n+\t     recurse into it.  */\n+\t  if (e->dest != bb\n+\t      && dominated_by_p (CDI_DOMINATORS, e->dest, bb))\n+\t    added |= maybe_add_assert_expr (e->dest);\n+\n+\t  /* Once we traversed the sub-graph, check if any block inside\n+\t     used either of the predicate's operands.  If so, add the\n+\t     appropriate ASSERT_EXPR.  */\n+\t  if (TEST_BIT (found, SSA_NAME_VERSION (op)))\n+\t    {\n+\t      /* We found a use of OP in the sub-graph rooted at\n+\t\t E->DEST.  Add an ASSERT_EXPR according to whether\n+\t\t E goes to THEN_CLAUSE or ELSE_CLAUSE.  */\n+\t      tree c, t;\n+\n+\t      if (e->flags & EDGE_TRUE_VALUE)\n+\t\tc = unshare_expr (cond);\n+\t      else if (e->flags & EDGE_FALSE_VALUE)\n+\t\tc = invert_truthvalue (cond);\n+\t      else\n+\t\tgcc_unreachable ();\n+\n+\t      t = build_assert_expr_for (c, op);\n+\t      bsi_insert_on_edge (e, t);\n+\t      added = true;\n+\t    }\n+\t}\n+\n+      /* Finally, mark all the COND_EXPR operands as found.  */\n+      SET_BIT (found, SSA_NAME_VERSION (op));\n+    }\n+  else\n+    {\n+      /* Step 3.  Recurse into the dominator children of BB.  */\n+      basic_block son;\n+\n+      for (son = first_dom_son (CDI_DOMINATORS, bb);\n+\t   son;\n+\t   son = next_dom_son (CDI_DOMINATORS, son))\n+\tadded |= maybe_add_assert_expr (son);\n+    }\n+\n+  return added;\n+}\n+\n+\n+/* Traverse the flowgraph looking for conditional jumps to insert range\n+   expressions.  These range expressions are meant to provide information\n+   to optimizations that need to reason in terms of value ranges.  They\n+   will not be expanded into RTL.  For instance, given:\n+\n+   x = ...\n+   y = ...\n+   if (x < y)\n+     y = x - 2;\n+   else\n+     x = y + 3;\n+\n+   this pass will transform the code into:\n+\n+   x = ...\n+   y = ...\n+   if (x < y)\n+    {\n+      x = ASSERT_EXPR <x, x < y>\n+      y = x - 2\n+    }\n+   else\n+    {\n+      y = ASSERT_EXPR <y, x <= y>\n+      x = y + 3\n+    }\n+\n+   The idea is that once copy and constant propagation have run, other\n+   optimizations will be able to determine what ranges of values can 'x'\n+   take in different paths of the code, simply by checking the reaching\n+   definition of 'x'.  */\n+\n+static void\n+insert_range_assertions (void)\n+{\n+  edge e;\n+  edge_iterator ei;\n+  bool update_ssa_p;\n+  \n+  found = sbitmap_alloc (num_ssa_names);\n+  sbitmap_zero (found);\n+\n+  calculate_dominance_info (CDI_DOMINATORS);\n+\n+  update_ssa_p = false;\n+  FOR_EACH_EDGE (e, ei, ENTRY_BLOCK_PTR->succs)\n+    if (maybe_add_assert_expr (e->dest))\n+      update_ssa_p = true;\n+\n+  if (update_ssa_p)\n+    {\n+      bsi_commit_edge_inserts ();\n+      update_ssa (TODO_update_ssa_no_phi);\n+    }\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"\\nSSA form after inserting ASSERT_EXPRs\\n\");\n+      dump_function_to_file (current_function_decl, dump_file, dump_flags);\n+    }\n+\n+  sbitmap_free (found);\n+}\n+\n+\n+/* Convert range assertion expressions into copies.  FIXME, explain why.  */\n+\n+static void\n+remove_range_assertions (void)\n+{\n+  basic_block bb;\n+  block_stmt_iterator si;\n+\n+  FOR_EACH_BB (bb)\n+    for (si = bsi_start (bb); !bsi_end_p (si); bsi_next (&si))\n+      {\n+\ttree stmt = bsi_stmt (si);\n+\n+\tif (TREE_CODE (stmt) == MODIFY_EXPR\n+\t    && TREE_CODE (TREE_OPERAND (stmt, 1)) == ASSERT_EXPR)\n+\t  {\n+\t    tree rhs = TREE_OPERAND (stmt, 1);\n+\t    tree cond = fold (ASSERT_EXPR_COND (rhs));\n+\t    gcc_assert (cond != boolean_false_node);\n+\t    TREE_OPERAND (stmt, 1) = ASSERT_EXPR_VAR (rhs);\n+\t    update_stmt (stmt);\n+\t  }\n+      }\n+}\n+\n+\n+/* Return true if STMT is interesting for VRP.  */\n+\n+static bool\n+stmt_interesting_for_vrp (tree stmt)\n+{\n+  if (TREE_CODE (stmt) == PHI_NODE\n+      && is_gimple_reg (PHI_RESULT (stmt))\n+      && (INTEGRAL_TYPE_P (TREE_TYPE (PHI_RESULT (stmt)))\n+\t  || POINTER_TYPE_P (TREE_TYPE (PHI_RESULT (stmt)))))\n+    return true;\n+  else if (TREE_CODE (stmt) == MODIFY_EXPR)\n+    {\n+      tree lhs = TREE_OPERAND (stmt, 0);\n+      stmt_ann_t ann = stmt_ann (stmt);\n+\n+      if (TREE_CODE (lhs) == SSA_NAME\n+\t  && (INTEGRAL_TYPE_P (TREE_TYPE (lhs))\n+\t      || POINTER_TYPE_P (TREE_TYPE (lhs)))\n+\t  && NUM_V_MAY_DEFS (V_MAY_DEF_OPS (ann)) == 0\n+\t  && NUM_VUSES (VUSE_OPS (ann)) == 0\n+\t  && NUM_V_MUST_DEFS (V_MUST_DEF_OPS (ann)) == 0)\n+\treturn true;\n+    }\n+  else if (TREE_CODE (stmt) == COND_EXPR || TREE_CODE (stmt) == SWITCH_EXPR)\n+    return true;\n+\n+  return false;\n+}\n+\n+\n+/* Initialize local data structures for VRP.  Return true if VRP\n+   is worth running (i.e. if we found any statements that could\n+   benefit from range information).  */\n+\n+static bool\n+vrp_initialize (void)\n+{\n+  basic_block bb;\n+  bool do_vrp;\n+\n+  /* If we don't find any ASSERT_EXPRs in the code, there's no point\n+     running VRP.  */\n+  do_vrp = false;\n+\n+  FOR_EACH_BB (bb)\n+    {\n+      block_stmt_iterator si;\n+      tree phi;\n+\n+      for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n+\t{\n+\t  if (!stmt_interesting_for_vrp (phi))\n+\t    {\n+\t      tree lhs = PHI_RESULT (phi);\n+\t      set_value_range (get_value_range (lhs), VR_VARYING, 0, 0);\n+\t      DONT_SIMULATE_AGAIN (phi) = true;\n+\t    }\n+\t  else\n+\t    DONT_SIMULATE_AGAIN (phi) = false;\n+\t}\n+\n+      for (si = bsi_start (bb); !bsi_end_p (si); bsi_next (&si))\n+        {\n+\t  tree stmt = bsi_stmt (si);\n+\n+\t  if (!stmt_interesting_for_vrp (stmt))\n+\t    {\n+\t      ssa_op_iter i;\n+\t      tree def;\n+\t      FOR_EACH_SSA_TREE_OPERAND (def, stmt, i, SSA_OP_DEF)\n+\t\tset_value_range (get_value_range (def), VR_VARYING, 0, 0);\n+\t      DONT_SIMULATE_AGAIN (stmt) = true;\n+\t    }\n+\t  else\n+\t    {\n+\t      if (TREE_CODE (stmt) == MODIFY_EXPR\n+\t           && TREE_CODE (TREE_OPERAND (stmt, 1)) == ASSERT_EXPR)\n+\t\tdo_vrp = true;\n+\n+\t      DONT_SIMULATE_AGAIN (stmt) = false;\n+\t    }\n+\t}\n+    }\n+\n+  return do_vrp;\n+}\n+\n+\n+/* Visit assignment STMT.  If it produces an interesting range, record\n+   the SSA name in *OUTPUT_P.  */\n+\n+static enum ssa_prop_result\n+vrp_visit_assignment (tree stmt, tree *output_p)\n+{\n+  tree lhs, rhs, def;\n+  ssa_op_iter iter;\n+\n+  lhs = TREE_OPERAND (stmt, 0);\n+  rhs = TREE_OPERAND (stmt, 1);\n+\n+  /* We only keep track of ranges in integral and pointer types.  */\n+  if (TREE_CODE (lhs) == SSA_NAME\n+      && (INTEGRAL_TYPE_P (TREE_TYPE (lhs))\n+\t  || POINTER_TYPE_P (TREE_TYPE (lhs))))\n+    {\n+      value_range *vr, new_vr;\n+      struct loop *l;\n+      \n+      vr = get_value_range (lhs);\n+      extract_range_from_expr (&new_vr, rhs);\n+\n+      /* If STMT is inside a loop, we may be able to know something\n+\t else about the range of LHS by examining scalar evolution\n+\t information.  */\n+      if (cfg_loops && (l = loop_containing_stmt (stmt)))\n+\tadjust_range_with_scev (&new_vr, l, lhs);\n+\n+      if (update_value_range (vr, new_vr.type, new_vr.min, new_vr.max))\n+\t{\n+\t  *output_p = lhs;\n+\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    {\n+\t      fprintf (dump_file, \"Found new range \");\n+\t      dump_value_range (dump_file, &new_vr);\n+\t      fprintf (dump_file, \" for \");\n+\t      print_generic_expr (dump_file, lhs, 0);\n+\t      fprintf (dump_file, \"\\n\\n\");\n+\t    }\n+\n+\t  if (new_vr.type == VR_VARYING)\n+\t    return SSA_PROP_VARYING;\n+\n+\t  return SSA_PROP_INTERESTING;\n+\t}\n+\n+      return SSA_PROP_NOT_INTERESTING;\n+    }\n+  \n+  /* Every other statements produces no useful ranges.  */\n+  FOR_EACH_SSA_TREE_OPERAND (def, stmt, iter, SSA_OP_DEF)\n+    set_value_range (get_value_range (def), VR_VARYING, 0, 0);\n+\n+  return SSA_PROP_VARYING;\n+}\n+\n+\n+/* Given a conditional predicate COND, try to determine if COND yields\n+   true or false based on the value ranges of its operands.  */\n+\n+static tree\n+vrp_evaluate_conditional (tree cond)\n+{\n+  gcc_assert (TREE_CODE (cond) == SSA_NAME\n+              || TREE_CODE_CLASS (TREE_CODE (cond)) == tcc_comparison);\n+\n+  if (TREE_CODE (cond) == SSA_NAME)\n+    {\n+      /* For SSA names, only return a truth value if the range is\n+\t known and contains exactly one value.  */\n+      value_range *vr = SSA_NAME_VALUE_RANGE (cond);\n+      if (vr && vr->type == VR_RANGE && vr->min == vr->max)\n+\treturn vr->min;\n+    }\n+  else\n+    {\n+      /* For comparisons, evaluate each operand and compare their\n+\t ranges.  */\n+      tree op0, op1;\n+      value_range *vr0, *vr1;\n+\n+      op0 = TREE_OPERAND (cond, 0);\n+      vr0 = (TREE_CODE (op0) == SSA_NAME) ? get_value_range (op0) : NULL;\n+\n+      op1 = TREE_OPERAND (cond, 1);\n+      vr1 = (TREE_CODE (op1) == SSA_NAME) ? get_value_range (op1) : NULL;\n+\n+      if (vr0 && vr1)\n+\treturn compare_ranges (TREE_CODE (cond), vr0, vr1);\n+      else if (vr0 && vr1 == NULL)\n+\treturn compare_range_with_value (TREE_CODE (cond), vr0, op1);\n+      else if (vr0 == NULL && vr1)\n+\treturn compare_range_with_value (opposite_comparison (TREE_CODE (cond)),\n+\t\t\t\t\t vr1, op0);\n+    }\n+\n+  /* Anything else cannot be computed statically.  */\n+  return NULL_TREE;\n+}\n+\n+\n+/* Visit conditional statement STMT.  If we can determine which edge\n+   will be taken out of STMT's basic block, record it in\n+   *TAKEN_EDGE_P and return SSA_PROP_INTERESTING.  Otherwise, return\n+   SSA_PROP_VARYING.  */\n+\n+static enum ssa_prop_result\n+vrp_visit_cond_stmt (tree stmt, edge *taken_edge_p)\n+{\n+  tree cond, val;\n+\n+  *taken_edge_p = NULL;\n+\n+  /* FIXME.  Handle SWITCH_EXPRs.  But first, the assert pass needs to\n+     add ASSERT_EXPRs for them.  */\n+  if (TREE_CODE (stmt) == SWITCH_EXPR)\n+    return SSA_PROP_VARYING;\n+\n+  cond = COND_EXPR_COND (stmt);\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      tree use;\n+      ssa_op_iter i;\n+\n+      fprintf (dump_file, \"\\nVisiting conditional with predicate: \");\n+      print_generic_expr (dump_file, cond, 0);\n+      fprintf (dump_file, \"\\nWith known ranges\\n\");\n+      \n+      FOR_EACH_SSA_TREE_OPERAND (use, stmt, i, SSA_OP_USE)\n+\t{\n+\t  fprintf (dump_file, \"\\t\");\n+\t  print_generic_expr (dump_file, use, 0);\n+\t  fprintf (dump_file, \": \");\n+\t  dump_value_range (dump_file, SSA_NAME_VALUE_RANGE (use));\n+\t}\n+\n+      fprintf (dump_file, \"\\n\");\n+    }\n+\n+  /* Compute the value of the predicate COND by checking the known\n+     ranges of each of its operands.  */\n+  val = vrp_evaluate_conditional (cond);\n+  if (val)\n+    *taken_edge_p = find_taken_edge (bb_for_stmt (stmt), val);\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"\\nPredicate evaluates to: \");\n+      if (val == NULL_TREE)\n+\tfprintf (dump_file, \"DON'T KNOW\\n\");\n+      else\n+\tprint_generic_stmt (dump_file, val, 0);\n+    }\n+\n+  return (*taken_edge_p) ? SSA_PROP_INTERESTING : SSA_PROP_VARYING;\n+}\n+\n+\n+/* Evaluate statement STMT.  If the statement produces a useful range,\n+   return SSA_PROP_INTERESTING and record the SSA name with the\n+   interesting range into *OUTPUT_P.\n+\n+   If STMT is a conditional branch and we can determine its truth\n+   value, the taken edge is recorded in *TAKEN_EDGE_P.\n+\n+   If STMT produces a varying value, return SSA_PROP_VARYING.  */\n+\n+static enum ssa_prop_result\n+vrp_visit_stmt (tree stmt, edge *taken_edge_p, tree *output_p)\n+{\n+  tree def;\n+  ssa_op_iter iter;\n+  stmt_ann_t ann;\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"\\nVisiting statement:\\n\");\n+      print_generic_stmt (dump_file, stmt, dump_flags);\n+      fprintf (dump_file, \"\\n\");\n+    }\n+\n+  ann = stmt_ann (stmt);\n+  if (TREE_CODE (stmt) == MODIFY_EXPR\n+      && NUM_V_MAY_DEFS (V_MAY_DEF_OPS (ann)) == 0\n+      && NUM_VUSES (VUSE_OPS (ann)) == 0\n+      && NUM_V_MUST_DEFS (V_MUST_DEF_OPS (ann)) == 0)\n+    return vrp_visit_assignment (stmt, output_p);\n+  else if (TREE_CODE (stmt) == COND_EXPR || TREE_CODE (stmt) == SWITCH_EXPR)\n+    return vrp_visit_cond_stmt (stmt, taken_edge_p);\n+\n+  /* All other statements produce nothing of interest for VRP, so mark\n+     their outputs varying and prevent further simulation.  */\n+  FOR_EACH_SSA_TREE_OPERAND (def, stmt, iter, SSA_OP_DEF)\n+    set_value_range (get_value_range (def), VR_VARYING, 0, 0);\n+\n+  return SSA_PROP_VARYING;\n+}\n+\n+\n+/* Meet operation for value ranges.  Given two value ranges VR0 and\n+   VR1, store in VR0 the result of meeting VR0 and VR1.\n+   \n+   The meeting rules are as follows:\n+\n+   1- If VR0 and VR1 have an empty intersection, set VR0 to VR_VARYING.\n+\n+   2- If VR0 and VR1 have a non-empty intersection, set VR0 to the\n+      union of VR0 and VR1.  */\n+\n+static void\n+vrp_meet (value_range *vr0, value_range *vr1)\n+{\n+  if (vr0->type == VR_UNDEFINED)\n+    {\n+      *vr0 = *vr1;\n+      return;\n+    }\n+\n+  if (vr1->type == VR_UNDEFINED)\n+    {\n+      /* Nothing to do.  VR0 already has the resulting range.  */\n+      return;\n+    }\n+\n+  if (vr0->type == VR_VARYING)\n+    {\n+      /* Nothing to do.  VR0 already has the resulting range.  */\n+      return;\n+    }\n+\n+  if (vr1->type == VR_VARYING)\n+    {\n+      *vr0 = *vr1;\n+      return;\n+    }\n+\n+  /* If either is a symbolic range, drop to VARYING.  */\n+  if (symbolic_range_p (vr0) || symbolic_range_p (vr1))\n+    {\n+      set_value_range (vr0, VR_VARYING, NULL_TREE, NULL_TREE);\n+      return;\n+    }\n+\n+  if (vr0->type == VR_RANGE && vr1->type == VR_RANGE)\n+    {\n+      /* If VR0 and VR1 have a non-empty intersection, compute the\n+\t union of both ranges.  */\n+      if (value_ranges_intersect_p (vr0, vr1))\n+\t{\n+\t  tree min, max;\n+\n+\t  min = vr0->min;\n+\t  max = vr0->max;\n+\n+\t  /* The lower limit of the new range is the minimum of the\n+\t     two ranges.  */\n+\t  if (compare_values (vr0->min, vr1->min) == 1)\n+\t    min = vr1->min;\n+\n+\t  /* The upper limit of the new range is the maximium of the\n+\t     two ranges.  */\n+\t  if (compare_values (vr0->max, vr1->max) == -1)\n+\t    max = vr1->max;\n+\n+\t  set_value_range (vr0, vr0->type, min, max);\n+\t}\n+      else\n+\t{\n+\t  /* The two ranges don't intersect, set the result to VR_VARYING.  */\n+\t  set_value_range (vr0, VR_VARYING, NULL_TREE, NULL_TREE);\n+\t}\n+    }\n+  else if (vr0->type == VR_ANTI_RANGE && vr1->type == VR_ANTI_RANGE)\n+    {\n+      /* Two anti-ranges meet only if they are both identical.  */\n+      if (compare_values (vr0->min, vr1->min) == 0\n+\t  && compare_values (vr0->max, vr1->max) == 0\n+\t  && compare_values (vr0->min, vr0->max) == 0)\n+\t/* Nothing to do.  */ ;\n+      else\n+\tset_value_range (vr0, VR_VARYING, NULL_TREE, NULL_TREE);\n+    }\n+  else if (vr0->type == VR_ANTI_RANGE || vr1->type == VR_ANTI_RANGE)\n+    {\n+      /* A range [VAL1, VAL2] and an anti-range ~[VAL3, VAL4] meet\n+\t only if the ranges have an empty intersection.  The result of\n+\t the meet operation is the anti-range.  */\n+      if (!value_ranges_intersect_p (vr0, vr1))\n+\t{\n+\t  if (vr1->type == VR_ANTI_RANGE)\n+\t    *vr0 = *vr1;\n+\t}\n+      else\n+\tset_value_range (vr0, VR_VARYING, NULL_TREE, NULL_TREE);\n+    }\n+  else\n+    gcc_unreachable ();\n+}\n+\n+      \n+/* Visit all arguments for PHI node PHI that flow through executable\n+   edges.  If a valid value range can be derived from all the incoming\n+   value ranges, set a new range for the LHS of PHI.  */\n+\n+static enum ssa_prop_result\n+vrp_visit_phi_node (tree phi)\n+{\n+  int i;\n+  tree lhs = PHI_RESULT (phi);\n+  value_range *lhs_vr = get_value_range (lhs);\n+  value_range vr_result = *lhs_vr;\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"\\nVisiting PHI node: \");\n+      print_generic_expr (dump_file, phi, dump_flags);\n+    }\n+\n+  for (i = 0; i < PHI_NUM_ARGS (phi); i++)\n+    {\n+      edge e = PHI_ARG_EDGE (phi, i);\n+\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  fprintf (dump_file,\n+\t      \"\\n    Argument #%d (%d -> %d %sexecutable)\\n\",\n+\t      i, e->src->index, e->dest->index,\n+\t      (e->flags & EDGE_EXECUTABLE) ? \"\" : \"not \");\n+\t}\n+\n+      if (e->flags & EDGE_EXECUTABLE)\n+\t{\n+\t  tree arg = PHI_ARG_DEF (phi, i);\n+\t  value_range vr_arg;\n+\n+\t  if (TREE_CODE (arg) == SSA_NAME)\n+\t    vr_arg = *(get_value_range (arg));\n+\t  else\n+\t    {\n+\t      vr_arg.type = VR_RANGE;\n+\t      vr_arg.min = arg;\n+\t      vr_arg.max = arg;\n+\t    }\n+\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    {\n+\t      fprintf (dump_file, \"\\t\");\n+\t      print_generic_expr (dump_file, arg, dump_flags);\n+\t      fprintf (dump_file, \"\\n\\tValue: \");\n+\t      dump_value_range (dump_file, &vr_arg);\n+\t      fprintf (dump_file, \"\\n\");\n+\t    }\n+\n+\t  vrp_meet (&vr_result, &vr_arg);\n+\n+\t  if (vr_result.type == VR_VARYING)\n+\t    break;\n+\t}\n+    }\n+\n+  if (vr_result.type == VR_VARYING)\n+    {\n+      set_value_range (lhs_vr, VR_VARYING, 0, 0);\n+      return SSA_PROP_VARYING;\n+    }\n+\n+  /* To prevent infinite iterations in the algorithm, derive ranges\n+     when the new value is slightly bigger or smaller than the\n+     previous one.  */\n+  if (lhs_vr->type == VR_RANGE)\n+    {\n+      if (!POINTER_TYPE_P (TREE_TYPE (lhs)))\n+\t{\n+\t  int cmp_min = compare_values (lhs_vr->min, vr_result.min);\n+\t  int cmp_max = compare_values (lhs_vr->max, vr_result.max);\n+\n+\t  /* If the new minimum is smaller or larger than the previous\n+\t     one, go all the way to -INF.  In the first case, to avoid\n+\t     iterating millions of times to reach -INF, and in the\n+\t     other case to avoid infinite bouncing between different\n+\t     minimums.  */\n+\t  if (cmp_min > 0 || cmp_min < 0)\n+\t    vr_result.min = TYPE_MIN_VALUE (TREE_TYPE (vr_result.min));\n+\n+\t  /* Similarly, if the new maximum is smaller or larger than\n+\t     the previous one, go all the way to +INF.  */\n+\t  if (cmp_max < 0 || cmp_max > 0)\n+\t    vr_result.max = TYPE_MAX_VALUE (TREE_TYPE (vr_result.max));\n+\n+\t  /* If we ended up with a (-INF, +INF) range, set it to\n+\t     VARYING.  */\n+\t  if (vr_result.min == TYPE_MIN_VALUE (TREE_TYPE (vr_result.min))\n+\t      && vr_result.max == TYPE_MAX_VALUE (TREE_TYPE (vr_result.max)))\n+\t    {\n+\t      set_value_range (lhs_vr, VR_VARYING, 0, 0);\n+\t      return SSA_PROP_VARYING;\n+\t    }\n+\t}\n+    }\n+\n+  /* If the new range is different than the previous value, keep\n+     iterating.  */\n+  if (update_value_range (lhs_vr, vr_result.type, vr_result.min, vr_result.max))\n+    return SSA_PROP_INTERESTING;\n+\n+  /* Nothing changed, don't add outgoing edges.  */\n+  return SSA_PROP_NOT_INTERESTING;\n+}\n+\n+\n+/* Traverse all the blocks folding conditionals with known ranges.  */\n+\n+static void\n+vrp_finalize (void)\n+{\n+  basic_block bb;\n+  int num_pred_folded = 0;\n+\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"\\nValue ranges after VRP:\\n\\n\");\n+      dump_all_value_ranges (dump_file);\n+      fprintf (dump_file, \"\\n\");\n+    }\n+\n+  FOR_EACH_BB (bb)\n+    {\n+      tree last = last_stmt (bb);\n+      if (last && TREE_CODE (last) == COND_EXPR)\n+\t{\n+\t  tree val = vrp_evaluate_conditional (COND_EXPR_COND (last));\n+\t  if (val)\n+\t    {\n+\t      if (dump_file)\n+\t\t{\n+\t\t  fprintf (dump_file, \"Folding predicate \");\n+\t\t  print_generic_expr (dump_file, COND_EXPR_COND (last), 0);\n+\t\t  fprintf (dump_file, \" to \");\n+\t\t  print_generic_expr (dump_file, val, 0);\n+\t\t  fprintf (dump_file, \"\\n\");\n+\t\t}\n+\n+\t      num_pred_folded++;\n+\t      COND_EXPR_COND (last) = val;\n+\t      update_stmt (last);\n+\t    }\n+\t}\n+    }\n+\n+  if (dump_file && (dump_flags & TDF_STATS))\n+    fprintf (dump_file, \"\\nNumber of predicates folded: %d\\n\\n\",\n+\t     num_pred_folded);\n+}\n+\n+\n+/* Main entry point to VRP (Value Range Propagation).  This pass is\n+   loosely based on J. R. C. Patterson, ``Accurate Static Branch\n+   Prediction by Value Range Propagation,'' in SIGPLAN Conference on\n+   Programming Language Design and Implementation, pp. 67-78, 1995.\n+   Also available at http://citeseer.ist.psu.edu/patterson95accurate.html\n+\n+   This is essentially an SSA-CCP pass modified to deal with ranges\n+   instead of constants.\n+\n+   TODO, the main difference between this pass and Patterson's is that\n+   we do not propagate edge probabilities.  We only compute whether\n+   edges can be taken or not.  That is, instead of having a spectrum\n+   of jump probabilities between 0 and 1, we only deal with 0, 1 and\n+   DON'T KNOW.  In the future, it may be worthwhile to propagate\n+   probabilities to aid branch prediction.  */\n+\n+static void\n+execute_vrp (void)\n+{\n+  insert_range_assertions ();\n+\n+  cfg_loops = loop_optimizer_init (NULL);\n+  if (cfg_loops)\n+    scev_initialize (cfg_loops);\n+\n+  if (vrp_initialize ())\n+    {\n+      ssa_propagate (vrp_visit_stmt, vrp_visit_phi_node);\n+      vrp_finalize ();\n+    }\n+\n+  if (cfg_loops)\n+    {\n+      scev_finalize ();\n+      loop_optimizer_finalize (cfg_loops, NULL);\n+      current_loops = NULL;\n+    }\n+\n+  remove_range_assertions ();\n+}\n+\n+static bool\n+gate_vrp (void)\n+{\n+  return flag_tree_vrp != 0;\n+}\n+\n+struct tree_opt_pass pass_vrp =\n+{\n+  \"vrp\",\t\t\t\t/* name */\n+  gate_vrp,\t\t\t\t/* gate */\n+  execute_vrp,\t\t\t\t/* execute */\n+  NULL,\t\t\t\t\t/* sub */\n+  NULL,\t\t\t\t\t/* next */\n+  0,\t\t\t\t\t/* static_pass_number */\n+  TV_TREE_VRP,\t\t\t\t/* tv_id */\n+  PROP_ssa | PROP_alias,\t\t/* properties_required */\n+  0,\t\t\t\t\t/* properties_provided */\n+  0,\t\t\t\t\t/* properties_destroyed */\n+  0,\t\t\t\t\t/* todo_flags_start */\n+  TODO_cleanup_cfg\n+    | TODO_ggc_collect\n+    | TODO_verify_ssa\n+    | TODO_dump_func\n+    | TODO_update_ssa,\t\t\t/* todo_flags_finish */\n+  0\t\t\t\t\t/* letter */\n+};"}, {"sha": "3806f5b0043dcbe224e430a5aa5d74acb5c1ffc7", "filename": "gcc/tree.def", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=0bca51f080dfff5e943b1f1775d874a73bbc441a", "patch": "@@ -899,6 +899,20 @@ DEFTREECODE (STATEMENT_LIST, \"statement_list\", tcc_exceptional, 0)\n    the same value, they will be assigned the same value handle.  */\n DEFTREECODE (VALUE_HANDLE, \"value_handle\", tcc_exceptional, 0)\n \n+/* Predicate assertion.  Artificial expression generated by the optimizers\n+   to keep track of predicate values.  This expression may only appear on\n+   the RHS of assignments.\n+   \n+   Given X = ASSERT_EXPR <Y, EXPR>, the optimizers can infer\n+   two things:\n+\n+   \t1- X is a copy of Y.\n+\t2- EXPR is a GIMPLE conditional expression (as defined by\n+\t   is_gimple_condexpr) and is known to be true.\n+\n+   The type of the expression is the same as Y.  */\n+DEFTREECODE (ASSERT_EXPR, \"assert_expr\", tcc_expression, 2)\n+\n /* Base class information. Holds information about a class as a\n    baseclass of itself or another class.  */\n DEFTREECODE (TREE_BINFO, \"tree_binfo\", tcc_exceptional, 0)"}, {"sha": "40cf7397c823888ec8d51d1c3666d2f8c8d0563e", "filename": "gcc/tree.h", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bca51f080dfff5e943b1f1775d874a73bbc441a/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=0bca51f080dfff5e943b1f1775d874a73bbc441a", "patch": "@@ -1283,6 +1283,10 @@ struct tree_vec GTY(())\n #define OBJ_TYPE_REF_OBJECT(NODE) TREE_OPERAND (OBJ_TYPE_REF_CHECK (NODE), 1)\n #define OBJ_TYPE_REF_TOKEN(NODE)  TREE_OPERAND (OBJ_TYPE_REF_CHECK (NODE), 2)\n \n+/* ASSERT_EXPR accessors.  */\n+#define ASSERT_EXPR_VAR(NODE)\tTREE_OPERAND (ASSERT_EXPR_CHECK (NODE), 0)\n+#define ASSERT_EXPR_COND(NODE)\tTREE_OPERAND (ASSERT_EXPR_CHECK (NODE), 1)\n+\n struct tree_exp GTY(())\n {\n   struct tree_common common;\n@@ -1329,12 +1333,17 @@ struct tree_exp GTY(())\n #define SSA_NAME_VALUE(N) \\\n    SSA_NAME_CHECK (N)->ssa_name.value_handle\n \n+/* Range information for SSA_NAMEs.  */\n+#define SSA_NAME_VALUE_RANGE(N) \\\n+    SSA_NAME_CHECK (N)->ssa_name.value_range\n+\n /* Auxiliary pass-specific data.  */\n #define SSA_NAME_AUX(N) \\\n    SSA_NAME_CHECK (N)->ssa_name.aux\n \n #ifndef _TREE_FLOW_H\n struct ptr_info_def;\n+struct value_range_def;\n #endif\n \n \n@@ -1372,6 +1381,9 @@ struct tree_ssa_name GTY(())\n      as well.  */\n   tree value_handle;\n \n+  /* Value range information.  */\n+  struct value_range_def *value_range;\n+\n   /* Auxiliary information stored with the ssa name.  */\n   PTR GTY((skip)) aux;\n \n@@ -1395,9 +1407,6 @@ struct tree_ssa_name GTY(())\n    the link to the next PHI is in PHI_CHAIN.  */\n #define PHI_CHAIN(NODE)\t\tTREE_CHAIN (PHI_NODE_CHECK (NODE))\n \n-/* Nonzero if the PHI node was rewritten by a previous pass through the\n-   SSA renamer.  */\n-#define PHI_REWRITTEN(NODE)\t\tPHI_NODE_CHECK (NODE)->phi.rewritten\n #define PHI_NUM_ARGS(NODE)\t\tPHI_NODE_CHECK (NODE)->phi.num_args\n #define PHI_ARG_CAPACITY(NODE)\t\tPHI_NODE_CHECK (NODE)->phi.capacity\n #define PHI_ARG_ELT(NODE, I)\t\tPHI_NODE_ELT_CHECK (NODE, I)\n@@ -1422,10 +1431,6 @@ struct tree_phi_node GTY(())\n   int num_args;\n   int capacity;\n \n-  /* Nonzero if the PHI node was rewritten by a previous pass through the\n-     SSA renamer.  */\n-  int rewritten;\n-\n   /* Basic block to that the phi node belongs.  */\n   struct basic_block_def *bb;\n "}]}