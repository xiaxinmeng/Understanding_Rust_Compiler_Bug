{"sha": "3548abca0218168da1bb9f8cace29282a7495fbf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzU0OGFiY2EwMjE4MTY4ZGExYmI5ZjhjYWNlMjkyODJhNzQ5NWZiZg==", "commit": {"author": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2015-02-03T20:24:13Z"}, "committer": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2015-02-03T20:24:13Z"}, "message": "re PR target/64660 ([SH] Convert atomic_fetch_<op> to atomic_<op>_fetch)\n\ngcc/\n\tPR target/64660\n\t* config/sh/sync.md (atomic_<fetchop_name><mode>_hard,\n\tatomic_not<mode>_hard, atomic_<fetchop_name><mode>_soft_tcb,\n\tatomic_not<mode>_soft_tcb, atomic_nand<mode>_hard,\n\tatomic_nand<mode>_soft_tcb): New insns.\n\t(atomic_fetch_<fetchop_name>si_hard): Convert to insn_and_split.\n\tSplit into atomic_<fetchop_name>_fetchsi_hard if operands[0] is unused.\n\t(define_insn \"atomic_fetch_notsi_hard): Convert to insn_and_split.\n\tSplit into atomic_not_fetchsi_hard if operands[0] is unused.\n\t(atomic_fetch_<fetchop_name><mode>_hard): Convert to insn_and_split.\n\tSplit into atomic_<fetchop_name><mode>_hard if operands[0] is unused.\n\t(atomic_fetch_not<mode>_hard): Convert to insn_and_split.  Split into\n\tatomic_not<mode>_hard if operands[0] is unused.\n\t(atomic_fetch_<fetchop_name><mode>_soft_gusa): Convert to\n\tinsn_and_split.  Split into atomic_<fetchop_name>_fetch<mode>_soft_gusa\n\tif operands[0] is unused.\n\t(atomic_fetch_not<mode>_soft_gusa): Convert to insn_and_split.  Split\n\tinto atomic_not_fetch<mode>_soft_gusa if operands[0] is unused.\n\t(atomic_fetch_<fetchop_name><mode>_soft_tcb): Convert to insn_and_split.\n\tSplit into atomic_<fetchop_name><mode>_soft_tcb if operands[0] is\n\tunused.\n\t(atomic_fetch_not<mode>_soft_tcb): Convert to insn_and_split.  Split\n\tinto atomic_not<mode>_soft_tcb if operands[0] is unused.\n\t(atomic_fetch_<fetchop_name><mode>_soft_imask): Convert to\n\tinsn_and_split.  Split into atomic_<fetchop_name>_fetch<mode>_soft_imask\n\tif operands[0] is unused.\n\t(atomic_fetch_not<mode>_soft_imask): Convert to insn_and_split.  Split\n\tinto atomic_not_fetch<mode>_soft_imask is operands[0] is unused.\n\t(atomic_fetch_nandsi_hard): Convert to insn_and_split.  Split into\n\tatomic_nand_fetchsi_hard if operands[0] is unused.\n\t(atomic_fetch_nand<mode>_hard): Convert to insn_and_split.  Split into\n\tatomic_nand<mode>_hard if operands[0] is unused.\n\t(atomic_fetch_nand<mode>_soft_gusa): Convert to insn_and_split.  Split\n\tinto atomic_nand_fetch<mode>_soft_gusa if operands[0] is unused.\n\t(atomic_fetch_nand<mode>_soft_tcb): Convert to insn_and_split.  Split\n\tinto atomic_nand<mode>_soft_tcb if operands[0] is unused.\n\t(atomic_fetch_nand<mode>_soft_imask): Convert to insn_and_split.  Split\n\tinto atomic_nand_fetch<mode>_soft_imask if operands[0] is unused.\n\t(atomic_<fetchop_name>_fetch<mode>_hard): Convert to insn_and_split.\n\tSplit into atomic_<fetchop_name><mode>_hard if operands[0] is unused.\n\t(atomic_not_fetch<mode>_hard): Convert to insn_and_split.  Split into\n\tatomic_not<mode>_hard if operands[0] is unused.\n\t(atomic_<fetchop_name>_fetch<mode>_soft_tcb): Convert to insn_and_split.\n\tSplit into atomic_<fetchop_name><mode>_soft_tcb if operands[0] is\n\tunused.\n\t(atomic_not_fetch<mode>_soft_tcb): Convert to insn_and_split.  Split\n\tinto atomic_not<mode>_soft_tcb if operands[0] is unused.\n\t(atomic_nand_fetch<mode>_hard): Convert to insn_and_split.  Split into\n\tatomic_nand<mode>_hard if operands[0] is unused.\n\t(atomic_nand_fetch<mode>_soft_tcb): Convert to insn_and_split.  Split\n\tinto atomic_nand<mode>_soft_tcb if operands[0] is unused.\n\ngcc/testsuite/\n\tPR target/64660\n\t* gcc.target/sh/pr64660-0.h: New.\n\t* gcc.target/sh/pr64660-1.c: New.\n\t* gcc.target/sh/pr64660-2.c: New.\n\t* gcc.target/sh/pr64660-3.c: New.\n\t* gcc.target/sh/pr64660-4.c: New.\n\nFrom-SVN: r220376", "tree": {"sha": "c47a87d39f9c500a700aef5ef93d27e45d2c70ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c47a87d39f9c500a700aef5ef93d27e45d2c70ec"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3548abca0218168da1bb9f8cace29282a7495fbf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3548abca0218168da1bb9f8cace29282a7495fbf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3548abca0218168da1bb9f8cace29282a7495fbf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3548abca0218168da1bb9f8cace29282a7495fbf/comments", "author": null, "committer": null, "parents": [{"sha": "0ed4f01761116587a0aac7faae8512d6e73eeed0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ed4f01761116587a0aac7faae8512d6e73eeed0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ed4f01761116587a0aac7faae8512d6e73eeed0"}], "stats": {"total": 494, "additions": 473, "deletions": 21}, "files": [{"sha": "98c968ecc20cab51b210a1ee725afa87d5aa26e2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3548abca0218168da1bb9f8cace29282a7495fbf/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3548abca0218168da1bb9f8cace29282a7495fbf/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3548abca0218168da1bb9f8cace29282a7495fbf", "patch": "@@ -1,3 +1,57 @@\n+2015-02-03  Oleg Endo  <olegendo@gcc.gnu.org>\n+\n+\tPR target/64660\n+\t* config/sh/sync.md (atomic_<fetchop_name><mode>_hard,\n+\tatomic_not<mode>_hard, atomic_<fetchop_name><mode>_soft_tcb,\n+\tatomic_not<mode>_soft_tcb, atomic_nand<mode>_hard,\n+\tatomic_nand<mode>_soft_tcb): New insns.\n+\t(atomic_fetch_<fetchop_name>si_hard): Convert to insn_and_split.\n+\tSplit into atomic_<fetchop_name>_fetchsi_hard if operands[0] is unused.\n+\t(define_insn \"atomic_fetch_notsi_hard): Convert to insn_and_split.\n+\tSplit into atomic_not_fetchsi_hard if operands[0] is unused.\n+\t(atomic_fetch_<fetchop_name><mode>_hard): Convert to insn_and_split.\n+\tSplit into atomic_<fetchop_name><mode>_hard if operands[0] is unused.\n+\t(atomic_fetch_not<mode>_hard): Convert to insn_and_split.  Split into\n+\tatomic_not<mode>_hard if operands[0] is unused.\n+\t(atomic_fetch_<fetchop_name><mode>_soft_gusa): Convert to\n+\tinsn_and_split.  Split into atomic_<fetchop_name>_fetch<mode>_soft_gusa\n+\tif operands[0] is unused.\n+\t(atomic_fetch_not<mode>_soft_gusa): Convert to insn_and_split.  Split\n+\tinto atomic_not_fetch<mode>_soft_gusa if operands[0] is unused.\n+\t(atomic_fetch_<fetchop_name><mode>_soft_tcb): Convert to insn_and_split.\n+\tSplit into atomic_<fetchop_name><mode>_soft_tcb if operands[0] is\n+\tunused.\n+\t(atomic_fetch_not<mode>_soft_tcb): Convert to insn_and_split.  Split\n+\tinto atomic_not<mode>_soft_tcb if operands[0] is unused.\n+\t(atomic_fetch_<fetchop_name><mode>_soft_imask): Convert to\n+\tinsn_and_split.  Split into atomic_<fetchop_name>_fetch<mode>_soft_imask\n+\tif operands[0] is unused.\n+\t(atomic_fetch_not<mode>_soft_imask): Convert to insn_and_split.  Split\n+\tinto atomic_not_fetch<mode>_soft_imask is operands[0] is unused.\n+\t(atomic_fetch_nandsi_hard): Convert to insn_and_split.  Split into\n+\tatomic_nand_fetchsi_hard if operands[0] is unused.\n+\t(atomic_fetch_nand<mode>_hard): Convert to insn_and_split.  Split into\n+\tatomic_nand<mode>_hard if operands[0] is unused.\n+\t(atomic_fetch_nand<mode>_soft_gusa): Convert to insn_and_split.  Split\n+\tinto atomic_nand_fetch<mode>_soft_gusa if operands[0] is unused.\n+\t(atomic_fetch_nand<mode>_soft_tcb): Convert to insn_and_split.  Split\n+\tinto atomic_nand<mode>_soft_tcb if operands[0] is unused.\n+\t(atomic_fetch_nand<mode>_soft_imask): Convert to insn_and_split.  Split\n+\tinto atomic_nand_fetch<mode>_soft_imask if operands[0] is unused.\n+\t(atomic_<fetchop_name>_fetch<mode>_hard): Convert to insn_and_split.\n+\tSplit into atomic_<fetchop_name><mode>_hard if operands[0] is unused.\n+\t(atomic_not_fetch<mode>_hard): Convert to insn_and_split.  Split into\n+\tatomic_not<mode>_hard if operands[0] is unused.\n+\t(atomic_<fetchop_name>_fetch<mode>_soft_tcb): Convert to insn_and_split.\n+\tSplit into atomic_<fetchop_name><mode>_soft_tcb if operands[0] is\n+\tunused.\n+\t(atomic_not_fetch<mode>_soft_tcb): Convert to insn_and_split.  Split\n+\tinto atomic_not<mode>_soft_tcb if operands[0] is unused.\n+\t(atomic_nand_fetch<mode>_hard): Convert to insn_and_split.  Split into\n+\tatomic_nand<mode>_hard if operands[0] is unused.\n+\t(atomic_nand_fetch<mode>_soft_tcb): Convert to insn_and_split.  Split\n+\tinto atomic_nand<mode>_soft_tcb if operands[0] is unused.\n+\n 2015-02-03  David Malcolm  <dmalcolm@redhat.com>\n \n \tPR jit/64810"}, {"sha": "d1413c595a69838db7b6aa5ccb610f51b96ca20c", "filename": "gcc/config/sh/sync.md", "status": "modified", "additions": 312, "deletions": 21, "changes": 333, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3548abca0218168da1bb9f8cace29282a7495fbf/gcc%2Fconfig%2Fsh%2Fsync.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3548abca0218168da1bb9f8cace29282a7495fbf/gcc%2Fconfig%2Fsh%2Fsync.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsync.md?ref=3548abca0218168da1bb9f8cace29282a7495fbf", "patch": "@@ -651,7 +651,7 @@\n   DONE;\n })\n \n-(define_insn \"atomic_fetch_<fetchop_name>si_hard\"\n+(define_insn_and_split \"atomic_fetch_<fetchop_name>si_hard\"\n   [(set (match_operand:SI 0 \"arith_reg_dest\" \"=&r\")\n \t(mem:SI (match_operand:SI 1 \"arith_reg_operand\" \"r\")))\n    (set (mem:SI (match_dup 1))\n@@ -670,11 +670,18 @@\n \t \"\t<fetchop_name>\t%2,r0\"\t\"\\n\"\n \t \"\tmovco.l\tr0,@%1\"\t\t\"\\n\"\n \t \"\tbf\t0b\";\n+}\n+  \"&& can_create_pseudo_p () && optimize\n+   && sh_reg_dead_or_unused_after_insn (insn, REGNO (operands[0]))\"\n+  [(const_int 0)]\n+{\n+  emit_insn (gen_atomic_<fetchop_name>_fetchsi_hard (gen_reg_rtx (SImode),\n+\t\t\t\t\t\t     operands[1], operands[2]));\n }\n   [(set_attr \"length\" \"10\")])\n \n ;; Combine pattern for xor (val, -1) / nand (val, -1).\n-(define_insn \"atomic_fetch_notsi_hard\"\n+(define_insn_and_split \"atomic_fetch_notsi_hard\"\n   [(set (match_operand:SI 0 \"arith_reg_dest\" \"=&r\")\n \t(mem:SI (match_operand:SI 1 \"arith_reg_operand\" \"r\")))\n    (set (mem:SI (match_dup 1))\n@@ -689,10 +696,16 @@\n \t \"\tnot\tr0,r0\"\t\t\"\\n\"\n \t \"\tmovco.l\tr0,@%1\"\t\t\"\\n\"\n \t \"\tbf\t0b\";\n+}\n+  \"&& can_create_pseudo_p () && optimize\n+   && sh_reg_dead_or_unused_after_insn (insn, REGNO (operands[0]))\"\n+  [(const_int 0)]\n+{\n+  emit_insn (gen_atomic_not_fetchsi_hard (gen_reg_rtx (SImode), operands[1]));\n }\n   [(set_attr \"length\" \"10\")])\n \n-(define_insn \"atomic_fetch_<fetchop_name><mode>_hard\"\n+(define_insn_and_split \"atomic_fetch_<fetchop_name><mode>_hard\"\n   [(set (match_operand:QIHI 0 \"arith_reg_dest\" \"=&r\")\n \t(mem:QIHI (match_operand:SI 1 \"arith_reg_operand\" \"r\")))\n    (set (mem:QIHI (match_dup 1))\n@@ -721,11 +734,46 @@\n \t \"\tmov.l\t@r15+,r0\"\t\t\"\\n\"\n \t \"\tmovco.l\tr0,@%3\"\t\t\t\"\\n\"\n \t \"\tbf\t0b\";\n+}\n+  \"&& can_create_pseudo_p () && optimize\n+   && sh_reg_dead_or_unused_after_insn (insn, REGNO (operands[0]))\"\n+  [(const_int 0)]\n+{\n+  emit_insn (gen_atomic_<fetchop_name><mode>_hard (operands[1], operands[2]));\n }\n   [(set_attr \"length\" \"28\")])\n \n+(define_insn \"atomic_<fetchop_name><mode>_hard\"\n+  [(set (mem:QIHI (match_operand:SI 0 \"arith_reg_operand\" \"r\"))\n+\t(unspec:QIHI\n+\t  [(FETCHOP:QIHI (mem:QIHI (match_dup 0))\n+\t\t\t (match_operand:QIHI 1 \"<fetchop_predicate_1>\"\n+\t\t\t\t\t       \"<fetchop_constraint_1_llcs>\"))]\n+\t  UNSPEC_ATOMIC))\n+   (set (reg:SI T_REG) (const_int 1))\n+   (clobber (reg:SI R0_REG))\n+   (clobber (match_scratch:SI 2 \"=&r\"))\n+   (clobber (match_scratch:SI 3 \"=0\"))]\n+  \"TARGET_ATOMIC_HARD_LLCS\"\n+{\n+  return \"\\r\tmov\t#-4,%2\"\t\t\t\"\\n\"\n+\t \"\tand\t%0,%2\"\t\t\t\"\\n\"\n+\t \"\txor\t%2,%0\"\t\t\t\"\\n\"\n+\t \"\tadd\tr15,%0\"\t\t\t\"\\n\"\n+\t \"\tadd\t#-4,%0\"\t\t\t\"\\n\"\n+\t \"0:\tmovli.l\t@%2,r0\"\t\t\t\"\\n\"\n+\t \"\tmov.l\tr0,@-r15\"\t\t\"\\n\"\n+\t \"\tmov.<bw>\t@%0,r0\"\t\t\"\\n\"\n+\t \"\t<fetchop_name>\t%1,r0\"\t\t\"\\n\"\n+\t \"\tmov.<bw>\tr0,@%0\"\t\t\"\\n\"\n+\t \"\tmov.l\t@r15+,r0\"\t\t\"\\n\"\n+\t \"\tmovco.l\tr0,@%2\"\t\t\t\"\\n\"\n+\t \"\tbf\t0b\";\n+}\n+  [(set_attr \"length\" \"26\")])\n+\n ;; Combine pattern for xor (val, -1) / nand (val, -1).\n-(define_insn \"atomic_fetch_not<mode>_hard\"\n+(define_insn_and_split \"atomic_fetch_not<mode>_hard\"\n   [(set (match_operand:QIHI 0 \"arith_reg_dest\" \"=&r\")\n \t(mem:QIHI (match_operand:SI 1 \"arith_reg_operand\" \"r\")))\n    (set (mem:QIHI (match_dup 1))\n@@ -749,10 +797,41 @@\n \t \"\tmov.l\t@r15+,r0\"\t\t\"\\n\"\n \t \"\tmovco.l\tr0,@%2\"\t\t\t\"\\n\"\n \t \"\tbf\t0b\";\n+}\n+  \"&& can_create_pseudo_p () && optimize\n+   && sh_reg_dead_or_unused_after_insn (insn, REGNO (operands[0]))\"\n+  [(const_int 0)]\n+{\n+  emit_insn (gen_atomic_not<mode>_hard (operands[1]));\n+}\n+  [(set_attr \"length\" \"26\")])\n+\n+(define_insn \"atomic_not<mode>_hard\"\n+  [(set (mem:QIHI (match_operand:SI 0 \"arith_reg_operand\" \"r\"))\n+\t(unspec:QIHI [(not:QIHI (mem:QIHI (match_dup 0)))] UNSPEC_ATOMIC))\n+   (set (reg:SI T_REG) (const_int 1))\n+   (clobber (reg:SI R0_REG))\n+   (clobber (match_scratch:SI 1 \"=&r\"))\n+   (clobber (match_scratch:SI 2 \"=0\"))]\n+  \"TARGET_ATOMIC_HARD_LLCS\"\n+{\n+  return \"\\r\tmov\t#-4,%1\"\t\t\t\"\\n\"\n+\t \"\tand\t%0,%1\"\t\t\t\"\\n\"\n+\t \"\txor\t%1,%0\"\t\t\t\"\\n\"\n+\t \"\tadd\tr15,%0\"\t\t\t\"\\n\"\n+\t \"\tadd\t#-4,%0\"\t\t\t\"\\n\"\n+\t \"0:\tmovli.l\t@%1,r0\"\t\t\t\"\\n\"\n+\t \"\tmov.l\tr0,@-r15\"\t\t\"\\n\"\n+\t \"\tmov.<bw>\t@%0,r0\"\t\t\"\\n\"\n+\t \"\tnot\tr0,r0\"\t\t\t\"\\n\"\n+\t \"\tmov.<bw>\tr0,@%0\"\t\t\"\\n\"\n+\t \"\tmov.l\t@r15+,r0\"\t\t\"\\n\"\n+\t \"\tmovco.l\tr0,@%1\"\t\t\t\"\\n\"\n+\t \"\tbf\t0b\";\n }\n   [(set_attr \"length\" \"26\")])\n \n-(define_insn \"atomic_fetch_<fetchop_name><mode>_soft_gusa\"\n+(define_insn_and_split \"atomic_fetch_<fetchop_name><mode>_soft_gusa\"\n   [(set (match_operand:QIHISI 0 \"arith_reg_dest\" \"=&u\")\n \t(mem:QIHISI (match_operand:SI 1 \"arith_reg_operand\" \"u\")))\n    (set (mem:QIHISI (match_dup 1))\n@@ -776,11 +855,18 @@\n \t \"\t<fetchop_name>\t%2,%3\"\t\t\"\\n\"\n \t \"\tmov.<bwl>\t%3,@%1\"\t\t\"\\n\"\n \t \"1:\tmov\tr1,r15\";\n+}\n+  \"&& can_create_pseudo_p () && optimize\n+   && sh_reg_dead_or_unused_after_insn (insn, REGNO (operands[0]))\"\n+  [(const_int 0)]\n+{\n+  emit_insn (gen_atomic_<fetchop_name>_fetch<mode>_soft_gusa (\n+\t\tgen_reg_rtx (<MODE>mode), operands[1], operands[2]));\n }\n   [(set_attr \"length\" \"18\")])\n \n ;; Combine pattern for xor (val, -1) / nand (val, -1).\n-(define_insn \"atomic_fetch_not<mode>_soft_gusa\"\n+(define_insn_and_split \"atomic_fetch_not<mode>_soft_gusa\"\n   [(set (match_operand:QIHISI 0 \"arith_reg_dest\" \"=&u\")\n \t(mem:QIHISI (match_operand:SI 1 \"arith_reg_operand\" \"u\")))\n    (set (mem:QIHISI (match_dup 1))\n@@ -798,10 +884,17 @@\n \t \"\tnot\t%0,%2\"\t\t\t\"\\n\"\n \t \"\tmov.<bwl>\t%2,@%1\"\t\t\"\\n\"\n \t \"1:\tmov\tr1,r15\";\n+}\n+  \"&& can_create_pseudo_p () && optimize\n+   && sh_reg_dead_or_unused_after_insn (insn, REGNO (operands[0]))\"\n+  [(const_int 0)]\n+{\n+  emit_insn (gen_atomic_not_fetch<mode>_soft_gusa (gen_reg_rtx (<MODE>mode),\n+\t\t\t\t\t\t   operands[1]));\n }\n   [(set_attr \"length\" \"16\")])\n \n-(define_insn \"atomic_fetch_<fetchop_name><mode>_soft_tcb\"\n+(define_insn_and_split \"atomic_fetch_<fetchop_name><mode>_soft_tcb\"\n   [(set (match_operand:QIHISI 0 \"arith_reg_dest\" \"=&r\")\n \t(mem:QIHISI (match_operand:SI 1 \"arith_reg_operand\" \"r\")))\n    (set (mem:QIHISI (match_dup 1))\n@@ -826,11 +919,43 @@\n \t \"\tmov.<bwl>\tr0,@%1\"\t\t\"\\n\"\n \t \"1:\tmov\t#0,r0\"\t\t\t\"\\n\"\n \t \"\tmov.l\tr0,@(%O3,gbr)\";\n+}\n+  \"&& can_create_pseudo_p () && optimize\n+   && sh_reg_dead_or_unused_after_insn (insn, REGNO (operands[0]))\"\n+  [(const_int 0)]\n+{\n+  emit_insn (gen_atomic_<fetchop_name><mode>_soft_tcb (\n+\t\t\t\t\toperands[1], operands[2], operands[3]));\n }\n   [(set_attr \"length\" \"20\")])\n \n+(define_insn \"atomic_<fetchop_name><mode>_soft_tcb\"\n+  [(set (mem:QIHISI (match_operand:SI 0 \"arith_reg_operand\" \"r\"))\n+\t(unspec:QIHISI\n+\t  [(FETCHOP:QIHISI\n+\t\t(mem:QIHISI (match_dup 0))\n+\t\t(match_operand:QIHISI 1 \"<fetchop_predicate_1>\"\n+\t\t\t\t\t\"<fetchop_constraint_1_tcb>\"))]\n+\t  UNSPEC_ATOMIC))\n+   (use (match_operand:SI 2 \"gbr_displacement\"))\n+   (clobber (reg:SI R0_REG))\n+   (clobber (reg:SI R1_REG))]\n+  \"TARGET_ATOMIC_SOFT_TCB\"\n+{\n+  return \"\\r\tmova\t1f,r0\"\t\t\t\"\\n\"\n+\t \"\tmov\t#(0f-1f),r1\"\t\t\"\\n\"\n+\t \"\t.align 2\"\t\t\t\"\\n\"\n+\t \"\tmov.l\tr0,@(%O2,gbr)\"\t\t\"\\n\"\n+\t \"0:\tmov.<bwl>\t@%0,r0\"\t\t\"\\n\"\n+\t \"\t<fetchop_name>\t%1,r0\"\t\t\"\\n\"\n+\t \"\tmov.<bwl>\tr0,@%0\"\t\t\"\\n\"\n+\t \"1:\tmov\t#0,r0\"\t\t\t\"\\n\"\n+\t \"\tmov.l\tr0,@(%O2,gbr)\";\n+}\n+  [(set_attr \"length\" \"18\")])\n+\n ;; Combine pattern for xor (val, -1) / nand (val, -1).\n-(define_insn \"atomic_fetch_not<mode>_soft_tcb\"\n+(define_insn_and_split \"atomic_fetch_not<mode>_soft_tcb\"\n   [(set (match_operand:QIHISI 0 \"arith_reg_dest\" \"=&r\")\n \t(mem:QIHISI (match_operand:SI 1 \"arith_reg_operand\" \"r\")))\n    (set (mem:QIHISI (match_dup 1))\n@@ -850,10 +975,36 @@\n \t \"\tmov.<bwl>\tr0,@%1\"\t\t\"\\n\"\n \t \"1:\tmov\t#0,r0\"\t\t\t\"\\n\"\n \t \"\tmov.l\tr0,@(%O2,gbr)\";\n+}\n+  \"&& can_create_pseudo_p () && optimize\n+   && sh_reg_dead_or_unused_after_insn (insn, REGNO (operands[0]))\"\n+  [(const_int 0)]\n+{\n+  emit_insn (gen_atomic_not<mode>_soft_tcb (operands[1], operands[2]));\n }\n   [(set_attr \"length\" \"20\")])\n \n-(define_insn \"atomic_fetch_<fetchop_name><mode>_soft_imask\"\n+(define_insn \"atomic_not<mode>_soft_tcb\"\n+  [(set (mem:QIHISI (match_operand:SI 0 \"arith_reg_operand\" \"r\"))\n+\t(unspec:QIHISI [(not:QIHISI (mem:QIHISI (match_dup 0)))] UNSPEC_ATOMIC))\n+   (use (match_operand:SI 1 \"gbr_displacement\"))\n+   (clobber (reg:SI R0_REG))\n+   (clobber (reg:SI R1_REG))]\n+  \"TARGET_ATOMIC_SOFT_TCB\"\n+{\n+  return \"\\r\tmova\t1f,r0\"\t\t\t\"\\n\"\n+\t \"\tmov\t#(0f-1f),r1\"\t\t\"\\n\"\n+\t \"\t.align 2\"\t\t\t\"\\n\"\n+\t \"\tmov.l\tr0,@(%O1,gbr)\"\t\t\"\\n\"\n+\t \"0:\tmov.<bwl>\t@%0,r0\"\t\t\"\\n\"\n+\t \"\tnot\tr0,r0\"\t\t\t\"\\n\"\n+\t \"\tmov.<bwl>\tr0,@%0\"\t\t\"\\n\"\n+\t \"1:\tmov\t#0,r0\"\t\t\t\"\\n\"\n+\t \"\tmov.l\tr0,@(%O1,gbr)\";\n+}\n+  [(set_attr \"length\" \"18\")])\n+\n+(define_insn_and_split \"atomic_fetch_<fetchop_name><mode>_soft_imask\"\n   [(set (match_operand:QIHISI 0 \"arith_reg_dest\" \"=&r\")\n \t(mem:QIHISI (match_operand:SI 1 \"arith_reg_operand\" \"r\")))\n    (set (mem:QIHISI (match_dup 1))\n@@ -876,11 +1027,18 @@\n \t \"\t<fetchop_name>\t%2,r0\"\t\t\"\\n\"\n \t \"\tmov.<bwl>\tr0,@%1\"\t\t\"\\n\"\n \t \"\tldc\t%3,sr\";\n+}\n+  \"&& can_create_pseudo_p () && optimize\n+   && sh_reg_dead_or_unused_after_insn (insn, REGNO (operands[0]))\"\n+  [(const_int 0)]\n+{\n+  emit_insn (gen_atomic_<fetchop_name>_fetch<mode>_soft_imask (\n+\t\t\tgen_reg_rtx (<MODE>mode), operands[1], operands[2]));\n }\n   [(set_attr \"length\" \"18\")])\n \n ;; Combine pattern for xor (val, -1) / nand (val, -1).\n-(define_insn \"atomic_fetch_not<mode>_soft_imask\"\n+(define_insn_and_split \"atomic_fetch_not<mode>_soft_imask\"\n   [(set (match_operand:QIHISI 0 \"arith_reg_dest\" \"=&r\")\n \t(mem:QIHISI (match_operand:SI 1 \"arith_reg_operand\" \"r\")))\n    (set (mem:QIHISI (match_dup 1))\n@@ -898,6 +1056,13 @@\n \t \"\tnot\tr0,r0\"\t\t\t\"\\n\"\n \t \"\tmov.<bwl>\tr0,@%1\"\t\t\"\\n\"\n \t \"\tldc\t%2,sr\";\n+}\n+  \"&& can_create_pseudo_p () && optimize\n+   && sh_reg_dead_or_unused_after_insn (insn, REGNO (operands[0]))\"\n+  [(const_int 0)]\n+{\n+  emit_insn (gen_atomic_not_fetch<mode>_soft_imask (gen_reg_rtx (<MODE>mode),\n+\t\t\t\t\t\t    operands[1]));\n }\n   [(set_attr \"length\" \"18\")])\n \n@@ -942,7 +1107,7 @@\n   DONE;\n })\n \n-(define_insn \"atomic_fetch_nandsi_hard\"\n+(define_insn_and_split \"atomic_fetch_nandsi_hard\"\n   [(set (match_operand:SI 0 \"arith_reg_dest\" \"=&r\")\n \t(mem:SI (match_operand:SI 1 \"arith_reg_operand\" \"r\")))\n    (set (mem:SI (match_dup 1))\n@@ -961,10 +1126,17 @@\n \t \"\tnot\tr0,r0\"\t\t\"\\n\"\n \t \"\tmovco.l\tr0,@%1\"\t\t\"\\n\"\n \t \"\tbf\t0b\";\n+}\n+  \"&& can_create_pseudo_p () && optimize\n+   && sh_reg_dead_or_unused_after_insn (insn, REGNO (operands[0]))\"\n+  [(const_int 0)]\n+{\n+  emit_insn (gen_atomic_nand_fetchsi_hard (gen_reg_rtx (SImode), operands[1],\n+\t\t\t\t\t   operands[2]));\n }\n   [(set_attr \"length\" \"12\")])\n \n-(define_insn \"atomic_fetch_nand<mode>_hard\"\n+(define_insn_and_split \"atomic_fetch_nand<mode>_hard\"\n   [(set (match_operand:QIHI 0 \"arith_reg_dest\" \"=&r\")\n \t(mem:QIHI (match_operand:SI 1 \"arith_reg_operand\" \"r\")))\n    (set (mem:QIHI (match_dup 1))\n@@ -993,10 +1165,45 @@\n \t \"\tmov.l\t@r15+,r0\"\t\t\"\\n\"\n \t \"\tmovco.l\tr0,@%3\"\t\t\t\"\\n\"\n \t \"\tbf\t0b\";\n+}\n+  \"&& can_create_pseudo_p () && optimize\n+   && sh_reg_dead_or_unused_after_insn (insn, REGNO (operands[0]))\"\n+  [(const_int 0)]\n+{\n+  emit_insn (gen_atomic_nand<mode>_hard (operands[1], operands[2]));\n }\n   [(set_attr \"length\" \"30\")])\n \n-(define_insn \"atomic_fetch_nand<mode>_soft_gusa\"\n+(define_insn \"atomic_nand<mode>_hard\"\n+  [(set (mem:QIHI (match_operand:SI 0 \"arith_reg_operand\" \"r\"))\n+\t(unspec:QIHI\n+\t  [(not:QIHI (and:QIHI (mem:QIHI (match_dup 0))\n+\t\t     (match_operand:QIHI 1 \"logical_operand\" \"rK08\")))]\n+\t  UNSPEC_ATOMIC))\n+   (set (reg:SI T_REG) (const_int 1))\n+   (clobber (reg:SI R0_REG))\n+   (clobber (match_scratch:SI 2 \"=&r\"))\n+   (clobber (match_scratch:SI 3 \"=0\"))]\n+  \"TARGET_ATOMIC_HARD_LLCS\"\n+{\n+  return \"\\r\tmov\t#-4,%2\"\t\t\t\"\\n\"\n+\t \"\tand\t%0,%2\"\t\t\t\"\\n\"\n+\t \"\txor\t%2,%0\"\t\t\t\"\\n\"\n+\t \"\tadd\tr15,%0\"\t\t\t\"\\n\"\n+\t \"\tadd\t#-4,%0\"\t\t\t\"\\n\"\n+\t \"0:\tmovli.l\t@%2,r0\"\t\t\t\"\\n\"\n+\t \"\tmov.l\tr0,@-r15\"\t\t\"\\n\"\n+\t \"\tmov.<bw>\t@%0,r0\"\t\t\"\\n\"\n+\t \"\tand\t%1,r0\"\t\t\t\"\\n\"\n+\t \"\tnot\tr0,r0\"\t\t\t\"\\n\"\n+\t \"\tmov.<bw>\tr0,@%0\"\t\t\"\\n\"\n+\t \"\tmov.l\t@r15+,r0\"\t\t\"\\n\"\n+\t \"\tmovco.l\tr0,@%2\"\t\t\t\"\\n\"\n+\t \"\tbf\t0b\";\n+}\n+  [(set_attr \"length\" \"28\")])\n+\n+(define_insn_and_split \"atomic_fetch_nand<mode>_soft_gusa\"\n   [(set (match_operand:QIHISI 0 \"arith_reg_dest\" \"=&u\")\n \t(mem:QIHISI (match_operand:SI 1 \"arith_reg_operand\" \"u\")))\n    (set (mem:QIHISI (match_dup 1))\n@@ -1020,10 +1227,17 @@\n \t \"\tnot\t%3,%3\"\t\t\t\"\\n\"\n \t \"\tmov.<bwl>\t%3,@%1\"\t\t\"\\n\"\n \t \"1:\tmov\tr1,r15\";\n+}\n+  \"&& can_create_pseudo_p () && optimize\n+   && sh_reg_dead_or_unused_after_insn (insn, REGNO (operands[0]))\"\n+  [(const_int 0)]\n+{\n+  emit_insn (gen_atomic_nand_fetch<mode>_soft_gusa (gen_reg_rtx (<MODE>mode),\n+\t\t\t\t\t\t    operands[1], operands[2]));\n }\n   [(set_attr \"length\" \"20\")])\n \n-(define_insn \"atomic_fetch_nand<mode>_soft_tcb\"\n+(define_insn_and_split \"atomic_fetch_nand<mode>_soft_tcb\"\n   [(set (match_operand:QIHISI 0 \"arith_reg_dest\" \"=&r\")\n \t(mem:QIHISI (match_operand:SI 1 \"arith_reg_operand\" \"r\")))\n    (set (mem:QIHISI (match_dup 1))\n@@ -1048,10 +1262,42 @@\n \t \"\tmov.<bwl>\tr0,@%1\"\t\t\"\\n\"\n \t \"1:\tmov\t#0,r0\"\t\t\t\"\\n\"\n \t \"\tmov.l\tr0,@(%O3,gbr)\";\n+}\n+  \"&& can_create_pseudo_p () && optimize\n+   && sh_reg_dead_or_unused_after_insn (insn, REGNO (operands[0]))\"\n+  [(const_int 0)]\n+{\n+  emit_insn (gen_atomic_nand<mode>_soft_tcb (operands[1], operands[2],\n+\t\t\t\t\t     operands[3]));\n }\n   [(set_attr \"length\" \"22\")])\n \n-(define_insn \"atomic_fetch_nand<mode>_soft_imask\"\n+(define_insn \"atomic_nand<mode>_soft_tcb\"\n+  [(set (mem:QIHISI (match_operand:SI 0 \"arith_reg_operand\" \"r\"))\n+\t(unspec:QIHISI\n+\t  [(not:QIHISI\n+\t     (and:QIHISI (mem:QIHISI (match_dup 0))\n+\t\t\t (match_operand:QIHISI 1 \"logical_operand\" \"rK08\")))]\n+\t  UNSPEC_ATOMIC))\n+   (use (match_operand:SI 2 \"gbr_displacement\"))\n+   (clobber (reg:SI R0_REG))\n+   (clobber (reg:SI R1_REG))]\n+  \"TARGET_ATOMIC_SOFT_TCB\"\n+{\n+  return \"\\r\tmova\t1f,r0\"\t\t\t\"\\n\"\n+\t \"\t.align 2\"\t\t\t\"\\n\"\n+\t \"\tmov\t#(0f-1f),r1\"\t\t\"\\n\"\n+\t \"\tmov.l\tr0,@(%O2,gbr)\"\t\t\"\\n\"\n+\t \"0:\tmov.<bwl>\t@%0,r0\"\t\t\"\\n\"\n+\t \"\tand\t%1,r0\"\t\t\t\"\\n\"\n+\t \"\tnot\tr0,r0\"\t\t\t\"\\n\"\n+\t \"\tmov.<bwl>\tr0,@%0\"\t\t\"\\n\"\n+\t \"1:\tmov\t#0,r0\"\t\t\t\"\\n\"\n+\t \"\tmov.l\tr0,@(%O2,gbr)\";\n+}\n+  [(set_attr \"length\" \"20\")])\n+\n+(define_insn_and_split \"atomic_fetch_nand<mode>_soft_imask\"\n   [(set (match_operand:QIHISI 0 \"arith_reg_dest\" \"=&r\")\n \t(mem:QIHISI (match_operand:SI 1 \"arith_reg_operand\" \"r\")))\n    (set (mem:QIHISI (match_dup 1))\n@@ -1074,6 +1320,13 @@\n \t \"\tnot\tr0,r0\"\t\t\t\"\\n\"\n \t \"\tmov.<bwl>\tr0,@%1\"\t\t\"\\n\"\n \t \"\tldc\t%3,sr\";\n+}\n+  \"&& can_create_pseudo_p () && optimize\n+   && sh_reg_dead_or_unused_after_insn (insn, REGNO (operands[0]))\"\n+  [(const_int 0)]\n+{\n+  emit_insn (gen_atomic_nand_fetch<mode>_soft_imask (gen_reg_rtx (<MODE>mode),\n+\t\t\t\t\t\t     operands[1], operands[2]));\n }\n   [(set_attr \"length\" \"20\")])\n \n@@ -1160,7 +1413,7 @@\n }\n   [(set_attr \"length\" \"8\")])\n \n-(define_insn \"atomic_<fetchop_name>_fetch<mode>_hard\"\n+(define_insn_and_split \"atomic_<fetchop_name>_fetch<mode>_hard\"\n   [(set (match_operand:QIHI 0 \"arith_reg_dest\" \"=&r\")\n \t(FETCHOP:QIHI\n \t  (mem:QIHI (match_operand:SI 1 \"arith_reg_operand\" \"r\"))\n@@ -1190,11 +1443,17 @@\n \t \"\tmov.l\t@r15+,r0\"\t\t\"\\n\"\n \t \"\tmovco.l\tr0,@%3\"\t\t\t\"\\n\"\n \t \"\tbf\t0b\";\n+}\n+  \"&& can_create_pseudo_p () && optimize\n+   && sh_reg_dead_or_unused_after_insn (insn, REGNO (operands[0]))\"\n+  [(const_int 0)]\n+{\n+  emit_insn (gen_atomic_<fetchop_name><mode>_hard (operands[1], operands[2]));\n }\n   [(set_attr \"length\" \"28\")])\n \n ;; Combine pattern for xor (val, -1) / nand (val, -1).\n-(define_insn \"atomic_not_fetch<mode>_hard\"\n+(define_insn_and_split \"atomic_not_fetch<mode>_hard\"\n   [(set (match_operand:QIHI 0 \"arith_reg_dest\" \"=&r\")\n \t(not:QIHI (mem:QIHI (match_operand:SI 1 \"arith_reg_operand\" \"r\"))))\n    (set (mem:QIHI (match_dup 1))\n@@ -1219,6 +1478,12 @@\n \t \"\tmov.l\t@r15+,r0\"\t\t\"\\n\"\n \t \"\tmovco.l\tr0,@%2\"\t\t\t\"\\n\"\n \t \"\tbf\t0b\";\n+}\n+  \"&& can_create_pseudo_p () && optimize\n+   && sh_reg_dead_or_unused_after_insn (insn, REGNO (operands[0]))\"\n+  [(const_int 0)]\n+{\n+  emit_insn (gen_atomic_not<mode>_hard (operands[1]));\n }\n   [(set_attr \"length\" \"28\")])\n \n@@ -1268,7 +1533,7 @@\n }\n   [(set_attr \"length\" \"16\")])\n \n-(define_insn \"atomic_<fetchop_name>_fetch<mode>_soft_tcb\"\n+(define_insn_and_split \"atomic_<fetchop_name>_fetch<mode>_soft_tcb\"\n   [(set (match_operand:QIHISI 0 \"arith_reg_dest\" \"=&r\")\n \t(FETCHOP:QIHISI\n \t  (mem:QIHISI (match_operand:SI 1 \"arith_reg_operand\" \"r\"))\n@@ -1293,11 +1558,18 @@\n \t \"1:\tmov\tr0,%0\"\t\t\t\"\\n\"\n \t \"\tmov\t#0,r0\"\t\t\t\"\\n\"\n \t \"\tmov.l\tr0,@(%O3,gbr)\";\n+}\n+  \"&& can_create_pseudo_p () && optimize\n+   && sh_reg_dead_or_unused_after_insn (insn, REGNO (operands[0]))\"\n+  [(const_int 0)]\n+{\n+  emit_insn (gen_atomic_<fetchop_name><mode>_soft_tcb (\n+\t\t\t\toperands[1], operands[2], operands[3]));\n }\n   [(set_attr \"length\" \"20\")])\n \n ;; Combine pattern for xor (val, -1) / nand (val, -1).\n-(define_insn \"atomic_not_fetch<mode>_soft_tcb\"\n+(define_insn_and_split \"atomic_not_fetch<mode>_soft_tcb\"\n   [(set (match_operand:QIHISI 0 \"arith_reg_dest\" \"=&r\")\n \t(not:QIHISI (mem:QIHISI (match_operand:SI 1 \"arith_reg_operand\" \"r\"))))\n    (set (mem:QIHISI (match_dup 1))\n@@ -1317,6 +1589,12 @@\n \t \"1:\tmov\tr0,%0\"\t\t\t\"\\n\"\n \t \"\tmov\t#0,r0\"\t\t\t\"\\n\"\n \t \"\tmov.l\tr0,@(%O2,gbr)\";\n+}\n+  \"&& can_create_pseudo_p () && optimize\n+   && sh_reg_dead_or_unused_after_insn (insn, REGNO (operands[0]))\"\n+  [(const_int 0)]\n+{\n+  emit_insn (gen_atomic_not<mode>_soft_tcb (operands[1], operands[2]));\n }\n   [(set_attr \"length\" \"20\")])\n \n@@ -1426,7 +1704,7 @@\n }\n   [(set_attr \"length\" \"10\")])\n \n-(define_insn \"atomic_nand_fetch<mode>_hard\"\n+(define_insn_and_split \"atomic_nand_fetch<mode>_hard\"\n   [(set (match_operand:QIHI 0 \"arith_reg_dest\" \"=&r\")\n \t(not:QIHI\n \t  (and:QIHI (mem:QIHI (match_operand:SI 1 \"arith_reg_operand\" \"r\"))\n@@ -1455,6 +1733,12 @@\n \t \"\tmov.l\t@r15+,r0\"\t\t\"\\n\"\n \t \"\tmovco.l\tr0,@%3\"\t\t\t\"\\n\"\n \t \"\tbf\t0b\";\n+}\n+  \"&& can_create_pseudo_p () && optimize\n+   && sh_reg_dead_or_unused_after_insn (insn, REGNO (operands[0]))\"\n+  [(const_int 0)]\n+{\n+  emit_insn (gen_atomic_nand<mode>_hard (operands[1], operands[2]));\n }\n   [(set_attr \"length\" \"28\")])\n \n@@ -1483,7 +1767,7 @@\n }\n   [(set_attr \"length\" \"18\")])\n \n-(define_insn \"atomic_nand_fetch<mode>_soft_tcb\"\n+(define_insn_and_split \"atomic_nand_fetch<mode>_soft_tcb\"\n   [(set (match_operand:QIHISI 0 \"arith_reg_dest\" \"=&r\")\n \t(not:QIHISI (and:QIHISI\n \t  (mem:QIHISI (match_operand:SI 1 \"arith_reg_operand\" \"r\"))\n@@ -1508,6 +1792,13 @@\n \t \"\tmov.<bwl>\tr0,@%1\"\t\t\"\\n\"\n \t \"1:\tmov\t#0,r0\"\t\t\t\"\\n\"\n \t \"\tmov.l\tr0,@(%O3,gbr)\";\n+}\n+  \"&& can_create_pseudo_p () && optimize\n+   && sh_reg_dead_or_unused_after_insn (insn, REGNO (operands[0]))\"\n+  [(const_int 0)]\n+{\n+  emit_insn (gen_atomic_nand<mode>_soft_tcb (operands[1], operands[2],\n+\t\t\t\t\t     operands[3]));\n }\n   [(set_attr \"length\" \"22\")])\n "}, {"sha": "98d72cbc38a3ae23802d83428e5ca8e560223bd3", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3548abca0218168da1bb9f8cace29282a7495fbf/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3548abca0218168da1bb9f8cace29282a7495fbf/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3548abca0218168da1bb9f8cace29282a7495fbf", "patch": "@@ -1,3 +1,12 @@\n+2015-02-03  Oleg Endo  <olegendo@gcc.gnu.org>\n+\n+\tPR target/64660\n+\t* gcc.target/sh/pr64660-0.h: New.\n+\t* gcc.target/sh/pr64660-1.c: New.\n+\t* gcc.target/sh/pr64660-2.c: New.\n+\t* gcc.target/sh/pr64660-3.c: New.\n+\t* gcc.target/sh/pr64660-4.c: New.\n+\n 2015-02-03  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/64877"}, {"sha": "28c1ac61aaeb4f9bbb9b94923c43929c996d186d", "filename": "gcc/testsuite/gcc.target/sh/pr64660-0.h", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3548abca0218168da1bb9f8cace29282a7495fbf/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr64660-0.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3548abca0218168da1bb9f8cace29282a7495fbf/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr64660-0.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr64660-0.h?ref=3548abca0218168da1bb9f8cace29282a7495fbf", "patch": "@@ -0,0 +1,44 @@\n+/* Check that the appropriate atomic insns are used if the result values\n+   are unused.  */\n+\n+#define concat_1(x, y) x ## y\n+#define concat(x, y) concat_1 (x, y)\n+#define makefuncname(name) concat (concat (test_, __LINE__), name)\n+\n+#define emitfuncs(name,val)\\\n+  void makefuncname (_0) (char* mem)\\\n+  {\\\n+    name (mem, val, __ATOMIC_ACQ_REL);\\\n+  }\\\n+  void makefuncname (_1) (short* mem)\\\n+  {\\\n+    name (mem, val, __ATOMIC_ACQ_REL);\\\n+  }\\\n+  void makefuncname (_2) (int* mem)\\\n+  {\\\n+    name (mem, val, __ATOMIC_ACQ_REL);\\\n+  }\\\n+\n+emitfuncs (__atomic_add_fetch, 1)\n+emitfuncs (__atomic_fetch_add, 1)\n+\n+emitfuncs (__atomic_sub_fetch, 1)\n+emitfuncs (__atomic_fetch_sub, 1)\n+\n+emitfuncs (__atomic_and_fetch, 1)\n+emitfuncs (__atomic_fetch_and, 1)\n+\n+emitfuncs (__atomic_or_fetch, 1)\n+emitfuncs (__atomic_fetch_or, 1)\n+\n+emitfuncs (__atomic_xor_fetch, 1)\n+emitfuncs (__atomic_fetch_xor, 1)\n+\n+emitfuncs (__atomic_nand_fetch, 1)\n+emitfuncs (__atomic_fetch_nand, 1)\n+\n+emitfuncs (__atomic_xor_fetch, -1)\n+emitfuncs (__atomic_fetch_xor, -1)\n+\n+emitfuncs (__atomic_nand_fetch, -1)\n+emitfuncs (__atomic_fetch_nand, -1)"}, {"sha": "2d5442c427c3c12ae4164f701c0956ee08b0d3ab", "filename": "gcc/testsuite/gcc.target/sh/pr64660-1.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3548abca0218168da1bb9f8cace29282a7495fbf/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr64660-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3548abca0218168da1bb9f8cace29282a7495fbf/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr64660-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr64660-1.c?ref=3548abca0218168da1bb9f8cace29282a7495fbf", "patch": "@@ -0,0 +1,12 @@\n+/* Check that the appropriate atomic insns are used if the result values\n+   are unused.  */\n+/* { dg-do compile { target { atomic_model_soft_gusa_available } } }  */\n+/* { dg-options \"-dp -O2 -matomic-model=soft-gusa,strict\" }  */\n+/* { dg-final { scan-assembler-times \"atomic_add_fetch\" 12 } }  */\n+/* { dg-final { scan-assembler-times \"atomic_and_fetch\" 6 } }  */\n+/* { dg-final { scan-assembler-times \"atomic_or_fetch\" 6 } }  */\n+/* { dg-final { scan-assembler-times \"atomic_xor_fetch\" 6 } }  */\n+/* { dg-final { scan-assembler-times \"atomic_nand_fetch\" 6 } }  */\n+/* { dg-final { scan-assembler-times \"atomic_not_fetch\" 12 } }  */\n+\n+#include \"pr64660-0.h\""}, {"sha": "c0cef13d1645749e794cf42d4b7cfc13a72dc2a0", "filename": "gcc/testsuite/gcc.target/sh/pr64660-2.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3548abca0218168da1bb9f8cace29282a7495fbf/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr64660-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3548abca0218168da1bb9f8cace29282a7495fbf/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr64660-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr64660-2.c?ref=3548abca0218168da1bb9f8cace29282a7495fbf", "patch": "@@ -0,0 +1,13 @@\n+/* Check that the appropriate atomic insns are used if the result values\n+   are unused.  */\n+/* { dg-do compile { target { atomic_model_soft_tcb_available } } }  */\n+/* { dg-options \"-dp -O2 -matomic-model=soft-tcb,gbr-offset=0,strict\" }  */\n+/* { dg-final { scan-assembler-times \"atomic_add\" 12 } }  */\n+/* { dg-final { scan-assembler-times \"atomic_and\" 6 } }  */\n+/* { dg-final { scan-assembler-times \"atomic_or\" 6 } }  */\n+/* { dg-final { scan-assembler-times \"atomic_xor\" 6 } }  */\n+/* { dg-final { scan-assembler-times \"atomic_nand\" 6 } }  */\n+/* { dg-final { scan-assembler-times \"atomic_not\" 12 } }  */\n+/* { dg-final { scan-assembler-not \"fetch\" } }  */\n+\n+#include \"pr64660-0.h\""}, {"sha": "fe3a83daf95c7c4d0e5dd1983dde1dd316c11e81", "filename": "gcc/testsuite/gcc.target/sh/pr64660-3.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3548abca0218168da1bb9f8cace29282a7495fbf/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr64660-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3548abca0218168da1bb9f8cace29282a7495fbf/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr64660-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr64660-3.c?ref=3548abca0218168da1bb9f8cace29282a7495fbf", "patch": "@@ -0,0 +1,12 @@\n+/* Check that the appropriate atomic insns are used if the result values\n+   are unused.  */\n+/* { dg-do compile { target { atomic_model_soft_imask_available } } }  */\n+/* { dg-options \"-dp -O2 -matomic-model=soft-imask,strict -mno-usermode\" }  */\n+/* { dg-final { scan-assembler-times \"atomic_add_fetch\" 12 } }  */\n+/* { dg-final { scan-assembler-times \"atomic_and_fetch\" 6 } }  */\n+/* { dg-final { scan-assembler-times \"atomic_or_fetch\" 6 } }  */\n+/* { dg-final { scan-assembler-times \"atomic_xor_fetch\" 6 } }  */\n+/* { dg-final { scan-assembler-times \"atomic_nand_fetch\" 6 } }  */\n+/* { dg-final { scan-assembler-times \"atomic_not_fetch\" 12 } }  */\n+\n+#include \"pr64660-0.h\""}, {"sha": "4d5d7f453928f740cc5903fc64f2eb141cb6f44e", "filename": "gcc/testsuite/gcc.target/sh/pr64660-4.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3548abca0218168da1bb9f8cace29282a7495fbf/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr64660-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3548abca0218168da1bb9f8cace29282a7495fbf/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr64660-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr64660-4.c?ref=3548abca0218168da1bb9f8cace29282a7495fbf", "patch": "@@ -0,0 +1,17 @@\n+/* Check that atomic not ops are generated.  */\n+/* { dg-do compile { target { atomic_model_hard_llcs_available } } }  */\n+/* { dg-options \"-dp -O2 -matomic-model=hard-llcs,strict\" }  */\n+/* { dg-final { scan-assembler-times \"atomic_add\" 12 } }  */\n+/* { dg-final { scan-assembler-times \"atomic_add_fetch\" 4 } }  */\n+/* { dg-final { scan-assembler-times \"atomic_and\" 6 } }  */\n+/* { dg-final { scan-assembler-times \"atomic_and_fetch\" 2 } }  */\n+/* { dg-final { scan-assembler-times \"atomic_or\" 6 } }  */\n+/* { dg-final { scan-assembler-times \"atomic_or_fetch\" 2 } }  */\n+/* { dg-final { scan-assembler-times \"atomic_xor\" 6 } }  */\n+/* { dg-final { scan-assembler-times \"atomic_xor_fetch\" 2 } }  */\n+/* { dg-final { scan-assembler-times \"atomic_nand\" 6 } }  */\n+/* { dg-final { scan-assembler-times \"atomic_nand_fetch\" 2 } }  */\n+/* { dg-final { scan-assembler-times \"atomic_not\" 12 } }  */\n+/* { dg-final { scan-assembler-times \"atomic_not_fetch\" 4 } }  */\n+\n+#include \"pr64660-0.h\""}]}