{"sha": "4b5f564a5d958295d51a1a7ff825896a89f22b75", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGI1ZjU2NGE1ZDk1ODI5NWQ1MWExYTdmZjgyNTg5NmE4OWYyMmI3NQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-11-06T16:53:31Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-11-06T16:59:20Z"}, "message": "libcpp: Provide date routine\n\nJoseph pointed me at cb_get_source_date_epoch, which allows repeatable\nbuilds and solves a FIXME I had on the modules branch.  Unfortunately\nit's used exclusively to generate __DATE__ and __TIME__ values, which\nfallback to using a time(2) call.  It'd be nicer if the preprocessor\nmade whatever time value it determined available to the rest of the\ncompiler.  So this patch adds a new cpp_get_date function, which\nabstracts the call to the get_source_date_epoch hook, or uses time\ndirectly.  The value is cached.  Thus the timestamp I end up putting\non CMI files matches __DATE__ and __TIME__ expansions.  That seems\nworthwhile.\n\n\tlibcpp/\n\t* include/cpplib.h (enum class CPP_time_kind): New.\n\t(cpp_get_date): Declare.\n\t* internal.h (struct cpp_reader): Replace source_date_epoch with\n\ttime_stamp and time_stamp_kind.\n\t* init.c (cpp_create_reader): Initialize them.\n\t* macro.c (_cpp_builtin_macro_text): Use cpp_get_date.\n\t(cpp_get_date): Broken out from _cpp_builtin_macro_text and\n\tgenericized.", "tree": {"sha": "89b054bb02f70619eacc29089f28e45e102c1a27", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/89b054bb02f70619eacc29089f28e45e102c1a27"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4b5f564a5d958295d51a1a7ff825896a89f22b75", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b5f564a5d958295d51a1a7ff825896a89f22b75", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b5f564a5d958295d51a1a7ff825896a89f22b75", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b5f564a5d958295d51a1a7ff825896a89f22b75/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6c3ce63b04b38f84c0357e4648383f0e3ab11cd9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c3ce63b04b38f84c0357e4648383f0e3ab11cd9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c3ce63b04b38f84c0357e4648383f0e3ab11cd9"}], "stats": {"total": 104, "additions": 71, "deletions": 33}, "files": [{"sha": "c4d7cc520d1d8741b0ed33f31b93c9de5942206a", "filename": "libcpp/include/cpplib.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b5f564a5d958295d51a1a7ff825896a89f22b75/libcpp%2Finclude%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b5f564a5d958295d51a1a7ff825896a89f22b75/libcpp%2Finclude%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finclude%2Fcpplib.h?ref=4b5f564a5d958295d51a1a7ff825896a89f22b75", "patch": "@@ -1040,6 +1040,15 @@ inline location_t cpp_macro_definition_location (cpp_hashnode *node)\n {\n   return node->value.macro->line;\n }\n+/* Return an idempotent time stamp (possibly from SOURCE_DATE_EPOCH).  */\n+enum class CPP_time_kind \n+{\n+  FIXED = -1,\t/* Fixed time via source epoch.  */\n+  DYNAMIC = -2,\t/* Dynamic via time(2).  */\n+  UNKNOWN = -3\t/* Wibbly wobbly, timey wimey.  */\n+};\n+extern CPP_time_kind cpp_get_date (cpp_reader *, time_t *);\n+\n extern void _cpp_backup_tokens (cpp_reader *, unsigned int);\n extern const cpp_token *cpp_peek_token (cpp_reader *, int);\n "}, {"sha": "dcf1d4be58724bd452aa67d3b77d5a74fe0212d8", "filename": "libcpp/init.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b5f564a5d958295d51a1a7ff825896a89f22b75/libcpp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b5f564a5d958295d51a1a7ff825896a89f22b75/libcpp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finit.c?ref=4b5f564a5d958295d51a1a7ff825896a89f22b75", "patch": "@@ -273,8 +273,9 @@ cpp_create_reader (enum c_lang lang, cpp_hash_table *table,\n   /* Do not force token locations by default.  */\n   pfile->forced_token_location = 0;\n \n-  /* Initialize source_date_epoch to -2 (not yet set).  */\n-  pfile->source_date_epoch = (time_t) -2;\n+  /* Note the timestamp is unset.  */\n+  pfile->time_stamp = time_t (-1);\n+  pfile->time_stamp_kind = 0;\n \n   /* The expression parser stack.  */\n   _cpp_expand_op_stack (pfile);"}, {"sha": "d7780e49d275f4eb4c6eca5e07e10ecd8890879e", "filename": "libcpp/internal.h", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b5f564a5d958295d51a1a7ff825896a89f22b75/libcpp%2Finternal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b5f564a5d958295d51a1a7ff825896a89f22b75/libcpp%2Finternal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finternal.h?ref=4b5f564a5d958295d51a1a7ff825896a89f22b75", "patch": "@@ -512,10 +512,9 @@ struct cpp_reader\n   const unsigned char *date;\n   const unsigned char *time;\n \n-  /* Externally set timestamp to replace current date and time useful for\n-     reproducibility.  It should be initialized to -2 (not yet set) and\n-     set to -1 to disable it or to a non-negative value to enable it.  */\n-  time_t source_date_epoch;\n+  /* Time stamp, set idempotently lazily.  */\n+  time_t time_stamp;\n+  int time_stamp_kind; /* Or errno.  */\n \n   /* A token forcing paste avoidance, and one demarking macro arguments.  */\n   cpp_token avoid_paste;"}, {"sha": "e2cb89e4c4379708234bff98c71edda71fa53505", "filename": "libcpp/macro.c", "status": "modified", "additions": 56, "deletions": 27, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b5f564a5d958295d51a1a7ff825896a89f22b75/libcpp%2Fmacro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b5f564a5d958295d51a1a7ff825896a89f22b75/libcpp%2Fmacro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fmacro.c?ref=4b5f564a5d958295d51a1a7ff825896a89f22b75", "patch": "@@ -606,29 +606,21 @@ _cpp_builtin_macro_text (cpp_reader *pfile, cpp_hashnode *node,\n \t     at init time, because time() and localtime() are very\n \t     slow on some systems.  */\n \t  time_t tt;\n-\t  struct tm *tb = NULL;\n+\t  auto kind = cpp_get_date (pfile, &tt);\n \n-\t  /* Set a reproducible timestamp for __DATE__ and __TIME__ macro\n-\t     if SOURCE_DATE_EPOCH is defined.  */\n-\t  if (pfile->source_date_epoch == (time_t) -2\n-\t      && pfile->cb.get_source_date_epoch != NULL)\n-\t    pfile->source_date_epoch = pfile->cb.get_source_date_epoch (pfile);\n-\n-\t  if (pfile->source_date_epoch >= (time_t) 0)\n-\t    tb = gmtime (&pfile->source_date_epoch);\n-\t  else\n+\t  if (kind == CPP_time_kind::UNKNOWN)\n \t    {\n-\t      /* (time_t) -1 is a legitimate value for \"number of seconds\n-\t\t since the Epoch\", so we have to do a little dance to\n-\t\t distinguish that from a genuine error.  */\n-\t      errno = 0;\n-\t      tt = time (NULL);\n-\t      if (tt != (time_t)-1 || errno == 0)\n-\t\ttb = localtime (&tt);\n+\t      cpp_errno (pfile, CPP_DL_WARNING,\n+\t\t\t \"could not determine date and time\");\n+\t\t\n+\t      pfile->date = UC\"\\\"??? ?? ????\\\"\";\n+\t      pfile->time = UC\"\\\"??:??:??\\\"\";\n \t    }\n-\n-\t  if (tb)\n+\t  else\n \t    {\n+\t      struct tm *tb = (kind == CPP_time_kind::FIXED\n+\t\t\t       ? gmtime : localtime) (&tt);\n+\n \t      pfile->date = _cpp_unaligned_alloc (pfile,\n \t\t\t\t\t\t  sizeof (\"\\\"Oct 11 1347\\\"\"));\n \t      sprintf ((char *) pfile->date, \"\\\"%s %2d %4d\\\"\",\n@@ -640,14 +632,6 @@ _cpp_builtin_macro_text (cpp_reader *pfile, cpp_hashnode *node,\n \t      sprintf ((char *) pfile->time, \"\\\"%02d:%02d:%02d\\\"\",\n \t\t       tb->tm_hour, tb->tm_min, tb->tm_sec);\n \t    }\n-\t  else\n-\t    {\n-\t      cpp_errno (pfile, CPP_DL_WARNING,\n-\t\t\t \"could not determine date and time\");\n-\t\t\n-\t      pfile->date = UC\"\\\"??? ?? ????\\\"\";\n-\t      pfile->time = UC\"\\\"??:??:??\\\"\";\n-\t    }\n \t}\n \n       if (node->value.builtin == BT_DATE)\n@@ -688,6 +672,51 @@ _cpp_builtin_macro_text (cpp_reader *pfile, cpp_hashnode *node,\n   return result;      \n }\n \n+/* Get an idempotent date.  Either the cached value, the value from\n+   source epoch, or failing that, the value from time(2).  Use this\n+   during compilation so that every time stamp is the same.  */\n+CPP_time_kind\n+cpp_get_date (cpp_reader *pfile, time_t *result)\n+{\n+  if (!pfile->time_stamp_kind)\n+    {\n+      int kind = 0;\n+      if (pfile->cb.get_source_date_epoch)\n+\t{\n+\t  /* Try reading the fixed epoch.  */\n+\t  pfile->time_stamp = pfile->cb.get_source_date_epoch (pfile);\n+\t  if (pfile->time_stamp != time_t (-1))\n+\t    kind = int (CPP_time_kind::FIXED);\n+\t}\n+\n+      if (!kind)\n+\t{\n+\t  /* Pedantically time_t (-1) is a legitimate value for\n+\t     \"number of seconds since the Epoch\".  It is a silly\n+\t     time.   */\n+\t  errno = 0;\n+\t  pfile->time_stamp = time (nullptr);\n+\t  /* Annoyingly a library could legally set errno and return a\n+\t     valid time!  Bad library!  */\n+\t  if (pfile->time_stamp == time_t (-1) && errno)\n+\t    kind = errno;\n+\t  else\n+\t    kind = int (CPP_time_kind::DYNAMIC);\n+\t}\n+\n+      pfile->time_stamp_kind = kind;\n+    }\n+\n+  *result = pfile->time_stamp;\n+  if (pfile->time_stamp_kind >= 0)\n+    {\n+      errno = pfile->time_stamp_kind;\n+      return CPP_time_kind::UNKNOWN;\n+    }\n+\n+  return CPP_time_kind (pfile->time_stamp_kind);\n+}\n+\n /* Convert builtin macros like __FILE__ to a token and push it on the\n    context stack.  Also handles _Pragma, for which a new token may not\n    be created.  Returns 1 if it generates a new token context, 0 to"}]}