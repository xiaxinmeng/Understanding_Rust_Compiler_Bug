{"sha": "703f140fb8dbe977cf5fabecd60e163267b6e227", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzAzZjE0MGZiOGRiZTk3N2NmNWZhYmVjZDYwZTE2MzI2N2I2ZTIyNw==", "commit": {"author": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2013-05-07T20:26:15Z"}, "committer": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2013-05-07T20:26:15Z"}, "message": "unordered_base.h: New.\n\n2013-05-07  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n\n\t* include/profile/unordered_base.h: New.\n\t* include/Makefile.am: Add new profile header.\n\t* include/Makefile.in: Regenerate.\n\t* include/profile/impl/profiler.h\n\t(__profcxx_inefficient_hash_is_on): New macro.\n\t* include/profile/unordered_map (std::profile::unordered_map<>):\n\tUse new _Unordered_profile base class. Use default implementations\n\tfor special functions.\n\t(std::profile::unordered_multimap<>): Likewise.\n\t* include/profile/unordered_set (std::profile::unordered_set<>):\n\tLikewise.\n\t(std::profile::unordered_multiset<>): Likewise.\n\t* testsuite/23_containers/unordered_multiset/55043.cc: Fix\n\tMoveOnly equality operator signature.\n\nFrom-SVN: r198698", "tree": {"sha": "92c9652b0d5109aa6374cb73a679a0241e262cd0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/92c9652b0d5109aa6374cb73a679a0241e262cd0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/703f140fb8dbe977cf5fabecd60e163267b6e227", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/703f140fb8dbe977cf5fabecd60e163267b6e227", "html_url": "https://github.com/Rust-GCC/gccrs/commit/703f140fb8dbe977cf5fabecd60e163267b6e227", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/703f140fb8dbe977cf5fabecd60e163267b6e227/comments", "author": null, "committer": null, "parents": [{"sha": "4ffecb1fed76821d63111b515c0b01d09411f119", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ffecb1fed76821d63111b515c0b01d09411f119", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ffecb1fed76821d63111b515c0b01d09411f119"}], "stats": {"total": 812, "additions": 464, "deletions": 348}, "files": [{"sha": "e6d873436be430d8ea8cedb5f6dee0a73979d9be", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703f140fb8dbe977cf5fabecd60e163267b6e227/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703f140fb8dbe977cf5fabecd60e163267b6e227/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=703f140fb8dbe977cf5fabecd60e163267b6e227", "patch": "@@ -1,3 +1,20 @@\n+2013-05-07  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n+\n+\t* include/profile/unordered_base.h: New.\n+\t* include/Makefile.am: Add new profile header.\n+\t* include/Makefile.in: Regenerate.\n+\t* include/profile/impl/profiler.h\n+\t(__profcxx_inefficient_hash_is_on): New macro.\n+\t* include/profile/unordered_map (std::profile::unordered_map<>):\n+\tUse new _Unordered_profile base class. Use default implementations\n+\tfor special functions.\n+\t(std::profile::unordered_multimap<>): Likewise.\n+\t* include/profile/unordered_set (std::profile::unordered_set<>):\n+\tLikewise.\n+\t(std::profile::unordered_multiset<>): Likewise.\n+\t* testsuite/23_containers/unordered_multiset/55043.cc: Fix\n+\tMoveOnly equality operator signature.\n+\n 2013-05-02  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \t* testsuite/tr1/4_metaprogramming/integral_constant/requirements/"}, {"sha": "11cb4dffec9aa47bc5f6c25423244a9eb6814a85", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703f140fb8dbe977cf5fabecd60e163267b6e227/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703f140fb8dbe977cf5fabecd60e163267b6e227/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=703f140fb8dbe977cf5fabecd60e163267b6e227", "patch": "@@ -788,6 +788,7 @@ profile_builddir = ./profile\n profile_headers = \\\n \t${profile_srcdir}/array \\\n \t${profile_srcdir}/base.h \\\n+\t${profile_srcdir}/unordered_base.h \\\n \t${profile_srcdir}/unordered_map \\\n \t${profile_srcdir}/unordered_set \\\n \t${profile_srcdir}/vector \\"}, {"sha": "b69f75756658dbefc13094b048422a75e13ee227", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703f140fb8dbe977cf5fabecd60e163267b6e227/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703f140fb8dbe977cf5fabecd60e163267b6e227/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=703f140fb8dbe977cf5fabecd60e163267b6e227", "patch": "@@ -1045,6 +1045,7 @@ profile_builddir = ./profile\n profile_headers = \\\n \t${profile_srcdir}/array \\\n \t${profile_srcdir}/base.h \\\n+\t${profile_srcdir}/unordered_base.h \\\n \t${profile_srcdir}/unordered_map \\\n \t${profile_srcdir}/unordered_set \\\n \t${profile_srcdir}/vector \\"}, {"sha": "081bb64ba961666f045668dbad9097273e43aaef", "filename": "libstdc++-v3/include/profile/impl/profiler.h", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703f140fb8dbe977cf5fabecd60e163267b6e227/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703f140fb8dbe977cf5fabecd60e163267b6e227/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler.h?ref=703f140fb8dbe977cf5fabecd60e163267b6e227", "patch": "@@ -188,7 +188,7 @@ namespace __gnu_profile\n   _GLIBCXX_PROFILE_REENTRANCE_GUARD(__gnu_profile::__is_invalid())\n #define __profcxx_is_on() \\\n   _GLIBCXX_PROFILE_REENTRANCE_GUARD(__gnu_profile::__is_on())\n-#define __profcxx__is_off() \\\n+#define __profcxx_is_off() \\\n   _GLIBCXX_PROFILE_REENTRANCE_GUARD(__gnu_profile::__is_off())\n #else\n #define __profcxx_report()\n@@ -237,15 +237,18 @@ namespace __gnu_profile\n \n // Turn on/off instrumentation for INEFFICIENT_HASH.\n #if defined(_GLIBCXX_PROFILE_INEFFICIENT_HASH)\n+#define __profcxx_inefficient_hash_is_on() \\\n+  __gnu_profile::__is_on()\n #define __profcxx_hashtable_construct2(__x...) \\\n   _GLIBCXX_PROFILE_REENTRANCE_GUARD( \\\n       __gnu_profile::__trace_hash_func_construct(__x))\n #define __profcxx_hashtable_destruct2(__x...) \\\n   _GLIBCXX_PROFILE_REENTRANCE_GUARD( \\\n       __gnu_profile::__trace_hash_func_destruct(__x))\n #else\n-#define __profcxx_hashtable_destruct2(__x...) \n-#define __profcxx_hashtable_construct2(__x...)  \n+#define __profcxx_inefficient_hash_is_on() false\n+#define __profcxx_hashtable_destruct2(__x...)\n+#define __profcxx_hashtable_construct2(__x...)\n #endif\n \n // Turn on/off instrumentation for VECTOR_TO_LIST."}, {"sha": "81d7694f515511ac3e87032bfa944ae8e4fff586", "filename": "libstdc++-v3/include/profile/unordered_base.h", "status": "added", "additions": 262, "deletions": 0, "changes": 262, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703f140fb8dbe977cf5fabecd60e163267b6e227/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Funordered_base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703f140fb8dbe977cf5fabecd60e163267b6e227/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Funordered_base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Funordered_base.h?ref=703f140fb8dbe977cf5fabecd60e163267b6e227", "patch": "@@ -0,0 +1,262 @@\n+// Profiling unordered containers implementation details -*- C++ -*-\n+\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+/** @file profile/unordered_base.h\n+ *  This file is a GNU profile extension to the Standard C++ Library.\n+ */\n+\n+#ifndef _GLIBCXX_PROFILE_UNORDERED\n+#define _GLIBCXX_PROFILE_UNORDERED 1\n+\n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+namespace __profile\n+{\n+  template<typename _UnorderedCont,\n+\t   typename _Value, bool _Cache_hash_code>\n+    struct _Bucket_index_helper;\n+\n+  template<typename _UnorderedCont, typename _Value>\n+    struct _Bucket_index_helper<_UnorderedCont, _Value, true>\n+    {\n+      static std::size_t\n+      bucket(const _UnorderedCont& __uc,\n+\t     const __detail::_Hash_node<_Value, true>* __node)\n+      { return __node->_M_hash_code % __uc.bucket_count(); }\n+    };\n+\n+  template<typename _UnorderedCont, typename _Value>\n+    struct _Bucket_index_helper<_UnorderedCont, _Value, false>\n+    {\n+      static std::size_t\n+      bucket(const _UnorderedCont& __uc,\n+\t     const __detail::_Hash_node<_Value, false>* __node)\n+      { return __uc.bucket(__node->_M_v()); }\n+    };\n+\n+  template<typename _UnorderedCont, typename _Key, typename _Mapped>\n+    struct _Bucket_index_helper<_UnorderedCont,\n+\t\t\t\tstd::pair<const _Key, _Mapped>, false>\n+    {\n+      typedef std::pair<const _Key, _Mapped> _Value;\n+\n+      static std::size_t\n+      bucket(const _UnorderedCont& __uc,\n+\t     const __detail::_Hash_node<_Value, false>* __node)\n+      { return __uc.bucket(__node->_M_v().first); }\n+    };\n+\n+  template<typename _UnorderedCont, typename _Value, bool _Cache_hash_code>\n+    std::size_t\n+    __get_bucket_index(const _UnorderedCont& __uc,\n+\t\t       const __detail::_Hash_node<_Value, _Cache_hash_code>* __node)\n+    {\n+      using __bucket_index_helper\n+\t= _Bucket_index_helper<_UnorderedCont, _Value, _Cache_hash_code>;\n+      return __bucket_index_helper::bucket(__uc, __node);\n+    }\n+\n+  template<typename _UnorderedCont,\n+\t   typename _Value, bool _Cache_hash_code>\n+    struct _Equal_helper;\n+\n+  template<typename _UnorderedCont, typename _Value>\n+    struct _Equal_helper<_UnorderedCont, _Value, true>\n+    {\n+      static std::size_t\n+      are_equal(const _UnorderedCont& __uc,\n+\t\tconst __detail::_Hash_node<_Value, true>* __lhs,\n+\t\tconst __detail::_Hash_node<_Value, true>* __rhs)\n+      {\n+\treturn __lhs->_M_hash_code == __rhs->_M_hash_code\n+\t  && __uc.key_eq()(__lhs->_M_v(), __rhs->_M_v());\n+      }\n+    };\n+\n+  template<typename _UnorderedCont,\n+\t   typename _Value>\n+    struct _Equal_helper<_UnorderedCont, _Value, false>\n+    {\n+      static std::size_t\n+      are_equal(const _UnorderedCont& __uc,\n+\t\tconst __detail::_Hash_node<_Value, false>* __lhs,\n+\t\tconst __detail::_Hash_node<_Value, false>* __rhs)\n+      { return __uc.key_eq()(__lhs->_M_v(), __rhs->_M_v()); }\n+    };\n+\n+  template<typename _UnorderedCont,\n+\t   typename _Key, typename _Mapped>\n+    struct _Equal_helper<_UnorderedCont, std::pair<const _Key, _Mapped>, true>\n+    {\n+      typedef std::pair<const _Key, _Mapped> _Value;\n+\n+      static std::size_t\n+      are_equal(const _UnorderedCont& __uc,\n+\t\tconst __detail::_Hash_node<_Value, true>* __lhs,\n+\t\tconst __detail::_Hash_node<_Value, true>* __rhs)\n+      {\n+\treturn __lhs->_M_hash_code == __rhs->_M_hash_code\n+\t  && __uc.key_eq()(__lhs->_M_v().first, __rhs->_M_v().first);\n+      }\n+    };\n+\n+  template<typename _UnorderedCont,\n+\t   typename _Key, typename _Mapped>\n+    struct _Equal_helper<_UnorderedCont, std::pair<const _Key, _Mapped>, false>\n+    {\n+      typedef std::pair<const _Key, _Mapped> _Value;\n+\n+      static std::size_t\n+      are_equal(const _UnorderedCont& __uc,\n+\t\tconst __detail::_Hash_node<_Value, false>* __lhs,\n+\t\tconst __detail::_Hash_node<_Value, false>* __rhs)\n+      { return __uc.key_eq()(__lhs->_M_v().first, __rhs->_M_v().first); }\n+    };\n+\n+  template<typename _UnorderedCont, typename _Value, bool _Cache_hash_code>\n+    bool\n+    __are_equal(const _UnorderedCont& __uc,\n+\t\tconst __detail::_Hash_node<_Value, _Cache_hash_code>* __lhs,\n+\t\tconst __detail::_Hash_node<_Value, _Cache_hash_code>* __rhs)\n+  {\n+    using __equal_helper\n+      = _Equal_helper<_UnorderedCont, _Value, _Cache_hash_code>;\n+    return __equal_helper::are_equal(__uc, __lhs, __rhs);\n+  }\n+\n+  template<typename _UnorderedCont, bool _Unique_keys>\n+    class _Unordered_profile\n+    {\n+      _UnorderedCont&\n+      _M_conjure()\n+      { return *(static_cast<_UnorderedCont*>(this)); }\n+\n+      using __unique_keys = std::integral_constant<bool, _Unique_keys>;\n+\n+    protected:\n+      _Unordered_profile()\n+      {\n+\tauto& __uc = _M_conjure();\n+        __profcxx_hashtable_construct(&__uc, __uc.bucket_count());\n+\t__profcxx_hashtable_construct2(&__uc);\n+      }\n+      _Unordered_profile(const _Unordered_profile&)\n+\t: _Unordered_profile() { }\n+      _Unordered_profile(_Unordered_profile&&)\n+\t: _Unordered_profile() { }\n+\n+      ~_Unordered_profile() noexcept\n+      {\n+\tauto& __uc = _M_conjure();\n+        __profcxx_hashtable_destruct(&__uc, __uc.bucket_count(), __uc.size());\n+        _M_profile_destruct();\n+      }\n+\n+      _Unordered_profile&\n+      operator=(const _Unordered_profile&) = default;\n+\n+      _Unordered_profile&\n+      operator=(_Unordered_profile&&) = default;\n+\n+      void\n+      _M_profile_destruct()\n+      {\n+\tif (!__profcxx_inefficient_hash_is_on())\n+\t  return;\n+\n+\t_M_profile_destruct(__unique_keys());\n+      }\n+\n+    private:\n+      void\n+      _M_profile_destruct(std::true_type);\n+\n+      void\n+      _M_profile_destruct(std::false_type);\n+    };\n+\n+  template<typename _UnorderedCont, bool _Unique_keys>\n+    void\n+    _Unordered_profile<_UnorderedCont, _Unique_keys>::\n+    _M_profile_destruct(std::true_type)\n+    {\n+      auto& __uc = _M_conjure();\n+      std::size_t __hops = 0, __lc = 0, __chain = 0;\n+      auto __it = __uc.begin();\n+      while (__it != __uc.end())\n+\t{\n+\t  auto __bkt = __get_bucket_index(__uc, __it._M_cur);\n+\t  auto __lit = __uc.begin(__bkt);\n+\t  auto __lend = __uc.end(__bkt);\n+\t  for (++__it, ++__lit; __lit != __lend; ++__it, ++__lit)\n+\t    ++__chain;\n+\t  if (__chain)\n+\t    {\n+\t      ++__chain;\n+\t      __lc = __lc > __chain ? __lc : __chain;\n+\t      __hops += __chain * (__chain - 1) / 2;\n+\t      __chain = 0;\n+\t    }\n+\t}\n+      __profcxx_hashtable_destruct2(&__uc, __lc, __uc.size(), __hops);\n+    }\n+\n+  template<typename _UnorderedCont, bool _Unique_keys>\n+    void\n+    _Unordered_profile<_UnorderedCont, _Unique_keys>::\n+    _M_profile_destruct(std::false_type)\n+    {\n+      auto& __uc = _M_conjure();\n+      std::size_t __hops = 0, __lc = 0, __chain = 0, __unique_size = 0;\n+      auto __it = __uc.begin();\n+      while (__it != __uc.end())\n+\t{\n+\t  auto __bkt = __get_bucket_index(__uc, __it._M_cur);\n+\t  auto __lit = __uc.begin(__bkt);\n+\t  auto __lend = __uc.end(__bkt);\n+\t  auto __pit = __it;\n+\t  ++__unique_size;\n+\t  for (++__it, ++__lit; __lit != __lend; ++__it, ++__lit)\n+\t    {\n+\t      if (!__are_equal(__uc, __pit._M_cur, __it._M_cur))\n+\t\t{\n+\t\t  ++__chain;\n+\t\t  ++__unique_size;\n+\t\t  __pit = __it;\n+\t\t}\n+\t    }\n+\t  if (__chain)\n+\t    {\n+\t      ++__chain;\n+\t      __lc = __lc > __chain ? __lc : __chain;\n+\t      __hops += __chain * (__chain - 1) / 2;\n+\t      __chain = 0;\n+\t    }\n+\t}\n+      __profcxx_hashtable_destruct2(&__uc, __lc, __unique_size, __hops);\n+    }\n+\n+} // namespace __profile\n+} // namespace std\n+\n+#endif"}, {"sha": "ac5fecc60fafc10f2c32eb108ecfca16a09f133d", "filename": "libstdc++-v3/include/profile/unordered_map", "status": "modified", "additions": 88, "deletions": 173, "changes": 261, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703f140fb8dbe977cf5fabecd60e163267b6e227/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Funordered_map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703f140fb8dbe977cf5fabecd60e163267b6e227/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Funordered_map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Funordered_map?ref=703f140fb8dbe977cf5fabecd60e163267b6e227", "patch": "@@ -34,6 +34,7 @@\n # include <unordered_map>\n \n #include <profile/base.h>\n+#include <profile/unordered_base.h>\n \n #define _GLIBCXX_BASE unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>\n #define _GLIBCXX_STD_BASE _GLIBCXX_STD_C::_GLIBCXX_BASE\n@@ -48,10 +49,18 @@ namespace __profile\n \t   typename _Pred = std::equal_to<_Key>,\n \t   typename _Alloc = std::allocator<std::pair<const _Key, _Tp> > >\n     class unordered_map\n-    : public _GLIBCXX_STD_BASE\n+    : public _GLIBCXX_STD_BASE,\n+      public _Unordered_profile<unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>,\n+\t\t\t\ttrue>\n     {\n       typedef typename _GLIBCXX_STD_BASE _Base;\n \n+      _Base&\n+      _M_base() noexcept       { return *this; }\n+\n+      const _Base&\n+      _M_base() const noexcept { return *this; }\n+\n     public:\n       typedef typename _Base::size_type       size_type;\n       typedef typename _Base::hasher          hasher;\n@@ -72,97 +81,69 @@ namespace __profile\n \t\t    const hasher& __hf = hasher(),\n \t\t    const key_equal& __eql = key_equal(),\n \t\t    const allocator_type& __a = allocator_type())\n-      : _Base(__n, __hf, __eql, __a)\n-      {\n-        __profcxx_hashtable_construct(this, _Base::bucket_count());\n-        __profcxx_hashtable_construct2(this);\n-      }\n+\t: _Base(__n, __hf, __eql, __a)\n+      { }\n \n       template<typename _InputIterator>\n         unordered_map(_InputIterator __f, _InputIterator __l,\n \t\t      size_type __n = 0,\n \t\t      const hasher& __hf = hasher(),\n \t\t      const key_equal& __eql = key_equal(),\n \t\t      const allocator_type& __a = allocator_type())\n-      : _Base(__f, __l, __n, __hf, __eql, __a)\n-      {\n-        __profcxx_hashtable_construct(this, _Base::bucket_count());\n-        __profcxx_hashtable_construct2(this);\n-      }\n+\t  : _Base(__f, __l, __n, __hf, __eql, __a)\n+        { }\n \n-      unordered_map(const unordered_map& __x)\n-      : _Base(__x) \n-      { \n-        __profcxx_hashtable_construct(this, _Base::bucket_count());\n-        __profcxx_hashtable_construct2(this);\n-      }\n+      unordered_map(const unordered_map&) = default;\n \n       unordered_map(const _Base& __x)\n-      : _Base(__x) \n-      { \n-        __profcxx_hashtable_construct(this, _Base::bucket_count());\n-        __profcxx_hashtable_construct2(this);\n-      }\n+\t: _Base(__x)\n+      { }\n \n-      unordered_map(unordered_map&& __x)\n-      : _Base(std::move(__x)) \n-      {\n-        __profcxx_hashtable_construct(this, _Base::bucket_count());\n-        __profcxx_hashtable_construct2(this);\n-      }\n+      unordered_map(unordered_map&&) = default;\n+\n+      explicit\n+      unordered_map(const allocator_type& __a)\n+\t: _Base(__a)\n+      { }\n+\n+      unordered_map(const unordered_map& __umap,\n+\t\t    const allocator_type& __a)\n+\t: _Base(__umap, __a)\n+      { }\n+\n+      unordered_map(unordered_map&& __umap,\n+\t\t    const allocator_type& __a)\n+\t: _Base(std::move(__umap._M_base()), __a)\n+      { }\n \n       unordered_map(initializer_list<value_type> __l,\n \t\t    size_type __n = 0,\n \t\t    const hasher& __hf = hasher(),\n \t\t    const key_equal& __eql = key_equal(),\n \t\t    const allocator_type& __a = allocator_type())\n-      : _Base(__l, __n, __hf, __eql, __a) { }\n+\t: _Base(__l, __n, __hf, __eql, __a)\n+      { }\n \n       unordered_map&\n-      operator=(const unordered_map& __x)\n-      {\n-\t*static_cast<_Base*>(this) = __x;\n-\treturn *this;\n-      }\n+      operator=(const unordered_map&) = default;\n \n       unordered_map&\n-      operator=(unordered_map&& __x)\n-      {\n-\t// NB: DR 1204.\n-\t// NB: DR 675.\n-\tthis->clear();\n-\tthis->swap(__x);\n-\treturn *this;\n-      }\n+      operator=(unordered_map&&) = default;\n \n       unordered_map&\n       operator=(initializer_list<value_type> __l)\n       {\n-\tthis->clear();\n-\tthis->insert(__l);\n+\t_M_base() = __l;\n \treturn *this;\n       }\n \n-      ~unordered_map() noexcept\n-      {\n-        __profcxx_hashtable_destruct(this, _Base::bucket_count(),\n-\t\t\t\t     _Base::size());\n-        _M_profile_destruct();\n-      }\n-\n-      _Base&\n-      _M_base() noexcept       { return *this; }\n-\n-      const _Base&\n-      _M_base() const noexcept { return *this; }\n-\n       void\n       clear() noexcept\n       {\n         __profcxx_hashtable_destruct(this, _Base::bucket_count(),\n \t\t\t\t     _Base::size());\n-        _M_profile_destruct();\n-        _Base::clear();\n+        this->_M_profile_destruct();\n+\t_Base::clear();\n       }\n \n       template<typename... _Args>\n@@ -247,14 +228,6 @@ namespace __profile\n \t  _M_profile_resize(__old_size); \n \t}\n \n-      void\n-      insert(const value_type* __first, const value_type* __last)\n-      {\n-        size_type __old_size = _Base::bucket_count(); \n-        _Base::insert(__first, __last);\n-        _M_profile_resize(__old_size); \n-      }\n-\n       // operator[]\n       mapped_type&\n       operator[](const _Key& __k)\n@@ -276,7 +249,8 @@ namespace __profile\n \n       void\n       swap(unordered_map& __x)\n-      { _Base::swap(__x); }\n+      noexcept( noexcept(__x._M_base().swap(__x)) )\n+      { _Base::swap(__x._M_base()); }\n \n       void rehash(size_type __n)\n       {\n@@ -293,29 +267,6 @@ namespace __profile\n \tif (__old_size != __new_size)\n \t  __profcxx_hashtable_resize(this, __old_size, __new_size);\n       }\n-\n-      void\n-      _M_profile_destruct()\n-      {\n-\tsize_type __hops = 0, __lc = 0, __chain = 0;\n-\titerator __it = this->begin();\n-\twhile (__it != this->end())\n-\t  {\n-\t    size_type __bkt = this->bucket(__it->first);\n-\t    auto __lit = this->begin(__bkt);\n-\t    auto __lend = this->end(__bkt);\n-\t    for (++__it, ++__lit; __lit != __lend; ++__it, ++__lit)\n-\t      ++__chain;\n-\t    if (__chain)\n-\t      {\n-\t\t++__chain;\n-\t\t__lc = __lc > __chain ? __lc : __chain;\n-\t\t__hops += __chain * (__chain - 1) / 2;\n-\t\t__chain = 0;\n-\t      }\n-\t  }\n-\t__profcxx_hashtable_destruct2(this, __lc, _Base::size(), __hops);\n-      }\n   };\n \n   template<typename _Key, typename _Tp, typename _Hash,\n@@ -350,10 +301,19 @@ namespace __profile\n \t   typename _Pred = std::equal_to<_Key>,\n \t   typename _Alloc = std::allocator<std::pair<const _Key, _Tp> > >\n     class unordered_multimap\n-    : public _GLIBCXX_STD_BASE\n+    : public _GLIBCXX_STD_BASE,\n+      public _Unordered_profile<unordered_multimap<_Key, _Tp,\n+\t\t\t\t\t\t   _Hash, _Pred, _Alloc>,\n+\t\t\t\tfalse>\n     {      \n       typedef typename _GLIBCXX_STD_BASE _Base;\n \n+      _Base&\n+      _M_base() noexcept       { return *this; }\n+\n+      const _Base&\n+      _M_base() const noexcept { return *this; }\n+\n     public:\n       typedef typename _Base::size_type       size_type;\n       typedef typename _Base::hasher          hasher;\n@@ -373,85 +333,69 @@ namespace __profile\n \t\t\t const hasher& __hf = hasher(),\n \t\t\t const key_equal& __eql = key_equal(),\n \t\t\t const allocator_type& __a = allocator_type())\n-      : _Base(__n, __hf, __eql, __a)\n-      {\n-        __profcxx_hashtable_construct(this, _Base::bucket_count());\n-      }\n+\t: _Base(__n, __hf, __eql, __a)\n+      { }\n+\n       template<typename _InputIterator>\n         unordered_multimap(_InputIterator __f, _InputIterator __l,\n \t\t\t   size_type __n = 0,\n \t\t\t   const hasher& __hf = hasher(),\n \t\t\t   const key_equal& __eql = key_equal(),\n \t\t\t   const allocator_type& __a = allocator_type())\n-      : _Base(__f, __l, __n, __hf, __eql, __a)\n-      {\n-        __profcxx_hashtable_construct(this, _Base::bucket_count());\n-      }\n+\t  : _Base(__f, __l, __n, __hf, __eql, __a)\n+      { }\n \n-      unordered_multimap(const unordered_multimap& __x)\n-      : _Base(__x)\n-      {\n-        __profcxx_hashtable_construct(this, _Base::bucket_count());\n-      }\n+      unordered_multimap(const unordered_multimap&) = default;\n \n       unordered_multimap(const _Base& __x)\n-      : _Base(__x)\n-      {\n-        __profcxx_hashtable_construct(this, _Base::bucket_count());\n-      }\n+\t: _Base(__x)\n+      { }\n \n-      unordered_multimap(unordered_multimap&& __x)\n-      : _Base(std::move(__x))\n-      {\n-        __profcxx_hashtable_construct(this, _Base::bucket_count());\n-      }\n+      unordered_multimap(unordered_multimap&&) = default;\n+\n+      explicit\n+      unordered_multimap(const allocator_type& __a)\n+\t: _Base(__a)\n+      { }\n+\n+      unordered_multimap(const unordered_multimap& __ummap,\n+\t\t\t const allocator_type& __a)\n+\t: _Base(__ummap._M_base(), __a)\n+      { }\n+\n+      unordered_multimap(unordered_multimap&& __ummap,\n+\t\t\t const allocator_type& __a)\n+\t: _Base(std::move(__ummap._M_base()), __a)\n+      { }\n \n       unordered_multimap(initializer_list<value_type> __l,\n \t\t\t size_type __n = 0,\n \t\t\t const hasher& __hf = hasher(),\n \t\t\t const key_equal& __eql = key_equal(),\n \t\t\t const allocator_type& __a = allocator_type())\n-      : _Base(__l, __n, __hf, __eql, __a) { }\n+      : _Base(__l, __n, __hf, __eql, __a)\n+      { }\n \n       unordered_multimap&\n-      operator=(const unordered_multimap& __x)\n-      {\n-\t*static_cast<_Base*>(this) = __x;\n-\treturn *this;\n-      }\n+      operator=(const unordered_multimap&) = default;\n \n       unordered_multimap&\n-      operator=(unordered_multimap&& __x)\n-      {\n-\t// NB: DR 1204.\n-\t// NB: DR 675.\n-\tthis->clear();\n-\tthis->swap(__x);\n-\treturn *this;\n-      }\n+      operator=(unordered_multimap&&) = default;\n \n       unordered_multimap&\n       operator=(initializer_list<value_type> __l)\n       {\n-\tthis->clear();\n-\tthis->insert(__l);\n+\t_M_base() = __l;\n \treturn *this;\n       }\n \n-      ~unordered_multimap() noexcept\n-      {\n-        __profcxx_hashtable_destruct(this, _Base::bucket_count(), \n-\t\t\t\t     _Base::size());\n-        _M_profile_destruct();\n-      }\n-\n       void\n       clear() noexcept\n       {\n-        __profcxx_hashtable_destruct(this, _Base::bucket_count(), \n+\t__profcxx_hashtable_destruct(this, _Base::bucket_count(), \n \t\t\t\t     _Base::size());\n-        _M_profile_destruct();\n-        _Base::clear();\n+\tthis->_M_profile_destruct();\n+\t_Base::clear();\n       }\n \n       template<typename... _Args>\n@@ -535,19 +479,13 @@ namespace __profile\n \t  _M_profile_resize(__old_size); \n \t}\n \n-      void\n-      insert(const value_type* __first, const value_type* __last)\n-      {\n-        size_type __old_size = _Base::bucket_count(); \n-        _Base::insert(__first, __last);\n-        _M_profile_resize(__old_size); \n-      }\n-\n       void\n       swap(unordered_multimap& __x)\n-      { _Base::swap(__x); }\n+      noexcept( noexcept(__x._M_base().swap(__x)) )\n+      { _Base::swap(__x._M_base()); }\n \n-      void rehash(size_type __n)\n+      void\n+      rehash(size_type __n)\n       {\n         size_type __old_size = _Base::bucket_count();\n         _Base::rehash(__n);\n@@ -562,29 +500,6 @@ namespace __profile\n         if (__old_size != __new_size)\n           __profcxx_hashtable_resize(this, __old_size, __new_size);\n       }\n-\n-      void\n-      _M_profile_destruct()\n-      {\n-\tsize_type __hops = 0, __lc = 0, __chain = 0;\n-\titerator __it = this->begin();\n-\twhile (__it != this->end())\n-\t  {\n-\t    size_type __bkt = this->bucket(__it->first);\n-\t    auto __lit = this->begin(__bkt);\n-\t    auto __lend = this->end(__bkt);\n-\t    for (++__it, ++__lit; __lit != __lend; ++__it, ++__lit)\n-\t      ++__chain;\n-\t    if (__chain)\n-\t      {\n-\t\t++__chain;\n-\t\t__lc = __lc > __chain ? __lc : __chain;\n-\t\t__hops += __chain * (__chain - 1) / 2;\n-\t\t__chain = 0;\n-\t      }\n-\t  }\n-\t__profcxx_hashtable_destruct2(this, __lc, _Base::size(), __hops);\n-      }\n   };\n \n   template<typename _Key, typename _Tp, typename _Hash,"}, {"sha": "f6bcda7d4d1e69af92c75b0acca1f8f585e6cb89", "filename": "libstdc++-v3/include/profile/unordered_set", "status": "modified", "additions": 88, "deletions": 171, "changes": 259, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703f140fb8dbe977cf5fabecd60e163267b6e227/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Funordered_set", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703f140fb8dbe977cf5fabecd60e163267b6e227/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Funordered_set", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Funordered_set?ref=703f140fb8dbe977cf5fabecd60e163267b6e227", "patch": "@@ -34,6 +34,7 @@\n # include <unordered_set>\n \n #include <profile/base.h>\n+#include <profile/unordered_base.h>\n \n #define _GLIBCXX_BASE unordered_set<_Key, _Hash, _Pred, _Alloc>\n #define _GLIBCXX_STD_BASE _GLIBCXX_STD_C::_GLIBCXX_BASE\n@@ -44,14 +45,22 @@ namespace __profile\n {\n   /** @brief Unordered_set wrapper with performance instrumentation.  */\n   template<typename _Key, \n-\t   typename _Hash  = std::hash<_Key>,\n+\t   typename _Hash = std::hash<_Key>,\n \t   typename _Pred = std::equal_to<_Key>,\n \t   typename _Alloc =  std::allocator<_Key> >\n     class unordered_set\n-    : public _GLIBCXX_STD_BASE\n+    : public _GLIBCXX_STD_BASE,\n+      public _Unordered_profile<unordered_set<_Key, _Hash, _Pred, _Alloc>,\n+\t\t\t\ttrue>\n     {\n       typedef _GLIBCXX_STD_BASE _Base;\n \n+      _Base&\n+      _M_base() noexcept       { return *this; }\n+\n+      const _Base&\n+      _M_base() const noexcept { return *this; }\n+\n     public:\n       typedef typename _Base::size_type       size_type;\n       typedef typename _Base::hasher          hasher;\n@@ -71,96 +80,73 @@ namespace __profile\n \t\t    const hasher& __hf = hasher(),\n \t\t    const key_equal& __eql = key_equal(),\n \t\t    const allocator_type& __a = allocator_type())\n-      : _Base(__n, __hf, __eql, __a)\n-      {\n-        __profcxx_hashtable_construct(this, _Base::bucket_count());\n-        __profcxx_hashtable_construct2(this);\n-      }\n+\t: _Base(__n, __hf, __eql, __a)\n+      { }\n \n       template<typename _InputIterator>\n         unordered_set(_InputIterator __f, _InputIterator __l,\n \t\t      size_type __n = 0,\n \t\t      const hasher& __hf = hasher(),\n \t\t      const key_equal& __eql = key_equal(),\n \t\t      const allocator_type& __a = allocator_type())\n-      : _Base(__f, __l, __n, __hf, __eql, __a)\n-      {\n-        __profcxx_hashtable_construct(this, _Base::bucket_count());\n-        __profcxx_hashtable_construct2(this);\n-      }\n+\t  : _Base(__f, __l, __n, __hf, __eql, __a)\n+      { }\n \n-      unordered_set(const unordered_set& __x)\n-      : _Base(__x) \n-      { \n-        __profcxx_hashtable_construct(this, _Base::bucket_count());\n-        __profcxx_hashtable_construct2(this);\n-      }\n+      unordered_set(const unordered_set&) = default;\n \n       unordered_set(const _Base& __x)\n-      : _Base(__x) \n-      { \n-        __profcxx_hashtable_construct(this, _Base::bucket_count());\n-        __profcxx_hashtable_construct2(this);\n-      }\n+\t: _Base(__x)\n+      { }\n \n-      unordered_set(unordered_set&& __x)\n-      : _Base(std::move(__x)) \n-      { \n-        __profcxx_hashtable_construct(this, _Base::bucket_count());\n-        __profcxx_hashtable_construct2(this);\n-      }\n+      unordered_set(unordered_set&&) = default;\n+\n+      explicit\n+      unordered_set(const allocator_type& __a)\n+\t: _Base(__a)\n+      { }\n+\n+      unordered_set(const unordered_set& __uset,\n+\t\t    const allocator_type& __a)\n+\t: _Base(__uset._M_base(), __a)\n+      { }\n+\n+      unordered_set(unordered_set&& __uset,\n+\t\t    const allocator_type& __a)\n+\t: _Base(std::move(__uset._M_base()), __a)\n+      { }\n \n       unordered_set(initializer_list<value_type> __l,\n \t\t    size_type __n = 0,\n \t\t    const hasher& __hf = hasher(),\n \t\t    const key_equal& __eql = key_equal(),\n \t\t    const allocator_type& __a = allocator_type())\n-      : _Base(__l, __n, __hf, __eql, __a) { }\n+      : _Base(__l, __n, __hf, __eql, __a)\n+      { }\n \n       unordered_set&\n-      operator=(const unordered_set& __x)\n-      {\n-\t*static_cast<_Base*>(this) = __x;\n-\treturn *this;\n-      }\n+      operator=(const unordered_set&) = default;\n \n       unordered_set&\n-      operator=(unordered_set&& __x)\n-      {\n-\t// NB: DR 1204.\n-\t// NB: DR 675.\n-\tthis->clear();\n-\tthis->swap(__x);\n-\treturn *this;\n-      }\n+      operator=(unordered_set&&) = default;\n \n       unordered_set&\n       operator=(initializer_list<value_type> __l)\n       {\n-\tthis->clear();\n-\tthis->insert(__l);\n+\t_M_base() = __l;\n \treturn *this;\n       }\n \n-      ~unordered_set() noexcept\n-      {\n-        __profcxx_hashtable_destruct(this, _Base::bucket_count(), \n-                                     _Base::size());\n-        _M_profile_destruct();\n-      }\n-\n       void\n       swap(unordered_set& __x)\n-      {\n-        _Base::swap(__x);\n-      }\n+      noexcept( noexcept(__x._M_base().swap(__x)) )\n+      { _Base::swap(__x); }\n \n       void\n       clear() noexcept\n       {\n         __profcxx_hashtable_destruct(this, _Base::bucket_count(), \n                                      _Base::size());\n-        _M_profile_destruct();\n+        this->_M_profile_destruct();\n         _Base::clear();\n       }\n \n@@ -240,14 +226,7 @@ namespace __profile\n \t}\n \n       void\n-      insert(const value_type* __first, const value_type* __last)\n-      {\n-        size_type __old_size = _Base::bucket_count(); \n-        _Base::insert(__first, __last);\n-        _M_profile_resize(__old_size); \n-      }\n-     \n-      void rehash(size_type __n)\n+      rehash(size_type __n)\n       {\n         size_type __old_size = _Base::bucket_count();\n         _Base::rehash(__n);\n@@ -262,29 +241,6 @@ namespace __profile\n \tif (__old_size != __new_size)\n \t  __profcxx_hashtable_resize(this, __old_size, __new_size);\n       }\n-\n-      void\n-      _M_profile_destruct()\n-      {\n-\tsize_type __hops = 0, __lc = 0, __chain = 0;\n-\titerator __it = this->begin();\n-\twhile (__it != this->end())\n-\t  {\n-\t    size_type __bkt = this->bucket(*__it);\n-\t    auto __lit = this->begin(__bkt);\n-\t    auto __lend = this->end(__bkt);\n-\t    for (++__it, ++__lit; __lit != __lend; ++__it, ++__lit)\n-\t      ++__chain;\n-\t    if (__chain)\n-\t      {\n-\t\t++__chain;\n-\t\t__lc = __lc > __chain ? __lc : __chain;\n-\t\t__hops += __chain * (__chain - 1) / 2;\n-\t\t__chain = 0;\n-\t      }\n-\t  }\n-        __profcxx_hashtable_destruct2(this, __lc, _Base::size(), __hops);\n-      }\n   };\n \n   template<typename _Key, typename _Hash, typename _Pred, typename _Alloc>\n@@ -312,14 +268,23 @@ namespace __profile\n \n   /** @brief Unordered_multiset wrapper with performance instrumentation.  */\n   template<typename _Value,\n-       typename _Hash  = std::hash<_Value>,\n-       typename _Pred = std::equal_to<_Value>,\n-       typename _Alloc =  std::allocator<_Value> >\n+\t   typename _Hash = std::hash<_Value>,\n+\t   typename _Pred = std::equal_to<_Value>,\n+\t   typename _Alloc =  std::allocator<_Value> >\n     class unordered_multiset\n-    : public _GLIBCXX_STD_BASE\n+    : public _GLIBCXX_STD_BASE,\n+      public _Unordered_profile<unordered_multiset<_Value,\n+\t\t\t\t\t\t   _Hash, _Pred, _Alloc>,\n+\t\t\t\tfalse>\n     {\n       typedef _GLIBCXX_STD_BASE _Base;\n \n+      _Base&\n+      _M_base() noexcept       { return *this; }\n+\n+      const _Base&\n+      _M_base() const noexcept { return *this; }\n+\n     public:\n       typedef typename _Base::size_type       size_type;\n       typedef typename _Base::hasher          hasher;\n@@ -339,91 +304,73 @@ namespace __profile\n \t\t\t const hasher& __hf = hasher(),\n \t\t\t const key_equal& __eql = key_equal(),\n \t\t\t const allocator_type& __a = allocator_type())\n-      : _Base(__n, __hf, __eql, __a)\n-      {\n-        __profcxx_hashtable_construct(this, _Base::bucket_count());\n-      }\n+\t: _Base(__n, __hf, __eql, __a)\n+      { }\n \n       template<typename _InputIterator>\n         unordered_multiset(_InputIterator __f, _InputIterator __l,\n \t\t\t   size_type __n = 0,\n \t\t\t   const hasher& __hf = hasher(),\n \t\t\t   const key_equal& __eql = key_equal(),\n \t\t\t   const allocator_type& __a = allocator_type())\n-      : _Base(__f, __l, __n, __hf, __eql, __a)\n-      {\n-        __profcxx_hashtable_construct(this, _Base::bucket_count());\n-      }\n+\t  : _Base(__f, __l, __n, __hf, __eql, __a)\n+      { }\n \n-      unordered_multiset(const unordered_multiset& __x)\n-      : _Base(__x)\n-      {\n-        __profcxx_hashtable_construct(this, _Base::bucket_count());\n-      }\n+      unordered_multiset(const unordered_multiset&) = default;\n \n       unordered_multiset(const _Base& __x)\n-      : _Base(__x)\n-      {\n-        __profcxx_hashtable_construct(this, _Base::bucket_count());\n-      }\n+\t: _Base(__x)\n+      { }\n \n-      unordered_multiset(unordered_multiset&& __x)\n-      : _Base(std::move(__x))\n-      {\n-        __profcxx_hashtable_construct(this, _Base::bucket_count());\n-      }\n+      unordered_multiset(unordered_multiset&&) = default;\n+\n+      explicit\n+      unordered_multiset(const allocator_type& __a)\n+\t: _Base(__a)\n+      { }\n+\n+      unordered_multiset(const unordered_multiset& __umset,\n+\t\t\t const allocator_type& __a)\n+\t: _Base(__umset._M_base(), __a)\n+      { }\n+\n+      unordered_multiset(unordered_multiset&& __umset,\n+\t\t\t const allocator_type& __a)\n+\t: _Base(std::move(__umset._M_base()), __a)\n+      { }\n \n       unordered_multiset(initializer_list<value_type> __l,\n \t\t\t size_type __n = 0,\n \t\t\t const hasher& __hf = hasher(),\n \t\t\t const key_equal& __eql = key_equal(),\n \t\t\t const allocator_type& __a = allocator_type())\n-      : _Base(__l, __n, __hf, __eql, __a) { }\n+\t: _Base(__l, __n, __hf, __eql, __a)\n+      { }\n \n       unordered_multiset&\n-      operator=(const unordered_multiset& __x)\n-      {\n-\t*static_cast<_Base*>(this) = __x;\n-\treturn *this;\n-      }\n+      operator=(const unordered_multiset&) = default;\n \n       unordered_multiset&\n-      operator=(unordered_multiset&& __x)\n-      {\n-\t// NB: DR 1204.\n-\t// NB: DR 675.\n-\tthis->clear();\n-\tthis->swap(__x);\n-\treturn *this;\n-      }\n+      operator=(unordered_multiset&&) = default;\n \n       unordered_multiset&\n       operator=(initializer_list<value_type> __l)\n       {\n-\tthis->clear();\n-\tthis->insert(__l);\n+\t_M_base() = __l;\n \treturn *this;\n       }\n \n-      ~unordered_multiset() noexcept\n-      {\n-        __profcxx_hashtable_destruct(this, _Base::bucket_count(), \n-                                     _Base::size());\n-        _M_profile_destruct();\n-      }\n-\n       void\n       swap(unordered_multiset& __x)\n-      {\n-        _Base::swap(__x);\n-      }\n+      noexcept( noexcept(__x._M_base().swap(__x)) )\n+      { _Base::swap(__x); }\n \n       void\n       clear() noexcept\n       {\n         __profcxx_hashtable_destruct(this, _Base::bucket_count(), \n                                      _Base::size());\n-        _M_profile_destruct();\n+        this->_M_profile_destruct();\n         _Base::clear();\n       }\n \n@@ -502,14 +449,7 @@ namespace __profile\n \t}\n \n       void\n-      insert(const value_type* __first, const value_type* __last)\n-      {\n-        size_type __old_size = _Base::bucket_count(); \n-        _Base::insert(__first, __last);\n-        _M_profile_resize(__old_size); \n-      }\n-     \n-      void rehash(size_type __n)\n+      rehash(size_type __n)\n       {\n         size_type __old_size = _Base::bucket_count();\n         _Base::rehash(__n);\n@@ -524,29 +464,6 @@ namespace __profile\n         if (__old_size != __new_size)\n           __profcxx_hashtable_resize(this, __old_size, __new_size);\n       }\n-\n-      void\n-      _M_profile_destruct()\n-      {\n-\tsize_type __hops = 0, __lc = 0, __chain = 0;\n-\titerator __it = this->begin();\n-\twhile (__it != this->end())\n-\t  {\n-\t    size_type __bkt = this->bucket(*__it);\n-\t    auto __lit = this->begin(__bkt);\n-\t    auto __lend = this->end(__bkt);\n-\t    for (++__it, ++__lit; __lit != __lend; ++__it, ++__lit)\n-\t      ++__chain;\n-\t    if (__chain)\n-\t      {\n-\t\t++__chain;\n-\t\t__lc = __lc > __chain ? __lc : __chain;\n-\t\t__hops += __chain * (__chain - 1) / 2;\n-\t\t__chain = 0;\n-\t      }\n-\t  }\n-        __profcxx_hashtable_destruct2(this, __lc, _Base::size(), __hops);\n-      }\n    };\n \n   template<typename _Value, typename _Hash, typename _Pred, typename _Alloc>"}, {"sha": "c80ce55cb7c35fa67816b249e2de80633155de93", "filename": "libstdc++-v3/testsuite/23_containers/unordered_multiset/55043.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703f140fb8dbe977cf5fabecd60e163267b6e227/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2F55043.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703f140fb8dbe977cf5fabecd60e163267b6e227/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2F55043.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2F55043.cc?ref=703f140fb8dbe977cf5fabecd60e163267b6e227", "patch": "@@ -30,7 +30,7 @@ struct MoveOnly\n };\n \n struct equal {\n-  bool operator()(const MoveOnly&, const MoveOnly) const { return true; }\n+  bool operator()(const MoveOnly&, const MoveOnly&) const { return true; }\n };\n struct hash {\n   std::size_t operator()(const MoveOnly&) const { return 0; }"}]}