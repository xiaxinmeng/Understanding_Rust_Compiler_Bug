{"sha": "ad08247592dad29c2734668fd8b345e82e56387b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWQwODI0NzU5MmRhZDI5YzI3MzQ2NjhmZDhiMzQ1ZTgyZTU2Mzg3Yg==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-02-09T23:47:23Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-02-09T23:47:23Z"}, "message": "entered into RCS\n\nFrom-SVN: r3453", "tree": {"sha": "e77733e23f614122e466c09b49376832836baf04", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e77733e23f614122e466c09b49376832836baf04"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ad08247592dad29c2734668fd8b345e82e56387b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad08247592dad29c2734668fd8b345e82e56387b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad08247592dad29c2734668fd8b345e82e56387b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad08247592dad29c2734668fd8b345e82e56387b/comments", "author": null, "committer": null, "parents": [{"sha": "edc03e8aa2ad34584ba40cafa82774dc69dc25f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/edc03e8aa2ad34584ba40cafa82774dc69dc25f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/edc03e8aa2ad34584ba40cafa82774dc69dc25f7"}], "stats": {"total": 597, "additions": 597, "deletions": 0}, "files": [{"sha": "e40c7871c0a552bd01ee242bbb4fdc6bfbc78377", "filename": "gcc/config/clipper/clipper.c", "status": "added", "additions": 389, "deletions": 0, "changes": 389, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad08247592dad29c2734668fd8b345e82e56387b/gcc%2Fconfig%2Fclipper%2Fclipper.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad08247592dad29c2734668fd8b345e82e56387b/gcc%2Fconfig%2Fclipper%2Fclipper.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fclipper%2Fclipper.c?ref=ad08247592dad29c2734668fd8b345e82e56387b", "patch": "@@ -0,0 +1,389 @@\n+/* Subroutines for insn-output.c for Clipper\n+   Copyright (C) 1987, 1988, 1991 Free Software Foundation, Inc.\n+\n+   Contributed by Holger Teutsch (holger@hotbso.rhein-main.de)\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#include <stdio.h>\n+#include \"config.h\"\n+#include \"rtl.h\"\n+#include \"regs.h\"\n+#include \"hard-reg-set.h\"\n+#include \"real.h\"\n+#include \"insn-config.h\"\n+#include \"conditions.h\"\n+#include \"insn-flags.h\"\n+#include \"output.h\"\n+#include \"insn-attr.h\"\n+#include \"tree.h\"\n+#include \"c-tree.h\"\n+#include \"expr.h\"\n+#include \"flags.h\"\n+#include \"machmode.h\"\n+\n+extern char regs_ever_live[];\n+\n+#ifdef ACCUMULATE_OUTGOING_ARGS\n+extern int current_function_outgoing_args_size;\n+#endif\n+\n+static int save_reg_offset;\n+\n+/*\n+ * prologue and epilogue output\n+ * function is entered with pc pushed, i.e. stack is 32 bit alligned\n+ *\n+ */\n+void\n+output_function_prologue (file, lsize)\n+     FILE *file;\n+     int lsize;\t\t\t\t/* size for locals */\n+{\n+  int i, offset;\n+  int save_size;\n+  int size;\t\t\t\t/* total size of frame */\n+\n+  save_size = 0;\t\t\t/* compute size for reg saves */\n+  for (i = 17; i < 32; i++)\n+    if (regs_ever_live[i] && !call_used_regs[i])\n+      save_size += 8;\n+\n+  for (i = 0; i < 16; i++)\n+    if (regs_ever_live[i] && !call_used_regs[i])\n+      save_size += 4;\n+\n+  save_reg_offset = lsize + save_size;\n+\n+  save_reg_offset = (save_reg_offset + 7) & ~7;\t/* align to 64 Bit */\n+\n+#ifdef ACCUMULATE_OUTGOING_ARGS\n+  size = save_reg_offset + current_function_outgoing_args_size;\n+#else\n+  size = save_reg_offset;\n+#endif\n+  \n+  size = (size + 7) & ~7;\t\t/* align to 64 Bit */\n+\n+  if (size == 0)\n+    {\n+      fputs (\"\\tpushw  fp,sp\\n\", file);\n+      fputs (\"\\tmovw   sp,fp\\n\", file);\n+    }\n+  else\n+    {\n+      if (size < 16)\n+\tfprintf (file, \"\\tsubq   $%d,sp\\n\", size + 4); /* room for fp */\n+      else\n+\tfprintf (file, \"\\tsubi   $%d,sp\\n\", size + 4);\n+\n+      fprintf (file, \"\\tstorw  fp,%d(sp)\\n\", size);\n+      fprintf (file, \"\\tloada  %d(sp),fp\\n\", size);\n+    }\n+\n+  offset = -save_reg_offset;\n+\n+  for (i = 16; i < 32; i++)\n+    if (regs_ever_live[i] && !call_used_regs[i])\n+      {\n+\tfprintf (file, \"\\tstord  f%d,%d(fp)\\n\", i-16, offset);\n+\toffset += 8;\n+      }\n+\n+  for (i = 0; i < 16; i++)\n+    if (regs_ever_live[i] && !call_used_regs[i])\n+      {\n+\tfprintf (file, \"\\tstorw  r%d,%d(fp)\\n\", i, offset);\n+\toffset += 4;\n+      }\n+}\n+\n+void\n+output_function_epilogue (file, size)\n+     FILE *file;\n+     int size;\t\t\t\t/* ignored */\n+{\n+  int i, offset;\n+\n+  offset = -save_reg_offset;\n+\n+  for (i = 16; i < 32; i++)\n+    if (regs_ever_live[i] && !call_used_regs[i])\n+      {\n+\tfprintf (file, \"\\tloadd  %d(fp),f%d\\n\", offset, i-16);\n+\toffset += 8;\n+      }\n+\n+  for (i = 0; i < 16; i++)\n+    if (regs_ever_live[i] && !call_used_regs[i])\n+      {\n+\tfprintf (file, \"\\tloadw  %d(fp),r%d\\n\", offset, i);\n+\toffset += 4;\n+      }\n+\n+  fputs (\"\\tmovw   fp,sp\\n\\tpopw   sp,fp\\n\\tret    sp\\n\",\n+\t file);\n+}\n+\n+/*\n+ * blockmove\n+ *\n+ * clipper_movstr ()\n+ */\n+void\n+clipper_movstr (operands)\n+     rtx *operands;\n+{\n+  rtx dst,src,cnt,tmp,top,bottom,xops[3];\n+  int align;\n+  int fixed;\n+\n+  extern FILE *asm_out_file;\n+\n+  dst = operands[0];\n+  src = operands[1];\n+  /* don't change this operands[2]; gcc 2.3.3 doesn't honor clobber note */\n+  align = INTVAL (operands[3]);\n+  tmp = operands[4];\n+  cnt = operands[5];\n+\n+  if (GET_CODE (operands[2]) == CONST_INT) /* fixed size move */\n+    {\n+      if ((fixed = INTVAL (operands[2])) <= 0)\n+\tabort ();\n+\n+      if (fixed <16)\n+\toutput_asm_insn (\"loadq  %2,%5\", operands);\n+      else\n+\toutput_asm_insn (\"loadi  %2,%5\", operands);\n+    }\n+  else\n+    {\n+      fixed = 0;\n+      bottom = (rtx)gen_label_rtx ();\t/* need a bottom label */\n+      xops[0] = cnt; xops[1] = bottom;\n+      output_asm_insn (\"movw   %2,%5\", operands); /* count is scratch reg 5 */\n+      output_asm_insn (\"brle   %l1\", xops);\n+    }\n+\n+\n+  top = (rtx)gen_label_rtx ();\t\t/* top of loop label */\n+  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\", CODE_LABEL_NUMBER (top));\n+\n+\n+  xops[0] = src; xops[1] = tmp; xops[2] = dst;\n+\n+  if (fixed && (align & 0x3) == 0)\t/* word aligned move with known size */\n+    {\n+      if (fixed >= 4)\n+\t{\n+\t  rtx xops1[2];\n+\t  output_asm_insn(\n+\t    \"loadw  %a0,%1\\n\\taddq   $4,%0\\n\\tstorw  %1,%a2\\n\\taddq   $4,%2\",\n+\t\t\t  xops);\n+\n+\t  xops1[0] = cnt; xops1[1] = top;\n+\t  output_asm_insn (\"subq   $4,%0\\n\\tbrgt   %l1\", xops1);\n+\t}\n+\n+      if (fixed & 0x2)\n+\t{\n+\t  output_asm_insn (\"loadh  %a0,%1\\n\\tstorh  %1,%a2\", xops);\n+\t  if (fixed & 0x1)\n+\t    output_asm_insn (\"loadb  2%a0,%1\\n\\tstorb  %1,2%a2\", xops);\n+\t}\n+      else\n+\tif (fixed & 0x1)\n+\t  output_asm_insn (\"loadb  %a0,%1\\n\\tstorb  %1,%a2\", xops);\n+    }\n+  else\n+    {\n+      output_asm_insn(\n+\t  \"loadb  %a0,%1\\n\\taddq   $1,%0\\n\\tstorb  %1,%a2\\n\\taddq   $1,%2\",\n+\t\t      xops);\n+\n+      xops[0] = cnt; xops[1] = top;\n+      output_asm_insn (\"subq   $1,%0\\n\\tbrgt   %l1\", xops);\n+    }\n+\n+  if (fixed == 0)\n+    ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\", CODE_LABEL_NUMBER (bottom));\n+}\n+\n+\f\n+print_operand_address (file, addr)\n+     FILE *file;\n+     register rtx addr;\n+{\n+  rtx op0,op1;\n+\n+ retry:\n+  switch (GET_CODE (addr))\n+    {\n+    case REG:\n+      fprintf (file, \"(%s)\", reg_names[REGNO (addr)]);\n+      break;\n+\n+    case PLUS:\n+      /* can be 'symbol + reg' or 'reg + reg' */\n+\n+      op0 = XEXP (addr, 0);\n+      op1 = XEXP (addr, 1);\n+\n+      if (GET_CODE (op0) == REG && GET_CODE (op1) == REG)\n+\t{\n+\t  fprintf (file, \"[%s](%s)\",\n+\t\t   reg_names[REGNO (op0)], reg_names[REGNO (op1)]);\n+\t  break;\n+\t}\n+\n+      if (GET_CODE (op0) == REG && CONSTANT_ADDRESS_P (op1))\n+\t{\n+\t  output_addr_const (file, op1);\n+\t  fprintf (file, \"(%s)\", reg_names[REGNO (op0)]);\n+\t  break;\n+\t}\n+\n+      if (GET_CODE (op1) == REG && CONSTANT_ADDRESS_P (op0))\n+\t{\n+\t  output_addr_const (file, op0);\n+\t  fprintf (file, \"(%s)\", reg_names[REGNO (op1)]);\n+\t  break;\n+\t}\n+      abort ();\t\t\t\t/* Oh no */\n+\n+    default:\n+      output_addr_const (file, addr);\n+    }\n+}\n+\n+\f\n+char *\n+rev_cond_name (op)\n+     rtx op;\n+{\n+  switch (GET_CODE (op))\n+    {\n+    case EQ:\n+      return \"ne\";\n+    case NE:\n+      return \"eq\";\n+    case LT:\n+      return \"ge\";\n+    case LE:\n+      return \"gt\";\n+    case GT:\n+      return \"le\";\n+    case GE:\n+      return \"lt\";\n+    case LTU:\n+      return \"geu\";\n+    case LEU:\n+      return \"gtu\";\n+    case GTU:\n+      return \"leu\";\n+    case GEU:\n+      return \"ltu\";\n+\n+    default:\n+      abort ();\n+    }\n+}\n+\n+\f\n+/* Do what is necessary for `va_start'.  The argument is ignored;\n+   We look at the current function to determine if stdargs or varargs\n+   is used and fill in an initial va_list.  A pointer to this constructor\n+   is returned.  */\n+\n+struct rtx_def *\n+clipper_builtin_saveregs (arglist)\n+     tree arglist;\n+{\n+  extern int current_function_varargs;\n+  rtx block, addr, argsize;\n+  /* Allocate the va_list constructor */\n+  block = assign_stack_local (BLKmode, 8 * UNITS_PER_WORD, 2 * BITS_PER_WORD);\n+  RTX_UNCHANGING_P (block) = 1;\n+  RTX_UNCHANGING_P (XEXP (block, 0)) = 1;\n+\n+  addr = copy_to_reg (XEXP (block, 0));\n+\n+  /* Store float regs  */\n+\n+  emit_move_insn (gen_rtx (MEM, DFmode, addr),\n+\t\t  gen_rtx (REG, DFmode, 16));\n+\n+  emit_move_insn (gen_rtx (MEM, DFmode,\n+\t\t\t   gen_rtx (PLUS, Pmode, addr,\n+\t\t\t\t    gen_rtx (CONST_INT, Pmode, 8))),\n+\t\t  gen_rtx (REG, DFmode, 17));\n+\n+  /* Store int regs  */\n+\n+  emit_move_insn (gen_rtx (MEM, SImode,\n+\t\t\t   gen_rtx (PLUS, Pmode, addr,\n+\t\t\t\t    gen_rtx (CONST_INT, Pmode, 16))),\n+\t\t  gen_rtx (REG, SImode, 0));\n+\n+  emit_move_insn (gen_rtx (MEM, SImode,\n+\t\t\t   gen_rtx (PLUS, Pmode, addr,\n+\t\t\t\t    gen_rtx (CONST_INT, Pmode, 20))),\n+\t\t  gen_rtx (REG, SImode, 1));\n+\n+\n+  /* Store the arg pointer in the __va_stk member.  */\n+\n+  emit_move_insn (gen_rtx (MEM, SImode,\n+\t\t\t   gen_rtx (PLUS, Pmode, addr,\n+\t\t\t\t    gen_rtx (CONST_INT, Pmode, 24))),\n+\t\t  copy_to_reg (virtual_incoming_args_rtx));\n+\n+\n+  /* Return the address of the va_list constructor, but don't put it in a\n+     register.  This fails when not optimizing and produces worse code when\n+     optimizing.  */\n+  return XEXP (block, 0);\n+}\n+\n+\n+/* Return truth value of whether OP can be used as an word register\n+   operand. Reject (SUBREG:SI (REG:SF )) */\n+\n+int\n+int_reg_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return (register_operand (op, mode) &&\n+\t  (GET_CODE (op) != SUBREG ||\n+\t   GET_MODE_CLASS (GET_MODE (SUBREG_REG (op))) == MODE_INT));\n+}\n+\n+/* Return truth value of whether OP can be used as a float register\n+   operand. Reject (SUBREG:SF (REG:SI )) )) */\n+\n+int\n+fp_reg_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return (register_operand (op, mode) &&\n+\t  (GET_CODE (op) != SUBREG ||\n+\t   GET_MODE_CLASS (GET_MODE (SUBREG_REG (op))) == MODE_FLOAT));\n+}\n+"}, {"sha": "7d9dd84c953b954b2a199ac44ead265b953f74ae", "filename": "gcc/config/clipper/clix.h", "status": "added", "additions": 163, "deletions": 0, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad08247592dad29c2734668fd8b345e82e56387b/gcc%2Fconfig%2Fclipper%2Fclix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad08247592dad29c2734668fd8b345e82e56387b/gcc%2Fconfig%2Fclipper%2Fclix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fclipper%2Fclix.h?ref=ad08247592dad29c2734668fd8b345e82e56387b", "patch": "@@ -0,0 +1,163 @@\n+/* Definitions of target machine for GNU compiler.  Vax sysV version.\n+   Copyright (C) 1988 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#include \"clipper.h\"\n+\n+#include \"svr3.h\"\n+\n+/* Names to predefine in the preprocessor for this target machine.  */\n+\n+#define CPP_PREDEFINES \"-Dclipper -Dunix\"\n+\n+#undef STARTFILE_SPEC\n+#define STARTFILE_SPEC  \\\n+  \"%{pg:gcrt1.o%s}%{!pg:%{p:mcrt1.o%s}%{!p:crt1.o%s}} crtbegin.o%s\"\n+\n+#undef ENDFILE_SPEC\n+#define ENDFILE_SPEC \"crtend.o%s crtn.o%s\"\n+\n+#undef LIB_SPEC\n+\n+#undef HAVE_ATEXIT\n+#define HAVE_ATEXIT\n+\n+#define ASM_OUTPUT_ASCII(FILE,PTR,LEN)\t\t\t\\\n+{\t\t\t\t\t\t\t\\\n+  unsigned char *s;\t\t\t\t\t\\\n+  int i;\t\t\t\t\t\t\\\n+  for (i = 0, s = (PTR); i < (LEN); s++, i++)\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      if ((i % 8) == 0)\t\t\t\t\t\\\n+\tfputs (\"\\n\\t.byte\\t\", (FILE));\t\t\t\\\n+      fprintf ((FILE), \"%s0x%x\", (i%8?\",\":\"\"), (unsigned)*s); \\\n+    }\t\t\t\t\t\t\t\\\n+  fputs (\"\\n\", (FILE));\t\t\t\t\t\\\n+}\n+\n+#undef ASM_OUTPUT_DOUBLE\n+#define ASM_OUTPUT_DOUBLE(FILE,VALUE)\t\\\n+{\t\t\t\t\t\\\n+  union { int i[2]; double d; } _d_;\t\\\n+  _d_.d = VALUE;\t\t\t\t\\\n+  fprintf (FILE, \"\\t.long 0x%08x,0x%08x\\n\", _d_.i[0],_d_.i[1]); \\\n+}\n+\n+#undef ASM_OUTPUT_FLOAT\n+#define ASM_OUTPUT_FLOAT(FILE,VALUE)\t\\\n+{\t\t\t\t\t\\\n+  union { int i; float f; } _f_;\t\\\n+  _f_.f = VALUE;\t\t\t\t\\\n+  fprintf (FILE, \"\\t.long 0x%08x\\n\", _f_.i); \\\n+}\n+\n+/* This is how to output an assembler line\n+   that says to advance the location counter\n+   to a multiple of 2**LOG bytes.  */\n+\n+#define ASM_OUTPUT_ALIGN(FILE,LOG) \\\n+  fprintf(FILE, \"\\t.align %d\\n\", 1 << (LOG))\n+\n+\n+#define ASM_LONG \".long\"\n+#define BSS_SECTION_ASM_OP  \".bss\"\n+#undef INIT_SECTION_ASM_OP\n+#define INIT_SECTION_ASM_OP \".section .init,\\\"x\\\"\"\n+\n+\f\n+/* Define a few machine-specific details of the implementation of\n+   constructors.\n+\n+   The __CTORS_LIST__ goes in the .init section.  Define CTOR_LIST_BEGIN\n+   and CTOR_LIST_END to contribute to the .init section an instruction to\n+   push a word containing 0 (or some equivalent of that).\n+\n+   ASM_OUTPUT_CONSTRUCTOR should be defined to push the address of the\n+   constructor.  */\n+\n+#define CTOR_LIST_BEGIN\t\t\t\t\\\n+  asm (INIT_SECTION_ASM_OP);\t\t\t\\\n+  asm (\"subq   $8,sp\");\t\t\t\t\\\n+  asm (\"loadq  $0,r0\");\t\t\t\t\\\n+  asm (\"storw  r0,(sp)\")\n+\n+/* don't need end marker */\n+\n+#undef CTOR_LIST_END\n+\n+#define ASM_OUTPUT_CONSTRUCTOR(FILE,NAME)\t\\\n+  do {\t\t\t\t\t\t\\\n+    init_section ();\t\t\t\t\\\n+    fputs (\"\\tloada  \", FILE);\t\t\t\\\n+    assemble_name (FILE, NAME);\t\t\t\\\n+    fputs (\",r0\\n\\tsubq   $8,sp\\n\\tstorw   r0,(sp)\\n\", FILE);\t\\\n+  } while (0)\n+\n+\n+/* fini psect is 8 aligned */\n+\n+#define DTOR_LIST_BEGIN\t\\\n+  asm (DTORS_SECTION_ASM_OP);\t\t\t\t\\\n+  func_ptr __DTOR_LIST__[2] = { (func_ptr) (-1), 0 };\n+\n+/* A C statement (sans semicolon) to output an element in the table of\n+   global destructors.  */\n+\n+#undef ASM_OUTPUT_DESTRUCTOR\n+#define ASM_OUTPUT_DESTRUCTOR(FILE,NAME)       \t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    fini_section ();                   \t\t\t\t\t\\\n+    fprintf (FILE, \"%s\\t \", ASM_LONG);\t\t\t\t\t\\\n+    assemble_name (FILE, NAME);              \t\t\t\t\\\n+    fprintf (FILE, \",0\\n\");\t\t\t\t\t\t\\\n+  } while (0)\n+\n+\n+/* On clix crt1.o first calls init code and then sets environ and a valid\n+   chrclass. Unfortunately stdio routines bomb with unset chrclass.\n+   Therefore we set chrclass prior to calling global constructors. */\n+\n+#undef DO_GLOBAL_CTORS_BODY\n+#define DO_GLOBAL_CTORS_BODY\t\t\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\\\n+  func_ptr *p, *beg = alloca (0);\t\t\t\t\\\n+  _setchrclass (0);\t\t\t\t\t\t\\\n+  for (p = beg; *p; p+=2)\t\t\t\t\t\\\n+    ;\t\t\t\t\t\t\t\t\\\n+  while (p != beg)\t\t\t\t\t\t\\\n+    { p-= 2; (*p) (); }\t\t\t\t\t\t\\\n+} while (0)\n+\n+\n+#undef DO_GLOBAL_DTORS_BODY\n+#define DO_GLOBAL_DTORS_BODY\t\\\n+  func_ptr *f = &__DTOR_LIST__[2];\t/* 0,1 contains -1,0 */\t\\\n+  int n = 0;\t\t\t\t\t\t\t\\\n+  while (*f)\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+     f+= 2;\t\t\t\t/* skip over alignment 0 */\t\\\n+     n++;\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  f -= 2;\t\t\t\t\t\t\t\\\n+  while (--n >= 0)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+     (*f) ();\t\t\t\t\t\t\t\\\n+     f-= 2;\t\t\t\t/* skip over alignment 0 */\t\\\n+    }\n+\n+"}, {"sha": "155161f94aac667524ba1517381c83be9a9d91d6", "filename": "gcc/config/clipper/x-clix", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad08247592dad29c2734668fd8b345e82e56387b/gcc%2Fconfig%2Fclipper%2Fx-clix", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad08247592dad29c2734668fd8b345e82e56387b/gcc%2Fconfig%2Fclipper%2Fx-clix", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fclipper%2Fx-clix?ref=ad08247592dad29c2734668fd8b345e82e56387b", "patch": "@@ -0,0 +1 @@\n+ALLOCA = alloca.o"}, {"sha": "846a1199ec19eae64312ece6bcfdfeed21c723f9", "filename": "gcc/config/clipper/xm-clix.h", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad08247592dad29c2734668fd8b345e82e56387b/gcc%2Fconfig%2Fclipper%2Fxm-clix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad08247592dad29c2734668fd8b345e82e56387b/gcc%2Fconfig%2Fclipper%2Fxm-clix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fclipper%2Fxm-clix.h?ref=ad08247592dad29c2734668fd8b345e82e56387b", "patch": "@@ -0,0 +1,44 @@\n+/* Config file for Clipper running Clix, system V. 3.2 clone  */\n+\n+\n+/* #defines that need visibility everywhere.  */\n+#define FALSE 0\n+#define TRUE 1\n+\n+/* target machine dependencies.\n+   tm.h is a symbolic link to the actual target specific file.   */\n+\n+#include \"tm.h\"\n+\n+/* This describes the machine the compiler is hosted on.  */\n+#define HOST_BITS_PER_CHAR 8\n+#define HOST_BITS_PER_SHORT 16\n+#define HOST_BITS_PER_INT 32\n+#define HOST_BITS_PER_LONG 32\n+#define HOST_BITS_PER_LONGLONG 64\n+\n+/* This machine uses IEEE floats.  */\n+/* #define HOST_FLOAT_FORMAT IEEE_FLOAT_FORMAT */\n+\n+/* Arguments to use with `exit'.  */\n+#define SUCCESS_EXIT_CODE 0\n+#define FATAL_EXIT_CODE 33\n+\n+/* If compiled with GNU C, use the built-in alloca */\n+#ifdef __GNUC__\n+#define alloca __builtin_alloca\n+#endif\n+\n+/* isinf isn't there, but finite is. */\n+#define isinf(x) (!finite(x))\n+\n+\n+#define USG\n+\n+#define bcopy(a,b,c) memcpy (b,a,c)\n+#define bzero(a,b) memset (a,0,b)\n+#define bcmp(a,b,c) memcmp (a,b,c)\n+#define index strchr\n+#define rindex strrchr\n+\n+#define TARGET_MEM_FUNCTIONS"}]}