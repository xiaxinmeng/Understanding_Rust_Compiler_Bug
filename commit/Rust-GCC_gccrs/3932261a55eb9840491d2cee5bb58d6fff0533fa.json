{"sha": "3932261a55eb9840491d2cee5bb58d6fff0533fa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzkzMjI2MWE1NWViOTg0MDQ5MWQyY2VlNWJiNThkNmZmZjA1MzNmYQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@markmitchell.com", "date": "1998-10-21T09:53:40Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1998-10-21T09:53:40Z"}, "message": "invoke.texi: Document -flang-isoc9x.\n\n\t* invoke.texi: Document -flang-isoc9x.\n\t* Makefile.in (OBJS): Add splay-tree.o.\n\t(c-common.o): Depend on rtl.h.\n\t(splay-tree.o): List dependencies and provide build rule.\n\t* rtl.h (record_alias_subset): New function.\n\t* alias.c: Include splay-tree.h.\n\t(alias_set_entry): New type.\n\t(CHECK_ALIAS_SETS_FOR_CONSISTENCY): Remove.\n\t(DIFFERENT_ALIAS_SETS_P): Use mem_in_disjoint_alias_sets_p.\n\t(mems_in_disjoin_alias_sets_p): New function.\n\t(alias_set_compare): Likewise.\n\t(insert_subset_children): Likewise.\n\t(get_alias_set_entry): Likewise.\n\t* tree.h (TYPE_RESTRICT): New macro.\n\t(TYPE_UNQUALIFIED): New manifest constant.\n\t(TYPE_QUAL_CONST): Likewise\n\t(TYPE_QUAL_VOLATILE): Likewise.\n\t(TYPE_QUAL_RESTRICT): Likewise.\n\t(tree_type): Add restrict_flag.  Reduce count of free bits.\n\t(DECL_POINTER_ALIAS_SET): New macro.\n\t(DECL_POINTER_ALIAS_SET_KNOWN_P): Likewise.\n\t(tree_decl): Add pointer_alias_set.\n\t(build_qualified_type): New function.\n\t(build_type_variant): Define in terms of build_qualified_type.\n\t* tree.c (set_type_quals): New function.\n\t(make_node): Initializae DECL_POINTER_ALIAS_SET.\n\t(build_type_attribute_variant): Use build_qualified_type and\n\tset_type_quals.\n\t(build_type_variant): Rename, and modify, to become...\n\t(build_qualified_type): New function.\n\t(build_complex_type): Use set_type_quals.\n\t* c-tree.h (C_TYPE_OBJECT_P): New macro.\n\t(C_TYPE_FUNCTION_P): Likewise.\n\t(C_TYPE_INCOMPLETE_P): Likewise.\n\t(C_TYPE_OBJECT_OR_INCOMPLETE_P): Likewise.\n\t(c_apply_type_quals_to_decl): New function.\n\t(c_build_qualified_type): New function.\n\t(c_build_type_variant): Define in terms of c_build_qualified_type.\n\t(flag_isoc9x): Declare.\n\t* c-typeck.c (qualify_type): Use c_build_qualified_type.\n\t(common_type): Change to use TYPE_QUALS.\n\t(comptypes): Likewise.\n\t(convert_for_assignment): Likewise.\n\t* c-aux-info.c (gen_type): Likewise.  Deal with `restrict'.\n\t* c-decl.c (flag_isoc9x): Define.\n\t(c_decode_option): Handle -flang-isoc9x.\n\t(grokdeclarator): Update to handle restrict.  Use TYPE_QUALS,\n\tc_build_qualified_type, etc.  Use c_apply_type_quals_to_decl.\n\t* c-lex.c (init_lex): Deal with restrict.\n\t(init_lex): Don't treat restrict as a reserved word in\n\t-traditional mode, or without -flang-isoc9x.\n\t* c-lex.h (rid): Add RID_RESTRICT.\n\t* c-parse.gperf (restrict, __restrict, __restrict__): Make\n\tequivalent to RID_RESTRICT.\n\t* c-parse.in (TYPE_QUAL): Update comment.\n\t* c-common.c: Include rtl.h.\n\t(c_find_base_decl): New function.\n\t(c_build_type_variant): Rename, and modify, to become ...\n\t(c_build_qualified_type): New function.\n\t(c_apply_type_quals_to_decl): Likewise.\n\t(c_get_alias_set): For INDIRECT_REFs, check to see if we can find\n\ta particular alias set for the reference.\n\t* toplev.c (documented_lang_options): Add -flang-isoc9x.\n\nFrom-SVN: r23212", "tree": {"sha": "9768c9c789a7b2a0a685cf74859c95d943a2cae0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9768c9c789a7b2a0a685cf74859c95d943a2cae0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3932261a55eb9840491d2cee5bb58d6fff0533fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3932261a55eb9840491d2cee5bb58d6fff0533fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3932261a55eb9840491d2cee5bb58d6fff0533fa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3932261a55eb9840491d2cee5bb58d6fff0533fa/comments", "author": null, "committer": null, "parents": [{"sha": "52e90c5508e2a90aaf2e85d923b175f4d9a92dc5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52e90c5508e2a90aaf2e85d923b175f4d9a92dc5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/52e90c5508e2a90aaf2e85d923b175f4d9a92dc5"}], "stats": {"total": 1100, "additions": 791, "deletions": 309}, "files": [{"sha": "1d65b6d88c9fa919494dedf40a42adaf20a73146", "filename": "gcc/ChangeLog", "status": "modified", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3932261a55eb9840491d2cee5bb58d6fff0533fa/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3932261a55eb9840491d2cee5bb58d6fff0533fa/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3932261a55eb9840491d2cee5bb58d6fff0533fa", "patch": "@@ -1,3 +1,73 @@\n+Wed Oct 21 09:18:58 1998  Mark Mitchell  <mark@markmitchell.com>\n+\n+\t* invoke.texi: Document -flang-isoc9x.\n+\n+\t* Makefile.in (OBJS): Add splay-tree.o.\n+\t(c-common.o): Depend on rtl.h.\n+\t(splay-tree.o): List dependencies and provide build rule.\n+\t\n+\t* rtl.h (record_alias_subset): New function.\n+\t* alias.c: Include splay-tree.h.\n+\t(alias_set_entry): New type.\n+\t(CHECK_ALIAS_SETS_FOR_CONSISTENCY): Remove.\n+\t(DIFFERENT_ALIAS_SETS_P): Use mem_in_disjoint_alias_sets_p.\n+\t(mems_in_disjoin_alias_sets_p): New function.\n+\t(alias_set_compare): Likewise.\n+\t(insert_subset_children): Likewise.\n+\t(get_alias_set_entry): Likewise.\n+\n+\t* tree.h (TYPE_RESTRICT): New macro.\n+\t(TYPE_UNQUALIFIED): New manifest constant.\n+\t(TYPE_QUAL_CONST): Likewise\n+\t(TYPE_QUAL_VOLATILE): Likewise.\n+\t(TYPE_QUAL_RESTRICT): Likewise.\n+\t(tree_type): Add restrict_flag.  Reduce count of free bits.\n+\t(DECL_POINTER_ALIAS_SET): New macro.\n+\t(DECL_POINTER_ALIAS_SET_KNOWN_P): Likewise.\n+\t(tree_decl): Add pointer_alias_set.\n+\t(build_qualified_type): New function.\n+\t(build_type_variant): Define in terms of build_qualified_type.\n+\t* tree.c (set_type_quals): New function.\n+\t(make_node): Initializae DECL_POINTER_ALIAS_SET.\n+\t(build_type_attribute_variant): Use build_qualified_type and\n+\tset_type_quals.\n+\t(build_type_variant): Rename, and modify, to become...\n+\t(build_qualified_type): New function.\n+\t(build_complex_type): Use set_type_quals.\n+\n+\t* c-tree.h (C_TYPE_OBJECT_P): New macro.\n+\t(C_TYPE_FUNCTION_P): Likewise.\n+\t(C_TYPE_INCOMPLETE_P): Likewise.\n+\t(C_TYPE_OBJECT_OR_INCOMPLETE_P): Likewise.\n+\t(c_apply_type_quals_to_decl): New function.\n+\t(c_build_qualified_type): New function.\n+\t(c_build_type_variant): Define in terms of c_build_qualified_type.\n+\t(flag_isoc9x): Declare.\n+\t* c-typeck.c (qualify_type): Use c_build_qualified_type.\n+\t(common_type): Change to use TYPE_QUALS.\n+\t(comptypes): Likewise.\n+\t(convert_for_assignment): Likewise.\n+\t* c-aux-info.c (gen_type): Likewise.  Deal with `restrict'.\n+\t* c-decl.c (flag_isoc9x): Define.\n+\t(c_decode_option): Handle -flang-isoc9x.\n+\t(grokdeclarator): Update to handle restrict.  Use TYPE_QUALS,\n+\tc_build_qualified_type, etc.  Use c_apply_type_quals_to_decl.\n+\t* c-lex.c (init_lex): Deal with restrict.\n+\t(init_lex): Don't treat restrict as a reserved word in\n+\t-traditional mode, or without -flang-isoc9x.\n+\t* c-lex.h (rid): Add RID_RESTRICT.\n+\t* c-parse.gperf (restrict, __restrict, __restrict__): Make\n+\tequivalent to RID_RESTRICT.\n+\t* c-parse.in (TYPE_QUAL): Update comment.\n+\t* c-common.c: Include rtl.h.\n+\t(c_find_base_decl): New function.\n+\t(c_build_type_variant): Rename, and modify, to become ...\n+\t(c_build_qualified_type): New function.\n+\t(c_apply_type_quals_to_decl): Likewise.\n+\t(c_get_alias_set): For INDIRECT_REFs, check to see if we can find\n+\ta particular alias set for the reference.\n+\t* toplev.c (documented_lang_options): Add -flang-isoc9x.\n+\n Wed Oct 21 09:15:06 1998  Nick Clifton  <nickc@cygnus.com>\n \n \t* config/arm/arm.h (TARGET_SWITCHES): Document arm specific"}, {"sha": "682f55ad551fee862844eba1963f10a8818b5eed", "filename": "gcc/Makefile.in", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3932261a55eb9840491d2cee5bb58d6fff0533fa/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3932261a55eb9840491d2cee5bb58d6fff0533fa/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=3932261a55eb9840491d2cee5bb58d6fff0533fa", "patch": "@@ -645,7 +645,7 @@ OBJS = toplev.o version.o tree.o print-tree.o stor-layout.o fold-const.o \\\n  insn-peep.o reorg.o $(SCHED_PREFIX)sched.o final.o recog.o reg-stack.o \\\n  insn-opinit.o insn-recog.o insn-extract.o insn-output.o insn-emit.o \\\n  profile.o insn-attrtab.o $(out_object_file) getpwd.o $(EXTRA_OBJS) convert.o \\\n- mbchar.o dyn-string.o\n+ mbchar.o dyn-string.o splay-tree.o\n \n # GEN files are listed separately, so they can be built before doing parallel\n #  makes for cc1 or cc1plus.  Otherwise sequent parallel make attempts to load\n@@ -1319,6 +1319,13 @@ vfprintf.o: $(srcdir)/../libiberty/vfprintf.c $(CONFIG_H) system.h gansidecl.h\n \t$(LN_S) $(srcdir)/../libiberty/vfprintf.c vfprintf.c\n \t$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) vfprintf.c\n \n+splay-tree.o: $(srcdir)/../libiberty/splay-tree.c \\\n+  $(srcdir)/../include/splay-tree.h $(srcdir)/../include/libiberty.h \\\n+  gansidecl.h\n+\trm -f splay-tree.c\n+\t$(LN_S) $(srcdir)/../libiberty/splay-tree.c splay-tree.c\n+\t$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) splay-tree.c\n+\n underscore.c: s-under ; @true\n \n s-under: $(GCC_PASSES)\n@@ -1337,7 +1344,7 @@ s-under: $(GCC_PASSES)\n # A file used by all variants of C.\n \n c-common.o : c-common.c $(CONFIG_H) system.h $(TREE_H) c-tree.h c-lex.h \\\n-\tflags.h toplev.h output.h\n+\tflags.h toplev.h output.h rtl.h\n \n # Language-independent files.\n "}, {"sha": "719b8901d155c4a3f5e9625f6db08c0cd19ef843", "filename": "gcc/alias.c", "status": "modified", "additions": 213, "deletions": 19, "changes": 232, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3932261a55eb9840491d2cee5bb58d6fff0533fa/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3932261a55eb9840491d2cee5bb58d6fff0533fa/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=3932261a55eb9840491d2cee5bb58d6fff0533fa", "patch": "@@ -28,6 +28,49 @@ Boston, MA 02111-1307, USA.  */\n #include \"flags.h\"\n #include \"output.h\"\n #include \"toplev.h\"\n+#include \"splay-tree.h\"\n+\n+/* The alias sets assigned to MEMs assist the back-end in determining\n+   which MEMs can alias which other MEMs.  In general, two MEMs in\n+   different alias sets to not alias each other.  There is one\n+   exception, however.  Consider something like:\n+\n+     struct S {int i; double d; };\n+\n+   a store to an `S' can alias something of either type `int' or type\n+   `double'.  (However, a store to an `int' cannot alias a `double'\n+   and vice versa.)  We indicate this via a tree structure that looks\n+   like:\n+           struct S\n+            /   \\\n+\t   /     \\\n+         |/_     _\\|\n+         int    double\n+\n+   (The arrows are directed and point downwards.)  If, when comparing\n+   two alias sets, we can hold one set fixed, and trace the other set\n+   downwards, and at some point find the first set, the two MEMs can\n+   alias one another.  In this situation we say the alias set for\n+   `struct S' is the `superset' and that those for `int' and `double'\n+   are `subsets'.  \n+\n+   Alias set zero is implicitly a superset of all other alias sets.\n+   However, this is no actual entry for alias set zero.  It is an\n+   error to attempt to explicitly construct a subset of zero.  */\n+\n+typedef struct alias_set_entry {\n+  /* The alias set number, as stored in MEM_ALIAS_SET.  */\n+  int alias_set;\n+\n+  /* The children of the alias set.  These are not just the immediate\n+     children, but, in fact, all children.  So, if we have:\n+\n+       struct T { struct S s; float f; } \n+\n+     continuing our example above, the children here will be all of\n+     `int', `double', `float', and `struct S'.  */\n+  splay_tree children;\n+}* alias_set_entry;\n \n static rtx canon_rtx\t\t\tPROTO((rtx));\n static int rtx_equal_for_memref_p\tPROTO((rtx, rtx));\n@@ -39,35 +82,23 @@ static rtx find_base_term\t\tPROTO((rtx));\n static int base_alias_check\t\tPROTO((rtx, rtx, enum machine_mode,\n \t\t\t\t\t       enum machine_mode));\n static rtx find_base_value\t\tPROTO((rtx));\n+static int mems_in_disjoint_alias_sets_p PROTO((rtx, rtx));\n+static int alias_set_compare            PROTO((splay_tree_key, \n+\t\t\t\t\t       splay_tree_key));\n+static int insert_subset_children       PROTO((splay_tree_node,\n+\t\t\t\t\t       void*));\n+static alias_set_entry get_alias_set_entry PROTO((int));\n \n /* Set up all info needed to perform alias analysis on memory references.  */\n \n #define SIZE_FOR_MODE(X) (GET_MODE_SIZE (GET_MODE (X)))\n \n-/* Perform a basic sanity check.  Namely, that there are\t\n-   no alias sets if we're not doing strict aliasing.  This helps     \n-   to catch bugs whereby someone uses PUT_CODE, but doesn't clear\n-   MEM_ALIAS_SET, or where a MEM is allocated in some way other\n-   than by the use of gen_rtx_MEM, and the MEM_ALIAS_SET is not\n-   cleared.  */\t\t\t\n-#ifdef ENABLE_CHECKING\t\n-#define CHECK_ALIAS_SETS_FOR_CONSISTENCY(MEM1, MEM2)\t\\\n-  (!flag_strict_aliasing\t\t\t\t\\\n-   && (MEM_ALIAS_SET (MEM1) || MEM_ALIAS_SET (MEM2))\t\\\n-   ? (abort (), 0) : 0)\n-#else \n-#define CHECK_ALIAS_SETS_FOR_CONSISTENCY(MEM1, MEM2) ((void)0)\n-#endif\n-\n /* Returns nonzero if MEM1 and MEM2 do not alias because they are in\n    different alias sets.  We ignore alias sets in functions making use\n    of variable arguments because the va_arg macros on some systems are\n    not legal ANSI C.  */\n #define DIFFERENT_ALIAS_SETS_P(MEM1, MEM2)\t\t\t\\\n-  (CHECK_ALIAS_SETS_FOR_CONSISTENCY(MEM1, MEM2),\t\t\\\n-   MEM_ALIAS_SET (MEM1) && MEM_ALIAS_SET (MEM2)\t\t\t\\\n-   && MEM_ALIAS_SET (MEM1) != MEM_ALIAS_SET (MEM2)\t\t\\\n-   && !current_function_stdarg && !current_function_varargs)\n+  mems_in_disjoint_alias_sets_p (MEM1, MEM2)\n \n /* Cap the number of passes we make over the insns propagating alias\n    information through set chains.\n@@ -131,6 +162,167 @@ char *reg_known_equiv_p;\n \n static int copying_arguments;\n \n+/* The splay-tree used to store the various alias set entries.  */\n+\n+static splay_tree alias_sets;\n+\n+/* Returns -1, 0, 1 according to whether SET1 is less than, equal to,\n+   or greater than SET2.  */\n+\n+static int\n+alias_set_compare (set1, set2)\n+     splay_tree_key set1;\n+     splay_tree_key set2;\n+{\n+  int s1 = (int) set1;\n+  int s2 = (int) set2;\n+\n+  if (s1 < s2)\n+    return -1;\n+  else if (s1 > s2)\n+    return 1;\n+  else \n+    return 0;\n+}\n+\n+/* Returns a pointer to the alias set entry for ALIAS_SET, if there is\n+   such an entry, or NULL otherwise.  */\n+\n+static alias_set_entry\n+get_alias_set_entry (alias_set)\n+     int alias_set;\n+{\n+  splay_tree_node sn =  \n+    splay_tree_lookup (alias_sets, (splay_tree_key) alias_set);\n+\n+  return sn ? ((alias_set_entry) sn->value) : ((alias_set_entry) 0);\n+}\n+\n+/* Returns nonzero value if the alias sets for MEM1 and MEM2 are such\n+   that the two MEMs cannot alias each other.  */\n+\n+static int \n+mems_in_disjoint_alias_sets_p (mem1, mem2)\n+     rtx mem1;\n+     rtx mem2;\n+{\n+  alias_set_entry ase;\n+\n+#ifdef ENABLE_CHECKING\t\n+/* Perform a basic sanity check.  Namely, that there are no alias sets\n+   if we're not using strict aliasing.  This helps to catch bugs\n+   whereby someone uses PUT_CODE, but doesn't clear MEM_ALIAS_SET, or\n+   where a MEM is allocated in some way other than by the use of\n+   gen_rtx_MEM, and the MEM_ALIAS_SET is not cleared.  If we begin to\n+   use alias sets to indicate that spilled registers cannot alias each\n+   other, we might need to remove this check.  */\n+  if (!flag_strict_aliasing && \n+      (MEM_ALIAS_SET (mem1) || MEM_ALIAS_SET (mem2)))\n+    abort ();\n+#endif\n+\n+  /* The code used in varargs macros are often not conforming ANSI C,\n+     which can trick the compiler into making incorrect aliasing\n+     assumptions in these functions.  So, we don't use alias sets in\n+     such a function.  FIXME: This should be moved into the front-end;\n+     it is a language-dependent notion, and there's no reason not to\n+     still use these checks to handle globals.  */\n+  if (current_function_stdarg || current_function_varargs)\n+    return 0;\n+\n+  if (!MEM_ALIAS_SET (mem1) || !MEM_ALIAS_SET (mem2))\n+    /* We have no alias set information for one of the MEMs, so we\n+       have to assume it can alias anything.  */\n+    return 0;\n+\n+  if (MEM_ALIAS_SET (mem1) == MEM_ALIAS_SET (mem2))\n+    /* The two alias sets are the same, so they may alias.  */\n+    return 0;\n+\n+  /* Iterate through each of the children of the first alias set,\n+     comparing it with the second alias set.  */\n+  ase = get_alias_set_entry (MEM_ALIAS_SET (mem1));\n+  if (ase && splay_tree_lookup (ase->children,\n+\t\t\t\t(splay_tree_key) MEM_ALIAS_SET (mem2)))\n+    return  0;\n+\n+  /* Now do the same, but with the alias sets reversed.  */\n+  ase = get_alias_set_entry (MEM_ALIAS_SET (mem2));\n+  if (ase && splay_tree_lookup (ase->children,\n+\t\t\t\t(splay_tree_key) MEM_ALIAS_SET (mem1)))\n+    return  0;\n+\n+  /* The two MEMs are in distinct alias sets, and neither one is the\n+     child of the other.  Therefore, they cannot alias.  */\n+  return 1;\n+}\n+\n+/* Insert the NODE into the splay tree given by DATA.  Used by\n+   record_alias_subset via splay_tree_foreach.  */\n+\n+static int\n+insert_subset_children (node, data)\n+     splay_tree_node node;\n+     void *data;\n+{\n+  splay_tree_insert ((splay_tree) data,\n+\t\t     node->key,\n+\t\t     node->value);\n+\n+  return 0;\n+}\n+\n+/* Indicate that things in SUBSET can alias things in SUPERSET, but\n+   not vice versa.  For example, in C, a store to an `int' can alias a\n+   structure containing an `int', but not vice versa.  Here, the\n+   structure would be the SUPERSET and `int' the SUBSET.  This\n+   function should be called only once per SUPERSET/SUBSET pair.  At\n+   present any given alias set may only be a subset of one superset.  \n+\n+   It is illegal for SUPERSET to be zero; everything is implicitly a\n+   subset of alias set zero.  */\n+\n+void\n+record_alias_subset (superset, subset)\n+     int superset;\n+     int subset;\n+{\n+  alias_set_entry superset_entry;\n+  alias_set_entry subset_entry;\n+\n+  if (superset == 0)\n+    abort ();\n+\n+  superset_entry = get_alias_set_entry (superset);\n+  if (!superset_entry) \n+    {\n+      /* Create an entry for the SUPERSET, so that we have a place to\n+\t attach the SUBSET.  */\n+      superset_entry = \n+\t(alias_set_entry) xmalloc (sizeof (struct alias_set_entry));\n+      superset_entry->alias_set = superset;\n+      superset_entry->children \n+\t= splay_tree_new (&alias_set_compare, 0, 0);\n+      splay_tree_insert (alias_sets, \n+\t\t\t (splay_tree_key) superset,\n+\t\t\t (splay_tree_value) superset_entry);\n+\n+    }\n+\n+  subset_entry = get_alias_set_entry (subset);\n+  if (subset_entry) \n+    /* There is an entry for the subset.  Enter all of its children\n+       (if they are not already present) as children of the SUPERSET.  */\n+    splay_tree_foreach (subset_entry->children,\n+\t\t\t&insert_subset_children,\n+\t\t\tsuperset_entry->children);\n+\n+  /* Enter the SUBSET itself as a child of the SUPERSET.  */\n+  splay_tree_insert (superset_entry->children, \n+\t\t     (splay_tree_key) subset,\n+\t\t     /*value=*/0);\n+}\n+\n /* Inside SRC, the source of a SET, find a base address.  */\n \n static rtx\n@@ -1063,6 +1255,8 @@ init_alias_once ()\n     if (FUNCTION_ARG_REGNO_P (OUTGOING_REGNO (i))\n \t&& HARD_REGNO_MODE_OK (i, Pmode))\n       SET_HARD_REG_BIT (argument_registers, i);\n+\n+  alias_sets = splay_tree_new (&alias_set_compare, 0, 0);\n }\n \n void"}, {"sha": "1125d5a10fe6bdb7326a19836ca9f5e63f01ed4d", "filename": "gcc/c-aux-info.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3932261a55eb9840491d2cee5bb58d6fff0533fa/gcc%2Fc-aux-info.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3932261a55eb9840491d2cee5bb58d6fff0533fa/gcc%2Fc-aux-info.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-aux-info.c?ref=3932261a55eb9840491d2cee5bb58d6fff0533fa", "patch": "@@ -478,8 +478,8 @@ gen_type (ret_val, t, style)\n         case INTEGER_TYPE:\n           data_type = IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (t)));\n           /* Normally, `unsigned' is part of the deal.  Not so if it comes\n-    \t     with `const' or `volatile'.  */\n-          if (TREE_UNSIGNED (t) && (TYPE_READONLY (t) || TYPE_VOLATILE (t)))\n+    \t     with a type qualifier.  */\n+          if (TREE_UNSIGNED (t) && TYPE_QUALS (t))\n     \t    data_type = concat (\"unsigned \", data_type);\n \t  break;\n \n@@ -503,6 +503,8 @@ gen_type (ret_val, t, style)\n     ret_val = concat (\"const \", ret_val);\n   if (TYPE_VOLATILE (t))\n     ret_val = concat (\"volatile \", ret_val);\n+  if (TYPE_RESTRICT (t))\n+    ret_val = concat (\"restrict \", ret_val);\n   return ret_val;\n }\n "}, {"sha": "4aaeb3c78182a95c04d701942b915c69f71503d5", "filename": "gcc/c-common.c", "status": "modified", "additions": 128, "deletions": 5, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3932261a55eb9840491d2cee5bb58d6fff0533fa/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3932261a55eb9840491d2cee5bb58d6fff0533fa/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=3932261a55eb9840491d2cee5bb58d6fff0533fa", "patch": "@@ -28,6 +28,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"toplev.h\"\n #include \"output.h\"\n #include \"c-pragma.h\"\n+#include \"rtl.h\"\n \n #if USE_CPPLIB\n #include \"cpplib.h\"\n@@ -66,6 +67,7 @@ static void init_attributes\t\tPROTO((void));\n static void record_function_format\tPROTO((tree, tree, enum format_type,\n \t\t\t\t\t       int, int));\n static void record_international_format\tPROTO((tree, tree, int));\n+static tree c_find_base_decl            PROTO((tree));\n \n /* Keep a stack of if statements.  We record the number of compound\n    statements seen up to the if keyword, as well as the line number\n@@ -2995,15 +2997,126 @@ get_directive_line (finput)\n    down to the element type of an array.  */\n \n tree\n-c_build_type_variant (type, constp, volatilep)\n+c_build_qualified_type (type, type_quals)\n      tree type;\n-     int constp, volatilep;\n+     int type_quals;\n {\n+  /* A restrict-qualified pointer type must be a pointer to object or\n+     incomplete type.  Note that the use of POINTER_TYPE_P also allows\n+     REFERENCE_TYPEs, which is appropriate for C++.  Unfortunately,\n+     the C++ front-end also use POINTER_TYPE for pointer-to-member\n+     values, so even though it should be illegal to use `restrict'\n+     with such an entity we don't flag that here.  Thus, special case\n+     code for that case is required in the C++ front-end.  */\n+  if ((type_quals & TYPE_QUAL_RESTRICT)\n+      && (!POINTER_TYPE_P (type)\n+\t  || !C_TYPE_OBJECT_OR_INCOMPLETE_P (TREE_TYPE (type))))\n+    {\n+      error (\"invalid use of `restrict'\");\n+      type_quals &= ~TYPE_QUAL_RESTRICT;\n+    }\n+\n   if (TREE_CODE (type) == ARRAY_TYPE)\n-    return build_array_type (c_build_type_variant (TREE_TYPE (type),\n-\t\t\t\t\t\t   constp, volatilep),\n+    return build_array_type (c_build_qualified_type (TREE_TYPE (type),\n+\t\t\t\t\t\t     type_quals),\n \t\t\t     TYPE_DOMAIN (type));\n-  return build_type_variant (type, constp, volatilep);\n+  return build_qualified_type (type, type_quals);\n+}\n+\n+/* Apply the TYPE_QUALS to the new DECL.  */\n+\n+void\n+c_apply_type_quals_to_decl (type_quals, decl)\n+     int type_quals;\n+     tree decl;\n+{\n+  if (type_quals & TYPE_QUAL_CONST)\n+    TREE_READONLY (decl) = 1;\n+  if (type_quals & TYPE_QUAL_VOLATILE)\n+    {\n+      TREE_SIDE_EFFECTS (decl) = 1;\n+      TREE_THIS_VOLATILE (decl) = 1;\n+    }\n+  if ((type_quals & TYPE_QUAL_RESTRICT) && flag_strict_aliasing)\n+    {\n+      /* No two restricted pointers can point at the same thing.\n+\t However, a restricted pointer can point at the same thing as\n+\t an unrestricted pointer, if that unrestricted pointer is\n+\t based on the restricted pointer.  So, we make the alias set\n+\t for the restricted pointer a subset of the alias set for the\n+\t type pointed to by the type of the decl.  */\n+\n+      int pointed_to_alias_set \n+\t= get_alias_set (TREE_TYPE (TREE_TYPE (decl)));\n+\n+      if (!pointed_to_alias_set)\n+\t/* It's not legal to make a subset of alias set zero.  */\n+\t    ;\n+      else\n+\t{\n+\t  DECL_POINTER_ALIAS_SET (decl) = new_alias_set ();\n+\t  record_alias_subset  (pointed_to_alias_set,\n+\t\t\t\tDECL_POINTER_ALIAS_SET (decl));\n+\t}\n+    }\n+}\n+\n+/* T is an expression with pointer type.  Find the DECL on which this\n+   expression is based.  (For example, in `a[i]' this would be `a'.)\n+   If there is no such DECL, or a unique decl cannot be determined,\n+   NULL_TREE is retured.  */\n+\n+static tree\n+c_find_base_decl (t)\n+     tree t;\n+{\n+  int i;\n+  tree decl;\n+\n+  if (t == NULL_TREE || t == error_mark_node)\n+    return NULL_TREE;\n+\n+  if (!POINTER_TYPE_P (TREE_TYPE (t)))\n+    return NULL_TREE;\n+\n+  decl = NULL_TREE;\n+\n+  if (TREE_CODE (t) == FIELD_DECL \n+      || TREE_CODE (t) == PARM_DECL\n+      || TREE_CODE (t) == VAR_DECL)\n+    /* Aha, we found a pointer-typed declaration.  */\n+    return t;\n+\n+  /* It would be nice to deal with COMPONENT_REFs here.  If we could\n+     tell that `a' and `b' were the same, then `a->f' and `b->f' are\n+     also the same.  */\n+\n+  /* Handle general expressions.  */\n+  switch (TREE_CODE_CLASS (TREE_CODE (t)))\n+    {\n+    case '1':\n+    case '2':\n+    case '3':\n+      for (i = tree_code_length [(int) TREE_CODE (t)]; --i >= 0;)\n+\t{\n+\t  tree d = c_find_base_decl (TREE_OPERAND (t, i));\n+\t  if (d)\n+\t    {\n+\t      if (!decl)\n+\t\tdecl = d;\n+\t      else if (d && d != decl)\n+\t\t/* Two different declarations.  That's confusing; let's\n+\t\t   just assume we don't know what's going on.  */\n+\t\tdecl = NULL_TREE;\n+\t    }\n+\t}\n+      break;\n+\n+    default:\n+      break;\n+    }\n+\n+  return decl;\n }\n \n /* Return the typed-based alias set for T, which may be an expression\n@@ -3044,6 +3157,16 @@ c_get_alias_set (t)\n        says that such accesses have implementation-defined behavior.  */ \n     return 0;\n \n+  if (TREE_CODE (t) == INDIRECT_REF)\n+    {\n+      /* Check for accesses through restrict-qualified pointers.  */\n+      tree decl = c_find_base_decl (TREE_OPERAND (t, 0));\n+\n+      if (decl && DECL_POINTER_ALIAS_SET_KNOWN_P (decl))\n+\t/* We use the alias set indicated in the declaration.  */\n+\treturn DECL_POINTER_ALIAS_SET (decl);\n+    }\n+\n   /* From here on, only the type matters.  */\n \n   if (TYPE_ALIAS_SET_KNOWN_P (type))"}, {"sha": "91e35104a110a9cfb3ae17967283151cb6576e26", "filename": "gcc/c-decl.c", "status": "modified", "additions": 80, "deletions": 60, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3932261a55eb9840491d2cee5bb58d6fff0533fa/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3932261a55eb9840491d2cee5bb58d6fff0533fa/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=3932261a55eb9840491d2cee5bb58d6fff0533fa", "patch": "@@ -468,6 +468,10 @@ int flag_no_nonansi_builtin;\n \n int flag_traditional;\n \n+/* Nonzero means use the ISO C9x dialect of C.  */\n+\n+int flag_isoc9x = 0;\n+\n /* Nonzero means that we have builtin functions, and main is an int */\n \n int flag_hosted = 1;\n@@ -648,6 +652,8 @@ c_decode_option (argc, argv)\n       flag_traditional = 0;\n       flag_writable_strings = 0;\n     }\n+  else if (!strcmp (p, \"-flang-isoc9x\"))\n+    flag_isoc9x = 1;\n   else if (!strcmp (p, \"-fdollars-in-identifiers\"))\n     dollars_in_ident = 1;\n   else if (!strcmp (p, \"-fno-dollars-in-identifiers\"))\n@@ -4322,7 +4328,9 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n   tree type = NULL_TREE;\n   int longlong = 0;\n   int constp;\n+  int restrictp;\n   int volatilep;\n+  int type_quals = TYPE_UNQUALIFIED;\n   int inlinep;\n   int explicit_int = 0;\n   int explicit_char = 0;\n@@ -4632,19 +4640,26 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n \ttype = build_complex_type (type);\n     }\n \n-  /* Set CONSTP if this declaration is `const', whether by\n-     explicit specification or via a typedef.\n-     Likewise for VOLATILEP.  */\n-\n+  /* Figure out the type qualifiers for the declaration.  There are\n+     two ways a declaration can become qualified.  One is something\n+     like `const int i' where the `const' is explicit.  Another is\n+     something like `typedef const int CI; CI i' where the type of the\n+     declaration contains the `const'.  */\n   constp = !! (specbits & 1 << (int) RID_CONST) + TYPE_READONLY (type);\n+  restrictp = !! (specbits & 1 << (int) RID_RESTRICT) + TYPE_RESTRICT (type);\n   volatilep = !! (specbits & 1 << (int) RID_VOLATILE) + TYPE_VOLATILE (type);\n   inlinep = !! (specbits & (1 << (int) RID_INLINE));\n   if (constp > 1)\n     pedwarn (\"duplicate `const'\");\n+  if (restrictp > 1)\n+    pedwarn (\"duplicate `restrict'\");\n   if (volatilep > 1)\n     pedwarn (\"duplicate `volatile'\");\n-  if (! flag_gen_aux_info && (TYPE_READONLY (type) || TYPE_VOLATILE (type)))\n+  if (! flag_gen_aux_info && (TYPE_QUALS (type)))\n     type = TYPE_MAIN_VARIANT (type);\n+  type_quals = ((constp ? TYPE_QUAL_CONST : 0)\n+\t\t| (restrictp ? TYPE_QUAL_RESTRICT : 0)\n+\t\t| (volatilep ? TYPE_QUAL_VOLATILE : 0));\n \n   /* Warn if two storage classes are given. Default to `auto'.  */\n \n@@ -4878,13 +4893,12 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n \t     is set correctly.  */\n \n \t  type = build_array_type (type, itype);\n-\t  if (constp || volatilep)\n-\t    type = c_build_type_variant (type, constp, volatilep);\n+\t  if (type_quals)\n+\t    type = c_build_qualified_type (type, type_quals);\n \n #if 0\t/* don't clear these; leave them set so that the array type\n \t   or the variable is itself const or volatile.  */\n-\t  constp = 0;\n-\t  volatilep = 0;\n+\t  type_quals = TYPE_UNQUALIFIED;\n #endif\n \n \t  if (size_varies)\n@@ -4949,12 +4963,11 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n \t\t\t\t      flag_traditional \n \t\t\t\t      ? NULL_TREE : arg_types);\n #endif\n-\t  /* ANSI seems to say that `const int foo ();'\n-\t     does not make the function foo const.  */\n-\t  if (constp || volatilep)\n-\t    type = c_build_type_variant (type, constp, volatilep);\n-\t  constp = 0;\n-\t  volatilep = 0;\n+\t  /* Type qualifiers before the return type of the function\n+\t     qualify the return type, not the function type.  */\n+\t  if (type_quals)\n+\t    type = c_build_qualified_type (type, type_quals);\n+\t  type_quals = TYPE_UNQUALIFIED;\n \n \t  type = build_function_type (type, arg_types);\n \t  declarator = TREE_OPERAND (declarator, 0);\n@@ -4978,12 +4991,11 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n \t     for the pointer.  */\n \n \t  if (pedantic && TREE_CODE (type) == FUNCTION_TYPE\n-\t      && (constp || volatilep))\n-\t    pedwarn (\"ANSI C forbids const or volatile function types\");\n-\t  if (constp || volatilep)\n-\t    type = c_build_type_variant (type, constp, volatilep);\n-\t  constp = 0;\n-\t  volatilep = 0;\n+\t      && type_quals)\n+\t    pedwarn (\"ANSI C forbids qualified function types\");\n+\t  if (type_quals)\n+\t    type = c_build_qualified_type (type, type_quals);\n+\t  type_quals = TYPE_UNQUALIFIED;\n \t  size_varies = 0;\n \n \t  type = build_pointer_type (type);\n@@ -4995,13 +5007,21 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n \t    {\n \t      register tree typemodlist;\n \t      int erred = 0;\n+\n+\t      constp = 0;\n+\t      volatilep = 0;\n+\t      restrictp = 0;\n \t      for (typemodlist = TREE_TYPE (declarator); typemodlist;\n \t\t   typemodlist = TREE_CHAIN (typemodlist))\n \t\t{\n-\t\t  if (TREE_VALUE (typemodlist) == ridpointers[(int) RID_CONST])\n+\t\t  tree qualifier = TREE_VALUE (typemodlist);\n+\n+\t\t  if (qualifier == ridpointers[(int) RID_CONST])\n \t\t    constp++;\n-\t\t  else if (TREE_VALUE (typemodlist) == ridpointers[(int) RID_VOLATILE])\n+\t\t  else if (qualifier == ridpointers[(int) RID_VOLATILE])\n \t\t    volatilep++;\n+\t\t  else if (qualifier == ridpointers[(int) RID_RESTRICT])\n+\t\t    restrictp++;\n \t\t  else if (!erred)\n \t\t    {\n \t\t      erred = 1;\n@@ -5012,6 +5032,12 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n \t\tpedwarn (\"duplicate `const'\");\n \t      if (volatilep > 1)\n \t\tpedwarn (\"duplicate `volatile'\");\n+\t      if (restrictp > 1)\n+\t\tpedwarn (\"duplicate `restrict'\");\n+\n+\t      type_quals = ((constp ? TYPE_QUAL_CONST : 0)\n+\t\t\t    | (restrictp ? TYPE_QUAL_RESTRICT : 0)\n+\t\t\t    | (volatilep ? TYPE_QUAL_VOLATILE : 0));\n \t    }\n \n \t  declarator = TREE_OPERAND (declarator, 0);\n@@ -5038,10 +5064,10 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n       /* Note that the grammar rejects storage classes\n \t in typenames, fields or parameters */\n       if (pedantic && TREE_CODE (type) == FUNCTION_TYPE\n-\t  && (constp || volatilep))\n-\tpedwarn (\"ANSI C forbids const or volatile function types\");\n-      if (constp || volatilep)\n-\ttype = c_build_type_variant (type, constp, volatilep);\n+\t  && type_quals)\n+\tpedwarn (\"ANSI C forbids qualified function types\");\n+      if (type_quals)\n+\ttype = c_build_qualified_type (type, type_quals);\n       decl = build_decl (TYPE_DECL, declarator, type);\n       if ((specbits & (1 << (int) RID_SIGNED))\n \t  || (typedef_decl && C_TYPEDEF_EXPLICITLY_SIGNED (typedef_decl)))\n@@ -5073,10 +5099,10 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n       /* Note that the grammar rejects storage classes\n \t in typenames, fields or parameters */\n       if (pedantic && TREE_CODE (type) == FUNCTION_TYPE\n-\t  && (constp || volatilep))\n+\t  && type_quals)\n \tpedwarn (\"ANSI C forbids const or volatile function types\");\n-      if (constp || volatilep)\n-\ttype = c_build_type_variant (type, constp, volatilep);\n+      if (type_quals)\n+\ttype = c_build_qualified_type (type, type_quals);\n       pop_obstacks ();\n       return type;\n     }\n@@ -5116,20 +5142,20 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n \t  {\n \t    /* Transfer const-ness of array into that of type pointed to.  */\n \t    type = TREE_TYPE (type);\n-\t    if (constp || volatilep)\n-\t      type = c_build_type_variant (type, constp, volatilep);\n+\t    if (type_quals)\n+\t      type = c_build_qualified_type (type, type_quals);\n \t    type = build_pointer_type (type);\n-\t    volatilep = constp = 0;\n+\t    type_quals = TYPE_UNQUALIFIED;\n \t    size_varies = 0;\n \t  }\n \telse if (TREE_CODE (type) == FUNCTION_TYPE)\n \t  {\n-\t    if (pedantic && (constp || volatilep))\n-\t      pedwarn (\"ANSI C forbids const or volatile function types\");\n-\t    if (constp || volatilep)\n-\t      type = c_build_type_variant (type, constp, volatilep);\n+\t    if (pedantic && type_quals)\n+\t      pedwarn (\"ANSI C forbids qualified function types\");\n+\t    if (type_quals)\n+\t      type = c_build_qualified_type (type, type_quals);\n \t    type = build_pointer_type (type);\n-\t    volatilep = constp = 0;\n+\t    type_quals = TYPE_UNQUALIFIED;\n \t  }\n \n \tdecl = build_decl (PARM_DECL, declarator, type);\n@@ -5177,13 +5203,13 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n \t    type = error_mark_node;\n \t  }\n \t/* Move type qualifiers down to element of an array.  */\n-\tif (TREE_CODE (type) == ARRAY_TYPE && (constp || volatilep))\n+\tif (TREE_CODE (type) == ARRAY_TYPE && type_quals)\n \t  {\n-\t    type = build_array_type (c_build_type_variant (TREE_TYPE (type),\n-\t\t\t\t\t\t\t   constp, volatilep),\n+\t    type = build_array_type (c_build_qualified_type (TREE_TYPE (type),\n+\t\t\t\t\t\t\t     type_quals),\n \t\t\t\t     TYPE_DOMAIN (type));\n #if 0 /* Leave the field const or volatile as well.  */\n-\t    constp = volatilep = 0;\n+\t    type_quals = TYPE_UNQUALIFIED;\n #endif\n \t  }\n \tdecl = build_decl (FIELD_DECL, declarator, type);\n@@ -5222,18 +5248,18 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n \tdecl = build_decl (FUNCTION_DECL, declarator, type);\n \tdecl = build_decl_attribute_variant (decl, decl_machine_attr);\n \n-\tif (pedantic && (constp || volatilep)\n-\t    && ! DECL_IN_SYSTEM_HEADER (decl))\n-\t  pedwarn (\"ANSI C forbids const or volatile functions\");\n+\tif (pedantic && type_quals && ! DECL_IN_SYSTEM_HEADER (decl))\n+\t  pedwarn (\"ANSI C forbids qualified function types\");\n \n \tif (pedantic\n \t    && TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (decl))) == void_type_node\n-\t    && (TYPE_READONLY (TREE_TYPE (TREE_TYPE (decl)))\n-\t\t|| TYPE_VOLATILE (TREE_TYPE (TREE_TYPE (decl))))\n+\t    && TYPE_QUALS (TREE_TYPE (TREE_TYPE (decl)))\n \t    && ! DECL_IN_SYSTEM_HEADER (decl))\n-\t  pedwarn (\"ANSI C forbids const or volatile void function return type\");\n+\t  pedwarn (\"ANSI C forbids qualified void function return type\");\n \n-\tif (volatilep\n+\t/* GNU C interprets a `volatile void' return type to indicate\n+\t   that the function does not return.  */\n+\tif ((type_quals & TYPE_QUAL_VOLATILE)\n \t    && TREE_TYPE (TREE_TYPE (decl)) != void_type_node)\n \t  warning (\"`noreturn' function returns non-void value\");\n \n@@ -5263,13 +5289,13 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n \tint extern_ref = !initialized && (specbits & (1 << (int) RID_EXTERN));\n \n \t/* Move type qualifiers down to element of an array.  */\n-\tif (TREE_CODE (type) == ARRAY_TYPE && (constp || volatilep))\n+\tif (TREE_CODE (type) == ARRAY_TYPE && type_quals)\n \t  {\n-\t    type = build_array_type (c_build_type_variant (TREE_TYPE (type),\n-\t\t\t\t\t\t\t   constp, volatilep),\n+\t    type = build_array_type (c_build_qualified_type (TREE_TYPE (type),\n+\t\t\t\t\t\t\t     type_quals),\n \t\t\t\t     TYPE_DOMAIN (type));\n #if 0 /* Leave the variable const or volatile as well.  */\n-\t    constp = volatilep = 0;\n+\t    type_quals = TYPE_UNQUALIFIED;\n #endif\n \t  }\n \n@@ -5316,14 +5342,8 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n       DECL_REGISTER (decl) = 1;\n \n     /* Record constancy and volatility.  */\n+    c_apply_type_quals_to_decl (type_quals, decl);\n \n-    if (constp)\n-      TREE_READONLY (decl) = 1;\n-    if (volatilep)\n-      {\n-\tTREE_SIDE_EFFECTS (decl) = 1;\n-\tTREE_THIS_VOLATILE (decl) = 1;\n-      }\n     /* If a type has volatile components, it should be stored in memory.\n        Otherwise, the fact that those components are volatile\n        will be ignored, and would even crash the compiler.  */"}, {"sha": "7ee506085ce552ef36755bcae89b863c426d938a", "filename": "gcc/c-gperf.h", "status": "modified", "additions": 111, "deletions": 119, "changes": 230, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3932261a55eb9840491d2cee5bb58d6fff0533fa/gcc%2Fc-gperf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3932261a55eb9840491d2cee5bb58d6fff0533fa/gcc%2Fc-gperf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-gperf.h?ref=3932261a55eb9840491d2cee5bb58d6fff0533fa", "patch": "@@ -1,14 +1,14 @@\n /* KR-C code produced by gperf version 2.7.1 (19981006 egcs) */\n-/* Command-line: gperf -L KR-C -F , 0, 0 -p -j1 -i 1 -g -o -t -G -N is_reserved_word -k1,3,$ /hurl/puke/law/egcs/egcs/gcc/c-parse.gperf  */\n+/* Command-line: gperf -L KR-C -F , 0, 0 -p -j1 -i 1 -g -o -t -G -N is_reserved_word -k1,3,$ ../../gcc/c-parse.gperf  */\n /* Command-line: gperf -L KR-C -F ', 0, 0' -p -j1 -i 1 -g -o -t -N is_reserved_word -k1,3,$ c-parse.gperf  */ \n struct resword { char *name; short token; enum rid rid; };\n \n-#define TOTAL_KEYWORDS 80\n+#define TOTAL_KEYWORDS 83\n #define MIN_WORD_LENGTH 2\n #define MAX_WORD_LENGTH 20\n-#define MIN_HASH_VALUE 10\n-#define MAX_HASH_VALUE 162\n-/* maximum key range = 153, duplicates = 0 */\n+#define MIN_HASH_VALUE 8\n+#define MAX_HASH_VALUE 141\n+/* maximum key range = 134, duplicates = 0 */\n \n #ifdef __GNUC__\n __inline\n@@ -20,32 +20,32 @@ hash (str, len)\n {\n   static unsigned char asso_values[] =\n     {\n-      163, 163, 163, 163, 163, 163, 163, 163, 163, 163,\n-      163, 163, 163, 163, 163, 163, 163, 163, 163, 163,\n-      163, 163, 163, 163, 163, 163, 163, 163, 163, 163,\n-      163, 163, 163, 163, 163, 163, 163, 163, 163, 163,\n-      163, 163, 163, 163, 163, 163, 163, 163, 163, 163,\n-      163, 163, 163, 163, 163, 163, 163, 163, 163, 163,\n-      163, 163, 163, 163,   8, 163, 163, 163, 163, 163,\n-      163, 163, 163, 163, 163, 163, 163, 163, 163, 163,\n-      163, 163, 163, 163, 163, 163, 163, 163, 163, 163,\n-      163, 163, 163, 163, 163,   1, 163,  24,   8,  61,\n-       37,   6,  47,  49,   2,   5, 163,   3,  51,  30,\n-       58,  91,  35, 163,  33,  13,   1,  18,  49,   2,\n-        2,   5,   3, 163, 163, 163, 163, 163, 163, 163,\n-      163, 163, 163, 163, 163, 163, 163, 163, 163, 163,\n-      163, 163, 163, 163, 163, 163, 163, 163, 163, 163,\n-      163, 163, 163, 163, 163, 163, 163, 163, 163, 163,\n-      163, 163, 163, 163, 163, 163, 163, 163, 163, 163,\n-      163, 163, 163, 163, 163, 163, 163, 163, 163, 163,\n-      163, 163, 163, 163, 163, 163, 163, 163, 163, 163,\n-      163, 163, 163, 163, 163, 163, 163, 163, 163, 163,\n-      163, 163, 163, 163, 163, 163, 163, 163, 163, 163,\n-      163, 163, 163, 163, 163, 163, 163, 163, 163, 163,\n-      163, 163, 163, 163, 163, 163, 163, 163, 163, 163,\n-      163, 163, 163, 163, 163, 163, 163, 163, 163, 163,\n-      163, 163, 163, 163, 163, 163, 163, 163, 163, 163,\n-      163, 163, 163, 163, 163, 163\n+      142, 142, 142, 142, 142, 142, 142, 142, 142, 142,\n+      142, 142, 142, 142, 142, 142, 142, 142, 142, 142,\n+      142, 142, 142, 142, 142, 142, 142, 142, 142, 142,\n+      142, 142, 142, 142, 142, 142, 142, 142, 142, 142,\n+      142, 142, 142, 142, 142, 142, 142, 142, 142, 142,\n+      142, 142, 142, 142, 142, 142, 142, 142, 142, 142,\n+      142, 142, 142, 142,  35, 142, 142, 142, 142, 142,\n+      142, 142, 142, 142, 142, 142, 142, 142, 142, 142,\n+      142, 142, 142, 142, 142, 142, 142, 142, 142, 142,\n+      142, 142, 142, 142, 142,   1, 142,  90,   1,  28,\n+       40,   6,   1,  24,   3,  13, 142,  36,  60,  14,\n+       49,   3,   6, 142,  19,   8,   1,  50,  33,  11,\n+        2,  23,   4, 142, 142, 142, 142, 142, 142, 142,\n+      142, 142, 142, 142, 142, 142, 142, 142, 142, 142,\n+      142, 142, 142, 142, 142, 142, 142, 142, 142, 142,\n+      142, 142, 142, 142, 142, 142, 142, 142, 142, 142,\n+      142, 142, 142, 142, 142, 142, 142, 142, 142, 142,\n+      142, 142, 142, 142, 142, 142, 142, 142, 142, 142,\n+      142, 142, 142, 142, 142, 142, 142, 142, 142, 142,\n+      142, 142, 142, 142, 142, 142, 142, 142, 142, 142,\n+      142, 142, 142, 142, 142, 142, 142, 142, 142, 142,\n+      142, 142, 142, 142, 142, 142, 142, 142, 142, 142,\n+      142, 142, 142, 142, 142, 142, 142, 142, 142, 142,\n+      142, 142, 142, 142, 142, 142, 142, 142, 142, 142,\n+      142, 142, 142, 142, 142, 142, 142, 142, 142, 142,\n+      142, 142, 142, 142, 142, 142\n     };\n   register int hval = len;\n \n@@ -64,120 +64,112 @@ hash (str, len)\n \n static struct resword wordlist[] =\n   {\n-    {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n+    {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n+    {\"out\", TYPE_QUAL, RID_OUT},\n     {\"\", 0, 0},\n-    {\"int\", TYPESPEC, RID_INT},\n-    {\"\", 0, 0}, {\"\", 0, 0},\n-    {\"__typeof__\", TYPEOF, NORID},\n+    {\"float\", TYPESPEC, RID_FLOAT},\n+    {\"__typeof\", TYPEOF, NORID},\n     {\"\", 0, 0},\n+    {\"__typeof__\", TYPEOF, NORID},\n+    {\"typeof\", TYPEOF, NORID},\n+    {\"typedef\", SCSPEC, RID_TYPEDEF},\n+    {\"if\", IF, NORID},\n+    {\"short\", TYPESPEC, RID_SHORT},\n+    {\"int\", TYPESPEC, RID_INT},\n+    {\"sizeof\", SIZEOF, NORID},\n+    {\"__signed__\", TYPESPEC, RID_SIGNED},\n+    {\"__extension__\", EXTENSION, NORID},\n+    {\"inout\", TYPE_QUAL, RID_INOUT},\n     {\"__imag__\", IMAGPART, NORID},\n-    {\"\", 0, 0},\n+    {\"else\", ELSE, NORID},\n     {\"__inline__\", SCSPEC, RID_INLINE},\n-    {\"while\", WHILE, NORID},\n+    {\"byref\", TYPE_QUAL, RID_BYREF},\n     {\"__iterator__\", SCSPEC, RID_ITERATOR},\n     {\"__inline\", SCSPEC, RID_INLINE},\n-    {\"__extension__\", EXTENSION, NORID},\n-    {\"break\", BREAK, NORID},\n-    {\"\", 0, 0}, {\"\", 0, 0},\n-    {\"__signed__\", TYPESPEC, RID_SIGNED},\n-    {\"switch\", SWITCH, NORID},\n-    {\"\", 0, 0}, {\"\", 0, 0},\n-    {\"else\", ELSE, NORID},\n-    {\"\", 0, 0}, {\"\", 0, 0},\n-    {\"@defs\", DEFS, NORID},\n-    {\"__asm__\", ASM_KEYWORD, NORID},\n-    {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n-    {\"__alignof__\", ALIGNOF, NORID},\n-    {\"\", 0, 0},\n-    {\"__attribute__\", ATTRIBUTE, NORID},\n-    {\"\", 0, 0}, {\"\", 0, 0},\n-    {\"__attribute\", ATTRIBUTE, NORID},\n     {\"__real__\", REALPART, NORID},\n-    {\"id\", OBJECTNAME, RID_ID},\n-    {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n-    {\"__iterator\", SCSPEC, RID_ITERATOR},\n-    {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n+    {\"switch\", SWITCH, NORID},\n+    {\"__restrict\", TYPE_QUAL, RID_RESTRICT},\n+    {\"goto\", GOTO, NORID},\n+    {\"__restrict__\", TYPE_QUAL, RID_RESTRICT},\n     {\"struct\", STRUCT, NORID},\n-    {\"if\", IF, NORID},\n-    {\"@private\", PRIVATE, NORID},\n-    {\"@selector\", SELECTOR, NORID},\n-    {\"__typeof\", TYPEOF, NORID},\n-    {\"enum\", ENUM, NORID},\n-    {\"__signed\", TYPESPEC, RID_SIGNED},\n-    {\"__asm\", ASM_KEYWORD, NORID},\n-    {\"__imag\", IMAGPART, NORID},\n-    {\"__label__\", LABEL, NORID},\n-    {\"__volatile__\", TYPE_QUAL, RID_VOLATILE},\n-    {\"\", 0, 0},\n-    {\"in\", TYPE_QUAL, RID_IN},\n-    {\"__volatile\", TYPE_QUAL, RID_VOLATILE},\n-    {\"double\", TYPESPEC, RID_DOUBLE},\n-    {\"inline\", SCSPEC, RID_INLINE},\n-    {\"sizeof\", SIZEOF, NORID},\n+    {\"while\", WHILE, NORID},\n+    {\"restrict\", TYPE_QUAL, RID_RESTRICT},\n     {\"__const\", TYPE_QUAL, RID_CONST},\n-    {\"extern\", SCSPEC, RID_EXTERN},\n+    {\"oneway\", TYPE_QUAL, RID_ONEWAY},\n     {\"__const__\", TYPE_QUAL, RID_CONST},\n     {\"__complex\", TYPESPEC, RID_COMPLEX},\n     {\"__complex__\", TYPESPEC, RID_COMPLEX},\n+    {\"for\", FOR, NORID},\n+    {\"__iterator\", SCSPEC, RID_ITERATOR},\n+    {\"__imag\", IMAGPART, NORID},\n+    {\"do\", DO, NORID},\n+    {\"case\", CASE, NORID},\n+    {\"__volatile__\", TYPE_QUAL, RID_VOLATILE},\n+    {\"break\", BREAK, NORID},\n+    {\"default\", DEFAULT, NORID},\n+    {\"__volatile\", TYPE_QUAL, RID_VOLATILE},\n+    {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n+    {\"@defs\", DEFS, NORID},\n+    {\"id\", OBJECTNAME, RID_ID},\n     {\"\", 0, 0},\n-    {\"unsigned\", TYPESPEC, RID_UNSIGNED},\n-    {\"\", 0, 0},\n-    {\"@class\", CLASS, NORID},\n-    {\"@encode\", ENCODE, NORID},\n+    {\"__signed\", TYPESPEC, RID_SIGNED},\n     {\"bycopy\", TYPE_QUAL, RID_BYCOPY},\n-    {\"__alignof\", ALIGNOF, NORID},\n-    {\"@interface\", INTERFACE, NORID},\n+    {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n+    {\"extern\", SCSPEC, RID_EXTERN},\n     {\"\", 0, 0},\n-    {\"case\", CASE, NORID},\n+    {\"in\", TYPE_QUAL, RID_IN},\n     {\"\", 0, 0},\n-    {\"union\", UNION, NORID},\n-    {\"asm\", ASM_KEYWORD, NORID},\n-    {\"@protected\", PROTECTED, NORID},\n-    {\"typeof\", TYPEOF, NORID},\n-    {\"typedef\", SCSPEC, RID_TYPEDEF},\n-    {\"__real\", REALPART, NORID},\n-    {\"default\", DEFAULT, NORID},\n-    {\"byref\", TYPE_QUAL, RID_BYREF},\n-    {\"@public\", PUBLIC, NORID},\n-    {\"void\", TYPESPEC, RID_VOID},\n-    {\"out\", TYPE_QUAL, RID_OUT},\n+    {\"@compatibility_alias\", ALIAS, NORID},\n     {\"\", 0, 0},\n+    {\"@private\", PRIVATE, NORID},\n+    {\"@selector\", SELECTOR, NORID},\n+    {\"register\", SCSPEC, RID_REGISTER},\n+    {\"__label__\", LABEL, NORID},\n+    {\"\", 0, 0}, {\"\", 0, 0},\n+    {\"enum\", ENUM, NORID},\n     {\"return\", RETURN, NORID},\n     {\"\", 0, 0}, {\"\", 0, 0},\n-    {\"@protocol\", PROTOCOL, NORID},\n-    {\"inout\", TYPE_QUAL, RID_INOUT},\n-    {\"\", 0, 0},\n-    {\"static\", SCSPEC, RID_STATIC},\n     {\"signed\", TYPESPEC, RID_SIGNED},\n+    {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n+    {\"const\", TYPE_QUAL, RID_CONST},\n     {\"\", 0, 0},\n-    {\"@end\", END, NORID},\n-    {\"oneway\", TYPE_QUAL, RID_ONEWAY},\n-    {\"\", 0, 0},\n-    {\"short\", TYPESPEC, RID_SHORT},\n+    {\"inline\", SCSPEC, RID_INLINE},\n+    {\"__real\", REALPART, NORID},\n+    {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n+    {\"void\", TYPESPEC, RID_VOID},\n+    {\"continue\", CONTINUE, NORID},\n+    {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n+    {\"@encode\", ENCODE, NORID},\n+    {\"auto\", SCSPEC, RID_AUTO},\n+    {\"__asm__\", ASM_KEYWORD, NORID},\n+    {\"@interface\", INTERFACE, NORID},\n+    {\"__alignof\", ALIGNOF, NORID},\n+    {\"double\", TYPESPEC, RID_DOUBLE},\n+    {\"__alignof__\", ALIGNOF, NORID},\n+    {\"@protected\", PROTECTED, NORID},\n+    {\"__attribute__\", ATTRIBUTE, NORID},\n+    {\"unsigned\", TYPESPEC, RID_UNSIGNED},\n+    {\"volatile\", TYPE_QUAL, RID_VOLATILE},\n+    {\"__attribute\", ATTRIBUTE, NORID},\n+    {\"@class\", CLASS, NORID},\n+    {\"__asm\", ASM_KEYWORD, NORID},\n+    {\"\", 0, 0}, {\"\", 0, 0},\n     {\"@implementation\", IMPLEMENTATION, NORID},\n+    {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n+    {\"union\", UNION, NORID},\n     {\"\", 0, 0}, {\"\", 0, 0},\n-    {\"volatile\", TYPE_QUAL, RID_VOLATILE},\n+    {\"@public\", PUBLIC, NORID},\n+    {\"asm\", ASM_KEYWORD, NORID},\n     {\"\", 0, 0},\n-    {\"for\", FOR, NORID},\n+    {\"@protocol\", PROTOCOL, NORID},\n+    {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n+    {\"@end\", END, NORID},\n     {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n-    {\"auto\", SCSPEC, RID_AUTO},\n-    {\"\", 0, 0},\n-    {\"char\", TYPESPEC, RID_CHAR},\n-    {\"register\", SCSPEC, RID_REGISTER},\n-    {\"\", 0, 0},\n-    {\"const\", TYPE_QUAL, RID_CONST},\n+    {\"static\", SCSPEC, RID_STATIC},\n     {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n-    {\"do\", DO, NORID},\n-    {\"\", 0, 0},\n-    {\"@compatibility_alias\", ALIAS, NORID},\n-    {\"continue\", CONTINUE, NORID},\n-    {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n-    {\"\", 0, 0},\n-    {\"float\", TYPESPEC, RID_FLOAT},\n-    {\"goto\", GOTO, NORID},\n-    {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n-    {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n-    {\"long\", TYPESPEC, RID_LONG}\n+    {\"long\", TYPESPEC, RID_LONG},\n+    {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n+    {\"char\", TYPESPEC, RID_CHAR}\n   };\n \n #ifdef __GNUC__"}, {"sha": "10e91216f665c44eeb9da935f979a15c5f20449e", "filename": "gcc/c-lex.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3932261a55eb9840491d2cee5bb58d6fff0533fa/gcc%2Fc-lex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3932261a55eb9840491d2cee5bb58d6fff0533fa/gcc%2Fc-lex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lex.c?ref=3932261a55eb9840491d2cee5bb58d6fff0533fa", "patch": "@@ -245,6 +245,7 @@ init_lex ()\n   ridpointers[(int) RID_SIGNED] = get_identifier (\"signed\");\n   ridpointers[(int) RID_INLINE] = get_identifier (\"inline\");\n   ridpointers[(int) RID_CONST] = get_identifier (\"const\");\n+  ridpointers[(int) RID_RESTRICT] = get_identifier (\"restrict\");\n   ridpointers[(int) RID_VOLATILE] = get_identifier (\"volatile\");\n   ridpointers[(int) RID_AUTO] = get_identifier (\"auto\");\n   ridpointers[(int) RID_STATIC] = get_identifier (\"static\");\n@@ -274,13 +275,17 @@ init_lex ()\n   if (flag_traditional)\n     {\n       UNSET_RESERVED_WORD (\"const\");\n+      UNSET_RESERVED_WORD (\"restrict\");\n       UNSET_RESERVED_WORD (\"volatile\");\n       UNSET_RESERVED_WORD (\"typeof\");\n       UNSET_RESERVED_WORD (\"signed\");\n       UNSET_RESERVED_WORD (\"inline\");\n       UNSET_RESERVED_WORD (\"iterator\");\n       UNSET_RESERVED_WORD (\"complex\");\n     }\n+  else if (!flag_isoc9x)\n+    UNSET_RESERVED_WORD (\"restrict\");\n+\n   if (flag_no_asm)\n     {\n       UNSET_RESERVED_WORD (\"asm\");"}, {"sha": "3aaa3a00c52b3667a9d00714fd8263a2658e57e2", "filename": "gcc/c-lex.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3932261a55eb9840491d2cee5bb58d6fff0533fa/gcc%2Fc-lex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3932261a55eb9840491d2cee5bb58d6fff0533fa/gcc%2Fc-lex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lex.h?ref=3932261a55eb9840491d2cee5bb58d6fff0533fa", "patch": "@@ -40,6 +40,7 @@ enum rid\n   RID_TYPEDEF,\n   RID_SIGNED,\n   RID_CONST,\n+  RID_RESTRICT,\n   RID_VOLATILE,\n   RID_INLINE,\n   RID_NOALIAS,"}, {"sha": "c20d2a00511ae49d38b73734e0e61ec93801e0f6", "filename": "gcc/c-parse.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3932261a55eb9840491d2cee5bb58d6fff0533fa/gcc%2Fc-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3932261a55eb9840491d2cee5bb58d6fff0533fa/gcc%2Fc-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parse.c?ref=3932261a55eb9840491d2cee5bb58d6fff0533fa", "patch": "@@ -1164,7 +1164,7 @@ static const short yycheck[] = {    38,\n     52\n };\n /* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */\n-#line 3 \"/usr/cygnus/progressive-98r1/share/bison.simple\"\n+#line 3 \"/usr/lib/bison.simple\"\n \n /* Skeleton output parser for bison,\n    Copyright (C) 1984, 1989, 1990 Free Software Foundation, Inc.\n@@ -1357,7 +1357,7 @@ __yy_memcpy (char *to, char *from, int count)\n #endif\n #endif\n \f\n-#line 196 \"/usr/cygnus/progressive-98r1/share/bison.simple\"\n+#line 196 \"/usr/lib/bison.simple\"\n \n /* The user can define YYPARSE_PARAM as the name of an argument to be passed\n    into yyparse.  The argument should have type void *.\n@@ -3676,7 +3676,7 @@ case 401:\n     break;}\n }\n    /* the action file gets copied in in place of this dollarsign */\n-#line 498 \"/usr/cygnus/progressive-98r1/share/bison.simple\"\n+#line 498 \"/usr/lib/bison.simple\"\n \f\n   yyvsp -= yylen;\n   yyssp -= yylen;"}, {"sha": "324bd249554082e30d10054e6eb1a1d30d0bdf35", "filename": "gcc/c-parse.gperf", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3932261a55eb9840491d2cee5bb58d6fff0533fa/gcc%2Fc-parse.gperf", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3932261a55eb9840491d2cee5bb58d6fff0533fa/gcc%2Fc-parse.gperf", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parse.gperf?ref=3932261a55eb9840491d2cee5bb58d6fff0533fa", "patch": "@@ -35,6 +35,8 @@ __iterator__, SCSPEC, RID_ITERATOR\n __label__, LABEL, NORID\n __real, REALPART, NORID\n __real__, REALPART, NORID\n+__restrict, TYPE_QUAL, RID_RESTRICT\n+__restrict__, TYPE_QUAL, RID_RESTRICT\n __signed, TYPESPEC, RID_SIGNED\n __signed__, TYPESPEC, RID_SIGNED\n __typeof, TYPEOF, NORID\n@@ -69,6 +71,7 @@ long, TYPESPEC, RID_LONG\n oneway, TYPE_QUAL, RID_ONEWAY\n out, TYPE_QUAL, RID_OUT\n register, SCSPEC, RID_REGISTER\n+restrict, TYPE_QUAL, RID_RESTRICT\n return, RETURN, NORID\n short, TYPESPEC, RID_SHORT\n signed, TYPESPEC, RID_SIGNED"}, {"sha": "88a308c118cdd2788fb31314314c8c093045bd79", "filename": "gcc/c-parse.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3932261a55eb9840491d2cee5bb58d6fff0533fa/gcc%2Fc-parse.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3932261a55eb9840491d2cee5bb58d6fff0533fa/gcc%2Fc-parse.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parse.in?ref=3932261a55eb9840491d2cee5bb58d6fff0533fa", "patch": "@@ -116,7 +116,7 @@ end ifc\n    yylval contains an IDENTIFIER_NODE which indicates which one.  */\n %token TYPESPEC\n \n-/* Reserved words that qualify type: \"const\" or \"volatile\".\n+/* Reserved words that qualify type: \"const\", \"volatile\", or \"restrict\".\n    yylval contains an IDENTIFIER_NODE which indicates which one.  */\n %token TYPE_QUAL\n "}, {"sha": "99cf1675c009797ddcda84dbf84f73e400f37045", "filename": "gcc/c-parse.y", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3932261a55eb9840491d2cee5bb58d6fff0533fa/gcc%2Fc-parse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3932261a55eb9840491d2cee5bb58d6fff0533fa/gcc%2Fc-parse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parse.y?ref=3932261a55eb9840491d2cee5bb58d6fff0533fa", "patch": "@@ -104,7 +104,7 @@ char *language_string = \"GNU C\";\n    yylval contains an IDENTIFIER_NODE which indicates which one.  */\n %token TYPESPEC\n \n-/* Reserved words that qualify type: \"const\" or \"volatile\".\n+/* Reserved words that qualify type: \"const\", \"volatile\", or \"restrict\".\n    yylval contains an IDENTIFIER_NODE which indicates which one.  */\n %token TYPE_QUAL\n "}, {"sha": "5ba7409c7c39bfadb3bf017e0ef0fcdb292099ab", "filename": "gcc/c-tree.h", "status": "modified", "additions": 26, "deletions": 1, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3932261a55eb9840491d2cee5bb58d6fff0533fa/gcc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3932261a55eb9840491d2cee5bb58d6fff0533fa/gcc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-tree.h?ref=3932261a55eb9840491d2cee5bb58d6fff0533fa", "patch": "@@ -80,6 +80,22 @@ extern int pedantic;\n    nonzero if the definition of the type has already started.  */\n #define C_TYPE_BEING_DEFINED(type) TYPE_LANG_FLAG_0 (type)\n \n+/* C types are partitioned into three subsets: object, function, and\n+   incomplete types.  */\n+#define C_TYPE_OBJECT_P(type) \\\n+  (TREE_CODE (type) != FUNCTION_TYPE && TYPE_SIZE (type))\n+\n+#define C_TYPE_FUNCTION_P(type) \\\n+  (TREE_CODE (type) == FUNCTION_TYPE)\n+\n+#define C_TYPE_INCOMPLETE_P(type) \\\n+  (TREE_CODE (type) != FUNCTION_TYPE && TYPE_SIZE (type) == 0)\n+\n+/* For convenience we define a single macro to identify the class of\n+   object or incomplete types.  */\n+#define C_TYPE_OBJECT_OR_INCOMPLETE_P(type) \\\n+  (!C_TYPE_FUNCTION_P (type))\n+\n /* In a RECORD_TYPE, a sorted array of the fields of the type.  */\n struct lang_type\n {\n@@ -165,6 +181,7 @@ extern void decl_attributes                     PROTO((tree, tree, tree));\n extern void init_function_format_info\t\tPROTO((void));\n extern void check_function_format\t\tPROTO((tree, tree, tree));\n extern int c_get_alias_set                      PROTO((tree));\n+extern void c_apply_type_quals_to_decl          PROTO((int, tree));\n /* Print an error message for invalid operands to arith operation CODE.\n    NOP_EXPR is used as a special case (see truthvalue_conversion).  */\n extern void binary_op_error                     PROTO((enum tree_code));\n@@ -267,7 +284,11 @@ extern tree build_enumerator                    PROTO((tree, tree));\n /* Declare a predefined function.  Return the declaration.  */\n extern tree builtin_function                    PROTO((char *, tree, enum built_in_function function_, char *));\n /* Add qualifiers to a type, in the fashion for C.  */\n-extern tree c_build_type_variant                PROTO((tree, int, int));\n+extern tree c_build_qualified_type              PROTO((tree, int));\n+#define c_build_type_variant(TYPE, CONST_P, VOLATILE_P)\t\t  \\\n+  c_build_qualified_type (TYPE, \t\t\t\t  \\\n+\t\t\t  ((CONST_P) ? TYPE_QUAL_CONST : 0) |\t  \\\n+\t\t\t  ((VOLATILE_P) ? TYPE_QUAL_VOLATILE : 0))\n extern int  c_decode_option                     PROTO((int, char **));\n extern void c_mark_varargs                      PROTO((void));\n extern tree check_identifier                    PROTO((tree, tree));\n@@ -497,6 +518,10 @@ extern int warn_main;\n \n extern int flag_traditional;\n \n+/* Nonzero means use the ISO C9x dialect of C.  */\n+\n+extern int flag_isoc9x;\n+\n /* Nonzero means to allow single precision math even if we're generally\n    being traditional. */\n extern int flag_allow_single_precision;"}, {"sha": "caf2bf53c9a69678c1ce0d312908bccf72770ad3", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 42, "deletions": 59, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3932261a55eb9840491d2cee5bb58d6fff0533fa/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3932261a55eb9840491d2cee5bb58d6fff0533fa/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=3932261a55eb9840491d2cee5bb58d6fff0533fa", "patch": "@@ -163,9 +163,7 @@ static tree\n qualify_type (type, like)\n      tree type, like;\n {\n-  int constflag = TYPE_READONLY (type) || TYPE_READONLY (like);\n-  int volflag = TYPE_VOLATILE (type) || TYPE_VOLATILE (like);\n-  return c_build_type_variant (type, constflag, volflag);\n+  return c_build_qualified_type (type, TYPE_QUALS (like));\n }\n \f\n /* Return the common type of two types.\n@@ -283,14 +281,14 @@ common_type (t1, t2)\n \t But ANSI C specifies doing this with the qualifiers.\n \t So I turned it on again.  */\n       {\n-\ttree target = common_type (TYPE_MAIN_VARIANT (TREE_TYPE (t1)),\n-\t\t\t\t   TYPE_MAIN_VARIANT (TREE_TYPE (t2)));\n-\tint constp\n-\t  = TYPE_READONLY (TREE_TYPE (t1)) || TYPE_READONLY (TREE_TYPE (t2));\n-\tint volatilep\n-\t  = TYPE_VOLATILE (TREE_TYPE (t1)) || TYPE_VOLATILE (TREE_TYPE (t2));\n-\tt1 = build_pointer_type (c_build_type_variant (target, constp,\n-\t\t\t\t volatilep));\n+\ttree pointed_to_1 = TREE_TYPE (t1);\n+\ttree pointed_to_2 = TREE_TYPE (t2);\n+\ttree target = common_type (TYPE_MAIN_VARIANT (pointed_to_1),\n+\t\t\t\t   TYPE_MAIN_VARIANT (pointed_to_2));\n+\tt1 = build_pointer_type (c_build_qualified_type \n+\t\t\t\t (target, \n+\t\t\t\t  TYPE_QUALS (pointed_to_1) | \n+\t\t\t\t  TYPE_QUALS (pointed_to_2)));\n \treturn build_type_attribute_variant (t1, attributes);\n       }\n #if 0\n@@ -447,9 +445,7 @@ comptypes (type1, type2)\n \n   /* Qualifiers must match.  */\n \n-  if (TYPE_READONLY (t1) != TYPE_READONLY (t2))\n-    return 0;\n-  if (TYPE_VOLATILE (t1) != TYPE_VOLATILE (t2))\n+  if (TYPE_QUALS (t1) != TYPE_QUALS (t2))\n     return 0;\n \n   /* Allow for two different type nodes which have essentially the same\n@@ -1084,11 +1080,12 @@ default_conversion (exp)\n \t  volatilep = TREE_THIS_VOLATILE (exp);\n \t}\n \n-      if (TYPE_READONLY (type) || TYPE_VOLATILE (type)\n-\t  || constp || volatilep)\n-\trestype = c_build_type_variant (restype,\n-\t\t\t\t\tTYPE_READONLY (type) || constp,\n-\t\t\t\t\tTYPE_VOLATILE (type) || volatilep);\n+      if (TYPE_QUALS (type) || constp || volatilep)\n+\trestype \n+\t  = c_build_qualified_type (restype,\n+\t\t\t\t    TYPE_QUALS (type) \n+\t\t\t\t    | (constp * TYPE_QUAL_CONST)\n+\t\t\t\t    | (volatilep * TYPE_QUAL_VOLATILE));\n \n       if (TREE_CODE (exp) == INDIRECT_REF)\n \treturn convert (TYPE_POINTER_TO (restype),\n@@ -3080,8 +3077,10 @@ build_unary_op (code, xarg, noconvert)\n \n       /* Ordinary case; arg is a COMPONENT_REF or a decl.  */\n       argtype = TREE_TYPE (arg);\n-      /* If the lvalue is const or volatile,\n-\t merge that into the type that the address will point to.  */\n+      /* If the lvalue is const or volatile, merge that into the type\n+         to which the address will point.  Note that you can't get a\n+\t restricted pointer by taking the address of something, so we\n+\t only have to deal with `const' and `volatile' here.  */\n       if (TREE_CODE_CLASS (TREE_CODE (arg)) == 'd'\n \t  || TREE_CODE_CLASS (TREE_CODE (arg)) == 'r')\n \t{\n@@ -3779,11 +3778,11 @@ build_c_cast (type, expr)\n \t    in_type = TREE_TYPE (in_type);\n \t  while (TREE_CODE (in_otype) == POINTER_TYPE)\n \t    in_otype = TREE_TYPE (in_otype);\n-\t    \n-\t  if (TYPE_VOLATILE (in_otype) && ! TYPE_VOLATILE (in_type))\n-\t    pedwarn (\"cast discards `volatile' from pointer target type\");\n-\t  if (TYPE_READONLY (in_otype) && ! TYPE_READONLY (in_type))\n-\t    pedwarn (\"cast discards `const' from pointer target type\");\n+\t  \n+\t  if (TYPE_QUALS (in_otype) & ~TYPE_QUALS (in_type))\n+\t    /* There are qualifiers present in IN_OTYPE that are not\n+\t       present in IN_TYPE.  */\n+\t    pedwarn (\"cast discards qualifiers from pointer target type\");\n \t}\n \n       /* Warn about possible alignment problems.  */\n@@ -4114,12 +4113,13 @@ convert_for_assignment (type, rhs, errtype, fundecl, funname, parmnum)\n \t\t  || comp_target_types (memb_type, rhstype))\n \t\t{\n \t\t  /* If this type won't generate any warnings, use it.  */\n-\t\t  if ((TREE_CODE (ttr) == FUNCTION_TYPE\n-\t\t       && TREE_CODE (ttl) == FUNCTION_TYPE)\n-\t\t      ? ((! TYPE_READONLY (ttl) | TYPE_READONLY (ttr))\n-\t\t\t & (! TYPE_VOLATILE (ttl) | TYPE_VOLATILE (ttr)))\n-\t\t      : ((TYPE_READONLY (ttl) | ! TYPE_READONLY (ttr))\n-\t\t\t & (TYPE_VOLATILE (ttl) | ! TYPE_VOLATILE (ttr))))\n+\t\t  if (TYPE_QUALS (ttl) == TYPE_QUALS (ttr)\n+\t\t      || ((TREE_CODE (ttr) == FUNCTION_TYPE\n+\t\t\t   && TREE_CODE (ttl) == FUNCTION_TYPE)\n+\t\t\t  ? ((TYPE_QUALS (ttl) | TYPE_QUALS (ttr))\n+\t\t\t     == TYPE_QUALS (ttr))\n+\t\t\t  : (TYPE_QUALS (ttl) | TYPE_QUALS (ttr)\n+\t\t\t     == TYPE_QUALS (ttl))))\n \t\t    break;\n \n \t\t  /* Keep looking for a better type, but remember this one.  */\n@@ -4157,26 +4157,15 @@ convert_for_assignment (type, rhs, errtype, fundecl, funname, parmnum)\n \t\t     certain things, it is okay to use a const or volatile\n \t\t     function where an ordinary one is wanted, but not\n \t\t     vice-versa.  */\n-\t\t  if (TYPE_READONLY (ttl) && ! TYPE_READONLY (ttr))\n-\t\t    warn_for_assignment (\"%s makes `const *' function pointer from non-const\",\n-\t\t\t\t\t get_spelling (errtype), funname,\n-\t\t\t\t\t parmnum);\n-\t\t  if (TYPE_VOLATILE (ttl) && ! TYPE_VOLATILE (ttr))\n-\t\t    warn_for_assignment (\"%s makes `volatile *' function pointer from non-volatile\",\n-\t\t\t\t\t get_spelling (errtype), funname,\n-\t\t\t\t\t parmnum);\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  if (! TYPE_READONLY (ttl) && TYPE_READONLY (ttr))\n-\t\t    warn_for_assignment (\"%s discards `const' from pointer target type\",\n-\t\t\t\t\t get_spelling (errtype), funname,\n-\t\t\t\t\t parmnum);\n-\t\t  if (! TYPE_VOLATILE (ttl) && TYPE_VOLATILE (ttr))\n-\t\t    warn_for_assignment (\"%s discards `volatile' from pointer target type\",\n+\t\t  if (TYPE_QUALS (ttl) & ~TYPE_QUALS (ttr))\n+\t\t    warn_for_assignment (\"%s makes qualified function pointer from unqualified\",\n \t\t\t\t\t get_spelling (errtype), funname,\n \t\t\t\t\t parmnum);\n \t\t}\n+\t      else if (TYPE_QUALS (ttr) & ~TYPE_QUALS (ttl))\n+\t\twarn_for_assignment (\"%s discards qualifiers from pointer target type\",\n+\t\t\t\t     get_spelling (errtype), funname,\n+\t\t\t\t     parmnum);\n \t    }\n \t  \n \t  if (pedantic && ! DECL_IN_SYSTEM_HEADER (fundecl))\n@@ -4217,11 +4206,8 @@ convert_for_assignment (type, rhs, errtype, fundecl, funname, parmnum)\n \t  else if (TREE_CODE (ttr) != FUNCTION_TYPE\n \t\t   && TREE_CODE (ttl) != FUNCTION_TYPE)\n \t    {\n-\t      if (! TYPE_READONLY (ttl) && TYPE_READONLY (ttr))\n-\t\twarn_for_assignment (\"%s discards `const' from pointer target type\",\n-\t\t\t\t     get_spelling (errtype), funname, parmnum);\n-\t      else if (! TYPE_VOLATILE (ttl) && TYPE_VOLATILE (ttr))\n-\t\twarn_for_assignment (\"%s discards `volatile' from pointer target type\",\n+\t      if (TYPE_QUALS (ttr) & ~TYPE_QUALS (ttl))\n+\t\twarn_for_assignment (\"%s discards qualifiers from pointer target type\",\n \t\t\t\t     get_spelling (errtype), funname, parmnum);\n \t      /* If this is not a case of ignoring a mismatch in signedness,\n \t\t no warning.  */\n@@ -4241,11 +4227,8 @@ convert_for_assignment (type, rhs, errtype, fundecl, funname, parmnum)\n \t\t that say the function will not do certain things,\n \t\t it is okay to use a const or volatile function\n \t\t where an ordinary one is wanted, but not vice-versa.  */\n-\t      if (TYPE_READONLY (ttl) && ! TYPE_READONLY (ttr))\n-\t\twarn_for_assignment (\"%s makes `const *' function pointer from non-const\",\n-\t\t\t\t     get_spelling (errtype), funname, parmnum);\n-\t      if (TYPE_VOLATILE (ttl) && ! TYPE_VOLATILE (ttr))\n-\t\twarn_for_assignment (\"%s makes `volatile *' function pointer from non-volatile\",\n+\t      if (TYPE_QUALS (ttl) & ~TYPE_QUALS (ttr))\n+\t\twarn_for_assignment (\"%s makes qualified function pointer from unqualified\",\n \t\t\t\t     get_spelling (errtype), funname, parmnum);\n \t    }\n \t}"}, {"sha": "3e6356a8c255129f0acc687ee9ee851225a62cdd", "filename": "gcc/invoke.texi", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3932261a55eb9840491d2cee5bb58d6fff0533fa/gcc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3932261a55eb9840491d2cee5bb58d6fff0533fa/gcc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finvoke.texi?ref=3932261a55eb9840491d2cee5bb58d6fff0533fa", "patch": "@@ -93,7 +93,7 @@ in the following sections.\n @item C Language Options\n @xref{C Dialect Options,,Options Controlling C Dialect}.\n @smallexample\n--ansi  -fallow-single-precision  -fcond-mismatch  -fno-asm\n+-ansi -flang-isoc9x -fallow-single-precision  -fcond-mismatch  -fno-asm\n -fno-builtin  -ffreestanding  -fhosted  -fsigned-bitfields  -fsigned-char\n -funsigned-bitfields  -funsigned-char  -fwritable-strings\n -traditional  -traditional-cpp  -trigraphs\n@@ -644,6 +644,15 @@ programs that might use these names for other things.\n The functions @code{alloca}, @code{abort}, @code{exit}, and\n @code{_exit} are not builtin functions when @samp{-ansi} is used.\n \n+@item -flang-isoc9x\n+Enable support for features found in the C9X standard.  In particular,\n+enable support for the C9X @code{restrict} keyword.  \n+\n+Even when this option is not specified, you can still use some C9X\n+features in so far as they do not conflict with previous C standards.\n+For example, you may use @code{__restrict__} even when -flang-isoc9x\n+is not specified. \n+\n @item -fno-asm\n Do not recognize @code{asm}, @code{inline} or @code{typeof} as a\n keyword, so that code can use these words as identifiers.  You can use"}, {"sha": "afc082e4b69fd4b677a3d5b0b9bf3eff6edd8f0b", "filename": "gcc/print-tree.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3932261a55eb9840491d2cee5bb58d6fff0533fa/gcc%2Fprint-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3932261a55eb9840491d2cee5bb58d6fff0533fa/gcc%2Fprint-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-tree.c?ref=3932261a55eb9840491d2cee5bb58d6fff0533fa", "patch": "@@ -404,6 +404,8 @@ print_node (file, prefix, node, indent)\n \tfprintf (file, \" built-in code %d\", DECL_FUNCTION_CODE (node));\n       if (TREE_CODE (node) == FIELD_DECL)\n \tprint_node (file, \"bitpos\", DECL_FIELD_BITPOS (node), indent + 4);\n+      if (DECL_POINTER_ALIAS_SET_KNOWN_P (node))\n+\tfprintf (file, \" alias set %d\", DECL_POINTER_ALIAS_SET (node));\n       print_node_brief (file, \"context\", DECL_CONTEXT (node), indent + 4);\n       print_node_brief (file, \"machine_attributes\", DECL_MACHINE_ATTRIBUTES (node), indent + 4);\n       print_node_brief (file, \"abstract_origin\","}, {"sha": "d655d4e593ede030329f71d1011a166f774a6e46", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3932261a55eb9840491d2cee5bb58d6fff0533fa/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3932261a55eb9840491d2cee5bb58d6fff0533fa/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=3932261a55eb9840491d2cee5bb58d6fff0533fa", "patch": "@@ -1505,5 +1505,6 @@ extern void init_alias_analysis\t\tPROTO ((void));\n extern void end_alias_analysis\t\tPROTO ((void));\n \n extern void record_base_value\t\tPROTO ((int, rtx, int));\n+extern void record_alias_subset         PROTO ((int, int));\n \n #endif /* _RTL_H */"}, {"sha": "203b40e6d2f85e6f37dcd0ee543877e7ec424eb7", "filename": "gcc/toplev.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3932261a55eb9840491d2cee5bb58d6fff0533fa/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3932261a55eb9840491d2cee5bb58d6fff0533fa/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=3932261a55eb9840491d2cee5bb58d6fff0533fa", "patch": "@@ -949,6 +949,7 @@ documented_lang_options[] =\n   { \"-traditional\", \"Attempt to support traditional K&R style C\"},\n   { \"-fnotraditional\", \"\" },\n   { \"-fno-traditional\", \"\" },\n+  { \"-flang-isoc9x\", \"Enable C9X features\"},\n \n   { \"-fasm\", \"\" },\n   { \"-fno-asm\", \"Do not recognise the 'asm' keyword\" },"}, {"sha": "04f7da8737bd471fa003c9ef9cc2132c5f26fb1a", "filename": "gcc/tree.c", "status": "modified", "additions": 30, "deletions": 28, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3932261a55eb9840491d2cee5bb58d6fff0533fa/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3932261a55eb9840491d2cee5bb58d6fff0533fa/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=3932261a55eb9840491d2cee5bb58d6fff0533fa", "patch": "@@ -264,6 +264,8 @@ int (*lang_get_alias_set) PROTO((tree));\n    codes are made.  */\n #define TYPE_HASH(TYPE) ((unsigned long) (TYPE) & 0777777)\n \n+static void set_type_quals PROTO((tree, int));\n+\n extern char *mode_name[];\n \n void gcc_obstack_init ();\n@@ -1100,6 +1102,9 @@ make_node (code)\n       DECL_SOURCE_LINE (t) = lineno;\n       DECL_SOURCE_FILE (t) = (input_filename) ? input_filename : \"<built-in>\";\n       DECL_UID (t) = next_decl_uid++;\n+      /* Note that we have not yet computed the alias set for this\n+\t declaration.  */\n+      DECL_POINTER_ALIAS_SET (t) = -1;\n       break;\n \n     case 't':\n@@ -3294,7 +3299,7 @@ build_type_attribute_variant (ttype, attribute)\n       /* Create a new main variant of TYPE.  */\n       TYPE_MAIN_VARIANT (ntype) = ntype;\n       TYPE_NEXT_VARIANT (ntype) = 0;\n-      TYPE_READONLY (ntype) = TYPE_VOLATILE (ntype) = 0;\n+      set_type_quals (ntype, TYPE_UNQUALIFIED);\n \n       hashcode = TYPE_HASH (TREE_CODE (ntype))\n \t\t + TYPE_HASH (TREE_TYPE (ntype))\n@@ -3319,8 +3324,7 @@ build_type_attribute_variant (ttype, attribute)\n         }\n \n       ntype = type_hash_canon (hashcode, ntype);\n-      ttype = build_type_variant (ntype, TYPE_READONLY (ttype),\n-\t\t\t\t  TYPE_VOLATILE (ttype));\n+      ttype = build_qualified_type (ntype, TYPE_QUALS (ttype));\n     }\n \n   return ttype;\n@@ -3576,45 +3580,44 @@ merge_machine_decl_attributes (olddecl, newdecl)\n #endif\n }\n \f\n-/* Return a type like TYPE except that its TYPE_READONLY is CONSTP\n-   and its TYPE_VOLATILE is VOLATILEP.\n+/* Set the type qualifiers for TYPE to TYPE_QUALS, which is a bitmask\n+   of the various TYPE_QUAL values.  */\n \n-   Such variant types already made are recorded so that duplicates\n-   are not made.\n+static void\n+set_type_quals (type, type_quals)\n+     tree type;\n+     int  type_quals;\n+{\n+  TYPE_READONLY (type) = (type_quals & TYPE_QUAL_CONST) != 0;\n+  TYPE_VOLATILE (type) = (type_quals & TYPE_QUAL_VOLATILE) != 0;\n+  TYPE_RESTRICT (type) = (type_quals & TYPE_QUAL_RESTRICT) != 0;\n+}\n \n-   A variant types should never be used as the type of an expression.\n-   Always copy the variant information into the TREE_READONLY\n-   and TREE_THIS_VOLATILE of the expression, and then give the expression\n-   as its type the \"main variant\", the variant whose TYPE_READONLY\n-   and TYPE_VOLATILE are zero.  Use TYPE_MAIN_VARIANT to find the\n-   main variant.  */\n+/* Given a type node TYPE and a TYPE_QUALIFIER_SET, return a type for\n+   the same kind of data as TYPE describes.  Variants point to the\n+   \"main variant\" (which has no qualifiers set) via TYPE_MAIN_VARIANT,\n+   and it points to a chain of other variants so that duplicate\n+   variants are never made.  Only main variants should ever appear as\n+   types of expressions.  */\n \n tree\n-build_type_variant (type, constp, volatilep)\n+build_qualified_type (type, type_quals)\n      tree type;\n-     int constp, volatilep;\n+     int type_quals;\n {\n   register tree t;\n-\n-  /* Treat any nonzero argument as 1.  */\n-  constp = !!constp;\n-  volatilep = !!volatilep;\n-\n+  \n   /* Search the chain of variants to see if there is already one there just\n      like the one we need to have.  If so, use that existing one.  We must\n      preserve the TYPE_NAME, since there is code that depends on this.  */\n \n   for (t = TYPE_MAIN_VARIANT (type); t; t = TYPE_NEXT_VARIANT (t))\n-    if (constp == TYPE_READONLY (t) && volatilep == TYPE_VOLATILE (t)\n-\t&& TYPE_NAME (t) == TYPE_NAME (type))\n+    if (TYPE_QUALS (t) == type_quals && TYPE_NAME (t) == TYPE_NAME (type))\n       return t;\n \n   /* We need a new one.  */\n-\n   t = build_type_copy (type);\n-  TYPE_READONLY (t) = constp;\n-  TYPE_VOLATILE (t) = volatilep;\n-\n+  set_type_quals (t, type_quals);\n   return t;\n }\n \n@@ -4422,8 +4425,7 @@ build_complex_type (component_type)\n   t = make_node (COMPLEX_TYPE);\n \n   TREE_TYPE (t) = TYPE_MAIN_VARIANT (component_type);\n-  TYPE_VOLATILE (t) = TYPE_VOLATILE (component_type);\n-  TYPE_READONLY (t) = TYPE_READONLY (component_type);\n+  set_type_quals (t, TYPE_QUALS (component_type));\n \n   /* If we already have such a type, use the old one and free this one.  */\n   hashcode = TYPE_HASH (component_type);"}, {"sha": "8dd784316df407021fdffdc127822763cc74b284", "filename": "gcc/tree.h", "status": "modified", "additions": 50, "deletions": 8, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3932261a55eb9840491d2cee5bb58d6fff0533fa/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3932261a55eb9840491d2cee5bb58d6fff0533fa/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=3932261a55eb9840491d2cee5bb58d6fff0533fa", "patch": "@@ -830,6 +830,25 @@ struct tree_block\n /* Means this type is const-qualified.  */\n #define TYPE_READONLY(NODE) ((NODE)->common.readonly_flag)\n \n+/* If nonzero, this type is `restrict'-qualified, in the C sense of\n+   the term.  */\n+#define TYPE_RESTRICT(NODE) (TYPE_CHECK (NODE)->type.restrict_flag)\n+\n+/* There is a TYPE_QUAL value for each type qualifier.  They can be\n+   combined by bitwise-or to form the complete set of qualifiers for a\n+   type.  */\n+\n+#define TYPE_UNQUALIFIED   0x0\n+#define TYPE_QUAL_CONST    0x1\n+#define TYPE_QUAL_VOLATILE 0x2\n+#define TYPE_QUAL_RESTRICT 0x4\n+\n+/* The set of type qualifiers for this type.  */\n+#define TYPE_QUALS(NODE)\t\t\t\\\n+  ((TYPE_READONLY(NODE) * TYPE_QUAL_CONST) |\t\\\n+   (TYPE_VOLATILE(NODE) * TYPE_QUAL_VOLATILE) |\t\\\n+   (TYPE_RESTRICT(NODE) * TYPE_QUAL_RESTRICT))\n+\n /* These flags are available for each language front end to use internally.  */\n #define TYPE_LANG_FLAG_0(NODE) (TYPE_CHECK (NODE)->type.lang_flag_0)\n #define TYPE_LANG_FLAG_1(NODE) (TYPE_CHECK (NODE)->type.lang_flag_1)\n@@ -881,14 +900,16 @@ struct tree_type\n   unsigned needs_constructing_flag : 1;\n   unsigned transparent_union_flag : 1;\n   unsigned packed_flag : 1;\n+  unsigned restrict_flag : 1;\n+\n   unsigned lang_flag_0 : 1;\n   unsigned lang_flag_1 : 1;\n   unsigned lang_flag_2 : 1;\n   unsigned lang_flag_3 : 1;\n   unsigned lang_flag_4 : 1;\n   unsigned lang_flag_5 : 1;\n   unsigned lang_flag_6 : 1;\n-  /* room for 4 more bits */\n+  /* room for 3 more bits */\n \n   unsigned int align;\n   union tree_node *pointer_to;\n@@ -1244,6 +1265,16 @@ struct tree_type\n    an address constant.  */\n #define DECL_NON_ADDR_CONST_P(NODE) (DECL_CHECK (NODE)->decl.non_addr_const_p)\n \n+/* Used to indicate an alias set for the memory pointed to by this\n+   particular FIELD_DECL, PARM_DECL, or VAR_DECL, which must have\n+   pointer (or reference) type.  */\n+#define DECL_POINTER_ALIAS_SET(NODE) \\\n+  (DECL_CHECK (NODE)->decl.pointer_alias_set)\n+\n+/* Nonzero if an alias set has been assigned to this declaration.  */\n+#define DECL_POINTER_ALIAS_SET_KNOWN_P(NODE) \\\n+  (DECL_POINTER_ALIAS_SET (NODE) != - 1)\n+\n struct tree_decl\n {\n   char common[sizeof (struct tree_common)];\n@@ -1316,6 +1347,7 @@ struct tree_decl\n     HOST_WIDE_INT i;\n   } saved_insns;\n   union tree_node *vindex;\n+  int pointer_alias_set;\n   /* Points to a structure whose details depend on the language in use.  */\n   struct lang_decl *lang_specific;\n };\n@@ -1502,14 +1534,24 @@ extern tree lookup_attribute\t\tPROTO((char *, tree));\n \n extern tree merge_attributes\t\tPROTO((tree, tree));\n \n-/* Given a type node TYPE, and CONSTP and VOLATILEP, return a type\n-   for the same kind of data as TYPE describes.\n-   Variants point to the \"main variant\" (which has neither CONST nor VOLATILE)\n-   via TYPE_MAIN_VARIANT, and it points to a chain of other variants\n-   so that duplicate variants are never made.\n-   Only main variants should ever appear as types of expressions.  */\n+/* Given a type node TYPE and a TYPE_QUALIFIER_SET, return a type for\n+   the same kind of data as TYPE describes.  Variants point to the\n+   \"main variant\" (which has no qualifiers set) via TYPE_MAIN_VARIANT,\n+   and it points to a chain of other variants so that duplicate\n+   variants are never made.  Only main variants should ever appear as\n+   types of expressions.  */\n+\n+extern tree build_qualified_type        PROTO((tree, int));\n+\n+/* Like build_qualified_type, but only deals with the `const' and\n+   `volatile' qualifiers.  This interface is retained for backwards\n+   compatiblity with the various front-ends; new code should use\n+   build_qualified_type instead.  */\n \n-extern tree build_type_variant\t\tPROTO((tree, int, int));\n+#define build_type_variant(TYPE, CONST_P, VOLATILE_P)\t\t\t\\\n+  build_qualified_type (TYPE,\t\t\t\t\t\t\\\n+\t\t\t((CONST_P) ? TYPE_QUAL_CONST : 0)\t\t\\\n+\t\t\t| ((VOLATILE_P) ? TYPE_QUAL_VOLATILE : 0))\n \n /* Make a copy of a type node.  */\n "}]}