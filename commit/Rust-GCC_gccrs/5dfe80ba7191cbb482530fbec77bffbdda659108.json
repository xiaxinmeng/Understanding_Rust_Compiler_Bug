{"sha": "5dfe80ba7191cbb482530fbec77bffbdda659108", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWRmZTgwYmE3MTkxY2JiNDgyNTMwZmJlYzc3YmZmYmRkYTY1OTEwOA==", "commit": {"author": {"name": "Andrew Stubbs", "email": "ams@codesourcery.com", "date": "2011-08-19T14:21:48Z"}, "committer": {"name": "Andrew Stubbs", "email": "ams@gcc.gnu.org", "date": "2011-08-19T14:21:48Z"}, "message": "arm.md (maddhidi4): Remove '*' from name.\n\n2011-08-19  Andrew Stubbs  <ams@codesourcery.com>\n\n\tgcc/\n\t* config/arm/arm.md (maddhidi4): Remove '*' from name.\n\t* expr.c (expand_expr_real_2): Use find_widening_optab_handler.\n\t* optabs.c (find_widening_optab_handler_and_mode): New function.\n\t(expand_widen_pattern_expr): Use find_widening_optab_handler.\n\t(expand_binop_directly): Likewise.\n\t(expand_binop): Likewise.\n\t* optabs.h (find_widening_optab_handler): New macro define.\n\t(find_widening_optab_handler_and_mode): New prototype.\n\t* tree-cfg.c (verify_gimple_assign_binary): Adjust WIDEN_MULT_EXPR\n\ttype precision rules.\n\t(verify_gimple_assign_ternary): Likewise for WIDEN_MULT_PLUS_EXPR.\n\t* tree-ssa-math-opts.c (build_and_insert_cast): New function.\n\t(is_widening_mult_rhs_p): Allow widening by more than one mode.\n\tExplicitly disallow mis-matched input types.\n\t(convert_mult_to_widen): Use find_widening_optab_handler, and cast\n\tinput types to fit the new handler.\n\t(convert_plusminus_to_widen): Likewise.\n\n\tgcc/testsuite/\n\t* gcc.target/arm/wmul-bitfield-1.c: New file.\n\nFrom-SVN: r177902", "tree": {"sha": "07832b1f8a143dfb806a099e0cf2d8e103e38162", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/07832b1f8a143dfb806a099e0cf2d8e103e38162"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5dfe80ba7191cbb482530fbec77bffbdda659108", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5dfe80ba7191cbb482530fbec77bffbdda659108", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5dfe80ba7191cbb482530fbec77bffbdda659108", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5dfe80ba7191cbb482530fbec77bffbdda659108/comments", "author": {"login": "ams-cs", "id": 2235130, "node_id": "MDQ6VXNlcjIyMzUxMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2235130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ams-cs", "html_url": "https://github.com/ams-cs", "followers_url": "https://api.github.com/users/ams-cs/followers", "following_url": "https://api.github.com/users/ams-cs/following{/other_user}", "gists_url": "https://api.github.com/users/ams-cs/gists{/gist_id}", "starred_url": "https://api.github.com/users/ams-cs/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ams-cs/subscriptions", "organizations_url": "https://api.github.com/users/ams-cs/orgs", "repos_url": "https://api.github.com/users/ams-cs/repos", "events_url": "https://api.github.com/users/ams-cs/events{/privacy}", "received_events_url": "https://api.github.com/users/ams-cs/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a484f6bae00618d6482bdaf1740bb32663d96d24", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a484f6bae00618d6482bdaf1740bb32663d96d24", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a484f6bae00618d6482bdaf1740bb32663d96d24"}], "stats": {"total": 254, "additions": 189, "deletions": 65}, "files": [{"sha": "f88f45c773a8b36e4b4a5ef56f80745bc9f55c5f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dfe80ba7191cbb482530fbec77bffbdda659108/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dfe80ba7191cbb482530fbec77bffbdda659108/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5dfe80ba7191cbb482530fbec77bffbdda659108", "patch": "@@ -1,3 +1,23 @@\n+2011-08-19  Andrew Stubbs  <ams@codesourcery.com>\n+\n+\t* config/arm/arm.md (maddhidi4): Remove '*' from name.\n+\t* expr.c (expand_expr_real_2): Use find_widening_optab_handler.\n+\t* optabs.c (find_widening_optab_handler_and_mode): New function.\n+\t(expand_widen_pattern_expr): Use find_widening_optab_handler.\n+\t(expand_binop_directly): Likewise.\n+\t(expand_binop): Likewise.\n+\t* optabs.h (find_widening_optab_handler): New macro define.\n+\t(find_widening_optab_handler_and_mode): New prototype.\n+\t* tree-cfg.c (verify_gimple_assign_binary): Adjust WIDEN_MULT_EXPR\n+\ttype precision rules.\n+\t(verify_gimple_assign_ternary): Likewise for WIDEN_MULT_PLUS_EXPR.\n+\t* tree-ssa-math-opts.c (build_and_insert_cast): New function.\n+\t(is_widening_mult_rhs_p): Allow widening by more than one mode.\n+\tExplicitly disallow mis-matched input types.\n+\t(convert_mult_to_widen): Use find_widening_optab_handler, and cast\n+\tinput types to fit the new handler.\n+\t(convert_plusminus_to_widen): Likewise.\n+\n 2011-08-19  Andrew Stubbs  <ams@codesourcery.com>\n \n \t* expr.c (expand_expr_real_2): Use widening_optab_handler."}, {"sha": "0f23400360369708fedcdf37f1f7c5447d0cad7a", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dfe80ba7191cbb482530fbec77bffbdda659108/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dfe80ba7191cbb482530fbec77bffbdda659108/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=5dfe80ba7191cbb482530fbec77bffbdda659108", "patch": "@@ -1857,7 +1857,7 @@\n    (set_attr \"predicable\" \"yes\")]\n )\n \n-(define_insn \"*maddhidi4\"\n+(define_insn \"maddhidi4\"\n   [(set (match_operand:DI 0 \"s_register_operand\" \"=r\")\n \t(plus:DI\n \t  (mult:DI (sign_extend:DI"}, {"sha": "82873eb8376b6a3d28cbc3f115f2d43334906d1c", "filename": "gcc/expr.c", "status": "modified", "additions": 12, "deletions": 16, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dfe80ba7191cbb482530fbec77bffbdda659108/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dfe80ba7191cbb482530fbec77bffbdda659108/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=5dfe80ba7191cbb482530fbec77bffbdda659108", "patch": "@@ -8003,19 +8003,16 @@ expand_expr_real_2 (sepops ops, rtx target, enum machine_mode tmode,\n \t{\n \t  enum machine_mode innermode = TYPE_MODE (TREE_TYPE (treeop0));\n \t  this_optab = usmul_widen_optab;\n-\t  if (mode == GET_MODE_2XWIDER_MODE (innermode))\n+\t  if (find_widening_optab_handler (this_optab, mode, innermode, 0)\n+\t\t!= CODE_FOR_nothing)\n \t    {\n-\t      if (widening_optab_handler (this_optab, mode, innermode)\n-\t\t    != CODE_FOR_nothing)\n-\t\t{\n-\t\t  if (TYPE_UNSIGNED (TREE_TYPE (treeop0)))\n-\t\t    expand_operands (treeop0, treeop1, NULL_RTX, &op0, &op1,\n-\t\t\t\t     EXPAND_NORMAL);\n-\t\t  else\n-\t\t    expand_operands (treeop0, treeop1, NULL_RTX, &op1, &op0,\n-\t\t\t\t     EXPAND_NORMAL);\n-\t\t  goto binop3;\n-\t\t}\n+\t      if (TYPE_UNSIGNED (TREE_TYPE (treeop0)))\n+\t\texpand_operands (treeop0, treeop1, NULL_RTX, &op0, &op1,\n+\t\t\t\t EXPAND_NORMAL);\n+\t      else\n+\t\texpand_operands (treeop0, treeop1, NULL_RTX, &op1, &op0,\n+\t\t\t\t EXPAND_NORMAL);\n+\t      goto binop3;\n \t    }\n \t}\n       /* Check for a multiplication with matching signedness.  */\n@@ -8030,10 +8027,9 @@ expand_expr_real_2 (sepops ops, rtx target, enum machine_mode tmode,\n \t  optab other_optab = zextend_p ? smul_widen_optab : umul_widen_optab;\n \t  this_optab = zextend_p ? umul_widen_optab : smul_widen_optab;\n \n-\t  if (mode == GET_MODE_2XWIDER_MODE (innermode)\n-\t      && TREE_CODE (treeop0) != INTEGER_CST)\n+\t  if (TREE_CODE (treeop0) != INTEGER_CST)\n \t    {\n-\t      if (widening_optab_handler (this_optab, mode, innermode)\n+\t      if (find_widening_optab_handler (this_optab, mode, innermode, 0)\n \t\t    != CODE_FOR_nothing)\n \t\t{\n \t\t  expand_operands (treeop0, treeop1, NULL_RTX, &op0, &op1,\n@@ -8042,7 +8038,7 @@ expand_expr_real_2 (sepops ops, rtx target, enum machine_mode tmode,\n \t\t\t\t\t       unsignedp, this_optab);\n \t\t  return REDUCE_BIT_FIELD (temp);\n \t\t}\n-\t      if (widening_optab_handler (other_optab, mode, innermode)\n+\t      if (find_widening_optab_handler (other_optab, mode, innermode, 0)\n \t\t    != CODE_FOR_nothing\n \t\t  && innermode == word_mode)\n \t\t{"}, {"sha": "a70119abfdcc61f0b4905b65579c61eebeef88fe", "filename": "gcc/optabs.c", "status": "modified", "additions": 44, "deletions": 11, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dfe80ba7191cbb482530fbec77bffbdda659108/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dfe80ba7191cbb482530fbec77bffbdda659108/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=5dfe80ba7191cbb482530fbec77bffbdda659108", "patch": "@@ -249,6 +249,37 @@ widened_mode (enum machine_mode to_mode, rtx op0, rtx op1)\n   return result;\n }\n \f\n+/* Find a widening optab even if it doesn't widen as much as we want.\n+   E.g. if from_mode is HImode, and to_mode is DImode, and there is no\n+   direct HI->SI insn, then return SI->DI, if that exists.\n+   If PERMIT_NON_WIDENING is non-zero then this can be used with\n+   non-widening optabs also.  */\n+\n+enum insn_code\n+find_widening_optab_handler_and_mode (optab op, enum machine_mode to_mode,\n+\t\t\t\t      enum machine_mode from_mode,\n+\t\t\t\t      int permit_non_widening,\n+\t\t\t\t      enum machine_mode *found_mode)\n+{\n+  for (; (permit_non_widening || from_mode != to_mode)\n+\t && GET_MODE_SIZE (from_mode) <= GET_MODE_SIZE (to_mode)\n+\t && from_mode != VOIDmode;\n+       from_mode = GET_MODE_WIDER_MODE (from_mode))\n+    {\n+      enum insn_code handler = widening_optab_handler (op, to_mode,\n+\t\t\t\t\t\t       from_mode);\n+\n+      if (handler != CODE_FOR_nothing)\n+\t{\n+\t  if (found_mode)\n+\t    *found_mode = from_mode;\n+\t  return handler;\n+\t}\n+    }\n+\n+  return CODE_FOR_nothing;\n+}\n+\f\n /* Widen OP to MODE and return the rtx for the widened operand.  UNSIGNEDP\n    says whether OP is signed or unsigned.  NO_EXTEND is nonzero if we need\n    not actually do a sign-extend or zero-extend, but can leave the\n@@ -539,8 +570,9 @@ expand_widen_pattern_expr (sepops ops, rtx op0, rtx op1, rtx wide_op,\n     optab_for_tree_code (ops->code, TREE_TYPE (oprnd0), optab_default);\n   if (ops->code == WIDEN_MULT_PLUS_EXPR\n       || ops->code == WIDEN_MULT_MINUS_EXPR)\n-    icode = widening_optab_handler (widen_pattern_optab,\n-\t\t\t\t    TYPE_MODE (TREE_TYPE (ops->op2)), tmode0);\n+    icode = find_widening_optab_handler (widen_pattern_optab,\n+\t\t\t\t\t TYPE_MODE (TREE_TYPE (ops->op2)),\n+\t\t\t\t\t tmode0, 0);\n   else\n     icode = optab_handler (widen_pattern_optab, tmode0);\n   gcc_assert (icode != CODE_FOR_nothing);\n@@ -1267,7 +1299,8 @@ expand_binop_directly (enum machine_mode mode, optab binoptab,\n \t\t       rtx last)\n {\n   enum machine_mode from_mode = widened_mode (mode, op0, op1);\n-  enum insn_code icode = widening_optab_handler (binoptab, mode, from_mode);\n+  enum insn_code icode = find_widening_optab_handler (binoptab, mode,\n+\t\t\t\t\t\t      from_mode, 1);\n   enum machine_mode xmode0 = insn_data[(int) icode].operand[1].mode;\n   enum machine_mode xmode1 = insn_data[(int) icode].operand[2].mode;\n   enum machine_mode mode0, mode1, tmp_mode;\n@@ -1414,8 +1447,8 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n   /* If we can do it with a three-operand insn, do so.  */\n \n   if (methods != OPTAB_MUST_WIDEN\n-      && widening_optab_handler (binoptab, mode,\n-\t\t\t\t widened_mode (mode, op0, op1))\n+      && find_widening_optab_handler (binoptab, mode,\n+\t\t\t\t      widened_mode (mode, op0, op1), 1)\n \t    != CODE_FOR_nothing)\n     {\n       temp = expand_binop_directly (mode, binoptab, op0, op1, target,\n@@ -1488,10 +1521,11 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n \tif (optab_handler (binoptab, wider_mode) != CODE_FOR_nothing\n \t    || (binoptab == smul_optab\n \t\t&& GET_MODE_WIDER_MODE (wider_mode) != VOIDmode\n-\t\t&& (widening_optab_handler ((unsignedp ? umul_widen_optab\n-\t\t\t\t\t\t       : smul_widen_optab),\n-\t\t\t\t\t    GET_MODE_WIDER_MODE (wider_mode),\n-\t\t\t\t\t    mode)\n+\t\t&& (find_widening_optab_handler ((unsignedp\n+\t\t\t\t\t\t  ? umul_widen_optab\n+\t\t\t\t\t\t  : smul_widen_optab),\n+\t\t\t\t\t\t GET_MODE_WIDER_MODE (wider_mode),\n+\t\t\t\t\t\t mode, 0)\n \t\t    != CODE_FOR_nothing)))\n \t  {\n \t    rtx xop0 = op0, xop1 = op1;\n@@ -2026,8 +2060,7 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n \t   wider_mode != VOIDmode;\n \t   wider_mode = GET_MODE_WIDER_MODE (wider_mode))\n \t{\n-\t  if (optab_handler (binoptab, wider_mode) != CODE_FOR_nothing\n-\t      || widening_optab_handler (binoptab, wider_mode, mode)\n+\t  if (find_widening_optab_handler (binoptab, wider_mode, mode, 1)\n \t\t  != CODE_FOR_nothing\n \t      || (methods == OPTAB_LIB\n \t\t  && optab_libfunc (binoptab, wider_mode)))"}, {"sha": "cf5a659647b3375cd59859563167844d1805663a", "filename": "gcc/optabs.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dfe80ba7191cbb482530fbec77bffbdda659108/gcc%2Foptabs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dfe80ba7191cbb482530fbec77bffbdda659108/gcc%2Foptabs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.h?ref=5dfe80ba7191cbb482530fbec77bffbdda659108", "patch": "@@ -807,6 +807,15 @@ extern rtx expand_copysign (rtx, rtx, rtx);\n extern void emit_unop_insn (enum insn_code, rtx, rtx, enum rtx_code);\n extern bool maybe_emit_unop_insn (enum insn_code, rtx, rtx, enum rtx_code);\n \n+/* Find a widening optab even if it doesn't widen as much as we want.  */\n+#define find_widening_optab_handler(A,B,C,D) \\\n+  find_widening_optab_handler_and_mode (A, B, C, D, NULL)\n+extern enum insn_code find_widening_optab_handler_and_mode (optab,\n+\t\t\t\t\t\t\t    enum machine_mode,\n+\t\t\t\t\t\t\t    enum machine_mode,\n+\t\t\t\t\t\t\t    int,\n+\t\t\t\t\t\t\t    enum machine_mode *);\n+\n /* An extra flag to control optab_for_tree_code's behavior.  This is needed to\n    distinguish between machines with a vector shift that takes a scalar for the\n    shift amount vs. machines that take a vector for the shift amount.  */"}, {"sha": "139969f8427b4cf68e7e48c60db3b26ae90e60ce", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dfe80ba7191cbb482530fbec77bffbdda659108/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dfe80ba7191cbb482530fbec77bffbdda659108/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5dfe80ba7191cbb482530fbec77bffbdda659108", "patch": "@@ -1,3 +1,7 @@\n+2011-08-19  Andrew Stubbs  <ams@codesourcery.com>\n+\n+\t* gcc.target/arm/wmul-bitfield-1.c: New file.\n+\n 2011-08-19  Joseph Myers  <joseph@codesourcery.com>\n \n \t* gcc.dg/c90-noreturn-1.c, gcc.dg/c99-noreturn-1.c: New tests."}, {"sha": "2e9da59233aef982e1a17b1f1aad49d775246a2d", "filename": "gcc/testsuite/gcc.target/arm/wmul-bitfield-1.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dfe80ba7191cbb482530fbec77bffbdda659108/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fwmul-bitfield-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dfe80ba7191cbb482530fbec77bffbdda659108/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fwmul-bitfield-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fwmul-bitfield-1.c?ref=5dfe80ba7191cbb482530fbec77bffbdda659108", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+/* { dg-require-effective-target arm_dsp } */\n+\n+struct bf\n+{\n+  int a : 3;\n+  int b : 15;\n+  int c : 3;\n+};\n+\n+long long\n+foo (long long a, struct bf b, struct bf c)\n+{\n+  return a + b.b * c.b;\n+}\n+\n+/* { dg-final { scan-assembler \"smlalbb\" } } */"}, {"sha": "b266d1bc55430a2696b59c0ddcd068824e8642e7", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dfe80ba7191cbb482530fbec77bffbdda659108/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dfe80ba7191cbb482530fbec77bffbdda659108/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=5dfe80ba7191cbb482530fbec77bffbdda659108", "patch": "@@ -3564,7 +3564,7 @@ verify_gimple_assign_binary (gimple stmt)\n     case WIDEN_MULT_EXPR:\n       if (TREE_CODE (lhs_type) != INTEGER_TYPE)\n \treturn true;\n-      return ((2 * TYPE_PRECISION (rhs1_type) != TYPE_PRECISION (lhs_type))\n+      return ((2 * TYPE_PRECISION (rhs1_type) > TYPE_PRECISION (lhs_type))\n \t      || (TYPE_PRECISION (rhs1_type) != TYPE_PRECISION (rhs2_type)));\n \n     case WIDEN_SUM_EXPR:\n@@ -3655,7 +3655,7 @@ verify_gimple_assign_ternary (gimple stmt)\n \t   && !FIXED_POINT_TYPE_P (rhs1_type))\n \t  || !useless_type_conversion_p (rhs1_type, rhs2_type)\n \t  || !useless_type_conversion_p (lhs_type, rhs3_type)\n-\t  || 2 * TYPE_PRECISION (rhs1_type) != TYPE_PRECISION (lhs_type)\n+\t  || 2 * TYPE_PRECISION (rhs1_type) > TYPE_PRECISION (lhs_type)\n \t  || TYPE_PRECISION (rhs1_type) != TYPE_PRECISION (rhs2_type))\n \t{\n \t  error (\"type mismatch in widening multiply-accumulate expression\");"}, {"sha": "2e3781ebab6a6eb62bae129ffc53d97b7d236c7b", "filename": "gcc/tree-ssa-math-opts.c", "status": "modified", "additions": 79, "deletions": 35, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dfe80ba7191cbb482530fbec77bffbdda659108/gcc%2Ftree-ssa-math-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dfe80ba7191cbb482530fbec77bffbdda659108/gcc%2Ftree-ssa-math-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-math-opts.c?ref=5dfe80ba7191cbb482530fbec77bffbdda659108", "patch": "@@ -1086,6 +1086,16 @@ build_and_insert_ref (gimple_stmt_iterator *gsi, location_t loc, tree type,\n   return result;\n }\n \n+/* Build a gimple assignment to cast VAL to TARGET.  Insert the statement\n+   prior to GSI's current position, and return the fresh SSA name.  */\n+\n+static tree\n+build_and_insert_cast (gimple_stmt_iterator *gsi, location_t loc,\n+\t\t       tree target, tree val)\n+{\n+  return build_and_insert_binop (gsi, loc, target, CONVERT_EXPR, val, NULL);\n+}\n+\n /* ARG0 and ARG1 are the two arguments to a pow builtin call in GSI\n    with location info LOC.  If possible, create an equivalent and\n    less expensive sequence of statements prior to GSI, and return an\n@@ -1959,8 +1969,8 @@ struct gimple_opt_pass pass_optimize_bswap =\n /* Return true if RHS is a suitable operand for a widening multiplication.\n    There are two cases:\n \n-     - RHS makes some value twice as wide.  Store that value in *NEW_RHS_OUT\n-       if so, and store its type in *TYPE_OUT.\n+     - RHS makes some value at least twice as wide.  Store that value\n+       in *NEW_RHS_OUT if so, and store its type in *TYPE_OUT.\n \n      - RHS is an integer constant.  Store that value in *NEW_RHS_OUT if so,\n        but leave *TYPE_OUT untouched.  */\n@@ -1988,7 +1998,7 @@ is_widening_mult_rhs_p (tree rhs, tree *type_out, tree *new_rhs_out)\n       rhs1 = gimple_assign_rhs1 (stmt);\n       type1 = TREE_TYPE (rhs1);\n       if (TREE_CODE (type1) != TREE_CODE (type)\n-\t  || TYPE_PRECISION (type1) * 2 != TYPE_PRECISION (type))\n+\t  || TYPE_PRECISION (type1) * 2 > TYPE_PRECISION (type))\n \treturn false;\n \n       *new_rhs_out = rhs1;\n@@ -2044,6 +2054,10 @@ is_widening_mult_p (gimple stmt,\n       *type2_out = *type1_out;\n     }\n \n+  /* FIXME: remove this restriction.  */\n+  if (TYPE_PRECISION (*type1_out) != TYPE_PRECISION (*type2_out))\n+    return false;\n+\n   return true;\n }\n \n@@ -2052,12 +2066,14 @@ is_widening_mult_p (gimple stmt,\n    value is true iff we converted the statement.  */\n \n static bool\n-convert_mult_to_widen (gimple stmt)\n+convert_mult_to_widen (gimple stmt, gimple_stmt_iterator *gsi)\n {\n-  tree lhs, rhs1, rhs2, type, type1, type2;\n+  tree lhs, rhs1, rhs2, type, type1, type2, tmp;\n   enum insn_code handler;\n-  enum machine_mode to_mode, from_mode;\n+  enum machine_mode to_mode, from_mode, actual_mode;\n   optab op;\n+  int actual_precision;\n+  location_t loc = gimple_location (stmt);\n \n   lhs = gimple_assign_lhs (stmt);\n   type = TREE_TYPE (lhs);\n@@ -2077,13 +2093,32 @@ convert_mult_to_widen (gimple stmt)\n   else\n     op = usmul_widen_optab;\n \n-  handler = widening_optab_handler (op, to_mode, from_mode);\n+  handler = find_widening_optab_handler_and_mode (op, to_mode, from_mode,\n+\t\t\t\t\t\t  0, &actual_mode);\n \n   if (handler == CODE_FOR_nothing)\n     return false;\n \n-  gimple_assign_set_rhs1 (stmt, fold_convert (type1, rhs1));\n-  gimple_assign_set_rhs2 (stmt, fold_convert (type2, rhs2));\n+  /* Ensure that the inputs to the handler are in the correct precison\n+     for the opcode.  This will be the full mode size.  */\n+  actual_precision = GET_MODE_PRECISION (actual_mode);\n+  if (actual_precision != TYPE_PRECISION (type1))\n+    {\n+      tmp = create_tmp_var (build_nonstandard_integer_type\n+\t\t\t\t(actual_precision, TYPE_UNSIGNED (type1)),\n+\t\t\t    NULL);\n+      rhs1 = build_and_insert_cast (gsi, loc, tmp, rhs1);\n+\n+      /* Reuse the same type info, if possible.  */\n+      if (TYPE_UNSIGNED (type1) != TYPE_UNSIGNED (type2))\n+\ttmp = create_tmp_var (build_nonstandard_integer_type\n+\t\t\t\t(actual_precision, TYPE_UNSIGNED (type2)),\n+\t\t\t      NULL);\n+      rhs2 = build_and_insert_cast (gsi, loc, tmp, rhs2);\n+    }\n+\n+  gimple_assign_set_rhs1 (stmt, rhs1);\n+  gimple_assign_set_rhs2 (stmt, rhs2);\n   gimple_assign_set_rhs_code (stmt, WIDEN_MULT_EXPR);\n   update_stmt (stmt);\n   widen_mul_stats.widen_mults_inserted++;\n@@ -2101,11 +2136,15 @@ convert_plusminus_to_widen (gimple_stmt_iterator *gsi, gimple stmt,\n \t\t\t    enum tree_code code)\n {\n   gimple rhs1_stmt = NULL, rhs2_stmt = NULL;\n-  tree type, type1, type2;\n+  tree type, type1, type2, tmp;\n   tree lhs, rhs1, rhs2, mult_rhs1, mult_rhs2, add_rhs;\n   enum tree_code rhs1_code = ERROR_MARK, rhs2_code = ERROR_MARK;\n   optab this_optab;\n   enum tree_code wmult_code;\n+  enum insn_code handler;\n+  enum machine_mode to_mode, from_mode, actual_mode;\n+  location_t loc = gimple_location (stmt);\n+  int actual_precision;\n \n   lhs = gimple_assign_lhs (stmt);\n   type = TREE_TYPE (lhs);\n@@ -2139,55 +2178,60 @@ convert_plusminus_to_widen (gimple_stmt_iterator *gsi, gimple stmt,\n   else\n     return false;\n \n-  if (code == PLUS_EXPR && rhs1_code == MULT_EXPR)\n+  /* If code is WIDEN_MULT_EXPR then it would seem unnecessary to call\n+     is_widening_mult_p, but we still need the rhs returns.\n+\n+     It might also appear that it would be sufficient to use the existing\n+     operands of the widening multiply, but that would limit the choice of\n+     multiply-and-accumulate instructions.  */\n+  if (code == PLUS_EXPR\n+      && (rhs1_code == MULT_EXPR || rhs1_code == WIDEN_MULT_EXPR))\n     {\n       if (!is_widening_mult_p (rhs1_stmt, &type1, &mult_rhs1,\n \t\t\t       &type2, &mult_rhs2))\n \treturn false;\n       add_rhs = rhs2;\n     }\n-  else if (rhs2_code == MULT_EXPR)\n+  else if (rhs2_code == MULT_EXPR || rhs2_code == WIDEN_MULT_EXPR)\n     {\n       if (!is_widening_mult_p (rhs2_stmt, &type1, &mult_rhs1,\n \t\t\t       &type2, &mult_rhs2))\n \treturn false;\n       add_rhs = rhs1;\n     }\n-  else if (code == PLUS_EXPR && rhs1_code == WIDEN_MULT_EXPR)\n-    {\n-      mult_rhs1 = gimple_assign_rhs1 (rhs1_stmt);\n-      mult_rhs2 = gimple_assign_rhs2 (rhs1_stmt);\n-      type1 = TREE_TYPE (mult_rhs1);\n-      type2 = TREE_TYPE (mult_rhs2);\n-      add_rhs = rhs2;\n-    }\n-  else if (rhs2_code == WIDEN_MULT_EXPR)\n-    {\n-      mult_rhs1 = gimple_assign_rhs1 (rhs2_stmt);\n-      mult_rhs2 = gimple_assign_rhs2 (rhs2_stmt);\n-      type1 = TREE_TYPE (mult_rhs1);\n-      type2 = TREE_TYPE (mult_rhs2);\n-      add_rhs = rhs1;\n-    }\n   else\n     return false;\n \n+  to_mode = TYPE_MODE (type);\n+  from_mode = TYPE_MODE (type1);\n+\n   if (TYPE_UNSIGNED (type1) != TYPE_UNSIGNED (type2))\n     return false;\n \n   /* Verify that the machine can perform a widening multiply\n      accumulate in this mode/signedness combination, otherwise\n      this transformation is likely to pessimize code.  */\n   this_optab = optab_for_tree_code (wmult_code, type1, optab_default);\n-  if (widening_optab_handler (this_optab, TYPE_MODE (type), TYPE_MODE (type1))\n-\t== CODE_FOR_nothing)\n+  handler = find_widening_optab_handler_and_mode (this_optab, to_mode,\n+\t\t\t\t\t\t  from_mode, 0, &actual_mode);\n+\n+  if (handler == CODE_FOR_nothing)\n     return false;\n \n-  /* ??? May need some type verification here?  */\n+  /* Ensure that the inputs to the handler are in the correct precison\n+     for the opcode.  This will be the full mode size.  */\n+  actual_precision = GET_MODE_PRECISION (actual_mode);\n+  if (actual_precision != TYPE_PRECISION (type1))\n+    {\n+      tmp = create_tmp_var (build_nonstandard_integer_type\n+\t\t\t\t(actual_precision, TYPE_UNSIGNED (type1)),\n+\t\t\t    NULL);\n+\n+      mult_rhs1 = build_and_insert_cast (gsi, loc, tmp, mult_rhs1);\n+      mult_rhs2 = build_and_insert_cast (gsi, loc, tmp, mult_rhs2);\n+    }\n \n-  gimple_assign_set_rhs_with_ops_1 (gsi, wmult_code,\n-\t\t\t\t    fold_convert (type1, mult_rhs1),\n-\t\t\t\t    fold_convert (type2, mult_rhs2),\n+  gimple_assign_set_rhs_with_ops_1 (gsi, wmult_code, mult_rhs1, mult_rhs2,\n \t\t\t\t    add_rhs);\n   update_stmt (gsi_stmt (*gsi));\n   widen_mul_stats.maccs_inserted++;\n@@ -2399,7 +2443,7 @@ execute_optimize_widening_mul (void)\n \t      switch (code)\n \t\t{\n \t\tcase MULT_EXPR:\n-\t\t  if (!convert_mult_to_widen (stmt)\n+\t\t  if (!convert_mult_to_widen (stmt, &gsi)\n \t\t      && convert_mult_to_fma (stmt,\n \t\t\t\t\t      gimple_assign_rhs1 (stmt),\n \t\t\t\t\t      gimple_assign_rhs2 (stmt)))"}]}