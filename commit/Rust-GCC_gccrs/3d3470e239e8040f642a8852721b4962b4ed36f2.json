{"sha": "3d3470e239e8040f642a8852721b4962b4ed36f2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2QzNDcwZTIzOWU4MDQwZjY0MmE4ODUyNzIxYjQ5NjJiNGVkMzZmMg==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2020-11-09T19:35:25Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2020-11-10T08:28:43Z"}, "message": "Normalize VARYING for -fstrict-enums.\n\nThe problem here is that the representation for VARYING in\n-fstrict-enums is different between value_range and irange.\n\nThe helper function irange::normalize_min_max() will normalize to\nVARYING only if setting the range to the entire domain of the\nunderlying type.  That is, [0, 0xff..ff], not the domain as defined by\n-fstrict-enums.  This causes problems because the multi-range version\nof varying_p() will return true if the range is the domain as defined\nby -fstrict-enums.  Thus, normalize_min_max and varying_p have\ndifferent concepts of varying for multi-ranges.\n\n(BTW, legacy ranges are different because they never look at the\nextremes of a range to determine varying-ness.  They only look at the\nkind field.)\n\nOne approach is to change all the code to limit ranges to the domain\nin the -fstrict-enums world, but this won't work because there are\nvarious instances of gimple where the values assigned or compared are\nbeyond the limits of TYPE_{MIN,MAX}_VALUE.  One example is the\naddition of 0xffffffff to represent subtraction.\n\nThis patch fixes multi-range varying_p() and set_varying() to agree\nwith the normalization code, using the extremes of the underlying type,\nto represent varying.\n\ngcc/ChangeLog:\n\n\tPR tree-optimization/97767\n\t* value-range.cc (dump_bound_with_infinite_markers): Use\n\twi::min_value and wi::max_value.\n\t(range_tests_strict_enum): New.\n\t(range_tests): Call range_tests_strict_enum.\n\t* value-range.h (irange::varying_p): Use wi::min_value\n\tand wi::max_value.\n\t(irange::set_varying): Same.\n\t(irange::normalize_min_max): Remove comment.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/opt/pr97767.C: New test.", "tree": {"sha": "d88d0a2a5c76c93e728b7e6fb0174d8908059da6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d88d0a2a5c76c93e728b7e6fb0174d8908059da6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3d3470e239e8040f642a8852721b4962b4ed36f2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d3470e239e8040f642a8852721b4962b4ed36f2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3d3470e239e8040f642a8852721b4962b4ed36f2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d3470e239e8040f642a8852721b4962b4ed36f2/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fb54c3032b8a554beed779499298ad2554d1ab42", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb54c3032b8a554beed779499298ad2554d1ab42", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fb54c3032b8a554beed779499298ad2554d1ab42"}], "stats": {"total": 75, "additions": 60, "deletions": 15}, "files": [{"sha": "da0879d05671e953beeb5d8c1b88459a726a3476", "filename": "gcc/testsuite/g++.dg/opt/pr97767.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d3470e239e8040f642a8852721b4962b4ed36f2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fpr97767.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d3470e239e8040f642a8852721b4962b4ed36f2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fpr97767.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fpr97767.C?ref=3d3470e239e8040f642a8852721b4962b4ed36f2", "patch": "@@ -0,0 +1,10 @@\n+// { dg-do compile }\n+// { dg-options \"-O -fstrict-enums -ftree-vrp -w\" }\n+\n+enum { E0 = 0, E1 = 1, E2 = 2 } e;\n+\n+int\n+foo (void)\n+{\n+  return __builtin_popcount ((int) e);\n+}"}, {"sha": "f83a824a982d9da961d5b00ee657e1f4ba98cb2d", "filename": "gcc/value-range.cc", "status": "modified", "additions": 40, "deletions": 2, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d3470e239e8040f642a8852721b4962b4ed36f2/gcc%2Fvalue-range.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d3470e239e8040f642a8852721b4962b4ed36f2/gcc%2Fvalue-range.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-range.cc?ref=3d3470e239e8040f642a8852721b4962b4ed36f2", "patch": "@@ -1866,12 +1866,17 @@ static void\n dump_bound_with_infinite_markers (FILE *file, tree bound)\n {\n   tree type = TREE_TYPE (bound);\n+  wide_int type_min = wi::min_value (TYPE_PRECISION (type), TYPE_SIGN (type));\n+  wide_int type_max = wi::max_value (TYPE_PRECISION (type), TYPE_SIGN (type));\n+\n   if (INTEGRAL_TYPE_P (type)\n       && !TYPE_UNSIGNED (type)\n-      && vrp_val_is_min (bound)\n+      && TREE_CODE (bound) == INTEGER_CST\n+      && wi::to_wide (bound) == type_min\n       && TYPE_PRECISION (type) != 1)\n     fprintf (file, \"-INF\");\n-  else if (vrp_val_is_max (bound)\n+  else if (TREE_CODE (bound) == INTEGER_CST\n+\t   && wi::to_wide (bound) == type_max\n \t   && TYPE_PRECISION (type) != 1)\n     fprintf (file, \"+INF\");\n   else\n@@ -2241,6 +2246,38 @@ range_tests_legacy ()\n   }\n }\n \n+// Simulate -fstrict-enums where the domain of a type is less than the\n+// underlying type.\n+\n+static void\n+range_tests_strict_enum ()\n+{\n+  // The enum can only hold [0, 3].\n+  tree rtype = copy_node (unsigned_type_node);\n+  TYPE_MIN_VALUE (rtype) = build_int_cstu (rtype, 0);\n+  TYPE_MAX_VALUE (rtype) = build_int_cstu (rtype, 3);\n+\n+  // Test that even though vr1 covers the strict enum domain ([0, 3]),\n+  // it does not cover the domain of the underlying type.\n+  int_range<1> vr1 (build_int_cstu (rtype, 0), build_int_cstu (rtype, 1));\n+  int_range<1> vr2 (build_int_cstu (rtype, 2), build_int_cstu (rtype, 3));\n+  vr1.union_ (vr2);\n+  ASSERT_TRUE (vr1 == int_range<1> (build_int_cstu (rtype, 0),\n+\t\t\t\t    build_int_cstu (rtype, 3)));\n+  ASSERT_FALSE (vr1.varying_p ());\n+\n+  // Test that copying to a multi-range does not change things.\n+  int_range<2> ir1 (vr1);\n+  ASSERT_TRUE (ir1 == vr1);\n+  ASSERT_FALSE (ir1.varying_p ());\n+\n+  // The same test as above, but using TYPE_{MIN,MAX}_VALUE instead of [0,3].\n+  vr1 = int_range<1> (TYPE_MIN_VALUE (rtype), TYPE_MAX_VALUE (rtype));\n+  ir1 = vr1;\n+  ASSERT_TRUE (ir1 == vr1);\n+  ASSERT_FALSE (ir1.varying_p ());\n+}\n+\n static void\n range_tests_misc ()\n {\n@@ -2442,6 +2479,7 @@ range_tests ()\n   range_tests_legacy ();\n   range_tests_irange3 ();\n   range_tests_int_range_max ();\n+  range_tests_strict_enum ();\n   range_tests_misc ();\n }\n "}, {"sha": "7428c91ea57e8385afbedbc9ca1d0b0217237149", "filename": "gcc/value-range.h", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d3470e239e8040f642a8852721b4962b4ed36f2/gcc%2Fvalue-range.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d3470e239e8040f642a8852721b4962b4ed36f2/gcc%2Fvalue-range.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-range.h?ref=3d3470e239e8040f642a8852721b4962b4ed36f2", "patch": "@@ -280,12 +280,14 @@ irange::varying_p () const\n   tree l = m_base[0];\n   tree u = m_base[1];\n   tree t = TREE_TYPE (l);\n+  unsigned prec = TYPE_PRECISION (t);\n+  signop sign = TYPE_SIGN (t);\n   if (INTEGRAL_TYPE_P (t))\n-    return l == TYPE_MIN_VALUE (t) && u == TYPE_MAX_VALUE (t);\n+    return (wi::to_wide (l) == wi::min_value (prec, sign)\n+\t    && wi::to_wide (u) == wi::max_value (prec, sign));\n   if (POINTER_TYPE_P (t))\n-    return wi::to_wide (l) == 0\n-\t   && wi::to_wide (u) == wi::max_value (TYPE_PRECISION (t),\n-\t\t\t\t\t\tTYPE_SIGN (t));\n+    return (wi::to_wide (l) == 0\n+\t    && wi::to_wide (u) == wi::max_value (prec, sign));\n   return true;\n \n }\n@@ -469,8 +471,10 @@ irange::set_varying (tree type)\n   m_num_ranges = 1;\n   if (INTEGRAL_TYPE_P (type))\n     {\n-      m_base[0] = TYPE_MIN_VALUE (type);\n-      m_base[1] = TYPE_MAX_VALUE (type);\n+      wide_int min = wi::min_value (TYPE_PRECISION (type), TYPE_SIGN (type));\n+      wide_int max = wi::max_value (TYPE_PRECISION (type), TYPE_SIGN (type));\n+      m_base[0] = wide_int_to_tree (type, min);\n+      m_base[1] = wide_int_to_tree (type, max);\n     }\n   else if (POINTER_TYPE_P (type))\n     {\n@@ -566,13 +570,6 @@ irange::set_zero (tree type)\n }\n \n // Normalize a range to VARYING or UNDEFINED if possible.\n-//\n-// Avoid using TYPE_{MIN,MAX}_VALUE because -fstrict-enums can\n-// restrict those to a subset of what actually fits in the type.\n-// Instead use the extremes of the type precision which will allow\n-// compare_range_with_value() to check if a value is inside a range,\n-// whereas if we used TYPE_*_VAL, said function would just punt upon\n-// seeing a VARYING.\n \n inline void\n irange::normalize_min_max ()"}]}