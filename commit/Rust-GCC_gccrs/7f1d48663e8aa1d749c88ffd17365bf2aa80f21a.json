{"sha": "7f1d48663e8aa1d749c88ffd17365bf2aa80f21a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2YxZDQ4NjYzZThhYTFkNzQ5Yzg4ZmZkMTczNjViZjJhYTgwZjIxYQ==", "commit": {"author": {"name": "Alexandre Petit-Bianco", "email": "apbianco@cygnus.com", "date": "1999-04-26T19:09:37Z"}, "committer": {"name": "Alexandre Petit-Bianco", "email": "apbianco@gcc.gnu.org", "date": "1999-04-26T19:09:37Z"}, "message": "class.c (layout_class_method): Generate <clinit>'s rtl for interfaces.\n\nSat Apr 24 16:50:19 1999  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n\t* class.c (layout_class_method): Generate <clinit>'s rtl for\n \tinterfaces.\n\t* decl.c (complete_start_java_method): Don't call _Jv_InitClass\n \tfor interfaces' <clinit>.\n\t* expr.c (lookup_field): Search for fields in interfaces.\n\t(expand_invoke): Fixed indentation.\n\t(expand_java_field_op): Likewise. Use IS_CLINIT.\n\t* parse.h (JPRIMITIVE_TYPE_OR_VOID_P): Macro removed.\n\t(IS_CLINIT): New macro.\n\t* parse.y (type_declaration:): Call maybe_generate_clinit after an\n \tinterface was parsed.\n\t(maybe_generate_clinit): Don't generate if the current class is an\n \tinterface with only fields of primitive types.\n\t(reset_method_name): Use IS_CLINIT.\n\t(java_complete_expand_method): Expand <clinit> when it exists for\n \tinterfaces. Use IS_CLINIT.\n\t(resolve_expression_name): Use DECL_CONTEXT instead of\n \tcurrent_class to build static field references.\n\t(java_complete_lhs): Use IS__CLINIT. Don't use SAVE_EXPR on\n \tARRAY_REF when doing xreferencing.\n\t(check_final_assignment): Fixed typo in leading comment. Use\n \tIS_CLINIT.\n\t(patch_array_ref): Don't fully expand array references when\n \txreferencing.\n\t(patch_return): Use IS_CLINIT.\n\t(patch_throw_statement): Likewise.\n\nFrom-SVN: r26661", "tree": {"sha": "38ae2203c1adb1c12229db14df3792c799011465", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/38ae2203c1adb1c12229db14df3792c799011465"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7f1d48663e8aa1d749c88ffd17365bf2aa80f21a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f1d48663e8aa1d749c88ffd17365bf2aa80f21a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7f1d48663e8aa1d749c88ffd17365bf2aa80f21a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f1d48663e8aa1d749c88ffd17365bf2aa80f21a/comments", "author": null, "committer": null, "parents": [{"sha": "ccd63d90d14a15e87224d8fba54870ab78167a25", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ccd63d90d14a15e87224d8fba54870ab78167a25", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ccd63d90d14a15e87224d8fba54870ab78167a25"}], "stats": {"total": 1065, "additions": 575, "deletions": 490}, "files": [{"sha": "7376267b9cbcebc39003b93e141c214ca931434b", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f1d48663e8aa1d749c88ffd17365bf2aa80f21a/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f1d48663e8aa1d749c88ffd17365bf2aa80f21a/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=7f1d48663e8aa1d749c88ffd17365bf2aa80f21a", "patch": "@@ -1,3 +1,32 @@\n+Sat Apr 24 16:50:19 1999  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+\t* class.c (layout_class_method): Generate <clinit>'s rtl for\n+ \tinterfaces.\n+\t* decl.c (complete_start_java_method): Don't call _Jv_InitClass\n+ \tfor interfaces' <clinit>.\n+\t* expr.c (lookup_field): Search for fields in interfaces.\n+\t(expand_invoke): Fixed indentation.\n+\t(expand_java_field_op): Likewise. Use IS_CLINIT.\n+\t* parse.h (JPRIMITIVE_TYPE_OR_VOID_P): Macro removed.\n+\t(IS_CLINIT): New macro.\n+\t* parse.y (type_declaration:): Call maybe_generate_clinit after an\n+ \tinterface was parsed.\n+\t(maybe_generate_clinit): Don't generate if the current class is an\n+ \tinterface with only fields of primitive types.\n+\t(reset_method_name): Use IS_CLINIT.\n+\t(java_complete_expand_method): Expand <clinit> when it exists for\n+ \tinterfaces. Use IS_CLINIT.\n+\t(resolve_expression_name): Use DECL_CONTEXT instead of\n+ \tcurrent_class to build static field references.\n+\t(java_complete_lhs): Use IS__CLINIT. Don't use SAVE_EXPR on\n+ \tARRAY_REF when doing xreferencing.\n+\t(check_final_assignment): Fixed typo in leading comment. Use\n+ \tIS_CLINIT.\n+\t(patch_array_ref): Don't fully expand array references when\n+ \txreferencing.\n+\t(patch_return): Use IS_CLINIT.\n+\t(patch_throw_statement): Likewise.\n+\n 1999-04-22  Tom Tromey  <tromey@cygnus.com>\n \n \t* Make-lang.in (JAVA_SRCS): Added check-init.c."}, {"sha": "6cb3dfcb265d853a69d9f99e26b6a266554217bb", "filename": "gcc/java/class.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f1d48663e8aa1d749c88ffd17365bf2aa80f21a/gcc%2Fjava%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f1d48663e8aa1d749c88ffd17365bf2aa80f21a/gcc%2Fjava%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fclass.c?ref=7f1d48663e8aa1d749c88ffd17365bf2aa80f21a", "patch": "@@ -1623,11 +1623,14 @@ layout_class_method (this_class, super_class, method_decl, dtable_count)\n   obstack_1grow (&temporary_obstack, '\\0');\n   asm_name = obstack_finish (&temporary_obstack);\n   DECL_ASSEMBLER_NAME (method_decl) = get_identifier (asm_name);\n+  /* We don't generate a RTL for the method if it's abstract, or if\n+     it's an interface method that isn't clinit. */\n   if (! METHOD_ABSTRACT (method_decl) \n-      && ! CLASS_INTERFACE (TYPE_NAME (this_class)))\n+      || (CLASS_INTERFACE (TYPE_NAME (this_class)) \n+\t  && (IS_CLINIT (method_decl))))\n     make_function_rtl (method_decl);\n   obstack_free (&temporary_obstack, asm_name);\n-  \n+\n   if (method_name == init_identifier_node)\n     {\n       char *p = IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (this_class)));"}, {"sha": "a04c1c89b6615f6d62a85d934e35e98d11006747", "filename": "gcc/java/decl.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f1d48663e8aa1d749c88ffd17365bf2aa80f21a/gcc%2Fjava%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f1d48663e8aa1d749c88ffd17365bf2aa80f21a/gcc%2Fjava%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fdecl.c?ref=7f1d48663e8aa1d749c88ffd17365bf2aa80f21a", "patch": "@@ -1526,7 +1526,8 @@ complete_start_java_method (fndecl)\n #endif\n \n   if (METHOD_STATIC (fndecl) && ! METHOD_PRIVATE (fndecl)\n-      && ! flag_emit_class_files)\n+      && ! flag_emit_class_files\n+      && ! CLASS_INTERFACE (TYPE_NAME (current_class)))\n     {\n       tree clas = DECL_CONTEXT (fndecl);\n       tree init = build (CALL_EXPR, void_type_node,"}, {"sha": "bcecb2b6898e5c168b89b1d39a1fc482fd8bdede", "filename": "gcc/java/expr.c", "status": "modified", "additions": 24, "deletions": 10, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f1d48663e8aa1d749c88ffd17365bf2aa80f21a/gcc%2Fjava%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f1d48663e8aa1d749c88ffd17365bf2aa80f21a/gcc%2Fjava%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexpr.c?ref=7f1d48663e8aa1d749c88ffd17365bf2aa80f21a", "patch": "@@ -1167,10 +1167,20 @@ lookup_field (typep, name)\n     }\n   do\n     {\n-      tree field;\n-      for (field = TYPE_FIELDS (*typep);  field;  field = TREE_CHAIN (field))\n+      tree field, basetype_vec;\n+      int n, i;\n+\n+      for (field = TYPE_FIELDS (*typep); field; field = TREE_CHAIN (field))\n+\tif (DECL_NAME (field) == name)\n+\t  return field;\n+\n+      /* Process implemented interfaces. */\n+      basetype_vec = TYPE_BINFO_BASETYPES (*typep);\n+      n = TREE_VEC_LENGTH (basetype_vec);\n+      for (i = 0; i < n; i++)\n \t{\n-\t  if (DECL_NAME (field) == name)\n+\t  tree t = BINFO_TYPE (TREE_VEC_ELT (basetype_vec, i));\n+\t  if ((field = lookup_field (&t, name)))\n \t    return field;\n \t}\n       *typep = CLASSTYPE_SUPER (*typep);\n@@ -1626,7 +1636,8 @@ expand_invoke (opcode, method_ref_index, nargs)\n   if (opcode == OPCODE_invokestatic || opcode == OPCODE_invokespecial\n       || (opcode == OPCODE_invokevirtual\n \t  && (METHOD_PRIVATE (method)\n-\t      || METHOD_FINAL (method) || CLASS_FINAL (TYPE_NAME (self_type)))))\n+\t      || METHOD_FINAL (method) \n+\t      || CLASS_FINAL (TYPE_NAME (self_type)))))\n     func = build_known_method_ref (method, method_type, self_type,\n \t\t\t\t   method_signature, arg_list);\n   else\n@@ -1663,11 +1674,14 @@ expand_java_field_op (is_static, is_putting, field_ref_index)\n      int is_putting;\n      int field_ref_index;\n {\n-  tree self_type = get_class_constant\n-    (current_jcf, COMPONENT_REF_CLASS_INDEX (&current_jcf->cpool, field_ref_index));\n+  tree self_type = \n+      get_class_constant (current_jcf, \n+\t\t\t  COMPONENT_REF_CLASS_INDEX (&current_jcf->cpool, \n+\t\t\t\t\t\t     field_ref_index));\n   char *self_name = IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (self_type)));\n   tree field_name = COMPONENT_REF_NAME (&current_jcf->cpool, field_ref_index);\n-  tree field_signature = COMPONENT_REF_SIGNATURE (&current_jcf->cpool, field_ref_index);\n+  tree field_signature = COMPONENT_REF_SIGNATURE (&current_jcf->cpool, \n+\t\t\t\t\t\t  field_ref_index);\n   tree field_type = get_type_from_signature (field_signature);\n   tree new_value = is_putting ? pop_value (field_type) : NULL_TREE;\n   tree field_ref;\n@@ -1727,15 +1741,15 @@ expand_java_field_op (is_static, is_putting, field_ref_index)\n \t\t     \"assignment to final field `%s' not in field's class\");\n \t  else if (FIELD_STATIC (field_decl))\n \t    {\n-\t      if (DECL_NAME (current_function_decl) != clinit_identifier_node)\n+\t      if (!IS_CLINIT (current_function_decl))\n \t\terror_with_decl (field_decl, \n              \"assignment to final static field `%s' not in class initializer\");\n \t    }\n \t  else\n \t    {\n \t      if (! DECL_CONSTRUCTOR_P (current_function_decl))\n-\t\terror_with_decl (field_decl, \n-                           \"assignment to final field `%s' not in constructor\");\n+\t\terror_with_decl (field_decl, \"assignment to final field `%s' \"\n+\t\t\t\t \"not in constructor\");\n \t    }\n \t}\n       expand_assignment (field_ref, new_value, 0, 0);"}, {"sha": "c69b2b91c4e209e9e2a8827512951615089947f2", "filename": "gcc/java/parse.c", "status": "modified", "additions": 455, "deletions": 435, "changes": 890, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f1d48663e8aa1d749c88ffd17365bf2aa80f21a/gcc%2Fjava%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f1d48663e8aa1d749c88ffd17365bf2aa80f21a/gcc%2Fjava%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.c?ref=7f1d48663e8aa1d749c88ffd17365bf2aa80f21a", "patch": "@@ -684,51 +684,51 @@ static const short yyrline[] = { 0,\n    508,   510,   515,   517,   520,   524,   529,   534,   536,   537,\n    538,   539,   540,   541,   542,   545,   550,   556,   558,   561,\n    564,   566,   570,   572,   575,   602,   604,   608,   621,   623,\n-   627,   634,   635,   637,   647,   652,   667,   671,   674,   677,\n-   680,   682,   684,   689,   693,   695,   697,   699,   703,   705,\n-   707,   714,   720,   725,   729,   732,   736,   738,   741,   743,\n-   744,   745,   749,   751,   753,   754,   756,   761,   764,   774,\n-   777,   779,   783,   786,   793,   799,   807,   809,   811,   813,\n-   815,   819,   821,   825,   832,   833,   837,   840,   842,   844,\n-   846,   848,   850,   852,   854,   861,   864,   866,   875,   877,\n-   881,   886,   891,   895,   900,   902,   904,   911,   913,   915,\n-   919,   922,   924,   928,   930,   931,   936,   942,   949,   957,\n-   964,   967,   970,   974,   977,   981,   990,   992,   994,   999,\n-  1006,  1014,  1016,  1020,  1027,  1037,  1041,  1044,  1047,  1050,\n-  1053,  1056,  1059,  1062,  1064,  1068,  1074,  1079,  1081,  1085,\n-  1088,  1092,  1094,  1097,  1099,  1100,  1102,  1106,  1110,  1116,\n-  1121,  1124,  1126,  1130,  1136,  1140,  1145,  1148,  1152,  1157,\n-  1165,  1167,  1170,  1172,  1174,  1178,  1182,  1185,  1189,  1191,\n-  1192,  1193,  1194,  1195,  1205,  1207,  1208,  1209,  1210,  1213,\n-  1215,  1216,  1217,  1218,  1219,  1220,  1221,  1222,  1223,  1224,\n-  1227,  1232,  1243,  1246,  1250,  1257,  1267,  1273,  1279,  1285,\n-  1287,  1293,  1295,  1301,  1303,  1305,  1307,  1309,  1313,  1315,\n-  1316,  1317,  1318,  1319,  1320,  1323,  1329,  1331,  1333,  1337,\n-  1342,  1347,  1353,  1363,  1369,  1371,  1373,  1380,  1383,  1385,\n-  1387,  1391,  1393,  1396,  1400,  1402,  1405,  1412,  1418,  1420,\n-  1422,  1426,  1434,  1437,  1439,  1441,  1445,  1450,  1459,  1464,\n-  1467,  1474,  1476,  1478,  1482,  1485,  1494,  1501,  1503,  1507,\n-  1520,  1522,  1528,  1534,  1538,  1540,  1544,  1547,  1549,  1553,\n-  1556,  1558,  1560,  1564,  1567,  1569,  1571,  1575,  1578,  1580,\n-  1582,  1586,  1592,  1594,  1598,  1605,  1607,  1609,  1611,  1615,\n-  1623,  1626,  1628,  1633,  1637,  1639,  1646,  1654,  1671,  1673,\n-  1675,  1679,  1682,  1687,  1689,  1692,  1694,  1696,  1698,  1699,\n-  1700,  1701,  1705,  1707,  1709,  1714,  1716,  1718,  1720,  1722,\n-  1726,  1729,  1734,  1736,  1741,  1742,  1743,  1744,  1745,  1747,\n-  1749,  1751,  1753,  1755,  1759,  1761,  1764,  1770,  1775,  1779,\n-  1782,  1784,  1786,  1790,  1792,  1794,  1796,  1800,  1803,  1807,\n-  1813,  1815,  1823,  1850,  1852,  1856,  1861,  1868,  1872,  1875,\n-  1877,  1888,  1899,  1904,  1913,  1915,  1919,  1922,  1924,  1929,\n-  1934,  1939,  1946,  1948,  1949,  1950,  1953,  1958,  1963,  1965,\n-  1966,  1968,  1970,  1971,  1973,  1977,  1980,  1984,  1987,  1991,\n-  1993,  1995,  1997,  1998,  2000,  2004,  2013,  2015,  2017,  2030,\n-  2032,  2038,  2040,  2042,  2046,  2048,  2053,  2058,  2063,  2065,\n-  2067,  2071,  2073,  2078,  2083,  2085,  2089,  2091,  2096,  2101,\n-  2106,  2108,  2110,  2114,  2116,  2121,  2126,  2131,  2136,  2138,\n-  2140,  2142,  2144,  2146,  2150,  2152,  2157,  2162,  2164,  2168,\n-  2170,  2175,  2179,  2181,  2186,  2190,  2192,  2197,  2201,  2203,\n-  2208,  2212,  2214,  2219,  2223,  2225,  2230,  2236,  2238,  2242,\n-  2244,  2247,  2250,  2258,  2260,  2261,  2264,  2266,  2269,  2273\n+   627,   634,   639,   641,   651,   656,   671,   675,   678,   681,\n+   684,   686,   688,   693,   697,   699,   701,   703,   707,   709,\n+   711,   718,   724,   729,   733,   736,   740,   742,   745,   747,\n+   748,   749,   753,   755,   757,   758,   760,   765,   768,   778,\n+   781,   783,   787,   790,   797,   803,   811,   813,   815,   817,\n+   819,   823,   825,   829,   836,   837,   841,   844,   846,   848,\n+   850,   852,   854,   856,   858,   865,   868,   870,   879,   881,\n+   885,   890,   895,   899,   904,   906,   908,   915,   917,   919,\n+   923,   926,   928,   932,   934,   935,   940,   946,   953,   961,\n+   968,   971,   974,   978,   981,   985,   994,   996,   998,  1003,\n+  1010,  1018,  1020,  1024,  1031,  1041,  1045,  1048,  1051,  1054,\n+  1057,  1060,  1063,  1066,  1068,  1072,  1078,  1083,  1085,  1089,\n+  1092,  1096,  1098,  1101,  1103,  1104,  1106,  1110,  1114,  1120,\n+  1125,  1128,  1130,  1134,  1140,  1144,  1149,  1152,  1156,  1161,\n+  1169,  1171,  1174,  1176,  1178,  1182,  1186,  1189,  1193,  1195,\n+  1196,  1197,  1198,  1199,  1209,  1211,  1212,  1213,  1214,  1217,\n+  1219,  1220,  1221,  1222,  1223,  1224,  1225,  1226,  1227,  1228,\n+  1231,  1236,  1247,  1250,  1254,  1261,  1271,  1277,  1283,  1289,\n+  1291,  1297,  1299,  1305,  1307,  1309,  1311,  1313,  1317,  1319,\n+  1320,  1321,  1322,  1323,  1324,  1327,  1333,  1335,  1337,  1341,\n+  1346,  1351,  1357,  1367,  1373,  1375,  1377,  1384,  1387,  1389,\n+  1391,  1395,  1397,  1400,  1404,  1406,  1409,  1416,  1422,  1424,\n+  1426,  1430,  1438,  1441,  1443,  1445,  1449,  1454,  1463,  1468,\n+  1471,  1478,  1480,  1482,  1486,  1489,  1498,  1505,  1507,  1511,\n+  1524,  1526,  1532,  1538,  1542,  1544,  1548,  1551,  1553,  1557,\n+  1560,  1562,  1564,  1568,  1571,  1573,  1575,  1579,  1582,  1584,\n+  1586,  1590,  1596,  1598,  1602,  1609,  1611,  1613,  1615,  1619,\n+  1627,  1630,  1632,  1637,  1641,  1643,  1650,  1658,  1675,  1677,\n+  1679,  1683,  1686,  1691,  1693,  1696,  1698,  1700,  1702,  1703,\n+  1704,  1705,  1709,  1711,  1713,  1718,  1720,  1722,  1724,  1726,\n+  1730,  1733,  1738,  1740,  1745,  1746,  1747,  1748,  1749,  1751,\n+  1753,  1755,  1757,  1759,  1763,  1765,  1768,  1774,  1779,  1783,\n+  1786,  1788,  1790,  1794,  1796,  1798,  1800,  1804,  1807,  1811,\n+  1817,  1819,  1827,  1854,  1856,  1860,  1865,  1872,  1876,  1879,\n+  1881,  1892,  1903,  1908,  1917,  1919,  1923,  1926,  1928,  1933,\n+  1938,  1943,  1950,  1952,  1953,  1954,  1957,  1962,  1967,  1969,\n+  1970,  1972,  1974,  1975,  1977,  1981,  1984,  1988,  1991,  1995,\n+  1997,  1999,  2001,  2002,  2004,  2008,  2017,  2019,  2021,  2034,\n+  2036,  2042,  2044,  2046,  2050,  2052,  2057,  2062,  2067,  2069,\n+  2071,  2075,  2077,  2082,  2087,  2089,  2093,  2095,  2100,  2105,\n+  2110,  2112,  2114,  2118,  2120,  2125,  2130,  2135,  2140,  2142,\n+  2144,  2146,  2148,  2150,  2154,  2156,  2161,  2166,  2168,  2172,\n+  2174,  2179,  2183,  2185,  2190,  2194,  2196,  2201,  2205,  2207,\n+  2212,  2216,  2218,  2223,  2227,  2229,  2234,  2240,  2242,  2246,\n+  2248,  2251,  2254,  2262,  2264,  2265,  2268,  2270,  2273,  2277\n };\n #endif\n \n@@ -2848,25 +2848,32 @@ case 51:\n \t\t  yyval.node = yyvsp[0].node;\n \t\t;\n     break;}\n+case 52:\n+#line 635 \"./parse.y\"\n+{\n+\t\t  maybe_generate_clinit ();\n+\t\t  yyval.node = yyvsp[0].node;\n+\t\t;\n+    break;}\n case 53:\n-#line 636 \"./parse.y\"\n+#line 640 \"./parse.y\"\n { yyval.node = NULL; ;\n     break;}\n case 54:\n-#line 638 \"./parse.y\"\n+#line 642 \"./parse.y\"\n {\n \t\t  YYERROR_NOW;\n \t\t  yyerror (\"Class or interface declaration expected\");\n \t\t;\n     break;}\n case 55:\n-#line 649 \"./parse.y\"\n+#line 653 \"./parse.y\"\n {\n \t\t  yyval.value = (1 << yyvsp[0].value);\n \t\t;\n     break;}\n case 56:\n-#line 653 \"./parse.y\"\n+#line 657 \"./parse.y\"\n {\n \t\t  int acc = (1 << yyvsp[0].value);\n \t\t  if (yyval.value & acc)\n@@ -2880,123 +2887,123 @@ case 56:\n \t\t;\n     break;}\n case 57:\n-#line 669 \"./parse.y\"\n+#line 673 \"./parse.y\"\n { create_class (yyvsp[-4].value, yyvsp[-2].node, yyvsp[-1].node, yyvsp[0].node); ;\n     break;}\n case 58:\n-#line 671 \"./parse.y\"\n+#line 675 \"./parse.y\"\n { \n \t\t  yyval.node = yyvsp[0].node;\n \t\t;\n     break;}\n case 59:\n-#line 675 \"./parse.y\"\n+#line 679 \"./parse.y\"\n { create_class (0, yyvsp[-2].node, yyvsp[-1].node, yyvsp[0].node); ;\n     break;}\n case 60:\n-#line 677 \"./parse.y\"\n+#line 681 \"./parse.y\"\n { \t\n \t\t  yyval.node = yyvsp[0].node;\n \t\t;\n     break;}\n case 61:\n-#line 681 \"./parse.y\"\n+#line 685 \"./parse.y\"\n {yyerror (\"Missing class name\"); RECOVER;;\n     break;}\n case 62:\n-#line 683 \"./parse.y\"\n+#line 687 \"./parse.y\"\n {yyerror (\"Missing class name\"); RECOVER;;\n     break;}\n case 63:\n-#line 685 \"./parse.y\"\n+#line 689 \"./parse.y\"\n {\n \t\t  if (!ctxp->class_err) yyerror (\"'{' expected\"); \n \t\t  DRECOVER(class1);\n \t\t;\n     break;}\n case 64:\n-#line 690 \"./parse.y\"\n+#line 694 \"./parse.y\"\n {if (!ctxp->class_err) yyerror (\"'{' expected\"); RECOVER;;\n     break;}\n case 65:\n-#line 694 \"./parse.y\"\n+#line 698 \"./parse.y\"\n { yyval.node = NULL; ;\n     break;}\n case 66:\n-#line 696 \"./parse.y\"\n+#line 700 \"./parse.y\"\n { yyval.node = yyvsp[0].node; ;\n     break;}\n case 67:\n-#line 698 \"./parse.y\"\n+#line 702 \"./parse.y\"\n {yyerror (\"'{' expected\"); ctxp->class_err=1;;\n     break;}\n case 68:\n-#line 700 \"./parse.y\"\n+#line 704 \"./parse.y\"\n {yyerror (\"Missing super class name\"); ctxp->class_err=1;;\n     break;}\n case 69:\n-#line 704 \"./parse.y\"\n+#line 708 \"./parse.y\"\n { yyval.node = NULL_TREE; ;\n     break;}\n case 70:\n-#line 706 \"./parse.y\"\n+#line 710 \"./parse.y\"\n { yyval.node = yyvsp[0].node; ;\n     break;}\n case 71:\n-#line 708 \"./parse.y\"\n+#line 712 \"./parse.y\"\n {\n \t\t  ctxp->class_err=1;\n \t\t  yyerror (\"Missing interface name\"); \n \t\t;\n     break;}\n case 72:\n-#line 716 \"./parse.y\"\n+#line 720 \"./parse.y\"\n { \n \t\t  ctxp->interface_number = 1;\n \t\t  yyval.node = build_tree_list (yyvsp[0].node, NULL_TREE);\n \t\t;\n     break;}\n case 73:\n-#line 721 \"./parse.y\"\n+#line 725 \"./parse.y\"\n { \n \t\t  ctxp->interface_number++;\n \t\t  yyval.node = chainon (yyvsp[-2].node, build_tree_list (yyvsp[0].node, NULL_TREE));\n \t\t;\n     break;}\n case 74:\n-#line 726 \"./parse.y\"\n+#line 730 \"./parse.y\"\n {yyerror (\"Missing interface name\"); RECOVER;;\n     break;}\n case 75:\n-#line 731 \"./parse.y\"\n+#line 735 \"./parse.y\"\n { yyval.node = ctxp->current_parsed_class; ;\n     break;}\n case 76:\n-#line 733 \"./parse.y\"\n+#line 737 \"./parse.y\"\n { yyval.node = ctxp->current_parsed_class; ;\n     break;}\n case 82:\n-#line 746 \"./parse.y\"\n+#line 750 \"./parse.y\"\n { yyval.node = parse_jdk1_1_error (\"instance initializer\"); ;\n     break;}\n case 84:\n-#line 752 \"./parse.y\"\n+#line 756 \"./parse.y\"\n { yyval.node = yyvsp[-1].node; ;\n     break;}\n case 86:\n-#line 755 \"./parse.y\"\n+#line 759 \"./parse.y\"\n { yyval.node = parse_jdk1_1_error (\"inner classe declaration\"); ;\n     break;}\n case 87:\n-#line 757 \"./parse.y\"\n+#line 761 \"./parse.y\"\n { yyval.node = parse_jdk1_1_error (\"inner interface declaration\"); ;\n     break;}\n case 88:\n-#line 763 \"./parse.y\"\n+#line 767 \"./parse.y\"\n { register_fields (0, yyvsp[-2].node, yyvsp[-1].node); ;\n     break;}\n case 89:\n-#line 765 \"./parse.y\"\n+#line 769 \"./parse.y\"\n {\n \t\t  check_modifiers \n \t\t    (\"Illegal modifier `%s' for field declaration\",\n@@ -3006,19 +3013,19 @@ case 89:\n \t\t;\n     break;}\n case 91:\n-#line 778 \"./parse.y\"\n+#line 782 \"./parse.y\"\n { yyval.node = chainon (yyvsp[-2].node, yyvsp[0].node); ;\n     break;}\n case 92:\n-#line 780 \"./parse.y\"\n+#line 784 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 93:\n-#line 785 \"./parse.y\"\n+#line 789 \"./parse.y\"\n { yyval.node = build_tree_list (yyvsp[0].node, NULL_TREE); ;\n     break;}\n case 94:\n-#line 787 \"./parse.y\"\n+#line 791 \"./parse.y\"\n { \n \t\t  if (java_error_count)\n \t\t    yyvsp[0].node = NULL_TREE;\n@@ -3027,101 +3034,101 @@ case 94:\n \t\t;\n     break;}\n case 95:\n-#line 794 \"./parse.y\"\n+#line 798 \"./parse.y\"\n {\n \t\t  yyerror (\"Missing variable initializer\");\n \t\t  yyval.node = build_tree_list (yyvsp[-2].node, NULL_TREE);\n \t\t  RECOVER;\n \t\t;\n     break;}\n case 96:\n-#line 800 \"./parse.y\"\n+#line 804 \"./parse.y\"\n {\n \t\t  yyerror (\"';' expected\");\n \t\t  yyval.node = build_tree_list (yyvsp[-3].node, NULL_TREE);\n \t\t  RECOVER;\n \t\t;\n     break;}\n case 98:\n-#line 810 \"./parse.y\"\n+#line 814 \"./parse.y\"\n { yyval.node = build_unresolved_array_type (yyvsp[-2].node); ;\n     break;}\n case 99:\n-#line 812 \"./parse.y\"\n+#line 816 \"./parse.y\"\n {yyerror (\"Invalid declaration\"); DRECOVER(vdi);;\n     break;}\n case 100:\n-#line 814 \"./parse.y\"\n+#line 818 \"./parse.y\"\n {yyerror (\"']' expected\"); DRECOVER(vdi);;\n     break;}\n case 101:\n-#line 816 \"./parse.y\"\n+#line 820 \"./parse.y\"\n {yyerror (\"Unbalanced ']'\"); DRECOVER(vdi);;\n     break;}\n case 104:\n-#line 827 \"./parse.y\"\n+#line 831 \"./parse.y\"\n {\n \t\t  current_function_decl = yyvsp[0].node;\n \t\t  source_start_java_method (current_function_decl);\n \t\t;\n     break;}\n case 105:\n-#line 832 \"./parse.y\"\n+#line 836 \"./parse.y\"\n { finish_method_declaration (yyvsp[0].node); ;\n     break;}\n case 106:\n-#line 834 \"./parse.y\"\n+#line 838 \"./parse.y\"\n {YYNOT_TWICE yyerror (\"'{' expected\"); RECOVER;;\n     break;}\n case 107:\n-#line 839 \"./parse.y\"\n+#line 843 \"./parse.y\"\n { yyval.node = method_header (0, yyvsp[-2].node, yyvsp[-1].node, yyvsp[0].node); ;\n     break;}\n case 108:\n-#line 841 \"./parse.y\"\n+#line 845 \"./parse.y\"\n { yyval.node = method_header (0, void_type_node, yyvsp[-1].node, yyvsp[0].node); ;\n     break;}\n case 109:\n-#line 843 \"./parse.y\"\n+#line 847 \"./parse.y\"\n { yyval.node = method_header (yyvsp[-3].value, yyvsp[-2].node, yyvsp[-1].node, yyvsp[0].node); ;\n     break;}\n case 110:\n-#line 845 \"./parse.y\"\n+#line 849 \"./parse.y\"\n { yyval.node = method_header (yyvsp[-3].value, void_type_node, yyvsp[-1].node, yyvsp[0].node); ;\n     break;}\n case 111:\n-#line 847 \"./parse.y\"\n+#line 851 \"./parse.y\"\n {RECOVER;;\n     break;}\n case 112:\n-#line 849 \"./parse.y\"\n+#line 853 \"./parse.y\"\n {RECOVER;;\n     break;}\n case 113:\n-#line 851 \"./parse.y\"\n+#line 855 \"./parse.y\"\n {yyerror (\"Identifier expected\"); RECOVER;;\n     break;}\n case 114:\n-#line 853 \"./parse.y\"\n+#line 857 \"./parse.y\"\n {yyerror (\"Identifier expected\"); RECOVER;;\n     break;}\n case 115:\n-#line 855 \"./parse.y\"\n+#line 859 \"./parse.y\"\n {\n \t\t  yyerror (\"Invalid method declaration, return type required\");\n \t\t  RECOVER;\n \t\t;\n     break;}\n case 116:\n-#line 863 \"./parse.y\"\n+#line 867 \"./parse.y\"\n { yyval.node = method_declarator (yyvsp[-2].node, NULL_TREE); ;\n     break;}\n case 117:\n-#line 865 \"./parse.y\"\n+#line 869 \"./parse.y\"\n { yyval.node = method_declarator (yyvsp[-3].node, yyvsp[-1].node); ;\n     break;}\n case 118:\n-#line 867 \"./parse.y\"\n+#line 871 \"./parse.y\"\n {\n \t\t  EXPR_WFL_LINECOL (wfl_operator) = yyvsp[-1].operator.location;\n \t\t  TREE_PURPOSE (yyvsp[-2].node) = \n@@ -3132,348 +3139,348 @@ case 118:\n \t\t;\n     break;}\n case 119:\n-#line 876 \"./parse.y\"\n+#line 880 \"./parse.y\"\n {yyerror (\"')' expected\"); DRECOVER(method_declarator);;\n     break;}\n case 120:\n-#line 878 \"./parse.y\"\n+#line 882 \"./parse.y\"\n {yyerror (\"']' expected\"); RECOVER;;\n     break;}\n case 121:\n-#line 883 \"./parse.y\"\n+#line 887 \"./parse.y\"\n {\n \t\t  ctxp->formal_parameter_number = 1;\n \t\t;\n     break;}\n case 122:\n-#line 887 \"./parse.y\"\n+#line 891 \"./parse.y\"\n {\n \t\t  ctxp->formal_parameter_number += 1;\n \t\t  yyval.node = chainon (yyvsp[-2].node, yyvsp[0].node);\n \t\t;\n     break;}\n case 123:\n-#line 892 \"./parse.y\"\n+#line 896 \"./parse.y\"\n {yyerror (\"Missing formal parameter term\"); RECOVER;;\n     break;}\n case 124:\n-#line 897 \"./parse.y\"\n+#line 901 \"./parse.y\"\n {\n \t\t  yyval.node = build_tree_list (yyvsp[0].node, yyvsp[-1].node);\n \t\t;\n     break;}\n case 125:\n-#line 901 \"./parse.y\"\n+#line 905 \"./parse.y\"\n { yyval.node = parse_jdk1_1_error (\"final parameters\"); ;\n     break;}\n case 126:\n-#line 903 \"./parse.y\"\n+#line 907 \"./parse.y\"\n {yyerror (\"Missing identifier\"); RECOVER;;\n     break;}\n case 127:\n-#line 905 \"./parse.y\"\n+#line 909 \"./parse.y\"\n {\n \t\t  SOURCE_FRONTEND_DEBUG ((\"Modifiers: %d\", yyvsp[-2].value));\n \t\t  yyerror (\"Missing identifier\"); RECOVER;\n \t\t;\n     break;}\n case 128:\n-#line 912 \"./parse.y\"\n+#line 916 \"./parse.y\"\n { yyval.node = NULL_TREE; ;\n     break;}\n case 129:\n-#line 914 \"./parse.y\"\n+#line 918 \"./parse.y\"\n { yyval.node = yyvsp[0].node; ;\n     break;}\n case 130:\n-#line 916 \"./parse.y\"\n+#line 920 \"./parse.y\"\n {yyerror (\"Missing class type term\"); RECOVER;;\n     break;}\n case 131:\n-#line 921 \"./parse.y\"\n+#line 925 \"./parse.y\"\n { yyval.node = build_tree_list (yyvsp[0].node, yyvsp[0].node); ;\n     break;}\n case 132:\n-#line 923 \"./parse.y\"\n+#line 927 \"./parse.y\"\n { yyval.node = tree_cons (yyvsp[0].node, yyvsp[0].node, yyvsp[-2].node); ;\n     break;}\n case 133:\n-#line 925 \"./parse.y\"\n+#line 929 \"./parse.y\"\n {yyerror (\"Missing class type term\"); RECOVER;;\n     break;}\n case 136:\n-#line 932 \"./parse.y\"\n+#line 936 \"./parse.y\"\n { yyval.node = NULL_TREE; ;\n     break;}\n case 137:\n-#line 938 \"./parse.y\"\n+#line 942 \"./parse.y\"\n {\n \t\t  TREE_CHAIN (yyvsp[0].node) = ctxp->static_initialized;\n \t\t  ctxp->static_initialized = yyvsp[0].node;\n \t\t;\n     break;}\n case 138:\n-#line 943 \"./parse.y\"\n+#line 947 \"./parse.y\"\n {\n \t\t  TREE_CHAIN (yyvsp[-1].node) = ctxp->static_initialized;\n \t\t  ctxp->static_initialized = yyvsp[-1].node;\n \t\t;\n     break;}\n case 139:\n-#line 951 \"./parse.y\"\n+#line 955 \"./parse.y\"\n {\n \t\t  SOURCE_FRONTEND_DEBUG ((\"Modifiers: %d\", yyvsp[0].value));\n \t\t;\n     break;}\n case 140:\n-#line 959 \"./parse.y\"\n+#line 963 \"./parse.y\"\n {\n \t\t  current_function_decl = yyvsp[0].node;\n \t\t  source_start_java_method (current_function_decl);\n \t\t;\n     break;}\n case 141:\n-#line 964 \"./parse.y\"\n+#line 968 \"./parse.y\"\n { finish_method_declaration (yyvsp[0].node); ;\n     break;}\n case 142:\n-#line 969 \"./parse.y\"\n+#line 973 \"./parse.y\"\n { yyval.node = method_header (0, NULL_TREE, yyvsp[-1].node, yyvsp[0].node); ;\n     break;}\n case 143:\n-#line 971 \"./parse.y\"\n+#line 975 \"./parse.y\"\n { yyval.node = method_header (yyvsp[-2].value, NULL_TREE, yyvsp[-1].node, yyvsp[0].node); ;\n     break;}\n case 144:\n-#line 976 \"./parse.y\"\n+#line 980 \"./parse.y\"\n { yyval.node = method_declarator (yyvsp[-2].node, NULL_TREE); ;\n     break;}\n case 145:\n-#line 978 \"./parse.y\"\n+#line 982 \"./parse.y\"\n { yyval.node = method_declarator (yyvsp[-3].node, yyvsp[-1].node); ;\n     break;}\n case 146:\n-#line 986 \"./parse.y\"\n+#line 990 \"./parse.y\"\n { \n \t\t  BLOCK_EXPR_BODY (yyvsp[0].node) = empty_stmt_node;\n \t\t  yyval.node = yyvsp[0].node;\n \t\t;\n     break;}\n case 147:\n-#line 991 \"./parse.y\"\n+#line 995 \"./parse.y\"\n { yyval.node = yyvsp[0].node; ;\n     break;}\n case 148:\n-#line 993 \"./parse.y\"\n+#line 997 \"./parse.y\"\n { yyval.node = yyvsp[0].node; ;\n     break;}\n case 149:\n-#line 995 \"./parse.y\"\n+#line 999 \"./parse.y\"\n { yyval.node = yyvsp[0].node; ;\n     break;}\n case 150:\n-#line 1001 \"./parse.y\"\n+#line 1005 \"./parse.y\"\n { \n \t\t  yyval.node = build_method_invocation (yyvsp[-3].node, NULL_TREE); \n \t\t  yyval.node = build_debugable_stmt (EXPR_WFL_LINECOL (yyvsp[-3].node), yyval.node);\n \t\t  yyval.node = java_method_add_stmt (current_function_decl, yyval.node);\n \t\t;\n     break;}\n case 151:\n-#line 1007 \"./parse.y\"\n+#line 1011 \"./parse.y\"\n { \n \t\t  yyval.node = build_method_invocation (yyvsp[-4].node, yyvsp[-2].node); \n \t\t  yyval.node = build_debugable_stmt (EXPR_WFL_LINECOL (yyvsp[-4].node), yyval.node);\n \t\t  yyval.node = java_method_add_stmt (current_function_decl, yyval.node);\n \t\t;\n     break;}\n case 152:\n-#line 1015 \"./parse.y\"\n+#line 1019 \"./parse.y\"\n {yyval.node = parse_jdk1_1_error (\"explicit constructor invocation\"); ;\n     break;}\n case 153:\n-#line 1017 \"./parse.y\"\n+#line 1021 \"./parse.y\"\n {yyval.node = parse_jdk1_1_error (\"explicit constructor invocation\"); ;\n     break;}\n case 154:\n-#line 1022 \"./parse.y\"\n+#line 1026 \"./parse.y\"\n {\n \t\t  tree wfl = build_wfl_node (this_identifier_node);\n \t\t  EXPR_WFL_LINECOL (wfl) = yyvsp[0].operator.location;\n \t\t  yyval.node = wfl;\n \t\t;\n     break;}\n case 155:\n-#line 1028 \"./parse.y\"\n+#line 1032 \"./parse.y\"\n {\n \t\t  tree wfl = build_wfl_node (super_identifier_node);\n \t\t  EXPR_WFL_LINECOL (wfl) = yyvsp[0].operator.location;\n \t\t  yyval.node = wfl;\n \t\t;\n     break;}\n case 156:\n-#line 1039 \"./parse.y\"\n+#line 1043 \"./parse.y\"\n { create_interface (0, yyvsp[0].node, NULL_TREE); ;\n     break;}\n case 157:\n-#line 1041 \"./parse.y\"\n+#line 1045 \"./parse.y\"\n {\n \t\t  yyval.node = yyvsp[0].node;\n \t\t;\n     break;}\n case 158:\n-#line 1045 \"./parse.y\"\n+#line 1049 \"./parse.y\"\n { create_interface (yyvsp[-2].value, yyvsp[0].node, NULL_TREE); ;\n     break;}\n case 159:\n-#line 1047 \"./parse.y\"\n+#line 1051 \"./parse.y\"\n {\n \t\t  yyval.node = yyvsp[0].node;\n \t\t;\n     break;}\n case 160:\n-#line 1051 \"./parse.y\"\n+#line 1055 \"./parse.y\"\n { create_interface (0, yyvsp[-1].node, yyvsp[0].node);\t;\n     break;}\n case 161:\n-#line 1053 \"./parse.y\"\n+#line 1057 \"./parse.y\"\n {\n \t\t  yyval.node = yyvsp[0].node;\n \t\t;\n     break;}\n case 162:\n-#line 1057 \"./parse.y\"\n+#line 1061 \"./parse.y\"\n { create_interface (yyvsp[-3].value, yyvsp[-1].node, yyvsp[0].node); ;\n     break;}\n case 163:\n-#line 1059 \"./parse.y\"\n+#line 1063 \"./parse.y\"\n {\n \t\t  yyval.node = yyvsp[0].node;\n \t\t;\n     break;}\n case 164:\n-#line 1063 \"./parse.y\"\n+#line 1067 \"./parse.y\"\n {yyerror (\"'{' expected\"); RECOVER;;\n     break;}\n case 165:\n-#line 1065 \"./parse.y\"\n+#line 1069 \"./parse.y\"\n {yyerror (\"'{' expected\"); RECOVER;;\n     break;}\n case 166:\n-#line 1070 \"./parse.y\"\n+#line 1074 \"./parse.y\"\n { \n \t\t  ctxp->interface_number = 1;\n \t\t  yyval.node = build_tree_list (yyvsp[0].node, NULL_TREE);\n \t\t;\n     break;}\n case 167:\n-#line 1075 \"./parse.y\"\n+#line 1079 \"./parse.y\"\n { \n \t\t  ctxp->interface_number++;\n \t\t  yyval.node = chainon (yyvsp[-2].node, build_tree_list (yyvsp[0].node, NULL_TREE));\n \t\t;\n     break;}\n case 168:\n-#line 1080 \"./parse.y\"\n+#line 1084 \"./parse.y\"\n {yyerror (\"Invalid interface type\"); RECOVER;;\n     break;}\n case 169:\n-#line 1082 \"./parse.y\"\n+#line 1086 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 170:\n-#line 1087 \"./parse.y\"\n+#line 1091 \"./parse.y\"\n { yyval.node = NULL_TREE; ;\n     break;}\n case 171:\n-#line 1089 \"./parse.y\"\n+#line 1093 \"./parse.y\"\n { yyval.node = NULL_TREE; ;\n     break;}\n case 176:\n-#line 1101 \"./parse.y\"\n+#line 1105 \"./parse.y\"\n { yyval.node = parse_jdk1_1_error (\"inner class declaration\"); ;\n     break;}\n case 177:\n-#line 1103 \"./parse.y\"\n+#line 1107 \"./parse.y\"\n { yyval.node = parse_jdk1_1_error (\"inner interface declaration\"); ;\n     break;}\n case 179:\n-#line 1112 \"./parse.y\"\n+#line 1116 \"./parse.y\"\n { \n \t\t  check_abstract_method_header (yyvsp[-1].node);\n \t\t  current_function_decl = NULL_TREE; /* FIXME ? */\n \t\t;\n     break;}\n case 180:\n-#line 1117 \"./parse.y\"\n+#line 1121 \"./parse.y\"\n {yyerror (\"';' expected\"); RECOVER;;\n     break;}\n case 181:\n-#line 1123 \"./parse.y\"\n+#line 1127 \"./parse.y\"\n { yyval.node = build_new_array_init (yyvsp[-1].operator.location, NULL_TREE); ;\n     break;}\n case 182:\n-#line 1125 \"./parse.y\"\n+#line 1129 \"./parse.y\"\n { yyval.node = build_new_array_init (yyvsp[-2].operator.location, yyvsp[-1].node); ;\n     break;}\n case 183:\n-#line 1127 \"./parse.y\"\n+#line 1131 \"./parse.y\"\n { yyval.node = build_new_array_init (yyvsp[-3].operator.location, yyvsp[-2].node); ;\n     break;}\n case 184:\n-#line 1132 \"./parse.y\"\n+#line 1136 \"./parse.y\"\n { \n \t\t  yyval.node = tree_cons (maybe_build_array_element_wfl (yyvsp[0].node), \n \t\t\t\t  yyvsp[0].node, NULL_TREE);\n \t\t;\n     break;}\n case 185:\n-#line 1137 \"./parse.y\"\n+#line 1141 \"./parse.y\"\n {\n \t\t  yyval.node = tree_cons (maybe_build_array_element_wfl (yyvsp[0].node), yyvsp[0].node, yyvsp[-2].node);\n \t\t;\n     break;}\n case 186:\n-#line 1141 \"./parse.y\"\n+#line 1145 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 187:\n-#line 1147 \"./parse.y\"\n+#line 1151 \"./parse.y\"\n { yyval.node = empty_stmt_node; ;\n     break;}\n case 188:\n-#line 1149 \"./parse.y\"\n+#line 1153 \"./parse.y\"\n { yyval.node = yyvsp[0].node; ;\n     break;}\n case 189:\n-#line 1154 \"./parse.y\"\n+#line 1158 \"./parse.y\"\n { enter_block (); ;\n     break;}\n case 190:\n-#line 1159 \"./parse.y\"\n+#line 1163 \"./parse.y\"\n { \n \t\t  maybe_absorb_scoping_blocks ();\n \t\t  yyval.node = exit_block ();\n \t\t;\n     break;}\n case 194:\n-#line 1173 \"./parse.y\"\n+#line 1177 \"./parse.y\"\n { java_method_add_stmt (current_function_decl, yyvsp[0].node); ;\n     break;}\n case 195:\n-#line 1175 \"./parse.y\"\n+#line 1179 \"./parse.y\"\n { parse_jdk1_1_error (\"inner class declaration\"); ;\n     break;}\n case 197:\n-#line 1184 \"./parse.y\"\n+#line 1188 \"./parse.y\"\n { declare_local_variables (0, yyvsp[-1].node, yyvsp[0].node); ;\n     break;}\n case 198:\n-#line 1186 \"./parse.y\"\n+#line 1190 \"./parse.y\"\n { declare_local_variables (yyvsp[-2].value, yyvsp[-1].node, yyvsp[0].node); ;\n     break;}\n case 204:\n-#line 1196 \"./parse.y\"\n+#line 1200 \"./parse.y\"\n { \n \t\t  /* If the for loop is unlabeled, we must return the\n \t\t     block it was defined it. It our last chance to\n@@ -3483,11 +3490,11 @@ case 204:\n \t\t;\n     break;}\n case 221:\n-#line 1229 \"./parse.y\"\n+#line 1233 \"./parse.y\"\n { yyval.node = empty_stmt_node; ;\n     break;}\n case 222:\n-#line 1234 \"./parse.y\"\n+#line 1238 \"./parse.y\"\n {\n \t\t  yyval.node = build_labeled_block (EXPR_WFL_LINECOL (yyvsp[-1].node), \n \t\t\t\t\t    EXPR_WFL_NODE (yyvsp[-1].node));\n@@ -3497,19 +3504,19 @@ case 222:\n \t\t;\n     break;}\n case 223:\n-#line 1245 \"./parse.y\"\n+#line 1249 \"./parse.y\"\n { yyval.node = finish_labeled_statement (yyvsp[-1].node, yyvsp[0].node); ;\n     break;}\n case 224:\n-#line 1247 \"./parse.y\"\n+#line 1251 \"./parse.y\"\n {yyerror (\"':' expected\"); RECOVER;;\n     break;}\n case 225:\n-#line 1252 \"./parse.y\"\n+#line 1256 \"./parse.y\"\n { yyval.node = finish_labeled_statement (yyvsp[-1].node, yyvsp[0].node); ;\n     break;}\n case 226:\n-#line 1259 \"./parse.y\"\n+#line 1263 \"./parse.y\"\n {\n \t\t  /* We have a statement. Generate a WFL around it so\n \t\t     we can debug it */\n@@ -3520,108 +3527,108 @@ case 226:\n \t\t;\n     break;}\n case 227:\n-#line 1268 \"./parse.y\"\n+#line 1272 \"./parse.y\"\n {\n \t\t  if (ctxp->prevent_ese != lineno)\n \t\t    yyerror (\"Invalid expression statement\");\n \t\t  DRECOVER (expr_stmt);\n \t\t;\n     break;}\n case 228:\n-#line 1274 \"./parse.y\"\n+#line 1278 \"./parse.y\"\n {\n \t\t  if (ctxp->prevent_ese != lineno)\n \t\t    yyerror (\"Invalid expression statement\");\n \t\t  DRECOVER (expr_stmt);\n \t\t;\n     break;}\n case 229:\n-#line 1280 \"./parse.y\"\n+#line 1284 \"./parse.y\"\n {\n \t\t  if (ctxp->prevent_ese != lineno)\n \t\t    yyerror (\"Invalid expression statement\");\n \t\t  DRECOVER (expr_stmt);\n \t\t;\n     break;}\n case 230:\n-#line 1286 \"./parse.y\"\n+#line 1290 \"./parse.y\"\n {yyerror (\"')' expected\"); RECOVER;;\n     break;}\n case 231:\n-#line 1288 \"./parse.y\"\n+#line 1292 \"./parse.y\"\n {\n \t\t  yyerror (\"Constructor invocation must be first \"\n \t\t\t   \"thing in a constructor\"); \n \t\t  RECOVER;\n \t\t;\n     break;}\n case 232:\n-#line 1294 \"./parse.y\"\n+#line 1298 \"./parse.y\"\n {yyerror (\"')' expected\"); RECOVER;;\n     break;}\n case 233:\n-#line 1296 \"./parse.y\"\n+#line 1300 \"./parse.y\"\n {\n \t\t  yyerror (\"Constructor invocation must be first \"\n \t\t\t   \"thing in a constructor\"); \n \t\t  RECOVER;\n \t\t;\n     break;}\n case 234:\n-#line 1302 \"./parse.y\"\n+#line 1306 \"./parse.y\"\n {yyerror (\"'(' expected\"); RECOVER;;\n     break;}\n case 235:\n-#line 1304 \"./parse.y\"\n+#line 1308 \"./parse.y\"\n {yyerror (\"')' expected\"); RECOVER;;\n     break;}\n case 236:\n-#line 1306 \"./parse.y\"\n+#line 1310 \"./parse.y\"\n {yyerror (\"')' expected\"); RECOVER;;\n     break;}\n case 237:\n-#line 1308 \"./parse.y\"\n+#line 1312 \"./parse.y\"\n {yyerror (\"';' expected\"); RECOVER;;\n     break;}\n case 238:\n-#line 1310 \"./parse.y\"\n+#line 1314 \"./parse.y\"\n {yyerror (\"';' expected\"); RECOVER;;\n     break;}\n case 246:\n-#line 1325 \"./parse.y\"\n+#line 1329 \"./parse.y\"\n { \n \t\t  yyval.node = build_if_else_statement (yyvsp[-3].operator.location, yyvsp[-2].node, \n \t\t\t\t\t\tyyvsp[0].node, NULL_TREE);\n \t\t;\n     break;}\n case 247:\n-#line 1330 \"./parse.y\"\n+#line 1334 \"./parse.y\"\n {yyerror (\"'(' expected\"); RECOVER;;\n     break;}\n case 248:\n-#line 1332 \"./parse.y\"\n+#line 1336 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 249:\n-#line 1334 \"./parse.y\"\n+#line 1338 \"./parse.y\"\n {yyerror (\"')' expected\"); RECOVER;;\n     break;}\n case 250:\n-#line 1339 \"./parse.y\"\n+#line 1343 \"./parse.y\"\n { yyval.node = build_if_else_statement (yyvsp[-5].operator.location, yyvsp[-4].node, yyvsp[-2].node, yyvsp[0].node); ;\n     break;}\n case 251:\n-#line 1344 \"./parse.y\"\n+#line 1348 \"./parse.y\"\n { yyval.node = build_if_else_statement (yyvsp[-5].operator.location, yyvsp[-4].node, yyvsp[-2].node, yyvsp[0].node); ;\n     break;}\n case 252:\n-#line 1349 \"./parse.y\"\n+#line 1353 \"./parse.y\"\n {\n \t\t  enter_block ();\n \t\t;\n     break;}\n case 253:\n-#line 1353 \"./parse.y\"\n+#line 1357 \"./parse.y\"\n { \n \t\t  /* Make into \"proper list\" of COMPOUND_EXPRs.\n \t\t     I.e. make the last statment also have its own\n@@ -3632,112 +3639,112 @@ case 253:\n \t\t;\n     break;}\n case 254:\n-#line 1365 \"./parse.y\"\n+#line 1369 \"./parse.y\"\n { \n \t\t  yyval.node = build (SWITCH_EXPR, NULL_TREE, yyvsp[-1].node, NULL_TREE);\n \t\t  EXPR_WFL_LINECOL (yyval.node) = yyvsp[-2].operator.location;\n \t\t;\n     break;}\n case 255:\n-#line 1370 \"./parse.y\"\n+#line 1374 \"./parse.y\"\n {yyerror (\"'(' expected\"); RECOVER;;\n     break;}\n case 256:\n-#line 1372 \"./parse.y\"\n+#line 1376 \"./parse.y\"\n {yyerror (\"Missing term or ')'\"); DRECOVER(switch_statement);;\n     break;}\n case 257:\n-#line 1374 \"./parse.y\"\n+#line 1378 \"./parse.y\"\n {yyerror (\"'{' expected\"); RECOVER;;\n     break;}\n case 258:\n-#line 1382 \"./parse.y\"\n+#line 1386 \"./parse.y\"\n { yyval.node = NULL_TREE; ;\n     break;}\n case 259:\n-#line 1384 \"./parse.y\"\n+#line 1388 \"./parse.y\"\n { yyval.node = NULL_TREE; ;\n     break;}\n case 260:\n-#line 1386 \"./parse.y\"\n+#line 1390 \"./parse.y\"\n { yyval.node = NULL_TREE; ;\n     break;}\n case 261:\n-#line 1388 \"./parse.y\"\n+#line 1392 \"./parse.y\"\n { yyval.node = NULL_TREE; ;\n     break;}\n case 267:\n-#line 1407 \"./parse.y\"\n+#line 1411 \"./parse.y\"\n { \n \t\t  tree lab = build1 (CASE_EXPR, NULL_TREE, yyvsp[-1].node);\n \t\t  EXPR_WFL_LINECOL (lab) = yyvsp[-2].operator.location;\n \t\t  java_method_add_stmt (current_function_decl, lab);\n \t\t;\n     break;}\n case 268:\n-#line 1413 \"./parse.y\"\n+#line 1417 \"./parse.y\"\n { \n \t\t  tree lab = build1 (DEFAULT_EXPR, NULL_TREE, NULL_TREE);\n \t\t  EXPR_WFL_LINECOL (lab) = yyvsp[-1].operator.location;\n \t\t  java_method_add_stmt (current_function_decl, lab);\n \t\t;\n     break;}\n case 269:\n-#line 1419 \"./parse.y\"\n+#line 1423 \"./parse.y\"\n {yyerror (\"Missing or invalid constant expression\"); RECOVER;;\n     break;}\n case 270:\n-#line 1421 \"./parse.y\"\n+#line 1425 \"./parse.y\"\n {yyerror (\"':' expected\"); RECOVER;;\n     break;}\n case 271:\n-#line 1423 \"./parse.y\"\n+#line 1427 \"./parse.y\"\n {yyerror (\"':' expected\"); RECOVER;;\n     break;}\n case 272:\n-#line 1428 \"./parse.y\"\n+#line 1432 \"./parse.y\"\n { \n \t\t  tree body = build_loop_body (yyvsp[-2].operator.location, yyvsp[-1].node, 0);\n \t\t  yyval.node = build_new_loop (body);\n \t\t;\n     break;}\n case 273:\n-#line 1436 \"./parse.y\"\n+#line 1440 \"./parse.y\"\n { yyval.node = finish_loop_body (0, NULL_TREE, yyvsp[0].node, 0); ;\n     break;}\n case 274:\n-#line 1438 \"./parse.y\"\n+#line 1442 \"./parse.y\"\n {YYERROR_NOW; yyerror (\"'(' expected\"); RECOVER;;\n     break;}\n case 275:\n-#line 1440 \"./parse.y\"\n+#line 1444 \"./parse.y\"\n {yyerror (\"Missing term and ')' expected\"); RECOVER;;\n     break;}\n case 276:\n-#line 1442 \"./parse.y\"\n+#line 1446 \"./parse.y\"\n {yyerror (\"')' expected\"); RECOVER;;\n     break;}\n case 277:\n-#line 1447 \"./parse.y\"\n+#line 1451 \"./parse.y\"\n { yyval.node = finish_loop_body (0, NULL_TREE, yyvsp[0].node, 0); ;\n     break;}\n case 278:\n-#line 1452 \"./parse.y\"\n+#line 1456 \"./parse.y\"\n { \n \t\t  tree body = build_loop_body (0, NULL_TREE, 1);\n \t\t  yyval.node = build_new_loop (body);\n \t\t;\n     break;}\n case 279:\n-#line 1461 \"./parse.y\"\n+#line 1465 \"./parse.y\"\n { yyval.node = finish_loop_body (yyvsp[-3].operator.location, yyvsp[-2].node, yyvsp[-5].node, 1); ;\n     break;}\n case 280:\n-#line 1466 \"./parse.y\"\n+#line 1470 \"./parse.y\"\n { yyval.node = finish_for_loop (EXPR_WFL_LINECOL (yyvsp[-4].node), yyvsp[-4].node, yyvsp[-2].node, yyvsp[0].node); ;\n     break;}\n case 281:\n-#line 1468 \"./parse.y\"\n+#line 1472 \"./parse.y\"\n { \n \t\t  yyval.node = finish_for_loop (0, NULL_TREE, yyvsp[-2].node, yyvsp[0].node);\n \t\t  /* We have not condition, so we get rid of the EXIT_EXPR */\n@@ -3746,23 +3753,23 @@ case 281:\n \t\t;\n     break;}\n case 282:\n-#line 1475 \"./parse.y\"\n+#line 1479 \"./parse.y\"\n {yyerror (\"Invalid control expression\"); RECOVER;;\n     break;}\n case 283:\n-#line 1477 \"./parse.y\"\n+#line 1481 \"./parse.y\"\n {yyerror (\"Invalid update expression\"); RECOVER;;\n     break;}\n case 284:\n-#line 1479 \"./parse.y\"\n+#line 1483 \"./parse.y\"\n {yyerror (\"Invalid update expression\"); RECOVER;;\n     break;}\n case 285:\n-#line 1484 \"./parse.y\"\n+#line 1488 \"./parse.y\"\n { yyval.node = finish_for_loop (EXPR_WFL_LINECOL (yyvsp[-4].node), yyvsp[-4].node, yyvsp[-2].node, yyvsp[0].node);;\n     break;}\n case 286:\n-#line 1486 \"./parse.y\"\n+#line 1490 \"./parse.y\"\n { \n \t\t  yyval.node = finish_for_loop (0, NULL_TREE, yyvsp[-2].node, yyvsp[0].node);\n \t\t  /* We have not condition, so we get rid of the EXIT_EXPR */\n@@ -3771,23 +3778,23 @@ case 286:\n \t\t;\n     break;}\n case 287:\n-#line 1496 \"./parse.y\"\n+#line 1500 \"./parse.y\"\n { \n \t\t  /* This scope defined for local variable that may be\n                      defined within the scope of the for loop */\n \t\t  enter_block (); \n \t\t;\n     break;}\n case 288:\n-#line 1502 \"./parse.y\"\n+#line 1506 \"./parse.y\"\n {yyerror (\"'(' expected\"); DRECOVER(for_1);;\n     break;}\n case 289:\n-#line 1504 \"./parse.y\"\n+#line 1508 \"./parse.y\"\n {yyerror (\"Invalid init statement\"); RECOVER;;\n     break;}\n case 290:\n-#line 1509 \"./parse.y\"\n+#line 1513 \"./parse.y\"\n { \n \t\t  /* We now declare the loop body. The loop is\n                      declared as a for loop. */\n@@ -3800,179 +3807,179 @@ case 290:\n \t\t;\n     break;}\n case 291:\n-#line 1521 \"./parse.y\"\n+#line 1525 \"./parse.y\"\n { yyval.node = empty_stmt_node; ;\n     break;}\n case 292:\n-#line 1523 \"./parse.y\"\n+#line 1527 \"./parse.y\"\n { \n \t\t  /* Init statement recorded within the previously\n                      defined block scope */\n \t\t  yyval.node = java_method_add_stmt (current_function_decl, yyvsp[0].node);\n \t\t;\n     break;}\n case 293:\n-#line 1529 \"./parse.y\"\n+#line 1533 \"./parse.y\"\n { \n \t\t  /* Local variable are recorded within the previously\n \t\t     defined block scope */\n \t\t  yyval.node = NULL_TREE;\n \t\t;\n     break;}\n case 294:\n-#line 1535 \"./parse.y\"\n+#line 1539 \"./parse.y\"\n {yyerror (\"';' expected\"); DRECOVER(for_init_1);;\n     break;}\n case 295:\n-#line 1539 \"./parse.y\"\n+#line 1543 \"./parse.y\"\n {yyval.node = empty_stmt_node;;\n     break;}\n case 296:\n-#line 1541 \"./parse.y\"\n+#line 1545 \"./parse.y\"\n { yyval.node = build_debugable_stmt (BUILD_LOCATION (), yyvsp[0].node); ;\n     break;}\n case 297:\n-#line 1546 \"./parse.y\"\n+#line 1550 \"./parse.y\"\n { yyval.node = add_stmt_to_compound (NULL_TREE, NULL_TREE, yyvsp[0].node); ;\n     break;}\n case 298:\n-#line 1548 \"./parse.y\"\n+#line 1552 \"./parse.y\"\n { yyval.node = add_stmt_to_compound (yyvsp[-2].node, NULL_TREE, yyvsp[0].node); ;\n     break;}\n case 299:\n-#line 1550 \"./parse.y\"\n+#line 1554 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 300:\n-#line 1555 \"./parse.y\"\n+#line 1559 \"./parse.y\"\n { yyval.node = build_bc_statement (yyvsp[-1].operator.location, 1, NULL_TREE); ;\n     break;}\n case 301:\n-#line 1557 \"./parse.y\"\n+#line 1561 \"./parse.y\"\n { yyval.node = build_bc_statement (yyvsp[-2].operator.location, 1, yyvsp[-1].node); ;\n     break;}\n case 302:\n-#line 1559 \"./parse.y\"\n+#line 1563 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 303:\n-#line 1561 \"./parse.y\"\n+#line 1565 \"./parse.y\"\n {yyerror (\"';' expected\"); RECOVER;;\n     break;}\n case 304:\n-#line 1566 \"./parse.y\"\n+#line 1570 \"./parse.y\"\n { yyval.node = build_bc_statement (yyvsp[-1].operator.location, 0, NULL_TREE); ;\n     break;}\n case 305:\n-#line 1568 \"./parse.y\"\n+#line 1572 \"./parse.y\"\n { yyval.node = build_bc_statement (yyvsp[-2].operator.location, 0, yyvsp[-1].node); ;\n     break;}\n case 306:\n-#line 1570 \"./parse.y\"\n+#line 1574 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 307:\n-#line 1572 \"./parse.y\"\n+#line 1576 \"./parse.y\"\n {yyerror (\"';' expected\"); RECOVER;;\n     break;}\n case 308:\n-#line 1577 \"./parse.y\"\n+#line 1581 \"./parse.y\"\n { yyval.node = build_return (yyvsp[-1].operator.location, NULL_TREE); ;\n     break;}\n case 309:\n-#line 1579 \"./parse.y\"\n+#line 1583 \"./parse.y\"\n { yyval.node = build_return (yyvsp[-2].operator.location, yyvsp[-1].node); ;\n     break;}\n case 310:\n-#line 1581 \"./parse.y\"\n+#line 1585 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 311:\n-#line 1583 \"./parse.y\"\n+#line 1587 \"./parse.y\"\n {yyerror (\"';' expected\"); RECOVER;;\n     break;}\n case 312:\n-#line 1588 \"./parse.y\"\n+#line 1592 \"./parse.y\"\n { \n \t\t  yyval.node = build1 (THROW_EXPR, NULL_TREE, yyvsp[-1].node);\n \t\t  EXPR_WFL_LINECOL (yyval.node) = yyvsp[-2].operator.location;\n \t\t;\n     break;}\n case 313:\n-#line 1593 \"./parse.y\"\n+#line 1597 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 314:\n-#line 1595 \"./parse.y\"\n+#line 1599 \"./parse.y\"\n {yyerror (\"';' expected\"); RECOVER;;\n     break;}\n case 315:\n-#line 1600 \"./parse.y\"\n+#line 1604 \"./parse.y\"\n { \n \t\t  yyval.node = build (SYNCHRONIZED_EXPR, NULL_TREE, yyvsp[-2].node, yyvsp[0].node);\n \t\t  EXPR_WFL_LINECOL (yyval.node) = \n \t\t    EXPR_WFL_LINECOL (MODIFIER_WFL (SYNCHRONIZED_TK));\n \t\t;\n     break;}\n case 316:\n-#line 1606 \"./parse.y\"\n+#line 1610 \"./parse.y\"\n {yyerror (\"'{' expected\"); RECOVER;;\n     break;}\n case 317:\n-#line 1608 \"./parse.y\"\n+#line 1612 \"./parse.y\"\n {yyerror (\"'(' expected\"); RECOVER;;\n     break;}\n case 318:\n-#line 1610 \"./parse.y\"\n+#line 1614 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 319:\n-#line 1612 \"./parse.y\"\n+#line 1616 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 320:\n-#line 1617 \"./parse.y\"\n+#line 1621 \"./parse.y\"\n {\n \t\t  if ((1 << yyvsp[0].value) != ACC_SYNCHRONIZED)\n \t\t    fatal (\"synchronized was '%d' - yyparse\", (1 << yyvsp[0].value));\n \t\t;\n     break;}\n case 321:\n-#line 1625 \"./parse.y\"\n+#line 1629 \"./parse.y\"\n { yyval.node = build_try_statement (yyvsp[-2].operator.location, yyvsp[-1].node, yyvsp[0].node); ;\n     break;}\n case 322:\n-#line 1627 \"./parse.y\"\n+#line 1631 \"./parse.y\"\n { yyval.node = build_try_finally_statement (yyvsp[-2].operator.location, yyvsp[-1].node, yyvsp[0].node); ;\n     break;}\n case 323:\n-#line 1629 \"./parse.y\"\n+#line 1633 \"./parse.y\"\n { yyval.node = build_try_finally_statement \n \t\t    (yyvsp[-3].operator.location, build_try_statement (yyvsp[-3].operator.location,\n \t\t\t\t\t\t       yyvsp[-2].node, yyvsp[-1].node), yyvsp[0].node);\n \t\t;\n     break;}\n case 324:\n-#line 1634 \"./parse.y\"\n+#line 1638 \"./parse.y\"\n {yyerror (\"'{' expected\"); DRECOVER (try_statement);;\n     break;}\n case 326:\n-#line 1640 \"./parse.y\"\n+#line 1644 \"./parse.y\"\n { \n \t\t  TREE_CHAIN (yyvsp[0].node) = yyvsp[-1].node;\n \t\t  yyval.node = yyvsp[0].node;\n \t\t;\n     break;}\n case 327:\n-#line 1648 \"./parse.y\"\n+#line 1652 \"./parse.y\"\n { \n \t\t  java_method_add_stmt (current_function_decl, yyvsp[0].node);\n \t\t  exit_block ();\n \t\t  yyval.node = yyvsp[-1].node;\n \t\t;\n     break;}\n case 328:\n-#line 1656 \"./parse.y\"\n+#line 1660 \"./parse.y\"\n { \n \t\t  /* We add a block to define a scope for\n \t\t     formal_parameter (CCBP). The formal parameter is\n@@ -3990,184 +3997,184 @@ case 328:\n \t\t;\n     break;}\n case 329:\n-#line 1672 \"./parse.y\"\n+#line 1676 \"./parse.y\"\n {yyerror (\"'(' expected\"); RECOVER;;\n     break;}\n case 330:\n-#line 1674 \"./parse.y\"\n+#line 1678 \"./parse.y\"\n {yyerror (\"Missing term or ')' expected\"); DRECOVER (2);;\n     break;}\n case 331:\n-#line 1676 \"./parse.y\"\n+#line 1680 \"./parse.y\"\n {yyerror (\"')' expected\"); DRECOVER (1);;\n     break;}\n case 332:\n-#line 1681 \"./parse.y\"\n+#line 1685 \"./parse.y\"\n { yyval.node = yyvsp[0].node; ;\n     break;}\n case 333:\n-#line 1683 \"./parse.y\"\n+#line 1687 \"./parse.y\"\n {yyerror (\"'{' expected\"); RECOVER; ;\n     break;}\n case 337:\n-#line 1695 \"./parse.y\"\n+#line 1699 \"./parse.y\"\n { yyval.node = build_this (yyvsp[0].operator.location); ;\n     break;}\n case 338:\n-#line 1697 \"./parse.y\"\n+#line 1701 \"./parse.y\"\n {yyval.node = yyvsp[-1].node;;\n     break;}\n case 343:\n-#line 1706 \"./parse.y\"\n+#line 1710 \"./parse.y\"\n { yyval.node = parse_jdk1_1_error (\"named class literals\"); ;\n     break;}\n case 344:\n-#line 1708 \"./parse.y\"\n+#line 1712 \"./parse.y\"\n { yyval.node = build_class_ref (yyvsp[-2].node); ;\n     break;}\n case 345:\n-#line 1710 \"./parse.y\"\n+#line 1714 \"./parse.y\"\n { yyval.node = build_class_ref (void_type_node); ;\n     break;}\n case 346:\n-#line 1715 \"./parse.y\"\n+#line 1719 \"./parse.y\"\n { yyval.node = parse_jdk1_1_error (\"class literals\"); ;\n     break;}\n case 347:\n-#line 1717 \"./parse.y\"\n+#line 1721 \"./parse.y\"\n {yyerror (\"')' expected\"); RECOVER;;\n     break;}\n case 348:\n-#line 1719 \"./parse.y\"\n+#line 1723 \"./parse.y\"\n {yyerror (\"'class' or 'this' expected\" ); RECOVER;;\n     break;}\n case 349:\n-#line 1721 \"./parse.y\"\n+#line 1725 \"./parse.y\"\n {yyerror (\"'class' expected\" ); RECOVER;;\n     break;}\n case 350:\n-#line 1723 \"./parse.y\"\n+#line 1727 \"./parse.y\"\n {yyerror (\"'class' expected\" ); RECOVER;;\n     break;}\n case 351:\n-#line 1728 \"./parse.y\"\n+#line 1732 \"./parse.y\"\n { yyval.node = build_new_invocation (yyvsp[-3].node, yyvsp[-1].node); ;\n     break;}\n case 352:\n-#line 1730 \"./parse.y\"\n+#line 1734 \"./parse.y\"\n { yyval.node = build_new_invocation (yyvsp[-2].node, NULL_TREE); ;\n     break;}\n case 353:\n-#line 1735 \"./parse.y\"\n+#line 1739 \"./parse.y\"\n { yyval.node = parse_jdk1_1_error (\"inner class instance creation\"); ;\n     break;}\n case 354:\n-#line 1737 \"./parse.y\"\n+#line 1741 \"./parse.y\"\n { yyval.node = parse_jdk1_1_error (\"inner class instance creation\"); ;\n     break;}\n case 359:\n-#line 1746 \"./parse.y\"\n+#line 1750 \"./parse.y\"\n {yyerror (\"'(' expected\"); DRECOVER(new_1);;\n     break;}\n case 360:\n-#line 1748 \"./parse.y\"\n+#line 1752 \"./parse.y\"\n {yyerror (\"'(' expected\"); RECOVER;;\n     break;}\n case 361:\n-#line 1750 \"./parse.y\"\n+#line 1754 \"./parse.y\"\n {yyerror (\"')' or term expected\"); RECOVER;;\n     break;}\n case 362:\n-#line 1752 \"./parse.y\"\n+#line 1756 \"./parse.y\"\n {yyerror (\"')' expected\"); RECOVER;;\n     break;}\n case 363:\n-#line 1754 \"./parse.y\"\n+#line 1758 \"./parse.y\"\n {YYERROR_NOW; yyerror (\"Identifier expected\"); RECOVER;;\n     break;}\n case 364:\n-#line 1756 \"./parse.y\"\n+#line 1760 \"./parse.y\"\n {yyerror (\"'(' expected\"); RECOVER;;\n     break;}\n case 367:\n-#line 1766 \"./parse.y\"\n+#line 1770 \"./parse.y\"\n { \n \t\t  yyval.node = tree_cons (NULL_TREE, yyvsp[0].node, NULL_TREE);\n \t\t  ctxp->formal_parameter_number = 1; \n \t\t;\n     break;}\n case 368:\n-#line 1771 \"./parse.y\"\n+#line 1775 \"./parse.y\"\n {\n \t\t  ctxp->formal_parameter_number += 1;\n \t\t  yyval.node = tree_cons (NULL_TREE, yyvsp[0].node, yyvsp[-2].node);\n \t\t;\n     break;}\n case 369:\n-#line 1776 \"./parse.y\"\n+#line 1780 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 370:\n-#line 1781 \"./parse.y\"\n+#line 1785 \"./parse.y\"\n { yyval.node = build_newarray_node (yyvsp[-1].node, yyvsp[0].node, 0); ;\n     break;}\n case 371:\n-#line 1783 \"./parse.y\"\n+#line 1787 \"./parse.y\"\n { yyval.node = build_newarray_node (yyvsp[-1].node, yyvsp[0].node, 0); ;\n     break;}\n case 372:\n-#line 1785 \"./parse.y\"\n+#line 1789 \"./parse.y\"\n { yyval.node = build_newarray_node (yyvsp[-2].node, yyvsp[-1].node, CURRENT_OSB (ctxp));;\n     break;}\n case 373:\n-#line 1787 \"./parse.y\"\n+#line 1791 \"./parse.y\"\n { yyval.node = build_newarray_node (yyvsp[-2].node, yyvsp[-1].node, CURRENT_OSB (ctxp));;\n     break;}\n case 374:\n-#line 1791 \"./parse.y\"\n+#line 1795 \"./parse.y\"\n { yyval.node = parse_jdk1_1_error (\"anonymous array\"); ;\n     break;}\n case 375:\n-#line 1793 \"./parse.y\"\n+#line 1797 \"./parse.y\"\n { yyval.node = parse_jdk1_1_error (\"anonymous array\"); ;\n     break;}\n case 376:\n-#line 1795 \"./parse.y\"\n+#line 1799 \"./parse.y\"\n {yyerror (\"'[' expected\"); DRECOVER (\"]\");;\n     break;}\n case 377:\n-#line 1797 \"./parse.y\"\n+#line 1801 \"./parse.y\"\n {yyerror (\"']' expected\"); RECOVER;;\n     break;}\n case 378:\n-#line 1802 \"./parse.y\"\n+#line 1806 \"./parse.y\"\n { yyval.node = build_tree_list (NULL_TREE, yyvsp[0].node); ;\n     break;}\n case 379:\n-#line 1804 \"./parse.y\"\n+#line 1808 \"./parse.y\"\n { yyval.node = tree_cons (NULL_TREE, yyvsp[0].node, yyval.node); ;\n     break;}\n case 380:\n-#line 1809 \"./parse.y\"\n+#line 1813 \"./parse.y\"\n { \n \t\t  EXPR_WFL_LINECOL (yyvsp[-1].node) = yyvsp[-2].operator.location;\n \t\t  yyval.node = yyvsp[-1].node;\n \t\t;\n     break;}\n case 381:\n-#line 1814 \"./parse.y\"\n+#line 1818 \"./parse.y\"\n {yyerror (\"']' expected\"); RECOVER;;\n     break;}\n case 382:\n-#line 1816 \"./parse.y\"\n+#line 1820 \"./parse.y\"\n {\n \t\t  yyerror (\"Missing term\");\n \t\t  yyerror (\"']' expected\");\n \t\t  RECOVER;\n \t\t;\n     break;}\n case 383:\n-#line 1825 \"./parse.y\"\n+#line 1829 \"./parse.y\"\n { \n \t\t  int allocate = 0;\n \t\t  /* If not initialized, allocate memory for the osb\n@@ -4195,19 +4202,19 @@ case 383:\n \t\t;\n     break;}\n case 384:\n-#line 1851 \"./parse.y\"\n+#line 1855 \"./parse.y\"\n { CURRENT_OSB (ctxp)++; ;\n     break;}\n case 385:\n-#line 1853 \"./parse.y\"\n+#line 1857 \"./parse.y\"\n { yyerror (\"']' expected\"); RECOVER;;\n     break;}\n case 386:\n-#line 1858 \"./parse.y\"\n+#line 1862 \"./parse.y\"\n { yyval.node = make_qualified_primary (yyvsp[-2].node, yyvsp[0].node, yyvsp[-1].operator.location); ;\n     break;}\n case 387:\n-#line 1862 \"./parse.y\"\n+#line 1866 \"./parse.y\"\n {\n \t\t  tree super_wfl = \n \t\t    build_wfl_node (super_identifier_node);\n@@ -4216,19 +4223,19 @@ case 387:\n \t\t;\n     break;}\n case 388:\n-#line 1869 \"./parse.y\"\n+#line 1873 \"./parse.y\"\n {yyerror (\"Field expected\"); DRECOVER (super_field_acces);;\n     break;}\n case 389:\n-#line 1874 \"./parse.y\"\n+#line 1878 \"./parse.y\"\n { yyval.node = build_method_invocation (yyvsp[-2].node, NULL_TREE); ;\n     break;}\n case 390:\n-#line 1876 \"./parse.y\"\n+#line 1880 \"./parse.y\"\n { yyval.node = build_method_invocation (yyvsp[-3].node, yyvsp[-1].node); ;\n     break;}\n case 391:\n-#line 1878 \"./parse.y\"\n+#line 1882 \"./parse.y\"\n { \n \t\t  if (TREE_CODE (yyvsp[-4].node) == THIS_EXPR)\n \t\t    yyval.node = build_this_super_qualified_invocation \n@@ -4241,7 +4248,7 @@ case 391:\n \t\t;\n     break;}\n case 392:\n-#line 1889 \"./parse.y\"\n+#line 1893 \"./parse.y\"\n { \n \t\t  if (TREE_CODE (yyvsp[-5].node) == THIS_EXPR)\n \t\t    yyval.node = build_this_super_qualified_invocation \n@@ -4254,121 +4261,121 @@ case 392:\n \t\t;\n     break;}\n case 393:\n-#line 1900 \"./parse.y\"\n+#line 1904 \"./parse.y\"\n { \n \t\t  yyval.node = build_this_super_qualified_invocation \n \t\t    (0, yyvsp[-2].node, NULL_TREE, yyvsp[-4].operator.location, yyvsp[-3].operator.location);\n \t\t;\n     break;}\n case 394:\n-#line 1905 \"./parse.y\"\n+#line 1909 \"./parse.y\"\n {\n \t\t  yyval.node = build_this_super_qualified_invocation \n \t\t    (0, yyvsp[-3].node, yyvsp[-1].node, yyvsp[-5].operator.location, yyvsp[-4].operator.location);\n \t\t;\n     break;}\n case 395:\n-#line 1914 \"./parse.y\"\n+#line 1918 \"./parse.y\"\n { yyerror (\"'(' expected\"); DRECOVER (method_invocation); ;\n     break;}\n case 396:\n-#line 1916 \"./parse.y\"\n+#line 1920 \"./parse.y\"\n { yyerror (\"'(' expected\"); DRECOVER (method_invocation); ;\n     break;}\n case 397:\n-#line 1921 \"./parse.y\"\n+#line 1925 \"./parse.y\"\n { yyval.node = build_array_ref (yyvsp[-2].operator.location, yyvsp[-3].node, yyvsp[-1].node); ;\n     break;}\n case 398:\n-#line 1923 \"./parse.y\"\n+#line 1927 \"./parse.y\"\n { yyval.node = build_array_ref (yyvsp[-2].operator.location, yyvsp[-3].node, yyvsp[-1].node); ;\n     break;}\n case 399:\n-#line 1925 \"./parse.y\"\n+#line 1929 \"./parse.y\"\n {\n \t\t  yyerror (\"Missing term and ']' expected\");\n \t\t  DRECOVER(array_access);\n \t\t;\n     break;}\n case 400:\n-#line 1930 \"./parse.y\"\n+#line 1934 \"./parse.y\"\n {\n \t\t  yyerror (\"']' expected\");\n \t\t  DRECOVER(array_access);\n \t\t;\n     break;}\n case 401:\n-#line 1935 \"./parse.y\"\n+#line 1939 \"./parse.y\"\n {\n \t\t  yyerror (\"Missing term and ']' expected\");\n \t\t  DRECOVER(array_access);\n \t\t;\n     break;}\n case 402:\n-#line 1940 \"./parse.y\"\n+#line 1944 \"./parse.y\"\n {\n \t\t  yyerror (\"']' expected\");\n \t\t  DRECOVER(array_access);\n \t\t;\n     break;}\n case 407:\n-#line 1955 \"./parse.y\"\n+#line 1959 \"./parse.y\"\n { yyval.node = build_incdec (yyvsp[0].operator.token, yyvsp[0].operator.location, yyvsp[-1].node, 1); ;\n     break;}\n case 408:\n-#line 1960 \"./parse.y\"\n+#line 1964 \"./parse.y\"\n { yyval.node = build_incdec (yyvsp[0].operator.token, yyvsp[0].operator.location, yyvsp[-1].node, 1); ;\n     break;}\n case 411:\n-#line 1967 \"./parse.y\"\n+#line 1971 \"./parse.y\"\n {yyval.node = build_unaryop (yyvsp[-1].operator.token, yyvsp[-1].operator.location, yyvsp[0].node); ;\n     break;}\n case 412:\n-#line 1969 \"./parse.y\"\n+#line 1973 \"./parse.y\"\n {yyval.node = build_unaryop (yyvsp[-1].operator.token, yyvsp[-1].operator.location, yyvsp[0].node); ;\n     break;}\n case 414:\n-#line 1972 \"./parse.y\"\n+#line 1976 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;\n     break;}\n case 415:\n-#line 1974 \"./parse.y\"\n+#line 1978 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;\n     break;}\n case 416:\n-#line 1979 \"./parse.y\"\n+#line 1983 \"./parse.y\"\n {yyval.node = build_incdec (yyvsp[-1].operator.token, yyvsp[-1].operator.location, yyvsp[0].node, 0); ;\n     break;}\n case 417:\n-#line 1981 \"./parse.y\"\n+#line 1985 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;\n     break;}\n case 418:\n-#line 1986 \"./parse.y\"\n+#line 1990 \"./parse.y\"\n {yyval.node = build_incdec (yyvsp[-1].operator.token, yyvsp[-1].operator.location, yyvsp[0].node, 0); ;\n     break;}\n case 419:\n-#line 1988 \"./parse.y\"\n+#line 1992 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;\n     break;}\n case 421:\n-#line 1994 \"./parse.y\"\n+#line 1998 \"./parse.y\"\n {yyval.node = build_unaryop (yyvsp[-1].operator.token, yyvsp[-1].operator.location, yyvsp[0].node); ;\n     break;}\n case 422:\n-#line 1996 \"./parse.y\"\n+#line 2000 \"./parse.y\"\n {yyval.node = build_unaryop (yyvsp[-1].operator.token, yyvsp[-1].operator.location, yyvsp[0].node); ;\n     break;}\n case 424:\n-#line 1999 \"./parse.y\"\n+#line 2003 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;\n     break;}\n case 425:\n-#line 2001 \"./parse.y\"\n+#line 2005 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;\n     break;}\n case 426:\n-#line 2006 \"./parse.y\"\n+#line 2010 \"./parse.y\"\n { \n \t\t  tree type = yyvsp[-3].node;\n \t\t  while (CURRENT_OSB (ctxp)--)\n@@ -4378,15 +4385,15 @@ case 426:\n \t\t;\n     break;}\n case 427:\n-#line 2014 \"./parse.y\"\n+#line 2018 \"./parse.y\"\n { yyval.node = build_cast (yyvsp[-3].operator.location, yyvsp[-2].node, yyvsp[0].node); ;\n     break;}\n case 428:\n-#line 2016 \"./parse.y\"\n+#line 2020 \"./parse.y\"\n { yyval.node = build_cast (yyvsp[-3].operator.location, yyvsp[-2].node, yyvsp[0].node); ;\n     break;}\n case 429:\n-#line 2018 \"./parse.y\"\n+#line 2022 \"./parse.y\"\n { \n \t\t  char *ptr;\n \t\t  while (CURRENT_OSB (ctxp)--)\n@@ -4401,275 +4408,275 @@ case 429:\n \t\t;\n     break;}\n case 430:\n-#line 2031 \"./parse.y\"\n+#line 2035 \"./parse.y\"\n {yyerror (\"']' expected, invalid type expression\");;\n     break;}\n case 431:\n-#line 2033 \"./parse.y\"\n+#line 2037 \"./parse.y\"\n {\n \t          if (ctxp->prevent_ese != lineno)\n \t\t    yyerror (\"Invalid type expression\"); RECOVER;\n \t\t  RECOVER;\n \t\t;\n     break;}\n case 432:\n-#line 2039 \"./parse.y\"\n+#line 2043 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 433:\n-#line 2041 \"./parse.y\"\n+#line 2045 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 434:\n-#line 2043 \"./parse.y\"\n+#line 2047 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 436:\n-#line 2049 \"./parse.y\"\n+#line 2053 \"./parse.y\"\n { \n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), \n \t\t\t\t    yyvsp[-1].operator.location, yyvsp[-2].node, yyvsp[0].node);\n \t\t;\n     break;}\n case 437:\n-#line 2054 \"./parse.y\"\n+#line 2058 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 438:\n-#line 2059 \"./parse.y\"\n+#line 2063 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 439:\n-#line 2064 \"./parse.y\"\n+#line 2068 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 440:\n-#line 2066 \"./parse.y\"\n+#line 2070 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 441:\n-#line 2068 \"./parse.y\"\n+#line 2072 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 443:\n-#line 2074 \"./parse.y\"\n+#line 2078 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 444:\n-#line 2079 \"./parse.y\"\n+#line 2083 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 445:\n-#line 2084 \"./parse.y\"\n+#line 2088 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 446:\n-#line 2086 \"./parse.y\"\n+#line 2090 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 448:\n-#line 2092 \"./parse.y\"\n+#line 2096 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 449:\n-#line 2097 \"./parse.y\"\n+#line 2101 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 450:\n-#line 2102 \"./parse.y\"\n+#line 2106 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 451:\n-#line 2107 \"./parse.y\"\n+#line 2111 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 452:\n-#line 2109 \"./parse.y\"\n+#line 2113 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 453:\n-#line 2111 \"./parse.y\"\n+#line 2115 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 455:\n-#line 2117 \"./parse.y\"\n+#line 2121 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 456:\n-#line 2122 \"./parse.y\"\n+#line 2126 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 457:\n-#line 2127 \"./parse.y\"\n+#line 2131 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 458:\n-#line 2132 \"./parse.y\"\n+#line 2136 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 459:\n-#line 2137 \"./parse.y\"\n+#line 2141 \"./parse.y\"\n { yyval.node = build_binop (INSTANCEOF_EXPR, yyvsp[-1].operator.location, yyvsp[-2].node, yyvsp[0].node); ;\n     break;}\n case 460:\n-#line 2139 \"./parse.y\"\n+#line 2143 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 461:\n-#line 2141 \"./parse.y\"\n+#line 2145 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 462:\n-#line 2143 \"./parse.y\"\n+#line 2147 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 463:\n-#line 2145 \"./parse.y\"\n+#line 2149 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 464:\n-#line 2147 \"./parse.y\"\n+#line 2151 \"./parse.y\"\n {yyerror (\"Invalid reference type\"); RECOVER;;\n     break;}\n case 466:\n-#line 2153 \"./parse.y\"\n+#line 2157 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 467:\n-#line 2158 \"./parse.y\"\n+#line 2162 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 468:\n-#line 2163 \"./parse.y\"\n+#line 2167 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 469:\n-#line 2165 \"./parse.y\"\n+#line 2169 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 471:\n-#line 2171 \"./parse.y\"\n+#line 2175 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 472:\n-#line 2176 \"./parse.y\"\n+#line 2180 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 474:\n-#line 2182 \"./parse.y\"\n+#line 2186 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 475:\n-#line 2187 \"./parse.y\"\n+#line 2191 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 477:\n-#line 2193 \"./parse.y\"\n+#line 2197 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 478:\n-#line 2198 \"./parse.y\"\n+#line 2202 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 480:\n-#line 2204 \"./parse.y\"\n+#line 2208 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 481:\n-#line 2209 \"./parse.y\"\n+#line 2213 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 483:\n-#line 2215 \"./parse.y\"\n+#line 2219 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 484:\n-#line 2220 \"./parse.y\"\n+#line 2224 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 486:\n-#line 2226 \"./parse.y\"\n+#line 2230 \"./parse.y\"\n {\n \t\t  yyval.node = build (CONDITIONAL_EXPR, NULL_TREE, yyvsp[-4].node, yyvsp[-2].node, yyvsp[0].node);\n \t\t  EXPR_WFL_LINECOL (yyval.node) = yyvsp[-3].operator.location;\n \t\t;\n     break;}\n case 487:\n-#line 2231 \"./parse.y\"\n+#line 2235 \"./parse.y\"\n {\n \t\t  YYERROR_NOW;\n \t\t  yyerror (\"Missing term\");\n \t\t  DRECOVER (1);\n \t\t;\n     break;}\n case 488:\n-#line 2237 \"./parse.y\"\n+#line 2241 \"./parse.y\"\n {yyerror (\"Missing term\"); DRECOVER (2);;\n     break;}\n case 489:\n-#line 2239 \"./parse.y\"\n+#line 2243 \"./parse.y\"\n {yyerror (\"Missing term\"); DRECOVER (3);;\n     break;}\n case 492:\n-#line 2249 \"./parse.y\"\n+#line 2253 \"./parse.y\"\n { yyval.node = build_assignment (yyvsp[-1].operator.token, yyvsp[-1].operator.location, yyvsp[-2].node, yyvsp[0].node); ;\n     break;}\n case 493:\n-#line 2251 \"./parse.y\"\n+#line 2255 \"./parse.y\"\n {\n \t\t  if (ctxp->prevent_ese != lineno)\n \t\t    yyerror (\"Missing term\");\n@@ -4874,7 +4881,7 @@ case 493:\n   yystate = yyn;\n   goto yynewstate;\n }\n-#line 2277 \"./parse.y\"\n+#line 2281 \"./parse.y\"\n \n \f\n \n@@ -5832,10 +5839,19 @@ static void\n maybe_generate_clinit ()\n {\n   tree mdecl, c;\n+  int is_interface = CLASS_INTERFACE (ctxp->current_parsed_class);\n+  int has_non_primitive_fields = 0;\n \n   if (!ctxp->static_initialized || java_error_count)\n     return;\n \n+  if (is_interface)\n+    for (c = TYPE_FIELDS (TREE_TYPE (ctxp->current_parsed_class));\n+\t c; c = TREE_CHAIN (c))\n+      has_non_primitive_fields |= !JPRIMITIVE_TYPE_P (TREE_TYPE (c));\n+  if (!has_non_primitive_fields && is_interface)\n+    return;\n+\n   mdecl = create_artificial_method (TREE_TYPE (ctxp->current_parsed_class),\n \t\t\t\t    ACC_STATIC, void_type_node,\n \t\t\t\t    clinit_identifier_node, end_params_node);\n@@ -7005,8 +7021,7 @@ static int\n reset_method_name (method)\n      tree method;\n {\n-  if (DECL_NAME (method) != clinit_identifier_node\n-      && DECL_NAME (method) != finit_identifier_node)\n+  if (!IS_CLINIT (method) && DECL_NAME (method) != finit_identifier_node)\n     {\n       /* NAME is just the plain name when Object is being defined */\n       if (DECL_CONTEXT (method) != object_type_node)\n@@ -8263,51 +8278,55 @@ java_complete_expand_methods ()\n   \n   for (current = ctxp->class_list; current; current = TREE_CHAIN (current))\n     {\n+      int is_interface;\n       tree class_type = CLASS_TO_HANDLE_TYPE (TREE_TYPE (current));\n       tree decl;\n \n       current_class = TREE_TYPE (current);\n+      is_interface = CLASS_INTERFACE (TYPE_NAME (current_class));\n \n       /* Initialize a new constant pool */\n       init_outgoing_cpool ();\n \n       /* We want <clinit> (if any) to be processed first. */\n       decl = tree_last (TYPE_METHODS (class_type));\n-      if (decl && DECL_NAME (decl) == clinit_identifier_node)\n+      if (IS_CLINIT (decl))\n \t{\n \t  tree list = nreverse (TYPE_METHODS (class_type));\n \t  list = TREE_CHAIN (list);\n \t  TREE_CHAIN (decl) = NULL_TREE;\n \t  TYPE_METHODS (class_type) = chainon (decl, nreverse (list));\n \t}\n+      \n+      for (decl = TYPE_METHODS (class_type); decl; decl = TREE_CHAIN (decl))\n+\t{\n+\t  /* Process only <clinit> method bodies in interfaces. */\n+\t  if (is_interface && decl != TYPE_METHODS (class_type))\n+\t    break;\n \n-      /* Don't process function bodies in interfaces */\n-      if (!CLASS_INTERFACE (TYPE_NAME (current_class)))\n-\tfor (decl = TYPE_METHODS (class_type); decl; decl = TREE_CHAIN (decl))\n-\t  {\n-\t    current_function_decl = decl;\n-\t    /* Don't generate debug info on line zero when expanding a\n-\t       generated constructor. */\n-\t    if (DECL_CONSTRUCTOR_P (decl) && !DECL_FUNCTION_BODY (decl))\n-\t      {\n-\t\t/* If we found errors, it's too dangerous to try to generate\n-\t\t   and expand a constructor */\n-\t\tif (!java_error_count)\n-\t\t  {\n-\t\t    restore_line_number_status (1);\n-\t\t    java_complete_expand_method (decl);\n-\t\t    restore_line_number_status (0);\n+\t  current_function_decl = decl;\n+\t  /* Don't generate debug info on line zero when expanding a\n+\t     generated constructor. */\n+\t  if (DECL_CONSTRUCTOR_P (decl) && !DECL_FUNCTION_BODY (decl))\n+\t    {\n+\t      /* If we found errors, it's too dangerous to try to\n+\t\t generate and expand a constructor */\n+\t      if (!java_error_count)\n+\t\t{\n+\t\t  restore_line_number_status (1);\n+\t\t  java_complete_expand_method (decl);\n+\t\t  restore_line_number_status (0);\n \t\t  }\n-\t      }\n-\t    else if (METHOD_ABSTRACT (decl) || METHOD_NATIVE (decl))\n-\t      continue;\n-\t    else \n-\t      java_complete_expand_method (decl);\n-\t  }\n+\t    }\n+\t  else if (METHOD_ABSTRACT (decl) || METHOD_NATIVE (decl))\n+\t    continue;\n+\t  else \n+\t    java_complete_expand_method (decl);\n+\t}\n \n       /* Now verify constructor circularity (stop after the first one\n          we find) */\n-      if (!CLASS_INTERFACE (TYPE_NAME (current_class)))\n+      if (!is_interface)\n \tfor (decl = TYPE_METHODS (class_type); decl; decl = TREE_CHAIN (decl))\n \t  if (DECL_CONSTRUCTOR_P (decl) && \n \t      verify_constructor_circularity (decl, decl))\n@@ -8362,7 +8381,7 @@ java_complete_expand_method (mdecl)\n       if (block_body != NULL_TREE)\n \t{\n \t  /* Prevent the use of `this' inside <clinit> */\n-\t  if (DECL_NAME (current_function_decl) == clinit_identifier_node)\n+\t  if (IS_CLINIT (current_function_decl))\n \t    ctxp->explicit_constructor_p = 1;\n \n \t  block_body = java_complete_tree (block_body);\n@@ -8698,9 +8717,9 @@ resolve_expression_name (id, orig)\n \n \t      /* Otherwise build what it takes to access the field */\n \t      decl = build_field_ref ((fs ? NULL_TREE : current_this),\n-\t\t\t\t      current_class, name);\n+\t\t\t\t      DECL_CONTEXT (decl), name);\n \t      if (fs && !flag_emit_class_files && !flag_emit_xref)\n-\t\tdecl = build_class_init (current_class, decl);\n+\t\tdecl = build_class_init (DECL_CONTEXT (decl), decl);\n \t      /* We may be asked to save the real field access node */\n \t      if (orig)\n \t\t*orig = decl;\n@@ -10675,7 +10694,7 @@ java_complete_lhs (node)\n          assignment in <clinit>, we may want to carray further\n          optimizations. (VAR_DECL means it's a static field. See\n          add_field. */\n-      if (DECL_NAME (current_function_decl) == clinit_identifier_node\n+      if (IS_CLINIT (current_function_decl) \n \t  && MODIFY_EXPR_FROM_INITIALIZATION_P (node)\n \t  && TREE_CODE (TREE_OPERAND (node, 0)) == VAR_DECL)\n \tnode = patch_initialized_static_field (node);\n@@ -10760,14 +10779,14 @@ java_complete_lhs (node)\n       TREE_OPERAND (node, 0) = java_complete_tree (wfl_op1);\n       if (TREE_OPERAND (node, 0) == error_mark_node)\n \treturn error_mark_node;\n-      if (!flag_emit_class_files)\n+      if (!flag_emit_class_files && !flag_emit_xref)\n \tTREE_OPERAND (node, 0) = save_expr (TREE_OPERAND (node, 0));\n       /* The same applies to wfl_op2 */\n       wfl_op2 = TREE_OPERAND (node, 1);\n       TREE_OPERAND (node, 1) = java_complete_tree (wfl_op2);\n       if (TREE_OPERAND (node, 1) == error_mark_node)\n \treturn error_mark_node;\n-      if (!flag_emit_class_files)\n+      if (!flag_emit_class_files && !flag_emit_xref)\n \tTREE_OPERAND (node, 1) = save_expr (TREE_OPERAND (node, 1));\n       return patch_array_ref (node);\n \n@@ -11108,14 +11127,15 @@ print_int_node (node)\n   return buffer;\n }\n \n-/* Return 1 if you an assignment of a FINAL is attempted */\n+/* Return 1 if an assignment to a FINAL is attempted in a non suitable\n+   context.  */\n \n static int\n check_final_assignment (lvalue, wfl)\n      tree lvalue, wfl;\n {\n-  if (JDECL_P (lvalue) && FIELD_FINAL (lvalue) &&\n-      DECL_NAME (current_function_decl) != clinit_identifier_node)\n+  if (JDECL_P (lvalue) \n+      && FIELD_FINAL (lvalue) && !IS_CLINIT (current_function_decl))\n     {\n       parse_error_context \n         (wfl, \"Can't assign a value to the final variable `%s'\",\n@@ -12671,7 +12691,7 @@ patch_array_ref (node)\n \n   array_type = TYPE_ARRAY_ELEMENT (array_type);\n \n-  if (flag_emit_class_files)\n+  if (flag_emit_class_files || flag_emit_xref)\n     {\n       TREE_OPERAND (node, 0) = array;\n       TREE_OPERAND (node, 1) = index;\n@@ -12997,7 +13017,7 @@ patch_return (node)\n     error_found = 1;\n \n   /* It's invalid to use a return statement in a static block */\n-  if (DECL_NAME (current_function_decl) == clinit_identifier_node)\n+  if (IS_CLINIT (current_function_decl))\n     error_found = 1;\n \n   /* It's invalid to have a no return value within a function that\n@@ -13007,7 +13027,7 @@ patch_return (node)\n \n   if (error_found)\n     {\n-      if (DECL_NAME (current_function_decl) == clinit_identifier_node)\n+      if (IS_CLINIT (current_function_decl))\n \tparse_error_context (wfl_operator,\n \t\t\t     \"`return' inside static initializer.\");\n \n@@ -13735,7 +13755,7 @@ patch_throw_statement (node, wfl_op1)\n       else if (!EXCEPTIONS_P (currently_caught_type_list) \n \t       && !tryblock_throws_ok)\n \t{\n-\t  if (DECL_NAME (current_function_decl) == clinit_identifier_node)\n+\t  if (IS_CLINIT (current_function_decl))\n \t    parse_error_context (wfl_operator, \"Checked exception `%s' can't \"\n \t\t\t\t \"be thrown in initializer\",\n \t\t\t\t lang_printable_name (type, 0));"}, {"sha": "08a96b4fbdce778f6c22ab0f9857cc6cf1d29b0f", "filename": "gcc/java/parse.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f1d48663e8aa1d749c88ffd17365bf2aa80f21a/gcc%2Fjava%2Fparse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f1d48663e8aa1d749c88ffd17365bf2aa80f21a/gcc%2Fjava%2Fparse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.h?ref=7f1d48663e8aa1d749c88ffd17365bf2aa80f21a", "patch": "@@ -177,9 +177,6 @@ extern tree stabilize_reference PROTO ((tree));\n \t\t\t\t  && (JNUMERIC_TYPE_P ((TYPE))\t\t  \\\n \t\t\t\t  || TREE_CODE ((TYPE)) == BOOLEAN_TYPE))\n \n-#define JPRIMITIVE_TYPE_OR_VOID_P(TYPE) \\\n-  (JPRIMITIVE_TYPE_P (TYPE) || ((TYPE) == void_type_node))\n-\n #define JBSC_TYPE_P(TYPE) ((TYPE) && (((TYPE) == byte_type_node)\t\\\n \t\t\t\t      || ((TYPE) == short_type_node)\t\\\n \t\t\t\t      || ((TYPE) == char_type_node)))\n@@ -583,6 +580,10 @@ typedef struct _jdeplist {\n   ctxp->import_list = node;\t\t\t\t\\\n }\n \n+/* Safe check that DECL is <clinit> */\n+#define IS_CLINIT(DECL)\t\t\t\t\\\n+  (DECL != NULL_TREE && DECL_NAME (DECL) == clinit_identifier_node)\n+\n /* Macro to access the osb (opening square bracket) count */\n #define CURRENT_OSB(C) (C)->osb_number [(C)->osb_depth]\n      "}, {"sha": "f8c21c7e2bf1429dc0034933574c4402e21b64ff", "filename": "gcc/java/parse.y", "status": "modified", "additions": 56, "deletions": 39, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f1d48663e8aa1d749c88ffd17365bf2aa80f21a/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f1d48663e8aa1d749c88ffd17365bf2aa80f21a/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=7f1d48663e8aa1d749c88ffd17365bf2aa80f21a", "patch": "@@ -632,6 +632,10 @@ type_declaration:\n \t\t  $$ = $1;\n \t\t}\n |\tinterface_declaration\n+\t\t{\n+\t\t  maybe_generate_clinit ();\n+\t\t  $$ = $1;\n+\t\t}\n |\tSC_TK\n \t\t{ $$ = NULL; }\n |\terror\n@@ -3231,10 +3235,19 @@ static void\n maybe_generate_clinit ()\n {\n   tree mdecl, c;\n+  int is_interface = CLASS_INTERFACE (ctxp->current_parsed_class);\n+  int has_non_primitive_fields = 0;\n \n   if (!ctxp->static_initialized || java_error_count)\n     return;\n \n+  if (is_interface)\n+    for (c = TYPE_FIELDS (TREE_TYPE (ctxp->current_parsed_class));\n+\t c; c = TREE_CHAIN (c))\n+      has_non_primitive_fields |= !JPRIMITIVE_TYPE_P (TREE_TYPE (c));\n+  if (!has_non_primitive_fields && is_interface)\n+    return;\n+\n   mdecl = create_artificial_method (TREE_TYPE (ctxp->current_parsed_class),\n \t\t\t\t    ACC_STATIC, void_type_node,\n \t\t\t\t    clinit_identifier_node, end_params_node);\n@@ -4404,8 +4417,7 @@ static int\n reset_method_name (method)\n      tree method;\n {\n-  if (DECL_NAME (method) != clinit_identifier_node\n-      && DECL_NAME (method) != finit_identifier_node)\n+  if (!IS_CLINIT (method) && DECL_NAME (method) != finit_identifier_node)\n     {\n       /* NAME is just the plain name when Object is being defined */\n       if (DECL_CONTEXT (method) != object_type_node)\n@@ -5662,51 +5674,55 @@ java_complete_expand_methods ()\n   \n   for (current = ctxp->class_list; current; current = TREE_CHAIN (current))\n     {\n+      int is_interface;\n       tree class_type = CLASS_TO_HANDLE_TYPE (TREE_TYPE (current));\n       tree decl;\n \n       current_class = TREE_TYPE (current);\n+      is_interface = CLASS_INTERFACE (TYPE_NAME (current_class));\n \n       /* Initialize a new constant pool */\n       init_outgoing_cpool ();\n \n       /* We want <clinit> (if any) to be processed first. */\n       decl = tree_last (TYPE_METHODS (class_type));\n-      if (decl && DECL_NAME (decl) == clinit_identifier_node)\n+      if (IS_CLINIT (decl))\n \t{\n \t  tree list = nreverse (TYPE_METHODS (class_type));\n \t  list = TREE_CHAIN (list);\n \t  TREE_CHAIN (decl) = NULL_TREE;\n \t  TYPE_METHODS (class_type) = chainon (decl, nreverse (list));\n \t}\n+      \n+      for (decl = TYPE_METHODS (class_type); decl; decl = TREE_CHAIN (decl))\n+\t{\n+\t  /* Process only <clinit> method bodies in interfaces. */\n+\t  if (is_interface && decl != TYPE_METHODS (class_type))\n+\t    break;\n \n-      /* Don't process function bodies in interfaces */\n-      if (!CLASS_INTERFACE (TYPE_NAME (current_class)))\n-\tfor (decl = TYPE_METHODS (class_type); decl; decl = TREE_CHAIN (decl))\n-\t  {\n-\t    current_function_decl = decl;\n-\t    /* Don't generate debug info on line zero when expanding a\n-\t       generated constructor. */\n-\t    if (DECL_CONSTRUCTOR_P (decl) && !DECL_FUNCTION_BODY (decl))\n-\t      {\n-\t\t/* If we found errors, it's too dangerous to try to generate\n-\t\t   and expand a constructor */\n-\t\tif (!java_error_count)\n-\t\t  {\n-\t\t    restore_line_number_status (1);\n-\t\t    java_complete_expand_method (decl);\n-\t\t    restore_line_number_status (0);\n+\t  current_function_decl = decl;\n+\t  /* Don't generate debug info on line zero when expanding a\n+\t     generated constructor. */\n+\t  if (DECL_CONSTRUCTOR_P (decl) && !DECL_FUNCTION_BODY (decl))\n+\t    {\n+\t      /* If we found errors, it's too dangerous to try to\n+\t\t generate and expand a constructor */\n+\t      if (!java_error_count)\n+\t\t{\n+\t\t  restore_line_number_status (1);\n+\t\t  java_complete_expand_method (decl);\n+\t\t  restore_line_number_status (0);\n \t\t  }\n-\t      }\n-\t    else if (METHOD_ABSTRACT (decl) || METHOD_NATIVE (decl))\n-\t      continue;\n-\t    else \n-\t      java_complete_expand_method (decl);\n-\t  }\n+\t    }\n+\t  else if (METHOD_ABSTRACT (decl) || METHOD_NATIVE (decl))\n+\t    continue;\n+\t  else \n+\t    java_complete_expand_method (decl);\n+\t}\n \n       /* Now verify constructor circularity (stop after the first one\n          we find) */\n-      if (!CLASS_INTERFACE (TYPE_NAME (current_class)))\n+      if (!is_interface)\n \tfor (decl = TYPE_METHODS (class_type); decl; decl = TREE_CHAIN (decl))\n \t  if (DECL_CONSTRUCTOR_P (decl) && \n \t      verify_constructor_circularity (decl, decl))\n@@ -5761,7 +5777,7 @@ java_complete_expand_method (mdecl)\n       if (block_body != NULL_TREE)\n \t{\n \t  /* Prevent the use of `this' inside <clinit> */\n-\t  if (DECL_NAME (current_function_decl) == clinit_identifier_node)\n+\t  if (IS_CLINIT (current_function_decl))\n \t    ctxp->explicit_constructor_p = 1;\n \n \t  block_body = java_complete_tree (block_body);\n@@ -6097,9 +6113,9 @@ resolve_expression_name (id, orig)\n \n \t      /* Otherwise build what it takes to access the field */\n \t      decl = build_field_ref ((fs ? NULL_TREE : current_this),\n-\t\t\t\t      current_class, name);\n+\t\t\t\t      DECL_CONTEXT (decl), name);\n \t      if (fs && !flag_emit_class_files && !flag_emit_xref)\n-\t\tdecl = build_class_init (current_class, decl);\n+\t\tdecl = build_class_init (DECL_CONTEXT (decl), decl);\n \t      /* We may be asked to save the real field access node */\n \t      if (orig)\n \t\t*orig = decl;\n@@ -8074,7 +8090,7 @@ java_complete_lhs (node)\n          assignment in <clinit>, we may want to carray further\n          optimizations. (VAR_DECL means it's a static field. See\n          add_field. */\n-      if (DECL_NAME (current_function_decl) == clinit_identifier_node\n+      if (IS_CLINIT (current_function_decl) \n \t  && MODIFY_EXPR_FROM_INITIALIZATION_P (node)\n \t  && TREE_CODE (TREE_OPERAND (node, 0)) == VAR_DECL)\n \tnode = patch_initialized_static_field (node);\n@@ -8159,14 +8175,14 @@ java_complete_lhs (node)\n       TREE_OPERAND (node, 0) = java_complete_tree (wfl_op1);\n       if (TREE_OPERAND (node, 0) == error_mark_node)\n \treturn error_mark_node;\n-      if (!flag_emit_class_files)\n+      if (!flag_emit_class_files && !flag_emit_xref)\n \tTREE_OPERAND (node, 0) = save_expr (TREE_OPERAND (node, 0));\n       /* The same applies to wfl_op2 */\n       wfl_op2 = TREE_OPERAND (node, 1);\n       TREE_OPERAND (node, 1) = java_complete_tree (wfl_op2);\n       if (TREE_OPERAND (node, 1) == error_mark_node)\n \treturn error_mark_node;\n-      if (!flag_emit_class_files)\n+      if (!flag_emit_class_files && !flag_emit_xref)\n \tTREE_OPERAND (node, 1) = save_expr (TREE_OPERAND (node, 1));\n       return patch_array_ref (node);\n \n@@ -8507,14 +8523,15 @@ print_int_node (node)\n   return buffer;\n }\n \n-/* Return 1 if you an assignment of a FINAL is attempted */\n+/* Return 1 if an assignment to a FINAL is attempted in a non suitable\n+   context.  */\n \n static int\n check_final_assignment (lvalue, wfl)\n      tree lvalue, wfl;\n {\n-  if (JDECL_P (lvalue) && FIELD_FINAL (lvalue) &&\n-      DECL_NAME (current_function_decl) != clinit_identifier_node)\n+  if (JDECL_P (lvalue) \n+      && FIELD_FINAL (lvalue) && !IS_CLINIT (current_function_decl))\n     {\n       parse_error_context \n         (wfl, \"Can't assign a value to the final variable `%s'\",\n@@ -10070,7 +10087,7 @@ patch_array_ref (node)\n \n   array_type = TYPE_ARRAY_ELEMENT (array_type);\n \n-  if (flag_emit_class_files)\n+  if (flag_emit_class_files || flag_emit_xref)\n     {\n       TREE_OPERAND (node, 0) = array;\n       TREE_OPERAND (node, 1) = index;\n@@ -10396,7 +10413,7 @@ patch_return (node)\n     error_found = 1;\n \n   /* It's invalid to use a return statement in a static block */\n-  if (DECL_NAME (current_function_decl) == clinit_identifier_node)\n+  if (IS_CLINIT (current_function_decl))\n     error_found = 1;\n \n   /* It's invalid to have a no return value within a function that\n@@ -10406,7 +10423,7 @@ patch_return (node)\n \n   if (error_found)\n     {\n-      if (DECL_NAME (current_function_decl) == clinit_identifier_node)\n+      if (IS_CLINIT (current_function_decl))\n \tparse_error_context (wfl_operator,\n \t\t\t     \"`return' inside static initializer.\");\n \n@@ -11134,7 +11151,7 @@ patch_throw_statement (node, wfl_op1)\n       else if (!EXCEPTIONS_P (currently_caught_type_list) \n \t       && !tryblock_throws_ok)\n \t{\n-\t  if (DECL_NAME (current_function_decl) == clinit_identifier_node)\n+\t  if (IS_CLINIT (current_function_decl))\n \t    parse_error_context (wfl_operator, \"Checked exception `%s' can't \"\n \t\t\t\t \"be thrown in initializer\",\n \t\t\t\t lang_printable_name (type, 0));"}]}