{"sha": "ab532386bd67549000dbe8db91d5fa3bf56239c7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWI1MzIzODZiZDY3NTQ5MDAwZGJlOGRiOTFkNWZhM2JmNTYyMzljNw==", "commit": {"author": {"name": "Joseph Myers", "email": "joseph@codesourcery.com", "date": "2005-07-03T21:08:11Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2005-07-03T21:08:11Z"}, "message": "bb-reorder.c, [...]: Avoid \".\" or \"\\n\" at end of diagnostics and capital letters at start of diagnostics.\n\n\t* bb-reorder.c, c-pch.c, c-pragma.c, c.opt, cfghooks.c, cfgloop.c,\n\tcfgrtl.c, cgraphunit.c, config/c4x/c4x.c, config/cris/cris.c,\n\tconfig/frv/frv.c, config/host-darwin.c, config/iq2000/iq2000.c,\n\tconfig/lynx.h, config/m68k/m68k.c, config/pa/pa.c, config/sh/sh.h,\n\tconfig/stormy16/stormy16.c, config/v850/v850.c,\n\tconfig/vax/netbsd-elf.h, coverage.c, dwarf2out.c, emit-rtl.c,\n\texcept.c, gcc.c, tree-cfg.c, tree-eh.c, tree-ssa.c, xcoffout.c:\n\tAvoid \".\" or \"\\n\" at end of diagnostics and capital letters at\n\tstart of diagnostics.\n\t* combine.c, cse.c: Don't translate dump file output.\n\t* toplev.c (print_version): Only translate output if going to\n\tstderr.\n\nFrom-SVN: r101561", "tree": {"sha": "9e35ca21fbfbb197d00f2ae30beb41c733d69f5f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9e35ca21fbfbb197d00f2ae30beb41c733d69f5f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ab532386bd67549000dbe8db91d5fa3bf56239c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab532386bd67549000dbe8db91d5fa3bf56239c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab532386bd67549000dbe8db91d5fa3bf56239c7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab532386bd67549000dbe8db91d5fa3bf56239c7/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9bce667ce5fcc889c3b3212085cf227381e09532", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9bce667ce5fcc889c3b3212085cf227381e09532", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9bce667ce5fcc889c3b3212085cf227381e09532"}], "stats": {"total": 417, "additions": 219, "deletions": 198}, "files": [{"sha": "c05031a00693c87c70d953bff89994ab79a0886c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab532386bd67549000dbe8db91d5fa3bf56239c7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab532386bd67549000dbe8db91d5fa3bf56239c7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ab532386bd67549000dbe8db91d5fa3bf56239c7", "patch": "@@ -1,3 +1,18 @@\n+2005-07-03  Joseph S. Myers  <joseph@codesourcery.com>\n+\n+\t* bb-reorder.c, c-pch.c, c-pragma.c, c.opt, cfghooks.c, cfgloop.c,\n+\tcfgrtl.c, cgraphunit.c, config/c4x/c4x.c, config/cris/cris.c,\n+\tconfig/frv/frv.c, config/host-darwin.c, config/iq2000/iq2000.c,\n+\tconfig/lynx.h, config/m68k/m68k.c, config/pa/pa.c, config/sh/sh.h,\n+\tconfig/stormy16/stormy16.c, config/v850/v850.c,\n+\tconfig/vax/netbsd-elf.h, coverage.c, dwarf2out.c, emit-rtl.c,\n+\texcept.c, gcc.c, tree-cfg.c, tree-eh.c, tree-ssa.c, xcoffout.c:\n+\tAvoid \".\" or \"\\n\" at end of diagnostics and capital letters at\n+\tstart of diagnostics.\n+\t* combine.c, cse.c: Don't translate dump file output.\n+\t* toplev.c (print_version): Only translate output if going to\n+\tstderr.\n+\n 2005-07-03  Kazu Hirata  <kazu@codesourcery.com>\n \n \t* c-decl.c, tree-object-size.c, tree-vectorizer.c,"}, {"sha": "e81debacaea93509b788594d0566fcd0b393bdc4", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab532386bd67549000dbe8db91d5fa3bf56239c7/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab532386bd67549000dbe8db91d5fa3bf56239c7/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=ab532386bd67549000dbe8db91d5fa3bf56239c7", "patch": "@@ -1863,7 +1863,7 @@ verify_hot_cold_block_grouping (void)\n \t{\n \t  if (switched_sections)\n \t    {\n-\t      error (\"Multiple hot/cold transitions found (bb %i)\",\n+\t      error (\"multiple hot/cold transitions found (bb %i)\",\n \t\t     bb->index);\n \t      err = 1;\n \t    }"}, {"sha": "d066b657b081909e8de7e135f32e268a6882de1d", "filename": "gcc/c-pch.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab532386bd67549000dbe8db91d5fa3bf56239c7/gcc%2Fc-pch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab532386bd67549000dbe8db91d5fa3bf56239c7/gcc%2Fc-pch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pch.c?ref=ab532386bd67549000dbe8db91d5fa3bf56239c7", "patch": "@@ -464,7 +464,7 @@ c_common_pch_pragma (cpp_reader *pfile)\n   \n   fd = open (name, O_RDONLY | O_BINARY, 0666);\n   if (fd == -1)\n-    fatal_error (\"%s: couldn%'t open PCH file: %m\\n\", name);\n+    fatal_error (\"%s: couldn%'t open PCH file: %m\", name);\n   \n   if (c_common_valid_pch (pfile, name, fd) != 1)\n     {"}, {"sha": "65b12ce54de9a29d413c0a0068f0e0cb3b99d5d7", "filename": "gcc/c-pragma.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab532386bd67549000dbe8db91d5fa3bf56239c7/gcc%2Fc-pragma.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab532386bd67549000dbe8db91d5fa3bf56239c7/gcc%2Fc-pragma.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pragma.c?ref=ab532386bd67549000dbe8db91d5fa3bf56239c7", "patch": "@@ -619,7 +619,7 @@ handle_pragma_visibility (cpp_reader *dummy ATTRIBUTE_UNUSED)\n         {\n           if (!VEC_length (visibility, visstack))\n             {\n-              GCC_BAD (\"No matching push for %<#pragma GCC visibility pop%>\");\n+              GCC_BAD (\"no matching push for %<#pragma GCC visibility pop%>\");\n             }\n           else\n             {"}, {"sha": "f13fbe86cd084d2ebbbd3b71f5ad9ea1c9d2956c", "filename": "gcc/c.opt", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab532386bd67549000dbe8db91d5fa3bf56239c7/gcc%2Fc.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab532386bd67549000dbe8db91d5fa3bf56239c7/gcc%2Fc.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc.opt?ref=ab532386bd67549000dbe8db91d5fa3bf56239c7", "patch": "@@ -218,7 +218,7 @@ C ObjC C++ ObjC++ Joined\n \n Winit-self\n C ObjC C++ ObjC++ Var(warn_init_self)\n-Warn about variables which are initialized to themselves.\n+Warn about variables which are initialized to themselves\n \n Wimplicit\n C ObjC C++ ObjC++\n@@ -233,7 +233,7 @@ Warn when a declaration does not specify a type\n \n Wimport\n C ObjC C++ ObjC++\n-Deprecated.  This switch has no effect.\n+Deprecated.  This switch has no effect\n \n Wint-to-pointer-cast\n C ObjC Var(warn_int_to_pointer_cast) Init(1)"}, {"sha": "bc296d43e0bc65cd88365ffe141296586163404c", "filename": "gcc/cfghooks.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab532386bd67549000dbe8db91d5fa3bf56239c7/gcc%2Fcfghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab532386bd67549000dbe8db91d5fa3bf56239c7/gcc%2Fcfghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfghooks.c?ref=ab532386bd67549000dbe8db91d5fa3bf56239c7", "patch": "@@ -162,7 +162,7 @@ verify_flow_info (void)\n \t}\n       if (n_fallthru > 1)\n \t{\n-\t  error (\"Wrong amount of branch edges after unconditional jump %i\", bb->index);\n+\t  error (\"wrong amount of branch edges after unconditional jump %i\", bb->index);\n \t  err = 1;\n \t}\n \n@@ -285,7 +285,7 @@ redirect_edge_and_branch (edge e, basic_block dest)\n   edge ret;\n \n   if (!cfg_hooks->redirect_edge_and_branch)\n-    internal_error (\"%s does not support redirect_edge_and_branch.\",\n+    internal_error (\"%s does not support redirect_edge_and_branch\",\n \t\t    cfg_hooks->name);\n \n   ret = cfg_hooks->redirect_edge_and_branch (e, dest);\n@@ -303,7 +303,7 @@ redirect_edge_and_branch_force (edge e, basic_block dest)\n   basic_block ret;\n \n   if (!cfg_hooks->redirect_edge_and_branch_force)\n-    internal_error (\"%s does not support redirect_edge_and_branch_force.\",\n+    internal_error (\"%s does not support redirect_edge_and_branch_force\",\n \t\t    cfg_hooks->name);\n \n   ret = cfg_hooks->redirect_edge_and_branch_force (e, dest);\n@@ -321,7 +321,7 @@ split_block (basic_block bb, void *i)\n   basic_block new_bb;\n \n   if (!cfg_hooks->split_block)\n-    internal_error (\"%s does not support split_block.\", cfg_hooks->name);\n+    internal_error (\"%s does not support split_block\", cfg_hooks->name);\n \n   new_bb = cfg_hooks->split_block (bb, i);\n   if (!new_bb)\n@@ -357,7 +357,7 @@ move_block_after (basic_block bb, basic_block after)\n   bool ret;\n \n   if (!cfg_hooks->move_block_after)\n-    internal_error (\"%s does not support move_block_after.\", cfg_hooks->name);\n+    internal_error (\"%s does not support move_block_after\", cfg_hooks->name);\n \n   ret = cfg_hooks->move_block_after (bb, after);\n \n@@ -370,7 +370,7 @@ void\n delete_basic_block (basic_block bb)\n {\n   if (!cfg_hooks->delete_basic_block)\n-    internal_error (\"%s does not support delete_basic_block.\", cfg_hooks->name);\n+    internal_error (\"%s does not support delete_basic_block\", cfg_hooks->name);\n \n   cfg_hooks->delete_basic_block (bb);\n \n@@ -402,7 +402,7 @@ split_edge (edge e)\n   bool irr = (e->flags & EDGE_IRREDUCIBLE_LOOP) != 0;\n \n   if (!cfg_hooks->split_edge)\n-    internal_error (\"%s does not support split_edge.\", cfg_hooks->name);\n+    internal_error (\"%s does not support split_edge\", cfg_hooks->name);\n \n   ret = cfg_hooks->split_edge (e);\n   ret->count = count;\n@@ -463,7 +463,7 @@ create_basic_block (void *head, void *end, basic_block after)\n   basic_block ret;\n \n   if (!cfg_hooks->create_basic_block)\n-    internal_error (\"%s does not support create_basic_block.\", cfg_hooks->name);\n+    internal_error (\"%s does not support create_basic_block\", cfg_hooks->name);\n \n   ret = cfg_hooks->create_basic_block (head, end, after);\n \n@@ -491,7 +491,7 @@ can_merge_blocks_p (basic_block bb1, basic_block bb2)\n   bool ret;\n \n   if (!cfg_hooks->can_merge_blocks_p)\n-    internal_error (\"%s does not support can_merge_blocks_p.\", cfg_hooks->name);\n+    internal_error (\"%s does not support can_merge_blocks_p\", cfg_hooks->name);\n \n   ret = cfg_hooks->can_merge_blocks_p (bb1, bb2);\n \n@@ -502,7 +502,7 @@ void\n predict_edge (edge e, enum br_predictor predictor, int probability)\n {\n   if (!cfg_hooks->predict_edge)\n-    internal_error (\"%s does not support predict_edge.\", cfg_hooks->name);\n+    internal_error (\"%s does not support predict_edge\", cfg_hooks->name);\n \n   cfg_hooks->predict_edge (e, predictor, probability);\n }\n@@ -511,7 +511,7 @@ bool\n predicted_by_p (basic_block bb, enum br_predictor predictor)\n {\n   if (!cfg_hooks->predict_edge)\n-    internal_error (\"%s does not support predicted_by_p.\", cfg_hooks->name);\n+    internal_error (\"%s does not support predicted_by_p\", cfg_hooks->name);\n \n   return cfg_hooks->predicted_by_p (bb, predictor);\n }\n@@ -525,7 +525,7 @@ merge_blocks (basic_block a, basic_block b)\n   edge_iterator ei;\n \n   if (!cfg_hooks->merge_blocks)\n-    internal_error (\"%s does not support merge_blocks.\", cfg_hooks->name);\n+    internal_error (\"%s does not support merge_blocks\", cfg_hooks->name);\n \n   cfg_hooks->merge_blocks (a, b);\n \n@@ -570,7 +570,7 @@ make_forwarder_block (basic_block bb, bool (*redirect_edge_p) (edge),\n   basic_block dummy, jump;\n \n   if (!cfg_hooks->make_forwarder_block)\n-    internal_error (\"%s does not support make_forwarder_block.\",\n+    internal_error (\"%s does not support make_forwarder_block\",\n \t\t    cfg_hooks->name);\n \n   fallthru = split_block_after_labels (bb);\n@@ -675,7 +675,7 @@ can_duplicate_block_p (basic_block bb)\n   edge e;\n \n   if (!cfg_hooks->can_duplicate_block_p)\n-    internal_error (\"%s does not support can_duplicate_block_p.\",\n+    internal_error (\"%s does not support can_duplicate_block_p\",\n \t\t    cfg_hooks->name);\n \n   if (bb == EXIT_BLOCK_PTR || bb == ENTRY_BLOCK_PTR)\n@@ -702,7 +702,7 @@ duplicate_block (basic_block bb, edge e)\n   edge_iterator ei;\n \n   if (!cfg_hooks->duplicate_block)\n-    internal_error (\"%s does not support duplicate_block.\",\n+    internal_error (\"%s does not support duplicate_block\",\n \t\t    cfg_hooks->name);\n \n   if (bb->count < new_count)"}, {"sha": "ff977039522b5002340ecb7b430c233175aae76b", "filename": "gcc/cfgloop.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab532386bd67549000dbe8db91d5fa3bf56239c7/gcc%2Fcfgloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab532386bd67549000dbe8db91d5fa3bf56239c7/gcc%2Fcfgloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.c?ref=ab532386bd67549000dbe8db91d5fa3bf56239c7", "patch": "@@ -1085,7 +1085,7 @@ verify_loop_structure (struct loops *loops)\n \n       if (loops->parray[i]->num_nodes != sizes[i])\n \t{\n-\t  error (\"Size of loop %d should be %d, not %d.\",\n+\t  error (\"size of loop %d should be %d, not %d\",\n \t\t   i, sizes[i], loops->parray[i]->num_nodes);\n \t  err = 1;\n \t}\n@@ -1102,7 +1102,7 @@ verify_loop_structure (struct loops *loops)\n       for (j = 0; j < loop->num_nodes; j++)\n \tif (!flow_bb_inside_loop_p (loop, bbs[j]))\n \t  {\n-\t    error (\"Bb %d do not belong to loop %d.\",\n+\t    error (\"bb %d do not belong to loop %d\",\n \t\t    bbs[j]->index, i);\n \t    err = 1;\n \t  }\n@@ -1119,36 +1119,36 @@ verify_loop_structure (struct loops *loops)\n       if ((loops->state & LOOPS_HAVE_PREHEADERS)\n \t  && EDGE_COUNT (loop->header->preds) != 2)\n \t{\n-\t  error (\"Loop %d's header does not have exactly 2 entries.\", i);\n+\t  error (\"loop %d's header does not have exactly 2 entries\", i);\n \t  err = 1;\n \t}\n       if (loops->state & LOOPS_HAVE_SIMPLE_LATCHES)\n \t{\n \t  if (!single_succ_p (loop->latch))\n \t    {\n-\t      error (\"Loop %d's latch does not have exactly 1 successor.\", i);\n+\t      error (\"loop %d's latch does not have exactly 1 successor\", i);\n \t      err = 1;\n \t    }\n \t  if (single_succ (loop->latch) != loop->header)\n \t    {\n-\t      error (\"Loop %d's latch does not have header as successor.\", i);\n+\t      error (\"loop %d's latch does not have header as successor\", i);\n \t      err = 1;\n \t    }\n \t  if (loop->latch->loop_father != loop)\n \t    {\n-\t      error (\"Loop %d's latch does not belong directly to it.\", i);\n+\t      error (\"loop %d's latch does not belong directly to it\", i);\n \t      err = 1;\n \t    }\n \t}\n       if (loop->header->loop_father != loop)\n \t{\n-\t  error (\"Loop %d's header does not belong directly to it.\", i);\n+\t  error (\"loop %d's header does not belong directly to it\", i);\n \t  err = 1;\n \t}\n       if ((loops->state & LOOPS_HAVE_MARKED_IRREDUCIBLE_REGIONS)\n \t  && (loop_latch_edge (loop)->flags & EDGE_IRREDUCIBLE_LOOP))\n \t{\n-\t  error (\"Loop %d's latch is marked as part of irreducible region.\", i);\n+\t  error (\"loop %d's latch is marked as part of irreducible region\", i);\n \t  err = 1;\n \t}\n     }\n@@ -1181,28 +1181,28 @@ verify_loop_structure (struct loops *loops)\n \t  if ((bb->flags & BB_IRREDUCIBLE_LOOP)\n \t      && !TEST_BIT (irreds, bb->index))\n \t    {\n-\t      error (\"Basic block %d should be marked irreducible.\", bb->index);\n+\t      error (\"basic block %d should be marked irreducible\", bb->index);\n \t      err = 1;\n \t    }\n \t  else if (!(bb->flags & BB_IRREDUCIBLE_LOOP)\n \t      && TEST_BIT (irreds, bb->index))\n \t    {\n-\t      error (\"Basic block %d should not be marked irreducible.\", bb->index);\n+\t      error (\"basic block %d should not be marked irreducible\", bb->index);\n \t      err = 1;\n \t    }\n \t  FOR_EACH_EDGE (e, ei, bb->succs)\n \t    {\n \t      if ((e->flags & EDGE_IRREDUCIBLE_LOOP)\n \t\t  && !(e->flags & (EDGE_ALL_FLAGS + 1)))\n \t\t{\n-\t\t  error (\"Edge from %d to %d should be marked irreducible.\",\n+\t\t  error (\"edge from %d to %d should be marked irreducible\",\n \t\t\t e->src->index, e->dest->index);\n \t\t  err = 1;\n \t\t}\n \t      else if (!(e->flags & EDGE_IRREDUCIBLE_LOOP)\n \t\t       && (e->flags & (EDGE_ALL_FLAGS + 1)))\n \t\t{\n-\t\t  error (\"Edge from %d to %d should not be marked irreducible.\",\n+\t\t  error (\"edge from %d to %d should not be marked irreducible\",\n \t\t\t e->src->index, e->dest->index);\n \t\t  err = 1;\n \t\t}\n@@ -1237,11 +1237,11 @@ verify_loop_structure (struct loops *loops)\n \t\t  if (loop->single_exit\n \t\t      && loop->single_exit != e)\n \t\t    {\n-\t\t      error (\"Wrong single exit %d->%d recorded for loop %d.\",\n+\t\t      error (\"wrong single exit %d->%d recorded for loop %d\",\n \t\t\t     loop->single_exit->src->index,\n \t\t\t     loop->single_exit->dest->index,\n \t\t\t     loop->num);\n-\t\t      error (\"Right exit is %d->%d.\",\n+\t\t      error (\"right exit is %d->%d\",\n \t\t\t     e->src->index, e->dest->index);\n \t\t      err = 1;\n \t\t    }\n@@ -1258,14 +1258,14 @@ verify_loop_structure (struct loops *loops)\n \t  if (sizes[i] == 1\n \t      && !loop->single_exit)\n \t    {\n-\t      error (\"Single exit not recorded for loop %d.\", loop->num);\n+\t      error (\"single exit not recorded for loop %d\", loop->num);\n \t      err = 1;\n \t    }\n \n \t  if (sizes[i] != 1\n \t      && loop->single_exit)\n \t    {\n-\t      error (\"Loop %d should not have single exit (%d -> %d).\",\n+\t      error (\"loop %d should not have single exit (%d -> %d)\",\n \t\t     loop->num,\n \t\t     loop->single_exit->src->index,\n \t\t     loop->single_exit->dest->index);"}, {"sha": "897df5d134bd1d054c92209c98ec7ab9ba889626", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab532386bd67549000dbe8db91d5fa3bf56239c7/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab532386bd67549000dbe8db91d5fa3bf56239c7/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=ab532386bd67549000dbe8db91d5fa3bf56239c7", "patch": "@@ -1983,7 +1983,7 @@ rtl_verify_flow_info_1 (void)\n \t\t      && e->src != ENTRY_BLOCK_PTR\n \t\t      && e->dest != EXIT_BLOCK_PTR))\n \t    { \n-\t\t  error (\"Fallthru edge crosses section boundary (bb %i)\",\n+\t\t  error (\"fallthru edge crosses section boundary (bb %i)\",\n \t\t\t e->src->index);\n \t\t  err = 1;\n \t\t}\n@@ -2008,36 +2008,36 @@ rtl_verify_flow_info_1 (void)\n       if (n_eh && GET_CODE (PATTERN (BB_END (bb))) != RESX\n \t  && !find_reg_note (BB_END (bb), REG_EH_REGION, NULL_RTX))\n \t{\n-\t  error (\"Missing REG_EH_REGION note in the end of bb %i\", bb->index);\n+\t  error (\"missing REG_EH_REGION note in the end of bb %i\", bb->index);\n \t  err = 1;\n \t}\n       if (n_branch\n \t  && (!JUMP_P (BB_END (bb))\n \t      || (n_branch > 1 && (any_uncondjump_p (BB_END (bb))\n \t\t\t\t   || any_condjump_p (BB_END (bb))))))\n \t{\n-\t  error (\"Too many outgoing branch edges from bb %i\", bb->index);\n+\t  error (\"too many outgoing branch edges from bb %i\", bb->index);\n \t  err = 1;\n \t}\n       if (n_fallthru && any_uncondjump_p (BB_END (bb)))\n \t{\n-\t  error (\"Fallthru edge after unconditional jump %i\", bb->index);\n+\t  error (\"fallthru edge after unconditional jump %i\", bb->index);\n \t  err = 1;\n \t}\n       if (n_branch != 1 && any_uncondjump_p (BB_END (bb)))\n \t{\n-\t  error (\"Wrong amount of branch edges after unconditional jump %i\", bb->index);\n+\t  error (\"wrong amount of branch edges after unconditional jump %i\", bb->index);\n \t  err = 1;\n \t}\n       if (n_branch != 1 && any_condjump_p (BB_END (bb))\n \t  && JUMP_LABEL (BB_END (bb)) == BB_HEAD (fallthru->dest))\n \t{\n-\t  error (\"Wrong amount of branch edges after conditional jump %i\", bb->index);\n+\t  error (\"wrong amount of branch edges after conditional jump %i\", bb->index);\n \t  err = 1;\n \t}\n       if (n_call && !CALL_P (BB_END (bb)))\n \t{\n-\t  error (\"Call edges for non-call insn in bb %i\", bb->index);\n+\t  error (\"call edges for non-call insn in bb %i\", bb->index);\n \t  err = 1;\n \t}\n       if (n_abnormal\n@@ -2046,7 +2046,7 @@ rtl_verify_flow_info_1 (void)\n \t      || any_condjump_p (BB_END (bb))\n \t      || any_uncondjump_p (BB_END (bb))))\n \t{\n-\t  error (\"Abnormal edges for no purpose in bb %i\", bb->index);\n+\t  error (\"abnormal edges for no purpose in bb %i\", bb->index);\n \t  err = 1;\n \t}\n "}, {"sha": "d65a20221fe140fb644e0489ca0111729b039b1e", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab532386bd67549000dbe8db91d5fa3bf56239c7/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab532386bd67549000dbe8db91d5fa3bf56239c7/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=ab532386bd67549000dbe8db91d5fa3bf56239c7", "patch": "@@ -652,7 +652,7 @@ verify_cgraph_node (struct cgraph_node *node)\n   for (e = node->callees; e; e = e->next_callee)\n     if (e->aux)\n       {\n-\terror (\"Aux field set for edge %s->%s\",\n+\terror (\"aux field set for edge %s->%s\",\n \t       cgraph_node_name (e->caller), cgraph_node_name (e->callee));\n \terror_found = true;\n       }\n@@ -664,30 +664,30 @@ verify_cgraph_node (struct cgraph_node *node)\n \t      != (e->caller->global.inlined_to\n \t\t  ? e->caller->global.inlined_to : e->caller))\n \t    {\n-\t      error (\"Inlined_to pointer is wrong\");\n+\t      error (\"inlined_to pointer is wrong\");\n \t      error_found = true;\n \t    }\n \t  if (node->callers->next_caller)\n \t    {\n-\t      error (\"Multiple inline callers\");\n+\t      error (\"multiple inline callers\");\n \t      error_found = true;\n \t    }\n \t}\n       else\n \tif (node->global.inlined_to)\n \t  {\n-\t    error (\"Inlined_to pointer set for noninline callers\");\n+\t    error (\"inlined_to pointer set for noninline callers\");\n \t    error_found = true;\n \t  }\n     }\n   if (!node->callers && node->global.inlined_to)\n     {\n-      error (\"Inlined_to pointer is set but no predecesors found\");\n+      error (\"inlined_to pointer is set but no predecesors found\");\n       error_found = true;\n     }\n   if (node->global.inlined_to == node)\n     {\n-      error (\"Inlined_to pointer refers to itself\");\n+      error (\"inlined_to pointer refers to itself\");\n       error_found = true;\n     }\n \n@@ -697,7 +697,7 @@ verify_cgraph_node (struct cgraph_node *node)\n       break;\n   if (!node)\n     {\n-      error (\"Node not found in DECL_ASSEMBLER_NAME hash\");\n+      error (\"node not found in DECL_ASSEMBLER_NAME hash\");\n       error_found = true;\n     }\n   \n@@ -725,13 +725,13 @@ verify_cgraph_node (struct cgraph_node *node)\n \t\t      {\n \t\t\tif (e->aux)\n \t\t\t  {\n-\t\t\t    error (\"Shared call_stmt:\");\n+\t\t\t    error (\"shared call_stmt:\");\n \t\t\t    debug_generic_stmt (stmt);\n \t\t\t    error_found = true;\n \t\t\t  }\n \t\t\tif (e->callee->decl != cgraph_node (decl)->decl)\n \t\t\t  {\n-\t\t\t    error (\"Edge points to wrong declaration:\");\n+\t\t\t    error (\"edge points to wrong declaration:\");\n \t\t\t    debug_tree (e->callee->decl);\n \t\t\t    fprintf (stderr,\" Instead of:\");\n \t\t\t    debug_tree (decl);\n@@ -740,7 +740,7 @@ verify_cgraph_node (struct cgraph_node *node)\n \t\t      }\n \t\t    else\n \t\t      {\n-\t\t\terror (\"Missing callgraph edge for call stmt:\");\n+\t\t\terror (\"missing callgraph edge for call stmt:\");\n \t\t\tdebug_generic_stmt (stmt);\n \t\t\terror_found = true;\n \t\t      }\n@@ -757,7 +757,7 @@ verify_cgraph_node (struct cgraph_node *node)\n \t{\n \t  if (!e->aux)\n \t    {\n-\t      error (\"Edge %s->%s has no corresponding call_stmt\",\n+\t      error (\"edge %s->%s has no corresponding call_stmt\",\n \t\t     cgraph_node_name (e->caller),\n \t\t     cgraph_node_name (e->callee));\n \t      debug_generic_stmt (e->call_stmt);\n@@ -769,7 +769,7 @@ verify_cgraph_node (struct cgraph_node *node)\n   if (error_found)\n     {\n       dump_cgraph_node (stderr, node);\n-      internal_error (\"verify_cgraph_node failed.\");\n+      internal_error (\"verify_cgraph_node failed\");\n     }\n   timevar_pop (TV_CGRAPH_VERIFY);\n }\n@@ -1271,7 +1271,7 @@ cgraph_optimize (void)\n \t    dump_cgraph_node (stderr, node);\n  \t  }\n       if (error_found)\n-\tinternal_error (\"Nodes with no released memory found.\");\n+\tinternal_error (\"nodes with no released memory found\");\n     }\n #endif\n }"}, {"sha": "9fa68bae651d5e64b42c4f1b2a793a6f941ab17e", "filename": "gcc/combine.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab532386bd67549000dbe8db91d5fa3bf56239c7/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab532386bd67549000dbe8db91d5fa3bf56239c7/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=ab532386bd67549000dbe8db91d5fa3bf56239c7", "patch": "@@ -12500,7 +12500,7 @@ insn_cuid (rtx insn)\n void\n dump_combine_stats (FILE *file)\n {\n-  fnotice\n+  fprintf\n     (file,\n      \";; Combiner statistics: %d attempts, %d substitutions (%d requiring new space),\\n;; %d successes.\\n\\n\",\n      combine_attempts, combine_merges, combine_extras, combine_successes);\n@@ -12509,7 +12509,7 @@ dump_combine_stats (FILE *file)\n void\n dump_combine_total_stats (FILE *file)\n {\n-  fnotice\n+  fprintf\n     (file,\n      \"\\n;; Combiner totals: %d attempts, %d substitutions (%d requiring new space),\\n;; %d successes.\\n\",\n      total_attempts, total_merges, total_extras, total_successes);"}, {"sha": "f7002c1d381ae9fb3869b00b3256a674a2dea7b6", "filename": "gcc/config/c4x/c4x.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab532386bd67549000dbe8db91d5fa3bf56239c7/gcc%2Fconfig%2Fc4x%2Fc4x.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab532386bd67549000dbe8db91d5fa3bf56239c7/gcc%2Fconfig%2Fc4x%2Fc4x.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.c?ref=ab532386bd67549000dbe8db91d5fa3bf56239c7", "patch": "@@ -4098,8 +4098,8 @@ c4x_rptb_rpts_p (rtx insn, rtx op)\n          where they are and print a warning.  We should\n          probably move these insns before the repeat block insn.  */\n       if (TARGET_DEBUG)\n-\tfatal_insn(\"c4x_rptb_rpts_p: Repeat block top label moved\\n\",\n-\t\t   insn);\n+\tfatal_insn (\"c4x_rptb_rpts_p: Repeat block top label moved\",\n+\t\t    insn);\n       return 0;\n     }\n "}, {"sha": "ac55717dd59be57021d35331262dab2842112b17", "filename": "gcc/config/cris/cris.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab532386bd67549000dbe8db91d5fa3bf56239c7/gcc%2Fconfig%2Fcris%2Fcris.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab532386bd67549000dbe8db91d5fa3bf56239c7/gcc%2Fconfig%2Fcris%2Fcris.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.c?ref=ab532386bd67549000dbe8db91d5fa3bf56239c7", "patch": "@@ -1470,7 +1470,7 @@ cris_notice_update_cc (rtx exp, rtx insn)\n       break;\n \n     default:\n-      internal_error (\"Unknown cc_attr value\");\n+      internal_error (\"unknown cc_attr value\");\n     }\n \n   CC_STATUS_INIT;"}, {"sha": "9b94bd3ddbbb9d5ca4a9b21562ff134a98b7a091", "filename": "gcc/config/frv/frv.c", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab532386bd67549000dbe8db91d5fa3bf56239c7/gcc%2Fconfig%2Ffrv%2Ffrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab532386bd67549000dbe8db91d5fa3bf56239c7/gcc%2Fconfig%2Ffrv%2Ffrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.c?ref=ab532386bd67549000dbe8db91d5fa3bf56239c7", "patch": "@@ -2510,7 +2510,7 @@ frv_print_operand_address (FILE * stream, rtx x)\n       break;\n     }\n \n-  fatal_insn (\"Bad insn to frv_print_operand_address:\", x);\n+  fatal_insn (\"bad insn to frv_print_operand_address:\", x);\n }\n \n \f\n@@ -2521,7 +2521,7 @@ frv_print_operand_memory_reference_reg (FILE * stream, rtx x)\n   if (GPR_P (regno))\n     fputs (reg_names[regno], stream);\n   else\n-    fatal_insn (\"Bad register to frv_print_operand_memory_reference_reg:\", x);\n+    fatal_insn (\"bad register to frv_print_operand_memory_reference_reg:\", x);\n }\n \n /* Print a memory reference suitable for the ld/st instructions.  */\n@@ -2560,7 +2560,7 @@ frv_print_operand_memory_reference (FILE * stream, rtx x, int addr_offset)\n       break;\n \n     default:\n-      fatal_insn (\"Bad insn to frv_print_operand_memory_reference:\", x);\n+      fatal_insn (\"bad insn to frv_print_operand_memory_reference:\", x);\n       break;\n \n     }\n@@ -2570,7 +2570,7 @@ frv_print_operand_memory_reference (FILE * stream, rtx x, int addr_offset)\n       if (!x1)\n \tx1 = const0_rtx;\n       else if (GET_CODE (x1) != CONST_INT)\n-\tfatal_insn (\"Bad insn to frv_print_operand_memory_reference:\", x);\n+\tfatal_insn (\"bad insn to frv_print_operand_memory_reference:\", x);\n     }\n \n   fputs (\"@(\", stream);\n@@ -2579,7 +2579,7 @@ frv_print_operand_memory_reference (FILE * stream, rtx x, int addr_offset)\n   else if (GET_CODE (x0) == REG || GET_CODE (x0) == SUBREG)\n     frv_print_operand_memory_reference_reg (stream, x0);\n   else\n-    fatal_insn (\"Bad insn to frv_print_operand_memory_reference:\", x);\n+    fatal_insn (\"bad insn to frv_print_operand_memory_reference:\", x);\n \n   fputs (\",\", stream);\n   if (!x1)\n@@ -2600,12 +2600,12 @@ frv_print_operand_memory_reference (FILE * stream, rtx x, int addr_offset)\n \n \tcase CONST:\n \t  if (!frv_const_unspec_p (x1, &unspec))\n-\t    fatal_insn (\"Bad insn to frv_print_operand_memory_reference:\", x1);\n+\t    fatal_insn (\"bad insn to frv_print_operand_memory_reference:\", x1);\n \t  frv_output_const_unspec (stream, &unspec);\n \t  break;\n \n \tdefault:\n-\t  fatal_insn (\"Bad insn to frv_print_operand_memory_reference:\", x);\n+\t  fatal_insn (\"bad insn to frv_print_operand_memory_reference:\", x);\n \t}\n     }\n \n@@ -2766,7 +2766,7 @@ frv_print_operand (FILE * file, rtx x, int code)\n \tvalue = CONST_DOUBLE_LOW (x);\n \n       else\n-        fatal_insn (\"Bad insn in frv_print_operand, bad const_double\", x);\n+        fatal_insn (\"bad insn in frv_print_operand, bad const_double\", x);\n     }\n \n   else\n@@ -2827,15 +2827,15 @@ frv_print_operand (FILE * file, rtx x, int code)\n \tfputs (\"0\", file);\n \n       else\n-\tfatal_insn (\"Bad insn to frv_print_operand, 'e' modifier:\", x);\n+\tfatal_insn (\"bad insn to frv_print_operand, 'e' modifier:\", x);\n       break;\n \n     case 'F':\n       /* Print appropriate test for floating point branch false operation.  */\n       switch (GET_CODE (x))\n \t{\n \tdefault:\n-\t  fatal_insn (\"Bad insn to frv_print_operand, 'F' modifier:\", x);\n+\t  fatal_insn (\"bad insn to frv_print_operand, 'F' modifier:\", x);\n \n \tcase EQ:  fputs (\"ne\",  file); break;\n \tcase NE:  fputs (\"eq\",  file); break;\n@@ -2851,7 +2851,7 @@ frv_print_operand (FILE * file, rtx x, int code)\n       switch (GET_CODE (x))\n \t{\n \tdefault:\n-\t  fatal_insn (\"Bad insn to frv_print_operand, 'f' modifier:\", x);\n+\t  fatal_insn (\"bad insn to frv_print_operand, 'f' modifier:\", x);\n \n \tcase EQ:  fputs (\"eq\",  file); break;\n \tcase NE:  fputs (\"ne\",  file); break;\n@@ -2865,7 +2865,7 @@ frv_print_operand (FILE * file, rtx x, int code)\n     case 'g':\n       /* Print appropriate GOT function.  */\n       if (GET_CODE (x) != CONST_INT)\n-\tfatal_insn (\"Bad insn to frv_print_operand, 'g' modifier:\", x);\n+\tfatal_insn (\"bad insn to frv_print_operand, 'g' modifier:\", x);\n       fputs (unspec_got_name (INTVAL (x)), file);\n       break;\n \n@@ -2913,7 +2913,7 @@ frv_print_operand (FILE * file, rtx x, int code)\n       if (GET_CODE (x) == REG)\n \tfputs (reg_names[ REGNO (x)+1 ], file);\n       else\n-\tfatal_insn (\"Bad insn to frv_print_operand, 'L' modifier:\", x);\n+\tfatal_insn (\"bad insn to frv_print_operand, 'L' modifier:\", x);\n       break;\n \n     /* case 'l': print a LABEL_REF.  */\n@@ -2926,7 +2926,7 @@ frv_print_operand (FILE * file, rtx x, int code)\n       switch (GET_CODE (x))\n \t{\n \tdefault:\n-\t  fatal_insn (\"Bad insn to frv_print_operand, 'M/N' modifier:\", x);\n+\t  fatal_insn (\"bad insn to frv_print_operand, 'M/N' modifier:\", x);\n \n \tcase MEM:\n \t  frv_print_operand_memory_reference (file, XEXP (x, 0), offset);\n@@ -2947,7 +2947,7 @@ frv_print_operand (FILE * file, rtx x, int code)\n       switch (GET_CODE (x))\n \t{\n \tdefault:\n-\t  fatal_insn (\"Bad insn to frv_print_operand, 'O' modifier:\", x);\n+\t  fatal_insn (\"bad insn to frv_print_operand, 'O' modifier:\", x);\n \n \tcase PLUS:     fputs (\"add\", file); break;\n \tcase MINUS:    fputs (\"sub\", file); break;\n@@ -2965,7 +2965,7 @@ frv_print_operand (FILE * file, rtx x, int code)\n     case 'P':\n       /* Print PIC label using operand as the number.  */\n       if (GET_CODE (x) != CONST_INT)\n-\tfatal_insn (\"Bad insn to frv_print_operand, P modifier:\", x);\n+\tfatal_insn (\"bad insn to frv_print_operand, P modifier:\", x);\n \n       fprintf (file, \".LCF%ld\", (long)INTVAL (x));\n       break;\n@@ -2985,7 +2985,7 @@ frv_print_operand (FILE * file, rtx x, int code)\n         fputs (reg_names [REGNO (x)], file);\n \n       else\n-        fatal_insn (\"Bad insn in frv_print_operand, z case\", x);\n+        fatal_insn (\"bad insn in frv_print_operand, z case\", x);\n       break;\n \n     case 'x':\n@@ -3016,7 +3016,7 @@ frv_print_operand (FILE * file, rtx x, int code)\n         frv_print_operand_address (file, x);\n \n       else\n-        fatal_insn (\"Bad insn in frv_print_operand, 0 case\", x);\n+        fatal_insn (\"bad insn in frv_print_operand, 0 case\", x);\n \n       break;\n \n@@ -4390,7 +4390,7 @@ output_move_single (rtx operands[], rtx insn)\n \t}\n     }\n \n-  fatal_insn (\"Bad output_move_single operand\", insn);\n+  fatal_insn (\"bad output_move_single operand\", insn);\n   return \"\";\n }\n \n@@ -4517,7 +4517,7 @@ output_move_double (rtx operands[], rtx insn)\n \t}\n     }\n \n-  fatal_insn (\"Bad output_move_double operand\", insn);\n+  fatal_insn (\"bad output_move_double operand\", insn);\n   return \"\";\n }\n \n@@ -4659,7 +4659,7 @@ output_condmove_single (rtx operands[], rtx insn)\n \t}\n     }\n \n-  fatal_insn (\"Bad output_condmove_single operand\", insn);\n+  fatal_insn (\"bad output_condmove_single operand\", insn);\n   return \"\";\n }\n "}, {"sha": "d8819515476a7d756469ab76ffc8bfb42f097ece", "filename": "gcc/config/host-darwin.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab532386bd67549000dbe8db91d5fa3bf56239c7/gcc%2Fconfig%2Fhost-darwin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab532386bd67549000dbe8db91d5fa3bf56239c7/gcc%2Fconfig%2Fhost-darwin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fhost-darwin.c?ref=ab532386bd67549000dbe8db91d5fa3bf56239c7", "patch": "@@ -60,7 +60,7 @@ darwin_gt_pch_use_address (void *addr, size_t sz, int fd, size_t off)\n   sz = (sz + pagesize - 1) / pagesize * pagesize;\n \n   if (munmap (pch_address_space + sz, sizeof (pch_address_space) - sz) != 0)\n-    fatal_error (\"couldn't unmap pch_address_space: %m\\n\");\n+    fatal_error (\"couldn't unmap pch_address_space: %m\");\n \n   if (ret)\n     {"}, {"sha": "57e24ea5833ffd3ff02171b76afc343bb0b115a4", "filename": "gcc/config/iq2000/iq2000.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab532386bd67549000dbe8db91d5fa3bf56239c7/gcc%2Fconfig%2Fiq2000%2Fiq2000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab532386bd67549000dbe8db91d5fa3bf56239c7/gcc%2Fconfig%2Fiq2000%2Fiq2000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fiq2000%2Fiq2000.c?ref=ab532386bd67549000dbe8db91d5fa3bf56239c7", "patch": "@@ -1805,7 +1805,7 @@ save_restore_insns (int store_p)\n \n   if (gp_offset < 0 || end_offset < 0)\n     internal_error\n-      (\"gp_offset (%ld) or end_offset (%ld) is less than zero.\",\n+      (\"gp_offset (%ld) or end_offset (%ld) is less than zero\",\n        (long) gp_offset, (long) end_offset);\n \n   else if (gp_offset < 32768)"}, {"sha": "2805a57d336e621d1ba3816e6780f8ebce216b66", "filename": "gcc/config/lynx.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab532386bd67549000dbe8db91d5fa3bf56239c7/gcc%2Fconfig%2Flynx.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab532386bd67549000dbe8db91d5fa3bf56239c7/gcc%2Fconfig%2Flynx.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Flynx.h?ref=ab532386bd67549000dbe8db91d5fa3bf56239c7", "patch": "@@ -68,7 +68,7 @@ Boston, MA 02110-1301, USA.  */\n # define CPP_OS_LYNX_SPEC \\\n \"%{mthreads: \\\n    %{mlegacy-threads: \\\n-     %eCannot use mthreads and mlegacy-threads together.}} \\\n+     %ecannot use mthreads and mlegacy-threads together}} \\\n  %{mthreads: -D_MULTITHREADED} \\\n  %{mlegacy-threads: -D_THREADS_POSIX4ad4} \\\n  -Asystem=lynx -Asystem=unix -D__Lynx__ -D__unix__\"\n@@ -93,7 +93,7 @@ Boston, MA 02110-1301, USA.  */\n #ifndef LINK_OS_LYNX_SPEC\n # define LINK_OS_LYNX_SPEC \\\n \"%{shared} %{static} \\\n- %{mshared: %{static: %eCannot use mshared and static together.}} \\\n+ %{mshared: %{static: %ecannot use mshared and static together}} \\\n  %{!mshared: %{!shared: %{!static: -static}}} \\\n  %{L*} \\\n  %{mthreads: \\"}, {"sha": "155d354207e391ef59bcb17735d3279a790e6055", "filename": "gcc/config/m68k/m68k.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab532386bd67549000dbe8db91d5fa3bf56239c7/gcc%2Fconfig%2Fm68k%2Fm68k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab532386bd67549000dbe8db91d5fa3bf56239c7/gcc%2Fconfig%2Fm68k%2Fm68k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.c?ref=ab532386bd67549000dbe8db91d5fa3bf56239c7", "patch": "@@ -330,7 +330,7 @@ override_options (void)\n   /* -fPIC uses 32-bit pc-relative displacements, which don't exist\n      until the 68020.  */\n   if (!TARGET_68020 && !TARGET_COLDFIRE && (flag_pic == 2))\n-    error(\"-fPIC is not currently supported on the 68000 or 68010\\n\");\n+    error (\"-fPIC is not currently supported on the 68000 or 68010\");\n \n   /* ??? A historic way of turning on pic, or is this intended to\n      be an embedded thing that doesn't have the same name binding"}, {"sha": "54e08edc99618069b81c421f85a590d47a43d658", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab532386bd67549000dbe8db91d5fa3bf56239c7/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab532386bd67549000dbe8db91d5fa3bf56239c7/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=ab532386bd67549000dbe8db91d5fa3bf56239c7", "patch": "@@ -449,12 +449,12 @@ override_options (void)\n \n   if (flag_pic && TARGET_PORTABLE_RUNTIME)\n     {\n-      warning (0, \"PIC code generation is not supported in the portable runtime model\\n\");\n+      warning (0, \"PIC code generation is not supported in the portable runtime model\");\n     }\n \n   if (flag_pic && TARGET_FAST_INDIRECT_CALLS)\n    {\n-      warning (0, \"PIC code generation is not compatible with fast indirect calls\\n\");\n+      warning (0, \"PIC code generation is not compatible with fast indirect calls\");\n    }\n \n   if (! TARGET_GAS && write_symbols != NO_DEBUG)"}, {"sha": "61005f034a469cd22d2d0a1cf66194feb3a0c191", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab532386bd67549000dbe8db91d5fa3bf56239c7/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab532386bd67549000dbe8db91d5fa3bf56239c7/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=ab532386bd67549000dbe8db91d5fa3bf56239c7", "patch": "@@ -604,7 +604,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n \t --with-newlib --with-headers.  But there is no way to check\t\\\n \t here we have a working libgcov, so just assume that we have.  */\\\n       if (profile_flag)\t\t\t\t\t\t\t\\\n-\twarning (0, \"Profiling is still experimental for this target.\");\\\n+\twarning (0, \"profiling is still experimental for this target\");\\\n     }\t\t\t\t\t\t\t\t\t\\\n   else\t\t\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\"}, {"sha": "68fd45057e82cff511d07bafad818286c86f2cc8", "filename": "gcc/config/stormy16/stormy16.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab532386bd67549000dbe8db91d5fa3bf56239c7/gcc%2Fconfig%2Fstormy16%2Fstormy16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab532386bd67549000dbe8db91d5fa3bf56239c7/gcc%2Fconfig%2Fstormy16%2Fstormy16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fstormy16%2Fstormy16.c?ref=ab532386bd67549000dbe8db91d5fa3bf56239c7", "patch": "@@ -494,7 +494,7 @@ xs_hi_general_operand (rtx x, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   if ((GET_CODE (x) == CONST_INT) \n    && ((INTVAL (x) >= 32768) || (INTVAL (x) < -32768)))\n-    error (\"Constant halfword load operand out of range.\");\n+    error (\"constant halfword load operand out of range\");\n   return general_operand (x, mode);\n }\n \n@@ -504,7 +504,7 @@ xs_hi_nonmemory_operand (rtx x, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   if ((GET_CODE (x) == CONST_INT) \n    && ((INTVAL (x) >= 32768) || (INTVAL (x) < -32768)))\n-    error (\"Constant arithmetic operand out of range.\");\n+    error (\"constant arithmetic operand out of range\");\n   return nonmemory_operand (x, mode);\n }\n \n@@ -1107,7 +1107,7 @@ xstormy16_expand_prologue (void)\n   layout = xstormy16_compute_stack_layout ();\n \n   if (layout.locals_size >= 32768)\n-    error (\"Local variable memory requirements exceed capacity.\");\n+    error (\"local variable memory requirements exceed capacity\");\n \n   /* Save the argument registers if necessary.  */\n   if (layout.stdarg_save_size)\n@@ -2306,7 +2306,7 @@ xstormy16_handle_below100_attribute (tree *node,\n       if (! (TREE_PUBLIC (*node) || TREE_STATIC (*node)))\n \t{\n \t  warning (OPT_Wattributes, \"__BELOW100__ attribute not allowed \"\n-\t\t   \"with auto storage class.\");\n+\t\t   \"with auto storage class\");\n \t  *no_add_attrs = true;\n \t}\n     }"}, {"sha": "79c56afe30d0f8ed15fa753f7d7d05956fc6e0e6", "filename": "gcc/config/v850/v850.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab532386bd67549000dbe8db91d5fa3bf56239c7/gcc%2Fconfig%2Fv850%2Fv850.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab532386bd67549000dbe8db91d5fa3bf56239c7/gcc%2Fconfig%2Fv850%2Fv850.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.c?ref=ab532386bd67549000dbe8db91d5fa3bf56239c7", "patch": "@@ -2278,7 +2278,7 @@ construct_restore_jr (rtx op)\n   \n   if (count <= 2)\n     {\n-      error (\"bogus JR construction: %d\\n\", count);\n+      error (\"bogus JR construction: %d\", count);\n       return NULL;\n     }\n \n@@ -2684,7 +2684,7 @@ construct_dispose_instruction (rtx op)\n   \n   if (count <= 2)\n     {\n-      error (\"Bogus DISPOSE construction: %d\\n\", count);\n+      error (\"bogus DISPOSE construction: %d\", count);\n       return NULL;\n     }\n \n@@ -2703,7 +2703,7 @@ construct_dispose_instruction (rtx op)\n      will fit into the DISPOSE instruction.  */\n   if (stack_bytes > 128)\n     {\n-      error (\"Too much stack space to dispose of: %d\", stack_bytes);\n+      error (\"too much stack space to dispose of: %d\", stack_bytes);\n       return NULL;\n     }\n \n@@ -2805,7 +2805,7 @@ construct_prepare_instruction (rtx op)\n   \n   if (count <= 1)\n     {\n-      error (\"Bogus PREPEARE construction: %d\\n\", count);\n+      error (\"bogus PREPEARE construction: %d\", count);\n       return NULL;\n     }\n \n@@ -2824,7 +2824,7 @@ construct_prepare_instruction (rtx op)\n      will fit into the DISPOSE instruction.  */\n   if (stack_bytes < -128)\n     {\n-      error (\"Too much stack space to prepare: %d\", stack_bytes);\n+      error (\"too much stack space to prepare: %d\", stack_bytes);\n       return NULL;\n     }\n "}, {"sha": "700e7903427d0ebb033129497a59ec23150c0f6a", "filename": "gcc/config/vax/netbsd-elf.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab532386bd67549000dbe8db91d5fa3bf56239c7/gcc%2Fconfig%2Fvax%2Fnetbsd-elf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab532386bd67549000dbe8db91d5fa3bf56239c7/gcc%2Fconfig%2Fvax%2Fnetbsd-elf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fnetbsd-elf.h?ref=ab532386bd67549000dbe8db91d5fa3bf56239c7", "patch": "@@ -39,7 +39,7 @@ Boston, MA 02110-1301, USA.  */\n    is added to the compiler.  */\n #define LINK_SPEC \\\n   \"%{assert*} %{R*} %{rpath*} \\\n-   %{shared:%eThe -shared option is not currently supported for VAX ELF.} \\\n+   %{shared:%ethe -shared option is not currently supported for VAX ELF} \\\n    %{!shared: \\\n      -dc -dp \\\n      %{!nostdlib: \\"}, {"sha": "b1e2e5121b2681d48714f371a246633839703d49", "filename": "gcc/coverage.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab532386bd67549000dbe8db91d5fa3bf56239c7/gcc%2Fcoverage.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab532386bd67549000dbe8db91d5fa3bf56239c7/gcc%2Fcoverage.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoverage.c?ref=ab532386bd67549000dbe8db91d5fa3bf56239c7", "patch": "@@ -271,15 +271,15 @@ read_counts_file (void)\n \t    }\n \t  else if (entry->checksum != checksum)\n \t    {\n-\t      error (\"coverage mismatch for function %u while reading execution counters.\",\n+\t      error (\"coverage mismatch for function %u while reading execution counters\",\n \t\t     fn_ident);\n \t      error (\"checksum is %x instead of %x\", entry->checksum, checksum);\n \t      htab_delete (counts_hash);\n \t      break;\n \t    }\n \t  else if (entry->summary.num != n_counts)\n \t    {\n-\t      error (\"coverage mismatch for function %u while reading execution counters.\",\n+\t      error (\"coverage mismatch for function %u while reading execution counters\",\n \t\t     fn_ident);\n \t      error (\"number of counters is %d instead of %d\", entry->summary.num, n_counts);\n \t      htab_delete (counts_hash);\n@@ -345,23 +345,23 @@ get_coverage_counts (unsigned counter, unsigned expected,\n   entry = htab_find (counts_hash, &elt);\n   if (!entry)\n     {\n-      warning (0, \"no coverage for function %qs found.\", IDENTIFIER_POINTER\n+      warning (0, \"no coverage for function %qs found\", IDENTIFIER_POINTER\n \t       (DECL_ASSEMBLER_NAME (current_function_decl)));\n       return 0;\n     }\n \n   checksum = compute_checksum ();\n   if (entry->checksum != checksum)\n     {\n-      error (\"coverage mismatch for function %qs while reading counter %qs.\",\n+      error (\"coverage mismatch for function %qs while reading counter %qs\",\n \t     IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (current_function_decl)),\n \t     ctr_names[counter]);\n       error (\"checksum is %x instead of %x\", entry->checksum, checksum);\n       return 0;\n     }\n   else if (entry->summary.num != expected)\n     {\n-      error (\"coverage mismatch for function %qs while reading counter %qs.\",\n+      error (\"coverage mismatch for function %qs while reading counter %qs\",\n \t     IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (current_function_decl)),\n \t     ctr_names[counter]);\n       error (\"number of counters is %d instead of %d\", entry->summary.num, expected);"}, {"sha": "b120645ae280dde35e0e073aba87056a18f69996", "filename": "gcc/cse.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab532386bd67549000dbe8db91d5fa3bf56239c7/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab532386bd67549000dbe8db91d5fa3bf56239c7/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=ab532386bd67549000dbe8db91d5fa3bf56239c7", "patch": "@@ -6799,7 +6799,7 @@ cse_main (rtx f, int nregs, FILE *file)\n       max_qty = val.nsets * 2;\n \n       if (file)\n-\tfnotice (file, \";; Processing block from %d to %d, %d sets.\\n\",\n+\tfprintf (file, \";; Processing block from %d to %d, %d sets.\\n\",\n \t\t INSN_UID (insn), val.last ? INSN_UID (val.last) : 0,\n \t\t val.nsets);\n "}, {"sha": "e7c4adb5cdc760bd8bf4350e73cea3640321217d", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab532386bd67549000dbe8db91d5fa3bf56239c7/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab532386bd67549000dbe8db91d5fa3bf56239c7/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=ab532386bd67549000dbe8db91d5fa3bf56239c7", "patch": "@@ -3448,7 +3448,7 @@ get_cfa_from_loc_descr (dw_cfa_location *cfa, struct dw_loc_descr_struct *loc)\n \t  cfa->offset = ptr->dw_loc_oprnd1.v.val_unsigned;\n \t  break;\n \tdefault:\n-\t  internal_error (\"DW_LOC_OP %s not implemented\\n\",\n+\t  internal_error (\"DW_LOC_OP %s not implemented\",\n \t\t\t  dwarf_stack_op_name (ptr->dw_loc_opc));\n \t}\n     }"}, {"sha": "e9d3213a49132f7459c3f960afcf62b60d85e276", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab532386bd67549000dbe8db91d5fa3bf56239c7/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab532386bd67549000dbe8db91d5fa3bf56239c7/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=ab532386bd67549000dbe8db91d5fa3bf56239c7", "patch": "@@ -2198,11 +2198,11 @@ verify_rtx_sharing (rtx orig, rtx insn)\n #ifdef ENABLE_CHECKING\n   if (RTX_FLAG (x, used))\n     {\n-      error (\"Invalid rtl sharing found in the insn\");\n+      error (\"invalid rtl sharing found in the insn\");\n       debug_rtx (insn);\n-      error (\"Shared rtx\");\n+      error (\"shared rtx\");\n       debug_rtx (x);\n-      internal_error (\"Internal consistency failure\");\n+      internal_error (\"internal consistency failure\");\n     }\n #endif\n   gcc_assert (!RTX_FLAG (x, used));"}, {"sha": "1d7bcb67cb21a79ee07e9ebf9b8b682ab35bbbae", "filename": "gcc/except.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab532386bd67549000dbe8db91d5fa3bf56239c7/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab532386bd67549000dbe8db91d5fa3bf56239c7/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=ab532386bd67549000dbe8db91d5fa3bf56239c7", "patch": "@@ -3746,7 +3746,7 @@ verify_eh_tree (struct function *fun)\n \t      {\n \t\tif (depth != -1)\n \t\t  {\n-\t\t    error (\"Tree list ends on depth %i\", depth + 1);\n+\t\t    error (\"tree list ends on depth %i\", depth + 1);\n \t\t    err = true;\n \t\t  }\n \t\tif (count != nvisited)\n@@ -3757,7 +3757,7 @@ verify_eh_tree (struct function *fun)\n \t\tif (err)\n \t\t  {\n \t\t    dump_eh_tree (stderr, fun);\n-\t\t    internal_error (\"verify_eh_tree failed.\");\n+\t\t    internal_error (\"verify_eh_tree failed\");\n \t\t  }\n \t        return;\n \t      }"}, {"sha": "1530fc0c16f87c6cff5d795580acc09f4e9a4a82", "filename": "gcc/gcc.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab532386bd67549000dbe8db91d5fa3bf56239c7/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab532386bd67549000dbe8db91d5fa3bf56239c7/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=ab532386bd67549000dbe8db91d5fa3bf56239c7", "patch": "@@ -6156,7 +6156,7 @@ main (int argc, const char **argv)\n       && do_spec_2 (sysroot_suffix_spec) == 0)\n     {\n       if (argbuf_index > 1)\n-        error (\"spec failure: more than one arg to SYSROOT_SUFFIX_SPEC.\");\n+        error (\"spec failure: more than one arg to SYSROOT_SUFFIX_SPEC\");\n       else if (argbuf_index == 1)\n         target_sysroot_suffix = xstrdup (argbuf[argbuf_index -1]);\n     }\n@@ -6179,7 +6179,7 @@ main (int argc, const char **argv)\n       && do_spec_2 (sysroot_hdrs_suffix_spec) == 0)\n     {\n       if (argbuf_index > 1)\n-        error (\"spec failure: more than one arg to SYSROOT_HEADERS_SUFFIX_SPEC.\");\n+        error (\"spec failure: more than one arg to SYSROOT_HEADERS_SUFFIX_SPEC\");\n       else if (argbuf_index == 1)\n         target_sysroot_hdrs_suffix = xstrdup (argbuf[argbuf_index -1]);\n     }"}, {"sha": "f88b761512ebdef91f6215b53f38fcbc9f8daa75", "filename": "gcc/toplev.c", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab532386bd67549000dbe8db91d5fa3bf56239c7/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab532386bd67549000dbe8db91d5fa3bf56239c7/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=ab532386bd67549000dbe8db91d5fa3bf56239c7", "patch": "@@ -1093,19 +1093,25 @@ const char *const debug_type_names[] =\n void\n print_version (FILE *file, const char *indent)\n {\n-#ifndef __VERSION__\n-#define __VERSION__ \"[?]\"\n-#endif\n-  fnotice (file,\n+  static const char fmt1[] =\n #ifdef __GNUC__\n-\t   \"%s%s%s version %s (%s)\\n%s\\tcompiled by GNU C version %s.\\n\"\n+    N_(\"%s%s%s version %s (%s)\\n%s\\tcompiled by GNU C version %s.\\n\")\n #else\n-\t   \"%s%s%s version %s (%s) compiled by CC.\\n\"\n+    N_(\"%s%s%s version %s (%s) compiled by CC.\\n\")\n+#endif\n+    ;\n+  static const char fmt2[] =\n+    N_(\"%s%sGGC heuristics: --param ggc-min-expand=%d --param ggc-min-heapsize=%d\\n\");\n+#ifndef __VERSION__\n+#define __VERSION__ \"[?]\"\n #endif\n-\t   , indent, *indent != 0 ? \" \" : \"\",\n+  fprintf (file,\n+\t   file == stderr ? _(fmt1) : fmt1,\n+\t   indent, *indent != 0 ? \" \" : \"\",\n \t   lang_hooks.name, version_string, TARGET_NAME,\n \t   indent, __VERSION__);\n-  fnotice (file, \"%s%sGGC heuristics: --param ggc-min-expand=%d --param ggc-min-heapsize=%d\\n\",\n+  fprintf (file,\n+\t   file == stderr ? _(fmt2) : fmt2,\n \t   indent, *indent != 0 ? \" \" : \"\",\n \t   PARAM_VALUE (GGC_MIN_EXPAND), PARAM_VALUE (GGC_MIN_HEAPSIZE));\n }"}, {"sha": "8dd16ce844b99fd02842c647bf1b68dac2637a9d", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab532386bd67549000dbe8db91d5fa3bf56239c7/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab532386bd67549000dbe8db91d5fa3bf56239c7/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=ab532386bd67549000dbe8db91d5fa3bf56239c7", "patch": "@@ -3187,7 +3187,7 @@ verify_expr (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n \t}\n       if (!is_gimple_condexpr (x))\n         {\n-\t  error (\"Invalid conditional operand\");\n+\t  error (\"invalid conditional operand\");\n \t  return x;\n \t}\n       break;\n@@ -3204,7 +3204,7 @@ verify_expr (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n     case BIT_NOT_EXPR:\n     case NON_LVALUE_EXPR:\n     case TRUTH_NOT_EXPR:\n-      CHECK_OP (0, \"Invalid operand to unary operator\");\n+      CHECK_OP (0, \"invalid operand to unary operator\");\n       break;\n \n     case REALPART_EXPR:\n@@ -3221,28 +3221,28 @@ verify_expr (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n       while (handled_component_p (t))\n \t{\n \t  if (TREE_CODE (t) == COMPONENT_REF && TREE_OPERAND (t, 2))\n-\t    CHECK_OP (2, \"Invalid COMPONENT_REF offset operator\");\n+\t    CHECK_OP (2, \"invalid COMPONENT_REF offset operator\");\n \t  else if (TREE_CODE (t) == ARRAY_REF\n \t\t   || TREE_CODE (t) == ARRAY_RANGE_REF)\n \t    {\n-\t      CHECK_OP (1, \"Invalid array index.\");\n+\t      CHECK_OP (1, \"invalid array index\");\n \t      if (TREE_OPERAND (t, 2))\n-\t\tCHECK_OP (2, \"Invalid array lower bound.\");\n+\t\tCHECK_OP (2, \"invalid array lower bound\");\n \t      if (TREE_OPERAND (t, 3))\n-\t\tCHECK_OP (3, \"Invalid array stride.\");\n+\t\tCHECK_OP (3, \"invalid array stride\");\n \t    }\n \t  else if (TREE_CODE (t) == BIT_FIELD_REF)\n \t    {\n-\t      CHECK_OP (1, \"Invalid operand to BIT_FIELD_REF\");\n-\t      CHECK_OP (2, \"Invalid operand to BIT_FIELD_REF\");\n+\t      CHECK_OP (1, \"invalid operand to BIT_FIELD_REF\");\n+\t      CHECK_OP (2, \"invalid operand to BIT_FIELD_REF\");\n \t    }\n \n \t  t = TREE_OPERAND (t, 0);\n \t}\n \n       if (!CONSTANT_CLASS_P (t) && !is_gimple_lvalue (t))\n \t{\n-\t  error (\"Invalid reference prefix.\");\n+\t  error (\"invalid reference prefix\");\n \t  return t;\n \t}\n       *walk_subtrees = 0;\n@@ -3284,8 +3284,8 @@ verify_expr (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n     case BIT_IOR_EXPR:\n     case BIT_XOR_EXPR:\n     case BIT_AND_EXPR:\n-      CHECK_OP (0, \"Invalid operand to binary operator\");\n-      CHECK_OP (1, \"Invalid operand to binary operator\");\n+      CHECK_OP (0, \"invalid operand to binary operator\");\n+      CHECK_OP (1, \"invalid operand to binary operator\");\n       break;\n \n     default:\n@@ -3307,7 +3307,7 @@ verify_stmt (tree stmt, bool last_in_block)\n \n   if (!is_gimple_stmt (stmt))\n     {\n-      error (\"Is not a valid GIMPLE statement.\");\n+      error (\"is not a valid GIMPLE statement\");\n       goto fail;\n     }\n \n@@ -3327,12 +3327,12 @@ verify_stmt (tree stmt, bool last_in_block)\n     {\n       if (!tree_could_throw_p (stmt))\n \t{\n-\t  error (\"Statement marked for throw, but doesn%'t.\");\n+\t  error (\"statement marked for throw, but doesn%'t\");\n \t  goto fail;\n \t}\n       if (!last_in_block && tree_can_throw_internal (stmt))\n \t{\n-\t  error (\"Statement marked for throw in middle of block.\");\n+\t  error (\"statement marked for throw in middle of block\");\n \t  goto fail;\n \t}\n     }\n@@ -3427,7 +3427,7 @@ verify_stmts (void)\n \n \t  if (bb_for_stmt (phi) != bb)\n \t    {\n-\t      error (\"bb_for_stmt (phi) is set to a wrong basic block\\n\");\n+\t      error (\"bb_for_stmt (phi) is set to a wrong basic block\");\n \t      err |= true;\n \t    }\n \n@@ -3458,7 +3458,7 @@ verify_stmts (void)\n \t      addr = walk_tree (&t, verify_node_sharing, htab, NULL);\n \t      if (addr)\n \t\t{\n-\t\t  error (\"Incorrect sharing of tree nodes\");\n+\t\t  error (\"incorrect sharing of tree nodes\");\n \t\t  debug_generic_stmt (phi);\n \t\t  debug_generic_stmt (addr);\n \t\t  err |= true;\n@@ -3472,7 +3472,7 @@ verify_stmts (void)\n \n \t  if (bb_for_stmt (stmt) != bb)\n \t    {\n-\t      error (\"bb_for_stmt (stmt) is set to a wrong basic block\\n\");\n+\t      error (\"bb_for_stmt (stmt) is set to a wrong basic block\");\n \t      err |= true;\n \t    }\n \n@@ -3481,7 +3481,7 @@ verify_stmts (void)\n \t  addr = walk_tree (&stmt, verify_node_sharing, htab, NULL);\n \t  if (addr)\n \t    {\n-\t      error (\"Incorrect sharing of tree nodes\");\n+\t      error (\"incorrect sharing of tree nodes\");\n \t      debug_generic_stmt (stmt);\n \t      debug_generic_stmt (addr);\n \t      err |= true;\n@@ -3490,7 +3490,7 @@ verify_stmts (void)\n     }\n \n   if (err)\n-    internal_error (\"verify_stmts failed.\");\n+    internal_error (\"verify_stmts failed\");\n \n   htab_delete (htab);\n   timevar_pop (TV_TREE_STMT_VERIFY);\n@@ -3511,20 +3511,20 @@ tree_verify_flow_info (void)\n \n   if (ENTRY_BLOCK_PTR->stmt_list)\n     {\n-      error (\"ENTRY_BLOCK has a statement list associated with it\\n\");\n+      error (\"ENTRY_BLOCK has a statement list associated with it\");\n       err = 1;\n     }\n \n   if (EXIT_BLOCK_PTR->stmt_list)\n     {\n-      error (\"EXIT_BLOCK has a statement list associated with it\\n\");\n+      error (\"EXIT_BLOCK has a statement list associated with it\");\n       err = 1;\n     }\n \n   FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR->preds)\n     if (e->flags & EDGE_FALLTHRU)\n       {\n-\terror (\"Fallthru to exit from bb %d\\n\", e->src->index);\n+\terror (\"fallthru to exit from bb %d\", e->src->index);\n \terr = 1;\n       }\n \n@@ -3546,7 +3546,7 @@ tree_verify_flow_info (void)\n \n \t  if (prev_stmt && DECL_NONLOCAL (LABEL_EXPR_LABEL (stmt)))\n \t    {\n-\t      error (\"Nonlocal label %s is not first \"\n+\t      error (\"nonlocal label %s is not first \"\n \t\t     \"in a sequence of labels in bb %d\",\n \t\t     IDENTIFIER_POINTER (DECL_NAME (LABEL_EXPR_LABEL (stmt))),\n \t\t     bb->index);\n@@ -3555,7 +3555,7 @@ tree_verify_flow_info (void)\n \n \t  if (label_to_block (LABEL_EXPR_LABEL (stmt)) != bb)\n \t    {\n-\t      error (\"Label %s to block does not match in bb %d\\n\",\n+\t      error (\"label %s to block does not match in bb %d\",\n \t\t     IDENTIFIER_POINTER (DECL_NAME (LABEL_EXPR_LABEL (stmt))),\n \t\t     bb->index);\n \t      err = 1;\n@@ -3564,7 +3564,7 @@ tree_verify_flow_info (void)\n \t  if (decl_function_context (LABEL_EXPR_LABEL (stmt))\n \t      != current_function_decl)\n \t    {\n-\t      error (\"Label %s has incorrect context in bb %d\\n\",\n+\t      error (\"label %s has incorrect context in bb %d\",\n \t\t     IDENTIFIER_POINTER (DECL_NAME (LABEL_EXPR_LABEL (stmt))),\n \t\t     bb->index);\n \t      err = 1;\n@@ -3578,7 +3578,7 @@ tree_verify_flow_info (void)\n \n \t  if (found_ctrl_stmt)\n \t    {\n-\t      error (\"Control flow in the middle of basic block %d\\n\",\n+\t      error (\"control flow in the middle of basic block %d\",\n \t\t     bb->index);\n \t      err = 1;\n \t    }\n@@ -3588,7 +3588,7 @@ tree_verify_flow_info (void)\n \n \t  if (TREE_CODE (stmt) == LABEL_EXPR)\n \t    {\n-\t      error (\"Label %s in the middle of basic block %d\\n\",\n+\t      error (\"label %s in the middle of basic block %d\",\n \t\t     IDENTIFIER_POINTER (DECL_NAME (LABEL_EXPR_LABEL (stmt))),\n \t\t     bb->index);\n \t      err = 1;\n@@ -3607,7 +3607,7 @@ tree_verify_flow_info (void)\n \t  FOR_EACH_EDGE (e, ei, bb->succs)\n \t    if (e->flags & EDGE_FALLTHRU)\n \t      {\n-\t\terror (\"Fallthru edge after a control statement in bb %d \\n\",\n+\t\terror (\"fallthru edge after a control statement in bb %d\",\n \t\t       bb->index);\n \t\terr = 1;\n \t      }\n@@ -3622,7 +3622,7 @@ tree_verify_flow_info (void)\n \t    if (TREE_CODE (COND_EXPR_THEN (stmt)) != GOTO_EXPR\n \t\t|| TREE_CODE (COND_EXPR_ELSE (stmt)) != GOTO_EXPR)\n \t      {\n-\t\terror (\"Structured COND_EXPR at the end of bb %d\\n\", bb->index);\n+\t\terror (\"structured COND_EXPR at the end of bb %d\", bb->index);\n \t\terr = 1;\n \t      }\n \n@@ -3635,23 +3635,23 @@ tree_verify_flow_info (void)\n \t\t|| (false_edge->flags & (EDGE_FALLTHRU | EDGE_ABNORMAL))\n \t\t|| EDGE_COUNT (bb->succs) >= 3)\n \t      {\n-\t\terror (\"Wrong outgoing edge flags at end of bb %d\\n\",\n+\t\terror (\"wrong outgoing edge flags at end of bb %d\",\n \t\t       bb->index);\n \t\terr = 1;\n \t      }\n \n \t    if (!has_label_p (true_edge->dest,\n \t\t\t      GOTO_DESTINATION (COND_EXPR_THEN (stmt))))\n \t      {\n-\t\terror (\"%<then%> label does not match edge at end of bb %d\\n\",\n+\t\terror (\"%<then%> label does not match edge at end of bb %d\",\n \t\t       bb->index);\n \t\terr = 1;\n \t      }\n \n \t    if (!has_label_p (false_edge->dest,\n \t\t\t      GOTO_DESTINATION (COND_EXPR_ELSE (stmt))))\n \t      {\n-\t\terror (\"%<else%> label does not match edge at end of bb %d\\n\",\n+\t\terror (\"%<else%> label does not match edge at end of bb %d\",\n \t\t       bb->index);\n \t\terr = 1;\n \t      }\n@@ -3661,7 +3661,7 @@ tree_verify_flow_info (void)\n \tcase GOTO_EXPR:\n \t  if (simple_goto_p (stmt))\n \t    {\n-\t      error (\"Explicit goto at end of bb %d\\n\", bb->index);\n+\t      error (\"explicit goto at end of bb %d\", bb->index);\n     \t      err = 1;\n \t    }\n \t  else\n@@ -3673,7 +3673,7 @@ tree_verify_flow_info (void)\n \t\t\t\t | EDGE_FALSE_VALUE))\n \t\t    || !(e->flags & EDGE_ABNORMAL))\n \t\t  {\n-\t\t    error (\"Wrong outgoing edge flags at end of bb %d\\n\",\n+\t\t    error (\"wrong outgoing edge flags at end of bb %d\",\n \t\t\t   bb->index);\n \t\t    err = 1;\n \t\t  }\n@@ -3686,12 +3686,12 @@ tree_verify_flow_info (void)\n \t\t  & (EDGE_FALLTHRU | EDGE_ABNORMAL\n \t\t     | EDGE_TRUE_VALUE | EDGE_FALSE_VALUE)))\n \t    {\n-\t      error (\"Wrong outgoing edge flags at end of bb %d\\n\", bb->index);\n+\t      error (\"wrong outgoing edge flags at end of bb %d\", bb->index);\n \t      err = 1;\n \t    }\n \t  if (single_succ (bb) != EXIT_BLOCK_PTR)\n \t    {\n-\t      error (\"Return edge does not point to exit in bb %d\\n\",\n+\t      error (\"return edge does not point to exit in bb %d\",\n \t\t     bb->index);\n \t      err = 1;\n \t    }\n@@ -3724,13 +3724,13 @@ tree_verify_flow_info (void)\n \t\ttree c = TREE_VEC_ELT (vec, i);\n \t\tif (! CASE_LOW (c))\n \t\t  {\n-\t\t    error (\"Found default case not at end of case vector\");\n+\t\t    error (\"found default case not at end of case vector\");\n \t\t    err = 1;\n \t\t    continue;\n \t\t  }\n \t\tif (! tree_int_cst_lt (CASE_LOW (prev), CASE_LOW (c)))\n \t\t  {\n-\t\t    error (\"Case labels not sorted:\\n \");\n+\t\t    error (\"case labels not sorted:\");\n \t\t    print_generic_expr (stderr, prev, 0);\n \t\t    fprintf (stderr,\" is greater than \");\n \t\t    print_generic_expr (stderr, c, 0);\n@@ -3741,23 +3741,23 @@ tree_verify_flow_info (void)\n \t      }\n \t    if (CASE_LOW (TREE_VEC_ELT (vec, n - 1)))\n \t      {\n-\t\terror (\"No default case found at end of case vector\");\n+\t\terror (\"no default case found at end of case vector\");\n \t\terr = 1;\n \t      }\n \n \t    FOR_EACH_EDGE (e, ei, bb->succs)\n \t      {\n \t\tif (!e->dest->aux)\n \t\t  {\n-\t\t    error (\"Extra outgoing edge %d->%d\\n\",\n+\t\t    error (\"extra outgoing edge %d->%d\",\n \t\t\t   bb->index, e->dest->index);\n \t\t    err = 1;\n \t\t  }\n \t\te->dest->aux = (void *)2;\n \t\tif ((e->flags & (EDGE_FALLTHRU | EDGE_ABNORMAL\n \t\t\t\t | EDGE_TRUE_VALUE | EDGE_FALSE_VALUE)))\n \t\t  {\n-\t\t    error (\"Wrong outgoing edge flags at end of bb %d\\n\",\n+\t\t    error (\"wrong outgoing edge flags at end of bb %d\",\n \t\t\t   bb->index);\n \t\t    err = 1;\n \t\t  }\n@@ -3771,7 +3771,7 @@ tree_verify_flow_info (void)\n \n \t\tif (label_bb->aux != (void *)2)\n \t\t  {\n-\t\t    error (\"Missing edge %i->%i\",\n+\t\t    error (\"missing edge %i->%i\",\n \t\t\t   bb->index, label_bb->index);\n \t\t    err = 1;\n \t\t  }"}, {"sha": "76c7ef7a298f20a5ae084d4c2b0ac8ca4f168fd2", "filename": "gcc/tree-eh.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab532386bd67549000dbe8db91d5fa3bf56239c7/gcc%2Ftree-eh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab532386bd67549000dbe8db91d5fa3bf56239c7/gcc%2Ftree-eh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.c?ref=ab532386bd67549000dbe8db91d5fa3bf56239c7", "patch": "@@ -1764,18 +1764,18 @@ mark_eh_edge (struct eh_region *region, void *data)\n   e = find_edge (src, dst);\n   if (!e)\n     {\n-      error (\"EH edge %i->%i is missing.\", src->index, dst->index);\n+      error (\"EH edge %i->%i is missing\", src->index, dst->index);\n       mark_eh_edge_found_error = true;\n     }\n   else if (!(e->flags & EDGE_EH))\n     {\n-      error (\"EH edge %i->%i miss EH flag.\", src->index, dst->index);\n+      error (\"EH edge %i->%i miss EH flag\", src->index, dst->index);\n       mark_eh_edge_found_error = true;\n     }\n   else if (e->aux)\n     {\n       /* ??? might not be mistake.  */\n-      error (\"EH edge %i->%i has duplicated regions.\", src->index, dst->index);\n+      error (\"EH edge %i->%i has duplicated regions\", src->index, dst->index);\n       mark_eh_edge_found_error = true;\n     }\n   else\n@@ -1827,7 +1827,7 @@ verify_eh_edges (tree stmt)\n     {\n       if ((e->flags & EDGE_EH) && !e->aux)\n \t{\n-\t  error (\"Unnecessary EH edge %i->%i\", bb->index, e->dest->index);\n+\t  error (\"unnecessary EH edge %i->%i\", bb->index, e->dest->index);\n \t  mark_eh_edge_found_error = true;\n \t  return true;\n \t}"}, {"sha": "c88030db358f6e0c8abec371b506a7dd19adf4b2", "filename": "gcc/tree-ssa.c", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab532386bd67549000dbe8db91d5fa3bf56239c7/gcc%2Ftree-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab532386bd67549000dbe8db91d5fa3bf56239c7/gcc%2Ftree-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.c?ref=ab532386bd67549000dbe8db91d5fa3bf56239c7", "patch": "@@ -108,38 +108,38 @@ verify_ssa_name (tree ssa_name, bool is_virtual)\n {\n   if (TREE_CODE (ssa_name) != SSA_NAME)\n     {\n-      error (\"Expected an SSA_NAME object\");\n+      error (\"expected an SSA_NAME object\");\n       return true;\n     }\n \n   if (TREE_TYPE (ssa_name) != TREE_TYPE (SSA_NAME_VAR (ssa_name)))\n     {\n-      error (\"Type mismatch between an SSA_NAME and its symbol.\");\n+      error (\"type mismatch between an SSA_NAME and its symbol\");\n       return true;\n     }\n \n   if (SSA_NAME_IN_FREE_LIST (ssa_name))\n     {\n-      error (\"Found an SSA_NAME that had been released into the free pool\");\n+      error (\"found an SSA_NAME that had been released into the free pool\");\n       return true;\n     }\n \n   if (is_virtual && is_gimple_reg (ssa_name))\n     {\n-      error (\"Found a virtual definition for a GIMPLE register\");\n+      error (\"found a virtual definition for a GIMPLE register\");\n       return true;\n     }\n \n   if (!is_virtual && !is_gimple_reg (ssa_name))\n     {\n-      error (\"Found a real definition for a non-register\");\n+      error (\"found a real definition for a non-register\");\n       return true;\n     }\n \n   if (is_virtual && var_ann (SSA_NAME_VAR (ssa_name)) \n       && get_subvars_for_var (SSA_NAME_VAR (ssa_name)) != NULL)\n     {\n-      error (\"Found real variable when subvariables should have appeared\");\n+      error (\"found real variable when subvariables should have appeared\");\n       return true;\n     }\n \n@@ -235,21 +235,21 @@ verify_use (basic_block bb, basic_block def_bb, use_operand_p use_p,\n     ; /* Default definitions have empty statements.  Nothing to do.  */\n   else if (!def_bb)\n     {\n-      error (\"Missing definition\");\n+      error (\"missing definition\");\n       err = true;\n     }\n   else if (bb != def_bb\n \t   && !dominated_by_p (CDI_DOMINATORS, bb, def_bb))\n     {\n-      error (\"Definition in block %i does not dominate use in block %i\",\n+      error (\"definition in block %i does not dominate use in block %i\",\n \t     def_bb->index, bb->index);\n       err = true;\n     }\n   else if (bb == def_bb\n \t   && names_defined_in_bb != NULL\n \t   && !bitmap_bit_p (names_defined_in_bb, SSA_NAME_VERSION (ssa_name)))\n     {\n-      error (\"Definition in block %i follows the use\", def_bb->index);\n+      error (\"definition in block %i follows the use\", def_bb->index);\n       err = true;\n     }\n \n@@ -264,7 +264,7 @@ verify_use (basic_block bb, basic_block def_bb, use_operand_p use_p,\n      element to make sure it's the same.  */\n   if (use_p->prev == NULL)\n     {\n-      error (\"No immediate_use list\");\n+      error (\"no immediate_use list\");\n       err = true;\n     }\n   else\n@@ -276,7 +276,7 @@ verify_use (basic_block bb, basic_block def_bb, use_operand_p use_p,\n \tlistvar = USE_FROM_PTR (use_p->prev);\n       if (listvar != ssa_name)\n         {\n-\t  error (\"Wrong immediate use list\");\n+\t  error (\"wrong immediate use list\");\n \t  err = true;\n \t}\n     }\n@@ -309,7 +309,7 @@ verify_phi_args (tree phi, basic_block bb, basic_block *definition_block)\n \n   if (EDGE_COUNT (bb->preds) != phi_num_args)\n     {\n-      error (\"Incoming edge count does not match number of PHI arguments\\n\");\n+      error (\"incoming edge count does not match number of PHI arguments\");\n       err = true;\n       goto error;\n     }\n@@ -324,7 +324,7 @@ verify_phi_args (tree phi, basic_block bb, basic_block *definition_block)\n \n       if (op == NULL_TREE)\n \t{\n-\t  error (\"PHI argument is missing for edge %d->%d\\n\",\n+\t  error (\"PHI argument is missing for edge %d->%d\",\n \t         e->src->index,\n \t\t e->dest->index);\n \t  err = true;\n@@ -345,7 +345,7 @@ verify_phi_args (tree phi, basic_block bb, basic_block *definition_block)\n \n       if (e->dest != bb)\n \t{\n-\t  error (\"Wrong edge %d->%d for PHI argument\\n\",\n+\t  error (\"wrong edge %d->%d for PHI argument\",\n \t         e->src->index, e->dest->index);\n \t  err = true;\n \t}\n@@ -394,7 +394,7 @@ verify_flow_insensitive_alias_info (void)\n \n \t  if (!may_be_aliased (alias))\n \t    {\n-\t      error (\"Non-addressable variable inside an alias set.\");\n+\t      error (\"non-addressable variable inside an alias set\");\n \t      debug_variable (alias);\n \t      goto err;\n \t    }\n@@ -410,7 +410,7 @@ verify_flow_insensitive_alias_info (void)\n \t  && ann->is_alias_tag\n \t  && !bitmap_bit_p (visited, DECL_UID (var)))\n \t{\n-\t  error (\"Addressable variable that is an alias tag but is not in any alias set.\");\n+\t  error (\"addressable variable that is an alias tag but is not in any alias set\");\n \t  goto err;\n \t}\n     }\n@@ -420,7 +420,7 @@ verify_flow_insensitive_alias_info (void)\n \n err:\n   debug_variable (var);\n-  internal_error (\"verify_flow_insensitive_alias_info failed.\");\n+  internal_error (\"verify_flow_insensitive_alias_info failed\");\n }\n \n \n@@ -462,23 +462,23 @@ verify_flow_sensitive_alias_info (void)\n       ann = var_ann (var);\n       if (pi->is_dereferenced && !pi->name_mem_tag && !ann->type_mem_tag)\n \t{\n-\t  error (\"Dereferenced pointers should have a name or a type tag\");\n+\t  error (\"dereferenced pointers should have a name or a type tag\");\n \t  goto err;\n \t}\n \n       if (pi->name_mem_tag\n \t  && !pi->pt_malloc\n \t  && (pi->pt_vars == NULL || bitmap_empty_p (pi->pt_vars)))\n \t{\n-\t  error (\"Pointers with a memory tag, should have points-to sets or point to malloc\");\n+\t  error (\"pointers with a memory tag, should have points-to sets or point to malloc\");\n \t  goto err;\n \t}\n \n       if (pi->value_escapes_p\n \t  && pi->name_mem_tag\n \t  && !is_call_clobbered (pi->name_mem_tag))\n \t{\n-\t  error (\"Pointer escapes but its name tag is not call-clobbered.\");\n+\t  error (\"pointer escapes but its name tag is not call-clobbered\");\n \t  goto err;\n \t}\n     }\n@@ -487,7 +487,7 @@ verify_flow_sensitive_alias_info (void)\n \n err:\n   debug_variable (ptr);\n-  internal_error (\"verify_flow_sensitive_alias_info failed.\");\n+  internal_error (\"verify_flow_sensitive_alias_info failed\");\n }\n \n DEF_VEC_P (bitmap);\n@@ -564,7 +564,7 @@ verify_name_tags (void)\n \n \t  if (!bitmap_intersect_compl_p (type_aliases, pi->pt_vars))\n \t    {\n-\t      error (\"Alias set of a pointer's type tag should be a superset of the corresponding name tag\");\n+\t      error (\"alias set of a pointer's type tag should be a superset of the corresponding name tag\");\n \t      debug_variable (tmt);\n \t      debug_variable (pi->name_mem_tag);\n \t      goto err;\n@@ -580,7 +580,7 @@ verify_name_tags (void)\n \t { \n \t   if (bitmap_equal_p (first, second))\n \t     {\n-\t       error (\"Two different pointers with identical points-to sets but different name tags\");\n+\t       error (\"two different pointers with identical points-to sets but different name tags\");\n \t       debug_variable (VEC_index (tree, name_tag_reps, j));\n \t       goto err;\n \t     }\n@@ -683,7 +683,7 @@ verify_ssa (bool check_modified_stmt)\n \t{\n \t  if (e->aux)\n \t    {\n-\t      error (\"AUX pointer initialized for edge %d->%d\\n\", e->src->index,\n+\t      error (\"AUX pointer initialized for edge %d->%d\", e->src->index,\n \t\t      e->dest->index);\n \t      goto err;\n \t    }\n@@ -706,7 +706,7 @@ verify_ssa (bool check_modified_stmt)\n \n \t  if (check_modified_stmt && stmt_modified_p (stmt))\n \t    {\n-\t      error (\"Stmt (%p) marked modified after optimization pass : \",\n+\t      error (\"stmt (%p) marked modified after optimization pass : \",\n \t\t     (void *)stmt);\n \t      print_generic_stmt (stderr, stmt, TDF_VOPS);\n \t      goto err;\n@@ -724,7 +724,7 @@ verify_ssa (bool check_modified_stmt)\n \t\t  && SSA_VAR_P (base_address)\n \t\t  && ZERO_SSA_OPERANDS (stmt, SSA_OP_VMAYDEF|SSA_OP_VMUSTDEF))\n \t\t{\n-\t\t  error (\"Statement makes a memory store, but has no \"\n+\t\t  error (\"statement makes a memory store, but has no \"\n \t\t\t \"V_MAY_DEFS nor V_MUST_DEFS\");\n \t\t  print_generic_stmt (stderr, stmt, TDF_VOPS);\n \t\t  goto err;\n@@ -735,7 +735,7 @@ verify_ssa (bool check_modified_stmt)\n \t  if (stmt_ann (stmt)->makes_aliased_stores \n \t      && ZERO_SSA_OPERANDS (stmt, SSA_OP_VMAYDEF))\n \t    {\n-\t      error (\"Statement makes aliased stores, but has no V_MAY_DEFS\");\n+\t      error (\"statement makes aliased stores, but has no V_MAY_DEFS\");\n \t      print_generic_stmt (stderr, stmt, TDF_VOPS);\n \t      goto err;\n \t    }\n@@ -774,7 +774,7 @@ verify_ssa (bool check_modified_stmt)\n   return;\n \n err:\n-  internal_error (\"verify_ssa failed.\");\n+  internal_error (\"verify_ssa failed\");\n }\n \n /* Return true if the uid in both int tree maps are equal.  */"}, {"sha": "24abe6d05f2aafdf8e09245c7b23fc669d15947a", "filename": "gcc/xcoffout.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab532386bd67549000dbe8db91d5fa3bf56239c7/gcc%2Fxcoffout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab532386bd67549000dbe8db91d5fa3bf56239c7/gcc%2Fxcoffout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fxcoffout.c?ref=ab532386bd67549000dbe8db91d5fa3bf56239c7", "patch": "@@ -184,7 +184,7 @@ xcoff_assign_fundamental_type_number (tree decl)\n /* Print an error message for unrecognized stab codes.  */\n \n #define UNKNOWN_STAB(STR)\t\\\n-  internal_error (\"no sclass for %s stab (0x%x)\\n\", STR, stab)\n+  internal_error (\"no sclass for %s stab (0x%x)\", STR, stab)\n \n /* Conversion routine from BSD stabs to AIX storage classes.  */\n "}]}