{"sha": "350b0e595144cf7c6cf70807b429d87077173415", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzUwYjBlNTk1MTQ0Y2Y3YzZjZjcwODA3YjQyOWQ4NzA3NzE3MzQxNQ==", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-06-16T16:50:03Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-06-16T16:50:03Z"}, "message": "Merge #495\n\n495: HIR cleanup r=philberty a=philberty\n\nThe HIR implementation has been bootstrapped from the AST, this has lead to a lot of missed desugaring. This PR removes TraitImpls and refactors the InerhentImpls to be an ImplBlock. The class hierarchy has been simplified in tandem here such that all impl items are of the same base class.\r\n\r\nMore cleanup is required but this is an isolated change that can go in now.\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>", "tree": {"sha": "eb920e6388e9d782bab2efc195f9c15e6edab20b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eb920e6388e9d782bab2efc195f9c15e6edab20b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/350b0e595144cf7c6cf70807b429d87077173415", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgyiu7CRBK7hj4Ov3rIwAAQnUIAA8N++IcnFD7Y4u67T9Z3UeQ\nXggoiGyE2cslqmG2EXhC0IUJ3c5052T8M+0qVFJxiuXkROtoL+F6m+5CQFT92Qxa\nVy3srl1ltvkG0sqJXrA3vhUwQ7QsPZjDB/CfyvI3ar5J4sfn8x1qnWBFM0626nR5\njCBqvz5wvVAD476wXDF1UKFW+lqdSPUXhhEJWGGq3a/rWoI+N3wlndjYKTOtj3aK\nmpOYL+ROZPeSa6XD8oHtoP/vfX4oSgD4imc/SQ4RT12iNoGntRHHTLZJKK8zNmrs\nmb+d0wnsZQhZ9vvisY0Bo31dMe8MXc960btmVT4spD/3542gBRVKVWA04+uwdII=\n=BKD6\n-----END PGP SIGNATURE-----\n", "payload": "tree eb920e6388e9d782bab2efc195f9c15e6edab20b\nparent 59f09fd5a48046ceba064bde2f230386fbc3700f\nparent 9d9ba03360721158e2000f19f6f65896f5af88b0\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1623862203 +0000\ncommitter GitHub <noreply@github.com> 1623862203 +0000\n\nMerge #495\n\n495: HIR cleanup r=philberty a=philberty\n\nThe HIR implementation has been bootstrapped from the AST, this has lead to a lot of missed desugaring. This PR removes TraitImpls and refactors the InerhentImpls to be an ImplBlock. The class hierarchy has been simplified in tandem here such that all impl items are of the same base class.\r\n\r\nMore cleanup is required but this is an isolated change that can go in now.\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/350b0e595144cf7c6cf70807b429d87077173415", "html_url": "https://github.com/Rust-GCC/gccrs/commit/350b0e595144cf7c6cf70807b429d87077173415", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/350b0e595144cf7c6cf70807b429d87077173415/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "59f09fd5a48046ceba064bde2f230386fbc3700f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59f09fd5a48046ceba064bde2f230386fbc3700f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/59f09fd5a48046ceba064bde2f230386fbc3700f"}, {"sha": "9d9ba03360721158e2000f19f6f65896f5af88b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d9ba03360721158e2000f19f6f65896f5af88b0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9d9ba03360721158e2000f19f6f65896f5af88b0"}], "stats": {"total": 959, "additions": 263, "deletions": 696}, "files": [{"sha": "232d5b94b7c5a3f0e0b9f0440a5888b82efdd771", "filename": "gcc/rust/backend/rust-compile-base.h", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/350b0e595144cf7c6cf70807b429d87077173415/gcc%2Frust%2Fbackend%2Frust-compile-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/350b0e595144cf7c6cf70807b429d87077173415/gcc%2Frust%2Fbackend%2Frust-compile-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-base.h?ref=350b0e595144cf7c6cf70807b429d87077173415", "patch": "@@ -147,9 +147,8 @@ class HIRCompileBase : public HIR::HIRVisitor\n   virtual void visit (HIR::TraitItemConst &item) {}\n   virtual void visit (HIR::TraitItemType &item) {}\n   virtual void visit (HIR::Trait &trait) {}\n-  virtual void visit (HIR::InherentImpl &impl) {}\n-  virtual void visit (HIR::TraitImpl &impl) {}\n-  // virtual void visit(ExternalItem& item) {}\n+  virtual void visit (HIR::ImplBlock &impl) {}\n+\n   virtual void visit (HIR::ExternalStaticItem &item) {}\n   virtual void visit (HIR::ExternalFunctionItem &item) {}\n   virtual void visit (HIR::ExternBlock &block) {}"}, {"sha": "d6698d1800ac153d5579ec0dbc98acb0c9ecb934", "filename": "gcc/rust/backend/rust-compile-implitem.h", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/350b0e595144cf7c6cf70807b429d87077173415/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/350b0e595144cf7c6cf70807b429d87077173415/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h?ref=350b0e595144cf7c6cf70807b429d87077173415", "patch": "@@ -34,17 +34,8 @@ class CompileInherentImplItem : public HIRCompileBase\n   using Rust::Compile::HIRCompileBase::visit;\n \n public:\n-  static void Compile (TyTy::BaseType *self, HIR::InherentImplItem *item,\n-\t\t       Context *ctx, bool compile_fns,\n-\t\t       TyTy::BaseType *concrete = nullptr)\n-  {\n-    CompileInherentImplItem compiler (self, ctx, compile_fns, concrete);\n-    item->accept_vis (compiler);\n-  }\n-\n-  static void Compile (TyTy::BaseType *self, HIR::TraitImplItem *item,\n-\t\t       Context *ctx, bool compile_fns,\n-\t\t       TyTy::BaseType *concrete = nullptr)\n+  static void Compile (TyTy::BaseType *self, HIR::ImplItem *item, Context *ctx,\n+\t\t       bool compile_fns, TyTy::BaseType *concrete = nullptr)\n   {\n     CompileInherentImplItem compiler (self, ctx, compile_fns, concrete);\n     item->accept_vis (compiler);"}, {"sha": "8a521e714fcbee42723f91ae59164dc1125f1914", "filename": "gcc/rust/backend/rust-compile-item.h", "status": "modified", "additions": 1, "deletions": 17, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/350b0e595144cf7c6cf70807b429d87077173415/gcc%2Frust%2Fbackend%2Frust-compile-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/350b0e595144cf7c6cf70807b429d87077173415/gcc%2Frust%2Fbackend%2Frust-compile-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-item.h?ref=350b0e595144cf7c6cf70807b429d87077173415", "patch": "@@ -274,23 +274,7 @@ class CompileItem : public HIRCompileBase\n     ctx->push_function (fndecl);\n   }\n \n-  void visit (HIR::InherentImpl &impl_block) override\n-  {\n-    TyTy::BaseType *self_lookup = nullptr;\n-    if (!ctx->get_tyctx ()->lookup_type (\n-\t  impl_block.get_type ()->get_mappings ().get_hirid (), &self_lookup))\n-      {\n-\trust_error_at (impl_block.get_locus (),\n-\t\t       \"failed to resolve type of impl\");\n-\treturn;\n-      }\n-\n-    for (auto &impl_item : impl_block.get_impl_items ())\n-      CompileInherentImplItem::Compile (self_lookup, impl_item.get (), ctx,\n-\t\t\t\t\tcompile_fns);\n-  }\n-\n-  void visit (HIR::TraitImpl &impl_block) override\n+  void visit (HIR::ImplBlock &impl_block) override\n   {\n     TyTy::BaseType *self_lookup = nullptr;\n     if (!ctx->get_tyctx ()->lookup_type ("}, {"sha": "cb1cfcf2d2585a0a0110dcec129b25591752bf5f", "filename": "gcc/rust/backend/rust-compile-resolve-path.cc", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/350b0e595144cf7c6cf70807b429d87077173415/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/350b0e595144cf7c6cf70807b429d87077173415/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc?ref=350b0e595144cf7c6cf70807b429d87077173415", "patch": "@@ -91,7 +91,7 @@ ResolvePathRef::visit (HIR::PathInExpression &expr)\n       else\n \t{\n \t  HirId parent_impl_id = UNKNOWN_HIRID;\n-\t  HIR::InherentImplItem *resolved_item\n+\t  HIR::ImplItem *resolved_item\n \t    = ctx->get_mappings ()->lookup_hir_implitem (\n \t      expr.get_mappings ().get_crate_num (), ref, &parent_impl_id);\n \t  if (resolved_item != nullptr)\n@@ -100,8 +100,7 @@ ResolvePathRef::visit (HIR::PathInExpression &expr)\n \t      HIR::Item *impl_ref = ctx->get_mappings ()->lookup_hir_item (\n \t\texpr.get_mappings ().get_crate_num (), parent_impl_id);\n \t      rust_assert (impl_ref != nullptr);\n-\t      HIR::InherentImpl *impl\n-\t\t= static_cast<HIR::InherentImpl *> (impl_ref);\n+\t      HIR::ImplBlock *impl = static_cast<HIR::ImplBlock *> (impl_ref);\n \n \t      TyTy::BaseType *self = nullptr;\n \t      bool ok = ctx->get_tyctx ()->lookup_type ("}, {"sha": "77036b21f43fc2e56bb14f1fd85d0a58c7b6a810", "filename": "gcc/rust/backend/rust-compile.cc", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/350b0e595144cf7c6cf70807b429d87077173415/gcc%2Frust%2Fbackend%2Frust-compile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/350b0e595144cf7c6cf70807b429d87077173415/gcc%2Frust%2Fbackend%2Frust-compile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile.cc?ref=350b0e595144cf7c6cf70807b429d87077173415", "patch": "@@ -137,9 +137,8 @@ CompileExpr::visit (HIR::MethodCallExpr &expr)\n     {\n       // this might fail because its a forward decl so we can attempt to\n       // resolve it now\n-      HIR::InherentImplItem *resolved_item\n-\t= ctx->get_mappings ()->lookup_hir_implitem (\n-\t  expr.get_mappings ().get_crate_num (), ref, nullptr);\n+      HIR::ImplItem *resolved_item = ctx->get_mappings ()->lookup_hir_implitem (\n+\texpr.get_mappings ().get_crate_num (), ref, nullptr);\n       if (resolved_item == nullptr)\n \t{\n \t  rust_error_at (expr.get_locus (), \"failed to lookup forward decl\");"}, {"sha": "4479d14383e3fa72578f06c3678a08998297a353", "filename": "gcc/rust/hir/rust-ast-lower-implitem.h", "status": "modified", "additions": 8, "deletions": 14, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/350b0e595144cf7c6cf70807b429d87077173415/gcc%2Frust%2Fhir%2Frust-ast-lower-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/350b0e595144cf7c6cf70807b429d87077173415/gcc%2Frust%2Fhir%2Frust-ast-lower-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-implitem.h?ref=350b0e595144cf7c6cf70807b429d87077173415", "patch": "@@ -34,23 +34,22 @@ class ASTLowerImplItem : public ASTLoweringBase\n   using Rust::HIR::ASTLoweringBase::visit;\n \n public:\n-  static HIR::InherentImplItem *translate (AST::InherentImplItem *item,\n-\t\t\t\t\t   HirId parent_impl_id)\n+  static HIR::ImplItem *translate (AST::InherentImplItem *item,\n+\t\t\t\t   HirId parent_impl_id)\n   {\n     ASTLowerImplItem resolver (parent_impl_id);\n     item->accept_vis (resolver);\n     rust_assert (resolver.translated != nullptr);\n     return resolver.translated;\n   }\n \n-  static HIR::TraitImplItem *translate (AST::TraitImplItem *item,\n-\t\t\t\t\tHirId parent_impl_id)\n+  static HIR::ImplItem *translate (AST::TraitImplItem *item,\n+\t\t\t\t   HirId parent_impl_id)\n   {\n     ASTLowerImplItem resolver (parent_impl_id);\n     item->accept_vis (resolver);\n-    rust_assert (resolver.trait_impl_item != nullptr);\n-    // can get a way with this for now since they have the same hierarchy\n-    return resolver.trait_impl_item;\n+    rust_assert (resolver.translated != nullptr);\n+    return resolver.translated;\n   }\n \n   void visit (AST::ConstantItem &constant) override\n@@ -72,7 +71,6 @@ class ASTLowerImplItem : public ASTLoweringBase\n \t\t\t       constant.get_outer_attrs (),\n \t\t\t       constant.get_locus ());\n     translated = translated_constant;\n-    trait_impl_item = translated_constant;\n \n     mappings->insert_hir_implitem (mapping.get_crate_num (),\n \t\t\t\t   mapping.get_hirid (), parent_impl_id,\n@@ -161,7 +159,6 @@ class ASTLowerImplItem : public ASTLoweringBase\n       }\n \n     translated = fn;\n-    trait_impl_item = fn;\n   }\n \n   void visit (AST::Method &method) override\n@@ -250,17 +247,14 @@ class ASTLowerImplItem : public ASTLoweringBase\n       }\n \n     translated = mth;\n-    trait_impl_item = mth;\n   }\n \n private:\n   ASTLowerImplItem (HirId parent_impl_id)\n-    : translated (nullptr), trait_impl_item (nullptr),\n-      parent_impl_id (parent_impl_id)\n+    : translated (nullptr), parent_impl_id (parent_impl_id)\n   {}\n \n-  HIR::InherentImplItem *translated;\n-  HIR::TraitImplItem *trait_impl_item;\n+  HIR::ImplItem *translated;\n   HirId parent_impl_id;\n };\n "}, {"sha": "bb9f764ca440a36eefb8e36f0374c321275857df", "filename": "gcc/rust/hir/rust-ast-lower-item.h", "status": "modified", "additions": 28, "deletions": 29, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/350b0e595144cf7c6cf70807b429d87077173415/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/350b0e595144cf7c6cf70807b429d87077173415/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h?ref=350b0e595144cf7c6cf70807b429d87077173415", "patch": "@@ -365,32 +365,33 @@ class ASTLoweringItem : public ASTLoweringBase\n \t  }\n       }\n \n-    HIR::Type *trait_type\n+    HIR::Type *impl_type\n       = ASTLoweringType::translate (impl_block.get_type ().get ());\n \n     auto crate_num = mappings->get_current_crate ();\n     Analysis::NodeMapping mapping (crate_num, impl_block.get_node_id (),\n \t\t\t\t   mappings->get_next_hir_id (crate_num),\n \t\t\t\t   mappings->get_next_localdef_id (crate_num));\n \n-    std::vector<std::unique_ptr<HIR::InherentImplItem> > impl_items;\n+    std::vector<std::unique_ptr<HIR::ImplItem> > impl_items;\n     std::vector<HirId> impl_item_ids;\n     for (auto &impl_item : impl_block.get_impl_items ())\n       {\n-\tHIR::InherentImplItem *lowered\n+\tHIR::ImplItem *lowered\n \t  = ASTLowerImplItem::translate (impl_item.get (),\n \t\t\t\t\t mapping.get_hirid ());\n-\timpl_items.push_back (std::unique_ptr<HIR::InherentImplItem> (lowered));\n+\timpl_items.push_back (std::unique_ptr<HIR::ImplItem> (lowered));\n \timpl_item_ids.push_back (lowered->get_impl_mappings ().get_hirid ());\n       }\n \n-    translated\n-      = new HIR::InherentImpl (mapping, std::move (impl_items),\n-\t\t\t       std::move (generic_params),\n-\t\t\t       std::unique_ptr<HIR::Type> (trait_type),\n-\t\t\t       where_clause, vis, impl_block.get_inner_attrs (),\n-\t\t\t       impl_block.get_outer_attrs (),\n-\t\t\t       impl_block.get_locus ());\n+    HIR::ImplBlock *hir_impl_block\n+      = new HIR::ImplBlock (mapping, std::move (impl_items),\n+\t\t\t    std::move (generic_params),\n+\t\t\t    std::unique_ptr<HIR::Type> (impl_type), nullptr,\n+\t\t\t    where_clause, vis, impl_block.get_inner_attrs (),\n+\t\t\t    impl_block.get_outer_attrs (),\n+\t\t\t    impl_block.get_locus ());\n+    translated = hir_impl_block;\n \n     mappings->insert_defid_mapping (mapping.get_defid (), translated);\n     mappings->insert_hir_item (mapping.get_crate_num (), mapping.get_hirid (),\n@@ -400,9 +401,7 @@ class ASTLoweringItem : public ASTLoweringBase\n \n     for (auto &impl_item_id : impl_item_ids)\n       {\n-\tmappings->insert_impl_item_mapping (impl_item_id,\n-\t\t\t\t\t    static_cast<HIR::InherentImpl *> (\n-\t\t\t\t\t      translated));\n+\tmappings->insert_impl_item_mapping (impl_item_id, hir_impl_block);\n       }\n   }\n \n@@ -472,6 +471,7 @@ class ASTLoweringItem : public ASTLoweringBase\n   void visit (AST::TraitImpl &impl_block) override\n   {\n     std::vector<std::unique_ptr<HIR::WhereClauseItem> > where_clause_items;\n+\n     HIR::WhereClause where_clause (std::move (where_clause_items));\n     HIR::Visibility vis = HIR::Visibility::create_public ();\n \n@@ -505,35 +505,36 @@ class ASTLoweringItem : public ASTLoweringBase\n \t  }\n       }\n \n-    HIR::Type *trait_type\n+    HIR::Type *impl_type\n       = ASTLoweringType::translate (impl_block.get_type ().get ());\n-    HIR::Type *trait = nullptr;\n+    HIR::TypePath *trait_ref\n+      = ASTLowerTypePath::translate (impl_block.get_trait_path ());\n \n     auto crate_num = mappings->get_current_crate ();\n     Analysis::NodeMapping mapping (crate_num, impl_block.get_node_id (),\n \t\t\t\t   mappings->get_next_hir_id (crate_num),\n \t\t\t\t   mappings->get_next_localdef_id (crate_num));\n \n-    std::vector<std::unique_ptr<HIR::TraitImplItem> > impl_items;\n+    std::vector<std::unique_ptr<HIR::ImplItem> > impl_items;\n     std::vector<HirId> impl_item_ids;\n     for (auto &impl_item : impl_block.get_impl_items ())\n       {\n-\tHIR::TraitImplItem *lowered\n+\tHIR::ImplItem *lowered\n \t  = ASTLowerImplItem::translate (impl_item.get (),\n \t\t\t\t\t mapping.get_hirid ());\n-\timpl_items.push_back (std::unique_ptr<HIR::TraitImplItem> (lowered));\n-\timpl_item_ids.push_back (\n-\t  lowered->get_trait_impl_mappings ().get_hirid ());\n+\timpl_items.push_back (std::unique_ptr<HIR::ImplItem> (lowered));\n+\timpl_item_ids.push_back (lowered->get_impl_mappings ().get_hirid ());\n       }\n \n-    translated\n-      = new HIR::TraitImpl (mapping, std::unique_ptr<HIR::Type> (trait),\n-\t\t\t    impl_block.is_unsafe (), impl_block.is_exclam (),\n-\t\t\t    std::move (impl_items), std::move (generic_params),\n-\t\t\t    std::unique_ptr<HIR::Type> (trait_type),\n+    HIR::ImplBlock *hir_impl_block\n+      = new HIR::ImplBlock (mapping, std::move (impl_items),\n+\t\t\t    std::move (generic_params),\n+\t\t\t    std::unique_ptr<HIR::Type> (impl_type),\n+\t\t\t    std::unique_ptr<HIR::TypePath> (trait_ref),\n \t\t\t    where_clause, vis, impl_block.get_inner_attrs (),\n \t\t\t    impl_block.get_outer_attrs (),\n \t\t\t    impl_block.get_locus ());\n+    translated = hir_impl_block;\n \n     mappings->insert_defid_mapping (mapping.get_defid (), translated);\n     mappings->insert_hir_item (mapping.get_crate_num (), mapping.get_hirid (),\n@@ -543,9 +544,7 @@ class ASTLoweringItem : public ASTLoweringBase\n \n     for (auto &impl_item_id : impl_item_ids)\n       {\n-\tmappings->insert_impl_item_mapping (impl_item_id,\n-\t\t\t\t\t    static_cast<HIR::InherentImpl *> (\n-\t\t\t\t\t      translated));\n+\tmappings->insert_impl_item_mapping (impl_item_id, hir_impl_block);\n       }\n   }\n "}, {"sha": "86e802e0fa96a1cf0f3a3417441419fd3b093ed8", "filename": "gcc/rust/hir/rust-ast-lower-type.h", "status": "modified", "additions": 64, "deletions": 67, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/350b0e595144cf7c6cf70807b429d87077173415/gcc%2Frust%2Fhir%2Frust-ast-lower-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/350b0e595144cf7c6cf70807b429d87077173415/gcc%2Frust%2Fhir%2Frust-ast-lower-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-type.h?ref=350b0e595144cf7c6cf70807b429d87077173415", "patch": "@@ -26,6 +26,68 @@\n namespace Rust {\n namespace HIR {\n \n+class ASTLowerTypePath : public ASTLoweringBase\n+{\n+  using Rust::HIR::ASTLoweringBase::visit;\n+\n+public:\n+  static HIR::TypePath *translate (AST::TypePath &type)\n+  {\n+    ASTLowerTypePath resolver;\n+    type.accept_vis (resolver);\n+\n+    rust_assert (resolver.translated != nullptr);\n+\n+    return resolver.translated;\n+  }\n+\n+  void visit (AST::TypePathSegment &segment) override\n+  {\n+    HIR::PathIdentSegment ident (segment.get_ident_segment ().as_string ());\n+    translated_segment\n+      = new HIR::TypePathSegment (ident,\n+\t\t\t\t  segment.get_separating_scope_resolution (),\n+\t\t\t\t  segment.get_locus ());\n+  }\n+\n+  void visit (AST::TypePathSegmentGeneric &segment) override;\n+\n+  void visit (AST::TypePath &path) override\n+  {\n+    std::vector<std::unique_ptr<HIR::TypePathSegment> > translated_segments;\n+\n+    path.iterate_segments ([&] (AST::TypePathSegment *seg) mutable -> bool {\n+      translated_segment = nullptr;\n+      seg->accept_vis (*this);\n+      if (translated_segment == nullptr)\n+\t{\n+\t  rust_fatal_error (seg->get_locus (),\n+\t\t\t    \"failed to translate AST TypePathSegment\");\n+\t  return false;\n+\t}\n+\n+      translated_segments.push_back (\n+\tstd::unique_ptr<HIR::TypePathSegment> (translated_segment));\n+      return true;\n+    });\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, path.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   mappings->get_next_localdef_id (crate_num));\n+    translated\n+      = new HIR::TypePath (std::move (mapping), std::move (translated_segments),\n+\t\t\t   path.get_locus (),\n+\t\t\t   path.has_opening_scope_resolution_op ());\n+    mappings->insert_hir_type (mapping.get_crate_num (), mapping.get_hirid (),\n+\t\t\t       translated);\n+  }\n+\n+private:\n+  HIR::TypePath *translated;\n+  HIR::TypePathSegment *translated_segment;\n+};\n+\n class ASTLoweringType : public ASTLoweringBase\n {\n   using Rust::HIR::ASTLoweringBase::visit;\n@@ -116,71 +178,9 @@ class ASTLoweringType : public ASTLoweringBase\n \t\t\t\t     tuple.get_locus ());\n   }\n \n-  void visit (AST::TypePathSegment &segment) override\n-  {\n-    HIR::PathIdentSegment ident (segment.get_ident_segment ().as_string ());\n-    translated_segment\n-      = new HIR::TypePathSegment (ident,\n-\t\t\t\t  segment.get_separating_scope_resolution (),\n-\t\t\t\t  segment.get_locus ());\n-  }\n-\n-  void visit (AST::TypePathSegmentGeneric &segment) override\n-  {\n-    std::vector<HIR::GenericArgsBinding> binding_args; // TODO\n-\n-    std::string segment_name = segment.get_ident_segment ().as_string ();\n-    bool has_separating_scope_resolution\n-      = segment.get_separating_scope_resolution ();\n-\n-    std::vector<HIR::Lifetime> lifetime_args;\n-    for (auto &lifetime : segment.get_generic_args ().get_lifetime_args ())\n-      {\n-\tHIR::Lifetime l = lower_lifetime (lifetime);\n-\tlifetime_args.push_back (std::move (l));\n-      }\n-\n-    std::vector<std::unique_ptr<HIR::Type> > type_args;\n-    for (auto &type : segment.get_generic_args ().get_type_args ())\n-      {\n-\tHIR::Type *t = ASTLoweringType::translate (type.get ());\n-\ttype_args.push_back (std::unique_ptr<HIR::Type> (t));\n-      }\n-\n-    translated_segment = new HIR::TypePathSegmentGeneric (\n-      segment_name, has_separating_scope_resolution, std::move (lifetime_args),\n-      std::move (type_args), std::move (binding_args), segment.get_locus ());\n-  }\n-\n   void visit (AST::TypePath &path) override\n   {\n-    std::vector<std::unique_ptr<HIR::TypePathSegment> > translated_segments;\n-\n-    path.iterate_segments ([&] (AST::TypePathSegment *seg) mutable -> bool {\n-      translated_segment = nullptr;\n-      seg->accept_vis (*this);\n-      if (translated_segment == nullptr)\n-\t{\n-\t  rust_fatal_error (seg->get_locus (),\n-\t\t\t    \"failed to translate AST TypePathSegment\");\n-\t  return false;\n-\t}\n-\n-      translated_segments.push_back (\n-\tstd::unique_ptr<HIR::TypePathSegment> (translated_segment));\n-      return true;\n-    });\n-\n-    auto crate_num = mappings->get_current_crate ();\n-    Analysis::NodeMapping mapping (crate_num, path.get_node_id (),\n-\t\t\t\t   mappings->get_next_hir_id (crate_num),\n-\t\t\t\t   mappings->get_next_localdef_id (crate_num));\n-    translated\n-      = new HIR::TypePath (std::move (mapping), std::move (translated_segments),\n-\t\t\t   path.get_locus (),\n-\t\t\t   path.has_opening_scope_resolution_op ());\n-    mappings->insert_hir_type (mapping.get_crate_num (), mapping.get_hirid (),\n-\t\t\t       translated);\n+    translated = ASTLowerTypePath::translate (path);\n   }\n \n   void visit (AST::ArrayType &type) override\n@@ -238,12 +238,9 @@ class ASTLoweringType : public ASTLoweringBase\n   }\n \n private:\n-  ASTLoweringType ()\n-    : ASTLoweringBase (), translated (nullptr), translated_segment (nullptr)\n-  {}\n+  ASTLoweringType () : ASTLoweringBase (), translated (nullptr) {}\n \n   HIR::Type *translated;\n-  HIR::TypePathSegment *translated_segment;\n };\n \n class ASTLowerGenericParam : public ASTLoweringBase"}, {"sha": "c7222e2e9983f45fee0944f37cec6c42b9954cae", "filename": "gcc/rust/hir/rust-ast-lower.cc", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/350b0e595144cf7c6cf70807b429d87077173415/gcc%2Frust%2Fhir%2Frust-ast-lower.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/350b0e595144cf7c6cf70807b429d87077173415/gcc%2Frust%2Fhir%2Frust-ast-lower.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower.cc?ref=350b0e595144cf7c6cf70807b429d87077173415", "patch": "@@ -363,5 +363,33 @@ ASTLoweringBase::lower_self (AST::SelfParam &self)\n \t\t\t self.get_is_mut (), self.get_locus ());\n }\n \n+void\n+ASTLowerTypePath::visit (AST::TypePathSegmentGeneric &segment)\n+{\n+  std::vector<HIR::GenericArgsBinding> binding_args; // TODO\n+\n+  std::string segment_name = segment.get_ident_segment ().as_string ();\n+  bool has_separating_scope_resolution\n+    = segment.get_separating_scope_resolution ();\n+\n+  std::vector<HIR::Lifetime> lifetime_args;\n+  for (auto &lifetime : segment.get_generic_args ().get_lifetime_args ())\n+    {\n+      HIR::Lifetime l = lower_lifetime (lifetime);\n+      lifetime_args.push_back (std::move (l));\n+    }\n+\n+  std::vector<std::unique_ptr<HIR::Type> > type_args;\n+  for (auto &type : segment.get_generic_args ().get_type_args ())\n+    {\n+      HIR::Type *t = ASTLoweringType::translate (type.get ());\n+      type_args.push_back (std::unique_ptr<HIR::Type> (t));\n+    }\n+\n+  translated_segment = new HIR::TypePathSegmentGeneric (\n+    segment_name, has_separating_scope_resolution, std::move (lifetime_args),\n+    std::move (type_args), std::move (binding_args), segment.get_locus ());\n+}\n+\n } // namespace HIR\n } // namespace Rust"}, {"sha": "0fa845b5e88835885725b7eb0fc55a13726ab3f6", "filename": "gcc/rust/hir/tree/rust-hir-full-decls.h", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/350b0e595144cf7c6cf70807b429d87077173415/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-decls.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/350b0e595144cf7c6cf70807b429d87077173415/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-decls.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-decls.h?ref=350b0e595144cf7c6cf70807b429d87077173415", "patch": "@@ -37,8 +37,7 @@ class GenericParam;\n class LifetimeParam;\n \n class TraitItem;\n-class InherentImplItem;\n-class TraitImplItem;\n+class ImplItem;\n struct Crate;\n class PathExpr;\n \n@@ -194,9 +193,7 @@ class TraitItemMethod;\n class TraitItemConst;\n class TraitItemType;\n class Trait;\n-class Impl;\n-class InherentImpl;\n-class TraitImpl;\n+class ImplBlock;\n class ExternalItem;\n class ExternalStaticItem;\n struct NamedFunctionParam;"}, {"sha": "32acefcdf8efe6224afe886b99a772198a07968a", "filename": "gcc/rust/hir/tree/rust-hir-full-test.cc", "status": "modified", "additions": 5, "deletions": 94, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/350b0e595144cf7c6cf70807b429d87077173415/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/350b0e595144cf7c6cf70807b429d87077173415/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-test.cc?ref=350b0e595144cf7c6cf70807b429d87077173415", "patch": "@@ -377,7 +377,7 @@ ConstantItem::as_string () const\n }\n \n std::string\n-InherentImpl::as_string () const\n+ImplBlock::as_string () const\n {\n   std::string str = VisItem::as_string ();\n \n@@ -398,15 +398,15 @@ InherentImpl::as_string () const\n \t    {\n \t      rust_debug (\n \t\t\"something really terrible has gone wrong - null pointer \"\n-\t\t\"generic param in inherent impl.\");\n+\t\t\"generic param in impl.\");\n \t      return \"nullptr_POINTER_MARK\";\n \t    }\n \n \t  str += \"\\n  \" + param->as_string ();\n \t}\n     }\n \n-  str += \"\\n Type: \" + trait_type->as_string ();\n+  str += \"\\n Type: \" + impl_type->as_string ();\n \n   str += \"\\n Where clause: \";\n   if (has_where_clause ())\n@@ -434,8 +434,7 @@ InherentImpl::as_string () const\n \t}\n     }\n \n-  // inherent impl items\n-  str += \"\\n Inherent impl items: \";\n+  str += \"\\n impl items: \";\n   if (!has_impl_items ())\n     {\n       str += \"none\";\n@@ -1083,88 +1082,6 @@ BlockExpr::as_string () const\n   return str;\n }\n \n-std::string\n-TraitImpl::as_string () const\n-{\n-  std::string str = VisItem::as_string ();\n-\n-  if (has_unsafe)\n-    {\n-      str += \"unsafe \";\n-    }\n-\n-  str += \"impl \";\n-\n-  // generic params\n-  str += \"\\n Generic params: \";\n-  if (!has_generics ())\n-    {\n-      str += \"none\";\n-    }\n-  else\n-    {\n-      for (const auto &param : generic_params)\n-\t{\n-\t  str += \"\\n  \" + param->as_string ();\n-\t}\n-    }\n-\n-  str += \"\\n Has exclam: \";\n-  if (has_exclam)\n-    {\n-      str += \"true\";\n-    }\n-  else\n-    {\n-      str += \"false\";\n-    }\n-\n-  str += \"\\n TypePath (to trait): \" + trait_path->as_string ();\n-\n-  str += \"\\n Type (struct to impl on): \" + trait_type->as_string ();\n-\n-  str += \"\\n Where clause: \";\n-  if (!has_where_clause ())\n-    {\n-      str += \"none\";\n-    }\n-  else\n-    {\n-      str += where_clause.as_string ();\n-    }\n-\n-  // inner attributes\n-  str += \"\\n inner attributes: \";\n-  if (inner_attrs.empty ())\n-    {\n-      str += \"none\";\n-    }\n-  else\n-    {\n-      /* note that this does not print them with \"inner attribute\" syntax -\n-       * just the body */\n-      for (const auto &attr : inner_attrs)\n-\t{\n-\t  str += \"\\n  \" + attr.as_string ();\n-\t}\n-    }\n-\n-  str += \"\\n trait impl items: \";\n-  if (!has_impl_items ())\n-    {\n-      str += \"none\";\n-    }\n-  else\n-    {\n-      for (const auto &item : impl_items)\n-\t{\n-\t  str += \"\\n  \" + item->as_string ();\n-\t}\n-    }\n-\n-  return str;\n-}\n-\n std::string\n TypeAlias::as_string () const\n {\n@@ -4687,13 +4604,7 @@ Trait::accept_vis (HIRVisitor &vis)\n }\n \n void\n-InherentImpl::accept_vis (HIRVisitor &vis)\n-{\n-  vis.visit (*this);\n-}\n-\n-void\n-TraitImpl::accept_vis (HIRVisitor &vis)\n+ImplBlock::accept_vis (HIRVisitor &vis)\n {\n   vis.visit (*this);\n }"}, {"sha": "74969f9b70ada96476188a7a1cd6aea9d7dc007a", "filename": "gcc/rust/hir/tree/rust-hir-item.h", "status": "modified", "additions": 56, "deletions": 280, "changes": 336, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/350b0e595144cf7c6cf70807b429d87077173415/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/350b0e595144cf7c6cf70807b429d87077173415/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h?ref=350b0e595144cf7c6cf70807b429d87077173415", "patch": "@@ -578,7 +578,7 @@ struct Visibility\n };\n \n // A method (function belonging to a type)\n-class Method : public InherentImplItem, public TraitImplItem\n+class Method : public ImplItem\n {\n   Analysis::NodeMapping mappings;\n \n@@ -700,11 +700,6 @@ class Method : public InherentImplItem, public TraitImplItem\n     return get_mappings ();\n   };\n \n-  Analysis::NodeMapping get_trait_impl_mappings () const override\n-  {\n-    return get_mappings ();\n-  };\n-\n   // Returns whether function has return type - if not, it is void.\n   bool has_function_return_type () const { return return_type != nullptr; }\n \n@@ -753,8 +748,6 @@ class Method : public InherentImplItem, public TraitImplItem\n \n   Location get_impl_locus () const final { return get_locus (); }\n \n-  Location get_trait_impl_locus () const final { return get_locus (); }\n-\n   std::unique_ptr<BlockExpr> &get_function_body () { return function_body; }\n   const std::unique_ptr<BlockExpr> &get_function_body () const\n   {\n@@ -768,13 +761,6 @@ class Method : public InherentImplItem, public TraitImplItem\n   {\n     return new Method (*this);\n   }\n-\n-  /* Use covariance to implement clone function as returning this object\n-   * rather than base */\n-  Method *clone_trait_impl_item_impl () const override\n-  {\n-    return new Method (*this);\n-  }\n };\n \n // Item that supports visibility - abstract base class\n@@ -1274,7 +1260,7 @@ class UseDeclaration : public VisItem\n class LetStmt;\n \n // Rust function declaration HIR node\n-class Function : public VisItem, public InherentImplItem, public TraitImplItem\n+class Function : public VisItem, public ImplItem\n {\n   FunctionQualifiers qualifiers;\n   Identifier function_name;\n@@ -1377,20 +1363,13 @@ class Function : public VisItem, public InherentImplItem, public TraitImplItem\n \n   Location get_impl_locus () const final { return get_locus (); }\n \n-  Location get_trait_impl_locus () const final { return get_locus (); }\n-\n   void accept_vis (HIRVisitor &vis) override;\n \n   Analysis::NodeMapping get_impl_mappings () const override\n   {\n     return get_mappings ();\n   };\n \n-  Analysis::NodeMapping get_trait_impl_mappings () const override\n-  {\n-    return get_mappings ();\n-  };\n-\n   std::vector<FunctionParam> &get_function_params () { return function_params; }\n   const std::vector<FunctionParam> &get_function_params () const\n   {\n@@ -1444,23 +1423,10 @@ class Function : public VisItem, public InherentImplItem, public TraitImplItem\n   {\n     return new Function (*this);\n   }\n-\n-  /* Use covariance to implement clone function as returning this object\n-   * rather than base */\n-  Function *clone_trait_impl_item_impl () const override\n-  {\n-    return new Function (*this);\n-  }\n-\n-  /* Use covariance to implement clone function as returning this object\n-   * rather than base */\n-  /*virtual Function* clone_statement_impl() const override {\n-      return new Function(*this);\n-  }*/\n };\n \n // Rust type alias (i.e. typedef) HIR node\n-class TypeAlias : public VisItem, public TraitImplItem\n+class TypeAlias : public VisItem, public ImplItem\n {\n   Identifier new_type_name;\n \n@@ -1512,11 +1478,8 @@ class TypeAlias : public VisItem, public TraitImplItem\n   {\n     VisItem::operator= (other);\n     new_type_name = other.new_type_name;\n-    // generic_params = other.generic_params;\n     where_clause = other.where_clause;\n     existing_type = other.existing_type->clone_type ();\n-    // visibility = other.visibility->clone_visibility();\n-    // outer_attrs = other.outer_attrs;\n     locus = other.locus;\n \n     generic_params.reserve (other.generic_params.size ());\n@@ -1532,7 +1495,7 @@ class TypeAlias : public VisItem, public TraitImplItem\n \n   Location get_locus () const { return locus; }\n \n-  Location get_trait_impl_locus () const final { return get_locus (); }\n+  Location get_impl_locus () const final { return get_locus (); }\n \n   void accept_vis (HIRVisitor &vis) override;\n \n@@ -1545,14 +1508,12 @@ class TypeAlias : public VisItem, public TraitImplItem\n     return generic_params;\n   }\n \n-  // TODO: is this better? Or is a \"vis_block\" better?\n   WhereClause &get_where_clause ()\n   {\n     rust_assert (has_where_clause ());\n     return where_clause;\n   }\n \n-  // TODO: is this better? Or is a \"vis_block\" better?\n   std::unique_ptr<Type> &get_type_aliased ()\n   {\n     rust_assert (existing_type != nullptr);\n@@ -1561,7 +1522,7 @@ class TypeAlias : public VisItem, public TraitImplItem\n \n   Identifier get_new_type_name () const { return new_type_name; }\n \n-  Analysis::NodeMapping get_trait_impl_mappings () const override\n+  Analysis::NodeMapping get_impl_mappings () const override\n   {\n     return get_mappings ();\n   };\n@@ -1573,16 +1534,10 @@ class TypeAlias : public VisItem, public TraitImplItem\n \n   /* Use covariance to implement clone function as returning this object\n    * rather than base */\n-  TypeAlias *clone_trait_impl_item_impl () const override\n+  TypeAlias *clone_inherent_impl_item_impl () const override\n   {\n     return new TypeAlias (*this);\n   }\n-\n-  /* Use covariance to implement clone function as returning this object\n-   * rather than base */\n-  /*virtual TypeAlias* clone_statement_impl() const override {\n-      return new TypeAlias(*this);\n-  }*/\n };\n \n // Rust base struct declaration HIR node - abstract base class\n@@ -2226,28 +2181,13 @@ class Union : public VisItem\n   /* Use covariance to implement clone function as returning this object\n    * rather than base */\n   Union *clone_item_impl () const override { return new Union (*this); }\n-\n-  /* Use covariance to implement clone function as returning this object\n-   * rather than base */\n-  /*virtual Union* clone_statement_impl() const override {\n-      return new Union(*this);\n-  }*/\n };\n \n-/* \"Constant item\" HIR node - used for constant, compile-time expressions\n- * within module scope (like constexpr) */\n-class ConstantItem : public VisItem,\n-\t\t     public InherentImplItem,\n-\t\t     public TraitImplItem\n+class ConstantItem : public VisItem, public ImplItem\n {\n-  // either has an identifier or \"_\" - maybe handle in identifier?\n-  // bool identifier_is_underscore;\n-  // if no identifier declared, identifier will be \"_\"\n   Identifier identifier;\n-\n   std::unique_ptr<Type> type;\n   std::unique_ptr<Expr> const_expr;\n-\n   Location locus;\n \n public:\n@@ -2284,16 +2224,14 @@ class ConstantItem : public VisItem,\n   ConstantItem (ConstantItem &&other) = default;\n   ConstantItem &operator= (ConstantItem &&other) = default;\n \n-  /* Returns whether constant item is an \"unnamed\" (wildcard underscore used\n-   * as identifier) constant. */\n+  // Returns whether constant item is an \"unnamed\" (wildcard underscore used\n+  // as identifier) constant.\n   bool is_unnamed () const { return identifier == std::string (\"_\"); }\n \n   Location get_locus () const { return locus; }\n \n   Location get_impl_locus () const final { return get_locus (); }\n \n-  Location get_trait_impl_locus () const final { return get_locus (); }\n-\n   void accept_vis (HIRVisitor &vis) override;\n \n   Type *get_type () { return type.get (); }\n@@ -2307,11 +2245,6 @@ class ConstantItem : public VisItem,\n     return get_mappings ();\n   };\n \n-  Analysis::NodeMapping get_trait_impl_mappings () const override\n-  {\n-    return get_mappings ();\n-  };\n-\n protected:\n   /* Use covariance to implement clone function as returning this object\n    * rather than base */\n@@ -2326,19 +2259,6 @@ class ConstantItem : public VisItem,\n   {\n     return new ConstantItem (*this);\n   }\n-\n-  /* Use covariance to implement clone function as returning this object\n-   * rather than base */\n-  ConstantItem *clone_trait_impl_item_impl () const override\n-  {\n-    return new ConstantItem (*this);\n-  }\n-\n-  /* Use covariance to implement clone function as returning this object\n-   * rather than base */\n-  /*virtual ConstantItem* clone_statement_impl() const override {\n-      return new ConstantItem(*this);\n-  }*/\n };\n \n /* Static item HIR node - items within module scope with fixed storage\n@@ -2958,84 +2878,52 @@ class Trait : public VisItem\n   /* Use covariance to implement clone function as returning this object\n    * rather than base */\n   Trait *clone_item_impl () const override { return new Trait (*this); }\n-\n-  /* Use covariance to implement clone function as returning this object\n-   * rather than base */\n-  /*virtual Trait* clone_statement_impl() const override {\n-      return new Trait(*this);\n-  }*/\n };\n \n-// Implementation item declaration HIR node - abstract base class\n-class Impl : public VisItem\n+class ImplBlock : public VisItem\n {\n-  // must be protected to allow subclasses to access them properly\n-protected:\n-  // bool has_generics;\n-  // Generics generic_params;\n-  std::vector<std::unique_ptr<GenericParam> > generic_params; // inlined\n-\n-  std::unique_ptr<Type> trait_type;\n-\n-  // bool has_where_clause;\n+  std::vector<std::unique_ptr<GenericParam> > generic_params;\n+  std::unique_ptr<Type> impl_type;\n+  std::unique_ptr<TypePath> trait_ref;\n   WhereClause where_clause;\n-\n-  // bool has_inner_attrs;\n   AST::AttrVec inner_attrs;\n-\n-private:\n-  // doesn't really need to be protected as write access probably not needed\n   Location locus;\n+  std::vector<std::unique_ptr<ImplItem> > impl_items;\n \n public:\n-  // Returns whether impl has generic parameters.\n-  bool has_generics () const { return !generic_params.empty (); }\n-\n-  // Returns whether impl has where clause.\n-  bool has_where_clause () const { return !where_clause.is_empty (); }\n-\n-  // Returns whether impl has inner attributes.\n-  bool has_inner_attrs () const { return !inner_attrs.empty (); }\n-\n-  Location get_locus () const { return locus; }\n-\n-  std::unique_ptr<Type> &get_type () { return trait_type; };\n-\n-  std::vector<std::unique_ptr<GenericParam> > &get_generic_params ()\n-  {\n-    return generic_params;\n-  }\n-\n-protected:\n-  // Mega-constructor\n-  Impl (Analysis::NodeMapping mappings,\n-\tstd::vector<std::unique_ptr<GenericParam> > generic_params,\n-\tstd::unique_ptr<Type> trait_type, WhereClause where_clause,\n-\tVisibility vis, AST::AttrVec inner_attrs, AST::AttrVec outer_attrs,\n-\tLocation locus)\n+  ImplBlock (Analysis::NodeMapping mappings,\n+\t     std::vector<std::unique_ptr<ImplItem> > impl_items,\n+\t     std::vector<std::unique_ptr<GenericParam> > generic_params,\n+\t     std::unique_ptr<Type> impl_type,\n+\t     std::unique_ptr<TypePath> trait_ref, WhereClause where_clause,\n+\t     Visibility vis, AST::AttrVec inner_attrs, AST::AttrVec outer_attrs,\n+\t     Location locus)\n     : VisItem (std::move (mappings), std::move (vis), std::move (outer_attrs)),\n       generic_params (std::move (generic_params)),\n-      trait_type (std::move (trait_type)),\n+      impl_type (std::move (impl_type)), trait_ref (std::move (trait_ref)),\n       where_clause (std::move (where_clause)),\n-      inner_attrs (std::move (inner_attrs)), locus (locus)\n+      inner_attrs (std::move (inner_attrs)), locus (locus),\n+      impl_items (std::move (impl_items))\n   {}\n \n-  // Copy constructor\n-  Impl (Impl const &other)\n-    : VisItem (other), trait_type (other.trait_type->clone_type ()),\n+  ImplBlock (ImplBlock const &other)\n+    : VisItem (other), impl_type (other.impl_type->clone_type ()),\n       where_clause (other.where_clause), inner_attrs (other.inner_attrs),\n       locus (other.locus)\n   {\n     generic_params.reserve (other.generic_params.size ());\n     for (const auto &e : other.generic_params)\n       generic_params.push_back (e->clone_generic_param ());\n+\n+    impl_items.reserve (other.impl_items.size ());\n+    for (const auto &e : other.impl_items)\n+      impl_items.push_back (e->clone_inherent_impl_item ());\n   }\n \n-  // Assignment operator overload with cloning\n-  Impl &operator= (Impl const &other)\n+  ImplBlock &operator= (ImplBlock const &other)\n   {\n     VisItem::operator= (other);\n-    trait_type = other.trait_type->clone_type ();\n+    impl_type = other.impl_type->clone_type ();\n     where_clause = other.where_clause;\n     inner_attrs = other.inner_attrs;\n     locus = other.locus;\n@@ -3044,180 +2932,68 @@ class Impl : public VisItem\n     for (const auto &e : other.generic_params)\n       generic_params.push_back (e->clone_generic_param ());\n \n+    impl_items.reserve (other.impl_items.size ());\n+    for (const auto &e : other.impl_items)\n+      impl_items.push_back (e->clone_inherent_impl_item ());\n+\n     return *this;\n   }\n \n-  // move constructors\n-  Impl (Impl &&other) = default;\n-  Impl &operator= (Impl &&other) = default;\n-};\n-\n-// Regular \"impl foo\" impl block declaration HIR node\n-class InherentImpl : public Impl\n-{\n-  // bool has_impl_items;\n-  std::vector<std::unique_ptr<InherentImplItem> > impl_items;\n+  ImplBlock (ImplBlock &&other) = default;\n+  ImplBlock &operator= (ImplBlock &&other) = default;\n \n-public:\n   std::string as_string () const override;\n \n   // Returns whether inherent impl block has inherent impl items.\n   bool has_impl_items () const { return !impl_items.empty (); }\n \n-  // Mega-constructor\n-  InherentImpl (Analysis::NodeMapping mappings,\n-\t\tstd::vector<std::unique_ptr<InherentImplItem> > impl_items,\n-\t\tstd::vector<std::unique_ptr<GenericParam> > generic_params,\n-\t\tstd::unique_ptr<Type> trait_type, WhereClause where_clause,\n-\t\tVisibility vis, AST::AttrVec inner_attrs,\n-\t\tAST::AttrVec outer_attrs, Location locus)\n-    : Impl (std::move (mappings), std::move (generic_params),\n-\t    std::move (trait_type), std::move (where_clause), std::move (vis),\n-\t    std::move (inner_attrs), std::move (outer_attrs), locus),\n-      impl_items (std::move (impl_items))\n-  {}\n-\n-  // Copy constructor with vector clone\n-  InherentImpl (InherentImpl const &other) : Impl (other)\n-  {\n-    impl_items.reserve (other.impl_items.size ());\n-    for (const auto &e : other.impl_items)\n-      impl_items.push_back (e->clone_inherent_impl_item ());\n-  }\n-\n-  // Overloaded assignment operator with vector clone\n-  InherentImpl &operator= (InherentImpl const &other)\n-  {\n-    Impl::operator= (other);\n-\n-    impl_items.reserve (other.impl_items.size ());\n-    for (const auto &e : other.impl_items)\n-      impl_items.push_back (e->clone_inherent_impl_item ());\n-\n-    return *this;\n-  }\n-\n-  // default move constructors\n-  InherentImpl (InherentImpl &&other) = default;\n-  InherentImpl &operator= (InherentImpl &&other) = default;\n-\n   void accept_vis (HIRVisitor &vis) override;\n \n-  std::vector<std::unique_ptr<InherentImplItem> > &get_impl_items ()\n+  std::vector<std::unique_ptr<ImplItem> > &get_impl_items ()\n   {\n     return impl_items;\n   };\n \n-  const std::vector<std::unique_ptr<InherentImplItem> > &get_impl_items () const\n+  const std::vector<std::unique_ptr<ImplItem> > &get_impl_items () const\n   {\n     return impl_items;\n   };\n \n-protected:\n-  /* Use covariance to implement clone function as returning this object\n-   * rather than base */\n-  InherentImpl *clone_item_impl () const override\n-  {\n-    return new InherentImpl (*this);\n-  }\n-\n-  /* Use covariance to implement clone function as returning this object\n-   * rather than base */\n-  /*virtual InherentImpl* clone_statement_impl() const override {\n-      return new InherentImpl(*this);\n-  }*/\n-};\n-\n-// The \"impl footrait for foo\" impl block declaration HIR node\n-class TraitImpl : public Impl\n-{\n-  bool has_unsafe;\n-  bool has_exclam;\n-  std::unique_ptr<Type> trait_path;\n-\n-  // bool has_impl_items;\n-  std::vector<std::unique_ptr<TraitImplItem> > impl_items;\n-\n-public:\n-  std::string as_string () const override;\n+  // Returns whether impl has generic parameters.\n+  bool has_generics () const { return !generic_params.empty (); }\n \n-  // Returns whether trait impl has impl items.\n-  bool has_impl_items () const { return !impl_items.empty (); }\n+  // Returns whether impl has where clause.\n+  bool has_where_clause () const { return !where_clause.is_empty (); }\n \n-  // Mega-constructor\n-  TraitImpl (Analysis::NodeMapping mappings, std::unique_ptr<Type> trait_path,\n-\t     bool is_unsafe, bool has_exclam,\n-\t     std::vector<std::unique_ptr<TraitImplItem> > impl_items,\n-\t     std::vector<std::unique_ptr<GenericParam> > generic_params,\n-\t     std::unique_ptr<Type> trait_type, WhereClause where_clause,\n-\t     Visibility vis, AST::AttrVec inner_attrs, AST::AttrVec outer_attrs,\n-\t     Location locus)\n-    : Impl (std::move (mappings), std::move (generic_params),\n-\t    std::move (trait_type), std::move (where_clause), std::move (vis),\n-\t    std::move (inner_attrs), std::move (outer_attrs), locus),\n-      has_unsafe (is_unsafe), has_exclam (has_exclam),\n-      trait_path (std::move (trait_path)), impl_items (std::move (impl_items))\n-  {}\n+  // Returns whether impl has inner attributes.\n+  bool has_inner_attrs () const { return !inner_attrs.empty (); }\n \n-  // TODO: constructors with less params\n+  Location get_locus () const { return locus; }\n \n-  // Copy constructor with vector clone\n-  TraitImpl (TraitImpl const &other)\n-    : Impl (other), has_unsafe (other.has_unsafe),\n-      has_exclam (other.has_exclam),\n-      trait_path (other.trait_path->clone_type ())\n-  {\n-    impl_items.reserve (other.impl_items.size ());\n-    for (const auto &e : other.impl_items)\n-      impl_items.push_back (e->clone_trait_impl_item ());\n-  }\n+  std::unique_ptr<Type> &get_type () { return impl_type; };\n \n-  // Overloaded assignment operator with vector clone\n-  TraitImpl &operator= (TraitImpl const &other)\n+  std::vector<std::unique_ptr<GenericParam> > &get_generic_params ()\n   {\n-    Impl::operator= (other);\n-    trait_path = other.trait_path->clone_type ();\n-    has_unsafe = other.has_unsafe;\n-    has_exclam = other.has_exclam;\n-\n-    impl_items.reserve (other.impl_items.size ());\n-    for (const auto &e : other.impl_items)\n-      impl_items.push_back (e->clone_trait_impl_item ());\n-\n-    return *this;\n+    return generic_params;\n   }\n \n-  // move constructors\n-  TraitImpl (TraitImpl &&other) = default;\n-  TraitImpl &operator= (TraitImpl &&other) = default;\n+  bool has_trait_ref () const { return trait_ref != nullptr; }\n \n-  void accept_vis (HIRVisitor &vis) override;\n-  std::vector<std::unique_ptr<TraitImplItem> > &get_impl_items ()\n+  std::unique_ptr<TypePath> &get_trait_ref ()\n   {\n-    return impl_items;\n-  };\n+    rust_assert (has_trait_ref ());\n+    return trait_ref;\n+  }\n \n protected:\n-  /* Use covariance to implement clone function as returning this object\n-   * rather than base */\n-  TraitImpl *clone_item_impl () const override { return new TraitImpl (*this); }\n-\n-  /* Use covariance to implement clone function as returning this object\n-   * rather than base */\n-  /*virtual TraitImpl* clone_statement_impl() const override {\n-      return new TraitImpl(*this);\n-  }*/\n+  ImplBlock *clone_item_impl () const override { return new ImplBlock (*this); }\n };\n \n // Abstract base class for an item used inside an extern block\n class ExternalItem\n {\n-  // bool has_outer_attrs;\n   AST::AttrVec outer_attrs;\n-\n-  // bool has_visibility;\n   Visibility visibility;\n-\n   Identifier item_name;\n   Location locus;\n "}, {"sha": "ad033b4d04c04502a18672d6b50948a865533815", "filename": "gcc/rust/hir/tree/rust-hir-visitor.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/350b0e595144cf7c6cf70807b429d87077173415/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-visitor.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/350b0e595144cf7c6cf70807b429d87077173415/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-visitor.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-visitor.h?ref=350b0e595144cf7c6cf70807b429d87077173415", "patch": "@@ -127,8 +127,7 @@ class HIRVisitor\n   virtual void visit (TraitItemConst &item) = 0;\n   virtual void visit (TraitItemType &item) = 0;\n   virtual void visit (Trait &trait) = 0;\n-  virtual void visit (InherentImpl &impl) = 0;\n-  virtual void visit (TraitImpl &impl) = 0;\n+  virtual void visit (ImplBlock &impl) = 0;\n   virtual void visit (ExternalStaticItem &item) = 0;\n   virtual void visit (ExternalFunctionItem &item) = 0;\n   virtual void visit (ExternBlock &block) = 0;"}, {"sha": "8700be8f8a18ed71ebbc1d97dde44a96585f136a", "filename": "gcc/rust/hir/tree/rust-hir.h", "status": "modified", "additions": 5, "deletions": 31, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/350b0e595144cf7c6cf70807b429d87077173415/gcc%2Frust%2Fhir%2Ftree%2Frust-hir.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/350b0e595144cf7c6cf70807b429d87077173415/gcc%2Frust%2Fhir%2Ftree%2Frust-hir.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir.h?ref=350b0e595144cf7c6cf70807b429d87077173415", "patch": "@@ -645,21 +645,19 @@ class TraitItem\n   const Analysis::NodeMapping &get_mappings () const { return mappings; }\n };\n \n-/* Abstract base class for items used within an inherent impl block (the impl\n- * name {} one) */\n-class InherentImplItem\n+class ImplItem\n {\n protected:\n   // Clone function implementation as pure virtual method\n-  virtual InherentImplItem *clone_inherent_impl_item_impl () const = 0;\n+  virtual ImplItem *clone_inherent_impl_item_impl () const = 0;\n \n public:\n-  virtual ~InherentImplItem () {}\n+  virtual ~ImplItem () {}\n \n   // Unique pointer custom clone function\n-  std::unique_ptr<InherentImplItem> clone_inherent_impl_item () const\n+  std::unique_ptr<ImplItem> clone_inherent_impl_item () const\n   {\n-    return std::unique_ptr<InherentImplItem> (clone_inherent_impl_item_impl ());\n+    return std::unique_ptr<ImplItem> (clone_inherent_impl_item_impl ());\n   }\n \n   virtual std::string as_string () const = 0;\n@@ -671,30 +669,6 @@ class InherentImplItem\n   virtual Location get_impl_locus () const = 0;\n };\n \n-// Abstract base class for items used in a trait impl\n-class TraitImplItem\n-{\n-protected:\n-  virtual TraitImplItem *clone_trait_impl_item_impl () const = 0;\n-\n-public:\n-  virtual ~TraitImplItem (){};\n-\n-  // Unique pointer custom clone function\n-  std::unique_ptr<TraitImplItem> clone_trait_impl_item () const\n-  {\n-    return std::unique_ptr<TraitImplItem> (clone_trait_impl_item_impl ());\n-  }\n-\n-  virtual std::string as_string () const = 0;\n-\n-  virtual void accept_vis (HIRVisitor &vis) = 0;\n-\n-  virtual Analysis::NodeMapping get_trait_impl_mappings () const = 0;\n-\n-  virtual Location get_trait_impl_locus () const = 0;\n-};\n-\n // A crate HIR object - holds all the data for a single compilation unit\n struct Crate\n {"}, {"sha": "0452917ee95707220ea6fcba94e704253a330e2f", "filename": "gcc/rust/lint/rust-lint-marklive-base.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/350b0e595144cf7c6cf70807b429d87077173415/gcc%2Frust%2Flint%2Frust-lint-marklive-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/350b0e595144cf7c6cf70807b429d87077173415/gcc%2Frust%2Flint%2Frust-lint-marklive-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Flint%2Frust-lint-marklive-base.h?ref=350b0e595144cf7c6cf70807b429d87077173415", "patch": "@@ -143,8 +143,7 @@ class MarkLiveBase : public HIR::HIRVisitor\n   virtual void visit (HIR::TraitItemConst &) override {}\n   virtual void visit (HIR::TraitItemType &) override {}\n   virtual void visit (HIR::Trait &) override {}\n-  virtual void visit (HIR::InherentImpl &) override {}\n-  virtual void visit (HIR::TraitImpl &) override {}\n+  virtual void visit (HIR::ImplBlock &) override {}\n \n   virtual void visit (HIR::ExternalStaticItem &) override {}\n   virtual void visit (HIR::ExternalFunctionItem &) override {}"}, {"sha": "3bfc1c37d0d4541f9bf462c5738f09089e9d3799", "filename": "gcc/rust/lint/rust-lint-marklive.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/350b0e595144cf7c6cf70807b429d87077173415/gcc%2Frust%2Flint%2Frust-lint-marklive.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/350b0e595144cf7c6cf70807b429d87077173415/gcc%2Frust%2Flint%2Frust-lint-marklive.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Flint%2Frust-lint-marklive.cc?ref=350b0e595144cf7c6cf70807b429d87077173415", "patch": "@@ -80,7 +80,7 @@ MarkLive::go (HIR::Crate &crate)\n       else\n \t{ // the item maybe inside a trait impl\n \t  HirId parent_impl_id = UNKNOWN_HIRID;\n-\t  HIR::InherentImplItem *implItem\n+\t  HIR::ImplItem *implItem\n \t    = mappings->lookup_hir_implitem (crateNum, hirId, &parent_impl_id);\n \t  if (implItem != nullptr)\n \t    implItem->accept_vis (*this);"}, {"sha": "2ad0aaef1ef806b39c2c1b1b33883dee49c44caf", "filename": "gcc/rust/lint/rust-lint-marklive.h", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/350b0e595144cf7c6cf70807b429d87077173415/gcc%2Frust%2Flint%2Frust-lint-marklive.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/350b0e595144cf7c6cf70807b429d87077173415/gcc%2Frust%2Flint%2Frust-lint-marklive.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Flint%2Frust-lint-marklive.h?ref=350b0e595144cf7c6cf70807b429d87077173415", "patch": "@@ -80,37 +80,36 @@ class MarkLive : public MarkLiveBase\n     expr.get_lhs ()->accept_vis (*this);\n     expr.get_rhs ()->accept_vis (*this);\n   }\n+\n   void visit (HIR::AssignmentExpr &expr) override\n   {\n     expr.visit_lhs (*this);\n     expr.visit_rhs (*this);\n   }\n+\n   void visit (HIR::Method &method) override\n   {\n     method.get_definition ().get ()->accept_vis (*this);\n   }\n+\n   void visit (HIR::TraitItemFunc &item) override\n   {\n     item.get_block_expr ()->accept_vis (*this);\n   }\n+\n   void visit (HIR::TraitItemMethod &item) override\n   {\n     item.get_block_expr ()->accept_vis (*this);\n   }\n-  void visit (HIR::InherentImpl &impl) override\n-  {\n-    for (auto &&item : impl.get_impl_items ())\n-      {\n-\titem.get ()->accept_vis (*this);\n-      }\n-  }\n-  void visit (HIR::TraitImpl &impl) override\n+\n+  void visit (HIR::ImplBlock &impl) override\n   {\n     for (auto &&item : impl.get_impl_items ())\n       {\n \titem.get ()->accept_vis (*this);\n       }\n   }\n+\n   void visit (HIR::LetStmt &stmt) override\n   {\n     if (stmt.has_init_expr ())\n@@ -150,4 +149,4 @@ class MarkLive : public MarkLiveBase\n } // namespace Analysis\n } // namespace Rust\n \n-#endif\n\\ No newline at end of file\n+#endif"}, {"sha": "d27d9cefab63b96717459cfbede737b9e56c5e60", "filename": "gcc/rust/typecheck/rust-hir-const-fold-base.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/350b0e595144cf7c6cf70807b429d87077173415/gcc%2Frust%2Ftypecheck%2Frust-hir-const-fold-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/350b0e595144cf7c6cf70807b429d87077173415/gcc%2Frust%2Ftypecheck%2Frust-hir-const-fold-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-const-fold-base.h?ref=350b0e595144cf7c6cf70807b429d87077173415", "patch": "@@ -146,8 +146,7 @@ class ConstFoldBase : public HIR::HIRVisitor\n   virtual void visit (HIR::TraitItemConst &) override {}\n   virtual void visit (HIR::TraitItemType &) override {}\n   virtual void visit (HIR::Trait &) override {}\n-  virtual void visit (HIR::InherentImpl &) override {}\n-  virtual void visit (HIR::TraitImpl &) override {}\n+  virtual void visit (HIR::ImplBlock &) override {}\n \n   virtual void visit (HIR::ExternalStaticItem &) override {}\n   virtual void visit (HIR::ExternalFunctionItem &) override {}"}, {"sha": "e93e12aa6789a89672117175c169b487a0fded28", "filename": "gcc/rust/typecheck/rust-hir-inherent-impl-overlap.h", "status": "modified", "additions": 21, "deletions": 23, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/350b0e595144cf7c6cf70807b429d87077173415/gcc%2Frust%2Ftypecheck%2Frust-hir-inherent-impl-overlap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/350b0e595144cf7c6cf70807b429d87077173415/gcc%2Frust%2Ftypecheck%2Frust-hir-inherent-impl-overlap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-inherent-impl-overlap.h?ref=350b0e595144cf7c6cf70807b429d87077173415", "patch": "@@ -25,14 +25,14 @@\n namespace Rust {\n namespace Resolver {\n \n-class InherentImplItemToName : public TypeCheckBase\n+class ImplItemToName : public TypeCheckBase\n {\n   using Rust::Resolver::TypeCheckBase::visit;\n \n public:\n-  static bool resolve (HIR::InherentImplItem *item, std::string &name_result)\n+  static bool resolve (HIR::ImplItem *item, std::string &name_result)\n   {\n-    InherentImplItemToName resolver (name_result);\n+    ImplItemToName resolver (name_result);\n     item->accept_vis (resolver);\n     return resolver.ok;\n   }\n@@ -56,7 +56,7 @@ class InherentImplItemToName : public TypeCheckBase\n   }\n \n private:\n-  InherentImplItemToName (std::string &result)\n+  ImplItemToName (std::string &result)\n     : TypeCheckBase (), ok (false), result (result)\n   {}\n \n@@ -69,7 +69,7 @@ class GetLocusFromImplItem : public TypeCheckBase\n   using Rust::Resolver::TypeCheckBase::visit;\n \n public:\n-  static bool Resolve (HIR::InherentImplItem *query, Location &locus)\n+  static bool Resolve (HIR::ImplItem *query, Location &locus)\n   {\n     GetLocusFromImplItem resolver (locus);\n     query->accept_vis (resolver);\n@@ -113,18 +113,17 @@ class OverlappingImplItemPass : public TypeCheckBase\n     OverlappingImplItemPass pass;\n \n     // generate mappings\n-    pass.mappings->iterate_impl_items ([&] (HirId id,\n-\t\t\t\t\t    HIR::InherentImplItem *impl_item,\n-\t\t\t\t\t    HIR::InherentImpl *impl) -> bool {\n-      pass.process_impl_item (id, impl_item, impl);\n-      return true;\n-    });\n+    pass.mappings->iterate_impl_items (\n+      [&] (HirId id, HIR::ImplItem *impl_item, HIR::ImplBlock *impl) -> bool {\n+\tpass.process_impl_item (id, impl_item, impl);\n+\treturn true;\n+      });\n \n     pass.scan ();\n   }\n \n-  void process_impl_item (HirId id, HIR::InherentImplItem *impl_item,\n-\t\t\t  HIR::InherentImpl *impl)\n+  void process_impl_item (HirId id, HIR::ImplItem *impl_item,\n+\t\t\t  HIR::ImplBlock *impl)\n   {\n     // lets make a mapping of impl-item Self type to (impl-item,name):\n     // {\n@@ -137,11 +136,10 @@ class OverlappingImplItemPass : public TypeCheckBase\n     rust_assert (ok);\n \n     std::string impl_item_name;\n-    ok = InherentImplItemToName::resolve (impl_item, impl_item_name);\n+    ok = ImplItemToName::resolve (impl_item, impl_item_name);\n     rust_assert (ok);\n \n-    std::pair<HIR::InherentImplItem *, std::string> elem (impl_item,\n-\t\t\t\t\t\t\t  impl_item_name);\n+    std::pair<HIR::ImplItem *, std::string> elem (impl_item, impl_item_name);\n     impl_mappings[impl_type].insert (std::move (elem));\n   }\n \n@@ -166,17 +164,17 @@ class OverlappingImplItemPass : public TypeCheckBase\n   }\n \n   void possible_collision (\n-    std::set<std::pair<HIR::InherentImplItem *, std::string> > query,\n-    std::set<std::pair<HIR::InherentImplItem *, std::string> > candidate)\n+    std::set<std::pair<HIR::ImplItem *, std::string> > query,\n+    std::set<std::pair<HIR::ImplItem *, std::string> > candidate)\n   {\n     for (auto &q : query)\n       {\n-\tHIR::InherentImplItem *query_impl_item = q.first;\n+\tHIR::ImplItem *query_impl_item = q.first;\n \tstd::string query_impl_item_name = q.second;\n \n \tfor (auto &c : candidate)\n \t  {\n-\t    HIR::InherentImplItem *candidate_impl_item = c.first;\n+\t    HIR::ImplItem *candidate_impl_item = c.first;\n \t    std::string candidate_impl_item_name = c.second;\n \n \t    if (query_impl_item_name.compare (candidate_impl_item_name) == 0)\n@@ -186,8 +184,8 @@ class OverlappingImplItemPass : public TypeCheckBase\n       }\n   }\n \n-  void collision_detected (HIR::InherentImplItem *query,\n-\t\t\t   HIR::InherentImplItem *dup, const std::string &name)\n+  void collision_detected (HIR::ImplItem *query, HIR::ImplItem *dup,\n+\t\t\t   const std::string &name)\n   {\n     Location qlocus; // query\n     bool ok = GetLocusFromImplItem::Resolve (query, qlocus);\n@@ -206,7 +204,7 @@ class OverlappingImplItemPass : public TypeCheckBase\n   OverlappingImplItemPass () : TypeCheckBase () {}\n \n   std::map<TyTy::BaseType *,\n-\t   std::set<std::pair<HIR::InherentImplItem *, std::string> > >\n+\t   std::set<std::pair<HIR::ImplItem *, std::string> > >\n     impl_mappings;\n };\n "}, {"sha": "06e8906d5a673a23c02fb315507fe7bb1ea8667b", "filename": "gcc/rust/typecheck/rust-hir-path-probe.h", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/350b0e595144cf7c6cf70807b429d87077173415/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/350b0e595144cf7c6cf70807b429d87077173415/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.h?ref=350b0e595144cf7c6cf70807b429d87077173415", "patch": "@@ -29,7 +29,7 @@ namespace Resolver {\n \n struct PathProbeCandidate\n {\n-  HIR::InherentImplItem *impl_item;\n+  HIR::ImplItem *impl_item;\n   TyTy::BaseType *ty;\n };\n \n@@ -43,16 +43,15 @@ class PathProbeType : public TypeCheckBase\n   {\n     PathProbeType probe (receiver, segment_name);\n     probe.mappings->iterate_impl_items (\n-      [&] (HirId id, HIR::InherentImplItem *item,\n-\t   HIR::InherentImpl *impl) mutable -> bool {\n+      [&] (HirId id, HIR::ImplItem *item,\n+\t   HIR::ImplBlock *impl) mutable -> bool {\n \tprobe.process_candidate (id, item, impl);\n \treturn true;\n       });\n     return probe.candidates;\n   }\n \n-  void process_candidate (HirId id, HIR::InherentImplItem *item,\n-\t\t\t  HIR::InherentImpl *impl)\n+  void process_candidate (HirId id, HIR::ImplItem *item, HIR::ImplBlock *impl)\n   {\n     HirId impl_ty_id = impl->get_type ()->get_mappings ().get_hirid ();\n     TyTy::BaseType *impl_block_ty = nullptr;"}, {"sha": "011ed669ae0e1acf80343904a39c512c0723a78c", "filename": "gcc/rust/typecheck/rust-hir-type-check-base.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/350b0e595144cf7c6cf70807b429d87077173415/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/350b0e595144cf7c6cf70807b429d87077173415/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.h?ref=350b0e595144cf7c6cf70807b429d87077173415", "patch": "@@ -145,8 +145,7 @@ class TypeCheckBase : public HIR::HIRVisitor\n   virtual void visit (HIR::TraitItemConst &) override {}\n   virtual void visit (HIR::TraitItemType &) override {}\n   virtual void visit (HIR::Trait &) override {}\n-  virtual void visit (HIR::InherentImpl &) override {}\n-  virtual void visit (HIR::TraitImpl &) override {}\n+  virtual void visit (HIR::ImplBlock &) override {}\n \n   virtual void visit (HIR::ExternalStaticItem &) override {}\n   virtual void visit (HIR::ExternalFunctionItem &) override {}"}, {"sha": "57a5ca18fdb7383986033990cbc3223d3f3430b9", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/350b0e595144cf7c6cf70807b429d87077173415/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/350b0e595144cf7c6cf70807b429d87077173415/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h?ref=350b0e595144cf7c6cf70807b429d87077173415", "patch": "@@ -229,7 +229,7 @@ class TypeCheckExpr : public TypeCheckBase\n       }\n \n     auto resolved_candidate = candidates.at (0);\n-    HIR::InherentImplItem *resolved_method = resolved_candidate.impl_item;\n+    HIR::ImplItem *resolved_method = resolved_candidate.impl_item;\n     TyTy::BaseType *lookup_tyty = resolved_candidate.ty;\n \n     if (lookup_tyty->get_kind () != TyTy::TypeKind::FNDEF)"}, {"sha": "1f66e6955b4a65587e2d908bc46e5b92f8079502", "filename": "gcc/rust/typecheck/rust-hir-type-check-implitem.h", "status": "modified", "additions": 2, "deletions": 16, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/350b0e595144cf7c6cf70807b429d87077173415/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/350b0e595144cf7c6cf70807b429d87077173415/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h?ref=350b0e595144cf7c6cf70807b429d87077173415", "patch": "@@ -34,15 +34,7 @@ class TypeCheckTopLevelImplItem : public TypeCheckBase\n \n public:\n   static void\n-  Resolve (HIR::InherentImplItem *item, TyTy::BaseType *self,\n-\t   std::vector<TyTy::SubstitutionParamMapping> substitutions)\n-  {\n-    TypeCheckTopLevelImplItem resolver (self, substitutions);\n-    item->accept_vis (resolver);\n-  }\n-\n-  static void\n-  Resolve (HIR::TraitImplItem *item, TyTy::BaseType *self,\n+  Resolve (HIR::ImplItem *item, TyTy::BaseType *self,\n \t   std::vector<TyTy::SubstitutionParamMapping> substitutions)\n   {\n     TypeCheckTopLevelImplItem resolver (self, substitutions);\n@@ -221,13 +213,7 @@ class TypeCheckImplItem : public TypeCheckBase\n   using Rust::Resolver::TypeCheckBase::visit;\n \n public:\n-  static void Resolve (HIR::InherentImplItem *item, TyTy::BaseType *self)\n-  {\n-    TypeCheckImplItem resolver (self);\n-    item->accept_vis (resolver);\n-  }\n-\n-  static void Resolve (HIR::TraitImplItem *item, TyTy::BaseType *self)\n+  static void Resolve (HIR::ImplItem *item, TyTy::BaseType *self)\n   {\n     TypeCheckImplItem resolver (self);\n     item->accept_vis (resolver);"}, {"sha": "5220101289103bb291cf06ac39ed7779c36aa42b", "filename": "gcc/rust/typecheck/rust-hir-type-check-item.h", "status": "modified", "additions": 2, "deletions": 17, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/350b0e595144cf7c6cf70807b429d87077173415/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/350b0e595144cf7c6cf70807b429d87077173415/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h?ref=350b0e595144cf7c6cf70807b429d87077173415", "patch": "@@ -40,29 +40,14 @@ class TypeCheckItem : public TypeCheckBase\n     item->accept_vis (resolver);\n   }\n \n-  void visit (HIR::InherentImpl &impl_block) override\n+  void visit (HIR::ImplBlock &impl_block) override\n   {\n     TyTy::BaseType *self = nullptr;\n     if (!context->lookup_type (\n \t  impl_block.get_type ()->get_mappings ().get_hirid (), &self))\n       {\n \trust_error_at (impl_block.get_locus (),\n-\t\t       \"failed to resolve Self for InherentImpl\");\n-\treturn;\n-      }\n-\n-    for (auto &impl_item : impl_block.get_impl_items ())\n-      TypeCheckImplItem::Resolve (impl_item.get (), self);\n-  }\n-\n-  void visit (HIR::TraitImpl &impl_block) override\n-  {\n-    TyTy::BaseType *self = nullptr;\n-    if (!context->lookup_type (\n-\t  impl_block.get_type ()->get_mappings ().get_hirid (), &self))\n-      {\n-\trust_error_at (impl_block.get_locus (),\n-\t\t       \"failed to resolve Self for TraitImpl\");\n+\t\t       \"failed to resolve Self for ImplBlock\");\n \treturn;\n       }\n "}, {"sha": "45bf6f3a5cbf49737ca281d1578f6ec8282c9589", "filename": "gcc/rust/typecheck/rust-hir-type-check-toplevel.h", "status": "modified", "additions": 1, "deletions": 42, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/350b0e595144cf7c6cf70807b429d87077173415/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/350b0e595144cf7c6cf70807b429d87077173415/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h?ref=350b0e595144cf7c6cf70807b429d87077173415", "patch": "@@ -235,7 +235,7 @@ class TypeCheckTopLevel : public TypeCheckBase\n     context->insert_type (function.get_mappings (), fnType);\n   }\n \n-  void visit (HIR::InherentImpl &impl_block) override\n+  void visit (HIR::ImplBlock &impl_block) override\n   {\n     std::vector<TyTy::SubstitutionParamMapping> substitutions;\n     if (impl_block.has_generics ())\n@@ -273,47 +273,6 @@ class TypeCheckTopLevel : public TypeCheckBase\n \t\t\t\t\t  substitutions);\n   }\n \n-  void visit (HIR::TraitImpl &impl_block) override\n-  {\n-    std::vector<TyTy::SubstitutionParamMapping> substitutions;\n-    if (impl_block.has_generics ())\n-      {\n-\tfor (auto &generic_param : impl_block.get_generic_params ())\n-\t  {\n-\t    switch (generic_param.get ()->get_kind ())\n-\t      {\n-\t      case HIR::GenericParam::GenericKind::LIFETIME:\n-\t\t// Skipping Lifetime completely until better handling.\n-\t\tbreak;\n-\n-\t\tcase HIR::GenericParam::GenericKind::TYPE: {\n-\t\t  auto param_type\n-\t\t    = TypeResolveGenericParam::Resolve (generic_param.get ());\n-\t\t  context->insert_type (generic_param->get_mappings (),\n-\t\t\t\t\tparam_type);\n-\n-\t\t  substitutions.push_back (TyTy::SubstitutionParamMapping (\n-\t\t    static_cast<HIR::TypeParam &> (*generic_param),\n-\t\t    param_type));\n-\t\t}\n-\t\tbreak;\n-\t      }\n-\t  }\n-      }\n-\n-    // TODO\n-    // resolve the trait and check all items implemented\n-\n-    auto self\n-      = TypeCheckType::Resolve (impl_block.get_type ().get (), &substitutions);\n-    if (self == nullptr || self->get_kind () == TyTy::TypeKind::ERROR)\n-      return;\n-\n-    for (auto &impl_item : impl_block.get_impl_items ())\n-      TypeCheckTopLevelImplItem::Resolve (impl_item.get (), self,\n-\t\t\t\t\t  substitutions);\n-  }\n-\n private:\n   TypeCheckTopLevel () : TypeCheckBase () {}\n };"}, {"sha": "11f0c3a671aed70e387af7a4d77910b6d128f2be", "filename": "gcc/rust/typecheck/rust-tycheck-dump.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/350b0e595144cf7c6cf70807b429d87077173415/gcc%2Frust%2Ftypecheck%2Frust-tycheck-dump.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/350b0e595144cf7c6cf70807b429d87077173415/gcc%2Frust%2Ftypecheck%2Frust-tycheck-dump.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tycheck-dump.h?ref=350b0e595144cf7c6cf70807b429d87077173415", "patch": "@@ -48,7 +48,7 @@ class TypeResolverDump : public TypeCheckBase\n \t    + \"\\n\";\n   }\n \n-  void visit (HIR::InherentImpl &impl_block) override\n+  void visit (HIR::ImplBlock &impl_block) override\n   {\n     dump += indent () + \"impl \"\n \t    + type_string (impl_block.get_type ()->get_mappings ()) + \" {\\n\";"}, {"sha": "fb8070ab942c95f8cc2f16ab680f788732968fab", "filename": "gcc/rust/util/rust-hir-map.cc", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/350b0e595144cf7c6cf70807b429d87077173415/gcc%2Frust%2Futil%2Frust-hir-map.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/350b0e595144cf7c6cf70807b429d87077173415/gcc%2Frust%2Futil%2Frust-hir-map.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-hir-map.cc?ref=350b0e595144cf7c6cf70807b429d87077173415", "patch": "@@ -261,16 +261,15 @@ Mappings::lookup_hir_item (CrateNum crateNum, HirId id)\n \n void\n Mappings::insert_hir_implitem (CrateNum crateNum, HirId id,\n-\t\t\t       HirId parent_impl_id,\n-\t\t\t       HIR::InherentImplItem *item)\n+\t\t\t       HirId parent_impl_id, HIR::ImplItem *item)\n {\n   rust_assert (lookup_hir_implitem (crateNum, id, nullptr) == nullptr);\n   hirImplItemMappings[crateNum][id]\n-    = std::pair<HirId, HIR::InherentImplItem *> (parent_impl_id, item);\n+    = std::pair<HirId, HIR::ImplItem *> (parent_impl_id, item);\n   nodeIdToHirMappings[crateNum][item->get_impl_mappings ().get_nodeid ()] = id;\n }\n \n-HIR::InherentImplItem *\n+HIR::ImplItem *\n Mappings::lookup_hir_implitem (CrateNum crateNum, HirId id,\n \t\t\t       HirId *parent_impl_id)\n {\n@@ -282,7 +281,7 @@ Mappings::lookup_hir_implitem (CrateNum crateNum, HirId id,\n   if (iy == it->second.end ())\n     return nullptr;\n \n-  std::pair<HirId, HIR::InherentImplItem *> &ref = iy->second;\n+  std::pair<HirId, HIR::ImplItem *> &ref = iy->second;\n   if (parent_impl_id != nullptr)\n     *parent_impl_id = ref.first;\n \n@@ -527,7 +526,7 @@ Mappings::resolve_nodeid_to_stmt (CrateNum crate, NodeId id, HIR::Stmt **stmt)\n \n void\n Mappings::iterate_impl_items (\n-  std::function<bool (HirId, HIR::InherentImplItem *, HIR::InherentImpl *)> cb)\n+  std::function<bool (HirId, HIR::ImplItem *, HIR::ImplBlock *)> cb)\n {\n   for (auto it = hirImplItemMappings.begin (); it != hirImplItemMappings.end ();\n        it++)"}, {"sha": "cb3f12ba9a90488c07c23e6e0b8d6bf3d5653b8a", "filename": "gcc/rust/util/rust-hir-map.h", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/350b0e595144cf7c6cf70807b429d87077173415/gcc%2Frust%2Futil%2Frust-hir-map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/350b0e595144cf7c6cf70807b429d87077173415/gcc%2Frust%2Futil%2Frust-hir-map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-hir-map.h?ref=350b0e595144cf7c6cf70807b429d87077173415", "patch": "@@ -129,9 +129,9 @@ class Mappings\n   HIR::Item *lookup_hir_item (CrateNum crateNum, HirId id);\n \n   void insert_hir_implitem (CrateNum crateNum, HirId id, HirId parent_impl_id,\n-\t\t\t    HIR::InherentImplItem *item);\n-  HIR::InherentImplItem *lookup_hir_implitem (CrateNum crateNum, HirId id,\n-\t\t\t\t\t      HirId *parent_impl_id);\n+\t\t\t    HIR::ImplItem *item);\n+  HIR::ImplItem *lookup_hir_implitem (CrateNum crateNum, HirId id,\n+\t\t\t\t      HirId *parent_impl_id);\n \n   void insert_hir_expr (CrateNum crateNum, HirId id, HIR::Expr *expr);\n   HIR::Expr *lookup_hir_expr (CrateNum crateNum, HirId id);\n@@ -177,23 +177,22 @@ class Mappings\n     return hirNodesWithinCrate[crate];\n   }\n \n-  void insert_impl_item_mapping (HirId impl_item_id, HIR::InherentImpl *impl)\n+  void insert_impl_item_mapping (HirId impl_item_id, HIR::ImplBlock *impl)\n   {\n     rust_assert (hirImplItemsToImplMappings.find (impl_item_id)\n \t\t == hirImplItemsToImplMappings.end ());\n     hirImplItemsToImplMappings[impl_item_id] = impl;\n   }\n \n-  HIR::InherentImpl *lookup_associated_impl (HirId impl_item_id)\n+  HIR::ImplBlock *lookup_associated_impl (HirId impl_item_id)\n   {\n     auto lookup = hirImplItemsToImplMappings.find (impl_item_id);\n     rust_assert (lookup != hirImplItemsToImplMappings.end ());\n     return lookup->second;\n   }\n \n   void iterate_impl_items (\n-    std::function<bool (HirId, HIR::InherentImplItem *, HIR::InherentImpl *)>\n-      cb);\n+    std::function<bool (HirId, HIR::ImplItem *, HIR::ImplBlock *)> cb);\n \n private:\n   Mappings ();\n@@ -217,11 +216,10 @@ class Mappings\n   std::map<CrateNum, std::map<HirId, HIR::FunctionParam *> > hirParamMappings;\n   std::map<CrateNum, std::map<HirId, HIR::StructExprField *> >\n     hirStructFieldMappings;\n-  std::map<CrateNum,\n-\t   std::map<HirId, std::pair<HirId, HIR::InherentImplItem *> > >\n+  std::map<CrateNum, std::map<HirId, std::pair<HirId, HIR::ImplItem *> > >\n     hirImplItemMappings;\n   std::map<CrateNum, std::map<HirId, HIR::SelfParam *> > hirSelfParamMappings;\n-  std::map<HirId, HIR::InherentImpl *> hirImplItemsToImplMappings;\n+  std::map<HirId, HIR::ImplBlock *> hirImplItemsToImplMappings;\n \n   // location info\n   std::map<CrateNum, std::map<NodeId, Location> > locations;"}]}