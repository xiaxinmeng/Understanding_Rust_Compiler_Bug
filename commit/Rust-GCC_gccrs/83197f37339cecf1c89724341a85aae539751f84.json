{"sha": "83197f37339cecf1c89724341a85aae539751f84", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODMxOTdmMzczMzljZWNmMWM4OTcyNDM0MWE4NWFhZTUzOTc1MWY4NA==", "commit": {"author": {"name": "Ira Rosen", "email": "ira.rosen@linaro.org", "date": "2011-06-30T06:37:41Z"}, "committer": {"name": "Ira Rosen", "email": "irar@gcc.gnu.org", "date": "2011-06-30T06:37:41Z"}, "message": "tree-vect-loop.c (vect_determine_vectorization_factor): Handle both pattern and original statements if necessary.\n\n\n        * tree-vect-loop.c (vect_determine_vectorization_factor): Handle\n        both pattern and original statements if necessary.\n        (vect_transform_loop): Likewise.\n        * tree-vect-patterns.c (vect_pattern_recog): Update documentation.\n        * tree-vect-stmts.c (vect_mark_relevant): Add new argument.\n        Mark the pattern statement only if the original statement doesn't\n        have its own uses.\n        (process_use): Call vect_mark_relevant with additional parameter.\n        (vect_mark_stmts_to_be_vectorized): Likewise.\n        (vect_get_vec_def_for_operand): Use vectorized pattern statement.\n        (vect_analyze_stmt): Handle both pattern and original statements\n        if necessary.\n        (vect_transform_stmt): Don't store vectorized pattern statement\n        in the original statement.\n        (vect_is_simple_use_1): Use related pattern statement only if the\n        original statement is irrelevant.\n        * tree-vect-slp.c (vect_get_and_check_slp_defs): Likewise.\n\nFrom-SVN: r175681", "tree": {"sha": "4f3bebd5f33136e8f6f42ff799dc8c7eb3704c7e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4f3bebd5f33136e8f6f42ff799dc8c7eb3704c7e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/83197f37339cecf1c89724341a85aae539751f84", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83197f37339cecf1c89724341a85aae539751f84", "html_url": "https://github.com/Rust-GCC/gccrs/commit/83197f37339cecf1c89724341a85aae539751f84", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83197f37339cecf1c89724341a85aae539751f84/comments", "author": null, "committer": null, "parents": [{"sha": "0dcd5f9db100c5c9d4209c04fdbe0f5bd75f2751", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0dcd5f9db100c5c9d4209c04fdbe0f5bd75f2751", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0dcd5f9db100c5c9d4209c04fdbe0f5bd75f2751"}], "stats": {"total": 343, "additions": 287, "deletions": 56}, "files": [{"sha": "9db422d5772120618c54cd9e6068edcd2b5eaf23", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83197f37339cecf1c89724341a85aae539751f84/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83197f37339cecf1c89724341a85aae539751f84/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=83197f37339cecf1c89724341a85aae539751f84", "patch": "@@ -1,3 +1,23 @@\n+2011-06-30  Ira Rosen  <ira.rosen@linaro.org>\n+\n+\t* tree-vect-loop.c (vect_determine_vectorization_factor): Handle\n+\tboth pattern and original statements if necessary.\n+\t(vect_transform_loop): Likewise.\n+\t* tree-vect-patterns.c (vect_pattern_recog): Update documentation.\n+\t* tree-vect-stmts.c (vect_mark_relevant): Add new argument.\n+\tMark the pattern statement only if the original statement doesn't\n+\thave its own uses.\n+\t(process_use): Call vect_mark_relevant with additional parameter.\n+\t(vect_mark_stmts_to_be_vectorized): Likewise.\n+\t(vect_get_vec_def_for_operand): Use vectorized pattern statement.\n+\t(vect_analyze_stmt): Handle both pattern and original statements\n+\tif necessary.\n+\t(vect_transform_stmt): Don't store vectorized pattern statement\n+\tin the original statement.\n+\t(vect_is_simple_use_1): Use related pattern statement only if the\n+\toriginal statement is irrelevant.\n+\t* tree-vect-slp.c (vect_get_and_check_slp_defs): Likewise.\n+\n 2011-06-29  Changpeng Fang <changpeng.fang@amd.com>\n \n \t* config/i386/i386.opt (mprefer-avx128): Redefine the flag as a Mask option."}, {"sha": "ac678156cc3e04e645802b07fbf7516253bb7589", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83197f37339cecf1c89724341a85aae539751f84/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83197f37339cecf1c89724341a85aae539751f84/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=83197f37339cecf1c89724341a85aae539751f84", "patch": "@@ -1,3 +1,8 @@\n+2011-06-30  Ira Rosen  <ira.rosen@linaro.org>\n+\n+\t* gcc.dg/vect/slp-widen-mult-half.c: New test.\n+\t* gcc.dg/vect/vect-widen-mult-half.c: New test.\n+\n 2011-06-29  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/49216"}, {"sha": "e7a0f2a75d491b55583d17a9f51f69ead8bd4a27", "filename": "gcc/testsuite/gcc.dg/vect/slp-widen-mult-half.c", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83197f37339cecf1c89724341a85aae539751f84/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-widen-mult-half.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83197f37339cecf1c89724341a85aae539751f84/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-widen-mult-half.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-widen-mult-half.c?ref=83197f37339cecf1c89724341a85aae539751f84", "patch": "@@ -0,0 +1,52 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include \"tree-vect.h\"\n+#include <stdlib.h>\n+\n+#define N 32\n+#define COEF 32470\n+#define COEF2 324700\n+\n+unsigned char in[N];\n+int out[N];\n+int out2[N];\n+\n+__attribute__ ((noinline)) void\n+foo ()\n+{\n+  int i;\n+\n+  for (i = 0; i < N/2; i++)\n+    {\n+      out[2*i] = in[2*i] * COEF;\n+      out2[2*i] = in[2*i] + COEF2;\n+      out[2*i+1] = in[2*i+1] * COEF;\n+      out2[2*i+1] = in[2*i+1] + COEF2;\n+    }\n+}\n+\n+int main (void)\n+{\n+  int i;\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      in[i] = i;\n+      __asm__ volatile (\"\");\n+    }\n+\n+  foo ();\n+\n+  for (i = 0; i < N; i++)\n+    if (out[i] != in[i] * COEF || out2[i] != in[i] + COEF2)\n+      abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target vect_widen_mult_hi_to_si } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 2 \"vect\" { target vect_widen_mult_hi_to_si } } } */\n+/* { dg-final { scan-tree-dump-times \"vect_recog_widen_mult_pattern: detected\" 2 \"vect\" { target vect_widen_mult_hi_to_si_pattern } } } */\n+/* { dg-final { scan-tree-dump-times \"pattern recognized\" 2 \"vect\" { target vect_widen_mult_hi_to_si_pattern } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+"}, {"sha": "3fb162de79a22034a19393d7ea2dfb9ca24b0929", "filename": "gcc/testsuite/gcc.dg/vect/vect-widen-mult-half.c", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83197f37339cecf1c89724341a85aae539751f84/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-widen-mult-half.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83197f37339cecf1c89724341a85aae539751f84/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-widen-mult-half.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-widen-mult-half.c?ref=83197f37339cecf1c89724341a85aae539751f84", "patch": "@@ -0,0 +1,49 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include \"tree-vect.h\"\n+#include <stdlib.h>\n+\n+#define N 32\n+#define COEF 32470\n+#define COEF2 324700\n+\n+unsigned char in[N];\n+int out[N];\n+int out2[N];\n+\n+__attribute__ ((noinline)) void\n+foo (int a)\n+{\n+  int i;\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      out[i] = in[i] * COEF;\n+      out2[i] = in[i] + a;\n+    }\n+}\n+\n+int main (void)\n+{\n+  int i;\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      in[i] = i;\n+      __asm__ volatile (\"\");\n+    }\n+\n+  foo (COEF2);\n+\n+  for (i = 0; i < N; i++)\n+    if (out[i] != in[i] * COEF || out2[i] != in[i] + COEF2)\n+      abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target vect_widen_mult_hi_to_si } } } */\n+/* { dg-final { scan-tree-dump-times \"vect_recog_widen_mult_pattern: detected\" 1 \"vect\" { target vect_widen_mult_hi_to_si_pattern } } } */\n+/* { dg-final { scan-tree-dump-times \"pattern recognized\" 1 \"vect\" { target vect_widen_mult_hi_to_si_pattern } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+"}, {"sha": "0352607732ba0a48fdad9fb993aca0294bed012b", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 47, "deletions": 10, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83197f37339cecf1c89724341a85aae539751f84/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83197f37339cecf1c89724341a85aae539751f84/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=83197f37339cecf1c89724341a85aae539751f84", "patch": "@@ -181,6 +181,8 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n   stmt_vec_info stmt_info;\n   int i;\n   HOST_WIDE_INT dummy;\n+  gimple stmt, pattern_stmt = NULL;\n+  bool analyze_pattern_stmt = false;\n \n   if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"=== vect_determine_vectorization_factor ===\");\n@@ -241,11 +243,19 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n \t    }\n \t}\n \n-      for (si = gsi_start_bb (bb); !gsi_end_p (si); gsi_next (&si))\n+      for (si = gsi_start_bb (bb); !gsi_end_p (si) || analyze_pattern_stmt;)\n         {\n-\t  tree vf_vectype;\n-\t  gimple stmt = gsi_stmt (si), pattern_stmt;\n-\t  stmt_info = vinfo_for_stmt (stmt);\n+          tree vf_vectype;\n+\n+          if (analyze_pattern_stmt)\n+            {\n+              stmt = pattern_stmt;\n+              analyze_pattern_stmt = false;\n+            }\n+          else\n+            stmt = gsi_stmt (si);\n+\n+          stmt_info = vinfo_for_stmt (stmt);\n \n \t  if (vect_print_dump_info (REPORT_DETAILS))\n \t    {\n@@ -276,9 +286,15 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n \t        {\n \t          if (vect_print_dump_info (REPORT_DETAILS))\n \t            fprintf (vect_dump, \"skip.\");\n+                  gsi_next (&si);\n \t          continue;\n                 }\n \t    }\n+          else if (STMT_VINFO_IN_PATTERN_P (stmt_info)\n+                   && (pattern_stmt = STMT_VINFO_RELATED_STMT (stmt_info))\n+                   && (STMT_VINFO_RELEVANT_P (vinfo_for_stmt (pattern_stmt))\n+                       || STMT_VINFO_LIVE_P (vinfo_for_stmt (pattern_stmt))))\n+            analyze_pattern_stmt = true;\n \n \t  if (gimple_get_lhs (stmt) == NULL_TREE)\n \t    {\n@@ -383,6 +399,9 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n \t  if (!vectorization_factor\n \t      || (nunits > vectorization_factor))\n \t    vectorization_factor = nunits;\n+\n+          if (!analyze_pattern_stmt)\n+            gsi_next (&si);\n         }\n     }\n \n@@ -5057,6 +5076,8 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n   tree cond_expr = NULL_TREE;\n   gimple_seq cond_expr_stmt_list = NULL;\n   bool do_peeling_for_loop_bound;\n+  gimple stmt, pattern_stmt;\n+  bool transform_pattern_stmt = false;\n \n   if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"=== vec_transform_loop ===\");\n@@ -5144,11 +5165,19 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n \t    }\n \t}\n \n-      for (si = gsi_start_bb (bb); !gsi_end_p (si);)\n+      pattern_stmt = NULL;\n+      for (si = gsi_start_bb (bb); !gsi_end_p (si) || transform_pattern_stmt;)\n \t{\n-\t  gimple stmt = gsi_stmt (si), pattern_stmt;\n \t  bool is_store;\n \n+          if (transform_pattern_stmt)\n+            {\n+              stmt = pattern_stmt;\n+              transform_pattern_stmt = false;\n+            }\n+          else\n+            stmt = gsi_stmt (si);\n+\n \t  if (vect_print_dump_info (REPORT_DETAILS))\n \t    {\n \t      fprintf (vect_dump, \"------>vectorizing statement: \");\n@@ -5186,6 +5215,11 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n \t          continue;\n                 }\n \t    }\n+          else if (STMT_VINFO_IN_PATTERN_P (stmt_info)\n+                   && (pattern_stmt = STMT_VINFO_RELATED_STMT (stmt_info))\n+                   && (STMT_VINFO_RELEVANT_P (vinfo_for_stmt (pattern_stmt))\n+                       || STMT_VINFO_LIVE_P (vinfo_for_stmt (pattern_stmt))))\n+            transform_pattern_stmt = true;\n \n \t  gcc_assert (STMT_VINFO_VECTYPE (stmt_info));\n \t  nunits = (unsigned int) TYPE_VECTOR_SUBPARTS (\n@@ -5214,8 +5248,9 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n \t      /* Hybrid SLP stmts must be vectorized in addition to SLP.  */\n \t      if (!vinfo_for_stmt (stmt) || PURE_SLP_STMT (stmt_info))\n \t\t{\n-\t\t  gsi_next (&si);\n-\t\t  continue;\n+                  if (!transform_pattern_stmt)\n+ \t\t    gsi_next (&si);\n+  \t\t  continue;\n \t\t}\n \t    }\n \n@@ -5234,7 +5269,7 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n \t\t     the chain.  */\n \t\t  vect_remove_stores (GROUP_FIRST_ELEMENT (stmt_info));\n \t\t  gsi_remove (&si, true);\n-\t\t  continue;\n+ \t\t  continue;\n \t\t}\n \t      else\n \t\t{\n@@ -5244,7 +5279,9 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n \t\t  continue;\n \t\t}\n \t    }\n-\t  gsi_next (&si);\n+\n+          if (!transform_pattern_stmt)\n+ \t    gsi_next (&si);\n \t}\t\t        /* stmts in BB */\n     }\t\t\t\t/* BBs in loop */\n "}, {"sha": "758d4bcbaed8e8f7ee4206e2628d0faccb31fe01", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83197f37339cecf1c89724341a85aae539751f84/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83197f37339cecf1c89724341a85aae539751f84/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=83197f37339cecf1c89724341a85aae539751f84", "patch": "@@ -1016,10 +1016,8 @@ vect_pattern_recog_1 (\n \n    If vectorization succeeds, vect_transform_stmt will skip over {S1,S2,S3}\n    (because they are marked as irrelevant).  It will vectorize S6, and record\n-   a pointer to the new vector stmt VS6 both from S6 (as usual), and also\n-   from S4.  We do that so that when we get to vectorizing stmts that use the\n-   def of S4 (like S5 that uses a_0), we'll know where to take the relevant\n-   vector-def from.  S4 will be skipped, and S5 will be vectorized as usual:\n+   a pointer to the new vector stmt VS6 from S6 (as usual).\n+   S4 will be skipped, and S5 will be vectorized as usual:\n \n                                   in_pattern_p  related_stmt    vec_stmt\n          S1: a_i = ....                 -       -               -\n@@ -1035,7 +1033,21 @@ vect_pattern_recog_1 (\n    elsewhere), and we'll end up with:\n \n         VS6: va_new = ....\n-        VS5: ... = ..vuse(va_new)..  */\n+        VS5: ... = ..vuse(va_new)..\n+\n+   In case of more than one pattern statements, e.g., widen-mult with\n+   intermediate type:\n+\n+     S1  a_t = ;\n+     S2  a_T = (TYPE) a_t;\n+           '--> S3: a_it = (interm_type) a_t;\n+     S4  prod_T = a_T * CONST;\n+           '--> S5: prod_T' = a_it w* CONST;\n+\n+   there may be other users of a_T outside the pattern.  In that case S2 will\n+   be marked as relevant (as well as S3), and both S2 and S3 will be analyzed\n+   and vectorized.  The vector stmt VS2 will be recorded in S2, and VS3 will\n+   be recorded in S3.  */\n \n void\n vect_pattern_recog (loop_vec_info loop_vinfo)"}, {"sha": "60bc475c75ab435cfe666fb2282cb7919ff2b4bb", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83197f37339cecf1c89724341a85aae539751f84/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83197f37339cecf1c89724341a85aae539751f84/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=83197f37339cecf1c89724341a85aae539751f84", "patch": "@@ -152,7 +152,9 @@ vect_get_and_check_slp_defs (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n       if (loop && def_stmt && gimple_bb (def_stmt)\n           && flow_bb_inside_loop_p (loop, gimple_bb (def_stmt))\n           && vinfo_for_stmt (def_stmt)\n-          && STMT_VINFO_IN_PATTERN_P (vinfo_for_stmt (def_stmt)))\n+          && STMT_VINFO_IN_PATTERN_P (vinfo_for_stmt (def_stmt))\n+          && !STMT_VINFO_RELEVANT (vinfo_for_stmt (def_stmt))\n+          && !STMT_VINFO_LIVE_P (vinfo_for_stmt (def_stmt)))\n         {\n           if (!*first_stmt_dt0)\n             *pattern0 = true;"}, {"sha": "1d334b01b904098de4c138a920a043b8079d607c", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 94, "deletions": 40, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83197f37339cecf1c89724341a85aae539751f84/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83197f37339cecf1c89724341a85aae539751f84/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=83197f37339cecf1c89724341a85aae539751f84", "patch": "@@ -126,33 +126,72 @@ create_array_ref (tree type, tree ptr, struct data_reference *first_dr)\n \n static void\n vect_mark_relevant (VEC(gimple,heap) **worklist, gimple stmt,\n-\t\t    enum vect_relevant relevant, bool live_p)\n+\t\t    enum vect_relevant relevant, bool live_p,\n+\t\t    bool used_in_pattern)\n {\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   enum vect_relevant save_relevant = STMT_VINFO_RELEVANT (stmt_info);\n   bool save_live_p = STMT_VINFO_LIVE_P (stmt_info);\n+  gimple pattern_stmt;\n \n   if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"mark relevant %d, live %d.\", relevant, live_p);\n \n+  /* If this stmt is an original stmt in a pattern, we might need to mark its\n+     related pattern stmt instead of the original stmt.  However, such stmts\n+     may have their own uses that are not in any pattern, in such cases the\n+     stmt itself should be marked.  */\n   if (STMT_VINFO_IN_PATTERN_P (stmt_info))\n     {\n-      gimple pattern_stmt;\n+      bool found = false;\n+      if (!used_in_pattern)\n+        {\n+          imm_use_iterator imm_iter;\n+          use_operand_p use_p;\n+          gimple use_stmt;\n+          tree lhs;\n \n-      /* This is the last stmt in a sequence that was detected as a\n-         pattern that can potentially be vectorized.  Don't mark the stmt\n-         as relevant/live because it's not going to be vectorized.\n-         Instead mark the pattern-stmt that replaces it.  */\n+          if (is_gimple_assign (stmt))\n+            lhs = gimple_assign_lhs (stmt);\n+          else\n+            lhs = gimple_call_lhs (stmt);\n \n-      pattern_stmt = STMT_VINFO_RELATED_STMT (stmt_info);\n+          /* This use is out of pattern use, if LHS has other uses that are\n+             pattern uses, we should mark the stmt itself, and not the pattern\n+             stmt.  */\n+          FOR_EACH_IMM_USE_FAST (use_p, imm_iter, lhs)\n+            {\n+              if (is_gimple_debug (USE_STMT (use_p)))\n+                continue;\n+              use_stmt = USE_STMT (use_p);\n \n-      if (vect_print_dump_info (REPORT_DETAILS))\n-        fprintf (vect_dump, \"last stmt in pattern. don't mark relevant/live.\");\n-      stmt_info = vinfo_for_stmt (pattern_stmt);\n-      gcc_assert (STMT_VINFO_RELATED_STMT (stmt_info) == stmt);\n-      save_relevant = STMT_VINFO_RELEVANT (stmt_info);\n-      save_live_p = STMT_VINFO_LIVE_P (stmt_info);\n-      stmt = pattern_stmt;\n+              if (vinfo_for_stmt (use_stmt)\n+                  && STMT_VINFO_IN_PATTERN_P (vinfo_for_stmt (use_stmt)))\n+                {\n+                  found = true;\n+                  break;\n+                }\n+            }\n+        }\n+\n+      if (!found)\n+        {\n+          /* This is the last stmt in a sequence that was detected as a\n+             pattern that can potentially be vectorized.  Don't mark the stmt\n+             as relevant/live because it's not going to be vectorized.\n+             Instead mark the pattern-stmt that replaces it.  */\n+\n+          pattern_stmt = STMT_VINFO_RELATED_STMT (stmt_info);\n+\n+          if (vect_print_dump_info (REPORT_DETAILS))\n+            fprintf (vect_dump, \"last stmt in pattern. don't mark\"\n+                                \" relevant/live.\");\n+          stmt_info = vinfo_for_stmt (pattern_stmt);\n+          gcc_assert (STMT_VINFO_RELATED_STMT (stmt_info) == stmt);\n+          save_relevant = STMT_VINFO_RELEVANT (stmt_info);\n+          save_live_p = STMT_VINFO_LIVE_P (stmt_info);\n+          stmt = pattern_stmt;\n+        }\n     }\n \n   STMT_VINFO_LIVE_P (stmt_info) |= live_p;\n@@ -437,7 +476,8 @@ process_use (gimple stmt, tree use, loop_vec_info loop_vinfo, bool live_p,\n         }\n     }\n \n-  vect_mark_relevant (worklist, def_stmt, relevant, live_p);\n+  vect_mark_relevant (worklist, def_stmt, relevant, live_p,\n+                      is_pattern_stmt_p (stmt_vinfo));\n   return true;\n }\n \n@@ -494,7 +534,7 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n \t    }\n \n \t  if (vect_stmt_relevant_p (phi, loop_vinfo, &relevant, &live_p))\n-\t    vect_mark_relevant (&worklist, phi, relevant, live_p);\n+\t    vect_mark_relevant (&worklist, phi, relevant, live_p, false);\n \t}\n       for (si = gsi_start_bb (bb); !gsi_end_p (si); gsi_next (&si))\n \t{\n@@ -506,7 +546,7 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n \t    }\n \n \t  if (vect_stmt_relevant_p (stmt, loop_vinfo, &relevant, &live_p))\n-            vect_mark_relevant (&worklist, stmt, relevant, live_p);\n+            vect_mark_relevant (&worklist, stmt, relevant, live_p, false);\n \t}\n     }\n \n@@ -1184,7 +1224,14 @@ vect_get_vec_def_for_operand (tree op, gimple stmt, tree *scalar_def)\n \n         /* Get the def from the vectorized stmt.  */\n         def_stmt_info = vinfo_for_stmt (def_stmt);\n+\n         vec_stmt = STMT_VINFO_VEC_STMT (def_stmt_info);\n+        /* Get vectorized pattern statement.  */\n+        if (!vec_stmt\n+            && STMT_VINFO_IN_PATTERN_P (def_stmt_info)\n+            && !STMT_VINFO_RELEVANT (def_stmt_info))\n+          vec_stmt = STMT_VINFO_VEC_STMT (vinfo_for_stmt (\n+                       STMT_VINFO_RELATED_STMT (def_stmt_info)));\n         gcc_assert (vec_stmt);\n \tif (gimple_code (vec_stmt) == GIMPLE_PHI)\n \t  vec_oprnd = PHI_RESULT (vec_stmt);\n@@ -4863,6 +4910,7 @@ vect_analyze_stmt (gimple stmt, bool *need_to_vectorize, slp_tree node)\n   enum vect_relevant relevance = STMT_VINFO_RELEVANT (stmt_info);\n   bool ok;\n   tree scalar_type, vectype;\n+  gimple pattern_stmt;\n \n   if (vect_print_dump_info (REPORT_DETAILS))\n     {\n@@ -4884,16 +4932,22 @@ vect_analyze_stmt (gimple stmt, bool *need_to_vectorize, slp_tree node)\n      - any LABEL_EXPRs in the loop\n      - computations that are used only for array indexing or loop control.\n      In basic blocks we only analyze statements that are a part of some SLP\n-     instance, therefore, all the statements are relevant.  */\n+     instance, therefore, all the statements are relevant.\n \n+     Pattern statement need to be analyzed instead of the original statement\n+     if the original statement is not relevant.  Otherwise, we analyze both\n+     statements.  */\n+\n+  pattern_stmt = STMT_VINFO_RELATED_STMT (stmt_info);\n   if (!STMT_VINFO_RELEVANT_P (stmt_info)\n       && !STMT_VINFO_LIVE_P (stmt_info))\n     {\n-      gimple pattern_stmt = STMT_VINFO_RELATED_STMT (stmt_info);\n       if (STMT_VINFO_IN_PATTERN_P (stmt_info)\n+          && pattern_stmt\n           && (STMT_VINFO_RELEVANT_P (vinfo_for_stmt (pattern_stmt))\n               || STMT_VINFO_LIVE_P (vinfo_for_stmt (pattern_stmt))))\n         {\n+          /* Analyze PATTERN_STMT instead of the original stmt.  */\n           stmt = pattern_stmt;\n           stmt_info = vinfo_for_stmt (pattern_stmt);\n           if (vect_print_dump_info (REPORT_DETAILS))\n@@ -4910,6 +4964,21 @@ vect_analyze_stmt (gimple stmt, bool *need_to_vectorize, slp_tree node)\n           return true;\n         }\n     }\n+  else if (STMT_VINFO_IN_PATTERN_P (stmt_info)\n+           && pattern_stmt\n+           && (STMT_VINFO_RELEVANT_P (vinfo_for_stmt (pattern_stmt))\n+               || STMT_VINFO_LIVE_P (vinfo_for_stmt (pattern_stmt))))\n+    {\n+      /* Analyze PATTERN_STMT too.  */\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+        {\n+          fprintf (vect_dump, \"==> examining pattern statement: \");\n+          print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n+        }\n+\n+      if (!vect_analyze_stmt (pattern_stmt, need_to_vectorize, node))\n+        return false;\n+   }\n \n   switch (STMT_VINFO_DEF_TYPE (stmt_info))\n     {\n@@ -5043,7 +5112,6 @@ vect_transform_stmt (gimple stmt, gimple_stmt_iterator *gsi,\n   bool is_store = false;\n   gimple vec_stmt = NULL;\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n-  gimple orig_stmt_in_pattern, orig_scalar_stmt = stmt;\n   bool done;\n \n   switch (STMT_VINFO_TYPE (stmt_info))\n@@ -5182,25 +5250,7 @@ vect_transform_stmt (gimple stmt, gimple_stmt_iterator *gsi,\n     }\n \n   if (vec_stmt)\n-    {\n-      STMT_VINFO_VEC_STMT (stmt_info) = vec_stmt;\n-      orig_stmt_in_pattern = STMT_VINFO_RELATED_STMT (stmt_info);\n-      if (orig_stmt_in_pattern)\n-\t{\n-\t  stmt_vec_info stmt_vinfo = vinfo_for_stmt (orig_stmt_in_pattern);\n-\t  /* STMT was inserted by the vectorizer to replace a computation idiom.\n-\t     ORIG_STMT_IN_PATTERN is a stmt in the original sequence that\n-\t     computed this idiom.  We need to record a pointer to VEC_STMT in\n-\t     the stmt_info of ORIG_STMT_IN_PATTERN.  See more details in the\n-\t     documentation of vect_pattern_recog.  */\n-\t  if (STMT_VINFO_IN_PATTERN_P (stmt_vinfo))\n-\t    {\n-\t      gcc_assert (STMT_VINFO_RELATED_STMT (stmt_vinfo)\n-                           == orig_scalar_stmt);\n-\t      STMT_VINFO_VEC_STMT (stmt_vinfo) = vec_stmt;\n-\t    }\n-\t}\n-    }\n+    STMT_VINFO_VEC_STMT (stmt_info) = vec_stmt;\n \n   return is_store;\n }\n@@ -5587,8 +5637,12 @@ vect_is_simple_use_1 (tree operand, loop_vec_info loop_vinfo,\n       || *dt == vect_nested_cycle)\n     {\n       stmt_vec_info stmt_info = vinfo_for_stmt (*def_stmt);\n-      if (STMT_VINFO_IN_PATTERN_P (stmt_info))\n+\n+      if (STMT_VINFO_IN_PATTERN_P (stmt_info)\n+          && !STMT_VINFO_RELEVANT (stmt_info)\n+          && !STMT_VINFO_LIVE_P (stmt_info))\n \tstmt_info = vinfo_for_stmt (STMT_VINFO_RELATED_STMT (stmt_info));\n+\n       *vectype = STMT_VINFO_VECTYPE (stmt_info);\n       gcc_assert (*vectype != NULL_TREE);\n     }"}]}