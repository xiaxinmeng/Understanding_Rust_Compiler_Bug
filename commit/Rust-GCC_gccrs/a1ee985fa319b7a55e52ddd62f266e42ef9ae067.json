{"sha": "a1ee985fa319b7a55e52ddd62f266e42ef9ae067", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTFlZTk4NWZhMzE5YjdhNTVlNTJkZGQ2MmYyNjZlNDJlZjlhZTA2Nw==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "2008-07-19T16:22:12Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "2008-07-19T16:22:12Z"}, "message": "gfortran.h (operator): Remove macro.\n\n\t* gfortran.h (operator): Remove macro.\n\t(gfc_namespace, gfc_expr): Avoid C++ keywords.\n\t* arith.c (eval_intrinsic, eval_intrinsic_f2, eval_intrinsic_f3):\n\tLikewise.\n\t* decl.c (access_attr_decl): Likewise.\n\t* dependency.c (gfc_dep_compare_expr): Likewise.\n\t* dump-parse-tree.c (show_expr, show_uop, show_namespace):\n\tLikewise.\n\t* expr.c (gfc_copy_expr, gfc_type_convert_binary,\n\tsimplify_intrinsic_op, check_intrinsic_op): Likewise.\n\t* interface.c (fold_unary, gfc_match_generic_spec,\n\tgfc_match_interface, gfc_match_end_interface,\n\tcheck_operator_interface, check_uop_interfaces,\n\tgfc_check_interfaces, gfc_extend_expr, gfc_extend_assign,\n\tgfc_add_interface, gfc_current_interface_head,\n\tgfc_set_current_interface_head): Likewise.\n\t* iresolve.c (gfc_resolve_dot_product, gfc_resolve_matmul):\n\tLikewise.\n\t* matchexp.c (gfc_get_parentheses, build_node): Likewise.\n\t* module.c (gfc_use_rename, gfc_match_use, find_use_name_n,\n\tnumber_use_names, mio_expr, load_operator_interfaces, read_module,\n\twrite_operator, write_module): Likewise.\n\t* openmp.c (resolve_omp_atomic): Likewise.\n\t* resolve.c (resolve_operator, gfc_resolve_character_operator,\n\tgfc_resolve_uops): Likewise.\n\t* symbol.c (free_uop_tree, gfc_free_namespace): Likewise.\n\t* trans-expr.c (gfc_conv_expr_op): Likewise.\n\t* trans-openmp.c (gfc_trans_omp_atomic): Likewise.\n\nFrom-SVN: r137981", "tree": {"sha": "eed351bb3b2763a12eff13217ad87938370c269c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eed351bb3b2763a12eff13217ad87938370c269c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a1ee985fa319b7a55e52ddd62f266e42ef9ae067", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1ee985fa319b7a55e52ddd62f266e42ef9ae067", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a1ee985fa319b7a55e52ddd62f266e42ef9ae067", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1ee985fa319b7a55e52ddd62f266e42ef9ae067/comments", "author": null, "committer": null, "parents": [{"sha": "9aa433c2945d1f8d62961452bcd4e07f509815a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9aa433c2945d1f8d62961452bcd4e07f509815a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9aa433c2945d1f8d62961452bcd4e07f509815a8"}], "stats": {"total": 383, "additions": 206, "deletions": 177}, "files": [{"sha": "1435ea3e56e63d604a266c6a106a44a0c673e1dd", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1ee985fa319b7a55e52ddd62f266e42ef9ae067/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1ee985fa319b7a55e52ddd62f266e42ef9ae067/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=a1ee985fa319b7a55e52ddd62f266e42ef9ae067", "patch": "@@ -1,3 +1,34 @@\n+2008-07-19  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* gfortran.h (operator): Remove macro.\n+\t(gfc_namespace, gfc_expr): Avoid C++ keywords.\n+\t* arith.c (eval_intrinsic, eval_intrinsic_f2, eval_intrinsic_f3):\n+\tLikewise.\n+\t* decl.c (access_attr_decl): Likewise.\n+\t* dependency.c (gfc_dep_compare_expr): Likewise.\n+\t* dump-parse-tree.c (show_expr, show_uop, show_namespace):\n+\tLikewise.\n+\t* expr.c (gfc_copy_expr, gfc_type_convert_binary,\n+\tsimplify_intrinsic_op, check_intrinsic_op): Likewise.\n+\t* interface.c (fold_unary, gfc_match_generic_spec,\n+\tgfc_match_interface, gfc_match_end_interface,\n+\tcheck_operator_interface, check_uop_interfaces,\n+\tgfc_check_interfaces, gfc_extend_expr, gfc_extend_assign,\n+\tgfc_add_interface, gfc_current_interface_head,\n+\tgfc_set_current_interface_head): Likewise.\n+\t* iresolve.c (gfc_resolve_dot_product, gfc_resolve_matmul):\n+\tLikewise.\n+\t* matchexp.c (gfc_get_parentheses, build_node): Likewise.\n+\t* module.c (gfc_use_rename, gfc_match_use, find_use_name_n,\n+\tnumber_use_names, mio_expr, load_operator_interfaces, read_module,\n+\twrite_operator, write_module): Likewise.\n+\t* openmp.c (resolve_omp_atomic): Likewise.\n+\t* resolve.c (resolve_operator, gfc_resolve_character_operator,\n+\tgfc_resolve_uops): Likewise.\n+\t* symbol.c (free_uop_tree, gfc_free_namespace): Likewise.\n+\t* trans-expr.c (gfc_conv_expr_op): Likewise.\n+\t* trans-openmp.c (gfc_trans_omp_atomic): Likewise.\n+\n 2008-07-19  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* gfortran.h (protected): Remove macro."}, {"sha": "38b71629df6e2cd94781754cc5fe0a2d559db7b3", "filename": "gcc/fortran/arith.c", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1ee985fa319b7a55e52ddd62f266e42ef9ae067/gcc%2Ffortran%2Farith.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1ee985fa319b7a55e52ddd62f266e42ef9ae067/gcc%2Ffortran%2Farith.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Farith.c?ref=a1ee985fa319b7a55e52ddd62f266e42ef9ae067", "patch": "@@ -1552,7 +1552,7 @@ eval_f;\n    operands are array constructors.  */\n \n static gfc_expr *\n-eval_intrinsic (gfc_intrinsic_op operator,\n+eval_intrinsic (gfc_intrinsic_op op,\n \t\teval_f eval, gfc_expr *op1, gfc_expr *op2)\n {\n   gfc_expr temp, *result;\n@@ -1561,7 +1561,7 @@ eval_intrinsic (gfc_intrinsic_op operator,\n \n   gfc_clear_ts (&temp.ts);\n \n-  switch (operator)\n+  switch (op)\n     {\n     /* Logical unary  */\n     case INTRINSIC_NOT:\n@@ -1650,19 +1650,19 @@ eval_intrinsic (gfc_intrinsic_op operator,\n \n       temp.expr_type = EXPR_OP;\n       gfc_clear_ts (&temp.ts);\n-      temp.value.op.operator = operator;\n+      temp.value.op.op = op;\n \n       temp.value.op.op1 = op1;\n       temp.value.op.op2 = op2;\n \n       gfc_type_convert_binary (&temp);\n \n-      if (operator == INTRINSIC_EQ || operator == INTRINSIC_NE\n-\t  || operator == INTRINSIC_GE || operator == INTRINSIC_GT\n-\t  || operator == INTRINSIC_LE || operator == INTRINSIC_LT\n-\t  || operator == INTRINSIC_EQ_OS || operator == INTRINSIC_NE_OS\n-\t  || operator == INTRINSIC_GE_OS || operator == INTRINSIC_GT_OS\n-\t  || operator == INTRINSIC_LE_OS || operator == INTRINSIC_LT_OS)\n+      if (op == INTRINSIC_EQ || op == INTRINSIC_NE\n+\t  || op == INTRINSIC_GE || op == INTRINSIC_GT\n+\t  || op == INTRINSIC_LE || op == INTRINSIC_LT\n+\t  || op == INTRINSIC_EQ_OS || op == INTRINSIC_NE_OS\n+\t  || op == INTRINSIC_GE_OS || op == INTRINSIC_GT_OS\n+\t  || op == INTRINSIC_LE_OS || op == INTRINSIC_LT_OS)\n \t{\n \t  temp.ts.type = BT_LOGICAL;\n \t  temp.ts.kind = gfc_default_logical_kind;\n@@ -1690,7 +1690,7 @@ eval_intrinsic (gfc_intrinsic_op operator,\n     }\n \n   /* Try to combine the operators.  */\n-  if (operator == INTRINSIC_POWER && op2->ts.type != BT_INTEGER)\n+  if (op == INTRINSIC_POWER && op2->ts.type != BT_INTEGER)\n     goto runtime;\n \n   if (op1->expr_type != EXPR_CONSTANT\n@@ -1725,7 +1725,7 @@ eval_intrinsic (gfc_intrinsic_op operator,\n   result->ts = temp.ts;\n \n   result->expr_type = EXPR_OP;\n-  result->value.op.operator = operator;\n+  result->value.op.op = op;\n \n   result->value.op.op1 = op1;\n   result->value.op.op2 = op2;\n@@ -1806,7 +1806,7 @@ reduce_binary0 (gfc_expr *op1, gfc_expr *op2)\n \n \n static gfc_expr *\n-eval_intrinsic_f2 (gfc_intrinsic_op operator,\n+eval_intrinsic_f2 (gfc_intrinsic_op op,\n \t\t   arith (*eval) (gfc_expr *, gfc_expr **),\n \t\t   gfc_expr *op1, gfc_expr *op2)\n {\n@@ -1816,22 +1816,22 @@ eval_intrinsic_f2 (gfc_intrinsic_op operator,\n   if (op2 == NULL)\n     {\n       if (gfc_zero_size_array (op1))\n-\treturn eval_type_intrinsic0 (operator, op1);\n+\treturn eval_type_intrinsic0 (op, op1);\n     }\n   else\n     {\n       result = reduce_binary0 (op1, op2);\n       if (result != NULL)\n-\treturn eval_type_intrinsic0 (operator, result);\n+\treturn eval_type_intrinsic0 (op, result);\n     }\n \n   f.f2 = eval;\n-  return eval_intrinsic (operator, f, op1, op2);\n+  return eval_intrinsic (op, f, op1, op2);\n }\n \n \n static gfc_expr *\n-eval_intrinsic_f3 (gfc_intrinsic_op operator,\n+eval_intrinsic_f3 (gfc_intrinsic_op op,\n \t\t   arith (*eval) (gfc_expr *, gfc_expr *, gfc_expr **),\n \t\t   gfc_expr *op1, gfc_expr *op2)\n {\n@@ -1840,10 +1840,10 @@ eval_intrinsic_f3 (gfc_intrinsic_op operator,\n \n   result = reduce_binary0 (op1, op2);\n   if (result != NULL)\n-    return eval_type_intrinsic0(operator, result);\n+    return eval_type_intrinsic0(op, result);\n \n   f.f3 = eval;\n-  return eval_intrinsic (operator, f, op1, op2);\n+  return eval_intrinsic (op, f, op1, op2);\n }\n \n "}, {"sha": "9fd54c56cc48ed34e721848c50ae563bfebaeade", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1ee985fa319b7a55e52ddd62f266e42ef9ae067/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1ee985fa319b7a55e52ddd62f266e42ef9ae067/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=a1ee985fa319b7a55e52ddd62f266e42ef9ae067", "patch": "@@ -5630,15 +5630,15 @@ access_attr_decl (gfc_statement st)\n   interface_type type;\n   gfc_user_op *uop;\n   gfc_symbol *sym;\n-  gfc_intrinsic_op operator;\n+  gfc_intrinsic_op op;\n   match m;\n \n   if (gfc_match (\" ::\") == MATCH_NO && gfc_match_space () == MATCH_NO)\n     goto done;\n \n   for (;;)\n     {\n-      m = gfc_match_generic_spec (&type, name, &operator);\n+      m = gfc_match_generic_spec (&type, name, &op);\n       if (m == MATCH_NO)\n \tgoto syntax;\n       if (m == MATCH_ERROR)\n@@ -5662,15 +5662,15 @@ access_attr_decl (gfc_statement st)\n \t  break;\n \n \tcase INTERFACE_INTRINSIC_OP:\n-\t  if (gfc_current_ns->operator_access[operator] == ACCESS_UNKNOWN)\n+\t  if (gfc_current_ns->operator_access[op] == ACCESS_UNKNOWN)\n \t    {\n-\t      gfc_current_ns->operator_access[operator] =\n+\t      gfc_current_ns->operator_access[op] =\n \t\t(st == ST_PUBLIC) ? ACCESS_PUBLIC : ACCESS_PRIVATE;\n \t    }\n \t  else\n \t    {\n \t      gfc_error (\"Access specification of the %s operator at %C has \"\n-\t\t\t \"already been specified\", gfc_op2string (operator));\n+\t\t\t \"already been specified\", gfc_op2string (op));\n \t      goto done;\n \t    }\n "}, {"sha": "3d98cac90ed1d3604c50599370022f3d92417775", "filename": "gcc/fortran/dependency.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1ee985fa319b7a55e52ddd62f266e42ef9ae067/gcc%2Ffortran%2Fdependency.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1ee985fa319b7a55e52ddd62f266e42ef9ae067/gcc%2Ffortran%2Fdependency.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdependency.c?ref=a1ee985fa319b7a55e52ddd62f266e42ef9ae067", "patch": "@@ -76,15 +76,15 @@ gfc_dep_compare_expr (gfc_expr *e1, gfc_expr *e2)\n   int i;\n \n   if (e1->expr_type == EXPR_OP\n-      && (e1->value.op.operator == INTRINSIC_UPLUS\n-\t  || e1->value.op.operator == INTRINSIC_PARENTHESES))\n+      && (e1->value.op.op == INTRINSIC_UPLUS\n+\t  || e1->value.op.op == INTRINSIC_PARENTHESES))\n     return gfc_dep_compare_expr (e1->value.op.op1, e2);\n   if (e2->expr_type == EXPR_OP\n-      && (e2->value.op.operator == INTRINSIC_UPLUS\n-\t  || e2->value.op.operator == INTRINSIC_PARENTHESES))\n+      && (e2->value.op.op == INTRINSIC_UPLUS\n+\t  || e2->value.op.op == INTRINSIC_PARENTHESES))\n     return gfc_dep_compare_expr (e1, e2->value.op.op1);\n \n-  if (e1->expr_type == EXPR_OP && e1->value.op.operator == INTRINSIC_PLUS)\n+  if (e1->expr_type == EXPR_OP && e1->value.op.op == INTRINSIC_PLUS)\n     {\n       /* Compare X+C vs. X.  */\n       if (e1->value.op.op2->expr_type == EXPR_CONSTANT\n@@ -93,7 +93,7 @@ gfc_dep_compare_expr (gfc_expr *e1, gfc_expr *e2)\n \treturn mpz_sgn (e1->value.op.op2->value.integer);\n \n       /* Compare P+Q vs. R+S.  */\n-      if (e2->expr_type == EXPR_OP && e2->value.op.operator == INTRINSIC_PLUS)\n+      if (e2->expr_type == EXPR_OP && e2->value.op.op == INTRINSIC_PLUS)\n \t{\n \t  int l, r;\n \n@@ -126,7 +126,7 @@ gfc_dep_compare_expr (gfc_expr *e1, gfc_expr *e2)\n     }\n \n   /* Compare X vs. X+C.  */\n-  if (e2->expr_type == EXPR_OP && e2->value.op.operator == INTRINSIC_PLUS)\n+  if (e2->expr_type == EXPR_OP && e2->value.op.op == INTRINSIC_PLUS)\n     {\n       if (e2->value.op.op2->expr_type == EXPR_CONSTANT\n \t  && e2->value.op.op2->ts.type == BT_INTEGER\n@@ -135,15 +135,15 @@ gfc_dep_compare_expr (gfc_expr *e1, gfc_expr *e2)\n     }\n \n   /* Compare X-C vs. X.  */\n-  if (e1->expr_type == EXPR_OP && e1->value.op.operator == INTRINSIC_MINUS)\n+  if (e1->expr_type == EXPR_OP && e1->value.op.op == INTRINSIC_MINUS)\n     {\n       if (e1->value.op.op2->expr_type == EXPR_CONSTANT\n \t  && e1->value.op.op2->ts.type == BT_INTEGER\n \t  && gfc_dep_compare_expr (e1->value.op.op1, e2) == 0)\n \treturn -mpz_sgn (e1->value.op.op2->value.integer);\n \n       /* Compare P-Q vs. R-S.  */\n-      if (e2->expr_type == EXPR_OP && e2->value.op.operator == INTRINSIC_MINUS)\n+      if (e2->expr_type == EXPR_OP && e2->value.op.op == INTRINSIC_MINUS)\n \t{\n \t  int l, r;\n \n@@ -163,7 +163,7 @@ gfc_dep_compare_expr (gfc_expr *e1, gfc_expr *e2)\n     }\n \n   /* Compare X vs. X-C.  */\n-  if (e2->expr_type == EXPR_OP && e2->value.op.operator == INTRINSIC_MINUS)\n+  if (e2->expr_type == EXPR_OP && e2->value.op.op == INTRINSIC_MINUS)\n     {\n       if (e2->value.op.op2->expr_type == EXPR_CONSTANT\n \t  && e2->value.op.op2->ts.type == BT_INTEGER\n@@ -196,7 +196,7 @@ gfc_dep_compare_expr (gfc_expr *e1, gfc_expr *e2)\n \n     case EXPR_OP:\n       /* Intrinsic operators are the same if their operands are the same.  */\n-      if (e1->value.op.operator != e2->value.op.operator)\n+      if (e1->value.op.op != e2->value.op.op)\n \treturn -2;\n       if (e1->value.op.op2 == 0)\n \t{"}, {"sha": "80ddda20c54194dbcf16e76eada3b7ed116a5bac", "filename": "gcc/fortran/dump-parse-tree.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1ee985fa319b7a55e52ddd62f266e42ef9ae067/gcc%2Ffortran%2Fdump-parse-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1ee985fa319b7a55e52ddd62f266e42ef9ae067/gcc%2Ffortran%2Fdump-parse-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdump-parse-tree.c?ref=a1ee985fa319b7a55e52ddd62f266e42ef9ae067", "patch": "@@ -437,7 +437,7 @@ show_expr (gfc_expr *p)\n \n     case EXPR_OP:\n       fputc ('(', dumpfile);\n-      switch (p->value.op.operator)\n+      switch (p->value.op.op)\n \t{\n \tcase INTRINSIC_UPLUS:\n \t  fputs (\"U+ \", dumpfile);\n@@ -737,7 +737,7 @@ show_uop (gfc_user_op *uop)\n   show_indent ();\n   fprintf (dumpfile, \"%s:\", uop->name);\n \n-  for (intr = uop->operator; intr; intr = intr->next)\n+  for (intr = uop->op; intr; intr = intr->next)\n     fprintf (dumpfile, \" %s\", intr->sym->name);\n }\n \n@@ -1897,7 +1897,7 @@ show_namespace (gfc_namespace *ns)\n       for (op = GFC_INTRINSIC_BEGIN; op != GFC_INTRINSIC_END; op++)\n \t{\n \t  /* User operator interfaces */\n-\t  intr = ns->operator[op];\n+\t  intr = ns->op[op];\n \t  if (intr == NULL)\n \t    continue;\n "}, {"sha": "c0c4fdd0d688e91fad4ce5c5e6911133f9267b97", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1ee985fa319b7a55e52ddd62f266e42ef9ae067/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1ee985fa319b7a55e52ddd62f266e42ef9ae067/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=a1ee985fa319b7a55e52ddd62f266e42ef9ae067", "patch": "@@ -480,7 +480,7 @@ gfc_copy_expr (gfc_expr *p)\n       break;\n \n     case EXPR_OP:\n-      switch (q->value.op.operator)\n+      switch (q->value.op.op)\n \t{\n \tcase INTRINSIC_NOT:\n \tcase INTRINSIC_PARENTHESES:\n@@ -659,7 +659,7 @@ gfc_type_convert_binary (gfc_expr *e)\n       e->ts = op1->ts;\n \n       /* Special case for ** operator.  */\n-      if (e->value.op.operator == INTRINSIC_POWER)\n+      if (e->value.op.op == INTRINSIC_POWER)\n \tgoto done;\n \n       gfc_convert_type (e->value.op.op2, &e->ts, 2);\n@@ -830,12 +830,12 @@ simplify_intrinsic_op (gfc_expr *p, int type)\n   gfc_intrinsic_op op;\n   gfc_expr *op1, *op2, *result;\n \n-  if (p->value.op.operator == INTRINSIC_USER)\n+  if (p->value.op.op == INTRINSIC_USER)\n     return SUCCESS;\n \n   op1 = p->value.op.op1;\n   op2 = p->value.op.op2;\n-  op  = p->value.op.operator;\n+  op  = p->value.op.op;\n \n   if (gfc_simplify_expr (op1, type) == FAILURE)\n     return FAILURE;\n@@ -1840,7 +1840,7 @@ check_intrinsic_op (gfc_expr *e, try (*check_function) (gfc_expr *))\n   if ((*check_function) (op1) == FAILURE)\n     return FAILURE;\n \n-  switch (e->value.op.operator)\n+  switch (e->value.op.op)\n     {\n     case INTRINSIC_UPLUS:\n     case INTRINSIC_UMINUS:\n@@ -1883,7 +1883,7 @@ check_intrinsic_op (gfc_expr *e, try (*check_function) (gfc_expr *))\n       if (!numeric_type (et0 (op1)) || !numeric_type (et0 (op2)))\n \tgoto not_numeric;\n \n-      if (e->value.op.operator == INTRINSIC_POWER\n+      if (e->value.op.op == INTRINSIC_POWER\n \t  && check_function == check_init_expr && et0 (op2) != BT_INTEGER)\n \t{\n \t  if (gfc_notify_std (GFC_STD_F2003,\"Fortran 2003: Noninteger \""}, {"sha": "e8a4cf29c1e5355aa573cd9057a28cee61d23276", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1ee985fa319b7a55e52ddd62f266e42ef9ae067/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1ee985fa319b7a55e52ddd62f266e42ef9ae067/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=a1ee985fa319b7a55e52ddd62f266e42ef9ae067", "patch": "@@ -982,8 +982,6 @@ gfc_interface;\n \n #define gfc_get_interface() XCNEW (gfc_interface)\n \n-/* FIXME: This macro is temporary until we convert everything.  */\n-#define operator op\n /* User operator nodes.  These are like stripped down symbols.  */\n typedef struct\n {\n@@ -1184,7 +1182,7 @@ typedef struct gfc_namespace\n   /* Points to the equivalence groups produced by trans_common.  */\n   struct gfc_equiv_list *equiv_lists;\n \n-  gfc_interface *operator[GFC_INTRINSIC_OPS];\n+  gfc_interface *op[GFC_INTRINSIC_OPS];\n \n   /* Points to the parent namespace, i.e. the namespace of a module or\n      procedure in which the procedure belonging to this namespace is\n@@ -1495,7 +1493,7 @@ typedef struct gfc_expr\n \n     struct\n     {\n-      gfc_intrinsic_op operator;\n+      gfc_intrinsic_op op;\n       gfc_user_op *uop;\n       struct gfc_expr *op1, *op2;\n     }"}, {"sha": "0fa5b57af85b435904786f1ca535a8c522204204", "filename": "gcc/fortran/interface.c", "status": "modified", "additions": 78, "deletions": 78, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1ee985fa319b7a55e52ddd62f266e42ef9ae067/gcc%2Ffortran%2Finterface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1ee985fa319b7a55e52ddd62f266e42ef9ae067/gcc%2Ffortran%2Finterface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finterface.c?ref=a1ee985fa319b7a55e52ddd62f266e42ef9ae067", "patch": "@@ -95,32 +95,32 @@ gfc_free_interface (gfc_interface *intr)\n    minus respectively, leaving the rest unchanged.  */\n \n static gfc_intrinsic_op\n-fold_unary (gfc_intrinsic_op operator)\n+fold_unary (gfc_intrinsic_op op)\n {\n-  switch (operator)\n+  switch (op)\n     {\n     case INTRINSIC_UPLUS:\n-      operator = INTRINSIC_PLUS;\n+      op = INTRINSIC_PLUS;\n       break;\n     case INTRINSIC_UMINUS:\n-      operator = INTRINSIC_MINUS;\n+      op = INTRINSIC_MINUS;\n       break;\n     default:\n       break;\n     }\n \n-  return operator;\n+  return op;\n }\n \n \n /* Match a generic specification.  Depending on which type of\n-   interface is found, the 'name' or 'operator' pointers may be set.\n+   interface is found, the 'name' or 'op' pointers may be set.\n    This subroutine doesn't return MATCH_NO.  */\n \n match\n gfc_match_generic_spec (interface_type *type,\n \t\t\tchar *name,\n-\t\t\tgfc_intrinsic_op *operator)\n+\t\t\tgfc_intrinsic_op *op)\n {\n   char buffer[GFC_MAX_SYMBOL_LEN + 1];\n   match m;\n@@ -129,14 +129,14 @@ gfc_match_generic_spec (interface_type *type,\n   if (gfc_match (\" assignment ( = )\") == MATCH_YES)\n     {\n       *type = INTERFACE_INTRINSIC_OP;\n-      *operator = INTRINSIC_ASSIGN;\n+      *op = INTRINSIC_ASSIGN;\n       return MATCH_YES;\n     }\n \n   if (gfc_match (\" operator ( %o )\", &i) == MATCH_YES)\n     {\t\t\t\t/* Operator i/f */\n       *type = INTERFACE_INTRINSIC_OP;\n-      *operator = fold_unary (i);\n+      *op = fold_unary (i);\n       return MATCH_YES;\n     }\n \n@@ -184,12 +184,12 @@ gfc_match_interface (void)\n   char name[GFC_MAX_SYMBOL_LEN + 1];\n   interface_type type;\n   gfc_symbol *sym;\n-  gfc_intrinsic_op operator;\n+  gfc_intrinsic_op op;\n   match m;\n \n   m = gfc_match_space ();\n \n-  if (gfc_match_generic_spec (&type, name, &operator) == MATCH_ERROR)\n+  if (gfc_match_generic_spec (&type, name, &op) == MATCH_ERROR)\n     return MATCH_ERROR;\n \n   /* If we're not looking at the end of the statement now, or if this\n@@ -229,7 +229,7 @@ gfc_match_interface (void)\n       break;\n \n     case INTERFACE_INTRINSIC_OP:\n-      current_interface.op = operator;\n+      current_interface.op = op;\n       break;\n \n     case INTERFACE_NAMELESS:\n@@ -275,12 +275,12 @@ gfc_match_end_interface (void)\n {\n   char name[GFC_MAX_SYMBOL_LEN + 1];\n   interface_type type;\n-  gfc_intrinsic_op operator;\n+  gfc_intrinsic_op op;\n   match m;\n \n   m = gfc_match_space ();\n \n-  if (gfc_match_generic_spec (&type, name, &operator) == MATCH_ERROR)\n+  if (gfc_match_generic_spec (&type, name, &op) == MATCH_ERROR)\n     return MATCH_ERROR;\n \n   /* If we're not looking at the end of the statement now, or if this\n@@ -308,7 +308,7 @@ gfc_match_end_interface (void)\n       break;\n \n     case INTERFACE_INTRINSIC_OP:\n-      if (type != current_interface.type || operator != current_interface.op)\n+      if (type != current_interface.type || op != current_interface.op)\n \t{\n \n \t  if (current_interface.op == INTRINSIC_ASSIGN)\n@@ -538,7 +538,7 @@ find_keyword_arg (const char *name, gfc_formal_arglist *f)\n    interfaces for that operator are legal.  */\n \n static void\n-check_operator_interface (gfc_interface *intr, gfc_intrinsic_op operator)\n+check_operator_interface (gfc_interface *intr, gfc_intrinsic_op op)\n {\n   gfc_formal_arglist *formal;\n   sym_intent i1, i2;\n@@ -585,10 +585,10 @@ check_operator_interface (gfc_interface *intr, gfc_intrinsic_op operator)\n \n   /* Only +, - and .not. can be unary operators.\n      .not. cannot be a binary operator.  */\n-  if (args == 0 || args > 2 || (args == 1 && operator != INTRINSIC_PLUS\n-\t\t\t\t&& operator != INTRINSIC_MINUS\n-\t\t\t\t&& operator != INTRINSIC_NOT)\n-      || (args == 2 && operator == INTRINSIC_NOT))\n+  if (args == 0 || args > 2 || (args == 1 && op != INTRINSIC_PLUS\n+\t\t\t\t&& op != INTRINSIC_MINUS\n+\t\t\t\t&& op != INTRINSIC_NOT)\n+      || (args == 2 && op == INTRINSIC_NOT))\n     {\n       gfc_error (\"Operator interface at %L has the wrong number of arguments\",\n \t\t &intr->sym->declared_at);\n@@ -597,7 +597,7 @@ check_operator_interface (gfc_interface *intr, gfc_intrinsic_op operator)\n \n   /* Check that intrinsics are mapped to functions, except\n      INTRINSIC_ASSIGN which should map to a subroutine.  */\n-  if (operator == INTRINSIC_ASSIGN)\n+  if (op == INTRINSIC_ASSIGN)\n     {\n       if (!sym->attr.subroutine)\n \t{\n@@ -638,7 +638,7 @@ check_operator_interface (gfc_interface *intr, gfc_intrinsic_op operator)\n     }\n \n   /* Check intents on operator interfaces.  */\n-  if (operator == INTRINSIC_ASSIGN)\n+  if (op == INTRINSIC_ASSIGN)\n     {\n       if (i1 != INTENT_OUT && i1 != INTENT_INOUT)\n \tgfc_error (\"First argument of defined assignment at %L must be \"\n@@ -674,15 +674,15 @@ check_operator_interface (gfc_interface *intr, gfc_intrinsic_op operator)\n   ((t) == BT_INTEGER || (t) == BT_REAL || (t) == BT_COMPLEX)\n \n   /* Unary ops are easy, do them first.  */\n-  if (operator == INTRINSIC_NOT)\n+  if (op == INTRINSIC_NOT)\n     {\n       if (t1 == BT_LOGICAL)\n \tgoto bad_repl;\n       else\n \treturn;\n     }\n \n-  if (args == 1 && (operator == INTRINSIC_PLUS || operator == INTRINSIC_MINUS))\n+  if (args == 1 && (op == INTRINSIC_PLUS || op == INTRINSIC_MINUS))\n     {\n       if (IS_NUMERIC_TYPE (t1))\n \tgoto bad_repl;\n@@ -702,7 +702,7 @@ check_operator_interface (gfc_interface *intr, gfc_intrinsic_op operator)\n   if (r1 != r2 && r1 != 0 && r2 != 0)\n     return;\n \n-  switch (operator)\n+  switch (op)\n   {\n     case INTRINSIC_EQ:\n     case INTRINSIC_EQ_OS:\n@@ -1243,7 +1243,7 @@ check_uop_interfaces (gfc_user_op *uop)\n   gfc_namespace *ns;\n \n   sprintf (interface_name, \"operator interface '%s'\", uop->name);\n-  if (check_interface0 (uop->operator, interface_name))\n+  if (check_interface0 (uop->op, interface_name))\n     return;\n \n   for (ns = gfc_current_ns; ns; ns = ns->parent)\n@@ -1252,7 +1252,7 @@ check_uop_interfaces (gfc_user_op *uop)\n       if (uop2 == NULL)\n \tcontinue;\n \n-      check_interface1 (uop->operator, uop2->operator, 0,\n+      check_interface1 (uop->op, uop2->op, 0,\n \t\t\tinterface_name, true);\n     }\n }\n@@ -1288,76 +1288,76 @@ gfc_check_interfaces (gfc_namespace *ns)\n \tsprintf (interface_name, \"intrinsic '%s' operator\",\n \t\t gfc_op2string (i));\n \n-      if (check_interface0 (ns->operator[i], interface_name))\n+      if (check_interface0 (ns->op[i], interface_name))\n \tcontinue;\n \n-      check_operator_interface (ns->operator[i], i);\n+      check_operator_interface (ns->op[i], i);\n \n       for (ns2 = ns; ns2; ns2 = ns2->parent)\n \t{\n-\t  if (check_interface1 (ns->operator[i], ns2->operator[i], 0,\n+\t  if (check_interface1 (ns->op[i], ns2->op[i], 0,\n \t\t\t\tinterface_name, true))\n \t    goto done;\n \n \t  switch (i)\n \t    {\n \t      case INTRINSIC_EQ:\n-\t\tif (check_interface1 (ns->operator[i], ns2->operator[INTRINSIC_EQ_OS],\n+\t\tif (check_interface1 (ns->op[i], ns2->op[INTRINSIC_EQ_OS],\n \t\t\t\t      0, interface_name, true)) goto done;\n \t\tbreak;\n \n \t      case INTRINSIC_EQ_OS:\n-\t\tif (check_interface1 (ns->operator[i], ns2->operator[INTRINSIC_EQ],\n+\t\tif (check_interface1 (ns->op[i], ns2->op[INTRINSIC_EQ],\n \t\t\t\t      0, interface_name, true)) goto done;\n \t\tbreak;\n \n \t      case INTRINSIC_NE:\n-\t\tif (check_interface1 (ns->operator[i], ns2->operator[INTRINSIC_NE_OS],\n+\t\tif (check_interface1 (ns->op[i], ns2->op[INTRINSIC_NE_OS],\n \t\t\t\t      0, interface_name, true)) goto done;\n \t\tbreak;\n \n \t      case INTRINSIC_NE_OS:\n-\t\tif (check_interface1 (ns->operator[i], ns2->operator[INTRINSIC_NE],\n+\t\tif (check_interface1 (ns->op[i], ns2->op[INTRINSIC_NE],\n \t\t\t\t      0, interface_name, true)) goto done;\n \t\tbreak;\n \n \t      case INTRINSIC_GT:\n-\t\tif (check_interface1 (ns->operator[i], ns2->operator[INTRINSIC_GT_OS],\n+\t\tif (check_interface1 (ns->op[i], ns2->op[INTRINSIC_GT_OS],\n \t\t\t\t      0, interface_name, true)) goto done;\n \t\tbreak;\n \n \t      case INTRINSIC_GT_OS:\n-\t\tif (check_interface1 (ns->operator[i], ns2->operator[INTRINSIC_GT],\n+\t\tif (check_interface1 (ns->op[i], ns2->op[INTRINSIC_GT],\n \t\t\t\t      0, interface_name, true)) goto done;\n \t\tbreak;\n \n \t      case INTRINSIC_GE:\n-\t\tif (check_interface1 (ns->operator[i], ns2->operator[INTRINSIC_GE_OS],\n+\t\tif (check_interface1 (ns->op[i], ns2->op[INTRINSIC_GE_OS],\n \t\t\t\t      0, interface_name, true)) goto done;\n \t\tbreak;\n \n \t      case INTRINSIC_GE_OS:\n-\t\tif (check_interface1 (ns->operator[i], ns2->operator[INTRINSIC_GE],\n+\t\tif (check_interface1 (ns->op[i], ns2->op[INTRINSIC_GE],\n \t\t\t\t      0, interface_name, true)) goto done;\n \t\tbreak;\n \n \t      case INTRINSIC_LT:\n-\t\tif (check_interface1 (ns->operator[i], ns2->operator[INTRINSIC_LT_OS],\n+\t\tif (check_interface1 (ns->op[i], ns2->op[INTRINSIC_LT_OS],\n \t\t\t\t      0, interface_name, true)) goto done;\n \t\tbreak;\n \n \t      case INTRINSIC_LT_OS:\n-\t\tif (check_interface1 (ns->operator[i], ns2->operator[INTRINSIC_LT],\n+\t\tif (check_interface1 (ns->op[i], ns2->op[INTRINSIC_LT],\n \t\t\t\t      0, interface_name, true)) goto done;\n \t\tbreak;\n \n \t      case INTRINSIC_LE:\n-\t\tif (check_interface1 (ns->operator[i], ns2->operator[INTRINSIC_LE_OS],\n+\t\tif (check_interface1 (ns->op[i], ns2->op[INTRINSIC_LE_OS],\n \t\t\t\t      0, interface_name, true)) goto done;\n \t\tbreak;\n \n \t      case INTRINSIC_LE_OS:\n-\t\tif (check_interface1 (ns->operator[i], ns2->operator[INTRINSIC_LE],\n+\t\tif (check_interface1 (ns->op[i], ns2->op[INTRINSIC_LE],\n \t\t\t\t      0, interface_name, true)) goto done;\n \t\tbreak;\n \n@@ -2566,7 +2566,7 @@ gfc_extend_expr (gfc_expr *e)\n       actual->next->expr = e->value.op.op2;\n     }\n \n-  i = fold_unary (e->value.op.operator);\n+  i = fold_unary (e->value.op.op);\n \n   if (i == INTRINSIC_USER)\n     {\n@@ -2576,7 +2576,7 @@ gfc_extend_expr (gfc_expr *e)\n \t  if (uop == NULL)\n \t    continue;\n \n-\t  sym = gfc_search_interface (uop->operator, 0, &actual);\n+\t  sym = gfc_search_interface (uop->op, 0, &actual);\n \t  if (sym != NULL)\n \t    break;\n \t}\n@@ -2591,48 +2591,48 @@ gfc_extend_expr (gfc_expr *e)\n \t    {\n \t      case INTRINSIC_EQ:\n \t      case INTRINSIC_EQ_OS:\n-\t\tsym = gfc_search_interface (ns->operator[INTRINSIC_EQ], 0, &actual);\n+\t\tsym = gfc_search_interface (ns->op[INTRINSIC_EQ], 0, &actual);\n \t\tif (sym == NULL)\n-\t\t  sym = gfc_search_interface (ns->operator[INTRINSIC_EQ_OS], 0, &actual);\n+\t\t  sym = gfc_search_interface (ns->op[INTRINSIC_EQ_OS], 0, &actual);\n \t\tbreak;\n \n \t      case INTRINSIC_NE:\n \t      case INTRINSIC_NE_OS:\n-\t\tsym = gfc_search_interface (ns->operator[INTRINSIC_NE], 0, &actual);\n+\t\tsym = gfc_search_interface (ns->op[INTRINSIC_NE], 0, &actual);\n \t\tif (sym == NULL)\n-\t\t  sym = gfc_search_interface (ns->operator[INTRINSIC_NE_OS], 0, &actual);\n+\t\t  sym = gfc_search_interface (ns->op[INTRINSIC_NE_OS], 0, &actual);\n \t\tbreak;\n \n \t      case INTRINSIC_GT:\n \t      case INTRINSIC_GT_OS:\n-\t\tsym = gfc_search_interface (ns->operator[INTRINSIC_GT], 0, &actual);\n+\t\tsym = gfc_search_interface (ns->op[INTRINSIC_GT], 0, &actual);\n \t\tif (sym == NULL)\n-\t\t  sym = gfc_search_interface (ns->operator[INTRINSIC_GT_OS], 0, &actual);\n+\t\t  sym = gfc_search_interface (ns->op[INTRINSIC_GT_OS], 0, &actual);\n \t\tbreak;\n \n \t      case INTRINSIC_GE:\n \t      case INTRINSIC_GE_OS:\n-\t\tsym = gfc_search_interface (ns->operator[INTRINSIC_GE], 0, &actual);\n+\t\tsym = gfc_search_interface (ns->op[INTRINSIC_GE], 0, &actual);\n \t\tif (sym == NULL)\n-\t\t  sym = gfc_search_interface (ns->operator[INTRINSIC_GE_OS], 0, &actual);\n+\t\t  sym = gfc_search_interface (ns->op[INTRINSIC_GE_OS], 0, &actual);\n \t\tbreak;\n \n \t      case INTRINSIC_LT:\n \t      case INTRINSIC_LT_OS:\n-\t\tsym = gfc_search_interface (ns->operator[INTRINSIC_LT], 0, &actual);\n+\t\tsym = gfc_search_interface (ns->op[INTRINSIC_LT], 0, &actual);\n \t\tif (sym == NULL)\n-\t\t  sym = gfc_search_interface (ns->operator[INTRINSIC_LT_OS], 0, &actual);\n+\t\t  sym = gfc_search_interface (ns->op[INTRINSIC_LT_OS], 0, &actual);\n \t\tbreak;\n \n \t      case INTRINSIC_LE:\n \t      case INTRINSIC_LE_OS:\n-\t\tsym = gfc_search_interface (ns->operator[INTRINSIC_LE], 0, &actual);\n+\t\tsym = gfc_search_interface (ns->op[INTRINSIC_LE], 0, &actual);\n \t\tif (sym == NULL)\n-\t\t  sym = gfc_search_interface (ns->operator[INTRINSIC_LE_OS], 0, &actual);\n+\t\t  sym = gfc_search_interface (ns->op[INTRINSIC_LE_OS], 0, &actual);\n \t\tbreak;\n \n \t      default:\n-\t\tsym = gfc_search_interface (ns->operator[i], 0, &actual);\n+\t\tsym = gfc_search_interface (ns->op[i], 0, &actual);\n \t    }\n \n \t  if (sym != NULL)\n@@ -2704,7 +2704,7 @@ gfc_extend_assign (gfc_code *c, gfc_namespace *ns)\n \n   for (; ns; ns = ns->parent)\n     {\n-      sym = gfc_search_interface (ns->operator[INTRINSIC_ASSIGN], 1, &actual);\n+      sym = gfc_search_interface (ns->op[INTRINSIC_ASSIGN], 1, &actual);\n       if (sym != NULL)\n \tbreak;\n     }\n@@ -2771,52 +2771,52 @@ gfc_add_interface (gfc_symbol *new)\n \t  {\n \t    case INTRINSIC_EQ:\n \t    case INTRINSIC_EQ_OS:\n-\t      if (check_new_interface (ns->operator[INTRINSIC_EQ], new) == FAILURE ||\n-\t          check_new_interface (ns->operator[INTRINSIC_EQ_OS], new) == FAILURE)\n+\t      if (check_new_interface (ns->op[INTRINSIC_EQ], new) == FAILURE ||\n+\t          check_new_interface (ns->op[INTRINSIC_EQ_OS], new) == FAILURE)\n \t\treturn FAILURE;\n \t      break;\n \n \t    case INTRINSIC_NE:\n \t    case INTRINSIC_NE_OS:\n-\t      if (check_new_interface (ns->operator[INTRINSIC_NE], new) == FAILURE ||\n-\t          check_new_interface (ns->operator[INTRINSIC_NE_OS], new) == FAILURE)\n+\t      if (check_new_interface (ns->op[INTRINSIC_NE], new) == FAILURE ||\n+\t          check_new_interface (ns->op[INTRINSIC_NE_OS], new) == FAILURE)\n \t\treturn FAILURE;\n \t      break;\n \n \t    case INTRINSIC_GT:\n \t    case INTRINSIC_GT_OS:\n-\t      if (check_new_interface (ns->operator[INTRINSIC_GT], new) == FAILURE ||\n-\t          check_new_interface (ns->operator[INTRINSIC_GT_OS], new) == FAILURE)\n+\t      if (check_new_interface (ns->op[INTRINSIC_GT], new) == FAILURE ||\n+\t          check_new_interface (ns->op[INTRINSIC_GT_OS], new) == FAILURE)\n \t\treturn FAILURE;\n \t      break;\n \n \t    case INTRINSIC_GE:\n \t    case INTRINSIC_GE_OS:\n-\t      if (check_new_interface (ns->operator[INTRINSIC_GE], new) == FAILURE ||\n-\t          check_new_interface (ns->operator[INTRINSIC_GE_OS], new) == FAILURE)\n+\t      if (check_new_interface (ns->op[INTRINSIC_GE], new) == FAILURE ||\n+\t          check_new_interface (ns->op[INTRINSIC_GE_OS], new) == FAILURE)\n \t\treturn FAILURE;\n \t      break;\n \n \t    case INTRINSIC_LT:\n \t    case INTRINSIC_LT_OS:\n-\t      if (check_new_interface (ns->operator[INTRINSIC_LT], new) == FAILURE ||\n-\t          check_new_interface (ns->operator[INTRINSIC_LT_OS], new) == FAILURE)\n+\t      if (check_new_interface (ns->op[INTRINSIC_LT], new) == FAILURE ||\n+\t          check_new_interface (ns->op[INTRINSIC_LT_OS], new) == FAILURE)\n \t\treturn FAILURE;\n \t      break;\n \n \t    case INTRINSIC_LE:\n \t    case INTRINSIC_LE_OS:\n-\t      if (check_new_interface (ns->operator[INTRINSIC_LE], new) == FAILURE ||\n-\t          check_new_interface (ns->operator[INTRINSIC_LE_OS], new) == FAILURE)\n+\t      if (check_new_interface (ns->op[INTRINSIC_LE], new) == FAILURE ||\n+\t          check_new_interface (ns->op[INTRINSIC_LE_OS], new) == FAILURE)\n \t\treturn FAILURE;\n \t      break;\n \n \t    default:\n-\t      if (check_new_interface (ns->operator[current_interface.op], new) == FAILURE)\n+\t      if (check_new_interface (ns->op[current_interface.op], new) == FAILURE)\n \t\treturn FAILURE;\n \t  }\n \n-      head = &current_interface.ns->operator[current_interface.op];\n+      head = &current_interface.ns->op[current_interface.op];\n       break;\n \n     case INTERFACE_GENERIC:\n@@ -2834,11 +2834,11 @@ gfc_add_interface (gfc_symbol *new)\n       break;\n \n     case INTERFACE_USER_OP:\n-      if (check_new_interface (current_interface.uop->operator, new)\n+      if (check_new_interface (current_interface.uop->op, new)\n \t  == FAILURE)\n \treturn FAILURE;\n \n-      head = &current_interface.uop->operator;\n+      head = &current_interface.uop->op;\n       break;\n \n     default:\n@@ -2862,15 +2862,15 @@ gfc_current_interface_head (void)\n   switch (current_interface.type)\n     {\n       case INTERFACE_INTRINSIC_OP:\n-\treturn current_interface.ns->operator[current_interface.op];\n+\treturn current_interface.ns->op[current_interface.op];\n \tbreak;\n \n       case INTERFACE_GENERIC:\n \treturn current_interface.sym->generic;\n \tbreak;\n \n       case INTERFACE_USER_OP:\n-\treturn current_interface.uop->operator;\n+\treturn current_interface.uop->op;\n \tbreak;\n \n       default:\n@@ -2885,15 +2885,15 @@ gfc_set_current_interface_head (gfc_interface *i)\n   switch (current_interface.type)\n     {\n       case INTERFACE_INTRINSIC_OP:\n-\tcurrent_interface.ns->operator[current_interface.op] = i;\n+\tcurrent_interface.ns->op[current_interface.op] = i;\n \tbreak;\n \n       case INTERFACE_GENERIC:\n \tcurrent_interface.sym->generic = i;\n \tbreak;\n \n       case INTERFACE_USER_OP:\n-\tcurrent_interface.uop->operator = i;\n+\tcurrent_interface.uop->op = i;\n \tbreak;\n \n       default:"}, {"sha": "f447ba279cfb925884cd3553d7e47cdb936026f5", "filename": "gcc/fortran/iresolve.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1ee985fa319b7a55e52ddd62f266e42ef9ae067/gcc%2Ffortran%2Firesolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1ee985fa319b7a55e52ddd62f266e42ef9ae067/gcc%2Ffortran%2Firesolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Firesolve.c?ref=a1ee985fa319b7a55e52ddd62f266e42ef9ae067", "patch": "@@ -705,7 +705,7 @@ gfc_resolve_dot_product (gfc_expr *f, gfc_expr *a, gfc_expr *b)\n \n   temp.expr_type = EXPR_OP;\n   gfc_clear_ts (&temp.ts);\n-  temp.value.op.operator = INTRINSIC_NONE;\n+  temp.value.op.op = INTRINSIC_NONE;\n   temp.value.op.op1 = a;\n   temp.value.op.op2 = b;\n   gfc_type_convert_binary (&temp);\n@@ -1332,7 +1332,7 @@ gfc_resolve_matmul (gfc_expr *f, gfc_expr *a, gfc_expr *b)\n     {\n       temp.expr_type = EXPR_OP;\n       gfc_clear_ts (&temp.ts);\n-      temp.value.op.operator = INTRINSIC_NONE;\n+      temp.value.op.op = INTRINSIC_NONE;\n       temp.value.op.op1 = a;\n       temp.value.op.op2 = b;\n       gfc_type_convert_binary (&temp);"}, {"sha": "433f4d21784558025ba9ac7219b655df6091d519", "filename": "gcc/fortran/matchexp.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1ee985fa319b7a55e52ddd62f266e42ef9ae067/gcc%2Ffortran%2Fmatchexp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1ee985fa319b7a55e52ddd62f266e42ef9ae067/gcc%2Ffortran%2Fmatchexp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatchexp.c?ref=a1ee985fa319b7a55e52ddd62f266e42ef9ae067", "patch": "@@ -142,7 +142,7 @@ gfc_get_parentheses (gfc_expr *e)\n   e2->ts = e->ts;\n   e2->rank = e->rank;\n   e2->where = e->where;\n-  e2->value.op.operator = INTRINSIC_PARENTHESES;\n+  e2->value.op.op = INTRINSIC_PARENTHESES;\n   e2->value.op.op1 = e;\n   e2->value.op.op2 = NULL;\n   return e2;\n@@ -208,14 +208,14 @@ match_primary (gfc_expr **result)\n /* Build an operator expression node.  */\n \n static gfc_expr *\n-build_node (gfc_intrinsic_op operator, locus *where,\n+build_node (gfc_intrinsic_op op, locus *where,\n \t    gfc_expr *op1, gfc_expr *op2)\n {\n   gfc_expr *new;\n \n   new = gfc_get_expr ();\n   new->expr_type = EXPR_OP;\n-  new->value.op.operator = operator;\n+  new->value.op.op = op;\n   new->where = *where;\n \n   new->value.op.op1 = op1;"}, {"sha": "3f27fda26d4ab5af7e845526aa4b68750002fd3e", "filename": "gcc/fortran/module.c", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1ee985fa319b7a55e52ddd62f266e42ef9ae067/gcc%2Ffortran%2Fmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1ee985fa319b7a55e52ddd62f266e42ef9ae067/gcc%2Ffortran%2Fmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmodule.c?ref=a1ee985fa319b7a55e52ddd62f266e42ef9ae067", "patch": "@@ -169,7 +169,7 @@ typedef struct gfc_use_rename\n   char local_name[GFC_MAX_SYMBOL_LEN + 1], use_name[GFC_MAX_SYMBOL_LEN + 1];\n   struct gfc_use_rename *next;\n   int found;\n-  gfc_intrinsic_op operator;\n+  gfc_intrinsic_op op;\n   locus where;\n }\n gfc_use_rename;\n@@ -504,7 +504,7 @@ gfc_match_use (void)\n   char name[GFC_MAX_SYMBOL_LEN + 1], module_nature[GFC_MAX_SYMBOL_LEN + 1];\n   gfc_use_rename *tail = NULL, *new;\n   interface_type type, type2;\n-  gfc_intrinsic_op operator;\n+  gfc_intrinsic_op op;\n   match m;\n \n   specified_int = false;\n@@ -593,8 +593,8 @@ gfc_match_use (void)\n \n       /* See what kind of interface we're dealing with.  Assume it is\n \t not an operator.  */\n-      new->operator = INTRINSIC_NONE;\n-      if (gfc_match_generic_spec (&type, name, &operator) == MATCH_ERROR)\n+      new->op = INTRINSIC_NONE;\n+      if (gfc_match_generic_spec (&type, name, &op) == MATCH_ERROR)\n \tgoto cleanup;\n \n       switch (type)\n@@ -614,7 +614,7 @@ gfc_match_use (void)\n \t    goto cleanup;\n \n \t  if (type == INTERFACE_USER_OP)\n-\t    new->operator = INTRINSIC_USER;\n+\t    new->op = INTRINSIC_USER;\n \n \t  if (only_flag)\n \t    {\n@@ -623,7 +623,7 @@ gfc_match_use (void)\n \t      else\n \t\t{\n \t\t  strcpy (new->local_name, name);\n-\t\t  m = gfc_match_generic_spec (&type2, new->use_name, &operator);\n+\t\t  m = gfc_match_generic_spec (&type2, new->use_name, &op);\n \t\t  if (type != type2)\n \t\t    goto syntax;\n \t\t  if (m == MATCH_NO)\n@@ -638,7 +638,7 @@ gfc_match_use (void)\n \t\tgoto syntax;\n \t      strcpy (new->local_name, name);\n \n-\t      m = gfc_match_generic_spec (&type2, new->use_name, &operator);\n+\t      m = gfc_match_generic_spec (&type2, new->use_name, &op);\n \t      if (type != type2)\n \t\tgoto syntax;\n \t      if (m == MATCH_NO)\n@@ -657,7 +657,7 @@ gfc_match_use (void)\n \t  break;\n \n \tcase INTERFACE_INTRINSIC_OP:\n-\t  new->operator = operator;\n+\t  new->op = op;\n \t  break;\n \n \tdefault:\n@@ -698,8 +698,8 @@ find_use_name_n (const char *name, int *inst, bool interface)\n   for (u = gfc_rename_list; u; u = u->next)\n     {\n       if (strcmp (u->use_name, name) != 0\n-\t  || (u->operator == INTRINSIC_USER && !interface)\n-\t  || (u->operator != INTRINSIC_USER &&  interface))\n+\t  || (u->op == INTRINSIC_USER && !interface)\n+\t  || (u->op != INTRINSIC_USER &&  interface))\n \tcontinue;\n       if (++i == *inst)\n \tbreak;\n@@ -746,12 +746,12 @@ number_use_names (const char *name, bool interface)\n /* Try to find the operator in the current list.  */\n \n static gfc_use_rename *\n-find_use_operator (gfc_intrinsic_op operator)\n+find_use_operator (gfc_intrinsic_op op)\n {\n   gfc_use_rename *u;\n \n   for (u = gfc_rename_list; u; u = u->next)\n-    if (u->operator == operator)\n+    if (u->op == op)\n       return u;\n \n   return NULL;\n@@ -2873,10 +2873,10 @@ mio_expr (gfc_expr **ep)\n   switch (e->expr_type)\n     {\n     case EXPR_OP:\n-      e->value.op.operator\n-\t= MIO_NAME (gfc_intrinsic_op) (e->value.op.operator, intrinsics);\n+      e->value.op.op\n+\t= MIO_NAME (gfc_intrinsic_op) (e->value.op.op, intrinsics);\n \n-      switch (e->value.op.operator)\n+      switch (e->value.op.op)\n \t{\n \tcase INTRINSIC_UPLUS:\n \tcase INTRINSIC_UMINUS:\n@@ -3383,16 +3383,16 @@ load_operator_interfaces (void)\n \t  if (i == 1)\n \t    {\n \t      uop = gfc_get_uop (p);\n-\t      pi = mio_interface_rest (&uop->operator);\n+\t      pi = mio_interface_rest (&uop->op);\n \t    }\n \t  else\n \t    {\n \t      if (gfc_find_uop (p, NULL))\n \t\tcontinue;\n \t      uop = gfc_get_uop (p);\n-\t      uop->operator = gfc_get_interface ();\n-\t      uop->operator->where = gfc_current_locus;\n-\t      add_fixup (pi->integer, &uop->operator->sym);\n+\t      uop->op = gfc_get_interface ();\n+\t      uop->op->where = gfc_current_locus;\n+\t      add_fixup (pi->integer, &uop->op->sym);\n \t    }\n \t}\n     }\n@@ -3954,7 +3954,7 @@ read_module (void)\n \t  u->found = 1;\n \t}\n \n-      mio_interface (&gfc_current_ns->operator[i]);\n+      mio_interface (&gfc_current_ns->op[i]);\n     }\n \n   mio_rparen ();\n@@ -3984,22 +3984,22 @@ read_module (void)\n       if (u->found)\n \tcontinue;\n \n-      if (u->operator == INTRINSIC_NONE)\n+      if (u->op == INTRINSIC_NONE)\n \t{\n \t  gfc_error (\"Symbol '%s' referenced at %L not found in module '%s'\",\n \t\t     u->use_name, &u->where, module_name);\n \t  continue;\n \t}\n \n-      if (u->operator == INTRINSIC_USER)\n+      if (u->op == INTRINSIC_USER)\n \t{\n \t  gfc_error (\"User operator '%s' referenced at %L not found \"\n \t\t     \"in module '%s'\", u->use_name, &u->where, module_name);\n \t  continue;\n \t}\n \n       gfc_error (\"Intrinsic operator '%s' referenced at %L not found \"\n-\t\t \"in module '%s'\", gfc_op2string (u->operator), &u->where,\n+\t\t \"in module '%s'\", gfc_op2string (u->op), &u->where,\n \t\t module_name);\n     }\n \n@@ -4319,11 +4319,11 @@ write_operator (gfc_user_op *uop)\n   static char nullstring[] = \"\";\n   const char *p = nullstring;\n \n-  if (uop->operator == NULL\n+  if (uop->op == NULL\n       || !gfc_check_access (uop->access, uop->ns->default_access))\n     return;\n \n-  mio_symbol_interface (&uop->name, &p, &uop->operator);\n+  mio_symbol_interface (&uop->name, &p, &uop->op);\n }\n \n \n@@ -4395,7 +4395,7 @@ write_module (void)\n \n       mio_interface (gfc_check_access (gfc_current_ns->operator_access[i],\n \t\t\t\t       gfc_current_ns->default_access)\n-\t\t     ? &gfc_current_ns->operator[i] : NULL);\n+\t\t     ? &gfc_current_ns->op[i] : NULL);\n     }\n \n   mio_rparen ();"}, {"sha": "9ac9a4aec913119bb4b3b6c51a3e76ac5e34ca33", "filename": "gcc/fortran/openmp.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1ee985fa319b7a55e52ddd62f266e42ef9ae067/gcc%2Ffortran%2Fopenmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1ee985fa319b7a55e52ddd62f266e42ef9ae067/gcc%2Ffortran%2Fopenmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fopenmp.c?ref=a1ee985fa319b7a55e52ddd62f266e42ef9ae067", "patch": "@@ -1093,7 +1093,7 @@ resolve_omp_atomic (gfc_code *code)\n   if (expr2->expr_type == EXPR_OP)\n     {\n       gfc_expr *v = NULL, *e, *c;\n-      gfc_intrinsic_op op = expr2->value.op.operator;\n+      gfc_intrinsic_op op = expr2->value.op.op;\n       gfc_intrinsic_op alt_op = INTRINSIC_NONE;\n \n       switch (op)\n@@ -1156,8 +1156,8 @@ resolve_omp_atomic (gfc_code *code)\n \t    else if ((c = is_conversion (e, true)) != NULL)\n \t      q = &e->value.function.actual->expr;\n \t    else if (e->expr_type != EXPR_OP\n-\t\t     || (e->value.op.operator != op\n-\t\t\t && e->value.op.operator != alt_op)\n+\t\t     || (e->value.op.op != op\n+\t\t\t && e->value.op.op != alt_op)\n \t\t     || e->rank != 0)\n \t      break;\n \t    else\n@@ -1176,7 +1176,7 @@ resolve_omp_atomic (gfc_code *code)\n \t  if (p != NULL)\n \t    {\n \t      e = *p;\n-\t      switch (e->value.op.operator)\n+\t      switch (e->value.op.op)\n \t\t{\n \t\tcase INTRINSIC_MINUS:\n \t\tcase INTRINSIC_DIVIDE:"}, {"sha": "758f86f7ed59b1f3b81af5be28653f4c5cedd57f", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1ee985fa319b7a55e52ddd62f266e42ef9ae067/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1ee985fa319b7a55e52ddd62f266e42ef9ae067/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=a1ee985fa319b7a55e52ddd62f266e42ef9ae067", "patch": "@@ -2903,7 +2903,7 @@ resolve_operator (gfc_expr *e)\n \n   /* Resolve all subnodes-- give them types.  */\n \n-  switch (e->value.op.operator)\n+  switch (e->value.op.op)\n     {\n     default:\n       if (gfc_resolve_expr (e->value.op.op2) == FAILURE)\n@@ -2933,7 +2933,7 @@ resolve_operator (gfc_expr *e)\n       goto bad_op;\n     }\n \n-  switch (e->value.op.operator)\n+  switch (e->value.op.op)\n     {\n     case INTRINSIC_UPLUS:\n     case INTRINSIC_UMINUS:\n@@ -2946,7 +2946,7 @@ resolve_operator (gfc_expr *e)\n \t}\n \n       sprintf (msg, _(\"Operand of unary numeric operator '%s' at %%L is %s\"),\n-\t       gfc_op2string (e->value.op.operator), gfc_typename (&e->ts));\n+\t       gfc_op2string (e->value.op.op), gfc_typename (&e->ts));\n       goto bad_op;\n \n     case INTRINSIC_PLUS:\n@@ -2962,7 +2962,7 @@ resolve_operator (gfc_expr *e)\n \n       sprintf (msg,\n \t       _(\"Operands of binary numeric operator '%s' at %%L are %s/%s\"),\n-\t       gfc_op2string (e->value.op.operator), gfc_typename (&op1->ts),\n+\t       gfc_op2string (e->value.op.op), gfc_typename (&op1->ts),\n \t       gfc_typename (&op2->ts));\n       goto bad_op;\n \n@@ -2996,7 +2996,7 @@ resolve_operator (gfc_expr *e)\n \t}\n \n       sprintf (msg, _(\"Operands of logical operator '%s' at %%L are %s/%s\"),\n-\t       gfc_op2string (e->value.op.operator), gfc_typename (&op1->ts),\n+\t       gfc_op2string (e->value.op.op), gfc_typename (&op1->ts),\n \t       gfc_typename (&op2->ts));\n \n       goto bad_op;\n@@ -3053,19 +3053,19 @@ resolve_operator (gfc_expr *e)\n       if (op1->ts.type == BT_LOGICAL && op2->ts.type == BT_LOGICAL)\n \tsprintf (msg,\n \t\t _(\"Logicals at %%L must be compared with %s instead of %s\"),\n-\t\t (e->value.op.operator == INTRINSIC_EQ \n-\t\t  || e->value.op.operator == INTRINSIC_EQ_OS)\n-\t\t ? \".eqv.\" : \".neqv.\", gfc_op2string (e->value.op.operator));\n+\t\t (e->value.op.op == INTRINSIC_EQ \n+\t\t  || e->value.op.op == INTRINSIC_EQ_OS)\n+\t\t ? \".eqv.\" : \".neqv.\", gfc_op2string (e->value.op.op));\n       else\n \tsprintf (msg,\n \t\t _(\"Operands of comparison operator '%s' at %%L are %s/%s\"),\n-\t\t gfc_op2string (e->value.op.operator), gfc_typename (&op1->ts),\n+\t\t gfc_op2string (e->value.op.op), gfc_typename (&op1->ts),\n \t\t gfc_typename (&op2->ts));\n \n       goto bad_op;\n \n     case INTRINSIC_USER:\n-      if (e->value.op.uop->operator == NULL)\n+      if (e->value.op.uop->op == NULL)\n \tsprintf (msg, _(\"Unknown operator '%s' at %%L\"), e->value.op.uop->name);\n       else if (op2 == NULL)\n \tsprintf (msg, _(\"Operand of user operator '%s' at %%L is %s\"),\n@@ -3091,7 +3091,7 @@ resolve_operator (gfc_expr *e)\n \n   t = SUCCESS;\n \n-  switch (e->value.op.operator)\n+  switch (e->value.op.op)\n     {\n     case INTRINSIC_PLUS:\n     case INTRINSIC_MINUS:\n@@ -4217,7 +4217,7 @@ gfc_resolve_character_operator (gfc_expr *e)\n   gfc_expr *e1 = NULL;\n   gfc_expr *e2 = NULL;\n \n-  gcc_assert (e->value.op.operator == INTRINSIC_CONCAT);\n+  gcc_assert (e->value.op.op == INTRINSIC_CONCAT);\n \n   if (op1->ts.cl && op1->ts.cl->length)\n     e1 = gfc_copy_expr (op1->ts.cl->length);\n@@ -9165,7 +9165,7 @@ gfc_resolve_uops (gfc_symtree *symtree)\n   gfc_resolve_uops (symtree->left);\n   gfc_resolve_uops (symtree->right);\n \n-  for (itr = symtree->n.uop->operator; itr; itr = itr->next)\n+  for (itr = symtree->n.uop->op; itr; itr = itr->next)\n     {\n       sym = itr->sym;\n       if (!sym->attr.function)"}, {"sha": "57870c0d63ec40201fe7d3855b9701adc6be818e", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1ee985fa319b7a55e52ddd62f266e42ef9ae067/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1ee985fa319b7a55e52ddd62f266e42ef9ae067/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=a1ee985fa319b7a55e52ddd62f266e42ef9ae067", "patch": "@@ -2843,7 +2843,7 @@ free_uop_tree (gfc_symtree *uop_tree)\n   free_uop_tree (uop_tree->left);\n   free_uop_tree (uop_tree->right);\n \n-  gfc_free_interface (uop_tree->n.uop->operator);\n+  gfc_free_interface (uop_tree->n.uop->op);\n \n   gfc_free (uop_tree->n.uop);\n   gfc_free (uop_tree);\n@@ -2997,7 +2997,7 @@ gfc_free_namespace (gfc_namespace *ns)\n   gfc_free_equiv_lists (ns->equiv_lists);\n \n   for (i = GFC_INTRINSIC_BEGIN; i != GFC_INTRINSIC_END; i++)\n-    gfc_free_interface (ns->operator[i]);\n+    gfc_free_interface (ns->op[i]);\n \n   gfc_free_data (ns->data);\n   p = ns->contained;"}, {"sha": "d4f5c59559c01cd01bdb737816e5b88a7ba8b161", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1ee985fa319b7a55e52ddd62f266e42ef9ae067/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1ee985fa319b7a55e52ddd62f266e42ef9ae067/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=a1ee985fa319b7a55e52ddd62f266e42ef9ae067", "patch": "@@ -1079,7 +1079,7 @@ gfc_conv_expr_op (gfc_se * se, gfc_expr * expr)\n \n   checkstring = 0;\n   lop = 0;\n-  switch (expr->value.op.operator)\n+  switch (expr->value.op.op)\n     {\n     case INTRINSIC_PARENTHESES:\n       if (expr->ts.type == BT_REAL"}, {"sha": "06329a9855445a313bd46389778103a7e0a3e97a", "filename": "gcc/fortran/trans-openmp.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1ee985fa319b7a55e52ddd62f266e42ef9ae067/gcc%2Ffortran%2Ftrans-openmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1ee985fa319b7a55e52ddd62f266e42ef9ae067/gcc%2Ffortran%2Ftrans-openmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-openmp.c?ref=a1ee985fa319b7a55e52ddd62f266e42ef9ae067", "patch": "@@ -969,7 +969,7 @@ gfc_trans_omp_atomic (gfc_code *code)\n   if (expr2->expr_type == EXPR_OP)\n     {\n       gfc_expr *e;\n-      switch (expr2->value.op.operator)\n+      switch (expr2->value.op.op)\n \t{\n \tcase INTRINSIC_PLUS:\n \t  op = PLUS_EXPR;"}]}