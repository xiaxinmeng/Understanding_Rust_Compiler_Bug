{"sha": "6b55b27fb97ee57bf644d1e5a0be57bed2a7e344", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmI1NWIyN2ZiOTdlZTU3YmY2NDRkMWU1YTBiZTU3YmVkMmE3ZTM0NA==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2002-12-02T19:04:14Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2002-12-02T19:04:14Z"}, "message": "For PR java/8740:\n\n\t* parse.y (do_resolve_class): Handle qualified name via\n\trecursion.\n\nFrom-SVN: r59728", "tree": {"sha": "64ae33546aa708be38f8166978639eeb79bd3a96", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/64ae33546aa708be38f8166978639eeb79bd3a96"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6b55b27fb97ee57bf644d1e5a0be57bed2a7e344", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b55b27fb97ee57bf644d1e5a0be57bed2a7e344", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b55b27fb97ee57bf644d1e5a0be57bed2a7e344", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b55b27fb97ee57bf644d1e5a0be57bed2a7e344/comments", "author": null, "committer": null, "parents": [{"sha": "aa863dca8bcd4410c4281b468d34e73319c8449f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa863dca8bcd4410c4281b468d34e73319c8449f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa863dca8bcd4410c4281b468d34e73319c8449f"}], "stats": {"total": 99, "additions": 63, "deletions": 36}, "files": [{"sha": "b6168b016edcc64446de2f3588311f1a3e217034", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b55b27fb97ee57bf644d1e5a0be57bed2a7e344/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b55b27fb97ee57bf644d1e5a0be57bed2a7e344/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=6b55b27fb97ee57bf644d1e5a0be57bed2a7e344", "patch": "@@ -1,3 +1,9 @@\n+2002-12-02  Tom Tromey  <tromey@redhat.com>\n+\n+\tFor PR java/8740:\n+\t* parse.y (do_resolve_class): Handle qualified name via\n+\trecursion.\n+\n 2002-11-27  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* decl.c (java_init_decl_processing): Use `LL' on 64-bit constant."}, {"sha": "97a0e6a0e27bed16a06b86e04accf5972ffc54c3", "filename": "gcc/java/parse.y", "status": "modified", "additions": 57, "deletions": 36, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b55b27fb97ee57bf644d1e5a0be57bed2a7e344/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b55b27fb97ee57bf644d1e5a0be57bed2a7e344/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=6b55b27fb97ee57bf644d1e5a0be57bed2a7e344", "patch": "@@ -5581,7 +5581,7 @@ java_complete_class ()\n   /* Process imports */\n   process_imports ();\n \n-  /* Rever things so we have the right order */\n+  /* Reverse things so we have the right order */\n   ctxp->class_list = nreverse (ctxp->class_list);\n   ctxp->classd_list = reverse_jdep_list (ctxp);\n \n@@ -5752,7 +5752,7 @@ resolve_class (enclosing, class_type, decl, cl)\n     return NULL_TREE;\n   resolved_type = TREE_TYPE (resolved_type_decl);\n \n-  /* 3- If we have and array, reconstruct the array down to its nesting */\n+  /* 3- If we have an array, reconstruct the array down to its nesting */\n   if (array_dims)\n     {\n       for (; array_dims; array_dims--)\n@@ -5778,37 +5778,58 @@ do_resolve_class (enclosing, class_type, decl, cl)\n   tree decl_result;\n   htab_t circularity_hash;\n \n-  /* This hash table is used to register the classes we're going\n-     through when searching the current class as an inner class, in\n-     order to detect circular references. Remember to free it before\n-     returning the section 0- of this function. */\n-  circularity_hash = htab_create (20, htab_hash_pointer, htab_eq_pointer,\n-\t\t\t\t  NULL);\n-\n-  /* 0- Search in the current class as an inner class.\n-     Maybe some code here should be added to load the class or\n-     something, at least if the class isn't an inner class and ended\n-     being loaded from class file. FIXME. */\n-  while (enclosing)\n-    {\n-      new_class_decl = resolve_inner_class (circularity_hash, cl, &enclosing,\n-\t\t\t\t\t    &super, class_type);\n-      if (new_class_decl)\n-\tbreak;\n-\n-      /* If we haven't found anything because SUPER reached Object and\n-\t ENCLOSING happens to be an innerclass, try the enclosing context. */\n-      if ((!super || super == object_type_node) &&\n-\t  enclosing && INNER_CLASS_DECL_P (enclosing))\n-\tenclosing = DECL_CONTEXT (enclosing);\n-      else\n-\tenclosing = NULL_TREE;\n+  if (QUALIFIED_P (TYPE_NAME (class_type)))\n+    {\n+      /* If the type name is of the form `Q . Id', then Q is either a\n+\t package name or a class name.  First we try to find Q as a\n+\t class and then treat Id as a member type.  If we can't find Q\n+\t as a class then we fall through.  */\n+      tree q, left, left_type, right;\n+      breakdown_qualified (&left, &right, TYPE_NAME (class_type));\n+      BUILD_PTR_FROM_NAME (left_type, left);\n+      q = do_resolve_class (enclosing, left_type, decl, cl);\n+      if (q)\n+\t{\n+\t  enclosing = q;\n+\t  saved_enclosing_type = TREE_TYPE (q);\n+\t  BUILD_PTR_FROM_NAME (class_type, right);\n+\t}\n     }\n \n-  htab_delete (circularity_hash);\n+  if (enclosing)\n+    {\n+      /* This hash table is used to register the classes we're going\n+\t through when searching the current class as an inner class, in\n+\t order to detect circular references. Remember to free it before\n+\t returning the section 0- of this function. */\n+      circularity_hash = htab_create (20, htab_hash_pointer, htab_eq_pointer,\n+\t\t\t\t      NULL);\n \n-  if (new_class_decl)\n-    return new_class_decl;\n+      /* 0- Search in the current class as an inner class.\n+\t Maybe some code here should be added to load the class or\n+\t something, at least if the class isn't an inner class and ended\n+\t being loaded from class file. FIXME. */\n+      while (enclosing)\n+\t{\n+\t  new_class_decl = resolve_inner_class (circularity_hash, cl, &enclosing,\n+\t\t\t\t\t\t&super, class_type);\n+\t  if (new_class_decl)\n+\t    break;\n+\n+\t  /* If we haven't found anything because SUPER reached Object and\n+\t     ENCLOSING happens to be an innerclass, try the enclosing context. */\n+\t  if ((!super || super == object_type_node) &&\n+\t      enclosing && INNER_CLASS_DECL_P (enclosing))\n+\t    enclosing = DECL_CONTEXT (enclosing);\n+\t  else\n+\t    enclosing = NULL_TREE;\n+\t}\n+\n+      htab_delete (circularity_hash);\n+\n+      if (new_class_decl)\n+\treturn new_class_decl;\n+    }\n \n   /* 1- Check for the type in single imports. This will change\n      TYPE_NAME() if something relevant is found */\n@@ -5837,7 +5858,7 @@ do_resolve_class (enclosing, class_type, decl, cl)\n     if (find_in_imports_on_demand (saved_enclosing_type, class_type))\n       return NULL_TREE;\n \n-  /* If found in find_in_imports_on_demant, the type has already been\n+  /* If found in find_in_imports_on_demand, the type has already been\n      loaded. */\n   if ((new_class_decl = IDENTIFIER_CLASS_VALUE (TYPE_NAME (class_type))))\n     return new_class_decl;\n@@ -5858,7 +5879,7 @@ do_resolve_class (enclosing, class_type, decl, cl)\n \t  return new_class_decl;\n     }\n \n-  /* 5- Check an other compilation unit that bears the name of type */\n+  /* 5- Check another compilation unit that bears the name of type */\n   load_class (TYPE_NAME (class_type), 0);\n \n   if (!cl)\n@@ -7029,7 +7050,7 @@ find_in_imports_on_demand (enclosing_type, class_type)\n     return (seen_once < 0 ? 0 : seen_once); /* It's ok not to have found */\n }\n \n-/* Add package NAME to the list of package encountered so far. To\n+/* Add package NAME to the list of packages encountered so far. To\n    speed up class lookup in do_resolve_class, we make sure a\n    particular package is added only once.  */\n \n@@ -11440,17 +11461,17 @@ breakdown_qualified (left, right, source)\n     tree *left, *right, source;\n {\n   char *p, *base;\n-  int   l = IDENTIFIER_LENGTH (source);\n+  int l = IDENTIFIER_LENGTH (source);\n \n   base = alloca (l + 1);\n   memcpy (base, IDENTIFIER_POINTER (source), l + 1);\n \n-  /* Breakdown NAME into REMAINDER . IDENTIFIER */\n+  /* Breakdown NAME into REMAINDER . IDENTIFIER.  */\n   p = base + l - 1;\n   while (*p != '.' && p != base)\n     p--;\n \n-  /* We didn't find a '.'. Return an error */\n+  /* We didn't find a '.'. Return an error.  */\n   if (p == base)\n     return 1;\n "}]}