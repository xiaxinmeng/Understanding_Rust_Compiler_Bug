{"sha": "c56684fd61223abd45854270cd1e83ab2f07148c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzU2Njg0ZmQ2MTIyM2FiZDQ1ODU0MjcwY2QxZTgzYWIyZjA3MTQ4Yw==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2020-08-03T16:13:00Z"}, "committer": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2020-08-03T16:13:00Z"}, "message": "Removal of HSA offloading from gcc and libgomp\n\nThis patch removes the generation of HSAIL from the compiler, the HSA\noffloading plugin from libgomp and the associated testsuite tests and\ninfrastructure bits from the respective testsuites.\n\nApart from removal of the obvious files, I removed bits that I found\nby searching for HSA related terms and by re-tracing my steps and\nlooking at the patches that introduced HSA in the first place.  I did\nnot remove everything these patches brought in, for example:\n\n  - the mechanism to pass offload-target specific info from the application to\n    the offloading plugin - but the same mechanism is also used to\n    communicate number of teams and the thread limit to all offload targets.\n\n  - run_func hook in gomp_device_descr stays too, although now it is\n    not used.  If some future offload target would like the ability to\n    refuse to offload some functions, it can use it.  It is easy to\n    remove as a follow-up if it is considered clutter, though.\n\n  - configure options --with-hsa-runtime=PATH, -with-hsa-runtime-include=PATH\n    and --with-hsa-runtime-lib=PATH rmeain because GCN uses them too.\n\n  - Surprisingly, GOMP_TARGET_ARG_HSA_KERNEL_ATTRIBUTES (a constant\n    from gomp-constants.h) appears in the source of the amdgcn libgomp\n    plugin, although I tend to think that code path is not ever used\n    and this patch certainly removes it from the compiler.\n    Nevertheless, it seems it has potential value beyond HSAIL and so\n    I've kept it, it can of course always be easily removed in the\n    future of GCN folk abandon it too.\n\n  - I assume constants OFFLOAD_TARGET_TYPE_HSA and GOMP_DEVICE_HSA\n    need to stay indefinitely too just so that no future offload\n    target picks that number.\n\n  - I have kept dg-require-effective-target\n    offload_device_nonshared_as requirement of thests which have it.\n\nIt is quite probable I missed some small HSA artifacts but those\nshould be easy to remove later as we find them.\n\ninclude/ChangeLog:\n\n2020-07-24  Martin Jambor  <mjambor@suse.cz>\n\n\t* gomp-constants.h (GOMP_VERSION_HSA): Remove.\n\ngcc/ChangeLog:\n\n2020-07-24  Martin Jambor  <mjambor@suse.cz>\n\n\t* hsa-brig-format.h: Moved to brig/brigfrontend.\n\t* hsa-brig.c: Removed.\n\t* hsa-builtins.def: Likewise.\n\t* hsa-common.c: Likewise.\n\t* hsa-common.h: Likewise.\n\t* hsa-dump.c: Likewise.\n\t* hsa-gen.c: Likewise.\n\t* hsa-regalloc.c: Likewise.\n\t* ipa-hsa.c: Likewise.\n\t* omp-grid.c: Likewise.\n\t* omp-grid.h: Likewise.\n\t* Makefile.in (BUILTINS_DEF): Remove hsa-builtins.def.\n\t(OBJS): Remove hsa-common.o, hsa-gen.o, hsa-regalloc.o, hsa-brig.o,\n\thsa-dump.o, ipa-hsa.c and omp-grid.o.\n\t(GTFILES): Removed hsa-common.c and omp-expand.c.\n\t* builtins.def: Remove processing of hsa-builtins.def.\n\t(DEF_HSA_BUILTIN): Remove.\n\t* common.opt (flag_disable_hsa): Remove.\n\t(-Whsa): Ignore.\n\t* config.in (ENABLE_HSA): Removed.\n\t* configure.ac: Removed handling configuration for hsa offloading.\n\t(ENABLE_HSA): Removed.\n\t* configure: Regenerated.\n\t* doc/install.texi (--enable-offload-targets): Remove hsa from the\n\texample.\n\t(--with-hsa-runtime): Reword to reference any HSA run-time, not\n\tspecifically HSA offloading.\n\t* doc/invoke.texi (Option Summary): Remove -Whsa.\n\t(Warning Options): Likewise.\n\t(Optimize Options): Remove hsa-gen-debug-stores.\n\t* doc/passes.texi (Regular IPA passes): Remove section on IPA HSA\n\tpass.\n\t* gimple-low.c (lower_stmt): Remove GIMPLE_OMP_GRID_BODY case.\n\t* gimple-pretty-print.c (dump_gimple_omp_for): Likewise.\n\t(dump_gimple_omp_block): Likewise.\n\t(pp_gimple_stmt_1): Likewise.\n\t* gimple-walk.c (walk_gimple_stmt): Likewise.\n\t* gimple.c (gimple_build_omp_grid_body): Removed function.\n\t(gimple_copy): Remove GIMPLE_OMP_GRID_BODY case.\n\t* gimple.def (GIMPLE_OMP_GRID_BODY): Removed.\n\t* gimple.h (gf_mask): Removed GF_OMP_PARALLEL_GRID_PHONY,\n\tOMP_FOR_KIND_GRID_LOOP, GF_OMP_FOR_GRID_PHONY,\n\tGF_OMP_FOR_GRID_INTRA_GROUP, GF_OMP_FOR_GRID_GROUP_ITER and\n\tGF_OMP_TEAMS_GRID_PHONY.  Renumbered GF_OMP_FOR_KIND_SIMD and\n\tGF_OMP_TEAMS_HOST.\n\t(gimple_build_omp_grid_body): Removed declaration.\n\t(gimple_has_substatements): Remove GIMPLE_OMP_GRID_BODY case.\n\t(gimple_omp_for_grid_phony): Removed.\n\t(gimple_omp_for_set_grid_phony): Likewise.\n\t(gimple_omp_for_grid_intra_group): Likewise.\n\t(gimple_omp_for_grid_intra_group): Likewise.\n\t(gimple_omp_for_grid_group_iter): Likewise.\n\t(gimple_omp_for_set_grid_group_iter): Likewise.\n\t(gimple_omp_parallel_grid_phony): Likewise.\n\t(gimple_omp_parallel_set_grid_phony): Likewise.\n\t(gimple_omp_teams_grid_phony): Likewise.\n\t(gimple_omp_teams_set_grid_phony): Likewise.\n\t(CASE_GIMPLE_OMP): Remove GIMPLE_OMP_GRID_BODY case.\n\t* lto-section-in.c (lto_section_name): Removed hsa.\n\t* lto-streamer.h (lto_section_type): Removed LTO_section_ipa_hsa.\n\t* lto-wrapper.c (compile_images_for_offload_targets): Remove special\n\thandling of hsa.\n\t* omp-expand.c: Do not include hsa-common.h and gt-omp-expand.h.\n\t(parallel_needs_hsa_kernel_p): Removed.\n\t(grid_launch_attributes_trees): Likewise.\n\t(grid_launch_attributes_trees): Likewise.\n\t(grid_create_kernel_launch_attr_types): Likewise.\n\t(grid_insert_store_range_dim): Likewise.\n\t(grid_get_kernel_launch_attributes): Likewise.\n\t(get_target_arguments): Remove code passing HSA grid sizes.\n\t(grid_expand_omp_for_loop): Remove.\n\t(grid_arg_decl_map): Likewise.\n\t(grid_remap_kernel_arg_accesses): Likewise.\n\t(grid_expand_target_grid_body): Likewise.\n\t(expand_omp): Remove call to grid_expand_target_grid_body.\n\t(omp_make_gimple_edges): Remove GIMPLE_OMP_GRID_BODY case.\n\t* omp-general.c: Do not include hsa-common.h.\n\t(omp_maybe_offloaded): Do not check for HSA offloading.\n\t(omp_context_selector_matches): Likewise.\n\t* omp-low.c: Do not include hsa-common.h and omp-grid.h.\n\t(build_outer_var_ref): Remove handling of GIMPLE_OMP_GRID_BODY.\n\t(scan_sharing_clauses): Remove handling of OMP_CLAUSE__GRIDDIM_.\n\t(scan_omp_parallel): Remove handling of the phoney variant.\n\t(check_omp_nesting_restrictions): Remove handling of\n\tGIMPLE_OMP_GRID_BODY and GF_OMP_FOR_KIND_GRID_LOOP.\n\t(scan_omp_1_stmt): Remove handling of GIMPLE_OMP_GRID_BODY.\n\t(lower_omp_for_lastprivate): Remove handling of gridified loops.\n\t(lower_omp_for): Remove phony loop handling.\n\t(lower_omp_taskreg): Remove phony construct handling.\n\t(lower_omp_teams): Likewise.\n\t(lower_omp_grid_body): Removed.\n\t(lower_omp_1): Remove GIMPLE_OMP_GRID_BODY case.\n\t(execute_lower_omp): Do not call omp_grid_gridify_all_targets.\n\t* opts.c (common_handle_option): Do not handle hsa when processing\n\tOPT_foffload_.\n\t* params.opt (hsa-gen-debug-stores): Remove.\n\t* passes.def: Remove pass_ipa_hsa and pass_gen_hsail.\n\t* timevar.def: Remove TV_IPA_HSA.\n\t* toplev.c: Do not include hsa-common.h.\n\t(compile_file): Do not call hsa_output_brig.\n\t* tree-core.h (enum omp_clause_code): Remove OMP_CLAUSE__GRIDDIM_.\n\t(tree_omp_clause): Remove union field dimension.\n\t* tree-nested.c (convert_nonlocal_omp_clauses): Remove the\n\tOMP_CLAUSE__GRIDDIM_ case.\n\t(convert_local_omp_clauses): Likewise.\n\t* tree-pass.h (make_pass_gen_hsail): Remove declaration.\n\t(make_pass_ipa_hsa): Likewise.\n\t* tree-pretty-print.c (dump_omp_clause): Remove GIMPLE_OMP_GRID_BODY\n\tcase.\n\t* tree.c (omp_clause_num_ops): Remove the element corresponding to\n\tOMP_CLAUSE__GRIDDIM_.\n\t(omp_clause_code_name): Likewise.\n\t(walk_tree_1): Remove GIMPLE_OMP_GRID_BODY case.\n\t* tree.h (OMP_CLAUSE__GRIDDIM__DIMENSION): Remove.\n\t(OMP_CLAUSE__GRIDDIM__SIZE): Likewise.\n\t(OMP_CLAUSE__GRIDDIM__GROUP): Likewise.\n\ngcc/fortran/ChangeLog:\n\n2020-07-24  Martin Jambor  <mjambor@suse.cz>\n\n\t* f95-lang.c (gfc_init_builtin_functions): Remove processing of\n\thsa-builtins.def.\n\ngcc/brig/ChangeLog:\n\n2020-07-24  Martin Jambor  <mjambor@suse.cz>\n\n\t* brigfrontend/brig-util.h (hsa_type_packed_p): Declared.\n\t* brigfrontend/brig-util.cc (hsa_type_packed_p): Moved here from\n\tremoved gcc/hsa-common.c.\n\nlibgomp/ChangeLog:\n\n2020-07-24  Martin Jambor  <mjambor@suse.cz>\n\n\t* plugin/Makefrag.am: Remove configuration of HSA plugin.\n\t* aclocal.m4: Regenerated.\n\t* Makefile.in: Regenerated.\n\t* config.h.in: Regenerated.\n\t* configure: Regenerated.\n\t* plugin/configfrag.ac: Likewise.\n\t* plugin/hsa_ext_finalize.h: Removed.\n\t* plugin/plugin-hsa.c: Likewise.\n\t* testsuite/Makefile.in: Regenerated.\n\t* testsuite/lib/libgomp.exp\n\t(offload_target_to_openacc_device_type): Remove hsa case.\n\t(check_effective_target_hsa_offloading_selected_nocache): Removed\n\t(check_effective_target_hsa_offloading_selected): Likewise.\n\t(libgomp_init): Do not add -Wno-hsa to additional_flags.\n\t* testsuite/libgomp.hsa.c/alloca-1.c: Removed test.\n\t* testsuite/libgomp.hsa.c/bitfield-1.c: Likewise.\n\t* testsuite/libgomp.hsa.c/bits-insns.c: Likewise.\n\t* testsuite/libgomp.hsa.c/builtins-1.c: Likewise.\n\t* testsuite/libgomp.hsa.c/c.exp: Likewise.\n\t* testsuite/libgomp.hsa.c/complex-1.c: Likewise.\n\t* testsuite/libgomp.hsa.c/complex-align-2.c: Likewise.\n\t* testsuite/libgomp.hsa.c/formal-actual-args-1.c: Likewise.\n\t* testsuite/libgomp.hsa.c/function-call-1.c: Likewise.\n\t* testsuite/libgomp.hsa.c/get-level-1.c: Likewise.\n\t* testsuite/libgomp.hsa.c/gridify-1.c: Likewise.\n\t* testsuite/libgomp.hsa.c/gridify-2.c: Likewise.\n\t* testsuite/libgomp.hsa.c/gridify-3.c: Likewise.\n\t* testsuite/libgomp.hsa.c/gridify-4.c: Likewise.\n\t* testsuite/libgomp.hsa.c/memory-operations-1.c: Likewise.\n\t* testsuite/libgomp.hsa.c/pr69568.c: Likewise.\n\t* testsuite/libgomp.hsa.c/pr82416.c: Likewise.\n\t* testsuite/libgomp.hsa.c/rotate-1.c: Likewise.\n\t* testsuite/libgomp.hsa.c/staticvar.c: Likewise.\n\t* testsuite/libgomp.hsa.c/switch-1.c: Likewise.\n\t* testsuite/libgomp.hsa.c/switch-branch-1.c: Likewise.\n\t* testsuite/libgomp.hsa.c/switch-sbr-2.c: Likewise.\n\t* testsuite/libgomp.hsa.c/tiling-1.c: Likewise.\n\t* testsuite/libgomp.hsa.c/tiling-2.c: Likewise.\n\ngcc/testsuite/ChangeLog:\n\n2020-07-24  Martin Jambor  <mjambor@suse.cz>\n\n\t* lib/target-supports.exp (check_effective_target_offload_hsa):\n\tRemoved.\n\t* c-c++-common/gomp/gridify-1.c: Removed test.\n\t* c-c++-common/gomp/gridify-2.c: Likewise.\n\t* c-c++-common/gomp/gridify-3.c: Likewise.\n\t* c-c++-common/gomp/hsa-indirect-call-1.c: Likewise.\n\t* gfortran.dg/gomp/gridify-1.f90: Likewise.\n\t* gcc.dg/gomp/gomp.exp: Do not pass -Wno-hsa to tests.\n\t* g++.dg/gomp/gomp.exp: Likewise.\n\t* gfortran.dg/gomp/gomp.exp: Likewise.", "tree": {"sha": "f1ebfbe4dfd00b87f9522b84f78f02ee512e83a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f1ebfbe4dfd00b87f9522b84f78f02ee512e83a8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c56684fd61223abd45854270cd1e83ab2f07148c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c56684fd61223abd45854270cd1e83ab2f07148c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c56684fd61223abd45854270cd1e83ab2f07148c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c56684fd61223abd45854270cd1e83ab2f07148c/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9623f61b142174b87760c81f78928dd14af7cbc6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9623f61b142174b87760c81f78928dd14af7cbc6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9623f61b142174b87760c81f78928dd14af7cbc6"}], "stats": {"total": 21776, "additions": 516, "deletions": 21260}, "files": [{"sha": "b77aa3b651dd1325d16fd46ed68d9f646cf6a5e3", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c56684fd61223abd45854270cd1e83ab2f07148c/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c56684fd61223abd45854270cd1e83ab2f07148c/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=c56684fd61223abd45854270cd1e83ab2f07148c", "patch": "@@ -933,8 +933,7 @@ FIXED_VALUE_H = fixed-value.h\n RTL_H = $(RTL_BASE_H) $(FLAGS_H) genrtl.h\n READ_MD_H = $(OBSTACK_H) $(HASHTAB_H) read-md.h\n BUILTINS_DEF = builtins.def sync-builtins.def omp-builtins.def \\\n-\tgtm-builtins.def sanitizer.def \\\n-\thsa-builtins.def\n+\tgtm-builtins.def sanitizer.def\n INTERNAL_FN_DEF = internal-fn.def\n INTERNAL_FN_H = internal-fn.h $(INTERNAL_FN_DEF)\n TREE_CORE_H = tree-core.h $(CORETYPES_H) all-tree.def tree.def \\\n@@ -1395,11 +1394,6 @@ OBJS = \\\n \thaifa-sched.o \\\n \thash-map-tests.o \\\n \thash-set-tests.o \\\n-\thsa-common.o \\\n-\thsa-gen.o \\\n-\thsa-regalloc.o \\\n-\thsa-brig.o \\\n-\thsa-dump.o \\\n \thw-doloop.o \\\n \thwint.o \\\n \tifcvt.o \\\n@@ -1427,7 +1421,6 @@ OBJS = \\\n \tipa-icf.o \\\n \tipa-icf-gimple.o \\\n \tipa-reference.o \\\n-\tipa-hsa.o \\\n \tipa-ref.o \\\n \tipa-utils.o \\\n \tipa.o \\\n@@ -1471,7 +1464,6 @@ OBJS = \\\n \tomp-offload.o \\\n \tomp-expand.o \\\n \tomp-general.o \\\n-\tomp-grid.o \\\n \tomp-low.o \\\n \tomp-simd-clone.o \\\n \topt-problem.o \\\n@@ -2619,7 +2611,6 @@ GTFILES = $(CPPLIB_H) $(srcdir)/input.h $(srcdir)/coretypes.h \\\n   $(srcdir)/tree-profile.c $(srcdir)/tree-nested.c \\\n   $(srcdir)/omp-offload.h \\\n   $(srcdir)/omp-offload.c \\\n-  $(srcdir)/omp-expand.c \\\n   $(srcdir)/omp-general.c \\\n   $(srcdir)/omp-low.c \\\n   $(srcdir)/targhooks.c $(out_file) $(srcdir)/passes.c $(srcdir)/cgraphunit.c \\\n@@ -2643,7 +2634,6 @@ GTFILES = $(CPPLIB_H) $(srcdir)/input.h $(srcdir)/coretypes.h \\\n   $(srcdir)/sancov.c \\\n   $(srcdir)/ipa-devirt.c \\\n   $(srcdir)/internal-fn.h \\\n-  $(srcdir)/hsa-common.c \\\n   $(srcdir)/calls.c \\\n   $(srcdir)/omp-general.h \\\n   @all_gtfiles@"}, {"sha": "a10f5e6a2a4bacbad98f6ff3fb6fcd0d527dd17c", "filename": "gcc/brig/brigfrontend/brig-util.cc", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c56684fd61223abd45854270cd1e83ab2f07148c/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-util.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c56684fd61223abd45854270cd1e83ab2f07148c/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-util.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-util.cc?ref=c56684fd61223abd45854270cd1e83ab2f07148c", "patch": "@@ -563,3 +563,12 @@ gccbrig_print_reg_use_info (FILE *dump, const regs_use_index &info)\n \t}\n     }\n }\n+\n+/* Return true if TYPE is a packed HSA type.  */\n+\n+bool\n+hsa_type_packed_p (BrigType16_t type)\n+{\n+  return (type & BRIG_TYPE_PACK_MASK) != BRIG_TYPE_PACK_NONE;\n+}\n+"}, {"sha": "b9f5232a935e4ee86637f1755a170ec7bce4242c", "filename": "gcc/brig/brigfrontend/brig-util.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c56684fd61223abd45854270cd1e83ab2f07148c/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-util.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c56684fd61223abd45854270cd1e83ab2f07148c/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-util.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-util.h?ref=c56684fd61223abd45854270cd1e83ab2f07148c", "patch": "@@ -115,4 +115,6 @@ gccbrig_type_vector_subparts (const_tree type)\n   return TYPE_VECTOR_SUBPARTS (type).to_constant ();\n }\n \n+bool hsa_type_packed_p (BrigType16_t type);\n+\n #endif"}, {"sha": "e16f469473eacd45455450ce3d1adf2642f3a347", "filename": "gcc/brig/brigfrontend/hsa-brig-format.h", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c56684fd61223abd45854270cd1e83ab2f07148c/gcc%2Fbrig%2Fbrigfrontend%2Fhsa-brig-format.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c56684fd61223abd45854270cd1e83ab2f07148c/gcc%2Fbrig%2Fbrigfrontend%2Fhsa-brig-format.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fhsa-brig-format.h?ref=c56684fd61223abd45854270cd1e83ab2f07148c", "previous_filename": "gcc/hsa-brig-format.h"}, {"sha": "102322b79121ae0d221b531aaa76206523980367", "filename": "gcc/builtins.def", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c56684fd61223abd45854270cd1e83ab2f07148c/gcc%2Fbuiltins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c56684fd61223abd45854270cd1e83ab2f07148c/gcc%2Fbuiltins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.def?ref=c56684fd61223abd45854270cd1e83ab2f07148c", "patch": "@@ -222,19 +222,6 @@ along with GCC; see the file COPYING3.  If not see\n \t\t|| flag_tree_parallelize_loops > 1 \\\n \t\t|| flag_offload_abi != OFFLOAD_ABI_UNSET))\n \n-#undef DEF_HSA_BUILTIN\n-#ifdef ENABLE_HSA\n-#define DEF_HSA_BUILTIN(ENUM, NAME, TYPE, ATTRS)\t\t\t\\\n-  DEF_BUILTIN (ENUM, \"__builtin_\" NAME, BUILT_IN_NORMAL, TYPE, TYPE,    \\\n-               false, false, true, ATTRS, false, \\\n-\t       (!flag_disable_hsa))\n-#else\n-#define DEF_HSA_BUILTIN(ENUM, NAME, TYPE, ATTRS)\t\t\t\\\n-  DEF_BUILTIN (ENUM, \"__builtin_\" NAME, BUILT_IN_NORMAL, TYPE, TYPE,    \\\n-               false, false, true, ATTRS, false, \\\n-\t       (false))\n-#endif\n-\n /* Builtin used by the implementation of GNU TM.  These\n    functions are mapped to the actual implementation of the STM library. */\n #undef DEF_TM_BUILTIN\n@@ -1063,9 +1050,6 @@ DEF_GCC_BUILTIN (BUILT_IN_LINE, \"LINE\", BT_FN_INT, ATTR_NOTHROW_LEAF_LIST)\n /* Offloading and Multi Processing builtins.  */\n #include \"omp-builtins.def\"\n \n-/* Heterogeneous Systems Architecture.  */\n-#include \"hsa-builtins.def\"\n-\n /* GTM builtins. */\n #include \"gtm-builtins.def\"\n "}, {"sha": "c16d1faff8898ff27223085223cf6609431b3e8a", "filename": "gcc/common.opt", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c56684fd61223abd45854270cd1e83ab2f07148c/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c56684fd61223abd45854270cd1e83ab2f07148c/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=c56684fd61223abd45854270cd1e83ab2f07148c", "patch": "@@ -228,10 +228,6 @@ unsigned int flag_sanitize_coverage\n Variable\n bool dump_base_name_prefixed = false\n \n-; Flag whether HSA generation has been explicitely disabled\n-Variable\n-bool flag_disable_hsa = false\n-\n ###\n Driver\n \n@@ -619,8 +615,8 @@ Common Var(warn_free_nonheap_object) Init(1) Warning\n Warn when attempting to free a non-heap object.\n \n Whsa\n-Common Var(warn_hsa) Init(1) Warning\n-Warn when a function cannot be expanded to HSAIL.\n+Common Ignore Warning\n+Does nothing.  Preserved for backward compatibility.\n \n Wimplicit-fallthrough\n Common Alias(Wimplicit-fallthrough=,3,0) Warning"}, {"sha": "478e74fac0221a7eb84eb9ec9aa4663d01e46ff0", "filename": "gcc/config.in", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c56684fd61223abd45854270cd1e83ab2f07148c/gcc%2Fconfig.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c56684fd61223abd45854270cd1e83ab2f07148c/gcc%2Fconfig.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.in?ref=c56684fd61223abd45854270cd1e83ab2f07148c", "patch": "@@ -181,12 +181,6 @@\n #endif\n \n \n-/* Define this to enable support for generating HSAIL. */\n-#ifndef USED_FOR_TARGET\n-#undef ENABLE_HSA\n-#endif\n-\n-\n /* Define if gcc should always pass --build-id to linker. */\n #ifndef USED_FOR_TARGET\n #undef ENABLE_LD_BUILDID"}, {"sha": "0f7a8dbe0f9837630576c6c0495b6bea49d1a5ad", "filename": "gcc/configure", "status": "modified", "additions": 22, "deletions": 32, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c56684fd61223abd45854270cd1e83ab2f07148c/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c56684fd61223abd45854270cd1e83ab2f07148c/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=c56684fd61223abd45854270cd1e83ab2f07148c", "patch": "@@ -7948,30 +7948,26 @@ fi\n for tgt in `echo $enable_offload_targets | sed 's/,/ /g'`; do\n   tgt=`echo $tgt | sed 's/=.*//'`\n \n-  if echo \"$tgt\" | grep \"^hsa\" > /dev/null ; then\n-    enable_hsa=1\n-  else\n-    enable_offloading=1\n-    case \"$tgt\" in\n-      *-intelmic-* | *-intelmicemul-*)\n-\tomp_device_property=omp-device-properties-i386\n-\tomp_device_property_tmake_file=\"${omp_device_property_tmake_file} \\$(srcdir)/config/i386/t-omp-device\"\n-\t;;\n-      amdgcn*)\n-\tomp_device_property=omp-device-properties-gcn\n-\tomp_device_property_tmake_file=\"${omp_device_property_tmake_file} \\$(srcdir)/config/gcn/t-omp-device\"\n-\t;;\n-      nvptx*)\n-\tomp_device_property=omp-device-properties-nvptx\n-\tomp_device_property_tmake_file=\"${omp_device_property_tmake_file} \\$(srcdir)/config/nvptx/t-omp-device\"\n-\t;;\n-      *)\n-\tas_fn_error $? \"unknown offload target specified\" \"$LINENO\" 5\n-\t;;\n-    esac\n-    omp_device_properties=\"${omp_device_properties} ${tgt}=${omp_device_property}\"\n-    omp_device_property_deps=\"${omp_device_property_deps} ${omp_device_property}\"\n-  fi\n+  enable_offloading=1\n+  case \"$tgt\" in\n+    *-intelmic-* | *-intelmicemul-*)\n+  \tomp_device_property=omp-device-properties-i386\n+  \tomp_device_property_tmake_file=\"${omp_device_property_tmake_file} \\$(srcdir)/config/i386/t-omp-device\"\n+  \t;;\n+    amdgcn*)\n+  \tomp_device_property=omp-device-properties-gcn\n+  \tomp_device_property_tmake_file=\"${omp_device_property_tmake_file} \\$(srcdir)/config/gcn/t-omp-device\"\n+  \t;;\n+    nvptx*)\n+  \tomp_device_property=omp-device-properties-nvptx\n+  \tomp_device_property_tmake_file=\"${omp_device_property_tmake_file} \\$(srcdir)/config/nvptx/t-omp-device\"\n+  \t;;\n+    *)\n+  \tas_fn_error $? \"unknown offload target specified\" \"$LINENO\" 5\n+  \t;;\n+  esac\n+  omp_device_properties=\"${omp_device_properties} ${tgt}=${omp_device_property}\"\n+  omp_device_property_deps=\"${omp_device_property_deps} ${omp_device_property}\"\n \n   if test x\"$offload_targets\" = x; then\n     offload_targets=$tgt\n@@ -7997,12 +7993,6 @@ $as_echo \"#define ENABLE_OFFLOADING 0\" >>confdefs.h\n \n fi\n \n-if test x\"$enable_hsa\" = x1 ; then\n-\n-$as_echo \"#define ENABLE_HSA 1\" >>confdefs.h\n-\n-fi\n-\n \n # Check whether --with-multilib-list was given.\n if test \"${with_multilib_list+set}\" = set; then :\n@@ -19023,7 +19013,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 19026 \"configure\"\n+#line 19016 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -19129,7 +19119,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 19132 \"configure\"\n+#line 19122 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H"}, {"sha": "0f11238c19f0ffe79b89758d6f344f3ff53faec9", "filename": "gcc/configure.ac", "status": "modified", "additions": 20, "deletions": 29, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c56684fd61223abd45854270cd1e83ab2f07148c/gcc%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c56684fd61223abd45854270cd1e83ab2f07148c/gcc%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.ac?ref=c56684fd61223abd45854270cd1e83ab2f07148c", "patch": "@@ -1057,30 +1057,26 @@ AC_SUBST(accel_dir_suffix)\n for tgt in `echo $enable_offload_targets | sed 's/,/ /g'`; do\n   tgt=`echo $tgt | sed 's/=.*//'`\n \n-  if echo \"$tgt\" | grep \"^hsa\" > /dev/null ; then\n-    enable_hsa=1\n-  else\n-    enable_offloading=1\n-    case \"$tgt\" in\n-      *-intelmic-* | *-intelmicemul-*)\n-\tomp_device_property=omp-device-properties-i386\n-\tomp_device_property_tmake_file=\"${omp_device_property_tmake_file} \\$(srcdir)/config/i386/t-omp-device\"\n-\t;;\n-      amdgcn*)\n-\tomp_device_property=omp-device-properties-gcn\n-\tomp_device_property_tmake_file=\"${omp_device_property_tmake_file} \\$(srcdir)/config/gcn/t-omp-device\"\n-\t;;\n-      nvptx*)\n-\tomp_device_property=omp-device-properties-nvptx\n-\tomp_device_property_tmake_file=\"${omp_device_property_tmake_file} \\$(srcdir)/config/nvptx/t-omp-device\"\n-\t;;\n-      *)\n-\tAC_MSG_ERROR([unknown offload target specified])\n-\t;;\n-    esac\n-    omp_device_properties=\"${omp_device_properties} ${tgt}=${omp_device_property}\"\n-    omp_device_property_deps=\"${omp_device_property_deps} ${omp_device_property}\"\n-  fi\n+  enable_offloading=1\n+  case \"$tgt\" in\n+    *-intelmic-* | *-intelmicemul-*)\n+  \tomp_device_property=omp-device-properties-i386\n+  \tomp_device_property_tmake_file=\"${omp_device_property_tmake_file} \\$(srcdir)/config/i386/t-omp-device\"\n+  \t;;\n+    amdgcn*)\n+  \tomp_device_property=omp-device-properties-gcn\n+  \tomp_device_property_tmake_file=\"${omp_device_property_tmake_file} \\$(srcdir)/config/gcn/t-omp-device\"\n+  \t;;\n+    nvptx*)\n+  \tomp_device_property=omp-device-properties-nvptx\n+  \tomp_device_property_tmake_file=\"${omp_device_property_tmake_file} \\$(srcdir)/config/nvptx/t-omp-device\"\n+  \t;;\n+    *)\n+  \tAC_MSG_ERROR([unknown offload target specified])\n+  \t;;\n+  esac\n+  omp_device_properties=\"${omp_device_properties} ${tgt}=${omp_device_property}\"\n+  omp_device_property_deps=\"${omp_device_property_deps} ${omp_device_property}\"\n \n   if test x\"$offload_targets\" = x; then\n     offload_targets=$tgt\n@@ -1101,11 +1097,6 @@ else\n     [Define this to enable support for offloading.])\n fi\n \n-if test x\"$enable_hsa\" = x1 ; then\n-  AC_DEFINE(ENABLE_HSA, 1,\n-    [Define this to enable support for generating HSAIL.])\n-fi\n-\n AC_ARG_WITH(multilib-list,\n [AS_HELP_STRING([--with-multilib-list], [select multilibs (AArch64, SH and x86-64 only)])],\n :,"}, {"sha": "e1ca876d729cea8a5a498698d87d19018fea9143", "filename": "gcc/doc/install.texi", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c56684fd61223abd45854270cd1e83ab2f07148c/gcc%2Fdoc%2Finstall.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c56684fd61223abd45854270cd1e83ab2f07148c/gcc%2Fdoc%2Finstall.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finstall.texi?ref=c56684fd61223abd45854270cd1e83ab2f07148c", "patch": "@@ -2194,22 +2194,18 @@ specifying paths @var{path1}, @dots{}, @var{pathN}.\n \n @smallexample\n % @var{srcdir}/configure \\\n-    --enable-offload-targets=x86_64-intelmicemul-linux-gnu=/path/to/x86_64/compiler,nvptx-none,hsa\n+    --enable-offload-targets=x86_64-intelmicemul-linux-gnu=/path/to/x86_64/compiler,nvptx-none\n @end smallexample\n \n-If @samp{hsa} is specified as one of the targets, the compiler will be\n-built with support for HSA GPU accelerators.  Because the same\n-compiler will emit the accelerator code, no path should be specified.\n-\n @item --with-hsa-runtime=@var{pathname}\n @itemx --with-hsa-runtime-include=@var{pathname}\n @itemx --with-hsa-runtime-lib=@var{pathname}\n \n-If you configure GCC with HSA offloading but do not have the HSA\n-run-time library installed in a standard location then you can\n-explicitly specify the directory where they are installed.  The\n-@option{--with-hsa-runtime=@/@var{hsainstalldir}} option is a\n-shorthand for\n+If you configure GCC with offloading which uses an HSA run-time such as\n+AMDGCN but do not have the HSA run-time library installed in a standard\n+location then you can explicitly specify the directory where they are\n+installed.  The @option{--with-hsa-runtime=@/@var{hsainstalldir}} option\n+is a shorthand for\n @option{--with-hsa-runtime-lib=@/@var{hsainstalldir}/lib} and\n @option{--with-hsa-runtime-include=@/@var{hsainstalldir}/include}.\n "}, {"sha": "003b99827b5cc876d41410883fc3ad7fc0d61911", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c56684fd61223abd45854270cd1e83ab2f07148c/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c56684fd61223abd45854270cd1e83ab2f07148c/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=c56684fd61223abd45854270cd1e83ab2f07148c", "patch": "@@ -332,7 +332,7 @@ Objective-C and Objective-C++ Dialects}.\n -Wformat-security  -Wformat-signedness  -Wformat-truncation=@var{n} @gol\n -Wformat-y2k  -Wframe-address @gol\n -Wframe-larger-than=@var{byte-size}  -Wno-free-nonheap-object @gol\n--Wno-hsa  -Wno-if-not-aligned  -Wno-ignored-attributes @gol\n+-Wno-if-not-aligned  -Wno-ignored-attributes @gol\n -Wignored-qualifiers  -Wno-incompatible-pointer-types @gol\n -Wimplicit  -Wimplicit-fallthrough  -Wimplicit-fallthrough=@var{n} @gol\n -Wno-implicit-function-declaration  -Wno-implicit-int @gol\n@@ -8591,12 +8591,6 @@ Suppress warnings when a positional initializer is used to initialize\n a structure that has been marked with the @code{designated_init}\n attribute.\n \n-@item -Wno-hsa\n-@opindex Whsa\n-@opindex Wno-hsa\n-Do not warn when HSAIL cannot be emitted for the compiled function or\n-OpenMP construct.  These warnings are enabled by default.\n-\n @end table\n \n @node Static Analyzer Options\n@@ -13393,12 +13387,6 @@ Maximum depth of recursion when querying properties of SSA names in things\n like fold routines.  One level of recursion corresponds to following a\n use-def chain.\n \n-@item hsa-gen-debug-stores\n-Enable emission of special debug stores within HSA kernels which are\n-then read and reported by libgomp plugin.  Generation of these stores\n-is disabled by default, use @option{--param hsa-gen-debug-stores=1} to\n-enable it.\n-\n @item max-speculative-devirt-maydefs\n The maximum number of may-defs we analyze when looking for a must-def\n specifying the dynamic type of an object that invokes a virtual call"}, {"sha": "a5ae4143a8c1293e674b499120372ee5fe5c412b", "filename": "gcc/doc/passes.texi", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c56684fd61223abd45854270cd1e83ab2f07148c/gcc%2Fdoc%2Fpasses.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c56684fd61223abd45854270cd1e83ab2f07148c/gcc%2Fdoc%2Fpasses.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fpasses.texi?ref=c56684fd61223abd45854270cd1e83ab2f07148c", "patch": "@@ -360,13 +360,6 @@ target doesn't support constructors and destructors natively.  The\n pass is located in @file{ipa.c} and is described by\n @code{pass_ipa_cdtor_merge}.\n \n-@item IPA HSA\n-\n-This pass is part of the GCC support for HSA (Heterogeneous System\n-Architecture) accelerators.  It is responsible for creation of HSA\n-clones and emitting HSAIL instructions for them.  It is located in\n-@file{ipa-hsa.c} and is described by @code{pass_ipa_hsa}.\n-\n @item IPA function summary\n \n This pass provides function analysis for inter-procedural passes."}, {"sha": "e3288d7f576eaa89f20d69251ef4b3bb1916f742", "filename": "gcc/fortran/f95-lang.c", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c56684fd61223abd45854270cd1e83ab2f07148c/gcc%2Ffortran%2Ff95-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c56684fd61223abd45854270cd1e83ab2f07148c/gcc%2Ffortran%2Ff95-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ff95-lang.c?ref=c56684fd61223abd45854270cd1e83ab2f07148c", "patch": "@@ -1238,17 +1238,6 @@ gfc_init_builtin_functions (void)\n #undef DEF_GOMP_BUILTIN\n     }\n \n-#ifdef ENABLE_HSA\n-  if (!flag_disable_hsa)\n-    {\n-#undef DEF_HSA_BUILTIN\n-#define DEF_HSA_BUILTIN(code, name, type, attr) \\\n-      gfc_define_builtin (\"__builtin_\" name, builtin_types[type], \\\n-\t\t\t  code, name, attr);\n-#include \"../hsa-builtins.def\"\n-    }\n-#endif\n-\n   gfc_define_builtin (\"__builtin_trap\", builtin_types[BT_FN_VOID],\n \t\t      BUILT_IN_TRAP, NULL, ATTR_NOTHROW_LEAF_LIST);\n   TREE_THIS_VOLATILE (builtin_decl_explicit (BUILT_IN_TRAP)) = 1;"}, {"sha": "e744d2a9cf8a2546933da432410892a1a82ccf6d", "filename": "gcc/gimple-low.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c56684fd61223abd45854270cd1e83ab2f07148c/gcc%2Fgimple-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c56684fd61223abd45854270cd1e83ab2f07148c/gcc%2Fgimple-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-low.c?ref=c56684fd61223abd45854270cd1e83ab2f07148c", "patch": "@@ -393,7 +393,6 @@ lower_stmt (gimple_stmt_iterator *gsi, struct lower_data *data)\n     case GIMPLE_OMP_TASK:\n     case GIMPLE_OMP_TARGET:\n     case GIMPLE_OMP_TEAMS:\n-    case GIMPLE_OMP_GRID_BODY:\n       data->cannot_fallthru = false;\n       lower_omp_directive (gsi, data);\n       data->cannot_fallthru = false;"}, {"sha": "a01bf90165745b00c5316176902cc9a63ce67b39", "filename": "gcc/gimple-pretty-print.c", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c56684fd61223abd45854270cd1e83ab2f07148c/gcc%2Fgimple-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c56684fd61223abd45854270cd1e83ab2f07148c/gcc%2Fgimple-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-pretty-print.c?ref=c56684fd61223abd45854270cd1e83ab2f07148c", "patch": "@@ -1498,9 +1498,6 @@ dump_gimple_omp_for (pretty_printer *buffer, const gomp_for *gs, int spc,\n \tcase GF_OMP_FOR_KIND_SIMD:\n \t  pp_string (buffer, \"#pragma omp simd\");\n \t  break;\n-\tcase GF_OMP_FOR_KIND_GRID_LOOP:\n-\t  pp_string (buffer, \"#pragma omp for grid_loop\");\n-\t  break;\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n@@ -1836,9 +1833,6 @@ dump_gimple_omp_block (pretty_printer *buffer, const gimple *gs, int spc,\n \tcase GIMPLE_OMP_SECTION:\n \t  pp_string (buffer, \"#pragma omp section\");\n \t  break;\n-\tcase GIMPLE_OMP_GRID_BODY:\n-\t  pp_string (buffer, \"#pragma omp gridified body\");\n-\t  break;\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n@@ -2703,7 +2697,6 @@ pp_gimple_stmt_1 (pretty_printer *buffer, const gimple *gs, int spc,\n \n     case GIMPLE_OMP_MASTER:\n     case GIMPLE_OMP_SECTION:\n-    case GIMPLE_OMP_GRID_BODY:\n       dump_gimple_omp_block (buffer, gs, spc, flags);\n       break;\n "}, {"sha": "a1ae3aa4060e7111d3b7035a774a80afa303aff0", "filename": "gcc/gimple-walk.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c56684fd61223abd45854270cd1e83ab2f07148c/gcc%2Fgimple-walk.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c56684fd61223abd45854270cd1e83ab2f07148c/gcc%2Fgimple-walk.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-walk.c?ref=c56684fd61223abd45854270cd1e83ab2f07148c", "patch": "@@ -668,7 +668,6 @@ walk_gimple_stmt (gimple_stmt_iterator *gsi, walk_stmt_fn callback_stmt,\n     case GIMPLE_OMP_SINGLE:\n     case GIMPLE_OMP_TARGET:\n     case GIMPLE_OMP_TEAMS:\n-    case GIMPLE_OMP_GRID_BODY:\n       ret = walk_gimple_seq_mod (gimple_omp_body_ptr (stmt), callback_stmt,\n \t\t\t     callback_op, wi);\n       if (ret)"}, {"sha": "41f7cf38b1c902059f3e42b2a66f835b3598a9af", "filename": "gcc/gimple.c", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c56684fd61223abd45854270cd1e83ab2f07148c/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c56684fd61223abd45854270cd1e83ab2f07148c/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=c56684fd61223abd45854270cd1e83ab2f07148c", "patch": "@@ -1035,20 +1035,6 @@ gimple_build_omp_master (gimple_seq body)\n   return p;\n }\n \n-/* Build a GIMPLE_OMP_GRID_BODY statement.\n-\n-   BODY is the sequence of statements to be executed by the kernel.  */\n-\n-gimple *\n-gimple_build_omp_grid_body (gimple_seq body)\n-{\n-  gimple *p = gimple_alloc (GIMPLE_OMP_GRID_BODY, 0);\n-  if (body)\n-    gimple_omp_set_body (p, body);\n-\n-  return p;\n-}\n-\n /* Build a GIMPLE_OMP_TASKGROUP statement.\n \n    BODY is the sequence of statements to be executed by the taskgroup\n@@ -2018,7 +2004,6 @@ gimple_copy (gimple *stmt)\n \n \tcase GIMPLE_OMP_SECTION:\n \tcase GIMPLE_OMP_MASTER:\n-\tcase GIMPLE_OMP_GRID_BODY:\n \tcopy_omp_body:\n \t  new_seq = gimple_seq_copy (gimple_omp_body (stmt));\n \t  gimple_omp_set_body (copy, new_seq);"}, {"sha": "4aa6f3d252369e7544e22d7350aa693808c3dd35", "filename": "gcc/gimple.def", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c56684fd61223abd45854270cd1e83ab2f07148c/gcc%2Fgimple.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c56684fd61223abd45854270cd1e83ab2f07148c/gcc%2Fgimple.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.def?ref=c56684fd61223abd45854270cd1e83ab2f07148c", "patch": "@@ -384,10 +384,6 @@ DEFGSCODE(GIMPLE_OMP_TEAMS, \"gimple_omp_teams\", GSS_OMP_PARALLEL_LAYOUT)\n    CLAUSES is an OMP_CLAUSE chain holding the associated clauses.  */\n DEFGSCODE(GIMPLE_OMP_ORDERED, \"gimple_omp_ordered\", GSS_OMP_SINGLE_LAYOUT)\n \n-/* GIMPLE_OMP_GRID_BODY <BODY> represents a parallel loop lowered for execution\n-   on a GPU.  It is an artificial statement created by omp lowering.  */\n-DEFGSCODE(GIMPLE_OMP_GRID_BODY, \"gimple_omp_gpukernel\", GSS_OMP)\n-\n /* GIMPLE_PREDICT <PREDICT, OUTCOME> specifies a hint for branch prediction.\n \n    PREDICT is one of the predictors from predict.def."}, {"sha": "6f7c7ff6a5fd76364cc6e72deebd3e38dc103cfb", "filename": "gcc/gimple.h", "status": "modified", "additions": 3, "deletions": 124, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c56684fd61223abd45854270cd1e83ab2f07148c/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c56684fd61223abd45854270cd1e83ab2f07148c/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=c56684fd61223abd45854270cd1e83ab2f07148c", "patch": "@@ -150,25 +150,16 @@ enum gf_mask {\n     GF_CALL_BY_DESCRIPTOR\t= 1 << 10,\n     GF_CALL_NOCF_CHECK\t\t= 1 << 11,\n     GF_OMP_PARALLEL_COMBINED\t= 1 << 0,\n-    GF_OMP_PARALLEL_GRID_PHONY = 1 << 1,\n     GF_OMP_TASK_TASKLOOP\t= 1 << 0,\n     GF_OMP_TASK_TASKWAIT\t= 1 << 1,\n     GF_OMP_FOR_KIND_MASK\t= (1 << 3) - 1,\n     GF_OMP_FOR_KIND_FOR\t\t= 0,\n     GF_OMP_FOR_KIND_DISTRIBUTE\t= 1,\n     GF_OMP_FOR_KIND_TASKLOOP\t= 2,\n     GF_OMP_FOR_KIND_OACC_LOOP\t= 4,\n-    GF_OMP_FOR_KIND_GRID_LOOP\t= 5,\n-    GF_OMP_FOR_KIND_SIMD\t= 6,\n+    GF_OMP_FOR_KIND_SIMD\t= 5,\n     GF_OMP_FOR_COMBINED\t\t= 1 << 3,\n     GF_OMP_FOR_COMBINED_INTO\t= 1 << 4,\n-    /* The following flag must not be used on GF_OMP_FOR_KIND_GRID_LOOP loop\n-       statements.  */\n-    GF_OMP_FOR_GRID_PHONY\t= 1 << 5,\n-    /* The following two flags should only be set on GF_OMP_FOR_KIND_GRID_LOOP\n-       loop statements.  */\n-    GF_OMP_FOR_GRID_INTRA_GROUP\t= 1 << 5,\n-    GF_OMP_FOR_GRID_GROUP_ITER  = 1 << 6,\n     GF_OMP_TARGET_KIND_MASK\t= (1 << 4) - 1,\n     GF_OMP_TARGET_KIND_REGION\t= 0,\n     GF_OMP_TARGET_KIND_DATA\t= 1,\n@@ -183,8 +174,7 @@ enum gf_mask {\n     GF_OMP_TARGET_KIND_OACC_ENTER_EXIT_DATA = 10,\n     GF_OMP_TARGET_KIND_OACC_DECLARE = 11,\n     GF_OMP_TARGET_KIND_OACC_HOST_DATA = 12,\n-    GF_OMP_TEAMS_GRID_PHONY\t= 1 << 0,\n-    GF_OMP_TEAMS_HOST\t\t= 1 << 1,\n+    GF_OMP_TEAMS_HOST\t\t= 1 << 0,\n \n     /* True on an GIMPLE_OMP_RETURN statement if the return does not require\n        a thread synchronization via some sort of barrier.  The exact barrier\n@@ -1559,7 +1549,6 @@ gomp_task *gimple_build_omp_task (gimple_seq, tree, tree, tree, tree,\n \t\t\t\t       tree, tree);\n gimple *gimple_build_omp_section (gimple_seq);\n gimple *gimple_build_omp_master (gimple_seq);\n-gimple *gimple_build_omp_grid_body (gimple_seq);\n gimple *gimple_build_omp_taskgroup (gimple_seq, tree);\n gomp_continue *gimple_build_omp_continue (tree, tree);\n gomp_ordered *gimple_build_omp_ordered (gimple_seq, tree);\n@@ -1830,7 +1819,6 @@ gimple_has_substatements (gimple *g)\n     case GIMPLE_OMP_CRITICAL:\n     case GIMPLE_WITH_CLEANUP_EXPR:\n     case GIMPLE_TRANSACTION:\n-    case GIMPLE_OMP_GRID_BODY:\n       return true;\n \n     default:\n@@ -5440,76 +5428,6 @@ gimple_omp_for_set_pre_body (gimple *gs, gimple_seq pre_body)\n   omp_for_stmt->pre_body = pre_body;\n }\n \n-/* Return the kernel_phony of OMP_FOR statement.  */\n-\n-static inline bool\n-gimple_omp_for_grid_phony (const gomp_for *omp_for)\n-{\n-  gcc_checking_assert (gimple_omp_for_kind (omp_for)\n-\t\t       != GF_OMP_FOR_KIND_GRID_LOOP);\n-  return (gimple_omp_subcode (omp_for) & GF_OMP_FOR_GRID_PHONY) != 0;\n-}\n-\n-/* Set kernel_phony flag of OMP_FOR to VALUE.  */\n-\n-static inline void\n-gimple_omp_for_set_grid_phony (gomp_for *omp_for, bool value)\n-{\n-  gcc_checking_assert (gimple_omp_for_kind (omp_for)\n-\t\t       != GF_OMP_FOR_KIND_GRID_LOOP);\n-  if (value)\n-    omp_for->subcode |= GF_OMP_FOR_GRID_PHONY;\n-  else\n-    omp_for->subcode &= ~GF_OMP_FOR_GRID_PHONY;\n-}\n-\n-/* Return the kernel_intra_group of a GRID_LOOP OMP_FOR statement.  */\n-\n-static inline bool\n-gimple_omp_for_grid_intra_group (const gomp_for *omp_for)\n-{\n-  gcc_checking_assert (gimple_omp_for_kind (omp_for)\n-\t\t       == GF_OMP_FOR_KIND_GRID_LOOP);\n-  return (gimple_omp_subcode (omp_for) & GF_OMP_FOR_GRID_INTRA_GROUP) != 0;\n-}\n-\n-/* Set kernel_intra_group flag of OMP_FOR to VALUE.  */\n-\n-static inline void\n-gimple_omp_for_set_grid_intra_group (gomp_for *omp_for, bool value)\n-{\n-  gcc_checking_assert (gimple_omp_for_kind (omp_for)\n-\t\t       == GF_OMP_FOR_KIND_GRID_LOOP);\n-  if (value)\n-    omp_for->subcode |= GF_OMP_FOR_GRID_INTRA_GROUP;\n-  else\n-    omp_for->subcode &= ~GF_OMP_FOR_GRID_INTRA_GROUP;\n-}\n-\n-/* Return true if iterations of a grid OMP_FOR statement correspond to HSA\n-   groups.  */\n-\n-static inline bool\n-gimple_omp_for_grid_group_iter (const gomp_for *omp_for)\n-{\n-  gcc_checking_assert (gimple_omp_for_kind (omp_for)\n-\t\t       == GF_OMP_FOR_KIND_GRID_LOOP);\n-  return (gimple_omp_subcode (omp_for) & GF_OMP_FOR_GRID_GROUP_ITER) != 0;\n-}\n-\n-/* Set group_iter flag of OMP_FOR to VALUE.  */\n-\n-static inline void\n-gimple_omp_for_set_grid_group_iter (gomp_for *omp_for, bool value)\n-{\n-  gcc_checking_assert (gimple_omp_for_kind (omp_for)\n-\t\t       == GF_OMP_FOR_KIND_GRID_LOOP);\n-  if (value)\n-    omp_for->subcode |= GF_OMP_FOR_GRID_GROUP_ITER;\n-  else\n-    omp_for->subcode &= ~GF_OMP_FOR_GRID_GROUP_ITER;\n-}\n-\n /* Return the clauses associated with OMP_PARALLEL GS.  */\n \n static inline tree\n@@ -5595,25 +5513,6 @@ gimple_omp_parallel_set_data_arg (gomp_parallel *omp_parallel_stmt,\n   omp_parallel_stmt->data_arg = data_arg;\n }\n \n-/* Return the kernel_phony flag of OMP_PARALLEL_STMT.  */\n-\n-static inline bool\n-gimple_omp_parallel_grid_phony (const gomp_parallel *stmt)\n-{\n-  return (gimple_omp_subcode (stmt) & GF_OMP_PARALLEL_GRID_PHONY) != 0;\n-}\n-\n-/* Set kernel_phony flag of OMP_PARALLEL_STMT to VALUE.  */\n-\n-static inline void\n-gimple_omp_parallel_set_grid_phony (gomp_parallel *stmt, bool value)\n-{\n-  if (value)\n-    stmt->subcode |= GF_OMP_PARALLEL_GRID_PHONY;\n-  else\n-    stmt->subcode &= ~GF_OMP_PARALLEL_GRID_PHONY;\n-}\n-\n /* Return the clauses associated with OMP_TASK GS.  */\n \n static inline tree\n@@ -6165,25 +6064,6 @@ gimple_omp_teams_set_data_arg (gomp_teams *omp_teams_stmt, tree data_arg)\n   omp_teams_stmt->data_arg = data_arg;\n }\n \n-/* Return the kernel_phony flag of an OMP_TEAMS_STMT.  */\n-\n-static inline bool\n-gimple_omp_teams_grid_phony (const gomp_teams *omp_teams_stmt)\n-{\n-  return (gimple_omp_subcode (omp_teams_stmt) & GF_OMP_TEAMS_GRID_PHONY) != 0;\n-}\n-\n-/* Set kernel_phony flag of an OMP_TEAMS_STMT to VALUE.  */\n-\n-static inline void\n-gimple_omp_teams_set_grid_phony (gomp_teams *omp_teams_stmt, bool value)\n-{\n-  if (value)\n-    omp_teams_stmt->subcode |= GF_OMP_TEAMS_GRID_PHONY;\n-  else\n-    omp_teams_stmt->subcode &= ~GF_OMP_TEAMS_GRID_PHONY;\n-}\n-\n /* Return the host flag of an OMP_TEAMS_STMT.  */\n \n static inline bool\n@@ -6547,8 +6427,7 @@ gimple_return_set_retval (greturn *gs, tree retval)\n     case GIMPLE_OMP_RETURN:\t\t\t\\\n     case GIMPLE_OMP_ATOMIC_LOAD:\t\t\\\n     case GIMPLE_OMP_ATOMIC_STORE:\t\t\\\n-    case GIMPLE_OMP_CONTINUE:\t\t\t\\\n-    case GIMPLE_OMP_GRID_BODY\n+    case GIMPLE_OMP_CONTINUE\n \n static inline bool\n is_gimple_omp (const gimple *stmt)"}, {"sha": "545385fd4aa0c4433ca6a155871bc757752d3c3d", "filename": "gcc/hsa-brig.c", "status": "removed", "additions": 0, "deletions": 2612, "changes": 2612, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9623f61b142174b87760c81f78928dd14af7cbc6/gcc%2Fhsa-brig.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9623f61b142174b87760c81f78928dd14af7cbc6/gcc%2Fhsa-brig.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhsa-brig.c?ref=9623f61b142174b87760c81f78928dd14af7cbc6", "patch": "@@ -1,2612 +0,0 @@\n-/* Producing binary form of HSA BRIG from our internal representation.\n-   Copyright (C) 2013-2020 Free Software Foundation, Inc.\n-   Contributed by Martin Jambor <mjambor@suse.cz> and\n-   Martin Liska <mliska@suse.cz>.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"target.h\"\n-#include \"memmodel.h\"\n-#include \"tm_p.h\"\n-#include \"is-a.h\"\n-#include \"vec.h\"\n-#include \"hash-table.h\"\n-#include \"hash-map.h\"\n-#include \"tree.h\"\n-#include \"tree-iterator.h\"\n-#include \"stor-layout.h\"\n-#include \"output.h\"\n-#include \"basic-block.h\"\n-#include \"function.h\"\n-#include \"cfg.h\"\n-#include \"fold-const.h\"\n-#include \"stringpool.h\"\n-#include \"gimple-pretty-print.h\"\n-#include \"diagnostic-core.h\"\n-#include \"cgraph.h\"\n-#include \"dumpfile.h\"\n-#include \"print-tree.h\"\n-#include \"alloc-pool.h\"\n-#include \"symbol-summary.h\"\n-#include \"hsa-common.h\"\n-#include \"gomp-constants.h\"\n-\n-/* Convert VAL to little endian form, if necessary.  */\n-\n-static uint16_t\n-lendian16 (uint16_t val)\n-{\n-#if GCC_VERSION >= 4008\n-#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__\n-  return val;\n-#elif __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__\n-  return __builtin_bswap16 (val);\n-#else   /* __ORDER_PDP_ENDIAN__ */\n-  return val;\n-#endif\n-#else\n-// provide a safe slower default, with shifts and masking\n-#ifndef WORDS_BIGENDIAN\n-  return val;\n-#else\n-  return (val >> 8) | (val << 8);\n-#endif\n-#endif\n-}\n-\n-/* Convert VAL to little endian form, if necessary.  */\n-\n-static uint32_t\n-lendian32 (uint32_t val)\n-{\n-#if GCC_VERSION >= 4006\n-#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__\n-  return val;\n-#elif __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__\n-  return __builtin_bswap32 (val);\n-#else  /* __ORDER_PDP_ENDIAN__ */\n-  return (val >> 16) | (val << 16);\n-#endif\n-#else\n-// provide a safe slower default, with shifts and masking\n-#ifndef WORDS_BIGENDIAN\n-  return val;\n-#else\n-  val = ((val & 0xff00ff00) >> 8) | ((val & 0xff00ff) << 8);\n-  return (val >> 16) | (val << 16);\n-#endif\n-#endif\n-}\n-\n-/* Convert VAL to little endian form, if necessary.  */\n-\n-static uint64_t\n-lendian64 (uint64_t val)\n-{\n-#if GCC_VERSION >= 4006\n-#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__\n-  return val;\n-#elif __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__\n-  return __builtin_bswap64 (val);\n-#else  /* __ORDER_PDP_ENDIAN__ */\n-  return (((val & 0xffffll) << 48)\n-\t  | ((val & 0xffff0000ll) << 16)\n-\t  | ((val & 0xffff00000000ll) >> 16)\n-\t  | ((val & 0xffff000000000000ll) >> 48));\n-#endif\n-#else\n-// provide a safe slower default, with shifts and masking\n-#ifndef WORDS_BIGENDIAN\n-  return val;\n-#else\n-  val = (((val & 0xff00ff00ff00ff00ll) >> 8)\n-\t | ((val & 0x00ff00ff00ff00ffll) << 8));\n-  val = ((( val & 0xffff0000ffff0000ll) >> 16)\n-\t | (( val & 0x0000ffff0000ffffll) << 16));\n-  return (val >> 32) | (val << 32);\n-#endif\n-#endif\n-}\n-\n-#define BRIG_ELF_SECTION_NAME \".brig\"\n-#define BRIG_LABEL_STRING \"hsa_brig\"\n-#define BRIG_SECTION_DATA_NAME    \"hsa_data\"\n-#define BRIG_SECTION_CODE_NAME    \"hsa_code\"\n-#define BRIG_SECTION_OPERAND_NAME \"hsa_operand\"\n-\n-#define BRIG_CHUNK_MAX_SIZE (64 * 1024)\n-\n-/* Required HSA section alignment.  */\n-\n-#define HSA_SECTION_ALIGNMENT 16\n-\n-/* Chunks of BRIG binary data.  */\n-\n-struct hsa_brig_data_chunk\n-{\n-  /* Size of the data already stored into a chunk.  */\n-  unsigned size;\n-\n-  /* Pointer to the data.  */\n-  char *data;\n-};\n-\n-/* Structure representing a BRIG section, holding and writing its data.  */\n-\n-struct hsa_brig_section\n-{\n-  /* Section name that will be output to the BRIG.  */\n-  const char *section_name;\n-  /* Size in bytes of all data stored in the section.  */\n-  unsigned total_size;\n-  /* The size of the header of the section including padding.  */\n-  unsigned header_byte_count;\n-  /* The size of the header of the section without any padding.  */\n-  unsigned header_byte_delta;\n-\n-  void init (const char *name);\n-  void release ();\n-  void output ();\n-  unsigned add (const void *data, unsigned len, void **output = NULL);\n-  void round_size_up (int factor);\n-  void *get_ptr_by_offset (unsigned int offset);\n-\n-private:\n-  void allocate_new_chunk ();\n-\n-  /* Buffers of binary data, each containing BRIG_CHUNK_MAX_SIZE bytes.  */\n-  vec <struct hsa_brig_data_chunk> chunks;\n-\n-  /* More convenient access to the last chunk from the vector above.  */\n-  struct hsa_brig_data_chunk *cur_chunk;\n-};\n-\n-static struct hsa_brig_section brig_data, brig_code, brig_operand;\n-static uint32_t brig_insn_count;\n-static bool brig_initialized = false;\n-\n-/* Mapping between emitted HSA functions and their offset in code segment.  */\n-static hash_map<tree, BrigCodeOffset32_t> *function_offsets;\n-\n-/* Hash map of emitted function declarations.  */\n-static hash_map <tree, BrigDirectiveExecutable *> *emitted_declarations;\n-\n-/* Hash table of emitted internal function declaration offsets.  */\n-hash_table <hsa_internal_fn_hasher> *hsa_emitted_internal_decls;\n-\n-/* List of sbr instructions.  */\n-static vec <hsa_insn_sbr *> *switch_instructions;\n-\n-class function_linkage_pair\n-{\n-public:\n-  function_linkage_pair (tree decl, unsigned int off)\n-    : function_decl (decl), offset (off) {}\n-\n-  /* Declaration of called function.  */\n-  tree function_decl;\n-\n-  /* Offset in operand section.  */\n-  unsigned int offset;\n-};\n-\n-/* Vector of function calls where we need to resolve function offsets.  */\n-static auto_vec <function_linkage_pair> function_call_linkage;\n-\n-/* Add a new chunk, allocate data for it and initialize it.  */\n-\n-void\n-hsa_brig_section::allocate_new_chunk ()\n-{\n-  struct hsa_brig_data_chunk new_chunk;\n-\n-  new_chunk.data = XCNEWVEC (char, BRIG_CHUNK_MAX_SIZE);\n-  new_chunk.size = 0;\n-  cur_chunk = chunks.safe_push (new_chunk);\n-}\n-\n-/* Initialize the brig section.  */\n-\n-void\n-hsa_brig_section::init (const char *name)\n-{\n-  section_name = name;\n-  /* While the following computation is basically wrong, because the intent\n-     certainly wasn't to have the first character of name and padding, which\n-     are a part of sizeof (BrigSectionHeader), included in the first addend,\n-     this is what the disassembler expects.  */\n-  total_size = sizeof (BrigSectionHeader) + strlen (section_name);\n-  chunks.create (1);\n-  allocate_new_chunk ();\n-  header_byte_delta = total_size;\n-  round_size_up (4);\n-  header_byte_count = total_size;\n-}\n-\n-/* Free all data in the section.  */\n-\n-void\n-hsa_brig_section::release ()\n-{\n-  for (unsigned i = 0; i < chunks.length (); i++)\n-    free (chunks[i].data);\n-  chunks.release ();\n-  cur_chunk = NULL;\n-}\n-\n-/* Write the section to the output file to a section with the name given at\n-   initialization.  Switches the output section and does not restore it.  */\n-\n-void\n-hsa_brig_section::output ()\n-{\n-  struct BrigSectionHeader section_header;\n-  char padding[8];\n-\n-  section_header.byteCount = lendian64 (total_size);\n-  section_header.headerByteCount = lendian32 (header_byte_count);\n-  section_header.nameLength = lendian32 (strlen (section_name));\n-  assemble_string ((const char *) &section_header, 16);\n-  assemble_string (section_name, (section_header.nameLength));\n-  memset (&padding, 0, sizeof (padding));\n-  /* This is also a consequence of the wrong header size computation described\n-     in a comment in hsa_brig_section::init.  */\n-  assemble_string (padding, 8);\n-  for (unsigned i = 0; i < chunks.length (); i++)\n-    assemble_string (chunks[i].data, chunks[i].size);\n-}\n-\n-/* Add to the stream LEN bytes of opaque binary DATA.  Return the offset at\n-   which it was stored.  If OUTPUT is not NULL, store into it the pointer to\n-   the place where DATA was actually stored.  */\n-\n-unsigned\n-hsa_brig_section::add (const void *data, unsigned len, void **output)\n-{\n-  unsigned offset = total_size;\n-\n-  gcc_assert (len <= BRIG_CHUNK_MAX_SIZE);\n-  if (cur_chunk->size > (BRIG_CHUNK_MAX_SIZE - len))\n-    allocate_new_chunk ();\n-\n-  char *dst = cur_chunk->data + cur_chunk->size;\n-  memcpy (dst, data, len);\n-  if (output)\n-    *output = dst;\n-  cur_chunk->size += len;\n-  total_size += len;\n-\n-  return offset;\n-}\n-\n-/* Add padding to section so that its size is divisible by FACTOR.  */\n-\n-void\n-hsa_brig_section::round_size_up (int factor)\n-{\n-  unsigned padding, res = total_size % factor;\n-\n-  if (res == 0)\n-    return;\n-\n-  padding = factor - res;\n-  total_size += padding;\n-  if (cur_chunk->size > (BRIG_CHUNK_MAX_SIZE - padding))\n-    {\n-      padding -= BRIG_CHUNK_MAX_SIZE - cur_chunk->size;\n-      cur_chunk->size = BRIG_CHUNK_MAX_SIZE;\n-      allocate_new_chunk ();\n-    }\n-\n-  cur_chunk->size += padding;\n-}\n-\n-/* Return pointer to data by global OFFSET in the section.  */\n-\n-void *\n-hsa_brig_section::get_ptr_by_offset (unsigned int offset)\n-{\n-  gcc_assert (offset < total_size);\n-  offset -= header_byte_delta;\n-\n-  unsigned i;\n-  for (i = 0; offset >= chunks[i].size; i++)\n-    offset -= chunks[i].size;\n-\n-  return chunks[i].data + offset;\n-}\n-\n-/* BRIG string data hashing.  */\n-\n-struct brig_string_slot\n-{\n-  const char *s;\n-  char prefix;\n-  int len;\n-  uint32_t offset;\n-};\n-\n-/* Hash table helpers.  */\n-\n-struct brig_string_slot_hasher : pointer_hash <brig_string_slot>\n-{\n-  static inline hashval_t hash (const value_type);\n-  static inline bool equal (const value_type, const compare_type);\n-  static inline void remove (value_type);\n-};\n-\n-/* Returns a hash code for DS.  Adapted from libiberty's htab_hash_string\n-   to support strings that may not end in '\\0'.  */\n-\n-inline hashval_t\n-brig_string_slot_hasher::hash (const value_type ds)\n-{\n-  hashval_t r = ds->len;\n-  int i;\n-\n-  for (i = 0; i < ds->len; i++)\n-     r = r * 67 + (unsigned) ds->s[i] - 113;\n-  r = r * 67 + (unsigned) ds->prefix - 113;\n-  return r;\n-}\n-\n-/* Returns nonzero if DS1 and DS2 are equal.  */\n-\n-inline bool\n-brig_string_slot_hasher::equal (const value_type ds1, const compare_type ds2)\n-{\n-  if (ds1->len == ds2->len)\n-    return ds1->prefix == ds2->prefix\n-      && memcmp (ds1->s, ds2->s, ds1->len) == 0;\n-\n-  return 0;\n-}\n-\n-/* Deallocate memory for DS upon its removal.  */\n-\n-inline void\n-brig_string_slot_hasher::remove (value_type ds)\n-{\n-  free (const_cast<char *> (ds->s));\n-  free (ds);\n-}\n-\n-/* Hash for strings we output in order not to duplicate them needlessly.  */\n-\n-static hash_table<brig_string_slot_hasher> *brig_string_htab;\n-\n-/* Emit a null terminated string STR to the data section and return its\n-   offset in it.  If PREFIX is non-zero, output it just before STR too.\n-   Sanitize the string if SANITIZE option is set to true.  */\n-\n-static unsigned\n-brig_emit_string (const char *str, char prefix = 0, bool sanitize = true)\n-{\n-  unsigned slen = strlen (str);\n-  unsigned offset, len = slen + (prefix ? 1 : 0);\n-  uint32_t hdr_len = lendian32 (len);\n-  brig_string_slot s_slot;\n-  brig_string_slot **slot;\n-  char *str2;\n-\n-  str2 = xstrdup (str);\n-\n-  if (sanitize)\n-    hsa_sanitize_name (str2);\n-  s_slot.s = str2;\n-  s_slot.len = slen;\n-  s_slot.prefix = prefix;\n-  s_slot.offset = 0;\n-\n-  slot = brig_string_htab->find_slot (&s_slot, INSERT);\n-  if (*slot == NULL)\n-    {\n-      brig_string_slot *new_slot = XCNEW (brig_string_slot);\n-\n-      /* In theory we should fill in BrigData but that would mean copying\n-\t the string to a buffer for no reason, so we just emulate it.  */\n-      offset = brig_data.add (&hdr_len, sizeof (hdr_len));\n-      if (prefix)\n-\tbrig_data.add (&prefix, 1);\n-\n-      brig_data.add (str2, slen);\n-      brig_data.round_size_up (4);\n-\n-      /* TODO: could use the string we just copied into\n-\t brig_string->cur_chunk */\n-      new_slot->s = str2;\n-      new_slot->len = slen;\n-      new_slot->prefix = prefix;\n-      new_slot->offset = offset;\n-      *slot = new_slot;\n-    }\n-  else\n-    {\n-      offset = (*slot)->offset;\n-      free (str2);\n-    }\n-\n-  return offset;\n-}\n-\n-/* Linked list of queued operands.  */\n-\n-static struct operand_queue\n-{\n-  /* First from the chain of queued operands.  */\n-  hsa_op_base *first_op, *last_op;\n-\n-  /* The offset at which the next operand will be enqueued.  */\n-  unsigned projected_size;\n-\n-} op_queue;\n-\n-/* Unless already initialized, initialize infrastructure to produce BRIG.  */\n-\n-static void\n-brig_init (void)\n-{\n-  brig_insn_count = 0;\n-\n-  if (brig_initialized)\n-    return;\n-\n-  brig_string_htab = new hash_table<brig_string_slot_hasher> (37);\n-  brig_data.init (BRIG_SECTION_DATA_NAME);\n-  brig_code.init (BRIG_SECTION_CODE_NAME);\n-  brig_operand.init (BRIG_SECTION_OPERAND_NAME);\n-  brig_initialized = true;\n-\n-  struct BrigDirectiveModule moddir;\n-  memset (&moddir, 0, sizeof (moddir));\n-  moddir.base.byteCount = lendian16 (sizeof (moddir));\n-\n-  char *modname;\n-  if (main_input_filename && *main_input_filename != '\\0')\n-    {\n-      const char *part = strrchr (main_input_filename, '/');\n-      if (!part)\n-\tpart = main_input_filename;\n-      else\n-\tpart++;\n-      modname = concat (\"&__hsa_module_\", part, NULL);\n-      char *extension = strchr (modname, '.');\n-      if (extension)\n-\t*extension = '\\0';\n-\n-      /* As in LTO mode, we have to emit a different module names.  */\n-      if (flag_ltrans)\n-\t{\n-\t  part = strrchr (asm_file_name, '/');\n-\t  if (!part)\n-\t    part = asm_file_name;\n-\t  else\n-\t    part++;\n-\t  char *modname2;\n-\t  modname2 = xasprintf (\"%s_%s\", modname, part);\n-\t  free (modname);\n-\t  modname = modname2;\n-\t}\n-\n-      hsa_sanitize_name (modname);\n-      moddir.name = brig_emit_string (modname);\n-      free (modname);\n-    }\n-  else\n-    moddir.name = brig_emit_string (\"__hsa_module_unnamed\", '&');\n-  moddir.base.kind = lendian16 (BRIG_KIND_DIRECTIVE_MODULE);\n-  moddir.hsailMajor = lendian32 (BRIG_VERSION_HSAIL_MAJOR);\n-  moddir.hsailMinor = lendian32 (BRIG_VERSION_HSAIL_MINOR);\n-  moddir.profile = hsa_full_profile_p () ? BRIG_PROFILE_FULL: BRIG_PROFILE_BASE;\n-  if (hsa_machine_large_p ())\n-    moddir.machineModel = BRIG_MACHINE_LARGE;\n-  else\n-    moddir.machineModel = BRIG_MACHINE_SMALL;\n-  moddir.defaultFloatRound = BRIG_ROUND_FLOAT_DEFAULT;\n-  brig_code.add (&moddir, sizeof (moddir));\n-}\n-\n-/* Free all BRIG data.  */\n-\n-static void\n-brig_release_data (void)\n-{\n-  delete brig_string_htab;\n-  brig_data.release ();\n-  brig_code.release ();\n-  brig_operand.release ();\n-\n-  brig_initialized = 0;\n-}\n-\n-/* Enqueue operation OP.  Return the offset at which it will be stored.  */\n-\n-static unsigned int\n-enqueue_op (hsa_op_base *op)\n-{\n-  unsigned ret;\n-\n-  if (op->m_brig_op_offset)\n-    return op->m_brig_op_offset;\n-\n-  ret = op_queue.projected_size;\n-  op->m_brig_op_offset = op_queue.projected_size;\n-\n-  if (!op_queue.first_op)\n-    op_queue.first_op = op;\n-  else\n-    op_queue.last_op->m_next = op;\n-  op_queue.last_op = op;\n-\n-  if (is_a <hsa_op_immed *> (op))\n-    op_queue.projected_size += sizeof (struct BrigOperandConstantBytes);\n-  else if (is_a <hsa_op_reg *> (op))\n-    op_queue.projected_size += sizeof (struct BrigOperandRegister);\n-  else if (is_a <hsa_op_address *> (op))\n-    op_queue.projected_size += sizeof (struct BrigOperandAddress);\n-  else if (is_a <hsa_op_code_ref *> (op))\n-    op_queue.projected_size += sizeof (struct BrigOperandCodeRef);\n-  else if (is_a <hsa_op_code_list *> (op))\n-    op_queue.projected_size += sizeof (struct BrigOperandCodeList);\n-  else if (is_a <hsa_op_operand_list *> (op))\n-    op_queue.projected_size += sizeof (struct BrigOperandOperandList);\n-  else\n-    gcc_unreachable ();\n-  return ret;\n-}\n-\n-static void emit_immediate_operand (hsa_op_immed *imm);\n-\n-/* Emit directive describing a symbol if it has not been emitted already.\n-   Return the offset of the directive.  */\n-\n-static unsigned\n-emit_directive_variable (class hsa_symbol *symbol)\n-{\n-  struct BrigDirectiveVariable dirvar;\n-  unsigned name_offset;\n-  static unsigned res_name_offset;\n-\n-  if (symbol->m_directive_offset)\n-    return symbol->m_directive_offset;\n-\n-  memset (&dirvar, 0, sizeof (dirvar));\n-  dirvar.base.byteCount = lendian16 (sizeof (dirvar));\n-  dirvar.base.kind = lendian16 (BRIG_KIND_DIRECTIVE_VARIABLE);\n-  dirvar.allocation = symbol->m_allocation;\n-\n-  char prefix = symbol->m_global_scope_p ? '&' : '%';\n-\n-  if (symbol->m_decl && TREE_CODE (symbol->m_decl) == RESULT_DECL)\n-    {\n-      if (res_name_offset == 0)\n-\tres_name_offset = brig_emit_string (symbol->m_name, '%');\n-      name_offset = res_name_offset;\n-    }\n-  else if (symbol->m_name)\n-    name_offset = brig_emit_string (symbol->m_name, prefix);\n-  else\n-    {\n-      char buf[64];\n-      snprintf (buf, 64, \"__%s_%i\", hsa_seg_name (symbol->m_segment),\n-\t\tsymbol->m_name_number);\n-      name_offset = brig_emit_string (buf, prefix);\n-    }\n-\n-  dirvar.name = lendian32 (name_offset);\n-\n-  if (symbol->m_decl && TREE_CODE (symbol->m_decl) == CONST_DECL)\n-    {\n-      hsa_op_immed *tmp = new hsa_op_immed (DECL_INITIAL (symbol->m_decl));\n-      dirvar.init = lendian32 (enqueue_op (tmp));\n-    }\n-  else\n-    dirvar.init = 0;\n-  dirvar.type = lendian16 (symbol->m_type);\n-  dirvar.segment = symbol->m_segment;\n-  dirvar.align = symbol->m_align;\n-  dirvar.linkage = symbol->m_linkage;\n-  dirvar.dim.lo = symbol->m_dim;\n-  dirvar.dim.hi = symbol->m_dim >> 32;\n-\n-  /* Global variables are just declared and linked via HSA runtime.  */\n-  if (symbol->m_linkage != BRIG_ALLOCATION_PROGRAM)\n-    dirvar.modifier |= BRIG_VARIABLE_DEFINITION;\n-  dirvar.reserved = 0;\n-\n-  if (symbol->m_cst_value)\n-    {\n-      dirvar.modifier |= BRIG_VARIABLE_CONST;\n-      dirvar.init = lendian32 (enqueue_op (symbol->m_cst_value));\n-    }\n-\n-  symbol->m_directive_offset = brig_code.add (&dirvar, sizeof (dirvar));\n-  return symbol->m_directive_offset;\n-}\n-\n-/* Emit directives describing either a function declaration or definition F and\n-   return the produced BrigDirectiveExecutable structure.  The function does\n-   not take into account any instructions when calculating nextModuleEntry\n-   field of the produced BrigDirectiveExecutable structure so when emitting\n-   actual definitions, this field needs to be updated after all of the function\n-   is actually added to the code section.  */\n-\n-static BrigDirectiveExecutable *\n-emit_function_directives (hsa_function_representation *f, bool is_declaration)\n-{\n-  struct BrigDirectiveExecutable fndir;\n-  unsigned name_offset, inarg_off, scoped_off, next_toplev_off;\n-  int count = 0;\n-  void *ptr_to_fndir;\n-  hsa_symbol *sym;\n-\n-  if (!f->m_declaration_p)\n-    for (int i = 0; f->m_global_symbols.iterate (i, &sym); i++)\n-      {\n-\tgcc_assert (!sym->m_emitted_to_brig);\n-\tsym->m_emitted_to_brig = true;\n-\temit_directive_variable (sym);\n-\tbrig_insn_count++;\n-      }\n-\n-  name_offset = brig_emit_string (f->m_name, '&');\n-  inarg_off = brig_code.total_size + sizeof (fndir)\n-    + (f->m_output_arg ? sizeof (struct BrigDirectiveVariable) : 0);\n-  scoped_off = inarg_off\n-    + f->m_input_args.length () * sizeof (struct BrigDirectiveVariable);\n-\n-  if (!f->m_declaration_p)\n-    {\n-      count += f->m_spill_symbols.length ();\n-      count += f->m_private_variables.length ();\n-    }\n-\n-  next_toplev_off = scoped_off + count * sizeof (struct BrigDirectiveVariable);\n-\n-  memset (&fndir, 0, sizeof (fndir));\n-  fndir.base.byteCount = lendian16 (sizeof (fndir));\n-  fndir.base.kind = lendian16 (f->m_kern_p ? BRIG_KIND_DIRECTIVE_KERNEL\n-\t\t\t       : BRIG_KIND_DIRECTIVE_FUNCTION);\n-  fndir.name = lendian32 (name_offset);\n-  fndir.inArgCount = lendian16 (f->m_input_args.length ());\n-  fndir.outArgCount = lendian16 (f->m_output_arg ? 1 : 0);\n-  fndir.firstInArg = lendian32 (inarg_off);\n-  fndir.firstCodeBlockEntry = lendian32 (scoped_off);\n-  fndir.nextModuleEntry = lendian32 (next_toplev_off);\n-  fndir.linkage = f->get_linkage ();\n-  if (!f->m_declaration_p)\n-    fndir.modifier |= BRIG_EXECUTABLE_DEFINITION;\n-  memset (&fndir.reserved, 0, sizeof (fndir.reserved));\n-\n-  /* Once we put a definition of function_offsets, we should not overwrite\n-     it with a declaration of the function.  */\n-  if (f->m_internal_fn == NULL)\n-    {\n-      if (!function_offsets->get (f->m_decl) || !is_declaration)\n-\tfunction_offsets->put (f->m_decl, brig_code.total_size);\n-    }\n-  else\n-    {\n-      /* Internal function.  */\n-      hsa_internal_fn **slot\n-\t= hsa_emitted_internal_decls->find_slot (f->m_internal_fn, INSERT);\n-      hsa_internal_fn *int_fn = new hsa_internal_fn (f->m_internal_fn);\n-      int_fn->m_offset = brig_code.total_size;\n-      *slot = int_fn;\n-    }\n-\n-  brig_code.add (&fndir, sizeof (fndir), &ptr_to_fndir);\n-\n-  if (f->m_output_arg)\n-    emit_directive_variable (f->m_output_arg);\n-  for (unsigned i = 0; i < f->m_input_args.length (); i++)\n-    emit_directive_variable (f->m_input_args[i]);\n-\n-  if (!f->m_declaration_p)\n-    {\n-      for (int i = 0; f->m_spill_symbols.iterate (i, &sym); i++)\n-\t{\n-\t  emit_directive_variable (sym);\n-\t  brig_insn_count++;\n-\t}\n-      for (unsigned i = 0; i < f->m_private_variables.length (); i++)\n-\t{\n-\t  emit_directive_variable (f->m_private_variables[i]);\n-\t  brig_insn_count++;\n-\t}\n-    }\n-\n-  return (BrigDirectiveExecutable *) ptr_to_fndir;\n-}\n-\n-/* Emit a label directive for the given HBB.  We assume it is about to start on\n-   the current offset in the code section.  */\n-\n-static void\n-emit_bb_label_directive (hsa_bb *hbb)\n-{\n-  struct BrigDirectiveLabel lbldir;\n-\n-  lbldir.base.byteCount = lendian16 (sizeof (lbldir));\n-  lbldir.base.kind = lendian16 (BRIG_KIND_DIRECTIVE_LABEL);\n-  char buf[32];\n-  snprintf (buf, 32, \"BB_%u_%i\", DECL_UID (current_function_decl),\n-\t    hbb->m_index);\n-  lbldir.name = lendian32 (brig_emit_string (buf, '@'));\n-\n-  hbb->m_label_ref.m_directive_offset = brig_code.add (&lbldir,\n-\t\t\t\t\t\t       sizeof (lbldir));\n-  brig_insn_count++;\n-}\n-\n-/* Map a normal HSAIL type to the type of the equivalent BRIG operand\n-   holding such, for constants and registers.  */\n-\n-static BrigType16_t\n-regtype_for_type (BrigType16_t t)\n-{\n-  switch (t)\n-    {\n-    case BRIG_TYPE_B1:\n-      return BRIG_TYPE_B1;\n-\n-    case BRIG_TYPE_U8:\n-    case BRIG_TYPE_U16:\n-    case BRIG_TYPE_U32:\n-    case BRIG_TYPE_S8:\n-    case BRIG_TYPE_S16:\n-    case BRIG_TYPE_S32:\n-    case BRIG_TYPE_B8:\n-    case BRIG_TYPE_B16:\n-    case BRIG_TYPE_B32:\n-    case BRIG_TYPE_F16:\n-    case BRIG_TYPE_F32:\n-    case BRIG_TYPE_U8X4:\n-    case BRIG_TYPE_U16X2:\n-    case BRIG_TYPE_S8X4:\n-    case BRIG_TYPE_S16X2:\n-    case BRIG_TYPE_F16X2:\n-      return BRIG_TYPE_B32;\n-\n-    case BRIG_TYPE_U64:\n-    case BRIG_TYPE_S64:\n-    case BRIG_TYPE_F64:\n-    case BRIG_TYPE_B64:\n-    case BRIG_TYPE_U8X8:\n-    case BRIG_TYPE_U16X4:\n-    case BRIG_TYPE_U32X2:\n-    case BRIG_TYPE_S8X8:\n-    case BRIG_TYPE_S16X4:\n-    case BRIG_TYPE_S32X2:\n-    case BRIG_TYPE_F16X4:\n-    case BRIG_TYPE_F32X2:\n-      return BRIG_TYPE_B64;\n-\n-    case BRIG_TYPE_B128:\n-    case BRIG_TYPE_U8X16:\n-    case BRIG_TYPE_U16X8:\n-    case BRIG_TYPE_U32X4:\n-    case BRIG_TYPE_U64X2:\n-    case BRIG_TYPE_S8X16:\n-    case BRIG_TYPE_S16X8:\n-    case BRIG_TYPE_S32X4:\n-    case BRIG_TYPE_S64X2:\n-    case BRIG_TYPE_F16X8:\n-    case BRIG_TYPE_F32X4:\n-    case BRIG_TYPE_F64X2:\n-      return BRIG_TYPE_B128;\n-\n-    default:\n-      gcc_unreachable ();\n-    }\n-}\n-\n-/* Return the length of the BRIG type TYPE that is going to be streamed out as\n-   an immediate constant (so it must not be B1).  */\n-\n-unsigned\n-hsa_get_imm_brig_type_len (BrigType16_t type)\n-{\n-  BrigType16_t base_type = type & BRIG_TYPE_BASE_MASK;\n-  BrigType16_t pack_type = type & BRIG_TYPE_PACK_MASK;\n-\n-  switch (pack_type)\n-    {\n-    case BRIG_TYPE_PACK_NONE:\n-      break;\n-    case BRIG_TYPE_PACK_32:\n-      return 4;\n-    case BRIG_TYPE_PACK_64:\n-      return 8;\n-    case BRIG_TYPE_PACK_128:\n-      return 16;\n-    default:\n-      gcc_unreachable ();\n-    }\n-\n-  switch (base_type)\n-    {\n-    case BRIG_TYPE_U8:\n-    case BRIG_TYPE_S8:\n-    case BRIG_TYPE_B8:\n-      return 1;\n-    case BRIG_TYPE_U16:\n-    case BRIG_TYPE_S16:\n-    case BRIG_TYPE_F16:\n-    case BRIG_TYPE_B16:\n-      return 2;\n-    case BRIG_TYPE_U32:\n-    case BRIG_TYPE_S32:\n-    case BRIG_TYPE_F32:\n-    case BRIG_TYPE_B32:\n-      return 4;\n-    case BRIG_TYPE_U64:\n-    case BRIG_TYPE_S64:\n-    case BRIG_TYPE_F64:\n-    case BRIG_TYPE_B64:\n-      return 8;\n-    case BRIG_TYPE_B128:\n-      return 16;\n-    default:\n-      gcc_unreachable ();\n-    }\n-}\n-\n-/* Emit one scalar VALUE to the buffer DATA intended for BRIG emission.\n-   If NEED_LEN is not equal to zero, shrink or extend the value\n-   to NEED_LEN bytes.  Return how many bytes were written.  */\n-\n-static int\n-emit_immediate_scalar_to_buffer (tree value, char *data, unsigned need_len)\n-{\n-  union hsa_bytes bytes;\n-\n-  memset (&bytes, 0, sizeof (bytes));\n-  tree type = TREE_TYPE (value);\n-  gcc_checking_assert (TREE_CODE (type) != VECTOR_TYPE);\n-\n-  unsigned data_len = tree_to_uhwi (TYPE_SIZE (type)) / BITS_PER_UNIT;\n-  if (INTEGRAL_TYPE_P (type)\n-      || (POINTER_TYPE_P (type) && TREE_CODE (value) == INTEGER_CST))\n-    switch (data_len)\n-      {\n-      case 1:\n-\tbytes.b8 = (uint8_t) TREE_INT_CST_LOW (value);\n-\tbreak;\n-      case 2:\n-\tbytes.b16 = (uint16_t) TREE_INT_CST_LOW (value);\n-\tbreak;\n-      case 4:\n-\tbytes.b32 = (uint32_t) TREE_INT_CST_LOW (value);\n-\tbreak;\n-      case 8:\n-\tbytes.b64 = (uint64_t) TREE_INT_CST_LOW (value);\n-\tbreak;\n-      default:\n-\tgcc_unreachable ();\n-      }\n-  else if (SCALAR_FLOAT_TYPE_P (type))\n-    {\n-      if (data_len == 2)\n-\t{\n-\t  sorry (\"Support for HSA does not implement immediate 16 bit FPU \"\n-\t\t \"operands\");\n-\t  return 2;\n-\t}\n-      unsigned int_len = GET_MODE_SIZE (SCALAR_FLOAT_TYPE_MODE (type));\n-      /* There are always 32 bits in each long, no matter the size of\n-\t the hosts long.  */\n-      long tmp[6];\n-\n-      real_to_target (tmp, TREE_REAL_CST_PTR (value), TYPE_MODE (type));\n-\n-      if (int_len == 4)\n-\tbytes.b32 = (uint32_t) tmp[0];\n-      else\n-\t{\n-\t  bytes.b64 = (uint64_t)(uint32_t) tmp[1];\n-\t  bytes.b64 <<= 32;\n-\t  bytes.b64 |= (uint32_t) tmp[0];\n-\t}\n-    }\n-  else\n-    gcc_unreachable ();\n-\n-  int len;\n-  if (need_len == 0)\n-    len = data_len;\n-  else\n-    len = need_len;\n-\n-  memcpy (data, &bytes, len);\n-  return len;\n-}\n-\n-char *\n-hsa_op_immed::emit_to_buffer (unsigned *brig_repr_size)\n-{\n-  char *brig_repr;\n-  *brig_repr_size = hsa_get_imm_brig_type_len (m_type);\n-\n-  if (m_tree_value != NULL_TREE)\n-    {\n-      /* Update brig_repr_size for special tree values.  */\n-      if (TREE_CODE (m_tree_value) == STRING_CST)\n-\t*brig_repr_size = TREE_STRING_LENGTH (m_tree_value);\n-      else if (TREE_CODE (m_tree_value) == CONSTRUCTOR)\n-\t*brig_repr_size\n-\t  = tree_to_uhwi (TYPE_SIZE_UNIT (TREE_TYPE (m_tree_value)));\n-\n-      unsigned total_len = *brig_repr_size;\n-\n-      /* As we can have a constructor with fewer elements, fill the memory\n-\t with zeros.  */\n-      brig_repr = XCNEWVEC (char, total_len);\n-      char *p = brig_repr;\n-\n-      if (TREE_CODE (m_tree_value) == VECTOR_CST)\n-\t{\n-\t  /* Variable-length vectors aren't supported.  */\n-\t  int i, num = VECTOR_CST_NELTS (m_tree_value).to_constant ();\n-\t  for (i = 0; i < num; i++)\n-\t    {\n-\t      tree v = VECTOR_CST_ELT (m_tree_value, i);\n-\t      unsigned actual = emit_immediate_scalar_to_buffer (v, p, 0);\n-\t      total_len -= actual;\n-\t      p += actual;\n-\t    }\n-\t  /* Vectors should have the exact size.  */\n-\t  gcc_assert (total_len == 0);\n-\t}\n-      else if (TREE_CODE (m_tree_value) == STRING_CST)\n-\tmemcpy (brig_repr, TREE_STRING_POINTER (m_tree_value),\n-\t\tTREE_STRING_LENGTH (m_tree_value));\n-      else if (TREE_CODE (m_tree_value) == COMPLEX_CST)\n-\t{\n-\t  gcc_assert (total_len % 2 == 0);\n-\t  unsigned actual;\n-\t  actual\n-\t    = emit_immediate_scalar_to_buffer (TREE_REALPART (m_tree_value), p,\n-\t\t\t\t\t       total_len / 2);\n-\n-\t  gcc_assert (actual == total_len / 2);\n-\t  p += actual;\n-\n-\t  actual\n-\t    = emit_immediate_scalar_to_buffer (TREE_IMAGPART (m_tree_value), p,\n-\t\t\t\t\t       total_len / 2);\n-\t  gcc_assert (actual == total_len / 2);\n-\t}\n-      else if (TREE_CODE (m_tree_value) == CONSTRUCTOR)\n-\t{\n-\t  unsigned len = CONSTRUCTOR_NELTS (m_tree_value);\n-\t  for (unsigned i = 0; i < len; i++)\n-\t    {\n-\t      tree v = CONSTRUCTOR_ELT (m_tree_value, i)->value;\n-\t      unsigned actual = emit_immediate_scalar_to_buffer (v, p, 0);\n-\t      total_len -= actual;\n-\t      p += actual;\n-\t    }\n-\t}\n-      else\n-\temit_immediate_scalar_to_buffer (m_tree_value, p, total_len);\n-    }\n-  else\n-    {\n-      hsa_bytes bytes;\n-\n-      switch (*brig_repr_size)\n-\t{\n-\tcase 1:\n-\t  bytes.b8 = (uint8_t) m_int_value;\n-\t  break;\n-\tcase 2:\n-\t  bytes.b16 = (uint16_t) m_int_value;\n-\t  break;\n-\tcase 4:\n-\t  bytes.b32 = (uint32_t) m_int_value;\n-\t  break;\n-\tcase 8:\n-\t  bytes.b64 = (uint64_t) m_int_value;\n-\t  break;\n-\tdefault:\n-\t  gcc_unreachable ();\n-\t}\n-\n-      brig_repr = XNEWVEC (char, *brig_repr_size);\n-      memcpy (brig_repr, &bytes, *brig_repr_size);\n-    }\n-\n-  return brig_repr;\n-}\n-\n-/* Emit an immediate BRIG operand IMM.  The BRIG type of the immediate might\n-   have been massaged to comply with various HSA/BRIG type requirements, so the\n-   only important aspect of that is the length (because HSAIL might expect\n-   smaller constants or become bit-data).  The data should be represented\n-   according to what is in the tree representation.  */\n-\n-static void\n-emit_immediate_operand (hsa_op_immed *imm)\n-{\n-  unsigned brig_repr_size;\n-  char *brig_repr = imm->emit_to_buffer (&brig_repr_size);\n-  struct BrigOperandConstantBytes out;\n-\n-  memset (&out, 0, sizeof (out));\n-  out.base.byteCount = lendian16 (sizeof (out));\n-  out.base.kind = lendian16 (BRIG_KIND_OPERAND_CONSTANT_BYTES);\n-  uint32_t byteCount = lendian32 (brig_repr_size);\n-  out.type = lendian16 (imm->m_type);\n-  out.bytes = lendian32 (brig_data.add (&byteCount, sizeof (byteCount)));\n-  brig_operand.add (&out, sizeof (out));\n-  brig_data.add (brig_repr, brig_repr_size);\n-  brig_data.round_size_up (4);\n-\n-  free (brig_repr);\n-}\n-\n-/* Emit a register BRIG operand REG.  */\n-\n-static void\n-emit_register_operand (hsa_op_reg *reg)\n-{\n-  struct BrigOperandRegister out;\n-\n-  out.base.byteCount = lendian16 (sizeof (out));\n-  out.base.kind = lendian16 (BRIG_KIND_OPERAND_REGISTER);\n-  out.regNum = lendian32 (reg->m_hard_num);\n-\n-  switch (regtype_for_type (reg->m_type))\n-    {\n-    case BRIG_TYPE_B32:\n-      out.regKind = BRIG_REGISTER_KIND_SINGLE;\n-      break;\n-    case BRIG_TYPE_B64:\n-      out.regKind = BRIG_REGISTER_KIND_DOUBLE;\n-      break;\n-    case BRIG_TYPE_B128:\n-      out.regKind = BRIG_REGISTER_KIND_QUAD;\n-      break;\n-    case BRIG_TYPE_B1:\n-      out.regKind = BRIG_REGISTER_KIND_CONTROL;\n-      break;\n-    default:\n-      gcc_unreachable ();\n-    }\n-\n-  brig_operand.add (&out, sizeof (out));\n-}\n-\n-/* Emit an address BRIG operand ADDR.  */\n-\n-static void\n-emit_address_operand (hsa_op_address *addr)\n-{\n-  struct BrigOperandAddress out;\n-\n-  out.base.byteCount = lendian16 (sizeof (out));\n-  out.base.kind = lendian16 (BRIG_KIND_OPERAND_ADDRESS);\n-  out.symbol = addr->m_symbol\n-    ? lendian32 (emit_directive_variable (addr->m_symbol)) : 0;\n-  out.reg = addr->m_reg ? lendian32 (enqueue_op (addr->m_reg)) : 0;\n-\n-  if (sizeof (addr->m_imm_offset) == 8)\n-    {\n-      out.offset.lo = lendian32 (addr->m_imm_offset);\n-      out.offset.hi = lendian32 (addr->m_imm_offset >> 32);\n-    }\n-  else\n-    {\n-      gcc_assert (sizeof (addr->m_imm_offset) == 4);\n-      out.offset.lo = lendian32 (addr->m_imm_offset);\n-      out.offset.hi = 0;\n-    }\n-\n-  brig_operand.add (&out, sizeof (out));\n-}\n-\n-/* Emit a code reference operand REF.  */\n-\n-static void\n-emit_code_ref_operand (hsa_op_code_ref *ref)\n-{\n-  struct BrigOperandCodeRef out;\n-\n-  out.base.byteCount = lendian16 (sizeof (out));\n-  out.base.kind = lendian16 (BRIG_KIND_OPERAND_CODE_REF);\n-  out.ref = lendian32 (ref->m_directive_offset);\n-  brig_operand.add (&out, sizeof (out));\n-}\n-\n-/* Emit a code list operand CODE_LIST.  */\n-\n-static void\n-emit_code_list_operand (hsa_op_code_list *code_list)\n-{\n-  struct BrigOperandCodeList out;\n-  unsigned args = code_list->m_offsets.length ();\n-\n-  for (unsigned i = 0; i < args; i++)\n-    gcc_assert (code_list->m_offsets[i]);\n-\n-  out.base.byteCount = lendian16 (sizeof (out));\n-  out.base.kind = lendian16 (BRIG_KIND_OPERAND_CODE_LIST);\n-\n-  uint32_t byteCount = lendian32 (4 * args);\n-\n-  out.elements = lendian32 (brig_data.add (&byteCount, sizeof (byteCount)));\n-  brig_data.add (code_list->m_offsets.address (), args * sizeof (uint32_t));\n-  brig_data.round_size_up (4);\n-  brig_operand.add (&out, sizeof (out));\n-}\n-\n-/* Emit an operand list operand OPERAND_LIST.  */\n-\n-static void\n-emit_operand_list_operand (hsa_op_operand_list *operand_list)\n-{\n-  struct BrigOperandOperandList out;\n-  unsigned args = operand_list->m_offsets.length ();\n-\n-  for (unsigned i = 0; i < args; i++)\n-    gcc_assert (operand_list->m_offsets[i]);\n-\n-  out.base.byteCount = lendian16 (sizeof (out));\n-  out.base.kind = lendian16 (BRIG_KIND_OPERAND_OPERAND_LIST);\n-\n-  uint32_t byteCount = lendian32 (4 * args);\n-\n-  out.elements = lendian32 (brig_data.add (&byteCount, sizeof (byteCount)));\n-  brig_data.add (operand_list->m_offsets.address (), args * sizeof (uint32_t));\n-  brig_data.round_size_up (4);\n-  brig_operand.add (&out, sizeof (out));\n-}\n-\n-/* Emit all operands queued for writing.  */\n-\n-static void\n-emit_queued_operands (void)\n-{\n-  for (hsa_op_base *op = op_queue.first_op; op; op = op->m_next)\n-    {\n-      gcc_assert (op->m_brig_op_offset == brig_operand.total_size);\n-      if (hsa_op_immed *imm = dyn_cast <hsa_op_immed *> (op))\n-\temit_immediate_operand (imm);\n-      else if (hsa_op_reg *reg = dyn_cast <hsa_op_reg *> (op))\n-\temit_register_operand (reg);\n-      else if (hsa_op_address *addr = dyn_cast <hsa_op_address *> (op))\n-\temit_address_operand (addr);\n-      else if (hsa_op_code_ref *ref = dyn_cast <hsa_op_code_ref *> (op))\n-\temit_code_ref_operand (ref);\n-      else if (hsa_op_code_list *code_list = dyn_cast <hsa_op_code_list *> (op))\n-\temit_code_list_operand (code_list);\n-      else if (hsa_op_operand_list *l = dyn_cast <hsa_op_operand_list *> (op))\n-\temit_operand_list_operand (l);\n-      else\n-\tgcc_unreachable ();\n-    }\n-}\n-\n-/* Emit directives describing the function that is used for\n-   a function declaration.  */\n-\n-static BrigDirectiveExecutable *\n-emit_function_declaration (tree decl)\n-{\n-  hsa_function_representation *f = hsa_generate_function_declaration (decl);\n-\n-  BrigDirectiveExecutable *e = emit_function_directives (f, true);\n-  emit_queued_operands ();\n-\n-  delete f;\n-\n-  return e;\n-}\n-\n-/* Emit directives describing the function that is used for\n-   an internal function declaration.  */\n-\n-static BrigDirectiveExecutable *\n-emit_internal_fn_decl (hsa_internal_fn *fn)\n-{\n-  hsa_function_representation *f = hsa_generate_internal_fn_decl (fn);\n-\n-  BrigDirectiveExecutable *e = emit_function_directives (f, true);\n-  emit_queued_operands ();\n-\n-  delete f;\n-\n-  return e;\n-}\n-\n-/* Enqueue all operands of INSN and return offset to BRIG data section\n-   to list of operand offsets.  */\n-\n-static unsigned\n-emit_insn_operands (hsa_insn_basic *insn)\n-{\n-  auto_vec<BrigOperandOffset32_t, HSA_BRIG_INT_STORAGE_OPERANDS>\n-    operand_offsets;\n-\n-  unsigned l = insn->operand_count ();\n-\n-  /* We have N operands so use 4 * N for the byte_count.  */\n-  uint32_t byte_count = lendian32 (4 * l);\n-  unsigned offset = brig_data.add (&byte_count, sizeof (byte_count));\n-  if (l > 0)\n-    {\n-      operand_offsets.safe_grow (l);\n-      for (unsigned i = 0; i < l; i++)\n-\toperand_offsets[i] = lendian32 (enqueue_op (insn->get_op (i)));\n-\n-      brig_data.add (operand_offsets.address (),\n-\t\t     l * sizeof (BrigOperandOffset32_t));\n-    }\n-  brig_data.round_size_up (4);\n-  return offset;\n-}\n-\n-/* Enqueue operand OP0, OP1, OP2 (if different from NULL) and return offset\n-   to BRIG data section to list of operand offsets.  */\n-\n-static unsigned\n-emit_operands (hsa_op_base *op0, hsa_op_base *op1 = NULL,\n-\t       hsa_op_base *op2 = NULL)\n-{\n-  auto_vec<BrigOperandOffset32_t, HSA_BRIG_INT_STORAGE_OPERANDS>\n-    operand_offsets;\n-\n-  gcc_checking_assert (op0 != NULL);\n-  operand_offsets.safe_push (enqueue_op (op0));\n-\n-  if (op1 != NULL)\n-    {\n-      operand_offsets.safe_push (enqueue_op (op1));\n-      if (op2 != NULL)\n-\toperand_offsets.safe_push (enqueue_op (op2));\n-    }\n-\n-  unsigned l = operand_offsets.length ();\n-\n-  /* We have N operands so use 4 * N for the byte_count.  */\n-  uint32_t byte_count = lendian32 (4 * l);\n-\n-  unsigned offset = brig_data.add (&byte_count, sizeof (byte_count));\n-  brig_data.add (operand_offsets.address (),\n-\t\t l * sizeof (BrigOperandOffset32_t));\n-\n-  brig_data.round_size_up (4);\n-\n-  return offset;\n-}\n-\n-/* Emit an HSA memory instruction and all necessary directives, schedule\n-   necessary operands for writing.  */\n-\n-static void\n-emit_memory_insn (hsa_insn_mem *mem)\n-{\n-  struct BrigInstMem repr;\n-  gcc_checking_assert (mem->operand_count () == 2);\n-\n-  hsa_op_address *addr = as_a <hsa_op_address *> (mem->get_op (1));\n-\n-  /* This is necessary because of the erroneous typedef of\n-     BrigMemoryModifier8_t which introduces padding which may then contain\n-     random stuff (which we do not want so that we can test things don't\n-     change).  */\n-  memset (&repr, 0, sizeof (repr));\n-  repr.base.base.byteCount = lendian16 (sizeof (repr));\n-  repr.base.base.kind = lendian16 (BRIG_KIND_INST_MEM);\n-  repr.base.opcode = lendian16 (mem->m_opcode);\n-  repr.base.type = lendian16 (mem->m_type);\n-  repr.base.operands = lendian32 (emit_insn_operands (mem));\n-\n-  if (addr->m_symbol)\n-    repr.segment = addr->m_symbol->m_segment;\n-  else\n-    repr.segment = BRIG_SEGMENT_FLAT;\n-  repr.modifier = 0;\n-  repr.equivClass = mem->m_equiv_class;\n-  repr.align = mem->m_align;\n-  if (mem->m_opcode == BRIG_OPCODE_LD)\n-    repr.width = BRIG_WIDTH_1;\n-  else\n-    repr.width = BRIG_WIDTH_NONE;\n-  memset (&repr.reserved, 0, sizeof (repr.reserved));\n-  brig_code.add (&repr, sizeof (repr));\n-  brig_insn_count++;\n-}\n-\n-/* Emit an HSA signal memory instruction and all necessary directives, schedule\n-   necessary operands for writing.  */\n-\n-static void\n-emit_signal_insn (hsa_insn_signal *mem)\n-{\n-  struct BrigInstSignal repr;\n-\n-  memset (&repr, 0, sizeof (repr));\n-  repr.base.base.byteCount = lendian16 (sizeof (repr));\n-  repr.base.base.kind = lendian16 (BRIG_KIND_INST_SIGNAL);\n-  repr.base.opcode = lendian16 (mem->m_opcode);\n-  repr.base.type = lendian16 (mem->m_type);\n-  repr.base.operands = lendian32 (emit_insn_operands (mem));\n-\n-  repr.memoryOrder = mem->m_memory_order;\n-  repr.signalOperation = mem->m_signalop;\n-  repr.signalType = hsa_machine_large_p () ? BRIG_TYPE_SIG64 : BRIG_TYPE_SIG32;\n-\n-  brig_code.add (&repr, sizeof (repr));\n-  brig_insn_count++;\n-}\n-\n-/* Emit an HSA atomic memory instruction and all necessary directives, schedule\n-   necessary operands for writing.  */\n-\n-static void\n-emit_atomic_insn (hsa_insn_atomic *mem)\n-{\n-  struct BrigInstAtomic repr;\n-\n-  /* Either operand[0] or operand[1] must be an address operand.  */\n-  hsa_op_address *addr = NULL;\n-  if (is_a <hsa_op_address *> (mem->get_op (0)))\n-    addr = as_a <hsa_op_address *> (mem->get_op (0));\n-  else\n-    addr = as_a <hsa_op_address *> (mem->get_op (1));\n-\n-  memset (&repr, 0, sizeof (repr));\n-  repr.base.base.byteCount = lendian16 (sizeof (repr));\n-  repr.base.base.kind = lendian16 (BRIG_KIND_INST_ATOMIC);\n-  repr.base.opcode = lendian16 (mem->m_opcode);\n-  repr.base.type = lendian16 (mem->m_type);\n-  repr.base.operands = lendian32 (emit_insn_operands (mem));\n-\n-  if (addr->m_symbol)\n-    repr.segment = addr->m_symbol->m_segment;\n-  else\n-    repr.segment = BRIG_SEGMENT_FLAT;\n-  repr.memoryOrder = mem->m_memoryorder;\n-  repr.memoryScope = mem->m_memoryscope;\n-  repr.atomicOperation = mem->m_atomicop;\n-\n-  brig_code.add (&repr, sizeof (repr));\n-  brig_insn_count++;\n-}\n-\n-/* Emit an HSA LDA instruction and all necessary directives, schedule\n-   necessary operands for writing.  */\n-\n-static void\n-emit_addr_insn (hsa_insn_basic *insn)\n-{\n-  struct BrigInstAddr repr;\n-\n-  hsa_op_address *addr = as_a <hsa_op_address *> (insn->get_op (1));\n-\n-  repr.base.base.byteCount = lendian16 (sizeof (repr));\n-  repr.base.base.kind = lendian16 (BRIG_KIND_INST_ADDR);\n-  repr.base.opcode = lendian16 (insn->m_opcode);\n-  repr.base.type = lendian16 (insn->m_type);\n-  repr.base.operands = lendian32 (emit_insn_operands (insn));\n-\n-  if (addr->m_symbol)\n-    repr.segment = addr->m_symbol->m_segment;\n-  else\n-    repr.segment = BRIG_SEGMENT_FLAT;\n-  memset (&repr.reserved, 0, sizeof (repr.reserved));\n-\n-  brig_code.add (&repr, sizeof (repr));\n-  brig_insn_count++;\n-}\n-\n-/* Emit an HSA segment conversion instruction and all necessary directives,\n-   schedule necessary operands for writing.  */\n-\n-static void\n-emit_segment_insn (hsa_insn_seg *seg)\n-{\n-  struct BrigInstSegCvt repr;\n-\n-  repr.base.base.byteCount = lendian16 (sizeof (repr));\n-  repr.base.base.kind = lendian16 (BRIG_KIND_INST_SEG_CVT);\n-  repr.base.opcode = lendian16 (seg->m_opcode);\n-  repr.base.type = lendian16 (seg->m_type);\n-  repr.base.operands = lendian32 (emit_insn_operands (seg));\n-  repr.sourceType = lendian16 (as_a <hsa_op_reg *> (seg->get_op (1))->m_type);\n-  repr.segment = seg->m_segment;\n-  repr.modifier = 0;\n-\n-  brig_code.add (&repr, sizeof (repr));\n-\n-  brig_insn_count++;\n-}\n-\n-/* Emit an HSA alloca instruction and all necessary directives,\n-   schedule necessary operands for writing.  */\n-\n-static void\n-emit_alloca_insn (hsa_insn_alloca *alloca)\n-{\n-  struct BrigInstMem repr;\n-  gcc_checking_assert (alloca->operand_count () == 2);\n-\n-  memset (&repr, 0, sizeof (repr));\n-  repr.base.base.byteCount = lendian16 (sizeof (repr));\n-  repr.base.base.kind = lendian16 (BRIG_KIND_INST_MEM);\n-  repr.base.opcode = lendian16 (alloca->m_opcode);\n-  repr.base.type = lendian16 (alloca->m_type);\n-  repr.base.operands = lendian32 (emit_insn_operands (alloca));\n-  repr.segment = BRIG_SEGMENT_PRIVATE;\n-  repr.modifier = 0;\n-  repr.equivClass = 0;\n-  repr.align = alloca->m_align;\n-  repr.width = BRIG_WIDTH_NONE;\n-  memset (&repr.reserved, 0, sizeof (repr.reserved));\n-  brig_code.add (&repr, sizeof (repr));\n-  brig_insn_count++;\n-}\n-\n-/* Emit an HSA comparison instruction and all necessary directives,\n-   schedule necessary operands for writing.  */\n-\n-static void\n-emit_cmp_insn (hsa_insn_cmp *cmp)\n-{\n-  struct BrigInstCmp repr;\n-\n-  memset (&repr, 0, sizeof (repr));\n-  repr.base.base.byteCount = lendian16 (sizeof (repr));\n-  repr.base.base.kind = lendian16 (BRIG_KIND_INST_CMP);\n-  repr.base.opcode = lendian16 (cmp->m_opcode);\n-  repr.base.type = lendian16 (cmp->m_type);\n-  repr.base.operands = lendian32 (emit_insn_operands (cmp));\n-\n-  if (is_a <hsa_op_reg *> (cmp->get_op (1)))\n-    repr.sourceType\n-      = lendian16 (as_a <hsa_op_reg *> (cmp->get_op (1))->m_type);\n-  else\n-    repr.sourceType\n-      = lendian16 (as_a <hsa_op_immed *> (cmp->get_op (1))->m_type);\n-  repr.modifier = 0;\n-  repr.compare = cmp->m_compare;\n-  repr.pack = 0;\n-\n-  brig_code.add (&repr, sizeof (repr));\n-  brig_insn_count++;\n-}\n-\n-/* Emit an HSA generic branching/sycnronization instruction.  */\n-\n-static void\n-emit_generic_branch_insn (hsa_insn_br *br)\n-{\n-  struct BrigInstBr repr;\n-  repr.base.base.byteCount = lendian16 (sizeof (repr));\n-  repr.base.base.kind = lendian16 (BRIG_KIND_INST_BR);\n-  repr.base.opcode = lendian16 (br->m_opcode);\n-  repr.width = br->m_width;\n-  repr.base.type = lendian16 (br->m_type);\n-  repr.base.operands = lendian32 (emit_insn_operands (br));\n-  memset (&repr.reserved, 0, sizeof (repr.reserved));\n-\n-  brig_code.add (&repr, sizeof (repr));\n-  brig_insn_count++;\n-}\n-\n-/* Emit an HSA conditional branching instruction and all necessary directives,\n-   schedule necessary operands for writing.  */\n-\n-static void\n-emit_cond_branch_insn (hsa_insn_cbr *br)\n-{\n-  struct BrigInstBr repr;\n-\n-  basic_block target = NULL;\n-  edge_iterator ei;\n-  edge e;\n-\n-  /* At the moment we only handle direct conditional jumps.  */\n-  gcc_assert (br->m_opcode == BRIG_OPCODE_CBR);\n-  repr.base.base.byteCount = lendian16 (sizeof (repr));\n-  repr.base.base.kind = lendian16 (BRIG_KIND_INST_BR);\n-  repr.base.opcode = lendian16 (br->m_opcode);\n-  repr.width = br->m_width;\n-  /* For Conditional jumps the type is always B1.  */\n-  repr.base.type = lendian16 (BRIG_TYPE_B1);\n-\n-  FOR_EACH_EDGE (e, ei, br->m_bb->succs)\n-    if (e->flags & EDGE_TRUE_VALUE)\n-      {\n-\ttarget = e->dest;\n-\tbreak;\n-      }\n-  gcc_assert (target);\n-\n-  repr.base.operands\n-    = lendian32 (emit_operands (br->get_op (0),\n-\t\t\t\t&hsa_bb_for_bb (target)->m_label_ref));\n-  memset (&repr.reserved, 0, sizeof (repr.reserved));\n-\n-  brig_code.add (&repr, sizeof (repr));\n-  brig_insn_count++;\n-}\n-\n-/* Emit an HSA unconditional jump branching instruction that points to\n-   a label REFERENCE.  */\n-\n-static void\n-emit_unconditional_jump (hsa_op_code_ref *reference)\n-{\n-  struct BrigInstBr repr;\n-\n-  repr.base.base.byteCount = lendian16 (sizeof (repr));\n-  repr.base.base.kind = lendian16 (BRIG_KIND_INST_BR);\n-  repr.base.opcode = lendian16 (BRIG_OPCODE_BR);\n-  repr.base.type = lendian16 (BRIG_TYPE_NONE);\n-  /* Direct branches to labels must be width(all).  */\n-  repr.width = BRIG_WIDTH_ALL;\n-\n-  repr.base.operands = lendian32 (emit_operands (reference));\n-  memset (&repr.reserved, 0, sizeof (repr.reserved));\n-  brig_code.add (&repr, sizeof (repr));\n-  brig_insn_count++;\n-}\n-\n-/* Emit an HSA switch jump instruction that uses a jump table to\n-   jump to a destination label.  */\n-\n-static void\n-emit_switch_insn (hsa_insn_sbr *sbr)\n-{\n-  struct BrigInstBr repr;\n-\n-  gcc_assert (sbr->m_opcode == BRIG_OPCODE_SBR);\n-  repr.base.base.byteCount = lendian16 (sizeof (repr));\n-  repr.base.base.kind = lendian16 (BRIG_KIND_INST_BR);\n-  repr.base.opcode = lendian16 (sbr->m_opcode);\n-  repr.width = BRIG_WIDTH_1;\n-  /* For Conditional jumps the type is always B1.  */\n-  hsa_op_reg *index = as_a <hsa_op_reg *> (sbr->get_op (0));\n-  repr.base.type = lendian16 (index->m_type);\n-  repr.base.operands\n-    = lendian32 (emit_operands (sbr->get_op (0), sbr->m_label_code_list));\n-  memset (&repr.reserved, 0, sizeof (repr.reserved));\n-\n-  brig_code.add (&repr, sizeof (repr));\n-  brig_insn_count++;\n-}\n-\n-/* Emit a HSA convert instruction and all necessary directives, schedule\n-   necessary operands for writing.  */\n-\n-static void\n-emit_cvt_insn (hsa_insn_cvt *insn)\n-{\n-  struct BrigInstCvt repr;\n-  BrigType16_t srctype;\n-\n-  repr.base.base.byteCount = lendian16 (sizeof (repr));\n-  repr.base.base.kind = lendian16 (BRIG_KIND_INST_CVT);\n-  repr.base.opcode = lendian16 (insn->m_opcode);\n-  repr.base.type = lendian16 (insn->m_type);\n-  repr.base.operands = lendian32 (emit_insn_operands (insn));\n-\n-  if (is_a <hsa_op_reg *> (insn->get_op (1)))\n-    srctype = as_a <hsa_op_reg *> (insn->get_op (1))->m_type;\n-  else\n-    srctype = as_a <hsa_op_immed *> (insn->get_op (1))->m_type;\n-  repr.sourceType = lendian16 (srctype);\n-  repr.modifier = 0;\n-  /* float to smaller float requires a rounding setting (we default\n-     to 'near'.  */\n-  if (hsa_type_float_p (insn->m_type)\n-      && (!hsa_type_float_p (srctype)\n-\t  || ((insn->m_type & BRIG_TYPE_BASE_MASK)\n-\t      < (srctype & BRIG_TYPE_BASE_MASK))))\n-    repr.round = BRIG_ROUND_FLOAT_NEAR_EVEN;\n-  else if (hsa_type_integer_p (insn->m_type) &&\n-\t   hsa_type_float_p (srctype))\n-    repr.round = BRIG_ROUND_INTEGER_ZERO;\n-  else\n-    repr.round = BRIG_ROUND_NONE;\n-  brig_code.add (&repr, sizeof (repr));\n-  brig_insn_count++;\n-}\n-\n-/* Emit call instruction INSN, where this instruction must be closed\n-   within a call block instruction.  */\n-\n-static void\n-emit_call_insn (hsa_insn_call *call)\n-{\n-  struct BrigInstBr repr;\n-\n-  repr.base.base.byteCount = lendian16 (sizeof (repr));\n-  repr.base.base.kind = lendian16 (BRIG_KIND_INST_BR);\n-  repr.base.opcode = lendian16 (BRIG_OPCODE_CALL);\n-  repr.base.type = lendian16 (BRIG_TYPE_NONE);\n-\n-  repr.base.operands\n-    = lendian32 (emit_operands (call->m_result_code_list, &call->m_func,\n-\t\t\t\tcall->m_args_code_list));\n-\n-  /* Internal functions have not set m_called_function.  */\n-  if (call->m_called_function)\n-    {\n-      function_linkage_pair pair (call->m_called_function,\n-\t\t\t\t  call->m_func.m_brig_op_offset);\n-      function_call_linkage.safe_push (pair);\n-    }\n-  else\n-    {\n-      hsa_internal_fn *slot\n-\t= hsa_emitted_internal_decls->find (call->m_called_internal_fn);\n-      gcc_assert (slot);\n-      gcc_assert (slot->m_offset > 0);\n-      call->m_func.m_directive_offset = slot->m_offset;\n-    }\n-\n-  repr.width = BRIG_WIDTH_ALL;\n-  memset (&repr.reserved, 0, sizeof (repr.reserved));\n-\n-  brig_code.add (&repr, sizeof (repr));\n-  brig_insn_count++;\n-}\n-\n-/* Emit argument block directive.  */\n-\n-static void\n-emit_arg_block_insn (hsa_insn_arg_block *insn)\n-{\n-  switch (insn->m_kind)\n-    {\n-    case BRIG_KIND_DIRECTIVE_ARG_BLOCK_START:\n-      {\n-\tstruct BrigDirectiveArgBlock repr;\n-\trepr.base.byteCount = lendian16 (sizeof (repr));\n-\trepr.base.kind = lendian16 (insn->m_kind);\n-\tbrig_code.add (&repr, sizeof (repr));\n-\n-\tfor (unsigned i = 0; i < insn->m_call_insn->m_input_args.length (); i++)\n-\t  {\n-\t    insn->m_call_insn->m_args_code_list->m_offsets[i]\n-\t      = lendian32 (emit_directive_variable\n-\t\t\t   (insn->m_call_insn->m_input_args[i]));\n-\t    brig_insn_count++;\n-\t  }\n-\n-\tif (insn->m_call_insn->m_output_arg)\n-\t  {\n-\t    insn->m_call_insn->m_result_code_list->m_offsets[0]\n-\t      = lendian32 (emit_directive_variable\n-\t\t\t   (insn->m_call_insn->m_output_arg));\n-\t    brig_insn_count++;\n-\t  }\n-\n-\tbreak;\n-      }\n-    case BRIG_KIND_DIRECTIVE_ARG_BLOCK_END:\n-      {\n-\tstruct BrigDirectiveArgBlock repr;\n-\trepr.base.byteCount = lendian16 (sizeof (repr));\n-\trepr.base.kind = lendian16 (insn->m_kind);\n-\tbrig_code.add (&repr, sizeof (repr));\n-\tbreak;\n-      }\n-    default:\n-      gcc_unreachable ();\n-    }\n-\n-  brig_insn_count++;\n-}\n-\n-/* Emit comment directive.  */\n-\n-static void\n-emit_comment_insn (hsa_insn_comment *insn)\n-{\n-  struct BrigDirectiveComment repr;\n-  memset (&repr, 0, sizeof (repr));\n-\n-  repr.base.byteCount = lendian16 (sizeof (repr));\n-  repr.base.kind = lendian16 (insn->m_opcode);\n-  repr.name = brig_emit_string (insn->m_comment, '\\0', false);\n-  brig_code.add (&repr, sizeof (repr));\n-}\n-\n-/* Emit queue instruction INSN.  */\n-\n-static void\n-emit_queue_insn (hsa_insn_queue *insn)\n-{\n-  BrigInstQueue repr;\n-  memset (&repr, 0, sizeof (repr));\n-\n-  repr.base.base.byteCount = lendian16 (sizeof (repr));\n-  repr.base.base.kind = lendian16 (BRIG_KIND_INST_QUEUE);\n-  repr.base.opcode = lendian16 (insn->m_opcode);\n-  repr.base.type = lendian16 (insn->m_type);\n-  repr.segment = insn->m_segment;\n-  repr.memoryOrder = insn->m_memory_order;\n-  repr.base.operands = lendian32 (emit_insn_operands (insn));\n-  brig_data.round_size_up (4);\n-  brig_code.add (&repr, sizeof (repr));\n-\n-  brig_insn_count++;\n-}\n-\n-/* Emit source type instruction INSN.  */\n-\n-static void\n-emit_srctype_insn (hsa_insn_srctype *insn)\n-{\n-  /* We assume that BrigInstMod has a BrigInstBasic prefix.  */\n-  struct BrigInstSourceType repr;\n-  unsigned operand_count = insn->operand_count ();\n-  gcc_checking_assert (operand_count >= 2);\n-\n-  memset (&repr, 0, sizeof (repr));\n-  repr.sourceType = lendian16 (insn->m_source_type);\n-  repr.base.base.byteCount = lendian16 (sizeof (repr));\n-  repr.base.base.kind = lendian16 (BRIG_KIND_INST_SOURCE_TYPE);\n-  repr.base.opcode = lendian16 (insn->m_opcode);\n-  repr.base.type = lendian16 (insn->m_type);\n-\n-  repr.base.operands = lendian32 (emit_insn_operands (insn));\n-  brig_code.add (&repr, sizeof (struct BrigInstSourceType));\n-  brig_insn_count++;\n-}\n-\n-/* Emit packed instruction INSN.  */\n-\n-static void\n-emit_packed_insn (hsa_insn_packed *insn)\n-{\n-  /* We assume that BrigInstMod has a BrigInstBasic prefix.  */\n-  struct BrigInstSourceType repr;\n-  unsigned operand_count = insn->operand_count ();\n-  gcc_checking_assert (operand_count >= 2);\n-\n-  memset (&repr, 0, sizeof (repr));\n-  repr.sourceType = lendian16 (insn->m_source_type);\n-  repr.base.base.byteCount = lendian16 (sizeof (repr));\n-  repr.base.base.kind = lendian16 (BRIG_KIND_INST_SOURCE_TYPE);\n-  repr.base.opcode = lendian16 (insn->m_opcode);\n-  repr.base.type = lendian16 (insn->m_type);\n-\n-  if (insn->m_opcode == BRIG_OPCODE_COMBINE)\n-    {\n-      /* Create operand list for packed type.  */\n-      for (unsigned i = 1; i < operand_count; i++)\n-\t{\n-\t  gcc_checking_assert (insn->get_op (i));\n-\t  insn->m_operand_list->m_offsets[i - 1]\n-\t    = lendian32 (enqueue_op (insn->get_op (i)));\n-\t}\n-\n-      repr.base.operands = lendian32 (emit_operands (insn->get_op (0),\n-\t\t\t\t\t\t     insn->m_operand_list));\n-    }\n-  else if (insn->m_opcode == BRIG_OPCODE_EXPAND)\n-    {\n-      /* Create operand list for packed type.  */\n-      for (unsigned i = 0; i < operand_count - 1; i++)\n-\t{\n-\t  gcc_checking_assert (insn->get_op (i));\n-\t  insn->m_operand_list->m_offsets[i]\n-\t    = lendian32 (enqueue_op (insn->get_op (i)));\n-\t}\n-\n-      unsigned ops = emit_operands (insn->m_operand_list,\n-\t\t\t\t    insn->get_op (insn->operand_count () - 1));\n-      repr.base.operands = lendian32 (ops);\n-    }\n-\n-\n-  brig_code.add (&repr, sizeof (struct BrigInstSourceType));\n-  brig_insn_count++;\n-}\n-\n-/* Emit a basic HSA instruction and all necessary directives, schedule\n-   necessary operands for writing.  */\n-\n-static void\n-emit_basic_insn (hsa_insn_basic *insn)\n-{\n-  /* We assume that BrigInstMod has a BrigInstBasic prefix.  */\n-  struct BrigInstMod repr;\n-  BrigType16_t type;\n-\n-  memset (&repr, 0, sizeof (repr));\n-  repr.base.base.byteCount = lendian16 (sizeof (BrigInstBasic));\n-  repr.base.base.kind = lendian16 (BRIG_KIND_INST_BASIC);\n-  repr.base.opcode = lendian16 (insn->m_opcode);\n-  switch (insn->m_opcode)\n-    {\n-      /* And the bit-logical operations need bit types and whine about\n-\t arithmetic types :-/  */\n-      case BRIG_OPCODE_AND:\n-      case BRIG_OPCODE_OR:\n-      case BRIG_OPCODE_XOR:\n-      case BRIG_OPCODE_NOT:\n-\ttype = regtype_for_type (insn->m_type);\n-\tbreak;\n-      default:\n-\ttype = insn->m_type;\n-\tbreak;\n-    }\n-  repr.base.type = lendian16 (type);\n-  repr.base.operands = lendian32 (emit_insn_operands (insn));\n-\n-  if (hsa_type_packed_p (type))\n-    {\n-      if (hsa_type_float_p (type)\n-\t  && !hsa_opcode_floating_bit_insn_p (insn->m_opcode))\n-\trepr.round = BRIG_ROUND_FLOAT_NEAR_EVEN;\n-      else\n-\trepr.round = 0;\n-      /* We assume that destination and sources agree in packing layout.  */\n-      if (insn->num_used_ops () >= 2)\n-\trepr.pack = BRIG_PACK_PP;\n-      else\n-\trepr.pack = BRIG_PACK_P;\n-      repr.reserved = 0;\n-      repr.base.base.byteCount = lendian16 (sizeof (BrigInstMod));\n-      repr.base.base.kind = lendian16 (BRIG_KIND_INST_MOD);\n-      brig_code.add (&repr, sizeof (struct BrigInstMod));\n-    }\n-  else\n-    brig_code.add (&repr, sizeof (struct BrigInstBasic));\n-  brig_insn_count++;\n-}\n-\n-/* Emit an HSA instruction and all necessary directives, schedule necessary\n-   operands for writing.  */\n-\n-static void\n-emit_insn (hsa_insn_basic *insn)\n-{\n-  gcc_assert (!is_a <hsa_insn_phi *> (insn));\n-\n-  insn->m_brig_offset = brig_code.total_size;\n-\n-  if (hsa_insn_signal *signal = dyn_cast <hsa_insn_signal *> (insn))\n-    emit_signal_insn (signal);\n-  else if (hsa_insn_atomic *atom = dyn_cast <hsa_insn_atomic *> (insn))\n-    emit_atomic_insn (atom);\n-  else if (hsa_insn_mem *mem = dyn_cast <hsa_insn_mem *> (insn))\n-    emit_memory_insn (mem);\n-  else if (insn->m_opcode == BRIG_OPCODE_LDA)\n-    emit_addr_insn (insn);\n-  else if (hsa_insn_seg *seg = dyn_cast <hsa_insn_seg *> (insn))\n-    emit_segment_insn (seg);\n-  else if (hsa_insn_cmp *cmp = dyn_cast <hsa_insn_cmp *> (insn))\n-    emit_cmp_insn (cmp);\n-  else if (hsa_insn_cbr *br = dyn_cast <hsa_insn_cbr *> (insn))\n-    emit_cond_branch_insn (br);\n-  else if (hsa_insn_sbr *sbr = dyn_cast <hsa_insn_sbr *> (insn))\n-    {\n-      if (switch_instructions == NULL)\n-\tswitch_instructions = new vec <hsa_insn_sbr *> ();\n-\n-      switch_instructions->safe_push (sbr);\n-      emit_switch_insn (sbr);\n-    }\n-  else if (hsa_insn_br *br = dyn_cast <hsa_insn_br *> (insn))\n-    emit_generic_branch_insn (br);\n-  else if (hsa_insn_arg_block *block = dyn_cast <hsa_insn_arg_block *> (insn))\n-    emit_arg_block_insn (block);\n-  else if (hsa_insn_call *call = dyn_cast <hsa_insn_call *> (insn))\n-    emit_call_insn (call);\n-  else if (hsa_insn_comment *comment = dyn_cast <hsa_insn_comment *> (insn))\n-    emit_comment_insn (comment);\n-  else if (hsa_insn_queue *queue = dyn_cast <hsa_insn_queue *> (insn))\n-    emit_queue_insn (queue);\n-  else if (hsa_insn_srctype *srctype = dyn_cast <hsa_insn_srctype *> (insn))\n-    emit_srctype_insn (srctype);\n-  else if (hsa_insn_packed *packed = dyn_cast <hsa_insn_packed *> (insn))\n-    emit_packed_insn (packed);\n-  else if (hsa_insn_cvt *cvt = dyn_cast <hsa_insn_cvt *> (insn))\n-    emit_cvt_insn (cvt);\n-  else if (hsa_insn_alloca *alloca = dyn_cast <hsa_insn_alloca *> (insn))\n-    emit_alloca_insn (alloca);\n-  else\n-    emit_basic_insn (insn);\n-}\n-\n-/* We have just finished emitting BB and are about to emit NEXT_BB if non-NULL,\n-   or we are about to finish emitting code, if it is NULL.  If the fall through\n-   edge from BB does not lead to NEXT_BB, emit an unconditional jump.  */\n-\n-static void\n-perhaps_emit_branch (basic_block bb, basic_block next_bb)\n-{\n-  basic_block t_bb = NULL, ff = NULL;\n-\n-  edge_iterator ei;\n-  edge e;\n-\n-  /* If the last instruction of BB is a switch, ignore emission of all\n-     edges.  */\n-  if (hsa_bb_for_bb (bb)->m_last_insn\n-      && is_a <hsa_insn_sbr *> (hsa_bb_for_bb (bb)->m_last_insn))\n-    return;\n-\n-  FOR_EACH_EDGE (e, ei, bb->succs)\n-    if (e->flags & EDGE_TRUE_VALUE)\n-      {\n-\tgcc_assert (!t_bb);\n-\tt_bb = e->dest;\n-      }\n-    else\n-      {\n-\tgcc_assert (!ff);\n-\tff = e->dest;\n-      }\n-\n-  if (!ff || ff == next_bb || ff == EXIT_BLOCK_PTR_FOR_FN (cfun))\n-    return;\n-\n-  emit_unconditional_jump (&hsa_bb_for_bb (ff)->m_label_ref);\n-}\n-\n-/* Emit the a function with name NAME to the various brig sections.  */\n-\n-void\n-hsa_brig_emit_function (void)\n-{\n-  basic_block bb, prev_bb;\n-  hsa_insn_basic *insn;\n-  BrigDirectiveExecutable *ptr_to_fndir;\n-\n-  brig_init ();\n-\n-  brig_insn_count = 0;\n-  memset (&op_queue, 0, sizeof (op_queue));\n-  op_queue.projected_size = brig_operand.total_size;\n-\n-  if (!function_offsets)\n-    function_offsets = new hash_map<tree, BrigCodeOffset32_t> ();\n-\n-  if (!emitted_declarations)\n-    emitted_declarations = new hash_map <tree, BrigDirectiveExecutable *> ();\n-\n-  for (unsigned i = 0; i < hsa_cfun->m_called_functions.length (); i++)\n-    {\n-      tree called = hsa_cfun->m_called_functions[i];\n-\n-      /* If the function has no definition, emit a declaration.  */\n-      if (!emitted_declarations->get (called))\n-\t{\n-\t  BrigDirectiveExecutable *e = emit_function_declaration (called);\n-\t  emitted_declarations->put (called, e);\n-\t}\n-    }\n-\n-  for (unsigned i = 0; i < hsa_cfun->m_called_internal_fns.length (); i++)\n-    {\n-      hsa_internal_fn *called = hsa_cfun->m_called_internal_fns[i];\n-      emit_internal_fn_decl (called);\n-    }\n-\n-  ptr_to_fndir = emit_function_directives (hsa_cfun, false);\n-  for (insn = hsa_bb_for_bb (ENTRY_BLOCK_PTR_FOR_FN (cfun))->m_first_insn;\n-       insn;\n-       insn = insn->m_next)\n-    emit_insn (insn);\n-  prev_bb = ENTRY_BLOCK_PTR_FOR_FN (cfun);\n-  FOR_EACH_BB_FN (bb, cfun)\n-    {\n-      perhaps_emit_branch (prev_bb, bb);\n-      emit_bb_label_directive (hsa_bb_for_bb (bb));\n-      for (insn = hsa_bb_for_bb (bb)->m_first_insn; insn; insn = insn->m_next)\n-\temit_insn (insn);\n-      prev_bb = bb;\n-    }\n-  perhaps_emit_branch (prev_bb, NULL);\n-  ptr_to_fndir->nextModuleEntry = lendian32 (brig_code.total_size);\n-\n-  /* Fill up label references for all sbr instructions.  */\n-  if (switch_instructions)\n-    {\n-      for (unsigned i = 0; i < switch_instructions->length (); i++)\n-\t{\n-\t  hsa_insn_sbr *sbr = (*switch_instructions)[i];\n-\t  for (unsigned j = 0; j < sbr->m_jump_table.length (); j++)\n-\t    {\n-\t      hsa_bb *hbb = hsa_bb_for_bb (sbr->m_jump_table[j]);\n-\t      sbr->m_label_code_list->m_offsets[j]\n-\t\t= hbb->m_label_ref.m_directive_offset;\n-\t    }\n-\t}\n-\n-      switch_instructions->release ();\n-      delete switch_instructions;\n-      switch_instructions = NULL;\n-    }\n-\n-  if (dump_file)\n-    {\n-      fprintf (dump_file, \"------- After BRIG emission: -------\\n\");\n-      dump_hsa_cfun (dump_file);\n-    }\n-\n-  emit_queued_operands ();\n-}\n-\n-/* Emit all OMP symbols related to OMP.  */\n-\n-void\n-hsa_brig_emit_omp_symbols (void)\n-{\n-  brig_init ();\n-  emit_directive_variable (hsa_num_threads);\n-}\n-\n-/* Create and return __hsa_global_variables symbol that contains\n-   all informations consumed by libgomp to link global variables\n-   with their string names used by an HSA kernel.  */\n-\n-static tree\n-hsa_output_global_variables ()\n-{\n-  unsigned l = hsa_global_variable_symbols->elements ();\n-\n-  tree variable_info_type = make_node (RECORD_TYPE);\n-  tree id_f1 = build_decl (BUILTINS_LOCATION, FIELD_DECL,\n-\t\t\t   get_identifier (\"name\"), ptr_type_node);\n-  DECL_CHAIN (id_f1) = NULL_TREE;\n-  tree id_f2 = build_decl (BUILTINS_LOCATION, FIELD_DECL,\n-\t\t\t   get_identifier (\"omp_data_size\"),\n-\t\t\t   ptr_type_node);\n-  DECL_CHAIN (id_f2) = id_f1;\n-  finish_builtin_struct (variable_info_type, \"__hsa_variable_info\", id_f2,\n-\t\t\t NULL_TREE);\n-\n-  tree int_num_of_global_vars;\n-  int_num_of_global_vars = build_int_cst (uint32_type_node, l);\n-  tree global_vars_num_index_type = build_index_type (int_num_of_global_vars);\n-  tree global_vars_array_type = build_array_type (variable_info_type,\n-\t\t\t\t\t\t  global_vars_num_index_type);\n-  TYPE_ARTIFICIAL (global_vars_array_type) = 1;\n-\n-  vec<constructor_elt, va_gc> *global_vars_vec = NULL;\n-\n-  for (hash_table <hsa_noop_symbol_hasher>::iterator it\n-       = hsa_global_variable_symbols->begin ();\n-       it != hsa_global_variable_symbols->end (); ++it)\n-    {\n-      unsigned len = strlen ((*it)->m_name);\n-      char *copy = XNEWVEC (char, len + 2);\n-      copy[0] = '&';\n-      memcpy (copy + 1, (*it)->m_name, len);\n-      copy[len + 1] = '\\0';\n-      len++;\n-      hsa_sanitize_name (copy);\n-\n-      tree var_name = build_string (len, copy);\n-      TREE_TYPE (var_name)\n-\t= build_array_type (char_type_node, build_index_type (size_int (len)));\n-      free (copy);\n-\n-      vec<constructor_elt, va_gc> *variable_info_vec = NULL;\n-      CONSTRUCTOR_APPEND_ELT (variable_info_vec, NULL_TREE,\n-\t\t\t      build1 (ADDR_EXPR,\n-\t\t\t\t      build_pointer_type (TREE_TYPE (var_name)),\n-\t\t\t\t      var_name));\n-      CONSTRUCTOR_APPEND_ELT (variable_info_vec, NULL_TREE,\n-\t\t\t      build_fold_addr_expr ((*it)->m_decl));\n-\n-      tree variable_info_ctor = build_constructor (variable_info_type,\n-\t\t\t\t\t\t   variable_info_vec);\n-\n-      CONSTRUCTOR_APPEND_ELT (global_vars_vec, NULL_TREE,\n-\t\t\t      variable_info_ctor);\n-    }\n-\n-  tree global_vars_ctor = build_constructor (global_vars_array_type,\n-\t\t\t\t\t     global_vars_vec);\n-\n-  char tmp_name[64];\n-  ASM_GENERATE_INTERNAL_LABEL (tmp_name, \"__hsa_global_variables\", 1);\n-  tree global_vars_table = build_decl (UNKNOWN_LOCATION, VAR_DECL,\n-\t\t\t\t\t   get_identifier (tmp_name),\n-\t\t\t\t\t   global_vars_array_type);\n-  TREE_STATIC (global_vars_table) = 1;\n-  TREE_READONLY (global_vars_table) = 1;\n-  TREE_PUBLIC (global_vars_table) = 0;\n-  DECL_ARTIFICIAL (global_vars_table) = 1;\n-  DECL_IGNORED_P (global_vars_table) = 1;\n-  DECL_EXTERNAL (global_vars_table) = 0;\n-  TREE_CONSTANT (global_vars_table) = 1;\n-  DECL_INITIAL (global_vars_table) = global_vars_ctor;\n-  varpool_node::finalize_decl (global_vars_table);\n-\n-  return global_vars_table;\n-}\n-\n-/* Create __hsa_host_functions and __hsa_kernels that contain\n-   all informations consumed by libgomp to register all kernels\n-   in the BRIG binary.  */\n-\n-static void\n-hsa_output_kernels (tree *host_func_table, tree *kernels)\n-{\n-  unsigned map_count = hsa_get_number_decl_kernel_mappings ();\n-\n-  tree int_num_of_kernels;\n-  int_num_of_kernels = build_int_cst (uint32_type_node, map_count);\n-  tree kernel_num_index_type = build_index_type (int_num_of_kernels);\n-  tree host_functions_array_type = build_array_type (ptr_type_node,\n-\t\t\t\t\t\t     kernel_num_index_type);\n-  TYPE_ARTIFICIAL (host_functions_array_type) = 1;\n-\n-  vec<constructor_elt, va_gc> *host_functions_vec = NULL;\n-  for (unsigned i = 0; i < map_count; ++i)\n-    {\n-      tree decl = hsa_get_decl_kernel_mapping_decl (i);\n-      tree host_fn = build_fold_addr_expr (hsa_get_host_function (decl));\n-      CONSTRUCTOR_APPEND_ELT (host_functions_vec, NULL_TREE, host_fn);\n-    }\n-  tree host_functions_ctor = build_constructor (host_functions_array_type,\n-\t\t\t\t\t\thost_functions_vec);\n-  char tmp_name[64];\n-  ASM_GENERATE_INTERNAL_LABEL (tmp_name, \"__hsa_host_functions\", 1);\n-  tree hsa_host_func_table = build_decl (UNKNOWN_LOCATION, VAR_DECL,\n-\t\t\t\t\t get_identifier (tmp_name),\n-\t\t\t\t\t host_functions_array_type);\n-  TREE_STATIC (hsa_host_func_table) = 1;\n-  TREE_READONLY (hsa_host_func_table) = 1;\n-  TREE_PUBLIC (hsa_host_func_table) = 0;\n-  DECL_ARTIFICIAL (hsa_host_func_table) = 1;\n-  DECL_IGNORED_P (hsa_host_func_table) = 1;\n-  DECL_EXTERNAL (hsa_host_func_table) = 0;\n-  TREE_CONSTANT (hsa_host_func_table) = 1;\n-  DECL_INITIAL (hsa_host_func_table) = host_functions_ctor;\n-  varpool_node::finalize_decl (hsa_host_func_table);\n-  *host_func_table = hsa_host_func_table;\n-\n-  /* Following code emits list of kernel_info structures.  */\n-\n-  tree kernel_info_type = make_node (RECORD_TYPE);\n-  tree id_f1 = build_decl (BUILTINS_LOCATION, FIELD_DECL,\n-\t\t\t   get_identifier (\"name\"), ptr_type_node);\n-  DECL_CHAIN (id_f1) = NULL_TREE;\n-  tree id_f2 = build_decl (BUILTINS_LOCATION, FIELD_DECL,\n-\t\t\t   get_identifier (\"omp_data_size\"),\n-\t\t\t   unsigned_type_node);\n-  DECL_CHAIN (id_f2) = id_f1;\n-  tree id_f3 = build_decl (BUILTINS_LOCATION, FIELD_DECL,\n-\t\t\t   get_identifier (\"gridified_kernel_p\"),\n-\t\t\t   boolean_type_node);\n-  DECL_CHAIN (id_f3) = id_f2;\n-  tree id_f4 = build_decl (BUILTINS_LOCATION, FIELD_DECL,\n-\t\t\t   get_identifier (\"kernel_dependencies_count\"),\n-\t\t\t   unsigned_type_node);\n-  DECL_CHAIN (id_f4) = id_f3;\n-  tree id_f5 = build_decl (BUILTINS_LOCATION, FIELD_DECL,\n-\t\t\t   get_identifier (\"kernel_dependencies\"),\n-\t\t\t   build_pointer_type (build_pointer_type\n-\t\t\t\t\t       (char_type_node)));\n-  DECL_CHAIN (id_f5) = id_f4;\n-  finish_builtin_struct (kernel_info_type, \"__hsa_kernel_info\", id_f5,\n-\t\t\t NULL_TREE);\n-\n-  int_num_of_kernels = build_int_cstu (uint32_type_node, map_count);\n-  tree kernel_info_vector_type\n-    = build_array_type (kernel_info_type,\n-\t\t\tbuild_index_type (int_num_of_kernels));\n-  TYPE_ARTIFICIAL (kernel_info_vector_type) = 1;\n-\n-  vec<constructor_elt, va_gc> *kernel_info_vector_vec = NULL;\n-  tree kernel_dependencies_vector_type = NULL;\n-\n-  for (unsigned i = 0; i < map_count; ++i)\n-    {\n-      tree kernel = hsa_get_decl_kernel_mapping_decl (i);\n-      char *name = hsa_get_decl_kernel_mapping_name (i);\n-      unsigned len = strlen (name);\n-      char *copy = XNEWVEC (char, len + 2);\n-      copy[0] = '&';\n-      memcpy (copy + 1, name, len);\n-      copy[len + 1] = '\\0';\n-      len++;\n-\n-      tree kern_name = build_string (len, copy);\n-      TREE_TYPE (kern_name)\n-\t= build_array_type (char_type_node, build_index_type (size_int (len)));\n-      free (copy);\n-\n-      unsigned omp_size = hsa_get_decl_kernel_mapping_omp_size (i);\n-      tree omp_data_size = build_int_cstu (unsigned_type_node, omp_size);\n-      bool gridified_kernel_p = hsa_get_decl_kernel_mapping_gridified (i);\n-      tree gridified_kernel_p_tree = build_int_cstu (boolean_type_node,\n-\t\t\t\t\t\t     gridified_kernel_p);\n-      unsigned count = 0;\n-      vec<constructor_elt, va_gc> *kernel_dependencies_vec = NULL;\n-      if (hsa_decl_kernel_dependencies)\n-\t{\n-\t  vec<const char *> **slot;\n-\t  slot = hsa_decl_kernel_dependencies->get (kernel);\n-\t  if (slot)\n-\t    {\n-\t      vec <const char *> *dependencies = *slot;\n-\t      count = dependencies->length ();\n-\n-\t      kernel_dependencies_vector_type\n-\t\t= build_array_type (build_pointer_type (char_type_node),\n-\t\t\t\t    build_index_type (size_int (count)));\n-\t      TYPE_ARTIFICIAL (kernel_dependencies_vector_type) = 1;\n-\n-\t      for (unsigned j = 0; j < count; j++)\n-\t\t{\n-\t\t  const char *d = (*dependencies)[j];\n-\t\t  len = strlen (d);\n-\t\t  tree dependency_name = build_string (len, d);\n-\t\t  TREE_TYPE (dependency_name)\n-\t\t    = build_array_type (char_type_node,\n-\t\t\t\t\tbuild_index_type (size_int (len)));\n-\n-\t\t  CONSTRUCTOR_APPEND_ELT\n-\t\t    (kernel_dependencies_vec, NULL_TREE,\n-\t\t     build1 (ADDR_EXPR,\n-\t\t\t     build_pointer_type (TREE_TYPE (dependency_name)),\n-\t\t\t     dependency_name));\n-\t\t}\n-\t    }\n-\t}\n-\n-      tree dependencies_count = build_int_cstu (unsigned_type_node, count);\n-\n-      vec<constructor_elt, va_gc> *kernel_info_vec = NULL;\n-      CONSTRUCTOR_APPEND_ELT (kernel_info_vec, NULL_TREE,\n-\t\t\t      build1 (ADDR_EXPR,\n-\t\t\t\t      build_pointer_type (TREE_TYPE\n-\t\t\t\t\t\t\t  (kern_name)),\n-\t\t\t\t      kern_name));\n-      CONSTRUCTOR_APPEND_ELT (kernel_info_vec, NULL_TREE, omp_data_size);\n-      CONSTRUCTOR_APPEND_ELT (kernel_info_vec, NULL_TREE,\n-\t\t\t      gridified_kernel_p_tree);\n-      CONSTRUCTOR_APPEND_ELT (kernel_info_vec, NULL_TREE, dependencies_count);\n-\n-      if (count > 0)\n-\t{\n-\t  ASM_GENERATE_INTERNAL_LABEL (tmp_name, \"__hsa_dependencies_list\", i);\n-\t  gcc_checking_assert (kernel_dependencies_vector_type);\n-\t  tree dependencies_list = build_decl (UNKNOWN_LOCATION, VAR_DECL,\n-\t\t\t\t\t       get_identifier (tmp_name),\n-\t\t\t\t\t       kernel_dependencies_vector_type);\n-\n-\t  TREE_STATIC (dependencies_list) = 1;\n-\t  TREE_READONLY (dependencies_list) = 1;\n-\t  TREE_PUBLIC (dependencies_list) = 0;\n-\t  DECL_ARTIFICIAL (dependencies_list) = 1;\n-\t  DECL_IGNORED_P (dependencies_list) = 1;\n-\t  DECL_EXTERNAL (dependencies_list) = 0;\n-\t  TREE_CONSTANT (dependencies_list) = 1;\n-\t  DECL_INITIAL (dependencies_list)\n-\t    = build_constructor (kernel_dependencies_vector_type,\n-\t\t\t\t kernel_dependencies_vec);\n-\t  varpool_node::finalize_decl (dependencies_list);\n-\n-\t  CONSTRUCTOR_APPEND_ELT (kernel_info_vec, NULL_TREE,\n-\t\t\t\t  build1 (ADDR_EXPR,\n-\t\t\t\t\t  build_pointer_type\n-\t\t\t\t\t    (TREE_TYPE (dependencies_list)),\n-\t\t\t\t\t  dependencies_list));\n-\t}\n-      else\n-\tCONSTRUCTOR_APPEND_ELT (kernel_info_vec, NULL_TREE, null_pointer_node);\n-\n-      tree kernel_info_ctor = build_constructor (kernel_info_type,\n-\t\t\t\t\t\t kernel_info_vec);\n-\n-      CONSTRUCTOR_APPEND_ELT (kernel_info_vector_vec, NULL_TREE,\n-\t\t\t      kernel_info_ctor);\n-    }\n-\n-  ASM_GENERATE_INTERNAL_LABEL (tmp_name, \"__hsa_kernels\", 1);\n-  tree hsa_kernels = build_decl (UNKNOWN_LOCATION, VAR_DECL,\n-\t\t\t\t get_identifier (tmp_name),\n-\t\t\t\t kernel_info_vector_type);\n-\n-  TREE_STATIC (hsa_kernels) = 1;\n-  TREE_READONLY (hsa_kernels) = 1;\n-  TREE_PUBLIC (hsa_kernels) = 0;\n-  DECL_ARTIFICIAL (hsa_kernels) = 1;\n-  DECL_IGNORED_P (hsa_kernels) = 1;\n-  DECL_EXTERNAL (hsa_kernels) = 0;\n-  TREE_CONSTANT (hsa_kernels) = 1;\n-  DECL_INITIAL (hsa_kernels) = build_constructor (kernel_info_vector_type,\n-\t\t\t\t\t\t  kernel_info_vector_vec);\n-  varpool_node::finalize_decl (hsa_kernels);\n-  *kernels = hsa_kernels;\n-}\n-\n-/* Create a static constructor that will register out brig stuff with\n-   libgomp.  */\n-\n-static void\n-hsa_output_libgomp_mapping (tree brig_decl)\n-{\n-  unsigned kernel_count = hsa_get_number_decl_kernel_mappings ();\n-  unsigned global_variable_count = hsa_global_variable_symbols->elements ();\n-\n-  tree kernels;\n-  tree host_func_table;\n-\n-  hsa_output_kernels (&host_func_table, &kernels);\n-  tree global_vars = hsa_output_global_variables ();\n-\n-  tree hsa_image_desc_type = make_node (RECORD_TYPE);\n-  tree id_f1 = build_decl (BUILTINS_LOCATION, FIELD_DECL,\n-\t\t\t   get_identifier (\"brig_module\"), ptr_type_node);\n-  DECL_CHAIN (id_f1) = NULL_TREE;\n-  tree id_f2 = build_decl (BUILTINS_LOCATION, FIELD_DECL,\n-\t\t\t   get_identifier (\"kernel_count\"),\n-\t\t\t   unsigned_type_node);\n-\n-  DECL_CHAIN (id_f2) = id_f1;\n-  tree id_f3 = build_decl (BUILTINS_LOCATION, FIELD_DECL,\n-\t\t\t   get_identifier (\"hsa_kernel_infos\"),\n-\t\t\t   ptr_type_node);\n-  DECL_CHAIN (id_f3) = id_f2;\n-  tree id_f4 = build_decl (BUILTINS_LOCATION, FIELD_DECL,\n-\t\t\t   get_identifier (\"global_variable_count\"),\n-\t\t\t   unsigned_type_node);\n-  DECL_CHAIN (id_f4) = id_f3;\n-  tree id_f5 = build_decl (BUILTINS_LOCATION, FIELD_DECL,\n-\t\t\t   get_identifier (\"hsa_global_variable_infos\"),\n-\t\t\t   ptr_type_node);\n-  DECL_CHAIN (id_f5) = id_f4;\n-  finish_builtin_struct (hsa_image_desc_type, \"__hsa_image_desc\", id_f5,\n-\t\t\t NULL_TREE);\n-  TYPE_ARTIFICIAL (hsa_image_desc_type) = 1;\n-\n-  vec<constructor_elt, va_gc> *img_desc_vec = NULL;\n-  CONSTRUCTOR_APPEND_ELT (img_desc_vec, NULL_TREE,\n-\t\t\t  build_fold_addr_expr (brig_decl));\n-  CONSTRUCTOR_APPEND_ELT (img_desc_vec, NULL_TREE,\n-\t\t\t  build_int_cstu (unsigned_type_node, kernel_count));\n-  CONSTRUCTOR_APPEND_ELT (img_desc_vec, NULL_TREE,\n-\t\t\t  build1 (ADDR_EXPR,\n-\t\t\t\t  build_pointer_type (TREE_TYPE (kernels)),\n-\t\t\t\t  kernels));\n-  CONSTRUCTOR_APPEND_ELT (img_desc_vec, NULL_TREE,\n-\t\t\t  build_int_cstu (unsigned_type_node,\n-\t\t\t\t\t  global_variable_count));\n-  CONSTRUCTOR_APPEND_ELT (img_desc_vec, NULL_TREE,\n-\t\t\t  build1 (ADDR_EXPR,\n-\t\t\t\t  build_pointer_type (TREE_TYPE (global_vars)),\n-\t\t\t\t  global_vars));\n-\n-  tree img_desc_ctor = build_constructor (hsa_image_desc_type, img_desc_vec);\n-\n-  char tmp_name[64];\n-  ASM_GENERATE_INTERNAL_LABEL (tmp_name, \"__hsa_img_descriptor\", 1);\n-  tree hsa_img_descriptor = build_decl (UNKNOWN_LOCATION, VAR_DECL,\n-\t\t\t\t\tget_identifier (tmp_name),\n-\t\t\t\t\thsa_image_desc_type);\n-  TREE_STATIC (hsa_img_descriptor) = 1;\n-  TREE_READONLY (hsa_img_descriptor) = 1;\n-  TREE_PUBLIC (hsa_img_descriptor) = 0;\n-  DECL_ARTIFICIAL (hsa_img_descriptor) = 1;\n-  DECL_IGNORED_P (hsa_img_descriptor) = 1;\n-  DECL_EXTERNAL (hsa_img_descriptor) = 0;\n-  TREE_CONSTANT (hsa_img_descriptor) = 1;\n-  DECL_INITIAL (hsa_img_descriptor) = img_desc_ctor;\n-  varpool_node::finalize_decl (hsa_img_descriptor);\n-\n-  /* Construct the \"host_table\" libgomp expects.  */\n-  tree index_type = build_index_type (build_int_cst (integer_type_node, 4));\n-  tree libgomp_host_table_type = build_array_type (ptr_type_node, index_type);\n-  TYPE_ARTIFICIAL (libgomp_host_table_type) = 1;\n-  vec<constructor_elt, va_gc> *libgomp_host_table_vec = NULL;\n-  tree host_func_table_addr = build_fold_addr_expr (host_func_table);\n-  CONSTRUCTOR_APPEND_ELT (libgomp_host_table_vec, NULL_TREE,\n-\t\t\t  host_func_table_addr);\n-  offset_int func_table_size\n-    = wi::to_offset (TYPE_SIZE_UNIT (ptr_type_node)) * kernel_count;\n-  CONSTRUCTOR_APPEND_ELT (libgomp_host_table_vec, NULL_TREE,\n-\t\t\t  fold_build2 (POINTER_PLUS_EXPR,\n-\t\t\t\t       TREE_TYPE (host_func_table_addr),\n-\t\t\t\t       host_func_table_addr,\n-\t\t\t\t       build_int_cst (size_type_node,\n-\t\t\t\t\t\t      func_table_size.to_uhwi\n-\t\t\t\t\t\t      ())));\n-  CONSTRUCTOR_APPEND_ELT (libgomp_host_table_vec, NULL_TREE, null_pointer_node);\n-  CONSTRUCTOR_APPEND_ELT (libgomp_host_table_vec, NULL_TREE, null_pointer_node);\n-  tree libgomp_host_table_ctor = build_constructor (libgomp_host_table_type,\n-\t\t\t\t\t\t    libgomp_host_table_vec);\n-  ASM_GENERATE_INTERNAL_LABEL (tmp_name, \"__hsa_libgomp_host_table\", 1);\n-  tree hsa_libgomp_host_table = build_decl (UNKNOWN_LOCATION, VAR_DECL,\n-\t\t\t\t\t    get_identifier (tmp_name),\n-\t\t\t\t\t    libgomp_host_table_type);\n-\n-  TREE_STATIC (hsa_libgomp_host_table) = 1;\n-  TREE_READONLY (hsa_libgomp_host_table) = 1;\n-  TREE_PUBLIC (hsa_libgomp_host_table) = 0;\n-  DECL_ARTIFICIAL (hsa_libgomp_host_table) = 1;\n-  DECL_IGNORED_P (hsa_libgomp_host_table) = 1;\n-  DECL_EXTERNAL (hsa_libgomp_host_table) = 0;\n-  TREE_CONSTANT (hsa_libgomp_host_table) = 1;\n-  DECL_INITIAL (hsa_libgomp_host_table) = libgomp_host_table_ctor;\n-  varpool_node::finalize_decl (hsa_libgomp_host_table);\n-\n-  /* Generate an initializer with a call to the registration routine.  */\n-\n-  tree offload_register\n-    = builtin_decl_explicit (BUILT_IN_GOMP_OFFLOAD_REGISTER);\n-  gcc_checking_assert (offload_register);\n-\n-  tree *hsa_ctor_stmts = hsa_get_ctor_statements ();\n-  append_to_statement_list\n-    (build_call_expr (offload_register, 4,\n-\t\t      build_int_cstu (unsigned_type_node,\n-\t\t\t\t      GOMP_VERSION_PACK (GOMP_VERSION,\n-\t\t\t\t\t\t\t GOMP_VERSION_HSA)),\n-\t\t      build_fold_addr_expr (hsa_libgomp_host_table),\n-\t\t      build_int_cst (integer_type_node, GOMP_DEVICE_HSA),\n-\t\t      build_fold_addr_expr (hsa_img_descriptor)),\n-     hsa_ctor_stmts);\n-\n-  cgraph_build_static_cdtor ('I', *hsa_ctor_stmts, DEFAULT_INIT_PRIORITY);\n-\n-  tree offload_unregister\n-    = builtin_decl_explicit (BUILT_IN_GOMP_OFFLOAD_UNREGISTER);\n-  gcc_checking_assert (offload_unregister);\n-\n-  tree *hsa_dtor_stmts = hsa_get_dtor_statements ();\n-  append_to_statement_list\n-    (build_call_expr (offload_unregister, 4,\n-\t\t      build_int_cstu (unsigned_type_node,\n-\t\t\t\t      GOMP_VERSION_PACK (GOMP_VERSION,\n-\t\t\t\t\t\t\t GOMP_VERSION_HSA)),\n-\t\t      build_fold_addr_expr (hsa_libgomp_host_table),\n-\t\t      build_int_cst (integer_type_node, GOMP_DEVICE_HSA),\n-\t\t      build_fold_addr_expr (hsa_img_descriptor)),\n-     hsa_dtor_stmts);\n-  cgraph_build_static_cdtor ('D', *hsa_dtor_stmts, DEFAULT_INIT_PRIORITY);\n-}\n-\n-/* Emit the brig module we have compiled to a section in the final assembly and\n-   also create a compile unit static constructor that will register the brig\n-   module with libgomp.  */\n-\n-void\n-hsa_output_brig (void)\n-{\n-  section *saved_section;\n-\n-  if (!brig_initialized)\n-    return;\n-\n-  for (unsigned i = 0; i < function_call_linkage.length (); i++)\n-    {\n-      function_linkage_pair p = function_call_linkage[i];\n-\n-      BrigCodeOffset32_t *func_offset = function_offsets->get (p.function_decl);\n-      gcc_assert (*func_offset);\n-      BrigOperandCodeRef *code_ref\n-\t= (BrigOperandCodeRef *) (brig_operand.get_ptr_by_offset (p.offset));\n-      gcc_assert (code_ref->base.kind == BRIG_KIND_OPERAND_CODE_REF);\n-      code_ref->ref = lendian32 (*func_offset);\n-    }\n-\n-  /* Iterate all function declarations and if we meet a function that should\n-     have module linkage and we are unable to emit HSAIL for the function,\n-     then change the linkage to program linkage.  Doing so, we will emit\n-     a valid BRIG image.  */\n-  if (hsa_failed_functions != NULL && emitted_declarations != NULL)\n-    for (hash_map <tree, BrigDirectiveExecutable *>::iterator it\n-\t = emitted_declarations->begin ();\n-\t it != emitted_declarations->end ();\n-\t ++it)\n-      {\n-\tif (hsa_failed_functions->contains ((*it).first))\n-\t  (*it).second->linkage = BRIG_LINKAGE_PROGRAM;\n-      }\n-\n-  saved_section = in_section;\n-\n-  switch_to_section (get_section (BRIG_ELF_SECTION_NAME, SECTION_NOTYPE, NULL));\n-  char tmp_name[64];\n-  ASM_GENERATE_INTERNAL_LABEL (tmp_name, BRIG_LABEL_STRING, 1);\n-  ASM_OUTPUT_LABEL (asm_out_file, tmp_name);\n-  tree brig_id = get_identifier (tmp_name);\n-  tree brig_decl = build_decl (UNKNOWN_LOCATION, VAR_DECL, brig_id,\n-\t\t\t       char_type_node);\n-  SET_DECL_ASSEMBLER_NAME (brig_decl, brig_id);\n-  TREE_ADDRESSABLE (brig_decl) = 1;\n-  TREE_READONLY (brig_decl) = 1;\n-  DECL_ARTIFICIAL (brig_decl) = 1;\n-  DECL_IGNORED_P (brig_decl) = 1;\n-  TREE_STATIC (brig_decl) = 1;\n-  TREE_PUBLIC (brig_decl) = 0;\n-  TREE_USED (brig_decl) = 1;\n-  DECL_INITIAL (brig_decl) = brig_decl;\n-  TREE_ASM_WRITTEN (brig_decl) = 1;\n-\n-  BrigModuleHeader module_header;\n-  memcpy (&module_header.identification, \"HSA BRIG\",\n-\t  sizeof (module_header.identification));\n-  module_header.brigMajor = lendian32 (BRIG_VERSION_BRIG_MAJOR);\n-  module_header.brigMinor = lendian32 (BRIG_VERSION_BRIG_MINOR);\n-  uint64_t section_index[3];\n-\n-  int data_padding, code_padding, operand_padding;\n-  data_padding = HSA_SECTION_ALIGNMENT\n-    - brig_data.total_size % HSA_SECTION_ALIGNMENT;\n-  code_padding = HSA_SECTION_ALIGNMENT\n-    - brig_code.total_size % HSA_SECTION_ALIGNMENT;\n-  operand_padding = HSA_SECTION_ALIGNMENT\n-    - brig_operand.total_size % HSA_SECTION_ALIGNMENT;\n-\n-  uint64_t module_size = sizeof (module_header)\n-    + sizeof (section_index)\n-    + brig_data.total_size\n-    + data_padding\n-    + brig_code.total_size\n-    + code_padding\n-    + brig_operand.total_size\n-    + operand_padding;\n-  gcc_assert ((module_size % 16) == 0);\n-  module_header.byteCount = lendian64 (module_size);\n-  memset (&module_header.hash, 0, sizeof (module_header.hash));\n-  module_header.reserved = 0;\n-  module_header.sectionCount = lendian32 (3);\n-  module_header.sectionIndex = lendian64 (sizeof (module_header));\n-  assemble_string ((const char *) &module_header, sizeof (module_header));\n-  uint64_t off = sizeof (module_header) + sizeof (section_index);\n-  section_index[0] = lendian64 (off);\n-  off += brig_data.total_size + data_padding;\n-  section_index[1] = lendian64 (off);\n-  off += brig_code.total_size + code_padding;\n-  section_index[2] = lendian64 (off);\n-  assemble_string ((const char *) &section_index, sizeof (section_index));\n-\n-  char padding[HSA_SECTION_ALIGNMENT];\n-  memset (padding, 0, sizeof (padding));\n-\n-  brig_data.output ();\n-  assemble_string (padding, data_padding);\n-  brig_code.output ();\n-  assemble_string (padding, code_padding);\n-  brig_operand.output ();\n-  assemble_string (padding, operand_padding);\n-\n-  if (saved_section)\n-    switch_to_section (saved_section);\n-\n-  hsa_output_libgomp_mapping (brig_decl);\n-\n-  hsa_free_decl_kernel_mapping ();\n-  brig_release_data ();\n-  hsa_deinit_compilation_unit_data ();\n-\n-  delete emitted_declarations;\n-  emitted_declarations = NULL;\n-  delete function_offsets;\n-  function_offsets = NULL;\n-}"}, {"sha": "dc60e42c71b703ef0f01ae66c8e0b15b2938606c", "filename": "gcc/hsa-builtins.def", "status": "removed", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9623f61b142174b87760c81f78928dd14af7cbc6/gcc%2Fhsa-builtins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9623f61b142174b87760c81f78928dd14af7cbc6/gcc%2Fhsa-builtins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhsa-builtins.def?ref=9623f61b142174b87760c81f78928dd14af7cbc6", "patch": "@@ -1,39 +0,0 @@\n-/* This file contains the definitions and documentation for the\n-   Offloading and Multi Processing builtins used in the GNU compiler.\n-   Copyright (C) 2005-2020 Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-/* Before including this file, you should define a macro:\n-\n-     DEF_HSA_BUILTIN (ENUM, NAME, TYPE, ATTRS)\n-\n-   See builtins.def for details.  */\n-\n-/* The reason why they aren't in gcc/builtins.def is that the Fortran front end\n-   doesn't source those.  */\n-\n-DEF_HSA_BUILTIN (BUILT_IN_HSA_WORKGROUPID, \"hsa_workgroupid\",\n-\t  \t BT_FN_UINT_UINT, ATTR_CONST_NOTHROW_LEAF_LIST)\n-DEF_HSA_BUILTIN (BUILT_IN_HSA_WORKITEMID, \"hsa_workitemid\",\n-\t  \t BT_FN_UINT_UINT, ATTR_CONST_NOTHROW_LEAF_LIST)\n-DEF_HSA_BUILTIN (BUILT_IN_HSA_WORKITEMABSID, \"hsa_workitemabsid\",\n-\t  \t BT_FN_UINT_UINT, ATTR_CONST_NOTHROW_LEAF_LIST)\n-DEF_HSA_BUILTIN (BUILT_IN_HSA_GRIDSIZE, \"hsa_gridsize\",\n-\t\t BT_FN_UINT_UINT, ATTR_CONST_NOTHROW_LEAF_LIST)\n-DEF_HSA_BUILTIN (BUILT_IN_HSA_CURRENTWORKGROUPSIZE, \"hsa_currentworkgroupsize\",\n-\t\t BT_FN_UINT_UINT, ATTR_CONST_NOTHROW_LEAF_LIST)"}, {"sha": "4b0679137347ffc826f48daad165843818813663", "filename": "gcc/hsa-common.c", "status": "removed", "additions": 0, "deletions": 996, "changes": 996, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9623f61b142174b87760c81f78928dd14af7cbc6/gcc%2Fhsa-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9623f61b142174b87760c81f78928dd14af7cbc6/gcc%2Fhsa-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhsa-common.c?ref=9623f61b142174b87760c81f78928dd14af7cbc6", "patch": "@@ -1,996 +0,0 @@\n-/* Implementation of commonly needed HSAIL related functions and methods.\n-   Copyright (C) 2013-2020 Free Software Foundation, Inc.\n-   Contributed by Martin Jambor <mjambor@suse.cz> and\n-   Martin Liska <mliska@suse.cz>.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"is-a.h\"\n-#include \"hash-set.h\"\n-#include \"hash-map.h\"\n-#include \"vec.h\"\n-#include \"tree.h\"\n-#include \"dumpfile.h\"\n-#include \"gimple-pretty-print.h\"\n-#include \"diagnostic-core.h\"\n-#include \"alloc-pool.h\"\n-#include \"cgraph.h\"\n-#include \"print-tree.h\"\n-#include \"stringpool.h\"\n-#include \"symbol-summary.h\"\n-#include \"hsa-common.h\"\n-#include \"internal-fn.h\"\n-#include \"ctype.h\"\n-#include \"builtins.h\"\n-#include \"stringpool.h\"\n-#include \"attribs.h\"\n-\n-/* Structure containing intermediate HSA representation of the generated\n-   function.  */\n-class hsa_function_representation *hsa_cfun;\n-\n-/* Element of the mapping vector between a host decl and an HSA kernel.  */\n-\n-struct GTY(()) hsa_decl_kernel_map_element\n-{\n-  /* The decl of the host function.  */\n-  tree decl;\n-  /* Name of the HSA kernel in BRIG.  */\n-  char * GTY((skip)) name;\n-  /* Size of OMP data, if the kernel contains a kernel dispatch.  */\n-  unsigned omp_data_size;\n-  /* True if the function is gridified kernel.  */\n-  bool gridified_kernel_p;\n-};\n-\n-/* Mapping between decls and corresponding HSA kernels in this compilation\n-   unit.  */\n-\n-static GTY (()) vec<hsa_decl_kernel_map_element, va_gc>\n-  *hsa_decl_kernel_mapping;\n-\n-/* Mapping between decls and corresponding HSA kernels\n-   called by the function.  */\n-hash_map <tree, vec <const char *> *> *hsa_decl_kernel_dependencies;\n-\n-/* Hash function to lookup a symbol for a decl.  */\n-hash_table <hsa_noop_symbol_hasher> *hsa_global_variable_symbols;\n-\n-/* HSA summaries.  */\n-hsa_summary_t *hsa_summaries = NULL;\n-\n-/* HSA number of threads.  */\n-hsa_symbol *hsa_num_threads = NULL;\n-\n-/* HSA function that cannot be expanded to HSAIL.  */\n-hash_set <tree> *hsa_failed_functions = NULL;\n-\n-/* True if compilation unit-wide data are already allocated and initialized.  */\n-static bool compilation_unit_data_initialized;\n-\n-/* Return true if FNDECL represents an HSA-callable function.  */\n-\n-bool\n-hsa_callable_function_p (tree fndecl)\n-{\n-  return (lookup_attribute (\"omp declare target\", DECL_ATTRIBUTES (fndecl))\n-\t  && !lookup_attribute (\"oacc function\", DECL_ATTRIBUTES (fndecl)));\n-}\n-\n-/* Allocate HSA structures that are used when dealing with different\n-   functions.  */\n-\n-void\n-hsa_init_compilation_unit_data (void)\n-{\n-  if (compilation_unit_data_initialized)\n-    return;\n-\n-  compilation_unit_data_initialized = true;\n-\n-  hsa_global_variable_symbols = new hash_table <hsa_noop_symbol_hasher> (8);\n-  hsa_failed_functions = new hash_set <tree> ();\n-  hsa_emitted_internal_decls = new hash_table <hsa_internal_fn_hasher> (2);\n-}\n-\n-/* Free data structures that are used when dealing with different\n-   functions.  */\n-\n-void\n-hsa_deinit_compilation_unit_data (void)\n-{\n-  gcc_assert (compilation_unit_data_initialized);\n-\n-  delete hsa_failed_functions;\n-  delete hsa_emitted_internal_decls;\n-\n-  for (hash_table <hsa_noop_symbol_hasher>::iterator it\n-       = hsa_global_variable_symbols->begin ();\n-       it != hsa_global_variable_symbols->end ();\n-       ++it)\n-    {\n-      hsa_symbol *sym = *it;\n-      delete sym;\n-    }\n-\n-  delete hsa_global_variable_symbols;\n-\n-  if (hsa_num_threads)\n-    {\n-      delete hsa_num_threads;\n-      hsa_num_threads = NULL;\n-    }\n-\n-  compilation_unit_data_initialized = false;\n-}\n-\n-/* Return true if we are generating large HSA machine model.  */\n-\n-bool\n-hsa_machine_large_p (void)\n-{\n-  /* FIXME: I suppose this is technically wrong but should work for me now.  */\n-  return (GET_MODE_BITSIZE (Pmode) == 64);\n-}\n-\n-/* Return the HSA profile we are using.  */\n-\n-bool\n-hsa_full_profile_p (void)\n-{\n-  return true;\n-}\n-\n-/* Return true if a register in operand number OPNUM of instruction\n-   is an output.  False if it is an input.  */\n-\n-bool\n-hsa_insn_basic::op_output_p (unsigned opnum)\n-{\n-  switch (m_opcode)\n-    {\n-    case HSA_OPCODE_PHI:\n-    case BRIG_OPCODE_CBR:\n-    case BRIG_OPCODE_SBR:\n-    case BRIG_OPCODE_ST:\n-    case BRIG_OPCODE_SIGNALNORET:\n-    case BRIG_OPCODE_DEBUGTRAP:\n-      /* FIXME: There are probably missing cases here, double check.  */\n-      return false;\n-    case BRIG_OPCODE_EXPAND:\n-      /* Example: expand_v4_b32_b128 (dest0, dest1, dest2, dest3), src0.  */\n-      return opnum < operand_count () - 1;\n-    default:\n-     return opnum == 0;\n-    }\n-}\n-\n-/* Return true if OPCODE is an floating-point bit instruction opcode.  */\n-\n-bool\n-hsa_opcode_floating_bit_insn_p (BrigOpcode16_t opcode)\n-{\n-  switch (opcode)\n-    {\n-    case BRIG_OPCODE_NEG:\n-    case BRIG_OPCODE_ABS:\n-    case BRIG_OPCODE_CLASS:\n-    case BRIG_OPCODE_COPYSIGN:\n-      return true;\n-    default:\n-      return false;\n-    }\n-}\n-\n-/* Return the number of destination operands for this INSN.  */\n-\n-unsigned\n-hsa_insn_basic::input_count ()\n-{\n-  switch (m_opcode)\n-    {\n-      default:\n-\treturn 1;\n-\n-      case BRIG_OPCODE_NOP:\n-\treturn 0;\n-\n-      case BRIG_OPCODE_EXPAND:\n-\treturn 2;\n-\n-      case BRIG_OPCODE_LD:\n-\t/* ld_v[234] not yet handled.  */\n-\treturn 1;\n-\n-      case BRIG_OPCODE_ST:\n-\treturn 0;\n-\n-      case BRIG_OPCODE_ATOMICNORET:\n-\treturn 0;\n-\n-      case BRIG_OPCODE_SIGNAL:\n-\treturn 1;\n-\n-      case BRIG_OPCODE_SIGNALNORET:\n-\treturn 0;\n-\n-      case BRIG_OPCODE_MEMFENCE:\n-\treturn 0;\n-\n-      case BRIG_OPCODE_RDIMAGE:\n-      case BRIG_OPCODE_LDIMAGE:\n-      case BRIG_OPCODE_STIMAGE:\n-      case BRIG_OPCODE_QUERYIMAGE:\n-      case BRIG_OPCODE_QUERYSAMPLER:\n-\tsorry (\"HSA image ops not handled\");\n-\treturn 0;\n-\n-      case BRIG_OPCODE_CBR:\n-      case BRIG_OPCODE_BR:\n-\treturn 0;\n-\n-      case BRIG_OPCODE_SBR:\n-\treturn 0; /* ??? */\n-\n-      case BRIG_OPCODE_WAVEBARRIER:\n-\treturn 0; /* ??? */\n-\n-      case BRIG_OPCODE_BARRIER:\n-      case BRIG_OPCODE_ARRIVEFBAR:\n-      case BRIG_OPCODE_INITFBAR:\n-      case BRIG_OPCODE_JOINFBAR:\n-      case BRIG_OPCODE_LEAVEFBAR:\n-      case BRIG_OPCODE_RELEASEFBAR:\n-      case BRIG_OPCODE_WAITFBAR:\n-\treturn 0;\n-\n-      case BRIG_OPCODE_LDF:\n-\treturn 1;\n-\n-      case BRIG_OPCODE_ACTIVELANECOUNT:\n-      case BRIG_OPCODE_ACTIVELANEID:\n-      case BRIG_OPCODE_ACTIVELANEMASK:\n-      case BRIG_OPCODE_ACTIVELANEPERMUTE:\n-\treturn 1; /* ??? */\n-\n-      case BRIG_OPCODE_CALL:\n-      case BRIG_OPCODE_SCALL:\n-      case BRIG_OPCODE_ICALL:\n-\treturn 0;\n-\n-      case BRIG_OPCODE_RET:\n-\treturn 0;\n-\n-      case BRIG_OPCODE_ALLOCA:\n-\treturn 1;\n-\n-      case BRIG_OPCODE_CLEARDETECTEXCEPT:\n-\treturn 0;\n-\n-      case BRIG_OPCODE_SETDETECTEXCEPT:\n-\treturn 0;\n-\n-      case BRIG_OPCODE_PACKETCOMPLETIONSIG:\n-      case BRIG_OPCODE_PACKETID:\n-      case BRIG_OPCODE_CASQUEUEWRITEINDEX:\n-      case BRIG_OPCODE_LDQUEUEREADINDEX:\n-      case BRIG_OPCODE_LDQUEUEWRITEINDEX:\n-      case BRIG_OPCODE_STQUEUEREADINDEX:\n-      case BRIG_OPCODE_STQUEUEWRITEINDEX:\n-\treturn 1; /* ??? */\n-\n-      case BRIG_OPCODE_ADDQUEUEWRITEINDEX:\n-\treturn 1;\n-\n-      case BRIG_OPCODE_DEBUGTRAP:\n-\treturn 0;\n-\n-      case BRIG_OPCODE_GROUPBASEPTR:\n-      case BRIG_OPCODE_KERNARGBASEPTR:\n-\treturn 1; /* ??? */\n-\n-      case HSA_OPCODE_ARG_BLOCK:\n-\treturn 0;\n-\n-      case BRIG_KIND_DIRECTIVE_COMMENT:\n-\treturn 0;\n-    }\n-}\n-\n-/* Return the number of source operands for this INSN.  */\n-\n-unsigned\n-hsa_insn_basic::num_used_ops ()\n-{\n-  gcc_checking_assert (input_count () <= operand_count ());\n-\n-  return operand_count () - input_count ();\n-}\n-\n-/* Set alignment to VALUE.  */\n-\n-void\n-hsa_insn_mem::set_align (BrigAlignment8_t value)\n-{\n-  /* TODO: Perhaps remove this dump later on:  */\n-  if (dump_file && (dump_flags & TDF_DETAILS) && value < m_align)\n-    {\n-      fprintf (dump_file, \"Decreasing alignment to %u in instruction \", value);\n-      dump_hsa_insn (dump_file, this);\n-    }\n-  m_align = value;\n-}\n-\n-/* Return size of HSA type T in bits.  */\n-\n-unsigned\n-hsa_type_bit_size (BrigType16_t t)\n-{\n-  switch (t)\n-    {\n-    case BRIG_TYPE_B1:\n-      return 1;\n-\n-    case BRIG_TYPE_U8:\n-    case BRIG_TYPE_S8:\n-    case BRIG_TYPE_B8:\n-      return 8;\n-\n-    case BRIG_TYPE_U16:\n-    case BRIG_TYPE_S16:\n-    case BRIG_TYPE_B16:\n-    case BRIG_TYPE_F16:\n-      return 16;\n-\n-    case BRIG_TYPE_U32:\n-    case BRIG_TYPE_S32:\n-    case BRIG_TYPE_B32:\n-    case BRIG_TYPE_F32:\n-    case BRIG_TYPE_U8X4:\n-    case BRIG_TYPE_U16X2:\n-    case BRIG_TYPE_S8X4:\n-    case BRIG_TYPE_S16X2:\n-    case BRIG_TYPE_F16X2:\n-      return 32;\n-\n-    case BRIG_TYPE_U64:\n-    case BRIG_TYPE_S64:\n-    case BRIG_TYPE_F64:\n-    case BRIG_TYPE_B64:\n-    case BRIG_TYPE_U8X8:\n-    case BRIG_TYPE_U16X4:\n-    case BRIG_TYPE_U32X2:\n-    case BRIG_TYPE_S8X8:\n-    case BRIG_TYPE_S16X4:\n-    case BRIG_TYPE_S32X2:\n-    case BRIG_TYPE_F16X4:\n-    case BRIG_TYPE_F32X2:\n-\n-      return 64;\n-\n-    case BRIG_TYPE_B128:\n-    case BRIG_TYPE_U8X16:\n-    case BRIG_TYPE_U16X8:\n-    case BRIG_TYPE_U32X4:\n-    case BRIG_TYPE_U64X2:\n-    case BRIG_TYPE_S8X16:\n-    case BRIG_TYPE_S16X8:\n-    case BRIG_TYPE_S32X4:\n-    case BRIG_TYPE_S64X2:\n-    case BRIG_TYPE_F16X8:\n-    case BRIG_TYPE_F32X4:\n-    case BRIG_TYPE_F64X2:\n-      return 128;\n-\n-    default:\n-      gcc_assert (hsa_seen_error ());\n-      return t;\n-    }\n-}\n-\n-/* Return BRIG bit-type with BITSIZE length.  */\n-\n-BrigType16_t\n-hsa_bittype_for_bitsize (unsigned bitsize)\n-{\n-  switch (bitsize)\n-    {\n-    case 1:\n-      return BRIG_TYPE_B1;\n-    case 8:\n-      return BRIG_TYPE_B8;\n-    case 16:\n-      return BRIG_TYPE_B16;\n-    case 32:\n-      return BRIG_TYPE_B32;\n-    case 64:\n-      return BRIG_TYPE_B64;\n-    case 128:\n-      return BRIG_TYPE_B128;\n-    default:\n-      gcc_unreachable ();\n-    }\n-}\n-\n-/* Return BRIG unsigned int type with BITSIZE length.  */\n-\n-BrigType16_t\n-hsa_uint_for_bitsize (unsigned bitsize)\n-{\n-  switch (bitsize)\n-    {\n-    case 8:\n-      return BRIG_TYPE_U8;\n-    case 16:\n-      return BRIG_TYPE_U16;\n-    case 32:\n-      return BRIG_TYPE_U32;\n-    case 64:\n-      return BRIG_TYPE_U64;\n-    default:\n-      gcc_unreachable ();\n-    }\n-}\n-\n-/* Return BRIG float type with BITSIZE length.  */\n-\n-BrigType16_t\n-hsa_float_for_bitsize (unsigned bitsize)\n-{\n-  switch (bitsize)\n-    {\n-    case 16:\n-      return BRIG_TYPE_F16;\n-    case 32:\n-      return BRIG_TYPE_F32;\n-    case 64:\n-      return BRIG_TYPE_F64;\n-    default:\n-      gcc_unreachable ();\n-    }\n-}\n-\n-/* Return HSA bit-type with the same size as the type T.  */\n-\n-BrigType16_t\n-hsa_bittype_for_type (BrigType16_t t)\n-{\n-  return hsa_bittype_for_bitsize (hsa_type_bit_size (t));\n-}\n-\n-/* Return HSA unsigned integer type with the same size as the type T.  */\n-\n-BrigType16_t\n-hsa_unsigned_type_for_type (BrigType16_t t)\n-{\n-  return hsa_uint_for_bitsize (hsa_type_bit_size (t));\n-}\n-\n-/* Return true if TYPE is a packed HSA type.  */\n-\n-bool\n-hsa_type_packed_p (BrigType16_t type)\n-{\n-  return (type & BRIG_TYPE_PACK_MASK) != BRIG_TYPE_PACK_NONE;\n-}\n-\n-/* Return true if and only if TYPE is a floating point number type.  */\n-\n-bool\n-hsa_type_float_p (BrigType16_t type)\n-{\n-  switch (type & BRIG_TYPE_BASE_MASK)\n-    {\n-    case BRIG_TYPE_F16:\n-    case BRIG_TYPE_F32:\n-    case BRIG_TYPE_F64:\n-      return true;\n-    default:\n-      return false;\n-    }\n-}\n-\n-/* Return true if and only if TYPE is an integer number type.  */\n-\n-bool\n-hsa_type_integer_p (BrigType16_t type)\n-{\n-  switch (type & BRIG_TYPE_BASE_MASK)\n-    {\n-    case BRIG_TYPE_U8:\n-    case BRIG_TYPE_U16:\n-    case BRIG_TYPE_U32:\n-    case BRIG_TYPE_U64:\n-    case BRIG_TYPE_S8:\n-    case BRIG_TYPE_S16:\n-    case BRIG_TYPE_S32:\n-    case BRIG_TYPE_S64:\n-      return true;\n-    default:\n-      return false;\n-    }\n-}\n-\n-/* Return true if and only if TYPE is an bit-type.  */\n-\n-bool\n-hsa_btype_p (BrigType16_t type)\n-{\n-  switch (type & BRIG_TYPE_BASE_MASK)\n-    {\n-    case BRIG_TYPE_B8:\n-    case BRIG_TYPE_B16:\n-    case BRIG_TYPE_B32:\n-    case BRIG_TYPE_B64:\n-    case BRIG_TYPE_B128:\n-      return true;\n-    default:\n-      return false;\n-    }\n-}\n-\n-\n-/* Return HSA alignment encoding alignment to N bits.  */\n-\n-BrigAlignment8_t\n-hsa_alignment_encoding (unsigned n)\n-{\n-  gcc_assert (n >= 8 && !(n & (n - 1)));\n-  if (n >= 256)\n-    return BRIG_ALIGNMENT_32;\n-\n-  switch (n)\n-    {\n-    case 8:\n-      return BRIG_ALIGNMENT_1;\n-    case 16:\n-      return BRIG_ALIGNMENT_2;\n-    case 32:\n-      return BRIG_ALIGNMENT_4;\n-    case 64:\n-      return BRIG_ALIGNMENT_8;\n-    case 128:\n-      return BRIG_ALIGNMENT_16;\n-    default:\n-      gcc_unreachable ();\n-    }\n-}\n-\n-/* Return HSA alignment encoding alignment of T got\n-   by get_object_alignment.  */\n-\n-BrigAlignment8_t\n-hsa_object_alignment (tree t)\n-{\n-  return hsa_alignment_encoding (get_object_alignment (t));\n-}\n-\n-/* Return byte alignment for given BrigAlignment8_t value.  */\n-\n-unsigned\n-hsa_byte_alignment (BrigAlignment8_t alignment)\n-{\n-  gcc_assert (alignment != BRIG_ALIGNMENT_NONE);\n-\n-  return 1 << (alignment - 1);\n-}\n-\n-/* Return natural alignment of HSA TYPE.  */\n-\n-BrigAlignment8_t\n-hsa_natural_alignment (BrigType16_t type)\n-{\n-  return hsa_alignment_encoding (hsa_type_bit_size (type & ~BRIG_TYPE_ARRAY));\n-}\n-\n-/* Call the correct destructor of a HSA instruction.  */\n-\n-void\n-hsa_destroy_insn (hsa_insn_basic *insn)\n-{\n-  if (hsa_insn_phi *phi = dyn_cast <hsa_insn_phi *> (insn))\n-    phi->~hsa_insn_phi ();\n-  else if (hsa_insn_cbr *br = dyn_cast <hsa_insn_cbr *> (insn))\n-    br->~hsa_insn_cbr ();\n-  else if (hsa_insn_cmp *cmp = dyn_cast <hsa_insn_cmp *> (insn))\n-    cmp->~hsa_insn_cmp ();\n-  else if (hsa_insn_mem *mem = dyn_cast <hsa_insn_mem *> (insn))\n-    mem->~hsa_insn_mem ();\n-  else if (hsa_insn_atomic *atomic = dyn_cast <hsa_insn_atomic *> (insn))\n-    atomic->~hsa_insn_atomic ();\n-  else if (hsa_insn_seg *seg = dyn_cast <hsa_insn_seg *> (insn))\n-    seg->~hsa_insn_seg ();\n-  else if (hsa_insn_call *call = dyn_cast <hsa_insn_call *> (insn))\n-    call->~hsa_insn_call ();\n-  else if (hsa_insn_arg_block *block = dyn_cast <hsa_insn_arg_block *> (insn))\n-    block->~hsa_insn_arg_block ();\n-  else if (hsa_insn_sbr *sbr = dyn_cast <hsa_insn_sbr *> (insn))\n-    sbr->~hsa_insn_sbr ();\n-  else if (hsa_insn_br *br = dyn_cast <hsa_insn_br *> (insn))\n-    br->~hsa_insn_br ();\n-  else if (hsa_insn_comment *comment = dyn_cast <hsa_insn_comment *> (insn))\n-    comment->~hsa_insn_comment ();\n-  else\n-    insn->~hsa_insn_basic ();\n-}\n-\n-/* Call the correct destructor of a HSA operand.  */\n-\n-void\n-hsa_destroy_operand (hsa_op_base *op)\n-{\n-  if (hsa_op_code_list *list = dyn_cast <hsa_op_code_list *> (op))\n-    list->~hsa_op_code_list ();\n-  else if (hsa_op_operand_list *list = dyn_cast <hsa_op_operand_list *> (op))\n-    list->~hsa_op_operand_list ();\n-  else if (hsa_op_reg *reg = dyn_cast <hsa_op_reg *> (op))\n-    reg->~hsa_op_reg ();\n-  else if (hsa_op_immed *immed = dyn_cast <hsa_op_immed *> (op))\n-    immed->~hsa_op_immed ();\n-  else\n-    op->~hsa_op_base ();\n-}\n-\n-/* Create a mapping between the original function DECL and kernel name NAME.  */\n-\n-void\n-hsa_add_kern_decl_mapping (tree decl, char *name, unsigned omp_data_size,\n-\t\t\t   bool gridified_kernel_p)\n-{\n-  hsa_decl_kernel_map_element dkm;\n-  dkm.decl = decl;\n-  dkm.name = name;\n-  dkm.omp_data_size = omp_data_size;\n-  dkm.gridified_kernel_p = gridified_kernel_p;\n-  vec_safe_push (hsa_decl_kernel_mapping, dkm);\n-}\n-\n-/* Return the number of kernel decl name mappings.  */\n-\n-unsigned\n-hsa_get_number_decl_kernel_mappings (void)\n-{\n-  return vec_safe_length (hsa_decl_kernel_mapping);\n-}\n-\n-/* Return the decl in the Ith kernel decl name mapping.  */\n-\n-tree\n-hsa_get_decl_kernel_mapping_decl (unsigned i)\n-{\n-  return (*hsa_decl_kernel_mapping)[i].decl;\n-}\n-\n-/* Return the name in the Ith kernel decl name mapping.  */\n-\n-char *\n-hsa_get_decl_kernel_mapping_name (unsigned i)\n-{\n-  return (*hsa_decl_kernel_mapping)[i].name;\n-}\n-\n-/* Return maximum OMP size for kernel decl name mapping.  */\n-\n-unsigned\n-hsa_get_decl_kernel_mapping_omp_size (unsigned i)\n-{\n-  return (*hsa_decl_kernel_mapping)[i].omp_data_size;\n-}\n-\n-/* Return if the function is gridified kernel in decl name mapping.  */\n-\n-bool\n-hsa_get_decl_kernel_mapping_gridified (unsigned i)\n-{\n-  return (*hsa_decl_kernel_mapping)[i].gridified_kernel_p;\n-}\n-\n-/* Free the mapping between original decls and kernel names.  */\n-\n-void\n-hsa_free_decl_kernel_mapping (void)\n-{\n-  if (hsa_decl_kernel_mapping == NULL)\n-    return;\n-\n-  for (unsigned i = 0; i < hsa_decl_kernel_mapping->length (); ++i)\n-    free ((*hsa_decl_kernel_mapping)[i].name);\n-  ggc_free (hsa_decl_kernel_mapping);\n-}\n-\n-/* Add new kernel dependency.  */\n-\n-void\n-hsa_add_kernel_dependency (tree caller, const char *called_function)\n-{\n-  if (hsa_decl_kernel_dependencies == NULL)\n-    hsa_decl_kernel_dependencies = new hash_map<tree, vec<const char *> *> ();\n-\n-  vec <const char *> *s = NULL;\n-  vec <const char *> **slot = hsa_decl_kernel_dependencies->get (caller);\n-  if (slot == NULL)\n-    {\n-      s = new vec <const char *> ();\n-      hsa_decl_kernel_dependencies->put (caller, s);\n-    }\n-  else\n-    s = *slot;\n-\n-  s->safe_push (called_function);\n-}\n-\n-/* Expansion to HSA needs a few gc roots to hold types, constructors etc.  In\n-   order to minimize the number of GTY roots, we'll root them all in the\n-   following array.  The individual elements should only be accessed by the\n-   very simple getters (of a pointer-to-tree) below.  */\n-\n-static GTY(()) tree hsa_tree_gt_roots[3];\n-\n-tree *\n-hsa_get_ctor_statements (void)\n-{\n-  return &hsa_tree_gt_roots[0];\n-}\n-\n-tree *\n-hsa_get_dtor_statements (void)\n-{\n-  return &hsa_tree_gt_roots[1];\n-}\n-\n-tree *\n-hsa_get_kernel_dispatch_type (void)\n-{\n-  return &hsa_tree_gt_roots[2];\n-}\n-\n-/* Modify the name P in-place so that it is a valid HSA identifier.  */\n-\n-void\n-hsa_sanitize_name (char *p)\n-{\n-  for (; *p; p++)\n-    if (*p == '.' || *p == '-')\n-      *p = '_';\n-}\n-\n-/* Clone the name P, set trailing ampersand and sanitize the name.  */\n-\n-char *\n-hsa_brig_function_name (const char *p)\n-{\n-  unsigned len = strlen (p);\n-  char *buf = XNEWVEC (char, len + 2);\n-\n-  buf[0] = '&';\n-  buf[len + 1] = '\\0';\n-  memcpy (buf + 1, p, len);\n-\n-  hsa_sanitize_name (buf);\n-  return buf;\n-}\n-\n-/* Add a flatten attribute and disable vectorization for gpu implementation\n-   function decl GDECL.  */\n-\n-void hsa_summary_t::process_gpu_implementation_attributes (tree gdecl)\n-{\n-  DECL_ATTRIBUTES (gdecl)\n-    = tree_cons (get_identifier (\"flatten\"), NULL_TREE,\n-\t\t DECL_ATTRIBUTES (gdecl));\n-\n-  tree fn_opts = DECL_FUNCTION_SPECIFIC_OPTIMIZATION (gdecl);\n-  if (fn_opts == NULL_TREE)\n-    fn_opts = optimization_default_node;\n-  fn_opts = copy_node (fn_opts);\n-  TREE_OPTIMIZATION (fn_opts)->x_flag_tree_loop_vectorize = false;\n-  TREE_OPTIMIZATION (fn_opts)->x_flag_tree_slp_vectorize = false;\n-  DECL_FUNCTION_SPECIFIC_OPTIMIZATION (gdecl) = fn_opts;\n-}\n-\n-void\n-hsa_summary_t::link_functions (cgraph_node *gpu, cgraph_node *host,\n-\t\t\t       hsa_function_kind kind, bool gridified_kernel_p)\n-{\n-  hsa_function_summary *gpu_summary = get_create (gpu);\n-  hsa_function_summary *host_summary = get_create (host);\n-\n-  gpu_summary->m_kind = kind;\n-  host_summary->m_kind = kind;\n-\n-  gpu_summary->m_gpu_implementation_p = true;\n-  host_summary->m_gpu_implementation_p = false;\n-\n-  gpu_summary->m_gridified_kernel_p = gridified_kernel_p;\n-  host_summary->m_gridified_kernel_p = gridified_kernel_p;\n-\n-  gpu_summary->m_bound_function = host;\n-  host_summary->m_bound_function = gpu;\n-\n-  process_gpu_implementation_attributes (gpu->decl);\n-\n-  /* Create reference between a kernel and a corresponding host implementation\n-     to quarantee LTO streaming to a same LTRANS.  */\n-  if (kind == HSA_KERNEL)\n-    gpu->create_reference (host, IPA_REF_ADDR);\n-}\n-\n-/* Add a HOST function to HSA summaries.  */\n-\n-void\n-hsa_register_kernel (cgraph_node *host)\n-{\n-  if (hsa_summaries == NULL)\n-    hsa_summaries = new hsa_summary_t (symtab);\n-  hsa_function_summary *s = hsa_summaries->get_create (host);\n-  s->m_kind = HSA_KERNEL;\n-}\n-\n-/* Add a pair of functions to HSA summaries.  GPU is an HSA implementation of\n-   a HOST function.  */\n-\n-void\n-hsa_register_kernel (cgraph_node *gpu, cgraph_node *host)\n-{\n-  if (hsa_summaries == NULL)\n-    hsa_summaries = new hsa_summary_t (symtab);\n-  hsa_summaries->link_functions (gpu, host, HSA_KERNEL, true);\n-}\n-\n-/* Return true if expansion of the current HSA function has already failed.  */\n-\n-bool\n-hsa_seen_error (void)\n-{\n-  return hsa_cfun->m_seen_error;\n-}\n-\n-/* Mark current HSA function as failed.  */\n-\n-void\n-hsa_fail_cfun (void)\n-{\n-  hsa_failed_functions->add (hsa_cfun->m_decl);\n-  hsa_cfun->m_seen_error = true;\n-}\n-\n-char *\n-hsa_internal_fn::name ()\n-{\n-  char *name = xstrdup (internal_fn_name (m_fn));\n-  for (char *ptr = name; *ptr; ptr++)\n-    *ptr = TOLOWER (*ptr);\n-\n-  const char *suffix = NULL;\n-  if (m_type_bit_size == 32)\n-    suffix = \"f\";\n-\n-  if (suffix)\n-    {\n-      char *name2 = concat (name, suffix, NULL);\n-      free (name);\n-      name = name2;\n-    }\n-\n-  hsa_sanitize_name (name);\n-  return name;\n-}\n-\n-unsigned\n-hsa_internal_fn::get_arity ()\n-{\n-  switch (m_fn)\n-    {\n-    case IFN_ACOS:\n-    case IFN_ASIN:\n-    case IFN_ATAN:\n-    case IFN_COS:\n-    case IFN_EXP:\n-    case IFN_EXP10:\n-    case IFN_EXP2:\n-    case IFN_EXPM1:\n-    case IFN_LOG:\n-    case IFN_LOG10:\n-    case IFN_LOG1P:\n-    case IFN_LOG2:\n-    case IFN_LOGB:\n-    case IFN_SIGNIFICAND:\n-    case IFN_SIN:\n-    case IFN_SQRT:\n-    case IFN_TAN:\n-    case IFN_CEIL:\n-    case IFN_FLOOR:\n-    case IFN_NEARBYINT:\n-    case IFN_RINT:\n-    case IFN_ROUND:\n-    case IFN_TRUNC:\n-      return 1;\n-    case IFN_ATAN2:\n-    case IFN_COPYSIGN:\n-    case IFN_FMOD:\n-    case IFN_POW:\n-    case IFN_REMAINDER:\n-    case IFN_SCALB:\n-    case IFN_LDEXP:\n-      return 2;\n-    case IFN_CLRSB:\n-    case IFN_CLZ:\n-    case IFN_CTZ:\n-    case IFN_FFS:\n-    case IFN_PARITY:\n-    case IFN_POPCOUNT:\n-    default:\n-      /* As we produce sorry message for unknown internal functions,\n-\t reaching this label is definitely a bug.  */\n-      gcc_unreachable ();\n-    }\n-}\n-\n-BrigType16_t\n-hsa_internal_fn::get_argument_type (int n)\n-{\n-  switch (m_fn)\n-    {\n-    case IFN_ACOS:\n-    case IFN_ASIN:\n-    case IFN_ATAN:\n-    case IFN_COS:\n-    case IFN_EXP:\n-    case IFN_EXP10:\n-    case IFN_EXP2:\n-    case IFN_EXPM1:\n-    case IFN_LOG:\n-    case IFN_LOG10:\n-    case IFN_LOG1P:\n-    case IFN_LOG2:\n-    case IFN_LOGB:\n-    case IFN_SIGNIFICAND:\n-    case IFN_SIN:\n-    case IFN_SQRT:\n-    case IFN_TAN:\n-    case IFN_CEIL:\n-    case IFN_FLOOR:\n-    case IFN_NEARBYINT:\n-    case IFN_RINT:\n-    case IFN_ROUND:\n-    case IFN_TRUNC:\n-    case IFN_ATAN2:\n-    case IFN_COPYSIGN:\n-    case IFN_FMOD:\n-    case IFN_POW:\n-    case IFN_REMAINDER:\n-    case IFN_SCALB:\n-      return hsa_float_for_bitsize (m_type_bit_size);\n-    case IFN_LDEXP:\n-      {\n-\tif (n == -1 || n == 0)\n-\t  return hsa_float_for_bitsize (m_type_bit_size);\n-\telse\n-\t  return BRIG_TYPE_S32;\n-      }\n-    default:\n-      /* As we produce sorry message for unknown internal functions,\n-\t reaching this label is definitely a bug.  */\n-      gcc_unreachable ();\n-    }\n-}\n-\n-#include \"gt-hsa-common.h\""}, {"sha": "ffeaaba454d140c80dccf82b9acdc62683292082", "filename": "gcc/hsa-common.h", "status": "removed", "additions": 0, "deletions": 1419, "changes": 1419, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9623f61b142174b87760c81f78928dd14af7cbc6/gcc%2Fhsa-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9623f61b142174b87760c81f78928dd14af7cbc6/gcc%2Fhsa-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhsa-common.h?ref=9623f61b142174b87760c81f78928dd14af7cbc6", "patch": "@@ -1,1419 +0,0 @@\n-/* HSAIL and BRIG related macros and definitions.\n-   Copyright (C) 2013-2020 Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#ifndef HSA_H\n-#define HSA_H\n-\n-#include \"hsa-brig-format.h\"\n-#include \"is-a.h\"\n-#include \"predict.h\"\n-#include \"tree.h\"\n-#include \"vec.h\"\n-#include \"hash-table.h\"\n-#include \"basic-block.h\"\n-#include \"bitmap.h\"\n-\n-\n-/* Return true if the compiler should produce HSAIL.  */\n-\n-static inline bool\n-hsa_gen_requested_p (void)\n-{\n-#ifndef ENABLE_HSA\n-  return false;\n-#endif\n-  return !flag_disable_hsa;\n-}\n-\n-/* Standard warning message if we failed to generate HSAIL for a function.  */\n-\n-#define HSA_SORRY_MSG \"could not emit HSAIL for the function\"\n-\n-class hsa_op_immed;\n-class hsa_op_cst_list;\n-class hsa_insn_basic;\n-class hsa_op_address;\n-class hsa_op_reg;\n-class hsa_bb;\n-\n-/* Class representing an input argument, output argument (result) or a\n-   variable, that will eventually end up being a symbol directive.  */\n-\n-class hsa_symbol\n-{\n-public:\n-  /* Constructor.  */\n-  hsa_symbol (BrigType16_t type, BrigSegment8_t segment,\n-\t      BrigLinkage8_t linkage, bool global_scope_p = false,\n-\t      BrigAllocation allocation = BRIG_ALLOCATION_AUTOMATIC,\n-\t      BrigAlignment8_t align = BRIG_ALIGNMENT_8);\n-\n-  /* Return total size of the symbol.  */\n-  unsigned HOST_WIDE_INT total_byte_size ();\n-\n-  /* Fill in those values into the symbol according to DECL, which are\n-     determined independently from whether it is parameter, result,\n-     or a variable, local or global.  */\n-  void fillup_for_decl (tree decl);\n-\n-  /* Pointer to the original tree, which is PARM_DECL for input parameters and\n-     RESULT_DECL for the output parameters.  Also can be CONST_DECL for Fortran\n-     constants which need to be put into readonly segment.  */\n-  tree m_decl;\n-\n-  /* Name of the symbol, that will be written into output and dumps.  Can be\n-     NULL, see name_number below.  */\n-  const char *m_name;\n-\n-  /* If name is NULL, artificial name will be formed from the segment name and\n-     this number.  */\n-  int m_name_number;\n-\n-  /* Once written, this is the offset of the associated symbol directive.  Zero\n-     means the symbol has not been written yet.  */\n-  unsigned m_directive_offset;\n-\n-  /* HSA type of the parameter.  */\n-  BrigType16_t m_type;\n-\n-  /* The HSA segment this will eventually end up in.  */\n-  BrigSegment8_t m_segment;\n-\n-  /* The HSA kind of linkage.  */\n-  BrigLinkage8_t m_linkage;\n-\n-  /* Array dimension, if non-zero.  */\n-  unsigned HOST_WIDE_INT m_dim;\n-\n-  /* Constant value, used for string constants.  */\n-  hsa_op_immed *m_cst_value;\n-\n-  /* Is in global scope.  */\n-  bool m_global_scope_p;\n-\n-  /* True if an error has been seen for the symbol.  */\n-  bool m_seen_error;\n-\n-  /* Symbol allocation.  */\n-  BrigAllocation m_allocation;\n-\n-  /* Flag used for global variables if a variable is already emitted or not.  */\n-  bool m_emitted_to_brig;\n-\n-  /* Alignment of the symbol.  */\n-  BrigAlignment8_t m_align;\n-\n-private:\n-  /* Default constructor.  */\n-  hsa_symbol ();\n-};\n-\n-/* Abstract class for HSA instruction operands.  */\n-\n-class hsa_op_base\n-{\n-public:\n-  /* Next operand scheduled to be written when writing BRIG operand\n-     section.  */\n-  hsa_op_base *m_next;\n-\n-  /* Offset to which the associated operand structure will be written.  Zero if\n-     yet not scheduled for writing.  */\n-  unsigned m_brig_op_offset;\n-\n-  /* The type of a particular operand.  */\n-  BrigKind16_t m_kind;\n-\n-protected:\n-  hsa_op_base (BrigKind16_t k);\n-private:\n-  /* Make the default constructor inaccessible.  */\n-  hsa_op_base () {}\n-};\n-\n-/* Common abstract ancestor for operands which have a type.  */\n-\n-class hsa_op_with_type : public hsa_op_base\n-{\n-public:\n-  /* The type.  */\n-  BrigType16_t m_type;\n-\n-  /* Convert an operand to a destination type DTYPE and attach insns\n-     to HBB if needed.  */\n-  hsa_op_with_type *get_in_type (BrigType16_t dtype, hsa_bb *hbb);\n-  /* If this operand has integer type smaller than 32 bits, extend it to 32\n-     bits, adding instructions to HBB if needed.  */\n-  hsa_op_with_type *extend_int_to_32bit (hsa_bb *hbb);\n-\n-protected:\n-  hsa_op_with_type (BrigKind16_t k, BrigType16_t t);\n-private:\n-  /* Make the default constructor inaccessible.  */\n-  hsa_op_with_type () : hsa_op_base (BRIG_KIND_NONE) {}\n-};\n-\n-/* An immediate HSA operand.  */\n-\n-class hsa_op_immed : public hsa_op_with_type\n-{\n-public:\n-  hsa_op_immed (tree tree_val, bool min32int = true);\n-  hsa_op_immed (HOST_WIDE_INT int_value, BrigType16_t type);\n-  void *operator new (size_t);\n-  ~hsa_op_immed ();\n-  void set_type (BrigKind16_t t);\n-\n-  /* Function returns pointer to a buffer that contains binary representation\n-     of the immeadiate value.  The buffer has length of BRIG_SIZE and\n-     a caller is responsible for deallocation of the buffer.  */\n-  char *emit_to_buffer (unsigned *brig_size);\n-\n-  /* Value as represented by middle end.  */\n-  tree m_tree_value;\n-\n-  /* Integer value representation.  */\n-  HOST_WIDE_INT m_int_value;\n-\n-private:\n-  /* Make the default constructor inaccessible.  */\n-  hsa_op_immed ();\n-  /* All objects are deallocated by destroying their pool, so make delete\n-     inaccessible too.  */\n-  void operator delete (void *) {}\n-};\n-\n-/* Report whether or not P is an immediate operand.  */\n-\n-template <>\n-template <>\n-inline bool\n-is_a_helper <hsa_op_immed *>::test (hsa_op_base *p)\n-{\n-  return p->m_kind == BRIG_KIND_OPERAND_CONSTANT_BYTES;\n-}\n-\n-/* Likewise, but for a more specified base. */\n-\n-template <>\n-template <>\n-inline bool\n-is_a_helper <hsa_op_immed *>::test (hsa_op_with_type *p)\n-{\n-  return p->m_kind == BRIG_KIND_OPERAND_CONSTANT_BYTES;\n-}\n-\n-\n-/* HSA register operand.  */\n-\n-class hsa_op_reg : public hsa_op_with_type\n-{\n-  friend class hsa_insn_basic;\n-  friend class hsa_insn_phi;\n-public:\n-  hsa_op_reg (BrigType16_t t);\n-  void *operator new (size_t);\n-\n-  /* Verify register operand.  */\n-  void verify_ssa ();\n-\n-  /* If NON-NULL, gimple SSA that we come from.  NULL if none.  */\n-  tree m_gimple_ssa;\n-\n-  /* Defining instruction while still in the SSA.  */\n-  hsa_insn_basic *m_def_insn;\n-\n-  /* If the register allocator decides to spill the register, this is the\n-     appropriate spill symbol.  */\n-  hsa_symbol *m_spill_sym;\n-\n-  /* Number of this register structure in the order in which they were\n-     allocated.  */\n-  int m_order;\n-  int m_lr_begin, m_lr_end;\n-\n-  /* Zero if the register is not yet allocated.  After, allocation, this must\n-     be 'c', 's', 'd' or 'q'.  */\n-  char m_reg_class;\n-  /* If allocated, the number of the HW register (within its HSA register\n-     class).  */\n-  char m_hard_num;\n-\n-private:\n-  /* Make the default constructor inaccessible.  */\n-  hsa_op_reg () : hsa_op_with_type (BRIG_KIND_NONE, BRIG_TYPE_NONE) {}\n-  /* All objects are deallocated by destroying their pool, so make delete\n-     inaccessible too.  */\n-  void operator delete (void *) {}\n-  /* Set definition where the register is defined.  */\n-  void set_definition (hsa_insn_basic *insn);\n-  /* Uses of the value while still in SSA.  */\n-  auto_vec <hsa_insn_basic *> m_uses;\n-};\n-\n-/* Report whether or not P is a register operand.  */\n-\n-template <>\n-template <>\n-inline bool\n-is_a_helper <hsa_op_reg *>::test (hsa_op_base *p)\n-{\n-  return p->m_kind == BRIG_KIND_OPERAND_REGISTER;\n-}\n-\n-/* Report whether or not P is a register operand.  */\n-\n-template <>\n-template <>\n-inline bool\n-is_a_helper <hsa_op_reg *>::test (hsa_op_with_type *p)\n-{\n-  return p->m_kind == BRIG_KIND_OPERAND_REGISTER;\n-}\n-\n-/* An address HSA operand.  */\n-\n-class hsa_op_address : public hsa_op_base\n-{\n-public:\n-  /* set up a new address operand consisting of base symbol SYM, register R and\n-     immediate OFFSET.  If the machine model is not large and offset is 64 bit,\n-     the upper, 32 bits have to be zero.  */\n-  hsa_op_address (hsa_symbol *sym, hsa_op_reg *reg,\n-\t\t  HOST_WIDE_INT offset = 0);\n-\n-  void *operator new (size_t);\n-\n-  /* Set up a new address operand consisting of base symbol SYM and\n-     immediate OFFSET.  If the machine model is not large and offset is 64 bit,\n-     the upper, 32 bits have to be zero.  */\n-  hsa_op_address (hsa_symbol *sym, HOST_WIDE_INT offset = 0);\n-\n-  /* Set up a new address operand consisting of register R and\n-     immediate OFFSET.  If the machine model is not large and offset is 64 bit,\n-     the upper, 32 bits have to be zero.  */\n-  hsa_op_address (hsa_op_reg *reg, HOST_WIDE_INT offset = 0);\n-\n-  /* Symbol base of the address.  Can be NULL if there is none.  */\n-  hsa_symbol *m_symbol;\n-\n-  /* Register offset.  Can be NULL if there is none.  */\n-  hsa_op_reg *m_reg;\n-\n-  /* Immediate byte offset.  */\n-  HOST_WIDE_INT m_imm_offset;\n-\n-private:\n-  /* Make the default constructor inaccessible.  */\n-  hsa_op_address () : hsa_op_base (BRIG_KIND_NONE) {}\n-  /* All objects are deallocated by destroying their pool, so make delete\n-     inaccessible too.  */\n-  void operator delete (void *) {}\n-};\n-\n-/* Report whether or not P is an address operand.  */\n-\n-template <>\n-template <>\n-inline bool\n-is_a_helper <hsa_op_address *>::test (hsa_op_base *p)\n-{\n-  return p->m_kind == BRIG_KIND_OPERAND_ADDRESS;\n-}\n-\n-/* A reference to code HSA operand.  It can be either reference\n-   to a start of a BB or a start of a function.  */\n-\n-class hsa_op_code_ref : public hsa_op_base\n-{\n-public:\n-  hsa_op_code_ref ();\n-\n-  /* Offset in the code section that this refers to.  */\n-  unsigned m_directive_offset;\n-};\n-\n-/* Report whether or not P is a code reference operand.  */\n-\n-template <>\n-template <>\n-inline bool\n-is_a_helper <hsa_op_code_ref *>::test (hsa_op_base *p)\n-{\n-  return p->m_kind == BRIG_KIND_OPERAND_CODE_REF;\n-}\n-\n-/* Code list HSA operand.  */\n-\n-class hsa_op_code_list: public hsa_op_base\n-{\n-public:\n-  hsa_op_code_list (unsigned elements);\n-  void *operator new (size_t);\n-\n-  /* Offset to variable-sized array in hsa_data section, where\n-     are offsets to entries in the hsa_code section.  */\n-  auto_vec<unsigned> m_offsets;\n-private:\n-  /* Make the default constructor inaccessible.  */\n-  hsa_op_code_list () : hsa_op_base (BRIG_KIND_NONE) {}\n-  /* All objects are deallocated by destroying their pool, so make delete\n-     inaccessible too.  */\n-  void operator delete (void *) {}\n-};\n-\n-/* Report whether or not P is a code list operand.  */\n-\n-template <>\n-template <>\n-inline bool\n-is_a_helper <hsa_op_code_list *>::test (hsa_op_base *p)\n-{\n-  return p->m_kind == BRIG_KIND_OPERAND_CODE_LIST;\n-}\n-\n-/* Operand list HSA operand.  */\n-\n-class hsa_op_operand_list: public hsa_op_base\n-{\n-public:\n-  hsa_op_operand_list (unsigned elements);\n-  ~hsa_op_operand_list ();\n-  void *operator new (size_t);\n-\n-  /* Offset to variable-sized array in hsa_data section, where\n-     are offsets to entries in the hsa_code section.  */\n-  auto_vec<unsigned> m_offsets;\n-private:\n-  /* Make the default constructor inaccessible.  */\n-  hsa_op_operand_list () : hsa_op_base (BRIG_KIND_NONE) {}\n-  /* All objects are deallocated by destroying their pool, so make delete\n-     inaccessible too.  */\n-  void operator delete (void *) {}\n-};\n-\n-/* Report whether or not P is a code list operand.  */\n-\n-template <>\n-template <>\n-inline bool\n-is_a_helper <hsa_op_operand_list *>::test (hsa_op_base *p)\n-{\n-  return p->m_kind == BRIG_KIND_OPERAND_OPERAND_LIST;\n-}\n-\n-/* Opcodes of instructions that are not part of HSA but that we use to\n-   represent it nevertheless.  */\n-\n-#define HSA_OPCODE_PHI (-1)\n-#define HSA_OPCODE_ARG_BLOCK (-2)\n-\n-/* The number of operand pointers we can directly in an instruction.  */\n-#define HSA_BRIG_INT_STORAGE_OPERANDS 5\n-\n-/* Class representing an HSA instruction.  Unlike typical ancestors for\n-   specialized classes, this one is also directly used for all instructions\n-   that are then represented as BrigInstBasic.  */\n-\n-class hsa_insn_basic\n-{\n-public:\n-  hsa_insn_basic (unsigned nops, int opc);\n-  hsa_insn_basic (unsigned nops, int opc, BrigType16_t t,\n-\t\t  hsa_op_base *arg0 = NULL,\n-\t\t  hsa_op_base *arg1 = NULL,\n-\t\t  hsa_op_base *arg2 = NULL,\n-\t\t  hsa_op_base *arg3 = NULL);\n-\n-  void *operator new (size_t);\n-  void set_op (int index, hsa_op_base *op);\n-  hsa_op_base *get_op (int index);\n-  hsa_op_base **get_op_addr (int index);\n-  unsigned int operand_count ();\n-  void verify ();\n-  unsigned input_count ();\n-  unsigned num_used_ops ();\n-  void set_output_in_type (hsa_op_reg *dest, unsigned op_index, hsa_bb *hbb);\n-  bool op_output_p (unsigned opnum);\n-\n-  /* The previous and next instruction in the basic block.  */\n-  hsa_insn_basic *m_prev, *m_next;\n-\n-  /* Basic block this instruction belongs to.  */\n-  basic_block m_bb;\n-\n-  /* Operand code distinguishing different types of instructions.  Eventually\n-     these should only be BRIG_INST_* values from the BrigOpcode16_t range but\n-     initially we use negative values for PHI nodes and such.  */\n-  int m_opcode;\n-\n-  /* Linearized number assigned to the instruction by HSA RA.  */\n-  int m_number;\n-\n-  /* Type of the destination of the operations.  */\n-  BrigType16_t m_type;\n-\n-  /* BRIG offset of the instruction in code section.  */\n-  unsigned int m_brig_offset;\n-\n-private:\n-  /* Make the default constructor inaccessible.  */\n-  hsa_insn_basic () {}\n-  /* All objects are deallocated by destroying their pool, so make delete\n-     inaccessible too.  */\n-  void operator delete (void *) {}\n-  /* The individual operands.  All instructions but PHI nodes have five or\n-     fewer instructions and so will fit the internal storage.  */\n-  /* TODO: Vast majority of instructions have three or fewer operands, so we\n-     may actually try reducing it.  */\n-  auto_vec<hsa_op_base *, HSA_BRIG_INT_STORAGE_OPERANDS> m_operands;\n-};\n-\n-/* Class representing a PHI node of the SSA form of HSA virtual\n-   registers.  */\n-\n-class hsa_insn_phi : public hsa_insn_basic\n-{\n-public:\n-  hsa_insn_phi (unsigned nops, hsa_op_reg *dst);\n-\n-  /* Destination.  */\n-  hsa_op_reg *m_dest;\n-\n-private:\n-  /* Make the default constructor inaccessible.  */\n-  hsa_insn_phi () : hsa_insn_basic (1, HSA_OPCODE_PHI) {}\n-};\n-\n-/* Report whether or not P is a PHI node.  */\n-\n-template <>\n-template <>\n-inline bool\n-is_a_helper <hsa_insn_phi *>::test (hsa_insn_basic *p)\n-{\n-  return p->m_opcode == HSA_OPCODE_PHI;\n-}\n-\n-/* HSA instruction for  */\n-class hsa_insn_br : public hsa_insn_basic\n-{\n-public:\n-  hsa_insn_br (unsigned nops, int opc, BrigType16_t t, BrigWidth8_t width,\n-\t       hsa_op_base *arg0 = NULL, hsa_op_base *arg1 = NULL,\n-\t       hsa_op_base *arg2 = NULL, hsa_op_base *arg3 = NULL);\n-\n-  /* Number of work-items affected in the same way by the instruction.  */\n-  BrigWidth8_t m_width;\n-\n-private:\n-  /* Make the default constructor inaccessible.  */\n-  hsa_insn_br () : hsa_insn_basic (0, BRIG_OPCODE_BR) {}\n-};\n-\n-/* Return true if P is a branching/synchronization instruction.  */\n-\n-template <>\n-template <>\n-inline bool\n-is_a_helper <hsa_insn_br *>::test (hsa_insn_basic *p)\n-{\n-  return p->m_opcode == BRIG_OPCODE_BARRIER\n-    || p->m_opcode == BRIG_OPCODE_BR;\n-}\n-\n-/* HSA instruction for conditional branches.  Structurally the same as\n-   hsa_insn_br but we represent it specially because of inherent control\n-   flow it represents.  */\n-\n-class hsa_insn_cbr : public hsa_insn_br\n-{\n-public:\n-  hsa_insn_cbr (hsa_op_reg *ctrl);\n-\n-private:\n-  /* Make the default constructor inaccessible.  */\n-  hsa_insn_cbr () : hsa_insn_br (0, BRIG_OPCODE_CBR, BRIG_TYPE_B1,\n-\t\t\t\t BRIG_WIDTH_1) {}\n-};\n-\n-/* Report whether P is a contitional branching instruction.  */\n-\n-template <>\n-template <>\n-inline bool\n-is_a_helper <hsa_insn_cbr *>::test (hsa_insn_basic *p)\n-{\n-  return p->m_opcode == BRIG_OPCODE_CBR;\n-}\n-\n-/* HSA instruction for switch branches.  */\n-\n-class hsa_insn_sbr : public hsa_insn_basic\n-{\n-public:\n-  hsa_insn_sbr (hsa_op_reg *index, unsigned jump_count);\n-\n-  /* Default destructor.  */\n-  ~hsa_insn_sbr ();\n-\n-  void replace_all_labels (basic_block old_bb, basic_block new_bb);\n-\n-  /* Width as described in HSA documentation.  */\n-  BrigWidth8_t m_width;\n-\n-  /* Jump table.  */\n-  vec <basic_block> m_jump_table;\n-\n-  /* Code list for label references.  */\n-  hsa_op_code_list *m_label_code_list;\n-\n-private:\n-  /* Make the default constructor inaccessible.  */\n-  hsa_insn_sbr () : hsa_insn_basic (1, BRIG_OPCODE_SBR) {}\n-};\n-\n-/* Report whether P is a switch branching instruction.  */\n-\n-template <>\n-template <>\n-inline bool\n-is_a_helper <hsa_insn_sbr *>::test (hsa_insn_basic *p)\n-{\n-  return p->m_opcode == BRIG_OPCODE_SBR;\n-}\n-\n-/* HSA instruction for comparisons.  */\n-\n-class hsa_insn_cmp : public hsa_insn_basic\n-{\n-public:\n-  hsa_insn_cmp (BrigCompareOperation8_t cmp, BrigType16_t t,\n-\t\thsa_op_base *arg0 = NULL, hsa_op_base *arg1 = NULL,\n-\t\thsa_op_base *arg2 = NULL);\n-\n-  /* Source type should be derived from operand types.  */\n-\n-  /* The comparison operation.  */\n-  BrigCompareOperation8_t m_compare;\n-\n-  /* TODO: Modifiers and packing control are missing but so are everywhere\n-     else.  */\n-private:\n-  /* Make the default constructor inaccessible.  */\n-  hsa_insn_cmp () : hsa_insn_basic (1, BRIG_OPCODE_CMP) {}\n-};\n-\n-/* Report whether or not P is a comparison instruction.  */\n-\n-template <>\n-template <>\n-inline bool\n-is_a_helper <hsa_insn_cmp *>::test (hsa_insn_basic *p)\n-{\n-  return p->m_opcode == BRIG_OPCODE_CMP;\n-}\n-\n-/* HSA instruction for memory operations.  */\n-\n-class hsa_insn_mem : public hsa_insn_basic\n-{\n-public:\n-  hsa_insn_mem (int opc, BrigType16_t t, hsa_op_base *arg0, hsa_op_base *arg1);\n-\n-  /* Set alignment to VALUE.  */\n-\n-  void set_align (BrigAlignment8_t value);\n-\n-  /* The segment is of the memory access is either the segment of the symbol in\n-     the address operand or flat address is there is no symbol there.  */\n-\n-  /* Required alignment of the memory operation.  */\n-  BrigAlignment8_t m_align;\n-\n-  /* HSA equiv class, basically an alias set number.  */\n-  uint8_t m_equiv_class;\n-\n-  /* TODO:  Add width modifier, perhaps also other things.  */\n-protected:\n-  hsa_insn_mem (unsigned nops, int opc, BrigType16_t t,\n-\t\thsa_op_base *arg0 = NULL, hsa_op_base *arg1 = NULL,\n-\t\thsa_op_base *arg2 = NULL, hsa_op_base *arg3 = NULL);\n-\n-private:\n-  /* Make the default constructor inaccessible.  */\n-  hsa_insn_mem () : hsa_insn_basic (1, BRIG_OPCODE_LD) {}\n-};\n-\n-/* Report whether or not P is a memory instruction.  */\n-\n-template <>\n-template <>\n-inline bool\n-is_a_helper <hsa_insn_mem *>::test (hsa_insn_basic *p)\n-{\n-  return (p->m_opcode == BRIG_OPCODE_LD\n-\t  || p->m_opcode == BRIG_OPCODE_ST);\n-}\n-\n-/* HSA instruction for atomic operations.  */\n-\n-class hsa_insn_atomic : public hsa_insn_mem\n-{\n-public:\n-  hsa_insn_atomic (int nops, int opc, enum BrigAtomicOperation aop,\n-\t\t   BrigType16_t t, BrigMemoryOrder memorder,\n-\t\t   hsa_op_base *arg0 = NULL, hsa_op_base *arg1 = NULL,\n-\t\t   hsa_op_base *arg2 = NULL, hsa_op_base *arg3 = NULL);\n-\n-  /* The operation itself.  */\n-  enum BrigAtomicOperation m_atomicop;\n-\n-  /* Things like acquire/release/aligned.  */\n-  enum BrigMemoryOrder m_memoryorder;\n-\n-  /* Scope of the atomic operation.  */\n-  enum BrigMemoryScope m_memoryscope;\n-\n-private:\n-  /* Make the default constructor inaccessible.  */\n-  hsa_insn_atomic () : hsa_insn_mem (1, BRIG_KIND_NONE, BRIG_TYPE_NONE) {}\n-};\n-\n-/* Report whether or not P is an atomic instruction.  */\n-\n-template <>\n-template <>\n-inline bool\n-is_a_helper <hsa_insn_atomic *>::test (hsa_insn_basic *p)\n-{\n-  return (p->m_opcode == BRIG_OPCODE_ATOMIC\n-\t  || p->m_opcode == BRIG_OPCODE_ATOMICNORET);\n-}\n-\n-/* HSA instruction for signal operations.  */\n-\n-class hsa_insn_signal : public hsa_insn_basic\n-{\n-public:\n-  hsa_insn_signal (int nops, int opc, enum BrigAtomicOperation sop,\n-\t\t   BrigType16_t t, BrigMemoryOrder memorder,\n-\t\t   hsa_op_base *arg0 = NULL, hsa_op_base *arg1 = NULL,\n-\t\t   hsa_op_base *arg2 = NULL, hsa_op_base *arg3 = NULL);\n-\n-  /* Things like acquire/release/aligned.  */\n-  enum BrigMemoryOrder m_memory_order;\n-\n-  /* The operation itself.  */\n-  enum BrigAtomicOperation m_signalop;\n-};\n-\n-/* Report whether or not P is a signal instruction.  */\n-\n-template <>\n-template <>\n-inline bool\n-is_a_helper <hsa_insn_signal *>::test (hsa_insn_basic *p)\n-{\n-  return (p->m_opcode == BRIG_OPCODE_SIGNAL\n-\t  || p->m_opcode == BRIG_OPCODE_SIGNALNORET);\n-}\n-\n-/* HSA instruction to convert between flat addressing and segments.  */\n-\n-class hsa_insn_seg : public hsa_insn_basic\n-{\n-public:\n-  hsa_insn_seg (int opc, BrigType16_t destt, BrigType16_t srct,\n-\t\tBrigSegment8_t seg, hsa_op_base *arg0, hsa_op_base *arg1);\n-\n-  /* Source type.  Depends on the source addressing/segment.  */\n-  BrigType16_t m_src_type;\n-  /* The segment we are converting from or to.  */\n-  BrigSegment8_t m_segment;\n-private:\n-  /* Make the default constructor inaccessible.  */\n-  hsa_insn_seg () : hsa_insn_basic (1, BRIG_OPCODE_STOF) {}\n-};\n-\n-/* Report whether or not P is a segment conversion instruction.  */\n-\n-template <>\n-template <>\n-inline bool\n-is_a_helper <hsa_insn_seg *>::test (hsa_insn_basic *p)\n-{\n-  return (p->m_opcode == BRIG_OPCODE_STOF\n-\t  || p->m_opcode == BRIG_OPCODE_FTOS);\n-}\n-\n-/* Class for internal functions for purpose of HSA emission.  */\n-\n-class hsa_internal_fn\n-{\n-public:\n-  hsa_internal_fn (enum internal_fn fn, unsigned type_bit_size):\n-    m_fn (fn), m_type_bit_size (type_bit_size), m_offset (0) {}\n-\n-  hsa_internal_fn (const hsa_internal_fn *f):\n-    m_fn (f->m_fn), m_type_bit_size (f->m_type_bit_size),\n-    m_offset (f->m_offset) {}\n-\n-  /* Return arity of the internal function.  */\n-  unsigned get_arity ();\n-\n-  /* Return BRIG type of N-th argument, if -1 is passed, return value type\n-     is received.  */\n-  BrigType16_t get_argument_type (int n);\n-\n-  /* Return function name.  The memory must be released by a caller.  */\n-  char *name ();\n-\n-  /* Internal function.  */\n-  enum internal_fn m_fn;\n-\n-  /* Bit width of return type.  */\n-  unsigned m_type_bit_size;\n-\n-  /* BRIG offset of declaration of the function.  */\n-  BrigCodeOffset32_t m_offset;\n-};\n-\n-/* HSA instruction for function call.  */\n-\n-class hsa_insn_call : public hsa_insn_basic\n-{\n-public:\n-  hsa_insn_call (tree callee);\n-  hsa_insn_call (hsa_internal_fn *fn);\n-\n-  /* Default destructor.  */\n-  ~hsa_insn_call ();\n-\n-  /* Called function.  */\n-  tree m_called_function;\n-\n-  /* Called internal function.  */\n-  hsa_internal_fn *m_called_internal_fn;\n-\n-  /* Input formal arguments.  */\n-  auto_vec <hsa_symbol *> m_input_args;\n-\n-  /* Input arguments store instructions.  */\n-  auto_vec <hsa_insn_mem *> m_input_arg_insns;\n-\n-  /* Output argument, can be NULL for void functions.  */\n-  hsa_symbol *m_output_arg;\n-\n-  /* Called function code reference.  */\n-  hsa_op_code_ref m_func;\n-\n-  /* Code list for arguments of the function.  */\n-  hsa_op_code_list *m_args_code_list;\n-\n-  /* Code list for result of the function.  */\n-  hsa_op_code_list *m_result_code_list;\n-private:\n-  /* Make the default constructor inaccessible.  */\n-  hsa_insn_call () : hsa_insn_basic (0, BRIG_OPCODE_CALL) {}\n-};\n-\n-/* Report whether or not P is a call instruction.  */\n-\n-template <>\n-template <>\n-inline bool\n-is_a_helper <hsa_insn_call *>::test (hsa_insn_basic *p)\n-{\n-  return (p->m_opcode == BRIG_OPCODE_CALL);\n-}\n-\n-/* HSA call instruction block encapsulates definition of arguments,\n-   result type, corresponding loads and a possible store.\n-   Moreover, it contains a single call instruction.\n-   Emission of the instruction will produce multiple\n-   HSAIL instructions.  */\n-\n-class hsa_insn_arg_block : public hsa_insn_basic\n-{\n-public:\n-  hsa_insn_arg_block (BrigKind brig_kind, hsa_insn_call * call);\n-\n-  /* Kind of argument block.  */\n-  BrigKind m_kind;\n-\n-  /* Call instruction.  */\n-  hsa_insn_call *m_call_insn;\n-};\n-\n-/* Report whether or not P is a call block instruction.  */\n-\n-template <>\n-template <>\n-inline bool\n-is_a_helper <hsa_insn_arg_block *>::test (hsa_insn_basic *p)\n-{\n-  return (p->m_opcode == HSA_OPCODE_ARG_BLOCK);\n-}\n-\n-/* HSA comment instruction.  */\n-\n-class hsa_insn_comment: public hsa_insn_basic\n-{\n-public:\n-  /* Constructor of class representing the comment in HSAIL.  */\n-  hsa_insn_comment (const char *s);\n-\n-  /* Default destructor.  */\n-  ~hsa_insn_comment ();\n-\n-  char *m_comment;\n-};\n-\n-/* Report whether or not P is a call block instruction.  */\n-\n-template <>\n-template <>\n-inline bool\n-is_a_helper <hsa_insn_comment *>::test (hsa_insn_basic *p)\n-{\n-  return (p->m_opcode == BRIG_KIND_DIRECTIVE_COMMENT);\n-}\n-\n-/* HSA queue instruction.  */\n-\n-class hsa_insn_queue: public hsa_insn_basic\n-{\n-public:\n-  hsa_insn_queue (int nops, int opcode, BrigSegment segment,\n-\t\t  BrigMemoryOrder memory_order,\n-\t\t  hsa_op_base *arg0 = NULL, hsa_op_base *arg1 = NULL,\n-\t\t  hsa_op_base *arg2 = NULL, hsa_op_base *arg3 = NULL);\n-\n-  /* Destructor.  */\n-  ~hsa_insn_queue ();\n-\n-  /* Segment used to refer to the queue.  Must be global or flat.  */\n-  BrigSegment m_segment;\n-  /* Memory order used to specify synchronization.  */\n-  BrigMemoryOrder m_memory_order;\n-};\n-\n-/* Report whether or not P is a queue instruction.  */\n-\n-template <>\n-template <>\n-inline bool\n-is_a_helper <hsa_insn_queue *>::test (hsa_insn_basic *p)\n-{\n-  return (p->m_opcode == BRIG_OPCODE_ADDQUEUEWRITEINDEX\n-\t  || p->m_opcode == BRIG_OPCODE_CASQUEUEWRITEINDEX\n-\t  || p->m_opcode == BRIG_OPCODE_LDQUEUEREADINDEX\n-\t  || p->m_opcode == BRIG_OPCODE_LDQUEUEWRITEINDEX\n-\t  || p->m_opcode == BRIG_OPCODE_STQUEUEREADINDEX\n-\t  || p->m_opcode == BRIG_OPCODE_STQUEUEWRITEINDEX);\n-}\n-\n-/* HSA source type instruction.  */\n-\n-class hsa_insn_srctype: public hsa_insn_basic\n-{\n-public:\n-  hsa_insn_srctype (int nops, BrigOpcode opcode, BrigType16_t destt,\n-\t\t   BrigType16_t srct, hsa_op_base *arg0, hsa_op_base *arg1,\n-\t\t   hsa_op_base *arg2);\n-\n-  /* Source type.  */\n-  BrigType16_t m_source_type;\n-\n-  /* Destructor.  */\n-  ~hsa_insn_srctype ();\n-};\n-\n-/* Report whether or not P is a source type instruction.  */\n-\n-template <>\n-template <>\n-inline bool\n-is_a_helper <hsa_insn_srctype *>::test (hsa_insn_basic *p)\n-{\n-  return (p->m_opcode == BRIG_OPCODE_POPCOUNT\n-\t  || p->m_opcode == BRIG_OPCODE_FIRSTBIT\n-\t  || p->m_opcode == BRIG_OPCODE_LASTBIT);\n-}\n-\n-/* HSA packed instruction.  */\n-\n-class hsa_insn_packed : public hsa_insn_srctype\n-{\n-public:\n-  hsa_insn_packed (int nops, BrigOpcode opcode, BrigType16_t destt,\n-\t\t   BrigType16_t srct, hsa_op_base *arg0, hsa_op_base *arg1,\n-\t\t   hsa_op_base *arg2);\n-\n-  /* Operand list for an operand of the instruction.  */\n-  hsa_op_operand_list *m_operand_list;\n-\n-  /* Destructor.  */\n-  ~hsa_insn_packed ();\n-};\n-\n-/* Report whether or not P is a combine instruction.  */\n-\n-template <>\n-template <>\n-inline bool\n-is_a_helper <hsa_insn_packed *>::test (hsa_insn_basic *p)\n-{\n-  return (p->m_opcode == BRIG_OPCODE_COMBINE\n-\t  || p->m_opcode == BRIG_OPCODE_EXPAND);\n-}\n-\n-/* HSA convert instruction.  */\n-\n-class hsa_insn_cvt: public hsa_insn_basic\n-{\n-public:\n-  hsa_insn_cvt (hsa_op_with_type *dest, hsa_op_with_type *src);\n-};\n-\n-/* Report whether or not P is a convert instruction.  */\n-\n-template <>\n-template <>\n-inline bool\n-is_a_helper <hsa_insn_cvt *>::test (hsa_insn_basic *p)\n-{\n-  return (p->m_opcode == BRIG_OPCODE_CVT);\n-}\n-\n-/* HSA alloca instruction.  */\n-\n-class hsa_insn_alloca: public hsa_insn_basic\n-{\n-public:\n-  hsa_insn_alloca (hsa_op_with_type *dest, hsa_op_with_type *size,\n-\t\t   unsigned alignment = 0);\n-\n-  /* Required alignment of the allocation.  */\n-  BrigAlignment8_t m_align;\n-};\n-\n-/* Report whether or not P is an alloca instruction.  */\n-\n-template <>\n-template <>\n-inline bool\n-is_a_helper <hsa_insn_alloca *>::test (hsa_insn_basic *p)\n-{\n-  return (p->m_opcode == BRIG_OPCODE_ALLOCA);\n-}\n-\n-/* Basic block of HSA instructions.  */\n-\n-class hsa_bb\n-{\n-public:\n-  hsa_bb (basic_block cfg_bb);\n-  hsa_bb (basic_block cfg_bb, int idx);\n-\n-  /* Append an instruction INSN into the basic block.  */\n-  void append_insn (hsa_insn_basic *insn);\n-\n-  /* Add a PHI instruction.  */\n-  void append_phi (hsa_insn_phi *phi);\n-\n-  /* The real CFG BB that this HBB belongs to.  */\n-  basic_block m_bb;\n-\n-  /* The operand that refers to the label to this BB.  */\n-  hsa_op_code_ref m_label_ref;\n-\n-  /* The first and last instruction.  */\n-  hsa_insn_basic *m_first_insn, *m_last_insn;\n-  /* The first and last phi node.  */\n-  hsa_insn_phi *m_first_phi, *m_last_phi;\n-\n-  /* Just a number to construct names from.  */\n-  int m_index;\n-\n-  auto_bitmap m_liveout, m_livein;\n-private:\n-  /* Make the default constructor inaccessible.  */\n-  hsa_bb ();\n-  /* All objects are deallocated by destroying their pool, so make delete\n-     inaccessible too.  */\n-  void operator delete (void *) {}\n-};\n-\n-/* Return the corresponding HSA basic block structure for the given control\n-   flow basic_block BB.  */\n-\n-static inline hsa_bb *\n-hsa_bb_for_bb (basic_block bb)\n-{\n-  return (class hsa_bb *) bb->aux;\n-}\n-\n-/* Class for hashing local hsa_symbols.  */\n-\n-struct hsa_noop_symbol_hasher : nofree_ptr_hash <hsa_symbol>\n-{\n-  static inline hashval_t hash (const value_type);\n-  static inline bool equal (const value_type, const compare_type);\n-};\n-\n-/* Hash hsa_symbol.  */\n-\n-inline hashval_t\n-hsa_noop_symbol_hasher::hash (const value_type item)\n-{\n-  return DECL_UID (item->m_decl);\n-}\n-\n-/* Return true if the DECL_UIDs of decls both symbols refer to are equal.  */\n-\n-inline bool\n-hsa_noop_symbol_hasher::equal (const value_type a, const compare_type b)\n-{\n-  return (DECL_UID (a->m_decl) == DECL_UID (b->m_decl));\n-}\n-\n-/* Structure that encapsulates intermediate representation of a HSA\n-   function.  */\n-\n-class hsa_function_representation\n-{\n-public:\n-  hsa_function_representation (tree fdecl, bool kernel_p,\n-\t\t\t       unsigned ssa_names_count,\n-\t\t\t       bool modified_cfg = false);\n-  hsa_function_representation (hsa_internal_fn *fn);\n-  ~hsa_function_representation ();\n-\n-  /* Builds a shadow register that is utilized to a kernel dispatch.  */\n-  hsa_op_reg *get_shadow_reg ();\n-\n-  /* Return true if we are in a function that has kernel dispatch\n-     shadow register.  */\n-  bool has_shadow_reg_p ();\n-\n-  /* The entry/exit blocks don't contain incoming code,\n-     but the HSA generator might use them to put code into,\n-     so we need hsa_bb instances of them.  */\n-  void init_extra_bbs ();\n-\n-  /* Update CFG dominators if m_modified_cfg flag is set.  */\n-  void update_dominance ();\n-\n-  /* Return linkage of the representation.  */\n-  BrigLinkage8_t get_linkage ();\n-\n-  /* Create a private symbol of requested TYPE.  */\n-  hsa_symbol *create_hsa_temporary (BrigType16_t type);\n-\n-  /* Lookup or create a HSA pseudo register for a given gimple SSA name.  */\n-  hsa_op_reg *reg_for_gimple_ssa (tree ssa);\n-\n-  /* Name of the function.  */\n-  char *m_name;\n-\n-  /* Number of allocated register structures.  */\n-  int m_reg_count;\n-\n-  /* Input arguments.  */\n-  vec <hsa_symbol *> m_input_args;\n-\n-  /* Output argument or NULL if there is none.  */\n-  hsa_symbol *m_output_arg;\n-\n-  /* Hash table of local variable symbols.  */\n-  hash_table <hsa_noop_symbol_hasher> *m_local_symbols;\n-\n-  /* Hash map for string constants.  */\n-  hash_map <tree, hsa_symbol *> m_string_constants_map;\n-\n-  /* Vector of pointers to spill symbols.  */\n-  vec <class hsa_symbol *> m_spill_symbols;\n-\n-  /* Vector of pointers to global variables and transformed string constants\n-     that are used by the function.  */\n-  vec <class hsa_symbol *> m_global_symbols;\n-\n-  /* Private function artificial variables.  */\n-  vec <class hsa_symbol *> m_private_variables;\n-\n-  /* Vector of called function declarations.  */\n-  vec <tree> m_called_functions;\n-\n-  /* Vector of used internal functions.  */\n-  vec <hsa_internal_fn *> m_called_internal_fns;\n-\n-  /* Number of HBB BBs.  */\n-  int m_hbb_count;\n-\n-  /* Whether or not we could check and enforce SSA properties.  */\n-  bool m_in_ssa;\n-\n-  /* True if the function is kernel function.  */\n-  bool m_kern_p;\n-\n-  /* True if the function representation is a declaration.  */\n-  bool m_declaration_p;\n-\n-  /* Function declaration tree.  */\n-  tree m_decl;\n-\n-  /* Internal function info is used for declarations of internal functions.  */\n-  hsa_internal_fn *m_internal_fn;\n-\n-  /* Runtime shadow register.  */\n-  hsa_op_reg *m_shadow_reg;\n-\n-  /* Number of kernel dispatched which take place in the function.  */\n-  unsigned m_kernel_dispatch_count;\n-\n-  /* If the function representation contains a kernel dispatch,\n-     OMP data size is necessary memory that is used for copying before\n-     a kernel dispatch.  */\n-  unsigned m_maximum_omp_data_size;\n-\n-  /* Return true if there's an HSA-specific warning already seen.  */\n-  bool m_seen_error;\n-\n-  /* Counter for temporary symbols created in the function representation.  */\n-  unsigned m_temp_symbol_count;\n-\n-  /* SSA names mapping.  */\n-  vec <hsa_op_reg *> m_ssa_map;\n-\n-  /* Flag whether a function needs update of dominators before RA.  */\n-  bool m_modified_cfg;\n-};\n-\n-enum hsa_function_kind\n-{\n-  HSA_INVALID,\n-  HSA_KERNEL,\n-  HSA_FUNCTION\n-};\n-\n-class hsa_function_summary\n-{\n-public:\n-  /* Default constructor.  */\n-  hsa_function_summary ();\n-\n-  /* Kind of GPU/host function.  */\n-  hsa_function_kind m_kind;\n-\n-  /* Pointer to a cgraph node which is a HSA implementation of the function.\n-     In case of the function is a HSA function, the bound function points\n-     to the host function.  */\n-  cgraph_node *m_bound_function;\n-\n-  /* Identifies if the function is an HSA function or a host function.  */\n-  bool m_gpu_implementation_p;\n-\n-  /* True if the function is a gridified kernel.  */\n-  bool m_gridified_kernel_p;\n-};\n-\n-inline\n-hsa_function_summary::hsa_function_summary (): m_kind (HSA_INVALID),\n-  m_bound_function (NULL), m_gpu_implementation_p (false)\n-{\n-}\n-\n-/* Function summary for HSA functions.  */\n-class hsa_summary_t: public function_summary <hsa_function_summary *>\n-{\n-public:\n-  hsa_summary_t (symbol_table *table):\n-    function_summary<hsa_function_summary *> (table)\n-  {\n-    disable_insertion_hook ();\n-  }\n-\n-  /* Couple GPU and HOST as gpu-specific and host-specific implementation of\n-     the same function.  KIND determines whether GPU is a host-invokable kernel\n-     or gpu-callable function and GRIDIFIED_KERNEL_P is set if the function was\n-     gridified in OMP.  */\n-\n-  void link_functions (cgraph_node *gpu, cgraph_node *host,\n-\t\t       hsa_function_kind kind, bool gridified_kernel_p);\n-\n-private:\n-  void process_gpu_implementation_attributes (tree gdecl);\n-};\n-\n-/* OMP simple builtin describes behavior that should be done for\n-   the routine.  */\n-class omp_simple_builtin\n-{\n-public:\n-  omp_simple_builtin (const char *name, const char *warning_message,\n-\t       bool sorry, hsa_op_immed *return_value = NULL):\n-    m_name (name), m_warning_message (warning_message), m_sorry (sorry),\n-    m_return_value (return_value)\n-  {}\n-\n-  /* Generate HSAIL instructions for the builtin or produce warning message.  */\n-  void generate (gimple *stmt, hsa_bb *hbb);\n-\n-  /* Name of function.  */\n-  const char *m_name;\n-\n-  /* Warning message.  */\n-  const char *m_warning_message;\n-\n-  /* Flag if we should sorry after the warning message is printed.  */\n-  bool m_sorry;\n-\n-  /* Return value of the function.  */\n-  hsa_op_immed *m_return_value;\n-\n-  /* Emission function.  */\n-  void (*m_emit_func) (gimple *stmt, hsa_bb *);\n-};\n-\n-/* Class for hashing hsa_internal_fn.  */\n-\n-struct hsa_internal_fn_hasher: free_ptr_hash <hsa_internal_fn>\n-{\n-  static inline hashval_t hash (const value_type);\n-  static inline bool equal (const value_type, const compare_type);\n-};\n-\n-/* Hash hsa_symbol.  */\n-\n-inline hashval_t\n-hsa_internal_fn_hasher::hash (const value_type item)\n-{\n-  return item->m_fn;\n-}\n-\n-/* Return true if the DECL_UIDs of decls both symbols refer to  are equal.  */\n-\n-inline bool\n-hsa_internal_fn_hasher::equal (const value_type a, const compare_type b)\n-{\n-  return a->m_fn == b->m_fn && a->m_type_bit_size == b->m_type_bit_size;\n-}\n-\n-/* in hsa-common.c */\n-extern class hsa_function_representation *hsa_cfun;\n-extern hash_map <tree, vec <const char *> *> *hsa_decl_kernel_dependencies;\n-extern hsa_summary_t *hsa_summaries;\n-extern hsa_symbol *hsa_num_threads;\n-extern unsigned hsa_kernel_calls_counter;\n-extern hash_set <tree> *hsa_failed_functions;\n-extern hash_table <hsa_noop_symbol_hasher> *hsa_global_variable_symbols;\n-\n-bool hsa_callable_function_p (tree fndecl);\n-void hsa_init_compilation_unit_data (void);\n-void hsa_deinit_compilation_unit_data (void);\n-bool hsa_machine_large_p (void);\n-bool hsa_full_profile_p (void);\n-bool hsa_opcode_floating_bit_insn_p (BrigOpcode16_t);\n-unsigned hsa_type_bit_size (BrigType16_t t);\n-BrigType16_t hsa_bittype_for_bitsize (unsigned bitsize);\n-BrigType16_t hsa_uint_for_bitsize (unsigned bitsize);\n-BrigType16_t hsa_float_for_bitsize (unsigned bitsize);\n-BrigType16_t hsa_bittype_for_type (BrigType16_t t);\n-BrigType16_t hsa_unsigned_type_for_type (BrigType16_t t);\n-bool hsa_type_packed_p (BrigType16_t type);\n-bool hsa_type_float_p (BrigType16_t type);\n-bool hsa_type_integer_p (BrigType16_t type);\n-bool hsa_btype_p (BrigType16_t type);\n-BrigAlignment8_t hsa_alignment_encoding (unsigned n);\n-BrigAlignment8_t hsa_natural_alignment (BrigType16_t type);\n-BrigAlignment8_t hsa_object_alignment (tree t);\n-unsigned hsa_byte_alignment (BrigAlignment8_t alignment);\n-void hsa_destroy_operand (hsa_op_base *op);\n-void hsa_destroy_insn (hsa_insn_basic *insn);\n-void hsa_add_kern_decl_mapping (tree decl, char *name, unsigned, bool);\n-unsigned hsa_get_number_decl_kernel_mappings (void);\n-tree hsa_get_decl_kernel_mapping_decl (unsigned i);\n-char *hsa_get_decl_kernel_mapping_name (unsigned i);\n-unsigned hsa_get_decl_kernel_mapping_omp_size (unsigned i);\n-bool hsa_get_decl_kernel_mapping_gridified (unsigned i);\n-void hsa_free_decl_kernel_mapping (void);\n-tree *hsa_get_ctor_statements (void);\n-tree *hsa_get_dtor_statements (void);\n-tree *hsa_get_kernel_dispatch_type (void);\n-void hsa_add_kernel_dependency (tree caller, const char *called_function);\n-void hsa_sanitize_name (char *p);\n-char *hsa_brig_function_name (const char *p);\n-const char *hsa_get_declaration_name (tree decl);\n-void hsa_register_kernel (cgraph_node *host);\n-void hsa_register_kernel (cgraph_node *gpu, cgraph_node *host);\n-bool hsa_seen_error (void);\n-void hsa_fail_cfun (void);\n-\n-/* In hsa-gen.c.  */\n-void hsa_build_append_simple_mov (hsa_op_reg *, hsa_op_base *, hsa_bb *);\n-hsa_symbol *hsa_get_spill_symbol (BrigType16_t);\n-hsa_symbol *hsa_get_string_cst_symbol (BrigType16_t);\n-hsa_op_reg *hsa_spill_in (hsa_insn_basic *, hsa_op_reg *, hsa_op_reg **);\n-hsa_op_reg *hsa_spill_out (hsa_insn_basic *, hsa_op_reg *, hsa_op_reg **);\n-hsa_bb *hsa_init_new_bb (basic_block);\n-hsa_function_representation *hsa_generate_function_declaration (tree decl);\n-hsa_function_representation *hsa_generate_internal_fn_decl (hsa_internal_fn *);\n-tree hsa_get_host_function (tree decl);\n-\n-/* In hsa-regalloc.c.  */\n-void hsa_regalloc (void);\n-\n-/* In hsa-brig.c.  */\n-extern hash_table <hsa_internal_fn_hasher> *hsa_emitted_internal_decls;\n-void hsa_brig_emit_function (void);\n-void hsa_output_brig (void);\n-unsigned hsa_get_imm_brig_type_len (BrigType16_t type);\n-void hsa_brig_emit_omp_symbols (void);\n-\n-/*  In hsa-dump.c.  */\n-const char *hsa_seg_name (BrigSegment8_t);\n-void dump_hsa_insn (FILE *f, hsa_insn_basic *insn);\n-void dump_hsa_bb (FILE *, hsa_bb *);\n-void dump_hsa_cfun (FILE *);\n-DEBUG_FUNCTION void debug_hsa_operand (hsa_op_base *opc);\n-DEBUG_FUNCTION void debug_hsa_insn (hsa_insn_basic *insn);\n-\n-union hsa_bytes\n-{\n-  uint8_t b8;\n-  uint16_t b16;\n-  uint32_t b32;\n-  uint64_t b64;\n-};\n-\n-/* Return true if a function DECL is an HSA implementation.  */\n-\n-static inline bool\n-hsa_gpu_implementation_p (tree decl)\n-{\n-  if (hsa_summaries == NULL)\n-    return false;\n-\n-  hsa_function_summary *s = hsa_summaries->get (cgraph_node::get_create (decl));\n-  return s != NULL && s->m_gpu_implementation_p;\n-}\n-\n-#endif /* HSA_H */"}, {"sha": "23aa4c93f0da28c6ac7ee0fb2f1048b0ec4f4a92", "filename": "gcc/hsa-dump.c", "status": "removed", "additions": 0, "deletions": 1278, "changes": 1278, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9623f61b142174b87760c81f78928dd14af7cbc6/gcc%2Fhsa-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9623f61b142174b87760c81f78928dd14af7cbc6/gcc%2Fhsa-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhsa-dump.c?ref=9623f61b142174b87760c81f78928dd14af7cbc6", "patch": "@@ -1,1278 +0,0 @@\n-/* Infrastructure to dump our HSAIL IL\n-   Copyright (C) 2013-2020 Free Software Foundation, Inc.\n-   Contributed by Martin Jambor <mjambor@suse.cz> and\n-   Martin Liska <mliska@suse.cz>.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"is-a.h\"\n-#include \"vec.h\"\n-#include \"tree.h\"\n-#include \"basic-block.h\"\n-#include \"function.h\"\n-#include \"cfg.h\"\n-#include \"dumpfile.h\"\n-#include \"gimple-pretty-print.h\"\n-#include \"cgraph.h\"\n-#include \"print-tree.h\"\n-#include \"alloc-pool.h\"\n-#include \"symbol-summary.h\"\n-#include \"hsa-common.h\"\n-\n-/* Return textual name of TYPE.  */\n-\n-static const char *\n-hsa_type_name (BrigType16_t type)\n-{\n-  switch (type)\n-    {\n-    case BRIG_TYPE_NONE:\n-      return \"none\";\n-    case BRIG_TYPE_U8:\n-      return \"u8\";\n-    case BRIG_TYPE_U16:\n-      return \"u16\";\n-    case BRIG_TYPE_U32:\n-      return \"u32\";\n-    case BRIG_TYPE_U64:\n-      return \"u64\";\n-    case BRIG_TYPE_S8:\n-      return \"s8\";\n-    case BRIG_TYPE_S16:\n-      return \"s16\";\n-    case BRIG_TYPE_S32:\n-      return \"s32\";\n-    case BRIG_TYPE_S64:\n-      return \"s64\";\n-    case BRIG_TYPE_F16:\n-      return \"f16\";\n-    case BRIG_TYPE_F32:\n-      return \"f32\";\n-    case BRIG_TYPE_F64:\n-      return \"f64\";\n-    case BRIG_TYPE_B1:\n-      return \"b1\";\n-    case BRIG_TYPE_B8:\n-      return \"b8\";\n-    case BRIG_TYPE_B16:\n-      return \"b16\";\n-    case BRIG_TYPE_B32:\n-      return \"b32\";\n-    case BRIG_TYPE_B64:\n-      return \"b64\";\n-    case BRIG_TYPE_B128:\n-      return \"b128\";\n-    case BRIG_TYPE_SAMP:\n-      return \"samp\";\n-    case BRIG_TYPE_ROIMG:\n-      return \"roimg\";\n-    case BRIG_TYPE_WOIMG:\n-      return \"woimg\";\n-    case BRIG_TYPE_RWIMG:\n-      return \"rwimg\";\n-    case BRIG_TYPE_SIG32:\n-      return \"sig32\";\n-    case BRIG_TYPE_SIG64:\n-      return \"sig64\";\n-    case BRIG_TYPE_U8X4:\n-      return \"u8x4\";\n-    case BRIG_TYPE_U8X8:\n-      return \"u8x8\";\n-    case BRIG_TYPE_U8X16:\n-      return \"u8x16\";\n-    case BRIG_TYPE_U16X2:\n-      return \"u16x2\";\n-    case BRIG_TYPE_U16X4:\n-      return \"u16x4\";\n-    case BRIG_TYPE_U16X8:\n-      return \"u16x8\";\n-    case BRIG_TYPE_U32X2:\n-      return \"u32x2\";\n-    case BRIG_TYPE_U32X4:\n-      return \"u32x4\";\n-    case BRIG_TYPE_U64X2:\n-      return \"u64x2\";\n-    case BRIG_TYPE_S8X4:\n-      return \"s8x4\";\n-    case BRIG_TYPE_S8X8:\n-      return \"s8x8\";\n-    case BRIG_TYPE_S8X16:\n-      return \"s8x16\";\n-    case BRIG_TYPE_S16X2:\n-      return \"s16x2\";\n-    case BRIG_TYPE_S16X4:\n-      return \"s16x4\";\n-    case BRIG_TYPE_S16X8:\n-      return \"s16x8\";\n-    case BRIG_TYPE_S32X2:\n-      return \"s32x2\";\n-    case BRIG_TYPE_S32X4:\n-      return \"s32x4\";\n-    case BRIG_TYPE_S64X2:\n-      return \"s64x2\";\n-    case BRIG_TYPE_F16X2:\n-      return \"f16x2\";\n-    case BRIG_TYPE_F16X4:\n-      return \"f16x4\";\n-    case BRIG_TYPE_F16X8:\n-      return \"f16x8\";\n-    case BRIG_TYPE_F32X2:\n-      return \"f32x2\";\n-    case BRIG_TYPE_F32X4:\n-      return \"f32x4\";\n-    case BRIG_TYPE_F64X2:\n-      return \"f64x2\";\n-    default:\n-      return \"UNKNOWN_TYPE\";\n-    }\n-}\n-\n-/* Return textual name of OPCODE.  */\n-\n-static const char *\n-hsa_opcode_name (BrigOpcode16_t opcode)\n-{\n-  switch (opcode)\n-    {\n-    case BRIG_OPCODE_NOP:\n-      return \"nop\";\n-    case BRIG_OPCODE_ABS:\n-      return \"abs\";\n-    case BRIG_OPCODE_ADD:\n-      return \"add\";\n-    case BRIG_OPCODE_BORROW:\n-      return \"borrow\";\n-    case BRIG_OPCODE_CARRY:\n-      return \"carry\";\n-    case BRIG_OPCODE_CEIL:\n-      return \"ceil\";\n-    case BRIG_OPCODE_COPYSIGN:\n-      return \"copysign\";\n-    case BRIG_OPCODE_DIV:\n-      return \"div\";\n-    case BRIG_OPCODE_FLOOR:\n-      return \"floor\";\n-    case BRIG_OPCODE_FMA:\n-      return \"fma\";\n-    case BRIG_OPCODE_FRACT:\n-      return \"fract\";\n-    case BRIG_OPCODE_MAD:\n-      return \"mad\";\n-    case BRIG_OPCODE_MAX:\n-      return \"max\";\n-    case BRIG_OPCODE_MIN:\n-      return \"min\";\n-    case BRIG_OPCODE_MUL:\n-      return \"mul\";\n-    case BRIG_OPCODE_MULHI:\n-      return \"mulhi\";\n-    case BRIG_OPCODE_NEG:\n-      return \"neg\";\n-    case BRIG_OPCODE_REM:\n-      return \"rem\";\n-    case BRIG_OPCODE_RINT:\n-      return \"rint\";\n-    case BRIG_OPCODE_SQRT:\n-      return \"sqrt\";\n-    case BRIG_OPCODE_SUB:\n-      return \"sub\";\n-    case BRIG_OPCODE_TRUNC:\n-      return \"trunc\";\n-    case BRIG_OPCODE_MAD24:\n-      return \"mad24\";\n-    case BRIG_OPCODE_MAD24HI:\n-      return \"mad24hi\";\n-    case BRIG_OPCODE_MUL24:\n-      return \"mul24\";\n-    case BRIG_OPCODE_MUL24HI:\n-      return \"mul24hi\";\n-    case BRIG_OPCODE_SHL:\n-      return \"shl\";\n-    case BRIG_OPCODE_SHR:\n-      return \"shr\";\n-    case BRIG_OPCODE_AND:\n-      return \"and\";\n-    case BRIG_OPCODE_NOT:\n-      return \"not\";\n-    case BRIG_OPCODE_OR:\n-      return \"or\";\n-    case BRIG_OPCODE_POPCOUNT:\n-      return \"popcount\";\n-    case BRIG_OPCODE_XOR:\n-      return \"xor\";\n-    case BRIG_OPCODE_BITEXTRACT:\n-      return \"bitextract\";\n-    case BRIG_OPCODE_BITINSERT:\n-      return \"bitinsert\";\n-    case BRIG_OPCODE_BITMASK:\n-      return \"bitmask\";\n-    case BRIG_OPCODE_BITREV:\n-      return \"bitrev\";\n-    case BRIG_OPCODE_BITSELECT:\n-      return \"bitselect\";\n-    case BRIG_OPCODE_FIRSTBIT:\n-      return \"firstbit\";\n-    case BRIG_OPCODE_LASTBIT:\n-      return \"lastbit\";\n-    case BRIG_OPCODE_COMBINE:\n-      return \"combine\";\n-    case BRIG_OPCODE_EXPAND:\n-      return \"expand\";\n-    case BRIG_OPCODE_LDA:\n-      return \"lda\";\n-    case BRIG_OPCODE_MOV:\n-      return \"mov\";\n-    case BRIG_OPCODE_SHUFFLE:\n-      return \"shuffle\";\n-    case BRIG_OPCODE_UNPACKHI:\n-      return \"unpackhi\";\n-    case BRIG_OPCODE_UNPACKLO:\n-      return \"unpacklo\";\n-    case BRIG_OPCODE_PACK:\n-      return \"pack\";\n-    case BRIG_OPCODE_UNPACK:\n-      return \"unpack\";\n-    case BRIG_OPCODE_CMOV:\n-      return \"cmov\";\n-    case BRIG_OPCODE_CLASS:\n-      return \"class\";\n-    case BRIG_OPCODE_NCOS:\n-      return \"ncos\";\n-    case BRIG_OPCODE_NEXP2:\n-      return \"nexp2\";\n-    case BRIG_OPCODE_NFMA:\n-      return \"nfma\";\n-    case BRIG_OPCODE_NLOG2:\n-      return \"nlog2\";\n-    case BRIG_OPCODE_NRCP:\n-      return \"nrcp\";\n-    case BRIG_OPCODE_NRSQRT:\n-      return \"nrsqrt\";\n-    case BRIG_OPCODE_NSIN:\n-      return \"nsin\";\n-    case BRIG_OPCODE_NSQRT:\n-      return \"nsqrt\";\n-    case BRIG_OPCODE_BITALIGN:\n-      return \"bitalign\";\n-    case BRIG_OPCODE_BYTEALIGN:\n-      return \"bytealign\";\n-    case BRIG_OPCODE_PACKCVT:\n-      return \"packcvt\";\n-    case BRIG_OPCODE_UNPACKCVT:\n-      return \"unpackcvt\";\n-    case BRIG_OPCODE_LERP:\n-      return \"lerp\";\n-    case BRIG_OPCODE_SAD:\n-      return \"sad\";\n-    case BRIG_OPCODE_SADHI:\n-      return \"sadhi\";\n-    case BRIG_OPCODE_SEGMENTP:\n-      return \"segmentp\";\n-    case BRIG_OPCODE_FTOS:\n-      return \"ftos\";\n-    case BRIG_OPCODE_STOF:\n-      return \"stof\";\n-    case BRIG_OPCODE_CMP:\n-      return \"cmp\";\n-    case BRIG_OPCODE_CVT:\n-      return \"cvt\";\n-    case BRIG_OPCODE_LD:\n-      return \"ld\";\n-    case BRIG_OPCODE_ST:\n-      return \"st\";\n-    case BRIG_OPCODE_ATOMIC:\n-      return \"atomic\";\n-    case BRIG_OPCODE_ATOMICNORET:\n-      return \"atomicnoret\";\n-    case BRIG_OPCODE_SIGNAL:\n-      return \"signal\";\n-    case BRIG_OPCODE_SIGNALNORET:\n-      return \"signalnoret\";\n-    case BRIG_OPCODE_MEMFENCE:\n-      return \"memfence\";\n-    case BRIG_OPCODE_RDIMAGE:\n-      return \"rdimage\";\n-    case BRIG_OPCODE_LDIMAGE:\n-      return \"ldimage\";\n-    case BRIG_OPCODE_STIMAGE:\n-      return \"stimage\";\n-    case BRIG_OPCODE_QUERYIMAGE:\n-      return \"queryimage\";\n-    case BRIG_OPCODE_QUERYSAMPLER:\n-      return \"querysampler\";\n-    case BRIG_OPCODE_CBR:\n-      return \"cbr\";\n-    case BRIG_OPCODE_BR:\n-      return \"br\";\n-    case BRIG_OPCODE_SBR:\n-      return \"sbr\";\n-    case BRIG_OPCODE_BARRIER:\n-      return \"barrier\";\n-    case BRIG_OPCODE_WAVEBARRIER:\n-      return \"wavebarrier\";\n-    case BRIG_OPCODE_ARRIVEFBAR:\n-      return \"arrivefbar\";\n-    case BRIG_OPCODE_INITFBAR:\n-      return \"initfbar\";\n-    case BRIG_OPCODE_JOINFBAR:\n-      return \"joinfbar\";\n-    case BRIG_OPCODE_LEAVEFBAR:\n-      return \"leavefbar\";\n-    case BRIG_OPCODE_RELEASEFBAR:\n-      return \"releasefbar\";\n-    case BRIG_OPCODE_WAITFBAR:\n-      return \"waitfbar\";\n-    case BRIG_OPCODE_LDF:\n-      return \"ldf\";\n-    case BRIG_OPCODE_ACTIVELANECOUNT:\n-      return \"activelanecount\";\n-    case BRIG_OPCODE_ACTIVELANEID:\n-      return \"activelaneid\";\n-    case BRIG_OPCODE_ACTIVELANEMASK:\n-      return \"activelanemask\";\n-    case BRIG_OPCODE_CALL:\n-      return \"call\";\n-    case BRIG_OPCODE_SCALL:\n-      return \"scall\";\n-    case BRIG_OPCODE_ICALL:\n-      return \"icall\";\n-    case BRIG_OPCODE_RET:\n-      return \"ret\";\n-    case BRIG_OPCODE_ALLOCA:\n-      return \"alloca\";\n-    case BRIG_OPCODE_CURRENTWORKGROUPSIZE:\n-      return \"currentworkgroupsize\";\n-    case BRIG_OPCODE_DIM:\n-      return \"dim\";\n-    case BRIG_OPCODE_GRIDGROUPS:\n-      return \"gridgroups\";\n-    case BRIG_OPCODE_GRIDSIZE:\n-      return \"gridsize\";\n-    case BRIG_OPCODE_PACKETCOMPLETIONSIG:\n-      return \"packetcompletionsig\";\n-    case BRIG_OPCODE_PACKETID:\n-      return \"packetid\";\n-    case BRIG_OPCODE_WORKGROUPID:\n-      return \"workgroupid\";\n-    case BRIG_OPCODE_WORKGROUPSIZE:\n-      return \"workgroupsize\";\n-    case BRIG_OPCODE_WORKITEMABSID:\n-      return \"workitemabsid\";\n-    case BRIG_OPCODE_WORKITEMFLATABSID:\n-      return \"workitemflatabsid\";\n-    case BRIG_OPCODE_WORKITEMFLATID:\n-      return \"workitemflatid\";\n-    case BRIG_OPCODE_WORKITEMID:\n-      return \"workitemid\";\n-    case BRIG_OPCODE_CLEARDETECTEXCEPT:\n-      return \"cleardetectexcept\";\n-    case BRIG_OPCODE_GETDETECTEXCEPT:\n-      return \"getdetectexcept\";\n-    case BRIG_OPCODE_SETDETECTEXCEPT:\n-      return \"setdetectexcept\";\n-    case BRIG_OPCODE_ADDQUEUEWRITEINDEX:\n-      return \"addqueuewriteindex\";\n-    case BRIG_OPCODE_CASQUEUEWRITEINDEX:\n-      return \"casqueuewriteindex\";\n-    case BRIG_OPCODE_LDQUEUEREADINDEX:\n-      return \"ldqueuereadindex\";\n-    case BRIG_OPCODE_LDQUEUEWRITEINDEX:\n-      return \"ldqueuewriteindex\";\n-    case BRIG_OPCODE_STQUEUEREADINDEX:\n-      return \"stqueuereadindex\";\n-    case BRIG_OPCODE_STQUEUEWRITEINDEX:\n-      return \"stqueuewriteindex\";\n-    case BRIG_OPCODE_CLOCK:\n-      return \"clock\";\n-    case BRIG_OPCODE_CUID:\n-      return \"cuid\";\n-    case BRIG_OPCODE_DEBUGTRAP:\n-      return \"debugtrap\";\n-    case BRIG_OPCODE_GROUPBASEPTR:\n-      return \"groupbaseptr\";\n-    case BRIG_OPCODE_KERNARGBASEPTR:\n-      return \"kernargbaseptr\";\n-    case BRIG_OPCODE_LANEID:\n-      return \"laneid\";\n-    case BRIG_OPCODE_MAXCUID:\n-      return \"maxcuid\";\n-    case BRIG_OPCODE_MAXWAVEID:\n-      return \"maxwaveid\";\n-    case BRIG_OPCODE_NULLPTR:\n-      return \"nullptr\";\n-    case BRIG_OPCODE_WAVEID:\n-      return \"waveid\";\n-    default:\n-      return \"UNKNOWN_OPCODE\";\n-    }\n-}\n-\n-/* Return textual name of SEG.  */\n-\n-const char *\n-hsa_seg_name (BrigSegment8_t seg)\n-{\n-  switch (seg)\n-    {\n-    case BRIG_SEGMENT_NONE:\n-      return \"none\";\n-    case BRIG_SEGMENT_FLAT:\n-      return \"flat\";\n-    case BRIG_SEGMENT_GLOBAL:\n-      return \"global\";\n-    case BRIG_SEGMENT_READONLY:\n-      return \"readonly\";\n-    case BRIG_SEGMENT_KERNARG:\n-      return \"kernarg\";\n-    case BRIG_SEGMENT_GROUP:\n-      return \"group\";\n-    case BRIG_SEGMENT_PRIVATE:\n-      return \"private\";\n-    case BRIG_SEGMENT_SPILL:\n-      return \"spill\";\n-    case BRIG_SEGMENT_ARG:\n-      return \"arg\";\n-    default:\n-      return \"UNKNOWN_SEGMENT\";\n-    }\n-}\n-\n-/* Return textual name of CMPOP.  */\n-\n-static const char *\n-hsa_cmpop_name (BrigCompareOperation8_t cmpop)\n-{\n-  switch (cmpop)\n-    {\n-    case BRIG_COMPARE_EQ:\n-      return \"eq\";\n-    case BRIG_COMPARE_NE:\n-      return \"ne\";\n-    case BRIG_COMPARE_LT:\n-      return \"lt\";\n-    case BRIG_COMPARE_LE:\n-      return \"le\";\n-    case BRIG_COMPARE_GT:\n-      return \"gt\";\n-    case BRIG_COMPARE_GE:\n-      return \"ge\";\n-    case BRIG_COMPARE_EQU:\n-      return \"equ\";\n-    case BRIG_COMPARE_NEU:\n-      return \"neu\";\n-    case BRIG_COMPARE_LTU:\n-      return \"ltu\";\n-    case BRIG_COMPARE_LEU:\n-      return \"leu\";\n-    case BRIG_COMPARE_GTU:\n-      return \"gtu\";\n-    case BRIG_COMPARE_GEU:\n-      return \"geu\";\n-    case BRIG_COMPARE_NUM:\n-      return \"num\";\n-    case BRIG_COMPARE_NAN:\n-      return \"nan\";\n-    case BRIG_COMPARE_SEQ:\n-      return \"seq\";\n-    case BRIG_COMPARE_SNE:\n-      return \"sne\";\n-    case BRIG_COMPARE_SLT:\n-      return \"slt\";\n-    case BRIG_COMPARE_SLE:\n-      return \"sle\";\n-    case BRIG_COMPARE_SGT:\n-      return \"sgt\";\n-    case BRIG_COMPARE_SGE:\n-      return \"sge\";\n-    case BRIG_COMPARE_SGEU:\n-      return \"sgeu\";\n-    case BRIG_COMPARE_SEQU:\n-      return \"sequ\";\n-    case BRIG_COMPARE_SNEU:\n-      return \"sneu\";\n-    case BRIG_COMPARE_SLTU:\n-      return \"sltu\";\n-    case BRIG_COMPARE_SLEU:\n-      return \"sleu\";\n-    case BRIG_COMPARE_SNUM:\n-      return \"snum\";\n-    case BRIG_COMPARE_SNAN:\n-      return \"snan\";\n-    case BRIG_COMPARE_SGTU:\n-      return \"sgtu\";\n-    default:\n-      return \"UNKNOWN_COMPARISON\";\n-    }\n-}\n-\n-/* Return textual name for memory order.  */\n-\n-static const char *\n-hsa_memsem_name (enum BrigMemoryOrder mo)\n-{\n-  switch (mo)\n-    {\n-    case BRIG_MEMORY_ORDER_NONE:\n-      return \"\";\n-    case BRIG_MEMORY_ORDER_RELAXED:\n-      return \"rlx\";\n-    case BRIG_MEMORY_ORDER_SC_ACQUIRE:\n-      return \"scacq\";\n-    case BRIG_MEMORY_ORDER_SC_RELEASE:\n-      return \"screl\";\n-    case BRIG_MEMORY_ORDER_SC_ACQUIRE_RELEASE:\n-      return \"scar\";\n-    default:\n-      return \"UNKNOWN_MEMORY_ORDER\";\n-    }\n-}\n-\n-/* Return textual name for memory scope.  */\n-\n-static const char *\n-hsa_memscope_name (enum BrigMemoryScope scope)\n-{\n-  switch (scope)\n-    {\n-    case BRIG_MEMORY_SCOPE_NONE:\n-      return \"\";\n-    case BRIG_MEMORY_SCOPE_WORKITEM:\n-      return \"wi\";\n-    case BRIG_MEMORY_SCOPE_WAVEFRONT:\n-      return \"wave\";\n-    case BRIG_MEMORY_SCOPE_WORKGROUP:\n-      return \"wg\";\n-    case BRIG_MEMORY_SCOPE_AGENT:\n-      return \"agent\";\n-    case BRIG_MEMORY_SCOPE_SYSTEM:\n-      return \"sys\";\n-    default:\n-      return \"UNKNOWN_SCOPE\";\n-    }\n-}\n-\n-/* Return textual name for atomic operation.  */\n-\n-static const char *\n-hsa_m_atomicop_name (enum BrigAtomicOperation op)\n-{\n-  switch (op)\n-    {\n-    case BRIG_ATOMIC_ADD:\n-      return \"add\";\n-    case BRIG_ATOMIC_AND:\n-      return \"and\";\n-    case BRIG_ATOMIC_CAS:\n-      return \"cas\";\n-    case BRIG_ATOMIC_EXCH:\n-      return \"exch\";\n-    case BRIG_ATOMIC_LD:\n-      return \"ld\";\n-    case BRIG_ATOMIC_MAX:\n-      return \"max\";\n-    case BRIG_ATOMIC_MIN:\n-      return \"min\";\n-    case BRIG_ATOMIC_OR:\n-      return \"or\";\n-    case BRIG_ATOMIC_ST:\n-      return \"st\";\n-    case BRIG_ATOMIC_SUB:\n-      return \"sub\";\n-    case BRIG_ATOMIC_WRAPDEC:\n-      return \"wrapdec\";\n-    case BRIG_ATOMIC_WRAPINC:\n-      return \"wrapinc\";\n-    case BRIG_ATOMIC_XOR:\n-      return \"xor\";\n-    case BRIG_ATOMIC_WAIT_EQ:\n-      return \"wait_eq\";\n-    case BRIG_ATOMIC_WAIT_NE:\n-      return \"wait_ne\";\n-    case BRIG_ATOMIC_WAIT_LT:\n-      return \"wait_lt\";\n-    case BRIG_ATOMIC_WAIT_GTE:\n-      return \"wait_gte\";\n-    case BRIG_ATOMIC_WAITTIMEOUT_EQ:\n-      return \"waittimeout_eq\";\n-    case BRIG_ATOMIC_WAITTIMEOUT_NE:\n-      return \"waittimeout_ne\";\n-    case BRIG_ATOMIC_WAITTIMEOUT_LT:\n-      return \"waittimeout_lt\";\n-    case BRIG_ATOMIC_WAITTIMEOUT_GTE:\n-      return \"waittimeout_gte\";\n-    default:\n-      return \"UNKNOWN_ATOMIC_OP\";\n-    }\n-}\n-\n-/* Return textual name for atomic operation.  */\n-\n-static const char *\n-hsa_width_specifier_name (BrigWidth8_t width)\n-{\n-  switch (width)\n-    {\n-    case BRIG_WIDTH_NONE:\n-      return \"none\";\n-    case BRIG_WIDTH_1:\n-      return \"1\";\n-    case BRIG_WIDTH_2:\n-      return \"2\";\n-    case BRIG_WIDTH_4:\n-      return \"4\";\n-    case BRIG_WIDTH_8:\n-      return \"8\";\n-    case BRIG_WIDTH_16:\n-      return \"16\";\n-    case BRIG_WIDTH_32:\n-      return \"32\";\n-    case BRIG_WIDTH_64:\n-      return \"64\";\n-    case BRIG_WIDTH_128:\n-      return \"128\";\n-    case BRIG_WIDTH_256:\n-      return \"256\";\n-    case BRIG_WIDTH_512:\n-      return \"512\";\n-    case BRIG_WIDTH_1024:\n-      return \"1024\";\n-    case BRIG_WIDTH_2048:\n-      return \"2048\";\n-    case BRIG_WIDTH_4096:\n-      return \"4096\";\n-    case BRIG_WIDTH_8192:\n-      return \"8192\";\n-    case BRIG_WIDTH_16384:\n-      return \"16384\";\n-    case BRIG_WIDTH_32768:\n-      return \"32768\";\n-    case BRIG_WIDTH_65536:\n-      return \"65536\";\n-    case BRIG_WIDTH_131072:\n-      return \"131072\";\n-    case BRIG_WIDTH_262144:\n-      return \"262144\";\n-    case BRIG_WIDTH_524288:\n-      return \"524288\";\n-    case BRIG_WIDTH_1048576:\n-      return \"1048576\";\n-    case BRIG_WIDTH_2097152:\n-      return \"2097152\";\n-    case BRIG_WIDTH_4194304:\n-      return \"4194304\";\n-    case BRIG_WIDTH_8388608:\n-      return \"8388608\";\n-    case BRIG_WIDTH_16777216:\n-      return \"16777216\";\n-    case BRIG_WIDTH_33554432:\n-      return \"33554432\";\n-    case BRIG_WIDTH_67108864:\n-      return \"67108864\";\n-    case BRIG_WIDTH_134217728:\n-      return \"134217728\";\n-    case BRIG_WIDTH_268435456:\n-      return \"268435456\";\n-    case BRIG_WIDTH_536870912:\n-      return \"536870912\";\n-    case BRIG_WIDTH_1073741824:\n-      return \"1073741824\";\n-    case BRIG_WIDTH_2147483648:\n-      return \"2147483648\";\n-    case BRIG_WIDTH_WAVESIZE:\n-      return \"wavesize\";\n-    case BRIG_WIDTH_ALL:\n-      return \"all\";\n-    default:\n-      return \"UNKNOWN_WIDTH\";\n-    }\n-}\n-\n-/* Dump textual representation of HSA IL register REG to file F.  */\n-\n-static void\n-dump_hsa_reg (FILE *f, hsa_op_reg *reg, bool dump_type = false)\n-{\n-  if (reg->m_reg_class)\n-    fprintf (f, \"$%c%i\", reg->m_reg_class, reg->m_hard_num);\n-  else\n-    fprintf (f, \"$_%i\", reg->m_order);\n-  if (dump_type)\n-    fprintf (f, \" (%s)\", hsa_type_name (reg->m_type));\n-}\n-\n-/* Dump textual representation of HSA IL immediate operand IMM to file F.  */\n-\n-static void\n-dump_hsa_immed (FILE *f, hsa_op_immed *imm)\n-{\n-  bool unsigned_int_type\n-    = (BRIG_TYPE_U8 | BRIG_TYPE_U16 | BRIG_TYPE_U32 | BRIG_TYPE_U64)\n-    & imm->m_type;\n-\n-  if (imm->m_tree_value)\n-    print_generic_expr (f, imm->m_tree_value);\n-  else\n-    {\n-      if (unsigned_int_type)\n-\tfprintf (f, HOST_WIDE_INT_PRINT_DEC, imm->m_int_value);\n-      else\n-\tfprintf (f, HOST_WIDE_INT_PRINT_UNSIGNED,\n-\t\t (unsigned HOST_WIDE_INT) imm->m_int_value);\n-    }\n-\n-  fprintf (f, \" (%s)\", hsa_type_name (imm->m_type));\n-}\n-\n-/* Dump textual representation of HSA IL address operand ADDR to file F.  */\n-\n-static void\n-dump_hsa_address (FILE *f, hsa_op_address *addr)\n-{\n-  bool sth = false;\n-\n-  if (addr->m_symbol)\n-    {\n-      sth = true;\n-      if (addr->m_symbol->m_name)\n-\tfprintf (f, \"[%%%s]\", addr->m_symbol->m_name);\n-      else\n-\tfprintf (f, \"[%%__%s_%i]\", hsa_seg_name (addr->m_symbol->m_segment),\n-\t\t addr->m_symbol->m_name_number);\n-    }\n-\n-  if (addr->m_reg)\n-    {\n-      fprintf (f, \"[\");\n-      dump_hsa_reg (f, addr->m_reg);\n-      if (addr->m_imm_offset != 0)\n-\tfprintf (f, \" + \" HOST_WIDE_INT_PRINT_DEC \"]\", addr->m_imm_offset);\n-      else\n-\tfprintf (f, \"]\");\n-    }\n-  else if (!sth || addr->m_imm_offset != 0)\n-    fprintf (f, \"[\" HOST_WIDE_INT_PRINT_DEC \"]\", addr->m_imm_offset);\n-}\n-\n-/* Dump textual representation of HSA IL symbol SYMBOL to file F.  */\n-\n-static void\n-dump_hsa_symbol (FILE *f, hsa_symbol *symbol)\n-{\n-  const char *name;\n-  char buf[64];\n-  if (symbol->m_name)\n-    name = symbol->m_name;\n-  else\n-    {\n-      sprintf (buf, \"__%s_%i\", hsa_seg_name (symbol->m_segment),\n-\t       symbol->m_name_number);\n-\n-      name = buf;\n-    }\n-\n-  fprintf (f, \"align(%u) %s_%s %s\", hsa_byte_alignment (symbol->m_align),\n-\t   hsa_seg_name (symbol->m_segment),\n-\t   hsa_type_name (symbol->m_type & ~BRIG_TYPE_ARRAY_MASK), name);\n-\n-  if (symbol->m_type & BRIG_TYPE_ARRAY_MASK)\n-    fprintf (f, \"[%lu]\", (unsigned long) symbol->m_dim);\n-\n-  if (symbol->m_directive_offset)\n-    fprintf (f, \"             /* BRIG offset: %u */\", symbol->m_directive_offset);\n-}\n-\n-/* Dump textual representation of HSA IL operand OP to file F.  */\n-\n-static void\n-dump_hsa_operand (FILE *f, hsa_op_base *op, bool dump_reg_type = false)\n-{\n-  if (is_a <hsa_op_immed *> (op))\n-    dump_hsa_immed (f, as_a <hsa_op_immed *> (op));\n-  else if (is_a <hsa_op_reg *> (op))\n-    dump_hsa_reg (f, as_a <hsa_op_reg *> (op), dump_reg_type);\n-  else if (is_a <hsa_op_address *> (op))\n-    dump_hsa_address (f, as_a <hsa_op_address *> (op));\n-  else\n-    fprintf (f, \"UNKNOWN_OP_KIND\");\n-}\n-\n-/* Dump textual representation of HSA IL operands in VEC to file F.  */\n-\n-static void\n-dump_hsa_operands (FILE *f, hsa_insn_basic *insn, int start = 0,\n-\t\t   int end = -1, bool dump_reg_type = false)\n-{\n-  if (end == -1)\n-    end = insn->operand_count ();\n-\n-  for (int i = start; i < end; i++)\n-    {\n-      dump_hsa_operand (f, insn->get_op (i), dump_reg_type);\n-      if (i != end - 1)\n-\tfprintf (f, \", \");\n-    }\n-}\n-\n-/* Indent F stream with INDENT spaces.  */\n-\n-static void indent_stream (FILE *f, int indent)\n-{\n-  for (int i = 0; i < indent; i++)\n-    fputc (' ', f);\n-}\n-\n-/* Dump textual representation of HSA IL instruction INSN to file F.  Prepend\n-   the instruction with *INDENT spaces and adjust the indentation for call\n-   instructions as appropriate.  */\n-\n-static void\n-dump_hsa_insn_1 (FILE *f, hsa_insn_basic *insn, int *indent)\n-{\n-  gcc_checking_assert (insn);\n-\n-  if (insn->m_number)\n-    fprintf (f, \"%5d: \", insn->m_number);\n-\n-  indent_stream (f, *indent);\n-\n-  if (is_a <hsa_insn_phi *> (insn))\n-    {\n-      hsa_insn_phi *phi = as_a <hsa_insn_phi *> (insn);\n-      bool first = true;\n-      dump_hsa_reg (f, phi->m_dest, true);\n-      fprintf (f, \" = PHI <\");\n-      unsigned count = phi->operand_count ();\n-      for (unsigned i = 0; i < count; i++)\n-\t{\n-\t  if (!phi->get_op (i))\n-\t    break;\n-\t  if (!first)\n-\t    fprintf (f, \", \");\n-\t  else\n-\t    first = false;\n-\t  dump_hsa_operand (f, phi->get_op (i), true);\n-\t}\n-      fprintf (f, \">\");\n-    }\n-  else if (is_a <hsa_insn_signal *> (insn))\n-    {\n-      hsa_insn_signal *mem = as_a <hsa_insn_signal *> (insn);\n-\n-      fprintf (f, \"%s\", hsa_opcode_name (mem->m_opcode));\n-      fprintf (f, \"_%s\", hsa_m_atomicop_name (mem->m_signalop));\n-      if (mem->m_memory_order != BRIG_MEMORY_ORDER_NONE)\n-\tfprintf (f, \"_%s\", hsa_memsem_name (mem->m_memory_order));\n-      fprintf (f, \"_%s \", hsa_type_name (mem->m_type));\n-\n-      dump_hsa_operands (f, mem);\n-    }\n-\n-  else if (is_a <hsa_insn_atomic *> (insn))\n-    {\n-      hsa_insn_atomic *mem = as_a <hsa_insn_atomic *> (insn);\n-\n-      /* Either operand[0] or operand[1] must be an address operand.  */\n-      hsa_op_address *addr = NULL;\n-      if (is_a <hsa_op_address *> (mem->get_op (0)))\n-\taddr = as_a <hsa_op_address *> (mem->get_op (0));\n-      else\n-\taddr = as_a <hsa_op_address *> (mem->get_op (1));\n-\n-      fprintf (f, \"%s\", hsa_opcode_name (mem->m_opcode));\n-      fprintf (f, \"_%s\", hsa_m_atomicop_name (mem->m_atomicop));\n-      if (addr->m_symbol)\n-\tfprintf (f, \"_%s\", hsa_seg_name (addr->m_symbol->m_segment));\n-      if (mem->m_memoryorder != BRIG_MEMORY_ORDER_NONE)\n-\tfprintf (f, \"_%s\", hsa_memsem_name (mem->m_memoryorder));\n-      if (mem->m_memoryscope != BRIG_MEMORY_SCOPE_NONE)\n-\tfprintf (f, \"_%s\", hsa_memscope_name (mem->m_memoryscope));\n-      fprintf (f, \"_%s \", hsa_type_name (mem->m_type));\n-\n-      dump_hsa_operands (f, mem);\n-    }\n-  else if (is_a <hsa_insn_mem *> (insn))\n-    {\n-      hsa_insn_mem *mem = as_a <hsa_insn_mem *> (insn);\n-      hsa_op_address *addr = as_a <hsa_op_address *> (mem->get_op (1));\n-\n-      fprintf (f, \"%s\", hsa_opcode_name (mem->m_opcode));\n-      if (addr->m_symbol)\n-\tfprintf (f, \"_%s\", hsa_seg_name (addr->m_symbol->m_segment));\n-      if (mem->m_align != BRIG_ALIGNMENT_NONE)\n-\tfprintf (f, \"_align(%u)\", hsa_byte_alignment (mem->m_align));\n-      if (mem->m_equiv_class != 0)\n-\tfprintf (f, \"_equiv(%i)\", mem->m_equiv_class);\n-      fprintf (f, \"_%s \", hsa_type_name (mem->m_type));\n-\n-      dump_hsa_operand (f, mem->get_op (0));\n-      fprintf (f, \", \");\n-      dump_hsa_address (f, addr);\n-    }\n-  else if (insn->m_opcode == BRIG_OPCODE_LDA)\n-    {\n-      hsa_op_address *addr = as_a <hsa_op_address *> (insn->get_op (1));\n-\n-      fprintf (f, \"%s\", hsa_opcode_name (insn->m_opcode));\n-      if (addr->m_symbol)\n-\tfprintf (f, \"_%s\", hsa_seg_name (addr->m_symbol->m_segment));\n-      fprintf (f, \"_%s \", hsa_type_name (insn->m_type));\n-\n-      dump_hsa_operand (f, insn->get_op (0));\n-      fprintf (f, \", \");\n-      dump_hsa_address (f, addr);\n-    }\n-  else if (is_a <hsa_insn_seg *> (insn))\n-    {\n-      hsa_insn_seg *seg = as_a <hsa_insn_seg *> (insn);\n-      fprintf (f, \"%s_%s_%s_%s \", hsa_opcode_name (seg->m_opcode),\n-\t       hsa_seg_name (seg->m_segment),\n-\t       hsa_type_name (seg->m_type), hsa_type_name (seg->m_src_type));\n-      dump_hsa_reg (f, as_a <hsa_op_reg *> (seg->get_op (0)));\n-      fprintf (f, \", \");\n-      dump_hsa_operand (f, seg->get_op (1));\n-    }\n-  else if (is_a <hsa_insn_cmp *> (insn))\n-    {\n-      hsa_insn_cmp *cmp = as_a <hsa_insn_cmp *> (insn);\n-      BrigType16_t src_type;\n-\n-      if (is_a <hsa_op_reg *> (cmp->get_op (1)))\n-\tsrc_type = as_a <hsa_op_reg *> (cmp->get_op (1))->m_type;\n-      else\n-\tsrc_type = as_a <hsa_op_immed *> (cmp->get_op (1))->m_type;\n-\n-      fprintf (f, \"%s_%s_%s_%s \", hsa_opcode_name (cmp->m_opcode),\n-\t       hsa_cmpop_name (cmp->m_compare),\n-\t       hsa_type_name (cmp->m_type), hsa_type_name (src_type));\n-      dump_hsa_reg (f, as_a <hsa_op_reg *> (cmp->get_op (0)));\n-      fprintf (f, \", \");\n-      dump_hsa_operand (f, cmp->get_op (1));\n-      fprintf (f, \", \");\n-      dump_hsa_operand (f, cmp->get_op (2));\n-    }\n-  else if (is_a <hsa_insn_cbr *> (insn))\n-    {\n-      hsa_insn_cbr *br = as_a <hsa_insn_cbr *> (insn);\n-      basic_block target = NULL;\n-      edge_iterator ei;\n-      edge e;\n-\n-      fprintf (f, \"%s \", hsa_opcode_name (br->m_opcode));\n-      if (br->m_opcode == BRIG_OPCODE_CBR)\n-\t{\n-\t  dump_hsa_reg (f, as_a <hsa_op_reg *> (br->get_op (0)));\n-\t  fprintf (f, \", \");\n-\t}\n-\n-      FOR_EACH_EDGE (e, ei, br->m_bb->succs)\n-\tif (e->flags & EDGE_TRUE_VALUE)\n-\t  {\n-\t    target = e->dest;\n-\t    break;\n-\t  }\n-      fprintf (f, \"BB %i\", hsa_bb_for_bb (target)->m_index);\n-    }\n-  else if (is_a <hsa_insn_sbr *> (insn))\n-    {\n-      hsa_insn_sbr *sbr = as_a <hsa_insn_sbr *> (insn);\n-\n-      fprintf (f, \"%s \", hsa_opcode_name (sbr->m_opcode));\n-      dump_hsa_reg (f, as_a <hsa_op_reg *> (sbr->get_op (0)));\n-      fprintf (f, \", [\");\n-\n-      for (unsigned i = 0; i < sbr->m_jump_table.length (); i++)\n-\t{\n-\t  fprintf (f, \"BB %i\", hsa_bb_for_bb (sbr->m_jump_table[i])->m_index);\n-\t  if (i != sbr->m_jump_table.length () - 1)\n-\t    fprintf (f, \", \");\n-\t}\n-    }\n-  else if (is_a <hsa_insn_br *> (insn))\n-    {\n-      hsa_insn_br *br = as_a <hsa_insn_br *> (insn);\n-      fprintf (f, \"%s_width(%s) \", hsa_opcode_name (br->m_opcode),\n-\t       hsa_width_specifier_name (br->m_width));\n-    }\n-  else if (is_a <hsa_insn_arg_block *> (insn))\n-    {\n-      hsa_insn_arg_block *arg_block = as_a <hsa_insn_arg_block *> (insn);\n-      bool start_p = arg_block->m_kind == BRIG_KIND_DIRECTIVE_ARG_BLOCK_START;\n-      char c = start_p ? '{' : '}';\n-\n-      if (start_p)\n-\t{\n-\t  *indent += 2;\n-\t  indent_stream (f, 2);\n-\t}\n-\n-      if (!start_p)\n-\t*indent -= 2;\n-\n-      fprintf (f, \"%c\", c);\n-    }\n-  else if (is_a <hsa_insn_call *> (insn))\n-    {\n-      hsa_insn_call *call = as_a <hsa_insn_call *> (insn);\n-      if (call->m_called_function)\n-\t{\n-\t  const char *name = hsa_get_declaration_name (call->m_called_function);\n-\t  fprintf (f, \"call &%s\", name);\n-\t}\n-      else\n-\t{\n-\t  char *name = call->m_called_internal_fn->name ();\n-\t  fprintf (f, \"call &%s\", name);\n-\t  free (name);\n-\t}\n-\n-      if (call->m_output_arg)\n-\tfprintf (f, \"(%%res) \");\n-\n-      fprintf (f, \"(\");\n-      for (unsigned i = 0; i < call->m_input_args.length (); i++)\n-\t{\n-\t  fprintf (f, \"%%__arg_%u\", i);\n-\n-\t  if (i != call->m_input_args.length () - 1)\n-\t    fprintf (f, \", \");\n-\t}\n-      fprintf (f, \")\");\n-    }\n-  else if (is_a <hsa_insn_comment *> (insn))\n-    {\n-      hsa_insn_comment *c = as_a <hsa_insn_comment *> (insn);\n-      fprintf (f, \"%s\", c->m_comment);\n-    }\n-  else if (is_a <hsa_insn_srctype *> (insn))\n-    {\n-      hsa_insn_srctype *srctype = as_a <hsa_insn_srctype *> (insn);\n-\n-      fprintf (f, \"%s_%s_%s \", hsa_opcode_name (srctype->m_opcode),\n-\t       hsa_type_name (srctype->m_type),\n-\t       hsa_type_name (srctype->m_source_type));\n-\n-      dump_hsa_operands (f, insn);\n-    }\n-  else if (is_a <hsa_insn_packed *> (insn))\n-    {\n-      hsa_insn_packed *packed = as_a <hsa_insn_packed *> (insn);\n-\n-      fprintf (f, \"%s_v%u_%s_%s \", hsa_opcode_name (packed->m_opcode),\n-\t       packed->operand_count () - 1,\n-\t       hsa_type_name (packed->m_type),\n-\t       hsa_type_name (packed->m_source_type));\n-\n-      if (packed->m_opcode == BRIG_OPCODE_COMBINE)\n-\t{\n-\t  dump_hsa_operand (f, insn->get_op (0));\n-\t  fprintf (f, \", (\");\n-\t  dump_hsa_operands (f, insn, 1);\n-\t  fprintf (f, \")\");\n-\t}\n-      else if (packed->m_opcode == BRIG_OPCODE_EXPAND)\n-\t{\n-\t  fprintf (f, \"(\");\n-\t  dump_hsa_operands (f, insn, 0, insn->operand_count () - 1);\n-\t  fprintf (f, \"), \");\n-\t  dump_hsa_operand (f, insn->get_op (insn->operand_count () - 1));\n-\n-\t}\n-      else\n-\tgcc_unreachable ();\n-    }\n-  else if (is_a <hsa_insn_alloca *> (insn))\n-    {\n-      hsa_insn_alloca *alloca = as_a <hsa_insn_alloca *> (insn);\n-\n-      fprintf (f, \"%s_align(%u)_%s \", hsa_opcode_name (insn->m_opcode),\n-\t       hsa_byte_alignment (alloca->m_align),\n-\t       hsa_type_name (insn->m_type));\n-\n-      dump_hsa_operands (f, insn);\n-    }\n-  else if (hsa_insn_queue *qi = dyn_cast <hsa_insn_queue *> (insn))\n-    {\n-      fprintf (f, \"%s_%s_%s_%s \", hsa_opcode_name (qi->m_opcode),\n-\t       hsa_seg_name (qi->m_segment),\n-\t       hsa_memsem_name (qi->m_memory_order),\n-\t       hsa_type_name (qi->m_type));\n-\n-      dump_hsa_operands (f, qi);\n-    }\n-  else\n-    {\n-      fprintf (f, \"%s_%s \", hsa_opcode_name (insn->m_opcode),\n-\t       hsa_type_name (insn->m_type));\n-\n-      dump_hsa_operands (f, insn);\n-    }\n-\n-  if (insn->m_brig_offset)\n-    {\n-      fprintf (f, \"             /* BRIG offset: %u\", insn->m_brig_offset);\n-\n-      for (unsigned i = 0; i < insn->operand_count (); i++)\n-\tfprintf (f, \", op%u: %u\", i, insn->get_op (i)->m_brig_op_offset);\n-\n-      fprintf (f, \" */\");\n-    }\n-\n-  fprintf (f, \"\\n\");\n-}\n-\n-/* Dump textual representation of HSA IL instruction INSN to file F.  */\n-\n-void\n-dump_hsa_insn (FILE *f, hsa_insn_basic *insn)\n-{\n-  int indent = 0;\n-  dump_hsa_insn_1 (f, insn, &indent);\n-}\n-\n-/* Dump textual representation of HSA IL in HBB to file F.  */\n-\n-void\n-dump_hsa_bb (FILE *f, hsa_bb *hbb)\n-{\n-  hsa_insn_basic *insn;\n-  edge_iterator ei;\n-  edge e;\n-  basic_block true_bb = NULL, other = NULL;\n-\n-  fprintf (f, \"BB %i:\\n\", hbb->m_index);\n-\n-  int indent = 2;\n-  for (insn = hbb->m_first_phi; insn; insn = insn->m_next)\n-    dump_hsa_insn_1 (f, insn, &indent);\n-\n-  for (insn = hbb->m_first_insn; insn; insn = insn->m_next)\n-    dump_hsa_insn_1 (f, insn, &indent);\n-\n-  if (hbb->m_last_insn && is_a <hsa_insn_sbr *> (hbb->m_last_insn))\n-    goto exit;\n-\n-  FOR_EACH_EDGE (e, ei, hbb->m_bb->succs)\n-    if (e->flags & EDGE_TRUE_VALUE)\n-      {\n-\tgcc_assert (!true_bb);\n-\ttrue_bb = e->dest;\n-      }\n-    else\n-      {\n-\tgcc_assert (!other);\n-\tother = e->dest;\n-      }\n-\n-  if (true_bb)\n-    {\n-      if (!hbb->m_last_insn\n-\t  || hbb->m_last_insn->m_opcode != BRIG_OPCODE_CBR)\n-\tfprintf (f, \"WARNING: No branch insn for a true edge. \\n\");\n-    }\n-  else if (hbb->m_last_insn\n-\t   && hbb->m_last_insn->m_opcode == BRIG_OPCODE_CBR)\n-    fprintf (f, \"WARNING: No true edge for a cbr statement\\n\");\n-\n-  if (other && other->aux)\n-    fprintf (f, \"  Fall-through to BB %i\\n\",\n-\t     hsa_bb_for_bb (other)->m_index);\n-  else if (hbb->m_last_insn\n-\t   && hbb->m_last_insn->m_opcode != BRIG_OPCODE_RET)\n-    fprintf (f, \"  WARNING: Fall through to a BB with no aux!\\n\");\n-\n-exit:\n-  fprintf (f, \"\\n\");\n-}\n-\n-/* Dump textual representation of HSA IL of the current function to file F.  */\n-\n-void\n-dump_hsa_cfun (FILE *f)\n-{\n-  basic_block bb;\n-\n-  if (hsa_cfun->m_global_symbols.length () > 0)\n-    fprintf (f, \"\\nHSAIL in global scope\\n\");\n-\n-  for (unsigned i = 0; i < hsa_cfun->m_global_symbols.length (); i++)\n-    {\n-      fprintf (f, \"  \");\n-      dump_hsa_symbol (f, hsa_cfun->m_global_symbols[i]);\n-      fprintf (f, \"\\n\");\n-    }\n-\n-  fprintf (f, \"\\nHSAIL IL for %s\\n\", hsa_cfun->m_name);\n-\n-  for (unsigned i = 0; i < hsa_cfun->m_private_variables.length (); i++)\n-    {\n-      fprintf (f, \"  \");\n-      dump_hsa_symbol (f, hsa_cfun->m_private_variables[i]);\n-      fprintf (f, \"\\n\");\n-    }\n-\n-  FOR_ALL_BB_FN (bb, cfun)\n-    {\n-      hsa_bb *hbb = (class hsa_bb *) bb->aux;\n-      dump_hsa_bb (f, hbb);\n-    }\n-}\n-\n-/* Dump textual representation of HSA IL instruction INSN to stderr.  */\n-\n-DEBUG_FUNCTION void\n-debug_hsa_insn (hsa_insn_basic *insn)\n-{\n-  dump_hsa_insn (stderr, insn);\n-}\n-\n-/* Dump textual representation of HSA IL in HBB to stderr.  */\n-\n-DEBUG_FUNCTION void\n-debug_hsa_bb (hsa_bb *hbb)\n-{\n-  dump_hsa_bb (stderr, hbb);\n-}\n-\n-/* Dump textual representation of HSA IL of the current function to stderr.  */\n-\n-DEBUG_FUNCTION void\n-debug_hsa_cfun (void)\n-{\n-  dump_hsa_cfun (stderr);\n-}\n-\n-/* Dump textual representation of an HSA operand to stderr.  */\n-\n-DEBUG_FUNCTION void\n-debug_hsa_operand (hsa_op_base *opc)\n-{\n-  dump_hsa_operand (stderr, opc, true);\n-  fprintf (stderr, \"\\n\");\n-}\n-\n-/* Dump textual representation of as HSA symbol.  */\n-\n-DEBUG_FUNCTION void\n-debug_hsa_symbol (hsa_symbol *symbol)\n-{\n-  dump_hsa_symbol (stderr, symbol);\n-  fprintf (stderr, \"\\n\");\n-}"}, {"sha": "2af999048b22014c43494775d7c30c65ae85ab17", "filename": "gcc/hsa-gen.c", "status": "removed", "additions": 0, "deletions": 6694, "changes": 6694, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9623f61b142174b87760c81f78928dd14af7cbc6/gcc%2Fhsa-gen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9623f61b142174b87760c81f78928dd14af7cbc6/gcc%2Fhsa-gen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhsa-gen.c?ref=9623f61b142174b87760c81f78928dd14af7cbc6"}, {"sha": "7614efea209f70b35c5751ce99573336e6d3f3d8", "filename": "gcc/hsa-regalloc.c", "status": "removed", "additions": 0, "deletions": 729, "changes": 729, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9623f61b142174b87760c81f78928dd14af7cbc6/gcc%2Fhsa-regalloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9623f61b142174b87760c81f78928dd14af7cbc6/gcc%2Fhsa-regalloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhsa-regalloc.c?ref=9623f61b142174b87760c81f78928dd14af7cbc6", "patch": "@@ -1,729 +0,0 @@\n-/* HSAIL IL Register allocation and out-of-SSA.\n-   Copyright (C) 2013-2020 Free Software Foundation, Inc.\n-   Contributed by Michael Matz <matz@suse.de>\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"is-a.h\"\n-#include \"vec.h\"\n-#include \"tree.h\"\n-#include \"dominance.h\"\n-#include \"basic-block.h\"\n-#include \"function.h\"\n-#include \"cfganal.h\"\n-#include \"cfg.h\"\n-#include \"bitmap.h\"\n-#include \"dumpfile.h\"\n-#include \"cgraph.h\"\n-#include \"print-tree.h\"\n-#include \"cfghooks.h\"\n-#include \"alloc-pool.h\"\n-#include \"symbol-summary.h\"\n-#include \"hsa-common.h\"\n-\n-\n-/* Process a PHI node PHI of basic block BB as a part of naive out-f-ssa.  */\n-\n-static void\n-naive_process_phi (hsa_insn_phi *phi, const vec<edge> &predecessors)\n-{\n-  unsigned count = phi->operand_count ();\n-  for (unsigned i = 0; i < count; i++)\n-    {\n-      gcc_checking_assert (phi->get_op (i));\n-      hsa_op_base *op = phi->get_op (i);\n-      hsa_bb *hbb;\n-      edge e;\n-\n-      if (!op)\n-\tbreak;\n-\n-      e = predecessors[i];\n-      if (single_succ_p (e->src))\n-\thbb = hsa_bb_for_bb (e->src);\n-      else\n-\t{\n-\t  basic_block old_dest = e->dest;\n-\t  hbb = hsa_init_new_bb (split_edge (e));\n-\n-\t  /* If switch insn used this edge, fix jump table.  */\n-\t  hsa_bb *source = hsa_bb_for_bb (e->src);\n-\t  hsa_insn_sbr *sbr;\n-\t  if (source->m_last_insn\n-\t      && (sbr = dyn_cast <hsa_insn_sbr *> (source->m_last_insn)))\n-\t    sbr->replace_all_labels (old_dest, hbb->m_bb);\n-\t}\n-\n-      hsa_build_append_simple_mov (phi->m_dest, op, hbb);\n-    }\n-}\n-\n-/* Naive out-of SSA.  */\n-\n-static void\n-naive_outof_ssa (void)\n-{\n-  basic_block bb;\n-\n-  hsa_cfun->m_in_ssa = false;\n-\n-  FOR_ALL_BB_FN (bb, cfun)\n-  {\n-    hsa_bb *hbb = hsa_bb_for_bb (bb);\n-    hsa_insn_phi *phi;\n-\n-    /* naive_process_phi can call split_edge on an incoming edge which order if\n-       the incoming edges to the basic block and thus make it inconsistent with\n-       the ordering of PHI arguments, so we collect them in advance.  */\n-    auto_vec<edge, 8> predecessors;\n-    unsigned pred_count = EDGE_COUNT (bb->preds);\n-    for (unsigned i = 0; i < pred_count; i++)\n-      predecessors.safe_push (EDGE_PRED (bb, i));\n-\n-    for (phi = hbb->m_first_phi;\n-\t phi;\n-\t phi = phi->m_next ? as_a <hsa_insn_phi *> (phi->m_next) : NULL)\n-      naive_process_phi (phi, predecessors);\n-\n-    /* Zap PHI nodes, they will be deallocated when everything else will.  */\n-    hbb->m_first_phi = NULL;\n-    hbb->m_last_phi = NULL;\n-  }\n-}\n-\n-/* Return register class number for the given HSA TYPE.  0 means the 'c' one\n-   bit register class, 1 means 's' 32 bit class, 2 stands for 'd' 64 bit class\n-   and 3 for 'q' 128 bit class.  */\n-\n-static int\n-m_reg_class_for_type (BrigType16_t type)\n-{\n-  switch (type)\n-    {\n-    case BRIG_TYPE_B1:\n-      return 0;\n-\n-    case BRIG_TYPE_U8:\n-    case BRIG_TYPE_U16:\n-    case BRIG_TYPE_U32:\n-    case BRIG_TYPE_S8:\n-    case BRIG_TYPE_S16:\n-    case BRIG_TYPE_S32:\n-    case BRIG_TYPE_F16:\n-    case BRIG_TYPE_F32:\n-    case BRIG_TYPE_B8:\n-    case BRIG_TYPE_B16:\n-    case BRIG_TYPE_B32:\n-    case BRIG_TYPE_U8X4:\n-    case BRIG_TYPE_S8X4:\n-    case BRIG_TYPE_U16X2:\n-    case BRIG_TYPE_S16X2:\n-    case BRIG_TYPE_F16X2:\n-      return 1;\n-\n-    case BRIG_TYPE_U64:\n-    case BRIG_TYPE_S64:\n-    case BRIG_TYPE_F64:\n-    case BRIG_TYPE_B64:\n-    case BRIG_TYPE_U8X8:\n-    case BRIG_TYPE_S8X8:\n-    case BRIG_TYPE_U16X4:\n-    case BRIG_TYPE_S16X4:\n-    case BRIG_TYPE_F16X4:\n-    case BRIG_TYPE_U32X2:\n-    case BRIG_TYPE_S32X2:\n-    case BRIG_TYPE_F32X2:\n-      return 2;\n-\n-    case BRIG_TYPE_B128:\n-    case BRIG_TYPE_U8X16:\n-    case BRIG_TYPE_S8X16:\n-    case BRIG_TYPE_U16X8:\n-    case BRIG_TYPE_S16X8:\n-    case BRIG_TYPE_F16X8:\n-    case BRIG_TYPE_U32X4:\n-    case BRIG_TYPE_U64X2:\n-    case BRIG_TYPE_S32X4:\n-    case BRIG_TYPE_S64X2:\n-    case BRIG_TYPE_F32X4:\n-    case BRIG_TYPE_F64X2:\n-      return 3;\n-\n-    default:\n-      gcc_unreachable ();\n-    }\n-}\n-\n-/* If the Ith operands of INSN is or contains a register (in an address),\n-   return the address of that register operand.  If not return NULL.  */\n-\n-static hsa_op_reg **\n-insn_reg_addr (hsa_insn_basic *insn, int i)\n-{\n-  hsa_op_base *op = insn->get_op (i);\n-  if (!op)\n-    return NULL;\n-  hsa_op_reg *reg = dyn_cast <hsa_op_reg *> (op);\n-  if (reg)\n-    return (hsa_op_reg **) insn->get_op_addr (i);\n-  hsa_op_address *addr = dyn_cast <hsa_op_address *> (op);\n-  if (addr && addr->m_reg)\n-    return &addr->m_reg;\n-  return NULL;\n-}\n-\n-struct m_reg_class_desc\n-{\n-  unsigned next_avail, max_num;\n-  unsigned used_num, max_used;\n-  uint64_t used[2];\n-  char cl_char;\n-};\n-\n-/* Rewrite the instructions in BB to observe spilled live ranges.\n-   CLASSES is the global register class state.  */\n-\n-static void\n-rewrite_code_bb (basic_block bb, struct m_reg_class_desc *classes)\n-{\n-  hsa_bb *hbb = hsa_bb_for_bb (bb);\n-  hsa_insn_basic *insn, *next_insn;\n-\n-  for (insn = hbb->m_first_insn; insn; insn = next_insn)\n-    {\n-      next_insn = insn->m_next;\n-      unsigned count = insn->operand_count ();\n-      for (unsigned i = 0; i < count; i++)\n-\t{\n-\t  gcc_checking_assert (insn->get_op (i));\n-\t  hsa_op_reg **regaddr = insn_reg_addr (insn, i);\n-\n-\t  if (regaddr)\n-\t    {\n-\t      hsa_op_reg *reg = *regaddr;\n-\t      if (reg->m_reg_class)\n-\t\tcontinue;\n-\t      gcc_assert (reg->m_spill_sym);\n-\n-\t      int cl = m_reg_class_for_type (reg->m_type);\n-\t      hsa_op_reg *tmp, *tmp2;\n-\t      if (insn->op_output_p (i))\n-\t\ttmp = hsa_spill_out (insn, reg, &tmp2);\n-\t      else\n-\t\ttmp = hsa_spill_in (insn, reg, &tmp2);\n-\n-\t      *regaddr = tmp;\n-\n-\t      tmp->m_reg_class = classes[cl].cl_char;\n-\t      tmp->m_hard_num = (char) (classes[cl].max_num + i);\n-\t      if (tmp2)\n-\t\t{\n-\t\t  gcc_assert (cl == 0);\n-\t\t  tmp2->m_reg_class = classes[1].cl_char;\n-\t\t  tmp2->m_hard_num = (char) (classes[1].max_num + i);\n-\t\t}\n-\t    }\n-\t}\n-    }\n-}\n-\n-/* Dump current function to dump file F, with info specific\n-   to register allocation.  */\n-\n-void\n-dump_hsa_cfun_regalloc (FILE *f)\n-{\n-  basic_block bb;\n-\n-  fprintf (f, \"\\nHSAIL IL for %s\\n\", hsa_cfun->m_name);\n-\n-  FOR_ALL_BB_FN (bb, cfun)\n-  {\n-    hsa_bb *hbb = (class hsa_bb *) bb->aux;\n-    bitmap_print (dump_file, hbb->m_livein, \"m_livein  \", \"\\n\");\n-    dump_hsa_bb (f, hbb);\n-    bitmap_print (dump_file, hbb->m_liveout, \"m_liveout \", \"\\n\");\n-  }\n-}\n-\n-/* Given the global register allocation state CLASSES and a\n-   register REG, try to give it a hardware register.  If successful,\n-   store that hardreg in REG and return it, otherwise return -1.\n-   Also changes CLASSES to accommodate for the allocated register.  */\n-\n-static int\n-try_alloc_reg (struct m_reg_class_desc *classes, hsa_op_reg *reg)\n-{\n-  int cl = m_reg_class_for_type (reg->m_type);\n-  int ret = -1;\n-  if (classes[1].used_num + classes[2].used_num * 2 + classes[3].used_num * 4\n-      >= 128 - 5)\n-    return -1;\n-  if (classes[cl].used_num < classes[cl].max_num)\n-    {\n-      unsigned int i;\n-      classes[cl].used_num++;\n-      if (classes[cl].used_num > classes[cl].max_used)\n-\tclasses[cl].max_used = classes[cl].used_num;\n-      for (i = 0; i < classes[cl].used_num; i++)\n-\tif (! (classes[cl].used[i / 64] & (((uint64_t)1) << (i & 63))))\n-\t  break;\n-      ret = i;\n-      classes[cl].used[i / 64] |= (((uint64_t)1) << (i & 63));\n-      reg->m_reg_class = classes[cl].cl_char;\n-      reg->m_hard_num = i;\n-    }\n-  return ret;\n-}\n-\n-/* Free up hardregs used by REG, into allocation state CLASSES.  */\n-\n-static void\n-free_reg (struct m_reg_class_desc *classes, hsa_op_reg *reg)\n-{\n-  int cl = m_reg_class_for_type (reg->m_type);\n-  int ret = reg->m_hard_num;\n-  gcc_assert (reg->m_reg_class == classes[cl].cl_char);\n-  classes[cl].used_num--;\n-  classes[cl].used[ret / 64] &= ~(((uint64_t)1) << (ret & 63));\n-}\n-\n-/* Note that the live range for REG ends at least at END.  */\n-\n-static void\n-note_lr_end (hsa_op_reg *reg, int end)\n-{\n-  if (reg->m_lr_end < end)\n-    reg->m_lr_end = end;\n-}\n-\n-/* Note that the live range for REG starts at least at BEGIN.  */\n-\n-static void\n-note_lr_begin (hsa_op_reg *reg, int begin)\n-{\n-  if (reg->m_lr_begin > begin)\n-    reg->m_lr_begin = begin;\n-}\n-\n-/* Given two registers A and B, return -1, 0 or 1 if A's live range\n-   starts before, at or after B's live range.  */\n-\n-static int\n-cmp_begin (const void *a, const void *b)\n-{\n-  const hsa_op_reg * const *rega = (const hsa_op_reg * const *)a;\n-  const hsa_op_reg * const *regb = (const hsa_op_reg * const *)b;\n-  int ret;\n-  if (rega == regb)\n-    return 0;\n-  ret = (*rega)->m_lr_begin - (*regb)->m_lr_begin;\n-  if (ret)\n-    return ret;\n-  return ((*rega)->m_order - (*regb)->m_order);\n-}\n-\n-/* Given two registers REGA and REGB, return true if REGA's\n-   live range ends after REGB's.  This results in a sorting order\n-   with earlier end points at the end.  */\n-\n-static bool\n-cmp_end (hsa_op_reg * const &rega, hsa_op_reg * const &regb)\n-{\n-  int ret;\n-  if (rega == regb)\n-    return false;\n-  ret = (regb)->m_lr_end - (rega)->m_lr_end;\n-  if (ret)\n-    return ret < 0;\n-  return (((regb)->m_order - (rega)->m_order)) < 0;\n-}\n-\n-/* Expire all old intervals in ACTIVE (a per-regclass vector),\n-   that is, those that end before the interval REG starts.  Give\n-   back resources freed so into the state CLASSES.  */\n-\n-static void\n-expire_old_intervals (hsa_op_reg *reg, vec<hsa_op_reg*> *active,\n-\t\t      struct m_reg_class_desc *classes)\n-{\n-  for (int i = 0; i < 4; i++)\n-    while (!active[i].is_empty ())\n-      {\n-\thsa_op_reg *a = active[i].pop ();\n-\tif (a->m_lr_end > reg->m_lr_begin)\n-\t  {\n-\t    active[i].quick_push (a);\n-\t    break;\n-\t  }\n-\tfree_reg (classes, a);\n-      }\n-}\n-\n-/* The interval REG didn't get a hardreg.  Spill it or one of those\n-   from ACTIVE (if the latter, then REG will become allocated to the\n-   hardreg that formerly was used by it).  */\n-\n-static void\n-spill_at_interval (hsa_op_reg *reg, vec<hsa_op_reg*> *active)\n-{\n-  int cl = m_reg_class_for_type (reg->m_type);\n-  gcc_assert (!active[cl].is_empty ());\n-  hsa_op_reg *cand = active[cl][0];\n-  if (cand->m_lr_end > reg->m_lr_end)\n-    {\n-      reg->m_reg_class = cand->m_reg_class;\n-      reg->m_hard_num = cand->m_hard_num;\n-      active[cl].ordered_remove (0);\n-      unsigned place = active[cl].lower_bound (reg, cmp_end);\n-      active[cl].quick_insert (place, reg);\n-    }\n-  else\n-    cand = reg;\n-\n-  gcc_assert (!cand->m_spill_sym);\n-  BrigType16_t type = cand->m_type;\n-  if (type == BRIG_TYPE_B1)\n-    type = BRIG_TYPE_U8;\n-  cand->m_reg_class = 0;\n-  cand->m_spill_sym = hsa_get_spill_symbol (type);\n-  cand->m_spill_sym->m_name_number = cand->m_order;\n-}\n-\n-/* Given the global register state CLASSES allocate all HSA virtual\n-   registers either to hardregs or to a spill symbol.  */\n-\n-static void\n-linear_scan_regalloc (struct m_reg_class_desc *classes)\n-{\n-  /* Compute liveness.  */\n-  bool changed;\n-  int i, n;\n-  int insn_order;\n-  int *bbs = XNEWVEC (int, n_basic_blocks_for_fn (cfun));\n-  bitmap work = BITMAP_ALLOC (NULL);\n-  vec<hsa_op_reg*> ind2reg = vNULL;\n-  vec<hsa_op_reg*> active[4] = {vNULL, vNULL, vNULL, vNULL};\n-  hsa_insn_basic *m_last_insn;\n-\n-  /* We will need the reverse post order for linearization,\n-     and the post order for liveness analysis, which is the same\n-     backward.  */\n-  n = pre_and_rev_post_order_compute (NULL, bbs, true);\n-  ind2reg.safe_grow_cleared (hsa_cfun->m_reg_count);\n-\n-  /* Give all instructions a linearized number, at the same time\n-     build a mapping from register index to register.  */\n-  insn_order = 1;\n-  for (i = 0; i < n; i++)\n-    {\n-      basic_block bb = BASIC_BLOCK_FOR_FN (cfun, bbs[i]);\n-      hsa_bb *hbb = hsa_bb_for_bb (bb);\n-      hsa_insn_basic *insn;\n-      for (insn = hbb->m_first_insn; insn; insn = insn->m_next)\n-\t{\n-\t  unsigned opi;\n-\t  insn->m_number = insn_order++;\n-\t  for (opi = 0; opi < insn->operand_count (); opi++)\n-\t    {\n-\t      gcc_checking_assert (insn->get_op (opi));\n-\t      hsa_op_reg **regaddr = insn_reg_addr (insn, opi);\n-\t      if (regaddr)\n-\t\tind2reg[(*regaddr)->m_order] = *regaddr;\n-\t    }\n-\t}\n-    }\n-\n-  /* Initialize all live ranges to [after-end, 0).  */\n-  for (i = 0; i < hsa_cfun->m_reg_count; i++)\n-    if (ind2reg[i])\n-      ind2reg[i]->m_lr_begin = insn_order, ind2reg[i]->m_lr_end = 0;\n-\n-  /* Classic liveness analysis, as long as something changes:\n-       m_liveout is union (m_livein of successors)\n-       m_livein is m_liveout minus defs plus uses.  */\n-  do\n-    {\n-      changed = false;\n-      for (i = n - 1; i >= 0; i--)\n-\t{\n-\t  edge e;\n-\t  edge_iterator ei;\n-\t  basic_block bb = BASIC_BLOCK_FOR_FN (cfun, bbs[i]);\n-\t  hsa_bb *hbb = hsa_bb_for_bb (bb);\n-\n-\t  /* Union of successors m_livein (or empty if none).  */\n-\t  bool first = true;\n-\t  FOR_EACH_EDGE (e, ei, bb->succs)\n-\t    if (e->dest != EXIT_BLOCK_PTR_FOR_FN (cfun))\n-\t      {\n-\t\thsa_bb *succ = hsa_bb_for_bb (e->dest);\n-\t\tif (first)\n-\t\t  {\n-\t\t    bitmap_copy (work, succ->m_livein);\n-\t\t    first = false;\n-\t\t  }\n-\t\telse\n-\t\t  bitmap_ior_into (work, succ->m_livein);\n-\t      }\n-\t  if (first)\n-\t    bitmap_clear (work);\n-\n-\t  bitmap_copy (hbb->m_liveout, work);\n-\n-\t  /* Remove defs, include uses in a backward insn walk.  */\n-\t  hsa_insn_basic *insn;\n-\t  for (insn = hbb->m_last_insn; insn; insn = insn->m_prev)\n-\t    {\n-\t      unsigned opi;\n-\t      unsigned ndefs = insn->input_count ();\n-\t      for (opi = 0; opi < ndefs && insn->get_op (opi); opi++)\n-\t\t{\n-\t\t  gcc_checking_assert (insn->get_op (opi));\n-\t\t  hsa_op_reg **regaddr = insn_reg_addr (insn, opi);\n-\t\t  if (regaddr)\n-\t\t    bitmap_clear_bit (work, (*regaddr)->m_order);\n-\t\t}\n-\t      for (; opi < insn->operand_count (); opi++)\n-\t\t{\n-\t\t  gcc_checking_assert (insn->get_op (opi));\n-\t\t  hsa_op_reg **regaddr = insn_reg_addr (insn, opi);\n-\t\t  if (regaddr)\n-\t\t    bitmap_set_bit (work, (*regaddr)->m_order);\n-\t\t}\n-\t    }\n-\n-\t  /* Note if that changed something.  */\n-\t  if (bitmap_ior_into (hbb->m_livein, work))\n-\t    changed = true;\n-\t}\n-    }\n-  while (changed);\n-\n-  /* Make one pass through all instructions in linear order,\n-     noting and merging possible live range start and end points.  */\n-  m_last_insn = NULL;\n-  for (i = n - 1; i >= 0; i--)\n-    {\n-      basic_block bb = BASIC_BLOCK_FOR_FN (cfun, bbs[i]);\n-      hsa_bb *hbb = hsa_bb_for_bb (bb);\n-      hsa_insn_basic *insn;\n-      int after_end_number;\n-      unsigned bit;\n-      bitmap_iterator bi;\n-\n-      if (m_last_insn)\n-\tafter_end_number = m_last_insn->m_number;\n-      else\n-\tafter_end_number = insn_order;\n-      /* Everything live-out in this BB has at least an end point\n-\t after us.  */\n-      EXECUTE_IF_SET_IN_BITMAP (hbb->m_liveout, 0, bit, bi)\n-\tnote_lr_end (ind2reg[bit], after_end_number);\n-\n-      for (insn = hbb->m_last_insn; insn; insn = insn->m_prev)\n-\t{\n-\t  unsigned opi;\n-\t  unsigned ndefs = insn->input_count ();\n-\t  for (opi = 0; opi < insn->operand_count (); opi++)\n-\t    {\n-\t      gcc_checking_assert (insn->get_op (opi));\n-\t      hsa_op_reg **regaddr = insn_reg_addr (insn, opi);\n-\t      if (regaddr)\n-\t\t{\n-\t\t  hsa_op_reg *reg = *regaddr;\n-\t\t  if (opi < ndefs)\n-\t\t    note_lr_begin (reg, insn->m_number);\n-\t\t  else\n-\t\t    note_lr_end (reg, insn->m_number);\n-\t\t}\n-\t    }\n-\t}\n-\n-      /* Everything live-in in this BB has a start point before\n-\t our first insn.  */\n-      int before_start_number;\n-      if (hbb->m_first_insn)\n-\tbefore_start_number = hbb->m_first_insn->m_number;\n-      else\n-\tbefore_start_number = after_end_number;\n-      before_start_number--;\n-      EXECUTE_IF_SET_IN_BITMAP (hbb->m_livein, 0, bit, bi)\n-\tnote_lr_begin (ind2reg[bit], before_start_number);\n-\n-      if (hbb->m_first_insn)\n-\tm_last_insn = hbb->m_first_insn;\n-    }\n-\n-  for (i = 0; i < hsa_cfun->m_reg_count; i++)\n-    if (ind2reg[i])\n-      {\n-\t/* All regs that have still their start at after all code actually\n-\t   are defined at the start of the routine (prologue).  */\n-\tif (ind2reg[i]->m_lr_begin == insn_order)\n-\t  ind2reg[i]->m_lr_begin = 0;\n-\t/* All regs that have no use but a def will have lr_end == 0,\n-\t   they are actually live from def until after the insn they are\n-\t   defined in.  */\n-\tif (ind2reg[i]->m_lr_end == 0)\n-\t  ind2reg[i]->m_lr_end = ind2reg[i]->m_lr_begin + 1;\n-      }\n-\n-  /* Sort all intervals by increasing start point.  */\n-  gcc_assert (ind2reg.length () == (size_t) hsa_cfun->m_reg_count);\n-\n-  if (flag_checking)\n-    for (unsigned i = 0; i < ind2reg.length (); i++)\n-      gcc_assert (ind2reg[i]);\n-\n-  ind2reg.qsort (cmp_begin);\n-  for (i = 0; i < 4; i++)\n-    active[i].reserve_exact (hsa_cfun->m_reg_count);\n-\n-  /* Now comes the linear scan allocation.  */\n-  for (i = 0; i < hsa_cfun->m_reg_count; i++)\n-    {\n-      hsa_op_reg *reg = ind2reg[i];\n-      if (!reg)\n-\tcontinue;\n-      expire_old_intervals (reg, active, classes);\n-      int cl = m_reg_class_for_type (reg->m_type);\n-      if (try_alloc_reg (classes, reg) >= 0)\n-\t{\n-\t  unsigned place = active[cl].lower_bound (reg, cmp_end);\n-\t  active[cl].quick_insert (place, reg);\n-\t}\n-      else\n-\tspill_at_interval (reg, active);\n-\n-      /* Some interesting dumping as we go.  */\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t{\n-\t  fprintf (dump_file, \"  reg%d: [%5d, %5d)->\",\n-\t\t   reg->m_order, reg->m_lr_begin, reg->m_lr_end);\n-\t  if (reg->m_reg_class)\n-\t    fprintf (dump_file, \"$%c%i\", reg->m_reg_class, reg->m_hard_num);\n-\t  else\n-\t    fprintf (dump_file, \"[%%__%s_%i]\",\n-\t\t     hsa_seg_name (reg->m_spill_sym->m_segment),\n-\t\t     reg->m_spill_sym->m_name_number);\n-\t  for (int cl = 0; cl < 4; cl++)\n-\t    {\n-\t      bool first = true;\n-\t      hsa_op_reg *r;\n-\t      fprintf (dump_file, \" {\");\n-\t      for (int j = 0; active[cl].iterate (j, &r); j++)\n-\t\tif (first)\n-\t\t  {\n-\t\t    fprintf (dump_file, \"%d\", r->m_order);\n-\t\t    first = false;\n-\t\t  }\n-\t\telse\n-\t\t  fprintf (dump_file, \", %d\", r->m_order);\n-\t      fprintf (dump_file, \"}\");\n-\t    }\n-\t  fprintf (dump_file, \"\\n\");\n-\t}\n-    }\n-\n-  BITMAP_FREE (work);\n-  free (bbs);\n-\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    {\n-      fprintf (dump_file, \"------- After liveness: -------\\n\");\n-      dump_hsa_cfun_regalloc (dump_file);\n-      fprintf (dump_file, \"  ----- Intervals:\\n\");\n-      for (i = 0; i < hsa_cfun->m_reg_count; i++)\n-\t{\n-\t  hsa_op_reg *reg = ind2reg[i];\n-\t  if (!reg)\n-\t    continue;\n-\t  fprintf (dump_file, \"  reg%d: [%5d, %5d)->\", reg->m_order,\n-\t\t   reg->m_lr_begin, reg->m_lr_end);\n-\t  if (reg->m_reg_class)\n-\t    fprintf (dump_file, \"$%c%i\\n\", reg->m_reg_class, reg->m_hard_num);\n-\t  else\n-\t    fprintf (dump_file, \"[%%__%s_%i]\\n\",\n-\t\t     hsa_seg_name (reg->m_spill_sym->m_segment),\n-\t\t     reg->m_spill_sym->m_name_number);\n-\t}\n-    }\n-\n-  for (i = 0; i < 4; i++)\n-    active[i].release ();\n-  ind2reg.release ();\n-}\n-\n-/* Entry point for register allocation.  */\n-\n-static void\n-regalloc (void)\n-{\n-  basic_block bb;\n-  m_reg_class_desc classes[4];\n-\n-  /* If there are no registers used in the function, exit right away.  */\n-  if (hsa_cfun->m_reg_count == 0)\n-    return;\n-\n-  memset (classes, 0, sizeof (classes));\n-  classes[0].next_avail = 0;\n-  classes[0].max_num = 7;\n-  classes[0].cl_char = 'c';\n-  classes[1].cl_char = 's';\n-  classes[2].cl_char = 'd';\n-  classes[3].cl_char = 'q';\n-\n-  for (int i = 1; i < 4; i++)\n-    {\n-      classes[i].next_avail = 0;\n-      classes[i].max_num = 20;\n-    }\n-\n-  linear_scan_regalloc (classes);\n-\n-  FOR_ALL_BB_FN (bb, cfun)\n-    rewrite_code_bb (bb, classes);\n-}\n-\n-/* Out of SSA and register allocation on HSAIL IL.  */\n-\n-void\n-hsa_regalloc (void)\n-{\n-  hsa_cfun->update_dominance ();\n-  naive_outof_ssa ();\n-\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    {\n-      fprintf (dump_file, \"------- After out-of-SSA: -------\\n\");\n-      dump_hsa_cfun (dump_file);\n-    }\n-\n-  regalloc ();\n-\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    {\n-      fprintf (dump_file, \"------- After register allocation: -------\\n\");\n-      dump_hsa_cfun (dump_file);\n-    }\n-}"}, {"sha": "f2980ba36885d678ff31810037ffcf2c18993a2d", "filename": "gcc/ipa-hsa.c", "status": "removed", "additions": 0, "deletions": 336, "changes": 336, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9623f61b142174b87760c81f78928dd14af7cbc6/gcc%2Fipa-hsa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9623f61b142174b87760c81f78928dd14af7cbc6/gcc%2Fipa-hsa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-hsa.c?ref=9623f61b142174b87760c81f78928dd14af7cbc6", "patch": "@@ -1,336 +0,0 @@\n-/* Callgraph based analysis of static variables.\n-   Copyright (C) 2015-2020 Free Software Foundation, Inc.\n-   Contributed by Martin Liska <mliska@suse.cz>\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-/* Interprocedural HSA pass is responsible for creation of HSA clones.\n-   For all these HSA clones, we emit HSAIL instructions and pass processing\n-   is terminated.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"is-a.h\"\n-#include \"hash-set.h\"\n-#include \"vec.h\"\n-#include \"tree.h\"\n-#include \"tree-pass.h\"\n-#include \"function.h\"\n-#include \"basic-block.h\"\n-#include \"gimple.h\"\n-#include \"dumpfile.h\"\n-#include \"gimple-pretty-print.h\"\n-#include \"tree-streamer.h\"\n-#include \"stringpool.h\"\n-#include \"cgraph.h\"\n-#include \"print-tree.h\"\n-#include \"alloc-pool.h\"\n-#include \"symbol-summary.h\"\n-#include \"hsa-common.h\"\n-\n-namespace {\n-\n-/* If NODE is not versionable, warn about not emiting HSAIL and return false.\n-   Otherwise return true.  */\n-\n-static bool\n-check_warn_node_versionable (cgraph_node *node)\n-{\n-  if (!node->versionable)\n-    {\n-      warning_at (EXPR_LOCATION (node->decl), OPT_Whsa,\n-\t\t  \"could not emit HSAIL for function %s: function cannot be \"\n-\t\t  \"cloned\", node->dump_name ());\n-      return false;\n-    }\n-  return true;\n-}\n-\n-/* The function creates HSA clones for all functions that were either\n-   marked as HSA kernels or are callable HSA functions.  Apart from that,\n-   we redirect all edges that come from an HSA clone and end in another\n-   HSA clone to connect these two functions.  */\n-\n-static unsigned int\n-process_hsa_functions (void)\n-{\n-  struct cgraph_node *node;\n-\n-  if (hsa_summaries == NULL)\n-    hsa_summaries = new hsa_summary_t (symtab);\n-\n-  FOR_EACH_DEFINED_FUNCTION (node)\n-    {\n-      hsa_function_summary *s = hsa_summaries->get (node);\n-\n-      /* A linked function is skipped.  */\n-      if (s != NULL && s->m_bound_function != NULL)\n-\tcontinue;\n-\n-      if (s != NULL)\n-\t{\n-\t  if (!check_warn_node_versionable (node))\n-\t    continue;\n-\t  cgraph_node *clone\n-\t    = node->create_virtual_clone (vec <cgraph_edge *> (),\n-\t\t\t\t\t  NULL, NULL, \"hsa\", 0);\n-\t  TREE_PUBLIC (clone->decl) = TREE_PUBLIC (node->decl);\n-\t  clone->externally_visible = node->externally_visible;\n-\n-\t  clone->force_output = true;\n-\t  hsa_summaries->link_functions (clone, node, s->m_kind, false);\n-\n-\t  if (dump_file)\n-\t    fprintf (dump_file, \"Created a new HSA clone: %s, type: %s\\n\",\n-\t\t     clone->dump_name (),\n-\t\t     s->m_kind == HSA_KERNEL ? \"kernel\" : \"function\");\n-\t}\n-      else if (hsa_callable_function_p (node->decl)\n-\t       /* At this point, this is enough to identify clones for\n-\t\t  parallel, which for HSA would need to be kernels anyway.  */\n-\t       && !DECL_ARTIFICIAL (node->decl))\n-\t{\n-\t  if (!check_warn_node_versionable (node))\n-\t    continue;\n-\t  cgraph_node *clone\n-\t    = node->create_virtual_clone (vec <cgraph_edge *> (),\n-\t\t\t\t\t  NULL, NULL, \"hsa\", 0);\n-\t  TREE_PUBLIC (clone->decl) = TREE_PUBLIC (node->decl);\n-\t  clone->externally_visible = node->externally_visible;\n-\n-\t  if (!node->local)\n-\t    clone->force_output = true;\n-\t  hsa_summaries->link_functions (clone, node, HSA_FUNCTION, false);\n-\n-\t  if (dump_file)\n-\t    fprintf (dump_file, \"Created a new HSA function clone: %s\\n\",\n-\t\t     clone->dump_name ());\n-\t}\n-    }\n-\n-  /* Redirect all edges that are between HSA clones.  */\n-  FOR_EACH_DEFINED_FUNCTION (node)\n-    {\n-      cgraph_edge *e = node->callees;\n-\n-      while (e)\n-\t{\n-\t  hsa_function_summary *src = hsa_summaries->get (node);\n-\t  if (src != NULL && src->m_gpu_implementation_p)\n-\t    {\n-\t      hsa_function_summary *dst = hsa_summaries->get (e->callee);\n-\t      if (dst != NULL && !dst->m_gpu_implementation_p)\n-\t\t{\n-\t\t  e->redirect_callee (dst->m_bound_function);\n-\t\t  if (dump_file)\n-\t\t    fprintf (dump_file,\n-\t\t\t     \"Redirecting edge to HSA function: %s->%s\\n\",\n-\t\t\t     e->caller->dump_name (),\n-\t\t\t     e->callee->dump_name ());\n-\t\t}\n-\t    }\n-\n-\t  e = e->next_callee;\n-\t}\n-    }\n-\n-  return 0;\n-}\n-\n-/* Iterate all HSA functions and stream out HSA function summary.  */\n-\n-static void\n-ipa_hsa_write_summary (void)\n-{\n-  struct bitpack_d bp;\n-  struct cgraph_node *node;\n-  struct output_block *ob;\n-  unsigned int count = 0;\n-  lto_symtab_encoder_iterator lsei;\n-  lto_symtab_encoder_t encoder;\n-\n-  if (!hsa_summaries)\n-    return;\n-\n-  ob = create_output_block (LTO_section_ipa_hsa);\n-  encoder = ob->decl_state->symtab_node_encoder;\n-  ob->symbol = NULL;\n-  for (lsei = lsei_start_function_in_partition (encoder); !lsei_end_p (lsei);\n-       lsei_next_function_in_partition (&lsei))\n-    {\n-      node = lsei_cgraph_node (lsei);\n-      hsa_function_summary *s = hsa_summaries->get (node);\n-\n-      if (s != NULL)\n-\tcount++;\n-    }\n-\n-  streamer_write_uhwi (ob, count);\n-\n-  /* Process all of the functions.  */\n-  for (lsei = lsei_start_function_in_partition (encoder); !lsei_end_p (lsei);\n-       lsei_next_function_in_partition (&lsei))\n-    {\n-      node = lsei_cgraph_node (lsei);\n-      hsa_function_summary *s = hsa_summaries->get (node);\n-\n-      if (s != NULL)\n-\t{\n-\t  encoder = ob->decl_state->symtab_node_encoder;\n-\t  int node_ref = lto_symtab_encoder_encode (encoder, node);\n-\t  streamer_write_uhwi (ob, node_ref);\n-\n-\t  bp = bitpack_create (ob->main_stream);\n-\t  bp_pack_value (&bp, s->m_kind, 2);\n-\t  bp_pack_value (&bp, s->m_gpu_implementation_p, 1);\n-\t  bp_pack_value (&bp, s->m_bound_function != NULL, 1);\n-\t  streamer_write_bitpack (&bp);\n-\t  if (s->m_bound_function)\n-\t    stream_write_tree (ob, s->m_bound_function->decl, true);\n-\t}\n-    }\n-\n-  streamer_write_char_stream (ob->main_stream, 0);\n-  produce_asm (ob, NULL);\n-  destroy_output_block (ob);\n-}\n-\n-/* Read section in file FILE_DATA of length LEN with data DATA.  */\n-\n-static void\n-ipa_hsa_read_section (struct lto_file_decl_data *file_data, const char *data,\n-\t\t       size_t len)\n-{\n-  const struct lto_function_header *header\n-    = (const struct lto_function_header *) data;\n-  const int cfg_offset = sizeof (struct lto_function_header);\n-  const int main_offset = cfg_offset + header->cfg_size;\n-  const int string_offset = main_offset + header->main_size;\n-  class data_in *data_in;\n-  unsigned int i;\n-  unsigned int count;\n-\n-  lto_input_block ib_main ((const char *) data + main_offset,\n-\t\t\t   header->main_size, file_data->mode_table);\n-\n-  data_in\n-    = lto_data_in_create (file_data, (const char *) data + string_offset,\n-\t\t\t  header->string_size, vNULL);\n-  count = streamer_read_uhwi (&ib_main);\n-\n-  for (i = 0; i < count; i++)\n-    {\n-      unsigned int index;\n-      struct cgraph_node *node;\n-      lto_symtab_encoder_t encoder;\n-\n-      index = streamer_read_uhwi (&ib_main);\n-      encoder = file_data->symtab_node_encoder;\n-      node = dyn_cast<cgraph_node *> (lto_symtab_encoder_deref (encoder,\n-\t\t\t\t\t\t\t\tindex));\n-      gcc_assert (node->definition);\n-      hsa_function_summary *s = hsa_summaries->get_create (node);\n-\n-      struct bitpack_d bp = streamer_read_bitpack (&ib_main);\n-      s->m_kind = (hsa_function_kind) bp_unpack_value (&bp, 2);\n-      s->m_gpu_implementation_p = bp_unpack_value (&bp, 1);\n-      bool has_tree = bp_unpack_value (&bp, 1);\n-\n-      if (has_tree)\n-\t{\n-\t  tree decl = stream_read_tree (&ib_main, data_in);\n-\t  s->m_bound_function = cgraph_node::get_create (decl);\n-\t}\n-    }\n-  lto_free_section_data (file_data, LTO_section_ipa_hsa, NULL, data,\n-\t\t\t len);\n-  lto_data_in_delete (data_in);\n-}\n-\n-/* Load streamed HSA functions summary and assign the summary to a function.  */\n-\n-static void\n-ipa_hsa_read_summary (void)\n-{\n-  struct lto_file_decl_data **file_data_vec = lto_get_file_decl_data ();\n-  struct lto_file_decl_data *file_data;\n-  unsigned int j = 0;\n-\n-  if (hsa_summaries == NULL)\n-    hsa_summaries = new hsa_summary_t (symtab);\n-\n-  while ((file_data = file_data_vec[j++]))\n-    {\n-      size_t len;\n-      const char *data\n-\t= lto_get_summary_section_data (file_data, LTO_section_ipa_hsa, &len);\n-      if (data)\n-\tipa_hsa_read_section (file_data, data, len);\n-    }\n-}\n-\n-const pass_data pass_data_ipa_hsa =\n-{\n-  IPA_PASS, /* type */\n-  \"hsa\", /* name */\n-  OPTGROUP_OMP, /* optinfo_flags */\n-  TV_IPA_HSA, /* tv_id */\n-  0, /* properties_required */\n-  0, /* properties_provided */\n-  0, /* properties_destroyed */\n-  0, /* todo_flags_start */\n-  TODO_dump_symtab, /* todo_flags_finish */\n-};\n-\n-class pass_ipa_hsa : public ipa_opt_pass_d\n-{\n-public:\n-  pass_ipa_hsa (gcc::context *ctxt)\n-    : ipa_opt_pass_d (pass_data_ipa_hsa, ctxt,\n-\t\t      NULL, /* generate_summary */\n-\t\t      ipa_hsa_write_summary, /* write_summary */\n-\t\t      ipa_hsa_read_summary, /* read_summary */\n-\t\t      ipa_hsa_write_summary, /* write_optimization_summary */\n-\t\t      ipa_hsa_read_summary, /* read_optimization_summary */\n-\t\t      NULL, /* stmt_fixup */\n-\t\t      0, /* function_transform_todo_flags_start */\n-\t\t      NULL, /* function_transform */\n-\t\t      NULL) /* variable_transform */\n-    {}\n-\n-  /* opt_pass methods: */\n-  virtual bool gate (function *);\n-\n-  virtual unsigned int execute (function *) { return process_hsa_functions (); }\n-\n-}; // class pass_ipa_reference\n-\n-bool\n-pass_ipa_hsa::gate (function *)\n-{\n-  return hsa_gen_requested_p ();\n-}\n-\n-} // anon namespace\n-\n-ipa_opt_pass_d *\n-make_pass_ipa_hsa (gcc::context *ctxt)\n-{\n-  return new pass_ipa_hsa (ctxt);\n-}"}, {"sha": "8a38fa27d7c721a45c64180554bc908f5b47a93d", "filename": "gcc/lto-section-in.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c56684fd61223abd45854270cd1e83ab2f07148c/gcc%2Flto-section-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c56684fd61223abd45854270cd1e83ab2f07148c/gcc%2Flto-section-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-section-in.c?ref=c56684fd61223abd45854270cd1e83ab2f07148c", "patch": "@@ -53,7 +53,6 @@ const char *lto_section_name[LTO_N_SECTION_TYPES] =\n   \"icf\",\n   \"offload_table\",\n   \"mode_table\",\n-  \"hsa\",\n   \"lto\",\n   \"ipa_sra\",\n   \"odr_types\","}, {"sha": "0129f00cc1aceb04a0a6b00a178e4bbea5cfa30e", "filename": "gcc/lto-streamer.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c56684fd61223abd45854270cd1e83ab2f07148c/gcc%2Flto-streamer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c56684fd61223abd45854270cd1e83ab2f07148c/gcc%2Flto-streamer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.h?ref=c56684fd61223abd45854270cd1e83ab2f07148c", "patch": "@@ -224,7 +224,6 @@ enum lto_section_type\n   LTO_section_ipa_icf,\n   LTO_section_offload_table,\n   LTO_section_mode_table,\n-  LTO_section_ipa_hsa,\n   LTO_section_lto,\n   LTO_section_ipa_sra,\n   LTO_section_odr_types,"}, {"sha": "82cfa6bd67e17a49f93063e48b5498bd3517de58", "filename": "gcc/lto-wrapper.c", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c56684fd61223abd45854270cd1e83ab2f07148c/gcc%2Flto-wrapper.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c56684fd61223abd45854270cd1e83ab2f07148c/gcc%2Flto-wrapper.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-wrapper.c?ref=c56684fd61223abd45854270cd1e83ab2f07148c", "patch": "@@ -976,7 +976,6 @@ compile_images_for_offload_targets (unsigned in_argc, char *in_argv[],\n     return;\n   unsigned num_targets = parse_env_var (target_names, &names, NULL);\n \n-  int next_name_entry = 0;\n   const char *compiler_path = getenv (\"COMPILER_PATH\");\n   if (!compiler_path)\n     goto out;\n@@ -986,19 +985,13 @@ compile_images_for_offload_targets (unsigned in_argc, char *in_argv[],\n   offload_names = XCNEWVEC (char *, num_targets + 1);\n   for (unsigned i = 0; i < num_targets; i++)\n     {\n-      /* HSA does not use LTO-like streaming and a different compiler, skip\n-\t it. */\n-      if (strcmp (names[i], \"hsa\") == 0)\n-\tcontinue;\n-\n-      offload_names[next_name_entry]\n+      offload_names[i]\n \t= compile_offload_image (names[i], compiler_path, in_argc, in_argv,\n \t\t\t\t compiler_opts, compiler_opt_count,\n \t\t\t\t linker_opts, linker_opt_count);\n-      if (!offload_names[next_name_entry])\n+      if (!offload_names[i])\n \tfatal_error (input_location,\n \t\t     \"problem with building target image for %s\", names[i]);\n-      next_name_entry++;\n     }\n \n  out:"}, {"sha": "efffac6f4b8ae6db3def8930c0c1e1f9ed619ab0", "filename": "gcc/omp-expand.c", "status": "modified", "additions": 0, "deletions": 457, "changes": 457, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c56684fd61223abd45854270cd1e83ab2f07148c/gcc%2Fomp-expand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c56684fd61223abd45854270cd1e83ab2f07148c/gcc%2Fomp-expand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-expand.c?ref=c56684fd61223abd45854270cd1e83ab2f07148c", "patch": "@@ -56,7 +56,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"symbol-summary.h\"\n #include \"gomp-constants.h\"\n #include \"gimple-pretty-print.h\"\n-#include \"hsa-common.h\"\n #include \"stringpool.h\"\n #include \"attribs.h\"\n \n@@ -484,37 +483,6 @@ gimple_build_cond_empty (tree cond)\n   return gimple_build_cond (pred_code, lhs, rhs, NULL_TREE, NULL_TREE);\n }\n \n-/* Return true if a parallel REGION is within a declare target function or\n-   within a target region and is not a part of a gridified target.  */\n-\n-static bool\n-parallel_needs_hsa_kernel_p (struct omp_region *region)\n-{\n-  bool indirect = false;\n-  for (region = region->outer; region; region = region->outer)\n-    {\n-      if (region->type == GIMPLE_OMP_PARALLEL)\n-\tindirect = true;\n-      else if (region->type == GIMPLE_OMP_TARGET)\n-\t{\n-\t  gomp_target *tgt_stmt\n-\t    = as_a <gomp_target *> (last_stmt (region->entry));\n-\n-\t  if (omp_find_clause (gimple_omp_target_clauses (tgt_stmt),\n-\t\t\t       OMP_CLAUSE__GRIDDIM_))\n-\t    return indirect;\n-\t  else\n-\t    return true;\n-\t}\n-    }\n-\n-  if (lookup_attribute (\"omp declare target\",\n-\t\t\tDECL_ATTRIBUTES (current_function_decl)))\n-    return true;\n-\n-  return false;\n-}\n-\n /* Change DECL_CONTEXT of CHILD_FNDECL to that of the parent function.\n    Add CHILD_FNDECL to decl chain of the supercontext of the block\n    ENTRY_BLOCK - this is the block which originally contained the\n@@ -772,13 +740,6 @@ expand_parallel_call (struct omp_region *region, basic_block bb,\n     }\n   force_gimple_operand_gsi (&gsi, t, true, NULL_TREE,\n \t\t\t    false, GSI_CONTINUE_LINKING);\n-\n-  if (hsa_gen_requested_p ()\n-      && parallel_needs_hsa_kernel_p (region))\n-    {\n-      cgraph_node *child_cnode = cgraph_node::get (child_fndecl);\n-      hsa_register_kernel (child_cnode);\n-    }\n }\n \n /* Build the function call to GOMP_task to actually\n@@ -8528,113 +8489,6 @@ mark_loops_in_oacc_kernels_region (basic_block region_entry,\n     loop->in_oacc_kernels_region = true;\n }\n \n-/* Types used to pass grid and wortkgroup sizes to kernel invocation.  */\n-\n-struct GTY(()) grid_launch_attributes_trees\n-{\n-  tree kernel_dim_array_type;\n-  tree kernel_lattrs_dimnum_decl;\n-  tree kernel_lattrs_grid_decl;\n-  tree kernel_lattrs_group_decl;\n-  tree kernel_launch_attributes_type;\n-};\n-\n-static GTY(()) struct grid_launch_attributes_trees *grid_attr_trees;\n-\n-/* Create types used to pass kernel launch attributes to target.  */\n-\n-static void\n-grid_create_kernel_launch_attr_types (void)\n-{\n-  if (grid_attr_trees)\n-    return;\n-  grid_attr_trees = ggc_alloc <grid_launch_attributes_trees> ();\n-\n-  tree dim_arr_index_type\n-    = build_index_type (build_int_cst (integer_type_node, 2));\n-  grid_attr_trees->kernel_dim_array_type\n-    = build_array_type (uint32_type_node, dim_arr_index_type);\n-\n-  grid_attr_trees->kernel_launch_attributes_type = make_node (RECORD_TYPE);\n-  grid_attr_trees->kernel_lattrs_dimnum_decl\n-    = build_decl (BUILTINS_LOCATION, FIELD_DECL, get_identifier (\"ndim\"),\n-\t\t  uint32_type_node);\n-  DECL_CHAIN (grid_attr_trees->kernel_lattrs_dimnum_decl) = NULL_TREE;\n-\n-  grid_attr_trees->kernel_lattrs_grid_decl\n-    = build_decl (BUILTINS_LOCATION, FIELD_DECL, get_identifier (\"grid_size\"),\n-\t\t  grid_attr_trees->kernel_dim_array_type);\n-  DECL_CHAIN (grid_attr_trees->kernel_lattrs_grid_decl)\n-    = grid_attr_trees->kernel_lattrs_dimnum_decl;\n-  grid_attr_trees->kernel_lattrs_group_decl\n-    = build_decl (BUILTINS_LOCATION, FIELD_DECL, get_identifier (\"group_size\"),\n-\t\t  grid_attr_trees->kernel_dim_array_type);\n-  DECL_CHAIN (grid_attr_trees->kernel_lattrs_group_decl)\n-    = grid_attr_trees->kernel_lattrs_grid_decl;\n-  finish_builtin_struct (grid_attr_trees->kernel_launch_attributes_type,\n-\t\t\t \"__gomp_kernel_launch_attributes\",\n-\t\t\t grid_attr_trees->kernel_lattrs_group_decl, NULL_TREE);\n-}\n-\n-/* Insert before the current statement in GSI a store of VALUE to INDEX of\n-   array (of type kernel_dim_array_type) FLD_DECL of RANGE_VAR.  VALUE must be\n-   of type uint32_type_node.  */\n-\n-static void\n-grid_insert_store_range_dim (gimple_stmt_iterator *gsi, tree range_var,\n-\t\t\t     tree fld_decl, int index, tree value)\n-{\n-  tree ref = build4 (ARRAY_REF, uint32_type_node,\n-\t\t     build3 (COMPONENT_REF,\n-\t\t\t     grid_attr_trees->kernel_dim_array_type,\n-\t\t\t     range_var, fld_decl, NULL_TREE),\n-\t\t     build_int_cst (integer_type_node, index),\n-\t\t     NULL_TREE, NULL_TREE);\n-  gsi_insert_before (gsi, gimple_build_assign (ref, value), GSI_SAME_STMT);\n-}\n-\n-/* Return a tree representation of a pointer to a structure with grid and\n-   work-group size information.  Statements filling that information will be\n-   inserted before GSI, TGT_STMT is the target statement which has the\n-   necessary information in it.  */\n-\n-static tree\n-grid_get_kernel_launch_attributes (gimple_stmt_iterator *gsi,\n-\t\t\t\t       gomp_target *tgt_stmt)\n-{\n-  grid_create_kernel_launch_attr_types ();\n-  tree lattrs = create_tmp_var (grid_attr_trees->kernel_launch_attributes_type,\n-\t\t\t\t\"__kernel_launch_attrs\");\n-\n-  unsigned max_dim = 0;\n-  for (tree clause = gimple_omp_target_clauses (tgt_stmt);\n-       clause;\n-       clause = OMP_CLAUSE_CHAIN (clause))\n-    {\n-      if (OMP_CLAUSE_CODE (clause) != OMP_CLAUSE__GRIDDIM_)\n-\tcontinue;\n-\n-      unsigned dim = OMP_CLAUSE__GRIDDIM__DIMENSION (clause);\n-      max_dim = MAX (dim, max_dim);\n-\n-      grid_insert_store_range_dim (gsi, lattrs,\n-\t\t\t\t   grid_attr_trees->kernel_lattrs_grid_decl,\n-\t\t\t\t   dim, OMP_CLAUSE__GRIDDIM__SIZE (clause));\n-      grid_insert_store_range_dim (gsi, lattrs,\n-\t\t\t\t   grid_attr_trees->kernel_lattrs_group_decl,\n-\t\t\t\t   dim, OMP_CLAUSE__GRIDDIM__GROUP (clause));\n-    }\n-\n-  tree dimref = build3 (COMPONENT_REF, uint32_type_node, lattrs,\n-\t\t\tgrid_attr_trees->kernel_lattrs_dimnum_decl, NULL_TREE);\n-  gcc_checking_assert (max_dim <= 2);\n-  tree dimensions = build_int_cstu (uint32_type_node, max_dim + 1);\n-  gsi_insert_before (gsi, gimple_build_assign (dimref, dimensions),\n-\t\t     GSI_SAME_STMT);\n-  TREE_ADDRESSABLE (lattrs) = 1;\n-  return build_fold_addr_expr (lattrs);\n-}\n-\n /* Build target argument identifier from the DEVICE identifier, value\n    identifier ID and whether the element also has a SUBSEQUENT_PARAM.  */\n \n@@ -8725,16 +8579,6 @@ get_target_arguments (gimple_stmt_iterator *gsi, gomp_target *tgt_stmt)\n \t\t\t\t\t   GOMP_TARGET_ARG_THREAD_LIMIT, t,\n \t\t\t\t\t   &args);\n \n-  /* Add HSA-specific grid sizes, if available.  */\n-  if (omp_find_clause (gimple_omp_target_clauses (tgt_stmt),\n-\t\t       OMP_CLAUSE__GRIDDIM_))\n-    {\n-      int id = GOMP_TARGET_ARG_HSA_KERNEL_ATTRIBUTES;\n-      t = get_target_argument_identifier (GOMP_DEVICE_HSA, true, id);\n-      args.quick_push (t);\n-      args.quick_push (grid_get_kernel_launch_attributes (gsi, tgt_stmt));\n-    }\n-\n   /* Produce more, perhaps device specific, arguments here.  */\n \n   tree argarray = create_tmp_var (build_array_type_nelts (ptr_type_node,\n@@ -9351,302 +9195,6 @@ expand_omp_target (struct omp_region *region)\n     }\n }\n \n-/* Expand KFOR loop as a HSA grifidied kernel, i.e. as a body only with\n-   iteration variable derived from the thread number.  INTRA_GROUP means this\n-   is an expansion of a loop iterating over work-items within a separate\n-   iteration over groups.  */\n-\n-static void\n-grid_expand_omp_for_loop (struct omp_region *kfor, bool intra_group)\n-{\n-  gimple_stmt_iterator gsi;\n-  gomp_for *for_stmt = as_a <gomp_for *> (last_stmt (kfor->entry));\n-  gcc_checking_assert (gimple_omp_for_kind (for_stmt)\n-\t\t       == GF_OMP_FOR_KIND_GRID_LOOP);\n-  size_t collapse = gimple_omp_for_collapse (for_stmt);\n-  struct omp_for_data_loop *loops\n-    = XALLOCAVEC (struct omp_for_data_loop,\n-\t\t  gimple_omp_for_collapse (for_stmt));\n-  struct omp_for_data fd;\n-\n-  remove_edge (BRANCH_EDGE (kfor->entry));\n-  basic_block body_bb = FALLTHRU_EDGE (kfor->entry)->dest;\n-\n-  gcc_assert (kfor->cont);\n-  omp_extract_for_data (for_stmt, &fd, loops);\n-\n-  gsi = gsi_start_bb (body_bb);\n-\n-  for (size_t dim = 0; dim < collapse; dim++)\n-    {\n-      tree type, itype;\n-      itype = type = TREE_TYPE (fd.loops[dim].v);\n-      if (POINTER_TYPE_P (type))\n-\titype = signed_type_for (type);\n-\n-      tree n1 = fd.loops[dim].n1;\n-      tree step = fd.loops[dim].step;\n-      n1 = force_gimple_operand_gsi (&gsi, fold_convert (type, n1),\n-\t\t\t\t     true, NULL_TREE, true, GSI_SAME_STMT);\n-      step = force_gimple_operand_gsi (&gsi, fold_convert (itype, step),\n-\t\t\t\t       true, NULL_TREE, true, GSI_SAME_STMT);\n-      tree threadid;\n-      if (gimple_omp_for_grid_group_iter (for_stmt))\n-\t{\n-\t  gcc_checking_assert (!intra_group);\n-\t  threadid = build_call_expr (builtin_decl_explicit\n-\t\t\t\t      (BUILT_IN_HSA_WORKGROUPID), 1,\n-\t\t\t\t      build_int_cstu (unsigned_type_node, dim));\n-\t}\n-      else if (intra_group)\n-\tthreadid = build_call_expr (builtin_decl_explicit\n-\t\t\t\t    (BUILT_IN_HSA_WORKITEMID), 1,\n-\t\t\t\t    build_int_cstu (unsigned_type_node, dim));\n-      else\n-\tthreadid = build_call_expr (builtin_decl_explicit\n-\t\t\t\t    (BUILT_IN_HSA_WORKITEMABSID), 1,\n-\t\t\t\t    build_int_cstu (unsigned_type_node, dim));\n-      threadid = fold_convert (itype, threadid);\n-      threadid = force_gimple_operand_gsi (&gsi, threadid, true, NULL_TREE,\n-\t\t\t\t\t   true, GSI_SAME_STMT);\n-\n-      tree startvar = fd.loops[dim].v;\n-      tree t = fold_build2 (MULT_EXPR, itype, threadid, step);\n-      if (POINTER_TYPE_P (type))\n-\tt = fold_build_pointer_plus (n1, t);\n-      else\n-\tt = fold_build2 (PLUS_EXPR, type, t, n1);\n-      t = fold_convert (type, t);\n-      t = force_gimple_operand_gsi (&gsi, t,\n-\t\t\t\t    DECL_P (startvar)\n-\t\t\t\t    && TREE_ADDRESSABLE (startvar),\n-\t\t\t\t    NULL_TREE, true, GSI_SAME_STMT);\n-      gassign *assign_stmt = gimple_build_assign (startvar, t);\n-      gsi_insert_before (&gsi, assign_stmt, GSI_SAME_STMT);\n-    }\n-  /* Remove the omp for statement.  */\n-  gsi = gsi_last_nondebug_bb (kfor->entry);\n-  gsi_remove (&gsi, true);\n-\n-  /* Remove the GIMPLE_OMP_CONTINUE statement.  */\n-  gsi = gsi_last_nondebug_bb (kfor->cont);\n-  gcc_assert (!gsi_end_p (gsi)\n-\t      && gimple_code (gsi_stmt (gsi)) == GIMPLE_OMP_CONTINUE);\n-  gsi_remove (&gsi, true);\n-\n-  /* Replace the GIMPLE_OMP_RETURN with a barrier, if necessary.  */\n-  gsi = gsi_last_nondebug_bb (kfor->exit);\n-  gcc_assert (!gsi_end_p (gsi)\n-\t      && gimple_code (gsi_stmt (gsi)) == GIMPLE_OMP_RETURN);\n-  if (intra_group)\n-    gsi_insert_before (&gsi, omp_build_barrier (NULL_TREE), GSI_SAME_STMT);\n-  gsi_remove (&gsi, true);\n-\n-  /* Fixup the much simpler CFG.  */\n-  remove_edge (find_edge (kfor->cont, body_bb));\n-\n-  if (kfor->cont != body_bb)\n-    set_immediate_dominator (CDI_DOMINATORS, kfor->cont, body_bb);\n-  set_immediate_dominator (CDI_DOMINATORS, kfor->exit, kfor->cont);\n-}\n-\n-/* Structure passed to grid_remap_kernel_arg_accesses so that it can remap\n-   argument_decls.  */\n-\n-struct grid_arg_decl_map\n-{\n-  tree old_arg;\n-  tree new_arg;\n-};\n-\n-/* Invoked through walk_gimple_op, will remap all PARM_DECLs to the ones\n-   pertaining to kernel function.  */\n-\n-static tree\n-grid_remap_kernel_arg_accesses (tree *tp, int *walk_subtrees, void *data)\n-{\n-  struct walk_stmt_info *wi = (struct walk_stmt_info *) data;\n-  struct grid_arg_decl_map *adm = (struct grid_arg_decl_map *) wi->info;\n-  tree t = *tp;\n-\n-  if (t == adm->old_arg)\n-    *tp = adm->new_arg;\n-  *walk_subtrees = !TYPE_P (t) && !DECL_P (t);\n-  return NULL_TREE;\n-}\n-\n-/* If TARGET region contains a kernel body for loop, remove its region from the\n-   TARGET and expand it in HSA gridified kernel fashion.  */\n-\n-static void\n-grid_expand_target_grid_body (struct omp_region *target)\n-{\n-  if (!hsa_gen_requested_p ())\n-    return;\n-\n-  gomp_target *tgt_stmt = as_a <gomp_target *> (last_stmt (target->entry));\n-  struct omp_region **pp;\n-\n-  for (pp = &target->inner; *pp; pp = &(*pp)->next)\n-    if ((*pp)->type == GIMPLE_OMP_GRID_BODY)\n-      break;\n-\n-  struct omp_region *gpukernel = *pp;\n-\n-  tree orig_child_fndecl = gimple_omp_target_child_fn (tgt_stmt);\n-  if (!gpukernel)\n-    {\n-      /* HSA cannot handle OACC stuff.  */\n-      if (gimple_omp_target_kind (tgt_stmt) != GF_OMP_TARGET_KIND_REGION)\n-\treturn;\n-      gcc_checking_assert (orig_child_fndecl);\n-      gcc_assert (!omp_find_clause (gimple_omp_target_clauses (tgt_stmt),\n-\t\t\t\t    OMP_CLAUSE__GRIDDIM_));\n-      cgraph_node *n = cgraph_node::get (orig_child_fndecl);\n-\n-      hsa_register_kernel (n);\n-      return;\n-    }\n-\n-  gcc_assert (omp_find_clause (gimple_omp_target_clauses (tgt_stmt),\n-\t\t\t       OMP_CLAUSE__GRIDDIM_));\n-  tree inside_block\n-    = gimple_block (first_stmt (single_succ (gpukernel->entry)));\n-  *pp = gpukernel->next;\n-  for (pp = &gpukernel->inner; *pp; pp = &(*pp)->next)\n-    if ((*pp)->type == GIMPLE_OMP_FOR)\n-      break;\n-\n-  struct omp_region *kfor = *pp;\n-  gcc_assert (kfor);\n-  gomp_for *for_stmt = as_a <gomp_for *> (last_stmt (kfor->entry));\n-  gcc_assert (gimple_omp_for_kind (for_stmt) == GF_OMP_FOR_KIND_GRID_LOOP);\n-  *pp = kfor->next;\n-  if (kfor->inner)\n-    {\n-      if (gimple_omp_for_grid_group_iter (for_stmt))\n-\t{\n-\t  struct omp_region **next_pp;\n-\t  for (pp = &kfor->inner; *pp; pp = next_pp)\n-\t    {\n-\t      next_pp = &(*pp)->next;\n-\t      if ((*pp)->type != GIMPLE_OMP_FOR)\n-\t\tcontinue;\n-\t      gomp_for *inner = as_a <gomp_for *> (last_stmt ((*pp)->entry));\n-\t      gcc_assert (gimple_omp_for_kind (inner)\n-\t\t\t  == GF_OMP_FOR_KIND_GRID_LOOP);\n-\t      grid_expand_omp_for_loop (*pp, true);\n-\t      *pp = (*pp)->next;\n-\t      next_pp = pp;\n-\t    }\n-\t}\n-      expand_omp (kfor->inner);\n-    }\n-  if (gpukernel->inner)\n-    expand_omp (gpukernel->inner);\n-\n-  tree kern_fndecl = copy_node (orig_child_fndecl);\n-  DECL_NAME (kern_fndecl) = clone_function_name_numbered (kern_fndecl,\n-\t\t\t\t\t\t\t  \"kernel\");\n-  SET_DECL_ASSEMBLER_NAME (kern_fndecl, DECL_NAME (kern_fndecl));\n-  tree tgtblock = gimple_block (tgt_stmt);\n-  tree fniniblock = make_node (BLOCK);\n-  BLOCK_ABSTRACT_ORIGIN (fniniblock) = BLOCK_ORIGIN (tgtblock);\n-  BLOCK_SOURCE_LOCATION (fniniblock) = BLOCK_SOURCE_LOCATION (tgtblock);\n-  BLOCK_SOURCE_END_LOCATION (fniniblock) = BLOCK_SOURCE_END_LOCATION (tgtblock);\n-  BLOCK_SUPERCONTEXT (fniniblock) = kern_fndecl;\n-  DECL_INITIAL (kern_fndecl) = fniniblock;\n-  push_struct_function (kern_fndecl);\n-  cfun->function_end_locus = gimple_location (tgt_stmt);\n-  init_tree_ssa (cfun);\n-  pop_cfun ();\n-\n-  tree old_parm_decl = DECL_ARGUMENTS (kern_fndecl);\n-  gcc_assert (!DECL_CHAIN (old_parm_decl));\n-  tree new_parm_decl = copy_node (DECL_ARGUMENTS (kern_fndecl));\n-  DECL_CONTEXT (new_parm_decl) = kern_fndecl;\n-  DECL_ARGUMENTS (kern_fndecl) = new_parm_decl;\n-  gcc_assert (VOID_TYPE_P (TREE_TYPE (DECL_RESULT (kern_fndecl))));\n-  DECL_RESULT (kern_fndecl) = copy_node (DECL_RESULT (kern_fndecl));\n-  DECL_CONTEXT (DECL_RESULT (kern_fndecl)) = kern_fndecl;\n-  struct function *kern_cfun = DECL_STRUCT_FUNCTION (kern_fndecl);\n-  kern_cfun->curr_properties = cfun->curr_properties;\n-\n-  grid_expand_omp_for_loop (kfor, false);\n-\n-  /* Remove the omp for statement.  */\n-  gimple_stmt_iterator gsi = gsi_last_nondebug_bb (gpukernel->entry);\n-  gsi_remove (&gsi, true);\n-  /* Replace the GIMPLE_OMP_RETURN at the end of the kernel region with a real\n-     return.  */\n-  gsi = gsi_last_nondebug_bb (gpukernel->exit);\n-  gcc_assert (!gsi_end_p (gsi)\n-\t      && gimple_code (gsi_stmt (gsi)) == GIMPLE_OMP_RETURN);\n-  gimple *ret_stmt = gimple_build_return (NULL);\n-  gsi_insert_after (&gsi, ret_stmt, GSI_SAME_STMT);\n-  gsi_remove (&gsi, true);\n-\n-  /* Statements in the first BB in the target construct have been produced by\n-     target lowering and must be copied inside the GPUKERNEL, with the two\n-     exceptions of the first OMP statement and the OMP_DATA assignment\n-     statement.  */\n-  gsi = gsi_start_bb (single_succ (gpukernel->entry));\n-  tree data_arg = gimple_omp_target_data_arg (tgt_stmt);\n-  tree sender = data_arg ? TREE_VEC_ELT (data_arg, 0) : NULL;\n-  for (gimple_stmt_iterator tsi = gsi_start_bb (single_succ (target->entry));\n-       !gsi_end_p (tsi); gsi_next (&tsi))\n-    {\n-      gimple *stmt = gsi_stmt (tsi);\n-      if (is_gimple_omp (stmt))\n-\tbreak;\n-      if (sender\n-\t  && is_gimple_assign (stmt)\n-\t  && TREE_CODE (gimple_assign_rhs1 (stmt)) == ADDR_EXPR\n-\t  && TREE_OPERAND (gimple_assign_rhs1 (stmt), 0) == sender)\n-\tcontinue;\n-      gimple *copy = gimple_copy (stmt);\n-      gsi_insert_before (&gsi, copy, GSI_SAME_STMT);\n-      gimple_set_block (copy, fniniblock);\n-    }\n-\n-  move_sese_region_to_fn (kern_cfun, single_succ (gpukernel->entry),\n-\t\t\t  gpukernel->exit, inside_block);\n-\n-  cgraph_node *kcn = cgraph_node::get_create (kern_fndecl);\n-  kcn->mark_force_output ();\n-  cgraph_node *orig_child = cgraph_node::get (orig_child_fndecl);\n-\n-  hsa_register_kernel (kcn, orig_child);\n-\n-  cgraph_node::add_new_function (kern_fndecl, true);\n-  push_cfun (kern_cfun);\n-  cgraph_edge::rebuild_edges ();\n-\n-  /* Re-map any mention of the PARM_DECL of the original function to the\n-     PARM_DECL of the new one.\n-\n-     TODO: It would be great if lowering produced references into the GPU\n-     kernel decl straight away and we did not have to do this.  */\n-  struct grid_arg_decl_map adm;\n-  adm.old_arg = old_parm_decl;\n-  adm.new_arg = new_parm_decl;\n-  basic_block bb;\n-  FOR_EACH_BB_FN (bb, kern_cfun)\n-    {\n-      for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n-\t{\n-\t  gimple *stmt = gsi_stmt (gsi);\n-\t  struct walk_stmt_info wi;\n-\t  memset (&wi, 0, sizeof (wi));\n-\t  wi.info = &adm;\n-\t  walk_gimple_op (stmt, grid_remap_kernel_arg_accesses, &wi);\n-\t}\n-    }\n-  pop_cfun ();\n-\n-  return;\n-}\n-\n /* Expand the parallel region tree rooted at REGION.  Expansion\n    proceeds in depth-first order.  Innermost regions are expanded\n    first.  This way, parallel regions that require a new function to\n@@ -9666,8 +9214,6 @@ expand_omp (struct omp_region *region)\n \t region.  */\n       if (region->type == GIMPLE_OMP_PARALLEL)\n \tdetermine_parallel_type (region);\n-      else if (region->type == GIMPLE_OMP_TARGET)\n-\tgrid_expand_target_grid_body (region);\n \n       if (region->type == GIMPLE_OMP_FOR\n \t  && gimple_omp_for_combined_p (last_stmt (region->entry)))\n@@ -10039,7 +9585,6 @@ omp_make_gimple_edges (basic_block bb, struct omp_region **region,\n     case GIMPLE_OMP_TASKGROUP:\n     case GIMPLE_OMP_CRITICAL:\n     case GIMPLE_OMP_SECTION:\n-    case GIMPLE_OMP_GRID_BODY:\n       cur_region = new_omp_region (bb, code, cur_region);\n       fallthru = true;\n       break;\n@@ -10181,5 +9726,3 @@ omp_make_gimple_edges (basic_block bb, struct omp_region **region,\n \n   return fallthru;\n }\n-\n-#include \"gt-omp-expand.h\""}, {"sha": "6e6d3e1c6f628e13ac0492b6838d4f095d650637", "filename": "gcc/omp-general.c", "status": "modified", "additions": 6, "deletions": 21, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c56684fd61223abd45854270cd1e83ab2f07148c/gcc%2Fomp-general.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c56684fd61223abd45854270cd1e83ab2f07148c/gcc%2Fomp-general.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-general.c?ref=c56684fd61223abd45854270cd1e83ab2f07148c", "patch": "@@ -39,7 +39,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cgraph.h\"\n #include \"alloc-pool.h\"\n #include \"symbol-summary.h\"\n-#include \"hsa-common.h\"\n #include \"tree-pass.h\"\n #include \"omp-device-properties.h\"\n #include \"tree-iterator.h\"\n@@ -1052,14 +1051,12 @@ omp_offload_device_kind_arch_isa (const char *props, const char *prop)\n static bool\n omp_maybe_offloaded (void)\n {\n-  if (!hsa_gen_requested_p ())\n-    {\n-      if (!ENABLE_OFFLOADING)\n-\treturn false;\n-      const char *names = getenv (\"OFFLOAD_TARGET_NAMES\");\n-      if (names == NULL || *names == '\\0')\n-\treturn false;\n-    }\n+  if (!ENABLE_OFFLOADING)\n+    return false;\n+  const char *names = getenv (\"OFFLOAD_TARGET_NAMES\");\n+  if (names == NULL || *names == '\\0')\n+    return false;\n+\n   if (symtab->state == PARSING)\n     /* Maybe.  */\n     return true;\n@@ -1234,12 +1231,6 @@ omp_context_selector_matches (tree ctx)\n \t\t\t   also offloading values.  */\n \t\t\tif (!omp_maybe_offloaded ())\n \t\t\t  return 0;\n-\t\t\tif (strcmp (arch, \"hsa\") == 0\n-\t\t\t    && hsa_gen_requested_p ())\n-\t\t\t  {\n-\t\t\t    ret = -1;\n-\t\t\t    continue;\n-\t\t\t  }\n \t\t\tif (ENABLE_OFFLOADING)\n \t\t\t  {\n \t\t\t    const char *arches = omp_offload_device_arch;\n@@ -1360,12 +1351,6 @@ omp_context_selector_matches (tree ctx)\n \t\t\t   also offloading values.  */\n \t\t\tif (!omp_maybe_offloaded ())\n \t\t\t  return 0;\n-\t\t\tif (strcmp (prop, \"gpu\") == 0\n-\t\t\t    && hsa_gen_requested_p ())\n-\t\t\t  {\n-\t\t\t    ret = -1;\n-\t\t\t    continue;\n-\t\t\t  }\n \t\t\tif (ENABLE_OFFLOADING)\n \t\t\t  {\n \t\t\t    const char *kinds = omp_offload_device_kind;"}, {"sha": "ba635fd3ea2a33ae1560ef5589aee2463e14c21e", "filename": "gcc/omp-grid.c", "status": "removed", "additions": 0, "deletions": 1419, "changes": 1419, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9623f61b142174b87760c81f78928dd14af7cbc6/gcc%2Fomp-grid.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9623f61b142174b87760c81f78928dd14af7cbc6/gcc%2Fomp-grid.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-grid.c?ref=9623f61b142174b87760c81f78928dd14af7cbc6", "patch": "@@ -1,1419 +0,0 @@\n-/* Lowering and expansion of OpenMP directives for HSA GPU agents.\n-\n-   Copyright (C) 2013-2020 Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"backend.h\"\n-#include \"tree.h\"\n-#include \"gimple.h\"\n-#include \"tree-pass.h\"\n-#include \"ssa.h\"\n-#include \"cgraph.h\"\n-#include \"pretty-print.h\"\n-#include \"fold-const.h\"\n-#include \"gimplify.h\"\n-#include \"gimple-iterator.h\"\n-#include \"gimple-walk.h\"\n-#include \"tree-inline.h\"\n-#include \"langhooks.h\"\n-#include \"omp-general.h\"\n-#include \"omp-low.h\"\n-#include \"omp-grid.h\"\n-#include \"gimple-pretty-print.h\"\n-\n-/* Return the lastprivate predicate for a given gridified loop described by\n-   FD).  */\n-\n-tree\n-omp_grid_lastprivate_predicate (struct omp_for_data *fd)\n-{\n-  /* When dealing with a gridified loop, we need to check up to three collapsed\n-     iteration variables but they are not actually captured in this fd.\n-     Fortunately, we can easily rely on HSA builtins to get this\n-     information.  */\n-\n-  tree id, size;\n-  if (gimple_omp_for_kind (fd->for_stmt) == GF_OMP_FOR_KIND_GRID_LOOP\n-      && gimple_omp_for_grid_intra_group (fd->for_stmt))\n-    {\n-      id = builtin_decl_explicit (BUILT_IN_HSA_WORKITEMID);\n-      size = builtin_decl_explicit (BUILT_IN_HSA_CURRENTWORKGROUPSIZE);\n-    }\n-  else\n-    {\n-      id = builtin_decl_explicit (BUILT_IN_HSA_WORKITEMABSID);\n-      size = builtin_decl_explicit (BUILT_IN_HSA_GRIDSIZE);\n-    }\n-  tree cond = NULL;\n-  for (int dim = 0; dim < fd->collapse; dim++)\n-    {\n-      tree dim_tree = build_int_cstu (unsigned_type_node, dim);\n-      tree u1 = build_int_cstu (unsigned_type_node, 1);\n-      tree c2\n-\t= build2 (EQ_EXPR, boolean_type_node,\n-\t\t  build2 (PLUS_EXPR, unsigned_type_node,\n-\t\t\t  build_call_expr (id, 1, dim_tree), u1),\n-\t\t  build_call_expr (size, 1, dim_tree));\n-      if (cond)\n-\tcond = build2 (TRUTH_AND_EXPR, boolean_type_node, cond, c2);\n-      else\n-\tcond = c2;\n-    }\n-  return cond;\n-}\n-\n-/* Structure describing the basic properties of the loop we ara analyzing\n-   whether it can be gridified and when it is gridified.  */\n-\n-class grid_prop\n-{\n-public:\n-  /* True when we are doing tiling gridification, i.e. when there is a distinct\n-     distribute loop over groups and a loop construct over work-items.  False\n-     when distribute and parallel for loops form a combined construct.  */\n-  bool tiling;\n-  /* Location of the target construct for optimization information\n-     messages.  */\n-  dump_user_location_t target_loc;\n-  /* The collapse clause of the involved loops.  Collapse value of all of them\n-     must be the same for gridification to take place.  */\n-  size_t collapse;\n-  /* Group sizes, if requested by the user or NULL if not requested.  */\n-  tree group_sizes[3];\n-};\n-\n-#define GRID_MISSED_MSG_PREFIX \"Will not turn target construct into a \" \\\n-  \"gridified HSA kernel because \"\n-\n-/* Return true if STMT is an assignment of a register-type into a local\n-   VAR_DECL.  If GRID is non-NULL, the assignment additionally must not be to\n-   any of the trees specifying group sizes there.  */\n-\n-static bool\n-grid_safe_assignment_p (gimple *stmt, grid_prop *grid)\n-{\n-  gassign *assign = dyn_cast <gassign *> (stmt);\n-  if (!assign)\n-    return false;\n-  if (gimple_clobber_p (assign))\n-    return true;\n-  tree lhs = gimple_assign_lhs (assign);\n-  if (!VAR_P (lhs)\n-      || !is_gimple_reg_type (TREE_TYPE (lhs))\n-      || is_global_var (lhs))\n-    return false;\n-  if (grid)\n-    for (unsigned i = 0; i < grid->collapse; i++)\n-      if (lhs == grid->group_sizes[i])\n-\treturn false;\n-  return true;\n-}\n-\n-/* Return true if all statements in SEQ are assignments to local register-type\n-   variables that do not hold group size information.  */\n-\n-static bool\n-grid_seq_only_contains_local_assignments (gimple_seq seq, grid_prop *grid)\n-{\n-  if (!seq)\n-    return true;\n-\n-  gimple_stmt_iterator gsi;\n-  for (gsi = gsi_start (seq); !gsi_end_p (gsi); gsi_next (&gsi))\n-    if (!grid_safe_assignment_p (gsi_stmt (gsi), grid))\n-      return false;\n-  return true;\n-}\n-\n-/* Scan statements in SEQ and call itself recursively on any bind.  GRID\n-   describes hitherto discovered properties of the loop that is evaluated for\n-   possible gridification.  If during whole search only assignments to\n-   register-type local variables (that do not overwrite group size information)\n-   and one single OMP statement is encountered, return true, otherwise return\n-   false.  RET is where we store any OMP statement encountered.  */\n-\n-static bool\n-grid_find_single_omp_among_assignments_1 (gimple_seq seq, grid_prop *grid,\n-\t\t\t\t\t  const char *name, gimple **ret)\n-{\n-  gimple_stmt_iterator gsi;\n-  for (gsi = gsi_start (seq); !gsi_end_p (gsi); gsi_next (&gsi))\n-    {\n-      gimple *stmt = gsi_stmt (gsi);\n-\n-      if (grid_safe_assignment_p (stmt, grid))\n-\tcontinue;\n-      if (gbind *bind = dyn_cast <gbind *> (stmt))\n-\t{\n-\t  gimple_seq bind_body = gimple_bind_body (bind);\n-\t  if (!grid_find_single_omp_among_assignments_1 (bind_body, grid, name,\n-\t\t\t\t\t\t\t ret))\n-\t      return false;\n-\t}\n-      else if (is_gimple_omp (stmt))\n-\t{\n-\t  if (*ret)\n-\t    {\n-\t      if (dump_enabled_p ())\n-\t\t{\n-\t\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, grid->target_loc,\n-\t\t\t\t   GRID_MISSED_MSG_PREFIX \"%s construct \"\n-\t\t\t\t   \"contains multiple OpenMP constructs\\n\",\n-\t\t\t\t   name);\n-\t\t  dump_printf_loc (MSG_NOTE, *ret,\n-\t\t\t\t   \"The first OpenMP construct within \"\n-\t\t\t\t   \"a parallel\\n\");\n-\t\t  dump_printf_loc (MSG_NOTE, stmt,\n-\t\t\t\t   \"The second OpenMP construct within \"\n-\t\t\t\t   \"a parallel\\n\");\n-\t\t}\n-\t      return false;\n-\t    }\n-\t  *ret = stmt;\n-\t}\n-      else\n-\t{\n-\t  if (dump_enabled_p ())\n-\t    {\n-\t      dump_printf_loc (MSG_MISSED_OPTIMIZATION, grid->target_loc,\n-\t\t\t       GRID_MISSED_MSG_PREFIX \"%s construct contains \"\n-\t\t\t       \"a complex statement\\n\", name);\n-\t      dump_printf_loc (MSG_NOTE, stmt,\n-\t\t\t       \"This statement cannot be analyzed for \"\n-\t\t\t       \"gridification\\n\");\n-\t    }\n-\t  return false;\n-\t}\n-    }\n-  return true;\n-}\n-\n-/* Scan statements in SEQ and make sure that it and any binds in it contain\n-   only assignments to local register-type variables (that do not overwrite\n-   group size information) and one OMP construct.  If so, return that\n-   construct, otherwise return NULL.  GRID describes hitherto discovered\n-   properties of the loop that is evaluated for possible gridification.  If\n-   dumping is enabled and function fails, use NAME to dump a note with the\n-   reason for failure.  */\n-\n-static gimple *\n-grid_find_single_omp_among_assignments (gimple_seq seq, grid_prop *grid,\n-\t\t\t\t\tconst char *name)\n-{\n-  if (!seq)\n-    {\n-      if (dump_enabled_p ())\n-\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, grid->target_loc,\n-\t\t\t GRID_MISSED_MSG_PREFIX \"%s construct has empty body\\n\",\n-\t\t\t name);\n-      return NULL;\n-    }\n-\n-  gimple *ret = NULL;\n-  if (grid_find_single_omp_among_assignments_1 (seq, grid, name, &ret))\n-    {\n-      if (!ret && dump_enabled_p ())\n-\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, grid->target_loc,\n-\t\t\t GRID_MISSED_MSG_PREFIX \"%s construct does not contain\"\n-\t\t\t \" any other OpenMP construct\\n\", name);\n-      return ret;\n-    }\n-  else\n-    return NULL;\n-}\n-\n-/* Walker function looking for statements there is no point gridifying (and for\n-   noreturn function calls which we cannot do).  Return non-NULL if such a\n-   function is found.  */\n-\n-static tree\n-grid_find_ungridifiable_statement (gimple_stmt_iterator *gsi,\n-\t\t\t\t   bool *handled_ops_p,\n-\t\t\t\t   struct walk_stmt_info *wi)\n-{\n-  *handled_ops_p = false;\n-  gimple *stmt = gsi_stmt (*gsi);\n-  switch (gimple_code (stmt))\n-    {\n-    case GIMPLE_CALL:\n-      if (gimple_call_noreturn_p (as_a <gcall *> (stmt)))\n-\t{\n-\t  *handled_ops_p = true;\n-\t  wi->info = stmt;\n-\t  return error_mark_node;\n-\t}\n-      break;\n-\n-    /* We may reduce the following list if we find a way to implement the\n-       clauses, but now there is no point trying further.  */\n-    case GIMPLE_OMP_CRITICAL:\n-    case GIMPLE_OMP_TASKGROUP:\n-    case GIMPLE_OMP_TASK:\n-    case GIMPLE_OMP_SECTION:\n-    case GIMPLE_OMP_SECTIONS:\n-    case GIMPLE_OMP_SECTIONS_SWITCH:\n-    case GIMPLE_OMP_TARGET:\n-    case GIMPLE_OMP_ORDERED:\n-      *handled_ops_p = true;\n-      wi->info = stmt;\n-      return error_mark_node;\n-    default:\n-      break;\n-    }\n-  return NULL;\n-}\n-\n-/* Examine clauses of omp parallel statement PAR and if any prevents\n-   gridification, issue a missed-optimization diagnostics and return false,\n-   otherwise return true.  GRID describes hitherto discovered properties of the\n-   loop that is evaluated for possible gridification.  */\n-\n-static bool\n-grid_parallel_clauses_gridifiable (gomp_parallel *par, dump_user_location_t tloc)\n-{\n-  tree clauses = gimple_omp_parallel_clauses (par);\n-  while (clauses)\n-    {\n-      switch (OMP_CLAUSE_CODE (clauses))\n-\t{\n-\tcase OMP_CLAUSE_NUM_THREADS:\n-\t  if (dump_enabled_p ())\n-\t    {\n-\t      dump_printf_loc (MSG_MISSED_OPTIMIZATION, tloc,\n-\t\t\t       GRID_MISSED_MSG_PREFIX \"because there is \"\n-\t\t\t       \"a num_threads clause of the parallel \"\n-\t\t\t       \"construct\\n\");\n-\t      dump_printf_loc (MSG_NOTE, par,\n-\t\t\t       \"Parallel construct has a num_threads clause\\n\");\n-\t    }\n-\t  return false;\n-\n-\tcase OMP_CLAUSE_REDUCTION:\n-\t  if (dump_enabled_p ())\n-\t    {\n-\t      dump_printf_loc (MSG_MISSED_OPTIMIZATION, tloc,\n-\t\t\t       GRID_MISSED_MSG_PREFIX \"a reduction clause \"\n-\t\t\t       \"is present\\n \");\n-\t      dump_printf_loc (MSG_NOTE, par,\n-\t\t\t       \"Parallel construct has a reduction clause\\n\");\n-\t    }\n-\t  return false;\n-\n-\tdefault:\n-\t  break;\n-\t}\n-      clauses = OMP_CLAUSE_CHAIN (clauses);\n-    }\n-  return true;\n-}\n-\n-/* Examine clauses and the body of omp loop statement GFOR and if something\n-   prevents gridification, issue a missed-optimization diagnostics and return\n-   false, otherwise return true.  GRID describes hitherto discovered properties\n-   of the loop that is evaluated for possible gridification.  */\n-\n-static bool\n-grid_inner_loop_gridifiable_p (gomp_for *gfor, grid_prop *grid)\n-{\n-  if (!grid_seq_only_contains_local_assignments (gimple_omp_for_pre_body (gfor),\n-\t\t\t\t\t\t grid))\n-    {\n-      if (dump_enabled_p ())\n-\t{\n-\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, grid->target_loc,\n-\t\t\t   GRID_MISSED_MSG_PREFIX \"the inner loop \"\n-\t\t\t   \"loop bounds computation contains a complex \"\n-\t\t\t   \"statement\\n\");\n-\t  dump_printf_loc (MSG_NOTE, gfor,\n-\t\t\t   \"Loop construct cannot be analyzed for \"\n-\t\t\t   \"gridification\\n\");\n-\t}\n-      return false;\n-    }\n-\n-  tree clauses = gimple_omp_for_clauses (gfor);\n-  while (clauses)\n-    {\n-      switch (OMP_CLAUSE_CODE (clauses))\n-\t{\n-\tcase OMP_CLAUSE_SCHEDULE:\n-\t  if (OMP_CLAUSE_SCHEDULE_KIND (clauses) != OMP_CLAUSE_SCHEDULE_AUTO)\n-\t    {\n-\t      if (dump_enabled_p ())\n-\t\t{\n-\t\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, grid->target_loc,\n-\t\t\t\t   GRID_MISSED_MSG_PREFIX \"the inner loop \"\n-\t\t\t\t   \"has a non-automatic schedule clause\\n\");\n-\t\t  dump_printf_loc (MSG_NOTE, gfor,\n-\t\t\t\t   \"Loop construct has a non automatic \"\n-\t\t\t\t   \"schedule clause\\n\");\n-\t\t}\n-\t      return false;\n-\t    }\n-\t  break;\n-\n-\tcase OMP_CLAUSE_REDUCTION:\n-\t  if (dump_enabled_p ())\n-\t    {\n-\t      dump_printf_loc (MSG_MISSED_OPTIMIZATION, grid->target_loc,\n-\t\t\t       GRID_MISSED_MSG_PREFIX \"a reduction \"\n-\t\t\t       \"clause is present\\n \");\n-\t      dump_printf_loc (MSG_NOTE, gfor,\n-\t\t\t       \"Loop construct has a reduction schedule \"\n-\t\t\t       \"clause\\n\");\n-\t    }\n-\t  return false;\n-\n-\tdefault:\n-\t  break;\n-\t}\n-      clauses = OMP_CLAUSE_CHAIN (clauses);\n-    }\n-  struct walk_stmt_info wi;\n-  memset (&wi, 0, sizeof (wi));\n-  if (walk_gimple_seq (gimple_omp_body (gfor),\n-\t\t       grid_find_ungridifiable_statement,\n-\t\t       NULL, &wi))\n-    {\n-      gimple *bad = (gimple *) wi.info;\n-      if (dump_enabled_p ())\n-\t{\n-\t  if (is_gimple_call (bad))\n-\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, grid->target_loc,\n-\t\t\t       GRID_MISSED_MSG_PREFIX \"the inner loop contains \"\n-\t\t\t       \"call to a noreturn function\\n\");\n-\t  else\n-\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, grid->target_loc,\n-\t\t\t     GRID_MISSED_MSG_PREFIX \"the inner loop contains \"\n-\t\t\t     \"statement %s which cannot be transformed\\n\",\n-\t\t\t     gimple_code_name[(int) gimple_code (bad)]);\n-\t  dump_printf_loc (MSG_NOTE, bad,\n-\t\t\t   \"This statement cannot be analyzed for \"\n-\t\t\t   \"gridification\\n\");\n-\t}\n-      return false;\n-    }\n-  return true;\n-}\n-\n-/* Given distribute omp construct represented by DIST, which in the original\n-   source forms a compound construct with a looping construct, return true if it\n-   can be turned into a gridified HSA kernel.  Otherwise return false.  GRID\n-   describes hitherto discovered properties of the loop that is evaluated for\n-   possible gridification.  */\n-\n-static bool\n-grid_dist_follows_simple_pattern (gomp_for *dist, grid_prop *grid)\n-{\n-  dump_user_location_t tloc = grid->target_loc;\n-  gimple *stmt = grid_find_single_omp_among_assignments (gimple_omp_body (dist),\n-\t\t\t\t\t\t\t grid, \"distribute\");\n-  gomp_parallel *par;\n-  if (!stmt\n-      || !(par = dyn_cast <gomp_parallel *> (stmt))\n-      || !grid_parallel_clauses_gridifiable (par, tloc))\n-    return false;\n-\n-  stmt = grid_find_single_omp_among_assignments (gimple_omp_body (par), grid,\n-\t\t\t\t\t\t \"parallel\");\n-  gomp_for *gfor;\n-  if (!stmt || !(gfor = dyn_cast <gomp_for *> (stmt)))\n-    return false;\n-\n-  if (gimple_omp_for_kind (gfor) != GF_OMP_FOR_KIND_FOR)\n-    {\n-      if (dump_enabled_p ())\n-\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, tloc,\n-\t\t\t GRID_MISSED_MSG_PREFIX \"the inner loop is not \"\n-\t\t\t \"a simple for loop\\n\");\n-      return false;\n-    }\n-  gcc_assert (gimple_omp_for_collapse (gfor) == grid->collapse);\n-\n-  if (!grid_inner_loop_gridifiable_p (gfor, grid))\n-    return false;\n-\n-  return true;\n-}\n-\n-/* Given an omp loop statement GFOR, return true if it can participate in\n-   tiling gridification, i.e. in one where the distribute and parallel for\n-   loops do not form a compound statement.  GRID describes hitherto discovered\n-   properties of the loop that is evaluated for possible gridification.  */\n-\n-static bool\n-grid_gfor_follows_tiling_pattern (gomp_for *gfor, grid_prop *grid)\n-{\n-  if (gimple_omp_for_kind (gfor) != GF_OMP_FOR_KIND_FOR)\n-    {\n-      if (dump_enabled_p ())\n-\t{\n-\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, grid->target_loc,\n-\t\t\t   GRID_MISSED_MSG_PREFIX \"an inner loop is not \"\n-\t\t\t   \"a simple for loop\\n\");\n-\t  dump_printf_loc (MSG_NOTE, gfor,\n-\t\t\t   \"This statement is not a simple for loop\\n\");\n-\t}\n-      return false;\n-    }\n-\n-  if (!grid_inner_loop_gridifiable_p (gfor, grid))\n-    return false;\n-\n-  if (gimple_omp_for_collapse (gfor) != grid->collapse)\n-    {\n-      if (dump_enabled_p ())\n-\t{\n-\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, grid->target_loc,\n-\t\t\t   GRID_MISSED_MSG_PREFIX \"an inner loop does not \"\n-\t\t\t   \"have use the same collapse clause\\n\");\n-\t  dump_printf_loc (MSG_NOTE, gfor,\n-\t\t\t   \"Loop construct uses a different collapse clause\\n\");\n-\t}\n-      return false;\n-    }\n-\n-  struct omp_for_data fd;\n-  struct omp_for_data_loop *loops\n-    = (struct omp_for_data_loop *)alloca (grid->collapse\n-\t\t\t\t\t  * sizeof (struct omp_for_data_loop));\n-  omp_extract_for_data (gfor, &fd, loops);\n-  for (unsigned i = 0; i < grid->collapse; i++)\n-    {\n-      tree itype, type = TREE_TYPE (fd.loops[i].v);\n-      if (POINTER_TYPE_P (type))\n-\titype = signed_type_for (type);\n-      else\n-\titype = type;\n-\n-      tree n1 = fold_convert (itype, fd.loops[i].n1);\n-      tree n2 = fold_convert (itype, fd.loops[i].n2);\n-      tree t = build_int_cst (itype,\n-\t\t\t      (fd.loops[i].cond_code == LT_EXPR ? -1 : 1));\n-      t = fold_build2 (PLUS_EXPR, itype, fd.loops[i].step, t);\n-      t = fold_build2 (PLUS_EXPR, itype, t, n2);\n-      t = fold_build2 (MINUS_EXPR, itype, t, n1);\n-      if (TYPE_UNSIGNED (itype) && fd.loops[i].cond_code == GT_EXPR)\n-\tt = fold_build2 (TRUNC_DIV_EXPR, itype,\n-\t\t\t fold_build1 (NEGATE_EXPR, itype, t),\n-\t\t\t fold_build1 (NEGATE_EXPR, itype, fd.loops[i].step));\n-      else\n-\tt = fold_build2 (TRUNC_DIV_EXPR, itype, t, fd.loops[i].step);\n-\n-      if (!operand_equal_p (grid->group_sizes[i], t, 0))\n-\t{\n-\t  if (dump_enabled_p ())\n-\t    {\n-\t      dump_printf_loc (MSG_MISSED_OPTIMIZATION, grid->target_loc,\n-\t\t\t       GRID_MISSED_MSG_PREFIX \"the distribute and \"\n-\t\t\t       \"an internal loop do not agree on tile size\\n\");\n-\t      dump_printf_loc (MSG_NOTE, gfor,\n-\t\t\t       \"Loop construct does not seem to loop over \"\n-\t\t\t       \"a tile size\\n\");\n-\t    }\n-\t  return false;\n-\t}\n-    }\n-  return true;\n-}\n-\n-/* Facing a call to FNDECL in the body of a distribute construct, return true\n-   if we can handle it or false if it precludes gridification.  */\n-\n-static bool\n-grid_call_permissible_in_distribute_p (tree fndecl)\n-{\n-  if (DECL_PURE_P (fndecl) || TREE_READONLY (fndecl))\n-    return true;\n-\n-  const char *name = IDENTIFIER_POINTER (DECL_NAME (fndecl));\n-  if (strstr (name, \"omp_\") != name)\n-    return false;\n-\n-  if ((strcmp (name, \"omp_get_thread_num\") == 0)\n-      || (strcmp (name, \"omp_get_num_threads\") == 0)\n-      || (strcmp (name, \"omp_get_num_teams\") == 0)\n-      || (strcmp (name, \"omp_get_team_num\") == 0)\n-      || (strcmp (name, \"omp_get_level\") == 0)\n-      || (strcmp (name, \"omp_get_active_level\") == 0)\n-      || (strcmp (name, \"omp_in_parallel\") == 0))\n-    return true;\n-\n-  return false;\n-}\n-\n-/* Facing a call satisfying grid_call_permissible_in_distribute_p in the body\n-   of a distribute construct that is pointed at by GSI, modify it as necessary\n-   for gridification.  If the statement itself got removed, return true.  */\n-\n-static bool\n-grid_handle_call_in_distribute (gimple_stmt_iterator *gsi)\n-{\n-  gimple *stmt = gsi_stmt (*gsi);\n-  tree fndecl = gimple_call_fndecl (stmt);\n-  gcc_checking_assert (stmt);\n-  if (DECL_PURE_P (fndecl) || TREE_READONLY (fndecl))\n-    return false;\n-\n-  const char *name = IDENTIFIER_POINTER (DECL_NAME (fndecl));\n-  if ((strcmp (name, \"omp_get_thread_num\") == 0)\n-      || (strcmp (name, \"omp_get_level\") == 0)\n-      || (strcmp (name, \"omp_get_active_level\") == 0)\n-      || (strcmp (name, \"omp_in_parallel\") == 0))\n-    {\n-      tree lhs = gimple_call_lhs (stmt);\n-      if (lhs)\n-\t{\n-\t  gassign *assign\n-\t    = gimple_build_assign (lhs, build_zero_cst (TREE_TYPE (lhs)));\n-\t  gsi_insert_before (gsi, assign, GSI_SAME_STMT);\n-\t}\n-      gsi_remove (gsi, true);\n-      return true;\n-    }\n-\n-  /* The rest of the omp functions can stay as they are, HSA back-end will\n-     handle them correctly.  */\n-  gcc_checking_assert ((strcmp (name, \"omp_get_num_threads\") == 0)\n-\t\t       || (strcmp (name, \"omp_get_num_teams\") == 0)\n-\t\t       || (strcmp (name, \"omp_get_team_num\") == 0));\n-  return false;\n-}\n-\n-/* Given a sequence of statements within a distribute omp construct or a\n-   parallel construct, which in the original source does not form a compound\n-   construct with a looping construct, return true if it does not prevent us\n-   from turning it into a gridified HSA kernel.  Otherwise return false.  GRID\n-   describes hitherto discovered properties of the loop that is evaluated for\n-   possible gridification.  IN_PARALLEL must be true if seq is within a\n-   parallel construct and flase if it is only within a distribute\n-   construct.  */\n-\n-static bool\n-grid_dist_follows_tiling_pattern (gimple_seq seq, grid_prop *grid,\n-\t\t\t\t  bool in_parallel)\n-{\n-  gimple_stmt_iterator gsi;\n-  for (gsi = gsi_start (seq); !gsi_end_p (gsi); gsi_next (&gsi))\n-    {\n-      gimple *stmt = gsi_stmt (gsi);\n-\n-      if (grid_safe_assignment_p (stmt, grid)\n-\t  || gimple_code (stmt) == GIMPLE_GOTO\n-\t  || gimple_code (stmt) == GIMPLE_LABEL\n-\t  || gimple_code (stmt) == GIMPLE_COND)\n-\tcontinue;\n-      else if (gbind *bind = dyn_cast <gbind *> (stmt))\n-\t{\n-\t  if (!grid_dist_follows_tiling_pattern (gimple_bind_body (bind),\n-\t\t\t\t\t\t grid, in_parallel))\n-\t    return false;\n-\t  continue;\n-\t}\n-      else if (gtry *try_stmt = dyn_cast <gtry *> (stmt))\n-\t{\n-\t  if (gimple_try_kind (try_stmt) == GIMPLE_TRY_CATCH)\n-\t    {\n-\t      if (dump_enabled_p ())\n-\t\t{\n-\t\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, grid->target_loc,\n-\t\t\t\t   GRID_MISSED_MSG_PREFIX \"the distribute \"\n-\t\t\t\t   \"construct contains a try..catch region\\n\");\n-\t\t  dump_printf_loc (MSG_NOTE, try_stmt,\n-\t\t\t\t   \"This statement cannot be analyzed for \"\n-\t\t\t\t   \"tiled gridification\\n\");\n-\t\t}\n-\t      return false;\n-\t    }\n-\t  if (!grid_dist_follows_tiling_pattern (gimple_try_eval (try_stmt),\n-\t\t\t\t\t\t grid, in_parallel))\n-\t    return false;\n-\t  if (!grid_dist_follows_tiling_pattern (gimple_try_cleanup (try_stmt),\n-\t\t\t\t\t\t grid, in_parallel))\n-\t    return false;\n-\t  continue;\n-\t}\n-      else if (is_gimple_call (stmt))\n-\t{\n-\t  tree fndecl = gimple_call_fndecl (stmt);\n-\t  if (fndecl && grid_call_permissible_in_distribute_p (fndecl))\n-\t    continue;\n-\n-\t  if (dump_enabled_p ())\n-\t    {\n-\t      dump_printf_loc (MSG_MISSED_OPTIMIZATION, grid->target_loc,\n-\t\t\t       GRID_MISSED_MSG_PREFIX \"the distribute \"\n-\t\t\t       \"construct contains a call\\n\");\n-\t      dump_printf_loc (MSG_NOTE, stmt,\n-\t\t\t       \"This statement cannot be analyzed for \"\n-\t\t\t       \"tiled gridification\\n\");\n-\t    }\n-\t  return false;\n-\t}\n-      else if (gomp_parallel *par = dyn_cast <gomp_parallel *> (stmt))\n-\t{\n-\t  if (in_parallel)\n-\t    {\n-\t      if (dump_enabled_p ())\n-\t\t{\n-\t\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, grid->target_loc,\n-\t\t\t\t   GRID_MISSED_MSG_PREFIX \"a parallel \"\n-\t\t\t\t   \"construct contains another parallel \"\n-\t\t\t\t   \"construct\\n\");\n-\t\t  dump_printf_loc (MSG_NOTE, stmt,\n-\t\t\t\t   \"This parallel construct is nested in \"\n-\t\t\t\t   \"another one\\n\");\n-\t\t}\n-\t      return false;\n-\t    }\n-\t  if (!grid_parallel_clauses_gridifiable (par, grid->target_loc)\n-\t      || !grid_dist_follows_tiling_pattern (gimple_omp_body (par),\n-\t\t\t\t\t\t    grid, true))\n-\t    return false;\n-\t}\n-      else if (gomp_for *gfor = dyn_cast <gomp_for *> (stmt))\n-\t{\n-\t  if (!in_parallel)\n-\t    {\n-\t      if (dump_enabled_p ())\n-\t\t{\n-\t\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, grid->target_loc,\n-\t\t\t\t   GRID_MISSED_MSG_PREFIX \"a loop \"\n-\t\t\t\t   \"construct is not nested within a parallel \"\n-\t\t\t\t   \"construct\\n\");\n-\t\t  dump_printf_loc (MSG_NOTE, stmt,\n-\t\t\t\t   \"This loop construct is not nested in \"\n-\t\t\t\t   \"a parallel construct\\n\");\n-\t\t}\n-\t      return false;\n-\t    }\n-\t  if (!grid_gfor_follows_tiling_pattern (gfor, grid))\n-\t    return false;\n-\t}\n-      else\n-\t{\n-\t  if (dump_enabled_p ())\n-\t    {\n-\t      dump_printf_loc (MSG_MISSED_OPTIMIZATION, grid->target_loc,\n-\t\t\t       GRID_MISSED_MSG_PREFIX \"the distribute \"\n-\t\t\t       \"construct contains a complex statement\\n\");\n-\t      dump_printf_loc (MSG_NOTE, stmt,\n-\t\t\t       \"This statement cannot be analyzed for \"\n-\t\t\t       \"tiled gridification\\n\");\n-\t    }\n-\t  return false;\n-\t}\n-    }\n-    return true;\n-}\n-\n-/* If TARGET follows a pattern that can be turned into a gridified HSA kernel,\n-   return true, otherwise return false.  In the case of success, also fill in\n-   GRID with information describing the kernel grid.  */\n-\n-static bool\n-grid_target_follows_gridifiable_pattern (gomp_target *target, grid_prop *grid)\n-{\n-  if (gimple_omp_target_kind (target) != GF_OMP_TARGET_KIND_REGION)\n-    return false;\n-\n-  dump_user_location_t tloc = target;\n-  grid->target_loc = tloc;\n-  gimple *stmt\n-    = grid_find_single_omp_among_assignments (gimple_omp_body (target),\n-\t\t\t\t\t      grid, \"target\");\n-  if (!stmt)\n-    return false;\n-  gomp_teams *teams = dyn_cast <gomp_teams *> (stmt);\n-  tree group_size = NULL;\n-  if (!teams)\n-    {\n-      if (dump_enabled_p ())\n-\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, tloc,\n-\t\t\t GRID_MISSED_MSG_PREFIX \"it does not have a sole \"\n-\t\t\t \"teams construct in it.\\n\");\n-      return false;\n-    }\n-\n-  tree clauses = gimple_omp_teams_clauses (teams);\n-  while (clauses)\n-    {\n-      switch (OMP_CLAUSE_CODE (clauses))\n-\t{\n-\tcase OMP_CLAUSE_NUM_TEAMS:\n-\t  if (dump_enabled_p ())\n-\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, tloc,\n-\t\t\t     GRID_MISSED_MSG_PREFIX \"the teams construct \"\n-\t\t\t     \"contains a num_teams clause\\n \");\n-\t  return false;\n-\n-\tcase OMP_CLAUSE_REDUCTION:\n-\t  if (dump_enabled_p ())\n-\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, tloc,\n-\t\t\t     GRID_MISSED_MSG_PREFIX \"a reduction \"\n-\t\t\t     \"clause is present\\n \");\n-\t  return false;\n-\n-\tcase OMP_CLAUSE_THREAD_LIMIT:\n-\t  if (!integer_zerop (OMP_CLAUSE_OPERAND (clauses, 0)))\n-\t    group_size = OMP_CLAUSE_OPERAND (clauses, 0);\n-\t  break;\n-\n-\tdefault:\n-\t  break;\n-\t}\n-      clauses = OMP_CLAUSE_CHAIN (clauses);\n-    }\n-\n-  stmt = grid_find_single_omp_among_assignments (gimple_omp_body (teams), grid,\n-\t\t\t\t\t\t \"teams\");\n-  if (!stmt)\n-    return false;\n-  gomp_for *dist = dyn_cast <gomp_for *> (stmt);\n-  if (!dist)\n-    {\n-      if (dump_enabled_p ())\n-\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, tloc,\n-\t\t\t GRID_MISSED_MSG_PREFIX \"the teams construct does not \"\n-\t\t\t \"have a single distribute construct in it.\\n\");\n-      return false;\n-    }\n-\n-  gcc_assert (gimple_omp_for_kind (dist) == GF_OMP_FOR_KIND_DISTRIBUTE);\n-\n-  grid->collapse = gimple_omp_for_collapse (dist);\n-  if (grid->collapse > 3)\n-    {\n-      if (dump_enabled_p ())\n-\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, tloc,\n-\t\t\t GRID_MISSED_MSG_PREFIX \"the distribute construct \"\n-\t\t\t \"contains collapse clause with parameter greater \"\n-\t\t\t \"than 3\\n\");\n-      return false;\n-    }\n-\n-  struct omp_for_data fd;\n-  struct omp_for_data_loop *dist_loops\n-    = (struct omp_for_data_loop *)alloca (grid->collapse\n-\t\t\t\t\t  * sizeof (struct omp_for_data_loop));\n-  omp_extract_for_data (dist, &fd, dist_loops);\n-  if (fd.chunk_size)\n-    {\n-      if (group_size && !operand_equal_p (group_size, fd.chunk_size, 0))\n-\t{\n-\t  if (dump_enabled_p ())\n-\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, tloc,\n-\t\t\t     GRID_MISSED_MSG_PREFIX \"the teams \"\n-\t\t\t     \"thread limit is different from distribute \"\n-\t\t\t     \"schedule chunk\\n\");\n-\t  return false;\n-\t}\n-      group_size = fd.chunk_size;\n-    }\n-  if (group_size && grid->collapse > 1)\n-    {\n-      if (dump_enabled_p ())\n-\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, tloc,\n-\t\t\t GRID_MISSED_MSG_PREFIX \"group size cannot be \"\n-\t\t\t \"set using thread_limit or schedule clauses \"\n-\t\t\t \"when also using a collapse clause greater than 1\\n\");\n-      return false;\n-    }\n-\n-  if (gimple_omp_for_combined_p (dist))\n-    {\n-      grid->tiling = false;\n-      grid->group_sizes[0] = group_size;\n-      for (unsigned i = 1; i < grid->collapse; i++)\n-\tgrid->group_sizes[i] = NULL;\n-      return grid_dist_follows_simple_pattern (dist, grid);\n-    }\n-  else\n-    {\n-      grid->tiling = true;\n-      if (group_size)\n-\t{\n-\t  if (dump_enabled_p ())\n-\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, tloc,\n-\t\t\t     GRID_MISSED_MSG_PREFIX \"group size cannot be set \"\n-\t\t\t     \"using thread_limit or schedule clauses when \"\n-\t\t\t     \"distribute and loop constructs do not form \"\n-\t\t\t     \"one combined construct\\n\");\n-\t  return false;\n-\t}\n-      for (unsigned i = 0; i < grid->collapse; i++)\n-\t{\n-\t  if (fd.loops[i].cond_code == GT_EXPR)\n-\t    grid->group_sizes[i] = fold_build1 (NEGATE_EXPR,\n-\t\t\t\t\t\tTREE_TYPE (fd.loops[i].step),\n-\t\t\t\t\t\tfd.loops[i].step);\n-\t  else\n-\t    grid->group_sizes[i] = fd.loops[i].step;\n-\t}\n-      return grid_dist_follows_tiling_pattern (gimple_omp_body (dist), grid,\n-\t\t\t\t\t       false);\n-    }\n-}\n-\n-/* Operand walker, used to remap pre-body declarations according to a hash map\n-   provided in DATA.  */\n-\n-static tree\n-grid_remap_prebody_decls (tree *tp, int *walk_subtrees, void *data)\n-{\n-  tree t = *tp;\n-\n-  if (DECL_P (t) || TYPE_P (t))\n-    *walk_subtrees = 0;\n-  else\n-    *walk_subtrees = 1;\n-\n-  if (VAR_P (t))\n-    {\n-      struct walk_stmt_info *wi = (struct walk_stmt_info *) data;\n-      hash_map<tree, tree> *declmap = (hash_map<tree, tree> *) wi->info;\n-      tree *repl = declmap->get (t);\n-      if (repl)\n-\t*tp = *repl;\n-    }\n-  return NULL_TREE;\n-}\n-\n-/* Identifiers of segments into which a particular variable should be places\n-   when gridifying.  */\n-\n-enum grid_var_segment {GRID_SEGMENT_PRIVATE, GRID_SEGMENT_GROUP,\n-\t\t       GRID_SEGMENT_GLOBAL};\n-\n-/* Mark VAR so that it is eventually placed into SEGMENT.  Place an artificial\n-   builtin call into SEQ that will make sure the variable is always considered\n-   address taken.  */\n-\n-static void\n-grid_mark_variable_segment (tree var, enum grid_var_segment segment)\n-{\n-  /* Making a non-addressable variables would require that we re-gimplify all\n-     their uses.  Fortunately, we do not have to do this because if they are\n-     not addressable, it means they are not used in atomic or parallel\n-     statements and so relaxed GPU consistency rules mean we can just keep them\n-     private.  */\n-  if (!TREE_ADDRESSABLE (var))\n-    return;\n-\n-  switch (segment)\n-    {\n-    case GRID_SEGMENT_GROUP:\n-      DECL_ATTRIBUTES (var) = tree_cons (get_identifier (\"hsa_group_segment\"),\n-\t\t\t\t\t NULL, DECL_ATTRIBUTES (var));\n-      break;\n-    case GRID_SEGMENT_GLOBAL:\n-      DECL_ATTRIBUTES (var) = tree_cons (get_identifier (\"hsa_global_segment\"),\n-\t\t\t\t\t NULL, DECL_ATTRIBUTES (var));\n-      break;\n-    default:\n-      gcc_unreachable ();\n-    }\n-\n-  if (!TREE_STATIC (var))\n-    {\n-      TREE_STATIC (var) = 1;\n-      const char *prefix = IDENTIFIER_POINTER (DECL_NAME (var));\n-      SET_DECL_ASSEMBLER_NAME (var, create_tmp_var_name (prefix));\n-      varpool_node::finalize_decl (var);\n-    }\n-\n-}\n-\n-/* Copy leading register-type assignments to local variables in SRC to just\n-   before DST, Creating temporaries, adjusting mapping of operands in WI and\n-   remapping operands as necessary.  Add any new temporaries to TGT_BIND.\n-   Return the first statement that does not conform to grid_safe_assignment_p\n-   or NULL.  If VAR_SEGMENT is not GRID_SEGMENT_PRIVATE, also mark all\n-   variables in traversed bind statements so that they are put into the\n-   appropriate segment.  */\n-\n-static gimple *\n-grid_copy_leading_local_assignments (gimple_seq src, gimple_stmt_iterator *dst,\n-\t\t\t\t     gbind *tgt_bind,\n-\t\t\t\t     enum grid_var_segment var_segment,\n-\t\t\t\t     struct walk_stmt_info *wi)\n-{\n-  hash_map<tree, tree> *declmap = (hash_map<tree, tree> *) wi->info;\n-  gimple_stmt_iterator gsi;\n-  for (gsi = gsi_start (src); !gsi_end_p (gsi); gsi_next (&gsi))\n-    {\n-      gimple *stmt = gsi_stmt (gsi);\n-      if (gbind *bind = dyn_cast <gbind *> (stmt))\n-\t{\n-\t  gimple *r = grid_copy_leading_local_assignments\n-\t    (gimple_bind_body (bind), dst, tgt_bind, var_segment, wi);\n-\n-\t  if (var_segment != GRID_SEGMENT_PRIVATE)\n-\t    for (tree var = gimple_bind_vars (bind);\n-\t\t var;\n-\t\t var = DECL_CHAIN (var))\n-\t      grid_mark_variable_segment (var, var_segment);\n-\t  if (r)\n-\t    return r;\n-\t  else\n-\t    continue;\n-\t}\n-      if (!grid_safe_assignment_p (stmt, NULL))\n-\treturn stmt;\n-      tree lhs = gimple_assign_lhs (as_a <gassign *> (stmt));\n-      tree repl = copy_var_decl (lhs, create_tmp_var_name (NULL),\n-\t\t\t\t TREE_TYPE (lhs));\n-      DECL_CONTEXT (repl) = current_function_decl;\n-      gimple_bind_append_vars (tgt_bind, repl);\n-\n-      declmap->put (lhs, repl);\n-      gassign *copy = as_a <gassign *> (gimple_copy (stmt));\n-      walk_gimple_op (copy, grid_remap_prebody_decls, wi);\n-      gsi_insert_before (dst, copy, GSI_SAME_STMT);\n-    }\n-  return NULL;\n-}\n-\n-/* Statement walker function to make adjustments to statements within the\n-   gridifed kernel copy.  */\n-\n-static tree\n-grid_process_grid_body (gimple_stmt_iterator *gsi, bool *handled_ops_p,\n-\t\t\tstruct walk_stmt_info *)\n-{\n-  *handled_ops_p = false;\n-  gimple *stmt = gsi_stmt (*gsi);\n-  if (gimple_code (stmt) == GIMPLE_OMP_FOR\n-      && gimple_omp_for_kind (stmt) == GF_OMP_FOR_KIND_SIMD)\n-  {\n-    gomp_for *loop = as_a <gomp_for *> (stmt);\n-    tree clauses = gimple_omp_for_clauses (loop);\n-    tree cl = omp_find_clause (clauses, OMP_CLAUSE_SAFELEN);\n-    if (cl)\n-      OMP_CLAUSE_SAFELEN_EXPR (cl) = integer_one_node;\n-    else\n-      {\n-\ttree c = build_omp_clause (UNKNOWN_LOCATION, OMP_CLAUSE_SAFELEN);\n-\tOMP_CLAUSE_SAFELEN_EXPR (c) = integer_one_node;\n-\tOMP_CLAUSE_CHAIN (c) = clauses;\n-\tgimple_omp_for_set_clauses (loop, c);\n-      }\n-  }\n-  return NULL_TREE;\n-}\n-\n-/* Given a PARLOOP that is a normal for looping construct but also a part of a\n-   combined construct with a simd loop, eliminate the simd loop.  */\n-\n-static void\n-grid_eliminate_combined_simd_part (gomp_for *parloop)\n-{\n-  struct walk_stmt_info wi;\n-\n-  memset (&wi, 0, sizeof (wi));\n-  wi.val_only = true;\n-  enum gf_mask msk = GF_OMP_FOR_KIND_SIMD;\n-  wi.info = (void *) &msk;\n-  walk_gimple_seq (gimple_omp_body (parloop), omp_find_combined_for, NULL, &wi);\n-  gimple *stmt = (gimple *) wi.info;\n-  /* We expect that the SIMD id the only statement in the parallel loop.  */\n-  gcc_assert (stmt\n-\t      && gimple_code (stmt) == GIMPLE_OMP_FOR\n-\t      && (gimple_omp_for_kind (stmt) == GF_OMP_FOR_KIND_SIMD)\n-\t      && gimple_omp_for_combined_into_p (stmt)\n-\t      && !gimple_omp_for_combined_p (stmt));\n-  gomp_for *simd = as_a <gomp_for *> (stmt);\n-\n-  /* Copy over the iteration properties because the body refers to the index in\n-     the bottmom-most loop.  */\n-  unsigned i, collapse = gimple_omp_for_collapse (parloop);\n-  gcc_checking_assert (collapse == gimple_omp_for_collapse (simd));\n-  for (i = 0; i < collapse; i++)\n-    {\n-      gimple_omp_for_set_index (parloop, i, gimple_omp_for_index (simd, i));\n-      gimple_omp_for_set_initial (parloop, i, gimple_omp_for_initial (simd, i));\n-      gimple_omp_for_set_final (parloop, i, gimple_omp_for_final (simd, i));\n-      gimple_omp_for_set_incr (parloop, i, gimple_omp_for_incr (simd, i));\n-    }\n-\n-  tree *tgt= gimple_omp_for_clauses_ptr (parloop);\n-  while (*tgt)\n-    tgt = &OMP_CLAUSE_CHAIN (*tgt);\n-\n-  /* Copy over all clauses, except for linear clauses, which are turned into\n-     private clauses, and all other simd-specific clauses, which are\n-     ignored.  */\n-  tree *pc = gimple_omp_for_clauses_ptr (simd);\n-  while (*pc)\n-    {\n-      tree c = *pc;\n-      switch (OMP_CLAUSE_CODE (c))\n-\t{\n-\tcase OMP_CLAUSE_LINEAR:\n-\t  {\n-\t    tree priv = build_omp_clause (UNKNOWN_LOCATION, OMP_CLAUSE_PRIVATE);\n-\t    OMP_CLAUSE_DECL (priv) = OMP_CLAUSE_DECL (c);\n-\t    OMP_CLAUSE_CHAIN (priv) = NULL;\n-\t    *tgt = priv;\n-\t    tgt = &OMP_CLAUSE_CHAIN (priv);\n-\t    pc = &OMP_CLAUSE_CHAIN (c);\n-\t    break;\n-\t  }\n-\n-\tcase OMP_CLAUSE_SAFELEN:\n-\tcase OMP_CLAUSE_SIMDLEN:\n-\tcase OMP_CLAUSE_ALIGNED:\n-\t  pc = &OMP_CLAUSE_CHAIN (c);\n-\t  break;\n-\n-\tdefault:\n-\t  *pc = OMP_CLAUSE_CHAIN (c);\n-\t  OMP_CLAUSE_CHAIN (c) = NULL;\n-\t  *tgt = c;\n-\t  tgt = &OMP_CLAUSE_CHAIN (c);\n-\t  break;\n-\t}\n-    }\n-\n-  /* Finally, throw away the simd and mark the parallel loop as not\n-     combined.  */\n-  gimple_omp_set_body (parloop, gimple_omp_body (simd));\n-  gimple_omp_for_set_combined_p (parloop, false);\n-}\n-\n-/* Statement walker function marking all parallels as grid_phony and loops as\n-   grid ones representing threads of a particular thread group.  */\n-\n-static tree\n-grid_mark_tiling_loops (gimple_stmt_iterator *gsi, bool *handled_ops_p,\n-\t\t\tstruct walk_stmt_info *wi_in)\n-{\n-  *handled_ops_p = false;\n-  if (gomp_for *loop = dyn_cast <gomp_for *> (gsi_stmt (*gsi)))\n-    {\n-      *handled_ops_p = true;\n-      gimple_omp_for_set_kind (loop, GF_OMP_FOR_KIND_GRID_LOOP);\n-      gimple_omp_for_set_grid_intra_group (loop, true);\n-      if (gimple_omp_for_combined_p (loop))\n-\tgrid_eliminate_combined_simd_part (loop);\n-\n-      struct walk_stmt_info body_wi;\n-      memset (&body_wi, 0, sizeof (body_wi));\n-      walk_gimple_seq_mod (gimple_omp_body_ptr (loop),\n-\t\t\t   grid_process_grid_body, NULL, &body_wi);\n-\n-      gbind *bind = (gbind *) wi_in->info;\n-      tree c;\n-      for (c = gimple_omp_for_clauses (loop); c; c = OMP_CLAUSE_CHAIN (c))\n-\tif (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_LASTPRIVATE)\n-\t  {\n-\t    push_gimplify_context ();\n-\t    tree ov = OMP_CLAUSE_DECL (c);\n-\t    tree gv = copy_var_decl (ov, create_tmp_var_name (NULL),\n-\t\t\t\t    TREE_TYPE (ov));\n-\n-\t    grid_mark_variable_segment (gv, GRID_SEGMENT_GROUP);\n-\t    DECL_CONTEXT (gv) = current_function_decl;\n-\t    gimple_bind_append_vars (bind, gv);\n-\t    tree x = lang_hooks.decls.omp_clause_assign_op (c, gv, ov);\n-\t    gimplify_and_add (x, &OMP_CLAUSE_LASTPRIVATE_GIMPLE_SEQ (c));\n-\t    x = lang_hooks.decls.omp_clause_copy_ctor (c, ov, gv);\n-\t    gimple_seq l = NULL;\n-\t    gimplify_and_add (x, &l);\n-\t    gsi_insert_seq_after (gsi, l, GSI_SAME_STMT);\n-\t    pop_gimplify_context (bind);\n-\t  }\n-    }\n-  return NULL_TREE;\n-}\n-\n-/* Statement walker function marking all parallels as grid_phony and loops as\n-   grid ones representing threads of a particular thread group.  */\n-\n-static tree\n-grid_mark_tiling_parallels_and_loops (gimple_stmt_iterator *gsi,\n-\t\t\t\t      bool *handled_ops_p,\n-\t\t\t\t      struct walk_stmt_info *wi_in)\n-{\n-  *handled_ops_p = false;\n-  wi_in->removed_stmt = false;\n-  gimple *stmt = gsi_stmt (*gsi);\n-  if (gbind *bind = dyn_cast <gbind *> (stmt))\n-    {\n-      for (tree var = gimple_bind_vars (bind); var; var = DECL_CHAIN (var))\n-\tgrid_mark_variable_segment (var, GRID_SEGMENT_GROUP);\n-    }\n-  else if (gomp_parallel *parallel = dyn_cast <gomp_parallel *> (stmt))\n-    {\n-      *handled_ops_p = true;\n-      gimple_omp_parallel_set_grid_phony (parallel, true);\n-\n-      gbind *new_bind = gimple_build_bind (NULL, NULL, make_node (BLOCK));\n-      gimple_bind_set_body (new_bind, gimple_omp_body (parallel));\n-      gimple_seq s = NULL;\n-      gimple_seq_add_stmt (&s, new_bind);\n-      gimple_omp_set_body (parallel, s);\n-\n-      struct walk_stmt_info wi_par;\n-      memset (&wi_par, 0, sizeof (wi_par));\n-      wi_par.info = new_bind;\n-      walk_gimple_seq_mod (gimple_bind_body_ptr (new_bind),\n-\t\t\t   grid_mark_tiling_loops, NULL, &wi_par);\n-    }\n-  else if (is_a <gcall *> (stmt))\n-    wi_in->removed_stmt = grid_handle_call_in_distribute (gsi);\n-  return NULL_TREE;\n-}\n-\n-/* Given freshly copied top level kernel SEQ, identify the individual OMP\n-   components, mark them as part of kernel, copy assignment leading to them\n-   just before DST, remapping them using WI and adding new temporaries to\n-   TGT_BIND, and return the loop that will be used for kernel dispatch.  */\n-\n-static gomp_for *\n-grid_process_kernel_body_copy (grid_prop *grid, gimple_seq seq,\n-\t\t\t       gimple_stmt_iterator *dst,\n-\t\t\t       gbind *tgt_bind, struct walk_stmt_info *wi)\n-{\n-  gimple *stmt = grid_copy_leading_local_assignments (seq, dst, tgt_bind,\n-\t\t\t\t\t\t      GRID_SEGMENT_GLOBAL, wi);\n-  gomp_teams *teams = dyn_cast <gomp_teams *> (stmt);\n-  gcc_assert (teams);\n-  gimple_omp_teams_set_grid_phony (teams, true);\n-  stmt = grid_copy_leading_local_assignments (gimple_omp_body (teams), dst,\n-\t\t\t\t\t      tgt_bind, GRID_SEGMENT_GLOBAL,\n-\t\t\t\t\t      wi);\n-  gcc_checking_assert (stmt);\n-  gomp_for *dist = dyn_cast <gomp_for *> (stmt);\n-  gcc_assert (dist);\n-  gimple_seq prebody = gimple_omp_for_pre_body (dist);\n-  if (prebody)\n-    grid_copy_leading_local_assignments (prebody, dst, tgt_bind,\n-\t\t\t\t\t GRID_SEGMENT_GROUP, wi);\n-\n-  if (grid->tiling)\n-    {\n-      gimple_omp_for_set_kind (dist, GF_OMP_FOR_KIND_GRID_LOOP);\n-      gimple_omp_for_set_grid_group_iter (dist, true);\n-\n-      struct walk_stmt_info wi_tiled;\n-      memset (&wi_tiled, 0, sizeof (wi_tiled));\n-      walk_gimple_seq_mod (gimple_omp_body_ptr (dist),\n-\t\t\t   grid_mark_tiling_parallels_and_loops, NULL,\n-\t\t\t   &wi_tiled);\n-      return dist;\n-    }\n-  else\n-    {\n-      gimple_omp_for_set_grid_phony (dist, true);\n-      stmt = grid_copy_leading_local_assignments (gimple_omp_body (dist), dst,\n-\t\t\t\t\t\t  tgt_bind,\n-\t\t\t\t\t\t  GRID_SEGMENT_PRIVATE, wi);\n-      gcc_checking_assert (stmt);\n-      gomp_parallel *parallel = as_a <gomp_parallel *> (stmt);\n-      gimple_omp_parallel_set_grid_phony (parallel, true);\n-      stmt = grid_copy_leading_local_assignments (gimple_omp_body (parallel),\n-\t\t\t\t\t\t  dst, tgt_bind,\n-\t\t\t\t\t\t  GRID_SEGMENT_PRIVATE, wi);\n-      gomp_for *inner_loop = as_a <gomp_for *> (stmt);\n-      gimple_omp_for_set_kind (inner_loop, GF_OMP_FOR_KIND_GRID_LOOP);\n-      prebody = gimple_omp_for_pre_body (inner_loop);\n-      if (prebody)\n-\tgrid_copy_leading_local_assignments (prebody, dst, tgt_bind,\n-\t\t\t\t\t     GRID_SEGMENT_PRIVATE, wi);\n-\n-      if (gimple_omp_for_combined_p (inner_loop))\n-\tgrid_eliminate_combined_simd_part (inner_loop);\n-      struct walk_stmt_info body_wi;\n-      memset (&body_wi, 0, sizeof (body_wi));\n-      walk_gimple_seq_mod (gimple_omp_body_ptr (inner_loop),\n-\t\t\t   grid_process_grid_body, NULL, &body_wi);\n-\n-      return inner_loop;\n-    }\n-}\n-\n-/* If TARGET points to a GOMP_TARGET which follows a gridifiable pattern,\n-   create a GPU kernel for it.  GSI must point to the same statement, TGT_BIND\n-   is the bind into which temporaries inserted before TARGET should be\n-   added.  */\n-\n-static void\n-grid_attempt_target_gridification (gomp_target *target,\n-\t\t\t\t   gimple_stmt_iterator *gsi,\n-\t\t\t\t   gbind *tgt_bind)\n-{\n-  /* removed group_size */\n-  grid_prop grid = {};\n-  if (!target || !grid_target_follows_gridifiable_pattern (target, &grid))\n-    return;\n-\n-  location_t loc = gimple_location (target);\n-  if (dump_enabled_p ())\n-    dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, target,\n-\t\t     \"Target construct will be turned into a gridified HSA \"\n-\t\t     \"kernel\\n\");\n-\n-  /* Copy target body to a GPUKERNEL construct:  */\n-  gimple_seq kernel_seq = copy_gimple_seq_and_replace_locals\n-    (gimple_omp_body (target));\n-\n-  hash_map<tree, tree> *declmap = new hash_map<tree, tree>;\n-  struct walk_stmt_info wi;\n-  memset (&wi, 0, sizeof (struct walk_stmt_info));\n-  wi.info = declmap;\n-\n-  /* Copy assignments in between OMP statements before target, mark OMP\n-     statements within copy appropriately.  */\n-  gomp_for *inner_loop = grid_process_kernel_body_copy (&grid, kernel_seq, gsi,\n-\t\t\t\t\t\t\ttgt_bind, &wi);\n-\n-  gbind *old_bind\n-    = as_a <gbind *> (gimple_seq_first (gimple_omp_body (target)));\n-  gbind *new_bind = as_a <gbind *> (gimple_seq_first (kernel_seq));\n-  tree new_block = gimple_bind_block (new_bind);\n-  tree enc_block = BLOCK_SUPERCONTEXT (gimple_bind_block (old_bind));\n-  BLOCK_CHAIN (new_block) = BLOCK_SUBBLOCKS (enc_block);\n-  BLOCK_SUBBLOCKS (enc_block) = new_block;\n-  BLOCK_SUPERCONTEXT (new_block) = enc_block;\n-  gimple *gpukernel = gimple_build_omp_grid_body (kernel_seq);\n-  gimple_seq_add_stmt\n-    (gimple_bind_body_ptr (as_a <gbind *> (gimple_omp_body (target))),\n-     gpukernel);\n-\n-  for (size_t i = 0; i < grid.collapse; i++)\n-    walk_tree (&grid.group_sizes[i], grid_remap_prebody_decls, &wi, NULL);\n-  push_gimplify_context ();\n-  for (size_t i = 0; i < grid.collapse; i++)\n-    {\n-      tree index_var = gimple_omp_for_index (inner_loop, i);\n-      tree itype, type = TREE_TYPE (index_var);\n-      if (POINTER_TYPE_P (type))\n-\titype = signed_type_for (type);\n-      else\n-\titype = type;\n-\n-      enum tree_code cond_code = gimple_omp_for_cond (inner_loop, i);\n-      tree n1 = unshare_expr (gimple_omp_for_initial (inner_loop, i));\n-      walk_tree (&n1, grid_remap_prebody_decls, &wi, NULL);\n-      tree n2 = unshare_expr (gimple_omp_for_final (inner_loop, i));\n-      walk_tree (&n2, grid_remap_prebody_decls, &wi, NULL);\n-      tree step\n-\t= omp_get_for_step_from_incr (loc, gimple_omp_for_incr (inner_loop, i));\n-      omp_adjust_for_condition (loc, &cond_code, &n2, index_var, step);\n-      n1 = fold_convert (itype, n1);\n-      n2 = fold_convert (itype, n2);\n-\n-      tree cond = fold_build2 (cond_code, boolean_type_node, n1, n2);\n-\n-      tree t = build_int_cst (itype, (cond_code == LT_EXPR ? -1 : 1));\n-      t = fold_build2 (PLUS_EXPR, itype, step, t);\n-      t = fold_build2 (PLUS_EXPR, itype, t, n2);\n-      t = fold_build2 (MINUS_EXPR, itype, t, n1);\n-      if (TYPE_UNSIGNED (itype) && cond_code == GT_EXPR)\n-\tt = fold_build2 (TRUNC_DIV_EXPR, itype,\n-\t\t\t fold_build1 (NEGATE_EXPR, itype, t),\n-\t\t\t fold_build1 (NEGATE_EXPR, itype, step));\n-      else\n-\tt = fold_build2 (TRUNC_DIV_EXPR, itype, t, step);\n-      t = fold_build3 (COND_EXPR, itype, cond, t, build_zero_cst (itype));\n-      if (grid.tiling)\n-\t{\n-\t  if (cond_code == GT_EXPR)\n-\t    step = fold_build1 (NEGATE_EXPR, itype, step);\n-\t  t = fold_build2 (MULT_EXPR, itype, t, step);\n-\t}\n-\n-      tree gs = fold_convert (uint32_type_node, t);\n-      gimple_seq tmpseq = NULL;\n-      gimplify_expr (&gs, &tmpseq, NULL, is_gimple_val, fb_rvalue);\n-      if (!gimple_seq_empty_p (tmpseq))\n-\tgsi_insert_seq_before (gsi, tmpseq, GSI_SAME_STMT);\n-\n-      tree ws;\n-      if (grid.group_sizes[i])\n-\t{\n-\t  ws = fold_convert (uint32_type_node, grid.group_sizes[i]);\n-\t  tmpseq = NULL;\n-\t  gimplify_expr (&ws, &tmpseq, NULL, is_gimple_val, fb_rvalue);\n-\t  if (!gimple_seq_empty_p (tmpseq))\n-\t    gsi_insert_seq_before (gsi, tmpseq, GSI_SAME_STMT);\n-\t}\n-      else\n-\tws = build_zero_cst (uint32_type_node);\n-\n-      tree c = build_omp_clause (UNKNOWN_LOCATION, OMP_CLAUSE__GRIDDIM_);\n-      OMP_CLAUSE__GRIDDIM__DIMENSION (c) = i;\n-      OMP_CLAUSE__GRIDDIM__SIZE (c) = gs;\n-      OMP_CLAUSE__GRIDDIM__GROUP (c) = ws;\n-      OMP_CLAUSE_CHAIN (c) = gimple_omp_target_clauses (target);\n-      gimple_omp_target_set_clauses (target, c);\n-    }\n-  pop_gimplify_context (tgt_bind);\n-  delete declmap;\n-  return;\n-}\n-\n-/* Walker function doing all the work for create_target_kernels.  */\n-\n-static tree\n-grid_gridify_all_targets_stmt (gimple_stmt_iterator *gsi,\n-\t\t\t\t   bool *handled_ops_p,\n-\t\t\t\t   struct walk_stmt_info *incoming)\n-{\n-  *handled_ops_p = false;\n-\n-  gimple *stmt = gsi_stmt (*gsi);\n-  gomp_target *target = dyn_cast <gomp_target *> (stmt);\n-  if (target)\n-    {\n-      gbind *tgt_bind = (gbind *) incoming->info;\n-      gcc_checking_assert (tgt_bind);\n-      grid_attempt_target_gridification (target, gsi, tgt_bind);\n-      return NULL_TREE;\n-    }\n-  gbind *bind = dyn_cast <gbind *> (stmt);\n-  if (bind)\n-    {\n-      *handled_ops_p = true;\n-      struct walk_stmt_info wi;\n-      memset (&wi, 0, sizeof (wi));\n-      wi.info = bind;\n-      walk_gimple_seq_mod (gimple_bind_body_ptr (bind),\n-\t\t\t   grid_gridify_all_targets_stmt, NULL, &wi);\n-    }\n-  return NULL_TREE;\n-}\n-\n-/* Attempt to gridify all target constructs in BODY_P.  All such targets will\n-   have their bodies duplicated, with the new copy being put into a\n-   gimple_omp_grid_body statement.  All kernel-related construct within the\n-   grid_body will be marked with phony flags or kernel kinds.  Moreover, some\n-   re-structuring is often needed, such as copying pre-bodies before the target\n-   construct so that kernel grid sizes can be computed.  */\n-\n-void\n-omp_grid_gridify_all_targets (gimple_seq *body_p)\n-{\n-  struct walk_stmt_info wi;\n-  memset (&wi, 0, sizeof (wi));\n-  walk_gimple_seq_mod (body_p, grid_gridify_all_targets_stmt, NULL, &wi);\n-}"}, {"sha": "38679f1cd29f290875fb97f79f4bc6a711dbf469", "filename": "gcc/omp-grid.h", "status": "removed", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9623f61b142174b87760c81f78928dd14af7cbc6/gcc%2Fomp-grid.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9623f61b142174b87760c81f78928dd14af7cbc6/gcc%2Fomp-grid.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-grid.h?ref=9623f61b142174b87760c81f78928dd14af7cbc6", "patch": "@@ -1,27 +0,0 @@\n-/* Lowering and expansion of OpenMP directives for HSA GPU agents.\n-\n-   Copyright (C) 2013-2020 Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#ifndef GCC_OMP_GRID_H\n-#define GCC_OMP_GRID_H\n-\n-extern tree omp_grid_lastprivate_predicate (struct omp_for_data *fd);\n-extern void omp_grid_gridify_all_targets (gimple_seq *body_p);\n-\n-#endif /* GCC_OMP_GRID_H */"}, {"sha": "52c2cae394a9fa9434330a4379ad24c1945fed0d", "filename": "gcc/omp-low.c", "status": "modified", "additions": 66, "deletions": 148, "changes": 214, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c56684fd61223abd45854270cd1e83ab2f07148c/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c56684fd61223abd45854270cd1e83ab2f07148c/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=c56684fd61223abd45854270cd1e83ab2f07148c", "patch": "@@ -50,15 +50,13 @@ along with GCC; see the file COPYING3.  If not see\n #include \"splay-tree.h\"\n #include \"omp-general.h\"\n #include \"omp-low.h\"\n-#include \"omp-grid.h\"\n #include \"gimple-low.h\"\n #include \"alloc-pool.h\"\n #include \"symbol-summary.h\"\n #include \"tree-nested.h\"\n #include \"context.h\"\n #include \"gomp-constants.h\"\n #include \"gimple-pretty-print.h\"\n-#include \"hsa-common.h\"\n #include \"stringpool.h\"\n #include \"attribs.h\"\n \n@@ -681,15 +679,7 @@ build_outer_var_ref (tree var, omp_context *ctx,\n \t}\n     }\n   else if (outer)\n-    {\n-      if (gimple_code (outer->stmt) == GIMPLE_OMP_GRID_BODY)\n-\t{\n-\t  outer = outer->outer;\n-\t  gcc_assert (outer\n-\t\t      && gimple_code (outer->stmt) != GIMPLE_OMP_GRID_BODY);\n-\t}\n-      x = lookup_decl (var, outer);\n-    }\n+    x = lookup_decl (var, outer);\n   else if (omp_is_reference (var))\n     /* This can happen with orphaned constructs.  If var is reference, it is\n        possible it is shared and as such valid.  */\n@@ -1460,14 +1450,6 @@ scan_sharing_clauses (tree clauses, omp_context *ctx)\n \t    }\n \t  break;\n \n-\tcase OMP_CLAUSE__GRIDDIM_:\n-\t  if (ctx->outer)\n-\t    {\n-\t      scan_omp_op (&OMP_CLAUSE__GRIDDIM__SIZE (c), ctx->outer);\n-\t      scan_omp_op (&OMP_CLAUSE__GRIDDIM__GROUP (c), ctx->outer);\n-\t    }\n-\t  break;\n-\n \tcase OMP_CLAUSE_ORDER:\n \t  ctx->order_concurrent = true;\n \t  break;\n@@ -1698,7 +1680,6 @@ scan_sharing_clauses (tree clauses, omp_context *ctx)\n \tcase OMP_CLAUSE_AUTO:\n \tcase OMP_CLAUSE_SEQ:\n \tcase OMP_CLAUSE_TILE:\n-\tcase OMP_CLAUSE__GRIDDIM_:\n \tcase OMP_CLAUSE__SIMT_:\n \tcase OMP_CLAUSE_IF_PRESENT:\n \tcase OMP_CLAUSE_FINALIZE:\n@@ -2021,11 +2002,8 @@ scan_omp_parallel (gimple_stmt_iterator *gsi, omp_context *outer_ctx)\n   DECL_NAMELESS (name) = 1;\n   TYPE_NAME (ctx->record_type) = name;\n   TYPE_ARTIFICIAL (ctx->record_type) = 1;\n-  if (!gimple_omp_parallel_grid_phony (stmt))\n-    {\n-      create_omp_child_function (ctx, false);\n-      gimple_omp_parallel_set_child_fn (stmt, ctx->cb.dst_fn);\n-    }\n+  create_omp_child_function (ctx, false);\n+  gimple_omp_parallel_set_child_fn (stmt, ctx->cb.dst_fn);\n \n   scan_sharing_clauses (gimple_omp_parallel_clauses (stmt), ctx);\n   scan_omp (gimple_omp_body_ptr (stmt), ctx);\n@@ -2801,11 +2779,6 @@ check_omp_nesting_restrictions (gimple *stmt, omp_context *ctx)\n {\n   tree c;\n \n-  if (ctx && gimple_code (ctx->stmt) == GIMPLE_OMP_GRID_BODY)\n-    /* GRID_BODY is an artificial construct, nesting rules will be checked in\n-       the original copy of its contents.  */\n-    return true;\n-\n   /* No nesting of non-OpenACC STMT (that is, an OpenMP one, or a GOMP builtin)\n      inside an OpenACC CTX.  */\n   if (!(is_gimple_omp (stmt)\n@@ -2891,7 +2864,6 @@ check_omp_nesting_restrictions (gimple *stmt, omp_context *ctx)\n \t{\n \t  if ((gimple_code (stmt) != GIMPLE_OMP_FOR\n \t       || (gimple_omp_for_kind (stmt) != GF_OMP_FOR_KIND_DISTRIBUTE\n-\t\t   && gimple_omp_for_kind (stmt) != GF_OMP_FOR_KIND_GRID_LOOP\n \t\t   && omp_find_clause (gimple_omp_for_clauses (stmt),\n \t\t\t\t       OMP_CLAUSE_BIND) == NULL_TREE))\n \t      && gimple_code (stmt) != GIMPLE_OMP_PARALLEL)\n@@ -3783,7 +3755,6 @@ scan_omp_1_stmt (gimple_stmt_iterator *gsi, bool *handled_ops_p,\n     case GIMPLE_OMP_MASTER:\n     case GIMPLE_OMP_ORDERED:\n     case GIMPLE_OMP_CRITICAL:\n-    case GIMPLE_OMP_GRID_BODY:\n       ctx = new_omp_context (stmt, ctx);\n       scan_omp (gimple_omp_body_ptr (stmt), ctx);\n       break;\n@@ -9518,65 +9489,59 @@ lower_omp_for_lastprivate (struct omp_for_data *fd, gimple_seq *body_p,\n \tcond_code = EQ_EXPR;\n     }\n \n-  if (gimple_omp_for_kind (fd->for_stmt) == GF_OMP_FOR_KIND_GRID_LOOP\n-      || gimple_omp_for_grid_phony (fd->for_stmt))\n-    cond = omp_grid_lastprivate_predicate (fd);\n-  else\n+  tree n2 = fd->loop.n2;\n+  if (fd->collapse > 1\n+      && TREE_CODE (n2) != INTEGER_CST\n+      && gimple_omp_for_combined_into_p (fd->for_stmt))\n     {\n-      tree n2 = fd->loop.n2;\n-      if (fd->collapse > 1\n-\t  && TREE_CODE (n2) != INTEGER_CST\n-\t  && gimple_omp_for_combined_into_p (fd->for_stmt))\n+      struct omp_context *taskreg_ctx = NULL;\n+      if (gimple_code (ctx->outer->stmt) == GIMPLE_OMP_FOR)\n \t{\n-\t  struct omp_context *taskreg_ctx = NULL;\n-\t  if (gimple_code (ctx->outer->stmt) == GIMPLE_OMP_FOR)\n+\t  gomp_for *gfor = as_a <gomp_for *> (ctx->outer->stmt);\n+\t  if (gimple_omp_for_kind (gfor) == GF_OMP_FOR_KIND_FOR\n+\t      || gimple_omp_for_kind (gfor) == GF_OMP_FOR_KIND_DISTRIBUTE)\n \t    {\n-\t      gomp_for *gfor = as_a <gomp_for *> (ctx->outer->stmt);\n-\t      if (gimple_omp_for_kind (gfor) == GF_OMP_FOR_KIND_FOR\n-\t\t  || gimple_omp_for_kind (gfor) == GF_OMP_FOR_KIND_DISTRIBUTE)\n+\t      if (gimple_omp_for_combined_into_p (gfor))\n \t\t{\n-\t\t  if (gimple_omp_for_combined_into_p (gfor))\n-\t\t    {\n-\t\t      gcc_assert (ctx->outer->outer\n-\t\t\t\t  && is_parallel_ctx (ctx->outer->outer));\n-\t\t      taskreg_ctx = ctx->outer->outer;\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      struct omp_for_data outer_fd;\n-\t\t      omp_extract_for_data (gfor, &outer_fd, NULL);\n-\t\t      n2 = fold_convert (TREE_TYPE (n2), outer_fd.loop.n2);\n-\t\t    }\n+\t\t  gcc_assert (ctx->outer->outer\n+\t\t\t      && is_parallel_ctx (ctx->outer->outer));\n+\t\t  taskreg_ctx = ctx->outer->outer;\n \t\t}\n-\t      else if (gimple_omp_for_kind (gfor) == GF_OMP_FOR_KIND_TASKLOOP)\n-\t\ttaskreg_ctx = ctx->outer->outer;\n-\t    }\n-\t  else if (is_taskreg_ctx (ctx->outer))\n-\t    taskreg_ctx = ctx->outer;\n-\t  if (taskreg_ctx)\n-\t    {\n-\t      int i;\n-\t      tree taskreg_clauses\n-\t\t= gimple_omp_taskreg_clauses (taskreg_ctx->stmt);\n-\t      tree innerc = omp_find_clause (taskreg_clauses,\n-\t\t\t\t\t     OMP_CLAUSE__LOOPTEMP_);\n-\t      gcc_assert (innerc);\n-\t      for (i = 0; i < fd->collapse; i++)\n+\t      else\n \t\t{\n-\t\t  innerc = omp_find_clause (OMP_CLAUSE_CHAIN (innerc),\n-\t\t\t\t\t    OMP_CLAUSE__LOOPTEMP_);\n-\t\t  gcc_assert (innerc);\n+\t\t  struct omp_for_data outer_fd;\n+\t\t  omp_extract_for_data (gfor, &outer_fd, NULL);\n+\t\t  n2 = fold_convert (TREE_TYPE (n2), outer_fd.loop.n2);\n \t\t}\n+\t    }\n+\t  else if (gimple_omp_for_kind (gfor) == GF_OMP_FOR_KIND_TASKLOOP)\n+\t    taskreg_ctx = ctx->outer->outer;\n+\t}\n+      else if (is_taskreg_ctx (ctx->outer))\n+\ttaskreg_ctx = ctx->outer;\n+      if (taskreg_ctx)\n+\t{\n+\t  int i;\n+\t  tree taskreg_clauses\n+\t    = gimple_omp_taskreg_clauses (taskreg_ctx->stmt);\n+\t  tree innerc = omp_find_clause (taskreg_clauses,\n+\t\t\t\t\t OMP_CLAUSE__LOOPTEMP_);\n+\t  gcc_assert (innerc);\n+\t  for (i = 0; i < fd->collapse; i++)\n+\t    {\n \t      innerc = omp_find_clause (OMP_CLAUSE_CHAIN (innerc),\n \t\t\t\t\tOMP_CLAUSE__LOOPTEMP_);\n-\t      if (innerc)\n-\t\tn2 = fold_convert (TREE_TYPE (n2),\n-\t\t\t\t   lookup_decl (OMP_CLAUSE_DECL (innerc),\n-\t\t\t\t\t\ttaskreg_ctx));\n+\t      gcc_assert (innerc);\n \t    }\n+\t  innerc = omp_find_clause (OMP_CLAUSE_CHAIN (innerc),\n+\t\t\t\t    OMP_CLAUSE__LOOPTEMP_);\n+\t  if (innerc)\n+\t    n2 = fold_convert (TREE_TYPE (n2),\n+\t\t\t       lookup_decl (OMP_CLAUSE_DECL (innerc),\n+\t\t\t\t\t    taskreg_ctx));\n \t}\n-      cond = build2 (cond_code, boolean_type_node, fd->loop.v, n2);\n     }\n+  cond = build2 (cond_code, boolean_type_node, fd->loop.v, n2);\n \n   clauses = gimple_omp_for_clauses (fd->for_stmt);\n   stmts = NULL;\n@@ -10638,24 +10603,17 @@ lower_omp_for (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t\t\t\t\t\tctx);\n \t}\n \n-  bool phony_loop = (gimple_omp_for_kind (stmt) != GF_OMP_FOR_KIND_GRID_LOOP\n-\t\t     && gimple_omp_for_grid_phony (stmt));\n   if ((ctx->scan_inclusive || ctx->scan_exclusive)\n       && gimple_omp_for_kind (stmt) == GF_OMP_FOR_KIND_FOR)\n-    {\n-      gcc_assert (!phony_loop);\n-      lower_omp_for_scan (&body, &dlist, stmt, &fd, ctx);\n-    }\n+    lower_omp_for_scan (&body, &dlist, stmt, &fd, ctx);\n   else\n     {\n-      if (!phony_loop)\n-\tgimple_seq_add_stmt (&body, stmt);\n+      gimple_seq_add_stmt (&body, stmt);\n       gimple_seq_add_seq (&body, gimple_omp_body (stmt));\n     }\n \n-  if (!phony_loop)\n-    gimple_seq_add_stmt (&body, gimple_build_omp_continue (fd.loop.v,\n-\t\t\t\t\t\t\t   fd.loop.v));\n+  gimple_seq_add_stmt (&body, gimple_build_omp_continue (fd.loop.v,\n+\t\t\t\t\t\t\t fd.loop.v));\n \n   /* After the loop, add exit clauses.  */\n   lower_reduction_clauses (gimple_omp_for_clauses (stmt), &body, &clist, ctx);\n@@ -10684,19 +10642,16 @@ lower_omp_for (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \n   body = maybe_catch_exception (body);\n \n-  if (!phony_loop)\n-    {\n-      /* Region exit marker goes at the end of the loop body.  */\n-      gimple *g = gimple_build_omp_return (fd.have_nowait);\n-      gimple_seq_add_stmt (&body, g);\n+  /* Region exit marker goes at the end of the loop body.  */\n+  gimple *g = gimple_build_omp_return (fd.have_nowait);\n+  gimple_seq_add_stmt (&body, g);\n \n-      gimple_seq_add_seq (&body, tred_dlist);\n+  gimple_seq_add_seq (&body, tred_dlist);\n \n-      maybe_add_implicit_barrier_cancel (ctx, g, &body);\n+  maybe_add_implicit_barrier_cancel (ctx, g, &body);\n \n-      if (rclauses)\n-\tOMP_CLAUSE_DECL (rclauses) = rtmp;\n-    }\n+  if (rclauses)\n+    OMP_CLAUSE_DECL (rclauses) = rtmp;\n \n   /* Add OpenACC joining and reduction markers just after the loop.  */\n   if (oacc_tail)\n@@ -11279,14 +11234,6 @@ lower_omp_taskreg (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n   gimple_seq par_olist = NULL;\n   gimple_seq par_ilist = NULL;\n   gimple_seq par_rlist = NULL;\n-  bool phony_construct = gimple_code (stmt) == GIMPLE_OMP_PARALLEL\n-    && gimple_omp_parallel_grid_phony (as_a <gomp_parallel *> (stmt));\n-  if (phony_construct && ctx->record_type)\n-    {\n-      gcc_checking_assert (!ctx->receiver_decl);\n-      ctx->receiver_decl = create_tmp_var\n-\t(build_reference_type (ctx->record_type), \".omp_rec\");\n-    }\n   lower_rec_input_clauses (clauses, &par_ilist, &par_olist, ctx, NULL);\n   lower_omp (&par_body, ctx);\n   if (gimple_code (stmt) == GIMPLE_OMP_PARALLEL)\n@@ -11345,22 +11292,16 @@ lower_omp_taskreg (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n     gimple_seq_add_stmt (&new_body,\n \t\t\t gimple_build_omp_continue (integer_zero_node,\n \t\t\t\t\t\t    integer_zero_node));\n-  if (!phony_construct)\n-    {\n-      gimple_seq_add_stmt (&new_body, gimple_build_omp_return (false));\n-      gimple_omp_set_body (stmt, new_body);\n-    }\n+  gimple_seq_add_stmt (&new_body, gimple_build_omp_return (false));\n+  gimple_omp_set_body (stmt, new_body);\n \n   if (dep_bind && gimple_bind_block (par_bind) == NULL_TREE)\n     bind = gimple_build_bind (NULL, NULL, make_node (BLOCK));\n   else\n     bind = gimple_build_bind (NULL, NULL, gimple_bind_block (par_bind));\n   gsi_replace (gsi_p, dep_bind ? dep_bind : bind, true);\n   gimple_bind_add_seq (bind, ilist);\n-  if (!phony_construct)\n-    gimple_bind_add_stmt (bind, stmt);\n-  else\n-    gimple_bind_add_seq (bind, new_body);\n+  gimple_bind_add_stmt (bind, stmt);\n   gimple_bind_add_seq (bind, olist);\n \n   pop_gimplify_context (NULL);\n@@ -12641,22 +12582,19 @@ lower_omp_teams (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n   lower_omp (gimple_omp_body_ptr (teams_stmt), ctx);\n   lower_reduction_clauses (gimple_omp_teams_clauses (teams_stmt), &olist,\n \t\t\t   NULL, ctx);\n-  if (!gimple_omp_teams_grid_phony (teams_stmt))\n-    {\n-      gimple_seq_add_stmt (&bind_body, teams_stmt);\n-      location_t loc = gimple_location (teams_stmt);\n-      tree decl = builtin_decl_explicit (BUILT_IN_GOMP_TEAMS);\n-      gimple *call = gimple_build_call (decl, 2, num_teams, thread_limit);\n-      gimple_set_location (call, loc);\n-      gimple_seq_add_stmt (&bind_body, call);\n-    }\n+  gimple_seq_add_stmt (&bind_body, teams_stmt);\n+\n+  location_t loc = gimple_location (teams_stmt);\n+  tree decl = builtin_decl_explicit (BUILT_IN_GOMP_TEAMS);\n+  gimple *call = gimple_build_call (decl, 2, num_teams, thread_limit);\n+  gimple_set_location (call, loc);\n+  gimple_seq_add_stmt (&bind_body, call);\n \n   gimple_seq_add_seq (&bind_body, gimple_omp_body (teams_stmt));\n   gimple_omp_set_body (teams_stmt, NULL);\n   gimple_seq_add_seq (&bind_body, olist);\n   gimple_seq_add_seq (&bind_body, dlist);\n-  if (!gimple_omp_teams_grid_phony (teams_stmt))\n-    gimple_seq_add_stmt (&bind_body, gimple_build_omp_return (true));\n+  gimple_seq_add_stmt (&bind_body, gimple_build_omp_return (true));\n   gimple_bind_set_body (bind, bind_body);\n \n   pop_gimplify_context (bind);\n@@ -12667,18 +12605,6 @@ lower_omp_teams (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n     TREE_USED (block) = 1;\n }\n \n-/* Expand code within an artificial GIMPLE_OMP_GRID_BODY OMP construct.  */\n-\n-static void\n-lower_omp_grid_body (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n-{\n-  gimple *stmt = gsi_stmt (*gsi_p);\n-  lower_omp (gimple_omp_body_ptr (stmt), ctx);\n-  gimple_seq_add_stmt (gimple_omp_body_ptr (stmt),\n-\t\t       gimple_build_omp_return (false));\n-}\n-\n-\n /* Callback for lower_omp_1.  Return non-NULL if *tp needs to be\n    regimplified.  If DATA is non-NULL, lower_omp_1 is outside\n    of OMP context, but with task_shared_vars set.  */\n@@ -12897,11 +12823,6 @@ lower_omp_1 (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n       else\n \tlower_omp_teams (gsi_p, ctx);\n       break;\n-    case GIMPLE_OMP_GRID_BODY:\n-      ctx = maybe_lookup_ctx (stmt);\n-      gcc_assert (ctx);\n-      lower_omp_grid_body (gsi_p, ctx);\n-      break;\n     case GIMPLE_CALL:\n       tree fndecl;\n       call_stmt = as_a <gcall *> (stmt);\n@@ -13059,9 +12980,6 @@ execute_lower_omp (void)\n \n   body = gimple_body (current_function_decl);\n \n-  if (hsa_gen_requested_p ())\n-    omp_grid_gridify_all_targets (&body);\n-\n   scan_omp (&body, NULL);\n   gcc_assert (taskreg_nesting_level == 0);\n   FOR_EACH_VEC_ELT (taskreg_contexts, i, ctx)"}, {"sha": "63c995ddde9035d0ce41bdf17f42a4f3983df565", "filename": "gcc/opts.c", "status": "modified", "additions": 2, "deletions": 29, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c56684fd61223abd45854270cd1e83ab2f07148c/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c56684fd61223abd45854270cd1e83ab2f07148c/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=c56684fd61223abd45854270cd1e83ab2f07148c", "patch": "@@ -2484,35 +2484,8 @@ common_handle_option (struct gcc_options *opts,\n       break;\n \n     case OPT_foffload_:\n-      {\n-\tconst char *p = arg;\n-\topts->x_flag_disable_hsa = true;\n-\twhile (*p != 0)\n-\t  {\n-\t    const char *comma = strchr (p, ',');\n-\n-\t    if ((strncmp (p, \"disable\", 7) == 0)\n-\t\t&& (p[7] == ',' || p[7] == '\\0'))\n-\t      {\n-\t\topts->x_flag_disable_hsa = true;\n-\t\tbreak;\n-\t      }\n-\n-\t    if ((strncmp (p, \"hsa\", 3) == 0)\n-\t\t&& (p[3] == ',' || p[3] == '\\0'))\n-\t      {\n-#ifdef ENABLE_HSA\n-\t\topts->x_flag_disable_hsa = false;\n-#else\n-\t\tsorry (\"HSA has not been enabled during configuration\");\n-#endif\n-\t      }\n-\t    if (!comma)\n-\t      break;\n-\t    p = comma + 1;\n-\t  }\n-\tbreak;\n-      }\n+      /* Deferred.  */\n+      break;\n \n #ifndef ACCEL_COMPILER\n     case OPT_foffload_abi_:"}, {"sha": "f39e5d1a0127ff8b3df34a7deef9eceb780a87cd", "filename": "gcc/params.opt", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c56684fd61223abd45854270cd1e83ab2f07148c/gcc%2Fparams.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c56684fd61223abd45854270cd1e83ab2f07148c/gcc%2Fparams.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.opt?ref=c56684fd61223abd45854270cd1e83ab2f07148c", "patch": "@@ -170,10 +170,6 @@ The number of most executed permilles of the profiled execution of the entire pr\n Common Joined UInteger Var(param_hot_bb_frequency_fraction) Init(1000) Param\n The denominator n of fraction 1/n of the execution frequency of the entry block of a function that a basic block of this function needs to at least have in order to be considered hot.\n \n--param=hsa-gen-debug-stores=\n-Common Joined UInteger Var(param_hsa_gen_debug_stores) IntegerRange(0, 1) Param\n-Level of hsa debug stores verbosity.\n-\n -param=inline-heuristics-hint-percent=\n Common Joined UInteger Var(param_inline_heuristics_hint_percent) Init(200) Optimization IntegerRange(100, 1000000) Param\n The scale (in percents) applied to inline-insns-single and auto limits when heuristics hints that inlining is very profitable."}, {"sha": "c0098d755bf083fa2ef891762c0c7bcc49c483b7", "filename": "gcc/passes.def", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c56684fd61223abd45854270cd1e83ab2f07148c/gcc%2Fpasses.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c56684fd61223abd45854270cd1e83ab2f07148c/gcc%2Fpasses.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.def?ref=c56684fd61223abd45854270cd1e83ab2f07148c", "patch": "@@ -153,7 +153,6 @@ along with GCC; see the file COPYING3.  If not see\n   NEXT_PASS (pass_ipa_cp);\n   NEXT_PASS (pass_ipa_sra);\n   NEXT_PASS (pass_ipa_cdtor_merge);\n-  NEXT_PASS (pass_ipa_hsa);\n   NEXT_PASS (pass_ipa_fn_summary);\n   NEXT_PASS (pass_ipa_inline);\n   NEXT_PASS (pass_ipa_pure_const);\n@@ -402,7 +401,6 @@ along with GCC; see the file COPYING3.  If not see\n   NEXT_PASS (pass_gimple_isel);\n   NEXT_PASS (pass_cleanup_cfg_post_optimizing);\n   NEXT_PASS (pass_warn_function_noreturn);\n-  NEXT_PASS (pass_gen_hsail);\n \n   NEXT_PASS (pass_expand);\n "}, {"sha": "f9b03ebd96fcb81cd8182fcdf4bfcacc8fc404b9", "filename": "gcc/testsuite/c-c++-common/gomp/gridify-1.c", "status": "removed", "additions": 0, "deletions": 54, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9623f61b142174b87760c81f78928dd14af7cbc6/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fgridify-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9623f61b142174b87760c81f78928dd14af7cbc6/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fgridify-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fgridify-1.c?ref=9623f61b142174b87760c81f78928dd14af7cbc6", "patch": "@@ -1,54 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-require-effective-target offload_hsa } */\n-/* { dg-options \"-fopenmp -fdump-tree-omplower-details\" } */\n-\n-void\n-foo1 (int n, int *a, int workgroup_size)\n-{\n-  int i;\n-#pragma omp target\n-#pragma omp teams thread_limit(workgroup_size)\n-#pragma omp distribute parallel for shared(a) firstprivate(n) private(i)\n-    for (i = 0; i < n; i++)\n-      a[i]++;\n-}\n-\n-void\n-foo2 (int j, int n, int *a)\n-{\n-  int i;\n-#pragma omp target teams\n-#pragma omp distribute parallel for shared(a) firstprivate(n) private(i) firstprivate(j)\n-    for (i = j + 1; i < n; i++)\n-      a[i] = i;\n-}\n-\n-void\n-foo3 (int j, int n, int *a)\n-{\n-  int i;\n-#pragma omp target teams\n-#pragma omp distribute parallel for shared(a) firstprivate(n) private(i) firstprivate(j)\n-  for (i = j + 1; i < n; i += 3)\n-    a[i] = i;\n-}\n-\n-void\n-foo4 (int j, int n, int *a)\n-{\n-#pragma omp parallel\n-  {\n-    #pragma omp single\n-    {\n-      int i;\n-#pragma omp target\n-#pragma omp teams\n-#pragma omp distribute parallel for shared(a) firstprivate(n) private(i) firstprivate(j)\n-      for (i = j + 1; i < n; i += 3)\n-\ta[i] = i;\n-    }\n-  }\n-}\n-\n-\n-/* { dg-final { scan-tree-dump-times \"Target construct will be turned into a gridified HSA kernel\" 4 \"omplower\" } } */"}, {"sha": "6b5cc9a8a7ddafd8cb553e5ee1377c97821f258e", "filename": "gcc/testsuite/c-c++-common/gomp/gridify-2.c", "status": "removed", "additions": 0, "deletions": 66, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9623f61b142174b87760c81f78928dd14af7cbc6/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fgridify-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9623f61b142174b87760c81f78928dd14af7cbc6/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fgridify-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fgridify-2.c?ref=9623f61b142174b87760c81f78928dd14af7cbc6", "patch": "@@ -1,66 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-require-effective-target offload_hsa } */\n-/* { dg-options \"-fopenmp -fdump-tree-omplower-details\" } */\n-\n-#define BLOCK_SIZE 16\n-\n-\n-void tiled_sgemm_tt(const int M, const int N, const int K, const float alpha, const float*A, const int LDA,\n-   const float*B, const int LDB, const float beta, float*C, const int LDC){\n-\n-#pragma omp target teams map(to:A[M*K],B[K*N]) map(from:C[M*N])\n-#pragma omp distribute collapse(2)\n-   for (int C_row_start=0 ; C_row_start < M ; C_row_start+=BLOCK_SIZE)\n-      for (int C_col_start=0 ; C_col_start < N ; C_col_start+=BLOCK_SIZE)\n-\t{\n-//       Each team has a local copy of these mini matrices\n-         float As[BLOCK_SIZE][BLOCK_SIZE];\n-         float Bs[BLOCK_SIZE][BLOCK_SIZE];\n-#pragma omp parallel\n-\t {\n-         int C_row, C_col;\n-         float Cval = 0.0;\n-\n-         for (int kblock = 0; kblock  < K ; kblock += BLOCK_SIZE )\n-\t   {\n-#pragma omp for collapse(2)\n-\t     for (int row=0 ; row < BLOCK_SIZE ; row++)\n-               for (int col=0 ; col < BLOCK_SIZE ; col++)\n-\t\t {\n-\t\t   C_row = C_row_start + row;\n-\t\t   C_col = C_col_start + col;\n-\t\t   if ((C_row < M) && (kblock + col < K))\n-\t\t     As[row][col] = A[(C_row*LDA)+ kblock + col];\n-\t\t   else\n-\t\t     As[row][col] = 0;\n-\t\t   if ((kblock + row < K) && C_col < N)\n-\t\t     Bs[row][col] = B[((kblock+row)*LDB)+ C_col];\n-\t\t   else\n-\t\t     Bs[row][col] = 0;\n-\t\t }\n-\n-#pragma omp for collapse(2)\n-\t     for (int row=0 ; row < BLOCK_SIZE ; row++)\n-\t       for (int col=0 ; col < BLOCK_SIZE ; col++)\n-\t\t {\n-\t\t   for (int e = 0; e < BLOCK_SIZE; ++e)\n-                     Cval += As[row][e] * Bs[e][col];\n-\t\t }\n-\t   }  /* End for kblock .. */\n-\n-\n-#pragma omp for collapse(2)\n-         for (int row=0 ; row < BLOCK_SIZE ; row++)\n-\t   for (int col=0 ; col < BLOCK_SIZE ; col++)\n-\t     {\n-               C_row = C_row_start + row;\n-               C_col = C_col_start + col;\n-\t       if ((C_row < M) && (C_col < N))\n-\t\t C[(C_row*LDC)+C_col] = alpha*Cval + beta*C[(C_row*LDC)+C_col];\n-\n-\t     }\n-         } /* end parallel */\n-      }\t   /* end target teams distribute */\n-}\n-\n-/* { dg-final { scan-tree-dump \"Target construct will be turned into a gridified HSA kernel\" \"omplower\" } } */"}, {"sha": "8dbeaef74cd39551e9cdfff53ea626e8d67e5264", "filename": "gcc/testsuite/c-c++-common/gomp/gridify-3.c", "status": "removed", "additions": 0, "deletions": 68, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9623f61b142174b87760c81f78928dd14af7cbc6/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fgridify-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9623f61b142174b87760c81f78928dd14af7cbc6/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fgridify-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fgridify-3.c?ref=9623f61b142174b87760c81f78928dd14af7cbc6", "patch": "@@ -1,68 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-require-effective-target offload_hsa } */\n-/* { dg-options \"-fopenmp -fdump-tree-omplower-details\" } */\n-\n-#define BLOCK_SIZE 16\n-\n-void tiled_sgemm_tt(const int M, const int N, const int K, const float alpha, const float*A, const int LDA,\n-   const float*B, const int LDB, const float beta, float*C, const int LDC)\n-{\n-#pragma omp target teams map(to:A[M*K],B[K*N]) map(from:C[M*N])\n-#pragma omp distribute collapse(2)\n-   for (int C_row_start=0 ; C_row_start < M ; C_row_start+=BLOCK_SIZE)\n-      for (int C_col_start=0 ; C_col_start < N ; C_col_start+=BLOCK_SIZE)\n-\t{\n-\t  float As[BLOCK_SIZE][BLOCK_SIZE];\n-\t  float Bs[BLOCK_SIZE][BLOCK_SIZE];\n-\t  float Cs[BLOCK_SIZE][BLOCK_SIZE];\n-\t  int C_row, C_col;\n-\n-#pragma omp parallel for collapse(2)\n-         for (int row=0 ; row < BLOCK_SIZE ; row++)\n-\t   for (int col=0 ; col < BLOCK_SIZE ; col++)\n-\t     {\n-               Cs[row][col] = 0.0;\n-\t     }\n-\n-\n-         for (int kblock = 0; kblock  < K ; kblock += BLOCK_SIZE )\n-\t   {\n-#pragma omp parallel for collapse(2)\n-\t     for (int row=0 ; row < BLOCK_SIZE ; row++)\n-               for (int col=0 ; col < BLOCK_SIZE ; col++)\n-\t\t {\n-\t\t   C_row = C_row_start + row;\n-\t\t   C_col = C_col_start + col;\n-\t\t   if ((C_row < M) && (kblock + col < K))\n-\t\t     As[row][col] = A[(C_row*LDA)+ kblock + col];\n-\t\t   else\n-\t\t     As[row][col] = 0;\n-\t\t   if ((kblock + row < K) && C_col < N)\n-\t\t     Bs[row][col] = B[((kblock+row)*LDB)+ C_col];\n-\t\t   else\n-\t\t     Bs[row][col] = 0;\n-\t\t }\n-\n-#pragma omp parallel for collapse(2)\n-\t     for (int row=0 ; row < BLOCK_SIZE ; row++)\n-               for (int col=0 ; col < BLOCK_SIZE ; col++)\n-\t\t {\n-\t\t   for (int e = 0; e < BLOCK_SIZE; ++e)\n-                     Cs[row][col] += As[row][e] * Bs[e][col];\n-\t\t }\n-         }  /* End for kblock .. */\n-\n-\n-#pragma omp parallel for collapse(2)\n-         for (int row=0 ; row < BLOCK_SIZE ; row++)\n-\t   for (int col=0 ; col < BLOCK_SIZE ; col++)\n-\t     {\n-               C_row = C_row_start + row;\n-               C_col = C_col_start + col;\n-\t       if ((C_row < M) && (C_col < N))\n-\t\t C[(C_row*LDC)+C_col] = alpha*Cs[row][col] + beta*C[(C_row*LDC)+C_col];\n-\t     }\n-      }\t/* End distribute */\n-}\n-\n-/* { dg-final { scan-tree-dump \"Target construct will be turned into a gridified HSA kernel\" \"omplower\" } } */"}, {"sha": "67ee6af309a8e0b6ff87d7f2c35f6f44e5a8b84c", "filename": "gcc/testsuite/c-c++-common/gomp/hsa-indirect-call-1.c", "status": "removed", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9623f61b142174b87760c81f78928dd14af7cbc6/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fhsa-indirect-call-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9623f61b142174b87760c81f78928dd14af7cbc6/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fhsa-indirect-call-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fhsa-indirect-call-1.c?ref=9623f61b142174b87760c81f78928dd14af7cbc6", "patch": "@@ -1,24 +0,0 @@\n-/* Instead of ICE, we'd like \"HSA does not implement indirect calls\".  */\n-\n-/* Reduced from 'libgomp.c/target-39.c'.  */\n-\n-/* { dg-require-effective-target offload_hsa } */\n-/* { dg-additional-options \"-Whsa\" } to override '{gcc,g++}.dg/gomp/gomp.exp'.  */\n-\n-typedef void (*fnp) (void);\n-void f1 (void) { }\n-fnp f2 (void) { return f1; }\n-#pragma omp declare target to (f1, f2)\n-\n-int\n-main ()\n-{\n-  #pragma omp target\n-  {\n-    fnp fnp = f2 ();\n-    fnp (); /* { dg-message \"note: support for HSA does not implement indirect calls\" } */\n-  }\n-  return 0;\n-}\n-\n-/* { dg-warning \"could not emit HSAIL for the function\" \"\" { target *-*-* } 0 } */"}, {"sha": "f5c68fb0e81754746d68ffde1c3602edf0fca37a", "filename": "gcc/testsuite/g++.dg/gomp/gomp.exp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c56684fd61223abd45854270cd1e83ab2f07148c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fgomp.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c56684fd61223abd45854270cd1e83ab2f07148c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fgomp.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fgomp.exp?ref=c56684fd61223abd45854270cd1e83ab2f07148c", "patch": "@@ -29,7 +29,7 @@ dg-init\n # Main loop.\n g++-dg-runtest [lsort [concat \\\n \t[find $srcdir/$subdir *.C] \\\n-\t[find $srcdir/c-c++-common/gomp *.c]]] \"\" \"-fopenmp -Wno-hsa\"\n+\t[find $srcdir/c-c++-common/gomp *.c]]] \"\" \"-fopenmp\"\n \n # All done.\n dg-finish"}, {"sha": "8a7f18ead462550715d95ed1ec1ebc4e0a1630a9", "filename": "gcc/testsuite/gcc.dg/gomp/gomp.exp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c56684fd61223abd45854270cd1e83ab2f07148c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fgomp.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c56684fd61223abd45854270cd1e83ab2f07148c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fgomp.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fgomp.exp?ref=c56684fd61223abd45854270cd1e83ab2f07148c", "patch": "@@ -31,7 +31,7 @@ dg-init\n # Main loop.\n dg-runtest [lsort [concat \\\n \t[find $srcdir/$subdir *.c] \\\n-\t[find $srcdir/c-c++-common/gomp *.c]]] \"\" \"-fopenmp -Wno-hsa\"\n+\t[find $srcdir/c-c++-common/gomp *.c]]] \"\" \"-fopenmp\"\n \n # All done.\n dg-finish"}, {"sha": "1b0fc0d3a1bd415e2f1b79ef4e76bc3f8a73f912", "filename": "gcc/testsuite/gfortran.dg/gomp/gomp.exp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c56684fd61223abd45854270cd1e83ab2f07148c/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fgomp.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c56684fd61223abd45854270cd1e83ab2f07148c/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fgomp.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fgomp.exp?ref=c56684fd61223abd45854270cd1e83ab2f07148c", "patch": "@@ -30,7 +30,7 @@ dg-init\n \n # Main loop.\n gfortran-dg-runtest [lsort \\\n-       [find $srcdir/$subdir *.\\[fF\\]{,90,95,03,08} ] ] \"\" \"-fopenmp -Wno-hsa\"\n+       [find $srcdir/$subdir *.\\[fF\\]{,90,95,03,08} ] ] \"\" \"-fopenmp\"\n \n # All done.\n dg-finish"}, {"sha": "7def27980bae3e018635029b434186d82853698f", "filename": "gcc/testsuite/gfortran.dg/gomp/gridify-1.f90", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9623f61b142174b87760c81f78928dd14af7cbc6/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fgridify-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9623f61b142174b87760c81f78928dd14af7cbc6/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fgridify-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fgridify-1.f90?ref=9623f61b142174b87760c81f78928dd14af7cbc6", "patch": "@@ -1,16 +0,0 @@\n-! { dg-do compile }\n-! { dg-require-effective-target offload_hsa }\n-! { dg-options \"-fopenmp -fdump-tree-omplower-details\" } */\n-\n-subroutine vector_square(n, a, b)\n-      integer i, n, b(n), a(n)\n-!$omp target teams\n-!$omp distribute parallel do\n-      do i=1,n\n-          b(i) = a(i) * a(i)\n-      enddo\n-!$omp end distribute parallel do\n-!$omp end target teams\n-end subroutine vector_square\n-\n-! { dg-final { scan-tree-dump \"Target construct will be turned into a gridified HSA kernel\" \"omplower\" } }"}, {"sha": "ba9db0be2f971329bcbabb899f3a1f9c1a47b014", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c56684fd61223abd45854270cd1e83ab2f07148c/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c56684fd61223abd45854270cd1e83ab2f07148c/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=c56684fd61223abd45854270cd1e83ab2f07148c", "patch": "@@ -9858,14 +9858,6 @@ proc check_effective_target_offload_nvptx { } {\n     } \"-foffload=nvptx-none\" ]\n }\n \n-# Return 1 if the compiler has been configured with hsa offloading.\n-\n-proc check_effective_target_offload_hsa { } {\n-    return [check_no_compiler_messages offload_hsa assembly {\n-\tint main () {return 0;}\n-    } \"-foffload=hsa\" ]\n-}\n-\n # Return 1 if the compiler has been configured with gcn offloading.\n \n proc check_effective_target_offload_gcn { } {"}, {"sha": "7dd1e2685a4e98b3367c3fa93b839e5921a193a8", "filename": "gcc/timevar.def", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c56684fd61223abd45854270cd1e83ab2f07148c/gcc%2Ftimevar.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c56684fd61223abd45854270cd1e83ab2f07148c/gcc%2Ftimevar.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.def?ref=c56684fd61223abd45854270cd1e83ab2f07148c", "patch": "@@ -99,7 +99,6 @@ DEFTIMEVAR (TV_WHOPR_WPA_IO          , \"whopr wpa I/O\")\n DEFTIMEVAR (TV_WHOPR_PARTITIONING    , \"whopr partitioning\")\n DEFTIMEVAR (TV_WHOPR_LTRANS          , \"whopr ltrans\")\n DEFTIMEVAR (TV_IPA_REFERENCE         , \"ipa reference\")\n-DEFTIMEVAR (TV_IPA_HSA\t\t     , \"ipa HSA\")\n DEFTIMEVAR (TV_IPA_PROFILE           , \"ipa profile\")\n DEFTIMEVAR (TV_IPA_AUTOFDO           , \"auto profile\")\n DEFTIMEVAR (TV_IPA_PURE_CONST        , \"ipa pure const\")"}, {"sha": "9a78af1e1cf3e48f6ed706f8a070ff67310dc599", "filename": "gcc/toplev.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c56684fd61223abd45854270cd1e83ab2f07148c/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c56684fd61223abd45854270cd1e83ab2f07148c/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=c56684fd61223abd45854270cd1e83ab2f07148c", "patch": "@@ -77,7 +77,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"ipa-prop.h\"\n #include \"gcse.h\"\n #include \"omp-offload.h\"\n-#include \"hsa-common.h\"\n #include \"edit-context.h\"\n #include \"tree-pass.h\"\n #include \"dumpfile.h\"\n@@ -512,8 +511,6 @@ compile_file (void)\n \n       omp_finish_file ();\n \n-      hsa_output_brig ();\n-\n       output_shared_constant_pool ();\n       output_object_blocks ();\n       finish_tm_clone_pairs ();"}, {"sha": "0e158784d0ed906bac0370d0e8636845bdb0256a", "filename": "gcc/tree-core.h", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c56684fd61223abd45854270cd1e83ab2f07148c/gcc%2Ftree-core.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c56684fd61223abd45854270cd1e83ab2f07148c/gcc%2Ftree-core.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-core.h?ref=c56684fd61223abd45854270cd1e83ab2f07148c", "patch": "@@ -488,10 +488,6 @@ enum omp_clause_code {\n   /* OpenACC clause: tile ( size-expr-list ).  */\n   OMP_CLAUSE_TILE,\n \n-  /* OpenMP internal-only clause to specify grid dimensions of a gridified\n-     kernel.  */\n-  OMP_CLAUSE__GRIDDIM_,\n-\n   /* OpenACC clause: if_present.  */\n   OMP_CLAUSE_IF_PRESENT,\n \n@@ -1557,9 +1553,6 @@ struct GTY(()) tree_omp_clause {\n     enum omp_clause_defaultmap_kind defaultmap_kind;\n     enum omp_clause_bind_kind      bind_kind;\n     enum omp_clause_device_type_kind device_type_kind;\n-    /* The dimension a OMP_CLAUSE__GRIDDIM_ clause of a gridified target\n-       construct describes.  */\n-    unsigned int\t\t   dimension;\n   } GTY ((skip)) subcode;\n \n   /* The gimplification of OMP_CLAUSE_REDUCTION_{INIT,MERGE} for omp-low's"}, {"sha": "6ce89a7bd8e21bc3abf6acfaf5c71579d2a6153d", "filename": "gcc/tree-nested.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c56684fd61223abd45854270cd1e83ab2f07148c/gcc%2Ftree-nested.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c56684fd61223abd45854270cd1e83ab2f07148c/gcc%2Ftree-nested.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nested.c?ref=c56684fd61223abd45854270cd1e83ab2f07148c", "patch": "@@ -1394,7 +1394,6 @@ convert_nonlocal_omp_clauses (tree *pclauses, struct walk_stmt_info *wi)\n \tcase OMP_CLAUSE__LOOPTEMP_:\n \tcase OMP_CLAUSE__REDUCTEMP_:\n \tcase OMP_CLAUSE__SIMDUID_:\n-\tcase OMP_CLAUSE__GRIDDIM_:\n \tcase OMP_CLAUSE__SIMT_:\n \t  /* Anything else.  */\n \tdefault:\n@@ -2137,7 +2136,6 @@ convert_local_omp_clauses (tree *pclauses, struct walk_stmt_info *wi)\n \tcase OMP_CLAUSE__LOOPTEMP_:\n \tcase OMP_CLAUSE__REDUCTEMP_:\n \tcase OMP_CLAUSE__SIMDUID_:\n-\tcase OMP_CLAUSE__GRIDDIM_:\n \tcase OMP_CLAUSE__SIMT_:\n \t  /* Anything else.  */\n \tdefault:"}, {"sha": "f01e811917da8eeba2fd478952eaf06d81392847", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c56684fd61223abd45854270cd1e83ab2f07148c/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c56684fd61223abd45854270cd1e83ab2f07148c/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=c56684fd61223abd45854270cd1e83ab2f07148c", "patch": "@@ -474,7 +474,6 @@ extern gimple_opt_pass *make_pass_sanopt (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_oacc_kernels (gcc::context *ctxt);\n extern simple_ipa_opt_pass *make_pass_ipa_oacc (gcc::context *ctxt);\n extern simple_ipa_opt_pass *make_pass_ipa_oacc_kernels (gcc::context *ctxt);\n-extern gimple_opt_pass *make_pass_gen_hsail (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_warn_nonnull_compare (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_sprintf_length (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_walloca (gcc::context *ctxt);\n@@ -508,7 +507,6 @@ extern ipa_opt_pass_d *make_pass_ipa_icf (gcc::context *ctxt);\n extern ipa_opt_pass_d *make_pass_ipa_devirt (gcc::context *ctxt);\n extern ipa_opt_pass_d *make_pass_ipa_odr (gcc::context *ctxt);\n extern ipa_opt_pass_d *make_pass_ipa_reference (gcc::context *ctxt);\n-extern ipa_opt_pass_d *make_pass_ipa_hsa (gcc::context *ctxt);\n extern ipa_opt_pass_d *make_pass_ipa_pure_const (gcc::context *ctxt);\n extern simple_ipa_opt_pass *make_pass_ipa_pta (gcc::context *ctxt);\n extern simple_ipa_opt_pass *make_pass_ipa_tm (gcc::context *ctxt);"}, {"sha": "655061c174d3281acde419ccd49a3a40a5863ce9", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c56684fd61223abd45854270cd1e83ab2f07148c/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c56684fd61223abd45854270cd1e83ab2f07148c/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=c56684fd61223abd45854270cd1e83ab2f07148c", "patch": "@@ -1246,17 +1246,6 @@ dump_omp_clause (pretty_printer *pp, tree clause, int spc, dump_flags_t flags)\n       pp_right_paren (pp);\n       break;\n \n-    case OMP_CLAUSE__GRIDDIM_:\n-      pp_string (pp, \"_griddim_(\");\n-      pp_unsigned_wide_integer (pp, OMP_CLAUSE__GRIDDIM__DIMENSION (clause));\n-      pp_colon (pp);\n-      dump_generic_node (pp, OMP_CLAUSE__GRIDDIM__SIZE (clause), spc, flags,\n-\t\t\t false);\n-      pp_comma (pp);\n-      dump_generic_node (pp, OMP_CLAUSE__GRIDDIM__GROUP (clause), spc, flags,\n-\t\t\t false);\n-      pp_right_paren (pp);\n-      break;\n     case OMP_CLAUSE_IF_PRESENT:\n       pp_string (pp, \"if_present\");\n       break;"}, {"sha": "6dea32aeb45bd1b8f62bd9d5f7f07ca4111edfc9", "filename": "gcc/tree.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c56684fd61223abd45854270cd1e83ab2f07148c/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c56684fd61223abd45854270cd1e83ab2f07148c/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=c56684fd61223abd45854270cd1e83ab2f07148c", "patch": "@@ -357,7 +357,6 @@ unsigned const char omp_clause_num_ops[] =\n   1, /* OMP_CLAUSE_NUM_WORKERS  */\n   1, /* OMP_CLAUSE_VECTOR_LENGTH  */\n   3, /* OMP_CLAUSE_TILE  */\n-  2, /* OMP_CLAUSE__GRIDDIM_  */\n   0, /* OMP_CLAUSE_IF_PRESENT */\n   0, /* OMP_CLAUSE_FINALIZE */\n };\n@@ -442,7 +441,6 @@ const char * const omp_clause_code_name[] =\n   \"num_workers\",\n   \"vector_length\",\n   \"tile\",\n-  \"_griddim_\",\n   \"if_present\",\n   \"finalize\",\n };\n@@ -12098,7 +12096,6 @@ walk_tree_1 (tree *tp, walk_tree_fn func, void *data,\n       switch (OMP_CLAUSE_CODE (*tp))\n \t{\n \tcase OMP_CLAUSE_GANG:\n-\tcase OMP_CLAUSE__GRIDDIM_:\n \t  WALK_SUBTREE (OMP_CLAUSE_OPERAND (*tp, 1));\n \t  /* FALLTHRU */\n "}, {"sha": "22dd4ac0f3c0440f6700b54fe06c385d3b57a1a9", "filename": "gcc/tree.h", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c56684fd61223abd45854270cd1e83ab2f07148c/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c56684fd61223abd45854270cd1e83ab2f07148c/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=c56684fd61223abd45854270cd1e83ab2f07148c", "patch": "@@ -1779,14 +1779,6 @@ class auto_suppress_location_wrappers\n #define OMP_CLAUSE_TILE_COUNT(NODE) \\\n   OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_TILE), 2)\n \n-#define OMP_CLAUSE__GRIDDIM__DIMENSION(NODE) \\\n-  (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE__GRIDDIM_)\\\n-   ->omp_clause.subcode.dimension)\n-#define OMP_CLAUSE__GRIDDIM__SIZE(NODE) \\\n-  OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE__GRIDDIM_), 0)\n-#define OMP_CLAUSE__GRIDDIM__GROUP(NODE) \\\n-  OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE__GRIDDIM_), 1)\n-\n /* _CONDTEMP_ holding temporary with iteration count.  */\n #define OMP_CLAUSE__CONDTEMP__ITER(NODE) \\\n   (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE__CONDTEMP_)->base.public_flag)"}, {"sha": "16f2d1352d825b02802e3c5e03281a8c0d764796", "filename": "include/gomp-constants.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c56684fd61223abd45854270cd1e83ab2f07148c/include%2Fgomp-constants.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c56684fd61223abd45854270cd1e83ab2f07148c/include%2Fgomp-constants.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Fgomp-constants.h?ref=c56684fd61223abd45854270cd1e83ab2f07148c", "patch": "@@ -243,7 +243,6 @@ enum gomp_map_kind\n #define GOMP_VERSION\t1\n #define GOMP_VERSION_NVIDIA_PTX 1\n #define GOMP_VERSION_INTEL_MIC 0\n-#define GOMP_VERSION_HSA 0\n #define GOMP_VERSION_GCN 1\n \n #define GOMP_VERSION_PACK(LIB, DEV) (((LIB) << 16) | (DEV))"}, {"sha": "2dc2168bce7094a4188aabd4465acb5a26e62638", "filename": "libgomp/Makefile.in", "status": "modified", "additions": 180, "deletions": 100, "changes": 280, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c56684fd61223abd45854270cd1e83ab2f07148c/libgomp%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c56684fd61223abd45854270cd1e83ab2f07148c/libgomp%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FMakefile.in?ref=c56684fd61223abd45854270cd1e83ab2f07148c", "patch": "@@ -1,7 +1,7 @@\n-# Makefile.in generated by automake 1.15.1 from Makefile.am.\n+# Makefile.in generated by automake 1.16.1 from Makefile.am.\n # @configure_input@\n \n-# Copyright (C) 1994-2017 Free Software Foundation, Inc.\n+# Copyright (C) 1994-2018 Free Software Foundation, Inc.\n \n # This Makefile.in is free software; the Free Software Foundation\n # gives unlimited permission to copy and/or distribute it,\n@@ -119,9 +119,8 @@ build_triplet = @build@\n host_triplet = @host@\n target_triplet = @target@\n @PLUGIN_NVPTX_TRUE@am__append_1 = libgomp-plugin-nvptx.la\n-@PLUGIN_HSA_TRUE@am__append_2 = libgomp-plugin-hsa.la\n-@PLUGIN_GCN_TRUE@am__append_3 = libgomp-plugin-gcn.la\n-@USE_FORTRAN_TRUE@am__append_4 = openacc.f90\n+@PLUGIN_GCN_TRUE@am__append_2 = libgomp-plugin-gcn.la\n+@USE_FORTRAN_TRUE@am__append_3 = openacc.f90\n subdir = .\n ACLOCAL_M4 = $(top_srcdir)/aclocal.m4\n am__aclocal_m4_deps = $(top_srcdir)/../config/acx.m4 \\\n@@ -198,17 +197,6 @@ libgomp_plugin_gcn_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC \\\n \t$(libgomp_plugin_gcn_la_LDFLAGS) $(LDFLAGS) -o $@\n @PLUGIN_GCN_TRUE@am_libgomp_plugin_gcn_la_rpath = -rpath \\\n @PLUGIN_GCN_TRUE@\t$(toolexeclibdir)\n-@PLUGIN_HSA_TRUE@libgomp_plugin_hsa_la_DEPENDENCIES = libgomp.la \\\n-@PLUGIN_HSA_TRUE@\t$(am__DEPENDENCIES_1)\n-@PLUGIN_HSA_TRUE@am_libgomp_plugin_hsa_la_OBJECTS =  \\\n-@PLUGIN_HSA_TRUE@\tlibgomp_plugin_hsa_la-plugin-hsa.lo\n-libgomp_plugin_hsa_la_OBJECTS = $(am_libgomp_plugin_hsa_la_OBJECTS)\n-libgomp_plugin_hsa_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC \\\n-\t$(libgomp_plugin_hsa_la_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n-\t--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \\\n-\t$(libgomp_plugin_hsa_la_LDFLAGS) $(LDFLAGS) -o $@\n-@PLUGIN_HSA_TRUE@am_libgomp_plugin_hsa_la_rpath = -rpath \\\n-@PLUGIN_HSA_TRUE@\t$(toolexeclibdir)\n @PLUGIN_NVPTX_TRUE@libgomp_plugin_nvptx_la_DEPENDENCIES = libgomp.la \\\n @PLUGIN_NVPTX_TRUE@\t$(am__DEPENDENCIES_1)\n @PLUGIN_NVPTX_TRUE@am_libgomp_plugin_nvptx_la_OBJECTS =  \\\n@@ -248,7 +236,32 @@ am__v_at_0 = @\n am__v_at_1 = \n DEFAULT_INCLUDES = -I.@am__isrc@\n depcomp = $(SHELL) $(top_srcdir)/../depcomp\n-am__depfiles_maybe = depfiles\n+am__maybe_remake_depfiles = depfiles\n+am__depfiles_remade = ./$(DEPDIR)/affinity-fmt.Plo \\\n+\t./$(DEPDIR)/affinity.Plo ./$(DEPDIR)/alloc.Plo \\\n+\t./$(DEPDIR)/allocator.Plo ./$(DEPDIR)/atomic.Plo \\\n+\t./$(DEPDIR)/bar.Plo ./$(DEPDIR)/barrier.Plo \\\n+\t./$(DEPDIR)/critical.Plo ./$(DEPDIR)/env.Plo \\\n+\t./$(DEPDIR)/error.Plo ./$(DEPDIR)/fortran.Plo \\\n+\t./$(DEPDIR)/icv-device.Plo ./$(DEPDIR)/icv.Plo \\\n+\t./$(DEPDIR)/iter.Plo ./$(DEPDIR)/iter_ull.Plo \\\n+\t./$(DEPDIR)/libgomp-plugin.Plo \\\n+\t./$(DEPDIR)/libgomp_plugin_gcn_la-plugin-gcn.Plo \\\n+\t./$(DEPDIR)/libgomp_plugin_nvptx_la-plugin-nvptx.Plo \\\n+\t./$(DEPDIR)/lock.Plo ./$(DEPDIR)/loop.Plo \\\n+\t./$(DEPDIR)/loop_ull.Plo ./$(DEPDIR)/mutex.Plo \\\n+\t./$(DEPDIR)/oacc-async.Plo ./$(DEPDIR)/oacc-cuda.Plo \\\n+\t./$(DEPDIR)/oacc-host.Plo ./$(DEPDIR)/oacc-init.Plo \\\n+\t./$(DEPDIR)/oacc-mem.Plo ./$(DEPDIR)/oacc-parallel.Plo \\\n+\t./$(DEPDIR)/oacc-plugin.Plo ./$(DEPDIR)/oacc-profiling.Plo \\\n+\t./$(DEPDIR)/oacc-target.Plo ./$(DEPDIR)/ordered.Plo \\\n+\t./$(DEPDIR)/parallel.Plo ./$(DEPDIR)/priority_queue.Plo \\\n+\t./$(DEPDIR)/proc.Plo ./$(DEPDIR)/ptrlock.Plo \\\n+\t./$(DEPDIR)/sections.Plo ./$(DEPDIR)/sem.Plo \\\n+\t./$(DEPDIR)/single.Plo ./$(DEPDIR)/splay-tree.Plo \\\n+\t./$(DEPDIR)/target.Plo ./$(DEPDIR)/task.Plo \\\n+\t./$(DEPDIR)/team.Plo ./$(DEPDIR)/teams.Plo \\\n+\t./$(DEPDIR)/time.Plo ./$(DEPDIR)/work.Plo\n am__mv = mv -f\n COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \\\n \t$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)\n@@ -281,7 +294,6 @@ am__v_FCLD_ = $(am__v_FCLD_@AM_DEFAULT_V@)\n am__v_FCLD_0 = @echo \"  FCLD    \" $@;\n am__v_FCLD_1 = \n SOURCES = $(libgomp_plugin_gcn_la_SOURCES) \\\n-\t$(libgomp_plugin_hsa_la_SOURCES) \\\n \t$(libgomp_plugin_nvptx_la_SOURCES) $(libgomp_la_SOURCES)\n AM_V_DVIPS = $(am__v_DVIPS_@AM_V@)\n am__v_DVIPS_ = $(am__v_DVIPS_@AM_DEFAULT_V@)\n@@ -450,10 +462,6 @@ PLUGIN_GCN = @PLUGIN_GCN@\n PLUGIN_GCN_CPPFLAGS = @PLUGIN_GCN_CPPFLAGS@\n PLUGIN_GCN_LDFLAGS = @PLUGIN_GCN_LDFLAGS@\n PLUGIN_GCN_LIBS = @PLUGIN_GCN_LIBS@\n-PLUGIN_HSA = @PLUGIN_HSA@\n-PLUGIN_HSA_CPPFLAGS = @PLUGIN_HSA_CPPFLAGS@\n-PLUGIN_HSA_LDFLAGS = @PLUGIN_HSA_LDFLAGS@\n-PLUGIN_HSA_LIBS = @PLUGIN_HSA_LIBS@\n PLUGIN_NVPTX = @PLUGIN_NVPTX@\n PLUGIN_NVPTX_CPPFLAGS = @PLUGIN_NVPTX_CPPFLAGS@\n PLUGIN_NVPTX_LDFLAGS = @PLUGIN_NVPTX_LDFLAGS@\n@@ -550,8 +558,7 @@ libsubincludedir = $(libdir)/gcc/$(target_alias)/$(gcc_version)/include\n AM_CPPFLAGS = $(addprefix -I, $(search_path))\n AM_CFLAGS = $(XCFLAGS)\n AM_LDFLAGS = $(XLDFLAGS) $(SECTION_LDFLAGS) $(OPT_LDFLAGS)\n-toolexeclib_LTLIBRARIES = libgomp.la $(am__append_1) $(am__append_2) \\\n-\t$(am__append_3)\n+toolexeclib_LTLIBRARIES = libgomp.la $(am__append_1) $(am__append_2)\n nodist_toolexeclib_HEADERS = libgomp.spec\n \n # -Wc is only a libtool option.\n@@ -577,7 +584,7 @@ libgomp_la_SOURCES = alloc.c atomic.c barrier.c critical.c env.c \\\n \toacc-parallel.c oacc-host.c oacc-init.c oacc-mem.c \\\n \toacc-async.c oacc-plugin.c oacc-cuda.c priority_queue.c \\\n \taffinity-fmt.c teams.c allocator.c oacc-profiling.c \\\n-\toacc-target.c $(am__append_4)\n+\toacc-target.c $(am__append_3)\n \n # Nvidia PTX OpenACC plugin.\n @PLUGIN_NVPTX_TRUE@libgomp_plugin_nvptx_version_info = -version-info $(libtool_VERSION)\n@@ -589,18 +596,6 @@ libgomp_la_SOURCES = alloc.c atomic.c barrier.c critical.c env.c \\\n @PLUGIN_NVPTX_TRUE@libgomp_plugin_nvptx_la_LIBADD = libgomp.la $(PLUGIN_NVPTX_LIBS)\n @PLUGIN_NVPTX_TRUE@libgomp_plugin_nvptx_la_LIBTOOLFLAGS = --tag=disable-static\n \n-# Heterogenous Systems Architecture plugin\n-@PLUGIN_HSA_TRUE@libgomp_plugin_hsa_version_info = -version-info $(libtool_VERSION)\n-@PLUGIN_HSA_TRUE@libgomp_plugin_hsa_la_SOURCES = plugin/plugin-hsa.c\n-@PLUGIN_HSA_TRUE@libgomp_plugin_hsa_la_CPPFLAGS = $(AM_CPPFLAGS) $(PLUGIN_HSA_CPPFLAGS) \\\n-@PLUGIN_HSA_TRUE@\t-D_GNU_SOURCE\n-\n-@PLUGIN_HSA_TRUE@libgomp_plugin_hsa_la_LDFLAGS =  \\\n-@PLUGIN_HSA_TRUE@\t$(libgomp_plugin_hsa_version_info) \\\n-@PLUGIN_HSA_TRUE@\t$(lt_host_flags) $(PLUGIN_HSA_LDFLAGS)\n-@PLUGIN_HSA_TRUE@libgomp_plugin_hsa_la_LIBADD = libgomp.la $(PLUGIN_HSA_LIBS)\n-@PLUGIN_HSA_TRUE@libgomp_plugin_hsa_la_LIBTOOLFLAGS = --tag=disable-static\n-\n # AMD GCN plugin\n @PLUGIN_GCN_TRUE@libgomp_plugin_gcn_version_info = -version-info $(libtool_VERSION)\n @PLUGIN_GCN_TRUE@libgomp_plugin_gcn_la_SOURCES = plugin/plugin-gcn.c\n@@ -674,8 +669,8 @@ Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status\n \t    echo ' $(SHELL) ./config.status'; \\\n \t    $(SHELL) ./config.status;; \\\n \t  *) \\\n-\t    echo ' cd $(top_builddir) && $(SHELL) ./config.status $@ $(am__depfiles_maybe)'; \\\n-\t    cd $(top_builddir) && $(SHELL) ./config.status $@ $(am__depfiles_maybe);; \\\n+\t    echo ' cd $(top_builddir) && $(SHELL) ./config.status $@ $(am__maybe_remake_depfiles)'; \\\n+\t    cd $(top_builddir) && $(SHELL) ./config.status $@ $(am__maybe_remake_depfiles);; \\\n \tesac;\n $(top_srcdir)/plugin/Makefrag.am $(top_srcdir)/../multilib.am $(am__empty):\n \n@@ -751,9 +746,6 @@ clean-toolexeclibLTLIBRARIES:\n libgomp-plugin-gcn.la: $(libgomp_plugin_gcn_la_OBJECTS) $(libgomp_plugin_gcn_la_DEPENDENCIES) $(EXTRA_libgomp_plugin_gcn_la_DEPENDENCIES) \n \t$(AM_V_CCLD)$(libgomp_plugin_gcn_la_LINK) $(am_libgomp_plugin_gcn_la_rpath) $(libgomp_plugin_gcn_la_OBJECTS) $(libgomp_plugin_gcn_la_LIBADD) $(LIBS)\n \n-libgomp-plugin-hsa.la: $(libgomp_plugin_hsa_la_OBJECTS) $(libgomp_plugin_hsa_la_DEPENDENCIES) $(EXTRA_libgomp_plugin_hsa_la_DEPENDENCIES) \n-\t$(AM_V_CCLD)$(libgomp_plugin_hsa_la_LINK) $(am_libgomp_plugin_hsa_la_rpath) $(libgomp_plugin_hsa_la_OBJECTS) $(libgomp_plugin_hsa_la_LIBADD) $(LIBS)\n-\n libgomp-plugin-nvptx.la: $(libgomp_plugin_nvptx_la_OBJECTS) $(libgomp_plugin_nvptx_la_DEPENDENCIES) $(EXTRA_libgomp_plugin_nvptx_la_DEPENDENCIES) \n \t$(AM_V_CCLD)$(libgomp_plugin_nvptx_la_LINK) $(am_libgomp_plugin_nvptx_la_rpath) $(libgomp_plugin_nvptx_la_OBJECTS) $(libgomp_plugin_nvptx_la_LIBADD) $(LIBS)\n \n@@ -766,53 +758,58 @@ mostlyclean-compile:\n distclean-compile:\n \t-rm -f *.tab.c\n \n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/affinity-fmt.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/affinity.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/alloc.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/allocator.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/atomic.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/bar.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/barrier.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/critical.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/env.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/error.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/fortran.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/icv-device.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/icv.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/iter.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/iter_ull.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libgomp-plugin.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libgomp_plugin_gcn_la-plugin-gcn.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libgomp_plugin_hsa_la-plugin-hsa.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libgomp_plugin_nvptx_la-plugin-nvptx.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/lock.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/loop.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/loop_ull.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mutex.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/oacc-async.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/oacc-cuda.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/oacc-host.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/oacc-init.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/oacc-mem.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/oacc-parallel.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/oacc-plugin.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/oacc-profiling.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/oacc-target.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ordered.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/parallel.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/priority_queue.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/proc.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ptrlock.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sections.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sem.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/single.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/splay-tree.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/target.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/task.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/team.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/teams.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/time.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/work.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/affinity-fmt.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/affinity.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/alloc.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/allocator.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/atomic.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/bar.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/barrier.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/critical.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/env.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/error.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/fortran.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/icv-device.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/icv.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/iter.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/iter_ull.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libgomp-plugin.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libgomp_plugin_gcn_la-plugin-gcn.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libgomp_plugin_nvptx_la-plugin-nvptx.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/lock.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/loop.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/loop_ull.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mutex.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/oacc-async.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/oacc-cuda.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/oacc-host.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/oacc-init.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/oacc-mem.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/oacc-parallel.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/oacc-plugin.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/oacc-profiling.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/oacc-target.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ordered.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/parallel.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/priority_queue.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/proc.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ptrlock.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sections.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sem.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/single.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/splay-tree.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/target.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/task.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/team.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/teams.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/time.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/work.Plo@am__quote@ # am--include-marker\n+\n+$(am__depfiles_remade):\n+\t@$(MKDIR_P) $(@D)\n+\t@echo '# dummy' >$@-t && $(am__mv) $@-t $@\n+\n+am--depfiles: $(am__depfiles_remade)\n \n .c.o:\n @am__fastdepCC_TRUE@\t$(AM_V_CC)$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<\n@@ -842,13 +839,6 @@ libgomp_plugin_gcn_la-plugin-gcn.lo: plugin/plugin-gcn.c\n @AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCC_FALSE@\t$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(libgomp_plugin_gcn_la_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libgomp_plugin_gcn_la_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libgomp_plugin_gcn_la-plugin-gcn.lo `test -f 'plugin/plugin-gcn.c' || echo '$(srcdir)/'`plugin/plugin-gcn.c\n \n-libgomp_plugin_hsa_la-plugin-hsa.lo: plugin/plugin-hsa.c\n-@am__fastdepCC_TRUE@\t$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(libgomp_plugin_hsa_la_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libgomp_plugin_hsa_la_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libgomp_plugin_hsa_la-plugin-hsa.lo -MD -MP -MF $(DEPDIR)/libgomp_plugin_hsa_la-plugin-hsa.Tpo -c -o libgomp_plugin_hsa_la-plugin-hsa.lo `test -f 'plugin/plugin-hsa.c' || echo '$(srcdir)/'`plugin/plugin-hsa.c\n-@am__fastdepCC_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/libgomp_plugin_hsa_la-plugin-hsa.Tpo $(DEPDIR)/libgomp_plugin_hsa_la-plugin-hsa.Plo\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\t$(AM_V_CC)source='plugin/plugin-hsa.c' object='libgomp_plugin_hsa_la-plugin-hsa.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(libgomp_plugin_hsa_la_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libgomp_plugin_hsa_la_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libgomp_plugin_hsa_la-plugin-hsa.lo `test -f 'plugin/plugin-hsa.c' || echo '$(srcdir)/'`plugin/plugin-hsa.c\n-\n libgomp_plugin_nvptx_la-plugin-nvptx.lo: plugin/plugin-nvptx.c\n @am__fastdepCC_TRUE@\t$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(libgomp_plugin_nvptx_la_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libgomp_plugin_nvptx_la_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libgomp_plugin_nvptx_la-plugin-nvptx.lo -MD -MP -MF $(DEPDIR)/libgomp_plugin_nvptx_la-plugin-nvptx.Tpo -c -o libgomp_plugin_nvptx_la-plugin-nvptx.lo `test -f 'plugin/plugin-nvptx.c' || echo '$(srcdir)/'`plugin/plugin-nvptx.c\n @am__fastdepCC_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/libgomp_plugin_nvptx_la-plugin-nvptx.Tpo $(DEPDIR)/libgomp_plugin_nvptx_la-plugin-nvptx.Plo\n@@ -1205,7 +1195,52 @@ clean-am: clean-aminfo clean-generic clean-libtool clean-local \\\n \n distclean: distclean-recursive\n \t-rm -f $(am__CONFIG_DISTCLEAN_FILES)\n-\t-rm -rf ./$(DEPDIR)\n+\t\t-rm -f ./$(DEPDIR)/affinity-fmt.Plo\n+\t-rm -f ./$(DEPDIR)/affinity.Plo\n+\t-rm -f ./$(DEPDIR)/alloc.Plo\n+\t-rm -f ./$(DEPDIR)/allocator.Plo\n+\t-rm -f ./$(DEPDIR)/atomic.Plo\n+\t-rm -f ./$(DEPDIR)/bar.Plo\n+\t-rm -f ./$(DEPDIR)/barrier.Plo\n+\t-rm -f ./$(DEPDIR)/critical.Plo\n+\t-rm -f ./$(DEPDIR)/env.Plo\n+\t-rm -f ./$(DEPDIR)/error.Plo\n+\t-rm -f ./$(DEPDIR)/fortran.Plo\n+\t-rm -f ./$(DEPDIR)/icv-device.Plo\n+\t-rm -f ./$(DEPDIR)/icv.Plo\n+\t-rm -f ./$(DEPDIR)/iter.Plo\n+\t-rm -f ./$(DEPDIR)/iter_ull.Plo\n+\t-rm -f ./$(DEPDIR)/libgomp-plugin.Plo\n+\t-rm -f ./$(DEPDIR)/libgomp_plugin_gcn_la-plugin-gcn.Plo\n+\t-rm -f ./$(DEPDIR)/libgomp_plugin_nvptx_la-plugin-nvptx.Plo\n+\t-rm -f ./$(DEPDIR)/lock.Plo\n+\t-rm -f ./$(DEPDIR)/loop.Plo\n+\t-rm -f ./$(DEPDIR)/loop_ull.Plo\n+\t-rm -f ./$(DEPDIR)/mutex.Plo\n+\t-rm -f ./$(DEPDIR)/oacc-async.Plo\n+\t-rm -f ./$(DEPDIR)/oacc-cuda.Plo\n+\t-rm -f ./$(DEPDIR)/oacc-host.Plo\n+\t-rm -f ./$(DEPDIR)/oacc-init.Plo\n+\t-rm -f ./$(DEPDIR)/oacc-mem.Plo\n+\t-rm -f ./$(DEPDIR)/oacc-parallel.Plo\n+\t-rm -f ./$(DEPDIR)/oacc-plugin.Plo\n+\t-rm -f ./$(DEPDIR)/oacc-profiling.Plo\n+\t-rm -f ./$(DEPDIR)/oacc-target.Plo\n+\t-rm -f ./$(DEPDIR)/ordered.Plo\n+\t-rm -f ./$(DEPDIR)/parallel.Plo\n+\t-rm -f ./$(DEPDIR)/priority_queue.Plo\n+\t-rm -f ./$(DEPDIR)/proc.Plo\n+\t-rm -f ./$(DEPDIR)/ptrlock.Plo\n+\t-rm -f ./$(DEPDIR)/sections.Plo\n+\t-rm -f ./$(DEPDIR)/sem.Plo\n+\t-rm -f ./$(DEPDIR)/single.Plo\n+\t-rm -f ./$(DEPDIR)/splay-tree.Plo\n+\t-rm -f ./$(DEPDIR)/target.Plo\n+\t-rm -f ./$(DEPDIR)/task.Plo\n+\t-rm -f ./$(DEPDIR)/team.Plo\n+\t-rm -f ./$(DEPDIR)/teams.Plo\n+\t-rm -f ./$(DEPDIR)/time.Plo\n+\t-rm -f ./$(DEPDIR)/work.Plo\n \t-rm -f Makefile\n distclean-am: clean-am distclean-compile distclean-generic \\\n \tdistclean-hdr distclean-libtool distclean-local distclean-tags\n@@ -1346,7 +1381,52 @@ installcheck-am:\n maintainer-clean: maintainer-clean-recursive\n \t-rm -f $(am__CONFIG_DISTCLEAN_FILES)\n \t-rm -rf $(top_srcdir)/autom4te.cache\n-\t-rm -rf ./$(DEPDIR)\n+\t\t-rm -f ./$(DEPDIR)/affinity-fmt.Plo\n+\t-rm -f ./$(DEPDIR)/affinity.Plo\n+\t-rm -f ./$(DEPDIR)/alloc.Plo\n+\t-rm -f ./$(DEPDIR)/allocator.Plo\n+\t-rm -f ./$(DEPDIR)/atomic.Plo\n+\t-rm -f ./$(DEPDIR)/bar.Plo\n+\t-rm -f ./$(DEPDIR)/barrier.Plo\n+\t-rm -f ./$(DEPDIR)/critical.Plo\n+\t-rm -f ./$(DEPDIR)/env.Plo\n+\t-rm -f ./$(DEPDIR)/error.Plo\n+\t-rm -f ./$(DEPDIR)/fortran.Plo\n+\t-rm -f ./$(DEPDIR)/icv-device.Plo\n+\t-rm -f ./$(DEPDIR)/icv.Plo\n+\t-rm -f ./$(DEPDIR)/iter.Plo\n+\t-rm -f ./$(DEPDIR)/iter_ull.Plo\n+\t-rm -f ./$(DEPDIR)/libgomp-plugin.Plo\n+\t-rm -f ./$(DEPDIR)/libgomp_plugin_gcn_la-plugin-gcn.Plo\n+\t-rm -f ./$(DEPDIR)/libgomp_plugin_nvptx_la-plugin-nvptx.Plo\n+\t-rm -f ./$(DEPDIR)/lock.Plo\n+\t-rm -f ./$(DEPDIR)/loop.Plo\n+\t-rm -f ./$(DEPDIR)/loop_ull.Plo\n+\t-rm -f ./$(DEPDIR)/mutex.Plo\n+\t-rm -f ./$(DEPDIR)/oacc-async.Plo\n+\t-rm -f ./$(DEPDIR)/oacc-cuda.Plo\n+\t-rm -f ./$(DEPDIR)/oacc-host.Plo\n+\t-rm -f ./$(DEPDIR)/oacc-init.Plo\n+\t-rm -f ./$(DEPDIR)/oacc-mem.Plo\n+\t-rm -f ./$(DEPDIR)/oacc-parallel.Plo\n+\t-rm -f ./$(DEPDIR)/oacc-plugin.Plo\n+\t-rm -f ./$(DEPDIR)/oacc-profiling.Plo\n+\t-rm -f ./$(DEPDIR)/oacc-target.Plo\n+\t-rm -f ./$(DEPDIR)/ordered.Plo\n+\t-rm -f ./$(DEPDIR)/parallel.Plo\n+\t-rm -f ./$(DEPDIR)/priority_queue.Plo\n+\t-rm -f ./$(DEPDIR)/proc.Plo\n+\t-rm -f ./$(DEPDIR)/ptrlock.Plo\n+\t-rm -f ./$(DEPDIR)/sections.Plo\n+\t-rm -f ./$(DEPDIR)/sem.Plo\n+\t-rm -f ./$(DEPDIR)/single.Plo\n+\t-rm -f ./$(DEPDIR)/splay-tree.Plo\n+\t-rm -f ./$(DEPDIR)/target.Plo\n+\t-rm -f ./$(DEPDIR)/task.Plo\n+\t-rm -f ./$(DEPDIR)/team.Plo\n+\t-rm -f ./$(DEPDIR)/teams.Plo\n+\t-rm -f ./$(DEPDIR)/time.Plo\n+\t-rm -f ./$(DEPDIR)/work.Plo\n \t-rm -f Makefile\n maintainer-clean-am: distclean-am maintainer-clean-aminfo \\\n \tmaintainer-clean-generic maintainer-clean-local\n@@ -1373,8 +1453,8 @@ uninstall-am: uninstall-dvi-am uninstall-html-am uninstall-info-am \\\n .MAKE: $(am__recursive_targets) all install-am install-strip\n \n .PHONY: $(am__recursive_targets) CTAGS GTAGS TAGS all all-am all-local \\\n-\tam--refresh check check-am clean clean-aminfo clean-cscope \\\n-\tclean-generic clean-libtool clean-local \\\n+\tam--depfiles am--refresh check check-am clean clean-aminfo \\\n+\tclean-cscope clean-generic clean-libtool clean-local \\\n \tclean-toolexeclibLTLIBRARIES cscope cscopelist-am ctags \\\n \tctags-am dist-info distclean distclean-compile \\\n \tdistclean-generic distclean-hdr distclean-libtool \\"}, {"sha": "471963bf6074a5a3ed0347de85a509e460374572", "filename": "libgomp/aclocal.m4", "status": "modified", "additions": 86, "deletions": 103, "changes": 189, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c56684fd61223abd45854270cd1e83ab2f07148c/libgomp%2Faclocal.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c56684fd61223abd45854270cd1e83ab2f07148c/libgomp%2Faclocal.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Faclocal.m4?ref=c56684fd61223abd45854270cd1e83ab2f07148c", "patch": "@@ -1,6 +1,6 @@\n-# generated automatically by aclocal 1.15.1 -*- Autoconf -*-\n+# generated automatically by aclocal 1.16.1 -*- Autoconf -*-\n \n-# Copyright (C) 1996-2017 Free Software Foundation, Inc.\n+# Copyright (C) 1996-2018 Free Software Foundation, Inc.\n \n # This file is free software; the Free Software Foundation\n # gives unlimited permission to copy and/or distribute it,\n@@ -20,7 +20,7 @@ You have another version of autoconf.  It may work, but is not guaranteed to.\n If you have problems, you may need to regenerate the build system entirely.\n To do so, use the procedure documented by the package, typically 'autoreconf'.])])\n \n-# Copyright (C) 2002-2017 Free Software Foundation, Inc.\n+# Copyright (C) 2002-2018 Free Software Foundation, Inc.\n #\n # This file is free software; the Free Software Foundation\n # gives unlimited permission to copy and/or distribute it,\n@@ -32,10 +32,10 @@ To do so, use the procedure documented by the package, typically 'autoreconf'.])\n # generated from the m4 files accompanying Automake X.Y.\n # (This private macro should not be called outside this file.)\n AC_DEFUN([AM_AUTOMAKE_VERSION],\n-[am__api_version='1.15'\n+[am__api_version='1.16'\n dnl Some users find AM_AUTOMAKE_VERSION and mistake it for a way to\n dnl require some minimum version.  Point them to the right macro.\n-m4_if([$1], [1.15.1], [],\n+m4_if([$1], [1.16.1], [],\n       [AC_FATAL([Do not call $0, use AM_INIT_AUTOMAKE([$1]).])])dnl\n ])\n \n@@ -51,14 +51,14 @@ m4_define([_AM_AUTOCONF_VERSION], [])\n # Call AM_AUTOMAKE_VERSION and AM_AUTOMAKE_VERSION so they can be traced.\n # This function is AC_REQUIREd by AM_INIT_AUTOMAKE.\n AC_DEFUN([AM_SET_CURRENT_AUTOMAKE_VERSION],\n-[AM_AUTOMAKE_VERSION([1.15.1])dnl\n+[AM_AUTOMAKE_VERSION([1.16.1])dnl\n m4_ifndef([AC_AUTOCONF_VERSION],\n   [m4_copy([m4_PACKAGE_VERSION], [AC_AUTOCONF_VERSION])])dnl\n _AM_AUTOCONF_VERSION(m4_defn([AC_AUTOCONF_VERSION]))])\n \n # AM_AUX_DIR_EXPAND                                         -*- Autoconf -*-\n \n-# Copyright (C) 2001-2017 Free Software Foundation, Inc.\n+# Copyright (C) 2001-2018 Free Software Foundation, Inc.\n #\n # This file is free software; the Free Software Foundation\n # gives unlimited permission to copy and/or distribute it,\n@@ -110,7 +110,7 @@ am_aux_dir=`cd \"$ac_aux_dir\" && pwd`\n \n # AM_CONDITIONAL                                            -*- Autoconf -*-\n \n-# Copyright (C) 1997-2017 Free Software Foundation, Inc.\n+# Copyright (C) 1997-2018 Free Software Foundation, Inc.\n #\n # This file is free software; the Free Software Foundation\n # gives unlimited permission to copy and/or distribute it,\n@@ -141,7 +141,7 @@ AC_CONFIG_COMMANDS_PRE(\n Usually this means the macro was only invoked conditionally.]])\n fi])])\n \n-# Copyright (C) 1999-2017 Free Software Foundation, Inc.\n+# Copyright (C) 1999-2018 Free Software Foundation, Inc.\n #\n # This file is free software; the Free Software Foundation\n # gives unlimited permission to copy and/or distribute it,\n@@ -332,63 +332,54 @@ _AM_SUBST_NOTMAKE([am__nodep])dnl\n \n # Generate code to set up dependency tracking.              -*- Autoconf -*-\n \n-# Copyright (C) 1999-2017 Free Software Foundation, Inc.\n+# Copyright (C) 1999-2018 Free Software Foundation, Inc.\n #\n # This file is free software; the Free Software Foundation\n # gives unlimited permission to copy and/or distribute it,\n # with or without modifications, as long as this notice is preserved.\n \n-\n # _AM_OUTPUT_DEPENDENCY_COMMANDS\n # ------------------------------\n AC_DEFUN([_AM_OUTPUT_DEPENDENCY_COMMANDS],\n [{\n   # Older Autoconf quotes --file arguments for eval, but not when files\n   # are listed without --file.  Let's play safe and only enable the eval\n   # if we detect the quoting.\n-  case $CONFIG_FILES in\n-  *\\'*) eval set x \"$CONFIG_FILES\" ;;\n-  *)   set x $CONFIG_FILES ;;\n-  esac\n+  # TODO: see whether this extra hack can be removed once we start\n+  # requiring Autoconf 2.70 or later.\n+  AS_CASE([$CONFIG_FILES],\n+          [*\\'*], [eval set x \"$CONFIG_FILES\"],\n+          [*], [set x $CONFIG_FILES])\n   shift\n-  for mf\n+  # Used to flag and report bootstrapping failures.\n+  am_rc=0\n+  for am_mf\n   do\n     # Strip MF so we end up with the name of the file.\n-    mf=`echo \"$mf\" | sed -e 's/:.*$//'`\n-    # Check whether this is an Automake generated Makefile or not.\n-    # We used to match only the files named 'Makefile.in', but\n-    # some people rename them; so instead we look at the file content.\n-    # Grep'ing the first line is not enough: some people post-process\n-    # each Makefile.in and add a new line on top of each file to say so.\n-    # Grep'ing the whole file is not good either: AIX grep has a line\n+    am_mf=`AS_ECHO([\"$am_mf\"]) | sed -e 's/:.*$//'`\n+    # Check whether this is an Automake generated Makefile which includes\n+    # dependency-tracking related rules and includes.\n+    # Grep'ing the whole file directly is not great: AIX grep has a line\n     # limit of 2048, but all sed's we know have understand at least 4000.\n-    if sed -n 's,^#.*generated by automake.*,X,p' \"$mf\" | grep X >/dev/null 2>&1; then\n-      dirpart=`AS_DIRNAME(\"$mf\")`\n-    else\n-      continue\n-    fi\n-    # Extract the definition of DEPDIR, am__include, and am__quote\n-    # from the Makefile without running 'make'.\n-    DEPDIR=`sed -n 's/^DEPDIR = //p' < \"$mf\"`\n-    test -z \"$DEPDIR\" && continue\n-    am__include=`sed -n 's/^am__include = //p' < \"$mf\"`\n-    test -z \"$am__include\" && continue\n-    am__quote=`sed -n 's/^am__quote = //p' < \"$mf\"`\n-    # Find all dependency output files, they are included files with\n-    # $(DEPDIR) in their names.  We invoke sed twice because it is the\n-    # simplest approach to changing $(DEPDIR) to its actual value in the\n-    # expansion.\n-    for file in `sed -n \"\n-      s/^$am__include $am__quote\\(.*(DEPDIR).*\\)$am__quote\"'$/\\1/p' <\"$mf\" | \\\n-\t sed -e 's/\\$(DEPDIR)/'\"$DEPDIR\"'/g'`; do\n-      # Make sure the directory exists.\n-      test -f \"$dirpart/$file\" && continue\n-      fdir=`AS_DIRNAME([\"$file\"])`\n-      AS_MKDIR_P([$dirpart/$fdir])\n-      # echo \"creating $dirpart/$file\"\n-      echo '# dummy' > \"$dirpart/$file\"\n-    done\n+    sed -n 's,^am--depfiles:.*,X,p' \"$am_mf\" | grep X >/dev/null 2>&1 \\\n+      || continue\n+    am_dirpart=`AS_DIRNAME([\"$am_mf\"])`\n+    am_filepart=`AS_BASENAME([\"$am_mf\"])`\n+    AM_RUN_LOG([cd \"$am_dirpart\" \\\n+      && sed -e '/# am--include-marker/d' \"$am_filepart\" \\\n+        | $MAKE -f - am--depfiles]) || am_rc=$?\n   done\n+  if test $am_rc -ne 0; then\n+    AC_MSG_FAILURE([Something went wrong bootstrapping makefile fragments\n+    for automatic dependency tracking.  Try re-running configure with the\n+    '--disable-dependency-tracking' option to at least be able to build\n+    the package (albeit without support for automatic dependency tracking).])\n+  fi\n+  AS_UNSET([am_dirpart])\n+  AS_UNSET([am_filepart])\n+  AS_UNSET([am_mf])\n+  AS_UNSET([am_rc])\n+  rm -f conftest-deps.mk\n }\n ])# _AM_OUTPUT_DEPENDENCY_COMMANDS\n \n@@ -397,18 +388,17 @@ AC_DEFUN([_AM_OUTPUT_DEPENDENCY_COMMANDS],\n # -----------------------------\n # This macro should only be invoked once -- use via AC_REQUIRE.\n #\n-# This code is only required when automatic dependency tracking\n-# is enabled.  FIXME.  This creates each '.P' file that we will\n-# need in order to bootstrap the dependency handling code.\n+# This code is only required when automatic dependency tracking is enabled.\n+# This creates each '.Po' and '.Plo' makefile fragment that we'll need in\n+# order to bootstrap the dependency handling code.\n AC_DEFUN([AM_OUTPUT_DEPENDENCY_COMMANDS],\n [AC_CONFIG_COMMANDS([depfiles],\n      [test x\"$AMDEP_TRUE\" != x\"\" || _AM_OUTPUT_DEPENDENCY_COMMANDS],\n-     [AMDEP_TRUE=\"$AMDEP_TRUE\" ac_aux_dir=\"$ac_aux_dir\"])\n-])\n+     [AMDEP_TRUE=\"$AMDEP_TRUE\" MAKE=\"${MAKE-make}\"])])\n \n # Do all the work for Automake.                             -*- Autoconf -*-\n \n-# Copyright (C) 1996-2017 Free Software Foundation, Inc.\n+# Copyright (C) 1996-2018 Free Software Foundation, Inc.\n #\n # This file is free software; the Free Software Foundation\n # gives unlimited permission to copy and/or distribute it,\n@@ -495,8 +485,8 @@ AC_REQUIRE([AM_PROG_INSTALL_STRIP])dnl\n AC_REQUIRE([AC_PROG_MKDIR_P])dnl\n # For better backward compatibility.  To be removed once Automake 1.9.x\n # dies out for good.  For more background, see:\n-# <http://lists.gnu.org/archive/html/automake/2012-07/msg00001.html>\n-# <http://lists.gnu.org/archive/html/automake/2012-07/msg00014.html>\n+# <https://lists.gnu.org/archive/html/automake/2012-07/msg00001.html>\n+# <https://lists.gnu.org/archive/html/automake/2012-07/msg00014.html>\n AC_SUBST([mkdir_p], ['$(MKDIR_P)'])\n # We need awk for the \"check\" target (and possibly the TAP driver).  The\n # system \"awk\" is bad on some platforms.\n@@ -563,7 +553,7 @@ END\n Aborting the configuration process, to ensure you take notice of the issue.\n \n You can download and install GNU coreutils to get an 'rm' implementation\n-that behaves properly: <http://www.gnu.org/software/coreutils/>.\n+that behaves properly: <https://www.gnu.org/software/coreutils/>.\n \n If you want to complete the configuration process using your problematic\n 'rm' anyway, export the environment variable ACCEPT_INFERIOR_RM_PROGRAM\n@@ -605,7 +595,7 @@ for _am_header in $config_headers :; do\n done\n echo \"timestamp for $_am_arg\" >`AS_DIRNAME([\"$_am_arg\"])`/stamp-h[]$_am_stamp_count])\n \n-# Copyright (C) 2001-2017 Free Software Foundation, Inc.\n+# Copyright (C) 2001-2018 Free Software Foundation, Inc.\n #\n # This file is free software; the Free Software Foundation\n # gives unlimited permission to copy and/or distribute it,\n@@ -629,7 +619,7 @@ AC_SUBST([install_sh])])\n # Add --enable-maintainer-mode option to configure.         -*- Autoconf -*-\n # From Jim Meyering\n \n-# Copyright (C) 1996-2017 Free Software Foundation, Inc.\n+# Copyright (C) 1996-2018 Free Software Foundation, Inc.\n #\n # This file is free software; the Free Software Foundation\n # gives unlimited permission to copy and/or distribute it,\n@@ -664,57 +654,50 @@ AC_MSG_CHECKING([whether to enable maintainer-specific portions of Makefiles])\n \n # Check to see how 'make' treats includes.\t            -*- Autoconf -*-\n \n-# Copyright (C) 2001-2017 Free Software Foundation, Inc.\n+# Copyright (C) 2001-2018 Free Software Foundation, Inc.\n #\n # This file is free software; the Free Software Foundation\n # gives unlimited permission to copy and/or distribute it,\n # with or without modifications, as long as this notice is preserved.\n \n # AM_MAKE_INCLUDE()\n # -----------------\n-# Check to see how make treats includes.\n+# Check whether make has an 'include' directive that can support all\n+# the idioms we need for our automatic dependency tracking code.\n AC_DEFUN([AM_MAKE_INCLUDE],\n-[am_make=${MAKE-make}\n-cat > confinc << 'END'\n+[AC_MSG_CHECKING([whether ${MAKE-make} supports the include directive])\n+cat > confinc.mk << 'END'\n am__doit:\n-\t@echo this is the am__doit target\n+\t@echo this is the am__doit target >confinc.out\n .PHONY: am__doit\n END\n-# If we don't find an include directive, just comment out the code.\n-AC_MSG_CHECKING([for style of include used by $am_make])\n am__include=\"#\"\n am__quote=\n-_am_result=none\n-# First try GNU make style include.\n-echo \"include confinc\" > confmf\n-# Ignore all kinds of additional output from 'make'.\n-case `$am_make -s -f confmf 2> /dev/null` in #(\n-*the\\ am__doit\\ target*)\n-  am__include=include\n-  am__quote=\n-  _am_result=GNU\n-  ;;\n-esac\n-# Now try BSD make style include.\n-if test \"$am__include\" = \"#\"; then\n-   echo '.include \"confinc\"' > confmf\n-   case `$am_make -s -f confmf 2> /dev/null` in #(\n-   *the\\ am__doit\\ target*)\n-     am__include=.include\n-     am__quote=\"\\\"\"\n-     _am_result=BSD\n-     ;;\n-   esac\n-fi\n-AC_SUBST([am__include])\n-AC_SUBST([am__quote])\n-AC_MSG_RESULT([$_am_result])\n-rm -f confinc confmf\n-])\n+# BSD make does it like this.\n+echo '.include \"confinc.mk\" # ignored' > confmf.BSD\n+# Other make implementations (GNU, Solaris 10, AIX) do it like this.\n+echo 'include confinc.mk # ignored' > confmf.GNU\n+_am_result=no\n+for s in GNU BSD; do\n+  AM_RUN_LOG([${MAKE-make} -f confmf.$s && cat confinc.out])\n+  AS_CASE([$?:`cat confinc.out 2>/dev/null`],\n+      ['0:this is the am__doit target'],\n+      [AS_CASE([$s],\n+          [BSD], [am__include='.include' am__quote='\"'],\n+          [am__include='include' am__quote=''])])\n+  if test \"$am__include\" != \"#\"; then\n+    _am_result=\"yes ($s style)\"\n+    break\n+  fi\n+done\n+rm -f confinc.* confmf.*\n+AC_MSG_RESULT([${_am_result}])\n+AC_SUBST([am__include])])\n+AC_SUBST([am__quote])])\n \n # Fake the existence of programs that GNU maintainers use.  -*- Autoconf -*-\n \n-# Copyright (C) 1997-2017 Free Software Foundation, Inc.\n+# Copyright (C) 1997-2018 Free Software Foundation, Inc.\n #\n # This file is free software; the Free Software Foundation\n # gives unlimited permission to copy and/or distribute it,\n@@ -753,7 +736,7 @@ fi\n \n # Helper functions for option handling.                     -*- Autoconf -*-\n \n-# Copyright (C) 2001-2017 Free Software Foundation, Inc.\n+# Copyright (C) 2001-2018 Free Software Foundation, Inc.\n #\n # This file is free software; the Free Software Foundation\n # gives unlimited permission to copy and/or distribute it,\n@@ -782,7 +765,7 @@ AC_DEFUN([_AM_SET_OPTIONS],\n AC_DEFUN([_AM_IF_OPTION],\n [m4_ifset(_AM_MANGLE_OPTION([$1]), [$2], [$3])])\n \n-# Copyright (C) 1999-2017 Free Software Foundation, Inc.\n+# Copyright (C) 1999-2018 Free Software Foundation, Inc.\n #\n # This file is free software; the Free Software Foundation\n # gives unlimited permission to copy and/or distribute it,\n@@ -829,7 +812,7 @@ AC_LANG_POP([C])])\n # For backward compatibility.\n AC_DEFUN_ONCE([AM_PROG_CC_C_O], [AC_REQUIRE([AC_PROG_CC])])\n \n-# Copyright (C) 2001-2017 Free Software Foundation, Inc.\n+# Copyright (C) 2001-2018 Free Software Foundation, Inc.\n #\n # This file is free software; the Free Software Foundation\n # gives unlimited permission to copy and/or distribute it,\n@@ -848,7 +831,7 @@ AC_DEFUN([AM_RUN_LOG],\n \n # Check to make sure that the build environment is sane.    -*- Autoconf -*-\n \n-# Copyright (C) 1996-2017 Free Software Foundation, Inc.\n+# Copyright (C) 1996-2018 Free Software Foundation, Inc.\n #\n # This file is free software; the Free Software Foundation\n # gives unlimited permission to copy and/or distribute it,\n@@ -929,7 +912,7 @@ AC_CONFIG_COMMANDS_PRE(\n rm -f conftest.file\n ])\n \n-# Copyright (C) 2009-2017 Free Software Foundation, Inc.\n+# Copyright (C) 2009-2018 Free Software Foundation, Inc.\n #\n # This file is free software; the Free Software Foundation\n # gives unlimited permission to copy and/or distribute it,\n@@ -989,7 +972,7 @@ AC_SUBST([AM_BACKSLASH])dnl\n _AM_SUBST_NOTMAKE([AM_BACKSLASH])dnl\n ])\n \n-# Copyright (C) 2001-2017 Free Software Foundation, Inc.\n+# Copyright (C) 2001-2018 Free Software Foundation, Inc.\n #\n # This file is free software; the Free Software Foundation\n # gives unlimited permission to copy and/or distribute it,\n@@ -1017,7 +1000,7 @@ fi\n INSTALL_STRIP_PROGRAM=\"\\$(install_sh) -c -s\"\n AC_SUBST([INSTALL_STRIP_PROGRAM])])\n \n-# Copyright (C) 2006-2017 Free Software Foundation, Inc.\n+# Copyright (C) 2006-2018 Free Software Foundation, Inc.\n #\n # This file is free software; the Free Software Foundation\n # gives unlimited permission to copy and/or distribute it,\n@@ -1036,7 +1019,7 @@ AC_DEFUN([AM_SUBST_NOTMAKE], [_AM_SUBST_NOTMAKE($@)])\n \n # Check how to create a tarball.                            -*- Autoconf -*-\n \n-# Copyright (C) 2004-2017 Free Software Foundation, Inc.\n+# Copyright (C) 2004-2018 Free Software Foundation, Inc.\n #\n # This file is free software; the Free Software Foundation\n # gives unlimited permission to copy and/or distribute it,"}, {"sha": "dd8a0a06d45677462ddb2dc0e25def3408f94f26", "filename": "libgomp/config.h.in", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c56684fd61223abd45854270cd1e83ab2f07148c/libgomp%2Fconfig.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c56684fd61223abd45854270cd1e83ab2f07148c/libgomp%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig.h.in?ref=c56684fd61223abd45854270cd1e83ab2f07148c", "patch": "@@ -173,9 +173,6 @@\n /* Define to 1 if the GCN plugin is built, 0 if not. */\n #undef PLUGIN_GCN\n \n-/* Define to 1 if the HSA plugin is built, 0 if not. */\n-#undef PLUGIN_HSA\n-\n /* Define to 1 if the NVIDIA plugin is built, 0 if not. */\n #undef PLUGIN_NVPTX\n "}, {"sha": "534f735778689738969c511b7387acb1ecada5e8", "filename": "libgomp/configure", "status": "modified", "additions": 100, "deletions": 173, "changes": 273, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c56684fd61223abd45854270cd1e83ab2f07148c/libgomp%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c56684fd61223abd45854270cd1e83ab2f07148c/libgomp%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfigure?ref=c56684fd61223abd45854270cd1e83ab2f07148c", "patch": "@@ -667,8 +667,6 @@ OPT_LDFLAGS\n SECTION_LDFLAGS\n PLUGIN_GCN_FALSE\n PLUGIN_GCN_TRUE\n-PLUGIN_HSA_FALSE\n-PLUGIN_HSA_TRUE\n PLUGIN_NVPTX_FALSE\n PLUGIN_NVPTX_TRUE\n offload_additional_lib_paths\n@@ -679,10 +677,6 @@ PLUGIN_GCN_LIBS\n PLUGIN_GCN_LDFLAGS\n PLUGIN_GCN_CPPFLAGS\n PLUGIN_GCN\n-PLUGIN_HSA_LIBS\n-PLUGIN_HSA_LDFLAGS\n-PLUGIN_HSA_CPPFLAGS\n-PLUGIN_HSA\n HSA_RUNTIME_LIB\n HSA_RUNTIME_INCLUDE\n PLUGIN_NVPTX_LIBS\n@@ -730,7 +724,6 @@ am__nodep\n AMDEPBACKSLASH\n AMDEP_FALSE\n AMDEP_TRUE\n-am__quote\n am__include\n DEPDIR\n OBJEXT\n@@ -821,7 +814,8 @@ PACKAGE_VERSION\n PACKAGE_TARNAME\n PACKAGE_NAME\n PATH_SEPARATOR\n-SHELL'\n+SHELL\n+am__quote'\n ac_subst_files=''\n ac_user_opts='\n enable_option_checking\n@@ -2891,7 +2885,7 @@ target_alias=${target_alias-$host_alias}\n #  -Wall:  turns on all automake warnings...\n #  -Wno-portability:  ...except this one, since GNU make is required.\n #  -Wno-override: ... and this one, since we do want this in testsuite.\n-am__api_version='1.15'\n+am__api_version='1.16'\n \n # Find a good install program.  We prefer a C program (faster),\n # so one script is as good as another.  But avoid the broken or\n@@ -3407,8 +3401,8 @@ MAKEINFO=${MAKEINFO-\"${am_missing_run}makeinfo\"}\n \n # For better backward compatibility.  To be removed once Automake 1.9.x\n # dies out for good.  For more background, see:\n-# <http://lists.gnu.org/archive/html/automake/2012-07/msg00001.html>\n-# <http://lists.gnu.org/archive/html/automake/2012-07/msg00014.html>\n+# <https://lists.gnu.org/archive/html/automake/2012-07/msg00001.html>\n+# <https://lists.gnu.org/archive/html/automake/2012-07/msg00014.html>\n mkdir_p='$(MKDIR_P)'\n \n # We need awk for the \"check\" target (and possibly the TAP driver).  The\n@@ -3459,7 +3453,7 @@ END\n Aborting the configuration process, to ensure you take notice of the issue.\n \n You can download and install GNU coreutils to get an 'rm' implementation\n-that behaves properly: <http://www.gnu.org/software/coreutils/>.\n+that behaves properly: <https://www.gnu.org/software/coreutils/>.\n \n If you want to complete the configuration process using your problematic\n 'rm' anyway, export the environment variable ACCEPT_INFERIOR_RM_PROGRAM\n@@ -4420,45 +4414,45 @@ DEPDIR=\"${am__leading_dot}deps\"\n \n ac_config_commands=\"$ac_config_commands depfiles\"\n \n-\n-am_make=${MAKE-make}\n-cat > confinc << 'END'\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking whether ${MAKE-make} supports the include directive\" >&5\n+$as_echo_n \"checking whether ${MAKE-make} supports the include directive... \" >&6; }\n+cat > confinc.mk << 'END'\n am__doit:\n-\t@echo this is the am__doit target\n+\t@echo this is the am__doit target >confinc.out\n .PHONY: am__doit\n END\n-# If we don't find an include directive, just comment out the code.\n-{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking for style of include used by $am_make\" >&5\n-$as_echo_n \"checking for style of include used by $am_make... \" >&6; }\n am__include=\"#\"\n am__quote=\n-_am_result=none\n-# First try GNU make style include.\n-echo \"include confinc\" > confmf\n-# Ignore all kinds of additional output from 'make'.\n-case `$am_make -s -f confmf 2> /dev/null` in #(\n-*the\\ am__doit\\ target*)\n-  am__include=include\n-  am__quote=\n-  _am_result=GNU\n-  ;;\n-esac\n-# Now try BSD make style include.\n-if test \"$am__include\" = \"#\"; then\n-   echo '.include \"confinc\"' > confmf\n-   case `$am_make -s -f confmf 2> /dev/null` in #(\n-   *the\\ am__doit\\ target*)\n-     am__include=.include\n-     am__quote=\"\\\"\"\n-     _am_result=BSD\n+# BSD make does it like this.\n+echo '.include \"confinc.mk\" # ignored' > confmf.BSD\n+# Other make implementations (GNU, Solaris 10, AIX) do it like this.\n+echo 'include confinc.mk # ignored' > confmf.GNU\n+_am_result=no\n+for s in GNU BSD; do\n+  { echo \"$as_me:$LINENO: ${MAKE-make} -f confmf.$s && cat confinc.out\" >&5\n+   (${MAKE-make} -f confmf.$s && cat confinc.out) >&5 2>&5\n+   ac_status=$?\n+   echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+   (exit $ac_status); }\n+  case $?:`cat confinc.out 2>/dev/null` in #(\n+  '0:this is the am__doit target') :\n+    case $s in #(\n+  BSD) :\n+    am__include='.include' am__quote='\"' ;; #(\n+  *) :\n+    am__include='include' am__quote='' ;;\n+esac ;; #(\n+  *) :\n      ;;\n-   esac\n-fi\n-\n-\n-{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $_am_result\" >&5\n-$as_echo \"$_am_result\" >&6; }\n-rm -f confinc confmf\n+esac\n+  if test \"$am__include\" != \"#\"; then\n+    _am_result=\"yes ($s style)\"\n+    break\n+  fi\n+done\n+rm -f confinc.* confmf.*\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: ${_am_result}\" >&5\n+$as_echo \"${_am_result}\" >&6; }\n \n # Check whether --enable-dependency-tracking was given.\n if test \"${enable_dependency_tracking+set}\" = set; then :\n@@ -11435,7 +11429,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 11438 \"configure\"\n+#line 11432 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -11541,7 +11535,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 11544 \"configure\"\n+#line 11538 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -15256,15 +15250,6 @@ if test \"x$HSA_RUNTIME_LIB\" != x; then\n   HSA_RUNTIME_LDFLAGS=-L$HSA_RUNTIME_LIB\n fi\n \n-PLUGIN_HSA=0\n-PLUGIN_HSA_CPPFLAGS=\n-PLUGIN_HSA_LDFLAGS=\n-PLUGIN_HSA_LIBS=\n-\n-\n-\n-\n-\n PLUGIN_GCN=0\n PLUGIN_GCN_CPPFLAGS=\n PLUGIN_GCN_LDFLAGS=\n@@ -15346,45 +15331,6 @@ rm -f core conftest.err conftest.$ac_objext \\\n \t  ;;\n \tesac\n \t;;\n-      hsa*)\n-\tcase \"${target}\" in\n-\t  x86_64-*-*)\n-\t    case \" ${CC} ${CFLAGS} \" in\n-\t      *\" -m32 \"*|*\" -mx32 \"*)\n-\t        PLUGIN_HSA=0\n-\t\t;;\n-\t      *)\n-\t\ttgt_plugin=hsa\n-\t        PLUGIN_HSA=$tgt\n-\t        PLUGIN_HSA_CPPFLAGS=$HSA_RUNTIME_CPPFLAGS\n-\t        PLUGIN_HSA_LDFLAGS=\"$HSA_RUNTIME_LDFLAGS\"\n-\t        PLUGIN_HSA_LIBS=\"-ldl\"\n-\n-\t        PLUGIN_HSA_save_CPPFLAGS=$CPPFLAGS\n-\t        CPPFLAGS=\"$PLUGIN_HSA_CPPFLAGS $CPPFLAGS\"\n-\t        PLUGIN_HSA_save_LDFLAGS=$LDFLAGS\n-\t        LDFLAGS=\"$PLUGIN_HSA_LDFLAGS $LDFLAGS\"\n-\t        PLUGIN_HSA_save_LIBS=$LIBS\n-\t        LIBS=\"$PLUGIN_HSA_LIBS $LIBS\"\n-\n-\t        PLUGIN_HSA=1\n-\t        CPPFLAGS=$PLUGIN_HSA_save_CPPFLAGS\n-\t        LDFLAGS=$PLUGIN_HSA_save_LDFLAGS\n-\t        LIBS=$PLUGIN_HSA_save_LIBS\n-\t        case $PLUGIN_HSA in\n-\t\t  hsa*)\n-\t            HSA_PLUGIN=0\n-\t            as_fn_error $? \"HSA run-time package required for HSA support\" \"$LINENO\" 5\n-\t            ;;\n-\t        esac\n-\t\t;;\n-\t      esac\n-    \t    ;;\n-\t  *-*-*)\n-\t    PLUGIN_HSA=0\n-            ;;\n-        esac\n-        ;;\n \n       amdgcn*)\n \tcase \"${target}\" in\n@@ -15424,10 +15370,7 @@ rm -f core conftest.err conftest.$ac_objext \\\n       offload_targets=$offload_targets,$tgt\n     fi\n     # Configure additional search paths.\n-    if test \"$tgt_plugin\" = hsa; then\n-      # Offloading compilation is all handled by the target compiler.\n-      :\n-    elif test x\"$tgt_dir\" != x; then\n+    if test x\"$tgt_dir\" != x; then\n       offload_additional_options=\"$offload_additional_options -B$tgt_dir/libexec/gcc/\\$(target_alias)/\\$(gcc_version) -B$tgt_dir/bin\"\n       offload_additional_lib_paths=\"$offload_additional_lib_paths:$tgt_dir/lib64:$tgt_dir/lib:$tgt_dir/lib32\"\n     else\n@@ -15457,19 +15400,6 @@ _ACEOF\n \n cat >>confdefs.h <<_ACEOF\n #define PLUGIN_NVPTX_DYNAMIC $PLUGIN_NVPTX_DYNAMIC\n-_ACEOF\n-\n- if test $PLUGIN_HSA = 1; then\n-  PLUGIN_HSA_TRUE=\n-  PLUGIN_HSA_FALSE='#'\n-else\n-  PLUGIN_HSA_TRUE='#'\n-  PLUGIN_HSA_FALSE=\n-fi\n-\n-\n-cat >>confdefs.h <<_ACEOF\n-#define PLUGIN_HSA $PLUGIN_HSA\n _ACEOF\n \n  if test $PLUGIN_GCN = 1; then\n@@ -16756,7 +16686,7 @@ case \"$host\" in\n     case \"$enable_cet\" in\n       auto)\n \t# Check if target supports multi-byte NOPs\n-\t# and if assembler supports CET insn.\n+\t# and if compiler and assembler support CET insn.\n \tcet_save_CFLAGS=\"$CFLAGS\"\n \tCFLAGS=\"$CFLAGS -fcf-protection\"\n \tcat confdefs.h - <<_ACEOF >conftest.$ac_ext\n@@ -17247,10 +17177,6 @@ if test -z \"${PLUGIN_NVPTX_TRUE}\" && test -z \"${PLUGIN_NVPTX_FALSE}\"; then\n   as_fn_error $? \"conditional \\\"PLUGIN_NVPTX\\\" was never defined.\n Usually this means the macro was only invoked conditionally.\" \"$LINENO\" 5\n fi\n-if test -z \"${PLUGIN_HSA_TRUE}\" && test -z \"${PLUGIN_HSA_FALSE}\"; then\n-  as_fn_error $? \"conditional \\\"PLUGIN_HSA\\\" was never defined.\n-Usually this means the macro was only invoked conditionally.\" \"$LINENO\" 5\n-fi\n if test -z \"${PLUGIN_GCN_TRUE}\" && test -z \"${PLUGIN_GCN_FALSE}\"; then\n   as_fn_error $? \"conditional \\\"PLUGIN_GCN\\\" was never defined.\n Usually this means the macro was only invoked conditionally.\" \"$LINENO\" 5\n@@ -17869,7 +17795,7 @@ CC=\"$CC\"\n CXX=\"$CXX\"\n GFORTRAN=\"$GFORTRAN\"\n GDC=\"$GDC\"\n-AMDEP_TRUE=\"$AMDEP_TRUE\" ac_aux_dir=\"$ac_aux_dir\"\n+AMDEP_TRUE=\"$AMDEP_TRUE\" MAKE=\"${MAKE-make}\"\n \n \n # The HP-UX ksh and POSIX shell print the target directory to stdout\n@@ -18859,29 +18785,35 @@ esac ;;\n   # Older Autoconf quotes --file arguments for eval, but not when files\n   # are listed without --file.  Let's play safe and only enable the eval\n   # if we detect the quoting.\n-  case $CONFIG_FILES in\n-  *\\'*) eval set x \"$CONFIG_FILES\" ;;\n-  *)   set x $CONFIG_FILES ;;\n-  esac\n+  # TODO: see whether this extra hack can be removed once we start\n+  # requiring Autoconf 2.70 or later.\n+  case $CONFIG_FILES in #(\n+  *\\'*) :\n+    eval set x \"$CONFIG_FILES\" ;; #(\n+  *) :\n+    set x $CONFIG_FILES ;; #(\n+  *) :\n+     ;;\n+esac\n   shift\n-  for mf\n+  # Used to flag and report bootstrapping failures.\n+  am_rc=0\n+  for am_mf\n   do\n     # Strip MF so we end up with the name of the file.\n-    mf=`echo \"$mf\" | sed -e 's/:.*$//'`\n-    # Check whether this is an Automake generated Makefile or not.\n-    # We used to match only the files named 'Makefile.in', but\n-    # some people rename them; so instead we look at the file content.\n-    # Grep'ing the first line is not enough: some people post-process\n-    # each Makefile.in and add a new line on top of each file to say so.\n-    # Grep'ing the whole file is not good either: AIX grep has a line\n+    am_mf=`$as_echo \"$am_mf\" | sed -e 's/:.*$//'`\n+    # Check whether this is an Automake generated Makefile which includes\n+    # dependency-tracking related rules and includes.\n+    # Grep'ing the whole file directly is not great: AIX grep has a line\n     # limit of 2048, but all sed's we know have understand at least 4000.\n-    if sed -n 's,^#.*generated by automake.*,X,p' \"$mf\" | grep X >/dev/null 2>&1; then\n-      dirpart=`$as_dirname -- \"$mf\" ||\n-$as_expr X\"$mf\" : 'X\\(.*[^/]\\)//*[^/][^/]*/*$' \\| \\\n-\t X\"$mf\" : 'X\\(//\\)[^/]' \\| \\\n-\t X\"$mf\" : 'X\\(//\\)$' \\| \\\n-\t X\"$mf\" : 'X\\(/\\)' \\| . 2>/dev/null ||\n-$as_echo X\"$mf\" |\n+    sed -n 's,^am--depfiles:.*,X,p' \"$am_mf\" | grep X >/dev/null 2>&1 \\\n+      || continue\n+    am_dirpart=`$as_dirname -- \"$am_mf\" ||\n+$as_expr X\"$am_mf\" : 'X\\(.*[^/]\\)//*[^/][^/]*/*$' \\| \\\n+\t X\"$am_mf\" : 'X\\(//\\)[^/]' \\| \\\n+\t X\"$am_mf\" : 'X\\(//\\)$' \\| \\\n+\t X\"$am_mf\" : 'X\\(/\\)' \\| . 2>/dev/null ||\n+$as_echo X\"$am_mf\" |\n     sed '/^X\\(.*[^/]\\)\\/\\/*[^/][^/]*\\/*$/{\n \t    s//\\1/\n \t    q\n@@ -18899,53 +18831,48 @@ $as_echo X\"$mf\" |\n \t    q\n \t  }\n \t  s/.*/./; q'`\n-    else\n-      continue\n-    fi\n-    # Extract the definition of DEPDIR, am__include, and am__quote\n-    # from the Makefile without running 'make'.\n-    DEPDIR=`sed -n 's/^DEPDIR = //p' < \"$mf\"`\n-    test -z \"$DEPDIR\" && continue\n-    am__include=`sed -n 's/^am__include = //p' < \"$mf\"`\n-    test -z \"$am__include\" && continue\n-    am__quote=`sed -n 's/^am__quote = //p' < \"$mf\"`\n-    # Find all dependency output files, they are included files with\n-    # $(DEPDIR) in their names.  We invoke sed twice because it is the\n-    # simplest approach to changing $(DEPDIR) to its actual value in the\n-    # expansion.\n-    for file in `sed -n \"\n-      s/^$am__include $am__quote\\(.*(DEPDIR).*\\)$am__quote\"'$/\\1/p' <\"$mf\" | \\\n-\t sed -e 's/\\$(DEPDIR)/'\"$DEPDIR\"'/g'`; do\n-      # Make sure the directory exists.\n-      test -f \"$dirpart/$file\" && continue\n-      fdir=`$as_dirname -- \"$file\" ||\n-$as_expr X\"$file\" : 'X\\(.*[^/]\\)//*[^/][^/]*/*$' \\| \\\n-\t X\"$file\" : 'X\\(//\\)[^/]' \\| \\\n-\t X\"$file\" : 'X\\(//\\)$' \\| \\\n-\t X\"$file\" : 'X\\(/\\)' \\| . 2>/dev/null ||\n-$as_echo X\"$file\" |\n-    sed '/^X\\(.*[^/]\\)\\/\\/*[^/][^/]*\\/*$/{\n-\t    s//\\1/\n-\t    q\n-\t  }\n-\t  /^X\\(\\/\\/\\)[^/].*/{\n+    am_filepart=`$as_basename -- \"$am_mf\" ||\n+$as_expr X/\"$am_mf\" : '.*/\\([^/][^/]*\\)/*$' \\| \\\n+\t X\"$am_mf\" : 'X\\(//\\)$' \\| \\\n+\t X\"$am_mf\" : 'X\\(/\\)' \\| . 2>/dev/null ||\n+$as_echo X/\"$am_mf\" |\n+    sed '/^.*\\/\\([^/][^/]*\\)\\/*$/{\n \t    s//\\1/\n \t    q\n \t  }\n-\t  /^X\\(\\/\\/\\)$/{\n+\t  /^X\\/\\(\\/\\/\\)$/{\n \t    s//\\1/\n \t    q\n \t  }\n-\t  /^X\\(\\/\\).*/{\n+\t  /^X\\/\\(\\/\\).*/{\n \t    s//\\1/\n \t    q\n \t  }\n \t  s/.*/./; q'`\n-      as_dir=$dirpart/$fdir; as_fn_mkdir_p\n-      # echo \"creating $dirpart/$file\"\n-      echo '# dummy' > \"$dirpart/$file\"\n-    done\n+    { echo \"$as_me:$LINENO: cd \"$am_dirpart\" \\\n+      && sed -e '/# am--include-marker/d' \"$am_filepart\" \\\n+        | $MAKE -f - am--depfiles\" >&5\n+   (cd \"$am_dirpart\" \\\n+      && sed -e '/# am--include-marker/d' \"$am_filepart\" \\\n+        | $MAKE -f - am--depfiles) >&5 2>&5\n+   ac_status=$?\n+   echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+   (exit $ac_status); } || am_rc=$?\n   done\n+  if test $am_rc -ne 0; then\n+    { { $as_echo \"$as_me:${as_lineno-$LINENO}: error: in \\`$ac_pwd':\" >&5\n+$as_echo \"$as_me: error: in \\`$ac_pwd':\" >&2;}\n+as_fn_error $? \"Something went wrong bootstrapping makefile fragments\n+    for automatic dependency tracking.  Try re-running configure with the\n+    '--disable-dependency-tracking' option to at least be able to build\n+    the package (albeit without support for automatic dependency tracking).\n+See \\`config.log' for more details\" \"$LINENO\" 5; }\n+  fi\n+  { am_dirpart=; unset am_dirpart;}\n+  { am_filepart=; unset am_filepart;}\n+  { am_mf=; unset am_mf;}\n+  { am_rc=; unset am_rc;}\n+  rm -f conftest-deps.mk\n }\n  ;;\n     \"libtool\":C)"}, {"sha": "54301f817c28957c0c4d8336050f79df2bb1b238", "filename": "libgomp/plugin/Makefrag.am", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c56684fd61223abd45854270cd1e83ab2f07148c/libgomp%2Fplugin%2FMakefrag.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c56684fd61223abd45854270cd1e83ab2f07148c/libgomp%2Fplugin%2FMakefrag.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fplugin%2FMakefrag.am?ref=c56684fd61223abd45854270cd1e83ab2f07148c", "patch": "@@ -39,20 +39,6 @@ libgomp_plugin_nvptx_la_LIBADD = libgomp.la $(PLUGIN_NVPTX_LIBS)\n libgomp_plugin_nvptx_la_LIBTOOLFLAGS = --tag=disable-static\n endif\n \n-if PLUGIN_HSA\n-# Heterogenous Systems Architecture plugin\n-libgomp_plugin_hsa_version_info = -version-info $(libtool_VERSION)\n-toolexeclib_LTLIBRARIES += libgomp-plugin-hsa.la\n-libgomp_plugin_hsa_la_SOURCES = plugin/plugin-hsa.c\n-libgomp_plugin_hsa_la_CPPFLAGS = $(AM_CPPFLAGS) $(PLUGIN_HSA_CPPFLAGS) \\\n-\t-D_GNU_SOURCE\n-libgomp_plugin_hsa_la_LDFLAGS = $(libgomp_plugin_hsa_version_info) \\\n-\t$(lt_host_flags)\n-libgomp_plugin_hsa_la_LDFLAGS += $(PLUGIN_HSA_LDFLAGS)\n-libgomp_plugin_hsa_la_LIBADD = libgomp.la $(PLUGIN_HSA_LIBS)\n-libgomp_plugin_hsa_la_LIBTOOLFLAGS = --tag=disable-static\n-endif\n-\n if PLUGIN_GCN\n # AMD GCN plugin\n libgomp_plugin_gcn_version_info = -version-info $(libtool_VERSION)"}, {"sha": "14030082ea834c2ca194f0d1145f83b4a62e4369", "filename": "libgomp/plugin/configfrag.ac", "status": "modified", "additions": 1, "deletions": 55, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c56684fd61223abd45854270cd1e83ab2f07148c/libgomp%2Fplugin%2Fconfigfrag.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c56684fd61223abd45854270cd1e83ab2f07148c/libgomp%2Fplugin%2Fconfigfrag.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fplugin%2Fconfigfrag.ac?ref=c56684fd61223abd45854270cd1e83ab2f07148c", "patch": "@@ -128,15 +128,6 @@ if test \"x$HSA_RUNTIME_LIB\" != x; then\n   HSA_RUNTIME_LDFLAGS=-L$HSA_RUNTIME_LIB\n fi\n \n-PLUGIN_HSA=0\n-PLUGIN_HSA_CPPFLAGS=\n-PLUGIN_HSA_LDFLAGS=\n-PLUGIN_HSA_LIBS=\n-AC_SUBST(PLUGIN_HSA)\n-AC_SUBST(PLUGIN_HSA_CPPFLAGS)\n-AC_SUBST(PLUGIN_HSA_LDFLAGS)\n-AC_SUBST(PLUGIN_HSA_LIBS)\n-\n PLUGIN_GCN=0\n PLUGIN_GCN_CPPFLAGS=\n PLUGIN_GCN_LDFLAGS=\n@@ -207,45 +198,6 @@ if test x\"$enable_offload_targets\" != x; then\n \t  ;;\n \tesac\n \t;;\n-      hsa*)\n-\tcase \"${target}\" in\n-\t  x86_64-*-*)\n-\t    case \" ${CC} ${CFLAGS} \" in\n-\t      *\" -m32 \"*|*\" -mx32 \"*)\n-\t        PLUGIN_HSA=0\n-\t\t;;\n-\t      *)\n-\t\ttgt_plugin=hsa\n-\t        PLUGIN_HSA=$tgt\n-\t        PLUGIN_HSA_CPPFLAGS=$HSA_RUNTIME_CPPFLAGS\n-\t        PLUGIN_HSA_LDFLAGS=\"$HSA_RUNTIME_LDFLAGS\"\n-\t        PLUGIN_HSA_LIBS=\"-ldl\"\n-\n-\t        PLUGIN_HSA_save_CPPFLAGS=$CPPFLAGS\n-\t        CPPFLAGS=\"$PLUGIN_HSA_CPPFLAGS $CPPFLAGS\"\n-\t        PLUGIN_HSA_save_LDFLAGS=$LDFLAGS\n-\t        LDFLAGS=\"$PLUGIN_HSA_LDFLAGS $LDFLAGS\"\n-\t        PLUGIN_HSA_save_LIBS=$LIBS\n-\t        LIBS=\"$PLUGIN_HSA_LIBS $LIBS\"\n-\n-\t        PLUGIN_HSA=1\n-\t        CPPFLAGS=$PLUGIN_HSA_save_CPPFLAGS\n-\t        LDFLAGS=$PLUGIN_HSA_save_LDFLAGS\n-\t        LIBS=$PLUGIN_HSA_save_LIBS\n-\t        case $PLUGIN_HSA in\n-\t\t  hsa*)\n-\t            HSA_PLUGIN=0\n-\t            AC_MSG_ERROR([HSA run-time package required for HSA support])\n-\t            ;;\n-\t        esac\n-\t\t;;\n-\t      esac\n-    \t    ;;\n-\t  *-*-*)\n-\t    PLUGIN_HSA=0\n-            ;;\n-        esac\n-        ;;\n \n       amdgcn*)\n \tcase \"${target}\" in\n@@ -285,10 +237,7 @@ if test x\"$enable_offload_targets\" != x; then\n       offload_targets=$offload_targets,$tgt\n     fi\n     # Configure additional search paths.\n-    if test \"$tgt_plugin\" = hsa; then\n-      # Offloading compilation is all handled by the target compiler.\n-      :\n-    elif test x\"$tgt_dir\" != x; then\n+    if test x\"$tgt_dir\" != x; then\n       offload_additional_options=\"$offload_additional_options -B$tgt_dir/libexec/gcc/\\$(target_alias)/\\$(gcc_version) -B$tgt_dir/bin\"\n       offload_additional_lib_paths=\"$offload_additional_lib_paths:$tgt_dir/lib64:$tgt_dir/lib:$tgt_dir/lib32\"\n     else\n@@ -304,9 +253,6 @@ AC_DEFINE_UNQUOTED([PLUGIN_NVPTX], [$PLUGIN_NVPTX],\n   [Define to 1 if the NVIDIA plugin is built, 0 if not.])\n AC_DEFINE_UNQUOTED([PLUGIN_NVPTX_DYNAMIC], [$PLUGIN_NVPTX_DYNAMIC],\n   [Define to 1 if the NVIDIA plugin should dlopen libcuda.so.1, 0 if it should be linked against it.])\n-AM_CONDITIONAL([PLUGIN_HSA], [test $PLUGIN_HSA = 1])\n-AC_DEFINE_UNQUOTED([PLUGIN_HSA], [$PLUGIN_HSA],\n-  [Define to 1 if the HSA plugin is built, 0 if not.])\n AM_CONDITIONAL([PLUGIN_GCN], [test $PLUGIN_GCN = 1])\n AC_DEFINE_UNQUOTED([PLUGIN_GCN], [$PLUGIN_GCN],\n   [Define to 1 if the GCN plugin is built, 0 if not.])"}, {"sha": "39284bdf5f7d7a30aa9a9f079c16d8b787d4c07f", "filename": "libgomp/plugin/hsa_ext_finalize.h", "status": "removed", "additions": 0, "deletions": 270, "changes": 270, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9623f61b142174b87760c81f78928dd14af7cbc6/libgomp%2Fplugin%2Fhsa_ext_finalize.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9623f61b142174b87760c81f78928dd14af7cbc6/libgomp%2Fplugin%2Fhsa_ext_finalize.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fplugin%2Fhsa_ext_finalize.h?ref=9623f61b142174b87760c81f78928dd14af7cbc6", "patch": "@@ -1,270 +0,0 @@\n-/* HSA Extensions API 1.0.1 representation description.\n-   Copyright (C) 2016-2020 Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-Under Section 7 of GPL version 3, you are granted additional\n-permissions described in the GCC Runtime Library Exception, version\n-3.1, as published by the Free Software Foundation.\n-\n-You should have received a copy of the GNU General Public License and\n-a copy of the GCC Runtime Library Exception along with this program;\n-see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-<http://www.gnu.org/licenses/>.\n-\n-The contents of the file was created by extracting data structures, enum,\n-typedef and other definitions from HSA Runtime Programmer\u2019s Reference Manual\n-Version 1.0 (http://www.hsafoundation.com/standards/).\n-\n-HTML version is provided on the following link:\n-http://www.hsafoundation.com/html/Content/Runtime/Topics/Runtime_title_page.htm\n-*/\n-\n-\n-#ifndef _HSA_EXT_FINALIZE_H\n-#define _HSA_EXT_FINALIZE_H 1\n-\n-struct BrigModuleHeader;\n-typedef struct BrigModuleHeader *BrigModule_t;\n-\n-typedef enum {\n-  HSA_EXT_IMAGE_GEOMETRY_1D = 0,\n-  HSA_EXT_IMAGE_GEOMETRY_2D = 1,\n-  HSA_EXT_IMAGE_GEOMETRY_3D = 2,\n-  HSA_EXT_IMAGE_GEOMETRY_1DA = 3,\n-  HSA_EXT_IMAGE_GEOMETRY_2DA = 4,\n-  HSA_EXT_IMAGE_GEOMETRY_1DB = 5,\n-  HSA_EXT_IMAGE_GEOMETRY_2DDEPTH = 6,\n-  HSA_EXT_IMAGE_GEOMETRY_2DADEPTH = 7\n-} hsa_ext_image_geometry_t;\n-\n-typedef enum {\n-  HSA_EXT_IMAGE_CHANNEL_TYPE_SNORM_INT8 = 0,\n-  HSA_EXT_IMAGE_CHANNEL_TYPE_SNORM_INT16 = 1,\n-  HSA_EXT_IMAGE_CHANNEL_TYPE_UNORM_INT8 = 2,\n-  HSA_EXT_IMAGE_CHANNEL_TYPE_UNORM_INT16 = 3,\n-  HSA_EXT_IMAGE_CHANNEL_TYPE_UNORM_INT24 = 4,\n-  HSA_EXT_IMAGE_CHANNEL_TYPE_UNORM_SHORT_555 = 5,\n-  HSA_EXT_IMAGE_CHANNEL_TYPE_UNORM_SHORT_565 = 6,\n-  HSA_EXT_IMAGE_CHANNEL_TYPE_UNORM_SHORT_101010 = 7,\n-  HSA_EXT_IMAGE_CHANNEL_TYPE_SIGNED_INT8 = 8,\n-  HSA_EXT_IMAGE_CHANNEL_TYPE_SIGNED_INT16 = 9,\n-  HSA_EXT_IMAGE_CHANNEL_TYPE_SIGNED_INT32 = 10,\n-  HSA_EXT_IMAGE_CHANNEL_TYPE_UNSIGNED_INT8 = 11,\n-  HSA_EXT_IMAGE_CHANNEL_TYPE_UNSIGNED_INT16 = 12,\n-  HSA_EXT_IMAGE_CHANNEL_TYPE_UNSIGNED_INT32 = 13,\n-  HSA_EXT_IMAGE_CHANNEL_TYPE_HALF_FLOAT = 14,\n-  HSA_EXT_IMAGE_CHANNEL_TYPE_FLOAT = 15\n-} hsa_ext_image_channel_type_t;\n-\n-typedef enum {\n-  HSA_EXT_IMAGE_CHANNEL_ORDER_A = 0,\n-  HSA_EXT_IMAGE_CHANNEL_ORDER_R = 1,\n-  HSA_EXT_IMAGE_CHANNEL_ORDER_RX = 2,\n-  HSA_EXT_IMAGE_CHANNEL_ORDER_RG = 3,\n-  HSA_EXT_IMAGE_CHANNEL_ORDER_RGX = 4,\n-  HSA_EXT_IMAGE_CHANNEL_ORDER_RA = 5,\n-  HSA_EXT_IMAGE_CHANNEL_ORDER_RGB = 6,\n-  HSA_EXT_IMAGE_CHANNEL_ORDER_RGBX = 7,\n-  HSA_EXT_IMAGE_CHANNEL_ORDER_RGBA = 8,\n-  HSA_EXT_IMAGE_CHANNEL_ORDER_BGRA = 9,\n-  HSA_EXT_IMAGE_CHANNEL_ORDER_ARGB = 10,\n-  HSA_EXT_IMAGE_CHANNEL_ORDER_ABGR = 11,\n-  HSA_EXT_IMAGE_CHANNEL_ORDER_SRGB = 12,\n-  HSA_EXT_IMAGE_CHANNEL_ORDER_SRGBX = 13,\n-  HSA_EXT_IMAGE_CHANNEL_ORDER_SRGBA = 14,\n-  HSA_EXT_IMAGE_CHANNEL_ORDER_SBGRA = 15,\n-  HSA_EXT_IMAGE_CHANNEL_ORDER_INTENSITY = 16,\n-  HSA_EXT_IMAGE_CHANNEL_ORDER_LUMINANCE = 17,\n-  HSA_EXT_IMAGE_CHANNEL_ORDER_DEPTH = 18,\n-  HSA_EXT_IMAGE_CHANNEL_ORDER_DEPTH_STENCIL = 19\n-} hsa_ext_image_channel_order_t;\n-\n-typedef struct hsa_ext_image_format_s\n-{\n-  hsa_ext_image_channel_type_t channel_type;\n-  hsa_ext_image_channel_order_t channel_order;\n-} hsa_ext_image_format_t;\n-\n-typedef struct hsa_ext_sampler_s\n-{\n-  uint64_t handle;\n-} hsa_ext_sampler_t;\n-typedef struct hsa_ext_image_data_info_s\n-{\n-  size_t size;\n-  size_t alignment;\n-} hsa_ext_image_data_info_t;\n-typedef enum {\n-  HSA_EXT_SAMPLER_ADDRESSING_MODE_UNDEFINED = 0,\n-  HSA_EXT_SAMPLER_ADDRESSING_MODE_CLAMP_TO_EDGE = 1,\n-  HSA_EXT_SAMPLER_ADDRESSING_MODE_CLAMP_TO_BORDER = 2,\n-  HSA_EXT_SAMPLER_ADDRESSING_MODE_REPEAT = 3,\n-  HSA_EXT_SAMPLER_ADDRESSING_MODE_MIRRORED_REPEAT = 4\n-} hsa_ext_sampler_addressing_mode_t;\n-typedef struct hsa_ext_image_s\n-{\n-  uint64_t handle;\n-} hsa_ext_image_t;\n-typedef enum {\n-  HSA_EXT_IMAGE_CAPABILITY_NOT_SUPPORTED = 0x0,\n-  HSA_EXT_IMAGE_CAPABILITY_READ_ONLY = 0x1,\n-  HSA_EXT_IMAGE_CAPABILITY_WRITE_ONLY = 0x2,\n-  HSA_EXT_IMAGE_CAPABILITY_READ_WRITE = 0x4,\n-  HSA_EXT_IMAGE_CAPABILITY_READ_MODIFY_WRITE = 0x8,\n-  HSA_EXT_IMAGE_CAPABILITY_ACCESS_INVARIANT_DATA_LAYOUT = 0x10\n-} hsa_ext_image_capability_t;\n-typedef struct hsa_ext_control_directives_s\n-{\n-  uint64_t control_directives_mask;\n-  uint16_t break_exceptions_mask;\n-  uint16_t detect_exceptions_mask;\n-  uint32_t max_dynamic_group_size;\n-  uint64_t max_flat_grid_size;\n-  uint32_t max_flat_workgroup_size;\n-  uint32_t reserved1;\n-  uint64_t required_grid_size[3];\n-  hsa_dim3_t required_workgroup_size;\n-  uint8_t required_dim;\n-  uint8_t reserved2[75];\n-} hsa_ext_control_directives_t;\n-typedef enum {\n-  HSA_EXT_SAMPLER_FILTER_MODE_NEAREST = 0,\n-  HSA_EXT_SAMPLER_FILTER_MODE_LINEAR = 1\n-} hsa_ext_sampler_filter_mode_t;\n-\n-typedef enum {\n-  HSA_EXT_SAMPLER_COORDINATE_MODE_UNNORMALIZED = 0,\n-  HSA_EXT_SAMPLER_COORDINATE_MODE_NORMALIZED = 1\n-} hsa_ext_sampler_coordinate_mode_t;\n-typedef enum {\n-  HSA_EXT_FINALIZER_CALL_CONVENTION_AUTO = -1\n-} hsa_ext_finalizer_call_convention_t;\n-typedef struct hsa_ext_program_s\n-{\n-  uint64_t handle;\n-} hsa_ext_program_t;\n-typedef struct hsa_ext_image_descriptor_s\n-{\n-  hsa_ext_image_geometry_t geometry;\n-  size_t width;\n-  size_t height;\n-  size_t depth;\n-  size_t array_size;\n-  hsa_ext_image_format_t format;\n-} hsa_ext_image_descriptor_t;\n-typedef enum {\n-  HSA_EXT_PROGRAM_INFO_MACHINE_MODEL = 0,\n-  HSA_EXT_PROGRAM_INFO_PROFILE = 1,\n-  HSA_EXT_PROGRAM_INFO_DEFAULT_FLOAT_ROUNDING_MODE = 2\n-} hsa_ext_program_info_t;\n-typedef BrigModule_t hsa_ext_module_t;\n-typedef struct hsa_ext_sampler_descriptor_s\n-{\n-  hsa_ext_sampler_coordinate_mode_t coordinate_mode;\n-  hsa_ext_sampler_filter_mode_t filter_mode;\n-  hsa_ext_sampler_addressing_mode_t address_mode;\n-} hsa_ext_sampler_descriptor_t;\n-\n-typedef struct hsa_ext_image_region_s\n-{\n-  hsa_dim3_t offset;\n-  hsa_dim3_t range;\n-} hsa_ext_image_region_t;\n-hsa_status_t hsa_ext_image_export (hsa_agent_t agent, hsa_ext_image_t src_image,\n-\t\t\t\t   void *dst_memory, size_t dst_row_pitch,\n-\t\t\t\t   size_t dst_slice_pitch,\n-\t\t\t\t   const hsa_ext_image_region_t *image_region);\n-hsa_status_t hsa_ext_program_add_module (hsa_ext_program_t program,\n-\t\t\t\t\t hsa_ext_module_t module);\n-hsa_status_t hsa_ext_program_iterate_modules (\n-  hsa_ext_program_t program,\n-  hsa_status_t (*callback) (hsa_ext_program_t program, hsa_ext_module_t module,\n-\t\t\t    void *data),\n-  void *data);\n-hsa_status_t hsa_ext_program_create (\n-  hsa_machine_model_t machine_model, hsa_profile_t profile,\n-  hsa_default_float_rounding_mode_t default_float_rounding_mode,\n-  const char *options, hsa_ext_program_t *program);\n-hsa_status_t\n-hsa_ext_image_data_get_info (hsa_agent_t agent,\n-\t\t\t     const hsa_ext_image_descriptor_t *image_descriptor,\n-\t\t\t     hsa_access_permission_t access_permission,\n-\t\t\t     hsa_ext_image_data_info_t *image_data_info);\n-\n-hsa_status_t hsa_ext_image_import (hsa_agent_t agent, const void *src_memory,\n-\t\t\t\t   size_t src_row_pitch, size_t src_slice_pitch,\n-\t\t\t\t   hsa_ext_image_t dst_image,\n-\t\t\t\t   const hsa_ext_image_region_t *image_region);\n-hsa_status_t hsa_ext_program_get_info (hsa_ext_program_t program,\n-\t\t\t\t       hsa_ext_program_info_t attribute,\n-\t\t\t\t       void *value);\n-enum\n-{\n-  HSA_EXT_STATUS_ERROR_IMAGE_FORMAT_UNSUPPORTED = 0x3000,\n-  HSA_EXT_STATUS_ERROR_IMAGE_SIZE_UNSUPPORTED = 0x3001\n-};\n-hsa_status_t hsa_ext_image_destroy (hsa_agent_t agent, hsa_ext_image_t image);\n-hsa_status_t hsa_ext_image_get_capability (\n-  hsa_agent_t agent, hsa_ext_image_geometry_t geometry,\n-  const hsa_ext_image_format_t *image_format, uint32_t *capability_mask);\n-enum\n-{\n-  HSA_EXT_STATUS_ERROR_INVALID_PROGRAM = 0x2000,\n-  HSA_EXT_STATUS_ERROR_INVALID_MODULE = 0x2001,\n-  HSA_EXT_STATUS_ERROR_INCOMPATIBLE_MODULE = 0x2002,\n-  HSA_EXT_STATUS_ERROR_MODULE_ALREADY_INCLUDED = 0x2003,\n-  HSA_EXT_STATUS_ERROR_SYMBOL_MISMATCH = 0x2004,\n-  HSA_EXT_STATUS_ERROR_FINALIZATION_FAILED = 0x2005,\n-  HSA_EXT_STATUS_ERROR_DIRECTIVE_MISMATCH = 0x2006\n-};\n-hsa_status_t hsa_ext_sampler_destroy (hsa_agent_t agent,\n-\t\t\t\t      hsa_ext_sampler_t sampler);\n-hsa_status_t hsa_ext_program_finalize (\n-  hsa_ext_program_t program, hsa_isa_t isa, int32_t call_convention,\n-  hsa_ext_control_directives_t control_directives, const char *options,\n-  hsa_code_object_type_t code_object_type, hsa_code_object_t *code_object);\n-hsa_status_t hsa_ext_image_create (\n-  hsa_agent_t agent, const hsa_ext_image_descriptor_t *image_descriptor,\n-  const void *image_data, hsa_access_permission_t access_permission,\n-  hsa_ext_image_t *image);\n-hsa_status_t hsa_ext_program_destroy (hsa_ext_program_t program);\n-hsa_status_t hsa_ext_image_copy (hsa_agent_t agent, hsa_ext_image_t src_image,\n-\t\t\t\t const hsa_dim3_t *src_offset,\n-\t\t\t\t hsa_ext_image_t dst_image,\n-\t\t\t\t const hsa_dim3_t *dst_offset,\n-\t\t\t\t const hsa_dim3_t *range);\n-hsa_status_t hsa_ext_image_clear (hsa_agent_t agent, hsa_ext_image_t image,\n-\t\t\t\t  const void *data,\n-\t\t\t\t  const hsa_ext_image_region_t *image_region);\n-enum\n-{\n-  HSA_EXT_AGENT_INFO_IMAGE_1D_MAX_ELEMENTS = 0x3000,\n-  HSA_EXT_AGENT_INFO_IMAGE_1DA_MAX_ELEMENTS = 0x3001,\n-  HSA_EXT_AGENT_INFO_IMAGE_1DB_MAX_ELEMENTS = 0x3002,\n-  HSA_EXT_AGENT_INFO_IMAGE_2D_MAX_ELEMENTS = 0x3003,\n-  HSA_EXT_AGENT_INFO_IMAGE_2DA_MAX_ELEMENTS = 0x3004,\n-  HSA_EXT_AGENT_INFO_IMAGE_2DDEPTH_MAX_ELEMENTS = 0x3005,\n-  HSA_EXT_AGENT_INFO_IMAGE_2DADEPTH_MAX_ELEMENTS = 0x3006,\n-  HSA_EXT_AGENT_INFO_IMAGE_3D_MAX_ELEMENTS = 0x3007,\n-  HSA_EXT_AGENT_INFO_IMAGE_ARRAY_MAX_LAYERS = 0x3008,\n-  HSA_EXT_AGENT_INFO_MAX_IMAGE_RD_HANDLES = 0x3009,\n-  HSA_EXT_AGENT_INFO_MAX_IMAGE_RORW_HANDLES = 0x300A,\n-  HSA_EXT_AGENT_INFO_MAX_SAMPLER_HANDLERS = 0x300B\n-};\n-hsa_status_t\n-hsa_ext_sampler_create (hsa_agent_t agent,\n-\t\t\tconst hsa_ext_sampler_descriptor_t *sampler_descriptor,\n-\t\t\thsa_ext_sampler_t *sampler);\n-\n-#endif /* _HSA_EXT_FINALIZE_H */"}, {"sha": "abd3bc64163bb864cb05f0809c93875e3e1b24c5", "filename": "libgomp/plugin/plugin-hsa.c", "status": "removed", "additions": 0, "deletions": 1871, "changes": 1871, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9623f61b142174b87760c81f78928dd14af7cbc6/libgomp%2Fplugin%2Fplugin-hsa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9623f61b142174b87760c81f78928dd14af7cbc6/libgomp%2Fplugin%2Fplugin-hsa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fplugin%2Fplugin-hsa.c?ref=9623f61b142174b87760c81f78928dd14af7cbc6", "patch": "@@ -1,1871 +0,0 @@\n-/* Plugin for HSAIL execution.\n-\n-   Copyright (C) 2013-2020 Free Software Foundation, Inc.\n-\n-   Contributed by Martin Jambor <mjambor@suse.cz> and\n-   Martin Liska <mliska@suse.cz>.\n-\n-   This file is part of the GNU Offloading and Multi Processing Library\n-   (libgomp).\n-\n-   Libgomp is free software; you can redistribute it and/or modify it\n-   under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 3, or (at your option)\n-   any later version.\n-\n-   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n-   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n-   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n-   more details.\n-\n-   Under Section 7 of GPL version 3, you are granted additional\n-   permissions described in the GCC Runtime Library Exception, version\n-   3.1, as published by the Free Software Foundation.\n-\n-   You should have received a copy of the GNU General Public License and\n-   a copy of the GCC Runtime Library Exception along with this program;\n-   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-#include \"config.h\"\n-#include <stdint.h>\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <string.h>\n-#include <pthread.h>\n-#ifdef HAVE_INTTYPES_H\n-#include <inttypes.h>\n-#endif\n-#include <stdbool.h>\n-#include <hsa.h>\n-#include <plugin/hsa_ext_finalize.h>\n-#include <dlfcn.h>\n-#include \"libgomp-plugin.h\"\n-#include \"gomp-constants.h\"\n-#include \"secure_getenv.h\"\n-\n-#ifdef HAVE_INTTYPES_H\n-typedef uint64_t print_uint64_t;\n-#else\n-#define PRIu64 \"lu\"\n-typedef unsigned long print_uint64_t; \n-#endif\n-\n-/* As an HSA runtime is dlopened, following structure defines function\n-   pointers utilized by the HSA plug-in.  */\n-\n-struct hsa_runtime_fn_info\n-{\n-  /* HSA runtime.  */\n-  hsa_status_t (*hsa_status_string_fn) (hsa_status_t status,\n-\t\t\t\t\tconst char **status_string);\n-  hsa_status_t (*hsa_agent_get_info_fn) (hsa_agent_t agent,\n-\t\t\t\t\t hsa_agent_info_t attribute,\n-\t\t\t\t\t void *value);\n-  hsa_status_t (*hsa_init_fn) (void);\n-  hsa_status_t (*hsa_iterate_agents_fn)\n-    (hsa_status_t (*callback)(hsa_agent_t agent, void *data), void *data);\n-  hsa_status_t (*hsa_region_get_info_fn) (hsa_region_t region,\n-\t\t\t\t\t  hsa_region_info_t attribute,\n-\t\t\t\t\t  void *value);\n-  hsa_status_t (*hsa_queue_create_fn)\n-    (hsa_agent_t agent, uint32_t size, hsa_queue_type_t type,\n-     void (*callback)(hsa_status_t status, hsa_queue_t *source, void *data),\n-     void *data, uint32_t private_segment_size,\n-     uint32_t group_segment_size, hsa_queue_t **queue);\n-  hsa_status_t (*hsa_agent_iterate_regions_fn)\n-    (hsa_agent_t agent,\n-     hsa_status_t (*callback)(hsa_region_t region, void *data), void *data);\n-  hsa_status_t (*hsa_executable_destroy_fn) (hsa_executable_t executable);\n-  hsa_status_t (*hsa_executable_create_fn)\n-    (hsa_profile_t profile, hsa_executable_state_t executable_state,\n-     const char *options, hsa_executable_t *executable);\n-  hsa_status_t (*hsa_executable_global_variable_define_fn)\n-    (hsa_executable_t executable, const char *variable_name, void *address);\n-  hsa_status_t (*hsa_executable_load_code_object_fn)\n-    (hsa_executable_t executable, hsa_agent_t agent,\n-     hsa_code_object_t code_object, const char *options);\n-  hsa_status_t (*hsa_executable_freeze_fn)(hsa_executable_t executable,\n-\t\t\t\t\t   const char *options);\n-  hsa_status_t (*hsa_signal_create_fn) (hsa_signal_value_t initial_value,\n-\t\t\t\t\tuint32_t num_consumers,\n-\t\t\t\t\tconst hsa_agent_t *consumers,\n-\t\t\t\t\thsa_signal_t *signal);\n-  hsa_status_t (*hsa_memory_allocate_fn) (hsa_region_t region, size_t size,\n-\t\t\t\t\t  void **ptr);\n-  hsa_status_t (*hsa_memory_free_fn) (void *ptr);\n-  hsa_status_t (*hsa_signal_destroy_fn) (hsa_signal_t signal);\n-  hsa_status_t (*hsa_executable_get_symbol_fn)\n-    (hsa_executable_t executable, const char *module_name,\n-     const char *symbol_name, hsa_agent_t agent, int32_t call_convention,\n-     hsa_executable_symbol_t *symbol);\n-  hsa_status_t (*hsa_executable_symbol_get_info_fn)\n-    (hsa_executable_symbol_t executable_symbol,\n-     hsa_executable_symbol_info_t attribute, void *value);\n-  uint64_t (*hsa_queue_add_write_index_release_fn) (const hsa_queue_t *queue,\n-\t\t\t\t\t\t    uint64_t value);\n-  uint64_t (*hsa_queue_load_read_index_acquire_fn) (const hsa_queue_t *queue);\n-  void (*hsa_signal_store_relaxed_fn) (hsa_signal_t signal,\n-\t\t\t\t       hsa_signal_value_t value);\n-  void (*hsa_signal_store_release_fn) (hsa_signal_t signal,\n-\t\t\t\t       hsa_signal_value_t value);\n-  hsa_signal_value_t (*hsa_signal_wait_acquire_fn)\n-    (hsa_signal_t signal, hsa_signal_condition_t condition,\n-     hsa_signal_value_t compare_value, uint64_t timeout_hint,\n-     hsa_wait_state_t wait_state_hint);\n-  hsa_signal_value_t (*hsa_signal_load_acquire_fn) (hsa_signal_t signal);\n-  hsa_status_t (*hsa_queue_destroy_fn) (hsa_queue_t *queue);\n-\n-  /* HSA finalizer.  */\n-  hsa_status_t (*hsa_ext_program_add_module_fn) (hsa_ext_program_t program,\n-\t\t\t\t\t\t hsa_ext_module_t module);\n-  hsa_status_t (*hsa_ext_program_create_fn)\n-    (hsa_machine_model_t machine_model, hsa_profile_t profile,\n-     hsa_default_float_rounding_mode_t default_float_rounding_mode,\n-     const char *options, hsa_ext_program_t *program);\n-  hsa_status_t (*hsa_ext_program_destroy_fn) (hsa_ext_program_t program);\n-  hsa_status_t (*hsa_ext_program_finalize_fn)\n-    (hsa_ext_program_t program,hsa_isa_t isa,\n-     int32_t call_convention, hsa_ext_control_directives_t control_directives,\n-     const char *options, hsa_code_object_type_t code_object_type,\n-     hsa_code_object_t *code_object);\n-};\n-\n-/* HSA runtime functions that are initialized in init_hsa_context.  */\n-\n-static struct hsa_runtime_fn_info hsa_fns;\n-\n-/* Keep the following GOMP prefixed structures in sync with respective parts of\n-   the compiler.  */\n-\n-/* Structure describing the run-time and grid properties of an HSA kernel\n-   lauch.  */\n-\n-struct GOMP_kernel_launch_attributes\n-{\n-  /* Number of dimensions the workload has.  Maximum number is 3.  */\n-  uint32_t ndim;\n-  /* Size of the grid in the three respective dimensions.  */\n-  uint32_t gdims[3];\n-  /* Size of work-groups in the respective dimensions.  */\n-  uint32_t wdims[3];\n-};\n-\n-/* Collection of information needed for a dispatch of a kernel from a\n-   kernel.  */\n-\n-struct GOMP_hsa_kernel_dispatch\n-{\n-  /* Pointer to a command queue associated with a kernel dispatch agent.  */\n-  void *queue;\n-  /* Pointer to reserved memory for OMP data struct copying.  */\n-  void *omp_data_memory;\n-  /* Pointer to a memory space used for kernel arguments passing.  */\n-  void *kernarg_address;\n-  /* Kernel object.  */\n-  uint64_t object;\n-  /* Synchronization signal used for dispatch synchronization.  */\n-  uint64_t signal;\n-  /* Private segment size.  */\n-  uint32_t private_segment_size;\n-  /* Group segment size.  */\n-  uint32_t group_segment_size;\n-  /* Number of children kernel dispatches.  */\n-  uint64_t kernel_dispatch_count;\n-  /* Debug purpose argument.  */\n-  uint64_t debug;\n-  /* Levels-var ICV.  */\n-  uint64_t omp_level;\n-  /* Kernel dispatch structures created for children kernel dispatches.  */\n-  struct GOMP_hsa_kernel_dispatch **children_dispatches;\n-  /* Number of threads.  */\n-  uint32_t omp_num_threads;\n-};\n-\n-/* Part of the libgomp plugin interface.  Return the name of the accelerator,\n-   which is \"hsa\".  */\n-\n-const char *\n-GOMP_OFFLOAD_get_name (void)\n-{\n-  return \"hsa\";\n-}\n-\n-/* Part of the libgomp plugin interface.  Return the specific capabilities the\n-   HSA accelerator have.  */\n-\n-unsigned int\n-GOMP_OFFLOAD_get_caps (void)\n-{\n-  return GOMP_OFFLOAD_CAP_SHARED_MEM | GOMP_OFFLOAD_CAP_OPENMP_400;\n-}\n-\n-/* Part of the libgomp plugin interface.  Identify as HSA accelerator.  */\n-\n-int\n-GOMP_OFFLOAD_get_type (void)\n-{\n-  return OFFLOAD_TARGET_TYPE_HSA;\n-}\n-\n-/* Return the libgomp version number we're compatible with.  There is\n-   no requirement for cross-version compatibility.  */\n-\n-unsigned\n-GOMP_OFFLOAD_version (void)\n-{\n-  return GOMP_VERSION;\n-}\n-\n-/* Flag to decide whether print to stderr information about what is going on.\n-   Set in init_debug depending on environment variables.  */\n-\n-static bool debug;\n-\n-/* Flag to decide if the runtime should suppress a possible fallback to host\n-   execution.  */\n-\n-static bool suppress_host_fallback;\n-\n-/* Flag to locate HSA runtime shared library that is dlopened\n-   by this plug-in.  */\n-\n-static const char *hsa_runtime_lib;\n-\n-/* Flag to decide if the runtime should support also CPU devices (can be\n-   a simulator).  */\n-\n-static bool support_cpu_devices;\n-\n-/* Initialize debug and suppress_host_fallback according to the environment.  */\n-\n-static void\n-init_enviroment_variables (void)\n-{\n-  if (secure_getenv (\"HSA_DEBUG\"))\n-    debug = true;\n-  else\n-    debug = false;\n-\n-  if (secure_getenv (\"HSA_SUPPRESS_HOST_FALLBACK\"))\n-    suppress_host_fallback = true;\n-  else\n-    suppress_host_fallback = false;\n-\n-  hsa_runtime_lib = secure_getenv (\"HSA_RUNTIME_LIB\");\n-  if (hsa_runtime_lib == NULL)\n-    hsa_runtime_lib = HSA_RUNTIME_LIB \"libhsa-runtime64.so\";\n-\n-  support_cpu_devices = secure_getenv (\"HSA_SUPPORT_CPU_DEVICES\");\n-}\n-\n-/* Print a logging message with PREFIX to stderr if HSA_DEBUG value\n-   is set to true.  */\n-\n-#define HSA_LOG(prefix, ...) \\\n-  do \\\n-  { \\\n-    if (debug) \\\n-      { \\\n-\tfprintf (stderr, prefix); \\\n-\tfprintf (stderr, __VA_ARGS__); \\\n-      } \\\n-  } \\\n-  while (false)\n-\n-/* Print a debugging message to stderr.  */\n-\n-#define HSA_DEBUG(...) HSA_LOG (\"HSA debug: \", __VA_ARGS__)\n-\n-/* Print a warning message to stderr.  */\n-\n-#define HSA_WARNING(...) HSA_LOG (\"HSA warning: \", __VA_ARGS__)\n-\n-/* Print HSA warning STR with an HSA STATUS code.  */\n-\n-static void\n-hsa_warn (const char *str, hsa_status_t status)\n-{\n-  if (!debug)\n-    return;\n-\n-  const char *hsa_error_msg = \"[unknown]\";\n-  hsa_fns.hsa_status_string_fn (status, &hsa_error_msg);\n-\n-  fprintf (stderr, \"HSA warning: %s\\nRuntime message: %s\", str, hsa_error_msg);\n-}\n-\n-/* Report a fatal error STR together with the HSA error corresponding to STATUS\n-   and terminate execution of the current process.  */\n-\n-static void\n-hsa_fatal (const char *str, hsa_status_t status)\n-{\n-  const char *hsa_error_msg = \"[unknown]\";\n-  hsa_fns.hsa_status_string_fn (status, &hsa_error_msg);\n-  GOMP_PLUGIN_fatal (\"HSA fatal error: %s\\nRuntime message: %s\", str,\n-\t\t     hsa_error_msg);\n-}\n-\n-/* Like hsa_fatal, except only report error message, and return FALSE\n-   for propagating error processing to outside of plugin.  */\n-\n-static bool\n-hsa_error (const char *str, hsa_status_t status)\n-{\n-  const char *hsa_error_msg = \"[unknown]\";\n-  hsa_fns.hsa_status_string_fn (status, &hsa_error_msg);\n-  GOMP_PLUGIN_error (\"HSA fatal error: %s\\nRuntime message: %s\", str,\n-\t\t     hsa_error_msg);\n-  return false;\n-}\n-\n-struct hsa_kernel_description\n-{\n-  const char *name;\n-  unsigned omp_data_size;\n-  bool gridified_kernel_p;\n-  unsigned kernel_dependencies_count;\n-  const char **kernel_dependencies;\n-};\n-\n-struct global_var_info\n-{\n-  const char *name;\n-  void *address;\n-};\n-\n-/* Data passed by the static initializer of a compilation unit containing BRIG\n-   to GOMP_offload_register.  */\n-\n-struct brig_image_desc\n-{\n-  hsa_ext_module_t brig_module;\n-  const unsigned kernel_count;\n-  struct hsa_kernel_description *kernel_infos;\n-  const unsigned global_variable_count;\n-  struct global_var_info *global_variables;\n-};\n-\n-struct agent_info;\n-\n-/* Information required to identify, finalize and run any given kernel.  */\n-\n-struct kernel_info\n-{\n-  /* Name of the kernel, required to locate it within the brig module.  */\n-  const char *name;\n-  /* Size of memory space for OMP data.  */\n-  unsigned omp_data_size;\n-  /* The specific agent the kernel has been or will be finalized for and run\n-     on.  */\n-  struct agent_info *agent;\n-  /* The specific module where the kernel takes place.  */\n-  struct module_info *module;\n-  /* Mutex enforcing that at most once thread ever initializes a kernel for\n-     use.  A thread should have locked agent->modules_rwlock for reading before\n-     acquiring it.  */\n-  pthread_mutex_t init_mutex;\n-  /* Flag indicating whether the kernel has been initialized and all fields\n-     below it contain valid data.  */\n-  bool initialized;\n-  /* Flag indicating that the kernel has a problem that blocks an execution.  */\n-  bool initialization_failed;\n-  /* The object to be put into the dispatch queue.  */\n-  uint64_t object;\n-  /* Required size of kernel arguments.  */\n-  uint32_t kernarg_segment_size;\n-  /* Required size of group segment.  */\n-  uint32_t group_segment_size;\n-  /* Required size of private segment.  */\n-  uint32_t private_segment_size;\n-  /* List of all kernel dependencies.  */\n-  const char **dependencies;\n-  /* Number of dependencies.  */\n-  unsigned dependencies_count;\n-  /* Maximum OMP data size necessary for kernel from kernel dispatches.  */\n-  unsigned max_omp_data_size;\n-  /* True if the kernel is gridified.  */\n-  bool gridified_kernel_p;\n-};\n-\n-/* Information about a particular brig module, its image and kernels.  */\n-\n-struct module_info\n-{\n-  /* The next and previous module in the linked list of modules of an agent.  */\n-  struct module_info *next, *prev;\n-  /* The description with which the program has registered the image.  */\n-  struct brig_image_desc *image_desc;\n-\n-  /* Number of kernels in this module.  */\n-  int kernel_count;\n-  /* An array of kernel_info structures describing each kernel in this\n-     module.  */\n-  struct kernel_info kernels[];\n-};\n-\n-/* Information about shared brig library.  */\n-\n-struct brig_library_info\n-{\n-  char *file_name;\n-  hsa_ext_module_t image;\n-};\n-\n-/* Description of an HSA GPU agent and the program associated with it.  */\n-\n-struct agent_info\n-{\n-  /* The HSA ID of the agent.  Assigned when hsa_context is initialized.  */\n-  hsa_agent_t id;\n-  /* Whether the agent has been initialized.  The fields below are usable only\n-     if it has been.  */\n-  bool initialized;\n-  /* The HSA ISA of this agent.  */\n-  hsa_isa_t isa;\n-  /* Command queue of the agent.  */\n-  hsa_queue_t *command_q;\n-  /* Kernel from kernel dispatch command queue.  */\n-  hsa_queue_t *kernel_dispatch_command_q;\n-  /* The HSA memory region from which to allocate kernel arguments.  */\n-  hsa_region_t kernarg_region;\n-\n-  /* Read-write lock that protects kernels which are running or about to be run\n-     from interference with loading and unloading of images.  Needs to be\n-     locked for reading while a kernel is being run, and for writing if the\n-     list of modules is manipulated (and thus the HSA program invalidated).  */\n-  pthread_rwlock_t modules_rwlock;\n-  /* The first module in a linked list of modules associated with this\n-     kernel.  */\n-  struct module_info *first_module;\n-\n-  /* Mutex enforcing that only one thread will finalize the HSA program.  A\n-     thread should have locked agent->modules_rwlock for reading before\n-     acquiring it.  */\n-  pthread_mutex_t prog_mutex;\n-  /* Flag whether the HSA program that consists of all the modules has been\n-     finalized.  */\n-  bool prog_finalized;\n-  /* Flag whether the program was finalized but with a failure.  */\n-  bool prog_finalized_error;\n-  /* HSA executable - the finalized program that is used to locate kernels.  */\n-  hsa_executable_t executable;\n-  /* List of BRIG libraries.  */\n-  struct brig_library_info **brig_libraries;\n-  /* Number of loaded shared BRIG libraries.  */\n-  unsigned brig_libraries_count;\n-};\n-\n-/* Information about the whole HSA environment and all of its agents.  */\n-\n-struct hsa_context_info\n-{\n-  /* Whether the structure has been initialized.  */\n-  bool initialized;\n-  /* Number of usable GPU HSA agents in the system.  */\n-  int agent_count;\n-  /* Array of agent_info structures describing the individual HSA agents.  */\n-  struct agent_info *agents;\n-};\n-\n-/* Information about the whole HSA environment and all of its agents.  */\n-\n-static struct hsa_context_info hsa_context;\n-\n-#define DLSYM_FN(function) \\\n-  hsa_fns.function##_fn = dlsym (handle, #function); \\\n-  if (hsa_fns.function##_fn == NULL) \\\n-    goto dl_fail;\n-\n-static bool\n-init_hsa_runtime_functions (void)\n-{\n-  void *handle = dlopen (hsa_runtime_lib, RTLD_LAZY);\n-  if (handle == NULL)\n-    goto dl_fail;\n-\n-  DLSYM_FN (hsa_status_string)\n-  DLSYM_FN (hsa_agent_get_info)\n-  DLSYM_FN (hsa_init)\n-  DLSYM_FN (hsa_iterate_agents)\n-  DLSYM_FN (hsa_region_get_info)\n-  DLSYM_FN (hsa_queue_create)\n-  DLSYM_FN (hsa_agent_iterate_regions)\n-  DLSYM_FN (hsa_executable_destroy)\n-  DLSYM_FN (hsa_executable_create)\n-  DLSYM_FN (hsa_executable_global_variable_define)\n-  DLSYM_FN (hsa_executable_load_code_object)\n-  DLSYM_FN (hsa_executable_freeze)\n-  DLSYM_FN (hsa_signal_create)\n-  DLSYM_FN (hsa_memory_allocate)\n-  DLSYM_FN (hsa_memory_free)\n-  DLSYM_FN (hsa_signal_destroy)\n-  DLSYM_FN (hsa_executable_get_symbol)\n-  DLSYM_FN (hsa_executable_symbol_get_info)\n-  DLSYM_FN (hsa_queue_add_write_index_release)\n-  DLSYM_FN (hsa_queue_load_read_index_acquire)\n-  DLSYM_FN (hsa_signal_wait_acquire)\n-  DLSYM_FN (hsa_signal_store_relaxed)\n-  DLSYM_FN (hsa_signal_store_release)\n-  DLSYM_FN (hsa_signal_load_acquire)\n-  DLSYM_FN (hsa_queue_destroy)\n-  DLSYM_FN (hsa_ext_program_add_module)\n-  DLSYM_FN (hsa_ext_program_create)\n-  DLSYM_FN (hsa_ext_program_destroy)\n-  DLSYM_FN (hsa_ext_program_finalize)\n-  return true;\n-\n- dl_fail:\n-  HSA_DEBUG (\"while loading %s: %s\\n\", hsa_runtime_lib, dlerror ());\n-  return false;\n-}\n-\n-/* Find kernel for an AGENT by name provided in KERNEL_NAME.  */\n-\n-static struct kernel_info *\n-get_kernel_for_agent (struct agent_info *agent, const char *kernel_name)\n-{\n-  struct module_info *module = agent->first_module;\n-\n-  while (module)\n-    {\n-      for (unsigned i = 0; i < module->kernel_count; i++)\n-\tif (strcmp (module->kernels[i].name, kernel_name) == 0)\n-\t  return &module->kernels[i];\n-\n-      module = module->next;\n-    }\n-\n-  return NULL;\n-}\n-\n-/* Return true if the agent is a GPU and acceptable of concurrent submissions\n-   from different threads.  */\n-\n-static bool\n-suitable_hsa_agent_p (hsa_agent_t agent)\n-{\n-  hsa_device_type_t device_type;\n-  hsa_status_t status\n-    = hsa_fns.hsa_agent_get_info_fn (agent, HSA_AGENT_INFO_DEVICE,\n-\t\t\t\t     &device_type);\n-  if (status != HSA_STATUS_SUCCESS)\n-    return false;\n-\n-  switch (device_type)\n-    {\n-    case HSA_DEVICE_TYPE_GPU:\n-      break;\n-    case HSA_DEVICE_TYPE_CPU:\n-      if (!support_cpu_devices)\n-\treturn false;\n-      break;\n-    default:\n-      return false;\n-    }\n-\n-  uint32_t features = 0;\n-  status = hsa_fns.hsa_agent_get_info_fn (agent, HSA_AGENT_INFO_FEATURE,\n-\t\t\t\t\t  &features);\n-  if (status != HSA_STATUS_SUCCESS\n-      || !(features & HSA_AGENT_FEATURE_KERNEL_DISPATCH))\n-    return false;\n-  hsa_queue_type_t queue_type;\n-  status = hsa_fns.hsa_agent_get_info_fn (agent, HSA_AGENT_INFO_QUEUE_TYPE,\n-\t\t\t\t\t  &queue_type);\n-  if (status != HSA_STATUS_SUCCESS\n-      || (queue_type != HSA_QUEUE_TYPE_MULTI))\n-    return false;\n-\n-  return true;\n-}\n-\n-/* Callback of hsa_iterate_agents, if AGENT is a GPU device, increment\n-   agent_count in hsa_context.  */\n-\n-static hsa_status_t\n-count_gpu_agents (hsa_agent_t agent, void *data __attribute__ ((unused)))\n-{\n-  if (suitable_hsa_agent_p (agent))\n-    hsa_context.agent_count++;\n-  return HSA_STATUS_SUCCESS;\n-}\n-\n-/* Callback of hsa_iterate_agents, if AGENT is a GPU device, assign the agent\n-   id to the describing structure in the hsa context.  The index of the\n-   structure is pointed to by DATA, increment it afterwards.  */\n-\n-static hsa_status_t\n-assign_agent_ids (hsa_agent_t agent, void *data)\n-{\n-  if (suitable_hsa_agent_p (agent))\n-    {\n-      int *agent_index = (int *) data;\n-      hsa_context.agents[*agent_index].id = agent;\n-      ++*agent_index;\n-    }\n-  return HSA_STATUS_SUCCESS;\n-}\n-\n-/* Initialize hsa_context if it has not already been done.\n-   Return TRUE on success.  */\n-\n-static bool\n-init_hsa_context (void)\n-{\n-  hsa_status_t status;\n-  int agent_index = 0;\n-\n-  if (hsa_context.initialized)\n-    return true;\n-  init_enviroment_variables ();\n-  if (!init_hsa_runtime_functions ())\n-    {\n-      HSA_DEBUG (\"Run-time could not be dynamically opened\\n\");\n-      return false;\n-    }\n-  status = hsa_fns.hsa_init_fn ();\n-  if (status != HSA_STATUS_SUCCESS)\n-    return hsa_error (\"Run-time could not be initialized\", status);\n-  HSA_DEBUG (\"HSA run-time initialized\\n\");\n-  status = hsa_fns.hsa_iterate_agents_fn (count_gpu_agents, NULL);\n-  if (status != HSA_STATUS_SUCCESS)\n-    return hsa_error (\"HSA GPU devices could not be enumerated\", status);\n-  HSA_DEBUG (\"There are %i HSA GPU devices.\\n\", hsa_context.agent_count);\n-\n-  hsa_context.agents\n-    = GOMP_PLUGIN_malloc_cleared (hsa_context.agent_count\n-\t\t\t\t  * sizeof (struct agent_info));\n-  status = hsa_fns.hsa_iterate_agents_fn (assign_agent_ids, &agent_index);\n-  if (agent_index != hsa_context.agent_count)\n-    {\n-      GOMP_PLUGIN_error (\"Failed to assign IDs to all HSA agents\");\n-      return false;\n-    }\n-  hsa_context.initialized = true;\n-  return true;\n-}\n-\n-/* Callback of dispatch queues to report errors.  */\n-\n-static void\n-queue_callback (hsa_status_t status,\n-\t\thsa_queue_t *queue __attribute__ ((unused)),\n-\t\tvoid *data __attribute__ ((unused)))\n-{\n-  hsa_fatal (\"Asynchronous queue error\", status);\n-}\n-\n-/* Callback of hsa_agent_iterate_regions.  Determine if a memory REGION can be\n-   used for kernarg allocations and if so write it to the memory pointed to by\n-   DATA and break the query.  */\n-\n-static hsa_status_t\n-get_kernarg_memory_region (hsa_region_t region, void *data)\n-{\n-  hsa_status_t status;\n-  hsa_region_segment_t segment;\n-\n-  status = hsa_fns.hsa_region_get_info_fn (region, HSA_REGION_INFO_SEGMENT,\n-\t\t\t\t\t   &segment);\n-  if (status != HSA_STATUS_SUCCESS)\n-    return status;\n-  if (segment != HSA_REGION_SEGMENT_GLOBAL)\n-    return HSA_STATUS_SUCCESS;\n-\n-  uint32_t flags;\n-  status = hsa_fns.hsa_region_get_info_fn (region, HSA_REGION_INFO_GLOBAL_FLAGS,\n-\t\t\t\t\t   &flags);\n-  if (status != HSA_STATUS_SUCCESS)\n-    return status;\n-  if (flags & HSA_REGION_GLOBAL_FLAG_KERNARG)\n-    {\n-      hsa_region_t *ret = (hsa_region_t *) data;\n-      *ret = region;\n-      return HSA_STATUS_INFO_BREAK;\n-    }\n-  return HSA_STATUS_SUCCESS;\n-}\n-\n-/* Part of the libgomp plugin interface.  Return the number of HSA devices on\n-   the system.  */\n-\n-int\n-GOMP_OFFLOAD_get_num_devices (void)\n-{\n-  if (!init_hsa_context ())\n-    return 0;\n-  return hsa_context.agent_count;\n-}\n-\n-/* Part of the libgomp plugin interface.  Initialize agent number N so that it\n-   can be used for computation.  Return TRUE on success.  */\n-\n-bool\n-GOMP_OFFLOAD_init_device (int n)\n-{\n-  if (!init_hsa_context ())\n-    return false;\n-  if (n >= hsa_context.agent_count)\n-    {\n-      GOMP_PLUGIN_error (\"Request to initialize non-existing HSA device %i\", n);\n-      return false;\n-    }\n-  struct agent_info *agent = &hsa_context.agents[n];\n-\n-  if (agent->initialized)\n-    return true;\n-\n-  if (pthread_rwlock_init (&agent->modules_rwlock, NULL))\n-    {\n-      GOMP_PLUGIN_error (\"Failed to initialize an HSA agent rwlock\");\n-      return false;\n-    }\n-  if (pthread_mutex_init (&agent->prog_mutex, NULL))\n-    {\n-      GOMP_PLUGIN_error (\"Failed to initialize an HSA agent program mutex\");\n-      return false;\n-    }\n-\n-  uint32_t queue_size;\n-  hsa_status_t status;\n-  status = hsa_fns.hsa_agent_get_info_fn (agent->id,\n-\t\t\t\t\t  HSA_AGENT_INFO_QUEUE_MAX_SIZE,\n-\t\t\t\t\t  &queue_size);\n-  if (status != HSA_STATUS_SUCCESS)\n-    return hsa_error (\"Error requesting maximum queue size of the HSA agent\",\n-    \t   \t      status);\n-  status = hsa_fns.hsa_agent_get_info_fn (agent->id, HSA_AGENT_INFO_ISA,\n-\t\t\t\t\t  &agent->isa);\n-  if (status != HSA_STATUS_SUCCESS)\n-    return hsa_error (\"Error querying the ISA of the agent\", status);\n-  status = hsa_fns.hsa_queue_create_fn (agent->id, queue_size,\n-\t\t\t\t\tHSA_QUEUE_TYPE_MULTI,\n-\t\t\t\t\tqueue_callback, NULL, UINT32_MAX,\n-\t\t\t\t\tUINT32_MAX,\n-\t\t\t\t\t&agent->command_q);\n-  if (status != HSA_STATUS_SUCCESS)\n-    return hsa_error (\"Error creating command queue\", status);\n-\n-  status = hsa_fns.hsa_queue_create_fn (agent->id, queue_size,\n-\t\t\t\t\tHSA_QUEUE_TYPE_MULTI,\n-\t\t\t\t\tqueue_callback, NULL, UINT32_MAX,\n-\t\t\t\t\tUINT32_MAX,\n-\t\t\t\t\t&agent->kernel_dispatch_command_q);\n-  if (status != HSA_STATUS_SUCCESS)\n-    return hsa_error (\"Error creating kernel dispatch command queue\", status);\n-\n-  agent->kernarg_region.handle = (uint64_t) -1;\n-  status = hsa_fns.hsa_agent_iterate_regions_fn (agent->id,\n-\t\t\t\t\t\t get_kernarg_memory_region,\n-\t\t\t\t\t\t &agent->kernarg_region);\n-  if (agent->kernarg_region.handle == (uint64_t) -1)\n-    {\n-      GOMP_PLUGIN_error (\"Could not find suitable memory region for kernel \"\n-\t\t\t \"arguments\");\n-      return false;\n-    }\n-  HSA_DEBUG (\"HSA agent initialized, queue has id %llu\\n\",\n-\t     (long long unsigned) agent->command_q->id);\n-  HSA_DEBUG (\"HSA agent initialized, kernel dispatch queue has id %llu\\n\",\n-\t     (long long unsigned) agent->kernel_dispatch_command_q->id);\n-  agent->initialized = true;\n-  return true;\n-}\n-\n-/* Verify that hsa_context has already been initialized and return the\n-   agent_info structure describing device number N.  Return NULL on error.  */\n-\n-static struct agent_info *\n-get_agent_info (int n)\n-{\n-  if (!hsa_context.initialized)\n-    {\n-      GOMP_PLUGIN_error (\"Attempt to use uninitialized HSA context.\");\n-      return NULL;\n-    }\n-  if (n >= hsa_context.agent_count)\n-    {\n-      GOMP_PLUGIN_error (\"Request to operate on anon-existing HSA device %i\", n);\n-      return NULL;\n-    }\n-  if (!hsa_context.agents[n].initialized)\n-    {\n-      GOMP_PLUGIN_error (\"Attempt to use an uninitialized HSA agent.\");\n-      return NULL;\n-    }\n-  return &hsa_context.agents[n];\n-}\n-\n-/* Insert MODULE to the linked list of modules of AGENT.  */\n-\n-static void\n-add_module_to_agent (struct agent_info *agent, struct module_info *module)\n-{\n-  if (agent->first_module)\n-    agent->first_module->prev = module;\n-  module->next = agent->first_module;\n-  module->prev = NULL;\n-  agent->first_module = module;\n-}\n-\n-/* Remove MODULE from the linked list of modules of AGENT.  */\n-\n-static void\n-remove_module_from_agent (struct agent_info *agent, struct module_info *module)\n-{\n-  if (agent->first_module == module)\n-    agent->first_module = module->next;\n-  if (module->prev)\n-    module->prev->next = module->next;\n-  if (module->next)\n-    module->next->prev = module->prev;\n-}\n-\n-/* Free the HSA program in agent and everything associated with it and set\n-   agent->prog_finalized and the initialized flags of all kernels to false.\n-   Return TRUE on success.  */\n-\n-static bool\n-destroy_hsa_program (struct agent_info *agent)\n-{\n-  if (!agent->prog_finalized || agent->prog_finalized_error)\n-    return true;\n-\n-  hsa_status_t status;\n-\n-  HSA_DEBUG (\"Destroying the current HSA program.\\n\");\n-\n-  status = hsa_fns.hsa_executable_destroy_fn (agent->executable);\n-  if (status != HSA_STATUS_SUCCESS)\n-    return hsa_error (\"Could not destroy HSA executable\", status);\n-\n-  struct module_info *module;\n-  for (module = agent->first_module; module; module = module->next)\n-    {\n-      int i;\n-      for (i = 0; i < module->kernel_count; i++)\n-\tmodule->kernels[i].initialized = false;\n-    }\n-  agent->prog_finalized = false;\n-  return true;\n-}\n-\n-/* Initialize KERNEL from D and other parameters.  Return true on success. */\n-\n-static bool\n-init_basic_kernel_info (struct kernel_info *kernel,\n-\t\t\tstruct hsa_kernel_description *d,\n-\t\t\tstruct agent_info *agent,\n-\t\t\tstruct module_info *module)\n-{\n-  kernel->agent = agent;\n-  kernel->module = module;\n-  kernel->name = d->name;\n-  kernel->omp_data_size = d->omp_data_size;\n-  kernel->gridified_kernel_p = d->gridified_kernel_p;\n-  kernel->dependencies_count = d->kernel_dependencies_count;\n-  kernel->dependencies = d->kernel_dependencies;\n-  if (pthread_mutex_init (&kernel->init_mutex, NULL))\n-    {\n-      GOMP_PLUGIN_error (\"Failed to initialize an HSA kernel mutex\");\n-      return false;\n-    }\n-  return true;\n-}\n-\n-/* Part of the libgomp plugin interface.  Load BRIG module described by struct\n-   brig_image_desc in TARGET_DATA and return references to kernel descriptors\n-   in TARGET_TABLE.  */\n-\n-int\n-GOMP_OFFLOAD_load_image (int ord, unsigned version, const void *target_data,\n-\t\t\t struct addr_pair **target_table)\n-{\n-  if (GOMP_VERSION_DEV (version) > GOMP_VERSION_HSA)\n-    {\n-      GOMP_PLUGIN_error (\"Offload data incompatible with HSA plugin\"\n-\t\t\t \" (expected %u, received %u)\",\n-\t\t\t GOMP_VERSION_HSA, GOMP_VERSION_DEV (version));\n-      return -1;\n-    }\n-\n-  struct brig_image_desc *image_desc = (struct brig_image_desc *) target_data;\n-  struct agent_info *agent;\n-  struct addr_pair *pair;\n-  struct module_info *module;\n-  struct kernel_info *kernel;\n-  int kernel_count = image_desc->kernel_count;\n-\n-  agent = get_agent_info (ord);\n-  if (!agent)\n-    return -1;\n-\n-  if (pthread_rwlock_wrlock (&agent->modules_rwlock))\n-    {\n-      GOMP_PLUGIN_error (\"Unable to write-lock an HSA agent rwlock\");\n-      return -1;\n-    }\n-  if (agent->prog_finalized\n-      && !destroy_hsa_program (agent))\n-    return -1;\n-\n-  HSA_DEBUG (\"Encountered %d kernels in an image\\n\", kernel_count);\n-  pair = GOMP_PLUGIN_malloc (kernel_count * sizeof (struct addr_pair));\n-  *target_table = pair;\n-  module = (struct module_info *)\n-    GOMP_PLUGIN_malloc_cleared (sizeof (struct module_info)\n-\t\t\t\t+ kernel_count * sizeof (struct kernel_info));\n-  module->image_desc = image_desc;\n-  module->kernel_count = kernel_count;\n-\n-  kernel = &module->kernels[0];\n-\n-  /* Allocate memory for kernel dependencies.  */\n-  for (unsigned i = 0; i < kernel_count; i++)\n-    {\n-      pair->start = (uintptr_t) kernel;\n-      pair->end = (uintptr_t) (kernel + 1);\n-\n-      struct hsa_kernel_description *d = &image_desc->kernel_infos[i];\n-      if (!init_basic_kernel_info (kernel, d, agent, module))\n-\treturn -1;\n-      kernel++;\n-      pair++;\n-    }\n-\n-  add_module_to_agent (agent, module);\n-  if (pthread_rwlock_unlock (&agent->modules_rwlock))\n-    {\n-      GOMP_PLUGIN_error (\"Unable to unlock an HSA agent rwlock\");\n-      return -1;\n-    }\n-  return kernel_count;\n-}\n-\n-/* Add a shared BRIG library from a FILE_NAME to an AGENT.  */\n-\n-static struct brig_library_info *\n-add_shared_library (const char *file_name, struct agent_info *agent)\n-{\n-  struct brig_library_info *library = NULL;\n-\n-  void *f = dlopen (file_name, RTLD_NOW);\n-  void *start = dlsym (f, \"__brig_start\");\n-  void *end = dlsym (f, \"__brig_end\");\n-\n-  if (start == NULL || end == NULL)\n-    return NULL;\n-\n-  unsigned size = end - start;\n-  char *buf = (char *) GOMP_PLUGIN_malloc (size);\n-  memcpy (buf, start, size);\n-\n-  library = GOMP_PLUGIN_malloc (sizeof (struct agent_info));\n-  library->file_name = (char *) GOMP_PLUGIN_malloc\n-    ((strlen (file_name) + 1));\n-  strcpy (library->file_name, file_name);\n-  library->image = (hsa_ext_module_t) buf;\n-\n-  return library;\n-}\n-\n-/* Release memory used for BRIG shared libraries that correspond\n-   to an AGENT.  */\n-\n-static void\n-release_agent_shared_libraries (struct agent_info *agent)\n-{\n-  for (unsigned i = 0; i < agent->brig_libraries_count; i++)\n-    if (agent->brig_libraries[i])\n-      {\n-\tfree (agent->brig_libraries[i]->file_name);\n-\tfree (agent->brig_libraries[i]->image);\n-\tfree (agent->brig_libraries[i]);\n-      }\n-\n-  free (agent->brig_libraries);\n-}\n-\n-/* Create and finalize the program consisting of all loaded modules.  */\n-\n-static void\n-create_and_finalize_hsa_program (struct agent_info *agent)\n-{\n-  hsa_status_t status;\n-  hsa_ext_program_t prog_handle;\n-  int mi = 0;\n-\n-  if (pthread_mutex_lock (&agent->prog_mutex))\n-    GOMP_PLUGIN_fatal (\"Could not lock an HSA agent program mutex\");\n-  if (agent->prog_finalized)\n-    goto final;\n-\n-  status = hsa_fns.hsa_ext_program_create_fn\n-    (HSA_MACHINE_MODEL_LARGE, HSA_PROFILE_FULL,\n-     HSA_DEFAULT_FLOAT_ROUNDING_MODE_DEFAULT,\n-     NULL, &prog_handle);\n-  if (status != HSA_STATUS_SUCCESS)\n-    hsa_fatal (\"Could not create an HSA program\", status);\n-\n-  HSA_DEBUG (\"Created a finalized program\\n\");\n-\n-  struct module_info *module = agent->first_module;\n-  while (module)\n-    {\n-      status = hsa_fns.hsa_ext_program_add_module_fn\n-\t(prog_handle, module->image_desc->brig_module);\n-      if (status != HSA_STATUS_SUCCESS)\n-\thsa_fatal (\"Could not add a module to the HSA program\", status);\n-      module = module->next;\n-      mi++;\n-    }\n-\n-  /* Load all shared libraries.  */\n-  const char *libraries[] = { \"libhsamath.so\", \"libhsastd.so\" };\n-  const unsigned libraries_count = sizeof (libraries) / sizeof (const char *);\n-\n-  agent->brig_libraries_count = libraries_count;\n-  agent->brig_libraries = GOMP_PLUGIN_malloc_cleared\n-    (sizeof (struct brig_library_info) * libraries_count);\n-\n-  for (unsigned i = 0; i < libraries_count; i++)\n-    {\n-      struct brig_library_info *library = add_shared_library (libraries[i],\n-\t\t\t\t\t\t\t      agent);\n-      if (library == NULL)\n-\t{\n-\t  HSA_WARNING (\"Could not open a shared BRIG library: %s\\n\",\n-\t\t       libraries[i]);\n-\t  continue;\n-\t}\n-\n-      status = hsa_fns.hsa_ext_program_add_module_fn (prog_handle,\n-\t\t\t\t\t\t      library->image);\n-      if (status != HSA_STATUS_SUCCESS)\n-\thsa_warn (\"Could not add a shared BRIG library the HSA program\",\n-\t\t  status);\n-      else\n-\tHSA_DEBUG (\"a shared BRIG library has been added to a program: %s\\n\",\n-\t\t   libraries[i]);\n-    }\n-\n-  hsa_ext_control_directives_t control_directives;\n-  memset (&control_directives, 0, sizeof (control_directives));\n-  hsa_code_object_t code_object;\n-  status = hsa_fns.hsa_ext_program_finalize_fn\n-    (prog_handle, agent->isa,HSA_EXT_FINALIZER_CALL_CONVENTION_AUTO,\n-     control_directives, \"\", HSA_CODE_OBJECT_TYPE_PROGRAM, &code_object);\n-  if (status != HSA_STATUS_SUCCESS)\n-    {\n-      hsa_warn (\"Finalization of the HSA program failed\", status);\n-      goto failure;\n-    }\n-\n-  HSA_DEBUG (\"Finalization done\\n\");\n-  hsa_fns.hsa_ext_program_destroy_fn (prog_handle);\n-\n-  status\n-    = hsa_fns.hsa_executable_create_fn (HSA_PROFILE_FULL,\n-\t\t\t\t\tHSA_EXECUTABLE_STATE_UNFROZEN,\n-\t\t\t\t\t\"\", &agent->executable);\n-  if (status != HSA_STATUS_SUCCESS)\n-    hsa_fatal (\"Could not create HSA executable\", status);\n-\n-  module = agent->first_module;\n-  while (module)\n-    {\n-      /* Initialize all global variables declared in the module.  */\n-      for (unsigned i = 0; i < module->image_desc->global_variable_count; i++)\n-\t{\n-\t  struct global_var_info *var;\n-\t  var = &module->image_desc->global_variables[i];\n-\t  status = hsa_fns.hsa_executable_global_variable_define_fn\n-\t    (agent->executable, var->name, var->address);\n-\n-\t  HSA_DEBUG (\"Defining global variable: %s, address: %p\\n\", var->name,\n-\t\t     var->address);\n-\n-\t  if (status != HSA_STATUS_SUCCESS)\n-\t    hsa_fatal (\"Could not define a global variable in the HSA program\",\n-\t\t       status);\n-\t}\n-\n-      module = module->next;\n-    }\n-\n-  status = hsa_fns.hsa_executable_load_code_object_fn (agent->executable,\n-\t\t\t\t\t\t       agent->id,\n-\t\t\t\t\t\t       code_object, \"\");\n-  if (status != HSA_STATUS_SUCCESS)\n-    hsa_fatal (\"Could not add a code object to the HSA executable\", status);\n-  status = hsa_fns.hsa_executable_freeze_fn (agent->executable, \"\");\n-  if (status != HSA_STATUS_SUCCESS)\n-    hsa_fatal (\"Could not freeze the HSA executable\", status);\n-\n-  HSA_DEBUG (\"Froze HSA executable with the finalized code object\\n\");\n-\n-  /* If all goes good, jump to final.  */\n-  goto final;\n-\n-failure:\n-  agent->prog_finalized_error = true;\n-\n-final:\n-  agent->prog_finalized = true;\n-\n-  if (pthread_mutex_unlock (&agent->prog_mutex))\n-    GOMP_PLUGIN_fatal (\"Could not unlock an HSA agent program mutex\");\n-}\n-\n-/* Create kernel dispatch data structure for given KERNEL.  */\n-\n-static struct GOMP_hsa_kernel_dispatch *\n-create_single_kernel_dispatch (struct kernel_info *kernel,\n-\t\t\t       unsigned omp_data_size)\n-{\n-  struct agent_info *agent = kernel->agent;\n-  struct GOMP_hsa_kernel_dispatch *shadow\n-    = GOMP_PLUGIN_malloc_cleared (sizeof (struct GOMP_hsa_kernel_dispatch));\n-\n-  shadow->queue = agent->command_q;\n-  shadow->omp_data_memory\n-    = omp_data_size > 0 ? GOMP_PLUGIN_malloc (omp_data_size) : NULL;\n-  unsigned dispatch_count = kernel->dependencies_count;\n-  shadow->kernel_dispatch_count = dispatch_count;\n-\n-  shadow->children_dispatches\n-    = GOMP_PLUGIN_malloc (dispatch_count * sizeof (shadow));\n-\n-  shadow->object = kernel->object;\n-\n-  hsa_signal_t sync_signal;\n-  hsa_status_t status = hsa_fns.hsa_signal_create_fn (1, 0, NULL, &sync_signal);\n-  if (status != HSA_STATUS_SUCCESS)\n-    hsa_fatal (\"Error creating the HSA sync signal\", status);\n-\n-  shadow->signal = sync_signal.handle;\n-  shadow->private_segment_size = kernel->private_segment_size;\n-  shadow->group_segment_size = kernel->group_segment_size;\n-\n-  status\n-    = hsa_fns.hsa_memory_allocate_fn (agent->kernarg_region,\n-\t\t\t\t      kernel->kernarg_segment_size,\n-\t\t\t\t      &shadow->kernarg_address);\n-  if (status != HSA_STATUS_SUCCESS)\n-    hsa_fatal (\"Could not allocate memory for HSA kernel arguments\", status);\n-\n-  return shadow;\n-}\n-\n-/* Release data structure created for a kernel dispatch in SHADOW argument.  */\n-\n-static void\n-release_kernel_dispatch (struct GOMP_hsa_kernel_dispatch *shadow)\n-{\n-  HSA_DEBUG (\"Released kernel dispatch: %p has value: %\" PRIu64 \" (%p)\\n\",\n-\t     shadow, (print_uint64_t) shadow->debug,\n-\t     (void *) (uintptr_t) shadow->debug);\n-\n-  hsa_fns.hsa_memory_free_fn (shadow->kernarg_address);\n-\n-  hsa_signal_t s;\n-  s.handle = shadow->signal;\n-  hsa_fns.hsa_signal_destroy_fn (s);\n-\n-  free (shadow->omp_data_memory);\n-\n-  for (unsigned i = 0; i < shadow->kernel_dispatch_count; i++)\n-    release_kernel_dispatch (shadow->children_dispatches[i]);\n-\n-  free (shadow->children_dispatches);\n-  free (shadow);\n-}\n-\n-/* Initialize a KERNEL without its dependencies.  MAX_OMP_DATA_SIZE is used\n-   to calculate maximum necessary memory for OMP data allocation.  */\n-\n-static void\n-init_single_kernel (struct kernel_info *kernel, unsigned *max_omp_data_size)\n-{\n-  hsa_status_t status;\n-  struct agent_info *agent = kernel->agent;\n-  hsa_executable_symbol_t kernel_symbol;\n-  status = hsa_fns.hsa_executable_get_symbol_fn (agent->executable, NULL,\n-\t\t\t\t\t\t kernel->name, agent->id,\n-\t\t\t\t\t\t 0, &kernel_symbol);\n-  if (status != HSA_STATUS_SUCCESS)\n-    {\n-      hsa_warn (\"Could not find symbol for kernel in the code object\", status);\n-      goto failure;\n-    }\n-  HSA_DEBUG (\"Located kernel %s\\n\", kernel->name);\n-  status = hsa_fns.hsa_executable_symbol_get_info_fn\n-    (kernel_symbol, HSA_EXECUTABLE_SYMBOL_INFO_KERNEL_OBJECT, &kernel->object);\n-  if (status != HSA_STATUS_SUCCESS)\n-    hsa_fatal (\"Could not extract a kernel object from its symbol\", status);\n-  status = hsa_fns.hsa_executable_symbol_get_info_fn\n-    (kernel_symbol, HSA_EXECUTABLE_SYMBOL_INFO_KERNEL_KERNARG_SEGMENT_SIZE,\n-     &kernel->kernarg_segment_size);\n-  if (status != HSA_STATUS_SUCCESS)\n-    hsa_fatal (\"Could not get info about kernel argument size\", status);\n-  status = hsa_fns.hsa_executable_symbol_get_info_fn\n-    (kernel_symbol, HSA_EXECUTABLE_SYMBOL_INFO_KERNEL_GROUP_SEGMENT_SIZE,\n-     &kernel->group_segment_size);\n-  if (status != HSA_STATUS_SUCCESS)\n-    hsa_fatal (\"Could not get info about kernel group segment size\", status);\n-  status = hsa_fns.hsa_executable_symbol_get_info_fn\n-    (kernel_symbol, HSA_EXECUTABLE_SYMBOL_INFO_KERNEL_PRIVATE_SEGMENT_SIZE,\n-     &kernel->private_segment_size);\n-  if (status != HSA_STATUS_SUCCESS)\n-    hsa_fatal (\"Could not get info about kernel private segment size\",\n-\t       status);\n-\n-  HSA_DEBUG (\"Kernel structure for %s fully initialized with \"\n-\t     \"following segment sizes: \\n\", kernel->name);\n-  HSA_DEBUG (\"  group_segment_size: %u\\n\",\n-\t     (unsigned) kernel->group_segment_size);\n-  HSA_DEBUG (\"  private_segment_size: %u\\n\",\n-\t     (unsigned) kernel->private_segment_size);\n-  HSA_DEBUG (\"  kernarg_segment_size: %u\\n\",\n-\t     (unsigned) kernel->kernarg_segment_size);\n-  HSA_DEBUG (\"  omp_data_size: %u\\n\", kernel->omp_data_size);\n-  HSA_DEBUG (\"  gridified_kernel_p: %u\\n\", kernel->gridified_kernel_p);\n-\n-  if (kernel->omp_data_size > *max_omp_data_size)\n-    *max_omp_data_size = kernel->omp_data_size;\n-\n-  for (unsigned i = 0; i < kernel->dependencies_count; i++)\n-    {\n-      struct kernel_info *dependency\n-\t= get_kernel_for_agent (agent, kernel->dependencies[i]);\n-\n-      if (dependency == NULL)\n-\t{\n-\t  HSA_DEBUG (\"Could not find a dependency for a kernel: %s, \"\n-\t\t     \"dependency name: %s\\n\", kernel->name,\n-\t\t     kernel->dependencies[i]);\n-\t  goto failure;\n-\t}\n-\n-      if (dependency->dependencies_count > 0)\n-\t{\n-\t  HSA_DEBUG (\"HSA does not allow kernel dispatching code with \"\n-\t\t     \"a depth bigger than one\\n\");\n-\t  goto failure;\n-\t}\n-\n-      init_single_kernel (dependency, max_omp_data_size);\n-    }\n-\n-  return;\n-\n-failure:\n-  kernel->initialization_failed = true;\n-}\n-\n-/* Indent stream F by INDENT spaces.  */\n-\n-static void\n-indent_stream (FILE *f, unsigned indent)\n-{\n-  fprintf (f, \"%*s\", indent, \"\");\n-}\n-\n-/* Dump kernel DISPATCH data structure and indent it by INDENT spaces.  */\n-\n-static void\n-print_kernel_dispatch (struct GOMP_hsa_kernel_dispatch *dispatch, unsigned indent)\n-{\n-  indent_stream (stderr, indent);\n-  fprintf (stderr, \"this: %p\\n\", dispatch);\n-  indent_stream (stderr, indent);\n-  fprintf (stderr, \"queue: %p\\n\", dispatch->queue);\n-  indent_stream (stderr, indent);\n-  fprintf (stderr, \"omp_data_memory: %p\\n\", dispatch->omp_data_memory);\n-  indent_stream (stderr, indent);\n-  fprintf (stderr, \"kernarg_address: %p\\n\", dispatch->kernarg_address);\n-  indent_stream (stderr, indent);\n-  fprintf (stderr, \"object: %\" PRIu64 \"\\n\", (print_uint64_t) dispatch->object);\n-  indent_stream (stderr, indent);\n-  fprintf (stderr, \"signal: %\" PRIu64 \"\\n\", (print_uint64_t) dispatch->signal);\n-  indent_stream (stderr, indent);\n-  fprintf (stderr, \"private_segment_size: %u\\n\",\n-\t   dispatch->private_segment_size);\n-  indent_stream (stderr, indent);\n-  fprintf (stderr, \"group_segment_size: %u\\n\",\n-\t   dispatch->group_segment_size);\n-  indent_stream (stderr, indent);\n-  fprintf (stderr, \"children dispatches: %\" PRIu64 \"\\n\",\n-\t   (print_uint64_t) dispatch->kernel_dispatch_count);\n-  indent_stream (stderr, indent);\n-  fprintf (stderr, \"omp_num_threads: %u\\n\",\n-\t   dispatch->omp_num_threads);\n-  fprintf (stderr, \"\\n\");\n-\n-  for (unsigned i = 0; i < dispatch->kernel_dispatch_count; i++)\n-    print_kernel_dispatch (dispatch->children_dispatches[i], indent + 2);\n-}\n-\n-/* Create kernel dispatch data structure for a KERNEL and all its\n-   dependencies.  */\n-\n-static struct GOMP_hsa_kernel_dispatch *\n-create_kernel_dispatch (struct kernel_info *kernel, unsigned omp_data_size)\n-{\n-  struct GOMP_hsa_kernel_dispatch *shadow\n-    = create_single_kernel_dispatch (kernel, omp_data_size);\n-  shadow->omp_num_threads = 64;\n-  shadow->debug = 0;\n-  shadow->omp_level = kernel->gridified_kernel_p ? 1 : 0;\n-\n-  /* Create kernel dispatch data structures.  We do not allow to have\n-     a kernel dispatch with depth bigger than one.  */\n-  for (unsigned i = 0; i < kernel->dependencies_count; i++)\n-    {\n-      struct kernel_info *dependency\n-\t= get_kernel_for_agent (kernel->agent, kernel->dependencies[i]);\n-      shadow->children_dispatches[i]\n-\t= create_single_kernel_dispatch (dependency, omp_data_size);\n-      shadow->children_dispatches[i]->queue\n-\t= kernel->agent->kernel_dispatch_command_q;\n-      shadow->children_dispatches[i]->omp_level = 1;\n-    }\n-\n-  return shadow;\n-}\n-\n-/* Do all the work that is necessary before running KERNEL for the first time.\n-   The function assumes the program has been created, finalized and frozen by\n-   create_and_finalize_hsa_program.  */\n-\n-static void\n-init_kernel (struct kernel_info *kernel)\n-{\n-  if (pthread_mutex_lock (&kernel->init_mutex))\n-    GOMP_PLUGIN_fatal (\"Could not lock an HSA kernel initialization mutex\");\n-  if (kernel->initialized)\n-    {\n-      if (pthread_mutex_unlock (&kernel->init_mutex))\n-\tGOMP_PLUGIN_fatal (\"Could not unlock an HSA kernel initialization \"\n-\t\t\t   \"mutex\");\n-\n-      return;\n-    }\n-\n-  /* Precomputed maximum size of OMP data necessary for a kernel from kernel\n-     dispatch operation.  */\n-  init_single_kernel (kernel, &kernel->max_omp_data_size);\n-\n-  if (!kernel->initialization_failed)\n-    HSA_DEBUG (\"\\n\");\n-\n-  kernel->initialized = true;\n-  if (pthread_mutex_unlock (&kernel->init_mutex))\n-    GOMP_PLUGIN_fatal (\"Could not unlock an HSA kernel initialization \"\n-\t\t       \"mutex\");\n-}\n-\n-/* Parse the target attributes INPUT provided by the compiler and return true\n-   if we should run anything all.  If INPUT is NULL, fill DEF with default\n-   values, then store INPUT or DEF into *RESULT.  */\n-\n-static bool\n-parse_target_attributes (void **input,\n-\t\t\t struct GOMP_kernel_launch_attributes *def,\n-\t\t\t struct GOMP_kernel_launch_attributes **result)\n-{\n-  if (!input)\n-    GOMP_PLUGIN_fatal (\"No target arguments provided\");\n-\n-  bool attrs_found = false;\n-  while (*input)\n-    {\n-      uintptr_t id = (uintptr_t) *input;\n-      if ((id & GOMP_TARGET_ARG_DEVICE_MASK) == GOMP_DEVICE_HSA\n-\t  && ((id & GOMP_TARGET_ARG_ID_MASK)\n-\t      == GOMP_TARGET_ARG_HSA_KERNEL_ATTRIBUTES))\n-\t{\n-\t  input++;\n-\t  attrs_found = true;\n-\t  break;\n-\t}\n-\n-      if (id & GOMP_TARGET_ARG_SUBSEQUENT_PARAM)\n-\tinput++;\n-      input++;\n-    }\n-\n-  if (!attrs_found)\n-    {\n-      def->ndim = 1;\n-      def->gdims[0] = 1;\n-      def->gdims[1] = 1;\n-      def->gdims[2] = 1;\n-      def->wdims[0] = 1;\n-      def->wdims[1] = 1;\n-      def->wdims[2] = 1;\n-      *result = def;\n-      HSA_DEBUG (\"GOMP_OFFLOAD_run called with no launch attributes\\n\");\n-      return true;\n-    }\n-\n-  struct GOMP_kernel_launch_attributes *kla;\n-  kla = (struct GOMP_kernel_launch_attributes *) *input;\n-  *result = kla;\n-  if (kla->ndim == 0 || kla->ndim > 3)\n-    GOMP_PLUGIN_fatal (\"Invalid number of dimensions (%u)\", kla->ndim);\n-\n-  HSA_DEBUG (\"GOMP_OFFLOAD_run called with %u dimensions:\\n\", kla->ndim);\n-  unsigned i;\n-  for (i = 0; i < kla->ndim; i++)\n-    {\n-      HSA_DEBUG (\"  Dimension %u: grid size %u and group size %u\\n\", i,\n-\t\t kla->gdims[i], kla->wdims[i]);\n-      if (kla->gdims[i] == 0)\n-\treturn false;\n-    }\n-  return true;\n-}\n-\n-/* Return the group size given the requested GROUP size, GRID size and number\n-   of grid dimensions NDIM.  */\n-\n-static uint32_t\n-get_group_size (uint32_t ndim, uint32_t grid, uint32_t group)\n-{\n-  if (group == 0)\n-    {\n-      /* TODO: Provide a default via environment or device characteristics.  */\n-      if (ndim == 1)\n-\tgroup = 64;\n-      else if (ndim == 2)\n-\tgroup = 8;\n-      else\n-\tgroup = 4;\n-    }\n-\n-  if (group > grid)\n-    group = grid;\n-  return group;\n-}\n-\n-/* Return true if the HSA runtime can run function FN_PTR.  */\n-\n-bool\n-GOMP_OFFLOAD_can_run (void *fn_ptr)\n-{\n-  struct kernel_info *kernel = (struct kernel_info *) fn_ptr;\n-  struct agent_info *agent = kernel->agent;\n-  create_and_finalize_hsa_program (agent);\n-\n-  if (agent->prog_finalized_error)\n-    goto failure;\n-\n-  init_kernel (kernel);\n-  if (kernel->initialization_failed)\n-    goto failure;\n-\n-  return true;\n-\n-failure:\n-  if (suppress_host_fallback)\n-    GOMP_PLUGIN_fatal (\"HSA host fallback has been suppressed\");\n-  HSA_DEBUG (\"HSA target cannot be launched, doing a host fallback\\n\");\n-  return false;\n-}\n-\n-/* Atomically store pair of uint16_t values (HEADER and REST) to a PACKET.  */\n-\n-void\n-packet_store_release (uint32_t* packet, uint16_t header, uint16_t rest)\n-{\n-  __atomic_store_n (packet, header | (rest << 16), __ATOMIC_RELEASE);\n-}\n-\n-/* Run KERNEL on its agent, pass VARS to it as arguments and take\n-   launchattributes from KLA.  */\n-\n-void\n-run_kernel (struct kernel_info *kernel, void *vars,\n-\t    struct GOMP_kernel_launch_attributes *kla)\n-{\n-  struct agent_info *agent = kernel->agent;\n-  if (pthread_rwlock_rdlock (&agent->modules_rwlock))\n-    GOMP_PLUGIN_fatal (\"Unable to read-lock an HSA agent rwlock\");\n-\n-  if (!agent->initialized)\n-    GOMP_PLUGIN_fatal (\"Agent must be initialized\");\n-\n-  if (!kernel->initialized)\n-    GOMP_PLUGIN_fatal (\"Called kernel must be initialized\");\n-\n-  struct GOMP_hsa_kernel_dispatch *shadow\n-    = create_kernel_dispatch (kernel, kernel->max_omp_data_size);\n-\n-  if (debug)\n-    {\n-      fprintf (stderr, \"\\nKernel has following dependencies:\\n\");\n-      print_kernel_dispatch (shadow, 2);\n-    }\n-\n-  uint64_t index\n-    = hsa_fns.hsa_queue_add_write_index_release_fn (agent->command_q, 1);\n-  HSA_DEBUG (\"Got AQL index %llu\\n\", (long long int) index);\n-\n-  /* Wait until the queue is not full before writing the packet.   */\n-  while (index - hsa_fns.hsa_queue_load_read_index_acquire_fn (agent->command_q)\n-\t >= agent->command_q->size)\n-    ;\n-\n-  hsa_kernel_dispatch_packet_t *packet;\n-  packet = ((hsa_kernel_dispatch_packet_t *) agent->command_q->base_address)\n-\t   + index % agent->command_q->size;\n-\n-  memset (((uint8_t *) packet) + 4, 0, sizeof (*packet) - 4);\n-  packet->grid_size_x = kla->gdims[0];\n-  packet->workgroup_size_x = get_group_size (kla->ndim, kla->gdims[0],\n-\t\t\t\t\t     kla->wdims[0]);\n-\n-  if (kla->ndim >= 2)\n-    {\n-      packet->grid_size_y = kla->gdims[1];\n-      packet->workgroup_size_y = get_group_size (kla->ndim, kla->gdims[1],\n-\t\t\t\t\t\t kla->wdims[1]);\n-    }\n-  else\n-    {\n-      packet->grid_size_y = 1;\n-      packet->workgroup_size_y = 1;\n-    }\n-\n-  if (kla->ndim == 3)\n-    {\n-      packet->grid_size_z = kla->gdims[2];\n-      packet->workgroup_size_z = get_group_size (kla->ndim, kla->gdims[2],\n-\t\t\t\t\t     kla->wdims[2]);\n-    }\n-  else\n-    {\n-      packet->grid_size_z = 1;\n-      packet->workgroup_size_z = 1;\n-    }\n-\n-  packet->private_segment_size = kernel->private_segment_size;\n-  packet->group_segment_size = kernel->group_segment_size;\n-  packet->kernel_object = kernel->object;\n-  packet->kernarg_address = shadow->kernarg_address;\n-  hsa_signal_t s;\n-  s.handle = shadow->signal;\n-  packet->completion_signal = s;\n-  hsa_fns.hsa_signal_store_relaxed_fn (s, 1);\n-  memcpy (shadow->kernarg_address, &vars, sizeof (vars));\n-\n-  /* PR hsa/70337.  */\n-  size_t vars_size = sizeof (vars);\n-  if (kernel->kernarg_segment_size > vars_size)\n-    {\n-      if (kernel->kernarg_segment_size != vars_size\n-\t  + sizeof (struct hsa_kernel_runtime *))\n-\tGOMP_PLUGIN_fatal (\"Kernel segment size has an unexpected value\");\n-      memcpy (packet->kernarg_address + vars_size, &shadow,\n-\t      sizeof (struct hsa_kernel_runtime *));\n-    }\n-\n-  HSA_DEBUG (\"Copying kernel runtime pointer to kernarg_address\\n\");\n-\n-  uint16_t header;\n-  header = HSA_PACKET_TYPE_KERNEL_DISPATCH << HSA_PACKET_HEADER_TYPE;\n-  header |= HSA_FENCE_SCOPE_SYSTEM << HSA_PACKET_HEADER_ACQUIRE_FENCE_SCOPE;\n-  header |= HSA_FENCE_SCOPE_SYSTEM << HSA_PACKET_HEADER_RELEASE_FENCE_SCOPE;\n-\n-  HSA_DEBUG (\"Going to dispatch kernel %s\\n\", kernel->name);\n-\n-  packet_store_release ((uint32_t *) packet, header,\n-\t\t\t(uint16_t) kla->ndim << HSA_KERNEL_DISPATCH_PACKET_SETUP_DIMENSIONS);\n-\n-  hsa_fns.hsa_signal_store_release_fn (agent->command_q->doorbell_signal,\n-\t\t\t\t       index);\n-\n-  /* TODO: GPU agents in Carrizo APUs cannot properly update L2 cache for\n-     signal wait and signal load operations on their own and we need to\n-     periodically call the hsa_signal_load_acquire on completion signals of\n-     children kernels in the CPU to make that happen.  As soon the\n-     limitation will be resolved, this workaround can be removed.  */\n-\n-  HSA_DEBUG (\"Kernel dispatched, waiting for completion\\n\");\n-\n-  /* Root signal waits with 1ms timeout.  */\n-  while (hsa_fns.hsa_signal_wait_acquire_fn (s, HSA_SIGNAL_CONDITION_LT, 1,\n-\t\t\t\t\t     1000 * 1000,\n-\t\t\t\t\t     HSA_WAIT_STATE_BLOCKED) != 0)\n-    for (unsigned i = 0; i < shadow->kernel_dispatch_count; i++)\n-      {\n-\thsa_signal_t child_s;\n-\tchild_s.handle = shadow->children_dispatches[i]->signal;\n-\n-\tHSA_DEBUG (\"Waiting for children completion signal: %\" PRIu64 \"\\n\",\n-\t\t   (print_uint64_t) shadow->children_dispatches[i]->signal);\n-\thsa_fns.hsa_signal_load_acquire_fn (child_s);\n-      }\n-\n-  release_kernel_dispatch (shadow);\n-\n-  if (pthread_rwlock_unlock (&agent->modules_rwlock))\n-    GOMP_PLUGIN_fatal (\"Unable to unlock an HSA agent rwlock\");\n-}\n-\n-/* Part of the libgomp plugin interface.  Run a kernel on device N (the number\n-   is actually ignored, we assume the FN_PTR has been mapped using the correct\n-   device) and pass it an array of pointers in VARS as a parameter.  The kernel\n-   is identified by FN_PTR which must point to a kernel_info structure.  */\n-\n-void\n-GOMP_OFFLOAD_run (int n __attribute__((unused)),\n-\t\t  void *fn_ptr, void *vars, void **args)\n-{\n-  struct kernel_info *kernel = (struct kernel_info *) fn_ptr;\n-  struct GOMP_kernel_launch_attributes def;\n-  struct GOMP_kernel_launch_attributes *kla;\n-  if (!parse_target_attributes (args, &def, &kla))\n-    {\n-      HSA_DEBUG (\"Will not run HSA kernel because the grid size is zero\\n\");\n-      return;\n-    }\n-  run_kernel (kernel, vars, kla);\n-}\n-\n-/* Information to be passed to a thread running a kernel asycnronously.  */\n-\n-struct async_run_info\n-{\n-  int device;\n-  void *tgt_fn;\n-  void *tgt_vars;\n-  void **args;\n-  void *async_data;\n-};\n-\n-/* Thread routine to run a kernel asynchronously.  */\n-\n-static void *\n-run_kernel_asynchronously (void *thread_arg)\n-{\n-  struct async_run_info *info = (struct async_run_info *) thread_arg;\n-  int device = info->device;\n-  void *tgt_fn = info->tgt_fn;\n-  void *tgt_vars = info->tgt_vars;\n-  void **args = info->args;\n-  void *async_data = info->async_data;\n-\n-  free (info);\n-  GOMP_OFFLOAD_run (device, tgt_fn, tgt_vars, args);\n-  GOMP_PLUGIN_target_task_completion (async_data);\n-  return NULL;\n-}\n-\n-/* Part of the libgomp plugin interface.  Run a kernel like GOMP_OFFLOAD_run\n-   does, but asynchronously and call GOMP_PLUGIN_target_task_completion when it\n-   has finished.  */\n-\n-void\n-GOMP_OFFLOAD_async_run (int device, void *tgt_fn, void *tgt_vars,\n-\t\t\tvoid **args, void *async_data)\n-{\n-  pthread_t pt;\n-  struct async_run_info *info;\n-  HSA_DEBUG (\"GOMP_OFFLOAD_async_run invoked\\n\");\n-  info = GOMP_PLUGIN_malloc (sizeof (struct async_run_info));\n-\n-  info->device = device;\n-  info->tgt_fn = tgt_fn;\n-  info->tgt_vars = tgt_vars;\n-  info->args = args;\n-  info->async_data = async_data;\n-\n-  int err = pthread_create (&pt, NULL, &run_kernel_asynchronously, info);\n-  if (err != 0)\n-    GOMP_PLUGIN_fatal (\"HSA asynchronous thread creation failed: %s\",\n-\t\t       strerror (err));\n-  err = pthread_detach (pt);\n-  if (err != 0)\n-    GOMP_PLUGIN_fatal (\"Failed to detach a thread to run HSA kernel \"\n-\t\t       \"asynchronously: %s\", strerror (err));\n-}\n-\n-/* Deinitialize all information associated with MODULE and kernels within\n-   it.  Return TRUE on success.  */\n-\n-static bool\n-destroy_module (struct module_info *module)\n-{\n-  int i;\n-  for (i = 0; i < module->kernel_count; i++)\n-    if (pthread_mutex_destroy (&module->kernels[i].init_mutex))\n-      {\n-\tGOMP_PLUGIN_error (\"Failed to destroy an HSA kernel initialization \"\n-\t\t\t   \"mutex\");\n-\treturn false;\n-      }\n-  return true;\n-}\n-\n-/* Part of the libgomp plugin interface.  Unload BRIG module described by\n-   struct brig_image_desc in TARGET_DATA from agent number N.  Return\n-   TRUE on success.  */\n-\n-bool\n-GOMP_OFFLOAD_unload_image (int n, unsigned version, const void *target_data)\n-{\n-  if (GOMP_VERSION_DEV (version) > GOMP_VERSION_HSA)\n-    {\n-      GOMP_PLUGIN_error (\"Offload data incompatible with HSA plugin\"\n-\t\t\t \" (expected %u, received %u)\",\n-\t\t\t GOMP_VERSION_HSA, GOMP_VERSION_DEV (version));\n-      return false;\n-    }\n-\n-  struct agent_info *agent;\n-  agent = get_agent_info (n);\n-  if (!agent)\n-    return false;\n-\n-  if (pthread_rwlock_wrlock (&agent->modules_rwlock))\n-    {\n-      GOMP_PLUGIN_error (\"Unable to write-lock an HSA agent rwlock\");\n-      return false;\n-    }\n-  struct module_info *module = agent->first_module;\n-  while (module)\n-    {\n-      if (module->image_desc == target_data)\n-\tbreak;\n-      module = module->next;\n-    }\n-  if (!module)\n-    {\n-      GOMP_PLUGIN_error (\"Attempt to unload an image that has never been \"\n-\t\t\t \"loaded before\");\n-      return false;\n-    }\n-\n-  remove_module_from_agent (agent, module);\n-  if (!destroy_module (module))\n-    return false;\n-  free (module);\n-  if (!destroy_hsa_program (agent))\n-    return false;\n-  if (pthread_rwlock_unlock (&agent->modules_rwlock))\n-    {\n-      GOMP_PLUGIN_error (\"Unable to unlock an HSA agent rwlock\");\n-      return false;\n-    }\n-  return true;\n-}\n-\n-/* Part of the libgomp plugin interface.  Deinitialize all information and\n-   status associated with agent number N.  We do not attempt any\n-   synchronization, assuming the user and libgomp will not attempt\n-   deinitialization of a device that is in any way being used at the same\n-   time.  Return TRUE on success.  */\n-\n-bool\n-GOMP_OFFLOAD_fini_device (int n)\n-{\n-  struct agent_info *agent = get_agent_info (n);\n-  if (!agent)\n-    return false;\n-\n-  if (!agent->initialized)\n-    return true;\n-\n-  struct module_info *next_module = agent->first_module;\n-  while (next_module)\n-    {\n-      struct module_info *module = next_module;\n-      next_module = module->next;\n-      if (!destroy_module (module))\n-\treturn false;\n-      free (module);\n-    }\n-  agent->first_module = NULL;\n-  if (!destroy_hsa_program (agent))\n-    return false;\n-\n-  release_agent_shared_libraries (agent);\n-\n-  hsa_status_t status = hsa_fns.hsa_queue_destroy_fn (agent->command_q);\n-  if (status != HSA_STATUS_SUCCESS)\n-    return hsa_error (\"Error destroying command queue\", status);\n-  status = hsa_fns.hsa_queue_destroy_fn (agent->kernel_dispatch_command_q);\n-  if (status != HSA_STATUS_SUCCESS)\n-    return hsa_error (\"Error destroying kernel dispatch command queue\", status);\n-  if (pthread_mutex_destroy (&agent->prog_mutex))\n-    {\n-      GOMP_PLUGIN_error (\"Failed to destroy an HSA agent program mutex\");\n-      return false;\n-    }\n-  if (pthread_rwlock_destroy (&agent->modules_rwlock))\n-    {\n-      GOMP_PLUGIN_error (\"Failed to destroy an HSA agent rwlock\");\n-      return false;\n-    }\n-  agent->initialized = false;\n-  return true;\n-}\n-\n-/* Part of the libgomp plugin interface.  Not implemented as it is not required\n-   for HSA.  */\n-\n-void *\n-GOMP_OFFLOAD_alloc (int ord, size_t size)\n-{\n-  GOMP_PLUGIN_error (\"HSA GOMP_OFFLOAD_alloc is not implemented because \"\n-\t\t     \"it should never be called\");\n-  return NULL;\n-}\n-\n-/* Part of the libgomp plugin interface.  Not implemented as it is not required\n-   for HSA.  */\n-\n-bool\n-GOMP_OFFLOAD_free (int ord, void *ptr)\n-{\n-  GOMP_PLUGIN_error (\"HSA GOMP_OFFLOAD_free is not implemented because \"\n-\t\t     \"it should never be called\");\n-  return false;\n-}\n-\n-/* Part of the libgomp plugin interface.  Not implemented as it is not required\n-   for HSA.  */\n-\n-bool\n-GOMP_OFFLOAD_dev2host (int ord, void *dst, const void *src, size_t n)\n-{\n-  GOMP_PLUGIN_error (\"HSA GOMP_OFFLOAD_dev2host is not implemented because \"\n-\t\t     \"it should never be called\");\n-  return false;\n-}\n-\n-/* Part of the libgomp plugin interface.  Not implemented as it is not required\n-   for HSA.  */\n-\n-bool\n-GOMP_OFFLOAD_host2dev (int ord, void *dst, const void *src, size_t n)\n-{\n-  GOMP_PLUGIN_error (\"HSA GOMP_OFFLOAD_host2dev is not implemented because \"\n-\t\t     \"it should never be called\");\n-  return false;\n-}\n-\n-/* Part of the libgomp plugin interface.  Not implemented as it is not required\n-   for HSA.  */\n-\n-bool\n-GOMP_OFFLOAD_dev2dev (int ord, void *dst, const void *src, size_t n)\n-{\n-  GOMP_PLUGIN_error (\"HSA GOMP_OFFLOAD_dev2dev is not implemented because \"\n-\t\t     \"it should never be called\");\n-  return false;\n-}"}, {"sha": "26e925b4d34de85659cde726bbeb5b8a9c80ba50", "filename": "libgomp/testsuite/Makefile.in", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c56684fd61223abd45854270cd1e83ab2f07148c/libgomp%2Ftestsuite%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c56684fd61223abd45854270cd1e83ab2f07148c/libgomp%2Ftestsuite%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2FMakefile.in?ref=c56684fd61223abd45854270cd1e83ab2f07148c", "patch": "@@ -1,7 +1,7 @@\n-# Makefile.in generated by automake 1.15.1 from Makefile.am.\n+# Makefile.in generated by automake 1.16.1 from Makefile.am.\n # @configure_input@\n \n-# Copyright (C) 1994-2017 Free Software Foundation, Inc.\n+# Copyright (C) 1994-2018 Free Software Foundation, Inc.\n \n # This Makefile.in is free software; the Free Software Foundation\n # gives unlimited permission to copy and/or distribute it,\n@@ -215,10 +215,6 @@ PLUGIN_GCN = @PLUGIN_GCN@\n PLUGIN_GCN_CPPFLAGS = @PLUGIN_GCN_CPPFLAGS@\n PLUGIN_GCN_LDFLAGS = @PLUGIN_GCN_LDFLAGS@\n PLUGIN_GCN_LIBS = @PLUGIN_GCN_LIBS@\n-PLUGIN_HSA = @PLUGIN_HSA@\n-PLUGIN_HSA_CPPFLAGS = @PLUGIN_HSA_CPPFLAGS@\n-PLUGIN_HSA_LDFLAGS = @PLUGIN_HSA_LDFLAGS@\n-PLUGIN_HSA_LIBS = @PLUGIN_HSA_LIBS@\n PLUGIN_NVPTX = @PLUGIN_NVPTX@\n PLUGIN_NVPTX_CPPFLAGS = @PLUGIN_NVPTX_CPPFLAGS@\n PLUGIN_NVPTX_LDFLAGS = @PLUGIN_NVPTX_LDFLAGS@\n@@ -335,8 +331,8 @@ Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status\n \t  *config.status*) \\\n \t    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \\\n \t  *) \\\n-\t    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \\\n-\t    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \\\n+\t    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__maybe_remake_depfiles)'; \\\n+\t    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__maybe_remake_depfiles);; \\\n \tesac;\n \n $(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)"}, {"sha": "5d86e2ac095fc8fa426ff28ecb8ee851e5e5b598", "filename": "libgomp/testsuite/lib/libgomp.exp", "status": "modified", "additions": 0, "deletions": 60, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c56684fd61223abd45854270cd1e83ab2f07148c/libgomp%2Ftestsuite%2Flib%2Flibgomp.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c56684fd61223abd45854270cd1e83ab2f07148c/libgomp%2Ftestsuite%2Flib%2Flibgomp.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flib%2Flibgomp.exp?ref=c56684fd61223abd45854270cd1e83ab2f07148c", "patch": "@@ -233,9 +233,6 @@ proc libgomp_init { args } {\n     # Disable caret\n     lappend ALWAYS_CFLAGS \"additional_flags=-fno-diagnostics-show-caret\"\n \n-    # Disable HSA warnings by default.\n-    lappend ALWAYS_CFLAGS \"additional_flags=-Wno-hsa\"\n-\n     # Disable color diagnostics\n     lappend ALWAYS_CFLAGS \"additional_flags=-fdiagnostics-color=never\"\n \n@@ -325,9 +322,6 @@ proc offload_target_to_openacc_device_type { offload_target } {\n \tdisable {\n \t    return \"host\"\n \t}\n-\thsa* {\n-\t    return \"\"\n-\t}\n \t*-intelmic* {\n \t    return \"\"\n \t}\n@@ -430,60 +424,6 @@ proc check_effective_target_openacc_host_selected { } {\n     return [string match \"host\" $openacc_device_type]\n }\n \n-# Return 1 if the selected OMP device is actually a HSA device\n-\n-proc check_effective_target_hsa_offloading_selected_nocache {} {\n-    global tool\n-\n-    set src {\n-\tint main () {\n-\t    int v = 1;\n-\t    #pragma omp target map(from:v)\n-\t    v = 0;\n-\t    return v;\n-\t}\n-    }\n-    \n-    set result [check_compile hsa_offloading_src executable $src]\n-    set lines [lindex $result 0]\n-    set exe [lindex $result 1]\n-\n-    set ok 0\n-    if { [string match \"\" $lines] } {\n-\t# No error messages, let us switch on HSA debugging output and run it\n-\tset prev_HSA_DEBUG [getenv HSA_DEBUG]\n-\tsetenv HSA_DEBUG \"1\"\n-\tset result [remote_load target \"./$exe\"]\n-\tif { [string match \"\" $prev_HSA_DEBUG] } {\n-\t    unsetenv HSA_DEBUG\n-\t} else {\n-\t    setenv HSA_DEBUG $prev_HSA_DEBUG\n-\t}\n-\tset status [lindex $result 0]\n-\tif { $status != \"pass\" } {\n-\t    remote_file build delete $exe\n-\t    verbose \"HSA availability test failed\"\n-\t    return 0\n-\t}\n-\tset output [lindex $result 1]\n-\tif { [string match \"*HSA debug: Going to dispatch kernel*\" $output] } {\n-\t    verbose \"HSA availability detected\"\n-\t    set ok 1\n-\t}\n-    }\n-    remote_file build delete $exe\n-    return $ok\n-}\n-\n-# Return 1 if the selected OMP device is actually a HSA device and\n-# cache the result\n-\n-proc check_effective_target_hsa_offloading_selected {} {\n-    return [check_cached_effective_target hsa_offloading_selected {\n-\tcheck_effective_target_hsa_offloading_selected_nocache\n-    }]\n-}\n-\n # Return 1 if at least one AMD GPU is accessible.\n \n proc check_effective_target_openacc_radeon_accel_present { } {"}, {"sha": "48dca94a47f55b412f1e0c9aa26bfb22ed2e46b8", "filename": "libgomp/testsuite/libgomp.hsa.c/alloca-1.c", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9623f61b142174b87760c81f78928dd14af7cbc6/libgomp%2Ftestsuite%2Flibgomp.hsa.c%2Falloca-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9623f61b142174b87760c81f78928dd14af7cbc6/libgomp%2Ftestsuite%2Flibgomp.hsa.c%2Falloca-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.hsa.c%2Falloca-1.c?ref=9623f61b142174b87760c81f78928dd14af7cbc6", "patch": "@@ -1,25 +0,0 @@\n-#define size 10\n-int i, j, k;\n-\n-int\n-main ()\n-{\n-  char *s = __builtin_malloc (size + 1);\n-\n-#pragma omp target teams\n-  {\n-#pragma omp distribute parallel for default(none) private(i) shared(s)\n-    for (i = 0; i < size; ++i)\n-      {\n-\tchar *buffer = __builtin_alloca (10);\n-\tbuffer[5] = 97 + i;\n-\ts[i] = buffer[5];\n-      }\n-  }\n-\n-  for (i = 0; i < size; ++i)\n-    if (s[i] != 97 + i)\n-      __builtin_abort ();\n-\n-  return 0;\n-}"}, {"sha": "4dbf34817333eb3955afba92423f3359a768603b", "filename": "libgomp/testsuite/libgomp.hsa.c/bitfield-1.c", "status": "removed", "additions": 0, "deletions": 160, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9623f61b142174b87760c81f78928dd14af7cbc6/libgomp%2Ftestsuite%2Flibgomp.hsa.c%2Fbitfield-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9623f61b142174b87760c81f78928dd14af7cbc6/libgomp%2Ftestsuite%2Flibgomp.hsa.c%2Fbitfield-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.hsa.c%2Fbitfield-1.c?ref=9623f61b142174b87760c81f78928dd14af7cbc6", "patch": "@@ -1,160 +0,0 @@\n-#include <assert.h>\n-\n-#define ASSIGN_SX(N)                                                           \\\n-  s##N.a1 = 1;                                                                 \\\n-  s##N.a2 = 2;                                                                 \\\n-  s##N.a3 = 3;                                                                 \\\n-  s##N.a4 = 4;                                                                 \\\n-  s##N.a5 = 5;                                                                 \\\n-  s##N.a6 = 6;                                                                 \\\n-  s##N.a7 = 7;                                                                 \\\n-  s##N.a8 = 8;                                                                 \\\n-  s##N.a9 = 9;                                                                 \\\n-  s##N.a10 = 10;\n-\n-#define ASSERT_SX(N)                                                           \\\n-  assert (s##N.a1 == 1); \\\n-  assert (s##N.a2 == 2); \\\n-  assert (s##N.a3 == 3); \\\n-  assert (s##N.a4 == 4); \\\n-  assert (s##N.a5 == 5); \\\n-  assert (s##N.a6 == 6); \\\n-  assert (s##N.a7 == 7); \\\n-  assert (s##N.a8 == 8); \\\n-  assert (s##N.a9 == 9); \\\n-  assert (s##N.a10 == 10);\n-\n-struct S1\n-{\n-  unsigned a : 10;\n-  unsigned b : 20;\n-};\n-\n-struct S2\n-{\n-  unsigned a1 : 10;\n-  unsigned a2 : 10;\n-  unsigned a3 : 10;\n-  unsigned a4 : 10;\n-  unsigned a5 : 10;\n-  unsigned a6 : 10;\n-  unsigned a7 : 10;\n-  unsigned a8 : 10;\n-  unsigned a9 : 10;\n-  unsigned a10 : 10;\n-};\n-\n-struct S3\n-{\n-  unsigned a1 : 10;\n-  unsigned a2 : 9;\n-  unsigned a3 : 8;\n-  unsigned a4 : 7;\n-  unsigned a5 : 6;\n-  unsigned a6 : 5;\n-  unsigned a7 : 6;\n-  unsigned a8 : 7;\n-  unsigned a9 : 8;\n-  unsigned a10 : 9;\n-};\n-\n-struct S4\n-{\n-  unsigned a1 : 10;\n-  int a2 : 9;\n-  unsigned a3 : 8;\n-  int a4 : 7;\n-  unsigned a5 : 6;\n-  int a6 : 5;\n-  unsigned a7 : 6;\n-  int a8 : 7;\n-  unsigned a9 : 8;\n-  int a10 : 9;\n-};\n-\n-struct S5\n-{\n-  unsigned a1 : 31;\n-  int a2 : 9;\n-  unsigned a3 : 17;\n-  int a4 : 7;\n-  unsigned a5 : 6;\n-  int a6 : 5;\n-  unsigned long a7 : 55;\n-  int a8 : 7;\n-  unsigned a9 : 8;\n-  int a10 : 9;\n-};\n-\n-int\n-main ()\n-{\n-  struct S1 s1;\n-\n-#pragma omp target map(to: s1)\n-  {\n-    s1.a = 2;\n-    s1.b = 3;\n-  }\n-\n-  assert (s1.a == 2);\n-  assert (s1.b == 3);\n-\n-  struct S2 s2;\n-\n-#pragma omp target map(to: s2)\n-  {\n-    ASSIGN_SX (2)\n-  }\n-\n-  ASSERT_SX (2)\n-\n-  struct S3 s3;\n-\n-#pragma omp target map(to: s3)\n-  {\n-    ASSIGN_SX (3)\n-  }\n-\n-  ASSERT_SX (3)\n-\n-  struct S4 s4;\n-\n-#pragma omp target map(to: s4)\n-  {\n-    ASSIGN_SX (4)\n-  }\n-\n-  ASSERT_SX (4)\n-\n-  struct S4 s5;\n-\n-  s5.a1 = 0;\n-  s5.a2 = 1;\n-  s5.a3 = 2;\n-  s5.a4 = 3;\n-  s5.a5 = 4;\n-  s5.a6 = 5;\n-  s5.a7 = 6;\n-  s5.a8 = 7;\n-  s5.a9 = 8;\n-  s5.a10 = 9;\n-\n-#pragma omp target map(to: s5)\n-  {\n-    s5.a1++;\n-    s5.a2++;\n-    s5.a3++;\n-    s5.a4++;\n-    s5.a5++;\n-    s5.a6++;\n-    s5.a7++;\n-    s5.a8++;\n-    s5.a9++;\n-    s5.a10++;\n-  }\n-\n-  ASSERT_SX (5)\n-\n-  return 0;\n-}"}, {"sha": "21cac72dac42d50592cf4d5fafe81f51d936051c", "filename": "libgomp/testsuite/libgomp.hsa.c/bits-insns.c", "status": "removed", "additions": 0, "deletions": 73, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9623f61b142174b87760c81f78928dd14af7cbc6/libgomp%2Ftestsuite%2Flibgomp.hsa.c%2Fbits-insns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9623f61b142174b87760c81f78928dd14af7cbc6/libgomp%2Ftestsuite%2Flibgomp.hsa.c%2Fbits-insns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.hsa.c%2Fbits-insns.c?ref=9623f61b142174b87760c81f78928dd14af7cbc6", "patch": "@@ -1,73 +0,0 @@\n-#include <math.h>\n-\n-#define N 12\n-\n-int main()\n-{\n-  unsigned int arguments[N] = {0u, 1u, 2u, 3u, 111u, 333u, 444u, 0x80000000u, 0x0000ffffu, 0xf0000000u, 0xff000000u, 0xffffffffu};\n-  int clrsb[N] = {};\n-  int clz[N] = {};\n-  int ctz[N] = {};\n-  int ffs[N] = {};\n-  int parity[N] = {};\n-  int popcount[N] = {};\n-\n-  int ref_clrsb[N] = {};\n-  int ref_clz[N] = {};\n-  int ref_ctz[N] = {};\n-  int ref_ffs[N] = {};\n-  int ref_parity[N] = {};\n-  int ref_popcount[N] = {};\n-\n-  for (unsigned i = 0; i < N; i++)\n-    {\n-      ref_clrsb[i] = __builtin_clrsb (arguments[i]);\n-      ref_clz[i] = __builtin_clz (arguments[i]);\n-      ref_ctz[i] = __builtin_ctz (arguments[i]);\n-      ref_ffs[i] = __builtin_ffs (arguments[i]);\n-      ref_parity[i] = __builtin_parity (arguments[i]);\n-      ref_popcount[i] = __builtin_popcount (arguments[i]);\n-    }\n-\n-  #pragma omp target map(from:clz, ctz, ffs, parity, popcount)\n-  {\n-    for (unsigned i = 0; i < N; i++)\n-    {\n-      clrsb[i] = __builtin_clrsb (arguments[i]);\n-      clz[i] = __builtin_clz (arguments[i]);\n-      ctz[i] = __builtin_ctz (arguments[i]);\n-      ffs[i] = __builtin_ffs (arguments[i]);\n-      parity[i] = __builtin_parity (arguments[i]);\n-      popcount[i] = __builtin_popcount (arguments[i]);\n-    }\n-  }\n-\n-  for (unsigned i = 0; i < N; i++)\n-    if (ref_clrsb[i] != clrsb[i])\n-      __builtin_abort ();\n-\n-  /* CLZ of zero is undefined for zero.  */\n-  for (unsigned i = 1; i < N; i++)\n-    if (ref_clz[i] != clz[i])\n-      __builtin_abort ();\n-\n-  /* Likewise for ctz */\n-  for (unsigned i = 1; i < N; i++)\n-    if (ref_ctz[i] != ctz[i])\n-      __builtin_abort ();\n-\n-  for (unsigned i = 0; i < N; i++)\n-    if (ref_ffs[i] != ffs[i])\n-      __builtin_abort ();\n-\n-  for (unsigned i = 0; i < N; i++)\n-    if (ref_parity[i] != parity[i])\n-      __builtin_abort ();\n-\n-  for (unsigned i = 0; i < N; i++)\n-    if (ref_popcount[i] != popcount[i])\n-      __builtin_abort ();\n-\n-  return 0;\n-}\n-"}, {"sha": "e603c21afcd28503ee83a34754a6a49c107b5724", "filename": "libgomp/testsuite/libgomp.hsa.c/builtins-1.c", "status": "removed", "additions": 0, "deletions": 97, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9623f61b142174b87760c81f78928dd14af7cbc6/libgomp%2Ftestsuite%2Flibgomp.hsa.c%2Fbuiltins-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9623f61b142174b87760c81f78928dd14af7cbc6/libgomp%2Ftestsuite%2Flibgomp.hsa.c%2Fbuiltins-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.hsa.c%2Fbuiltins-1.c?ref=9623f61b142174b87760c81f78928dd14af7cbc6", "patch": "@@ -1,97 +0,0 @@\n-/* { dg-additional-options \"-ffast-math\" } */\n-\n-#include <assert.h>\n-#include <math.h>\n-\n-#define N 10\n-#define N2 14\n-\n-#define c1 1.2345f\n-#define c2 1.2345\n-\n-#define DELTA 0.001\n-\n-#define TEST_BIT_BUILTINS(T, S, S2)                                            \\\n-  {                                                                            \\\n-    T arguments[N2]                                                            \\\n-      = {0##S,\t\t1##S,\t  2##S,\t  3##S,                    \\\n-\t 111##S,\t333##S,\t444##S,\t0x80000000##S,           \\\n-\t 0x0000ffff##S, 0xf0000000##S, 0xff000000##S, 0xffffffff##S};          \\\n-    int clrsb[N2] = {};                                                        \\\n-    int clz[N2] = {};                                                          \\\n-    int ctz[N2] = {};                                                          \\\n-    int ffs[N2] = {};                                                          \\\n-    int parity[N2] = {};                                                       \\\n-    int popcount[N2] = {};                                                     \\\n-                                                                               \\\n-    _Pragma (\"omp target map(to:clz[:N2], ctz[:N2], ffs[:N2], parity[:N2], popcount[:N2])\")                                                 \\\n-    {                                                                          \\\n-      for (unsigned i = 0; i < N2; i++)                                        \\\n-\t{                                                                      \\\n-\t  clrsb[i] = __builtin_clrsb##S2 (arguments[i]);                       \\\n-\t  clz[i] = __builtin_clz##S2 (arguments[i]);                           \\\n-\t  ctz[i] = __builtin_ctz##S2 (arguments[i]);                           \\\n-\t  ffs[i] = __builtin_ffs##S2 (arguments[i]);                           \\\n-\t  parity[i] = __builtin_parity##S2 (arguments[i]);                     \\\n-\t  popcount[i] = __builtin_popcount##S2 (arguments[i]);                 \\\n-\t}                                                                      \\\n-    }                                                                          \\\n-                                                                               \\\n-    for (unsigned i = 0; i < N2; i++)                                          \\\n-      {                                                                        \\\n-\tassert (clrsb[i] == __builtin_clrsb##S2 (arguments[i]));               \\\n-\tif (arguments[0] != 0)                                                 \\\n-\t  {                                                                    \\\n-\t    assert (clz[i] == __builtin_clz##S2 (arguments[i]));               \\\n-\t    assert (ctz[i] == __builtin_ctz##S2 (arguments[i]));               \\\n-\t  }                                                                    \\\n-\tassert (ffs[i] == __builtin_ffs##S2 (arguments[i]));                   \\\n-\tassert (parity[i] == __builtin_parity##S2 (arguments[i]));             \\\n-\tassert (popcount[i] == __builtin_popcount##S2 (arguments[i]));         \\\n-      }                                                                        \\\n-  }\n-\n-#define ASSERT(v1, v2) assert (fabs (v1 - v2) < DELTA)\n-\n-int\n-main ()\n-{\n-  float f[N] = {};\n-  float d[N] = {};\n-\n-/* 1) test direct mapping to HSA insns.  */\n-\n-#pragma omp target map(to: f[ : N], d[ : N])\n-  {\n-    f[0] = sinf (c1);\n-    f[1] = cosf (c1);\n-    f[2] = exp2f (c1);\n-    f[3] = log2f (c1);\n-    f[4] = truncf (c1);\n-    f[5] = sqrtf (c1);\n-\n-    d[0] = trunc (c2);\n-    d[1] = sqrt (c2);\n-  }\n-\n-  ASSERT (f[0], sinf (c1));\n-  ASSERT (f[1], cosf (c1));\n-  ASSERT (f[2], exp2f (c1));\n-  ASSERT (f[3], log2f (c1));\n-  ASSERT (f[4], truncf (c1));\n-  ASSERT (f[5], sqrtf (c1));\n-\n-  ASSERT (d[0], trunc (c2));\n-  ASSERT (d[1], sqrt (c2));\n-\n-  /* 2) test bit builtins for unsigned int.  */\n-  TEST_BIT_BUILTINS (int, , );\n-\n-  /* 3) test bit builtins for unsigned long int.  */\n-  TEST_BIT_BUILTINS (long, l, l);\n-\n-  /* 4) test bit builtins for unsigned long long int.  */\n-  TEST_BIT_BUILTINS (long long, ll, ll);\n-\n-  return 0;\n-}"}, {"sha": "4614192320adb6236abbb3d9269537e6e3fde1a7", "filename": "libgomp/testsuite/libgomp.hsa.c/c.exp", "status": "removed", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9623f61b142174b87760c81f78928dd14af7cbc6/libgomp%2Ftestsuite%2Flibgomp.hsa.c%2Fc.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9623f61b142174b87760c81f78928dd14af7cbc6/libgomp%2Ftestsuite%2Flibgomp.hsa.c%2Fc.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.hsa.c%2Fc.exp?ref=9623f61b142174b87760c81f78928dd14af7cbc6", "patch": "@@ -1,42 +0,0 @@\n-if [info exists lang_library_path] then {\n-    unset lang_library_path\n-    unset lang_link_flags\n-}\n-if [info exists lang_test_file] then {\n-    unset lang_test_file\n-}\n-if [info exists lang_include_flags] then {\n-    unset lang_include_flags\n-}\n-\n-load_lib libgomp-dg.exp\n-load_gcc_lib gcc-dg.exp\n-\n-# Initialize dg.\n-dg-init\n-\n-# Turn on OpenMP.\n-lappend ALWAYS_CFLAGS \"additional_flags=-fopenmp\"\n-\n-set ld_library_path $always_ld_library_path\n-append ld_library_path [gcc-set-multilib-library-path $GCC_UNDER_TEST]\n-set_ld_library_path_env_vars\n-\n-global DEFAULT_CFLAGS\n-if [info exists DEFAULT_CFLAGS] then {\n-    set CFLAGS_list [list \"-O0\" $DEFAULT_CFLAGS]\n-} else {\n-    set CFLAGS_list [list \"-O0\" \"-O2\"]\n-}\n-\n-if [check_effective_target_hsa_offloading_selected] {\n-    foreach USE_CFLAGS $CFLAGS_list {\n-\t# Gather a list of all tests.\n-\tset tests [lsort [find $srcdir/$subdir *.c]]\n-\t# Main loop.\n-\tdg-runtest $tests \"\" [concat $USE_CFLAGS \"-Whsa\"]\n-    }\n-}\n-\n-# All done.\n-dg-finish"}, {"sha": "438c64a1593cd2f4c47b70d18ebe837a25bf056c", "filename": "libgomp/testsuite/libgomp.hsa.c/complex-1.c", "status": "removed", "additions": 0, "deletions": 65, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9623f61b142174b87760c81f78928dd14af7cbc6/libgomp%2Ftestsuite%2Flibgomp.hsa.c%2Fcomplex-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9623f61b142174b87760c81f78928dd14af7cbc6/libgomp%2Ftestsuite%2Flibgomp.hsa.c%2Fcomplex-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.hsa.c%2Fcomplex-1.c?ref=9623f61b142174b87760c81f78928dd14af7cbc6", "patch": "@@ -1,65 +0,0 @@\n-#include <assert.h>\n-#include <complex.h>\n-#include <math.h>\n-\n-#define uchar unsigned char\n-#define C 123\n-\n-#define TEST(type)                                                             \\\n-  type foo_##type (void)                                                       \\\n-  {                                                                            \\\n-    _Complex type a = C + 45I;                                                 \\\n-    return __real__ a;                                                         \\\n-  }\n-\n-#pragma omp declare target\n-TEST (char)\n-TEST (uchar)\n-TEST (short)\n-TEST (int)\n-\n-float\n-bar (float a, float b)\n-{\n-  _Complex float c = a + b * I;\n-\n-  c += 11.f + 12.f * I;\n-\n-  _Complex float d = 2.f + 4.44f * I;\n-\n-  return __real__(crealf (c + d) + cimag (d) * I);\n-}\n-\n-#pragma omp end declare target\n-\n-int\n-main (void)\n-{\n-  int v = 0;\n-  float v2 = 0.0f;\n-\n-#pragma omp target map(to: v)\n-  v = foo_char ();\n-\n-  assert (v == C);\n-\n-#pragma omp target map(to: v)\n-  v = foo_uchar ();\n-\n-  assert (v == C);\n-\n-#pragma omp target map(to: v)\n-  v = foo_short ();\n-\n-  assert (v == C);\n-\n-#pragma omp target map(to: v)\n-  v = foo_int ();\n-\n-  assert (v == C);\n-\n-#pragma omp target map(to: v2)\n-  v2 = bar (1.12f, 4.44f);\n-\n-  assert (fabs (v2 - 14.12) < 0.0001f);\n-}"}, {"sha": "b2d7acff443ca34c80f1a53a52f6a5d91278aa8d", "filename": "libgomp/testsuite/libgomp.hsa.c/complex-align-2.c", "status": "removed", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9623f61b142174b87760c81f78928dd14af7cbc6/libgomp%2Ftestsuite%2Flibgomp.hsa.c%2Fcomplex-align-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9623f61b142174b87760c81f78928dd14af7cbc6/libgomp%2Ftestsuite%2Flibgomp.hsa.c%2Fcomplex-align-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.hsa.c%2Fcomplex-align-2.c?ref=9623f61b142174b87760c81f78928dd14af7cbc6", "patch": "@@ -1,27 +0,0 @@\n-#pragma omp declare target\n-    _Complex int *g;\n-#pragma omp end declare target\n-\n-\n-\n-_Complex float f(void);\n-\n-int\n-main ()\n-{\n-  _Complex int y;\n-#pragma omp target map(from:y)\n-  {\n-    _Complex int x;\n-    g = &x;\n-    __imag__ x = 1;\n-    __real__ x = 2;\n-    y = x;\n-  }\n-\n-  if ((__imag__ y != 1)\n-      || (__real__ y != 2))\n-    __builtin_abort ();\n-  return 0;\n-}\n-"}, {"sha": "058a036d371658dd371a16f210d6716ddb70e199", "filename": "libgomp/testsuite/libgomp.hsa.c/formal-actual-args-1.c", "status": "removed", "additions": 0, "deletions": 83, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9623f61b142174b87760c81f78928dd14af7cbc6/libgomp%2Ftestsuite%2Flibgomp.hsa.c%2Fformal-actual-args-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9623f61b142174b87760c81f78928dd14af7cbc6/libgomp%2Ftestsuite%2Flibgomp.hsa.c%2Fformal-actual-args-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.hsa.c%2Fformal-actual-args-1.c?ref=9623f61b142174b87760c81f78928dd14af7cbc6", "patch": "@@ -1,83 +0,0 @@\n-#include <assert.h>\n-\n-struct Cube\n-{\n-  int x;\n-  int y;\n-  int z;\n-};\n-\n-#pragma omp declare target\n-int\n-foo (short a)\n-{\n-  switch (a)\n-    {\n-    case 1:\n-      return 11;\n-      break;\n-    case 33:\n-      return 333;\n-      break;\n-    case 55:\n-      return 55;\n-      break;\n-    default:\n-      return -1;\n-    }\n-}\n-\n-int\n-bar (int a)\n-{\n-  int *ptr = &a;\n-\n-  *ptr = 100;\n-  return a + *ptr;\n-}\n-\n-struct Cube\n-baz (struct Cube c)\n-{\n-  c.x = 11;\n-  return c;\n-}\n-\n-#pragma omp end declare target\n-\n-#define s 100\n-\n-int\n-main (int argc)\n-{\n-  /* Test 1: argument types: char to short.  */\n-\n-  int array[s];\n-#pragma omp target map(tofrom : array[ : s])\n-  {\n-    for (char i = 0; i < s; i++)\n-      array[i] = foo (i);\n-  }\n-\n-  for (int i = 0; i < s; i++)\n-    assert (array[i] == foo (i));\n-\n-  /* Test 2: argument address is taken.  */\n-  int v = 2;\n-\n-#pragma omp target map(tofrom : v)\n-  v = bar (v);\n-\n-  assert (v == 200);\n-\n-  /* Test 3: passing a structure as a function argument.  */\n-  struct Cube r;\n-  struct Cube c = {.x = 1, .y = 2, .z = 3};\n-\n-#pragma omp target map(to : r) map(from : c)\n-  r = baz (c);\n-\n-  assert (r.x == 11);\n-  assert (r.y == c.y);\n-  assert (r.z == c.z);\n-}"}, {"sha": "7f15dff96b99240d8a3ee390834fd667005b0bb0", "filename": "libgomp/testsuite/libgomp.hsa.c/function-call-1.c", "status": "removed", "additions": 0, "deletions": 50, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9623f61b142174b87760c81f78928dd14af7cbc6/libgomp%2Ftestsuite%2Flibgomp.hsa.c%2Ffunction-call-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9623f61b142174b87760c81f78928dd14af7cbc6/libgomp%2Ftestsuite%2Flibgomp.hsa.c%2Ffunction-call-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.hsa.c%2Ffunction-call-1.c?ref=9623f61b142174b87760c81f78928dd14af7cbc6", "patch": "@@ -1,50 +0,0 @@\n-#define size 8\n-\n-#pragma omp declare target\n-int\n-identity (int x)\n-{\n-  return x;\n-}\n-\n-int\n-expx (int x, int n)\n-{\n-  for (int i = 0; i < n - 1; i++)\n-    x *= x;\n-\n-  return x;\n-}\n-\n-float\n-init (int x, int y)\n-{\n-  int x1 = identity (identity (identity (identity (x))));\n-  int y1 = identity (identity (identity (identity (y))));\n-\n-  int x2 = expx (x1, 2);\n-  int y2 = expx (y1, 2);\n-\n-  return (x2 + y2);\n-}\n-#pragma omp end declare target\n-\n-int\n-main ()\n-{\n-  int i, j;\n-  int a[size][size];\n-\n-#pragma omp target teams map(to:a[:size][:size])\n-#pragma omp distribute parallel for default(none) private(i, j) shared(a)\n-  for (i = 0; i < size; ++i)\n-    for (j = 0; j < size; ++j)\n-      a[i][j] = init (i, j);\n-\n-  for (i = 0; i < size; ++i)\n-    for (j = 0; j < size; ++j)\n-      if (i * i + j * j != a[i][j])\n-       __builtin_abort ();\n-\n-  return 0;\n-}"}, {"sha": "81c9df002761ef1bbf3163de4e80bc57f3065a81", "filename": "libgomp/testsuite/libgomp.hsa.c/get-level-1.c", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9623f61b142174b87760c81f78928dd14af7cbc6/libgomp%2Ftestsuite%2Flibgomp.hsa.c%2Fget-level-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9623f61b142174b87760c81f78928dd14af7cbc6/libgomp%2Ftestsuite%2Flibgomp.hsa.c%2Fget-level-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.hsa.c%2Fget-level-1.c?ref=9623f61b142174b87760c81f78928dd14af7cbc6", "patch": "@@ -1,26 +0,0 @@\n-#include <omp.h>\n-\n-int\n-main ()\n-{\n-  int i;\n-  int level = -1;\n-\n-#pragma omp target map(tofrom : level)\n-  {\n-    level = omp_get_level ();\n-  }\n-\n-  if (level != 0)\n-    __builtin_abort ();\n-\n-#pragma omp target teams map(tofrom : level)\n-#pragma omp distribute parallel for default(none) private(i) shared(level)\n-  for (i = 0; i < 1; ++i)\n-    level += omp_get_level ();\n-\n-  if (level != 1)\n-    __builtin_abort ();\n-\n-  return 0;\n-}"}, {"sha": "b670b9b654cc4a38f46951705b9483f11ed9ee60", "filename": "libgomp/testsuite/libgomp.hsa.c/gridify-1.c", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9623f61b142174b87760c81f78928dd14af7cbc6/libgomp%2Ftestsuite%2Flibgomp.hsa.c%2Fgridify-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9623f61b142174b87760c81f78928dd14af7cbc6/libgomp%2Ftestsuite%2Flibgomp.hsa.c%2Fgridify-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.hsa.c%2Fgridify-1.c?ref=9623f61b142174b87760c81f78928dd14af7cbc6", "patch": "@@ -1,26 +0,0 @@\n-void __attribute__((noinline, noclone))\n-foo (int n, int *a, int workgroup_size)\n-{\n-  int i;\n-#pragma omp target\n-#pragma omp teams thread_limit(workgroup_size)\n-#pragma omp distribute parallel for shared(a) firstprivate(n) private(i)\n-    for (i = 0; i < n; i++)\n-      a[i]++;\n-}\n-\n-int main (int argc, char **argv)\n-{\n-  int n = 32;\n-  int *a = __builtin_malloc (sizeof (int) * n);\n-  int i;\n-\n-  __builtin_memset (a, 0, sizeof (int) * n);\n-  foo (n, a, 32);\n-  for (i = 0; i < n; i ++)\n-    {\n-      if (a[i] != 1)\n-\t__builtin_abort ();\n-    }\n-  return 0;\n-}"}, {"sha": "3692eb0d11cc69bf380fc44f68bfa76705fa6b59", "filename": "libgomp/testsuite/libgomp.hsa.c/gridify-2.c", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9623f61b142174b87760c81f78928dd14af7cbc6/libgomp%2Ftestsuite%2Flibgomp.hsa.c%2Fgridify-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9623f61b142174b87760c81f78928dd14af7cbc6/libgomp%2Ftestsuite%2Flibgomp.hsa.c%2Fgridify-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.hsa.c%2Fgridify-2.c?ref=9623f61b142174b87760c81f78928dd14af7cbc6", "patch": "@@ -1,26 +0,0 @@\n-void __attribute__((noinline, noclone))\n-foo (int j, int n, int *a)\n-{\n-  int i;\n-#pragma omp target\n-#pragma omp teams\n-#pragma omp distribute parallel for shared(a) firstprivate(n) private(i) firstprivate(j)\n-    for (i = j + 1; i < n; i++)\n-      a[i] = i;\n-}\n-\n-int main (int argc, char **argv)\n-{\n-  int n = 32;\n-  int *a = __builtin_malloc (sizeof (int) * n);\n-  int i, j = 4;\n-\n-  __builtin_memset (a, 0, sizeof (int) * n);\n-  foo (j, n, a);\n-  for (i = j + 1; i < n; i ++)\n-    {\n-      if (a[i] != i)\n-\t__builtin_abort ();\n-    }\n-  return 0;\n-}"}, {"sha": "f881d81e18ef8e0fc73530bf99360b74dae33ae4", "filename": "libgomp/testsuite/libgomp.hsa.c/gridify-3.c", "status": "removed", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9623f61b142174b87760c81f78928dd14af7cbc6/libgomp%2Ftestsuite%2Flibgomp.hsa.c%2Fgridify-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9623f61b142174b87760c81f78928dd14af7cbc6/libgomp%2Ftestsuite%2Flibgomp.hsa.c%2Fgridify-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.hsa.c%2Fgridify-3.c?ref=9623f61b142174b87760c81f78928dd14af7cbc6", "patch": "@@ -1,39 +0,0 @@\n-#define THE_LOOP \\\n-  for (i = j + 1; i < n; i += 3) \\\n-    a[i] = i\n-\n-void __attribute__((noinline, noclone))\n-foo (int j, int n, int *a)\n-{\n-  int i;\n-#pragma omp target\n-#pragma omp teams\n-#pragma omp distribute parallel for shared(a) firstprivate(n) private(i) firstprivate(j)\n-  THE_LOOP;\n-}\n-\n-void __attribute__((noinline, noclone))\n-bar (int j, int n, int *a)\n-{\n-  int i;\n-  THE_LOOP;\n-}\n-\n-int main (int argc, char **argv)\n-{\n-  int n = 32;\n-  int *a = __builtin_malloc (sizeof (int) * n);\n-  int *ref = __builtin_malloc (sizeof (int) * n);\n-  int i, j = 4;\n-\n-  __builtin_memset (a, 0, sizeof (int) * n);\n-  __builtin_memset (ref, 0, sizeof (int) * n);\n-  bar (j, n, ref);\n-  foo (j, n, a);\n-  for (i = 0; i < n; i ++)\n-    {\n-      if (a[i] != ref[i])\n-\t__builtin_abort ();\n-    }\n-  return 0;\n-}"}, {"sha": "c3fbdbf55d4afa6eaa3b031adc567d86f9feb28d", "filename": "libgomp/testsuite/libgomp.hsa.c/gridify-4.c", "status": "removed", "additions": 0, "deletions": 45, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9623f61b142174b87760c81f78928dd14af7cbc6/libgomp%2Ftestsuite%2Flibgomp.hsa.c%2Fgridify-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9623f61b142174b87760c81f78928dd14af7cbc6/libgomp%2Ftestsuite%2Flibgomp.hsa.c%2Fgridify-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.hsa.c%2Fgridify-4.c?ref=9623f61b142174b87760c81f78928dd14af7cbc6", "patch": "@@ -1,45 +0,0 @@\n-#define THE_LOOP \\\n-  for (i = j + 1; i < n; i += 3) \\\n-    a[i] = i\n-\n-void __attribute__((noinline, noclone))\n-foo (int j, int n, int *a)\n-{\n-#pragma omp parallel\n-  {\n-    #pragma omp single\n-    {\n-      int i;\n-#pragma omp target\n-#pragma omp teams\n-#pragma omp distribute parallel for shared(a) firstprivate(n) private(i) firstprivate(j)\n-      THE_LOOP;\n-    }\n-  }\n-}\n-\n-void __attribute__((noinline, noclone))\n-bar (int j, int n, int *a)\n-{\n-  int i;\n-  THE_LOOP;\n-}\n-\n-int main (int argc, char **argv)\n-{\n-  int n = 32;\n-  int *a = __builtin_malloc (sizeof (int) * n);\n-  int *ref = __builtin_malloc (sizeof (int) * n);\n-  int i, j = 4;\n-\n-  __builtin_memset (a, 0, sizeof (int) * n);\n-  __builtin_memset (ref, 0, sizeof (int) * n);\n-  bar (j, n, ref);\n-  foo (j, n, a);\n-  for (i = 0; i < n; i ++)\n-    {\n-      if (a[i] != ref[i])\n-\t__builtin_abort ();\n-    }\n-  return 0;\n-}"}, {"sha": "a17be932111a74d459015d85da5a358a0d645245", "filename": "libgomp/testsuite/libgomp.hsa.c/memory-operations-1.c", "status": "removed", "additions": 0, "deletions": 92, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9623f61b142174b87760c81f78928dd14af7cbc6/libgomp%2Ftestsuite%2Flibgomp.hsa.c%2Fmemory-operations-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9623f61b142174b87760c81f78928dd14af7cbc6/libgomp%2Ftestsuite%2Flibgomp.hsa.c%2Fmemory-operations-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.hsa.c%2Fmemory-operations-1.c?ref=9623f61b142174b87760c81f78928dd14af7cbc6", "patch": "@@ -1,92 +0,0 @@\n-#include <assert.h>\n-\n-#define C 55\n-\n-int i, j, k;\n-\n-static void\n-test_bzero (unsigned size)\n-{\n-  unsigned bsize = size * sizeof (int);\n-  int *x = __builtin_malloc (bsize);\n-  __builtin_memset (x, C, bsize);\n-\n-#pragma omp target map(tofrom: x[:size]) map(from: bsize)\n-  {\n-    __builtin_bzero (x, bsize);\n-  }\n-\n-  char *buffer = (char *) x;\n-  for (unsigned i = 0; i < bsize; ++i)\n-    assert (buffer[i] == 0);\n-}\n-\n-static void\n-test_memcpy (unsigned size)\n-{\n-  unsigned bsize = size * sizeof (int);\n-  int *x = __builtin_malloc (bsize);\n-  __builtin_memset (x, C, bsize);\n-  int *y = __builtin_malloc (bsize);\n-\n-#pragma omp target map(tofrom: x[:size], y[:size]) map(from: bsize)\n-  {\n-    __builtin_memcpy (y, x, bsize);\n-  }\n-\n-  char *buffer = (char *) y;\n-  for (unsigned i = 0; i < bsize; ++i)\n-    assert (buffer[i] == C);\n-}\n-\n-static void\n-test_mempcpy (unsigned size)\n-{\n-  unsigned bsize = size * sizeof (int);\n-  int *x = __builtin_malloc (bsize);\n-  __builtin_memset (x, C, bsize);\n-  int *y = __builtin_malloc (bsize);\n-  int *ptr = 0;\n-\n-#pragma omp target map(tofrom :x[:size], y[:size], ptr) map(from: bsize)\n-  {\n-    ptr = __builtin_mempcpy (y, x, bsize);\n-  }\n-\n-  char *buffer = (char *) y;\n-  for (unsigned i = 0; i < bsize; ++i)\n-    assert (buffer[i] == C);\n-\n-  assert (ptr == y + size);\n-}\n-\n-static void\n-test_memset (unsigned size)\n-{\n-  unsigned bsize = size * sizeof (int);\n-  int *x = __builtin_malloc (bsize);\n-  __builtin_bzero (x, bsize);\n-\n-#pragma omp target map(tofrom : x[:size]) map(from: bsize)\n-  {\n-    __builtin_memset (x, C, bsize);\n-  }\n-\n-  char *buffer = (char *) x;\n-  for (unsigned i = 0; i < bsize; ++i)\n-    assert (buffer[i] == C);\n-}\n-\n-int\n-main (void)\n-{\n-  unsigned tests[] = {1, 2, 3, 4, 5, 8, 15, 17, 23, 33, 0};\n-\n-  for (unsigned i = 0; tests[i]; i++)\n-    {\n-      test_bzero (tests[i]);\n-      test_memset (tests[i]);\n-      test_memcpy (tests[i]);\n-      test_mempcpy (tests[i]);\n-    }\n-}"}, {"sha": "6262eee3e7108c5c0cea4fdfb35970d6a7fef1cb", "filename": "libgomp/testsuite/libgomp.hsa.c/pr69568.c", "status": "removed", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9623f61b142174b87760c81f78928dd14af7cbc6/libgomp%2Ftestsuite%2Flibgomp.hsa.c%2Fpr69568.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9623f61b142174b87760c81f78928dd14af7cbc6/libgomp%2Ftestsuite%2Flibgomp.hsa.c%2Fpr69568.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.hsa.c%2Fpr69568.c?ref=9623f61b142174b87760c81f78928dd14af7cbc6", "patch": "@@ -1,41 +0,0 @@\n-/* PR hsa/69568 */\n-\n-typedef float float2 __attribute__ ((vector_size (8)));\n-float2 *output;\n-\n-void __attribute__((noinline, noclone))\n-foo (int n, float2 *a, int workgroup_size)\n-{\n-  int i;\n-#pragma omp target map(from:a[:n]) firstprivate(n, workgroup_size)\n-#pragma omp teams thread_limit(workgroup_size)\n-#pragma omp distribute parallel for shared(a) firstprivate(n) private(i)\n-    for (i = 0; i < n; i++)\n-      { float2 v;\n-\tv[0] = i;\n-\tv[1] = 1+i;\n-\ta[i] = v;\n-      }\n-}\n-\n-int main (int argc, char **argv)\n-{\n-  int n = 32;\n-  float2 *a = __builtin_malloc (sizeof (float2) * n);\n-  int i;\n-\n-  __builtin_memset (a, 0, sizeof (float2) * n);\n-  foo (n, a, 32);\n-  for (i = 0; i < n; i++)\n-    {\n-      float2 v = a[i];\n-      if (__builtin_abs (v[0] - i) > 0.1\n-\t  || __builtin_abs (v[1] - i - 1) > 0.1)\n-\t{\n-\t  __builtin_abort ();\n-\t  return 1;\n-\t}\n-    }\n-  return 0;\n-}\n-"}, {"sha": "40378ab12a5d762d4c022328b1461dafa2fd75a3", "filename": "libgomp/testsuite/libgomp.hsa.c/pr82416.c", "status": "removed", "additions": 0, "deletions": 43, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9623f61b142174b87760c81f78928dd14af7cbc6/libgomp%2Ftestsuite%2Flibgomp.hsa.c%2Fpr82416.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9623f61b142174b87760c81f78928dd14af7cbc6/libgomp%2Ftestsuite%2Flibgomp.hsa.c%2Fpr82416.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.hsa.c%2Fpr82416.c?ref=9623f61b142174b87760c81f78928dd14af7cbc6", "patch": "@@ -1,43 +0,0 @@\n-char __attribute__ ((noipa))\n-toup (char X)\n-{\n-  if (X >= 97 && X <= 122)\n-    return X - 32;\n-  else\n-    return X;\n-}\n-\n-char\n-target_toup_1 (char X)\n-{\n-  char r;\n-#pragma omp target map(to:X) map(from:r)\n-  {\n-    if (X >= 97 && X <= 122)\n-      r = X - 32;\n-    else\n-      r = X;\n-  }\n-  return r;\n-}\n-\n-char __attribute__ ((noipa))\n-target_toup (char X)\n-{\n-  return target_toup_1 (X);\n-}\n-\n-int main (int argc, char **argv)\n-{\n-  char a = 'a';\n-  if (toup (a) != target_toup (a))\n-    __builtin_abort ();\n-  a = 'Z';\n-  if (toup (a) != target_toup (a))\n-    __builtin_abort ();\n-  a = 5;\n-  if (toup (a) != target_toup (a))\n-    __builtin_abort ();\n-\n-  return 0;\n-}"}, {"sha": "494388bd10c27763f08ee3b88957cf25bcc42c45", "filename": "libgomp/testsuite/libgomp.hsa.c/rotate-1.c", "status": "removed", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9623f61b142174b87760c81f78928dd14af7cbc6/libgomp%2Ftestsuite%2Flibgomp.hsa.c%2Frotate-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9623f61b142174b87760c81f78928dd14af7cbc6/libgomp%2Ftestsuite%2Flibgomp.hsa.c%2Frotate-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.hsa.c%2Frotate-1.c?ref=9623f61b142174b87760c81f78928dd14af7cbc6", "patch": "@@ -1,39 +0,0 @@\n-#include <assert.h>\n-#include <limits.h>\n-\n-#define T unsigned int\n-#define BITSIZE CHAR_BIT * sizeof (T)\n-\n-#define C1 123u\n-\n-#pragma omp declare target\n-T\n-rotate (T value, T shift)\n-{\n-  T r = (value << shift) | (value >> (BITSIZE - shift));\n-  return (r >> shift) | (r << (BITSIZE - shift));\n-}\n-#pragma omp end declare target\n-\n-int\n-main (int argc)\n-{\n-  T v1, v2, v3, v4, v5;\n-\n-#pragma omp target map(to: v1, v2, v3, v4, v5)\n-  {\n-    v1 = rotate (C1, 10);\n-    v2 = rotate (C1, 2);\n-    v3 = rotate (C1, 5);\n-    v4 = rotate (C1, 16);\n-    v5 = rotate (C1, 32);\n-  }\n-\n-  assert (v1 == C1);\n-  assert (v2 == C1);\n-  assert (v3 == C1);\n-  assert (v4 == C1);\n-  assert (v5 == C1);\n-\n-  return 0;\n-}"}, {"sha": "6d20c9aa32872401cfd2a2307e278c93924b5a82", "filename": "libgomp/testsuite/libgomp.hsa.c/staticvar.c", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9623f61b142174b87760c81f78928dd14af7cbc6/libgomp%2Ftestsuite%2Flibgomp.hsa.c%2Fstaticvar.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9623f61b142174b87760c81f78928dd14af7cbc6/libgomp%2Ftestsuite%2Flibgomp.hsa.c%2Fstaticvar.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.hsa.c%2Fstaticvar.c?ref=9623f61b142174b87760c81f78928dd14af7cbc6", "patch": "@@ -1,23 +0,0 @@\n-extern void abort (void);\n-\n-#pragma omp declare target\n-int\n-foo (void)\n-{\n-  static int s;\n-  return ++s;\n-}\n-#pragma omp end declare target\n-\n-int\n-main ()\n-{\n-  int r;\n-  #pragma omp target map(from:r)\n-  {\n-    r = foo ();\n-  }\n-  if (r != 1)\n-    abort ();\n-  return 0;\n-}"}, {"sha": "a180cf6cb7bcadae5d029b7f7d0f34b0ed1a10e7", "filename": "libgomp/testsuite/libgomp.hsa.c/switch-1.c", "status": "removed", "additions": 0, "deletions": 145, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9623f61b142174b87760c81f78928dd14af7cbc6/libgomp%2Ftestsuite%2Flibgomp.hsa.c%2Fswitch-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9623f61b142174b87760c81f78928dd14af7cbc6/libgomp%2Ftestsuite%2Flibgomp.hsa.c%2Fswitch-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.hsa.c%2Fswitch-1.c?ref=9623f61b142174b87760c81f78928dd14af7cbc6", "patch": "@@ -1,145 +0,0 @@\n-#include <assert.h>\n-\n-#define s 100\n-\n-#pragma omp declare target\n-int\n-switch1 (int a)\n-{\n-  switch (a)\n-    {\n-    case 1:\n-      return 11;\n-    case 33:\n-      return 333;\n-    case 55:\n-      return 55;\n-    default:\n-      return -1;\n-    }\n-}\n-\n-int\n-switch2 (int a)\n-{\n-  switch (a)\n-    {\n-    case 1 ... 11:\n-      return 11;\n-      break;\n-    case 33:\n-      return 333;\n-      break;\n-    case 55:\n-      return 55;\n-      break;\n-    default:\n-      return -1;\n-    }\n-}\n-\n-int\n-switch3 (int a)\n-{\n-  switch (a)\n-    {\n-    case 1 ... 11:\n-      return 11;\n-    case 12 ... 22:\n-      return 22;\n-    case 23 ... 33:\n-      return 33;\n-    case 34 ... 44:\n-      return 44;\n-    default:\n-      return 44;\n-    }\n-}\n-\n-int\n-switch4 (int a, int b)\n-{\n-  switch (a)\n-    {\n-    case 1 ... 11:\n-      return a;\n-    case 12 ... 22:\n-      return b;\n-    case 23 ... 33:\n-      return a;\n-    case 34 ... 44:\n-      return b;\n-    default:\n-      return 12345;\n-    }\n-}\n-\n-int\n-switch5 (int a, int b)\n-{\n-  switch (a)\n-    {\n-    case 1 ... 2:\n-      return 1;\n-    case 3 ... 4:\n-      return 2;\n-    case 5 ... 6:\n-      return 3;\n-    case 7 ... 11:\n-      return 4;\n-    }\n-\n-  return -1;\n-}\n-#pragma omp end declare target\n-\n-int\n-main (int argc)\n-{\n-  int array[s];\n-\n-#pragma omp target map(tofrom : array[:s])\n-  {\n-    for (int i = 0; i < s; i++)\n-      array[i] = switch1 (i);\n-  }\n-\n-  for (int i = 0; i < s; i++)\n-    assert (array[i] == switch1 (i));\n-\n-#pragma omp target map(tofrom : array[:s])\n-  {\n-    for (int i = 0; i < s; i++)\n-      array[i] = switch2 (i);\n-  }\n-\n-  for (int i = 0; i < s; i++)\n-    assert (array[i] == switch2 (i));\n-\n-#pragma omp target map(tofrom : array[:s])\n-  {\n-    for (int i = 0; i < s; i++)\n-      array[i] = switch3 (i);\n-  }\n-\n-  for (int i = 0; i < s; i++)\n-    assert (array[i] == switch3 (i));\n-\n-#pragma omp target map(tofrom : array[:s])\n-  {\n-    for (int i = 0; i < s; i++)\n-      array[i] = switch4 (i, i + 1);\n-  }\n-\n-  for (int i = 0; i < s; i++)\n-    assert (array[i] == switch4 (i, i + 1));\n-\n-#pragma omp target map(tofrom : array[:s])\n-  {\n-    for (int i = 0; i < s; i++)\n-      array[i] = switch5 (i, i + 1);\n-  }\n-\n-  for (int i = 0; i < s; i++)\n-    assert (array[i] == switch5 (i, i + 1));\n-}"}, {"sha": "9af1d6d07623a5f79d62a7493acb98a729901591", "filename": "libgomp/testsuite/libgomp.hsa.c/switch-branch-1.c", "status": "removed", "additions": 0, "deletions": 116, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9623f61b142174b87760c81f78928dd14af7cbc6/libgomp%2Ftestsuite%2Flibgomp.hsa.c%2Fswitch-branch-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9623f61b142174b87760c81f78928dd14af7cbc6/libgomp%2Ftestsuite%2Flibgomp.hsa.c%2Fswitch-branch-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.hsa.c%2Fswitch-branch-1.c?ref=9623f61b142174b87760c81f78928dd14af7cbc6", "patch": "@@ -1,116 +0,0 @@\n-#include <assert.h>\n-\n-#define s 100\n-\n-#pragma omp declare target\n-int\n-switch1 (unsigned a)\n-{\n-  switch (a)\n-    {\n-    case 1 ... 11:\n-      return 11;\n-    case 12 ... 13:\n-      return 22;\n-    default:\n-      return 44;\n-    }\n-}\n-\n-int\n-switch2 (unsigned a)\n-{\n-  switch (a)\n-    {\n-    case 1 ... 5:\n-      return 1;\n-    case 9 ... 11:\n-      return a + 3;\n-    case 12 ... 13:\n-      return a + 3;\n-    default:\n-      return 44;\n-    }\n-}\n-\n-#define OFFSET 12\n-\n-int\n-switch3 (unsigned a)\n-{\n-  switch (a)\n-    {\n-    case (OFFSET + 0):\n-      return 1;\n-    case (OFFSET + 1)...(OFFSET + 11):\n-      return 11;\n-    case (OFFSET + 12)...(OFFSET + 13):\n-      return (OFFSET + 22);\n-    default:\n-      return (OFFSET + 44);\n-    }\n-}\n-\n-int\n-switch4 (unsigned a)\n-{\n-  switch (a)\n-    {\n-    case -2:\n-      return 1;\n-    case -1:\n-      return a + 3;\n-    case 3:\n-      return a + 3;\n-    default:\n-      return 44;\n-    }\n-}\n-#pragma omp end declare target\n-\n-#define low -33\n-#define high 55\n-\n-int\n-main (int argc)\n-{\n-  int array[s];\n-\n-#pragma omp target map(tofrom : array[:s])\n-  {\n-    for (int i = low; i < high; i++)\n-      array[i - low] = switch1 (i);\n-  }\n-\n-  for (int i = low; i < high; i++)\n-    assert (array[i - low] == switch1 (i));\n-\n-#pragma omp target map(tofrom : array[:s])\n-  {\n-    for (int i = low; i < high; i++)\n-      array[i - low] = switch2 (i);\n-  }\n-\n-  for (int i = low; i < high; i++)\n-    assert (array[i - low] == switch2 (i));\n-\n-#pragma omp target map(tofrom : array[:s])\n-  {\n-    for (int i = low; i < high; i++)\n-      array[i - low] = switch3 (i);\n-  }\n-\n-  for (int i = low; i < high; i++)\n-    assert (array[i - low] == switch3 (i));\n-\n-#pragma omp target map(tofrom : array[:s])\n-  {\n-    for (int i = low; i < high; i++)\n-      array[i - low] = switch4 (i);\n-  }\n-\n-  for (int i = low; i < high; i++)\n-    assert (array[i - low] == switch4 (i));\n-\n-  return 0;\n-}"}, {"sha": "06990d1c2c065b61e572cd3bb9b6988fd05d9bab", "filename": "libgomp/testsuite/libgomp.hsa.c/switch-sbr-2.c", "status": "removed", "additions": 0, "deletions": 59, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9623f61b142174b87760c81f78928dd14af7cbc6/libgomp%2Ftestsuite%2Flibgomp.hsa.c%2Fswitch-sbr-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9623f61b142174b87760c81f78928dd14af7cbc6/libgomp%2Ftestsuite%2Flibgomp.hsa.c%2Fswitch-sbr-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.hsa.c%2Fswitch-sbr-2.c?ref=9623f61b142174b87760c81f78928dd14af7cbc6", "patch": "@@ -1,59 +0,0 @@\n-/* { dg-additional-options \"-fno-tree-switch-conversion\" } */\n-\n-#pragma omp declare target\n-int\n-foo (unsigned a)\n-{\n-  switch (a)\n-    {\n-    case 1 ... 5:\n-      return 1;\n-    case 9 ... 11:\n-      return a + 3;\n-    case 12 ... 13:\n-      return a + 3;\n-    default:\n-      return 44;\n-    }\n-}\n-#pragma omp end declare target\n-\n-#define s 100\n-\n-void __attribute__((noinline, noclone))\n-verify(int *a)\n-{\n-  if (a[0] != 44)\n-    __builtin_abort ();\n-  \n-  for (int i = 1; i <= 5; i++)\n-    if (a[i] != 1)\n-      __builtin_abort ();\n-\n-  for (int i = 6; i <= 8; i++)\n-    if (a[i] != 44)\n-      __builtin_abort ();\n-\n-  for (int i = 9; i <= 13; i++)\n-    if (a[i] != i + 3)\n-      __builtin_abort ();\n-\n-  for (int i = 14; i < s; i++)\n-    if (a[i] != 44)\n-      __builtin_abort ();\n-}\n-\n-int main(int argc)\n-{\n-  int array[s];\n-#pragma omp target\n-  {\n-    for (int i = 0; i < s; i++)\n-      {\n-\tint v = foo (i);\n-\tarray[i] = v;\n-      }\n-  }\n-  verify (array);\n-  return 0;\n-}"}, {"sha": "9149adc04e9b21f0addf114ef872be570502aa75", "filename": "libgomp/testsuite/libgomp.hsa.c/tiling-1.c", "status": "removed", "additions": 0, "deletions": 212, "changes": 212, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9623f61b142174b87760c81f78928dd14af7cbc6/libgomp%2Ftestsuite%2Flibgomp.hsa.c%2Ftiling-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9623f61b142174b87760c81f78928dd14af7cbc6/libgomp%2Ftestsuite%2Flibgomp.hsa.c%2Ftiling-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.hsa.c%2Ftiling-1.c?ref=9623f61b142174b87760c81f78928dd14af7cbc6", "patch": "@@ -1,212 +0,0 @@\n-/*\n-\n-   matmul.c : Matrix Multiplication with tiling for openmp4 example\n-\n-*/\n-\n-#include <stdlib.h>\n-#include <math.h>\n-\n-#define BLOCK_SIZE 16\n-/*\n-  #define BLOCK_SIZE 32\n-*/\n-#define NSECPERSEC 1000000000L\n-\n-typedef struct {\n-   int width;\n-   int height;\n-   int stride;\n-   int hpad;\n-   float* elements;\n-} Matrix;\n-\n-/* Correctly extract the number of nanoseconds from the two time structures */\n-long int get_nanosecs( struct timespec start_time, struct timespec end_time) {\n-   long int nanosecs;\n-   if ((end_time.tv_nsec-start_time.tv_nsec)<0) nanosecs =\n-      ((((long int) end_time.tv_sec- (long int) start_time.tv_sec )-1)*NSECPERSEC ) +\n-      ( NSECPERSEC + (long int) end_time.tv_nsec - (long int) start_time.tv_nsec) ;\n-   else nanosecs =\n-      (((long int) end_time.tv_sec- (long int) start_time.tv_sec )*NSECPERSEC ) +\n-      ( (long int) end_time.tv_nsec - (long int) start_time.tv_nsec );\n-   return nanosecs;\n-}\n-\n-void simple_sgemm_tt(const int M,const int N,const int K,const float alpha, const float* A,const int LDA,\n-     const float* B,const int LDB, const float beta,float* C, const int LDC) ;\n-void simple_sgemm_tn(const int M,const int N,const int K,const float alpha, const float* A,const int LDA,\n-     const float* B,const int LDB, const float beta,float* C, const int LDC) ;\n-void  tiled_sgemm_tt(const int M,const int N,const int K,const float alpha, const float*A, const int LDA,\n-     const float* B,const int LDB, const float beta,float* C, const int LDC) ;\n-\n-int verify(float* v_res, float* v_ref, int len) {\n-    int passed = 1;\n-    int i;\n-    for (i = 0; i < len; ++i) {\n-        if (fabs(v_res[i] - v_ref[i]) > 0.001*v_ref[i]) {\n-\t  __builtin_abort ();\n-        }\n-    }\n-    return passed;\n-}\n-\n-\n-int main(int argc, char* argv[]){\n-\n-   Matrix A,B,Bt,C,Cref;\n-   int a1,a2,a3,i,j;\n-   struct timespec start_time1, end_time1;\n-   struct timespec start_time2, end_time2;\n-   long int nanosecs,total_ops;\n-   float gflopsTiled,gflopsCPU;\n-\n-   a1 = 35;\n-   a2 = 28;\n-   a3 = 47;\n-\n-   A.height = a1;\n-   A.width = a2;\n-   A.stride = (((A.width-1)/BLOCK_SIZE)+1) * BLOCK_SIZE;\n-   A.hpad = (((A.height-1)/BLOCK_SIZE)+1) * BLOCK_SIZE;\n-   A.elements = (float*)malloc(A.stride * A.hpad* sizeof(float));\n-\n-   B.height = a2;\n-   B.width = a3;\n-   B.stride = (((B.width-1)/BLOCK_SIZE)+1) * BLOCK_SIZE;\n-   B.hpad = (((B.height-1)/BLOCK_SIZE)+1) * BLOCK_SIZE;\n-   B.elements = (float*)malloc(B.stride * B.hpad * sizeof(float));\n-\n-   /* Bt is same as B but stored in column-major order */\n-   Bt.height = B.height;\n-   Bt.width = B.width;\n-   Bt.stride = B.stride;\n-   Bt.hpad = B.hpad;\n-   Bt.elements = (float*)malloc(Bt.stride * Bt.hpad * sizeof(float));\n-\n-   C.height = a1;\n-   C.width = a3;\n-   C.stride = (((C.width-1)/BLOCK_SIZE)+1) * BLOCK_SIZE;\n-   C.hpad = (((C.height-1)/BLOCK_SIZE)+1) * BLOCK_SIZE;\n-   C.elements = (float*)malloc(C.stride * C.hpad * sizeof(float));\n-\n-   Cref.height = a1;\n-   Cref.width = a3;\n-   Cref.stride = (((Cref.width-1)/BLOCK_SIZE)+1) * BLOCK_SIZE;\n-   Cref.hpad = (((Cref.height-1)/BLOCK_SIZE)+1) * BLOCK_SIZE;\n-   Cref.elements = (float*)malloc(Cref.stride * Cref.hpad * sizeof(float));\n-\n-   for(i = 0; i < A.hpad ; i++)\n-      for(j = 0; j < A.stride; j++) {\n-         if (( j<A.width ) && (i<A.height)) {\n-            A.elements[i*A.stride + j] = (i % 3);\n-         } else {\n-            A.elements[i*A.stride + j] = 0.0;\n-         }\n-      }\n-\n-   /*  Initialize B and Bt */\n-   for(i = 0; i < B.hpad ; i++)\n-      for(j = 0; j < B.stride; j++) {\n-         if (( j<B.width ) && (i<B.height)) {\n-            B.elements[i*B.stride+j] = (j % 2);\n-            Bt.elements[j*Bt.stride+i] = B.elements[i*B.stride+j] ;\n-         } else {\n-            B.elements[i*B.stride+j] = 0.0;\n-            Bt.elements[j*Bt.stride+i] = 0.0;\n-         }\n-      }\n-\n-   /* zero C, and Cref */\n-   for(i = 0; i < C.hpad; i++)\n-      for(j = 0; j < C.stride; j++) {\n-         C.elements[i*C.stride+j] = 0.0;\n-         Cref.elements[i*Cref.stride+j] = 0.0;\n-      }\n-\n-   simple_sgemm_tt(A.height,B.width,B.height,1.0,A.elements,A.stride,B.elements,B.stride,1.0,Cref.elements,Cref.stride);\n-   tiled_sgemm_tt(A.height,B.width,B.height,1.0,A.elements,A.stride,B.elements,B.stride,1.0,C.elements,C.stride);\n-\n-   verify(C.elements, Cref.elements, C.height * C.stride);\n-   return 0;\n-}\n-\n-void simple_sgemm_tt(const int M,const int N,const int K,const float alpha, const float* A,const int LDA,\n-const float* B,const int LDB, const float beta,float* C, const int LDC) {\n-   /*  A,B, and C  are in row-major order */\n-   int c_row,c_col,inner;\n-   float sum;\n-   for (c_col  = 0 ;  c_col<N; c_col++ ) {\n-      for (c_row = 0 ; c_row<M; c_row++ ) {\n-         sum = 0.0 ;\n-         for (inner = 0 ; inner<K; inner++ ) {\n-            sum += A[c_row*LDA + inner] * B[inner*LDB + c_col] ;\n-         }\n-         C[c_row*LDC + c_col] = alpha*sum + beta*C[ c_row*LDC + c_col] ;\n-      }\n-   }\n-}\n-\n-/***************************\n-\n-   tiled_sgemm_tt:  Tiled matrix multiplication:\n-\n-***************************/\n-\n-void tiled_sgemm_tt(const int M, const int N, const int K, const float alpha, const float*A, const int LDA,\n-   const float*B, const int LDB, const float beta, float*C, const int LDC){\n-\n-#pragma omp target teams map(to:A[M*K],B[K*N]) map(from:C[M*N])\n-#pragma omp distribute collapse(2)\n-   for (int C_row_start=0 ; C_row_start < M ; C_row_start+=BLOCK_SIZE)\n-      for (int C_col_start=0 ; C_col_start < N ; C_col_start+=BLOCK_SIZE)\n-\t{\n-//       Each team has a local copy of these mini matrices\n-         float As[BLOCK_SIZE][BLOCK_SIZE];\n-         float Bs[BLOCK_SIZE][BLOCK_SIZE];\n-#pragma omp parallel\n-\t {\n-         int C_row, C_col;\n-         float Cval = 0.0;\n-\n-         for (int kblock = 0; kblock  < K ; kblock += BLOCK_SIZE )\n-\t   {\n-#pragma omp for collapse(2)\n-\t     for (int row=0 ; row < BLOCK_SIZE ; row++)\n-               for (int col=0 ; col < BLOCK_SIZE ; col++)\n-\t\t {\n-\t\t   C_row = C_row_start + row;\n-\t\t   C_col = C_col_start + col;\n-\t\t   if ((C_row < M) && (kblock + col < K))\n-\t\t     As[row][col] = A[(C_row*LDA)+ kblock + col];\n-\t\t   else\n-\t\t     As[row][col] = 0;\n-\t\t   if ((kblock + row < K) && C_col < N)\n-\t\t     Bs[row][col] = B[((kblock+row)*LDB)+ C_col];\n-\t\t   else\n-\t\t     Bs[row][col] = 0;\n-\t\t }\n-\n-#pragma omp for collapse(2)\n-\t     for (int row=0 ; row < BLOCK_SIZE ; row++)\n-\t       for (int col=0 ; col < BLOCK_SIZE ; col++)\n-\t\t {\n-\t\t   for (int e = 0; e < BLOCK_SIZE; ++e)\n-                     Cval += As[row][e] * Bs[e][col];\n-\t\t }\n-\t   }  /* End for kblock .. */\n-\n-\n-#pragma omp for collapse(2)\n-         for (int row=0 ; row < BLOCK_SIZE ; row++)\n-\t   for (int col=0 ; col < BLOCK_SIZE ; col++)\n-\t     {\n-               C_row = C_row_start + row;\n-               C_col = C_col_start + col;\n-\t       if ((C_row < M) && (C_col < N))\n-\t\t C[(C_row*LDC)+C_col] = alpha*Cval + beta*C[(C_row*LDC)+C_col];\n-\n-\t     }\n-         } /* end parallel */\n-      }\t   /* end target teams distribute */\n-}"}, {"sha": "2756d14ca8287d1c29c6eec6f28d118de7ab4888", "filename": "libgomp/testsuite/libgomp.hsa.c/tiling-2.c", "status": "removed", "additions": 0, "deletions": 258, "changes": 258, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9623f61b142174b87760c81f78928dd14af7cbc6/libgomp%2Ftestsuite%2Flibgomp.hsa.c%2Ftiling-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9623f61b142174b87760c81f78928dd14af7cbc6/libgomp%2Ftestsuite%2Flibgomp.hsa.c%2Ftiling-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.hsa.c%2Ftiling-2.c?ref=9623f61b142174b87760c81f78928dd14af7cbc6", "patch": "@@ -1,258 +0,0 @@\n-/*\n-\n-   matmul.c : Matrix Multiplication with tiling for openmp4 example\n-\n-*/\n-\n-#include <stdlib.h>\n-#include <math.h>\n-\n-#define BLOCK_SIZE 16\n-/*\n-  #define BLOCK_SIZE 32\n-*/\n-#define NSECPERSEC 1000000000L\n-\n-typedef struct {\n-   int width;\n-   int height;\n-   int stride;\n-   int hpad;\n-   float* elements;\n-} Matrix;\n-\n-/* Correctly extract the number of nanoseconds from the two time structures */\n-long int get_nanosecs( struct timespec start_time, struct timespec end_time) {\n-   long int nanosecs;\n-   if ((end_time.tv_nsec-start_time.tv_nsec)<0) nanosecs =\n-      ((((long int) end_time.tv_sec- (long int) start_time.tv_sec )-1)*NSECPERSEC ) +\n-      ( NSECPERSEC + (long int) end_time.tv_nsec - (long int) start_time.tv_nsec) ;\n-   else nanosecs =\n-      (((long int) end_time.tv_sec- (long int) start_time.tv_sec )*NSECPERSEC ) +\n-      ( (long int) end_time.tv_nsec - (long int) start_time.tv_nsec );\n-   return nanosecs;\n-}\n-\n-void simple_sgemm_tt(const int M,const int N,const int K,const float alpha, const float* A,const int LDA,\n-     const float* B,const int LDB, const float beta,float* C, const int LDC) ;\n-void simple_sgemm_tn(const int M,const int N,const int K,const float alpha, const float* A,const int LDA,\n-     const float* B,const int LDB, const float beta,float* C, const int LDC) ;\n-void  tiled_sgemm_tt(const int M,const int N,const int K,const float alpha, const float*A, const int LDA,\n-     const float* B,const int LDB, const float beta,float* C, const int LDC) ;\n-\n-int verify(float* v_res, float* v_ref, int len) {\n-    int passed = 1;\n-    int i;\n-    for (i = 0; i < len; ++i) {\n-        if (fabs(v_res[i] - v_ref[i]) > 0.001*v_ref[i]) {\n-\t  __builtin_abort ();\n-        }\n-    }\n-    return passed;\n-}\n-\n-\n-int main(int argc, char* argv[]){\n-\n-   Matrix A,B,Bt,C,Cref;\n-   int a1,a2,a3,i,j;\n-   struct timespec start_time1, end_time1;\n-   struct timespec start_time2, end_time2;\n-   long int nanosecs,total_ops;\n-   float gflopsTiled,gflopsCPU;\n-\n-   a1 = 35;\n-   a2 = 28;\n-   a3 = 47;\n-\n-   A.height = a1;\n-   A.width = a2;\n-   A.stride = (((A.width-1)/BLOCK_SIZE)+1) * BLOCK_SIZE;\n-   A.hpad = (((A.height-1)/BLOCK_SIZE)+1) * BLOCK_SIZE;\n-   A.elements = (float*)malloc(A.stride * A.hpad* sizeof(float));\n-\n-   B.height = a2;\n-   B.width = a3;\n-   B.stride = (((B.width-1)/BLOCK_SIZE)+1) * BLOCK_SIZE;\n-   B.hpad = (((B.height-1)/BLOCK_SIZE)+1) * BLOCK_SIZE;\n-   B.elements = (float*)malloc(B.stride * B.hpad * sizeof(float));\n-\n-   /* Bt is same as B but stored in column-major order */\n-   Bt.height = B.height;\n-   Bt.width = B.width;\n-   Bt.stride = B.stride;\n-   Bt.hpad = B.hpad;\n-   Bt.elements = (float*)malloc(Bt.stride * Bt.hpad * sizeof(float));\n-\n-   C.height = a1;\n-   C.width = a3;\n-   C.stride = (((C.width-1)/BLOCK_SIZE)+1) * BLOCK_SIZE;\n-   C.hpad = (((C.height-1)/BLOCK_SIZE)+1) * BLOCK_SIZE;\n-   C.elements = (float*)malloc(C.stride * C.hpad * sizeof(float));\n-\n-   Cref.height = a1;\n-   Cref.width = a3;\n-   Cref.stride = (((Cref.width-1)/BLOCK_SIZE)+1) * BLOCK_SIZE;\n-   Cref.hpad = (((Cref.height-1)/BLOCK_SIZE)+1) * BLOCK_SIZE;\n-   Cref.elements = (float*)malloc(Cref.stride * Cref.hpad * sizeof(float));\n-\n-   for(i = 0; i < A.hpad ; i++)\n-      for(j = 0; j < A.stride; j++) {\n-         if (( j<A.width ) && (i<A.height)) {\n-            A.elements[i*A.stride + j] = (i % 3);\n-         } else {\n-            A.elements[i*A.stride + j] = 0.0;\n-         }\n-      }\n-\n-   /*  Initialize B and Bt */\n-   for(i = 0; i < B.hpad ; i++)\n-      for(j = 0; j < B.stride; j++) {\n-         if (( j<B.width ) && (i<B.height)) {\n-            B.elements[i*B.stride+j] = (j % 2);\n-            Bt.elements[j*Bt.stride+i] = B.elements[i*B.stride+j] ;\n-         } else {\n-            B.elements[i*B.stride+j] = 0.0;\n-            Bt.elements[j*Bt.stride+i] = 0.0;\n-         }\n-      }\n-\n-   /* zero C, and Cref */\n-   for(i = 0; i < C.hpad; i++)\n-      for(j = 0; j < C.stride; j++) {\n-         C.elements[i*C.stride+j] = 0.0;\n-         Cref.elements[i*Cref.stride+j] = 0.0;\n-      }\n-\n-   simple_sgemm_tt(A.height,B.width,B.height,1.0,A.elements,A.stride,B.elements,B.stride,1.0,Cref.elements,Cref.stride);\n-   tiled_sgemm_tt(A.height,B.width,B.height,1.0,A.elements,A.stride,B.elements,B.stride,1.0,C.elements,C.stride);\n-\n-   verify(C.elements, Cref.elements, C.height * C.stride);\n-   return 0;\n-}\n-\n-void simple_sgemm_tt(const int M,const int N,const int K,const float alpha, const float* A,const int LDA,\n-const float* B,const int LDB, const float beta,float* C, const int LDC) {\n-   /*  A,B, and C  are in row-major order */\n-   int c_row,c_col,inner;\n-   float sum;\n-   for (c_col  = 0 ;  c_col<N; c_col++ ) {\n-      for (c_row = 0 ; c_row<M; c_row++ ) {\n-         sum = 0.0 ;\n-         for (inner = 0 ; inner<K; inner++ ) {\n-            sum += A[c_row*LDA + inner] * B[inner*LDB + c_col] ;\n-         }\n-         C[c_row*LDC + c_col] = alpha*sum + beta*C[ c_row*LDC + c_col] ;\n-      }\n-   }\n-}\n-\n-/***************************\n-\n-   tiled_sgemm_tt:  Tiled matrix multiplication:\n-\n-***************************/\n-\n-void tiled_sgemm_tt(const int M, const int N, const int K, const float alpha, const float*A, const int LDA,\n-   const float*B, const int LDB, const float beta, float*C, const int LDC){\n-\n-#pragma omp target teams map(to:A[M*K],B[K*N]) map(from:C[M*N])\n-#pragma omp distribute collapse(2)\n-   for (int C_row_start=0 ; C_row_start < M ; C_row_start+=BLOCK_SIZE) {\n-      for (int C_col_start=0 ; C_col_start < N ; C_col_start+=BLOCK_SIZE) {\n-\n-// We now have M/BLOCK_SIZE * N/BLOCK_SIZE teams = (M*N)/(BLOCK_SIZE*BLOCK_SIZE)\n-// The grid global dimensions are M,N,1\n-// The grid local dimensions are BLOCK_SIZE,BLOCK_SIZE,1\n-\n-// -------------------------------------------------------------------\n-//      The rest of this code forms the HSAIL kernel with the\n-//      pairs of \"parallel for collapse(2)\" loops replaced with a barrier.\n-//      The kernel initializes these values\n-//      C_row_start = get_group_id(0) * BLOCK_SIZE\n-//      C_col_start = get_group_id(1) * BLOCK_SIZE\n-//      row=get_local_id(0)\n-//      col=get_local_id(1)\n-// -------------------------------------------------------------------\n-\n-//       Each team has a local copy of these mini matrices\n-         float As[BLOCK_SIZE][BLOCK_SIZE];\n-         float Bs[BLOCK_SIZE][BLOCK_SIZE];\n-         float Cs[BLOCK_SIZE][BLOCK_SIZE];\n-         int C_row, C_col;\n-\n-         /* Zero Cs for this BLOCK */\n-// - - - - - - - - - - - - - - - - - - - -\n-// REPLACE NEXT THREE LINES WITH A BARRIER\n-#pragma omp parallel for collapse(2)\n-         for (int row=0 ; row < BLOCK_SIZE ; row++) {\n-            for (int col=0 ; col < BLOCK_SIZE ; col++) {\n-// END BARRIER\n-// - - - - - - - - - - - - - - - - - - - -\n-               Cs[row][col] = 0.0;\n-            }\n-         }\n-\n-         // This kblock loop is run on the master thread of each team\n-         for (int kblock = 0; kblock  < K ; kblock += BLOCK_SIZE ) {\n-\n-            // Copy global memory values to local memory\n-// - - - - - - - - - - - - - - - - - - - -\n-// REPLACE NEXT THREE LINES WITH A BARRIER\n-#pragma omp parallel for collapse(2)\n-            for (int row=0 ; row < BLOCK_SIZE ; row++) {\n-               for (int col=0 ; col < BLOCK_SIZE ; col++) {\n-// END BARRIER\n-// - - - - - - - - - - - - - - - - - - - -\n-                  C_row = C_row_start + row;\n-                  C_col = C_col_start + col;\n-\t\t  if ((C_row < M) && (kblock + col < K))\n-\t\t    As[row][col] = A[(C_row*LDA)+ kblock + col];\n-\t\t  else\n-\t\t    As[row][col] = 0;\n-\t\t  if ((kblock + row < K) && C_col < N)\n-\t\t    Bs[row][col] = B[((kblock+row)*LDB)+ C_col];\n-\t\t  else\n-\t\t    Bs[row][col] = 0;\n-               }\n-            }\n-\n-            // Calculate Cs <- Sum(As X Bs) across all kblocks\n-// - - - - - - - - - - - - - - - - - - - -\n-// REPLACE NEXT THREE LINES WITH A BARRIER\n-#pragma omp parallel for collapse(2)\n-            for (int row=0 ; row < BLOCK_SIZE ; row++) {\n-               for (int col=0 ; col < BLOCK_SIZE ; col++) {\n-// END BARRIER\n-// - - - - - - - - - - - - - - - - - - - -\n-                  for (int e = 0; e < BLOCK_SIZE; ++e)\n-                     Cs[row][col] += As[row][e] * Bs[e][col];\n-                }\n-            }\n-\n-         }  /* End for kblock .. */\n-\n-\n-         // Scale Update actual C from Cs\n-// - - - - - - - - - - - - - - - - - - - -\n-// REPLACE NEXT THREE LINES WITH A BARRIER\n-#pragma omp parallel for collapse(2)\n-         for (int row=0 ; row < BLOCK_SIZE ; row++) {\n-            for (int col=0 ; col < BLOCK_SIZE ; col++) {\n-// END BARRIER\n-// - - - - - - - - - - - - - - - - - - - -\n-               C_row = C_row_start + row;\n-               C_col = C_col_start + col;\n-\t       if ((C_row < M) && (C_col < N)) {\n-\t\t C[(C_row*LDC)+C_col] = alpha*Cs[row][col] + beta*C[(C_row*LDC)+C_col];\n-\t       }\n-            }\n-         }\n-\n-// -------------------------------------------------------------------\n-// This is the end of the kernel\n-\n-      }\n-   }\n-\n-}"}]}