{"sha": "c2d777d6f3a17ac07f78bc4c7dc4d1e0ddd566ae", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzJkNzc3ZDZmM2ExN2FjMDdmNzhiYzRjN2RjNGQxZTBkZGQ1NjZhZQ==", "commit": {"author": {"name": "Bill Schmidt", "email": "wschmidt@linux.ibm.com", "date": "2021-07-20T22:45:57Z"}, "committer": {"name": "Bill Schmidt", "email": "wschmidt@linux.ibm.com", "date": "2021-07-21T17:48:41Z"}, "message": "rs6000: Parsing built-in input file, part 1 of 3\n\n2021-07-20  Bill Schmidt  <wschmidt@linux.ibm.com>\n\ngcc/\n\t* config/rs6000/rs6000-gen-builtins.c (bif_stanza): New enum.\n\t(curr_bif_stanza): New variable.\n\t(stanza_entry): New struct.\n\t(stanza_map): New initialized variable.\n\t(enable_string): Likewise.\n\t(fnkinds): New enum.\n\t(typelist): New struct.\n\t(attrinfo): Likewise.\n\t(MAXRESTROPNDS): New macro.\n\t(prototype): New struct.\n\t(MAXBIFS): New macro.\n\t(bifdata): New struct.\n\t(bifs): New variable.\n\t(curr_bif): Likewise.\n\t(bif_order): Likewise.\n\t(bif_index): Likewise.\n\t(fatal): New function.\n\t(stanza_name_to_stanza): Likewise.\n\t(parse_bif_attrs): New stub function.\n\t(parse_prototype): Likewise.\n\t(parse_bif_entry): New function.\n\t(parse_bif_stanza): Likewise.\n\t(parse_bif): Implement.\n\t(set_bif_order): New function.\n\t(create_bif_order): Implement.", "tree": {"sha": "9852bb2434aa7879421865220d95525592d06ba5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9852bb2434aa7879421865220d95525592d06ba5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c2d777d6f3a17ac07f78bc4c7dc4d1e0ddd566ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2d777d6f3a17ac07f78bc4c7dc4d1e0ddd566ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c2d777d6f3a17ac07f78bc4c7dc4d1e0ddd566ae", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2d777d6f3a17ac07f78bc4c7dc4d1e0ddd566ae/comments", "author": null, "committer": null, "parents": [{"sha": "005054e48e2d6c4d9b0aac7fda2e4a324886307c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/005054e48e2d6c4d9b0aac7fda2e4a324886307c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/005054e48e2d6c4d9b0aac7fda2e4a324886307c"}], "stats": {"total": 379, "additions": 378, "deletions": 1}, "files": [{"sha": "b066ece4471a307282fe3740e12fd92ed8109850", "filename": "gcc/config/rs6000/rs6000-gen-builtins.c", "status": "modified", "additions": 378, "deletions": 1, "changes": 379, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2d777d6f3a17ac07f78bc4c7dc4d1e0ddd566ae/gcc%2Fconfig%2Frs6000%2Frs6000-gen-builtins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2d777d6f3a17ac07f78bc4c7dc4d1e0ddd566ae/gcc%2Fconfig%2Frs6000%2Frs6000-gen-builtins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-gen-builtins.c?ref=c2d777d6f3a17ac07f78bc4c7dc4d1e0ddd566ae", "patch": "@@ -194,6 +194,101 @@ enum void_status\n  VOID_OK\n };\n \n+/* Stanzas are groupings of built-in functions and overloads by some\n+   common feature/attribute.  These definitions are for built-in function\n+   stanzas.  */\n+enum bif_stanza\n+{\n+ BSTZ_ALWAYS,\n+ BSTZ_P5,\n+ BSTZ_P6,\n+ BSTZ_ALTIVEC,\n+ BSTZ_CELL,\n+ BSTZ_VSX,\n+ BSTZ_P7,\n+ BSTZ_P7_64,\n+ BSTZ_P8,\n+ BSTZ_P8V,\n+ BSTZ_P9,\n+ BSTZ_P9_64,\n+ BSTZ_P9V,\n+ BSTZ_IEEE128_HW,\n+ BSTZ_DFP,\n+ BSTZ_CRYPTO,\n+ BSTZ_HTM,\n+ BSTZ_P10,\n+ BSTZ_P10_64,\n+ BSTZ_MMA,\n+ NUMBIFSTANZAS\n+};\n+\n+static bif_stanza curr_bif_stanza;\n+\n+struct stanza_entry\n+{\n+  const char *stanza_name;\n+  bif_stanza stanza;\n+};\n+\n+static stanza_entry stanza_map[NUMBIFSTANZAS] =\n+  {\n+    { \"always\",\t\tBSTZ_ALWAYS\t},\n+    { \"power5\",\t\tBSTZ_P5\t\t},\n+    { \"power6\",\t\tBSTZ_P6\t\t},\n+    { \"altivec\",\tBSTZ_ALTIVEC\t},\n+    { \"cell\",\t\tBSTZ_CELL\t},\n+    { \"vsx\",\t\tBSTZ_VSX\t},\n+    { \"power7\",\t\tBSTZ_P7\t\t},\n+    { \"power7-64\",\tBSTZ_P7_64\t},\n+    { \"power8\",\t\tBSTZ_P8\t\t},\n+    { \"power8-vector\",\tBSTZ_P8V\t},\n+    { \"power9\",\t\tBSTZ_P9\t\t},\n+    { \"power9-64\",\tBSTZ_P9_64\t},\n+    { \"power9-vector\",\tBSTZ_P9V\t},\n+    { \"ieee128-hw\",\tBSTZ_IEEE128_HW\t},\n+    { \"dfp\",\t\tBSTZ_DFP\t},\n+    { \"crypto\",\t\tBSTZ_CRYPTO\t},\n+    { \"htm\",\t\tBSTZ_HTM\t},\n+    { \"power10\",\tBSTZ_P10\t},\n+    { \"power10-64\",\tBSTZ_P10_64\t},\n+    { \"mma\",\t\tBSTZ_MMA\t}\n+  };\n+\n+static const char *enable_string[NUMBIFSTANZAS] =\n+  {\n+    \"ENB_ALWAYS\",\n+    \"ENB_P5\",\n+    \"ENB_P6\",\n+    \"ENB_ALTIVEC\",\n+    \"ENB_CELL\",\n+    \"ENB_VSX\",\n+    \"ENB_P7\",\n+    \"ENB_P7_64\",\n+    \"ENB_P8\",\n+    \"ENB_P8V\",\n+    \"ENB_P9\",\n+    \"ENB_P9_64\",\n+    \"ENB_P9V\",\n+    \"ENB_IEEE128_HW\",\n+    \"ENB_DFP\",\n+    \"ENB_CRYPTO\",\n+    \"ENB_HTM\",\n+    \"ENB_P10\",\n+    \"ENB_P10_64\",\n+    \"ENB_MMA\"\n+  };\n+\n+/* Function modifiers provide special handling for const, pure, and fpmath\n+   functions.  These are mutually exclusive, and therefore kept separate\n+   from other bif attributes.  */\n+enum fnkinds\n+{\n+  FNK_NONE,\n+  FNK_CONST,\n+  FNK_PURE,\n+  FNK_FPMATH\n+};\n+\n /* Legal base types for an argument or return type.  */\n enum basetype\n {\n@@ -250,7 +345,76 @@ struct typeinfo\n   char *val2;\n };\n \n+/* A list of argument types.  */\n+struct typelist\n+{\n+  typeinfo info;\n+  typelist *next;\n+};\n+\n+/* Attributes of a builtin function.  */\n+struct attrinfo\n+{\n+  bool isinit;\n+  bool isset;\n+  bool isextract;\n+  bool isnosoft;\n+  bool isldvec;\n+  bool isstvec;\n+  bool isreve;\n+  bool ispred;\n+  bool ishtm;\n+  bool ishtmspr;\n+  bool ishtmcr;\n+  bool ismma;\n+  bool isquad;\n+  bool ispair;\n+  bool isno32bit;\n+  bool is32bit;\n+  bool iscpu;\n+  bool isldstmask;\n+  bool islxvrse;\n+  bool islxvrze;\n+  bool isendian;\n+};\n+\n+/* Fields associated with a function prototype (bif or overload).  */\n+#define MAXRESTROPNDS 3\n+struct prototype\n+{\n+  typeinfo rettype;\n+  char *bifname;\n+  int nargs;\n+  typelist *args;\n+  int restr_opnd[MAXRESTROPNDS];\n+  restriction restr[MAXRESTROPNDS];\n+  char *restr_val1[MAXRESTROPNDS];\n+  char *restr_val2[MAXRESTROPNDS];\n+};\n+\n+/* Data associated with a builtin function, and a table of such data.  */\n+#define MAXBIFS 16384\n+struct bifdata\n+{\n+  int stanza;\n+  fnkinds kind;\n+  prototype proto;\n+  char *idname;\n+  char *patname;\n+  attrinfo attrs;\n+  char *fndecl;\n+};\n+\n+static bifdata bifs[MAXBIFS];\n static int num_bifs;\n+static int curr_bif;\n+\n+/* Array used to track the order in which built-ins appeared in the\n+   built-in file.  We reorder them alphabetically but sometimes need\n+   this information.  */\n+static int *bif_order;\n+static int bif_index = 0;\n+\n static int num_ovld_stanzas;\n static int num_ovlds;\n \n@@ -419,6 +583,25 @@ handle_pointer (typeinfo *typedata)\n     }\n }\n \n+/* Produce a fatal error message.  */\n+static void\n+fatal (const char *msg)\n+{\n+  fprintf (stderr, \"FATAL: %s\\n\", msg);\n+  abort ();\n+}\n+\n+static bif_stanza\n+stanza_name_to_stanza (const char *stanza_name)\n+{\n+  for (int i = 0; i < NUMBIFSTANZAS; i++)\n+    if (!strcmp (stanza_name, stanza_map[i].stanza_name))\n+      return stanza_map[i].stanza;\n+  fatal (\"Stanza mapping is inconsistent.\");\n+  /* Unreachable.  */\n+  return BSTZ_ALWAYS;\n+}\n+\n /* Match one of the allowable base types.  Consumes one token unless the\n    token is \"long\", which must be paired with a second \"long\".  Optionally\n    consumes a following '*' token for pointers.  Return 1 for success,\n@@ -889,18 +1072,212 @@ match_type (typeinfo *typedata, int voidok)\n   return 1;\n }\n \n+/* Parse the attribute list.  */\n+static parse_codes\n+parse_bif_attrs (attrinfo *attrptr)\n+{\n+  return PC_OK;\n+}\n+\n+/* Parse a function prototype.  This code is shared by the bif and overload\n+   file processing.  */\n+static parse_codes\n+parse_prototype (prototype *protoptr)\n+{\n+  return PC_OK;\n+}\n+\n+/* Parse a two-line entry for a built-in function.  */\n+static parse_codes\n+parse_bif_entry (void)\n+{\n+  /* Check for end of stanza.  */\n+  pos = 0;\n+  consume_whitespace ();\n+  if (linebuf[pos] == '[')\n+    return PC_EOSTANZA;\n+\n+  /* Allocate an entry in the bif table.  */\n+  if (num_bifs >= MAXBIFS - 1)\n+    {\n+      (*diag) (\"too many built-in functions.\\n\");\n+      return PC_PARSEFAIL;\n+    }\n+\n+  curr_bif = num_bifs++;\n+  bifs[curr_bif].stanza = curr_bif_stanza;\n+\n+  /* Read the first token and see if it is a function modifier.  */\n+  consume_whitespace ();\n+  int oldpos = pos;\n+  char *token = match_identifier ();\n+  if (!token)\n+    {\n+      (*diag) (\"malformed entry at column %d\\n\", oldpos + 1);\n+      return PC_PARSEFAIL;\n+    }\n+\n+  if (!strcmp (token, \"const\"))\n+    bifs[curr_bif].kind = FNK_CONST;\n+  else if (!strcmp (token, \"pure\"))\n+    bifs[curr_bif].kind = FNK_PURE;\n+  else if (!strcmp (token, \"fpmath\"))\n+    bifs[curr_bif].kind = FNK_FPMATH;\n+  else\n+    {\n+      /* No function modifier, so push the token back.  */\n+      pos = oldpos;\n+      bifs[curr_bif].kind = FNK_NONE;\n+    }\n+\n+  if (parse_prototype (&bifs[curr_bif].proto) == PC_PARSEFAIL)\n+    return PC_PARSEFAIL;\n+\n+  /* Now process line 2.  First up is the builtin id.  */\n+  if (!advance_line (bif_file))\n+    {\n+      (*diag) (\"unexpected EOF.\\n\");\n+      return PC_PARSEFAIL;\n+    }\n+\n+  pos = 0;\n+  consume_whitespace ();\n+  oldpos = pos;\n+  bifs[curr_bif].idname = match_identifier ();\n+  if (!bifs[curr_bif].idname)\n+    {\n+      (*diag) (\"missing builtin id at column %d.\\n\", pos + 1);\n+      return PC_PARSEFAIL;\n+    }\n+\n+#ifdef DEBUG\n+  (*diag) (\"ID name is '%s'.\\n\", bifs[curr_bif].idname);\n+#endif\n+\n+  /* Save the ID in a lookup structure.  */\n+  if (!rbt_insert (&bif_rbt, bifs[curr_bif].idname))\n+    {\n+      (*diag) (\"duplicate function ID '%s' at column %d.\\n\",\n+\t       bifs[curr_bif].idname, oldpos + 1);\n+      return PC_PARSEFAIL;\n+    }\n+\n+  /* Append a number representing the order in which this function\n+     was encountered to its name, and save in another lookup\n+     structure.  */\n+  char *buf;\n+  asprintf (&buf, \"%s:%05d\", bifs[curr_bif].idname, curr_bif);\n+\n+  if (!rbt_insert (&bifo_rbt, buf))\n+    {\n+      (*diag) (\"internal error inserting '%s' in bifo_rbt\\n\", buf);\n+      return PC_PARSEFAIL;\n+    }\n+\n+  /* Now the pattern name.  */\n+  consume_whitespace ();\n+  bifs[curr_bif].patname = match_identifier ();\n+  if (!bifs[curr_bif].patname)\n+    {\n+      (*diag) (\"missing pattern name at column %d.\\n\", pos + 1);\n+      return PC_PARSEFAIL;\n+    }\n+\n+#ifdef DEBUG\n+  (*diag) (\"pattern name is '%s'.\\n\", bifs[curr_bif].patname);\n+#endif\n+\n+  /* Process attributes.  */\n+  return parse_bif_attrs (&bifs[curr_bif].attrs);\n+}\n+\n+/* Parse one stanza of the input BIF file.  linebuf already contains the\n+   first line to parse.  */\n+static parse_codes\n+parse_bif_stanza (void)\n+{\n+  /* Parse the stanza header.  */\n+  pos = 0;\n+  consume_whitespace ();\n+\n+  if (linebuf[pos] != '[')\n+    {\n+      (*diag) (\"ill-formed stanza header at column %d.\\n\", pos + 1);\n+      return PC_PARSEFAIL;\n+    }\n+  safe_inc_pos ();\n+\n+  const char *stanza_name = match_to_right_bracket ();\n+  if (!stanza_name)\n+    {\n+      (*diag) (\"no expression found in stanza header.\\n\");\n+      return PC_PARSEFAIL;\n+    }\n+\n+  curr_bif_stanza = stanza_name_to_stanza (stanza_name);\n+\n+  if (linebuf[pos] != ']')\n+    {\n+      (*diag) (\"ill-formed stanza header at column %d.\\n\", pos + 1);\n+      return PC_PARSEFAIL;\n+    }\n+  safe_inc_pos ();\n+\n+  consume_whitespace ();\n+  if (linebuf[pos] != '\\n' && pos != LINELEN - 1)\n+    {\n+      (*diag) (\"garbage after stanza header.\\n\");\n+      return PC_PARSEFAIL;\n+    }\n+\n+  parse_codes result = PC_OK;\n+\n+  while (result != PC_EOSTANZA)\n+    {\n+      if (!advance_line (bif_file))\n+\treturn PC_EOFILE;\n+      result = parse_bif_entry ();\n+      if (result == PC_PARSEFAIL)\n+\treturn PC_PARSEFAIL;\n+    }\n+\n+  return PC_OK;\n+}\n+\n /* Parse the built-in file.  */\n static parse_codes\n parse_bif (void)\n {\n-  return PC_OK;\n+  parse_codes result;\n+  diag = &bif_diag;\n+  if (!advance_line (bif_file))\n+    return PC_OK;\n+\n+  do\n+    result = parse_bif_stanza ();\n+  while (result == PC_OK);\n+\n+  if (result == PC_EOFILE)\n+    return PC_OK;\n+  return result;\n+}\n+\n+/* Callback function for create_bif_order.  */\n+void set_bif_order (char *str)\n+{\n+  int num = 0;\n+  char *colon = strchr (str, ':');\n+  sscanf (++colon, \"%d\", &num);\n+  bif_order[bif_index++] = num;\n }\n \n /* Create a mapping from function IDs in their final order to the order\n    they appear in the built-in function file.  */\n static void\n create_bif_order (void)\n {\n+  bif_order = (int *) malloc ((curr_bif + 1)  * sizeof (int));\n+  rbt_inorder_callback (&bifo_rbt, bifo_rbt.rbt_root, set_bif_order);\n }\n \n /* Parse the overload file.  */"}]}