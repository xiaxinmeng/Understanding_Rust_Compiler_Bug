{"sha": "8cfaf4c938c34b48f7102b539d6db44851bf3ac4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGNmYWY0YzkzOGMzNGI0OGY3MTAyYjUzOWQ2ZGI0NDg1MWJmM2FjNA==", "commit": {"author": {"name": "Paolo Carlini", "email": "paolo.carlini@oracle.com", "date": "2010-10-06T17:17:16Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2010-10-06T17:17:16Z"}, "message": "functional (struct _Weak_result_type_impl): Add specializazions for cv-qualified function types...\n\n2010-10-06  Paolo Carlini  <paolo.carlini@oracle.com>\n\n\t* include/std/functional (struct _Weak_result_type_impl): Add\n\tspecializazions for cv-qualified function types, for variadic\n\tfunction types and pointers and references to function types,\n\tand for pointers to member function types.\n\t(struct _Reference_wrapper_base): Add specializations for\n\tcv-qualified unary and binary function types.\n\t* testsuite/20_util/reference_wrapper/result_type.cc: New.\n\t* testsuite/20_util/reference_wrapper/typedefs-2.cc: Likewise.\n\nFrom-SVN: r165056", "tree": {"sha": "619ca9a1c53872403240f1d89461f35d6d93bbc4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/619ca9a1c53872403240f1d89461f35d6d93bbc4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8cfaf4c938c34b48f7102b539d6db44851bf3ac4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8cfaf4c938c34b48f7102b539d6db44851bf3ac4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8cfaf4c938c34b48f7102b539d6db44851bf3ac4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8cfaf4c938c34b48f7102b539d6db44851bf3ac4/comments", "author": null, "committer": null, "parents": [{"sha": "db0d4b71b579a9ce556bb19948ce4c847cc6c129", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db0d4b71b579a9ce556bb19948ce4c847cc6c129", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db0d4b71b579a9ce556bb19948ce4c847cc6c129"}], "stats": {"total": 268, "additions": 229, "deletions": 39}, "files": [{"sha": "bd06501440c019f93b08853af51f51ec74ffb09c", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cfaf4c938c34b48f7102b539d6db44851bf3ac4/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cfaf4c938c34b48f7102b539d6db44851bf3ac4/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=8cfaf4c938c34b48f7102b539d6db44851bf3ac4", "patch": "@@ -1,3 +1,14 @@\n+2010-10-06  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+\t* include/std/functional (struct _Weak_result_type_impl): Add\n+\tspecializazions for cv-qualified function types, for variadic\n+\tfunction types and pointers and references to function types,\n+\tand for pointers to member function types.\n+\t(struct _Reference_wrapper_base): Add specializations for\n+\tcv-qualified unary and binary function types.\n+\t* testsuite/20_util/reference_wrapper/result_type.cc: New.\n+\t* testsuite/20_util/reference_wrapper/typedefs-2.cc: Likewise.\n+\n 2010-10-06  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \tPR libstdc++/45863"}, {"sha": "33fe07284accbe2c3d693e481deed6bff78e70e3", "filename": "libstdc++-v3/include/std/functional", "status": "modified", "additions": 107, "deletions": 39, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cfaf4c938c34b48f7102b539d6db44851bf3ac4/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffunctional", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cfaf4c938c34b48f7102b539d6db44851bf3ac4/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffunctional", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffunctional?ref=8cfaf4c938c34b48f7102b539d6db44851bf3ac4", "patch": "@@ -60,9 +60,6 @@\n \n namespace std\n {\n-  template<typename _MemberPointer>\n-    class _Mem_fn;\n-\n _GLIBCXX_HAS_NESTED_TYPE(result_type)\n \n   /// If we have found a result_type, extract it.\n@@ -72,9 +69,7 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n \n   template<typename _Functor>\n     struct _Maybe_get_result_type<true, _Functor>\n-    {\n-      typedef typename _Functor::result_type result_type;\n-    };\n+    { typedef typename _Functor::result_type result_type; };\n \n   /**\n    *  Base class for any function object that has a weak result type, as\n@@ -88,51 +83,91 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n   /// Retrieve the result type for a function type.\n   template<typename _Res, typename... _ArgTypes> \n     struct _Weak_result_type_impl<_Res(_ArgTypes...)>\n-    {\n-      typedef _Res result_type;\n-    };\n+    { typedef _Res result_type; };\n+\n+  template<typename _Res, typename... _ArgTypes> \n+    struct _Weak_result_type_impl<_Res(_ArgTypes......)>\n+    { typedef _Res result_type; };\n+\n+  template<typename _Res, typename... _ArgTypes> \n+    struct _Weak_result_type_impl<_Res(_ArgTypes...) const>\n+    { typedef _Res result_type; };\n+\n+  template<typename _Res, typename... _ArgTypes> \n+    struct _Weak_result_type_impl<_Res(_ArgTypes......) const>\n+    { typedef _Res result_type; };\n+\n+  template<typename _Res, typename... _ArgTypes> \n+    struct _Weak_result_type_impl<_Res(_ArgTypes...) volatile>\n+    { typedef _Res result_type; };\n+\n+  template<typename _Res, typename... _ArgTypes> \n+    struct _Weak_result_type_impl<_Res(_ArgTypes......) volatile>\n+    { typedef _Res result_type; };\n+\n+  template<typename _Res, typename... _ArgTypes> \n+    struct _Weak_result_type_impl<_Res(_ArgTypes...) const volatile>\n+    { typedef _Res result_type; };\n+\n+  template<typename _Res, typename... _ArgTypes> \n+    struct _Weak_result_type_impl<_Res(_ArgTypes......) const volatile>\n+    { typedef _Res result_type; };\n \n   /// Retrieve the result type for a function reference.\n   template<typename _Res, typename... _ArgTypes> \n     struct _Weak_result_type_impl<_Res(&)(_ArgTypes...)>\n-    {\n-      typedef _Res result_type;\n-    };\n+    { typedef _Res result_type; };\n+\n+  template<typename _Res, typename... _ArgTypes> \n+    struct _Weak_result_type_impl<_Res(&)(_ArgTypes......)>\n+    { typedef _Res result_type; };\n \n   /// Retrieve the result type for a function pointer.\n   template<typename _Res, typename... _ArgTypes> \n     struct _Weak_result_type_impl<_Res(*)(_ArgTypes...)>\n-    {\n-      typedef _Res result_type;\n-    };\n+    { typedef _Res result_type; };\n+\n+  template<typename _Res, typename... _ArgTypes> \n+    struct _Weak_result_type_impl<_Res(*)(_ArgTypes......)>\n+    { typedef _Res result_type; };\n \n   /// Retrieve result type for a member function pointer. \n   template<typename _Res, typename _Class, typename... _ArgTypes> \n     struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes...)>\n-    {\n-      typedef _Res result_type;\n-    };\n+    { typedef _Res result_type; };\n+\n+  template<typename _Res, typename _Class, typename... _ArgTypes> \n+    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes......)>\n+    { typedef _Res result_type; };\n \n   /// Retrieve result type for a const member function pointer. \n   template<typename _Res, typename _Class, typename... _ArgTypes> \n     struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes...) const>\n-    {\n-      typedef _Res result_type;\n-    };\n+    { typedef _Res result_type; };\n+\n+  template<typename _Res, typename _Class, typename... _ArgTypes> \n+    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes......) const>\n+    { typedef _Res result_type; };\n \n   /// Retrieve result type for a volatile member function pointer. \n   template<typename _Res, typename _Class, typename... _ArgTypes> \n     struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes...) volatile>\n-    {\n-      typedef _Res result_type;\n-    };\n+    { typedef _Res result_type; };\n+\n+  template<typename _Res, typename _Class, typename... _ArgTypes> \n+    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes......) volatile>\n+    { typedef _Res result_type; };\n \n   /// Retrieve result type for a const volatile member function pointer. \n   template<typename _Res, typename _Class, typename... _ArgTypes> \n-    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes...)const volatile>\n-    {\n-      typedef _Res result_type;\n-    };\n+    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes...) \n+\t\t\t\t  const volatile>\n+    { typedef _Res result_type; };\n+\n+  template<typename _Res, typename _Class, typename... _ArgTypes> \n+    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes......)\n+\t\t\t\t  const volatile>\n+    { typedef _Res result_type; };\n \n   /**\n    *  Strip top-level cv-qualifiers from the function object and let\n@@ -280,12 +315,42 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n     : unary_function<_T1, _Res>\n     { };\n \n+  template<typename _Res, typename _T1>\n+    struct _Reference_wrapper_base<_Res(_T1) const>\n+    : unary_function<_T1, _Res>\n+    { };\n+\n+  template<typename _Res, typename _T1>\n+    struct _Reference_wrapper_base<_Res(_T1) volatile>\n+    : unary_function<_T1, _Res>\n+    { };\n+\n+  template<typename _Res, typename _T1>\n+    struct _Reference_wrapper_base<_Res(_T1) const volatile>\n+    : unary_function<_T1, _Res>\n+    { };\n+\n   // - a function type (binary)\n   template<typename _Res, typename _T1, typename _T2>\n     struct _Reference_wrapper_base<_Res(_T1, _T2)>\n     : binary_function<_T1, _T2, _Res>\n     { };\n \n+  template<typename _Res, typename _T1, typename _T2>\n+    struct _Reference_wrapper_base<_Res(_T1, _T2) const>\n+    : binary_function<_T1, _T2, _Res>\n+    { };\n+\n+  template<typename _Res, typename _T1, typename _T2>\n+    struct _Reference_wrapper_base<_Res(_T1, _T2) volatile>\n+    : binary_function<_T1, _T2, _Res>\n+    { };\n+\n+  template<typename _Res, typename _T1, typename _T2>\n+    struct _Reference_wrapper_base<_Res(_T1, _T2) const volatile>\n+    : binary_function<_T1, _T2, _Res>\n+    { };\n+\n   // - a function pointer type (unary)\n   template<typename _Res, typename _T1>\n     struct _Reference_wrapper_base<_Res(*)(_T1)>\n@@ -423,17 +488,8 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n \n   // @} group functors\n \n-  template<typename _Tp, bool>\n-    struct _Mem_fn_const_or_non\n-    {\n-      typedef const _Tp& type;\n-    };\n-\n-  template<typename _Tp>\n-    struct _Mem_fn_const_or_non<_Tp, false>\n-    {\n-      typedef _Tp& type;\n-    };\n+  template<typename _MemberPointer>\n+    class _Mem_fn;\n \n   /**\n    * Derives from @c unary_function or @c binary_function, or perhaps\n@@ -639,6 +695,18 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n     };\n \n \n+  template<typename _Tp, bool>\n+    struct _Mem_fn_const_or_non\n+    {\n+      typedef const _Tp& type;\n+    };\n+\n+  template<typename _Tp>\n+    struct _Mem_fn_const_or_non<_Tp, false>\n+    {\n+      typedef _Tp& type;\n+    };\n+\n   template<typename _Res, typename _Class>\n     class _Mem_fn<_Res _Class::*>\n     {"}, {"sha": "911e9a944adaa363238f816b5ddec3f8e6b7283c", "filename": "libstdc++-v3/testsuite/20_util/reference_wrapper/result_type.cc", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cfaf4c938c34b48f7102b539d6db44851bf3ac4/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Freference_wrapper%2Fresult_type.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cfaf4c938c34b48f7102b539d6db44851bf3ac4/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Freference_wrapper%2Fresult_type.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Freference_wrapper%2Fresult_type.cc?ref=8cfaf4c938c34b48f7102b539d6db44851bf3ac4", "patch": "@@ -0,0 +1,42 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-do compile }\n+\n+// 2010-10-06  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <functional>\n+\n+using namespace std;\n+\n+struct T;\n+\n+reference_wrapper<int(float, ...)>::result_type                       i01;\n+reference_wrapper<int(float, ...) const>::result_type                 i02;\n+reference_wrapper<int(float, ...) volatile>::result_type              i03;\n+reference_wrapper<int(float, ...) const volatile>::result_type        i04;\n+\n+reference_wrapper<int(*)(float, ...)>::result_type                    i05;\n+reference_wrapper<int(* const)(float, ...)>::result_type              i06;\n+reference_wrapper<int(* volatile)(float, ...)>::result_type           i07;\n+reference_wrapper<int(* const volatile)(float, ...)>::result_type     i08;\n+\n+reference_wrapper<int(T::*)(float, ...)>::result_type                 i09;\n+reference_wrapper<int(T::*)(float, ...) const>::result_type           i10;\n+reference_wrapper<int(T::*)(float, ...) volatile>::result_type        i11;\n+reference_wrapper<int(T::*)(float, ...) const volatile>::result_type  i12;"}, {"sha": "8b1b7e3f14e220f1faf24851121c3ab73541e24c", "filename": "libstdc++-v3/testsuite/20_util/reference_wrapper/typedefs-2.cc", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cfaf4c938c34b48f7102b539d6db44851bf3ac4/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Freference_wrapper%2Ftypedefs-2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cfaf4c938c34b48f7102b539d6db44851bf3ac4/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Freference_wrapper%2Ftypedefs-2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Freference_wrapper%2Ftypedefs-2.cc?ref=8cfaf4c938c34b48f7102b539d6db44851bf3ac4", "patch": "@@ -0,0 +1,69 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-do compile }\n+\n+// 2010-10-06  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <functional>\n+\n+using namespace std;\n+\n+reference_wrapper<int(float)>::argument_type                               i01;\n+reference_wrapper<int(float) const>::argument_type                         i02;\n+reference_wrapper<int(float) volatile>::argument_type                      i03;\n+reference_wrapper<int(float) const volatile>::argument_type                i04;\n+reference_wrapper<int(float)>::result_type                                 i05;\n+reference_wrapper<int(float) const>::result_type                           i06;\n+reference_wrapper<int(float) volatile>::result_type                        i07;\n+reference_wrapper<int(float) const volatile>::result_type                  i08;\n+\n+reference_wrapper<int(*)(float)>::argument_type                            i09;\n+reference_wrapper<int(* const)(float)>::argument_type                      i10;\n+reference_wrapper<int(* volatile)(float)>::argument_type                   i11;\n+reference_wrapper<int(* const volatile)(float)>::argument_type             i12;\n+reference_wrapper<int(*)(float)>::result_type                              i13;\n+reference_wrapper<int(* const)(float)>::result_type                        i14;\n+reference_wrapper<int(* volatile)(float)>::result_type                     i15;\n+reference_wrapper<int(* const volatile)(float)>::result_type               i16;\n+\n+reference_wrapper<int(float, char)>::first_argument_type                   i17;\n+reference_wrapper<int(float, char) const>::first_argument_type             i18;\n+reference_wrapper<int(float, char) volatile>::first_argument_type          i19;\n+reference_wrapper<int(float, char) const volatile>::first_argument_type    i20;\n+reference_wrapper<int(float, char)>::second_argument_type                  i21;\n+reference_wrapper<int(float, char) const>::second_argument_type            i22;\n+reference_wrapper<int(float, char) volatile>::second_argument_type         i23;\n+reference_wrapper<int(float, char) const volatile>::second_argument_type   i24;\n+reference_wrapper<int(float, char)>::result_type                           i25;\n+reference_wrapper<int(float, char) const>::result_type                     i26;\n+reference_wrapper<int(float, char) volatile>::result_type                  i27;\n+reference_wrapper<int(float, char) const volatile>::result_type            i28;\n+\n+reference_wrapper<int(*)(float, char)>::first_argument_type                i29;\n+reference_wrapper<int(* const)(float, char)>::first_argument_type          i30;\n+reference_wrapper<int(* volatile)(float, char)>::first_argument_type       i31;\n+reference_wrapper<int(* const volatile)(float, char)>::first_argument_type i32;\n+reference_wrapper<int(*)(float, char)>::second_argument_type               i33;\n+reference_wrapper<int(* const)(float, char)>::second_argument_type         i34;\n+reference_wrapper<int(* volatile)(float, char)>::second_argument_type      i35;\n+reference_wrapper<int(*const volatile)(float, char)>::second_argument_type i36;\n+reference_wrapper<int(*)(float, char)>::result_type                        i37;\n+reference_wrapper<int(* const)(float, char)>::result_type                  i38;\n+reference_wrapper<int(* volatile)(float, char)>::result_type               i39;\n+reference_wrapper<int(* const volatile)(float, char)>::result_type         i40;"}]}