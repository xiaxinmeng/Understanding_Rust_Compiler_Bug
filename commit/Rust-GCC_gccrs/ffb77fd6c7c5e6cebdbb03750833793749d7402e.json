{"sha": "ffb77fd6c7c5e6cebdbb03750833793749d7402e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmZiNzdmZDZjN2M1ZTZjZWJkYmIwMzc1MDgzMzc5Mzc0OWQ3NDAyZQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2017-04-26T10:31:08Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2017-04-26T10:31:08Z"}, "message": "ipa-cp.c (estimate_local_effects): Convert sreal to int.\n\n\t* ipa-cp.c (estimate_local_effects): Convert sreal to int.\n\t* ipa-inline-analysis.c (MAX_TIME): Remove.\n\t(account_size_time): Use sreal for time.\n\t(dump_inline_summary): Update.\n\t(estimate_function_body_sizes): Update.\n\t(estimate_edge_size_and_time): Update.\n\t(estimate_calls_size_and_time): Update.\n\t(estimate_node_size_and_time): Update.\n\t(inline_merge_summary): Update.\n\t(inline_update_overall_summary): Update.\n\t(estimate_time_after_inlining): Update.\n\t(inline_read_section): Update.\n\t(inline_write_summary): Update.\n\t* ipa-inline.c (compute_uninlined_call_time): Update.\n\t(compute_inlined_call_time): Update.\n\t(recursive_inlining): Update.\n\t(inline_small_functions): Update.\n\t(dump_overall_stats): Update.\n\t* ipa-inline.h: Include sreal.h.\n\t(size_time_entry): Turn time to sreal.\n\t(inline_summary): Turn self_time nad time to sreal.\n\nFrom-SVN: r247277", "tree": {"sha": "a3dec9b6607771a4f930efc665f8829ca9a92d3e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a3dec9b6607771a4f930efc665f8829ca9a92d3e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ffb77fd6c7c5e6cebdbb03750833793749d7402e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ffb77fd6c7c5e6cebdbb03750833793749d7402e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ffb77fd6c7c5e6cebdbb03750833793749d7402e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ffb77fd6c7c5e6cebdbb03750833793749d7402e/comments", "author": null, "committer": null, "parents": [{"sha": "8a267096506388a0165d869daa42607b8bf96583", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a267096506388a0165d869daa42607b8bf96583", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a267096506388a0165d869daa42607b8bf96583"}], "stats": {"total": 144, "additions": 79, "deletions": 65}, "files": [{"sha": "4d20754226319ad3b938515c586deece60a7c180", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffb77fd6c7c5e6cebdbb03750833793749d7402e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffb77fd6c7c5e6cebdbb03750833793749d7402e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ffb77fd6c7c5e6cebdbb03750833793749d7402e", "patch": "@@ -1,3 +1,27 @@\n+2017-04-25  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* ipa-cp.c (estimate_local_effects): Convert sreal to int.\n+\t* ipa-inline-analysis.c (MAX_TIME): Remove.\n+\t(account_size_time): Use sreal for time.\n+\t(dump_inline_summary): Update.\n+\t(estimate_function_body_sizes): Update.\n+\t(estimate_edge_size_and_time): Update.\n+\t(estimate_calls_size_and_time): Update.\n+\t(estimate_node_size_and_time): Update.\n+\t(inline_merge_summary): Update.\n+\t(inline_update_overall_summary): Update.\n+\t(estimate_time_after_inlining): Update.\n+\t(inline_read_section): Update.\n+\t(inline_write_summary): Update.\n+\t* ipa-inline.c (compute_uninlined_call_time): Update.\n+\t(compute_inlined_call_time): Update.\n+\t(recursive_inlining): Update.\n+\t(inline_small_functions): Update.\n+\t(dump_overall_stats): Update.\n+\t* ipa-inline.h: Include sreal.h.\n+\t(size_time_entry): Turn time to sreal.\n+\t(inline_summary): Turn self_time nad time to sreal.\n+\n 2017-04-25  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* sreal.c: Include backend.h, tree.h, gimple.h, cgraph.h and"}, {"sha": "d31e2c30a4687c1ec54bc366a52a0c89225b6cbf", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffb77fd6c7c5e6cebdbb03750833793749d7402e/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffb77fd6c7c5e6cebdbb03750833793749d7402e/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=ffb77fd6c7c5e6cebdbb03750833793749d7402e", "patch": "@@ -2832,7 +2832,7 @@ estimate_local_effects (struct cgraph_node *node)\n   vec<ipa_agg_jump_function> known_aggs;\n   vec<ipa_agg_jump_function_p> known_aggs_ptrs;\n   bool always_const;\n-  int base_time = inline_summaries->get (node)->time;\n+  int base_time = inline_summaries->get (node)->time.to_int ();\n   int removable_params_cost;\n \n   if (!count || !ipcp_versionable_function_p (node))"}, {"sha": "2cf594429bb62d62dcbec40c7e5240347938a510", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 28, "deletions": 52, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffb77fd6c7c5e6cebdbb03750833793749d7402e/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffb77fd6c7c5e6cebdbb03750833793749d7402e/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=ffb77fd6c7c5e6cebdbb03750833793749d7402e", "patch": "@@ -96,11 +96,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cfgexpand.h\"\n #include \"gimplify.h\"\n \n-/* Estimate runtime of function can easilly run into huge numbers with many\n-   nested loops.  Be sure we can compute time * INLINE_SIZE_SCALE * 2 in an\n-   integer.  For anything larger we use gcov_type.  */\n-#define MAX_TIME 500000\n-\n /* Number of bits in integer, but we really want to be stable across different\n    hosts.  */\n #define NUM_CONDITIONS 32\n@@ -668,7 +663,7 @@ dump_inline_hints (FILE *f, inline_hints hints)\n /* Record SIZE and TIME under condition PRED into the inline summary.  */\n \n static void\n-account_size_time (struct inline_summary *summary, int size, int time,\n+account_size_time (struct inline_summary *summary, int size, sreal time,\n \t\t   struct predicate *pred)\n {\n   size_time_entry *e;\n@@ -680,12 +675,9 @@ account_size_time (struct inline_summary *summary, int size, int time,\n \n   /* We need to create initial empty unconitional clause, but otherwie\n      we don't need to account empty times and sizes.  */\n-  if (!size && !time && summary->entry)\n+  if (!size && time == 0 && summary->entry)\n     return;\n \n-  /* Watch overflow that might result from insane profiles.  */\n-  if (time > MAX_TIME * INLINE_TIME_SCALE)\n-    time = MAX_TIME * INLINE_TIME_SCALE;\n   gcc_assert (time >= 0);\n \n   for (i = 0; vec_safe_iterate (summary->entry, i, &e); i++)\n@@ -705,12 +697,12 @@ account_size_time (struct inline_summary *summary, int size, int time,\n \t\t \"\\t\\tReached limit on number of entries, \"\n \t\t \"ignoring the predicate.\");\n     }\n-  if (dump_file && (dump_flags & TDF_DETAILS) && (time || size))\n+  if (dump_file && (dump_flags & TDF_DETAILS) && (time != 0 || size))\n     {\n       fprintf (dump_file,\n \t       \"\\t\\tAccounting size:%3.2f, time:%3.2f on %spredicate:\",\n \t       ((double) size) / INLINE_SIZE_SCALE,\n-\t       ((double) time) / INLINE_TIME_SCALE, found ? \"\" : \"new \");\n+\t       (time.to_double ()) / INLINE_TIME_SCALE, found ? \"\" : \"new \");\n       dump_predicate (dump_file, summary->conds, pred);\n     }\n   if (!found)\n@@ -725,8 +717,6 @@ account_size_time (struct inline_summary *summary, int size, int time,\n     {\n       e->size += size;\n       e->time += time;\n-      if (e->time > MAX_TIME * INLINE_TIME_SCALE)\n-\te->time = MAX_TIME * INLINE_TIME_SCALE;\n     }\n }\n \n@@ -1048,7 +1038,8 @@ reset_inline_summary (struct cgraph_node *node,\n {\n   struct cgraph_edge *e;\n \n-  info->self_size = info->self_time = 0;\n+  info->self_size = 0;\n+  info->self_time = 0;\n   info->estimated_stack_size = 0;\n   info->estimated_self_stack_size = 0;\n   info->stack_frame_offset = 0;\n@@ -1434,8 +1425,8 @@ dump_inline_summary (FILE *f, struct cgraph_node *node)\n \tfprintf (f, \" contains_cilk_spawn\");\n       if (s->fp_expressions)\n \tfprintf (f, \" fp_expression\");\n-      fprintf (f, \"\\n  self time:       %i\\n\", s->self_time);\n-      fprintf (f, \"  global time:     %i\\n\", s->time);\n+      fprintf (f, \"\\n  self time:       %f\\n\", s->self_time.to_double ());\n+      fprintf (f, \"  global time:     %f\\n\", s->time.to_double ());\n       fprintf (f, \"  self size:       %i\\n\", s->self_size);\n       fprintf (f, \"  global size:     %i\\n\", s->size);\n       fprintf (f, \"  min size:       %i\\n\", s->min_size);\n@@ -1450,7 +1441,7 @@ dump_inline_summary (FILE *f, struct cgraph_node *node)\n \t{\n \t  fprintf (f, \"    size:%f, time:%f, predicate:\",\n \t\t   (double) e->size / INLINE_SIZE_SCALE,\n-\t\t   (double) e->time / INLINE_TIME_SCALE);\n+\t\t   e->time.to_double () / INLINE_TIME_SCALE);\n \t  dump_predicate (f, s->conds, &e->predicate);\n \t}\n       if (s->loop_iterations)\n@@ -2534,7 +2525,7 @@ fp_expression_p (gimple *stmt)\n static void\n estimate_function_body_sizes (struct cgraph_node *node, bool early)\n {\n-  gcov_type time = 0;\n+  sreal time = 0;\n   /* Estimate static overhead for function prologue/epilogue and alignment. */\n   int size = 2;\n   /* Benefits are scaled by probability of elimination that is in range\n@@ -2780,8 +2771,6 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n \t\t{\n \t\t  time += this_time;\n \t\t  size += this_size;\n-\t\t  if (time > MAX_TIME * INLINE_TIME_SCALE)\n-\t\t    time = MAX_TIME * INLINE_TIME_SCALE;\n \t\t}\n \n \t      /* We account everything but the calls.  Calls have their own\n@@ -2814,9 +2803,7 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n \t}\n     }\n   set_hint_predicate (&inline_summaries->get (node)->array_index, array_index);\n-  time = (time + CGRAPH_FREQ_BASE / 2) / CGRAPH_FREQ_BASE;\n-  if (time > MAX_TIME)\n-    time = MAX_TIME;\n+  time = time / CGRAPH_FREQ_BASE;\n   free (order);\n \n   if (nonconstant_names.exists () && !early)\n@@ -3167,7 +3154,7 @@ estimate_edge_devirt_benefit (struct cgraph_edge *ie,\n \n static inline void\n estimate_edge_size_and_time (struct cgraph_edge *e, int *size, int *min_size,\n-\t\t\t     int *time,\n+\t\t\t     sreal *time,\n \t\t\t     int prob,\n \t\t\t     vec<tree> known_vals,\n \t\t\t     vec<ipa_polymorphic_call_context> known_contexts,\n@@ -3187,10 +3174,8 @@ estimate_edge_size_and_time (struct cgraph_edge *e, int *size, int *min_size,\n   *size += cur_size;\n   if (min_size)\n     *min_size += cur_size;\n-  *time += apply_probability ((gcov_type) call_time, prob)\n+  *time += call_time * prob / REG_BR_PROB_BASE\n     * e->frequency * (INLINE_TIME_SCALE / CGRAPH_FREQ_BASE);\n-  if (*time > MAX_TIME * INLINE_TIME_SCALE)\n-    *time = MAX_TIME * INLINE_TIME_SCALE;\n }\n \n \n@@ -3201,7 +3186,7 @@ estimate_edge_size_and_time (struct cgraph_edge *e, int *size, int *min_size,\n \n static void\n estimate_calls_size_and_time (struct cgraph_node *node, int *size,\n-\t\t\t      int *min_size, int *time,\n+\t\t\t      int *min_size, sreal *time,\n \t\t\t      inline_hints *hints,\n \t\t\t      clause_t possible_truths,\n \t\t\t      vec<tree> known_vals,\n@@ -3283,7 +3268,7 @@ estimate_node_size_and_time (struct cgraph_node *node,\n   struct inline_summary *info = inline_summaries->get (node);\n   size_time_entry *e;\n   int size = 0;\n-  int time = 0;\n+  sreal time = 0;\n   int min_size = 0;\n   inline_hints hints = 0;\n   int i;\n@@ -3323,10 +3308,8 @@ estimate_node_size_and_time (struct cgraph_node *node,\n \t\t\t\t\t      inline_param_summary);\n \t    gcc_checking_assert (prob >= 0);\n \t    gcc_checking_assert (prob <= REG_BR_PROB_BASE);\n-\t    time += apply_probability ((gcov_type) e->time, prob);\n+\t    time += e->time * prob / REG_BR_PROB_BASE;\n \t  }\n-\tif (time > MAX_TIME * INLINE_TIME_SCALE)\n-\t  time = MAX_TIME * INLINE_TIME_SCALE;\n \tgcc_checking_assert (time >= 0);\n \n       }\n@@ -3358,9 +3341,9 @@ estimate_node_size_and_time (struct cgraph_node *node,\n   min_size = RDIV (min_size, INLINE_SIZE_SCALE);\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n-    fprintf (dump_file, \"\\n   size:%i time:%i\\n\", (int) size, (int) time);\n+    fprintf (dump_file, \"\\n   size:%i time:%f\\n\", (int) size, time.to_double ());\n   if (ret_time)\n-    *ret_time = time;\n+    *ret_time = time.to_int ();\n   if (ret_size)\n     *ret_size = size;\n   if (ret_min_size)\n@@ -3727,14 +3710,11 @@ inline_merge_summary (struct cgraph_edge *edge)\n \t\t\t\t\t    &toplev_predicate);\n       if (!false_predicate_p (&p))\n \t{\n-\t  gcov_type add_time = ((gcov_type) e->time * edge->frequency\n-\t\t\t\t+ CGRAPH_FREQ_BASE / 2) / CGRAPH_FREQ_BASE;\n+\t  sreal add_time = e->time * edge->frequency / CGRAPH_FREQ_BASE;\n \t  int prob = predicate_probability (callee_info->conds,\n \t\t\t\t\t    &e->predicate,\n \t\t\t\t\t    clause, es->param);\n-\t  add_time = apply_probability ((gcov_type) add_time, prob);\n-\t  if (add_time > MAX_TIME * INLINE_TIME_SCALE)\n-\t    add_time = MAX_TIME * INLINE_TIME_SCALE;\n+\t  add_time = add_time * prob / REG_BR_PROB_BASE;\n \t  if (prob != REG_BR_PROB_BASE\n \t      && dump_file && (dump_flags & TDF_DETAILS))\n \t    {\n@@ -3782,14 +3762,12 @@ inline_update_overall_summary (struct cgraph_node *node)\n   for (i = 0; vec_safe_iterate (info->entry, i, &e); i++)\n     {\n       info->size += e->size, info->time += e->time;\n-      if (info->time > MAX_TIME * INLINE_TIME_SCALE)\n-\tinfo->time = MAX_TIME * INLINE_TIME_SCALE;\n     }\n   estimate_calls_size_and_time (node, &info->size, &info->min_size,\n \t\t\t\t&info->time, NULL,\n \t\t\t\t~(clause_t) (1 << predicate_false_condition),\n \t\t\t\tvNULL, vNULL, vNULL);\n-  info->time = (info->time + INLINE_TIME_SCALE / 2) / INLINE_TIME_SCALE;\n+  info->time = info->time / INLINE_TIME_SCALE;\n   info->size = (info->size + INLINE_SIZE_SCALE / 2) / INLINE_SIZE_SCALE;\n }\n \n@@ -3965,15 +3943,13 @@ estimate_time_after_inlining (struct cgraph_node *node,\n   struct inline_edge_summary *es = inline_edge_summary (edge);\n   if (!es->predicate || !false_predicate_p (es->predicate))\n     {\n-      gcov_type time =\n+      sreal time =\n \tinline_summaries->get (node)->time + estimate_edge_time (edge);\n       if (time < 0)\n \ttime = 0;\n-      if (time > MAX_TIME)\n-\ttime = MAX_TIME;\n-      return time;\n+      return time.to_int ();\n     }\n-  return inline_summaries->get (node)->time;\n+  return inline_summaries->get (node)->time.to_int ();\n }\n \n \n@@ -4317,7 +4293,7 @@ inline_read_section (struct lto_file_decl_data *file_data, const char *data,\n       info->estimated_stack_size\n \t= info->estimated_self_stack_size = streamer_read_uhwi (&ib);\n       info->size = info->self_size = streamer_read_uhwi (&ib);\n-      info->time = info->self_time = streamer_read_uhwi (&ib);\n+      info->time = info->self_time = sreal::stream_in (&ib);\n \n       bp = streamer_read_bitpack (&ib);\n       info->inlinable = bp_unpack_value (&bp, 1);\n@@ -4347,7 +4323,7 @@ inline_read_section (struct lto_file_decl_data *file_data, const char *data,\n \t  struct size_time_entry e;\n \n \t  e.size = streamer_read_uhwi (&ib);\n-\t  e.time = streamer_read_uhwi (&ib);\n+\t  e.time = sreal::stream_in (&ib);\n \t  e.predicate = read_predicate (&ib);\n \n \t  vec_safe_push (info->entry, e);\n@@ -4482,7 +4458,7 @@ inline_write_summary (void)\n \t  streamer_write_uhwi (ob, lto_symtab_encoder_encode (encoder, cnode));\n \t  streamer_write_hwi (ob, info->estimated_self_stack_size);\n \t  streamer_write_hwi (ob, info->self_size);\n-\t  streamer_write_hwi (ob, info->self_time);\n+\t  info->self_time.stream_out (ob);\n \t  bp = bitpack_create (ob->main_stream);\n \t  bp_pack_value (&bp, info->inlinable, 1);\n \t  bp_pack_value (&bp, info->contains_cilk_spawn, 1);\n@@ -4506,7 +4482,7 @@ inline_write_summary (void)\n \t  for (i = 0; vec_safe_iterate (info->entry, i, &e); i++)\n \t    {\n \t      streamer_write_uhwi (ob, e->size);\n-\t      streamer_write_uhwi (ob, e->time);\n+\t      e->time.stream_out (ob);\n \t      write_predicate (ob, &e->predicate);\n \t    }\n \t  write_predicate (ob, info->loop_iterations);"}, {"sha": "f50d29b6a5dac61ae24b4cac58135a8e047e87b4", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 21, "deletions": 9, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffb77fd6c7c5e6cebdbb03750833793749d7402e/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffb77fd6c7c5e6cebdbb03750833793749d7402e/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=ffb77fd6c7c5e6cebdbb03750833793749d7402e", "patch": "@@ -654,7 +654,7 @@ compute_uninlined_call_time (struct inline_summary *callee_info,\n   else\n     uninlined_call_time = uninlined_call_time >> 11;\n \n-  int caller_time = inline_summaries->get (caller)->time;\n+  sreal caller_time = inline_summaries->get (caller)->time;\n   return uninlined_call_time + caller_time;\n }\n \n@@ -668,7 +668,7 @@ compute_inlined_call_time (struct cgraph_edge *edge,\n   cgraph_node *caller = (edge->caller->global.inlined_to \n \t\t\t ? edge->caller->global.inlined_to\n \t\t\t : edge->caller);\n-  int caller_time = inline_summaries->get (caller)->time;\n+  sreal caller_time = inline_summaries->get (caller)->time;\n   sreal time = edge_time;\n \n   if (edge->count && caller->count)\n@@ -753,6 +753,14 @@ want_inline_small_function_p (struct cgraph_edge *e, bool report)\n       int growth = estimate_edge_growth (e);\n       inline_hints hints = estimate_edge_hints (e);\n       bool big_speedup = big_speedup_p (e);\n+/*\n+\tfprintf (stderr, \"%i %i %i\\n\",growth,hints,big_speedup);\n+\tdump_inline_summary (stderr, e->caller->global.inlined_to ? e->caller->global.inlined_to : e->caller);\n+\tdump_inline_summary (stderr, e->callee);\n+  sreal time = compute_uninlined_call_time (inline_summaries->get (e->callee),\n+\t\t\t\t\t    e);\n+  sreal inlined_time = compute_inlined_call_time (e, estimate_edge_time (e));\n+ fprintf (stderr, \"%f %f\\n\", time.to_double (), inlined_time.to_double ());*/\n \n       if (growth <= 0)\n \t;\n@@ -1023,7 +1031,9 @@ edge_badness (struct cgraph_edge *edge, bool dump)\n   edge_time = estimate_edge_time (edge);\n   hints = estimate_edge_hints (edge);\n   gcc_checking_assert (edge_time >= 0);\n-  gcc_checking_assert (edge_time <= callee_info->time);\n+  /* FIXME: -1 to care of rounding issues should go away once cache is migrated.\n+     to sreals.  */\n+  gcc_checking_assert (edge_time - 1 <= callee_info->time);\n   gcc_checking_assert (growth <= callee_info->size);\n \n   if (dump)\n@@ -1554,9 +1564,11 @@ recursive_inlining (struct cgraph_edge *edge,\n   if (dump_file)\n     fprintf (dump_file,\n \t     \"\\n   Inlined %i times, \"\n-\t     \"body grown from size %i to %i, time %i to %i\\n\", n,\n-\t     inline_summaries->get (master_clone)->size, inline_summaries->get (node)->size,\n-\t     inline_summaries->get (master_clone)->time, inline_summaries->get (node)->time);\n+\t     \"body grown from size %i to %i, time %f to %f\\n\", n,\n+\t     inline_summaries->get (master_clone)->size,\n+\t     inline_summaries->get (node)->size,\n+\t     inline_summaries->get (master_clone)->time.to_double (),\n+\t     inline_summaries->get (node)->time.to_double ());\n \n   /* Remove master clone we used for inlining.  We rely that clones inlined\n      into master clone gets queued just before master clone so we don't\n@@ -2052,10 +2064,10 @@ inline_small_functions (void)\n       if (dump_file)\n \t{\n \t  fprintf (dump_file,\n-\t\t   \" Inlined into %s which now has time %i and size %i, \"\n+\t\t   \" Inlined into %s which now has time %f and size %i, \"\n \t\t   \"net change of %+i.\\n\",\n \t\t   edge->caller->name (),\n-\t\t   inline_summaries->get (edge->caller)->time,\n+\t\t   inline_summaries->get (edge->caller)->time.to_double (),\n \t\t   inline_summaries->get (edge->caller)->size,\n \t\t   overall_size - old_size);\n \t}\n@@ -2245,7 +2257,7 @@ dump_overall_stats (void)\n     if (!node->global.inlined_to\n \t&& !node->alias)\n       {\n-\tint time = inline_summaries->get (node)->time;\n+\tint time = inline_summaries->get (node)->time.to_double ();\n \tsum += time;\n \tsum_weighted += time * node->count;\n       }"}, {"sha": "077f0cc936baf65bc7f3db41f00dc45ce563b514", "filename": "gcc/ipa-inline.h", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffb77fd6c7c5e6cebdbb03750833793749d7402e/gcc%2Fipa-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffb77fd6c7c5e6cebdbb03750833793749d7402e/gcc%2Fipa-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.h?ref=ffb77fd6c7c5e6cebdbb03750833793749d7402e", "patch": "@@ -21,6 +21,8 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_IPA_INLINE_H\n #define GCC_IPA_INLINE_H\n \n+#include \"sreal.h\"\n+\n \n /* Representation of inline parameters that do depend on context function is\n    inlined into (i.e. known constant values of function parameters.\n@@ -109,7 +111,7 @@ struct GTY(()) size_time_entry\n {\n   struct predicate predicate;\n   int size;\n-  int time;\n+  sreal GTY((skip)) time;\n };\n \n /* Function inlining information.  */\n@@ -122,7 +124,7 @@ struct GTY(()) inline_summary\n   /* Size of the function body.  */\n   int self_size;\n   /* Time of the function body.  */\n-  int self_time;\n+  sreal GTY((skip)) self_time;\n   /* Minimal size increase after inlining.  */\n   int min_size;\n \n@@ -146,7 +148,7 @@ struct GTY(()) inline_summary\n   /* Expected offset of the stack frame of inlined function.  */\n   HOST_WIDE_INT stack_frame_offset;\n   /* Estimated size of the function after inlining.  */\n-  int time;\n+  sreal GTY((skip)) time;\n   int size;\n \n   /* Conditional size/time information.  The summaries are being"}]}