{"sha": "7fcb18047a53780b572b72c964d1df9cddec1660", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2ZjYjE4MDQ3YTUzNzgwYjU3MmI3MmM5NjRkMWRmOWNkZGVjMTY2MA==", "commit": {"author": {"name": "Tobias Schl\u00fcter", "email": "tobi@gcc.gnu.org", "date": "2004-08-23T14:28:31Z"}, "committer": {"name": "Tobias Schl\u00fcter", "email": "tobi@gcc.gnu.org", "date": "2004-08-23T14:28:31Z"}, "message": "io.h, [...]: Fix formatting issues, update copyright years.\n\n* io/io.h, io/list_read.c, io/open.c, io/transfer.c, io/write.c:\nFix formatting issues, update copyright years.\n\nFrom-SVN: r86425", "tree": {"sha": "0f798efffa4545365420b55d47237058cfaa04c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0f798efffa4545365420b55d47237058cfaa04c6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7fcb18047a53780b572b72c964d1df9cddec1660", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7fcb18047a53780b572b72c964d1df9cddec1660", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7fcb18047a53780b572b72c964d1df9cddec1660", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7fcb18047a53780b572b72c964d1df9cddec1660/comments", "author": {"login": "TobiSchluter", "id": 11887541, "node_id": "MDQ6VXNlcjExODg3NTQx", "avatar_url": "https://avatars.githubusercontent.com/u/11887541?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TobiSchluter", "html_url": "https://github.com/TobiSchluter", "followers_url": "https://api.github.com/users/TobiSchluter/followers", "following_url": "https://api.github.com/users/TobiSchluter/following{/other_user}", "gists_url": "https://api.github.com/users/TobiSchluter/gists{/gist_id}", "starred_url": "https://api.github.com/users/TobiSchluter/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TobiSchluter/subscriptions", "organizations_url": "https://api.github.com/users/TobiSchluter/orgs", "repos_url": "https://api.github.com/users/TobiSchluter/repos", "events_url": "https://api.github.com/users/TobiSchluter/events{/privacy}", "received_events_url": "https://api.github.com/users/TobiSchluter/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TobiSchluter", "id": 11887541, "node_id": "MDQ6VXNlcjExODg3NTQx", "avatar_url": "https://avatars.githubusercontent.com/u/11887541?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TobiSchluter", "html_url": "https://github.com/TobiSchluter", "followers_url": "https://api.github.com/users/TobiSchluter/followers", "following_url": "https://api.github.com/users/TobiSchluter/following{/other_user}", "gists_url": "https://api.github.com/users/TobiSchluter/gists{/gist_id}", "starred_url": "https://api.github.com/users/TobiSchluter/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TobiSchluter/subscriptions", "organizations_url": "https://api.github.com/users/TobiSchluter/orgs", "repos_url": "https://api.github.com/users/TobiSchluter/repos", "events_url": "https://api.github.com/users/TobiSchluter/events{/privacy}", "received_events_url": "https://api.github.com/users/TobiSchluter/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b3d1f5b404c57db42824d112f3368d76e1711e11", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3d1f5b404c57db42824d112f3368d76e1711e11", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b3d1f5b404c57db42824d112f3368d76e1711e11"}], "stats": {"total": 695, "additions": 346, "deletions": 349}, "files": [{"sha": "796a6247f21e26d728e68b1fb54ea95e536a4fc4", "filename": "libgfortran/io/io.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fcb18047a53780b572b72c964d1df9cddec1660/libgfortran%2Fio%2Fio.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fcb18047a53780b572b72c964d1df9cddec1660/libgfortran%2Fio%2Fio.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fio.h?ref=7fcb18047a53780b572b72c964d1df9cddec1660", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 2002-2003 Free Software Foundation, Inc.\n+/* Copyright (C) 2002, 2003, 2004 Free Software Foundation, Inc.\n    Contributed by Andy Vaught\n \n This file is part of the GNU Fortran 95 runtime library (libgfortran)."}, {"sha": "95b5b8834915e2d923ff7eb90b7eb54805fe00b7", "filename": "libgfortran/io/list_read.c", "status": "modified", "additions": 93, "deletions": 97, "changes": 190, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fcb18047a53780b572b72c964d1df9cddec1660/libgfortran%2Fio%2Flist_read.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fcb18047a53780b572b72c964d1df9cddec1660/libgfortran%2Fio%2Flist_read.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Flist_read.c?ref=7fcb18047a53780b572b72c964d1df9cddec1660", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 2002-2003 Free Software Foundation, Inc.\n+/* Copyright (C) 2002, 2003, 2004 Free Software Foundation, Inc.\n    Contributed by Andy Vaught\n \n This file is part of the GNU Fortran 95 runtime library (libgfortran).\n@@ -27,19 +27,19 @@ Boston, MA 02111-1307, USA.  */\n \n \n /* List directed input.  Several parsing subroutines are practically\n- * reimplemented from formatted input, the reason being that there are\n- * all kinds of small differences between formatted and list directed\n- * parsing. */\n+   reimplemented from formatted input, the reason being that there are\n+   all kinds of small differences between formatted and list directed\n+   parsing.  */\n \n \n /* Subroutines for reading characters from the input.  Because a\n- * repeat count is ambiguous with an integer, we have to read the\n- * whole digit string before seeing if there is a '*' which signals\n- * the repeat count.  Since we can have a lot of potential leading\n- * zeros, we have to be able to back up by arbitrary amount.  Because\n- * the input might not be seekable, we have to buffer the data\n- * ourselves.  Data is buffered in scratch[] until it becomes too\n- * large, after which we start allocating memory on the heap.  */\n+   repeat count is ambiguous with an integer, we have to read the\n+   whole digit string before seeing if there is a '*' which signals\n+   the repeat count.  Since we can have a lot of potential leading\n+   zeros, we have to be able to back up by arbitrary amount.  Because\n+   the input might not be seekable, we have to buffer the data\n+   ourselves.  Data is buffered in scratch[] until it becomes too\n+   large, after which we start allocating memory on the heap.  */\n \n static int repeat_count, saved_length, saved_used, input_complete, at_eol;\n static int comma_flag, namelist_mode;\n@@ -50,7 +50,7 @@ static bt saved_type;\n \n \n /* Storage area for values except for strings.  Must be large enough\n- * to hold a complex value (two reals) of the largest kind */\n+   to hold a complex value (two reals) of the largest kind.  */\n \n static char value[20];\n \n@@ -59,18 +59,17 @@ static char value[20];\n \n #define CASE_SEPARATORS  case ' ': case ',': case '/': case '\\n': case '\\t'\n \n-/* This macro assumes that we're operating on a variable */\n+/* This macro assumes that we're operating on a variable.  */\n \n #define is_separator(c) (c == '/' ||  c == ',' || c == '\\n' || c == ' ' \\\n                          || c == '\\t')\n \n-/* Maximum repeat count.  Less than ten times the maximum signed int32. */\n+/* Maximum repeat count.  Less than ten times the maximum signed int32.  */\n \n #define MAX_REPEAT 200000000\n \n \n-/* push_char()-- Save a character to a string buffer, enlarging it as\n- * necessary. */\n+/* Save a character to a string buffer, enlarging it as necessary.  */\n \n static void\n push_char (char c)\n@@ -103,7 +102,7 @@ push_char (char c)\n }\n \n \n-/* free_saved()-- Free the input buffer if necessary. */\n+/* Free the input buffer if necessary.  */\n \n static void\n free_saved (void)\n@@ -152,7 +151,7 @@ next_char (void)\n }\n \n \n-/* unget_char()-- Push a character back onto the input */\n+/* Push a character back onto the input.  */\n \n static void\n unget_char (char c)\n@@ -162,9 +161,8 @@ unget_char (char c)\n }\n \n \n-/* eat_spaces()-- Skip over spaces in the input.  Returns the nonspace\n- * character that terminated the eating and also places it back on the\n- * input. */\n+/* Skip over spaces in the input.  Returns the nonspace character that\n+   terminated the eating and also places it back on the input.  */\n \n static char\n eat_spaces (void)\n@@ -182,17 +180,16 @@ eat_spaces (void)\n }\n \n \n-/* eat_separator()-- Skip over a separator.  Technically, we don't\n- * always eat the whole separator.  This is because if we've processed\n- * the last input item, then a separator is unnecessary.  Plus the\n- * fact that operating systems usually deliver console input on a line\n- * basis.\n- *\n- * The upshot is that if we see a newline as part of reading a\n- * separator, we stop reading.  If there are more input items, we\n- * continue reading the separator with finish_separator() which takes\n- * care of the fact that we may or may not have seen a comma as part\n- * of the separator. */\n+/* Skip over a separator.  Technically, we don't always eat the whole\n+   separator.  This is because if we've processed the last input item,\n+   then a separator is unnecessary.  Plus the fact that operating\n+   systems usually deliver console input on a line basis.\n+\n+   The upshot is that if we see a newline as part of reading a\n+   separator, we stop reading.  If there are more input items, we\n+   continue reading the separator with finish_separator() which takes\n+   care of the fact that we may or may not have seen a comma as part\n+   of the separator.  */\n \n static void\n eat_separator (void)\n@@ -220,15 +217,15 @@ eat_separator (void)\n \n     case '!':\n       if (namelist_mode)\n-\t{\t\t\t/* Eat a namelist comment */\n+\t{\t\t\t/* Eat a namelist comment.  */\n \t  do\n \t    c = next_char ();\n \t  while (c != '\\n');\n \n \t  break;\n \t}\n \n-      /* Fall Through */\n+      /* Fall Through...  */\n \n     default:\n       unget_char (c);\n@@ -237,9 +234,9 @@ eat_separator (void)\n }\n \n \n-/* finish_separator()-- Finish processing a separator that was\n- * interrupted by a newline.  If we're here, then another data item is\n- * present, so we finish what we started on the previous line. */\n+/* Finish processing a separator that was interrupted by a newline.\n+   If we're here, then another data item is present, so we finish what\n+   we started on the previous line.  */\n \n static void\n finish_separator (void)\n@@ -289,10 +286,9 @@ finish_separator (void)\n }\n \n \n-/* convert_integer()-- Convert an unsigned string to an integer.  The\n- * length value is -1 if we are working on a repeat count.  Returns\n- * nonzero if we have a range problem.  As a side effect, frees the\n- * saved_string. */\n+/* Convert an unsigned string to an integer.  The length value is -1\n+   if we are working on a repeat count.  Returns nonzero if we have a\n+   range problem.  As a side effect, frees the saved_string.  */\n \n static int\n convert_integer (int length, int negative)\n@@ -363,9 +359,9 @@ convert_integer (int length, int negative)\n }\n \n \n-/* parse_repeat()-- Parse a repeat count for logical and complex\n- * values which cannot begin with a digit.  Returns nonzero if we are\n- * done, zero if we should continue on. */\n+/* Parse a repeat count for logical and complex values which cannot\n+   begin with a digit.  Returns nonzero if we are done, zero if we\n+   should continue on.  */\n \n static int\n parse_repeat (void)\n@@ -441,7 +437,7 @@ parse_repeat (void)\n }\n \n \n-/* read_logical()-- Read a logical character on the input */\n+/* Read a logical character on the input.  */\n \n static void\n read_logical (int length)\n@@ -485,7 +481,7 @@ read_logical (int length)\n     CASE_SEPARATORS:\n       unget_char (c);\n       eat_separator ();\n-      return;\t\t\t/* Null value */\n+      return;\t\t\t/* Null value.  */\n \n     default:\n       goto bad_logical;\n@@ -494,8 +490,7 @@ read_logical (int length)\n   saved_type = BT_LOGICAL;\n   saved_length = length;\n \n-  /* Eat trailing garbage */\n-\n+  /* Eat trailing garbage.  */\n   do\n     {\n       c = next_char ();\n@@ -517,10 +512,10 @@ read_logical (int length)\n }\n \n \n-/* read_integer()-- Reading integers is tricky because we can actually\n- * be reading a repeat count.  We have to store the characters in a\n- * buffer because we could be reading an integer that is larger than the\n- * default int used for repeat counts.  */\n+/* Reading integers is tricky because we can actually be reading a\n+   repeat count.  We have to store the characters in a buffer because\n+   we could be reading an integer that is larger than the default int\n+   used for repeat counts.  */\n \n static void\n read_integer (int length)\n@@ -535,13 +530,13 @@ read_integer (int length)\n     {\n     case '-':\n       negative = 1;\n-      /* Fall through */\n+      /* Fall through...  */\n \n     case '+':\n       c = next_char ();\n       goto get_integer;\n \n-    CASE_SEPARATORS:\t\t/* Single null */\n+    CASE_SEPARATORS:\t\t/* Single null.  */\n       unget_char (c);\n       eat_separator ();\n       return;\n@@ -554,7 +549,7 @@ read_integer (int length)\n       goto bad_integer;\n     }\n \n-  /* Take care of what may be a repeat count */\n+  /* Take care of what may be a repeat count.  */\n \n   for (;;)\n     {\n@@ -569,7 +564,7 @@ read_integer (int length)\n \t  push_char ('\\0');\n \t  goto repeat;\n \n-\tCASE_SEPARATORS:\t/* Not a repeat count */\n+\tCASE_SEPARATORS:\t/* Not a repeat count.  */\n \t  goto done;\n \n \tdefault:\n@@ -581,7 +576,7 @@ read_integer (int length)\n   if (convert_integer (-1, 0))\n     return;\n \n-/* Get the real integer */\n+  /* Get the real integer.  */\n \n   c = next_char ();\n   switch (c)\n@@ -596,7 +591,7 @@ read_integer (int length)\n \n     case '-':\n       negative = 1;\n-      /* Fall through */\n+      /* Fall through...  */\n \n     case '+':\n       c = next_char ();\n@@ -649,14 +644,14 @@ read_integer (int length)\n }\n \n \n-/* read_character()-- Read a character variable */\n+/* Read a character variable.  */\n \n static void\n read_character (int length)\n {\n   char c, quote, message[100];\n \n-  quote = ' ';\t\t\t/* Space means no quote character */\n+  quote = ' ';\t\t\t/* Space means no quote character.  */\n \n   c = next_char ();\n   switch (c)\n@@ -666,7 +661,7 @@ read_character (int length)\n       break;\n \n     CASE_SEPARATORS:\n-      unget_char (c);\t\t/* NULL value */\n+      unget_char (c);\t\t/* NULL value.  */\n       eat_separator ();\n       return;\n \n@@ -680,7 +675,7 @@ read_character (int length)\n       goto get_string;\n     }\n \n-/* Deal with a possible repeat count */\n+  /* Deal with a possible repeat count.  */\n \n   for (;;)\n     {\n@@ -693,29 +688,29 @@ read_character (int length)\n \n \tCASE_SEPARATORS:\n \t  unget_char (c);\n-\t  goto done;\t\t/* String was only digits! */\n+\t  goto done;\t\t/* String was only digits!  */\n \n \tcase '*':\n \t  push_char ('\\0');\n \t  goto got_repeat;\n \n \tdefault:\n \t  push_char (c);\n-\t  goto get_string;\t/* Not a repeat count after all */\n+\t  goto get_string;\t/* Not a repeat count after all.  */\n \t}\n     }\n \n got_repeat:\n   if (convert_integer (-1, 0))\n     return;\n \n-  /* Now get the real string */\n+  /* Now get the real string.  */\n \n   c = next_char ();\n   switch (c)\n     {\n     CASE_SEPARATORS:\n-      unget_char (c);\t\t/* repeated NULL values */\n+      unget_char (c);\t\t/* Repeated NULL values.  */\n       eat_separator ();\n       return;\n \n@@ -743,7 +738,8 @@ read_character (int length)\n \t      break;\n \t    }\n \n-\t  /* See if we have a doubled quote character or the end of the string */\n+\t  /* See if we have a doubled quote character or the end of\n+\t     the string.  */\n \n \t  c = next_char ();\n \t  if (c == quote)\n@@ -772,7 +768,8 @@ read_character (int length)\n \t}\n     }\n \n-/* At this point, we have to have a separator, or else the string is invalid */\n+/* At this point, we have to have a separator, or else the string is\n+   invalid.  */\n \n done:\n   c = next_char ();\n@@ -791,9 +788,8 @@ read_character (int length)\n }\n \n \n-/* parse_real()-- Parse a component of a complex constant or a real\n- * number that we are sure is already there.  This is a straight real\n- * number parser. */\n+/* Parse a component of a complex constant or a real number that we\n+   are sure is already there.  This is a straight real number parser.  */\n \n static int\n parse_real (void *buffer, int length)\n@@ -906,8 +902,8 @@ parse_real (void *buffer, int length)\n }\n \n \n-/* read_complex()-- Reading a complex number is straightforward\n- * because we can tell what it is right away. */\n+/* Reading a complex number is straightforward because we can tell\n+   what it is right away.  */\n \n static void\n read_complex (int length)\n@@ -968,7 +964,7 @@ read_complex (int length)\n }\n \n \n-/* read_real()-- Parse a real number with a possible repeat count. */\n+/* Parse a real number with a possible repeat count.  */\n \n static void\n read_real (int length)\n@@ -995,15 +991,15 @@ read_real (int length)\n       goto got_sign;\n \n     CASE_SEPARATORS:\n-      unget_char (c);\t\t/* Single null */\n+      unget_char (c);\t\t/* Single null.  */\n       eat_separator ();\n       return;\n \n     default:\n       goto bad_real;\n     }\n \n-  /* Get the digit string that might be a repeat count */\n+  /* Get the digit string that might be a repeat count.  */\n \n   for (;;)\n     {\n@@ -1041,7 +1037,7 @@ read_real (int length)\n \n \tCASE_SEPARATORS:\n           if (c != '\\n')\n-            unget_char (c);        /* Real number that is just a digit-string */\n+            unget_char (c);    /* Real number that is just a digit-string.  */\n \t  goto done;\n \n \tdefault:\n@@ -1053,11 +1049,11 @@ read_real (int length)\n   if (convert_integer (-1, 0))\n     return;\n \n-/* Now get the number itself */\n+  /* Now get the number itself.  */\n \n   c = next_char ();\n   if (is_separator (c))\n-    {\t\t\t\t/* Repeated null value */\n+    {\t\t\t\t/* Repeated null value.  */\n       unget_char (c);\n       eat_separator ();\n       return;\n@@ -1178,8 +1174,8 @@ read_real (int length)\n }\n \n \n-/* check_type()-- Check the current type against the saved type to\n- * make sure they are compatible.  Returns nonzero if incompatible.  */\n+/* Check the current type against the saved type to make sure they are\n+   compatible.  Returns nonzero if incompatible.  */\n \n static int\n check_type (bt type, int len)\n@@ -1211,11 +1207,10 @@ check_type (bt type, int len)\n }\n \n \n-/* list_formatted_read()-- Top level data transfer subroutine for list\n- * reads.  Because we have to deal with repeat counts, the data item\n- * is always saved after reading, usually in the value[] array.  If a\n- * repeat count is greater than one, we copy the data item multiple\n- * times. */\n+/* Top level data transfer subroutine for list reads.  Because we have\n+   to deal with repeat counts, the data item is always saved after\n+   reading, usually in the value[] array.  If a repeat count is\n+   greater than one, we copy the data item multiple times.  */\n \n void\n list_formatted_read (bt type, void *p, int len)\n@@ -1240,7 +1235,7 @@ list_formatted_read (bt type, void *p, int len)\n \n       c = eat_spaces ();\n       if (is_separator (c))\n-\t{\t\t\t/* Found a null value */\n+\t{\t\t\t/* Found a null value.  */\n \t  eat_separator ();\n \t  repeat_count = 0;\n \t  if (at_eol)\n@@ -1304,7 +1299,7 @@ list_formatted_read (bt type, void *p, int len)\n     {\n     case BT_COMPLEX:\n       len = 2 * len;\n-      /* Fall through */\n+      /* Fall through.  */\n \n     case BT_INTEGER:\n     case BT_REAL:\n@@ -1318,7 +1313,8 @@ list_formatted_read (bt type, void *p, int len)\n           m = (len < saved_used) ? len : saved_used;\n           memcpy (p, saved_string, m);\n        }\n-      else    /* just delimiters encountered, nothing to copy but SPACE */\n+      else    \n+\t/* Just delimiters encountered, nothing to copy but SPACE.  */\n         m = 0;\n \n       if (m < len)\n@@ -1339,7 +1335,7 @@ init_at_eol()\n   at_eol = 0;\n }\n \n-/* finish_list_read()-- Finish a list read */\n+/* Finish a list read.  */\n \n void\n finish_list_read (void)\n@@ -1386,7 +1382,7 @@ match_namelist_name (char *name, int len)\n   char * namelist_name = name;\n \n   name_len = 0;\n-  /* Match the name of the namelist */\n+  /* Match the name of the namelist.  */\n \n   if (tolower (next_char ()) != tolower (namelist_name[name_len++]))\n     {\n@@ -1408,8 +1404,9 @@ match_namelist_name (char *name, int len)\n       Namelist reads\n ********************************************************************/\n \n-/* namelist_read()-- Process a namelist read.  This subroutine\n- * initializes things, positions to the first element and */\n+/* Process a namelist read.  This subroutine initializes things,\n+   positions to the first element and \n+   FIXME: was this comment ever complete?  */\n \n void\n namelist_read (void)\n@@ -1449,10 +1446,10 @@ namelist_read (void)\n       return;\n     }\n \n-  /* Match the name of the namelist */\n+  /* Match the name of the namelist.  */\n   match_namelist_name(ioparm.namelist_name, ioparm.namelist_name_len);\n \n-  /* Ready to read namelist elements */\n+  /* Ready to read namelist elements.  */\n   while (!input_complete)\n     {\n       c = next_char ();\n@@ -1509,7 +1506,7 @@ namelist_read (void)\n             {\n             case BT_COMPLEX:\n               len = 2 * len;\n-              /* Fall through */\n+              /* Fall through...  */\n \n             case BT_INTEGER:\n             case BT_REAL:\n@@ -1537,4 +1534,3 @@ namelist_read (void)\n         }\n    }\n }\n-"}, {"sha": "2d04537045fffcf0545faf4e2aaa15856696460f", "filename": "libgfortran/io/open.c", "status": "modified", "additions": 34, "deletions": 36, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fcb18047a53780b572b72c964d1df9cddec1660/libgfortran%2Fio%2Fopen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fcb18047a53780b572b72c964d1df9cddec1660/libgfortran%2Fio%2Fopen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fopen.c?ref=7fcb18047a53780b572b72c964d1df9cddec1660", "patch": "@@ -1,5 +1,4 @@\n-\n-/* Copyright (C) 2002-2003 Free Software Foundation, Inc.\n+/* Copyright (C) 2002, 2003, 2004 Free Software Foundation, Inc.\n    Contributed by Andy Vaught\n \n This file is part of the GNU Fortran 95 runtime library (libgfortran).\n@@ -134,10 +133,10 @@ static st_option access_opt[] = {\n };\n \n \n-/* test_endfile()-- Given a unit, test to see if the file is\n- * positioned at the terminal point, and if so, change state from\n- * NO_ENDFILE flag to AT_ENDFILE.  This prevents us from changing the\n- * state from AFTER_ENDFILE to AT_ENDFILE. */\n+/* Given a unit, test to see if the file is positioned at the terminal\n+   point, and if so, change state from NO_ENDFILE flag to AT_ENDFILE.\n+   This prevents us from changing the state from AFTER_ENDFILE to\n+   AT_ENDFILE.  */\n \n void\n test_endfile (gfc_unit * u)\n@@ -148,14 +147,14 @@ test_endfile (gfc_unit * u)\n }\n \n \n-/* edit_modes()-- Change the modes of a file, those that are allowed\n- * to be changed. */\n+/* Change the modes of a file, those that are allowed * to be\n+   changed.  */\n \n static void\n edit_modes (gfc_unit * u, unit_flags * flags)\n {\n \n-  /* Complain about attempts to change the unchangeable */\n+  /* Complain about attempts to change the unchangeable.  */\n \n   if (flags->status != STATUS_UNSPECIFIED &&\n       u->flags.status != flags->position)\n@@ -178,7 +177,7 @@ edit_modes (gfc_unit * u, unit_flags * flags)\n     generate_error (ERROR_BAD_OPTION,\n \t\t    \"Cannot change ACTION parameter in OPEN statement\");\n \n-  /* Status must be OLD if present */\n+  /* Status must be OLD if present.  */\n \n   if (flags->status != STATUS_UNSPECIFIED && flags->status != STATUS_OLD)\n     generate_error (ERROR_BAD_OPTION,\n@@ -203,7 +202,8 @@ edit_modes (gfc_unit * u, unit_flags * flags)\n     }\n \n   if (ioparm.library_return == LIBRARY_OK)\n-    {\t\t\t\t/* Change the changeable */\n+    {\n+      /* Change the changeable:  */\n       if (flags->blank != BLANK_UNSPECIFIED)\n \tu->flags.blank = flags->blank;\n       if (flags->delim != DELIM_UNSPECIFIED)\n@@ -212,7 +212,7 @@ edit_modes (gfc_unit * u, unit_flags * flags)\n \tu->flags.pad = flags->pad;\n     }\n \n-  /* Reposition the file if necessary. */\n+  /* Reposition the file if necessary.  */\n \n   switch (flags->position)\n     {\n@@ -227,15 +227,15 @@ edit_modes (gfc_unit * u, unit_flags * flags)\n       u->current_record = 0;\n       u->last_record = 0;\n \n-      test_endfile (u);\t\t/* We might be at the end */\n+      test_endfile (u);\t\t/* We might be at the end.  */\n       break;\n \n     case POSITION_APPEND:\n       if (sseek (u->s, file_length (u->s)) == FAILURE)\n \tgoto seek_error;\n \n       u->current_record = 0;\n-      u->endfile = AT_ENDFILE;\t/* We are at the end */\n+      u->endfile = AT_ENDFILE;\t/* We are at the end.  */\n       break;\n \n     seek_error:\n@@ -245,7 +245,7 @@ edit_modes (gfc_unit * u, unit_flags * flags)\n }\n \n \n-/* new_unit()-- Open an unused unit */\n+/* Open an unused unit.  */\n \n void\n new_unit (unit_flags * flags)\n@@ -254,13 +254,13 @@ new_unit (unit_flags * flags)\n   stream *s;\n   char tmpname[5 /* fort. */ + 10 /* digits of unit number */ + 1 /* 0 */];\n \n-  /* Change unspecifieds to defaults */\n+  /* Change unspecifieds to defaults.  */\n \n   if (flags->access == ACCESS_UNSPECIFIED)\n     flags->access = ACCESS_SEQUENTIAL;\n \n   if (flags->action == ACTION_UNSPECIFIED)\n-    flags->action = ACTION_READWRITE;\t/* Processor dependent */\n+    flags->action = ACTION_READWRITE;\t/* Processor dependent.  */\n \n   if (flags->form == FORM_UNSPECIFIED)\n     flags->form = (flags->access == ACCESS_SEQUENTIAL)\n@@ -321,7 +321,7 @@ new_unit (unit_flags * flags)\n   if (flags->status == STATUS_UNSPECIFIED)\n     flags->status = STATUS_UNKNOWN;\n \n-  /* Checks */\n+  /* Checks.  */\n \n   if (flags->access == ACCESS_DIRECT && ioparm.recl_in == 0)\n     {\n@@ -362,15 +362,15 @@ new_unit (unit_flags * flags)\n       internal_error (\"new_unit(): Bad status\");\n     }\n \n-  /* Make sure the file isn't already open someplace else */\n+  /* Make sure the file isn't already open someplace else.  */\n \n   if (find_file () != NULL)\n     {\n       generate_error (ERROR_ALREADY_OPEN, NULL);\n       goto cleanup;\n     }\n \n-  /* Open file */\n+  /* Open file.  */\n \n   s = open_external (flags->action, flags->status);\n   if (s == NULL)\n@@ -382,23 +382,23 @@ new_unit (unit_flags * flags)\n   if (flags->status == STATUS_NEW || flags->status == STATUS_REPLACE)\n     flags->status = STATUS_OLD;\n \n-  /* Create the unit structure */\n+  /* Create the unit structure.  */\n \n   u = get_mem (sizeof (gfc_unit) + ioparm.file_len);\n \n   u->unit_number = ioparm.unit;\n   u->s = s;\n   u->flags = *flags;\n \n-  /* Unspecified recl ends up with a processor dependent value */\n+  /* Unspecified recl ends up with a processor dependent value.  */\n \n   u->recl = (ioparm.recl_in != 0) ? ioparm.recl_in : DEFAULT_RECL;\n   u->last_record = 0;\n   u->current_record = 0;\n \n   /* If the file is direct access, calculate the maximum record number\n-   * via a division now instead of letting the multiplication overflow\n-   * later. */\n+     via a division now instead of letting the multiplication overflow\n+     later.  */\n \n   if (flags->access == ACCESS_DIRECT)\n     u->maxrec = g.max_offset / u->recl;\n@@ -409,25 +409,24 @@ new_unit (unit_flags * flags)\n   insert_unit (u);\n \n   /* The file is now connected.  Errors after this point leave the\n-   * file connected.  Curiously, the standard requires that the\n-   * position specifier be ignored for new files so a newly connected\n-   * file starts out that the initial point.  We still need to figure\n-   * out if the file is at the end or not. */\n+     file connected.  Curiously, the standard requires that the\n+     position specifier be ignored for new files so a newly connected\n+     file starts out that the initial point.  We still need to figure\n+     out if the file is at the end or not.  */\n \n   test_endfile (u);\n \n cleanup:\n \n-  /* Free memory associated with a temporary filename */\n+  /* Free memory associated with a temporary filename.  */\n \n   if (flags->status == STATUS_SCRATCH)\n     free_mem (ioparm.file);\n }\n \n \n-/* already_open()-- Open a unit which is already open.  This involves\n- * changing the modes or closing what is there now and opening the new\n- * file. */\n+/* Open a unit which is already open.  This involves changing the\n+   modes or closing what is there now and opening the new file.  */\n \n static void\n already_open (gfc_unit * u, unit_flags * flags)\n@@ -440,7 +439,7 @@ already_open (gfc_unit * u, unit_flags * flags)\n     }\n \n   /* If the file is connected to something else, close it and open a\n-   * new unit */\n+     new unit.  */\n \n   if (!compare_file_filename (u->s, ioparm.file, ioparm.file_len))\n     {\n@@ -458,8 +457,7 @@ already_open (gfc_unit * u, unit_flags * flags)\n }\n \n \n-/*************/\n-/* open file */\n+/* Open file.  */\n \n void\n st_open (void)\n@@ -469,7 +467,7 @@ st_open (void)\n  \n   library_start ();\n \n-  /* Decode options */\n+  /* Decode options.  */\n \n   flags.access = (ioparm.access == NULL) ? ACCESS_UNSPECIFIED :\n     find_option (ioparm.access, ioparm.access_len, access_opt,"}, {"sha": "b6f7c0e0129503dee5d56d4a9d7b23f0749d209f", "filename": "libgfortran/io/transfer.c", "status": "modified", "additions": 166, "deletions": 162, "changes": 328, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fcb18047a53780b572b72c964d1df9cddec1660/libgfortran%2Fio%2Ftransfer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fcb18047a53780b572b72c964d1df9cddec1660/libgfortran%2Fio%2Ftransfer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Ftransfer.c?ref=7fcb18047a53780b572b72c964d1df9cddec1660", "patch": "@@ -1,5 +1,4 @@\n-\n-/* Copyright (C) 2002-2003 Free Software Foundation, Inc.\n+/* Copyright (C) 2002, 2003, 2004 Free Software Foundation, Inc.\n    Contributed by Andy Vaught\n \n This file is part of the GNU Fortran 95 runtime library (libgfortran).\n@@ -20,7 +19,7 @@ the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n \n-/* transfer.c -- Top level handling of data transfer statements. */\n+/* transfer.c -- Top level handling of data transfer statements.  */\n \n #include \"config.h\"\n #include <string.h>\n@@ -30,30 +29,29 @@ Boston, MA 02111-1307, USA.  */\n \n \n /* Calling conventions:  Data transfer statements are unlike other\n- * library calls in that they extend over several calls.\n-\n- * The first call is always a call to st_read() or st_write().  These\n- * subroutines return no status unless a namelist read or write is\n- * being done, in which case there is the usual status.  No further\n- * calls are necessary in this case.\n- *\n- * For other sorts of data transfer, there are zero or more data\n- * transfer statement that depend on the format of the data transfer\n- * statement.\n- *\n- *    transfer_integer\n- *    transfer_logical\n- *    transfer_character\n- *    transfer_real\n- *    transfer_complex\n- *\n- *  These subroutines do not return status.\n- *\n- *  The last call is a call to st_[read|write]_done().  While\n- *  something can easily go wrong with the initial st_read() or\n- *  st_write(), an error inhibits any data from actually being\n- *  transferred.\n- */\n+   library calls in that they extend over several calls.\n+\n+   The first call is always a call to st_read() or st_write().  These\n+   subroutines return no status unless a namelist read or write is\n+   being done, in which case there is the usual status.  No further\n+   calls are necessary in this case.\n+\n+   For other sorts of data transfer, there are zero or more data\n+   transfer statement that depend on the format of the data transfer\n+   statement.\n+\n+      transfer_integer\n+      transfer_logical\n+      transfer_character\n+      transfer_real\n+      transfer_complex\n+\n+    These subroutines do not return status.\n+\n+    The last call is a call to st_[read|write]_done().  While\n+    something can easily go wrong with the initial st_read() or\n+    st_write(), an error inhibits any data from actually being\n+    transferred.  */\n \n gfc_unit *current_unit;\n static int sf_seen_eor = 0;\n@@ -101,20 +99,20 @@ current_mode (void)\n \n \n /* Mid level data transfer statements.  These subroutines do reading\n- * and writing in the style of salloc_r()/salloc_w() within the\n- * current record. */\n-\n-/* read_sf()-- When reading sequential formatted records we have a\n- * problem.  We don't know how long the line is until we read the\n- * trailing newline, and we don't want to read too much.  If we read\n- * too much, we might have to do a physical seek backwards depending\n- * on how much data is present, and devices like terminals aren't\n- * seekable and would cause an I/O error.\n- *\n- * Given this, the solution is to read a byte at a time, stopping if\n- * we hit the newline.  For small locations, we use a static buffer.\n- * For larger allocations, we are forced to allocate memory on the\n- * heap.  Hopefully this won't happen very often. */\n+   and writing in the style of salloc_r()/salloc_w() within the\n+   current record.  */\n+\n+/* When reading sequential formatted records we have a problem.  We\n+   don't know how long the line is until we read the trailing newline,\n+   and we don't want to read too much.  If we read too much, we might\n+   have to do a physical seek backwards depending on how much data is\n+   present, and devices like terminals aren't seekable and would cause\n+   an I/O error.\n+\n+   Given this, the solution is to read a byte at a time, stopping if\n+   we hit the newline.  For small locations, we use a static buffer.\n+   For larger allocations, we are forced to allocate memory on the\n+   heap.  Hopefully this won't happen very often.  */\n \n static char *\n read_sf (int *length)\n@@ -138,7 +136,8 @@ read_sf (int *length)\n     {\n       if (is_internal_unit())\n         {\n-       /* unity may be modified inside salloc_r if is_internal_unit() is true */\n+\t  /* unity may be modified inside salloc_r if \n+\t     is_internal_unit() is true.  */\n           unity = 1;\n         }\n \n@@ -149,11 +148,11 @@ read_sf (int *length)\n       if (*q == '\\n')\n \t{\n           if (current_unit->unit_number == options.stdin_unit)\n-            { \n+            {\n               if (n <= 0)\n                 continue;\n-            }          \n-\t\t\t/* Unexpected end of line */\n+            }\n+\t  /* Unexpected end of line.  */\n \t  if (current_unit->flags.pad == PAD_NO)\n \t    {\n \t      generate_error (ERROR_EOR, NULL);\n@@ -176,15 +175,15 @@ read_sf (int *length)\n }\n \n \n-/* read_block()-- Function for reading the next couple of bytes from\n- * the current file, advancing the current position.  We return a\n- * pointer to a buffer containing the bytes.  We return NULL on end of\n- * record or end of file.\n- *\n- * If the read is short, then it is because the current record does not\n- * have enough data to satisfy the read request and the file was\n- * opened with PAD=YES.  The caller must assume tailing spaces for\n- * short reads.  */\n+/* Function for reading the next couple of bytes from the current\n+   file, advancing the current position.  We return a pointer to a\n+   buffer containing the bytes.  We return NULL on end of record or\n+   end of file.\n+  \n+   If the read is short, then it is because the current record does not\n+   have enough data to satisfy the read request and the file was\n+   opened with PAD=YES.  The caller must assume tailing spaces for\n+   short reads.  */\n \n void *\n read_block (int *length)\n@@ -194,13 +193,13 @@ read_block (int *length)\n \n   if (current_unit->flags.form == FORM_FORMATTED &&\n       current_unit->flags.access == ACCESS_SEQUENTIAL)\n-    return read_sf (length);\t/* Special case */\n+    return read_sf (length);\t/* Special case.  */\n \n   if (current_unit->bytes_left < *length)\n     {\n       if (current_unit->flags.pad == PAD_NO)\n \t{\n-\t  generate_error (ERROR_EOR, NULL);\t/* Not enough data left */\n+\t  generate_error (ERROR_EOR, NULL); /* Not enough data left.  */\n \t  return NULL;\n \t}\n \n@@ -216,7 +215,7 @@ read_block (int *length)\n     *ioparm.size += nread;\n \n   if (nread != *length)\n-    {\t\t\t\t/* Short read, this shouldn't happen */\n+    {\t\t\t\t/* Short read, this shouldn't happen.  */\n       if (current_unit->flags.pad == PAD_YES)\n \t*length = nread;\n       else\n@@ -230,10 +229,10 @@ read_block (int *length)\n }\n \n \n-/* write_block()-- Function for writing a block of bytes to the\n- * current file at the current position, advancing the file pointer.\n- * We are given a length and return a pointer to a buffer that the\n- * caller must (completely) fill in.  Returns NULL on error. */\n+/* Function for writing a block of bytes to the current file at the\n+   current position, advancing the file pointer. We are given a length\n+   and return a pointer to a buffer that the caller must (completely)\n+   fill in.  Returns NULL on error.  */\n \n void *\n write_block (int length)\n@@ -256,7 +255,7 @@ write_block (int length)\n }\n \n \n-/* unformatted_read()-- Master function for unformatted reads.  */\n+/* Master function for unformatted reads.  */\n \n static void\n unformatted_read (bt type, void *dest, int length)\n@@ -274,6 +273,8 @@ unformatted_read (bt type, void *dest, int length)\n     }\n }\n \n+/* Master function for unformatted writes.  */\n+\n static void\n unformatted_write (bt type, void *source, int length)\n {\n@@ -284,7 +285,7 @@ unformatted_write (bt type, void *source, int length)\n }\n \n \n-/* type_name()-- Return a pointer to the name of a type. */\n+/* Return a pointer to the name of a type.  */\n \n const char *\n type_name (bt type)\n@@ -316,9 +317,9 @@ type_name (bt type)\n }\n \n \n-/* write_constant_string()-- write a constant string to the output.\n- * This is complicated because the string can have doubled delimiters\n- * in it.  The length in the format node is the true length. */\n+/* Write a constant string to the output.\n+   This is complicated because the string can have doubled delimiters\n+   in it.  The length in the format node is the true length.  */\n \n static void\n write_constant_string (fnode * f)\n@@ -341,14 +342,14 @@ write_constant_string (fnode * f)\n     {\n       c = *p++ = *q++;\n       if (c == delimiter && c != 'H')\n-\tq++;\t\t\t/* Skip the doubled delimiter */\n+\tq++;\t\t\t/* Skip the doubled delimiter.  */\n     }\n }\n \n \n-/* require_type()-- Given actual and expected types in a formatted\n- * data transfer, make sure they agree.  If not, an error message is\n- * generated.  Returns nonzero if something went wrong.  */\n+/* Given actual and expected types in a formatted data transfer, make\n+   sure they agree.  If not, an error message is generated.  Returns\n+   nonzero if something went wrong.  */\n \n static int\n require_type (bt expected, bt actual, fnode * f)\n@@ -366,14 +367,13 @@ require_type (bt expected, bt actual, fnode * f)\n }\n \n \n-/* formatted_transfer()-- This subroutine is the main loop for a\n- * formatted data transfer statement.  It would be natural to\n- * implement this as a coroutine with the user program, but C makes\n- * that awkward.  We loop, processesing format elements.  When we\n- * actually have to transfer data instead of just setting flags, we\n- * return control to the user program which calls a subroutine that\n- * supplies the address and type of the next element, then comes back\n- * here to process it.  */\n+/* This subroutine is the main loop for a formatted data transfer\n+   statement.  It would be natural to implement this as a coroutine\n+   with the user program, but C makes that awkward.  We loop,\n+   processesing format elements.  When we actually have to transfer\n+   data instead of just setting flags, we return control to the user\n+   program which calls a subroutine that supplies the address and type\n+   of the next element, then comes back here to process it.  */\n \n static void\n formatted_transfer (bt type, void *p, int len)\n@@ -383,14 +383,14 @@ formatted_transfer (bt type, void *p, int len)\n   int i, n;\n   int consume_data_flag;\n \n-  /* Change a complex data item into a pair of reals */\n+  /* Change a complex data item into a pair of reals.  */\n \n   n = (p == NULL) ? 0 : ((type != BT_COMPLEX) ? 1 : 2);\n   if (type == BT_COMPLEX)\n     type = BT_REAL;\n \n   /* If reversion has occurred and there is another real data item,\n-   * then we have to move to the next record */\n+     then we have to move to the next record.  */\n \n   if (g.reversion_flag && n > 0)\n     {\n@@ -405,7 +405,7 @@ formatted_transfer (bt type, void *p, int len)\n \n       f = next_format ();\n       if (f == NULL)\n-\treturn;\t\t\t/* No data descriptors left (already raised) */\n+\treturn;\t\t/* No data descriptors left (already raised).  */\n \n       switch (f->format)\n \t{\n@@ -598,7 +598,7 @@ formatted_transfer (bt type, void *p, int len)\n \t  write_constant_string (f);\n \t  break;\n \n-\t  /* Format codes that don't transfer data */\n+\t  /* Format codes that don't transfer data.  */\n \tcase FMT_X:\n \tcase FMT_TR:\n           consume_data_flag = 0 ;\n@@ -690,9 +690,10 @@ formatted_transfer (bt type, void *p, int len)\n \t  break;\n \n \tcase FMT_COLON:\n-\t  /* A colon descriptor causes us to exit this loop (in particular\n-\t   * preventing another / descriptor from being processed) unless there\n-\t   * is another data item to be transferred. */\n+\t  /* A colon descriptor causes us to exit this loop (in\n+\t     particular preventing another / descriptor from being\n+\t     processed) unless there is another data item to be\n+\t     transferred.  */\n           consume_data_flag = 0 ;\n \t  if (n == 0)\n \t    return;\n@@ -703,16 +704,16 @@ formatted_transfer (bt type, void *p, int len)\n \t}\n \n       /* Free a buffer that we had to allocate during a sequential\n-       * formatted read of a block that was larger than the static\n-       * buffer. */\n+\t formatted read of a block that was larger than the static\n+\t buffer.  */\n \n       if (line_buffer != NULL)\n \t{\n \t  free_mem (line_buffer);\n \t  line_buffer = NULL;\n \t}\n \n-      /* Adjust the item count and data pointer */\n+      /* Adjust the item count and data pointer.  */\n \n       if ((consume_data_flag > 0) && (n > 0))\n       {\n@@ -724,8 +725,8 @@ formatted_transfer (bt type, void *p, int len)\n   return;\n \n /* Come here when we need a data descriptor but don't have one.  We\n- * push the current format node back onto the input, then return and\n- * let the user program call us back with the data. */\n+   push the current format node back onto the input, then return and\n+   let the user program call us back with the data.  */\n \n need_data:\n   unget_format (f);\n@@ -734,8 +735,8 @@ formatted_transfer (bt type, void *p, int len)\n \n \n /* Data transfer entry points.  The type of the data entity is\n- * implicit in the subroutine call.  This prevents us from having to\n- * share a common enum with the compiler. */\n+   implicit in the subroutine call.  This prevents us from having to\n+   share a common enum with the compiler.  */\n \n void\n transfer_integer (void *p, int kind)\n@@ -792,7 +793,7 @@ transfer_complex (void *p, int kind)\n }\n \n \n-/* us_read()-- Preposition a sequential unformatted file while reading. */\n+/* Preposition a sequential unformatted file while reading.  */\n \n static void\n us_read (void)\n@@ -813,9 +814,8 @@ us_read (void)\n }\n \n \n-/* us_write()-- Preposition a sequential unformatted file while\n- * writing.  This amount to writing a bogus length that will be filled\n- * in later.  */\n+/* Preposition a sequential unformatted file while writing.  This\n+   amount to writing a bogus length that will be filled in later.  */\n \n static void\n us_write (void)\n@@ -832,29 +832,29 @@ us_write (void)\n       return;\n     }\n \n-  *p = 0;\t\t\t/* Bogus value for now */\n+  *p = 0;\t\t\t/* Bogus value for now.  */\n   if (sfree (current_unit->s) == FAILURE)\n     generate_error (ERROR_OS, NULL);\n \n-  /* for sequential unformatted, we write until we have more bytes than\n-      can fit in the record markers. if disk space runs out first it will\n-      error on the write */\n+  /* For sequential unformatted, we write until we have more bytes than\n+     can fit in the record markers. If disk space runs out first, it will\n+     error on the write.  */\n   current_unit->recl = g.max_offset;\n \n   current_unit->bytes_left = current_unit->recl;\n }\n \n \n-/* pre_position()-- position to the next record prior to transfer.  We\n- * are assumed to be before the next record.  We also calculate the\n- * bytes in the next record. */\n+/* Position to the next record prior to transfer.  We are assumed to\n+   be before the next record.  We also calculate the bytes in the next\n+   record.  */\n \n static void\n pre_position (void)\n {\n \n   if (current_unit->current_record)\n-    return;\t\t\t/* Already positioned */\n+    return;\t\t\t/* Already positioned.  */\n \n   switch (current_mode ())\n     {\n@@ -877,26 +877,26 @@ pre_position (void)\n }\n \n \n-/* data_transfer_init()-- Initialize things for a data transfer.  This\n- * code is common for both reading and writing. */\n+/* Initialize things for a data transfer.  This code is common for\n+   both reading and writing.  */\n \n static void\n data_transfer_init (int read_flag)\n {\n-  unit_flags u_flags;  /* used for creating a unit if needed */\n+  unit_flags u_flags;  /* Used for creating a unit if needed.  */\n \n   g.mode = read_flag ? READING : WRITING;\n \n   if (ioparm.size != NULL)\n-    *ioparm.size = 0;\t\t/* Initialize the count */\n+    *ioparm.size = 0;\t\t/* Initialize the count.  */\n \n   current_unit = get_unit (read_flag);\n   if (current_unit == NULL)\n-  {  /* open the unit with some default flags */\n+  {  /* Open the unit with some default flags.  */\n      memset (&u_flags, '\\0', sizeof (u_flags));\n      u_flags.access = ACCESS_SEQUENTIAL;\n      u_flags.action = ACTION_READWRITE;\n-     /* is it unformatted ?*/\n+     /* Is it unformatted?  */\n      if (ioparm.format == NULL && !ioparm.list_format)\n        u_flags.form = FORM_UNFORMATTED;\n      else\n@@ -919,7 +919,7 @@ data_transfer_init (int read_flag)\n         empty_internal_buffer (current_unit->s);\n     }\n \n-  /* Check the action */\n+  /* Check the action.  */\n \n   if (read_flag && current_unit->flags.action == ACTION_WRITE)\n     generate_error (ERROR_BAD_ACTION,\n@@ -931,7 +931,7 @@ data_transfer_init (int read_flag)\n   if (ioparm.library_return != LIBRARY_OK)\n     return;\n \n-  /* Check the format */\n+  /* Check the format.  */\n \n   if (ioparm.format)\n     parse_format ();\n@@ -960,7 +960,7 @@ data_transfer_init (int read_flag)\n     generate_error (ERROR_OPTION_CONFLICT,\n \t\t    \"Internal file cannot be accessed by UNFORMATTED data transfer\");\n \n-  /* Check the record number */\n+  /* Check the record number.  */\n \n   if (current_unit->flags.access == ACCESS_DIRECT && ioparm.rec == 0)\n     {\n@@ -976,7 +976,7 @@ data_transfer_init (int read_flag)\n       return;\n     }\n \n-  /* Process the ADVANCE option */\n+  /* Process the ADVANCE option.  */\n \n   advance_status = (ioparm.advance == NULL) ? ADVANCE_UNSPECIFIED :\n     find_option (ioparm.advance, ioparm.advance_len, advance_opt,\n@@ -1009,8 +1009,7 @@ data_transfer_init (int read_flag)\n \n     }\n   else\n-    {\t\t\t\t/* Write constraints */\n-\n+    {\t\t\t\t/* Write constraints.  */\n       if (ioparm.end != 0)\n \tgenerate_error (ERROR_OPTION_CONFLICT,\n \t\t\t\"END specification cannot appear in a write statement\");\n@@ -1029,7 +1028,7 @@ data_transfer_init (int read_flag)\n   if (ioparm.library_return != LIBRARY_OK)\n     return;\n \n-  /* Sanity checks on the record number */\n+  /* Sanity checks on the record number.  */\n \n   if (ioparm.rec)\n     {\n@@ -1045,14 +1044,14 @@ data_transfer_init (int read_flag)\n \t  return;\n \t}\n \n-      /* Position the file */\n+      /* Position the file.  */\n \n       if (sseek (current_unit->s,\n                (ioparm.rec - 1) * current_unit->recl) == FAILURE)\n \tgenerate_error (ERROR_OS, NULL);\n     }\n \n-  /* Set the initial value of flags */\n+  /* Set the initial value of flags.  */\n \n   g.blank_status = current_unit->flags.blank;\n   g.sign_status = SIGN_S;\n@@ -1063,7 +1062,7 @@ data_transfer_init (int read_flag)\n \n   pre_position ();\n \n-  /* Set up the subroutine that will handle the transfers */\n+  /* Set up the subroutine that will handle the transfers.  */\n \n   if (read_flag)\n     {\n@@ -1093,7 +1092,7 @@ data_transfer_init (int read_flag)\n \t}\n     }\n \n-  /* Make sure that we don't do a read after a nonadvancing write */\n+  /* Make sure that we don't do a read after a nonadvancing write.  */\n \n   if (read_flag)\n     {\n@@ -1110,7 +1109,7 @@ data_transfer_init (int read_flag)\n \tcurrent_unit->read_bad = 1;\n     }\n \n-  /* Start the data transfer if we are doing a formatted transfer */\n+  /* Start the data transfer if we are doing a formatted transfer.  */\n   if (current_unit->flags.form == FORM_FORMATTED && !ioparm.list_format\n       && ioparm.namelist_name == NULL && ionml == NULL)\n \n@@ -1119,9 +1118,9 @@ data_transfer_init (int read_flag)\n }\n \n \n-/* next_record_r()-- Space to the next record for read mode.  If the\n- * file is not seekable, we read MAX_READ chunks until we get to the\n- * right position. */\n+/* Space to the next record for read mode.  If the file is not\n+   seekable, we read MAX_READ chunks until we get to the right\n+   position.  */\n \n #define MAX_READ 4096\n \n@@ -1137,7 +1136,7 @@ next_record_r (int done)\n     case UNFORMATTED_SEQUENTIAL:\n       current_unit->bytes_left += sizeof (gfc_offset);\t/* Skip over tail */\n \n-      /* Fall through */\n+      /* Fall through...  */\n \n     case FORMATTED_DIRECT:\n     case UNFORMATTED_DIRECT:\n@@ -1148,14 +1147,14 @@ next_record_r (int done)\n \t{\n \t  new = file_position (current_unit->s) + current_unit->bytes_left;\n \n-\t  /* Direct access files do not generate END conditions, only I/O errors */\n-\n+\t  /* Direct access files do not generate END conditions, \n+\t     only I/O errors.  */\n \t  if (sseek (current_unit->s, new) == FAILURE)\n \t    generate_error (ERROR_OS, NULL);\n \n \t}\n       else\n-\t{\t\t\t/* Seek by reading data */\n+\t{\t\t\t/* Seek by reading data.  */\n \t  while (current_unit->bytes_left > 0)\n \t    {\n \t      rlength = length = (MAX_READ > current_unit->bytes_left) ?\n@@ -1183,7 +1182,7 @@ next_record_r (int done)\n         {\n           p = salloc_r (current_unit->s, &length);\n \n-          /*In case of internal file, there may not be any '\\n'.*/\n+          /* In case of internal file, there may not be any '\\n'.  */\n           if (is_internal_unit() && p == NULL)\n             {\n                break;\n@@ -1211,7 +1210,7 @@ next_record_r (int done)\n }\n \n \n-/* next_record_w()-- Position to the next record in write mode */\n+/* Position to the next record in write mode.  */\n \n static void\n next_record_w (int done)\n@@ -1243,12 +1242,12 @@ next_record_w (int done)\n       break;\n \n     case UNFORMATTED_SEQUENTIAL:\n-      m = current_unit->recl - current_unit->bytes_left; /* Bytes written */\n+      m = current_unit->recl - current_unit->bytes_left; /* Bytes written.  */\n       c = file_position (current_unit->s);\n \n       length = sizeof (gfc_offset);\n \n-      /* Write the length tail */\n+      /* Write the length tail.  */\n \n       p = salloc_w (current_unit->s, &length);\n       if (p == NULL)\n@@ -1258,7 +1257,8 @@ next_record_w (int done)\n       if (sfree (current_unit->s) == FAILURE)\n \tgoto io_error;\n \n-      /* Seek to the head and overwrite the bogus length with the real length */\n+      /* Seek to the head and overwrite the bogus length with the real\n+\t length.  */\n \n       p = salloc_w_at (current_unit->s, &length, c - m - length);\n       if (p == NULL)\n@@ -1268,7 +1268,7 @@ next_record_w (int done)\n       if (sfree (current_unit->s) == FAILURE)\n \tgoto io_error;\n \n-      /* Seek past the end of the current record */\n+      /* Seek past the end of the current record.  */\n \n       if (sseek (current_unit->s, c + sizeof (gfc_offset)) == FAILURE)\n \tgoto io_error;\n@@ -1282,7 +1282,7 @@ next_record_w (int done)\n       if (!is_internal_unit())\n         {\n           if (p)\n-            *p = '\\n'; /* no CR for internal writes */\n+            *p = '\\n'; /* No CR for internal writes.  */\n           else\n             goto io_error;\n         }\n@@ -1299,15 +1299,15 @@ next_record_w (int done)\n }\n \n \n-/* next_record()-- Position to the next record, which means moving to\n- * the end of the current record.  This can happen under several\n- * different conditions.  If the done flag is not set, we get ready to\n- * process the next record.  */\n+/* Position to the next record, which means moving to the end of the\n+   current record.  This can happen under several different\n+   conditions.  If the done flag is not set, we get ready to process\n+   the next record.  */\n \n void\n next_record (int done)\n {\n-  gfc_offset fp; /* file position */\n+  gfc_offset fp; /* File position.  */\n \n   current_unit->read_bad = 0;\n \n@@ -1333,7 +1333,7 @@ next_record (int done)\n \n \n /* Finalize the current data transfer.  For a nonadvancing transfer,\n- * this means advancing to the next record. */\n+   this means advancing to the next record.  */\n \n static void\n finalize_transfer (void)\n@@ -1430,7 +1430,7 @@ st_iolength_done (void)\n }\n \n \n-/* The READ statement */\n+/* The READ statement.  */\n \n void\n st_read (void)\n@@ -1441,9 +1441,9 @@ st_read (void)\n   data_transfer_init (1);\n \n   /* Handle complications dealing with the endfile record.  It is\n-   * significant that this is the only place where ERROR_END is\n-   * generated.  Reading an end of file elsewhere is either end of\n-   * record or an I/O error. */\n+     significant that this is the only place where ERROR_END is\n+     generated.  Reading an end of file elsewhere is either end of\n+     record or an I/O error. */\n \n   if (current_unit->flags.access == ACCESS_SEQUENTIAL)\n     switch (current_unit->endfile)\n@@ -1490,19 +1490,19 @@ st_write_done (void)\n \n   finalize_transfer ();\n \n-  /* Deal with endfile conditions associated with sequential files */\n+  /* Deal with endfile conditions associated with sequential files.  */\n \n   if (current_unit != NULL && current_unit->flags.access == ACCESS_SEQUENTIAL)\n     switch (current_unit->endfile)\n       {\n-      case AT_ENDFILE:\t\t/* Remain at the endfile record */\n+      case AT_ENDFILE:\t\t/* Remain at the endfile record.  */\n \tbreak;\n \n       case AFTER_ENDFILE:\n-\tcurrent_unit->endfile = AT_ENDFILE;\t/* Just at it now */\n+\tcurrent_unit->endfile = AT_ENDFILE;\t/* Just at it now.  */\n \tbreak;\n \n-      case NO_ENDFILE:\t\t/* Get rid of whatever is after this record */\n+      case NO_ENDFILE:\t/* Get rid of whatever is after this record.  */\n \tif (struncate (current_unit->s) == FAILURE)\n \t  generate_error (ERROR_OS, NULL);\n \n@@ -1519,8 +1519,7 @@ st_set_nml_var (void * var_addr, char * var_name, int var_name_len,\n                 int kind, bt type, int string_length)\n {\n   namelist_info *t1 = NULL, *t2 = NULL;\n-  namelist_info *nml = (namelist_info *) get_mem (sizeof(\n-                                                    namelist_info ));\n+  namelist_info *nml = (namelist_info *) get_mem (sizeof (namelist_info));\n   nml->mem_pos = var_addr;\n   if (var_name)\n     {\n@@ -1557,37 +1556,42 @@ st_set_nml_var (void * var_addr, char * var_name, int var_name_len,\n \n void\n st_set_nml_var_int (void * var_addr, char * var_name, int var_name_len,\n-                int kind)\n+\t\t    int kind)\n {\n-   st_set_nml_var (var_addr, var_name, var_name_len, kind, BT_INTEGER, 0);\n+\n+  st_set_nml_var (var_addr, var_name, var_name_len, kind, BT_INTEGER, 0);\n }\n \n void\n st_set_nml_var_float (void * var_addr, char * var_name, int var_name_len,\n-                int kind)\n+\t\t      int kind)\n {\n-   st_set_nml_var (var_addr, var_name, var_name_len, kind, BT_REAL, 0);\n+\n+  st_set_nml_var (var_addr, var_name, var_name_len, kind, BT_REAL, 0);\n }\n \n void\n st_set_nml_var_char (void * var_addr, char * var_name, int var_name_len,\n-                int kind, gfc_strlen_type string_length)\n+\t\t     int kind, gfc_strlen_type string_length)\n {\n-   st_set_nml_var (var_addr, var_name, var_name_len, kind, BT_CHARACTER,\n-                   string_length);\n+\n+  st_set_nml_var (var_addr, var_name, var_name_len, kind, BT_CHARACTER,\n+\t\t  string_length);\n }\n \n void\n st_set_nml_var_complex (void * var_addr, char * var_name, int var_name_len,\n-                int kind)\n+\t\t\tint kind)\n {\n-   st_set_nml_var (var_addr, var_name, var_name_len, kind, BT_COMPLEX, 0);\n+\n+  st_set_nml_var (var_addr, var_name, var_name_len, kind, BT_COMPLEX, 0);\n }\n \n void\n st_set_nml_var_log (void * var_addr, char * var_name, int var_name_len,\n-                int kind)\n+\t\t    int kind)\n {\n+  \n    st_set_nml_var (var_addr, var_name, var_name_len, kind, BT_LOGICAL, 0);\n }\n "}, {"sha": "551e686b7535a797d01ad5db0224b32a54ef1a2c", "filename": "libgfortran/io/write.c", "status": "modified", "additions": 52, "deletions": 53, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fcb18047a53780b572b72c964d1df9cddec1660/libgfortran%2Fio%2Fwrite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fcb18047a53780b572b72c964d1df9cddec1660/libgfortran%2Fio%2Fwrite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fwrite.c?ref=7fcb18047a53780b572b72c964d1df9cddec1660", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 2002-2003 Free Software Foundation, Inc.\n+/* Copyright (C) 2002, 2003, 2004 Free Software Foundation, Inc.\n    Contributed by Andy Vaught\n \n This file is part of the GNU Fortran 95 runtime library (libgfortran).\n@@ -104,9 +104,8 @@ extract_real (const void *p, int len)\n }\n \n \n-/* calculate sign()-- Given a flag that indicate if a value is\n- * negative or not, return a sign_t that gives the sign that we need\n- * to produce. */\n+/* Given a flag that indicate if a value is negative or not, return a\n+   sign_t that gives the sign that we need to produce.  */\n \n static sign_t\n calculate_sign (int negative_flag)\n@@ -133,7 +132,7 @@ calculate_sign (int negative_flag)\n }\n \n \n-/* calculate_exp()-- returns the value of 10**d.  */\n+/* Returns the value of 10**d.  */\n \n static double\n calculate_exp (int d)\n@@ -150,8 +149,7 @@ calculate_exp (int d)\n }\n \n \n-/* calculate_G_format()-- geneate corresponding I/O format for\n-   FMT_G output.\n+/* Generate corresponding I/O format for FMT_G output.\n    The rules to translate FMT_G to FMT_E or FNT_F from DEC fortran\n    LRM (table 11-2, Chapter 11, \"I/O Formatting\", P11-25) is:\n \n@@ -252,8 +250,7 @@ calculate_G_format (fnode *f, double value, int len, int *num_blank)\n }\n \n \n-/* output_float() -- output a real number according to its format\n-                     which is FMT_G free */\n+/* Output a real number according to its format which is FMT_G free.  */\n \n static void\n output_float (fnode *f, double value, int len)\n@@ -275,17 +272,17 @@ output_float (fnode *f, double value, int len)\n   int intval = 0, intlen = 0;\n   int j;\n   \n-  /* EXP value for this number */\n+  /* EXP value for this number.  */\n   neval = 0;\n \n-  /* Width of EXP and it's sign*/\n+  /* Width of EXP and it's sign.  */\n   nesign = 0;\n \n   ft = f->format;\n   w = f->u.real.w;\n   d = f->u.real.d + 1;\n \n-  /* Width of the EXP */\n+  /* Width of the EXP.  */\n   e = 0;\n \n   sca = g.scale_factor;\n@@ -295,7 +292,7 @@ output_float (fnode *f, double value, int len)\n   if (n < 0)\n     n = -n;\n \n-  /* Width of the sign for the whole number */\n+  /* Width of the sign for the whole number.  */\n   nsign = (sign == SIGN_NONE ? 0 : 1);\n \n   digits = 0;\n@@ -312,8 +309,8 @@ output_float (fnode *f, double value, int len)\n       minv = 0.1;\n       maxv = 1.0;\n \n-      /* Here calculate the new val of the number with consideration\n-         of Globle Scale value */\n+      /* Calculate the new val of the number with consideration\n+         of global scale value.  */\n       while (sca >  0)\n         {\n           minv *= 10.0;\n@@ -323,7 +320,7 @@ output_float (fnode *f, double value, int len)\n           neval --;\n         }\n \n-      /* Now calculate the new Exp value for this number */\n+      /* Now calculate the new Exp value for this number.  */\n       sca = g.scale_factor;\n       while(sca >= 1)\n         {\n@@ -343,7 +340,7 @@ output_float (fnode *f, double value, int len)\n        maxv = 10.0;\n      }\n \n-   /* OK, let's scale the number to appropriate range */\n+   /* OK, let's scale the number to appropriate range.  */\n    while (scale_flag && n > 0.0 && n < minv)\n      {\n        if (n < minv)\n@@ -361,12 +358,11 @@ output_float (fnode *f, double value, int len)\n          }\n      }\n \n-  /* It is time to process the EXP part of the number. \n-     Value of 'nesign' is 0 unless following codes is executed.\n-  */\n+  /* It is time to process the EXP part of the number.\n+     Value of 'nesign' is 0 unless following codes is executed.  */\n   if (ft != FMT_F)\n     {\n-     /* Sign of the EXP value */\n+     /* Sign of the EXP value.  */\n      if (neval >= 0)\n        esign = SIGN_PLUS;\n      else\n@@ -375,7 +371,7 @@ output_float (fnode *f, double value, int len)\n          neval = - neval ;\n        }\n \n-      /* Width of the EXP*/\n+      /* Width of the EXP.  */\n       e_new = 0;\n       j = neval;\n       while (j > 0)\n@@ -386,15 +382,15 @@ output_float (fnode *f, double value, int len)\n       if (e <= e_new)\n          e = e_new;\n \n-     /* Got the width of EXP */\n+     /* Got the width of EXP.  */\n      if (e < digits)\n        e = digits ;\n \n-     /* Minimum value of the width would be 2 */\n+     /* Minimum value of the width would be 2.  */\n      if (e < 2)\n        e = 2;\n \n-     nesign =  1 ;  /* We must give a position for the 'exp_char' */\n+     nesign =  1 ;  /* We must give a position for the 'exp_char'  */\n      if (e > 0)\n        nesign = e + nesign + (esign != SIGN_NONE ? 1 : 0);\n    }\n@@ -424,7 +420,7 @@ output_float (fnode *f, double value, int len)\n        nesign -= 1;\n        nblank = w - (nsign + intlen + d + nesign);\n      }\n-  /* don't let a leading '0' cause field overflow */\n+  /* Don't let a leading '0' cause field overflow.  */\n   if (nblank == -1 && ft == FMT_F && q[0] == '0')\n      {\n         q++;\n@@ -487,7 +483,7 @@ write_l (fnode * f, char *source, int len)\n {\n   char *p;\n   int64_t n;\n-                                                                                \n+\n   p = write_block (f->u.w);\n   if (p == NULL)\n     return;\n@@ -497,7 +493,7 @@ write_l (fnode * f, char *source, int len)\n   p[f->u.w - 1] = (n) ? 'T' : 'F';\n }\n \n-/* write_float() -- output a real number according to its format */\n+/* Output a real number according to its format.  */\n \n static void\n write_float (fnode *f, const char *source, int len)\n@@ -562,7 +558,7 @@ write_float (fnode *f, const char *source, int len)\n           p = write_block (nb);\n           memset (p, ' ', nb);\n         }\n-   }\n+    }\n }\n \n \n@@ -579,7 +575,7 @@ write_int (fnode *f, const char *source, int len, char *(*conv) (uint64_t))\n \n   n = extract_int (source, len);\n \n-  /* Special case */\n+  /* Special case:  */\n \n   if (m == 0 && n == 0)\n     {\n@@ -606,7 +602,7 @@ write_int (fnode *f, const char *source, int len, char *(*conv) (uint64_t))\n   digits = strlen (q);\n \n   /* Select a width if none was specified.  The idea here is to always\n-   * print something. */\n+     print something.  */\n \n   if (w == 0)\n     w = ((digits < m) ? m : digits);\n@@ -619,7 +615,7 @@ write_int (fnode *f, const char *source, int len, char *(*conv) (uint64_t))\n   if (digits < m)\n     nzero = m - digits;\n \n-  /* See if things will work */\n+  /* See if things will work.  */\n \n   nblank = w - (nzero + digits);\n \n@@ -654,7 +650,7 @@ write_decimal (fnode *f, const char *source, int len, char *(*conv) (int64_t))\n \n   n = extract_int (source, len);\n \n-  /* Special case */\n+  /* Special case:  */\n \n   if (m == 0 && n == 0)\n     {\n@@ -679,7 +675,7 @@ write_decimal (fnode *f, const char *source, int len, char *(*conv) (int64_t))\n   digits = strlen (q);\n \n   /* Select a width if none was specified.  The idea here is to always\n-   * print something. */\n+     print something.  */\n \n   if (w == 0)\n     w = ((digits < m) ? m : digits) + nsign;\n@@ -692,7 +688,7 @@ write_decimal (fnode *f, const char *source, int len, char *(*conv) (int64_t))\n   if (digits < m)\n     nzero = m - digits;\n \n-  /* See if things will work */\n+  /* See if things will work.  */\n \n   nblank = w - (nsign + nzero + digits);\n \n@@ -727,7 +723,7 @@ write_decimal (fnode *f, const char *source, int len, char *(*conv) (int64_t))\n }\n \n \n-/* otoa()-- Convert unsigned octal to ascii */\n+/* Convert unsigned octal to ascii.  */\n \n static char *\n otoa (uint64_t n)\n@@ -755,7 +751,7 @@ otoa (uint64_t n)\n }\n \n \n-/* btoa()-- Convert unsigned binary to ascii */\n+/* Convert unsigned binary to ascii.  */\n \n static char *\n btoa (uint64_t n)\n@@ -816,39 +812,44 @@ write_z (fnode * f, const char *p, int len)\n void\n write_d (fnode *f, const char *p, int len)\n {\n+\n   write_float (f, p, len);\n }\n \n \n void\n write_e (fnode *f, const char *p, int len)\n {\n+\n   write_float (f, p, len);\n }\n \n \n void\n write_f (fnode *f, const char *p, int len)\n {\n+\n   write_float (f, p, len);\n }\n \n \n void\n write_en (fnode *f, const char *p, int len)\n {\n+\n   write_float (f, p, len);\n }\n \n \n void\n write_es (fnode *f, const char *p, int len)\n {\n+\n   write_float (f, p, len);\n }\n \n \n-/* write_x()-- Take care of the X/TR descriptor */\n+/* Take care of the X/TR descriptor.  */\n \n void\n write_x (fnode * f)\n@@ -863,11 +864,11 @@ write_x (fnode * f)\n }\n \n \n-/* List-directed writing */\n+/* List-directed writing.  */\n \n \n-/* write_char()-- Write a single character to the output.  Returns\n- * nonzero if something goes wrong. */\n+/* Write a single character to the output.  Returns nonzero if\n+   something goes wrong.  */\n \n static int\n write_char (char c)\n@@ -884,7 +885,7 @@ write_char (char c)\n }\n \n \n-/* write_logical()-- Write a list-directed logical value */\n+/* Write a list-directed logical value.  */\n \n static void\n write_logical (const char *source, int length)\n@@ -893,7 +894,7 @@ write_logical (const char *source, int length)\n }\n \n \n-/* write_integer()-- Write a list-directed integer value. */\n+/* Write a list-directed integer value.  */\n \n static void\n write_integer (const char *source, int length)\n@@ -939,9 +940,8 @@ write_integer (const char *source, int length)\n }\n \n \n-/* write_character()-- Write a list-directed string.  We have to worry\n- * about delimiting the strings if the file has been opened in that\n- * mode. */\n+/* Write a list-directed string.  We have to worry about delimiting\n+   the strings if the file has been opened in that mode.  */\n \n static void\n write_character (const char *source, int length)\n@@ -995,8 +995,8 @@ write_character (const char *source, int length)\n }\n \n \n-/* Output the Real number with default format.\n-   REAL(4) is 1PG14.7E2, and REAL(8) is 1PG23.15E3  */\n+/* Output a real number with default format.\n+   This is 1PG14.7E2 for REAL(4) and 1PG23.15E3 for REAL(8).  */\n \n static void\n write_real (const char *source, int length)\n@@ -1038,7 +1038,7 @@ write_complex (const char *source, int len)\n }\n \n \n-/* write_separator()-- Write the separator between items. */\n+/* Write the separator between items.  */\n \n static void\n write_separator (void)\n@@ -1053,9 +1053,9 @@ write_separator (void)\n }\n \n \n-/* list_formatted_write()-- Write an item with list formatting.\n- * TODO: handle skipping to the next record correctly, particularly\n- * with strings. */\n+/* Write an item with list formatting.\n+   TODO: handle skipping to the next record correctly, particularly\n+   with strings.  */\n \n void\n list_formatted_write (bt type, void *p, int len)\n@@ -1160,4 +1160,3 @@ namelist_write (void)\n      write_character(\"/\",1);\n \n }\n-"}]}