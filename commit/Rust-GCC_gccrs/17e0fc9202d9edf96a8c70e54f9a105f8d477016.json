{"sha": "17e0fc9202d9edf96a8c70e54f9a105f8d477016", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTdlMGZjOTIwMmQ5ZWRmOTZhOGM3MGU1NGY5YTEwNWY4ZDQ3NzAxNg==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2014-12-11T21:48:48Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2014-12-11T21:48:48Z"}, "message": "re PR ipa/61324 (ICE: SIGSEGV at ipa-comdats.c:321 with -fno-use-cxa-atexit -fkeep-inline-functions)\n\n\n\tPR ipa/61324\n\t* testsuite/g++.dg/pr61324.C: New testcase by Trevor Saunders.\n\t* testsuite/g++.dg/tm/pr51411-2.C: Update se the extern function is\n\tnot eliminated early.\n\t* testsuite/gcc.target/i386/pr57756.c: Turn extern inline into static\n\tinline.\n\n\t* passes.c (execute_todo): Update call of remove_unreachable_nodes.\n\t* ipa-chkp.c (chkp_produce_thunks): Use TODO_remove_functions.\n\t* cgraphunit.c (symbol_table::process_new_functions): Add\n\tIPA_SSA_AFTER_INLINING.\n\t(ipa_passes): Update call of remove_unreachable_nodes.\n\t(symbol_table::compile): Remove call of remove_unreachable_nodes.\n\t* ipa-inline.c (inline_small_functions): Do not ICE with\n\t-flto-partition=none\n\t(ipa_inline): Update symtab->state; fix formatting\n\tupdate call of remove_unreachable_nodes.\n\t* cgraphclones.c (symbol_table::materialize_all_clones): Likewise.\n\t* cgraph.h (enum symtab_state): Add IPA_SSA_AFTER_INLINING.\n\t(remove_unreachable_nodes): Update.\n\t* ipa.c (process_references): Keep external references only\n\twhen optimizing.\n\t(walk_polymorphic_call_targets): Keep possible polymorphic call\n\ttarget only when devirtualizing.\n\t(symbol_table::remove_unreachable_nodes): Remove BEFORE_INLINING_P\n\tparameter.\n\t(ipa_single_use): Update comment.\n\t* ipa-pure-const.c (cdtor_p): New function.\n\t(propagate_pure_const): Track if some cdtor was turned pure/const.\n\t(execute): Return TODO_remove_functions if needed.\n\t* ipa-comdats.c (ipa_comdats): Update comment.\n\t\n\t* lto.c (read_cgraph_and_symbols): Update call of\n\tremove_unreachable_nodes.\n\t(do_whole_program_analysis): Remove call of\n\tsymtab->remove_unreachable_nodes\n\nFrom-SVN: r218640", "tree": {"sha": "5fd382a134825548701642cd06befc46ffb8a9b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5fd382a134825548701642cd06befc46ffb8a9b4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/17e0fc9202d9edf96a8c70e54f9a105f8d477016", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17e0fc9202d9edf96a8c70e54f9a105f8d477016", "html_url": "https://github.com/Rust-GCC/gccrs/commit/17e0fc9202d9edf96a8c70e54f9a105f8d477016", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17e0fc9202d9edf96a8c70e54f9a105f8d477016/comments", "author": null, "committer": null, "parents": [{"sha": "d4b7742db2e94140e2556fbd44fc819ef5c912e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4b7742db2e94140e2556fbd44fc819ef5c912e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d4b7742db2e94140e2556fbd44fc819ef5c912e1"}], "stats": {"total": 218, "additions": 168, "deletions": 50}, "files": [{"sha": "c0de7443afc734449f9334b0047dc40a50d56a77", "filename": "gcc/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17e0fc9202d9edf96a8c70e54f9a105f8d477016/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17e0fc9202d9edf96a8c70e54f9a105f8d477016/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=17e0fc9202d9edf96a8c70e54f9a105f8d477016", "patch": "@@ -1,3 +1,32 @@\n+2014-12-11  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\tPR ipa/61324\n+\t* passes.c (execute_todo): Update call of remove_unreachable_nodes.\n+\t* ipa-chkp.c (chkp_produce_thunks): Use TODO_remove_functions.\n+\t* cgraphunit.c (symbol_table::process_new_functions): Add\n+\tIPA_SSA_AFTER_INLINING.\n+\t(ipa_passes): Update call of remove_unreachable_nodes.\n+\t(symbol_table::compile): Remove call of remove_unreachable_nodes.\n+\t* ipa-inline.c (inline_small_functions): Do not ICE with\n+\t-flto-partition=none\n+\t(ipa_inline): Update symtab->state; fix formatting\n+\tupdate call of remove_unreachable_nodes.\n+\t* passes.c (execute_todo): Update call of remove_unreachable_nodes.\n+\t* cgraphclones.c (symbol_table::materialize_all_clones): Likewise.\n+\t* cgraph.h (enum symtab_state): Add IPA_SSA_AFTER_INLINING.\n+\t(remove_unreachable_nodes): Update.\n+\t* ipa.c (process_references): Keep external references only\n+\twhen optimizing.\n+\t(walk_polymorphic_call_targets): Keep possible polymorphic call\n+\ttarget only when devirtualizing.\n+\t(symbol_table::remove_unreachable_nodes): Remove BEFORE_INLINING_P\n+\tparameter.\n+\t(ipa_single_use): Update comment.\n+\t* ipa-pure-const.c (cdtor_p): New function.\n+\t(propagate_pure_const): Track if some cdtor was turned pure/const.\n+\t(execute): Return TODO_remove_functions if needed.\n+\t* ipa-comdats.c (ipa_comdats): Update comment.\n+\n 2014-12-11  Aldy Hernandez  <aldyh@redhat.com>\n \n \t* dwarf2out.c (gen_lexical_block_die): Remove unused `depth'"}, {"sha": "a2fc56300a7c378436a8b8e93a08cb94391b9c2f", "filename": "gcc/cgraph.h", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17e0fc9202d9edf96a8c70e54f9a105f8d477016/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17e0fc9202d9edf96a8c70e54f9a105f8d477016/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=17e0fc9202d9edf96a8c70e54f9a105f8d477016", "patch": "@@ -1801,12 +1801,15 @@ enum symtab_state\n   PARSING,\n   /* Callgraph is being constructed.  It is safe to add new functions.  */\n   CONSTRUCTION,\n-  /* Callgraph is being at LTO time.  */\n+  /* Callgraph is being streamed-in at LTO time.  */\n   LTO_STREAMING,\n-  /* Callgraph is built and IPA passes are being run.  */\n+  /* Callgraph is built and early IPA passes are being run.  */\n   IPA,\n   /* Callgraph is built and all functions are transformed to SSA form.  */\n   IPA_SSA,\n+  /* All inline decisions are done; it is now possible to remove extern inline\n+     functions and virtual call targets.  */\n+  IPA_SSA_AFTER_INLINING,\n   /* Functions are now ordered and being passed to RTL expanders.  */\n   EXPANSION,\n   /* All cgraph expansion is done.  */\n@@ -1876,7 +1879,7 @@ class GTY((tag (\"SYMTAB\"))) symbol_table\n   }\n \n   /* Perform reachability analysis and reclaim all unreachable nodes.  */\n-  bool remove_unreachable_nodes (bool before_inlining_p, FILE *file);\n+  bool remove_unreachable_nodes (FILE *file);\n \n   /* Optimization of function bodies might've rendered some variables as\n      unnecessary so we want to avoid these from being compiled.  Re-do"}, {"sha": "43d81a9f0ab539306704099839a81301dec26541", "filename": "gcc/cgraphclones.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17e0fc9202d9edf96a8c70e54f9a105f8d477016/gcc%2Fcgraphclones.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17e0fc9202d9edf96a8c70e54f9a105f8d477016/gcc%2Fcgraphclones.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphclones.c?ref=17e0fc9202d9edf96a8c70e54f9a105f8d477016", "patch": "@@ -1146,7 +1146,7 @@ symbol_table::materialize_all_clones (void)\n #ifdef ENABLE_CHECKING\n   cgraph_node::verify_cgraph_nodes ();\n #endif\n-  symtab->remove_unreachable_nodes (false, symtab->dump_file);\n+  symtab->remove_unreachable_nodes (symtab->dump_file);\n }\n \n #include \"gt-cgraphclones.h\""}, {"sha": "53abd173fa67c1153f230c04287d9581890aa45f", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17e0fc9202d9edf96a8c70e54f9a105f8d477016/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17e0fc9202d9edf96a8c70e54f9a105f8d477016/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=17e0fc9202d9edf96a8c70e54f9a105f8d477016", "patch": "@@ -327,6 +327,7 @@ symbol_table::process_new_functions (void)\n \n \tcase IPA:\n \tcase IPA_SSA:\n+\tcase IPA_SSA_AFTER_INLINING:\n \t  /* When IPA optimization already started, do all essential\n \t     transformations that has been already performed on the whole\n \t     cgraph but not on this function.  */\n@@ -335,7 +336,7 @@ symbol_table::process_new_functions (void)\n \t  if (!node->analyzed)\n \t    node->analyze ();\n \t  push_cfun (DECL_STRUCT_FUNCTION (fndecl));\n-\t  if (state == IPA_SSA\n+\t  if ((state == IPA_SSA || state == IPA_SSA_AFTER_INLINING)\n \t      && !gimple_in_ssa_p (DECL_STRUCT_FUNCTION (fndecl)))\n \t    g->get_passes ()->execute_early_local_passes ();\n \t  else if (inline_summary_vec != NULL)\n@@ -507,6 +508,7 @@ cgraph_node::add_new_function (tree fndecl, bool lowered)\n \n       case IPA:\n       case IPA_SSA:\n+      case IPA_SSA_AFTER_INLINING:\n       case EXPANSION:\n \t/* Bring the function into finalized state and enqueue for later\n \t   analyzing and compilation.  */\n@@ -2053,7 +2055,7 @@ ipa_passes (void)\n \n   /* This extra symtab_remove_unreachable_nodes pass tends to catch some\n      devirtualization and other changes where removal iterate.  */\n-  symtab->remove_unreachable_nodes (true, symtab->dump_file);\n+  symtab->remove_unreachable_nodes (symtab->dump_file);\n \n   /* If pass_all_early_optimizations was not scheduled, the state of\n      the cgraph will not be properly updated.  Update it now.  */\n@@ -2194,10 +2196,6 @@ symbol_table::compile (void)\n       return;\n     }\n \n-  /* This pass remove bodies of extern inline functions we never inlined.\n-     Do this later so other IPA passes see what is really going on.\n-     FIXME: This should be run just after inlining by pasmanager.  */\n-  remove_unreachable_nodes (false, dump_file);\n   global_info_ready = true;\n   if (dump_file)\n     {"}, {"sha": "c6bd15ff61a731945b4bfa3874bf60cf672e1e27", "filename": "gcc/ipa-chkp.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17e0fc9202d9edf96a8c70e54f9a105f8d477016/gcc%2Fipa-chkp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17e0fc9202d9edf96a8c70e54f9a105f8d477016/gcc%2Fipa-chkp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-chkp.c?ref=17e0fc9202d9edf96a8c70e54f9a105f8d477016", "patch": "@@ -647,9 +647,7 @@ chkp_produce_thunks (void)\n \tchkp_function_mark_instrumented (node->decl);\n     }\n \n-  symtab->remove_unreachable_nodes (true, dump_file);\n-\n-  return 0;\n+  return TODO_remove_functions;\n }\n \n const pass_data pass_data_ipa_chkp_versioning ="}, {"sha": "306f55f8f869fb8ccd3f0731f3cf0ab5626911f7", "filename": "gcc/ipa-comdats.c", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17e0fc9202d9edf96a8c70e54f9a105f8d477016/gcc%2Fipa-comdats.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17e0fc9202d9edf96a8c70e54f9a105f8d477016/gcc%2Fipa-comdats.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-comdats.c?ref=17e0fc9202d9edf96a8c70e54f9a105f8d477016", "patch": "@@ -327,7 +327,14 @@ ipa_comdats (void)\n \t  && !symbol->alias\n \t  && symbol->real_symbol_p ())\n \t{\n-\t  tree group = *map.get (symbol);\n+\t  tree *val = map.get (symbol);\n+\n+\t  /* A NULL here means that SYMBOL is unreachable in the definition\n+\t     of ipa-comdats. Either ipa-comdats is wrong about this or someone\n+\t     forgot to cleanup and remove unreachable functions earlier.  */\n+\t  gcc_assert (val);\n+\n+\t  tree group = *val;\n \n \t  if (group == error_mark_node)\n \t    continue;"}, {"sha": "8954e49353392613dc9e9dd791ba514a7199b0bf", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17e0fc9202d9edf96a8c70e54f9a105f8d477016/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17e0fc9202d9edf96a8c70e54f9a105f8d477016/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=17e0fc9202d9edf96a8c70e54f9a105f8d477016", "patch": "@@ -1731,9 +1731,9 @@ inline_small_functions (void)\n \t\t   \" to be inlined into %s/%i in %s:%i\\n\"\n \t\t   \" Estimated badness is %\"PRId64\", frequency %.2f.\\n\",\n \t\t   edge->caller->name (), edge->caller->order,\n-\t\t   flag_wpa ? \"unknown\"\n+\t\t   edge->call_stmt ? \"unknown\"\n \t\t   : gimple_filename ((const_gimple) edge->call_stmt),\n-\t\t   flag_wpa ? -1\n+\t\t   edge->call_stmt ? -1\n \t\t   : gimple_lineno ((const_gimple) edge->call_stmt),\n \t\t   badness.to_int (),\n \t\t   edge->frequency / (double)CGRAPH_FREQ_BASE);\n@@ -2188,9 +2188,12 @@ ipa_inline (void)\n \n   inline_small_functions ();\n \n-  /* Do first after-inlining removal.  We want to remove all \"stale\" extern inline\n-     functions and virtual functions so we really know what is called once.  */\n-  symtab->remove_unreachable_nodes (false, dump_file);\n+  gcc_assert (symtab->state == IPA_SSA);\n+  symtab->state = IPA_SSA_AFTER_INLINING;\n+  /* Do first after-inlining removal.  We want to remove all \"stale\" extern\n+     inline functions and virtual functions so we really know what is called\n+     once.  */\n+  symtab->remove_unreachable_nodes (dump_file);\n   free (order);\n \n   /* Inline functions with a property that after inlining into all callers the\n@@ -2199,7 +2202,8 @@ ipa_inline (void)\n      are met.  */\n   if (dump_file)\n     fprintf (dump_file,\n-\t     \"\\nDeciding on functions to be inlined into all callers and removing useless speculations:\\n\");\n+\t     \"\\nDeciding on functions to be inlined into all callers and \"\n+\t     \"removing useless speculations:\\n\");\n \n   /* Inlining one function called once has good chance of preventing\n      inlining other function into the same callee.  Ideally we should\n@@ -2247,10 +2251,11 @@ ipa_inline (void)\n \t      int num_calls = 0;\n \t      node->call_for_symbol_thunks_and_aliases (sum_callers, &num_calls,\n \t\t\t\t\t\t      true);\n-\t      while (node->call_for_symbol_thunks_and_aliases (inline_to_all_callers,\n-\t\t\t\t\t\t\t     &num_calls, true))\n+\t      while (node->call_for_symbol_thunks_and_aliases\n+\t\t       (inline_to_all_callers, &num_calls, true))\n \t\t;\n-\t      remove_functions = true;\n+\t      if (num_calls)\n+\t        remove_functions = true;\n \t    }\n \t}\n     }"}, {"sha": "94c3f81dfc885408c7a25b92ab622a9c635de318", "filename": "gcc/ipa-pure-const.c", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17e0fc9202d9edf96a8c70e54f9a105f8d477016/gcc%2Fipa-pure-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17e0fc9202d9edf96a8c70e54f9a105f8d477016/gcc%2Fipa-pure-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-pure-const.c?ref=17e0fc9202d9edf96a8c70e54f9a105f8d477016", "patch": "@@ -1160,10 +1160,21 @@ self_recursive_p (struct cgraph_node *node)\n   return false;\n }\n \n+/* Return true if N is cdtor that is not const or pure.  In this case we may\n+   need to remove unreachable function if it is marked const/pure.  */\n+\n+static bool\n+cdtor_p (cgraph_node *n, void *)\n+{\n+  if (DECL_STATIC_CONSTRUCTOR (n->decl) || DECL_STATIC_DESTRUCTOR (n->decl))\n+    return !TREE_READONLY (n->decl) && !DECL_PURE_P (n->decl);\n+  return false;\n+}\n+\n /* Produce transitive closure over the callgraph and compute pure/const\n    attributes.  */\n \n-static void\n+static bool\n propagate_pure_const (void)\n {\n   struct cgraph_node *node;\n@@ -1173,6 +1184,7 @@ propagate_pure_const (void)\n   int order_pos;\n   int i;\n   struct ipa_dfs_info * w_info;\n+  bool remove_p = false;\n \n   order_pos = ipa_reduced_postorder (order, true, false, NULL);\n   if (dump_file)\n@@ -1447,6 +1459,8 @@ propagate_pure_const (void)\n \t\t\t       this_looping ? \"looping \" : \"\",\n \t\t\t       w->name ());\n \t\t  }\n+\t\tremove_p |= w->call_for_symbol_and_aliases (cdtor_p,\n+\t\t\t\t\t\t\t    NULL, true);\n \t\tw->set_const_flag (true, this_looping);\n \t\tbreak;\n \n@@ -1459,6 +1473,8 @@ propagate_pure_const (void)\n \t\t\t       this_looping ? \"looping \" : \"\",\n \t\t\t       w->name ());\n \t\t  }\n+\t\tremove_p |= w->call_for_symbol_and_aliases (cdtor_p,\n+\t\t\t\t\t\t\t    NULL, true);\n \t\tw->set_pure_flag (true, this_looping);\n \t\tbreak;\n \n@@ -1472,6 +1488,7 @@ propagate_pure_const (void)\n \n   ipa_free_postorder_info ();\n   free (order);\n+  return remove_p;\n }\n \n /* Produce transitive closure over the callgraph and compute nothrow\n@@ -1581,6 +1598,7 @@ pass_ipa_pure_const::\n execute (function *)\n {\n   struct cgraph_node *node;\n+  bool remove_p;\n \n   symtab->remove_cgraph_insertion_hook (function_insertion_hook_holder);\n   symtab->remove_cgraph_duplication_hook (node_duplication_hook_holder);\n@@ -1589,14 +1607,14 @@ execute (function *)\n   /* Nothrow makes more function to not lead to return and improve\n      later analysis.  */\n   propagate_nothrow ();\n-  propagate_pure_const ();\n+  remove_p = propagate_pure_const ();\n \n   /* Cleanup. */\n   FOR_EACH_FUNCTION (node)\n     if (has_function_state (node))\n       free (get_function_state (node));\n   funct_state_vec.release ();\n-  return 0;\n+  return remove_p ? TODO_remove_functions : 0;\n }\n \n static bool"}, {"sha": "bed20e9d664cfb885517fd2a696009d7d735f0c6", "filename": "gcc/ipa.c", "status": "modified", "additions": 49, "deletions": 19, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17e0fc9202d9edf96a8c70e54f9a105f8d477016/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17e0fc9202d9edf96a8c70e54f9a105f8d477016/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=17e0fc9202d9edf96a8c70e54f9a105f8d477016", "patch": "@@ -123,21 +123,33 @@ process_references (symtab_node *snode,\n   for (i = 0; snode->iterate_reference (i, ref); i++)\n     {\n       symtab_node *node = ref->referred;\n+      symtab_node *body = node->ultimate_alias_target ();\n \n       if (node->definition && !node->in_other_partition\n \t  && ((!DECL_EXTERNAL (node->decl) || node->alias)\n \t      || (((before_inlining_p\n-\t\t    && (symtab->state < IPA_SSA\n-\t\t        || !lookup_attribute (\"always_inline\",\n-\t\t\t\t\t      DECL_ATTRIBUTES (node->decl)))))\n-\t\t  /* We use variable constructors during late complation for\n+\t\t    && (TREE_CODE (node->decl) != FUNCTION_DECL\n+\t\t\t|| opt_for_fn (body->decl, optimize)\n+\t\t        || (symtab->state < IPA_SSA\n+\t\t            && lookup_attribute\n+\t\t\t\t (\"always_inline\",\n+\t\t\t          DECL_ATTRIBUTES (body->decl))))))\n+\t\t  /* We use variable constructors during late compilation for\n \t\t     constant folding.  Keep references alive so partitioning\n \t\t     knows about potential references.  */\n \t\t  || (TREE_CODE (node->decl) == VAR_DECL\n \t\t      && flag_wpa\n \t\t      && ctor_for_folding (node->decl)\n \t\t         != error_mark_node))))\n-\treachable->add (node);\n+\t{\n+\t  /* Be sure that we will not optimize out alias target\n+\t     body.  */\n+\t  if (DECL_EXTERNAL (node->decl)\n+\t      && node->alias\n+\t      && before_inlining_p)\n+\t    reachable->add (body);\n+\t  reachable->add (node);\n+\t}\n       enqueue_node (node, first, reachable);\n     }\n }\n@@ -178,15 +190,23 @@ walk_polymorphic_call_targets (hash_set<void *> *reachable_call_targets,\n \t\t    (method_class_type (TREE_TYPE (n->decl))))\n \t    continue;\n \n+\t   symtab_node *body = n->function_symbol ();\n+\n \t  /* Prior inlining, keep alive bodies of possible targets for\n \t     devirtualization.  */\n \t   if (n->definition\n \t       && (before_inlining_p\n-\t\t   && (symtab->state < IPA_SSA\n-\t\t       || !lookup_attribute (\"always_inline\",\n-\t\t\t\t\t     DECL_ATTRIBUTES (n->decl)))))\n-\t     reachable->add (n);\n-\n+\t\t   && opt_for_fn (body->decl, optimize)\n+\t\t   && opt_for_fn (body->decl, flag_devirtualize)))\n+\t      {\n+\t\t /* Be sure that we will not optimize out alias target\n+\t\t    body.  */\n+\t\t if (DECL_EXTERNAL (n->decl)\n+\t\t     && n->alias\n+\t\t     && before_inlining_p)\n+\t\t   reachable->add (body);\n+\t\treachable->add (n);\n+\t      }\n \t  /* Even after inlining we want to keep the possible targets in the\n \t     boundary, so late passes can still produce direct call even if\n \t     the chance for inlining is lost.  */\n@@ -246,8 +266,6 @@ walk_polymorphic_call_targets (hash_set<void *> *reachable_call_targets,\n      After inlining we release their bodies and turn them into unanalyzed\n      nodes even when they are reachable.\n \n-     BEFORE_INLINING_P specify whether we are before or after inlining.\n-\n    - virtual functions are kept in callgraph even if they seem unreachable in\n      hope calls to them will be devirtualized. \n \n@@ -293,7 +311,7 @@ walk_polymorphic_call_targets (hash_set<void *> *reachable_call_targets,\n    we set AUX pointer of processed symbols in the boundary to constant 2.  */\n \n bool\n-symbol_table::remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n+symbol_table::remove_unreachable_nodes (FILE *file)\n {\n   symtab_node *first = (symtab_node *) (void *) 1;\n   struct cgraph_node *node, *next;\n@@ -302,6 +320,8 @@ symbol_table::remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n   hash_set<symtab_node *> reachable;\n   hash_set<tree> body_needed_for_clonning;\n   hash_set<void *> reachable_call_targets;\n+  bool before_inlining_p = symtab->state < (!optimize ? IPA_SSA\n+\t\t\t\t\t    : IPA_SSA_AFTER_INLINING);\n \n   timevar_push (TV_IPA_UNREACHABLE);\n   build_type_inheritance_graph ();\n@@ -414,19 +434,25 @@ symbol_table::remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \t\t}\n \t      for (e = cnode->callees; e; e = e->next_callee)\n \t\t{\n+\t          symtab_node *body = e->callee->function_symbol ();\n \t\t  if (e->callee->definition\n \t\t      && !e->callee->in_other_partition\n \t\t      && (!e->inline_failed\n \t\t\t  || !DECL_EXTERNAL (e->callee->decl)\n \t\t\t  || e->callee->alias\n-\t\t\t  || before_inlining_p))\n+\t\t\t  || (before_inlining_p\n+\t\t\t      && (opt_for_fn (body->decl, optimize)\n+\t\t                  || (symtab->state < IPA_SSA\n+\t\t                      && lookup_attribute\n+\t\t\t\t          (\"always_inline\",\n+\t\t\t\t           DECL_ATTRIBUTES (body->decl)))))))\n \t\t    {\n \t\t      /* Be sure that we will not optimize out alias target\n \t\t\t body.  */\n \t\t      if (DECL_EXTERNAL (e->callee->decl)\n \t\t\t  && e->callee->alias\n \t\t\t  && before_inlining_p)\n-\t\t\treachable.add (e->callee->function_symbol ());\n+\t\t\treachable.add (body);\n \t\t      reachable.add (e->callee);\n \t\t    }\n \t\t  enqueue_node (e->callee, &first, &reachable);\n@@ -1219,14 +1245,15 @@ propagate_single_user (varpool_node *vnode, cgraph_node *function,\n \t    function = BOTTOM;\n \t}\n       else\n-        function = meet (function, dyn_cast <varpool_node *> (ref->referring), single_user_map);\n+\tfunction = meet (function, dyn_cast <varpool_node *> (ref->referring),\n+\t\t\t single_user_map);\n     }\n   return function;\n }\n \n /* Pass setting used_by_single_function flag.\n-   This flag is set on variable when there is only one function that may possibly\n-   referr to it.  */\n+   This flag is set on variable when there is only one function that may\n+   possibly referr to it.  */\n \n static unsigned int\n ipa_single_use (void)\n@@ -1304,7 +1331,10 @@ ipa_single_use (void)\n       if (var->aux != BOTTOM)\n \t{\n #ifdef ENABLE_CHECKING\n-\t  if (!single_user_map.get (var))\n+\t  /* Not having the single user known means that the VAR is\n+\t     unreachable.  Either someone forgot to remove unreachable\n+\t     variables or the reachability here is wrong.  */\n+\n           gcc_assert (single_user_map.get (var));\n #endif\n \t  if (dump_file)"}, {"sha": "7f1088fa1454da4f677f669217f3b18e7b765e82", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17e0fc9202d9edf96a8c70e54f9a105f8d477016/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17e0fc9202d9edf96a8c70e54f9a105f8d477016/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=17e0fc9202d9edf96a8c70e54f9a105f8d477016", "patch": "@@ -1,3 +1,11 @@\n+2014-12-11  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\tPR ipa/61324\n+\t* lto.c (read_cgraph_and_symbols): Update call of\n+\tremove_unreachable_nodes.\n+\t(do_whole_program_analysis): Remove call of\n+\tsymtab->remove_unreachable_nodes\n+\n 2014-12-08  Trevor Saunders  <tsaunders@mozilla.com>\n \n \t* lto.c (read_cgraph_and_symbols): allocate gimple_canonical_types"}, {"sha": "324538a0cb8b355352a38b1723a9c5d575b63bce", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17e0fc9202d9edf96a8c70e54f9a105f8d477016/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17e0fc9202d9edf96a8c70e54f9a105f8d477016/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=17e0fc9202d9edf96a8c70e54f9a105f8d477016", "patch": "@@ -3098,7 +3098,7 @@ read_cgraph_and_symbols (unsigned nfiles, const char **fnames)\n   /* Removal of unreachable symbols is needed to make verify_symtab to pass;\n      we are still having duplicated comdat groups containing local statics.\n      We could also just remove them while merging.  */\n-  symtab->remove_unreachable_nodes (true, dump_file);\n+  symtab->remove_unreachable_nodes (dump_file);\n   ggc_collect ();\n   symtab->state = IPA_SSA;\n \n@@ -3255,7 +3255,6 @@ do_whole_program_analysis (void)\n   symtab->state = IPA_SSA;\n \n   execute_ipa_pass_list (g->get_passes ()->all_regular_ipa_passes);\n-  symtab->remove_unreachable_nodes (false, dump_file);\n \n   if (symtab->dump_file)\n     {"}, {"sha": "3f9f7df11edddc1a9d91ee21e785280acc0c8423", "filename": "gcc/passes.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17e0fc9202d9edf96a8c70e54f9a105f8d477016/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17e0fc9202d9edf96a8c70e54f9a105f8d477016/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=17e0fc9202d9edf96a8c70e54f9a105f8d477016", "patch": "@@ -2003,7 +2003,7 @@ execute_todo (unsigned int flags)\n   if (flags & TODO_remove_functions)\n     {\n       gcc_assert (!cfun);\n-      symtab->remove_unreachable_nodes (true, dump_file);\n+      symtab->remove_unreachable_nodes (dump_file);\n     }\n \n   if ((flags & TODO_dump_symtab) && dump_file && !current_function_decl)"}, {"sha": "e85830cadc52a036a6214b9b13a043adbdb7736e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17e0fc9202d9edf96a8c70e54f9a105f8d477016/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17e0fc9202d9edf96a8c70e54f9a105f8d477016/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=17e0fc9202d9edf96a8c70e54f9a105f8d477016", "patch": "@@ -1,3 +1,12 @@\n+2014-12-11  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\tPR ipa/61324\n+\t* testsuite/g++.dg/pr61324.C: New testcase by Trevor Saunders.\n+\t* testsuite/g++.dg/tm/pr51411-2.C: Update se the extern function is\n+\tnot eliminated early.\n+\t* testsuite/gcc.target/i386/pr57756.c: Turn extern inline into static\n+\tinline.\n+\n 2014-12-11  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/42108"}, {"sha": "610257436b3bd1b012fc1f11c4a6867c6fdbd858", "filename": "gcc/testsuite/g++.dg/pr61324.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17e0fc9202d9edf96a8c70e54f9a105f8d477016/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr61324.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17e0fc9202d9edf96a8c70e54f9a105f8d477016/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr61324.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr61324.C?ref=17e0fc9202d9edf96a8c70e54f9a105f8d477016", "patch": "@@ -0,0 +1,13 @@\n+// { dg-do compile }\n+// { dg-options \"-O -fkeep-inline-functions -fno-use-cxa-atexit\" }\n+void foo ();\n+\n+struct S\n+{\n+  ~S ()\n+  {\n+    foo ();\n+  }\n+};\n+\n+S s;"}, {"sha": "3147d2f1d8737119aaf966e6078408f10543ae3e", "filename": "gcc/testsuite/g++.dg/tm/pr51411-2.C", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17e0fc9202d9edf96a8c70e54f9a105f8d477016/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fpr51411-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17e0fc9202d9edf96a8c70e54f9a105f8d477016/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fpr51411-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fpr51411-2.C?ref=17e0fc9202d9edf96a8c70e54f9a105f8d477016", "patch": "@@ -26,6 +26,7 @@ public:\n     bool compare(const basic_string& __str) const {\n         return 0;\n     }\n+    void key ();\n };\n \n typedef basic_string<char> string;\n@@ -35,7 +36,7 @@ inline bool operator<(const basic_string<_CharT, _Traits>& __lhs, const basic_st\n     return __lhs.compare(__rhs);\n }\n \n-extern template class basic_string<char>;\n+template class basic_string<char>;\n \n }\n "}, {"sha": "7edd4b5d697e107bdb583b6b78bec393ee91d0fc", "filename": "gcc/testsuite/gcc.target/i386/pr57756.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17e0fc9202d9edf96a8c70e54f9a105f8d477016/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr57756.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17e0fc9202d9edf96a8c70e54f9a105f8d477016/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr57756.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr57756.c?ref=17e0fc9202d9edf96a8c70e54f9a105f8d477016", "patch": "@@ -9,7 +9,7 @@ __inline int callee () /* { dg-error \"inlining failed in call to always_inline\"\n }\n \n __attribute__((target(\"sse\")))\n-__inline int caller ()\n+static __inline int caller ()\n {\n   return callee(); /* { dg-error \"called from here\" }  */\n }"}]}