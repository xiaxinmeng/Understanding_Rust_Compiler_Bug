{"sha": "fa89b6ecba4ce9448b82a21f91b360eacf57bc72", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmE4OWI2ZWNiYTRjZTk0NDhiODJhMjFmOTFiMzYwZWFjZjU3YmM3Mg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2007-09-11T19:43:02Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2007-09-11T19:43:02Z"}, "message": "tree-ssa-structalias.c (push_fields_onto_fieldstack): Deal with TYPE_NONALIASED_COMPONENT like with DECL_NONADDRESSABLE_P.\n\n\t* tree-ssa-structalias.c (push_fields_onto_fieldstack): Deal with\n\tTYPE_NONALIASED_COMPONENT like with DECL_NONADDRESSABLE_P.\n\nada/\n\t* decl.c (array_type_has_nonaliased_component): New predicate.\n\t(gnat_to_gnu_field) <E_Array_Type>: Invoke the above predicate to\n\tset the TYPE_NONALIASED_COMPONENT flag on the type.\n\t<E_Array_Subtype>: Likewise.\n\t* gigi.h (type_for_nonaliased_component_p): Declare.\n\t* utils.c (type_for_nonaliased_component_p): New predicate.\n\t(create_field_decl): Invoke the above predicate to set the\n\tDECL_NONADDRESSABLE_P flag on the field.\n\nFrom-SVN: r128391", "tree": {"sha": "6794bfdde0fa3a761d0a915bf86007b0ca87d7e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6794bfdde0fa3a761d0a915bf86007b0ca87d7e2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fa89b6ecba4ce9448b82a21f91b360eacf57bc72", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa89b6ecba4ce9448b82a21f91b360eacf57bc72", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa89b6ecba4ce9448b82a21f91b360eacf57bc72", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa89b6ecba4ce9448b82a21f91b360eacf57bc72/comments", "author": null, "committer": null, "parents": [{"sha": "868eaa1f422576b092cc1bdcf576d4cfa3d18fb3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/868eaa1f422576b092cc1bdcf576d4cfa3d18fb3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/868eaa1f422576b092cc1bdcf576d4cfa3d18fb3"}], "stats": {"total": 101, "additions": 70, "deletions": 31}, "files": [{"sha": "3fff25df9b0466050aff97e309be575c79f30eb7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa89b6ecba4ce9448b82a21f91b360eacf57bc72/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa89b6ecba4ce9448b82a21f91b360eacf57bc72/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fa89b6ecba4ce9448b82a21f91b360eacf57bc72", "patch": "@@ -1,3 +1,8 @@\n+2007-09-11  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* tree-ssa-structalias.c (push_fields_onto_fieldstack): Deal with\n+\tTYPE_NONALIASED_COMPONENT like with DECL_NONADDRESSABLE_P.\n+\n 2007-09-11  Jason Merrill  <jason@redhat.com>\n \n \tPR middle-end/27945"}, {"sha": "6951351c64f0add8c87318f6a721c54c70f5018a", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa89b6ecba4ce9448b82a21f91b360eacf57bc72/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa89b6ecba4ce9448b82a21f91b360eacf57bc72/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=fa89b6ecba4ce9448b82a21f91b360eacf57bc72", "patch": "@@ -1,3 +1,14 @@\n+2007-09-11  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* decl.c (array_type_has_nonaliased_component): New predicate.\n+\t(gnat_to_gnu_field) <E_Array_Type>: Invoke the above predicate to\n+\tset the TYPE_NONALIASED_COMPONENT flag on the type.\n+\t<E_Array_Subtype>: Likewise.\n+\t* gigi.h (type_for_nonaliased_component_p): Declare.\n+\t* utils.c (type_for_nonaliased_component_p): New predicate.\n+\t(create_field_decl): Invoke the above predicate to set the\n+\tDECL_NONADDRESSABLE_P flag on the field.\n+\n 2007-09-11  Javier Miranda  <miranda@adacore.com>\n \n \t* einfo.ads, einfo.adb (Dispatch_Table_Wrapper): New attribute. Present"}, {"sha": "3d7c849fa713b0ff1315ad3538ceb74704397327", "filename": "gcc/ada/decl.c", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa89b6ecba4ce9448b82a21f91b360eacf57bc72/gcc%2Fada%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa89b6ecba4ce9448b82a21f91b360eacf57bc72/gcc%2Fada%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdecl.c?ref=fa89b6ecba4ce9448b82a21f91b360eacf57bc72", "patch": "@@ -103,6 +103,7 @@ static tree gnat_to_gnu_field (Entity_Id, tree, int, bool);\n static tree gnat_to_gnu_param (Entity_Id, Mechanism_Type, Entity_Id, bool,\n \t\t\t       bool *);\n static bool same_discriminant_p (Entity_Id, Entity_Id);\n+static bool array_type_has_nonaliased_component (Entity_Id, tree);\n static void components_to_record (tree, Node_Id, tree, int, bool, tree *,\n \t\t\t\t  bool, bool, bool, bool);\n static Uint annotate_value (tree);\n@@ -1788,16 +1789,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t  {\n \t    tem = build_array_type (tem, gnu_index_types[index]);\n \t    TYPE_MULTI_ARRAY_P (tem) = (index > 0);\n-\n-\t    /* If the type below this is a multi-array type, then this\n-\t       does not have aliased components.  But we have to make\n-\t       them addressable if it must be passed by reference or\n-\t       if that is the default.  */\n-\t    if ((TREE_CODE (TREE_TYPE (tem)) == ARRAY_TYPE\n-\t\t && TYPE_MULTI_ARRAY_P (TREE_TYPE (tem)))\n-\t\t|| (!Has_Aliased_Components (gnat_entity)\n-\t\t    && !must_pass_by_ref (TREE_TYPE (tem))\n-\t\t    && !default_pass_by_ref (TREE_TYPE (tem))))\n+\t    if (array_type_has_nonaliased_component (gnat_entity, tem))\n \t      TYPE_NONALIASED_COMPONENT (tem) = 1;\n \t  }\n \n@@ -2123,16 +2115,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    {\n \t      gnu_type = build_array_type (gnu_type, gnu_index_type[index]);\n \t      TYPE_MULTI_ARRAY_P (gnu_type) = (index > 0);\n-\n-\t      /* If the type below this is a multi-array type, then this\n-\t\t does not have aliased components.  But we have to make\n-\t\t them addressable if it must be passed by reference or\n-\t\t if that is the default.  */\n-\t      if ((TREE_CODE (TREE_TYPE (gnu_type)) == ARRAY_TYPE\n-\t\t   && TYPE_MULTI_ARRAY_P (TREE_TYPE (gnu_type)))\n-\t\t  || (!Has_Aliased_Components (gnat_entity)\n-\t\t      && !must_pass_by_ref (TREE_TYPE (gnu_type))\n-\t\t      && !default_pass_by_ref (TREE_TYPE (gnu_type))))\n+\t      if (array_type_has_nonaliased_component (gnat_entity, gnu_type))\n \t\tTYPE_NONALIASED_COMPONENT (gnu_type) = 1;\n \t    }\n \n@@ -4625,6 +4608,24 @@ same_discriminant_p (Entity_Id discr1, Entity_Id discr2)\n   return\n     Original_Record_Component (discr1) == Original_Record_Component (discr2);\n }\n+\n+/* Return true if the array type specified by GNAT_TYPE and GNU_TYPE has\n+   a non-aliased component in the back-end sense.  */\n+\n+static bool\n+array_type_has_nonaliased_component (Entity_Id gnat_type, tree gnu_type)\n+{\n+  /* If the type below this is a multi-array type, then\n+     this does not have aliased components.  */\n+  if (TREE_CODE (TREE_TYPE (gnu_type)) == ARRAY_TYPE\n+      && TYPE_MULTI_ARRAY_P (TREE_TYPE (gnu_type)))\n+    return true;\n+\n+  if (Has_Aliased_Components (gnat_type))\n+    return false;\n+\n+  return type_for_nonaliased_component_p (TREE_TYPE (gnu_type));\n+}\n \f\n /* Given GNAT_ENTITY, elaborate all expressions that are required to\n    be elaborated at the point of its definition, but do nothing else.  */"}, {"sha": "97a1862a268bc176798d120aec0ee9dd18855284", "filename": "gcc/ada/gigi.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa89b6ecba4ce9448b82a21f91b360eacf57bc72/gcc%2Fada%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa89b6ecba4ce9448b82a21f91b360eacf57bc72/gcc%2Fada%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgigi.h?ref=fa89b6ecba4ce9448b82a21f91b360eacf57bc72", "patch": "@@ -704,6 +704,10 @@ extern tree unchecked_convert (tree type, tree expr, bool notrunc_p);\n    the latter being a record type as predicated by Is_Record_Type.  */\n extern enum tree_code tree_code_for_record_type (Entity_Id);\n \n+/* Return true if GNU_TYPE is suitable as the type of a non-aliased\n+   component of an aggregate type.  */\n+extern bool type_for_nonaliased_component_p (tree);\n+\n /* Prepare expr to be an argument of a TRUTH_NOT_EXPR or other logical\n    operation.\n "}, {"sha": "56d490073c4870aa76db5a3925c40f8bc761c6bd", "filename": "gcc/ada/utils.c", "status": "modified", "additions": 22, "deletions": 9, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa89b6ecba4ce9448b82a21f91b360eacf57bc72/gcc%2Fada%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa89b6ecba4ce9448b82a21f91b360eacf57bc72/gcc%2Fada%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils.c?ref=fa89b6ecba4ce9448b82a21f91b360eacf57bc72", "patch": "@@ -1625,21 +1625,14 @@ create_field_decl (tree field_name, tree field_type, tree record_type,\n     }\n \n   /* In addition to what our caller says, claim the field is addressable if we\n-     know we might ever attempt to take its address, then mark the decl as\n-     nonaddressable accordingly.\n+     know that its type is not suitable.\n \n      The field may also be \"technically\" nonaddressable, meaning that even if\n      we attempt to take the field's address we will actually get the address\n      of a copy.  This is the case for true bitfields, but the DECL_BIT_FIELD\n      value we have at this point is not accurate enough, so we don't account\n      for this here and let finish_record_type decide.  */\n-\n-  /* We will take the address in any argument passing sequence if the field\n-     type is passed by reference, and we might need the address for any array\n-     type, even if normally passed by-copy, to construct a fat pointer if the\n-     field is used as an actual for an unconstrained formal.  */\n-  if (TREE_CODE (field_type) == ARRAY_TYPE\n-      || must_pass_by_ref (field_type) || default_pass_by_ref (field_type))\n+  if (!type_for_nonaliased_component_p (field_type))\n     addressable = 1;\n \n   DECL_NONADDRESSABLE_P (field_decl) = !addressable;\n@@ -4004,6 +3997,26 @@ tree_code_for_record_type (Entity_Id gnat_type)\n   return UNION_TYPE;\n }\n \n+/* Return true if GNU_TYPE is suitable as the type of a non-aliased\n+   component of an aggregate type.  */\n+\n+bool\n+type_for_nonaliased_component_p (tree gnu_type)\n+{\n+  /* If the type is passed by reference, we may have pointers to the\n+     component so it cannot be made non-aliased. */\n+  if (must_pass_by_ref (gnu_type) || default_pass_by_ref (gnu_type))\n+    return false;\n+\n+  /* We might need the address for any array type, even if normally\n+     passed by copy, to construct a fat pointer if the component is\n+     used as an actual for an unconstrained formal.  */\n+  if (TREE_CODE (gnu_type) == ARRAY_TYPE)\n+    return false;\n+\n+  return true;\n+}\n+\n /* Perform final processing on global variables.  */\n \n void"}, {"sha": "3e588bdfcdb499ad046a061a08219f200337ba90", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa89b6ecba4ce9448b82a21f91b360eacf57bc72/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa89b6ecba4ce9448b82a21f91b360eacf57bc72/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=fa89b6ecba4ce9448b82a21f91b360eacf57bc72", "patch": "@@ -4114,7 +4114,9 @@ push_fields_onto_fieldstack (tree type, VEC(fieldoff_s,heap) **fieldstack,\n \t  else if (!(pushed = push_fields_onto_fieldstack\n \t\t     (TREE_TYPE (type), fieldstack,\n \t\t      offset + i * TREE_INT_CST_LOW (elsz), has_union,\n-\t\t      TREE_TYPE (type))))\n+\t\t      (TYPE_NONALIASED_COMPONENT (type)\n+\t\t       ? addressable_type\n+\t\t       : TREE_TYPE (type)))))\n \t    /* Empty structures may have actual size, like in C++. So\n \t       see if we didn't push any subfields and the size is\n \t       nonzero, push the field onto the stack */\n@@ -4129,7 +4131,10 @@ push_fields_onto_fieldstack (tree type, VEC(fieldoff_s,heap) **fieldstack,\n \t      pair->size = elsz;\n \t      pair->decl = NULL_TREE;\n \t      pair->offset = offset + i * TREE_INT_CST_LOW (elsz);\n-\t      pair->alias_set = -1;\n+\t      if (TYPE_NONALIASED_COMPONENT (type))\n+\t\tpair->alias_set = get_alias_set (addressable_type);\n+\t      else\n+\t\tpair->alias_set = -1;\n \t      count++;\n \t    }\n \t  else"}]}