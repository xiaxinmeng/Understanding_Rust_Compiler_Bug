{"sha": "a1bc7628e49249aafa3f97a63a6662a3f6227f37", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTFiYzc2MjhlNDkyNDlhYWZhM2Y5N2E2M2E2NjYyYTNmNjIyN2YzNw==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2011-08-16T09:01:59Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2011-08-16T09:01:59Z"}, "message": "tree-vrp.c (extract_range_from_multiplicative_op_1): New helper factored out from ...\n\n2011-08-16  Richard Guenther  <rguenther@suse.de>\n\n\t* tree-vrp.c (extract_range_from_multiplicative_op_1): New\n\thelper factored out from ...\n\t(extract_range_from_binary_expr_1): ... here.  Re-structure\n\tto not glob handling too different tree codes.\n\nFrom-SVN: r177781", "tree": {"sha": "d4029785d142fce6937873e007275946fcf8bb9b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d4029785d142fce6937873e007275946fcf8bb9b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a1bc7628e49249aafa3f97a63a6662a3f6227f37", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1bc7628e49249aafa3f97a63a6662a3f6227f37", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a1bc7628e49249aafa3f97a63a6662a3f6227f37", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1bc7628e49249aafa3f97a63a6662a3f6227f37/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "776b90cd211d75caa42433b007cf8459855a30d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/776b90cd211d75caa42433b007cf8459855a30d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/776b90cd211d75caa42433b007cf8459855a30d6"}], "stats": {"total": 367, "additions": 218, "deletions": 149}, "files": [{"sha": "825c75f83d34228da4edd87e571372a473057a37", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1bc7628e49249aafa3f97a63a6662a3f6227f37/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1bc7628e49249aafa3f97a63a6662a3f6227f37/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a1bc7628e49249aafa3f97a63a6662a3f6227f37", "patch": "@@ -1,3 +1,10 @@\n+2011-08-16  Richard Guenther  <rguenther@suse.de>\n+\n+\t* tree-vrp.c (extract_range_from_multiplicative_op_1): New\n+\thelper factored out from ...\n+\t(extract_range_from_binary_expr_1): ... here.  Re-structure\n+\tto not glob handling too different tree codes.\n+\n 2011-08-15  Richard Henderson  <rth@redhat.com>\n \n \tPR middle-end/50006"}, {"sha": "df19cbbfdd1133d9a17d343cd13d2d02f7f03cd3", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 211, "deletions": 149, "changes": 360, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1bc7628e49249aafa3f97a63a6662a3f6227f37/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1bc7628e49249aafa3f97a63a6662a3f6227f37/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=a1bc7628e49249aafa3f97a63a6662a3f6227f37", "patch": "@@ -2181,6 +2181,158 @@ zero_nonzero_bits_from_vr (value_range_t *vr,\n   return true;\n }\n \n+/* Helper to extract a value-range *VR for a multiplicative operation\n+   *VR0 CODE *VR1.  */\n+\n+static void\n+extract_range_from_multiplicative_op_1 (value_range_t *vr,\n+\t\t\t\t\tenum tree_code code,\n+\t\t\t\t\tvalue_range_t *vr0, value_range_t *vr1)\n+{\n+  enum value_range_type type;\n+  tree val[4];\n+  size_t i;\n+  tree min, max;\n+  bool sop;\n+  int cmp;\n+\n+  /* Multiplications, divisions and shifts are a bit tricky to handle,\n+     depending on the mix of signs we have in the two ranges, we\n+     need to operate on different values to get the minimum and\n+     maximum values for the new range.  One approach is to figure\n+     out all the variations of range combinations and do the\n+     operations.\n+\n+     However, this involves several calls to compare_values and it\n+     is pretty convoluted.  It's simpler to do the 4 operations\n+     (MIN0 OP MIN1, MIN0 OP MAX1, MAX0 OP MIN1 and MAX0 OP MAX0 OP\n+     MAX1) and then figure the smallest and largest values to form\n+     the new range.  */\n+  gcc_assert (code == MULT_EXPR\n+\t      || code == TRUNC_DIV_EXPR\n+\t      || code == FLOOR_DIV_EXPR\n+\t      || code == CEIL_DIV_EXPR\n+\t      || code == EXACT_DIV_EXPR\n+\t      || code == ROUND_DIV_EXPR\n+\t      || code == RSHIFT_EXPR);\n+  gcc_assert ((vr0->type == VR_RANGE\n+\t       || (code == MULT_EXPR && vr0->type == VR_ANTI_RANGE))\n+\t      && vr0->type == vr1->type);\n+\n+  type = vr0->type;\n+\n+  /* Compute the 4 cross operations.  */\n+  sop = false;\n+  val[0] = vrp_int_const_binop (code, vr0->min, vr1->min);\n+  if (val[0] == NULL_TREE)\n+    sop = true;\n+\n+  if (vr1->max == vr1->min)\n+    val[1] = NULL_TREE;\n+  else\n+    {\n+      val[1] = vrp_int_const_binop (code, vr0->min, vr1->max);\n+      if (val[1] == NULL_TREE)\n+\tsop = true;\n+    }\n+\n+  if (vr0->max == vr0->min)\n+    val[2] = NULL_TREE;\n+  else\n+    {\n+      val[2] = vrp_int_const_binop (code, vr0->max, vr1->min);\n+      if (val[2] == NULL_TREE)\n+\tsop = true;\n+    }\n+\n+  if (vr0->min == vr0->max || vr1->min == vr1->max)\n+    val[3] = NULL_TREE;\n+  else\n+    {\n+      val[3] = vrp_int_const_binop (code, vr0->max, vr1->max);\n+      if (val[3] == NULL_TREE)\n+\tsop = true;\n+    }\n+\n+  if (sop)\n+    {\n+      set_value_range_to_varying (vr);\n+      return;\n+    }\n+\n+  /* Set MIN to the minimum of VAL[i] and MAX to the maximum\n+     of VAL[i].  */\n+  min = val[0];\n+  max = val[0];\n+  for (i = 1; i < 4; i++)\n+    {\n+      if (!is_gimple_min_invariant (min)\n+\t  || (TREE_OVERFLOW (min) && !is_overflow_infinity (min))\n+\t  || !is_gimple_min_invariant (max)\n+\t  || (TREE_OVERFLOW (max) && !is_overflow_infinity (max)))\n+\tbreak;\n+\n+      if (val[i])\n+\t{\n+\t  if (!is_gimple_min_invariant (val[i])\n+\t      || (TREE_OVERFLOW (val[i])\n+\t\t  && !is_overflow_infinity (val[i])))\n+\t    {\n+\t      /* If we found an overflowed value, set MIN and MAX\n+\t\t to it so that we set the resulting range to\n+\t\t VARYING.  */\n+\t      min = max = val[i];\n+\t      break;\n+\t    }\n+\n+\t  if (compare_values (val[i], min) == -1)\n+\t    min = val[i];\n+\n+\t  if (compare_values (val[i], max) == 1)\n+\t    max = val[i];\n+\t}\n+    }\n+\n+  /* If either MIN or MAX overflowed, then set the resulting range to\n+     VARYING.  But we do accept an overflow infinity\n+     representation.  */\n+  if (min == NULL_TREE\n+      || !is_gimple_min_invariant (min)\n+      || (TREE_OVERFLOW (min) && !is_overflow_infinity (min))\n+      || max == NULL_TREE\n+      || !is_gimple_min_invariant (max)\n+      || (TREE_OVERFLOW (max) && !is_overflow_infinity (max)))\n+    {\n+      set_value_range_to_varying (vr);\n+      return;\n+    }\n+\n+  /* We punt if:\n+     1) [-INF, +INF]\n+     2) [-INF, +-INF(OVF)]\n+     3) [+-INF(OVF), +INF]\n+     4) [+-INF(OVF), +-INF(OVF)]\n+     We learn nothing when we have INF and INF(OVF) on both sides.\n+     Note that we do accept [-INF, -INF] and [+INF, +INF] without\n+     overflow.  */\n+  if ((vrp_val_is_min (min) || is_overflow_infinity (min))\n+      && (vrp_val_is_max (max) || is_overflow_infinity (max)))\n+    {\n+      set_value_range_to_varying (vr);\n+      return;\n+    }\n+\n+  cmp = compare_values (min, max);\n+  if (cmp == -2 || cmp == 1)\n+    {\n+      /* If the new range has its limits swapped around (MIN > MAX),\n+\t then the operation caused one of them to wrap around, mark\n+\t the new range VARYING.  */\n+      set_value_range_to_varying (vr);\n+    }\n+  else\n+    set_value_range (vr, type, min, max, NULL);\n+}\n \n /* Extract range information from a binary operation CODE based on\n    the ranges of each of its operands, *VR0 and *VR1 with resulting\n@@ -2193,9 +2345,16 @@ extract_range_from_binary_expr_1 (value_range_t *vr,\n {\n   value_range_t vr0 = *vr0_, vr1 = *vr1_;\n   enum value_range_type type;\n-  tree min, max;\n+  tree min = NULL_TREE, max = NULL_TREE;\n   int cmp;\n \n+  if (!INTEGRAL_TYPE_P (expr_type)\n+      && !POINTER_TYPE_P (expr_type))\n+    {\n+      set_value_range_to_varying (vr);\n+      return;\n+    }\n+\n   /* Not all binary expressions can be applied to ranges in a\n      meaningful way.  Handle only arithmetic operations.  */\n   if (code != PLUS_EXPR\n@@ -2307,9 +2466,7 @@ extract_range_from_binary_expr_1 (value_range_t *vr,\n \n   /* For integer ranges, apply the operation to each end of the\n      range and see what we end up with.  */\n-  if (code == PLUS_EXPR\n-      || code == MIN_EXPR\n-      || code == MAX_EXPR)\n+  if (code == PLUS_EXPR)\n     {\n       /* If we have a PLUS_EXPR with two VR_ANTI_RANGEs, drop to\n \t VR_VARYING.  It would take more effort to compute a precise\n@@ -2320,32 +2477,21 @@ extract_range_from_binary_expr_1 (value_range_t *vr,\n \t this point.  */\n       if (vr0.type == VR_ANTI_RANGE)\n \t{\n-\t  if (code == PLUS_EXPR)\n-\t    {\n-\t      set_value_range_to_varying (vr);\n-\t      return;\n-\t    }\n-\t  /* For MIN_EXPR and MAX_EXPR with two VR_ANTI_RANGEs,\n-\t     the resulting VR_ANTI_RANGE is the same - intersection\n-\t     of the two ranges.  */\n-\t  min = vrp_int_const_binop (MAX_EXPR, vr0.min, vr1.min);\n-\t  max = vrp_int_const_binop (MIN_EXPR, vr0.max, vr1.max);\n-\t}\n-      else\n-\t{\n-\t  /* For operations that make the resulting range directly\n-\t     proportional to the original ranges, apply the operation to\n-\t     the same end of each range.  */\n-\t  min = vrp_int_const_binop (code, vr0.min, vr1.min);\n-\t  max = vrp_int_const_binop (code, vr0.max, vr1.max);\n+\t  set_value_range_to_varying (vr);\n+\t  return;\n \t}\n \n+      /* For operations that make the resulting range directly\n+\t proportional to the original ranges, apply the operation to\n+\t the same end of each range.  */\n+      min = vrp_int_const_binop (code, vr0.min, vr1.min);\n+      max = vrp_int_const_binop (code, vr0.max, vr1.max);\n+\n       /* If both additions overflowed the range kind is still correct.\n \t This happens regularly with subtracting something in unsigned\n \t arithmetic.\n          ???  See PR30318 for all the cases we do not handle.  */\n-      if (code == PLUS_EXPR\n-\t  && (TREE_OVERFLOW (min) && !is_overflow_infinity (min))\n+      if ((TREE_OVERFLOW (min) && !is_overflow_infinity (min))\n \t  && (TREE_OVERFLOW (max) && !is_overflow_infinity (max)))\n \t{\n \t  min = build_int_cst_wide (TREE_TYPE (min),\n@@ -2356,18 +2502,28 @@ extract_range_from_binary_expr_1 (value_range_t *vr,\n \t\t\t\t    TREE_INT_CST_HIGH (max));\n \t}\n     }\n-  else if (code == MULT_EXPR\n-\t   || code == TRUNC_DIV_EXPR\n-\t   || code == FLOOR_DIV_EXPR\n-\t   || code == CEIL_DIV_EXPR\n-\t   || code == EXACT_DIV_EXPR\n-\t   || code == ROUND_DIV_EXPR\n-\t   || code == RSHIFT_EXPR)\n+  else if (code == MIN_EXPR\n+\t   || code == MAX_EXPR)\n+    {\n+      if (vr0.type == VR_ANTI_RANGE)\n+\t{\n+\t  /* For MIN_EXPR and MAX_EXPR with two VR_ANTI_RANGEs,\n+\t     the resulting VR_ANTI_RANGE is the same - intersection\n+\t     of the two ranges.  */\n+\t  min = vrp_int_const_binop (MAX_EXPR, vr0.min, vr1.min);\n+\t  max = vrp_int_const_binop (MIN_EXPR, vr0.max, vr1.max);\n+\t}\n+      else\n+\t{\n+\t  /* For operations that make the resulting range directly\n+\t     proportional to the original ranges, apply the operation to\n+\t     the same end of each range.  */\n+\t  min = vrp_int_const_binop (code, vr0.min, vr1.min);\n+\t  max = vrp_int_const_binop (code, vr0.max, vr1.max);\n+\t}\n+    }\n+  else if (code == MULT_EXPR)\n     {\n-      tree val[4];\n-      size_t i;\n-      bool sop;\n-\n       /* If we have an unsigned MULT_EXPR with two VR_ANTI_RANGEs,\n \t drop to VR_VARYING.  It would take more effort to compute a\n \t precise range for such a case.  For example, if we have\n@@ -2376,14 +2532,18 @@ extract_range_from_binary_expr_1 (value_range_t *vr,\n \t we cannot claim that the product is in ~[0,0].  Note that we\n \t are guaranteed to have vr0.type == vr1.type at this\n \t point.  */\n-      if (code == MULT_EXPR\n-\t  && vr0.type == VR_ANTI_RANGE\n+      if (vr0.type == VR_ANTI_RANGE\n \t  && !TYPE_OVERFLOW_UNDEFINED (expr_type))\n \t{\n \t  set_value_range_to_varying (vr);\n \t  return;\n \t}\n \n+      extract_range_from_multiplicative_op_1 (vr, code, &vr0, &vr1);\n+      return;\n+    }\n+  else if (code == RSHIFT_EXPR)\n+    {\n       /* If we have a RSHIFT_EXPR with any shift values outside [0..prec-1],\n \t then drop to VR_VARYING.  Outside of this range we get undefined\n \t behavior from the shift operation.  We cannot even trust\n@@ -2402,12 +2562,16 @@ extract_range_from_binary_expr_1 (value_range_t *vr,\n \t    }\n \t}\n \n-      else if ((code == TRUNC_DIV_EXPR\n-\t\t|| code == FLOOR_DIV_EXPR\n-\t\t|| code == CEIL_DIV_EXPR\n-\t\t|| code == EXACT_DIV_EXPR\n-\t\t|| code == ROUND_DIV_EXPR)\n-\t       && (vr0.type != VR_RANGE || symbolic_range_p (&vr0)))\n+      extract_range_from_multiplicative_op_1 (vr, code, &vr0, &vr1);\n+      return;\n+    }\n+  else if (code == TRUNC_DIV_EXPR\n+\t   || code == FLOOR_DIV_EXPR\n+\t   || code == CEIL_DIV_EXPR\n+\t   || code == EXACT_DIV_EXPR\n+\t   || code == ROUND_DIV_EXPR)\n+    {\n+      if (vr0.type != VR_RANGE || symbolic_range_p (&vr0))\n \t{\n \t  /* For division, if op1 has VR_RANGE but op0 does not, something\n \t     can be deduced just from that range.  Say [min, max] / [4, max]\n@@ -2429,12 +2593,7 @@ extract_range_from_binary_expr_1 (value_range_t *vr,\n \n       /* For divisions, if flag_non_call_exceptions is true, we must\n \t not eliminate a division by zero.  */\n-      if ((code == TRUNC_DIV_EXPR\n-\t   || code == FLOOR_DIV_EXPR\n-\t   || code == CEIL_DIV_EXPR\n-\t   || code == EXACT_DIV_EXPR\n-\t   || code == ROUND_DIV_EXPR)\n-\t  && cfun->can_throw_non_call_exceptions\n+      if (cfun->can_throw_non_call_exceptions\n \t  && (vr1.type != VR_RANGE\n \t      || symbolic_range_p (&vr1)\n \t      || range_includes_zero_p (&vr1)))\n@@ -2446,20 +2605,14 @@ extract_range_from_binary_expr_1 (value_range_t *vr,\n       /* For divisions, if op0 is VR_RANGE, we can deduce a range\n \t even if op1 is VR_VARYING, VR_ANTI_RANGE, symbolic or can\n \t include 0.  */\n-      if ((code == TRUNC_DIV_EXPR\n-\t   || code == FLOOR_DIV_EXPR\n-\t   || code == CEIL_DIV_EXPR\n-\t   || code == EXACT_DIV_EXPR\n-\t   || code == ROUND_DIV_EXPR)\n-\t  && vr0.type == VR_RANGE\n+      if (vr0.type == VR_RANGE\n \t  && (vr1.type != VR_RANGE\n \t      || symbolic_range_p (&vr1)\n \t      || range_includes_zero_p (&vr1)))\n \t{\n \t  tree zero = build_int_cst (TREE_TYPE (vr0.min), 0);\n \t  int cmp;\n \n-\t  sop = false;\n \t  min = NULL_TREE;\n \t  max = NULL_TREE;\n \t  if (TYPE_UNSIGNED (expr_type)\n@@ -2498,96 +2651,10 @@ extract_range_from_binary_expr_1 (value_range_t *vr,\n \t      return;\n \t    }\n \t}\n-\n-      /* Multiplications and divisions are a bit tricky to handle,\n-\t depending on the mix of signs we have in the two ranges, we\n-\t need to operate on different values to get the minimum and\n-\t maximum values for the new range.  One approach is to figure\n-\t out all the variations of range combinations and do the\n-\t operations.\n-\n-\t However, this involves several calls to compare_values and it\n-\t is pretty convoluted.  It's simpler to do the 4 operations\n-\t (MIN0 OP MIN1, MIN0 OP MAX1, MAX0 OP MIN1 and MAX0 OP MAX0 OP\n-\t MAX1) and then figure the smallest and largest values to form\n-\t the new range.  */\n       else\n \t{\n-\t  gcc_assert ((vr0.type == VR_RANGE\n-\t\t       || (code == MULT_EXPR && vr0.type == VR_ANTI_RANGE))\n-\t\t      && vr0.type == vr1.type);\n-\n-\t  /* Compute the 4 cross operations.  */\n-\t  sop = false;\n-\t  val[0] = vrp_int_const_binop (code, vr0.min, vr1.min);\n-\t  if (val[0] == NULL_TREE)\n-\t    sop = true;\n-\n-\t  if (vr1.max == vr1.min)\n-\t    val[1] = NULL_TREE;\n-\t  else\n-\t    {\n-\t      val[1] = vrp_int_const_binop (code, vr0.min, vr1.max);\n-\t      if (val[1] == NULL_TREE)\n-\t\tsop = true;\n-\t    }\n-\n-\t  if (vr0.max == vr0.min)\n-\t    val[2] = NULL_TREE;\n-\t  else\n-\t    {\n-\t      val[2] = vrp_int_const_binop (code, vr0.max, vr1.min);\n-\t      if (val[2] == NULL_TREE)\n-\t\tsop = true;\n-\t    }\n-\n-\t  if (vr0.min == vr0.max || vr1.min == vr1.max)\n-\t    val[3] = NULL_TREE;\n-\t  else\n-\t    {\n-\t      val[3] = vrp_int_const_binop (code, vr0.max, vr1.max);\n-\t      if (val[3] == NULL_TREE)\n-\t\tsop = true;\n-\t    }\n-\n-\t  if (sop)\n-\t    {\n-\t      set_value_range_to_varying (vr);\n-\t      return;\n-\t    }\n-\n-\t  /* Set MIN to the minimum of VAL[i] and MAX to the maximum\n-\t     of VAL[i].  */\n-\t  min = val[0];\n-\t  max = val[0];\n-\t  for (i = 1; i < 4; i++)\n-\t    {\n-\t      if (!is_gimple_min_invariant (min)\n-\t\t  || (TREE_OVERFLOW (min) && !is_overflow_infinity (min))\n-\t\t  || !is_gimple_min_invariant (max)\n-\t\t  || (TREE_OVERFLOW (max) && !is_overflow_infinity (max)))\n-\t\tbreak;\n-\n-\t      if (val[i])\n-\t\t{\n-\t\t  if (!is_gimple_min_invariant (val[i])\n-\t\t      || (TREE_OVERFLOW (val[i])\n-\t\t\t  && !is_overflow_infinity (val[i])))\n-\t\t    {\n-\t\t      /* If we found an overflowed value, set MIN and MAX\n-\t\t\t to it so that we set the resulting range to\n-\t\t\t VARYING.  */\n-\t\t      min = max = val[i];\n-\t\t      break;\n-\t\t    }\n-\n-\t\t  if (compare_values (val[i], min) == -1)\n-\t\t    min = val[i];\n-\n-\t\t  if (compare_values (val[i], max) == 1)\n-\t\t    max = val[i];\n-\t\t}\n-\t    }\n+\t  extract_range_from_multiplicative_op_1 (vr, code, &vr0, &vr1);\n+\t  return;\n \t}\n     }\n   else if (code == TRUNC_MOD_EXPR)\n@@ -2733,11 +2800,6 @@ extract_range_from_binary_expr_1 (value_range_t *vr,\n \t  else\n \t    max = min = NULL_TREE;\n \t}\n-      else\n-\t{\n-\t  set_value_range_to_varying (vr);\n-\t  return;\n-\t}\n     }\n   else\n     gcc_unreachable ();"}]}