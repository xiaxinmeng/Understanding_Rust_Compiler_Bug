{"sha": "021921d0e44e1ab96434d8881b96306bd3df4c31", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDIxOTIxZDBlNDRlMWFiOTY0MzRkODg4MWI5NjMwNmJkM2RmNGMzMQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2001-02-19T00:00:08Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2001-02-19T00:00:08Z"}, "message": "sibcall.c (optimize_sibling_and_tail_recursive_call): Compare against last real insn in basic block.\n\n\t* sibcall.c (optimize_sibling_and_tail_recursive_call): Compare\n\tagainst last real insn in basic block.\n\tRework to avoid gotos.\n\nFrom-SVN: r39858", "tree": {"sha": "1ab57fac38106fe435334ac264664c2165a45c66", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1ab57fac38106fe435334ac264664c2165a45c66"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/021921d0e44e1ab96434d8881b96306bd3df4c31", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/021921d0e44e1ab96434d8881b96306bd3df4c31", "html_url": "https://github.com/Rust-GCC/gccrs/commit/021921d0e44e1ab96434d8881b96306bd3df4c31", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/021921d0e44e1ab96434d8881b96306bd3df4c31/comments", "author": null, "committer": null, "parents": [{"sha": "fb0c0a1270d945fb86e4abeaddc7e97481822270", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb0c0a1270d945fb86e4abeaddc7e97481822270", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fb0c0a1270d945fb86e4abeaddc7e97481822270"}], "stats": {"total": 118, "additions": 52, "deletions": 66}, "files": [{"sha": "571a1ca299bb458c5cec32e97c30a22132d1e6a6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/021921d0e44e1ab96434d8881b96306bd3df4c31/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/021921d0e44e1ab96434d8881b96306bd3df4c31/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=021921d0e44e1ab96434d8881b96306bd3df4c31", "patch": "@@ -1,5 +1,9 @@\n Sun Feb 18 15:45:17 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n+\t* sibcall.c (optimize_sibling_and_tail_recursive_call): Compare\n+\tagainst last real insn in basic block.\n+\tRework to avoid gotos.\n+\n \t* Makefile.in (gcse.o): Now includes ggc.h.\n \t* gcse.c: Include ggc.h.\n \t(want_to_gcse_p): Verify expression can be in SET as valid insn."}, {"sha": "debefc709923cb2311719c26abe8d4f9e44cc947", "filename": "gcc/sibcall.c", "status": "modified", "additions": 48, "deletions": 66, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/021921d0e44e1ab96434d8881b96306bd3df4c31/gcc%2Fsibcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/021921d0e44e1ab96434d8881b96306bd3df4c31/gcc%2Fsibcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsibcall.c?ref=021921d0e44e1ab96434d8881b96306bd3df4c31", "patch": "@@ -533,20 +533,18 @@ optimize_sibling_and_tail_recursive_calls ()\n \t{\n \t  int sibcall = (XEXP (PATTERN (insn), 1) != NULL_RTX);\n \t  int tailrecursion = (XEXP (PATTERN (insn), 2) != NULL_RTX);\n-\t  basic_block succ_block, call_block;\n-\t  rtx temp, hardret, softret;\n+\t  basic_block call_block;\n+\t  rtx end, temp, hardret, softret;\n \n \t  /* We must be careful with stack slots which are live at\n \t     potential optimization sites.\n \n \t     ?!? This test is overly conservative and will be replaced.  */\n-\t  if (frame_offset)\n-\t    goto failure;\n-\n-\t  /* Taking the address of a local variable is fatal to tail\n-\t     recursion if the address is used by the recursive call.  */\n-\t  if (current_function_uses_addressof)\n-\t    goto failure;\n+\t  if (frame_offset\n+\t      /* Taking the address of a local variable is fatal to tail\n+\t\t recursion if the address is used by the recursive call.  */\n+\t      || current_function_uses_addressof)\n+\t    sibcall = 0, tailrecursion = 0;\n \n \t  /* alloca (until we have stack slot life analysis) inhibits\n \t     sibling call optimizations, but not tail recursion.\n@@ -556,73 +554,57 @@ optimize_sibling_and_tail_recursive_calls ()\n \t      || current_function_varargs || current_function_stdarg)\n \t    sibcall = 0;\n \n+\t  /* Get the block for the call and the last non-note insn in it.  We\n+\t     take advantage of the fact that this cannot be the exit block.  */\n \t  call_block = BLOCK_FOR_INSN (insn);\n+\t  end = prev_nonnote_insn (NEXT_INSN (call_block->end));\n \n \t  /* If the block has more than one successor, then we can not\n-\t     perform sibcall or tail recursion optimizations.  */\n+\t     perform sibcall or tail recursion optimizations.  If the single\n+\t     successor is not the exit block, then we can not perform sibcall\n+\t     or tail recursion optimizations.  Note that these two tests\n+\t     combined are sufficient to prevent tail call optimization in the\n+\t     presense of active exception handlers.  */\n \t  if (call_block->succ == NULL\n-\t      || call_block->succ->succ_next != NULL)\n-\t    goto failure;\n-\n-\t  /* If the single successor is not the exit block, then we can not\n-\t     perform sibcall or tail recursion optimizations. \n-\n-\t     Note that this test combined with the previous is sufficient\n-\t     to prevent tail call optimization in the presense of active\n-\t     exception handlers.  */\n-\t  succ_block = call_block->succ->dest;\n-\t  if (succ_block != EXIT_BLOCK_PTR && succ_block != alternate_exit)\n-\t    goto failure;\n-\n-\t  /* If the call was the end of the block, then we're OK.  */\n-\t  temp = insn;\n-\t  if (temp == call_block->end)\n-\t    goto success;\n-\n-\t  /* Skip over copying from the call's return value pseudo into\n-\t     this function's hard return register.  */\n-\t  if (identify_call_return_value (PATTERN (insn), &hardret, &softret))\n-\t    {\n-\t      temp = skip_copy_to_return_value (temp, hardret, softret);\n-\t      if (temp == call_block->end)\n-\t        goto success;\n-\t    }\n-\n-\t  /* Skip any stack adjustment.  */\n-\t  temp = skip_stack_adjustment (temp);\n-\t  if (temp == call_block->end)\n-\t    goto success;\n-\n-\t  /* Skip over a CLOBBER of the return value (as a hard reg).  */\n-\t  temp = skip_use_of_return_value (temp, CLOBBER);\n-\t  if (temp == call_block->end)\n-\t    goto success;\n-\n-\t  /* Skip over a USE of the return value (as a hard reg).  */\n-\t  temp = skip_use_of_return_value (temp, USE);\n-\t  if (temp == call_block->end)\n-\t    goto success;\n-\n-\t  /* Skip over the JUMP_INSN at the end of the block.  */\n-\t  temp = skip_jump_insn (temp);\n-\t  if (GET_CODE (temp) == NOTE)\n-\t    temp = next_nonnote_insn (temp);\n-\t  if (temp == call_block->end)\n-\t    goto success;\n-\n-\t  /* There are operations at the end of the block which we must\n-\t     execute after returning from the function call.  So this call\n-\t     can not be optimized.  */\n-failure:\n-\t  sibcall = 0, tailrecursion = 0;\n-success:\n+\t      || call_block->succ->succ_next != NULL\n+\t      || (call_block->succ->dest != EXIT_BLOCK_PTR\n+\t\t  && call_block->succ->dest != alternate_exit))\n+\t    sibcall = 0, tailrecursion = 0;\n+\t  \n+\t  /* If we haven't failed yet, check if this (or safe things) ends our\n+\t     block.  */\n+\t  if ((sibcall || tailrecursion)\n+\t      /* If the call was the end of the block, then we're OK.  */\n+\t      && (end == (temp = insn)\n+\t\t  /* Skip over copying from the call's return value pseudo into\n+\t\t     this function's hard return register and if that's the end\n+\t\t     of the block, we're OK.  */\n+\t\t  || (identify_call_return_value (PATTERN (insn), &hardret,\n+\t\t\t\t\t\t  &softret)\n+\t\t      && end == (temp = skip_copy_to_return_value (insn,\n+\t\t\t\t\t\t\t\t   hardret,\n+\t\t\t\t\t\t\t\t   softret)))\n+\t\t  /* Skip any stack adjustment.  */\n+\t\t  || end == (temp = skip_stack_adjustment (temp))\n+\t\t  /* Skip over a CLOBBER of the return value as a hard reg.  */\n+\t\t  || end == (temp = skip_use_of_return_value (temp, CLOBBER))\n+\t\t  /* Skip over a USE of the return value (as a hard reg).  */\n+\t\t  || end == (temp = skip_use_of_return_value (temp, USE))\n+\t\t  /* Skip over the JUMP_INSN at the end of the block.  */\n+\t\t  || end == (temp = skip_jump_insn (temp))))\n+\t    ;\n+\t  else\n+\t    /* There are operations at the end of the block which we must\n+\t       execute after returning from the function call.  So this call\n+\t       can not be optimized.  */\n+\t    sibcall = 0, tailrecursion = 0;\n \n \t  /* Select a set of insns to implement the call and emit them.\n \t     Tail recursion is the most efficient, so select it over\n \t     a tail/sibling call.  */\n-  \n \t  if (sibcall)\n \t    successful_sibling_call = 1;\n+\n \t  replaced_call_placeholder = 1;\n \t  replace_call_placeholder (insn, \n \t\t\t\t    tailrecursion != 0 "}]}