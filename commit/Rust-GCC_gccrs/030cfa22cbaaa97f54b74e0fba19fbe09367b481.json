{"sha": "030cfa22cbaaa97f54b74e0fba19fbe09367b481", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDMwY2ZhMjJjYmFhYTk3ZjU0Yjc0ZTBmYmExOWZiZTA5MzY3YjQ4MQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2017-06-02T13:23:08Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2017-06-02T13:23:08Z"}, "message": "Remove lang_type_ptrmem.\n\n\tcp/\n\tRemove lang_type_ptrmem.\n\t* cp-tree.h (lang_type_header): Remove is_lang_type_class. Move\n\tinto ...\n\t(lang_type_class): ... this.  Reorder bitfields.  Rename to ...\n\t(lang_type): ... this.  Delete old definition.\n\t(lang_type_ptrmem): Delete.\n\t(LANG_TYPE_CLASS_CHECK): Simply get TYPE_LANG_SPECIFIC.  Adjust\n\tuses.\n\t(LANG_TYPE_PTRMEM_CHECK): Delete.\n\t(TYPE_GET_PTRMEMFUNC_TYPE, TYPE_SET_PTRMEMFUNC_TYPE): Delete.\n\t(TYPE_PTRMEMFUNC_TYPE): New.  Use TYPE_LANG_SLOT_1.\n\t* decl.c (build_ptrmemfunc_type): Adjust.\n\t* lex.c (copy_lang_type): Remove lang_type_ptrmem handling.\n\t(maybe_add_lang_type_raw): Don't set u.c.h.is_lang_type_class.\n\n\tobjcp/\n\t* objcp-decl.h (SIZEOF_OBJC_TYPE_LANG_SPECIFIC): Use lang_type.\n\t(ALLOC_OBJC_TYPE_LANG_SPECIFIC): Use it.  Don't set\n\tu.c.h.is_lang_type_class.\n\nFrom-SVN: r248826", "tree": {"sha": "b860dbc9fa66af625ee6f7a4ef8cef3e9b0557fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b860dbc9fa66af625ee6f7a4ef8cef3e9b0557fd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/030cfa22cbaaa97f54b74e0fba19fbe09367b481", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/030cfa22cbaaa97f54b74e0fba19fbe09367b481", "html_url": "https://github.com/Rust-GCC/gccrs/commit/030cfa22cbaaa97f54b74e0fba19fbe09367b481", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/030cfa22cbaaa97f54b74e0fba19fbe09367b481/comments", "author": null, "committer": null, "parents": [{"sha": "9186a9d353815352d9625fc765dd0449fb64d8a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9186a9d353815352d9625fc765dd0449fb64d8a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9186a9d353815352d9625fc765dd0449fb64d8a9"}], "stats": {"total": 152, "additions": 46, "deletions": 106}, "files": [{"sha": "96377cc79aed2a813937eecef57fcc1b7ef1ec50", "filename": "gcc/cp/class.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/030cfa22cbaaa97f54b74e0fba19fbe09367b481/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/030cfa22cbaaa97f54b74e0fba19fbe09367b481/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=030cfa22cbaaa97f54b74e0fba19fbe09367b481", "patch": "@@ -6025,7 +6025,7 @@ check_bases_and_members (tree t)\n \n   /* Figure out whether or not we will need a cookie when dynamically\n      allocating an array of this type.  */\n-  TYPE_LANG_SPECIFIC (t)->u.c.vec_new_uses_cookie\n+  LANG_TYPE_CLASS_CHECK (t)->vec_new_uses_cookie\n     = type_requires_array_cookie (t);\n }\n "}, {"sha": "da45d95cb67ad9d50b4f83940d4627ba6d67c706", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 29, "deletions": 80, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/030cfa22cbaaa97f54b74e0fba19fbe09367b481/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/030cfa22cbaaa97f54b74e0fba19fbe09367b481/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=030cfa22cbaaa97f54b74e0fba19fbe09367b481", "patch": "@@ -460,6 +460,7 @@ extern GTY(()) tree cp_global_trees[CPTI_MAX];\n    TYPE_LANG_SLOT_1\n      For an ENUMERAL_TYPE, this is ENUM_TEMPLATE_INFO.\n      For a FUNCTION_TYPE or METHOD_TYPE, this is TYPE_RAISES_EXCEPTIONS\n+     For a POINTER_TYPE (to a METHOD_TYPE), this is TYPE_PTRMEMFUNC_TYPE\n \n   BINFO_VIRTUALS\n      For a binfo, this is a TREE_LIST.  There is an entry for each\n@@ -1849,22 +1850,6 @@ struct GTY (()) tree_pair_s {\n };\n typedef tree_pair_s *tree_pair_p;\n \n-/* This is a few header flags for 'struct lang_type'.  Actually,\n-   all but the first are used only for lang_type_class; they\n-   are put in this structure to save space.  */\n-struct GTY(()) lang_type_header {\n-  BOOL_BITFIELD is_lang_type_class : 1;\n-\n-  BOOL_BITFIELD has_type_conversion : 1;\n-  BOOL_BITFIELD has_copy_ctor : 1;\n-  BOOL_BITFIELD has_default_ctor : 1;\n-  BOOL_BITFIELD const_needs_init : 1;\n-  BOOL_BITFIELD ref_needs_init : 1;\n-  BOOL_BITFIELD has_const_copy_assign : 1;\n-\n-  BOOL_BITFIELD spare : 1;\n-};\n-\n /* This structure provides additional information above and beyond\n    what is provide in the ordinary tree_type.  In the past, we used it\n    for the types of class types, template parameters types, typename\n@@ -1878,11 +1863,17 @@ struct GTY(()) lang_type_header {\n    many (i.e., thousands) of classes can easily be generated.\n    Therefore, we should endeavor to keep the size of this structure to\n    a minimum.  */\n-struct GTY(()) lang_type_class {\n-  struct lang_type_header h;\n-\n+struct GTY(()) lang_type {\n   unsigned char align;\n \n+  unsigned has_type_conversion : 1;\n+  unsigned has_copy_ctor : 1;\n+  unsigned has_default_ctor : 1;\n+  unsigned const_needs_init : 1;\n+  unsigned ref_needs_init : 1;\n+  unsigned has_const_copy_assign : 1;\n+  unsigned use_template : 2;\n+\n   unsigned has_mutable : 1;\n   unsigned com_interface : 1;\n   unsigned non_pod_class : 1;\n@@ -1899,6 +1890,7 @@ struct GTY(()) lang_type_class {\n   unsigned anon_aggr : 1;\n   unsigned non_zero_init : 1;\n   unsigned empty_p : 1;\n+  /* 32 bits allocated.  */\n \n   unsigned vec_new_uses_cookie : 1;\n   unsigned declared_class : 1;\n@@ -1909,25 +1901,24 @@ struct GTY(()) lang_type_class {\n   unsigned fields_readonly : 1;\n   unsigned ptrmemfunc_flag : 1;\n \n-  unsigned use_template : 2;\n   unsigned was_anonymous : 1;\n   unsigned lazy_default_ctor : 1;\n   unsigned lazy_copy_ctor : 1;\n   unsigned lazy_copy_assign : 1;\n   unsigned lazy_destructor : 1;\n   unsigned has_const_copy_ctor : 1;\n-\n   unsigned has_complex_copy_ctor : 1;\n   unsigned has_complex_copy_assign : 1;\n+\n   unsigned non_aggregate : 1;\n   unsigned has_complex_dflt : 1;\n   unsigned has_list_ctor : 1;\n   unsigned non_std_layout : 1;\n   unsigned is_literal : 1;\n   unsigned lazy_move_ctor : 1;\n-\n   unsigned lazy_move_assign : 1;\n   unsigned has_complex_move_ctor : 1;\n+\n   unsigned has_complex_move_assign : 1;\n   unsigned has_constexpr_ctor : 1;\n   unsigned unique_obj_representations : 1;\n@@ -1940,7 +1931,7 @@ struct GTY(()) lang_type_class {\n   /* There are some bits left to fill out a 32-bit word.  Keep track\n      of this by updating the size of this bitfield whenever you add or\n      remove a flag.  */\n-  unsigned dummy : 2;\n+  unsigned dummy : 4;\n \n   tree primary_base;\n   vec<tree_pair_s, va_gc> *vcall_indices;\n@@ -1968,40 +1959,9 @@ struct GTY(()) lang_type_class {\n   tree lambda_expr;\n };\n \n-struct GTY(()) lang_type_ptrmem {\n-  struct lang_type_header h;\n-  tree record;\n-};\n-\n-struct GTY(()) lang_type {\n-  union lang_type_u\n-  {\n-    struct lang_type_header GTY((skip (\"\"))) h;\n-    struct lang_type_class  GTY((tag (\"1\"))) c;\n-    struct lang_type_ptrmem GTY((tag (\"0\"))) ptrmem;\n-  } GTY((desc (\"%h.h.is_lang_type_class\"))) u;\n-};\n-\n-#if defined ENABLE_TREE_CHECKING && (GCC_VERSION >= 2007)\n-\n-#define LANG_TYPE_CLASS_CHECK(NODE) __extension__\t\t\\\n-({  struct lang_type *lt = TYPE_LANG_SPECIFIC (NODE);\t\t\\\n-    if (! lt->u.h.is_lang_type_class)\t\t\t\t\\\n-      lang_check_failed (__FILE__, __LINE__, __FUNCTION__);\t\\\n-    &lt->u.c; })\n-\n-#define LANG_TYPE_PTRMEM_CHECK(NODE) __extension__\t\t\\\n-({  struct lang_type *lt = TYPE_LANG_SPECIFIC (NODE);\t\t\\\n-    if (lt->u.h.is_lang_type_class)\t\t\t\t\\\n-      lang_check_failed (__FILE__, __LINE__, __FUNCTION__);\t\\\n-    &lt->u.ptrmem; })\n-\n-#else\n-\n-#define LANG_TYPE_CLASS_CHECK(NODE) (&TYPE_LANG_SPECIFIC (NODE)->u.c)\n-#define LANG_TYPE_PTRMEM_CHECK(NODE) (&TYPE_LANG_SPECIFIC (NODE)->u.ptrmem)\n-\n-#endif /* ENABLE_TREE_CHECKING */\n+/* We used to have a variant type for lang_type.  Keep the name of the\n+   checking accessor for the sole survivor.  */\n+#define LANG_TYPE_CLASS_CHECK(NODE) (TYPE_LANG_SPECIFIC (NODE))\n \n /* Nonzero for _CLASSTYPE means that operator delete is defined.  */\n #define TYPE_GETS_DELETE(NODE) (LANG_TYPE_CLASS_CHECK (NODE)->gets_delete)\n@@ -2016,7 +1976,7 @@ struct GTY(()) lang_type {\n /* Nonzero means that this _CLASSTYPE node defines ways of converting\n    itself to other types.  */\n #define TYPE_HAS_CONVERSION(NODE) \\\n-  (LANG_TYPE_CLASS_CHECK (NODE)->h.has_type_conversion)\n+  (LANG_TYPE_CLASS_CHECK (NODE)->has_type_conversion)\n \n /* Nonzero means that NODE (a class type) has a default constructor --\n    but that it has not yet been declared.  */\n@@ -2059,10 +2019,10 @@ struct GTY(()) lang_type {\n /* True iff the class type NODE has an \"operator =\" whose parameter\n    has a parameter of type \"const X&\".  */\n #define TYPE_HAS_CONST_COPY_ASSIGN(NODE) \\\n-  (LANG_TYPE_CLASS_CHECK (NODE)->h.has_const_copy_assign)\n+  (LANG_TYPE_CLASS_CHECK (NODE)->has_const_copy_assign)\n \n /* Nonzero means that this _CLASSTYPE node has an X(X&) constructor.  */\n-#define TYPE_HAS_COPY_CTOR(NODE) (LANG_TYPE_CLASS_CHECK (NODE)->h.has_copy_ctor)\n+#define TYPE_HAS_COPY_CTOR(NODE) (LANG_TYPE_CLASS_CHECK (NODE)->has_copy_ctor)\n #define TYPE_HAS_CONST_COPY_CTOR(NODE) \\\n   (LANG_TYPE_CLASS_CHECK (NODE)->has_const_copy_ctor)\n \n@@ -2214,7 +2174,7 @@ struct GTY(()) lang_type {\n \n /* Nonzero means that this type has an X() constructor.  */\n #define TYPE_HAS_DEFAULT_CONSTRUCTOR(NODE) \\\n-  (LANG_TYPE_CLASS_CHECK (NODE)->h.has_default_ctor)\n+  (LANG_TYPE_CLASS_CHECK (NODE)->has_default_ctor)\n \n /* Nonzero means that this type contains a mutable member.  */\n #define CLASSTYPE_HAS_MUTABLE(NODE) (LANG_TYPE_CLASS_CHECK (NODE)->has_mutable)\n@@ -2283,17 +2243,17 @@ struct GTY(()) lang_type {\n    which have no specified initialization.  */\n #define CLASSTYPE_READONLY_FIELDS_NEED_INIT(NODE)\t\\\n   (TYPE_LANG_SPECIFIC (NODE)\t\t\t\t\\\n-   ? LANG_TYPE_CLASS_CHECK (NODE)->h.const_needs_init : 0)\n+   ? LANG_TYPE_CLASS_CHECK (NODE)->const_needs_init : 0)\n #define SET_CLASSTYPE_READONLY_FIELDS_NEED_INIT(NODE, VALUE) \\\n-  (LANG_TYPE_CLASS_CHECK (NODE)->h.const_needs_init = (VALUE))\n+  (LANG_TYPE_CLASS_CHECK (NODE)->const_needs_init = (VALUE))\n \n /* Nonzero if this class has ref members\n    which have no specified initialization.  */\n #define CLASSTYPE_REF_FIELDS_NEED_INIT(NODE)\t\t\\\n   (TYPE_LANG_SPECIFIC (NODE)\t\t\t\t\\\n-   ? LANG_TYPE_CLASS_CHECK (NODE)->h.ref_needs_init : 0)\n+   ? LANG_TYPE_CLASS_CHECK (NODE)->ref_needs_init : 0)\n #define SET_CLASSTYPE_REF_FIELDS_NEED_INIT(NODE, VALUE) \\\n-  (LANG_TYPE_CLASS_CHECK (NODE)->h.ref_needs_init = (VALUE))\n+  (LANG_TYPE_CLASS_CHECK (NODE)->ref_needs_init = (VALUE))\n \n /* Nonzero if this class is included from a header file which employs\n    `#pragma interface', and it is not included in its implementation file.  */\n@@ -4296,21 +4256,10 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n #define TYPE_PTRMEMFUNC_OBJECT_TYPE(NODE) \\\n   TYPE_METHOD_BASETYPE (TREE_TYPE (TYPE_PTRMEMFUNC_FN_TYPE (NODE)))\n \n-/* These are use to manipulate the canonical RECORD_TYPE from the\n-   hashed POINTER_TYPE, and can only be used on the POINTER_TYPE.  */\n-#define TYPE_GET_PTRMEMFUNC_TYPE(NODE) \\\n-  (TYPE_LANG_SPECIFIC (NODE) ? LANG_TYPE_PTRMEM_CHECK (NODE)->record : NULL)\n-#define TYPE_SET_PTRMEMFUNC_TYPE(NODE, VALUE)\t\t\t\t\\\n-  do {\t\t\t\t\t\t\t\t\t\\\n-    if (TYPE_LANG_SPECIFIC (NODE) == NULL)\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tTYPE_LANG_SPECIFIC (NODE)                                       \\\n-\t= (struct lang_type *) ggc_internal_cleared_alloc\t\t\\\n-\t (sizeof (struct lang_type_ptrmem));\t\t\t\t\\\n-\tTYPE_LANG_SPECIFIC (NODE)->u.ptrmem.h.is_lang_type_class = 0;\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-    TYPE_LANG_SPECIFIC (NODE)->u.ptrmem.record = (VALUE);\t\t\\\n-  } while (0)\n+/* The canonical internal RECORD_TYPE from the POINTER_TYPE to\n+   METHOD_TYPE.  */\n+#define TYPE_PTRMEMFUNC_TYPE(NODE) \\\n+  TYPE_LANG_SLOT_1 (NODE)\n \n /* For a pointer-to-member type of the form `T X::*', this is `X'.\n    For a type like `void (X::*)() const', this type is `X', not `const"}, {"sha": "b144426d56fb872b13364025ffcc2a8edc345e97", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/030cfa22cbaaa97f54b74e0fba19fbe09367b481/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/030cfa22cbaaa97f54b74e0fba19fbe09367b481/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=030cfa22cbaaa97f54b74e0fba19fbe09367b481", "patch": "@@ -9154,7 +9154,9 @@ build_ptrmemfunc_type (tree type)\n      this method instead of type_hash_canon, because it only does a\n      simple equality check on the list of field members.  */\n \n-  if ((t = TYPE_GET_PTRMEMFUNC_TYPE (type)))\n+\n+  t = TYPE_PTRMEMFUNC_TYPE (type);\n+  if (t)\n     return t;\n \n   t = make_node (RECORD_TYPE);\n@@ -9178,7 +9180,7 @@ build_ptrmemfunc_type (tree type)\n \n   /* Cache this pointer-to-member type so that we can find it again\n      later.  */\n-  TYPE_SET_PTRMEMFUNC_TYPE (type, t);\n+  TYPE_PTRMEMFUNC_TYPE (type) = t;\n \n   if (TYPE_STRUCTURAL_EQUALITY_P (type))\n     SET_TYPE_STRUCTURAL_EQUALITY (t);"}, {"sha": "cf7c0d11ab3a172a18ba6bad39e40518dec2ba10", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 8, "deletions": 16, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/030cfa22cbaaa97f54b74e0fba19fbe09367b481/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/030cfa22cbaaa97f54b74e0fba19fbe09367b481/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=030cfa22cbaaa97f54b74e0fba19fbe09367b481", "patch": "@@ -678,24 +678,19 @@ copy_decl (tree decl MEM_STAT_DECL)\n static void\n copy_lang_type (tree node)\n {\n-  int size;\n-  struct lang_type *lt;\n-\n   if (! TYPE_LANG_SPECIFIC (node))\n     return;\n \n-  if (TYPE_LANG_SPECIFIC (node)->u.h.is_lang_type_class)\n-    size = sizeof (struct lang_type);\n-  else\n-    size = sizeof (struct lang_type_ptrmem);\n-  lt = (struct lang_type *) ggc_internal_alloc (size);\n-  memcpy (lt, TYPE_LANG_SPECIFIC (node), size);\n+  struct lang_type *lt\n+    = (struct lang_type *) ggc_internal_alloc (sizeof (struct lang_type));\n+\n+  memcpy (lt, TYPE_LANG_SPECIFIC (node), (sizeof (struct lang_type)));\n   TYPE_LANG_SPECIFIC (node) = lt;\n \n   if (GATHER_STATISTICS)\n     {\n       tree_node_counts[(int)lang_type] += 1;\n-      tree_node_sizes[(int)lang_type] += size;\n+      tree_node_sizes[(int)lang_type] += sizeof (struct lang_type);\n     }\n }\n \n@@ -720,12 +715,9 @@ maybe_add_lang_type_raw (tree t)\n \t      || TREE_CODE (t) == BOUND_TEMPLATE_TEMPLATE_PARM);\n   if (add)\n     {\n-      struct lang_type *pi\n-\t= (struct lang_type *) ggc_internal_cleared_alloc\n-\t(sizeof (struct lang_type));\n-\n-      TYPE_LANG_SPECIFIC (t) = pi;\n-      pi->u.c.h.is_lang_type_class = 1;\n+      TYPE_LANG_SPECIFIC (t)\n+\t= (struct lang_type *) (ggc_internal_cleared_alloc\n+\t\t\t\t(sizeof (struct lang_type)));\n \n       if (GATHER_STATISTICS)\n \t{"}, {"sha": "2da7e71510d31be1ac7cf1fa5e0919752ee6224a", "filename": "gcc/objcp/objcp-decl.h", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/030cfa22cbaaa97f54b74e0fba19fbe09367b481/gcc%2Fobjcp%2Fobjcp-decl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/030cfa22cbaaa97f54b74e0fba19fbe09367b481/gcc%2Fobjcp%2Fobjcp-decl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjcp%2Fobjcp-decl.h?ref=030cfa22cbaaa97f54b74e0fba19fbe09367b481", "patch": "@@ -62,14 +62,11 @@ extern tree objcp_end_compound_stmt (tree, int);\n #undef TYPE_OBJC_INFO\n #define TYPE_OBJC_INFO(TYPE) LANG_TYPE_CLASS_CHECK (TYPE)->objc_info\n #undef SIZEOF_OBJC_TYPE_LANG_SPECIFIC\n-#define SIZEOF_OBJC_TYPE_LANG_SPECIFIC sizeof (struct lang_type_class)\n+#define SIZEOF_OBJC_TYPE_LANG_SPECIFIC sizeof (struct lang_type)\n #undef ALLOC_OBJC_TYPE_LANG_SPECIFIC\n-#define ALLOC_OBJC_TYPE_LANG_SPECIFIC(NODE)\t\t\t\t\\\n-  do {\t\t\t\t\t\t\t\t\t\\\n-    TYPE_LANG_SPECIFIC (NODE) = (struct lang_type *) \\\n-      ggc_internal_cleared_alloc (sizeof (struct lang_type_class));\t\\\n-    TYPE_LANG_SPECIFIC (NODE)->u.c.h.is_lang_type_class = 1;\t\t\\\n-  } while (0)\n+#define ALLOC_OBJC_TYPE_LANG_SPECIFIC(NODE)\t\t\t\\\n+  (TYPE_LANG_SPECIFIC (NODE) = (struct lang_type *)\t\t\\\n+   ggc_internal_cleared_alloc (SIZEOF_OBJC_TYPE_LANG_SPECIFIC))\n \n #define OBJCP_ORIGINAL_FUNCTION(name, args) \t(name)args\n "}]}