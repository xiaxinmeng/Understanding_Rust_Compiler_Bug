{"sha": "5b9633c834593d626e85321b22bd5549f0df5bc9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWI5NjMzYzgzNDU5M2Q2MjZlODUzMjFiMjJiZDU1NDlmMGRmNWJjOQ==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2009-07-24T13:27:41Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2009-07-24T13:27:41Z"}, "message": "ipa-prop.h (struct ipa_node_params): New flag node_enqued.\n\n2009-07-24  Martin Jambor  <mjambor@suse.cz>\n\n\t* ipa-prop.h (struct ipa_node_params): New flag node_enqued.\n\t(ipa_push_func_to_list_1): Declare.\n\t(ipa_push_func_to_list): New function.\n\n\t* ipa-prop.c (ipa_push_func_to_list_1): New function.\n\t(ipa_init_func_list): Call ipa_push_func_to_list_1.\n\t(ipa_push_func_to_list): Removed.\n\t(ipa_pop_func_from_list): Clear node_enqueued flag.\n\nFrom-SVN: r150053", "tree": {"sha": "40e8e9f552d7ef293b2d19e281320018f0d15141", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/40e8e9f552d7ef293b2d19e281320018f0d15141"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5b9633c834593d626e85321b22bd5549f0df5bc9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b9633c834593d626e85321b22bd5549f0df5bc9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b9633c834593d626e85321b22bd5549f0df5bc9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b9633c834593d626e85321b22bd5549f0df5bc9/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ff5b964d6ecc372b272ed46ebaa9c11ca1f21a43", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff5b964d6ecc372b272ed46ebaa9c11ca1f21a43", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff5b964d6ecc372b272ed46ebaa9c11ca1f21a43"}], "stats": {"total": 77, "additions": 55, "deletions": 22}, "files": [{"sha": "fd752b62cef917bd46fa7d279a300c1fae8c45d3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b9633c834593d626e85321b22bd5549f0df5bc9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b9633c834593d626e85321b22bd5549f0df5bc9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5b9633c834593d626e85321b22bd5549f0df5bc9", "patch": "@@ -1,3 +1,14 @@\n+2009-07-24  Martin Jambor  <mjambor@suse.cz>\n+\n+\t* ipa-prop.h (struct ipa_node_params): New flag node_enqued.\n+\t(ipa_push_func_to_list_1): Declare.\n+\t(ipa_push_func_to_list): New function.\n+\n+\t* ipa-prop.c (ipa_push_func_to_list_1): New function.\n+\t(ipa_init_func_list): Call ipa_push_func_to_list_1.\n+\t(ipa_push_func_to_list): Removed.\n+\t(ipa_pop_func_from_list): Clear node_enqueued flag.\n+\n 2009-07-24  Andreas Krebbel  <krebbel1@de.ibm.com>\n \t\n \t* config/s390/s390.c (override_options): Default"}, {"sha": "1a7003295a2c7ddf46a0e6c9a316773a14d83415", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 29, "deletions": 21, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b9633c834593d626e85321b22bd5549f0df5bc9/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b9633c834593d626e85321b22bd5549f0df5bc9/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=5b9633c834593d626e85321b22bd5549f0df5bc9", "patch": "@@ -45,6 +45,24 @@ static struct cgraph_node_hook_list *node_removal_hook_holder;\n static struct cgraph_2edge_hook_list *edge_duplication_hook_holder;\n static struct cgraph_2node_hook_list *node_duplication_hook_holder;\n \n+/* Add cgraph NODE described by INFO to the worklist WL regardless of whether\n+   it is in one or not.  It should almost never be used directly, as opposed to\n+   ipa_push_func_to_list.  */\n+\n+void\n+ipa_push_func_to_list_1 (struct ipa_func_list **wl,\n+\t\t\t struct cgraph_node *node,\n+\t\t\t struct ipa_node_params *info)\n+{\n+  struct ipa_func_list *temp;\n+\n+  info->node_enqueued = 1;\n+  temp = XCNEW (struct ipa_func_list);\n+  temp->node = node;\n+  temp->next = *wl;\n+  *wl = temp;\n+}\n+\n /* Initialize worklist to contain all functions.  */\n \n struct ipa_func_list *\n@@ -57,43 +75,33 @@ ipa_init_func_list (void)\n   for (node = cgraph_nodes; node; node = node->next)\n     if (node->analyzed)\n       {\n+\tstruct ipa_node_params *info = IPA_NODE_REF (node);\n \t/* Unreachable nodes should have been eliminated before ipcp and\n \t   inlining.  */\n \tgcc_assert (node->needed || node->reachable);\n-\tipa_push_func_to_list (&wl, node);\n+\tipa_push_func_to_list_1 (&wl, node, info);\n       }\n \n   return wl;\n }\n \n-/* Add cgraph node MT to the worklist. Set worklist element WL\n-   to point to MT.  */\n-\n-void\n-ipa_push_func_to_list (struct ipa_func_list **wl, struct cgraph_node *mt)\n-{\n-  struct ipa_func_list *temp;\n-\n-  temp = XCNEW (struct ipa_func_list);\n-  temp->node = mt;\n-  temp->next = *wl;\n-  *wl = temp;\n-}\n-\n-/* Remove a function from the worklist. WL points to the first\n-   element in the list, which is removed.  */\n+/* Remove a function from the worklist WL and return it.  */\n \n struct cgraph_node *\n-ipa_pop_func_from_list (struct ipa_func_list ** wl)\n+ipa_pop_func_from_list (struct ipa_func_list **wl)\n {\n+  struct ipa_node_params *info;\n   struct ipa_func_list *first;\n-  struct cgraph_node *return_func;\n+  struct cgraph_node *node;\n \n   first = *wl;\n   *wl = (*wl)->next;\n-  return_func = first->node;\n+  node = first->node;\n   free (first);\n-  return return_func;\n+\n+  info = IPA_NODE_REF (node);\n+  info->node_enqueued = 0;\n+  return node;\n }\n \n /* Return index of the formal whose tree is PTREE in function which corresponds"}, {"sha": "fafadaca247dd77cf7b86d42fb67682cb5394fb7", "filename": "gcc/ipa-prop.h", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b9633c834593d626e85321b22bd5549f0df5bc9/gcc%2Fipa-prop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b9633c834593d626e85321b22bd5549f0df5bc9/gcc%2Fipa-prop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.h?ref=5b9633c834593d626e85321b22bd5549f0df5bc9", "patch": "@@ -167,6 +167,8 @@ struct ipa_node_params\n   unsigned modification_analysis_done : 1;\n   /* Whether the param uses analysis has already been performed.  */\n   unsigned uses_analysis_done : 1;\n+  /* Whether the function is enqueued in an ipa_func_list.  */\n+  unsigned node_enqueued : 1;\n };\n \n /* ipa_node_params access functions.  Please use these to access fields that\n@@ -369,9 +371,21 @@ struct ipa_func_list\n \n /* ipa_func_list interface.  */\n struct ipa_func_list *ipa_init_func_list (void);\n-void ipa_push_func_to_list (struct ipa_func_list **, struct cgraph_node *);\n+void ipa_push_func_to_list_1 (struct ipa_func_list **, struct cgraph_node *,\n+\t\t\t      struct ipa_node_params *);\n struct cgraph_node *ipa_pop_func_from_list (struct ipa_func_list **);\n \n+/* Add cgraph NODE to the worklist WL if it is not already in one.  */\n+\n+static inline void\n+ipa_push_func_to_list (struct ipa_func_list **wl, struct cgraph_node *node)\n+{\n+  struct ipa_node_params *info = IPA_NODE_REF (node);\n+\n+  if (!info->node_enqueued)\n+    ipa_push_func_to_list_1 (wl, node, info);\n+}\n+\n /* Callsite related calculations.  */\n void ipa_compute_jump_functions (struct cgraph_edge *);\n void ipa_count_arguments (struct cgraph_edge *);"}]}