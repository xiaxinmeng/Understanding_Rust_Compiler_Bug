{"sha": "36f6df662c5c857bf44d37bd609c8cb47e1d29c8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzZmNmRmNjYyYzVjODU3YmY0NGQzN2JkNjA5YzhjYjQ3ZTFkMjljOA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-07-16T14:39:51Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-07-16T14:39:51Z"}, "message": "[multiple changes]\n\n2014-07-16  Vincent Celier  <celier@adacore.com>\n\n\t* make.adb: Do not read gnat.adc when gnatmake is invoked\n\twith -gnatA.\n\n2014-07-16  Pascal Obry  <obry@adacore.com>\n\n\t* gnat_rm.texi, impunit.adb, g-rewdat.adb, g-rewdat.ads: Initial\n\timplementation of GNAT.Rewrite_Data.\n\nFrom-SVN: r212659", "tree": {"sha": "fcce786e4bd1507c3bd52d0be313638eedc625db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fcce786e4bd1507c3bd52d0be313638eedc625db"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/36f6df662c5c857bf44d37bd609c8cb47e1d29c8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36f6df662c5c857bf44d37bd609c8cb47e1d29c8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/36f6df662c5c857bf44d37bd609c8cb47e1d29c8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36f6df662c5c857bf44d37bd609c8cb47e1d29c8/comments", "author": null, "committer": null, "parents": [{"sha": "c624a26b6ab44115eb42c76d93eebffcaa1df15c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c624a26b6ab44115eb42c76d93eebffcaa1df15c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c624a26b6ab44115eb42c76d93eebffcaa1df15c"}], "stats": {"total": 448, "additions": 442, "deletions": 6}, "files": [{"sha": "b1be626e1a579f2fa09f60a18ccf602ea99addff", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36f6df662c5c857bf44d37bd609c8cb47e1d29c8/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36f6df662c5c857bf44d37bd609c8cb47e1d29c8/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=36f6df662c5c857bf44d37bd609c8cb47e1d29c8", "patch": "@@ -1,3 +1,13 @@\n+2014-07-16  Vincent Celier  <celier@adacore.com>\n+\n+\t* make.adb: Do not read gnat.adc when gnatmake is invoked\n+\twith -gnatA.\n+\n+2014-07-16  Pascal Obry  <obry@adacore.com>\n+\n+\t* gnat_rm.texi, impunit.adb, g-rewdat.adb, g-rewdat.ads: Initial\n+\timplementation of GNAT.Rewrite_Data.\n+\n 2014-07-16  Vincent Celier  <celier@adacore.com>\n \n \t* gnatls.adb (Normalize): New function."}, {"sha": "846ff9dcee8669729de3b772ece0941ba7cb3dd2", "filename": "gcc/ada/g-rewdat.adb", "status": "added", "additions": 253, "deletions": 0, "changes": 253, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36f6df662c5c857bf44d37bd609c8cb47e1d29c8/gcc%2Fada%2Fg-rewdat.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36f6df662c5c857bf44d37bd609c8cb47e1d29c8/gcc%2Fada%2Fg-rewdat.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-rewdat.adb?ref=36f6df662c5c857bf44d37bd609c8cb47e1d29c8", "patch": "@@ -0,0 +1,253 @@\n+-----------------------------------------------------------------------------\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                     G N A T . R E W R I T E _ D A T A                    --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--            Copyright (C) 2014, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Unchecked_Conversion;\n+\n+package body GNAT.Rewrite_Data is\n+\n+   use Ada;\n+\n+   subtype SEO is Stream_Element_Offset;\n+\n+   procedure Do_Output\n+     (B      : in out Buffer;\n+      Data   : Stream_Element_Array;\n+      Output : not null access procedure (Data : Stream_Element_Array));\n+   --  Do the actual output, this ensures that we properly send the data\n+   --  through linked rewrite buffers if any.\n+\n+   ------------\n+   -- Create --\n+   ------------\n+\n+   function Create\n+     (Pattern, Value : String;\n+      Size           : Stream_Element_Offset := 1_024) return Buffer\n+   is\n+\n+      subtype SP   is String (1 .. Pattern'Length);\n+      subtype SEAP is Stream_Element_Array (1 .. Pattern'Length);\n+\n+      subtype SV   is String (1 .. Value'Length);\n+      subtype SEAV is Stream_Element_Array (1 .. Value'Length);\n+\n+      function To_SEAP is new Unchecked_Conversion (SP, SEAP);\n+      function To_SEAV is new Unchecked_Conversion (SV, SEAV);\n+\n+   begin\n+      --  Return result (can't be smaller than pattern\n+\n+      return B : Buffer\n+                   (SEO'Max (Size, SEO (Pattern'Length)),\n+                    SEO (Pattern'Length),\n+                    SEO (Value'Length))\n+      do\n+         B.Pattern := To_SEAP (Pattern);\n+         B.Value   := To_SEAV (Value);\n+         B.Pos_C   := 0;\n+         B.Pos_B   := 0;\n+      end return;\n+   end Create;\n+\n+   ---------------\n+   -- Do_Output --\n+   ---------------\n+\n+   procedure Do_Output\n+     (B      : in out Buffer;\n+      Data   : Stream_Element_Array;\n+      Output : not null access procedure (Data : Stream_Element_Array))\n+   is\n+   begin\n+      if B.Next = null then\n+         Output (Data);\n+      else\n+         Write (B.Next.all, Data, Output);\n+      end if;\n+   end Do_Output;\n+\n+   -----------\n+   -- Flush --\n+   -----------\n+\n+   procedure Flush\n+     (B      : in out Buffer;\n+      Output : not null access procedure (Data : Stream_Element_Array))\n+   is\n+   begin\n+      --  Flush output buffer\n+\n+      if B.Pos_B > 0 then\n+         Do_Output (B, B.Buffer (1 .. B.Pos_B), Output);\n+      end if;\n+\n+      --  Flush current buffer\n+\n+      if B.Pos_C > 0 then\n+         Do_Output (B, B.Current (1 .. B.Pos_C), Output);\n+      end if;\n+\n+      --  Flush linked buffer if any\n+\n+      if B.Next /= null then\n+         Flush (B.Next.all, Output);\n+      end if;\n+\n+      Reset (B);\n+   end Flush;\n+\n+   ----------\n+   -- Link --\n+   ----------\n+\n+   procedure Link (From : in out Buffer; To : Buffer_Ref) is\n+   begin\n+      From.Next := To;\n+   end Link;\n+\n+   -----------\n+   -- Reset --\n+   -----------\n+\n+   procedure Reset (B : in out Buffer) is\n+   begin\n+      B.Pos_B := 0;\n+      B.Pos_C := 0;\n+\n+      if B.Next /= null then\n+         Reset (B.Next.all);\n+      end if;\n+   end Reset;\n+\n+   -------------\n+   -- Rewrite --\n+   -------------\n+\n+   procedure Rewrite\n+     (B      : in out Buffer;\n+      Input  : not null access procedure\n+                 (Buffer : out Stream_Element_Array;\n+                  Last   : out Stream_Element_Offset);\n+      Output : not null access procedure (Data : Stream_Element_Array))\n+   is\n+      Buffer : Stream_Element_Array (1 .. B.Size);\n+      Last   : Stream_Element_Offset;\n+\n+   begin\n+      Rewrite_All : loop\n+         Input (Buffer, Last);\n+         exit Rewrite_All when Last = 0;\n+         Write (B, Buffer (1 .. Last), Output);\n+      end loop Rewrite_All;\n+\n+      Flush (B, Output);\n+   end Rewrite;\n+\n+   ----------\n+   -- Size --\n+   ----------\n+\n+   function Size (B : Buffer) return Natural is\n+   begin\n+      return Natural (B.Pos_B + B.Pos_C);\n+   end Size;\n+\n+   -----------\n+   -- Write --\n+   -----------\n+\n+   procedure Write\n+     (B      : in out Buffer;\n+      Data   : Stream_Element_Array;\n+      Output : not null access procedure (Data : Stream_Element_Array))\n+   is\n+      procedure Need_Space (Size : Stream_Element_Offset);\n+      pragma Inline (Need_Space);\n+\n+      ----------------\n+      -- Need_Space --\n+      ----------------\n+\n+      procedure Need_Space (Size : Stream_Element_Offset) is\n+      begin\n+         if B.Pos_B + Size > B.Size then\n+            Do_Output (B, B.Buffer (1 .. B.Pos_B), Output);\n+            B.Pos_B := 0;\n+         end if;\n+      end Need_Space;\n+\n+   --  Start of processing for Write\n+\n+   begin\n+      if B.Size_Pattern = 0 then\n+         Do_Output (B, Data, Output);\n+\n+      else\n+         for K in Data'Range loop\n+            if Data (K) = B.Pattern (B.Pos_C + 1) then\n+\n+               --  Store possible start of a match\n+\n+               B.Pos_C := B.Pos_C + 1;\n+               B.Current (B.Pos_C) := Data (K);\n+\n+            else\n+               --  Not part of pattern, if a start of a match was found,\n+               --  remove it.\n+\n+               if B.Pos_C /= 0 then\n+                  Need_Space (B.Pos_C);\n+\n+                  B.Buffer (B.Pos_B + 1 .. B.Pos_B + B.Pos_C) :=\n+                    B.Current (1 .. B.Pos_C);\n+                  B.Pos_B := B.Pos_B + B.Pos_C;\n+                  B.Pos_C := 0;\n+               end if;\n+\n+               Need_Space (1);\n+               B.Pos_B := B.Pos_B + 1;\n+               B.Buffer (B.Pos_B) := Data (K);\n+            end if;\n+\n+            if B.Pos_C = B.Size_Pattern then\n+\n+               --  The pattern is found\n+\n+               Need_Space (B.Size_Value);\n+\n+               B.Buffer (B.Pos_B + 1 .. B.Pos_B + B.Size_Value) := B.Value;\n+               B.Pos_C := 0;\n+               B.Pos_B := B.Pos_B + B.Size_Value;\n+            end if;\n+         end loop;\n+      end if;\n+   end Write;\n+\n+end GNAT.Rewrite_Data;"}, {"sha": "4fc8afd6461c5ba3af10d9ed4e561e50fcd3299d", "filename": "gcc/ada/g-rewdat.ads", "status": "added", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36f6df662c5c857bf44d37bd609c8cb47e1d29c8/gcc%2Fada%2Fg-rewdat.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36f6df662c5c857bf44d37bd609c8cb47e1d29c8/gcc%2Fada%2Fg-rewdat.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-rewdat.ads?ref=36f6df662c5c857bf44d37bd609c8cb47e1d29c8", "patch": "@@ -0,0 +1,151 @@\n+------------------------------------------------------------------------------\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                     G N A T . R E W R I T E _ D A T A                    --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--            Copyright (C) 2014, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package can be used to rewrite data on the fly. All occurences of a\n+--  string (named pattern) will be replaced by another string.\n+\n+--  It is not necessary to load all data in memory and so this package can be\n+--  used for large data chunks like disk files for example. The pattern is\n+--  a standard string and not a regular expression.\n+\n+--  There is no dynamic allocation in the implementation.\n+\n+--  Example, to replace all occurences of \"Gnat\" with \"GNAT\":\n+\n+--    Rewriter : Buffer := Create (Pattern => \"Gnat\", Value => \"GNAT\");\n+\n+--  The output procedure that will receive the rewritten data:\n+\n+--    procedure Do (Data : Stream_Element_Array) is\n+--    begin\n+--       <implementation to handle Data>\n+--    end Do;\n+\n+--  Then:\n+\n+--    Write (Rewriter, \"Let's talk about Gnat compiler\", Do'Access);\n+--    Write (Rewriter, \"Gnat is an Ada compiler\", Do'Access);\n+--    Flush (Rewriter, Do'Access);\n+\n+--  Another possible usage is to specify a method to get the input data:\n+\n+--    procedure Get\n+--      (Buffer : out Stream_Element_Array;\n+--       Last   : out Stream_Element_Offset)\n+--    is\n+--    begin\n+--       <get some data from a file, a socket, etc...>\n+--       Last := ...\n+--       Buffer := ...\n+--    end Get;\n+\n+--  Then we can rewrite the whole file with:\n+\n+--    Rewrite (Rewriter, Input => Get'Access, Output => Do'Access);\n+\n+with Ada.Streams; use Ada.Streams;\n+\n+package GNAT.Rewrite_Data is\n+\n+   type Buffer (<>) is limited private;\n+   type Buffer_Ref is access all Buffer;\n+\n+   function Create\n+     (Pattern, Value : String;\n+      Size           : Stream_Element_Offset := 1_024) return Buffer;\n+   --  Create a rewriter buffer. Pattern is the string to be rewriten as Value.\n+   --  Size represent the size of the internal buffer used to store the data\n+   --  reeady to be output. A larger buffer may improve the performance as the\n+   --  Output routine (see Write, Rewrite below) will be called only when this\n+   --  buffer is full. Note that Size cannot be lower than Pattern'Length, if\n+   --  this is the case then Size value is set to Pattern'Length.\n+\n+   function Size (B : Buffer) return Natural;\n+   --  Returns the current size of the buffer (count of Stream_Array_Element)\n+\n+   procedure Flush\n+     (B      : in out Buffer;\n+      Output : not null access procedure (Data : Stream_Element_Array));\n+   --  Call Output for all remaining data in the buffer. The buffer is\n+   --  reset and ready for another use after this call.\n+\n+   procedure Reset (B : in out Buffer);\n+   pragma Inline (Reset);\n+   --  Clear all data in buffer, B is ready for another use. Note that this is\n+   --  not needed after a Flush. Note: all data remaining in Buffer is lost.\n+\n+   procedure Write\n+     (B      : in out Buffer;\n+      Data   : Stream_Element_Array;\n+      Output : not null access procedure (Data : Stream_Element_Array));\n+   --  Write Data into the buffer, call Output for any prepared data. Flush\n+   --  must be called when the last piece of Data as been sent in the Buffer.\n+\n+   procedure Rewrite\n+     (B      : in out Buffer;\n+      Input  : not null access procedure\n+                          (Buffer : out Stream_Element_Array;\n+                           Last   : out Stream_Element_Offset);\n+      Output : not null access procedure (Data : Stream_Element_Array));\n+   --  Read data from Input, rewrite it and then call Output. When there is\n+   --  no more data to be read from Input Last must be set to 0. Before leaving\n+   --  this routine call Flush above to send all remaining data to Output.\n+\n+   procedure Link (From : in out Buffer; To : Buffer_Ref);\n+   --  Link two rewrite buffers, that is all data sent to From buffer will be\n+   --  rewritten and then passed to the To rewrite buffer.\n+\n+private\n+\n+   type Buffer\n+     (Size, Size_Pattern, Size_Value : Stream_Element_Offset) is\n+   limited record\n+      Buffer : Stream_Element_Array (1 .. Size);\n+      --  Fully prepared/rewritten data waiting to be output\n+\n+      Current : Stream_Element_Array (1 .. Size_Pattern);\n+      --  Current data checked, this buffer contains every piece of data\n+      --  starting with the pattern. It means that at any point:\n+      --  Current (1 .. Pos_C) = Pattern (1 .. Pos_C).\n+\n+      Pattern : Stream_Element_Array (1 .. Size_Pattern);\n+      --  The pattern to look for\n+\n+      Value : Stream_Element_Array (1 .. Size_Value);\n+      --  The value the pattern is replaced by\n+\n+      Pos_C : Stream_Element_Offset; -- last valid element in Current\n+      Pos_B : Stream_Element_Offset; -- last valid element in Buffer\n+\n+      Next  : Buffer_Ref;\n+      --  A link to another rewriter if any\n+   end record;\n+\n+end GNAT.Rewrite_Data;"}, {"sha": "70b4c25c04ae63f98d81b0f8d5f1252d97886780", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36f6df662c5c857bf44d37bd609c8cb47e1d29c8/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36f6df662c5c857bf44d37bd609c8cb47e1d29c8/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=36f6df662c5c857bf44d37bd609c8cb47e1d29c8", "patch": "@@ -594,6 +594,7 @@ The GNAT Library\n * GNAT.Regexp (g-regexp.ads)::\n * GNAT.Registry (g-regist.ads)::\n * GNAT.Regpat (g-regpat.ads)::\n+* GNAT.Rewrite_Data (g-rewdat.ads)::\n * GNAT.Secondary_Stack_Info (g-sestin.ads)::\n * GNAT.Semaphores (g-semaph.ads)::\n * GNAT.Serial_Communications (g-sercom.ads)::\n@@ -18464,6 +18465,7 @@ of GNAT, and will generate a warning message.\n * GNAT.Regexp (g-regexp.ads)::\n * GNAT.Registry (g-regist.ads)::\n * GNAT.Regpat (g-regpat.ads)::\n+* GNAT.Rewrite_Data (g-rewdat.ads)::\n * GNAT.Secondary_Stack_Info (g-sestin.ads)::\n * GNAT.Semaphores (g-semaph.ads)::\n * GNAT.Serial_Communications (g-sercom.ads)::\n@@ -19563,6 +19565,17 @@ A complete implementation of Unix-style regular expression matching, copied\n from the original V7 style regular expression library written in C by\n Henry Spencer (and binary compatible with this C library).\n \n+@node GNAT.Rewrite_Data (g-rewdat.ads)\n+@section @code{GNAT.Rewrite_Data} (@file{g-rewdat.ads})\n+@cindex @code{GNAT.Rewrite_Data} (@file{g-rewdat.ads})\n+@cindex Rewrite data\n+\n+@noindent\n+A unit to rewrite on-the-fly string occurrences in a stream of\n+data. The implementation has a very minimum memory footprint as the\n+full content to be processed is not loaded into memory. This makes\n+this implementation usable for large files or socket streams.\n+\n @node GNAT.Secondary_Stack_Info (g-sestin.ads)\n @section @code{GNAT.Secondary_Stack_Info} (@file{g-sestin.ads})\n @cindex @code{GNAT.Secondary_Stack_Info} (@file{g-sestin.ads})"}, {"sha": "ae7a5e29d9769292e366cbdc47451280467ae137", "filename": "gcc/ada/impunit.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36f6df662c5c857bf44d37bd609c8cb47e1d29c8/gcc%2Fada%2Fimpunit.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36f6df662c5c857bf44d37bd609c8cb47e1d29c8/gcc%2Fada%2Fimpunit.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fimpunit.adb?ref=36f6df662c5c857bf44d37bd609c8cb47e1d29c8", "patch": "@@ -291,6 +291,7 @@ package body Impunit is\n     (\"g-regexp\", F),  -- GNAT.Regexp\n     (\"g-regist\", F),  -- GNAT.Registry\n     (\"g-regpat\", F),  -- GNAT.Regpat\n+    (\"g-rewdat\", F),  -- GNAT.Rewrite_Data\n     (\"g-semaph\", F),  -- GNAT.Semaphores\n     (\"g-sercom\", F),  -- GNAT.Serial_Communications\n     (\"g-sestin\", F),  -- GNAT.Secondary_Stack_Info"}, {"sha": "ebd2bfd9a522506e6b19d98cde1dca9c7b6afa52", "filename": "gcc/ada/make.adb", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36f6df662c5c857bf44d37bd609c8cb47e1d29c8/gcc%2Fada%2Fmake.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36f6df662c5c857bf44d37bd609c8cb47e1d29c8/gcc%2Fada%2Fmake.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmake.adb?ref=36f6df662c5c857bf44d37bd609c8cb47e1d29c8", "patch": "@@ -6671,13 +6671,15 @@ package body Make is\n \n          Fname.UF.Initialize;\n \n-         begin\n-            Fname.SF.Read_Source_File_Name_Pragmas;\n+         if Config_File then\n+            begin\n+               Fname.SF.Read_Source_File_Name_Pragmas;\n \n-         exception\n-            when Err : SFN_Scan.Syntax_Error_In_GNAT_ADC =>\n-               Make_Failed (Exception_Message (Err));\n-         end;\n+            exception\n+               when Err : SFN_Scan.Syntax_Error_In_GNAT_ADC =>\n+                  Make_Failed (Exception_Message (Err));\n+            end;\n+         end if;\n       end if;\n \n       --  Make sure no project object directory is recorded\n@@ -7907,6 +7909,12 @@ package body Make is\n                Do_Link_Step := False;\n             end if;\n \n+         --  If -gnatA is specified, make sure that gnat.adc is never read\n+\n+         elsif Argv'Length >= 6 and then Argv (2 .. 6) = \"gnatA\" then\n+            Add_Switch (Argv, Compiler, And_Save => And_Save);\n+            Opt.Config_File := False;\n+\n          elsif Argv (2 .. Argv'Last) = \"nostdlib\" then\n \n             --  Pass -nstdlib to gnatbind and gnatlink"}]}