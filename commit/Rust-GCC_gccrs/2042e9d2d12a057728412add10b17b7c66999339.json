{"sha": "2042e9d2d12a057728412add10b17b7c66999339", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjA0MmU5ZDJkMTJhMDU3NzI4NDEyYWRkMTBiMTdiN2M2Njk5OTMzOQ==", "commit": {"author": {"name": "Chris Smith", "email": "cks@gnu.org", "date": "1992-01-15T13:10:20Z"}, "committer": {"name": "Chris Smith", "email": "cks@gnu.org", "date": "1992-01-15T13:10:20Z"}, "message": "Initial revision\n\nFrom-SVN: r187", "tree": {"sha": "0a26420594ccb8fba37d99d9f58db2d497c6718e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0a26420594ccb8fba37d99d9f58db2d497c6718e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2042e9d2d12a057728412add10b17b7c66999339", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2042e9d2d12a057728412add10b17b7c66999339", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2042e9d2d12a057728412add10b17b7c66999339", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2042e9d2d12a057728412add10b17b7c66999339/comments", "author": null, "committer": null, "parents": [{"sha": "c2263e7936960d86af7b6deca36bb4354dcd7903", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2263e7936960d86af7b6deca36bb4354dcd7903", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c2263e7936960d86af7b6deca36bb4354dcd7903"}], "stats": {"total": 1182, "additions": 1182, "deletions": 0}, "files": [{"sha": "9c93bfea4d25442fd6a6e3cc2b1f2241e194888e", "filename": "gcc/config/convex/convex.h", "status": "added", "additions": 1182, "deletions": 0, "changes": 1182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2042e9d2d12a057728412add10b17b7c66999339/gcc%2Fconfig%2Fconvex%2Fconvex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2042e9d2d12a057728412add10b17b7c66999339/gcc%2Fconfig%2Fconvex%2Fconvex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fconvex%2Fconvex.h?ref=2042e9d2d12a057728412add10b17b7c66999339", "patch": "@@ -0,0 +1,1182 @@\n+/* Definitions of target machine for GNU compiler.  Convex version.\n+   Copyright (C) 1992 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+\n+/* Standard GCC variables that we reference. */\n+\n+extern int target_flags;\n+\n+/* Interface to convex.c. */\n+\n+extern int current_section_is_text;\n+extern int const_double_low_int ();\n+extern int const_double_high_int ();\n+extern char *set_cmp (), *gen_cmp ();\n+extern char *output_call ();\n+\n+/* Use the proper incantation to search Posix-compliant libraries. */\n+\n+#define LINK_SPEC \\\n+\"%{!traditional:-Eposix}%{traditional:-Enoposix}\\\n+ -A__iob=___ap$iob\\\n+ -A_use_libc_sema=___ap$use_libc_sema\\\n+ -L /usr/lib\"\n+\n+/* Use the matching startup files. */\n+\n+#define STARTFILE_SPEC \\\n+\"%{pg:/usr/lib/crt/gcrt0.o}\\\n+%{!pg:%{p:/usr/lib/crt/mcrt0.o}\\\n+%{!p:/usr/lib/crt/crt0.o}}\"\n+\n+/* Names to predefine in the preprocessor for this target machine.  */\n+\n+#define CPP_PREDEFINES \"-Dconvex -Dunix\"\n+\n+/* Print subsidiary information on the compiler version in use.  */\n+\n+#define TARGET_VERSION fprintf (stderr, \" (convex)\");\n+\n+/* Macros used in the machine description to test the flags.  */\n+\n+/* \n+   -mc1\t\tC1 target (avoid C2-only instructions)\n+   -mc2\t\tC2 target\n+   -mc32\tvitesse\n+   -mc34\tjavelin\n+   -mc38\tneptune\n+   -margcount\tuse standard calling sequence, with arg count word\n+   -mnoargcount don't push arg count, depend on symbol table\n+*/\n+\n+#define TARGET_C1 (target_flags & 1)\n+#define TARGET_C2 (target_flags & 2)\n+#define TARGET_C34 (target_flags & 4)\n+#define TARGET_C38 (target_flags & 010)\n+#define TARGET_INDIRECTS (target_flags & 020)\n+#define TARGET_ARGCOUNT (target_flags & 040)\n+\n+/* Macro to define tables used to set the flags.\n+   This is a list in braces of pairs in braces,\n+   each pair being { \"NAME\", VALUE }\n+   where VALUE is the bits to set or minus the bits to clear.\n+   An empty string NAME is used to identify the default VALUE.  */\n+\n+#define TARGET_SWITCHES \\\n+  { { \"c1\", 021 }, \t\\\n+    { \"c2\", 022 },\t\\\n+    { \"c32\", 022 },\t\\\n+    { \"c34\", 006 },\t\\\n+    { \"c38\", 012 },\t\\\n+    { \"noc1\", -001 }, \t\\\n+    { \"noc2\", -022 },\t\\\n+    { \"argcount\", 040 },  \\\n+    { \"noargcount\", -040 }, \\\n+    { \"\", TARGET_DEFAULT }}\n+\n+/* Default target_flags if no switches specified.  */\n+\n+#ifndef TARGET_DEFAULT\n+#define TARGET_DEFAULT 0\n+#endif\n+\n+/* Allow $ in identifiers. */\n+\n+#define DOLLARS_IN_IDENTIFIERS 2\n+\f\n+/* Target machine storage layout */\n+\n+/* Define this if most significant bit is lowest numbered\n+   in instructions that operate on numbered bit-fields. */\n+#define BITS_BIG_ENDIAN 1\n+\n+/* Define this if most significant byte of a word is the lowest numbered.  */\n+#define BYTES_BIG_ENDIAN 1\n+\n+/* Define this if most significant word of a multiword number is numbered.  */\n+#define WORDS_BIG_ENDIAN 1\n+\n+/* Number of bits in an addressible storage unit */\n+#define BITS_PER_UNIT 8\n+\n+/* Width in bits of a \"word\", which is the contents of a machine register.\n+   Note that this is not necessarily the width of data type `int';\n+   if using 16-bit ints on a 68000, this would still be 32.\n+   But on a machine with 16-bit registers, this would be 16.  */\n+#define BITS_PER_WORD 64\n+\n+/* Width of a word, in units (bytes).  */\n+#define UNITS_PER_WORD 8\n+\n+/* Width in bits of a pointer.\n+   See also the macro `Pmode' defined below.  */\n+#define POINTER_SIZE 32\n+\n+/* Allocation boundary (in *bits*) for storing arguments in argument list.  */\n+#define PARM_BOUNDARY 32\n+\n+/* Boundary (in *bits*) on which stack pointer should be aligned.  */\n+#define STACK_BOUNDARY 32\n+\n+/* Allocation boundary (in *bits*) for the code of a function.  */\n+#define FUNCTION_BOUNDARY 16\n+\n+/* Alignment of field after `int : 0' in a structure.  */\n+#define EMPTY_FIELD_BOUNDARY 32\n+\n+/* Every structure's size must be a multiple of this.  */\n+#define STRUCTURE_SIZE_BOUNDARY 8\n+\n+/* A bitfield declared as `int' forces `int' alignment for the struct.  */\n+#define PCC_BITFIELD_TYPE_MATTERS 1\n+\n+/* No data type wants to be aligned rounder than this.  */\n+/* beware of doubles in structs -- 64 is incompatible with pcc */\n+#define BIGGEST_ALIGNMENT 32\n+\n+/* Define this if move instructions will actually fail to work\n+   when given unaligned data.  */\n+/* #define STRICT_ALIGNMENT */\n+\n+/* Define sizes of basic C types to conform to ordinary usage -- these\n+   types depend on BITS_PER_WORD otherwise.  */\n+#define CHAR_TYPE_SIZE\t\t8\n+#define SHORT_TYPE_SIZE\t\t16\n+#define INT_TYPE_SIZE\t\t32\n+#define LONG_TYPE_SIZE\t\t32\n+#define LONG_LONG_TYPE_SIZE\t64\n+#define FLOAT_TYPE_SIZE\t\t32\n+#define DOUBLE_TYPE_SIZE\t64\n+#define LONG_DOUBLE_TYPE_SIZE\t64\n+\n+/* The real.h version of this macro inexplicably checks BITS_PER_WORD */\n+\n+#define REAL_VALUE_TRUNCATE(mode, x) ((mode) == SFmode ? (float) (x) : (x))\n+\n+/* Declare the standard types used by builtins to match convex stddef.h --\n+   with int rather than long.  */\n+\n+#define SIZE_TYPE \"unsigned int\"\n+#define PTRDIFF_TYPE \"int\"\n+\f\n+/* Standard register usage.  */\n+\n+/* Number of actual hardware registers.\n+   The hardware registers are assigned numbers for the compiler\n+   from 0 to just below FIRST_PSEUDO_REGISTER.\n+   All registers that the compiler knows about must be given numbers,\n+   even those that are not normally considered general registers.  */\n+#define FIRST_PSEUDO_REGISTER 16\n+\n+/* 1 for registers that have pervasive standard uses\n+   and are not available for the register allocator.\n+   For Convex, these are AP, FP, and SP.  */\n+#define FIXED_REGISTERS {0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1} \n+\n+/* 1 for registers not available across function calls.\n+   These must include the FIXED_REGISTERS and also any\n+   registers that can be used without being saved.\n+   The latter must include the registers where values are returned\n+   and the register where structure-value addresses are passed.\n+   Aside from that, you can include as many other registers as you like.  */\n+#define CALL_USED_REGISTERS {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}\n+\n+/* Return number of consecutive hard regs needed starting at reg REGNO\n+   to hold something of mode MODE.\n+   This is ordinarily the length in words of a value of mode MODE\n+   but can be less for certain modes in special long registers.\n+   On Convex, all values fit in one register.  */\n+#define HARD_REGNO_NREGS(REGNO, MODE)   1\n+\n+/* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.\n+   On Convex, S registers can hold any type, A registers any nonfloat. */\n+#define HARD_REGNO_MODE_OK(REGNO, MODE) \\\n+  ((REGNO) < 8 || (GET_MODE_CLASS (MODE) != MODE_FLOAT &&\t\t\\\n+\t\t   GET_MODE_CLASS (MODE) != MODE_COMPLEX_FLOAT &&\t\\\n+\t\t   (MODE) != DImode))\n+\n+/* Value is 1 if it is a good idea to tie two pseudo registers\n+   when one has mode MODE1 and one has mode MODE2.\n+   If HARD_REGNO_MODE_OK could produce different values for MODE1 and MODE2,\n+   for any hard reg, then this must be 0 for correct output.  */\n+#define MODES_TIEABLE_P(MODE1, MODE2)  \\\n+    ((GET_MODE_CLASS (MODE1) == MODE_FLOAT \\\n+      || GET_MODE_CLASS (MODE1) == MODE_COMPLEX_FLOAT \\\n+      || (MODE1) == DImode) \\\n+     == (GET_MODE_CLASS (MODE2) == MODE_FLOAT \\\n+\t || GET_MODE_CLASS (MODE2) == MODE_COMPLEX_FLOAT \\\n+\t || (MODE2) == DImode))\n+\n+/* Specify the registers used for certain standard purposes.\n+   The values of these macros are register numbers.  */\n+\n+/* Register to use for pushing function arguments.  */\n+#define STACK_POINTER_REGNUM 8\n+\n+/* Base register for access to local variables of the function.  */\n+#define FRAME_POINTER_REGNUM 15\n+\n+/* Value should be nonzero if functions must have frame pointers.\n+   Zero means the frame pointer need not be set up (and parms\n+   may be accessed via the stack pointer) in functions that seem suitable.\n+   This is computed in `reload', in reload1.c.  */\n+#define FRAME_POINTER_REQUIRED 1\n+\n+/* Base register for access to arguments of the function.  */\n+#define ARG_POINTER_REGNUM 14\n+\n+/* Register in which static-chain is passed to a function.\n+   Use S0, not an A reg, because this rare use would otherwise prevent\n+   an A reg from being available to global-alloc across calls.  */\n+#define STATIC_CHAIN_REGNUM 0\n+\n+/* Register in which address to store a structure value\n+   is passed to a function.  */\n+#define STRUCT_VALUE_REGNUM 9\n+\f\n+/* Define the classes of registers for register constraints in the\n+   machine description.  Also define ranges of constants.\n+\n+   One of the classes must always be named ALL_REGS and include all hard regs.\n+   If there is more than one class, another class must be named NO_REGS\n+   and contain no registers.\n+\n+   The name GENERAL_REGS must be the name of a class (or an alias for\n+   another name such as ALL_REGS).  This is the class of registers\n+   that is allowed by \"g\" or \"r\" in a register constraint.\n+   Also, registers outside this class are allocated only when\n+   instructions express preferences for them.\n+\n+   The classes must be numbered in nondecreasing order; that is,\n+   a larger-numbered class must never be contained completely\n+   in a smaller-numbered class.\n+\n+   For any two classes, it is very desirable that there be another\n+   class that represents their union.  */\n+   \n+/* Convex has classes A (address) and S (scalar).\n+   A is further divided into SP_REGS (stack pointer) and INDEX_REGS.\n+   Seems to work better to put S first, here and in the md. */\n+\n+enum reg_class {\n+  NO_REGS, S_REGS, INDEX_REGS, SP_REGS, A_REGS, ALL_REGS, LIM_REG_CLASSES \n+};\n+\n+#define N_REG_CLASSES (int) LIM_REG_CLASSES\n+\n+/* Since GENERAL_REGS is the same class as ALL_REGS,\n+   don't give it a different class number; just make it an alias.  */\n+\n+#define GENERAL_REGS ALL_REGS\n+\n+/* Give names of register classes as strings for dump file.   */\n+\n+#define REG_CLASS_NAMES \\\n+ {\"NO_REGS\", \"S_REGS\", \"INDEX_REGS\", \"SP_REGS\", \"A_REGS\", \"ALL_REGS\" }\n+\n+/* Define which registers fit in which classes.\n+   This is an initializer for a vector of HARD_REG_SET\n+   of length N_REG_CLASSES.  */\n+\n+#define REG_CLASS_CONTENTS {0, 0x00ff, 0xfe00, 0x0100, 0xff00, 0xffff}\n+\n+/* The same information, inverted:\n+   Return the class number of the smallest class containing\n+   reg number REGNO.  This could be a conditional expression\n+   or could index an array.  */\n+\n+#define REGNO_REG_CLASS(REGNO) \\\n+  (S_REGNO_P (REGNO) ? S_REGS : REGNO == 8 ? SP_REGS : INDEX_REGS)\n+\n+#define S_REGNO_P(REGNO) ((REGNO) < 8)\n+#define A_REGNO_P(REGNO) ((REGNO) >= 8)\n+\n+#define S_REG_P(X) (REG_P (X) && S_REGNO_P (REGNO (X)))\n+#define A_REG_P(X) (REG_P (X) && A_REGNO_P (REGNO (X)))\n+\n+/* The class value for index registers, and the one for base regs.  */\n+\n+#define INDEX_REG_CLASS INDEX_REGS\n+#define BASE_REG_CLASS INDEX_REGS\n+\n+/* Get reg_class from a letter such as appears in the machine description.  */\n+/* S regs use the letter 'd' because 's' is taken. */\n+\n+#define REG_CLASS_FROM_LETTER(C) \\\n+  ((C) == 'a' ? A_REGS : (C) == 'd' ? S_REGS : NO_REGS)\n+\n+/* The letters I, J, K, L and M in a register constraint string\n+   can be used to stand for particular ranges of immediate operands.\n+   This macro defines what the ranges are.\n+   C is the letter, and VALUE is a constant value.\n+   Return 1 if VALUE is in the range specified by C.  */\n+\n+/* Convex uses only I:\n+   32-bit value with sign bit off, usable as immediate in DImode logical \n+     instructions and, or, xor */ \n+\n+#define CONST_OK_FOR_LETTER_P(VALUE, C)  ((VALUE) >= 0)\n+\n+/* Similar, but for floating constants, and defining letters G and H.\n+   Here VALUE is the CONST_DOUBLE rtx itself.  */\n+/* Convex uses only G:\n+   value usable in ld.d (low word 0) or ld.l (high word all sign) */\n+\n+#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C) \\\n+  (LD_D_P (VALUE) || LD_L_P (VALUE))\n+\n+#define LD_D_P(X) (const_double_low_int (X) == 0)\n+\n+#define LD_L_P(X) (const_double_low_int (X) >= 0 \\\n+\t\t   ? const_double_high_int (X) == 0 \\\n+\t\t   : const_double_high_int (X) == -1)\n+\n+/* Given an rtx X being reloaded into a reg required to be\n+   in class CLASS, return the class of reg to actually use.\n+   In general this is just CLASS; but on some machines\n+   in some cases it is preferable to use a more restrictive class.  */\n+\n+/* CONST_DOUBLEs (constraint 'F') are passed by LEGITIMATE_CONSTANT_P\n+   without regard to their value.  Constraint 'G' is used by instructions\n+   that need to reject non-immediate values.  The rejected values are\n+   dealt with by reload -- PREFERRED_RELOAD_CLASS returns NO_REGS for\n+   nonimmediate values, causing reload to put them in memory.  Every insn\n+   that uses 'G' must have an alternative that accepts memory.  */\n+\n+#define PREFERRED_RELOAD_CLASS(X,CLASS)\t\\\n+  (GET_CODE (X) != CONST_DOUBLE ? (CLASS) : \\\n+   (GET_MODE (X) != TFmode && (LD_L_P (X) || LD_D_P (X))) ? (CLASS) : NO_REGS)\n+   \n+/* Return the maximum number of consecutive registers\n+   needed to represent mode MODE in a register of class CLASS.  */\n+#define CLASS_MAX_NREGS(CLASS, MODE)  ((GET_MODE_SIZE (MODE) + 7) / 8)\n+\f\n+/* Stack layout; function entry, exit and calling.  */\n+\n+/* Define this if pushing a word on the stack\n+   makes the stack pointer a smaller address.  */\n+#define STACK_GROWS_DOWNWARD\n+\n+/* Define this if the nominal address of the stack frame\n+   is at the high-address end of the local variables;\n+   that is, each additional local variable allocated\n+   goes at a more negative offset in the frame.  */\n+#define FRAME_GROWS_DOWNWARD\n+\n+/* Define this if should default to -fcaller-saves.  */\n+#define DEFAULT_CALLER_SAVES\n+\n+/* Offset within stack frame to start allocating local variables at.\n+   If FRAME_GROWS_DOWNWARD, this is the offset to the END of the\n+   first local allocated.  Otherwise, it is the offset to the BEGINNING\n+   of the first local allocated.  */\n+#define STARTING_FRAME_OFFSET 0\n+\n+/* If we generate an insn to push BYTES bytes,\n+   this says how many the stack pointer really advances by. */\n+#define PUSH_ROUNDING(BYTES) (((BYTES) + 3) & ~3)\n+\n+/* Offset of first parameter from the argument pointer register value.  */\n+#define FIRST_PARM_OFFSET(FNDECL) 0\n+\n+/* Value is the number of bytes of arguments automatically\n+   popped when returning from a subroutine call.\n+   FUNTYPE is the data type of the function (as a tree),\n+   or for a library call it is an identifier node for the subroutine name.\n+   SIZE is the number of bytes of arguments passed on the stack.  */\n+/* The standard Convex call, with arg count word, includes popping the\n+   args as part of the call template.  We optionally omit the arg count\n+   word and let gcc combine the arg pops. */\n+#define RETURN_POPS_ARGS(FUNTYPE,SIZE) (TARGET_ARGCOUNT)\n+\n+/* Define how to find the value returned by a function.\n+   VALTYPE is the data type of the value (as a tree).\n+   If the precise function being called is known, FUNC is its FUNCTION_DECL;\n+   otherwise, FUNC is 0.  */\n+\n+/* On Convex the return value is in S0 regardless.  */   \n+\n+#define FUNCTION_VALUE(VALTYPE, FUNC)  \\\n+  gen_rtx (REG, TYPE_MODE (VALTYPE), 0)\n+\n+/* Define how to find the value returned by a library function\n+   assuming the value has mode MODE.  */\n+\n+/* On Convex the return value is in S0 regardless.  */   \n+\n+#define LIBCALL_VALUE(MODE)  gen_rtx (REG, MODE, 0)\n+\n+/* Define this if PCC uses the nonreentrant convention for returning\n+   structure and union values.  */\n+\n+#define PCC_STATIC_STRUCT_RETURN\n+\n+/* 1 if N is a possible register number for a function value.\n+   On the Convex, S0 is the only register thus used.  */\n+\n+#define FUNCTION_VALUE_REGNO_P(N) ((N) == 0)\n+\n+/* 1 if N is a possible register number for function argument passing. */\n+\n+#define FUNCTION_ARG_REGNO_P(N) 0\n+\f\n+/* Define a data type for recording info about an argument list\n+   during the scan of that argument list.  This data type should\n+   hold all necessary information about the function itself\n+   and about the args processed so far, enough to enable macros\n+   such as FUNCTION_ARG to determine where the next arg should go.\n+\n+   On convex, this is a single integer, which is a number of bytes\n+   of arguments scanned so far.  */\n+\n+#define CUMULATIVE_ARGS int\n+\n+/* Initialize a variable CUM of type CUMULATIVE_ARGS\n+   for a call to a function whose data type is FNTYPE.\n+   For a library call, FNTYPE is 0.\n+\n+   On Convex, the offset starts at 0.  */\n+\n+#define INIT_CUMULATIVE_ARGS(CUM,FNTYPE,LIBNAME)\t\\\n+ ((CUM) = 0)\n+\n+/* Update the data in CUM to advance over an argument\n+   of mode MODE and data type TYPE.\n+   (TYPE is null for libcalls where that information may not be available.)  */\n+\n+#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\\\n+ ((CUM) += ((MODE) != BLKmode\t\t\t\\\n+\t    ? (GET_MODE_SIZE (MODE) + 3) & ~3\t\\\n+\t    : (int_size_in_bytes (TYPE) + 3) & ~3))\n+\n+/* Define where to put the arguments to a function.\n+   Value is zero to push the argument on the stack,\n+   or a hard register in which to store the argument.\n+\n+   MODE is the argument's machine mode.\n+   TYPE is the data type of the argument (as a tree).\n+    This is null for libcalls where that information may\n+    not be available.\n+   CUM is a variable of type CUMULATIVE_ARGS which gives info about\n+    the preceding args and about the function being called.\n+   NAMED is nonzero if this argument is a named parameter\n+    (otherwise it is an extra parameter matching an ellipsis).  */\n+\n+/* On Convex, all args are pushed.  */   \n+\n+#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) 0\n+\n+/* This macro generates the assembly code for function entry.\n+   FILE is a stdio stream to output the code to.\n+   SIZE is an int: how many units of temporary storage to allocate.\n+   Refer to the array `regs_ever_live' to determine which registers\n+   to save; `regs_ever_live[I]' is nonzero if register number I\n+   is ever used in the function.  This macro is responsible for\n+   knowing which registers should not be saved even if used.  */\n+\n+#define FUNCTION_PROLOGUE(FILE, SIZE)     \\\n+{  if ((SIZE) != 0) fprintf (FILE, \"\\tsub.w #%d,sp\\n\", ((SIZE) + 3) & -4);}\n+\n+/* Output assembler code for a block containing the constant parts\n+   of a trampoline, leaving space for the variable parts.  */\n+\n+/* On convex, the code for a trampoline is\n+       ld.w #<link>,s0\n+       jmp <func>  */\n+\n+#define TRAMPOLINE_TEMPLATE(FILE) \\\n+{\t\t\t\t\t\t\t\t\t\\\n+  ASM_OUTPUT_SHORT (FILE, gen_rtx (CONST_INT, VOIDmode, 0x11c8));\t\\\n+  ASM_OUTPUT_SHORT (FILE, const0_rtx);\t\t\t\t\t\\\n+  ASM_OUTPUT_SHORT (FILE, const0_rtx);\t\t\t\t\t\\\n+  ASM_OUTPUT_SHORT (FILE, gen_rtx (CONST_INT, VOIDmode, 0x0140));\t\\\n+  ASM_OUTPUT_SHORT (FILE, const0_rtx);\t\t\t\t\t\\\n+  ASM_OUTPUT_SHORT (FILE, const0_rtx);\t\t\t\t\t\\\n+}\n+\n+/* Length in units of the trampoline for entering a nested function.  */\n+\n+#define TRAMPOLINE_SIZE 12\n+\n+/* Emit RTL insns to initialize the variable parts of a trampoline.\n+   FNADDR is an RTX for the address of the function's pure code.\n+   CXT is an RTX for the static chain value for the function.  */\n+\n+#define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT) \\\n+{\t\t\t\t\t\t\t\t\t\\\n+  emit_move_insn (gen_rtx (MEM, Pmode, plus_constant (TRAMP, 2)), CXT);\t\\\n+  emit_move_insn (gen_rtx (MEM, Pmode, plus_constant (TRAMP, 8)), FNADDR); \\\n+  emit_call_insn (gen_call (gen_rtx (MEM, QImode,\t\t\t\\\n+\t\t\t\t     gen_rtx (SYMBOL_REF, Pmode,\t\\\n+\t\t\t\t\t      \"__enable_execute_stack\")), \\\n+\t\t\t    const0_rtx));\t\t\t\t\\\n+}\n+\n+/* Output assembler code to FILE to increment profiler label # LABELNO\n+   for profiling a function entry.  */\n+\n+#define FUNCTION_PROFILER(FILE, LABELNO)  \\\n+   fprintf (FILE, \"\\tldea LP%d,a1\\n\\tcallq mcount\\n\", (LABELNO));\n+\n+/* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,\n+   the stack pointer does not matter.  The value is tested only in\n+   functions that have frame pointers.\n+   No definition is equivalent to always zero.  */\n+\n+#define EXIT_IGNORE_STACK 1\n+\n+/* This macro generates the assembly code for function exit,\n+   on machines that need it.  If FUNCTION_EPILOGUE is not defined\n+   then individual return instructions are generated for each\n+   return statement.  Args are same as for FUNCTION_PROLOGUE.  */\n+\n+/* #define FUNCTION_EPILOGUE(FILE, SIZE)  */\n+\n+/* Store in the variable DEPTH the initial difference between the\n+   frame pointer reg contents and the stack pointer reg contents,\n+   as of the start of the function body.  This depends on the layout\n+   of the fixed parts of the stack frame and on how registers are saved.  */\n+#define INITIAL_FRAME_POINTER_OFFSET(DEPTH)\t\t\t\\\n+{ (DEPTH) = get_frame_size (); }\n+\f\n+/* Addressing modes, and classification of registers for them.  */\n+\n+/* #define HAVE_POST_INCREMENT */\n+/* #define HAVE_POST_DECREMENT */\n+\n+/* #define HAVE_PRE_DECREMENT */\n+/* #define HAVE_PRE_INCREMENT */\n+\n+/* Macros to check register numbers against specific register classes.  */\n+\n+/* These assume that REGNO is a hard or pseudo reg number.\n+   They give nonzero only if REGNO is a hard reg of the suitable class\n+   or a pseudo reg currently allocated to a suitable hard reg.\n+   Since they use reg_renumber, they are safe only once reg_renumber\n+   has been allocated, which happens in local-alloc.c.  */\n+\n+#define REGNO_OK_FOR_INDEX_P(regno)  \\\n+  ((((regno) ^ 010) < 8 || ((reg_renumber[regno] ^ 010) & -8) == 0) \\\n+   && regno != 8)\n+\n+#define REGNO_OK_FOR_BASE_P(regno)  REGNO_OK_FOR_INDEX_P (regno)\n+\f\n+/* Maximum number of registers that can appear in a valid memory address.  */\n+\n+#define MAX_REGS_PER_ADDRESS 1\n+\n+/* 1 if X is an rtx for a constant that is a valid address.  */\n+\n+#define CONSTANT_ADDRESS_P(X) CONSTANT_P (X)\n+\n+/* Nonzero if the constant value X is a legitimate general operand.\n+   It is given that X satisfies CONSTANT_P or is a CONST_DOUBLE.  */\n+\n+/* For convex, any single-word constant is ok; the only contexts\n+   allowing general_operand of mode DI or DF are movdi and movdf. */\n+\n+#define LEGITIMATE_CONSTANT_P(X) \\\n+  (GET_CODE (X) != CONST_DOUBLE ? 1 : (LD_D_P (X) || LD_L_P (X)))\n+\n+/* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n+   and check its validity for a certain class.\n+   We have two alternate definitions for each of them.\n+   The usual definition accepts all pseudo regs; the other rejects\n+   them unless they have been allocated suitable hard regs.\n+   The symbol REG_OK_STRICT causes the latter definition to be used.\n+\n+   Most source files want to accept pseudo regs in the hope that\n+   they will get allocated to the class that the insn wants them to be in.\n+   Source files for reload pass need to be strict.\n+   After reload, it makes no difference, since pseudo regs have\n+   been eliminated by then.  */\n+\n+#ifndef REG_OK_STRICT\n+\n+/* Nonzero if X is a hard reg that can be used as an index\n+   or if it is a pseudo reg.  */\n+#define REG_OK_FOR_INDEX_P(X) (REGNO (X) > 8)\n+/* Nonzero if X is a hard reg that can be used as a base reg\n+   or if it is a pseudo reg.  */\n+#define REG_OK_FOR_BASE_P(X) (REGNO (X) > 8)\n+\n+#else\n+\n+/* Nonzero if X is a hard reg that can be used as an index.  */\n+#define REG_OK_FOR_INDEX_P(X) REGNO_OK_FOR_INDEX_P (REGNO (X))\n+/* Nonzero if X is a hard reg that can be used as a base reg.  */\n+#define REG_OK_FOR_BASE_P(X) REGNO_OK_FOR_BASE_P (REGNO (X))\n+\n+#endif\n+\f\n+/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n+   that is a valid memory address for an instruction.\n+   The MODE argument is the machine mode for the MEM expression\n+   that wants to use this address.\n+\n+   For Convex, valid addresses are\n+       indirectable or (MEM indirectable)\n+   where indirectable is \n+       const, reg, (PLUS reg const)\n+\n+   On C3-series processors, we avoid indirection since it's substantially\n+   slower.  */\n+\n+/* 1 if X is an address that we could indirect through.  */\n+#define INDIRECTABLE_ADDRESS_P(X)  \\\n+  (CONSTANT_ADDRESS_P (X)\t\t\t\t\t\t\\\n+   || (GET_CODE (X) == REG && REG_OK_FOR_BASE_P (X))\t\t\t\\\n+   || (GET_CODE (X) == PLUS\t\t\t\t\t\t\\\n+       && GET_CODE (XEXP (X, 0)) == REG\t\t\t\t\t\\\n+       && REG_OK_FOR_BASE_P (XEXP (X, 0))\t\t\t\t\\\n+       && CONSTANT_ADDRESS_P (XEXP (X, 1)))\t\t\t\t\\\n+   || (GET_CODE (X) == PLUS\t\t\t\t\t\t\\\n+       && GET_CODE (XEXP (X, 1)) == REG\t\t\t\t\t\\\n+       && REG_OK_FOR_BASE_P (XEXP (X, 1))\t\t\t\t\\\n+       && CONSTANT_ADDRESS_P (XEXP (X, 0))))\n+\n+/* Go to ADDR if X is a valid address. */\n+#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)  \\\n+{ register rtx xfoob = (X);\t\t\t\t\t\t\\\n+  if (INDIRECTABLE_ADDRESS_P (xfoob))\t\t\t\t\t\\\n+    goto ADDR;\t\t\t\t\t\t\t\t\\\n+  xfoob = XEXP (X, 0);\t\t\t\t\t\t\t\\\n+  if (GET_CODE (X) == MEM\t\t\t\t\t\t\\\n+      && TARGET_INDIRECTS\t\t\t\t\t\t\\\n+      && INDIRECTABLE_ADDRESS_P (xfoob))\t\t\t\t\\\n+    goto ADDR;\t\t\t\t\t\t\t\t\\\n+  if (GET_CODE (X) == PRE_DEC && REG_P (xfoob)\t\t\t\t\\\n+      && REGNO (xfoob) == STACK_POINTER_REGNUM)\t\t\t\t\\\n+    goto ADDR; }\n+\f\n+/* Try machine-dependent ways of modifying an illegitimate address\n+   to be legitimate.  If we find one, return the new, valid address.\n+   This macro is used in only one place: `memory_address' in explow.c.\n+\n+   OLDX is the address as it was before break_out_memory_refs was called.\n+   In some cases it is useful to look at this to decide what needs to be done.\n+\n+   MODE and WIN are passed so that this macro can use\n+   GO_IF_LEGITIMATE_ADDRESS.\n+\n+   It is always safe for this macro to do nothing.  It exists to recognize\n+   opportunities to optimize the output.\n+\n+   For Convex, nothing needs to be done.  */\n+\n+#define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN)  {}\n+\n+/* Go to LABEL if ADDR (a legitimate address expression)\n+   has an effect that depends on the machine mode it is used for. */\n+\n+#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR,LABEL)  {}\n+\f\n+/* Specify the machine mode that this machine uses\n+   for the index in the tablejump instruction.  */\n+#define CASE_VECTOR_MODE SImode\n+\n+/* Define this if the case instruction expects the table\n+   to contain offsets from the address of the table.\n+   Do not define this if the table should contain absolute addresses.  */\n+/* #define CASE_VECTOR_PC_RELATIVE */\n+\n+/* Define this if the case instruction drops through after the table\n+   when the index is out of range.  Don't define it if the case insn\n+   jumps to the default label instead.  */\n+/* #define CASE_DROPS_THROUGH */\n+\n+/* Specify the tree operation to be used to convert reals to integers.  */\n+#define IMPLICIT_FIX_EXPR FIX_ROUND_EXPR\n+\n+/* This is the kind of divide that is easiest to do in the general case.  */\n+#define EASY_DIV_EXPR TRUNC_DIV_EXPR\n+\n+/* Define this as 1 if `char' should by default be signed; else as 0.  */\n+#define DEFAULT_SIGNED_CHAR 1\n+\n+/* This flag, if defined, says the same insns that convert to a signed fixnum\n+   also convert validly to an unsigned one.  */\n+#define FIXUNS_TRUNC_LIKE_FIX_TRUNC\n+\n+/* Max number of bytes we can move from memory to memory\n+   in one reasonably fast instruction.  */\n+#define MOVE_MAX 8\n+\n+/* Define this if zero-extension is slow (more than one real instruction).  */\n+/* #define SLOW_ZERO_EXTEND */\n+\n+/* Nonzero if access to memory by bytes is slow and undesirable.  */\n+#define SLOW_BYTE_ACCESS 0\n+\n+/* Define if shifts truncate the shift count\n+   which implies one can omit a sign-extension or zero-extension\n+   of a shift count.  */\n+#define SHIFT_COUNT_TRUNCATED\n+\n+/* Value is 1 if truncating an integer of INPREC bits to OUTPREC bits\n+   is done just by pretending it is already truncated.  */\n+#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC) 1\n+\n+/* On Convex, it is as good to call a constant function address as to\n+   call an address kept in a register. */\n+#define NO_FUNCTION_CSE\n+\n+/* When a prototype says `char' or `short', really pass an `int'.  */\n+#define PROMOTE_PROTOTYPES\n+\n+/* Specify the machine mode that pointers have.\n+   After generation of rtl, the compiler makes no further distinction\n+   between pointers and any other objects of this machine mode.  */\n+#define Pmode SImode\n+\n+/* A function address in a call instruction\n+   is a byte address (for indexing purposes)\n+   so give the MEM rtx a byte's mode.  */\n+#define FUNCTION_MODE QImode\n+\n+/* Compute the cost of computing a constant rtl expression RTX\n+   whose rtx-code is CODE.  The body of this macro is a portion\n+   of a switch statement.  If the code is computed here,\n+   return it with a return statement.  Otherwise, break from the switch.  */\n+\n+#define CONST_COSTS(RTX,CODE) \\\n+  case CONST: \\\n+  case LABEL_REF: \\\n+  case SYMBOL_REF: \\\n+  case CONST_INT: \\\n+    return 0; \\\n+  case CONST_DOUBLE: \\\n+    return 2;\n+\n+/* Provide the costs of a rtl expression.  This is in the body of a\n+   switch on CODE. \n+   On C1 and C2, multiply is faster than shift. */\n+\n+#define RTX_COSTS(RTX,CODE) \\\n+  case MULT:\t\t\t\t\t\t\t\t\\\n+    total = COSTS_N_INSNS (4);\t\t\t\t\t\t\\\n+    break;\t\t\t\t\t\t\t\t\\\n+  case LSHIFT:\t\t\t\t\t\t\t\t\\\n+  case ASHIFT:\t\t\t\t\t\t\t\t\\\n+  case LSHIFTRT:\t\t\t\t\t\t\t\\\n+  case ASHIFTRT:\t\t\t\t\t\t\t\\\n+    total = COSTS_N_INSNS (3);\t\t\t\t\t\t\\\n+    break;\n+\n+/* Compute the cost of an address.  This is meant to approximate the size\n+   and/or execution delay of an insn using that address.  If the cost is\n+   approximated by the RTL complexity, including CONST_COSTS above, as\n+   is usually the case for CISC machines, this macro should not be defined.\n+   For aggressively RISCy machines, only one insn format is allowed, so\n+   this macro should be a constant.  The value of this macro only matters\n+   for valid addresses.  */\n+\n+#define ADDRESS_COST(RTX) (GET_CODE (RTX) == MEM ? 3 : 1)\n+\n+/* Check a `double' value for validity for a particular machine mode.  */\n+\n+#define CHECK_FLOAT_VALUE(mode, d) \\\n+  if ((mode) == SFmode) \\\n+    { \\\n+      if ((d) > 1.7014117331926443e+38) \\\n+\t{ error (\"magnitude of constant too large for `float'\"); \\\n+\t  (d) = 1.7014117331926443e+38; } \\\n+      else if ((d) < -1.7014117331926443e+38) \\\n+\t{ error (\"magnitude of constant too large for `float'\"); \\\n+\t  (d) = -1.7014117331926443e+38; } \\\n+      else if (((d) > 0) && ((d) < 2.9387358770557188e-39)) \\\n+\t{ warning (\"`float' constant truncated to zero\"); \\\n+\t  (d) = 0.0; } \\\n+      else if (((d) < 0) && ((d) > -2.9387358770557188e-39)) \\\n+\t{ warning (\"`float' constant truncated to zero\"); \\\n+\t  (d) = 0.0; } \\\n+    }\n+\f\n+/* Tell final.c how to eliminate redundant test instructions.  */\n+\n+/* Here we define machine-dependent flags and fields in cc_status\n+   (see `conditions.h').  No extra ones are needed for convex.  */\n+\n+/* Store in cc_status the expressions\n+   that the condition codes will describe\n+   after execution of an instruction whose pattern is EXP.\n+   Do not alter them if the instruction would not alter the cc's.  */\n+\n+#define NOTICE_UPDATE_CC(EXP,INSN)  {}\n+\f\n+/* Control the assembler format that we output.  */\n+\n+/* Output at beginning of assembler file.  */\n+\n+#define ASM_FILE_START(FILE) fprintf (FILE, \";NO_APP\\n\")\n+\n+/* Output to assembler file text saying following lines\n+   may contain character constants, extra white space, comments, etc.  */\n+\n+#define ASM_APP_ON \";APP\\n\"\n+\n+/* Output to assembler file text saying following lines\n+   no longer contain unusual constructs.  */\n+\n+#define ASM_APP_OFF \";NO_APP\\n\"\n+\n+/* Alignment with Convex's assembler goes like this:\n+   .text can be .aligned up to a halfword.\n+   .data and .bss can be .aligned up to a longword.\n+   .lcomm is not supported, explicit declarations in .bss must be used instead.\n+   We get alignment for word and longword .text data by conventionally\n+   using .text 2 for word-aligned data and .text 3 for longword-aligned\n+   data.  This requires that the data's size be a multiple of its alignment,\n+   which seems to be always true.  */\n+\n+/* Output before read-only data.  */\n+\n+#define TEXT_SECTION_ASM_OP (current_section_is_text = 1, \".text\")\n+\n+/* Output before writable data.  */\n+\n+#define DATA_SECTION_ASM_OP (current_section_is_text = 0, \".data\") \n+\n+/* Output before uninitialized data.  */\n+\n+#define BSS_SECTION_ASM_OP (current_section_is_text = 0, \".bss\") \n+\n+/* Define the .bss section for ASM_OUTPUT_LOCAL to use. */\n+\n+#define EXTRA_SECTIONS in_bss\n+\n+#define EXTRA_SECTION_FUNCTIONS\t\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\t\t\\\n+bss_section ()\t\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (in_section != in_bss)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"%s\\n\", BSS_SECTION_ASM_OP);\t\t\\\n+      in_section = in_bss;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+/* This is how to output an assembler line\n+   that says to advance the location counter\n+   to a multiple of 2**LOG bytes.  */\n+\n+#define ASM_OUTPUT_ALIGN(FILE,LOG)  \\\n+  if (current_section_is_text && (LOG) > 1)\t\t\t\t\\\n+    fprintf (FILE, \".text %d\\n\", LOG);\t\t\t\t\t\\\n+  else if (current_section_is_text)\t\t\t\t\t\\\n+    fprintf (FILE, \".text\\n.align %d\\n\", 1 << (LOG));\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    fprintf (FILE, \".align %d\\n\", 1 << (LOG))\n+\n+/* How to refer to registers in assembler output.\n+   This sequence is indexed by compiler's hard-register-number (see above).  */\n+\n+#define REGISTER_NAMES \\\n+{\"s0\", \"s1\", \"s2\", \"s3\", \"s4\", \"s5\", \"s6\", \"s7\", \\\n+ \"sp\", \"a1\", \"a2\", \"a3\", \"a4\", \"a5\", \"ap\", \"fp\"}\n+\n+/* This is BSD, so it wants DBX format.  */\n+\n+#define DBX_DEBUGGING_INFO\n+\n+/* How to renumber registers for dbx and gdb. */\n+\n+#define DBX_REGISTER_NUMBER(REGNO) (REGNO)\n+\n+/* Do not break .stabs pseudos into continuations.  */\n+\n+#define DBX_CONTIN_LENGTH 0\n+\n+/* This is the char to use for continuation (in case we need to turn\n+   continuation back on).  */\n+\n+#define DBX_CONTIN_CHAR '?'\n+\n+/* Don't use stab extensions until GDB v4 port is available for convex. */\n+\n+#define DEFAULT_GDB_EXTENSIONS 0\n+#define DBX_NO_XREFS\n+\n+/* This is how to output the definition of a user-level label named NAME,\n+   such as the label on a static function or variable NAME.  */\n+\n+#define ASM_OUTPUT_LABEL(FILE,NAME)\t\\\n+  do { assemble_name (FILE, NAME); fputs (\":\\n\", FILE); } while (0)\n+\n+/* This is how to output a command to make the user-level label named NAME\n+   defined for reference from other files.  */\n+\n+#define ASM_GLOBALIZE_LABEL(FILE,NAME)\t\\\n+  do { fputs (\".globl \", FILE); assemble_name (FILE, NAME); fputs (\"\\n\", FILE);} while (0)\n+\n+/* This is how to output a reference to a user-level label named NAME.  */\n+\n+#define ASM_OUTPUT_LABELREF(FILE,NAME)\t\\\n+  fprintf (FILE, \"_%s\", NAME)\n+\n+/* This is how to output an internal numbered label where\n+   PREFIX is the class of label and NUM is the number within the class.  */\n+\n+#define ASM_OUTPUT_INTERNAL_LABEL(FILE,PREFIX,NUM)\t\\\n+  fprintf (FILE, \"%s%d:\\n\", PREFIX, NUM)\n+\n+/* Put case tables in .text 2, where they will be word-aligned */\n+\n+#define ASM_OUTPUT_CASE_LABEL(FILE,PREFIX,NUM,TABLE) \\\n+  ASM_OUTPUT_ALIGN (FILE, 2); \\\n+  ASM_OUTPUT_INTERNAL_LABEL (FILE, PREFIX, NUM)\n+\n+#define ASM_OUTPUT_CASE_END(FILE,NUM,TABLE) \\\n+  ASM_OUTPUT_ALIGN (FILE, 1)\n+\n+/* This is how to store into the string LABEL\n+   the symbol_ref name of an internal numbered label where\n+   PREFIX is the class of label and NUM is the number within the class.\n+   This is suitable for output with `assemble_name'.  */\n+\n+#define ASM_GENERATE_INTERNAL_LABEL(LABEL,PREFIX,NUM)\t\\\n+  sprintf (LABEL, \"*%s%d\", PREFIX, NUM)\n+\n+/* This is how to output an assembler line defining a `double' constant.  */\n+\n+#define ASM_OUTPUT_DOUBLE(FILE,VALUE)  \\\n+  fprintf (FILE, \"\\tds.d %.17e\\n\", (VALUE))\n+\n+/* This is how to output an assembler line defining a `float' constant.  */\n+\n+#define ASM_OUTPUT_FLOAT(FILE,VALUE)  \\\n+  fprintf (FILE, \"\\tds.s %.9e\\n\", (VALUE))\n+\n+/* This is how to output an assembler line defining an `int' constant.  */\n+\n+#define ASM_OUTPUT_INT(FILE,VALUE)  \\\n+( fprintf (FILE, \"\\tds.w \"),\t\t\t\\\n+  output_addr_const (FILE, (VALUE)),\t\t\\\n+  fprintf (FILE, \"\\n\"))\n+\n+/* Likewise for a `long long int' constant.  */\n+\n+#define ASM_OUTPUT_DOUBLE_INT(FILE,VALUE)  \\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (GET_CODE (VALUE) == CONST_DOUBLE)\t\t\t\t\t\\\n+    fprintf (FILE, \"\\tds.w %d,%d\\n\",\t\t\t\t\t\\\n+\t     const_double_high_int (VALUE), const_double_low_int (VALUE)); \\\n+  else if (GET_CODE (VALUE) == CONST_INT)\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      int val = INTVAL (VALUE);\t\t\t\t\t\t\\\n+      fprintf (FILE, \"\\tds.w %d,%d\\n\", val < 0 ? -1 : 0, val);\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    abort ();\t\t\t\t\t\t\t\t\\\n+}\n+\n+/* Likewise for `char' and `short' constants.  */\n+\n+#define ASM_OUTPUT_SHORT(FILE,VALUE)  \\\n+( fprintf (FILE, \"\\tds.h \"),\t\t\t\\\n+  output_addr_const (FILE, (VALUE)),\t\t\\\n+  fprintf (FILE, \"\\n\"))\n+\n+#define ASM_OUTPUT_CHAR(FILE,VALUE)  \\\n+( fprintf (FILE, \"\\tds.b \"),\t\t\t\\\n+  output_addr_const (FILE, (VALUE)),\t\t\\\n+  fprintf (FILE, \"\\n\"))\n+\n+/* This is how to output an assembler line for a numeric constant byte.  */\n+\n+#define ASM_OUTPUT_BYTE(FILE,VALUE)  \\\n+  fprintf (FILE, \"\\tds.b %#x\\n\", (VALUE))\n+\n+/* This is how to output a string */\n+\n+#define ASM_OUTPUT_ASCII(FILE,STR,SIZE) do {\t\t\t\t\\\n+  int i;\t\t\t\t\t\t\t\t\\\n+  fprintf ((FILE), \"\\tds.b \\\"\");\t\t\t\t\t\\\n+  for (i = 0; i < (SIZE); i++) {\t\t\t\t\t\\\n+      register int c = (STR)[i] & 0377;\t\t\t\t\t\\\n+      if (c >= ' ' && c < 0177 && c != '\\\\' && c != '\"')\t\t\\\n+\t  putc (c, (FILE));\t\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+\t  fprintf ((FILE), \"\\\\%03o\", c);}\t\t\t\t\\\n+  fprintf ((FILE), \"\\\"\\n\");} while (0)\n+\n+/* This is how to output an insn to push a register on the stack.\n+   It need not be very fast code.  */\n+\n+#define ASM_OUTPUT_REG_PUSH(FILE,REGNO)  \t\\\n+   fprintf (FILE, \"\\tpsh.%c %s\\n\",\t\t\\\n+\t    S_REGNO_P (REGNO) ? 'l' : 'w',\t\\\n+\t    reg_names[REGNO])\n+\n+/* This is how to output an insn to pop a register from the stack.\n+   It need not be very fast code.  */\n+\n+#define ASM_OUTPUT_REG_POP(FILE,REGNO)\t\t\\\n+   fprintf (FILE, \"\\tpop.%c %s\\n\",\t\t\\\n+\t    S_REGNO_P (REGNO) ? 'l' : 'w',\t\\\n+\t    reg_names[REGNO])\n+\n+/* This is how to output an element of a case-vector that is absolute. */\n+\n+#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)  \\\n+  fprintf (FILE, \"\\tds.w L%d\\n\", VALUE)\n+\n+/* This is how to output an element of a case-vector that is relative.  \n+   (not used on Convex) */\n+\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL)  \\\n+  fprintf (FILE, \"\\tds.w L%d-L%d\\n\", VALUE, REL)\n+\n+/* This is how to output an assembler line\n+   that says to advance the location counter by SIZE bytes.  */\n+\n+#define ASM_OUTPUT_SKIP(FILE,SIZE)  \\\n+  fprintf (FILE, \"\\tds.b %u(0)\\n\", (SIZE))\n+\n+/* This says how to output an assembler line\n+   to define a global common symbol.  */\n+\n+#define ASM_OUTPUT_COMMON(FILE, NAME, SIZE, ROUNDED)  \\\n+( fputs (\".comm \", (FILE)),\t\t\t\\\n+  assemble_name ((FILE), (NAME)),\t\t\\\n+  fprintf ((FILE), \",%u\\n\", (ROUNDED)))\n+\n+/* This says how to output an assembler line\n+   to define a local common symbol.  */\n+\n+#define ASM_OUTPUT_LOCAL(FILE, NAME, SIZE, ROUNDED)  \\\n+( bss_section (),\t\t\t\t\\\n+  assemble_name ((FILE), (NAME)),\t\t\\\n+  fprintf ((FILE), \":\\tbs.b %u\\n\", (ROUNDED)))\n+\n+/* Store in OUTPUT a string (made with alloca) containing\n+   an assembler-name for a local static variable named NAME.\n+   LABELNO is an integer which is different for each call.  */\n+\n+#define ASM_FORMAT_PRIVATE_NAME(OUTPUT, NAME, LABELNO)\t\\\n+( (OUTPUT) = (char *) alloca (strlen ((NAME)) + 10),\t\\\n+  sprintf ((OUTPUT), \"%s.%d\", (NAME), (LABELNO)))\n+\n+/* Define the parentheses used to group arithmetic operations\n+   in assembler code.  */\n+\n+#define ASM_OPEN_PAREN \"(\"\n+#define ASM_CLOSE_PAREN \")\"\n+\n+/* Define results of standard character escape sequences.  */\n+#define TARGET_BELL 007\n+#define TARGET_BS 010\n+#define TARGET_TAB 011\n+#define TARGET_NEWLINE 012\n+#define TARGET_VT 013\n+#define TARGET_FF 014\n+#define TARGET_CR 015\n+\n+/* Print an instruction operand X on file FILE.\n+   CODE is the code from the %-spec that requested printing this operand;\n+   if `%z3' was used to print operand 3, then CODE is 'z'. */\n+\n+#define PRINT_OPERAND(FILE, X, CODE)  \\\n+{ if (GET_CODE (X) == REG)\t\t\t\t\t\t\\\n+    fprintf (FILE, \"%s\", reg_names[REGNO (X)]);\t\t\t\t\\\n+  else if (GET_CODE (X) == MEM)\t\t\t\t\t\t\\\n+    output_address (XEXP (X, 0));\t\t\t\t\t\\\n+  else if (GET_CODE (X) == CONST_DOUBLE\t\t\t\t\t\\\n+\t   && GET_MODE_CLASS (GET_MODE (X)) == MODE_FLOAT)\t\t\\\n+    { union { double d; int i[2]; } u;\t\t\t\t\t\\\n+      u.i[0] = CONST_DOUBLE_LOW (X); u.i[1] = CONST_DOUBLE_HIGH (X);\t\\\n+      fprintf (FILE, \"#%.9e\", u.d); }\t\t\t \t\t\\\n+  else { putc ('#', FILE); output_addr_const (FILE, X); }}\n+\n+/* Print a memory operand whose address is X, on file FILE. */\n+\n+#define PRINT_OPERAND_ADDRESS(FILE, ADDR)\t\t\t\t\\\n+{ \t\t\t\t\t\t\t\t\t\\\n+  register rtx addr = ADDR;\t\t\t\t\t\t\\\n+  register rtx index = 0;\t\t\t\t\t\t\\\n+  register rtx offset = 0;\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  if (GET_CODE (addr) == MEM)\t\t\t\t\t\t\\\n+    {  \t\t\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"@\");\t\t\t\t\t\t\\\n+      addr = XEXP (addr, 0);\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  switch (GET_CODE (addr))\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+    case REG:\t\t\t\t\t\t\t\t\\\n+      index = addr;\t\t\t\t\t\t\t\\\n+      break;\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    case PLUS:\t\t\t\t\t\t\t\t\\\n+      index = XEXP (addr, 0);\t\t\t\t\t\t\\\n+      if (REG_P (index))\t\t\t\t\t\t\\\n+\toffset = XEXP (addr, 1);\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  offset = XEXP (addr, 0);\t\t\t\t\t\\\n+\t  index = XEXP (addr, 1);\t\t\t\t\t\\\n+\t  if (! REG_P (index)) abort ();\t\t\t\t\\\n+        }\t\t\t\t\t\t\t\t\\\n+      break;\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    default:\t\t\t\t\t\t\t\t\\\n+      offset = addr;\t\t\t\t\t\t\t\\\n+      break;\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  if (offset)\t\t\t\t\t\t\t\t\\\n+    output_addr_const (FILE, offset);\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  if (index) \t\t\t\t\t\t\t\t\\\n+    fprintf (FILE, \"(%s)\", reg_names[REGNO (index)]);\t\t\t\\\n+}\n+\f\n+/* Definitions for g++.  */\n+\n+/* Do not put out GNU stabs for constructors and destructors.\n+   ld bounces them.  */\n+\n+#define FASCIST_ASSEMBLER\n+\n+/* Convex user addresses are negative, so use positive numbers\n+   to mean `vtable index'.  */\n+\n+#define VTABLE_USES_MASK\n+#define VINDEX_MAX ((unsigned) 0x80000000)\n+#define SET_DECL_VINDEX(DECL, INDEX) \\\n+  (DECL_VINDEX (DECL) = (INDEX))\n+\n+/* Defs for compiling collect2.c in -pcc mode during bootstrap. */\n+\n+#ifdef COLLECT\n+\n+#ifdef __STDC__\n+\n+#define HAVE_STRERROR\n+\n+#else\n+\n+#define vfprintf(file,fmt,args) _doprnt (fmt, args, file)\n+#define WTERMSIG(x) (((union wait *) &(x))->w_termsig)\n+#define WEXITSTATUS(x) (((union wait *) &(x))->w_retcode)\n+\n+#endif\n+\n+#endif /* COLLECT */"}]}