{"sha": "c44c2088f77877c43b110c508bbfec492ba487a7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzQ0YzIwODhmNzc4NzdjNDNiMTEwYzUwOGJiZmVjNDkyYmE0ODdhNw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2012-05-19T09:49:47Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2012-05-19T09:49:47Z"}, "message": "cgraphbuild.c (record_reference): Update.\n\n\t* cgraphbuild.c (record_reference): Update.\n\t* lto-cgraph.c (lto_output_varpool_node): External vars\n\tare not in other partition even if they are not output\n\tin current partition.\n\t* gimple-fold.c (can_refer_decl_in_current_unit_p): Take FROM_DECL\n\targument; fix.\n\t(canonicalize_constructor_val): Take FROM_DECL argument.\n\t(fold_ctor_reference, fold_string_cst_ctor_reference,\n\tfold_array_ctor_reference, fold_nonarray_ctor_reference,\n\tfold_ctor_reference): Likewise.\n\t(fold_const_aggregate_ref_1, gimple_get_virt_method_for_binfo): Update.\n\t* gimple.h (gimple_fold_builtin): Likewise.\n\nFrom-SVN: r187678", "tree": {"sha": "bb72d53e69f1fe6cb1c4cad585a0b19bdc16980d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bb72d53e69f1fe6cb1c4cad585a0b19bdc16980d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c44c2088f77877c43b110c508bbfec492ba487a7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c44c2088f77877c43b110c508bbfec492ba487a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c44c2088f77877c43b110c508bbfec492ba487a7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c44c2088f77877c43b110c508bbfec492ba487a7/comments", "author": null, "committer": null, "parents": [{"sha": "c80c1ce9510e2840d036d6a5e9b035a659701c41", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c80c1ce9510e2840d036d6a5e9b035a659701c41", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c80c1ce9510e2840d036d6a5e9b035a659701c41"}], "stats": {"total": 136, "additions": 94, "deletions": 42}, "files": [{"sha": "b648c7032b5b39dfaae0b96520fe5a507b584f14", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c44c2088f77877c43b110c508bbfec492ba487a7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c44c2088f77877c43b110c508bbfec492ba487a7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c44c2088f77877c43b110c508bbfec492ba487a7", "patch": "@@ -1,3 +1,18 @@\n+2012-05-18  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cgraphbuild.c (record_reference): Update.\n+\t* lto-cgraph.c (lto_output_varpool_node): External vars\n+\tare not in other partition even if they are not output\n+\tin current partition.\n+\t* gimple-fold.c (can_refer_decl_in_current_unit_p): Take FROM_DECL\n+\targument; fix.\n+\t(canonicalize_constructor_val): Take FROM_DECL argument.\n+\t(fold_ctor_reference, fold_string_cst_ctor_reference,\n+\tfold_array_ctor_reference, fold_nonarray_ctor_reference,\n+\tfold_ctor_reference): Likewise.\n+\t(fold_const_aggregate_ref_1, gimple_get_virt_method_for_binfo): Update.\n+\t* gimple.h (gimple_fold_builtin): Likewise.\n+\n 2012-05-18  Olivier Hainque  <hainque@adacore.com>\n \n \t* Makefile.in (FLAGS_TO_PASS): Pass $(libexecsubdir) instead of"}, {"sha": "ce8f2ee080a798f8fe1a1efab09aa4e8dedbeef0", "filename": "gcc/cgraphbuild.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c44c2088f77877c43b110c508bbfec492ba487a7/gcc%2Fcgraphbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c44c2088f77877c43b110c508bbfec492ba487a7/gcc%2Fcgraphbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphbuild.c?ref=c44c2088f77877c43b110c508bbfec492ba487a7", "patch": "@@ -54,7 +54,7 @@ record_reference (tree *tp, int *walk_subtrees, void *data)\n   tree decl;\n   struct record_reference_ctx *ctx = (struct record_reference_ctx *)data;\n \n-  t = canonicalize_constructor_val (t);\n+  t = canonicalize_constructor_val (t, NULL);\n   if (!t)\n     t = *tp;\n   else if (t != *tp)"}, {"sha": "6b4d987e025715e9c4d462921253b3061df385d2", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 77, "deletions": 40, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c44c2088f77877c43b110c508bbfec492ba487a7/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c44c2088f77877c43b110c508bbfec492ba487a7/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=c44c2088f77877c43b110c508bbfec492ba487a7", "patch": "@@ -33,8 +33,9 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimple-fold.h\"\n \n /* Return true when DECL can be referenced from current unit.\n-   We can get declarations that are not possible to reference for\n-   various reasons:\n+   FROM_DECL (if non-null) specify constructor of variable DECL was taken from.\n+   We can get declarations that are not possible to reference for various\n+   reasons:\n \n      1) When analyzing C++ virtual tables.\n \tC++ virtual tables do have known constructors even\n@@ -54,19 +55,35 @@ along with GCC; see the file COPYING3.  If not see\n         directly.  */\n \n static bool\n-can_refer_decl_in_current_unit_p (tree decl)\n+can_refer_decl_in_current_unit_p (tree decl, tree from_decl)\n {\n   struct varpool_node *vnode;\n   struct cgraph_node *node;\n-\n-  if (!TREE_STATIC (decl) && !DECL_EXTERNAL (decl))\n+  symtab_node snode;\n+\n+  /* We will later output the initializer, so we can reffer to it.\n+     So we are concerned only when DECL comes from initializer of\n+     external var.  */\n+  if (!from_decl\n+      || TREE_CODE (from_decl) != VAR_DECL\n+      || !DECL_EXTERNAL (from_decl)\n+      || (symtab_get_node (from_decl)->symbol.in_other_partition))\n+    return true;\n+  /* We are concerned ony about static/external vars and functions.  */\n+  if ((!TREE_STATIC (decl) && !DECL_EXTERNAL (decl))\n+      || (TREE_CODE (decl) != VAR_DECL && TREE_CODE (decl) != FUNCTION_DECL))\n     return true;\n-  /* External flag is set, so we deal with C++ reference\n-     to static object from other file.\n-     We also may see weakref that is always safe.  */\n-  if (DECL_EXTERNAL (decl) && TREE_STATIC (decl)\n-      && TREE_CODE (decl) == VAR_DECL)\n-    return lookup_attribute (\"weakref\", DECL_ATTRIBUTES (decl)) != NULL;\n+  /* Weakrefs have somewhat confusing DECL_EXTERNAL flag set; they are always safe.  */\n+  if (DECL_EXTERNAL (decl)\n+      && lookup_attribute (\"weakref\", DECL_ATTRIBUTES (decl)))\n+    return true;\n+  /* We are folding reference from external vtable.  The vtable may reffer\n+     to a symbol keyed to other compilation unit.  The other compilation\n+     unit may be in separate DSO and the symbol may be hidden.  */\n+  if (DECL_VISIBILITY_SPECIFIED (decl)\n+      && DECL_EXTERNAL (decl)\n+      && (!(snode = symtab_get_node (decl)) || !snode->symbol.in_other_partition))\n+    return false;\n   /* When function is public, we always can introduce new reference.\n      Exception are the COMDAT functions where introducing a direct\n      reference imply need to include function body in the curren tunit.  */\n@@ -75,14 +92,19 @@ can_refer_decl_in_current_unit_p (tree decl)\n   /* We are not at ltrans stage; so don't worry about WHOPR.\n      Also when still gimplifying all referred comdat functions will be\n      produced.\n-     ??? as observed in PR20991 for already optimized out comdat virtual functions\n-     we may not neccesarily give up because the copy will be output elsewhere when\n-     corresponding vtable is output.  */\n+\n+     As observed in PR20991 for already optimized out comdat virtual functions\n+     it may be tempting to not neccesarily give up because the copy will be\n+     output elsewhere when corresponding vtable is output.  \n+     This is however not possible - ABI specify that COMDATs are output in\n+     units where they are used and when the other unit was compiled with LTO\n+     it is possible that vtable was kept public while the function itself\n+     was privatized. */\n   if (!flag_ltrans && (!DECL_COMDAT (decl) || !cgraph_function_flags_ready))\n     return true;\n-  /* If we already output the function body, we are safe.  */\n-  if (TREE_ASM_WRITTEN (decl))\n-    return true;\n+\n+  /* OK we are seeing either COMDAT or static variable.  In this case we must\n+     check that the definition is still around so we can refer it.  */\n   if (TREE_CODE (decl) == FUNCTION_DECL)\n     {\n       node = cgraph_get_node (decl);\n@@ -92,22 +114,29 @@ can_refer_decl_in_current_unit_p (tree decl)\n          compilation stage when making a new reference no longer makes callee\n          to be compiled.  */\n       if (!node || !node->analyzed || node->global.inlined_to)\n-\treturn false;\n+\t{\n+\t  gcc_checking_assert (!TREE_ASM_WRITTEN (decl));\n+\t  return false;\n+\t}\n     }\n   else if (TREE_CODE (decl) == VAR_DECL)\n     {\n       vnode = varpool_get_node (decl);\n-      if (!vnode || !vnode->finalized)\n-\treturn false;\n+      if (!vnode || !vnode->analyzed)\n+\t{\n+\t  gcc_checking_assert (!TREE_ASM_WRITTEN (decl));\n+\t  return false;\n+\t}\n     }\n   return true;\n }\n \n /* CVAL is value taken from DECL_INITIAL of variable.  Try to transform it into\n-   acceptable form for is_gimple_min_invariant.   */\n+   acceptable form for is_gimple_min_invariant.\n+   FROM_DECL (if non-NULL) specify variable whose constructor contains CVAL.  */\n \n tree\n-canonicalize_constructor_val (tree cval)\n+canonicalize_constructor_val (tree cval, tree from_decl)\n {\n   STRIP_NOPS (cval);\n   if (TREE_CODE (cval) == POINTER_PLUS_EXPR\n@@ -130,7 +159,7 @@ canonicalize_constructor_val (tree cval)\n \n       if ((TREE_CODE (base) == VAR_DECL\n \t   || TREE_CODE (base) == FUNCTION_DECL)\n-\t  && !can_refer_decl_in_current_unit_p (base))\n+\t  && !can_refer_decl_in_current_unit_p (base, from_decl))\n \treturn NULL_TREE;\n       if (TREE_CODE (base) == VAR_DECL)\n \t{\n@@ -163,7 +192,7 @@ get_symbol_constant_value (tree sym)\n       tree val = DECL_INITIAL (sym);\n       if (val)\n \t{\n-\t  val = canonicalize_constructor_val (val);\n+\t  val = canonicalize_constructor_val (val, sym);\n \t  if (val && is_gimple_min_invariant (val))\n \t    return val;\n \t  else\n@@ -2627,7 +2656,7 @@ gimple_fold_stmt_to_constant (gimple stmt, tree (*valueize) (tree))\n \n static tree fold_ctor_reference (tree type, tree ctor,\n \t\t\t\t unsigned HOST_WIDE_INT offset,\n-\t\t\t\t unsigned HOST_WIDE_INT size);\n+\t\t\t\t unsigned HOST_WIDE_INT size, tree);\n \n /* See if we can find constructor defining value of BASE.\n    When we know the consructor with constant offset (such as\n@@ -2735,7 +2764,8 @@ fold_string_cst_ctor_reference (tree type, tree ctor,\n static tree\n fold_array_ctor_reference (tree type, tree ctor,\n \t\t\t   unsigned HOST_WIDE_INT offset,\n-\t\t\t   unsigned HOST_WIDE_INT size)\n+\t\t\t   unsigned HOST_WIDE_INT size,\n+\t\t\t   tree from_decl)\n {\n   unsigned HOST_WIDE_INT cnt;\n   tree cfield, cval;\n@@ -2824,7 +2854,8 @@ fold_array_ctor_reference (tree type, tree ctor,\n       /* Do we have match?  */\n       if (double_int_cmp (access_index, index, 1) >= 0\n \t  && double_int_cmp (access_index, max_index, 1) <= 0)\n-\treturn fold_ctor_reference (type, cval, inner_offset, size);\n+\treturn fold_ctor_reference (type, cval, inner_offset, size,\n+\t\t\t\t    from_decl);\n     }\n   /* When memory is not explicitely mentioned in constructor,\n      it is 0 (or out of range).  */\n@@ -2837,7 +2868,8 @@ fold_array_ctor_reference (tree type, tree ctor,\n static tree\n fold_nonarray_ctor_reference (tree type, tree ctor,\n \t\t\t      unsigned HOST_WIDE_INT offset,\n-\t\t\t      unsigned HOST_WIDE_INT size)\n+\t\t\t      unsigned HOST_WIDE_INT size,\n+\t\t\t      tree from_decl)\n {\n   unsigned HOST_WIDE_INT cnt;\n   tree cfield, cval;\n@@ -2892,7 +2924,8 @@ fold_nonarray_ctor_reference (tree type, tree ctor,\n \t  if (double_int_cmp (uhwi_to_double_int (offset), bitoffset, 0) < 0)\n \t    return NULL_TREE;\n \t  return fold_ctor_reference (type, cval,\n-\t\t\t\t      double_int_to_uhwi (inner_offset), size);\n+\t\t\t\t      double_int_to_uhwi (inner_offset), size,\n+\t\t\t\t      from_decl);\n \t}\n     }\n   /* When memory is not explicitely mentioned in constructor, it is 0.  */\n@@ -2904,14 +2937,14 @@ fold_nonarray_ctor_reference (tree type, tree ctor,\n \n static tree\n fold_ctor_reference (tree type, tree ctor, unsigned HOST_WIDE_INT offset,\n-\t\t     unsigned HOST_WIDE_INT size)\n+\t\t     unsigned HOST_WIDE_INT size, tree from_decl)\n {\n   tree ret;\n \n   /* We found the field with exact match.  */\n   if (useless_type_conversion_p (type, TREE_TYPE (ctor))\n       && !offset)\n-    return canonicalize_constructor_val (ctor);\n+    return canonicalize_constructor_val (ctor, from_decl);\n \n   /* We are at the end of walk, see if we can view convert the\n      result.  */\n@@ -2920,7 +2953,7 @@ fold_ctor_reference (tree type, tree ctor, unsigned HOST_WIDE_INT offset,\n       && operand_equal_p (TYPE_SIZE (type),\n \t\t\t  TYPE_SIZE (TREE_TYPE (ctor)), 0))\n     {\n-      ret = canonicalize_constructor_val (ctor);\n+      ret = canonicalize_constructor_val (ctor, from_decl);\n       ret = fold_unary (VIEW_CONVERT_EXPR, type, ret);\n       if (ret)\n \tSTRIP_NOPS (ret);\n@@ -2933,9 +2966,11 @@ fold_ctor_reference (tree type, tree ctor, unsigned HOST_WIDE_INT offset,\n \n       if (TREE_CODE (TREE_TYPE (ctor)) == ARRAY_TYPE\n \t  || TREE_CODE (TREE_TYPE (ctor)) == VECTOR_TYPE)\n-\treturn fold_array_ctor_reference (type, ctor, offset, size);\n+\treturn fold_array_ctor_reference (type, ctor, offset, size,\n+\t\t\t\t\t  from_decl);\n       else\n-\treturn fold_nonarray_ctor_reference (type, ctor, offset, size);\n+\treturn fold_nonarray_ctor_reference (type, ctor, offset, size,\n+\t\t\t\t\t     from_decl);\n     }\n \n   return NULL_TREE;\n@@ -3008,7 +3043,8 @@ fold_const_aggregate_ref_1 (tree t, tree (*valueize) (tree))\n \t\treturn NULL_TREE;\n \t      return fold_ctor_reference (TREE_TYPE (t), ctor, offset,\n \t\t\t\t\t  TREE_INT_CST_LOW (unit_size)\n-\t\t\t\t\t  * BITS_PER_UNIT);\n+\t\t\t\t\t  * BITS_PER_UNIT,\n+\t\t\t\t\t  base);\n \t    }\n \t}\n       /* Fallthru.  */\n@@ -3034,7 +3070,8 @@ fold_const_aggregate_ref_1 (tree t, tree (*valueize) (tree))\n       if (offset < 0)\n \treturn NULL_TREE;\n \n-      return fold_ctor_reference (TREE_TYPE (t), ctor, offset, size);\n+      return fold_ctor_reference (TREE_TYPE (t), ctor, offset, size,\n+\t\t\t\t  base);\n \n     case REALPART_EXPR:\n     case IMAGPART_EXPR:\n@@ -3068,9 +3105,9 @@ tree\n gimple_get_virt_method_for_binfo (HOST_WIDE_INT token, tree known_binfo)\n {\n   unsigned HOST_WIDE_INT offset, size;\n-  tree v, fn;\n+  tree v, fn, vtable;\n \n-  v = BINFO_VTABLE (known_binfo);\n+  vtable = v = BINFO_VTABLE (known_binfo);\n   /* If there is no virtual methods table, leave the OBJ_TYPE_REF alone.  */\n   if (!v)\n     return NULL_TREE;\n@@ -3096,7 +3133,7 @@ gimple_get_virt_method_for_binfo (HOST_WIDE_INT token, tree known_binfo)\n   size = tree_low_cst (TYPE_SIZE (TREE_TYPE (TREE_TYPE (v))), 1);\n   offset += token * size;\n   fn = fold_ctor_reference (TREE_TYPE (TREE_TYPE (v)), DECL_INITIAL (v),\n-\t\t\t    offset, size);\n+\t\t\t    offset, size, vtable);\n   if (!fn || integer_zerop (fn))\n     return NULL_TREE;\n   gcc_assert (TREE_CODE (fn) == ADDR_EXPR\n@@ -3108,7 +3145,7 @@ gimple_get_virt_method_for_binfo (HOST_WIDE_INT token, tree known_binfo)\n      devirtualize.  This can happen in WHOPR when the actual method\n      ends up in other partition, because we found devirtualization\n      possibility too late.  */\n-  if (!can_refer_decl_in_current_unit_p (fn))\n+  if (!can_refer_decl_in_current_unit_p (fn, vtable))\n     return NULL_TREE;\n \n   /* Make sure we create a cgraph node for functions we'll reference."}, {"sha": "aefccaaeab7c301560a8863ba0e2799130a5f3bb", "filename": "gcc/gimple.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c44c2088f77877c43b110c508bbfec492ba487a7/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c44c2088f77877c43b110c508bbfec492ba487a7/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=c44c2088f77877c43b110c508bbfec492ba487a7", "patch": "@@ -5315,7 +5315,7 @@ tree gimple_fold_builtin (gimple);\n bool fold_stmt (gimple_stmt_iterator *);\n bool fold_stmt_inplace (gimple_stmt_iterator *);\n tree get_symbol_constant_value (tree);\n-tree canonicalize_constructor_val (tree);\n+tree canonicalize_constructor_val (tree, tree);\n extern tree maybe_fold_and_comparisons (enum tree_code, tree, tree, \n \t\t\t\t\tenum tree_code, tree, tree);\n extern tree maybe_fold_or_comparisons (enum tree_code, tree, tree,"}]}