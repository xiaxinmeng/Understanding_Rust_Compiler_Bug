{"sha": "b3458f6117797fd0fff6b451e771a18fe6ba0434", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjM0NThmNjExNzc5N2ZkMGZmZjZiNDUxZTc3MWExOGZlNmJhMDQzNA==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2014-08-25T16:36:54Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2014-08-25T16:36:54Z"}, "message": "config/arc: Use rtx_insn\n\ngcc/\n\t* config/arc/arc-protos.h (arc_final_prescan_insn): Strengthen\n\tfirst param from rtx to rtx_insn *.\n\t(arc_verify_short): Likewise.\n\t(arc_short_long): Likewise.\n\t(arc_need_delay): Likewise.\n\n\t* config/arc/arc.c (struct arc_ccfsm): Likewise for field\n\t\"target_insn\".\n\t(arc_ccfsm_advance): Likewise for param \"insn\" and locals\n\t\"start_insn\", \"this_insn\".\n\t(arc_ccfsm_record_condition): Likewise for local \"seq_insn\".\n\t(arc_ccfsm_post_advance): Likewise for param \"insn\".\n\t(arc_next_active_insn): Likewise for return type and param \"insn\".\n\tConvert NULL_RTX to NULL as appropriate.  Add a checked cast.\n\t(arc_verify_short): Strengthen param \"insn\" from rtx to rtx_insn *.\n\t(output_short_suffix): Likewise for local \"insn\".\n\t(arc_final_prescan_insn): Likewise for param \"insn\".  Remove\n\tnow-redundant checked cast.\n\t(arc_reorg): Strengthen locals \"insn\", \"top_label\", \"lp\", \"prev\",\n\t\"lp_simple\", \"next\", \"mov\", \"scan\", \"link_insn\" from rtx to\n\trtx_insn *.  Add a checked cast.  Introduce local \"lc_set_insn\"\n\tfor use where lc_set became an insn.\n\t(arc_adjust_insn_length): Strengthen locals \"prev\", \"succ\" from\n\trtx to rtx_insn *.\n\t(arc_get_insn_variants): Likewise for local \"prev\".\n\t(arc_ifcvt): Likewise for locals \"insn\", \"seq\", \"prev\", \"pprev\",\n\t\"next\".\n\t(arc_predicate_delay_insns): Likewise for local \"insn\".\n\t(arc_pad_return): Likewise for local \"prev\".  For now, add a\n\tchecked cast when extracting the insn from \"final_sequence\".\n\t(arc_short_long): Likewise for param \"insn\".\n\t(arc_need_delay): Likewise for param \"insn\" and local \"next\".\n\t(arc_label_align): Likewise for locals \"prev\", \"next\".\n\nFrom-SVN: r214436", "tree": {"sha": "1b92f591dc31ba3ab77f0cb42a50a82e690704c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1b92f591dc31ba3ab77f0cb42a50a82e690704c5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b3458f6117797fd0fff6b451e771a18fe6ba0434", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3458f6117797fd0fff6b451e771a18fe6ba0434", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b3458f6117797fd0fff6b451e771a18fe6ba0434", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3458f6117797fd0fff6b451e771a18fe6ba0434/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "cad003bacf9bf8306fdeb296c018b252fdd91903", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cad003bacf9bf8306fdeb296c018b252fdd91903", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cad003bacf9bf8306fdeb296c018b252fdd91903"}], "stats": {"total": 141, "additions": 91, "deletions": 50}, "files": [{"sha": "48b1874d67dcdd2a454be464bf3fcb5db3274cfc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3458f6117797fd0fff6b451e771a18fe6ba0434/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3458f6117797fd0fff6b451e771a18fe6ba0434/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b3458f6117797fd0fff6b451e771a18fe6ba0434", "patch": "@@ -1,3 +1,39 @@\n+2014-08-25  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* config/arc/arc-protos.h (arc_final_prescan_insn): Strengthen\n+\tfirst param from rtx to rtx_insn *.\n+\t(arc_verify_short): Likewise.\n+\t(arc_short_long): Likewise.\n+\t(arc_need_delay): Likewise.\n+\n+\t* config/arc/arc.c (struct arc_ccfsm): Likewise for field\n+\t\"target_insn\".\n+\t(arc_ccfsm_advance): Likewise for param \"insn\" and locals\n+\t\"start_insn\", \"this_insn\".\n+\t(arc_ccfsm_record_condition): Likewise for local \"seq_insn\".\n+\t(arc_ccfsm_post_advance): Likewise for param \"insn\".\n+\t(arc_next_active_insn): Likewise for return type and param \"insn\".\n+\tConvert NULL_RTX to NULL as appropriate.  Add a checked cast.\n+\t(arc_verify_short): Strengthen param \"insn\" from rtx to rtx_insn *.\n+\t(output_short_suffix): Likewise for local \"insn\".\n+\t(arc_final_prescan_insn): Likewise for param \"insn\".  Remove\n+\tnow-redundant checked cast.\n+\t(arc_reorg): Strengthen locals \"insn\", \"top_label\", \"lp\", \"prev\",\n+\t\"lp_simple\", \"next\", \"mov\", \"scan\", \"link_insn\" from rtx to\n+\trtx_insn *.  Add a checked cast.  Introduce local \"lc_set_insn\"\n+\tfor use where lc_set became an insn.\n+\t(arc_adjust_insn_length): Strengthen locals \"prev\", \"succ\" from\n+\trtx to rtx_insn *.\n+\t(arc_get_insn_variants): Likewise for local \"prev\".\n+\t(arc_ifcvt): Likewise for locals \"insn\", \"seq\", \"prev\", \"pprev\",\n+\t\"next\".\n+\t(arc_predicate_delay_insns): Likewise for local \"insn\".\n+\t(arc_pad_return): Likewise for local \"prev\".  For now, add a\n+\tchecked cast when extracting the insn from \"final_sequence\".\n+\t(arc_short_long): Likewise for param \"insn\".\n+\t(arc_need_delay): Likewise for param \"insn\" and local \"next\".\n+\t(arc_label_align): Likewise for locals \"prev\", \"next\".\n+\n 2014-08-25  David Malcolm  <dmalcolm@redhat.com>\n \n \t* config/alpha/alpha.c (alpha_emit_set_const): Strengthen local"}, {"sha": "89538455e1ea49ef867e04035d55c3b5ad1b753c", "filename": "gcc/config/arc/arc-protos.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3458f6117797fd0fff6b451e771a18fe6ba0434/gcc%2Fconfig%2Farc%2Farc-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3458f6117797fd0fff6b451e771a18fe6ba0434/gcc%2Fconfig%2Farc%2Farc-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc-protos.h?ref=b3458f6117797fd0fff6b451e771a18fe6ba0434", "patch": "@@ -31,7 +31,7 @@ extern bool compact_sda_memory_operand (rtx op,enum machine_mode  mode);\n extern bool arc_double_limm_p (rtx);\n extern void arc_print_operand (FILE *, rtx, int);\n extern void arc_print_operand_address (FILE *, rtx);\n-extern void arc_final_prescan_insn (rtx, rtx *, int);\n+extern void arc_final_prescan_insn (rtx_insn *, rtx *, int);\n extern void arc_set_default_type_attributes(tree type);\n extern const char *arc_output_libcall (const char *);\n extern bool prepare_extend_operands (rtx *operands, enum rtx_code code,\n@@ -100,14 +100,14 @@ extern void split_addsi (rtx *);\n extern void split_subsi (rtx *);\n extern void arc_pad_return (void);\n extern rtx arc_split_move (rtx *);\n-extern int arc_verify_short (rtx insn, int unalign, int);\n-extern const char *arc_short_long (rtx insn, const char *, const char *);\n+extern int arc_verify_short (rtx_insn *insn, int unalign, int);\n+extern const char *arc_short_long (rtx_insn *insn, const char *, const char *);\n extern rtx arc_regno_use_in (unsigned int, rtx);\n extern int arc_attr_type (rtx);\n extern bool arc_scheduling_not_expected (void);\n extern bool arc_sets_cc_p (rtx insn);\n extern int arc_label_align (rtx label);\n-extern bool arc_need_delay (rtx insn);\n+extern bool arc_need_delay (rtx_insn *insn);\n extern bool arc_text_label (rtx);\n extern int arc_decl_pretend_args (tree decl);\n extern bool arc_short_comparison_p (rtx, int);"}, {"sha": "352080f65b92f3a32588b7839fb0cf66b8f5e51c", "filename": "gcc/config/arc/arc.c", "status": "modified", "additions": 51, "deletions": 46, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3458f6117797fd0fff6b451e771a18fe6ba0434/gcc%2Fconfig%2Farc%2Farc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3458f6117797fd0fff6b451e771a18fe6ba0434/gcc%2Fconfig%2Farc%2Farc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.c?ref=b3458f6117797fd0fff6b451e771a18fe6ba0434", "patch": "@@ -117,7 +117,7 @@ struct GTY (()) arc_ccfsm\n   int state;\n   int cc;\n   rtx cond;\n-  rtx target_insn;\n+  rtx_insn *target_insn;\n   int target_label;\n };\n \n@@ -3404,7 +3404,7 @@ unspec_prof_htab_eq (const void *x, const void *y)\n    before letting final output INSN.  */\n \n static void\n-arc_ccfsm_advance (rtx insn, struct arc_ccfsm *state)\n+arc_ccfsm_advance (rtx_insn *insn, struct arc_ccfsm *state)\n {\n   /* BODY will hold the body of INSN.  */\n   register rtx body;\n@@ -3418,7 +3418,7 @@ arc_ccfsm_advance (rtx insn, struct arc_ccfsm *state)\n \n   /* START_INSN will hold the insn from where we start looking.  This is the\n      first insn after the following code_label if REVERSE is true.  */\n-  rtx start_insn = insn;\n+  rtx_insn *start_insn = insn;\n \n   /* Type of the jump_insn. Brcc insns don't affect ccfsm changes,\n      since they don't rely on a cmp preceding the.  */\n@@ -3516,7 +3516,8 @@ arc_ccfsm_advance (rtx insn, struct arc_ccfsm *state)\n       int then_not_else = TRUE;\n       /* Nonzero if next insn must be the target label.  */\n       int next_must_be_target_label_p;\n-      rtx this_insn = start_insn, label = 0;\n+      rtx_insn *this_insn = start_insn;\n+      rtx label = 0;\n \n       /* Register the insn jumped to.  */\n       if (reverse)\n@@ -3725,7 +3726,7 @@ arc_ccfsm_at_label (const char *prefix, int num, struct arc_ccfsm *state)\n       && !strcmp (prefix, \"L\"))\n     {\n       state->state = 0;\n-      state->target_insn = NULL_RTX;\n+      state->target_insn = NULL;\n     }\n }\n \n@@ -3737,7 +3738,7 @@ void\n arc_ccfsm_record_condition (rtx cond, bool reverse, rtx jump,\n \t\t\t    struct arc_ccfsm *state)\n {\n-  rtx seq_insn = NEXT_INSN (PREV_INSN (jump));\n+  rtx_insn *seq_insn = NEXT_INSN (PREV_INSN (jump));\n   if (!state)\n     state = &arc_ccfsm_current;\n \n@@ -3769,7 +3770,7 @@ arc_ccfsm_record_condition (rtx cond, bool reverse, rtx jump,\n /* Update *STATE as we would when we emit INSN.  */\n \n static void\n-arc_ccfsm_post_advance (rtx insn, struct arc_ccfsm *state)\n+arc_ccfsm_post_advance (rtx_insn *insn, struct arc_ccfsm *state)\n {\n   enum attr_type type;\n \n@@ -3827,8 +3828,8 @@ arc_ccfsm_cond_exec_p (void)\n /* Like next_active_insn, but return NULL if we find an ADDR_(DIFF_)VEC,\n    and look inside SEQUENCEs.  */\n \n-static rtx\n-arc_next_active_insn (rtx insn, struct arc_ccfsm *statep)\n+static rtx_insn *\n+arc_next_active_insn (rtx_insn *insn, struct arc_ccfsm *statep)\n {\n   rtx pat;\n \n@@ -3838,7 +3839,7 @@ arc_next_active_insn (rtx insn, struct arc_ccfsm *statep)\n \tarc_ccfsm_post_advance (insn, statep);\n       insn = NEXT_INSN (insn);\n       if (!insn || BARRIER_P (insn))\n-\treturn NULL_RTX;\n+\treturn NULL;\n       if (statep)\n \tarc_ccfsm_advance (insn, statep);\n     }\n@@ -3853,9 +3854,9 @@ arc_next_active_insn (rtx insn, struct arc_ccfsm *statep)\n       gcc_assert (INSN_P (insn));\n       pat = PATTERN (insn);\n       if (GET_CODE (pat) == ADDR_VEC || GET_CODE (pat) == ADDR_DIFF_VEC)\n-\treturn NULL_RTX;\n+\treturn NULL;\n       if (GET_CODE (pat) == SEQUENCE)\n-\treturn XVECEXP (pat, 0, 0);\n+\treturn as_a <rtx_insn *> (XVECEXP (pat, 0, 0));\n     }\n   return insn;\n }\n@@ -3885,7 +3886,7 @@ arc_next_active_insn (rtx insn, struct arc_ccfsm *statep)\n    If CHECK_ATTR is greater than 0, check the iscompact attribute first.  */\n \n int\n-arc_verify_short (rtx insn, int, int check_attr)\n+arc_verify_short (rtx_insn *insn, int, int check_attr)\n {\n   enum attr_iscompact iscompact;\n   struct machine_function *machine;\n@@ -3911,7 +3912,7 @@ arc_verify_short (rtx insn, int, int check_attr)\n static void\n output_short_suffix (FILE *file)\n {\n-  rtx insn = current_output_insn;\n+  rtx_insn *insn = current_output_insn;\n \n   if (arc_verify_short (insn, cfun->machine->unalign, 1))\n     {\n@@ -3925,7 +3926,7 @@ output_short_suffix (FILE *file)\n /* Implement FINAL_PRESCAN_INSN.  */\n \n void\n-arc_final_prescan_insn (rtx insn, rtx *opvec ATTRIBUTE_UNUSED,\n+arc_final_prescan_insn (rtx_insn *insn, rtx *opvec ATTRIBUTE_UNUSED,\n \t\t\tint noperands ATTRIBUTE_UNUSED)\n {\n   if (TARGET_DUMPISIZE)\n@@ -3943,7 +3944,7 @@ arc_final_prescan_insn (rtx insn, rtx *opvec ATTRIBUTE_UNUSED,\n       current_output_insn =\n \temit_insn_before (gen_nop (), NEXT_INSN (PREV_INSN (insn)));\n       final_scan_insn (current_output_insn, asm_out_file, optimize, 1, NULL);\n-      current_output_insn = as_a <rtx_insn *> (insn);\n+      current_output_insn = insn;\n     }\n   /* Restore extraction data which might have been clobbered by arc_hazard.  */\n   extract_constrain_insn_cached (insn);\n@@ -5733,7 +5734,8 @@ static int arc_reorg_in_progress = 0;\n static void\n arc_reorg (void)\n {\n-  rtx insn, pattern;\n+  rtx_insn *insn;\n+  rtx pattern;\n   rtx pc_target;\n   long offset;\n   int changed;\n@@ -5745,7 +5747,7 @@ arc_reorg (void)\n   if (crtl->profile)\n     {\n       section *save_text_section;\n-      rtx insn;\n+      rtx_insn *insn;\n       int size = get_max_uid () >> 4;\n       htab_t htab = htab_create (size, unspec_prof_hash, unspec_prof_htab_eq,\n \t\t\t\t NULL);\n@@ -5766,12 +5768,12 @@ arc_reorg (void)\n       if (GET_CODE (insn) == JUMP_INSN\n \t  && recog_memoized (insn) == CODE_FOR_doloop_end_i)\n \t{\n-\t  rtx top_label\n-\t    = XEXP (XEXP (SET_SRC (XVECEXP (PATTERN (insn), 0, 0)), 1), 0);\n+\t  rtx_insn *top_label\n+\t    = as_a <rtx_insn *> (XEXP (XEXP (SET_SRC (XVECEXP (PATTERN (insn), 0, 0)), 1), 0));\n \t  rtx num = GEN_INT (CODE_LABEL_NUMBER (top_label));\n-\t  rtx lp, prev = prev_nonnote_insn (top_label);\n-\t  rtx lp_simple = NULL_RTX;\n-\t  rtx next = NULL_RTX;\n+\t  rtx_insn *lp, *prev = prev_nonnote_insn (top_label);\n+\t  rtx_insn *lp_simple = NULL;\n+\t  rtx_insn *next = NULL;\n \t  rtx op0 = XEXP (XVECEXP (PATTERN (insn), 0, 1), 0);\n \t  HOST_WIDE_INT loop_end_id\n \t    = -INTVAL (XEXP (XVECEXP (PATTERN (insn), 0, 4), 0));\n@@ -5785,7 +5787,7 @@ arc_reorg (void)\n \t  if (!lp || !NONJUMP_INSN_P (lp)\n \t      || dead_or_set_regno_p (lp, LP_COUNT))\n \t    {\n-\t      for (prev = next = insn, lp = NULL_RTX ; prev || next;)\n+\t      for (prev = next = insn, lp = NULL ; prev || next;)\n \t\t{\n \t\t  if (prev)\n \t\t    {\n@@ -5814,7 +5816,7 @@ arc_reorg (void)\n \t\t      next = next_nonnote_insn (next);\n \t\t    }\n \t\t}\n-\t      prev = NULL_RTX;\n+\t      prev = NULL;\n \t    }\n \t  else\n \t    lp_simple = lp;\n@@ -5850,7 +5852,8 @@ arc_reorg (void)\n \t\t move exists.  */\n \t      if (true_regnum (begin_cnt) != LP_COUNT)\n \t\t{\n-\t\t  rtx mov, set, note;\n+\t\t  rtx_insn *mov;\n+\t\t  rtx set, note;\n \n \t\t  for (mov = prev_nonnote_insn (lp); mov;\n \t\t       mov = prev_nonnote_insn (mov))\n@@ -5902,16 +5905,16 @@ arc_reorg (void)\n \t\t\t\t   XEXP (XVECEXP (PATTERN (lp), 0, 3), 0),\n \t\t\t\t   const0_rtx);\n \n-\t\t  lc_set = emit_insn_before (lc_set, insn);\n+\t\t  rtx_insn *lc_set_insn = emit_insn_before (lc_set, insn);\n \t\t  delete_insn (lp);\n \t\t  delete_insn (insn);\n-\t\t  insn = lc_set;\n+\t\t  insn = lc_set_insn;\n \t\t}\n \t      /* If the loop is non-empty with zero length, we can't make it\n \t\t a zero-overhead loop.  That can happen for empty asms.  */\n \t      else\n \t\t{\n-\t\t  rtx scan;\n+\t\t  rtx_insn *scan;\n \n \t\t  for (scan = top_label;\n \t\t       (scan && scan != insn\n@@ -6064,7 +6067,8 @@ arc_reorg (void)\n \t  label = XEXP (pc_target, 1);\n \n \t    {\n-\t      rtx pat, scan, link_insn = NULL;\n+\t      rtx pat;\n+\t      rtx_insn *scan, *link_insn = NULL;\n \n \t      for (scan = PREV_INSN (insn);\n \t\t   scan && GET_CODE (scan) != CODE_LABEL;\n@@ -7804,7 +7808,7 @@ arc_adjust_insn_length (rtx insn, int len, bool)\n      loop.  */\n   if (recog_memoized (insn) == CODE_FOR_doloop_end_i)\n     {\n-      rtx prev = prev_nonnote_insn (insn);\n+      rtx_insn *prev = prev_nonnote_insn (insn);\n \n       return ((LABEL_P (prev)\n \t       || (TARGET_ARC600\n@@ -7834,7 +7838,7 @@ arc_adjust_insn_length (rtx insn, int len, bool)\n     }\n   if (TARGET_ARC600)\n     {\n-      rtx succ = next_real_insn (insn);\n+      rtx_insn *succ = next_real_insn (insn);\n \n       /* One the ARC600, a write to an extension register must be separated\n \t from a read.  */\n@@ -7953,7 +7957,7 @@ arc_get_insn_variants (rtx insn, int len, bool, bool target_p,\n   /* If the previous instruction is an sfunc call, this insn is always\n      a target, even though the middle-end is unaware of this.  */\n   bool force_target = false;\n-  rtx prev = prev_active_insn (insn);\n+  rtx_insn *prev = prev_active_insn (insn);\n   if (prev && arc_next_active_insn (prev, 0) == insn\n       && ((NONJUMP_INSN_P (prev) && GET_CODE (PATTERN (prev)) == SEQUENCE)\n \t  ? CALL_ATTR (XVECEXP (PATTERN (prev), 0, 0), NON_SIBCALL)\n@@ -8228,7 +8232,7 @@ arc_ifcvt (void)\n   basic_block merge_bb = 0;\n \n   memset (statep, 0, sizeof *statep);\n-  for (rtx insn = get_insns (); insn; insn = next_insn (insn))\n+  for (rtx_insn *insn = get_insns (); insn; insn = next_insn (insn))\n     {\n       arc_ccfsm_advance (insn, statep);\n \n@@ -8247,7 +8251,7 @@ arc_ifcvt (void)\n \t      = BLOCK_FOR_INSN (NEXT_INSN (NEXT_INSN (PREV_INSN (insn))));\n \t    arc_ccfsm_post_advance (insn, statep);\n \t    gcc_assert (!IN_RANGE (statep->state, 1, 2));\n-\t    rtx seq = NEXT_INSN (PREV_INSN (insn));\n+\t    rtx_insn *seq = NEXT_INSN (PREV_INSN (insn));\n \t    if (seq != insn)\n \t      {\n \t\trtx slot = XVECEXP (PATTERN (seq), 0, 1);\n@@ -8302,7 +8306,8 @@ arc_ifcvt (void)\n \n \t  /* Conditionalized insn.  */\n \n-\t  rtx prev, pprev, *patp, pat, cond;\n+\t  rtx_insn *prev, *pprev;\n+\t  rtx *patp, pat, cond;\n \t  bool annulled; annulled = false;\n \n \t  /* If this is a delay slot insn in a non-annulled branch,\n@@ -8347,7 +8352,7 @@ arc_ifcvt (void)\n \t    gcc_unreachable ();\n \t  if (JUMP_P (insn))\n \t    {\n-\t      rtx next = next_nonnote_insn (insn);\n+\t      rtx_insn *next = next_nonnote_insn (insn);\n \t      if (GET_CODE (next) == BARRIER)\n \t\tdelete_insn (next);\n \t      if (statep->state == 3)\n@@ -8368,7 +8373,7 @@ arc_ifcvt (void)\n static unsigned\n arc_predicate_delay_insns (void)\n {\n-  for (rtx insn = get_insns (); insn; insn = NEXT_INSN (insn))\n+  for (rtx_insn *insn = get_insns (); insn; insn = NEXT_INSN (insn))\n     {\n       rtx pat, jump, dlay, src, cond, *patp;\n       int reverse;\n@@ -8652,7 +8657,7 @@ void\n arc_pad_return (void)\n {\n   rtx_insn *insn = current_output_insn;\n-  rtx prev = prev_active_insn (insn);\n+  rtx_insn *prev = prev_active_insn (insn);\n   int want_long;\n \n   if (!prev)\n@@ -8693,7 +8698,7 @@ arc_pad_return (void)\n \t      || !reg_set_p (gen_rtx_REG (CCmode, CC_REG),\n \t\t\t     XVECEXP (final_sequence, 0, 1))))\n \t{\n-\t  prev = XVECEXP (final_sequence, 0, 1);\n+\t  prev = as_a <rtx_insn *> (XVECEXP (final_sequence, 0, 1));\n \t  gcc_assert (!prev_real_insn (insn)\n \t\t      || !arc_hazard (prev_real_insn (insn), prev));\n \t  cfun->machine->force_short_suffix = !want_long;\n@@ -9030,7 +9035,7 @@ arc_split_move (rtx *operands)\n    and l_tmpl (for long INSNs).  */\n \n const char *\n-arc_short_long (rtx insn, const char *s_tmpl, const char *l_tmpl)\n+arc_short_long (rtx_insn *insn, const char *s_tmpl, const char *l_tmpl)\n {\n   int is_short = arc_verify_short (insn, cfun->machine->unalign, -1);\n \n@@ -9099,9 +9104,9 @@ arc_sets_cc_p (rtx insn)\n    to fill.  */\n \n bool\n-arc_need_delay (rtx insn)\n+arc_need_delay (rtx_insn *insn)\n {\n-  rtx next;\n+  rtx_insn *next;\n \n   if (!flag_delayed_branch)\n     return false;\n@@ -9151,7 +9156,7 @@ arc_label_align (rtx label)\n \n   if (loop_align > align_labels_log)\n     {\n-      rtx prev = prev_nonnote_insn (label);\n+      rtx_insn *prev = prev_nonnote_insn (label);\n \n       if (prev && NONJUMP_INSN_P (prev)\n \t  && GET_CODE (PATTERN (prev)) == PARALLEL\n@@ -9162,7 +9167,7 @@ arc_label_align (rtx label)\n      ADDR_DIFF_VEC.  */\n   if (align_labels_log < 1)\n     {\n-      rtx next = next_nonnote_nondebug_insn (label);\n+      rtx_insn *next = next_nonnote_nondebug_insn (label);\n       if (INSN_P (next) && recog_memoized (next) >= 0)\n \treturn 1;\n     }\n@@ -9174,7 +9179,7 @@ arc_label_align (rtx label)\n bool\n arc_text_label (rtx label)\n {\n-  rtx next;\n+  rtx_insn *next;\n \n   /* ??? We use deleted labels like they were still there, see\n      gcc.c-torture/compile/20000326-2.c .  */"}]}