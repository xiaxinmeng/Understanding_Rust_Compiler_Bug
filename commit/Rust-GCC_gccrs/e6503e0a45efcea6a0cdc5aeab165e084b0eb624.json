{"sha": "e6503e0a45efcea6a0cdc5aeab165e084b0eb624", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTY1MDNlMGE0NWVmY2VhNmEwY2RjNWFlYWIxNjVlMDg0YjBlYjYyNA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2015-10-19T14:00:28Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2015-10-19T14:00:28Z"}, "message": "re PR tree-optimization/67975 (Failure to optimise equality between two call sequences)\n\n2015-10-19  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/67975\n\t* tree-cfg.h (extract_true_false_controlled_edges): Declare.\n\t* tree-cfg.c (extract_true_false_controlled_edges): Split out\n\tcore worker from ...\n\t* tree-ssa-loop-im.c (extract_true_false_args_from_phi): ... here.\n\t* tree-ssa-sccvn.c (vn_phi_compute_hash): Hash number of args\n\tinstead of block number for PHIs with two or one args.\n\t(vn_phi_eq): Compare edge predicates of PHIs that are in different\n\tblocks.\n\n\t* gcc.dg/tree-ssa/ssa-fre-50.c: New testcase.\n\nFrom-SVN: r228971", "tree": {"sha": "075dea0c963d70dcf98b41407036d2fb506b1b92", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/075dea0c963d70dcf98b41407036d2fb506b1b92"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e6503e0a45efcea6a0cdc5aeab165e084b0eb624", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6503e0a45efcea6a0cdc5aeab165e084b0eb624", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e6503e0a45efcea6a0cdc5aeab165e084b0eb624", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6503e0a45efcea6a0cdc5aeab165e084b0eb624/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4534c2032ba23be0a1f6b74ea2e23bc94df0cb81", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4534c2032ba23be0a1f6b74ea2e23bc94df0cb81", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4534c2032ba23be0a1f6b74ea2e23bc94df0cb81"}], "stats": {"total": 260, "additions": 196, "deletions": 64}, "files": [{"sha": "89a42c141be64bbd6483493aa505e0876af5ad9a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6503e0a45efcea6a0cdc5aeab165e084b0eb624/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6503e0a45efcea6a0cdc5aeab165e084b0eb624/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e6503e0a45efcea6a0cdc5aeab165e084b0eb624", "patch": "@@ -1,3 +1,15 @@\n+2015-10-19  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/67975\n+\t* tree-cfg.h (extract_true_false_controlled_edges): Declare.\n+\t* tree-cfg.c (extract_true_false_controlled_edges): Split out\n+\tcore worker from ...\n+\t* tree-ssa-loop-im.c (extract_true_false_args_from_phi): ... here.\n+\t* tree-ssa-sccvn.c (vn_phi_compute_hash): Hash number of args\n+\tinstead of block number for PHIs with two or one args.\n+\t(vn_phi_eq): Compare edge predicates of PHIs that are in different\n+\tblocks.\n+\n 2015-10-19  Richard Biener  <rguenther@suse.de>\n \n \t* gimple-fold.c (gimple_phi_nonnegative_warnv_p): New function."}, {"sha": "c4e96a7bc799758fd996d4815b3f4a48b7219da5", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6503e0a45efcea6a0cdc5aeab165e084b0eb624/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6503e0a45efcea6a0cdc5aeab165e084b0eb624/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e6503e0a45efcea6a0cdc5aeab165e084b0eb624", "patch": "@@ -1,3 +1,8 @@\n+2015-10-19  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/67975\n+\t* gcc.dg/tree-ssa/ssa-fre-50.c: New testcase.\n+\n 2015-10-19  Richard Biener  <rguenther@suse.de>\n \n \t* gcc.dg/torture/builtin-cproj-1.c: Skip for -O0."}, {"sha": "9155f8c7e8c4c8ae369a8d6dfd636b173867b500", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-50.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6503e0a45efcea6a0cdc5aeab165e084b0eb624/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-50.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6503e0a45efcea6a0cdc5aeab165e084b0eb624/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-50.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-50.c?ref=e6503e0a45efcea6a0cdc5aeab165e084b0eb624", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -ffinite-math-only -fdump-tree-fre1\" } */\n+\n+extern double cos (double);\n+extern double tan (double);\n+\n+int\n+f1 (double x, double y)\n+{\n+  double z1 = cos(y<10 ? x : tan(x<20 ? x : y));\n+  double z2 = cos(y<10 ? x : tan(x<20 ? x : y));\n+  return z1 == z2;\n+}\n+\n+/* { dg-final { scan-tree-dump \"return 1;\" \"fre1\" } } */"}, {"sha": "5bf546e59e46a71640f41f48e00691c16295a8b5", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6503e0a45efcea6a0cdc5aeab165e084b0eb624/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6503e0a45efcea6a0cdc5aeab165e084b0eb624/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=e6503e0a45efcea6a0cdc5aeab165e084b0eb624", "patch": "@@ -8532,6 +8532,75 @@ extract_true_false_edges_from_block (basic_block b,\n     }\n }\n \n+\n+/* From a controlling predicate in the immediate dominator DOM of\n+   PHIBLOCK determine the edges into PHIBLOCK that are chosen if the\n+   predicate evaluates to true and false and store them to\n+   *TRUE_CONTROLLED_EDGE and *FALSE_CONTROLLED_EDGE if\n+   they are non-NULL.  Returns true if the edges can be determined,\n+   else return false.  */\n+\n+bool\n+extract_true_false_controlled_edges (basic_block dom, basic_block phiblock,\n+\t\t\t\t     edge *true_controlled_edge,\n+\t\t\t\t     edge *false_controlled_edge)\n+{\n+  basic_block bb = phiblock;\n+  edge true_edge, false_edge, tem;\n+  edge e0 = NULL, e1 = NULL;\n+\n+  /* We have to verify that one edge into the PHI node is dominated\n+     by the true edge of the predicate block and the other edge\n+     dominated by the false edge.  This ensures that the PHI argument\n+     we are going to take is completely determined by the path we\n+     take from the predicate block.\n+     We can only use BB dominance checks below if the destination of\n+     the true/false edges are dominated by their edge, thus only\n+     have a single predecessor.  */\n+  extract_true_false_edges_from_block (dom, &true_edge, &false_edge);\n+  tem = EDGE_PRED (bb, 0);\n+  if (tem == true_edge\n+      || (single_pred_p (true_edge->dest)\n+\t  && (tem->src == true_edge->dest\n+\t      || dominated_by_p (CDI_DOMINATORS,\n+\t\t\t\t tem->src, true_edge->dest))))\n+    e0 = tem;\n+  else if (tem == false_edge\n+\t   || (single_pred_p (false_edge->dest)\n+\t       && (tem->src == false_edge->dest\n+\t\t   || dominated_by_p (CDI_DOMINATORS,\n+\t\t\t\t      tem->src, false_edge->dest))))\n+    e1 = tem;\n+  else\n+    return false;\n+  tem = EDGE_PRED (bb, 1);\n+  if (tem == true_edge\n+      || (single_pred_p (true_edge->dest)\n+\t  && (tem->src == true_edge->dest\n+\t      || dominated_by_p (CDI_DOMINATORS,\n+\t\t\t\t tem->src, true_edge->dest))))\n+    e0 = tem;\n+  else if (tem == false_edge\n+\t   || (single_pred_p (false_edge->dest)\n+\t       && (tem->src == false_edge->dest\n+\t\t   || dominated_by_p (CDI_DOMINATORS,\n+\t\t\t\t      tem->src, false_edge->dest))))\n+    e1 = tem;\n+  else\n+    return false;\n+  if (!e0 || !e1)\n+    return false;\n+\n+  if (true_controlled_edge)\n+    *true_controlled_edge = e0;\n+  if (false_controlled_edge)\n+    *false_controlled_edge = e1;\n+\n+  return true;\n+}\n+\n+\n+\n /* Emit return warnings.  */\n \n namespace {"}, {"sha": "1bfa5c4b11da56ce345296dd7500e7f1fe46e725", "filename": "gcc/tree-cfg.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6503e0a45efcea6a0cdc5aeab165e084b0eb624/gcc%2Ftree-cfg.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6503e0a45efcea6a0cdc5aeab165e084b0eb624/gcc%2Ftree-cfg.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.h?ref=e6503e0a45efcea6a0cdc5aeab165e084b0eb624", "patch": "@@ -105,5 +105,7 @@ extern unsigned int execute_fixup_cfg (void);\n extern unsigned int split_critical_edges (void);\n extern basic_block insert_cond_bb (basic_block, gimple *, gimple *);\n extern bool gimple_find_sub_bbs (gimple_seq, gimple_stmt_iterator *);\n+extern bool extract_true_false_controlled_edges (basic_block, basic_block,\n+\t\t\t\t\t\t edge *, edge *);\n \n #endif /* _TREE_CFG_H  */"}, {"sha": "0598c182f413c7fc8c15cb79970890e1d6c65f6c", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 5, "deletions": 46, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6503e0a45efcea6a0cdc5aeab165e084b0eb624/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6503e0a45efcea6a0cdc5aeab165e084b0eb624/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=e6503e0a45efcea6a0cdc5aeab165e084b0eb624", "patch": "@@ -619,56 +619,15 @@ static bool\n extract_true_false_args_from_phi (basic_block dom, gphi *phi,\n \t\t\t\t  tree *true_arg_p, tree *false_arg_p)\n {\n-  basic_block bb = gimple_bb (phi);\n-  edge true_edge, false_edge, tem;\n-  tree arg0 = NULL_TREE, arg1 = NULL_TREE;\n-\n-  /* We have to verify that one edge into the PHI node is dominated\n-     by the true edge of the predicate block and the other edge\n-     dominated by the false edge.  This ensures that the PHI argument\n-     we are going to take is completely determined by the path we\n-     take from the predicate block.\n-     We can only use BB dominance checks below if the destination of\n-     the true/false edges are dominated by their edge, thus only\n-     have a single predecessor.  */\n-  extract_true_false_edges_from_block (dom, &true_edge, &false_edge);\n-  tem = EDGE_PRED (bb, 0);\n-  if (tem == true_edge\n-      || (single_pred_p (true_edge->dest)\n-\t  && (tem->src == true_edge->dest\n-\t      || dominated_by_p (CDI_DOMINATORS,\n-\t\t\t\t tem->src, true_edge->dest))))\n-    arg0 = PHI_ARG_DEF (phi, tem->dest_idx);\n-  else if (tem == false_edge\n-\t   || (single_pred_p (false_edge->dest)\n-\t       && (tem->src == false_edge->dest\n-\t\t   || dominated_by_p (CDI_DOMINATORS,\n-\t\t\t\t      tem->src, false_edge->dest))))\n-    arg1 = PHI_ARG_DEF (phi, tem->dest_idx);\n-  else\n-    return false;\n-  tem = EDGE_PRED (bb, 1);\n-  if (tem == true_edge\n-      || (single_pred_p (true_edge->dest)\n-\t  && (tem->src == true_edge->dest\n-\t      || dominated_by_p (CDI_DOMINATORS,\n-\t\t\t\t tem->src, true_edge->dest))))\n-    arg0 = PHI_ARG_DEF (phi, tem->dest_idx);\n-  else if (tem == false_edge\n-\t   || (single_pred_p (false_edge->dest)\n-\t       && (tem->src == false_edge->dest\n-\t\t   || dominated_by_p (CDI_DOMINATORS,\n-\t\t\t\t      tem->src, false_edge->dest))))\n-    arg1 = PHI_ARG_DEF (phi, tem->dest_idx);\n-  else\n-    return false;\n-  if (!arg0 || !arg1)\n+  edge te, fe;\n+  if (! extract_true_false_controlled_edges (dom, gimple_bb (phi),\n+\t\t\t\t\t     &te, &fe))\n     return false;\n \n   if (true_arg_p)\n-    *true_arg_p = arg0;\n+    *true_arg_p = PHI_ARG_DEF (phi, te->dest_idx);\n   if (false_arg_p)\n-    *false_arg_p = arg1;\n+    *false_arg_p = PHI_ARG_DEF (phi, fe->dest_idx);\n \n   return true;\n }"}, {"sha": "c57fb259f033f3e63bbf6b1cdffdffd6beeb7a22", "filename": "gcc/tree-ssa-sccvn.c", "status": "modified", "additions": 88, "deletions": 18, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6503e0a45efcea6a0cdc5aeab165e084b0eb624/gcc%2Ftree-ssa-sccvn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6503e0a45efcea6a0cdc5aeab165e084b0eb624/gcc%2Ftree-ssa-sccvn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.c?ref=e6503e0a45efcea6a0cdc5aeab165e084b0eb624", "patch": "@@ -2658,7 +2658,8 @@ vn_nary_op_insert_stmt (gimple *stmt, tree result)\n static inline hashval_t\n vn_phi_compute_hash (vn_phi_t vp1)\n {\n-  inchash::hash hstate (vp1->block->index);\n+  inchash::hash hstate (vp1->phiargs.length () > 2\n+\t\t\t? vp1->block->index : vp1->phiargs.length ());\n   tree phi1op;\n   tree type;\n   edge e;\n@@ -2685,6 +2686,7 @@ vn_phi_compute_hash (vn_phi_t vp1)\n   return hstate.end ();\n }\n \n+\n /* Compare two phi entries for equality, ignoring VN_TOP arguments.  */\n \n static int\n@@ -2693,29 +2695,97 @@ vn_phi_eq (const_vn_phi_t const vp1, const_vn_phi_t const vp2)\n   if (vp1->hashcode != vp2->hashcode)\n     return false;\n \n-  if (vp1->block == vp2->block)\n+  if (vp1->block != vp2->block)\n     {\n-      int i;\n-      tree phi1op;\n-\n-      /* If the PHI nodes do not have compatible types\n-\t they are not the same.  */\n-      if (!types_compatible_p (vp1->type, vp2->type))\n+      if (vp1->phiargs.length () != vp2->phiargs.length ())\n \treturn false;\n \n-      /* Any phi in the same block will have it's arguments in the\n-\t same edge order, because of how we store phi nodes.  */\n-      FOR_EACH_VEC_ELT (vp1->phiargs, i, phi1op)\n+      switch (vp1->phiargs.length ())\n \t{\n-\t  tree phi2op = vp2->phiargs[i];\n-\t  if (phi1op == VN_TOP || phi2op == VN_TOP)\n-\t    continue;\n-\t  if (!expressions_equal_p (phi1op, phi2op))\n-\t    return false;\n+\tcase 1:\n+\t  /* Single-arg PHIs are just copies.  */\n+\t  break;\n+\n+\tcase 2:\n+\t  {\n+\t    /* Rule out backedges into the PHI.  */\n+\t    if (vp1->block->loop_father->header == vp1->block\n+\t\t|| vp2->block->loop_father->header == vp2->block)\n+\t      return false;\n+\n+\t    /* If the PHI nodes do not have compatible types\n+\t       they are not the same.  */\n+\t    if (!types_compatible_p (vp1->type, vp2->type))\n+\t      return false;\n+\n+\t    basic_block idom1\n+\t      = get_immediate_dominator (CDI_DOMINATORS, vp1->block);\n+\t    basic_block idom2\n+\t      = get_immediate_dominator (CDI_DOMINATORS, vp2->block);\n+\t    /* If the immediate dominator end in switch stmts multiple\n+\t       values may end up in the same PHI arg via intermediate\n+\t       CFG merges.  */\n+\t    if (EDGE_COUNT (idom1->succs) != 2\n+\t\t|| EDGE_COUNT (idom2->succs) != 2)\n+\t      return false;\n+\n+\t    /* Verify the controlling stmt is the same.  */\n+\t    gimple *last1 = last_stmt (idom1);\n+\t    gimple *last2 = last_stmt (idom2);\n+\t    if (gimple_code (last1) != GIMPLE_COND\n+\t\t|| gimple_code (last2) != GIMPLE_COND)\n+\t      return false;\n+\t    gcond *cond1 = as_a <gcond *> (last1);\n+\t    gcond *cond2 = as_a <gcond *> (last2);\n+\t    if (gimple_cond_code (cond1) != gimple_cond_code (cond2)\n+\t\t|| ! expressions_equal_p (gimple_cond_lhs (cond1),\n+\t\t\t\t       gimple_cond_lhs (cond2))\n+\t\t|| ! expressions_equal_p (gimple_cond_rhs (cond1),\n+\t\t\t\t\t  gimple_cond_rhs (cond2)))\n+\t      return false;\n+\n+\t    /* Get at true/false controlled edges into the PHI.  */\n+\t    edge te1, te2, fe1, fe2;\n+\t    if (! extract_true_false_controlled_edges (idom1, vp1->block,\n+\t\t\t\t\t\t       &te1, &fe1)\n+\t\t|| ! extract_true_false_controlled_edges (idom2, vp2->block,\n+\t\t\t\t\t\t\t  &te2, &fe2))\n+\t      return false;\n+\n+\t    /* ???  Handle VN_TOP specially.  */\n+\t    if (! expressions_equal_p (vp1->phiargs[te1->dest_idx],\n+\t\t\t\t       vp2->phiargs[te2->dest_idx])\n+\t\t|| ! expressions_equal_p (vp1->phiargs[fe1->dest_idx],\n+\t\t\t\t\t  vp2->phiargs[fe2->dest_idx]))\n+\t      return false;\n+\n+\t    return true;\n+\t  }\n+\n+\tdefault:\n+\t  return false;\n \t}\n-      return true;\n     }\n-  return false;\n+\n+  /* If the PHI nodes do not have compatible types\n+     they are not the same.  */\n+  if (!types_compatible_p (vp1->type, vp2->type))\n+    return false;\n+\n+  /* Any phi in the same block will have it's arguments in the\n+     same edge order, because of how we store phi nodes.  */\n+  int i;\n+  tree phi1op;\n+  FOR_EACH_VEC_ELT (vp1->phiargs, i, phi1op)\n+    {\n+      tree phi2op = vp2->phiargs[i];\n+      if (phi1op == VN_TOP || phi2op == VN_TOP)\n+\tcontinue;\n+      if (!expressions_equal_p (phi1op, phi2op))\n+\treturn false;\n+    }\n+\n+  return true;\n }\n \n static vec<tree> shared_lookup_phiargs;"}]}