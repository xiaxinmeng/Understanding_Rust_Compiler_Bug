{"sha": "756506468674bd03d9a3b8fa25f8b33bd49878b3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzU2NTA2NDY4Njc0YmQwM2Q5YTNiOGZhMjVmOGIzM2JkNDk4NzhiMw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mmitchell@usa.net", "date": "1998-01-19T22:41:40Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1998-01-19T22:41:40Z"}, "message": "decl.c (start_decl): Don't allow duplicate definitions of static data members.\n\n\t* decl.c (start_decl): Don't allow duplicate definitions of static\n\tdata members.\n\t* call.c (build_user_type_conversion_1): Handle user-defined\n\ttemplate conversion operators correctly.\n\t* decl2.c (build_expr_from_tree): Issue an error message if the\n\tobject in a COMPONENT_REF is a TEMPLATE_DECL.\n\t* typeck.c (incomplete_type_error): Handle TEMPLATE_TYPE_PARMs.\n\t* class.c (is_local_class): New function.\n\t* cp-tree.h (is_local_class): Declare it.\n\t(last_tree): Likewise.\n\t(begin_tree): Likewise.\n\t(end_tree): Likewise.\n\t(lookup_template_class): Change prototype.\n\t* decl.c (cp_finish_decl): Check for NULL where necesary.\n\tConsider FUNCTION_DECLS to declare objects with top-level binding,\n\twhen calling make_decl_rtl.\n\t(grokdeclarator): Give members of local classes internal linkage.\n\t(start_function): Remove declaration of last_tree.\n\t(finish_function): Set flag_keep_inline_functions around call to\n\trest_of_compilation if we are processing a member function in a\n\tlocal class.\n\t(start_method): Call push_template_decl for member functions of\n\tlocal classes in template functions.\n\t* decl2.c (import_export_decl): Don't give external linkage to\n\tinstantiations of templates with internal linkage.\n\t* parse.y (last_tree): Remove declaration.\n\t(template_type): Pass extra parameter to lookup_template_class.\n\t(self_template_type): Likewise.\n\t(structsp): Move call to reset_specialization into left_curly.\n\t(left_curly): Call reset_specialization, and begin_tree.\n\t* pt.c (saved_trees): New variable.\n\t(mangle_class_name_for_template): Change prototype.  Use\n\tadditional function context to name local classes in templates\n\tcorrectly.\n\t(classtype_mangled_name): Pass the context.\n\t(push_template_decl): Handle local classes and templates, and\n\tmember functions for such classes.\n\t(convert_nontype_parameter): Fix handling of pointer-to-member\n\tconstants.\n\t(lookup_template_class): Handle local classes in templates.\n\t(tsubst): Likewise.  Don't assume that template instantiations\n\thave external linkage; pay attention to the template declaration.\n\t(mark_decl_instantiated): Likewise.\n\t(begin_tree): New function.\n\t(end_tree): Likewise.\n\t* decl.c (xref_basetypes): Don't call complete_type for basetypes\n\tthat involve template parameters; that can lead to infinite\n\trecursion unnecessarily.\n\t* pt.c (register_specialization): Do not register specializations\n\tthat aren't ready to be registered yet.\n\t(check_explicit_specialization): Handle explicit specialization of\n\tconstructors and destructors.\n\t(build_template_decl): New function.\n\t(push_template_delc): Handle out-of-class specializations of\n\tmember templates.\n        * pt.c (check_explicit_specialization): Set up the template\n        information before registering the specialization.\n        (coerce_template_parms): Fix thinko.\n        (tsubst): Handle specializations of member templates correctly.\n\t* class.c (finish_struct_methods): Remove calls to\n\tcheck_explicit_specialization from here.\n\t(finish_struct): And insert them here.\n\t* cp-tree.h (perform_qualification_conversions): New function.\n\t(perform_array_to_pointer_conversion): Likewise.\n\t(begin_explicit_instantiation): Likewise.\n\t(end_explicit_instantiation): Likewise.\n\t(determine_specialization): Renamed from\n\tdetermine_explicit_specialization.\n\t(comp_template_parms): New function.\n\t(processing_explicit_instantiation): New variable.\n\t* cvt.c (perform_qualification_conversions): New function.\n\t(perform_array_to_pointer_conversion): Likewise.\n\t* decl.c (duplicate_decls): Don't consider template functions\n\talike unless they have the same parameters.  Refine handling of\n\tinstantiation/specialization mismatches.\n\t(start_decl): Don't call pushdecl for template specializations,\n\tsince they don't affect overloading.\n\t(start_function): Likewise\n\t(grokfndecl): Call check_explicit_specialization a little later.\n\tDon't call duplicate_decls for memberm template specializations.\n\t(grokdeclarator): Don't update template_count for classes that are\n\tthemselves specializations.  Remove use of `2' as parameter to\n\tgrokfndecl since that value isn't used.\n\t* lex.c (cons_up_default_function): Save and restore\n\tprocessing_explicit_instantiation around calls to grokfield.\n\t* parse.y (finish_member_template_decl): New function.\n\t(component_decl_1): Use it.\n\t(fn.def2): Likewise.\n\t(template_arg_list_opt): New nonterminal.\n\t(template_type): Use it.\n\t(self_template_type): Likewise.\n\t(template_id): Likewise.\n\t(object_template_id): Likewise.\n\t(notype_template_declarator): Likwise.\n\t(begin_explicit_instantiation): Likewise.\n\t(end_explicit_instantiation): Likewise.\n\t(explicit_instantiation): Use them.\n\t* pt.c (coerce_template_parms): Add parameters.\n\t(processing_explicit_instantiation): New variable.\n\t(convert_nontype_parameter): New function.\n\t(determine_overloaded_function): Likewise.\n\t(begin_explicit_instantiation): Likewise.\n\t(end_explicit_instantiation): Likewise.\n\t(retrieve_specialization): Likewise.\n\t(register_specialization): Likewise.\n\t(processing_explicit_specialization): Removed.\n\t(determine_specialization): Handle specializations of member\n\tfunctions of template class instantiations.\n\t(check_explicit_specialization): Refine to conform to standard.\n\t(comp_template_parms): New function.\n\t(coerce_template_parms): Call convert_nontype_parameter.\n\t(tsubst): Refine handling of member templates.  Use\n\tregister_specialization.\n\t(instantiate_template): Use retrieve_specialization.\n\t(do_decl_instantiation): Likewise.\n\t(instantiate_decl): Likewise.\n\t(type_unification): Improve handling of explict template\n\targuments.\n\t* tree.c (mapcar): Return error_mark_node, rather than aborting,\n\ton VAR_DECLS, FUNCTION_DECLS, and CONST_DECLS.\n\t* typeck.c (build_unary_op): Call determine_specialization, rather\n\tthan determine_explicit_specialization.\n\nFrom-SVN: r17426", "tree": {"sha": "dc2cfa2b2cd56480d694d16d1dfc486ff448d071", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dc2cfa2b2cd56480d694d16d1dfc486ff448d071"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/756506468674bd03d9a3b8fa25f8b33bd49878b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/756506468674bd03d9a3b8fa25f8b33bd49878b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/756506468674bd03d9a3b8fa25f8b33bd49878b3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/756506468674bd03d9a3b8fa25f8b33bd49878b3/comments", "author": null, "committer": null, "parents": [{"sha": "685885b773c21a431e87d59de0620b0098fc6dc2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/685885b773c21a431e87d59de0620b0098fc6dc2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/685885b773c21a431e87d59de0620b0098fc6dc2"}], "stats": {"total": 2476, "additions": 1884, "deletions": 592}, "files": [{"sha": "aa4b3cbbda50f603ca2f2efedeb278692d4d4c96", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/756506468674bd03d9a3b8fa25f8b33bd49878b3/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/756506468674bd03d9a3b8fa25f8b33bd49878b3/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=756506468674bd03d9a3b8fa25f8b33bd49878b3", "patch": "@@ -1,3 +1,136 @@\n+Mon Jan 19 22:40:03 1998  Mark Mitchell  <mmitchell@usa.net>\n+\n+\t* decl.c (start_decl): Don't allow duplicate definitions of static\n+\tdata members.\n+\n+\t* call.c (build_user_type_conversion_1): Handle user-defined\n+\ttemplate conversion operators correctly.\n+\n+\t* decl2.c (build_expr_from_tree): Issue an error message if the\n+\tobject in a COMPONENT_REF is a TEMPLATE_DECL.\n+\t\n+\t* typeck.c (incomplete_type_error): Handle TEMPLATE_TYPE_PARMs.\n+\t\n+\t* class.c (is_local_class): New function.\n+\t* cp-tree.h (is_local_class): Declare it.\n+\t(last_tree): Likewise.\n+\t(begin_tree): Likewise.\n+\t(end_tree): Likewise.\n+\t(lookup_template_class): Change prototype.\n+\t* decl.c (cp_finish_decl): Check for NULL where necesary.\n+\tConsider FUNCTION_DECLS to declare objects with top-level binding,\n+\twhen calling make_decl_rtl.\n+\t(grokdeclarator): Give members of local classes internal linkage.\n+\t(start_function): Remove declaration of last_tree.\n+\t(finish_function): Set flag_keep_inline_functions around call to\n+\trest_of_compilation if we are processing a member function in a\n+\tlocal class.\n+\t(start_method): Call push_template_decl for member functions of\n+\tlocal classes in template functions.\n+\t* decl2.c (import_export_decl): Don't give external linkage to\n+\tinstantiations of templates with internal linkage.\n+\t* parse.y (last_tree): Remove declaration.\n+\t(template_type): Pass extra parameter to lookup_template_class.\n+\t(self_template_type): Likewise.\n+\t(structsp): Move call to reset_specialization into left_curly.\n+\t(left_curly): Call reset_specialization, and begin_tree.\n+\t* pt.c (saved_trees): New variable.\n+\t(mangle_class_name_for_template): Change prototype.  Use\n+\tadditional function context to name local classes in templates\n+\tcorrectly. \n+\t(classtype_mangled_name): Pass the context.\n+\t(push_template_decl): Handle local classes and templates, and\n+\tmember functions for such classes.\n+\t(convert_nontype_parameter): Fix handling of pointer-to-member\n+\tconstants. \n+\t(lookup_template_class): Handle local classes in templates.\n+\t(tsubst): Likewise.  Don't assume that template instantiations\n+\thave external linkage; pay attention to the template declaration. \n+\t(mark_decl_instantiated): Likewise.\n+\t(begin_tree): New function.\n+\t(end_tree): Likewise.\n+\t\n+\t* decl.c (xref_basetypes): Don't call complete_type for basetypes\n+\tthat involve template parameters; that can lead to infinite\n+\trecursion unnecessarily.\n+\n+\t* pt.c (register_specialization): Do not register specializations\n+\tthat aren't ready to be registered yet.\n+\t(check_explicit_specialization): Handle explicit specialization of\n+\tconstructors and destructors.\n+\t(build_template_decl): New function.\n+\t(push_template_delc): Handle out-of-class specializations of\n+\tmember templates.\n+\t\n+        * pt.c (check_explicit_specialization): Set up the template\n+        information before registering the specialization.\n+        (coerce_template_parms): Fix thinko.\n+        (tsubst): Handle specializations of member templates correctly.\n+\n+\t* class.c (finish_struct_methods): Remove calls to\n+\tcheck_explicit_specialization from here.\n+\t(finish_struct): And insert them here.\n+\t* cp-tree.h (perform_qualification_conversions): New function.\n+\t(perform_array_to_pointer_conversion): Likewise.\n+\t(begin_explicit_instantiation): Likewise.\n+\t(end_explicit_instantiation): Likewise.\n+\t(determine_specialization): Renamed from\n+\tdetermine_explicit_specialization. \n+\t(comp_template_parms): New function.\n+\t(processing_explicit_instantiation): New variable.\n+\t* cvt.c (perform_qualification_conversions): New function.\n+\t(perform_array_to_pointer_conversion): Likewise.\n+\t* decl.c (duplicate_decls): Don't consider template functions\n+\talike unless they have the same parameters.  Refine handling of\n+\tinstantiation/specialization mismatches.\n+\t(start_decl): Don't call pushdecl for template specializations,\n+\tsince they don't affect overloading.\n+\t(start_function): Likewise\n+\t(grokfndecl): Call check_explicit_specialization a little later.\n+\tDon't call duplicate_decls for memberm template specializations.\n+\t(grokdeclarator): Don't update template_count for classes that are\n+\tthemselves specializations.  Remove use of `2' as parameter to\n+\tgrokfndecl since that value isn't used.\n+\t* lex.c (cons_up_default_function): Save and restore\n+\tprocessing_explicit_instantiation around calls to grokfield.\n+\t* parse.y (finish_member_template_decl): New function.\n+\t(component_decl_1): Use it.\n+\t(fn.def2): Likewise.\n+\t(template_arg_list_opt): New nonterminal.\t\n+\t(template_type): Use it.\n+\t(self_template_type): Likewise.\n+\t(template_id): Likewise.\n+\t(object_template_id): Likewise.\n+\t(notype_template_declarator): Likwise.\n+\t(begin_explicit_instantiation): Likewise.\n+\t(end_explicit_instantiation): Likewise.\n+\t(explicit_instantiation): Use them.\n+\t* pt.c (coerce_template_parms): Add parameters.\n+\t(processing_explicit_instantiation): New variable.\n+\t(convert_nontype_parameter): New function.\n+\t(determine_overloaded_function): Likewise.\n+\t(begin_explicit_instantiation): Likewise.\n+\t(end_explicit_instantiation): Likewise.\n+\t(retrieve_specialization): Likewise.\n+\t(register_specialization): Likewise.\n+\t(processing_explicit_specialization): Removed.\n+\t(determine_specialization): Handle specializations of member\n+\tfunctions of template class instantiations.\n+\t(check_explicit_specialization): Refine to conform to standard.\n+\t(comp_template_parms): New function.\n+\t(coerce_template_parms): Call convert_nontype_parameter.\n+\t(tsubst): Refine handling of member templates.  Use\n+\tregister_specialization. \n+\t(instantiate_template): Use retrieve_specialization.\n+\t(do_decl_instantiation): Likewise.\n+\t(instantiate_decl): Likewise.\n+\t(type_unification): Improve handling of explict template\n+\targuments. \n+\t* tree.c (mapcar): Return error_mark_node, rather than aborting,\n+\ton VAR_DECLS, FUNCTION_DECLS, and CONST_DECLS.\n+\t* typeck.c (build_unary_op): Call determine_specialization, rather\n+\tthan determine_explicit_specialization.\n+\n Mon Jan 19 13:18:51 1998  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* cvt.c (build_up_reference): A TARGET_EXPR has side effects."}, {"sha": "ca0e5b4d3e86296ab480e19e90952378649a7846", "filename": "gcc/cp/call.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/756506468674bd03d9a3b8fa25f8b33bd49878b3/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/756506468674bd03d9a3b8fa25f8b33bd49878b3/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=756506468674bd03d9a3b8fa25f8b33bd49878b3", "patch": "@@ -4356,8 +4356,11 @@ build_user_type_conversion_1 (totype, expr, flags)\n       if (TREE_CODE (totype) == REFERENCE_TYPE)\n \tconvflags |= LOOKUP_NO_TEMP_BIND;\n \n-      ics = implicit_conversion\n-\t(totype, TREE_TYPE (TREE_TYPE (fn)), 0, convflags);\n+      if (TREE_CODE (fn) != TEMPLATE_DECL)\n+\tics = implicit_conversion\n+\t  (totype, TREE_TYPE (TREE_TYPE (fn)), 0, convflags);\n+      else\n+\tics = implicit_conversion (totype, totype, 0, convflags);\n \n       if (TREE_CODE (totype) == REFERENCE_TYPE && ics && ICS_BAD_FLAG (ics))\n \t/* ignore the near match.  */;"}, {"sha": "7dd43f076581208f077f7edc0e9efba0ef892cdb", "filename": "gcc/cp/class.c", "status": "modified", "additions": 87, "deletions": 49, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/756506468674bd03d9a3b8fa25f8b33bd49878b3/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/756506468674bd03d9a3b8fa25f8b33bd49878b3/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=756506468674bd03d9a3b8fa25f8b33bd49878b3", "patch": "@@ -2107,53 +2107,6 @@ finish_struct_methods (t, fn_fields, nonprivate_method)\n \tobstack_free (current_obstack, baselink_vec);\n     }\n \n-  /* Now, figure out what any member template specializations were\n-     specializing.  */\n-  for (i = 0; i < TREE_VEC_LENGTH (method_vec); ++i)\n-    {\n-      tree fn;\n-      for (fn = TREE_VEC_ELT (method_vec, i);\n-\t   fn != NULL_TREE;\n-\t   fn = DECL_CHAIN (fn))\n-\tif (DECL_TEMPLATE_SPECIALIZATION (fn))\n-\t  {\n-\t    tree f;\n-\t    tree spec_args;\n-\n-\t    /* If there is a template, and t uses template parms, we\n-\t       are dealing with a specialization of a member\n-\t       template in a template class, and we must grab the\n-\t       template, rather than the function.  */\n-\t    if (DECL_TI_TEMPLATE (fn) && uses_template_parms (t))\n-\t      f = DECL_TI_TEMPLATE (fn);\n-\t    else\n-\t      f = fn;\n-\n-\t    /* We want the specialization arguments, which will be the\n-\t       innermost ones.  */\n-\t    if (DECL_TI_ARGS (f) \n-\t\t&& TREE_CODE (DECL_TI_ARGS (f)) == TREE_VEC)\n-\t      spec_args \n-\t\t= TREE_VEC_ELT (DECL_TI_ARGS (f), 0);\n-\t    else\n-\t      spec_args = DECL_TI_ARGS (f);\n-\t\t\n-\t    check_explicit_specialization \n-\t      (lookup_template_function (DECL_NAME (f), spec_args),\n-\t       f, 0, 1);\n-\n-\t    /* Now, the assembler name will be correct for fn, so we\n-\t       make its RTL.  */\n-\t    DECL_RTL (f) = 0;\n-\t    make_decl_rtl (f, NULL_PTR, 1);\n-\t    if (f != fn)\n-\t      {\n-\t\tDECL_RTL (fn) = 0;\n-\t\tmake_decl_rtl (fn, NULL_PTR, 1);\n-\t      }\n-\t  }\n-    }\n-\n   return method_vec;\n }\n \n@@ -4350,10 +4303,13 @@ finish_struct (t, list_of_fieldlists, attributes, warn_anon)\n {\n   tree fields = NULL_TREE;\n   tree *tail = &TYPE_METHODS (t);\n+  tree specializations = NULL_TREE;\n+  tree *specialization_tail = &specializations;\n   tree name = TYPE_NAME (t);\n   tree x, last_x = NULL_TREE;\n   tree access;\n   tree dummy = NULL_TREE;\n+  tree next_x = NULL_TREE;\n \n   if (TREE_CODE (name) == TYPE_DECL)\n     {\n@@ -4402,8 +4358,10 @@ finish_struct (t, list_of_fieldlists, attributes, warn_anon)\n \t    access = access_private_node;\n \t}\n \n-      for (x = TREE_VALUE (list_of_fieldlists); x; x = TREE_CHAIN (x))\n+      for (x = TREE_VALUE (list_of_fieldlists); x; x = next_x)\n \t{\n+\t  next_x = TREE_CHAIN (x);\n+\n \t  TREE_PRIVATE (x) = access == access_private_node;\n \t  TREE_PROTECTED (x) = access == access_protected_node;\n \n@@ -4441,8 +4399,23 @@ finish_struct (t, list_of_fieldlists, attributes, warn_anon)\n \t      || DECL_FUNCTION_TEMPLATE_P (x))\n \t    {\n \t      DECL_CLASS_CONTEXT (x) = t;\n+\n \t      if (last_x)\n-\t\tTREE_CHAIN (last_x) = TREE_CHAIN (x);\n+\t\tTREE_CHAIN (last_x) = next_x;\n+\n+\t      if (DECL_TEMPLATE_SPECIALIZATION (x))\n+\t\t/* We don't enter the specialization into the class\n+\t\t   method vector since specializations don't affect\n+\t\t   overloading.  Instead we keep track of the\n+\t\t   specializations, and process them after the method\n+\t\t   vector is complete.  */\n+\t\t{\n+\t\t  *specialization_tail = x;\n+\t\t  specialization_tail = &TREE_CHAIN (x);\n+\t\t  TREE_CHAIN (x) = NULL_TREE;\n+\t\t  continue;\n+\t\t}\n+\n \t      /* Link x onto end of TYPE_METHODS.  */\n \t      *tail = x;\n \t      tail = &TREE_CHAIN (x);\n@@ -4525,6 +4498,53 @@ finish_struct (t, list_of_fieldlists, attributes, warn_anon)\n \n   TYPE_BEING_DEFINED (t) = 0;\n \n+  /* Now, figure out what any member template specializations were\n+     specializing.  */\n+  for (x = specializations; x != NULL_TREE; x = TREE_CHAIN (x))\n+    {\n+      tree spec_args;\n+      tree fn;\n+\n+      if (uses_template_parms (t))\n+\t/* If t is a template class, and x is a specialization, then x\n+\t   is itself really a template.  Due to the vagaries of the\n+\t   parser, however, we will have a handle to a function\n+\t   declaration, rather than the template declaration, at this\n+\t   point.  */\n+\t{\n+\t  my_friendly_assert (DECL_TEMPLATE_INFO (x) != NULL_TREE, 0);\n+\t  my_friendly_assert (DECL_TI_TEMPLATE (x) != NULL_TREE, 0);\n+\t  fn = DECL_TI_TEMPLATE (x);\n+\t}\n+      else\n+\tfn = x;\n+\n+      /* We want the specialization arguments, which will be the\n+\t innermost ones.  */\n+      if (DECL_TI_ARGS (fn) && TREE_CODE (DECL_TI_ARGS (fn)) == TREE_VEC)\n+\tspec_args \n+\t  = TREE_VEC_ELT (DECL_TI_ARGS (fn), 0);\n+      else\n+\tspec_args = DECL_TI_ARGS (fn);\n+      \n+      check_explicit_specialization \n+\t(lookup_template_function (DECL_NAME (fn), spec_args),\n+\t fn, 0, 1 | (8 * (int) TREE_CHAIN (DECL_TEMPLATE_INFO (fn))));\n+\n+      TREE_CHAIN (DECL_TEMPLATE_INFO (fn)) = NULL_TREE;\n+\n+      /* Now, the assembler name will be correct for fn, so we\n+\t make its RTL.  */\n+      DECL_RTL (fn) = 0;\n+      make_decl_rtl (fn, NULL_PTR, 1);\n+\n+      if (x != fn)\n+\t{\n+\t  DECL_RTL (x) = 0;\n+\t  make_decl_rtl (x, NULL_PTR, 1);\n+\t}\n+    }\n+\n   if (current_class_type)\n     popclass (0);\n   else\n@@ -5484,3 +5504,21 @@ build_self_reference ()\n   pushdecl_class_level (value);\n   return value;\n }\n+\n+\n+/* Returns non-zero iff the TYPE is a local class; i.e., if it is\n+   declared in a function context, or within a local class.  */\n+\n+int\n+is_local_class (type)\n+     tree type;\n+{\n+  if (type == NULL_TREE || TYPE_CONTEXT (type) == NULL_TREE)\n+    return 0;\n+\n+  if (TREE_CODE (TYPE_CONTEXT (type)) == FUNCTION_DECL)\n+    return 1;\n+\n+  return is_local_class (TYPE_CONTEXT (type));\n+}\n+"}, {"sha": "73b185d331f579e2fd3ee1023e37c6e2dd7358ee", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/756506468674bd03d9a3b8fa25f8b33bd49878b3/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/756506468674bd03d9a3b8fa25f8b33bd49878b3/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=756506468674bd03d9a3b8fa25f8b33bd49878b3", "patch": "@@ -1539,6 +1539,7 @@ extern tree null_node;\n \n extern tree current_template_parms;\n extern HOST_WIDE_INT processing_template_decl;\n+extern tree last_tree;\n \n /* The template currently being instantiated, and where the instantiation\n    was triggered.  */\n@@ -1983,6 +1984,7 @@ extern void maybe_push_cache_obstack\t\tPROTO((void));\n extern unsigned HOST_WIDE_INT skip_rtti_stuff\tPROTO((tree *));\n extern tree build_self_reference\t\tPROTO((void));\n extern void warn_hidden\t\t\t\tPROTO((tree));\n+extern int is_local_class                       PROTO((tree));\n \n /* in cvt.c */\n extern tree convert_to_reference\t\tPROTO((tree, tree, int, int, tree));\n@@ -1998,6 +2000,8 @@ extern tree build_type_conversion\t\tPROTO((enum tree_code, tree, tree, int));\n extern tree build_expr_type_conversion\t\tPROTO((int, tree, int));\n extern int build_default_binary_type_conversion\tPROTO((enum tree_code, tree *, tree *));\n extern tree type_promotes_to\t\t\tPROTO((tree));\n+extern tree perform_qualification_conversions   PROTO((tree, tree));\n+extern tree perform_array_to_pointer_conversion PROTO((tree));\n \n /* decl.c */\n /* resume_binding_level */\n@@ -2317,14 +2321,16 @@ extern void begin_template_parm_list\t\tPROTO((void));\n extern void begin_specialization                PROTO((void));\n extern void reset_specialization                PROTO((void));\n extern void end_specialization                  PROTO((void));\n-extern tree determine_explicit_specialization   PROTO((tree, tree, tree *, int, int));\n-extern int check_explicit_specialization       PROTO((tree, tree, int, int));\n+extern void begin_explicit_instantiation        PROTO((void));\n+extern void end_explicit_instantiation          PROTO((void));\n+extern tree determine_specialization            PROTO((tree, tree, tree *, int, int));\n+extern int check_explicit_specialization        PROTO((tree, tree, int, int));\n extern tree process_template_parm\t\tPROTO((tree, tree));\n extern tree end_template_parm_list\t\tPROTO((tree));\n extern void end_template_decl\t\t\tPROTO((void));\n extern tree current_template_args\t\tPROTO((void));\n extern void push_template_decl\t\t\tPROTO((tree));\n-extern tree lookup_template_class\t\tPROTO((tree, tree, tree));\n+extern tree lookup_template_class\t\tPROTO((tree, tree, tree, tree));\n extern tree lookup_template_function            PROTO((tree, tree));\n extern int uses_template_parms\t\t\tPROTO((tree));\n extern tree instantiate_class_template\t\tPROTO((tree));\n@@ -2344,14 +2350,18 @@ extern tree do_poplevel\t\t\t\tPROTO((void));\n extern tree get_bindings\t\t\tPROTO((tree, tree));\n /* CONT ... */\n extern void add_tree\t\t\t\tPROTO((tree));\n+extern void begin_tree                          PROTO((void));\n+extern void end_tree                            PROTO((void));\n extern void add_maybe_template\t\t\tPROTO((tree, tree));\n extern void pop_tinst_level\t\t\tPROTO((void));\n extern tree most_specialized\t\t\tPROTO((tree, tree));\n extern tree most_specialized_class\t\tPROTO((tree, tree));\n extern int more_specialized_class\t\tPROTO((tree, tree));\n extern void do_pushlevel\t\t\tPROTO((void));\n extern int is_member_template                   PROTO((tree));\n+extern int comp_template_parms                  PROTO((tree, tree));\n extern int processing_specialization;\n+extern int processing_explicit_instantiation;\n \n /* in repo.c */\n extern void repo_template_used\t\t\tPROTO((tree));"}, {"sha": "341b83a46ac77f6337c90e4fa08040605ab61c5d", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/756506468674bd03d9a3b8fa25f8b33bd49878b3/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/756506468674bd03d9a3b8fa25f8b33bd49878b3/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=756506468674bd03d9a3b8fa25f8b33bd49878b3", "patch": "@@ -1682,3 +1682,134 @@ type_promotes_to (type)\n \n   return cp_build_type_variant (type, constp, volatilep);\n }\n+\n+\n+/* The routines below this point are carefully written to conform to\n+   the standard.  They use the same terminology, and follow the rules\n+   closely.  Although they are used only in pt.c at the moment, they\n+   should presumably be used everywhere in the future.  */\n+\n+tree \n+perform_qualification_conversions (type, expr)\n+     tree type;\n+     tree expr;\n+{\n+  tree expr_type = TREE_TYPE (expr);\n+  tree t1;\n+  tree t2;\n+  int j;\n+  int all_have_const = 1;\n+\n+  if (comptypes (type, expr_type, 1))\n+    /* The two types are already the same, so there is nothing to do.  */\n+    return expr;\n+\n+  j = 0;\n+  t1 = expr_type;\n+  t2 = type; \n+\n+  while (1)\n+    {\n+      if (TREE_CODE (type) != TREE_CODE (expr_type))\n+\treturn error_mark_node;\n+\n+      if (j > 0 \n+\t  && TREE_CODE (type) == POINTER_TYPE)\n+\t{\n+\t  if (TYPE_READONLY (t1) > TYPE_READONLY (t2)\n+\t      || TYPE_VOLATILE (t1) > TYPE_VOLATILE (t2))\n+\t    /* For every j>0, if const is in cv1,j the const is in\n+\t       cv2,j, and similarly for volatile.  */\n+\t    return error_mark_node;\n+\t}\n+\n+      if (!all_have_const \n+\t  && (TYPE_READONLY (t1) != TYPE_READONLY (t2)\n+\t      || TYPE_READONLY (t1) != TYPE_READONLY (t2)))\n+\t/* If the cv1,j and cv2,j are different, then const is in every\n+\t   cv2,k for 0<k<j.  */\n+\treturn error_mark_node;\n+\t\n+      if (j > 0 && !TYPE_READONLY (t2))\n+\tall_have_const = 0;\n+\n+      if (TREE_CODE (type) != POINTER_TYPE)\n+\t{\n+\t  if (j == 0)\n+\t    /* The two things to be converted weren't even pointer\n+\t       types.  */\n+\t    return error_mark_node;\n+\t  \n+\t  if (TYPE_PTRMEMFUNC_P (type))\n+\t    {\n+\t      t1 = TYPE_PTRMEMFUNC_FN_TYPE (t1);\n+\t      t2 = TYPE_PTRMEMFUNC_FN_TYPE (t2);\n+\t    }\n+\n+\t  if (comptypes (TYPE_MAIN_VARIANT (t1),\n+\t\t\t TYPE_MAIN_VARIANT (t2), 1))\n+\t    return build1 (NOP_EXPR, type, expr);\n+\t  else\n+\t    /* The pointers were not similar.  */\n+\t    return error_mark_node;\n+\t}\n+\n+      if (TYPE_PTRMEM_P (type) \n+\t  && !comptypes (TYPE_OFFSET_BASETYPE (TREE_TYPE (t1)),\n+\t\t\t TYPE_OFFSET_BASETYPE (TREE_TYPE (t2)),\n+\t\t\t 1))\n+\t/* One type is X::* and the other is Y::*.  */\n+\treturn error_mark_node;\n+\n+      if (TYPE_PTRMEM_P (type))\n+\t{\n+\t  t1 = TREE_TYPE (TREE_TYPE (t1));\n+\t  t2 = TREE_TYPE (TREE_TYPE (t2));\n+\t}\n+      else\n+\t{\n+\t  t1 = TREE_TYPE (t1);\n+\t  t2 = TREE_TYPE (t2);\n+\t}\n+    }\n+}\n+\n+\n+/* Perform array-to-pointer conversion on EXPR, if appropriate.\n+   Return the converted expression, or EXPR if no\n+   conversion was performed, or error_mark_node if the conversion was\n+   attempted, but failed.  (For example, if an attempt is made to take\n+   the address of a non-addressable object.)  */\n+\n+tree \n+perform_array_to_pointer_conversion (expr)\n+     tree expr;\n+{\n+  tree result = expr;\n+\n+  if (TREE_CODE (TREE_TYPE (expr)) == ARRAY_TYPE)\n+    {\n+      tree type = build_pointer_type (TREE_TYPE (TREE_TYPE (expr)));\n+      \n+      /* This section is copied from decay_conversion.  */\n+      if (TREE_CODE (expr) == VAR_DECL)\n+\t{\n+\t  /* ??? This is not really quite correct\n+\t     in that the type of the operand of ADDR_EXPR\n+\t     is not the target type of the type of the ADDR_EXPR itself.\n+\t     Question is, can this lossage be avoided?  */\n+\t  result = build1 (ADDR_EXPR, type, expr);\n+\t  if (mark_addressable (expr) == 0)\n+\t    return error_mark_node;\n+\t  TREE_CONSTANT (result) = staticp (expr);\n+\t  TREE_SIDE_EFFECTS (result) = 0; /* Default would be, same as\n+\t\t\t\t\t     EXPR.  */ \n+\t}\n+      else \n+\t/* This way is better for a COMPONENT_REF since it can\n+\t   simplify the offset for a component.  */\n+\tresult = build_unary_op (ADDR_EXPR, expr, 1);\n+    }\n+\n+  return result;\n+}"}, {"sha": "7bdc60706e91c0e3709b3cadbeda4d38b9948a5d", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 169, "deletions": 48, "changes": 217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/756506468674bd03d9a3b8fa25f8b33bd49878b3/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/756506468674bd03d9a3b8fa25f8b33bd49878b3/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=756506468674bd03d9a3b8fa25f8b33bd49878b3", "patch": "@@ -2529,7 +2529,9 @@ duplicate_decls (newdecl, olddecl)\n \t  else if (TREE_CODE (DECL_TEMPLATE_RESULT (olddecl)) == FUNCTION_DECL\n \t\t   && TREE_CODE (DECL_TEMPLATE_RESULT (newdecl)) == FUNCTION_DECL\n \t\t   && compparms (TYPE_ARG_TYPES (TREE_TYPE (DECL_TEMPLATE_RESULT (olddecl))),\n-\t\t\t\t TYPE_ARG_TYPES (TREE_TYPE (DECL_TEMPLATE_RESULT (newdecl))), 3))\n+\t\t\t\t TYPE_ARG_TYPES (TREE_TYPE (DECL_TEMPLATE_RESULT (newdecl))), 3)\n+\t\t   && comp_template_parms (DECL_TEMPLATE_PARMS (newdecl),\n+\t\t\t\t\t   DECL_TEMPLATE_PARMS (olddecl)))\n \t    {\n \t      cp_error (\"new declaration `%#D'\", newdecl);\n \t      cp_error_at (\"ambiguates old declaration `%#D'\", olddecl);\n@@ -2563,19 +2565,31 @@ duplicate_decls (newdecl, olddecl)\n \t  cp_error_at (\"previous declaration as `%#D'\", olddecl);\n \t}\n     }\n-  else if ((TREE_CODE (olddecl) == FUNCTION_DECL \n-\t    && DECL_TEMPLATE_SPECIALIZATION (olddecl)\n-\t    && (!DECL_TEMPLATE_SPECIALIZATION (newdecl)\n-\t\t|| (DECL_TI_TEMPLATE (newdecl) \n-\t\t    != DECL_TI_TEMPLATE (olddecl))))\n-\t   || (TREE_CODE (newdecl) == FUNCTION_DECL\n-\t       && DECL_TEMPLATE_SPECIALIZATION (newdecl)\n-\t       && (!DECL_TEMPLATE_SPECIALIZATION (olddecl)\n-\t\t   || (DECL_TI_TEMPLATE (olddecl) != DECL_TI_TEMPLATE\n-\t\t       (newdecl)))))\n+  else if (TREE_CODE (newdecl) == FUNCTION_DECL \n+\t    && ((DECL_TEMPLATE_SPECIALIZATION (olddecl)\n+\t\t && (!DECL_TEMPLATE_INFO (newdecl)\n+\t\t     || (DECL_TI_TEMPLATE (newdecl) \n+\t\t\t != DECL_TI_TEMPLATE (olddecl))))\n+\t\t|| (DECL_TEMPLATE_SPECIALIZATION (newdecl)\n+\t\t    && (!DECL_TEMPLATE_INFO (olddecl)\n+\t\t\t|| (DECL_TI_TEMPLATE (olddecl) \n+\t\t\t    != DECL_TI_TEMPLATE (newdecl))))))\n     /* It's OK to have a template specialization and a non-template\n        with the same type, or to have specializations of two\n-       different templates with the same type. */\n+       different templates with the same type.  Note that if one is a\n+       specialization, and the other is an instantiation of the same\n+       template, that we do not exit at this point.  That situation\n+       can occur if we instantiate a template class, and then\n+       specialize one of its methods.  This situation is legal, but\n+       the declarations must be merged in the usual way.  */\n+    return 0;\n+  else if (TREE_CODE (newdecl) == FUNCTION_DECL \n+\t   && ((DECL_TEMPLATE_INSTANTIATION (olddecl) \n+\t\t&& !DECL_USE_TEMPLATE (newdecl))\n+\t       || (DECL_TEMPLATE_INSTANTIATION (newdecl)\n+\t\t   && !DECL_USE_TEMPLATE (olddecl))))\n+    /* One of the declarations is a template instantiation, and the\n+       other is not a template at all.  That's OK.  */\n     return 0;\n   else\n     {\n@@ -2860,9 +2874,29 @@ duplicate_decls (newdecl, olddecl)\n \n   if (TREE_CODE (newdecl) == FUNCTION_DECL)\n     {\n-      if (DECL_TEMPLATE_INSTANTIATION (olddecl) &&\n-\t  !DECL_TEMPLATE_INSTANTIATION (newdecl)) \n-\tDECL_USE_TEMPLATE (olddecl) = DECL_USE_TEMPLATE (newdecl);\n+      if (DECL_TEMPLATE_INSTANTIATION (olddecl) \n+\t  && !DECL_TEMPLATE_INSTANTIATION (newdecl)) \n+\t{\n+\t  /* If newdecl is not a specialization, then it is not a\n+\t     template-related function at all.  And that means that we\n+\t     shoud have exited above, returning 0.  */\n+\t  my_friendly_assert (DECL_TEMPLATE_SPECIALIZATION (newdecl),\n+\t\t\t      0);\n+\n+\t  if (TREE_USED (olddecl)) \n+\t    /* From [temp.expl.spec]:\n+\t       \n+\t       If a template, a member template or the member of a class\n+\t       template is explicitly specialized then that\n+\t       specialization shall be declared before the first use of\n+\t       that specialization that would cause an implicit\n+\t       instantiation to take place, in every translation unit in\n+\t       which such a use occurs.  */\n+\t    cp_error (\"explicit specialization of %D after first use\", \n+\t\t      olddecl);\n+\n+\t  SET_DECL_TEMPLATE_SPECIALIZATION (olddecl);\n+\t}\n       DECL_THIS_INLINE (newdecl) |= DECL_THIS_INLINE (olddecl);\n \n       /* If either decl says `inline', this fn is inline, unless its\n@@ -2922,8 +2956,8 @@ duplicate_decls (newdecl, olddecl)\n \n   if (TREE_CODE (newdecl) == TEMPLATE_DECL)\n     {\n-      DECL_TEMPLATE_INSTANTIATIONS (newdecl)\n-\t= DECL_TEMPLATE_INSTANTIATIONS (olddecl);\n+      DECL_TEMPLATE_SPECIALIZATIONS (newdecl)\n+\t= DECL_TEMPLATE_SPECIALIZATIONS (olddecl);\n       if (DECL_CHAIN (newdecl) == NULL_TREE)\n \tDECL_CHAIN (newdecl) = DECL_CHAIN (olddecl);\n     }\n@@ -2965,6 +2999,38 @@ duplicate_decls (newdecl, olddecl)\n #define ROUND(x) ((x + obstack_alignment_mask (&permanent_obstack)) \\\n \t\t  & ~ obstack_alignment_mask (&permanent_obstack))\n \n+      if (DECL_TEMPLATE_INSTANTIATION (newdecl))\n+\t{\n+\t  /* If newdecl is a template instantiation, it is possible that\n+\t     the following sequence of events has occurred:\n+\n+\t     o A friend function was declared in a class template.  The\n+\t     class template was instantiated.  \n+\n+\t     o The instantiation of the friend declaration was \n+\t     recorded on the instantiation list, and is newdecl.  \n+\n+\t     o Later, however, instantiate_class_template called pushdecl\n+\t     on the newdecl to perform name injection.  But, pushdecl in\n+\t     turn called duplicate_decls when it discovered that another\n+\t     declaration of a global function with the same name already\n+\t     existed. \n+\n+\t     o Here, in duplicate_decls, we decided to clobber newdecl.\n+\n+\t     If we're going to do that, we'd better make sure that\n+\t     olddecl, and not newdecl, is on the list of\n+\t     instantiations so that if we try to do the instantiation\n+\t     again we won't get the clobbered declaration.  */\n+\n+\t  tree tmpl = DECL_TI_TEMPLATE (newdecl); \n+\t  tree decls = DECL_TEMPLATE_SPECIALIZATIONS (tmpl); \n+\n+\t  for (; decls; decls = TREE_CHAIN (decls))\n+\t    if (TREE_VALUE (decls) == newdecl)\n+\t      TREE_VALUE (decls) = olddecl;\n+\t}\n+\n       if ((char *)newdecl + ROUND (function_size)\n \t  + ROUND (sizeof (struct lang_decl))\n \t  == obstack_next_free (&permanent_obstack))\n@@ -6024,6 +6090,13 @@ start_decl (declarator, declspecs, initialized)\n \t\t\t      context, DECL_NAME (decl));\n \t\t  DECL_CONTEXT (decl) = DECL_CONTEXT (field);\n \t\t}\n+\t      /* Static data member are tricky; an in-class initialization\n+\t\t still doesn't provide a definition, so the in-class\n+\t\t declaration will have DECL_EXTERNAL set, but will have an\n+\t\t initialization.  Thus, duplicate_decls won't warn\n+\t\t about this situation, and so we check here.  */\n+\t      if (DECL_INITIAL (decl) && DECL_INITIAL (field))\n+\t\tcp_error (\"duplicate initialization of %D\", decl);\n \t      if (duplicate_decls (decl, field))\n \t\tdecl = field;\n \t    }\n@@ -6056,7 +6129,13 @@ start_decl (declarator, declspecs, initialized)\n   \n   if ((TREE_CODE (decl) != PARM_DECL && DECL_CONTEXT (decl) != NULL_TREE)\n       || (TREE_CODE (decl) == TEMPLATE_DECL && !global_bindings_p ())\n-      || TREE_CODE (type) == LANG_TYPE)\n+      || TREE_CODE (type) == LANG_TYPE\n+      /* The declaration of template specializations does not affect\n+\t the functions available for overload resolution, so we do not\n+\t call pushdecl.  */\n+      || (!flag_guiding_decls \n+\t  && TREE_CODE (decl) == FUNCTION_DECL\n+\t  && DECL_TEMPLATE_SPECIALIZATION (decl)))\n     tem = decl;\n   else\n     tem = pushdecl (decl);\n@@ -6397,9 +6476,12 @@ cp_finish_decl (decl, init, asmspec_tree, need_pop, flags)\n       if (minimal_parse_mode && ! DECL_ARTIFICIAL (decl))\n \t{\n \t  tree stmt = DECL_VINDEX (decl);\n-\t  DECL_VINDEX (decl) = NULL_TREE;\n-\t  TREE_OPERAND (stmt, 2) = copy_to_permanent (init);\n-\t  add_tree (stmt);\n+\t  if (stmt != NULL_TREE)\n+\t    {\n+\t      DECL_VINDEX (decl) = NULL_TREE;\n+\t      TREE_OPERAND (stmt, 2) = copy_to_permanent (init);\n+\t      add_tree (stmt);\n+\t    }\n \t}\n \n       goto finish_end0;\n@@ -6685,7 +6767,11 @@ cp_finish_decl (decl, init, asmspec_tree, need_pop, flags)\n       || TREE_CODE (decl) == RESULT_DECL)\n     {\n       /* ??? FIXME: What about nested classes?  */\n-      int toplev = toplevel_bindings_p () || pseudo_global_level_p ();\n+      /* We check for FUNCTION_DECL here so that member functions of\n+\t local classes, which will have internal linkage, are not\n+\t given bizarre names by make_decl_rtl.  */\n+      int toplev = toplevel_bindings_p () || pseudo_global_level_p ()\n+\t|| TREE_CODE (decl) == FUNCTION_DECL;\n       int was_temp\n \t= (TREE_STATIC (decl) && TYPE_NEEDS_DESTRUCTOR (type)\n \t   && allocation_temporary_p ());\n@@ -7367,12 +7453,12 @@ grokfndecl (ctype, type, declarator, orig_declarator, virtualp, flags, quals,\n \tbreak;\n       }\n \n-  /* Caller will do the rest of this.  */\n-  check_explicit_specialization (orig_declarator, decl,\n-\t\t\t\t template_count, \n-\t\t\t\t funcdef_flag ? 2 : \n-\t\t\t\t (friendp ? 3 : 0));\n+  if (friendp && \n+      TREE_CODE (orig_declarator) == TEMPLATE_ID_EXPR)\n+    /* A friend declaration of the form friend void f<>().  */\n+    SET_DECL_IMPLICIT_INSTANTIATION (decl);\n \n+  /* Caller will do the rest of this.  */\n   if (check < 0)\n     return decl;\n \n@@ -7391,6 +7477,11 @@ grokfndecl (ctype, type, declarator, orig_declarator, virtualp, flags, quals,\n \n       grokclassfn (ctype, declarator, decl, flags, quals);\n \n+      check_explicit_specialization (orig_declarator, decl,\n+\t\t\t\t     template_count, \n+\t\t\t\t     funcdef_flag ? 2 : \n+\t\t\t\t     (friendp ? 3 : 0));\n+\n       if (check)\n \t{\n \t  tmp = check_classfn (ctype, decl);\n@@ -7433,12 +7524,17 @@ grokfndecl (ctype, type, declarator, orig_declarator, virtualp, flags, quals,\n       if (ctype != NULL_TREE)\n \tgrokclassfn (ctype, cname, decl, flags, quals);\n \n+      check_explicit_specialization (orig_declarator, decl,\n+\t\t\t\t     template_count, \n+\t\t\t\t     funcdef_flag ? 2 : \n+\t\t\t\t     (friendp ? 3 : 0));\n+\n       if (ctype != NULL_TREE && check)\n \t{\n \t  tmp = check_classfn (ctype, decl);\n \n \t  if (tmp && TREE_CODE (tmp) == TEMPLATE_DECL)\n-\t    tmp = DECL_TEMPLATE_RESULT(tmp);\n+\t    tmp = DECL_TEMPLATE_RESULT (tmp);\n \t      \n \t  if (tmp && DECL_STATIC_FUNCTION_P (tmp)\n \t      && TREE_CODE (TREE_TYPE (decl)) == METHOD_TYPE)\n@@ -7466,19 +7562,27 @@ grokfndecl (ctype, type, declarator, orig_declarator, virtualp, flags, quals,\n \t methods, though.  */\n       if (! current_function_decl)\n \t{\n-\t  /* FIXME: this should only need to look at\n-             IDENTIFIER_GLOBAL_VALUE.  */\n-\t  tmp = lookup_name (DECL_ASSEMBLER_NAME (decl), 0);\n-\t  if (tmp == NULL_TREE)\n-\t    IDENTIFIER_GLOBAL_VALUE (DECL_ASSEMBLER_NAME (decl)) = decl;\n-\t  else if (TREE_CODE (tmp) != TREE_CODE (decl))\n-\t    cp_error (\"inconsistent declarations for `%D'\", decl);\n-\t  else\n+\t  if (!DECL_TEMPLATE_SPECIALIZATION (decl))\n \t    {\n-\t      duplicate_decls (decl, tmp);\n-\t      decl = tmp;\n-\t      /* avoid creating circularities.  */\n-\t      DECL_CHAIN (decl) = NULL_TREE;\n+\t      /* We don't do this for specializations since the\n+\t\t equivalent checks will be done later.  Also, at this\n+\t\t point the DECL_ASSEMBLER_NAME is not yet fully\n+\t\t accurate.  */\n+\n+\t      /* FIXME: this should only need to look at\n+\t\t IDENTIFIER_GLOBAL_VALUE.  */\n+\t      tmp = lookup_name (DECL_ASSEMBLER_NAME (decl), 0);\n+\t      if (tmp == NULL_TREE)\n+\t\tIDENTIFIER_GLOBAL_VALUE (DECL_ASSEMBLER_NAME (decl)) = decl;\n+\t      else if (TREE_CODE (tmp) != TREE_CODE (decl))\n+\t\tcp_error (\"inconsistent declarations for `%D'\", decl);\n+\t      else\n+\t\t{\n+\t\t  duplicate_decls (decl, tmp);\n+\t\t  decl = tmp;\n+\t\t  /* avoid creating circularities.  */\n+\t\t  DECL_CHAIN (decl) = NULL_TREE;\n+\t\t}\n \t    }\n \n \t  if (attrlist)\n@@ -9169,7 +9273,8 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t    t = ctype;\n \t    while (t != NULL_TREE) \n \t      {\n-\t\tif (CLASSTYPE_TEMPLATE_INFO (t))\n+\t\tif (CLASSTYPE_TEMPLATE_INFO (t) &&\n+\t\t    !CLASSTYPE_TEMPLATE_SPECIALIZATION (t))\n \t\t  template_count += 1;\n \t\tt = TYPE_MAIN_DECL (t);\n \t\tif (DECL_LANG_SPECIFIC (t))\n@@ -9595,7 +9700,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t      }\n \n \t    /* Tell grokfndecl if it needs to set TREE_PUBLIC on the node.  */\n-\t    publicp = (! friendp || ! staticp);\n+\t    publicp = (! friendp || ! staticp) && !is_local_class (ctype);\n \t    decl = grokfndecl (ctype, type, \n \t\t\t       TREE_CODE (declarator) != TEMPLATE_ID_EXPR\n \t\t\t       ? declarator : dname,\n@@ -9811,7 +9916,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \n \tdecl = grokfndecl (ctype, type, original_name, declarator,\n \t\t\t   virtualp, flags, quals, raises, attrlist,\n-\t\t\t   friendp ? 2 : 1, friendp,\n+\t\t\t   1, friendp,\n \t\t\t   publicp, inlinep, funcdef_flag, \n \t\t\t   template_count);\n \tif (decl == NULL_TREE)\n@@ -10926,8 +11031,8 @@ xref_basetypes (code_type_node, name, ref, binfo)\n \t}\n #if 1\n       /* This code replaces similar code in layout_basetypes.  */\n-      else if (TYPE_SIZE (complete_type (basetype)) == NULL_TREE\n-\t       && ! (current_template_parms && uses_template_parms (basetype)))\n+      else if (! (current_template_parms && uses_template_parms (basetype))\n+\t       && TYPE_SIZE (complete_type (basetype)) == NULL_TREE)\n \t{\n \t  cp_error (\"base class `%T' has incomplete type\", basetype);\n \t  continue;\n@@ -11506,7 +11611,10 @@ start_function (declspecs, declarator, attrs, pre_parsed_p)\n     push_template_decl (decl1);\n   else if (pre_parsed_p == 0)\n     {\n-      decl1 = pushdecl (decl1);\n+      /* A specialization is not used to guide overload resolution.  */\n+      if (flag_guiding_decls \n+\t  || !DECL_TEMPLATE_SPECIALIZATION (decl1))\n+\tdecl1 = pushdecl (decl1);\n       DECL_MAIN_VARIANT (decl1) = decl1;\n       fntype = TREE_TYPE (decl1);\n     }\n@@ -11637,7 +11745,6 @@ start_function (declspecs, declarator, attrs, pre_parsed_p)\n \n   if (processing_template_decl)\n     {\n-      extern tree last_tree;\n       ++minimal_parse_mode;\n       last_tree = DECL_SAVED_TREE (decl1)\n \t= build_nt (EXPR_STMT, void_zero_node);\n@@ -12361,9 +12468,21 @@ finish_function (lineno, call_poplevel, nested)\n \n   if (! processing_template_decl)\n     {\n+      int saved_flag_keep_inline_functions =\n+\tflag_keep_inline_functions;\n+\n       /* So we can tell if jump_optimize sets it to 1.  */\n       can_reach_end = 0;\n \n+      if (DECL_CONTEXT (fndecl) != NULL_TREE\n+\t  && is_local_class (DECL_CONTEXT (fndecl)))\n+\t/* Trick rest_of_compilation into not deferring output of this\n+\t   function, even if it is inline, since the rtl_obstack for\n+\t   this function is the function_obstack of the enclosing\n+\t   function and will be deallocated when the enclosing\n+\t   function is gone.  See save_tree_status.  */\n+\tflag_keep_inline_functions = 1;\n+\n       /* Run the optimizers and output the assembler code for this\n          function.  */\n \n@@ -12384,6 +12503,8 @@ finish_function (lineno, call_poplevel, nested)\n       else\n \trest_of_compilation (fndecl);\n \n+      flag_keep_inline_functions = saved_flag_keep_inline_functions;\n+\n       if (DECL_SAVED_INSNS (fndecl) && ! TREE_ASM_WRITTEN (fndecl))\n \t{\n \t  /* Set DECL_EXTERNAL so that assemble_external will be called as\n@@ -12529,7 +12650,7 @@ start_method (declspecs, declarator)\n   if (flag_default_inline)\n     DECL_INLINE (fndecl) = 1;\n \n-  if (processing_template_decl && ! current_function_decl)\n+  if (processing_template_decl)\n     push_template_decl (fndecl);\n \n   /* We read in the parameters on the maybepermanent_obstack,"}, {"sha": "f10390d54a7c1fcdacf9d623a28a50fc33717cde", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/756506468674bd03d9a3b8fa25f8b33bd49878b3/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/756506468674bd03d9a3b8fa25f8b33bd49878b3/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=756506468674bd03d9a3b8fa25f8b33bd49878b3", "patch": "@@ -2785,7 +2785,11 @@ import_export_decl (decl)\n       if (DECL_IMPLICIT_INSTANTIATION (decl)\n \t  && (flag_implicit_templates || DECL_THIS_INLINE (decl)))\n \t{\n-\t  if (TREE_CODE (decl) == FUNCTION_DECL)\n+\t  if (!TREE_PUBLIC (decl))\n+\t    /* Templates are allowed to have internal linkage.  See \n+\t       [basic.link].  */\n+\t    ;\n+\t  else if (TREE_CODE (decl) == FUNCTION_DECL)\n \t    comdat_linkage (decl);\n \t  else\n \t    DECL_COMDAT (decl) = 1;\n@@ -3600,9 +3604,20 @@ build_expr_from_tree (t)\n       }\n \n     case COMPONENT_REF:\n-      return build_x_component_ref\n-\t(build_expr_from_tree (TREE_OPERAND (t, 0)),\n-\t TREE_OPERAND (t, 1), NULL_TREE, 1);\n+      {\n+\ttree object = build_expr_from_tree (TREE_OPERAND (t, 0));\n+\n+\tif (object != NULL_TREE \n+\t    && TREE_CODE (object) == TEMPLATE_DECL)\n+\t  {\n+\t    cp_error (\"invalid use of %D\", object);\n+\t    object = error_mark_node;\n+\t  }\n+\n+\treturn build_x_component_ref\n+\t  (object,\n+\t   TREE_OPERAND (t, 1), NULL_TREE, 1);\n+      }\n \n     case THROW_EXPR:\n       return build_throw (build_expr_from_tree (TREE_OPERAND (t, 0)));"}, {"sha": "cc264e619b6da07e3d73f1a4cadcafc3bfea4ba4", "filename": "gcc/cp/error.c", "status": "modified", "additions": 67, "deletions": 49, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/756506468674bd03d9a3b8fa25f8b33bd49878b3/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/756506468674bd03d9a3b8fa25f8b33bd49878b3/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=756506468674bd03d9a3b8fa25f8b33bd49878b3", "patch": "@@ -952,71 +952,89 @@ dump_function_name (t)\n   else\n     dump_decl (name, 0);\n \n-  if (DECL_LANG_SPECIFIC (t)\n-      && (DECL_TEMPLATE_SPECIALIZATION (t) || DECL_IMPLICIT_INSTANTIATION (t))\n-      && (DECL_CLASS_CONTEXT (t) == NULL_TREE || is_member_template (t)))\n+  if (DECL_LANG_SPECIFIC (t) && DECL_USE_TEMPLATE (t))\n     {\n-      tree args = DECL_TEMPLATE_INFO (t) \n-\t? DECL_TI_ARGS (t) : NULL_TREE; \n-\n-      OB_PUTC ('<');\n-\n-      /* Be careful only to print things when we have them, so as not\n-\t to crash producing error messages.  */\n-      if (args)\n+      tree args = DECL_TEMPLATE_INFO (t) ? DECL_TI_ARGS (t) : NULL_TREE; \n+\n+      if (args != NULL_TREE\n+\t  && DECL_CONTEXT (t) != NULL_TREE\n+\t  && uses_template_parms (DECL_CONTEXT (t))\n+\t  /* This next clause checks that there is only one level of\n+\t     template arguments.  In that case, they are the\n+\t     arguments for the class context.  */\n+\t  && (TREE_CODE (args) == TREE_LIST\n+\t      || (TREE_CODE (args) == TREE_VEC \n+\t\t  && TREE_VEC_ELT (args, 0) != NULL_TREE\n+\t\t  && TREE_CODE (TREE_VEC_ELT (args, 0)) != TREE_VEC)))\n+\t/* We have something like this:\n+\t   \n+\t   template <class T> struct S { void f(); };\n+\t   \n+\t   and we are printing S<int>::f().  This is a template\n+\t   instantiation, but we don't print anything after the f.  */\n+\t;\n+      else\n \t{\n-\t  if (TREE_CODE (args) == TREE_LIST)\n-\t    {\n-\t      tree arg;\n-\t      int need_comma = 0;\n+\t  OB_PUTC ('<');\n \n-\t      for (arg = args; arg; arg = TREE_CHAIN (arg))\n+\t  /* Be careful only to print things when we have them, so as not\n+\t     to crash producing error messages.  */\n+\t  if (args)\n+\t    {\n+\t      if (TREE_CODE (args) == TREE_LIST)\n \t\t{\n-\t\t  tree a = TREE_VALUE (arg);\n-\n-\t\t  if (need_comma)\n-\t\t    OB_PUTS (\", \");\n+\t\t  tree arg;\n+\t\t  int need_comma = 0;\n \n-\t\t  if (a)\n+\t\t  for (arg = args; arg; arg = TREE_CHAIN (arg))\n \t\t    {\n-\t\t      if (TREE_CODE_CLASS (TREE_CODE (a)) == 't')\n-\t\t\tdump_type (a, 0);\n-\t\t      else\n-\t\t\tdump_expr (a, 0);\n-\t\t    }\n+\t\t      tree a = TREE_VALUE (arg);\n+\n+\t\t      if (need_comma)\n+\t\t\tOB_PUTS (\", \");\n+\n+\t\t      if (a)\n+\t\t\t{\n+\t\t\t  if (TREE_CODE_CLASS (TREE_CODE (a)) == 't')\n+\t\t\t    dump_type (a, 0);\n+\t\t\t  else\n+\t\t\t    dump_expr (a, 0);\n+\t\t\t}\n \t\t  \n-\t\t  need_comma = 1;\n+\t\t      need_comma = 1;\n+\t\t    }\n \t\t}\n-\t    }\n-\t  else if (TREE_CODE (args) == TREE_VEC)\n-\t    {\n-\t      int i;\n-\t      int need_comma = 0;\n-\n-\t      if (TREE_VEC_LENGTH (args) > 0\n-\t\t  && TREE_CODE (TREE_VEC_ELT (args, 0)) == TREE_VEC)\n-\t\targs = TREE_VEC_ELT (args, 0);\n-\n-\t      for (i = 0; i < TREE_VEC_LENGTH (args); i++)\n+\t      else if (TREE_CODE (args) == TREE_VEC)\n \t\t{\n-\t\t  tree a = TREE_VEC_ELT (args, i);\n+\t\t  int i;\n+\t\t  int need_comma = 0;\n \n-\t\t  if (need_comma)\n-\t\t    OB_PUTS (\", \");\n+\t\t  if (TREE_VEC_LENGTH (args) > 0\n+\t\t      && TREE_CODE (TREE_VEC_ELT (args, 0)) == TREE_VEC)\n+\t\t    args = TREE_VEC_ELT (args, \n+\t\t\t\t\t TREE_VEC_LENGTH (args) - 1);\n \n-\t\t  if (a)\n+\t\t  for (i = 0; i < TREE_VEC_LENGTH (args); i++)\n \t\t    {\n-\t\t      if (TREE_CODE_CLASS (TREE_CODE (a)) == 't')\n-\t\t\tdump_type (a, 0);\n-\t\t      else\n-\t\t\tdump_expr (a, 0);\n-\t\t    }\n+\t\t      tree a = TREE_VEC_ELT (args, i);\n+\n+\t\t      if (need_comma)\n+\t\t\tOB_PUTS (\", \");\n+\n+\t\t      if (a)\n+\t\t\t{\n+\t\t\t  if (TREE_CODE_CLASS (TREE_CODE (a)) == 't')\n+\t\t\t    dump_type (a, 0);\n+\t\t\t  else\n+\t\t\t    dump_expr (a, 0);\n+\t\t\t}\n \t\t  \n-\t\t  need_comma = 1;\n+\t\t      need_comma = 1;\n+\t\t    }\n \t\t}\n \t    }\n+\t  OB_PUTC ('>');\n \t}\n-      OB_PUTC ('>');\n     }\n }\n "}, {"sha": "1114a631e5c1acd8bf7512bb0fc9f1b2366b8550", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/756506468674bd03d9a3b8fa25f8b33bd49878b3/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/756506468674bd03d9a3b8fa25f8b33bd49878b3/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=756506468674bd03d9a3b8fa25f8b33bd49878b3", "patch": "@@ -1995,15 +1995,21 @@ cons_up_default_function (type, full_name, kind)\n   {\n     tree declarator = make_call_declarator (name, args, NULL_TREE, NULL_TREE);\n     int saved_processing_specialization;\n+    int saved_processing_explicit_instantiation;\n     if (retref)\n       declarator = build_parse_node (ADDR_EXPR, declarator);\n \n     /* The following is in case we're generating the default\n        implementation in the midst of handling a specialization. */\n     saved_processing_specialization = processing_specialization;\n+    saved_processing_explicit_instantiation =\n+      processing_explicit_instantiation; \n     processing_specialization = 0;\n+    processing_explicit_instantiation = 0;\n     fn = grokfield (declarator, declspecs, NULL_TREE, NULL_TREE, NULL_TREE);\n     processing_specialization = saved_processing_specialization;\n+    processing_explicit_instantiation = \n+      saved_processing_explicit_instantiation;\n   }\n   \n   if (fn == void_type_node)"}, {"sha": "054479edc705d86a62bd3c74241e6ef9c2385ca5", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 95, "deletions": 99, "changes": 194, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/756506468674bd03d9a3b8fa25f8b33bd49878b3/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/756506468674bd03d9a3b8fa25f8b33bd49878b3/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=756506468674bd03d9a3b8fa25f8b33bd49878b3", "patch": "@@ -56,7 +56,6 @@ extern int errno;\n \n extern int end_of_file;\n extern int current_class_depth;\n-extern tree last_tree;\n \n /* FSF LOCAL dje prefix attributes */\n extern tree strip_attrs\t\tPROTO((tree));\n@@ -73,6 +72,7 @@ extern tree strip_attrs\t\tPROTO((tree));\n static char *cond_stmt_keyword;\n \n static tree empty_parms PROTO((void));\n+static tree finish_member_template_decl PROTO((tree, tree));\n \n /* Nonzero if we have an `extern \"C\"' acting as an extern specifier.  */\n int have_extern_spec;\n@@ -94,6 +94,32 @@ empty_parms ()\n     parms = NULL_TREE;\n   return parms;\n }\n+\n+\n+static tree\n+finish_member_template_decl (template_arguments, decl)\n+  tree template_arguments;\n+  tree decl;\n+{\n+  if (template_arguments)\n+    end_template_decl();\n+  else\n+    end_specialization();\n+\n+  if (decl && DECL_TEMPLATE_INFO (decl) &&\n+      !DECL_TEMPLATE_SPECIALIZATION (decl))\n+    {\n+      check_member_template (DECL_TI_TEMPLATE (decl));\n+      return DECL_TI_TEMPLATE (decl);\n+    }\n+\n+  if (decl)\n+    return decl;\n+\n+  cp_error (\"invalid member template declaration\");\n+  return NULL_TREE;\n+}\n+\n %}\n \n %start program\n@@ -260,7 +286,7 @@ empty_parms ()\n %type <ttype> template_header template_parm_list template_parm\n %type <ttype> template_type_parm\n %type <code>  template_close_bracket\n-%type <ttype> template_type template_arg_list template_arg\n+%type <ttype> template_type template_arg_list template_arg_list_opt template_arg\n %type <ttype> condition xcond paren_cond_or_null\n %type <ttype> type_name nested_name_specifier nested_type ptr_to_mem\n %type <ttype> complete_type_name notype_identifier nonnested_type\n@@ -716,26 +742,7 @@ fn.def2:\n \t| constructor_declarator\n \t\t{ $$ = start_method (NULL_TREE, $$); goto rest_of_mdef; }\n         | template_header fn.def2 \n-                { \n-                  if ($1)\n-                    end_template_decl (); \n-\t\t  else\n-\t\t    end_specialization ();\n-\n-\t\t  if ($2 && DECL_TEMPLATE_INFO ($2)\n-\t\t      && !DECL_TEMPLATE_SPECIALIZATION ($2))\n-\t\t    {\n-\t\t      $$ = DECL_TI_TEMPLATE ($2); \n-\t\t      check_member_template ($$);\n-\t\t    }\n-\t\t  else if ($2)\n-\t\t    $$ = $2;\n-\t\t  else \n-\t\t    {\n-\t\t      cp_error(\"invalid member template declaration\");\n-\t\t      $$ = NULL_TREE;\n-\t\t    }\n-\t\t}\n+                { $$ = finish_member_template_decl ($1, $2); }\n \t;\n \n return_id:\n@@ -848,70 +855,67 @@ identifier_defn:\n \t;\n \n explicit_instantiation:\n-\t  TEMPLATE typespec ';'\n-\t\t{ do_type_instantiation ($2.t, NULL_TREE);\n-\t\t  yyungetc (';', 1); }\n-\t| TEMPLATE typed_declspecs declarator\n-\t\t{ tree specs = strip_attrs ($2.t);\n-\t\t  do_decl_instantiation (specs, $3, NULL_TREE); }\n-\t| TEMPLATE notype_declarator\n-\t\t{ do_decl_instantiation (NULL_TREE, $2, NULL_TREE); }\n-\t| TEMPLATE constructor_declarator\n-\t\t{ do_decl_instantiation (NULL_TREE, $2, NULL_TREE); }\n-\t| SCSPEC TEMPLATE typespec ';'\n-\t\t{ do_type_instantiation ($3.t, $1);\n+\t  TEMPLATE begin_explicit_instantiation typespec ';'\n+\t\t{ do_type_instantiation ($3.t, NULL_TREE);\n \t\t  yyungetc (';', 1); }\n-\t| SCSPEC TEMPLATE typed_declspecs declarator\n+          end_explicit_instantiation\n+\t| TEMPLATE begin_explicit_instantiation typed_declspecs declarator\n \t\t{ tree specs = strip_attrs ($3.t);\n-\t\t  do_decl_instantiation (specs, $4, $1); }\n-\t| SCSPEC TEMPLATE notype_declarator\n-\t\t{ do_decl_instantiation (NULL_TREE, $3, $1); }\n-\t| SCSPEC TEMPLATE constructor_declarator\n-\t\t{ do_decl_instantiation (NULL_TREE, $3, $1); }\n-\t;\n+\t\t  do_decl_instantiation (specs, $4, NULL_TREE); }\n+          end_explicit_instantiation\n+\t| TEMPLATE begin_explicit_instantiation notype_declarator\n+\t\t{ do_decl_instantiation (NULL_TREE, $3, NULL_TREE); }\n+          end_explicit_instantiation\n+\t| TEMPLATE begin_explicit_instantiation constructor_declarator\n+\t\t{ do_decl_instantiation (NULL_TREE, $3, NULL_TREE); }\n+          end_explicit_instantiation\n+\t| SCSPEC TEMPLATE begin_explicit_instantiation typespec ';'\n+\t\t{ do_type_instantiation ($4.t, $1);\n+\t\t  yyungetc (';', 1); }\n+          end_explicit_instantiation\n+\t| SCSPEC TEMPLATE begin_explicit_instantiation typed_declspecs \n+          declarator\n+\t\t{ tree specs = strip_attrs ($4.t);\n+\t\t  do_decl_instantiation (specs, $5, $1); }\n+          end_explicit_instantiation\n+\t| SCSPEC TEMPLATE begin_explicit_instantiation notype_declarator\n+\t\t{ do_decl_instantiation (NULL_TREE, $4, $1); }\n+          end_explicit_instantiation\n+\t| SCSPEC TEMPLATE begin_explicit_instantiation constructor_declarator\n+\t\t{ do_decl_instantiation (NULL_TREE, $4, $1); }\n+          end_explicit_instantiation\n+\t;\n+\n+begin_explicit_instantiation: \n+      { begin_explicit_instantiation(); }\n+\n+end_explicit_instantiation: \n+      { end_explicit_instantiation(); }\n \n /* The TYPENAME expansions are to deal with use of a template class name as\n   a template within the class itself, where the template decl is hidden by\n   a type decl.  Got all that?  */\n \n template_type:\n-\t  PTYPENAME '<' template_arg_list template_close_bracket\n+\t  PTYPENAME '<' template_arg_list_opt template_close_bracket\n \t\t{\n-\t\t  $$ = lookup_template_class ($1, $3, NULL_TREE);\n+\t\t  $$ = lookup_template_class ($1, $3, NULL_TREE, NULL_TREE);\n \t\t  if ($$ != error_mark_node)\n \t\t    $$ = TYPE_STUB_DECL ($$);\n \t\t}\n-\t| PTYPENAME '<' template_close_bracket\n+\t| TYPENAME  '<' template_arg_list_opt template_close_bracket\n \t\t{\n-\t\t  $$ = lookup_template_class ($1, NULL_TREE, NULL_TREE);\n-\t\t  if ($$ != error_mark_node)\n-\t\t    $$ = TYPE_STUB_DECL ($$);\n-\t\t}\n-\t| TYPENAME  '<' template_arg_list template_close_bracket\n-\t\t{\n-\t\t  $$ = lookup_template_class ($1, $3, NULL_TREE);\n-\t\t  if ($$ != error_mark_node)\n-\t\t    $$ = TYPE_STUB_DECL ($$);\n-\t\t}\n-\t| TYPENAME '<' template_close_bracket\n-\t\t{\n-\t\t  $$ = lookup_template_class ($1, NULL_TREE, NULL_TREE);\n+\t\t  $$ = lookup_template_class ($1, $3, NULL_TREE, NULL_TREE);\n \t\t  if ($$ != error_mark_node)\n \t\t    $$ = TYPE_STUB_DECL ($$);\n \t\t}\n \t| self_template_type\n \t;\n \n self_template_type:\n-\t  SELFNAME  '<' template_arg_list template_close_bracket\n+\t  SELFNAME  '<' template_arg_list_opt template_close_bracket\n \t\t{\n-\t\t  $$ = lookup_template_class ($1, $3, NULL_TREE);\n-\t\t  if ($$ != error_mark_node)\n-\t\t    $$ = TYPE_STUB_DECL ($$);\n-\t\t}\n-\t| SELFNAME '<' template_close_bracket\n-\t\t{\n-\t\t  $$ = lookup_template_class ($1, NULL_TREE, NULL_TREE);\n+\t\t  $$ = lookup_template_class ($1, $3, NULL_TREE, NULL_TREE);\n \t\t  if ($$ != error_mark_node)\n \t\t    $$ = TYPE_STUB_DECL ($$);\n \t\t}\n@@ -927,8 +931,14 @@ template_close_bracket:\n \t\t}\n \t;\n \n+template_arg_list_opt:\n+         /* empty */\n+                 { $$ = NULL_TREE; }\n+       | template_arg_list\n+       ;\n+\n template_arg_list:\n-\t  template_arg\n+        template_arg\n \t\t{ $$ = build_tree_list (NULL_TREE, $$); }\n \t| template_arg_list ',' template_arg\n \t\t{ $$ = chainon ($$, build_tree_list (NULL_TREE, $3)); }\n@@ -1297,22 +1307,19 @@ do_id:\n \t\t{ $$ = do_identifier ($<ttype>-1, 1); }\n \n template_id:\n-          PFUNCNAME '<' do_id template_arg_list template_close_bracket \n+          PFUNCNAME '<' do_id template_arg_list_opt template_close_bracket \n                 { $$ = lookup_template_function ($3, $4); }\n-        | PFUNCNAME '<' do_id template_close_bracket\n-                { $$ = lookup_template_function ($3, NULL_TREE); }\n-        | operator_name '<' do_id template_arg_list template_close_bracket\n+        | operator_name '<' do_id template_arg_list_opt template_close_bracket\n                 { $$ = lookup_template_function ($3, $4); }\n-        | operator_name '<' do_id template_close_bracket\n-                { $$ = lookup_template_function ($3, NULL_TREE); }\n \t;\n \n object_template_id:\n-        TEMPLATE identifier '<' template_arg_list template_close_bracket\n+        TEMPLATE identifier '<' template_arg_list_opt template_close_bracket\n                 { $$ = lookup_template_function ($2, $4); }\n-        | TEMPLATE PFUNCNAME '<' template_arg_list template_close_bracket\n+        | TEMPLATE PFUNCNAME '<' template_arg_list_opt template_close_bracket\n                 { $$ = lookup_template_function ($2, $4); }\n-        | TEMPLATE operator_name '<' template_arg_list template_close_bracket\n+        | TEMPLATE operator_name '<' template_arg_list_opt \n+          template_close_bracket\n                 { $$ = lookup_template_function ($2, $4); }\n         ;\n \n@@ -1333,7 +1340,7 @@ expr_or_declarator:\n \t;\n \n notype_template_declarator:\n-\t  IDENTIFIER '<' template_arg_list template_close_bracket\n+\t  IDENTIFIER '<' template_arg_list_opt template_close_bracket\n                 { $$ = lookup_template_function ($1, $3); }\n \t| NSNAME '<' template_arg_list template_close_bracket\n                 { $$ = lookup_template_function ($1, $3); }\n@@ -2261,7 +2268,6 @@ structsp:\n \t\t  $$.new_type_flag = 0; }\n \t/* C++ extensions, merged with C to avoid shift/reduce conflicts */\n \t| class_head left_curly \n-                { reset_specialization(); }\n           opt.component_decl_list '}' maybe_attribute\n \t\t{\n \t\t  int semi;\n@@ -2285,7 +2291,7 @@ structsp:\n \t\t    ;\n \t\t  else\n \t\t    {\n-\t\t      $<ttype>$ = finish_struct ($1, $4, $6, semi);\n+\t\t      $<ttype>$ = finish_struct ($1, $3, $5, semi);\n \t\t      if (semi) note_got_semicolon ($<ttype>$);\n \t\t    }\n \n@@ -2304,10 +2310,13 @@ structsp:\n \t\t}\n \t  pending_inlines\n \t\t{ \n-\t\t  $$.t = $<ttype>7;\n+\t\t  $$.t = $<ttype>6;\n \t\t  $$.new_type_flag = 1; \n \t\t  if (current_class_type == NULL_TREE)\n \t\t    clear_inline_text_obstack (); \n+\n+\t\t  /* Undo the begin_tree in left_curly.  */\n+\t\t  end_tree ();\n \t\t}\n \t| class_head  %prec EMPTY\n \t\t{\n@@ -2670,6 +2679,12 @@ left_curly:\n \t\t  if (t && IDENTIFIER_TEMPLATE (t))\n \t\t    overload_template_name (t, 1);\n #endif\n+\t\t  reset_specialization();\n+\n+\t\t  /* In case this is a local class within a template\n+\t\t     function, we save the current tree structure so\n+\t\t     that we can get it back later.  */\n+\t\t  begin_tree ();\n \t\t}\n \t;\n \n@@ -2791,26 +2806,7 @@ component_decl_1:\n \t| using_decl\n \t\t{ $$ = do_class_using_decl ($1); }\n         | template_header component_decl_1 \n-                { \n-                  if ($1)\n-\t\t    end_template_decl (); \n-                  else\n-                    end_specialization ();\n-\n-\t\t  if ($2 && DECL_TEMPLATE_INFO ($2)\n-\t\t      && !DECL_TEMPLATE_SPECIALIZATION ($2))\n-\t\t    {\n-\t\t      $$ = DECL_TI_TEMPLATE ($2); \n-\t\t      check_member_template ($$);\n-\t\t    }\n-\t\t  else if ($2)\n-\t\t    $$ = $2;\n-\t\t  else\n-\t\t    {\n-\t\t      cp_error(\"invalid member template declaration\");\n-\t\t      $$ = NULL_TREE;\n-\t\t    }\n-\t\t}\n+                { $$ = finish_member_template_decl ($1, $2); }\n \n /* The case of exactly one component is handled directly by component_decl.  */\n /* ??? Huh? ^^^ */"}, {"sha": "b76a763dc33666b8bcff36652807a84fdf361c5b", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 1145, "deletions": 334, "changes": 1479, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/756506468674bd03d9a3b8fa25f8b33bd49878b3/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/756506468674bd03d9a3b8fa25f8b33bd49878b3/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=756506468674bd03d9a3b8fa25f8b33bd49878b3", "patch": "@@ -61,28 +61,31 @@ static tree *maybe_template_tail = &maybe_templates;\n int minimal_parse_mode;\n \n int processing_specialization;\n+int processing_explicit_instantiation;\n static int template_header_count;\n \n+static tree saved_trees;\n+\n #define obstack_chunk_alloc xmalloc\n #define obstack_chunk_free free\n \n static int unify PROTO((tree, tree *, int, tree, tree, int *, int));\n static void add_pending_template PROTO((tree));\n static int push_tinst_level PROTO((tree));\n static tree classtype_mangled_name PROTO((tree));\n-static char *mangle_class_name_for_template PROTO((char *, tree, tree));\n+static char *mangle_class_name_for_template PROTO((char *, tree, tree, tree));\n static tree tsubst_expr_values PROTO((tree, tree));\n static int comp_template_args PROTO((tree, tree));\n static int list_eq PROTO((tree, tree));\n static tree get_class_bindings PROTO((tree, tree, tree));\n-static tree coerce_template_parms PROTO((tree, tree, tree));\n+static tree coerce_template_parms PROTO((tree, tree, tree, int, int));\n static tree tsubst_enum\tPROTO((tree, tree, int, tree *));\n static tree add_to_template_args PROTO((tree, tree));\n static int  type_unification_real PROTO((tree, tree *, tree, tree, int*,\n \t\t\t\t\t int, int, int));\n-static int processing_explicit_specialization PROTO((int));\n static void note_template_header PROTO((int));\n static tree maybe_fold_nontype_arg PROTO((tree));\n+static tree convert_nontype_parameter PROTO((tree, tree));\n \n /* Restore the template parameter context. */\n \n@@ -140,8 +143,19 @@ end_member_template_processing ()\n   poplevel (0, 0, 0);\n }\n \n-/* Returns non-zero iff T is a member template function.  Works if T\n-   is either a FUNCTION_DECL or a TEMPLATE_DECL.  */\n+/* Returns non-zero iff T is a member template function.  We must be\n+   careful as in \n+\n+     template <class T> class C { void f(); }\n+\n+   Here, f is a template function, and a member, but not a member\n+   template.  This function does not concern itself with the origin of\n+   T, only its present state.  So if we have \n+\n+     template <class T> class C { template <class U> void f(U); }\n+\n+   then neither C<int>::f<char> nor C<T>::f<double> is considered\n+   to be a member template.  */\n \n int\n is_member_template (t)\n@@ -151,7 +165,7 @@ is_member_template (t)\n \n   if (TREE_CODE (t) != FUNCTION_DECL\n       && !DECL_FUNCTION_TEMPLATE_P (t))\n-    /* Anything that isn't a template or a template function is\n+    /* Anything that isn't a function or a template function is\n        certainly not a member template.  */\n     return 0;\n \n@@ -175,33 +189,27 @@ is_member_template (t)\n \t  int template_class_levels = 0;\n \t  tree ctx = DECL_CLASS_CONTEXT (t);\n \n-\t  if (CLASSTYPE_TEMPLATE_INFO (ctx))\n-\t    {\n-\t      tree args;\n+\t  /* NB - The code below does not yet handle template class\n+\t     members, e.g. \n+\t     \n+\t       template <class T> class C { template <class U> class D; }}\n \n-\t      /* Here, we should really count the number of levels\n-\t\t deep ctx is, making sure not to count any levels that\n-\t\t are just specializations.  Since there are no member\n-\t\t template classes yet, we don't have to do all that.  */\n+\t     correctly.  In that case, the D should have level 2.  */\n \n-\t      if (!CLASSTYPE_TEMPLATE_SPECIALIZATION (ctx))\n+\t  if (CLASSTYPE_TEMPLATE_INFO (ctx))\n+\t    {\n+\t      tree args = CLASSTYPE_TI_ARGS (ctx);\n+\t      int i;\n+\t      \n+\t      if (args == NULL_TREE)\n \t\ttemplate_class_levels = 1;\n-\t      else\n-\t\t{\n-\t\t  int i;\n-\n-\t\t  args = CLASSTYPE_TI_ARGS (ctx);\n-\n-\t\t  if (args == NULL_TREE)\n-\t\t    template_class_levels = 1;\n-\t\t  else \n-\t\t    for (i = 0; i < TREE_VEC_LENGTH (args); ++i)\n-\t\t      if (uses_template_parms (TREE_VEC_ELT (args, i)))\n-\t\t\t{\n-\t\t\t  template_class_levels++;\n-\t\t\t  break;\n-\t\t\t}\n-\t\t}\n+\t      else \n+\t\tfor (i = 0; i < TREE_VEC_LENGTH (args); ++i)\n+\t\t  if (uses_template_parms (TREE_VEC_ELT (args, i)))\n+\t\t    {\n+\t\t      template_class_levels++;\n+\t\t      break;\n+\t\t    }\n \t    }\n \n \t  if (parm_levels > template_class_levels)\n@@ -298,99 +306,184 @@ note_template_header (specialization)\n }\n \n \n-/* Returns non-zero iff a declarator, in which the number of template\n-   types that appeared was TEMPLATE_COUNT, is an explicit\n-   specialization.  */\n+/* We're beginning an explicit instantiation.  */\n \n-static int\n-processing_explicit_specialization (template_count)\n-     int template_count;\n+void\n+begin_explicit_instantiation ()\n {\n-  /* A function declaration is an explicit specialization of a member\n-     template if all of the following conditions hold:\n-     \n-     o There was a template <...> preceeding the declaration.\n-     o The last template <...> was in fact template <>.\n-     o The number of template <...>'s preceeding the declaration, less\n-       the number of template classes with arguments specified used to\n-       qualify the function name, is 1.\n+  ++processing_explicit_instantiation;\n+}\n \n-     For example:\n \n-     template <> void S<int>::foo(); \n-     template <class T> template <> void S<T>::foo();\n-     template <> struct S<int> { ... template <> void foo(); }\n+void\n+end_explicit_instantiation ()\n+{\n+  my_friendly_assert(processing_explicit_instantiation > 0, 0);\n+  --processing_explicit_instantiation;\n+}\n \n-     The first of these is not a specialization of S<int>::foo() (it\n-     is instead a specialization of S<T>::foo), while the next two are\n-     specializations of member template functions.  */\n \n-  return processing_specialization \n-    && template_header_count > template_count; \n+/* Retrieve the specialization (in the sense of [temp.spec] - a\n+   specialization is either an instantiation or an explicit\n+   specialization) of TMPL for the given template ARGS.  If there is\n+   no such specialization, return NULL_TREE.  The ARGS are a vector of\n+   arguments, or a vector of vectors of arguments, in the case of\n+   templates with more than one level of parameters.  */\n+   \n+static tree\n+retrieve_specialization (tmpl, args)\n+     tree tmpl;\n+     tree args;\n+{\n+  tree s;\n+\n+  my_friendly_assert (TREE_CODE (tmpl) == TEMPLATE_DECL, 0);\n+\n+  for (s = DECL_TEMPLATE_SPECIALIZATIONS (tmpl);\n+       s != NULL_TREE;\n+       s = TREE_CHAIN (s))\n+    if (comp_template_args (TREE_PURPOSE (s), args))\n+      return TREE_VALUE (s);\n+\n+  return NULL_TREE;\n }\n \n-/* Returns the template function specialized by TEMPLATE_ID, or\n-   NULL_TREE if there is none.\n \n-   The TEMPLATE_ID is a TEMPLATE_ID_EXPR.  The TYPE is\n-   the type it has been declared to have.  Return the TEMPLATE_DECL\n-   that is being specialized, and put the specialization arguments in\n-   *TARGS.  If no appropriate specialization can be found, NULL_TREE is\n-   returned, and *TARGS is assigned NULL_TREE.  If complain is\n-   non-zero, error messages are printed where appropriate.  */\n-   \n+\n+/* Register the specialization SPEC as a specialization of TMPL with\n+   the indicated ARGS.  */\n+\n+static void\n+register_specialization (spec, tmpl, args)\n+     tree spec;\n+     tree tmpl;\n+     tree args;\n+{\n+  tree s;\n+\n+  my_friendly_assert (TREE_CODE (tmpl) == TEMPLATE_DECL, 0);\n+\n+  if (TREE_CODE (spec) != TEMPLATE_DECL\n+      && list_length (DECL_TEMPLATE_PARMS (tmpl)) > 1)\n+    /* Avoid registering function declarations as\n+       specializations of member templates, as would otherwise\n+       happen with out-of-class specializations of member\n+       templates.  */\n+    return;\n+    \n+  for (s = DECL_TEMPLATE_SPECIALIZATIONS (tmpl);\n+       s != NULL_TREE;\n+       s = TREE_CHAIN (s))\n+    if (comp_template_args (TREE_PURPOSE (s), args))\n+      {\n+\ttree fn = TREE_VALUE (s);\n+\n+\tif (DECL_TEMPLATE_SPECIALIZATION (spec))\n+\t  {\n+\t    if (DECL_TEMPLATE_INSTANTIATION (fn))\n+\t      {\n+\t\tif (TREE_USED (fn) \n+\t\t    || DECL_EXPLICIT_INSTANTIATION (fn))\n+\t\t  {\n+\t\t    cp_error (\"specialization of %D after instantiation\",\n+\t\t\t      fn);\n+\t\t    return;\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    /* This situation should occur only if the first\n+\t\t       specialization is an implicit instantiation,\n+\t\t       the second is an explicit specialization, and\n+\t\t       the implicit instantiation has not yet been\n+\t\t       used.  That situation can occur if we have\n+\t\t       implicitly instantiated a member function of\n+\t\t       class type, and then specialized it later.  */\n+\n+\t\t    /* FIXME: Should we call duplicate_decls here?  */\n+\t\t    TREE_VALUE (s) = spec;\n+\t\t    return;\n+\t\t  }\n+\t      }\n+\t    else if (DECL_TEMPLATE_SPECIALIZATION (fn))\n+\t      {\n+\t\tif (DECL_INITIAL (fn))\n+\t\t  cp_error (\"duplicate specialization of %D\", fn);\n+\n+\t\t/* FIXME: Should we call duplicate_decls here?  */\n+\t\tTREE_VALUE (s) = spec;\n+\t\treturn;\n+\t      }\n+\t  }\n+      }\n+\n+  DECL_TEMPLATE_SPECIALIZATIONS (tmpl)\n+     = perm_tree_cons (args, spec, DECL_TEMPLATE_SPECIALIZATIONS (tmpl));\n+}\n+\n+\n+/* Returns the template (one of the functions given by TEMPLATE_ID)\n+   which can be specialized to have the indicated TYPE with the\n+   explicit template args given in TEMPLATE_ID.  TARGS_IN.  The\n+   template args (those explicitly specified and those deduced) are\n+   output in a newly created vector *TARGS_OUT.  If it is impossible\n+   to determine the result, an error message is issued, unless\n+   COMPLAIN is 0.  */\n+\n tree\n-determine_explicit_specialization (template_id, type, targs_out,\n-\t\t\t\t   need_member_template,\n-\t\t\t\t   complain)\n+determine_specialization (template_id, type, targs_out, \n+\t\t\t  need_member_template,\n+\t\t\t  complain)\n      tree template_id;\n      tree type;\n      tree* targs_out;\n      int need_member_template;\n      int complain;\n {\n-  int i;\n-  int overloaded;\n-  tree fns;\n+  tree fns = TREE_OPERAND (template_id, 0);\n+  tree targs_in = TREE_OPERAND (template_id, 1);\n   tree matching_fns = NULL_TREE;\n-  tree result;\n   tree fn;\n-\n-  my_friendly_assert (TREE_CODE (template_id) == TEMPLATE_ID_EXPR\n-\t\t      && TREE_OPERAND (template_id, 0), 0); \n-\t\t      \n-  fns = TREE_OPERAND (template_id, 0);\n+  int overloaded;\n+  int i;\n \n   if (is_overloaded_fn (fns))\n     fn = get_first_fn (fns);\n   else\n     fn = NULL_TREE;\n \n   overloaded = really_overloaded_fn (fns);\n-\n   for (; fn != NULL_TREE; \n        fn = overloaded ? DECL_CHAIN (fn) : NULL_TREE)\n     {\n       int dummy = 0;\n       tree targs;\n-\n-      if (TREE_CODE (fn) != TEMPLATE_DECL\n+      tree t;\n+      tree tmpl;\n+\n+      if (!need_member_template \n+\t  && TREE_CODE (fn) == FUNCTION_DECL \n+\t  && DECL_USE_TEMPLATE (fn)\n+\t  && DECL_TI_TEMPLATE (fn))\n+\ttmpl = DECL_TI_TEMPLATE (fn);\n+      else if (TREE_CODE (fn) != TEMPLATE_DECL\n \t  || (need_member_template && !is_member_template (fn)))\n \tcontinue;\n+      else\n+\ttmpl = fn;\n \n-      if (list_length (TREE_OPERAND (template_id, 1)) > DECL_NTPARMS (fn))\n+      if (list_length (targs_in) > DECL_NTPARMS (tmpl))\n \tcontinue;\n \n-      targs = make_scratch_vec (DECL_NTPARMS (fn));\n+      targs = make_scratch_vec (DECL_NTPARMS (tmpl));\n \n       /* We allow incomplete unification here, because we are going to\n \t check all the functions. */\n-      i = type_unification (DECL_INNERMOST_TEMPLATE_PARMS (fn),\n+      i = type_unification (DECL_INNERMOST_TEMPLATE_PARMS (tmpl),\n \t\t\t    &TREE_VEC_ELT (targs, 0),\n \t\t\t    type \n-\t\t\t    ? TYPE_ARG_TYPES (TREE_TYPE (fn)) : NULL_TREE, \n+\t\t\t    ? TYPE_ARG_TYPES (TREE_TYPE (tmpl)) : NULL_TREE, \n \t\t\t    type ? TYPE_ARG_TYPES (type) : NULL_TREE,\n-\t\t\t    TREE_OPERAND (template_id, 1),\n+\t\t\t    targs_in,\n \t\t\t    &dummy, 1, 1);\n       \n       if (i == 0) \n@@ -399,9 +492,9 @@ determine_explicit_specialization (template_id, type, targs_out,\n \t     match. */\n \t  if (type != NULL_TREE)\n \t    {\n-\t      tree tmpl_return_type = tsubst (TREE_TYPE (TREE_TYPE (fn)),\n+\t      tree tmpl_return_type = tsubst (TREE_TYPE (TREE_TYPE (tmpl)),\n \t\t\t\t\t      targs,\n-\t\t\t\t\t      DECL_NTPARMS (fn),\n+\t\t\t\t\t      DECL_NTPARMS (tmpl),\n \t\t\t\t\t      NULL_TREE);\n \t      \n \t      if (tmpl_return_type != TREE_TYPE (type))\n@@ -412,35 +505,37 @@ determine_explicit_specialization (template_id, type, targs_out,\n \t\t     problem.  */\n \t\t  cp_error (\"Return type of explicit specialization of\");\n \t\t  cp_error (\"`%D' is `%T', but should be `%T'.\", \n-\t\t\t    fn, TREE_TYPE (type), tmpl_return_type);\n+\t\t\t    tmpl, TREE_TYPE (type), tmpl_return_type);\n \t\t  *targs_out = NULL_TREE;\n \t\t  return NULL_TREE;\n \t\t}\n \t    }\n \n-\t  matching_fns = scratch_tree_cons (fn, targs, matching_fns);\n+\t  matching_fns = scratch_tree_cons (tmpl, targs, matching_fns);\n \t}\n     }\n-\n+  \n   if (matching_fns == NULL_TREE)\n     {\n       if (complain)\n \tcp_error (\"`%D' does not match any template declaration.\",\n \t\t  template_id);\n-\n+      \n       *targs_out = NULL_TREE;\n       return NULL_TREE;\n     }\n-\n+  \n   if (TREE_CHAIN (matching_fns) != NULL_TREE) \n     {\n       if (complain)\n \t{\n-\t  tree fn;\n+\t  tree tmpl;\n \t  \n \t  cp_error (\"Ambiguous explicit specialization.  Candidates are:\");\n-\t  for (fn = matching_fns; fn != NULL_TREE; fn = TREE_CHAIN (fn))\n-\t    cp_error (\"    %D\", TREE_PURPOSE (fn));\n+\t  for (tmpl = matching_fns; \n+\t       tmpl != NULL_TREE; \n+\t       tmpl = TREE_CHAIN (tmpl)) \n+\t    cp_error (\"    %D\", TREE_PURPOSE (tmpl));\n \t}\n \n       *targs_out = NULL_TREE;\n@@ -454,14 +549,50 @@ determine_explicit_specialization (template_id, type, targs_out,\n \n \t\n /* Check to see if the function just declared, as indicated in\n-   DECLARATOR, and in DECL, is a specialization.  Check that the\n-   specialization is OK.  If FLAGS == 1, we are being called by\n-   finish_struct_methods.  If FLAGS == 2, we are being called by\n-   grokfndecl, and the function has a definition, or is a friend.  If\n-   FLAGS == 3, this is a friend declaration.\n-   Returns 0 if the decl is not an explicit specialization or\n-   instantiation, 1 if it is an explicit specialization, and 2 if it\n-   is an explicit instantiation.  */\n+   DECLARATOR, and in DECL, is a specialization of a function\n+   template.  We may also discover that the declaration is an explicit\n+   instantiation at this point.\n+\n+   Returns:\n+   \n+     0: The function is not an explicit specialization or instantiation.\n+     1: The function is an explicit specialization.\n+     2: The function is an explicit instantiation.\n+\n+   FLAGS is a bitmask consisting of the following flags: \n+\n+   1: We are being called by finish_struct.  (We are unable to\n+      determine what template is specialized by an in-class\n+      declaration until the class definition is complete, so\n+      finish_struct_methods calls this function again later to finish\n+      the job.)\n+   2: The function has a definition.\n+   4: The function is a friend.\n+   8: The function is known to be a specialization of a member\n+      template. \n+\n+   The TEMPLATE_COUNT is the number of references to qualifying\n+   template classes that appeared in the name of the function.  For\n+   example, in\n+\n+     template <class T> struct S { void f(); };\n+     void S<int>::f();\n+     \n+   the TEMPLATE_COUNT would be 1.  However, explicitly specialized\n+   classes are not counted in the TEMPLATE_COUNT, so that in\n+\n+     template <class T> struct S {};\n+     template <> struct S<int> { void f(); }\n+     template <>\n+     void S<int>::f();\n+\n+   the TEMPLATE_COUNT would be 0.  (Note that this declaration is\n+   illegal; there should be no template <>.)\n+\n+   If the function is a specialization, it is marked as such via\n+   DECL_TEMPLATE_SPECIALIZATION.  Furthermore, its DECL_TEMPLATE_INFO\n+   is set up correctly, and it is added to the list of specializations \n+   for that template.  */\n \n int\n check_explicit_specialization (declarator, decl, template_count, flags)\n@@ -470,49 +601,122 @@ check_explicit_specialization (declarator, decl, template_count, flags)\n      int template_count;\n      int flags;\n {\n-  int finish_member = flags == 1;\n-  int have_def = flags == 2;\n-  int is_friend = flags == 3;\n+  int finish_member = flags & 1;\n+  int have_def = flags & 2;\n+  int is_friend = flags & 4;\n+  int specialization = 0;\n+  int member_specialization = flags & 8;\n+\n+  tree ctype = DECL_CLASS_CONTEXT (decl);\n+  tree dname = DECL_NAME (decl);\n \n-  if (processing_explicit_specialization (template_count)\n-      || finish_member\n-      || TREE_CODE (declarator) == TEMPLATE_ID_EXPR)\n+  if (!finish_member)\n     {\n-      tree tmpl = NULL_TREE;\n-      tree dname = DECL_NAME (decl);\n-      tree ctype = DECL_CLASS_CONTEXT (decl);\n-      tree targs;\n+      if (processing_specialization) \n+\t{\n+\t  /* The last template header was of the form template <>.  */\n+\t  \n+\t  if (template_header_count > template_count) \n+\t    {\n+\t      /* There were more template headers than qualifying template\n+\t\t classes.  */\n+\t      if (template_header_count - template_count > 1)\n+\t\t/* There shouldn't be that many template parameter\n+\t\t   lists.  There can be at most one parameter list for\n+\t\t   every qualifying class, plus one for the function\n+\t\t   itself.  */\n+\t\tcp_error (\"too many template parameter lists in declaration of `%D'\", decl);\n \n-      /* We've come across a declarator that looks like: U f<T1,\n-\t T2, ...>(A1, A2, ..).  This is an explicit template\n-\t specialization.  Check that: \n-\t       \n-\t o The explicitly specified parameters together with those\n-\t that can be deduced by template argument deduction\n-\t uniquely determine a particular specialization.  \n-\t       \n-\t See [temp.expl.spec].  */\n+\t      SET_DECL_TEMPLATE_SPECIALIZATION (decl);\n+\t      if (ctype)\n+\t\tmember_specialization = 1;\n+\t      else\n+\t\tspecialization = 1;\n+\t    }\n+\t  else if (template_header_count == template_count)\n+\t    {\n+\t      /* The counts are equal.  So, this might be a\n+\t\t specialization, but it is not a specialization of a\n+\t\t member template.  It might be something like\n+\t\t \n+\t\t template <class T> struct S { \n+\t         void f(int i); \n+\t\t };\n+\t\t template <>\n+\t\t void S<int>::f(int i) {}  */\n+\t      specialization = 1;\n+\t      SET_DECL_TEMPLATE_SPECIALIZATION (decl);\n+\t    }\n+\t  else \n+\t    {\n+\t      /* This cannot be an explicit specialization.  There are not\n+\t\t enough headers for all of the qualifying classes.  For\n+\t\t example, we might have:\n+\t     \n+\t\t template <>\n+\t\t void S<int>::T<char>::f();\n+\n+\t\t But, we're missing another template <>.  */\n+\t      cp_error(\"too few template parameter lists in declaration of `%D'\", decl);\n+\t      return 0;\n+\t    } \n+\t}\n+      else if (processing_explicit_instantiation)\n+\t{\n+\t  if (template_header_count)\n+\t    cp_error (\"template parameter list used in explicit instantiation\");\n+\t  \n+\t  if (have_def)\n+\t    cp_error (\"definition provided for explicit instantiation\");\n \n-      if (!finish_member\n-\t  && TREE_CODE (declarator) == TEMPLATE_ID_EXPR\n-\t  && !processing_explicit_specialization (template_count)\n-\t  && !is_friend)\n+\t  SET_DECL_EXPLICIT_INSTANTIATION (decl);\n+\n+\t  /* We don't try to figure out what's being explicitly\n+\t     instantiated at this point, since do_decl_instantiation\n+\t     will do that later.  */\n+\t  return 2;\n+\t}\n+      else if ((ctype != NULL_TREE\n+\t\t&& !TYPE_BEING_DEFINED (ctype)\n+\t\t&& CLASSTYPE_TEMPLATE_INSTANTIATION (ctype))\n+\t       || TREE_CODE (declarator) == TEMPLATE_ID_EXPR)\n \t{\n-\t  if (! have_def && ! template_header_count && ! ctype)\n-\t    /* This is not an explict specialization.  It must be\n-\t       an explicit instantiation.  */\n-\t    return 2;\n-\t  else if (template_header_count > template_count\n-\t\t   && !processing_specialization)\n+\t  /* The first part of the above clause catches illegal code\n+\t     that looks like this:\n+\n+\t     template <class T> struct S { void f(); }\n+\t     void S<int>::f() {} // Missing template <>\n+\n+\t     We disable this check when the type is being defined to\n+\t     avoid complaining about default compiler-generated\n+\t     constructors, destructors, and assignment operators.\n+\t     Since the type is an instantiation, not a specialization,\n+\t     these are the only functions that can be defined before\n+\t     the class is complete.\n+\n+\t     The second part handles bogus declarations like\n+\t     template <> template <class T>\n+\t     void f<int>();  */\n+\n+\t  if (template_header_count > template_count)\n \t    {\n \t      cp_error (\"template-id `%D' in declaration of primary template\",\n \t\t\tdeclarator);\n \t      return 0;\n \t    }\n-\t  else if (pedantic || uses_template_parms (decl))\n-\t    pedwarn (\"explicit specialization not preceded by `template <>'\");\n+\t  \n+\t  cp_error (\"explicit specialization not preceded by `template <>'\");\n+\t  return 0;\n \t}\n+    }\n \n+  if (specialization || member_specialization)\n+    {\n+      tree tmpl = NULL_TREE;\n+      tree targs = NULL_TREE;\n+      tree targs_in;\n+\n+      /* Make sure that the declarator is a TEMPLATE_ID_EXPR.  */\n       if (TREE_CODE (declarator) != TEMPLATE_ID_EXPR)\n \t{\n \t  tree fns;\n@@ -524,7 +728,8 @@ check_explicit_specialization (declarator, decl, template_count, flags)\n \t  else\n \t    fns = dname;\n \n-\t  declarator = lookup_template_function (fns, NULL_TREE);\n+\t  declarator = \n+\t    lookup_template_function (fns, NULL_TREE);\n \t}\n \n       if (TREE_CODE (TREE_OPERAND (declarator, 0)) == LOOKUP_EXPR) \n@@ -536,50 +741,81 @@ check_explicit_specialization (declarator, decl, template_count, flags)\n \t  return 1;\n \t} \n \n-      if (ctype \n-\t  && TREE_CODE (TREE_OPERAND (declarator, 0)) == IDENTIFIER_NODE)\n+      if (ctype != NULL_TREE && TYPE_BEING_DEFINED (ctype))\n+\t{\n+\t  /* Since finish_struct_1 has not been called yet, we\n+\t     can't call lookup_fnfields.  We note that this\n+\t     template is a specialization, and proceed, letting\n+\t     finish_struct fix this up later.  */\n+\t  DECL_TEMPLATE_INFO (decl) \n+\t    = perm_tree_cons (NULL_TREE, \n+\t\t\t      TREE_OPERAND (declarator, 1),\n+\t\t\t      /* We remember whether or not this was a\n+\t\t\t\t member specialization by recording\n+\t\t\t\t this value, temporarily, in the\n+\t\t\t\t TREE_CHAIN field.  Nobody looks at\n+\t\t\t\t this, and we clear it in\n+\t\t\t\t finish_struct.  */ \n+\t\t\t      (tree) member_specialization);\n+\t  return 1;\n+\t}\n+      else if (ctype != NULL_TREE \n+\t       && (TREE_CODE (TREE_OPERAND (declarator, 0)) ==\n+\t\t   IDENTIFIER_NODE))\n \t{\n+\t  /* Find the list of functions in ctype that have the same\n+\t     name as the declared function.  */\n+\t  tree name = TREE_OPERAND (declarator, 0);\n \t  tree fns;\n- \n-\t  if (TYPE_BEING_DEFINED (ctype) && !finish_member)\n+\t  \n+\t  if (name == constructor_name (ctype) \n+\t      || name == constructor_name_full (ctype))\n \t    {\n-\t      /* Since finish_struct_1 has not been called yet, we\n-\t\t can't call lookup_fnfields.  We note that this\n-\t\t template is a specialization, and proceed, letting\n-\t\t finish_struct_methods fix this up later.  */\n-\t      SET_DECL_TEMPLATE_SPECIALIZATION (decl);\n-\t      DECL_TEMPLATE_INFO (decl) \n-\t\t= perm_tree_cons (NULL_TREE, \n-\t\t\t\t  TREE_OPERAND (declarator, 1),\n-\t\t\t\t  NULL_TREE);\n-\t      return 1;\n-\t    }\n+\t      int is_constructor = DECL_CONSTRUCTOR_P (decl);\n+\t      \n+\t      if (is_constructor ? !TYPE_HAS_CONSTRUCTOR (ctype)\n+\t\t  : !TYPE_HAS_DESTRUCTOR (ctype))\n+\t\t{\n+\t\t  /* From [temp.expl.spec]:\n+\n+\t\t     If such an explicit specialization for the member\n+\t\t     of a class template names an implicitly-declared\n+\t\t     special member function (clause _special_), the\n+\t\t     program is ill-formed.  */\n+\t\t  cp_error (\"specialization of implicitly-declared special member function\");\n+\n+\t\t  return 1;\n+\t\t}\n \n-\t  fns = lookup_fnfields (TYPE_BINFO (ctype), \n-\t\t\t\t TREE_OPERAND (declarator, 0),\n-\t\t\t\t 1);\n+\t      fns = TREE_VEC_ELT(CLASSTYPE_METHOD_VEC (ctype),\n+\t\t\t\t is_constructor ? 0 : 1);\n+\t    }\n+\t  else \n+\t    fns = lookup_fnfields (TYPE_BINFO (ctype), name,\n+\t\t\t\t   1);\n \t  \n \t  if (fns == NULL_TREE) \n \t    {\n-\t      cp_error (\"No member template `%s' declared in `%T'\",\n-\t\t\tIDENTIFIER_POINTER (TREE_OPERAND (declarator,\n-\t\t\t\t\t\t\t  0)),\n+\t      cp_error (\"no member function `%s' declared in `%T'\",\n+\t\t\tIDENTIFIER_POINTER (name),\n \t\t\tctype);\n \t      return 1;\n \t    }\n \t  else\n \t    TREE_OPERAND (declarator, 0) = fns;\n \t}\n-\n-      tmpl = \n-\tdetermine_explicit_specialization \n-\t(declarator, TREE_TYPE (decl), &targs, \n-\t TREE_CODE (decl) == TEMPLATE_DECL, 1);\n+      \n+      /* Figure out what exactly is being specialized at this point.  */\n+      tmpl = determine_specialization (declarator,\n+\t\t\t\t       TREE_TYPE (decl), &targs, \n+\t\t\t\t       member_specialization,\n+\t\t\t\t       1);\n \t    \n       if (tmpl)\n \t{\n \t  /* Mangle the function name appropriately.  */\n-\t  if (name_mangling_version >= 1)\n+\t  if ((member_specialization || ctype == NULL_TREE)\n+\t      && name_mangling_version >= 1)\n \t    {\n \t      tree arg_types = TYPE_ARG_TYPES (TREE_TYPE (tmpl));\n \n@@ -606,16 +842,9 @@ check_explicit_specialization (declarator, decl, template_count, flags)\n \t      SET_DECL_IMPLICIT_INSTANTIATION (decl);\n \t      DECL_TEMPLATE_INFO (decl) \n \t\t= perm_tree_cons (tmpl, targs, NULL_TREE);\n-\t      return 1;\n+\t      return 2;\n \t    }\n \n-\t  /* This function declaration is a template specialization.\n-\t     Record that fact.  */\n-\t  SET_DECL_TEMPLATE_SPECIALIZATION (decl);\n-\t  DECL_TEMPLATE_SPECIALIZATIONS (tmpl) \n-\t    = perm_tree_cons (targs, decl, \n-\t\t\t      DECL_TEMPLATE_SPECIALIZATIONS\n-\t\t\t      (tmpl));\n \t  /* If DECL_TI_TEMPLATE (decl), the decl is an\n \t     instantiation of a specialization of a member template.\n \t     (In other words, there was a member template, in a\n@@ -635,13 +864,70 @@ check_explicit_specialization (declarator, decl, template_count, flags)\n \t  if (!(DECL_TEMPLATE_INFO (decl) && DECL_TI_TEMPLATE (decl)))\n \t    DECL_TEMPLATE_INFO (decl)\n \t      = perm_tree_cons (tmpl, targs, NULL_TREE);\n+\n+\t  register_specialization (decl, tmpl, targs);\n+\n \t  return 1;\n \t}\n     }\n-\n+  \n   return 0;\n }\n-\t\t\t   \n+\n+\n+/* Returns 1 iff PARMS1 and PARMS2 are identical sets of template\n+   parameters.  These are represented in the same format used for\n+   DECL_TEMPLATE_PARMS.  */\n+\n+int comp_template_parms (parms1, parms2)\n+     tree parms1;\n+     tree parms2;\n+{\n+  tree p1;\n+  tree p2;\n+\n+  if (parms1 == parms2)\n+    return 1;\n+\n+  for (p1 = parms1, p2 = parms2; \n+       p1 != NULL_TREE && p2 != NULL_TREE;\n+       p1 = TREE_CHAIN (p1), p2 = TREE_CHAIN (p2))\n+    {\n+      tree t1 = TREE_VALUE (p1);\n+      tree t2 = TREE_VALUE (p2);\n+      int i;\n+\n+      my_friendly_assert (TREE_CODE (t1) == TREE_VEC, 0);\n+      my_friendly_assert (TREE_CODE (t2) == TREE_VEC, 0);\n+\n+      if (TREE_VEC_LENGTH (t1) != TREE_VEC_LENGTH (t2))\n+\treturn 0;\n+\n+      for (i = 0; i < TREE_VEC_LENGTH (t2); ++i) \n+\t{\n+\t  tree parm1 = TREE_VALUE (TREE_VEC_ELT (t1, i));\n+\t  tree parm2 = TREE_VALUE (TREE_VEC_ELT (t2, i));\n+\n+\t  if (TREE_CODE (parm1) != TREE_CODE (parm2))\n+\t    return 0;\n+\n+\t  if (TREE_CODE (parm1) == TEMPLATE_TYPE_PARM)\n+\t    continue;\n+\t  else if (!comptypes (TREE_TYPE (parm1), \n+\t\t\t       TREE_TYPE (parm2), 1))\n+\t    return 0;\n+\t}\n+    }\n+\n+  if ((p1 != NULL_TREE) != (p2 != NULL_TREE))\n+    /* One set of parameters has more parameters lists than the\n+       other.  */\n+    return 0;\n+\n+  return 1;\n+}\n+\n+\n /* Process information from new template parameter NEXT and append it to the\n    LIST being built.  */\n \n@@ -805,6 +1091,25 @@ current_template_args ()\n \n   return args;\n }\n+\n+static tree\n+build_template_decl (decl, parms)\n+     tree decl;\n+     tree parms;\n+{\n+  tree tmpl = build_lang_decl (TEMPLATE_DECL, DECL_NAME (decl), NULL_TREE);\n+  DECL_TEMPLATE_PARMS (tmpl) = parms;\n+  DECL_CONTEXT (tmpl) = DECL_CONTEXT (decl);\n+  if (DECL_LANG_SPECIFIC (decl))\n+    {\n+      DECL_CLASS_CONTEXT (tmpl) = DECL_CLASS_CONTEXT (decl);\n+      DECL_STATIC_FUNCTION_P (tmpl) = \n+\tDECL_STATIC_FUNCTION_P (decl);\n+    }\n+\n+  return tmpl;\n+}\n+\n   \n void\n push_template_decl (decl)\n@@ -851,25 +1156,19 @@ push_template_decl (decl)\n \n   args = current_template_args ();\n \n-  if (! ctx || TYPE_BEING_DEFINED (ctx))\n+  if (! ctx || TREE_CODE (ctx) == FUNCTION_DECL \n+      || TYPE_BEING_DEFINED (ctx))\n     {\n-      tmpl = build_lang_decl (TEMPLATE_DECL, DECL_NAME (decl), NULL_TREE);\n-      DECL_TEMPLATE_PARMS (tmpl) = current_template_parms;\n-      DECL_CONTEXT (tmpl) = DECL_CONTEXT (decl);\n-      if (DECL_LANG_SPECIFIC (decl))\n+      tmpl = build_template_decl (decl, current_template_parms);\n+      \n+      if (DECL_LANG_SPECIFIC (decl)\n+\t  && DECL_TEMPLATE_SPECIALIZATION (decl))\n \t{\n-\t  DECL_CLASS_CONTEXT (tmpl) = DECL_CLASS_CONTEXT (decl);\n-\t  DECL_STATIC_FUNCTION_P (tmpl) = \n-\t    DECL_STATIC_FUNCTION_P (decl);\n-\n-\t  if (DECL_TEMPLATE_SPECIALIZATION (decl))\n-\t    {\n-\t      /* A specialization of a member template of a template\n-\t\t class. */\n-\t      SET_DECL_TEMPLATE_SPECIALIZATION (tmpl);\n-\t      DECL_TEMPLATE_INFO (tmpl) = DECL_TEMPLATE_INFO (decl);\n-\t      DECL_TEMPLATE_INFO (decl) = NULL_TREE;\n-\t    }\n+\t  /* A specialization of a member template of a template\n+\t     class. */\n+\t  SET_DECL_TEMPLATE_SPECIALIZATION (tmpl);\n+\t  DECL_TEMPLATE_INFO (tmpl) = DECL_TEMPLATE_INFO (decl);\n+\t  DECL_TEMPLATE_INFO (decl) = NULL_TREE;\n \t}\n     }\n   else\n@@ -892,6 +1191,31 @@ push_template_decl (decl)\n       \n       if (is_member_template (tmpl))\n \t{\n+\t  if (DECL_TEMPLATE_INFO (decl) && DECL_TI_ARGS (decl) \n+\t      && DECL_TEMPLATE_SPECIALIZATION (decl))\n+\t    {\n+\t      tree new_tmpl;\n+\n+\t      /* The declaration is a specialization of a member\n+\t\t template, declared outside the class.  Therefore, the\n+\t\t innermost template arguments will be NULL, so we\n+\t\t replace them with the arguments determined by the\n+\t\t earlier call to check_explicit_specialization.  */\n+\t      args = DECL_TI_ARGS (decl);\n+\n+\t      new_tmpl \n+\t\t= build_template_decl (decl, current_template_parms);\n+\t      DECL_TEMPLATE_RESULT (new_tmpl) = decl;\n+\t      TREE_TYPE (new_tmpl) = TREE_TYPE (decl);\n+\t      DECL_TI_TEMPLATE (decl) = new_tmpl;\n+\t      SET_DECL_TEMPLATE_SPECIALIZATION (new_tmpl);\n+\t      DECL_TEMPLATE_INFO (new_tmpl) = \n+\t\tperm_tree_cons (tmpl, args, NULL_TREE);\n+\n+\t      register_specialization (new_tmpl, tmpl, args);\n+\t      return;\n+\t    }\n+\t  \n \t  a = TREE_VEC_ELT (args, TREE_VEC_LENGTH (args) - 1);\n \t  t = DECL_INNERMOST_TEMPLATE_PARMS (DECL_TI_TEMPLATE (decl));\n \t  if (TREE_VEC_LENGTH (t) \n@@ -952,25 +1276,368 @@ push_template_decl (decl)\n   if (TREE_CODE (decl) == TYPE_DECL && DECL_ARTIFICIAL (decl))\n     {\n       CLASSTYPE_TEMPLATE_INFO (TREE_TYPE (tmpl)) = info;\n-      DECL_NAME (decl) = classtype_mangled_name (TREE_TYPE (decl));\n+      if (!ctx || TREE_CODE (ctx) != FUNCTION_DECL)\n+\tDECL_NAME (decl) = classtype_mangled_name (TREE_TYPE (decl));\n     }\n   else if (! DECL_LANG_SPECIFIC (decl))\n     cp_error (\"template declaration of `%#D'\", decl);\n   else\n     DECL_TEMPLATE_INFO (decl) = info;\n }\n \n+\n+/* Attempt to determine which of the overloaded functions given by\n+   FNS has the indicated TYPE.  If this cannot be determined\n+   unambiguously, return error_mark_node.  */\n+\n+static tree\n+determine_overloaded_function (type, fns)\n+     tree type;\n+     tree fns;\n+{\n+  tree fn;\n+\n+  my_friendly_assert (fns != NULL_TREE, 0);\n+  \n+  if (!is_overloaded_fn (fns))\n+    return error_mark_node;\n+  \n+  if (really_overloaded_fn (fns))\n+    {\n+      fn = instantiate_type (type, fns, 0);\n+      if (fn == error_mark_node)\n+\t/* We couldn't resolve the overloading.  */\n+\treturn error_mark_node;\n+    }\n+  else\n+    fn = get_first_fn (fns);\n+  \n+  my_friendly_assert (TREE_CODE (fn) == FUNCTION_DECL, 0);\n+\n+  return fn;\n+}\n+\n+\n+/* Attempt to convert the non-type template parameter EXPR to the\n+   indicated TYPE.  If the conversion is successful, return the\n+   converted value.  If the conversion is unsuccesful, return\n+   NULL_TREE if we issued an error message, or error_mark_node if we\n+   did not.  We issue error messages for out-and-out bad template\n+   parameters, but not simply because the conversion failed, since we\n+   might be just trying to do argument deduction.  By the time this\n+   function is called, neither TYPE nor EXPR may make use of template\n+   parameters.  */\n+\n+static tree\n+convert_nontype_parameter (type, expr)\n+     tree type;\n+     tree expr;\n+{\n+  tree expr_type = TREE_TYPE (expr);\n+\n+  /* A template-argument for a non-type, non-template\n+     template-parameter shall be one of:\n+\n+     --an integral constant-expression of integral or enumeration\n+     type; or\n+     \n+     --the name of a non-type template-parameter; or\n+     \n+     --the name of an object or function with external linkage,\n+     including function templates and function template-ids but\n+     excluding non- tatic class members, expressed as id-expression;\n+     or\n+     \n+     --the address of an object or function with external linkage,\n+     including function templates and function template-ids but\n+     excluding non-static class members, expressed as & id-expression\n+     where the & is optional if the name refers to a function or\n+     array; or\n+     \n+     --a pointer to member expressed as described in _expr.unary.op_.  */\n+\n+  if (INTEGRAL_TYPE_P (expr_type) \n+      || TYPE_PTRMEM_P (expr_type) \n+      || TYPE_PTRMEMFUNC_P (expr_type))\n+    {\n+      if (!TREE_CONSTANT (expr) \n+\t  /* FIXME: Should this case be handled by fold()?  Why not?  */\n+\t  && !(TREE_CODE (expr) == VAR_DECL && TREE_READONLY (expr)))\n+\t{\n+\t  cp_error (\"non-constant `%E' cannot be used as template argument\",\n+\t\t    expr);\n+\t  return NULL_TREE;\n+\t}\n+    }\n+  else if (TYPE_PTR_P (expr_type) \n+\t   /* If expr is the address of an overloaded function, we\n+\t      will get the unknown_type_node at this point.  */\n+\t   || expr_type == unknown_type_node)\n+    {\n+      tree referent;\n+\n+      if (TREE_CODE (expr) != ADDR_EXPR)\n+\t{\n+\tbad_argument:\n+\t  cp_error (\"`%E' is not a valid template argument\", expr);\n+\t  error (\"it must be %s%s with external linkage\",\n+\t\t TREE_CODE (TREE_TYPE (expr)) == POINTER_TYPE\n+\t\t ? \"a pointer to \" : \"\",\n+\t\t TREE_CODE (TREE_TYPE (TREE_TYPE (expr))) == FUNCTION_TYPE\n+\t\t ? \"a function\" : \"an object\");\n+\t  return NULL_TREE;\n+\t}\n+\n+      referent = TREE_OPERAND (expr, 0);\n+      STRIP_NOPS (referent);\n+      \n+      if (TREE_CODE (referent) == STRING_CST)\n+\t{\n+\t  cp_error (\"string literal %E is not a valid template argument\", \n+\t\t    referent);\n+\t  error (\"because it is the address of an object with static linkage\");\n+\t  return NULL_TREE;\n+\t}\n+\n+      if (is_overloaded_fn (referent))\n+\t/* We'll check that it has external linkage later.  */\n+\t;\n+      else if (TREE_CODE (referent) != VAR_DECL)\n+\tgoto bad_argument;\n+      else if (!TREE_PUBLIC (referent))\n+\t{\n+\t  cp_error (\"address of non-extern `%E' cannot be used as template argument\", referent); \n+\t  return error_mark_node;\n+\t}\n+    }\n+  else if (TREE_CODE (expr_type) == VAR_DECL)\n+    {\n+      if (!TREE_PUBLIC (expr))\n+\tgoto bad_argument;\n+    }\n+  else if (is_overloaded_fn (expr))\n+    /* OK for now.  We'll check that it has external linkage later.  */\n+    ;\n+  else \n+    {\n+      cp_error (\"object `%E' cannot be used as template argument\", expr);\n+      return NULL_TREE;\n+    }\n+\n+  switch (TREE_CODE (type))\n+    {\n+    case INTEGER_TYPE:\n+    case BOOLEAN_TYPE:\n+    case ENUMERAL_TYPE:\n+      /* For a non-type template-parameter of integral or enumeration\n+         type, integral promotions (_conv.prom_) and integral\n+         conversions (_conv.integral_) are applied. */\n+      if (!INTEGRAL_TYPE_P (expr_type))\n+\treturn error_mark_node;\n+      \n+      /* It's safe to call digest_init in this case; we know we're\n+\t just converting one integral constant expression to another.  */\n+      return digest_init (type, expr, (tree*) 0);\n+\n+    case POINTER_TYPE:\n+      {\n+\ttree type_pointed_to = TREE_TYPE (type);\n+ \n+\tif (TYPE_PTRMEM_P (type))\n+\t  /* For a non-type template-parameter of type pointer to data\n+\t     member, qualification conversions (_conv.qual_) are\n+\t     applied.  */\n+\t  return perform_qualification_conversions (type, expr);\n+\telse if (TREE_CODE (type_pointed_to) == FUNCTION_TYPE)\n+\t  { \n+\t    /* For a non-type template-parameter of type pointer to\n+\t       function, only the function-to-pointer conversion\n+\t       (_conv.func_) is applied.  If the template-argument\n+\t       represents a set of overloaded functions (or a pointer to\n+\t       such), the matching function is selected from the set\n+\t       (_over.over_).  */\n+\t    tree fns;\n+\t    tree fn;\n+\n+\t    if (TYPE_PTRFN_P (expr_type) ||\n+\t\texpr_type == unknown_type_node)\n+\t      fns = TREE_OPERAND (expr, 0);\n+\t    else\n+\t      fns = expr;\n+\n+\t    fn = determine_overloaded_function (type_pointed_to, fns);\n+\n+\t    if (fn == error_mark_node)\n+\t      return error_mark_node;\n+\n+\t    if (!TREE_PUBLIC (fn))\n+\t      {\n+\t\tif (really_overloaded_fn (fns))\n+\t\t  return error_mark_node;\n+\t\telse\n+\t\t  goto bad_argument;\n+\t      }\n+\n+\t    expr = build_unary_op (ADDR_EXPR, fn, 0);\n+\n+\t    my_friendly_assert (comptypes (type, TREE_TYPE (expr), 1), \n+\t\t\t\t0);\n+\t    return expr;\n+\t  }\n+\telse \n+\t  {\n+\t    /* For a non-type template-parameter of type pointer to\n+\t       object, qualification conversions (_conv.qual_) and the\n+\t       array-to-pointer conversion (_conv.array_) are applied.\n+\t       [Note: In particular, neither the null pointer conversion\n+\t       (_conv.ptr_) nor the derived-to-base conversion\n+\t       (_conv.ptr_) are applied.  Although 0 is a valid\n+\t       template-argument for a non-type template-parameter of\n+\t       integral type, it is not a valid template-argument for a\n+\t       non-type template-parameter of pointer type.]  */\n+\t    expr = perform_array_to_pointer_conversion (expr);\n+\n+\t    if (expr == error_mark_node)\n+\t      return error_mark_node;\n+\t    else\n+\t      return perform_qualification_conversions (type, expr);\n+\t  }\n+      }\n+      break;\n+\n+    case REFERENCE_TYPE:\n+      {\n+\ttree type_referred_to = TREE_TYPE (type);\n+\n+\tif (TREE_CODE (type_referred_to) == FUNCTION_TYPE)\n+\t  {\n+\t    /* For a non-type template-parameter of type reference to\n+\t      function, no conversions apply.  If the\n+\t      template-argument represents a set of overloaded\n+\t      functions, the matching function is selected from the\n+\t      set (_over.over_).  */\n+\t    tree fns = expr;\n+\t    tree fn;\n+\n+\t    fn = determine_overloaded_function (type_referred_to, fns);\n+\n+\t    if (!TREE_PUBLIC (fn))\n+\t      {\n+\t\tif (really_overloaded_fn (fns))\n+\t\t  /* Don't issue an error here; we might get a different\n+\t\t     function if the overloading had worked out\n+\t\t     differently.  */\n+\t\t  return error_mark_node;\n+\t\telse\n+\t\t  goto bad_argument;\n+\t      }\n+\n+\t    if (fn == error_mark_node)\n+\t      return error_mark_node;\n+\n+\t    my_friendly_assert (comptypes (type, TREE_TYPE (fn), 1),\n+\t\t\t\t0);\n+\n+\t    return fn;\n+\t  }\n+\telse\n+\t  {\n+\t    /* For a non-type template-parameter of type reference to\n+\t       object, no conversions apply.  The type referred to by the\n+\t       reference may be more cv-qualified than the (otherwise\n+\t       identical) type of the template-argument.  The\n+\t       template-parameter is bound directly to the\n+\t       template-argument, which must be an lvalue.  */\n+\t    if (!comptypes (TYPE_MAIN_VARIANT (expr_type),\n+\t\t\t    TYPE_MAIN_VARIANT (type), 1)\n+\t\t|| (TYPE_READONLY (expr_type) >\n+\t\t    TYPE_READONLY (type_referred_to))\n+\t\t|| (TYPE_VOLATILE (expr_type) >\n+\t\t    TYPE_VOLATILE (type_referred_to))\n+\t\t|| !real_lvalue_p (expr))\n+\t      return error_mark_node;\n+\t    else\n+\t      return expr;\n+\t  }\n+      }\n+      break;\n+\n+    case RECORD_TYPE:\n+      {\n+\ttree fns;\n+\ttree fn;\n+\n+\tmy_friendly_assert (TYPE_PTRMEMFUNC_P (type), 0);\n+\n+\t/* For a non-type template-parameter of type pointer to member\n+\t   function, no conversions apply.  If the template-argument\n+\t   represents a set of overloaded member functions, the\n+\t   matching member function is selected from the set\n+\t   (_over.over_).  */\n+\n+\tif (!TYPE_PTRMEMFUNC_P (expr_type) && \n+\t    expr_type != unknown_type_node)\n+\t  return error_mark_node;\n+\n+\tif (TREE_CODE (expr) == CONSTRUCTOR)\n+\t  {\n+\t    /* A ptr-to-member constant.  */\n+\t    if (!comptypes (type, expr_type, 1))\n+\t      return error_mark_node;\n+\t    else \n+\t      return expr;\n+\t  }\n+\n+\tif (TREE_CODE (expr) != ADDR_EXPR)\n+\t  return error_mark_node;\n+\n+\tfns = TREE_OPERAND (expr, 0);\n+\t\n+\tfn = determine_overloaded_function (TREE_TYPE (TREE_TYPE (type)), \n+\t\t\t\t\t    fns);\n+\t\n+\tif (fn == error_mark_node)\n+\t  return error_mark_node;\n+\n+\texpr = build_unary_op (ADDR_EXPR, fn, 0);\n+\t\n+\tmy_friendly_assert (comptypes (type, TREE_TYPE (expr), 1), \n+\t\t\t    0);\n+\treturn expr;\n+      }\n+      break;\n+\n+    default:\n+      /* All non-type parameters must have one of these types.  */\n+      my_friendly_abort (0);\n+      break;\n+    }\n+\n+  return error_mark_node;\n+}\n+\n /* Convert all template arguments to their appropriate types, and return\n    a vector containing the resulting values.  If any error occurs, return\n-   error_mark_node.  */\n+   error_mark_node, and, if COMPLAIN is non-zero, issue an error message.\n+   Some error messages are issued even if COMPLAIN is zero; for\n+   instance, if a template argument is composed from a local class. \n+\n+   If REQUIRE_ALL_ARGUMENTS is non-zero, all arguments must be\n+   provided in ARGLIST, or else trailing parameters must have default\n+   values.  If REQUIRE_ALL_ARGUMENTS is zero, we will attempt argument\n+   deduction for any unspecified trailing arguments.  */\n \n static tree\n-coerce_template_parms (parms, arglist, in_decl)\n+coerce_template_parms (parms, arglist, in_decl,\n+\t\t       complain,\n+\t\t       require_all_arguments)\n      tree parms, arglist;\n      tree in_decl;\n+     int complain;\n+     int require_all_arguments;\n {\n   int nparms, nargs, i, lost = 0;\n-  tree vec;\n+  tree vec = NULL_TREE;\n \n   if (arglist == NULL_TREE)\n     nargs = 0;\n@@ -983,12 +1650,19 @@ coerce_template_parms (parms, arglist, in_decl)\n \n   if (nargs > nparms\n       || (nargs < nparms\n+\t  && require_all_arguments\n \t  && TREE_PURPOSE (TREE_VEC_ELT (parms, nargs)) == NULL_TREE))\n     {\n-      error (\"incorrect number of parameters (%d, should be %d)\",\n-\t     nargs, nparms);\n-      if (in_decl)\n-\tcp_error_at (\"in template expansion for decl `%D'\", in_decl);\n+      if (complain) \n+\t{\n+\t  error (\"incorrect number of parameters (%d, should be %d)\",\n+\t\t nargs, nparms);\n+\t  \n+\t  if (in_decl)\n+\t    cp_error_at (\"in template expansion for decl `%D'\",\n+\t\t\t in_decl);\n+\t}\n+\n       return error_mark_node;\n     }\n \n@@ -997,9 +1671,11 @@ coerce_template_parms (parms, arglist, in_decl)\n   else\n     {\n       vec = make_tree_vec (nparms);\n+\n       for (i = 0; i < nparms; i++)\n \t{\n \t  tree arg;\n+\t  tree parm = TREE_VEC_ELT (parms, i);\n \n \t  if (arglist)\n \t    {\n@@ -1011,13 +1687,15 @@ coerce_template_parms (parms, arglist, in_decl)\n \t      else\n \t\targ = TREE_VALUE (arg);\n \t    }\n-\t  else if (TREE_CODE (TREE_VALUE (TREE_VEC_ELT (parms, i)))\n-\t\t   == TYPE_DECL)\n-\t    arg = tsubst (TREE_PURPOSE (TREE_VEC_ELT (parms, i)),\n-\t\t\t  vec, i, in_decl);\n+\t  else if (TREE_PURPOSE (parm) == NULL_TREE)\n+\t    {\n+\t      my_friendly_assert (!require_all_arguments, 0);\n+\t      break;\n+\t    }\n+\t  else if (TREE_CODE (TREE_VALUE (parm)) == TYPE_DECL)\n+\t    arg = tsubst (TREE_PURPOSE (parm), vec, i, in_decl);\n \t  else\n-\t    arg = tsubst_expr (TREE_PURPOSE (TREE_VEC_ELT (parms, i)),\n-\t\t\t       vec, i, in_decl);\n+\t    arg = tsubst_expr (TREE_PURPOSE (parm), vec, i, in_decl);\n \n \t  TREE_VEC_ELT (vec, i) = arg;\n \t}\n@@ -1029,6 +1707,20 @@ coerce_template_parms (parms, arglist, in_decl)\n       tree val = 0;\n       int is_type, requires_type;\n \n+      if (arg == NULL_TREE)\n+\t/* We're out of arguments.  */\n+\t{\n+\t  my_friendly_assert (!require_all_arguments, 0);\n+\t  break;\n+\t}\n+\n+      if (arg == error_mark_node)\n+\t{\n+\t  cp_error (\"template argument %d is invalid\", i + 1);\n+\t  lost++;\n+\t  continue;\n+\t}\n+\n       is_type = TREE_CODE_CLASS (TREE_CODE (arg)) == 't';\n       requires_type = TREE_CODE (parm) == TYPE_DECL;\n \n@@ -1037,6 +1729,7 @@ coerce_template_parms (parms, arglist, in_decl)\n \t{\n \t  cp_pedwarn (\"to refer to a type member of a template parameter,\");\n \t  cp_pedwarn (\"  use `typename %E'\", arg);\n+\n \t  arg = make_typename_type (TREE_OPERAND (arg, 0),\n \t\t\t\t    TREE_OPERAND (arg, 1));\n \t  is_type = 1;\n@@ -1045,13 +1738,16 @@ coerce_template_parms (parms, arglist, in_decl)\n \t{\n \t  if (in_decl)\n \t    {\n-\t      cp_error (\"type/value mismatch at argument %d in template parameter list for `%D'\",\n-\t\t\ti, in_decl);\n-\t      if (is_type)\n-\t\tcp_error (\"  expected a constant of type `%T', got `%T'\",\n-\t\t\t  TREE_TYPE (parm), arg);\n-\t      else\n-\t\tcp_error (\"  expected a type, got `%E'\", arg);\n+\t      if (complain)\n+\t\t{\n+\t\t  cp_error (\"type/value mismatch at argument %d in template parameter list for `%D'\",\n+\t\t\t    i + 1, in_decl);\n+\t\t  if (is_type)\n+\t\t    cp_error (\"  expected a constant of type `%T', got `%T'\",\n+\t\t\t      TREE_TYPE (parm), arg);\n+\t\t  else\n+\t\t    cp_error (\"  expected a type, got `%E'\", arg);\n+\t\t}\n \t    }\n \t  lost++;\n \t  TREE_VEC_ELT (vec, i) = error_mark_node;\n@@ -1076,70 +1772,30 @@ coerce_template_parms (parms, arglist, in_decl)\n \t{\n \t  tree t = tsubst (TREE_TYPE (parm), vec,\n \t\t\t   TREE_VEC_LENGTH (vec), in_decl);\n+\n \t  if (processing_template_decl)\n-\t    val = maybe_fold_nontype_arg (arg);\n+\t    arg = maybe_fold_nontype_arg (arg);\n+\n+\t  if (!uses_template_parms (arg) && !uses_template_parms (t))\n+\t    /* We used to call digest_init here.  However, digest_init\n+\t       will report errors, which we don't want when complain\n+\t       is zero.  More importantly, digest_init will try too\n+\t       hard to convert things: for example, `0' should not be\n+\t       converted to pointer type at this point according to\n+\t       the standard.  Accepting this is not merely an\n+\t       extension, since deciding whether or not these\n+\t       conversions can occur is part of determining which\n+\t       function template to call, or whether a given epxlicit\n+\t       argument specification is legal.  */\n+\t    val = convert_nontype_parameter (t, arg);\n \t  else\n \t    val = arg;\n \n-\t  if (!uses_template_parms (val) && !uses_template_parms (t))\n-\t    val = digest_init (t, val, (tree *) 0);\n-\n-\t  if (val == error_mark_node \n-\t      || (processing_template_decl && uses_template_parms (val)))\n-\t    ;\n-\n-\t  /* 14.2: Other template-arguments must be constant-expressions,\n-\t     addresses of objects or functions with external linkage, or of\n-\t     static class members.  */\n-\t  else if (IS_AGGR_TYPE (TREE_TYPE (val)))\n-\t    {\n-\t      cp_error (\"object `%E' cannot be used as template argument\", arg);\n-\t      val = error_mark_node;\n-\t    }\n-\t  else if (!TREE_CONSTANT (val))\n-\t    {\n-\t      cp_error (\"non-constant `%E' cannot be used as template argument\",\n-\t\t\targ);\n-\t      val = error_mark_node;\n-\t    }\n-\t  else if (POINTER_TYPE_P (TREE_TYPE (val))\n-\t\t   && ! integer_zerop (val)\n-\t\t   && TREE_CODE (TREE_TYPE (TREE_TYPE (val))) != OFFSET_TYPE\n-\t\t   && TREE_CODE (TREE_TYPE (TREE_TYPE (val))) != METHOD_TYPE)\n-\t    {\n-\t      t = val;\n-\t      STRIP_NOPS (t);\n-\t      if (TREE_CODE (t) == ADDR_EXPR)\n-\t\t{\n-\t\t  tree a = TREE_OPERAND (t, 0);\n-\t\t  STRIP_NOPS (a);\n-\t\t  if (TREE_CODE (a) == STRING_CST)\n-\t\t    {\n-\t\t      cp_error (\"string literal %E is not a valid template argument\", a);\n-\t\t      error (\"because it is the address of an object with static linkage\");\n-\t\t      val = error_mark_node;\n-\t\t    }\n-\t\t  else if (TREE_CODE (a) != VAR_DECL\n-\t\t\t   && TREE_CODE (a) != FUNCTION_DECL)\n-\t\t    goto bad;\n-\t\t  else if (! TREE_PUBLIC (a))\n-\t\t    {\n-\t\t      cp_error (\"address of non-extern `%E' cannot be used as template argument\", a);\n-\t\t      val = error_mark_node;\n-\t\t    }\n-\t\t}\n-\t      else\n-\t\t{\n-\t\tbad:\n-\t\t  cp_error (\"`%E' is not a valid template argument\", t);\n-\t\t  error (\"it must be %s%s with external linkage\",\n-\t\t\t TREE_CODE (TREE_TYPE (val)) == POINTER_TYPE\n-\t\t\t ? \"a pointer to \" : \"\",\n-\t\t\t TREE_CODE (TREE_TYPE (TREE_TYPE (val))) == FUNCTION_TYPE\n-\t\t\t ? \"a function\" : \"an object\");\n-\t\t  val = error_mark_node;\n-\t\t}\n-\t    }\n+\t  if (val == NULL_TREE)\n+\t    val = error_mark_node;\n+\t  else if (val == error_mark_node && complain)\n+\t    cp_error (\"could not convert template argument `%E' to `%T'\", \n+\t\t      arg, t);\n \t}\n \n       if (val == error_mark_node)\n@@ -1192,9 +1848,10 @@ comp_template_args (oldargs, newargs)\n    for the instantiation.  */\n \n static char *\n-mangle_class_name_for_template (name, parms, arglist)\n+mangle_class_name_for_template (name, parms, arglist, ctx)\n      char *name;\n      tree parms, arglist;\n+     tree ctx;\n {\n   static struct obstack scratch_obstack;\n   static char *scratch_firstobj;\n@@ -1219,6 +1876,12 @@ mangle_class_name_for_template (name, parms, arglist)\n #define cat(s)\tobstack_grow (&scratch_obstack, (s), strlen (s))\n #endif\n \n+  if (ctx)\n+    {\n+      char* s = fndecl_as_string(ctx, 0);\n+      cat (s);\n+      cat (\"::\");\n+    }\n   cat (name);\n   ccat ('<');\n   nparms = TREE_VEC_LENGTH (parms);\n@@ -1284,7 +1947,9 @@ classtype_mangled_name (t)\n       char *mangled_name = mangle_class_name_for_template\n \t(IDENTIFIER_POINTER (name),\n \t DECL_INNERMOST_TEMPLATE_PARMS (CLASSTYPE_TI_TEMPLATE (t)),\n-\t CLASSTYPE_TI_ARGS (t));\n+\t CLASSTYPE_TI_ARGS (t), \n+\t (DECL_CONTEXT (t) && TREE_CODE (t) == FUNCTION_DECL) ? \n+\t DECL_CONTEXT (t) : NULL_TREE);\n       tree id = get_identifier (mangled_name);\n       IDENTIFIER_TEMPLATE (id) = name;\n       return id;\n@@ -1346,12 +2011,17 @@ lookup_template_function (fns, arglist)\n    to keep it from being reclaimed when the decl storage is reclaimed.\n \n    IN_DECL, if non-NULL, is the template declaration we are trying to\n-   instantiate.  */\n+   instantiate.  \n+\n+   If the template class is really a local class in a template\n+   function, then the FUNCTION_CONTEXT is the function in which it is\n+   being instantiated.  */\n \n tree\n-lookup_template_class (d1, arglist, in_decl)\n+lookup_template_class (d1, arglist, in_decl, function_context)\n      tree d1, arglist;\n      tree in_decl;\n+     tree function_context;\n {\n   tree template, parmlist;\n   char *mangled_name;\n@@ -1394,7 +2064,8 @@ lookup_template_class (d1, arglist, in_decl)\n     {\n       parmlist = DECL_INNERMOST_TEMPLATE_PARMS (template);\n \n-      arglist = coerce_template_parms (parmlist, arglist, template);\n+      arglist = coerce_template_parms (parmlist, arglist, template,\n+\t\t\t\t       1, 1);\n       if (arglist == error_mark_node)\n \treturn error_mark_node;\n       if (uses_template_parms (arglist))\n@@ -1425,18 +2096,35 @@ lookup_template_class (d1, arglist, in_decl)\n \t}\n \n       mangled_name = mangle_class_name_for_template (IDENTIFIER_POINTER (d1),\n-\t\t\t\t\t\t     parmlist, arglist);\n+\t\t\t\t\t\t     parmlist,\n+\t\t\t\t\t\t     arglist,\n+\t\t\t\t\t\t     function_context);\n       id = get_identifier (mangled_name);\n       IDENTIFIER_TEMPLATE (id) = d1;\n \n       maybe_push_to_top_level (uses_template_parms (arglist));\n       t = xref_tag_from_type (TREE_TYPE (template), id, 1);\n+\n+      if (function_context != NULL_TREE)\n+\t{\n+\t  /* Set up the context for the type_decl correctly.  Note\n+\t     that we must clear DECL_ASSEMBLER_NAME to fool\n+\t     build_overload_name into creating a new name.  */\n+\t  tree type_decl = TYPE_STUB_DECL (t);\n+\n+\t  TYPE_CONTEXT (t) = function_context;\n+\t  DECL_CONTEXT (type_decl) = function_context;\n+\t  DECL_ASSEMBLER_NAME (type_decl) = DECL_NAME (type_decl);\n+\t  DECL_ASSEMBLER_NAME (type_decl) = \n+\t    get_identifier (build_overload_name (t, 1, 1));\n+\t}\n+\n       pop_from_top_level ();\n     }\n   else\n     {\n       tree ctx = lookup_template_class (TYPE_CONTEXT (TREE_TYPE (template)),\n-\t\t\t\t\targlist, in_decl);\n+\t\t\t\t\targlist, in_decl, NULL_TREE);\n       id = d1;\n       arglist = CLASSTYPE_TI_ARGS (ctx);\n \n@@ -2114,7 +2802,15 @@ tsubst (t, args, nargs, in_decl)\n       if (uses_template_parms (t))\n \t{\n \t  tree argvec = tsubst (CLASSTYPE_TI_ARGS (t), args, nargs, in_decl);\n-\t  tree r = lookup_template_class (t, argvec, in_decl);\n+\t  tree context;\n+\t  tree r;\n+\n+\t  context = (TYPE_CONTEXT (t) \n+\t\t     && TREE_CODE (TYPE_CONTEXT (t)) == FUNCTION_DECL)\n+\t    ? tsubst (TYPE_CONTEXT (t), args, nargs, in_decl) : NULL_TREE;\n+\n+\t  r = lookup_template_class (t, argvec, in_decl, context);\n+\n \t  return cp_build_type_variant (r, TYPE_READONLY (t),\n \t\t\t\t\tTYPE_VOLATILE (t));\n \t}\n@@ -2230,12 +2926,9 @@ tsubst (t, args, nargs, in_decl)\n \tint i;\n \n \t/* We might already have an instance of this template. */\n-\ttree instances = DECL_TEMPLATE_INSTANTIATIONS (t);\n-\ttree ctx = tsubst (DECL_CLASS_CONTEXT (t), args, nargs, in_decl); \n-\t  \n-\tfor (; instances; instances = TREE_CHAIN (instances))\n-\t  if (DECL_CLASS_CONTEXT (TREE_VALUE (instances)) == ctx)\n-\t    return TREE_VALUE (instances);\n+\tspec = retrieve_specialization (t, args);\n+\tif (spec != NULL_TREE)\n+\t  return spec;\n \n \t/* Make a new template decl.  It will be similar to the\n \t   original, but will record the current template arguments. \n@@ -2265,12 +2958,64 @@ tsubst (t, args, nargs, in_decl)\n \t     parms = TREE_CHAIN (parms))\n \t  TREE_CHAIN (parms) = copy_node (TREE_CHAIN (parms));\n \n-\t/* Record this partial instantiation. */\n-\tDECL_TEMPLATE_INSTANTIATIONS (t)\n-\t  = perm_tree_cons (NULL_TREE, tmpl,\n-\t\t\t    DECL_TEMPLATE_INSTANTIATIONS (t));\n-\n+\t/* What should we do with the specializations of this member\n+\t   template?  Are they specializations of this new template,\n+\t   or instantiations of the templates they previously were?\n+\t   this new template?  And where should their\n+\t   DECL_TI_TEMPLATES point?  */ \n \tDECL_TEMPLATE_SPECIALIZATIONS (tmpl) = NULL_TREE;\n+\tfor (spec = DECL_TEMPLATE_SPECIALIZATIONS (t);\n+\t     spec != NULL_TREE;\n+\t     spec = TREE_CHAIN (spec))\n+\t  {\n+\t    /* It helps to consider example here.  Consider:\n+\n+\t       template <class T>\n+\t       struct S {\n+\t         template <class U>\n+\t\t void f(U u);\n+\n+\t\t template <>\n+\t\t void f(T* t) {}\n+\t       };\n+\t       \n+\t       Now, for example, we are instantiating S<int>::f(U u).  \n+\t       We want to make a template:\n+\n+\t       template <class U>\n+\t       void S<int>::f(U);\n+\n+\t       It will have a specialization, for the case U = int*, of\n+\t       the form:\n+\n+\t       template <>\n+\t       void S<int>::f<int*>(int*);\n+\n+\t       This specialization will be an instantiation of\n+\t       the specialization given in the declaration of S, with\n+\t       argument list int*.  */\n+\n+\t    tree fn = TREE_VALUE (spec);\n+\t    tree spec_args;\n+\t    tree new_fn;\n+\n+\t    if (!DECL_TEMPLATE_SPECIALIZATION (fn))\n+\t      /* Instantiations are on the same list, but they're of\n+\t\t no concern to us.  */\n+\t      continue;\n+\n+\t    spec_args = tsubst (DECL_TI_ARGS (fn), args, nargs,\n+\t\t\t\tin_decl); \n+\t    new_fn = tsubst (DECL_RESULT (fn), args, nargs,\n+\t\t\t     in_decl); \n+\t    DECL_TEMPLATE_SPECIALIZATIONS (tmpl) = \n+\t      perm_tree_cons (spec_args, new_fn, \n+\t\t\t      DECL_TEMPLATE_SPECIALIZATIONS (tmpl));\n+\t  }\n+\n+\t/* Record this partial instantiation.  */\n+\tregister_specialization (tmpl, t, args);\n+\n \treturn tmpl;\n       }\n \n@@ -2302,13 +3047,10 @@ tsubst (t, args, nargs, in_decl)\n \tif (DECL_TEMPLATE_INFO (t) != NULL_TREE)\n \t  {\n \t    tree tmpl = DECL_TI_TEMPLATE (t);\n-\t    tree decls = DECL_TEMPLATE_INSTANTIATIONS (tmpl);\n+\t    tree spec = retrieve_specialization (tmpl, args);\n \n-\t    for (; decls; decls = TREE_CHAIN (decls))\n-\t      if (TREE_TYPE (TREE_VALUE (decls)) == type\n-\t\t  && DECL_CLASS_CONTEXT (TREE_VALUE (decls)) == ctx\n-\t\t  && comp_template_args (TREE_PURPOSE (decls), args))\n-\t\treturn TREE_VALUE (decls);\n+\t    if (spec)\n+\t      return spec;\n \t  }\n \n \t/* We do NOT check for matching decls pushed separately at this\n@@ -2390,16 +3132,46 @@ tsubst (t, args, nargs, in_decl)\n \t\t   we re-use the parms from the original template, which\n \t\t   have level 2.  When this is fixed we can remove the\n \t\t   add_to_template_args from instantiate_template.  */\n-\t\ttree tparms = DECL_TEMPLATE_PARMS (tmpl);\n-\n-\t\twhile (tparms && TREE_CHAIN (tparms) != NULL_TREE)\n-\t\t  tparms = TREE_CHAIN (tparms);\n-\n+\t\ttree tparms;\n+\t\ttree targs;\n+\n+\t\tif (!DECL_TEMPLATE_SPECIALIZATION (tmpl)) \n+\t\t  {\n+\t\t    tparms = DECL_TEMPLATE_PARMS (tmpl);\n+\n+\t\t    while (tparms && TREE_CHAIN (tparms) != NULL_TREE)\n+\t\t      tparms = TREE_CHAIN (tparms);\n+\t\t    \n+\t\t    targs = \n+\t\t      (TREE_CODE (TREE_VEC_ELT (args, 0)) == TREE_VEC \n+\t\t       ? TREE_VEC_ELT (args, TREE_VEC_LENGTH (args) - 1)\n+\t\t       : args); \n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    /* If the template is a specialization, then it is\n+\t\t       a member template specialization.  We have\n+\t\t       something like:\n+\n+\t\t       template <class T> struct S {\n+\t\t         template <int i> void f();\n+\t\t\t template <> void f<7>();\n+\t\t       };\n+\n+\t\t       and now we are forming S<double>::f<7>.\n+\t\t       Therefore, the template parameters of interest\n+\t\t       are those that are specialized by the template\n+\t\t       (i.e., the int), not those we are using to\n+\t\t       instantiate the template, i.e. the double.  */\n+\t\t    tparms = DECL_TEMPLATE_PARMS (DECL_TI_TEMPLATE (tmpl));\n+\t\t    targs = DECL_TI_ARGS (tmpl);\n+\t\t  }\n+\t\t    \n \t\tmy_friendly_assert (tparms != NULL_TREE\n \t\t\t\t    && TREE_CODE (tparms) == TREE_LIST,\n \t\t\t\t    0);\n \t\ttparms = TREE_VALUE (tparms);\n-\n+\t\t \n \t\targ_types = TYPE_ARG_TYPES (TREE_TYPE (tmpl));\n \t\tif (member && TREE_CODE (type) == FUNCTION_TYPE)\n \t\t  arg_types = hash_tree_chain \n@@ -2410,11 +3182,7 @@ tsubst (t, args, nargs, in_decl)\n \t\t  = build_template_decl_overload \n \t\t  (DECL_NAME (r), arg_types, \n \t\t   TREE_TYPE (TREE_TYPE (tmpl)),\n-\t\t   tparms,\n-\t\t   TREE_CODE (TREE_VEC_ELT (args, 0)) == TREE_VEC \n-\t\t   ? TREE_VEC_ELT (args, TREE_VEC_LENGTH (args) - 1) :\n-\t\t   args, \n-\t\t   member);\n+\t\t   tparms, targs, member);\n \t      }\n \t  }\n \tDECL_RTL (r) = 0;\n@@ -2426,7 +3194,7 @@ tsubst (t, args, nargs, in_decl)\n \tDECL_INITIAL (r) = NULL_TREE;\n \n \tTREE_STATIC (r) = 0;\n-\tTREE_PUBLIC (r) = 1;\n+\tTREE_PUBLIC (r) = TREE_PUBLIC (t);\n \tDECL_EXTERNAL (r) = 1;\n \tDECL_INTERFACE_KNOWN (r) = 0;\n \tDECL_DEFER_OUTPUT (r) = 0;\n@@ -2471,22 +3239,32 @@ tsubst (t, args, nargs, in_decl)\n \tif (DECL_TEMPLATE_INFO (t) != NULL_TREE)\n \t  {\n \t    tree tmpl = DECL_TI_TEMPLATE (t);\n-\t    tree *declsp = &DECL_TEMPLATE_INSTANTIATIONS (tmpl);\n \t    tree argvec = tsubst (DECL_TI_ARGS (t), args, nargs, in_decl);\n \n \t    if (DECL_TEMPLATE_INFO (tmpl) && DECL_TI_ARGS (tmpl))\n-\t      argvec = add_to_template_args (DECL_TI_ARGS (tmpl), argvec);\n+\t      {\n+\t\tif (!DECL_TEMPLATE_SPECIALIZATION (tmpl))\n+\t\t  argvec = add_to_template_args (DECL_TI_ARGS (tmpl), argvec);\n+\t\telse\n+\t\t  /* In this case, we are instantiating a\n+\t\t     specialization.  The innermost template args are\n+\t\t     already given by the specialization.  */\n+\t\t  argvec = add_to_template_args (argvec, DECL_TI_ARGS (tmpl));\n+\t      }\n \n \t    DECL_TEMPLATE_INFO (r) = perm_tree_cons (tmpl, argvec, NULL_TREE);\n-\t    *declsp = perm_tree_cons (argvec, r, *declsp);\n \n \t    /* If we have a preexisting version of this function, don't expand\n \t       the template version, use the other instead.  */\n-\t    if (TREE_STATIC (r) || DECL_TEMPLATE_SPECIALIZATION (r))\n+\t    if (TREE_STATIC (r) || \n+\t\t(DECL_TEMPLATE_SPECIALIZATION (r) &&\n+\t\t /* FIXME: Explain this condition.  */\n+\t\t !DECL_TEMPLATE_SPECIALIZATION (tmpl)))\n \t      SET_DECL_TEMPLATE_SPECIALIZATION (r);\n \t    else\n \t      SET_DECL_IMPLICIT_INSTANTIATION (r);\n \n+\t    register_specialization (r, tmpl, argvec);\n \t  }\n \n \t/* Like grokfndecl.  If we don't do this, pushdecl will mess up our\n@@ -3469,14 +4247,11 @@ instantiate_template (tmpl, targ_ptr)\n \n   if (DECL_FUNCTION_TEMPLATE_P (tmpl))\n     {\n-      tree specs;\n+      /* Check to see if we already have this specialization.  */\n+      tree spec = retrieve_specialization (tmpl, targ_ptr);\n       \n-      /* Check to see if there is a matching specialization. */\n-      for (specs = DECL_TEMPLATE_SPECIALIZATIONS (tmpl);\n-\t   specs != NULL_TREE;\n-\t   specs = TREE_CHAIN (specs))\n-\tif (comp_template_args (TREE_PURPOSE (specs), targ_ptr))\n-\t  return TREE_VALUE (specs);\n+      if (spec != NULL_TREE)\n+\treturn spec;\n     }\n \n   push_obstacks (&permanent_obstack, &permanent_obstack);\n@@ -3605,22 +4380,38 @@ type_unification (tparms, targs, parms, args, targs_in, nsubsts,\n      int *nsubsts, strict, allow_incomplete;\n {\n   int ntparms = TREE_VEC_LENGTH (tparms);\n-  tree t;\n+  tree arg;\n+  tree parm;\n   int i;\n   int r;\n \n   bzero ((char *) targs, sizeof (tree) * ntparms);\n \n-  /* Insert any explicit template arguments.  They are encoded as the\n-     operands of NOP_EXPRs so that unify can tell that they are\n-     explicit arguments.  */\n-  for (i = 0, t = targs_in; t != NULL_TREE; t = TREE_CHAIN (t), ++i)\n-    targs[i] = build1 (NOP_EXPR, NULL_TREE, TREE_VALUE (t));\n+  if (targs_in != NULL_TREE)\n+    {\n+      tree arg_vec;\n+      arg_vec = coerce_template_parms (tparms, targs_in, NULL_TREE, 0,\n+\t\t\t\t       0);\n+\n+      if (arg_vec == error_mark_node)\n+\treturn 1;\n \n+      for (i = 0; \n+\t   i < TREE_VEC_LENGTH (arg_vec) \n+\t     && TREE_VEC_ELT (arg_vec, i) != NULL_TREE; \n+\t   ++i)\n+\t/* Insert the template argument.  It is encoded as the operands\n+\t   of NOP_EXPRs so that unify can tell that it is an explicit\n+\t   arguments.  */\n+\ttargs[i] = build1 (NOP_EXPR, NULL_TREE, TREE_VEC_ELT (arg_vec, i));\n+    }\n+  \n   r = type_unification_real (tparms, targs, parms, args, nsubsts, 0,\n \t\t\t     strict, allow_incomplete); \n \n-  for (i = 0, t = targs_in; t != NULL_TREE; t = TREE_CHAIN (t), ++i)\n+  for (i = 0, arg = targs_in; \n+       arg != NULL_TREE; \n+       arg = TREE_CHAIN (arg), ++i)\n     if (TREE_CODE (targs[i]) == NOP_EXPR)\n       targs[i] = TREE_OPERAND (targs[i], 0);\n \n@@ -4032,7 +4823,11 @@ mark_decl_instantiated (result, extern_p)\n {\n   if (DECL_TEMPLATE_INSTANTIATION (result))\n     SET_DECL_EXPLICIT_INSTANTIATION (result);\n-  TREE_PUBLIC (result) = 1;\n+\n+  if (TREE_CODE (result) != FUNCTION_DECL)\n+    /* The TREE_PUBLIC flag for function declarations will have been\n+       set correctly by tsubst.  */\n+    TREE_PUBLIC (result) = 1;\n \n   if (! extern_p)\n     {\n@@ -4041,7 +4836,7 @@ mark_decl_instantiated (result, extern_p)\n \n       /* For WIN32 we also want to put explicit instantiations in\n \t linkonce sections.  */\n-      if (supports_one_only () && ! SUPPORTS_WEAK)\n+      if (supports_one_only () && ! SUPPORTS_WEAK && TREE_PUBLIC (result))\n \tmake_decl_one_only (result);\n     }\n   else if (TREE_CODE (result) == FUNCTION_DECL)\n@@ -4290,11 +5085,12 @@ do_decl_instantiation (declspecs, declarator, storage)\n     }\n   else if (DECL_FUNCTION_MEMBER_P (decl))\n     {\n-      if (DECL_TEMPLATE_INSTANTIATION (decl))\n+      if (DECL_TEMPLATE_INSTANTIATION (decl) && DECL_RTL (decl))\n \tresult = decl;\n       else if (name = DECL_ASSEMBLER_NAME (decl),\n \t       fn = IDENTIFIER_GLOBAL_VALUE (name),\n-\t       fn && DECL_TEMPLATE_INSTANTIATION (fn))\n+\t       fn && DECL_TEMPLATE_INSTANTIATION (fn)\n+\t       && DECL_RTL (fn))\n \tresult = fn;\n       else \n \t{\n@@ -4517,14 +5313,11 @@ instantiate_decl (d)\n \n   if (TREE_CODE (d) == FUNCTION_DECL) \n     {\n-      tree specs;\n-\n-      /* Check to see if there is a matching specialization. */\n-      for (specs = DECL_TEMPLATE_SPECIALIZATIONS (tmpl);\n-\t   specs != NULL_TREE;\n-\t   specs = TREE_CHAIN (specs))\n-\tif (comp_template_args (TREE_PURPOSE (specs), args))\n-\t  return TREE_VALUE (specs);\n+      tree spec = retrieve_specialization (tmpl, args);\n+      \n+      if (spec != NULL_TREE \n+\t  && DECL_TEMPLATE_SPECIALIZATION (spec))\n+\treturn spec;\n     }\n \n   /* This needs to happen before any tsubsting.  */\n@@ -4727,6 +5520,24 @@ add_tree (t)\n   last_tree = TREE_CHAIN (last_tree) = t;\n }\n \n+\n+void\n+begin_tree ()\n+{\n+  saved_trees = tree_cons (NULL_TREE, last_tree, saved_trees);\n+  last_tree = NULL_TREE;\n+}\n+\n+\n+void \n+end_tree ()\n+{\n+  my_friendly_assert (saved_trees != NULL_TREE, 0);\n+\n+  last_tree = TREE_VALUE (saved_trees);\n+  saved_trees = TREE_CHAIN (saved_trees);\n+}\n+\n /* D is an undefined function declaration in the presence of templates with\n    the same name, listed in FNS.  If one of them can produce D as an\n    instantiation, remember this so we can instantiate it at EOF if D has"}, {"sha": "365ee4d8d2dabfa9b2f2fdc43fa09954d4dde598", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/756506468674bd03d9a3b8fa25f8b33bd49878b3/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/756506468674bd03d9a3b8fa25f8b33bd49878b3/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=756506468674bd03d9a3b8fa25f8b33bd49878b3", "patch": "@@ -1464,7 +1464,11 @@ mapcar (t, func)\n     case VAR_DECL:\n     case FUNCTION_DECL:\n     case CONST_DECL:\n-      break;\n+      /* Rather than aborting, return error_mark_node.  This allows us\n+\t to report a sensible error message on code like this:\n+\n+\t void g() { int i; f<i>(7); } */\n+      return error_mark_node;\n \n     case PARM_DECL:\n       {"}, {"sha": "e3c426d9a325bbdc11380aa9565372db7c0f13a4", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/756506468674bd03d9a3b8fa25f8b33bd49878b3/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/756506468674bd03d9a3b8fa25f8b33bd49878b3/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=756506468674bd03d9a3b8fa25f8b33bd49878b3", "patch": "@@ -4481,9 +4481,11 @@ build_unary_op (code, xarg, noconvert)\n \t  /* We don't require a match here; it's possible that the\n \t     context (like a cast to a particular type) will resolve\n \t     the particular choice of template.  */\n-\t  fn = determine_explicit_specialization (arg, NULL_TREE,\n-\t\t\t\t\t\t  &targs,\n-\t\t\t\t\t\t  0, 0);\n+\t  fn = determine_specialization (arg,\n+\t\t\t\t\t NULL_TREE,\n+\t\t\t\t\t &targs, \n+\t\t\t\t\t 0, \n+\t\t\t\t\t 0);\n \n \t  if (fn)\n \t    {"}, {"sha": "92cbcc34aa8e0139793d931131185d0463e1c116", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/756506468674bd03d9a3b8fa25f8b33bd49878b3/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/756506468674bd03d9a3b8fa25f8b33bd49878b3/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=756506468674bd03d9a3b8fa25f8b33bd49878b3", "patch": "@@ -247,6 +247,10 @@ incomplete_type_error (value, type)\n \t  error (\"invalid use of member type (did you forget the `&' ?)\");\n \t  return;\n \n+\tcase TEMPLATE_TYPE_PARM:\n+\t  error (\"invalid use of template type parameter\");\n+\t  return;\n+\n \tdefault:\n \t  my_friendly_abort (108);\n \t}"}]}