{"sha": "c43137e800bb9ca2ecda0a6b6189e0eb5c22f0d7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzQzMTM3ZTgwMGJiOWNhMmVjZGEwYTZiNjE4OWUwZWI1YzIyZjBkNw==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-12-05T23:09:51Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-12-05T23:09:51Z"}, "message": "runtime: add precise stack scan support\n    \n    This CL adds support of precise stack scan using stack maps to\n    the runtime. The stack maps are generated by the compiler (if\n    supported). Each safepoint is associated with a (real or dummy)\n    landing pad, and its \"type info\" in the exception table is a\n    pointer to the stack map. When a stack is scanned, the stack map\n    is found by the stack unwinding code by inspecting the exception\n    table (LSDA).\n    \n    For precise stack scan we need to unwind the stack. There are\n    three cases:\n    \n    - If a goroutine is scanning its own stack, it can unwind the\n      stack and scan the frames.\n    \n    - If a goroutine is scanning another, stopped, goroutine, it\n      cannot directly unwind the target stack. We handle this by\n      switching (runtime.gogo) to the target g, letting it unwind\n      and scan the stack, and switch back.\n    \n    - If we are scanning a goroutine that is blocked in a syscall,\n      we send a signal to the target goroutine's thread, and let the\n      signal handler unwind and scan the stack. Extra care is needed\n      as this races with enter/exit syscall.\n    \n    Currently this is only implemented on linux.\n    \n    Reviewed-on: https://go-review.googlesource.com/c/140518\n\nFrom-SVN: r266832", "tree": {"sha": "df5d750d82dff84b98ec03163cc8c2b2552a559a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/df5d750d82dff84b98ec03163cc8c2b2552a559a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c43137e800bb9ca2ecda0a6b6189e0eb5c22f0d7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c43137e800bb9ca2ecda0a6b6189e0eb5c22f0d7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c43137e800bb9ca2ecda0a6b6189e0eb5c22f0d7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c43137e800bb9ca2ecda0a6b6189e0eb5c22f0d7/comments", "author": null, "committer": null, "parents": [{"sha": "e4a9a572770b48375561c7ca424eb94eb45a9fcb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4a9a572770b48375561c7ca424eb94eb45a9fcb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e4a9a572770b48375561c7ca424eb94eb45a9fcb"}], "stats": {"total": 596, "additions": 573, "deletions": 23}, "files": [{"sha": "b71d71ff42c507ddef2676b73e5ab20ac0de8efd", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43137e800bb9ca2ecda0a6b6189e0eb5c22f0d7/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43137e800bb9ca2ecda0a6b6189e0eb5c22f0d7/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=c43137e800bb9ca2ecda0a6b6189e0eb5c22f0d7", "patch": "@@ -1,4 +1,4 @@\n-d3a98b7a9ea8032be22ebb3ea2f389ce22669d53\n+edc7e7172e674b8c7e9c3caa30e24280cd289a9c\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "631c4d7133b7e69dbc6442196b496535366f9ebd", "filename": "libgo/go/runtime/mgcmark.go", "status": "modified", "additions": 115, "deletions": 6, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43137e800bb9ca2ecda0a6b6189e0eb5c22f0d7/libgo%2Fgo%2Fruntime%2Fmgcmark.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43137e800bb9ca2ecda0a6b6189e0eb5c22f0d7/libgo%2Fgo%2Fruntime%2Fmgcmark.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmgcmark.go?ref=c43137e800bb9ca2ecda0a6b6189e0eb5c22f0d7", "patch": "@@ -664,7 +664,10 @@ func gcFlushBgCredit(scanWork int64) {\n }\n \n // We use a C function to find the stack.\n-func doscanstack(*g, *gcWork)\n+// Returns whether we succesfully scanned the stack.\n+func doscanstack(*g, *gcWork) bool\n+\n+func doscanstackswitch(*g, *g)\n \n // scanstack scans gp's stack, greying all pointers found on the stack.\n //\n@@ -691,7 +694,16 @@ func scanstack(gp *g, gcw *gcWork) {\n \t\treturn\n \tcase _Grunning:\n \t\t// ok for gccgo, though not for gc.\n-\tcase _Grunnable, _Gsyscall, _Gwaiting:\n+\t\tif usestackmaps {\n+\t\t\tprint(\"runtime: gp=\", gp, \", goid=\", gp.goid, \", gp->atomicstatus=\", readgstatus(gp), \"\\n\")\n+\t\t\tthrow(\"scanstack: goroutine not stopped\")\n+\t\t}\n+\tcase _Gsyscall:\n+\t\tif usestackmaps {\n+\t\t\tprint(\"runtime: gp=\", gp, \", goid=\", gp.goid, \", gp->atomicstatus=\", readgstatus(gp), \"\\n\")\n+\t\t\tthrow(\"scanstack: goroutine in syscall\")\n+\t\t}\n+\tcase _Grunnable, _Gwaiting:\n \t\t// ok\n \t}\n \n@@ -701,15 +713,64 @@ func scanstack(gp *g, gcw *gcWork) {\n \t}\n \n \t// Scan the stack.\n-\tdoscanstack(gp, gcw)\n+\tif usestackmaps {\n+\t\tg := getg()\n+\t\tif g == gp {\n+\t\t\t// Scan its own stack.\n+\t\t\tdoscanstack(gp, gcw)\n+\t\t} else if gp.entry != nil {\n+\t\t\t// This is a newly created g that hasn't run. No stack to scan.\n+\t\t} else {\n+\t\t\t// Scanning another g's stack. We need to switch to that g\n+\t\t\t// to unwind its stack. And switch back after scan.\n+\t\t\tscanstackswitch(gp, gcw)\n+\t\t}\n+\t} else {\n+\t\tdoscanstack(gp, gcw)\n \n-\t// Conservatively scan the saved register values.\n-\tscanstackblock(uintptr(unsafe.Pointer(&gp.gcregs)), unsafe.Sizeof(gp.gcregs), gcw)\n-\tscanstackblock(uintptr(unsafe.Pointer(&gp.context)), unsafe.Sizeof(gp.context), gcw)\n+\t\t// Conservatively scan the saved register values.\n+\t\tscanstackblock(uintptr(unsafe.Pointer(&gp.gcregs)), unsafe.Sizeof(gp.gcregs), gcw)\n+\t\tscanstackblock(uintptr(unsafe.Pointer(&gp.context)), unsafe.Sizeof(gp.context), gcw)\n+\t}\n \n \tgp.gcscanvalid = true\n }\n \n+// scanstackswitch scans gp's stack by switching (gogo) to gp and\n+// letting it scan its own stack, and switching back upon finish.\n+//\n+//go:nowritebarrier\n+func scanstackswitch(gp *g, gcw *gcWork) {\n+\tg := getg()\n+\n+\t// We are on the system stack which prevents preemption. But\n+\t// we are going to switch to g stack. Lock m to block preemption.\n+\tmp := acquirem()\n+\n+\t// The doscanstackswitch function will modify the current g's\n+\t// context. Preserve it.\n+\t// The stack scan code may call systemstack, which will modify\n+\t// gp's context. Preserve it as well so we can resume gp.\n+\tcontext := g.context\n+\tstackcontext := g.stackcontext\n+\tcontext2 := gp.context\n+\tstackcontext2 := gp.stackcontext\n+\n+\tgp.scangcw = uintptr(unsafe.Pointer(gcw))\n+\tgp.scang = uintptr(unsafe.Pointer(g))\n+\tdoscanstackswitch(g, gp)\n+\n+\t// Restore the contexts.\n+\tg.context = context\n+\tg.stackcontext = stackcontext\n+\tgp.context = context2\n+\tgp.stackcontext = stackcontext2\n+\tgp.scangcw = 0\n+\t// gp.scang is already cleared in C code.\n+\n+\treleasem(mp)\n+}\n+\n type gcDrainFlags int\n \n const (\n@@ -1064,6 +1125,10 @@ func scanobject(b uintptr, gcw *gcWork) {\n // scanblock, but we scan the stack conservatively, so there is no\n // bitmask of pointers.\n func scanstackblock(b, n uintptr, gcw *gcWork) {\n+\tif usestackmaps {\n+\t\tthrow(\"scanstackblock: conservative scan but stack map is used\")\n+\t}\n+\n \tfor i := uintptr(0); i < n; i += sys.PtrSize {\n \t\t// Same work as in scanobject; see comments there.\n \t\tobj := *(*uintptr)(unsafe.Pointer(b + i))\n@@ -1073,6 +1138,50 @@ func scanstackblock(b, n uintptr, gcw *gcWork) {\n \t}\n }\n \n+// scanstackblockwithmap is like scanstackblock, but with an explicit\n+// pointer bitmap. This is used only when precise stack scan is enabled.\n+//go:linkname scanstackblockwithmap runtime.scanstackblockwithmap\n+//go:nowritebarrier\n+func scanstackblockwithmap(pc, b0, n0 uintptr, ptrmask *uint8, gcw *gcWork) {\n+\t// Use local copies of original parameters, so that a stack trace\n+\t// due to one of the throws below shows the original block\n+\t// base and extent.\n+\tb := b0\n+\tn := n0\n+\n+\tfor i := uintptr(0); i < n; {\n+\t\t// Find bits for the next word.\n+\t\tbits := uint32(*addb(ptrmask, i/(sys.PtrSize*8)))\n+\t\tif bits == 0 {\n+\t\t\ti += sys.PtrSize * 8\n+\t\t\tcontinue\n+\t\t}\n+\t\tfor j := 0; j < 8 && i < n; j++ {\n+\t\t\tif bits&1 != 0 {\n+\t\t\t\t// Same work as in scanobject; see comments there.\n+\t\t\t\tobj := *(*uintptr)(unsafe.Pointer(b + i))\n+\t\t\t\tif obj != 0 {\n+\t\t\t\t\to, span, objIndex := findObject(obj, b, i, false)\n+\t\t\t\t\tif obj < minPhysPageSize ||\n+\t\t\t\t\t\tspan != nil && span.state != _MSpanManual &&\n+\t\t\t\t\t\t\t(obj < span.base() || obj >= span.limit || span.state != mSpanInUse) {\n+\t\t\t\t\t\tprint(\"runtime: found in object at *(\", hex(b), \"+\", hex(i), \") = \", hex(obj), \", pc=\", hex(pc), \"\\n\")\n+\t\t\t\t\t\tname, file, line := funcfileline(pc, -1)\n+\t\t\t\t\t\tprint(name, \"\\n\", file, \":\", line, \"\\n\")\n+\t\t\t\t\t\t//gcDumpObject(\"object\", b, i)\n+\t\t\t\t\t\tthrow(\"found bad pointer in Go stack (incorrect use of unsafe or cgo?)\")\n+\t\t\t\t\t}\n+\t\t\t\t\tif o != 0 {\n+\t\t\t\t\t\tgreyobject(o, b, i, span, gcw, objIndex, false)\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tbits >>= 1\n+\t\t\ti += sys.PtrSize\n+\t\t}\n+\t}\n+}\n+\n // Shade the object if it isn't already.\n // The object is not nil and known to be in the heap.\n // Preemption must be disabled."}, {"sha": "08511fd2acaa249e06e83b7b813540f9dc5e6efa", "filename": "libgo/go/runtime/os_gccgo.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43137e800bb9ca2ecda0a6b6189e0eb5c22f0d7/libgo%2Fgo%2Fruntime%2Fos_gccgo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43137e800bb9ca2ecda0a6b6189e0eb5c22f0d7/libgo%2Fgo%2Fruntime%2Fos_gccgo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fos_gccgo.go?ref=c43137e800bb9ca2ecda0a6b6189e0eb5c22f0d7", "patch": "@@ -27,7 +27,8 @@ func mpreinit(mp *m) {\n func minit() {\n \tminitSignals()\n \n-\t// FIXME: We should set _g_.m.procid here.\n+\t// FIXME: only works on linux for now.\n+\tgetg().m.procid = uint64(gettid())\n }\n \n // Called from dropm to undo the effect of an minit."}, {"sha": "ef166cb9d28d57d35f658b4313e19d7326022700", "filename": "libgo/go/runtime/proc.go", "status": "modified", "additions": 50, "deletions": 1, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43137e800bb9ca2ecda0a6b6189e0eb5c22f0d7/libgo%2Fgo%2Fruntime%2Fproc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43137e800bb9ca2ecda0a6b6189e0eb5c22f0d7/libgo%2Fgo%2Fruntime%2Fproc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fproc.go?ref=c43137e800bb9ca2ecda0a6b6189e0eb5c22f0d7", "patch": "@@ -528,6 +528,8 @@ func schedinit() {\n \n \tsched.maxmcount = 10000\n \n+\tusestackmaps = probestackmaps()\n+\n \tmallocinit()\n \tmcommoninit(_g_.m)\n \tcpuinit() // must run before alginit\n@@ -891,7 +893,49 @@ loop:\n \t\tcase _Gcopystack:\n \t\t// Stack being switched. Go around again.\n \n-\t\tcase _Grunnable, _Gsyscall, _Gwaiting:\n+\t\tcase _Gsyscall:\n+\t\t\tif usestackmaps {\n+\t\t\t\t// Claim goroutine by setting scan bit.\n+\t\t\t\t// Racing with execution or readying of gp.\n+\t\t\t\t// The scan bit keeps them from running\n+\t\t\t\t// the goroutine until we're done.\n+\t\t\t\tif castogscanstatus(gp, s, s|_Gscan) {\n+\t\t\t\t\tif gp.scanningself {\n+\t\t\t\t\t\t// Don't try to scan the stack\n+\t\t\t\t\t\t// if the goroutine is going to do\n+\t\t\t\t\t\t// it itself.\n+\t\t\t\t\t\t// FIXME: can this happen?\n+\t\t\t\t\t\trestartg(gp)\n+\t\t\t\t\t\tbreak\n+\t\t\t\t\t}\n+\t\t\t\t\tif !gp.gcscandone {\n+\t\t\t\t\t\t// Send a signal to let the goroutine scan\n+\t\t\t\t\t\t// itself. This races with enter/exitsyscall.\n+\t\t\t\t\t\t// If the goroutine is not stopped at a safepoint,\n+\t\t\t\t\t\t// it will not scan the stack and we'll try again.\n+\t\t\t\t\t\tmp := gp.m\n+\t\t\t\t\t\tnoteclear(&mp.scannote)\n+\t\t\t\t\t\tgp.scangcw = uintptr(unsafe.Pointer(gcw))\n+\t\t\t\t\t\ttgkill(getpid(), _pid_t(mp.procid), _SIGURG)\n+\n+\t\t\t\t\t\t// Wait for gp to scan its own stack.\n+\t\t\t\t\t\tnotesleep(&mp.scannote)\n+\n+\t\t\t\t\t\tif !gp.gcscandone {\n+\t\t\t\t\t\t\t// The signal delivered at a bad time.\n+\t\t\t\t\t\t\t// Try again.\n+\t\t\t\t\t\t\trestartg(gp)\n+\t\t\t\t\t\t\tbreak\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\trestartg(gp)\n+\t\t\t\t\tbreak loop\n+\t\t\t\t}\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t\tfallthrough\n+\n+\t\tcase _Grunnable, _Gwaiting:\n \t\t\t// Claim goroutine by setting scan bit.\n \t\t\t// Racing with execution or readying of gp.\n \t\t\t// The scan bit keeps them from running\n@@ -954,6 +998,11 @@ loop:\n \n // The GC requests that this routine be moved from a scanmumble state to a mumble state.\n func restartg(gp *g) {\n+\tif gp.scang != 0 || gp.scangcw != 0 {\n+\t\tprint(\"g \", gp.goid, \"is being scanned scang=\", gp.scang, \" scangcw=\", gp.scangcw, \"\\n\")\n+\t\tthrow(\"restartg: being scanned\")\n+\t}\n+\n \ts := readgstatus(gp)\n \tswitch s {\n \tdefault:"}, {"sha": "6eb9491018d7acc22f0066af9494120fb98c4e86", "filename": "libgo/go/runtime/runtime2.go", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43137e800bb9ca2ecda0a6b6189e0eb5c22f0d7/libgo%2Fgo%2Fruntime%2Fruntime2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43137e800bb9ca2ecda0a6b6189e0eb5c22f0d7/libgo%2Fgo%2Fruntime%2Fruntime2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fruntime2.go?ref=c43137e800bb9ca2ecda0a6b6189e0eb5c22f0d7", "patch": "@@ -430,6 +430,9 @@ type g struct {\n \n \tscanningself bool // whether goroutine is scanning its own stack\n \n+\tscang   uintptr // the g that wants to scan this g's stack (uintptr to avoid write barrier)\n+\tscangcw uintptr // gc worker for scanning stack (uintptr to avoid write barrier)\n+\n \tisSystemGoroutine bool // whether goroutine is a \"system\" goroutine\n \n \ttraceback uintptr // stack traceback buffer\n@@ -514,6 +517,8 @@ type m struct {\n \texiting    bool // thread is exiting\n \n \tgcing int32\n+\n+\tscannote note // synchonization for signal-based stack scanning\n }\n \n type p struct {"}, {"sha": "b41eaf409702204f643405e0622cf063332b1d1e", "filename": "libgo/go/runtime/signal_sighandler.go", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43137e800bb9ca2ecda0a6b6189e0eb5c22f0d7/libgo%2Fgo%2Fruntime%2Fsignal_sighandler.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43137e800bb9ca2ecda0a6b6189e0eb5c22f0d7/libgo%2Fgo%2Fruntime%2Fsignal_sighandler.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fsignal_sighandler.go?ref=c43137e800bb9ca2ecda0a6b6189e0eb5c22f0d7", "patch": "@@ -36,6 +36,28 @@ func sighandler(sig uint32, info *_siginfo_t, ctxt unsafe.Pointer, gp *g) {\n \n \tsigfault, sigpc := getSiginfo(info, ctxt)\n \n+\tif sig == _SIGURG && usestackmaps {\n+\t\t// We may be signaled to do a stack scan.\n+\t\t// The signal delivery races with enter/exitsyscall.\n+\t\t// We may be on g0 stack now. gp.m.curg is the g we\n+\t\t// want to scan.\n+\t\t// If we're not on g stack, give up. The sender will\n+\t\t// try again later.\n+\t\t// If we're not stopped at a safepoint (doscanstack will\n+\t\t// return false), also give up.\n+\t\tif s := readgstatus(gp.m.curg); s == _Gscansyscall {\n+\t\t\tif gp == gp.m.curg {\n+\t\t\t\tif doscanstack(gp, (*gcWork)(unsafe.Pointer(gp.scangcw))) {\n+\t\t\t\t\tgp.gcscanvalid = true\n+\t\t\t\t\tgp.gcscandone = true\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tgp.m.curg.scangcw = 0\n+\t\t\tnotewakeup(&gp.m.scannote)\n+\t\t\treturn\n+\t\t}\n+\t}\n+\n \tif sig == _SIGPROF {\n \t\tsigprof(sigpc, gp, _g_.m)\n \t\treturn"}, {"sha": "4caa39d5e942b3847779ef640dc63cb2700983a0", "filename": "libgo/go/runtime/stubs.go", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43137e800bb9ca2ecda0a6b6189e0eb5c22f0d7/libgo%2Fgo%2Fruntime%2Fstubs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43137e800bb9ca2ecda0a6b6189e0eb5c22f0d7/libgo%2Fgo%2Fruntime%2Fstubs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fstubs.go?ref=c43137e800bb9ca2ecda0a6b6189e0eb5c22f0d7", "patch": "@@ -447,3 +447,10 @@ func bool2int(x bool) int {\n // signal handler, which will attempt to tear down the runtime\n // immediately.\n func abort()\n+\n+// usestackmaps is true if stack map (precise stack scan) is enabled.\n+var usestackmaps bool\n+\n+// probestackmaps detects whether there are stack maps.\n+//go:linkname probestackmaps runtime.probestackmaps\n+func probestackmaps() bool"}, {"sha": "3c733e37d9ad6d1a5a567ff6530d328307314520", "filename": "libgo/go/runtime/stubs_linux.go", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43137e800bb9ca2ecda0a6b6189e0eb5c22f0d7/libgo%2Fgo%2Fruntime%2Fstubs_linux.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43137e800bb9ca2ecda0a6b6189e0eb5c22f0d7/libgo%2Fgo%2Fruntime%2Fstubs_linux.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fstubs_linux.go?ref=c43137e800bb9ca2ecda0a6b6189e0eb5c22f0d7", "patch": "@@ -7,3 +7,11 @@\n package runtime\n \n func sbrk0() uintptr\n+\n+func gettid() _pid_t {\n+\treturn _pid_t(syscall(_SYS_gettid, 0, 0, 0, 0, 0, 0))\n+}\n+\n+func tgkill(pid _pid_t, tid _pid_t, sig uint32) uint32 {\n+\treturn uint32(syscall(_SYS_tgkill, uintptr(pid), uintptr(tid), uintptr(sig), 0, 0, 0))\n+}"}, {"sha": "4cdab0c8b8139509a84b1f4df6f8a2572e966880", "filename": "libgo/go/runtime/stubs_nonlinux.go", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43137e800bb9ca2ecda0a6b6189e0eb5c22f0d7/libgo%2Fgo%2Fruntime%2Fstubs_nonlinux.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43137e800bb9ca2ecda0a6b6189e0eb5c22f0d7/libgo%2Fgo%2Fruntime%2Fstubs_nonlinux.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fstubs_nonlinux.go?ref=c43137e800bb9ca2ecda0a6b6189e0eb5c22f0d7", "patch": "@@ -10,3 +10,11 @@ package runtime\n func sbrk0() uintptr {\n \treturn 0\n }\n+\n+func gettid() _pid_t {\n+\treturn 0\n+}\n+\n+func tgkill(pid _pid_t, tid _pid_t, sig uint32) uint32 {\n+\tthrow(\"tgkill not implemented\")\n+}"}, {"sha": "a1a9558597bfac7ecc19f717163d36c52427b236", "filename": "libgo/runtime/go-unwind.c", "status": "modified", "additions": 248, "deletions": 0, "changes": 248, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43137e800bb9ca2ecda0a6b6189e0eb5c22f0d7/libgo%2Fruntime%2Fgo-unwind.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43137e800bb9ca2ecda0a6b6189e0eb5c22f0d7/libgo%2Fruntime%2Fgo-unwind.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-unwind.c?ref=c43137e800bb9ca2ecda0a6b6189e0eb5c22f0d7", "patch": "@@ -304,6 +304,26 @@ read_encoded_value (struct _Unwind_Context *context, uint8_t encoding,\n   return p;\n }\n \n+static inline int\n+value_size (uint8_t encoding)\n+{\n+  switch (encoding & 0x0f)\n+    {\n+      case DW_EH_PE_sdata2:\n+      case DW_EH_PE_udata2:\n+        return 2;\n+      case DW_EH_PE_sdata4:\n+      case DW_EH_PE_udata4:\n+        return 4;\n+      case DW_EH_PE_sdata8:\n+      case DW_EH_PE_udata8:\n+        return 8;\n+      default:\n+        break;\n+    }\n+  abort ();\n+}\n+\n /* The rest of this code is really similar to gcc/unwind-c.c and\n    libjava/exception.cc.  */\n \n@@ -563,3 +583,231 @@ PERSONALITY_FUNCTION (int version,\n   _Unwind_SetIP (context, landing_pad);\n   return _URC_INSTALL_CONTEXT;\n }\n+\n+// A dummy personality function, which doesn't capture any exception\n+// and simply passes by. This is used for functions that don't\n+// capture exceptions but need LSDA for stack maps.\n+_Unwind_Reason_Code\n+__gccgo_personality_dummy (int, _Unwind_Action, _Unwind_Exception_Class,\n+\t\t      struct _Unwind_Exception *, struct _Unwind_Context *)\n+  __attribute__ ((no_split_stack));\n+\n+_Unwind_Reason_Code\n+__gccgo_personality_dummy (int version __attribute__ ((unused)),\n+\t\t      _Unwind_Action actions __attribute__ ((unused)),\n+\t\t      _Unwind_Exception_Class exception_class __attribute__ ((unused)),\n+\t\t      struct _Unwind_Exception *ue_header __attribute__ ((unused)),\n+\t\t      struct _Unwind_Context *context __attribute__ ((unused)))\n+{\n+  CONTINUE_UNWINDING;\n+}\n+\n+// A sentinel value for Go functions.\n+// A function is a Go function if it has LSDA, which has type info,\n+// and the first (dummy) landing pad's type info is a pointer to\n+// this value.\n+#define GO_FUNC_SENTINEL ((uint64)'G' | ((uint64)'O'<<8) | \\\n+                          ((uint64)'.'<<16) | ((uint64)'.'<<24) | \\\n+                          ((uint64)'F'<<32) | ((uint64)'U'<<40) | \\\n+                          ((uint64)'N'<<48) | ((uint64)'C'<<56))\n+\n+struct _stackmap {\n+  uint32 len;\n+  uint8 data[1]; // variabe length\n+};\n+\n+extern void\n+  runtime_scanstackblockwithmap (uintptr ip, uintptr sp, uintptr size, uint8 *ptrmask, void* gcw)\n+  __asm__ (GOSYM_PREFIX \"runtime.scanstackblockwithmap\");\n+\n+#define FOUND        0\n+#define NOTFOUND_OK  1\n+#define NOTFOUND_BAD 2\n+\n+// Helper function to search for stack maps in the unwinding records of a frame.\n+// If found, populate ip, sp, and stackmap. Returns the #define'd values above.\n+static int\n+findstackmaps (struct _Unwind_Context *context, _Unwind_Ptr *ip, _Unwind_Ptr *sp, struct _stackmap **stackmap)\n+{\n+  lsda_header_info info;\n+  const unsigned char *language_specific_data, *p, *action_record;\n+  bool first;\n+  struct _stackmap *stackmap1;\n+  _Unwind_Ptr ip1;\n+  int ip_before_insn = 0;\n+  _sleb128_t index;\n+  int size;\n+\n+  language_specific_data = (const unsigned char *)\n+    _Unwind_GetLanguageSpecificData (context);\n+\n+  /* If no LSDA, then there is no stack maps.  */\n+  if (! language_specific_data)\n+    return NOTFOUND_OK;\n+\n+  p = parse_lsda_header (context, language_specific_data, &info);\n+\n+  if (info.TType == NULL)\n+    return NOTFOUND_OK;\n+\n+#ifdef HAVE_GETIPINFO\n+  ip1 = _Unwind_GetIPInfo (context, &ip_before_insn);\n+#else\n+  ip1 = _Unwind_GetIP (context);\n+#endif\n+  if (! ip_before_insn)\n+    --ip1;\n+\n+  size = value_size (info.ttype_encoding);\n+\n+  action_record = NULL;\n+  first = true;\n+\n+  /* Search the call-site table for the action associated with this IP.  */\n+  while (p < info.action_table)\n+    {\n+      _Unwind_Ptr cs_start, cs_len, cs_lp;\n+      _uleb128_t cs_action;\n+\n+      /* Note that all call-site encodings are \"absolute\" displacements.  */\n+      p = read_encoded_value (0, info.call_site_encoding, p, &cs_start);\n+      p = read_encoded_value (0, info.call_site_encoding, p, &cs_len);\n+      p = read_encoded_value (0, info.call_site_encoding, p, &cs_lp);\n+      p = read_uleb128 (p, &cs_action);\n+\n+      if (first)\n+        {\n+          // For a Go function, the first entry points to the sentinel value.\n+          // Check this here.\n+          const unsigned char *p1, *action1;\n+          uint64 *x;\n+\n+          if (!cs_action)\n+            return NOTFOUND_OK;\n+\n+          action1 = info.action_table + cs_action - 1;\n+          read_sleb128 (action1, &index);\n+          p1 = info.TType - index*size;\n+          read_encoded_value (context, info.ttype_encoding, p1, (_Unwind_Ptr*)&x);\n+          if (x == NULL || *x != GO_FUNC_SENTINEL)\n+            return NOTFOUND_OK;\n+\n+          first = false;\n+          continue;\n+        }\n+\n+      /* The table is sorted, so if we've passed the ip, stop.  */\n+      if (ip1 < info.Start + cs_start)\n+        return NOTFOUND_BAD;\n+      else if (ip1 < info.Start + cs_start + cs_len)\n+        {\n+          if (cs_action)\n+            action_record = info.action_table + cs_action - 1;\n+          break;\n+        }\n+    }\n+\n+  if (action_record == NULL)\n+    return NOTFOUND_BAD;\n+\n+  read_sleb128 (action_record, &index);\n+  p = info.TType - index*size;\n+  read_encoded_value (context, info.ttype_encoding, p, (_Unwind_Ptr*)&stackmap1);\n+  if (stackmap1 == NULL)\n+    return NOTFOUND_BAD;\n+\n+  if (ip != NULL)\n+    *ip = ip1;\n+  if (sp != NULL)\n+    *sp = _Unwind_GetCFA (context);\n+  if (stackmap != NULL)\n+    *stackmap = stackmap1;\n+  return FOUND;\n+}\n+\n+// Callback function to scan a stack frame with stack maps.\n+// It skips non-Go functions.\n+static _Unwind_Reason_Code\n+scanstackwithmap_callback (struct _Unwind_Context *context, void *arg)\n+{\n+  struct _stackmap *stackmap;\n+  _Unwind_Ptr ip, sp;\n+  G* gp;\n+  void *gcw = arg;\n+\n+  switch (findstackmaps (context, &ip, &sp, &stackmap))\n+    {\n+      case NOTFOUND_OK:\n+        // Not a Go function. Skip this frame.\n+        return _URC_NO_REASON;\n+      case NOTFOUND_BAD:\n+        {\n+          // No stack map found.\n+          // If we're scanning from the signal stack, the goroutine\n+          // may be not stopped at a safepoint. Allow this case.\n+          gp = runtime_g ();\n+          if (gp != gp->m->gsignal)\n+            {\n+              // TODO: print gp, pc, sp\n+              runtime_throw (\"no stack map\");\n+            }\n+          return _URC_NORMAL_STOP;\n+        }\n+      case FOUND:\n+        break;\n+      default:\n+        abort ();\n+    }\n+\n+  runtime_scanstackblockwithmap (ip, sp, (uintptr)(stackmap->len) * sizeof(uintptr), stackmap->data, gcw);\n+\n+  return _URC_NO_REASON;\n+}\n+\n+// Scan the stack with stack maps. Return whether the scan\n+// succeeded.\n+bool\n+scanstackwithmap (void *gcw)\n+{\n+  _Unwind_Reason_Code code;\n+  code = _Unwind_Backtrace (scanstackwithmap_callback, gcw);\n+  return code == _URC_END_OF_STACK;\n+}\n+\n+// Returns whether stack map is enabled.\n+bool\n+usestackmaps ()\n+{\n+  return runtime_usestackmaps;\n+}\n+\n+// Callback function to probe if a stack frame has stack maps.\n+static _Unwind_Reason_Code\n+probestackmaps_callback (struct _Unwind_Context *context,\n+                         void *arg __attribute__ ((unused)))\n+{\n+  switch (findstackmaps (context, NULL, NULL, NULL))\n+    {\n+      case NOTFOUND_OK:\n+      case NOTFOUND_BAD:\n+        return _URC_NO_REASON;\n+      case FOUND:\n+        break;\n+      default:\n+        abort ();\n+    }\n+\n+  // Found a stack map. No need to keep unwinding.\n+  runtime_usestackmaps = true;\n+  return _URC_NORMAL_STOP;\n+}\n+\n+// Try to find a stack map, store the result in global variable runtime_usestackmaps.\n+// Called in start-up time from Go code, so there is a Go frame on the stack.\n+bool\n+probestackmaps ()\n+{\n+  runtime_usestackmaps = false;\n+  _Unwind_Backtrace (probestackmaps_callback, NULL);\n+  return runtime_usestackmaps;\n+}"}, {"sha": "99b2cb166aa960f3e892c26b2b1c9699bb61e18f", "filename": "libgo/runtime/proc.c", "status": "modified", "additions": 71, "deletions": 2, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43137e800bb9ca2ecda0a6b6189e0eb5c22f0d7/libgo%2Fruntime%2Fproc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43137e800bb9ca2ecda0a6b6189e0eb5c22f0d7/libgo%2Fruntime%2Fproc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fproc.c?ref=c43137e800bb9ca2ecda0a6b6189e0eb5c22f0d7", "patch": "@@ -59,6 +59,8 @@ uintptr runtime_stacks_sys;\n void gtraceback(G*)\n   __asm__(GOSYM_PREFIX \"runtime.gtraceback\");\n \n+static void gscanstack(G*);\n+\n #ifdef __rtems__\n #define __thread\n #endif\n@@ -340,6 +342,8 @@ runtime_mcall(FuncVal *fv)\n \n \t\tif(gp->traceback != 0)\n \t\t\tgtraceback(gp);\n+\t\tif(gp->scang != 0)\n+\t\t\tgscanstack(gp);\n \t}\n \tif (gp == nil || !gp->fromgogo) {\n #ifdef USING_SPLIT_STACK\n@@ -469,6 +473,66 @@ gtraceback(G* gp)\n \truntime_gogo(traceback->gp);\n }\n \n+void doscanstackswitch(G*, G*) __asm__(GOSYM_PREFIX \"runtime.doscanstackswitch\");\n+\n+// Switch to gp and let it scan its stack.\n+// The first time gp->scang is set (to me). The second time here\n+// gp is done scanning, and has unset gp->scang, so we just return.\n+void\n+doscanstackswitch(G* me, G* gp)\n+{\n+\t__go_assert(me->entry == nil);\n+\tme->fromgogo = false;\n+\n+#ifdef USING_SPLIT_STACK\n+\t__splitstack_getcontext((void*)(&me->stackcontext[0]));\n+#endif\n+\tgetcontext(ucontext_arg(&me->context[0]));\n+\n+\tif(me->entry != nil) {\n+\t\t// Got here from mcall.\n+\t\t// The stack scanning code may call systemstack, which calls\n+\t\t// mcall, which calls setcontext.\n+\t\t// Run the function, which at the end will switch back to gp.\n+\t\tFuncVal *fv = me->entry;\n+\t\tvoid (*pfn)(G*) = (void (*)(G*))fv->fn;\n+\t\tG* gp1 = (G*)me->param;\n+\t\t__go_assert(gp1 == gp);\n+\t\tme->entry = nil;\n+\t\tme->param = nil;\n+\t\t__builtin_call_with_static_chain(pfn(gp1), fv);\n+\t\tabort();\n+\t}\n+\n+\tif (gp->scang != 0)\n+\t\truntime_gogo(gp);\n+}\n+\n+// Do a stack scan, then switch back to the g that triggers this scan.\n+// We come here from doscanstackswitch.\n+static void\n+gscanstack(G *gp)\n+{\n+\tG *oldg, *oldcurg;\n+\tM* holdm;\n+\n+\toldg = (G*)gp->scang;\n+\toldcurg = oldg->m->curg;\n+\tholdm = gp->m;\n+\tif(holdm != nil && holdm != g->m)\n+\t\truntime_throw(\"gscanstack: m is not nil\");\n+\toldg->m->curg = gp;\n+\tgp->m = oldg->m;\n+\tgp->scang = 0;\n+\n+\tdoscanstack(gp, (void*)gp->scangcw);\n+\n+\tgp->scangcw = 0;\n+\tgp->m = holdm;\n+\toldg->m->curg = oldcurg;\n+\truntime_gogo(oldg);\n+}\n+\n // Called by pthread_create to start an M.\n void*\n runtime_mstart(void *arg)\n@@ -516,6 +580,9 @@ runtime_mstart(void *arg)\n \t\t// may always go to the getcontext call in mcall.\n \t\tgtraceback(gp);\n \t}\n+\tif(gp->scang != 0)\n+\t\t// Got here from doscanswitch. Should not happen.\n+\t\truntime_throw(\"mstart with scang\");\n \n \tif(gp->entry != nil) {\n \t\t// Got here from mcall.\n@@ -630,7 +697,8 @@ runtime_entersyscall()\n {\n \t// Save the registers in the g structure so that any pointers\n \t// held in registers will be seen by the garbage collector.\n-\tgetcontext(ucontext_arg(&g->gcregs[0]));\n+\tif (!runtime_usestackmaps)\n+\t\tgetcontext(ucontext_arg(&g->gcregs[0]));\n \n \t// Note that if this function does save any registers itself,\n \t// we might store the wrong value in the call to getcontext.\n@@ -676,7 +744,8 @@ runtime_entersyscallblock()\n {\n \t// Save the registers in the g structure so that any pointers\n \t// held in registers will be seen by the garbage collector.\n-\tgetcontext(ucontext_arg(&g->gcregs[0]));\n+\tif (!runtime_usestackmaps)\n+\t\tgetcontext(ucontext_arg(&g->gcregs[0]));\n \n \t// See comment in runtime_entersyscall.\n \tdoentersyscallblock((uintptr)runtime_getcallerpc(),"}, {"sha": "21921ec16dfbe276445620285ba35e3178f1e253", "filename": "libgo/runtime/runtime.h", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43137e800bb9ca2ecda0a6b6189e0eb5c22f0d7/libgo%2Fruntime%2Fruntime.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43137e800bb9ca2ecda0a6b6189e0eb5c22f0d7/libgo%2Fruntime%2Fruntime.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fruntime.h?ref=c43137e800bb9ca2ecda0a6b6189e0eb5c22f0d7", "patch": "@@ -502,3 +502,16 @@ struct funcfileline_return\n struct funcfileline_return\n runtime_funcfileline (uintptr targetpc, int32 index)\n   __asm__ (GOSYM_PREFIX \"runtime.funcfileline\");\n+\n+/*\n+ * helpers for stack scan.\n+ */\n+bool scanstackwithmap(void*)\n+  __asm__(GOSYM_PREFIX \"runtime.scanstackwithmap\");\n+bool doscanstack(G*, void*)\n+  __asm__(\"runtime.doscanstack\");\n+\n+bool runtime_usestackmaps;\n+\n+bool probestackmaps(void)\n+  __asm__(\"runtime.probestackmaps\");"}, {"sha": "2d5d1e09c15b423628588e54ea883f11a26257e4", "filename": "libgo/runtime/stack.c", "status": "modified", "additions": 23, "deletions": 12, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43137e800bb9ca2ecda0a6b6189e0eb5c22f0d7/libgo%2Fruntime%2Fstack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43137e800bb9ca2ecda0a6b6189e0eb5c22f0d7/libgo%2Fruntime%2Fstack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fstack.c?ref=c43137e800bb9ca2ecda0a6b6189e0eb5c22f0d7", "patch": "@@ -23,33 +23,43 @@ extern void * __splitstack_find_context (void *context[10], size_t *, void **,\n extern void scanstackblock(void *addr, uintptr size, void *gcw)\n   __asm__(\"runtime.scanstackblock\");\n \n-void doscanstack(G*, void*)\n-  __asm__(\"runtime.doscanstack\");\n-\n-static void doscanstack1(G*, void*)\n+static bool doscanstack1(G*, void*)\n   __attribute__ ((noinline));\n \n // Scan gp's stack, passing stack chunks to scanstackblock.\n-void doscanstack(G *gp, void* gcw) {\n+bool doscanstack(G *gp, void* gcw) {\n \t// Save registers on the stack, so that if we are scanning our\n \t// own stack we will see them.\n-\t__builtin_unwind_init();\n-\tflush_registers_to_secondary_stack();\n+\tif (!runtime_usestackmaps) {\n+\t\t__builtin_unwind_init();\n+\t\tflush_registers_to_secondary_stack();\n+\t}\n \n-\tdoscanstack1(gp, gcw);\n+\treturn doscanstack1(gp, gcw);\n }\n \n // Scan gp's stack after saving registers.\n-static void doscanstack1(G *gp, void *gcw) {\n+static bool doscanstack1(G *gp, void *gcw) {\n #ifdef USING_SPLIT_STACK\n \tvoid* sp;\n \tsize_t spsize;\n \tvoid* next_segment;\n \tvoid* next_sp;\n \tvoid* initial_sp;\n-\n-\tif (gp == runtime_g()) {\n+\tG* _g_;\n+\n+\t_g_ = runtime_g();\n+\tif (runtime_usestackmaps) {\n+\t\t// If stack map is enabled, we get here only when we can unwind\n+\t\t// the stack being scanned. That is, either we are scanning our\n+\t\t// own stack, or we are scanning through a signal handler.\n+\t\t__go_assert((_g_ == gp) || ((_g_ == gp->m->gsignal) && (gp == gp->m->curg)));\n+\t\treturn scanstackwithmap(gcw);\n+\t}\n+\tif (_g_ == gp) {\n \t\t// Scanning our own stack.\n+\t\t// If we are on a signal stack, it can unwind through the signal\n+\t\t// handler and see the g stack, so just scan our own stack.\n \t\tsp = __splitstack_find(nil, nil, &spsize, &next_segment,\n \t\t\t\t       &next_sp, &initial_sp);\n \t} else {\n@@ -95,7 +105,7 @@ static void doscanstack1(G *gp, void *gcw) {\n \t\t// The goroutine is usually asleep (the world is stopped).\n \t\tbottom = (void*)gp->gcnextsp;\n \t\tif(bottom == nil)\n-\t\t\treturn;\n+\t\t\treturn true;\n \t\tnextsp2 = (void*)gp->gcnextsp2;\n \t}\n \ttop = (byte*)(void*)(gp->gcinitialsp) + gp->gcstacksize;\n@@ -111,4 +121,5 @@ static void doscanstack1(G *gp, void *gcw) {\n \t\t\tscanstackblock(initialsp2, (uintptr)(nextsp2 - initialsp2), gcw);\n \t}\n #endif\n+\treturn true;\n }"}]}