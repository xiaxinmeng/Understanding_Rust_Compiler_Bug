{"sha": "63ee8641f82a11bd60b5cf12be02aeeb1728d649", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjNlZTg2NDFmODJhMTFiZDYwYjVjZjEyYmUwMmFlZWIxNzI4ZDY0OQ==", "commit": {"author": {"name": "Nathan Froyd", "email": "froydnj@codesourcery.com", "date": "2011-03-24T15:23:23Z"}, "committer": {"name": "Nathan Froyd", "email": "froydnj@gcc.gnu.org", "date": "2011-03-24T15:23:23Z"}, "message": "tree.c (record_node_allocation_statistics): New function.\n\n\t* tree.c (record_node_allocation_statistics): New function.\n\t(make_node_stat, copy_node_stat, build_string): Call it.\n\t(make_tree_binfo_stat, make_tree_vec_stat, tree_cons_stat): Likewise.\n\t(build1_stat, build_omp_clause): Likewise.\n\nFrom-SVN: r171399", "tree": {"sha": "ff6109e5cdfa3804e7b326ec5666f594533f923c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ff6109e5cdfa3804e7b326ec5666f594533f923c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/63ee8641f82a11bd60b5cf12be02aeeb1728d649", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63ee8641f82a11bd60b5cf12be02aeeb1728d649", "html_url": "https://github.com/Rust-GCC/gccrs/commit/63ee8641f82a11bd60b5cf12be02aeeb1728d649", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63ee8641f82a11bd60b5cf12be02aeeb1728d649/comments", "author": null, "committer": null, "parents": [{"sha": "abbc8c7b156d75c1f4baad852af5762482203ee1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/abbc8c7b156d75c1f4baad852af5762482203ee1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/abbc8c7b156d75c1f4baad852af5762482203ee1"}], "stats": {"total": 103, "additions": 47, "deletions": 56}, "files": [{"sha": "0bc1e9fd92bf1afb7e2c4620c2d34db913b33c39", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63ee8641f82a11bd60b5cf12be02aeeb1728d649/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63ee8641f82a11bd60b5cf12be02aeeb1728d649/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=63ee8641f82a11bd60b5cf12be02aeeb1728d649", "patch": "@@ -1,3 +1,10 @@\n+2011-03-24  Nathan Froyd  <froydnj@codesourcery.com>\n+\n+\t* tree.c (record_node_allocation_statistics): New function.\n+\t(make_node_stat, copy_node_stat, build_string): Call it.\n+\t(make_tree_binfo_stat, make_tree_vec_stat, tree_cons_stat): Likewise.\n+\t(build1_stat, build_omp_clause): Likewise.\n+\n 2011-03-24  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \t* builtins.c (expand_movstr): Fix endp == 1 adjustment after"}, {"sha": "6f22be4992a234a08eb6a9d0cf094cee04b575d2", "filename": "gcc/tree.c", "status": "modified", "additions": 40, "deletions": 56, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63ee8641f82a11bd60b5cf12be02aeeb1728d649/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63ee8641f82a11bd60b5cf12be02aeeb1728d649/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=63ee8641f82a11bd60b5cf12be02aeeb1728d649", "patch": "@@ -769,20 +769,15 @@ tree_size (const_tree node)\n     }\n }\n \n-/* Return a newly allocated node of code CODE.  For decl and type\n-   nodes, some other fields are initialized.  The rest of the node is\n-   initialized to zero.  This function cannot be used for TREE_VEC or\n-   OMP_CLAUSE nodes, which is enforced by asserts in tree_code_size.\n+/* Record interesting allocation statistics for a tree node with CODE\n+   and LENGTH.  */\n \n-   Achoo!  I got a code in the node.  */\n-\n-tree\n-make_node_stat (enum tree_code code MEM_STAT_DECL)\n+static void\n+record_node_allocation_statistics (enum tree_code code ATTRIBUTE_UNUSED,\n+\t\t\t\t   size_t length ATTRIBUTE_UNUSED)\n {\n-  tree t;\n-  enum tree_code_class type = TREE_CODE_CLASS (code);\n-  size_t length = tree_code_size (code);\n #ifdef GATHER_STATISTICS\n+  enum tree_code_class type = TREE_CODE_CLASS (code);\n   tree_node_kind kind;\n \n   switch (type)\n@@ -841,19 +836,44 @@ make_node_stat (enum tree_code code MEM_STAT_DECL)\n \t  kind = constr_kind;\n \t  break;\n \n+\tcase OMP_CLAUSE:\n+\t  kind = omp_clause_kind;\n+\t  break;\n+\n \tdefault:\n \t  kind = x_kind;\n \t  break;\n \t}\n       break;\n \n+    case tcc_vl_exp:\n+      kind = e_kind;\n+      break;\n+\n     default:\n       gcc_unreachable ();\n     }\n \n   tree_node_counts[(int) kind]++;\n   tree_node_sizes[(int) kind] += length;\n #endif\n+}\n+\n+/* Return a newly allocated node of code CODE.  For decl and type\n+   nodes, some other fields are initialized.  The rest of the node is\n+   initialized to zero.  This function cannot be used for TREE_VEC or\n+   OMP_CLAUSE nodes, which is enforced by asserts in tree_code_size.\n+\n+   Achoo!  I got a code in the node.  */\n+\n+tree\n+make_node_stat (enum tree_code code MEM_STAT_DECL)\n+{\n+  tree t;\n+  enum tree_code_class type = TREE_CODE_CLASS (code);\n+  size_t length = tree_code_size (code);\n+\n+  record_node_allocation_statistics (code, length);\n \n   t = ggc_alloc_zone_cleared_tree_node_stat (\n                (code == IDENTIFIER_NODE) ? &tree_id_zone : &tree_zone,\n@@ -950,6 +970,7 @@ copy_node_stat (tree node MEM_STAT_DECL)\n   gcc_assert (code != STATEMENT_LIST);\n \n   length = tree_size (node);\n+  record_node_allocation_statistics (code, length);\n   t = ggc_alloc_zone_tree_node_stat (&tree_zone, length PASS_MEM_STAT);\n   memcpy (t, node, length);\n \n@@ -1540,10 +1561,7 @@ build_string (int len, const char *str)\n   /* Do not waste bytes provided by padding of struct tree_string.  */\n   length = len + offsetof (struct tree_string, str) + 1;\n \n-#ifdef GATHER_STATISTICS\n-  tree_node_counts[(int) c_kind]++;\n-  tree_node_sizes[(int) c_kind] += length;\n-#endif\n+  record_node_allocation_statistics (STRING_CST, length);\n \n   s = ggc_alloc_tree_node (length);\n \n@@ -1663,10 +1681,7 @@ make_tree_binfo_stat (unsigned base_binfos MEM_STAT_DECL)\n   size_t length = (offsetof (struct tree_binfo, base_binfos)\n \t\t   + VEC_embedded_size (tree, base_binfos));\n \n-#ifdef GATHER_STATISTICS\n-  tree_node_counts[(int) binfo_kind]++;\n-  tree_node_sizes[(int) binfo_kind] += length;\n-#endif\n+  record_node_allocation_statistics (TREE_BINFO, length);\n \n   t = ggc_alloc_zone_tree_node_stat (&tree_zone, length PASS_MEM_STAT);\n \n@@ -1688,10 +1703,7 @@ make_tree_vec_stat (int len MEM_STAT_DECL)\n   tree t;\n   int length = (len - 1) * sizeof (tree) + sizeof (struct tree_vec);\n \n-#ifdef GATHER_STATISTICS\n-  tree_node_counts[(int) vec_kind]++;\n-  tree_node_sizes[(int) vec_kind] += length;\n-#endif\n+  record_node_allocation_statistics (TREE_VEC, length);\n \n   t = ggc_alloc_zone_cleared_tree_node_stat (&tree_zone, length PASS_MEM_STAT);\n \n@@ -2229,10 +2241,7 @@ tree_cons_stat (tree purpose, tree value, tree chain MEM_STAT_DECL)\n                                         PASS_MEM_STAT);\n   memset (node, 0, sizeof (struct tree_common));\n \n-#ifdef GATHER_STATISTICS\n-  tree_node_counts[(int) x_kind]++;\n-  tree_node_sizes[(int) x_kind] += sizeof (struct tree_list);\n-#endif\n+  record_node_allocation_statistics (TREE_LIST, sizeof (struct tree_list));\n \n   TREE_SET_CODE (node, TREE_LIST);\n   TREE_CHAIN (node) = chain;\n@@ -3689,28 +3698,9 @@ tree\n build1_stat (enum tree_code code, tree type, tree node MEM_STAT_DECL)\n {\n   int length = sizeof (struct tree_exp);\n-#ifdef GATHER_STATISTICS\n-  tree_node_kind kind;\n-#endif\n   tree t;\n \n-#ifdef GATHER_STATISTICS\n-  switch (TREE_CODE_CLASS (code))\n-    {\n-    case tcc_statement:  /* an expression with side effects */\n-      kind = s_kind;\n-      break;\n-    case tcc_reference:  /* a reference */\n-      kind = r_kind;\n-      break;\n-    default:\n-      kind = e_kind;\n-      break;\n-    }\n-\n-  tree_node_counts[(int) kind]++;\n-  tree_node_sizes[(int) kind] += length;\n-#endif\n+  record_node_allocation_statistics (code, length);\n \n   gcc_assert (TREE_CODE_LENGTH (code) == 1);\n \n@@ -9664,17 +9654,14 @@ build_omp_clause (location_t loc, enum omp_clause_code code)\n   length = omp_clause_num_ops[code];\n   size = (sizeof (struct tree_omp_clause) + (length - 1) * sizeof (tree));\n \n+  record_node_allocation_statistics (OMP_CLAUSE, size);\n+\n   t = ggc_alloc_tree_node (size);\n   memset (t, 0, size);\n   TREE_SET_CODE (t, OMP_CLAUSE);\n   OMP_CLAUSE_SET_CODE (t, code);\n   OMP_CLAUSE_LOCATION (t) = loc;\n \n-#ifdef GATHER_STATISTICS\n-  tree_node_counts[(int) omp_clause_kind]++;\n-  tree_node_sizes[(int) omp_clause_kind] += size;\n-#endif\n-\n   return t;\n }\n \n@@ -9692,10 +9679,7 @@ build_vl_exp_stat (enum tree_code code, int len MEM_STAT_DECL)\n   gcc_assert (TREE_CODE_CLASS (code) == tcc_vl_exp);\n   gcc_assert (len >= 1);\n \n-#ifdef GATHER_STATISTICS\n-  tree_node_counts[(int) e_kind]++;\n-  tree_node_sizes[(int) e_kind] += length;\n-#endif\n+  record_node_allocation_statistics (code, length);\n \n   t = ggc_alloc_zone_cleared_tree_node_stat (&tree_zone, length PASS_MEM_STAT);\n "}]}