{"sha": "70e06f23df998477ef7b1b906968aef1f2afc388", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzBlMDZmMjNkZjk5ODQ3N2VmN2IxYjkwNjk2OGFlZjFmMmFmYzM4OA==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1997-04-02T03:31:36Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1997-04-02T03:31:36Z"}, "message": "libgcc2.c (find_exception_table): Fix to logic to deal with functions that are in their own section...\n\n\t* libgcc2.c (find_exception_table): Fix to logic to deal with\n \tfunctions that are in their own section, such as template\n \tinstantiations, that cause overlapping EH tables.\n\nFrom-SVN: r13830", "tree": {"sha": "62c8018ef65f97fc595ac53403869bd88e472270", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/62c8018ef65f97fc595ac53403869bd88e472270"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/70e06f23df998477ef7b1b906968aef1f2afc388", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70e06f23df998477ef7b1b906968aef1f2afc388", "html_url": "https://github.com/Rust-GCC/gccrs/commit/70e06f23df998477ef7b1b906968aef1f2afc388", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70e06f23df998477ef7b1b906968aef1f2afc388/comments", "author": null, "committer": null, "parents": [{"sha": "ebf0d0254440202422a4434686b4b4654351b2c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebf0d0254440202422a4434686b4b4654351b2c8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ebf0d0254440202422a4434686b4b4654351b2c8"}], "stats": {"total": 88, "additions": 43, "deletions": 45}, "files": [{"sha": "9fcd17eb58e6544e66c3d5e3344e51a776c6c9e6", "filename": "gcc/libgcc2.c", "status": "modified", "additions": 43, "deletions": 45, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70e06f23df998477ef7b1b906968aef1f2afc388/gcc%2Flibgcc2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70e06f23df998477ef7b1b906968aef1f2afc388/gcc%2Flibgcc2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcc2.c?ref=70e06f23df998477ef7b1b906968aef1f2afc388", "patch": "@@ -3117,18 +3117,6 @@ struct exception_table_node {\n \n static struct exception_table_node *exception_table_list;\n \n-static exception_table *\n-find_exception_table (void *pc)\n-{\n-  register struct exception_table_node *table = exception_table_list;\n-  for ( ; table != 0; table = table->next)\n-    {\n-      if (table->start <= pc && table->end > pc)\n-\treturn table->table;\n-    }\n-  return 0;\n-}\n-\n /* this routine takes a pc, and the address of the exception handler associated\n    with the closest exception table handler entry associated with that PC,\n    or 0 if there are no table entries the PC fits in.  The algorithm works\n@@ -3156,49 +3144,59 @@ find_exception_table (void *pc)\n void *\n __find_first_exception_table_match (void *pc)\n {\n-  exception_table *table = find_exception_table (pc);\n-  int pos = 0;\n-  int best = 0;\n-  if (table == 0)\n-    return (void *) 0;\n+  register struct exception_table_node *tnp;\n+  register exception_table *table;\n+  int pos;\n+  int best;\n+\n #if 0\n   printf (\"find_first_exception_table_match (): pc = %x!\\n\", pc);\n #endif\n \n-#if 0\n-  /* We can't do this yet, as we don't know that the table is sorted.  */\n-  do {\n-    ++pos;\n-    if (table[pos].start > pc)\n-      /* found the first table[pos].start > pc, so the previous\n-\t entry better be the one we want! */\n-      break;\n-  } while (table[pos].exception_handler != (void *) -1);\n-\n-  --pos;\n-  if (table[pos].start <= pc && table[pos].end > pc)\n+  for (tnp = exception_table_list; tnp != 0; tnp = tnp->next)\n     {\n+      if (tnp->start > pc || tnp->end <= pc)\n+\tcontinue;\n+\n+      table = tnp->table;\n+\n+      pos = 0;\n+      best = 0;\n+#if 0\n+      /* We can't do this yet, as we don't know that the table is sorted.  */\n+      do {\n+\t++pos;\n+\tif (table[pos].start > pc)\n+\t  /* found the first table[pos].start > pc, so the previous\n+\t     entry better be the one we want! */\n+\t  break;\n+      } while (table[pos].exception_handler != (void *) -1);\n+\n+      --pos;\n+      if (table[pos].start <= pc && table[pos].end > pc)\n+\t{\n #if 0\n-      printf (\"find_first_eh_table_match (): found match: %x\\n\", table[pos].exception_handler);\n+\t  printf (\"find_first_eh_table_match (): found match: %x\\n\", table[pos].exception_handler);\n #endif\n-      return table[pos].exception_handler;\n-    }\n+\t  return table[pos].exception_handler;\n+\t}\n #else\n-  while (table[++pos].exception_handler != (void *) -1) {\n-    if (table[pos].start <= pc && table[pos].end > pc)\n-      {\n-\t/* This can apply.  Make sure it is better or as good as the previous\n-\t   best.  */\n-\t/* The best one ends first.  */\n-\tif (best == 0 || (table[pos].end <= table[best].end\n-\t\t\t  /* The best one starts last.  */\n-\t\t\t  && table[pos].start >= table[best].start))\n-\t  best = pos;\n+      while (table[++pos].exception_handler != (void *) -1) {\n+\tif (table[pos].start <= pc && table[pos].end > pc)\n+\t  {\n+\t    /* This can apply.  Make sure it is better or as good as\n+\t       the previous best.  */\n+\t    /* The best one ends first.  */\n+\t    if (best == 0 || (table[pos].end <= table[best].end\n+\t\t\t      /* The best one starts last.  */\n+\t\t\t      && table[pos].start >= table[best].start))\n+\t      best = pos;\n+\t  }\n       }\n-  }\n-  if (best != 0)\n-    return table[best].exception_handler;\n+      if (best != 0)\n+\treturn table[best].exception_handler;\n #endif\n+    }\n \n #if 0\n   printf (\"find_first_eh_table_match (): else: returning NULL!\\n\");"}]}