{"sha": "bdc193bad16766de82346ac6191a49e0771662c6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmRjMTkzYmFkMTY3NjZkZTgyMzQ2YWM2MTkxYTQ5ZTA3NzE2NjJjNg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-08-01T14:35:44Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-08-01T14:35:44Z"}, "message": "[multiple changes]\n\n2014-08-01  Bob Duff  <duff@adacore.com>\n\n\t* gnat_ugn.texi: Minor updates.\n\n2014-08-01  Robert Dewar  <dewar@adacore.com>\n\n\t* atree.adb: Minor reformatting.\n\n2014-08-01  Ed Schonberg  <schonberg@adacore.com>\n\n\t* exp_aggr.adb (Init_Hidden_Discriminants): If some ancestor is a\n\tprivate extension, get stored constraint, if any, from full view.\n\nFrom-SVN: r213479", "tree": {"sha": "19364ef153d21b8a1628cdc488ffb2be92aa4c31", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/19364ef153d21b8a1628cdc488ffb2be92aa4c31"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bdc193bad16766de82346ac6191a49e0771662c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bdc193bad16766de82346ac6191a49e0771662c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bdc193bad16766de82346ac6191a49e0771662c6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bdc193bad16766de82346ac6191a49e0771662c6/comments", "author": null, "committer": null, "parents": [{"sha": "8bef7ba92c0fc93e591042d962518b7d93ef507d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8bef7ba92c0fc93e591042d962518b7d93ef507d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8bef7ba92c0fc93e591042d962518b7d93ef507d"}], "stats": {"total": 228, "additions": 121, "deletions": 107}, "files": [{"sha": "c4654d130cd010aa56882e9e833170e63a3c5daa", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdc193bad16766de82346ac6191a49e0771662c6/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdc193bad16766de82346ac6191a49e0771662c6/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=bdc193bad16766de82346ac6191a49e0771662c6", "patch": "@@ -1,3 +1,16 @@\n+2014-08-01  Bob Duff  <duff@adacore.com>\n+\n+\t* gnat_ugn.texi: Minor updates.\n+\n+2014-08-01  Robert Dewar  <dewar@adacore.com>\n+\n+\t* atree.adb: Minor reformatting.\n+\n+2014-08-01  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* exp_aggr.adb (Init_Hidden_Discriminants): If some ancestor is a\n+\tprivate extension, get stored constraint, if any, from full view.\n+\n 2014-08-01  Robert Dewar  <dewar@adacore.com>\n \n \t* opt.ads (No_Elab_Code_All_Pragma): New global variable."}, {"sha": "2af7e2e48b9378b6b13e894e8bf1520ffa3d614e", "filename": "gcc/ada/atree.adb", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdc193bad16766de82346ac6191a49e0771662c6/gcc%2Fada%2Fatree.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdc193bad16766de82346ac6191a49e0771662c6/gcc%2Fada%2Fatree.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.adb?ref=bdc193bad16766de82346ac6191a49e0771662c6", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2013, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -1800,18 +1800,17 @@ package body Atree is\n       New_Node := New_Copy (Source);\n       Fix_Parents (Ref_Node => Source, Fix_Node => New_Node);\n \n-      --  We now set the parent of the new node to be the same as the\n-      --  parent of the source. Almost always this parent will be\n-      --  replaced by a new value when the relocated node is reattached\n-      --  to the tree, but by doing it now, we ensure that this node is\n-      --  not even temporarily disconnected from the tree. Note that this\n-      --  does not happen free, because in the list case, the parent does\n-      --  not get set.\n+      --  We now set the parent of the new node to be the same as the parent of\n+      --  the source. Almost always this parent will be replaced by a new value\n+      --  when the relocated node is reattached to the tree, but by doing it\n+      --  now, we ensure that this node is not even temporarily disconnected\n+      --  from the tree. Note that this does not happen free, because in the\n+      --  list case, the parent does not get set.\n \n       Set_Parent (New_Node, Parent (Source));\n \n-      --  If the node being relocated was a rewriting of some original\n-      --  node, then the relocated node has the same original node.\n+      --  If the node being relocated was a rewriting of some original node,\n+      --  then the relocated node has the same original node.\n \n       if Orig_Nodes.Table (Source) /= Source then\n          Orig_Nodes.Table (New_Node) := Orig_Nodes.Table (Source);"}, {"sha": "378d66fee631f9cf164fc6fedc7a96f1e354dfd0", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 94, "deletions": 89, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdc193bad16766de82346ac6191a49e0771662c6/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdc193bad16766de82346ac6191a49e0771662c6/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=bdc193bad16766de82346ac6191a49e0771662c6", "patch": "@@ -2132,10 +2132,19 @@ package body Exp_Aggr is\n \n             Disc := First_Discriminant (Parent_Type);\n \n-            --  We know that one of the stored-constraint lists is present.\n+            --  We know that one of the stored-constraint lists is present\n \n             if Present (Stored_Constraint (Btype)) then\n                Discr_Val := First_Elmt (Stored_Constraint (Btype));\n+\n+            --  For private extension, stored constraint may be on full view\n+\n+            elsif Is_Private_Type (Btype)\n+              and then Present (Full_View (Btype))\n+              and then Present (Stored_Constraint (Full_View (Btype)))\n+            then\n+               Discr_Val := First_Elmt (Stored_Constraint (Full_View (Btype)));\n+\n             else\n                Discr_Val := First_Elmt (Stored_Constraint (Typ));\n             end if;\n@@ -2197,10 +2206,10 @@ package body Exp_Aggr is\n          Finalization_Done := True;\n \n          --  Determine the external finalization list. It is either the\n-         --  finalization list of the outer-scope or the one coming from\n-         --  an outer aggregate. When the target is not a temporary, the\n-         --  proper scope is the scope of the target rather than the\n-         --  potentially transient current scope.\n+         --  finalization list of the outer-scope or the one coming from an\n+         --  outer aggregate. When the target is not a temporary, the proper\n+         --  scope is the scope of the target rather than the potentially\n+         --  transient current scope.\n \n          if Is_Controlled (Typ) and then Ancestor_Is_Subtype_Mark then\n             Ref := Convert_To (Init_Typ, New_Copy_Tree (Target));\n@@ -2433,6 +2442,7 @@ package body Exp_Aggr is\n             --  in the limited case, the ancestor part must be either a\n             --  function call (possibly qualified, or wrapped in an unchecked\n             --  conversion) or aggregate (definitely qualified).\n+\n             --  The ancestor part can also be a function call (that may be\n             --  transformed into an explicit dereference) or a qualification\n             --  of one such.\n@@ -3009,10 +3019,10 @@ package body Exp_Aggr is\n          Next (Comp);\n       end loop;\n \n-      --  If the type is tagged, the tag needs to be initialized (unless\n-      --  compiling for the Java VM where tags are implicit). It is done\n-      --  late in the initialization process because in some cases, we call\n-      --  the init proc of an ancestor which will not leave out the right tag\n+      --  If the type is tagged, the tag needs to be initialized (unless we\n+      --  are in VM-mode where tags are implicit). It is done late in the\n+      --  initialization process because in some cases, we call the init\n+      --  proc of an ancestor which will not leave out the right tag.\n \n       if Ancestor_Is_Expression then\n          null;\n@@ -3042,7 +3052,7 @@ package body Exp_Aggr is\n \n          Append_To (L, Instr);\n \n-         --  Ada 2005 (AI-251): If the tagged type has been derived from\n+         --  Ada 2005 (AI-251): If the tagged type has been derived from an\n          --  abstract interfaces we must also initialize the tags of the\n          --  secondary dispatch tables.\n \n@@ -3378,16 +3388,16 @@ package body Exp_Aggr is\n          or else (Parent_Kind = N_Assignment_Statement\n                    and then Inside_Init_Proc)\n \n-         --  (Ada 2005) An inherently limited type in a return statement,\n-         --  which will be handled in a build-in-place fashion, and may be\n-         --  rewritten as an extended return and have its own finalization\n-         --  machinery. In the case of a simple return, the aggregate needs\n-         --  to be delayed until the scope for the return statement has been\n-         --  created, so that any finalization chain will be associated with\n-         --  that scope. For extended returns, we delay expansion to avoid the\n-         --  creation of an unwanted transient scope that could result in\n-         --  premature finalization of the return object (which is built in\n-         --  in place within the caller's scope).\n+         --  (Ada 2005) An inherently limited type in a return statement, which\n+         --  will be handled in a build-in-place fashion, and may be rewritten\n+         --  as an extended return and have its own finalization machinery.\n+         --  In the case of a simple return, the aggregate needs to be delayed\n+         --  until the scope for the return statement has been created, so\n+         --  that any finalization chain will be associated with that scope.\n+         --  For extended returns, we delay expansion to avoid the creation\n+         --  of an unwanted transient scope that could result in premature\n+         --  finalization of the return object (which is built in in place\n+         --  within the caller's scope).\n \n          or else\n            (Is_Limited_View (Typ)\n@@ -3404,9 +3414,9 @@ package body Exp_Aggr is\n       end if;\n \n       --  If the aggregate is non-limited, create a temporary. If it is limited\n-      --  and the context is an assignment, this is a subaggregate for an\n-      --  enclosing aggregate being expanded. It must be built in place, so use\n-      --  the target of the current assignment.\n+      --  and context is an assignment, this is a subaggregate for an enclosing\n+      --  aggregate being expanded. It must be built in place, so use target of\n+      --  the current assignment.\n \n       if Is_Limited_Type (Typ)\n         and then Nkind (Parent (N)) = N_Assignment_Statement\n@@ -3491,6 +3501,8 @@ package body Exp_Aggr is\n       -- Check_Static_Components --\n       -----------------------------\n \n+      --  Could use some comments in this body ???\n+\n       procedure Check_Static_Components is\n          Expr : Node_Id;\n \n@@ -3777,15 +3789,16 @@ package body Exp_Aggr is\n \n                      else\n                         Choice_Index := UI_To_Int (Expr_Value (Choice));\n+\n                         if Choice_Index in Vals'Range then\n                            Vals (Choice_Index) :=\n                              New_Copy_Tree (Expression (Elmt));\n                            goto Continue;\n \n-                        else\n-                           --  Choice is statically out-of-range, will be\n-                           --  rewritten to raise Constraint_Error.\n+                        --  Choice is statically out-of-range, will be\n+                        --  rewritten to raise Constraint_Error.\n \n+                        else\n                            return False;\n                         end if;\n                      end if;\n@@ -3798,6 +3811,7 @@ package body Exp_Aggr is\n                      not Compile_Time_Known_Value (Hi)\n                   then\n                      return False;\n+\n                   else\n                      for J in UI_To_Int (Expr_Value (Lo)) ..\n                               UI_To_Int (Expr_Value (Hi))\n@@ -4175,7 +4189,8 @@ package body Exp_Aggr is\n          end if;\n \n          Remainder := Value rem 2**System_Storage_Unit;\n-         for I in 1 .. Nunits - 1 loop\n+\n+         for J in 1 .. Nunits - 1 loop\n             Value := Value / 2**System_Storage_Unit;\n \n             if Value rem 2**System_Storage_Unit /= Remainder then\n@@ -4240,7 +4255,7 @@ package body Exp_Aggr is\n          Decl :=\n            Make_Full_Type_Declaration (Loc,\n                Defining_Identifier => Agg_Type,\n-               Type_Definition =>\n+               Type_Definition     =>\n                  Make_Constrained_Array_Definition (Loc,\n                    Discrete_Subtype_Definitions => Indexes,\n                    Component_Definition         =>\n@@ -4274,7 +4289,7 @@ package body Exp_Aggr is\n          Get_Index_Bounds (Index_Bounds, Ind_Lo, Ind_Hi);\n \n          --  Generate the following test:\n-         --\n+\n          --    [constraint_error when\n          --      Aggr_Lo <= Aggr_Hi and then\n          --        (Aggr_Lo < Ind_Lo or else Aggr_Hi > Ind_Hi)]\n@@ -4364,8 +4379,7 @@ package body Exp_Aggr is\n          if Index_Checks_Suppressed (Ind_Typ) then\n             Cond := Empty;\n \n-         elsif Dim = 1\n-           or else (Aggr_Lo = Sub_Lo and then Aggr_Hi = Sub_Hi)\n+         elsif Dim = 1 or else (Aggr_Lo = Sub_Lo and then Aggr_Hi = Sub_Hi)\n          then\n             Cond := Empty;\n \n@@ -4588,12 +4602,12 @@ package body Exp_Aggr is\n          --  Start of processing for Safe_Component\n \n          begin\n-            --  If the component appears in an association that may\n-            --  correspond to more than one element, it is not analyzed\n-            --  before the expansion into assignments, to avoid side effects.\n-            --  We analyze, but do not resolve the copy, to obtain sufficient\n-            --  entity information for the checks that follow. If component is\n-            --  overloaded we assume an unsafe function call.\n+            --  If the component appears in an association that may correspond\n+            --  to more than one element, it is not analyzed before expansion\n+            --  into assignments, to avoid side effects. We analyze, but do not\n+            --  resolve the copy, to obtain sufficient entity information for\n+            --  the checks that follow. If component is overloaded we assume\n+            --  an unsafe function call.\n \n             if not Analyzed (Comp) then\n                if Is_Overloaded (Expr) then\n@@ -4632,9 +4646,9 @@ package body Exp_Aggr is\n             --  assignment in place unless the bounds of the aggregate are\n             --  statically equal to those of the target.\n \n-            --  If the aggregate is given by an others choice, the bounds\n-            --  are derived from the left-hand side, and the assignment is\n-            --  safe if the expression is.\n+            --  If the aggregate is given by an others choice, the bounds are\n+            --  derived from the left-hand side, and the assignment is safe if\n+            --  the expression is.\n \n             if Is_Others_Aggregate (N) then\n                return\n@@ -4648,8 +4662,8 @@ package body Exp_Aggr is\n                Obj_In  := First_Index (Etype (Name (Parent (N))));\n \n             else\n-               --  Context is an allocator. Check bounds of aggregate\n-               --  against given type in qualified expression.\n+               --  Context is an allocator. Check bounds of aggregate against\n+               --  given type in qualified expression.\n \n                pragma Assert (Nkind (Parent (Parent (N))) = N_Allocator);\n                Obj_In :=\n@@ -4733,6 +4747,8 @@ package body Exp_Aggr is\n                --  Count the number of discrete choices. Start with -1 because\n                --  the others choice does not count.\n \n+               --  Is there some reason we do not use List_Length here ???\n+\n                Nb_Choices := -1;\n                Assoc := First (Component_Associations (Sub_Aggr));\n                while Present (Assoc) loop\n@@ -4834,7 +4850,7 @@ package body Exp_Aggr is\n                         Expressions    =>\n                           New_List\n                             (Duplicate_Subexpr_Move_Checks (Aggr_Lo))),\n-                    Right_Opnd => Make_Integer_Literal (Loc, Nb_Elements - 1)),\n+                Right_Opnd => Make_Integer_Literal (Loc, Nb_Elements - 1)),\n \n                 Right_Opnd =>\n                   Make_Attribute_Reference (Loc,\n@@ -4854,17 +4870,13 @@ package body Exp_Aggr is\n               Make_Or_Else (Loc,\n                 Left_Opnd =>\n                   Make_Op_Lt (Loc,\n-                    Left_Opnd  =>\n-                      Duplicate_Subexpr_Move_Checks (Choices_Lo),\n-                    Right_Opnd =>\n-                      Duplicate_Subexpr_Move_Checks (Aggr_Lo)),\n+                    Left_Opnd  => Duplicate_Subexpr_Move_Checks (Choices_Lo),\n+                    Right_Opnd => Duplicate_Subexpr_Move_Checks (Aggr_Lo)),\n \n                 Right_Opnd =>\n                   Make_Op_Gt (Loc,\n-                    Left_Opnd  =>\n-                      Duplicate_Subexpr (Choices_Hi),\n-                    Right_Opnd =>\n-                      Duplicate_Subexpr (Aggr_Hi)));\n+                    Left_Opnd  => Duplicate_Subexpr (Choices_Hi),\n+                    Right_Opnd => Duplicate_Subexpr (Aggr_Hi)));\n          end if;\n \n          if Present (Cond) then\n@@ -5027,12 +5039,12 @@ package body Exp_Aggr is\n          Compute_Others_Present (N, 1);\n \n          for J in 1 .. Aggr_Dimension loop\n-            --  There is no need to emit a check if an others choice is\n-            --  present for this array aggregate dimension since in this\n-            --  case one of N's sub-aggregates has taken its bounds from the\n-            --  context and these bounds must have been checked already. In\n-            --  addition all sub-aggregates corresponding to the same\n-            --  dimension must all have the same bounds (checked in (c) below).\n+            --  There is no need to emit a check if an others choice is present\n+            --  for this array aggregate dimension since in this case one of\n+            --  N's sub-aggregates has taken its bounds from the context and\n+            --  these bounds must have been checked already. In addition all\n+            --  sub-aggregates corresponding to the same dimension must all\n+            --  have the same bounds (checked in (c) below).\n \n             if not Range_Checks_Suppressed (Etype (Index_Constraint))\n               and then not Others_Present (J)\n@@ -5261,8 +5273,8 @@ package body Exp_Aggr is\n           (Nkind (Parent (N)) = N_Assignment_Statement\n             and then In_Place_Assign_OK)\n \n-          or else\n-            (Nkind (Parent (Parent (N))) = N_Allocator\n+            or else\n+             (Nkind (Parent (Parent (N))) = N_Allocator\n               and then In_Place_Assign_OK);\n       end if;\n \n@@ -5365,10 +5377,9 @@ package body Exp_Aggr is\n          Maybe_In_Place_OK := False;\n          Tmp := Make_Temporary (Loc, 'A', N);\n          Tmp_Decl :=\n-           Make_Object_Declaration\n-             (Loc,\n-              Defining_Identifier => Tmp,\n-              Object_Definition   => New_Occurrence_Of (Typ, Loc));\n+           Make_Object_Declaration (Loc,\n+             Defining_Identifier => Tmp,\n+             Object_Definition   => New_Occurrence_Of (Typ, Loc));\n          Set_No_Initialization (Tmp_Decl, True);\n \n          --  If we are within a loop, the temporary will be pushed on the\n@@ -5398,7 +5409,6 @@ package body Exp_Aggr is\n             Target := New_Occurrence_Of (Tmp, Loc);\n \n          else\n-\n             if Has_Default_Init_Comps (N) then\n \n                --  Ada 2005 (AI-287): This case has not been analyzed???\n@@ -5606,6 +5616,7 @@ package body Exp_Aggr is\n \n          Expand_Array_Aggregate (N);\n       end if;\n+\n    exception\n       when RE_Not_Available =>\n          return;\n@@ -5887,11 +5898,11 @@ package body Exp_Aggr is\n    --  Start of processing for Expand_Record_Aggregate\n \n    begin\n-      --  If the aggregate is to be assigned to an atomic variable, we\n-      --  have to prevent a piecemeal assignment even if the aggregate\n-      --  is to be expanded. We create a temporary for the aggregate, and\n-      --  assign the temporary instead, so that the back end can generate\n-      --  an atomic move for it.\n+      --  If the aggregate is to be assigned to an atomic variable, we have\n+      --  to prevent a piecemeal assignment even if the aggregate is to be\n+      --  expanded. We create a temporary for the aggregate, and assign the\n+      --  temporary instead, so that the back end can generate an atomic move\n+      --  for it.\n \n       if Is_Atomic (Typ)\n         and then Comes_From_Source (Parent (N))\n@@ -6054,9 +6065,9 @@ package body Exp_Aggr is\n                            New_List (New_Occurrence_Of (Discriminant, Loc)),\n \n                          Expression =>\n-                           New_Copy_Tree (\n-                             Get_Discriminant_Value (\n-                                 Discriminant,\n+                           New_Copy_Tree\n+                             (Get_Discriminant_Value\n+                                (Discriminant,\n                                  Typ,\n                                  Discriminant_Constraint (Typ))));\n \n@@ -6081,8 +6092,7 @@ package body Exp_Aggr is\n                   Comp := First_Comp;\n                   Next (First_Comp);\n \n-                  if Ekind (Entity\n-                             (First (Choices (Comp)))) = E_Discriminant\n+                  if Ekind (Entity (First (Choices (Comp)))) = E_Discriminant\n                   then\n                      Remove (Comp);\n                      Num_Disc := Num_Disc + 1;\n@@ -6120,20 +6130,20 @@ package body Exp_Aggr is\n                        New_Copy_Tree\n                          (Get_Discriminant_Value\n                             (Discriminant,\n-                              Typ,\n-                              Discriminant_Constraint (Typ)));\n+                             Typ,\n+                             Discriminant_Constraint (Typ)));\n                      Append (New_Comp, Constraints);\n                      Next_Stored_Discriminant (Discriminant);\n                   end loop;\n \n                   Decl :=\n                     Make_Subtype_Declaration (Loc,\n                       Defining_Identifier => Make_Temporary (Loc, 'T'),\n-                      Subtype_Indication =>\n+                      Subtype_Indication  =>\n                         Make_Subtype_Indication (Loc,\n                           Subtype_Mark =>\n                             New_Occurrence_Of (Etype (Base_Type (Typ)), Loc),\n-                          Constraint =>\n+                          Constraint   =>\n                             Make_Index_Or_Discriminant_Constraint\n                               (Loc, Constraints)));\n \n@@ -6175,18 +6185,16 @@ package body Exp_Aggr is\n \n                   --  Skip all expander-generated components\n \n-                  if\n-                    not Comes_From_Source (Original_Record_Component (Comp))\n+                  if not Comes_From_Source (Original_Record_Component (Comp))\n                   then\n                      null;\n \n                   else\n                      New_Comp :=\n                        Make_Selected_Component (Loc,\n-                         Prefix =>\n+                         Prefix        =>\n                            Unchecked_Convert_To (Typ,\n                              Duplicate_Subexpr (Parent_Expr, True)),\n-\n                          Selector_Name => New_Occurrence_Of (Comp, Loc));\n \n                      Append_To (Comps,\n@@ -6311,6 +6319,7 @@ package body Exp_Aggr is\n       Comps : constant List_Id := Component_Associations (N);\n       C     : Node_Id;\n       Expr  : Node_Id;\n+\n    begin\n       pragma Assert (Nkind_In (N, N_Aggregate, N_Extension_Aggregate));\n \n@@ -6471,7 +6480,6 @@ package body Exp_Aggr is\n    is\n    begin\n       Set_Assignment_OK (Name);\n-\n       return Make_Assignment_Statement (Sloc, Name, Expression);\n    end Make_OK_Assignment_Statement;\n \n@@ -6977,14 +6985,12 @@ package body Exp_Aggr is\n             Incr := +Comp_Size;\n          end if;\n \n-         Shift := Init_Shift;\n-         One_Dim := First (Expressions (N));\n-\n          --  Iterate over each subaggregate\n \n+         Shift := Init_Shift;\n+         One_Dim := First (Expressions (N));\n          while Present (One_Dim) loop\n             One_Comp := First (Expressions (One_Dim));\n-\n             while Present (One_Comp) loop\n                if Packed_Num = Byte_Size / Comp_Size then\n \n@@ -7026,8 +7032,7 @@ package body Exp_Aggr is\n              Unchecked_Convert_To (Typ,\n                Make_Qualified_Expression (Loc,\n                  Subtype_Mark => New_Occurrence_Of (Packed_Array, Loc),\n-                 Expression   =>\n-                   Make_Aggregate (Loc,  Expressions => Comps))));\n+                 Expression   => Make_Aggregate (Loc, Expressions => Comps))));\n          Analyze_And_Resolve (N);\n          return True;\n       end;"}, {"sha": "5293eab30501b9354f8a410472bb0e4f36ec88ff", "filename": "gcc/ada/gnat_ugn.texi", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdc193bad16766de82346ac6191a49e0771662c6/gcc%2Fada%2Fgnat_ugn.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdc193bad16766de82346ac6191a49e0771662c6/gcc%2Fada%2Fgnat_ugn.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_ugn.texi?ref=bdc193bad16766de82346ac6191a49e0771662c6", "patch": "@@ -14140,10 +14140,9 @@ tool argument.\n Incremental processing on a per-file basis. Source files are only\n processed if they have been modified, or if files they depend on have\n been modified. This is similar to the way gnatmake/gprbuild only\n-compiles files that need to be recompiled. Note that in this mode\n-@command{gnatpp} is acting in place of the compiler, so if a project\n-file is used, the switches set for the compiler should not be set\n-to switches recognized by @command{gcc}.\n+compiles files that need to be recompiled. A project file is required\n+in this mode, and the gnat driver (as in @command{gnat pretty}) is not\n+supported.\n \n @item --pp-off=@var{xxx}\n @cindex @option{--pp-off} @command{gnatpp}\n@@ -14577,10 +14576,8 @@ options:\n --incremental -- incremental processing on a per-file basis. Source files are\n       only processed if they have been modified, or if files they depend\n       on have been modified. This is similar to the way gnatmake/gprbuild\n-      only compiles files that need to be recompiled. Note that in this mode\n-      @command{gnat2xml} is acting in place of the compiler, so if a project\n-      file is used, the switches set for the compiler should not be set\n-      to switches recognized by @command{gcc}.\n+      only compiles files that need to be recompiled. A project file\n+      is required in this mode.\n \n -j@var{n} -- In @option{--incremental} mode, use @var{n} @command{gnat2xml}\n       processes to perform XML generation in parallel. If @var{n} is 0, then"}]}