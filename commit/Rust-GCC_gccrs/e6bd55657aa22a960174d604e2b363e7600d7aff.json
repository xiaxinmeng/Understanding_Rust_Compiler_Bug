{"sha": "e6bd55657aa22a960174d604e2b363e7600d7aff", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTZiZDU1NjU3YWEyMmE5NjAxNzRkNjA0ZTJiMzYzZTc2MDBkN2FmZg==", "commit": {"author": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2006-06-15T05:49:19Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2006-06-15T05:49:19Z"}, "message": "re PR c++/26559 (ICE with __builtin_constant_p in template argument)\n\n\tPR c++/26559\n\t* pt.c (tsubst_expr): Use finish_omp_atomic.\n\t(value_dependent_expression_p): All CALL_EXPRs are dependent.\n\t* semantics.c (finish_omp_atomic): Rework to use standard\n\tparadigms for handling non-dependent expressions.\n\nFrom-SVN: r114671", "tree": {"sha": "dc8c58c5f22b679a93f2bbb7b3e86bd109033421", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dc8c58c5f22b679a93f2bbb7b3e86bd109033421"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e6bd55657aa22a960174d604e2b363e7600d7aff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6bd55657aa22a960174d604e2b363e7600d7aff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e6bd55657aa22a960174d604e2b363e7600d7aff", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6bd55657aa22a960174d604e2b363e7600d7aff/comments", "author": null, "committer": null, "parents": [{"sha": "4c4e648c764466b842ddaae513af83f7ac88c21c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c4e648c764466b842ddaae513af83f7ac88c21c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c4e648c764466b842ddaae513af83f7ac88c21c"}], "stats": {"total": 47, "additions": 32, "deletions": 15}, "files": [{"sha": "bb535559117d751ea5c58589fd1c1495ab4fb680", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 32, "deletions": 15, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6bd55657aa22a960174d604e2b363e7600d7aff/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6bd55657aa22a960174d604e2b363e7600d7aff/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=e6bd55657aa22a960174d604e2b363e7600d7aff", "patch": "@@ -3834,24 +3834,41 @@ finish_omp_for (location_t locus, tree decl, tree init, tree cond,\n void\n finish_omp_atomic (enum tree_code code, tree lhs, tree rhs)\n {\n-  /* If either of the operands are dependent, we can't do semantic\n-     processing yet.  Stuff the values away for now.  We cheat a bit\n-     and use the same tree code for this, even though the operands\n-     are of totally different form, thus we need to remember which\n-     statements are which, thus the lang_flag bit.  */\n-  /* ??? We ought to be using type_dependent_expression_p, but the\n-     invocation of build_modify_expr in c_finish_omp_atomic can result\n-     in the creation of CONVERT_EXPRs, which are not handled by\n-     tsubst_copy_and_build.  */\n-  if (uses_template_parms (lhs) || uses_template_parms (rhs))\n-    {\n-      tree stmt = build2 (OMP_ATOMIC, void_type_node, lhs, rhs);\n+  tree orig_lhs;\n+  tree orig_rhs;\n+  bool dependent_p;\n+  tree stmt;\n+\n+  orig_lhs = lhs;\n+  orig_rhs = rhs;\n+  dependent_p = false;\n+  stmt = NULL_TREE;\n+\n+  /* Even in a template, we can detect invalid uses of the atomic\n+     pragma if neither LHS nor RHS is type-dependent.  */\n+  if (processing_template_decl)\n+    {\n+      dependent_p = (type_dependent_expression_p (lhs) \n+\t\t     || type_dependent_expression_p (rhs));\n+      if (!dependent_p)\n+\t{\n+\t  lhs = build_non_dependent_expr (lhs);\n+\t  rhs = build_non_dependent_expr (rhs);\n+\t}\n+    }\n+  if (!dependent_p)\n+    {\n+      stmt = c_finish_omp_atomic (code, lhs, rhs);\n+      if (stmt == error_mark_node)\n+\treturn;\n+    }\n+  if (processing_template_decl)\n+    {\n+      stmt = build2 (OMP_ATOMIC, void_type_node, orig_lhs, orig_rhs);\n       OMP_ATOMIC_DEPENDENT_P (stmt) = 1;\n       OMP_ATOMIC_CODE (stmt) = code;\n-      add_stmt (stmt);\n     }\n-  else\n-    c_finish_omp_atomic (code, lhs, rhs);\n+  add_stmt (stmt);\n }\n \n void"}]}