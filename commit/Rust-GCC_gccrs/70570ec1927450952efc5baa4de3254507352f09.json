{"sha": "70570ec1927450952efc5baa4de3254507352f09", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzA1NzBlYzE5Mjc0NTA5NTJlZmM1YmFhNGRlMzI1NDUwNzM1MmYwOQ==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2019-09-01T12:53:02Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2019-09-01T12:53:02Z"}, "message": "array.c (spec_dimen_size): Check for the presence of expressions for the bounds.\n\n2019-09-01  Paul Thomas  <pault@gcc.gnu.org>\n\n\t* array.c (spec_dimen_size): Check for the presence of\n\texpressions for the bounds.\n\t* decl.c (gfc_match_end): Add case COMP_SELECT_RANK.\n\t* dump-parse-tree.c(show_symbol): Show the arrayspec of class\n\tentities.\n\t(show_code_node): Show the code for SELECT_RANK.\n\t* expr.c (gfc_check_vardef_context): Omit the context of\n\tvariable definition for select rank associate names since the\n\tASSUMED RANK throws.\n\t* gfortran.h : Add ST_SELECT_RANK and ST_RANK to enum\n\tgfc_statement. Add select_rank_temporary to symbol attribute\n\tstructure. Add EXEC_SELECT_RANK to enum gfc_exec_op.\n\t* match.c (match_exit_cycle): Add COMP_SELECT_RANK.\n\t(copy_ts_from_selector_to_associate): Add as special case for\n\tassumed rank class variables.\n\t(select_intrinsic_set_tmp): Clean up the code by using symbols\n\tfor references to the temporary and the selector.\n\t(select_type_set_tmp): Ditto.\n\t(select_rank_set_tmp): New function.\n\t(gfc_match_select_rank): New function.\n\t(gfc_match_rank_is): New function.\n\t* match.h : Add prototypes for gfc_match_select_rank and\n\tgfc_match_rank_is.\n\t* parse.c (decode_statement): Attempt to match select_rank and\n\trank statements.\n\t(next_statement, gfc_ascii_statement): Add ST_SELECT_RANK.\n\t(parse_select_rank_block): New function.\n\t(parse_executable): Parse select rank block for ST_SELECT_RANK.\n\t* parse.h : Add COMP_SELECT_RANK to enum gfc_compile_state.\n\t* resolve.c (resolve_variable): Exclude select_rank_temporaries\n\tfrom the check on use of ASSUMED RANK.\n\t(gfc_resolve_expr): Make sure that unlimited polymorphic select\n\trank temporaries expressions are not resolved again after being\n\tsuccessfully resolved.\n\t(resolve_assoc_var): Do not do the rank check for select rank\n\ttemporaries.\n\t(resolve_select_rank): New function.\n\t(gfc_resolve_blocks): Deal with case EXEC_SELECT_RANK.\n\t(resolve_symbol): Exclude select rank temporaries for check on\n\tuse of ASSUMED RANK.\n\t* st.c (gfc_free_statement): Include EXEC_SELECT_RANK.\n\t* trans-array.c (gfc_conv_array_ref): Select rank temporaries\n\tmay have dimen == 0.\n\t(gfc_conv_expr_descriptor): Zero the offset of select rank\n\ttemporaries.\n\t* trans-stmt.c (copy_descriptor): New function.\n\t(trans_associate_var): Add code to associate select rank temps.\n\t(gfc_trans_select_rank_cases): New function.\n\t(gfc_trans_select_rank): New function.\n\t* trans-stmt.h : Add prototype for gfc_trans_select_rank.\n\ttrans.c (trans_code): Add select rank case.\n\n\n2019-09-01  Paul Thomas  <pault@gcc.gnu.org>\n\n\t* gfortran.dg/select_rank_1.f90 : New test.\n\t* gfortran.dg/select_rank_2.f90 : New test.\n\nFrom-SVN: r275269", "tree": {"sha": "d0baf00593ad714a097942a7238267ec362f1411", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d0baf00593ad714a097942a7238267ec362f1411"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/70570ec1927450952efc5baa4de3254507352f09", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70570ec1927450952efc5baa4de3254507352f09", "html_url": "https://github.com/Rust-GCC/gccrs/commit/70570ec1927450952efc5baa4de3254507352f09", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70570ec1927450952efc5baa4de3254507352f09/comments", "author": null, "committer": null, "parents": [{"sha": "3e7254c5e4a0545059ca61b34134f7ef5c3d3a86", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e7254c5e4a0545059ca61b34134f7ef5c3d3a86", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3e7254c5e4a0545059ca61b34134f7ef5c3d3a86"}], "stats": {"total": 1432, "additions": 1355, "deletions": 77}, "files": [{"sha": "0ed86cee170048a6d28994b63194b52a13181545", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 55, "deletions": 1, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70570ec1927450952efc5baa4de3254507352f09/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70570ec1927450952efc5baa4de3254507352f09/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=70570ec1927450952efc5baa4de3254507352f09", "patch": "@@ -1,3 +1,57 @@\n+2019-09-01  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\t* array.c (spec_dimen_size): Check for the presence of\n+\texpressions for the bounds.\n+\t* decl.c (gfc_match_end): Add case COMP_SELECT_RANK.\n+\t* dump-parse-tree.c(show_symbol): Show the arrayspec of class\n+\tentities.\n+\t(show_code_node): Show the code for SELECT_RANK.\n+\t* expr.c (gfc_check_vardef_context): Omit the context of\n+\tvariable definition for select rank associate names since the\n+\tASSUMED RANK throws.\n+\t* gfortran.h : Add ST_SELECT_RANK and ST_RANK to enum\n+\tgfc_statement. Add select_rank_temporary to symbol attribute\n+\tstructure. Add EXEC_SELECT_RANK to enum gfc_exec_op.\n+\t* match.c (match_exit_cycle): Add COMP_SELECT_RANK.\n+\t(copy_ts_from_selector_to_associate): Add as special case for\n+\tassumed rank class variables.\n+\t(select_intrinsic_set_tmp): Clean up the code by using symbols\n+\tfor references to the temporary and the selector.\n+\t(select_type_set_tmp): Ditto.\n+\t(select_rank_set_tmp): New function.\n+\t(gfc_match_select_rank): New function.\n+\t(gfc_match_rank_is): New function.\n+\t* match.h : Add prototypes for gfc_match_select_rank and\n+\tgfc_match_rank_is.\n+\t* parse.c (decode_statement): Attempt to match select_rank and\n+\trank statements.\n+\t(next_statement, gfc_ascii_statement): Add ST_SELECT_RANK.\n+\t(parse_select_rank_block): New function.\n+\t(parse_executable): Parse select rank block for ST_SELECT_RANK.\n+\t* parse.h : Add COMP_SELECT_RANK to enum gfc_compile_state.\n+\t* resolve.c (resolve_variable): Exclude select_rank_temporaries\n+\tfrom the check on use of ASSUMED RANK.\n+\t(gfc_resolve_expr): Make sure that unlimited polymorphic select\n+\trank temporaries expressions are not resolved again after being\n+\tsuccessfully resolved.\n+\t(resolve_assoc_var): Do not do the rank check for select rank\n+\ttemporaries.\n+\t(resolve_select_rank): New function.\n+\t(gfc_resolve_blocks): Deal with case EXEC_SELECT_RANK.\n+\t(resolve_symbol): Exclude select rank temporaries for check on\n+\tuse of ASSUMED RANK.\n+\t* st.c (gfc_free_statement): Include EXEC_SELECT_RANK.\n+\t* trans-array.c (gfc_conv_array_ref): Select rank temporaries\n+\tmay have dimen == 0.\n+\t(gfc_conv_expr_descriptor): Zero the offset of select rank\n+\ttemporaries.\n+\t* trans-stmt.c (copy_descriptor): New function.\n+\t(trans_associate_var): Add code to associate select rank temps.\n+\t(gfc_trans_select_rank_cases): New function.\n+\t(gfc_trans_select_rank): New function.\n+\t* trans-stmt.h : Add prototype for gfc_trans_select_rank.\n+\ttrans.c (trans_code): Add select rank case.\n+\n 2019-08-30  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \tPR fortran/91587\n@@ -49,7 +103,7 @@\n 2019-08-27  Mark Eggleston  <mark.eggleston@codethink.com>\n \n \t* invoke.texi: Ensure that the option lists fit within the\n-\tmargins of a PDF page.  Re-worded description of \n+\tmargins of a PDF page.  Re-worded description of\n \t'-ffrontend-loop-interchange' so that it fits with the margins\n \tof a PDF page.  Add '-fdec-include', '-fdec-blank-format-item'\n \tand '-fdec-format-defaults' to list of options that are enabled"}, {"sha": "b972abe8a38bc13698a194ae38eefbb73504f555", "filename": "gcc/fortran/array.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70570ec1927450952efc5baa4de3254507352f09/gcc%2Ffortran%2Farray.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70570ec1927450952efc5baa4de3254507352f09/gcc%2Ffortran%2Farray.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Farray.c?ref=70570ec1927450952efc5baa4de3254507352f09", "patch": "@@ -2213,7 +2213,11 @@ spec_dimen_size (gfc_array_spec *as, int dimen, mpz_t *result)\n     gfc_internal_error (\"spec_dimen_size(): Bad dimension\");\n \n   if (as->type != AS_EXPLICIT\n-      || as->lower[dimen]->expr_type != EXPR_CONSTANT\n+      || !as->lower[dimen]\n+      || !as->upper[dimen])\n+    return false;\n+\n+  if (as->lower[dimen]->expr_type != EXPR_CONSTANT\n       || as->upper[dimen]->expr_type != EXPR_CONSTANT\n       || as->lower[dimen]->ts.type != BT_INTEGER\n       || as->upper[dimen]->ts.type != BT_INTEGER)"}, {"sha": "071119157d6dafd746da88d0b68e2e888a32f4ff", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70570ec1927450952efc5baa4de3254507352f09/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70570ec1927450952efc5baa4de3254507352f09/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=70570ec1927450952efc5baa4de3254507352f09", "patch": "@@ -8164,6 +8164,7 @@ gfc_match_end (gfc_statement *st)\n \n     case COMP_SELECT:\n     case COMP_SELECT_TYPE:\n+    case COMP_SELECT_RANK:\n       *st = ST_END_SELECT;\n       target = \" select\";\n       eos_ok = 0;"}, {"sha": "513f211b68b793681ac099eac2a0b0c792f035b4", "filename": "gcc/fortran/dump-parse-tree.c", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70570ec1927450952efc5baa4de3254507352f09/gcc%2Ffortran%2Fdump-parse-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70570ec1927450952efc5baa4de3254507352f09/gcc%2Ffortran%2Fdump-parse-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdump-parse-tree.c?ref=70570ec1927450952efc5baa4de3254507352f09", "patch": "@@ -1000,12 +1000,18 @@ show_symbol (gfc_symbol *sym)\n       show_expr (sym->value);\n     }\n \n-  if (sym->as)\n+  if (sym->ts.type != BT_CLASS && sym->as)\n     {\n       show_indent ();\n       fputs (\"Array spec:\", dumpfile);\n       show_array_spec (sym->as);\n     }\n+  else if (sym->ts.type == BT_CLASS && CLASS_DATA (sym)->as)\n+    {\n+      show_indent ();\n+      fputs (\"Array spec:\", dumpfile);\n+      show_array_spec (CLASS_DATA (sym)->as);\n+    }\n \n   if (sym->generic)\n     {\n@@ -2168,18 +2174,22 @@ show_code_node (int level, gfc_code *c)\n \n     case EXEC_SELECT:\n     case EXEC_SELECT_TYPE:\n+    case EXEC_SELECT_RANK:\n       d = c->block;\n-      if (c->op == EXEC_SELECT_TYPE)\n+      fputc ('\\n', dumpfile);\n+      code_indent (level, 0);\n+      if (c->op == EXEC_SELECT_RANK)\n+\tfputs (\"SELECT RANK \", dumpfile);\n+      else if (c->op == EXEC_SELECT_TYPE)\n \tfputs (\"SELECT TYPE \", dumpfile);\n       else\n \tfputs (\"SELECT CASE \", dumpfile);\n       show_expr (c->expr1);\n-      fputc ('\\n', dumpfile);\n \n       for (; d; d = d->block)\n \t{\n+\t  fputc ('\\n', dumpfile);\n \t  code_indent (level, 0);\n-\n \t  fputs (\"CASE \", dumpfile);\n \t  for (cp = d->ext.block.case_list; cp; cp = cp->next)\n \t    {\n@@ -2190,9 +2200,9 @@ show_code_node (int level, gfc_code *c)\n \t      fputc (')', dumpfile);\n \t      fputc (' ', dumpfile);\n \t    }\n-\t  fputc ('\\n', dumpfile);\n \n \t  show_code (level + 1, d->next);\n+\t  fputc ('\\n', dumpfile);\n \t}\n \n       code_indent (level, c->label1);"}, {"sha": "c6d17d6f27f39fbb08e0884ed9e53665c798b2d0", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70570ec1927450952efc5baa4de3254507352f09/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70570ec1927450952efc5baa4de3254507352f09/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=70570ec1927450952efc5baa4de3254507352f09", "patch": "@@ -6181,7 +6181,7 @@ gfc_check_vardef_context (gfc_expr* e, bool pointer, bool alloc_obj,\n \t}\n     }\n   /* Check variable definition context for associate-names.  */\n-  if (!pointer && sym->assoc)\n+  if (!pointer && sym->assoc && !sym->attr.select_rank_temporary)\n     {\n       const char* name;\n       gfc_association_list* assoc;"}, {"sha": "80e31ee1a877b8eff6826a1b8abddb140b12f13a", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70570ec1927450952efc5baa4de3254507352f09/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70570ec1927450952efc5baa4de3254507352f09/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=70570ec1927450952efc5baa4de3254507352f09", "patch": "@@ -216,7 +216,7 @@ enum gfc_statement\n   ST_POINTER_ASSIGNMENT, ST_SELECT_CASE, ST_SEQUENCE, ST_SIMPLE_IF,\n   ST_STATEMENT_FUNCTION, ST_DERIVED_DECL, ST_LABEL_ASSIGNMENT, ST_ENUM,\n   ST_ENUMERATOR, ST_END_ENUM, ST_SELECT_TYPE, ST_TYPE_IS, ST_CLASS_IS,\n-  ST_STRUCTURE_DECL, ST_END_STRUCTURE,\n+  ST_SELECT_RANK, ST_RANK, ST_STRUCTURE_DECL, ST_END_STRUCTURE,\n   ST_UNION, ST_END_UNION, ST_MAP, ST_END_MAP,\n   ST_OACC_PARALLEL_LOOP, ST_OACC_END_PARALLEL_LOOP, ST_OACC_PARALLEL,\n   ST_OACC_END_PARALLEL, ST_OACC_KERNELS, ST_OACC_END_KERNELS, ST_OACC_DATA,\n@@ -894,9 +894,9 @@ typedef struct\n \t   event_comp:1, defined_assign_comp:1, unlimited_polymorphic:1,\n \t   has_dtio_procs:1, caf_token:1;\n \n-  /* This is a temporary selector for SELECT TYPE or an associate\n-     variable for SELECT_TYPE or ASSOCIATE.  */\n-  unsigned select_type_temporary:1, associate_var:1;\n+  /* This is a temporary selector for SELECT TYPE/RANK or an associate\n+     variable for SELECT TYPE/RANK or ASSOCIATE.  */\n+  unsigned select_type_temporary:1, select_rank_temporary:1, associate_var:1;\n \n   /* These are the attributes required for parameterized derived\n      types.  */\n@@ -2555,8 +2555,8 @@ enum gfc_exec_op\n   EXEC_IF, EXEC_ARITHMETIC_IF, EXEC_DO, EXEC_DO_CONCURRENT, EXEC_DO_WHILE,\n   EXEC_SELECT, EXEC_BLOCK, EXEC_FORALL, EXEC_WHERE, EXEC_CYCLE, EXEC_EXIT,\n   EXEC_CALL_PPC, EXEC_ALLOCATE, EXEC_DEALLOCATE, EXEC_END_PROCEDURE,\n-  EXEC_SELECT_TYPE, EXEC_SYNC_ALL, EXEC_SYNC_MEMORY, EXEC_SYNC_IMAGES,\n-  EXEC_OPEN, EXEC_CLOSE, EXEC_WAIT,\n+  EXEC_SELECT_TYPE, EXEC_SELECT_RANK, EXEC_SYNC_ALL, EXEC_SYNC_MEMORY,\n+  EXEC_SYNC_IMAGES, EXEC_OPEN, EXEC_CLOSE, EXEC_WAIT,\n   EXEC_READ, EXEC_WRITE, EXEC_IOLENGTH, EXEC_TRANSFER, EXEC_DT_END,\n   EXEC_BACKSPACE, EXEC_ENDFILE, EXEC_INQUIRE, EXEC_REWIND, EXEC_FLUSH,\n   EXEC_FORM_TEAM, EXEC_CHANGE_TEAM, EXEC_END_TEAM, EXEC_SYNC_TEAM,"}, {"sha": "56d9af047777f366900250f2d4d715a884d52b16", "filename": "gcc/fortran/match.c", "status": "modified", "additions": 386, "deletions": 41, "changes": 427, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70570ec1927450952efc5baa4de3254507352f09/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70570ec1927450952efc5baa4de3254507352f09/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=70570ec1927450952efc5baa4de3254507352f09", "patch": "@@ -2825,6 +2825,7 @@ match_exit_cycle (gfc_statement st, gfc_exec_op op)\n     case COMP_IF:\n     case COMP_SELECT:\n     case COMP_SELECT_TYPE:\n+    case COMP_SELECT_RANK:\n       gcc_assert (sym);\n       if (op == EXEC_CYCLE)\n \t{\n@@ -6065,7 +6066,14 @@ copy_ts_from_selector_to_associate (gfc_expr *associate, gfc_expr *selector)\n     ref = ref->next;\n \n   if (selector->ts.type == BT_CLASS && CLASS_DATA (selector)->as\n-      && ref && ref->type == REF_ARRAY)\n+      && CLASS_DATA (selector)->as->type == AS_ASSUMED_RANK)\n+    {\n+      assoc_sym->attr.dimension = 1;\n+      assoc_sym->as = gfc_copy_array_spec (CLASS_DATA (selector)->as);\n+      goto build_class_sym;\n+    }\n+  else if (selector->ts.type == BT_CLASS && CLASS_DATA (selector)->as\n+\t   && ref && ref->type == REF_ARRAY)\n     {\n       /* Ensure that the array reference type is set.  We cannot use\n \t gfc_resolve_expr at this point, so the usable parts of\n@@ -6116,6 +6124,7 @@ copy_ts_from_selector_to_associate (gfc_expr *associate, gfc_expr *selector)\n   else\n     assoc_sym->as = NULL;\n \n+build_class_sym:\n   if (selector->ts.type == BT_CLASS)\n     {\n       /* The correct class container has to be available.  */\n@@ -6149,14 +6158,17 @@ select_intrinsic_set_tmp (gfc_typespec *ts)\n   char name[GFC_MAX_SYMBOL_LEN];\n   gfc_symtree *tmp;\n   HOST_WIDE_INT charlen = 0;\n+  gfc_symbol *selector = select_type_stack->selector;\n+  gfc_symbol *sym;\n \n   if (ts->type == BT_CLASS || ts->type == BT_DERIVED)\n     return NULL;\n \n-  if (select_type_stack->selector->ts.type == BT_CLASS\n-      && !select_type_stack->selector->attr.class_ok)\n+  if (selector->ts.type == BT_CLASS && !selector->attr.class_ok)\n     return NULL;\n \n+  /* Case value == NULL corresponds to SELECT TYPE cases otherwise\n+     the values correspond to SELECT rank cases.  */\n   if (ts->type == BT_CHARACTER && ts->u.cl && ts->u.cl->length\n       && ts->u.cl->length->expr_type == EXPR_CONSTANT)\n     charlen = gfc_mpz_get_hwi (ts->u.cl->length->value.integer);\n@@ -6165,29 +6177,28 @@ select_intrinsic_set_tmp (gfc_typespec *ts)\n     sprintf (name, \"__tmp_%s_%d\", gfc_basic_typename (ts->type),\n \t     ts->kind);\n   else\n-    snprintf (name, sizeof (name), \"__tmp_%s_\" HOST_WIDE_INT_PRINT_DEC \"_%d\",\n+    snprintf (name, sizeof (name),\n+\t      \"__tmp_%s_\" HOST_WIDE_INT_PRINT_DEC \"_%d\",\n \t      gfc_basic_typename (ts->type), charlen, ts->kind);\n \n   gfc_get_sym_tree (name, gfc_current_ns, &tmp, false);\n-  gfc_add_type (tmp->n.sym, ts, NULL);\n+  sym = tmp->n.sym;\n+  gfc_add_type (sym, ts, NULL);\n \n   /* Copy across the array spec to the selector.  */\n-  if (select_type_stack->selector->ts.type == BT_CLASS\n-      && (CLASS_DATA (select_type_stack->selector)->attr.dimension\n-\t  || CLASS_DATA (select_type_stack->selector)->attr.codimension))\n+  if (selector->ts.type == BT_CLASS\n+      && (CLASS_DATA (selector)->attr.dimension\n+\t  || CLASS_DATA (selector)->attr.codimension))\n     {\n-      tmp->n.sym->attr.pointer = 1;\n-      tmp->n.sym->attr.dimension\n-\t\t= CLASS_DATA (select_type_stack->selector)->attr.dimension;\n-      tmp->n.sym->attr.codimension\n-\t\t= CLASS_DATA (select_type_stack->selector)->attr.codimension;\n-      tmp->n.sym->as\n-\t= gfc_copy_array_spec (CLASS_DATA (select_type_stack->selector)->as);\n+      sym->attr.pointer = 1;\n+      sym->attr.dimension = CLASS_DATA (selector)->attr.dimension;\n+      sym->attr.codimension = CLASS_DATA (selector)->attr.codimension;\n+      sym->as = gfc_copy_array_spec (CLASS_DATA (selector)->as);\n     }\n \n-  gfc_set_sym_referenced (tmp->n.sym);\n-  gfc_add_flavor (&tmp->n.sym->attr, FL_VARIABLE, name, NULL);\n-  tmp->n.sym->attr.select_type_temporary = 1;\n+  gfc_set_sym_referenced (sym);\n+  gfc_add_flavor (&sym->attr, FL_VARIABLE, name, NULL);\n+  sym->attr.select_type_temporary = 1;\n \n   return tmp;\n }\n@@ -6200,6 +6211,8 @@ select_type_set_tmp (gfc_typespec *ts)\n {\n   char name[GFC_MAX_SYMBOL_LEN];\n   gfc_symtree *tmp = NULL;\n+  gfc_symbol *selector = select_type_stack->selector;\n+  gfc_symbol *sym;\n \n   if (!ts)\n     {\n@@ -6218,42 +6231,45 @@ select_type_set_tmp (gfc_typespec *ts)\n \tsprintf (name, \"__tmp_class_%s\", ts->u.derived->name);\n       else\n \tsprintf (name, \"__tmp_type_%s\", ts->u.derived->name);\n+\n       gfc_get_sym_tree (name, gfc_current_ns, &tmp, false);\n-      gfc_add_type (tmp->n.sym, ts, NULL);\n+      sym = tmp->n.sym;\n+      gfc_add_type (sym, ts, NULL);\n \n-      if (select_type_stack->selector->ts.type == BT_CLASS\n-\t&& select_type_stack->selector->attr.class_ok)\n+      if (selector->ts.type == BT_CLASS && selector->attr.class_ok)\n \t{\n-\t  tmp->n.sym->attr.pointer\n-\t\t= CLASS_DATA (select_type_stack->selector)->attr.class_pointer;\n+\t  sym->attr.pointer\n+\t\t= CLASS_DATA (selector)->attr.class_pointer;\n \n \t  /* Copy across the array spec to the selector.  */\n-\t  if (CLASS_DATA (select_type_stack->selector)->attr.dimension\n-\t      || CLASS_DATA (select_type_stack->selector)->attr.codimension)\n+\t  if (CLASS_DATA (selector)->attr.dimension\n+\t      || CLASS_DATA (selector)->attr.codimension)\n \t    {\n-\t      tmp->n.sym->attr.dimension\n-\t\t    = CLASS_DATA (select_type_stack->selector)->attr.dimension;\n-\t      tmp->n.sym->attr.codimension\n-\t\t    = CLASS_DATA (select_type_stack->selector)->attr.codimension;\n-\t      tmp->n.sym->as\n-\t    = gfc_copy_array_spec (CLASS_DATA (select_type_stack->selector)->as);\n+\t      sym->attr.dimension\n+\t\t    = CLASS_DATA (selector)->attr.dimension;\n+\t      sym->attr.codimension\n+\t\t    = CLASS_DATA (selector)->attr.codimension;\n+\t      sym->as\n+\t\t    = gfc_copy_array_spec (CLASS_DATA (selector)->as);\n \t    }\n-    }\n+\t}\n \n-  gfc_set_sym_referenced (tmp->n.sym);\n-  gfc_add_flavor (&tmp->n.sym->attr, FL_VARIABLE, name, NULL);\n-  tmp->n.sym->attr.select_type_temporary = 1;\n+      gfc_set_sym_referenced (sym);\n+      gfc_add_flavor (&sym->attr, FL_VARIABLE, name, NULL);\n+      sym->attr.select_type_temporary = 1;\n \n-  if (ts->type == BT_CLASS)\n-    gfc_build_class_symbol (&tmp->n.sym->ts, &tmp->n.sym->attr,\n-\t\t\t    &tmp->n.sym->as);\n+      if (ts->type == BT_CLASS)\n+\tgfc_build_class_symbol (&sym->ts, &sym->attr, &sym->as);\n     }\n+  else\n+    sym = tmp->n.sym;\n+\n \n   /* Add an association for it, so the rest of the parser knows it is\n      an associate-name.  The target will be set during resolution.  */\n-  tmp->n.sym->assoc = gfc_get_association_list ();\n-  tmp->n.sym->assoc->dangling = 1;\n-  tmp->n.sym->assoc->st = tmp;\n+  sym->assoc = gfc_get_association_list ();\n+  sym->assoc->dangling = 1;\n+  sym->assoc->st = tmp;\n \n   select_type_stack->tmp = tmp;\n }\n@@ -6374,6 +6390,234 @@ gfc_match_select_type (void)\n }\n \n \n+/* Set the temporary for the current intrinsic SELECT RANK selector.  */\n+\n+static void\n+select_rank_set_tmp (gfc_typespec *ts, int *case_value)\n+{\n+  char name[2 * GFC_MAX_SYMBOL_LEN];\n+  char tname[GFC_MAX_SYMBOL_LEN];\n+  gfc_symtree *tmp;\n+  gfc_symbol *selector = select_type_stack->selector;\n+  gfc_symbol *sym;\n+  gfc_symtree *st;\n+  HOST_WIDE_INT charlen = 0;\n+\n+  if (case_value == NULL)\n+    return;\n+\n+  if (ts->type == BT_CHARACTER && ts->u.cl && ts->u.cl->length\n+      && ts->u.cl->length->expr_type == EXPR_CONSTANT)\n+    charlen = gfc_mpz_get_hwi (ts->u.cl->length->value.integer);\n+\n+  if (ts->type == BT_CLASS)\n+    sprintf (tname, \"class_%s\", ts->u.derived->name);\n+  else if (ts->type == BT_DERIVED)\n+    sprintf (tname, \"type_%s\", ts->u.derived->name);\n+  else if (ts->type != BT_CHARACTER)\n+    sprintf (tname, \"%s_%d\", gfc_basic_typename (ts->type), ts->kind);\n+  else\n+    sprintf (tname, \"%s_\" HOST_WIDE_INT_PRINT_DEC \"_%d\",\n+\t     gfc_basic_typename (ts->type), charlen, ts->kind);\n+\n+  /* Case value == NULL corresponds to SELECT TYPE cases otherwise\n+     the values correspond to SELECT rank cases.  */\n+  if (*case_value >=0)\n+    sprintf (name, \"__tmp_%s_rank_%d\", tname, *case_value);\n+  else\n+    sprintf (name, \"__tmp_%s_rank_m%d\", tname, -*case_value);\n+\n+  gfc_find_sym_tree (name, gfc_current_ns, 0, &st);\n+  if (st)\n+    return;\n+\n+  gfc_get_sym_tree (name, gfc_current_ns, &tmp, false);\n+  sym = tmp->n.sym;\n+  gfc_add_type (sym, ts, NULL);\n+\n+  /* Copy across the array spec to the selector.  */\n+  if (selector->ts.type == BT_CLASS)\n+    {\n+      sym->ts.u.derived = CLASS_DATA (selector)->ts.u.derived;\n+      sym->attr.pointer = CLASS_DATA (selector)->attr.pointer;\n+      sym->attr.allocatable = CLASS_DATA (selector)->attr.allocatable;\n+      sym->attr.target = CLASS_DATA (selector)->attr.target;\n+      sym->attr.class_ok = 0;\n+      if (case_value && *case_value != 0)\n+\t{\n+\t  sym->attr.dimension = 1;\n+\t  sym->as = gfc_copy_array_spec (CLASS_DATA (selector)->as);\n+\t  if (*case_value > 0)\n+\t    {\n+\t      sym->as->type = AS_DEFERRED;\n+\t      sym->as->rank = *case_value;\n+\t    }\n+\t  else if (*case_value == -1)\n+\t    {\n+\t      sym->as->type = AS_ASSUMED_SIZE;\n+\t      sym->as->rank = 1;\n+\t    }\n+\t}\n+    }\n+  else\n+    {\n+      sym->attr.pointer = selector->attr.pointer;\n+      sym->attr.allocatable = selector->attr.allocatable;\n+      sym->attr.target = selector->attr.target;\n+      if (case_value && *case_value != 0)\n+\t{\n+\t  sym->attr.dimension = 1;\n+\t  sym->as = gfc_copy_array_spec (selector->as);\n+\t  if (*case_value > 0)\n+\t    {\n+\t      sym->as->type = AS_DEFERRED;\n+\t      sym->as->rank = *case_value;\n+\t    }\n+\t  else if (*case_value == -1)\n+\t    {\n+\t      sym->as->type = AS_ASSUMED_SIZE;\n+\t      sym->as->rank = 1;\n+\t    }\n+\t}\n+    }\n+\n+  gfc_set_sym_referenced (sym);\n+  gfc_add_flavor (&sym->attr, FL_VARIABLE, name, NULL);\n+  sym->attr.select_type_temporary = 1;\n+  if (case_value)\n+    sym->attr.select_rank_temporary = 1;\n+\n+  if (ts->type == BT_CLASS)\n+    gfc_build_class_symbol (&sym->ts, &sym->attr, &sym->as);\n+\n+  /* Add an association for it, so the rest of the parser knows it is\n+     an associate-name.  The target will be set during resolution.  */\n+  sym->assoc = gfc_get_association_list ();\n+  sym->assoc->dangling = 1;\n+  sym->assoc->st = tmp;\n+\n+  select_type_stack->tmp = tmp;\n+}\n+\n+\n+/* Match a SELECT RANK statement.  */\n+\n+match\n+gfc_match_select_rank (void)\n+{\n+  gfc_expr *expr1, *expr2 = NULL;\n+  match m;\n+  char name[GFC_MAX_SYMBOL_LEN];\n+  gfc_symbol *sym, *sym2;\n+  gfc_namespace *ns = gfc_current_ns;\n+  gfc_array_spec *as;\n+\n+  m = gfc_match_label ();\n+  if (m == MATCH_ERROR)\n+    return m;\n+\n+  m = gfc_match (\" select rank ( \");\n+  if (m != MATCH_YES)\n+    return m;\n+\n+  if (!gfc_notify_std (GFC_STD_F2018, \"SELECT RANK statement at %C\"))\n+    return MATCH_NO;\n+\n+  gfc_current_ns = gfc_build_block_ns (ns);\n+  m = gfc_match (\" %n => %e\", name, &expr2);\n+  if (m == MATCH_YES)\n+    {\n+      expr1 = gfc_get_expr ();\n+      expr1->expr_type = EXPR_VARIABLE;\n+      expr1->where = expr2->where;\n+      expr1->ref = gfc_copy_ref (expr2->ref);\n+      if (gfc_get_sym_tree (name, NULL, &expr1->symtree, false))\n+\t{\n+\t  m = MATCH_ERROR;\n+\t  goto cleanup;\n+\t}\n+\n+      sym = expr1->symtree->n.sym;\n+      sym2 = expr2->symtree->n.sym;\n+\n+      as = sym2->ts.type == BT_CLASS ? CLASS_DATA (sym2)->as : sym2->as;\n+      if (expr2->expr_type != EXPR_VARIABLE\n+\t  || !(as && as->type == AS_ASSUMED_RANK))\n+\tgfc_error_now (\"The SELECT RANK selector at %C must be an assumed \"\n+\t\t       \"rank variable\");\n+\n+      if (expr2->ts.type == BT_CLASS)\n+\t{\n+\t  copy_ts_from_selector_to_associate (expr1, expr2);\n+\n+\t  sym->attr.flavor = FL_VARIABLE;\n+\t  sym->attr.referenced = 1;\n+\t  sym->attr.class_ok = 1;\n+\t  CLASS_DATA (sym)->attr.allocatable = CLASS_DATA (sym2)->attr.allocatable;\n+\t  CLASS_DATA (sym)->attr.pointer = CLASS_DATA (sym2)->attr.pointer;\n+\t  CLASS_DATA (sym)->attr.target = CLASS_DATA (sym2)->attr.target;\n+\t  sym->attr.pointer = 1;\n+\t}\n+      else\n+\t{\n+\t  sym->ts = sym2->ts;\n+\t  sym->as = gfc_copy_array_spec (sym2->as);\n+\t  sym->attr.dimension = 1;\n+\n+\t  sym->attr.flavor = FL_VARIABLE;\n+\t  sym->attr.referenced = 1;\n+\t  sym->attr.class_ok = sym2->attr.class_ok;\n+\t  sym->attr.allocatable = sym2->attr.allocatable;\n+\t  sym->attr.pointer = sym2->attr.pointer;\n+\t  sym->attr.target = sym2->attr.target;\n+\t}\n+    }\n+  else\n+    {\n+      m = gfc_match (\" %e \", &expr1);\n+\n+      if (m != MATCH_YES)\n+\t{\n+\t  std::swap (ns, gfc_current_ns);\n+\t  gfc_free_namespace (ns);\n+\t  return m;\n+\t}\n+\n+      sym = expr1->symtree->n.sym;\n+      as = sym->ts.type == BT_CLASS ? CLASS_DATA (sym)->as : sym->as;\n+      if (expr1->expr_type != EXPR_VARIABLE\n+\t  || !(as && as->type == AS_ASSUMED_RANK))\n+\tgfc_error_now (\"The SELECT RANK selector at %C must be an assumed \"\n+\t\t       \"rank variable\");\n+    }\n+\n+  m = gfc_match (\" )%t\");\n+  if (m != MATCH_YES)\n+    {\n+      gfc_error (\"parse error in SELECT RANK statement at %C\");\n+      goto cleanup;\n+    }\n+\n+  new_st.op = EXEC_SELECT_RANK;\n+  new_st.expr1 = expr1;\n+  new_st.expr2 = expr2;\n+  new_st.ext.block.ns = gfc_current_ns;\n+\n+  select_type_push (expr1->symtree->n.sym);\n+  gfc_current_ns = ns;\n+\n+  return MATCH_YES;\n+\n+cleanup:\n+  gfc_free_expr (expr1);\n+  gfc_free_expr (expr2);\n+  gfc_undo_symbols ();\n+  std::swap (ns, gfc_current_ns);\n+  gfc_free_namespace (ns);\n+  return m;\n+}\n+\n+\n /* Match a CASE statement.  */\n \n match\n@@ -6595,6 +6839,107 @@ gfc_match_class_is (void)\n }\n \n \n+/* Match a RANK statement.  */\n+\n+match\n+gfc_match_rank_is (void)\n+{\n+  gfc_case *c = NULL;\n+  match m;\n+  int case_value;\n+\n+  if (gfc_current_state () != COMP_SELECT_RANK)\n+    {\n+      gfc_error (\"Unexpected RANK statement at %C\");\n+      return MATCH_ERROR;\n+    }\n+\n+  if (gfc_match (\"% default\") == MATCH_YES)\n+    {\n+      m = match_case_eos ();\n+      if (m == MATCH_NO)\n+\tgoto syntax;\n+      if (m == MATCH_ERROR)\n+\tgoto cleanup;\n+\n+      new_st.op = EXEC_SELECT_RANK;\n+      c = gfc_get_case ();\n+      c->ts.type = BT_UNKNOWN;\n+      c->where = gfc_current_locus;\n+      new_st.ext.block.case_list = c;\n+      select_type_stack->tmp = NULL;\n+      return MATCH_YES;\n+    }\n+\n+  if (gfc_match_char ('(') != MATCH_YES)\n+    goto syntax;\n+\n+  c = gfc_get_case ();\n+  c->where = gfc_current_locus;\n+  c->ts = select_type_stack->selector->ts;\n+\n+  m = gfc_match_expr (&c->low);\n+  if (m == MATCH_NO)\n+    {\n+      if (gfc_match_char ('*') == MATCH_YES)\n+\tc->low = gfc_get_int_expr (gfc_default_integer_kind,\n+\t\t\t\t   NULL, -1);\n+      else\n+\tgoto syntax;\n+\n+      case_value = -1;\n+    }\n+  else if (m == MATCH_YES)\n+    {\n+      /* F2018: R1150  */\n+      if (c->low->expr_type != EXPR_CONSTANT\n+\t  || c->low->ts.type != BT_INTEGER\n+\t  || c->low->rank)\n+\t{\n+\t  gfc_error (\"The SELECT RANK CASE expression at %C must be a \"\n+\t\t     \"scalar, integer constant\");\n+\t  goto cleanup;\n+\t}\n+\n+      case_value = (int) mpz_get_si (c->low->value.integer);\n+      /* F2018: C1151  */\n+      if ((case_value < 0) || (case_value > GFC_MAX_DIMENSIONS))\n+\t{\n+\t  gfc_error (\"The value of the SELECT RANK CASE expression at \"\n+\t\t     \"%C must not be less than zero or greater than %d\",\n+\t\t     GFC_MAX_DIMENSIONS);\n+\t  goto cleanup;\n+\t}\n+    }\n+  else\n+    goto cleanup;\n+\n+  if (gfc_match_char (')') != MATCH_YES)\n+    goto syntax;\n+\n+  m = match_case_eos ();\n+  if (m == MATCH_NO)\n+    goto syntax;\n+  if (m == MATCH_ERROR)\n+    goto cleanup;\n+\n+  new_st.op = EXEC_SELECT_RANK;\n+  new_st.ext.block.case_list = c;\n+\n+  /* Create temporary variable. Recycle the select type code.  */\n+  select_rank_set_tmp (&c->ts, &case_value);\n+\n+  return MATCH_YES;\n+\n+syntax:\n+  gfc_error (\"Syntax error in RANK specification at %C\");\n+\n+cleanup:\n+  if (c != NULL)\n+    gfc_free_case_list (c);  /* new_st is cleaned up in parse.c.  */\n+  return MATCH_ERROR;\n+}\n+\n /********************* WHERE subroutines ********************/\n \n /* Match the rest of a simple WHERE statement that follows an IF statement."}, {"sha": "1bd78b14338f7c587539d9d837888e956c3206e3", "filename": "gcc/fortran/match.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70570ec1927450952efc5baa4de3254507352f09/gcc%2Ffortran%2Fmatch.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70570ec1927450952efc5baa4de3254507352f09/gcc%2Ffortran%2Fmatch.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.h?ref=70570ec1927450952efc5baa4de3254507352f09", "patch": "@@ -121,6 +121,8 @@ match gfc_match_select (void);\n match gfc_match_select_type (void);\n match gfc_match_type_is (void);\n match gfc_match_class_is (void);\n+match gfc_match_select_rank (void);\n+match gfc_match_rank_is (void);\n match gfc_match_where (gfc_statement *);\n match gfc_match_elsewhere (void);\n match gfc_match_forall (gfc_statement *);"}, {"sha": "caea16b9f5fc686362c03eefd07e368fb89cefb2", "filename": "gcc/fortran/parse.c", "status": "modified", "additions": 91, "deletions": 4, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70570ec1927450952efc5baa4de3254507352f09/gcc%2Ffortran%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70570ec1927450952efc5baa4de3254507352f09/gcc%2Ffortran%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.c?ref=70570ec1927450952efc5baa4de3254507352f09", "patch": "@@ -426,6 +426,7 @@ decode_statement (void)\n   match (NULL, gfc_match_critical, ST_CRITICAL);\n   match (NULL, gfc_match_select, ST_SELECT_CASE);\n   match (NULL, gfc_match_select_type, ST_SELECT_TYPE);\n+  match (NULL, gfc_match_select_rank, ST_SELECT_RANK);\n \n   /* General statement matching: Instead of testing every possible\n      statement, we eliminate most possibilities by peeking at the\n@@ -546,6 +547,7 @@ decode_statement (void)\n       break;\n \n     case 'r':\n+      match (\"rank\", gfc_match_rank_is, ST_RANK);\n       match (\"read\", gfc_match_read, ST_READ);\n       match (\"return\", gfc_match_return, ST_RETURN);\n       match (\"rewind\", gfc_match_rewind, ST_REWIND);\n@@ -1537,7 +1539,7 @@ next_statement (void)\n #define case_exec_markers case ST_DO: case ST_FORALL_BLOCK: \\\n   case ST_IF_BLOCK: case ST_BLOCK: case ST_ASSOCIATE: \\\n   case ST_WHERE_BLOCK: case ST_SELECT_CASE: case ST_SELECT_TYPE: \\\n-  case ST_OMP_PARALLEL: \\\n+  case ST_SELECT_RANK: case ST_OMP_PARALLEL: \\\n   case ST_OMP_PARALLEL_SECTIONS: case ST_OMP_SECTIONS: case ST_OMP_ORDERED: \\\n   case ST_OMP_CRITICAL: case ST_OMP_MASTER: case ST_OMP_SINGLE: \\\n   case ST_OMP_DO: case ST_OMP_PARALLEL_DO: case ST_OMP_ATOMIC: \\\n@@ -2077,12 +2079,18 @@ gfc_ascii_statement (gfc_statement st)\n     case ST_SELECT_TYPE:\n       p = \"SELECT TYPE\";\n       break;\n+    case ST_SELECT_RANK:\n+      p = \"SELECT RANK\";\n+      break;\n     case ST_TYPE_IS:\n       p = \"TYPE IS\";\n       break;\n     case ST_CLASS_IS:\n       p = \"CLASS IS\";\n       break;\n+    case ST_RANK:\n+      p = \"RANK\";\n+      break;\n     case ST_SEQUENCE:\n       p = \"SEQUENCE\";\n       break;\n@@ -4179,7 +4187,7 @@ parse_select_block (void)\n       reject_statement ();\n     }\n \n-  /* At this point, we're got a nonempty select block.  */\n+  /* At this point, we've got a nonempty select block.  */\n   cp = new_level (cp);\n   *cp = new_st;\n \n@@ -4263,7 +4271,7 @@ parse_select_type_block (void)\n       reject_statement ();\n     }\n \n-  /* At this point, we're got a nonempty select block.  */\n+  /* At this point, we've got a nonempty select block.  */\n   cp = new_level (cp);\n   *cp = new_st;\n \n@@ -4306,6 +4314,81 @@ parse_select_type_block (void)\n }\n \n \n+/* Parse a SELECT RANK construct.  */\n+\n+static void\n+parse_select_rank_block (void)\n+{\n+  gfc_statement st;\n+  gfc_code *cp;\n+  gfc_state_data s;\n+\n+  gfc_current_ns = new_st.ext.block.ns;\n+  accept_statement (ST_SELECT_RANK);\n+\n+  cp = gfc_state_stack->tail;\n+  push_state (&s, COMP_SELECT_RANK, gfc_new_block);\n+\n+  /* Make sure that the next statement is a RANK IS or RANK DEFAULT.  */\n+  for (;;)\n+    {\n+      st = next_statement ();\n+      if (st == ST_NONE)\n+\tunexpected_eof ();\n+      if (st == ST_END_SELECT)\n+\t/* Empty SELECT CASE is OK.  */\n+\tgoto done;\n+      if (st == ST_RANK)\n+\tbreak;\n+\n+      gfc_error (\"Expected RANK or RANK DEFAULT \"\n+\t\t \"following SELECT RANK at %C\");\n+\n+      reject_statement ();\n+    }\n+\n+  /* At this point, we've got a nonempty select block.  */\n+  cp = new_level (cp);\n+  *cp = new_st;\n+\n+  accept_statement (st);\n+\n+  do\n+    {\n+      st = parse_executable (ST_NONE);\n+      switch (st)\n+\t{\n+\tcase ST_NONE:\n+\t  unexpected_eof ();\n+\n+\tcase ST_RANK:\n+\t  cp = new_level (gfc_state_stack->head);\n+\t  *cp = new_st;\n+\t  gfc_clear_new_st ();\n+\n+\t  accept_statement (st);\n+\t  /* Fall through */\n+\n+\tcase ST_END_SELECT:\n+\t  break;\n+\n+\t/* Can't have an executable statement because of\n+\t   parse_executable().  */\n+\tdefault:\n+\t  unexpected_statement (st);\n+\t  break;\n+\t}\n+    }\n+  while (st != ST_END_SELECT);\n+\n+done:\n+  pop_state ();\n+  accept_statement (st);\n+  gfc_current_ns = gfc_current_ns->parent;\n+  select_type_pop ();\n+}\n+\n+\n /* Given a symbol, make sure it is not an iteration variable for a DO\n    statement.  This subroutine is called when the symbol is seen in a\n    context that causes it to become redefined.  If the symbol is an\n@@ -5360,6 +5443,10 @@ parse_executable (gfc_statement st)\n \t  parse_select_type_block ();\n \t  break;\n \n+\tcase ST_SELECT_RANK:\n+\t  parse_select_rank_block ();\n+\t  break;\n+\n \tcase ST_DO:\n \t  parse_do_block ();\n \t  if (check_do_closure () == 1)\n@@ -6410,7 +6497,7 @@ gfc_parse_file (void)\n \n   if (flag_dump_fortran_global)\n     gfc_dump_global_symbols (stdout);\n-  \n+\n   gfc_end_source_files ();\n   return true;\n "}, {"sha": "58c2c1b96775724322f6ef8643d9b852f6ec6476", "filename": "gcc/fortran/parse.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70570ec1927450952efc5baa4de3254507352f09/gcc%2Ffortran%2Fparse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70570ec1927450952efc5baa4de3254507352f09/gcc%2Ffortran%2Fparse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.h?ref=70570ec1927450952efc5baa4de3254507352f09", "patch": "@@ -30,7 +30,8 @@ enum gfc_compile_state\n   COMP_DERIVED_CONTAINS, COMP_BLOCK, COMP_ASSOCIATE, COMP_IF,\n   COMP_STRUCTURE, COMP_UNION, COMP_MAP,\n   COMP_DO, COMP_SELECT, COMP_FORALL, COMP_WHERE, COMP_CONTAINS, COMP_ENUM,\n-  COMP_SELECT_TYPE, COMP_OMP_STRUCTURED_BLOCK, COMP_CRITICAL, COMP_DO_CONCURRENT\n+  COMP_SELECT_TYPE, COMP_SELECT_RANK, COMP_OMP_STRUCTURED_BLOCK, COMP_CRITICAL,\n+  COMP_DO_CONCURRENT\n };\n \n /* Stack element for the current compilation state.  These structures"}, {"sha": "383ba442f425cf298e61d1aabcdce9bc58ef1232", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 198, "deletions": 12, "changes": 210, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70570ec1927450952efc5baa4de3254507352f09/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70570ec1927450952efc5baa4de3254507352f09/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=70570ec1927450952efc5baa4de3254507352f09", "patch": "@@ -1866,7 +1866,7 @@ resolve_procedure_expression (gfc_expr* expr)\n \n \n /* Check that name is not a derived type.  */\n- \n+\n static bool\n is_dt_name (const char *name)\n {\n@@ -5455,13 +5455,16 @@ resolve_variable (gfc_expr *e)\n \t}\n     }\n   /* TS 29113, C535b.  */\n-  else if ((sym->ts.type == BT_CLASS && sym->attr.class_ok\n-\t    && CLASS_DATA (sym)->as\n-\t    && CLASS_DATA (sym)->as->type == AS_ASSUMED_RANK)\n-\t   || (sym->ts.type != BT_CLASS && sym->as\n-\t       && sym->as->type == AS_ASSUMED_RANK))\n+  else if (((sym->ts.type == BT_CLASS && sym->attr.class_ok\n+\t     && CLASS_DATA (sym)->as\n+\t     && CLASS_DATA (sym)->as->type == AS_ASSUMED_RANK)\n+\t    || (sym->ts.type != BT_CLASS && sym->as\n+\t        && sym->as->type == AS_ASSUMED_RANK))\n+\t   && !sym->attr.select_rank_temporary)\n     {\n-      if (!actual_arg)\n+      if (!actual_arg\n+\t  && !(cs_base && cs_base->current\n+\t       && cs_base->current->op == EXEC_SELECT_RANK))\n \t{\n \t  gfc_error (\"Assumed-rank variable %s at %L may only be used as \"\n \t\t     \"actual argument\", sym->name, &e->where);\n@@ -6915,7 +6918,7 @@ gfc_resolve_expr (gfc_expr *e)\n   bool t;\n   bool inquiry_save, actual_arg_save, first_actual_arg_save;\n \n-  if (e == NULL)\n+  if (e == NULL || e->do_not_resolve_again)\n     return true;\n \n   /* inquiry_argument only applies to variables.  */\n@@ -7025,6 +7028,13 @@ gfc_resolve_expr (gfc_expr *e)\n   actual_arg = actual_arg_save;\n   first_actual_arg = first_actual_arg_save;\n \n+  /* For some reason, resolving these expressions a second time mangles\n+     the typespec of the expression itself.  */\n+  if (t && e->expr_type == EXPR_VARIABLE\n+      && e->symtree->n.sym->attr.select_rank_temporary\n+      && UNLIMITED_POLY (e->symtree->n.sym))\n+    e->do_not_resolve_again = 1;\n+\n   return t;\n }\n \n@@ -8841,7 +8851,7 @@ resolve_assoc_var (gfc_symbol* sym, bool resolve_target)\n   if (target->ts.type == BT_CLASS)\n     gfc_fix_class_refs (target);\n \n-  if (target->rank != 0)\n+  if (target->rank != 0 && !sym->attr.select_rank_temporary)\n     {\n       gfc_array_spec *as;\n       /* The rank may be incorrectly guessed at parsing, therefore make sure\n@@ -8871,7 +8881,7 @@ resolve_assoc_var (gfc_symbol* sym, bool resolve_target)\n \t    CLASS_DATA (sym)->attr.codimension = 1;\n \t}\n     }\n-  else\n+  else if (!sym->attr.select_rank_temporary)\n     {\n       /* target's rank is 0, but the type of the sym is still array valued,\n \t which has to be corrected.  */\n@@ -9490,6 +9500,175 @@ resolve_select_type (gfc_code *code, gfc_namespace *old_ns)\n }\n \n \n+/* Resolve a SELECT RANK statement.  */\n+\n+static void\n+resolve_select_rank (gfc_code *code, gfc_namespace *old_ns)\n+{\n+  gfc_namespace *ns;\n+  gfc_code *body, *new_st, *tail;\n+  gfc_case *c;\n+  char tname[GFC_MAX_SYMBOL_LEN];\n+  char name[2 * GFC_MAX_SYMBOL_LEN];\n+  gfc_symtree *st;\n+  gfc_expr *selector_expr = NULL;\n+  int case_value;\n+  HOST_WIDE_INT charlen = 0;\n+\n+  ns = code->ext.block.ns;\n+  gfc_resolve (ns);\n+\n+  code->op = EXEC_BLOCK;\n+  if (code->expr2)\n+    {\n+      gfc_association_list* assoc;\n+\n+      assoc = gfc_get_association_list ();\n+      assoc->st = code->expr1->symtree;\n+      assoc->target = gfc_copy_expr (code->expr2);\n+      assoc->target->where = code->expr2->where;\n+      /* assoc->variable will be set by resolve_assoc_var.  */\n+\n+      code->ext.block.assoc = assoc;\n+      code->expr1->symtree->n.sym->assoc = assoc;\n+\n+      resolve_assoc_var (code->expr1->symtree->n.sym, false);\n+    }\n+  else\n+    code->ext.block.assoc = NULL;\n+\n+  /* Loop over RANK cases. Note that returning on the errors causes a\n+     cascade of further errors because the case blocks do not compile\n+     correctly.  */\n+  for (body = code->block; body; body = body->block)\n+    {\n+      c = body->ext.block.case_list;\n+      if (c->low)\n+\tcase_value = (int) mpz_get_si (c->low->value.integer);\n+      else\n+\tcase_value = -2;\n+\n+      /* Check for repeated cases.  */\n+      for (tail = code->block; tail; tail = tail->block)\n+\t{\n+\t  gfc_case *d = tail->ext.block.case_list;\n+\t  int case_value2;\n+\n+\t  if (tail == body)\n+\t    break;\n+\n+\t  /* Check F2018: C1153.  */\n+\t  if (!c->low && !d->low)\n+\t    gfc_error (\"RANK DEFAULT at %L is repeated at %L\",\n+\t\t       &c->where, &d->where);\n+\n+\t  if (!c->low || !d->low)\n+\t    continue;\n+\n+\t  /* Check F2018: C1153.  */\n+\t  case_value2 = (int) mpz_get_si (d->low->value.integer);\n+\t  if ((case_value == case_value2) && case_value == -1)\n+\t    gfc_error (\"RANK (*) at %L is repeated at %L\",\n+\t\t       &c->where, &d->where);\n+\t  else if (case_value == case_value2)\n+\t    gfc_error (\"RANK (%i) at %L is repeated at %L\",\n+\t\t       case_value, &c->where, &d->where);\n+\t}\n+\n+      if (!c->low)\n+        continue;\n+\n+      /* Check F2018: C1155.  */\n+      if (case_value == -1 && (gfc_expr_attr (code->expr1).allocatable\n+\t\t\t       || gfc_expr_attr (code->expr1).pointer))\n+\tgfc_error (\"RANK (*) at %L cannot be used with the pointer or \"\n+\t\t   \"allocatable selector at %L\", &c->where, &code->expr1->where);\n+\n+      if (case_value == -1 && (gfc_expr_attr (code->expr1).allocatable\n+\t\t\t       || gfc_expr_attr (code->expr1).pointer))\n+\tgfc_error (\"RANK (*) at %L cannot be used with the pointer or \"\n+\t\t   \"allocatable selector at %L\", &c->where, &code->expr1->where);\n+    }\n+\n+  /* Add EXEC_SELECT to switch on rank.  */\n+  new_st = gfc_get_code (code->op);\n+  new_st->expr1 = code->expr1;\n+  new_st->expr2 = code->expr2;\n+  new_st->block = code->block;\n+  code->expr1 = code->expr2 =  NULL;\n+  code->block = NULL;\n+  if (!ns->code)\n+    ns->code = new_st;\n+  else\n+    ns->code->next = new_st;\n+  code = new_st;\n+  code->op = EXEC_SELECT_RANK;\n+\n+  selector_expr = code->expr1;\n+\n+  /* Loop over SELECT RANK cases.  */\n+  for (body = code->block; body; body = body->block)\n+    {\n+      c = body->ext.block.case_list;\n+      int case_value;\n+\n+      /* Pass on the default case.  */\n+      if (c->low == NULL)\n+\tcontinue;\n+\n+      /* Associate temporary to selector.  This should only be done\n+\t when this case is actually true, so build a new ASSOCIATE\n+\t that does precisely this here (instead of using the\n+\t 'global' one).  */\n+      if (c->ts.type == BT_CHARACTER && c->ts.u.cl && c->ts.u.cl->length\n+\t  && c->ts.u.cl->length->expr_type == EXPR_CONSTANT)\n+\tcharlen = gfc_mpz_get_hwi (c->ts.u.cl->length->value.integer);\n+\n+      if (c->ts.type == BT_CLASS)\n+\tsprintf (tname, \"class_%s\", c->ts.u.derived->name);\n+      else if (c->ts.type == BT_DERIVED)\n+\tsprintf (tname, \"type_%s\", c->ts.u.derived->name);\n+      else if (c->ts.type != BT_CHARACTER)\n+\tsprintf (tname, \"%s_%d\", gfc_basic_typename (c->ts.type), c->ts.kind);\n+      else\n+\tsprintf (tname, \"%s_\" HOST_WIDE_INT_PRINT_DEC \"_%d\",\n+\t\t gfc_basic_typename (c->ts.type), charlen, c->ts.kind);\n+\n+      case_value = (int) mpz_get_si (c->low->value.integer);\n+      if (case_value >= 0)\n+\tsprintf (name, \"__tmp_%s_rank_%d\", tname, case_value);\n+      else\n+\tsprintf (name, \"__tmp_%s_rank_m%d\", tname, -case_value);\n+\n+      st = gfc_find_symtree (ns->sym_root, name);\n+      gcc_assert (st->n.sym->assoc);\n+\n+      st->n.sym->assoc->target = gfc_get_variable_expr (selector_expr->symtree);\n+      st->n.sym->assoc->target->where = selector_expr->where;\n+\n+      new_st = gfc_get_code (EXEC_BLOCK);\n+      new_st->ext.block.ns = gfc_build_block_ns (ns);\n+      new_st->ext.block.ns->code = body->next;\n+      body->next = new_st;\n+\n+      /* Chain in the new list only if it is marked as dangling.  Otherwise\n+\t there is a CASE label overlap and this is already used.  Just ignore,\n+\t the error is diagnosed elsewhere.  */\n+      if (st->n.sym->assoc->dangling)\n+\t{\n+\t  new_st->ext.block.assoc = st->n.sym->assoc;\n+\t  st->n.sym->assoc->dangling = 0;\n+\t}\n+\n+      resolve_assoc_var (st->n.sym, false);\n+    }\n+\n+  gfc_current_ns = ns;\n+  gfc_resolve_blocks (code->block, gfc_current_ns);\n+  gfc_current_ns = old_ns;\n+}\n+\n+\n /* Resolve a transfer statement. This is making sure that:\n    -- a derived type being transferred has only non-pointer components\n    -- a derived type being transferred doesn't have private components, unless\n@@ -10366,6 +10545,7 @@ gfc_resolve_blocks (gfc_code *b, gfc_namespace *ns)\n \n \tcase EXEC_SELECT:\n \tcase EXEC_SELECT_TYPE:\n+\tcase EXEC_SELECT_RANK:\n \tcase EXEC_FORALL:\n \tcase EXEC_DO:\n \tcase EXEC_DO_WHILE:\n@@ -11643,6 +11823,10 @@ gfc_resolve_code (gfc_code *code, gfc_namespace *ns)\n \t  resolve_select_type (code, ns);\n \t  break;\n \n+\tcase EXEC_SELECT_RANK:\n+\t  resolve_select_rank (code, ns);\n+\t  break;\n+\n \tcase EXEC_BLOCK:\n \t  resolve_block_construct (code);\n \t  break;\n@@ -13573,7 +13757,7 @@ resolve_typebound_procedure (gfc_symtree* stree)\n     }\n   else\n     {\n-      /* If proc has not been resolved at this point, proc->name may \n+      /* If proc has not been resolved at this point, proc->name may\n \t actually be a USE associated entity. See PR fortran/89647. */\n       if (!proc->resolved\n \t  && proc->attr.function == 0 && proc->attr.subroutine == 0)\n@@ -15048,7 +15232,9 @@ resolve_symbol (gfc_symbol *sym)\n \t}\n       /* TS 29113, C535a.  */\n       if (as->type == AS_ASSUMED_RANK && !sym->attr.dummy\n-\t  && !sym->attr.select_type_temporary)\n+\t  && !sym->attr.select_type_temporary\n+\t  && !(cs_base && cs_base->current\n+\t       && cs_base->current->op == EXEC_SELECT_RANK))\n \t{\n \t  gfc_error (\"Assumed-rank array at %L must be a dummy argument\",\n \t\t     &sym->declared_at);"}, {"sha": "ee18d7aea8adc01c6ddef8925f7567642c224074", "filename": "gcc/fortran/st.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70570ec1927450952efc5baa4de3254507352f09/gcc%2Ffortran%2Fst.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70570ec1927450952efc5baa4de3254507352f09/gcc%2Ffortran%2Fst.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fst.c?ref=70570ec1927450952efc5baa4de3254507352f09", "patch": "@@ -141,6 +141,7 @@ gfc_free_statement (gfc_code *p)\n \n     case EXEC_SELECT:\n     case EXEC_SELECT_TYPE:\n+    case EXEC_SELECT_RANK:\n       if (p->ext.block.case_list)\n \tgfc_free_case_list (p->ext.block.case_list);\n       break;"}, {"sha": "da7030192f5472250862c33b600e7ff55df9fc9d", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70570ec1927450952efc5baa4de3254507352f09/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70570ec1927450952efc5baa4de3254507352f09/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=70570ec1927450952efc5baa4de3254507352f09", "patch": "@@ -3609,7 +3609,7 @@ gfc_conv_array_ref (gfc_se * se, gfc_array_ref * ar, gfc_expr *expr,\n \n   if (ar->dimen == 0)\n     {\n-      gcc_assert (ar->codimen);\n+      gcc_assert (ar->codimen || sym->attr.select_rank_temporary);\n \n       if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (se->expr)))\n \tse->expr = build_fold_indirect_ref (gfc_conv_array_data (se->expr));\n@@ -7758,6 +7758,12 @@ gfc_conv_expr_descriptor (gfc_se *se, gfc_expr *expr)\n \t  gfc_conv_descriptor_offset_set (&loop.pre, parm,\n \t\t\t\t\t gfc_conv_descriptor_offset_get (desc));\n \t}\n+      else if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (desc))\n+\t       && !se->data_not_needed\n+\t       && gfc_expr_attr (expr).select_rank_temporary)\n+\t{\n+\t  gfc_conv_descriptor_offset_set (&loop.pre, parm, gfc_index_zero_node);\n+\t}\n       else if (onebased && (!rank_remap || se->use_offset)\n \t  && expr->symtree\n \t  && !(expr->symtree->n.sym && expr->symtree->n.sym->ts.type == BT_CLASS"}, {"sha": "856a171abf4761e8824eb8059f30831c70ad109c", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 311, "deletions": 4, "changes": 315, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70570ec1927450952efc5baa4de3254507352f09/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70570ec1927450952efc5baa4de3254507352f09/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=70570ec1927450952efc5baa4de3254507352f09", "patch": "@@ -1641,6 +1641,48 @@ class_has_len_component (gfc_symbol *sym)\n }\n \n \n+static void\n+copy_descriptor (stmtblock_t *block, tree dst, tree src, int rank)\n+{\n+  int n;\n+  tree dim;\n+  tree tmp;\n+  tree tmp2;\n+  tree size;\n+  tree offset;\n+\n+  offset = gfc_index_zero_node;\n+\n+  /* Use memcpy to copy the descriptor. The size is the minimum of\n+     the sizes of 'src' and 'dst'. This avoids a non-trivial conversion.  */\n+  tmp = TYPE_SIZE_UNIT (TREE_TYPE (src));\n+  tmp2 = TYPE_SIZE_UNIT (TREE_TYPE (dst));\n+  size = fold_build2_loc (input_location, MIN_EXPR,\n+\t\t\t  TREE_TYPE (tmp), tmp, tmp2);\n+  tmp = builtin_decl_explicit (BUILT_IN_MEMCPY);\n+  tmp = build_call_expr_loc (input_location, tmp, 3,\n+\t\t\t     gfc_build_addr_expr (NULL_TREE, dst),\n+\t\t\t     gfc_build_addr_expr (NULL_TREE, src),\n+\t\t\t     fold_convert (size_type_node, size));\n+  gfc_add_expr_to_block (block, tmp);\n+\n+  /* Set the offset correctly.  */\n+  for (n = 0; n < rank; n++)\n+    {\n+      dim = gfc_rank_cst[n];\n+      tmp = gfc_conv_descriptor_lbound_get (src, dim);\n+      tmp2 = gfc_conv_descriptor_stride_get (src, dim);\n+      tmp = fold_build2_loc (input_location, MULT_EXPR, TREE_TYPE (tmp),\n+\t\t\t     tmp, tmp2);\n+      offset = fold_build2_loc (input_location, MINUS_EXPR,\n+\t\t\tTREE_TYPE (offset), offset, tmp);\n+      offset = gfc_evaluate_now (offset, block);\n+    }\n+\n+  gfc_conv_descriptor_offset_set (block, dst, offset);\n+}\n+\n+\n /* Do proper initialization for ASSOCIATE names.  */\n \n static void\n@@ -1658,6 +1700,7 @@ trans_associate_var (gfc_symbol *sym, gfc_wrapped_block *block)\n   bool need_len_assign;\n   bool whole_array = true;\n   gfc_ref *ref;\n+  gfc_symbol *sym2;\n \n   gcc_assert (sym->assoc);\n   e = sym->assoc->target;\n@@ -1690,12 +1733,140 @@ trans_associate_var (gfc_symbol *sym, gfc_wrapped_block *block)\n                      && e->ts.u.derived->attr.unlimited_polymorphic))\n       && (sym->ts.type == BT_CHARACTER\n           || ((sym->ts.type == BT_CLASS || sym->ts.type == BT_DERIVED)\n-              && class_has_len_component (sym))));\n+              && class_has_len_component (sym)))\n+      && !sym->attr.select_rank_temporary);\n+\n   /* Do a `pointer assignment' with updated descriptor (or assign descriptor\n      to array temporary) for arrays with either unknown shape or if associating\n-     to a variable.  */\n-  if (sym->attr.dimension && !class_target\n-      && (sym->as->type == AS_DEFERRED || sym->assoc->variable))\n+     to a variable. Select rank temporaries need somewhat different treatment\n+     to other associate names and case temporaries. This because the selector\n+     is assumed rank and so the offset in particular has to be changed. Also,\n+     the case temporaries carry both allocatable and target attributes if\n+     present in the selector. This means that an allocatation or change of\n+     association can occur and so has to be dealt with.  */\n+  if (sym->attr.select_rank_temporary)\n+    {\n+      gfc_se se;\n+      tree class_decl = NULL_TREE;\n+      int rank = 0;\n+      bool class_ptr;\n+\n+      sym2 = e->symtree->n.sym;\n+      gfc_init_se (&se, NULL);\n+      if (e->ts.type == BT_CLASS)\n+\t{\n+\t  /* Go straight to the class data.  */\n+\t  if (sym2->attr.dummy)\n+\t    {\n+\t      class_decl = DECL_LANG_SPECIFIC (sym2->backend_decl) ?\n+\t\t\t   GFC_DECL_SAVED_DESCRIPTOR (sym2->backend_decl) :\n+\t\t\t   sym2->backend_decl;\n+\t      if (POINTER_TYPE_P (TREE_TYPE (class_decl)))\n+\t\tclass_decl = build_fold_indirect_ref_loc (input_location,\n+\t\t\t\t\t\t\t  class_decl);\n+\t      gcc_assert (GFC_CLASS_TYPE_P (TREE_TYPE (class_decl)));\n+\t      se.expr = gfc_class_data_get (class_decl);\n+\t    }\n+\t  else\n+\t    {\n+\t      class_decl = sym2->backend_decl;\n+\t      gfc_conv_expr_descriptor (&se, e);\n+\t      if (POINTER_TYPE_P (TREE_TYPE (se.expr)))\n+\t\tse.expr = build_fold_indirect_ref_loc (input_location,\n+\t\t\t\t\t\t       se.expr);\n+\t    }\n+\n+\t  if (CLASS_DATA (sym)->as && CLASS_DATA (sym)->as->rank > 0)\n+\t    rank = CLASS_DATA (sym)->as->rank;\n+\t}\n+      else\n+\t{\n+\t  gfc_conv_expr_descriptor (&se, e);\n+\t  if (sym->as && sym->as->rank > 0)\n+\t    rank = sym->as->rank;\n+\t}\n+\n+      desc = sym->backend_decl;\n+\n+      /* The SELECT TYPE mechanisms turn class temporaries into pointers, which\n+\t point to the selector. */\n+      class_ptr = class_decl != NULL_TREE && POINTER_TYPE_P (TREE_TYPE (desc));\n+      if (class_ptr)\n+\t{\n+\t  tmp = gfc_create_var (TREE_TYPE (TREE_TYPE (desc)), \"class\");\n+\t  tmp = gfc_build_addr_expr (NULL, tmp);\n+\t  gfc_add_modify (&se.pre, desc, tmp);\n+\n+\t  tmp = gfc_class_vptr_get (class_decl);\n+\t  gfc_add_modify (&se.pre, gfc_class_vptr_get (desc), tmp);\n+\t  if (UNLIMITED_POLY (sym))\n+\t    gfc_add_modify (&se.pre, gfc_class_len_get (desc),\n+\t\t\t    gfc_class_len_get (class_decl));\n+\n+\t  desc = gfc_class_data_get (desc);\n+\t}\n+\n+      /* SELECT RANK temporaries can carry the allocatable and pointer\n+\t attributes so the selector descriptor must be copied in and\n+\t copied out.  */\n+      if (rank > 0)\n+\tcopy_descriptor (&se.pre, desc, se.expr, rank);\n+      else\n+\t{\n+\t  tmp = gfc_conv_descriptor_data_get (se.expr);\n+\t  gfc_add_modify (&se.pre, desc,\n+\t\t\t  fold_convert (TREE_TYPE (desc), tmp));\n+\t}\n+\n+      /* Deal with associate_name => selector. Class associate names are\n+\t treated in the same way as in SELECT TYPE.  */\n+      sym2 = sym->assoc->target->symtree->n.sym;\n+      if (sym2->assoc && sym->assoc->target && sym2->ts.type != BT_CLASS)\n+\t{\n+\t  sym2 = sym2->assoc->target->symtree->n.sym;\n+\t  se.expr = sym2->backend_decl;\n+\n+\t  if (POINTER_TYPE_P (TREE_TYPE (se.expr)))\n+\t    se.expr = build_fold_indirect_ref_loc (input_location,\n+\t\t\t\t\t\t   se.expr);\n+\t}\n+\n+      /* There could have been reallocation.  Copy descriptor back to the\n+\t selector and update the offset.  */\n+      if (sym->attr.allocatable || sym->attr.pointer\n+\t  || (sym->ts.type == BT_CLASS\n+\t      && (CLASS_DATA (sym)->attr.allocatable\n+\t\t  || CLASS_DATA (sym)->attr.pointer)))\n+\t{\n+\t  if (rank > 0)\n+\t    copy_descriptor (&se.post, se.expr, desc, rank);\n+\t  else\n+\t    {\n+\t      tmp = gfc_conv_descriptor_data_get (desc);\n+\t      gfc_conv_descriptor_data_set (&se.post, se.expr, tmp);\n+\t    }\n+\n+\t  /* The dynamic type could have changed too.  */\n+\t  if (sym->ts.type == BT_CLASS)\n+\t    {\n+\t      tmp = sym->backend_decl;\n+\t      if (class_ptr)\n+\t\ttmp = build_fold_indirect_ref_loc (input_location, tmp);\n+\t      gfc_add_modify (&se.post, gfc_class_vptr_get (class_decl),\n+\t\t\t      gfc_class_vptr_get (tmp));\n+\t      if (UNLIMITED_POLY (sym))\n+\t\tgfc_add_modify (&se.post, gfc_class_len_get (class_decl),\n+\t\t\t\tgfc_class_len_get (tmp));\n+\t    }\n+\t}\n+\n+      tmp = gfc_finish_block (&se.post);\n+\n+      gfc_add_init_cleanup (block, gfc_finish_block (&se.pre), tmp);\n+    }\n+  /* Now all the other kinds of associate variable.  */\n+  else if (sym->attr.dimension && !class_target\n+\t   && (sym->as->type == AS_DEFERRED || sym->assoc->variable))\n     {\n       gfc_se se;\n       tree desc;\n@@ -3424,6 +3595,142 @@ gfc_trans_select_type (gfc_code * code)\n }\n \n \n+static tree\n+gfc_trans_select_rank_cases (gfc_code * code)\n+{\n+  gfc_code *c;\n+  gfc_case *cp;\n+  tree tmp;\n+  tree cond;\n+  tree low;\n+  tree sexpr;\n+  tree rank;\n+  tree rank_minus_one;\n+  tree minus_one;\n+  gfc_se se;\n+  gfc_se cse;\n+  stmtblock_t block;\n+  stmtblock_t body;\n+  bool def = false;\n+\n+  gfc_start_block (&block);\n+\n+  /* Calculate the switch expression.  */\n+  gfc_init_se (&se, NULL);\n+  gfc_conv_expr_descriptor (&se, code->expr1);\n+  rank = gfc_conv_descriptor_rank (se.expr);\n+  rank = gfc_evaluate_now (rank, &block);\n+  minus_one = build_int_cst (TREE_TYPE (rank), -1);\n+  tmp = fold_build2_loc (input_location, MINUS_EXPR,\n+\t\t\t gfc_array_index_type,\n+\t\t\t fold_convert (gfc_array_index_type, rank),\n+\t\t\t build_int_cst (gfc_array_index_type, 1));\n+  rank_minus_one = gfc_evaluate_now (tmp, &block);\n+  tmp = gfc_conv_descriptor_ubound_get (se.expr, rank_minus_one);\n+  cond = fold_build2_loc (input_location, NE_EXPR, logical_type_node,\n+\t\t\t  tmp, build_int_cst (TREE_TYPE (tmp), -1));\n+  tmp = fold_build3_loc (input_location, COND_EXPR,\n+\t\t\t TREE_TYPE (rank), cond,\n+\t\t\t rank, minus_one);\n+  cond = fold_build2_loc (input_location, EQ_EXPR, logical_type_node,\n+\t\t\t  rank, build_int_cst (TREE_TYPE (rank), 0));\n+  sexpr = fold_build3_loc (input_location, COND_EXPR,\n+\t\t\t   TREE_TYPE (rank), cond,\n+\t\t\t   rank, tmp);\n+  sexpr = gfc_evaluate_now (sexpr, &block);\n+  TREE_USED (code->exit_label) = 0;\n+\n+repeat:\n+  for (c = code->block; c; c = c->block)\n+    {\n+      cp = c->ext.block.case_list;\n+\n+      /* Assume it's the default case.  */\n+      low = NULL_TREE;\n+      tmp = NULL_TREE;\n+\n+      /* Put the default case at the end.  */\n+      if ((!def && !cp->low) || (def && cp->low))\n+\tcontinue;\n+\n+      if (cp->low)\n+\t{\n+\t  gfc_init_se (&cse, NULL);\n+\t  gfc_conv_expr_val (&cse, cp->low);\n+\t  gfc_add_block_to_block (&block, &cse.pre);\n+\t  low = cse.expr;\n+\t}\n+\n+      gfc_init_block (&body);\n+\n+      /* Add the statements for this case.  */\n+      tmp = gfc_trans_code (c->next);\n+      gfc_add_expr_to_block (&body, tmp);\n+\n+      /* Break to the end of the SELECT RANK construct.  The default\n+\t case just falls through.  */\n+      if (!def)\n+\t{\n+\t  TREE_USED (code->exit_label) = 1;\n+\t  tmp = build1_v (GOTO_EXPR, code->exit_label);\n+\t  gfc_add_expr_to_block (&body, tmp);\n+\t}\n+\n+      tmp = gfc_finish_block (&body);\n+\n+      if (low != NULL_TREE)\n+\t{\n+\t  cond = fold_build2_loc (input_location, EQ_EXPR,\n+\t\t\t\t  TREE_TYPE (sexpr), sexpr,\n+\t\t\t\t  fold_convert (TREE_TYPE (sexpr), low));\n+\t  tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node,\n+\t\t\t\t cond, tmp,\n+\t\t\t\t build_empty_stmt (input_location));\n+\t}\n+\n+      gfc_add_expr_to_block (&block, tmp);\n+    }\n+\n+  if (!def)\n+    {\n+      def = true;\n+      goto repeat;\n+    }\n+\n+  return gfc_finish_block (&block);\n+}\n+\n+\n+tree\n+gfc_trans_select_rank (gfc_code * code)\n+{\n+  stmtblock_t block;\n+  tree body;\n+  tree exit_label;\n+\n+  gcc_assert (code && code->expr1);\n+  gfc_init_block (&block);\n+\n+  /* Build the exit label and hang it in.  */\n+  exit_label = gfc_build_label_decl (NULL_TREE);\n+  code->exit_label = exit_label;\n+\n+  /* Empty SELECT constructs are legal.  */\n+  if (code->block == NULL)\n+    body = build_empty_stmt (input_location);\n+  else\n+    body = gfc_trans_select_rank_cases (code);\n+\n+  /* Build everything together.  */\n+  gfc_add_expr_to_block (&block, body);\n+\n+  if (TREE_USED (exit_label))\n+    gfc_add_expr_to_block (&block, build1_v (LABEL_EXPR, exit_label));\n+\n+  return gfc_finish_block (&block);\n+}\n+\n+\n /* Traversal function to substitute a replacement symtree if the symbol\n    in the expression is the same as that passed.  f == 2 signals that\n    that variable itself is not to be checked - only the references."}, {"sha": "967f7791681a59f7a8dc230fcb44dbb928115924", "filename": "gcc/fortran/trans-stmt.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70570ec1927450952efc5baa4de3254507352f09/gcc%2Ffortran%2Ftrans-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70570ec1927450952efc5baa4de3254507352f09/gcc%2Ffortran%2Ftrans-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.h?ref=70570ec1927450952efc5baa4de3254507352f09", "patch": "@@ -53,6 +53,7 @@ tree gfc_trans_do_concurrent (gfc_code *);\n tree gfc_trans_do_while (gfc_code *);\n tree gfc_trans_select (gfc_code *);\n tree gfc_trans_select_type (gfc_code *);\n+tree gfc_trans_select_rank (gfc_code *);\n tree gfc_trans_sync (gfc_code *, gfc_exec_op);\n tree gfc_trans_lock_unlock (gfc_code *, gfc_exec_op);\n tree gfc_trans_event_post_wait (gfc_code *, gfc_exec_op);"}, {"sha": "2f878f6b11856d734086c8cdc9ac85e30bd87632", "filename": "gcc/fortran/trans.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70570ec1927450952efc5baa4de3254507352f09/gcc%2Ffortran%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70570ec1927450952efc5baa4de3254507352f09/gcc%2Ffortran%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.c?ref=70570ec1927450952efc5baa4de3254507352f09", "patch": "@@ -1968,6 +1968,10 @@ trans_code (gfc_code * code, tree cond)\n \t  res = gfc_trans_select_type (code);\n \t  break;\n \n+\tcase EXEC_SELECT_RANK:\n+\t  res = gfc_trans_select_rank (code);\n+\t  break;\n+\n \tcase EXEC_FLUSH:\n \t  res = gfc_trans_flush (code);\n \t  break;"}, {"sha": "308e4735c1c5eca68ffab1485d478541357283a1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70570ec1927450952efc5baa4de3254507352f09/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70570ec1927450952efc5baa4de3254507352f09/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=70570ec1927450952efc5baa4de3254507352f09", "patch": "@@ -1,3 +1,8 @@\n+2019-09-01  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\t* gfortran.dg/select_rank_1.f90 : New test.\n+\t* gfortran.dg/select_rank_2.f90 : New test.\n+\n 2019-09-01  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR middle-end/91623"}, {"sha": "69f66556a6a3e2c47f2d7ed777d86e005449074c", "filename": "gcc/testsuite/gfortran.dg/select_rank_1.f90", "status": "added", "additions": 179, "deletions": 0, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70570ec1927450952efc5baa4de3254507352f09/gcc%2Ftestsuite%2Fgfortran.dg%2Fselect_rank_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70570ec1927450952efc5baa4de3254507352f09/gcc%2Ftestsuite%2Fgfortran.dg%2Fselect_rank_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fselect_rank_1.f90?ref=70570ec1927450952efc5baa4de3254507352f09", "patch": "@@ -0,0 +1,179 @@\n+! { dg-do run }\n+!\n+! Basic tests of SELECT RANK\n+!\n+! Contributed by Paul Thomas  <pault@gcc.gnu.org>\n+!\n+  implicit none\n+  type mytype\n+    real :: r\n+  end type\n+  type, extends(mytype) :: thytype\n+    integer :: i\n+  end type\n+\n+! Torture using integers\n+ints: block\n+  integer, dimension(2,2) :: y = reshape ([1,2,3,4],[2,2])\n+  integer, dimension(4) :: z = [1,2,3,4]\n+  integer, dimension(2,2,2) :: q = reshape ([11,12,13,14,15,16,17,18],[2,2,2])\n+  integer :: i = 42\n+\n+  call ifoo(y, \"y\")\n+  if (any (y .ne. reshape ([10,11,12,13], [2,2]))) stop 1\n+  call ifoo(z, \"z\")\n+  call ifoo(i, \"i\")\n+  call ifoo(q, \"q\")\n+  if (any (q .ne. reshape ([11,12,10,11,15,16,12,13], [2,2,2]))) stop 2\n+  call ibar(y)\n+end block ints\n+\n+! Check derived types\n+types: block\n+  integer :: i\n+  type(mytype), allocatable, dimension(:,:) :: t\n+  type(mytype), allocatable :: u\n+\n+  allocate (t, source = reshape ([(mytype(real(i)), i = 1,4)],[2,2]))\n+  call tfoo(t, \"t\")\n+  if (any (size (t) .ne. [1,1])) stop 3   ! 't' has been reallocated!\n+  if (abs (t(1,1)%r - 42.0) .ge. 1e-6) stop 4\n+  allocate (u, source = mytype(42.0))\n+  call tfoo(u, \"u\")\n+end block types\n+\n+! Check classes\n+classes: block\n+  integer :: i\n+  class(mytype), allocatable, dimension(:,:) :: v\n+  class(mytype), allocatable :: w\n+\n+  allocate (v, source = reshape ([(mytype(real(i)), i = 1,4)],[2,2]))\n+  call cfoo(v, \"v\")\n+  select type (v)\n+    type is (mytype)\n+      stop 5\n+    type is (thytype)\n+      if (any (ubound (v) .ne. [3,3])) stop 6\n+      if (any (abs (v%r - 99.0) .ge. 1e-6)) stop 7\n+      if (any (v%i .ne. 42)) stop 8\n+  end select\n+  allocate (w, source = thytype(42.0, 99))\n+  call cfoo(w, \"w\")\n+end block classes\n+\n+! Check unlimited polymorphic.\n+unlimited: block\n+  integer(4) :: i\n+  class(*), allocatable, dimension(:,:,:) :: v\n+\n+  allocate (v, source = reshape ([(i, i = 1,8)],[2,2,2]))\n+  call ufoo(v, \"v\")\n+  select type (v)\n+    type is (integer(4))\n+      stop 9\n+    type is (real(4))\n+      if (any (ubound(v) .ne. [2,2,1])) stop 10\n+      if (abs (sum (v) - 10.0) .gt. 1e-6) stop 11\n+  end select\n+end block unlimited\n+\n+contains\n+\n+  recursive subroutine ifoo(w, chr)\n+    integer, dimension(..) :: w\n+    character(1) :: chr\n+\n+    OUTER: select rank (x => w)\n+      rank (2)\n+        if ((chr .eq. 'y') .and. (any (x(1,:) .ne. [1,3]))) stop 12\n+        if ((chr .eq. 'r') .and. (any (x(1,:) .ne. [13,17]))) stop 13\n+        x = reshape ([10,11,12,13], [2,2])\n+      rank (0)\n+        if ((chr .eq. 'i') .and. (x .ne. 42)) stop 14\n+      rank (*)\n+        if ((chr .eq. 'w') .and. (any (x(1:4) .ne. [10,11,12,13]))) stop 15\n+      rank default\n+        if ((chr .eq. 'z') .and. (rank (x) .ne. 1)) stop 16\n+        if ((chr .eq. 'q') .and. (rank (x) .ne. 3)) stop 17\n+        INNER: select rank (x)\n+          rank (1) INNER\n+            if ((chr .eq. 'z') .and. (any (x(1:4) .ne. [1,2,3,4]))) stop 18\n+          rank (3) INNER\n+ ! Pass a rank 2 section otherwise an infinite loop ensues.\n+            call ifoo(x(:,2,:), 'r')\n+        end select INNER\n+    end select OUTER\n+  end subroutine ifoo\n+\n+  subroutine ibar(x)\n+    integer, dimension(*) :: x\n+\n+    call ifoo(x, \"w\")\n+  end subroutine ibar\n+\n+  subroutine tfoo(w, chr)\n+    type(mytype), dimension(..), allocatable :: w\n+    character(1) :: chr\n+    integer :: i\n+    type(mytype), dimension(2,2) :: r\n+\n+    select rank (x => w)\n+      rank (2)\n+        if (chr .eq. 't') then\n+          r = reshape ([(mytype(real(i)), i = 1,4)],[2,2])\n+          if (any (abs (x%r - r%r) .gt. 1e-6)) stop 19\n+          if (allocated (x)) deallocate (x)\n+          allocate (x(1,1))\n+          x(1,1) = mytype (42.0)\n+        end if\n+      rank default\n+        if ((chr .eq. 'u') .and. (rank (x) .ne. 0)) stop 20\n+    end select\n+  end subroutine tfoo\n+\n+  subroutine cfoo(w, chr)\n+    class(mytype), dimension(..), allocatable :: w\n+    character(1) :: chr\n+    integer :: i\n+    type(mytype), dimension(2,2) :: r\n+\n+    select rank (c => w)\n+      rank (2)\n+        select type (c)\n+          type is (mytype)\n+            if (chr .eq. 'v') then\n+              r = reshape ([(mytype(real(i)), i = 1,4)],[2,2])\n+              if (any (abs (c%r - r%r) .gt. 1e-6)) stop 21\n+            end if\n+          class default\n+            stop 22\n+        end select\n+        if (allocated (c)) deallocate (c)\n+        allocate (c(3,3), source = thytype (99.0, 42))\n+      rank default\n+        if ((chr .eq. 'w') .and. (rank (c) .ne. 0)) stop 23\n+    end select\n+  end subroutine cfoo\n+\n+  subroutine ufoo(w, chr)\n+    class(*), dimension(..), allocatable :: w\n+    character(1) :: chr\n+    integer :: i\n+\n+    select rank (c => w)\n+      rank (3)\n+        select type (c)\n+          type is (integer(4))\n+            if (chr .eq. 'v' .and. (sum (c) .ne. 36)) stop 24\n+          class default\n+            stop 25\n+        end select\n+        if (allocated (c)) deallocate(c)\n+        allocate (c, source = reshape ([(real(i), i = 1,4)],[2,2,1]))\n+      rank default\n+        stop 26\n+    end select\n+  end subroutine ufoo\n+\n+end"}, {"sha": "2415fdff90c4b0ddb1e1fd03147a875d88b77043", "filename": "gcc/testsuite/gfortran.dg/select_rank_2.f90", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70570ec1927450952efc5baa4de3254507352f09/gcc%2Ftestsuite%2Fgfortran.dg%2Fselect_rank_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70570ec1927450952efc5baa4de3254507352f09/gcc%2Ftestsuite%2Fgfortran.dg%2Fselect_rank_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fselect_rank_2.f90?ref=70570ec1927450952efc5baa4de3254507352f09", "patch": "@@ -0,0 +1,85 @@\n+! { dg-do compile }\n+!\n+! Basic tests of SELECT RANK\n+!\n+! Contributed by Paul Thomas  <pault@gcc.gnu.org>\n+!\n+subroutine foo1 (arg)\n+  integer :: i\n+  integer, dimension(3) :: arg\n+  select rank (arg)   ! { dg-error \"must be an assumed rank variable\" }\n+    rank (3)\n+    print *, arg\n+  end select\n+end\n+\n+subroutine foo2 (arg)\n+  integer :: i\n+  integer, dimension(..) :: arg\n+  select rank (arg)\n+    rank (i)          ! { dg-error \"must be a scalar\" }\n+    print *, arg      ! { dg-error \"Expected RANK or RANK DEFAULT\" }\n+  end select\n+end\n+\n+subroutine foo3 (arg)\n+  integer :: i\n+  integer, parameter :: r = 3\n+  integer, dimension(..) :: arg\n+  select rank (arg)\n+    rank (16)         ! { dg-error \"must not be less than zero or greater than 15\" }\n+    print *, arg      ! { dg-error \"Expected RANK or RANK DEFAULT\" }\n+    rank (-1)         ! { dg-error \"must not be less than zero or greater than 15\" }\n+    print *, arg      ! { dg-error \"Expected RANK or RANK DEFAULT\" }\n+    rank (r)          ! OK\n+    print *, arg\n+  end select\n+end\n+\n+subroutine foo4 (arg)\n+  integer :: i\n+  integer, dimension(..), pointer :: arg\n+  select rank (arg)   ! { dg-error \"cannot be used with the pointer or allocatable selector\" }\n+    rank (*)          ! { dg-error \"cannot be used with the pointer or allocatable selector\" }\n+    print *, arg(1:1)\n+    rank (1)\n+    print *, arg\n+  end select\n+end\n+\n+subroutine foo5 (arg)\n+  integer :: i\n+  integer, dimension(..), ALLOCATABLE :: arg\n+  select rank (arg)   ! { dg-error \"cannot be used with the pointer or allocatable selector\" }\n+    rank (*)          ! { dg-error \"pointer or allocatable selector|deferred shape or assumed rank\" }\n+    print *, arg(1:1)\n+    rank (1)\n+    print *, arg\n+  end select\n+end\n+\n+subroutine foo6 (arg)\n+  integer :: i\n+  integer, dimension(..) :: arg\n+  select rank (arg)\n+    rank (*)\n+    print *, arg      ! { dg-error \"assumed.size array\" }\n+    rank (1)\n+    print *, arg\n+  end select\n+end\n+\n+subroutine foo7 (arg)\n+  integer :: i\n+  integer, dimension(..) :: arg\n+  select rank (arg)\n+    rank (1)          ! { dg-error \"is repeated\" }\n+      arg = 1\n+    rank (1)          ! { dg-error \"is repeated\" }\n+      arg = 1\n+    rank (*)          ! { dg-error \"is repeated\" }\n+    rank (*)          ! { dg-error \"is repeated\" }\n+    rank default      ! { dg-error \"is repeated\" }\n+    rank default      ! { dg-error \"is repeated\" }\n+  end select\n+end"}]}