{"sha": "1a6d4fb73c25078994d945918a1451a94f79e56c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWE2ZDRmYjczYzI1MDc4OTk0ZDk0NTkxOGExNDUxYTk0Zjc5ZTU2Yw==", "commit": {"author": {"name": "Alexandre Petit-Bianco", "email": "apbianco@cygnus.com", "date": "1999-07-07T13:11:03Z"}, "committer": {"name": "Alexandre Petit-Bianco", "email": "apbianco@gcc.gnu.org", "date": "1999-07-07T13:11:03Z"}, "message": "[multiple changes]\n\nSat Jul  3 22:26:32 1999  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n\t* expr.c (force_evaluation_order): Save the COMPOUND_EXPR'ed\n \tCALL_EXPR, to avoid order of evaluation changes.\nFri Jul  2 17:44:08 1999  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n\t* parse.y (qualify_ambiguous_name): Do not use\n \tIDENTIFIER_LOCAL_VALUE when name is a STRING_CST.\nThu Jul  1 23:31:16 1999  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n\t* check-init.c (check_init): Handle MAX_EXPR.\n\t* expr.c (force_evaluation_order): Force method call arguments to\n \tbe evaluated in left-to-right order.\n\t* parse.y (qualify_ambiguous_name): Loop again to qualify\n \tNEW_ARRAY_EXPR properly.\nWed Jun 30 17:27:58 1999  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n\t* parse.y (patch_invoke): Resolve unresolved invoked method\n \treturned type.\n\t(qualify_ambiguous_name): STRING_CST to qualify expression for\n \ttype name resolution.\n\nFrom-SVN: r27998", "tree": {"sha": "5b9696999f573cbe70d7dd465a7618959da1fc81", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5b9696999f573cbe70d7dd465a7618959da1fc81"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1a6d4fb73c25078994d945918a1451a94f79e56c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a6d4fb73c25078994d945918a1451a94f79e56c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a6d4fb73c25078994d945918a1451a94f79e56c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a6d4fb73c25078994d945918a1451a94f79e56c/comments", "author": null, "committer": null, "parents": [{"sha": "44a6ce434cdb606a3a8d9e542351aefbf1eb8965", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44a6ce434cdb606a3a8d9e542351aefbf1eb8965", "html_url": "https://github.com/Rust-GCC/gccrs/commit/44a6ce434cdb606a3a8d9e542351aefbf1eb8965"}], "stats": {"total": 107, "additions": 83, "deletions": 24}, "files": [{"sha": "df78c4269c01f7bf7cd1a0801a42ebac0ac81fe0", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a6d4fb73c25078994d945918a1451a94f79e56c/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a6d4fb73c25078994d945918a1451a94f79e56c/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=1a6d4fb73c25078994d945918a1451a94f79e56c", "patch": "@@ -1,3 +1,28 @@\n+Sat Jul  3 22:26:32 1999  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+\t* expr.c (force_evaluation_order): Save the COMPOUND_EXPR'ed\n+ \tCALL_EXPR, to avoid order of evaluation changes.\n+\n+Fri Jul  2 17:44:08 1999  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+\t* parse.y (qualify_ambiguous_name): Do not use\n+ \tIDENTIFIER_LOCAL_VALUE when name is a STRING_CST.\n+\n+Thu Jul  1 23:31:16 1999  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+\t* check-init.c (check_init): Handle MAX_EXPR.\n+\t* expr.c (force_evaluation_order): Force method call arguments to\n+ \tbe evaluated in left-to-right order.\n+\t* parse.y (qualify_ambiguous_name): Loop again to qualify\n+ \tNEW_ARRAY_EXPR properly.\n+\n+Wed Jun 30 17:27:58 1999  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+\t* parse.y (patch_invoke): Resolve unresolved invoked method\n+ \treturned type.\n+\t(qualify_ambiguous_name): STRING_CST to qualify expression for\n+ \ttype name resolution.\n+\n 1999-06-24  Andrew Haley  <aph@cygnus.com>\n \n \t* class.c (finish_class): Whenever a deferred method is"}, {"sha": "93695368d00c24b61bc32a2251b53d6c92dfadb0", "filename": "gcc/java/check-init.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a6d4fb73c25078994d945918a1451a94f79e56c/gcc%2Fjava%2Fcheck-init.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a6d4fb73c25078994d945918a1451a94f79e56c/gcc%2Fjava%2Fcheck-init.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fcheck-init.c?ref=1a6d4fb73c25078994d945918a1451a94f79e56c", "patch": "@@ -643,6 +643,7 @@ check_init (exp, before)\n     case GE_EXPR:\n     case LT_EXPR:\n     case LE_EXPR:\n+    case MAX_EXPR:\n     case ARRAY_REF:\n     binop:\n       check_init (TREE_OPERAND (exp, 0), before);"}, {"sha": "8998bdb3a58fc3eb75e4ca01aa6d79950ef97831", "filename": "gcc/java/expr.c", "status": "modified", "additions": 25, "deletions": 10, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a6d4fb73c25078994d945918a1451a94f79e56c/gcc%2Fjava%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a6d4fb73c25078994d945918a1451a94f79e56c/gcc%2Fjava%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexpr.c?ref=1a6d4fb73c25078994d945918a1451a94f79e56c", "patch": "@@ -2578,6 +2578,10 @@ process_jvm_instruction (PC, byte_ops, length)\n \n    We fix this by using save_expr.  This forces the sub-operand to be\n    copied into a fresh virtual register,\n+\n+   For method invocation, we modify the arguments so that a\n+   left-to-right order evaluation is performed. Saved expressions\n+   will, in CALL_EXPR order, be reused when the call will be expanded.\n */\n \n tree\n@@ -2593,19 +2597,30 @@ force_evaluation_order (node)\n     }\n   else if (TREE_CODE (node) == CALL_EXPR || TREE_CODE (node) == NEW_CLASS_EXPR)\n     {\n-      tree last_side_effecting_arg = NULL_TREE;\n-      tree arg = TREE_OPERAND (node, 1);\n-      for (; arg != NULL_TREE; arg = TREE_CHAIN (arg))\n+      tree arg, cmp;\n+\n+      if (!TREE_OPERAND (node, 1))\n+\treturn node;\n+\n+      /* This reverses the evaluation order. This is a desired effect. */\n+      for (cmp = NULL_TREE, arg = TREE_OPERAND (node, 1); \n+\t   arg; arg = TREE_CHAIN (arg))\n \t{\n-\t  if (TREE_SIDE_EFFECTS (TREE_VALUE (arg)))\n-\t    last_side_effecting_arg = arg;\n+\t  tree saved = save_expr (TREE_VALUE (arg));\n+\t  cmp = (cmp == NULL_TREE ? saved :\n+\t\t build (COMPOUND_EXPR, void_type_node, cmp, saved));\n+\t  TREE_VALUE (arg) = saved;\n \t}\n-      arg = TREE_OPERAND (node, 1);\n-      for (; arg != NULL_TREE;  arg = TREE_CHAIN (arg))\n+      \n+      if (cmp && TREE_CODE (cmp) == COMPOUND_EXPR)\n+\tTREE_SIDE_EFFECTS (cmp) = 1;\n+\n+      if (cmp)\n \t{\n-\t  if (arg == last_side_effecting_arg)\n-\t    break;\n-\t  TREE_VALUE (arg) = save_expr (TREE_VALUE (arg)); \n+\t  cmp = save_expr (build (COMPOUND_EXPR, TREE_TYPE (node), cmp, node));\n+\t  CAN_COMPLETE_NORMALLY (cmp) = CAN_COMPLETE_NORMALLY (node);\n+\t  TREE_SIDE_EFFECTS (cmp) = 1;\n+\t  node = cmp;\n \t}\n     }\n   return node;"}, {"sha": "cdb62d71b75e9a7c1d001946ed039279a8a986c6", "filename": "gcc/java/parse.c", "status": "modified", "additions": 19, "deletions": 9, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a6d4fb73c25078994d945918a1451a94f79e56c/gcc%2Fjava%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a6d4fb73c25078994d945918a1451a94f79e56c/gcc%2Fjava%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.c?ref=1a6d4fb73c25078994d945918a1451a94f79e56c", "patch": "@@ -2212,7 +2212,7 @@ static const short yycheck[] = {     3,\n #define YYPURE 1\n \n /* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */\n-#line 3 \"/usr/cygnus/gnupro-98r1/share/bison.simple\"\n+#line 3 \"/usr/share/misc/bison.simple\"\n \n /* Skeleton output parser for bison,\n    Copyright (C) 1984, 1989, 1990 Free Software Foundation, Inc.\n@@ -2229,7 +2229,7 @@ static const short yycheck[] = {     3,\n \n    You should have received a copy of the GNU General Public License\n    along with this program; if not, write to the Free Software\n-   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n \n /* As a special exception, when this file is copied by Bison into a\n    Bison output file, you may use that output file without restriction.\n@@ -2363,8 +2363,10 @@ int yydebug;\t\t\t/*  nonzero means print parse trace\t*/\n \n /* Prevent warning if -Wstrict-prototypes.  */\n #ifdef __GNUC__\n+#ifndef YYPARSE_PARAM\n int yyparse (void);\n #endif\n+#endif\n \f\n #if __GNUC__ > 1\t\t/* GNU C and GNU C++ define this.  */\n #define __yy_memcpy(TO,FROM,COUNT)\t__builtin_memcpy(TO,FROM,COUNT)\n@@ -2405,7 +2407,7 @@ __yy_memcpy (char *to, char *from, int count)\n #endif\n #endif\n \f\n-#line 196 \"/usr/cygnus/gnupro-98r1/share/bison.simple\"\n+#line 196 \"/usr/share/misc/bison.simple\"\n \n /* The user can define YYPARSE_PARAM as the name of an argument to be passed\n    into yyparse.  The argument should have type void *.\n@@ -4694,7 +4696,7 @@ case 495:\n     break;}\n }\n    /* the action file gets copied in in place of this dollarsign */\n-#line 498 \"/usr/cygnus/gnupro-98r1/share/bison.simple\"\n+#line 498 \"/usr/share/misc/bison.simple\"\n \f\n   yyvsp -= yylen;\n   yyssp -= yylen;\n@@ -9813,6 +9815,11 @@ patch_invoke (patch, method, args)\n     if (JPRIMITIVE_TYPE_P (TREE_TYPE (TREE_VALUE (ta))) &&\n \tTREE_TYPE (TREE_VALUE (ta)) != TREE_VALUE (t))\n       TREE_VALUE (ta) = convert (TREE_VALUE (t), TREE_VALUE (ta));\n+\n+  /* Resolve unresolved returned type isses */\n+  t = TREE_TYPE (TREE_TYPE (method));\n+  if (TREE_CODE (t) == POINTER_TYPE && !CLASS_LOADED_P (TREE_TYPE (t)))\n+    resolve_and_layout (TREE_TYPE (t), NULL);\n   \n   if (flag_emit_class_files || flag_emit_xref)\n     func = method;\n@@ -10223,7 +10230,7 @@ qualify_ambiguous_name (id)\n \tbreak;\n       case NEW_ARRAY_EXPR:\n \tqual = TREE_CHAIN (qual);\n-\tnew_array_found = 1;\n+\tagain = new_array_found = 1;\n \tcontinue;\n       case NEW_CLASS_EXPR:\n       case CONVERT_EXPR:\n@@ -10301,7 +10308,8 @@ qualify_ambiguous_name (id)\n      declaration or parameter declaration, then it is an expression\n      name. We don't carry this test out if we're in the context of the\n      use of SUPER or THIS */\n-  if (!this_found && !super_found && (decl = IDENTIFIER_LOCAL_VALUE (name)))\n+  if (!this_found && !super_found && \n+      TREE_CODE (name) != STRING_CST && (decl = IDENTIFIER_LOCAL_VALUE (name)))\n     {\n       RESOLVE_EXPRESSION_NAME_P (qual_wfl) = 1;\n       QUAL_RESOLUTION (qual) = decl;\n@@ -10318,15 +10326,17 @@ qualify_ambiguous_name (id)\n       QUAL_RESOLUTION (qual) = (new_array_found ? NULL_TREE : decl);\n     }\n \n-  /* We reclassify NAME as a type name if:\n+  /* We reclassify NAME as yielding to a type name resolution if:\n      - NAME is a class/interface declared within the compilation\n        unit containing NAME,\n      - NAME is imported via a single-type-import declaration,\n      - NAME is declared in an another compilation unit of the package\n        of the compilation unit containing NAME,\n      - NAME is declared by exactly on type-import-on-demand declaration\n-     of the compilation unit containing NAME. */\n-  else if ((decl = resolve_and_layout (name, NULL_TREE)))\n+     of the compilation unit containing NAME. \n+     - NAME is actually a STRING_CST. */\n+  else if (TREE_CODE (name) == STRING_CST ||\n+\t   (decl = resolve_and_layout (name, NULL_TREE)))\n     {\n       RESOLVE_TYPE_NAME_P (qual_wfl) = 1;\n       QUAL_RESOLUTION (qual) = decl;"}, {"sha": "4a4b32453750ffc0ec8965f9e3ca8529a4ea6e54", "filename": "gcc/java/parse.y", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a6d4fb73c25078994d945918a1451a94f79e56c/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a6d4fb73c25078994d945918a1451a94f79e56c/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=1a6d4fb73c25078994d945918a1451a94f79e56c", "patch": "@@ -7228,6 +7228,11 @@ patch_invoke (patch, method, args)\n     if (JPRIMITIVE_TYPE_P (TREE_TYPE (TREE_VALUE (ta))) &&\n \tTREE_TYPE (TREE_VALUE (ta)) != TREE_VALUE (t))\n       TREE_VALUE (ta) = convert (TREE_VALUE (t), TREE_VALUE (ta));\n+\n+  /* Resolve unresolved returned type isses */\n+  t = TREE_TYPE (TREE_TYPE (method));\n+  if (TREE_CODE (t) == POINTER_TYPE && !CLASS_LOADED_P (TREE_TYPE (t)))\n+    resolve_and_layout (TREE_TYPE (t), NULL);\n   \n   if (flag_emit_class_files || flag_emit_xref)\n     func = method;\n@@ -7638,7 +7643,7 @@ qualify_ambiguous_name (id)\n \tbreak;\n       case NEW_ARRAY_EXPR:\n \tqual = TREE_CHAIN (qual);\n-\tnew_array_found = 1;\n+\tagain = new_array_found = 1;\n \tcontinue;\n       case NEW_CLASS_EXPR:\n       case CONVERT_EXPR:\n@@ -7716,7 +7721,8 @@ qualify_ambiguous_name (id)\n      declaration or parameter declaration, then it is an expression\n      name. We don't carry this test out if we're in the context of the\n      use of SUPER or THIS */\n-  if (!this_found && !super_found && (decl = IDENTIFIER_LOCAL_VALUE (name)))\n+  if (!this_found && !super_found && \n+      TREE_CODE (name) != STRING_CST && (decl = IDENTIFIER_LOCAL_VALUE (name)))\n     {\n       RESOLVE_EXPRESSION_NAME_P (qual_wfl) = 1;\n       QUAL_RESOLUTION (qual) = decl;\n@@ -7733,15 +7739,17 @@ qualify_ambiguous_name (id)\n       QUAL_RESOLUTION (qual) = (new_array_found ? NULL_TREE : decl);\n     }\n \n-  /* We reclassify NAME as a type name if:\n+  /* We reclassify NAME as yielding to a type name resolution if:\n      - NAME is a class/interface declared within the compilation\n        unit containing NAME,\n      - NAME is imported via a single-type-import declaration,\n      - NAME is declared in an another compilation unit of the package\n        of the compilation unit containing NAME,\n      - NAME is declared by exactly on type-import-on-demand declaration\n-     of the compilation unit containing NAME. */\n-  else if ((decl = resolve_and_layout (name, NULL_TREE)))\n+     of the compilation unit containing NAME. \n+     - NAME is actually a STRING_CST. */\n+  else if (TREE_CODE (name) == STRING_CST ||\n+\t   (decl = resolve_and_layout (name, NULL_TREE)))\n     {\n       RESOLVE_TYPE_NAME_P (qual_wfl) = 1;\n       QUAL_RESOLUTION (qual) = decl;"}]}