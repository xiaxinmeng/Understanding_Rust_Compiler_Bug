{"sha": "e966361c8258d07ef78948d0110b27f2a5a4c69e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTk2NjM2MWM4MjU4ZDA3ZWY3ODk0OGQwMTEwYjI3ZjJhNWE0YzY5ZQ==", "commit": {"author": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2020-08-21T09:58:51Z"}, "committer": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2020-08-26T08:03:54Z"}, "message": "d: Move d_gimplify_expr and dependencies to d-gimplify.cc\n\ngcc/d/ChangeLog:\n\n\t* Make-lang.in (D_OBJS): Add d-gimplify.o.\n\t* d-lang.cc (empty_modify_p): Move to d-gimplify.cc.\n\t(d_gimplify_expr): Likewise.\n\t* d-tree.h (d_gimplify_expr): Declare.\n\t* d-gimplify.cc: New file.", "tree": {"sha": "cae530f34bd1f1fd764ad37142e7603514af284e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cae530f34bd1f1fd764ad37142e7603514af284e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e966361c8258d07ef78948d0110b27f2a5a4c69e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e966361c8258d07ef78948d0110b27f2a5a4c69e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e966361c8258d07ef78948d0110b27f2a5a4c69e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e966361c8258d07ef78948d0110b27f2a5a4c69e/comments", "author": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "363080bb8bd2cca81dd9e2e774910a8c8226f430", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/363080bb8bd2cca81dd9e2e774910a8c8226f430", "html_url": "https://github.com/Rust-GCC/gccrs/commit/363080bb8bd2cca81dd9e2e774910a8c8226f430"}], "stats": {"total": 351, "additions": 191, "deletions": 160}, "files": [{"sha": "18d99abab354db7a14bc7d45173b97bee3389239", "filename": "gcc/d/Make-lang.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e966361c8258d07ef78948d0110b27f2a5a4c69e/gcc%2Fd%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e966361c8258d07ef78948d0110b27f2a5a4c69e/gcc%2Fd%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2FMake-lang.in?ref=e966361c8258d07ef78948d0110b27f2a5a4c69e", "patch": "@@ -141,6 +141,7 @@ D_OBJS = \\\n \td/d-ctfloat.o \\\n \td/d-diagnostic.o \\\n \td/d-frontend.o \\\n+\td/d-gimplify.o \\\n \td/d-incpath.o \\\n \td/d-lang.o \\\n \td/d-longdouble.o \\"}, {"sha": "ed49e5f8dc4b56ce305d10014eb62930106fe8ae", "filename": "gcc/d/d-gimplify.cc", "status": "added", "additions": 187, "deletions": 0, "changes": 187, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e966361c8258d07ef78948d0110b27f2a5a4c69e/gcc%2Fd%2Fd-gimplify.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e966361c8258d07ef78948d0110b27f2a5a4c69e/gcc%2Fd%2Fd-gimplify.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-gimplify.cc?ref=e966361c8258d07ef78948d0110b27f2a5a4c69e", "patch": "@@ -0,0 +1,187 @@\n+/* D-specific tree lowering bits; see also gimple.c.\n+   Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+\n+#include \"dmd/globals.h\"\n+\n+#include \"tree.h\"\n+#include \"gimple-expr.h\"\n+#include \"gimplify.h\"\n+\n+#include \"d-tree.h\"\n+\n+\n+/* Return TRUE if an operand OP of a given TYPE being copied has no data.\n+   The middle-end does a similar check with zero sized types.  */\n+\n+static bool\n+empty_modify_p (tree type, tree op)\n+{\n+  tree_code code = TREE_CODE (op);\n+  switch (code)\n+    {\n+    case COMPOUND_EXPR:\n+      return empty_modify_p (type, TREE_OPERAND (op, 1));\n+\n+    case CONSTRUCTOR:\n+      /* Non-empty construcors are valid.  */\n+      if (CONSTRUCTOR_NELTS (op) != 0 || TREE_CLOBBER_P (op))\n+\treturn false;\n+      break;\n+\n+    case CALL_EXPR:\n+      /* Leave nrvo alone because it isn't a copy.  */\n+      if (CALL_EXPR_RETURN_SLOT_OPT (op))\n+\treturn false;\n+      break;\n+\n+    default:\n+      /* If the operand doesn't have a simple form.  */\n+      if (!is_gimple_lvalue (op) && !INDIRECT_REF_P (op))\n+\treturn false;\n+      break;\n+    }\n+\n+  return empty_aggregate_p (type);\n+}\n+\n+/* Implements the lang_hooks.gimplify_expr routine for language D.\n+   Do gimplification of D specific expression trees in EXPR_P.  */\n+\n+int\n+d_gimplify_expr (tree *expr_p, gimple_seq *pre_p,\n+\t\t gimple_seq *post_p ATTRIBUTE_UNUSED)\n+{\n+  tree_code code = TREE_CODE (*expr_p);\n+  enum gimplify_status ret = GS_UNHANDLED;\n+  tree op0, op1;\n+  tree type;\n+\n+  switch (code)\n+    {\n+    case INIT_EXPR:\n+    case MODIFY_EXPR:\n+      op0 = TREE_OPERAND (*expr_p, 0);\n+      op1 = TREE_OPERAND (*expr_p, 1);\n+\n+      if (!error_operand_p (op0) && !error_operand_p (op1)\n+\t  && (AGGREGATE_TYPE_P (TREE_TYPE (op0))\n+\t      || AGGREGATE_TYPE_P (TREE_TYPE (op1)))\n+\t  && !useless_type_conversion_p (TREE_TYPE (op1), TREE_TYPE (op0)))\n+\t{\n+\t  /* If the back end isn't clever enough to know that the lhs and rhs\n+\t     types are the same, add an explicit conversion.  */\n+\t  TREE_OPERAND (*expr_p, 1) = build1 (VIEW_CONVERT_EXPR,\n+\t\t\t\t\t      TREE_TYPE (op0), op1);\n+\t  ret = GS_OK;\n+\t}\n+      else if (empty_modify_p (TREE_TYPE (op0), op1))\n+\t{\n+\t  /* Remove any copies of empty aggregates.  */\n+\t  gimplify_expr (&TREE_OPERAND (*expr_p, 0), pre_p, post_p,\n+\t\t\t is_gimple_lvalue, fb_lvalue);\n+\n+\t  if (TREE_SIDE_EFFECTS (op1))\n+\t    gimplify_and_add (op1, pre_p);\n+\n+\t  *expr_p = TREE_OPERAND (*expr_p, 0);\n+\t  ret = GS_OK;\n+\t}\n+      break;\n+\n+    case ADDR_EXPR:\n+      op0 = TREE_OPERAND (*expr_p, 0);\n+      /* Constructors are not lvalues, so make them one.  */\n+      if (TREE_CODE (op0) == CONSTRUCTOR)\n+\t{\n+\t  TREE_OPERAND (*expr_p, 0) = force_target_expr (op0);\n+\t  ret = GS_OK;\n+\t}\n+      break;\n+\n+    case CALL_EXPR:\n+      if (CALL_EXPR_ARGS_ORDERED (*expr_p))\n+\t{\n+\t  /* Strictly evaluate all arguments from left to right.  */\n+\t  int nargs = call_expr_nargs (*expr_p);\n+\t  location_t loc = EXPR_LOC_OR_LOC (*expr_p, input_location);\n+\n+\t  /* No need to enforce evaluation order if only one argument.  */\n+\t  if (nargs < 2)\n+\t    break;\n+\n+\t  /* Or if all arguments are already free of side-effects.  */\n+\t  bool has_side_effects = false;\n+\t  for (int i = 0; i < nargs; i++)\n+\t    {\n+\t      if (TREE_SIDE_EFFECTS (CALL_EXPR_ARG (*expr_p, i)))\n+\t\t{\n+\t\t  has_side_effects = true;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\n+\t  if (!has_side_effects)\n+\t    break;\n+\n+\t  /* Leave the last argument for gimplify_call_expr.  */\n+\t  for (int i = 0; i < nargs - 1; i++)\n+\t    {\n+\t      tree new_arg = CALL_EXPR_ARG (*expr_p, i);\n+\n+\t      /* If argument has a side-effect, gimplify_arg will handle it.  */\n+\t      if (gimplify_arg (&new_arg, pre_p, loc) == GS_ERROR)\n+\t\tret = GS_ERROR;\n+\n+\t      /* Even if an argument itself doesn't have any side-effects, it\n+\t\t might be altered by another argument in the list.  */\n+\t      if (new_arg == CALL_EXPR_ARG (*expr_p, i)\n+\t\t  && !really_constant_p (new_arg))\n+\t\tnew_arg = get_formal_tmp_var (new_arg, pre_p);\n+\n+\t      CALL_EXPR_ARG (*expr_p, i) = new_arg;\n+\t    }\n+\n+\t  if (ret != GS_ERROR)\n+\t    ret = GS_OK;\n+\t}\n+      break;\n+\n+    case UNSIGNED_RSHIFT_EXPR:\n+      /* Convert op0 to an unsigned type.  */\n+      op0 = TREE_OPERAND (*expr_p, 0);\n+      op1 = TREE_OPERAND (*expr_p, 1);\n+\n+      type = d_unsigned_type (TREE_TYPE (op0));\n+\n+      *expr_p = convert (TREE_TYPE (*expr_p),\n+\t\t\t build2 (RSHIFT_EXPR, type, convert (type, op0), op1));\n+      ret = GS_OK;\n+      break;\n+\n+    case FLOAT_MOD_EXPR:\n+      gcc_unreachable ();\n+\n+    default:\n+      break;\n+    }\n+\n+  return ret;\n+}"}, {"sha": "6183389007ad0f20d69b96e39c899783564f69bd", "filename": "gcc/d/d-lang.cc", "status": "modified", "additions": 0, "deletions": 160, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e966361c8258d07ef78948d0110b27f2a5a4c69e/gcc%2Fd%2Fd-lang.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e966361c8258d07ef78948d0110b27f2a5a4c69e/gcc%2Fd%2Fd-lang.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-lang.cc?ref=e966361c8258d07ef78948d0110b27f2a5a4c69e", "patch": "@@ -48,8 +48,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"varasm.h\"\n #include \"output.h\"\n #include \"print-tree.h\"\n-#include \"gimple-expr.h\"\n-#include \"gimplify.h\"\n #include \"debug.h\"\n \n #include \"d-tree.h\"\n@@ -843,164 +841,6 @@ d_post_options (const char ** fn)\n   return false;\n }\n \n-/* Return TRUE if an operand OP of a given TYPE being copied has no data.\n-   The middle-end does a similar check with zero sized types.  */\n-\n-static bool\n-empty_modify_p (tree type, tree op)\n-{\n-  tree_code code = TREE_CODE (op);\n-  switch (code)\n-    {\n-    case COMPOUND_EXPR:\n-      return empty_modify_p (type, TREE_OPERAND (op, 1));\n-\n-    case CONSTRUCTOR:\n-      /* Non-empty construcors are valid.  */\n-      if (CONSTRUCTOR_NELTS (op) != 0 || TREE_CLOBBER_P (op))\n-\treturn false;\n-      break;\n-\n-    case CALL_EXPR:\n-      /* Leave nrvo alone because it isn't a copy.  */\n-      if (CALL_EXPR_RETURN_SLOT_OPT (op))\n-\treturn false;\n-      break;\n-\n-    default:\n-      /* If the operand doesn't have a simple form.  */\n-      if (!is_gimple_lvalue (op) && !INDIRECT_REF_P (op))\n-\treturn false;\n-      break;\n-    }\n-\n-  return empty_aggregate_p (type);\n-}\n-\n-/* Implements the lang_hooks.gimplify_expr routine for language D.\n-   Do gimplification of D specific expression trees in EXPR_P.  */\n-\n-static int\n-d_gimplify_expr (tree *expr_p, gimple_seq *pre_p,\n-\t\t gimple_seq *post_p ATTRIBUTE_UNUSED)\n-{\n-  tree_code code = TREE_CODE (*expr_p);\n-  enum gimplify_status ret = GS_UNHANDLED;\n-  tree op0, op1;\n-  tree type;\n-\n-  switch (code)\n-    {\n-    case INIT_EXPR:\n-    case MODIFY_EXPR:\n-      op0 = TREE_OPERAND (*expr_p, 0);\n-      op1 = TREE_OPERAND (*expr_p, 1);\n-\n-      if (!error_operand_p (op0) && !error_operand_p (op1)\n-\t  && (AGGREGATE_TYPE_P (TREE_TYPE (op0))\n-\t      || AGGREGATE_TYPE_P (TREE_TYPE (op1)))\n-\t  && !useless_type_conversion_p (TREE_TYPE (op1), TREE_TYPE (op0)))\n-\t{\n-\t  /* If the back end isn't clever enough to know that the lhs and rhs\n-\t     types are the same, add an explicit conversion.  */\n-\t  TREE_OPERAND (*expr_p, 1) = build1 (VIEW_CONVERT_EXPR,\n-\t\t\t\t\t      TREE_TYPE (op0), op1);\n-\t  ret = GS_OK;\n-\t}\n-      else if (empty_modify_p (TREE_TYPE (op0), op1))\n-\t{\n-\t  /* Remove any copies of empty aggregates.  */\n-\t  gimplify_expr (&TREE_OPERAND (*expr_p, 0), pre_p, post_p,\n-\t\t\t is_gimple_lvalue, fb_lvalue);\n-\n-\t  if (TREE_SIDE_EFFECTS (op1))\n-\t    gimplify_and_add (op1, pre_p);\n-\n-\t  *expr_p = TREE_OPERAND (*expr_p, 0);\n-\t  ret = GS_OK;\n-\t}\n-      break;\n-\n-    case ADDR_EXPR:\n-      op0 = TREE_OPERAND (*expr_p, 0);\n-      /* Constructors are not lvalues, so make them one.  */\n-      if (TREE_CODE (op0) == CONSTRUCTOR)\n-\t{\n-\t  TREE_OPERAND (*expr_p, 0) = force_target_expr (op0);\n-\t  ret = GS_OK;\n-\t}\n-      break;\n-\n-    case CALL_EXPR:\n-      if (CALL_EXPR_ARGS_ORDERED (*expr_p))\n-\t{\n-\t  /* Strictly evaluate all arguments from left to right.  */\n-\t  int nargs = call_expr_nargs (*expr_p);\n-\t  location_t loc = EXPR_LOC_OR_LOC (*expr_p, input_location);\n-\n-\t  /* No need to enforce evaluation order if only one argument.  */\n-\t  if (nargs < 2)\n-\t    break;\n-\n-\t  /* Or if all arguments are already free of side-effects.  */\n-\t  bool has_side_effects = false;\n-\t  for (int i = 0; i < nargs; i++)\n-\t    {\n-\t      if (TREE_SIDE_EFFECTS (CALL_EXPR_ARG (*expr_p, i)))\n-\t\t{\n-\t\t  has_side_effects = true;\n-\t\t  break;\n-\t\t}\n-\t    }\n-\n-\t  if (!has_side_effects)\n-\t    break;\n-\n-\t  /* Leave the last argument for gimplify_call_expr.  */\n-\t  for (int i = 0; i < nargs - 1; i++)\n-\t    {\n-\t      tree new_arg = CALL_EXPR_ARG (*expr_p, i);\n-\n-\t      /* If argument has a side-effect, gimplify_arg will handle it.  */\n-\t      if (gimplify_arg (&new_arg, pre_p, loc) == GS_ERROR)\n-\t\tret = GS_ERROR;\n-\n-\t      /* Even if an argument itself doesn't have any side-effects, it\n-\t\t might be altered by another argument in the list.  */\n-\t      if (new_arg == CALL_EXPR_ARG (*expr_p, i)\n-\t\t  && !really_constant_p (new_arg))\n-\t\tnew_arg = get_formal_tmp_var (new_arg, pre_p);\n-\n-\t      CALL_EXPR_ARG (*expr_p, i) = new_arg;\n-\t    }\n-\n-\t  if (ret != GS_ERROR)\n-\t    ret = GS_OK;\n-\t}\n-      break;\n-\n-    case UNSIGNED_RSHIFT_EXPR:\n-      /* Convert op0 to an unsigned type.  */\n-      op0 = TREE_OPERAND (*expr_p, 0);\n-      op1 = TREE_OPERAND (*expr_p, 1);\n-\n-      type = d_unsigned_type (TREE_TYPE (op0));\n-\n-      *expr_p = convert (TREE_TYPE (*expr_p),\n-\t\t\t build2 (RSHIFT_EXPR, type, convert (type, op0), op1));\n-      ret = GS_OK;\n-      break;\n-\n-    case FLOAT_MOD_EXPR:\n-      gcc_unreachable ();\n-\n-    default:\n-      break;\n-    }\n-\n-  return ret;\n-}\n-\n /* Add the module M to the list of modules that may declare GCC builtins.\n    These are scanned after first semantic and before codegen passes.\n    See d_maybe_set_builtin() for the implementation.  */"}, {"sha": "b01a133fe62f18b79106ff8e082c078f578ddea2", "filename": "gcc/d/d-tree.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e966361c8258d07ef78948d0110b27f2a5a4c69e/gcc%2Fd%2Fd-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e966361c8258d07ef78948d0110b27f2a5a4c69e/gcc%2Fd%2Fd-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-tree.h?ref=e966361c8258d07ef78948d0110b27f2a5a4c69e", "patch": "@@ -593,6 +593,9 @@ extern tree convert_for_condition (tree, Type *);\n extern tree d_array_convert (Expression *);\n extern tree d_array_convert (Type *, Expression *);\n \n+/* In d-gimplify.cc.  */\n+extern int d_gimplify_expr (tree *, gimple_seq *, gimple_seq *);\n+\n /* In d-incpath.cc.  */\n extern void add_import_paths (const char *, const char *, bool);\n "}]}