{"sha": "4b8181c5877bf2732c983b63342f40bd88171c2d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGI4MTgxYzU4NzdiZjI3MzJjOTgzYjYzMzQyZjQwYmQ4ODE3MWMyZA==", "commit": {"author": {"name": "Bin Cheng", "email": "bin.cheng@arm.com", "date": "2012-11-12T02:17:38Z"}, "committer": {"name": "Bin Cheng", "email": "amker@gcc.gnu.org", "date": "2012-11-12T02:17:38Z"}, "message": "gcse.c (struct bb_data): Add new fields, old_pressure, live_in and backup.\n\n\n\t* gcse.c (struct bb_data): Add new fields, old_pressure, live_in\n\tand backup.\n\t(get_regno_pressure_class): Add prototype.\n\t(update_bb_reg_pressure): New.\n\t(should_hoist_expr_to_dom): Add new parameter from.\n\tMonitor the change of reg pressure and use it to drive hoisting.\n\t(hoist_code): Update LIVE and reg pressure information.\n\t(calculate_bb_reg_pressure): Initialize live_in and backup.\n\n\t* gcc.dg/hoist-register-pressure-3.c: New test.\n\nFrom-SVN: r193425", "tree": {"sha": "40b643468baab7f01d4d0c42584076eb891615cd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/40b643468baab7f01d4d0c42584076eb891615cd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4b8181c5877bf2732c983b63342f40bd88171c2d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b8181c5877bf2732c983b63342f40bd88171c2d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b8181c5877bf2732c983b63342f40bd88171c2d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b8181c5877bf2732c983b63342f40bd88171c2d/comments", "author": null, "committer": null, "parents": [{"sha": "6ba9e4013545a8af604d49f59a33fd53848e94a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ba9e4013545a8af604d49f59a33fd53848e94a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ba9e4013545a8af604d49f59a33fd53848e94a0"}], "stats": {"total": 245, "additions": 203, "deletions": 42}, "files": [{"sha": "9a82d73134c24d16e51eb698979488fc8359eaae", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b8181c5877bf2732c983b63342f40bd88171c2d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b8181c5877bf2732c983b63342f40bd88171c2d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4b8181c5877bf2732c983b63342f40bd88171c2d", "patch": "@@ -1,3 +1,14 @@\n+2012-11-12  Bin Cheng  <bin.cheng@arm.com>\n+\n+\t* gcse.c (struct bb_data): Add new fields, old_pressure, live_in\n+\tand backup.\n+\t(get_regno_pressure_class): Add prototype.\n+\t(update_bb_reg_pressure): New.\n+\t(should_hoist_expr_to_dom): Add new parameter from.\n+\tMonitor the change of reg pressure and use it to drive hoisting.\n+\t(hoist_code): Update LIVE and reg pressure information.\n+\t(calculate_bb_reg_pressure): Initialize live_in and backup.\n+\n 2012-11-12  Oleg Endo  <olegendo@gcc.gnu.org>\n \n \t* doc/md.texi (Standard Pattern Names For Generation): Fix swapped"}, {"sha": "9b7a92f1072e1000fa8de00ffb7388fa0cd6c801", "filename": "gcc/gcse.c", "status": "modified", "additions": 156, "deletions": 42, "changes": 198, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b8181c5877bf2732c983b63342f40bd88171c2d/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b8181c5877bf2732c983b63342f40bd88171c2d/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=4b8181c5877bf2732c983b63342f40bd88171c2d", "patch": "@@ -20,9 +20,6 @@ along with GCC; see the file COPYING3.  If not see\n \n /* TODO\n    - reordering of memory allocation and freeing to be more space efficient\n-   - simulate register pressure change of each basic block accurately during\n-     hoist process.  But I doubt the benefit since most expressions hoisted\n-     are constant or address, which usually won't reduce register pressure.\n    - calc rough register pressure information and use the info to drive all\n      kinds of code motion (including code hoisting) in a unified way.\n */\n@@ -421,6 +418,15 @@ struct bb_data\n   /* Maximal register pressure inside basic block for given register class\n      (defined only for the pressure classes).  */\n   int max_reg_pressure[N_REG_CLASSES];\n+  /* Recorded register pressure of basic block before trying to hoist\n+     an expression.  Will be used to restore the register pressure\n+     if the expression should not be hoisted.  */\n+  int old_pressure;\n+  /* Recorded register live_in info of basic block during code hoisting\n+     process.  BACKUP is used to record live_in info before trying to\n+     hoist an expression, and will be used to restore LIVE_IN if the\n+     expression should not be hoisted.  */\n+  bitmap live_in, backup;\n };\n \n #define BB_DATA(bb) ((struct bb_data *) (bb)->aux)\n@@ -481,8 +487,9 @@ static void compute_code_hoist_vbeinout (void);\n static void compute_code_hoist_data (void);\n static int should_hoist_expr_to_dom (basic_block, struct expr *, basic_block,\n \t\t\t\t     sbitmap, int, int *, enum reg_class,\n-\t\t\t\t     int *, bitmap);\n+\t\t\t\t     int *, bitmap, rtx);\n static int hoist_code (void);\n+static enum reg_class get_regno_pressure_class (int regno, int *nregs);\n static enum reg_class get_pressure_class_and_nregs (rtx insn, int *nregs);\n static int one_code_hoisting_pass (void);\n static rtx process_insert_insn (struct expr *);\n@@ -2847,6 +2854,71 @@ compute_code_hoist_data (void)\n     fprintf (dump_file, \"\\n\");\n }\n \n+/* Update register pressure for BB when hoisting an expression from\n+   instruction FROM, if live ranges of inputs are shrunk.  Also\n+   maintain live_in information if live range of register referred\n+   in FROM is shrunk.\n+   \n+   Return 0 if register pressure doesn't change, otherwise return\n+   the number by which register pressure is decreased.\n+   \n+   NOTE: Register pressure won't be increased in this function.  */\n+\n+static int\n+update_bb_reg_pressure (basic_block bb, rtx from)\n+{\n+  rtx dreg, insn;\n+  basic_block succ_bb;\n+  df_ref *op, op_ref;\n+  edge succ;\n+  edge_iterator ei;\n+  int decreased_pressure = 0;\n+  int nregs;\n+  enum reg_class pressure_class;\n+  \n+  for (op = DF_INSN_USES (from); *op; op++)\n+    {\n+      dreg = DF_REF_REAL_REG (*op);\n+      /* The live range of register is shrunk only if it isn't:\n+\t 1. referred on any path from the end of this block to EXIT, or\n+\t 2. referred by insns other than FROM in this block.  */\n+      FOR_EACH_EDGE (succ, ei, bb->succs)\n+\t{\n+\t  succ_bb = succ->dest;\n+\t  if (succ_bb == EXIT_BLOCK_PTR)\n+\t    continue;\n+\n+\t  if (bitmap_bit_p (BB_DATA (succ_bb)->live_in, REGNO (dreg)))\n+\t    break;\n+\t}\n+      if (succ != NULL)\n+\tcontinue;\n+\n+      op_ref = DF_REG_USE_CHAIN (REGNO (dreg));\n+      for (; op_ref; op_ref = DF_REF_NEXT_REG (op_ref))\n+\t{\n+\t  if (!DF_REF_INSN_INFO (op_ref))\n+\t    continue;\n+\n+\t  insn = DF_REF_INSN (op_ref);\n+\t  if (BLOCK_FOR_INSN (insn) == bb\n+\t      && NONDEBUG_INSN_P (insn) && insn != from)\n+\t    break;\n+\t}\n+\n+      pressure_class = get_regno_pressure_class (REGNO (dreg), &nregs);\n+      /* Decrease register pressure and update live_in information for\n+\t this block.  */\n+      if (!op_ref && pressure_class != NO_REGS)\n+\t{\n+\t  decreased_pressure += nregs;\n+\t  BB_DATA (bb)->max_reg_pressure[pressure_class] -= nregs;\n+\t  bitmap_clear_bit (BB_DATA (bb)->live_in, REGNO (dreg));\n+\t}\n+    }\n+  return decreased_pressure;\n+}\n+\n /* Determine if the expression EXPR should be hoisted to EXPR_BB up in\n    flow graph, if it can reach BB unimpared.  Stop the search if the\n    expression would need to be moved more than DISTANCE instructions.\n@@ -2863,6 +2935,8 @@ compute_code_hoist_data (void)\n    HOISTED_BBS points to a bitmap indicating basic blocks through which\n    EXPR is hoisted.\n \n+   FROM is the instruction from which EXPR is hoisted.\n+\n    It's unclear exactly what Muchnick meant by \"unimpared\".  It seems\n    to me that the expression must either be computed or transparent in\n    *every* block in the path(s) from EXPR_BB to BB.  Any other definition\n@@ -2877,28 +2951,54 @@ static int\n should_hoist_expr_to_dom (basic_block expr_bb, struct expr *expr,\n \t\t\t  basic_block bb, sbitmap visited, int distance,\n \t\t\t  int *bb_size, enum reg_class pressure_class,\n-\t\t\t  int *nregs, bitmap hoisted_bbs)\n+\t\t\t  int *nregs, bitmap hoisted_bbs, rtx from)\n {\n   unsigned int i;\n   edge pred;\n   edge_iterator ei;\n   sbitmap_iterator sbi;\n   int visited_allocated_locally = 0;\n+  int decreased_pressure = 0;\n \n+  if (flag_ira_hoist_pressure)\n+    {\n+      /* Record old information of basic block BB when it is visited\n+\t at the first time.  */\n+      if (!bitmap_bit_p (hoisted_bbs, bb->index))\n+\t{\n+\t  struct bb_data *data = BB_DATA (bb);\n+\t  bitmap_copy (data->backup, data->live_in);\n+\t  data->old_pressure = data->max_reg_pressure[pressure_class];\n+\t}\n+      decreased_pressure = update_bb_reg_pressure (bb, from);\n+    }\n   /* Terminate the search if distance, for which EXPR is allowed to move,\n      is exhausted.  */\n   if (distance > 0)\n     {\n-      /* Let EXPR be hoisted through basic block at no cost if the block\n-\t has low register pressure.  An exception is constant expression,\n-\t because hoisting constant expr aggressively results in worse code.\n-\t The exception is made by the observation of CSiBE on ARM target,\n-\t while it has no obvious effect on other targets like x86, x86_64,\n-\t mips and powerpc.  */\n-      if (!flag_ira_hoist_pressure\n-\t  || (BB_DATA (bb)->max_reg_pressure[pressure_class]\n-\t\t>= ira_class_hard_regs_num[pressure_class]\n-\t      || CONST_INT_P (expr->expr)))\n+      if (flag_ira_hoist_pressure)\n+\t{\n+\t  /* Prefer to hoist EXPR if register pressure is decreased.  */\n+\t  if (decreased_pressure > *nregs)\n+\t    distance += bb_size[bb->index];\n+\t  /* Let EXPR be hoisted through basic block at no cost if one\n+\t     of following conditions is satisfied:\n+\n+\t     1. The basic block has low register pressure.\n+\t     2. Register pressure won't be increases after hoisting EXPR.\n+\n+\t     Constant expressions is handled conservatively, because\n+\t     hoisting constant expression aggressively results in worse\n+\t     code.  This decision is made by the observation of CSiBE\n+\t     on ARM target, while it has no obvious effect on other\n+\t     targets like x86, x86_64, mips and powerpc.  */\n+\t  else if (CONST_INT_P (expr->expr)\n+\t\t   || (BB_DATA (bb)->max_reg_pressure[pressure_class]\n+\t\t\t >= ira_class_hard_regs_num[pressure_class]\n+\t\t       && decreased_pressure < *nregs))\n+\t    distance -= bb_size[bb->index];\n+\t}\n+      else\n \tdistance -= bb_size[bb->index];\n \n       if (distance <= 0)\n@@ -2932,24 +3032,21 @@ should_hoist_expr_to_dom (basic_block expr_bb, struct expr *expr,\n \t  bitmap_set_bit (visited, pred_bb->index);\n \t  if (! should_hoist_expr_to_dom (expr_bb, expr, pred_bb,\n \t\t\t\t\t  visited, distance, bb_size,\n-\t\t\t\t\t  pressure_class, nregs, hoisted_bbs))\n+\t\t\t\t\t  pressure_class, nregs,\n+\t\t\t\t\t  hoisted_bbs, from))\n \t    break;\n \t}\n     }\n   if (visited_allocated_locally)\n     {\n       /* If EXPR can be hoisted to expr_bb, record basic blocks through\n-\t which EXPR is hoisted in hoisted_bbs.  Also update register\n-\t pressure for basic blocks newly added in hoisted_bbs.  */\n+\t which EXPR is hoisted in hoisted_bbs.  */\n       if (flag_ira_hoist_pressure && !pred)\n \t{\n+\t  /* Record the basic block from which EXPR is hoisted.  */\n+\t  bitmap_set_bit (visited, bb->index);\n \t  EXECUTE_IF_SET_IN_BITMAP (visited, 0, i, sbi)\n-\t    if (!bitmap_bit_p (hoisted_bbs, i))\n-\t      {\n-\t\tbitmap_set_bit (hoisted_bbs, i);\n-\t\tBB_DATA (BASIC_BLOCK (i))->max_reg_pressure[pressure_class]\n-\t\t    += *nregs;\n-\t      }\n+\t    bitmap_set_bit (hoisted_bbs, i);\n \t}\n       sbitmap_free (visited);\n     }\n@@ -2990,23 +3087,28 @@ find_occr_in_bb (struct occr *occr, basic_block bb)\n    from rtx cost of the corresponding expression and it's used to control\n    how long the expression can be hoisted up in flow graph.  As the\n    expression is hoisted up in flow graph, GCC decreases its DISTANCE\n-   and stops the hoist if DISTANCE reaches 0.\n+   and stops the hoist if DISTANCE reaches 0.  Code hoisting can decrease\n+   register pressure if live ranges of inputs are shrunk.\n \n    Option \"-fira-hoist-pressure\" implements register pressure directed\n    hoist based on upper method.  The rationale is:\n      1. Calculate register pressure for each basic block by reusing IRA\n \tfacility.\n      2. When expression is hoisted through one basic block, GCC checks\n-\tregister pressure of the basic block and decrease DISTANCE only\n-\twhen the register pressure is high.  In other words, expression\n-\twill be hoisted through basic block with low register pressure\n-\tat no cost.\n-     3. Update register pressure information for basic blocks through\n- \twhich expression is hoisted.\n-\tTODO: It is possible to have register pressure decreased because\n-\tof shrinked live ranges of input pseudo registers when hoisting\n-\tan expression.  For now, this effect is not simulated and we just\n-\tincrease register pressure for hoisted expressions.  */\n+\tthe change of live ranges for inputs/output.  The basic block's\n+\tregister pressure will be increased because of extended live\n+\trange of output.  However, register pressure will be decreased\n+\tif the live ranges of inputs are shrunk.\n+     3. After knowing how hoisting affects register pressure, GCC prefers\n+\tto hoist the expression if it can decrease register pressure, by\n+\tincreasing DISTANCE of the corresponding expression.\n+     4. If hoisting the expression increases register pressure, GCC checks\n+\tregister pressure of the basic block and decrease DISTANCE only if\n+\tthe register pressure is high.  In other words, expression will be\n+\thoisted through at no cost if the basic block has low register\n+\tpressure.\n+     5. Update register pressure information for basic blocks through\n+\twhich expression is hoisted.  */\n \n static int\n hoist_code (void)\n@@ -3163,7 +3265,7 @@ hoist_code (void)\n \t\t  if (should_hoist_expr_to_dom (bb, expr, dominated, NULL,\n \t\t\t\t\t\tmax_distance, bb_size,\n \t\t\t\t\t\tpressure_class,\t&nregs,\n-\t\t\t\t\t\thoisted_bbs))\n+\t\t\t\t\t\thoisted_bbs, occr->insn))\n \t\t    {\n \t\t      hoistable++;\n \t\t      VEC_safe_push (occr_t, heap,\n@@ -3207,19 +3309,28 @@ hoist_code (void)\n \t      if (flag_ira_hoist_pressure\n \t\t  && !VEC_empty (occr_t, occrs_to_hoist))\n \t\t{\n-\t\t  /* Update register pressure for basic block to which expr\n-\t\t     is hoisted.  */\n+\t\t  /* Increase register pressure of basic blocks to which\n+\t\t     expr is hoisted because of extended live range of\n+\t\t     output.  */\n \t\t  data = BB_DATA (bb);\n \t\t  data->max_reg_pressure[pressure_class] += nregs;\n+\t\t  EXECUTE_IF_SET_IN_BITMAP (hoisted_bbs, 0, k, bi)\n+\t\t    {\n+\t\t      data = BB_DATA (BASIC_BLOCK (k));\n+\t\t      data->max_reg_pressure[pressure_class] += nregs;\n+\t\t    }\n \t\t}\n \t      else if (flag_ira_hoist_pressure)\n \t\t{\n-\t\t  /* Restore register pressure of basic block recorded in\n-\t\t     hoisted_bbs when expr will not be hoisted.  */\n+\t\t  /* Restore register pressure and live_in info for basic\n+\t\t     blocks recorded in hoisted_bbs when expr will not be\n+\t\t     hoisted.  */\n \t\t  EXECUTE_IF_SET_IN_BITMAP (hoisted_bbs, 0, k, bi)\n \t\t    {\n \t\t      data = BB_DATA (BASIC_BLOCK (k));\n-\t\t      data->max_reg_pressure[pressure_class] -= nregs;\n+\t\t      bitmap_copy (data->live_in, data->backup);\n+\t\t      data->max_reg_pressure[pressure_class]\n+\t\t\t  = data->old_pressure;\n \t\t    }\n \t\t}\n \n@@ -3382,7 +3493,10 @@ calculate_bb_reg_pressure (void)\n   FOR_EACH_BB (bb)\n     {\n       curr_bb = bb;\n-      bitmap_copy (curr_regs_live, DF_LR_OUT (bb));\n+      BB_DATA (bb)->live_in = BITMAP_ALLOC (NULL);\n+      BB_DATA (bb)->backup = BITMAP_ALLOC (NULL);\n+      bitmap_copy (BB_DATA (bb)->live_in, df_get_live_in (bb));\n+      bitmap_copy (curr_regs_live, df_get_live_out (bb));\n       for (i = 0; i < ira_pressure_classes_num; i++)\n \tcurr_reg_pressure[ira_pressure_classes[i]] = 0;\n       EXECUTE_IF_SET_IN_BITMAP (curr_regs_live, 0, j, bi)"}, {"sha": "11dc4cf9b51d8126cb4613b072048357dc92d4a0", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b8181c5877bf2732c983b63342f40bd88171c2d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b8181c5877bf2732c983b63342f40bd88171c2d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4b8181c5877bf2732c983b63342f40bd88171c2d", "patch": "@@ -1,3 +1,7 @@\n+2012-11-12  Bin Cheng  <bin.cheng@arm.com>\n+\n+\t* gcc.dg/hoist-register-pressure-3.c: New test.\n+\n 2012-11-11  Oleg Endo  <olegendo@gcc.gnu.org>\n \n \t* gcc.target/sh/sh4a-fprun.c: Add test_sinf and test_cosf noinline"}, {"sha": "bea8bd40110c8220a4a7c164cdbb97e50da75c36", "filename": "gcc/testsuite/gcc.dg/hoist-register-pressure-3.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b8181c5877bf2732c983b63342f40bd88171c2d/gcc%2Ftestsuite%2Fgcc.dg%2Fhoist-register-pressure-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b8181c5877bf2732c983b63342f40bd88171c2d/gcc%2Ftestsuite%2Fgcc.dg%2Fhoist-register-pressure-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fhoist-register-pressure-3.c?ref=4b8181c5877bf2732c983b63342f40bd88171c2d", "patch": "@@ -0,0 +1,32 @@\n+/* { dg-options \"-Os -fdump-rtl-hoist\" }  */\n+/* { dg-final { scan-rtl-dump \"PRE/HOIST: end of bb .* copying expression\" \"hoist\" } } */\n+\n+#define BUF 100\n+int a[BUF];\n+\n+void com (int);\n+void bar (int);\n+\n+int foo (int x, int y, int z)\n+{\n+  /* \"x+y\" won't be hoisted if \"-fira-hoist-pressure\" is disabled,\n+     because its rtx_cost is too small.  */\n+  if (z)\n+    {\n+      a[1] = a[0] + a[2] + a[3] + a[4] + a[5] + a[6];\n+      a[2] = a[1] + a[3] + a[5] + a[5] + a[6] + a[7];\n+      a[3] = a[2] + a[5] + a[7] + a[6] + a[7] + a[8];\n+      a[4] = a[3] + a[7] + a[11] + a[7] + a[8] + a[9];\n+      a[5] = a[5] + a[11] + a[13] + a[8] + a[9] + a[10];\n+      a[6] = a[7] + a[13] + a[17] + a[9] + a[10] + a[11];\n+      a[7] = a[11] + a[17] + a[19] + a[10] + a[11] + a[12];\n+      com (x+y);\n+    }\n+  else\n+    {\n+      bar (x+y);\n+    }\n+\n+  return 0;\n+}\n+"}]}