{"sha": "db126753a6da192ce01557e62ed56263477d8c8c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGIxMjY3NTNhNmRhMTkyY2UwMTU1N2U2MmVkNTYyNjM0NzdkOGM4Yw==", "commit": {"author": {"name": "David Edelsohn", "email": "dje@gcc.gnu.org", "date": "1998-02-19T19:41:03Z"}, "committer": {"name": "David Edelsohn", "email": "dje@gcc.gnu.org", "date": "1998-02-19T19:41:03Z"}, "message": "[multiple changes]\n\nThu Feb 19 22:36:53 1998  Andrey Slepuhin  <pooh@msu.net>\n\t\t\t  David Edelsohn  <edelsohn@mhpcc.edu>\n\t* collect2.c (XCOFF_SCAN_LIBS): Remove.\n\t(export_flag): New variable.\n\t(export_file): #ifdef COLLECT_EXPORT_LIST.\n\t(import_file, exports, imports, undefined): New variables.\n\t(libs, cmdline_lib_dirs, libpath_lib_dirs, libpath, libexts): Same.\n\t(dump_list, dump_prefix_list, is_in_list): New functions.\n\t(write_export_file): $ifdef COLLECT_EXPORT_LIST.\n\t(write_import_file, resolve_lib_name): New functions.\n\t(use_import_list, ignore_library): Same.\n\t(collect_exit): maybe_unlink import_file and #ifdef.\n\t(handler): Same.\n\t(main): New variable importf, #ifdef exportf.  Move parsing of\n \t-shared before general argument parsing.  Resolve AIX library\n \tpaths and import libgcc.a symbols.  Treat .so shared libraries the\n \tsame as objects and .a libraries.  Create alias for object_lst and\n \tincrement it instead of original pointer.  Scan AIX libraries as\n \tobjects earlier instead of using scan_libraries.  Perform AIX\n \ttlink later to resolve templates instead of forking ld.\n\t(GCC_OK_SYMBOL): Ensure symbol not in undef section.\n\t(GCC_UNDEF_SYMBOL): New macro.\n\t(scan_prog_file): Loop for members of AIX libraries.  Handle\n \texport/import of ctors/dtors.\n\t(aix_std_libs): New variable.\n\t(scan_libraries, XCOFF): Delete.\nFri Feb 19 22:36:52 1998  Robert Lipe   <robertl@dgii.com>\n\t* collect2.c (full_real_ld_suffix): #ifdef CROSS_COMPILE.\n\nFrom-SVN: r18128", "tree": {"sha": "215eb66ba09531a3d7393cd3b08b2b62b190b590", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/215eb66ba09531a3d7393cd3b08b2b62b190b590"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/db126753a6da192ce01557e62ed56263477d8c8c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db126753a6da192ce01557e62ed56263477d8c8c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db126753a6da192ce01557e62ed56263477d8c8c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db126753a6da192ce01557e62ed56263477d8c8c/comments", "author": null, "committer": null, "parents": [{"sha": "e642002f8629578ceea4977d14ffb2d183d5276a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e642002f8629578ceea4977d14ffb2d183d5276a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e642002f8629578ceea4977d14ffb2d183d5276a"}], "stats": {"total": 757, "additions": 511, "deletions": 246}, "files": [{"sha": "8c3f426abcf56a8adc4578b52210ac06091d9bba", "filename": "gcc/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db126753a6da192ce01557e62ed56263477d8c8c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db126753a6da192ce01557e62ed56263477d8c8c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=db126753a6da192ce01557e62ed56263477d8c8c", "patch": "@@ -1,3 +1,35 @@\n+Thu Feb 19 22:36:53 1998  Andrey Slepuhin  <pooh@msu.net>\n+\t\t\t  David Edelsohn  <edelsohn@mhpcc.edu>\n+\n+\t* collect2.c (XCOFF_SCAN_LIBS): Remove.\n+\t(export_flag): New variable.\n+\t(export_file): #ifdef COLLECT_EXPORT_LIST.\n+\t(import_file, exports, imports, undefined): New variables.\n+\t(libs, cmdline_lib_dirs, libpath_lib_dirs, libpath, libexts): Same.\n+\t(dump_list, dump_prefix_list, is_in_list): New functions.\n+\t(write_export_file): $ifdef COLLECT_EXPORT_LIST.\n+\t(write_import_file, resolve_lib_name): New functions.\n+\t(use_import_list, ignore_library): Same.\n+\t(collect_exit): maybe_unlink import_file and #ifdef.\n+\t(handler): Same.\n+\t(main): New variable importf, #ifdef exportf.  Move parsing of\n+ \t-shared before general argument parsing.  Resolve AIX library\n+ \tpaths and import libgcc.a symbols.  Treat .so shared libraries the\n+ \tsame as objects and .a libraries.  Create alias for object_lst and\n+ \tincrement it instead of original pointer.  Scan AIX libraries as\n+ \tobjects earlier instead of using scan_libraries.  Perform AIX\n+ \ttlink later to resolve templates instead of forking ld.\n+\t(GCC_OK_SYMBOL): Ensure symbol not in undef section.\n+\t(GCC_UNDEF_SYMBOL): New macro.\n+\t(scan_prog_file): Loop for members of AIX libraries.  Handle\n+ \texport/import of ctors/dtors.\n+\t(aix_std_libs): New variable.\n+\t(scan_libraries, XCOFF): Delete.\n+\n+Thu Feb 19 22:36:52 1998  Robert Lipe   <robertl@dgii.com>\n+\n+\t* collect2.c (full_real_ld_suffix): #ifdef CROSS_COMPILE.\n+\n 1998-02-19  Mike Stump  <mrs@wrs.com>\n \n \t* Makefile.in: Use $tooldir for sys-include to match toplevel"}, {"sha": "456716c29a719933d3280da0d5e1e212705e04b7", "filename": "gcc/collect2.c", "status": "modified", "additions": 479, "deletions": 246, "changes": 725, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db126753a6da192ce01557e62ed56263477d8c8c/gcc%2Fcollect2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db126753a6da192ce01557e62ed56263477d8c8c/gcc%2Fcollect2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcollect2.c?ref=db126753a6da192ce01557e62ed56263477d8c8c", "patch": "@@ -99,7 +99,7 @@ extern char *choose_temp_base ();\n /* On certain systems, we have code that works by scanning the object file\n    directly.  But this code uses system-specific header files and library\n    functions, so turn it off in a cross-compiler.  Likewise, the names of\n-   the utilities aren't correct for a cross-compiler; we have to hope that\n+   the utilities are not correct for a cross-compiler; we have to hope that\n    cross-versions are in the proper directories.  */\n \n #ifdef CROSS_COMPILE\n@@ -112,10 +112,10 @@ extern char *choose_temp_base ();\n #undef REAL_STRIP_FILE_NAME\n #endif\n \n-/* If we can't use a special method, use the ordinary one:\n+/* If we cannot use a special method, use the ordinary one:\n    run nm to find what symbols are present.\n    In a cross-compiler, this means you need a cross nm,\n-   but that isn't quite as unpleasant as special headers.  */\n+   but that is not quite as unpleasant as special headers.  */\n \n #if !defined (OBJECT_FORMAT_COFF) && !defined (OBJECT_FORMAT_ROSE)\n #define OBJECT_FORMAT_NONE\n@@ -147,10 +147,6 @@ extern char *choose_temp_base ();\n #define MY_ISCOFF(X) ISCOFF (X)\n #endif\n \n-#ifdef XCOFF_DEBUGGING_INFO\n-#define XCOFF_SCAN_LIBS\n-#endif\n-\n #endif /* OBJECT_FORMAT_COFF */\n \n #ifdef OBJECT_FORMAT_ROSE\n@@ -189,7 +185,7 @@ extern char *choose_temp_base ();\n #define SYMBOL__MAIN __main\n #endif\n \n-#if defined (LDD_SUFFIX) || SUNOS4_SHARED_LIBRARIES || defined(XCOFF_SCAN_LIBS)\n+#if defined (LDD_SUFFIX) || SUNOS4_SHARED_LIBRARIES\n #define SCAN_LIBRARIES\n #endif\n \n@@ -234,6 +230,9 @@ extern char *version_string;\n int vflag;\t\t\t\t/* true if -v */\n static int rflag;\t\t\t/* true if -r */\n static int strip_flag;\t\t\t/* true if -s */\n+#ifdef COLLECT_EXPORT_LIST\n+static int export_flag;                 /* true if -bE */\n+#endif\n \n int debug;\t\t\t\t/* true if -debug */\n \n@@ -243,7 +242,10 @@ static int   temp_filename_length;\t/* Length of temp_filename */\n static char *temp_filename;\t\t/* Base of temp filenames */\n static char *c_file;\t\t\t/* <xxx>.c for constructor/destructor list.  */\n static char *o_file;\t\t\t/* <xxx>.o for constructor/destructor list.  */\n+#ifdef COLLECT_EXPORT_LIST\n static char *export_file;\t        /* <xxx>.x for AIX export list.  */\n+static char *import_file;\t        /* <xxx>.p for AIX import list.  */\n+#endif\n char *ldout;\t\t\t\t/* File for ld errors.  */\n static char *output_file;\t\t/* Output file for ld.  */\n static char *nm_file_name;\t\t/* pathname of nm */\n@@ -254,7 +256,11 @@ static char *initname, *fininame;\t/* names of init and fini funcs */\n \n static struct head constructors;\t/* list of constructors found */\n static struct head destructors;\t\t/* list of destructors found */\n+#ifdef COLLECT_EXPORT_LIST\n static struct head exports;\t\t/* list of exported symbols */\n+static struct head imports;\t\t/* list of imported symbols */\n+static struct head undefined;\t\t/* list of undefined symbols */\n+#endif\n static struct head frame_tables;\t/* list of frame unwind info tables */\n \n struct obstack temporary_obstack;\n@@ -284,6 +290,16 @@ struct path_prefix\n   char *name;                 /* Name of this list (used in config stuff) */\n };\n \n+#ifdef COLLECT_EXPORT_LIST\n+/* Lists to keep libraries to be scanned for global constructors/destructors. */\n+static struct head libs;                    /* list of libraries */\n+static struct path_prefix cmdline_lib_dirs; /* directories specified with -L */\n+static struct path_prefix libpath_lib_dirs; /* directories in LIBPATH */\n+static struct path_prefix *libpaths[3] = {&cmdline_lib_dirs,\n+\t\t\t\t\t  &libpath_lib_dirs, NULL};\n+static char *libexts[3] = {\"a\", \"so\", NULL};  /* possible library extentions */\n+#endif\n+\n void collect_exit\t\tPROTO((int));\n void collect_execute\t\tPROTO((char *, char **, char *));\n void dump_file\t\t\tPROTO((char *));\n@@ -299,13 +315,22 @@ static void fork_execute\tPROTO((char *, char **));\n static void maybe_unlink\tPROTO((char *));\n static void add_to_list\t\tPROTO((struct head *, char *));\n static void write_list\t\tPROTO((FILE *, char *, struct id *));\n+static void dump_list\t\tPROTO((FILE *, char *, struct id *));\n+static void dump_prefix_list\tPROTO((FILE *, char *, struct prefix_list *));\n+static int is_in_list\t\tPROTO((char *, struct id *));\n static void write_list_with_asm PROTO((FILE *, char *, struct id *));\n static void write_c_file\tPROTO((FILE *, char *));\n-static void write_export_file\tPROTO((FILE *));\n static void scan_prog_file\tPROTO((char *, enum pass));\n #ifdef SCAN_LIBRARIES\n static void scan_libraries\tPROTO((char *));\n #endif\n+#ifdef COLLECT_EXPORT_LIST\n+static void write_export_file\tPROTO((FILE *));\n+static void write_import_file\tPROTO((FILE *));\n+static char *resolve_lib_name\tPROTO((char *));\n+static int use_import_list\tPROTO((char *));\n+static int ignore_library\tPROTO((char *));\n+#endif\n \n char *xcalloc ();\n char *xmalloc ();\n@@ -378,9 +403,14 @@ collect_exit (status)\n   if (o_file != 0 && o_file[0])\n     maybe_unlink (o_file);\n \n+#ifdef COLLECT_EXPORT_LIST\n   if (export_file != 0 && export_file[0])\n     maybe_unlink (export_file);\n \n+  if (import_file != 0 && import_file[0])\n+    maybe_unlink (import_file);\n+#endif\n+\n   if (ldout != 0 && ldout[0])\n     {\n       dump_file (ldout);\n@@ -454,9 +484,14 @@ handler (signo)\n   if (ldout != 0 && ldout[0])\n     maybe_unlink (ldout);\n \n+#ifdef COLLECT_EXPORT_LIST\n   if (export_file != 0 && export_file[0])\n     maybe_unlink (export_file);\n \n+  if (import_file != 0 && import_file[0])\n+    maybe_unlink (import_file);\n+#endif\n+\n   signal (signo, SIG_DFL);\n   kill (getpid (), signo);\n }\n@@ -639,7 +674,7 @@ is_ctor_dtor (s)\n #endif\n     { \"GLOBAL__FI_\", sizeof (\"GLOBAL__FI_\")-1, 3, 0 },\n     { \"GLOBAL__FD_\", sizeof (\"GLOBAL__FD_\")-1, 4, 0 },\n-#ifdef CFRONT_LOSSAGE /* Don't collect cfront initialization functions.\n+#ifdef CFRONT_LOSSAGE /* Do not collect cfront initialization functions.\n \t\t\t cfront has its own linker procedure to collect them;\n \t\t\t if collect2 gets them too, they get collected twice\n \t\t\t when the cfront procedure is run and the compiler used\n@@ -925,7 +960,9 @@ main (argc, argv)\n   char *ld_suffix\t= \"ld\";\n   char *full_ld_suffix\t= ld_suffix;\n   char *real_ld_suffix\t= \"real-ld\";\n+#ifdef CROSS_COMPILE\n   char *full_real_ld_suffix = real_ld_suffix;\n+#endif\n   char *collect_ld_suffix = \"collect-ld\";\n   char *nm_suffix\t= \"nm\";\n   char *full_nm_suffix\t= nm_suffix;\n@@ -940,7 +977,11 @@ main (argc, argv)\n   char *gstrip_suffix\t= \"gstrip\";\n   char *full_gstrip_suffix = gstrip_suffix;\n   char *arg;\n-  FILE *outf, *exportf;\n+  FILE *outf;\n+#ifdef COLLECT_EXPORT_LIST\n+  FILE *exportf;\n+  FILE *importf;\n+#endif\n   char *ld_file_name;\n   char *collect_name;\n   char *collect_names;\n@@ -978,12 +1019,12 @@ main (argc, argv)\n \n      In practice, collect will rarely invoke itself.  This can happen now\n      that we are no longer called gld.  A perfect example is when running\n-     gcc in a build directory that has been installed.  When looking for \n-     ld's, we'll find our installed version and believe that's the real ld.  */\n+     gcc in a build directory that has been installed.  When looking for\n+     ld, we will find our installed version and believe that's the real ld.  */\n \n   /* We must also append COLLECT_NAME to COLLECT_NAMES to watch for the\n      previous version of collect (the one that used COLLECT_NAME and only\n-     handled two levels of recursion).  If we don't we may mutually recurse\n+     handled two levels of recursion).  If we do not we may mutually recurse\n      forever.  This can happen (I think) when bootstrapping the old version\n      and a new one is installed (rare, but we should handle it).\n      ??? Hopefully references to COLLECT_NAME can be removed at some point.  */\n@@ -1006,7 +1047,7 @@ main (argc, argv)\n   prefix_from_env (\"COLLECT_NAMES\", &our_file_names);\n \n   /* Set environment variable COLLECT_NAME to our name so the previous version\n-     of collect won't find us.  If it does we'll mutually recurse forever.\n+     of collect will not find us.  If it does we will mutually recurse forever.\n      This can happen when bootstrapping the new version and an old version is\n      installed.\n      ??? Hopefully this bit of code can be removed at some point.  */\n@@ -1207,17 +1248,49 @@ main (argc, argv)\n   temp_filename_length = strlen (temp_filename);\n   c_file = xcalloc (temp_filename_length + sizeof (\".c\"), 1);\n   o_file = xcalloc (temp_filename_length + sizeof (\".o\"), 1);\n+#ifdef COLLECT_EXPORT_LIST\n   export_file = xmalloc (temp_filename_length + sizeof (\".x\"));\n+  import_file = xmalloc (temp_filename_length + sizeof (\".p\"));\n+#endif\n   ldout = xmalloc (temp_filename_length + sizeof (\".ld\"));\n   sprintf (ldout, \"%s.ld\", temp_filename);\n   sprintf (c_file, \"%s.c\", temp_filename);\n   sprintf (o_file, \"%s.o\", temp_filename);\n+#ifdef COLLECT_EXPORT_LIST\n   sprintf (export_file, \"%s.x\", temp_filename);\n+  sprintf (import_file, \"%s.p\", temp_filename);\n+#endif\n   *c_ptr++ = c_file_name;\n   *c_ptr++ = \"-c\";\n   *c_ptr++ = \"-o\";\n   *c_ptr++ = o_file;\n \n+#ifdef COLLECT_EXPORT_LIST\n+  /* Generate a list of directories from LIBPATH.  */\n+  prefix_from_env (\"LIBPATH\", &libpath_lib_dirs);\n+  /* Add to this list also two standard directories where\n+     AIX loader always searches for libraries.  */\n+  add_prefix (&libpath_lib_dirs, \"/lib\");\n+  add_prefix (&libpath_lib_dirs, \"/usr/lib\");\n+#endif\n+\n+  /* Get any options that the upper GCC wants to pass to the sub-GCC.  \n+\n+     AIX support needs to know if -shared has been specified before\n+     parsing commandline arguments.  */\n+\n+  p = (char *) getenv (\"COLLECT_GCC_OPTIONS\");\n+  while (p && *p)\n+    {\n+      char *q = extract_string (&p);\n+      if (*q == '-' && (q[1] == 'm' || q[1] == 'f'))\n+\t*c_ptr++ = obstack_copy0 (&permanent_obstack, q, strlen (q));\n+      if (strncmp (q, \"-shared\", sizeof (\"-shared\") - 1) == 0)\n+\tshared_obj = 1;\n+    }\n+  obstack_free (&temporary_obstack, temporary_firstobj);\n+  *c_ptr++ = \"-fno-exceptions\";\n+\n   /* !!! When GCC calls collect2,\n      it does not know whether it is calling collect2 or ld.\n      So collect2 cannot meaningfully understand any options\n@@ -1237,6 +1310,15 @@ main (argc, argv)\n \t{\n \t  switch (arg[1])\n \t    {\n+#ifdef COLLECT_EXPORT_LIST\n+\t    /* We want to disable automatic exports on AIX when user\n+\t       explicitly puts an export list in command line */\n+\t    case 'b':\n+\t      if (arg[2] == 'E' || strncmp (&arg[2], \"export\", 6) == 0)\n+                export_flag = 1;\n+\t      break;\n+#endif\n+\n \t    case 'd':\n \t      if (!strcmp (arg, \"-debug\"))\n \t\t{\n@@ -1256,7 +1338,31 @@ main (argc, argv)\n \t\t  *ld2++ = o_file;\n \t\t  *ld2++ = arg;\n \t\t}\n+#ifdef COLLECT_EXPORT_LIST\n+\t      {\n+\t        /* Resolving full library name.  */\n+\t\tchar *s = resolve_lib_name (arg+2);\n+\n+\t\t/* If we will use an import list for this library,\n+\t\t   we should exclude it from ld args.  */\n+\t\tif (use_import_list (s))\n+\t\t  {\n+\t\t    ld1--;\n+\t\t    ld2--;\n+\t\t  }\n+\n+\t\t/* Saving a full library name.  */\n+\t\tadd_to_list (&libs, s);\n+\t      }\n+#endif\n+\t      break;\n+\n+#ifdef COLLECT_EXPORT_LIST\n+\t    /* Saving directories where to search for libraries.  */\n+       \t    case 'L':\n+\t      add_prefix (&cmdline_lib_dirs, arg+2);\n \t      break;\n+#endif\n \n \t    case 'o':\n \t      if (arg[2] == '\\0')\n@@ -1274,7 +1380,7 @@ main (argc, argv)\n \t      if (arg[2] == '\\0' && do_collecting)\n \t\t{\n \t\t  /* We must strip after the nm run, otherwise C++ linking\n-\t\t     won't work.  Thus we strip in the second ld run, or\n+\t\t     will not work.  Thus we strip in the second ld run, or\n \t\t     else with strip if there is no second ld run.  */\n \t\t  strip_flag = 1;\n \t\t  ld1--;\n@@ -1288,7 +1394,8 @@ main (argc, argv)\n \t    }\n \t}\n       else if ((p = rindex (arg, '.')) != (char *) 0\n-\t       && (strcmp (p, \".o\") == 0 || strcmp (p, \".a\") == 0))\n+\t       && (strcmp (p, \".o\") == 0 || strcmp (p, \".a\") == 0\n+\t\t   || strcmp (p, \".so\") == 0))\n \t{\n \t  if (first_file)\n \t    {\n@@ -1305,39 +1412,66 @@ main (argc, argv)\n \t    }\n \t  if (p[1] == 'o')\n \t    *object++ = arg;\n+#ifdef COLLECT_EXPORT_LIST\n+\t  /* libraries can be specified directly, i.e. without -l flag.  */\n+       \t  else\n+       \t    { \n+\t      /* If we will use an import list for this library,\n+\t\t we should exclude it from ld args.  */\n+\t      if (use_import_list (arg))\n+\t        {\n+\t\t  ld1--;\n+\t\t  ld2--;\n+\t\t}\n+\n+\t      /* Saving a full library name.  */\n+              add_to_list (&libs, arg);\n+            }\n+#endif\n \t}\n     }\n \n-  /* Get any options that the upper GCC wants to pass to the sub-GCC.  */\n-  p = (char *) getenv (\"COLLECT_GCC_OPTIONS\");\n-  while (p && *p)\n+#ifdef COLLECT_EXPORT_LIST\n+  /* This is added only for debugging purposes.  */\n+  if (debug)\n     {\n-      char *q = extract_string (&p);\n-      if (*q == '-' && (q[1] == 'm' || q[1] == 'f'))\n-\t*c_ptr++ = obstack_copy0 (&permanent_obstack, q, strlen (q));\n-      if (strncmp (q, \"-shared\", sizeof (\"shared\") - 1) == 0)\n-\tshared_obj = 1;\n+      fprintf (stderr, \"List of libraries:\\n\");\n+      dump_list (stderr, \"\\t\", libs.first);\n     }\n-  obstack_free (&temporary_obstack, temporary_firstobj);\n-  *c_ptr++ = \"-fno-exceptions\";\n \n-#ifdef COLLECT_EXPORT_LIST\n   /* The AIX linker will discard static constructors in object files if\n      nothing else in the file is referenced, so look at them first.  */\n-  while (object_lst < object)\n-    scan_prog_file (*object_lst++, PASS_OBJ);\n-\n   {\n-    char *buf = alloca (strlen (export_file) + 5);\n-    sprintf (buf, \"-bE:%s\", export_file);\n-    *ld1++ = buf;\n-    *ld2++ = buf;\n+      char **export_object_lst = object_lst;\n+      while (export_object_lst < object)\n+\tscan_prog_file (*export_object_lst++, PASS_OBJ);\n+  }\n+  {\n+    struct id *list = libs.first;\n+    for (; list; list = list->next)\n+      scan_prog_file (list->name, PASS_FIRST);\n+  }\n+  {\n+    char *buf1 = alloca (strlen (export_file) + 5);\n+    char *buf2 = alloca (strlen (import_file) + 5);\n+    sprintf (buf1, \"-bE:%s\", export_file);\n+    sprintf (buf2, \"-bI:%s\", import_file);\n+    *ld1++ = buf1;\n+    *ld2++ = buf1;\n+    *ld1++ = buf2;\n+    *ld2++ = buf2;\n     exportf = fopen (export_file, \"w\");\n     if (exportf == (FILE *) 0)\n       fatal_perror (\"%s\", export_file);\n     write_export_file (exportf);\n     if (fclose (exportf))\n       fatal_perror (\"closing %s\", export_file);\n+    importf = fopen (import_file, \"w\");\n+    if (importf == (FILE *) 0)\n+      fatal_perror (\"%s\", import_file);\n+    write_import_file (importf);\n+    if (fclose (importf))\n+      fatal_perror (\"closing %s\", import_file);\n   }\n #endif\n \n@@ -1399,23 +1533,32 @@ main (argc, argv)\n   /* Load the program, searching all libraries and attempting to provide\n      undefined symbols from repository information.  */\n \n-  do_tlink (ld1_argv, object_lst);\n+  /* On AIX we do this later.  */\n+#ifndef COLLECT_EXPORT_LIST\n+  do_tlink (ld1_argv, object_lst); \n+#else\n \n-  /* If -r or they'll be run via some other method, don't build the\n+  /* If -r or they will be run via some other method, do not build the\n      constructor or destructor list, just return now.  */\n   if (rflag || ! do_collecting)\n     {\n       /* But make sure we delete the export file we may have created.  */\n       if (export_file != 0 && export_file[0])\n \tmaybe_unlink (export_file);\n+      if (import_file != 0 && import_file[0])\n+\tmaybe_unlink (import_file);\n       return 0;\n     }\n+#endif\n \n   /* Examine the namelist with nm and search it for static constructors\n      and destructors to call.\n      Write the constructor and destructor tables to a .s file and reload.  */\n \n+  /* On AIX we already done scanning for global constructors/destructors.  */\n+#ifndef COLLECT_EXPORT_LIST\n   scan_prog_file (output_file, PASS_FIRST);\n+#endif\n \n #ifdef SCAN_LIBRARIES\n   scan_libraries (output_file);\n@@ -1429,14 +1572,18 @@ main (argc, argv)\n \n   if (constructors.number == 0 && destructors.number == 0\n       && frame_tables.number == 0\n-#ifdef SCAN_LIBRARIES\n+#if defined (SCAN_LIBRARIES) || defined (COLLECT_EXPORT_LIST)\n       /* If we will be running these functions ourselves, we want to emit\n-\t stubs into the shared library so that we don't have to relink\n+\t stubs into the shared library so that we do not have to relink\n \t dependent programs when we add static objects.  */\n       && ! shared_obj\n #endif\n       )\n     {\n+#ifdef COLLECT_EXPORT_LIST\n+      /* Doing tlink without additional code generation */\n+      do_tlink (ld1_argv, object_lst);\n+#endif\n       /* Strip now if it was requested on the command line.  */\n       if (strip_flag)\n \t{\n@@ -1449,6 +1596,7 @@ main (argc, argv)\n \n #ifdef COLLECT_EXPORT_LIST\n       maybe_unlink (export_file);\n+      maybe_unlink (import_file);\n #endif\n       return 0;\n     }\n@@ -1505,15 +1653,26 @@ main (argc, argv)\n      Link the tables in with the rest of the program.  */\n \n   fork_execute (\"gcc\",  c_argv);\n+#ifdef COLLECT_EXPORT_LIST\n+  /* On AIX we must call tlink because of possible templates resolution */\n+  do_tlink (ld2_argv, object_lst);\n+#else\n+  /* Otherwise, simply call ld because tlink is already done */\n   fork_execute (\"ld\", ld2_argv);\n \n   /* Let scan_prog_file do any final mods (OSF/rose needs this for\n      constructors/destructors in shared libraries.  */\n   scan_prog_file (output_file, PASS_SECOND);\n+#endif \n \n   maybe_unlink (c_file);\n   maybe_unlink (o_file);\n+\n+#ifdef COLLECT_EXPORT_LIST\n   maybe_unlink (export_file);\n+  maybe_unlink (import_file);\n+#endif\n+\n   return 0;\n }\n \n@@ -1596,8 +1755,8 @@ collect_execute (prog, argv, redir)\n   fflush (stdout);\n   fflush (stderr);\n \n-  /* If we can't find a program we need, complain error.  Do this here\n-     since we might not end up needing something that we couldn't find.  */\n+  /* If we cannot find a program we need, complain error.  Do this here\n+     since we might not end up needing something that we could not find.  */\n \n   if (argv[0] == 0)\n     fatal (\"cannot find `%s'\", prog);\n@@ -1700,6 +1859,47 @@ write_list (stream, prefix, list)\n     }\n }\n \n+/* This function is really used only on AIX, but may be useful.  */\n+static int\n+is_in_list (prefix, list)\n+     char *prefix;\n+     struct id *list;\n+{\n+  while (list)\n+    {\n+      if (!strcmp (prefix, list->name)) return 1;\n+      list = list->next;\n+    }\n+    return 0;\n+}\n+\n+/* Added for debugging purpose.  */\n+static void\n+dump_list (stream, prefix, list)\n+     FILE *stream;\n+     char *prefix;\n+     struct id *list;\n+{\n+  while (list)\n+    {\n+      fprintf (stream, \"%s%s,\\n\", prefix, list->name);\n+      list = list->next;\n+    }\n+}\n+\n+static void\n+dump_prefix_list (stream, prefix, list)\n+     FILE *stream;\n+     char *prefix;\n+     struct prefix_list *list;\n+{\n+  while (list)\n+    {\n+      fprintf (stream, \"%s%s,\\n\", prefix, list->prefix);\n+      list = list->next;\n+    }\n+}\n+\n static void\n write_list_with_asm (stream, prefix, list)\n      FILE *stream;\n@@ -1930,6 +2130,7 @@ write_c_file (stream, name)\n   fprintf (stream, \"#ifdef __cplusplus\\n}\\n#endif\\n\");\n }\n \n+#ifdef COLLECT_EXPORT_LIST\n static void\n write_export_file (stream)\n      FILE *stream;\n@@ -1938,6 +2139,17 @@ write_export_file (stream)\n   for (; list; list = list->next)\n     fprintf (stream, \"%s\\n\", list->name);\n }\n+\n+static void\n+write_import_file (stream)\n+     FILE *stream;\n+{\n+  struct id *list = imports.first;\n+  fprintf (stream, \"%s\\n\", \"#! .\");\n+  for (; list; list = list->next)\n+    fprintf (stream, \"%s\\n\", list->name);\n+}\n+#endif\n \f\n #ifdef OBJECT_FORMAT_NONE\n \n@@ -1967,7 +2179,7 @@ scan_prog_file (prog_name, which_pass)\n   if (which_pass == PASS_SECOND)\n     return;\n \n-  /* If we don't have an `nm', complain.  */\n+  /* If we do not have an `nm', complain.  */\n   if (nm_file_name == 0)\n     fatal (\"cannot find `nm'\");\n \n@@ -2057,7 +2269,7 @@ scan_prog_file (prog_name, which_pass)\n   \n       name = p;\n       /* Find the end of the symbol name.\n-\t Don't include `|', because Encore nm can tack that on the end.  */\n+\t Do not include `|', because Encore nm can tack that on the end.  */\n       for (end = p; (ch2 = *end) != '\\0' && !isspace (ch2) && ch2 != '|';\n \t   end++)\n \tcontinue;\n@@ -2181,7 +2393,7 @@ libselect (d)\n \n    We must verify that the extension is numeric, because Sun saves the\n    original versions of patched libraries with a .FCS extension.  Files with\n-   invalid extensions must go last in the sort, so that they won't be used.  */\n+   invalid extensions must go last in the sort, so that they will not be used.  */\n \n static int\n libcompare (d1, d2)\n@@ -2409,7 +2621,7 @@ scan_libraries (prog_name)\n   char buf[1024];\n   FILE *inf;\n \n-  /* If we don't have an `ldd', complain.  */\n+  /* If we do not have an `ldd', complain.  */\n   if (ldd_file_name == 0)\n     {\n       error (\"cannot find `ldd'\");\n@@ -2554,8 +2766,11 @@ scan_libraries (prog_name)\n #   define GCC_SYMENT\t\tSYMENT\n #   define GCC_OK_SYMBOL(X) \\\n      (((X).n_sclass == C_EXT) && \\\n-        (((X).n_type & N_TMASK) == (DT_NON << N_BTSHFT) || \\\n-         ((X).n_type & N_TMASK) == (DT_FCN << N_BTSHFT)))\n+      ((X).n_scnum > N_UNDEF) && \\\n+      (((X).n_type & N_TMASK) == (DT_NON << N_BTSHFT) || \\\n+       ((X).n_type & N_TMASK) == (DT_FCN << N_BTSHFT)))\n+#   define GCC_UNDEF_SYMBOL(X) \\\n+     (((X).n_sclass == C_EXT) && ((X).n_scnum == N_UNDEF))\n #   define GCC_SYMINC(X)\t((X).n_numaux+1)\n #   define GCC_SYMZERO(X)\t0\n #   define GCC_CHECK_HDR(X)\t(1)\n@@ -2579,246 +2794,264 @@ scan_prog_file (prog_name, which_pass)\n {\n   LDFILE *ldptr = NULL;\n   int sym_index, sym_count;\n+  int is_shared = 0;\n+#ifdef COLLECT_EXPORT_LIST\n+  /* Should we generate an import list for given prog_name?  */\n+  int import_flag = (which_pass == PASS_OBJ ? 0 : use_import_list (prog_name));\n+#endif\n \n   if (which_pass != PASS_FIRST && which_pass != PASS_OBJ)\n     return;\n \n-  if ((ldptr = ldopen (prog_name, ldptr)) == NULL)\n-    fatal (\"%s: can't open as COFF file\", prog_name);\n-      \n-  if (!MY_ISCOFF (HEADER (ldptr).f_magic))\n-    fatal (\"%s: not a COFF file\", prog_name);\n+#ifdef COLLECT_EXPORT_LIST\n+  /* We do not need scanning for some standard C libraries.  */\n+  if (which_pass == PASS_FIRST && ignore_library (prog_name))\n+    return;\n \n-  if (GCC_CHECK_HDR (ldptr))\n+  /* On AIX we have a loop, because there is not much difference\n+     between an object and an archive. This trick allows us to\n+     eliminate scan_libraries() function.  */\n+  do\n     {\n-      sym_count = GCC_SYMBOLS (ldptr);\n-      sym_index = GCC_SYMZERO (ldptr);\n-      while (sym_index < sym_count)\n+#endif\n+      if ((ldptr = ldopen (prog_name, ldptr)) != NULL)\n \t{\n-\t  GCC_SYMENT symbol;\n \n-\t  if (ldtbread (ldptr, sym_index, &symbol) <= 0)\n-\t    break;\n-\t  sym_index += GCC_SYMINC (symbol);\n+\t  if (!MY_ISCOFF (HEADER (ldptr).f_magic))\n+\t    fatal (\"%s: not a COFF file\", prog_name);\n \n-\t  if (GCC_OK_SYMBOL (symbol))\n+#ifdef COLLECT_EXPORT_LIST\n+\t  /* Is current archive member a shared object?  */\n+\t  is_shared = HEADER (ldptr).f_flags & F_SHROBJ;\n+#endif\n+\t  if (GCC_CHECK_HDR (ldptr))\n \t    {\n-\t      char *name;\n+\t      sym_count = GCC_SYMBOLS (ldptr);\n+\t      sym_index = GCC_SYMZERO (ldptr);\n+\t      while (sym_index < sym_count)\n+\t\t{\n+\t\t  GCC_SYMENT symbol;\n+\n+\t\t  if (ldtbread (ldptr, sym_index, &symbol) <= 0)\n+\t\t    break;\n+\t\t  sym_index += GCC_SYMINC (symbol);\n+\n+\t\t  if (GCC_OK_SYMBOL (symbol))\n+\t\t    {\n+\t\t      char *name;\n \n-\t      if ((name = ldgetname (ldptr, &symbol)) == NULL)\n-\t\tcontinue;\t\t/* should never happen */\n+\t\t      if ((name = ldgetname (ldptr, &symbol)) == NULL)\n+\t\t\tcontinue;\t\t/* should never happen */\n \n #ifdef XCOFF_DEBUGGING_INFO\n-\t      /* All AIX function names have a duplicate entry beginning\n-\t\t with a dot.  */\n-\t      if (*name == '.')\n-\t\t++name;\n+\t\t      /* All AIX function names have a duplicate entry\n+\t\t\t beginning with a dot.  */\n+\t\t      if (*name == '.')\n+\t\t\t++name;\n #endif\n \n-\t      switch (is_ctor_dtor (name))\n-\t\t{\n-\t\tcase 1:\n-\t\t  add_to_list (&constructors, name);\n-\t\t  if (which_pass == PASS_OBJ)\n-\t\t    add_to_list (&exports, name);\n-\t\t  break;\n+\t\t      switch (is_ctor_dtor (name))\n+\t\t\t{\n+\t\t\tcase 1:\n+\t\t\t  if (! is_shared) add_to_list (&constructors, name);\n+\t\t\t  if (which_pass == PASS_OBJ)\n+\t\t\t    add_to_list (&exports, name);\n+#ifdef COLLECT_EXPORT_LIST\n+\t\t\t  /* If this symbol was undefined and we are building\n+\t\t\t     an import list, we should add a symbol to this\n+\t\t\t     list.  */\n+\t\t\t  else\n+\t\t\t    if (import_flag\n+\t\t\t\t&& is_in_list (name, undefined.first))\n+\t\t\t      add_to_list (&imports, name);\n+#endif\n+\t\t\t  break;\n+\n+\t\t\tcase 2:\n+\t\t\t  if (! is_shared) add_to_list (&destructors, name);\n+\t\t\t  if (which_pass == PASS_OBJ)\n+\t\t\t    add_to_list (&exports, name);\n+#ifdef COLLECT_EXPORT_LIST\n+\t\t\t  /* If this symbol was undefined and we are building\n+\t\t\t     an import list, we should add a symbol to this\n+\t\t\t     list.  */\n+\t\t\t  else\n+\t\t\t    if (import_flag\n+\t\t\t\t&& is_in_list (name, undefined.first))\n+\t\t\t      add_to_list (&imports, name);\n+#endif\n+\t\t\t  break;\n \n-\t\tcase 2:\n-\t\t  add_to_list (&destructors, name);\n-\t\t  if (which_pass == PASS_OBJ)\n-\t\t    add_to_list (&exports, name);\n-\t\t  break;\n+#ifdef COLLECT_EXPORT_LIST\n+\t\t\tcase 3:\n+\t\t\t  if (is_shared)\n+\t\t\t    add_to_list (&constructors, name);\n+\t\t\t  break;\n \n-\t\tdefault:\t\t/* not a constructor or destructor */\n-\t\t  continue;\n-\t\t}\n+\t\t\tcase 4:\n+\t\t\t  if (is_shared)\n+\t\t\t    add_to_list (&destructors, name);\n+\t\t\t  break;\n+#endif\n+\n+\t\t\tdefault:\t/* not a constructor or destructor */\n+#ifdef COLLECT_EXPORT_LIST\n+\t\t\t  /* If we are building a shared object on AIX we need\n+\t\t\t     to explicitly export all global symbols or add\n+\t\t\t     them to import list.  */\n+\t\t\t  if (shared_obj) \n+\t\t\t    if (which_pass == PASS_OBJ && (! export_flag))\n+\t\t\t      add_to_list (&exports, name);\n+\t\t\t    else if (! is_shared && which_pass == PASS_FIRST\n+\t\t\t\t     && import_flag\n+\t\t\t\t     && is_in_list(name, undefined.first))\n+\t\t\t      add_to_list (&imports, name);\n+#endif\n+\t\t\t  continue;\n+\t\t\t}\n \n #if !defined(EXTENDED_COFF)\n-\t      if (debug)\n-\t\tfprintf (stderr, \"\\tsec=%d class=%d type=%s%o %s\\n\",\n-\t\t\t symbol.n_scnum, symbol.n_sclass,\n-\t\t\t (symbol.n_type ? \"0\" : \"\"), symbol.n_type,\n-\t\t\t name);\n+\t\t      if (debug)\n+\t\t\tfprintf (stderr, \"\\tsec=%d class=%d type=%s%o %s\\n\",\n+\t\t\t\t symbol.n_scnum, symbol.n_sclass,\n+\t\t\t\t (symbol.n_type ? \"0\" : \"\"), symbol.n_type,\n+\t\t\t\t name);\n #else\n-\t      if (debug)\n-\t\tfprintf (stderr, \"\\tiss = %5d, value = %5d, index = %5d, name = %s\\n\",\n-\t\t\t symbol.iss, symbol.value, symbol.index, name);\n+\t\t      if (debug)\n+\t\t\tfprintf (stderr,\n+\t\t\t\t \"\\tiss = %5d, value = %5d, index = %5d, name = %s\\n\",\n+\t\t\t\t symbol.iss, symbol.value, symbol.index, name);\n+#endif\n+\t\t    }\n+#ifdef COLLECT_EXPORT_LIST\n+\t\t  /* If we are building a shared object we should collect\n+\t\t     information about undefined symbols for later\n+\t\t     import list generation.  */\n+\t\t  else if (shared_obj && GCC_UNDEF_SYMBOL (symbol))\n+\t\t    {\n+\t\t      char *name;\n+\n+\t\t      if ((name = ldgetname (ldptr, &symbol)) == NULL)\n+\t\t\tcontinue;\t\t/* should never happen */\n+\n+\t\t      /* All AIX function names have a duplicate entry\n+\t\t\t beginning with a dot.  */\n+\t\t      if (*name == '.')\n+\t\t\t++name;\n+\t\t      add_to_list (&undefined, name);\n+\t\t    }\n #endif\n+\t\t}\n \t    }\n \t}\n+      else\n+\t{\n+\t  fatal (\"%s: cannot open as COFF file\", prog_name);\n+\t}\n+#ifdef COLLECT_EXPORT_LIST\n+      /* On AIX loop continues while there are more members in archive.  */\n     }\n-\n+  while (ldclose (ldptr) == FAILURE);\n+#else\n+  /* Otherwise we simply close ldptr.  */\n   (void) ldclose(ldptr);\n+#endif\n }\n \n-#ifdef XCOFF_SCAN_LIBS\n-/* Scan imported AIX libraries for GCC static ctors and dtors.\n-   FIXME: it is possible to link an executable without the actual import\n-\t  library by using an \"import file\" - a text file listing symbols\n-\t  exported by a library.  To support this, we would have to scan\n-\t  import files as well as actual shared binaries to find GCC ctors.\n-   TODO: use memory mapping instead of 'ld' routines, files are already\n-\t memory mapped, but we could eliminate the extra in-memory copies.\n-\t Is it worth the effort?  */\n \n-static void\n-scan_libraries (prog_name)\n+#ifdef COLLECT_EXPORT_LIST\n+\n+/* This new function is used to decide whether we should\n+   generate import list for an object or to use it directly.  */\n+static int\n+use_import_list (prog_name)\n      char *prog_name;\n {\n-  LDFILE *ldptr;\n-  SCNHDR ldsh;\n-  static struct path_prefix libpath; /* we should only do this once */\n+  char *p;\n \n-  if ((ldptr = ldopen (prog_name, ldptr)) == NULL)\n-    fatal (\"%s: can't open as COFF file\", prog_name);\n-      \n-  if (!MY_ISCOFF (HEADER (ldptr).f_magic))\n-    fatal (\"%s: not a COFF file\", prog_name);\n+  /* If we do not build a shared object then import list should not be used.  */\n+  if (! shared_obj) return 0;\n \n-  /* find and read loader section */\n-  if (ldnshread (ldptr, _LOADER, &ldsh))\n-    {\n-      LDHDR ldh;\n-      char *impbuf;\n-      int entry;\n+  /* Currently we check only for libgcc, but this can be changed in future.  */\n+  p = strstr (prog_name, \"libgcc.a\");\n+  if (p != 0 && (strlen (p) == sizeof (\"libgcc.a\") - 1))\n+    return 1;\n+  return 0;\n+}\n \n-      FSEEK (ldptr, ldsh.s_scnptr, BEGINNING);\n-      FREAD (&ldh, sizeof (ldh), 1, ldptr);\n-      /* read import library list */\n-      impbuf = alloca (ldh.l_istlen);\n-      FSEEK (ldptr, ldh.l_impoff + ldsh.s_scnptr, BEGINNING);\n-      FREAD (impbuf, ldh.l_istlen, 1, ldptr);\n+/* Given a library name without \"lib\" prefix, this function\n+   returns a full library name including a path.  */\n+static char *\n+resolve_lib_name (name)\n+     char *name;\n+{\n+  char *lib_buf;\n+  int i, j, l = 0;\n \n-      if (debug)\n-\tfprintf (stderr, \"LIBPATH=%s\\n\", impbuf);\n-      prefix_from_string (impbuf, &libpath);\n+  for (i = 0; libpaths[i]; i++)\n+    if (libpaths[i]->max_len > l)\n+      l = libpaths[i]->max_len;\n \n-      /* skip LIBPATH and empty base and member fields */\n-      impbuf += strlen (impbuf) + 3;\n-      for (entry = 1; entry < ldh.l_nimpid; ++entry)\n-\t{\n-\t  char *impath = impbuf;\n-\t  char *implib = impath + strlen (impath) + 1;\n-\t  char *impmem = implib + strlen (implib) + 1;\n-\t  char *soname = NULL;\n-\t  char *trial;\n-\t  int pathlen;\n-\t  LDFILE *libptr = NULL;\n-\t  struct prefix_list *pl;\n-\t  ARCHDR ah;\n-\n-\t  impbuf = impmem + strlen (impmem) + 1;\n-\t  if (debug)\n-\t    fprintf (stderr, \"PATH+BASE=%s%s\\n\", impath, implib);\n-\t  /* Skip AIX kernel exports */\n-\t  if (*impath == '/' && *(impath+1) == '\\0'\n-\t      && strcmp (implib, \"unix\") == 0)\n-\t    continue;\n-\t  pathlen = strlen (impath);\n-          trial = alloca (MAX (pathlen + 1, libpath.max_len)\n-\t\t\t  + strlen (implib) + 1);\n-\t  if (*impath)\n-\t    {\n-\t      strcpy (trial, impath);\n-\t      if (impath[pathlen - 1] != '/')\n-\t\ttrial[pathlen++] = '/';\n-\t      strcpy (trial + pathlen, implib);\n-\t      if (access (trial, R_OK) == 0)\n-\t\tsoname = trial;\n-\t    }\n-\t  else\n-\t    for (pl = libpath.plist; pl; pl = pl->next)\n-\t      {\n-\t\tstrcpy (trial, pl->prefix);\n-\t\tstrcat (trial, implib);\n-\t\tif (access (trial, R_OK) == 0)\n-\t\t  {\n-\t\t    soname = trial;\n-\t\t    break;\n-\t\t  }\n-\t      }\n+  lib_buf = xmalloc (l + strlen(name) + 10);\n \n-\t  if (! soname)\n-\t    fatal (\"%s: library not found\", implib);\n-\t  if (debug)\n-\t    if (*impmem)\n-\t      fprintf (stderr, \"%s (%s)\\n\", soname, impmem);\n-\t    else\n-\t      fprintf (stderr, \"%s\\n\", soname);\n-\n-\t  do\n+  for (i = 0; libpaths[i]; i++)\n+    {\n+      struct prefix_list *list = libpaths[i]->plist;\n+      for (; list; list = list->next)\n+\t{\n+\t  for (j = 0; libexts[j]; j++)\n \t    {\n-\t      /* scan imported shared objects for GCC GLOBAL ctors */\n-\t      short type;\n-\t      if ((libptr = ldopen (soname, libptr)) == NULL)\n-\t\tfatal (\"%s: can't open import library\", soname);\n-\t      if (TYPE (libptr) == ARTYPE)\n-\t\t{\n-\t\t  LDFILE *memptr;\n-\t\t  if (! *impmem)\n-\t\t    fatal (\"%s: no archive member specified\", soname);\n-\t\t  ldahread (libptr, &ah);\n-\t\t  if (strcmp (ah.ar_name, impmem))\n-\t\t    continue;\n-\t\t}\n-\t      type = HEADER (libptr).f_magic;\n-\t      if (HEADER (libptr).f_flags & F_SHROBJ)\n+              /* The following lines are needed because path_prefix list\n+                 may contain directories both with trailing '/' and\n+                 without it.  */\n+              char *p = \"\";\n+              if (list->prefix[strlen(list->prefix)-1] != '/')\n+                p = \"/\";\n+       \t      sprintf (lib_buf, \"%s%slib%s.%s\",\n+\t\t       list->prefix, p, name, libexts[j]);\n+if (debug) fprintf (stderr, \"searching for: %s\\n\", lib_buf);\n+\t      if (file_exists (lib_buf))\n \t\t{\n-\t\t  SCNHDR soldsh;\n-\t\t  LDHDR soldh;\n-\t\t  long symcnt, i;\n-\t\t  char *ldstrings;\n-\t\t  LDSYM *lsyms;\n-\t\t  if (!ldnshread (libptr, _LOADER, &soldsh))\n-\t\t    fatal (\"%s: not an import library\", soname);\n-\t\t  FSEEK (libptr, soldsh.s_scnptr, BEGINNING);\n-\t\t  if (FREAD (&soldh, sizeof (soldh), 1, libptr) != 1)\n-\t\t    fatal (\"%s: can't read loader section\", soname);\n-\t\t  /*fprintf (stderr, \"\\tscanning %s\\n\", soname);*/\n-\t\t  symcnt = soldh.l_nsyms;\n-\t\t  lsyms = (LDSYM *) alloca (symcnt * sizeof (*lsyms));\n-\t\t  symcnt = FREAD (lsyms, sizeof (*lsyms), symcnt, libptr);\n-\t\t  ldstrings = alloca (soldh.l_stlen);\n-\t\t  FSEEK (libptr, soldsh.s_scnptr+soldh.l_stoff, BEGINNING);\n-\t\t  FREAD (ldstrings, soldh.l_stlen, 1, libptr);\n-\t\t  for (i = 0; i < symcnt; ++i)\n-\t\t    {\n-\t\t      LDSYM *l = lsyms + i;\n-\t\t      if (LDR_EXPORT (*l))\n-\t\t\t{\n-\t\t\t  char *expname = 0;\n-\t\t\t  if (l->l_zeroes)\n-\t\t\t    expname = l->l_name;\n-\t\t\t  else if (l->l_offset < soldh.l_stlen)\n-\t\t\t    expname = ldstrings + l->l_offset;\n-\t\t\t  switch (is_ctor_dtor (expname))\n-\t\t\t    {\n-\t\t\t    case 3:\n-\t\t\t      if (debug)\n-\t\t\t\tfprintf (stderr, \"\\t%s\\n\", expname);\n-\t\t\t      add_to_list (&constructors, expname);\n-\t\t\t      break;\n-\n-\t\t\t    case 4:\n-\t\t\t      add_to_list (&destructors, expname);\n-\t\t\t      break;\n-\n-\t\t\t    default: /* not a constructor or destructor */\n-\t\t\t      continue;\n-\t\t\t    }\n-\t\t\t}\n-\t\t    }\n+if (debug) fprintf (stderr, \"found: %s\\n\", lib_buf);\n+\t\t  return (lib_buf);\n \t\t}\n-\t      else\n-\t\tfprintf (stderr, \"%s: type = %04X flags = %04X\\n\", \n-\t\t\t ah.ar_name, type, HEADER (libptr).f_flags);\n \t    }\n-\t  while (ldclose (libptr) == FAILURE);\n-\t  /* printf (stderr, \"closed %s\\n\", soname); */\n \t}\n     }\n+  if (debug)\n+    fprintf (stderr, \"not found\\n\");\n+  else\n+    fatal (\"Library lib%s not found\", name);\n+  return (NULL);\n+}\n+\n+/* Array of standard AIX libraries which should not\n+   be scanned for ctors/dtors.  */\n+static char* aix_std_libs[] = {\n+  \"/unix\",\n+  \"/lib/libc.a\",\n+  \"/lib/libc_r.a\",\n+  \"/usr/lib/libc.a\",\n+  \"/usr/lib/libc_r.a\",\n+  \"/usr/lib/threads/libc.a\",\n+  \"/usr/ccs/lib/libc.a\",\n+  \"/usr/ccs/lib/libc_r.a\",\n+  NULL\n+};\n+\n+/* This function checks the filename and returns 1\n+   if this name matches the location of a standard AIX library. */\n+static int\n+ignore_library (name)\n+     char *name;\n+{\n+  char **p = &aix_std_libs[0];\n+  while (*p++ != NULL)\n+    if (! strcmp (name, *p)) return 1;\n+  return 0;\n }\n-#endif /* XCOFF_SCAN_LIBS */\n+\n+#endif\n \n #endif /* OBJECT_FORMAT_COFF */\n \n@@ -2912,7 +3145,7 @@ scan_prog_file (prog_name, which_pass)\n \n   prog_fd = open (prog_name, (rw) ? O_RDWR : O_RDONLY);\n   if (prog_fd < 0)\n-    fatal_perror (\"can't read %s\", prog_name);\n+    fatal_perror (\"cannot read %s\", prog_name);\n \n   obj_file = read_file (prog_name, prog_fd, rw);\n   obj = obj_file->start;\n@@ -3084,7 +3317,7 @@ scan_prog_file (prog_name, which_pass)\n \tfatal (\"no cmd_strings found\");\n \n       /* Add __main to initializer list.\n-\t If we are building a program instead of a shared library, don't\n+\t If we are building a program instead of a shared library, do not\n \t do anything, since in the current version, you cannot do mallocs\n \t and such in the constructors.  */\n "}]}