{"sha": "ece54d544da404f5d0e9c5efd78ff53e9636ce36", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWNlNTRkNTQ0ZGE0MDRmNWQwZTljNWVmZDc4ZmY1M2U5NjM2Y2UzNg==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.demon.co.uk", "date": "2001-09-28T09:40:22Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2001-09-28T09:40:22Z"}, "message": "cpphash.h (struct cpp_buff): Make unsigned.\n\n\t* cpphash.h (struct cpp_buff): Make unsigned.\n\t(_cpp_get_buff): Take length of size_t.\n\t(_cpp_unaligned_alloc): New.\n\t(BUFF_ROOM, BUFF_FRONT, BUFF_LIMIT): New.\n\t(struct cpp_reader): Remove ident_pool.  Add u_buff.\n\t* cppinit.c (cpp_create_reader): Initialize u_buff, not ident_pool.\n\t(cpp_destroy): Destroy u_buff, not ident_pool.\n\t* cpplex.c (parse_number, parse_string, save_comment,\n\tcpp_token_as_text): Update to use the unaligned buffer.\n\t(new_buff): Make unsigned.\n\t(_cpp_unaligned_alloc): New.\n\t* cpplib.c (glue_header_name): Update to use the unaligned buffer.\n\t* cppmacro.c (new_number_token, builtin_macro, stringify_arg):\n\tSimilarly.\n\t(collect_args): Make unsigned.\n\nFrom-SVN: r45858", "tree": {"sha": "04de76def0a1a191465d81cb782799aeec34587f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/04de76def0a1a191465d81cb782799aeec34587f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ece54d544da404f5d0e9c5efd78ff53e9636ce36", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ece54d544da404f5d0e9c5efd78ff53e9636ce36", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ece54d544da404f5d0e9c5efd78ff53e9636ce36", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ece54d544da404f5d0e9c5efd78ff53e9636ce36/comments", "author": null, "committer": null, "parents": [{"sha": "0c0d83a1b4414876e77011d606631aafe94a271d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c0d83a1b4414876e77011d606631aafe94a271d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c0d83a1b4414876e77011d606631aafe94a271d"}], "stats": {"total": 204, "additions": 129, "deletions": 75}, "files": [{"sha": "fe1ebff2ae6790a14abe89b4bcf624ed9a6b7583", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ece54d544da404f5d0e9c5efd78ff53e9636ce36/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ece54d544da404f5d0e9c5efd78ff53e9636ce36/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ece54d544da404f5d0e9c5efd78ff53e9636ce36", "patch": "@@ -1,3 +1,21 @@\n+2001-09-28  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+\t* cpphash.h (struct cpp_buff): Make unsigned.\n+\t(_cpp_get_buff): Take length of size_t.\n+\t(_cpp_unaligned_alloc): New.\n+\t(BUFF_ROOM, BUFF_FRONT, BUFF_LIMIT): New.\n+\t(struct cpp_reader): Remove ident_pool.  Add u_buff.\n+\t* cppinit.c (cpp_create_reader): Initialize u_buff, not ident_pool.\n+\t(cpp_destroy): Destroy u_buff, not ident_pool.\n+\t* cpplex.c (parse_number, parse_string, save_comment,\n+\tcpp_token_as_text): Update to use the unaligned buffer.\n+\t(new_buff): Make unsigned.\n+\t(_cpp_unaligned_alloc): New.\n+\t* cpplib.c (glue_header_name): Update to use the unaligned buffer.\n+\t* cppmacro.c (new_number_token, builtin_macro, stringify_arg):\n+\tSimilarly.\n+\t(collect_args): Make unsigned.\n+\n 2001-09-27  Zack Weinberg  <zack@codesourcery.com>\n \n \t* cpplex.c (cpp_output_token): Use a putc loop for"}, {"sha": "874baf2e63bfdeb23de9488b6a6637dabda81488", "filename": "gcc/cpphash.h", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ece54d544da404f5d0e9c5efd78ff53e9636ce36/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ece54d544da404f5d0e9c5efd78ff53e9636ce36/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=ece54d544da404f5d0e9c5efd78ff53e9636ce36", "patch": "@@ -77,14 +77,18 @@ typedef struct _cpp_buff _cpp_buff;\n struct _cpp_buff\n {\n   struct _cpp_buff *next;\n-  char *base, *cur, *limit;\n+  unsigned char *base, *cur, *limit;\n };\n \n-extern _cpp_buff *_cpp_get_buff PARAMS ((cpp_reader *, unsigned int));\n+extern _cpp_buff *_cpp_get_buff PARAMS ((cpp_reader *, size_t));\n extern void _cpp_release_buff PARAMS ((cpp_reader *, _cpp_buff *));\n extern _cpp_buff *_cpp_extend_buff PARAMS ((cpp_reader *, _cpp_buff *,\n-\t\t\t\t\t    unsigned int));\n+\t\t\t\t\t    size_t));\n extern void _cpp_free_buff PARAMS ((_cpp_buff *));\n+extern unsigned char *_cpp_unaligned_alloc PARAMS ((cpp_reader *, size_t));\n+#define BUFF_ROOM(BUFF) ((BUFF)->limit - (BUFF)->cur)\n+#define BUFF_FRONT(BUFF) ((BUFF)->cur)\n+#define BUFF_LIMIT(BUFF) ((BUFF)->limit)\n \n /* List of directories to look for include files in.  */\n struct search_path\n@@ -267,12 +271,11 @@ struct cpp_reader\n   unsigned int directive_line;\n \n   /* Memory pools.  */\n-  cpp_pool ident_pool;\t\t/* For all identifiers, and permanent\n-\t\t\t\t   numbers and strings.  */\n   cpp_pool macro_pool;\t\t/* For macro definitions.  Permanent.  */\n \n   /* Memory buffers.  */\n-  _cpp_buff *free_buffs;\n+  _cpp_buff *u_buff;\t\t/* Unaligned permanent storage.  */\n+  _cpp_buff *free_buffs;\t/* Free buffer chain.  */\n \n   /* Context stack.  */\n   struct cpp_context base_context;"}, {"sha": "5150a0e2c46311eb55b44035e7d136ac9eeaaf07", "filename": "gcc/cppinit.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ece54d544da404f5d0e9c5efd78ff53e9636ce36/gcc%2Fcppinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ece54d544da404f5d0e9c5efd78ff53e9636ce36/gcc%2Fcppinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppinit.c?ref=ece54d544da404f5d0e9c5efd78ff53e9636ce36", "patch": "@@ -527,8 +527,8 @@ cpp_create_reader (table, lang)\n   pfile->base_context.macro = 0;\n   pfile->base_context.prev = pfile->base_context.next = 0;\n \n-  /* Identifier pool initially 8K.  Unaligned, permanent pool.  */\n-  _cpp_init_pool (&pfile->ident_pool, 8 * 1024, 1, 0);\n+  /* Unaligned storage.  */\n+  pfile->u_buff = _cpp_get_buff (pfile, 0);\n \n   /* Macro pool initially 8K.  Aligned, permanent pool.  */\n   _cpp_init_pool (&pfile->macro_pool, 8 * 1024, 0, 0);\n@@ -585,8 +585,8 @@ cpp_destroy (pfile)\n   _cpp_destroy_hashtable (pfile);\n   _cpp_cleanup_includes (pfile);\n \n-  _cpp_free_pool (&pfile->ident_pool);\n   _cpp_free_pool (&pfile->macro_pool);\n+  _cpp_free_buff (pfile->u_buff);\n   _cpp_free_buff (pfile->free_buffs);\n \n   for (run = &pfile->base_run; run; run = runn)"}, {"sha": "e3fa56ccabc3d35da920abcdba9d3cea9b2f3eb1", "filename": "gcc/cpplex.c", "status": "modified", "additions": 54, "deletions": 21, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ece54d544da404f5d0e9c5efd78ff53e9636ce36/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ece54d544da404f5d0e9c5efd78ff53e9636ce36/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=ece54d544da404f5d0e9c5efd78ff53e9636ce36", "patch": "@@ -599,17 +599,20 @@ parse_number (pfile, number, c, leading_period)\n      int leading_period;\n {\n   cpp_buffer *buffer = pfile->buffer;\n-  cpp_pool *pool = &pfile->ident_pool;\n   unsigned char *dest, *limit;\n \n-  dest = POOL_FRONT (pool);\n-  limit = POOL_LIMIT (pool);\n+  dest = BUFF_FRONT (pfile->u_buff);\n+  limit = BUFF_LIMIT (pfile->u_buff);\n \n   /* Place a leading period.  */\n   if (leading_period)\n     {\n-      if (dest >= limit)\n-\tlimit = _cpp_next_chunk (pool, 0, &dest);\n+      if (dest == limit)\n+\t{\n+\t  pfile->u_buff = _cpp_extend_buff (pfile, pfile->u_buff, 1);\n+\t  dest = BUFF_FRONT (pfile->u_buff);\n+\t  limit = BUFF_LIMIT (pfile->u_buff);\n+\t}\n       *dest++ = '.';\n     }\n   \n@@ -618,8 +621,13 @@ parse_number (pfile, number, c, leading_period)\n       do\n \t{\n \t  /* Need room for terminating null.  */\n-\t  if (dest + 1 >= limit)\n-\t    limit = _cpp_next_chunk (pool, 0, &dest);\n+\t  if ((size_t) (limit - dest) < 2)\n+\t    {\n+\t      size_t len_so_far = dest - BUFF_FRONT (pfile->u_buff);\n+\t      pfile->u_buff = _cpp_extend_buff (pfile, pfile->u_buff, 2);\n+\t      dest = BUFF_FRONT (pfile->u_buff) + len_so_far;\n+\t      limit = BUFF_LIMIT (pfile->u_buff);\n+\t    }\n \t  *dest++ = c;\n \n \t  c = EOF;\n@@ -643,9 +651,9 @@ parse_number (pfile, number, c, leading_period)\n   /* Null-terminate the number.  */\n   *dest = '\\0';\n \n-  number->text = POOL_FRONT (pool);\n+  number->text = BUFF_FRONT (pfile->u_buff);\n   number->len = dest - number->text;\n-  POOL_COMMIT (pool, number->len + 1);\n+  BUFF_FRONT (pfile->u_buff) = dest + 1;\n }\n \n /* Subroutine of parse_string.  Emits error for unterminated strings.  */\n@@ -676,7 +684,7 @@ unescaped_terminator_p (pfile, dest)\n   if (pfile->state.angled_headers)\n     return 1;\n \n-  start = POOL_FRONT (&pfile->ident_pool);\n+  start = BUFF_FRONT (pfile->u_buff);\n \n   /* An odd number of consecutive backslashes represents an escaped\n      terminator.  */\n@@ -699,13 +707,12 @@ parse_string (pfile, token, terminator)\n      cppchar_t terminator;\n {\n   cpp_buffer *buffer = pfile->buffer;\n-  cpp_pool *pool = &pfile->ident_pool;\n   unsigned char *dest, *limit;\n   cppchar_t c;\n   bool warned_nulls = false, warned_multi = false;\n \n-  dest = POOL_FRONT (pool);\n-  limit = POOL_LIMIT (pool);\n+  dest = BUFF_FRONT (pfile->u_buff);\n+  limit = BUFF_LIMIT (pfile->u_buff);\n \n   for (;;)\n     {\n@@ -716,8 +723,13 @@ parse_string (pfile, token, terminator)\n \n     have_char:\n       /* We need space for the terminating NUL.  */\n-      if (dest >= limit)\n-\tlimit = _cpp_next_chunk (pool, 0, &dest);\n+      if ((size_t) (limit - dest) < 1)\n+\t{\n+\t  size_t len_so_far = dest - BUFF_FRONT (pfile->u_buff);\n+\t  pfile->u_buff = _cpp_extend_buff (pfile, pfile->u_buff, 2);\n+\t  dest = BUFF_FRONT (pfile->u_buff) + len_so_far;\n+\t  limit = BUFF_LIMIT (pfile->u_buff);\n+\t}\n \n       if (c == EOF)\n \t{\n@@ -781,9 +793,9 @@ parse_string (pfile, token, terminator)\n   buffer->read_ahead = c;\n   *dest = '\\0';\n \n-  token->val.str.text = POOL_FRONT (pool);\n-  token->val.str.len = dest - token->val.str.text;\n-  POOL_COMMIT (pool, token->val.str.len + 1);\n+  token->val.str.text = BUFF_FRONT (pfile->u_buff);\n+  token->val.str.len = dest - BUFF_FRONT (pfile->u_buff);\n+  BUFF_FRONT (pfile->u_buff) = dest + 1;\n }\n \n /* The stored comment includes the comment start and any terminator.  */\n@@ -801,7 +813,7 @@ save_comment (pfile, token, from)\n      line, which we don't want to save in the comment.  */\n   if (pfile->buffer->read_ahead != EOF)\n     len--;\n-  buffer = _cpp_pool_alloc (&pfile->ident_pool, len);\n+  buffer = _cpp_unaligned_alloc (pfile, len);\n   \n   token->type = CPP_COMMENT;\n   token->val.str.len = len;\n@@ -1485,7 +1497,7 @@ cpp_token_as_text (pfile, token)\n      const cpp_token *token;\n {\n   unsigned int len = cpp_token_len (token);\n-  unsigned char *start = _cpp_pool_alloc (&pfile->ident_pool, len), *end;\n+  unsigned char *start = _cpp_unaligned_alloc (pfile, len), *end;\n \n   end = cpp_spell_token (pfile, token, start);\n   end[0] = '\\0';\n@@ -2043,7 +2055,7 @@ new_buff (len)\n      unsigned int len;\n {\n   _cpp_buff *result;\n-  char *base;\n+  unsigned char *base;\n \n   if (len < MIN_BUFF_SIZE)\n     len = MIN_BUFF_SIZE;\n@@ -2130,6 +2142,27 @@ _cpp_free_buff (buff)\n     }\n }\n \n+/* Allocate permanent, unaligned storage of length LEN.  */\n+unsigned char *\n+_cpp_unaligned_alloc (pfile, len)\n+     cpp_reader *pfile;\n+     size_t len;\n+{\n+  _cpp_buff *buff = pfile->u_buff;\n+  unsigned char *result = buff->cur;\n+\n+  if (len > (size_t) (buff->limit - result))\n+    {\n+      buff = _cpp_get_buff (pfile, len);\n+      buff->next = pfile->u_buff;\n+      pfile->u_buff = buff;\n+      result = buff->cur;\n+    }\n+\n+  buff->cur = result + len;\n+  return result;\n+}\n+\n static int\n chunk_suitable (chunk, size)\n      cpp_chunk *chunk;"}, {"sha": "2d5968a37c8cb2630f89b77c6cf51728e72ed3d6", "filename": "gcc/cpplib.c", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ece54d544da404f5d0e9c5efd78ff53e9636ce36/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ece54d544da404f5d0e9c5efd78ff53e9636ce36/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=ece54d544da404f5d0e9c5efd78ff53e9636ce36", "patch": "@@ -493,49 +493,48 @@ glue_header_name (pfile)\n {\n   cpp_token *header = NULL;\n   const cpp_token *token;\n-  unsigned char *buffer, *token_mem;\n-  size_t len, total_len = 0, capacity = 1024;\n+  unsigned char *dest;\n+  size_t len;\n \n   /* To avoid lexed tokens overwriting our glued name, we can only\n      allocate from the string pool once we've lexed everything.  */\n \n-  buffer = (unsigned char *) xmalloc (capacity);\n+  dest = BUFF_FRONT (pfile->u_buff);\n   for (;;)\n     {\n       token = cpp_get_token (pfile);\n \n       if (token->type == CPP_GREATER || token->type == CPP_EOF)\n \tbreak;\n \n-      len = cpp_token_len (token);\n-      if (total_len + len > capacity)\n+      /* + 1 for terminating NUL.  */\n+      len = cpp_token_len (token) + 1;\n+      if ((size_t) (BUFF_LIMIT (pfile->u_buff) - dest) < len)\n \t{\n-\t  capacity = (capacity + len) * 2;\n-\t  buffer = (unsigned char *) xrealloc (buffer, capacity);\n+\t  size_t len_so_far = dest - BUFF_FRONT (pfile->u_buff);\n+\t  pfile->u_buff = _cpp_extend_buff (pfile, pfile->u_buff, len);\n+\t  dest = BUFF_FRONT (pfile->u_buff) + len_so_far;\n \t}\n \n       if (token->flags & PREV_WHITE)\n-\tbuffer[total_len++] = ' ';\n+\t*dest++ = ' ';\n \n-      total_len = cpp_spell_token (pfile, token, &buffer[total_len]) - buffer;\n+      dest = cpp_spell_token (pfile, token, dest);\n     }\n \n   if (token->type == CPP_EOF)\n     cpp_error (pfile, \"missing terminating > character\");\n   else\n     {\n-      token_mem = _cpp_pool_alloc (&pfile->ident_pool, total_len + 1);\n-      memcpy (token_mem, buffer, total_len);\n-      token_mem[total_len] = '\\0';\n-\n       header = _cpp_temp_token (pfile);\n       header->type = CPP_HEADER_NAME;\n-      header->flags &= ~PREV_WHITE;\n-      header->val.str.len = total_len;\n-      header->val.str.text = token_mem;\n+      header->flags = 0;\n+      header->val.str.len = dest - BUFF_FRONT (pfile->u_buff);\n+      header->val.str.text = BUFF_FRONT (pfile->u_buff);\n+      *dest++ = '\\0';\n+      BUFF_FRONT (pfile->u_buff) = dest;\n     }\n \n-  free ((PTR) buffer);\n   return header;\n }\n "}, {"sha": "7886bdf54a42e05dce7d525ff154f39f5e075623", "filename": "gcc/cppmacro.c", "status": "modified", "additions": 29, "deletions": 28, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ece54d544da404f5d0e9c5efd78ff53e9636ce36/gcc%2Fcppmacro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ece54d544da404f5d0e9c5efd78ff53e9636ce36/gcc%2Fcppmacro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppmacro.c?ref=ece54d544da404f5d0e9c5efd78ff53e9636ce36", "patch": "@@ -116,7 +116,7 @@ new_number_token (pfile, number)\n      int number;\n {\n   cpp_token *token = _cpp_temp_token (pfile);\n-  unsigned char *buf = _cpp_pool_alloc (&pfile->ident_pool, 20);\n+  unsigned char *buf = _cpp_unaligned_alloc (pfile, 20);\n \n   sprintf ((char *) buf, \"%d\", number);\n   token->type = CPP_NUMBER;\n@@ -158,7 +158,7 @@ builtin_macro (pfile, node)\n \n \tname = map->to_file;\n \tlen = strlen (name);\n-\tbuf = _cpp_pool_alloc (&pfile->ident_pool, len * 4 + 1);\n+\tbuf = _cpp_unaligned_alloc (pfile, len * 4 + 1);\n \tlen = quote_string (buf, (const unsigned char *) name, len) - buf;\n \n \treturn new_string_token (pfile, buf, len);\n@@ -196,15 +196,15 @@ builtin_macro (pfile, node)\n \t  struct tm *tb = localtime (&tt);\n \n \t  pfile->date.val.str.text =\n-\t    _cpp_pool_alloc (&pfile->ident_pool, sizeof (\"Oct 11 1347\"));\n+\t    _cpp_unaligned_alloc (pfile, sizeof (\"Oct 11 1347\"));\n \t  pfile->date.val.str.len = sizeof (\"Oct 11 1347\") - 1;\n \t  pfile->date.type = CPP_STRING;\n \t  pfile->date.flags = 0;\n \t  sprintf ((char *) pfile->date.val.str.text, \"%s %2d %4d\",\n \t\t   monthnames[tb->tm_mon], tb->tm_mday, tb->tm_year + 1900);\n \n \t  pfile->time.val.str.text =\n-\t    _cpp_pool_alloc (&pfile->ident_pool, sizeof (\"12:34:56\"));\n+\t    _cpp_unaligned_alloc (pfile, sizeof (\"12:34:56\"));\n \t  pfile->time.val.str.len = sizeof (\"12:34:56\") - 1;\n \t  pfile->time.type = CPP_STRING;\n \t  pfile->time.flags = 0;\n@@ -255,17 +255,15 @@ stringify_arg (pfile, arg)\n      cpp_reader *pfile;\n      macro_arg *arg;\n {\n-  cpp_pool *pool = &pfile->ident_pool;\n-  unsigned char *start = POOL_FRONT (pool);\n-  unsigned int i, escape_it, total_len = 0, backslash_count = 0;\n+  unsigned char *dest = BUFF_FRONT (pfile->u_buff);\n+  unsigned int i, escape_it, backslash_count = 0;\n   const cpp_token *source = NULL;\n+  size_t len;\n \n   /* Loop, reading in the argument's tokens.  */\n   for (i = 0; i < arg->count; i++)\n     {\n-      unsigned char *dest;\n       const cpp_token *token = arg->first[i];\n-      unsigned int len;\n \n       if (token->type == CPP_PADDING)\n \t{\n@@ -277,21 +275,22 @@ stringify_arg (pfile, arg)\n       escape_it = (token->type == CPP_STRING || token->type == CPP_WSTRING\n \t\t   || token->type == CPP_CHAR || token->type == CPP_WCHAR);\n \n+      /* Room for each char being written in octal, initial space and\n+\t final NUL.  */\n       len = cpp_token_len (token);\n       if (escape_it)\n-\t/* Worst case is each char is octal.  */\n \tlen *= 4;\n-      len += 2;\t\t\t/* Room for initial space and final NUL.  */\n+      len += 2;\n \n-      dest = &start[total_len];\n-      if (dest + len > POOL_LIMIT (pool))\n+      if ((size_t) (BUFF_LIMIT (pfile->u_buff) - dest) < len)\n \t{\n-\t  _cpp_next_chunk (pool, len, (unsigned char **) &start);\n-\t  dest = &start[total_len];\n+\t  size_t len_so_far = dest - BUFF_FRONT (pfile->u_buff);\n+\t  pfile->u_buff = _cpp_extend_buff (pfile, pfile->u_buff, len);\n+\t  dest = BUFF_FRONT (pfile->u_buff) + len_so_far;\n \t}\n \n       /* Leading white space?  */\n-      if (total_len)\n+      if (dest != BUFF_FRONT (pfile->u_buff))\n \t{\n \t  if (source == NULL)\n \t    source = token;\n@@ -302,15 +301,14 @@ stringify_arg (pfile, arg)\n \n       if (escape_it)\n \t{\n-\t  unsigned char *buf = (unsigned char *) xmalloc (len);\n-\n+\t  _cpp_buff *buff = _cpp_get_buff (pfile, len);\n+\t  unsigned char *buf = BUFF_FRONT (buff);\n \t  len = cpp_spell_token (pfile, token, buf) - buf;\n \t  dest = quote_string (dest, buf, len);\n-\t  free (buf);\n+\t  _cpp_release_buff (pfile, buff);\n \t}\n       else\n \tdest = cpp_spell_token (pfile, token, dest);\n-      total_len = dest - start;\n \n       if (token->type == CPP_OTHER && token->val.c == '\\\\')\n \tbackslash_count++;\n@@ -322,12 +320,13 @@ stringify_arg (pfile, arg)\n   if (backslash_count & 1)\n     {\n       cpp_warning (pfile, \"invalid string literal, ignoring final '\\\\'\");\n-      total_len--;\n+      dest--;\n     }\n \n   /* Commit the memory, including NUL, and return the token.  */\n-  POOL_COMMIT (pool, total_len + 1);\n-  return new_string_token (pfile, start, total_len);\n+  len = dest - BUFF_FRONT (pfile->u_buff);\n+  BUFF_FRONT (pfile->u_buff) = dest + 1;\n+  return new_string_token (pfile, dest - len, len);\n }\n \n /* Try to paste two tokens.  On success, return non-zero.  In any\n@@ -447,7 +446,7 @@ collect_args (pfile, node)\n   base_buff = buff;\n   args = (macro_arg *) buff->base;\n   memset (args, 0, argc * sizeof (macro_arg));\n-  buff->cur = (char *) &args[argc];\n+  buff->cur = (unsigned char *) &args[argc];\n   arg = args, argc = 0;\n \n   /* Collect the tokens making up each argument.  We don't yet know\n@@ -464,7 +463,7 @@ collect_args (pfile, node)\n       for (;;)\n \t{\n \t  /* Require space for 2 new tokens (including a CPP_EOF).  */\n-\t  if ((char *) &arg->first[ntokens + 2] > buff->limit)\n+\t  if ((unsigned char *) &arg->first[ntokens + 2] > buff->limit)\n \t    {\n \t      buff = _cpp_extend_buff (pfile, buff,\n \t\t\t\t       1000 * sizeof (cpp_token *));\n@@ -512,7 +511,7 @@ collect_args (pfile, node)\n \t overwrite the final legitimate argument, before failing.  */\n       if (argc <= macro->paramc)\n \t{\n-\t  buff->cur = (char *) &arg->first[ntokens + 1];\n+\t  buff->cur = (unsigned char *) &arg->first[ntokens + 1];\n \t  if (argc != macro->paramc)\n \t    arg++;\n \t}\n@@ -538,10 +537,12 @@ collect_args (pfile, node)\n \t  step_back = true;\n \t}\n       else\n-\t/* We still need the CPP_EOF to end directives, and to end\n-           pre-expansion of a macro argument.  */\n \tstep_back = (pfile->context->prev || pfile->state.in_directive);\n \n+      /* We still need the CPP_EOF to end directives, and to end\n+\t pre-expansion of a macro argument.  Step back is not\n+\t unconditional, since we don't want to return a CPP_EOF to our\n+\t callers at the end of an -include-d file.  */\n       if (step_back)\n \t_cpp_backup_tokens (pfile, 1);\n       cpp_error (pfile, \"unterminated argument list invoking macro \\\"%s\\\"\","}]}