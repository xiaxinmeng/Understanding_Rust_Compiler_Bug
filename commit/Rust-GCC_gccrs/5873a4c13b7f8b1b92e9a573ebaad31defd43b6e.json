{"sha": "5873a4c13b7f8b1b92e9a573ebaad31defd43b6e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTg3M2E0YzEzYjdmOGIxYjkyZTlhNTczZWJhYWQzMWRlZmQ0M2I2ZQ==", "commit": {"author": {"name": "Nicola Pero", "email": "n.pero@mi.flashnet.it", "date": "2002-09-06T15:43:46Z"}, "committer": {"name": "Nicola Pero", "email": "nicola@gcc.gnu.org", "date": "2002-09-06T15:43:46Z"}, "message": "Compile ObjC @protocols into list of ObjC statically allocated instances,\n\nfixing long standing problems with standalone @protocols in ObjC files\n\nFrom-SVN: r56887", "tree": {"sha": "7abb30c6567ea1c257e0c973bbb714b59a016392", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7abb30c6567ea1c257e0c973bbb714b59a016392"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5873a4c13b7f8b1b92e9a573ebaad31defd43b6e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5873a4c13b7f8b1b92e9a573ebaad31defd43b6e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5873a4c13b7f8b1b92e9a573ebaad31defd43b6e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5873a4c13b7f8b1b92e9a573ebaad31defd43b6e/comments", "author": null, "committer": null, "parents": [{"sha": "22d4398d6d31aa7a83b687df3eff7eb14cd3e4f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22d4398d6d31aa7a83b687df3eff7eb14cd3e4f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/22d4398d6d31aa7a83b687df3eff7eb14cd3e4f0"}], "stats": {"total": 96, "additions": 95, "deletions": 1}, "files": [{"sha": "47fa60929d5e352afbb3c1a095d02df2875212db", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5873a4c13b7f8b1b92e9a573ebaad31defd43b6e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5873a4c13b7f8b1b92e9a573ebaad31defd43b6e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5873a4c13b7f8b1b92e9a573ebaad31defd43b6e", "patch": "@@ -1,3 +1,14 @@\n+Fri Sep  6 16:35:32 2002  Nicola Pero  <n.pero@mi.flashnet.it>\n+\n+\tFix PR/1727 and long-standing failing testcase\n+\tobjc/formal-protocol-6.m.\n+\t* objc-act.c (build_protocol_expr): If compiling for the GNU\n+\truntime, create a list of Protocol statically allocated instances\n+\tif it doesn't exist, then add the Protocol object to this same\n+\tlist.\n+\t(get_objc_string_decl): Fixed typo/bug - TREE_VALUE had been used\n+\tinstead of TREE_CHAIN.\n+\n Fri Sep  6 16:17:33 2002  Nicola Pero  <n.pero@mi.flashnet.it>\n \n \t* objc/objc-act.c (dump_interface): Enlarged the char * buffer to"}, {"sha": "6b4d76c2ec1d8bb8e05c2a4098494092280b607a", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 84, "deletions": 1, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5873a4c13b7f8b1b92e9a573ebaad31defd43b6e/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5873a4c13b7f8b1b92e9a573ebaad31defd43b6e/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=5873a4c13b7f8b1b92e9a573ebaad31defd43b6e", "patch": "@@ -1679,7 +1679,7 @@ get_objc_string_decl (ident, section)\n   else\n     abort ();\n \n-  for (; chain != 0; chain = TREE_VALUE (chain))\n+  for (; chain != 0; chain = TREE_CHAIN (chain))\n     if (TREE_VALUE (chain) == ident)\n       return (TREE_PURPOSE (chain));\n \n@@ -2867,6 +2867,43 @@ generate_protocol_references (plist)\n     }\n }\n \n+/* For each protocol which was referenced either from a @protocol()\n+   expression, or because a class/category implements it (then a\n+   pointer to the protocol is stored in the struct describing the\n+   class/category), we create a statically allocated instance of the\n+   Protocol class.  The code is written in such a way as to generate\n+   as few Protocol objects as possible; we generate a unique Protocol\n+   instance for each protocol, and we don't generate a Protocol\n+   instance if the protocol is never referenced (either from a\n+   @protocol() or from a class/category implementation).  These\n+   statically allocated objects can be referred to via the static\n+   (that is, private to this module) symbols _OBJC_PROTOCOL_n.\n+   \n+   The statically allocated Protocol objects that we generate here\n+   need to be fixed up at runtime in order to be used: the 'isa'\n+  pointer of the objects need to be set up to point to the 'Protocol'\n+   class, as known at runtime.\n+\n+   The NeXT runtime fixes up all protocols at program startup time,\n+   before main() is entered.  It uses a low-level trick to look up all\n+   those symbols, then loops on them and fixes them up.\n+\n+   The GNU runtime as well fixes up all protocols before user code\n+   from the module is executed; it requires pointers to those symbols\n+   to be put in the objc_symtab (which is then passed as argument to\n+   the function __objc_exec_class() which the compiler sets up to be\n+   executed automatically when the module is loaded); setup of those\n+   Protocol objects happen in two ways in the GNU runtime: all\n+   Protocol objects referred to by a class or category implementation\n+   are fixed up when the class/category is loaded; all Protocol\n+   objects referred to by a @protocol() expression are added by the\n+   compiler to the list of statically allocated instances to fixup\n+   (the same list holding the statically allocated constant string\n+   objects).  Because, as explained above, the compiler generates as\n+   few Protocol objects as possible, some Protocol object might end up\n+   being referenced multiple times when compiled with the GNU runtime,\n+   and end up being fixed up multiple times at runtime inizialization.\n+   But that doesn't hurt, it's just a little inefficient.  */\n static void\n generate_protocols ()\n {\n@@ -5081,6 +5118,8 @@ build_protocol_reference (p)\n   PROTOCOL_FORWARD_DECL (p) = decl;\n }\n \n+/* This function is called by the parser when (and only when) a\n+   @protocol() expression is found, in order to compile it.  */\n tree\n build_protocol_expr (protoname)\n      tree protoname;\n@@ -5102,6 +5141,50 @@ build_protocol_expr (protoname)\n \n   TREE_TYPE (expr) = protocol_type;\n \n+  /* The @protocol() expression is being compiled into a pointer to a\n+     statically allocated instance of the Protocol class.  To become\n+     usable at runtime, the 'isa' pointer of the instance need to be\n+     fixed up at runtime by the runtime library, to point to the\n+     actual 'Protocol' class.  */\n+\n+  /* For the GNU runtime, put the static Protocol instance in the list\n+     of statically allocated instances, so that we make sure that its\n+     'isa' pointer is fixed up at runtime by the GNU runtime library\n+     to point to the Protocol class (at runtime, when loading the\n+     module, the GNU runtime library loops on the statically allocated\n+     instances (as found in the defs field in objc_symtab) and fixups\n+     all the 'isa' pointers of those objects).  */\n+  if (! flag_next_runtime)\n+    {\n+      /* This type is a struct containing the fields of a Protocol\n+        object.  (Cfr. protocol_type instead is the type of a pointer\n+        to such a struct).  */\n+      tree protocol_struct_type = xref_tag \n+       (RECORD_TYPE, get_identifier (PROTOCOL_OBJECT_CLASS_NAME));\n+      tree *chain;\n+      \n+      /* Look for the list of Protocol statically allocated instances\n+        to fixup at runtime.  Create a new list to hold Protocol\n+        statically allocated instances, if the list is not found.  At\n+        present there is only another list, holding NSConstantString\n+        static instances to be fixed up at runtime.  */\n+      for (chain = &objc_static_instances;\n+\t   *chain && TREE_VALUE (*chain) != protocol_struct_type;\n+\t   chain = &TREE_CHAIN (*chain));\n+      if (!*chain)\n+\t{\n+         *chain = tree_cons (NULL_TREE, protocol_struct_type, NULL_TREE);\n+         add_objc_string (TYPE_NAME (protocol_struct_type),\n+                          class_names);\n+       }\n+      \n+      /* Add this statically allocated instance to the Protocol list.  */\n+      TREE_PURPOSE (*chain) = tree_cons (NULL_TREE, \n+\t\t\t\t\t PROTOCOL_FORWARD_DECL (p),\n+\t\t\t\t\t TREE_PURPOSE (*chain));\n+    }\n+  \n+\n   return expr;\n }\n "}]}