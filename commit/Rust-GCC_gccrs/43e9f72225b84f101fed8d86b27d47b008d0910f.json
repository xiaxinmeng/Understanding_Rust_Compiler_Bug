{"sha": "43e9f72225b84f101fed8d86b27d47b008d0910f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDNlOWY3MjIyNWI4NGYxMDFmZWQ4ZDg2YjI3ZDQ3YjAwOGQwOTEwZg==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2014-10-29T18:21:59Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2014-10-29T18:21:59Z"}, "message": "Add <experimental/algorithm> and <experimental/functional>.\n\n\t* doc/xml/manual/status_cxx2014.xml: Update TS status.\n\t* include/Makefile.am: Add new headers.\n\t* include/Makefile.in: Regenerate.\n\t* include/experimental/algorithm: New.\n\t* include/experimental/functional: New.\n\t* testsuite/experimental/algorithm/sample.cc: New.\n\t* testsuite/experimental/algorithm/search.cc: New.\n\t* testsuite/experimental/functional/not_fn.cc: New.\n\t* testsuite/experimental/functional/searchers.cc: New.\n\t* testsuite/experimental/functional/value.cc: New.\n\t* testsuite/experimental/feat-lib-fund.cc: Add headers and reorder.\n\nFrom-SVN: r216847", "tree": {"sha": "05d478dc562d3eb657d1a38d40af80b8e8120b84", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/05d478dc562d3eb657d1a38d40af80b8e8120b84"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/43e9f72225b84f101fed8d86b27d47b008d0910f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43e9f72225b84f101fed8d86b27d47b008d0910f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/43e9f72225b84f101fed8d86b27d47b008d0910f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43e9f72225b84f101fed8d86b27d47b008d0910f/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "86fea2cb8b5dfc36eb9dd3f391fe5dd95836e69e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86fea2cb8b5dfc36eb9dd3f391fe5dd95836e69e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/86fea2cb8b5dfc36eb9dd3f391fe5dd95836e69e"}], "stats": {"total": 1020, "additions": 1005, "deletions": 15}, "files": [{"sha": "78ffe5ec764cd0e49ef866a8e8aef6edc3246f18", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43e9f72225b84f101fed8d86b27d47b008d0910f/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43e9f72225b84f101fed8d86b27d47b008d0910f/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=43e9f72225b84f101fed8d86b27d47b008d0910f", "patch": "@@ -1,3 +1,17 @@\n+2014-10-29  Jonathan Wakely  <jwakely@redhat.com>\n+\n+\t* doc/xml/manual/status_cxx2014.xml: Update TS status.\n+\t* include/Makefile.am: Add new headers.\n+\t* include/Makefile.in: Regenerate.\n+\t* include/experimental/algorithm: New.\n+\t* include/experimental/functional: New.\n+\t* testsuite/experimental/algorithm/sample.cc: New.\n+\t* testsuite/experimental/algorithm/search.cc: New.\n+\t* testsuite/experimental/functional/not_fn.cc: New.\n+\t* testsuite/experimental/functional/searchers.cc: New.\n+\t* testsuite/experimental/functional/value.cc: New.\n+\t* testsuite/experimental/feat-lib-fund.cc: Add headers and reorder.\n+\n 2014-10-25  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n \n \t* doc/xml/manual/status_cxx2011.xml: Update unordered container"}, {"sha": "f7d18a2a340d75719d4b329ab0989ae6b6733af2", "filename": "libstdc++-v3/doc/xml/manual/status_cxx2014.xml", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43e9f72225b84f101fed8d86b27d47b008d0910f/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fstatus_cxx2014.xml", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43e9f72225b84f101fed8d86b27d47b008d0910f/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fstatus_cxx2014.xml", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fstatus_cxx2014.xml?ref=43e9f72225b84f101fed8d86b27d47b008d0910f", "patch": "@@ -329,14 +329,13 @@ not in any particular release.\n     </row>\n \n     <row>\n-      <?dbhtml bgcolor=\"#C8B0B0\" ?>\n       <entry>\n \t<link xmlns:xlink=\"http://www.w3.org/1999/xlink\" xlink:href=\"\">\n \t  N3905\n \t</link>\n       </entry>\n       <entry>Faster string searching (Boyer-Moore et al.)</entry>\n-      <entry>N</entry>\n+      <entry>Y</entry>\n       <entry>Library Fundamentals TS</entry>\n     </row>\n \n@@ -387,14 +386,13 @@ not in any particular release.\n     </row>\n \n     <row>\n-      <?dbhtml bgcolor=\"#C8B0B0\" ?>\n       <entry>\n \t<link xmlns:xlink=\"http://www.w3.org/1999/xlink\" xlink:href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3925.pdf\">\n \t  N3925\n \t</link>\n       </entry>\n       <entry>A sample proposal</entry>\n-      <entry>N</entry>\n+      <entry>Y</entry>\n       <entry>Library Fundamentals TS</entry>\n     </row>\n "}, {"sha": "5fa243b96f449277934aad236c7e4e383861c001", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43e9f72225b84f101fed8d86b27d47b008d0910f/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43e9f72225b84f101fed8d86b27d47b008d0910f/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=43e9f72225b84f101fed8d86b27d47b008d0910f", "patch": "@@ -639,8 +639,10 @@ decimal_headers = \\\n experimental_srcdir = ${glibcxx_srcdir}/include/experimental\n experimental_builddir = ./experimental\n experimental_headers = \\\n+\t${experimental_srcdir}/algorithm \\\n \t${experimental_srcdir}/any \\\n \t${experimental_srcdir}/chrono \\\n+\t${experimental_srcdir}/functional \\\n \t${experimental_srcdir}/optional \\\n \t${experimental_srcdir}/ratio \\\n \t${experimental_srcdir}/string_view \\"}, {"sha": "4ae4e41f3acf03f05415583aee037cbd5bab0654", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43e9f72225b84f101fed8d86b27d47b008d0910f/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43e9f72225b84f101fed8d86b27d47b008d0910f/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=43e9f72225b84f101fed8d86b27d47b008d0910f", "patch": "@@ -905,8 +905,10 @@ decimal_headers = \\\n experimental_srcdir = ${glibcxx_srcdir}/include/experimental\n experimental_builddir = ./experimental\n experimental_headers = \\\n+\t${experimental_srcdir}/algorithm \\\n \t${experimental_srcdir}/any \\\n \t${experimental_srcdir}/chrono \\\n+\t${experimental_srcdir}/functional \\\n \t${experimental_srcdir}/optional \\\n \t${experimental_srcdir}/ratio \\\n \t${experimental_srcdir}/string_view \\"}, {"sha": "3d669b048cc5dd2ccd7c95444e04e518166f4194", "filename": "libstdc++-v3/include/experimental/algorithm", "status": "added", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43e9f72225b84f101fed8d86b27d47b008d0910f/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Falgorithm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43e9f72225b84f101fed8d86b27d47b008d0910f/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Falgorithm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Falgorithm?ref=43e9f72225b84f101fed8d86b27d47b008d0910f", "patch": "@@ -0,0 +1,137 @@\n+// <experimental/algorithm> -*- C++ -*-\n+\n+// Copyright (C) 2014 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/** @file experimental/algorithm\n+ *  This is a TS C++ Library header.\n+ */\n+\n+#ifndef _GLIBCXX_EXPERIMENTAL_ALGORITHM\n+#define _GLIBCXX_EXPERIMENTAL_ALGORITHM 1\n+\n+#pragma GCC system_header\n+\n+#if __cplusplus <= 201103L\n+# include <bits/c++14_warning.h>\n+#else\n+\n+#include <algorithm>\n+#include <random>\n+\n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+namespace experimental\n+{\n+inline namespace fundamentals_v1\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+  template<typename _ForwardIterator, typename _Searcher>\n+    inline _ForwardIterator\n+    search(_ForwardIterator __first, _ForwardIterator __last,\n+\t   const _Searcher& __searcher)\n+    { return __searcher(__first, __last); }\n+\n+#define __cpp_lib_experimental_sample 201402\n+\n+  /// Reservoir sampling algorithm.\n+  template<typename _InputIterator, typename _RandomAccessIterator,\n+           typename _Size, typename _UniformRandomNumberGenerator>\n+    _RandomAccessIterator\n+    __sample(_InputIterator __first, _InputIterator __last, input_iterator_tag,\n+\t     _RandomAccessIterator __out, random_access_iterator_tag,\n+\t     _Size __n, _UniformRandomNumberGenerator&& __g)\n+    {\n+      using __distrib_type = std::uniform_int_distribution<_Size>;\n+      using __param_type = typename __distrib_type::param_type;\n+      __distrib_type __d{};\n+      _Size __sample_sz = 0;\n+      while (__first != __last && __sample_sz != __n)\n+\t__out[__sample_sz++] = *__first++;\n+      for (auto __pop_sz = __sample_sz; __first != __last;\n+\t  ++__first, ++__pop_sz)\n+\t{\n+\t  const auto __k = __d(__g, __param_type{0, __pop_sz});\n+\t  if (__k < __n)\n+\t    __out[__k] = *__first;\n+\t}\n+      return __out + __sample_sz;\n+    }\n+\n+  /// Selection sampling algorithm.\n+  template<typename _ForwardIterator, typename _OutputIterator, typename _Cat,\n+           typename _Size, typename _UniformRandomNumberGenerator>\n+    _OutputIterator\n+    __sample(_ForwardIterator __first, _ForwardIterator __last,\n+\t     forward_iterator_tag,\n+\t     _OutputIterator __out, _Cat,\n+\t     _Size __n, _UniformRandomNumberGenerator&& __g)\n+    {\n+      using __distrib_type = std::uniform_int_distribution<_Size>;\n+      using __param_type = typename __distrib_type::param_type;\n+      __distrib_type __d{};\n+      _Size __unsampled_sz = std::distance(__first, __last);\n+      for (__n = std::min(__n, __unsampled_sz); __n != 0; ++__first)\n+\tif (__d(__g, __param_type{0, --__unsampled_sz}) < __n)\n+\t  {\n+\t    *__out++ = *__first;\n+\t    --__n;\n+\t  }\n+      return __out;\n+    }\n+\n+  /// Take a random sample from a population.\n+  template<typename _PopulationIterator, typename _SampleIterator,\n+           typename _Distance, typename _UniformRandomNumberGenerator>\n+    _SampleIterator\n+    sample(_PopulationIterator __first, _PopulationIterator __last,\n+\t   _SampleIterator __out, _Distance __n,\n+\t   _UniformRandomNumberGenerator&& __g)\n+    {\n+      using __pop_cat = typename\n+\tstd::iterator_traits<_PopulationIterator>::iterator_category;\n+      using __samp_cat = typename\n+\tstd::iterator_traits<_SampleIterator>::iterator_category;\n+\n+      static_assert(\n+\t  __or_<is_convertible<__pop_cat, forward_iterator_tag>,\n+\t\tis_convertible<__samp_cat, random_access_iterator_tag>>::value,\n+\t  \"output range must use a RandomAccessIterator when input range\"\n+\t  \" does not meet the ForwardIterator requirements\");\n+\n+      static_assert(is_integral<_Distance>::value,\n+\t\t    \"sample size must be an integer type\");\n+\n+      return std::experimental::__sample(\n+\t  __first, __last, __pop_cat{}, __out, __samp_cat{},\n+\t  __n, std::forward<_UniformRandomNumberGenerator>(__g));\n+    }\n+\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace fundamentals_v1\n+} // namespace experimental\n+} // namespace std\n+\n+#endif // C++14\n+\n+#endif // _GLIBCXX_EXPERIMENTAL_ALGORITHM"}, {"sha": "4ecc6a5fb6d6fecc17da353f78600ebd45b13bb5", "filename": "libstdc++-v3/include/experimental/functional", "status": "added", "additions": 428, "deletions": 0, "changes": 428, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43e9f72225b84f101fed8d86b27d47b008d0910f/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Ffunctional", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43e9f72225b84f101fed8d86b27d47b008d0910f/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Ffunctional", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Ffunctional?ref=43e9f72225b84f101fed8d86b27d47b008d0910f", "patch": "@@ -0,0 +1,428 @@\n+// <experimental/functional> -*- C++ -*-\n+\n+// Copyright (C) 2014 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/** @file experimental/functional\n+ *  This is a TS C++ Library header.\n+ */\n+\n+#ifndef _GLIBCXX_EXPERIMENTAL_FUNCTIONAL\n+#define _GLIBCXX_EXPERIMENTAL_FUNCTIONAL 1\n+\n+#pragma GCC system_header\n+\n+#if __cplusplus <= 201103L\n+# include <bits/c++14_warning.h>\n+#else\n+\n+#include <functional>\n+#include <tuple>\n+#include <iterator>\n+#include <unordered_map>\n+#include <vector>\n+#include <array>\n+#include <bits/stl_algo.h>\n+\n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+namespace experimental\n+{\n+inline namespace fundamentals_v1\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+  // See C++14 \u00a720.9.9, Function object binders\n+\n+  /// Variable template for std::is_bind_expression\n+  template<typename _Tp>\n+    constexpr bool is_bind_expression_v = std::is_bind_expression<_Tp>::value;\n+\n+  /// Variable template for std::is_placeholder\n+  template<typename _Tp>\n+    constexpr int is_placeholder_v = std::is_placeholder<_Tp>::value;\n+\n+#define __cpp_lib_experimental_boyer_moore_searching 201402\n+\n+  // Searchers\n+\n+  template<typename _ForwardIterator1, typename _BinaryPredicate = equal_to<>>\n+    class default_searcher\n+    {\n+    public:\n+      default_searcher(_ForwardIterator1 __pat_first,\n+\t\t       _ForwardIterator1 __pat_last,\n+\t\t       _BinaryPredicate __pred = _BinaryPredicate())\n+      : _M_m(__pat_first, __pat_last, std::move(__pred))\n+      { }\n+\n+      template<typename _ForwardIterator2>\n+\t_ForwardIterator2\n+\toperator()(_ForwardIterator2 __first, _ForwardIterator2 __last) const\n+\t{\n+\t  return std::search(__first, __last,\n+\t\t\t     std::get<0>(_M_m), std::get<1>(_M_m),\n+\t\t\t     std::get<2>(_M_m));\n+\t}\n+\n+    private:\n+      std::tuple<_ForwardIterator1, _ForwardIterator1, _BinaryPredicate> _M_m;\n+    };\n+\n+  template<typename _Key, typename _Tp, typename _Hash, typename _Pred>\n+    struct __boyer_moore_map_base\n+    {\n+      template<typename _RAIter>\n+\t__boyer_moore_map_base(_RAIter __pat, size_t __patlen,\n+\t\t\t       _Hash&& __hf, _Pred&& __pred)\n+\t: _M_bad_char{ __patlen, std::move(__hf), std::move(__pred) }\n+\t{\n+\t  if (__patlen > 0)\n+\t    for (__diff_type __i = 0; __i < __patlen - 1; ++__i)\n+\t      _M_bad_char[__pat[__i]] = __patlen - 1 - __i;\n+\t}\n+\n+      using __diff_type = _Tp;\n+\n+      __diff_type\n+      _M_lookup(_Key __key, __diff_type __not_found) const\n+      {\n+\tauto __iter = _M_bad_char.find(__key);\n+\tif (__iter == _M_bad_char.end())\n+\t  return __not_found;\n+\treturn __iter->second;\n+      }\n+\n+      _Pred\n+      _M_pred() const { return _M_bad_char.key_eq(); }\n+\n+      std::unordered_map<_Key, _Tp, _Hash, _Pred> _M_bad_char;\n+    };\n+\n+  template<typename _Tp, size_t _Len, typename _Pred>\n+    struct __boyer_moore_array_base\n+    {\n+      template<typename _RAIter, typename _Unused>\n+\t__boyer_moore_array_base(_RAIter __pat, size_t __patlen,\n+\t\t\t\t _Unused&&, _Pred&& __pred)\n+\t: _M_bad_char{ {}, std::move(__pred) }\n+\t{\n+\t  std::get<0>(_M_bad_char).fill(__patlen);\n+\t  if (__patlen > 0)\n+\t    for (__diff_type __i = 0; __i < __patlen - 1; ++__i)\n+\t      {\n+\t\tauto __ch = __pat[__i];\n+\t\tusing _UCh = std::make_unsigned_t<decltype(__ch)>;\n+\t\tauto __uch = static_cast<_UCh>(__ch);\n+\t\tstd::get<0>(_M_bad_char)[__uch] = __patlen - 1 - __i;\n+\t      }\n+\t}\n+\n+      using __diff_type = _Tp;\n+\n+      template<typename _Key>\n+\t__diff_type\n+\t_M_lookup(_Key __key, __diff_type __not_found) const\n+\t{\n+\t  auto __ukey = static_cast<std::make_unsigned_t<_Key>>(__key);\n+\t  if (__ukey >= _Len)\n+\t    return __not_found;\n+\t  return std::get<0>(_M_bad_char)[__ukey];\n+\t}\n+\n+      const _Pred&\n+      _M_pred() const { return std::get<1>(_M_bad_char); }\n+\n+      std::tuple<std::array<_Tp, _Len>, _Pred> _M_bad_char;\n+    };\n+\n+  template<typename _Pred>\n+    struct __is_std_equal_to : std::false_type { };\n+\n+  template<>\n+    struct __is_std_equal_to<std::equal_to<void>> : std::true_type { };\n+\n+  // Use __boyer_moore_array_base when pattern consists of narrow characters\n+  // and uses std::equal_to as the predicate.\n+  template<typename _RAIter, typename _Hash, typename _Pred,\n+           typename _Val = typename iterator_traits<_RAIter>::value_type,\n+\t   typename _Diff = typename iterator_traits<_RAIter>::difference_type>\n+    using __boyer_moore_base_t\n+      = std::conditional_t<sizeof(_Val) == 1 && is_integral<_Val>::value\n+\t\t\t   && __is_std_equal_to<_Pred>::value,\n+\t\t\t   __boyer_moore_array_base<_Diff, 256, _Pred>,\n+\t\t\t   __boyer_moore_map_base<_Val, _Diff, _Hash, _Pred>>;\n+\n+  template<typename _RAIter, typename _Hash\n+\t     = std::hash<typename std::iterator_traits<_RAIter>::value_type>,\n+\t   typename _BinaryPredicate = std::equal_to<>>\n+    class boyer_moore_searcher\n+    : __boyer_moore_base_t<_RAIter, _Hash, _BinaryPredicate>\n+    {\n+      using _Base = __boyer_moore_base_t<_RAIter, _Hash, _BinaryPredicate>;\n+      using typename _Base::__diff_type;\n+\n+    public:\n+      boyer_moore_searcher(_RAIter __pat_first, _RAIter __pat_last,\n+\t\t\t   _Hash __hf = _Hash(),\n+\t\t\t   _BinaryPredicate __pred = _BinaryPredicate());\n+\n+      template<typename _RandomAccessIterator2>\n+\t_RandomAccessIterator2\n+\toperator()(_RandomAccessIterator2 __first,\n+\t\t   _RandomAccessIterator2 __last) const;\n+\n+    private:\n+      bool\n+      _M_is_prefix(_RAIter __word, __diff_type __len,\n+\t\t   __diff_type __pos)\n+      {\n+\tconst auto& __pred = this->_M_pred();\n+\t__diff_type __suffixlen = __len - __pos;\n+\tfor (__diff_type __i = 0; __i < __suffixlen; ++__i)\n+\t  if (!__pred(__word[__i], __word[__pos + __i]))\n+\t    return false;\n+\treturn true;\n+      }\n+\n+      __diff_type\n+      _M_suffix_length(_RAIter __word, __diff_type __len,\n+\t\t       __diff_type __pos)\n+      {\n+\tconst auto& __pred = this->_M_pred();\n+\t__diff_type __i = 0;\n+\twhile (__pred(__word[__pos - __i], __word[__len - 1 - __i])\n+\t       && __i < __pos)\n+\t  {\n+\t    ++__i;\n+\t  }\n+\treturn __i;\n+      }\n+\n+      template<typename _Tp>\n+\t__diff_type\n+\t_M_bad_char_shift(_Tp __c) const\n+\t{ return this->_M_lookup(__c, _M_pat_end - _M_pat); }\n+\n+      _RAIter _M_pat;\n+      _RAIter _M_pat_end;\n+      std::vector<__diff_type> _M_good_suffix;\n+    };\n+\n+  template<typename _RAIter, typename _Hash\n+\t     = std::hash<typename std::iterator_traits<_RAIter>::value_type>,\n+\t   typename _BinaryPredicate = std::equal_to<>>\n+    class boyer_moore_horspool_searcher\n+    : __boyer_moore_base_t<_RAIter, _Hash, _BinaryPredicate>\n+    {\n+      using _Base = __boyer_moore_base_t<_RAIter, _Hash, _BinaryPredicate>;\n+      using typename _Base::__diff_type;\n+\n+    public:\n+      boyer_moore_horspool_searcher(_RAIter __pat,\n+\t\t\t\t    _RAIter __pat_end,\n+\t\t\t\t    _Hash __hf = _Hash(),\n+\t\t\t\t    _BinaryPredicate __pred\n+\t\t\t\t    = _BinaryPredicate())\n+      : _Base(__pat, __pat_end - __pat, std::move(__hf), std::move(__pred)),\n+\t_M_pat(__pat), _M_pat_end(__pat_end)\n+      { }\n+\n+      template<typename _RandomAccessIterator2>\n+\t_RandomAccessIterator2\n+\toperator()(_RandomAccessIterator2 __first,\n+\t\t   _RandomAccessIterator2 __last) const\n+\t{\n+\t  const auto& __pred = this->_M_pred();\n+\t  auto __patlen = _M_pat_end - _M_pat;\n+\t  if (__patlen == 0)\n+\t    return __first;\n+\t  auto __len = __last - __first;\n+\t  while (__len >= __patlen)\n+\t    {\n+\t      for (auto __scan = __patlen - 1;\n+\t\t   __pred(__first[__scan], _M_pat[__scan]); --__scan)\n+\t\tif (__scan == 0)\n+\t\t  return __first;\n+\t      auto __shift = _M_bad_char_shift(__first[__patlen - 1]);\n+\t      __len -= __shift;\n+\t      __first += __shift;\n+\t    }\n+\t  return __last;\n+\t}\n+\n+    private:\n+      template<typename _Tp>\n+\t__diff_type\n+\t_M_bad_char_shift(_Tp __c) const\n+\t{ return this->_M_lookup(__c, _M_pat_end - _M_pat); }\n+\n+      _RAIter _M_pat;\n+      _RAIter _M_pat_end;\n+    };\n+\n+  /// Generator function for default_searcher\n+  template<typename _ForwardIterator,\n+\t   typename _BinaryPredicate = std::equal_to<>>\n+    inline default_searcher<_ForwardIterator, _BinaryPredicate>\n+    make_default_searcher(_ForwardIterator __pat_first,\n+\t\t\t  _ForwardIterator __pat_last,\n+\t\t\t  _BinaryPredicate __pred = _BinaryPredicate())\n+    { return { __pat_first, __pat_last, __pred }; }\n+\n+  /// Generator function for boyer_moore_searcher\n+  template<typename _RAIter, typename _Hash\n+\t     = std::hash<typename std::iterator_traits<_RAIter>::value_type>,\n+\t   typename _BinaryPredicate = equal_to<>>\n+    inline boyer_moore_searcher<_RAIter, _Hash, _BinaryPredicate>\n+    make_boyer_moore_searcher(_RAIter __pat_first, _RAIter __pat_last,\n+\t\t\t      _Hash __hf = _Hash(),\n+\t\t\t      _BinaryPredicate __pred = _BinaryPredicate())\n+    { return { __pat_first, __pat_last, std::move(__hf), std::move(__pred) }; }\n+\n+  /// Generator function for boyer_moore_horspool_searcher\n+  template<typename _RAIter, typename _Hash\n+\t     = std::hash<typename std::iterator_traits<_RAIter>::value_type>,\n+\t   typename _BinaryPredicate = equal_to<>>\n+    inline boyer_moore_horspool_searcher<_RAIter, _Hash, _BinaryPredicate>\n+    make_boyer_moore_horspool_searcher(_RAIter __pat_first, _RAIter __pat_last,\n+\t\t\t\t       _Hash __hf = _Hash(),\n+\t\t\t\t       _BinaryPredicate __pred\n+\t\t\t\t       = _BinaryPredicate())\n+    { return { __pat_first, __pat_last, std::move(__hf), std::move(__pred) }; }\n+\n+  template<typename _RAIter, typename _Hash, typename _BinaryPredicate>\n+    boyer_moore_searcher<_RAIter, _Hash, _BinaryPredicate>::\n+    boyer_moore_searcher(_RAIter __pat, _RAIter __pat_end,\n+\t\t\t _Hash __hf, _BinaryPredicate __pred)\n+    : _Base(__pat, __pat_end - __pat, std::move(__hf), std::move(__pred)),\n+      _M_pat(__pat), _M_pat_end(__pat_end), _M_good_suffix(__pat_end - __pat)\n+    {\n+      auto __patlen = __pat_end - __pat;\n+      if (__patlen == 0)\n+\treturn;\n+      __diff_type __last_prefix = __patlen - 1;\n+      for (__diff_type __p = __patlen - 1; __p >= 0; --__p)\n+\t{\n+\t  if (_M_is_prefix(__pat, __patlen, __p + 1))\n+\t    __last_prefix = __p + 1;\n+\t  _M_good_suffix[__p] = __last_prefix + (__patlen - 1 - __p);\n+\t}\n+      for (__diff_type __p = 0; __p < __patlen - 1; ++__p)\n+\t{\n+\t  auto __slen = _M_suffix_length(__pat, __patlen, __p);\n+\t  auto __pos = __patlen - 1 - __slen;\n+\t  if (!__pred(__pat[__p - __slen], __pat[__pos]))\n+\t    _M_good_suffix[__pos] = __patlen - 1 - __p + __slen;\n+\t}\n+    }\n+\n+  template<typename _RAIter, typename _Hash, typename _BinaryPredicate>\n+  template<typename _RandomAccessIterator2>\n+    _RandomAccessIterator2\n+    boyer_moore_searcher<_RAIter, _Hash, _BinaryPredicate>::\n+    operator()(_RandomAccessIterator2 __first,\n+\t       _RandomAccessIterator2 __last) const\n+    {\n+      auto __patlen = _M_pat_end - _M_pat;\n+      if (__patlen == 0)\n+\treturn __first;\n+      const auto& __pred = this->_M_pred();\n+      __diff_type __i = __patlen - 1;\n+      auto __stringlen = __last - __first;\n+      while (__i < __stringlen)\n+\t{\n+\t  __diff_type __j = __patlen - 1;\n+\t  while (__j >= 0 && __pred(__first[__i], _M_pat[__j]))\n+\t    {\n+\t      --__i;\n+\t      --__j;\n+\t    }\n+\t  if (__j < 0)\n+\t    return __first + __i + 1;\n+\t  __i += std::max(_M_bad_char_shift(__first[__i]),\n+\t\t\t  _M_good_suffix[__j]);\n+\t}\n+      return __last;\n+    }\n+\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace fundamentals_v1\n+\n+inline namespace fundamentals_v2\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+#define __cpp_lib_experimental_not_fn 201406\n+\n+  /// Generalized negator.\n+  template<typename _Fn>\n+    struct _Not_fn\n+    {\n+      template<typename _Fn2>\n+\texplicit\n+\t_Not_fn(_Fn2&& __fn) : _M_fn(std::forward<_Fn2>(__fn)) { }\n+\n+      _Not_fn(const _Not_fn& __fn) = default;\n+      _Not_fn(_Not_fn&& __fn) = default;\n+      _Not_fn& operator=(const _Not_fn& __fn) = default;\n+      _Not_fn& operator=(_Not_fn&& __fn) = default;\n+      ~_Not_fn() = default;\n+\n+      template<typename... _Args>\n+\tdecltype(auto)\n+\toperator()(_Args&&... __args)\n+\t{ return !_M_fn(std::forward<_Args>(__args)...); }\n+\n+      template<typename... _Args>\n+\tdecltype(auto)\n+\toperator()(_Args&&... __args) const\n+\t{ return !_M_fn(std::forward<_Args>(__args)...); }\n+\n+      template<typename... _Args>\n+\tdecltype(auto)\n+\toperator()(_Args&&... __args) volatile\n+\t{ return !_M_fn(std::forward<_Args>(__args)...); }\n+\n+      template<typename... _Args>\n+\tdecltype(auto)\n+\toperator()(_Args&&... __args) const volatile\n+\t{ return !_M_fn(std::forward<_Args>(__args)...); }\n+\n+    private:\n+      _Fn _M_fn;\n+    };\n+\n+  /// [func.not_fn] Function template not_fn\n+  template <class _Fn>\n+    inline auto\n+    not_fn(_Fn&& __fn)\n+    { return _Not_fn<std::decay_t<_Fn>>{std::forward<_Fn>(__fn)}; }\n+\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace fundamentals_v2\n+} // namespace experimental\n+} // namespace std\n+\n+#endif // C++14\n+\n+#endif // _GLIBCXX_EXPERIMENTAL_FUNCTIONAL"}, {"sha": "b1d3efecb93fccaa15537bef738e694581eea486", "filename": "libstdc++-v3/testsuite/experimental/algorithm/sample.cc", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43e9f72225b84f101fed8d86b27d47b008d0910f/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Falgorithm%2Fsample.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43e9f72225b84f101fed8d86b27d47b008d0910f/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Falgorithm%2Fsample.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Falgorithm%2Fsample.cc?ref=43e9f72225b84f101fed8d86b27d47b008d0910f", "patch": "@@ -0,0 +1,99 @@\n+// Copyright (C) 2014 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++14\" }\n+\n+#include <experimental/algorithm>\n+#include <iterator>\n+#include <sstream>\n+#include <forward_list>\n+#include <vector>\n+#include <testsuite_hooks.h>\n+\n+std::mt19937 rng;\n+\n+using std::experimental::sample;\n+using std::istream_iterator;\n+using std::ostream_iterator;\n+\n+void\n+test01()\n+{\n+  const int pop[] = { 1, 2 };\n+  int samp[10] = { };\n+\n+  // population smaller than desired sample size\n+  auto it = sample(pop, pop + 2, samp, 10, rng);\n+  VERIFY( it == samp + 2 );\n+  VERIFY( std::accumulate(samp, samp + 10, 0) == 3 );\n+}\n+\n+void\n+test02()\n+{\n+  const int pop[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 };\n+  int samp[10] = { };\n+\n+  auto it = sample(pop, std::end(pop), samp, 10, rng);\n+  VERIFY( it == samp + 10 );\n+\n+  std::sort(samp, it);\n+  auto it2 = std::unique(samp, it);\n+  VERIFY( it2 == it );\n+}\n+\n+void\n+test03()\n+{\n+  std::istringstream pop(\"0 1 2 3 4 5 6 7 8 9\");\n+  int samp[5] = { };\n+\n+  // input iterator for population\n+  auto it = sample(istream_iterator<int>{pop}, {}, samp, 5, rng);\n+  VERIFY( it == samp + 5 );\n+\n+  std::sort(samp, it);\n+  auto it2 = std::unique(samp, it);\n+  VERIFY( it2 == it );\n+}\n+\n+void\n+test04()\n+{\n+  std::forward_list<int> pop{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n+  std::stringstream samp;\n+\n+  // forward iterator for population and output iterator for result\n+  sample(pop.begin(), pop.end(), ostream_iterator<int>{samp, \" \"}, 5, rng);\n+\n+  // samp.rdbuf()->pubseekoff(0, std::ios::beg);\n+  std::vector<int> v(istream_iterator<int>{samp}, {});\n+  VERIFY( v.size() == 5 );\n+\n+  std::sort(v.begin(), v.end());\n+  auto it = std::unique(v.begin(), v.end());\n+  VERIFY( it == v.end() );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  test04();\n+}"}, {"sha": "3ec7ed1d882316e51c1042b9d88037eb010d914a", "filename": "libstdc++-v3/testsuite/experimental/algorithm/search.cc", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43e9f72225b84f101fed8d86b27d47b008d0910f/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Falgorithm%2Fsearch.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43e9f72225b84f101fed8d86b27d47b008d0910f/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Falgorithm%2Fsearch.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Falgorithm%2Fsearch.cc?ref=43e9f72225b84f101fed8d86b27d47b008d0910f", "patch": "@@ -0,0 +1,44 @@\n+// Copyright (C) 2014 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++14\" }\n+\n+#include <experimental/algorithm>\n+#include <testsuite_hooks.h>\n+\n+struct nocopy\n+{\n+  nocopy() = default;\n+  nocopy(const nocopy&) = delete;\n+  nocopy& operator=(const nocopy&) = delete;\n+\n+  int* operator()(int* f, int* l) const { return f; }\n+};\n+\n+void\n+test01()\n+{\n+  int i[] = { 1, 2 };\n+  auto res = std::experimental::search(i, i + 2, nocopy{});\n+  VERIFY( res == i );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}, {"sha": "fbc374470764134ce43890fe600430c67b2be8c4", "filename": "libstdc++-v3/testsuite/experimental/feat-lib-fund.cc", "status": "modified", "additions": 40, "deletions": 11, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43e9f72225b84f101fed8d86b27d47b008d0910f/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffeat-lib-fund.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43e9f72225b84f101fed8d86b27d47b008d0910f/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffeat-lib-fund.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffeat-lib-fund.cc?ref=43e9f72225b84f101fed8d86b27d47b008d0910f", "patch": "@@ -1,29 +1,58 @@\n // { dg-options \"-std=gnu++14\" }\n // { dg-do compile }\n \n-#include <experimental/optional>\n-#include <experimental/string_view>\n+#if !__has_include(<experimental/tuple>)\n+#  error \"<experimental/tuple>\"\n+#endif\n+\n+#if !__has_include(<experimental/type_traits>)\n+#  error \"<experimental/type_traits>\"\n+#endif\n+\n+#if !__has_include(<experimental/ratio>)\n+#  error \"<experimental/ratio>\"\n+#endif\n+\n+#if !__has_include(<experimental/chrono>)\n+#  error \"<experimental/chrono>\"\n+#endif\n+\n+#if !__has_include(<experimental/system_error>)\n+#  error \"<experimental/system_error>\"\n+#endif\n+\n+#if !__has_include(<experimental/functional>)\n+#  error \"<experimental/functional>\"\n+#endif\n \n #if !__has_include(<experimental/optional>)\n #  error \"<experimental/optional>\"\n #endif\n \n-//#if !__has_include(<experimental/net>)\n-//#  error \"<experimental/net>\"\n-//#endif\n-\n #if !__has_include(<experimental/any>)\n #  error \"<experimental/any>\"\n #endif\n \n+#if !__has_include(<experimental/string_view>)\n+#  error \"<experimental/string_view>\"\n+#endif\n+\n+//#if !__has_include(<experimental/memory>)\n+//#  error \"<experimental/memory>\"\n+//#endif\n+\n //#if !__has_include(<experimental/memory_resource>)\n //#  error \"<experimental/memory_resource>\"\n //#endif\n \n-#if !__has_include(<experimental/string_view>)\n-#  error \"<experimental/string_view>\"\n-#endif\n+//#if !__has_include(<experimental/future>)\n+//#  error \"<experimental/future>\"\n+//#endif\n \n-#if !__has_include(<experimental/tuple>)\n-#  error \"<experimental/tuple>\"\n+#if !__has_include(<experimental/algorithm>)\n+#  error \"<experimental/algorithm>\"\n #endif\n+\n+//#if !__has_include(<experimental/net>)\n+//#  error \"<experimental/net>\"\n+//#endif"}, {"sha": "d4c8ed94e9b18183bc678b51f55602bbcb9bba05", "filename": "libstdc++-v3/testsuite/experimental/functional/not_fn.cc", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43e9f72225b84f101fed8d86b27d47b008d0910f/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffunctional%2Fnot_fn.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43e9f72225b84f101fed8d86b27d47b008d0910f/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffunctional%2Fnot_fn.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffunctional%2Fnot_fn.cc?ref=43e9f72225b84f101fed8d86b27d47b008d0910f", "patch": "@@ -0,0 +1,57 @@\n+// Copyright (C) 2014 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++14\" }\n+\n+#include <experimental/functional>\n+#include <testsuite_hooks.h>\n+\n+int func(int, char) { return 0; }\n+\n+struct F\n+{\n+  bool operator()() { return false; }\n+  bool operator()() const { return true; }\n+  bool operator()(int) { return false; }\n+  bool operator()(int) volatile { return true; }\n+};\n+\n+void\n+test01()\n+{\n+  using std::experimental::not_fn;\n+\n+  auto f1 = not_fn(func);\n+  VERIFY( f1(1, '2') == true );\n+\n+  auto f2 = not_fn( [] { return true; } );\n+  VERIFY( f2() == false );\n+\n+  auto f3 = not_fn( F{} );\n+  VERIFY( f3() == true );\n+  VERIFY( f3(1) == true );\n+  const auto f4 = f3;\n+  VERIFY( f4() == false );\n+  volatile auto f5 = f3;\n+  VERIFY( f5(1) == false );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}, {"sha": "ae04f6ffee8112c9d04ccd6a829fcce5cdf69960", "filename": "libstdc++-v3/testsuite/experimental/functional/searchers.cc", "status": "added", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43e9f72225b84f101fed8d86b27d47b008d0910f/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffunctional%2Fsearchers.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43e9f72225b84f101fed8d86b27d47b008d0910f/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffunctional%2Fsearchers.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffunctional%2Fsearchers.cc?ref=43e9f72225b84f101fed8d86b27d47b008d0910f", "patch": "@@ -0,0 +1,137 @@\n+// Copyright (C) 2014 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++14\" }\n+\n+#include <experimental/functional>\n+#include <cstring>\n+#ifdef _GLIBCXX_USE_WCHAR_T\n+# include <cwchar>\n+#endif\n+#include <testsuite_hooks.h>\n+\n+using std::experimental::make_default_searcher;\n+using std::experimental::make_boyer_moore_searcher;\n+using std::experimental::make_boyer_moore_horspool_searcher;\n+\n+void\n+test01()\n+{\n+  const char s[] = { 'a', (char)-97, 'a', '\\0' };\n+  const char* needles[] = {\n+    s, \"\", \"a\", \"aa\", \"aaa\", \"ab\", \"cd\", \"abcd\", \"abcdabcd\", \"abcabcd\"\n+  };\n+  const char* haystacks[] = {\n+    s, \"\", \"a\", \"aa\", \"aaa\", \"ab\", \"cd\", \"abcd\", \"abcdabcd\", \"abcabcd\",\n+    \"aaaaaaa\", \"aabaa\", \"aaacab\", \"cdabcdab\", \"abcdabcd\", \"xyzabcdxyz\"\n+  };\n+\n+  for (auto n : needles)\n+  {\n+    auto ne = n + std::strlen(n);\n+    auto d = make_default_searcher(n, ne);\n+    auto bm = make_boyer_moore_searcher(n, ne);\n+    auto bmh = make_boyer_moore_horspool_searcher(n, ne);\n+    for (auto h : haystacks)\n+    {\n+      auto he = h + std::strlen(h);\n+      auto res = std::search(h, he, n, ne);\n+      auto d_res = d(h, he);\n+      VERIFY( d_res == res );\n+      auto bm_res = bm(h, he);\n+      VERIFY( bm_res == res );\n+      auto bmh_res = bmh(h, he);\n+      VERIFY( bmh_res == res );\n+    }\n+  }\n+}\n+\n+void\n+test02()\n+{\n+#ifdef _GLIBCXX_USE_WCHAR_T\n+  const wchar_t s[] = { L'a', (wchar_t)-97, L'a', L'\\0' };\n+  const wchar_t* needles[] = {\n+    s, L\"\", L\"a\", L\"aa\", L\"aaa\", L\"ab\", L\"cd\", L\"abcd\", L\"abcdabcd\", L\"abcabcd\"\n+  };\n+  const wchar_t* haystacks[] = {\n+    s, L\"\", L\"a\", L\"aa\", L\"aaa\", L\"ab\", L\"cd\", L\"abcd\", L\"abcdabcd\", L\"abcabcd\",\n+    L\"aaaaaaa\", L\"aabaa\", L\"aaacab\", L\"cdabcdab\", L\"abcdabcd\", L\"xyzabcdxyz\"\n+  };\n+\n+  for (auto n : needles)\n+  {\n+    auto ne = n + std::wcslen(n);\n+    auto d = make_default_searcher(n, ne);\n+    auto bm = make_boyer_moore_searcher(n, ne);\n+    auto bmh = make_boyer_moore_horspool_searcher(n, ne);\n+    for (auto h : haystacks)\n+    {\n+      auto he = h + std::wcslen(h);\n+      auto res = std::search(h, he, n, ne);\n+      auto d_res = d(h, he);\n+      VERIFY( d_res == res );\n+      auto bm_res = bm(h, he);\n+      VERIFY( bm_res == res );\n+      auto bmh_res = bmh(h, he);\n+      VERIFY( bmh_res == res );\n+    }\n+  }\n+#endif\n+}\n+\n+void\n+test03()\n+{\n+  // custom predicate\n+  struct\n+  {\n+    static unsigned char\n+    norm(unsigned char c) { return std::isalnum(c) ? c : '#'; }\n+\n+    // equality\n+    bool operator()(char l, char r) const { return norm(l) == norm(r); }\n+\n+    // hash\n+    std::size_t operator()(char c) const { return std::hash<char>{}(norm(c)); }\n+  } eq;\n+\n+  const char* needle = \" foo 123 \";\n+  const char* haystack = \"*****foo*123******\";\n+  const char* ne = needle + std::strlen(needle);\n+  const char* he = haystack + std::strlen(haystack);\n+\n+  auto d = make_default_searcher(needle, ne, eq);\n+  auto bm = make_boyer_moore_searcher(needle, ne, eq, eq);\n+  auto bmh = make_boyer_moore_horspool_searcher(needle, ne, eq, eq);\n+\n+  auto res = std::search(haystack, he, needle, ne, eq);\n+  auto d_res = d(haystack, he);\n+  VERIFY( d_res == res );\n+  auto bm_res = bm(haystack, he);\n+  VERIFY( bm_res == res );\n+  auto bmh_res = bmh(haystack, he);\n+  VERIFY( bmh_res == res );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+}"}, {"sha": "8136e7c3ac6f063b7f30a3fde29dc202b427c115", "filename": "libstdc++-v3/testsuite/experimental/functional/value.cc", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43e9f72225b84f101fed8d86b27d47b008d0910f/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffunctional%2Fvalue.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43e9f72225b84f101fed8d86b27d47b008d0910f/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffunctional%2Fvalue.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffunctional%2Fvalue.cc?ref=43e9f72225b84f101fed8d86b27d47b008d0910f", "patch": "@@ -0,0 +1,43 @@\n+// Copyright (C) 2014 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++14\" }\n+// { dg-do compile }\n+\n+#include <experimental/functional>\n+\n+// These tests are rather simple, the front-end tests already test\n+// variable templates, and the library tests for the underlying\n+// traits are more elaborate. These are just simple sanity tests.\n+\n+int f(int);\n+\n+using B = decltype(std::bind(f, std::placeholders::_1));\n+\n+static_assert(!std::experimental::is_bind_expression_v<int>\n+\t      && !std::is_bind_expression<int>::value, \"\");\n+\n+static_assert(std::experimental::is_bind_expression_v<B>\n+\t      && std::is_bind_expression<B>::value, \"\");\n+\n+using PH = decltype(std::placeholders::_1);\n+\n+static_assert(!std::experimental::is_placeholder_v<int>\n+\t      && !std::is_placeholder<int>::value, \"\");\n+\n+static_assert(std::experimental::is_placeholder_v<PH>\n+\t      && std::is_placeholder<PH>::value, \"\");"}]}