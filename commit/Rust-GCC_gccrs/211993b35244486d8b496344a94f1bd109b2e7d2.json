{"sha": "211993b35244486d8b496344a94f1bd109b2e7d2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjExOTkzYjM1MjQ0NDg2ZDhiNDk2MzQ0YTk0ZjFiZDEwOWIyZTdkMg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2012-09-21T17:48:30Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2012-09-21T17:48:30Z"}, "message": "compiler: len(<-c) is not a constant.\n\nFrom-SVN: r191616", "tree": {"sha": "62e004ec784224e59aaae5e4b46ebea79d45fd2b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/62e004ec784224e59aaae5e4b46ebea79d45fd2b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/211993b35244486d8b496344a94f1bd109b2e7d2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/211993b35244486d8b496344a94f1bd109b2e7d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/211993b35244486d8b496344a94f1bd109b2e7d2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/211993b35244486d8b496344a94f1bd109b2e7d2/comments", "author": null, "committer": null, "parents": [{"sha": "7f0919843b3218d66300278ee169bf4707dd33ea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f0919843b3218d66300278ee169bf4707dd33ea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7f0919843b3218d66300278ee169bf4707dd33ea"}], "stats": {"total": 95, "additions": 47, "deletions": 48}, "files": [{"sha": "922b7df4486c3393a4d266a32edea4b80913e557", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 47, "deletions": 48, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/211993b35244486d8b496344a94f1bd109b2e7d2/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/211993b35244486d8b496344a94f1bd109b2e7d2/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=211993b35244486d8b496344a94f1bd109b2e7d2", "patch": "@@ -6679,38 +6679,6 @@ Builtin_call_expression::do_set_recover_arg(Expression* arg)\n   this->set_args(new_args);\n }\n \n-// A traversal class which looks for a call expression.\n-\n-class Find_call_expression : public Traverse\n-{\n- public:\n-  Find_call_expression()\n-    : Traverse(traverse_expressions),\n-      found_(false)\n-  { }\n-\n-  int\n-  expression(Expression**);\n-\n-  bool\n-  found()\n-  { return this->found_; }\n-\n- private:\n-  bool found_;\n-};\n-\n-int\n-Find_call_expression::expression(Expression** pexpr)\n-{\n-  if ((*pexpr)->call_expression() != NULL)\n-    {\n-      this->found_ = true;\n-      return TRAVERSE_EXIT;\n-    }\n-  return TRAVERSE_CONTINUE;\n-}\n-\n // Lower a builtin call expression.  This turns new and make into\n // specific expressions.  We also convert to a constant if we can.\n \n@@ -6731,20 +6699,6 @@ Builtin_call_expression::do_lower(Gogo* gogo, Named_object* function,\n \n   if (this->is_constant())\n     {\n-      // We can only lower len and cap if there are no function calls\n-      // in the arguments.  Otherwise we have to make the call.\n-      if (this->code_ == BUILTIN_LEN || this->code_ == BUILTIN_CAP)\n-\t{\n-\t  Expression* arg = this->one_arg();\n-\t  if (arg != NULL && !arg->is_constant())\n-\t    {\n-\t      Find_call_expression find_call;\n-\t      Expression::traverse(&arg, &find_call);\n-\t      if (find_call.found())\n-\t\treturn this;\n-\t    }\n-\t}\n-\n       Numeric_constant nc;\n       if (this->numeric_constant_value(&nc))\n \treturn nc.expression(loc);\n@@ -7061,8 +7015,42 @@ Builtin_call_expression::one_arg() const\n   return args->front();\n }\n \n-// Return whether this is constant: len of a string, or len or cap of\n-// a fixed array, or unsafe.Sizeof, unsafe.Offsetof, unsafe.Alignof.\n+// A traversal class which looks for a call or receive expression.\n+\n+class Find_call_expression : public Traverse\n+{\n+ public:\n+  Find_call_expression()\n+    : Traverse(traverse_expressions),\n+      found_(false)\n+  { }\n+\n+  int\n+  expression(Expression**);\n+\n+  bool\n+  found()\n+  { return this->found_; }\n+\n+ private:\n+  bool found_;\n+};\n+\n+int\n+Find_call_expression::expression(Expression** pexpr)\n+{\n+  if ((*pexpr)->call_expression() != NULL\n+      || (*pexpr)->receive_expression() != NULL)\n+    {\n+      this->found_ = true;\n+      return TRAVERSE_EXIT;\n+    }\n+  return TRAVERSE_CONTINUE;\n+}\n+\n+// Return whether this is constant: len of a string constant, or len\n+// or cap of an array, or unsafe.Sizeof, unsafe.Offsetof,\n+// unsafe.Alignof.\n \n bool\n Builtin_call_expression::do_is_constant() const\n@@ -7085,6 +7073,17 @@ Builtin_call_expression::do_is_constant() const\n \t    && !arg_type->points_to()->is_slice_type())\n \t  arg_type = arg_type->points_to();\n \n+\t// The len and cap functions are only constant if there are no\n+\t// function calls or channel operations in the arguments.\n+\t// Otherwise we have to make the call.\n+\tif (!arg->is_constant())\n+\t  {\n+\t    Find_call_expression find_call;\n+\t    Expression::traverse(&arg, &find_call);\n+\t    if (find_call.found())\n+\t      return false;\n+\t  }\n+\n \tif (arg_type->array_type() != NULL\n \t    && arg_type->array_type()->length() != NULL)\n \t  return true;"}]}