{"sha": "e2f79f3c038687310e4230478fdaecfde214eee2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTJmNzlmM2MwMzg2ODczMTBlNDIzMDQ3OGZkYWVjZmRlMjE0ZWVlMg==", "commit": {"author": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1996-06-07T07:30:20Z"}, "committer": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1996-06-07T07:30:20Z"}, "message": "cpplib.c (xcalloc): From from cppalloc.c.\n\n* cpplib.c (xcalloc):  From from cppalloc.c.\n* cpplib.c (cpp_push_buffer):  If recursion too deap, return NULL\nrather than exiting with fatal.\n(make_assertion, cpp_expand_to_buffer, push_macro_expansion,\ndo_include, cpp_start_rea):  Handle NULL return from cpp_push_buffer.\n(output_line_command):  Update position even if no_output.\n        (parse_clear_mark):  Use fatal instead of abort.\n\nFrom-SVN: r12207", "tree": {"sha": "93ee504ddd260c42cde7548fae8e07ae00f94ccb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/93ee504ddd260c42cde7548fae8e07ae00f94ccb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e2f79f3c038687310e4230478fdaecfde214eee2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2f79f3c038687310e4230478fdaecfde214eee2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e2f79f3c038687310e4230478fdaecfde214eee2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2f79f3c038687310e4230478fdaecfde214eee2/comments", "author": null, "committer": null, "parents": [{"sha": "426b6fa3ab953ff01fe116eb3a29e8bb04ba0e93", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/426b6fa3ab953ff01fe116eb3a29e8bb04ba0e93", "html_url": "https://github.com/Rust-GCC/gccrs/commit/426b6fa3ab953ff01fe116eb3a29e8bb04ba0e93"}], "stats": {"total": 56, "additions": 43, "deletions": 13}, "files": [{"sha": "c66616b3f70b0c458b9e9db203b9732685d4214d", "filename": "gcc/cpplib.c", "status": "modified", "additions": 43, "deletions": 13, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2f79f3c038687310e4230478fdaecfde214eee2/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2f79f3c038687310e4230478fdaecfde214eee2/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=e2f79f3c038687310e4230478fdaecfde214eee2", "patch": "@@ -262,7 +262,9 @@ static void trigraph_pcp ();\n static int finclude ();\n static void validate_else ();\n static int comp_def_part ();\n+#ifdef abort\n extern void fancy_abort ();\n+#endif\n static void pipe_closed ();\n static void print_containing_files ();\n static int lookup_import ();\n@@ -288,7 +290,7 @@ static void push_macro_expansion PARAMS ((cpp_reader *,\n \t\t\t\t\t  U_CHAR*, int, HASHNODE*));\n static struct cpp_pending *nreverse_pending PARAMS ((struct cpp_pending*));\n extern char *xrealloc ();\n-extern char *xcalloc ();\n+static char *xcalloc ();\n static char *savestring ();\n \n static void conditional_skip ();\n@@ -605,7 +607,6 @@ make_assertion (pfile, option, str)\n      char *option;\n      U_CHAR *str;\n {\n-  cpp_buffer *ip;\n   struct directive *kt;\n   U_CHAR *buf, *p, *q;\n \n@@ -637,9 +638,11 @@ make_assertion (pfile, option, str)\n     return;\n   }\n   \n-  ip = cpp_push_buffer (pfile, buf, strlen (buf));\n-  do_assert (pfile, NULL, NULL, NULL);\n-  cpp_pop_buffer (pfile);\n+  if (cpp_push_buffer (pfile, buf, strlen (buf)) != NULL)\n+    {\n+      do_assert (pfile, NULL, NULL, NULL);\n+      cpp_pop_buffer (pfile);\n+    }\n }\n \f\n /* Append a chain of `struct file_name_list's\n@@ -950,7 +953,7 @@ cpp_skip_hspace (pfile)\n /* Read the rest of the current line.\n    The line is appended to PFILE's output buffer. */\n \n-void\n+static void\n copy_rest_of_line (pfile)\n      cpp_reader *pfile;\n {\n@@ -1864,7 +1867,11 @@ cpp_push_buffer (pfile, buffer, length)\n {\n   register cpp_buffer *buf = CPP_BUFFER (pfile);\n   if (buf == pfile->buffer_stack)\n-    fatal (\"%s: macro or `#include' recursion too deep\", buf->fname);\n+    {\n+      cpp_fatal (pfile, \"%s: macro or `#include' recursion too deep\",\n+\t\t buf->fname);\n+      return NULL;\n+    }\n   buf--;\n   bzero ((char *) buf, sizeof (cpp_buffer));\n   CPP_BUFFER (pfile) = buf;\n@@ -1946,6 +1953,8 @@ cpp_expand_to_buffer (pfile, buf, length)\n   buf1[length] = 0;\n \n   ip = cpp_push_buffer (pfile, buf1, length);\n+  if (ip == NULL)\n+    return;\n   ip->has_escapes = 1;\n #if 0\n   ip->lineno = obuf.lineno = 1;\n@@ -2067,11 +2076,15 @@ output_line_command (pfile, conditional, file_change)\n   long line, col;\n   cpp_buffer *ip = CPP_BUFFER (pfile);\n \n-  if (ip->fname == NULL || CPP_OPTIONS (pfile)->no_output) {\n+  if (ip->fname == NULL)\n     return;\n-  }\n \n   update_position (ip);\n+\n+  if (CPP_OPTIONS (pfile)->no_line_commands\n+      || CPP_OPTIONS (pfile)->no_output)\n+    return;\n+\n   line = CPP_BUFFER (pfile)->lineno;\n   col = CPP_BUFFER (pfile)->colno;\n   adjust_position (CPP_LINE_BASE (ip), ip->cur, &line, &col);\n@@ -2986,6 +2999,8 @@ push_macro_expansion (pfile, xbuf, xbuf_len, hp)\n      HASHNODE *hp;\n {\n   register cpp_buffer *mbuf = cpp_push_buffer (pfile, xbuf, xbuf_len);\n+  if (mbuf == NULL)\n+    return;\n   mbuf->cleanup = macro_cleanup;\n   mbuf->data = hp;\n \n@@ -3453,7 +3468,8 @@ do_include (pfile, keyword, unused1, unused2)\n #endif\n     \n     /* Actually process the file */\n-    cpp_push_buffer (pfile, NULL, 0);\n+    if (cpp_push_buffer (pfile, NULL, 0) == NULL)\n+      return 0;\n     if (finclude (pfile, f, fname, is_system_include (pfile, fname),\n \t\t  searchptr != dsp ? searchptr : SELF_DIR_DUMMY))\n       {\n@@ -5681,6 +5697,8 @@ cpp_start_read (pfile, fname)\n   /* Do partial setup of input buffer for the sake of generating\n      early #line directives (when -g is in effect).  */\n   fp = cpp_push_buffer (pfile, NULL, 0);\n+  if (!fp)\n+    return 0;\n   if (opts->in_fname == NULL)\n     opts->in_fname = \"\";\n   fp->nominal_fname = fp->fname = opts->in_fname;\n@@ -5945,7 +5963,8 @@ cpp_start_read (pfile, fname)\n \t      cpp_perror_with_name (pfile, pend->arg);\n \t      return 0;\n \t    }\n-\t  cpp_push_buffer (pfile, NULL, 0);\n+\t  if (!cpp_push_buffer (pfile, NULL, 0))\n+\t      return 0;\n \t  finclude (pfile, fd, pend->arg, 0, NULL_PTR);\n \t  cpp_scan_buffer (pfile);\n \t}\n@@ -6113,7 +6132,8 @@ cpp_start_read (pfile, fname)\n \t      cpp_perror_with_name (pfile, pend->arg);\n \t      return 0;\n \t    }\n-\t  cpp_push_buffer (pfile, NULL, 0);\n+\t  if (!cpp_push_buffer (pfile, NULL, 0))\n+\t    return 0;\n \t  finclude (pfile, fd, pend->arg, 0, NULL_PTR);\n \t}\n     }\n@@ -7169,6 +7189,16 @@ safe_read (desc, ptr, len)\n   return len - left;\n }\n \n+static char *\n+xcalloc (number, size)\n+     unsigned number, size;\n+{\n+  register unsigned total = number * size;\n+  register char *ptr = (char *) xmalloc (total);\n+  bzero (ptr, total);\n+  return ptr;\n+}\n+\n static char *\n savestring (input)\n      char *input;\n@@ -7199,7 +7229,7 @@ parse_clear_mark (pmark)\n {\n   struct parse_marker **pp = &pmark->buf->marks;\n   for (; ; pp = &(*pp)->next) {\n-    if (*pp == NULL) fatal (\"internal error\", \"in parse_set_mark\");\n+    if (*pp == NULL) abort ();\n     if (*pp == pmark) break;\n   }\n   *pp = pmark->next;"}]}