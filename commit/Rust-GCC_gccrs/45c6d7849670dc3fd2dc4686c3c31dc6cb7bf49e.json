{"sha": "45c6d7849670dc3fd2dc4686c3c31dc6cb7bf49e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDVjNmQ3ODQ5NjcwZGMzZmQyZGM0Njg2YzNjMzFkYzZjYjdiZjQ5ZQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2018-05-24T13:05:59Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2018-05-24T13:05:59Z"}, "message": "[Ada] Handle version 2 of Windows unwinding information structures\n\n2018-05-24  Eric Botcazou  <ebotcazou@adacore.com>\n\ngcc/ada/\n\n\t* raise-gcc.c (__gnat_SEH_error_handler): Remove prototype.\n\t(__gnat_personality_seh0): Adjust and beef up comments, and\n\tfix formatting throughout.\n\t(__gnat_adjust_context): Deal minimally with version 2.\n\t* seh_init.c (__gnat_map_SEH): Fix formatting.\n\t(_gnat_SEH_error_handler): Adjust comments.\n\t(__gnat_install_SEH_handler): Fix formatting.\n\nFrom-SVN: r260659", "tree": {"sha": "18927dc96d96e1b3480de2b1197b98748e575202", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/18927dc96d96e1b3480de2b1197b98748e575202"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/45c6d7849670dc3fd2dc4686c3c31dc6cb7bf49e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45c6d7849670dc3fd2dc4686c3c31dc6cb7bf49e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/45c6d7849670dc3fd2dc4686c3c31dc6cb7bf49e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45c6d7849670dc3fd2dc4686c3c31dc6cb7bf49e/comments", "author": null, "committer": null, "parents": [{"sha": "b6784d9087199e43c77a626b3de277bec9f08088", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6784d9087199e43c77a626b3de277bec9f08088", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b6784d9087199e43c77a626b3de277bec9f08088"}], "stats": {"total": 188, "additions": 111, "deletions": 77}, "files": [{"sha": "32e4b6a6deedada177513939cbf3b6f7a935bfed", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45c6d7849670dc3fd2dc4686c3c31dc6cb7bf49e/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45c6d7849670dc3fd2dc4686c3c31dc6cb7bf49e/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=45c6d7849670dc3fd2dc4686c3c31dc6cb7bf49e", "patch": "@@ -1,3 +1,13 @@\n+2018-05-24  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* raise-gcc.c (__gnat_SEH_error_handler): Remove prototype.\n+\t(__gnat_personality_seh0): Adjust and beef up comments, and\n+\tfix formatting throughout.\n+\t(__gnat_adjust_context): Deal minimally with version 2.\n+\t* seh_init.c (__gnat_map_SEH): Fix formatting.\n+\t(_gnat_SEH_error_handler): Adjust comments.\n+\t(__gnat_install_SEH_handler): Fix formatting.\n+\n 2018-05-24  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* exp_ch7.adb, sem_ch3.adb, sem_res.adb: Minor reformatting."}, {"sha": "7558414d5a38e81ab143fbfcc166fa3f77fde574", "filename": "gcc/ada/raise-gcc.c", "status": "modified", "additions": 50, "deletions": 31, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45c6d7849670dc3fd2dc4686c3c31dc6cb7bf49e/gcc%2Fada%2Fraise-gcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45c6d7849670dc3fd2dc4686c3c31dc6cb7bf49e/gcc%2Fada%2Fraise-gcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fraise-gcc.c?ref=45c6d7849670dc3fd2dc4686c3c31dc6cb7bf49e", "patch": "@@ -1457,9 +1457,6 @@ __gnat_Unwind_ForcedUnwind (_Unwind_Exception *e ATTRIBUTE_UNUSED,\n        (STATUS_USER_DEFINED | ((TYPE) << 24) | GCC_MAGIC)\n #define STATUS_GCC_THROW\t\tGCC_EXCEPTION (0)\n \n-EXCEPTION_DISPOSITION __gnat_SEH_error_handler\n- (struct _EXCEPTION_RECORD*, void*, struct _CONTEXT*, void*);\n-\n struct Exception_Data *\n __gnat_map_SEH (EXCEPTION_RECORD* ExceptionRecord, const char **msg);\n \n@@ -1481,22 +1478,30 @@ __gnat_create_machine_occurrence_from_signal_handler (Exception_Id,\n /* Modify the IP value saved in the machine frame.  This is really a kludge,\n    that will be removed if we could propagate the Windows exception (and not\n    the GCC one).\n+\n    What is very wrong is that the Windows unwinder will try to decode the\n-   instruction at IP, which isn't valid anymore after the adjust.  */\n+   instruction at IP, which isn't valid anymore after the adjustment.  */\n \n static void\n __gnat_adjust_context (unsigned char *unw, ULONG64 rsp)\n {\n   unsigned int len;\n \n-  /* Version = 1, no flags, no prologue.  */\n-  if (unw[0] != 1 || unw[1] != 0)\n+  /* Version 1 or 2.  */\n+  if (unw[0] != 1 && unw[0] != 2)\n+    return;\n+  /* No flags, no prologue.  */\n+  if (unw[1] != 0)\n     return;\n   len = unw[2];\n-  /* No frame pointer.  */\n+  /* No frame.  */\n   if (unw[3] != 0)\n     return;\n-  unw += 4;\n+  /* ??? Skip the first 2 undocumented opcodes for version 2.  */\n+  if (unw[0] == 2)\n+    unw += 8;\n+  else\n+    unw += 4;\n   while (len > 0)\n     {\n       /* Offset in prologue = 0.  */\n@@ -1541,9 +1546,7 @@ __gnat_personality_seh0 (PEXCEPTION_RECORD ms_exc, void *this_frame,\n \t\t\t PCONTEXT ms_orig_context,\n \t\t\t PDISPATCHER_CONTEXT ms_disp)\n {\n-  /* Possibly transform run-time errors into Ada exceptions.  As a small\n-     optimization, we call __gnat_SEH_error_handler only on non-user\n-     exceptions.  */\n+  /* Possibly transform run-time errors into Ada exceptions.  */\n   if (!(ms_exc->ExceptionCode & STATUS_USER_DEFINED))\n     {\n       struct Exception_Data *exception;\n@@ -1557,13 +1560,21 @@ __gnat_personality_seh0 (PEXCEPTION_RECORD ms_exc, void *this_frame,\n \t\t       + ms_disp->FunctionEntry->EndAddress))\n \t{\n \t  /* This is a fault in this function.  We need to adjust the return\n-\t     address before raising the GCC exception.  */\n+\t     address before raising the GCC exception.  In order to do that,\n+\t     we need to locate the machine frame that has been pushed onto\n+\t     the stack in response to the hardware exception, so we will do\n+\t     a private unwinding from here, i.e. the frame of the personality\n+\t     routine, up to the frame immediately following the frame of this\n+\t     function.  This frame corresponds to a dummy prologue which is\n+\t     never actually executed but instead appears before the real entry\n+\t     point of an interrupt routine and exists only to provide a place\n+\t     to simulate the push of a machine frame.  */\n \t  CONTEXT context;\n \t  PRUNTIME_FUNCTION mf_func = NULL;\n \t  ULONG64 mf_imagebase;\n \t  ULONG64 mf_rsp = 0;\n \n-\t  /* Get the context.  */\n+\t  /* Get the current context.  */\n \t  RtlCaptureContext (&context);\n \n \t  while (1)\n@@ -1574,27 +1585,31 @@ __gnat_personality_seh0 (PEXCEPTION_RECORD ms_exc, void *this_frame,\n \t      ULONG64 EstablisherFrame;\n \n \t      /* Get function metadata.  */\n-\t      RuntimeFunction = RtlLookupFunctionEntry\n-\t\t(context.Rip, &ImageBase, ms_disp->HistoryTable);\n+\t      RuntimeFunction\n+\t\t= RtlLookupFunctionEntry (context.Rip, &ImageBase,\n+\t\t\t\t\t  ms_disp->HistoryTable);\n+\n+\t      /* Stop once we reached the frame of this function.  */\n \t      if (RuntimeFunction == ms_disp->FunctionEntry)\n \t\tbreak;\n+\n \t      mf_func = RuntimeFunction;\n \t      mf_imagebase = ImageBase;\n \t      mf_rsp = context.Rsp;\n \n-\t      if (!RuntimeFunction)\n-\t\t{\n-\t\t  /* In case of failure, assume this is a leaf function.  */\n-\t\t  context.Rip = *(ULONG64 *) context.Rsp;\n-\t\t  context.Rsp += 8;\n-\t\t}\n-\t      else\n+\t      if (RuntimeFunction)\n \t\t{\n \t\t  /* Unwind.  */\n \t\t  RtlVirtualUnwind (0, ImageBase, context.Rip, RuntimeFunction,\n \t\t\t\t    &context, &HandlerData, &EstablisherFrame,\n \t\t\t\t    NULL);\n \t\t}\n+\t      else\n+\t\t{\n+\t\t  /* In case of failure, assume this is a leaf function.  */\n+\t\t  context.Rip = *(ULONG64 *) context.Rsp;\n+\t\t  context.Rsp += 8;\n+\t\t}\n \n \t      /* 0 means bottom of the stack.  */\n \t      if (context.Rip == 0)\n@@ -1603,6 +1618,8 @@ __gnat_personality_seh0 (PEXCEPTION_RECORD ms_exc, void *this_frame,\n \t\t  break;\n \t\t}\n \t    }\n+\n+\t  /* If we have found the machine frame, adjust the return address.  */\n \t  if (mf_func != NULL)\n \t    __gnat_adjust_context\n \t      ((unsigned char *)(mf_imagebase + mf_func->UnwindData), mf_rsp);\n@@ -1611,16 +1628,16 @@ __gnat_personality_seh0 (PEXCEPTION_RECORD ms_exc, void *this_frame,\n       exception = __gnat_map_SEH (ms_exc, &msg);\n       if (exception != NULL)\n \t{\n-\t  struct _Unwind_Exception *exc;\n+\t  /* Directly convert the system exception into a GCC one.\n \n-\t  /* Directly convert the system exception to a GCC one.\n \t     This is really breaking the API, but is necessary for stack size\n \t     reasons: the normal way is to call Raise_From_Signal_Handler,\n-\t     which build the exception and calls _Unwind_RaiseException, which\n-\t     unwinds the stack and will call this personality routine. But\n-\t     the Windows unwinder needs about 2KB of stack.  */\n-\t  exc = __gnat_create_machine_occurrence_from_signal_handler\n-\t    (exception, msg);\n+\t     which builds the exception and calls _Unwind_RaiseException,\n+\t     which unwinds the stack and will call this personality routine.\n+\t     But the Windows unwinder needs about 2KB of stack.  */\n+\t  struct _Unwind_Exception *exc\n+\t    = __gnat_create_machine_occurrence_from_signal_handler (exception,\n+\t\t\t\t\t\t\t\t    msg);\n \t  memset (exc->private_, 0, sizeof (exc->private_));\n \t  ms_exc->ExceptionCode = STATUS_GCC_THROW;\n \t  ms_exc->NumberParameters = 1;\n@@ -1629,9 +1646,11 @@ __gnat_personality_seh0 (PEXCEPTION_RECORD ms_exc, void *this_frame,\n \n     }\n \n-  return _GCC_specific_handler (ms_exc, this_frame, ms_orig_context,\n-\t\t\t\tms_disp, __gnat_personality_imp);\n+  return\n+    _GCC_specific_handler (ms_exc, this_frame, ms_orig_context, ms_disp,\n+\t\t\t   __gnat_personality_imp);\n }\n+\n #endif /* SEH */\n \n #if !defined (__USING_SJLJ_EXCEPTIONS__)"}, {"sha": "98b9e4e632711c873a4ecf0f7c229e77c7dc7b4c", "filename": "gcc/ada/seh_init.c", "status": "modified", "additions": 51, "deletions": 46, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45c6d7849670dc3fd2dc4686c3c31dc6cb7bf49e/gcc%2Fada%2Fseh_init.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45c6d7849670dc3fd2dc4686c3c31dc6cb7bf49e/gcc%2Fada%2Fseh_init.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fseh_init.c?ref=45c6d7849670dc3fd2dc4686c3c31dc6cb7bf49e", "patch": "@@ -30,7 +30,7 @@\n  ****************************************************************************/\n \n /*  This unit contains support for SEH (Structured Exception Handling).\n-    Right now the only implementation is for Win32.  */\n+    Right now the only implementation is for Win32 and Cygwin.  */\n \n #if defined (_WIN32) || (defined (__CYGWIN__) && defined (__SEH__))\n /* Include system headers, before system.h poisons malloc.  */\n@@ -64,8 +64,7 @@ extern struct Exception_Data storage_error;\n extern struct Exception_Data tasking_error;\n extern struct Exception_Data _abort_signal;\n \n-#define Raise_From_Signal_Handler \\\n-                      ada__exceptions__raise_from_signal_handler\n+#define Raise_From_Signal_Handler ada__exceptions__raise_from_signal_handler\n extern void Raise_From_Signal_Handler (struct Exception_Data *, const char *)\n   ATTRIBUTE_NORETURN;\n \n@@ -81,28 +80,27 @@ EXCEPTION_DISPOSITION __gnat_SEH_error_handler\n struct Exception_Data *\n __gnat_map_SEH (EXCEPTION_RECORD* ExceptionRecord, const char **msg);\n \n-/* Convert an SEH exception to an Ada one.  Return the exception ID\n-   and set MSG with the corresponding message.  */\n+/* Convert an SEH exception to an Ada one.  Return the exception ID and set\n+   MSG to the corresponding message.  */\n \n struct Exception_Data *\n __gnat_map_SEH (EXCEPTION_RECORD* ExceptionRecord, const char **msg)\n {\n   switch (ExceptionRecord->ExceptionCode)\n     {\n     case EXCEPTION_ACCESS_VIOLATION:\n-      /* If the failing address isn't maximally-aligned or if the page\n-\t before the faulting page is not accessible, this is a program error.\n-      */\n+      /* If the failing address isn't maximally aligned or if the page before\n+\t the faulting page is not accessible, this is a program error.  */\n       if ((ExceptionRecord->ExceptionInformation[1] & 3) != 0\n \t  || IsBadCodePtr\n-\t  ((FARPROC)(ExceptionRecord->ExceptionInformation[1] + 4096)))\n+\t     ((FARPROC)(ExceptionRecord->ExceptionInformation[1] + 4096)))\n \t{\n \t  *msg = \"EXCEPTION_ACCESS_VIOLATION\";\n \t  return &program_error;\n \t}\n       else\n \t{\n-\t  /* otherwise it is a stack overflow  */\n+\t  /* Otherwise this is a stack overflow.  */\n \t  *msg = \"stack overflow or erroneous memory access\";\n \t  return &storage_error;\n \t}\n@@ -175,6 +173,8 @@ __gnat_map_SEH (EXCEPTION_RECORD* ExceptionRecord, const char **msg)\n \n #if !(defined (_WIN64) && defined (__SEH__))\n \n+/* The \"fake\" exception handler to be associated with the .text section.  */\n+\n EXCEPTION_DISPOSITION\n __gnat_SEH_error_handler (struct _EXCEPTION_RECORD* ExceptionRecord,\n \t\t\t  void *EstablisherFrame ATTRIBUTE_UNUSED,\n@@ -192,45 +192,47 @@ __gnat_SEH_error_handler (struct _EXCEPTION_RECORD* ExceptionRecord,\n       msg = \"unhandled signal\";\n     }\n \n-#if ! defined (_WIN64)\n+#if !defined (_WIN64)\n   /* This call is important as it avoids locking the second time we catch a\n-     signal. Note that this routine is documented as internal to Windows and\n-     should not be used.  */\n-\n+     signal; it's equivalent to RtlUnwind (EstablisherFrame, NULL, NULL, 0);\n+     Note that this routine is documented as internal to Windows and should\n+     not be used.  */\n   _global_unwind2 (EstablisherFrame);\n-  /* Call equivalent to RtlUnwind (EstablisherFrame, NULL, NULL, 0); */\n #endif\n \n   Raise_From_Signal_Handler (exception, msg);\n }\n+\n #endif /* !(defined (_WIN64) && defined (__SEH__)) */\n \n #if defined (_WIN64)\n-/*  On x86_64 windows exception mechanism is no more based on a chained list\n-    of handlers addresses on the stack. Instead unwinding information is used\n-    to retrieve the exception handler (similar to ZCX GCC mechanism). So in\n-    order to register an exception handler we need to put in the final\n-    executable some unwinding information. This information might be present\n-    statically in the image file inside the .pdata section or registered\n-    through RtlAddFunctionTable API. Currently the GCC toolchain does not\n-    generate the .pdata information for each function. As we don't need to\n-    handle SEH exceptions except for signal handling we are registering a\n-    \"fake\" unwinding data that associate a SEH exception handler to the\n-    complete .text section. As we never return from the handler, the system\n-    does not try to do the final unwinding using the pdata information. The\n-    unwinding is handled by the runtime using either the GNAT SJLJ mechanism\n-    or the ZCX GCC mechanism.\n+\n+/*  On x86-64/Windows the EH mechanism is no more based on a chained list of\n+    handlers addresses on the stack.  Instead unwinding information is used\n+    to retrieve the exception handler (similar to DWARF2 unwinding).  So in\n+    order to register an exception handler, we need to put in the binary\n+    some unwinding information.  This information can be present statically\n+    in the image file inside the .pdata section or registered through the\n+    RtlAddFunctionTable API.  In the case where the GCC toolchain does not\n+    generate the .pdata information for each function, we don't really need\n+    to handle SEH exceptions except for signal handling, so we register a\n+    \"fake\" unwinding data that associates a SEH exception handler with the\n+    complete .text section.  As we never return from the handler, the system\n+    does not try to do the final unwinding using the .pdata information and\n+    the unwinding is handled by the runtime using the GNAT or GCC mechanism.\n \n     Solutions based on SetUnhandledExceptionFilter have been discarded as this\n-    function is mostly disabled on last Windows versions.\n+    function is mostly disabled on latest Windows versions.\n+\n     Using AddVectoredExceptionHandler should also be discarded as it overrides\n     all SEH exception handlers that might be present in the program itself and\n-    the loaded DLL (for example it results in unexpected behaviors in the\n-    Win32 subsystem.  */\n+    the loaded DLL; for example it results in unexpected behavior in the Win32\n+    subsystem.  */\n \n #ifndef __SEH__\n-  /* Don't use this trick when SEH are emitted by gcc, as it will conflict with\n-     them.  */\n+\n+  /* Do not use this trick when GCC generates the .pdata information, since it\n+     is not necessary and will conflict with the per-function data.  */\n asm\n (\n  \" .section .rdata, \\\"dr\\\"\\n\"\n@@ -250,19 +252,21 @@ asm\n  \"\\n\"\n  \" .text\\n\"\n );\n+\n #endif /* __SEH__ */\n \n+/* Nothing to do, the handler is either not used or statically installed by\n+   the asm statement just above.  */\n void __gnat_install_SEH_handler (void *eh ATTRIBUTE_UNUSED)\n {\n-  /* Nothing to do, the handler is statically installed by the asm statement\n-     just above.  */\n }\n \n #else /* defined (_WIN64) */\n-/*  Install the Win32 SEH exception handler. Note that the caller must have\n-    allocated 8 bytes on the stack and pass the pointer to this stack\n-    space. This is needed as the SEH exception handler must be on the stack of\n-    the thread.\n+\n+/*  Install the Win32 SEH exception handler.  Note that the caller must have\n+    allocated 8 bytes on the stack and pass the pointer to this stack space.\n+    This is needed as the SEH exception handler must be on the stack of the\n+    thread.\n \n        int buf[2];\n \n@@ -271,31 +275,32 @@ void __gnat_install_SEH_handler (void *eh ATTRIBUTE_UNUSED)\n        main();\n \n    This call must be done before calling the main procedure or the thread\n-   entry. The stack space must exists during all the main run.  */\n+   entry.  The stack space must exist during the entire main run.  */\n \n void\n __gnat_install_SEH_handler (void *ER)\n {\n   int *ptr;\n \n-  /* put current handler in ptr */\n-\n+  /* Put current handler in PTR.  */\n   asm (\"mov %%fs:(0),%0\" : \"=r\" (ptr));\n \n   ((int *)ER)[0] = (int)ptr;                       /* previous handler */\n   ((int *)ER)[1] = (int)__gnat_SEH_error_handler;  /* new handler */\n \n-  /* ER is the new handler, set fs:(0) with this value */\n-\n+  /* ER is the new handler, set fs:(0) to this value.  */\n   asm volatile (\"mov %0,%%fs:(0)\": : \"r\" (ER));\n }\n+\n #endif\n \n #else /* defined (_WIN32) */\n-/* For all non Windows targets we provide a dummy SEH install handler.  */\n+\n+/* For all non-Windows targets we provide a dummy SEH install handler.  */\n void __gnat_install_SEH_handler (void *eh ATTRIBUTE_UNUSED)\n {\n }\n+\n #endif\n \n #ifdef __cplusplus"}]}