{"sha": "e3a5cc3259ea173f74e34094c1eeffec7ccd9fe1", "node_id": "C_kwDOANBUbNoAKGUzYTVjYzMyNTllYTE3M2Y3NGUzNDA5NGMxZWVmZmVjN2NjZDlmZTE", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2022-12-13T23:33:06Z"}, "committer": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2022-12-13T23:58:24Z"}, "message": "ipa-sra: Be optimistic about Fortran descriptors\n\nFortran descriptors are structures which are often constructed just\nfor a particular argument of a particular call where it is passed by\nreference.  When the called function is under compiler's control, it\ncan be beneficial to split up the descriptor and pass it in individual\nparameters.  Unfortunately, currently we allow IPA-SRA to replace a\npointer with a set of replacements which are at most twice as big in\ntotal and for descriptors we'd need to bump that factor to seven.\n\nThis patch looks for parameters which are ADDR_EXPRs of local\nvariables which are written to and passed as arguments by reference\nbut are never loaded from and marks them with a flag in the call edge\nsummary.  The IPA analysis phase then identifies formal parameters\nwhich are always fed such arguments and then is more lenient when it\ncomoes to size.\n\nIn order not to store to maximums per formal parameter, I calculate\nthe more lenient one by multiplying the existing one with a new\nparameter.  If it is preferable to keep the maximums independent, we\ncan do that.  Documentation for the new parameter is missing as I\nstill need to re-base the patch on a version which has sphinx.  I will\nwrite it before committing.\n\nI have disable IPA-SRA in pr48636-2.f90 in order to be able to keep\nusing its dump-scan expressions.  The new testcase is basically a copy\nof it with different options and IPA-SRA dump scans.\n\ngcc/ChangeLog:\n\n2022-11-11  Martin Jambor  <mjambor@suse.cz>\n\n\t* ipa-sra.cc (isra_param_desc): New field not_specially_constructed.\n\t(struct isra_param_flow): New field constructed_for_calls.\n\t(isra_call_summary::dump): Dump the new flag.\n\t(loaded_decls): New variable.\n\t(dump_isra_param_descriptor): New parameter hints, dump\n\tnot_specially_constructed if it is true.\n\t(dump_isra_param_descriptors): New parameter hints, pass it to\n\tdump_isra_param_descriptor.\n\t(ipa_sra_function_summaries::duplicate): Duplicate new flag.\n\t(create_parameter_descriptors): Adjust comment.\n\t(get_gensum_param_desc): Bail out when decl2desc is NULL.\n\t(scan_expr_access): Add loaded local variables to loaded_decls.\n\t(scan_function): Survive if final_bbs is NULL.\n\t(isra_analyze_call): Compute constructed_for_calls flag.\n\t(process_scan_results): Be optimistic about size limits.  Do not dump\n\tcomputed param hints when dumpint IPA-SRA structures.\n\t(isra_write_edge_summary): Stream constructed_for_calls.\n\t(isra_read_edge_summary): Likewise.\n\t(ipa_sra_dump_all_summaries): New parameter hints, pass it to\n\tdump_isra_param_descriptor.\n\t(flip_all_hints_pessimistic): New function.\n\t(flip_all_param_hints_pessimistic): Likewise.\n\t(propagate_param_hints): Likewise.\n\t(disable_unavailable_parameters): Renamed to\n\tadjust_parameter_descriptions.  Expand size limits for parameters\n\twhich are specially contstructed by all callers.  Check limits again.p\n\t(ipa_sra_analysis): Pass required hints to ipa_sra_dump_all_summaries.\n\tAdd hint propagation.\n\t(ipa_sra_summarize_function): Initialize and destory loaded_decls,\n\trearrange so that scan_function is called even when there are no\n\tcandidates.\n\t* params.opt (ipa-sra-ptrwrap-growth-factor): New parameter.\n\ngcc/testsuite/ChangeLog:\n\n2021-11-11  Martin Jambor  <mjambor@suse.cz>\n\n\t* gfortran.dg/pr48636-2.f90: Disable IPA-SRA.\n\t* gfortran.dg/ipa-sra-1.f90: New test.", "tree": {"sha": "25272055fb4ad5ab46ba3f9f1e0f5003fe2cc629", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/25272055fb4ad5ab46ba3f9f1e0f5003fe2cc629"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e3a5cc3259ea173f74e34094c1eeffec7ccd9fe1", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEE5elVTFt/d09Vsoczv2PBvD+kNUAFAmOZEaEACgkQv2PBvD+k\nNUBVhQ/+PBOKHEUTpT2uvsSZ6cRWiuqQ0YbAqBvULwL/T/dMnurv3ePiPhwtmiVP\nIYurMRp/2hjQrVjrpGqYhA76YTuKUa1MvgeiQ60PEhWL6gud6gcNQKfY3HsGe84U\nY7k3IvcYYcu85tJnnIjr5yRUQCASb+pqJW/0efJNeNbz4C2RAe1FUr9oJ97bRbAY\nICFaQkHM65iSSzJ5r+SCvgIsbAXVJu2bnFALdeZHPDODUJNyuiz6S8lZ9yWMISr1\n5qeLW9L/Y8Gldevr5/qgW9xjpJc6VR2J7SqE4Oi2VqOvMcQrUhGiQUcoikPhULBO\nI0pTHj2GQEVSl3Oe5pe4CRYbaWbwhnZ4ubuviYxKagf8uLMnzp36iIbDNDDTaXEM\nw6n+r/Ch+dED2+2R1zML6tl+kbScbniPZcNlG10qbAPMNLH2Z1a8rMrqAumHPKSh\nD+92dby/KRYc2AnBo1ahO9/n4K9tNFENhnP6Kl2QlG1pIzIupaFtPSi5i82O6Rks\nmaebDJ0qnLGkKPDZbfJbV/Oag6pO0rqlDkFXaAeKFcOSyKewaldRuqgZ5YT24xLB\nuEdvrPMCUV4PyC08k61Ad4EwbY2fZ1G6tveo44AP+dBnW92duR1SxZHaYZZcWyux\nfl75e8xVtACwpmxKvNtjcYmMoebJEpYe0yjcGDQq/+IPm2c7lCE=\n=TVS0\n-----END PGP SIGNATURE-----", "payload": "tree 25272055fb4ad5ab46ba3f9f1e0f5003fe2cc629\nparent 803a91330bf20174d1cf6a164cafd97405655b82\nauthor Martin Jambor <mjambor@suse.cz> 1670974386 +0100\ncommitter Martin Jambor <mjambor@suse.cz> 1670975904 +0100\n\nipa-sra: Be optimistic about Fortran descriptors\n\nFortran descriptors are structures which are often constructed just\nfor a particular argument of a particular call where it is passed by\nreference.  When the called function is under compiler's control, it\ncan be beneficial to split up the descriptor and pass it in individual\nparameters.  Unfortunately, currently we allow IPA-SRA to replace a\npointer with a set of replacements which are at most twice as big in\ntotal and for descriptors we'd need to bump that factor to seven.\n\nThis patch looks for parameters which are ADDR_EXPRs of local\nvariables which are written to and passed as arguments by reference\nbut are never loaded from and marks them with a flag in the call edge\nsummary.  The IPA analysis phase then identifies formal parameters\nwhich are always fed such arguments and then is more lenient when it\ncomoes to size.\n\nIn order not to store to maximums per formal parameter, I calculate\nthe more lenient one by multiplying the existing one with a new\nparameter.  If it is preferable to keep the maximums independent, we\ncan do that.  Documentation for the new parameter is missing as I\nstill need to re-base the patch on a version which has sphinx.  I will\nwrite it before committing.\n\nI have disable IPA-SRA in pr48636-2.f90 in order to be able to keep\nusing its dump-scan expressions.  The new testcase is basically a copy\nof it with different options and IPA-SRA dump scans.\n\ngcc/ChangeLog:\n\n2022-11-11  Martin Jambor  <mjambor@suse.cz>\n\n\t* ipa-sra.cc (isra_param_desc): New field not_specially_constructed.\n\t(struct isra_param_flow): New field constructed_for_calls.\n\t(isra_call_summary::dump): Dump the new flag.\n\t(loaded_decls): New variable.\n\t(dump_isra_param_descriptor): New parameter hints, dump\n\tnot_specially_constructed if it is true.\n\t(dump_isra_param_descriptors): New parameter hints, pass it to\n\tdump_isra_param_descriptor.\n\t(ipa_sra_function_summaries::duplicate): Duplicate new flag.\n\t(create_parameter_descriptors): Adjust comment.\n\t(get_gensum_param_desc): Bail out when decl2desc is NULL.\n\t(scan_expr_access): Add loaded local variables to loaded_decls.\n\t(scan_function): Survive if final_bbs is NULL.\n\t(isra_analyze_call): Compute constructed_for_calls flag.\n\t(process_scan_results): Be optimistic about size limits.  Do not dump\n\tcomputed param hints when dumpint IPA-SRA structures.\n\t(isra_write_edge_summary): Stream constructed_for_calls.\n\t(isra_read_edge_summary): Likewise.\n\t(ipa_sra_dump_all_summaries): New parameter hints, pass it to\n\tdump_isra_param_descriptor.\n\t(flip_all_hints_pessimistic): New function.\n\t(flip_all_param_hints_pessimistic): Likewise.\n\t(propagate_param_hints): Likewise.\n\t(disable_unavailable_parameters): Renamed to\n\tadjust_parameter_descriptions.  Expand size limits for parameters\n\twhich are specially contstructed by all callers.  Check limits again.p\n\t(ipa_sra_analysis): Pass required hints to ipa_sra_dump_all_summaries.\n\tAdd hint propagation.\n\t(ipa_sra_summarize_function): Initialize and destory loaded_decls,\n\trearrange so that scan_function is called even when there are no\n\tcandidates.\n\t* params.opt (ipa-sra-ptrwrap-growth-factor): New parameter.\n\ngcc/testsuite/ChangeLog:\n\n2021-11-11  Martin Jambor  <mjambor@suse.cz>\n\n\t* gfortran.dg/pr48636-2.f90: Disable IPA-SRA.\n\t* gfortran.dg/ipa-sra-1.f90: New test.\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3a5cc3259ea173f74e34094c1eeffec7ccd9fe1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e3a5cc3259ea173f74e34094c1eeffec7ccd9fe1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3a5cc3259ea173f74e34094c1eeffec7ccd9fe1/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "803a91330bf20174d1cf6a164cafd97405655b82", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/803a91330bf20174d1cf6a164cafd97405655b82", "html_url": "https://github.com/Rust-GCC/gccrs/commit/803a91330bf20174d1cf6a164cafd97405655b82"}], "stats": {"total": 321, "additions": 266, "deletions": 55}, "files": [{"sha": "2820c0ec38e808225b41928c96b5474cdda0af6b", "filename": "gcc/ipa-sra.cc", "status": "modified", "additions": 223, "deletions": 53, "changes": 276, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3a5cc3259ea173f74e34094c1eeffec7ccd9fe1/gcc%2Fipa-sra.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3a5cc3259ea173f74e34094c1eeffec7ccd9fe1/gcc%2Fipa-sra.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-sra.cc?ref=e3a5cc3259ea173f74e34094c1eeffec7ccd9fe1", "patch": "@@ -181,6 +181,10 @@ struct GTY(()) isra_param_desc\n   unsigned split_candidate : 1;\n   /* Is this a parameter passing stuff by reference?  */\n   unsigned by_ref : 1;\n+  /* Parameter hint set during IPA analysis when there is a caller which does\n+     not construct the argument just to pass it to calls.  Only meaningful for\n+     by_ref parameters.  */\n+  unsigned not_specially_constructed : 1;\n };\n \n /* Structure used when generating summaries that describes a parameter.  */\n@@ -340,6 +344,10 @@ struct isra_param_flow\n   /* True when it is safe to copy access candidates here from the callee, which\n      would mean introducing dereferences into callers of the caller.  */\n   unsigned safe_to_import_accesses : 1;\n+  /* True when the passed value is an address of a structure that has been\n+     constructed in the caller just to be passed by reference to functions\n+     (i.e. is never read).  */\n+  unsigned constructed_for_calls : 1;\n };\n \n /* Structure used to convey information about calls from the intra-procedural\n@@ -420,6 +428,7 @@ ipa_sra_function_summaries::duplicate (cgraph_node *, cgraph_node *,\n       d->locally_unused = s->locally_unused;\n       d->split_candidate = s->split_candidate;\n       d->by_ref = s->by_ref;\n+      d->not_specially_constructed = s->not_specially_constructed;\n \n       unsigned acc_count = vec_safe_length (s->accesses);\n       vec_safe_reserve_exact (d->accesses, acc_count);\n@@ -531,6 +540,9 @@ isra_call_summary::dump (FILE *f)\n       if (ipf->pointer_pass_through)\n \tfprintf (f, \"      Pointer pass through from the param given above, \"\n \t\t \"safe_to_import_accesses: %u\\n\", ipf->safe_to_import_accesses);\n+      if (ipf->constructed_for_calls)\n+\tfprintf (f, \"      Variable constructed just to be passed to \"\n+\t\t \"calls.\\n\");\n     }\n }\n \n@@ -559,6 +571,10 @@ namespace {\n \n hash_map<tree, gensum_param_desc *> *decl2desc;\n \n+/* All local DECLs ever loaded from.  */\n+\n+hash_set <tree> *loaded_decls;\n+\n /* Countdown of allowed Alias Analysis steps during summary building.  */\n \n int aa_walking_limit;\n@@ -728,10 +744,11 @@ dump_gensum_param_descriptors (FILE *f, tree fndecl,\n }\n \n \n-/* Dump DESC to F.   */\n+/* Dump DESC to F.  If HINTS is true, also dump IPA-analysis computed\n+   hints.  */\n \n static void\n-dump_isra_param_descriptor (FILE *f, isra_param_desc *desc)\n+dump_isra_param_descriptor (FILE *f, isra_param_desc *desc, bool hints)\n {\n   if (desc->locally_unused)\n     {\n@@ -742,9 +759,15 @@ dump_isra_param_descriptor (FILE *f, isra_param_desc *desc)\n       fprintf (f, \"    not a candidate for splitting\\n\");\n       return;\n     }\n-  fprintf (f, \"    param_size_limit: %u, size_reached: %u%s\\n\",\n+  fprintf (f, \"    param_size_limit: %u, size_reached: %u%s\",\n \t   desc->param_size_limit, desc->size_reached,\n \t   desc->by_ref ? \", by_ref\" : \"\");\n+  if (hints)\n+    {\n+      if (desc->by_ref && !desc->not_specially_constructed)\n+\tfprintf (f, \", args_specially_constructed\");\n+    }\n+  fprintf (f, \"\\n\");\n \n   for (unsigned i = 0; i < vec_safe_length (desc->accesses); ++i)\n     {\n@@ -753,12 +776,12 @@ dump_isra_param_descriptor (FILE *f, isra_param_desc *desc)\n     }\n }\n \n-/* Dump all parameter descriptors in IFS, assuming it describes FNDECL, to\n-   F.  */\n+/* Dump all parameter descriptors in IFS, assuming it describes FNDECL, to F.\n+   If HINTS is true, also dump IPA-analysis computed hints.  */\n \n static void\n-dump_isra_param_descriptors (FILE *f, tree fndecl,\n-\t\t\t     isra_func_summary *ifs)\n+dump_isra_param_descriptors (FILE *f, tree fndecl, isra_func_summary *ifs,\n+\t\t\t     bool hints)\n {\n   tree parm = DECL_ARGUMENTS (fndecl);\n   if (!ifs->m_parameters)\n@@ -774,7 +797,7 @@ dump_isra_param_descriptors (FILE *f, tree fndecl,\n       fprintf (f, \"  Descriptor for parameter %i \", i);\n       print_generic_expr (f, parm, TDF_UID);\n       fprintf (f, \"\\n\");\n-      dump_isra_param_descriptor (f, &(*ifs->m_parameters)[i]);\n+      dump_isra_param_descriptor (f, &(*ifs->m_parameters)[i], hints);\n     }\n }\n \n@@ -1086,7 +1109,7 @@ ptr_parm_has_nonarg_uses (cgraph_node *node, function *fun, tree parm,\n /* Initialize vector of parameter descriptors of NODE.  Return true if there\n    are any candidates for splitting or unused aggregate parameter removal (the\n    function may return false if there are candidates for removal of register\n-   parameters) and function body must be scanned.  */\n+   parameters).  */\n \n static bool\n create_parameter_descriptors (cgraph_node *node,\n@@ -1254,6 +1277,8 @@ create_parameter_descriptors (cgraph_node *node,\n static gensum_param_desc *\n get_gensum_param_desc (tree decl)\n {\n+  if (!decl2desc)\n+    return NULL;\n   gcc_checking_assert (TREE_CODE (decl) == PARM_DECL);\n   gensum_param_desc **slot = decl2desc->get (decl);\n   if (!slot)\n@@ -1705,6 +1730,12 @@ scan_expr_access (tree expr, gimple *stmt, isra_scan_context ctx,\n \treturn;\n       deref = true;\n     }\n+  else if (TREE_CODE (base) == VAR_DECL\n+\t   && !TREE_STATIC (base)\n+\t   && (ctx == ISRA_CTX_ARG\n+\t       || ctx == ISRA_CTX_LOAD))\n+    loaded_decls->add (base);\n+\n   if (TREE_CODE (base) != PARM_DECL)\n     return;\n \n@@ -1884,7 +1915,7 @@ scan_function (cgraph_node *node, struct function *fun)\n \t{\n \t  gimple *stmt = gsi_stmt (gsi);\n \n-\t  if (stmt_can_throw_external (fun, stmt))\n+\t  if (final_bbs && stmt_can_throw_external (fun, stmt))\n \t    bitmap_set_bit (final_bbs, bb->index);\n \t  switch (gimple_code (stmt))\n \t    {\n@@ -1893,7 +1924,8 @@ scan_function (cgraph_node *node, struct function *fun)\n \t\ttree t = gimple_return_retval (as_a <greturn *> (stmt));\n \t\tif (t != NULL_TREE)\n \t\t  scan_expr_access (t, stmt, ISRA_CTX_LOAD, bb);\n-\t\tbitmap_set_bit (final_bbs, bb->index);\n+\t\tif (final_bbs)\n+\t\t  bitmap_set_bit (final_bbs, bb->index);\n \t      }\n \t      break;\n \n@@ -1938,8 +1970,9 @@ scan_function (cgraph_node *node, struct function *fun)\n \t\tif (lhs)\n \t\t  scan_expr_access (lhs, stmt, ISRA_CTX_STORE, bb);\n \t\tint flags = gimple_call_flags (stmt);\n-\t\tif (((flags & (ECF_CONST | ECF_PURE)) == 0)\n-\t\t    || (flags & ECF_LOOPING_CONST_OR_PURE))\n+\t\tif (final_bbs\n+\t\t    && (((flags & (ECF_CONST | ECF_PURE)) == 0)\n+\t\t\t|| (flags & ECF_LOOPING_CONST_OR_PURE)))\n \t\t  bitmap_set_bit (final_bbs, bb->index);\n \t      }\n \t      break;\n@@ -1949,7 +1982,8 @@ scan_function (cgraph_node *node, struct function *fun)\n \t\tgasm *asm_stmt = as_a <gasm *> (stmt);\n \t\twalk_stmt_load_store_addr_ops (asm_stmt, NULL, NULL, NULL,\n \t\t\t\t\t       asm_visit_addr);\n-\t\tbitmap_set_bit (final_bbs, bb->index);\n+\t\tif (final_bbs)\n+\t\t  bitmap_set_bit (final_bbs, bb->index);\n \n \t\tfor (unsigned i = 0; i < gimple_asm_ninputs (asm_stmt); i++)\n \t\t  {\n@@ -2045,6 +2079,23 @@ isra_analyze_call (cgraph_edge *cs)\n   for (unsigned i = 0; i < count; i++)\n     {\n       tree arg = gimple_call_arg (call_stmt, i);\n+      if (TREE_CODE (arg) == ADDR_EXPR)\n+\t{\n+\t  poly_int64 poffset, psize, pmax_size;\n+\t  bool reverse;\n+\t  tree base = get_ref_base_and_extent (TREE_OPERAND (arg, 0), &poffset,\n+\t\t\t\t\t       &psize, &pmax_size, &reverse);\n+\t  /* TODO: Next patch will need the offset too, so we cannot use\n+\t     get_base_address. */\n+\t  if (TREE_CODE (base) == VAR_DECL\n+\t      && !TREE_STATIC (base)\n+\t      && !loaded_decls->contains (base))\n+\t    {\n+\t      csum->init_inputs (count);\n+\t      csum->m_arg_flow[i].constructed_for_calls = true;\n+\t    }\n+\t}\n+\n       if (is_gimple_reg (arg))\n \tcontinue;\n \n@@ -2355,18 +2406,28 @@ process_scan_results (cgraph_node *node, struct function *fun,\n \n       HOST_WIDE_INT cur_param_size\n \t= tree_to_uhwi (TYPE_SIZE (TREE_TYPE (parm)));\n-      HOST_WIDE_INT param_size_limit;\n+      HOST_WIDE_INT param_size_limit, optimistic_limit;\n       if (!desc->by_ref || optimize_function_for_size_p (fun))\n-\tparam_size_limit = cur_param_size;\n+\t{\n+\t  param_size_limit = cur_param_size;\n+\t  optimistic_limit = cur_param_size;\n+\t}\n       else\n+\t{\n \t  param_size_limit\n \t    = opt_for_fn (node->decl,\n \t\t\t  param_ipa_sra_ptr_growth_factor) * cur_param_size;\n-      if (nonarg_acc_size > param_size_limit\n+\t  optimistic_limit\n+\t    = (opt_for_fn (node->decl, param_ipa_sra_ptrwrap_growth_factor)\n+\t       * param_size_limit);\n+\t}\n+\n+      if (nonarg_acc_size > optimistic_limit\n \t  || (!desc->by_ref && nonarg_acc_size == param_size_limit))\n \t{\n \t  disqualify_split_candidate (desc, \"Would result into a too big set \"\n-\t\t\t\t      \"of replacements.\");\n+\t\t\t\t      \"of replacements even in best \"\n+\t\t\t\t      \"scenarios.\");\n \t}\n       else\n \t{\n@@ -2487,7 +2548,7 @@ process_scan_results (cgraph_node *node, struct function *fun,\n     }\n \n   if (dump_file)\n-    dump_isra_param_descriptors (dump_file, node->decl, ifs);\n+    dump_isra_param_descriptors (dump_file, node->decl, ifs, false);\n }\n \n /* Return true if there are any overlaps among certain accesses of DESC.  If\n@@ -2588,6 +2649,7 @@ isra_write_edge_summary (output_block *ob, cgraph_edge *e)\n       bp_pack_value (&bp, ipf->aggregate_pass_through, 1);\n       bp_pack_value (&bp, ipf->pointer_pass_through, 1);\n       bp_pack_value (&bp, ipf->safe_to_import_accesses, 1);\n+      bp_pack_value (&bp, ipf->constructed_for_calls, 1);\n       streamer_write_bitpack (&bp);\n       streamer_write_uhwi (ob, ipf->unit_offset);\n       streamer_write_uhwi (ob, ipf->unit_size);\n@@ -2636,6 +2698,7 @@ isra_write_node_summary (output_block *ob, cgraph_node *node)\n       bp_pack_value (&bp, desc->locally_unused, 1);\n       bp_pack_value (&bp, desc->split_candidate, 1);\n       bp_pack_value (&bp, desc->by_ref, 1);\n+      gcc_assert (!desc->not_specially_constructed);\n       streamer_write_bitpack (&bp);\n     }\n   bitpack_d bp = bitpack_create (ob->main_stream);\n@@ -2709,6 +2772,7 @@ isra_read_edge_summary (struct lto_input_block *ib, cgraph_edge *cs)\n       ipf->aggregate_pass_through = bp_unpack_value (&bp, 1);\n       ipf->pointer_pass_through = bp_unpack_value (&bp, 1);\n       ipf->safe_to_import_accesses = bp_unpack_value (&bp, 1);\n+      ipf->constructed_for_calls = bp_unpack_value (&bp, 1);\n       ipf->unit_offset = streamer_read_uhwi (ib);\n       ipf->unit_size = streamer_read_uhwi (ib);\n     }\n@@ -2755,6 +2819,7 @@ isra_read_node_info (struct lto_input_block *ib, cgraph_node *node,\n       desc->locally_unused = bp_unpack_value (&bp, 1);\n       desc->split_candidate = bp_unpack_value (&bp, 1);\n       desc->by_ref = bp_unpack_value (&bp, 1);\n+      desc->not_specially_constructed = 0;\n     }\n   bitpack_d bp = streamer_read_bitpack (ib);\n   ifs->m_candidate = bp_unpack_value (&bp, 1);\n@@ -2837,10 +2902,11 @@ ipa_sra_read_summary (void)\n     }\n }\n \n-/* Dump all IPA-SRA summary data for all cgraph nodes and edges to file F.  */\n+/* Dump all IPA-SRA summary data for all cgraph nodes and edges to file F.  If\n+   HINTS is true, also dump IPA-analysis computed hints.  */\n \n static void\n-ipa_sra_dump_all_summaries (FILE *f)\n+ipa_sra_dump_all_summaries (FILE *f, bool hints)\n {\n   cgraph_node *node;\n   FOR_EACH_FUNCTION_WITH_GIMPLE_BODY (node)\n@@ -2863,7 +2929,7 @@ ipa_sra_dump_all_summaries (FILE *f)\n \t    for (unsigned i = 0; i < ifs->m_parameters->length (); ++i)\n \t      {\n \t\tfprintf (f, \"  Descriptor for parameter %i:\\n\", i);\n-\t\tdump_isra_param_descriptor (f, &(*ifs->m_parameters)[i]);\n+\t\tdump_isra_param_descriptor (f, &(*ifs->m_parameters)[i], hints);\n \t      }\n \t  fprintf (f, \"\\n\");\n \t}\n@@ -3200,6 +3266,61 @@ isra_mark_caller_param_used (isra_func_summary *from_ifs, int input_idx,\n     }\n }\n \n+/* Set all param hints in DESC to the pessimistic values.  */\n+\n+static void\n+flip_all_hints_pessimistic (isra_param_desc *desc)\n+{\n+  desc->not_specially_constructed = true;\n+\n+  return;\n+}\n+\n+/* Because we have not analyzed a caller, go over all parameter int flags of\n+   NODE and turn them pessimistic.  */\n+\n+static void\n+flip_all_param_hints_pessimistic (cgraph_node *node)\n+{\n+  isra_func_summary *ifs = func_sums->get (node);\n+  if (!ifs || !ifs->m_candidate)\n+    return;\n+\n+  unsigned param_count = vec_safe_length (ifs->m_parameters);\n+\n+  for (unsigned i = 0; i < param_count; i++)\n+    flip_all_hints_pessimistic (&(*ifs->m_parameters)[i]);\n+\n+  return;\n+}\n+\n+/* Propagate hints accross edge CS which ultimately leads to CALLEE.  */\n+\n+static void\n+propagate_param_hints (cgraph_edge *cs, cgraph_node *callee)\n+{\n+  isra_call_summary *csum = call_sums->get (cs);\n+  isra_func_summary *to_ifs = func_sums->get (callee);\n+  if (!to_ifs || !to_ifs->m_candidate)\n+    return;\n+\n+  unsigned args_count = csum->m_arg_flow.length ();\n+  unsigned param_count = vec_safe_length (to_ifs->m_parameters);\n+\n+  for (unsigned i = 0; i < param_count; i++)\n+    {\n+      isra_param_desc *desc = &(*to_ifs->m_parameters)[i];\n+      if (i >= args_count)\n+\t{\n+\t  flip_all_hints_pessimistic (desc);\n+\t  continue;\n+\t}\n+\n+      if (desc->by_ref && !csum->m_arg_flow[i].constructed_for_calls)\n+\tdesc->not_specially_constructed = true;\n+    }\n+  return;\n+}\n \n /* Propagate information that any parameter is not used only locally within a\n    SCC across CS to the caller, which must be in the same SCC as the\n@@ -3850,10 +3971,12 @@ process_isra_node_results (cgraph_node *node,\n /* Check which parameters of NODE described by IFS have survived until IPA-SRA\n    and disable transformations for those which have not or which should not\n    transformed because the associated debug counter reached its limit.  Return\n-   true if none survived or if there were no candidates to begin with.  */\n+   true if none survived or if there were no candidates to begin with.\n+   Additionally, also adjust parameter descriptions based on debug counters and\n+   hints propagated earlier.  */\n \n static bool\n-disable_unavailable_parameters (cgraph_node *node, isra_func_summary *ifs)\n+adjust_parameter_descriptions (cgraph_node *node, isra_func_summary *ifs)\n {\n   bool ret = true;\n   unsigned len = vec_safe_length (ifs->m_parameters);\n@@ -3898,8 +4021,23 @@ disable_unavailable_parameters (cgraph_node *node, isra_func_summary *ifs)\n \t      fprintf (dump_file, \" %u\", i);\n \t    }\n \t}\n-      else if (desc->locally_unused || desc->split_candidate)\n-\tret = false;\n+      else\n+\t{\n+\t  if (desc->split_candidate)\n+\t    {\n+\t      if (desc->by_ref && !desc->not_specially_constructed)\n+\t\t{\n+\t\t  int extra_factor\n+\t\t    = opt_for_fn (node->decl,\n+\t\t\t\t  param_ipa_sra_ptrwrap_growth_factor);\n+\t\t  desc->param_size_limit = extra_factor * desc->param_size_limit;\n+\t\t}\n+\t      if (size_would_violate_limit_p (desc, desc->size_reached))\n+\t\tdesc->split_candidate = false;\n+\t    }\n+\t  if (desc->locally_unused || desc->split_candidate)\n+\t    ret = false;\n+\t}\n     }\n \n   if (dumped_first)\n@@ -3917,7 +4055,7 @@ ipa_sra_analysis (void)\n   if (dump_file)\n     {\n       fprintf (dump_file, \"\\n========== IPA-SRA IPA stage ==========\\n\");\n-      ipa_sra_dump_all_summaries (dump_file);\n+      ipa_sra_dump_all_summaries (dump_file, false);\n     }\n \n   gcc_checking_assert (func_sums);\n@@ -3979,6 +4117,24 @@ ipa_sra_analysis (void)\n \t\t  }\n \t      }\n \t}\n+\n+      /* Parameter hint propagation.  */\n+      for (cgraph_node *v : cycle_nodes)\n+\t{\n+\t  isra_func_summary *ifs = func_sums->get (v);\n+\t  for (cgraph_edge *cs = v->callees; cs; cs = cs->next_callee)\n+\t    {\n+\t      enum availability availability;\n+\t      cgraph_node *callee = cs->callee->function_symbol (&availability);\n+\t      if (!ifs)\n+\t\t{\n+\t\t  flip_all_param_hints_pessimistic (callee);\n+\t\t  continue;\n+\t\t}\n+\t      propagate_param_hints (cs, callee);\n+\t    }\n+\t}\n+\n       cycle_nodes.release ();\n     }\n \n@@ -3994,7 +4150,7 @@ ipa_sra_analysis (void)\n \t  isra_func_summary *ifs = func_sums->get (v);\n \t  if (!ifs || !ifs->m_candidate)\n \t    continue;\n-\t  if (disable_unavailable_parameters (v, ifs))\n+\t  if (adjust_parameter_descriptions (v, ifs))\n \t    continue;\n \t  for (cgraph_edge *cs = v->indirect_calls; cs; cs = cs->next_callee)\n \t    process_edge_to_unknown_caller (cs);\n@@ -4057,7 +4213,7 @@ ipa_sra_analysis (void)\n \t{\n \t  fprintf (dump_file, \"\\n========== IPA-SRA propagation final state \"\n \t\t   \" ==========\\n\");\n-\t  ipa_sra_dump_all_summaries (dump_file);\n+\t  ipa_sra_dump_all_summaries (dump_file, true);\n \t}\n       fprintf (dump_file, \"\\n========== IPA-SRA decisions ==========\\n\");\n     }\n@@ -4138,30 +4294,32 @@ ipa_sra_summarize_function (cgraph_node *node)\n   if (dump_file)\n     fprintf (dump_file, \"Creating summary for %s/%i:\\n\", node->name (),\n \t     node->order);\n-  if (!ipa_sra_preliminary_function_checks (node))\n-    {\n-      isra_analyze_all_outgoing_calls (node);\n-      return;\n-    }\n   gcc_obstack_init (&gensum_obstack);\n-  isra_func_summary *ifs = func_sums->get_create (node);\n-  ifs->m_candidate = true;\n-  tree ret = TREE_TYPE (TREE_TYPE (node->decl));\n-  ifs->m_returns_value = (TREE_CODE (ret) != VOID_TYPE);\n+  loaded_decls = new hash_set<tree>;\n \n-  decl2desc = new hash_map<tree, gensum_param_desc *>;\n+  isra_func_summary *ifs = NULL;\n   unsigned count = 0;\n-  for (tree parm = DECL_ARGUMENTS (node->decl); parm; parm = DECL_CHAIN (parm))\n-    count++;\n+  if (ipa_sra_preliminary_function_checks (node))\n+    {\n+      ifs = func_sums->get_create (node);\n+      ifs->m_candidate = true;\n+      tree ret = TREE_TYPE (TREE_TYPE (node->decl));\n+      ifs->m_returns_value = (TREE_CODE (ret) != VOID_TYPE);\n+      for (tree parm = DECL_ARGUMENTS (node->decl);\n+\t   parm;\n+\t   parm = DECL_CHAIN (parm))\n+\tcount++;\n+    }\n+  auto_vec<gensum_param_desc, 16> param_descriptions (count);\n \n+  struct function *fun = DECL_STRUCT_FUNCTION (node->decl);\n+  bool cfun_pushed = false;\n   if (count > 0)\n     {\n-      auto_vec<gensum_param_desc, 16> param_descriptions (count);\n+      decl2desc = new hash_map<tree, gensum_param_desc *>;\n       param_descriptions.reserve_exact (count);\n       param_descriptions.quick_grow_cleared (count);\n \n-      bool cfun_pushed = false;\n-      struct function *fun = DECL_STRUCT_FUNCTION (node->decl);\n       if (create_parameter_descriptors (node, &param_descriptions))\n \t{\n \t  push_cfun (fun);\n@@ -4171,15 +4329,22 @@ ipa_sra_summarize_function (cgraph_node *node)\n \t\t\t\t      unsafe_by_ref_count\n \t\t\t\t      * last_basic_block_for_fn (fun));\n \t  aa_walking_limit = opt_for_fn (node->decl, param_ipa_max_aa_steps);\n-\t  scan_function (node, fun);\n+\t}\n+    }\n+  /* Scan function is run even when there are no removal or splitting\n+     candidates so that we can calculate hints on call edges which can be\n+     useful in callees. */\n+  scan_function (node, fun);\n \n-\t  if (dump_file)\n-\t    {\n-\t      dump_gensum_param_descriptors (dump_file, node->decl,\n-\t\t\t\t\t     &param_descriptions);\n-\t      fprintf (dump_file, \"----------------------------------------\\n\");\n-\t    }\n+  if (count > 0)\n+    {\n+      if (dump_file)\n+\t{\n+\t  dump_gensum_param_descriptors (dump_file, node->decl,\n+\t\t\t\t\t &param_descriptions);\n+\t  fprintf (dump_file, \"----------------------------------------\\n\");\n \t}\n+\n       process_scan_results (node, fun, ifs, &param_descriptions);\n \n       if (cfun_pushed)\n@@ -4194,8 +4359,13 @@ ipa_sra_summarize_function (cgraph_node *node)\n     }\n   isra_analyze_all_outgoing_calls (node);\n \n-  delete decl2desc;\n-  decl2desc = NULL;\n+  delete loaded_decls;\n+  loaded_decls = NULL;\n+  if (decl2desc)\n+    {\n+      delete decl2desc;\n+      decl2desc = NULL;\n+    }\n   obstack_free (&gensum_obstack, NULL);\n   if (dump_file)\n     fprintf (dump_file, \"\\n\\n\");"}, {"sha": "e0fd05fb44ab55d0996538e70e7ff26c645b2fc8", "filename": "gcc/params.opt", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3a5cc3259ea173f74e34094c1eeffec7ccd9fe1/gcc%2Fparams.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3a5cc3259ea173f74e34094c1eeffec7ccd9fe1/gcc%2Fparams.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.opt?ref=e3a5cc3259ea173f74e34094c1eeffec7ccd9fe1", "patch": "@@ -292,7 +292,11 @@ Maximum pieces that IPA-SRA tracks per formal parameter, as a consequence, also\n \n -param=ipa-sra-ptr-growth-factor=\n Common Joined UInteger Var(param_ipa_sra_ptr_growth_factor) Init(2) Param Optimization\n-Maximum allowed growth of number and total size of new parameters that ipa-sra replaces a pointer to an aggregate with.\n+Maximum allowed growth of total size of new parameters that ipa-sra replaces a pointer to an aggregate with.\n+\n+-param=ipa-sra-ptrwrap-growth-factor=\n+Common Joined UInteger Var(param_ipa_sra_ptrwrap_growth_factor) Init(4) IntegerRange(1, 8) Param Optimization\n+Additional maximum allowed growth of total size of new parameters that ipa-sra replaces a pointer to an aggregate with, if it points to a local variable that the caller never writes to.\n \n -param=ira-loop-reserved-regs=\n Common Joined UInteger Var(param_ira_loop_reserved_regs) Init(2) Param Optimization"}, {"sha": "0c916c76148497c6072dba34470632eb6695bc47", "filename": "gcc/testsuite/gfortran.dg/ipa-sra-1.f90", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3a5cc3259ea173f74e34094c1eeffec7ccd9fe1/gcc%2Ftestsuite%2Fgfortran.dg%2Fipa-sra-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3a5cc3259ea173f74e34094c1eeffec7ccd9fe1/gcc%2Ftestsuite%2Fgfortran.dg%2Fipa-sra-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fipa-sra-1.f90?ref=e3a5cc3259ea173f74e34094c1eeffec7ccd9fe1", "patch": "@@ -0,0 +1,37 @@\n+! { dg-do compile }\n+! { dg-options \"-O2 -fno-inline -fno-ipa-cp -fwhole-program -fdump-ipa-sra-details\" }\n+\n+module foo\n+  implicit none\n+contains\n+  subroutine bar(a,x)\n+    real, dimension(:,:), intent(in) :: a\n+    real, intent(out) :: x\n+    integer :: i,j\n+\n+    x = 0\n+    do j=1,ubound(a,2)\n+       do i=1,ubound(a,1)\n+          x = x + a(i,j)**2\n+       end do\n+    end do\n+  end subroutine bar\n+end module foo\n+\n+program main\n+  use foo\n+  implicit none\n+  real, dimension(2,3) :: a\n+  real :: x\n+  integer :: i\n+\n+  data a /1.0, 2.0, 3.0, -1.0, -2.0, -3.0/\n+\n+  do i=1,2000000\n+     call bar(a,x)\n+  end do\n+  print *,x\n+end program main\n+\n+! { dg-final { scan-ipa-dump \"Created new node.*bar\\\\.isra\" \"sra\" } }\n+! { dg-final { scan-ipa-dump-times \"IPA_PARAM_OP_SPLIT\" 7 \"sra\" } }"}, {"sha": "4d2bd69b47e16548b89aa95db17b8d9bcdbc6cdf", "filename": "gcc/testsuite/gfortran.dg/pr48636-2.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3a5cc3259ea173f74e34094c1eeffec7ccd9fe1/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr48636-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3a5cc3259ea173f74e34094c1eeffec7ccd9fe1/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr48636-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr48636-2.f90?ref=e3a5cc3259ea173f74e34094c1eeffec7ccd9fe1", "patch": "@@ -1,5 +1,5 @@\n ! { dg-do compile }\n-! { dg-options \"-O3 -fdump-ipa-cp-details -fno-inline\" }\n+! { dg-options \"-O3 -fdump-ipa-cp-details -fno-inline -fno-ipa-sra\" }\n \n module foo\n   implicit none"}]}