{"sha": "114278e7115aac1d32cd465a272f27e80a0e4dff", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTE0Mjc4ZTcxMTVhYWMxZDMyY2Q0NjVhMjcyZjI3ZTgwYTBlNGRmZg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2003-04-17T09:59:32Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2003-04-17T09:59:32Z"}, "message": "s390.c (SYMBOL_FLAG_ALIGN1): New.\n\n        * config/s390/s390.c (SYMBOL_FLAG_ALIGN1): New.\n        (tls_model_chars): Remove.\n        (larl_operand): Use SYMBOL_REF_FLAGS.\n        (tls_symbolic_operand): Use SYMBOL_REF_TLS_MODEL.\n        (legitimize_pic_address): Use SYMBOL_REF_LOCAL_P.\n        (s390_output_mi_thunk): Likewise.\n        (s390_emit_prologue): Set SYMBOL_FLAG_LOCAL as needed.\n        (s390_function_profiler): Likewise.\n        (s390_encode_section_info): Use default_encode_section_info\n        and SYMBOL_FLAG_ALIGN1.\n        (s390_strip_name_encoding): Remove.\n        * config/s390/s390.h (ASM_OUTPUT_LABELREF): Remove.\n        * config/s390/s390.md (call, call_value): Use SYMBOL_REF_LOCAL_P.\n        (builtin_setjmp_receiver): Set SYMBOL_FLAG_LOCAL as needed.\n\nFrom-SVN: r65734", "tree": {"sha": "23abe5b718221fe052756c850a97c0fffeb185ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/23abe5b718221fe052756c850a97c0fffeb185ae"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/114278e7115aac1d32cd465a272f27e80a0e4dff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/114278e7115aac1d32cd465a272f27e80a0e4dff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/114278e7115aac1d32cd465a272f27e80a0e4dff", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/114278e7115aac1d32cd465a272f27e80a0e4dff/comments", "author": null, "committer": null, "parents": [{"sha": "e95ef1878f06e85f88073db03b7677f3c2c640f8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e95ef1878f06e85f88073db03b7677f3c2c640f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e95ef1878f06e85f88073db03b7677f3c2c640f8"}], "stats": {"total": 178, "additions": 47, "deletions": 131}, "files": [{"sha": "460537d73c7536cedb9732bc11d0955a79042301", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/114278e7115aac1d32cd465a272f27e80a0e4dff/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/114278e7115aac1d32cd465a272f27e80a0e4dff/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=114278e7115aac1d32cd465a272f27e80a0e4dff", "patch": "@@ -1,3 +1,20 @@\n+2003-04-17  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/s390/s390.c (SYMBOL_FLAG_ALIGN1): New.\n+\t(tls_model_chars): Remove.\n+\t(larl_operand): Use SYMBOL_REF_FLAGS.\n+\t(tls_symbolic_operand): Use SYMBOL_REF_TLS_MODEL.\n+\t(legitimize_pic_address): Use SYMBOL_REF_LOCAL_P. \n+\t(s390_output_mi_thunk): Likewise.\n+\t(s390_emit_prologue): Set SYMBOL_FLAG_LOCAL as needed.\n+\t(s390_function_profiler): Likewise.\n+\t(s390_encode_section_info): Use default_encode_section_info\n+\tand SYMBOL_FLAG_ALIGN1.\n+\t(s390_strip_name_encoding): Remove.\n+\t* config/s390/s390.h (ASM_OUTPUT_LABELREF): Remove.\n+\t* config/s390/s390.md (call, call_value): Use SYMBOL_REF_LOCAL_P.\n+\t(builtin_setjmp_receiver): Set SYMBOL_FLAG_LOCAL as needed.\n+\n 2003-04-17  Richard Henderson  <rth@redhat.com>\n \n \t* config/ns32k/ns32k.c (ns32k_encode_section_info): Remove."}, {"sha": "18a7bcceb7e971ec9a516778d2bb49845cc90eb0", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 27, "deletions": 124, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/114278e7115aac1d32cd465a272f27e80a0e4dff/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/114278e7115aac1d32cd465a272f27e80a0e4dff/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=114278e7115aac1d32cd465a272f27e80a0e4dff", "patch": "@@ -50,11 +50,14 @@ Boston, MA 02111-1307, USA.  */\n #include \"langhooks.h\"\n #include \"optabs.h\"\n \n+/* Machine-specific symbol_ref flags.  */\n+#define SYMBOL_FLAG_ALIGN1\t(SYMBOL_FLAG_MACH_DEP << 0)\n+\n+\n static bool s390_assemble_integer PARAMS ((rtx, unsigned int, int));\n static void s390_select_rtx_section PARAMS ((enum machine_mode, rtx, \n \t\t\t\t\t     unsigned HOST_WIDE_INT));\n static void s390_encode_section_info PARAMS ((tree, int));\n-static const char *s390_strip_name_encoding PARAMS ((const char *));\n static bool s390_cannot_force_const_mem PARAMS ((rtx));\n static rtx s390_delegitimize_address PARAMS ((rtx));\n static void s390_init_builtins PARAMS ((void));\n@@ -89,8 +92,6 @@ static int s390_address_cost PARAMS ((rtx));\n \n #undef\tTARGET_ENCODE_SECTION_INFO\n #define TARGET_ENCODE_SECTION_INFO s390_encode_section_info\n-#undef  TARGET_STRIP_NAME_ENCODING\n-#define TARGET_STRIP_NAME_ENCODING s390_strip_name_encoding\n \n #ifdef HAVE_AS_TLS\n #undef TARGET_HAVE_TLS\n@@ -135,9 +136,6 @@ static int s390_sr_alias_set = 0;\n    emitted.  */\n rtx s390_compare_op0, s390_compare_op1;\n \n-/* The encoding characters for the four TLS models present in ELF.  */\n-static char const tls_model_chars[] = \" GLil\";\n-\n /* Structure used to hold the components of a S/390 memory\n    address.  A legitimate address on S/390 is of the general\n    form\n@@ -1050,12 +1048,10 @@ larl_operand (op, mode)\n   /* Allow labels and local symbols.  */\n   if (GET_CODE (op) == LABEL_REF)\n     return 1;\n-  if (GET_CODE (op) == SYMBOL_REF\n-      && XSTR (op, 0)[0] != '@'\n-      && !tls_symbolic_operand (op)\n-      && (!flag_pic || SYMBOL_REF_FLAG (op) \n-          || CONSTANT_POOL_ADDRESS_P (op)))\n-    return 1;\n+  if (GET_CODE (op) == SYMBOL_REF)\n+    return ((SYMBOL_REF_FLAGS (op) & SYMBOL_FLAG_ALIGN1) == 0\n+\t    && SYMBOL_REF_TLS_MODEL (op) == 0\n+\t    && (!flag_pic || SYMBOL_REF_LOCAL_P (op)));\n \n   /* Everything else must have a CONST, so strip it.  */\n   if (GET_CODE (op) != CONST)\n@@ -1074,12 +1070,10 @@ larl_operand (op, mode)\n   /* Labels and local symbols allowed here as well.  */\n   if (GET_CODE (op) == LABEL_REF)\n     return 1;\n-  if (GET_CODE (op) == SYMBOL_REF\n-      && XSTR (op, 0)[0] != '@'\n-      && !tls_symbolic_operand (op)\n-      && (!flag_pic || SYMBOL_REF_FLAG (op)\n-          || CONSTANT_POOL_ADDRESS_P (op)))\n-    return 1;\n+  if (GET_CODE (op) == SYMBOL_REF)\n+    return ((SYMBOL_REF_FLAGS (op) & SYMBOL_FLAG_ALIGN1) == 0\n+\t    && SYMBOL_REF_TLS_MODEL (op) == 0\n+\t    && (!flag_pic || SYMBOL_REF_LOCAL_P (op)));\n \n   /* Now we must have a @GOTENT offset or @PLT stub\n      or an @INDNTPOFF TLS offset.  */\n@@ -1320,15 +1314,9 @@ int\n tls_symbolic_operand (op)\n      register rtx op;\n {\n-  const char *symbol_str;\n-\n   if (GET_CODE (op) != SYMBOL_REF)\n     return 0;\n-  symbol_str = XSTR (op, 0);\n-\n-  if (symbol_str[0] != '%')\n-    return 0;\n-  return strchr (tls_model_chars, symbol_str[1]) - tls_model_chars;\n+  return SYMBOL_REF_TLS_MODEL (op);\n }\n \f\n /* Return true if OP is a load multiple operation.  It is known to be a\n@@ -2159,7 +2147,7 @@ s390_load_address (dst, src)\n \n    2. Static data references, constant pool addresses, and code labels\n       compute the address as an offset from the GOT, whose base is in\n-      the PIC reg.  Static data objects have SYMBOL_REF_FLAG set to\n+      the PIC reg.  Static data objects have SYMBOL_FLAG_LOCAL set to\n       differentiate them from global data objects.  The returned\n       address is the PIC reg + an unspec constant.\n \n@@ -2176,9 +2164,7 @@ legitimize_pic_address (orig, reg)\n   rtx base;\n \n   if (GET_CODE (addr) == LABEL_REF\n-      || (GET_CODE (addr) == SYMBOL_REF\n-\t  && (SYMBOL_REF_FLAG (addr) \n-              || CONSTANT_POOL_ADDRESS_P (addr))))\n+      || (GET_CODE (addr) == SYMBOL_REF && SYMBOL_REF_LOCAL_P (addr)))\n     {\n       /* This is a local symbol.  */\n       if (TARGET_64BIT && larl_operand (addr, VOIDmode))\n@@ -2330,9 +2316,7 @@ legitimize_pic_address (orig, reg)\n \t  /* Check first to see if this is a constant offset \n              from a local symbol reference.  */\n \t  if ((GET_CODE (op0) == LABEL_REF\n-\t\t|| (GET_CODE (op0) == SYMBOL_REF\n-\t\t    && (SYMBOL_REF_FLAG (op0)\n-                        || CONSTANT_POOL_ADDRESS_P (op0))))\n+\t\t|| (GET_CODE (op0) == SYMBOL_REF && SYMBOL_REF_LOCAL_P (op0)))\n \t      && GET_CODE (op1) == CONST_INT)\n \t    {\n               if (TARGET_64BIT && larl_operand (op0, VOIDmode))\n@@ -5485,7 +5469,7 @@ s390_emit_prologue ()\n   if (flag_pic && regs_ever_live[PIC_OFFSET_TABLE_REGNUM])\n     {\n       rtx got_symbol = gen_rtx_SYMBOL_REF (Pmode, \"_GLOBAL_OFFSET_TABLE_\");\n-      SYMBOL_REF_FLAG (got_symbol) = 1;\n+      SYMBOL_REF_FLAGS (got_symbol) = SYMBOL_FLAG_LOCAL;\n \n       if (TARGET_64BIT)\n \t{\n@@ -6354,7 +6338,7 @@ s390_function_profiler (file, labelno)\n \n   op[2] = gen_rtx_REG (Pmode, 1);\n   op[3] = gen_rtx_SYMBOL_REF (Pmode, label);\n-  SYMBOL_REF_FLAG (op[3]) = 1;\n+  SYMBOL_REF_FLAGS (op[3]) = SYMBOL_FLAG_LOCAL;\n \n   op[4] = gen_rtx_SYMBOL_REF (Pmode, \"_mcount\");\n   if (flag_pic)\n@@ -6419,101 +6403,20 @@ s390_select_rtx_section (mode, x, align)\n }\n \n /* Encode symbol attributes (local vs. global, tls model) of a SYMBOL_REF\n-   into its name and SYMBOL_REF_FLAG.  */\n+   into its SYMBOL_REF_FLAGS.  */\n \n static void\n s390_encode_section_info (decl, first)\n      tree decl;\n-     int first ATTRIBUTE_UNUSED;\n+     int first;\n {\n-  bool local_p = (*targetm.binds_local_p) (decl);\n-  rtx rtl, symbol;\n+  default_encode_section_info (decl, first);\n \n-  rtl = DECL_P (decl) ? DECL_RTL (decl) : TREE_CST_RTL (decl);\n-  if (GET_CODE (rtl) != MEM)\n-    return;\n-  symbol = XEXP (rtl, 0);\n-  if (GET_CODE (symbol) != SYMBOL_REF)\n-    return;\n-\n-  /* When using PIC, SYMBOL_REF_FLAG marks non-global symbols\n-     that can be accessed directly.  */\n-  if (flag_pic)\n-    SYMBOL_REF_FLAG (symbol) = local_p;\n-\n-  /* Encode thread-local data with %[GLil] for \"global dynamic\",\n-     \"local dynamic\", \"initial exec\" or \"local exec\" TLS models,\n-     respectively.  */\n-\n-  if (TREE_CODE (decl) == VAR_DECL && DECL_THREAD_LOCAL (decl))\n-    {\n-      const char *symbol_str = XSTR (symbol, 0);\n-      char *newstr;\n-      size_t len;\n-      enum tls_model kind = decl_tls_model (decl);\n-\n-      if (!flag_pic)\n-\t{\n-\t  /* We don't allow non-pic code for shared libraries,\n-\t     so don't generate GD/LD TLS models for non-pic code.  */\n-\t  switch (kind)\n-\t    {\n-\t    case TLS_MODEL_GLOBAL_DYNAMIC:\n-\t      kind = TLS_MODEL_INITIAL_EXEC; break;\n-\t    case TLS_MODEL_LOCAL_DYNAMIC:\n-\t      kind = TLS_MODEL_LOCAL_EXEC; break;\n-\t    default:\n-\t      break;\n-\t    }\n-\t}\n-\n-      if (symbol_str[0] == '%')\n-\t{\n-\t  if (symbol_str[1] == tls_model_chars[kind])\n-\t    return;\n-\t  symbol_str += 2;\n-\t}\n-      len = strlen (symbol_str) + 1;\n-      newstr = alloca (len + 2);\n-\n-      newstr[0] = '%';\n-      newstr[1] = tls_model_chars[kind];\n-      memcpy (newstr + 2, symbol_str, len);\n-\n-      XSTR (symbol, 0) = ggc_alloc_string (newstr, len + 2 - 1);\n-    }\n-\n-  /* If a variable has a forced alignment to < 2 bytes, mark it\n-     with '@' to prevent it from being used as LARL operand.  */\n-\n-  else if (TREE_CODE (decl) == VAR_DECL \n-\t   && DECL_USER_ALIGN (decl) && DECL_ALIGN (decl) < 16\n-\t   && XSTR (symbol, 0)[0] != '@')\n-    {\n-      const char *symbol_str = XSTR (symbol, 0);\n-      size_t len = strlen (symbol_str) + 1;\n-      char *newstr = alloca (len + 1);\n-\n-      newstr[0] = '@';\n-      memcpy (newstr + 1, symbol_str, len);\n-\n-      XSTR (symbol, 0) = ggc_alloc_string (newstr, len + 1 - 1);\n-    }\n-}\n-\n-/* Undo the above when printing symbol names.  */\n-\n-static const char *\n-s390_strip_name_encoding (str)\n-     const char *str;\n-{\n-  if (str[0] == '%')\n-    str += 2;\n-  if (str[0] == '@')\n-    str += 1;\n-  if (str[0] == '*')\n-    str += 1;\n-  return str;\n+  /* If a variable has a forced alignment to < 2 bytes, mark it with\n+     SYMBOL_FLAG_ALIGN1 to prevent it from being used as LARL operand.  */\n+  if (TREE_CODE (decl) == VAR_DECL \n+      && DECL_USER_ALIGN (decl) && DECL_ALIGN (decl) < 16)\n+    SYMBOL_REF_FLAGS (XEXP (DECL_RTL (decl), 0)) |= SYMBOL_FLAG_ALIGN1;\n }\n \n /* Output thunk to FILE that implements a C++ virtual function call (with\n@@ -6534,7 +6437,7 @@ s390_output_mi_thunk (file, thunk, delta, vcall_offset, function)\n \n   /* Operand 0 is the target function.  */\n   op[0] = XEXP (DECL_RTL (function), 0);\n-  if (flag_pic && !SYMBOL_REF_FLAG (op[0]))\n+  if (flag_pic && !SYMBOL_REF_LOCAL_P (op[0]))\n     {\n       op[0] = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, op[0]), 113);\n       op[0] = gen_rtx_CONST (Pmode, op[0]);"}, {"sha": "11926f927e8df4469f8030c3036e905e6cb264bf", "filename": "gcc/config/s390/s390.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/114278e7115aac1d32cd465a272f27e80a0e4dff/gcc%2Fconfig%2Fs390%2Fs390.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/114278e7115aac1d32cd465a272f27e80a0e4dff/gcc%2Fconfig%2Fs390%2Fs390.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.h?ref=114278e7115aac1d32cd465a272f27e80a0e4dff", "patch": "@@ -917,10 +917,6 @@ extern int flag_pic;\n #define ASM_OUTPUT_SKIP(FILE, SIZE) \\\n   fprintf ((FILE), \"\\t.set\\t.,.+%u\\n\", (SIZE))\n \n-/* Output a reference to a user-level label named NAME.  */\n-#define ASM_OUTPUT_LABELREF(FILE, NAME) \\\n-  asm_fprintf ((FILE), \"%U%s\", (*targetm.strip_name_encoding) (NAME))\n-\n /* The LOCAL_LABEL_PREFIX variable is used by dbxelf.h.  */\n #define LOCAL_LABEL_PREFIX \".\"\n "}, {"sha": "88f0dcdc9d044e955f204c6c15a986f38b92a442", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/114278e7115aac1d32cd465a272f27e80a0e4dff/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/114278e7115aac1d32cd465a272f27e80a0e4dff/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=114278e7115aac1d32cd465a272f27e80a0e4dff", "patch": "@@ -6256,7 +6256,7 @@\n \n       /* When calling a global routine in PIC mode, we must\n          replace the symbol itself with the PLT stub.  */\n-      if (flag_pic && !SYMBOL_REF_FLAG (sym))\n+      if (flag_pic && !SYMBOL_REF_LOCAL_P (sym))\n         {\n           sym = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, sym), 113);\n           sym = gen_rtx_CONST (Pmode, sym);\n@@ -6375,7 +6375,7 @@\n \n       /* When calling a global routine in PIC mode, we must\n          replace the symbol itself with the PLT stub.  */\n-      if (flag_pic && !SYMBOL_REF_FLAG (sym))\n+      if (flag_pic && !SYMBOL_REF_LOCAL_P (sym))\n         {\n           sym = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, sym), 113);\n           sym = gen_rtx_CONST (Pmode, sym);\n@@ -6720,7 +6720,7 @@\n {\n   rtx gotreg = gen_rtx_REG (Pmode, PIC_OFFSET_TABLE_REGNUM);\n   rtx got = gen_rtx_SYMBOL_REF (Pmode, \\\"_GLOBAL_OFFSET_TABLE_\\\");\n-  SYMBOL_REF_FLAG (got) = 1;\n+  SYMBOL_REF_FLAGS (got) = SYMBOL_FLAG_LOCAL;\n \n   emit_move_insn (gotreg, got);\n   emit_insn (gen_rtx_USE (VOIDmode, gotreg));"}]}