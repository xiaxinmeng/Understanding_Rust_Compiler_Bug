{"sha": "9caa3eb2db5a2f0d04bbc7765fd76bf58d384c45", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWNhYTNlYjJkYjVhMmYwZDA0YmJjNzc2NWZkNzZiZjU4ZDM4NGM0NQ==", "commit": {"author": {"name": "David Edelsohn", "email": "edelsohn@gnu.org", "date": "2002-11-16T18:01:51Z"}, "committer": {"name": "David Edelsohn", "email": "dje@gcc.gnu.org", "date": "2002-11-16T18:01:51Z"}, "message": "rs6000.c (rs6000_outout_load_multiple): New function.\n\n        * config/rs6000/rs6000.c (rs6000_outout_load_multiple): New function.\n        * config/rs6000/rs6000.md (movti_string): Remove output modifier\n        when scratch register never needed.\n        (ldmsi[3-8]): New patterns.\n\nFrom-SVN: r59174", "tree": {"sha": "2162b196a7a6c89f8066c11abb27e920d3e33ec6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2162b196a7a6c89f8066c11abb27e920d3e33ec6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9caa3eb2db5a2f0d04bbc7765fd76bf58d384c45", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9caa3eb2db5a2f0d04bbc7765fd76bf58d384c45", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9caa3eb2db5a2f0d04bbc7765fd76bf58d384c45", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9caa3eb2db5a2f0d04bbc7765fd76bf58d384c45/comments", "author": null, "committer": null, "parents": [{"sha": "476c5eb60eb1046af8609079235c2f6db25365f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/476c5eb60eb1046af8609079235c2f6db25365f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/476c5eb60eb1046af8609079235c2f6db25365f4"}], "stats": {"total": 231, "additions": 176, "deletions": 55}, "files": [{"sha": "f023800db586b263574a68bdbca549698b955f90", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9caa3eb2db5a2f0d04bbc7765fd76bf58d384c45/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9caa3eb2db5a2f0d04bbc7765fd76bf58d384c45/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9caa3eb2db5a2f0d04bbc7765fd76bf58d384c45", "patch": "@@ -1,3 +1,10 @@\n+2002-11-16  David Edelsohn  <edelsohn@gnu.org>\n+\n+\t* config/rs6000/rs6000.c (rs6000_outout_load_multiple): New function.\n+\t* config/rs6000/rs6000.md (movti_string): Remove output modifier\n+\twhen scratch register never needed.\n+\t(ldmsi[3-8]): New patterns.\n+\n 2002-11-16  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* hard-reg-set.h: Follow spelling conventions."}, {"sha": "a7ec02b03e23f79e44bc7c5016f5bfe478a40b2c", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9caa3eb2db5a2f0d04bbc7765fd76bf58d384c45/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9caa3eb2db5a2f0d04bbc7765fd76bf58d384c45/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=9caa3eb2db5a2f0d04bbc7765fd76bf58d384c45", "patch": "@@ -84,6 +84,7 @@ extern int constant_pool_expr_p PARAMS ((rtx));\n extern int toc_relative_expr_p PARAMS ((rtx));\n extern int expand_block_move PARAMS ((rtx[]));\n extern int load_multiple_operation PARAMS ((rtx, enum machine_mode));\n+extern const char * rs6000_output_load_multiple PARAMS ((rtx[]));\n extern int store_multiple_operation PARAMS ((rtx, enum machine_mode));\n extern int branch_comparison_operator PARAMS ((rtx, enum machine_mode));\n extern int branch_positive_comparison_operator \n@@ -186,7 +187,7 @@ extern void rs6000_emit_load_toc_table PARAMS ((int));\n extern void rs6000_aix_emit_builtin_unwind_init PARAMS ((void));\n extern void rs6000_emit_epilogue PARAMS ((int));\n extern void debug_stack_info PARAMS ((rs6000_stack_t *));\n-extern const char *output_isel PARAMS ((rtx *));\n+extern const char * output_isel PARAMS ((rtx *));\n extern int vrsave_operation PARAMS ((rtx, enum machine_mode));\n extern int rs6000_register_move_cost PARAMS ((enum machine_mode,\n \t\t\t\t\t      enum reg_class, enum reg_class));"}, {"sha": "5dd2e120a4b494bd0d380845f111b3978e1f286c", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9caa3eb2db5a2f0d04bbc7765fd76bf58d384c45/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9caa3eb2db5a2f0d04bbc7765fd76bf58d384c45/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=9caa3eb2db5a2f0d04bbc7765fd76bf58d384c45", "patch": "@@ -6390,6 +6390,64 @@ store_multiple_operation (op, mode)\n   return 1;\n }\n \n+/* Return a string to perform a load_multiple operation.\n+   operands[0] is the vector.\n+   operands[1] is the source address.\n+   operands[2] is the first destination register.  */\n+\n+const char *\n+rs6000_output_load_multiple (operands)\n+     rtx operands[2];\n+{\n+  /* We have to handle the case where the pseudo used to contain the address\n+     is assigned to one of the output registers.  */\n+  int i, j;\n+  int words = XVECLEN (operands[0], 0);\n+  rtx xop[10];\n+\n+  if (XVECLEN (operands[0], 0) == 1)\n+    return \"{l|lwz} %2,0(%1)\";\n+\n+  for (i = 0; i < words; i++)\n+    if (refers_to_regno_p (REGNO (operands[2]) + i,\n+\t\t\t   REGNO (operands[2]) + i + 1, operands[1], 0))\n+      {\n+\tif (i == words-1)\n+\t  {\n+\t    xop[0] = GEN_INT (4 * (words-1));\n+\t    xop[1] = operands[1];\n+\t    xop[2] = operands[2];\n+\t    output_asm_insn (\"{lsi|lswi} %2,%1,%0\\n\\t{l|lwz} %1,%0(%1)\", xop);\n+\t    return \"\";\n+\t  }\n+\telse if (i == 0)\n+\t  {\n+\t    xop[0] = GEN_INT (4 * (words-1));\n+\t    xop[1] = operands[1];\n+\t    xop[2] = gen_rtx_REG (SImode, REGNO (operands[2]) + 1);\n+\t    output_asm_insn (\"{cal %1,4(%1)|addi %1,%1,4}\\n\\t{lsi|lswi} %2,%1,%0\\n\\t{l|lwz} %1,-4(%1)\", xop);\n+\t    return \"\";\n+\t  }\n+\telse\n+\t  {\n+\t    for (j = 0; j < words; j++)\n+\t      if (j != i)\n+\t\t{\n+\t\t  xop[0] = GEN_INT (j * 4);\n+\t\t  xop[1] = operands[1];\n+\t\t  xop[2] = gen_rtx_REG (SImode, REGNO (operands[2]) + j);\n+\t\t  output_asm_insn (\"{l|lwz} %2,%0(%1)\", xop);\n+\t\t}\n+\t    xop[0] = GEN_INT (i * 4);\n+\t    xop[1] = operands[1];\n+\t    output_asm_insn (\"{l|lwz} %1,%0(%1)\", xop);\n+\t    return \"\";\n+\t  }\n+      }\n+\n+  return \"{lsi|lswi} %2,%1,%N0\";\n+}\n+\n /* Return 1 for a parallel vrsave operation.  */\n \n int"}, {"sha": "853dab23f881af6bdd4a855e913a74508195491a", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 109, "deletions": 54, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9caa3eb2db5a2f0d04bbc7765fd76bf58d384c45/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9caa3eb2db5a2f0d04bbc7765fd76bf58d384c45/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=9caa3eb2db5a2f0d04bbc7765fd76bf58d384c45", "patch": "@@ -9250,7 +9250,7 @@\n (define_insn \"*movti_string\"\n   [(set (match_operand:TI 0 \"reg_or_mem_operand\" \"=Q,m,????r,????r,????r\")\n \t(match_operand:TI 1 \"reg_or_mem_operand\" \"r,r,r,Q,m\"))\n-   (clobber (match_scratch:SI 2 \"=X,X,X,X,X\"))]\n+   (clobber (match_scratch:SI 2 \"X,X,X,X,X\"))]\n   \"TARGET_STRING && ! TARGET_POWER && ! TARGET_POWERPC64\n    && (gpc_reg_operand (operands[0], TImode) || gpc_reg_operand (operands[1], TImode))\"\n   \"*\n@@ -9371,65 +9371,120 @@\n \t\t     adjust_address (op1, SImode, i * 4));\n }\")\n \n-(define_insn \"\"\n+(define_insn \"*ldmsi8\"\n   [(match_parallel 0 \"load_multiple_operation\"\n-\t\t   [(set (match_operand:SI 1 \"gpc_reg_operand\" \"=r\")\n-\t\t\t (mem:SI (match_operand:SI 2 \"gpc_reg_operand\" \"b\")))])]\n-  \"TARGET_STRING\"\n+    [(set (match_operand:SI 2 \"gpc_reg_operand\" \"\")\n+          (mem:SI (match_operand:SI 1 \"gpc_reg_operand\" \"b\")))\n+     (set (match_operand:SI 3 \"gpc_reg_operand\" \"\")\n+          (mem:SI (plus:SI (match_dup 1) (const_int 4))))\n+     (set (match_operand:SI 4 \"gpc_reg_operand\" \"\")\n+          (mem:SI (plus:SI (match_dup 1) (const_int 8))))\n+     (set (match_operand:SI 5 \"gpc_reg_operand\" \"\")\n+          (mem:SI (plus:SI (match_dup 1) (const_int 12))))\n+     (set (match_operand:SI 6 \"gpc_reg_operand\" \"\")\n+          (mem:SI (plus:SI (match_dup 1) (const_int 16))))\n+     (set (match_operand:SI 7 \"gpc_reg_operand\" \"\")\n+          (mem:SI (plus:SI (match_dup 1) (const_int 20))))\n+     (set (match_operand:SI 8 \"gpc_reg_operand\" \"\")\n+          (mem:SI (plus:SI (match_dup 1) (const_int 24))))\n+     (set (match_operand:SI 9 \"gpc_reg_operand\" \"\")\n+          (mem:SI (plus:SI (match_dup 1) (const_int 28))))])]\n+  \"TARGET_STRING && XVECLEN (operands[0], 0) == 8\"\n   \"*\n-{\n-  /* We have to handle the case where the pseudo used to contain the address\n-     is assigned to one of the output registers.  */\n-  int i, j;\n-  int words = XVECLEN (operands[0], 0);\n-  rtx xop[10];\n+{ return rs6000_output_load_multiple (operands); }\"\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"length\" \"32\")])\n \n-  if (XVECLEN (operands[0], 0) == 1)\n-    return \\\"{l|lwz} %1,0(%2)\\\";\n+(define_insn \"*ldmsi7\"\n+  [(match_parallel 0 \"load_multiple_operation\"\n+    [(set (match_operand:SI 2 \"gpc_reg_operand\" \"\")\n+          (mem:SI (match_operand:SI 1 \"gpc_reg_operand\" \"b\")))\n+     (set (match_operand:SI 3 \"gpc_reg_operand\" \"\")\n+          (mem:SI (plus:SI (match_dup 1) (const_int 4))))\n+     (set (match_operand:SI 4 \"gpc_reg_operand\" \"\")\n+          (mem:SI (plus:SI (match_dup 1) (const_int 8))))\n+     (set (match_operand:SI 5 \"gpc_reg_operand\" \"\")\n+          (mem:SI (plus:SI (match_dup 1) (const_int 12))))\n+     (set (match_operand:SI 6 \"gpc_reg_operand\" \"\")\n+          (mem:SI (plus:SI (match_dup 1) (const_int 16))))\n+     (set (match_operand:SI 7 \"gpc_reg_operand\" \"\")\n+          (mem:SI (plus:SI (match_dup 1) (const_int 20))))\n+     (set (match_operand:SI 8 \"gpc_reg_operand\" \"\")\n+          (mem:SI (plus:SI (match_dup 1) (const_int 24))))])]\n+  \"TARGET_STRING && XVECLEN (operands[0], 0) == 7\"\n+  \"*\n+{ return rs6000_output_load_multiple (operands); }\"\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"length\" \"32\")])\n \n-  for (i = 0; i < words; i++)\n-    if (refers_to_regno_p (REGNO (operands[1]) + i,\n-\t\t\t   REGNO (operands[1]) + i + 1, operands[2], 0))\n-      {\n-\tif (i == words-1)\n-\t  {\n-\t    xop[0] = operands[1];\n-\t    xop[1] = operands[2];\n-\t    xop[2] = GEN_INT (4 * (words-1));\n-\t    output_asm_insn (\\\"{lsi|lswi} %0,%1,%2\\;{l|lwz} %1,%2(%1)\\\", xop);\n-\t    return \\\"\\\";\n-\t  }\n-\telse if (i == 0)\n-\t  {\n-\t    xop[0] = operands[1];\n-\t    xop[1] = gen_rtx_REG (SImode, REGNO (operands[1]) + 1);\n-\t    xop[2] = GEN_INT (4 * (words-1));\n-\t    output_asm_insn (\\\"{cal %0,4(%0)|addi %0,%0,4}\\;{lsi|lswi} %1,%0,%2\\;{l|lwz} %0,-4(%0)\\\", xop);\n-\t    return \\\"\\\";\n-\t  }\n-\telse\n-\t  {\n-\t    for (j = 0; j < words; j++)\n-\t      if (j != i)\n-\t\t{\n-\t\t  xop[0] = gen_rtx_REG (SImode, REGNO (operands[1]) + j);\n-\t\t  xop[1] = operands[2];\n-\t\t  xop[2] = GEN_INT (j * 4);\n-\t\t  output_asm_insn (\\\"{l|lwz} %0,%2(%1)\\\", xop);\n-\t\t}\n-\t    xop[0] = operands[2];\n-\t    xop[1] = GEN_INT (i * 4);\n-\t    output_asm_insn (\\\"{l|lwz} %0,%1(%0)\\\", xop);\n-\t    return \\\"\\\";\n-\t  }\n-      }\n+(define_insn \"*ldmsi6\"\n+  [(match_parallel 0 \"load_multiple_operation\"\n+    [(set (match_operand:SI 2 \"gpc_reg_operand\" \"\")\n+          (mem:SI (match_operand:SI 1 \"gpc_reg_operand\" \"b\")))\n+     (set (match_operand:SI 3 \"gpc_reg_operand\" \"\")\n+          (mem:SI (plus:SI (match_dup 1) (const_int 4))))\n+     (set (match_operand:SI 4 \"gpc_reg_operand\" \"\")\n+          (mem:SI (plus:SI (match_dup 1) (const_int 8))))\n+     (set (match_operand:SI 5 \"gpc_reg_operand\" \"\")\n+          (mem:SI (plus:SI (match_dup 1) (const_int 12))))\n+     (set (match_operand:SI 6 \"gpc_reg_operand\" \"\")\n+          (mem:SI (plus:SI (match_dup 1) (const_int 16))))\n+     (set (match_operand:SI 7 \"gpc_reg_operand\" \"\")\n+          (mem:SI (plus:SI (match_dup 1) (const_int 20))))])]\n+  \"TARGET_STRING && XVECLEN (operands[0], 0) == 6\"\n+  \"*\n+{ return rs6000_output_load_multiple (operands); }\"\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"length\" \"32\")])\n \n-  return \\\"{lsi|lswi} %1,%2,%N0\\\";\n-}\"\n+(define_insn \"*ldmsi5\"\n+  [(match_parallel 0 \"load_multiple_operation\"\n+    [(set (match_operand:SI 2 \"gpc_reg_operand\" \"\")\n+          (mem:SI (match_operand:SI 1 \"gpc_reg_operand\" \"b\")))\n+     (set (match_operand:SI 3 \"gpc_reg_operand\" \"\")\n+          (mem:SI (plus:SI (match_dup 1) (const_int 4))))\n+     (set (match_operand:SI 4 \"gpc_reg_operand\" \"\")\n+          (mem:SI (plus:SI (match_dup 1) (const_int 8))))\n+     (set (match_operand:SI 5 \"gpc_reg_operand\" \"\")\n+          (mem:SI (plus:SI (match_dup 1) (const_int 12))))\n+     (set (match_operand:SI 6 \"gpc_reg_operand\" \"\")\n+          (mem:SI (plus:SI (match_dup 1) (const_int 16))))])]\n+  \"TARGET_STRING && XVECLEN (operands[0], 0) == 5\"\n+  \"*\n+{ return rs6000_output_load_multiple (operands); }\"\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"length\" \"32\")])\n+\n+(define_insn \"*ldmsi4\"\n+  [(match_parallel 0 \"load_multiple_operation\"\n+    [(set (match_operand:SI 2 \"gpc_reg_operand\" \"\")\n+          (mem:SI (match_operand:SI 1 \"gpc_reg_operand\" \"b\")))\n+     (set (match_operand:SI 3 \"gpc_reg_operand\" \"\")\n+          (mem:SI (plus:SI (match_dup 1) (const_int 4))))\n+     (set (match_operand:SI 4 \"gpc_reg_operand\" \"\")\n+          (mem:SI (plus:SI (match_dup 1) (const_int 8))))\n+     (set (match_operand:SI 5 \"gpc_reg_operand\" \"\")\n+          (mem:SI (plus:SI (match_dup 1) (const_int 12))))])]\n+  \"TARGET_STRING && XVECLEN (operands[0], 0) == 4\"\n+  \"*\n+{ return rs6000_output_load_multiple (operands); }\"\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"length\" \"32\")])\n+\n+(define_insn \"*ldmsi3\"\n+  [(match_parallel 0 \"load_multiple_operation\"\n+    [(set (match_operand:SI 2 \"gpc_reg_operand\" \"\")\n+          (mem:SI (match_operand:SI 1 \"gpc_reg_operand\" \"b\")))\n+     (set (match_operand:SI 3 \"gpc_reg_operand\" \"\")\n+          (mem:SI (plus:SI (match_dup 1) (const_int 4))))\n+     (set (match_operand:SI 4 \"gpc_reg_operand\" \"\")\n+          (mem:SI (plus:SI (match_dup 1) (const_int 8))))])]\n+  \"TARGET_STRING && XVECLEN (operands[0], 0) == 3\"\n+  \"*\n+{ return rs6000_output_load_multiple (operands); }\"\n   [(set_attr \"type\" \"load\")\n    (set_attr \"length\" \"32\")])\n \n-\f\n (define_expand \"store_multiple\"\n   [(match_par_dup 3 [(set (match_operand:SI 0 \"\" \"\")\n \t\t\t  (match_operand:SI 1 \"\" \"\"))\n@@ -9474,7 +9529,7 @@\n \t\t     gen_rtx_REG (SImode, regno + i));\n }\")\n \n-(define_insn \"\"\n+(define_insn \"*store_multiple_power\"\n   [(match_parallel 0 \"store_multiple_operation\"\n \t\t   [(set (match_operand:SI 1 \"indirect_operand\" \"=Q\")\n \t\t\t (match_operand:SI 2 \"gpc_reg_operand\" \"r\"))\n@@ -9483,7 +9538,7 @@\n   \"{stsi|stswi} %2,%P1,%O0\"\n   [(set_attr \"type\" \"store\")])\n \n-(define_insn \"\"\n+(define_insn \"*store_multiple_string\"\n   [(match_parallel 0 \"store_multiple_operation\"\n \t\t   [(set (mem:SI (match_operand:SI 1 \"gpc_reg_operand\" \"b\"))\n \t\t\t (match_operand:SI 2 \"gpc_reg_operand\" \"r\"))"}]}