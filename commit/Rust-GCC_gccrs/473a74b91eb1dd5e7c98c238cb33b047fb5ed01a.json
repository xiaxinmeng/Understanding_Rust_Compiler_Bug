{"sha": "473a74b91eb1dd5e7c98c238cb33b047fb5ed01a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDczYTc0YjkxZWIxZGQ1ZTdjOThjMjM4Y2IzM2IwNDdmYjVlZDAxYQ==", "commit": {"author": {"name": "Ben Elliston", "email": "bje@au.ibm.com", "date": "2005-11-28T22:30:30Z"}, "committer": {"name": "Ben Elliston", "email": "bje@gcc.gnu.org", "date": "2005-11-28T22:30:30Z"}, "message": "* libdecnumber: Import decNumber sources from the dfp-branch.\n\nFrom-SVN: r107629", "tree": {"sha": "5fcc2b1fb06bddcda9698d0f0981e68409e0df95", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5fcc2b1fb06bddcda9698d0f0981e68409e0df95"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/473a74b91eb1dd5e7c98c238cb33b047fb5ed01a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/473a74b91eb1dd5e7c98c238cb33b047fb5ed01a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/473a74b91eb1dd5e7c98c238cb33b047fb5ed01a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/473a74b91eb1dd5e7c98c238cb33b047fb5ed01a/comments", "author": null, "committer": null, "parents": [{"sha": "e669bd2b69b82732454e51c8b9c2cad26ea8bbd7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e669bd2b69b82732454e51c8b9c2cad26ea8bbd7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e669bd2b69b82732454e51c8b9c2cad26ea8bbd7"}], "stats": {"total": 9071, "additions": 9071, "deletions": 0}, "files": [{"sha": "00518f22c6fe127190a6877816a0b763b869bf22", "filename": "ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/473a74b91eb1dd5e7c98c238cb33b047fb5ed01a/ChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/473a74b91eb1dd5e7c98c238cb33b047fb5ed01a/ChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/ChangeLog?ref=473a74b91eb1dd5e7c98c238cb33b047fb5ed01a", "patch": "@@ -1,3 +1,7 @@\n+2005-11-29  Ben Elliston  <bje@au.ibm.com>\n+\n+\t* libdecnumber: Import decNumber sources from the dfp-branch.\n+\n 2005-11-21  Kean Johnston  <jkj@sco.com>\n \n \t* config.sub, config.guess: Sync from upstream sources."}, {"sha": "64730aeded31999b893d7ca36faa0e0f2be19f81", "filename": "libdecnumber/ChangeLog", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/473a74b91eb1dd5e7c98c238cb33b047fb5ed01a/libdecnumber%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/473a74b91eb1dd5e7c98c238cb33b047fb5ed01a/libdecnumber%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libdecnumber%2FChangeLog?ref=473a74b91eb1dd5e7c98c238cb33b047fb5ed01a", "patch": "@@ -0,0 +1,9 @@\n+2005-11-29  Ben Elliston  <bje@au.ibm.com>\n+\n+\t* decimal32.h, decimal64.h, decimal128.h: New.\n+        * decimal32.c, decimal64.c, decimal128.c: Likewise.\n+\t* decContext.c, decContext.h: Likewise.\n+\t* decUtility.c, decUtility.h: Likewise.\n+\t* decNumber.c, decNumber.h, decNumberLocal.h: Likewise.\n+\t* decDPD.h: Likewise.\n+\t* decLibrary.c, decRound.c: Likewise."}, {"sha": "26a7f3bcf4a1541b99fd48ffb90afe32b126e853", "filename": "libdecnumber/decContext.c", "status": "added", "additions": 218, "deletions": 0, "changes": 218, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/473a74b91eb1dd5e7c98c238cb33b047fb5ed01a/libdecnumber%2FdecContext.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/473a74b91eb1dd5e7c98c238cb33b047fb5ed01a/libdecnumber%2FdecContext.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libdecnumber%2FdecContext.c?ref=473a74b91eb1dd5e7c98c238cb33b047fb5ed01a", "patch": "@@ -0,0 +1,218 @@\n+/* Decimal context module for the decNumber C Library.\n+   Copyright (C) 2005 Free Software Foundation, Inc.\n+   Contributed by IBM Corporation.  Author Mike Cowlishaw.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 2, or (at your option) any later\n+   version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+   for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING.  If not, write to the Free\n+   Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+   02111-1307, USA.  */\n+\n+/*  This module compirises the routines for handling the arithmetic\n+    context structures. */\n+\n+#include <string.h>\t\t/* for strcmp */\n+#include \"decContext.h\"\t\t/* context and base types */\n+#include \"decNumberLocal.h\"\t/* decNumber local types, etc. */\n+\n+/* ------------------------------------------------------------------ */\n+/* decContextDefault -- initialize a context structure                */\n+/*                                                                    */\n+/*  context is the structure to be initialized                        */\n+/*  kind selects the required set of default values, one of:          */\n+/*      DEC_INIT_BASE       -- select ANSI X3-274 defaults            */\n+/*      DEC_INIT_DECIMAL32  -- select IEEE 754r defaults, 32-bit      */\n+/*      DEC_INIT_DECIMAL64  -- select IEEE 754r defaults, 64-bit      */\n+/*      DEC_INIT_DECIMAL128 -- select IEEE 754r defaults, 128-bit     */\n+/*      For any other value a valid context is returned, but with     */\n+/*      Invalid_operation set in the status field.                    */\n+/*  returns a context structure with the appropriate initial values.  */\n+/* ------------------------------------------------------------------ */\n+decContext *\n+decContextDefault (decContext * context, Int kind)\n+{\n+  /* set defaults... */\n+  context->digits = 9;\t\t/* 9 digits */\n+  context->emax = DEC_MAX_EMAX;\t/* 9-digit exponents */\n+  context->emin = DEC_MIN_EMIN;\t/* .. balanced */\n+  context->round = DEC_ROUND_HALF_UP;\t/* 0.5 rises */\n+  context->traps = DEC_Errors;\t/* all but informational */\n+  context->status = 0;\t\t/* cleared */\n+  context->clamp = 0;\t\t/* no clamping */\n+#if DECSUBSET\n+  context->extended = 0;\t/* cleared */\n+#endif\n+  switch (kind)\n+    {\n+    case DEC_INIT_BASE:\n+      /* [use defaults] */\n+      break;\n+    case DEC_INIT_DECIMAL32:\n+      context->digits = 7;\t/* digits */\n+      context->emax = 96;\t/* Emax */\n+      context->emin = -95;\t/* Emin */\n+      context->round = DEC_ROUND_HALF_EVEN;\t/* 0.5 to nearest even */\n+      context->traps = 0;\t/* no traps set */\n+      context->clamp = 1;\t/* clamp exponents */\n+#if DECSUBSET\n+      context->extended = 1;\t/* set */\n+#endif\n+      break;\n+    case DEC_INIT_DECIMAL64:\n+      context->digits = 16;\t/* digits */\n+      context->emax = 384;\t/* Emax */\n+      context->emin = -383;\t/* Emin */\n+      context->round = DEC_ROUND_HALF_EVEN;\t/* 0.5 to nearest even */\n+      context->traps = 0;\t/* no traps set */\n+      context->clamp = 1;\t/* clamp exponents */\n+#if DECSUBSET\n+      context->extended = 1;\t/* set */\n+#endif\n+      break;\n+    case DEC_INIT_DECIMAL128:\n+      context->digits = 34;\t/* digits */\n+      context->emax = 6144;\t/* Emax */\n+      context->emin = -6143;\t/* Emin */\n+      context->round = DEC_ROUND_HALF_EVEN;\t/* 0.5 to nearest even */\n+      context->traps = 0;\t/* no traps set */\n+      context->clamp = 1;\t/* clamp exponents */\n+#if DECSUBSET\n+      context->extended = 1;\t/* set */\n+#endif\n+      break;\n+\n+    default:\t\t\t/* invalid Kind */\n+      /* use defaults, and .. */\n+      decContextSetStatus (context, DEC_Invalid_operation);\t/* trap */\n+    }\n+  return context;\n+}\t\t\t\t/* decContextDefault */\n+\n+/* ------------------------------------------------------------------ */\n+/* decContextStatusToString -- convert status flags to a string       */\n+/*                                                                    */\n+/*  context is a context with valid status field                      */\n+/*                                                                    */\n+/*  returns a constant string describing the condition.  If multiple  */\n+/*    (or no) flags are set, a generic constant message is returned.  */\n+/* ------------------------------------------------------------------ */\n+const char *\n+decContextStatusToString (decContext * context)\n+{\n+  Int status = context->status;\n+  if (status == DEC_Conversion_syntax)\n+    return DEC_Condition_CS;\n+  if (status == DEC_Division_by_zero)\n+    return DEC_Condition_DZ;\n+  if (status == DEC_Division_impossible)\n+    return DEC_Condition_DI;\n+  if (status == DEC_Division_undefined)\n+    return DEC_Condition_DU;\n+  if (status == DEC_Inexact)\n+    return DEC_Condition_IE;\n+  if (status == DEC_Insufficient_storage)\n+    return DEC_Condition_IS;\n+  if (status == DEC_Invalid_context)\n+    return DEC_Condition_IC;\n+  if (status == DEC_Invalid_operation)\n+    return DEC_Condition_IO;\n+#if DECSUBSET\n+  if (status == DEC_Lost_digits)\n+    return DEC_Condition_LD;\n+#endif\n+  if (status == DEC_Overflow)\n+    return DEC_Condition_OV;\n+  if (status == DEC_Clamped)\n+    return DEC_Condition_PA;\n+  if (status == DEC_Rounded)\n+    return DEC_Condition_RO;\n+  if (status == DEC_Subnormal)\n+    return DEC_Condition_SU;\n+  if (status == DEC_Underflow)\n+    return DEC_Condition_UN;\n+  if (status == 0)\n+    return DEC_Condition_ZE;\n+  return DEC_Condition_MU;\t/* Multiple errors */\n+}\t\t\t\t/* decContextStatusToString */\n+\n+/* ------------------------------------------------------------------ */\n+/* decContextSetStatusFromString -- set status from a string          */\n+/*                                                                    */\n+/*  context is the controlling context                                */\n+/*  string is a string exactly equal to one that might be returned    */\n+/*            by decContextStatusToString                             */\n+/*                                                                    */\n+/*  The status bit corresponding to the string is set, and a trap     */\n+/*  is raised if appropriate.                                         */\n+/*                                                                    */\n+/*  returns the context structure, unless the string is equal to      */\n+/*    DEC_Condition_MU or is not recognized.  In these cases NULL is  */\n+/*    returned.                                                       */\n+/* ------------------------------------------------------------------ */\n+decContext *\n+decContextSetStatusFromString (decContext * context, char *string)\n+{\n+  if (strcmp (string, DEC_Condition_CS) == 0)\n+    return decContextSetStatus (context, DEC_Conversion_syntax);\n+  if (strcmp (string, DEC_Condition_DZ) == 0)\n+    return decContextSetStatus (context, DEC_Division_by_zero);\n+  if (strcmp (string, DEC_Condition_DI) == 0)\n+    return decContextSetStatus (context, DEC_Division_impossible);\n+  if (strcmp (string, DEC_Condition_DU) == 0)\n+    return decContextSetStatus (context, DEC_Division_undefined);\n+  if (strcmp (string, DEC_Condition_IE) == 0)\n+    return decContextSetStatus (context, DEC_Inexact);\n+  if (strcmp (string, DEC_Condition_IS) == 0)\n+    return decContextSetStatus (context, DEC_Insufficient_storage);\n+  if (strcmp (string, DEC_Condition_IC) == 0)\n+    return decContextSetStatus (context, DEC_Invalid_context);\n+  if (strcmp (string, DEC_Condition_IO) == 0)\n+    return decContextSetStatus (context, DEC_Invalid_operation);\n+#if DECSUBSET\n+  if (strcmp (string, DEC_Condition_LD) == 0)\n+    return decContextSetStatus (context, DEC_Lost_digits);\n+#endif\n+  if (strcmp (string, DEC_Condition_OV) == 0)\n+    return decContextSetStatus (context, DEC_Overflow);\n+  if (strcmp (string, DEC_Condition_PA) == 0)\n+    return decContextSetStatus (context, DEC_Clamped);\n+  if (strcmp (string, DEC_Condition_RO) == 0)\n+    return decContextSetStatus (context, DEC_Rounded);\n+  if (strcmp (string, DEC_Condition_SU) == 0)\n+    return decContextSetStatus (context, DEC_Subnormal);\n+  if (strcmp (string, DEC_Condition_UN) == 0)\n+    return decContextSetStatus (context, DEC_Underflow);\n+  if (strcmp (string, DEC_Condition_ZE) == 0)\n+    return context;\n+  return NULL;\t\t\t/* Multiple status, or unknown */\n+}\t\t\t\t/* decContextSetStatusFromString */\n+\n+/* ------------------------------------------------------------------ */\n+/* decContextSetStatus -- set status and raise trap if appropriate    */\n+/*                                                                    */\n+/*  context is the controlling context                                */\n+/*  status  is the DEC_ exception code                                */\n+/*  returns the context structure                                     */\n+/*                                                                    */\n+/* Control may never return from this routine, if there is a signal   */\n+/* handler and it takes a long jump.                                  */\n+/* ------------------------------------------------------------------ */\n+decContext *\n+decContextSetStatus (decContext * context, uInt status)\n+{\n+  context->status |= status;\n+  if (status & context->traps)\n+    raise (SIGFPE);\n+  return context;\n+}\t\t\t\t/* decContextSetStatus */"}, {"sha": "d011f4f6337040cd19ec68c13f5b41f474d9f2b3", "filename": "libdecnumber/decContext.h", "status": "added", "additions": 178, "deletions": 0, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/473a74b91eb1dd5e7c98c238cb33b047fb5ed01a/libdecnumber%2FdecContext.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/473a74b91eb1dd5e7c98c238cb33b047fb5ed01a/libdecnumber%2FdecContext.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libdecnumber%2FdecContext.h?ref=473a74b91eb1dd5e7c98c238cb33b047fb5ed01a", "patch": "@@ -0,0 +1,178 @@\n+/* Decimal Context module header for the decNumber C Library\n+   Copyright (C) 2005 Free Software Foundation, Inc.\n+   Contributed by IBM Corporation.  Author Mike Cowlishaw.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 2, or (at your option) any later\n+   version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+   for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING.  If not, write to the Free\n+   Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+   02111-1307, USA.  */\n+\n+/* ------------------------------------------------------------------ */\n+/*                                                                    */\n+/* Context must always be set correctly:                              */\n+/*                                                                    */\n+/*  digits   -- must be in the range 1 through 999999999              */\n+/*  emax     -- must be in the range 0 through 999999999              */\n+/*  emin     -- must be in the range 0 through -999999999             */\n+/*  round    -- must be one of the enumerated rounding modes          */\n+/*  traps    -- only defined bits may be set                          */\n+/*  status   -- [any bits may be cleared, but not set, by user]       */\n+/*  clamp    -- must be either 0 or 1                                 */\n+/*  extended -- must be either 0 or 1 [present only if DECSUBSET]     */\n+/*                                                                    */\n+/* ------------------------------------------------------------------ */\n+\n+#if !defined(DECCONTEXT)\n+#define DECCONTEXT\n+#define DECCNAME     \"decContext\"\t/* Short name */\n+#define DECCFULLNAME \"Decimal Context Descriptor\"\t/* Verbose name */\n+#define DECCAUTHOR   \"Mike Cowlishaw\"\t/* Who to blame */\n+\n+#include <stdint.h>\t\t/* C99 standard integers */\n+#include <signal.h>\t\t/* for traps */\n+\n+\n+  /* Conditional code flag -- set this to 0 for best performance */\n+#define DECSUBSET 0\t\t/* 1 to enable subset arithmetic */\n+\n+  /* Context for operations, with associated constants */\n+enum rounding\n+{\n+  DEC_ROUND_CEILING,\t\t/* round towards +infinity */\n+  DEC_ROUND_UP,\t\t\t/* round away from 0 */\n+  DEC_ROUND_HALF_UP,\t\t/* 0.5 rounds up */\n+  DEC_ROUND_HALF_EVEN,\t\t/* 0.5 rounds to nearest even */\n+  DEC_ROUND_HALF_DOWN,\t\t/* 0.5 rounds down */\n+  DEC_ROUND_DOWN,\t\t/* round towards 0 (truncate) */\n+  DEC_ROUND_FLOOR,\t\t/* round towards -infinity */\n+  DEC_ROUND_MAX\t\t\t/* enum must be less than this */\n+};\n+\n+typedef struct\n+{\n+  int32_t digits;\t\t/* working precision */\n+  int32_t emax;\t\t\t/* maximum positive exponent */\n+  int32_t emin;\t\t\t/* minimum negative exponent */\n+  enum rounding round;\t\t/* rounding mode */\n+  uint32_t traps;\t\t/* trap-enabler flags */\n+  uint32_t status;\t\t/* status flags */\n+  uint8_t clamp;\t\t/* flag: apply IEEE exponent clamp */\n+#if DECSUBSET\n+  uint8_t extended;\t\t/* flag: special-values allowed */\n+#endif\n+} decContext;\n+\n+  /* Maxima and Minima */\n+#define DEC_MAX_DIGITS 999999999\n+#define DEC_MIN_DIGITS         1\n+#define DEC_MAX_EMAX   999999999\n+#define DEC_MIN_EMAX           0\n+#define DEC_MAX_EMIN           0\n+#define DEC_MIN_EMIN  -999999999\n+\n+  /* Trap-enabler and Status flags (exceptional conditions), and their names */\n+  /* Top byte is reserved for internal use */\n+#define DEC_Conversion_syntax    0x00000001\n+#define DEC_Division_by_zero     0x00000002\n+#define DEC_Division_impossible  0x00000004\n+#define DEC_Division_undefined   0x00000008\n+#define DEC_Insufficient_storage 0x00000010\t/* [used if malloc fails] */\n+#define DEC_Inexact              0x00000020\n+#define DEC_Invalid_context      0x00000040\n+#define DEC_Invalid_operation    0x00000080\n+#if DECSUBSET\n+#define DEC_Lost_digits          0x00000100\n+#endif\n+#define DEC_Overflow             0x00000200\n+#define DEC_Clamped              0x00000400\n+#define DEC_Rounded              0x00000800\n+#define DEC_Subnormal            0x00001000\n+#define DEC_Underflow            0x00002000\n+\n+  /* IEEE 854 groupings for the flags */\n+  /* [DEC_Clamped, DEC_Lost_digits, DEC_Rounded, and DEC_Subnormal are */\n+  /* not in IEEE 854] */\n+#define DEC_IEEE_854_Division_by_zero  (DEC_Division_by_zero)\n+#if DECSUBSET\n+#define DEC_IEEE_854_Inexact           (DEC_Inexact | DEC_Lost_digits)\n+#else\n+#define DEC_IEEE_854_Inexact           (DEC_Inexact)\n+#endif\n+#define DEC_IEEE_854_Invalid_operation (DEC_Conversion_syntax |     \\\n+                                          DEC_Division_impossible |   \\\n+                                          DEC_Division_undefined |    \\\n+                                          DEC_Insufficient_storage |  \\\n+                                          DEC_Invalid_context |       \\\n+                                          DEC_Invalid_operation)\n+#define DEC_IEEE_854_Overflow          (DEC_Overflow)\n+#define DEC_IEEE_854_Underflow         (DEC_Underflow)\n+\n+  /* flags which are normally errors (results are qNaN, infinite, or 0) */\n+#define DEC_Errors (DEC_IEEE_854_Division_by_zero |                 \\\n+                      DEC_IEEE_854_Invalid_operation |                \\\n+                      DEC_IEEE_854_Overflow | DEC_IEEE_854_Underflow)\n+  /* flags which cause a result to become qNaN */\n+#define DEC_NaNs    DEC_IEEE_854_Invalid_operation\n+\n+  /* flags which are normally for information only (have finite results) */\n+#if DECSUBSET\n+#define DEC_Information (DEC_Clamped | DEC_Rounded | DEC_Inexact     \\\n+                          | DEC_Lost_digits)\n+#else\n+#define DEC_Information (DEC_Clamped | DEC_Rounded | DEC_Inexact)\n+#endif\n+\n+  /* name strings for the exceptional conditions */\n+\n+#define DEC_Condition_CS \"Conversion syntax\"\n+#define DEC_Condition_DZ \"Division by zero\"\n+#define DEC_Condition_DI \"Division impossible\"\n+#define DEC_Condition_DU \"Division undefined\"\n+#define DEC_Condition_IE \"Inexact\"\n+#define DEC_Condition_IS \"Insufficient storage\"\n+#define DEC_Condition_IC \"Invalid context\"\n+#define DEC_Condition_IO \"Invalid operation\"\n+#if DECSUBSET\n+#define DEC_Condition_LD \"Lost digits\"\n+#endif\n+#define DEC_Condition_OV \"Overflow\"\n+#define DEC_Condition_PA \"Clamped\"\n+#define DEC_Condition_RO \"Rounded\"\n+#define DEC_Condition_SU \"Subnormal\"\n+#define DEC_Condition_UN \"Underflow\"\n+#define DEC_Condition_ZE \"No status\"\n+#define DEC_Condition_MU \"Multiple status\"\n+#define DEC_Condition_Length 21\t/* length of the longest string, */\n+\t\t\t\t   /* including terminator */\n+\n+  /* Initialization descriptors, used by decContextDefault */\n+#define DEC_INIT_BASE         0\n+#define DEC_INIT_DECIMAL32   32\n+#define DEC_INIT_DECIMAL64   64\n+#define DEC_INIT_DECIMAL128 128\n+\n+  /* decContext routines */\n+#ifdef IN_LIBGCC2\n+#define decContextDefault __decContextDefault\n+#define decContextSetStatus __decContextSetStatus\n+#define decContextStatusToString __decContextStatusToString\n+#define decContextSetStatusFromString __decContextSetStatusFromString\n+#endif\n+decContext *decContextDefault (decContext *, int32_t);\n+decContext *decContextSetStatus (decContext *, uint32_t);\n+const char *decContextStatusToString (decContext *);\n+decContext *decContextSetStatusFromString (decContext *, char *);\n+\n+#endif"}, {"sha": "827b675c628fbed1c6cb348e58bb8482eb76769b", "filename": "libdecnumber/decDPD.h", "status": "added", "additions": 525, "deletions": 0, "changes": 525, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/473a74b91eb1dd5e7c98c238cb33b047fb5ed01a/libdecnumber%2FdecDPD.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/473a74b91eb1dd5e7c98c238cb33b047fb5ed01a/libdecnumber%2FdecDPD.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libdecnumber%2FdecDPD.h?ref=473a74b91eb1dd5e7c98c238cb33b047fb5ed01a", "patch": "@@ -0,0 +1,525 @@\n+/* Binary Coded Decimal <--> Densely Packed Decimal lookup tables.\n+   Copyright (C) 2005 Free Software Foundation, Inc.\n+   Contributed by IBM Corporation.  Author Mike Cowlishaw.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 2, or (at your option) any later\n+   version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+   for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING.  If not, write to the Free\n+   Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+   02111-1307, USA.  */\n+\n+/* ------------------------------------------------------------------------ */\n+/* For details, see: http://www2.hursley.ibm.com/decimal/DPDecimal.html     */\n+/*                                                                          */\n+/* This include file defines conversion tables for DPD, as follows.         */\n+/*                                                                          */\n+/*   uint16_t BCD2DPD[2458];     // BCD -> DPD (0x999 => 2457)              */\n+/*   uint16_t DPD2BCD[1024];     // DPD -> BCD (0x3FF => 0x999)             */\n+/*   uint16_t BIN2DPD[1000];     // BIN -> DPD (999 => 2457)                */\n+/*   uint16_t DPD2BIN[1024];     // DPD -> BIN (0x3FF => 999)               */\n+/*                                                                          */\n+/* In all cases the result (10 bits or 12 bits, or binary) is right-aligned */\n+/* in the table entry.                                                      */\n+/*                                                                          */\n+/* To use a table, its name, prefixed with DEC_, must be defined with a     */\n+/* value of 1 before this header file is included.  For example:            */\n+/*    #define DEC_BCD2DPD 1                                                 */\n+/* ------------------------------------------------------------------------ */\n+\n+#if DEC_BCD2DPD==1\n+\n+const uint16_t BCD2DPD[2458] = { 0, 1, 2, 3, 4, 5, 6, 7,\n+  8, 9, 0, 0, 0, 0, 0, 0, 16, 17, 18, 19, 20,\n+  21, 22, 23, 24, 25, 0, 0, 0, 0, 0, 0, 32, 33,\n+  34, 35, 36, 37, 38, 39, 40, 41, 0, 0, 0, 0, 0,\n+  0, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 0, 0,\n+  0, 0, 0, 0, 64, 65, 66, 67, 68, 69, 70, 71, 72,\n+  73, 0, 0, 0, 0, 0, 0, 80, 81, 82, 83, 84, 85,\n+  86, 87, 88, 89, 0, 0, 0, 0, 0, 0, 96, 97, 98,\n+  99, 100, 101, 102, 103, 104, 105, 0, 0, 0, 0, 0, 0,\n+  112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 0, 0, 0,\n+  0, 0, 0, 10, 11, 42, 43, 74, 75, 106, 107, 78, 79,\n+  0, 0, 0, 0, 0, 0, 26, 27, 58, 59, 90, 91, 122,\n+  123, 94, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0, 10, 11, 42, 43, 74,\n+  75, 106, 107, 78, 79, 0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 0, 0,\n+  0, 0, 0, 0, 144, 145, 146, 147, 148, 149, 150, 151, 152,\n+  153, 0, 0, 0, 0, 0, 0, 160, 161, 162, 163, 164, 165,\n+  166, 167, 168, 169, 0, 0, 0, 0, 0, 0, 176, 177, 178,\n+  179, 180, 181, 182, 183, 184, 185, 0, 0, 0, 0, 0, 0,\n+  192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 0, 0, 0,\n+  0, 0, 0, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217,\n+  0, 0, 0, 0, 0, 0, 224, 225, 226, 227, 228, 229, 230,\n+  231, 232, 233, 0, 0, 0, 0, 0, 0, 240, 241, 242, 243,\n+  244, 245, 246, 247, 248, 249, 0, 0, 0, 0, 0, 0, 138,\n+  139, 170, 171, 202, 203, 234, 235, 206, 207, 0, 0, 0, 0,\n+  0, 0, 154, 155, 186, 187, 218, 219, 250, 251, 222, 223, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 0, 0, 0, 138, 139, 170, 171, 202, 203, 234, 235, 206,\n+  207, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 256, 257, 258,\n+  259, 260, 261, 262, 263, 264, 265, 0, 0, 0, 0, 0, 0,\n+  272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 0, 0, 0,\n+  0, 0, 0, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297,\n+  0, 0, 0, 0, 0, 0, 304, 305, 306, 307, 308, 309, 310,\n+  311, 312, 313, 0, 0, 0, 0, 0, 0, 320, 321, 322, 323,\n+  324, 325, 326, 327, 328, 329, 0, 0, 0, 0, 0, 0, 336,\n+  337, 338, 339, 340, 341, 342, 343, 344, 345, 0, 0, 0, 0,\n+  0, 0, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 0,\n+  0, 0, 0, 0, 0, 368, 369, 370, 371, 372, 373, 374, 375,\n+  376, 377, 0, 0, 0, 0, 0, 0, 266, 267, 298, 299, 330,\n+  331, 362, 363, 334, 335, 0, 0, 0, 0, 0, 0, 282, 283,\n+  314, 315, 346, 347, 378, 379, 350, 351, 0, 0, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+  266, 267, 298, 299, 330, 331, 362, 363, 334, 335, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0, 384, 385, 386, 387, 388, 389, 390,\n+  391, 392, 393, 0, 0, 0, 0, 0, 0, 400, 401, 402, 403,\n+  404, 405, 406, 407, 408, 409, 0, 0, 0, 0, 0, 0, 416,\n+  417, 418, 419, 420, 421, 422, 423, 424, 425, 0, 0, 0, 0,\n+  0, 0, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 0,\n+  0, 0, 0, 0, 0, 448, 449, 450, 451, 452, 453, 454, 455,\n+  456, 457, 0, 0, 0, 0, 0, 0, 464, 465, 466, 467, 468,\n+  469, 470, 471, 472, 473, 0, 0, 0, 0, 0, 0, 480, 481,\n+  482, 483, 484, 485, 486, 487, 488, 489, 0, 0, 0, 0, 0,\n+  0, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 0, 0,\n+  0, 0, 0, 0, 394, 395, 426, 427, 458, 459, 490, 491, 462,\n+  463, 0, 0, 0, 0, 0, 0, 410, 411, 442, 443, 474, 475,\n+  506, 507, 478, 479, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 394, 395, 426, 427,\n+  458, 459, 490, 491, 462, 463, 0, 0, 0, 0, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 0, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 0,\n+  0, 0, 0, 0, 0, 528, 529, 530, 531, 532, 533, 534, 535,\n+  536, 537, 0, 0, 0, 0, 0, 0, 544, 545, 546, 547, 548,\n+  549, 550, 551, 552, 553, 0, 0, 0, 0, 0, 0, 560, 561,\n+  562, 563, 564, 565, 566, 567, 568, 569, 0, 0, 0, 0, 0,\n+  0, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 0, 0,\n+  0, 0, 0, 0, 592, 593, 594, 595, 596, 597, 598, 599, 600,\n+  601, 0, 0, 0, 0, 0, 0, 608, 609, 610, 611, 612, 613,\n+  614, 615, 616, 617, 0, 0, 0, 0, 0, 0, 624, 625, 626,\n+  627, 628, 629, 630, 631, 632, 633, 0, 0, 0, 0, 0, 0,\n+  522, 523, 554, 555, 586, 587, 618, 619, 590, 591, 0, 0, 0,\n+  0, 0, 0, 538, 539, 570, 571, 602, 603, 634, 635, 606, 607,\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 0, 0, 0, 0, 522, 523, 554, 555, 586, 587, 618, 619,\n+  590, 591, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 640, 641,\n+  642, 643, 644, 645, 646, 647, 648, 649, 0, 0, 0, 0, 0,\n+  0, 656, 657, 658, 659, 660, 661, 662, 663, 664, 665, 0, 0,\n+  0, 0, 0, 0, 672, 673, 674, 675, 676, 677, 678, 679, 680,\n+  681, 0, 0, 0, 0, 0, 0, 688, 689, 690, 691, 692, 693,\n+  694, 695, 696, 697, 0, 0, 0, 0, 0, 0, 704, 705, 706,\n+  707, 708, 709, 710, 711, 712, 713, 0, 0, 0, 0, 0, 0,\n+  720, 721, 722, 723, 724, 725, 726, 727, 728, 729, 0, 0, 0,\n+  0, 0, 0, 736, 737, 738, 739, 740, 741, 742, 743, 744, 745,\n+  0, 0, 0, 0, 0, 0, 752, 753, 754, 755, 756, 757, 758,\n+  759, 760, 761, 0, 0, 0, 0, 0, 0, 650, 651, 682, 683,\n+  714, 715, 746, 747, 718, 719, 0, 0, 0, 0, 0, 0, 666,\n+  667, 698, 699, 730, 731, 762, 763, 734, 735, 0, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 650, 651, 682, 683, 714, 715, 746, 747, 718, 719, 0, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0, 0, 768, 769, 770, 771, 772, 773,\n+  774, 775, 776, 777, 0, 0, 0, 0, 0, 0, 784, 785, 786,\n+  787, 788, 789, 790, 791, 792, 793, 0, 0, 0, 0, 0, 0,\n+  800, 801, 802, 803, 804, 805, 806, 807, 808, 809, 0, 0, 0,\n+  0, 0, 0, 816, 817, 818, 819, 820, 821, 822, 823, 824, 825,\n+  0, 0, 0, 0, 0, 0, 832, 833, 834, 835, 836, 837, 838,\n+  839, 840, 841, 0, 0, 0, 0, 0, 0, 848, 849, 850, 851,\n+  852, 853, 854, 855, 856, 857, 0, 0, 0, 0, 0, 0, 864,\n+  865, 866, 867, 868, 869, 870, 871, 872, 873, 0, 0, 0, 0,\n+  0, 0, 880, 881, 882, 883, 884, 885, 886, 887, 888, 889, 0,\n+  0, 0, 0, 0, 0, 778, 779, 810, 811, 842, 843, 874, 875,\n+  846, 847, 0, 0, 0, 0, 0, 0, 794, 795, 826, 827, 858,\n+  859, 890, 891, 862, 863, 0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 778, 779, 810,\n+  811, 842, 843, 874, 875, 846, 847, 0, 0, 0, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 0, 0, 896, 897, 898, 899, 900, 901, 902, 903, 904, 905,\n+  0, 0, 0, 0, 0, 0, 912, 913, 914, 915, 916, 917, 918,\n+  919, 920, 921, 0, 0, 0, 0, 0, 0, 928, 929, 930, 931,\n+  932, 933, 934, 935, 936, 937, 0, 0, 0, 0, 0, 0, 944,\n+  945, 946, 947, 948, 949, 950, 951, 952, 953, 0, 0, 0, 0,\n+  0, 0, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 0,\n+  0, 0, 0, 0, 0, 976, 977, 978, 979, 980, 981, 982, 983,\n+  984, 985, 0, 0, 0, 0, 0, 0, 992, 993, 994, 995, 996,\n+  997, 998, 999, 1000, 1001, 0, 0, 0, 0, 0, 0, 1008, 1009,\n+  1010, 1011, 1012, 1013, 1014, 1015, 1016, 1017, 0, 0, 0, 0, 0,\n+  0, 906, 907, 938, 939, 970, 971, 1002, 1003, 974, 975, 0, 0,\n+  0, 0, 0, 0, 922, 923, 954, 955, 986, 987, 1018, 1019, 990,\n+  991, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0, 906, 907, 938, 939, 970, 971, 1002,\n+  1003, 974, 975, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12,\n+  13, 268, 269, 524, 525, 780, 781, 46, 47, 0, 0, 0, 0,\n+  0, 0, 28, 29, 284, 285, 540, 541, 796, 797, 62, 63, 0,\n+  0, 0, 0, 0, 0, 44, 45, 300, 301, 556, 557, 812, 813,\n+  302, 303, 0, 0, 0, 0, 0, 0, 60, 61, 316, 317, 572,\n+  573, 828, 829, 318, 319, 0, 0, 0, 0, 0, 0, 76, 77,\n+  332, 333, 588, 589, 844, 845, 558, 559, 0, 0, 0, 0, 0,\n+  0, 92, 93, 348, 349, 604, 605, 860, 861, 574, 575, 0, 0,\n+  0, 0, 0, 0, 108, 109, 364, 365, 620, 621, 876, 877, 814,\n+  815, 0, 0, 0, 0, 0, 0, 124, 125, 380, 381, 636, 637,\n+  892, 893, 830, 831, 0, 0, 0, 0, 0, 0, 14, 15, 270,\n+  271, 526, 527, 782, 783, 110, 111, 0, 0, 0, 0, 0, 0,\n+  30, 31, 286, 287, 542, 543, 798, 799, 126, 127, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 0, 14, 15, 270, 271, 526, 527, 782, 783, 110, 111, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0, 140, 141, 396, 397, 652,\n+  653, 908, 909, 174, 175, 0, 0, 0, 0, 0, 0, 156, 157,\n+  412, 413, 668, 669, 924, 925, 190, 191, 0, 0, 0, 0, 0,\n+  0, 172, 173, 428, 429, 684, 685, 940, 941, 430, 431, 0, 0,\n+  0, 0, 0, 0, 188, 189, 444, 445, 700, 701, 956, 957, 446,\n+  447, 0, 0, 0, 0, 0, 0, 204, 205, 460, 461, 716, 717,\n+  972, 973, 686, 687, 0, 0, 0, 0, 0, 0, 220, 221, 476,\n+  477, 732, 733, 988, 989, 702, 703, 0, 0, 0, 0, 0, 0,\n+  236, 237, 492, 493, 748, 749, 1004, 1005, 942, 943, 0, 0, 0,\n+  0, 0, 0, 252, 253, 508, 509, 764, 765, 1020, 1021, 958, 959,\n+  0, 0, 0, 0, 0, 0, 142, 143, 398, 399, 654, 655, 910,\n+  911, 238, 239, 0, 0, 0, 0, 0, 0, 158, 159, 414, 415,\n+  670, 671, 926, 927, 254, 255\n+};\n+#endif\n+\n+#if DEC_DPD2BCD==1\n+\n+const uint16_t DPD2BCD[1024] = { 0, 1, 2, 3, 4, 5, 6, 7,\n+  8, 9, 128, 129, 2048, 2049, 2176, 2177, 16, 17, 18, 19, 20,\n+  21, 22, 23, 24, 25, 144, 145, 2064, 2065, 2192, 2193, 32, 33,\n+  34, 35, 36, 37, 38, 39, 40, 41, 130, 131, 2080, 2081, 2056,\n+  2057, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 146, 147,\n+  2096, 2097, 2072, 2073, 64, 65, 66, 67, 68, 69, 70, 71, 72,\n+  73, 132, 133, 2112, 2113, 136, 137, 80, 81, 82, 83, 84, 85,\n+  86, 87, 88, 89, 148, 149, 2128, 2129, 152, 153, 96, 97, 98,\n+  99, 100, 101, 102, 103, 104, 105, 134, 135, 2144, 2145, 2184, 2185,\n+  112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 150, 151, 2160,\n+  2161, 2200, 2201, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265,\n+  384, 385, 2304, 2305, 2432, 2433, 272, 273, 274, 275, 276, 277, 278,\n+  279, 280, 281, 400, 401, 2320, 2321, 2448, 2449, 288, 289, 290, 291,\n+  292, 293, 294, 295, 296, 297, 386, 387, 2336, 2337, 2312, 2313, 304,\n+  305, 306, 307, 308, 309, 310, 311, 312, 313, 402, 403, 2352, 2353,\n+  2328, 2329, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 388,\n+  389, 2368, 2369, 392, 393, 336, 337, 338, 339, 340, 341, 342, 343,\n+  344, 345, 404, 405, 2384, 2385, 408, 409, 352, 353, 354, 355, 356,\n+  357, 358, 359, 360, 361, 390, 391, 2400, 2401, 2440, 2441, 368, 369,\n+  370, 371, 372, 373, 374, 375, 376, 377, 406, 407, 2416, 2417, 2456,\n+  2457, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 640, 641,\n+  2050, 2051, 2178, 2179, 528, 529, 530, 531, 532, 533, 534, 535, 536,\n+  537, 656, 657, 2066, 2067, 2194, 2195, 544, 545, 546, 547, 548, 549,\n+  550, 551, 552, 553, 642, 643, 2082, 2083, 2088, 2089, 560, 561, 562,\n+  563, 564, 565, 566, 567, 568, 569, 658, 659, 2098, 2099, 2104, 2105,\n+  576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 644, 645, 2114,\n+  2115, 648, 649, 592, 593, 594, 595, 596, 597, 598, 599, 600, 601,\n+  660, 661, 2130, 2131, 664, 665, 608, 609, 610, 611, 612, 613, 614,\n+  615, 616, 617, 646, 647, 2146, 2147, 2184, 2185, 624, 625, 626, 627,\n+  628, 629, 630, 631, 632, 633, 662, 663, 2162, 2163, 2200, 2201, 768,\n+  769, 770, 771, 772, 773, 774, 775, 776, 777, 896, 897, 2306, 2307,\n+  2434, 2435, 784, 785, 786, 787, 788, 789, 790, 791, 792, 793, 912,\n+  913, 2322, 2323, 2450, 2451, 800, 801, 802, 803, 804, 805, 806, 807,\n+  808, 809, 898, 899, 2338, 2339, 2344, 2345, 816, 817, 818, 819, 820,\n+  821, 822, 823, 824, 825, 914, 915, 2354, 2355, 2360, 2361, 832, 833,\n+  834, 835, 836, 837, 838, 839, 840, 841, 900, 901, 2370, 2371, 904,\n+  905, 848, 849, 850, 851, 852, 853, 854, 855, 856, 857, 916, 917,\n+  2386, 2387, 920, 921, 864, 865, 866, 867, 868, 869, 870, 871, 872,\n+  873, 902, 903, 2402, 2403, 2440, 2441, 880, 881, 882, 883, 884, 885,\n+  886, 887, 888, 889, 918, 919, 2418, 2419, 2456, 2457, 1024, 1025, 1026,\n+  1027, 1028, 1029, 1030, 1031, 1032, 1033, 1152, 1153, 2052, 2053, 2180,\n+    2181,\n+  1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1168, 1169,\n+    2068,\n+  2069, 2196, 2197, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064,\n+    1065,\n+  1154, 1155, 2084, 2085, 2120, 2121, 1072, 1073, 1074, 1075, 1076, 1077,\n+    1078,\n+  1079, 1080, 1081, 1170, 1171, 2100, 2101, 2136, 2137, 1088, 1089, 1090,\n+    1091,\n+  1092, 1093, 1094, 1095, 1096, 1097, 1156, 1157, 2116, 2117, 1160, 1161,\n+    1104,\n+  1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1172, 1173, 2132,\n+    2133,\n+  1176, 1177, 1120, 1121, 1122, 1123, 1124, 1125, 1126, 1127, 1128, 1129,\n+    1158,\n+  1159, 2148, 2149, 2184, 2185, 1136, 1137, 1138, 1139, 1140, 1141, 1142,\n+    1143,\n+  1144, 1145, 1174, 1175, 2164, 2165, 2200, 2201, 1280, 1281, 1282, 1283,\n+    1284,\n+  1285, 1286, 1287, 1288, 1289, 1408, 1409, 2308, 2309, 2436, 2437, 1296,\n+    1297,\n+  1298, 1299, 1300, 1301, 1302, 1303, 1304, 1305, 1424, 1425, 2324, 2325,\n+    2452,\n+  2453, 1312, 1313, 1314, 1315, 1316, 1317, 1318, 1319, 1320, 1321, 1410,\n+    1411,\n+  2340, 2341, 2376, 2377, 1328, 1329, 1330, 1331, 1332, 1333, 1334, 1335,\n+    1336,\n+  1337, 1426, 1427, 2356, 2357, 2392, 2393, 1344, 1345, 1346, 1347, 1348,\n+    1349,\n+  1350, 1351, 1352, 1353, 1412, 1413, 2372, 2373, 1416, 1417, 1360, 1361,\n+    1362,\n+  1363, 1364, 1365, 1366, 1367, 1368, 1369, 1428, 1429, 2388, 2389, 1432,\n+    1433,\n+  1376, 1377, 1378, 1379, 1380, 1381, 1382, 1383, 1384, 1385, 1414, 1415,\n+    2404,\n+  2405, 2440, 2441, 1392, 1393, 1394, 1395, 1396, 1397, 1398, 1399, 1400,\n+    1401,\n+  1430, 1431, 2420, 2421, 2456, 2457, 1536, 1537, 1538, 1539, 1540, 1541,\n+    1542,\n+  1543, 1544, 1545, 1664, 1665, 2054, 2055, 2182, 2183, 1552, 1553, 1554,\n+    1555,\n+  1556, 1557, 1558, 1559, 1560, 1561, 1680, 1681, 2070, 2071, 2198, 2199,\n+    1568,\n+  1569, 1570, 1571, 1572, 1573, 1574, 1575, 1576, 1577, 1666, 1667, 2086,\n+    2087,\n+  2152, 2153, 1584, 1585, 1586, 1587, 1588, 1589, 1590, 1591, 1592, 1593,\n+    1682,\n+  1683, 2102, 2103, 2168, 2169, 1600, 1601, 1602, 1603, 1604, 1605, 1606,\n+    1607,\n+  1608, 1609, 1668, 1669, 2118, 2119, 1672, 1673, 1616, 1617, 1618, 1619,\n+    1620,\n+  1621, 1622, 1623, 1624, 1625, 1684, 1685, 2134, 2135, 1688, 1689, 1632,\n+    1633,\n+  1634, 1635, 1636, 1637, 1638, 1639, 1640, 1641, 1670, 1671, 2150, 2151,\n+    2184,\n+  2185, 1648, 1649, 1650, 1651, 1652, 1653, 1654, 1655, 1656, 1657, 1686,\n+    1687,\n+  2166, 2167, 2200, 2201, 1792, 1793, 1794, 1795, 1796, 1797, 1798, 1799,\n+    1800,\n+  1801, 1920, 1921, 2310, 2311, 2438, 2439, 1808, 1809, 1810, 1811, 1812,\n+    1813,\n+  1814, 1815, 1816, 1817, 1936, 1937, 2326, 2327, 2454, 2455, 1824, 1825,\n+    1826,\n+  1827, 1828, 1829, 1830, 1831, 1832, 1833, 1922, 1923, 2342, 2343, 2408,\n+    2409,\n+  1840, 1841, 1842, 1843, 1844, 1845, 1846, 1847, 1848, 1849, 1938, 1939,\n+    2358,\n+  2359, 2424, 2425, 1856, 1857, 1858, 1859, 1860, 1861, 1862, 1863, 1864,\n+    1865,\n+  1924, 1925, 2374, 2375, 1928, 1929, 1872, 1873, 1874, 1875, 1876, 1877,\n+    1878,\n+  1879, 1880, 1881, 1940, 1941, 2390, 2391, 1944, 1945, 1888, 1889, 1890,\n+    1891,\n+  1892, 1893, 1894, 1895, 1896, 1897, 1926, 1927, 2406, 2407, 2440, 2441,\n+    1904,\n+  1905, 1906, 1907, 1908, 1909, 1910, 1911, 1912, 1913, 1942, 1943, 2422,\n+    2423,\n+  2456, 2457\n+};\n+#endif\n+\n+#if DEC_BIN2DPD==1\n+\n+const uint16_t BIN2DPD[1000] = { 0, 1, 2, 3, 4, 5, 6, 7,\n+  8, 9, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 32,\n+  33, 34, 35, 36, 37, 38, 39, 40, 41, 48, 49, 50, 51,\n+  52, 53, 54, 55, 56, 57, 64, 65, 66, 67, 68, 69, 70,\n+  71, 72, 73, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89,\n+  96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 112, 113, 114,\n+  115, 116, 117, 118, 119, 120, 121, 10, 11, 42, 43, 74, 75,\n+  106, 107, 78, 79, 26, 27, 58, 59, 90, 91, 122, 123, 94,\n+  95, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 144, 145,\n+  146, 147, 148, 149, 150, 151, 152, 153, 160, 161, 162, 163, 164,\n+  165, 166, 167, 168, 169, 176, 177, 178, 179, 180, 181, 182, 183,\n+  184, 185, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 208,\n+  209, 210, 211, 212, 213, 214, 215, 216, 217, 224, 225, 226, 227,\n+  228, 229, 230, 231, 232, 233, 240, 241, 242, 243, 244, 245, 246,\n+  247, 248, 249, 138, 139, 170, 171, 202, 203, 234, 235, 206, 207,\n+  154, 155, 186, 187, 218, 219, 250, 251, 222, 223, 256, 257, 258,\n+  259, 260, 261, 262, 263, 264, 265, 272, 273, 274, 275, 276, 277,\n+  278, 279, 280, 281, 288, 289, 290, 291, 292, 293, 294, 295, 296,\n+  297, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 320, 321,\n+  322, 323, 324, 325, 326, 327, 328, 329, 336, 337, 338, 339, 340,\n+  341, 342, 343, 344, 345, 352, 353, 354, 355, 356, 357, 358, 359,\n+  360, 361, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 266,\n+  267, 298, 299, 330, 331, 362, 363, 334, 335, 282, 283, 314, 315,\n+  346, 347, 378, 379, 350, 351, 384, 385, 386, 387, 388, 389, 390,\n+  391, 392, 393, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409,\n+  416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 432, 433, 434,\n+  435, 436, 437, 438, 439, 440, 441, 448, 449, 450, 451, 452, 453,\n+  454, 455, 456, 457, 464, 465, 466, 467, 468, 469, 470, 471, 472,\n+  473, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 496, 497,\n+  498, 499, 500, 501, 502, 503, 504, 505, 394, 395, 426, 427, 458,\n+  459, 490, 491, 462, 463, 410, 411, 442, 443, 474, 475, 506, 507,\n+  478, 479, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 528,\n+  529, 530, 531, 532, 533, 534, 535, 536, 537, 544, 545, 546, 547,\n+  548, 549, 550, 551, 552, 553, 560, 561, 562, 563, 564, 565, 566,\n+  567, 568, 569, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585,\n+  592, 593, 594, 595, 596, 597, 598, 599, 600, 601, 608, 609, 610,\n+  611, 612, 613, 614, 615, 616, 617, 624, 625, 626, 627, 628, 629,\n+  630, 631, 632, 633, 522, 523, 554, 555, 586, 587, 618, 619, 590,\n+  591, 538, 539, 570, 571, 602, 603, 634, 635, 606, 607, 640, 641,\n+  642, 643, 644, 645, 646, 647, 648, 649, 656, 657, 658, 659, 660,\n+  661, 662, 663, 664, 665, 672, 673, 674, 675, 676, 677, 678, 679,\n+  680, 681, 688, 689, 690, 691, 692, 693, 694, 695, 696, 697, 704,\n+  705, 706, 707, 708, 709, 710, 711, 712, 713, 720, 721, 722, 723,\n+  724, 725, 726, 727, 728, 729, 736, 737, 738, 739, 740, 741, 742,\n+  743, 744, 745, 752, 753, 754, 755, 756, 757, 758, 759, 760, 761,\n+  650, 651, 682, 683, 714, 715, 746, 747, 718, 719, 666, 667, 698,\n+  699, 730, 731, 762, 763, 734, 735, 768, 769, 770, 771, 772, 773,\n+  774, 775, 776, 777, 784, 785, 786, 787, 788, 789, 790, 791, 792,\n+  793, 800, 801, 802, 803, 804, 805, 806, 807, 808, 809, 816, 817,\n+  818, 819, 820, 821, 822, 823, 824, 825, 832, 833, 834, 835, 836,\n+  837, 838, 839, 840, 841, 848, 849, 850, 851, 852, 853, 854, 855,\n+  856, 857, 864, 865, 866, 867, 868, 869, 870, 871, 872, 873, 880,\n+  881, 882, 883, 884, 885, 886, 887, 888, 889, 778, 779, 810, 811,\n+  842, 843, 874, 875, 846, 847, 794, 795, 826, 827, 858, 859, 890,\n+  891, 862, 863, 896, 897, 898, 899, 900, 901, 902, 903, 904, 905,\n+  912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 928, 929, 930,\n+  931, 932, 933, 934, 935, 936, 937, 944, 945, 946, 947, 948, 949,\n+  950, 951, 952, 953, 960, 961, 962, 963, 964, 965, 966, 967, 968,\n+  969, 976, 977, 978, 979, 980, 981, 982, 983, 984, 985, 992, 993,\n+  994, 995, 996, 997, 998, 999, 1000, 1001, 1008, 1009, 1010, 1011, 1012,\n+  1013, 1014, 1015, 1016, 1017, 906, 907, 938, 939, 970, 971, 1002, 1003,\n+  974, 975, 922, 923, 954, 955, 986, 987, 1018, 1019, 990, 991, 12,\n+  13, 268, 269, 524, 525, 780, 781, 46, 47, 28, 29, 284, 285,\n+  540, 541, 796, 797, 62, 63, 44, 45, 300, 301, 556, 557, 812,\n+  813, 302, 303, 60, 61, 316, 317, 572, 573, 828, 829, 318, 319,\n+  76, 77, 332, 333, 588, 589, 844, 845, 558, 559, 92, 93, 348,\n+  349, 604, 605, 860, 861, 574, 575, 108, 109, 364, 365, 620, 621,\n+  876, 877, 814, 815, 124, 125, 380, 381, 636, 637, 892, 893, 830,\n+  831, 14, 15, 270, 271, 526, 527, 782, 783, 110, 111, 30, 31,\n+  286, 287, 542, 543, 798, 799, 126, 127, 140, 141, 396, 397, 652,\n+  653, 908, 909, 174, 175, 156, 157, 412, 413, 668, 669, 924, 925,\n+  190, 191, 172, 173, 428, 429, 684, 685, 940, 941, 430, 431, 188,\n+  189, 444, 445, 700, 701, 956, 957, 446, 447, 204, 205, 460, 461,\n+  716, 717, 972, 973, 686, 687, 220, 221, 476, 477, 732, 733, 988,\n+  989, 702, 703, 236, 237, 492, 493, 748, 749, 1004, 1005, 942, 943,\n+  252, 253, 508, 509, 764, 765, 1020, 1021, 958, 959, 142, 143, 398,\n+  399, 654, 655, 910, 911, 238, 239, 158, 159, 414, 415, 670, 671,\n+  926, 927, 254, 255\n+};\n+#endif\n+\n+#if DEC_DPD2BIN==1\n+\n+const uint16_t DPD2BIN[1024] = { 0, 1, 2, 3, 4, 5, 6, 7,\n+  8, 9, 80, 81, 800, 801, 880, 881, 10, 11, 12, 13, 14,\n+  15, 16, 17, 18, 19, 90, 91, 810, 811, 890, 891, 20, 21,\n+  22, 23, 24, 25, 26, 27, 28, 29, 82, 83, 820, 821, 808,\n+  809, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 92, 93,\n+  830, 831, 818, 819, 40, 41, 42, 43, 44, 45, 46, 47, 48,\n+  49, 84, 85, 840, 841, 88, 89, 50, 51, 52, 53, 54, 55,\n+  56, 57, 58, 59, 94, 95, 850, 851, 98, 99, 60, 61, 62,\n+  63, 64, 65, 66, 67, 68, 69, 86, 87, 860, 861, 888, 889,\n+  70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 96, 97, 870,\n+  871, 898, 899, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109,\n+  180, 181, 900, 901, 980, 981, 110, 111, 112, 113, 114, 115, 116,\n+  117, 118, 119, 190, 191, 910, 911, 990, 991, 120, 121, 122, 123,\n+  124, 125, 126, 127, 128, 129, 182, 183, 920, 921, 908, 909, 130,\n+  131, 132, 133, 134, 135, 136, 137, 138, 139, 192, 193, 930, 931,\n+  918, 919, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 184,\n+  185, 940, 941, 188, 189, 150, 151, 152, 153, 154, 155, 156, 157,\n+  158, 159, 194, 195, 950, 951, 198, 199, 160, 161, 162, 163, 164,\n+  165, 166, 167, 168, 169, 186, 187, 960, 961, 988, 989, 170, 171,\n+  172, 173, 174, 175, 176, 177, 178, 179, 196, 197, 970, 971, 998,\n+  999, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 280, 281,\n+  802, 803, 882, 883, 210, 211, 212, 213, 214, 215, 216, 217, 218,\n+  219, 290, 291, 812, 813, 892, 893, 220, 221, 222, 223, 224, 225,\n+  226, 227, 228, 229, 282, 283, 822, 823, 828, 829, 230, 231, 232,\n+  233, 234, 235, 236, 237, 238, 239, 292, 293, 832, 833, 838, 839,\n+  240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 284, 285, 842,\n+  843, 288, 289, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259,\n+  294, 295, 852, 853, 298, 299, 260, 261, 262, 263, 264, 265, 266,\n+  267, 268, 269, 286, 287, 862, 863, 888, 889, 270, 271, 272, 273,\n+  274, 275, 276, 277, 278, 279, 296, 297, 872, 873, 898, 899, 300,\n+  301, 302, 303, 304, 305, 306, 307, 308, 309, 380, 381, 902, 903,\n+  982, 983, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 390,\n+  391, 912, 913, 992, 993, 320, 321, 322, 323, 324, 325, 326, 327,\n+  328, 329, 382, 383, 922, 923, 928, 929, 330, 331, 332, 333, 334,\n+  335, 336, 337, 338, 339, 392, 393, 932, 933, 938, 939, 340, 341,\n+  342, 343, 344, 345, 346, 347, 348, 349, 384, 385, 942, 943, 388,\n+  389, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 394, 395,\n+  952, 953, 398, 399, 360, 361, 362, 363, 364, 365, 366, 367, 368,\n+  369, 386, 387, 962, 963, 988, 989, 370, 371, 372, 373, 374, 375,\n+  376, 377, 378, 379, 396, 397, 972, 973, 998, 999, 400, 401, 402,\n+  403, 404, 405, 406, 407, 408, 409, 480, 481, 804, 805, 884, 885,\n+  410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 490, 491, 814,\n+  815, 894, 895, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429,\n+  482, 483, 824, 825, 848, 849, 430, 431, 432, 433, 434, 435, 436,\n+  437, 438, 439, 492, 493, 834, 835, 858, 859, 440, 441, 442, 443,\n+  444, 445, 446, 447, 448, 449, 484, 485, 844, 845, 488, 489, 450,\n+  451, 452, 453, 454, 455, 456, 457, 458, 459, 494, 495, 854, 855,\n+  498, 499, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 486,\n+  487, 864, 865, 888, 889, 470, 471, 472, 473, 474, 475, 476, 477,\n+  478, 479, 496, 497, 874, 875, 898, 899, 500, 501, 502, 503, 504,\n+  505, 506, 507, 508, 509, 580, 581, 904, 905, 984, 985, 510, 511,\n+  512, 513, 514, 515, 516, 517, 518, 519, 590, 591, 914, 915, 994,\n+  995, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 582, 583,\n+  924, 925, 948, 949, 530, 531, 532, 533, 534, 535, 536, 537, 538,\n+  539, 592, 593, 934, 935, 958, 959, 540, 541, 542, 543, 544, 545,\n+  546, 547, 548, 549, 584, 585, 944, 945, 588, 589, 550, 551, 552,\n+  553, 554, 555, 556, 557, 558, 559, 594, 595, 954, 955, 598, 599,\n+  560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 586, 587, 964,\n+  965, 988, 989, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579,\n+  596, 597, 974, 975, 998, 999, 600, 601, 602, 603, 604, 605, 606,\n+  607, 608, 609, 680, 681, 806, 807, 886, 887, 610, 611, 612, 613,\n+  614, 615, 616, 617, 618, 619, 690, 691, 816, 817, 896, 897, 620,\n+  621, 622, 623, 624, 625, 626, 627, 628, 629, 682, 683, 826, 827,\n+  868, 869, 630, 631, 632, 633, 634, 635, 636, 637, 638, 639, 692,\n+  693, 836, 837, 878, 879, 640, 641, 642, 643, 644, 645, 646, 647,\n+  648, 649, 684, 685, 846, 847, 688, 689, 650, 651, 652, 653, 654,\n+  655, 656, 657, 658, 659, 694, 695, 856, 857, 698, 699, 660, 661,\n+  662, 663, 664, 665, 666, 667, 668, 669, 686, 687, 866, 867, 888,\n+  889, 670, 671, 672, 673, 674, 675, 676, 677, 678, 679, 696, 697,\n+  876, 877, 898, 899, 700, 701, 702, 703, 704, 705, 706, 707, 708,\n+  709, 780, 781, 906, 907, 986, 987, 710, 711, 712, 713, 714, 715,\n+  716, 717, 718, 719, 790, 791, 916, 917, 996, 997, 720, 721, 722,\n+  723, 724, 725, 726, 727, 728, 729, 782, 783, 926, 927, 968, 969,\n+  730, 731, 732, 733, 734, 735, 736, 737, 738, 739, 792, 793, 936,\n+  937, 978, 979, 740, 741, 742, 743, 744, 745, 746, 747, 748, 749,\n+  784, 785, 946, 947, 788, 789, 750, 751, 752, 753, 754, 755, 756,\n+  757, 758, 759, 794, 795, 956, 957, 798, 799, 760, 761, 762, 763,\n+  764, 765, 766, 767, 768, 769, 786, 787, 966, 967, 988, 989, 770,\n+  771, 772, 773, 774, 775, 776, 777, 778, 779, 796, 797, 976, 977,\n+  998, 999\n+};\n+#endif"}, {"sha": "b7cbd109b252029be31d40e577d58d69e432e36b", "filename": "libdecnumber/decLibrary.c", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/473a74b91eb1dd5e7c98c238cb33b047fb5ed01a/libdecnumber%2FdecLibrary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/473a74b91eb1dd5e7c98c238cb33b047fb5ed01a/libdecnumber%2FdecLibrary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libdecnumber%2FdecLibrary.c?ref=473a74b91eb1dd5e7c98c238cb33b047fb5ed01a", "patch": "@@ -0,0 +1,81 @@\n+/* Temporary library support for decimal floating point.\n+   Copyright (C) 2005 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"decContext.h\"\n+#include \"decimal128.h\"\n+#include \"decimal64.h\"\n+#include \"decimal32.h\"\n+\n+void __host_to_ieee_32 (_Decimal32, decimal32 *);\n+void __host_to_ieee_64 (_Decimal64, decimal64 *);\n+void __host_to_ieee_128 (_Decimal128, decimal128 *);\n+\n+extern int isinfd32 (_Decimal32);\n+extern int isinfd64 (_Decimal64);\n+extern int isinfd128 (_Decimal128);\n+extern void __dfp_enable_traps (void);\n+extern void __dfp_raise (int exception __attribute__ ((unused)));\n+\n+int\n+isinfd32 (_Decimal32 arg)\n+{\n+  decNumber dn;\n+  decimal32 d32;\n+\n+  __host_to_ieee_32 (arg, &d32);\n+  decimal32ToNumber (&d32, &dn);\n+  return (decNumberIsInfinite (&dn));\n+}\n+\n+int\n+isinfd64 (_Decimal64 arg)\n+{\n+  decNumber dn;\n+  decimal64 d64;\n+\n+  __host_to_ieee_64 (arg, &d64);\n+  decimal64ToNumber (&d64, &dn);\n+  return (decNumberIsInfinite (&dn));\n+}\n+\n+int\n+isinfd128 (_Decimal128 arg)\n+{\n+  decNumber dn;\n+  decimal128 d128;\n+\n+  __host_to_ieee_128 (arg, &d128);\n+  decimal128ToNumber (&d128, &dn);\n+  return (decNumberIsInfinite (&dn));\n+}\n+\n+int __dfp_traps;\n+\n+void\n+__dfp_enable_traps (void)\n+{\n+  __dfp_traps = 1;\n+}\n+\n+void\n+__dfp_raise (int exception __attribute__ ((unused)))\n+{\n+  raise (SIGFPE);\n+}"}, {"sha": "c2a898006802e239abaf647d0429cf80a6088ff9", "filename": "libdecnumber/decNumber.c", "status": "added", "additions": 5939, "deletions": 0, "changes": 5939, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/473a74b91eb1dd5e7c98c238cb33b047fb5ed01a/libdecnumber%2FdecNumber.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/473a74b91eb1dd5e7c98c238cb33b047fb5ed01a/libdecnumber%2FdecNumber.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libdecnumber%2FdecNumber.c?ref=473a74b91eb1dd5e7c98c238cb33b047fb5ed01a"}, {"sha": "d7cf30f154e4f394174b06513f5f022ba28f881c", "filename": "libdecnumber/decNumber.h", "status": "added", "additions": 183, "deletions": 0, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/473a74b91eb1dd5e7c98c238cb33b047fb5ed01a/libdecnumber%2FdecNumber.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/473a74b91eb1dd5e7c98c238cb33b047fb5ed01a/libdecnumber%2FdecNumber.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libdecnumber%2FdecNumber.h?ref=473a74b91eb1dd5e7c98c238cb33b047fb5ed01a", "patch": "@@ -0,0 +1,183 @@\n+/* Decimal Number module header for the decNumber C Library\n+   Copyright (C) 2005 Free Software Foundation, Inc.\n+   Contributed by IBM Corporation.  Author Mike Cowlishaw.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 2, or (at your option) any later\n+   version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+   for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING.  If not, write to the Free\n+   Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+   02111-1307, USA.  */\n+\n+#if !defined(DECNUMBER)\n+#define DECNUMBER\n+#define DECNAME     \"decNumber\"\t/* Short name */\n+#define DECVERSION  \"decNumber 3.24\"\t/* Version [16 max.] */\n+#define DECFULLNAME \"Decimal Number Module\"\t/* Verbose name */\n+#define DECAUTHOR   \"Mike Cowlishaw\"\t/* Who to blame */\n+\n+#if !defined(DECCONTEXT)\n+#include \"decContext.h\"\n+#endif\n+\n+\n+  /* Bit settings for decNumber.bits */\n+#define DECNEG    0x80\t\t/* Sign; 1=negative, 0=positive or zero */\n+#define DECINF    0x40\t\t/* 1=Infinity */\n+#define DECNAN    0x20\t\t/* 1=NaN */\n+#define DECSNAN   0x10\t\t/* 1=sNaN */\n+  /* The remaining bits are reserved; they must be 0 */\n+#define DECSPECIAL (DECINF|DECNAN|DECSNAN)\t/* any special value */\n+\n+  /* DECNUMDIGITS is the default number of digits we can hold in the */\n+  /* structure.  If undefined, 1 is assumed and it is assumed that the */\n+  /* structure will be immediately followed by extra space (if */\n+  /* required).  DECNUMDIGITS is always >0. */\n+#if !defined(DECNUMDIGITS)\n+#define DECNUMDIGITS 1\n+#endif\n+\n+\n+  /* Define the decNumber data structure.  The size and shape of the */\n+  /* units array in the structure is determined by the following */\n+  /* constant.  This must not be changed without recompiling the */\n+  /* decNumber library modules. */\n+#define DECDPUN 4\t\t/* Decimal Digits Per UNit [must be in */\n+\t\t\t\t   /* range 1-9; power of 2 recommended]. */\n+  /* The size (integer data type) of each unit is determined by the */\n+  /* number of digits it will hold. */\n+#if   DECDPUN<=2\n+#define decNumberUnit uint8_t\n+#elif DECDPUN<=4\n+#define decNumberUnit uint16_t\n+#else\n+#define decNumberUnit uint32_t\n+#endif\n+  /* The number of decNumberUnits we need is ceiling of DECNUMDIGITS/DECDPUN */\n+#define DECNUMUNITS ((DECNUMDIGITS+DECDPUN-1)/DECDPUN)\n+\n+  /* The data structure... */\n+typedef struct\n+{\n+  int32_t digits;\t\t/* Count of digits in the coefficient; >0 */\n+  int32_t exponent;\t\t/* Unadjusted exponent, unbiased, in */\n+  /* range: -1999999997 through 999999999 */\n+  uint8_t bits;\t\t\t/* Indicator bits (see above) */\n+  decNumberUnit lsu[DECNUMUNITS];\t/* Coefficient, from least significant unit */\n+} decNumber;\n+\n+  /* Notes: */\n+  /* 1. If digits is > DECDPUN then there will be more than one */\n+  /*    decNumberUnits immediately following the first element of lsu. */\n+  /*    These contain the remaining (more significant) digits of the */\n+  /*    number, and may be in the lsu array, or may be guaranteed by */\n+  /*    some other mechanism (such as being contained in another */\n+  /*    structure, or being overlaid on dynamically allocated storage). */\n+  /* */\n+  /*    Each integer of the coefficient (except the possibly the last) */\n+  /*    contains DECDPUN digits (e.g., a value in the range 0 through */\n+  /*    99999999 if DECDPUN is 8, or 0 through 9999 if DECDPUN is 4). */\n+  /* */\n+  /* 2. A decNumber converted to a string may need up to digits+14 */\n+  /*    characters.  The worst cases (non-exponential and exponential */\n+  /*    formats) are: -0.00000{9...}# */\n+  /*             and: -9.{9...}E+999999999#   (where # is '\\0') */\n+\n+\n+  /* ------------------------------------------------------------------ */\n+  /* decNumber public functions and macros                              */\n+  /* ------------------------------------------------------------------ */\n+\n+#ifdef IN_LIBGCC2\n+#define decNumberFromString __decNumberFromString\n+#define decNumberToString __decNumberToString\n+#define decNumberToEngString __decNumberToEngString\n+#define decNumberAbs __decNumberAbs\n+#define decNumberAdd __decNumberAdd\n+#define decNumberCompare __decNumberCompare\n+#define decNumberDivide __decNumberDivide\n+#define decNumberDivideInteger __decNumberDivideInteger\n+#define decNumberMax __decNumberMax\n+#define decNumberMin __decNumberMin\n+#define decNumberMinus __decNumberMinus\n+#define decNumberMultiply __decNumberMultiply\n+#define decNumberNormalize __decNumberNormalize\n+#define decNumberPlus __decNumberPlus\n+#define decNumberPower __decNumberPower\n+#define decNumberQuantize __decNumberQuantize\n+#define decNumberRemainder __decNumberRemainder\n+#define decNumberRemainderNear __decNumberRemainderNear\n+#define decNumberRescale __decNumberRescale\n+#define decNumberSameQuantum __decNumberSameQuantum\n+#define decNumberSquareRoot __decNumberSquareRoot\n+#define decNumberSubtract __decNumberSubtract\n+#define decNumberToIntegralValue __decNumberToIntegralValue\n+#define decNumberCopy __decNumberCopy\n+#define decNumberTrim __decNumberTrim\n+#define decNumberVersion __decNumberVersion\n+#define decNumberZero __decNumberZero\n+#endif\n+\n+  /* Conversions */\n+decNumber *decNumberFromString (decNumber *, char *, decContext *);\n+char *decNumberToString (decNumber *, char *);\n+char *decNumberToEngString (decNumber *, char *);\n+\n+  /* Operators */\n+decNumber *decNumberAbs (decNumber *, decNumber *, decContext *);\n+decNumber *decNumberAdd (decNumber *, decNumber *, decNumber *, decContext *);\n+decNumber *decNumberCompare (decNumber *, decNumber *, decNumber *,\n+\t\t\t     decContext *);\n+decNumber *decNumberDivide (decNumber *, decNumber *, decNumber *,\n+\t\t\t    decContext *);\n+decNumber *decNumberDivideInteger (decNumber *, decNumber *, decNumber *,\n+\t\t\t\t   decContext *);\n+decNumber *decNumberMax (decNumber *, decNumber *, decNumber *, decContext *);\n+decNumber *decNumberMin (decNumber *, decNumber *, decNumber *, decContext *);\n+decNumber *decNumberMinus (decNumber *, decNumber *, decContext *);\n+decNumber *decNumberMultiply (decNumber *, decNumber *, decNumber *,\n+\t\t\t      decContext *);\n+decNumber *decNumberNormalize (decNumber *, decNumber *, decContext *);\n+decNumber *decNumberPlus (decNumber *, decNumber *, decContext *);\n+decNumber *decNumberPower (decNumber *, decNumber *, decNumber *,\n+\t\t\t   decContext *);\n+decNumber *decNumberQuantize (decNumber *, decNumber *, decNumber *,\n+\t\t\t      decContext *);\n+decNumber *decNumberRemainder (decNumber *, decNumber *, decNumber *,\n+\t\t\t       decContext *);\n+decNumber *decNumberRemainderNear (decNumber *, decNumber *, decNumber *,\n+\t\t\t\t   decContext *);\n+decNumber *decNumberRescale (decNumber *, decNumber *, decNumber *,\n+\t\t\t     decContext *);\n+decNumber *decNumberSameQuantum (decNumber *, decNumber *, decNumber *);\n+decNumber *decNumberSquareRoot (decNumber *, decNumber *, decContext *);\n+decNumber *decNumberSubtract (decNumber *, decNumber *, decNumber *,\n+\t\t\t      decContext *);\n+decNumber *decNumberToIntegralValue (decNumber *, decNumber *, decContext *);\n+\n+  /* Utilities */\n+decNumber *decNumberCopy (decNumber *, decNumber *);\n+decNumber *decNumberTrim (decNumber *);\n+const char *decNumberVersion (void);\n+decNumber *decNumberZero (decNumber *);\n+\n+  /* Macros */\n+#define decNumberIsZero(dn)     (*(dn)->lsu==0 \\\n+                                   && (dn)->digits==1 \\\n+                                   && (((dn)->bits&DECSPECIAL)==0))\n+#define decNumberIsNegative(dn) (((dn)->bits&DECNEG)!=0)\n+#define decNumberIsNaN(dn)      (((dn)->bits&(DECNAN|DECSNAN))!=0)\n+#define decNumberIsInfinite(dn) (((dn)->bits&DECINF)!=0)\n+#define decNumberNegate(dn) (((dn)->bits)^=DECNEG)\n+\n+#endif"}, {"sha": "928551445b74b0c3b160c4e2f997cf5ef7926497", "filename": "libdecnumber/decNumberLocal.h", "status": "added", "additions": 127, "deletions": 0, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/473a74b91eb1dd5e7c98c238cb33b047fb5ed01a/libdecnumber%2FdecNumberLocal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/473a74b91eb1dd5e7c98c238cb33b047fb5ed01a/libdecnumber%2FdecNumberLocal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libdecnumber%2FdecNumberLocal.h?ref=473a74b91eb1dd5e7c98c238cb33b047fb5ed01a", "patch": "@@ -0,0 +1,127 @@\n+/* decNumber package local type, tuning, and macro definitions.\n+   Copyright (C) 2005 Free Software Foundation, Inc.\n+   Contributed by IBM Corporation.  Author Mike Cowlishaw.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 2, or (at your option) any later\n+   version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+   for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING.  If not, write to the Free\n+   Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+   02111-1307, USA.  */\n+\n+/* ------------------------------------------------------------------ */\n+/* This header file is included by all modules in the decNumber       */\n+/* library, and contains local type definitions, tuning parameters,   */\n+/* etc.  It must only be included once, and should not need to be     */\n+/* used by application programs.  decNumber.h must be included first. */\n+/* ------------------------------------------------------------------ */\n+\n+#if !defined(DECNUMBERLOC)\n+#define DECNUMBERLOC\n+#define DECNLAUTHOR   \"Mike Cowlishaw\"\t/* Who to blame */\n+\n+  /* Local names for common types -- decNumber modules do not use int or\n+     long directly */\n+#define Flag   uint8_t\n+#define Byte   int8_t\n+#define uByte  uint8_t\n+#define Short  int16_t\n+#define uShort uint16_t\n+#define Int    int32_t\n+#define uInt   uint32_t\n+#define Unit   decNumberUnit\n+\n+\n+  /* Tuning parameter */\n+#define DECBUFFER 36\t\t/* Maximum size basis for local buffers. */\n+\t\t\t      /* Should be a common maximum precision */\n+\t\t\t      /* rounded up to a multiple of 4; must */\n+\t\t\t      /* be non-negative. */\n+\n+  /* Conditional code flags -- set these to 0 for best performance */\n+#define DECCHECK  0\t\t/* 1 to enable robust checking */\n+#define DECALLOC  0\t\t/* 1 to enable memory allocation accounting */\n+#define DECTRACE  0\t\t/* 1 to trace critical intermediates, etc. */\n+\n+\n+  /* Development use defines */\n+#if DECALLOC\n+     /* if these interfere with your C includes, just comment them out */\n+#define  int ?\t\t\t/* enable to ensure we do not use plain C */\n+#define  long ??\t\t/* .. 'int' or 'long' types from here on */\n+#endif\n+\n+  /* Limits and constants */\n+#define DECNUMMAXP 999999999\t/* maximum precision we can handle (9 digits) */\n+#define DECNUMMAXE 999999999\t/* maximum adjusted exponent ditto (9 digits) */\n+#define DECNUMMINE -999999999\t/* minimum adjusted exponent ditto (9 digits) */\n+#if (DECNUMMAXP != DEC_MAX_DIGITS)\n+#error Maximum digits mismatch\n+#endif\n+#if (DECNUMMAXE != DEC_MAX_EMAX)\n+#error Maximum exponent mismatch\n+#endif\n+#if (DECNUMMINE != DEC_MIN_EMIN)\n+#error Minimum exponent mismatch\n+#endif\n+\n+  /* Set DECDPUNMAX -- the maximum integer that fits in DECDPUN digits */\n+#if   DECDPUN==1\n+#define DECDPUNMAX 9\n+#elif DECDPUN==2\n+#define DECDPUNMAX 99\n+#elif DECDPUN==3\n+#define DECDPUNMAX 999\n+#elif DECDPUN==4\n+#define DECDPUNMAX 9999\n+#elif DECDPUN==5\n+#define DECDPUNMAX 99999\n+#elif DECDPUN==6\n+#define DECDPUNMAX 999999\n+#elif DECDPUN==7\n+#define DECDPUNMAX 9999999\n+#elif DECDPUN==8\n+#define DECDPUNMAX 99999999\n+#elif DECDPUN==9\n+#define DECDPUNMAX 999999999\n+#elif defined(DECDPUN)\n+#error DECDPUN must be in the range 1-9\n+#endif\n+\n+\n+  /* ----- Shared data ----- */\n+  /* The powers of of ten array (powers[n]==10**n, 0<=n<=10) */\n+extern const uInt powers[];\n+\n+  /* ----- Macros ----- */\n+  /* ISZERO -- return true if decNumber dn is a zero */\n+  /* [performance-critical in some situations] */\n+#define ISZERO(dn) decNumberIsZero(dn)\t/* now just a local name */\n+\n+  /* X10 and X100 -- multiply integer i by 10 or 100 */\n+  /* [shifts are usually faster than multiply; could be conditional] */\n+#define X10(i)  (((i)<<1)+((i)<<3))\n+#define X100(i) (((i)<<2)+((i)<<5)+((i)<<6))\n+\n+  /* D2U -- return the number of Units needed to hold d digits */\n+#if DECDPUN==8\n+#define D2U(d) ((unsigned)((d)+7)>>3)\n+#elif DECDPUN==4\n+#define D2U(d) ((unsigned)((d)+3)>>2)\n+#else\n+#define D2U(d) (((d)+DECDPUN-1)/DECDPUN)\n+#endif\n+\n+#else\n+#error decNumberLocal included more than once\n+#endif"}, {"sha": "d3726665e13ee1ccad4006f0ae0ddd4f4fb97635", "filename": "libdecnumber/decRound.c", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/473a74b91eb1dd5e7c98c238cb33b047fb5ed01a/libdecnumber%2FdecRound.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/473a74b91eb1dd5e7c98c238cb33b047fb5ed01a/libdecnumber%2FdecRound.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libdecnumber%2FdecRound.c?ref=473a74b91eb1dd5e7c98c238cb33b047fb5ed01a", "patch": "@@ -0,0 +1,92 @@\n+/* Temporary support for a libc-like fp environment for decimal float.\n+   Copyright (C) 2005 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"decContext.h\"\n+\n+#define FE_DEC_DOWNWARD 0\n+#define FE_DEC_TONEAREST 1\n+#define FE_DEC_TONEARESTFROMZERO 2\n+#define FE_DEC_TOWARDZERO 3\n+#define FE_DEC_UPWARD 4\n+#define FE_DEC_MAX 5\n+\n+extern void __dfp_set_round (int);\n+extern int __dfp_get_round (void);\n+extern enum rounding __decGetRound (void);\n+\n+/* FIXME: these should be in thread-local storage for runtime support.  */\n+static enum rounding __dfp_rounding_mode = DEC_ROUND_HALF_EVEN;\n+\n+/* Set the decNumber rounding mode from the FE_DEC_* value in MODE.  */ \n+\n+void\n+__dfp_set_round (int mode)\n+{\n+  switch (mode)\n+    {\n+    case FE_DEC_DOWNWARD:\n+      __dfp_rounding_mode = DEC_ROUND_FLOOR; break;\n+    case FE_DEC_TONEAREST:\n+      __dfp_rounding_mode = DEC_ROUND_HALF_EVEN; break;\n+    case FE_DEC_TONEARESTFROMZERO:\n+      __dfp_rounding_mode = DEC_ROUND_HALF_UP; break;\n+    case FE_DEC_TOWARDZERO:\n+      __dfp_rounding_mode = DEC_ROUND_DOWN; break;\n+    case FE_DEC_UPWARD:\n+      __dfp_rounding_mode = DEC_ROUND_CEILING; break;\n+    default:\n+     /* We can't use assert in libgcc, so just return the default mode.  */\n+      __dfp_rounding_mode = DEC_ROUND_HALF_EVEN; break;\n+    }\n+}\n+\n+/* Return the decNumber rounding mode as an FE_DEC_* value.  */\n+\n+int\n+__dfp_get_round (void)\n+{\n+  int mode;\n+\n+  switch (__dfp_rounding_mode)\n+    {\n+    case DEC_ROUND_FLOOR:\n+      mode = FE_DEC_DOWNWARD; break;\n+    case DEC_ROUND_HALF_EVEN:\n+      mode = FE_DEC_TONEAREST; break;\n+    case DEC_ROUND_HALF_UP:\n+      mode = FE_DEC_TONEARESTFROMZERO; break;\n+    case DEC_ROUND_DOWN:\n+      mode = FE_DEC_TOWARDZERO; break;\n+    case DEC_ROUND_CEILING:\n+      mode = FE_DEC_UPWARD; break;\n+    default:\n+      /* We shouldn't get here, but can't use assert in libgcc.  */\n+      mode = -1;\n+    }\n+  return mode;\n+}\n+\n+/* Return the decNumber version of the current rounding mode.  */\n+\n+enum rounding\n+__decGetRound (void)\n+{\n+  return __dfp_rounding_mode;\n+}"}, {"sha": "75439227bba00cce2dc16668710f50ba497465bf", "filename": "libdecnumber/decUtility.c", "status": "added", "additions": 372, "deletions": 0, "changes": 372, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/473a74b91eb1dd5e7c98c238cb33b047fb5ed01a/libdecnumber%2FdecUtility.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/473a74b91eb1dd5e7c98c238cb33b047fb5ed01a/libdecnumber%2FdecUtility.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libdecnumber%2FdecUtility.c?ref=473a74b91eb1dd5e7c98c238cb33b047fb5ed01a", "patch": "@@ -0,0 +1,372 @@\n+/* Utility functions for decimal floating point support via decNumber.\n+   Copyright (C) 2005 Free Software Foundation, Inc.\n+   Contributed by IBM Corporation.  Author Mike Cowlishaw.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 2, or (at your option) any later\n+   version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+   for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING.  If not, write to the Free\n+   Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+   02111-1307, USA.  */\n+\n+#include \"decNumber.h\"          /* base number library */\n+#include \"decNumberLocal.h\"     /* decNumber local types, etc. */\n+#include \"decUtility.h\"         /* utility routines */\n+\n+#include \"tconfig.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+\n+/* ================================================================== */\n+/* Shared utility routines                                            */\n+/* ================================================================== */\n+\n+/* define and include the conversion tables to use */\n+#define DEC_BIN2DPD 1\t\t/* used for all sizes */\n+#if DECDPUN==3\n+#define DEC_DPD2BIN 1\n+#else\n+#define DEC_DPD2BCD 1\n+#endif\n+#include \"decDPD.h\"\t\t/* lookup tables */\n+\n+/* The maximum number of decNumberUnits we need for a working copy of */\n+/* the units array is the ceiling of digits/DECDPUN, where digits is */\n+/* the maximum number of digits in any of the formats for which this */\n+/* is used.  We do not want to include decimal128.h, so, as a very */\n+/* special case, that number is defined here. */\n+#define DECMAX754   34\n+#define DECMAXUNITS ((DECMAX754+DECDPUN-1)/DECDPUN)\n+\n+/* ------------------------------------------------------------------ */\n+/* decDensePackCoeff -- densely pack coefficient into DPD form        */\n+/*                                                                    */\n+/*   dn is the source number (assumed valid, max DECMAX754 digits)    */\n+/*   bytes is the target's byte array                                 */\n+/*   len is length of target format's byte array                      */\n+/*   shift is the number of 0 digits to add on the right (normally 0) */\n+/*                                                                    */\n+/* The coefficient must be known small enough to fit, and is filled   */\n+/* in from the right (least significant first).  Note that the full   */\n+/* coefficient is copied, including the leading 'odd' digit.  This    */\n+/* digit is retrieved and packed into the combination field by the    */\n+/* caller.                                                            */\n+/*                                                                    */\n+/* shift is used for 'fold-down' padding.                             */\n+/*                                                                    */\n+/* No error is possible.                                              */\n+/* ------------------------------------------------------------------ */\n+void\n+decDensePackCoeff (decNumber * dn, uByte * bytes, Int len, Int shift)\n+{\n+  Int cut;\t\t\t/* work */\n+  Int n;\t\t\t/* output bunch counter */\n+  Int digits = dn->digits;\t/* digit countdown */\n+  uInt dpd;\t\t\t/* densely packed decimal value */\n+  uInt bin;\t\t\t/* binary value 0-999 */\n+  uByte *bout;\t\t\t/* -> current output byte */\n+  Unit *inu = dn->lsu;\t\t/* -> current input unit */\n+  Unit uar[DECMAXUNITS];\t/* working copy of units, iff shifted */\n+#if DECDPUN!=3\t\t\t/* not fast path */\n+  Unit in;\t\t\t/* current input unit */\n+#endif\n+\n+  if (shift != 0)\n+    {\t\t\t\t/* shift towards most significant required */\n+      /* shift the units array to the left by pad digits and copy */\n+      /* [this code is a special case of decShiftToMost, which could */\n+      /* be used instead if exposed and the array were copied first] */\n+      Unit *target, *source, *first;\t/* work */\n+      uInt next = 0;\t\t/* work */\n+\n+      source = dn->lsu + D2U (digits) - 1;\t/* where msu comes from */\n+      first = uar + D2U (digits + shift) - 1;\t/* where msu will end up */\n+      target = uar + D2U (digits) - 1 + D2U (shift);\t/* where upper part of first cut goes */\n+\n+      cut = (DECDPUN - shift % DECDPUN) % DECDPUN;\n+      for (; source >= dn->lsu; source--, target--)\n+\t{\n+\t  /* split the source Unit and accumulate remainder for next */\n+\t  uInt rem = *source % powers[cut];\n+\t  next += *source / powers[cut];\n+\t  if (target <= first)\n+\t    *target = (Unit) next;\t/* write to target iff valid */\n+\t  next = rem * powers[DECDPUN - cut];\t/* save remainder for next Unit */\n+\t}\n+      /* propagate remainder to one below and clear the rest */\n+      for (; target >= uar; target--)\n+\t{\n+\t  *target = (Unit) next;\n+\t  next = 0;\n+\t}\n+      digits += shift;\t\t/* add count (shift) of zeros added */\n+      inu = uar;\t\t/* use units in working array */\n+    }\n+\n+  /* densely pack the coefficient into the byte array, starting from\n+     the right (optionally padded) */\n+  bout = &bytes[len - 1];\t/* rightmost result byte for phase */\n+\n+#if DECDPUN!=3\t\t\t/* not fast path */\n+  in = *inu;\t\t\t/* prime */\n+  cut = 0;\t\t\t/* at lowest digit */\n+  bin = 0;\t\t\t/* [keep compiler quiet] */\n+#endif\n+\n+  for (n = 0; digits > 0; n++)\n+    {\t\t\t\t/* each output bunch */\n+#if DECDPUN==3\t\t\t/* fast path, 3-at-a-time */\n+      bin = *inu;\t\t/* 3 ready for convert */\n+      digits -= 3;\t\t/* [may go negative] */\n+      inu++;\t\t\t/* may need another */\n+\n+#else /* must collect digit-by-digit */\n+      Unit dig;\t\t\t/* current digit */\n+      Int j;\t\t\t/* digit-in-bunch count */\n+      for (j = 0; j < 3; j++)\n+\t{\n+#if DECDPUN<=4\n+\t  Unit temp = (Unit) ((uInt) (in * 6554) >> 16);\n+\t  dig = (Unit) (in - X10 (temp));\n+\t  in = temp;\n+#else\n+\t  dig = in % 10;\n+\t  in = in / 10;\n+#endif\n+\n+\t  if (j == 0)\n+\t    bin = dig;\n+\t  else if (j == 1)\n+\t    bin += X10 (dig);\n+\t  else\t\t\t/* j==2 */\n+\t    bin += X100 (dig);\n+\n+\t  digits--;\n+\t  if (digits == 0)\n+\t    break;\t\t/* [also protects *inu below] */\n+\t  cut++;\n+\t  if (cut == DECDPUN)\n+\t    {\n+\t      inu++;\n+\t      in = *inu;\n+\t      cut = 0;\n+\t    }\n+\t}\n+#endif\n+      /* here we have 3 digits in bin, or have used all input digits */\n+\n+      dpd = BIN2DPD[bin];\n+\n+      /* write bunch (bcd) to byte array */\n+      switch (n & 0x03)\n+\t{\t\t\t/* phase 0-3 */\n+\tcase 0:\n+\t  *bout = (uByte) dpd;\t/* [top 2 bits truncated] */\n+\t  bout--;\n+\t  *bout = (uByte) (dpd >> 8);\n+\t  break;\n+\tcase 1:\n+\t  *bout |= (uByte) (dpd << 2);\n+\t  bout--;\n+\t  *bout = (uByte) (dpd >> 6);\n+\t  break;\n+\tcase 2:\n+\t  *bout |= (uByte) (dpd << 4);\n+\t  bout--;\n+\t  *bout = (uByte) (dpd >> 4);\n+\t  break;\n+\tcase 3:\n+\t  *bout |= (uByte) (dpd << 6);\n+\t  bout--;\n+\t  *bout = (uByte) (dpd >> 2);\n+\t  bout--;\n+\t  break;\n+\t}\t\t\t/* switch */\n+    }\t\t\t\t/* n bunches */\n+  return;\n+}\n+\n+/* ------------------------------------------------------------------ */\n+/* decDenseUnpackCoeff -- unpack a format's coefficient               */\n+/*                                                                    */\n+/*   byte is the source's byte array                                  */\n+/*   len is length of the source's byte array                         */\n+/*   dn is the target number, with 7, 16, or 34-digit space.          */\n+/*   bunches is the count of DPD groups in the decNumber (2, 5, or 11)*/\n+/*   odd is 1 if there is a non-zero leading 10-bit group containing  */\n+/*     a single digit, 0 otherwise                                    */\n+/*                                                                    */\n+/* (This routine works on a copy of the number, if necessary, where   */\n+/* an extra 10-bit group is prefixed to the coefficient continuation  */\n+/* to hold the most significant digit if the latter is non-0.)        */\n+/*                                                                    */\n+/* dn->digits is set, but not the sign or exponent.                   */\n+/* No error is possible [the redundant 888 codes are allowed].        */\n+/* ------------------------------------------------------------------ */\n+void\n+decDenseUnpackCoeff (uByte * bytes, Int len, decNumber * dn,\n+\t\t     Int bunches, Int odd)\n+{\n+  uInt dpd = 0;\t\t\t/* collector for 10 bits */\n+  Int n;\t\t\t/* counter */\n+  uByte *bin;\t\t\t/* -> current input byte */\n+  Unit *uout = dn->lsu;\t\t/* -> current output unit */\n+  Unit out = 0;\t\t\t/* accumulator */\n+  Int cut = 0;\t\t\t/* power of ten in current unit */\n+  Unit *last = uout;\t\t/* will be unit containing msd */\n+#if DECDPUN!=3\n+  uInt bcd;\t\t\t/* BCD result */\n+  uInt nibble;\t\t\t/* work */\n+#endif\n+\n+  /* Expand the densely-packed integer, right to left */\n+  bin = &bytes[len - 1];\t/* next input byte to use */\n+  for (n = 0; n < bunches + odd; n++)\n+    {\t\t\t\t/* N bunches of 10 bits */\n+      /* assemble the 10 bits */\n+      switch (n & 0x03)\n+\t{\t\t\t/* phase 0-3 */\n+\tcase 0:\n+\t  dpd = *bin;\n+\t  bin--;\n+\t  dpd |= (*bin & 0x03) << 8;\n+\t  break;\n+\tcase 1:\n+\t  dpd = (unsigned) *bin >> 2;\n+\t  bin--;\n+\t  dpd |= (*bin & 0x0F) << 6;\n+\t  break;\n+\tcase 2:\n+\t  dpd = (unsigned) *bin >> 4;\n+\t  bin--;\n+\t  dpd |= (*bin & 0x3F) << 4;\n+\t  break;\n+\tcase 3:\n+\t  dpd = (unsigned) *bin >> 6;\n+\t  bin--;\n+\t  dpd |= (*bin) << 2;\n+\t  bin--;\n+\t  break;\n+\t}\t\t\t/*switch */\n+\n+#if DECDPUN==3\n+      if (dpd == 0)\n+\t*uout = 0;\n+      else\n+\t{\n+\t  *uout = DPD2BIN[dpd];\t/* convert 10 bits to binary 0-999 */\n+\t  last = uout;\t\t/* record most significant unit */\n+\t}\n+      uout++;\n+\n+#else /* DECDPUN!=3 */\n+      if (dpd == 0)\n+\t{\t\t\t/* fastpath [e.g., leading zeros] */\n+\t  cut += 3;\n+\t  for (; cut >= DECDPUN;)\n+\t    {\n+\t      cut -= DECDPUN;\n+\t      *uout = out;\n+\t      uout++;\n+\t      out = 0;\n+\t    }\n+\t  continue;\n+\t}\n+      bcd = DPD2BCD[dpd];\t/* convert 10 bits to 12 bits BCD */\n+      /* now split the 3 BCD nibbles into bytes, and accumulate into units */\n+      /* If this is the last bunch and it is an odd one, we only have one */\n+      /* nibble to handle [extras could overflow a Unit] */\n+      nibble = bcd & 0x000f;\n+      if (nibble)\n+\t{\n+\t  last = uout;\n+\t  out = (Unit) (out + nibble * powers[cut]);\n+\t}\n+      cut++;\n+      if (cut == DECDPUN)\n+\t{\n+\t  *uout = out;\n+\t  uout++;\n+\t  cut = 0;\n+\t  out = 0;\n+\t}\n+      if (n < bunches)\n+\t{\n+\t  nibble = bcd & 0x00f0;\n+\t  if (nibble)\n+\t    {\n+\t      nibble >>= 4;\n+\t      last = uout;\n+\t      out = (Unit) (out + nibble * powers[cut]);\n+\t    }\n+\t  cut++;\n+\t  if (cut == DECDPUN)\n+\t    {\n+\t      *uout = out;\n+\t      uout++;\n+\t      cut = 0;\n+\t      out = 0;\n+\t    }\n+\t  nibble = bcd & 0x0f00;\n+\t  if (nibble)\n+\t    {\n+\t      nibble >>= 8;\n+\t      last = uout;\n+\t      out = (Unit) (out + nibble * powers[cut]);\n+\t    }\n+\t  cut++;\n+\t  if (cut == DECDPUN)\n+\t    {\n+\t      *uout = out;\n+\t      uout++;\n+\t      cut = 0;\n+\t      out = 0;\n+\t    }\n+\t}\n+#endif\n+    }\t\t\t\t/* n */\n+  if (cut != 0)\n+    *uout = out;\t\t/* write out final unit */\n+\n+  /* here, last points to the most significant unit with digits */\n+  /* we need to inspect it to get final digits count */\n+  dn->digits = (last - dn->lsu) * DECDPUN;\t/* floor of digits */\n+  for (cut = 0; cut < DECDPUN; cut++)\n+    {\n+      if (*last < powers[cut])\n+\tbreak;\n+      dn->digits++;\n+    }\n+  if (dn->digits == 0)\n+    dn->digits++;\t\t/* zero has one digit */\n+  return;\n+}\n+\n+unsigned long\n+__dec_byte_swap (unsigned long in)\n+{\n+  unsigned long out;\n+  unsigned char *p = (unsigned char *) &out;\n+  union {\n+    unsigned long i;\n+    unsigned char b[4];\n+  } u;\n+\n+  u.i = in;\n+  p[0] = u.b[3];\n+  p[1] = u.b[2];\n+  p[2] = u.b[1];\n+  p[3] = u.b[0];\n+\n+  return out;\n+}"}, {"sha": "b5136478a6e76f26528fd430217431515d3ef403", "filename": "libdecnumber/decUtility.h", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/473a74b91eb1dd5e7c98c238cb33b047fb5ed01a/libdecnumber%2FdecUtility.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/473a74b91eb1dd5e7c98c238cb33b047fb5ed01a/libdecnumber%2FdecUtility.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libdecnumber%2FdecUtility.h?ref=473a74b91eb1dd5e7c98c238cb33b047fb5ed01a", "patch": "@@ -0,0 +1,29 @@\n+/* Utility functions for decimal floating point support via decNumber.\n+   Copyright (C) 2005 Free Software Foundation, Inc.\n+   Contributed by IBM Corporation.  Author Mike Cowlishaw.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 2, or (at your option) any later\n+   version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+   for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING.  If not, write to the Free\n+   Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+   02111-1307, USA.  */\n+\n+#ifdef IN_LIBGCC2\n+#define decDensePackCoeff __decDensePackCoeff\n+#define decDenseUnpackCoeff __decDenseUnpackCoeff\n+#endif\n+\n+extern void decDensePackCoeff (decNumber *, uByte *, Int, Int);\n+extern void decDenseUnpackCoeff (uByte *, Int, decNumber *, Int, Int);\n+extern unsigned long __dec_byte_swap (unsigned long in);"}, {"sha": "214dba0f1becbb47217242e0baf2b06d541a7d7f", "filename": "libdecnumber/decimal128.c", "status": "added", "additions": 337, "deletions": 0, "changes": 337, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/473a74b91eb1dd5e7c98c238cb33b047fb5ed01a/libdecnumber%2Fdecimal128.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/473a74b91eb1dd5e7c98c238cb33b047fb5ed01a/libdecnumber%2Fdecimal128.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libdecnumber%2Fdecimal128.c?ref=473a74b91eb1dd5e7c98c238cb33b047fb5ed01a", "patch": "@@ -0,0 +1,337 @@\n+/* Decimal 128-bit format module from the decNumber C Library.\n+   Copyright (C) 2005 Free Software Foundation, Inc.\n+   Contributed by IBM Corporation.  Author Mike Cowlishaw.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 2, or (at your option) any later\n+   version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+   for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING.  If not, write to the Free\n+   Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+   02111-1307, USA.  */\n+\n+/* ------------------------------------------------------------------ */\n+/* This module comprises the routines for decimal128 format numbers.  */\n+/* Conversions are supplied to and from decNumber and String.         */\n+/*                                                                    */\n+/* No arithmetic routines are included; decNumber provides these.     */\n+/*                                                                    */\n+/* Error handling is the same as decNumber (qv.).                     */\n+/* ------------------------------------------------------------------ */\n+#include <string.h>\t\t/* [for memset/memcpy] */\n+#include <stdio.h>\t\t/* [for printf] */\n+\n+#define  DECNUMDIGITS 34\t/* we need decNumbers with space for 34 */\n+#include \"decNumber.h\"\t\t/* base number library */\n+#include \"decNumberLocal.h\"\t/* decNumber local types, etc. */\n+#include \"decimal128.h\"\t\t/* our primary include */\n+#include \"decUtility.h\"\t\t/* utility routines */\n+\n+#if DECTRACE || DECCHECK\n+void decimal128Show (decimal128 *);\t/* for debug */\n+void decNumberShow (decNumber *);\t/* .. */\n+#endif\n+\n+/* Useful macro */\n+/* Clear a structure (e.g., a decNumber) */\n+#define DEC_clear(d) memset(d, 0, sizeof(*d))\n+\n+/* ------------------------------------------------------------------ */\n+/* decimal128FromNumber -- convert decNumber to decimal128            */\n+/*                                                                    */\n+/*   ds is the target decimal128                                      */\n+/*   dn is the source number (assumed valid)                          */\n+/*   set is the context, used only for reporting errors               */\n+/*                                                                    */\n+/* The set argument is used only for status reporting and for the     */\n+/* rounding mode (used if the coefficient is more than DECIMAL128_Pmax*/\n+/* digits or an overflow is detected).  If the exponent is out of the */\n+/* valid range then Overflow or Underflow will be raised.             */\n+/* After Underflow a subnormal result is possible.                    */\n+/*                                                                    */\n+/* DEC_Clamped is set if the number has to be 'folded down' to fit,   */\n+/* by reducing its exponent and multiplying the coefficient by a      */\n+/* power of ten, or if the exponent on a zero had to be clamped.      */\n+/* ------------------------------------------------------------------ */\n+decimal128 *\n+decimal128FromNumber (decimal128 * d128, decNumber * dn, decContext * set)\n+{\n+  uInt status = 0;\t\t/* status accumulator */\n+  Int pad = 0;\t\t\t/* coefficient pad digits */\n+  decNumber dw;\t\t\t/* work */\n+  decContext dc;\t\t/* .. */\n+  uByte isneg = dn->bits & DECNEG;\t/* non-0 if original sign set */\n+  uInt comb, exp;\t\t/* work */\n+\n+  /* If the number is finite, and has too many digits, or the exponent */\n+  /* could be out of range then we reduce the number under the */\n+  /* appropriate constraints */\n+  if (!(dn->bits & DECSPECIAL))\n+    {\t\t\t\t/* not a special value */\n+      Int ae = dn->exponent + dn->digits - 1;\t/* adjusted exponent */\n+      if (dn->digits > DECIMAL128_Pmax\t/* too many digits */\n+\t  || ae > DECIMAL128_Emax\t/* likely overflow */\n+\t  || ae < DECIMAL128_Emin)\n+\t{\t\t\t/* likely underflow */\n+\t  decContextDefault (&dc, DEC_INIT_DECIMAL128);\t/* [no traps] */\n+\t  dc.round = set->round;\t/* use supplied rounding */\n+\t  decNumberPlus (&dw, dn, &dc);\t/* (round and check) */\n+\t  /* [this changes -0 to 0, but it will be restored below] */\n+\t  status |= dc.status;\t/* save status */\n+\t  dn = &dw;\t\t/* use the work number */\n+\t}\n+      /* [this could have pushed number to Infinity or zero, so this */\n+      /* rounding must be done before we generate the decimal128] */\n+    }\n+\n+  DEC_clear (d128);\t\t/* clean the target */\n+  if (dn->bits & DECSPECIAL)\n+    {\t\t\t\t/* a special value */\n+      uByte top;\t\t/* work */\n+      if (dn->bits & DECINF)\n+\ttop = DECIMAL_Inf;\n+      else\n+\t{\t\t\t/* sNaN or qNaN */\n+\t  if ((*dn->lsu != 0 || dn->digits > 1)\t/* non-zero coefficient */\n+\t      && (dn->digits < DECIMAL128_Pmax))\n+\t    {\t\t\t/* coefficient fits */\n+\t      decDensePackCoeff (dn, d128->bytes, sizeof (d128->bytes), 0);\n+\t    }\n+\t  if (dn->bits & DECNAN)\n+\t    top = DECIMAL_NaN;\n+\t  else\n+\t    top = DECIMAL_sNaN;\n+\t}\n+      d128->bytes[0] = top;\n+    }\n+  else if (decNumberIsZero (dn))\n+    {\t\t\t\t/* a zero */\n+      /* set and clamp exponent */\n+      if (dn->exponent < -DECIMAL128_Bias)\n+\t{\n+\t  exp = 0;\n+\t  status |= DEC_Clamped;\n+\t}\n+      else\n+\t{\n+\t  exp = dn->exponent + DECIMAL128_Bias;\t/* bias exponent */\n+\t  if (exp > DECIMAL128_Ehigh)\n+\t    {\t\t\t/* top clamp */\n+\t      exp = DECIMAL128_Ehigh;\n+\t      status |= DEC_Clamped;\n+\t    }\n+\t}\n+      comb = (exp >> 9) & 0x18;\t/* combination field */\n+      d128->bytes[0] = (uByte) (comb << 2);\n+      exp &= 0xfff;\t\t/* remaining exponent bits */\n+      decimal128SetExpCon (d128, exp);\n+    }\n+  else\n+    {\t\t\t\t/* non-zero finite number */\n+      uInt msd;\t\t\t/* work */\n+\n+      /* we have a dn that fits, but it may need to be padded */\n+      exp = (uInt) (dn->exponent + DECIMAL128_Bias);\t/* bias exponent */\n+\n+      if (exp > DECIMAL128_Ehigh)\n+\t{\t\t\t/* fold-down case */\n+\t  pad = exp - DECIMAL128_Ehigh;\n+\t  exp = DECIMAL128_Ehigh;\t/* [to maximum] */\n+\t  status |= DEC_Clamped;\n+\t}\n+\n+      decDensePackCoeff (dn, d128->bytes, sizeof (d128->bytes), pad);\n+\n+      /* save and clear the top digit */\n+      msd = ((unsigned) d128->bytes[1] << 2) & 0x0c;\t/* top 2 bits */\n+      msd |= ((unsigned) d128->bytes[2] >> 6);\t/* low 2 bits */\n+      d128->bytes[1] &= 0xfc;\n+      d128->bytes[2] &= 0x3f;\n+\n+      /* create the combination field */\n+      if (msd >= 8)\n+\tcomb = 0x18 | (msd & 0x01) | ((exp >> 11) & 0x06);\n+      else\n+\tcomb = (msd & 0x07) | ((exp >> 9) & 0x18);\n+      d128->bytes[0] = (uByte) (comb << 2);\n+      exp &= 0xfff;\t\t/* remaining exponent bits */\n+      decimal128SetExpCon (d128, exp);\n+    }\n+\n+  if (isneg)\n+    decimal128SetSign (d128, 1);\n+  if (status != 0)\n+    decContextSetStatus (set, status);\t/* pass on status */\n+\n+  /* decimal128Show(d128); */\n+  return d128;\n+}\n+\n+/* ------------------------------------------------------------------ */\n+/* decimal128ToNumber -- convert decimal128 to decNumber              */\n+/*   d128 is the source decimal128                                    */\n+/*   dn is the target number, with appropriate space                  */\n+/* No error is possible.                                              */\n+/* ------------------------------------------------------------------ */\n+decNumber *\n+decimal128ToNumber (decimal128 * d128, decNumber * dn)\n+{\n+  uInt msd;\t\t\t/* coefficient MSD */\n+  decimal128 wk;\t\t/* working copy, if needed */\n+  uInt top = d128->bytes[0] & 0x7f;\t/* top byte, less sign bit */\n+  decNumberZero (dn);\t\t/* clean target */\n+  /* set the sign if negative */\n+  if (decimal128Sign (d128))\n+    dn->bits = DECNEG;\n+\n+  if (top >= 0x78)\n+    {\t\t\t\t/* is a special */\n+      if ((top & 0x7c) == (DECIMAL_Inf & 0x7c))\n+\tdn->bits |= DECINF;\n+      else if ((top & 0x7e) == (DECIMAL_NaN & 0x7e))\n+\tdn->bits |= DECNAN;\n+      else\n+\tdn->bits |= DECSNAN;\n+      msd = 0;\t\t\t/* no top digit */\n+    }\n+  else\n+    {\t\t\t\t/* have a finite number */\n+      uInt comb = top >> 2;\t/* combination field */\n+      uInt exp;\t\t\t/* exponent */\n+\n+      if (comb >= 0x18)\n+\t{\n+\t  msd = 8 + (comb & 0x01);\n+\t  exp = (comb & 0x06) << 11;\t/* MSBs */\n+\t}\n+      else\n+\t{\n+\t  msd = comb & 0x07;\n+\t  exp = (comb & 0x18) << 9;\n+\t}\n+      dn->exponent = exp + decimal128ExpCon (d128) - DECIMAL128_Bias;\t/* remove bias */\n+    }\n+\n+  /* get the coefficient, unless infinite */\n+  if (!(dn->bits & DECINF))\n+    {\n+      Int bunches = DECIMAL128_Pmax / 3;\t/* coefficient full bunches to convert */\n+      Int odd = 0;\t\t/* assume MSD is 0 (no odd bunch) */\n+      if (msd != 0)\n+\t{\t\t\t/* coefficient has leading non-0 digit */\n+\t  /* make a copy of the decimal128, with an extra bunch which has */\n+\t  /* the top digit ready for conversion */\n+\t  wk = *d128;\t\t/* take a copy */\n+\t  wk.bytes[0] = 0;\t/* clear all but coecon */\n+\t  wk.bytes[1] = 0;\t/* .. */\n+\t  wk.bytes[2] &= 0x3f;\t/* .. */\n+\t  wk.bytes[1] |= (msd >> 2);\t/* and prefix MSD */\n+\t  wk.bytes[2] |= (msd << 6);\t/* .. */\n+\t  odd++;\t\t/* indicate the extra */\n+\t  d128 = &wk;\t\t/* use the work copy */\n+\t}\n+      decDenseUnpackCoeff (d128->bytes, sizeof (d128->bytes), dn, bunches,\n+\t\t\t   odd);\n+    }\n+\n+  /* decNumberShow(dn); */\n+  return dn;\n+}\n+\n+/* ------------------------------------------------------------------ */\n+/* to-scientific-string -- conversion to numeric string               */\n+/* to-engineering-string -- conversion to numeric string              */\n+/*                                                                    */\n+/*   decimal128ToString(d128, string);                                */\n+/*   decimal128ToEngString(d128, string);                             */\n+/*                                                                    */\n+/*  d128 is the decimal128 format number to convert                   */\n+/*  string is the string where the result will be laid out            */\n+/*                                                                    */\n+/*  string must be at least 24 characters                             */\n+/*                                                                    */\n+/*  No error is possible, and no status can be set.                   */\n+/* ------------------------------------------------------------------ */\n+char *\n+decimal128ToString (decimal128 * d128, char *string)\n+{\n+  decNumber dn;\t\t\t/* work */\n+  decimal128ToNumber (d128, &dn);\n+  decNumberToString (&dn, string);\n+  return string;\n+}\n+\n+char *\n+decimal128ToEngString (decimal128 * d128, char *string)\n+{\n+  decNumber dn;\t\t\t/* work */\n+  decimal128ToNumber (d128, &dn);\n+  decNumberToEngString (&dn, string);\n+  return string;\n+}\n+\n+/* ------------------------------------------------------------------ */\n+/* to-number -- conversion from numeric string                        */\n+/*                                                                    */\n+/*   decimal128FromString(result, string, set);                       */\n+/*                                                                    */\n+/*  result  is the decimal128 format number which gets the result of  */\n+/*          the conversion                                            */\n+/*  *string is the character string which should contain a valid      */\n+/*          number (which may be a special value)                     */\n+/*  set     is the context                                            */\n+/*                                                                    */\n+/* The context is supplied to this routine is used for error handling */\n+/* (setting of status and traps) and for the rounding mode, only.     */\n+/* If an error occurs, the result will be a valid decimal128 NaN.     */\n+/* ------------------------------------------------------------------ */\n+decimal128 *\n+decimal128FromString (decimal128 * result, char *string, decContext * set)\n+{\n+  decContext dc;\t\t/* work */\n+  decNumber dn;\t\t\t/* .. */\n+\n+  decContextDefault (&dc, DEC_INIT_DECIMAL128);\t/* no traps, please */\n+  dc.round = set->round;\t/* use supplied rounding */\n+\n+  decNumberFromString (&dn, string, &dc);\t/* will round if needed */\n+  decimal128FromNumber (result, &dn, &dc);\n+  if (dc.status != 0)\n+    {\t\t\t\t/* something happened */\n+      decContextSetStatus (set, dc.status);\t/* .. pass it on */\n+    }\n+  return result;\n+}\n+\n+\n+#if DECTRACE || DECCHECK\n+/* ------------------------------------------------------------------ */\n+/* decimal128Show -- display a single in hexadecimal [debug aid]      */\n+/*   d128 -- the number to show                                       */\n+/* ------------------------------------------------------------------ */\n+/* Also shows sign/cob/expconfields extracted */\n+void\n+decimal128Show (decimal128 * d128)\n+{\n+  char buf[DECIMAL128_Bytes * 2 + 1];\n+  Int i, j;\n+  j = 0;\n+  for (i = 0; i < DECIMAL128_Bytes; i++)\n+    {\n+      sprintf (&buf[j], \"%02x\", d128->bytes[i]);\n+      j = j + 2;\n+    }\n+  printf (\" D128> %s [S:%d Cb:%02x E:%d]\\n\", buf,\n+\t  decimal128Sign (d128), decimal128Comb (d128),\n+\t  decimal128ExpCon (d128));\n+}\n+#endif"}, {"sha": "381750ef00e35da1539c568389a0932236fcf35c", "filename": "libdecnumber/decimal128.h", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/473a74b91eb1dd5e7c98c238cb33b047fb5ed01a/libdecnumber%2Fdecimal128.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/473a74b91eb1dd5e7c98c238cb33b047fb5ed01a/libdecnumber%2Fdecimal128.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libdecnumber%2Fdecimal128.h?ref=473a74b91eb1dd5e7c98c238cb33b047fb5ed01a", "patch": "@@ -0,0 +1,113 @@\n+/* Decimal 128-bit format module header for the decNumber C Library\n+   Copyright (C) 2005 Free Software Foundation, Inc.\n+   Contributed by IBM Corporation.  Author Mike Cowlishaw.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 2, or (at your option) any later\n+   version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+   for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING.  If not, write to the Free\n+   Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+   02111-1307, USA.  */\n+\n+#if !defined(DECIMAL128)\n+#define DECIMAL128\n+#define DEC128NAME     \"decimal128\"\t/* Short name */\n+#define DEC128FULLNAME \"Decimal 128-bit Number\"\t/* Verbose name */\n+#define DEC128AUTHOR   \"Mike Cowlishaw\"\t/* Who to blame */\n+\n+#if defined(DECIMAL32)\n+#error decimal128.h must precede decimal32.h for correct DECNUMDIGITS\n+#else\n+#if defined(DECIMAL64)\n+#error decimal128.h must precede decimal64.h for correct DECNUMDIGITS\n+#endif\n+#endif\n+\n+  /* parameters for decimal128s */\n+#define DECIMAL128_Bytes  16\t/* length */\n+#define DECIMAL128_Pmax   34\t/* maximum precision (digits) */\n+#define DECIMAL128_Emax   6144\t/* maximum adjusted exponent */\n+#define DECIMAL128_Emin  -6143\t/* minimum adjusted exponent */\n+#define DECIMAL128_Bias   6176\t/* bias for the exponent */\n+#define DECIMAL128_String 43\t/* maximum string length, +1 */\n+  /* highest biased exponent (Elimit-1) */\n+#define DECIMAL128_Ehigh  (DECIMAL128_Emax+DECIMAL128_Bias-DECIMAL128_Pmax+1)\n+\n+#ifndef DECNUMDIGITS\n+#define DECNUMDIGITS DECIMAL128_Pmax\t/* size if not already defined */\n+#endif\n+#ifndef DECNUMBER\n+#include \"decNumber.h\"\t\t/* context and number library */\n+#endif\n+\n+  /* Decimal 128-bit type, accessible by bytes */\n+typedef struct\n+{\n+  uint8_t bytes[DECIMAL128_Bytes];\t/* decimal128: 1, 5, 12, 110 bits */\n+} decimal128;\n+\n+  /* special values [top byte excluding sign bit; last two bits are\n+     don't-care for Infinity on input, last bit don't-care for NaN] */\n+#if !defined(DECIMAL_NaN)\n+#define DECIMAL_NaN     0x7c\t/* 0 11111 00 NaN */\n+#define DECIMAL_sNaN    0x7e\t/* 0 11111 10 sNaN */\n+#define DECIMAL_Inf     0x78\t/* 0 11110 00 Infinity */\n+#endif\n+\n+  /* Macros for accessing decimal128 fields.  These assume the argument\n+     is a reference (pointer) to the decimal128 structure */\n+  /* Get sign */\n+#define decimal128Sign(d)       ((unsigned)(d)->bytes[0]>>7)\n+\n+  /* Get combination field */\n+#define decimal128Comb(d)       (((d)->bytes[0] & 0x7c)>>2)\n+\n+  /* Get exponent continuation [does not remove bias] */\n+#define decimal128ExpCon(d)     ((((d)->bytes[0] & 0x03)<<10)       \\\n+                                | ((unsigned)(d)->bytes[1]<<2)        \\\n+                                | ((unsigned)(d)->bytes[2]>>6))\n+\n+  /* Set sign [this assumes sign previously 0] */\n+#define decimal128SetSign(d, b) {                                   \\\n+    (d)->bytes[0]|=((unsigned)(b)<<7);}\n+\n+  /* Set exponent continuation [does not apply bias] */\n+  /* This assumes range has been checked and exponent previously 0; */\n+  /* type of exponent must be unsigned */\n+#define decimal128SetExpCon(d, e) {                                 \\\n+    (d)->bytes[0]|=(uint8_t)((e)>>10);                                \\\n+    (d)->bytes[1] =(uint8_t)(((e)&0x3fc)>>2);                         \\\n+    (d)->bytes[2]|=(uint8_t)(((e)&0x03)<<6);}\n+\n+  /* ------------------------------------------------------------------ */\n+  /* Routines                                                           */\n+  /* ------------------------------------------------------------------ */\n+\n+#ifdef IN_LIBGCC2\n+#define decimal128FromString __decimal128FromString\n+#define decimal128ToString __decimal128ToString\n+#define decimal128ToEngString __decimal128ToEngString\n+#define decimal128FromNumber __decimal128FromNumber\n+#define decimal128ToNumber __decimal128ToNumber\n+#endif\n+\n+  /* String conversions */\n+decimal128 *decimal128FromString (decimal128 *, char *, decContext *);\n+char *decimal128ToString (decimal128 *, char *);\n+char *decimal128ToEngString (decimal128 *, char *);\n+\n+  /* decNumber conversions */\n+decimal128 *decimal128FromNumber (decimal128 *, decNumber *, decContext *);\n+decNumber *decimal128ToNumber (decimal128 *, decNumber *);\n+\n+#endif"}, {"sha": "20bdf28b6c1f94d1939c87ae57748dc4cfa51fba", "filename": "libdecnumber/decimal32.c", "status": "added", "additions": 327, "deletions": 0, "changes": 327, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/473a74b91eb1dd5e7c98c238cb33b047fb5ed01a/libdecnumber%2Fdecimal32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/473a74b91eb1dd5e7c98c238cb33b047fb5ed01a/libdecnumber%2Fdecimal32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libdecnumber%2Fdecimal32.c?ref=473a74b91eb1dd5e7c98c238cb33b047fb5ed01a", "patch": "@@ -0,0 +1,327 @@\n+/* Decimal 32-bit format module for the decNumber C Library\n+   Copyright (C) 2005 Free Software Foundation, Inc.\n+   Contributed by IBM Corporation.  Author Mike Cowlishaw.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 2, or (at your option) any later\n+   version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+   for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING.  If not, write to the Free\n+   Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+   02111-1307, USA.  */\n+\n+/* ------------------------------------------------------------------ */\n+/* This module comprises the routines for decimal32 format numbers.   */\n+/* Conversions are supplied to and from decNumber and String.         */\n+/*                                                                    */\n+/* No arithmetic routines are included; decNumber provides these.     */\n+/*                                                                    */\n+/* Error handling is the same as decNumber (qv.).                     */\n+/* ------------------------------------------------------------------ */\n+#include <string.h>\t\t/* [for memset/memcpy] */\n+#include <stdio.h>\t\t/* [for printf] */\n+\n+#define  DECNUMDIGITS  7\t/* we need decNumbers with space for 7 */\n+#include \"decNumber.h\"\t\t/* base number library */\n+#include \"decNumberLocal.h\"\t/* decNumber local types, etc. */\n+#include \"decimal32.h\"\t\t/* our primary include */\n+#include \"decUtility.h\"\t\t/* utility routines */\n+\n+#if DECTRACE || DECCHECK\n+void decimal32Show (decimal32 *);\t/* for debug */\n+void decNumberShow (decNumber *);\t/* .. */\n+#endif\n+\n+/* Useful macro */\n+/* Clear a structure (e.g., a decNumber) */\n+#define DEC_clear(d) memset(d, 0, sizeof(*d))\n+\n+/* ------------------------------------------------------------------ */\n+/* decimal32FromNumber -- convert decNumber to decimal32              */\n+/*                                                                    */\n+/*   ds is the target decimal32                                       */\n+/*   dn is the source number (assumed valid)                          */\n+/*   set is the context, used only for reporting errors               */\n+/*                                                                    */\n+/* The set argument is used only for status reporting and for the     */\n+/* rounding mode (used if the coefficient is more than DECIMAL32_Pmax */\n+/* digits or an overflow is detected).  If the exponent is out of the */\n+/* valid range then Overflow or Underflow will be raised.             */\n+/* After Underflow a subnormal result is possible.                    */\n+/*                                                                    */\n+/* DEC_Clamped is set if the number has to be 'folded down' to fit,   */\n+/* by reducing its exponent and multiplying the coefficient by a      */\n+/* power of ten, or if the exponent on a zero had to be clamped.      */\n+/* ------------------------------------------------------------------ */\n+decimal32 *\n+decimal32FromNumber (decimal32 * d32, decNumber * dn, decContext * set)\n+{\n+  uInt status = 0;\t\t/* status accumulator */\n+  Int pad = 0;\t\t\t/* coefficient pad digits */\n+  decNumber dw;\t\t\t/* work */\n+  decContext dc;\t\t/* .. */\n+  uByte isneg = dn->bits & DECNEG;\t/* non-0 if original sign set */\n+  uInt comb, exp;\t\t/* work */\n+\n+  /* If the number is finite, and has too many digits, or the exponent */\n+  /* could be out of range then we reduce the number under the */\n+  /* appropriate constraints */\n+  if (!(dn->bits & DECSPECIAL))\n+    {\t\t\t\t/* not a special value */\n+      Int ae = dn->exponent + dn->digits - 1;\t/* adjusted exponent */\n+      if (dn->digits > DECIMAL32_Pmax\t/* too many digits */\n+\t  || ae > DECIMAL32_Emax\t/* likely overflow */\n+\t  || ae < DECIMAL32_Emin)\n+\t{\t\t\t/* likely underflow */\n+\t  decContextDefault (&dc, DEC_INIT_DECIMAL32);\t/* [no traps] */\n+\t  dc.round = set->round;\t/* use supplied rounding */\n+\t  decNumberPlus (&dw, dn, &dc);\t/* (round and check) */\n+\t  /* [this changes -0 to 0, but it will be restored below] */\n+\t  status |= dc.status;\t/* save status */\n+\t  dn = &dw;\t\t/* use the work number */\n+\t}\n+      /* [this could have pushed number to Infinity or zero, so this */\n+      /* rounding must be done before we generate the decimal32] */\n+    }\n+\n+  DEC_clear (d32);\t\t/* clean the target */\n+  if (dn->bits & DECSPECIAL)\n+    {\t\t\t\t/* a special value */\n+      uByte top;\t\t/* work */\n+      if (dn->bits & DECINF)\n+\ttop = DECIMAL_Inf;\n+      else\n+\t{\t\t\t/* sNaN or qNaN */\n+\t  if ((*dn->lsu != 0 || dn->digits > 1)\t/* non-zero coefficient */\n+\t      && (dn->digits < DECIMAL32_Pmax))\n+\t    {\t\t\t/* coefficient fits */\n+\t      decDensePackCoeff (dn, d32->bytes, sizeof (d32->bytes), 0);\n+\t    }\n+\t  if (dn->bits & DECNAN)\n+\t    top = DECIMAL_NaN;\n+\t  else\n+\t    top = DECIMAL_sNaN;\n+\t}\n+      d32->bytes[0] = top;\n+    }\n+  else if (decNumberIsZero (dn))\n+    {\t\t\t\t/* a zero */\n+      /* set and clamp exponent */\n+      if (dn->exponent < -DECIMAL32_Bias)\n+\t{\n+\t  exp = 0;\n+\t  status |= DEC_Clamped;\n+\t}\n+      else\n+\t{\n+\t  exp = dn->exponent + DECIMAL32_Bias;\t/* bias exponent */\n+\t  if (exp > DECIMAL32_Ehigh)\n+\t    {\t\t\t/* top clamp */\n+\t      exp = DECIMAL32_Ehigh;\n+\t      status |= DEC_Clamped;\n+\t    }\n+\t}\n+      comb = (exp >> 3) & 0x18;\t/* combination field */\n+      d32->bytes[0] = (uByte) (comb << 2);\n+      exp &= 0x3f;\t\t/* remaining exponent bits */\n+      decimal32SetExpCon (d32, exp);\n+    }\n+  else\n+    {\t\t\t\t/* non-zero finite number */\n+      uInt msd;\t\t\t/* work */\n+\n+      /* we have a dn that fits, but it may need to be padded */\n+      exp = (uInt) (dn->exponent + DECIMAL32_Bias);\t/* bias exponent */\n+\n+      if (exp > DECIMAL32_Ehigh)\n+\t{\t\t\t/* fold-down case */\n+\t  pad = exp - DECIMAL32_Ehigh;\n+\t  exp = DECIMAL32_Ehigh;\t/* [to maximum] */\n+\t  status |= DEC_Clamped;\n+\t}\n+\n+      decDensePackCoeff (dn, d32->bytes, sizeof (d32->bytes), pad);\n+\n+      /* save and clear the top digit */\n+      msd = ((unsigned) d32->bytes[1] >> 4);\n+      d32->bytes[1] &= 0x0f;\n+      /* create the combination field */\n+      if (msd >= 8)\n+\tcomb = 0x18 | (msd & 0x01) | ((exp >> 5) & 0x06);\n+      else\n+\tcomb = (msd & 0x07) | ((exp >> 3) & 0x18);\n+      d32->bytes[0] = (uByte) (comb << 2);\n+      exp &= 0x3f;\t\t/* remaining exponent bits */\n+      decimal32SetExpCon (d32, exp);\n+    }\n+\n+  if (isneg)\n+    decimal32SetSign (d32, 1);\n+  if (status != 0)\n+    decContextSetStatus (set, status);\t/* pass on status */\n+\n+  /*decimal32Show(d32); */\n+  return d32;\n+}\n+\n+/* ------------------------------------------------------------------ */\n+/* decimal32ToNumber -- convert decimal32 to decNumber                */\n+/*   d32 is the source decimal32                                      */\n+/*   dn is the target number, with appropriate space                  */\n+/* No error is possible.                                              */\n+/* ------------------------------------------------------------------ */\n+decNumber *\n+decimal32ToNumber (decimal32 * d32, decNumber * dn)\n+{\n+  uInt msd;\t\t\t/* coefficient MSD */\n+  decimal32 wk;\t\t\t/* working copy, if needed */\n+  uInt top = d32->bytes[0] & 0x7f;\t/* top byte, less sign bit */\n+  decNumberZero (dn);\t\t/* clean target */\n+  /* set the sign if negative */\n+  if (decimal32Sign (d32))\n+    dn->bits = DECNEG;\n+\n+  if (top >= 0x78)\n+    {\t\t\t\t/* is a special */\n+      if ((top & 0x7c) == (DECIMAL_Inf & 0x7c))\n+\tdn->bits |= DECINF;\n+      else if ((top & 0x7e) == (DECIMAL_NaN & 0x7e))\n+\tdn->bits |= DECNAN;\n+      else\n+\tdn->bits |= DECSNAN;\n+      msd = 0;\t\t\t/* no top digit */\n+    }\n+  else\n+    {\t\t\t\t/* have a finite number */\n+      uInt comb = top >> 2;\t/* combination field */\n+      uInt exp;\t\t\t/* working exponent */\n+\n+      if (comb >= 0x18)\n+\t{\n+\t  msd = 8 + (comb & 0x01);\n+\t  exp = (comb & 0x06) << 5;\t/* MSBs */\n+\t}\n+      else\n+\t{\n+\t  msd = comb & 0x07;\n+\t  exp = (comb & 0x18) << 3;\n+\t}\n+      dn->exponent = exp + decimal32ExpCon (d32) - DECIMAL32_Bias;\t/* remove bias */\n+    }\n+\n+  /* get the coefficient, unless infinite */\n+  if (!(dn->bits & DECINF))\n+    {\n+      Int bunches = DECIMAL32_Pmax / 3;\t/* coefficient full bunches to convert */\n+      Int odd = 0;\t\t/* assume MSD is 0 (no odd bunch) */\n+      if (msd != 0)\n+\t{\t\t\t/* coefficient has leading non-0 digit */\n+\t  /* make a copy of the decimal32, with an extra bunch which has */\n+\t  /* the top digit ready for conversion */\n+\t  wk = *d32;\t\t/* take a copy */\n+\t  wk.bytes[0] = 0;\t/* clear all but coecon */\n+\t  wk.bytes[1] &= 0x0f;\t/* .. */\n+\t  wk.bytes[1] |= (msd << 4);\t/* and prefix MSD */\n+\t  odd++;\t\t/* indicate the extra */\n+\t  d32 = &wk;\t\t/* use the work copy */\n+\t}\n+      decDenseUnpackCoeff (d32->bytes, sizeof (d32->bytes), dn, bunches, odd);\n+    }\n+  return dn;\n+}\n+\n+/* ------------------------------------------------------------------ */\n+/* to-scientific-string -- conversion to numeric string               */\n+/* to-engineering-string -- conversion to numeric string              */\n+/*                                                                    */\n+/*   decimal32ToString(d32, string);                                  */\n+/*   decimal32ToEngString(d32, string);                               */\n+/*                                                                    */\n+/*  d32 is the decimal32 format number to convert                     */\n+/*  string is the string where the result will be laid out            */\n+/*                                                                    */\n+/*  string must be at least 24 characters                             */\n+/*                                                                    */\n+/*  No error is possible, and no status can be set.                   */\n+/* ------------------------------------------------------------------ */\n+char *\n+decimal32ToString (decimal32 * d32, char *string)\n+{\n+  decNumber dn;\t\t\t/* work */\n+  decimal32ToNumber (d32, &dn);\n+  decNumberToString (&dn, string);\n+  return string;\n+}\n+\n+char *\n+decimal32ToEngString (decimal32 * d32, char *string)\n+{\n+  decNumber dn;\t\t\t/* work */\n+  decimal32ToNumber (d32, &dn);\n+  decNumberToEngString (&dn, string);\n+  return string;\n+}\n+\n+/* ------------------------------------------------------------------ */\n+/* to-number -- conversion from numeric string                        */\n+/*                                                                    */\n+/*   decimal32FromString(result, string, set);                        */\n+/*                                                                    */\n+/*  result  is the decimal32 format number which gets the result of   */\n+/*          the conversion                                            */\n+/*  *string is the character string which should contain a valid      */\n+/*          number (which may be a special value)                     */\n+/*  set     is the context                                            */\n+/*                                                                    */\n+/* The context is supplied to this routine is used for error handling */\n+/* (setting of status and traps) and for the rounding mode, only.     */\n+/* If an error occurs, the result will be a valid decimal32 NaN.      */\n+/* ------------------------------------------------------------------ */\n+decimal32 *\n+decimal32FromString (decimal32 * result, char *string, decContext * set)\n+{\n+  decContext dc;\t\t/* work */\n+  decNumber dn;\t\t\t/* .. */\n+\n+  decContextDefault (&dc, DEC_INIT_DECIMAL32);\t/* no traps, please */\n+  dc.round = set->round;\t/* use supplied rounding */\n+\n+  decNumberFromString (&dn, string, &dc);\t/* will round if needed */\n+  decimal32FromNumber (result, &dn, &dc);\n+  if (dc.status != 0)\n+    {\t\t\t\t/* something happened */\n+      decContextSetStatus (set, dc.status);\t/* .. pass it on */\n+    }\n+  return result;\n+}\n+\n+#if DECTRACE || DECCHECK\n+/* ------------------------------------------------------------------ */\n+/* decimal32Show -- display a single in hexadecimal [debug aid]       */\n+/*   d32 -- the number to show                                        */\n+/* ------------------------------------------------------------------ */\n+/* Also shows sign/cob/expconfields extracted */\n+void\n+decimal32Show (decimal32 * d32)\n+{\n+  char buf[DECIMAL32_Bytes * 2 + 1];\n+  Int i, j;\n+  j = 0;\n+  for (i = 0; i < DECIMAL32_Bytes; i++)\n+    {\n+      sprintf (&buf[j], \"%02x\", d32->bytes[i]);\n+      j = j + 2;\n+    }\n+  printf (\" D32> %s [S:%d Cb:%02x E:%d]\\n\", buf,\n+\t  decimal32Sign (d32), decimal32Comb (d32), decimal32ExpCon (d32));\n+}\n+#endif"}, {"sha": "541858ed417ecf27e3206a132feca172c0188804", "filename": "libdecnumber/decimal32.h", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/473a74b91eb1dd5e7c98c238cb33b047fb5ed01a/libdecnumber%2Fdecimal32.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/473a74b91eb1dd5e7c98c238cb33b047fb5ed01a/libdecnumber%2Fdecimal32.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libdecnumber%2Fdecimal32.h?ref=473a74b91eb1dd5e7c98c238cb33b047fb5ed01a", "patch": "@@ -0,0 +1,103 @@\n+/* Decimal 32-bit format module header for the decNumber C Library\n+   Copyright (C) 2005 Free Software Foundation, Inc.\n+   Contributed by IBM Corporation.  Author Mike Cowlishaw.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 2, or (at your option) any later\n+   version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+   for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING.  If not, write to the Free\n+   Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+   02111-1307, USA.  */\n+\n+#if !defined(DECIMAL32)\n+#define DECIMAL32\n+#define DEC32NAME     \"decimal32\"\t/* Short name */\n+#define DEC32FULLNAME \"Decimal 32-bit Number\"\t/* Verbose name */\n+#define DEC32AUTHOR   \"Mike Cowlishaw\"\t/* Who to blame */\n+\n+  /* parameters for decimal32s */\n+#define DECIMAL32_Bytes  4\t/* length */\n+#define DECIMAL32_Pmax   7\t/* maximum precision (digits) */\n+#define DECIMAL32_Emax   96\t/* maximum adjusted exponent */\n+#define DECIMAL32_Emin  -95\t/* minimum adjusted exponent */\n+#define DECIMAL32_Bias   101\t/* bias for the exponent */\n+#define DECIMAL32_String 15\t/* maximum string length, +1 */\n+  /* highest biased exponent (Elimit-1) */\n+#define DECIMAL32_Ehigh  (DECIMAL32_Emax+DECIMAL32_Bias-DECIMAL32_Pmax+1)\n+\n+#ifndef DECNUMDIGITS\n+#define DECNUMDIGITS DECIMAL32_Pmax\t/* size if not already defined */\n+#endif\n+#ifndef DECNUMBER\n+#include \"decNumber.h\"\t\t/* context and number library */\n+#endif\n+\n+  /* Decimal 32-bit type, accessible by bytes */\n+typedef struct\n+{\n+  uint8_t bytes[DECIMAL32_Bytes];\t/* decimal32: 1, 5, 6, 20 bits */\n+} decimal32;\n+\n+  /* special values [top byte excluding sign bit; last two bits are\n+     don't-care for Infinity on input, last bit don't-care for NaN] */\n+#if !defined(DECIMAL_NaN)\n+#define DECIMAL_NaN     0x7c\t/* 0 11111 00 NaN */\n+#define DECIMAL_sNaN    0x7e\t/* 0 11111 10 sNaN */\n+#define DECIMAL_Inf     0x78\t/* 0 11110 00 Infinity */\n+#endif\n+\n+  /* Macros for accessing decimal32 fields.  These assume the argument\n+     is a reference (pointer) to the decimal32 structure */\n+  /* Get sign */\n+#define decimal32Sign(d)       ((unsigned)(d)->bytes[0]>>7)\n+\n+  /* Get combination field */\n+#define decimal32Comb(d)       (((d)->bytes[0] & 0x7c)>>2)\n+\n+  /* Get exponent continuation [does not remove bias] */\n+#define decimal32ExpCon(d)     ((((d)->bytes[0] & 0x03)<<4)         \\\n+                               | ((unsigned)(d)->bytes[1]>>4))\n+\n+  /* Set sign [this assumes sign previously 0] */\n+#define decimal32SetSign(d, b) {                                    \\\n+    (d)->bytes[0]|=((unsigned)(b)<<7);}\n+\n+  /* Set exponent continuation [does not apply bias] */\n+  /* This assumes range has been checked and exponent previously 0; */\n+  /* type of exponent must be unsigned */\n+#define decimal32SetExpCon(d, e) {                                  \\\n+    (d)->bytes[0]|=(uint8_t)((e)>>4);                                 \\\n+    (d)->bytes[1]|=(uint8_t)(((e)&0x0F)<<4);}\n+\n+  /* ------------------------------------------------------------------ */\n+  /* Routines                                                           */\n+  /* ------------------------------------------------------------------ */\n+\n+#ifdef IN_LIBGCC2\n+#define decimal32FromString __decimal32FromString\n+#define decimal32ToString __decimal32ToString\n+#define decimal32ToEngString __decimal32ToEngString\n+#define decimal32FromNumber __decimal32FromNumber\n+#define decimal32ToNumber __decimal32ToNumber\n+#endif\n+\n+/* String conversions.  */\n+decimal32 *decimal32FromString (decimal32 *, char *, decContext *);\n+char *decimal32ToString (decimal32 *, char *);\n+char *decimal32ToEngString (decimal32 *, char *);\n+\n+/* decNumber conversions.  */\n+decimal32 *decimal32FromNumber (decimal32 *, decNumber *, decContext *);\n+decNumber *decimal32ToNumber (decimal32 *, decNumber *);\n+\n+#endif"}, {"sha": "c6e2394823f455a9635d48033e7cae85e8ed34c2", "filename": "libdecnumber/decimal64.c", "status": "added", "additions": 327, "deletions": 0, "changes": 327, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/473a74b91eb1dd5e7c98c238cb33b047fb5ed01a/libdecnumber%2Fdecimal64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/473a74b91eb1dd5e7c98c238cb33b047fb5ed01a/libdecnumber%2Fdecimal64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libdecnumber%2Fdecimal64.c?ref=473a74b91eb1dd5e7c98c238cb33b047fb5ed01a", "patch": "@@ -0,0 +1,327 @@\n+/* Decimal 64-bit format module for the decNumber C Library\n+   Copyright (C) 2005 Free Software Foundation, Inc.\n+   Contributed by IBM Corporation.  Author Mike Cowlishaw.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 2, or (at your option) any later\n+   version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+   for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING.  If not, write to the Free\n+   Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+   02111-1307, USA.  */\n+\n+/* ------------------------------------------------------------------ */\n+/* This module comprises the routines for decimal64 format numbers.   */\n+/* Conversions are supplied to and from decNumber and String.         */\n+/*                                                                    */\n+/* No arithmetic routines are included; decNumber provides these.     */\n+/*                                                                    */\n+/* Error handling is the same as decNumber (qv.).                     */\n+/* ------------------------------------------------------------------ */\n+#include <string.h>\t\t/* [for memset/memcpy] */\n+#include <stdio.h>\t\t/* [for printf] */\n+\n+#define  DECNUMDIGITS 16\t/* we need decNumbers with space for 16 */\n+#include \"decNumber.h\"\t\t/* base number library */\n+#include \"decNumberLocal.h\"\t/* decNumber local types, etc. */\n+#include \"decimal64.h\"\t\t/* our primary include */\n+#include \"decUtility.h\"\t\t/* utility routines */\n+\n+#if DECTRACE || DECCHECK\n+void decimal64Show (decimal64 *);\t/* for debug */\n+void decNumberShow (decNumber *);\t/* .. */\n+#endif\n+\n+/* Useful macro */\n+/* Clear a structure (e.g., a decNumber) */\n+#define DEC_clear(d) memset(d, 0, sizeof(*d))\n+\n+/* ------------------------------------------------------------------ */\n+/* decimal64FromNumber -- convert decNumber to decimal64              */\n+/*                                                                    */\n+/*   ds is the target decimal64                                       */\n+/*   dn is the source number (assumed valid)                          */\n+/*   set is the context, used only for reporting errors               */\n+/*                                                                    */\n+/* The set argument is used only for status reporting and for the     */\n+/* rounding mode (used if the coefficient is more than DECIMAL64_Pmax */\n+/* digits or an overflow is detected).  If the exponent is out of the */\n+/* valid range then Overflow or Underflow will be raised.             */\n+/* After Underflow a subnormal result is possible.                    */\n+/*                                                                    */\n+/* DEC_Clamped is set if the number has to be 'folded down' to fit,   */\n+/* by reducing its exponent and multiplying the coefficient by a      */\n+/* power of ten, or if the exponent on a zero had to be clamped.      */\n+/* ------------------------------------------------------------------ */\n+decimal64 *\n+decimal64FromNumber (decimal64 * d64, decNumber * dn, decContext * set)\n+{\n+  uInt status = 0;\t\t/* status accumulator */\n+  Int pad = 0;\t\t\t/* coefficient pad digits */\n+  decNumber dw;\t\t\t/* work */\n+  decContext dc;\t\t/* .. */\n+  uByte isneg = dn->bits & DECNEG;\t/* non-0 if original sign set */\n+  uInt comb, exp;\t\t/* work */\n+\n+  /* If the number is finite, and has too many digits, or the exponent */\n+  /* could be out of range then we reduce the number under the */\n+  /* appropriate constraints */\n+  if (!(dn->bits & DECSPECIAL))\n+    {\t\t\t\t/* not a special value */\n+      Int ae = dn->exponent + dn->digits - 1;\t/* adjusted exponent */\n+      if (dn->digits > DECIMAL64_Pmax\t/* too many digits */\n+\t  || ae > DECIMAL64_Emax\t/* likely overflow */\n+\t  || ae < DECIMAL64_Emin)\n+\t{\t\t\t/* likely underflow */\n+\t  decContextDefault (&dc, DEC_INIT_DECIMAL64);\t/* [no traps] */\n+\t  dc.round = set->round;\t/* use supplied rounding */\n+\t  decNumberPlus (&dw, dn, &dc);\t/* (round and check) */\n+\t  /* [this changes -0 to 0, but it will be restored below] */\n+\t  status |= dc.status;\t/* save status */\n+\t  dn = &dw;\t\t/* use the work number */\n+\t}\n+      /* [this could have pushed number to Infinity or zero, so this */\n+      /* rounding must be done before we generate the decimal64] */\n+    }\n+\n+  DEC_clear (d64);\t\t/* clean the target */\n+  if (dn->bits & DECSPECIAL)\n+    {\t\t\t\t/* a special value */\n+      uByte top;\t\t/* work */\n+      if (dn->bits & DECINF)\n+\ttop = DECIMAL_Inf;\n+      else\n+\t{\t\t\t/* sNaN or qNaN */\n+\t  if ((*dn->lsu != 0 || dn->digits > 1)\t/* non-zero coefficient */\n+\t      && (dn->digits < DECIMAL64_Pmax))\n+\t    {\t\t\t/* coefficient fits */\n+\t      decDensePackCoeff (dn, d64->bytes, sizeof (d64->bytes), 0);\n+\t    }\n+\t  if (dn->bits & DECNAN)\n+\t    top = DECIMAL_NaN;\n+\t  else\n+\t    top = DECIMAL_sNaN;\n+\t}\n+      d64->bytes[0] = top;\n+    }\n+  else if (decNumberIsZero (dn))\n+    {\t\t\t\t/* a zero */\n+      /* set and clamp exponent */\n+      if (dn->exponent < -DECIMAL64_Bias)\n+\t{\n+\t  exp = 0;\n+\t  status |= DEC_Clamped;\n+\t}\n+      else\n+\t{\n+\t  exp = dn->exponent + DECIMAL64_Bias;\t/* bias exponent */\n+\t  if (exp > DECIMAL64_Ehigh)\n+\t    {\t\t\t/* top clamp */\n+\t      exp = DECIMAL64_Ehigh;\n+\t      status |= DEC_Clamped;\n+\t    }\n+\t}\n+      comb = (exp >> 5) & 0x18;\t/* combination field */\n+      d64->bytes[0] = (uByte) (comb << 2);\n+      exp &= 0xff;\t\t/* remaining exponent bits */\n+      decimal64SetExpCon (d64, exp);\n+    }\n+  else\n+    {\t\t\t\t/* non-zero finite number */\n+      uInt msd;\t\t\t/* work */\n+\n+      /* we have a dn that fits, but it may need to be padded */\n+      exp = (uInt) (dn->exponent + DECIMAL64_Bias);\t/* bias exponent */\n+      if (exp > DECIMAL64_Ehigh)\n+\t{\t\t\t/* fold-down case */\n+\t  pad = exp - DECIMAL64_Ehigh;\n+\t  exp = DECIMAL64_Ehigh;\t/* [to maximum] */\n+\t  status |= DEC_Clamped;\n+\t}\n+\n+      decDensePackCoeff (dn, d64->bytes, sizeof (d64->bytes), pad);\n+\n+      /* save and clear the top digit */\n+      msd = ((unsigned) d64->bytes[1] >> 2) & 0x0f;\n+      d64->bytes[1] &= 0x03;\n+      /* create the combination field */\n+      if (msd >= 8)\n+\tcomb = 0x18 | (msd & 0x01) | ((exp >> 7) & 0x06);\n+      else\n+\tcomb = (msd & 0x07) | ((exp >> 5) & 0x18);\n+      d64->bytes[0] = (uByte) (comb << 2);\n+      exp &= 0xff;\t\t/* remaining exponent bits */\n+      decimal64SetExpCon (d64, exp);\n+    }\n+\n+  if (isneg)\n+    decimal64SetSign (d64, 1);\n+  if (status != 0)\n+    decContextSetStatus (set, status);\t/* pass on status */\n+\n+  /*decimal64Show(d64); */\n+  return d64;\n+}\n+\n+/* ------------------------------------------------------------------ */\n+/* decimal64ToNumber -- convert decimal64 to decNumber                */\n+/*   d64 is the source decimal64                                      */\n+/*   dn is the target number, with appropriate space                  */\n+/* No error is possible.                                              */\n+/* ------------------------------------------------------------------ */\n+decNumber *\n+decimal64ToNumber (decimal64 * d64, decNumber * dn)\n+{\n+  uInt msd;\t\t\t/* coefficient MSD */\n+  decimal64 wk;\t\t\t/* working copy, if needed */\n+  uInt top = d64->bytes[0] & 0x7f;\t/* top byte, less sign bit */\n+  decNumberZero (dn);\t\t/* clean target */\n+  /* set the sign if negative */\n+  if (decimal64Sign (d64))\n+    dn->bits = DECNEG;\n+\n+  if (top >= 0x78)\n+    {\t\t\t\t/* is a special */\n+      if ((top & 0x7c) == (DECIMAL_Inf & 0x7c))\n+\tdn->bits |= DECINF;\n+      else if ((top & 0x7e) == (DECIMAL_NaN & 0x7e))\n+\tdn->bits |= DECNAN;\n+      else\n+\tdn->bits |= DECSNAN;\n+      msd = 0;\t\t\t/* no top digit */\n+    }\n+  else\n+    {\t\t\t\t/* have a finite number */\n+      uInt comb = top >> 2;\t/* combination field */\n+      uInt exp;\t\t\t/* exponent */\n+\n+      if (comb >= 0x18)\n+\t{\n+\t  msd = 8 + (comb & 0x01);\n+\t  exp = (comb & 0x06) << 7;\t/* MSBs */\n+\t}\n+      else\n+\t{\n+\t  msd = comb & 0x07;\n+\t  exp = (comb & 0x18) << 5;\n+\t}\n+      dn->exponent = exp + decimal64ExpCon (d64) - DECIMAL64_Bias;\t/* remove bias */\n+    }\n+\n+  /* get the coefficient, unless infinite */\n+  if (!(dn->bits & DECINF))\n+    {\n+      Int bunches = DECIMAL64_Pmax / 3;\t/* coefficient full bunches to convert */\n+      Int odd = 0;\t\t/* assume MSD is 0 (no odd bunch) */\n+      if (msd != 0)\n+\t{\t\t\t/* coefficient has leading non-0 digit */\n+\t  /* make a copy of the decimal64, with an extra bunch which has */\n+\t  /* the top digit ready for conversion */\n+\t  wk = *d64;\t\t/* take a copy */\n+\t  wk.bytes[0] = 0;\t/* clear all but coecon */\n+\t  wk.bytes[1] &= 0x03;\t/* .. */\n+\t  wk.bytes[1] |= (msd << 2);\t/* and prefix MSD */\n+\t  odd++;\t\t/* indicate the extra */\n+\t  d64 = &wk;\t\t/* use the work copy */\n+\t}\n+      decDenseUnpackCoeff (d64->bytes, sizeof (d64->bytes), dn, bunches, odd);\n+    }\n+  return dn;\n+}\n+\n+/* ------------------------------------------------------------------ */\n+/* to-scientific-string -- conversion to numeric string               */\n+/* to-engineering-string -- conversion to numeric string              */\n+/*                                                                    */\n+/*   decimal64ToString(d64, string);                                  */\n+/*   decimal64ToEngString(d64, string);                               */\n+/*                                                                    */\n+/*  d64 is the decimal64 format number to convert                     */\n+/*  string is the string where the result will be laid out            */\n+/*                                                                    */\n+/*  string must be at least 24 characters                             */\n+/*                                                                    */\n+/*  No error is possible, and no status can be set.                   */\n+/* ------------------------------------------------------------------ */\n+char *\n+decimal64ToString (decimal64 * d64, char *string)\n+{\n+  decNumber dn;\t\t\t/* work */\n+  decimal64ToNumber (d64, &dn);\n+  decNumberToString (&dn, string);\n+  return string;\n+}\n+\n+char *\n+decimal64ToEngString (decimal64 * d64, char *string)\n+{\n+  decNumber dn;\t\t\t/* work */\n+  decimal64ToNumber (d64, &dn);\n+  decNumberToEngString (&dn, string);\n+  return string;\n+}\n+\n+/* ------------------------------------------------------------------ */\n+/* to-number -- conversion from numeric string                        */\n+/*                                                                    */\n+/*   decimal64FromString(result, string, set);                        */\n+/*                                                                    */\n+/*  result  is the decimal64 format number which gets the result of   */\n+/*          the conversion                                            */\n+/*  *string is the character string which should contain a valid      */\n+/*          number (which may be a special value)                     */\n+/*  set     is the context                                            */\n+/*                                                                    */\n+/* The context is supplied to this routine is used for error handling */\n+/* (setting of status and traps) and for the rounding mode, only.     */\n+/* If an error occurs, the result will be a valid decimal64 NaN.      */\n+/* ------------------------------------------------------------------ */\n+decimal64 *\n+decimal64FromString (decimal64 * result, char *string, decContext * set)\n+{\n+  decContext dc;\t\t/* work */\n+  decNumber dn;\t\t\t/* .. */\n+\n+  decContextDefault (&dc, DEC_INIT_DECIMAL64);\t/* no traps, please */\n+  dc.round = set->round;\t/* use supplied rounding */\n+\n+  decNumberFromString (&dn, string, &dc);\t/* will round if needed */\n+\n+  decimal64FromNumber (result, &dn, &dc);\n+  if (dc.status != 0)\n+    {\t\t\t\t/* something happened */\n+      decContextSetStatus (set, dc.status);\t/* .. pass it on */\n+    }\n+  return result;\n+}\n+\n+#if DECTRACE || DECCHECK\n+/* ------------------------------------------------------------------ */\n+/* decimal64Show -- display a single in hexadecimal [debug aid]       */\n+/*   d64 -- the number to show                                        */\n+/* ------------------------------------------------------------------ */\n+/* Also shows sign/cob/expconfields extracted */\n+void\n+decimal64Show (decimal64 * d64)\n+{\n+  char buf[DECIMAL64_Bytes * 2 + 1];\n+  Int i, j;\n+  j = 0;\n+  for (i = 0; i < DECIMAL64_Bytes; i++)\n+    {\n+      sprintf (&buf[j], \"%02x\", d64->bytes[i]);\n+      j = j + 2;\n+    }\n+  printf (\" D64> %s [S:%d Cb:%02x E:%d]\\n\", buf,\n+\t  decimal64Sign (d64), decimal64Comb (d64), decimal64ExpCon (d64));\n+}\n+#endif"}, {"sha": "a282df1e86ece8c91b866707f030677f8a021dbf", "filename": "libdecnumber/decimal64.h", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/473a74b91eb1dd5e7c98c238cb33b047fb5ed01a/libdecnumber%2Fdecimal64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/473a74b91eb1dd5e7c98c238cb33b047fb5ed01a/libdecnumber%2Fdecimal64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libdecnumber%2Fdecimal64.h?ref=473a74b91eb1dd5e7c98c238cb33b047fb5ed01a", "patch": "@@ -0,0 +1,107 @@\n+/* Decimal 64-bit format module header for the decNumber C Library\n+   Copyright (C) 2005 Free Software Foundation, Inc.\n+   Contributed by IBM Corporation.  Author Mike Cowlishaw.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 2, or (at your option) any later\n+   version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+   for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING.  If not, write to the Free\n+   Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+   02111-1307, USA.  */\n+\n+#if !defined(DECIMAL64)\n+#define DECIMAL64\n+#define DEC64NAME     \"decimal64\"\t/* Short name */\n+#define DEC64FULLNAME \"Decimal 64-bit Number\"\t/* Verbose name */\n+#define DEC64AUTHOR   \"Mike Cowlishaw\"\t/* Who to blame */\n+\n+#if defined(DECIMAL32)\n+#error decimal64.h must precede decimal32.h for correct DECNUMDIGITS\n+#endif\n+\n+  /* parameters for decimal64s */\n+#define DECIMAL64_Bytes  8\t/* length */\n+#define DECIMAL64_Pmax   16\t/* maximum precision (digits) */\n+#define DECIMAL64_Emax   384\t/* maximum adjusted exponent */\n+#define DECIMAL64_Emin  -383\t/* minimum adjusted exponent */\n+#define DECIMAL64_Bias   398\t/* bias for the exponent */\n+#define DECIMAL64_String 24\t/* maximum string length, +1 */\n+  /* highest biased exponent (Elimit-1) */\n+#define DECIMAL64_Ehigh  (DECIMAL64_Emax+DECIMAL64_Bias-DECIMAL64_Pmax+1)\n+\n+#ifndef DECNUMDIGITS\n+#define DECNUMDIGITS DECIMAL64_Pmax\t/* size if not already defined */\n+#endif\n+#ifndef DECNUMBER\n+#include \"decNumber.h\"\t\t/* context and number library */\n+#endif\n+\n+  /* Decimal 64-bit type, accessible by bytes */\n+typedef struct\n+{\n+  uint8_t bytes[DECIMAL64_Bytes];\t/* decimal64: 1, 5, 8, 50 bits */\n+} decimal64;\n+\n+  /* special values [top byte excluding sign bit; last two bits are\n+     don't-care for Infinity on input, last bit don't-care for NaN] */\n+#if !defined(DECIMAL_NaN)\n+#define DECIMAL_NaN     0x7c\t/* 0 11111 00 NaN */\n+#define DECIMAL_sNaN    0x7e\t/* 0 11111 10 sNaN */\n+#define DECIMAL_Inf     0x78\t/* 0 11110 00 Infinity */\n+#endif\n+\n+  /* Macros for accessing decimal64 fields.  These assume the argument\n+     is a reference (pointer) to the decimal64 structure */\n+  /* Get sign */\n+#define decimal64Sign(d)       ((unsigned)(d)->bytes[0]>>7)\n+\n+  /* Get combination field */\n+#define decimal64Comb(d)       (((d)->bytes[0] & 0x7c)>>2)\n+\n+  /* Get exponent continuation [does not remove bias] */\n+#define decimal64ExpCon(d)     ((((d)->bytes[0] & 0x03)<<6)         \\\n+                               | ((unsigned)(d)->bytes[1]>>2))\n+\n+  /* Set sign [this assumes sign previously 0] */\n+#define decimal64SetSign(d, b) {                                    \\\n+    (d)->bytes[0]|=((unsigned)(b)<<7);}\n+\n+  /* Set exponent continuation [does not apply bias] */\n+  /* This assumes range has been checked and exponent previously 0; type */\n+  /* of exponent must be unsigned */\n+#define decimal64SetExpCon(d, e) {                                  \\\n+    (d)->bytes[0]|=(uint8_t)((e)>>6);                                 \\\n+    (d)->bytes[1]|=(uint8_t)(((e)&0x3F)<<2);}\n+\n+  /* ------------------------------------------------------------------ */\n+  /* Routines                                                           */\n+  /* ------------------------------------------------------------------ */\n+\n+#ifdef IN_LIBGCC2\n+#define decimal64FromString __decimal64FromString\n+#define decimal64ToString __decimal64ToString\n+#define decimal64ToEngString __decimal64ToEngString\n+#define decimal64FromNumber __decimal64FromNumber\n+#define decimal64ToNumber __decimal64ToNumber\n+#endif\n+\n+  /* String conversions */\n+decimal64 *decimal64FromString (decimal64 *, char *, decContext *);\n+char *decimal64ToString (decimal64 *, char *);\n+char *decimal64ToEngString (decimal64 *, char *);\n+\n+  /* decNumber conversions */\n+decimal64 *decimal64FromNumber (decimal64 *, decNumber *, decContext *);\n+decNumber *decimal64ToNumber (decimal64 *, decNumber *);\n+\n+#endif"}]}