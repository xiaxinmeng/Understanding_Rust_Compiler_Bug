{"sha": "48f6bfac395697f131fc89a52fad6b20e3612471", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDhmNmJmYWMzOTU2OTdmMTMxZmM4OWE1MmZhZDZiMjBlMzYxMjQ3MQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-10-12T22:35:07Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-10-12T22:35:07Z"}, "message": "(output_prolog): Put out file and line number if sdb debugging format...\n\n(output_prolog): Put out file and line number if sdb debugging format, put out\n.ent directive, signal start of function for alpha_output_filename and set updebugging auto/arg offsets.\n(output_epilog): Signal end of function for alpha_output_filename.\n(alpha_output_filename, alpha_output_lineno): New functions.\n\nFrom-SVN: r5759", "tree": {"sha": "9647418457e99ca9a537cd3df600b253e3954edc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9647418457e99ca9a537cd3df600b253e3954edc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/48f6bfac395697f131fc89a52fad6b20e3612471", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48f6bfac395697f131fc89a52fad6b20e3612471", "html_url": "https://github.com/Rust-GCC/gccrs/commit/48f6bfac395697f131fc89a52fad6b20e3612471", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48f6bfac395697f131fc89a52fad6b20e3612471/comments", "author": null, "committer": null, "parents": [{"sha": "691e5fb4042a60976bbc70d794f326d525df74fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/691e5fb4042a60976bbc70d794f326d525df74fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/691e5fb4042a60976bbc70d794f326d525df74fc"}], "stats": {"total": 133, "additions": 133, "deletions": 0}, "files": [{"sha": "e03fbd5588c668fd6be5f46596f19744a1caae7c", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48f6bfac395697f131fc89a52fad6b20e3612471/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48f6bfac395697f131fc89a52fad6b20e3612471/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=48f6bfac395697f131fc89a52fad6b20e3612471", "patch": "@@ -48,6 +48,16 @@ int alpha_compare_fp_p;\n \n char *alpha_function_name;\n \n+/* Non-zero if inside of a function, because the Alpha asm can't\n+   handle .files inside of functions.  */\n+\n+static int inside_function = FALSE;\n+\n+/* Whether to suppress issuing .loc's because the user attempted\n+   to change the filename within a function.  */\n+\n+static int ignore_line_number = FALSE;\n+\n /* Nonzero if the current function needs gp.  */\n \n int alpha_function_needs_gp;\n@@ -1189,6 +1199,35 @@ output_prolog (file, size)\n   unsigned reg_mask = 0;\n   int i;\n \n+  /* Ecoff can handle multiple .file directives, put out file and lineno.\n+     We have to do that before the .ent directive as we cannot switch\n+     files within procedures with native ecoff because line numbers are\n+     linked to procedure descriptors.\n+     Outputting the lineno helps debugging of one line functions as they\n+     would otherwise get no line number at all. Please note that we would\n+     like to put out last_linenum from final.c, but it is not accesible.  */\n+\n+  if (write_symbols == SDB_DEBUG)\n+    {\n+      ASM_OUTPUT_SOURCE_FILENAME (file,\n+\t\t\t\t  DECL_SOURCE_FILE (current_function_decl));\n+      if (debug_info_level != DINFO_LEVEL_TERSE)\n+        ASM_OUTPUT_SOURCE_LINE (file, DECL_SOURCE_LINE (current_function_decl));\n+    }\n+\n+  /* The assembly language programmer's guide states that the second argument\n+     to the .ent directive, the lex_level, is ignored by the assembler,\n+     so we might as well omit it.  */\n+     \n+  fprintf (file, \"\\t.ent %s\\n\", alpha_function_name);\n+  ASM_OUTPUT_LABEL (file, alpha_function_name);\n+  inside_function = TRUE;\n+\n+  /* Set up offsets to alpha virtual arg/local debugging pointer.  */\n+\n+  alpha_auto_offset = -frame_size + current_function_pretend_args_size;\n+  alpha_arg_offset = -frame_size + 48;\n+\n   /* If we need a GP (we have a LDSYM insn or a CALL_INSN), load it first. \n      Even if we are a static function, we still need to do this in case\n      our address is taken and passed to something like qsort.  */\n@@ -1445,7 +1484,101 @@ output_epilog (file, size)\n \n   /* End the function.  */\n   fprintf (file, \"\\t.end %s\\n\", alpha_function_name);\n+  inside_function = FALSE;\n+  ignore_line_number = FALSE;\n \n   /* Show that we know this function if it is called again.  */\n   SYMBOL_REF_FLAG (XEXP (DECL_RTL (current_function_decl), 0)) = 1;\n }\n+\f\n+/* Debugging support.  */\n+\n+#include \"gstab.h\"\n+\n+/* Count the number of sdb related labels are generated (to find block\n+   start and end boundaries).  */\n+\n+int sdb_label_count = 0;\n+\n+/* Next label # for each statement.  */\n+\n+static int sym_lineno = 0;\n+\n+/* Count the number of .file directives, so that .loc is up to date.  */\n+\n+static int num_source_filenames = 0;\n+\n+/* Name of the file containing the current function.  */\n+\n+static char *current_function_file = \"\";\n+\n+/* Offsets to alpha virtual arg/local debugging pointers.  */\n+\n+long alpha_arg_offset;\n+long alpha_auto_offset;\n+\f\n+/* Emit a new filename to a stream.  */\n+\n+void\n+alpha_output_filename (stream, name)\n+     FILE *stream;\n+     char *name;\n+{\n+  static int first_time = TRUE;\n+  char ltext_label_name[100];\n+\n+  if (first_time)\n+    {\n+      first_time = FALSE;\n+      ++num_source_filenames;\n+      current_function_file = name;\n+      fprintf (stream, \"\\t.file\\t%d \", num_source_filenames);\n+      output_quoted_string (stream, name);\n+      fprintf (stream, \"\\n\");\n+      if (!TARGET_GAS && write_symbols == DBX_DEBUG)\n+\tfprintf (stream, \"\\t#@stabs\\n\");\n+    }\n+\n+  else if (!TARGET_GAS && write_symbols == DBX_DEBUG)\n+    {\n+      ASM_GENERATE_INTERNAL_LABEL (ltext_label_name, \"Ltext\", 0);\n+      fprintf (stream, \"%s \", ASM_STABS_OP);\n+      output_quoted_string (stream, name);\n+      fprintf (stream, \",%d,0,0,%s\\n\", N_SOL, &ltext_label_name[1]);\n+    }\n+\n+  else if (name != current_function_file\n+      && strcmp (name, current_function_file) != 0)\n+    {\n+      if (inside_function && ! TARGET_GAS)\n+\tfprintf (stream, \"\\t#.file\\t%d \", num_source_filenames);\n+      else\n+\t{\n+\t  ++num_source_filenames;\n+\t  current_function_file = name;\n+\t  fprintf (stream, \"\\t.file\\t%d \", num_source_filenames);\n+\t}\n+\n+      output_quoted_string (stream, name);\n+      fprintf (stream, \"\\n\");\n+    }\n+}\n+\f\n+/* Emit a linenumber to a stream.  */\n+\n+void\n+alpha_output_lineno (stream, line)\n+     FILE *stream;\n+     int line;\n+{\n+  if (! TARGET_GAS && write_symbols == DBX_DEBUG)\n+    {\n+      /* mips-tfile doesn't understand .stabd directives.  */\n+      ++sym_lineno;\n+      fprintf (stream, \"$LM%d:\\n\\t%s %d,0,%d,$LM%d\\n\",\n+\t       sym_lineno, ASM_STABN_OP, N_SLINE, line, sym_lineno);\n+    }\n+  else\n+    fprintf (stream, \"\\n\\t%s.loc\\t%d %d\\n\", (ignore_line_number) ? \"#\" : \"\",\n+\t     num_source_filenames, line);\n+}"}]}