{"sha": "0b7b376d89fcaf1abccf11da606d612d9f4cc378", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGI3YjM3NmQ4OWZjYWYxYWJjY2YxMWRhNjA2ZDYxMmQ5ZjRjYzM3OA==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2010-05-10T09:43:17Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2010-05-10T09:43:17Z"}, "message": "c-common.c (struct c_common_attributes): Add fnspec attribute.\n\n2010-05-10  Richard Guenther  <rguenther@suse.de>\n\n\t* c-common.c (struct c_common_attributes): Add fnspec attribute.\n\t(handle_fnspec_attribute): New function.\n\t* gimple.h (gimple_call_return_flags): Declare.\n\t(gimple_call_arg_flags): Likewise.\n\t* gimple.c (gimple_call_arg_flags): New function.\n\t(gimple_call_return_flags): Likewise.\n\t* tree.h (EAF_DIRECT, EAF_NOCLOBBER, EAF_NOESCAPE, EAF_UNUSED):\n\tNew argument flags.\n\t(ERF_RETURN_ARG_MASK, ERF_RETURNS_ARG, ERF_NOALIAS): New function\n\treturn value flags.\n\t* tree-ssa-alias.c (ref_maybe_used_by_call_p_1): Skip unused args.\n\t* tree-ssa-structalias.c (make_constraint_from_heapvar): Split\n\tmain work to ...\n\t(make_heapvar_for): ... this new function.\n\t(handle_rhs_call): Handle fnspec attribute argument specifiers.\n\t(handle_lhs_call): Likewise.\n\t(find_func_aliases): Adjust.\n\n\tfortran/\n\t* trans-decl.c (gfc_build_library_function_decl): Split out\n\tworker to ...\n\t(build_library_function_decl_1): ... this new function.\n\tSet a fnspec attribute if a specification was provided.\n\t(gfc_build_library_function_decl_with_spec): New function.\n\t(gfc_build_intrinsic_function_decls): Annotate internal_pack\n\tand internal_unpack.\n\nFrom-SVN: r159215", "tree": {"sha": "df80e1fff82251162890e6945cab6479837e953a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/df80e1fff82251162890e6945cab6479837e953a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0b7b376d89fcaf1abccf11da606d612d9f4cc378", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b7b376d89fcaf1abccf11da606d612d9f4cc378", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b7b376d89fcaf1abccf11da606d612d9f4cc378", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b7b376d89fcaf1abccf11da606d612d9f4cc378/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1755aad0945c2f55a23ae98f5f2e19bdce3ed4e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1755aad0945c2f55a23ae98f5f2e19bdce3ed4e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1755aad0945c2f55a23ae98f5f2e19bdce3ed4e7"}], "stats": {"total": 342, "additions": 301, "deletions": 41}, "files": [{"sha": "e31c2f4bc41c137ebe0aedc190847d906e79036b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b7b376d89fcaf1abccf11da606d612d9f4cc378/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b7b376d89fcaf1abccf11da606d612d9f4cc378/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0b7b376d89fcaf1abccf11da606d612d9f4cc378", "patch": "@@ -1,3 +1,23 @@\n+2010-05-10  Richard Guenther  <rguenther@suse.de>\n+\n+\t* c-common.c (struct c_common_attributes): Add fnspec attribute.\n+\t(handle_fnspec_attribute): New function.\n+\t* gimple.h (gimple_call_return_flags): Declare.\n+\t(gimple_call_arg_flags): Likewise.\n+\t* gimple.c (gimple_call_arg_flags): New function.\n+\t(gimple_call_return_flags): Likewise.\n+\t* tree.h (EAF_DIRECT, EAF_NOCLOBBER, EAF_NOESCAPE, EAF_UNUSED):\n+\tNew argument flags.\n+\t(ERF_RETURN_ARG_MASK, ERF_RETURNS_ARG, ERF_NOALIAS): New function\n+\treturn value flags.\n+\t* tree-ssa-alias.c (ref_maybe_used_by_call_p_1): Skip unused args.\n+\t* tree-ssa-structalias.c (make_constraint_from_heapvar): Split\n+\tmain work to ...\n+\t(make_heapvar_for): ... this new function.\n+\t(handle_rhs_call): Handle fnspec attribute argument specifiers.\n+\t(handle_lhs_call): Likewise.\n+\t(find_func_aliases): Adjust.\n+\n 2010-05-10  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/44050"}, {"sha": "7dce96214ea1c5dbeabe3fe3418cf82d78fa9a85", "filename": "gcc/c-common.c", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b7b376d89fcaf1abccf11da606d612d9f4cc378/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b7b376d89fcaf1abccf11da606d612d9f4cc378/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=0b7b376d89fcaf1abccf11da606d612d9f4cc378", "patch": "@@ -529,6 +529,7 @@ static tree handle_type_generic_attribute (tree *, tree, tree, int, bool *);\n static tree handle_alloc_size_attribute (tree *, tree, tree, int, bool *);\n static tree handle_target_attribute (tree *, tree, tree, int, bool *);\n static tree handle_optimize_attribute (tree *, tree, tree, int, bool *);\n+static tree handle_fnspec_attribute (tree *, tree, tree, int, bool *);\n \n static void check_function_nonnull (tree, int, tree *);\n static void check_nonnull_arg (void *, tree, unsigned HOST_WIDE_INT);\n@@ -829,6 +830,10 @@ const struct attribute_spec c_common_attribute_table[] =\n \t\t\t      handle_target_attribute },\n   { \"optimize\",               1, -1, true, false, false,\n \t\t\t      handle_optimize_attribute },\n+  /* For internal use (marking of builtins and runtime functions) only.\n+     The name contains space to prevent its usage in source code.  */\n+  { \"fn spec\",\t \t      1, 1, false, true, true,\n+\t\t\t      handle_fnspec_attribute },\n   { NULL,                     0, 0, false, false, false, NULL }\n };\n \n@@ -7138,6 +7143,20 @@ handle_alloc_size_attribute (tree *node, tree ARG_UNUSED (name), tree args,\n   return NULL_TREE;\n }\n \n+/* Handle a \"fn spec\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+handle_fnspec_attribute (tree *node ATTRIBUTE_UNUSED, tree ARG_UNUSED (name),\n+\t\t\t tree args, int ARG_UNUSED (flags),\n+\t\t\t bool *no_add_attrs ATTRIBUTE_UNUSED)\n+{\n+  gcc_assert (args\n+\t      && TREE_CODE (TREE_VALUE (args)) == STRING_CST\n+\t      && !TREE_CHAIN (args));\n+  return NULL_TREE;\n+}\n+\n /* Handle a \"returns_twice\" attribute; arguments as in\n    struct attribute_spec.handler.  */\n "}, {"sha": "2b488fc7ac0d1355936198e186e8c69781a08949", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b7b376d89fcaf1abccf11da606d612d9f4cc378/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b7b376d89fcaf1abccf11da606d612d9f4cc378/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=0b7b376d89fcaf1abccf11da606d612d9f4cc378", "patch": "@@ -1,3 +1,13 @@\n+2010-05-10  Richard Guenther  <rguenther@suse.de>\n+\n+\t* trans-decl.c (gfc_build_library_function_decl): Split out\n+\tworker to ...\n+\t(build_library_function_decl_1): ... this new function.\n+\tSet a fnspec attribute if a specification was provided.\n+\t(gfc_build_library_function_decl_with_spec): New function.\n+\t(gfc_build_intrinsic_function_decls): Annotate internal_pack\n+\tand internal_unpack.\n+\n 2010-05-07  Daniel Franke  <franke.daniel@gmail.com>\n \n \tPR fortran/40728"}, {"sha": "64d87caa073309c849afbe9a0090c3da7cc9310d", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 46, "deletions": 12, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b7b376d89fcaf1abccf11da606d612d9f4cc378/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b7b376d89fcaf1abccf11da606d612d9f4cc378/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=0b7b376d89fcaf1abccf11da606d612d9f4cc378", "patch": "@@ -2317,22 +2317,19 @@ gfc_get_fake_result_decl (gfc_symbol * sym, int parent_flag)\n /* Builds a function decl.  The remaining parameters are the types of the\n    function arguments.  Negative nargs indicates a varargs function.  */\n \n-tree\n-gfc_build_library_function_decl (tree name, tree rettype, int nargs, ...)\n+static tree\n+build_library_function_decl_1 (tree name, const char *spec,\n+\t\t\t       tree rettype, int nargs, va_list p)\n {\n   tree arglist;\n   tree argtype;\n   tree fntype;\n   tree fndecl;\n-  va_list p;\n   int n;\n \n   /* Library functions must be declared with global scope.  */\n   gcc_assert (current_function_decl == NULL_TREE);\n \n-  va_start (p, nargs);\n-\n-\n   /* Create a list of the argument types.  */\n   for (arglist = NULL_TREE, n = abs (nargs); n > 0; n--)\n     {\n@@ -2348,22 +2345,59 @@ gfc_build_library_function_decl (tree name, tree rettype, int nargs, ...)\n \n   /* Build the function type and decl.  */\n   fntype = build_function_type (rettype, arglist);\n+  if (spec)\n+    {\n+      tree attr_args = build_tree_list (NULL_TREE,\n+\t\t\t\t\tbuild_string (strlen (spec), spec));\n+      tree attrs = tree_cons (get_identifier (\"fn spec\"),\n+\t\t\t      attr_args, TYPE_ATTRIBUTES (fntype));\n+      fntype = build_type_attribute_variant (fntype, attrs);\n+    }\n   fndecl = build_decl (input_location,\n \t\t       FUNCTION_DECL, name, fntype);\n \n   /* Mark this decl as external.  */\n   DECL_EXTERNAL (fndecl) = 1;\n   TREE_PUBLIC (fndecl) = 1;\n \n-  va_end (p);\n-\n   pushdecl (fndecl);\n \n   rest_of_decl_compilation (fndecl, 1, 0);\n \n   return fndecl;\n }\n \n+/* Builds a function decl.  The remaining parameters are the types of the\n+   function arguments.  Negative nargs indicates a varargs function.  */\n+\n+tree\n+gfc_build_library_function_decl (tree name, tree rettype, int nargs, ...)\n+{\n+  tree ret;\n+  va_list args;\n+  va_start (args, nargs);\n+  ret = build_library_function_decl_1 (name, NULL, rettype, nargs, args);\n+  va_end (args);\n+  return ret;\n+}\n+\n+/* Builds a function decl.  The remaining parameters are the types of the\n+   function arguments.  Negative nargs indicates a varargs function.\n+   The SPEC parameter specifies the function argument and return type\n+   specification according to the fnspec function type attribute.  */\n+\n+static tree\n+gfc_build_library_function_decl_with_spec (tree name, const char *spec,\n+\t\t\t\t\t   tree rettype, int nargs, ...)\n+{\n+  tree ret;\n+  va_list args;\n+  va_start (args, nargs);\n+  ret = build_library_function_decl_1 (name, spec, rettype, nargs, args);\n+  va_end (args);\n+  return ret;\n+}\n+\n static void\n gfc_build_intrinsic_function_decls (void)\n {\n@@ -2821,12 +2855,12 @@ gfc_build_builtin_function_decls (void)\n     gfc_build_library_function_decl (get_identifier (PREFIX(\"set_max_subrecord_length\")),\n \t\t\t\t     void_type_node, 1, integer_type_node);\n \n-  gfor_fndecl_in_pack = gfc_build_library_function_decl (\n-        get_identifier (PREFIX(\"internal_pack\")),\n+  gfor_fndecl_in_pack = gfc_build_library_function_decl_with_spec (\n+        get_identifier (PREFIX(\"internal_pack\")), \".r\",\n         pvoid_type_node, 1, pvoid_type_node);\n \n-  gfor_fndecl_in_unpack = gfc_build_library_function_decl (\n-        get_identifier (PREFIX(\"internal_unpack\")),\n+  gfor_fndecl_in_unpack = gfc_build_library_function_decl_with_spec (\n+        get_identifier (PREFIX(\"internal_unpack\")), \".wR\",\n         void_type_node, 2, pvoid_type_node, pvoid_type_node);\n \n   gfor_fndecl_associated ="}, {"sha": "6f3ba6dfb3a1578c1d45b769ef5ef846dc5edb17", "filename": "gcc/gimple.c", "status": "modified", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b7b376d89fcaf1abccf11da606d612d9f4cc378/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b7b376d89fcaf1abccf11da606d612d9f4cc378/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=0b7b376d89fcaf1abccf11da606d612d9f4cc378", "patch": "@@ -1756,6 +1756,80 @@ gimple_call_flags (const_gimple stmt)\n   return flags;\n }\n \n+/* Detects argument flags for argument number ARG on call STMT.  */\n+\n+int\n+gimple_call_arg_flags (const_gimple stmt, unsigned arg)\n+{\n+  tree type = TREE_TYPE (TREE_TYPE (gimple_call_fn (stmt)));\n+  tree attr = lookup_attribute (\"fn spec\", TYPE_ATTRIBUTES (type));\n+  if (!attr)\n+    return 0;\n+\n+  attr = TREE_VALUE (TREE_VALUE (attr));\n+  if (1 + arg >= (unsigned) TREE_STRING_LENGTH (attr))\n+    return 0;\n+\n+  switch (TREE_STRING_POINTER (attr)[1 + arg])\n+    {\n+    case 'x':\n+    case 'X':\n+      return EAF_UNUSED;\n+\n+    case 'R':\n+      return EAF_DIRECT | EAF_NOCLOBBER | EAF_NOESCAPE;\n+\n+    case 'r':\n+      return EAF_NOCLOBBER | EAF_NOESCAPE;\n+\n+    case 'W':\n+      return EAF_DIRECT | EAF_NOESCAPE;\n+\n+    case 'w':\n+      return EAF_NOESCAPE;\n+\n+    case '.':\n+    default:\n+      return 0;\n+    }\n+}\n+\n+/* Detects return flags for the call STMT.  */\n+\n+int\n+gimple_call_return_flags (const_gimple stmt)\n+{\n+  tree type;\n+  tree attr = NULL_TREE;\n+\n+  if (gimple_call_flags (stmt) & ECF_MALLOC)\n+    return ERF_NOALIAS;\n+\n+  type = TREE_TYPE (TREE_TYPE (gimple_call_fn (stmt)));\n+  attr = lookup_attribute (\"fn spec\", TYPE_ATTRIBUTES (type));\n+  if (!attr)\n+    return 0;\n+\n+  attr = TREE_VALUE (TREE_VALUE (attr));\n+  if (TREE_STRING_LENGTH (attr) < 1)\n+    return 0;\n+\n+  switch (TREE_STRING_POINTER (attr)[0])\n+    {\n+    case '1':\n+    case '2':\n+    case '3':\n+    case '4':\n+      return ERF_RETURNS_ARG | (TREE_STRING_POINTER (attr)[0] - '1');\n+\n+    case 'm':\n+      return ERF_NOALIAS;\n+\n+    case '.':\n+    default:\n+      return 0;\n+    }\n+}\n \n /* Return true if GS is a copy assignment.  */\n "}, {"sha": "4f1c4d4035585d5fe1d6e2c480eeab6ce24ad911", "filename": "gcc/gimple.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b7b376d89fcaf1abccf11da606d612d9f4cc378/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b7b376d89fcaf1abccf11da606d612d9f4cc378/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=0b7b376d89fcaf1abccf11da606d612d9f4cc378", "patch": "@@ -857,6 +857,8 @@ void gimple_seq_free (gimple_seq);\n void gimple_seq_add_seq (gimple_seq *, gimple_seq);\n gimple_seq gimple_seq_copy (gimple_seq);\n int gimple_call_flags (const_gimple);\n+int gimple_call_return_flags (const_gimple);\n+int gimple_call_arg_flags (const_gimple, unsigned);\n void gimple_call_reset_alias_info (gimple);\n bool gimple_assign_copy_p (gimple);\n bool gimple_assign_ssa_name_copy_p (gimple);"}, {"sha": "715c2f10f9a87edbd558f0e90393f82de9dc2c91", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b7b376d89fcaf1abccf11da606d612d9f4cc378/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b7b376d89fcaf1abccf11da606d612d9f4cc378/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=0b7b376d89fcaf1abccf11da606d612d9f4cc378", "patch": "@@ -1097,6 +1097,10 @@ ref_maybe_used_by_call_p_1 (gimple call, ao_ref *ref)\n   for (i = 0; i < gimple_call_num_args (call); ++i)\n     {\n       tree op = gimple_call_arg (call, i);\n+      int flags = gimple_call_arg_flags (call, i);\n+\n+      if (flags & EAF_UNUSED)\n+\tcontinue;\n \n       if (TREE_CODE (op) == WITH_SIZE_EXPR)\n \top = TREE_OPERAND (op, 0);"}, {"sha": "a45c6d52c6b5a26b1b7ff190b3e511b4ea72fe3c", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 102, "deletions": 29, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b7b376d89fcaf1abccf11da606d612d9f4cc378/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b7b376d89fcaf1abccf11da606d612d9f4cc378/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=0b7b376d89fcaf1abccf11da606d612d9f4cc378", "patch": "@@ -3599,11 +3599,11 @@ make_transitive_closure_constraints (varinfo_t vi)\n   process_constraint (new_constraint (lhs, rhs));\n }\n \n-/* Create a new artificial heap variable with NAME and make a\n-   constraint from it to LHS.  Return the created variable.  */\n+/* Create a new artificial heap variable with NAME.\n+   Return the created variable.  */\n \n static varinfo_t\n-make_constraint_from_heapvar (varinfo_t lhs, const char *name)\n+make_heapvar_for (varinfo_t lhs, const char *name)\n {\n   varinfo_t vi;\n   tree heapvar = heapvar_lookup (lhs->decl, lhs->offset);\n@@ -3635,6 +3635,16 @@ make_constraint_from_heapvar (varinfo_t lhs, const char *name)\n   vi->is_full_var = true;\n   insert_vi_for_tree (heapvar, vi);\n \n+  return vi;\n+}\n+\n+/* Create a new artificial heap variable with NAME and make a\n+   constraint from it to LHS.  Return the created variable.  */\n+\n+static varinfo_t\n+make_constraint_from_heapvar (varinfo_t lhs, const char *name)\n+{\n+  varinfo_t vi = make_heapvar_for (lhs, name);\n   make_constraint_from (lhs, vi->id);\n \n   return vi;\n@@ -3709,17 +3719,61 @@ handle_rhs_call (gimple stmt, VEC(ce_s, heap) **results)\n {\n   struct constraint_expr rhsc;\n   unsigned i;\n+  bool returns_uses = false;\n \n   for (i = 0; i < gimple_call_num_args (stmt); ++i)\n     {\n       tree arg = gimple_call_arg (stmt, i);\n+      int flags = gimple_call_arg_flags (stmt, i);\n \n-      /* Find those pointers being passed, and make sure they end up\n-\t pointing to anything.  */\n-      if (could_have_pointers (arg))\n+      /* If the argument is not used or it does not contain pointers\n+\t we can ignore it.  */\n+      if ((flags & EAF_UNUSED)\n+\t  || !could_have_pointers (arg))\n+\tcontinue;\n+\n+      /* As we compute ESCAPED context-insensitive we do not gain\n+         any precision with just EAF_NOCLOBBER but not EAF_NOESCAPE\n+\t set.  The argument would still get clobbered through the\n+\t escape solution.\n+\t ???  We might get away with less (and more precise) constraints\n+\t if using a temporary for transitively closing things.  */\n+      if ((flags & EAF_NOCLOBBER)\n+\t   && (flags & EAF_NOESCAPE))\n+\t{\n+\t  varinfo_t uses = get_call_use_vi (stmt);\n+\t  if (!(flags & EAF_DIRECT))\n+\t    make_transitive_closure_constraints (uses);\n+\t  make_constraint_to (uses->id, arg);\n+\t  returns_uses = true;\n+\t}\n+      else if (flags & EAF_NOESCAPE)\n+\t{\n+\t  varinfo_t uses = get_call_use_vi (stmt);\n+\t  varinfo_t clobbers = get_call_clobber_vi (stmt);\n+\t  if (!(flags & EAF_DIRECT))\n+\t    {\n+\t      make_transitive_closure_constraints (uses);\n+\t      make_transitive_closure_constraints (clobbers);\n+\t    }\n+\t  make_constraint_to (uses->id, arg);\n+\t  make_constraint_to (clobbers->id, arg);\n+\t  returns_uses = true;\n+\t}\n+      else\n \tmake_escape_constraint (arg);\n     }\n \n+  /* If we added to the calls uses solution make sure we account for\n+     pointers to it to be returned.  */\n+  if (returns_uses)\n+    {\n+      rhsc.var = get_call_use_vi (stmt)->id;\n+      rhsc.offset = 0;\n+      rhsc.type = SCALAR;\n+      VEC_safe_push (ce_s, heap, *results, &rhsc);\n+    }\n+\n   /* The static chain escapes as well.  */\n   if (gimple_call_chain (stmt))\n     make_escape_constraint (gimple_call_chain (stmt));\n@@ -3752,44 +3806,63 @@ handle_rhs_call (gimple stmt, VEC(ce_s, heap) **results)\n    the LHS point to global and escaped variables.  */\n \n static void\n-handle_lhs_call (tree lhs, int flags, VEC(ce_s, heap) *rhsc, tree fndecl)\n+handle_lhs_call (gimple stmt, tree lhs, int flags, VEC(ce_s, heap) *rhsc,\n+\t\t tree fndecl)\n {\n   VEC(ce_s, heap) *lhsc = NULL;\n \n   get_constraint_for (lhs, &lhsc);\n-\n-  if (flags & ECF_MALLOC)\n+  /* If the store is to a global decl make sure to\n+     add proper escape constraints.  */\n+  lhs = get_base_address (lhs);\n+  if (lhs\n+      && DECL_P (lhs)\n+      && is_global_var (lhs))\n+    {\n+      struct constraint_expr tmpc;\n+      tmpc.var = escaped_id;\n+      tmpc.offset = 0;\n+      tmpc.type = SCALAR;\n+      VEC_safe_push (ce_s, heap, lhsc, &tmpc);\n+    }\n+\n+  /* If the call returns an argument unmodified override the rhs\n+     constraints.  */\n+  flags = gimple_call_return_flags (stmt);\n+  if (flags & ERF_RETURNS_ARG\n+      && (flags & ERF_RETURN_ARG_MASK) < gimple_call_num_args (stmt))\n+    {\n+      tree arg;\n+      rhsc = NULL;\n+      arg = gimple_call_arg (stmt, flags & ERF_RETURN_ARG_MASK);\n+      get_constraint_for (arg, &rhsc);\n+      process_all_all_constraints (lhsc, rhsc);\n+      VEC_free (ce_s, heap, rhsc);\n+    }\n+  else if (flags & ERF_NOALIAS)\n     {\n       varinfo_t vi;\n-      vi = make_constraint_from_heapvar (get_vi_for_tree (lhs), \"HEAP\");\n+      struct constraint_expr tmpc;\n+      rhsc = NULL;\n+      vi = make_heapvar_for (get_vi_for_tree (lhs), \"HEAP\");\n       /* We delay marking allocated storage global until we know if\n          it escapes.  */\n       DECL_EXTERNAL (vi->decl) = 0;\n       vi->is_global_var = 0;\n       /* If this is not a real malloc call assume the memory was\n-         initialized and thus may point to global memory.  All\n+\t initialized and thus may point to global memory.  All\n \t builtin functions with the malloc attribute behave in a sane way.  */\n       if (!fndecl\n \t  || DECL_BUILT_IN_CLASS (fndecl) != BUILT_IN_NORMAL)\n \tmake_constraint_from (vi, nonlocal_id);\n+      tmpc.var = vi->id;\n+      tmpc.offset = 0;\n+      tmpc.type = ADDRESSOF;\n+      VEC_safe_push (ce_s, heap, rhsc, &tmpc);\n     }\n-  else if (VEC_length (ce_s, rhsc) > 0)\n-    {\n-      /* If the store is to a global decl make sure to\n-\t add proper escape constraints.  */\n-      lhs = get_base_address (lhs);\n-      if (lhs\n-\t  && DECL_P (lhs)\n-\t  && is_global_var (lhs))\n-\t{\n-\t  struct constraint_expr tmpc;\n-\t  tmpc.var = escaped_id;\n-\t  tmpc.offset = 0;\n-\t  tmpc.type = SCALAR;\n-\t  VEC_safe_push (ce_s, heap, lhsc, &tmpc);\n-\t}\n-      process_all_all_constraints (lhsc, rhsc);\n-    }\n+\n+  process_all_all_constraints (lhsc, rhsc);\n+\n   VEC_free (ce_s, heap, lhsc);\n }\n \n@@ -4202,7 +4275,7 @@ find_func_aliases (gimple origt)\n \t    handle_rhs_call (t, &rhsc);\n \t  if (gimple_call_lhs (t)\n \t      && could_have_pointers (gimple_call_lhs (t)))\n-\t    handle_lhs_call (gimple_call_lhs (t), flags, rhsc, fndecl);\n+\t    handle_lhs_call (t, gimple_call_lhs (t), flags, rhsc, fndecl);\n \t  VEC_free (ce_s, heap, rhsc);\n \t}\n       else"}, {"sha": "7eed68fc1b7520cd42675eb1301d95eb85374e43", "filename": "gcc/tree.h", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b7b376d89fcaf1abccf11da606d612d9f4cc378/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b7b376d89fcaf1abccf11da606d612d9f4cc378/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=0b7b376d89fcaf1abccf11da606d612d9f4cc378", "patch": "@@ -5169,6 +5169,30 @@ extern tree build_duplicate_type (tree);\n extern int flags_from_decl_or_type (const_tree);\n extern int call_expr_flags (const_tree);\n \n+/* Call argument flags.  */\n+\n+/* Nonzero if the argument is not dereferenced recursively, thus only\n+   directly reachable memory is read or written.  */\n+#define EAF_DIRECT\t\t(1 << 0)\n+/* Nonzero if memory reached by the argument is not clobbered.  */\n+#define EAF_NOCLOBBER\t\t(1 << 1)\n+/* Nonzero if the argument does not escape.  */\n+#define EAF_NOESCAPE\t\t(1 << 2)\n+/* Nonzero if the argument is not used by the function.  */\n+#define EAF_UNUSED\t\t(1 << 3)\n+\n+/* Call return flags.  */\n+\n+/* Mask for the argument number that is returned.  Lower two bits of\n+   the return flags, encodes argument slots zero to three.  */\n+#define ERF_RETURN_ARG_MASK\t(3)\n+/* Nonzero if the return value is equal to the argument number\n+   flags & ERF_RETURN_ARG_MASK.  */\n+#define ERF_RETURNS_ARG\t\t(1 << 2)\n+/* Nonzero if the return value does not alias with anything.  Functions\n+   with the malloc attribute have this set on their return value.  */\n+#define ERF_NOALIAS\t\t(1 << 3)\n+\n extern int setjmp_call_p (const_tree);\n extern bool gimple_alloca_call_p (const_gimple);\n extern bool alloca_call_p (const_tree);"}]}