{"sha": "5a47aa2c8c36571a51552e46f3d971c107d5bf88", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWE0N2FhMmM4YzM2NTcxYTUxNTUyZTQ2ZjNkOTcxYzEwN2Q1YmY4OA==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2017-09-28T16:00:57Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2017-09-28T16:00:57Z"}, "message": "jit: handle equality of function pointer types\n\ngcc/jit/ChangeLog:\n\t* jit-recording.c\n\t(gcc::jit::recording::function_type::is_same_type_as): New function.\n\t* jit-recording.h: In namespace gcc::jit::recording::\n\t(type::accepts_writes_from): Use is_same_type_as rather than pointer\n\tequality.\n\t(type::is_same_type_as): New virtual function.\n\t(function_type::is_same_type_as): New override.\n\ngcc/testsuite/ChangeLog:\n\t* jit.dg/test-error-mismatching-types-in-assignment-fn-ptr.c: New\n\ttest case.\n\t* jit.dg/test-returning-function-ptr.c (create_code): Update to\n\tcreate a function pointer type independently of the call to\n\tgcc_jit_function_get_address, and assign the pointer to a local\n\tbefore returning it, to exercise the function pointer type\n\tcomparison code.\n\nFrom-SVN: r253255", "tree": {"sha": "5896869c2602163e4d7f534581d112054601d4e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5896869c2602163e4d7f534581d112054601d4e2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5a47aa2c8c36571a51552e46f3d971c107d5bf88", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a47aa2c8c36571a51552e46f3d971c107d5bf88", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a47aa2c8c36571a51552e46f3d971c107d5bf88", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a47aa2c8c36571a51552e46f3d971c107d5bf88/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f276c46cd81d7a0008c696ddb75638dc6aa25f92", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f276c46cd81d7a0008c696ddb75638dc6aa25f92", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f276c46cd81d7a0008c696ddb75638dc6aa25f92"}], "stats": {"total": 201, "additions": 193, "deletions": 8}, "files": [{"sha": "b5e2ed7868ffeef4c0a139f87e1d0044912473e1", "filename": "gcc/jit/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a47aa2c8c36571a51552e46f3d971c107d5bf88/gcc%2Fjit%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a47aa2c8c36571a51552e46f3d971c107d5bf88/gcc%2Fjit%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2FChangeLog?ref=5a47aa2c8c36571a51552e46f3d971c107d5bf88", "patch": "@@ -1,3 +1,13 @@\n+2017-09-28  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* jit-recording.c\n+\t(gcc::jit::recording::function_type::is_same_type_as): New function.\n+\t* jit-recording.h: In namespace gcc::jit::recording::\n+\t(type::accepts_writes_from): Use is_same_type_as rather than pointer\n+\tequality.\n+\t(type::is_same_type_as): New virtual function.\n+\t(function_type::is_same_type_as): New override.\n+\n 2017-09-27  David Malcolm  <dmalcolm@redhat.com>\n \n \t* docs/cp/topics/expressions.rst (Function pointers): New section."}, {"sha": "6d7dc80049b72ce1f94d17ac34abfbb8354c7e71", "filename": "gcc/jit/jit-recording.c", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a47aa2c8c36571a51552e46f3d971c107d5bf88/gcc%2Fjit%2Fjit-recording.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a47aa2c8c36571a51552e46f3d971c107d5bf88/gcc%2Fjit%2Fjit-recording.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fjit-recording.c?ref=5a47aa2c8c36571a51552e46f3d971c107d5bf88", "patch": "@@ -2643,6 +2643,53 @@ recording::function_type::dereference ()\n   return NULL;\n }\n \n+/* Implementation of virtual hook recording::type::is_same_type_as for\n+   recording::function_type.\n+\n+   We override this to avoid requiring identity of function pointer types,\n+   so that if client code has obtained the same signature in\n+   different ways (e.g. via gcc_jit_context_new_function_ptr_type\n+   vs gcc_jit_function_get_address), the different function_type\n+   instances are treated as compatible.\n+\n+   We can't use type::accepts_writes_from for this as we need a stronger\n+   notion of \"sameness\": if we have a fn_ptr type that has args that are\n+   themselves fn_ptr types, then those args still need to match exactly.\n+\n+   Alternatively, we could consolidate attempts to create identical\n+   function_type instances so that pointer equality works, but that runs\n+   into issues about the lifetimes of the cache (w.r.t. nested contexts).  */\n+\n+bool\n+recording::function_type::is_same_type_as (type *other)\n+{\n+  gcc_assert (other);\n+\n+  function_type *other_fn_type = other->dyn_cast_function_type ();\n+  if (!other_fn_type)\n+    return false;\n+\n+  /* Everything must match.  */\n+\n+  if (!m_return_type->is_same_type_as (other_fn_type->m_return_type))\n+    return false;\n+\n+  if (m_param_types.length () != other_fn_type->m_param_types.length ())\n+    return false;\n+\n+  unsigned i;\n+  type *param_type;\n+  FOR_EACH_VEC_ELT (m_param_types, i, param_type)\n+    if (!param_type->is_same_type_as (other_fn_type->m_param_types[i]))\n+      return false;\n+\n+  if (m_is_variadic != other_fn_type->m_is_variadic)\n+    return false;\n+\n+  /* Passed all tests.  */\n+  return true;\n+}\n+\n /* Implementation of pure virtual hook recording::memento::replay_into\n    for recording::function_type.  */\n "}, {"sha": "91236455a9b9ff3aa4dcc1a11ac5835e09da5938", "filename": "gcc/jit/jit-recording.h", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a47aa2c8c36571a51552e46f3d971c107d5bf88/gcc%2Fjit%2Fjit-recording.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a47aa2c8c36571a51552e46f3d971c107d5bf88/gcc%2Fjit%2Fjit-recording.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fjit-recording.h?ref=5a47aa2c8c36571a51552e46f3d971c107d5bf88", "patch": "@@ -491,7 +491,12 @@ class type : public memento\n   virtual bool accepts_writes_from (type *rtype)\n   {\n     gcc_assert (rtype);\n-    return this->unqualified () == rtype->unqualified ();\n+    return this->unqualified ()->is_same_type_as (rtype->unqualified ());\n+  }\n+\n+  virtual bool is_same_type_as (type *other)\n+  {\n+    return this == other;\n   }\n \n   /* Strip off \"const\" etc */\n@@ -751,6 +756,8 @@ class function_type : public type\n   function_type *dyn_cast_function_type () FINAL OVERRIDE { return this; }\n   function_type *as_a_function_type () FINAL OVERRIDE { return this; }\n \n+  bool is_same_type_as (type *other) FINAL OVERRIDE;\n+\n   bool is_int () const FINAL OVERRIDE { return false; }\n   bool is_float () const FINAL OVERRIDE { return false; }\n   bool is_bool () const FINAL OVERRIDE { return false; }"}, {"sha": "1fff0be9db0a8f8ea917fad6c16d503d2753c5ca", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a47aa2c8c36571a51552e46f3d971c107d5bf88/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a47aa2c8c36571a51552e46f3d971c107d5bf88/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5a47aa2c8c36571a51552e46f3d971c107d5bf88", "patch": "@@ -1,3 +1,13 @@\n+2017-09-28  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* jit.dg/test-error-mismatching-types-in-assignment-fn-ptr.c: New\n+\ttest case.\n+\t* jit.dg/test-returning-function-ptr.c (create_code): Update to\n+\tcreate a function pointer type independently of the call to\n+\tgcc_jit_function_get_address, and assign the pointer to a local\n+\tbefore returning it, to exercise the function pointer type\n+\tcomparison code.\n+\n 2017-09-27  David Malcolm  <dmalcolm@redhat.com>\n \n \t* jit.dg/all-non-failing-tests.h: Add"}, {"sha": "4faa3b41d5fc9cdd4673763c8a8b4175e8518b6c", "filename": "gcc/testsuite/jit.dg/test-error-mismatching-types-in-assignment-fn-ptr.c", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a47aa2c8c36571a51552e46f3d971c107d5bf88/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-mismatching-types-in-assignment-fn-ptr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a47aa2c8c36571a51552e46f3d971c107d5bf88/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-mismatching-types-in-assignment-fn-ptr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-mismatching-types-in-assignment-fn-ptr.c?ref=5a47aa2c8c36571a51552e46f3d971c107d5bf88", "patch": "@@ -0,0 +1,92 @@\n+#include <stdlib.h>\n+#include <stdio.h>\n+\n+#include \"libgccjit.h\"\n+\n+#include \"harness.h\"\n+\n+void\n+create_code (gcc_jit_context *ctxt, void *user_data)\n+{\n+  /* Let's try to inject the equivalent of:\n+\n+     typedef void (*fn_ptr_iii) (int, int, int);\n+     typedef void (*fn_ptr_ifi) (int, float, int);\n+     void\n+     test_fn (void)\n+     {\n+        fn_ptr_iii iii_ptr;\n+        fn_ptr_ifi ifi_ptr;\n+\n+\tiii_ptr = NULL;\n+\tifi_ptr = iii_ptr;\n+     }\n+\n+     and verify that the API complains about the mismatching types\n+     in the second assignment (but not the first).\n+  */\n+  gcc_jit_type *void_type =\n+    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_VOID);\n+  gcc_jit_type *int_type =\n+    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_INT);\n+  gcc_jit_type *float_type =\n+    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_FLOAT);\n+\n+  gcc_jit_type *iii_types[] = {int_type, int_type, int_type};\n+  gcc_jit_type *fn_ptr_type_iii\n+    = gcc_jit_context_new_function_ptr_type (ctxt, NULL,\n+\t\t\t\t\t     void_type,\n+\t\t\t\t\t     3, iii_types,\n+\t\t\t\t\t     0);\n+\n+  gcc_jit_type *ifi_types[] = {int_type, float_type, int_type};\n+  gcc_jit_type *fn_ptr_type_ifi\n+    = gcc_jit_context_new_function_ptr_type (ctxt, NULL,\n+\t\t\t\t\t     void_type,\n+\t\t\t\t\t     3, ifi_types,\n+\t\t\t\t\t     0);\n+\n+  gcc_jit_function *test_fn =\n+    gcc_jit_context_new_function (ctxt, NULL,\n+                                  GCC_JIT_FUNCTION_EXPORTED,\n+                                  void_type,\n+                                  \"test_fn\",\n+                                  0, NULL,\n+                                  0);\n+  gcc_jit_lvalue *iii_ptr =\n+    gcc_jit_function_new_local (\n+      test_fn, NULL, fn_ptr_type_iii, \"iii_ptr\");\n+  gcc_jit_lvalue *ifi_ptr =\n+    gcc_jit_function_new_local (\n+      test_fn, NULL, fn_ptr_type_ifi, \"ifi_ptr\");\n+\n+  gcc_jit_block *block = gcc_jit_function_new_block (test_fn, NULL);\n+\n+  /* iii_ptr = NULL; */\n+  gcc_jit_block_add_assignment (\n+    block, NULL,\n+    iii_ptr,\n+    gcc_jit_context_null (ctxt, fn_ptr_type_iii));\n+  /* ifi_ptr = iii_ptr; */\n+  gcc_jit_block_add_assignment (\n+    block, NULL,\n+    ifi_ptr,\n+    gcc_jit_lvalue_as_rvalue (iii_ptr));\n+  gcc_jit_block_end_with_void_return (block, NULL);\n+}\n+\n+void\n+verify_code (gcc_jit_context *ctxt, gcc_jit_result *result)\n+{\n+  CHECK_VALUE (result, NULL);\n+\n+  /* Verify that the correct error message was emitted.  */\n+  CHECK_STRING_VALUE (gcc_jit_context_get_first_error (ctxt),\n+\t\t      \"gcc_jit_block_add_assignment:\"\n+\t\t      \" mismatching types:\"\n+\t\t      \" assignment to ifi_ptr\"\n+\t\t      \" (type: void (*) (int, float, int))\"\n+\t\t      \" from iii_ptr\"\n+\t\t      \" (type: void (*) (int, int, int))\");\n+}\n+"}, {"sha": "f96079c45f7a482827e413ab084d8c01acf5e331", "filename": "gcc/testsuite/jit.dg/test-returning-function-ptr.c", "status": "modified", "additions": 26, "deletions": 7, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a47aa2c8c36571a51552e46f3d971c107d5bf88/gcc%2Ftestsuite%2Fjit.dg%2Ftest-returning-function-ptr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a47aa2c8c36571a51552e46f3d971c107d5bf88/gcc%2Ftestsuite%2Fjit.dg%2Ftest-returning-function-ptr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-returning-function-ptr.c?ref=5a47aa2c8c36571a51552e46f3d971c107d5bf88", "patch": "@@ -28,10 +28,15 @@ create_code (gcc_jit_context *ctxt, void *user_data)\n         internally_called_function (a * 3, a * 4, a * 5);\n      }\n \n-     void (*) (int)\n+     typedef void (*fn_ptr_type) (int);\n+\n+     fn_ptr_type\n      get_test_caller (void)\n      {\n-       return internal_test_caller;\n+       // Verify that we can assign function pointers to variables\n+       fn_ptr_type p;\n+       p = internal_test_caller;\n+       return p;\n      }\n   */\n   int i;\n@@ -87,11 +92,11 @@ create_code (gcc_jit_context *ctxt, void *user_data)\n \t\t\t      3, args));\n   gcc_jit_block_end_with_void_return (block, NULL);\n \n-  gcc_jit_rvalue *fn_ptr\n-    = gcc_jit_function_get_address (test_caller, NULL);\n-\n   gcc_jit_type *fn_ptr_type\n-    = gcc_jit_rvalue_get_type (fn_ptr);\n+    = gcc_jit_context_new_function_ptr_type (ctxt, NULL,\n+\t\t\t\t\t     void_type,\n+\t\t\t\t\t     1, &int_type,\n+\t\t\t\t\t     0);\n \n   /* Build the get_test_caller fn.  */\n   gcc_jit_function *get_test_caller =\n@@ -102,7 +107,21 @@ create_code (gcc_jit_context *ctxt, void *user_data)\n \t\t\t\t  0, NULL,\n \t\t\t\t  0);\n   block = gcc_jit_function_new_block (get_test_caller, NULL);\n-  gcc_jit_block_end_with_return (block, NULL, fn_ptr);\n+\n+  /* fn_ptr_type p; */\n+  gcc_jit_lvalue *local_p\n+    = gcc_jit_function_new_local (get_test_caller, NULL,\n+\t\t\t\t  fn_ptr_type, \"p\");\n+\n+  /* p = internal_test_caller; */\n+  gcc_jit_block_add_assignment (block, NULL,\n+\t\t\t\tlocal_p,\n+\t\t\t\tgcc_jit_function_get_address (test_caller,\n+\t\t\t\t\t\t\t      NULL));\n+\n+  /* return p; */\n+  gcc_jit_block_end_with_return (block, NULL,\n+\t\t\t\t gcc_jit_lvalue_as_rvalue (local_p));\n }\n \n static int called_with[3];"}]}