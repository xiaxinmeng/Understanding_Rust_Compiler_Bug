{"sha": "bf6465d0461234ccd45ae34d5e2375a0bee0081d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmY2NDY1ZDA0NjEyMzRjY2Q0NWFlMzRkNWUyMzc1YTBiZWUwMDgxZA==", "commit": {"author": {"name": "H.J. Lu", "email": "hjl.tools@gmail.com", "date": "2020-02-10T15:58:45Z"}, "committer": {"name": "H.J. Lu", "email": "hjl.tools@gmail.com", "date": "2020-02-10T15:59:10Z"}, "message": "i386: Properly pop restore token in signal frame\n\nLinux CET kernel places a restore token on shadow stack for signal\nhandler to enhance security.  The restore token is 8 byte and aligned\nto 8 bytes.  It is usually transparent to user programs since kernel\nwill pop the restore token when signal handler returns.  But when an\nexception is thrown from a signal handler, now we need to pop the\nrestore token from shadow stack.  For x86-64, we just need to treat\nthe signal frame as normal frame.  For i386, we need to search for\nthe restore token to check if the original shadow stack is 8 byte\naligned.  If the original shadow stack is 8 byte aligned, we just\nneed to pop 2 slots, one restore token, from shadow stack.  Otherwise,\nwe need to pop 3 slots, one restore token + 4 byte padding, from\nshadow stack.\n\nThis patch also includes 2 tests, one has a restore token with 4 byte\npadding and one without.\n\nTested on Linux/x86-64 CET machine with and without -m32.\n\nlibgcc/\n\n\tPR libgcc/85334\n\t* config/i386/shadow-stack-unwind.h (_Unwind_Frames_Increment):\n\tNew.\n\ngcc/testsuite/\n\n\tPR libgcc/85334\n\t* g++.target/i386/pr85334-1.C: New test.\n\t* g++.target/i386/pr85334-2.C: Likewise.", "tree": {"sha": "71a56036daba549bcf0290f3780a4b27a1304c37", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/71a56036daba549bcf0290f3780a4b27a1304c37"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bf6465d0461234ccd45ae34d5e2375a0bee0081d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf6465d0461234ccd45ae34d5e2375a0bee0081d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bf6465d0461234ccd45ae34d5e2375a0bee0081d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf6465d0461234ccd45ae34d5e2375a0bee0081d/comments", "author": {"login": "hjl-tools", "id": 1072356, "node_id": "MDQ6VXNlcjEwNzIzNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hjl-tools", "html_url": "https://github.com/hjl-tools", "followers_url": "https://api.github.com/users/hjl-tools/followers", "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}", "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}", "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions", "organizations_url": "https://api.github.com/users/hjl-tools/orgs", "repos_url": "https://api.github.com/users/hjl-tools/repos", "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}", "received_events_url": "https://api.github.com/users/hjl-tools/received_events", "type": "User", "site_admin": false}, "committer": {"login": "hjl-tools", "id": 1072356, "node_id": "MDQ6VXNlcjEwNzIzNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hjl-tools", "html_url": "https://github.com/hjl-tools", "followers_url": "https://api.github.com/users/hjl-tools/followers", "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}", "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}", "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions", "organizations_url": "https://api.github.com/users/hjl-tools/orgs", "repos_url": "https://api.github.com/users/hjl-tools/repos", "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}", "received_events_url": "https://api.github.com/users/hjl-tools/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1cad5e89a9e1b4ffa47bc6e3551643b342f6cfe8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1cad5e89a9e1b4ffa47bc6e3551643b342f6cfe8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1cad5e89a9e1b4ffa47bc6e3551643b342f6cfe8"}], "stats": {"total": 158, "additions": 158, "deletions": 0}, "files": [{"sha": "e416516e5c3ffea09daaa563eb20455d2bbb1ad9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf6465d0461234ccd45ae34d5e2375a0bee0081d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf6465d0461234ccd45ae34d5e2375a0bee0081d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bf6465d0461234ccd45ae34d5e2375a0bee0081d", "patch": "@@ -1,3 +1,9 @@\n+2020-02-10  H.J. Lu  <hongjiu.lu@intel.com>\n+\n+\tPR libgcc/85334\n+\t* config/i386/shadow-stack-unwind.h (_Unwind_Frames_Increment):\n+\tNew.\n+\n 2020-02-10  Richard Earnshaw  <rearnsha@arm.com>\n \n \tPR target/91913"}, {"sha": "64835ffc351cc8acbd8d89efdcc97948a10fe133", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf6465d0461234ccd45ae34d5e2375a0bee0081d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf6465d0461234ccd45ae34d5e2375a0bee0081d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=bf6465d0461234ccd45ae34d5e2375a0bee0081d", "patch": "@@ -1,3 +1,9 @@\n+2020-02-10  H.J. Lu  <hongjiu.lu@intel.com>\n+\n+\tPR libgcc/85334\n+\t* g++.target/i386/pr85334-1.C: New test.\n+\t* g++.target/i386/pr85334-2.C: Likewise.\n+\n 2020-02-10  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR other/93641"}, {"sha": "3c5ccad1714fcf5821f5d782638b2496415b8ce7", "filename": "gcc/testsuite/g++.target/i386/pr85334-1.C", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf6465d0461234ccd45ae34d5e2375a0bee0081d/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fi386%2Fpr85334-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf6465d0461234ccd45ae34d5e2375a0bee0081d/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fi386%2Fpr85334-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fi386%2Fpr85334-1.C?ref=bf6465d0461234ccd45ae34d5e2375a0bee0081d", "patch": "@@ -0,0 +1,55 @@\n+// { dg-do run }\n+// { dg-require-effective-target cet }\n+// { dg-additional-options \"-fexceptions -fnon-call-exceptions -fcf-protection\" }\n+\n+// Delta between numbers of call stacks of pr85334-1.C and pr85334-2.C is 1.\n+\n+#include <signal.h>\n+#include <stdlib.h>\n+\n+void sighandler (int signo, siginfo_t * si, void * uc)\n+{\n+  throw (5);\n+}\n+\n+char *\n+__attribute ((noinline, noclone))\n+dosegv ()\n+{    \n+  * ((volatile int *)0) = 12;\n+  return 0;\n+}\n+\n+int\n+__attribute ((noinline, noclone))\n+func2 ()\n+{\n+  try {\n+    dosegv ();\n+  }\n+  catch (int x) {\n+    return (x != 5);\n+  }\n+  return 1;\n+}\n+\n+int\n+__attribute ((noinline, noclone))\n+func1 ()\n+{\n+  return func2 ();\n+}\n+\n+int main ()\n+{\n+  struct sigaction sa;\n+  int status;\n+\n+  sa.sa_sigaction = sighandler;\n+  sa.sa_flags = SA_SIGINFO;\n+    \n+  status = sigaction (SIGSEGV, & sa, NULL);\n+  status = sigaction (SIGBUS, & sa, NULL);\n+\n+  return func1 ();\n+}"}, {"sha": "e2b5afe78cb490f7c66041dd04a0875f19068be7", "filename": "gcc/testsuite/g++.target/i386/pr85334-2.C", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf6465d0461234ccd45ae34d5e2375a0bee0081d/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fi386%2Fpr85334-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf6465d0461234ccd45ae34d5e2375a0bee0081d/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fi386%2Fpr85334-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fi386%2Fpr85334-2.C?ref=bf6465d0461234ccd45ae34d5e2375a0bee0081d", "patch": "@@ -0,0 +1,48 @@\n+// { dg-do run }\n+// { dg-require-effective-target cet }\n+// { dg-additional-options \"-fexceptions -fnon-call-exceptions -fcf-protection\" }\n+\n+// Delta between numbers of call stacks of pr85334-1.C and pr85334-2.C is 1.\n+\n+#include <signal.h>\n+#include <stdlib.h>\n+\n+void sighandler (int signo, siginfo_t * si, void * uc)\n+{\n+  throw (5);\n+}\n+\n+char *\n+__attribute ((noinline, noclone))\n+dosegv ()\n+{    \n+  * ((volatile int *)0) = 12;\n+  return 0;\n+}\n+\n+int\n+__attribute ((noinline, noclone))\n+func1 ()\n+{\n+  try {\n+    dosegv ();\n+  }\n+  catch (int x) {\n+    return (x != 5);\n+  }\n+  return 1;\n+}\n+\n+int main ()\n+{\n+  struct sigaction sa;\n+  int status;\n+\n+  sa.sa_sigaction = sighandler;\n+  sa.sa_flags = SA_SIGINFO;\n+    \n+  status = sigaction (SIGSEGV, & sa, NULL);\n+  status = sigaction (SIGBUS, & sa, NULL);\n+\n+  return func1 ();\n+}"}, {"sha": "201b21531139882d4d33d8eb8d041ae80ccea658", "filename": "libgcc/config/i386/shadow-stack-unwind.h", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf6465d0461234ccd45ae34d5e2375a0bee0081d/libgcc%2Fconfig%2Fi386%2Fshadow-stack-unwind.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf6465d0461234ccd45ae34d5e2375a0bee0081d/libgcc%2Fconfig%2Fi386%2Fshadow-stack-unwind.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fi386%2Fshadow-stack-unwind.h?ref=bf6465d0461234ccd45ae34d5e2375a0bee0081d", "patch": "@@ -49,3 +49,46 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n \t}\t\t\t\t\t\\\n     }\t\t\t\t\t\t\\\n     while (0)\n+\n+/* Linux CET kernel places a restore token on shadow stack for signal\n+   handler to enhance security.  The restore token is 8 byte and aligned\n+   to 8 bytes.  It is usually transparent to user programs since kernel\n+   will pop the restore token when signal handler returns.  But when an\n+   exception is thrown from a signal handler, now we need to pop the\n+   restore token from shadow stack.  For x86-64, we just need to treat\n+   the signal frame as normal frame.  For i386, we need to search for\n+   the restore token to check if the original shadow stack is 8 byte\n+   aligned.  If the original shadow stack is 8 byte aligned, we just\n+   need to pop 2 slots, one restore token, from shadow stack.  Otherwise,\n+   we need to pop 3 slots, one restore token + 4 byte padding, from\n+   shadow stack.  */\n+#ifndef __x86_64__\n+#undef _Unwind_Frames_Increment\n+#define _Unwind_Frames_Increment(context, frames)\t\\\n+  if (_Unwind_IsSignalFrame (context))\t\t\t\\\n+    do\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\\\n+\t_Unwind_Word ssp, prev_ssp, token;\t\t\\\n+\tssp = _get_ssp ();\t\t\t\t\\\n+\tif (ssp != 0)\t\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\\\n+\t    /* Align shadow stack pointer to the next\t\\\n+\t       8 byte aligned boundary.  */\t\t\\\n+\t    ssp = (ssp + 4) & ~7;\t\t\t\\\n+\t    do\t\t\t\t\t\t\\\n+\t      {\t\t\t\t\t\t\\\n+\t\t/* Look for a restore token.  */\t\\\n+\t\ttoken = (*(_Unwind_Word *) (ssp - 8));\t\\\n+\t\tprev_ssp = token & ~7;\t\t\t\\\n+\t\tif (prev_ssp == ssp)\t\t\t\\\n+\t\t  break;\t\t\t\t\\\n+\t\tssp += 8;\t\t\t\t\\\n+\t      }\t\t\t\t\t\t\\\n+\t    while (1);\t\t\t\t\t\\\n+\t    frames += (token & 0x4) ? 3 : 2;\t\t\\\n+\t  }\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\\\n+    while (0);\t\t\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\\\n+    frames++;\n+#endif"}]}