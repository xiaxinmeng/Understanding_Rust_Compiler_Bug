{"sha": "2a22f99cb12d82712dd93cfef808b1cef543601b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmEyMmY5OWNiMTJkODI3MTJkZDkzY2ZlZjgwOGIxY2VmNTQzNjAxYg==", "commit": {"author": {"name": "Trevor Saunders", "email": "tsaunders@mozilla.com", "date": "2014-10-12T22:22:53Z"}, "committer": {"name": "Trevor Saunders", "email": "tbsaunde@gcc.gnu.org", "date": "2014-10-12T22:22:53Z"}, "message": "move many gc hashtab to hash_table\n\ngcc/\n\n* asan.c, cfgloop.c, cfgloop.h, cgraph.c, cgraph.h,\n\tconfig/darwin.c, config/m32c/m32c.c, config/mep/mep.c,\n\tconfig/mips/mips.c, config/rs6000/rs6000.c, dwarf2out.c,\n\tfunction.c, function.h, gimple-ssa.h, libfuncs.h, optabs.c,\n\toutput.h, rtl.h, sese.c, symtab.c, tree-cfg.c, tree-dfa.c,\n\ttree-ssa.c, varasm.c: Use hash-table instead of hashtab.\n\t* doc/gty.texi (for_user): Document new option.\n\t* gengtype.c (create_user_defined_type): Don't try to get a struct for\n\tchar.\n\t(walk_type): Don't error out on for_user option.\n\t(write_func_for_structure): Emit user marking routines if requested by\n\tfor_user option.\n\t(write_local_func_for_structure): Likewise.\n\t(main): Mark types with for_user option as used.\n\t* ggc.h (gt_pch_nx): Add overload for unsigned int.\n\t* hash-map.h (hash_map::hash_entry::pch_nx_helper): AddOverloads.\n\t* hash-table.h (ggc_hasher): New struct.\n\t(hash_table::create_ggc): New function.\n\t(gt_pch_nx): New overload for hash_table.\n\njava/\n\n\t* class.c, decl.c, except.c, expr.c, java-tree.h, lang.c: Use\n\thash_table instead of hashtab.\n\nobjc/\n\n\t* objc-act.c: use hash_table instead of hashtab.\n\ncp/\n\n\t* cp-gimplify.c, cp-tree.h, decl.c, mangle.c, name-lookup.c,\n\tpt.c, semantics.c, tree.c, typeck2.c: Use hash_table instead of\n\thashtab.\n\nfortran/\n\n\t* trans-decl.c, trans.c, trans.h: Use hash_table instead of hashtab.\n\nc-family/\n\n\t* c-common.c: Use hash_table instead of hashtab.\n\nFrom-SVN: r216127", "tree": {"sha": "c828063f153ceb609ce5c7d44ea9f00391b32950", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c828063f153ceb609ce5c7d44ea9f00391b32950"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2a22f99cb12d82712dd93cfef808b1cef543601b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a22f99cb12d82712dd93cfef808b1cef543601b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a22f99cb12d82712dd93cfef808b1cef543601b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a22f99cb12d82712dd93cfef808b1cef543601b/comments", "author": null, "committer": null, "parents": [{"sha": "7b262a51ea2310bdb6cc901de00f04b0e7be0a4e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b262a51ea2310bdb6cc901de00f04b0e7be0a4e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b262a51ea2310bdb6cc901de00f04b0e7be0a4e"}], "stats": {"total": 2590, "additions": 1355, "deletions": 1235}, "files": [{"sha": "387e175f3985410b275c63b524b653fd9c1e5b4e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2a22f99cb12d82712dd93cfef808b1cef543601b", "patch": "@@ -1,3 +1,25 @@\n+2014-10-12  Trevor Saunders  <tsaunders@mozilla.com>\n+\n+* asan.c, cfgloop.c, cfgloop.h, cgraph.c, cgraph.h,\n+\tconfig/darwin.c, config/m32c/m32c.c, config/mep/mep.c,\n+\tconfig/mips/mips.c, config/rs6000/rs6000.c, dwarf2out.c,\n+\tfunction.c, function.h, gimple-ssa.h, libfuncs.h, optabs.c,\n+\toutput.h, rtl.h, sese.c, symtab.c, tree-cfg.c, tree-dfa.c,\n+\ttree-ssa.c, varasm.c: Use hash-table instead of hashtab.\n+\t* doc/gty.texi (for_user): Document new option.\n+\t* gengtype.c (create_user_defined_type): Don't try to get a struct for\n+\tchar.\n+\t(walk_type): Don't error out on for_user option.\n+\t(write_func_for_structure): Emit user marking routines if requested by\n+\tfor_user option.\n+\t(write_local_func_for_structure): Likewise.\n+\t(main): Mark types with for_user option as used.\n+\t* ggc.h (gt_pch_nx): Add overload for unsigned int.\n+\t* hash-map.h (hash_map::hash_entry::pch_nx_helper): AddOverloads.\n+\t* hash-table.h (ggc_hasher): New struct.\n+\t(hash_table::create_ggc): New function.\n+\t(gt_pch_nx): New overload for hash_table.\n+\n 2014-10-11  Oleg Endo  <olegendo@gcc.gnu.org>\n \n \t* config/sh/sh.h (TARGET_SH4A_ARCH): Remove macro."}, {"sha": "ba933c0a5e847606492e6fecdf9c6f244ad05031", "filename": "gcc/asan.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Fasan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Fasan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fasan.c?ref=2a22f99cb12d82712dd93cfef808b1cef543601b", "patch": "@@ -2368,15 +2368,15 @@ initialize_sanitizer_builtins (void)\n /* Called via htab_traverse.  Count number of emitted\n    STRING_CSTs in the constant hash table.  */\n \n-static int\n-count_string_csts (void **slot, void *data)\n+int\n+count_string_csts (constant_descriptor_tree **slot,\n+\t\t   unsigned HOST_WIDE_INT *data)\n {\n-  struct constant_descriptor_tree *desc\n-    = (struct constant_descriptor_tree *) *slot;\n+  struct constant_descriptor_tree *desc = *slot;\n   if (TREE_CODE (desc->value) == STRING_CST\n       && TREE_ASM_WRITTEN (desc->value)\n       && asan_protect_global (desc->value))\n-    ++*((unsigned HOST_WIDE_INT *) data);\n+    ++*data;\n   return 1;\n }\n \n@@ -2389,20 +2389,18 @@ struct asan_add_string_csts_data\n   vec<constructor_elt, va_gc> *v;\n };\n \n-/* Called via htab_traverse.  Call asan_add_global\n+/* Called via hash_table::traverse.  Call asan_add_global\n    on emitted STRING_CSTs from the constant hash table.  */\n \n-static int\n-add_string_csts (void **slot, void *data)\n+int\n+add_string_csts (constant_descriptor_tree **slot,\n+\t\t asan_add_string_csts_data *aascd)\n {\n-  struct constant_descriptor_tree *desc\n-    = (struct constant_descriptor_tree *) *slot;\n+  struct constant_descriptor_tree *desc = *slot;\n   if (TREE_CODE (desc->value) == STRING_CST\n       && TREE_ASM_WRITTEN (desc->value)\n       && asan_protect_global (desc->value))\n     {\n-      struct asan_add_string_csts_data *aascd\n-\t= (struct asan_add_string_csts_data *) data;\n       asan_add_global (SYMBOL_REF_DECL (XEXP (desc->rtl, 0)),\n \t\t       aascd->type, aascd->v);\n     }\n@@ -2440,8 +2438,9 @@ asan_finish_file (void)\n     if (TREE_ASM_WRITTEN (vnode->decl)\n \t&& asan_protect_global (vnode->decl))\n       ++gcount;\n-  htab_t const_desc_htab = constant_pool_htab ();\n-  htab_traverse (const_desc_htab, count_string_csts, &gcount);\n+  hash_table<tree_descriptor_hasher> *const_desc_htab = constant_pool_htab ();\n+  const_desc_htab->traverse<unsigned HOST_WIDE_INT *, count_string_csts>\n+    (&gcount);\n   if (gcount)\n     {\n       tree type = asan_global_struct (), var, ctor;\n@@ -2465,7 +2464,8 @@ asan_finish_file (void)\n       struct asan_add_string_csts_data aascd;\n       aascd.type = TREE_TYPE (type);\n       aascd.v = v;\n-      htab_traverse (const_desc_htab, add_string_csts, &aascd);\n+      const_desc_htab->traverse<asan_add_string_csts_data *, add_string_csts>\n+       \t(&aascd);\n       ctor = build_constructor (type, v);\n       TREE_CONSTANT (ctor) = 1;\n       TREE_STATIC (ctor) = 1;"}, {"sha": "e579619245e6014ecb16db32e4a57d5df367f2a7", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=2a22f99cb12d82712dd93cfef808b1cef543601b", "patch": "@@ -1,3 +1,7 @@\n+2014-10-12  Trevor Saunders  <tsaunders@mozilla.com>\n+\n+\t* c-common.c: Use hash_table instead of hashtab.\n+\n 2014-10-06  Edward Smith-Rowland  <3dw4rd@verizon.net>\n \n \t* c-family/c-cppbuiltin.c: Move __cpp_attribute_deprecated to the"}, {"sha": "23163f51d6767a3431bb856d915bec6e0fcbd078", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=2a22f99cb12d82712dd93cfef808b1cef543601b", "patch": "@@ -4803,23 +4803,28 @@ c_apply_type_quals_to_decl (int type_quals, tree decl)\n     }\n }\n \n+struct c_type_hasher : ggc_hasher<tree>\n+{\n+  static hashval_t hash (tree);\n+  static bool equal (tree, tree);\n+};\n+\n /* Hash function for the problem of multiple type definitions in\n    different files.  This must hash all types that will compare\n    equal via comptypes to the same value.  In practice it hashes\n    on some of the simple stuff and leaves the details to comptypes.  */\n \n-static hashval_t\n-c_type_hash (const void *p)\n+hashval_t\n+c_type_hasher::hash (tree t)\n {\n   int n_elements;\n   int shift, size;\n-  const_tree const t = (const_tree) p;\n   tree t2;\n   switch (TREE_CODE (t))\n     {\n     /* For pointers, hash on pointee type plus some swizzling.  */\n     case POINTER_TYPE:\n-      return c_type_hash (TREE_TYPE (t)) ^ 0x3003003;\n+      return hash (TREE_TYPE (t)) ^ 0x3003003;\n     /* Hash on number of elements and total size.  */\n     case ENUMERAL_TYPE:\n       shift = 3;\n@@ -4851,7 +4856,13 @@ c_type_hash (const void *p)\n   return ((size << 24) | (n_elements << shift));\n }\n \n-static GTY((param_is (union tree_node))) htab_t type_hash_table;\n+bool\n+c_type_hasher::equal (tree t1, tree t2)\n+{\n+  return lang_hooks.types_compatible_p (t1, t2);\n+}\n+\n+static GTY(()) hash_table<c_type_hasher> *type_hash_table;\n \n /* Return the typed-based alias set for T, which may be an expression\n    or a type.  Return -1 if we don't do anything special.  */\n@@ -4860,7 +4871,6 @@ alias_set_type\n c_common_get_alias_set (tree t)\n {\n   tree u;\n-  PTR *slot;\n \n   /* For VLAs, use the alias set of the element type rather than the\n      default of alias set 0 for types compared structurally.  */\n@@ -4953,10 +4963,8 @@ c_common_get_alias_set (tree t)\n   /* Look up t in hash table.  Only one of the compatible types within each\n      alias set is recorded in the table.  */\n   if (!type_hash_table)\n-    type_hash_table = htab_create_ggc (1021, c_type_hash,\n-\t    (htab_eq) lang_hooks.types_compatible_p,\n-\t    NULL);\n-  slot = htab_find_slot (type_hash_table, t, INSERT);\n+    type_hash_table = hash_table<c_type_hasher>::create_ggc (1021);\n+  tree *slot = type_hash_table->find_slot (t, INSERT);\n   if (*slot != NULL)\n     {\n       TYPE_ALIAS_SET (t) = TYPE_ALIAS_SET ((tree)*slot);"}, {"sha": "0eaadde9a0ef5c1980668ff9f4d1d723743855eb", "filename": "gcc/cfgloop.c", "status": "modified", "additions": 22, "deletions": 30, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Fcfgloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Fcfgloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.c?ref=2a22f99cb12d82712dd93cfef808b1cef543601b", "patch": "@@ -958,31 +958,26 @@ get_loop_body_in_bfs_order (const struct loop *loop)\n \n /* Hash function for struct loop_exit.  */\n \n-static hashval_t\n-loop_exit_hash (const void *ex)\n+hashval_t\n+loop_exit_hasher::hash (loop_exit *exit)\n {\n-  const struct loop_exit *const exit = (const struct loop_exit *) ex;\n-\n   return htab_hash_pointer (exit->e);\n }\n \n /* Equality function for struct loop_exit.  Compares with edge.  */\n \n-static int\n-loop_exit_eq (const void *ex, const void *e)\n+bool\n+loop_exit_hasher::equal (loop_exit *exit, edge e)\n {\n-  const struct loop_exit *const exit = (const struct loop_exit *) ex;\n-\n   return exit->e == e;\n }\n \n /* Frees the list of loop exit descriptions EX.  */\n \n-static void\n-loop_exit_free (void *ex)\n+void\n+loop_exit_hasher::remove (loop_exit *exit)\n {\n-  struct loop_exit *exit = (struct loop_exit *) ex, *next;\n-\n+  loop_exit *next;\n   for (; exit; exit = next)\n     {\n       next = exit->next_e;\n@@ -999,8 +994,7 @@ loop_exit_free (void *ex)\n static struct loop_exit *\n get_exit_descriptions (edge e)\n {\n-  return (struct loop_exit *) htab_find_with_hash (current_loops->exits, e,\n-\t\t\t                           htab_hash_pointer (e));\n+  return current_loops->exits->find_with_hash (e, htab_hash_pointer (e));\n }\n \n /* Updates the lists of loop exits in that E appears.\n@@ -1012,7 +1006,6 @@ get_exit_descriptions (edge e)\n void\n rescan_loop_exit (edge e, bool new_edge, bool removed)\n {\n-  void **slot;\n   struct loop_exit *exits = NULL, *exit;\n   struct loop *aloop, *cloop;\n \n@@ -1045,20 +1038,20 @@ rescan_loop_exit (edge e, bool new_edge, bool removed)\n   if (!exits && new_edge)\n     return;\n \n-  slot = htab_find_slot_with_hash (current_loops->exits, e,\n-\t\t\t\t   htab_hash_pointer (e),\n-\t\t\t\t   exits ? INSERT : NO_INSERT);\n+  loop_exit **slot\n+    = current_loops->exits->find_slot_with_hash (e, htab_hash_pointer (e),\n+\t\t\t\t\t\t exits ? INSERT : NO_INSERT);\n   if (!slot)\n     return;\n \n   if (exits)\n     {\n       if (*slot)\n-\tloop_exit_free (*slot);\n+\tloop_exit_hasher::remove (*slot);\n       *slot = exits;\n     }\n   else\n-    htab_clear_slot (current_loops->exits, slot);\n+    current_loops->exits->clear_slot (slot);\n }\n \n /* For each loop, record list of exit edges, and start maintaining these\n@@ -1079,9 +1072,8 @@ record_loop_exits (void)\n   loops_state_set (LOOPS_HAVE_RECORDED_EXITS);\n \n   gcc_assert (current_loops->exits == NULL);\n-  current_loops->exits = htab_create_ggc (2 * number_of_loops (cfun),\n-\t\t\t\t\t  loop_exit_hash, loop_exit_eq,\n-\t\t\t\t\t  loop_exit_free);\n+  current_loops->exits\n+    = hash_table<loop_exit_hasher>::create_ggc (2 * number_of_loops (cfun));\n \n   FOR_EACH_BB_FN (bb, cfun)\n     {\n@@ -1095,17 +1087,17 @@ record_loop_exits (void)\n /* Dumps information about the exit in *SLOT to FILE.\n    Callback for htab_traverse.  */\n \n-static int\n-dump_recorded_exit (void **slot, void *file)\n+int\n+dump_recorded_exit (loop_exit **slot, FILE *file)\n {\n-  struct loop_exit *exit = (struct loop_exit *) *slot;\n+  struct loop_exit *exit = *slot;\n   unsigned n = 0;\n   edge e = exit->e;\n \n   for (; exit != NULL; exit = exit->next_e)\n     n++;\n \n-  fprintf ((FILE*) file, \"Edge %d->%d exits %u loops\\n\",\n+  fprintf (file, \"Edge %d->%d exits %u loops\\n\",\n \t   e->src->index, e->dest->index, n);\n \n   return 1;\n@@ -1119,7 +1111,7 @@ dump_recorded_exits (FILE *file)\n {\n   if (!current_loops->exits)\n     return;\n-  htab_traverse (current_loops->exits, dump_recorded_exit, file);\n+  current_loops->exits->traverse<FILE *, dump_recorded_exit> (file);\n }\n \n /* Releases lists of loop exits.  */\n@@ -1128,7 +1120,7 @@ void\n release_recorded_exits (void)\n {\n   gcc_assert (loops_state_satisfies_p (LOOPS_HAVE_RECORDED_EXITS));\n-  htab_delete (current_loops->exits);\n+  current_loops->exits->empty ();\n   current_loops->exits = NULL;\n   loops_state_clear (LOOPS_HAVE_RECORDED_EXITS);\n }\n@@ -1623,7 +1615,7 @@ verify_loop_structure (void)\n \t    }\n \t}\n \n-      if (n_exits != htab_elements (current_loops->exits))\n+      if (n_exits != current_loops->exits->elements ())\n \t{\n \t  error (\"too many loop exits recorded\");\n \t  err = 1;"}, {"sha": "432f8fe7b16b460008d63104a11f4278d0b4aaf0", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=2a22f99cb12d82712dd93cfef808b1cef543601b", "patch": "@@ -76,7 +76,7 @@ struct GTY ((chain_next (\"%h.next\"))) nb_iter_bound {\n \n /* Description of the loop exit.  */\n \n-struct GTY (()) loop_exit {\n+struct GTY ((for_user)) loop_exit {\n   /* The exit edge.  */\n   edge e;\n \n@@ -88,6 +88,15 @@ struct GTY (()) loop_exit {\n   struct loop_exit *next_e;\n };\n \n+struct loop_exit_hasher : ggc_hasher<loop_exit *>\n+{\n+  typedef edge compare_type;\n+\n+  static hashval_t hash (loop_exit *);\n+  static bool equal (loop_exit *, edge);\n+  static void remove (loop_exit *);\n+};\n+\n typedef struct loop *loop_p;\n \n /* An integer estimation of the number of iterations.  Estimate_state\n@@ -229,7 +238,7 @@ struct GTY (()) loops {\n   /* Maps edges to the list of their descriptions as loop exits.  Edges\n      whose sources or destinations have loop_father == NULL (which may\n      happen during the cfg manipulations) should not appear in EXITS.  */\n-  htab_t GTY((param_is (struct loop_exit))) exits;\n+  hash_table<loop_exit_hasher> *GTY(()) exits;\n \n   /* Pointer to root of loop hierarchy tree.  */\n   struct loop *tree_root;"}, {"sha": "02224f376ae2fabc02fd9f9ddf219d7bf6175a54", "filename": "gcc/cgraph.c", "status": "modified", "additions": 43, "deletions": 54, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=2a22f99cb12d82712dd93cfef808b1cef543601b", "patch": "@@ -103,30 +103,34 @@ struct cgraph_2node_hook_list {\n   struct cgraph_2node_hook_list *next;\n };\n \n+/* Hash descriptor for cgraph_function_version_info.  */\n+\n+struct function_version_hasher : ggc_hasher<cgraph_function_version_info *>\n+{\n+  static hashval_t hash (cgraph_function_version_info *);\n+  static bool equal (cgraph_function_version_info *,\n+\t\t     cgraph_function_version_info *);\n+};\n+\n /* Map a cgraph_node to cgraph_function_version_info using this htab.\n    The cgraph_function_version_info has a THIS_NODE field that is the\n    corresponding cgraph_node..  */\n \n-static GTY((param_is (cgraph_function_version_info))) htab_t\n-  cgraph_fnver_htab = NULL;\n+static GTY(()) hash_table<function_version_hasher> *cgraph_fnver_htab = NULL;\n \n /* Hash function for cgraph_fnver_htab.  */\n-static hashval_t\n-cgraph_fnver_htab_hash (const void *ptr)\n+hashval_t\n+function_version_hasher::hash (cgraph_function_version_info *ptr)\n {\n-  int uid = ((const cgraph_function_version_info *)ptr)->this_node->uid;\n+  int uid = ptr->this_node->uid;\n   return (hashval_t)(uid);\n }\n \n /* eq function for cgraph_fnver_htab.  */\n-static int\n-cgraph_fnver_htab_eq (const void *p1, const void *p2)\n+bool\n+function_version_hasher::equal (cgraph_function_version_info *n1,\n+\t\t\t       \tcgraph_function_version_info *n2)\n {\n-  const cgraph_function_version_info *n1\n-    = (const cgraph_function_version_info *)p1;\n-  const cgraph_function_version_info *n2\n-    = (const cgraph_function_version_info *)p2;\n-\n   return n1->this_node->uid == n2->this_node->uid;\n }\n \n@@ -138,37 +142,29 @@ static GTY(()) struct cgraph_function_version_info *\n cgraph_function_version_info *\n cgraph_node::function_version (void)\n {\n-  cgraph_function_version_info *ret;\n   cgraph_function_version_info key;\n   key.this_node = this;\n \n   if (cgraph_fnver_htab == NULL)\n     return NULL;\n \n-  ret = (cgraph_function_version_info *)\n-    htab_find (cgraph_fnver_htab, &key);\n-\n-  return ret;\n+  return cgraph_fnver_htab->find (&key);\n }\n \n /* Insert a new cgraph_function_version_info node into cgraph_fnver_htab\n    corresponding to cgraph_node NODE.  */\n cgraph_function_version_info *\n cgraph_node::insert_new_function_version (void)\n {\n-  void **slot;\n-  \n   version_info_node = NULL;\n   version_info_node = ggc_cleared_alloc<cgraph_function_version_info> ();\n   version_info_node->this_node = this;\n \n   if (cgraph_fnver_htab == NULL)\n-    cgraph_fnver_htab = htab_create_ggc (2, cgraph_fnver_htab_hash,\n-\t\t\t\t         cgraph_fnver_htab_eq, NULL);\n+    cgraph_fnver_htab = hash_table<function_version_hasher>::create_ggc (2);\n \n-  slot = htab_find_slot (cgraph_fnver_htab, version_info_node, INSERT);\n-  gcc_assert (slot != NULL);\n-  *slot = version_info_node;\n+  *cgraph_fnver_htab->find_slot (version_info_node, INSERT)\n+    = version_info_node;\n   return version_info_node;\n }\n \n@@ -195,7 +191,7 @@ cgraph_node::delete_function_version (tree decl)\n     decl_v->next->prev = decl_v->prev;\n \n   if (cgraph_fnver_htab != NULL)\n-    htab_remove_elt (cgraph_fnver_htab, decl_v);\n+    cgraph_fnver_htab->remove_elt (decl_v);\n \n   decl_node->remove ();\n }\n@@ -596,47 +592,43 @@ cgraph_node::get_for_asmname (tree asmname)\n \n /* Returns a hash value for X (which really is a cgraph_edge).  */\n \n-static hashval_t\n-edge_hash (const void *x)\n+hashval_t\n+cgraph_edge_hasher::hash (cgraph_edge *e)\n {\n-  return htab_hash_pointer (((const cgraph_edge *) x)->call_stmt);\n+  return htab_hash_pointer (e->call_stmt);\n }\n \n /* Return nonzero if the call_stmt of of cgraph_edge X is stmt *Y.  */\n \n-static int\n-edge_eq (const void *x, const void *y)\n+inline bool\n+cgraph_edge_hasher::equal (cgraph_edge *x, gimple y)\n {\n-  return ((const cgraph_edge *) x)->call_stmt == y;\n+  return x->call_stmt == y;\n }\n \n /* Add call graph edge E to call site hash of its caller.  */\n \n static inline void\n cgraph_update_edge_in_call_site_hash (cgraph_edge *e)\n {\n-  void **slot;\n-  slot = htab_find_slot_with_hash (e->caller->call_site_hash,\n-\t\t\t\t   e->call_stmt,\n-\t\t\t\t   htab_hash_pointer (e->call_stmt),\n-\t\t\t\t   INSERT);\n-  *slot = e;\n+  gimple call = e->call_stmt;\n+  *e->caller->call_site_hash->find_slot_with_hash (call,\n+\t\t\t\t\t\t   htab_hash_pointer (call),\n+\t\t\t\t\t\t   INSERT) = e;\n }\n \n /* Add call graph edge E to call site hash of its caller.  */\n \n static inline void\n cgraph_add_edge_to_call_site_hash (cgraph_edge *e)\n {\n-  void **slot;\n   /* There are two speculative edges for every statement (one direct,\n      one indirect); always hash the direct one.  */\n   if (e->speculative && e->indirect_unknown_callee)\n     return;\n-  slot = htab_find_slot_with_hash (e->caller->call_site_hash,\n-\t\t\t\t   e->call_stmt,\n-\t\t\t\t   htab_hash_pointer (e->call_stmt),\n-\t\t\t\t   INSERT);\n+  cgraph_edge **slot = e->caller->call_site_hash->find_slot_with_hash\n+\t\t\t\t   (e->call_stmt,\n+\t\t\t\t    htab_hash_pointer (e->call_stmt), INSERT);\n   if (*slot)\n     {\n       gcc_assert (((cgraph_edge *)*slot)->speculative);\n@@ -658,9 +650,8 @@ cgraph_node::get_edge (gimple call_stmt)\n   int n = 0;\n \n   if (call_site_hash)\n-    return (cgraph_edge *)\n-      htab_find_with_hash (call_site_hash, call_stmt,\n-      \t                   htab_hash_pointer (call_stmt));\n+    return call_site_hash->find_with_hash (call_stmt,\n+\t\t\t\t\t   htab_hash_pointer (call_stmt));\n \n   /* This loop may turn out to be performance problem.  In such case adding\n      hashtables into call nodes with very many edges is probably best\n@@ -684,7 +675,7 @@ cgraph_node::get_edge (gimple call_stmt)\n \n   if (n > 100)\n     {\n-      call_site_hash = htab_create_ggc (120, edge_hash, edge_eq, NULL);\n+      call_site_hash = hash_table<cgraph_edge_hasher>::create_ggc (120);\n       for (e2 = callees; e2; e2 = e2->next_callee)\n \tcgraph_add_edge_to_call_site_hash (e2);\n       for (e2 = indirect_calls; e2; e2 = e2->next_callee)\n@@ -722,9 +713,8 @@ cgraph_edge::set_call_stmt (gimple new_stmt, bool update_speculative)\n   if (caller->call_site_hash\n       && (!speculative || !indirect_unknown_callee))\n     {\n-      htab_remove_elt_with_hash (caller->call_site_hash,\n-\t\t\t\t call_stmt,\n-\t\t\t\t htab_hash_pointer (call_stmt));\n+      caller->call_site_hash->remove_elt_with_hash\n+\t(call_stmt, htab_hash_pointer (call_stmt));\n     }\n \n   cgraph_edge *e = this;\n@@ -942,9 +932,8 @@ cgraph_edge::remove_caller (void)\n \tcaller->callees = next_callee;\n     }\n   if (caller->call_site_hash)\n-    htab_remove_elt_with_hash (caller->call_site_hash,\n-\t\t\t       call_stmt,\n-\t\t\t       htab_hash_pointer (call_stmt));\n+    caller->call_site_hash->remove_elt_with_hash (call_stmt,\n+\t\t\t\t\t\t  htab_hash_pointer (call_stmt));\n }\n \n /* Put the edge onto the free list.  */\n@@ -1564,7 +1553,7 @@ cgraph_node::remove_callees (void)\n   callees = NULL;\n   if (call_site_hash)\n     {\n-      htab_delete (call_site_hash);\n+      call_site_hash->empty ();\n       call_site_hash = NULL;\n     }\n }\n@@ -1743,7 +1732,7 @@ cgraph_node::remove (void)\n   decl = NULL;\n   if (call_site_hash)\n     {\n-      htab_delete (call_site_hash);\n+      call_site_hash->empty ();\n       call_site_hash = NULL;\n     }\n "}, {"sha": "a5777c24bf2f0c3faa3dc55bafdaa243824e9101", "filename": "gcc/cgraph.h", "status": "modified", "additions": 81, "deletions": 13, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=2a22f99cb12d82712dd93cfef808b1cef543601b", "patch": "@@ -42,7 +42,7 @@ enum symtab_type\n /* Section names are stored as reference counted strings in GGC safe hashtable\n    (to make them survive through PCH).  */\n \n-struct GTY(()) section_hash_entry_d\n+struct GTY((for_user)) section_hash_entry_d\n {\n   int ref_count;\n   char *name;  /* As long as this datastructure stays in GGC, we can not put\n@@ -52,6 +52,14 @@ struct GTY(()) section_hash_entry_d\n \n typedef struct section_hash_entry_d section_hash_entry;\n \n+struct section_name_hasher : ggc_hasher<section_hash_entry *>\n+{\n+  typedef const char *compare_type;\n+\n+  static hashval_t hash (section_hash_entry *);\n+  static bool equal (section_hash_entry *, const char *);\n+};\n+\n enum availability\n {\n   /* Not yet set by cgraph_function_body_availability.  */\n@@ -704,7 +712,7 @@ struct GTY(()) cgraph_simd_clone {\n };\n \n /* Function Multiversioning info.  */\n-struct GTY(()) cgraph_function_version_info {\n+struct GTY((for_user)) cgraph_function_version_info {\n   /* The cgraph_node for which the function version info is stored.  */\n   cgraph_node *this_node;\n   /* Chains all the semantically identical function versions.  The\n@@ -743,6 +751,14 @@ enum cgraph_inline_failed_type_t\n \n struct cgraph_edge;\n \n+struct cgraph_edge_hasher : ggc_hasher<cgraph_edge *>\n+{\n+  typedef gimple compare_type;\n+\n+  static hashval_t hash (cgraph_edge *);\n+  static bool equal (cgraph_edge *, gimple);\n+};\n+\n /* The cgraph data structure.\n    Each function decl has assigned cgraph_node listing callees and callers.  */\n \n@@ -1175,7 +1191,7 @@ struct GTY((tag (\"SYMTAB_FUNCTION\"))) cgraph_node : public symtab_node {\n   cgraph_node *clone_of;\n   /* For functions with many calls sites it holds map from call expression\n      to the edge to speed up cgraph_edge function.  */\n-  htab_t GTY((param_is (cgraph_edge))) call_site_hash;\n+  hash_table<cgraph_edge_hasher> *GTY(()) call_site_hash;\n   /* Declaration node used to be clone of. */\n   tree former_clone_of;\n \n@@ -1401,7 +1417,8 @@ struct GTY(()) cgraph_indirect_call_info\n   unsigned vptr_changed : 1;\n };\n \n-struct GTY((chain_next (\"%h.next_caller\"), chain_prev (\"%h.prev_caller\"))) cgraph_edge {\n+struct GTY((chain_next (\"%h.next_caller\"), chain_prev (\"%h.prev_caller\"),\n+\t    for_user)) cgraph_edge {\n   friend class cgraph_node;\n \n   /* Remove the edge in the cgraph.  */\n@@ -1733,6 +1750,20 @@ enum symtab_state\n   FINISHED\n };\n \n+struct asmname_hasher\n+{\n+  typedef symtab_node *value_type;\n+  typedef const_tree compare_type;\n+  typedef int store_values_directly;\n+\n+  static hashval_t hash (symtab_node *n);\n+  static bool equal (symtab_node *n, const_tree t);\n+  static void ggc_mx (symtab_node *n);\n+  static void pch_nx (symtab_node *&);\n+  static void pch_nx (symtab_node *&, gt_pointer_operator, void *);\n+  static void remove (symtab_node *) {}\n+};\n+\n class GTY((tag (\"SYMTAB\"))) symbol_table\n {\n public:\n@@ -1969,10 +2000,10 @@ class GTY((tag (\"SYMTAB\"))) symbol_table\n   bool cpp_implicit_aliases_done;\n \n   /* Hash table used to hold sectoons.  */\n-  htab_t GTY((param_is (section_hash_entry))) section_hash;\n+  hash_table<section_name_hasher> *GTY(()) section_hash;\n \n   /* Hash table used to convert assembler names into nodes.  */\n-  htab_t GTY((param_is (symtab_node))) assembler_name_hash;\n+  hash_table<asmname_hasher> *assembler_name_hash;\n \n   /* Hash table used to hold init priorities.  */\n   hash_map<symtab_node *, symbol_priority_map> *init_priority_hash;\n@@ -2005,11 +2036,7 @@ class GTY((tag (\"SYMTAB\"))) symbol_table\n   /* Compare ASMNAME with the DECL_ASSEMBLER_NAME of DECL.  */\n   static bool decl_assembler_name_equal (tree decl, const_tree asmname);\n \n-  /* Returns a hash code for P.  */\n-  static hashval_t hash_node_by_assembler_name (const void *p);\n-\n-  /* Returns nonzero if P1 and P2 are equal.  */\n-  static int eq_assembler_name (const void *p1, const void *p2);\n+  friend struct asmname_hasher;\n \n   /* List of hooks triggered when an edge is removed.  */\n   cgraph_edge_hook_list * GTY((skip)) m_first_edge_removal_hook;\n@@ -2031,6 +2058,41 @@ extern GTY(()) symbol_table *symtab;\n \n extern vec<cgraph_node *> cgraph_new_nodes;\n \n+inline hashval_t\n+asmname_hasher::hash (symtab_node *n)\n+{\n+  return symbol_table::decl_assembler_name_hash\n+    (DECL_ASSEMBLER_NAME (n->decl));\n+}\n+\n+inline bool\n+asmname_hasher::equal (symtab_node *n, const_tree t)\n+{\n+  return symbol_table::decl_assembler_name_equal (n->decl, t);\n+}\n+\n+extern void gt_ggc_mx (symtab_node *&);\n+\n+inline void\n+asmname_hasher::ggc_mx (symtab_node *n)\n+{\n+  gt_ggc_mx (n);\n+}\n+\n+extern void gt_pch_nx (symtab_node *&);\n+\n+inline void\n+asmname_hasher::pch_nx (symtab_node *&n)\n+{\n+  gt_pch_nx (n);\n+}\n+\n+inline void\n+asmname_hasher::pch_nx (symtab_node *&n, gt_pointer_operator op, void *cookie)\n+{\n+  op (&n, cookie);\n+}\n+\n /* In cgraph.c  */\n void release_function_body (tree);\n cgraph_indirect_call_info *cgraph_allocate_init_indirect_info (void);\n@@ -2485,7 +2547,7 @@ tree add_new_static_var (tree type);\n    Each constant in memory thus far output is recorded\n    in `const_desc_table'.  */\n \n-struct GTY(()) constant_descriptor_tree {\n+struct GTY((for_user)) constant_descriptor_tree {\n   /* A MEM for the constant.  */\n   rtx rtl;\n \n@@ -2544,8 +2606,14 @@ varpool_node::all_refs_explicit_p ()\n \t  && !force_output);\n }\n \n+struct tree_descriptor_hasher : ggc_hasher<constant_descriptor_tree *>\n+{\n+  static hashval_t hash (constant_descriptor_tree *);\n+  static bool equal (constant_descriptor_tree *, constant_descriptor_tree *);\n+};\n+\n /* Constant pool accessor function.  */\n-htab_t constant_pool_htab (void);\n+hash_table<tree_descriptor_hasher> *constant_pool_htab (void);\n \n /* Return node that alias is aliasing.  */\n "}, {"sha": "34dc9aa1dd93ae833233c8377ce3f29171cbcf09", "filename": "gcc/config/darwin.c", "status": "modified", "additions": 46, "deletions": 49, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Fconfig%2Fdarwin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Fconfig%2Fdarwin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdarwin.c?ref=2a22f99cb12d82712dd93cfef808b1cef543601b", "patch": "@@ -450,7 +450,7 @@ machopic_should_output_picbase_label (void)\n /* The suffix attached to stub symbols.  */\n #define STUB_SUFFIX \"$stub\"\n \n-typedef struct GTY (()) machopic_indirection\n+typedef struct GTY ((for_user)) machopic_indirection\n {\n   /* The SYMBOL_REF for the entity referenced.  */\n   rtx symbol;\n@@ -463,29 +463,33 @@ typedef struct GTY (()) machopic_indirection\n   bool used;\n } machopic_indirection;\n \n+struct indirection_hasher : ggc_hasher<machopic_indirection *>\n+{\n+  typedef const char *compare_type;\n+  static hashval_t hash (machopic_indirection *);\n+  static bool equal (machopic_indirection *, const char *);\n+};\n+\n /* A table mapping stub names and non-lazy pointer names to\n    SYMBOL_REFs for the stubbed-to and pointed-to entities.  */\n \n-static GTY ((param_is (struct machopic_indirection))) htab_t\n-  machopic_indirections;\n+static GTY (()) hash_table<indirection_hasher> *machopic_indirections;\n \n /* Return a hash value for a SLOT in the indirections hash table.  */\n \n-static hashval_t\n-machopic_indirection_hash (const void *slot)\n+hashval_t\n+indirection_hasher::hash (machopic_indirection *p)\n {\n-  const machopic_indirection *p = (const machopic_indirection *) slot;\n   return htab_hash_string (p->ptr_name);\n }\n \n /* Returns true if the KEY is the same as that associated with\n    SLOT.  */\n \n-static int\n-machopic_indirection_eq (const void *slot, const void *key)\n+bool\n+indirection_hasher::equal (machopic_indirection *s, const char *k)\n {\n-  return strcmp (((const machopic_indirection *) slot)->ptr_name,\n-\t\t (const char *) key) == 0;\n+  return strcmp (s->ptr_name, k) == 0;\n }\n \n /* Return the name of the non-lazy pointer (if STUB_P is false) or\n@@ -498,7 +502,6 @@ machopic_indirection_name (rtx sym_ref, bool stub_p)\n   const char *name = XSTR (sym_ref, 0);\n   size_t namelen = strlen (name);\n   machopic_indirection *p;\n-  void ** slot;\n   bool needs_quotes;\n   const char *suffix;\n   const char *prefix = user_label_prefix;\n@@ -548,16 +551,15 @@ machopic_indirection_name (rtx sym_ref, bool stub_p)\n   sprintf (buffer, \"&%sL%s%s%s%s\", quote, prefix, name, suffix, quote);\n \n   if (!machopic_indirections)\n-    machopic_indirections = htab_create_ggc (37,\n-\t\t\t\t\t     machopic_indirection_hash,\n-\t\t\t\t\t     machopic_indirection_eq,\n-\t\t\t\t\t     /*htab_del=*/NULL);\n+    machopic_indirections = hash_table<indirection_hasher>::create_ggc (37);\n \n-  slot = htab_find_slot_with_hash (machopic_indirections, buffer,\n-\t\t\t\t   htab_hash_string (buffer), INSERT);\n+  machopic_indirection **slot\n+    = machopic_indirections->find_slot_with_hash (buffer,\n+\t\t\t\t\t\t  htab_hash_string (buffer),\n+\t\t\t\t\t\t  INSERT);\n   if (*slot)\n     {\n-      p = (machopic_indirection *) *slot;\n+      p = *slot;\n     }\n   else\n     {\n@@ -589,11 +591,8 @@ machopic_mcount_stub_name (void)\n void\n machopic_validate_stub_or_non_lazy_ptr (const char *name)\n {\n-  machopic_indirection *p;\n-\n-  p = ((machopic_indirection *)\n-       (htab_find_with_hash (machopic_indirections, name,\n-\t\t\t     htab_hash_string (name))));\n+  machopic_indirection *p\n+    = machopic_indirections->find_with_hash (name, htab_hash_string (name));\n   if (p && ! p->used)\n     {\n       const char *real_name;\n@@ -1062,11 +1061,10 @@ machopic_legitimize_pic_address (rtx orig, enum machine_mode mode, rtx reg)\n    DATA is the FILE* for assembly output.  Called from\n    htab_traverse.  */\n \n-static int\n-machopic_output_indirection (void **slot, void *data)\n+int\n+machopic_output_indirection (machopic_indirection **slot, FILE *asm_out_file)\n {\n-  machopic_indirection *p = *((machopic_indirection **) slot);\n-  FILE *asm_out_file = (FILE *) data;\n+  machopic_indirection *p = *slot;\n   rtx symbol;\n   const char *sym_name;\n   const char *ptr_name;\n@@ -1180,9 +1178,8 @@ void\n machopic_finish (FILE *asm_out_file)\n {\n   if (machopic_indirections)\n-    htab_traverse_noresize (machopic_indirections,\n-\t\t\t    machopic_output_indirection,\n-\t\t\t    asm_out_file);\n+    machopic_indirections\n+      ->traverse_noresize<FILE *, machopic_output_indirection> (asm_out_file);\n }\n \n int\n@@ -3254,17 +3251,20 @@ static enum built_in_function darwin_builtin_cfstring;\n /* Store all constructed constant CFStrings in a hash table so that\n    they get uniqued properly.  */\n \n-typedef struct GTY (()) cfstring_descriptor {\n+typedef struct GTY ((for_user)) cfstring_descriptor {\n   /* The string literal.  */\n   tree literal;\n   /* The resulting constant CFString.  */\n   tree constructor;\n } cfstring_descriptor;\n \n-static GTY ((param_is (struct cfstring_descriptor))) htab_t cfstring_htab;\n+struct cfstring_hasher : ggc_hasher<cfstring_descriptor *>\n+{\n+  static hashval_t hash (cfstring_descriptor *);\n+  static bool equal (cfstring_descriptor *, cfstring_descriptor *);\n+};\n \n-static hashval_t cfstring_hash (const void *);\n-static int cfstring_eq (const void *, const void *);\n+static GTY (()) hash_table<cfstring_hasher> *cfstring_htab;\n \n static tree\n add_builtin_field_decl (tree type, const char *name, tree **chain)\n@@ -3347,7 +3347,7 @@ darwin_init_cfstring_builtins (unsigned builtin_cfstring)\n   rest_of_decl_compilation (cfstring_class_reference, 0, 0);\n   \n   /* Initialize the hash table used to hold the constant CFString objects.  */\n-  cfstring_htab = htab_create_ggc (31, cfstring_hash, cfstring_eq, NULL);\n+  cfstring_htab = hash_table<cfstring_hasher>::create_ggc (31);\n \n   return cfstring_type_node;\n }\n@@ -3421,10 +3421,10 @@ darwin_libc_has_function (enum function_class fn_class)\n   return true;\n }\n \n-static hashval_t\n-cfstring_hash (const void *ptr)\n+hashval_t\n+cfstring_hasher::hash (cfstring_descriptor *ptr)\n {\n-  tree str = ((const struct cfstring_descriptor *)ptr)->literal;\n+  tree str = ptr->literal;\n   const unsigned char *p = (const unsigned char *) TREE_STRING_POINTER (str);\n   int i, len = TREE_STRING_LENGTH (str);\n   hashval_t h = len;\n@@ -3435,11 +3435,11 @@ cfstring_hash (const void *ptr)\n   return h;\n }\n \n-static int\n-cfstring_eq (const void *ptr1, const void *ptr2)\n+bool\n+cfstring_hasher::equal (cfstring_descriptor *ptr1, cfstring_descriptor *ptr2)\n {\n-  tree str1 = ((const struct cfstring_descriptor *)ptr1)->literal;\n-  tree str2 = ((const struct cfstring_descriptor *)ptr2)->literal;\n+  tree str1 = ptr1->literal;\n+  tree str2 = ptr2->literal;\n   int len1 = TREE_STRING_LENGTH (str1);\n \n   return (len1 == TREE_STRING_LENGTH (str2)\n@@ -3451,7 +3451,6 @@ tree\n darwin_build_constant_cfstring (tree str)\n {\n   struct cfstring_descriptor *desc, key;\n-  void **loc;\n   tree addr;\n \n   if (!str)\n@@ -3473,8 +3472,8 @@ darwin_build_constant_cfstring (tree str)\n \n   /* Perhaps we already constructed a constant CFString just like this one? */\n   key.literal = str;\n-  loc = htab_find_slot (cfstring_htab, &key, INSERT);\n-  desc = (struct cfstring_descriptor *) *loc;\n+  cfstring_descriptor **loc = cfstring_htab->find_slot (&key, INSERT);\n+  desc = *loc;\n \n   if (!desc)\n     {\n@@ -3550,7 +3549,6 @@ bool\n darwin_cfstring_p (tree str)\n {\n   struct cfstring_descriptor key;\n-  void **loc;\n \n   if (!str)\n     return false;\n@@ -3564,7 +3562,7 @@ darwin_cfstring_p (tree str)\n     return false;\n \n   key.literal = str;\n-  loc = htab_find_slot (cfstring_htab, &key, NO_INSERT);\n+  cfstring_descriptor **loc = cfstring_htab->find_slot (&key, NO_INSERT);\n   \n   if (loc)\n     return true;\n@@ -3576,10 +3574,9 @@ void\n darwin_enter_string_into_cfstring_table (tree str)\n {\n   struct cfstring_descriptor key;\n-  void **loc;\n \n   key.literal = str;\n-  loc = htab_find_slot (cfstring_htab, &key, INSERT);\n+  cfstring_descriptor **loc = cfstring_htab->find_slot (&key, INSERT);\n \n   if (!*loc)\n     {"}, {"sha": "fc89821f16853f271a7528fdaec280a03732023d", "filename": "gcc/config/m32c/m32c.c", "status": "modified", "additions": 17, "deletions": 42, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Fconfig%2Fm32c%2Fm32c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Fconfig%2Fm32c%2Fm32c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fm32c.c?ref=2a22f99cb12d82712dd93cfef808b1cef543601b", "patch": "@@ -3035,66 +3035,41 @@ m32c_insert_attributes (tree node ATTRIBUTE_UNUSED,\n }\n \n \n-struct GTY(()) pragma_entry {\n-  const char *varname;\n-  unsigned address;\n+struct pragma_traits : default_hashmap_traits\n+{\n+  static hashval_t hash (const char *str) { return htab_hash_string (str); }\n+  static bool\n+  equal_keys (const char *a, const char *b)\n+  {\n+    return !strcmp (a, b);\n+  }\n };\n-typedef struct pragma_entry pragma_entry;\n \n /* Hash table of pragma info.  */\n-static GTY((param_is (pragma_entry))) htab_t pragma_htab;\n-\n-static int\n-pragma_entry_eq (const void *p1, const void *p2)\n-{\n-  const pragma_entry *old = (const pragma_entry *) p1;\n-  const char *new_name = (const char *) p2;\n-\n-  return strcmp (old->varname, new_name) == 0;\n-}\n-\n-static hashval_t\n-pragma_entry_hash (const void *p)\n-{\n-  const pragma_entry *old = (const pragma_entry *) p;\n-  return htab_hash_string (old->varname);\n-}\n+static GTY(()) hash_map<const char *, unsigned, pragma_traits> *pragma_htab;\n \n void\n m32c_note_pragma_address (const char *varname, unsigned address)\n {\n-  pragma_entry **slot;\n-\n   if (!pragma_htab)\n-    pragma_htab = htab_create_ggc (31, pragma_entry_hash,\n-\t\t\t\t    pragma_entry_eq, NULL);\n+    pragma_htab\n+      = hash_map<const char *, unsigned, pragma_traits>::create_ggc (31);\n \n-  slot = (pragma_entry **)\n-    htab_find_slot_with_hash (pragma_htab, varname,\n-\t\t\t      htab_hash_string (varname), INSERT);\n-\n-  if (!*slot)\n-    {\n-      *slot = ggc_alloc<pragma_entry> ();\n-      (*slot)->varname = ggc_strdup (varname);\n-    }\n-  (*slot)->address = address;\n+  const char *name = ggc_strdup (varname);\n+  unsigned int *slot = &pragma_htab->get_or_insert (name);\n+  *slot = address;\n }\n \n static bool\n m32c_get_pragma_address (const char *varname, unsigned *address)\n {\n-  pragma_entry **slot;\n-\n   if (!pragma_htab)\n     return false;\n \n-  slot = (pragma_entry **)\n-    htab_find_slot_with_hash (pragma_htab, varname,\n-\t\t\t      htab_hash_string (varname), NO_INSERT);\n-  if (slot && *slot)\n+  unsigned int *slot = pragma_htab->get (varname);\n+  if (slot)\n     {\n-      *address = (*slot)->address;\n+      *address = *slot;\n       return true;\n     }\n   return false;"}, {"sha": "03ecc96ad046bb7a305e32ba62de9e055c6c31a9", "filename": "gcc/config/mep/mep.c", "status": "modified", "additions": 30, "deletions": 47, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Fconfig%2Fmep%2Fmep.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Fconfig%2Fmep%2Fmep.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmep%2Fmep.c?ref=2a22f99cb12d82712dd93cfef808b1cef543601b", "patch": "@@ -4061,69 +4061,53 @@ mep_can_inline_p (tree caller, tree callee)\n struct GTY(()) pragma_entry {\n   int used;\n   int flag;\n-  const char *funcname;\n };\n-typedef struct pragma_entry pragma_entry;\n \n-/* Hash table of farcall-tagged sections.  */\n-static GTY((param_is (pragma_entry))) htab_t pragma_htab;\n-\n-static int\n-pragma_entry_eq (const void *p1, const void *p2)\n+struct pragma_traits : default_hashmap_traits\n {\n-  const pragma_entry *old = (const pragma_entry *) p1;\n-  const char *new_name = (const char *) p2;\n-\n-  return strcmp (old->funcname, new_name) == 0;\n-}\n+  static hashval_t hash (const char *s) { return htab_hash_string (s); }\n+  static bool\n+  equal_keys (const char *a, const char *b)\n+  {\n+    return strcmp (a, b) == 0;\n+  }\n+};\n \n-static hashval_t\n-pragma_entry_hash (const void *p)\n-{\n-  const pragma_entry *old = (const pragma_entry *) p;\n-  return htab_hash_string (old->funcname);\n-}\n+/* Hash table of farcall-tagged sections.  */\n+static GTY(()) hash_map<const char *, pragma_entry, pragma_traits> *\n+  pragma_htab;\n \n static void\n mep_note_pragma_flag (const char *funcname, int flag)\n {\n-  pragma_entry **slot;\n-\n   if (!pragma_htab)\n-    pragma_htab = htab_create_ggc (31, pragma_entry_hash,\n-\t\t\t\t    pragma_entry_eq, NULL);\n-\n-  slot = (pragma_entry **)\n-    htab_find_slot_with_hash (pragma_htab, funcname,\n-\t\t\t      htab_hash_string (funcname), INSERT);\n+    pragma_htab\n+      = hash_map<const char *, pragma_entry, pragma_traits>::create_ggc (31);\n \n-  if (!*slot)\n+  bool existed;\n+  const char *name = ggc_strdup (funcname);\n+  pragma_entry *slot = &pragma_htab->get_or_insert (name, &existed);\n+  if (!existed)\n     {\n-      *slot = ggc_alloc<pragma_entry> ();\n-      (*slot)->flag = 0;\n-      (*slot)->used = 0;\n-      (*slot)->funcname = ggc_strdup (funcname);\n+      slot->flag = 0;\n+      slot->used = 0;\n     }\n-  (*slot)->flag |= flag;\n+  slot->flag |= flag;\n }\n \n static bool\n mep_lookup_pragma_flag (const char *funcname, int flag)\n {\n-  pragma_entry **slot;\n-\n   if (!pragma_htab)\n     return false;\n \n   if (funcname[0] == '@' && funcname[2] == '.')\n     funcname += 3;\n \n-  slot = (pragma_entry **)\n-    htab_find_slot_with_hash (pragma_htab, funcname,\n-\t\t\t      htab_hash_string (funcname), NO_INSERT);\n-  if (slot && *slot && ((*slot)->flag & flag))\n+  pragma_entry *slot = pragma_htab->get (funcname);\n+  if (slot && (slot->flag & flag))\n     {\n-      (*slot)->used |= flag;\n+      slot->used |= flag;\n       return true;\n     }\n   return false;\n@@ -4153,22 +4137,21 @@ mep_note_pragma_disinterrupt (const char *funcname)\n   mep_note_pragma_flag (funcname, FUNC_DISINTERRUPT);\n }\n \n-static int\n-note_unused_pragma_disinterrupt (void **slot, void *data ATTRIBUTE_UNUSED)\n+bool\n+note_unused_pragma_disinterrupt (const char *const &s, const pragma_entry &e,\n+\t\t\t\t void *)\n {\n-  const pragma_entry *d = (const pragma_entry *)(*slot);\n-\n-  if ((d->flag & FUNC_DISINTERRUPT)\n-      && !(d->used & FUNC_DISINTERRUPT))\n-    warning (0, \"\\\"#pragma disinterrupt %s\\\" not used\", d->funcname);\n+  if ((e.flag & FUNC_DISINTERRUPT)\n+      && !(e.used & FUNC_DISINTERRUPT))\n+    warning (0, \"\\\"#pragma disinterrupt %s\\\" not used\", s);\n   return 1;\n }\n \n void\n mep_file_cleanups (void)\n {\n   if (pragma_htab)\n-    htab_traverse (pragma_htab, note_unused_pragma_disinterrupt, NULL);\n+    pragma_htab->traverse<void *, note_unused_pragma_disinterrupt> (NULL);\n }\n \n /* These three functions provide a bridge between the pramgas that"}, {"sha": "af72da55423b7fc6370b8d87b1079448aba1ca22", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 40, "deletions": 66, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=2a22f99cb12d82712dd93cfef808b1cef543601b", "patch": "@@ -1202,28 +1202,20 @@ static int mips_register_move_cost (enum machine_mode, reg_class_t,\n \t\t\t\t    reg_class_t);\n static unsigned int mips_function_arg_boundary (enum machine_mode, const_tree);\n \f\n-/* This hash table keeps track of implicit \"mips16\" and \"nomips16\" attributes\n-   for -mflip_mips16.  It maps decl names onto a boolean mode setting.  */\n-struct GTY (())  mflip_mips16_entry {\n-  const char *name;\n-  bool mips16_p;\n-};\n-static GTY ((param_is (struct mflip_mips16_entry))) htab_t mflip_mips16_htab;\n-\n-/* Hash table callbacks for mflip_mips16_htab.  */\n-\n-static hashval_t\n-mflip_mips16_htab_hash (const void *entry)\n+struct mips16_flip_traits : default_hashmap_traits\n {\n-  return htab_hash_string (((const struct mflip_mips16_entry *) entry)->name);\n-}\n+  static hashval_t hash (const char *s) { return htab_hash_string (s); }\n+  static bool\n+  equal_keys (const char *a, const char *b)\n+  {\n+    return !strcmp (a, b);\n+  }\n+};\n \n-static int\n-mflip_mips16_htab_eq (const void *entry, const void *name)\n-{\n-  return strcmp (((const struct mflip_mips16_entry *) entry)->name,\n-\t\t (const char *) name) == 0;\n-}\n+/* This hash table keeps track of implicit \"mips16\" and \"nomips16\" attributes\n+   for -mflip_mips16.  It maps decl names onto a boolean mode setting.  */\n+static GTY (()) hash_map<const char *, bool, mips16_flip_traits> *\n+  mflip_mips16_htab;\n \n /* True if -mflip-mips16 should next add an attribute for the default MIPS16\n    mode, false if it should next add an attribute for the opposite mode.  */\n@@ -1236,33 +1228,27 @@ static GTY(()) bool mips16_flipper;\n static bool\n mflip_mips16_use_mips16_p (tree decl)\n {\n-  struct mflip_mips16_entry *entry;\n   const char *name;\n-  hashval_t hash;\n-  void **slot;\n   bool base_is_mips16 = (mips_base_compression_flags & MASK_MIPS16) != 0;\n \n   /* Use the opposite of the command-line setting for anonymous decls.  */\n   if (!DECL_NAME (decl))\n     return !base_is_mips16;\n \n   if (!mflip_mips16_htab)\n-    mflip_mips16_htab = htab_create_ggc (37, mflip_mips16_htab_hash,\n-\t\t\t\t\t mflip_mips16_htab_eq, NULL);\n+    mflip_mips16_htab\n+      = hash_map<const char *, bool, mips16_flip_traits>::create_ggc (37);\n \n   name = IDENTIFIER_POINTER (DECL_NAME (decl));\n-  hash = htab_hash_string (name);\n-  slot = htab_find_slot_with_hash (mflip_mips16_htab, name, hash, INSERT);\n-  entry = (struct mflip_mips16_entry *) *slot;\n-  if (!entry)\n+\n+  bool existed;\n+  bool *slot = &mflip_mips16_htab->get_or_insert (name, &existed);\n+  if (!existed)\n     {\n       mips16_flipper = !mips16_flipper;\n-      entry = ggc_alloc<mflip_mips16_entry> ();\n-      entry->name = name;\n-      entry->mips16_p = mips16_flipper ? !base_is_mips16 : base_is_mips16;\n-      *slot = entry;\n+      *slot = mips16_flipper ? !base_is_mips16 : base_is_mips16;\n     }\n-  return entry->mips16_p;\n+  return *slot;\n }\n \f\n /* Predicates to test for presence of \"near\" and \"far\"/\"long_call\"\n@@ -6391,34 +6377,29 @@ mips_load_call_address (enum mips_call_type type, rtx dest, rtx addr)\n     }\n }\n \f\n+struct local_alias_traits : default_hashmap_traits\n+{\n+  static hashval_t hash (rtx);\n+  static bool equal_keys (rtx, rtx);\n+};\n+\n /* Each locally-defined hard-float MIPS16 function has a local symbol\n    associated with it.  This hash table maps the function symbol (FUNC)\n    to the local symbol (LOCAL). */\n-struct GTY(()) mips16_local_alias {\n-  rtx func;\n-  rtx local;\n-};\n-static GTY ((param_is (struct mips16_local_alias))) htab_t mips16_local_aliases;\n+static GTY (()) hash_map<rtx, rtx, local_alias_traits> *mips16_local_aliases;\n \n /* Hash table callbacks for mips16_local_aliases.  */\n \n-static hashval_t\n-mips16_local_aliases_hash (const void *entry)\n+hashval_t\n+local_alias_traits::hash (rtx func)\n {\n-  const struct mips16_local_alias *alias;\n-\n-  alias = (const struct mips16_local_alias *) entry;\n-  return htab_hash_string (XSTR (alias->func, 0));\n+  return htab_hash_string (XSTR (func, 0));\n }\n \n-static int\n-mips16_local_aliases_eq (const void *entry1, const void *entry2)\n+bool\n+local_alias_traits::equal_keys (rtx func1, rtx func2)\n {\n-  const struct mips16_local_alias *alias1, *alias2;\n-\n-  alias1 = (const struct mips16_local_alias *) entry1;\n-  alias2 = (const struct mips16_local_alias *) entry2;\n-  return rtx_equal_p (alias1->func, alias2->func);\n+  return rtx_equal_p (func1, func2);\n }\n \n /* FUNC is the symbol for a locally-defined hard-float MIPS16 function.\n@@ -6427,21 +6408,17 @@ mips16_local_aliases_eq (const void *entry1, const void *entry2)\n static rtx\n mips16_local_alias (rtx func)\n {\n-  struct mips16_local_alias *alias, tmp_alias;\n-  void **slot;\n-\n   /* Create the hash table if this is the first call.  */\n   if (mips16_local_aliases == NULL)\n-    mips16_local_aliases = htab_create_ggc (37, mips16_local_aliases_hash,\n-\t\t\t\t\t    mips16_local_aliases_eq, NULL);\n+    mips16_local_aliases\n+      = hash_map<rtx, rtx, local_alias_traits>::create_ggc (37);\n \n   /* Look up the function symbol, creating a new entry if need be.  */\n-  tmp_alias.func = func;\n-  slot = htab_find_slot (mips16_local_aliases, &tmp_alias, INSERT);\n+  bool existed;\n+  rtx *slot = &mips16_local_aliases->get_or_insert (func, &existed);\n   gcc_assert (slot != NULL);\n \n-  alias = (struct mips16_local_alias *) *slot;\n-  if (alias == NULL)\n+  if (!existed)\n     {\n       const char *func_name, *local_name;\n       rtx local;\n@@ -6455,12 +6432,9 @@ mips16_local_alias (rtx func)\n       SYMBOL_REF_FLAGS (local) = SYMBOL_REF_FLAGS (func) | SYMBOL_FLAG_LOCAL;\n \n       /* Create a new structure to represent the mapping.  */\n-      alias = ggc_alloc<struct mips16_local_alias> ();\n-      alias->func = func;\n-      alias->local = local;\n-      *slot = alias;\n+      *slot = local;\n     }\n-  return alias->local;\n+  return *slot;\n }\n \f\n /* A chained list of functions for which mips16_build_call_stub has already"}, {"sha": "eb9f0c36d95c2299f2cbac893b571c14e9639c9d", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 35, "deletions": 37, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=2a22f99cb12d82712dd93cfef808b1cef543601b", "patch": "@@ -1174,7 +1174,7 @@ rtl_opt_pass *make_pass_analyze_swaps (gcc::context*);\n \n /* Hash table stuff for keeping track of TOC entries.  */\n \n-struct GTY(()) toc_hash_struct\n+struct GTY((for_user)) toc_hash_struct\n {\n   /* `key' will satisfy CONSTANT_P; in fact, it will satisfy\n      ASM_OUTPUT_SPECIAL_POOL_ENTRY_P.  */\n@@ -1183,18 +1183,30 @@ struct GTY(()) toc_hash_struct\n   int labelno;\n };\n \n-static GTY ((param_is (struct toc_hash_struct))) htab_t toc_hash_table;\n+struct toc_hasher : ggc_hasher<toc_hash_struct *>\n+{\n+  static hashval_t hash (toc_hash_struct *);\n+  static bool equal (toc_hash_struct *, toc_hash_struct *);\n+};\n+\n+static GTY (()) hash_table<toc_hasher> *toc_hash_table;\n \n /* Hash table to keep track of the argument types for builtin functions.  */\n \n-struct GTY(()) builtin_hash_struct\n+struct GTY((for_user)) builtin_hash_struct\n {\n   tree type;\n   enum machine_mode mode[4];\t/* return value + 3 arguments.  */\n   unsigned char uns_p[4];\t/* and whether the types are unsigned.  */\n };\n \n-static GTY ((param_is (struct builtin_hash_struct))) htab_t builtin_hash_table;\n+struct builtin_hasher : ggc_hasher<builtin_hash_struct *>\n+{\n+  static hashval_t hash (builtin_hash_struct *);\n+  static bool equal (builtin_hash_struct *, builtin_hash_struct *);\n+};\n+\n+static GTY (()) hash_table<builtin_hasher> *builtin_hash_table;\n \n \f\n /* Default register names.  */\n@@ -15113,13 +15125,11 @@ htm_init_builtins (void)\n \n /* Hash function for builtin functions with up to 3 arguments and a return\n    type.  */\n-static unsigned\n-builtin_hash_function (const void *hash_entry)\n+hashval_t\n+builtin_hasher::hash (builtin_hash_struct *bh)\n {\n   unsigned ret = 0;\n   int i;\n-  const struct builtin_hash_struct *bh =\n-    (const struct builtin_hash_struct *) hash_entry;\n \n   for (i = 0; i < 4; i++)\n     {\n@@ -15131,12 +15141,9 @@ builtin_hash_function (const void *hash_entry)\n }\n \n /* Compare builtin hash entries H1 and H2 for equivalence.  */\n-static int\n-builtin_hash_eq (const void *h1, const void *h2)\n+bool\n+builtin_hasher::equal (builtin_hash_struct *p1, builtin_hash_struct *p2)\n {\n-  const struct builtin_hash_struct *p1 = (const struct builtin_hash_struct *) h1;\n-  const struct builtin_hash_struct *p2 = (const struct builtin_hash_struct *) h2;\n-\n   return ((p1->mode[0] == p2->mode[0])\n \t  && (p1->mode[1] == p2->mode[1])\n \t  && (p1->mode[2] == p2->mode[2])\n@@ -15157,16 +15164,14 @@ builtin_function_type (enum machine_mode mode_ret, enum machine_mode mode_arg0,\n {\n   struct builtin_hash_struct h;\n   struct builtin_hash_struct *h2;\n-  void **found;\n   int num_args = 3;\n   int i;\n   tree ret_type = NULL_TREE;\n   tree arg_type[3] = { NULL_TREE, NULL_TREE, NULL_TREE };\n \n   /* Create builtin_hash_table.  */\n   if (builtin_hash_table == NULL)\n-    builtin_hash_table = htab_create_ggc (1500, builtin_hash_function,\n-\t\t\t\t\t  builtin_hash_eq, NULL);\n+    builtin_hash_table = hash_table<builtin_hasher>::create_ggc (1500);\n \n   h.type = NULL_TREE;\n   h.mode[0] = mode_ret;\n@@ -15322,18 +15327,18 @@ builtin_function_type (enum machine_mode mode_ret, enum machine_mode mode_arg0,\n \t\t     GET_MODE_NAME (m));\n     }\n \n-  found = htab_find_slot (builtin_hash_table, &h, INSERT);\n+  builtin_hash_struct **found = builtin_hash_table->find_slot (&h, INSERT);\n   if (*found == NULL)\n     {\n       h2 = ggc_alloc<builtin_hash_struct> ();\n       *h2 = h;\n-      *found = (void *)h2;\n+      *found = h2;\n \n       h2->type = build_function_type_list (ret_type, arg_type[0], arg_type[1],\n \t\t\t\t\t   arg_type[2], NULL_TREE);\n     }\n \n-  return ((struct builtin_hash_struct *)(*found))->type;\n+  return (*found)->type;\n }\n \n static void\n@@ -25561,24 +25566,21 @@ rs6000_hash_constant (rtx k)\n   return result;\n }\n \n-static unsigned\n-toc_hash_function (const void *hash_entry)\n+hashval_t\n+toc_hasher::hash (toc_hash_struct *thc)\n {\n-  const struct toc_hash_struct *thc =\n-    (const struct toc_hash_struct *) hash_entry;\n   return rs6000_hash_constant (thc->key) ^ thc->key_mode;\n }\n \n /* Compare H1 and H2 for equivalence.  */\n \n-static int\n-toc_hash_eq (const void *h1, const void *h2)\n+bool\n+toc_hasher::equal (toc_hash_struct *h1, toc_hash_struct *h2)\n {\n-  rtx r1 = ((const struct toc_hash_struct *) h1)->key;\n-  rtx r2 = ((const struct toc_hash_struct *) h2)->key;\n+  rtx r1 = h1->key;\n+  rtx r2 = h2->key;\n \n-  if (((const struct toc_hash_struct *) h1)->key_mode\n-      != ((const struct toc_hash_struct *) h2)->key_mode)\n+  if (h1->key_mode != h2->key_mode)\n     return 0;\n \n   return rtx_equal_p (r1, r2);\n@@ -25665,20 +25667,18 @@ output_toc (FILE *file, rtx x, int labelno, enum machine_mode mode)\n   if (TARGET_TOC && GET_CODE (x) != LABEL_REF)\n     {\n       struct toc_hash_struct *h;\n-      void * * found;\n \n       /* Create toc_hash_table.  This can't be done at TARGET_OPTION_OVERRIDE\n \t time because GGC is not initialized at that point.  */\n       if (toc_hash_table == NULL)\n-\ttoc_hash_table = htab_create_ggc (1021, toc_hash_function,\n-\t\t\t\t\t  toc_hash_eq, NULL);\n+\ttoc_hash_table = hash_table<toc_hasher>::create_ggc (1021);\n \n       h = ggc_alloc<toc_hash_struct> ();\n       h->key = x;\n       h->key_mode = mode;\n       h->labelno = labelno;\n \n-      found = htab_find_slot (toc_hash_table, h, INSERT);\n+      toc_hash_struct **found = toc_hash_table->find_slot (h, INSERT);\n       if (*found == NULL)\n \t*found = h;\n       else  /* This is indeed a duplicate.\n@@ -25688,8 +25688,7 @@ output_toc (FILE *file, rtx x, int labelno, enum machine_mode mode)\n \t  ASM_OUTPUT_INTERNAL_LABEL_PREFIX (file, \"LC\");\n \t  fprintf (file, \"%d,\", labelno);\n \t  ASM_OUTPUT_INTERNAL_LABEL_PREFIX (file, \"LC\");\n-\t  fprintf (file, \"%d\\n\", ((*(const struct toc_hash_struct **)\n-\t\t\t\t\t      found)->labelno));\n+\t  fprintf (file, \"%d\\n\", ((*found)->labelno));\n \n #ifdef HAVE_AS_TLS\n \t  if (TARGET_XCOFF && GET_CODE (x) == SYMBOL_REF\n@@ -25700,8 +25699,7 @@ output_toc (FILE *file, rtx x, int labelno, enum machine_mode mode)\n \t      ASM_OUTPUT_INTERNAL_LABEL_PREFIX (file, \"LCM\");\n \t      fprintf (file, \"%d,\", labelno);\n \t      ASM_OUTPUT_INTERNAL_LABEL_PREFIX (file, \"LCM\");\n-\t      fprintf (file, \"%d\\n\", ((*(const struct toc_hash_struct **)\n-\t\t\t       \t\t\t      found)->labelno));\n+\t      fprintf (file, \"%d\\n\", ((*found)->labelno));\n \t    }\n #endif\n \t  return;"}, {"sha": "18eef9a9960b5c3e57917e75e35a9213b82c5a39", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=2a22f99cb12d82712dd93cfef808b1cef543601b", "patch": "@@ -1,3 +1,9 @@\n+2014-10-12  Trevor Saunders  <tsaunders@mozilla.com>\n+\n+\t* cp-gimplify.c, cp-tree.h, decl.c, mangle.c, name-lookup.c,\n+\tpt.c, semantics.c, tree.c, typeck2.c: Use hash_table instead of\n+\thashtab.\n+\n 2014-10-10  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/62115"}, {"sha": "22703b7660ed9b35f0371f12fbe0cd4f20086a2d", "filename": "gcc/cp/cp-gimplify.c", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Fcp%2Fcp-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Fcp%2Fcp-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-gimplify.c?ref=2a22f99cb12d82712dd93cfef808b1cef543601b", "patch": "@@ -758,20 +758,18 @@ is_invisiref_parm (const_tree t)\n \n /* Return true if the uid in both int tree maps are equal.  */\n \n-int\n-cxx_int_tree_map_eq (const void *va, const void *vb)\n+bool\n+cxx_int_tree_map_hasher::equal (cxx_int_tree_map *a, cxx_int_tree_map *b)\n {\n-  const struct cxx_int_tree_map *a = (const struct cxx_int_tree_map *) va;\n-  const struct cxx_int_tree_map *b = (const struct cxx_int_tree_map *) vb;\n   return (a->uid == b->uid);\n }\n \n /* Hash a UID in a cxx_int_tree_map.  */\n \n unsigned int\n-cxx_int_tree_map_hash (const void *item)\n+cxx_int_tree_map_hasher::hash (cxx_int_tree_map *item)\n {\n-  return ((const struct cxx_int_tree_map *)item)->uid;\n+  return item->uid;\n }\n \n /* A stable comparison routine for use with splay trees and DECLs.  */\n@@ -911,9 +909,7 @@ cp_genericize_r (tree *stmt_p, int *walk_subtrees, void *data)\n     {\n       struct cxx_int_tree_map *h, in;\n       in.uid = DECL_UID (stmt);\n-      h = (struct cxx_int_tree_map *)\n-\t  htab_find_with_hash (cp_function_chain->extern_decl_map,\n-\t\t\t       &in, in.uid);\n+      h = cp_function_chain->extern_decl_map->find_with_hash (&in, in.uid);\n       if (h)\n \t{\n \t  *stmt_p = h->to;"}, {"sha": "dbbf26daa114db2a0ed0c542a8a692bd6491e863", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=2a22f99cb12d82712dd93cfef808b1cef543601b", "patch": "@@ -1133,13 +1133,24 @@ struct GTY(()) saved_scope {\n \n extern GTY(()) struct saved_scope *scope_chain;\n \n-struct GTY(()) cxx_int_tree_map {\n+struct GTY((for_user)) cxx_int_tree_map {\n   unsigned int uid;\n   tree to;\n };\n \n-extern unsigned int cxx_int_tree_map_hash (const void *);\n-extern int cxx_int_tree_map_eq (const void *, const void *);\n+struct cxx_int_tree_map_hasher : ggc_hasher<cxx_int_tree_map *>\n+{\n+  static hashval_t hash (cxx_int_tree_map *);\n+  static bool equal (cxx_int_tree_map *, cxx_int_tree_map *);\n+};\n+\n+struct named_label_entry;\n+\n+struct named_label_hasher : ggc_hasher<named_label_entry *>\n+{\n+  static hashval_t hash (named_label_entry *);\n+  static bool equal (named_label_entry *, named_label_entry *);\n+};\n \n /* Global state pertinent to the current function.  */\n \n@@ -1165,13 +1176,13 @@ struct GTY(()) language_function {\n   /* True if this function can throw an exception.  */\n   BOOL_BITFIELD can_throw : 1;\n \n-  htab_t GTY((param_is(struct named_label_entry))) x_named_labels;\n+  hash_table<named_label_hasher> *x_named_labels;\n   cp_binding_level *bindings;\n   vec<tree, va_gc> *x_local_names;\n   /* Tracking possibly infinite loops.  This is a vec<tree> only because\n      vec<bool> doesn't work with gtype.  */\n   vec<tree, va_gc> *infinite_loops;\n-  htab_t GTY((param_is (struct cxx_int_tree_map))) extern_decl_map;\n+  hash_table<cxx_int_tree_map_hasher> *extern_decl_map;\n };\n \n /* The current C++-specific per-function global variables.  */"}, {"sha": "88164cd8954610e747dc82c534f6df0a2865cdaa", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 57, "deletions": 67, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=2a22f99cb12d82712dd93cfef808b1cef543601b", "patch": "@@ -31,6 +31,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"coretypes.h\"\n #include \"tm.h\"\n #include \"tree.h\"\n+#include \"tree-hasher.h\"\n #include \"stringpool.h\"\n #include \"stor-layout.h\"\n #include \"varasm.h\"\n@@ -88,8 +89,6 @@ static int member_function_or_else (tree, tree, enum overload_flags);\n static void bad_specifiers (tree, enum bad_spec_place, int, int, int, int,\n \t\t\t    int);\n static void check_for_uninitialized_const_var (tree);\n-static hashval_t typename_hash (const void *);\n-static int typename_compare (const void *, const void *);\n static tree local_variable_p_walkfn (tree *, int *, void *);\n static tree record_builtin_java_type (const char *, int);\n static const char *tag_name (enum tag_types);\n@@ -210,7 +209,7 @@ struct GTY((chain_next (\"%h.next\"))) named_label_use_entry {\n    we can clear out their names' definitions at the end of the\n    function, and so we can check the validity of jumps to these labels.  */\n \n-struct GTY(()) named_label_entry {\n+struct GTY((for_user)) named_label_entry {\n   /* The decl itself.  */\n   tree label_decl;\n \n@@ -394,11 +393,10 @@ pop_label (tree label, tree old_value)\n    go out of scope.  BLOCK is the top-level block for the\n    function.  */\n \n-static int\n-pop_labels_1 (void **slot, void *data)\n+int\n+pop_labels_1 (named_label_entry **slot, tree block)\n {\n-  struct named_label_entry *ent = (struct named_label_entry *) *slot;\n-  tree block = (tree) data;\n+  struct named_label_entry *ent = *slot;\n \n   pop_label (ent->label_decl, NULL_TREE);\n \n@@ -407,7 +405,7 @@ pop_labels_1 (void **slot, void *data)\n   DECL_CHAIN (ent->label_decl) = BLOCK_VARS (block);\n   BLOCK_VARS (block) = ent->label_decl;\n \n-  htab_clear_slot (named_labels, slot);\n+  named_labels->clear_slot (slot);\n \n   return 1;\n }\n@@ -417,7 +415,7 @@ pop_labels (tree block)\n {\n   if (named_labels)\n     {\n-      htab_traverse (named_labels, pop_labels_1, block);\n+      named_labels->traverse<tree, pop_labels_1> (block);\n       named_labels = NULL;\n     }\n }\n@@ -428,13 +426,12 @@ static void\n pop_local_label (tree label, tree old_value)\n {\n   struct named_label_entry dummy;\n-  void **slot;\n \n   pop_label (label, old_value);\n \n   dummy.label_decl = label;\n-  slot = htab_find_slot (named_labels, &dummy, NO_INSERT);\n-  htab_clear_slot (named_labels, slot);\n+  named_label_entry **slot = named_labels->find_slot (&dummy, NO_INSERT);\n+  named_labels->clear_slot (slot);\n }\n \n /* The following two routines are used to interface to Objective-C++.\n@@ -474,11 +471,10 @@ objc_mark_locals_volatile (void *enclosing_blk)\n \n /* Update data for defined and undefined labels when leaving a scope.  */\n \n-static int\n-poplevel_named_label_1 (void **slot, void *data)\n+int\n+poplevel_named_label_1 (named_label_entry **slot, cp_binding_level *bl)\n {\n-  struct named_label_entry *ent = (struct named_label_entry *) *slot;\n-  cp_binding_level *bl = (cp_binding_level *) data;\n+  named_label_entry *ent = *slot;\n   cp_binding_level *obl = bl->level_chain;\n \n   if (ent->binding_level == bl)\n@@ -585,8 +581,8 @@ poplevel (int keep, int reverse, int functionbody)\n   /* Any uses of undefined labels, and any defined labels, now operate\n      under constraints of next binding contour.  */\n   if (cfun && !functionbody && named_labels)\n-    htab_traverse (named_labels, poplevel_named_label_1,\n-\t\t   current_binding_level);\n+    named_labels->traverse<cp_binding_level *, poplevel_named_label_1>\n+\t\t   (current_binding_level);\n \n   /* Get the decls in the order they were written.\n      Usually current_binding_level->names is in reverse order.\n@@ -2717,19 +2713,16 @@ redeclaration_error_message (tree newdecl, tree olddecl)\n \f\n /* Hash and equality functions for the named_label table.  */\n \n-static hashval_t\n-named_label_entry_hash (const void *data)\n+hashval_t\n+named_label_hasher::hash (named_label_entry *ent)\n {\n-  const struct named_label_entry *ent = (const struct named_label_entry *) data;\n   return DECL_UID (ent->label_decl);\n }\n \n-static int\n-named_label_entry_eq (const void *a, const void *b)\n+bool\n+named_label_hasher::equal (named_label_entry *a, named_label_entry *b)\n {\n-  const struct named_label_entry *ent_a = (const struct named_label_entry *) a;\n-  const struct named_label_entry *ent_b = (const struct named_label_entry *) b;\n-  return ent_a->label_decl == ent_b->label_decl;\n+  return a->label_decl == b->label_decl;\n }\n \n /* Create a new label, named ID.  */\n@@ -2738,7 +2731,6 @@ static tree\n make_label_decl (tree id, int local_p)\n {\n   struct named_label_entry *ent;\n-  void **slot;\n   tree decl;\n \n   decl = build_decl (input_location, LABEL_DECL, id, void_type_node);\n@@ -2756,16 +2748,15 @@ make_label_decl (tree id, int local_p)\n \n   /* Create the label htab for the function on demand.  */\n   if (!named_labels)\n-    named_labels = htab_create_ggc (13, named_label_entry_hash,\n-\t\t\t\t    named_label_entry_eq, NULL);\n+    named_labels = hash_table<named_label_hasher>::create_ggc (13);\n \n   /* Record this label on the list of labels used in this function.\n      We do this before calling make_label_decl so that we get the\n      IDENTIFIER_LABEL_VALUE before the new label is declared.  */\n   ent = ggc_cleared_alloc<named_label_entry> ();\n   ent->label_decl = decl;\n \n-  slot = htab_find_slot (named_labels, ent, INSERT);\n+  named_label_entry **slot = named_labels->find_slot (ent, INSERT);\n   gcc_assert (*slot == NULL);\n   *slot = ent;\n \n@@ -2979,7 +2970,7 @@ check_goto (tree decl)\n     return;\n \n   dummy.label_decl = decl;\n-  ent = (struct named_label_entry *) htab_find (named_labels, &dummy);\n+  ent = named_labels->find (&dummy);\n   gcc_assert (ent != NULL);\n \n   /* If the label hasn't been defined yet, defer checking.  */\n@@ -3089,7 +3080,7 @@ define_label_1 (location_t location, tree name)\n   decl = lookup_label (name);\n \n   dummy.label_decl = decl;\n-  ent = (struct named_label_entry *) htab_find (named_labels, &dummy);\n+  ent = named_labels->find (&dummy);\n   gcc_assert (ent != NULL);\n \n   /* After labels, make any new cleanups in the function go into their\n@@ -3264,50 +3255,50 @@ finish_case_label (location_t loc, tree low_value, tree high_value)\n   return r;\n }\n \f\n-/* Hash a TYPENAME_TYPE.  K is really of type `tree'.  */\n-\n-static hashval_t\n-typename_hash (const void* k)\n-{\n-  hashval_t hash;\n-  const_tree const t = (const_tree) k;\n-\n-  hash = (htab_hash_pointer (TYPE_CONTEXT (t))\n-\t  ^ htab_hash_pointer (TYPE_IDENTIFIER (t)));\n-\n-  return hash;\n-}\n-\n-typedef struct typename_info {\n+struct typename_info {\n   tree scope;\n   tree name;\n   tree template_id;\n   bool enum_p;\n   bool class_p;\n-} typename_info;\n-\n-/* Compare two TYPENAME_TYPEs.  K1 is really of type `tree', K2 is\n-   really of type `typename_info*'  */\n+};\n \n-static int\n-typename_compare (const void * k1, const void * k2)\n+struct typename_hasher : ggc_hasher<tree>\n {\n-  const_tree const t1 = (const_tree) k1;\n-  const typename_info *const t2 = (const typename_info *) k2;\n+  typedef typename_info *compare_type;\n \n-  return (TYPE_IDENTIFIER (t1) == t2->name\n-\t  && TYPE_CONTEXT (t1) == t2->scope\n-\t  && TYPENAME_TYPE_FULLNAME (t1) == t2->template_id\n-\t  && TYPENAME_IS_ENUM_P (t1) == t2->enum_p\n-\t  && TYPENAME_IS_CLASS_P (t1) == t2->class_p);\n-}\n+  /* Hash a TYPENAME_TYPE.  */\n+\n+  static hashval_t\n+  hash (tree t)\n+  {\n+    hashval_t hash;\n+\n+    hash = (htab_hash_pointer (TYPE_CONTEXT (t))\n+\t    ^ htab_hash_pointer (TYPE_IDENTIFIER (t)));\n+\n+    return hash;\n+  }\n+\n+  /* Compare two TYPENAME_TYPEs.  */\n+\n+  static bool\n+  equal (tree t1, const typename_info *t2)\n+  {\n+    return (TYPE_IDENTIFIER (t1) == t2->name\n+\t    && TYPE_CONTEXT (t1) == t2->scope\n+\t    && TYPENAME_TYPE_FULLNAME (t1) == t2->template_id\n+\t    && TYPENAME_IS_ENUM_P (t1) == t2->enum_p\n+\t    && TYPENAME_IS_CLASS_P (t1) == t2->class_p);\n+  }\n+};\n \n /* Build a TYPENAME_TYPE.  If the type is `typename T::t', CONTEXT is\n    the type of `T', NAME is the IDENTIFIER_NODE for `t'.\n \n    Returns the new TYPENAME_TYPE.  */\n \n-static GTY ((param_is (union tree_node))) htab_t typename_htab;\n+static GTY (()) hash_table<typename_hasher> *typename_htab;\n \n static tree\n build_typename_type (tree context, tree name, tree fullname,\n@@ -3316,12 +3307,11 @@ build_typename_type (tree context, tree name, tree fullname,\n   tree t;\n   tree d;\n   typename_info ti;\n-  void **e;\n+  tree *e;\n   hashval_t hash;\n \n   if (typename_htab == NULL)\n-    typename_htab = htab_create_ggc (61, &typename_hash,\n-\t\t\t\t     &typename_compare, NULL);\n+    typename_htab = hash_table<typename_hasher>::create_ggc (61);\n \n   ti.scope = FROB_CONTEXT (context);\n   ti.name = name;\n@@ -3334,9 +3324,9 @@ build_typename_type (tree context, tree name, tree fullname,\n \t   ^ htab_hash_pointer (ti.name));\n \n   /* See if we already have this type.  */\n-  e = htab_find_slot_with_hash (typename_htab, &ti, hash, INSERT);\n+  e = typename_htab->find_slot_with_hash (&ti, hash, INSERT);\n   if (*e)\n-    t = (tree) *e;\n+    t = *e;\n   else\n     {\n       /* Build the TYPENAME_TYPE.  */"}, {"sha": "6b8f7066aa01e63dea20a8d65512e07b1f9fee9d", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 21, "deletions": 14, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=2a22f99cb12d82712dd93cfef808b1cef543601b", "patch": "@@ -49,6 +49,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"coretypes.h\"\n #include \"tm.h\"\n #include \"tree.h\"\n+#include \"tree-hasher.h\"\n #include \"stor-layout.h\"\n #include \"stringpool.h\"\n #include \"tm_p.h\"\n@@ -3690,26 +3691,32 @@ mangle_thunk (tree fn_decl, const int this_adjusting, tree fixed_offset,\n   return result;\n }\n \n+struct conv_type_hasher : ggc_hasher<tree>\n+{\n+  static hashval_t hash (tree);\n+  static bool equal (tree, tree);\n+};\n+\n /* This hash table maps TYPEs to the IDENTIFIER for a conversion\n    operator to TYPE.  The nodes are IDENTIFIERs whose TREE_TYPE is the\n    TYPE.  */\n \n-static GTY ((param_is (union tree_node))) htab_t conv_type_names;\n+static GTY (()) hash_table<conv_type_hasher> *conv_type_names;\n \n /* Hash a node (VAL1) in the table.  */\n \n-static hashval_t\n-hash_type (const void *val)\n+hashval_t\n+conv_type_hasher::hash (tree val)\n {\n-  return (hashval_t) TYPE_UID (TREE_TYPE ((const_tree) val));\n+  return (hashval_t) TYPE_UID (TREE_TYPE (val));\n }\n \n /* Compare VAL1 (a node in the table) with VAL2 (a TYPE).  */\n \n-static int\n-compare_type (const void *val1, const void *val2)\n+bool\n+conv_type_hasher::equal (tree val1, tree val2)\n {\n-  return TREE_TYPE ((const_tree) val1) == (const_tree) val2;\n+  return TREE_TYPE (val1) == val2;\n }\n \n /* Return an identifier for the mangled unqualified name for a\n@@ -3719,25 +3726,25 @@ compare_type (const void *val1, const void *val2)\n tree\n mangle_conv_op_name_for_type (const tree type)\n {\n-  void **slot;\n+  tree *slot;\n   tree identifier;\n \n   if (type == error_mark_node)\n     return error_mark_node;\n \n   if (conv_type_names == NULL)\n-    conv_type_names = htab_create_ggc (31, &hash_type, &compare_type, NULL);\n+    conv_type_names = hash_table<conv_type_hasher>::create_ggc (31);\n \n-  slot = htab_find_slot_with_hash (conv_type_names, type,\n-\t\t\t\t   (hashval_t) TYPE_UID (type), INSERT);\n-  identifier = (tree)*slot;\n+  slot = conv_type_names->find_slot_with_hash (type,\n+\t\t\t\t\t       (hashval_t) TYPE_UID (type),\n+\t\t\t\t\t       INSERT);\n+  identifier = *slot;\n   if (!identifier)\n     {\n       char buffer[64];\n \n        /* Create a unique name corresponding to TYPE.  */\n-      sprintf (buffer, \"operator %lu\",\n-\t       (unsigned long) htab_elements (conv_type_names));\n+      sprintf (buffer, \"operator %lu\", conv_type_names->elements ());\n       identifier = get_identifier (buffer);\n       *slot = identifier;\n "}, {"sha": "d42bcac92197b3669e255126eac690132ea0e80d", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=2a22f99cb12d82712dd93cfef808b1cef543601b", "patch": "@@ -766,22 +766,19 @@ pushdecl_maybe_friend_1 (tree x, bool is_friend)\n \t\t   middle end.  */\n \t\t{\n \t\t  struct cxx_int_tree_map *h;\n-\t\t  void **loc;\n \n \t\t  TREE_PUBLIC (x) = TREE_PUBLIC (t);\n \n \t\t  if (cp_function_chain->extern_decl_map == NULL)\n \t\t    cp_function_chain->extern_decl_map\n-\t\t      = htab_create_ggc (20, cxx_int_tree_map_hash,\n-\t\t\t\t\t cxx_int_tree_map_eq, NULL);\n+\t\t      = hash_table<cxx_int_tree_map_hasher>::create_ggc (20);\n \n \t\t  h = ggc_alloc<cxx_int_tree_map> ();\n \t\t  h->uid = DECL_UID (x);\n \t\t  h->to = t;\n-\t\t  loc = htab_find_slot_with_hash\n-\t\t\t  (cp_function_chain->extern_decl_map, h,\n-\t\t\t   h->uid, INSERT);\n-\t\t  *(struct cxx_int_tree_map **) loc = h;\n+\t\t  cxx_int_tree_map **loc = cp_function_chain->extern_decl_map\n+\t\t    ->find_slot (h, INSERT);\n+\t\t  *loc = h;\n \t\t}\n \t    }\n \t  else if (TREE_CODE (t) == PARM_DECL)"}, {"sha": "47b5d93b261d9cd9ab641a829d8c33836b203352", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 37, "deletions": 45, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=2a22f99cb12d82712dd93cfef808b1cef543601b", "patch": "@@ -80,18 +80,22 @@ static tree cur_stmt_expr;\n /* True if we've recursed into fn_type_unification too many times.  */\n static bool excessive_deduction_depth;\n \n-typedef struct GTY(()) spec_entry\n+struct GTY((for_user)) spec_entry\n {\n   tree tmpl;\n   tree args;\n   tree spec;\n-} spec_entry;\n+};\n+\n+struct spec_hasher : ggc_hasher<spec_entry *>\n+{\n+  static hashval_t hash (spec_entry *);\n+  static bool equal (spec_entry *, spec_entry *);\n+};\n \n-static GTY ((param_is (spec_entry)))\n-  htab_t decl_specializations;\n+static GTY (()) hash_table<spec_hasher> *decl_specializations;\n \n-static GTY ((param_is (spec_entry)))\n-  htab_t type_specializations;\n+static GTY (()) hash_table<spec_hasher> *type_specializations;\n \n /* Contains canonical template parameter types. The vector is indexed by\n    the TEMPLATE_TYPE_IDX of the template parameter. Each element is a\n@@ -153,7 +157,6 @@ static bool inline_needs_template_parms (tree, bool);\n static void push_inline_template_parms_recursive (tree, int);\n static tree retrieve_local_specialization (tree);\n static void register_local_specialization (tree, tree);\n-static hashval_t hash_specialization (const void *p);\n static tree reduce_template_parm_level (tree, tree, int, tree, tsubst_flags_t);\n static int mark_template_parm (tree, void *);\n static int template_parm_this_level_p (tree, void *);\n@@ -931,18 +934,18 @@ maybe_process_partial_specialization (tree type)\n \t\t     new member specialization template.  */\n \t\t  spec_entry elt;\n \t\t  spec_entry *entry;\n-\t\t  void **slot;\n \n \t\t  elt.tmpl = most_general_template (tmpl);\n \t\t  elt.args = CLASSTYPE_TI_ARGS (inst);\n \t\t  elt.spec = inst;\n \n-\t\t  htab_remove_elt (type_specializations, &elt);\n+\t\t  type_specializations->remove_elt (&elt);\n \n \t\t  elt.tmpl = tmpl;\n \t\t  elt.args = INNERMOST_TEMPLATE_ARGS (elt.args);\n \n-\t\t  slot = htab_find_slot (type_specializations, &elt, INSERT);\n+\t\t  spec_entry **slot\n+\t\t    = type_specializations->find_slot (&elt, INSERT);\n \t\t  entry = ggc_alloc<spec_entry> ();\n \t\t  *entry = elt;\n \t\t  *slot = entry;\n@@ -1085,7 +1088,7 @@ retrieve_specialization (tree tmpl, tree args, hashval_t hash)\n     {\n       spec_entry *found;\n       spec_entry elt;\n-      htab_t specializations;\n+      hash_table<spec_hasher> *specializations;\n \n       elt.tmpl = tmpl;\n       elt.args = args;\n@@ -1097,8 +1100,8 @@ retrieve_specialization (tree tmpl, tree args, hashval_t hash)\n \tspecializations = decl_specializations;\n \n       if (hash == 0)\n-\thash = hash_specialization (&elt);\n-      found = (spec_entry *) htab_find_with_hash (specializations, &elt, hash);\n+\thash = spec_hasher::hash (&elt);\n+      found = specializations->find_with_hash (&elt, hash);\n       if (found)\n \treturn found->spec;\n     }\n@@ -1343,7 +1346,7 @@ register_specialization (tree spec, tree tmpl, tree args, bool is_friend,\n \t\t\t hashval_t hash)\n {\n   tree fn;\n-  void **slot = NULL;\n+  spec_entry **slot = NULL;\n   spec_entry elt;\n \n   gcc_assert ((TREE_CODE (tmpl) == TEMPLATE_DECL && DECL_P (spec))\n@@ -1376,10 +1379,10 @@ register_specialization (tree spec, tree tmpl, tree args, bool is_friend,\n       elt.spec = spec;\n \n       if (hash == 0)\n-\thash = hash_specialization (&elt);\n+\thash = spec_hasher::hash (&elt);\n \n       slot =\n-\thtab_find_slot_with_hash (decl_specializations, &elt, hash, INSERT);\n+\tdecl_specializations->find_slot_with_hash (&elt, hash, INSERT);\n       if (*slot)\n \tfn = ((spec_entry *) *slot)->spec;\n       else\n@@ -1500,11 +1503,9 @@ register_specialization (tree spec, tree tmpl, tree args, bool is_friend,\n \n int comparing_specializations;\n \n-static int\n-eq_specializations (const void *p1, const void *p2)\n+bool\n+spec_hasher::equal (spec_entry *e1, spec_entry *e2)\n {\n-  const spec_entry *e1 = (const spec_entry *)p1;\n-  const spec_entry *e2 = (const spec_entry *)p2;\n   int equal;\n \n   ++comparing_specializations;\n@@ -1527,10 +1528,9 @@ hash_tmpl_and_args (tree tmpl, tree args)\n /* Returns a hash for a spec_entry node based on the TMPL and ARGS members,\n    ignoring SPEC.  */\n \n-static hashval_t\n-hash_specialization (const void *p)\n+hashval_t\n+spec_hasher::hash (spec_entry *e)\n {\n-  const spec_entry *e = (const spec_entry *)p;\n   return hash_tmpl_and_args (e->tmpl, e->args);\n }\n \n@@ -1710,7 +1710,7 @@ reregister_specialization (tree spec, tree tinfo, tree new_spec)\n   elt.args = TI_ARGS (tinfo);\n   elt.spec = NULL_TREE;\n \n-  entry = (spec_entry *) htab_find (decl_specializations, &elt);\n+  entry = decl_specializations->find (&elt);\n   if (entry != NULL)\n     {\n       gcc_assert (entry->spec == spec || entry->spec == new_spec);\n@@ -7418,7 +7418,7 @@ lookup_template_class_1 (tree d1, tree arglist, tree in_decl, tree context,\n {\n   tree templ = NULL_TREE, parmlist;\n   tree t;\n-  void **slot;\n+  spec_entry **slot;\n   spec_entry *entry;\n   spec_entry elt;\n   hashval_t hash;\n@@ -7684,9 +7684,8 @@ lookup_template_class_1 (tree d1, tree arglist, tree in_decl, tree context,\n       /* If we already have this specialization, return it.  */\n       elt.tmpl = gen_tmpl;\n       elt.args = arglist;\n-      hash = hash_specialization (&elt);\n-      entry = (spec_entry *) htab_find_with_hash (type_specializations,\n-\t\t\t\t\t\t  &elt, hash);\n+      hash = spec_hasher::hash (&elt);\n+      entry = type_specializations->find_with_hash (&elt, hash);\n \n       if (entry)\n \treturn entry->spec;\n@@ -7930,8 +7929,7 @@ lookup_template_class_1 (tree d1, tree arglist, tree in_decl, tree context,\n       SET_TYPE_TEMPLATE_INFO (t, build_template_info (found, arglist));\n \n       elt.spec = t;\n-      slot = htab_find_slot_with_hash (type_specializations,\n-\t\t\t\t       &elt, hash, INSERT);\n+      slot = type_specializations->find_slot_with_hash (&elt, hash, INSERT);\n       entry = ggc_alloc<spec_entry> ();\n       *entry = elt;\n       *slot = entry;\n@@ -8652,7 +8650,7 @@ tsubst_friend_function (tree decl, tree args)\n \t\t      elt.args = DECL_TI_ARGS (spec);\n \t\t      elt.spec = NULL_TREE;\n \n-\t\t      htab_remove_elt (decl_specializations, &elt);\n+\t\t      decl_specializations->remove_elt (&elt);\n \n \t\t      DECL_TI_ARGS (spec)\n \t\t\t= add_outermost_template_args (new_args,\n@@ -22316,14 +22314,8 @@ convert_generic_types_to_packs (tree parm, int start_idx, int end_idx)\n void\n init_template_processing (void)\n {\n-  decl_specializations = htab_create_ggc (37,\n-\t\t\t\t\t  hash_specialization,\n-\t\t\t\t\t  eq_specializations,\n-\t\t\t\t\t  ggc_free);\n-  type_specializations = htab_create_ggc (37,\n-\t\t\t\t\t  hash_specialization,\n-\t\t\t\t\t  eq_specializations,\n-\t\t\t\t\t  ggc_free);\n+  decl_specializations = hash_table<spec_hasher>::create_ggc (37);\n+  type_specializations = hash_table<spec_hasher>::create_ggc (37);\n }\n \n /* Print stats about the template hash tables for -fstats.  */\n@@ -22332,13 +22324,13 @@ void\n print_template_statistics (void)\n {\n   fprintf (stderr, \"decl_specializations: size %ld, %ld elements, \"\n-\t   \"%f collisions\\n\", (long) htab_size (decl_specializations),\n-\t   (long) htab_elements (decl_specializations),\n-\t   htab_collisions (decl_specializations));\n+\t   \"%f collisions\\n\", decl_specializations->size (),\n+\t   decl_specializations->elements (),\n+\t   decl_specializations->collisions ());\n   fprintf (stderr, \"type_specializations: size %ld, %ld elements, \"\n-\t   \"%f collisions\\n\", (long) htab_size (type_specializations),\n-\t   (long) htab_elements (type_specializations),\n-\t   htab_collisions (type_specializations));\n+\t   \"%f collisions\\n\", type_specializations->size (),\n+\t   type_specializations->elements (),\n+\t   type_specializations->collisions ());\n }\n \n #include \"gt-cp-pt.h\""}, {"sha": "85d5383979ae18843f1cf8e67ffe96efeb42d56d", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 37, "deletions": 37, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=2a22f99cb12d82712dd93cfef808b1cef543601b", "patch": "@@ -7579,35 +7579,38 @@ ensure_literal_type_for_constexpr_object (tree decl)\n \n /* Representation of entries in the constexpr function definition table.  */\n \n-typedef struct GTY(()) constexpr_fundef {\n+struct GTY((for_user)) constexpr_fundef {\n   tree decl;\n   tree body;\n-} constexpr_fundef;\n+};\n+\n+struct constexpr_fundef_hasher : ggc_hasher<constexpr_fundef *>\n+{\n+  static hashval_t hash (constexpr_fundef *);\n+  static bool equal (constexpr_fundef *, constexpr_fundef *);\n+};\n \n /* This table holds all constexpr function definitions seen in\n    the current translation unit.  */\n \n-static GTY ((param_is (constexpr_fundef))) htab_t constexpr_fundef_table;\n+static GTY (()) hash_table<constexpr_fundef_hasher> *constexpr_fundef_table;\n \n /* Utility function used for managing the constexpr function table.\n    Return true if the entries pointed to by P and Q are for the\n    same constexpr function.  */\n \n-static inline int\n-constexpr_fundef_equal (const void *p, const void *q)\n+inline bool\n+constexpr_fundef_hasher::equal (constexpr_fundef *lhs, constexpr_fundef *rhs)\n {\n-  const constexpr_fundef *lhs = (const constexpr_fundef *) p;\n-  const constexpr_fundef *rhs = (const constexpr_fundef *) q;\n   return lhs->decl == rhs->decl;\n }\n \n /* Utility function used for managing the constexpr function table.\n    Return a hash value for the entry pointed to by Q.  */\n \n-static inline hashval_t\n-constexpr_fundef_hash (const void *p)\n+inline hashval_t\n+constexpr_fundef_hasher::hash (constexpr_fundef *fundef)\n {\n-  const constexpr_fundef *fundef = (const constexpr_fundef *) p;\n   return DECL_UID (fundef->decl);\n }\n \n@@ -7621,7 +7624,7 @@ retrieve_constexpr_fundef (tree fun)\n     return NULL;\n \n   fundef.decl = fun;\n-  return (constexpr_fundef *) htab_find (constexpr_fundef_table, &fundef);\n+  return constexpr_fundef_table->find (&fundef);\n }\n \n /* Check whether the parameter and return types of FUN are valid for a\n@@ -8236,14 +8239,12 @@ register_constexpr_fundef (tree fun, tree body)\n \n   /* Create the constexpr function table if necessary.  */\n   if (constexpr_fundef_table == NULL)\n-    constexpr_fundef_table = htab_create_ggc (101,\n-                                              constexpr_fundef_hash,\n-                                              constexpr_fundef_equal,\n-                                              ggc_free);\n+    constexpr_fundef_table\n+      = hash_table<constexpr_fundef_hasher>::create_ggc (101);\n+\n   entry.decl = fun;\n   entry.body = body;\n-  slot = (constexpr_fundef **)\n-    htab_find_slot (constexpr_fundef_table, &entry, INSERT);\n+  slot = constexpr_fundef_table->find_slot (&entry, INSERT);\n \n   gcc_assert (*slot == NULL);\n   *slot = ggc_alloc<constexpr_fundef> ();\n@@ -8296,7 +8297,7 @@ explain_invalid_constexpr_fn (tree fun)\n    along with the bindings of parameters to their arguments, for\n    the purpose of compile time evaluation.  */\n \n-typedef struct GTY(()) constexpr_call {\n+struct GTY((for_user)) constexpr_call {\n   /* Description of the constexpr function definition.  */\n   constexpr_fundef *fundef;\n   /* Parameter bindings environment.  A TREE_LIST where each TREE_PURPOSE\n@@ -8314,39 +8315,42 @@ typedef struct GTY(()) constexpr_call {\n   /* The hash of this call; we remember it here to avoid having to\n      recalculate it when expanding the hash table.  */\n   hashval_t hash;\n-} constexpr_call;\n+};\n+\n+struct constexpr_call_hasher : ggc_hasher<constexpr_call *>\n+{\n+  static hashval_t hash (constexpr_call *);\n+  static bool equal (constexpr_call *, constexpr_call *);\n+\t\t     };\n \n /* A table of all constexpr calls that have been evaluated by the\n    compiler in this translation unit.  */\n \n-static GTY ((param_is (constexpr_call))) htab_t constexpr_call_table;\n+static GTY (()) hash_table<constexpr_call_hasher> *constexpr_call_table;\n \n static tree cxx_eval_constant_expression (const constexpr_call *, tree,\n \t\t\t\t\t  bool, bool, bool *, bool *);\n \n /* Compute a hash value for a constexpr call representation.  */\n \n-static hashval_t\n-constexpr_call_hash (const void *p)\n+inline hashval_t\n+constexpr_call_hasher::hash (constexpr_call *info)\n {\n-  const constexpr_call *info = (const constexpr_call *) p;\n   return info->hash;\n }\n \n-/* Return 1 if the objects pointed to by P and Q represent calls\n+/* Return true if the objects pointed to by P and Q represent calls\n    to the same constexpr function with the same arguments.\n-   Otherwise, return 0.  */\n+   Otherwise, return false.  */\n \n-static int\n-constexpr_call_equal (const void *p, const void *q)\n+bool\n+constexpr_call_hasher::equal (constexpr_call *lhs, constexpr_call *rhs)\n {\n-  const constexpr_call *lhs = (const constexpr_call *) p;\n-  const constexpr_call *rhs = (const constexpr_call *) q;\n   tree lhs_bindings;\n   tree rhs_bindings;\n   if (lhs == rhs)\n     return 1;\n-  if (!constexpr_fundef_equal (lhs->fundef, rhs->fundef))\n+  if (!constexpr_fundef_hasher::equal (lhs->fundef, rhs->fundef))\n     return 0;\n   lhs_bindings = lhs->bindings;\n   rhs_bindings = rhs->bindings;\n@@ -8369,10 +8373,7 @@ static void\n maybe_initialize_constexpr_call_table (void)\n {\n   if (constexpr_call_table == NULL)\n-    constexpr_call_table = htab_create_ggc (101,\n-                                            constexpr_call_hash,\n-                                            constexpr_call_equal,\n-                                            ggc_free);\n+    constexpr_call_table = hash_table<constexpr_call_hasher>::create_ggc (101);\n }\n \n /* Return true if T designates the implied `this' parameter.  */\n@@ -8681,12 +8682,11 @@ cxx_eval_call_expression (const constexpr_call *old_call, tree t,\n \n   new_call.hash\n     = iterative_hash_template_arg (new_call.bindings,\n-\t\t\t\t   constexpr_fundef_hash (new_call.fundef));\n+\t\t\t\t   constexpr_fundef_hasher::hash (new_call.fundef));\n \n   /* If we have seen this call before, we are done.  */\n   maybe_initialize_constexpr_call_table ();\n-  slot = (constexpr_call **)\n-    htab_find_slot (constexpr_call_table, &new_call, INSERT);\n+  slot = constexpr_call_table->find_slot (&new_call, INSERT);\n   entry = *slot;\n   if (entry == NULL)\n     {"}, {"sha": "9008cdb4da9cf27122dec435787b82650072774a", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 45, "deletions": 40, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=2a22f99cb12d82712dd93cfef808b1cef543601b", "patch": "@@ -23,6 +23,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"coretypes.h\"\n #include \"tm.h\"\n #include \"tree.h\"\n+#include \"tree-hasher.h\"\n #include \"stor-layout.h\"\n #include \"print-tree.h\"\n #include \"tree-iterator.h\"\n@@ -40,9 +41,7 @@ along with GCC; see the file COPYING3.  If not see\n \n static tree bot_manip (tree *, int *, void *);\n static tree bot_replace (tree *, int *, void *);\n-static int list_hash_eq (const void *, const void *);\n static hashval_t list_hash_pieces (tree, tree, tree);\n-static hashval_t list_hash (const void *);\n static tree build_target_expr (tree, tree, tsubst_flags_t);\n static tree count_trees_r (tree *, int *, void *);\n static tree verify_stmt_tree_r (tree *, int *, void *);\n@@ -722,40 +721,45 @@ rvalue (tree expr)\n }\n \n \f\n+struct cplus_array_info\n+{\n+  tree type;\n+  tree domain;\n+};\n+\n+struct cplus_array_hasher : ggc_hasher<tree>\n+{\n+  typedef cplus_array_info *compare_type;\n+\n+  static hashval_t hash (tree t);\n+  static bool equal (tree, cplus_array_info *);\n+};\n+\n /* Hash an ARRAY_TYPE.  K is really of type `tree'.  */\n \n-static hashval_t\n-cplus_array_hash (const void* k)\n+hashval_t\n+cplus_array_hasher::hash (tree t)\n {\n   hashval_t hash;\n-  const_tree const t = (const_tree) k;\n \n   hash = TYPE_UID (TREE_TYPE (t));\n   if (TYPE_DOMAIN (t))\n     hash ^= TYPE_UID (TYPE_DOMAIN (t));\n   return hash;\n }\n \n-typedef struct cplus_array_info {\n-  tree type;\n-  tree domain;\n-} cplus_array_info;\n-\n /* Compare two ARRAY_TYPEs.  K1 is really of type `tree', K2 is really\n    of type `cplus_array_info*'. */\n \n-static int\n-cplus_array_compare (const void * k1, const void * k2)\n+bool\n+cplus_array_hasher::equal (tree t1, cplus_array_info *t2)\n {\n-  const_tree const t1 = (const_tree) k1;\n-  const cplus_array_info *const t2 = (const cplus_array_info*) k2;\n-\n   return (TREE_TYPE (t1) == t2->type && TYPE_DOMAIN (t1) == t2->domain);\n }\n \n /* Hash table containing dependent array types, which are unsuitable for\n    the language-independent type hash table.  */\n-static GTY ((param_is (union tree_node))) htab_t cplus_array_htab;\n+static GTY (()) hash_table<cplus_array_hasher> *cplus_array_htab;\n \n /* Build an ARRAY_TYPE without laying it out.  */\n \n@@ -813,21 +817,19 @@ build_cplus_array_type (tree elt_type, tree index_type)\n     {\n       /* Since type_hash_canon calls layout_type, we need to use our own\n \t hash table.  */\n-      void **e;\n       cplus_array_info cai;\n       hashval_t hash;\n \n       if (cplus_array_htab == NULL)\n-\tcplus_array_htab = htab_create_ggc (61, &cplus_array_hash,\n-\t\t\t\t\t    &cplus_array_compare, NULL);\n+\tcplus_array_htab = hash_table<cplus_array_hasher>::create_ggc (61);\n       \n       hash = TYPE_UID (elt_type);\n       if (index_type)\n \thash ^= TYPE_UID (index_type);\n       cai.type = elt_type;\n       cai.domain = index_type;\n \n-      e = htab_find_slot_with_hash (cplus_array_htab, &cai, hash, INSERT); \n+      tree *e = cplus_array_htab->find_slot_with_hash (&cai, hash, INSERT); \n       if (*e)\n \t/* We have found the type: we're done.  */\n \treturn (tree) *e;\n@@ -1641,30 +1643,35 @@ copy_binfo (tree binfo, tree type, tree t, tree *igo_prev, int virt)\n /* Hashing of lists so that we don't make duplicates.\n    The entry point is `list_hash_canon'.  */\n \n-/* Now here is the hash table.  When recording a list, it is added\n-   to the slot whose index is the hash code mod the table size.\n-   Note that the hash table is used for several kinds of lists.\n-   While all these live in the same table, they are completely independent,\n-   and the hash code is computed differently for each of these.  */\n-\n-static GTY ((param_is (union tree_node))) htab_t list_hash_table;\n-\n struct list_proxy\n {\n   tree purpose;\n   tree value;\n   tree chain;\n };\n \n+struct list_hasher : ggc_hasher<tree>\n+{\n+  typedef list_proxy *compare_type;\n+\n+  static hashval_t hash (tree);\n+  static bool equal (tree, list_proxy *);\n+};\n+\n+/* Now here is the hash table.  When recording a list, it is added\n+   to the slot whose index is the hash code mod the table size.\n+   Note that the hash table is used for several kinds of lists.\n+   While all these live in the same table, they are completely independent,\n+   and the hash code is computed differently for each of these.  */\n+\n+static GTY (()) hash_table<list_hasher> *list_hash_table;\n+\n /* Compare ENTRY (an entry in the hash table) with DATA (a list_proxy\n    for a node we are thinking about adding).  */\n \n-static int\n-list_hash_eq (const void* entry, const void* data)\n+bool\n+list_hasher::equal (tree t, list_proxy *proxy)\n {\n-  const_tree const t = (const_tree) entry;\n-  const struct list_proxy *const proxy = (const struct list_proxy *) data;\n-\n   return (TREE_VALUE (t) == proxy->value\n \t  && TREE_PURPOSE (t) == proxy->purpose\n \t  && TREE_CHAIN (t) == proxy->chain);\n@@ -1695,10 +1702,9 @@ list_hash_pieces (tree purpose, tree value, tree chain)\n \n /* Hash an already existing TREE_LIST.  */\n \n-static hashval_t\n-list_hash (const void* p)\n+hashval_t\n+list_hasher::hash (tree t)\n {\n-  const_tree const t = (const_tree) p;\n   return list_hash_pieces (TREE_PURPOSE (t),\n \t\t\t   TREE_VALUE (t),\n \t\t\t   TREE_CHAIN (t));\n@@ -1712,7 +1718,7 @@ tree\n hash_tree_cons (tree purpose, tree value, tree chain)\n {\n   int hashcode = 0;\n-  void **slot;\n+  tree *slot;\n   struct list_proxy proxy;\n \n   /* Hash the list node.  */\n@@ -1723,8 +1729,7 @@ hash_tree_cons (tree purpose, tree value, tree chain)\n   proxy.value = value;\n   proxy.chain = chain;\n   /* See if it is already in the table.  */\n-  slot = htab_find_slot_with_hash (list_hash_table, &proxy, hashcode,\n-\t\t\t\t   INSERT);\n+  slot = list_hash_table->find_slot_with_hash (&proxy, hashcode, INSERT);\n   /* If not, create a new node.  */\n   if (!*slot)\n     *slot = tree_cons (purpose, value, chain);\n@@ -3670,7 +3675,7 @@ cp_save_expr (tree expr)\n void\n init_tree (void)\n {\n-  list_hash_table = htab_create_ggc (31, list_hash, list_hash_eq, NULL);\n+  list_hash_table = hash_table<list_hasher>::create_ggc (61);\n }\n \n /* Returns the kind of special function that DECL (a FUNCTION_DECL)"}, {"sha": "ad69668765a60d5b74da880933e7a66e65ff902c", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 23, "deletions": 24, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=2a22f99cb12d82712dd93cfef808b1cef543601b", "patch": "@@ -135,7 +135,7 @@ cxx_readonly_error (tree arg, enum lvalue_use errstring)\n /* Structure that holds information about declarations whose type was\n    incomplete and we could not check whether it was abstract or not.  */\n \n-struct GTY((chain_next (\"%h.next\"))) pending_abstract_type {\n+struct GTY((chain_next (\"%h.next\"), for_user)) pending_abstract_type {\n   /* Declaration which we are checking for abstractness. It is either\n      a DECL node, or an IDENTIFIER_NODE if we do not have a full\n      declaration available.  */\n@@ -155,37 +155,36 @@ struct GTY((chain_next (\"%h.next\"))) pending_abstract_type {\n   struct pending_abstract_type* next;\n };\n \n+struct abstract_type_hasher : ggc_hasher<pending_abstract_type *>\n+{\n+  typedef tree compare_type;\n+  static hashval_t hash (pending_abstract_type *);\n+  static bool equal (pending_abstract_type *, tree);\n+};\n \n /* Compute the hash value of the node VAL. This function is used by the\n    hash table abstract_pending_vars.  */\n \n-static hashval_t\n-pat_calc_hash (const void* val)\n+hashval_t\n+abstract_type_hasher::hash (pending_abstract_type *pat)\n {\n-  const struct pending_abstract_type *pat =\n-     (const struct pending_abstract_type *) val;\n   return (hashval_t) TYPE_UID (pat->type);\n }\n \n \n /* Compare node VAL1 with the type VAL2. This function is used by the\n    hash table abstract_pending_vars.  */\n \n-static int\n-pat_compare (const void* val1, const void* val2)\n+bool\n+abstract_type_hasher::equal (pending_abstract_type *pat1, tree type2)\n {\n-  const struct pending_abstract_type *const pat1 =\n-     (const struct pending_abstract_type *) val1;\n-  const_tree const type2 = (const_tree)val2;\n-\n   return (pat1->type == type2);\n }\n \n /* Hash table that maintains pending_abstract_type nodes, for which we still\n    need to check for type abstractness.  The key of the table is the type\n    of the declaration.  */\n-static GTY ((param_is (struct pending_abstract_type)))\n-htab_t abstract_pending_vars = NULL;\n+static GTY (()) hash_table<abstract_type_hasher> *abstract_pending_vars = NULL;\n \n static int abstract_virtuals_error_sfinae (tree, tree, abstract_class_use, tsubst_flags_t);\n \n@@ -197,7 +196,6 @@ static int abstract_virtuals_error_sfinae (tree, tree, abstract_class_use, tsubs\n void\n complete_type_check_abstract (tree type)\n {\n-  void **slot;\n   struct pending_abstract_type *pat;\n   location_t cur_loc = input_location;\n \n@@ -207,11 +205,12 @@ complete_type_check_abstract (tree type)\n     return;\n \n   /* Retrieve the list of pending declarations for this type.  */\n-  slot = htab_find_slot_with_hash (abstract_pending_vars, type,\n-\t\t\t\t   (hashval_t)TYPE_UID (type), NO_INSERT);\n+  pending_abstract_type **slot\n+    = abstract_pending_vars->find_slot_with_hash (type, TYPE_UID (type),\n+\t\t\t\t\t\t  NO_INSERT);\n   if (!slot)\n     return;\n-  pat = (struct pending_abstract_type*)*slot;\n+  pat = *slot;\n   gcc_assert (pat);\n \n   /* If the type is not abstract, do not do anything.  */\n@@ -244,7 +243,7 @@ complete_type_check_abstract (tree type)\n \t}\n     }\n \n-  htab_clear_slot (abstract_pending_vars, slot);\n+  abstract_pending_vars->clear_slot (slot);\n \n   input_location = cur_loc;\n }\n@@ -282,17 +281,17 @@ abstract_virtuals_error_sfinae (tree decl, tree type, abstract_class_use use,\n      name.  */\n   if (!COMPLETE_TYPE_P (type) && (complain & tf_error))\n     {\n-      void **slot;\n       struct pending_abstract_type *pat;\n \n       gcc_assert (!decl || DECL_P (decl) || identifier_p (decl));\n \n       if (!abstract_pending_vars)\n-\tabstract_pending_vars = htab_create_ggc (31, &pat_calc_hash,\n-\t\t\t\t\t\t&pat_compare, NULL);\n+\tabstract_pending_vars\n+\t  = hash_table<abstract_type_hasher>::create_ggc (31);\n \n-      slot = htab_find_slot_with_hash (abstract_pending_vars, type,\n-\t\t\t\t      (hashval_t)TYPE_UID (type), INSERT);\n+      pending_abstract_type **slot\n+       \t= abstract_pending_vars->find_slot_with_hash (type, TYPE_UID (type),\n+\t\t\t\t\t\t      INSERT);\n \n       pat = ggc_alloc<pending_abstract_type> ();\n       pat->type = type;\n@@ -302,7 +301,7 @@ abstract_virtuals_error_sfinae (tree decl, tree type, abstract_class_use use,\n \t\t    ? DECL_SOURCE_LOCATION (decl)\n \t\t    : input_location);\n \n-      pat->next = (struct pending_abstract_type *) *slot;\n+      pat->next = *slot;\n       *slot = pat;\n \n       return 0;"}, {"sha": "609cfceefd2b39e0126275487e455a81bf6fd11b", "filename": "gcc/doc/gty.texi", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Fdoc%2Fgty.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Fdoc%2Fgty.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgty.texi?ref=2a22f99cb12d82712dd93cfef808b1cef543601b", "patch": "@@ -197,6 +197,12 @@ If @code{skip} is applied to a field, the type machinery will ignore it.\n This is somewhat dangerous; the only safe use is in a union when one\n field really isn't ever used.\n \n+@findex for_user\n+Use this to mark types that need to be marked by user gc routines, but are not\n+refered to in a template argument.  So if you have some user gc type T1 and a\n+non user gc type T2 you can give T2 the for_user option so that the marking\n+functions for T1 can call non mangled functions to mark T2.\n+\n @findex desc\n @findex tag\n @findex default"}, {"sha": "00eba7896855993faf1274585e655659d36ec257", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 200, "deletions": 193, "changes": 393, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=2a22f99cb12d82712dd93cfef808b1cef543601b", "patch": "@@ -205,15 +205,23 @@ static GTY(()) section *debug_frame_section;\n \n static GTY(()) vec<dw_fde_ref, va_gc> *fde_vec;\n \n-struct GTY(()) indirect_string_node {\n+struct GTY((for_user)) indirect_string_node {\n   const char *str;\n   unsigned int refcount;\n   enum dwarf_form form;\n   char *label;\n   unsigned int index;\n };\n \n-static GTY ((param_is (struct indirect_string_node))) htab_t debug_str_hash;\n+struct indirect_string_hasher : ggc_hasher<indirect_string_node *>\n+{\n+  typedef const char *compare_type;\n+\n+  static hashval_t hash (indirect_string_node *);\n+  static bool equal (indirect_string_node *, const char *);\n+};\n+\n+static GTY (()) hash_table<indirect_string_hasher> *debug_str_hash;\n \n /* With split_debug_info, both the comp_dir and dwo_name go in the\n    main object file, rather than the dwo, similar to the force_direct\n@@ -234,8 +242,7 @@ static GTY ((param_is (struct indirect_string_node))) htab_t debug_str_hash;\n    main object file.  This limits the complexity to just the places\n    that need it.  */\n \n-static GTY ((param_is (struct indirect_string_node)))\n-  htab_t skeleton_debug_str_hash;\n+static GTY (()) hash_table<indirect_string_hasher> *skeleton_debug_str_hash;\n \n static GTY(()) int dw2_string_counter;\n \n@@ -1235,7 +1242,7 @@ dwarf2out_switch_text_section (void)\n    for emitting location expressions.  */\n \n /* Data about a single source file.  */\n-struct GTY(()) dwarf_file_data {\n+struct GTY((for_user)) dwarf_file_data {\n   const char * filename;\n   int emitted_number;\n };\n@@ -1258,7 +1265,7 @@ enum ate_kind {\n   ate_kind_label\n };\n \n-typedef struct GTY(()) addr_table_entry_struct {\n+typedef struct GTY((for_user)) addr_table_entry_struct {\n   enum ate_kind kind;\n   unsigned int refcount;\n   unsigned int index;\n@@ -2417,7 +2424,6 @@ build_cfa_aligned_loc (dw_cfa_location *cfa,\n /* And now, the support for symbolic debugging information.  */\n \n /* .debug_str support.  */\n-static int output_indirect_string (void **, void *);\n \n static void dwarf2out_init (const char *);\n static void dwarf2out_finish (const char *);\n@@ -2589,7 +2595,7 @@ dw_attr_node;\n    The children of each node form a circular list linked by\n    die_sib.  die_child points to the node *before* the \"first\" child node.  */\n \n-typedef struct GTY((chain_circular (\"%h.die_sib\"))) die_struct {\n+typedef struct GTY((chain_circular (\"%h.die_sib\"), for_user)) die_struct {\n   union die_symbol_or_type_node\n     {\n       const char * GTY ((tag (\"0\"))) die_symbol;\n@@ -2775,16 +2781,37 @@ static GTY(()) limbo_die_node *limbo_die_list;\n    DW_AT_{,MIPS_}linkage_name once their DECL_ASSEMBLER_NAMEs are set.  */\n static GTY(()) limbo_die_node *deferred_asm_name;\n \n+struct dwarf_file_hasher : ggc_hasher<dwarf_file_data *>\n+{\n+  typedef const char *compare_type;\n+\n+  static hashval_t hash (dwarf_file_data *);\n+  static bool equal (dwarf_file_data *, const char *);\n+};\n+\n /* Filenames referenced by this compilation unit.  */\n-static GTY((param_is (struct dwarf_file_data))) htab_t file_table;\n+static GTY(()) hash_table<dwarf_file_hasher> *file_table;\n \n+struct decl_die_hasher : ggc_hasher<die_node *>\n+{\n+  typedef tree compare_type;\n+\n+  static hashval_t hash (die_node *);\n+  static bool equal (die_node *, tree);\n+};\n /* A hash table of references to DIE's that describe declarations.\n    The key is a DECL_UID() which is a unique number identifying each decl.  */\n-static GTY ((param_is (struct die_struct))) htab_t decl_die_table;\n+static GTY (()) hash_table<decl_die_hasher> *decl_die_table;\n+\n+struct block_die_hasher : ggc_hasher<die_struct *>\n+{\n+  static hashval_t hash (die_struct *);\n+  static bool equal (die_struct *, die_struct *);\n+};\n \n /* A hash table of references to DIE's that describe COMMON blocks.\n    The key is DECL_UID() ^ die_parent.  */\n-static GTY ((param_is (struct die_struct))) htab_t common_block_die_table;\n+static GTY (()) hash_table<block_die_hasher> *common_block_die_table;\n \n typedef struct GTY(()) die_arg_entry_struct {\n     dw_die_ref die;\n@@ -2808,7 +2835,7 @@ struct GTY ((chain_next (\"%h.next\"))) var_loc_node {\n };\n \n /* Variable location list.  */\n-struct GTY (()) var_loc_list_def {\n+struct GTY ((for_user)) var_loc_list_def {\n   struct var_loc_node * GTY (()) first;\n \n   /* Pointer to the last but one or last element of the\n@@ -2840,8 +2867,16 @@ struct GTY ((chain_next (\"%h.next\"))) call_arg_loc_node {\n };\n \n \n+struct decl_loc_hasher : ggc_hasher<var_loc_list *>\n+{\n+  typedef const_tree compare_type;\n+\n+  static hashval_t hash (var_loc_list *);\n+  static bool equal (var_loc_list *, const_tree);\n+};\n+\n /* Table of decl location linked lists.  */\n-static GTY ((param_is (var_loc_list))) htab_t decl_loc_table;\n+static GTY (()) hash_table<decl_loc_hasher> *decl_loc_table;\n \n /* Head and tail of call_arg_loc chain.  */\n static GTY (()) struct call_arg_loc_node *call_arg_locations;\n@@ -2857,7 +2892,7 @@ static int tail_call_site_count = -1;\n static vec<dw_die_ref> block_map;\n \n /* A cached location list.  */\n-struct GTY (()) cached_dw_loc_list_def {\n+struct GTY ((for_user)) cached_dw_loc_list_def {\n   /* The DECL_UID of the decl that this entry describes.  */\n   unsigned int decl_id;\n \n@@ -2866,8 +2901,17 @@ struct GTY (()) cached_dw_loc_list_def {\n };\n typedef struct cached_dw_loc_list_def cached_dw_loc_list;\n \n+struct dw_loc_list_hasher : ggc_hasher<cached_dw_loc_list *>\n+{\n+\n+  typedef const_tree compare_type;\n+  \n+  static hashval_t hash (cached_dw_loc_list *);\n+  static bool equal (cached_dw_loc_list *, const_tree);\n+};\n+\n /* Table of cached location lists.  */\n-static GTY ((param_is (cached_dw_loc_list))) htab_t cached_dw_loc_list_table;\n+static GTY (()) hash_table<dw_loc_list_hasher> *cached_dw_loc_list_table;\n \n /* A pointer to the base of a list of references to DIE's that\n    are uniquely identified by their tag, presence/absence of\n@@ -3002,8 +3046,6 @@ static void add_AT_double (dw_die_ref, enum dwarf_attribute,\n static inline void add_AT_vec (dw_die_ref, enum dwarf_attribute, unsigned int,\n \t\t\t       unsigned int, unsigned char *);\n static void add_AT_data8 (dw_die_ref, enum dwarf_attribute, unsigned char *);\n-static hashval_t debug_str_do_hash (const void *);\n-static int debug_str_eq (const void *, const void *);\n static void add_AT_string (dw_die_ref, enum dwarf_attribute, const char *);\n static inline const char *AT_string (dw_attr_ref);\n static enum dwarf_form AT_string_form (dw_attr_ref);\n@@ -3048,13 +3090,7 @@ static dw_die_ref lookup_type_die (tree);\n static dw_die_ref strip_naming_typedef (tree, dw_die_ref);\n static dw_die_ref lookup_type_die_strip_naming_typedef (tree);\n static void equate_type_number_to_die (tree, dw_die_ref);\n-static hashval_t decl_die_table_hash (const void *);\n-static int decl_die_table_eq (const void *, const void *);\n static dw_die_ref lookup_decl_die (tree);\n-static hashval_t common_block_die_table_hash (const void *);\n-static int common_block_die_table_eq (const void *, const void *);\n-static hashval_t decl_loc_table_hash (const void *);\n-static int decl_loc_table_eq (const void *, const void *);\n static var_loc_list *lookup_decl_loc (const_tree);\n static void equate_decl_number_to_die (tree, dw_die_ref);\n static struct var_loc_node *add_var_loc_to_decl (tree, rtx, const char *);\n@@ -3908,37 +3944,36 @@ add_AT_low_high_pc (dw_die_ref die, const char *lbl_low, const char *lbl_high,\n \n /* Hash and equality functions for debug_str_hash.  */\n \n-static hashval_t\n-debug_str_do_hash (const void *x)\n+hashval_t\n+indirect_string_hasher::hash (indirect_string_node *x)\n {\n-  return htab_hash_string (((const struct indirect_string_node *)x)->str);\n+  return htab_hash_string (x->str);\n }\n \n-static int\n-debug_str_eq (const void *x1, const void *x2)\n+bool\n+indirect_string_hasher::equal (indirect_string_node *x1, const char *x2)\n {\n-  return strcmp ((((const struct indirect_string_node *)x1)->str),\n-\t\t (const char *)x2) == 0;\n+  return strcmp (x1->str, x2) == 0;\n }\n \n /* Add STR to the given string hash table.  */\n \n static struct indirect_string_node *\n-find_AT_string_in_table (const char *str, htab_t table)\n+find_AT_string_in_table (const char *str,\n+\t\t\t hash_table<indirect_string_hasher> *table)\n {\n   struct indirect_string_node *node;\n-  void **slot;\n \n-  slot = htab_find_slot_with_hash (table, str,\n-\t\t\t\t   htab_hash_string (str), INSERT);\n+  indirect_string_node **slot\n+    = table->find_slot_with_hash (str, htab_hash_string (str), INSERT);\n   if (*slot == NULL)\n     {\n       node = ggc_cleared_alloc<indirect_string_node> ();\n       node->str = ggc_strdup (str);\n       *slot = node;\n     }\n   else\n-    node = (struct indirect_string_node *) *slot;\n+    node = *slot;\n \n   node->refcount++;\n   return node;\n@@ -3950,8 +3985,7 @@ static struct indirect_string_node *\n find_AT_string (const char *str)\n {\n   if (! debug_str_hash)\n-    debug_str_hash = htab_create_ggc (10, debug_str_do_hash,\n-\t\t\t\t      debug_str_eq, NULL);\n+    debug_str_hash = hash_table<indirect_string_hasher>::create_ggc (10);\n \n   return find_AT_string_in_table (str, debug_str_hash);\n }\n@@ -4180,16 +4214,21 @@ AT_loc_list_ptr (dw_attr_ref a)\n   return &a->dw_attr_val.v.val_loc_list;\n }\n \n+struct addr_hasher : ggc_hasher<addr_table_entry *>\n+{\n+  static hashval_t hash (addr_table_entry *);\n+  static bool equal (addr_table_entry *, addr_table_entry *);\n+};\n+\n /* Table of entries into the .debug_addr section.  */\n \n-static GTY ((param_is (addr_table_entry))) htab_t addr_index_table;\n+static GTY (()) hash_table<addr_hasher> *addr_index_table;\n \n /* Hash an address_table_entry.  */\n \n-static hashval_t\n-addr_table_entry_do_hash (const void *x)\n+hashval_t\n+addr_hasher::hash (addr_table_entry *a)\n {\n-  const addr_table_entry *a = (const addr_table_entry *) x;\n   inchash::hash hstate;\n   switch (a->kind)\n     {\n@@ -4210,12 +4249,9 @@ addr_table_entry_do_hash (const void *x)\n \n /* Determine equality for two address_table_entries.  */\n \n-static int\n-addr_table_entry_eq (const void *x1, const void *x2)\n+bool\n+addr_hasher::equal (addr_table_entry *a1, addr_table_entry *a2)\n {\n-  const addr_table_entry *a1 = (const addr_table_entry *) x1;\n-  const addr_table_entry *a2 = (const addr_table_entry *) x2;\n-\n   if (a1->kind != a2->kind)\n     return 0;\n   switch (a1->kind)\n@@ -4258,14 +4294,12 @@ add_addr_table_entry (void *addr, enum ate_kind kind)\n {\n   addr_table_entry *node;\n   addr_table_entry finder;\n-  void **slot;\n \n   gcc_assert (dwarf_split_debug_info);\n   if (! addr_index_table)\n-    addr_index_table = htab_create_ggc (10, addr_table_entry_do_hash,\n-                                        addr_table_entry_eq, NULL);\n+    addr_index_table = hash_table<addr_hasher>::create_ggc (10);\n   init_addr_table_entry (&finder, kind, addr);\n-  slot = htab_find_slot (addr_index_table, &finder, INSERT);\n+  addr_table_entry **slot = addr_index_table->find_slot (&finder, INSERT);\n \n   if (*slot == HTAB_EMPTY_ENTRY)\n     {\n@@ -4274,7 +4308,7 @@ add_addr_table_entry (void *addr, enum ate_kind kind)\n       *slot = node;\n     }\n   else\n-    node = (addr_table_entry *) *slot;\n+    node = *slot;\n \n   node->refcount++;\n   return node;\n@@ -4314,11 +4348,10 @@ remove_loc_list_addr_table_entries (dw_loc_descr_ref descr)\n    because the indexing code relies on htab_traverse to traverse nodes\n    in the same order for each run. */\n \n-static int\n-index_addr_table_entry (void **h, void *v)\n+int\n+index_addr_table_entry (addr_table_entry **h, unsigned int *index)\n {\n-  addr_table_entry *node = (addr_table_entry *) *h;\n-  unsigned int *index = (unsigned int *) v;\n+  addr_table_entry *node = *h;\n \n   /* Don't index unreferenced nodes.  */\n   if (node->refcount == 0)\n@@ -4913,43 +4946,43 @@ equate_type_number_to_die (tree type, dw_die_ref type_die)\n \n /* Returns a hash value for X (which really is a die_struct).  */\n \n-static hashval_t\n-decl_die_table_hash (const void *x)\n+inline hashval_t\n+decl_die_hasher::hash (die_node *x)\n {\n-  return (hashval_t) ((const_dw_die_ref) x)->decl_id;\n+  return (hashval_t) x->decl_id;\n }\n \n /* Return nonzero if decl_id of die_struct X is the same as UID of decl *Y.  */\n \n-static int\n-decl_die_table_eq (const void *x, const void *y)\n+inline bool\n+decl_die_hasher::equal (die_node *x, tree y)\n {\n-  return (((const_dw_die_ref) x)->decl_id == DECL_UID ((const_tree) y));\n+  return (x->decl_id == DECL_UID (y));\n }\n \n /* Return the DIE associated with a given declaration.  */\n \n static inline dw_die_ref\n lookup_decl_die (tree decl)\n {\n-  return (dw_die_ref) htab_find_with_hash (decl_die_table, decl, DECL_UID (decl));\n+  return decl_die_table->find_with_hash (decl, DECL_UID (decl));\n }\n \n /* Returns a hash value for X (which really is a var_loc_list).  */\n \n-static hashval_t\n-decl_loc_table_hash (const void *x)\n+inline hashval_t\n+decl_loc_hasher::hash (var_loc_list *x)\n {\n-  return (hashval_t) ((const var_loc_list *) x)->decl_id;\n+  return (hashval_t) x->decl_id;\n }\n \n /* Return nonzero if decl_id of var_loc_list X is the same as\n    UID of decl *Y.  */\n \n-static int\n-decl_loc_table_eq (const void *x, const void *y)\n+inline bool\n+decl_loc_hasher::equal (var_loc_list *x, const_tree y)\n {\n-  return (((const var_loc_list *) x)->decl_id == DECL_UID ((const_tree) y));\n+  return (x->decl_id == DECL_UID (y));\n }\n \n /* Return the var_loc list associated with a given declaration.  */\n@@ -4959,26 +4992,24 @@ lookup_decl_loc (const_tree decl)\n {\n   if (!decl_loc_table)\n     return NULL;\n-  return (var_loc_list *)\n-    htab_find_with_hash (decl_loc_table, decl, DECL_UID (decl));\n+  return decl_loc_table->find_with_hash (decl, DECL_UID (decl));\n }\n \n /* Returns a hash value for X (which really is a cached_dw_loc_list_list).  */\n \n-static hashval_t\n-cached_dw_loc_list_table_hash (const void *x)\n+inline hashval_t\n+dw_loc_list_hasher::hash (cached_dw_loc_list *x)\n {\n-  return (hashval_t) ((const cached_dw_loc_list *) x)->decl_id;\n+  return (hashval_t) x->decl_id;\n }\n \n /* Return nonzero if decl_id of cached_dw_loc_list X is the same as\n    UID of decl *Y.  */\n \n-static int\n-cached_dw_loc_list_table_eq (const void *x, const void *y)\n+inline bool\n+dw_loc_list_hasher::equal (cached_dw_loc_list *x, const_tree y)\n {\n-  return (((const cached_dw_loc_list *) x)->decl_id\n-\t  == DECL_UID ((const_tree) y));\n+  return (x->decl_id == DECL_UID (y));\n }\n \n /* Equate a DIE to a particular declaration.  */\n@@ -4987,10 +5018,8 @@ static void\n equate_decl_number_to_die (tree decl, dw_die_ref decl_die)\n {\n   unsigned int decl_id = DECL_UID (decl);\n-  void **slot;\n \n-  slot = htab_find_slot_with_hash (decl_die_table, decl, decl_id, INSERT);\n-  *slot = decl_die;\n+  *decl_die_table->find_slot_with_hash (decl, decl_id, INSERT) = decl_die;\n   decl_die->decl_id = decl_id;\n }\n \n@@ -5138,7 +5167,6 @@ add_var_loc_to_decl (tree decl, rtx loc_note, const char *label)\n {\n   unsigned int decl_id;\n   var_loc_list *temp;\n-  void **slot;\n   struct var_loc_node *loc = NULL;\n   HOST_WIDE_INT bitsize = -1, bitpos = -1;\n \n@@ -5166,15 +5194,16 @@ add_var_loc_to_decl (tree decl, rtx loc_note, const char *label)\n     }\n \n   decl_id = DECL_UID (decl);\n-  slot = htab_find_slot_with_hash (decl_loc_table, decl, decl_id, INSERT);\n+  var_loc_list **slot\n+    = decl_loc_table->find_slot_with_hash (decl, decl_id, INSERT);\n   if (*slot == NULL)\n     {\n       temp = ggc_cleared_alloc<var_loc_list> ();\n       temp->decl_id = decl_id;\n       *slot = temp;\n     }\n   else\n-    temp = (var_loc_list *) *slot;\n+    temp = *slot;\n \n   /* For PARM_DECLs try to keep around the original incoming value,\n      even if that means we'll emit a zero-range .debug_loc entry.  */\n@@ -9037,8 +9066,8 @@ add_skeleton_AT_string (dw_die_ref die, enum dwarf_attribute attr_kind,\n   struct indirect_string_node *node;\n \n   if (! skeleton_debug_str_hash)\n-    skeleton_debug_str_hash = htab_create_ggc (10, debug_str_do_hash,\n-                                               debug_str_eq, NULL);\n+    skeleton_debug_str_hash\n+      = hash_table<indirect_string_hasher>::create_ggc (10);\n \n   node = find_AT_string_in_table (str, skeleton_debug_str_hash);\n   find_string_form (node);\n@@ -9739,11 +9768,10 @@ struct file_name_acquire_data\n \n /* Traversal function for the hash table.  */\n \n-static int\n-file_name_acquire (void ** slot, void *data)\n+int\n+file_name_acquire (dwarf_file_data **slot, file_name_acquire_data *fnad)\n {\n-  struct file_name_acquire_data *fnad = (struct file_name_acquire_data *) data;\n-  struct dwarf_file_data *d = (struct dwarf_file_data *) *slot;\n+  struct dwarf_file_data *d = *slot;\n   struct file_info *fi;\n   const char *f;\n \n@@ -9818,7 +9846,7 @@ output_file_names (void)\n   fnad.files = files;\n   fnad.used_files = 0;\n   fnad.max_files = numfiles;\n-  htab_traverse (file_table, file_name_acquire, &fnad);\n+  file_table->traverse<file_name_acquire_data *, file_name_acquire> (&fnad);\n   gcc_assert (fnad.used_files == fnad.max_files);\n \n   qsort (files, numfiles, sizeof (files[0]), file_info_cmp);\n@@ -15812,7 +15840,6 @@ add_location_or_const_value_attribute (dw_die_ref die, tree decl, bool cache_p,\n   dw_loc_list_ref list;\n   var_loc_list *loc_list;\n   cached_dw_loc_list *cache;\n-  void **slot;\n \n   if (TREE_CODE (decl) == ERROR_MARK)\n     return false;\n@@ -15856,8 +15883,7 @@ add_location_or_const_value_attribute (dw_die_ref die, tree decl, bool cache_p,\n     cache_p = false;\n   if (cache_p)\n     {\n-      cache = (cached_dw_loc_list *)\n-\thtab_find_with_hash (cached_dw_loc_list_table, decl, DECL_UID (decl));\n+      cache = cached_dw_loc_list_table->find_with_hash (decl, DECL_UID (decl));\n       if (cache)\n \tlist = cache->loc_list;\n     }\n@@ -15868,8 +15894,10 @@ add_location_or_const_value_attribute (dw_die_ref die, tree decl, bool cache_p,\n \t BLOCK_NONLOCALIZED_VARS and if the list has at least two elements.  */\n       if (cache_p && list && list->dw_loc_next)\n \t{\n-\t  slot = htab_find_slot_with_hash (cached_dw_loc_list_table, decl,\n-\t\t\t\t\t   DECL_UID (decl), INSERT);\n+\t  cached_dw_loc_list **slot\n+\t    = cached_dw_loc_list_table->find_slot_with_hash (decl,\n+\t\t\t\t\t\t\t     DECL_UID (decl),\n+\t\t\t\t\t\t\t     INSERT);\n \t  cache = ggc_cleared_alloc<cached_dw_loc_list> ();\n \t  cache->decl_id = DECL_UID (decl);\n \t  cache->loc_list = list;\n@@ -17991,8 +18019,8 @@ dwarf2out_abstract_function (tree decl)\n   tree save_fn;\n   tree context;\n   int was_abstract;\n-  htab_t old_decl_loc_table;\n-  htab_t old_cached_dw_loc_list_table;\n+  hash_table<decl_loc_hasher> *old_decl_loc_table;\n+  hash_table<dw_loc_list_hasher> *old_cached_dw_loc_list_table;\n   int old_call_site_count, old_tail_call_site_count;\n   struct call_arg_loc_node *old_call_arg_locations;\n \n@@ -18070,9 +18098,9 @@ premark_used_types_helper (tree const &type, void *)\n    marked as unused by prune_unused_types. The DIE of the type is marked\n    only if the global variable using the type will actually be emitted.  */\n \n-static int\n-premark_types_used_by_global_vars_helper (void **slot,\n-\t\t\t\t\t  void *data ATTRIBUTE_UNUSED)\n+int\n+premark_types_used_by_global_vars_helper (types_used_by_vars_entry **slot,\n+\t\t\t\t\t  void *)\n {\n   struct types_used_by_vars_entry *entry;\n   dw_die_ref die;\n@@ -18112,8 +18140,8 @@ static void\n premark_types_used_by_global_vars (void)\n {\n   if (types_used_by_vars_hash)\n-    htab_traverse (types_used_by_vars_hash,\n-\t\t   premark_types_used_by_global_vars_helper, NULL);\n+    types_used_by_vars_hash\n+      ->traverse<void *, premark_types_used_by_global_vars_helper> (NULL);\n }\n \n /* Generate a DW_TAG_GNU_call_site DIE in function DECL under SUBR_DIE\n@@ -18782,22 +18810,19 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)\n \n /* Returns a hash value for X (which really is a die_struct).  */\n \n-static hashval_t\n-common_block_die_table_hash (const void *x)\n+hashval_t\n+block_die_hasher::hash (die_struct *d)\n {\n-  const_dw_die_ref d = (const_dw_die_ref) x;\n   return (hashval_t) d->decl_id ^ htab_hash_pointer (d->die_parent);\n }\n \n /* Return nonzero if decl_id and die_parent of die_struct X is the same\n    as decl_id and die_parent of die_struct Y.  */\n \n-static int\n-common_block_die_table_eq (const void *x, const void *y)\n+bool\n+block_die_hasher::equal (die_struct *x, die_struct *y)\n {\n-  const_dw_die_ref d = (const_dw_die_ref) x;\n-  const_dw_die_ref e = (const_dw_die_ref) y;\n-  return d->decl_id == e->decl_id && d->die_parent == e->die_parent;\n+  return x->decl_id == y->decl_id && x->die_parent == y->die_parent;\n }\n \n /* Generate a DIE to represent a declared data object.\n@@ -18862,19 +18887,17 @@ gen_variable_die (tree decl, tree origin, dw_die_ref context_die)\n \t}\n \n       if (common_block_die_table == NULL)\n-\tcommon_block_die_table\n-\t  = htab_create_ggc (10, common_block_die_table_hash,\n-\t\t\t     common_block_die_table_eq, NULL);\n+\tcommon_block_die_table = hash_table<block_die_hasher>::create_ggc (10);\n \n       com_die_arg.decl_id = DECL_UID (com_decl);\n       com_die_arg.die_parent = context_die;\n-      com_die = (dw_die_ref) htab_find (common_block_die_table, &com_die_arg);\n+      com_die = common_block_die_table->find (&com_die_arg);\n       loc = loc_list_from_tree (com_decl, 2);\n       if (com_die == NULL)\n \t{\n \t  const char *cnam\n \t    = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (com_decl));\n-\t  void **slot;\n+\t  die_node **slot;\n \n \t  com_die = new_die (DW_TAG_common_block, context_die, decl);\n \t  add_name_and_src_coords_attributes (com_die, com_decl);\n@@ -18890,8 +18913,8 @@ gen_variable_die (tree decl, tree origin, dw_die_ref context_die)\n \t  if (want_pubnames ())\n \t    add_pubname_string (cnam, com_die); /* ??? needed? */\n \t  com_die->decl_id = DECL_UID (com_decl);\n-\t  slot = htab_find_slot (common_block_die_table, com_die, INSERT);\n-\t  *slot = (void *) com_die;\n+\t  slot = common_block_die_table->find_slot (com_die, INSERT);\n+\t  *slot = com_die;\n \t}\n       else if (get_AT (com_die, DW_AT_location) == NULL && loc)\n \t{\n@@ -21066,8 +21089,8 @@ dwarf2out_function_decl (tree decl)\n   call_site_count = -1;\n   tail_call_site_count = -1;\n   block_map.release ();\n-  htab_empty (decl_loc_table);\n-  htab_empty (cached_dw_loc_list_table);\n+  decl_loc_table->empty ();\n+  cached_dw_loc_list_table->empty ();\n }\n \n /* Output a marker (i.e. a label) for the beginning of the generated code for\n@@ -21121,19 +21144,15 @@ dwarf2out_ignore_block (const_tree block)\n \n /* Hash table routines for file_hash.  */\n \n-static int\n-file_table_eq (const void *p1_p, const void *p2_p)\n+bool\n+dwarf_file_hasher::equal (dwarf_file_data *p1, const char *p2)\n {\n-  const struct dwarf_file_data *const p1 =\n-    (const struct dwarf_file_data *) p1_p;\n-  const char *const p2 = (const char *) p2_p;\n   return filename_cmp (p1->filename, p2) == 0;\n }\n \n-static hashval_t\n-file_table_hash (const void *p_p)\n+hashval_t\n+dwarf_file_hasher::hash (dwarf_file_data *p)\n {\n-  const struct dwarf_file_data *const p = (const struct dwarf_file_data *) p_p;\n   return htab_hash_string (p->filename);\n }\n \n@@ -21151,7 +21170,6 @@ file_table_hash (const void *p_p)\n static struct dwarf_file_data *\n lookup_filename (const char *file_name)\n {\n-  void ** slot;\n   struct dwarf_file_data * created;\n \n   /* Check to see if the file name that was searched on the previous\n@@ -21162,10 +21180,11 @@ lookup_filename (const char *file_name)\n     return file_table_last_lookup;\n \n   /* Didn't match the previous lookup, search the table.  */\n-  slot = htab_find_slot_with_hash (file_table, file_name,\n-\t\t\t\t   htab_hash_string (file_name), INSERT);\n+  dwarf_file_data **slot\n+    = file_table->find_slot_with_hash (file_name, htab_hash_string (file_name),\n+\t\t\t\t       INSERT);\n   if (*slot)\n-    return (struct dwarf_file_data *) *slot;\n+    return *slot;\n \n   created = ggc_alloc<dwarf_file_data> ();\n   created->filename = file_name;\n@@ -21525,10 +21544,10 @@ dwarf2out_var_location (rtx_insn *loc_note)\n \n /* Note in one location list that text section has changed.  */\n \n-static int\n-var_location_switch_text_section_1 (void **slot, void *data ATTRIBUTE_UNUSED)\n+int\n+var_location_switch_text_section_1 (var_loc_list **slot, void *)\n {\n-  var_loc_list *list = (var_loc_list *) *slot;\n+  var_loc_list *list = *slot;\n   if (list->first)\n     list->last_before_switch\n       = list->last->next ? list->last->next : list->last;\n@@ -21543,7 +21562,7 @@ var_location_switch_text_section (void)\n   if (decl_loc_table == NULL)\n     return;\n \n-  htab_traverse (decl_loc_table, var_location_switch_text_section_1, NULL);\n+  decl_loc_table->traverse<void *, var_location_switch_text_section_1> (NULL);\n }\n \n /* Create a new line number table.  */\n@@ -21652,13 +21671,12 @@ dwarf2out_begin_function (tree fun)\n    Set have_multiple_function_sections to true in that case and\n    terminate htab traversal.  */\n \n-static int\n-find_empty_loc_ranges_at_text_label (void **slot, void *)\n+int\n+find_empty_loc_ranges_at_text_label (var_loc_list **slot, int)\n {\n-  var_loc_list *entry;\n+  var_loc_list *entry = *slot;\n   struct var_loc_node *node;\n \n-  entry = (var_loc_list *) *slot;\n   node = entry->first;\n   if (node && node->next && node->next->label)\n     {\n@@ -21689,8 +21707,7 @@ dwarf2out_end_function (unsigned int)\n       && !have_multiple_function_sections\n       && first_loclabel_num_not_at_text_label\n       && decl_loc_table)\n-    htab_traverse (decl_loc_table, find_empty_loc_ranges_at_text_label,\n-\t\t   NULL);\n+    decl_loc_table->traverse<int, find_empty_loc_ranges_at_text_label> (0);\n   in_first_function_p = false;\n   maybe_at_text_label_p = false;\n }\n@@ -22303,21 +22320,16 @@ static void\n dwarf2out_init (const char *filename ATTRIBUTE_UNUSED)\n {\n   /* Allocate the file_table.  */\n-  file_table = htab_create_ggc (50, file_table_hash,\n-\t\t\t\tfile_table_eq, NULL);\n+  file_table = hash_table<dwarf_file_hasher>::create_ggc (50);\n \n   /* Allocate the decl_die_table.  */\n-  decl_die_table = htab_create_ggc (10, decl_die_table_hash,\n-\t\t\t\t    decl_die_table_eq, NULL);\n+  decl_die_table = hash_table<decl_die_hasher>::create_ggc (10);\n \n   /* Allocate the decl_loc_table.  */\n-  decl_loc_table = htab_create_ggc (10, decl_loc_table_hash,\n-\t\t\t\t    decl_loc_table_eq, NULL);\n+  decl_loc_table = hash_table<decl_loc_hasher>::create_ggc (10);\n \n   /* Allocate the cached_dw_loc_list_table.  */\n-  cached_dw_loc_list_table\n-    = htab_create_ggc (10, cached_dw_loc_list_table_hash,\n-\t\t       cached_dw_loc_list_table_eq, NULL);\n+  cached_dw_loc_list_table = hash_table<dw_loc_list_hasher>::create_ggc (10);\n \n   /* Allocate the initial hunk of the decl_scope_table.  */\n   vec_alloc (decl_scope_table, 256);\n@@ -22450,11 +22462,10 @@ dwarf2out_assembly_start (void)\n    because the indexing code relies on htab_traverse to traverse nodes\n    in the same order for each run. */\n \n-static int\n-index_string (void **h, void *v)\n+int\n+index_string (indirect_string_node **h, unsigned int *index)\n {\n-  struct indirect_string_node *node = (struct indirect_string_node *) *h;\n-  unsigned int *index = (unsigned int *) v;\n+  indirect_string_node *node = *h;\n \n   find_string_form (node);\n   if (node->form == DW_FORM_GNU_str_index && node->refcount > 0)\n@@ -22470,11 +22481,10 @@ index_string (void **h, void *v)\n    htab_traverse.  Output the offset to a string and update the\n    current offset.  */\n \n-static int\n-output_index_string_offset (void **h, void *v)\n+int\n+output_index_string_offset (indirect_string_node **h, unsigned int *offset)\n {\n-  struct indirect_string_node *node = (struct indirect_string_node *) *h;\n-  unsigned int *offset = (unsigned int *) v;\n+  indirect_string_node *node = *h;\n \n   if (node->form == DW_FORM_GNU_str_index && node->refcount > 0)\n     {\n@@ -22491,11 +22501,10 @@ output_index_string_offset (void **h, void *v)\n /* A helper function for dwarf2out_finish called through\n    htab_traverse.  Output the indexed string.  */\n \n-static int\n-output_index_string (void **h, void *v)\n+int\n+output_index_string (indirect_string_node **h, unsigned int *cur_idx)\n {\n-  struct indirect_string_node *node = (struct indirect_string_node *) *h;\n-  unsigned int *cur_idx = (unsigned int *) v;\n+  struct indirect_string_node *node = *h;\n \n   if (node->form == DW_FORM_GNU_str_index && node->refcount > 0)\n     {\n@@ -22511,10 +22520,10 @@ output_index_string (void **h, void *v)\n /* A helper function for dwarf2out_finish called through\n    htab_traverse.  Emit one queued .debug_str string.  */\n \n-static int\n-output_indirect_string (void **h, void *v ATTRIBUTE_UNUSED)\n+int\n+output_indirect_string (indirect_string_node **h, void *)\n {\n-  struct indirect_string_node *node = (struct indirect_string_node *) *h;\n+  struct indirect_string_node *node = *h;\n \n   node->form = find_string_form (node);\n   if (node->form == DW_FORM_strp && node->refcount > 0)\n@@ -22533,33 +22542,30 @@ output_indirect_strings (void)\n {\n   switch_to_section (debug_str_section);\n   if (!dwarf_split_debug_info)\n-    htab_traverse (debug_str_hash, output_indirect_string, NULL);\n+    debug_str_hash->traverse<void *, output_indirect_string> (NULL);\n   else\n     {\n       unsigned int offset = 0;\n       unsigned int cur_idx = 0;\n \n-      htab_traverse (skeleton_debug_str_hash, output_indirect_string, NULL);\n+      skeleton_debug_str_hash->traverse<void *, output_indirect_string> (NULL);\n \n       switch_to_section (debug_str_offsets_section);\n-      htab_traverse_noresize (debug_str_hash,\n-                              output_index_string_offset,\n-                              &offset);\n+      debug_str_hash->traverse_noresize\n+\t<unsigned int *, output_index_string_offset> (&offset);\n       switch_to_section (debug_str_dwo_section);\n-      htab_traverse_noresize (debug_str_hash,\n-                              output_index_string,\n-                              &cur_idx);\n+      debug_str_hash->traverse_noresize<unsigned int *, output_index_string>\n+\t(&cur_idx);\n     }\n }\n \n /* Callback for htab_traverse to assign an index to an entry in the\n    table, and to write that entry to the .debug_addr section.  */\n \n-static int\n-output_addr_table_entry (void **slot, void *data)\n+int\n+output_addr_table_entry (addr_table_entry **slot, unsigned int *cur_index)\n {\n-  addr_table_entry *entry = (addr_table_entry *) *slot;\n-  unsigned int *cur_index = (unsigned int *)data;\n+  addr_table_entry *entry = *slot;\n \n   if (entry->refcount == 0)\n     {\n@@ -22600,11 +22606,12 @@ static void\n output_addr_table (void)\n {\n   unsigned int index = 0;\n-  if (addr_index_table == NULL || htab_size (addr_index_table) == 0)\n+  if (addr_index_table == NULL || addr_index_table->size () == 0)\n     return;\n \n   switch_to_section (debug_addr_section);\n-  htab_traverse_noresize (addr_index_table, output_addr_table_entry, &index);\n+  addr_index_table\n+    ->traverse_noresize<unsigned int *, output_addr_table_entry> (&index);\n }\n \n #if ENABLE_ASSERT_CHECKING\n@@ -22859,10 +22866,10 @@ prune_unused_types_update_strings (dw_die_ref die)\n \tif (s->refcount\n \t    == ((DEBUG_STR_SECTION_FLAGS & SECTION_MERGE) ? 1 : 2))\n \t  {\n-\t    void ** slot;\n-\t    slot = htab_find_slot_with_hash (debug_str_hash, s->str,\n-\t\t\t\t\t     htab_hash_string (s->str),\n-\t\t\t\t\t     INSERT);\n+\t    indirect_string_node **slot\n+\t      = debug_str_hash->find_slot_with_hash (s->str,\n+\t\t\t\t\t\t     htab_hash_string (s->str),\n+\t\t\t\t\t\t     INSERT);\n \t    gcc_assert (*slot == NULL);\n \t    *slot = s;\n \t  }\n@@ -22950,9 +22957,9 @@ prune_unused_types (void)\n     prune_unused_types_mark (base_type, 1);\n \n   if (debug_str_hash)\n-    htab_empty (debug_str_hash);\n+    debug_str_hash->empty ();\n   if (skeleton_debug_str_hash)\n-    htab_empty (skeleton_debug_str_hash);\n+    skeleton_debug_str_hash->empty ();\n   prune_unused_types_prune (comp_unit_die ());\n   for (node = limbo_die_list; node; node = node->next)\n     prune_unused_types_prune (node->die);\n@@ -22969,11 +22976,10 @@ prune_unused_types (void)\n \n /* Set the parameter to true if there are any relative pathnames in\n    the file table.  */\n-static int\n-file_table_relative_p (void ** slot, void *param)\n+int\n+file_table_relative_p (dwarf_file_data **slot, bool *p)\n {\n-  bool *p = (bool *) param;\n-  struct dwarf_file_data *d = (struct dwarf_file_data *) *slot;\n+  struct dwarf_file_data *d = *slot;\n   if (!IS_ABSOLUTE_PATH (d->filename))\n     {\n       *p = true;\n@@ -24222,7 +24228,7 @@ dwarf2out_finish (const char *filename)\n   else if (get_AT (comp_unit_die (), DW_AT_comp_dir) == NULL)\n     {\n       bool p = false;\n-      htab_traverse (file_table, file_table_relative_p, &p);\n+      file_table->traverse<bool *, file_table_relative_p> (&p);\n       if (p)\n \tadd_comp_dir_attribute (comp_unit_die ());\n     }\n@@ -24444,8 +24450,9 @@ dwarf2out_finish (const char *filename)\n       if (addr_index_table != NULL)\n         {\n           unsigned int index = 0;\n-          htab_traverse_noresize (addr_index_table,\n-                                  index_addr_table_entry, &index);\n+          addr_index_table\n+\t    ->traverse_noresize<unsigned int *, index_addr_table_entry>\n+\t    (&index);\n         }\n     }\n \n@@ -24464,7 +24471,7 @@ dwarf2out_finish (const char *filename)\n          skeleton die attrs are added when the skeleton type unit is\n          created, so ensure it is created by this point.  */\n       add_top_level_skeleton_die_attrs (main_comp_unit_die);\n-      htab_traverse_noresize (debug_str_hash, index_string, &index);\n+      debug_str_hash->traverse_noresize<unsigned int *, index_string> (&index);\n     }\n \n   /* Output all of the compilation units.  We put the main one last so that"}, {"sha": "a2a1cf15c33f0dbe185320df82edbe2f417b0110", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=2a22f99cb12d82712dd93cfef808b1cef543601b", "patch": "@@ -1,3 +1,7 @@\n+2014-10-12  Trevor Saunders  <tsaunders@mozilla.com>\n+\n+\t* trans-decl.c, trans.c, trans.h: Use hash_table instead of hashtab.\n+\n 2014-10-11  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n \n \tPR fortran/48979"}, {"sha": "d168bdc6931eca5cadc8d3ff033bb5cb282f9781", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 30, "deletions": 40, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=2a22f99cb12d82712dd93cfef808b1cef543601b", "patch": "@@ -4228,72 +4228,62 @@ gfc_trans_deferred_vars (gfc_symbol * proc_sym, gfc_wrapped_block * block)\n   gfc_add_init_cleanup (block, gfc_finish_block (&tmpblock), NULL_TREE);\n }\n \n-static GTY ((param_is (struct module_htab_entry))) htab_t module_htab;\n-\n-/* Hash and equality functions for module_htab.  */\n-\n-static hashval_t\n-module_htab_do_hash (const void *x)\n+struct module_hasher : ggc_hasher<module_htab_entry *>\n {\n-  return htab_hash_string (((const struct module_htab_entry *)x)->name);\n-}\n+  typedef const char *compare_type;\n \n-static int\n-module_htab_eq (const void *x1, const void *x2)\n-{\n-  return strcmp ((((const struct module_htab_entry *)x1)->name),\n-\t\t (const char *)x2) == 0;\n-}\n+  static hashval_t hash (module_htab_entry *s) { return htab_hash_string (s); }\n+  static bool\n+  equal (module_htab_entry *a, const char *b)\n+  {\n+    return !strcmp (a->name, b);\n+  }\n+};\n+\n+static GTY (()) hash_table<module_hasher> *module_htab;\n \n /* Hash and equality functions for module_htab's decls.  */\n \n-static hashval_t\n-module_htab_decls_hash (const void *x)\n+hashval_t\n+module_decl_hasher::hash (tree t)\n {\n-  const_tree t = (const_tree) x;\n   const_tree n = DECL_NAME (t);\n   if (n == NULL_TREE)\n     n = TYPE_NAME (TREE_TYPE (t));\n   return htab_hash_string (IDENTIFIER_POINTER (n));\n }\n \n-static int\n-module_htab_decls_eq (const void *x1, const void *x2)\n+bool\n+module_decl_hasher::equal (tree t1, const char *x2)\n {\n-  const_tree t1 = (const_tree) x1;\n   const_tree n1 = DECL_NAME (t1);\n   if (n1 == NULL_TREE)\n     n1 = TYPE_NAME (TREE_TYPE (t1));\n-  return strcmp (IDENTIFIER_POINTER (n1), (const char *) x2) == 0;\n+  return strcmp (IDENTIFIER_POINTER (n1), x2) == 0;\n }\n \n struct module_htab_entry *\n gfc_find_module (const char *name)\n {\n-  void **slot;\n-\n   if (! module_htab)\n-    module_htab = htab_create_ggc (10, module_htab_do_hash,\n-\t\t\t\t   module_htab_eq, NULL);\n+    module_htab = hash_table<module_hasher>::create_ggc (10);\n \n-  slot = htab_find_slot_with_hash (module_htab, name,\n-\t\t\t\t   htab_hash_string (name), INSERT);\n+  module_htab_entry **slot\n+    = module_htab->find_slot_with_hash (name, htab_hash_string (name), INSERT);\n   if (*slot == NULL)\n     {\n       module_htab_entry *entry = ggc_cleared_alloc<module_htab_entry> ();\n \n       entry->name = gfc_get_string (name);\n-      entry->decls = htab_create_ggc (10, module_htab_decls_hash,\n-\t\t\t\t      module_htab_decls_eq, NULL);\n-      *slot = (void *) entry;\n+      entry->decls = hash_table<module_decl_hasher>::create_ggc (10);\n+      *slot = entry;\n     }\n-  return (struct module_htab_entry *) *slot;\n+  return *slot;\n }\n \n void\n gfc_module_add_decl (struct module_htab_entry *entry, tree decl)\n {\n-  void **slot;\n   const char *name;\n \n   if (DECL_NAME (decl))\n@@ -4303,10 +4293,11 @@ gfc_module_add_decl (struct module_htab_entry *entry, tree decl)\n       gcc_assert (TREE_CODE (decl) == TYPE_DECL);\n       name = IDENTIFIER_POINTER (TYPE_NAME (TREE_TYPE (decl)));\n     }\n-  slot = htab_find_slot_with_hash (entry->decls, name,\n-\t\t\t\t   htab_hash_string (name), INSERT);\n+  tree *slot\n+    = entry->decls->find_slot_with_hash (name, htab_hash_string (name),\n+\t\t\t\t\t INSERT);\n   if (*slot == NULL)\n-    *slot = (void *) decl;\n+    *slot = decl;\n }\n \n static struct module_htab_entry *cur_module;\n@@ -4485,14 +4476,13 @@ gfc_trans_use_stmts (gfc_namespace * ns)\n       for (rent = use_stmt->rename; rent; rent = rent->next)\n \t{\n \t  tree decl, local_name;\n-\t  void **slot;\n \n \t  if (rent->op != INTRINSIC_NONE)\n \t    continue;\n \n-\t  slot = htab_find_slot_with_hash (entry->decls, rent->use_name,\n-\t\t\t\t\t   htab_hash_string (rent->use_name),\n-\t\t\t\t\t   INSERT);\n+\t\t\t\t\t\t hashval_t hash = htab_hash_string (rent->use_name);\n+\t  tree *slot = entry->decls->find_slot_with_hash (rent->use_name, hash,\n+\t\t\t\t\t\t\t  INSERT);\n \t  if (*slot == NULL)\n \t    {\n \t      gfc_symtree *st;\n@@ -4547,7 +4537,7 @@ gfc_trans_use_stmts (gfc_namespace * ns)\n \t      else\n \t\t{\n \t\t  *slot = error_mark_node;\n-\t\t  htab_clear_slot (entry->decls, slot);\n+\t\t  entry->decls->clear_slot (slot);\n \t\t  continue;\n \t\t}\n \t      *slot = decl;"}, {"sha": "b70702303e49d6d5e7d514c101b36a6e0136891d", "filename": "gcc/fortran/trans.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Ffortran%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Ffortran%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.c?ref=2a22f99cb12d82712dd93cfef808b1cef543601b", "patch": "@@ -1963,7 +1963,7 @@ gfc_generate_module_code (gfc_namespace * ns)\n   entry = gfc_find_module (ns->proc_name->name);\n   if (entry->namespace_decl)\n     /* Buggy sourcecode, using a module before defining it?  */\n-    htab_empty (entry->decls);\n+    entry->decls->empty ();\n   entry->namespace_decl = ns->proc_name->backend_decl;\n \n   gfc_generate_module_vars (ns);"}, {"sha": "465661c390fc9ba1c4fa61185a11318f2576e6de", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=2a22f99cb12d82712dd93cfef808b1cef543601b", "patch": "@@ -575,10 +575,18 @@ void gfc_generate_module_vars (gfc_namespace *);\n /* Get the appropriate return statement for a procedure.  */\n tree gfc_generate_return (void);\n \n-struct GTY(()) module_htab_entry {\n+struct module_decl_hasher : ggc_hasher<tree_node *>\n+{\n+  typedef const char *compare_type;\n+\n+  static hashval_t hash (tree);\n+  static bool equal (tree, const char *);\n+};\n+\n+struct GTY((for_user)) module_htab_entry {\n   const char *name;\n   tree namespace_decl;\n-  htab_t GTY ((param_is (union tree_node))) decls;\n+  hash_table<module_decl_hasher> *GTY (()) decls;\n };\n \n struct module_htab_entry *gfc_find_module (const char *);"}, {"sha": "71b5f0de0aa7315c914e62992c121a0d588ebcdb", "filename": "gcc/function.c", "status": "modified", "additions": 39, "deletions": 53, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=2a22f99cb12d82712dd93cfef808b1cef543601b", "patch": "@@ -108,7 +108,7 @@ static GTY((if_marked (\"ggc_marked_p\"), param_is (struct rtx_def)))\n   htab_t epilogue_insn_hash;\n \f\n \n-htab_t types_used_by_vars_hash = NULL;\n+hash_table<used_type_hasher> *types_used_by_vars_hash = NULL;\n vec<tree, va_gc> *types_used_by_cur_var_decl;\n \n /* Forward declarations.  */\n@@ -540,18 +540,24 @@ struct GTY(()) temp_slot {\n   HOST_WIDE_INT full_size;\n };\n \n-/* A table of addresses that represent a stack slot.  The table is a mapping\n-   from address RTXen to a temp slot.  */\n-static GTY((param_is(struct temp_slot_address_entry))) htab_t temp_slot_address_table;\n-static size_t n_temp_slots_in_use;\n-\n-/* Entry for the above hash table.  */\n-struct GTY(()) temp_slot_address_entry {\n+/* Entry for the below hash table.  */\n+struct GTY((for_user)) temp_slot_address_entry {\n   hashval_t hash;\n   rtx address;\n   struct temp_slot *temp_slot;\n };\n \n+struct temp_address_hasher : ggc_hasher<temp_slot_address_entry *>\n+{\n+  static hashval_t hash (temp_slot_address_entry *);\n+  static bool equal (temp_slot_address_entry *, temp_slot_address_entry *);\n+};\n+\n+/* A table of addresses that represent a stack slot.  The table is a mapping\n+   from address RTXen to a temp slot.  */\n+static GTY(()) hash_table<temp_address_hasher> *temp_slot_address_table;\n+static size_t n_temp_slots_in_use;\n+\n /* Removes temporary slot TEMP from LIST.  */\n \n static void\n@@ -634,46 +640,39 @@ temp_slot_address_compute_hash (struct temp_slot_address_entry *t)\n }\n \n /* Return the hash value for an address -> temp slot mapping.  */\n-static hashval_t\n-temp_slot_address_hash (const void *p)\n+hashval_t\n+temp_address_hasher::hash (temp_slot_address_entry *t)\n {\n-  const struct temp_slot_address_entry *t;\n-  t = (const struct temp_slot_address_entry *) p;\n   return t->hash;\n }\n \n /* Compare two address -> temp slot mapping entries.  */\n-static int\n-temp_slot_address_eq (const void *p1, const void *p2)\n+bool\n+temp_address_hasher::equal (temp_slot_address_entry *t1,\n+\t\t\t    temp_slot_address_entry *t2)\n {\n-  const struct temp_slot_address_entry *t1, *t2;\n-  t1 = (const struct temp_slot_address_entry *) p1;\n-  t2 = (const struct temp_slot_address_entry *) p2;\n   return exp_equiv_p (t1->address, t2->address, 0, true);\n }\n \n /* Add ADDRESS as an alias of TEMP_SLOT to the addess -> temp slot mapping.  */\n static void\n insert_temp_slot_address (rtx address, struct temp_slot *temp_slot)\n {\n-  void **slot;\n   struct temp_slot_address_entry *t = ggc_alloc<temp_slot_address_entry> ();\n   t->address = address;\n   t->temp_slot = temp_slot;\n   t->hash = temp_slot_address_compute_hash (t);\n-  slot = htab_find_slot_with_hash (temp_slot_address_table, t, t->hash, INSERT);\n-  *slot = t;\n+  *temp_slot_address_table->find_slot_with_hash (t, t->hash, INSERT) = t;\n }\n \n /* Remove an address -> temp slot mapping entry if the temp slot is\n    not in use anymore.  Callback for remove_unused_temp_slot_addresses.  */\n-static int\n-remove_unused_temp_slot_addresses_1 (void **slot, void *data ATTRIBUTE_UNUSED)\n+int\n+remove_unused_temp_slot_addresses_1 (temp_slot_address_entry **slot, void *)\n {\n-  const struct temp_slot_address_entry *t;\n-  t = (const struct temp_slot_address_entry *) *slot;\n+  const struct temp_slot_address_entry *t = *slot;\n   if (! t->temp_slot->in_use)\n-    htab_clear_slot (temp_slot_address_table, slot);\n+    temp_slot_address_table->clear_slot (slot);\n   return 1;\n }\n \n@@ -683,11 +682,10 @@ remove_unused_temp_slot_addresses (void)\n {\n   /* Use quicker clearing if there aren't any active temp slots.  */\n   if (n_temp_slots_in_use)\n-    htab_traverse (temp_slot_address_table,\n-\t\t   remove_unused_temp_slot_addresses_1,\n-\t\t   NULL);\n+    temp_slot_address_table->traverse\n+      <void *, remove_unused_temp_slot_addresses_1> (NULL);\n   else\n-    htab_empty (temp_slot_address_table);\n+    temp_slot_address_table->empty ();\n }\n \n /* Find the temp slot corresponding to the object at address X.  */\n@@ -703,8 +701,7 @@ find_temp_slot_from_address (rtx x)\n   tmp.address = x;\n   tmp.temp_slot = NULL;\n   tmp.hash = temp_slot_address_compute_hash (&tmp);\n-  t = (struct temp_slot_address_entry *)\n-    htab_find_with_hash (temp_slot_address_table, &tmp, tmp.hash);\n+  t = temp_slot_address_table->find_with_hash (&tmp, tmp.hash);\n   if (t)\n     return t->temp_slot;\n \n@@ -1195,12 +1192,9 @@ init_temp_slots (void)\n \n   /* Set up the table to map addresses to temp slots.  */\n   if (! temp_slot_address_table)\n-    temp_slot_address_table = htab_create_ggc (32,\n-\t\t\t\t\t       temp_slot_address_hash,\n-\t\t\t\t\t       temp_slot_address_eq,\n-\t\t\t\t\t       NULL);\n+    temp_slot_address_table = hash_table<temp_address_hasher>::create_ggc (32);\n   else\n-    htab_empty (temp_slot_address_table);\n+    temp_slot_address_table->empty ();\n }\n \f\n /* Functions and data structures to keep track of the values hard regs\n@@ -6145,24 +6139,17 @@ hash_types_used_by_vars_entry (const struct types_used_by_vars_entry *entry)\n /* Hash function of the types_used_by_vars_entry hash table.  */\n \n hashval_t\n-types_used_by_vars_do_hash (const void *x)\n+used_type_hasher::hash (types_used_by_vars_entry *entry)\n {\n-  const struct types_used_by_vars_entry *entry =\n-    (const struct types_used_by_vars_entry *) x;\n-\n   return hash_types_used_by_vars_entry (entry);\n }\n \n /*Equality function of the types_used_by_vars_entry hash table.  */\n \n-int\n-types_used_by_vars_eq (const void *x1, const void *x2)\n+bool\n+used_type_hasher::equal (types_used_by_vars_entry *e1,\n+\t\t\t types_used_by_vars_entry *e2)\n {\n-  const struct types_used_by_vars_entry *e1 =\n-    (const struct types_used_by_vars_entry *) x1;\n-  const struct types_used_by_vars_entry *e2 =\n-    (const struct types_used_by_vars_entry *)x2;\n-\n   return (e1->var_decl == e2->var_decl && e1->type == e2->type);\n }\n \n@@ -6173,16 +6160,15 @@ types_used_by_var_decl_insert (tree type, tree var_decl)\n {\n   if (type != NULL && var_decl != NULL)\n     {\n-      void **slot;\n+      types_used_by_vars_entry **slot;\n       struct types_used_by_vars_entry e;\n       e.var_decl = var_decl;\n       e.type = type;\n       if (types_used_by_vars_hash == NULL)\n-\ttypes_used_by_vars_hash =\n-\t  htab_create_ggc (37, types_used_by_vars_do_hash,\n-\t\t\t   types_used_by_vars_eq, NULL);\n-      slot = htab_find_slot_with_hash (types_used_by_vars_hash, &e,\n-\t\t\t\t       hash_types_used_by_vars_entry (&e), INSERT);\n+\ttypes_used_by_vars_hash\n+\t  = hash_table<used_type_hasher>::create_ggc (37);\n+\n+      slot = types_used_by_vars_hash->find_slot (&e, INSERT);\n       if (*slot == NULL)\n \t{\n \t  struct types_used_by_vars_entry *entry;"}, {"sha": "a8d9f6a5135e5df852f06936651099c9d8c365f8", "filename": "gcc/function.h", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=2a22f99cb12d82712dd93cfef808b1cef543601b", "patch": "@@ -703,21 +703,24 @@ extern int virtuals_instantiated;\n /* Nonzero if at least one trampoline has been created.  */\n extern int trampolines_created;\n \n-struct GTY(()) types_used_by_vars_entry {\n+struct GTY((for_user)) types_used_by_vars_entry {\n   tree type;\n   tree var_decl;\n };\n \n+struct used_type_hasher : ggc_hasher<types_used_by_vars_entry *>\n+{\n+  static hashval_t hash (types_used_by_vars_entry *);\n+  static bool equal (types_used_by_vars_entry *, types_used_by_vars_entry *);\n+};\n+\n /* Hash table making the relationship between a global variable\n    and the types it references in its initializer. The key of the\n    entry is a referenced type, and the value is the DECL of the global\n    variable. types_use_by_vars_do_hash and types_used_by_vars_eq below are\n    the hash and equality functions to use for this hash table.  */\n-extern GTY((param_is (struct types_used_by_vars_entry))) htab_t\n-  types_used_by_vars_hash;\n+extern GTY(()) hash_table<used_type_hasher> *types_used_by_vars_hash;\n \n-hashval_t types_used_by_vars_do_hash (const void*);\n-int types_used_by_vars_eq (const void *, const void *);\n void types_used_by_var_decl_insert (tree type, tree var_decl);\n \n /* During parsing of a global variable, this vector contains the types"}, {"sha": "bc88eb8224f13e7ec0f202f7421e6b0f56771cb5", "filename": "gcc/gengtype.c", "status": "modified", "additions": 38, "deletions": 1, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Fgengtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Fgengtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.c?ref=2a22f99cb12d82712dd93cfef808b1cef543601b", "patch": "@@ -648,6 +648,12 @@ create_user_defined_type (const char *type_name, struct fileloc *pos)\n \t  if (is_ptr)\n \t    offset_to_star = star - type_id;\n \n+\t  if (strstr (type_id, \"char*\"))\n+\t    {\n+\t  type_id = strtoken (0, \",>\", &next);\n+\t  continue;\n+\t    }\n+\n \t  char *field_name = xstrdup (type_id);\n \n \t  type_p arg_type;\n@@ -2845,6 +2851,8 @@ walk_type (type_p t, struct walk_type_data *d)\n       ;\n     else if (strcmp (oo->name, \"variable_size\") == 0)\n       ;\n+    else if (strcmp (oo->name, \"for_user\") == 0)\n+      ;\n     else\n       error_at_line (d->line, \"unknown option `%s'\\n\", oo->name);\n \n@@ -3642,7 +3650,6 @@ write_user_func_for_structure_body (type_p s, const char *prefix,\n   oprintf (d->of, \"}\\n\");\n }\n \n-\n /* Emit the user-callable functions needed to mark all the types used\n    by the user structure S.  PREFIX is the prefix to use to\n    distinguish ggc and pch markers.  D contains data needed to pass to\n@@ -3712,6 +3719,8 @@ write_func_for_structure (type_p orig_s, type_p s, type_p *param,\n \n   memset (&d, 0, sizeof (d));\n   d.of = get_output_file_for_structure (s, param);\n+\n+  bool for_user = false;\n   for (opt = s->u.s.opt; opt; opt = opt->next)\n     if (strcmp (opt->name, \"chain_next\") == 0\n \t&& opt->kind == OPTION_STRING)\n@@ -3725,6 +3734,8 @@ write_func_for_structure (type_p orig_s, type_p s, type_p *param,\n     else if (strcmp (opt->name, \"mark_hook\") == 0\n \t     && opt->kind == OPTION_STRING)\n       mark_hook_name = opt->info.string;\n+    else if (strcmp (opt->name, \"for_user\") == 0)\n+      for_user = true;\n   if (chain_prev != NULL && chain_next == NULL)\n     error_at_line (&s->u.s.line, \"chain_prev without chain_next\");\n   if (chain_circular != NULL && chain_next != NULL)\n@@ -3868,6 +3879,12 @@ write_func_for_structure (type_p orig_s, type_p s, type_p *param,\n \n   if (orig_s->kind == TYPE_USER_STRUCT)\n     write_user_marking_functions (orig_s, wtd, &d);\n+\n+  if (for_user)\n+    {\n+      write_user_func_for_structure_body (orig_s, wtd->prefix, &d);\n+      write_user_func_for_structure_ptr (d.of, orig_s, wtd);\n+    }\n }\n \n \n@@ -4244,6 +4261,13 @@ write_local_func_for_structure (const_type_p orig_s, type_p s, type_p *param)\n   /* Write user-callable entry points for the PCH walking routines.  */\n   if (orig_s->kind == TYPE_USER_STRUCT)\n     write_pch_user_walking_functions (s, &d);\n+\n+  for (options_p o = s->u.s.opt; o; o = o->next)\n+    if (strcmp (o->name, \"for_user\") == 0)\n+      {\n+\twrite_pch_user_walking_for_structure_body (s, &d);\n+\tbreak;\n+      }\n }\n \n /* Write out local marker routines for STRUCTURES and PARAM_STRUCTS.  */\n@@ -5690,6 +5714,19 @@ main (int argc, char **argv)\n      hence enlarge the param_structs list of types.  */\n   set_gc_used (variables);\n \n+  for (type_p t = structures; t; t = t->next)\n+    {\n+      bool for_user = false;\n+      for (options_p o = t->u.s.opt; o; o = o->next)\n+\tif (strcmp (o->name, \"for_user\") == 0)\n+\t  {\n+\t    for_user = true;\n+\t    break;\n+\t  }\n+\n+      if (for_user)\n+\tset_gc_used_type (t, GC_POINTED_TO, NULL);\n+    }\n  /* The state at this point is read from the state input file or by\n     parsing source files and optionally augmented by parsing plugin\n     source files.  Write it now.  */"}, {"sha": "dc215207a49303e280ed64813bf538dd840520c8", "filename": "gcc/ggc.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Fggc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Fggc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc.h?ref=2a22f99cb12d82712dd93cfef808b1cef543601b", "patch": "@@ -358,4 +358,9 @@ gt_pch_nx (int)\n {\n }\n \n+static inline void\n+gt_pch_nx (unsigned int)\n+{\n+}\n+\n #endif"}, {"sha": "c0239561787fe94843217a06a34a8d544976b96d", "filename": "gcc/gimple-ssa.h", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Fgimple-ssa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Fgimple-ssa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa.h?ref=2a22f99cb12d82712dd93cfef808b1cef543601b", "patch": "@@ -22,6 +22,7 @@ along with GCC; see the file COPYING3.  If not see\n #define GCC_GIMPLE_SSA_H\n \n #include \"hash-map.h\"\n+#include \"tree-hasher.h\"\n #include \"tree-ssa-operands.h\"\n \n /* This structure is used to map a gimple statement to a label,\n@@ -32,6 +33,25 @@ struct GTY(()) tm_restart_node {\n   tree label_or_list;\n };\n \n+struct ssa_name_hasher : ggc_hasher<tree>\n+{\n+  /* Hash a tree in a uid_decl_map.  */\n+\n+  static hashval_t\n+  hash (tree item)\n+  {\n+    return item->ssa_name.var->decl_minimal.uid;\n+  }\n+\n+  /* Return true if the DECL_UID in both trees are equal.  */\n+\n+  static bool\n+  equal (tree a, tree b)\n+{\n+  return (a->ssa_name.var->decl_minimal.uid == b->ssa_name.var->decl_minimal.uid);\n+}\n+};\n+\n /* Gimple dataflow datastructure. All publicly available fields shall have\n    gimple_ accessor defined, all publicly modifiable fields should have\n    gimple_set accessor.  */\n@@ -63,7 +83,7 @@ struct GTY(()) gimple_df {\n      means that the first reference to this variable in the function is a\n      USE or a VUSE.  In those cases, the SSA renamer creates an SSA name\n      for this variable with an empty defining statement.  */\n-  htab_t GTY((param_is (union tree_node))) default_defs;\n+  hash_table<ssa_name_hasher> *default_defs;\n \n   /* True if there are any symbols that need to be renamed.  */\n   unsigned int ssa_renaming_needed : 1;"}, {"sha": "4988fe4d0377f05adeadc801ab85624c62011653", "filename": "gcc/hash-map.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Fhash-map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Fhash-map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhash-map.h?ref=2a22f99cb12d82712dd93cfef808b1cef543601b", "patch": "@@ -168,6 +168,16 @@ class GTY((user)) hash_map\n \t{\n \t}\n \n+    static void\n+      pch_nx_helper (unsigned int, gt_pointer_operator, void *)\n+\t{\n+\t}\n+\n+    static void\n+      pch_nx_helper (bool, gt_pointer_operator, void *)\n+\t{\n+\t}\n+\n     template<typename T>\n       static void\n       pch_nx_helper (T *&x, gt_pointer_operator op, void *cookie)"}, {"sha": "2493f2e983a26f99b68f9d980452682a8306e024", "filename": "gcc/hash-table.h", "status": "modified", "additions": 60, "deletions": 4, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Fhash-table.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Fhash-table.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhash-table.h?ref=2a22f99cb12d82712dd93cfef808b1cef543601b", "patch": "@@ -198,6 +198,7 @@ along with GCC; see the file COPYING3.  If not see\n \n #include \"ggc.h\"\n #include \"hashtab.h\"\n+#include <new>\n \n template<typename, typename, typename> class hash_map;\n template<typename, typename> class hash_set;\n@@ -301,6 +302,38 @@ pointer_hash <Type>::equal (const value_type &existing,\n   return existing == candidate;\n }\n \n+/* Hasher for entry in gc memory.  */\n+\n+template<typename T>\n+struct ggc_hasher\n+{\n+  typedef T value_type;\n+  typedef T compare_type;\n+  typedef int store_values_directly;\n+\n+  static void remove (T) {}\n+\n+  static void\n+  ggc_mx (T p)\n+  {\n+    extern void gt_ggc_mx (T &);\n+    gt_ggc_mx (p);\n+  }\n+\n+  static void\n+  pch_nx (T &p)\n+  {\n+  extern void gt_pch_nx (T &);\n+  gt_pch_nx (p);\n+  }\n+\n+  static void\n+  pch_nx (T &p, gt_pointer_operator op, void *cookie)\n+  {\n+    op (&p, cookie);\n+  }\n+};\n+\n \n /* Table of primes and their inversion information.  */\n \n@@ -1004,6 +1037,16 @@ class hash_table<Descriptor, Allocator, true>\n   explicit hash_table (size_t, bool ggc = false);\n   ~hash_table ();\n \n+  /* Create a hash_table in gc memory.  */\n+\n+  static hash_table *\n+  create_ggc (size_t n)\n+  {\n+    hash_table *table = ggc_alloc<hash_table> ();\n+    new (table) hash_table (n, true);\n+    return table;\n+  }\n+\n   /* Current size (in entries) of the hash table.  */\n   size_t size () const { return m_size; }\n \n@@ -1110,9 +1153,15 @@ class hash_table<Descriptor, Allocator, true>\n private:\n   template<typename T> friend void gt_ggc_mx (hash_table<T> *);\n   template<typename T> friend void gt_pch_nx (hash_table<T> *);\n-  template<typename T> friend void hashtab_entry_note_pointers (void *, void *, gt_pointer_operator, void *);\n-  template<typename T, typename U, typename V> friend void gt_pch_nx (hash_map<T, U, V> *, gt_pointer_operator, void *);\n-  template<typename T, typename U> friend void gt_pch_nx (hash_set<T, U> *, gt_pointer_operator, void *);\n+  template<typename T> friend void\n+    hashtab_entry_note_pointers (void *, void *, gt_pointer_operator, void *);\n+  template<typename T, typename U, typename V> friend void\n+  gt_pch_nx (hash_map<T, U, V> *, gt_pointer_operator, void *);\n+  template<typename T, typename U> friend void gt_pch_nx (hash_set<T, U> *,\n+\t\t\t\t\t\t\t  gt_pointer_operator,\n+\t\t\t\t\t\t\t  void *);\n+  template<typename T> friend void gt_pch_nx (hash_table<T> *,\n+\t\t\t\t\t      gt_pointer_operator, void *);\n \n   value_type *find_empty_slot_for_expand (hashval_t);\n   void expand ();\n@@ -1598,7 +1647,7 @@ template<typename D>\n static void\n gt_pch_nx (hash_table<D> *h)\n {\n-  bool success ATTRIBUTE_UNUSED\n+  bool success\n     = gt_pch_note_object (h->m_entries, h, hashtab_entry_note_pointers<D>);\n   gcc_checking_assert (success);\n   for (size_t i = 0; i < h->m_size; i++)\n@@ -1611,4 +1660,11 @@ gt_pch_nx (hash_table<D> *h)\n     }\n }\n \n+template<typename D>\n+static inline void\n+gt_pch_nx (hash_table<D> *h, gt_pointer_operator op, void *cookie)\n+{\n+  op (&h->m_entries, cookie);\n+}\n+\n #endif /* TYPED_HASHTAB_H */"}, {"sha": "c9336d341e9cac9db27be049e27678ca9f55d5ac", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=2a22f99cb12d82712dd93cfef808b1cef543601b", "patch": "@@ -1,3 +1,8 @@\n+2014-10-12  Trevor Saunders  <tsaunders@mozilla.com>\n+\n+\t* class.c, decl.c, except.c, expr.c, java-tree.h, lang.c: Use\n+\thash_table instead of hashtab.\n+\n 2014-10-07  Marek Polacek  <polacek@redhat.com>\n \n \t* jvgenmain.c (main): Provide declarations for JvRunMain{,Name}."}, {"sha": "25af6976ed0d1b354fed1ef34fb5044280127efd", "filename": "gcc/java/class.c", "status": "modified", "additions": 18, "deletions": 29, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Fjava%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Fjava%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fclass.c?ref=2a22f99cb12d82712dd93cfef808b1cef543601b", "patch": "@@ -774,7 +774,7 @@ add_method_1 (tree this_class, int access_flags, tree name, tree function_type)\n   /* Initialize the initialized (static) class table. */\n   if (access_flags & ACC_STATIC)\n     DECL_FUNCTION_INITIALIZED_CLASS_TABLE (fndecl) =\n-      htab_create_ggc (50, htab_hash_pointer, htab_eq_pointer, NULL);\n+      hash_table<ict_hasher>::create_ggc (50);\n \n   DECL_CHAIN (fndecl) = TYPE_METHODS (this_class);\n   TYPE_METHODS (this_class) = fndecl;\n@@ -3070,14 +3070,12 @@ build_assertion_table_entry (tree code, tree op1, tree op2)\n /* Add an entry to the type assertion table. Callback used during hashtable\n    traversal.  */\n \n-static int\n-add_assertion_table_entry (void **htab_entry, void *ptr)\n+int\n+add_assertion_table_entry (type_assertion **slot, vec<constructor_elt, va_gc> **v)\n {\n   tree entry;\n   tree code_val, op1_utf8, op2_utf8;\n-  vec<constructor_elt, va_gc> **v\n-      = ((vec<constructor_elt, va_gc> **) ptr);\n-  type_assertion *as = (type_assertion *) *htab_entry;\n+  type_assertion *as = *slot;\n \n   code_val = build_int_cst (NULL_TREE, as->assertion_code);\n \n@@ -3103,11 +3101,12 @@ static tree\n emit_assertion_table (tree klass)\n {\n   tree null_entry, ctor, table_decl;\n-  htab_t assertions_htab = TYPE_ASSERTIONS (klass);\n+  hash_table<type_assertion_hasher> *assertions_htab = TYPE_ASSERTIONS (klass);\n   vec<constructor_elt, va_gc> *v = NULL;\n \n   /* Iterate through the hash table.  */\n-  htab_traverse (assertions_htab, add_assertion_table_entry, &v);\n+  assertions_htab\n+    ->traverse<vec<constructor_elt, va_gc> **, add_assertion_table_entry> (&v);\n \n   /* Finish with a null entry.  */\n   null_entry = build_assertion_table_entry (integer_zero_node,\n@@ -3146,66 +3145,56 @@ init_class_processing (void)\n   gcc_obstack_init (&temporary_obstack);\n }\n \f\n-static hashval_t java_treetreehash_hash (const void *);\n-static int java_treetreehash_compare (const void *, const void *);\n-\n /* A hash table mapping trees to trees.  Used generally.  */\n \n #define JAVA_TREEHASHHASH_H(t) ((hashval_t)TYPE_UID (t))\n \n-static hashval_t\n-java_treetreehash_hash (const void *k_p)\n+hashval_t\n+treetreehasher::hash (treetreehash_entry *k)\n {\n-  const struct treetreehash_entry *const k\n-    = (const struct treetreehash_entry *) k_p;\n   return JAVA_TREEHASHHASH_H (k->key);\n }\n \n-static int\n-java_treetreehash_compare (const void * k1_p, const void * k2_p)\n+bool\n+treetreehasher::equal (treetreehash_entry *k1, tree k2)\n {\n-  const struct treetreehash_entry *const k1\n-    = (const struct treetreehash_entry *) k1_p;\n-  const_tree const k2 = (const_tree) k2_p;\n   return (k1->key == k2);\n }\n \n tree \n-java_treetreehash_find (htab_t ht, tree t)\n+java_treetreehash_find (hash_table<treetreehasher> *ht, tree t)\n {\n   struct treetreehash_entry *e;\n   hashval_t hv = JAVA_TREEHASHHASH_H (t);\n-  e = (struct treetreehash_entry *) htab_find_with_hash (ht, t, hv);\n+  e = ht->find_with_hash (t, hv);\n   if (e == NULL)\n     return NULL;\n   else\n     return e->value;\n }\n \n tree *\n-java_treetreehash_new (htab_t ht, tree t)\n+java_treetreehash_new (hash_table<treetreehasher> *ht, tree t)\n {\n-  void **e;\n   struct treetreehash_entry *tthe;\n   hashval_t hv = JAVA_TREEHASHHASH_H (t);\n \n-  e = htab_find_slot_with_hash (ht, t, hv, INSERT);\n+  treetreehash_entry **e = ht->find_slot_with_hash (t, hv, INSERT);\n   if (*e == NULL)\n     {\n       tthe = ggc_cleared_alloc<treetreehash_entry> ();\n       tthe->key = t;\n       *e = tthe;\n     }\n   else\n-    tthe = (struct treetreehash_entry *) *e;\n+    tthe = *e;\n   return &tthe->value;\n }\n \n-htab_t\n+hash_table<treetreehasher> *\n java_treetreehash_create (size_t size)\n {\n-  return htab_create_ggc (size, java_treetreehash_hash,\n-\t\t\t  java_treetreehash_compare, NULL);\n+  return hash_table<treetreehasher>::create_ggc (size);\n }\n \n /* Break down qualified IDENTIFIER into package and class-name components."}, {"sha": "7271ea70aba334b385d9656ab22e3e79044a9cea", "filename": "gcc/java/decl.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Fjava%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Fjava%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fdecl.c?ref=2a22f99cb12d82712dd93cfef808b1cef543601b", "patch": "@@ -1846,8 +1846,8 @@ end_java_method (void)\n \t variable to the block_body */\n       fbody = DECL_SAVED_TREE (fndecl);\n       block_body = BIND_EXPR_BODY (fbody);\n-      htab_traverse (DECL_FUNCTION_INIT_TEST_TABLE (fndecl),\n-\t\t     attach_init_test_initialization_flags, block_body);\n+      hash_table<treetreehasher> *ht = DECL_FUNCTION_INIT_TEST_TABLE (fndecl);\n+      ht->traverse<tree, attach_init_test_initialization_flags> (block_body);\n     }\n \n   finish_method (fndecl);"}, {"sha": "492e9775855b0fbf5bf7ca9d5f1221026ba2aa24", "filename": "gcc/java/except.c", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Fjava%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Fjava%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexcept.c?ref=2a22f99cb12d82712dd93cfef808b1cef543601b", "patch": "@@ -433,10 +433,10 @@ prepare_eh_table_type (tree type)\n   return exp;\n }\n \n-static int\n-expand_catch_class (void **entry, void *x ATTRIBUTE_UNUSED)\n+int\n+expand_catch_class (treetreehash_entry **entry, int)\n {\n-  struct treetreehash_entry *ite = (struct treetreehash_entry *) *entry;\n+  struct treetreehash_entry *ite = *entry;\n   tree addr = TREE_VALUE ((tree)ite->value);\n   tree decl;\n   STRIP_NOPS (addr);\n@@ -452,9 +452,7 @@ void\n java_expand_catch_classes (tree this_class)\n {\n   if (TYPE_TO_RUNTIME_MAP (this_class))\n-    htab_traverse \n-      (TYPE_TO_RUNTIME_MAP (this_class),\n-       expand_catch_class, NULL);\n+    TYPE_TO_RUNTIME_MAP (this_class)->traverse<int, expand_catch_class> (0);\n }\n \n /* Build and push the variable that will hold the exception object"}, {"sha": "877f1b034ecd8466cf1fbd357d5209ae3427c687", "filename": "gcc/java/expr.c", "status": "modified", "additions": 14, "deletions": 19, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Fjava%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Fjava%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexpr.c?ref=2a22f99cb12d82712dd93cfef808b1cef543601b", "patch": "@@ -398,22 +398,19 @@ pop_type (tree type)\n \f\n /* Return true if two type assertions are equal.  */\n \n-static int\n-type_assertion_eq (const void * k1_p, const void * k2_p)\n+bool\n+type_assertion_hasher::equal (type_assertion *k1, type_assertion *k2)\n {\n-  const type_assertion k1 = *(const type_assertion *)k1_p;\n-  const type_assertion k2 = *(const type_assertion *)k2_p;\n-  return (k1.assertion_code == k2.assertion_code\n-          && k1.op1 == k2.op1\n-\t  && k1.op2 == k2.op2);\n+  return (k1->assertion_code == k2->assertion_code\n+          && k1->op1 == k2->op1\n+\t  && k1->op2 == k2->op2);\n }\n \n /* Hash a type assertion.  */\n \n-static hashval_t\n-type_assertion_hash (const void *p)\n+hashval_t\n+type_assertion_hasher::hash (type_assertion *k_p)\n {\n-  const type_assertion *k_p = (const type_assertion *) p;\n   hashval_t hash = iterative_hash (&k_p->assertion_code, sizeof\n \t\t\t\t   k_p->assertion_code, 0);\n \n@@ -449,30 +446,29 @@ type_assertion_hash (const void *p)\n void\n add_type_assertion (tree klass, int assertion_code, tree op1, tree op2)\n {\n-  htab_t assertions_htab;\n+  hash_table<type_assertion_hasher> *assertions_htab;\n   type_assertion as;\n-  void **as_pp;\n+  type_assertion **as_pp;\n \n   assertions_htab = TYPE_ASSERTIONS (klass);\n   if (assertions_htab == NULL)\n     {\n-      assertions_htab = htab_create_ggc (7, type_assertion_hash, \n-\t\t\t\t\t type_assertion_eq, NULL);\n+      assertions_htab = hash_table<type_assertion_hasher>::create_ggc (7);\n       TYPE_ASSERTIONS (current_class) = assertions_htab;\n     }\n \n   as.assertion_code = assertion_code;\n   as.op1 = op1;\n   as.op2 = op2;\n \n-  as_pp = htab_find_slot (assertions_htab, &as, INSERT);\n+  as_pp = assertions_htab->find_slot (&as, INSERT);\n \n   /* Don't add the same assertion twice.  */\n   if (*as_pp)\n     return;\n \n   *as_pp = ggc_alloc<type_assertion> ();\n-  **(type_assertion **)as_pp = as;\n+  **as_pp = as;\n }\n \n \f\n@@ -1946,10 +1942,9 @@ pop_arguments (tree method_type)\n /* Attach to PTR (a block) the declaration found in ENTRY. */\n \n int\n-attach_init_test_initialization_flags (void **entry, void *ptr)\n+attach_init_test_initialization_flags (treetreehash_entry **slot, tree block)\n {\n-  tree block = (tree)ptr;\n-  struct treetreehash_entry *ite = (struct treetreehash_entry *) *entry;\n+  treetreehash_entry *ite = *slot;\n \n   if (block != error_mark_node)\n     {"}, {"sha": "40b687d7e7caca5eb3399e60b48d6da64d7c7575", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 34, "deletions": 14, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=2a22f99cb12d82712dd93cfef808b1cef543601b", "patch": "@@ -710,6 +710,25 @@ union GTY((desc (\"TREE_CODE (&%h.generic) == IDENTIFIER_NODE\"),\n        && TREE_CODE (TREE_TYPE (NODE)) != POINTER_TYPE) \\\n    || TREE_CODE (NODE) == REAL_CST)\n \n+struct GTY((for_user)) treetreehash_entry {\n+  tree key;\n+  tree value;\n+};\n+\n+struct treetreehasher : ggc_hasher<treetreehash_entry *>\n+{\n+  typedef tree compare_type;\n+\n+  static hashval_t hash (treetreehash_entry *);\n+  static bool equal (treetreehash_entry *, tree);\n+};\n+\n+struct ict_hasher : ggc_hasher<tree_node *>\n+{\n+  static hashval_t hash (tree t) { return htab_hash_pointer (t); }\n+  static bool equal (tree a, tree b) { return a == b; }\n+};\n+\n /* DECL_LANG_SPECIFIC for FUNCTION_DECLs. */\n struct GTY(()) lang_decl_func {\n   /*  tree chain; not yet used. */\n@@ -726,10 +745,10 @@ struct GTY(()) lang_decl_func {\n   tree exc_obj;\t\t\t/* Decl holding the exception object.  */\n \n   /* Class initialization test variables  */\n-  htab_t GTY ((param_is (struct treetreehash_entry))) init_test_table;\n+  hash_table<treetreehasher> *init_test_table;\n \t\t\t\t\n   /* Initialized (static) Class Table */\n-  htab_t GTY ((param_is (union tree_node))) ict;\n+  hash_table<ict_hasher> *ict;\n \n   unsigned int native : 1;\t/* Nonzero if this is a native method  */\n   unsigned int strictfp : 1;\n@@ -742,11 +761,6 @@ struct GTY(()) lang_decl_func {\n   unsigned int varargs : 1;\t/* Varargs method.  */\n };\n \n-struct GTY(()) treetreehash_entry {\n-  tree key;\n-  tree value;\n-};\n-\n /* These represent the possible assertion_codes that can be emitted in the\n    type assertion table.  */\n enum\n@@ -778,15 +792,21 @@ typedef enum\n   JV_ANNOTATION_DEFAULT_KIND\n } jv_attr_kind;\n \n-typedef struct GTY(()) type_assertion {\n+typedef struct GTY((for_user)) type_assertion {\n   int assertion_code; /* 'opcode' for the type of this assertion. */\n   tree op1;           /* First operand. */\n   tree op2;           /* Second operand. */\n } type_assertion;\n \n-extern tree java_treetreehash_find (htab_t, tree);\n-extern tree * java_treetreehash_new (htab_t, tree);\n-extern htab_t java_treetreehash_create (size_t size);\n+struct type_assertion_hasher : ggc_hasher<type_assertion *>\n+{\n+  static hashval_t hash (type_assertion *);\n+  static bool equal (type_assertion *, type_assertion *);\n+};\n+\n+extern tree java_treetreehash_find (hash_table<treetreehasher> *, tree);\n+extern tree * java_treetreehash_new (hash_table<treetreehasher> *, tree);\n+extern hash_table<treetreehasher> *java_treetreehash_create (size_t size);\n \n /* DECL_LANG_SPECIFIC for VAR_DECL, PARM_DECL and sometimes FIELD_DECL\n    (access methods on outer class fields) and final fields. */\n@@ -893,11 +913,11 @@ struct GTY(()) lang_type {\n \t\t\t\t   type matcher.  */\n   vec<constructor_elt, va_gc> *catch_classes;\n \n-  htab_t GTY ((param_is (struct treetreehash_entry))) type_to_runtime_map;   \n+  hash_table<treetreehasher> *type_to_runtime_map;   \n                                 /* The mapping of classes to exception region\n \t\t\t\t   markers.  */\n \n-  htab_t GTY ((param_is (struct type_assertion))) type_assertions;\n+  hash_table<type_assertion_hasher> *type_assertions;\n \t\t\t\t/* Table of type assertions to be evaluated \n   \t\t\t\t   by the runtime when this class is loaded. */\n \n@@ -1013,7 +1033,7 @@ extern void maybe_rewrite_invocation (tree *, vec<tree, va_gc> **, tree *,\n extern tree build_known_method_ref (tree, tree, tree, tree, vec<tree, va_gc> *,\n \t\t\t\t    tree);\n extern tree build_class_init (tree, tree);\n-extern int attach_init_test_initialization_flags (void **, void *);\n+extern int attach_init_test_initialization_flags (treetreehash_entry **, tree);\n extern tree build_invokevirtual (tree, tree, tree);\n extern tree build_invokeinterface (tree, tree);\n extern tree build_jni_stub (tree);"}, {"sha": "7f0b09de3922289236da2615517d099f3b2a23c8", "filename": "gcc/java/lang.c", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Fjava%2Flang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Fjava%2Flang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flang.c?ref=2a22f99cb12d82712dd93cfef808b1cef543601b", "patch": "@@ -57,8 +57,6 @@ static void put_decl_string (const char *, int);\n static void put_decl_node (tree, int);\n static void java_print_error_function (diagnostic_context *, const char *,\n \t\t\t\t       diagnostic_info *);\n-static int merge_init_test_initialization (void * *, void *);\n-static int inline_init_test_initialization (void * *, void *);\n static bool java_dump_tree (void *, tree);\n static void dump_compound_expr (dump_info_p, tree);\n static bool java_decl_ok_for_sibcall (const_tree);\n@@ -713,10 +711,10 @@ decl_constant_value (tree decl)\n /* Create a mapping from a boolean variable in a method being inlined\n    to one in the scope of the method being inlined into.  */\n \n-static int\n-merge_init_test_initialization (void **entry, void *x)\n+int\n+merge_init_test_initialization (treetreehash_entry **entry, void *x)\n {\n-  struct treetreehash_entry *ite = (struct treetreehash_entry *) *entry;\n+  struct treetreehash_entry *ite = *entry;\n   splay_tree decl_map = (splay_tree)x;\n   splay_tree_node n;\n   tree *init_test_decl;\n@@ -761,9 +759,8 @@ merge_init_test_initialization (void **entry, void *x)\n void\n java_inlining_merge_static_initializers (tree fn, void *decl_map)\n {\n-  htab_traverse\n-    (DECL_FUNCTION_INIT_TEST_TABLE (fn),\n-     merge_init_test_initialization, decl_map);\n+    DECL_FUNCTION_INIT_TEST_TABLE (fn)\n+      ->traverse<void *, merge_init_test_initialization> (decl_map);\n }\n \n /* Lookup a DECL_FUNCTION_INIT_TEST_TABLE entry in the method we're\n@@ -772,10 +769,10 @@ java_inlining_merge_static_initializers (tree fn, void *decl_map)\n    from the variable in the inlined class to the corresponding\n    pre-existing one.  */\n \n-static int\n-inline_init_test_initialization (void **entry, void *x)\n+int\n+inline_init_test_initialization (treetreehash_entry **entry, void *x)\n {\n-  struct treetreehash_entry *ite = (struct treetreehash_entry *) *entry;\n+  struct treetreehash_entry *ite = *entry;\n   splay_tree decl_map = (splay_tree)x;\n \n   tree h = java_treetreehash_find\n@@ -796,9 +793,8 @@ inline_init_test_initialization (void **entry, void *x)\n void\n java_inlining_map_static_initializers (tree fn, void *decl_map)\n {\n-  htab_traverse\n-    (DECL_FUNCTION_INIT_TEST_TABLE (fn),\n-     inline_init_test_initialization, decl_map);\n+  DECL_FUNCTION_INIT_TEST_TABLE (fn)\n+    ->traverse<void *, inline_init_test_initialization> (decl_map);\n }\n \n /* Avoid voluminous output for deep recursion of compound exprs.  */"}, {"sha": "ea067bd5df1c59124b1ce5401ea4e820fc80ab29", "filename": "gcc/libfuncs.h", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Flibfuncs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Flibfuncs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibfuncs.h?ref=2a22f99cb12d82712dd93cfef808b1cef543601b", "patch": "@@ -55,19 +55,27 @@ enum libfunc_index\n    We use the same hashtable for normal optabs and conversion optabs.  In\n    the first case mode2 is forced to VOIDmode.  */\n \n-struct GTY(()) libfunc_entry {\n+struct GTY((for_user)) libfunc_entry {\n   int op, mode1, mode2;\n   rtx libfunc;\n };\n \n+/* Descriptor for libfunc_entry.  */\n+\n+struct libfunc_hasher : ggc_hasher<libfunc_entry *>\n+{\n+  static hashval_t hash (libfunc_entry *);\n+  static bool equal (libfunc_entry *, libfunc_entry *);\n+};\n+\n /* Target-dependent globals.  */\n struct GTY(()) target_libfuncs {\n   /* SYMBOL_REF rtx's for the library functions that are called\n      implicitly and not via optabs.  */\n   rtx x_libfunc_table[LTI_MAX];\n \n   /* Hash table used to convert declarations into nodes.  */\n-  htab_t GTY((param_is (struct libfunc_entry))) x_libfunc_hash;\n+  hash_table<libfunc_hasher> *GTY(()) x_libfunc_hash;\n };\n \n extern GTY(()) struct target_libfuncs default_target_libfuncs;"}, {"sha": "6cfbefacfb7c98073aab95ea571cb2e106a5610f", "filename": "gcc/objc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Fobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Fobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FChangeLog?ref=2a22f99cb12d82712dd93cfef808b1cef543601b", "patch": "@@ -1,3 +1,7 @@\n+2014-10-12  Trevor Saunders  <tsaunders@mozilla.com>\n+\n+\t* objc-act.c: use hash_table instead of hashtab.\n+\n 2014-09-15  Jakub Jelinek  <jakub@redhat.com>\n \n \t* Make-lang.in (check_objc_parallelize): Change to just an upper"}, {"sha": "a703c4291e36cce2ae6ffbcb378052ba625cf17d", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=2a22f99cb12d82712dd93cfef808b1cef543601b", "patch": "@@ -253,15 +253,21 @@ vec<tree, va_gc> *local_variables_to_volatilize = NULL;\n /* Store all constructed constant strings in a hash table so that\n    they get uniqued properly.  */\n \n-struct GTY(()) string_descriptor {\n+struct GTY((for_user)) string_descriptor {\n   /* The literal argument .  */\n   tree literal;\n \n   /* The resulting constant string.  */\n   tree constructor;\n };\n \n-static GTY((param_is (struct string_descriptor))) htab_t string_htab;\n+struct objc_string_hasher : ggc_hasher<string_descriptor *>\n+{\n+  static hashval_t hash (string_descriptor *);\n+  static bool equal (string_descriptor *, string_descriptor *);\n+};\n+\n+static GTY(()) hash_table<objc_string_hasher> *string_htab;\n \n FILE *gen_declaration_file;\n \n@@ -3107,10 +3113,10 @@ my_build_string_pointer (int len, const char *str)\n   return build1 (ADDR_EXPR, ptrtype, string);\n }\n \n-static hashval_t\n-string_hash (const void *ptr)\n+hashval_t\n+objc_string_hasher::hash (string_descriptor *ptr)\n {\n-  const_tree const str = ((const struct string_descriptor *)ptr)->literal;\n+  const_tree const str = ptr->literal;\n   const unsigned char *p = (const unsigned char *) TREE_STRING_POINTER (str);\n   int i, len = TREE_STRING_LENGTH (str);\n   hashval_t h = len;\n@@ -3121,11 +3127,11 @@ string_hash (const void *ptr)\n   return h;\n }\n \n-static int\n-string_eq (const void *ptr1, const void *ptr2)\n+bool\n+objc_string_hasher::equal (string_descriptor *ptr1, string_descriptor *ptr2)\n {\n-  const_tree const str1 = ((const struct string_descriptor *)ptr1)->literal;\n-  const_tree const str2 = ((const struct string_descriptor *)ptr2)->literal;\n+  const_tree const str1 = ptr1->literal;\n+  const_tree const str2 = ptr2->literal;\n   int len1 = TREE_STRING_LENGTH (str1);\n \n   return (len1 == TREE_STRING_LENGTH (str2)\n@@ -3147,7 +3153,6 @@ objc_build_string_object (tree string)\n   int length;\n   tree addr;\n   struct string_descriptor *desc, key;\n-  void **loc;\n \n   /* We should be passed a STRING_CST.  */\n   gcc_checking_assert (TREE_CODE (string) == STRING_CST);\n@@ -3198,8 +3203,8 @@ objc_build_string_object (tree string)\n \n   /* Perhaps we already constructed a constant string just like this one? */\n   key.literal = string;\n-  loc = htab_find_slot (string_htab, &key, INSERT);\n-  desc = (struct string_descriptor *) *loc;\n+  string_descriptor **loc = string_htab->find_slot (&key, INSERT);\n+  desc = *loc;\n \n   if (!desc)\n     {\n@@ -5776,8 +5781,7 @@ hash_init (void)\n   alias_name_map = objc_map_alloc_ggc (200);\n \n   /* Initialize the hash table used to hold the constant string objects.  */\n-  string_htab = htab_create_ggc (31, string_hash,\n-\t\t\t\t   string_eq, NULL);\n+  string_htab = hash_table<objc_string_hasher>::create_ggc (31);\n }\n \n /* Use the following to add a method to class_method_map or"}, {"sha": "d55a6bbf8d9a5fa4d4a0bf0a0aa64d180c395dc9", "filename": "gcc/optabs.c", "status": "modified", "additions": 32, "deletions": 38, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=2a22f99cb12d82712dd93cfef808b1cef543601b", "patch": "@@ -29,6 +29,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"insn-config.h\"\n #include \"rtl.h\"\n #include \"tree.h\"\n+#include \"tree-hasher.h\"\n #include \"stor-layout.h\"\n #include \"stringpool.h\"\n #include \"varasm.h\"\n@@ -73,20 +74,17 @@ void debug_optab_libfuncs (void);\n \f\n /* Used for libfunc_hash.  */\n \n-static hashval_t\n-hash_libfunc (const void *p)\n+hashval_t\n+libfunc_hasher::hash (libfunc_entry *e)\n {\n-  const struct libfunc_entry *const e = (const struct libfunc_entry *) p;\n   return ((e->mode1 + e->mode2 * NUM_MACHINE_MODES) ^ e->op);\n }\n \n /* Used for libfunc_hash.  */\n \n-static int\n-eq_libfunc (const void *p, const void *q)\n+bool\n+libfunc_hasher::equal (libfunc_entry *e1, libfunc_entry *e2)\n {\n-  const struct libfunc_entry *const e1 = (const struct libfunc_entry *) p;\n-  const struct libfunc_entry *const e2 = (const struct libfunc_entry *) q;\n   return e1->op == e2->op && e1->mode1 == e2->mode1 && e1->mode2 == e2->mode2;\n }\n \n@@ -109,8 +107,7 @@ convert_optab_libfunc (convert_optab optab, enum machine_mode mode1,\n   e.op = optab;\n   e.mode1 = mode1;\n   e.mode2 = mode2;\n-  slot = (struct libfunc_entry **)\n-    htab_find_slot (libfunc_hash, &e, NO_INSERT);\n+  slot = libfunc_hash->find_slot (&e, NO_INSERT);\n   if (!slot)\n     {\n       const struct convert_optab_libcall_d *d\n@@ -120,8 +117,7 @@ convert_optab_libfunc (convert_optab optab, enum machine_mode mode1,\n \treturn NULL;\n \n       d->libcall_gen (optab, d->libcall_basename, mode1, mode2);\n-      slot = (struct libfunc_entry **)\n-\thtab_find_slot (libfunc_hash, &e, NO_INSERT);\n+      slot = libfunc_hash->find_slot (&e, NO_INSERT);\n       if (!slot)\n \treturn NULL;\n     }\n@@ -146,8 +142,7 @@ optab_libfunc (optab optab, enum machine_mode mode)\n   e.op = optab;\n   e.mode1 = mode;\n   e.mode2 = VOIDmode;\n-  slot = (struct libfunc_entry **)\n-    htab_find_slot (libfunc_hash, &e, NO_INSERT);\n+  slot = libfunc_hash->find_slot (&e, NO_INSERT);\n   if (!slot)\n     {\n       const struct optab_libcall_d *d\n@@ -157,8 +152,7 @@ optab_libfunc (optab optab, enum machine_mode mode)\n \treturn NULL;\n \n       d->libcall_gen (optab, d->libcall_basename, d->libcall_suffix, mode);\n-      slot = (struct libfunc_entry **)\n-\thtab_find_slot (libfunc_hash, &e, NO_INSERT);\n+      slot = libfunc_hash->find_slot (&e, NO_INSERT);\n       if (!slot)\n \treturn NULL;\n     }\n@@ -6100,22 +6094,25 @@ gen_satfractuns_conv_libfunc (convert_optab tab,\n   gen_interclass_conv_libfunc (tab, opname, tmode, fmode);\n }\n \n-/* A table of previously-created libfuncs, hashed by name.  */\n-static GTY ((param_is (union tree_node))) htab_t libfunc_decls;\n-\n /* Hashtable callbacks for libfunc_decls.  */\n \n-static hashval_t\n-libfunc_decl_hash (const void *entry)\n+struct libfunc_decl_hasher : ggc_hasher<tree>\n {\n-  return IDENTIFIER_HASH_VALUE (DECL_NAME ((const_tree) entry));\n-}\n+  static hashval_t\n+  hash (tree entry)\n+  {\n+    return IDENTIFIER_HASH_VALUE (DECL_NAME (entry));\n+  }\n \n-static int\n-libfunc_decl_eq (const void *entry1, const void *entry2)\n-{\n-  return DECL_NAME ((const_tree) entry1) == (const_tree) entry2;\n-}\n+  static bool\n+  equal (tree decl, tree name)\n+  {\n+    return DECL_NAME (decl) == name;\n+  }\n+};\n+\n+/* A table of previously-created libfuncs, hashed by name.  */\n+static GTY (()) hash_table<libfunc_decl_hasher> *libfunc_decls;\n \n /* Build a decl for a libfunc named NAME. */\n \n@@ -6143,18 +6140,16 @@ rtx\n init_one_libfunc (const char *name)\n {\n   tree id, decl;\n-  void **slot;\n   hashval_t hash;\n \n   if (libfunc_decls == NULL)\n-    libfunc_decls = htab_create_ggc (37, libfunc_decl_hash,\n-\t\t\t\t     libfunc_decl_eq, NULL);\n+    libfunc_decls = hash_table<libfunc_decl_hasher>::create_ggc (37);\n \n   /* See if we have already created a libfunc decl for this function.  */\n   id = get_identifier (name);\n   hash = IDENTIFIER_HASH_VALUE (id);\n-  slot = htab_find_slot_with_hash (libfunc_decls, id, hash, INSERT);\n-  decl = (tree) *slot;\n+  tree *slot = libfunc_decls->find_slot_with_hash (id, hash, INSERT);\n+  decl = *slot;\n   if (decl == NULL)\n     {\n       /* Create a new decl, so that it can be passed to\n@@ -6171,12 +6166,11 @@ rtx\n set_user_assembler_libfunc (const char *name, const char *asmspec)\n {\n   tree id, decl;\n-  void **slot;\n   hashval_t hash;\n \n   id = get_identifier (name);\n   hash = IDENTIFIER_HASH_VALUE (id);\n-  slot = htab_find_slot_with_hash (libfunc_decls, id, hash, NO_INSERT);\n+  tree *slot = libfunc_decls->find_slot_with_hash (id, hash, NO_INSERT);\n   gcc_assert (slot);\n   decl = (tree) *slot;\n   set_user_assembler_name (decl, asmspec);\n@@ -6200,7 +6194,7 @@ set_optab_libfunc (optab op, enum machine_mode mode, const char *name)\n     val = init_one_libfunc (name);\n   else\n     val = 0;\n-  slot = (struct libfunc_entry **) htab_find_slot (libfunc_hash, &e, INSERT);\n+  slot = libfunc_hash->find_slot (&e, INSERT);\n   if (*slot == NULL)\n     *slot = ggc_alloc<libfunc_entry> ();\n   (*slot)->op = op;\n@@ -6228,7 +6222,7 @@ set_conv_libfunc (convert_optab optab, enum machine_mode tmode,\n     val = init_one_libfunc (name);\n   else\n     val = 0;\n-  slot = (struct libfunc_entry **) htab_find_slot (libfunc_hash, &e, INSERT);\n+  slot = libfunc_hash->find_slot (&e, INSERT);\n   if (*slot == NULL)\n     *slot = ggc_alloc<libfunc_entry> ();\n   (*slot)->op = optab;\n@@ -6244,9 +6238,9 @@ void\n init_optabs (void)\n {\n   if (libfunc_hash)\n-    htab_empty (libfunc_hash);\n+    libfunc_hash->empty ();\n   else\n-    libfunc_hash = htab_create_ggc (10, hash_libfunc, eq_libfunc, NULL);\n+    libfunc_hash = hash_table<libfunc_hasher>::create_ggc (10);\n \n   /* Fill in the optabs with the insns we support.  */\n   init_all_optabs (this_fn_optabs);"}, {"sha": "f1ac57b5fad06cbba88e0d2b4f83acbe20c14d8b", "filename": "gcc/output.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Foutput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Foutput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foutput.h?ref=2a22f99cb12d82712dd93cfef808b1cef543601b", "patch": "@@ -486,7 +486,7 @@ struct GTY(()) noswitch_section {\n };\n \n /* Information about a section, which may be named or unnamed.  */\n-union GTY ((desc (\"SECTION_STYLE (&(%h))\"))) section {\n+union GTY ((desc (\"SECTION_STYLE (&(%h))\"), for_user)) section {\n   struct section_common GTY ((skip)) common;\n   struct named_section GTY ((tag (\"SECTION_NAMED\"))) named;\n   struct unnamed_section GTY ((tag (\"SECTION_UNNAMED\"))) unnamed;"}, {"sha": "6ce0dce31b5bd62fa7028a1f9f2319295ec50003", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=2a22f99cb12d82712dd93cfef808b1cef543601b", "patch": "@@ -224,7 +224,7 @@ struct GTY(()) block_symbol {\n \n /* Describes a group of objects that are to be placed together in such\n    a way that their relative positions are known.  */\n-struct GTY(()) object_block {\n+struct GTY((for_user)) object_block {\n   /* The section in which these objects should be placed.  */\n   section *sect;\n "}, {"sha": "71a752eab6a9cd5e57df13d1c138177da4f6b201", "filename": "gcc/sese.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Fsese.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Fsese.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsese.c?ref=2a22f99cb12d82712dd93cfef808b1cef543601b", "patch": "@@ -618,9 +618,9 @@ if_region_set_false_region (ifsese if_region, sese region)\n   edge exit_region = SESE_EXIT (region);\n   basic_block before_region = entry_region->src;\n   basic_block last_in_region = exit_region->src;\n-  void **slot = htab_find_slot_with_hash (current_loops->exits, exit_region,\n-\t\t\t\t\t  htab_hash_pointer (exit_region),\n-\t\t\t\t\t  NO_INSERT);\n+  hashval_t hash = htab_hash_pointer (exit_region);\n+  loop_exit **slot\n+    = current_loops->exits->find_slot_with_hash (exit_region, hash, NO_INSERT);\n \n   entry_region->flags = false_edge->flags;\n   false_edge->flags = exit_region->flags;\n@@ -644,11 +644,11 @@ if_region_set_false_region (ifsese if_region, sese region)\n       struct loop_exit *loop_exit = ggc_cleared_alloc<struct loop_exit> ();\n \n       memcpy (loop_exit, *((struct loop_exit **) slot), sizeof (struct loop_exit));\n-      htab_clear_slot (current_loops->exits, slot);\n+      current_loops->exits->clear_slot (slot);\n \n-      slot = htab_find_slot_with_hash (current_loops->exits, false_edge,\n-\t\t\t\t       htab_hash_pointer (false_edge),\n-\t\t\t\t       INSERT);\n+\t\t\t\t\t\t\thashval_t hash = htab_hash_pointer (false_edge);\n+      slot = current_loops->exits->find_slot_with_hash (false_edge, hash,\n+\t\t\t\t\t\t\tINSERT);\n       loop_exit->e = false_edge;\n       *slot = loop_exit;\n       false_edge->src->loop_father->exits->next = loop_exit;"}, {"sha": "d99546f7e986e8688f2c3877a488cb0ae1ce2a83", "filename": "gcc/symtab.c", "status": "modified", "additions": 28, "deletions": 52, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Fsymtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Fsymtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsymtab.c?ref=2a22f99cb12d82712dd93cfef808b1cef543601b", "patch": "@@ -83,15 +83,6 @@ symbol_table::decl_assembler_name_hash (const_tree asmname)\n }\n \n \n-/* Returns a hash code for P.  */\n-\n-hashval_t\n-symbol_table::hash_node_by_assembler_name (const void *p)\n-{\n-  const symtab_node *n = (const symtab_node *) p;\n-  return (hashval_t) decl_assembler_name_hash (DECL_ASSEMBLER_NAME (n->decl));\n-}\n-\n /* Compare ASMNAME with the DECL_ASSEMBLER_NAME of DECL.  */\n \n bool\n@@ -150,14 +141,6 @@ symbol_table::decl_assembler_name_equal (tree decl, const_tree asmname)\n \n /* Returns nonzero if P1 and P2 are equal.  */\n \n-int\n-symbol_table::eq_assembler_name (const void *p1, const void *p2)\n-{\n-  const symtab_node *n1 = (const symtab_node *) p1;\n-  const_tree name = (const_tree)p2;\n-  return (decl_assembler_name_equal (n1->decl, name));\n-}\n-\n /* Insert NODE to assembler name hash.  */\n \n void\n@@ -170,19 +153,18 @@ symbol_table::insert_to_assembler_name_hash (symtab_node *node,\n \t\t       && !node->next_sharing_asm_name);\n   if (assembler_name_hash)\n     {\n-      void **aslot;\n+      symtab_node **aslot;\n       cgraph_node *cnode;\n       tree decl = node->decl;\n \n       tree name = DECL_ASSEMBLER_NAME (node->decl);\n \n-      aslot = htab_find_slot_with_hash (assembler_name_hash, name,\n-\t\t\t\t\tdecl_assembler_name_hash (name),\n-\t\t\t\t\tINSERT);\n+      hashval_t hash = decl_assembler_name_hash (name);\n+      aslot = assembler_name_hash->find_slot_with_hash (name, hash, INSERT);\n       gcc_assert (*aslot != node);\n       node->next_sharing_asm_name = (symtab_node *)*aslot;\n       if (*aslot != NULL)\n-\t((symtab_node *)*aslot)->previous_sharing_asm_name = node;\n+\t(*aslot)->previous_sharing_asm_name = node;\n       *aslot = node;\n \n       /* Update also possible inline clones sharing a decl.  */\n@@ -217,13 +199,13 @@ symbol_table::unlink_from_assembler_name_hash (symtab_node *node,\n       else\n \t{\n \t  tree name = DECL_ASSEMBLER_NAME (node->decl);\n-          void **slot;\n-\t  slot = htab_find_slot_with_hash (assembler_name_hash, name,\n-\t\t\t\t\t   decl_assembler_name_hash (name),\n-\t\t\t\t\t   NO_INSERT);\n+          symtab_node **slot;\n+\t  hashval_t hash = decl_assembler_name_hash (name);\n+\t  slot = assembler_name_hash->find_slot_with_hash (name, hash,\n+\t\t\t\t\t\t\t   NO_INSERT);\n \t  gcc_assert (*slot == node);\n \t  if (!node->next_sharing_asm_name)\n-\t    htab_clear_slot (assembler_name_hash, slot);\n+\t    assembler_name_hash->clear_slot (slot);\n \t  else\n \t    *slot = node->next_sharing_asm_name;\n \t}\n@@ -256,9 +238,7 @@ symbol_table::symtab_initialize_asm_name_hash (void)\n   symtab_node *node;\n   if (!assembler_name_hash)\n     {\n-      assembler_name_hash =\n-\thtab_create_ggc (10, hash_node_by_assembler_name, eq_assembler_name,\n-\t\t\t NULL);\n+      assembler_name_hash = hash_table<asmname_hasher>::create_ggc (10);\n       FOR_EACH_SYMBOL (node)\n \tinsert_to_assembler_name_hash (node, false);\n     }\n@@ -322,20 +302,17 @@ resolution_used_from_other_file_p (enum ld_plugin_symbol_resolution resolution)\n \n /* Hash sections by their names.  */\n \n-static hashval_t\n-hash_section_hash_entry (const void *p)\n+hashval_t\n+section_name_hasher::hash (section_hash_entry *n)\n {\n-  const section_hash_entry *n = (const section_hash_entry *) p;\n   return htab_hash_string (n->name);\n }\n \n /* Return true if section P1 name equals to P2.  */\n \n-static int\n-eq_sections (const void *p1, const void *p2)\n+bool\n+section_name_hasher::equal (section_hash_entry *n1, const char *name)\n {\n-  const section_hash_entry *n1 = (const section_hash_entry *) p1;\n-  const char *name = (const char *)p2;\n   return n1->name == name || !strcmp (n1->name, name);\n }\n \n@@ -936,16 +913,16 @@ symtab_node *\n symtab_node::get_for_asmname (const_tree asmname)\n {\n   symtab_node *node;\n-  void **slot;\n \n   symtab->symtab_initialize_asm_name_hash ();\n-  slot = htab_find_slot_with_hash (symtab->assembler_name_hash, asmname,\n-\t\t\t\t   symtab->decl_assembler_name_hash (asmname),\n-\t\t\t\t   NO_INSERT);\n+  hashval_t hash = symtab->decl_assembler_name_hash (asmname);\n+  symtab_node **slot\n+    = symtab->assembler_name_hash->find_slot_with_hash (asmname, hash,\n+\t\t\t\t\t\t\tNO_INSERT);\n \n   if (slot)\n     {\n-      node = (symtab_node *) *slot;\n+      node = *slot;\n       return node;\n     }\n   return NULL;\n@@ -1382,7 +1359,7 @@ void\n symtab_node::set_section_for_node (const char *section)\n {\n   const char *current = get_section ();\n-  void **slot;\n+  section_hash_entry **slot;\n \n   if (current == section\n       || (current && section\n@@ -1394,11 +1371,11 @@ symtab_node::set_section_for_node (const char *section)\n       x_section->ref_count--;\n       if (!x_section->ref_count)\n \t{\n-\t  slot = htab_find_slot_with_hash (symtab->section_hash, x_section->name,\n-\t\t\t\t\t   htab_hash_string (x_section->name),\n-\t\t\t\t\t   INSERT);\n+\t  hashval_t hash = htab_hash_string (x_section->name);\n+\t  slot = symtab->section_hash->find_slot_with_hash (x_section->name,\n+\t\t\t\t\t\t\t    hash, INSERT);\n \t  ggc_free (x_section);\n-\t  htab_clear_slot (symtab->section_hash, slot);\n+\t  symtab->section_hash->clear_slot (slot);\n \t}\n       x_section = NULL;\n     }\n@@ -1408,11 +1385,10 @@ symtab_node::set_section_for_node (const char *section)\n       return;\n     }\n   if (!symtab->section_hash)\n-    symtab->section_hash = htab_create_ggc (10, hash_section_hash_entry,\n-\t\t\t\t    eq_sections, NULL);\n-  slot = htab_find_slot_with_hash (symtab->section_hash, section,\n-\t\t\t\t   htab_hash_string (section),\n-\t\t\t\t   INSERT);\n+    symtab->section_hash = hash_table<section_name_hasher>::create_ggc (10);\n+  slot = symtab->section_hash->find_slot_with_hash (section,\n+\t\t\t\t\t\t    htab_hash_string (section),\n+\t\t\t\t\t\t    INSERT);\n   if (*slot)\n     x_section = (section_hash_entry *)*slot;\n   else"}, {"sha": "cdab6391bd32df5ba65625fd73482484985f5bda", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=2a22f99cb12d82712dd93cfef808b1cef543601b", "patch": "@@ -6980,11 +6980,12 @@ move_sese_region_to_fn (struct function *dest_cfun, basic_block entry_bb,\n       if (loops_for_fn (saved_cfun)->exits)\n \tFOR_EACH_EDGE (e, ei, bb->succs)\n \t  {\n-\t    void **slot = htab_find_slot_with_hash\n-\t\t(loops_for_fn (saved_cfun)->exits, e,\n-\t\t htab_hash_pointer (e), NO_INSERT);\n+\t    struct loops *l = loops_for_fn (saved_cfun);\n+\t    loop_exit **slot\n+\t      = l->exits->find_slot_with_hash (e, htab_hash_pointer (e),\n+\t\t\t\t\t       NO_INSERT);\n \t    if (slot)\n-\t      htab_clear_slot (loops_for_fn (saved_cfun)->exits, slot);\n+\t      l->exits->clear_slot (slot);\n \t  }\n     }\n "}, {"sha": "9e3902841a980d5dd1fc3b218a4e5c508dcaa1d0", "filename": "gcc/tree-dfa.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Ftree-dfa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Ftree-dfa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dfa.c?ref=2a22f99cb12d82712dd93cfef808b1cef543601b", "patch": "@@ -322,7 +322,7 @@ ssa_default_def (struct function *fn, tree var)\n \t      || TREE_CODE (var) == RESULT_DECL);\n   in.var = (tree)&ind;\n   ind.uid = DECL_UID (var);\n-  return (tree) htab_find_with_hash (DEFAULT_DEFS (fn), &in, DECL_UID (var));\n+  return DEFAULT_DEFS (fn)->find_with_hash ((tree)&in, DECL_UID (var));\n }\n \n /* Insert the pair VAR's UID, DEF into the default_defs hashtable\n@@ -333,7 +333,6 @@ set_ssa_default_def (struct function *fn, tree var, tree def)\n {\n   struct tree_decl_minimal ind;\n   struct tree_ssa_name in;\n-  void **loc;\n \n   gcc_assert (TREE_CODE (var) == VAR_DECL\n \t      || TREE_CODE (var) == PARM_DECL\n@@ -342,25 +341,26 @@ set_ssa_default_def (struct function *fn, tree var, tree def)\n   ind.uid = DECL_UID (var);\n   if (!def)\n     {\n-      loc = htab_find_slot_with_hash (DEFAULT_DEFS (fn), &in,\n-\t\t\t\t      DECL_UID (var), NO_INSERT);\n+      tree *loc = DEFAULT_DEFS (fn)->find_slot_with_hash ((tree)&in,\n+\t\t\t\t\t\t\t  DECL_UID (var),\n+\t\t\t\t\t\t\t  NO_INSERT);\n       if (loc)\n \t{\n \t  SSA_NAME_IS_DEFAULT_DEF (*(tree *)loc) = false;\n-\t  htab_clear_slot (DEFAULT_DEFS (fn), loc);\n+\t  DEFAULT_DEFS (fn)->clear_slot (loc);\n \t}\n       return;\n     }\n   gcc_assert (TREE_CODE (def) == SSA_NAME && SSA_NAME_VAR (def) == var);\n-  loc = htab_find_slot_with_hash (DEFAULT_DEFS (fn), &in,\n-                                  DECL_UID (var), INSERT);\n+  tree *loc = DEFAULT_DEFS (fn)->find_slot_with_hash ((tree)&in,\n+\t\t\t\t\t\t      DECL_UID (var), INSERT);\n \n   /* Default definition might be changed by tail call optimization.  */\n   if (*loc)\n-    SSA_NAME_IS_DEFAULT_DEF (*(tree *) loc) = false;\n+    SSA_NAME_IS_DEFAULT_DEF (*loc) = false;\n \n    /* Mark DEF as the default definition for VAR.  */\n-  *(tree *) loc = def;\n+  *loc = def;\n   SSA_NAME_IS_DEFAULT_DEF (def) = true;\n }\n "}, {"sha": "f05db176f9bbe6123f4dff5e7f3ab411e87a3774", "filename": "gcc/tree-ssa.c", "status": "modified", "additions": 2, "deletions": 21, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Ftree-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Ftree-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.c?ref=2a22f99cb12d82712dd93cfef808b1cef543601b", "patch": "@@ -1055,33 +1055,14 @@ verify_ssa (bool check_modified_stmt, bool check_ssa_operands)\n   internal_error (\"verify_ssa failed\");\n }\n \n-/* Return true if the DECL_UID in both trees are equal.  */\n-\n-static int\n-uid_ssaname_map_eq (const void *va, const void *vb)\n-{\n-  const_tree a = (const_tree) va;\n-  const_tree b = (const_tree) vb;\n-  return (a->ssa_name.var->decl_minimal.uid == b->ssa_name.var->decl_minimal.uid);\n-}\n-\n-/* Hash a tree in a uid_decl_map.  */\n-\n-static unsigned int\n-uid_ssaname_map_hash (const void *item)\n-{\n-  return ((const_tree)item)->ssa_name.var->decl_minimal.uid;\n-}\n-\n \n /* Initialize global DFA and SSA structures.  */\n \n void\n init_tree_ssa (struct function *fn)\n {\n   fn->gimple_df = ggc_cleared_alloc<gimple_df> ();\n-  fn->gimple_df->default_defs = htab_create_ggc (20, uid_ssaname_map_hash,\n-\t\t\t\t                 uid_ssaname_map_eq, NULL);\n+  fn->gimple_df->default_defs = hash_table<ssa_name_hasher>::create_ggc (20);\n   pt_solution_reset (&fn->gimple_df->escaped);\n   init_ssanames (fn, 0);\n }\n@@ -1153,7 +1134,7 @@ delete_tree_ssa (void)\n   if (ssa_operands_active (cfun))\n     fini_ssa_operands (cfun);\n \n-  htab_delete (cfun->gimple_df->default_defs);\n+  cfun->gimple_df->default_defs->empty ();\n   cfun->gimple_df->default_defs = NULL;\n   pt_solution_reset (&cfun->gimple_df->escaped);\n   if (cfun->gimple_df->decls_to_pointers != NULL)"}, {"sha": "abb743b6b8383be3571aeb9a475b88bd04ec86c4", "filename": "gcc/varasm.c", "status": "modified", "additions": 84, "deletions": 89, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a22f99cb12d82712dd93cfef808b1cef543601b/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=2a22f99cb12d82712dd93cfef808b1cef543601b", "patch": "@@ -110,8 +110,6 @@ static int contains_pointers_p (tree);\n static bool incorporeal_function_p (tree);\n #endif\n static void decode_addr_const (tree, struct addr_const *);\n-static hashval_t const_desc_hash (const void *);\n-static int const_desc_eq (const void *, const void *);\n static hashval_t const_hash_1 (const tree);\n static int compare_constant (const tree, const tree);\n static void output_constant_def_contents (rtx);\n@@ -175,11 +173,27 @@ static GTY(()) section *unnamed_sections;\n   ((TREE_CODE (DECL) == FUNCTION_DECL || TREE_CODE (DECL) == VAR_DECL) \\\n    && DECL_SECTION_NAME (DECL) != NULL)\n \n+struct section_hasher : ggc_hasher<section *>\n+{\n+  typedef const char *compare_type;\n+\n+  static hashval_t hash (section *);\n+  static bool equal (section *, const char *);\n+};\n+\n /* Hash table of named sections.  */\n-static GTY((param_is (section))) htab_t section_htab;\n+static GTY(()) hash_table<section_hasher> *section_htab;\n+\n+struct object_block_hasher : ggc_hasher<object_block *>\n+{\n+  typedef const section *compare_type;\n+\n+  static hashval_t hash (object_block *);\n+  static bool equal (object_block *, const section *);\n+};\n \n /* A table of object_blocks, indexed by section.  */\n-static GTY((param_is (struct object_block))) htab_t object_block_htab;\n+static GTY(()) hash_table<object_block_hasher> *object_block_htab;\n \n /* The next number to use for internal anchor labels.  */\n static GTY(()) int anchor_labelno;\n@@ -189,19 +203,15 @@ static GTY(()) struct rtx_constant_pool *shared_constant_pool;\n \n /* Helper routines for maintaining section_htab.  */\n \n-static int\n-section_entry_eq (const void *p1, const void *p2)\n+bool\n+section_hasher::equal (section *old, const char *new_name)\n {\n-  const section *old = (const section *) p1;\n-  const char *new_name = (const char *) p2;\n-\n   return strcmp (old->named.name, new_name) == 0;\n }\n \n-static hashval_t\n-section_entry_hash (const void *p)\n+hashval_t\n+section_hasher::hash (section *old)\n {\n-  const section *old = (const section *) p;\n   return htab_hash_string (old->named.name);\n }\n \n@@ -217,19 +227,15 @@ hash_section (section *sect)\n \n /* Helper routines for maintaining object_block_htab.  */\n \n-static int\n-object_block_entry_eq (const void *p1, const void *p2)\n+inline bool\n+object_block_hasher::equal (object_block *old, const section *new_section)\n {\n-  const struct object_block *old = (const struct object_block *) p1;\n-  const section *new_section = (const section *) p2;\n-\n   return old->sect == new_section;\n }\n \n-static hashval_t\n-object_block_entry_hash (const void *p)\n+hashval_t\n+object_block_hasher::hash (object_block *old)\n {\n-  const struct object_block *old = (const struct object_block *) p;\n   return hash_section (old->sect);\n }\n \n@@ -273,9 +279,8 @@ get_section (const char *name, unsigned int flags, tree decl)\n {\n   section *sect, **slot;\n \n-  slot = (section **)\n-    htab_find_slot_with_hash (section_htab, name,\n-\t\t\t      htab_hash_string (name), INSERT);\n+  slot = section_htab->find_slot_with_hash (name, htab_hash_string (name),\n+\t\t\t\t\t    INSERT);\n   flags |= SECTION_NAMED;\n   if (*slot == NULL)\n     {\n@@ -350,14 +355,14 @@ static struct object_block *\n get_block_for_section (section *sect)\n {\n   struct object_block *block;\n-  void **slot;\n \n   if (sect == NULL)\n     return NULL;\n \n-  slot = htab_find_slot_with_hash (object_block_htab, sect,\n-\t\t\t\t   hash_section (sect), INSERT);\n-  block = (struct object_block *) *slot;\n+  object_block **slot\n+    = object_block_htab->find_slot_with_hash (sect, hash_section (sect),\n+\t\t\t\t\t      INSERT);\n+  block = *slot;\n   if (block == NULL)\n     {\n       block = ggc_cleared_alloc<object_block> ();\n@@ -2824,26 +2829,24 @@ decode_addr_const (tree exp, struct addr_const *value)\n   value->offset = offset;\n }\n \f\n-\n-static GTY((param_is (struct constant_descriptor_tree)))\n-     htab_t const_desc_htab;\n+static GTY(()) hash_table<tree_descriptor_hasher> *const_desc_htab;\n \n static void maybe_output_constant_def_contents (struct constant_descriptor_tree *, int);\n \n /* Constant pool accessor function.  */\n \n-htab_t\n+hash_table<tree_descriptor_hasher> *\n constant_pool_htab (void)\n {\n   return const_desc_htab;\n }\n \n /* Compute a hash code for a constant expression.  */\n \n-static hashval_t\n-const_desc_hash (const void *ptr)\n+hashval_t\n+tree_descriptor_hasher::hash (constant_descriptor_tree *ptr)\n {\n-  return ((const struct constant_descriptor_tree *)ptr)->hash;\n+  return ptr->hash;\n }\n \n static hashval_t\n@@ -2956,13 +2959,10 @@ const_hash_1 (const tree exp)\n }\n \n /* Wrapper of compare_constant, for the htab interface.  */\n-static int\n-const_desc_eq (const void *p1, const void *p2)\n+bool\n+tree_descriptor_hasher::equal (constant_descriptor_tree *c1,\n+\t\t\t       constant_descriptor_tree *c2)\n {\n-  const struct constant_descriptor_tree *const c1\n-    = (const struct constant_descriptor_tree *) p1;\n-  const struct constant_descriptor_tree *const c2\n-    = (const struct constant_descriptor_tree *) p2;\n   if (c1->hash != c2->hash)\n     return 0;\n   return compare_constant (c1->value, c2->value);\n@@ -3264,15 +3264,15 @@ output_constant_def (tree exp, int defer)\n {\n   struct constant_descriptor_tree *desc;\n   struct constant_descriptor_tree key;\n-  void **loc;\n \n   /* Look up EXP in the table of constant descriptors.  If we didn't find\n      it, create a new one.  */\n   key.value = exp;\n   key.hash = const_hash_1 (exp);\n-  loc = htab_find_slot_with_hash (const_desc_htab, &key, key.hash, INSERT);\n+  constant_descriptor_tree **loc\n+    = const_desc_htab->find_slot_with_hash (&key, key.hash, INSERT);\n \n-  desc = (struct constant_descriptor_tree *) *loc;\n+  desc = *loc;\n   if (desc == 0)\n     {\n       desc = build_constant_desc (exp);\n@@ -3387,13 +3387,12 @@ output_constant_def_contents (rtx symbol)\n rtx\n lookup_constant_def (tree exp)\n {\n-  struct constant_descriptor_tree *desc;\n   struct constant_descriptor_tree key;\n \n   key.value = exp;\n   key.hash = const_hash_1 (exp);\n-  desc = (struct constant_descriptor_tree *)\n-    htab_find_with_hash (const_desc_htab, &key, key.hash);\n+  constant_descriptor_tree *desc\n+    = const_desc_htab->find_with_hash (&key, key.hash);\n \n   return (desc ? desc->rtl : NULL_RTX);\n }\n@@ -3407,16 +3406,16 @@ tree\n tree_output_constant_def (tree exp)\n {\n   struct constant_descriptor_tree *desc, key;\n-  void **loc;\n   tree decl;\n \n   /* Look up EXP in the table of constant descriptors.  If we didn't find\n      it, create a new one.  */\n   key.value = exp;\n   key.hash = const_hash_1 (exp);\n-  loc = htab_find_slot_with_hash (const_desc_htab, &key, key.hash, INSERT);\n+  constant_descriptor_tree **loc\n+    = const_desc_htab->find_slot_with_hash (&key, key.hash, INSERT);\n \n-  desc = (struct constant_descriptor_tree *) *loc;\n+  desc = *loc;\n   if (desc == 0)\n     {\n       desc = build_constant_desc (exp);\n@@ -3429,6 +3428,25 @@ tree_output_constant_def (tree exp)\n   return decl;\n }\n \f\n+struct GTY((chain_next (\"%h.next\"), for_user)) constant_descriptor_rtx {\n+  struct constant_descriptor_rtx *next;\n+  rtx mem;\n+  rtx sym;\n+  rtx constant;\n+  HOST_WIDE_INT offset;\n+  hashval_t hash;\n+  enum machine_mode mode;\n+  unsigned int align;\n+  int labelno;\n+  int mark;\n+};\n+\n+struct const_rtx_desc_hasher : ggc_hasher<constant_descriptor_rtx *>\n+{\n+  static hashval_t hash (constant_descriptor_rtx *);\n+  static bool equal (constant_descriptor_rtx *, constant_descriptor_rtx *);\n+};\n+\n /* Used in the hash tables to avoid outputting the same constant\n    twice.  Unlike 'struct constant_descriptor_tree', RTX constants\n    are output once per function, not once per file.  */\n@@ -3445,44 +3463,25 @@ struct GTY(()) rtx_constant_pool {\n      It is used on RISC machines where immediate integer arguments and\n      constant addresses are restricted so that such constants must be stored\n      in memory.  */\n-  htab_t GTY((param_is (struct constant_descriptor_rtx))) const_rtx_htab;\n+  hash_table<const_rtx_desc_hasher> *const_rtx_htab;\n \n   /* Current offset in constant pool (does not include any\n      machine-specific header).  */\n   HOST_WIDE_INT offset;\n };\n \n-struct GTY((chain_next (\"%h.next\"))) constant_descriptor_rtx {\n-  struct constant_descriptor_rtx *next;\n-  rtx mem;\n-  rtx sym;\n-  rtx constant;\n-  HOST_WIDE_INT offset;\n-  hashval_t hash;\n-  enum machine_mode mode;\n-  unsigned int align;\n-  int labelno;\n-  int mark;\n-};\n-\n /* Hash and compare functions for const_rtx_htab.  */\n \n-static hashval_t\n-const_desc_rtx_hash (const void *ptr)\n+hashval_t\n+const_rtx_desc_hasher::hash (constant_descriptor_rtx *desc)\n {\n-  const struct constant_descriptor_rtx *const desc\n-    = (const struct constant_descriptor_rtx *) ptr;\n   return desc->hash;\n }\n \n-static int\n-const_desc_rtx_eq (const void *a, const void *b)\n+bool\n+const_rtx_desc_hasher::equal (constant_descriptor_rtx *x,\n+\t\t\t      constant_descriptor_rtx *y)\n {\n-  const struct constant_descriptor_rtx *const x\n-    = (const struct constant_descriptor_rtx *) a;\n-  const struct constant_descriptor_rtx *const y\n-    = (const struct constant_descriptor_rtx *) b;\n-\n   if (x->mode != y->mode)\n     return 0;\n   return rtx_equal_p (x->constant, y->constant);\n@@ -3585,8 +3584,7 @@ create_constant_pool (void)\n   struct rtx_constant_pool *pool;\n \n   pool = ggc_alloc<rtx_constant_pool> ();\n-  pool->const_rtx_htab = htab_create_ggc (31, const_desc_rtx_hash,\n-\t\t\t\t\t  const_desc_rtx_eq, NULL);\n+  pool->const_rtx_htab = hash_table<const_rtx_desc_hasher>::create_ggc (31);\n   pool->first = NULL;\n   pool->last = NULL;\n   pool->offset = 0;\n@@ -3624,7 +3622,7 @@ force_const_mem (enum machine_mode mode, rtx x)\n   rtx def, symbol;\n   hashval_t hash;\n   unsigned int align;\n-  void **slot;\n+  constant_descriptor_rtx **slot;\n \n   /* If we're not allowed to drop X into the constant pool, don't.  */\n   if (targetm.cannot_force_const_mem (mode, x))\n@@ -3642,8 +3640,8 @@ force_const_mem (enum machine_mode mode, rtx x)\n   tmp.constant = x;\n   tmp.mode = mode;\n   hash = const_rtx_hash (x);\n-  slot = htab_find_slot_with_hash (pool->const_rtx_htab, &tmp, hash, INSERT);\n-  desc = (struct constant_descriptor_rtx *) *slot;\n+  slot = pool->const_rtx_htab->find_slot_with_hash (&tmp, hash, INSERT);\n+  desc = *slot;\n \n   /* If the constant was already present, return its memory.  */\n   if (desc)\n@@ -5923,12 +5921,9 @@ make_decl_one_only (tree decl, tree comdat_group)\n void\n init_varasm_once (void)\n {\n-  section_htab = htab_create_ggc (31, section_entry_hash,\n-\t\t\t\t  section_entry_eq, NULL);\n-  object_block_htab = htab_create_ggc (31, object_block_entry_hash,\n-\t\t\t\t       object_block_entry_eq, NULL);\n-  const_desc_htab = htab_create_ggc (1009, const_desc_hash,\n-\t\t\t\t     const_desc_eq, NULL);\n+  section_htab = hash_table<section_hasher>::create_ggc (31);\n+  object_block_htab = hash_table<object_block_hasher>::create_ggc (31);\n+  const_desc_htab = hash_table<tree_descriptor_hasher>::create_ggc (1009);\n \n   const_alias_set = new_alias_set ();\n   shared_constant_pool = create_constant_pool ();\n@@ -7255,10 +7250,10 @@ output_object_block (struct object_block *block)\n /* A htab_traverse callback used to call output_object_block for\n    each member of object_block_htab.  */\n \n-static int\n-output_object_block_htab (void **slot, void *data ATTRIBUTE_UNUSED)\n+int\n+output_object_block_htab (object_block **slot, void *)\n {\n-  output_object_block ((struct object_block *) (*slot));\n+  output_object_block (*slot);\n   return 1;\n }\n \n@@ -7267,7 +7262,7 @@ output_object_block_htab (void **slot, void *data ATTRIBUTE_UNUSED)\n void\n output_object_blocks (void)\n {\n-  htab_traverse (object_block_htab, output_object_block_htab, NULL);\n+  object_block_htab->traverse<void *, output_object_block_htab> (NULL);\n }\n \n /* This function provides a possible implementation of the"}]}