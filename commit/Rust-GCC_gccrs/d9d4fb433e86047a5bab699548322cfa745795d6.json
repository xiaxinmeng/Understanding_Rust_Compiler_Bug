{"sha": "d9d4fb433e86047a5bab699548322cfa745795d6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDlkNGZiNDMzZTg2MDQ3YTViYWI2OTk1NDgzMjJjZmE3NDU3OTVkNg==", "commit": {"author": {"name": "Alex Samuel", "email": "samuel@gcc.gnu.org", "date": "2000-03-10T08:16:55Z"}, "committer": {"name": "Alex Samuel", "email": "samuel@gcc.gnu.org", "date": "2000-03-10T08:16:55Z"}, "message": "Changes in include:\n\n\t* partition.h: New file.\n\nChanges in libiberty:\n\n\t* Makefile.in (CFILES): Add partition.c.\n\t(REQUIRED_OFILES): Add partition.o.\n\t(partition.o): New rule.\n\t* partition.c: New file.\n\nChanges in gcc:\n\n\t* Makefile.in (ssa.o): New rule.\n\t(OBJS): Add ssa.o.\n\t(STAGESTUFF): Add *.ssa and *.ussa.\n\t(mostlyclean): Delete *.ssa, *.ussa, */*.ssa, */*.ussa.\n\t* rtl.def (PHI): New RTL expression.\n\t* rtl.h (clear_log_links): New declaration.\n\t(convert_to_ssa): Likewise.\n\t(convert_from_ssa): Likewise.\n\t* flow.c (split_edge): If the entry node falls through to the\n\tsplit edge's source block, split the entry edge.\n\t(clear_log_links): New function.\n\t* toplev.c (ssa_dump): New variable.\n\t(flag_ssa): Likewise.\n\t(f_options): Add \"ssa\".\n\t(compile_file): Create SSA dump files.\n\t(rest_of_compilation): Go to and from SSA if enabled.\n\t(decide_d_option): Handle -de for SSA dump files.\n\t* ssa.c: New file.\n\nFrom-SVN: r32465", "tree": {"sha": "03e5dea61e82a209e52f9313b2506ef3fc4b78a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/03e5dea61e82a209e52f9313b2506ef3fc4b78a4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d9d4fb433e86047a5bab699548322cfa745795d6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9d4fb433e86047a5bab699548322cfa745795d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d9d4fb433e86047a5bab699548322cfa745795d6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9d4fb433e86047a5bab699548322cfa745795d6/comments", "author": null, "committer": null, "parents": [{"sha": "ea7f51a4af057b3a231b25fc037417373a5421cd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea7f51a4af057b3a231b25fc037417373a5421cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea7f51a4af057b3a231b25fc037417373a5421cd"}], "stats": {"total": 1908, "additions": 1893, "deletions": 15}, "files": [{"sha": "a5bfcda917c0864094100e062358b6818ed825a4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9d4fb433e86047a5bab699548322cfa745795d6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9d4fb433e86047a5bab699548322cfa745795d6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d9d4fb433e86047a5bab699548322cfa745795d6", "patch": "@@ -1,3 +1,25 @@\n+2000-03-09  Richard Henderson  <rth@cygnus.com>\n+\t    Alex Samuel  <samuel@codesourcery.com> and others\n+\t\n+\t* Makefile.in (ssa.o): New rule.\n+\t(OBJS): Add ssa.o.\n+\t(STAGESTUFF): Add *.ssa and *.ussa.\n+\t(mostlyclean): Delete *.ssa, *.ussa, */*.ssa, */*.ussa.\n+\t* rtl.def (PHI): New RTL expression.\n+\t* rtl.h (clear_log_links): New declaration.\n+\t(convert_to_ssa): Likewise.\n+\t(convert_from_ssa): Likewise.\n+\t* flow.c (split_edge): If the entry node falls through to the\n+\tsplit edge's source block, split the entry edge.\n+\t(clear_log_links): New function.\n+\t* toplev.c (ssa_dump): New variable.\n+\t(flag_ssa): Likewise.\n+\t(f_options): Add \"ssa\".\n+\t(compile_file): Create SSA dump files.\n+\t(rest_of_compilation): Go to and from SSA if enabled.\n+\t(decide_d_option): Handle -de for SSA dump files.\n+\t* ssa.c: New file.\n+\t\n Thu Mar  9 20:01:38 2000  Jim Wilson  <wilson@cygnus.com>\n \n \t* expr.c (expand_assignment): For a CALL_EXPR, special case PARM_DECL"}, {"sha": "88f965ff24b7dacb95287dea56fb0fab5c5aeea2", "filename": "gcc/Makefile.in", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9d4fb433e86047a5bab699548322cfa745795d6/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9d4fb433e86047a5bab699548322cfa745795d6/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=d9d4fb433e86047a5bab699548322cfa745795d6", "patch": "@@ -674,7 +674,7 @@ OBJS = diagnostic.o \\\n  insn-opinit.o insn-recog.o insn-extract.o insn-output.o insn-emit.o lcm.o \\\n  profile.o insn-attrtab.o $(out_object_file) $(EXTRA_OBJS) convert.o \\\n  mbchar.o dyn-string.o splay-tree.o graph.o sbitmap.o resource.o hash.o \\\n- predict.o lists.o ggc-common.o $(GGC) simplify-rtx.o\n+ predict.o lists.o ggc-common.o $(GGC) simplify-rtx.o ssa.o\n \n # GEN files are listed separately, so they can be built before doing parallel\n #  makes for cc1 or cc1plus.  Otherwise sequent parallel make attempts to load\n@@ -704,6 +704,7 @@ STAGESTUFF = *$(objext) insn-flags.h insn-config.h insn-codes.h \\\n  gcov$(exeext) *.bp \\\n  *.greg *.lreg *.combine *.flow *.cse *.jump *.rtl *.tree *.loop \\\n  *.dbr *.jump2 *.sched *.cse2 *.sched2 *.stack *.gcse *.flow2 *.peephole2 \\\n+ *.ssa *.ussa \\\n  *.[si] libcpp.a \\\n  $(LANG_STAGESTUFF)\n \n@@ -1565,6 +1566,8 @@ resource.o : resource.c $(CONFIG_H) $(RTL_H) hard-reg-set.h system.h \\\n    insn-attr.h\n lcm.o : lcm.c $(CONFIG_H) system.h $(RTL_H) $(REGS_H) hard-reg-set.h flags.h \\\n    real.h insn-config.h insn-attr.h $(RECOG_H) $(EXPR_H) $(BASIC_BLOCK_H)\n+ssa.o : ssa.c $(CONFIG_H) system.h $(RTL_H) $(REGS_H) $(BASIC_BLOCK_H) \\\n+   output.h insn-config.h\n profile.o : profile.c $(CONFIG_H) system.h $(RTL_H) flags.h insn-flags.h \\\n    gcov-io.h $(TREE_H) output.h $(REGS_H) toplev.h function.h insn-config.h \\\n    ggc.h\n@@ -2355,11 +2358,11 @@ mostlyclean: $(INTL_MOSTLYCLEAN) lang.mostlyclean\n # Delete debugging dump files.\n \t-rm -f *.greg *.lreg *.combine *.flow *.cse *.jump *.rtl *.tree *.loop\n \t-rm -f *.dbr *.jump2 *.sched *.cse2 *.sched2 *.stack *.addressof\n-\t-rm -f *.regmove *.mach *.bp *.gcse *.flow2 *.peephole2\n+\t-rm -f *.regmove *.mach *.bp *.gcse *.flow2 *.peephole2 *.ssa *.ussa\n \t-rm -f */*.greg */*.lreg */*.combine */*.flow */*.cse */*.jump */*.rtl\n \t-rm -f */*.tree */*.loop */*.dbr */*.jump2 */*.sched */*.cse2\n \t-rm -f */*.sched2 */*.stack */*.regmove */*.gcse */*.flow2\n-\t-rm -f */*.peephole2\n+\t-rm -f */*.peephole2 */*.ssa */*.ussa\n # Delete some files made during installation.\n \t-rm -f specs float.h-* enquire SYSCALLS.c.X SYSCALLS.c\n \t-rm -f collect collect2 mips-tfile mips-tdump alloca.s"}, {"sha": "799114e736308ce1a20691e42d5f19a5be6c0505", "filename": "gcc/flow.c", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9d4fb433e86047a5bab699548322cfa745795d6/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9d4fb433e86047a5bab699548322cfa745795d6/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=d9d4fb433e86047a5bab699548322cfa745795d6", "patch": "@@ -362,6 +362,7 @@ static void fixup_reorder_chain\t\tPARAMS ((void));\n    it being unused. */\n void verify_flow_info\t\t\tPARAMS ((void));\n int flow_loop_outside_edge_p\t\tPARAMS ((const struct loop *, edge));\n+void clear_log_links                    PARAMS ((rtx));\n \f\n /* Find basic blocks of the current function.\n    F is the first insn of the function and NREGS the number of register\n@@ -1369,7 +1370,8 @@ split_edge (edge_in)\n \t  basic_block jump_block;\n \t  rtx pos;\n \n-\t  if ((e->flags & EDGE_CRITICAL) == 0)\n+\t  if ((e->flags & EDGE_CRITICAL) == 0\n+\t      && e->src != ENTRY_BLOCK_PTR)\n \t    {\n \t      /* Non critical -- we can simply add a jump to the end\n \t\t of the existing predecessor.  */\n@@ -7047,7 +7049,6 @@ flow_loop_outside_edge_p (loop, e)\n }\n \n \n-\n typedef struct reorder_block_def {\n   int flags;\n   int index;\n@@ -7769,3 +7770,14 @@ reorder_basic_blocks ()\n   flow_loops_free (&loops_info);\n }\n \n+\n+/* Clear LOG_LINKS fields of insns in a chain.  */\n+void\n+clear_log_links (insns)\n+     rtx insns;\n+{\n+  rtx i;\n+  for (i = insns; i; i = NEXT_INSN (i))\n+    if (GET_RTX_CLASS (GET_CODE (i)) == 'i')\n+      LOG_LINKS (i) = 0;\n+}"}, {"sha": "fd2f13d63d473fe4d8348cf29b0649e390ac2be5", "filename": "gcc/rtl.def", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9d4fb433e86047a5bab699548322cfa745795d6/gcc%2Frtl.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9d4fb433e86047a5bab699548322cfa745795d6/gcc%2Frtl.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.def?ref=d9d4fb433e86047a5bab699548322cfa745795d6", "patch": "@@ -880,6 +880,21 @@ DEF_RTL_EXPR(CONSTANT_P_RTX, \"constant_p_rtx\", \"e\", 'x')\n    after we select a call method.  */\n DEF_RTL_EXPR(CALL_PLACEHOLDER, \"call_placeholder\", \"uuuu\", 'x')\n \n+/* The SSA phi operator. \n+\n+   The argument is a vector of 2N rtxes.  Element 2N+1 is a CONST_INT\n+   containing the block number of the predecessor through which control\n+   has passed when the register at element 2N is used.\n+\n+   Note that PHI may only appear at the beginning of a basic block.\n+\n+   ??? There may be multiple PHI insns, but they are all evaluated\n+   in parallel.  This probably ought to be changed to use a real\n+   PARALLEL, as that would be less confusing and more in the spirit\n+   of canonical RTL.  It is, however, easier to manipulate this way.  */\n+DEF_RTL_EXPR(PHI, \"phi\", \"E\", 'x')\n+\n+\n /*\n Local variables:\n mode:c"}, {"sha": "cdabfdba058e1f2369983ddf42d4961e4fdf444a", "filename": "gcc/rtl.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9d4fb433e86047a5bab699548322cfa745795d6/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9d4fb433e86047a5bab699548322cfa745795d6/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=d9d4fb433e86047a5bab699548322cfa745795d6", "patch": "@@ -1149,6 +1149,7 @@ void free_EXPR_LIST_node \t\tPARAMS ((rtx));\n void free_INSN_LIST_node \t\tPARAMS ((rtx));\n rtx alloc_INSN_LIST\t\t\tPARAMS ((rtx, rtx));\n rtx alloc_EXPR_LIST\t\t\tPARAMS ((int, rtx, rtx));\n+void clear_log_links                    PARAMS ((rtx));\n \n /* regclass.c */\n \n@@ -1710,6 +1711,10 @@ extern rtx addr_side_effect_eval\tPARAMS ((rtx, int, int));\n extern int stack_regs_mentioned\t\tPARAMS ((rtx insn));\n #endif\n \n+/* In ssa.c */\n+extern void convert_to_ssa\t\tPARAMS ((void));\n+extern void convert_from_ssa\t\tPARAMS ((void));\n+\n /* In toplev.c */\n \n extern rtx stack_limit_rtx;"}, {"sha": "7320f8ec7f066bbdc8deeb964c73cf0d5dc7702a", "filename": "gcc/ssa.c", "status": "added", "additions": 1503, "deletions": 0, "changes": 1503, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9d4fb433e86047a5bab699548322cfa745795d6/gcc%2Fssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9d4fb433e86047a5bab699548322cfa745795d6/gcc%2Fssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fssa.c?ref=d9d4fb433e86047a5bab699548322cfa745795d6", "patch": "@@ -0,0 +1,1503 @@\n+/* Static Single Assignment conversion routines for the GNU compiler.\n+   Copyright (C) 2000 Free Software Foundation, Inc.\n+\n+   This file is part of GNU CC.\n+\n+   GNU CC is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 2, or (at your option)\n+   any later version.\n+\n+   GNU CC is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GNU CC; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330,\n+   Boston, MA 02111-1307, USA.  */\n+\n+/* References:\n+\n+   Building an Optimizing Compiler\n+   Robert Morgan\n+   Butterworth-Heinemann, 1998\n+\n+   Static Single Assignment Construction\n+   Preston Briggs, Tim Harvey, Taylor Simpson\n+   Technical Report, Rice University, 1995\n+   ftp://ftp.cs.rice.edu/public/preston/optimizer/SSA.ps.gz\n+*/\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+\n+#include \"rtl.h\"\n+#include \"regs.h\"\n+#include \"hard-reg-set.h\"\n+#include \"flags.h\"\n+#include \"function.h\"\n+#include \"real.h\"\n+#include \"insn-config.h\"\n+#include \"recog.h\"\n+#include \"basic-block.h\"\n+#include \"output.h\"\n+#include \"partition.h\"\n+\n+\n+/* TODO: \n+\n+   ??? What to do about strict_low_part.  Probably I'll have to split\n+   them out of their current instructions first thing.\n+\n+   Actually the best solution may be to have a kind of \"mid-level rtl\"\n+   in which the RTL encodes exactly what we want, without exposing a\n+   lot of niggling processor details.  At some later point we lower\n+   the representation, calling back into optabs to finish any necessary\n+   expansion.\n+*/\n+\n+\n+/* Element I is the single instruction that sets register I+PSEUDO.  */\n+varray_type ssa_definition;\n+\n+/* Element I is an INSN_LIST of instructions that use register I+PSEUDO.  */\n+varray_type ssa_uses;\n+\n+/* Element I-PSEUDO is the normal register that originated the ssa\n+   register in question.  */\n+varray_type ssa_rename_from;\n+\n+/* The running target ssa register for a given normal register.  */\n+static rtx *ssa_rename_to;\n+\n+/* The number of registers that were live on entry to the SSA routines.  */\n+static int ssa_max_reg_num;\n+\n+/* Local function prototypes.  */\n+\n+static inline rtx * phi_alternative\n+  PARAMS ((rtx, int));\n+\n+static int remove_phi_alternative\n+  PARAMS ((rtx, int));\n+static void simplify_to_immediate_dominators \n+  PARAMS ((int *idom, sbitmap *dominators));\n+static void compute_dominance_frontiers_1\n+  PARAMS ((sbitmap *frontiers, int *idom, int bb, sbitmap done));\n+static void compute_dominance_frontiers\n+  PARAMS ((sbitmap *frontiers, int *idom));\n+static void find_evaluations_1\n+  PARAMS ((rtx dest, rtx set, void *data));\n+static void find_evaluations\n+  PARAMS ((sbitmap *evals, int nregs));\n+static void compute_iterated_dominance_frontiers\n+  PARAMS ((sbitmap *idfs, sbitmap *frontiers, sbitmap *evals, int nregs));\n+static void insert_phi_node\n+  PARAMS ((int regno, int b));\n+static void insert_phi_nodes\n+  PARAMS ((sbitmap *idfs, sbitmap *evals, int nregs));\n+static int rename_insn_1 \n+  PARAMS ((rtx *ptr, void *data));\n+static void rename_block \n+  PARAMS ((int b, int *idom));\n+static void rename_registers \n+  PARAMS ((int nregs, int *idom));\n+\n+static inline int ephi_add_node\n+  PARAMS ((rtx reg, rtx *nodes, int *n_nodes));\n+static int * ephi_forward\n+  PARAMS ((int t, sbitmap visited, sbitmap *succ, int *tstack));\n+static void ephi_backward\n+  PARAMS ((int t, sbitmap visited, sbitmap *pred, rtx *nodes));\n+static void ephi_create\n+  PARAMS ((int t, sbitmap visited, sbitmap *pred, sbitmap *succ, rtx *nodes));\n+static void eliminate_phi\n+  PARAMS ((edge e, partition reg_partition));\n+\n+static int make_regs_equivalent_over_bad_edges \n+  PARAMS ((int bb, partition reg_partition));\n+static int make_equivalent_phi_alternatives_equivalent \n+  PARAMS ((int bb, partition reg_partition));\n+static partition compute_conservative_reg_partition \n+  PARAMS (());\n+static int rename_equivalent_regs_in_insn \n+  PARAMS ((rtx *ptr, void *data));\n+static void rename_equivalent_regs \n+  PARAMS ((partition reg_partition));\n+\n+\n+/* Determine if the insn is a PHI node.  */\n+#define PHI_NODE_P(X)\t\t\t\t\\\n+  (X && GET_CODE (X) == INSN\t\t\t\\\n+   && GET_CODE (PATTERN (X)) == SET\t\t\\\n+   && GET_CODE (SET_SRC (PATTERN (X))) == PHI)\n+\n+/* Given the SET of a PHI node, return the address of the alternative\n+   for predecessor block C.  */\n+\n+static inline rtx *\n+phi_alternative (set, c)\n+     rtx set;\n+     int c;\n+{\n+  rtvec phi_vec = XVEC (SET_SRC (set), 0);\n+  int v;\n+\n+  for (v = GET_NUM_ELEM (phi_vec) - 2; v >= 0; v -= 2)\n+    if (INTVAL (RTVEC_ELT (phi_vec, v + 1)) == c)\n+      return &RTVEC_ELT (phi_vec, v);\n+\n+  return NULL;\n+}\n+\n+/* Given the SET of a phi node, remove the alternative for predecessor\n+   block C.  Return non-zero on success, or zero if no alternative is\n+   found for C.  */\n+\n+static int\n+remove_phi_alternative (set, c)\n+     rtx set;\n+     int c;\n+{\n+  rtvec phi_vec = XVEC (SET_SRC (set), 0);\n+  int num_elem = GET_NUM_ELEM (phi_vec);\n+  int v;\n+\n+  for (v = num_elem - 2; v >= 0; v -= 2)\n+    if (INTVAL (RTVEC_ELT (phi_vec, v + 1)) == c)\n+      {\n+\tif (v < num_elem - 2)\n+\t  {\n+\t    RTVEC_ELT (phi_vec, v) = RTVEC_ELT (phi_vec, num_elem - 2);\n+\t    RTVEC_ELT (phi_vec, v + 1) = RTVEC_ELT (phi_vec, num_elem - 1);\n+\t  }\n+\tPUT_NUM_ELEM (phi_vec, num_elem - 2);\n+\treturn 1;\n+      }\n+\n+  return 0;\n+}\n+\n+/* Computing the Immediate Dominators:\n+\n+   Throughout, we don't actually want the full dominators set as\n+   calculated by flow, but rather the immediate dominators.\n+*/\n+\n+static void\n+simplify_to_immediate_dominators (idom, dominators)\n+     int *idom;\n+     sbitmap *dominators;\n+{\n+  sbitmap *tmp;\n+  int b;\n+\n+  tmp = sbitmap_vector_alloc (n_basic_blocks, n_basic_blocks);\n+\n+  /* Begin with tmp(n) = dom(n) - { n }.  */\n+  for (b = n_basic_blocks; --b >= 0; )\n+    {\n+      sbitmap_copy (tmp[b], dominators[b]);\n+      RESET_BIT (tmp[b], b);\n+    }\n+\n+  /* Subtract out all of our dominator's dominators.  */\n+  for (b = n_basic_blocks; --b >= 0; )\n+    {\n+      sbitmap tmp_b = tmp[b];\n+      int s;\n+\n+      for (s = n_basic_blocks; --s >= 0; )\n+\tif (TEST_BIT (tmp_b, s))\n+\t  sbitmap_difference (tmp_b, tmp_b, tmp[s]);\n+    }\n+\n+  /* Find the one bit set in the bitmap and put it in the output array.  */\n+  for (b = n_basic_blocks; --b >= 0; )\n+    {\n+      int t;\n+      EXECUTE_IF_SET_IN_SBITMAP (tmp[b], 0, t, { idom[b] = t; });\n+    }\n+\n+  sbitmap_vector_free (tmp);\n+}\n+\n+\n+/* For all registers, find all blocks in which they are set.\n+\n+   This is the transform of what would be local kill information that\n+   we ought to be getting from flow.  */\n+\n+static sbitmap *fe_evals;\n+static int fe_current_bb;\n+\n+static void\n+find_evaluations_1 (dest, set, data)\n+     rtx dest;\n+     rtx set ATTRIBUTE_UNUSED;\n+     void *data ATTRIBUTE_UNUSED;\n+{\n+  if (GET_CODE (dest) == REG\n+      && REGNO (dest) >= FIRST_PSEUDO_REGISTER)\n+    SET_BIT (fe_evals[REGNO (dest) - FIRST_PSEUDO_REGISTER], fe_current_bb);\n+}\n+\n+static void\n+find_evaluations (evals, nregs)\n+     sbitmap *evals;\n+     int nregs;\n+{\n+  int bb;\n+\n+  sbitmap_vector_zero (evals, nregs);\n+  fe_evals = evals;\n+\n+  for (bb = n_basic_blocks; --bb >= 0; )\n+    {\n+      rtx p, last;\n+\n+      fe_current_bb = bb;\n+      p = BLOCK_HEAD (bb);\n+      last = BLOCK_END (bb);\n+      while (1)\n+\t{\n+\t  if (GET_RTX_CLASS (GET_CODE (p)) == 'i')\n+\t    note_stores (PATTERN (p), find_evaluations_1, NULL);\n+\n+\t  if (p == last)\n+\t    break;\n+\t  p = NEXT_INSN (p);\n+\t}\n+    }\n+}\n+\n+\n+/* Computing the Dominance Frontier:\n+  \n+   As decribed in Morgan, section 3.5, this may be done simply by \n+   walking the dominator tree bottom-up, computing the frontier for\n+   the children before the parent.  When considering a block B,\n+   there are two cases:\n+\n+   (1) A flow graph edge leaving B that does not lead to a child\n+   of B in the dominator tree must be a block that is either equal\n+   to B or not dominated by B.  Such blocks belong in the frontier\n+   of B.\n+\n+   (2) Consider a block X in the frontier of one of the children C\n+   of B.  If X is not equal to B and is not dominated by B, it\n+   is in the frontier of B.\n+*/\n+\n+static void\n+compute_dominance_frontiers_1 (frontiers, idom, bb, done)\n+     sbitmap *frontiers;\n+     int *idom;\n+     int bb;\n+     sbitmap done;\n+{\n+  basic_block b = BASIC_BLOCK (bb);\n+  edge e;\n+  int c;\n+\n+  SET_BIT (done, bb);\n+  sbitmap_zero (frontiers[bb]);\n+\n+  /* Do the frontier of the children first.  Not all children in the\n+     dominator tree (blocks dominated by this one) are children in the\n+     CFG, so check all blocks.  */\n+  for (c = 0; c < n_basic_blocks; ++c)\n+    if (idom[c] == bb && ! TEST_BIT (done, c))\n+      compute_dominance_frontiers_1 (frontiers, idom, c, done);\n+\n+  /* Find blocks conforming to rule (1) above.  */\n+  for (e = b->succ; e; e = e->succ_next)\n+    {\n+      if (e->dest == EXIT_BLOCK_PTR)\n+\tcontinue;\n+      if (idom[e->dest->index] != bb)\n+\tSET_BIT (frontiers[bb], e->dest->index);\n+    }\n+\n+  /* Find blocks conforming to rule (2).  */\n+  for (c = 0; c < n_basic_blocks; ++c)\n+    if (idom[c] == bb)\n+      {\n+\tint x;\n+\tEXECUTE_IF_SET_IN_SBITMAP (frontiers[c], 0, x,\n+\t  {\n+\t    if (idom[x] != bb)\n+\t      SET_BIT (frontiers[bb], x);\n+\t  });\n+      }\n+}\n+\n+static void\n+compute_dominance_frontiers (frontiers, idom)\n+     sbitmap *frontiers;\n+     int *idom;\n+{\n+  sbitmap done = sbitmap_alloc (n_basic_blocks);\n+  sbitmap_zero (done);\n+\n+  compute_dominance_frontiers_1 (frontiers, idom, 0, done);\n+\n+  sbitmap_free (done);\n+}\n+\n+\n+/* Computing the Iterated Dominance Frontier:\n+\n+   This is the set of merge points for a given register.\n+\n+   This is not particularly intuitive.  See section 7.1 of Morgan, in\n+   particular figures 7.3 and 7.4 and the immediately surrounding text.\n+*/\n+\n+static void\n+compute_iterated_dominance_frontiers (idfs, frontiers, evals, nregs)\n+     sbitmap *idfs;\n+     sbitmap *frontiers;\n+     sbitmap *evals;\n+     int nregs;\n+{\n+  sbitmap worklist;\n+  int reg, passes = 0;\n+\n+  worklist = sbitmap_alloc (n_basic_blocks);\n+\n+  for (reg = 0; reg < nregs; ++reg)\n+    {\n+      sbitmap idf = idfs[reg];\n+      int b, changed;\n+\n+      /* Start the iterative process by considering those blocks that\n+\t evaluate REG.  We'll add their dominance frontiers to the\n+\t IDF, and then consider the blocks we just added.  */\n+      sbitmap_copy (worklist, evals[reg]);\n+\n+      /* Morgan's algorithm is incorrect here.  Blocks that evaluate\n+\t REG aren't necessarily in REG's IDF.  Start with an empty IDF.  */\n+      sbitmap_zero (idf);\n+\n+      /* Iterate until the worklist is empty.  */\n+      do\n+\t{\n+\t  changed = 0;\n+\t  passes++;\n+\t  EXECUTE_IF_SET_IN_SBITMAP (worklist, 0, b,\n+\t    {\n+\t      RESET_BIT (worklist, b);\n+\t      /* For each block on the worklist, add to the IDF all\n+\t\t blocks on its dominance frontier that aren't already\n+\t\t on the IDF.  Every block that's added is also added\n+\t\t to the worklist.  */\n+\t      sbitmap_union_of_diff (worklist, worklist, frontiers[b], idf);\n+\t      sbitmap_a_or_b (idf, idf, frontiers[b]);\n+\t      changed = 1;\n+\t    });\n+\t}\n+      while (changed);\n+    }\n+\n+  sbitmap_free (worklist);\n+\n+  if (rtl_dump_file)\n+    {\n+      fprintf(rtl_dump_file,\n+\t      \"Iterated dominance frontier: %d passes on %d regs.\\n\",\n+\t      passes, nregs);\n+    }\n+}\n+\n+\n+/* Insert the phi nodes.  */\n+\n+static void\n+insert_phi_node (regno, bb)\n+     int regno, bb;\n+{\n+  basic_block b = BASIC_BLOCK (bb);\n+  edge e;\n+  int npred, i;\n+  rtvec vec;\n+  rtx phi, reg;\n+\n+  /* Find out how many predecessors there are.  */\n+  for (e = b->pred, npred = 0; e; e = e->pred_next)\n+    if (e->src != ENTRY_BLOCK_PTR)\n+      npred++;\n+\n+  /* If this block has no \"interesting\" preds, then there is nothing to\n+     do.  Consider a block that only has the entry block as a pred.  */\n+  if (npred == 0)\n+    return;\n+\n+  /* This is the register to which the phi function will be assinged.  */\n+  reg = regno_reg_rtx[regno + FIRST_PSEUDO_REGISTER];\n+\n+  /* Construct the arguments to the PHI node.  The use of pc_rtx is just\n+     a placeholder; we'll insert the proper value in rename_registers.  */\n+  vec = rtvec_alloc (npred * 2);\n+  for (e = b->pred, i = 0; e ; e = e->pred_next, i += 2)\n+    if (e->src != ENTRY_BLOCK_PTR)\n+      {\n+\tRTVEC_ELT (vec, i + 0) = pc_rtx;\n+\tRTVEC_ELT (vec, i + 1) = GEN_INT (e->src->index);\n+      }\n+\n+  phi = gen_rtx_PHI (VOIDmode, vec);\n+  phi = gen_rtx_SET (VOIDmode, reg, phi);\n+\n+  if (GET_CODE (b->head) == CODE_LABEL)\n+    emit_insn_after (phi, b->head);\n+  else\n+    b->head = emit_insn_before (phi, b->head);\n+}\n+\n+\n+static void\n+insert_phi_nodes (idfs, evals, nregs)\n+     sbitmap *idfs;\n+     sbitmap *evals ATTRIBUTE_UNUSED;\n+     int nregs;\n+{\n+  int reg;\n+\n+  for (reg = 0; reg < nregs; ++reg)\n+    {\n+      int b;\n+      EXECUTE_IF_SET_IN_SBITMAP (idfs[reg], 0, b,\n+\t{\n+\t  if (REGNO_REG_SET_P (BASIC_BLOCK (b)->global_live_at_start, \n+\t\t\t       reg + FIRST_PSEUDO_REGISTER))\n+\t    insert_phi_node (reg, b);\n+\t});\n+    }\n+}\n+\n+/* Rename the registers to conform to SSA. \n+\n+   This is essentially the algorithm presented in Figure 7.8 of Morgan,\n+   with a few changes to reduce pattern search time in favour of a bit\n+   more memory usage.  */\n+\n+\n+/* One of these is created for each set.  It will live in a list local\n+   to its basic block for the duration of that block's processing.  */\n+struct rename_set_data\n+{\n+  struct rename_set_data *next;\n+  rtx *reg_loc;\n+  rtx set_dest;\n+  rtx new_reg;\n+  rtx prev_reg;\n+};\n+\n+static void new_registers_for_updates \n+  PARAMS ((struct rename_set_data *set_data,\n+\t   struct rename_set_data *old_set_data, rtx insn));\n+\n+/* This is part of a rather ugly hack to allow the pre-ssa regno to be\n+   reused.  If, during processing, a register has not yet been touched,\n+   ssa_rename_to[regno] will be NULL.  Now, in the course of pushing\n+   and popping values from ssa_rename_to, when we would ordinarily \n+   pop NULL back in, we pop RENAME_NO_RTX.  We treat this exactly the\n+   same as NULL, except that it signals that the original regno has\n+   already been reused.  */\n+#define RENAME_NO_RTX  pc_rtx\n+\n+/* Part one of the first step of rename_block, called through for_each_rtx. \n+   Mark pseudos that are set for later update.  Transform uses of pseudos.  */\n+\n+static int\n+rename_insn_1 (ptr, data)\n+     rtx *ptr;\n+     void *data;\n+{\n+  rtx x = *ptr;\n+  struct rename_set_data **set_datap = data;\n+\n+  if (x == NULL_RTX)\n+    return 0;\n+\n+  switch (GET_CODE (x))\n+    {\n+    case SET:\n+      {\n+\trtx *destp = &SET_DEST (x);\n+\trtx dest = SET_DEST (x);\n+\n+\t/* Subregs at word 0 are interesting.  Subregs at word != 0 are\n+\t   presumed to be part of a contiguous multi-word set sequence.  */\n+\twhile (GET_CODE (dest) == SUBREG\n+\t       && SUBREG_WORD (dest) == 0)\n+\t  {\n+\t    destp = &SUBREG_REG (dest);\n+\t    dest = SUBREG_REG (dest);\n+\t  }\n+\n+\tif (GET_CODE (dest) == REG\n+\t    && REGNO (dest) >= FIRST_PSEUDO_REGISTER)\n+\t  {\n+\t    /* We found a genuine set of an interesting register.  Tag\n+\t       it so that we can create a new name for it after we finish\n+\t       processing this insn.  */\n+\n+\t    struct rename_set_data *r;\n+\t    r = (struct rename_set_data *) xmalloc (sizeof(*r));\n+\n+\t    r->reg_loc = destp;\n+\t    r->set_dest = SET_DEST (x);\n+\t    r->next = *set_datap;\n+\t    *set_datap = r;\n+\n+\t    /* Since we do not wish to (directly) traverse the\n+\t       SET_DEST, recurse through for_each_rtx for the SET_SRC\n+\t       and return.  */\n+\t    for_each_rtx (&SET_SRC (x), rename_insn_1, data);\n+\t    return -1;\n+\t  }\n+\n+\t/* Otherwise, this was not an interesting destination.  Continue\n+\t   on, marking uses as normal.  */\n+\treturn 0;\n+      }\n+\n+    case REG:\n+      if (REGNO (x) >= FIRST_PSEUDO_REGISTER\n+\t  && REGNO (x) < ssa_max_reg_num)\n+\t{\n+\t  rtx new_reg = ssa_rename_to[REGNO(x) - FIRST_PSEUDO_REGISTER];\n+\n+\t  if (new_reg != NULL_RTX && new_reg != RENAME_NO_RTX)\n+\t    {\n+\t      if (GET_MODE (x) != GET_MODE (new_reg))\n+\t\tabort ();\n+\t      *ptr = new_reg;\n+\t      /* ??? Mark for a new ssa_uses entry.  */\n+\t    }\n+\t  /* Else this is a use before a set.  Warn?  */\n+\t}\n+      return -1;\n+\n+    case PHI:\n+      /* Never muck with the phi.  We do that elsewhere, special-like.  */\n+      return -1;\n+\n+    default:\n+      /* Anything else, continue traversing.  */\n+      return 0;\n+    }\n+}\n+\n+/* Second part of the first step of rename_block.  The portion of the list\n+   beginning at SET_DATA through OLD_SET_DATA contain the sets present in\n+   INSN.  Update data structures accordingly.  */\n+\n+static void\n+new_registers_for_updates (set_data, old_set_data, insn)\n+     struct rename_set_data *set_data, *old_set_data;\n+     rtx insn;\n+{\n+  while (set_data != old_set_data)\n+    {\n+      int regno, new_regno;\n+      rtx old_reg, new_reg, prev_reg;\n+\n+      old_reg = *set_data->reg_loc;\n+      regno = REGNO (*set_data->reg_loc);\n+\n+      /* For the first set we come across, reuse the original regno.  */\n+      if (ssa_rename_to[regno - FIRST_PSEUDO_REGISTER] == NULL_RTX)\n+\t{\n+\t  new_reg = old_reg;\n+\t  prev_reg = RENAME_NO_RTX;\n+\t}\n+      else\n+\t{\n+\t  prev_reg = ssa_rename_to[regno - FIRST_PSEUDO_REGISTER];\n+\t  new_reg = gen_reg_rtx (GET_MODE (old_reg));\n+\t}\n+\n+      set_data->new_reg = new_reg;\n+      set_data->prev_reg = prev_reg;\n+      new_regno = REGNO (new_reg);\n+      ssa_rename_to[regno - FIRST_PSEUDO_REGISTER] = new_reg;\n+\n+      if (new_regno >= (int) ssa_definition->num_elements)\n+\t{\n+\t  int new_limit = new_regno * 5 / 4;\n+\t  ssa_definition = VARRAY_GROW (ssa_definition, new_limit);\n+\t  ssa_uses = VARRAY_GROW (ssa_uses, new_limit);\n+\t  ssa_rename_from = VARRAY_GROW (ssa_rename_from, new_limit);\n+\t}\n+\n+      VARRAY_RTX (ssa_definition, new_regno) = insn;\n+      VARRAY_RTX (ssa_rename_from, new_regno) = old_reg;\n+\n+      set_data = set_data->next;\n+    }\n+}\n+\n+static void\n+rename_block (bb, idom)\n+     int bb;\n+     int *idom;\n+{\n+  basic_block b = BASIC_BLOCK (bb);\n+  edge e;\n+  rtx insn, next, last;\n+  struct rename_set_data *set_data = NULL;\n+  int c;\n+\n+  /* Step One: Walk the basic block, adding new names for sets and\n+     replacing uses.  */\n+     \n+  next = b->head;\n+  last = b->end;\n+  do\n+    {\n+      insn = next;\n+      if (GET_RTX_CLASS (GET_CODE (insn)) == 'i')\n+\t{\n+\t  struct rename_set_data *old_set_data = set_data;\n+\n+\t  for_each_rtx (&PATTERN (insn), rename_insn_1, &set_data);\n+\t  for_each_rtx (&REG_NOTES (insn), rename_insn_1, &set_data);\n+\t  \n+\t  new_registers_for_updates (set_data, old_set_data, insn);\n+\t}\n+\n+      next = NEXT_INSN (insn);\n+    }\n+  while (insn != last);\n+\n+  /* Step Two: Update the phi nodes of this block's successors.  */\n+\n+  for (e = b->succ; e; e = e->succ_next)\n+    {\n+      if (e->dest == EXIT_BLOCK_PTR)\n+\tcontinue;\n+\n+      insn = e->dest->head;\n+      if (GET_CODE (insn) == CODE_LABEL)\n+\tinsn = NEXT_INSN (insn);\n+\n+      while (PHI_NODE_P (insn))\n+\t{\n+\t  rtx phi = PATTERN (insn);\n+\t  int regno;\n+\t  rtx reg;\n+\n+\t  /* Find out which of our outgoing registers this node is\n+\t     indended to replace.  Note that if this not the first PHI\n+\t     node to have been created for this register, we have to\n+\t     jump through rename links to figure out which register\n+\t     we're talking about.  This can easily be recognized by\n+\t     noting that the regno is new to this pass.  */\n+\t  regno = REGNO (SET_DEST (phi));\n+\t  if (regno >= ssa_max_reg_num)\n+\t    regno = REGNO (VARRAY_RTX (ssa_rename_from, regno));\n+\t  reg = ssa_rename_to[regno - FIRST_PSEUDO_REGISTER];\n+\n+\t  /* It is possible for the variable to be uninitialized on\n+\t     edges in.  Reduce the arity of the PHI so that we don't\n+\t     consider those edges.  */\n+\t  if (reg == NULL || reg == RENAME_NO_RTX)\n+\t    {\n+\t      if (! remove_phi_alternative (phi, bb))\n+\t\tabort ();\n+\t    }\n+\t  else\n+\t    {\n+\t      /* When we created the PHI nodes, we did not know what mode\n+\t     the register should be.  Now that we've found an original,\n+\t     we can fill that in.  */\n+\t      if (GET_MODE (SET_DEST (phi)) == VOIDmode)\n+\t\tPUT_MODE (SET_DEST (phi), GET_MODE (reg));\n+\t      else if (GET_MODE (SET_DEST (phi)) != GET_MODE (reg))\n+\t\tabort();\n+\n+\t      *phi_alternative (phi, bb) = reg;\n+\t      /* ??? Mark for a new ssa_uses entry.  */\n+\t    }\n+\n+\t  insn = NEXT_INSN (insn);\n+\t}\n+    }\n+\n+  /* Step Three: Do the same to the children of this block in\n+     dominator order.  */\n+\n+  for (c = 0; c < n_basic_blocks; ++c)\n+    if (idom[c] == bb)\n+      rename_block (c, idom);\n+\n+  /* Step Four: Update the sets to refer to their new register.  */\n+\n+  while (set_data)\n+    {\n+      struct rename_set_data *next;\n+      rtx old_reg;\n+\n+      old_reg = *set_data->reg_loc;\n+      *set_data->reg_loc = set_data->new_reg;\n+      ssa_rename_to[REGNO (old_reg)-FIRST_PSEUDO_REGISTER]\n+\t= set_data->prev_reg;\n+\n+      next = set_data->next;\n+      free (set_data);\n+      set_data = next;\n+    }      \n+}\n+\n+static void\n+rename_registers (nregs, idom)\n+     int nregs;\n+     int *idom;\n+{\n+  VARRAY_RTX_INIT (ssa_definition, nregs * 3, \"ssa_definition\");\n+  VARRAY_RTX_INIT (ssa_uses, nregs * 3, \"ssa_uses\");\n+  VARRAY_RTX_INIT (ssa_rename_from, nregs * 3, \"ssa_rename_from\");\n+\n+  ssa_rename_to = (rtx *) alloca (nregs * sizeof(rtx));\n+  bzero (ssa_rename_to, nregs * sizeof(rtx));\n+\n+  rename_block (0, idom);\n+\n+  /* ??? Update basic_block_live_at_start, and other flow info \n+     as needed.  */\n+\n+  ssa_rename_to = NULL;\n+}\n+\n+\n+/* The main entry point for moving to SSA.  */\n+\n+void\n+convert_to_ssa()\n+{\n+  /* Element I is the set of blocks that set register I.  */\n+  sbitmap *evals;\n+\n+  /* Dominator bitmaps.  */\n+  sbitmap *dominators;\n+  sbitmap *dfs;\n+  sbitmap *idfs;\n+\n+  /* Element I is the immediate dominator of block I.  */\n+  int *idom;\n+\n+  int nregs;\n+\n+  find_basic_blocks (get_insns (), max_reg_num(), NULL);\n+  /* The dominator algorithms assume all blocks are reachable, clean\n+     up first.  */\n+  cleanup_cfg (get_insns ());\n+  life_analysis (get_insns (), max_reg_num (), NULL, 1);\n+\n+  /* Compute dominators.  */\n+  dominators = sbitmap_vector_alloc (n_basic_blocks, n_basic_blocks);\n+  compute_flow_dominators (dominators, NULL);\n+\n+  idom = (int *) alloca (n_basic_blocks * sizeof (int));\n+  memset ((void *)idom, -1, (size_t)n_basic_blocks * sizeof (int));\n+  simplify_to_immediate_dominators (idom, dominators);\n+\n+  sbitmap_vector_free (dominators);\n+\n+  if (rtl_dump_file)\n+    {\n+      int i;\n+      fputs (\";; Immediate Dominators:\\n\", rtl_dump_file);\n+      for (i = 0; i < n_basic_blocks; ++i)\n+\tfprintf (rtl_dump_file, \";\\t%3d = %3d\\n\", i, idom[i]);\n+      fflush (rtl_dump_file);\n+    }\n+\n+  /* Compute dominance frontiers.  */\n+\n+  dfs = sbitmap_vector_alloc (n_basic_blocks, n_basic_blocks);\n+  compute_dominance_frontiers (dfs, idom);\n+\n+  if (rtl_dump_file)\n+    {\n+      dump_sbitmap_vector (rtl_dump_file, \";; Dominance Frontiers:\",\n+\t\t\t   \"; Basic Block\", dfs, n_basic_blocks);\n+      fflush (rtl_dump_file);\n+    }\n+\n+  /* Compute register evaluations.  */\n+\n+  ssa_max_reg_num = max_reg_num();\n+  nregs = ssa_max_reg_num - FIRST_PSEUDO_REGISTER;\n+  evals = sbitmap_vector_alloc (nregs, n_basic_blocks);\n+  find_evaluations (evals, nregs);\n+\n+  /* Compute the iterated dominance frontier for each register.  */\n+\n+  idfs = sbitmap_vector_alloc (nregs, n_basic_blocks);\n+  compute_iterated_dominance_frontiers (idfs, dfs, evals, nregs);\n+\n+  if (rtl_dump_file)\n+    {\n+      dump_sbitmap_vector (rtl_dump_file, \";; Iterated Dominance Frontiers:\",\n+\t\t\t   \"; Register-FIRST_PSEUDO_REGISTER\", idfs, nregs);\n+      fflush (rtl_dump_file);\n+    }\n+\n+  /* Insert the phi nodes.  */\n+\n+  insert_phi_nodes (idfs, evals, nregs);\n+\n+  /* Rename the registers to satisfy SSA.  */\n+\n+  rename_registers (nregs, idom);\n+\n+  /* All done!  Clean up and go home.  */\n+\n+  sbitmap_vector_free (dfs);\n+  sbitmap_vector_free (evals);\n+  sbitmap_vector_free (idfs);\n+}\n+\n+\n+/* This is intended to be the FIND of a UNION/FIND algorithm managing\n+   the partitioning of the pseudos.  Glancing through the rest of the\n+   global optimizations, it seems things will work out best if the\n+   partition is set up just before convert_from_ssa is called.  See\n+   section 11.4 of Morgan.\n+\n+   ??? Morgan's algorithm, perhaps with some care, may allow copy\n+   propagation to happen concurrently with the conversion from SSA.\n+\n+   However, it presents potential problems with critical edges -- to\n+   split or not to split.  He mentions beginning the partitioning by\n+   unioning registers associated by a PHI across abnormal critical\n+   edges.  This is the approache taken here.  It is unclear to me how\n+   we are able to do that arbitrarily, though.\n+\n+   Alternately, Briggs presents an algorithm in which critical edges\n+   need not be split, at the expense of the creation of new pseudos,\n+   and the need for some concurrent register renaming.  Moreover, it\n+   is ameanable for modification such that the instructions can be\n+   placed anywhere in the target block, which solves the before-call\n+   placement problem.  However, I don't immediately see how we could\n+   do that concurrently with copy propoagation.\n+\n+   More study is required.  */\n+\n+\n+/*\n+ * Eliminate the PHI across the edge from C to B.\n+ */\n+\n+/* REG is the representative temporary of its partition.  Add it to the\n+   set of nodes to be processed, if it hasn't been already.  Return the\n+   index of this register in the node set.  */\n+\n+static inline int\n+ephi_add_node (reg, nodes, n_nodes)\n+     rtx reg, *nodes;\n+     int *n_nodes;\n+{\n+  int i;\n+  for (i = *n_nodes - 1; i >= 0; --i)\n+    if (REGNO (reg) == REGNO (nodes[i]))\n+      return i;\n+\n+  nodes[i = (*n_nodes)++] = reg;\n+  return i;\n+}\n+\n+/* Part one of the topological sort.  This is a forward (downward) search\n+   through the graph collecting a stack of nodes to process.  Assuming no\n+   cycles, the nodes at top of the stack when we are finished will have\n+   no other dependancies.  */\n+\n+static int *\n+ephi_forward (t, visited, succ, tstack)\n+     int t;\n+     sbitmap visited;\n+     sbitmap *succ;\n+     int *tstack;\n+{\n+  int s;\n+\n+  SET_BIT (visited, t);\n+\n+  EXECUTE_IF_SET_IN_SBITMAP (succ[t], 0, s,\n+    {\n+      if (! TEST_BIT (visited, s))\n+        tstack = ephi_forward (s, visited, succ, tstack);\n+    });\n+\n+  *tstack++ = t;\n+  return tstack;\n+}\n+\n+/* Part two of the topological sort.  The is a backward search through\n+   a cycle in the graph, copying the data forward as we go.  */\n+\n+static void\n+ephi_backward (t, visited, pred, nodes)\n+     int t;\n+     sbitmap visited, *pred;\n+     rtx *nodes;\n+{\n+  int p;\n+\n+  SET_BIT (visited, t);\n+\n+  EXECUTE_IF_SET_IN_SBITMAP (pred[t], 0, p,\n+    {\n+      if (! TEST_BIT (visited, p))\n+\t{\n+\t  ephi_backward (p, visited, pred, nodes);\n+\t  emit_move_insn (nodes[p], nodes[t]);\n+\t}\n+    });\n+}\n+\n+/* Part two of the topological sort.  Create the copy for a register\n+   and any cycle of which it is a member.  */\n+\n+static void\n+ephi_create (t, visited, pred, succ, nodes)\n+     int t;\n+     sbitmap visited, *pred, *succ;\n+     rtx *nodes;\n+{\n+  rtx reg_u = NULL_RTX;\n+  int unvisited_predecessors = 0;\n+  int p;\n+\n+  /* Iterate through the predecessor list looking for unvisited nodes.\n+     If there are any, we have a cycle, and must deal with that.  At \n+     the same time, look for a visited predecessor.  If there is one,\n+     we won't need to create a temporary.  */\n+\n+  EXECUTE_IF_SET_IN_SBITMAP (pred[t], 0, p,\n+    {\n+      if (! TEST_BIT (visited, p))\n+\tunvisited_predecessors = 1;\n+      else if (!reg_u)\n+\treg_u = nodes[p];\n+    });\n+\n+  if (unvisited_predecessors)\n+    {\n+      /* We found a cycle.  Copy out one element of the ring (if necessary),\n+\t then traverse the ring copying as we go.  */\n+\n+      if (!reg_u)\n+\t{\n+\t  reg_u = gen_reg_rtx (GET_MODE (nodes[t]));\n+\t  emit_move_insn (reg_u, nodes[t]);\n+\t}\n+\n+      EXECUTE_IF_SET_IN_SBITMAP (pred[t], 0, p,\n+\t{\n+\t  if (! TEST_BIT (visited, p))\n+\t    {\n+\t      ephi_backward (p, visited, pred, nodes);\n+\t      emit_move_insn (nodes[p], reg_u);\n+\t    }\n+\t});\n+    }  \n+  else \n+    {\n+      /* No cycle.  Just copy the value from a successor.  */\n+\n+      int s;\n+      EXECUTE_IF_SET_IN_SBITMAP (succ[t], 0, s,\n+\t{\n+\t  SET_BIT (visited, t);\n+\t  emit_move_insn (nodes[t], nodes[s]);\n+\t  return;\n+\t});\n+    }\n+}\n+\n+/* Convert the edge to normal form.  */\n+\n+static void\n+eliminate_phi (e, reg_partition)\n+     edge e;\n+     partition reg_partition;\n+{\n+  int n_nodes;\n+  sbitmap *pred, *succ;\n+  sbitmap visited;\n+  rtx *nodes;\n+  int *stack, *tstack;\n+  rtx insn;\n+  int i;\n+\n+  /* Collect an upper bound on the number of registers needing processing.  */\n+\n+  insn = e->dest->head;\n+  if (GET_CODE (insn) == CODE_LABEL)\n+    insn = next_nonnote_insn (insn);\n+\n+  n_nodes = 0;\n+  while (PHI_NODE_P (insn))\n+    {\n+      insn = next_nonnote_insn (insn);\n+      n_nodes += 2;\n+    }\n+\n+  if (n_nodes == 0)\n+    return;\n+\n+  /* Build the auxilliary graph R(B). \n+\n+     The nodes of the graph are the members of the register partition\n+     present in Phi(B).  There is an edge from FIND(T0)->FIND(T1) for\n+     each T0 = PHI(...,T1,...), where T1 is for the edge from block C.  */\n+\n+  nodes = (rtx *) alloca (n_nodes * sizeof(rtx));\n+  pred = sbitmap_vector_alloc (n_nodes, n_nodes);\n+  succ = sbitmap_vector_alloc (n_nodes, n_nodes);\n+  sbitmap_vector_zero (pred, n_nodes);\n+  sbitmap_vector_zero (succ, n_nodes);\n+\n+  insn = e->dest->head;\n+  if (GET_CODE (insn) == CODE_LABEL)\n+    insn = next_nonnote_insn (insn);\n+\n+  n_nodes = 0;\n+  for (; PHI_NODE_P (insn); insn = next_nonnote_insn (insn))\n+    {\n+      rtx* preg = phi_alternative (PATTERN (insn), e->src->index);\n+      rtx tgt = SET_DEST (PATTERN (insn));\n+      rtx reg;\n+\n+      /* There may be no phi alternative corresponding to this edge.\n+\t This indicates that the phi variable is undefined along this\n+\t edge.  */\n+      if (preg == NULL)\n+\tcontinue;\n+      reg = *preg;\n+\n+      if (GET_CODE (reg) != REG || GET_CODE (tgt) != REG)\n+\tabort();\n+\n+      /* If the two registers are already in the same partition, \n+\t nothing will need to be done.  */\n+      if (partition_find (reg_partition, REGNO (reg)) \n+\t  != partition_find (reg_partition, REGNO (tgt)))\n+\t{\n+\t  int ireg, itgt;\n+\n+\t  ireg = ephi_add_node (reg, nodes, &n_nodes);\n+\t  itgt = ephi_add_node (tgt, nodes, &n_nodes);\n+\n+\t  SET_BIT (pred[ireg], itgt);\n+\t  SET_BIT (succ[itgt], ireg);\n+\t}\n+    }\n+\n+  if (n_nodes == 0)\n+    goto out;\n+\n+  /* Begin a topological sort of the graph.  */\n+\n+  visited = sbitmap_alloc (n_nodes);\n+  sbitmap_zero (visited);\n+\n+  tstack = stack = (int *) alloca (n_nodes * sizeof (int));\n+\n+  for (i = 0; i < n_nodes; ++i)\n+    if (! TEST_BIT (visited, i))\n+      tstack = ephi_forward (i, visited, succ, tstack);\n+\n+  sbitmap_zero (visited);\n+\n+  /* As we find a solution to the tsort, collect the implementation \n+     insns in a sequence.  */\n+  start_sequence ();\n+  \n+  while (tstack != stack)\n+    {\n+      i = *--tstack;\n+      if (! TEST_BIT (visited, i))\n+\tephi_create (i, visited, pred, succ, nodes);\n+    }\n+\n+  insn = gen_sequence ();\n+  end_sequence ();\n+  insert_insn_on_edge (insn, e);\n+  if (rtl_dump_file)\n+    fprintf (rtl_dump_file, \"Emitting copy on edge (%d,%d)\\n\",\n+\t     e->src->index, e->dest->index);\n+\n+  sbitmap_free (visited);\n+out:\n+  sbitmap_vector_free (pred);\n+  sbitmap_vector_free (succ);\n+}\n+\n+\n+/* For basic block B, consider all phi insns which provide an\n+   alternative corresponding to an incoming abnormal critical edge.\n+   Place the phi alternative corresponding to that abnormal critical\n+   edge in the same register class as the destination of the set.  \n+\n+   From Morgan, p. 178:\n+\n+     For each abnormal critical edge (C, B), \n+     if T0 = phi (T1, ..., Ti, ..., Tm) is a phi node in B, \n+     and C is the ith predecessor of B, \n+     then T0 and Ti must be equivalent. \n+\n+   Return non-zero iff any such cases were found for which the two\n+   regs were not already in the same class.  */\n+\n+static int\n+make_regs_equivalent_over_bad_edges (bb, reg_partition)\n+     int bb;\n+     partition reg_partition;\n+{\n+  int changed = 0;\n+  basic_block b = BASIC_BLOCK (bb);\n+  rtx phi = b->head;\n+\n+  /* Advance to the first phi node.  */\n+  if (GET_CODE (phi) == CODE_LABEL)\n+    phi = next_nonnote_insn (phi);\n+\n+  /* Scan all the phi nodes.  */\n+  for (; \n+       PHI_NODE_P (phi);\n+       phi = next_nonnote_insn (phi))\n+    {\n+      edge e;\n+      int tgt_regno;\n+      rtx set = PATTERN (phi);\n+      rtx tgt = SET_DEST (set);\n+\n+      /* The set target is expected to be a pseudo.  */\n+      if (GET_CODE (tgt) != REG \n+\t  || REGNO (tgt) < FIRST_PSEUDO_REGISTER)\n+\tabort ();\n+      tgt_regno = REGNO (tgt);\n+\n+      /* Scan incoming abnormal critical edges.  */\n+      for (e = b->pred; e; e = e->pred_next)\n+\tif (e->flags & (EDGE_ABNORMAL | EDGE_CRITICAL))\n+\t  {\n+\t    rtx *alt = phi_alternative (set, e->src->index);\n+\t    int alt_regno;\n+\n+\t    /* If there is no alternative corresponding to this edge,\n+\t       the value is undefined along the edge, so just go on.  */\n+\t    if (alt == 0)\n+\t      continue;\n+\n+\t    /* The phi alternative is expected to be a pseudo.  */\n+\t    if (GET_CODE (*alt) != REG \n+\t\t|| REGNO (*alt) < FIRST_PSEUDO_REGISTER)\n+\t      abort ();\n+\t    alt_regno = REGNO (*alt);\n+\n+\t    /* If the set destination and the phi alternative aren't\n+\t       already in the same class...  */\n+\t    if (partition_find (reg_partition, tgt_regno) \n+\t\t!= partition_find (reg_partition, alt_regno))\n+\t      {\n+\t\t/* ... make them such.  */\n+\t\tpartition_union (reg_partition, \n+\t\t\t\t tgt_regno, alt_regno);\n+\t\t++changed;\n+\t      }\n+\t  }\n+    }\n+\n+  return changed;\n+}\n+\n+\n+/* Consider phi insns in basic block BB pairwise.  If the set target\n+   of both isns are equivalent pseudos, make the corresponding phi\n+   alternatives in each phi corresponding equivalent.\n+\n+   Return nonzero if any new register classes were unioned.  */\n+\n+static int\n+make_equivalent_phi_alternatives_equivalent (bb, reg_partition)\n+     int bb;\n+     partition reg_partition;\n+{\n+  int changed = 0;\n+  rtx phi = BLOCK_HEAD (bb);\n+  basic_block b = BASIC_BLOCK (bb);\n+\n+  /* Advance to the first phi node.  */\n+  if (GET_CODE (phi) == CODE_LABEL)\n+    phi = next_nonnote_insn (phi);\n+\n+  /* Scan all the phi nodes.  */\n+  for (; \n+       PHI_NODE_P (phi);\n+       phi = next_nonnote_insn (phi))\n+    {\n+      rtx set = PATTERN (phi);\n+      /* The regno of the destination of the set.  */\n+      int tgt_regno = REGNO (SET_DEST (PATTERN (phi)));\n+\n+      rtx phi2 = next_nonnote_insn (phi);\n+\n+      /* Scan all phi nodes following this one.  */\n+      for (;\n+\t   PHI_NODE_P (phi2);\n+\t   phi2 = next_nonnote_insn (phi2))\n+\t{\n+\t  rtx set2 = PATTERN (phi2);\n+\t  /* The regno of the destination of the set.  */\n+\t  int tgt2_regno = REGNO (SET_DEST (set2));\n+\t\t  \n+\t  /* Are the set destinations equivalent regs?  */\n+\t  if (partition_find (reg_partition, tgt_regno) ==\n+\t      partition_find (reg_partition, tgt2_regno))\n+\t    {\n+\t      edge e;\n+\t      /* Scan over edges.  */\n+\t      for (e = b->pred; e; e = e->pred_next)\n+\t\t{\n+\t\t  int pred_block = e->src->index;\n+\t\t  /* Identify the phi altnernatives from both phi\n+\t\t     nodes corresponding to this edge.  */\n+\t\t  rtx *alt = phi_alternative (set, pred_block);\n+\t\t  rtx *alt2 = phi_alternative (set2, pred_block);\n+\n+\t\t  /* If one of the phi nodes doesn't have a\n+\t\t     corresponding alternative, just skip it.  */\n+\t\t  if (alt == 0 || alt2 == 0)\n+\t\t    continue;\n+\n+\t\t  /* Both alternatives should be pseudos.  */\n+\t\t  if (GET_CODE (*alt) != REG\n+\t\t      || REGNO (*alt) < FIRST_PSEUDO_REGISTER)\n+\t\t    abort ();\n+\t\t  if (GET_CODE (*alt2) != REG\n+\t\t      || REGNO (*alt2) < FIRST_PSEUDO_REGISTER)\n+\t\t    abort ();\n+\n+\t\t  /* If the altneratives aren't already in the same\n+\t\t     class ... */\n+\t\t  if (partition_find (reg_partition, REGNO (*alt)) \n+\t\t      != partition_find (reg_partition, REGNO (*alt2)))\n+\t\t    {\n+\t\t      /* ... make them so.  */\n+\t\t      partition_union (reg_partition, \n+\t\t\t\t       REGNO (*alt), REGNO (*alt2));\n+\t\t      ++changed;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+  return changed;\n+}\n+\n+\n+/* Compute a conservative partition of outstanding pseudo registers.\n+   See Morgan 7.3.1.  */\n+\n+static partition\n+compute_conservative_reg_partition ()\n+{\n+  int bb;\n+  int changed = 0;\n+\n+  /* We don't actually work with hard registers, but it's easier to\n+     carry them around anyway rather than constantly doing register\n+     number arithmetic.  */\n+  partition p = \n+    partition_new (ssa_definition->num_elements + FIRST_PSEUDO_REGISTER);\n+\n+  /* The first priority is to make sure registers that might have to\n+     be copied on abnormal critical edges are placed in the same\n+     partition.  This saves us from having to split abnormal critical\n+     edges.  */\n+  for (bb = n_basic_blocks; --bb >= 0; )\n+    changed += make_regs_equivalent_over_bad_edges (bb, p);\n+  \n+  /* Now we have to insure that corresponding arguments of phi nodes\n+     assigning to corresponding regs are equivalent.  Iterate until\n+     nothing changes.  */\n+  while (changed > 0)\n+    {\n+      changed = 0;\n+      for (bb = n_basic_blocks; --bb >= 0; )\n+\tchanged += make_equivalent_phi_alternatives_equivalent (bb, p);\n+    }\n+\n+  return p;\n+}\n+\n+\n+/* Rename regs in insn PTR that are equivalent.  DATA is the register\n+   partition which specifies equivalences.  */\n+\n+static int\n+rename_equivalent_regs_in_insn (ptr, data)\n+     rtx *ptr;\n+     void* data;\n+{\n+  rtx x = *ptr;\n+  partition reg_partition = (partition) data;\n+\n+  if (x == NULL_RTX)\n+    return 0;\n+\n+  switch (GET_CODE (x))\n+    {\n+    case SET:\n+      {\n+\trtx *destp = &SET_DEST (x);\n+\trtx dest = SET_DEST (x);\n+\n+\t/* Subregs at word 0 are interesting.  Subregs at word != 0 are\n+\t   presumed to be part of a contiguous multi-word set sequence.  */\n+\twhile (GET_CODE (dest) == SUBREG\n+\t       && SUBREG_WORD (dest) == 0)\n+\t  {\n+\t    destp = &SUBREG_REG (dest);\n+\t    dest = SUBREG_REG (dest);\n+\t  }\n+\n+\tif (GET_CODE (dest) == REG\n+\t    && REGNO (dest) >= FIRST_PSEUDO_REGISTER)\n+\t  {\n+\t    /* Got a pseudo; replace it.  */\n+\t    int regno = REGNO (dest);\n+\t    int new_regno = partition_find (reg_partition, regno);\n+\t    if (regno != new_regno)\n+\t      *destp = regno_reg_rtx [new_regno];\n+\n+\t    for_each_rtx (&SET_SRC (x), \n+\t\t\t  rename_equivalent_regs_in_insn, \n+\t\t\t  data);\n+\t    return -1;\n+\t  }\n+\n+\t/* Otherwise, this was not an interesting destination.  Continue\n+\t   on, marking uses as normal.  */\n+\treturn 0;\n+      }\n+\n+    case REG:\n+      if (REGNO (x) >= FIRST_PSEUDO_REGISTER)\n+\t{\n+\t  int regno = REGNO (x);\n+\t  int new_regno = partition_find (reg_partition, regno);\n+\t  if (regno != new_regno)\n+\t    {\n+\t      rtx new_reg = regno_reg_rtx[new_regno];\n+\t      if (GET_MODE (x) != GET_MODE (new_reg))\n+\t\tabort ();\n+\t      *ptr = new_reg;\n+\t    }\n+\t}\n+      return -1;\n+\n+    case PHI:\n+      /* No need to rename the phi nodes.  We'll check equivalence\n+\t when inserting copies.  */\n+      return -1;\n+\n+    default:\n+      /* Anything else, continue traversing.  */\n+      return 0;\n+    }\n+}\n+\n+\n+/* Rename regs that are equivalent in REG_PARTITION.  */\n+\n+static void\n+rename_equivalent_regs (reg_partition)\n+     partition reg_partition;\n+{\n+  int bb;\n+\n+  for (bb = n_basic_blocks; --bb >= 0; )\n+    {\n+      basic_block b = BASIC_BLOCK (bb);\n+      rtx next = b->head;\n+      rtx last = b->end;\n+      rtx insn;\n+\n+      do\n+\t{\n+\t  insn = next;\n+\t  if (GET_RTX_CLASS (GET_CODE (insn)) == 'i')\n+\t    {\n+\t      for_each_rtx (&PATTERN (insn), \n+\t\t\t    rename_equivalent_regs_in_insn, \n+\t\t\t    reg_partition);\n+\t      for_each_rtx (&REG_NOTES (insn), \n+\t\t\t    rename_equivalent_regs_in_insn, \n+\t\t\t    reg_partition);\n+\t    }\n+\n+\t  next = NEXT_INSN (insn);\n+\t}\n+      while (insn != last);\n+    }\n+}\n+\n+\n+/* The main entry point for moving from SSA.  */\n+\n+void\n+convert_from_ssa()\n+{\n+  int bb;\n+  partition reg_partition;\n+  \n+  reg_partition = compute_conservative_reg_partition ();\n+  rename_equivalent_regs (reg_partition);\n+\n+  /* Eliminate the PHI nodes.  */\n+  for (bb = n_basic_blocks; --bb >= 0; )\n+    {\n+      basic_block b = BASIC_BLOCK (bb);\n+      edge e;\n+\n+      for (e = b->pred; e; e = e->pred_next)\n+\tif (e->src != ENTRY_BLOCK_PTR)\n+\t  eliminate_phi (e, reg_partition);\n+    }\n+\n+  partition_delete (reg_partition);\n+\n+  /* Actually delete the PHI nodes.  */\n+  for (bb = n_basic_blocks; --bb >= 0; )\n+    {\n+      rtx insn = BLOCK_HEAD (bb);\n+      int start = (GET_CODE (insn) != CODE_LABEL);\n+\n+      if (! start)\n+\tinsn = next_nonnote_insn (insn);\n+      while (PHI_NODE_P (insn))\n+\t{\n+\t  insn = delete_insn (insn);\n+\t  if (GET_CODE (insn) == NOTE)\n+\t    insn = next_nonnote_insn (insn);\n+\t}\n+      if (start)\n+\tBLOCK_HEAD (bb) = insn;\n+    }\n+\n+  /* Commit all the copy nodes needed to convert out of SSA form.  */\n+  commit_edge_insertions ();\n+\n+  count_or_remove_death_notes (NULL, 1);\n+}"}, {"sha": "b1a0694336f2433c62f4dae3e9dbfa12e81cf86a", "filename": "gcc/toplev.c", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9d4fb433e86047a5bab699548322cfa745795d6/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9d4fb433e86047a5bab699548322cfa745795d6/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=d9d4fb433e86047a5bab699548322cfa745795d6", "patch": "@@ -257,6 +257,7 @@ int stack_reg_dump = 0;\n #ifdef MACHINE_DEPENDENT_REORG\n int mach_dep_reorg_dump = 0;\n #endif\n+int ssa_dump = 0;\n static int flag_print_mem = 0;\n static int version_flag = 0;\n static char * filename = 0;\n@@ -695,6 +696,9 @@ int flag_gnu_linker = 0;\n int flag_gnu_linker = 1;\n #endif\n \n+/* Enable SSA.  */\n+int flag_ssa = 0;\n+\n /* Tag all structures with __attribute__(packed) */\n int flag_pack_struct = 0;\n \n@@ -997,6 +1001,8 @@ lang_independent_options f_options[] =\n    \"Suppress output of instruction numbers and line number notes in debugging dumps\"},\n   {\"instrument-functions\", &flag_instrument_function_entry_exit, 1,\n    \"Instrument function entry/exit with profiling calls\"},\n+  {\"ssa\", &flag_ssa, 1,\n+   \"Enable SSA optimizations\" },\n   {\"leading-underscore\", &flag_leading_underscore, 1,\n    \"External symbols have a leading underscore\" },\n   {\"ident\", &flag_no_ident, 0,\n@@ -2152,6 +2158,11 @@ compile_file (name)\n       if (graph_dump_format != no_graph)\n \tclean_graph_dump_file (dump_base_name, \".03.addressof\");\n     }\n+  if (ssa_dump)\n+    {\n+      clean_dump_file (\".033.ssa\");\n+      clean_dump_file (\".037.ussa\");\n+    }\n   if (gcse_dump)\n     {\n       clean_dump_file (\".04.gcse\");\n@@ -3125,6 +3136,30 @@ rest_of_compilation (decl)\n   if (ggc_p)\n     ggc_collect ();\n \n+  if (flag_ssa)\n+    {\n+      if (ssa_dump)\n+\topen_dump_file (\".033.ssa\", decl_printable_name (decl, 2));\n+      convert_to_ssa ();\n+      if (ssa_dump)\n+\tclose_dump_file (print_rtl_with_bb, insns);\n+\n+      if (ssa_dump)\n+\topen_dump_file (\".037.ussa\", decl_printable_name (decl, 2));\n+      convert_from_ssa ();\n+      /* New registers have been created.  Rescan their usage.  */\n+      reg_scan (insns, max_reg_num (), 1);\n+      if (ssa_dump)\n+\tclose_dump_file (print_rtl_with_bb, insns);\n+\n+      /* Life analysis used in SSA adds log_links but these shouldn't\n+\t be there until the flow stage, so clear them away.  */\n+      clear_log_links (insns);\n+\n+      if (ggc_p)\n+\tggc_collect ();\n+    }\n+\n   /* Perform global cse.  */\n \n   if (optimize > 0 && flag_gcse)\n@@ -4021,6 +4056,7 @@ decode_d_option (arg)\n \tmach_dep_reorg_dump = 1;\n #endif\n \tpeephole2_dump = 1;\n+\tssa_dump = 1;\n \tbreak;\n       case 'A':\n \tflag_debug_asm = 1;\n@@ -4039,6 +4075,9 @@ decode_d_option (arg)\n \tdbr_sched_dump = 1;\n \tbreak;\n #endif\n+      case 'e':\n+\tssa_dump = 1;\n+\tbreak;\n       case 'f':\n \tflow_dump = 1;\n \tbreak;"}, {"sha": "be7061c63942362d89cd0c492ca7b1860bd3b33b", "filename": "include/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9d4fb433e86047a5bab699548322cfa745795d6/include%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9d4fb433e86047a5bab699548322cfa745795d6/include%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2FChangeLog?ref=d9d4fb433e86047a5bab699548322cfa745795d6", "patch": "@@ -1,3 +1,7 @@\n+2000-03-09  Alex Samuel  <samuel@codesourcery.com>\n+\n+\t* partition.h: New file.\n+\n 2000-03-09  Zack Weinberg  <zack@wolery.cumb.org>\n \n \t* hashtab.h (struct htab): Add del_f."}, {"sha": "f49d67a8cadac356a02689288034a885aa6e9d72", "filename": "include/partition.h", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9d4fb433e86047a5bab699548322cfa745795d6/include%2Fpartition.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9d4fb433e86047a5bab699548322cfa745795d6/include%2Fpartition.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Fpartition.h?ref=d9d4fb433e86047a5bab699548322cfa745795d6", "patch": "@@ -0,0 +1,81 @@\n+/* List implentation of a partition of consecutive integers.\n+   Copyright (C) 2000 Free Software Foundation, Inc.\n+   Contributed by CodeSourcery, LLC.\n+\n+   This file is part of GNU CC.\n+\n+   GNU CC is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 2, or (at your option)\n+   any later version.\n+\n+   GNU CC is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GNU CC; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330,\n+   Boston, MA 02111-1307, USA.  */\n+\n+/* This package implements a partition of consecutive integers.  The\n+   elements are partitioned into classes.  Each class is represented\n+   by one of its elements, the canonical element, which is chosen\n+   arbitrarily from elements in the class.  The principal operations\n+   on a partition are FIND, which takes an element, determines its\n+   class, and returns the canonical element for that class, and UNION,\n+   which unites the two classes that contain two given elements into a\n+   single class.\n+\n+   The list implementation used here provides constant-time finds.  By\n+   storing the size of each class with the class's canonical element,\n+   it is able to perform unions over all the classes in the partition\n+   in O (N log N) time.  */\n+\n+#ifndef _PARTITION_H\n+#define _PARTITION_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif /* __cplusplus */\n+\n+#include <ansidecl.h>\n+#include <stdio.h>\n+\n+struct partition_elem\n+{\n+  /* The canonical element that represents the class containing this\n+     element.  */\n+  int class_element;\n+  /* The next element in this class.  Elements in each class form a\n+     circular list.  */\n+  struct partition_elem* next;\n+  /* The number of elements in this class.  Valid only if this is the\n+     canonical element for its class.  */\n+  unsigned class_count;\n+};\n+\n+typedef struct partition_def \n+{\n+  /* The number of elements in this partition.  */\n+  int num_elements;\n+  /* The elements in the partition.  */\n+  struct partition_elem elements[1];\n+} *partition;\n+\n+extern partition partition_new          PARAMS((int));\n+extern void partition_delete            PARAMS((partition));\n+extern int partition_union              PARAMS((partition,\n+\t\t\t\t\t\tint,\n+\t\t\t\t\t\tint));\n+extern void partition_print             PARAMS((partition,\n+\t\t\t\t\t\tFILE*));\n+\n+/* Returns the canonical element corresponding to the class containing\n+   ELEMENT__ in PARTITION__.  */\n+\n+#define partition_find(partition__, element__) \\\n+    ((partition__)->elements[(element__)].class_element)\n+\n+#endif /* _PARTITION_H */"}, {"sha": "de8ed944ad074f32d1ccab6488337d1aec5f13b1", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9d4fb433e86047a5bab699548322cfa745795d6/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9d4fb433e86047a5bab699548322cfa745795d6/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=d9d4fb433e86047a5bab699548322cfa745795d6", "patch": "@@ -1,3 +1,10 @@\n+2000-03-09  Alex Samuel  <samuel@codesourcery.com>\n+\n+\t* Makefile.in (CFILES): Add partition.c.\n+\t(REQUIRED_OFILES): Add partition.o.\n+\t(partition.o): New rule.\n+\t* partition.c: New file.\n+\t\n 2000-03-09  Zack Weinberg  <zack@wolery.cumb.org>\n \n \t* hashtab.c (htab_create): Set del_f."}, {"sha": "1039d5922c63aebec2f794dca69a82931d6d70db", "filename": "libiberty/Makefile.in", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9d4fb433e86047a5bab699548322cfa745795d6/libiberty%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9d4fb433e86047a5bab699548322cfa745795d6/libiberty%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FMakefile.in?ref=d9d4fb433e86047a5bab699548322cfa745795d6", "patch": "@@ -123,21 +123,22 @@ HFILES = alloca-conf.h\n # NOTE: If you add new files to the library, add them to this list\n # (alphabetical), and add them to REQUIRED_OFILES or funcs in\n # configure.in.\n-CFILES = asprintf.c alloca.c argv.c atexit.c basename.c bcmp.c bcopy.c \\\n+CFILES = asprintf.c alloca.c argv.c atexit.c basename.c bcmp.c bcopy.c\t      \\\n \tbzero.c calloc.c choose-temp.c clock.c concat.c cplus-dem.c fdmatch.c \\\n-\tfnmatch.c getcwd.c getpwd.c getopt.c getopt1.c getpagesize.c \\\n-\tgetruntime.c floatformat.c hashtab.c hex.c index.c insque.c memchr.c \\\n-\tmemcmp.c memcpy.c memmove.c memset.c mkstemps.c objalloc.c obstack.c \\\n-\tpexecute.c putenv.c random.c rename.c rindex.c setenv.c sigsetmask.c \\\n-\tspaces.c splay-tree.c strcasecmp.c strncasecmp.c strchr.c strdup.c \\\n-\tstrerror.c strrchr.c strsignal.c strstr.c strtod.c strtol.c strtoul.c \\\n-\ttmpnam.c vasprintf.c vfork.c vfprintf.c vprintf.c vsprintf.c \\\n-\twaitpid.c xatexit.c xexit.c xmalloc.c xmemdup.c xstrdup.c xstrerror.c\n+\tfnmatch.c getcwd.c getpwd.c getopt.c getopt1.c getpagesize.c\t      \\\n+\tgetruntime.c floatformat.c hashtab.c hex.c index.c insque.c memchr.c  \\\n+\tmemcmp.c memcpy.c memmove.c memset.c mkstemps.c objalloc.c obstack.c  \\\n+\tpartition.c pexecute.c putenv.c random.c rename.c rindex.c\t      \\\n+\tsetenv.c sigsetmask.c spaces.c splay-tree.c strcasecmp.c\t      \\\n+\tstrncasecmp.c strchr.c strdup.c strerror.c strrchr.c\t\t      \\\n+\tstrsignal.c strstr.c strtod.c strtol.c strtoul.c tmpnam.c\t      \\\n+\tvasprintf.c vfork.c vfprintf.c vprintf.c vsprintf.c waitpid.c\t      \\\n+\txatexit.c xexit.c xmalloc.c xmemdup.c xstrdup.c xstrerror.c\n \n # These are always included in the library.\n REQUIRED_OFILES = argv.o choose-temp.o concat.o cplus-dem.o \\\n   fdmatch.o fnmatch.o getopt.o getopt1.o getpwd.o getruntime.o hashtab.o \\\n-  hex.o floatformat.o objalloc.o obstack.o pexecute.o spaces.o \\\n+  hex.o floatformat.o objalloc.o obstack.o partition.o pexecute.o spaces.o \\\n   splay-tree.o strerror.o strsignal.o xatexit.o xexit.o xmalloc.o \\\n   xmemdup.o xstrdup.o xstrerror.o\n \n@@ -271,6 +272,7 @@ floatformat.o: $(INCDIR)/floatformat.h\n mkstemps.o: config.h\n objalloc.o: $(INCDIR)/objalloc.h\n obstack.o: config.h $(INCDIR)/obstack.h\n+partition.o: $(INCDIR)/partition.h\n pexecute.o: config.h $(INCDIR)/libiberty.h\n setenv.o: config.h\n spaces.o: $(INCDIR)/libiberty.h"}, {"sha": "c1d584774bfa2f3047670ca14d7502a65696a62c", "filename": "libiberty/partition.c", "status": "added", "additions": 185, "deletions": 0, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9d4fb433e86047a5bab699548322cfa745795d6/libiberty%2Fpartition.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9d4fb433e86047a5bab699548322cfa745795d6/libiberty%2Fpartition.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fpartition.c?ref=d9d4fb433e86047a5bab699548322cfa745795d6", "patch": "@@ -0,0 +1,185 @@\n+/* List implentation of a partition of consecutive integers.\n+   Copyright (C) 2000 Free Software Foundation, Inc.\n+   Contributed by CodeSourcery, LLC.\n+\n+   This file is part of GNU CC.\n+\n+   GNU CC is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 2, or (at your option)\n+   any later version.\n+\n+   GNU CC is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GNU CC; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330,\n+   Boston, MA 02111-1307, USA.  */\n+\n+#ifdef HAVE_CONFIG_H\n+#include \"config.h\"\n+#endif\n+\n+#ifdef HAVE_STDLIB_H\n+#include <stdlib.h>\n+#endif\n+\n+#include \"libiberty.h\"\n+#include \"partition.h\"\n+\n+/* Creates a partition of NUM_ELEMENTS elements.  Initially each\n+   element is in a class by itself.  */\n+\n+partition\n+partition_new (num_elements)\n+     int num_elements;\n+{\n+  int e;\n+  \n+  partition part = (partition) \n+    xmalloc (sizeof (struct partition_def) + \n+\t     (num_elements - 1) * sizeof (struct partition_elem));\n+  part->num_elements = num_elements;\n+  for (e = 0; e < num_elements; ++e) \n+    {\n+      part->elements[e].class_element = e;\n+      part->elements[e].next = &(part->elements[e]);\n+      part->elements[e].class_count = 1;\n+    }\n+\n+  return part;\n+}\n+\n+/* Freeds a partition.  */\n+\n+void\n+partition_delete (part)\n+      partition part;\n+{\n+  free (part);\n+}\n+\n+/* Unites the classes containing ELEM1 and ELEM2 into a single class\n+   of partition PART.  If ELEM1 and ELEM2 are already in the same\n+   class, does nothing.  Returns the canonical element of the\n+   resulting union class.  */\n+\n+int\n+partition_union (part, elem1, elem2)\n+     partition part;\n+     int elem1;\n+     int elem2;\n+{\n+  struct partition_elem *elements = part->elements;\n+  struct partition_elem *e1;\n+  struct partition_elem *e2;\n+  struct partition_elem *p;\n+  struct partition_elem *old_next;\n+  /* The canonical element of the resulting union class.  */\n+  int class_element = elements[elem1].class_element;\n+\n+  /* If they're already in the same class, do nothing.  */\n+  if (class_element == elements[elem2].class_element)\n+    return class_element;\n+\n+  /* Make sure ELEM1 is in the larger class of the two.  If not, swap\n+     them.  This way we always scan the shorter list.  */\n+  if (elements[elem1].class_count < elements[elem2].class_count) \n+    {\n+      int temp = elem1;\n+      elem1 = elem2;\n+      elem2 = temp;\n+      class_element = elements[elem1].class_element;\n+    }\n+\n+  e1 = &(elements[elem1]);\n+  e2 = &(elements[elem2]);\n+\n+  /* Keep a count of the number of elements in the list.  */\n+  elements[class_element].class_count \n+    += elements[e2->class_element].class_count;\n+\n+  /* Update the class fields in elem2's class list.  */\n+  e2->class_element = class_element;\n+  for (p = e2->next; p != e2; p = p->next)\n+    p->class_element = class_element;\n+  \n+  /* Splice ELEM2's class list into ELEM1's.  These are circular\n+     lists.  */\n+  old_next = e1->next;\n+  e1->next = e2->next;\n+  e2->next = old_next;\n+\n+  return class_element;\n+}\n+\n+/* Compare elements ELEM1 and ELEM2 from array of integers, given a\n+   pointer to each.  Used to qsort such an array.  */\n+\n+static int \n+elem_compare (elem1, elem2)\n+     const void *elem1;\n+     const void *elem2;\n+{\n+  int e1 = * (int *) elem1;\n+  int e2 = * (int *) elem2;\n+  if (e1 < e2)\n+    return -1;\n+  else if (e1 > e2)\n+    return 1;\n+  else\n+    return 0;\n+}\n+\n+/* Prints PART to the file pointer FP.  The elements of each\n+   class are sorted.  */\n+\n+void\n+partition_print (part, fp)\n+     partition part;\n+     FILE *fp;\n+{\n+  char *done;\n+  int num_elements = part->num_elements;\n+  struct partition_elem *elements = part->elements;\n+  int *class_elements;\n+  int e;\n+\n+  /* Flag the elements we've already printed.  */\n+  done = (char *) xmalloc (num_elements);\n+  memset (done, 0, num_elements);\n+\n+  /* A buffer used to sort elements in a class.  */\n+  class_elements = (int *) xmalloc (num_elements * sizeof (int));\n+\n+  fputc ('[', fp);\n+  for (e = 0; e < num_elements; ++e)\n+    /* If we haven't printed this element, print its entire class.  */\n+    if (! done[e]) \n+      {\n+\tint c = e;\n+\tint count = elements[elements[e].class_element].class_count;\n+\tint i;\n+\n+      /* Collect the elements in this class.  */\n+\tfor (i = 0; i < count; ++i) {\n+\t  class_elements[i] = c;\n+\t  done[c] = 1;\n+\t  c = elements[c].next - elements;\n+\t}\n+\t/* Sort them.  */\n+\tqsort ((void *) class_elements, count, sizeof (int), &elem_compare);\n+\t/* Print them.  */\n+\tfputc ('(', fp);\n+\tfor (i = 0; i < count; ++i) \n+\t  fprintf (fp, i == 0 ? \"%d\" : \" %d\", class_elements[i]);\n+\tfputc (')', fp);\n+      }\n+  fputc (']', fp);\n+\n+  free (done);\n+}\n+"}]}