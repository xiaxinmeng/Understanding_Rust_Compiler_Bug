{"sha": "9a0a7d5dfad84220ef3b243fa8d231e7c30cc058", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWEwYTdkNWRmYWQ4NDIyMGVmM2IyNDNmYThkMjMxZTdjMzBjYzA1OA==", "commit": {"author": {"name": "Hans-Peter Nilsson", "email": "hp@bitrange.com", "date": "2002-11-20T20:06:34Z"}, "committer": {"name": "Hans-Peter Nilsson", "email": "hp@gcc.gnu.org", "date": "2002-11-20T20:06:34Z"}, "message": "ggc-common.c [!ENABLE_VALGRIND_CHECKING] (VALGRIND_DISCARD): Define as empty.\n\n\t* ggc-common.c [!ENABLE_VALGRIND_CHECKING] (VALGRIND_DISCARD):\n\tDefine as empty.\n\t(ggc_realloc): Update valgrind annotations.\n\t* ggc-page.c [!ENABLE_VALGRIND_CHECKING] (VALGRIND_DISCARD):\n\tDefine as empty.\n \t(alloc_anon, free_page, ggc_alloc, poison_pages): Add machinery to\n\tvalgrind-annotate memory.\n\nFrom-SVN: r59310", "tree": {"sha": "875408dbc971a059d46c40bc2e97d990800c184a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/875408dbc971a059d46c40bc2e97d990800c184a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9a0a7d5dfad84220ef3b243fa8d231e7c30cc058", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a0a7d5dfad84220ef3b243fa8d231e7c30cc058", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a0a7d5dfad84220ef3b243fa8d231e7c30cc058", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a0a7d5dfad84220ef3b243fa8d231e7c30cc058/comments", "author": null, "committer": null, "parents": [{"sha": "414d23ae18deaae675fe45cd997e71ede2f6af94", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/414d23ae18deaae675fe45cd997e71ede2f6af94", "html_url": "https://github.com/Rust-GCC/gccrs/commit/414d23ae18deaae675fe45cd997e71ede2f6af94"}], "stats": {"total": 87, "additions": 85, "deletions": 2}, "files": [{"sha": "526ecdb0e1d84e4d73d7daea523c33dd4274ee9f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a0a7d5dfad84220ef3b243fa8d231e7c30cc058/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a0a7d5dfad84220ef3b243fa8d231e7c30cc058/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9a0a7d5dfad84220ef3b243fa8d231e7c30cc058", "patch": "@@ -18,6 +18,14 @@\n \t* gcc.c (execute) [ENABLE_VALGRIND_CHECKING]: Arrange to prepend\n \tVALGRIND_PATH -q to each command.\n \n+\t* ggc-common.c [!ENABLE_VALGRIND_CHECKING] (VALGRIND_DISCARD):\n+\tDefine as empty.\n+\t(ggc_realloc): Update valgrind annotations.\n+\t* ggc-page.c [!ENABLE_VALGRIND_CHECKING] (VALGRIND_DISCARD):\n+\tDefine as empty.\n+ \t(alloc_anon, free_page, ggc_alloc, poison_pages): Add machinery to\n+\tvalgrind-annotate memory.\n+\n 2002-11-20  Ulrich Weigand  <uweigand@de.ibm.com>\n \n \t* recog.c (constrain_operands): Prefer exact match over reloadable"}, {"sha": "b0ebabc40ce6ff4bf4019bb6415ea9713cc061f3", "filename": "gcc/ggc-common.c", "status": "modified", "additions": 33, "deletions": 1, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a0a7d5dfad84220ef3b243fa8d231e7c30cc058/gcc%2Fggc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a0a7d5dfad84220ef3b243fa8d231e7c30cc058/gcc%2Fggc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-common.c?ref=9a0a7d5dfad84220ef3b243fa8d231e7c30cc058", "patch": "@@ -30,6 +30,12 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"varray.h\"\n #include \"ggc.h\"\n #include \"langhooks.h\"\n+#ifdef ENABLE_VALGRIND_CHECKING\n+#include <valgrind.h>\n+#else\n+/* Avoid #ifdef:s when we can help it.  */\n+#define VALGRIND_DISCARD(x)\n+#endif\n \n /* Statistics about the allocation.  */\n static ggc_statistics *ggc_stats;\n@@ -155,10 +161,36 @@ ggc_realloc (x, size)\n \n   old_size = ggc_get_size (x);\n   if (size <= old_size)\n-    return x;\n+    {\n+      /* Mark the unwanted memory as unaccessible.  We also need to make\n+\t the \"new\" size accessible, since ggc_get_size returns the size of\n+\t the pool, not the size of the individually allocated object, the\n+\t size which was previously made accessible.  Unfortunately, we\n+\t don't know that previously allocated size.  Without that\n+\t knowledge we have to lose some initialization-tracking for the\n+\t old parts of the object.  An alternative is to mark the whole\n+\t old_size as reachable, but that would lose tracking of writes \n+\t after the end of the object (by small offsets).  Discard the\n+\t handle to avoid handle leak.  */\n+      VALGRIND_DISCARD (VALGRIND_MAKE_NOACCESS ((char *) x + size,\n+\t\t\t\t\t\told_size - size));\n+      VALGRIND_DISCARD (VALGRIND_MAKE_READABLE (x, size));\n+      return x;\n+    }\n \n   r = ggc_alloc (size);\n+\n+  /* Since ggc_get_size returns the size of the pool, not the size of the\n+     individually allocated object, we'd access parts of the old object\n+     that were marked invalid with the memcpy below.  We lose a bit of the\n+     initialization-tracking since some of it may be uninitialized.  */\n+  VALGRIND_DISCARD (VALGRIND_MAKE_READABLE (x, old_size));\n+\n   memcpy (r, x, old_size);\n+\n+  /* The old object is not supposed to be used anymore.  */\n+  VALGRIND_DISCARD (VALGRIND_MAKE_NOACCESS (x, old_size));\n+\n   return r;\n }\n "}, {"sha": "f210af93abef9498d8b6943d750360f061b36768", "filename": "gcc/ggc-page.c", "status": "modified", "additions": 44, "deletions": 1, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a0a7d5dfad84220ef3b243fa8d231e7c30cc058/gcc%2Fggc-page.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a0a7d5dfad84220ef3b243fa8d231e7c30cc058/gcc%2Fggc-page.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-page.c?ref=9a0a7d5dfad84220ef3b243fa8d231e7c30cc058", "patch": "@@ -29,6 +29,12 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"ggc.h\"\n #include \"timevar.h\"\n #include \"params.h\"\n+#ifdef ENABLE_VALGRIND_CHECKING\n+#include <valgrind.h>\n+#else\n+/* Avoid #ifdef:s when we can help it.  */\n+#define VALGRIND_DISCARD(x)\n+#endif\n \n /* Prefer MAP_ANON(YMOUS) to /dev/zero, since we don't need to keep a\n    file open.  Prefer either to valloc.  */\n@@ -524,6 +530,11 @@ alloc_anon (pref, size)\n   /* Remember that we allocated this memory.  */\n   G.bytes_mapped += size;\n \n+  /* Pretend we don't have access to the allocated pages.  We'll enable\n+     access to smaller pieces of the area in ggc_alloc.  Discard the\n+     handle to avoid handle leak.  */\n+  VALGRIND_DISCARD (VALGRIND_MAKE_NOACCESS (page, size));\n+\n   return page;\n }\n #endif\n@@ -750,6 +761,10 @@ free_page (entry)\n \t     \"Deallocating page at %p, data %p-%p\\n\", (PTR) entry,\n \t     entry->page, entry->page + entry->bytes - 1);\n \n+  /* Mark the page as inaccessible.  Discard the handle to avoid handle\n+     leak.  */\n+  VALGRIND_DISCARD (VALGRIND_MAKE_NOACCESS (entry->page, entry->bytes));\n+\n   set_page_table_entry (entry->page, NULL);\n \n #ifdef USING_MALLOC_PAGE_GROUPS\n@@ -943,11 +958,27 @@ ggc_alloc (size)\n   result = entry->page + object_offset;\n \n #ifdef ENABLE_GC_CHECKING\n+  /* Keep poisoning-by-writing-0xaf the object, in an attempt to keep the\n+     exact same semantics in presence of memory bugs, regardless of\n+     ENABLE_VALGRIND_CHECKING.  We override this request below.  Drop the\n+     handle to avoid handle leak.  */\n+  VALGRIND_DISCARD (VALGRIND_MAKE_WRITABLE (result, OBJECT_SIZE (order)));\n+\n   /* `Poison' the entire allocated object, including any padding at\n      the end.  */\n   memset (result, 0xaf, OBJECT_SIZE (order));\n+\n+  /* Make the bytes after the end of the object unaccessible.  Discard the\n+     handle to avoid handle leak.  */\n+  VALGRIND_DISCARD (VALGRIND_MAKE_NOACCESS ((char *) result + size,\n+\t\t\t\t\t    OBJECT_SIZE (order) - size));\n #endif\n \n+  /* Tell Valgrind that the memory is there, but its content isn't\n+     defined.  The bytes at the end of the object are still marked\n+     unaccessible.  */\n+  VALGRIND_DISCARD (VALGRIND_MAKE_WRITABLE (result, size));\n+\n   /* Keep track of how many bytes are being allocated.  This\n      information is used in deciding when to collect.  */\n   G.allocated += OBJECT_SIZE (order);\n@@ -1433,7 +1464,19 @@ poison_pages ()\n \t      word = i / HOST_BITS_PER_LONG;\n \t      bit = i % HOST_BITS_PER_LONG;\n \t      if (((p->in_use_p[word] >> bit) & 1) == 0)\n-\t\tmemset (p->page + i * size, 0xa5, size);\n+\t\t{\n+\t\t  char *object = p->page + i * size;\n+\n+\t\t  /* Keep poison-by-write when we expect to use Valgrind,\n+\t\t     so the exact same memory semantics is kept, in case\n+\t\t     there are memory errors.  We override this request\n+\t\t     below.  */\n+\t\t  VALGRIND_DISCARD (VALGRIND_MAKE_WRITABLE (object, size));\n+\t\t  memset (object, 0xa5, size);\n+\n+\t\t  /* Drop the handle to avoid handle leak.  */\n+\t\t  VALGRIND_DISCARD (VALGRIND_MAKE_NOACCESS (object, size));\n+\t\t}\n \t    }\n \t}\n     }"}]}