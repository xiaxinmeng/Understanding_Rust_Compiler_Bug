{"sha": "bc9053abce09400d12ced72db73bff5dbbd05007", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmM5MDUzYWJjZTA5NDAwZDEyY2VkNzJkYjczYmZmNWRiYmQwNTAwNw==", "commit": {"author": {"name": "Paolo Carlini", "email": "pcarlini@suse.de", "date": "2005-12-08T11:32:37Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2005-12-08T11:32:37Z"}, "message": "re PR libstdc++/24617 (vector vs __erase_at_end)\n\n2005-12-08  Paolo Carlini  <pcarlini@suse.de>\n\n\t* include/bits/stl_vector.h (vector<>::size, resize, capacity,\n\toperator[]): Avoid troubles with ADL, user defined operators\n\tand __normal_iterator.\n\t(_M_erase_at_end): Fix to take a pointer.\n\t(clear): Adjust call.\n\t* include/bits/vector.tcc (vector<>::insert(iterator, const\n\tvalue_type&), erase(iterator, iterator), operator=(const\n\tvector<>&), _M_assign_aux(input_iterator_tag), _M_insert_aux,\n\t_M_fill_insert, _M_range_insert): Likewise.\n\t(_M_fill_assign, _M_assign_aux(forward_iterator_tag)): Adjust\n\t_M_erase_at_end call.\n\t* testsuite/23_containers/vector/types/1.cc: New.\n\n2005-12-08  Paolo Carlini  <pcarlini@suse.de>\n\n\tPR libstdc++/24617\n\t* include/bits/stl_vector.h (vector<>::_M_erase_at_end): New.\n\t(vector<>::clear, resize): Use it.\n\t* include/bits/vector.tcc (vector<>::erase(iterator, iterator),\n\t_M_fill_assign, _M_assign_aux): Likewise.\n\n\t* testsuite/23_containers/vector/modifiers/erase/1.cc: New.\n\nFrom-SVN: r108227", "tree": {"sha": "1fe2e6170d3fe3e2a5153f90964e9890a3320fd2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1fe2e6170d3fe3e2a5153f90964e9890a3320fd2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bc9053abce09400d12ced72db73bff5dbbd05007", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc9053abce09400d12ced72db73bff5dbbd05007", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc9053abce09400d12ced72db73bff5dbbd05007", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc9053abce09400d12ced72db73bff5dbbd05007/comments", "author": null, "committer": null, "parents": [{"sha": "b2a93c0a5a9119b67977cac08dd6c08571d778b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2a93c0a5a9119b67977cac08dd6c08571d778b0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b2a93c0a5a9119b67977cac08dd6c08571d778b0"}], "stats": {"total": 384, "additions": 303, "deletions": 81}, "files": [{"sha": "6785bb39d20c5385b8aee9787051f1a49c6eb73e", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc9053abce09400d12ced72db73bff5dbbd05007/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc9053abce09400d12ced72db73bff5dbbd05007/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=bc9053abce09400d12ced72db73bff5dbbd05007", "patch": "@@ -1,3 +1,28 @@\n+2005-12-08  Paolo Carlini  <pcarlini@suse.de>\n+\n+\t* include/bits/stl_vector.h (vector<>::size, resize, capacity,\n+\toperator[]): Avoid troubles with ADL, user defined operators\n+\tand __normal_iterator.\n+\t(_M_erase_at_end): Fix to take a pointer.\n+\t(clear): Adjust call.\n+\t* include/bits/vector.tcc (vector<>::insert(iterator, const\n+\tvalue_type&), erase(iterator, iterator), operator=(const\n+\tvector<>&), _M_assign_aux(input_iterator_tag), _M_insert_aux,\n+\t_M_fill_insert, _M_range_insert): Likewise.\n+\t(_M_fill_assign, _M_assign_aux(forward_iterator_tag)): Adjust\n+\t_M_erase_at_end call.\n+\t* testsuite/23_containers/vector/types/1.cc: New.\n+\n+2005-12-08  Paolo Carlini  <pcarlini@suse.de>\n+\n+\tPR libstdc++/24617\n+\t* include/bits/stl_vector.h (vector<>::_M_erase_at_end): New.\n+\t(vector<>::clear, resize): Use it.\n+\t* include/bits/vector.tcc (vector<>::erase(iterator, iterator),\n+\t_M_fill_assign, _M_assign_aux): Likewise.\n+\n+\t* testsuite/23_containers/vector/modifiers/erase/1.cc: New.\n+\n 2005-12-07  Paolo Carlini  <pcarlini@suse.de>\n \n \t* docs/html/configopts.html ([--enable-libstdcxx-allocator]):"}, {"sha": "7d8519cdfdd4738d2c2412d1b45e904b0dd3f89e", "filename": "libstdc++-v3/include/bits/stl_vector.h", "status": "modified", "additions": 23, "deletions": 17, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc9053abce09400d12ced72db73bff5dbbd05007/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc9053abce09400d12ced72db73bff5dbbd05007/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h?ref=bc9053abce09400d12ced72db73bff5dbbd05007", "patch": "@@ -266,8 +266,7 @@ namespace _GLIBCXX_STD\n        */\n       ~vector()\n       { std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,\n-\t\t      _M_get_Tp_allocator());\n-      }\n+\t\t      _M_get_Tp_allocator()); }\n \n       /**\n        *  @brief  %Vector assignment operator.\n@@ -326,7 +325,7 @@ namespace _GLIBCXX_STD\n        */\n       iterator\n       begin()\n-      { return iterator (this->_M_impl._M_start); }\n+      { return iterator(this->_M_impl._M_start); }\n \n       /**\n        *  Returns a read-only (constant) iterator that points to the\n@@ -335,7 +334,7 @@ namespace _GLIBCXX_STD\n        */\n       const_iterator\n       begin() const\n-      { return const_iterator (this->_M_impl._M_start); }\n+      { return const_iterator(this->_M_impl._M_start); }\n \n       /**\n        *  Returns a read/write iterator that points one past the last\n@@ -344,7 +343,7 @@ namespace _GLIBCXX_STD\n        */\n       iterator\n       end()\n-      { return iterator (this->_M_impl._M_finish); }\n+      { return iterator(this->_M_impl._M_finish); }\n \n       /**\n        *  Returns a read-only (constant) iterator that points one past\n@@ -353,7 +352,7 @@ namespace _GLIBCXX_STD\n        */\n       const_iterator\n       end() const\n-      { return const_iterator (this->_M_impl._M_finish); }\n+      { return const_iterator(this->_M_impl._M_finish); }\n \n       /**\n        *  Returns a read/write reverse iterator that points to the\n@@ -395,7 +394,7 @@ namespace _GLIBCXX_STD\n       /**  Returns the number of elements in the %vector.  */\n       size_type\n       size() const\n-      { return size_type(end() - begin()); }\n+      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }\n \n       /**  Returns the size() of the largest possible %vector.  */\n       size_type\n@@ -417,7 +416,7 @@ namespace _GLIBCXX_STD\n       resize(size_type __new_size, value_type __x = value_type())\n       {\n \tif (__new_size < size())\n-\t  erase(begin() + __new_size, end());\n+\t  _M_erase_at_end(this->_M_impl._M_start + __new_size);\n \telse\n \t  insert(end(), __new_size - size(), __x);\n       }\n@@ -428,8 +427,8 @@ namespace _GLIBCXX_STD\n        */\n       size_type\n       capacity() const\n-      { return size_type(const_iterator(this->_M_impl._M_end_of_storage)\n-\t\t\t - begin()); }\n+      { return size_type(this->_M_impl._M_end_of_storage\n+\t\t\t - this->_M_impl._M_start); }\n \n       /**\n        *  Returns true if the %vector is empty.  (Thus begin() would\n@@ -473,7 +472,7 @@ namespace _GLIBCXX_STD\n        */\n       reference\n       operator[](size_type __n)\n-      { return *(begin() + __n); }\n+      { return *(this->_M_impl._M_start + __n); }\n \n       /**\n        *  @brief  Subscript access to the data contained in the %vector.\n@@ -488,7 +487,7 @@ namespace _GLIBCXX_STD\n        */\n       const_reference\n       operator[](size_type __n) const\n-      { return *(begin() + __n); }\n+      { return *(this->_M_impl._M_start + __n); }\n \n     protected:\n       /// @if maint Safety check used only from at().  @endif\n@@ -742,11 +741,7 @@ namespace _GLIBCXX_STD\n        */\n       void\n       clear()\n-      {\n-\tstd::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,\n-\t\t      _M_get_Tp_allocator());\n-\tthis->_M_impl._M_finish = this->_M_impl._M_start;\n-      }\n+      { _M_erase_at_end(this->_M_impl._M_start); }\n \n     protected:\n       /**\n@@ -910,6 +905,17 @@ namespace _GLIBCXX_STD\n       // Called by insert(p,x)\n       void\n       _M_insert_aux(iterator __position, const value_type& __x);\n+\n+      // Internal erase functions follow.\n+\n+      // Called by erase(q1,q2), clear(), resize(), _M_fill_assign,\n+      // _M_assign_aux.\n+      void\n+      _M_erase_at_end(pointer __pos)\n+      {\n+\tstd::_Destroy(__pos, this->_M_impl._M_finish, _M_get_Tp_allocator());\n+\tthis->_M_impl._M_finish = __pos;\n+      }\n     };\n \n "}, {"sha": "9213057a2abcd026075e5bb21b43e1f98697125d", "filename": "libstdc++-v3/include/bits/vector.tcc", "status": "modified", "additions": 65, "deletions": 64, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc9053abce09400d12ced72db73bff5dbbd05007/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvector.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc9053abce09400d12ced72db73bff5dbbd05007/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvector.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvector.tcc?ref=bc9053abce09400d12ced72db73bff5dbbd05007", "patch": "@@ -73,8 +73,7 @@ namespace _GLIBCXX_STD\n       if (this->capacity() < __n)\n \t{\n \t  const size_type __old_size = size();\n-\t  pointer __tmp = _M_allocate_and_copy(__n,\n-\t\t\t\t\t       this->_M_impl._M_start,\n+\t  pointer __tmp = _M_allocate_and_copy(__n, this->_M_impl._M_start,\n \t\t\t\t\t       this->_M_impl._M_finish);\n \t  std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,\n \t\t\t_M_get_Tp_allocator());\n@@ -101,7 +100,7 @@ namespace _GLIBCXX_STD\n \t}\n       else\n         _M_insert_aux(__position, __x);\n-      return begin() + __n;\n+      return iterator(this->_M_impl._M_start + __n);\n     }\n \n   template<typename _Tp, typename _Alloc>\n@@ -121,9 +120,9 @@ namespace _GLIBCXX_STD\n     vector<_Tp, _Alloc>::\n     erase(iterator __first, iterator __last)\n     {\n-      iterator __i(std::copy(__last, end(), __first));\n-      std::_Destroy(__i, end(), _M_get_Tp_allocator());\n-      this->_M_impl._M_finish = this->_M_impl._M_finish - (__last - __first);\n+      if (__last != end())\n+\tstd::copy(__last, end(), __first);\n+      _M_erase_at_end(__first.base() + (end() - __last));\n       return __first;\n     }\n \n@@ -149,15 +148,16 @@ namespace _GLIBCXX_STD\n \t    }\n \t  else if (size() >= __xlen)\n \t    {\n-\t      iterator __i(std::copy(__x.begin(), __x.end(), begin()));\n-\t      std::_Destroy(__i, end(), _M_get_Tp_allocator());\n+\t      std::_Destroy(std::copy(__x.begin(), __x.end(), begin()),\n+\t\t\t    end(), _M_get_Tp_allocator());\n \t    }\n \t  else\n \t    {\n-\t      std::copy(__x.begin(), __x.begin() + size(),\n+\t      std::copy(__x._M_impl._M_start, __x._M_impl._M_start + size(),\n \t\t\tthis->_M_impl._M_start);\n-\t      std::__uninitialized_copy_a(__x.begin() + size(),\n-\t\t\t\t\t  __x.end(), this->_M_impl._M_finish,\n+\t      std::__uninitialized_copy_a(__x._M_impl._M_start + size(),\n+\t\t\t\t\t  __x._M_impl._M_finish,\n+\t\t\t\t\t  this->_M_impl._M_finish,\n \t\t\t\t\t  _M_get_Tp_allocator());\n \t    }\n \t  this->_M_impl._M_finish = this->_M_impl._M_start + __xlen;\n@@ -184,7 +184,7 @@ namespace _GLIBCXX_STD\n \t  this->_M_impl._M_finish += __n - size();\n \t}\n       else\n-        erase(std::fill_n(begin(), __n, __val), end());\n+        _M_erase_at_end(std::fill_n(this->_M_impl._M_start, __n, __val));\n     }\n \n   template<typename _Tp, typename _Alloc>\n@@ -194,11 +194,12 @@ namespace _GLIBCXX_STD\n       _M_assign_aux(_InputIterator __first, _InputIterator __last,\n \t\t    std::input_iterator_tag)\n       {\n-\titerator __cur(begin());\n-\tfor (; __first != __last && __cur != end(); ++__cur, ++__first)\n+\tpointer __cur(this->_M_impl._M_start);\n+\tfor (; __first != __last && __cur != this->_M_impl._M_finish;\n+\t     ++__cur, ++__first)\n \t  *__cur = *__first;\n \tif (__first == __last)\n-\t  erase(__cur, end());\n+\t  _M_erase_at_end(__cur);\n \telse\n \t  insert(end(), __first, __last);\n       }\n@@ -225,12 +226,7 @@ namespace _GLIBCXX_STD\n \t    this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;\n \t  }\n \telse if (size() >= __len)\n-\t  {\n-\t    iterator __new_finish(std::copy(__first, __last,\n-\t\t\t\t       this->_M_impl._M_start));\n-\t    std::_Destroy(__new_finish, end(), _M_get_Tp_allocator());\n-\t    this->_M_impl._M_finish = __new_finish.base();\n-\t  }\n+\t  _M_erase_at_end(std::copy(__first, __last, this->_M_impl._M_start));\n \telse\n \t  {\n \t    _ForwardIterator __mid = __first;\n@@ -254,9 +250,9 @@ namespace _GLIBCXX_STD\n \t\t\t\t  *(this->_M_impl._M_finish - 1));\n \t  ++this->_M_impl._M_finish;\n \t  _Tp __x_copy = __x;\n-\t  std::copy_backward(__position,\n-\t\t\t     iterator(this->_M_impl._M_finish-2),\n-\t\t\t     iterator(this->_M_impl._M_finish-1));\n+\t  std::copy_backward(__position.base(),\n+\t\t\t     this->_M_impl._M_finish - 2,\n+\t\t\t     this->_M_impl._M_finish - 1);\n \t  *__position = __x_copy;\n \t}\n       else\n@@ -272,36 +268,36 @@ namespace _GLIBCXX_STD\n \t  if (__len < __old_size)\n \t    __len = this->max_size();\n \n-\t  iterator __new_start(this->_M_allocate(__len));\n-\t  iterator __new_finish(__new_start);\n+\t  pointer __new_start(this->_M_allocate(__len));\n+\t  pointer __new_finish(__new_start);\n \t  try\n \t    {\n \t      __new_finish =\n-\t\tstd::__uninitialized_copy_a(iterator(this->_M_impl._M_start),\n-\t\t\t\t\t    __position,\n-\t\t\t\t\t    __new_start,\n+\t\tstd::__uninitialized_copy_a(this->_M_impl._M_start,\n+\t\t\t\t\t    __position.base(), __new_start,\n \t\t\t\t\t    _M_get_Tp_allocator());\n-\t      this->_M_impl.construct(__new_finish.base(), __x);\n+\t      this->_M_impl.construct(__new_finish, __x);\n \t      ++__new_finish;\n \t      __new_finish =\n-\t\tstd::__uninitialized_copy_a(__position,\n-\t\t\t\t\t    iterator(this->_M_impl._M_finish),\n+\t\tstd::__uninitialized_copy_a(__position.base(),\n+\t\t\t\t\t    this->_M_impl._M_finish,\n \t\t\t\t\t    __new_finish,\n \t\t\t\t\t    _M_get_Tp_allocator());\n \t    }\n \t  catch(...)\n \t    {\n \t      std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator());\n-\t      _M_deallocate(__new_start.base(),__len);\n+\t      _M_deallocate(__new_start, __len);\n \t      __throw_exception_again;\n \t    }\n-\t  std::_Destroy(begin(), end(), _M_get_Tp_allocator());\n+\t  std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,\n+\t\t\t_M_get_Tp_allocator());\n \t  _M_deallocate(this->_M_impl._M_start,\n \t\t\tthis->_M_impl._M_end_of_storage\n \t\t\t- this->_M_impl._M_start);\n-\t  this->_M_impl._M_start = __new_start.base();\n-\t  this->_M_impl._M_finish = __new_finish.base();\n-\t  this->_M_impl._M_end_of_storage = __new_start.base() + __len;\n+\t  this->_M_impl._M_start = __new_start;\n+\t  this->_M_impl._M_finish = __new_finish;\n+\t  this->_M_impl._M_end_of_storage = __new_start + __len;\n \t}\n     }\n \n@@ -317,17 +313,18 @@ namespace _GLIBCXX_STD\n \t    {\n \t      value_type __x_copy = __x;\n \t      const size_type __elems_after = end() - __position;\n-\t      iterator __old_finish(this->_M_impl._M_finish);\n+\t      pointer __old_finish(this->_M_impl._M_finish);\n \t      if (__elems_after > __n)\n \t\t{\n \t\t  std::__uninitialized_copy_a(this->_M_impl._M_finish - __n,\n \t\t\t\t\t      this->_M_impl._M_finish,\n \t\t\t\t\t      this->_M_impl._M_finish,\n \t\t\t\t\t      _M_get_Tp_allocator());\n \t\t  this->_M_impl._M_finish += __n;\n-\t\t  std::copy_backward(__position, __old_finish - __n,\n+\t\t  std::copy_backward(__position.base(), __old_finish - __n,\n \t\t\t\t     __old_finish);\n-\t\t  std::fill(__position, __position + __n, __x_copy);\n+\t\t  std::fill(__position.base(), __position.base() + __n,\n+\t\t\t    __x_copy);\n \t\t}\n \t      else\n \t\t{\n@@ -336,11 +333,11 @@ namespace _GLIBCXX_STD\n \t\t\t\t\t\t__x_copy,\n \t\t\t\t\t\t_M_get_Tp_allocator());\n \t\t  this->_M_impl._M_finish += __n - __elems_after;\n-\t\t  std::__uninitialized_copy_a(__position, __old_finish,\n+\t\t  std::__uninitialized_copy_a(__position.base(), __old_finish,\n \t\t\t\t\t      this->_M_impl._M_finish,\n \t\t\t\t\t      _M_get_Tp_allocator());\n \t\t  this->_M_impl._M_finish += __elems_after;\n-\t\t  std::fill(__position, __old_finish, __x_copy);\n+\t\t  std::fill(__position.base(), __old_finish, __x_copy);\n \t\t}\n \t    }\n \t  else\n@@ -354,36 +351,39 @@ namespace _GLIBCXX_STD\n \t      if (__len < __old_size)\n \t\t__len = this->max_size();\n \n-\t      iterator __new_start(this->_M_allocate(__len));\n-\t      iterator __new_finish(__new_start);\n+\t      pointer __new_start(this->_M_allocate(__len));\n+\t      pointer __new_finish(__new_start);\n \t      try\n \t\t{\n \t\t  __new_finish =\n-\t\t    std::__uninitialized_copy_a(begin(), __position,\n+\t\t    std::__uninitialized_copy_a(this->_M_impl._M_start,\n+\t\t\t\t\t\t__position.base(),\n \t\t\t\t\t\t__new_start,\n \t\t\t\t\t\t_M_get_Tp_allocator());\n \t\t  std::__uninitialized_fill_n_a(__new_finish, __n, __x,\n \t\t\t\t\t\t_M_get_Tp_allocator());\n \t\t  __new_finish += __n;\n \t\t  __new_finish =\n-\t\t    std::__uninitialized_copy_a(__position, end(), __new_finish,\n+\t\t    std::__uninitialized_copy_a(__position.base(),\n+\t\t\t\t\t\tthis->_M_impl._M_finish,\n+\t\t\t\t\t\t__new_finish,\n \t\t\t\t\t\t_M_get_Tp_allocator());\n \t\t}\n \t      catch(...)\n \t\t{\n \t\t  std::_Destroy(__new_start, __new_finish,\n \t\t\t\t_M_get_Tp_allocator());\n-\t\t  _M_deallocate(__new_start.base(), __len);\n+\t\t  _M_deallocate(__new_start, __len);\n \t\t  __throw_exception_again;\n \t\t}\n \t      std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,\n \t\t\t    _M_get_Tp_allocator());\n \t      _M_deallocate(this->_M_impl._M_start,\n \t\t\t    this->_M_impl._M_end_of_storage\n \t\t\t    - this->_M_impl._M_start);\n-\t      this->_M_impl._M_start = __new_start.base();\n-\t      this->_M_impl._M_finish = __new_finish.base();\n-\t      this->_M_impl._M_end_of_storage = __new_start.base() + __len;\n+\t      this->_M_impl._M_start = __new_start;\n+\t      this->_M_impl._M_finish = __new_finish;\n+\t      this->_M_impl._M_end_of_storage = __new_start + __len;\n \t    }\n \t}\n     }\n@@ -415,15 +415,15 @@ namespace _GLIBCXX_STD\n \t\t\t  - this->_M_impl._M_finish) >= __n)\n \t      {\n \t\tconst size_type __elems_after = end() - __position;\n-\t\titerator __old_finish(this->_M_impl._M_finish);\n+\t\tpointer __old_finish(this->_M_impl._M_finish);\n \t\tif (__elems_after > __n)\n \t\t  {\n \t\t    std::__uninitialized_copy_a(this->_M_impl._M_finish - __n,\n \t\t\t\t\t\tthis->_M_impl._M_finish,\n \t\t\t\t\t\tthis->_M_impl._M_finish,\n \t\t\t\t\t\t_M_get_Tp_allocator());\n \t\t    this->_M_impl._M_finish += __n;\n-\t\t    std::copy_backward(__position, __old_finish - __n,\n+\t\t    std::copy_backward(__position.base(), __old_finish - __n,\n \t\t\t\t       __old_finish);\n \t\t    std::copy(__first, __last, __position);\n \t\t  }\n@@ -435,7 +435,8 @@ namespace _GLIBCXX_STD\n \t\t\t\t\t\tthis->_M_impl._M_finish,\n \t\t\t\t\t\t_M_get_Tp_allocator());\n \t\t    this->_M_impl._M_finish += __n - __elems_after;\n-\t\t    std::__uninitialized_copy_a(__position, __old_finish,\n+\t\t    std::__uninitialized_copy_a(__position.base(),\n+\t\t\t\t\t\t__old_finish,\n \t\t\t\t\t\tthis->_M_impl._M_finish,\n \t\t\t\t\t\t_M_get_Tp_allocator());\n \t\t    this->_M_impl._M_finish += __elems_after;\n@@ -453,39 +454,39 @@ namespace _GLIBCXX_STD\n \t\tif (__len < __old_size)\n \t\t  __len = this->max_size();\n \n-\t\titerator __new_start(this->_M_allocate(__len));\n-\t\titerator __new_finish(__new_start);\n+\t\tpointer __new_start(this->_M_allocate(__len));\n+\t\tpointer __new_finish(__new_start);\n \t\ttry\n \t\t  {\n \t\t    __new_finish =\n-\t\t      std::__uninitialized_copy_a(iterator(this->_M_impl._M_start),\n-\t\t\t\t\t\t  __position,\n+\t\t      std::__uninitialized_copy_a(this->_M_impl._M_start,\n+\t\t\t\t\t\t  __position.base(),\n \t\t\t\t\t\t  __new_start,\n \t\t\t\t\t\t  _M_get_Tp_allocator());\n \t\t    __new_finish =\n \t\t      std::__uninitialized_copy_a(__first, __last, __new_finish,\n \t\t\t\t\t\t  _M_get_Tp_allocator());\n \t\t    __new_finish =\n-\t\t      std::__uninitialized_copy_a(__position,\n-\t\t\t\t\t\t  iterator(this->_M_impl._M_finish),\n+\t\t      std::__uninitialized_copy_a(__position.base(),\n+\t\t\t\t\t\t  this->_M_impl._M_finish,\n \t\t\t\t\t\t  __new_finish,\n \t\t\t\t\t\t  _M_get_Tp_allocator());\n \t\t  }\n \t\tcatch(...)\n \t\t  {\n-\t\t    std::_Destroy(__new_start,__new_finish,\n+\t\t    std::_Destroy(__new_start, __new_finish,\n \t\t\t\t  _M_get_Tp_allocator());\n-\t\t    _M_deallocate(__new_start.base(), __len);\n+\t\t    _M_deallocate(__new_start, __len);\n \t\t    __throw_exception_again;\n \t\t  }\n \t\tstd::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,\n \t\t\t      _M_get_Tp_allocator());\n \t\t_M_deallocate(this->_M_impl._M_start,\n \t\t\t      this->_M_impl._M_end_of_storage\n \t\t\t      - this->_M_impl._M_start);\n-\t\tthis->_M_impl._M_start = __new_start.base();\n-\t\tthis->_M_impl._M_finish = __new_finish.base();\n-\t\tthis->_M_impl._M_end_of_storage = __new_start.base() + __len;\n+\t\tthis->_M_impl._M_start = __new_start;\n+\t\tthis->_M_impl._M_finish = __new_finish;\n+\t\tthis->_M_impl._M_end_of_storage = __new_start + __len;\n \t      }\n \t  }\n       }"}, {"sha": "0a3cffb90b20197d72fac06b6e09ecd9b700b71d", "filename": "libstdc++-v3/testsuite/23_containers/vector/modifiers/erase/1.cc", "status": "added", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc9053abce09400d12ced72db73bff5dbbd05007/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fmodifiers%2Ferase%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc9053abce09400d12ced72db73bff5dbbd05007/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fmodifiers%2Ferase%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fmodifiers%2Ferase%2F1.cc?ref=bc9053abce09400d12ced72db73bff5dbbd05007", "patch": "@@ -0,0 +1,136 @@\n+// 2005-11-02  Paolo Carlini  <pcarlini@suse.de>\n+\n+// Copyright (C) 2005 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 23.2.4.3 vector modifiers\n+\n+#include <vector>\n+#include <testsuite_hooks.h>\n+\n+const int  A[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15};\n+const int A1[] = {0, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15};\n+const int A2[] = {0, 2, 3, 4, 10, 11, 12, 13, 14, 15};\n+const int A3[] = {0, 2, 3, 4, 10, 11};\n+const int A4[] = {4, 10, 11};\n+const int A5[] = {4, 10};\n+const int  N = sizeof(A)  / sizeof(int);\n+const int N1 = sizeof(A1) / sizeof(int);\n+const int N2 = sizeof(A2) / sizeof(int);\n+const int N3 = sizeof(A3) / sizeof(int);\n+const int N4 = sizeof(A4) / sizeof(int);\n+const int N5 = sizeof(A5) / sizeof(int);\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  typedef std::vector<int>   vec_type;\n+  typedef vec_type::iterator iterator_type;\n+\n+  vec_type v(A, A + N);\n+\n+  iterator_type it1 = v.erase(v.begin() + 1);\n+  VERIFY( it1 == v.begin() + 1 );\n+  VERIFY( v.size() == N1 );\n+  VERIFY( std::equal(v.begin(), v.end(), A1) );\n+  \n+  iterator_type it2 = v.erase(v.begin() + 4, v.begin() + 9);\n+  VERIFY( it2 == v.begin() + 4 );\n+  VERIFY( v.size() == N2 );\n+  VERIFY( std::equal(v.begin(), v.end(), A2) );\n+  \n+  iterator_type it3 = v.erase(v.begin() + 6, v.end());\n+  VERIFY( it3 == v.begin() + 6 );\n+  VERIFY( v.size() == N3 );\n+  VERIFY( std::equal(v.begin(), v.end(), A3) );\n+\n+  iterator_type it4 = v.erase(v.begin(), v.begin() + 3);\n+  VERIFY( it4 == v.begin() );\n+  VERIFY( v.size() == N4 );\n+  VERIFY( std::equal(v.begin(), v.end(), A4) );\n+\n+  iterator_type it5 = v.erase(v.begin() + 2);\n+  VERIFY( it5 == v.begin() + 2 );\n+  VERIFY( v.size() == N5 );\n+  VERIFY( std::equal(v.begin(), v.end(), A5) );\n+\n+  iterator_type it6 = v.erase(v.begin(), v.end());\n+  VERIFY( it6 == v.begin() );\n+  VERIFY( v.empty() );\n+}\n+\n+void\n+test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  typedef std::vector<std::vector<int> >   vec_type;\n+  typedef vec_type::iterator          iterator_type;\n+\n+  vec_type v, v1, v2, v3, v4, v5;\n+  for (int i = 0; i < N; ++i)\n+    v.push_back(std::vector<int>(1, A[i]));\n+  for (int i = 0; i < N1; ++i)\n+    v1.push_back(std::vector<int>(1, A1[i]));\n+  for (int i = 0; i < N2; ++i)\n+    v2.push_back(std::vector<int>(1, A2[i]));\n+  for (int i = 0; i < N3; ++i)\n+    v3.push_back(std::vector<int>(1, A3[i]));\n+  for (int i = 0; i < N4; ++i)\n+    v4.push_back(std::vector<int>(1, A4[i]));\n+  for (int i = 0; i < N5; ++i)\n+    v5.push_back(std::vector<int>(1, A5[i]));\n+  \n+  iterator_type it1 = v.erase(v.begin() + 1);\n+  VERIFY( it1 == v.begin() + 1 );\n+  VERIFY( v.size() == N1 );\n+  VERIFY( std::equal(v.begin(), v.end(), v1.begin()) );\n+  \n+  iterator_type it2 = v.erase(v.begin() + 4, v.begin() + 9);\n+  VERIFY( it2 == v.begin() + 4 );\n+  VERIFY( v.size() == N2 );\n+  VERIFY( std::equal(v.begin(), v.end(), v2.begin()) );\n+  \n+  iterator_type it3 = v.erase(v.begin() + 6, v.end());\n+  VERIFY( it3 == v.begin() + 6 );\n+  VERIFY( v.size() == N3 );\n+  VERIFY( std::equal(v.begin(), v.end(), v3.begin()) );\n+\n+  iterator_type it4 = v.erase(v.begin(), v.begin() + 3);\n+  VERIFY( it4 == v.begin() );\n+  VERIFY( v.size() == N4 );\n+  VERIFY( std::equal(v.begin(), v.end(), v4.begin()) );\n+\n+  iterator_type it5 = v.erase(v.begin() + 2);\n+  VERIFY( it5 == v.begin() + 2 );\n+  VERIFY( v.size() == N5 );\n+  VERIFY( std::equal(v.begin(), v.end(), v5.begin()) );\n+\n+  iterator_type it6 = v.erase(v.begin(), v.end());\n+  VERIFY( it6 == v.begin() );\n+  VERIFY( v.empty() );\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "09a00dfbf87789a154934da29c9bdae4fbddac14", "filename": "libstdc++-v3/testsuite/23_containers/vector/types/1.cc", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc9053abce09400d12ced72db73bff5dbbd05007/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Ftypes%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc9053abce09400d12ced72db73bff5dbbd05007/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Ftypes%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Ftypes%2F1.cc?ref=bc9053abce09400d12ced72db73bff5dbbd05007", "patch": "@@ -0,0 +1,54 @@\n+// 2005-12-01  Paolo Carlini  <pcarlini@suse.de>\n+\n+// Copyright (C) 2005 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// { dg-do compile }\n+\n+#include <vector>\n+\n+namespace N\n+{\n+  struct X { };\n+\n+  template<typename T>\n+    X operator+(T, std::size_t)\n+    { return X(); }\n+\n+  template<typename T>\n+    X operator-(T, T)\n+    { return X(); }\n+}\n+\n+int main()\n+{\n+  std::vector<N::X> v(5);\n+  const std::vector<N::X> w(1);\n+\n+  v[0];\n+  w[0];\n+  v.size();\n+  v.capacity();\n+  v.resize(1);\n+  v.insert(v.begin(), N::X());\n+  v.insert(v.begin(), 1, N::X());\n+  v.insert(v.begin(), w.begin(), w.end());\n+  v = w;\n+\n+  return 0;\n+}"}]}