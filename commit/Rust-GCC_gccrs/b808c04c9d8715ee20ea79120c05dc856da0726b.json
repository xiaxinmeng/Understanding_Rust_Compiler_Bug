{"sha": "b808c04c9d8715ee20ea79120c05dc856da0726b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjgwOGMwNGM5ZDg3MTVlZTIwZWE3OTEyMGMwNWRjODU2ZGEwNzI2Yg==", "commit": {"author": {"name": "Ulrich Weigand", "email": "uweigand@de.ibm.com", "date": "2002-09-03T16:30:32Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2002-09-03T16:30:32Z"}, "message": "s390.c (s390_decompose_address): Remove STRICT parameter and register validity checks.\n\n\t* config/s390/s390.c (s390_decompose_address): Remove STRICT parameter\n\tand register validity checks.\n\t(general_s_operand): Adapt to s390_decompose_address interface change.\n\t(q_constraint): Likewise.\n\t(s390_expand_plus_operand): Likewise.\n\t(legitimiate_address_p): Likewise.\n\t(legitimate_la_operand_p): Likewise.\n\t(legitimize_la_operand): Likewise.\n\t(print_operand_address): Likewise.\n\t(print_operand): Likewise.\n\nFrom-SVN: r56759", "tree": {"sha": "4d1c342c8a0967c2fc077376f29760ede12f1ac5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4d1c342c8a0967c2fc077376f29760ede12f1ac5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b808c04c9d8715ee20ea79120c05dc856da0726b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b808c04c9d8715ee20ea79120c05dc856da0726b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b808c04c9d8715ee20ea79120c05dc856da0726b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b808c04c9d8715ee20ea79120c05dc856da0726b/comments", "author": null, "committer": null, "parents": [{"sha": "ee453219a98247aeb62a3d0c33e72c222f53096b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee453219a98247aeb62a3d0c33e72c222f53096b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ee453219a98247aeb62a3d0c33e72c222f53096b"}], "stats": {"total": 76, "additions": 53, "deletions": 23}, "files": [{"sha": "a2a6f2545fe8ea8f6600869c4248bcb4bf0bd3cc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b808c04c9d8715ee20ea79120c05dc856da0726b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b808c04c9d8715ee20ea79120c05dc856da0726b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b808c04c9d8715ee20ea79120c05dc856da0726b", "patch": "@@ -1,3 +1,16 @@\n+2002-09-03  Ulrich Weigand  <uweigand@de.ibm.com>\n+\n+\t* config/s390/s390.c (s390_decompose_address): Remove STRICT parameter\n+\tand register validity checks.\n+\t(general_s_operand): Adapt to s390_decompose_address interface change.\n+\t(q_constraint): Likewise.\n+\t(s390_expand_plus_operand): Likewise.\n+\t(legitimiate_address_p): Likewise.\n+\t(legitimate_la_operand_p): Likewise.\n+\t(legitimize_la_operand): Likewise.\n+\t(print_operand_address): Likewise.\n+\t(print_operand): Likewise.\n+\n Tue Sep  3 11:32:14 2002  Nicola Pero  <n.pero@mi.flashnet.it>\n \n \tPR objc/5956:"}, {"sha": "8fadf026ad28bf33d6b3824efff032ef518fe58e", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 40, "deletions": 23, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b808c04c9d8715ee20ea79120c05dc856da0726b/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b808c04c9d8715ee20ea79120c05dc856da0726b/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=b808c04c9d8715ee20ea79120c05dc856da0726b", "patch": "@@ -126,7 +126,7 @@ static int s390_branch_condition_mask PARAMS ((rtx));\n static const char *s390_branch_condition_mnemonic PARAMS ((rtx, int));\n static int check_mode PARAMS ((rtx, enum machine_mode *));\n static int general_s_operand PARAMS ((rtx, enum machine_mode, int));\n-static int s390_decompose_address PARAMS ((rtx, struct s390_address *, int));\n+static int s390_decompose_address PARAMS ((rtx, struct s390_address *));\n static int reg_used_in_mem_p PARAMS ((int, rtx));\n static int addr_generation_dependency_p PARAMS ((rtx, rtx));\n static void s390_split_branches PARAMS ((void));\n@@ -949,7 +949,7 @@ general_s_operand (op, mode, allow_immediate)\n       case MEM:\n \tif (GET_CODE (XEXP (op, 0)) == ADDRESSOF)\n \t  return 1;\n-\tif (s390_decompose_address (XEXP (op, 0), &addr, FALSE) \n+\tif (s390_decompose_address (XEXP (op, 0), &addr) \n \t    && !addr.indx)\n \t  return 1;\n \tbreak;\n@@ -1000,7 +1000,7 @@ q_constraint (op)\n   if (GET_CODE (op) != MEM)\n     return 0;\n \n-  if (!s390_decompose_address (XEXP (op, 0), &addr, FALSE))\n+  if (!s390_decompose_address (XEXP (op, 0), &addr))\n     return 0;\n \n   if (addr.indx)\n@@ -1371,6 +1371,7 @@ s390_expand_plus_operand (target, src, scratch_in)\n      register rtx scratch_in;\n {\n   rtx sum1, sum2, scratch;\n+  struct s390_address ad;\n \n   /* ??? reload apparently does not ensure that the scratch register\n      and the target do not overlap.  We absolutely require this to be\n@@ -1391,9 +1392,11 @@ s390_expand_plus_operand (target, src, scratch_in)\n   sum1 = find_replacement (&XEXP (src, 0));\n   sum2 = find_replacement (&XEXP (src, 1));\n \n-  /* Accept already valid addresses.  */\n+  /* Accept already strictly valid addresses.  */\n   src = gen_rtx_PLUS (Pmode, sum1, sum2);\n-  if (s390_decompose_address (src, NULL, 1))\n+  if (s390_decompose_address (src, &ad)\n+      && (!ad.base || REG_OK_FOR_BASE_STRICT_P (ad.base))\n+      && (!ad.indx || REG_OK_FOR_INDEX_STRICT_P (ad.indx)))\n     {\n       src = legitimize_la_operand (src);\n       emit_insn (gen_rtx_SET (VOIDmode, target, src));\n@@ -1449,8 +1452,8 @@ s390_expand_plus_operand (target, src, scratch_in)\n \n \n /* Decompose a RTL expression ADDR for a memory address into\n-   its components, returned in OUT.  The boolean STRICT \n-   specifies whether strict register checking applies.\n+   its components, returned in OUT.\n+\n    Returns 0 if ADDR is not a valid memory address, nonzero\n    otherwise.  If OUT is NULL, don't return the components,\n    but check for validity only.\n@@ -1460,10 +1463,9 @@ s390_expand_plus_operand (target, src, scratch_in)\n    canonical form so that they will be recognized.  */\n \n static int\n-s390_decompose_address (addr, out, strict)\n+s390_decompose_address (addr, out)\n      register rtx addr;\n      struct s390_address *out;\n-     int strict;\n {\n   rtx base = NULL_RTX;\n   rtx indx = NULL_RTX;\n@@ -1528,10 +1530,6 @@ s390_decompose_address (addr, out, strict)\n       if (GET_CODE (base) != REG || GET_MODE (base) != Pmode)\n \t  return FALSE;\n \n-      if ((strict && ! REG_OK_FOR_BASE_STRICT_P (base))\n-\t  || (! strict && ! REG_OK_FOR_BASE_NONSTRICT_P (base)))\n-\t  return FALSE;\n-    \n       if (REGNO (base) == BASE_REGISTER\n \t  || REGNO (base) == STACK_POINTER_REGNUM\n \t  || REGNO (base) == FRAME_POINTER_REGNUM\n@@ -1557,10 +1555,6 @@ s390_decompose_address (addr, out, strict)\n       if (GET_CODE (indx) != REG || GET_MODE (indx) != Pmode)\n \t  return FALSE;\n \n-      if ((strict && ! REG_OK_FOR_BASE_STRICT_P (indx))\n-\t  || (! strict && ! REG_OK_FOR_BASE_NONSTRICT_P (indx)))\n-\t  return FALSE;\n-    \n       if (REGNO (indx) == BASE_REGISTER\n \t  || REGNO (indx) == STACK_POINTER_REGNUM\n \t  || REGNO (indx) == FRAME_POINTER_REGNUM\n@@ -1691,7 +1685,26 @@ legitimate_address_p (mode, addr, strict)\n      register rtx addr;\n      int strict;\n {\n-  return s390_decompose_address (addr, NULL, strict);\n+  struct s390_address ad;\n+  if (!s390_decompose_address (addr, &ad))\n+    return FALSE;\n+\n+  if (strict)\n+    {\n+      if (ad.base && !REG_OK_FOR_BASE_STRICT_P (ad.base))\n+\treturn FALSE;\n+      if (ad.indx && !REG_OK_FOR_INDEX_STRICT_P (ad.indx))\n+\treturn FALSE;\n+    }\n+  else\n+    {\n+      if (ad.base && !REG_OK_FOR_BASE_NONSTRICT_P (ad.base))\n+\treturn FALSE;\n+      if (ad.indx && !REG_OK_FOR_INDEX_NONSTRICT_P (ad.indx))\n+\treturn FALSE;\n+    }\n+\n+  return TRUE;\n }\n \n /* Return 1 if OP is a valid operand for the LA instruction.\n@@ -1703,7 +1716,7 @@ legitimate_la_operand_p (op)\n      register rtx op;\n {\n   struct s390_address addr;\n-  if (!s390_decompose_address (op, &addr, FALSE))\n+  if (!s390_decompose_address (op, &addr))\n     return FALSE;\n \n   if (TARGET_64BIT || addr.pointer)\n@@ -1720,7 +1733,7 @@ legitimize_la_operand (op)\n      register rtx op;\n {\n   struct s390_address addr;\n-  if (!s390_decompose_address (op, &addr, FALSE))\n+  if (!s390_decompose_address (op, &addr))\n     abort ();\n \n   if (TARGET_64BIT || addr.pointer)\n@@ -2247,7 +2260,9 @@ print_operand_address (file, addr)\n {\n   struct s390_address ad;\n \n-  if (!s390_decompose_address (addr, &ad, TRUE))\n+  if (!s390_decompose_address (addr, &ad)\n+      || (ad.base && !REG_OK_FOR_BASE_STRICT_P (ad.base))\n+      || (ad.indx && !REG_OK_FOR_INDEX_STRICT_P (ad.indx)))\n     output_operand_lossage (\"Cannot decompose address.\");\n  \n   if (ad.disp)\n@@ -2298,7 +2313,8 @@ print_operand (file, x, code)\n         struct s390_address ad;\n \n         if (GET_CODE (x) != MEM\n-            || !s390_decompose_address (XEXP (x, 0), &ad, TRUE)\n+            || !s390_decompose_address (XEXP (x, 0), &ad)\n+\t    || (ad.base && !REG_OK_FOR_BASE_STRICT_P (ad.base))\n             || ad.indx)\n           abort ();\n \n@@ -2314,7 +2330,8 @@ print_operand (file, x, code)\n         struct s390_address ad;\n \n         if (GET_CODE (x) != MEM\n-            || !s390_decompose_address (XEXP (x, 0), &ad, TRUE)\n+            || !s390_decompose_address (XEXP (x, 0), &ad)\n+\t    || (ad.base && !REG_OK_FOR_BASE_STRICT_P (ad.base))\n             || ad.indx)\n           abort ();\n "}]}