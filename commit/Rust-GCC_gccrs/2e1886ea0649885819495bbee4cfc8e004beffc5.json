{"sha": "2e1886ea0649885819495bbee4cfc8e004beffc5", "node_id": "C_kwDOANBUbNoAKDJlMTg4NmVhMDY0OTg4NTgxOTQ5NWJiZWU0Y2ZjOGUwMDRiZWZmYzU", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2021-11-12T17:33:02Z"}, "committer": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2021-11-12T17:33:02Z"}, "message": "aarch64: Add vf_factor to aarch64_vec_op_count\n\n-mtune=neoverse-512tvb sets the likely SVE vector length to 128 bits,\nbut it also takes into account Neoverse V1, which is a 256-bit target.\nThis patch adds this VF (VL) factor to aarch64_vec_op_count.\n\ngcc/\n\t* config/aarch64/aarch64.c (aarch64_vec_op_count::m_vf_factor):\n\tNew member variable.\n\t(aarch64_vec_op_count::aarch64_vec_op_count): Add a parameter for it.\n\t(aarch64_vec_op_count::vf_factor): New function.\n\t(aarch64_vector_costs::aarch64_vector_costs): When costing for\n\tneoverse-512tvb, pass a vf_factor of 2 for the Neoverse V1 version\n\tof an SVE loop.\n\t(aarch64_vector_costs::adjust_body_cost): Read the vf factor\n\tinstead of hard-coding 2.", "tree": {"sha": "ecf2e2329fe985eb4213d5d9bb32f79c5d53c091", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ecf2e2329fe985eb4213d5d9bb32f79c5d53c091"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2e1886ea0649885819495bbee4cfc8e004beffc5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e1886ea0649885819495bbee4cfc8e004beffc5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e1886ea0649885819495bbee4cfc8e004beffc5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e1886ea0649885819495bbee4cfc8e004beffc5/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a82ffd436193d97b0b47441f540e61001f16a682", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a82ffd436193d97b0b47441f540e61001f16a682", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a82ffd436193d97b0b47441f540e61001f16a682"}], "stats": {"total": 30, "additions": 24, "deletions": 6}, "files": [{"sha": "5fa64fe5350aa0ffe43f8308bfabcaaf056aadba", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 24, "deletions": 6, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e1886ea0649885819495bbee4cfc8e004beffc5/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e1886ea0649885819495bbee4cfc8e004beffc5/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=2e1886ea0649885819495bbee4cfc8e004beffc5", "patch": "@@ -14711,9 +14711,12 @@ class aarch64_vec_op_count\n {\n public:\n   aarch64_vec_op_count () = default;\n-  aarch64_vec_op_count (const aarch64_vec_issue_info *, unsigned int);\n+  aarch64_vec_op_count (const aarch64_vec_issue_info *, unsigned int,\n+\t\t\tunsigned int = 1);\n \n   unsigned int vec_flags () const { return m_vec_flags; }\n+  unsigned int vf_factor () const { return m_vf_factor; }\n+\n   const aarch64_base_vec_issue_info *base_issue_info () const;\n   const aarch64_simd_vec_issue_info *simd_issue_info () const;\n   const aarch64_sve_vec_issue_info *sve_issue_info () const;\n@@ -14753,13 +14756,23 @@ class aarch64_vec_op_count\n      - If M_VEC_FLAGS & VEC_ANY_SVE is nonzero then this structure describes\n        SVE code.  */\n   unsigned int m_vec_flags = 0;\n+\n+  /* Assume that, when the code is executing on the core described\n+     by M_ISSUE_INFO, one iteration of the loop will handle M_VF_FACTOR\n+     times more data than the vectorizer anticipates.\n+\n+     This is only ever different from 1 for SVE.  It allows us to consider\n+     what would happen on a 256-bit SVE target even when the -mtune\n+     parameters say that the \u201clikely\u201d SVE length is 128 bits.  */\n+  unsigned int m_vf_factor = 1;\n };\n \n aarch64_vec_op_count::\n aarch64_vec_op_count (const aarch64_vec_issue_info *issue_info,\n-\t\t      unsigned int vec_flags)\n+\t\t      unsigned int vec_flags, unsigned int vf_factor)\n   : m_issue_info (issue_info),\n-    m_vec_flags (vec_flags)\n+    m_vec_flags (vec_flags),\n+    m_vf_factor (vf_factor)\n {\n }\n \n@@ -14973,7 +14986,11 @@ aarch64_vector_costs::aarch64_vector_costs (vec_info *vinfo,\n       if (m_vec_flags & VEC_ANY_SVE)\n \tm_advsimd_ops.quick_push ({ issue_info, VEC_ADVSIMD });\n       if (aarch64_tune_params.vec_costs == &neoverse512tvb_vector_cost)\n-\tm_ops.quick_push ({ &neoversev1_vec_issue_info, m_vec_flags });\n+\t{\n+\t  unsigned int vf_factor = (m_vec_flags & VEC_ANY_SVE) ? 2 : 1;\n+\t  m_ops.quick_push ({ &neoversev1_vec_issue_info, m_vec_flags,\n+\t\t\t      vf_factor });\n+\t}\n     }\n }\n \n@@ -16111,8 +16128,9 @@ adjust_body_cost (loop_vec_info loop_vinfo,\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t     \"Neoverse V1 estimate:\\n\");\n-\t  adjust_body_cost_sve (&m_ops[1], scalar_cycles_per_iter * 2,\n-\t\t\t\tadvsimd_cycles_per_iter * 2,\n+\t  auto vf_factor = m_ops[1].vf_factor ();\n+\t  adjust_body_cost_sve (&m_ops[1], scalar_cycles_per_iter * vf_factor,\n+\t\t\t\tadvsimd_cycles_per_iter * vf_factor,\n \t\t\t\tcould_use_advsimd, orig_body_cost,\n \t\t\t\t&body_cost, &should_disparage);\n \t}"}]}