{"sha": "09da15320b1856ba010101ca5a1c2766d493c1b4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDlkYTE1MzIwYjE4NTZiYTAxMDEwMWNhNWExYzI3NjZkNDkzYzFiNA==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2002-12-13T00:17:22Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2002-12-13T00:17:22Z"}, "message": "c-decl.c: Fix a comment typo.\n\n\t* c-decl.c: Fix a comment typo.\n\t* cfg.c: Likewise.\n\t* cfgcleanup.c: Likewise.\n\t* cfglayout.c: Likewise.\n\t* cfgrtl.c: Likewise.\n\t* c-typeck.c: Likewise.\n\t* dominance.c: Likewise.\n\t* dwarf2asm.c: Likewise.\n\t* dwarfout.c: Likewise.\n\t* expmed.c: Likewise.\n\t* expr.c: Likewise.\n\t* final.c: Likewise.\n\t* flow.c: Likewise.\n\t* function.c: Likewise.\n\t* gcc.c: Likewise.\n\t* genautomata.c: Likewise.\n\t* integrate.c: Likewise.\n\t* loop.c: Likewise.\n\t* loop.h: Likewise.\n\t* output.h: Likewise.\n\t* profile.c: Likewise.\n\t* ra.h: Likewise.\n\t* reload1.c: Likewise.\n\t* reload.c: Likewise.\n\t* sched-rgn.c: Likewise.\n\t* stmt.c: Likewise.\n\t* tree.h: Likewise.\n\t* vmsdbgout.c: Likewise.\n\nFrom-SVN: r60085", "tree": {"sha": "3f4977682a21560e2c4d370fc537230aad533512", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3f4977682a21560e2c4d370fc537230aad533512"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/09da15320b1856ba010101ca5a1c2766d493c1b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09da15320b1856ba010101ca5a1c2766d493c1b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/09da15320b1856ba010101ca5a1c2766d493c1b4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09da15320b1856ba010101ca5a1c2766d493c1b4/comments", "author": null, "committer": null, "parents": [{"sha": "7930523de8ea4ce820f4a83b2a87b076b5d0ff37", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7930523de8ea4ce820f4a83b2a87b076b5d0ff37", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7930523de8ea4ce820f4a83b2a87b076b5d0ff37"}], "stats": {"total": 105, "additions": 68, "deletions": 37}, "files": [{"sha": "36c3f9491d291f8c5837a0f9d80787a01a7193f4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09da15320b1856ba010101ca5a1c2766d493c1b4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09da15320b1856ba010101ca5a1c2766d493c1b4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=09da15320b1856ba010101ca5a1c2766d493c1b4", "patch": "@@ -1,3 +1,34 @@\n+2002-12-12  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* c-decl.c: Fix a comment typo.\n+\t* cfg.c: Likewise.\n+\t* cfgcleanup.c: Likewise.\n+\t* cfglayout.c: Likewise.\n+\t* cfgrtl.c: Likewise.\n+\t* c-typeck.c: Likewise.\n+\t* dominance.c: Likewise.\n+\t* dwarf2asm.c: Likewise.\n+\t* dwarfout.c: Likewise.\n+\t* expmed.c: Likewise.\n+\t* expr.c: Likewise.\n+\t* final.c: Likewise.\n+\t* flow.c: Likewise.\n+\t* function.c: Likewise.\n+\t* gcc.c: Likewise.\n+\t* genautomata.c: Likewise.\n+\t* integrate.c: Likewise.\n+\t* loop.c: Likewise.\n+\t* loop.h: Likewise.\n+\t* output.h: Likewise.\n+\t* profile.c: Likewise.\n+\t* ra.h: Likewise.\n+\t* reload1.c: Likewise.\n+\t* reload.c: Likewise.\n+\t* sched-rgn.c: Likewise.\n+\t* stmt.c: Likewise.\n+\t* tree.h: Likewise.\n+\t* vmsdbgout.c: Likewise.\n+\n 2002-12-12  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* config/h8300/h8300.md: Add a new peephole2."}, {"sha": "bb7d881ba80df51601019595b3caeb6c7860d6e9", "filename": "gcc/c-decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09da15320b1856ba010101ca5a1c2766d493c1b4/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09da15320b1856ba010101ca5a1c2766d493c1b4/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=09da15320b1856ba010101ca5a1c2766d493c1b4", "patch": "@@ -1726,7 +1726,7 @@ pushdecl (x)\n \t}\n \n       /* If we are processing a typedef statement, generate a whole new\n-\t ..._TYPE node (which will be just an variant of the existing\n+\t ..._TYPE node (which will be just a variant of the existing\n \t ..._TYPE node with identical properties) and then install the\n \t TYPE_DECL node generated to represent the typedef name as the\n \t TYPE_NAME of this brand new (duplicate) ..._TYPE node."}, {"sha": "c63344d6682f76308fdc223faba039a950ad35de", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09da15320b1856ba010101ca5a1c2766d493c1b4/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09da15320b1856ba010101ca5a1c2766d493c1b4/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=09da15320b1856ba010101ca5a1c2766d493c1b4", "patch": "@@ -5214,7 +5214,7 @@ really_start_incremental_init (type)\n \t    constructor_max_index = build_int_2 (-1, -1);\n \n \t  /* constructor_max_index needs to be an INTEGER_CST.  Attempts\n-\t     to initialize VLAs will cause an proper error; avoid tree\n+\t     to initialize VLAs will cause a proper error; avoid tree\n \t     checking errors as well by setting a safe value.  */\n \t  if (constructor_max_index\n \t      && TREE_CODE (constructor_max_index) != INTEGER_CST)\n@@ -5404,7 +5404,7 @@ push_init_level (implicit)\n \t    constructor_max_index = build_int_2 (-1, -1);\n \n \t  /* constructor_max_index needs to be an INTEGER_CST.  Attempts\n-\t     to initialize VLAs will cause an proper error; avoid tree\n+\t     to initialize VLAs will cause a proper error; avoid tree\n \t     checking errors as well by setting a safe value.  */\n \t  if (constructor_max_index\n \t      && TREE_CODE (constructor_max_index) != INTEGER_CST)"}, {"sha": "9dc69d88348171b6ff199266c7bcb2cd7e945404", "filename": "gcc/cfg.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09da15320b1856ba010101ca5a1c2766d493c1b4/gcc%2Fcfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09da15320b1856ba010101ca5a1c2766d493c1b4/gcc%2Fcfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfg.c?ref=09da15320b1856ba010101ca5a1c2766d493c1b4", "patch": "@@ -684,7 +684,7 @@ static void *first_block_aux_obj = 0;\n static struct obstack edge_aux_obstack;\n static void *first_edge_aux_obj = 0;\n \n-/* Allocate an memory block of SIZE as BB->aux.  The obstack must\n+/* Allocate a memory block of SIZE as BB->aux.  The obstack must\n    be first initialized by alloc_aux_for_blocks.  */\n \n inline void\n@@ -752,7 +752,7 @@ free_aux_for_blocks ()\n   clear_aux_for_blocks ();\n }\n \n-/* Allocate an memory edge of SIZE as BB->aux.  The obstack must\n+/* Allocate a memory edge of SIZE as BB->aux.  The obstack must\n    be first initialized by alloc_aux_for_edges.  */\n \n inline void"}, {"sha": "67ddfa90b89967478e0f5738978d1c1ba9ffe867", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09da15320b1856ba010101ca5a1c2766d493c1b4/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09da15320b1856ba010101ca5a1c2766d493c1b4/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=09da15320b1856ba010101ca5a1c2766d493c1b4", "patch": "@@ -1246,7 +1246,7 @@ outgoing_edges_match (mode, bb1, bb2)\n       return match;\n     }\n \n-  /* Generic case - we are seeing an computed jump, table jump or trapping\n+  /* Generic case - we are seeing a computed jump, table jump or trapping\n      instruction.  */\n \n   /* First ensure that the instructions match.  There may be many outgoing"}, {"sha": "3214e808886a1fb9ef37a219baacf27e9dc33192", "filename": "gcc/cfglayout.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09da15320b1856ba010101ca5a1c2766d493c1b4/gcc%2Fcfglayout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09da15320b1856ba010101ca5a1c2766d493c1b4/gcc%2Fcfglayout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfglayout.c?ref=09da15320b1856ba010101ca5a1c2766d493c1b4", "patch": "@@ -708,7 +708,7 @@ cfg_layout_can_duplicate_bb_p (bb)\n   if (bb == EXIT_BLOCK_PTR || bb == ENTRY_BLOCK_PTR)\n     return false;\n \n-  /* Duplicating fallthru block to exit would require adding an jump\n+  /* Duplicating fallthru block to exit would require adding a jump\n      and splitting the real last BB.  */\n   for (s = bb->succ; s; s = s->succ_next)\n     if (s->dest == EXIT_BLOCK_PTR && s->flags & EDGE_FALLTHRU)\n@@ -862,7 +862,7 @@ cfg_layout_redirect_edge (e, dest)\n   src->next_bb = old_next_bb;\n }\n \n-/* Create an duplicate of the basic block BB and redirect edge E into it.  */\n+/* Create a duplicate of the basic block BB and redirect edge E into it.  */\n \n basic_block\n cfg_layout_duplicate_bb (bb, e)"}, {"sha": "c8ad0984e00aa36b9cb64da9ff578129a0ef36b7", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09da15320b1856ba010101ca5a1c2766d493c1b4/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09da15320b1856ba010101ca5a1c2766d493c1b4/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=09da15320b1856ba010101ca5a1c2766d493c1b4", "patch": "@@ -793,7 +793,7 @@ try_redirect_by_replacing_jump (e, target)\n /* Return last loop_beg note appearing after INSN, before start of next\n    basic block.  Return INSN if there are no such notes.\n \n-   When emitting jump to redirect an fallthru edge, it should always appear\n+   When emitting jump to redirect a fallthru edge, it should always appear\n    after the LOOP_BEG notes, as loop optimizer expect loop to either start by\n    fallthru edge or jump following the LOOP_BEG note jumping to the loop exit\n    test.  */"}, {"sha": "1bba31fb57c9499c2caf1a54be3493d0ce3c9192", "filename": "gcc/dominance.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09da15320b1856ba010101ca5a1c2766d493c1b4/gcc%2Fdominance.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09da15320b1856ba010101ca5a1c2766d493c1b4/gcc%2Fdominance.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdominance.c?ref=09da15320b1856ba010101ca5a1c2766d493c1b4", "patch": "@@ -101,7 +101,7 @@ struct dom_info\n      number of that node in DFS order counted from 1.  This is an index\n      into most of the other arrays in this structure.  */\n   TBB *dfs_order;\n-  /* If x is the DFS-index of a node which corresponds with an basic block,\n+  /* If x is the DFS-index of a node which corresponds with a basic block,\n      dfs_to_bb[x] is that basic block.  Note, that in our structure there are\n      more nodes that basic blocks, so only dfs_to_bb[dfs_order[bb->index]]==bb\n      is true for every basic block bb, but not the opposite.  */"}, {"sha": "b5a87de863004fc050d02f496c9662c1bc2d2e30", "filename": "gcc/dwarf2asm.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09da15320b1856ba010101ca5a1c2766d493c1b4/gcc%2Fdwarf2asm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09da15320b1856ba010101ca5a1c2766d493c1b4/gcc%2Fdwarf2asm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2asm.c?ref=09da15320b1856ba010101ca5a1c2766d493c1b4", "patch": "@@ -564,7 +564,7 @@ dw2_asm_output_data_uleb128 VPARAMS ((unsigned HOST_WIDE_INT value,\n   VA_CLOSE (ap);\n }\n \n-/* Output an signed LEB128 quantity.  */\n+/* Output a signed LEB128 quantity.  */\n \n void\n dw2_asm_output_data_sleb128 VPARAMS ((HOST_WIDE_INT value,"}, {"sha": "bbbfcfcd718b17bf96771c73c472fea37e1d0431", "filename": "gcc/dwarfout.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09da15320b1856ba010101ca5a1c2766d493c1b4/gcc%2Fdwarfout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09da15320b1856ba010101ca5a1c2766d493c1b4/gcc%2Fdwarfout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarfout.c?ref=09da15320b1856ba010101ca5a1c2766d493c1b4", "patch": "@@ -162,7 +162,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n  is required by the current DWARF draft specification.\n \n  Specifically, the current DWARF draft specification seems to require that\n- the type of an non-unsigned integral bit-field member of a struct or union\n+ the type of a non-unsigned integral bit-field member of a struct or union\n  type be represented as either a \"signed\" type or as a \"plain\" type,\n  depending upon the exact set of keywords that were used in the\n  type specification for the given bit-field member.  It was felt (by the"}, {"sha": "405e45f8089df9760d94dc56789c9d9434fb2e4b", "filename": "gcc/expmed.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09da15320b1856ba010101ca5a1c2766d493c1b4/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09da15320b1856ba010101ca5a1c2766d493c1b4/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=09da15320b1856ba010101ca5a1c2766d493c1b4", "patch": "@@ -2922,7 +2922,7 @@ expand_mult_highpart (mode, op0, cnst1, target, unsignedp, max_cost)\n    the result is exact for inputs up to 0x1fffffff.\n    The input range can be reduced by using cross-sum rules.\n    For odd divisors >= 3, the following table gives right shift counts\n-   so that if an number is shifted by an integer multiple of the given\n+   so that if a number is shifted by an integer multiple of the given\n    amount, the remainder stays the same:\n    2, 4, 3, 6, 10, 12, 4, 8, 18, 6, 11, 20, 18, 0, 5, 10, 12, 0, 12, 20,\n    14, 12, 23, 21, 8, 0, 20, 18, 0, 0, 6, 12, 0, 22, 0, 18, 20, 30, 0, 0,"}, {"sha": "e5f7ae51783875005dca9517eeac29db4d8889c1", "filename": "gcc/expr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09da15320b1856ba010101ca5a1c2766d493c1b4/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09da15320b1856ba010101ca5a1c2766d493c1b4/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=09da15320b1856ba010101ca5a1c2766d493c1b4", "patch": "@@ -4358,7 +4358,7 @@ store_expr (exp, target, want_value)\n       dont_return_target = 1;\n     }\n   else if (GET_CODE (target) == SUBREG && SUBREG_PROMOTED_VAR_P (target))\n-    /* If this is an scalar in a register that is stored in a wider mode\n+    /* If this is a scalar in a register that is stored in a wider mode\n        than the declared mode, compute the result into its declared mode\n        and then convert to the wider mode.  Our value is the computed\n        expression.  */"}, {"sha": "312ae76f8fccb589ec0a08c85b83ba7a144542f9", "filename": "gcc/final.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09da15320b1856ba010101ca5a1c2766d493c1b4/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09da15320b1856ba010101ca5a1c2766d493c1b4/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=09da15320b1856ba010101ca5a1c2766d493c1b4", "patch": "@@ -994,7 +994,7 @@ compute_alignments ()\n \t    }\n \t}\n       /* In case block is frequent and reached mostly by non-fallthru edge,\n-\t align it.  It is most likely an first block of loop.  */\n+\t align it.  It is most likely a first block of loop.  */\n       if (has_fallthru\n \t  && branch_frequency + fallthru_frequency > BB_FREQ_MAX / 10\n \t  && branch_frequency > fallthru_frequency * 2)\n@@ -4011,7 +4011,7 @@ leaf_function_p ()\n   return 1;\n }\n \n-/* Return 1 if branch is an forward branch.\n+/* Return 1 if branch is a forward branch.\n    Uses insn_shuid array, so it works only in the final pass.  May be used by\n    output templates to customary add branch prediction hints.\n  */"}, {"sha": "9ac4f2f9fd8b8695693bc10a0ec41c937244021b", "filename": "gcc/flow.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09da15320b1856ba010101ca5a1c2766d493c1b4/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09da15320b1856ba010101ca5a1c2766d493c1b4/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=09da15320b1856ba010101ca5a1c2766d493c1b4", "patch": "@@ -1380,7 +1380,7 @@ calculate_global_regs_live (blocks_in, blocks_out, flags)\n }\n \n \f\n-/* This structure is used to pass parameters to an from the\n+/* This structure is used to pass parameters to and from the\n    the function find_regno_partial(). It is used to pass in the\n    register number we are looking, as well as to return any rtx\n    we find.  */"}, {"sha": "26334f124da87fda50002efa417d9544d8ef640f", "filename": "gcc/function.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09da15320b1856ba010101ca5a1c2766d493c1b4/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09da15320b1856ba010101ca5a1c2766d493c1b4/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=09da15320b1856ba010101ca5a1c2766d493c1b4", "patch": "@@ -2380,7 +2380,7 @@ fixup_var_refs_1 (var, promoted_mode, loc, insn, replacements, no_share)\n \t       copy SET_SRC (x) to SET_DEST (x) in some way.  So\n \t       we generate the move and see whether it requires more\n \t       than one insn.  If it does, we emit those insns and\n-\t       delete INSN.  Otherwise, we an just replace the pattern\n+\t       delete INSN.  Otherwise, we can just replace the pattern\n \t       of INSN; we have already verified above that INSN has\n \t       no other function that to do X.  */\n "}, {"sha": "b05367326ff005c1fed6557bbe02c27d38a6110d", "filename": "gcc/gcc.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09da15320b1856ba010101ca5a1c2766d493c1b4/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09da15320b1856ba010101ca5a1c2766d493c1b4/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=09da15320b1856ba010101ca5a1c2766d493c1b4", "patch": "@@ -420,7 +420,7 @@ or with constant text in a single argument.\n \tand substitute the full name found.\n  %eSTR  Print STR as an error message.  STR is terminated by a newline.\n         Use this when inconsistent options are detected.\n- %nSTR  Print STR as an notice.  STR is terminated by a newline.\n+ %nSTR  Print STR as a notice.  STR is terminated by a newline.\n  %x{OPTION}\tAccumulate an option for %X.\n  %X\tOutput the accumulated linker options specified by compilations.\n  %Y\tOutput the accumulated assembler options specified by compilations.\n@@ -4399,7 +4399,7 @@ do_spec_1 (spec, inswitch, soft_matched_part)\n \t    }\n \t    break;\n \t  case 'n':\n-\t    /* %nfoo means report an notice with `foo' on stderr.  */\n+\t    /* %nfoo means report a notice with `foo' on stderr.  */\n \t    {\n \t      const char *q = p;\n \t      char *buf;"}, {"sha": "8c48d6ad637a08f74b0d6d6f0ef1064ded0e3994", "filename": "gcc/genautomata.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09da15320b1856ba010101ca5a1c2766d493c1b4/gcc%2Fgenautomata.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09da15320b1856ba010101ca5a1c2766d493c1b4/gcc%2Fgenautomata.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenautomata.c?ref=09da15320b1856ba010101ca5a1c2766d493c1b4", "patch": "@@ -2492,7 +2492,7 @@ add_excls (dest_list, source_list, excl_pos)\n     }\n }\n \n-/* Checking NAMES in an presence clause vector and returning formed\n+/* Checking NAMES in a presence clause vector and returning formed\n    unit_set_el_list.  The function is called only after processing all\n    exclusion sets.  */\n static unit_set_el_t\n@@ -4531,7 +4531,7 @@ get_excl_set (in_set)\n /* The page contains abstract data for work with presence/absence sets\n    (see presence_set/absence_set in file rtl.def).  */\n \n-/* The following variables refer to correspondingly an presence and an\n+/* The following variables refer to correspondingly a presence and an\n    absence set returned by get_presence_absence_set.  This is bit\n    string of length equal to cpu units number.  */\n static reserv_sets_t presence_set, absence_set;"}, {"sha": "6746b3f450f1000c5e7826cd509f7a409ad3d6a0", "filename": "gcc/integrate.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09da15320b1856ba010101ca5a1c2766d493c1b4/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09da15320b1856ba010101ca5a1c2766d493c1b4/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=09da15320b1856ba010101ca5a1c2766d493c1b4", "patch": "@@ -861,7 +861,7 @@ expand_inline_function (fndecl, parms, target, ignore, type,\n \n      ??? These numbers are quite arbitrary and were obtained by\n      experimentation.  At some point, we should try to allocate the\n-     table after all the parameters are set up so we an more accurately\n+     table after all the parameters are set up so we can more accurately\n      estimate the number of pseudos we will need.  */\n \n   VARRAY_CONST_EQUIV_INIT (map->const_equiv_varray,"}, {"sha": "d7abe5ff654d605d4d5410e2bd3bf69debe618c4", "filename": "gcc/loop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09da15320b1856ba010101ca5a1c2766d493c1b4/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09da15320b1856ba010101ca5a1c2766d493c1b4/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=09da15320b1856ba010101ca5a1c2766d493c1b4", "patch": "@@ -2884,7 +2884,7 @@ find_and_verify_loops (f, loops)\n \n \t\t\t/* If no suitable BARRIER was found, create a suitable\n \t\t\t   one before TARGET.  Since TARGET is a fall through\n-\t\t\t   path, we'll need to insert an jump around our block\n+\t\t\t   path, we'll need to insert a jump around our block\n \t\t\t   and add a BARRIER before TARGET.\n \n \t\t\t   This creates an extra unconditional jump outside"}, {"sha": "362013f39781ff39386ac741adf65537d3243c1b", "filename": "gcc/loop.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09da15320b1856ba010101ca5a1c2766d493c1b4/gcc%2Floop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09da15320b1856ba010101ca5a1c2766d493c1b4/gcc%2Floop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.h?ref=09da15320b1856ba010101ca5a1c2766d493c1b4", "patch": "@@ -248,7 +248,7 @@ struct loop_reg\n      During code motion, a negative value indicates a reg that has\n      been made a candidate; in particular -2 means that it is an\n      candidate that we know is equal to a constant and -1 means that\n-     it is an candidate not known equal to a constant.  After code\n+     it is a candidate not known equal to a constant.  After code\n      motion, regs moved have 0 (which is accurate now) while the\n      failed candidates have the original number of times set.\n "}, {"sha": "0f089719082198b56c2a631620cb0799507e166c", "filename": "gcc/output.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09da15320b1856ba010101ca5a1c2766d493c1b4/gcc%2Foutput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09da15320b1856ba010101ca5a1c2766d493c1b4/gcc%2Foutput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foutput.h?ref=09da15320b1856ba010101ca5a1c2766d493c1b4", "patch": "@@ -118,7 +118,7 @@ extern void split_double\tPARAMS ((rtx, rtx *, rtx *));\n /* Return nonzero if this function has no function calls.  */\n extern int leaf_function_p\tPARAMS ((void));\n \n-/* Return 1 if branch is an forward branch.\n+/* Return 1 if branch is a forward branch.\n    Uses insn_shuid array, so it works only in the final pass.  May be used by\n    output templates to add branch prediction hints, for example.  */\n extern int final_forward_branch_p PARAMS ((rtx));"}, {"sha": "a70dc6176215d67f26c61c7afc261d8889b63a9c", "filename": "gcc/profile.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09da15320b1856ba010101ca5a1c2766d493c1b4/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09da15320b1856ba010101ca5a1c2766d493c1b4/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=09da15320b1856ba010101ca5a1c2766d493c1b4", "patch": "@@ -1109,7 +1109,7 @@ union_groups (bb1, bb2)\n /* This function searches all of the edges in the program flow graph, and puts\n    as many bad edges as possible onto the spanning tree.  Bad edges include\n    abnormals edges, which can't be instrumented at the moment.  Since it is\n-   possible for fake edges to form an cycle, we will have to develop some\n+   possible for fake edges to form a cycle, we will have to develop some\n    better way in the future.  Also put critical edges to the tree, since they\n    are more expensive to instrument.  */\n \n@@ -1128,7 +1128,7 @@ find_spanning_tree (el)\n   /* Add fake edge exit to entry we can't instrument.  */\n   union_groups (EXIT_BLOCK_PTR, ENTRY_BLOCK_PTR);\n \n-  /* First add all abnormal edges to the tree unless they form an cycle. Also\n+  /* First add all abnormal edges to the tree unless they form a cycle. Also\n      add all edges to EXIT_BLOCK_PTR to avoid inserting profiling code behind\n      setting return value from function.  */\n   for (i = 0; i < num_edges; i++)\n@@ -1148,7 +1148,7 @@ find_spanning_tree (el)\n \t}\n     }\n \n-  /* Now insert all critical edges to the tree unless they form an cycle.  */\n+  /* Now insert all critical edges to the tree unless they form a cycle.  */\n   for (i = 0; i < num_edges; i++)\n     {\n       edge e = INDEX_EDGE (el, i);"}, {"sha": "d3c1f1ae43eda1c6f2234941875d34c82b11fe5b", "filename": "gcc/ra.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09da15320b1856ba010101ca5a1c2766d493c1b4/gcc%2Fra.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09da15320b1856ba010101ca5a1c2766d493c1b4/gcc%2Fra.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fra.h?ref=09da15320b1856ba010101ca5a1c2766d493c1b4", "patch": "@@ -303,7 +303,7 @@ struct web_link\n   struct web *web;\n };\n \n-/* A subconflict is part of an conflict edge to track precisely,\n+/* A subconflict is part of a conflict edge to track precisely,\n    which parts of two webs conflict, in case not all of both webs do.  */\n struct sub_conflict\n {"}, {"sha": "a5069241cc3efb515d651c12dd1175a9891296db", "filename": "gcc/reload.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09da15320b1856ba010101ca5a1c2766d493c1b4/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09da15320b1856ba010101ca5a1c2766d493c1b4/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=09da15320b1856ba010101ca5a1c2766d493c1b4", "patch": "@@ -2143,13 +2143,13 @@ operands_match_p (x, y)\n   /* If two operands must match, because they are really a single\n      operand of an assembler insn, then two postincrements are invalid\n      because the assembler insn would increment only once.\n-     On the other hand, an postincrement matches ordinary indexing\n+     On the other hand, a postincrement matches ordinary indexing\n      if the postincrement is the output operand.  */\n   if (code == POST_DEC || code == POST_INC || code == POST_MODIFY)\n     return operands_match_p (XEXP (x, 0), y);\n   /* Two preincrements are invalid\n      because the assembler insn would increment only once.\n-     On the other hand, an preincrement matches ordinary indexing\n+     On the other hand, a preincrement matches ordinary indexing\n      if the preincrement is the input operand.\n      In this case, return 2, since some callers need to do special\n      things when this happens.  */"}, {"sha": "399b1f1de2d1c6d842a0e297d4cc46be74441594", "filename": "gcc/reload1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09da15320b1856ba010101ca5a1c2766d493c1b4/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09da15320b1856ba010101ca5a1c2766d493c1b4/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=09da15320b1856ba010101ca5a1c2766d493c1b4", "patch": "@@ -9464,7 +9464,7 @@ fixup_abnormal_edges ()\n     {\n       edge e;\n \n-      /* Look for cases we are interested in - an calls or instructions causing\n+      /* Look for cases we are interested in - calls or instructions causing\n          exceptions.  */\n       for (e = bb->succ; e; e = e->succ_next)\n \t{"}, {"sha": "88545b29b0945e2c8fe676b48d916522a5b36bfb", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09da15320b1856ba010101ca5a1c2766d493c1b4/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09da15320b1856ba010101ca5a1c2766d493c1b4/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=09da15320b1856ba010101ca5a1c2766d493c1b4", "patch": "@@ -637,7 +637,7 @@ find_rgns (edge_list, dom)\n   /* Note if a block is a natural loop header.  */\n   sbitmap header;\n \n-  /* Note if a block is an natural inner loop header.  */\n+  /* Note if a block is a natural inner loop header.  */\n   sbitmap inner;\n \n   /* Note if a block is in the block queue.  */"}, {"sha": "f283b7590c6b27f6d41387eaf1733b0c17ca6720", "filename": "gcc/stmt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09da15320b1856ba010101ca5a1c2766d493c1b4/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09da15320b1856ba010101ca5a1c2766d493c1b4/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=09da15320b1856ba010101ca5a1c2766d493c1b4", "patch": "@@ -5244,7 +5244,7 @@ expand_end_case_type (orig_index, orig_type)\n \n   do_pending_stack_adjust ();\n \n-  /* This might get an spurious warning in the presence of a syntax error;\n+  /* This might get a spurious warning in the presence of a syntax error;\n      it could be fixed by moving the call to check_seenlabel after the\n      check for error_mark_node, and copying the code of check_seenlabel that\n      deals with case_stack->data.case_stmt.line_number_status /"}, {"sha": "36e7fd4eeb36782ee038abd4addbc27023bdb750", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09da15320b1856ba010101ca5a1c2766d493c1b4/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09da15320b1856ba010101ca5a1c2766d493c1b4/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=09da15320b1856ba010101ca5a1c2766d493c1b4", "patch": "@@ -457,7 +457,7 @@ extern void tree_vec_elt_check_failed PARAMS ((int, int, const char *,\n    is sufficient to check bounds at the time the reference is seated,\n    and assume that all future uses of the reference are safe, since\n    the address of references cannot change.  (2) When a reference\n-   supertype is seated to an subtype object.  The bounds \"remember\"\n+   supertype is seated to a subtype object.  The bounds \"remember\"\n    the true size of the complete object, so that subsequent upcasts of\n    the address of the reference will be checked properly (is such a\n    thing valid C++?).  */"}, {"sha": "3b8b8f893318e06787789dddc38fc050a0577c31", "filename": "gcc/vmsdbgout.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09da15320b1856ba010101ca5a1c2766d493c1b4/gcc%2Fvmsdbgout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09da15320b1856ba010101ca5a1c2766d493c1b4/gcc%2Fvmsdbgout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvmsdbgout.c?ref=09da15320b1856ba010101ca5a1c2766d493c1b4", "patch": "@@ -84,7 +84,7 @@ dst_file_info_entry;\n #define PTR_SIZE 4 /* Must be 32 bits for VMS debug info */\n #endif\n \n-/* Pointer to an structure of filenames referenced by this compilation unit.  */\n+/* Pointer to a structure of filenames referenced by this compilation unit.  */\n static dst_file_info_ref file_info_table;\n \n /* Total number of entries in the table (i.e. array) pointed to by"}]}