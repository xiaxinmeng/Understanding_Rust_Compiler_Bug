{"sha": "674dd90ad753944b202de7dd4dcff19bfcb5cd20", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Njc0ZGQ5MGFkNzUzOTQ0YjIwMmRlN2RkNGRjZmYxOWJmY2I1Y2QyMA==", "commit": {"author": {"name": "Yuri Rumyantsev", "email": "yuri.s.rumyantsev@intel.com", "date": "2012-06-01T11:56:00Z"}, "committer": {"name": "Kirill Yukhin", "email": "kyukhin@gcc.gnu.org", "date": "2012-06-01T11:56:00Z"}, "message": "i386.c (x86_sched_reorder): New function.\n\n       * config/i386/i386.c (x86_sched_reorder): New function.\n       Added new function x86_sched_reorder.\n\nFrom-SVN: r188107", "tree": {"sha": "9a7578fda886081ae4f0d7c2a74af4a5deca23c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9a7578fda886081ae4f0d7c2a74af4a5deca23c4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/674dd90ad753944b202de7dd4dcff19bfcb5cd20", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/674dd90ad753944b202de7dd4dcff19bfcb5cd20", "html_url": "https://github.com/Rust-GCC/gccrs/commit/674dd90ad753944b202de7dd4dcff19bfcb5cd20", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/674dd90ad753944b202de7dd4dcff19bfcb5cd20/comments", "author": null, "committer": null, "parents": [{"sha": "9ca86fc37119cfff2ddad79a3148fade09f0615b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ca86fc37119cfff2ddad79a3148fade09f0615b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ca86fc37119cfff2ddad79a3148fade09f0615b"}], "stats": {"total": 111, "additions": 111, "deletions": 0}, "files": [{"sha": "3f7bd3033877f8f82f4722690be337f908be096f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/674dd90ad753944b202de7dd4dcff19bfcb5cd20/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/674dd90ad753944b202de7dd4dcff19bfcb5cd20/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=674dd90ad753944b202de7dd4dcff19bfcb5cd20", "patch": "@@ -1,3 +1,8 @@\n+2012-06-01  Yuri Rumyantsev  <yuri.s.rumyantsev@intel.com>\n+\n+\t* config/i386/i386.c (x86_sched_reorder): New function.\n+\tAdded new function x86_sched_reorder.\n+\n 2012-06-01  Richard Guenther  <rguenther@suse.de>\n \n \t* tree-loop-distribution.c (stmt_has_scalar_dependences_outside_loop):"}, {"sha": "c6c2c5e5e5abd07461ed5caeb84f7b3dc66b373a", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/674dd90ad753944b202de7dd4dcff19bfcb5cd20/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/674dd90ad753944b202de7dd4dcff19bfcb5cd20/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=674dd90ad753944b202de7dd4dcff19bfcb5cd20", "patch": "@@ -23857,6 +23857,110 @@ ia32_multipass_dfa_lookahead (void)\n     }\n }\n \n+/* Try to reorder ready list to take advantage of Atom pipelined IMUL\n+   execution. It is applied if\n+   (1) IMUL instruction is on the top of list;\n+   (2) There exists the only producer of independent IMUL instruction in\n+       ready list;\n+   (3) Put found producer on the top of ready list.\n+   Returns issue rate.  */\n+\n+static int\n+ix86_sched_reorder(FILE *dump, int sched_verbose, rtx *ready, int *pn_ready,\n+                   int clock_var ATTRIBUTE_UNUSED)\n+{\n+  static int issue_rate = -1;\n+  int n_ready = *pn_ready;\n+  rtx insn, insn1, insn2;\n+  int i;\n+  sd_iterator_def sd_it;\n+  dep_t dep;\n+  int index = -1;\n+\n+  /* Set up issue rate.  */\n+  issue_rate = ix86_issue_rate();\n+\n+  /* Do reodering for Atom only.  */\n+  if (ix86_tune != PROCESSOR_ATOM)\n+    return issue_rate;\n+  /* Nothing to do if ready list contains only 1 instruction.  */\n+  if (n_ready <= 1)\n+    return issue_rate;\n+\n+  /* Check that IMUL instruction is on the top of ready list.  */\n+  insn = ready[n_ready - 1];\n+  if (!NONDEBUG_INSN_P (insn))\n+    return issue_rate;\n+  insn = PATTERN (insn);\n+  if (GET_CODE (insn) == PARALLEL)\n+    insn = XVECEXP (insn, 0, 0);\n+  if (GET_CODE (insn) != SET)\n+    return issue_rate;\n+  if (!(GET_CODE (SET_SRC (insn)) == MULT\n+      && GET_MODE (SET_SRC (insn)) == SImode))\n+    return issue_rate;\n+\n+  /* Search for producer of independent IMUL instruction.  */\n+  for (i = n_ready - 2; i>= 0; i--)\n+    {\n+      insn = ready[i];\n+      if (!NONDEBUG_INSN_P (insn))\n+        continue;\n+      /* Skip IMUL instruction.  */\n+      insn2 = PATTERN (insn);\n+      if (GET_CODE (insn2) == PARALLEL)\n+        insn2 = XVECEXP (insn2, 0, 0);\n+      if (GET_CODE (insn2) == SET\n+          && GET_CODE (SET_SRC (insn2)) == MULT\n+          && GET_MODE (SET_SRC (insn2)) == SImode)\n+        continue;\n+\n+      FOR_EACH_DEP (insn, SD_LIST_FORW, sd_it, dep)\n+        {\n+          rtx con;\n+\t  con = DEP_CON (dep);\n+          insn1 = PATTERN (con);\n+          if (GET_CODE (insn1) == PARALLEL)\n+            insn1 = XVECEXP (insn1, 0, 0);\n+\n+          if (GET_CODE (insn1) == SET\n+              && GET_CODE (SET_SRC (insn1)) == MULT\n+              && GET_MODE (SET_SRC (insn1)) == SImode)\n+            {\n+              sd_iterator_def sd_it1;\n+              dep_t dep1;\n+              /* Check if there is no other dependee for IMUL.  */\n+              index = i;\n+              FOR_EACH_DEP (con, SD_LIST_BACK, sd_it1, dep1)\n+                {\n+                  rtx pro;\n+                  pro = DEP_PRO (dep1);\n+                  if (pro != insn)\n+                    index = -1;\n+\t        }\n+              if (index >= 0)\n+                break;\n+            }\n+        }\n+      if (index >= 0)\n+        break;\n+    }\n+  if (index < 0)\n+    return issue_rate; /* Didn't find IMUL producer.  */\n+\n+  if (sched_verbose > 1)\n+    fprintf(dump, \";;\\tatom sched_reorder: swap %d and %d insns\\n\",\n+            INSN_UID (ready[index]), INSN_UID (ready[n_ready - 1]));\n+\n+  /* Put IMUL producer (ready[index]) at the top of ready list.  */\n+  insn1= ready[index];\n+  for (i = index; i < n_ready - 1; i++)\n+    ready[i] = ready[i + 1];\n+  ready[n_ready - 1] = insn1;\n+\n+  return issue_rate;\n+}\n+\n \f\n \n /* Model decoder of Core 2/i7.\n@@ -38500,6 +38604,8 @@ ix86_enum_va_list (int idx, const char **pname, tree *ptree)\n #define TARGET_SCHED_DISPATCH_DO do_dispatch\n #undef TARGET_SCHED_REASSOCIATION_WIDTH\n #define TARGET_SCHED_REASSOCIATION_WIDTH ix86_reassociation_width\n+#undef TARGET_SCHED_REORDER\n+#define TARGET_SCHED_REORDER ix86_sched_reorder\n \n /* The size of the dispatch window is the total number of bytes of\n    object code allowed in a window.  */"}]}