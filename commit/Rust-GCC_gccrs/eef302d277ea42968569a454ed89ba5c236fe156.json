{"sha": "eef302d277ea42968569a454ed89ba5c236fe156", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWVmMzAyZDI3N2VhNDI5Njg1NjlhNDU0ZWQ4OWJhNWMyMzZmZTE1Ng==", "commit": {"author": {"name": "Richard Sandiford", "email": "rdsandiford@googlemail.com", "date": "2008-08-28T20:02:54Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2008-08-28T20:02:54Z"}, "message": "rtl.h (simplify_subreg_regno): Declare.\n\ngcc/\n\t* rtl.h (simplify_subreg_regno): Declare.\n\t* rtlanal.c (simplify_subreg_regno): New function, split out from...\n\t* simplify-rtx.c (simplify_subreg): ...here.\n\t* reload.c (find_reloads): Use simplify_subreg_regno instead of\n\tsubreg_offset_representable_p.\n\nFrom-SVN: r139736", "tree": {"sha": "f924db7c9c66de457eab2a6629f8d764877ab80c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f924db7c9c66de457eab2a6629f8d764877ab80c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eef302d277ea42968569a454ed89ba5c236fe156", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eef302d277ea42968569a454ed89ba5c236fe156", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eef302d277ea42968569a454ed89ba5c236fe156", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eef302d277ea42968569a454ed89ba5c236fe156/comments", "author": {"login": "rsandifo", "id": 4235983, "node_id": "MDQ6VXNlcjQyMzU5ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4235983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo", "html_url": "https://github.com/rsandifo", "followers_url": "https://api.github.com/users/rsandifo/followers", "following_url": "https://api.github.com/users/rsandifo/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo/orgs", "repos_url": "https://api.github.com/users/rsandifo/repos", "events_url": "https://api.github.com/users/rsandifo/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9b3f31f2ed0f19d5c740684d85afd71152a473c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b3f31f2ed0f19d5c740684d85afd71152a473c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b3f31f2ed0f19d5c740684d85afd71152a473c0"}], "stats": {"total": 113, "additions": 79, "deletions": 34}, "files": [{"sha": "22f639bd8be9faa423646c6e39842bdb2f527e9a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eef302d277ea42968569a454ed89ba5c236fe156/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eef302d277ea42968569a454ed89ba5c236fe156/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=eef302d277ea42968569a454ed89ba5c236fe156", "patch": "@@ -1,3 +1,11 @@\n+2008-08-28  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* rtl.h (simplify_subreg_regno): Declare.\n+\t* rtlanal.c (simplify_subreg_regno): New function, split out from...\n+\t* simplify-rtx.c (simplify_subreg): ...here.\n+\t* reload.c (find_reloads): Use simplify_subreg_regno instead of\n+\tsubreg_offset_representable_p.\n+\n 2008-08-28  Manuel Lopez-Ibanez  <manu@gcc.gnu.org>\n \n \tPR c/30949"}, {"sha": "e353c50acdb19f7473c59c64e690c65eb56007c3", "filename": "gcc/reload.c", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eef302d277ea42968569a454ed89ba5c236fe156/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eef302d277ea42968569a454ed89ba5c236fe156/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=eef302d277ea42968569a454ed89ba5c236fe156", "patch": "@@ -2999,12 +2999,11 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \t      if (REG_P (SUBREG_REG (operand))\n \t\t  && REGNO (SUBREG_REG (operand)) < FIRST_PSEUDO_REGISTER)\n \t\t{\n-\t\t  if (!subreg_offset_representable_p\n-\t\t\t(REGNO (SUBREG_REG (operand)),\n-\t\t\t GET_MODE (SUBREG_REG (operand)),\n-\t\t\t SUBREG_BYTE (operand),\n-\t\t\t GET_MODE (operand)))\n-\t\t     force_reload = 1;\n+\t\t  if (simplify_subreg_regno (REGNO (SUBREG_REG (operand)),\n+\t\t\t\t\t     GET_MODE (SUBREG_REG (operand)),\n+\t\t\t\t\t     SUBREG_BYTE (operand),\n+\t\t\t\t\t     GET_MODE (operand)) < 0)\n+\t\t    force_reload = 1;\n \t\t  offset += subreg_regno_offset (REGNO (SUBREG_REG (operand)),\n \t\t\t\t\t\t GET_MODE (SUBREG_REG (operand)),\n \t\t\t\t\t\t SUBREG_BYTE (operand),"}, {"sha": "9e7d40ad6e5661874f0db75c819d2d25af36f1ae", "filename": "gcc/rtl.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eef302d277ea42968569a454ed89ba5c236fe156/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eef302d277ea42968569a454ed89ba5c236fe156/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=eef302d277ea42968569a454ed89ba5c236fe156", "patch": "@@ -1084,6 +1084,8 @@ extern unsigned int subreg_regno_offset\t(unsigned int, enum machine_mode,\n extern bool subreg_offset_representable_p (unsigned int, enum machine_mode,\n \t\t\t\t\t   unsigned int, enum machine_mode);\n extern unsigned int subreg_regno (const_rtx);\n+extern int simplify_subreg_regno (unsigned int, enum machine_mode,\n+\t\t\t\t  unsigned int, enum machine_mode);\n extern unsigned int subreg_nregs (const_rtx);\n extern unsigned int subreg_nregs_with_regno (unsigned int, const_rtx);\n extern unsigned HOST_WIDE_INT nonzero_bits (const_rtx, enum machine_mode);"}, {"sha": "9c5a1e53c7f553adc266e458987d84da3d235c14", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eef302d277ea42968569a454ed89ba5c236fe156/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eef302d277ea42968569a454ed89ba5c236fe156/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=eef302d277ea42968569a454ed89ba5c236fe156", "patch": "@@ -3244,6 +3244,64 @@ subreg_offset_representable_p (unsigned int xregno, enum machine_mode xmode,\n   return info.representable_p;\n }\n \n+/* Return the number of a YMODE register to which\n+\n+       (subreg:YMODE (reg:XMODE XREGNO) OFFSET)\n+\n+   can be simplified.  Return -1 if the subreg can't be simplified.\n+\n+   XREGNO is a hard register number.  */\n+\n+int\n+simplify_subreg_regno (unsigned int xregno, enum machine_mode xmode,\n+\t\t       unsigned int offset, enum machine_mode ymode)\n+{\n+  struct subreg_info info;\n+  unsigned int yregno;\n+\n+#ifdef CANNOT_CHANGE_MODE_CLASS\n+  /* Give the backend a chance to disallow the mode change.  */\n+  if (GET_MODE_CLASS (xmode) != MODE_COMPLEX_INT\n+      && GET_MODE_CLASS (xmode) != MODE_COMPLEX_FLOAT\n+      && REG_CANNOT_CHANGE_MODE_P (xregno, xmode, ymode))\n+    return -1;\n+#endif\n+\n+  /* We shouldn't simplify stack-related registers.  */\n+  if ((!reload_completed || frame_pointer_needed)\n+      && (xregno == FRAME_POINTER_REGNUM\n+\t  || xregno == HARD_FRAME_POINTER_REGNUM))\n+    return -1;\n+\n+  if (FRAME_POINTER_REGNUM != ARG_POINTER_REGNUM\n+      && xregno == ARG_POINTER_REGNUM)\n+    return -1;\n+\n+  if (xregno == STACK_POINTER_REGNUM)\n+    return -1;\n+\n+  /* Try to get the register offset.  */\n+  subreg_get_info (xregno, xmode, offset, ymode, &info);\n+  if (!info.representable_p)\n+    return -1;\n+\n+  /* Make sure that the offsetted register value is in range.  */\n+  yregno = xregno + info.offset;\n+  if (!HARD_REGISTER_NUM_P (yregno))\n+    return -1;\n+\n+  /* See whether (reg:YMODE YREGNO) is valid.\n+\n+     ??? We allow invalid registers if (reg:XMODE XREGNO) is also invalid.\n+     This is a kludge to work around how float/complex arguments are passed\n+     on 32-bit SPARC and should be fixed.  */\n+  if (!HARD_REGNO_MODE_OK (yregno, ymode)\n+      && HARD_REGNO_MODE_OK (xregno, xmode))\n+    return -1;\n+\n+  return (int) yregno;\n+}\n+\n /* Return the final regno that a subreg expression refers to.  */\n unsigned int\n subreg_regno (const_rtx x)"}, {"sha": "606a850622ca9f0278e77dec752e73f19384f75d", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 6, "deletions": 28, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eef302d277ea42968569a454ed89ba5c236fe156/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eef302d277ea42968569a454ed89ba5c236fe156/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=eef302d277ea42968569a454ed89ba5c236fe156", "patch": "@@ -5069,35 +5069,13 @@ simplify_subreg (enum machine_mode outermode, rtx op,\n      suppress this simplification.  If the hard register is the stack,\n      frame, or argument pointer, leave this as a SUBREG.  */\n \n-  if (REG_P (op)\n-      && REGNO (op) < FIRST_PSEUDO_REGISTER\n-#ifdef CANNOT_CHANGE_MODE_CLASS\n-      && ! (REG_CANNOT_CHANGE_MODE_P (REGNO (op), innermode, outermode)\n-\t    && GET_MODE_CLASS (innermode) != MODE_COMPLEX_INT\n-\t    && GET_MODE_CLASS (innermode) != MODE_COMPLEX_FLOAT)\n-#endif\n-      && ((reload_completed && !frame_pointer_needed)\n-\t  || (REGNO (op) != FRAME_POINTER_REGNUM\n-#if HARD_FRAME_POINTER_REGNUM != FRAME_POINTER_REGNUM\n-\t      && REGNO (op) != HARD_FRAME_POINTER_REGNUM\n-#endif\n-\t     ))\n-#if FRAME_POINTER_REGNUM != ARG_POINTER_REGNUM\n-      && REGNO (op) != ARG_POINTER_REGNUM\n-#endif\n-      && REGNO (op) != STACK_POINTER_REGNUM\n-      && subreg_offset_representable_p (REGNO (op), innermode,\n-\t\t\t\t\tbyte, outermode))\n+  if (REG_P (op) && HARD_REGISTER_P (op))\n     {\n-      unsigned int regno = REGNO (op);\n-      unsigned int final_regno\n-\t= regno + subreg_regno_offset (regno, innermode, byte, outermode);\n-\n-      /* ??? We do allow it if the current REG is not valid for\n-\t its mode.  This is a kludge to work around how float/complex\n-\t arguments are passed on 32-bit SPARC and should be fixed.  */\n-      if (HARD_REGNO_MODE_OK (final_regno, outermode)\n-\t  || ! HARD_REGNO_MODE_OK (regno, innermode))\n+      unsigned int regno, final_regno;\n+\n+      regno = REGNO (op);\n+      final_regno = simplify_subreg_regno (regno, innermode, byte, outermode);\n+      if (HARD_REGISTER_NUM_P (final_regno))\n \t{\n \t  rtx x;\n \t  int final_offset = byte;"}]}