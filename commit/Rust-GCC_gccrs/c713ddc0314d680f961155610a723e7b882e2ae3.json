{"sha": "c713ddc0314d680f961155610a723e7b882e2ae3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzcxM2RkYzAzMTRkNjgwZjk2MTE1NTYxMGE3MjNlN2I4ODJlMmFlMw==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@codesourcery.com", "date": "2014-11-13T13:54:07Z"}, "committer": {"name": "Kirill Yukhin", "email": "kyukhin@gcc.gnu.org", "date": "2014-11-13T13:54:07Z"}, "message": "[PATCH 6/7] OpenMP 4.0 offloading infrastructure: option handling.\n\ngcc/\n\t* common.opt (foffload, foffload-abi): New options.\n\t* config/i386/i386.c (ix86_offload_options): New static function.\n\t(TARGET_OFFLOAD_OPTIONS): Define.\n\t* coretypes.h (enum offload_abi): New enum.\n\t* doc/tm.texi: Regenerate.\n\t* doc/tm.texi.in (TARGET_OFFLOAD_OPTIONS): Document.\n\t* gcc.c (offload_targets): New static variable.\n\t(handle_foffload_option): New static function.\n\t(driver_handle_option): Handle OPT_foffload_.\n\t(driver::maybe_putenv_OFFLOAD_TARGETS): Set OFFLOAD_TARGET_NAMES\n\taccording to offload_targets.\n\t* hooks.c (hook_charptr_void_null): New hook.\n\t* hooks.h (hook_charptr_void_null): Declare.\n\t* lto-opts.c: Include lto-section-names.h.\n\t(lto_write_options): Append options from target offload_options hook and\n\tstore them to offload_lto section.  Do not store target-specific,\n\tdriver and diagnostic options in offload_lto section.\n\t* lto-wrapper.c (merge_and_complain): Handle OPT_foffload_ and\n\tOPT_foffload_abi_.\n\t(append_compiler_options, append_linker_options)\n\t(append_offload_options): New static functions.\n\t(compile_offload_image): Add new arguments with options.\n\tCall append_compiler_options and append_offload_options.\n\t(compile_images_for_offload_targets): Add new arguments with options.\n\t(find_and_merge_options): New static function.\n\t(run_gcc): Outline options handling into the new functions:\n\tfind_and_merge_options, append_compiler_options, append_linker_options.\n\t* opts.c (common_handle_option): Don't handle OPT_foffload_.\n\tForbid OPT_foffload_abi_ for non-offload compiler.\n\t* target.def (offload_options): New target hook.\n\nCo-Authored-By: Andrey Turetskiy <andrey.turetskiy@intel.com>\nCo-Authored-By: Ilya Verbin <ilya.verbin@intel.com>\n\nFrom-SVN: r217493", "tree": {"sha": "2fe44e0f530c8b4cf77e4ce8d2d53f000fba9744", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2fe44e0f530c8b4cf77e4ce8d2d53f000fba9744"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c713ddc0314d680f961155610a723e7b882e2ae3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c713ddc0314d680f961155610a723e7b882e2ae3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c713ddc0314d680f961155610a723e7b882e2ae3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c713ddc0314d680f961155610a723e7b882e2ae3/comments", "author": null, "committer": null, "parents": [{"sha": "1df3f84256114788e5340cc800b2cdea0e1c9486", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1df3f84256114788e5340cc800b2cdea0e1c9486", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1df3f84256114788e5340cc800b2cdea0e1c9486"}], "stats": {"total": 682, "additions": 540, "deletions": 142}, "files": [{"sha": "22c2e0443f9e69bd131985f9eea653fda72bf35a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c713ddc0314d680f961155610a723e7b882e2ae3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c713ddc0314d680f961155610a723e7b882e2ae3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c713ddc0314d680f961155610a723e7b882e2ae3", "patch": "@@ -1,3 +1,38 @@\n+2014-11-13  Bernd Schmidt  <bernds@codesourcery.com>\n+\t    Andrey Turetskiy  <andrey.turetskiy@intel.com>\n+\t    Ilya Verbin  <ilya.verbin@intel.com>\n+\n+\t* common.opt (foffload, foffload-abi): New options.\n+\t* config/i386/i386.c (ix86_offload_options): New static function.\n+\t(TARGET_OFFLOAD_OPTIONS): Define.\n+\t* coretypes.h (enum offload_abi): New enum.\n+\t* doc/tm.texi: Regenerate.\n+\t* doc/tm.texi.in (TARGET_OFFLOAD_OPTIONS): Document.\n+\t* gcc.c (offload_targets): New static variable.\n+\t(handle_foffload_option): New static function.\n+\t(driver_handle_option): Handle OPT_foffload_.\n+\t(driver::maybe_putenv_OFFLOAD_TARGETS): Set OFFLOAD_TARGET_NAMES\n+\taccording to offload_targets.\n+\t* hooks.c (hook_charptr_void_null): New hook.\n+\t* hooks.h (hook_charptr_void_null): Declare.\n+\t* lto-opts.c: Include lto-section-names.h.\n+\t(lto_write_options): Append options from target offload_options hook and\n+\tstore them to offload_lto section.  Do not store target-specific,\n+\tdriver and diagnostic options in offload_lto section.\n+\t* lto-wrapper.c (merge_and_complain): Handle OPT_foffload_ and\n+\tOPT_foffload_abi_.\n+\t(append_compiler_options, append_linker_options)\n+\t(append_offload_options): New static functions.\n+\t(compile_offload_image): Add new arguments with options.\n+\tCall append_compiler_options and append_offload_options.\n+\t(compile_images_for_offload_targets): Add new arguments with options.\n+\t(find_and_merge_options): New static function.\n+\t(run_gcc): Outline options handling into the new functions:\n+\tfind_and_merge_options, append_compiler_options, append_linker_options.\n+\t* opts.c (common_handle_option): Don't handle OPT_foffload_.\n+\tForbid OPT_foffload_abi_ for non-offload compiler.\n+\t* target.def (offload_options): New target hook.\n+\n 2014-11-13  Ilya Verbin  <ilya.verbin@intel.com>\n \t    Bernd Schmidt  <bernds@codesourcery.com>\n \t    Andrey Turetskiy  <andrey.turetskiy@intel.com>"}, {"sha": "e57c45770ba65c132943cabe63c7c9834a0614c7", "filename": "gcc/common.opt", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c713ddc0314d680f961155610a723e7b882e2ae3/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c713ddc0314d680f961155610a723e7b882e2ae3/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=c713ddc0314d680f961155610a723e7b882e2ae3", "patch": "@@ -1665,6 +1665,23 @@ fnon-call-exceptions\n Common Report Var(flag_non_call_exceptions) Optimization\n Support synchronous non-call exceptions\n \n+foffload=\n+Common Driver Joined MissingArgError(options or targets missing after %qs)\n+-foffload=<targets>=<options>  Specify offloading targets and options for them\n+\n+foffload-abi=\n+Common Joined RejectNegative Enum(offload_abi) Var(flag_offload_abi) Init(OFFLOAD_ABI_UNSET)\n+-foffload-abi=[lp64|ilp32]     Set the ABI to use in an offload compiler\n+\n+Enum\n+Name(offload_abi) Type(enum offload_abi) UnknownError(unknown offload ABI %qs)\n+\n+EnumValue\n+Enum(offload_abi) String(ilp32) Value(OFFLOAD_ABI_ILP32)\n+\n+EnumValue\n+Enum(offload_abi) String(lp64) Value(OFFLOAD_ABI_LP64)\n+\n fomit-frame-pointer\n Common Report Var(flag_omit_frame_pointer) Optimization\n When possible do not generate stack frames"}, {"sha": "3400ca3d5771f7ce6e9ef6e235c25ecdbc5e1674", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c713ddc0314d680f961155610a723e7b882e2ae3/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c713ddc0314d680f961155610a723e7b882e2ae3/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=c713ddc0314d680f961155610a723e7b882e2ae3", "patch": "@@ -4335,6 +4335,15 @@ ix86_option_override (void)\n   register_pass (&insert_vzeroupper_info);\n }\n \n+/* Implement the TARGET_OFFLOAD_OPTIONS hook.  */\n+static char *\n+ix86_offload_options (void)\n+{\n+  if (TARGET_LP64)\n+    return xstrdup (\"-foffload-abi=lp64\");\n+  return xstrdup (\"-foffload-abi=ilp32\");\n+}\n+\n /* Update register usage after having seen the compiler flags.  */\n \n static void\n@@ -51673,6 +51682,10 @@ ix86_initialize_bounds (tree var, tree lb, tree ub, tree *stmts)\n #undef TARGET_SETUP_INCOMING_VARARG_BOUNDS\n #define TARGET_SETUP_INCOMING_VARARG_BOUNDS ix86_setup_incoming_vararg_bounds\n \n+#undef TARGET_OFFLOAD_OPTIONS\n+#define TARGET_OFFLOAD_OPTIONS \\\n+  ix86_offload_options\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n #include \"gt-i386.h\""}, {"sha": "a21359d7ddd557403128c384b598a938d9b47166", "filename": "gcc/coretypes.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c713ddc0314d680f961155610a723e7b882e2ae3/gcc%2Fcoretypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c713ddc0314d680f961155610a723e7b882e2ae3/gcc%2Fcoretypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoretypes.h?ref=c713ddc0314d680f961155610a723e7b882e2ae3", "patch": "@@ -132,6 +132,13 @@ enum tls_model {\n   TLS_MODEL_LOCAL_EXEC\n };\n \n+/* Types of ABI for an offload compiler.  */\n+enum offload_abi {\n+  OFFLOAD_ABI_UNSET,\n+  OFFLOAD_ABI_LP64,\n+  OFFLOAD_ABI_ILP32\n+};\n+\n /* Types of unwind/exception handling info that can be generated.  */\n \n enum unwind_info_type"}, {"sha": "6e2825f2e01944bb31edfdc262a95b52a2feaf60", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c713ddc0314d680f961155610a723e7b882e2ae3/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c713ddc0314d680f961155610a723e7b882e2ae3/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=c713ddc0314d680f961155610a723e7b882e2ae3", "patch": "@@ -11402,6 +11402,15 @@ sections are available.  It is called once for each symbol that must be\n recorded in the offload function and variable table.\n @end deftypefn\n \n+@deftypefn {Target Hook} {char *} TARGET_OFFLOAD_OPTIONS (void)\n+Used when writing out the list of options into an LTO file.  It should\n+translate any relevant target-specific options (such as the ABI in use)\n+into one of the @option{-foffload} options that exist as a common interface\n+to express such options.  It should return a string containing these options,\n+separated by spaces, which the caller will free.\n+\n+@end deftypefn\n+\n @defmac TARGET_SUPPORTS_WIDE_INT\n \n On older ports, large integers are stored in @code{CONST_DOUBLE} rtl"}, {"sha": "929ee85de366561bf844855f14f17e144465d929", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c713ddc0314d680f961155610a723e7b882e2ae3/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c713ddc0314d680f961155610a723e7b882e2ae3/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=c713ddc0314d680f961155610a723e7b882e2ae3", "patch": "@@ -8171,6 +8171,8 @@ and the associated definitions of those functions.\n \n @hook TARGET_RECORD_OFFLOAD_SYMBOL\n \n+@hook TARGET_OFFLOAD_OPTIONS\n+\n @defmac TARGET_SUPPORTS_WIDE_INT\n \n On older ports, large integers are stored in @code{CONST_DOUBLE} rtl"}, {"sha": "4422fa038e8d79c27a1495dcd05934444b124ef0", "filename": "gcc/gcc.c", "status": "modified", "additions": 105, "deletions": 3, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c713ddc0314d680f961155610a723e7b882e2ae3/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c713ddc0314d680f961155610a723e7b882e2ae3/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=c713ddc0314d680f961155610a723e7b882e2ae3", "patch": "@@ -159,6 +159,10 @@ static const char *const spec_version = DEFAULT_TARGET_VERSION;\n static const char *spec_machine = DEFAULT_TARGET_MACHINE;\n static const char *spec_host_machine = DEFAULT_REAL_TARGET_MACHINE;\n \n+/* List of offload targets.  */\n+\n+static char *offload_targets = NULL;\n+\n /* Nonzero if cross-compiling.\n    When -b is used, the value comes from the `specs' file.  */\n \n@@ -3358,6 +3362,92 @@ driver_wrong_lang_callback (const struct cl_decoded_option *decoded,\n static const char *spec_lang = 0;\n static int last_language_n_infiles;\n \n+/* Parse -foffload option argument.  */\n+\n+static void\n+handle_foffload_option (const char *arg)\n+{\n+  const char *c, *cur, *n, *next, *end;\n+  char *target;\n+\n+  /* If option argument starts with '-' then no target is specified and we\n+     do not need to parse it.  */\n+  if (arg[0] == '-')\n+    return;\n+\n+  end = strchrnul (arg, '=');\n+  cur = arg;\n+\n+  while (cur < end)\n+    {\n+      next = strchrnul (cur, ',');\n+      next = (next > end) ? end : next;\n+\n+      target = XNEWVEC (char, next - cur + 1);\n+      strncpy (target, cur, next - cur);\n+      target[next - cur] = '\\0';\n+\n+      /* If 'disable' is passed to the option, stop parsing the option and clean\n+         the list of offload targets.  */\n+      if (strcmp (target, \"disable\") == 0)\n+\t{\n+\t  free (offload_targets);\n+\t  offload_targets = xstrdup (\"\");\n+\t  break;\n+\t}\n+\n+      /* Check that GCC is configured to support the offload target.  */\n+      c = OFFLOAD_TARGETS;\n+      while (c)\n+\t{\n+\t  n = strchrnul (c, ',');\n+\n+\t  if (strlen (target) == (size_t) (n - c)\n+\t      && strncmp (target, c, n - c) == 0)\n+\t    break;\n+\n+\t  c = *n ? n + 1 : NULL;\n+\t}\n+\n+      if (!c)\n+\tfatal_error (\"GCC is not configured to support %s as offload target\",\n+\t\t     target);\n+\n+      if (!offload_targets)\n+\toffload_targets = xstrdup (target);\n+      else\n+\t{\n+\t  /* Check that the target hasn't already presented in the list.  */\n+\t  c = offload_targets;\n+\t  do\n+\t    {\n+\t      n = strchrnul (c, ':');\n+\n+\t      if (strlen (target) == (size_t) (n - c)\n+\t\t  && strncmp (c, target, n - c) == 0)\n+\t\tbreak;\n+\n+\t      c = n + 1;\n+\t    }\n+\t  while (*n);\n+\n+\t  /* If duplicate is not found, append the target to the list.  */\n+\t  if (c > n)\n+\t    {\n+\t      offload_targets\n+\t\t= XRESIZEVEC (char, offload_targets,\n+\t\t\t      strlen (offload_targets) + strlen (target) + 2);\n+\t      if (strlen (offload_targets) != 0)\n+\t\tstrcat (offload_targets, \":\");\n+\t      strcat (offload_targets, target);\n+\t    }\n+\t}\n+\n+      cur = next + 1;\n+      XDELETEVEC (target);\n+    }\n+}\n+\n /* Handle a driver option; arguments and return value as for\n    handle_option.  */\n \n@@ -3735,6 +3825,10 @@ driver_handle_option (struct gcc_options *opts,\n       flag_wpa = \"\";\n       break;\n \n+    case OPT_foffload_:\n+      handle_foffload_option (arg);\n+      break;\n+\n     default:\n       /* Various driver options need no special processing at this\n \t point, having been handled in a prescan above or being\n@@ -7252,14 +7346,22 @@ driver::maybe_putenv_COLLECT_LTO_WRAPPER () const\n void\n driver::maybe_putenv_OFFLOAD_TARGETS () const\n {\n-  if (strlen (OFFLOAD_TARGETS) > 0)\n+  const char *targets = offload_targets;\n+\n+  /* If no targets specified by -foffload, use all available targets.  */\n+  if (!targets)\n+    targets = OFFLOAD_TARGETS;\n+\n+  if (strlen (targets) > 0)\n     {\n       obstack_grow (&collect_obstack, \"OFFLOAD_TARGET_NAMES=\",\n \t\t    sizeof (\"OFFLOAD_TARGET_NAMES=\") - 1);\n-      obstack_grow (&collect_obstack, OFFLOAD_TARGETS,\n-\t\t    strlen (OFFLOAD_TARGETS) + 1);\n+      obstack_grow (&collect_obstack, targets,\n+\t\t    strlen (targets) + 1);\n       xputenv (XOBFINISH (&collect_obstack, char *));\n     }\n+\n+  free (offload_targets);\n }\n \n /* Reject switches that no pass was interested in.  */"}, {"sha": "f698d1d2e9e01ac2e58a7d4b89db494a3a1d327c", "filename": "gcc/hooks.c", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c713ddc0314d680f961155610a723e7b882e2ae3/gcc%2Fhooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c713ddc0314d680f961155610a723e7b882e2ae3/gcc%2Fhooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhooks.c?ref=c713ddc0314d680f961155610a723e7b882e2ae3", "patch": "@@ -386,13 +386,20 @@ hook_tree_tree_tree_tree_3rd_identity (tree a ATTRIBUTE_UNUSED,\n   return c;\n }\n \n-/* Generic hook that takes no arguments and returns a NULL string.  */\n+/* Generic hook that takes no arguments and returns a NULL const string.  */\n const char *\n hook_constcharptr_void_null (void)\n {\n   return NULL;\n }\n \n+/* Generic hook that takes no arguments and returns a NULL string.  */\n+char *\n+hook_charptr_void_null (void)\n+{\n+  return NULL;\n+}\n+\n /* Generic hook that takes a tree and returns a NULL string.  */\n const char *\n hook_constcharptr_const_tree_null (const_tree t ATTRIBUTE_UNUSED)"}, {"sha": "b1b312d176a86a99092341c955eefe5181c6ec2d", "filename": "gcc/hooks.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c713ddc0314d680f961155610a723e7b882e2ae3/gcc%2Fhooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c713ddc0314d680f961155610a723e7b882e2ae3/gcc%2Fhooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhooks.h?ref=c713ddc0314d680f961155610a723e7b882e2ae3", "patch": "@@ -106,6 +106,7 @@ extern rtx hook_rtx_rtx_identity (rtx);\n extern rtx hook_rtx_rtx_null (rtx);\n extern rtx hook_rtx_tree_int_null (tree, int);\n \n+extern char *hook_charptr_void_null (void);\n extern const char *hook_constcharptr_void_null (void);\n extern const char *hook_constcharptr_const_tree_null (const_tree);\n extern const char *hook_constcharptr_const_rtx_insn_null (const rtx_insn *);"}, {"sha": "72b09571e269258ad621d0a8c92a02e6e665a027", "filename": "gcc/lto-opts.c", "status": "modified", "additions": 29, "deletions": 3, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c713ddc0314d680f961155610a723e7b882e2ae3/gcc%2Flto-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c713ddc0314d680f961155610a723e7b882e2ae3/gcc%2Flto-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-opts.c?ref=c713ddc0314d680f961155610a723e7b882e2ae3", "patch": "@@ -49,6 +49,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"ipa-ref.h\"\n #include \"cgraph.h\"\n #include \"lto-streamer.h\"\n+#include \"lto-section-names.h\"\n #include \"toplev.h\"\n \n /* Append the option piece OPT to the COLLECT_GCC_OPTIONS string\n@@ -158,6 +159,23 @@ lto_write_options (void)\n     append_to_collect_gcc_options (&temporary_obstack, &first_p,\n \t\t\t       \"-fno-strict-overflow\");\n \n+  /* Append options from target hook and store them to offload_lto section.  */\n+  if (strcmp (section_name_prefix, OFFLOAD_SECTION_NAME_PREFIX) == 0)\n+    {\n+      char *offload_opts = targetm.offload_options ();\n+      char *offload_ptr = offload_opts;\n+      while (offload_ptr)\n+       {\n+\t char *next = strchr (offload_ptr, ' ');\n+\t if (next)\n+\t   *next++ = '\\0';\n+\t append_to_collect_gcc_options (&temporary_obstack, &first_p,\n+\t\t\t\t\toffload_ptr);\n+\t offload_ptr = next;\n+       }\n+      free (offload_opts);\n+    }\n+\n   /* Output explicitly passed options.  */\n   for (i = 1; i < save_decoded_options_count; ++i)\n     {\n@@ -181,15 +199,23 @@ lto_write_options (void)\n       if (!(cl_options[option->opt_index].flags & (CL_COMMON|CL_TARGET|CL_LTO)))\n \tcontinue;\n \n+      /* Do not store target-specific options in offload_lto section.  */\n+      if ((cl_options[option->opt_index].flags & CL_TARGET)\n+\t && strcmp (section_name_prefix, OFFLOAD_SECTION_NAME_PREFIX) == 0)\n+       continue;\n+\n       /* Drop options created from the gcc driver that will be rejected\n \t when passed on to the driver again.  */\n       if (cl_options[option->opt_index].cl_reject_driver)\n \tcontinue;\n \n       /* Also drop all options that are handled by the driver as well,\n-         which includes things like -o and -v or -fhelp for example.\n-\t We do not need those.  Also drop all diagnostic options.  */\n-      if (cl_options[option->opt_index].flags & (CL_DRIVER|CL_WARNING))\n+\t which includes things like -o and -v or -fhelp for example.\n+\t We do not need those.  The only exception is -foffload option, if we\n+\t write it in offload_lto section.  Also drop all diagnostic options.  */\n+      if ((cl_options[option->opt_index].flags & (CL_DRIVER|CL_WARNING))\n+\t  && (strcmp (section_name_prefix, OFFLOAD_SECTION_NAME_PREFIX) != 0\n+\t      || option->opt_index != OPT_foffload_))\n \tcontinue;\n \n       for (j = 0; j < option->canonical_option_num_elements; ++j)"}, {"sha": "de73ebcdb8b82a515fbb1223b8f91911867b2c9d", "filename": "gcc/lto-wrapper.c", "status": "modified", "additions": 294, "deletions": 135, "changes": 429, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c713ddc0314d680f961155610a723e7b882e2ae3/gcc%2Flto-wrapper.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c713ddc0314d680f961155610a723e7b882e2ae3/gcc%2Flto-wrapper.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-wrapper.c?ref=c713ddc0314d680f961155610a723e7b882e2ae3", "patch": "@@ -296,6 +296,17 @@ merge_and_complain (struct cl_decoded_option **decoded_options,\n \t\t\t \" files\", foption->orig_option_with_args_text);\n \t  break;\n \n+\tcase OPT_foffload_abi_:\n+\t  for (j = 0; j < *decoded_options_count; ++j)\n+\t    if ((*decoded_options)[j].opt_index == foption->opt_index)\n+\t      break;\n+\t    if (j == *decoded_options_count)\n+\t      append_option (decoded_options, decoded_options_count, foption);\n+\t    else if (foption->value != (*decoded_options)[j].value)\n+\t      fatal_error (\"Option %s not used consistently in all LTO input\"\n+\t\t\t   \" files\", foption->orig_option_with_args_text);\n+\t    break;\n+\n \tcase OPT_O:\n \tcase OPT_Ofast:\n \tcase OPT_Og:\n@@ -366,6 +377,10 @@ merge_and_complain (struct cl_decoded_option **decoded_options,\n \t      (*decoded_options)[j].value = 1;\n \t    }\n \t  break;\n+\n+\tcase OPT_foffload_:\n+\t  append_option (decoded_options, decoded_options_count, foption);\n+\t  break;\n \t}\n     }\n }\n@@ -427,6 +442,167 @@ parse_env_var (const char *str, char ***pvalues, const char *append)\n   return num;\n }\n \n+/* Append options OPTS from lto or offload_lto sections to ARGV_OBSTACK.  */\n+\n+static void\n+append_compiler_options (obstack *argv_obstack, struct cl_decoded_option *opts,\n+\t\t\t unsigned int count)\n+{\n+  /* Append compiler driver arguments as far as they were merged.  */\n+  for (unsigned int j = 1; j < count; ++j)\n+    {\n+      struct cl_decoded_option *option = &opts[j];\n+\n+      /* File options have been properly filtered by lto-opts.c.  */\n+      switch (option->opt_index)\n+\t{\n+\t/* Drop arguments that we want to take from the link line.  */\n+\tcase OPT_flto_:\n+\tcase OPT_flto:\n+\tcase OPT_flto_partition_:\n+\t  continue;\n+\n+\tdefault:\n+\t  break;\n+\t}\n+\n+      /* For now do what the original LTO option code was doing - pass\n+\t on any CL_TARGET flag and a few selected others.  */\n+      switch (option->opt_index)\n+\t{\n+\tcase OPT_fPIC:\n+\tcase OPT_fpic:\n+\tcase OPT_fPIE:\n+\tcase OPT_fpie:\n+\tcase OPT_fcommon:\n+\tcase OPT_fexceptions:\n+\tcase OPT_fnon_call_exceptions:\n+\tcase OPT_fgnu_tm:\n+\tcase OPT_freg_struct_return:\n+\tcase OPT_fpcc_struct_return:\n+\tcase OPT_fshort_double:\n+\tcase OPT_ffp_contract_:\n+\tcase OPT_fmath_errno:\n+\tcase OPT_fsigned_zeros:\n+\tcase OPT_ftrapping_math:\n+\tcase OPT_fwrapv:\n+\tcase OPT_ftrapv:\n+\tcase OPT_fstrict_overflow:\n+\tcase OPT_foffload_abi_:\n+\tcase OPT_O:\n+\tcase OPT_Ofast:\n+\tcase OPT_Og:\n+\tcase OPT_Os:\n+\t  break;\n+\n+\tdefault:\n+\t  if (!(cl_options[option->opt_index].flags & CL_TARGET))\n+\t    continue;\n+\t}\n+\n+      /* Pass the option on.  */\n+      for (unsigned int i = 0; i < option->canonical_option_num_elements; ++i)\n+\tobstack_ptr_grow (argv_obstack, option->canonical_option[i]);\n+    }\n+}\n+\n+/* Append linker options OPTS to ARGV_OBSTACK.  */\n+\n+static void\n+append_linker_options (obstack *argv_obstack, struct cl_decoded_option *opts,\n+\t\t       unsigned int count)\n+{\n+  /* Append linker driver arguments.  Compiler options from the linker\n+     driver arguments will override / merge with those from the compiler.  */\n+  for (unsigned int j = 1; j < count; ++j)\n+    {\n+      struct cl_decoded_option *option = &opts[j];\n+\n+      /* Do not pass on frontend specific flags not suitable for lto.  */\n+      if (!(cl_options[option->opt_index].flags\n+\t    & (CL_COMMON|CL_TARGET|CL_DRIVER|CL_LTO)))\n+\tcontinue;\n+\n+      switch (option->opt_index)\n+\t{\n+\tcase OPT_o:\n+\tcase OPT_flto_:\n+\tcase OPT_flto:\n+\t  /* We've handled these LTO options, do not pass them on.  */\n+\t  continue;\n+\n+\tcase OPT_freg_struct_return:\n+\tcase OPT_fpcc_struct_return:\n+\tcase OPT_fshort_double:\n+\t  /* Ignore these, they are determined by the input files.\n+\t     ???  We fail to diagnose a possible mismatch here.  */\n+\t  continue;\n+\n+\tdefault:\n+\t  break;\n+\t}\n+\n+      /* Pass the option on.  */\n+      for (unsigned int i = 0; i < option->canonical_option_num_elements; ++i)\n+\tobstack_ptr_grow (argv_obstack, option->canonical_option[i]);\n+    }\n+}\n+\n+/* Extract options for TARGET offload compiler from OPTIONS and append\n+   them to ARGV_OBSTACK.  */\n+\n+static void\n+append_offload_options (obstack *argv_obstack, const char *target,\n+\t\t\tstruct cl_decoded_option *options,\n+\t\t\tunsigned int options_count)\n+{\n+  for (unsigned i = 0; i < options_count; i++)\n+    {\n+      const char *cur, *next, *opts;\n+      char **argv;\n+      unsigned argc;\n+      struct cl_decoded_option *option = &options[i];\n+\n+      if (option->opt_index != OPT_foffload_)\n+\tcontinue;\n+\n+      /* If option argument starts with '-' then no target is specified.  That\n+\t means offload options are specified for all targets, so we need to\n+\t append them.  */\n+      if (option->arg[0] == '-')\n+\topts = option->arg;\n+      else\n+\t{\n+\t  opts = strchr (option->arg, '=');\n+\t  if (!opts)\n+\t    continue;\n+\n+\t  cur = option->arg;\n+\n+\t  while (cur < opts)\n+\t    {\n+\t      next = strchrnul (cur, ',');\n+\t      next = (next > opts) ? opts : next;\n+\n+\t      if (strlen (target) == (size_t) (next - cur)\n+\t\t  && strncmp (target, cur, next - cur) == 0)\n+\t\tbreak;\n+\n+\t      cur = next + 1;\n+\t    }\n+\n+\t  if (cur >= opts)\n+\t    continue;\n+\n+\t  opts++;\n+\t}\n+\n+      argv = buildargv (opts);\n+      for (argc = 0; argv[argc]; argc++)\n+\tobstack_ptr_grow (argv_obstack, argv[argc]);\n+    }\n+}\n+\n /* Check whether NAME can be accessed in MODE.  This is like access,\n    except that it never considers directories to be executable.  */\n \n@@ -450,7 +626,11 @@ access_check (const char *name, int mode)\n \n static char *\n compile_offload_image (const char *target, const char *compiler_path,\n-\t\t       unsigned in_argc, char *in_argv[])\n+\t\t       unsigned in_argc, char *in_argv[],\n+\t\t       struct cl_decoded_option *compiler_opts,\n+\t\t       unsigned int compiler_opt_count,\n+\t\t       struct cl_decoded_option *linker_opts,\n+\t\t       unsigned int linker_opt_count)\n {\n   char *filename = NULL;\n   char **argv;\n@@ -482,10 +662,22 @@ compile_offload_image (const char *target, const char *compiler_path,\n       obstack_ptr_grow (&argv_obstack, \"-o\");\n       obstack_ptr_grow (&argv_obstack, filename);\n \n+      /* Append names of input object files.  */\n       for (unsigned i = 1; i < in_argc; i++)\n \tobstack_ptr_grow (&argv_obstack, in_argv[i]);\n-      obstack_ptr_grow (&argv_obstack, NULL);\n \n+      /* Append options from offload_lto sections.  */\n+      append_compiler_options (&argv_obstack, compiler_opts,\n+\t\t\t       compiler_opt_count);\n+\n+      /* Append options specified by -foffload last.  In case of conflicting\n+\t options we expect offload compiler to choose the latest.  */\n+      append_offload_options (&argv_obstack, target, compiler_opts,\n+\t\t\t      compiler_opt_count);\n+      append_offload_options (&argv_obstack, target, linker_opts,\n+\t\t\t      linker_opt_count);\n+\n+      obstack_ptr_grow (&argv_obstack, NULL);\n       argv = XOBFINISH (&argv_obstack, char **);\n       fork_execute (argv[0], argv, true);\n       obstack_free (&argv_obstack, NULL);\n@@ -502,7 +694,11 @@ compile_offload_image (const char *target, const char *compiler_path,\n    target sections, we pass them all to target compilers.  */\n \n static void\n-compile_images_for_offload_targets (unsigned in_argc, char *in_argv[])\n+compile_images_for_offload_targets (unsigned in_argc, char *in_argv[],\n+\t\t\t\t    struct cl_decoded_option *compiler_opts,\n+\t\t\t\t    unsigned int compiler_opt_count,\n+\t\t\t\t    struct cl_decoded_option *linker_opts,\n+\t\t\t\t    unsigned int linker_opt_count)\n {\n   char **names = NULL;\n   const char *target_names = getenv (OFFLOAD_TARGET_NAMES_ENV);\n@@ -519,8 +715,10 @@ compile_images_for_offload_targets (unsigned in_argc, char *in_argv[])\n   offload_names = XCNEWVEC (char *, num_targets + 1);\n   for (unsigned i = 0; i < num_targets; i++)\n     {\n-      offload_names[i] = compile_offload_image (names[i], compiler_path,\n-\t\t\t\t\t\tin_argc, in_argv);\n+      offload_names[i]\n+\t= compile_offload_image (names[i], compiler_path, in_argc, in_argv,\n+\t\t\t\t compiler_opts, compiler_opt_count,\n+\t\t\t\t linker_opts, linker_opt_count);\n       if (!offload_names[i])\n \tfatal_error (\"problem with building target image for %s\\n\", names[i]);\n     }\n@@ -587,6 +785,74 @@ find_offloadbeginend (void)\n   free_array_of_ptrs ((void **) paths, n_paths);\n }\n \n+/* A subroutine of run_gcc.  Examine the open file FD for lto sections with\n+   name prefix PREFIX, at FILE_OFFSET, and store any options we find in OPTS\n+   and OPT_COUNT.  Return true if we found a matchingn section, false\n+   otherwise.  COLLECT_GCC holds the value of the environment variable with\n+   the same name.  */\n+\n+static bool\n+find_and_merge_options (int fd, off_t file_offset, const char *prefix,\n+\t\t\tstruct cl_decoded_option **opts,\n+\t\t\tunsigned int *opt_count, const char *collect_gcc)\n+{\n+  off_t offset, length;\n+  char *data;\n+  char *fopts;\n+  const char *errmsg;\n+  int err;\n+  struct cl_decoded_option *fdecoded_options = *opts;\n+  unsigned int fdecoded_options_count = *opt_count;\n+\n+  simple_object_read *sobj;\n+  sobj = simple_object_start_read (fd, file_offset, \"__GNU_LTO\",\n+\t\t\t\t   &errmsg, &err);\n+  if (!sobj)\n+    return false;\n+\n+  char *secname = XALLOCAVEC (char, strlen (prefix) + sizeof (\".opts\"));\n+  strcpy (secname, prefix);\n+  strcat (secname, \".opts\");\n+  if (!simple_object_find_section (sobj, secname, &offset, &length,\n+\t\t\t\t   &errmsg, &err))\n+    {\n+      simple_object_release_read (sobj);\n+      return false;\n+    }\n+\n+  lseek (fd, file_offset + offset, SEEK_SET);\n+  data = (char *)xmalloc (length);\n+  read (fd, data, length);\n+  fopts = data;\n+  do\n+    {\n+      struct cl_decoded_option *f2decoded_options;\n+      unsigned int f2decoded_options_count;\n+      get_options_from_collect_gcc_options (collect_gcc,\n+\t\t\t\t\t    fopts, CL_LANG_ALL,\n+\t\t\t\t\t    &f2decoded_options,\n+\t\t\t\t\t    &f2decoded_options_count);\n+      if (!fdecoded_options)\n+       {\n+\t fdecoded_options = f2decoded_options;\n+\t fdecoded_options_count = f2decoded_options_count;\n+       }\n+      else\n+\tmerge_and_complain (&fdecoded_options,\n+\t\t\t    &fdecoded_options_count,\n+\t\t\t    f2decoded_options, f2decoded_options_count);\n+\n+      fopts += strlen (fopts) + 1;\n+    }\n+  while (fopts - data < length);\n+\n+  free (data);\n+  simple_object_release_read (sobj);\n+  *opts = fdecoded_options;\n+  *opt_count = fdecoded_options_count;\n+  return true;\n+}\n+\n /* Execute gcc. ARGC is the number of arguments. ARGV contains the arguments. */\n \n static void\n@@ -602,7 +868,9 @@ run_gcc (unsigned argc, char *argv[])\n   int jobserver = 0;\n   bool no_partition = false;\n   struct cl_decoded_option *fdecoded_options = NULL;\n+  struct cl_decoded_option *offload_fdecoded_options = NULL;\n   unsigned int fdecoded_options_count = 0;\n+  unsigned int offload_fdecoded_options_count = 0;\n   struct cl_decoded_option *decoded_options;\n   unsigned int decoded_options_count;\n   struct obstack argv_obstack;\n@@ -625,18 +893,13 @@ run_gcc (unsigned argc, char *argv[])\n   /* Look at saved options in the IL files.  */\n   for (i = 1; i < argc; ++i)\n     {\n-      char *data, *p;\n-      char *fopts;\n+      char *p;\n       int fd;\n-      const char *errmsg;\n-      int err;\n-      off_t file_offset = 0, offset, length;\n+      off_t file_offset = 0;\n       long loffset;\n-      simple_object_read *sobj;\n       int consumed;\n-      struct cl_decoded_option *f2decoded_options;\n-      unsigned int f2decoded_options_count;\n       char *filename = argv[i];\n+\n       if ((p = strrchr (argv[i], '@'))\n \t  && p != argv[i] \n \t  && sscanf (p, \"@%li%n\", &loffset, &consumed) >= 1\n@@ -650,50 +913,15 @@ run_gcc (unsigned argc, char *argv[])\n       fd = open (argv[i], O_RDONLY);\n       if (fd == -1)\n \tcontinue;\n-      sobj = simple_object_start_read (fd, file_offset, \"__GNU_LTO\", \n-\t  \t\t\t       &errmsg, &err);\n-      if (!sobj)\n-\t{\n-\t  close (fd);\n-\t  continue;\n-\t}\n-      if (simple_object_find_section (sobj, OFFLOAD_SECTION_NAME_PREFIX \".opts\",\n-\t\t\t\t      &offset, &length, &errmsg, &err))\n-\thave_offload = true;\n-      if (!simple_object_find_section (sobj, LTO_SECTION_NAME_PREFIX \".\" \"opts\",\n-\t\t\t\t       &offset, &length, &errmsg, &err))\n-\t{\n-\t  simple_object_release_read (sobj);\n-\t  close (fd);\n-\t  continue;\n-\t}\n-      have_lto = true;\n-      lseek (fd, file_offset + offset, SEEK_SET);\n-      data = (char *)xmalloc (length);\n-      read (fd, data, length);\n-      fopts = data;\n-      do\n-\t{\n-\t  get_options_from_collect_gcc_options (collect_gcc,\n-\t\t\t\t\t\tfopts, CL_LANG_ALL,\n-\t\t\t\t\t\t&f2decoded_options,\n-\t\t\t\t\t\t&f2decoded_options_count);\n-\t  if (!fdecoded_options)\n-\t    {\n-\t      fdecoded_options = f2decoded_options;\n-\t      fdecoded_options_count = f2decoded_options_count;\n-\t    }\n-\t  else\n-\t    merge_and_complain (&fdecoded_options,\n-\t\t\t\t&fdecoded_options_count,\n-\t\t\t\tf2decoded_options, f2decoded_options_count);\n \n-\t  fopts += strlen (fopts) + 1;\n-\t}\n-      while (fopts - data < length);\n-\n-      free (data);\n-      simple_object_release_read (sobj);\n+      have_lto\n+\t= find_and_merge_options (fd, file_offset, LTO_SECTION_NAME_PREFIX,\n+\t\t\t\t  &fdecoded_options, &fdecoded_options_count,\n+\t\t\t\t  collect_gcc);\n+      have_offload\n+\t= find_and_merge_options (fd, file_offset, OFFLOAD_SECTION_NAME_PREFIX,\n+\t\t\t\t  &offload_fdecoded_options,\n+\t\t\t\t  &offload_fdecoded_options_count, collect_gcc);\n       close (fd);\n     }\n \n@@ -703,79 +931,19 @@ run_gcc (unsigned argc, char *argv[])\n   obstack_ptr_grow (&argv_obstack, \"-xlto\");\n   obstack_ptr_grow (&argv_obstack, \"-c\");\n \n-  /* Append compiler driver arguments as far as they were merged.  */\n-  for (j = 1; j < fdecoded_options_count; ++j)\n-    {\n-      struct cl_decoded_option *option = &fdecoded_options[j];\n-\n-      /* File options have been properly filtered by lto-opts.c.  */\n-      switch (option->opt_index)\n-\t{\n-\t  /* Drop arguments that we want to take from the link line.  */\n-\t  case OPT_flto_:\n-\t  case OPT_flto:\n-\t  case OPT_flto_partition_:\n-\t      continue;\n-\n-\t  default:\n-\t      break;\n-\t}\n-\n-      /* For now do what the original LTO option code was doing - pass\n-\t on any CL_TARGET flag and a few selected others.  */\n-      switch (option->opt_index)\n-\t{\n-\tcase OPT_fPIC:\n-\tcase OPT_fpic:\n-\tcase OPT_fPIE:\n-\tcase OPT_fpie:\n-\tcase OPT_fcommon:\n-\tcase OPT_fexceptions:\n-\tcase OPT_fnon_call_exceptions:\n-\tcase OPT_fgnu_tm:\n-\tcase OPT_freg_struct_return:\n-\tcase OPT_fpcc_struct_return:\n-\tcase OPT_fshort_double:\n-\tcase OPT_ffp_contract_:\n-\tcase OPT_fmath_errno:\n-\tcase OPT_fsigned_zeros:\n-\tcase OPT_ftrapping_math:\n-\tcase OPT_fwrapv:\n-\tcase OPT_ftrapv:\n-\tcase OPT_fstrict_overflow:\n-\tcase OPT_O:\n-\tcase OPT_Ofast:\n-\tcase OPT_Og:\n-\tcase OPT_Os:\n-\t  break;\n-\n-\tdefault:\n-\t  if (!(cl_options[option->opt_index].flags & CL_TARGET))\n-\t    continue;\n-\t}\n-\n-      /* Pass the option on.  */\n-      for (i = 0; i < option->canonical_option_num_elements; ++i)\n-\tobstack_ptr_grow (&argv_obstack, option->canonical_option[i]);\n-    }\n+  append_compiler_options (&argv_obstack, fdecoded_options,\n+\t\t\t   fdecoded_options_count);\n+  append_linker_options (&argv_obstack, decoded_options, decoded_options_count);\n \n-  /* Append linker driver arguments.  Compiler options from the linker\n-     driver arguments will override / merge with those from the compiler.  */\n+  /* Scan linker driver arguments for things that are of relevance to us.  */\n   for (j = 1; j < decoded_options_count; ++j)\n     {\n       struct cl_decoded_option *option = &decoded_options[j];\n-\n-      /* Do not pass on frontend specific flags not suitable for lto.  */\n-      if (!(cl_options[option->opt_index].flags\n-\t    & (CL_COMMON|CL_TARGET|CL_DRIVER|CL_LTO)))\n-\tcontinue;\n-\n       switch (option->opt_index)\n \t{\n \tcase OPT_o:\n \t  linker_output = option->arg;\n-\t  /* We generate new intermediate output, drop this arg.  */\n-\t  continue;\n+\t  break;\n \n \tcase OPT_save_temps:\n \t  save_temps = 1;\n@@ -806,23 +974,11 @@ run_gcc (unsigned argc, char *argv[])\n \n \tcase OPT_flto:\n \t  lto_mode = LTO_MODE_WHOPR;\n-\t  /* We've handled these LTO options, do not pass them on.  */\n-\t  continue;\n-\n-\tcase OPT_freg_struct_return:\n-\tcase OPT_fpcc_struct_return:\n-\tcase OPT_fshort_double:\n-\t  /* Ignore these, they are determined by the input files.\n-\t     ???  We fail to diagnose a possible mismatch here.  */\n-\t  continue;\n+\t  break;\n \n \tdefault:\n \t  break;\n \t}\n-\n-      /* Pass the option on.  */\n-      for (i = 0; i < option->canonical_option_num_elements; ++i)\n-\tobstack_ptr_grow (&argv_obstack, option->canonical_option[i]);\n     }\n \n   if (no_partition)\n@@ -864,7 +1020,10 @@ run_gcc (unsigned argc, char *argv[])\n \n   if (have_offload)\n     {\n-      compile_images_for_offload_targets (argc, argv);\n+      compile_images_for_offload_targets (argc, argv, offload_fdecoded_options,\n+\t\t\t\t\t  offload_fdecoded_options_count,\n+\t\t\t\t\t  decoded_options,\n+\t\t\t\t\t  decoded_options_count);\n       if (offload_names)\n \t{\n \t  find_offloadbeginend ();"}, {"sha": "d22882bf3a22405f7f60a8d17d4d31e06b6a2504", "filename": "gcc/opts.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c713ddc0314d680f961155610a723e7b882e2ae3/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c713ddc0314d680f961155610a723e7b882e2ae3/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=c713ddc0314d680f961155610a723e7b882e2ae3", "patch": "@@ -1807,6 +1807,17 @@ common_handle_option (struct gcc_options *opts,\n       /* Deferred.  */\n       break;\n \n+    case OPT_foffload_:\n+      /* Deferred.  */\n+      break;\n+\n+#ifndef ACCEL_COMPILER\n+    case OPT_foffload_abi_:\n+      error_at (loc, \"-foffload-abi option can be specified only for \"\n+\t\t\"offload compiler\");\n+      break;\n+#endif\n+\n     case OPT_fpack_struct_:\n       if (value <= 0 || (value & (value - 1)) || value > 16)\n \terror_at (loc,"}, {"sha": "015496794408bb3ba778e6d7100c9c8b1ca44def", "filename": "gcc/target.def", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c713ddc0314d680f961155610a723e7b882e2ae3/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c713ddc0314d680f961155610a723e7b882e2ae3/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=c713ddc0314d680f961155610a723e7b882e2ae3", "patch": "@@ -1802,6 +1802,15 @@ actions then, you should have @code{TARGET_OPTION_OVERRIDE} call\\n\\\n  void, (void),\n  hook_void_void)\n \n+DEFHOOK\n+(offload_options,\n+ \"Used when writing out the list of options into an LTO file.  It should\\n\\\n+translate any relevant target-specific options (such as the ABI in use)\\n\\\n+into one of the @option{-foffload} options that exist as a common interface\\n\\\n+to express such options.  It should return a string containing these options,\\n\\\n+separated by spaces, which the caller will free.\\n\",\n+char *, (void), hook_charptr_void_null)\n+\n DEFHOOK_UNDOC\n (eh_return_filter_mode,\n  \"Return machine mode for filter value.\","}]}