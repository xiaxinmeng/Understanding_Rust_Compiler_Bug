{"sha": "ce245ec69e750d05637be21b59f5013da98f1602", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2UyNDVlYzY5ZTc1MGQwNTYzN2JlMjFiNTlmNTAxM2RhOThmMTYwMg==", "commit": {"author": {"name": "Andreas Krebbel", "email": "Andreas.Krebbel@de.ibm.com", "date": "2014-02-07T10:14:24Z"}, "committer": {"name": "Andreas Krebbel", "email": "krebbel@gcc.gnu.org", "date": "2014-02-07T10:14:24Z"}, "message": "_fixdfdi.c: Throw invalid exception if number cannot be represented.\n\n2014-02-07  Andreas Krebbel  <Andreas.Krebbel@de.ibm.com>\n\n\t* config/s390/32/_fixdfdi.c: Throw invalid exception if number\n\tcannot be represented.\n\t* config/s390/32/_fixsfdi.c: Likewise.\n\t* config/s390/32/_fixtfdi.c: Likewise.\n\t* config/s390/32/_fixunsdfdi.c: Likewise.\n\t* config/s390/32/_fixunssfdi.c: Likewise.\n\t* config/s390/32/_fixunstfdi.c: Likewise.\n\n2014-02-07  Andreas Krebbel  <Andreas.Krebbel@de.ibm.com>\n\n\t* gcc.target/s390/fp2int1.c: New testcase.\n\nFrom-SVN: r207596", "tree": {"sha": "bd57e14f45de42cc9484512765bf1e00c671e867", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bd57e14f45de42cc9484512765bf1e00c671e867"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ce245ec69e750d05637be21b59f5013da98f1602", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce245ec69e750d05637be21b59f5013da98f1602", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce245ec69e750d05637be21b59f5013da98f1602", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce245ec69e750d05637be21b59f5013da98f1602/comments", "author": null, "committer": null, "parents": [{"sha": "32cab212f2dd2f17c80c2894e6d9095912db02cc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32cab212f2dd2f17c80c2894e6d9095912db02cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/32cab212f2dd2f17c80c2894e6d9095912db02cc"}], "stats": {"total": 356, "additions": 290, "deletions": 66}, "files": [{"sha": "1a5a636a6872f7dcfd130fc405173d2b2eaa20a6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce245ec69e750d05637be21b59f5013da98f1602/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce245ec69e750d05637be21b59f5013da98f1602/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ce245ec69e750d05637be21b59f5013da98f1602", "patch": "@@ -1,3 +1,7 @@\n+2014-02-07  Andreas Krebbel  <Andreas.Krebbel@de.ibm.com>\n+\n+\t* gcc.target/s390/fp2int1.c: New testcase.\n+\n 2014-02-07  Richard Biener  <rguenther@suse.de>\n \n \tPR middle-end/60092"}, {"sha": "4a90a8b91deda3ad6748e633f262aa96e2d629ea", "filename": "gcc/testsuite/gcc.target/s390/fp2int1.c", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce245ec69e750d05637be21b59f5013da98f1602/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Ffp2int1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce245ec69e750d05637be21b59f5013da98f1602/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Ffp2int1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Ffp2int1.c?ref=ce245ec69e750d05637be21b59f5013da98f1602", "patch": "@@ -0,0 +1,95 @@\n+/* Test for the 32 bit fp to 64 bit int conversion routines.\n+   \n+   On S/390 32 bit we use our own implementations in order to be IEEE\n+   complaint as we are with our machine instructions.  These missed to\n+   throw FE_INVALID exceptions in a bunch of cases.  */\n+\n+/* { dg-do run { target s390-*-* } } */\n+/* { dg-options \"-O3 -mesa\" } */\n+/* { dg-require-effective-target fenv_exceptions } */\n+\n+#define _GNU_SOURCE\n+#include <stdlib.h>\n+#include <stdio.h>\n+#include <fenv.h>\n+\n+#define INFINITYf       (__builtin_inff())\n+#define INFINITY        (__builtin_inf())\n+#define INFINITYl       (__builtin_infl())\n+#define NANf            (__builtin_nanf (\"\"))\n+#define NAN             (__builtin_nan (\"\"))\n+#define NANl            (__builtin_nanl (\"\"))\n+\n+#define TESTEXCEPT_FUNC(FUNC, TYPE_FROM, TYPE_TO)\t\t\t\\\n+  TYPE_TO\t\t\t\t\t\t\t\t\\\n+  __attribute__((noinline)) FUNC (TYPE_FROM a)\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    asm volatile (\"\" : : \"f\" (a));\t\t\t\t\t\\\n+    return (TYPE_TO)a;\t\t\t\t\t\t\t\\\n+  }\n+\n+#define TESTEXCEPT(FUNC, EXCEPT, EXPECT, VALUE, TYPE_TO)\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    TYPE_TO b;\t\t\t\t\t\t\t\t\\\n+    feclearexcept (FE_ALL_EXCEPT);\t\t\t\t\t\\\n+    b = FUNC (VALUE);\t\t\t\t\t\t\t\\\n+    if ((fetestexcept (EXCEPT) & (EXCEPT)) != EXPECT)\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tprintf (\"FAIL in line: %d\\n\", __LINE__);\t\t\t\\\n+\tabort ();\t\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+  }\n+\n+#define TESTEXCEPT_FUNC_ALLFLOATS(FUNC, TYPE_TO)\t\t\\\n+  TESTEXCEPT_FUNC (FUNC##_f, float, TYPE_TO);\t\t\t\\\n+  TESTEXCEPT_FUNC (FUNC##_d, double, TYPE_TO);\t\t\t\\\n+  TESTEXCEPT_FUNC (FUNC##_l, long double, TYPE_TO);\t\t\\\n+\n+#define TESTEXCEPT_ALLFLOATS(FUNC, EXCEPT, EXPECT, VALUE, TYPE_TO)\t\\\n+  TESTEXCEPT (FUNC##_f, EXCEPT, EXPECT, VALUE##f, TYPE_TO);\t\t\\\n+  TESTEXCEPT (FUNC##_d, EXCEPT, EXPECT, VALUE, TYPE_TO);\t\t\\\n+  TESTEXCEPT (FUNC##_l, EXCEPT, EXPECT, VALUE##l, TYPE_TO);\t\t\\\n+\n+TESTEXCEPT_FUNC_ALLFLOATS (a, unsigned long long);\n+TESTEXCEPT_FUNC_ALLFLOATS (u, long long);\n+\n+\n+int\n+main ()\n+{\n+  /* Prevent getting signals.  */\n+  fedisableexcept (FE_INVALID);\n+\n+  /* To unsigned long long */\n+\n+  TESTEXCEPT_ALLFLOATS (a, FE_INVALID, FE_INVALID, INFINITY, unsigned long long);\n+  TESTEXCEPT_ALLFLOATS (a, FE_INVALID, FE_INVALID, -INFINITY, unsigned long long);\n+  TESTEXCEPT_ALLFLOATS (a, FE_INVALID, FE_INVALID, NAN, unsigned long long);\n+  TESTEXCEPT_ALLFLOATS (a, FE_INVALID, FE_INVALID, -NAN, unsigned long long);\n+\n+  /* Negative values >-1.0 must not cause FE_INVALID.  */\n+  TESTEXCEPT_ALLFLOATS (a, FE_INVALID, 0, -0x0.ffffffp0, unsigned long long);\n+  /* -1.0 instead must.  */\n+  TESTEXCEPT_ALLFLOATS (a, FE_INVALID, FE_INVALID, -0x1.0p+0, unsigned long long);\n+  TESTEXCEPT_ALLFLOATS (a, FE_INVALID, 0, 0x1.0p+63, unsigned long long);\n+  TESTEXCEPT_ALLFLOATS (a, FE_INVALID, FE_INVALID, 0x1.0p+64, unsigned long long);\n+\n+  /* To signed long long */\n+\n+  TESTEXCEPT_ALLFLOATS (u, FE_INVALID, FE_INVALID, INFINITY, long long);\n+  TESTEXCEPT_ALLFLOATS (u, FE_INVALID, FE_INVALID, -INFINITY, long long);\n+  TESTEXCEPT_ALLFLOATS (u, FE_INVALID, FE_INVALID, NAN, long long);\n+  TESTEXCEPT_ALLFLOATS (u, FE_INVALID, FE_INVALID, -NAN, long long);\n+\n+  TESTEXCEPT_ALLFLOATS (u, FE_INVALID, 0, -0x1.0p+63, long long);\n+  TESTEXCEPT_ALLFLOATS (u, FE_INVALID, FE_INVALID, -0x1.1p+63, long long);\n+  TESTEXCEPT_ALLFLOATS (u, FE_INVALID, 0, 0x0.fffffp+63, long long);\n+  TESTEXCEPT_ALLFLOATS (u, FE_INVALID, FE_INVALID, 0x1.0p+63, long long);\n+\n+  /* If there are additional bits which would not make it into the\n+     integer value no exception is supposed to occur.  */\n+  TESTEXCEPT (u_l, FE_INVALID,          0, -0x1.000000000000000123p+63l, long long);\n+  TESTEXCEPT (u_l, FE_INVALID, FE_INVALID, -0x1.000000000000000223p+63l, long long);\n+\n+  return 0;\n+}"}, {"sha": "64be83de082b20ecc1244fc26cfed685f99df02b", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce245ec69e750d05637be21b59f5013da98f1602/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce245ec69e750d05637be21b59f5013da98f1602/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=ce245ec69e750d05637be21b59f5013da98f1602", "patch": "@@ -1,3 +1,13 @@\n+2014-02-07  Andreas Krebbel  <Andreas.Krebbel@de.ibm.com>\n+\n+\t* config/s390/32/_fixdfdi.c: Throw invalid exception if number\n+\tcannot be represented.\n+\t* config/s390/32/_fixsfdi.c: Likewise.\n+\t* config/s390/32/_fixtfdi.c: Likewise.\n+\t* config/s390/32/_fixunsdfdi.c: Likewise.\n+\t* config/s390/32/_fixunssfdi.c: Likewise.\n+\t* config/s390/32/_fixunstfdi.c: Likewise.\n+\n 2014-02-07  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \t* configure.ac (libgcc_cv_mips_hard_float): New."}, {"sha": "e6dd4d1144190a0943387f3e212b1328032048cb", "filename": "libgcc/config/s390/32/_fixdfdi.c", "status": "modified", "additions": 28, "deletions": 14, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce245ec69e750d05637be21b59f5013da98f1602/libgcc%2Fconfig%2Fs390%2F32%2F_fixdfdi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce245ec69e750d05637be21b59f5013da98f1602/libgcc%2Fconfig%2Fs390%2F32%2F_fixdfdi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fs390%2F32%2F_fixdfdi.c?ref=ce245ec69e750d05637be21b59f5013da98f1602", "patch": "@@ -27,12 +27,16 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #ifndef __s390x__\n \n #define EXPD(fp)\t(((fp.l.upper) >> 20) & 0x7FF)\n-#define EXCESSD\t\t1022\n+#define EXPONENT_BIAS\t1023\n+#define MANTISSA_BITS   52\n+#define PRECISION       (MANTISSA_BITS + 1)\n #define SIGNBIT\t\t0x80000000\n-#define SIGND(fp)\t((fp.l.upper) & SIGNBIT)\n+#define SIGN(fp)\t((fp.l.upper) & SIGNBIT)\n #define MANTD_LL(fp)\t((fp.ll & (HIDDEND_LL-1)) | HIDDEND_LL)\n #define FRACD_LL(fp)\t(fp.ll & (HIDDEND_LL-1))\n-#define HIDDEND_LL\t((UDItype_x)1 << 52)\n+#define HIDDEND_LL\t((UDItype_x)1 << MANTISSA_BITS)\n+#define LLONG_MAX       9223372036854775807LL\n+#define LLONG_MIN       (-LLONG_MAX - 1LL)\n \n typedef int DItype_x __attribute__ ((mode (DI)));\n typedef unsigned int UDItype_x __attribute__ ((mode (DI)));\n@@ -48,6 +52,12 @@ union double_long {\n     UDItype_x ll;\n };\n \n+static __inline__ void\n+fexceptdiv (float d, float e)\n+{\n+  __asm__ __volatile__ (\"debr %0,%1\" : : \"f\" (d), \"f\" (e) );\n+}\n+\n DItype_x __fixdfdi (double a1);\n \n /* convert double to int */\n@@ -61,29 +71,33 @@ __fixdfdi (double a1)\n     dl1.d = a1;\n \n     /* +/- 0, denormalized */\n-\n     if (!EXPD (dl1))\n       return 0;\n \n-    exp = EXPD (dl1) - EXCESSD - 53;\n+    /* The exponent - considered the binary point at the right end of\n+       the mantissa.  */\n+    exp = EXPD (dl1) - EXPONENT_BIAS - MANTISSA_BITS;\n \n     /* number < 1 */\n-\n-    if (exp < -53)\n+    if (exp <= -PRECISION)\n       return 0;\n \n     /* NaN */\n \n     if ((EXPD(dl1) == 0x7ff) && (FRACD_LL(dl1) != 0)) /* NaN */\n-      return 0x8000000000000000ULL;\n+      {\n+\t/* C99 Annex F.4 requires an \"invalid\" exception to be thrown.  */\n+\tfexceptdiv (0.0, 0.0);\n+\treturn 0x8000000000000000ULL;\n+      }\n \n     /* Number big number & +/- inf */\n-\n     if (exp >= 11) {\n-\tl = (long long)1<<63;\n-\tif (!SIGND(dl1))\n-\t    l--;\n-\treturn l;\n+      /* Don't throw an exception for -1p+63  */\n+      if (!SIGN (dl1) || exp > 11 || FRACD_LL (dl1) != 0)\n+\t/* C99 Annex F.4 requires an \"invalid\" exception to be thrown.  */\n+\tfexceptdiv (0.0, 0.0);\n+      return SIGN (dl1) ? LLONG_MIN : LLONG_MAX;\n     }\n \n     l = MANTD_LL(dl1);\n@@ -94,6 +108,6 @@ __fixdfdi (double a1)\n     else\n       l >>= -exp;\n \n-    return (SIGND (dl1) ? -l : l);\n+    return (SIGN (dl1) ? -l : l);\n }\n #endif /* !__s390x__ */"}, {"sha": "99f91a7051a5730259df0e9b07465470bb5e537a", "filename": "libgcc/config/s390/32/_fixsfdi.c", "status": "modified", "additions": 28, "deletions": 16, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce245ec69e750d05637be21b59f5013da98f1602/libgcc%2Fconfig%2Fs390%2F32%2F_fixsfdi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce245ec69e750d05637be21b59f5013da98f1602/libgcc%2Fconfig%2Fs390%2F32%2F_fixsfdi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fs390%2F32%2F_fixsfdi.c?ref=ce245ec69e750d05637be21b59f5013da98f1602", "patch": "@@ -26,13 +26,17 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n \n #ifndef __s390x__\n \n-#define EXP(fp)         (((fp.l) >> 23) & 0xFF)\n-#define EXCESS          126\n+#define EXPONENT_BIAS   127\n+#define MANTISSA_BITS   23\n+#define EXP(fp)         (((fp.l) >> MANTISSA_BITS) & 0xFF)\n+#define PRECISION       (MANTISSA_BITS + 1)\n #define SIGNBIT         0x80000000\n #define SIGN(fp)        ((fp.l) & SIGNBIT)\n-#define HIDDEN          (1 << 23)\n+#define HIDDEN          (1 << MANTISSA_BITS)\n #define MANT(fp)        (((fp.l) & 0x7FFFFF) | HIDDEN)\n #define FRAC(fp)        ((fp.l) & 0x7FFFFF)\n+#define LLONG_MAX       9223372036854775807LL\n+#define LLONG_MIN       (-LLONG_MAX - 1LL)\n \n typedef int DItype_x __attribute__ ((mode (DI)));\n typedef unsigned int UDItype_x __attribute__ ((mode (DI)));\n@@ -45,6 +49,12 @@ union float_long\n     USItype_x l;\n   };\n \n+static __inline__ void\n+fexceptdiv (float d, float e)\n+{\n+  __asm__ __volatile__ (\"debr %0,%1\" : : \"f\" (d), \"f\" (e) );\n+}\n+\n DItype_x __fixsfdi (float a1);\n \n /* convert double to int */\n@@ -58,32 +68,34 @@ __fixsfdi (float a1)\n     fl1.f = a1;\n \n     /* +/- 0, denormalized */\n-\n     if (!EXP (fl1))\n       return 0;\n \n-    exp = EXP (fl1) - EXCESS - 24;\n+    exp = EXP (fl1) - EXPONENT_BIAS - MANTISSA_BITS;\n \n     /* number < 1 */\n-\n-    if (exp < -24)\n+    if (exp <= -PRECISION)\n       return 0;\n \n     /* NaN */\n \n-    if ((EXP(fl1) == 0xff) && (FRAC(fl1) != 0)) /* NaN */\n-      return 0x8000000000000000ULL;\n+    if ((EXP (fl1) == 0xff) && (FRAC (fl1) != 0)) /* NaN */\n+      {\n+\t/* C99 Annex F.4 requires an \"invalid\" exception to be thrown.  */\n+\tfexceptdiv (0.0, 0.0);\n+\treturn 0x8000000000000000ULL;\n+      }\n \n     /* Number big number & +/- inf */\n-\n-    if (exp >= 40) {\n-\tl = (long long)1<<63;\n-\tif (!SIGN(fl1))\n-\t    l--;\n-\treturn l;\n+    if (exp >= 40) {      \n+      /* Don't throw an exception for -1p+63  */\n+      if (!SIGN (fl1) || exp > 40 || FRAC (fl1) != 0)\n+\t/* C99 Annex F.4 requires an \"invalid\" exception to be thrown.  */\n+\tfexceptdiv (0.0, 0.0);\n+      return SIGN (fl1) ? LLONG_MIN : LLONG_MAX;\n     }\n \n-    l = MANT(fl1);\n+    l = MANT (fl1);\n \n     if (exp > 0)\n       l <<= exp;"}, {"sha": "de84972a22a537861a0f64d854f78e30a8485b1c", "filename": "libgcc/config/s390/32/_fixtfdi.c", "status": "modified", "additions": 23, "deletions": 5, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce245ec69e750d05637be21b59f5013da98f1602/libgcc%2Fconfig%2Fs390%2F32%2F_fixtfdi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce245ec69e750d05637be21b59f5013da98f1602/libgcc%2Fconfig%2Fs390%2F32%2F_fixtfdi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fs390%2F32%2F_fixtfdi.c?ref=ce245ec69e750d05637be21b59f5013da98f1602", "patch": "@@ -31,13 +31,15 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #define MANTISSA_BITS      112\n #define PRECISION          (MANTISSA_BITS + 1)\n #define SIGNBIT\t\t   0x80000000\n-#define SIGND(fp)\t   ((fp.l.i[0]) & SIGNBIT)\n+#define SIGN(fp)\t   ((fp.l.i[0]) & SIGNBIT)\n #define MANTD_HIGH_LL(fp)  ((fp.ll[0] & HIGH_LL_FRAC_MASK) | HIGH_LL_UNIT_BIT)\n #define MANTD_LOW_LL(fp)   (fp.ll[1])\n #define FRACD_ZERO_P(fp)   (!fp.ll[1] && !(fp.ll[0] & HIGH_LL_FRAC_MASK))\n #define HIGH_LL_FRAC_BITS  48\n #define HIGH_LL_UNIT_BIT   ((UDItype_x)1 << HIGH_LL_FRAC_BITS)\n #define HIGH_LL_FRAC_MASK  (HIGH_LL_UNIT_BIT - 1)\n+#define LLONG_MAX       9223372036854775807LL\n+#define LLONG_MIN       (-LLONG_MAX - 1LL)\n \n typedef int DItype_x __attribute__ ((mode (DI)));\n typedef unsigned int UDItype_x __attribute__ ((mode (DI)));\n@@ -52,6 +54,12 @@ union double_long {\n   UDItype_x ll[2];   /* 64 bit parts: 0 upper, 1 lower */\n };\n \n+static __inline__ void\n+fexceptdiv (float d, float e)\n+{\n+  __asm__ __volatile__ (\"debr %0,%1\" : : \"f\" (d), \"f\" (e) );\n+}\n+\n DItype_x __fixtfdi (long double a1);\n \n /* convert double to unsigned int */\n@@ -79,7 +87,11 @@ __fixtfdi (long double a1)\n \n     /* NaN: All exponent bits set and a nonzero fraction.  */\n     if ((EXPD(dl1) == 0x7fff) && !FRACD_ZERO_P (dl1))\n-      return 0x8000000000000000ULL;\n+      {\n+\t/* C99 Annex F.4 requires an \"invalid\" exception to be thrown.  */\n+\tfexceptdiv (0.0, 0.0);\n+\treturn 0x8000000000000000ULL;\n+      }\n \n     /* One extra bit is needed for the unit bit which is appended by\n        MANTD_HIGH_LL on the left of the matissa.  */\n@@ -92,13 +104,19 @@ __fixtfdi (long double a1)\n        or more.  */\n     if (exp >= 0)\n       {\n-\tl = 1ULL << 63; /* long long min */\n-\treturn SIGND (dl1) ? l : l - 1;\n+\t/* Don't throw an exception for -1p+63  */\n+\tif (!SIGN (dl1)\n+\t    || exp > 0\n+\t    || MANTD_LOW_LL (dl1) >> (HIGH_LL_FRAC_BITS + 1)\n+\t    || (dl1.ll[0] & HIGH_LL_FRAC_MASK))\n+\t  /* C99 Annex F.4 requires an \"invalid\" exception to be thrown.  */\n+\t  fexceptdiv (0.0, 0.0);\n+\treturn SIGN (dl1) ? LLONG_MIN : LLONG_MAX;\n       }\n \n     l = MANTD_LOW_LL (dl1) >> (HIGH_LL_FRAC_BITS + 1)\n         | MANTD_HIGH_LL (dl1) << (64 - (HIGH_LL_FRAC_BITS + 1));\n \n-    return SIGND (dl1) ? -(l >> -exp) : l >> -exp;\n+    return SIGN (dl1) ? -(l >> -exp) : l >> -exp;\n }\n #endif /* !__s390x__ */"}, {"sha": "0a249611a23d6151ad7c5c32d53a217aa3dd017b", "filename": "libgcc/config/s390/32/_fixunsdfdi.c", "status": "modified", "additions": 35, "deletions": 11, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce245ec69e750d05637be21b59f5013da98f1602/libgcc%2Fconfig%2Fs390%2F32%2F_fixunsdfdi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce245ec69e750d05637be21b59f5013da98f1602/libgcc%2Fconfig%2Fs390%2F32%2F_fixunsdfdi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fs390%2F32%2F_fixunsdfdi.c?ref=ce245ec69e750d05637be21b59f5013da98f1602", "patch": "@@ -27,9 +27,11 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #ifndef __s390x__\n \n #define EXPD(fp)\t(((fp.l.upper) >> 20) & 0x7FF)\n-#define EXCESSD\t\t1022\n+#define EXPONENT_BIAS\t1023\n+#define MANTISSA_BITS   52\n+#define PRECISION       (MANTISSA_BITS + 1)\n #define SIGNBIT\t\t0x80000000\n-#define SIGND(fp)\t((fp.l.upper) & SIGNBIT)\n+#define SIGN(fp)\t((fp.l.upper) & SIGNBIT)\n #define MANTD_LL(fp)\t((fp.ll & (HIDDEND_LL-1)) | HIDDEND_LL)\n #define FRACD_LL(fp)\t(fp.ll & (HIDDEND_LL-1))\n #define HIDDEND_LL\t((UDItype_x)1 << 52)\n@@ -48,6 +50,12 @@ union double_long {\n     UDItype_x ll;\n };\n \n+static __inline__ void\n+fexceptdiv (float d, float e)\n+{\n+  __asm__ __volatile__ (\"debr %0,%1\" : : \"f\" (d), \"f\" (e) );\n+}\n+\n UDItype_x __fixunsdfdi (double a1);\n \n /* convert double to unsigned int */\n@@ -60,28 +68,44 @@ __fixunsdfdi (double a1)\n \n     dl1.d = a1;\n \n-    /* +/- 0, denormalized, negative */\n-\n-    if (!EXPD (dl1) || SIGND(dl1))\n+    /* +/- 0, denormalized  */\n+    if (!EXPD (dl1))\n       return 0;\n \n-    exp = EXPD (dl1) - EXCESSD - 53;\n+    /* Negative.  */\n+    if (SIGN (dl1))\n+      { \n+\t/* Value is <= -1.0\n+\t   C99 Annex F.4 requires an \"invalid\" exception to be thrown.  */\n+\tif (EXPD (dl1) >= EXPONENT_BIAS)\n+\t  fexceptdiv (0.0, 0.0);\n+\treturn 0;\n+      }\n+\n+    exp = EXPD (dl1) - EXPONENT_BIAS - MANTISSA_BITS;\n \n     /* number < 1 */\n \n-    if (exp < -53)\n+    if (exp < -PRECISION)\n       return 0;\n \n     /* NaN */\n \n     if ((EXPD(dl1) == 0x7ff) && (FRACD_LL(dl1) != 0)) /* NaN */\n-      return 0x0ULL;\n+      {\n+\t/* C99 Annex F.4 requires an \"invalid\" exception to be thrown.  */\n+\tfexceptdiv (0.0, 0.0);\n+\treturn 0x0ULL;\n+      }\n \n     /* Number big number & + inf */\n \n-    if (exp >= 12) {\n-      return 0xFFFFFFFFFFFFFFFFULL;\n-    }\n+    if (exp >= 12)\n+      {\n+\t/* C99 Annex F.4 requires an \"invalid\" exception to be thrown.  */\n+\tfexceptdiv (0.0, 0.0);\n+\treturn 0xFFFFFFFFFFFFFFFFULL;\n+      }\n \n     l = MANTD_LL(dl1);\n "}, {"sha": "7aeed28a0bdd78276f194425fdadf67cda0c76ad", "filename": "libgcc/config/s390/32/_fixunssfdi.c", "status": "modified", "additions": 36, "deletions": 14, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce245ec69e750d05637be21b59f5013da98f1602/libgcc%2Fconfig%2Fs390%2F32%2F_fixunssfdi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce245ec69e750d05637be21b59f5013da98f1602/libgcc%2Fconfig%2Fs390%2F32%2F_fixunssfdi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fs390%2F32%2F_fixunssfdi.c?ref=ce245ec69e750d05637be21b59f5013da98f1602", "patch": "@@ -26,11 +26,12 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n \n #ifndef __s390x__\n \n-#define EXP(fp)         (((fp.l) >> 23) & 0xFF)\n-#define EXCESS          126\n+#define EXPONENT_BIAS   127\n+#define MANTISSA_BITS   23\n+#define EXP(fp)         (((fp.l) >> MANTISSA_BITS) & 0xFF)\n #define SIGNBIT         0x80000000\n #define SIGN(fp)        ((fp.l) & SIGNBIT)\n-#define HIDDEN          (1 << 23)\n+#define HIDDEN          (1 << MANTISSA_BITS)\n #define MANT(fp)        (((fp.l) & 0x7FFFFF) | HIDDEN)\n #define FRAC(fp)        ((fp.l) & 0x7FFFFF)\n \n@@ -45,6 +46,12 @@ union float_long\n     USItype_x l;\n   };\n \n+static __inline__ void\n+fexceptdiv (float d, float e)\n+{\n+  __asm__ __volatile__ (\"debr %0,%1\" : : \"f\" (d), \"f\" (e) );\n+}\n+\n UDItype_x __fixunssfdi (float a1);\n \n /* convert float to unsigned int */\n@@ -57,30 +64,45 @@ __fixunssfdi (float a1)\n \n     fl1.f = a1;\n \n-    /* +/- 0, denormalized, negative */\n-\n-    if (!EXP (fl1) || SIGN(fl1))\n+    /* +/- 0, denormalized  */\n+    if (!EXP (fl1))\n       return 0;\n \n-    exp = EXP (fl1) - EXCESS - 24;\n+    /* Negative.  */\n+    if (SIGN (fl1))\n+      { \n+\t/* Value is <= -1.0\n+\t   C99 Annex F.4 requires an \"invalid\" exception to be thrown.  */\n+\tif (EXP (fl1) >= EXPONENT_BIAS)\n+\t  fexceptdiv (0.0, 0.0);\n+\treturn 0;\n+      }\n \n-    /* number < 1 */\n+    exp = EXP (fl1) - EXPONENT_BIAS - MANTISSA_BITS;\n \n+    /* number < 1 */\n     if (exp < -24)\n       return 0;\n \n     /* NaN */\n \n-    if ((EXP(fl1) == 0xff) && (FRAC(fl1) != 0)) /* NaN */\n-      return 0x0ULL;\n+    if ((EXP (fl1) == 0xff) && (FRAC (fl1) != 0)) /* NaN */\n+      {\n+\t/* C99 Annex F.4 requires an \"invalid\" exception to be thrown.  */\n+\tfexceptdiv (0.0, 0.0);\t\n+\treturn 0x0ULL;\n+      }\n \n     /* Number big number & + inf */\n \n-    if (exp >= 41) {\n-      return 0xFFFFFFFFFFFFFFFFULL;\n-    }\n+    if (exp >= 41)\n+      {\n+\t/* C99 Annex F.4 requires an \"invalid\" exception to be thrown.  */\n+\tfexceptdiv (0.0, 0.0);\n+\treturn 0xFFFFFFFFFFFFFFFFULL;\n+      }\n \n-    l = MANT(fl1);\n+    l = MANT (fl1);\n \n     if (exp > 0)\n       l <<= exp;"}, {"sha": "2f90a5f2f163810959ad9d8ac29087a388921aea", "filename": "libgcc/config/s390/32/_fixunstfdi.c", "status": "modified", "additions": 31, "deletions": 6, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce245ec69e750d05637be21b59f5013da98f1602/libgcc%2Fconfig%2Fs390%2F32%2F_fixunstfdi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce245ec69e750d05637be21b59f5013da98f1602/libgcc%2Fconfig%2Fs390%2F32%2F_fixunstfdi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fs390%2F32%2F_fixunstfdi.c?ref=ce245ec69e750d05637be21b59f5013da98f1602", "patch": "@@ -52,6 +52,12 @@ union double_long {\n   UDItype_x ll[2];   /* 64 bit parts: 0 upper, 1 lower */\n };\n \n+static __inline__ void\n+fexceptdiv (float d, float e)\n+{\n+  __asm__ __volatile__ (\"debr %0,%1\" : : \"f\" (d), \"f\" (e) );\n+}\n+\n UDItype_x __fixunstfdi (long double a1);\n \n /* convert double to unsigned int */\n@@ -64,10 +70,20 @@ __fixunstfdi (long double a1)\n \n     dl1.d = a1;\n \n-    /* +/- 0, denormalized, negative */\n-    if (!EXPD (dl1) || SIGND(dl1))\n+    /* +/- 0, denormalized */\n+    if (!EXPD (dl1))\n       return 0;\n \n+    /* Negative.  */\n+    if (SIGND (dl1))\n+      {\n+\t/* Value is <= -1.0\n+\t   C99 Annex F.4 requires an \"invalid\" exception to be thrown.  */\n+\tif (EXPD (dl1) >= EXPONENT_BIAS)\n+\t  fexceptdiv (0.0, 0.0);\n+\treturn 0;\n+      }\n+\n     /* The exponent - considered the binary point at the right end of\n        the mantissa.  */\n     exp = EXPD (dl1) - EXPONENT_BIAS - MANTISSA_BITS;\n@@ -80,16 +96,25 @@ __fixunstfdi (long double a1)\n \n     /* NaN: All exponent bits set and a nonzero fraction.  */\n     if ((EXPD(dl1) == 0x7fff) && !FRACD_ZERO_P (dl1))\n-      return 0x0ULL;\n+      {\n+\t/* C99 Annex F.4 requires an \"invalid\" exception to be thrown.  */\n+\tfexceptdiv (0.0, 0.0);\n+\treturn 0;\n+      }\n \n     /* One extra bit is needed for the unit bit which is appended by\n        MANTD_HIGH_LL on the left of the matissa.  */\n     exp += HIGH_LL_FRAC_BITS + 1;\n \n-    /* If the result would still need a left shift it will be too large\n-       to be represented.  */\n+    /* If the result would still need a left shift it will be too\n+       large to be represented.  Infinities have all exponent bits set\n+       and will end up here as well.  */\n     if (exp > 0)\n-      return 0xFFFFFFFFFFFFFFFFULL;\n+      {\n+\t/* C99 Annex F.4 requires an \"invalid\" exception to be thrown.  */\n+\tfexceptdiv (0.0, 0.0);\n+\treturn 0xFFFFFFFFFFFFFFFFULL;\n+      }\n \n     l = MANTD_LOW_LL (dl1) >> (HIGH_LL_FRAC_BITS + 1)\n         | MANTD_HIGH_LL (dl1) << (64 - (HIGH_LL_FRAC_BITS + 1));"}]}