{"sha": "c877ae8dc867e29552b5ab4b2367479829b4de69", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yzg3N2FlOGRjODY3ZTI5NTUyYjVhYjRiMjM2NzQ3OTgyOWI0ZGU2OQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2016-10-13T12:10:46Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2016-10-13T12:10:46Z"}, "message": "[multiple changes]\n\n2016-10-13  Yannick Moy  <moy@adacore.com>\n\n\t* sem_prag.adb (Analyze_Refined_Depends_In_Decl_Part): Adapt to\n\toptional refinement for abstract states with only partial refinement\n\tvisible.\n\n2016-10-13  Justin Squirek  <squirek@adacore.com>\n\n\t* sem_ch13.adb: Minor correction in comment in\n\tAnalyze_Aspect_Specifications\n\t* sem_prag.adb: Minor reformatting.\n\n2016-10-13  Thomas Quinot  <quinot@adacore.com>\n\n\t* s-stratt-xdr.adb: Disable compiler unit warnings.\n\n2016-10-13  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch3.adb (Visible_Component): In an instance body, check\n\twhether the component may be hidden in a selected component by\n\ta homonym that is a primitive operation of the type of the prefix.\n\nFrom-SVN: r241106", "tree": {"sha": "95fbefc58a093c1dd48ea1c3841826028726fa78", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/95fbefc58a093c1dd48ea1c3841826028726fa78"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c877ae8dc867e29552b5ab4b2367479829b4de69", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c877ae8dc867e29552b5ab4b2367479829b4de69", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c877ae8dc867e29552b5ab4b2367479829b4de69", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c877ae8dc867e29552b5ab4b2367479829b4de69/comments", "author": null, "committer": null, "parents": [{"sha": "c59552242d60f0c89534dc1bed28f4a402a56e11", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c59552242d60f0c89534dc1bed28f4a402a56e11", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c59552242d60f0c89534dc1bed28f4a402a56e11"}], "stats": {"total": 208, "additions": 175, "deletions": 33}, "files": [{"sha": "31404026c797f2fb4421f5c30725535befa8c389", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c877ae8dc867e29552b5ab4b2367479829b4de69/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c877ae8dc867e29552b5ab4b2367479829b4de69/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=c877ae8dc867e29552b5ab4b2367479829b4de69", "patch": "@@ -1,3 +1,25 @@\n+2016-10-13  Yannick Moy  <moy@adacore.com>\n+\n+\t* sem_prag.adb (Analyze_Refined_Depends_In_Decl_Part): Adapt to\n+\toptional refinement for abstract states with only partial refinement\n+\tvisible.\n+\n+2016-10-13  Justin Squirek  <squirek@adacore.com>\n+\n+\t* sem_ch13.adb: Minor correction in comment in\n+\tAnalyze_Aspect_Specifications\n+\t* sem_prag.adb: Minor reformatting.\n+\n+2016-10-13  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* s-stratt-xdr.adb: Disable compiler unit warnings.\n+\n+2016-10-13  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch3.adb (Visible_Component): In an instance body, check\n+\twhether the component may be hidden in a selected component by\n+\ta homonym that is a primitive operation of the type of the prefix.\n+\n 2016-10-13  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR target/77957"}, {"sha": "1c5d3cf62d13ade24172ba66ea276be4610408d4", "filename": "gcc/ada/s-stratt-xdr.adb", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c877ae8dc867e29552b5ab4b2367479829b4de69/gcc%2Fada%2Fs-stratt-xdr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c877ae8dc867e29552b5ab4b2367479829b4de69/gcc%2Fada%2Fs-stratt-xdr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-stratt-xdr.adb?ref=c877ae8dc867e29552b5ab4b2367479829b4de69", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---         Copyright (C) 1996-2013, Free Software Foundation, Inc.          --\n+--         Copyright (C) 1996-2016, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GARLIC is free software;  you can redistribute it and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -33,6 +33,11 @@\n --  standard. It is especially useful for exchanging streams between two\n --  different systems with different basic type representations and endianness.\n \n+pragma Warnings (Off, \"*not allowed in compiler unit\");\n+--  This body is used only when rebuilding the runtime library, not when\n+--  building the compiler, so it's OK to depend on features that would\n+--  otherwise break bootstrap (e.g. IF-expressions).\n+\n with Ada.IO_Exceptions;\n with Ada.Streams;              use Ada.Streams;\n with Ada.Unchecked_Conversion;"}, {"sha": "863777914cc95cd7c2bcaf4d3782126df9ced656", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c877ae8dc867e29552b5ab4b2367479829b4de69/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c877ae8dc867e29552b5ab4b2367479829b4de69/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=c877ae8dc867e29552b5ab4b2367479829b4de69", "patch": "@@ -1852,7 +1852,7 @@ package body Sem_Ch13 is\n                Set_From_Aspect_Specification (Aitem);\n             end Make_Aitem_Pragma;\n \n-         --  Start of processing for Analyze_One_Aspect\n+         --  Start of processing for Analyze_Aspect_Specifications\n \n          begin\n             --  Skip aspect if already analyzed, to avoid looping in some cases"}, {"sha": "5e659fdb2f9de2c7f27aebd98eb1abfab6d3c02f", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 30, "deletions": 3, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c877ae8dc867e29552b5ab4b2367479829b4de69/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c877ae8dc867e29552b5ab4b2367479829b4de69/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=c877ae8dc867e29552b5ab4b2367479829b4de69", "patch": "@@ -18133,11 +18133,38 @@ package body Sem_Ch3 is\n       then\n          return True;\n \n-      --  In the body of an instantiation, no need to check for the visibility\n-      --  of a component.\n+      --  In the body of an instantiation, check the visibility of a component\n+      --  in case it has a homograph that is a primitive operation of a private\n+      --  type which was not visible in the generic unit.\n+\n+      --  Should Is_Prefixed_Call be propagated from template to instance???\n \n       elsif In_Instance_Body then\n-         return True;\n+         if not Is_Tagged_Type (Original_Type)\n+           or else not Is_Private_Type (Original_Type)\n+         then\n+            return True;\n+\n+         else\n+            declare\n+               Subp_Elmt : Elmt_Id;\n+\n+            begin\n+               Subp_Elmt := First_Elmt (Primitive_Operations (Original_Type));\n+               while Present (Subp_Elmt) loop\n+\n+                  --  The component is hidden by a primitive operation\n+\n+                  if Chars (Node (Subp_Elmt)) = Chars (C) then\n+                     return False;\n+                  end if;\n+\n+                  Next_Elmt (Subp_Elmt);\n+               end loop;\n+\n+               return True;\n+            end;\n+         end if;\n \n       --  If the component has been declared in an ancestor which is currently\n       --  a private type, then it is not visible. The same applies if the"}, {"sha": "4128216e01a10e1bf2c63b62ffa7b165ac398936", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 116, "deletions": 28, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c877ae8dc867e29552b5ab4b2367479829b4de69/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c877ae8dc867e29552b5ab4b2367479829b4de69/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=c877ae8dc867e29552b5ab4b2367479829b4de69", "patch": "@@ -23653,16 +23653,27 @@ package body Sem_Prag is\n       --  The inputs and outputs of the subprogram spec synthesized from pragma\n       --  Depends.\n \n-      procedure Check_Dependency_Clause (Dep_Clause : Node_Id);\n+      procedure Check_Dependency_Clause\n+        (States     : Elist_Id;\n+         Dep_Clause : Node_Id);\n       --  Try to match a single dependency clause Dep_Clause against one or\n       --  more refinement clauses found in list Refinements. Each successful\n       --  match eliminates at least one refinement clause from Refinements.\n+      --  States is a list of states appearing in dependencies obtained by\n+      --  calling Get_States_Seen.\n \n       procedure Check_Output_States;\n       --  Determine whether pragma Depends contains an output state with a\n       --  visible refinement and if so, ensure that pragma Refined_Depends\n       --  mentions all its constituents as outputs.\n \n+      function Get_States_Seen (Dependencies : List_Id) return Elist_Id;\n+      --  Given a normalized list of dependencies obtained from calling\n+      --  Normalize_Clauses, return a list containing the entities of all\n+      --  states appearing in dependencies. It helps in checking refinements\n+      --  involving a state and a corresponding constituent which is not a\n+      --  direct constituent of the state.\n+\n       procedure Normalize_Clauses (Clauses : List_Id);\n       --  Given a list of dependence or refinement clauses Clauses, normalize\n       --  each clause by creating multiple dependencies with exactly one input\n@@ -23675,7 +23686,10 @@ package body Sem_Prag is\n       -- Check_Dependency_Clause --\n       -----------------------------\n \n-      procedure Check_Dependency_Clause (Dep_Clause : Node_Id) is\n+      procedure Check_Dependency_Clause\n+        (States     : Elist_Id;\n+         Dep_Clause : Node_Id)\n+      is\n          Dep_Input  : constant Node_Id := Expression (Dep_Clause);\n          Dep_Output : constant Node_Id := First (Choices (Dep_Clause));\n \n@@ -23692,7 +23706,7 @@ package body Sem_Prag is\n             Ref_Item : Node_Id;\n             Matched  : out Boolean);\n          --  Try to match dependence item Dep_Item against refinement item\n-         --  Ref_Item. To match against a possible null refinement (see 2, 7),\n+         --  Ref_Item. To match against a possible null refinement (see 2, 9),\n          --  set Ref_Item to Empty. Flag Matched is set to True when one of\n          --  the following conformance scenarios is in effect:\n          --    1) Both items denote null\n@@ -23706,10 +23720,11 @@ package body Sem_Prag is\n          --       and Ref_Item denotes null.\n          --    9) Dep_Item is an abstract state with visible null refinement\n          --       and Ref_Item is Empty (special case).\n-         --   10) Dep_Item is an abstract state with visible non-null\n-         --       refinement and Ref_Item denotes one of its constituents.\n-         --   11) Dep_Item is an abstract state without a visible refinement\n-         --       and Ref_Item denotes the same state.\n+         --   10) Dep_Item is an abstract state with full or partial visible\n+         --       non-null refinement and Ref_Item denotes one of its\n+         --       constituents.\n+         --   11) Dep_Item is an abstract state without a full visible\n+         --       refinement and Ref_Item denotes the same state.\n          --  When scenario 10 is in effect, the entity of the abstract state\n          --  denoted by Dep_Item is added to list Refined_States.\n \n@@ -23829,8 +23844,8 @@ package body Sem_Prag is\n                                                   E_Constant,\n                                                   E_Variable)\n                           and then Present (Encapsulating_State (Ref_Item_Id))\n-                          and then Encapsulating_State (Ref_Item_Id) =\n-                                     Dep_Item_Id\n+                          and then Find_Encapsulating_State\n+                                     (States, Ref_Item_Id) = Dep_Item_Id\n                         then\n                            Record_Item (Dep_Item_Id);\n                            Matched := True;\n@@ -24066,17 +24081,19 @@ package body Sem_Prag is\n          procedure Check_Constituent_Usage (State_Id : Entity_Id);\n          --  Determine whether all constituents of state State_Id with full\n          --  visible refinement are used as outputs in pragma Refined_Depends.\n-         --  Emit an error if this is not the case.\n+         --  Emit an error if this is not the case (SPARK RM 7.2.4(5)).\n \n          -----------------------------\n          -- Check_Constituent_Usage --\n          -----------------------------\n \n          procedure Check_Constituent_Usage (State_Id : Entity_Id) is\n             Constits     : constant Elist_Id :=\n-                             Refinement_Constituents (State_Id);\n+                             Partial_Refinement_Constituents (State_Id);\n             Constit_Elmt : Elmt_Id;\n             Constit_Id   : Entity_Id;\n+            Only_Partial : constant Boolean :=\n+                             not Has_Visible_Refinement (State_Id);\n             Posted       : Boolean := False;\n \n          begin\n@@ -24085,9 +24102,28 @@ package body Sem_Prag is\n                while Present (Constit_Elmt) loop\n                   Constit_Id := Node (Constit_Elmt);\n \n+                  --  Issue an error when a constituent of State_Id is used,\n+                  --  and State_Id has only partial visible refinement\n+                  --  (SPARK RM 7.2.4(3d)).\n+\n+                  if Only_Partial then\n+                     if (Present (Body_Inputs)\n+                          and then Appears_In (Body_Inputs, Constit_Id))\n+                       or else\n+                        (Present (Body_Outputs)\n+                          and then Appears_In (Body_Outputs, Constit_Id))\n+                     then\n+                        Error_Msg_Name_1 := Chars (State_Id);\n+                        SPARK_Msg_NE\n+                          (\"constituent & of state % cannot be used in \"\n+                           & \"dependence refinement\", N, Constit_Id);\n+                        Error_Msg_Name_1 := Chars (State_Id);\n+                        SPARK_Msg_N (\"\\use state % instead\", N);\n+                     end if;\n+\n                   --  The constituent acts as an input (SPARK RM 7.2.5(3))\n \n-                  if Present (Body_Inputs)\n+                  elsif Present (Body_Inputs)\n                     and then Appears_In (Body_Inputs, Constit_Id)\n                   then\n                      Error_Msg_Name_1 := Chars (State_Id);\n@@ -24161,9 +24197,7 @@ package body Sem_Prag is\n                   --  Ensure that all of the constituents are utilized as\n                   --  outputs in pragma Refined_Depends.\n \n-                  elsif Has_Visible_Refinement (Item_Id)\n-                    and then Has_Non_Null_Visible_Refinement (Item_Id)\n-                  then\n+                  elsif Has_Non_Null_Visible_Refinement (Item_Id) then\n                      Check_Constituent_Usage (Item_Id);\n                   end if;\n                end if;\n@@ -24173,6 +24207,55 @@ package body Sem_Prag is\n          end if;\n       end Check_Output_States;\n \n+      ---------------------\n+      -- Get_States_Seen --\n+      ---------------------\n+\n+      function Get_States_Seen (Dependencies : List_Id) return Elist_Id is\n+         States_Seen : Elist_Id := No_Elist;\n+\n+         procedure Get_State (Glob_Item : Node_Id);\n+         --  Add global item to States_Seen when it corresponds to a state\n+\n+         ---------------\n+         -- Get_State --\n+         ---------------\n+\n+         procedure Get_State (Glob_Item : Node_Id) is\n+            Id : Entity_Id;\n+         begin\n+            if Is_Entity_Name (Glob_Item) then\n+               Id := Entity_Of (Glob_Item);\n+\n+               if Ekind (Id) = E_Abstract_State then\n+                  Append_New_Elmt (Id, States_Seen);\n+               end if;\n+            end if;\n+         end Get_State;\n+\n+         --  Local variables\n+\n+         Dep_Clause : Node_Id;\n+         Dep_Input  : Node_Id;\n+         Dep_Output : Node_Id;\n+\n+      --  Start of processing for Get_States_Seen\n+\n+      begin\n+         Dep_Clause := First (Dependencies);\n+         while Present (Dep_Clause) loop\n+            Dep_Input  := Expression (Dep_Clause);\n+            Dep_Output := First (Choices (Dep_Clause));\n+\n+            Get_State (Dep_Input);\n+            Get_State (Dep_Output);\n+\n+            Next (Dep_Clause);\n+         end loop;\n+\n+         return States_Seen;\n+      end Get_States_Seen;\n+\n       -----------------------\n       -- Normalize_Clauses --\n       -----------------------\n@@ -24380,7 +24463,6 @@ package body Sem_Prag is\n       Body_Decl : constant Node_Id   := Find_Related_Declaration_Or_Body (N);\n       Body_Id   : constant Entity_Id := Defining_Entity (Body_Decl);\n       Errors    : constant Nat       := Serious_Errors_Detected;\n-      Clause    : Node_Id;\n       Deps      : Node_Id;\n       Dummy     : Boolean;\n       Refs      : Node_Id;\n@@ -24502,11 +24584,17 @@ package body Sem_Prag is\n          --  and one input. Examine all clauses of pragma Depends looking for\n          --  matching clauses in pragma Refined_Depends.\n \n-         Clause := First (Dependencies);\n-         while Present (Clause) loop\n-            Check_Dependency_Clause (Clause);\n-            Next (Clause);\n-         end loop;\n+         declare\n+            States_Seen : constant Elist_Id := Get_States_Seen (Dependencies);\n+            Clause      : Node_Id;\n+\n+         begin\n+            Clause := First (Dependencies);\n+            while Present (Clause) loop\n+               Check_Dependency_Clause (States_Seen, Clause);\n+               Next (Clause);\n+            end loop;\n+         end;\n \n          if Serious_Errors_Detected = Errors then\n             Report_Extra_Clauses;\n@@ -24795,8 +24883,8 @@ package body Sem_Prag is\n          --  Determine whether at least one constituent of state State_Id with\n          --  full or partial visible refinement is used and has mode Input.\n          --  Ensure that the remaining constituents do not have In_Out or\n-         --  Output modes. Emit an error if this is not the case (SPARK RM\n-         --  7.2.4(5)).\n+         --  Output modes. Emit an error if this is not the case\n+         --  (SPARK RM 7.2.4(5)).\n \n          -----------------------------\n          -- Check_Constituent_Usage --\n@@ -24846,9 +24934,9 @@ package body Sem_Prag is\n             --  Not one of the constituents appeared as Input. Always emit an\n             --  error when the full refinement is visible (SPARK RM 7.2.4(3a)).\n             --  When only partial refinement is visible, emit an\n-            --  error if the abstract state itself is not utilized (SPARK RM\n-            --  7.2.4(3d)). In the case where both are utilized, an error will\n-            --  be issued in Check_State_And_Constituent_Use.\n+            --  error if the abstract state itself is not utilized\n+            --  (SPARK RM 7.2.4(3d)). In the case where both are utilized,\n+            --  an error will be issued in Check_State_And_Constituent_Use.\n \n             if not In_Seen\n               and then (Has_Visible_Refinement (State_Id)\n@@ -25030,8 +25118,8 @@ package body Sem_Prag is\n          --  Determine whether at least one constituent of state State_Id with\n          --  full or partial visible refinement is used and has mode Proof_In.\n          --  Ensure that the remaining constituents do not have Input, In_Out\n-         --  or Output modes. Emit an error of this is not the case (SPARK RM\n-         --  7.2.4(5)).\n+         --  or Output modes. Emit an error of this is not the case\n+         --  (SPARK RM 7.2.4(5)).\n \n          -----------------------------\n          -- Check_Constituent_Usage --"}]}