{"sha": "944420629e3950229f4ddc380df3bdcfb4d03bfb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTQ0NDIwNjI5ZTM5NTAyMjlmNGRkYzM4MGRmM2JkY2ZiNGQwM2JmYg==", "commit": {"author": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1995-12-15T07:43:33Z"}, "committer": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1995-12-15T07:43:33Z"}, "message": "fix-header.c: Support different kinds of functions (ANSI and Posix1).\n\n* fix-header.c:  Support different kinds of functions (ANSI and\nPosix1).  Enable ANSI proptotypes if __STRICT_ANSI__.\n\nFrom-SVN: r10729", "tree": {"sha": "944d2fdba142da0473ada896afc962666ff4d163", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/944d2fdba142da0473ada896afc962666ff4d163"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/944420629e3950229f4ddc380df3bdcfb4d03bfb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/944420629e3950229f4ddc380df3bdcfb4d03bfb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/944420629e3950229f4ddc380df3bdcfb4d03bfb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/944420629e3950229f4ddc380df3bdcfb4d03bfb/comments", "author": null, "committer": null, "parents": [{"sha": "8106dc08326b97c77ade099fa8704d6e73073fd8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8106dc08326b97c77ade099fa8704d6e73073fd8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8106dc08326b97c77ade099fa8704d6e73073fd8"}], "stats": {"total": 286, "additions": 177, "deletions": 109}, "files": [{"sha": "84307c6f8132fe9120ad807c140853d13df9172d", "filename": "gcc/fix-header.c", "status": "modified", "additions": 177, "deletions": 109, "changes": 286, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/944420629e3950229f4ddc380df3bdcfb4d03bfb/gcc%2Ffix-header.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/944420629e3950229f4ddc380df3bdcfb4d03bfb/gcc%2Ffix-header.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffix-header.c?ref=944420629e3950229f4ddc380df3bdcfb4d03bfb", "patch": "@@ -135,124 +135,158 @@ enum special_file\n \n typedef const char* namelist;\n \n-struct std_include_entry {\n-  const char *name;\n-  namelist required;\n-  namelist extra;\n-  int special;\n+/* The following macros provide the bits for symbol_flags. */\n+typedef int symbol_flags;\n+\n+/* Used to mark names defined in the ANSI/ISO C standard. */\n+#define ANSI_SYMBOL 1\n+\n+  /* Used to mark names defined in the Posix.1 or Posix.2 standard. */\n+#define POSIX1_SYMBOL 2\n+#define POSIX2_SYMBOL 4\n+\n+/* Used to indicate names that are not functions */\n+#define MACRO_SYMBOL 8\n+\n+struct symbol_list {\n+  symbol_flags flags;\n+  namelist names;\n };\n \n-/* End of namelist NAMES. */\n+#define SYMBOL_TABLE_SIZE 10\n+struct symbol_list symbol_table[SYMBOL_TABLE_SIZE];\n+int cur_symbol_table_size;\n \n-namelist\n-namelist_end (names)\n+void\n+add_symbols (flags, names)\n+     symbol_flags flags;\n      namelist names;\n {\n-  register namelist ptr;\n-  for (ptr = names; ; ptr++)\n-    {\n-      if (*ptr == '\\0')\n-\t{\n-\t  ptr++;\n-\t  if (*ptr == '\\0')\n-\t    return ptr;\n-\t}\n-    }\n+  symbol_table[cur_symbol_table_size].flags = flags;\n+  symbol_table[cur_symbol_table_size].names = names;\n+  cur_symbol_table_size++;\n+  if (cur_symbol_table_size >= SYMBOL_TABLE_SIZE)\n+    fatal (\"too many calls to add_symbols\");\n+  symbol_table[cur_symbol_table_size].names = NULL; /* Termination. */\n }\n \n-const char NONE[] = \"\";\n+struct std_include_entry {\n+  const char *name;\n+  symbol_flags flags;\n+  namelist names;\n+};\n+\n+const char NONE[] = \"\";  /* The empty namelist. */\n+\n+/* Special name to indicate a continuation line in std_include_table. */\n+const char CONTINUED[] = \"\";\n \n struct std_include_entry *include_entry;\n \n struct std_include_entry std_include_table [] = {\n-  { \"ctype.h\",\n+  { \"ctype.h\", ANSI_SYMBOL,\n       \"isalnum\\0isalpha\\0iscntrl\\0isdigit\\0isgraph\\0islower\\0\\\n-isprint\\0ispunct\\0isspace\\0isupper\\0isxdigit\\0tolower\\0toupper\\0\", NONE },\n+isprint\\0ispunct\\0isspace\\0isupper\\0isxdigit\\0tolower\\0toupper\\0\" },\n \n-  { \"dirent.h\", \"closedir\\0opendir\\0readdir\\0rewinddir\\0\", NONE},\n+  { \"dirent.h\", POSIX1_SYMBOL, \"closedir\\0opendir\\0readdir\\0rewinddir\\0\"},\n \n-  { \"errno.h\", NONE, \"errno\\0\" },\n+  { \"errno.h\", ANSI_SYMBOL|MACRO_SYMBOL, \"errno\\0\" },\n \n-  { \"curses.h\", \"box\\0delwin\\0endwin\\0getcurx\\0getcury\\0initscr\\0\\\n+  /* ANSI_SYMBOL is wrong, but ... */\n+  { \"curses.h\", ANSI_SYMBOL, \"box\\0delwin\\0endwin\\0getcurx\\0getcury\\0initscr\\0\\\n mvcur\\0mvwprintw\\0mvwscanw\\0newwin\\0overlay\\0overwrite\\0\\\n scroll\\0subwin\\0touchwin\\0waddstr\\0wclear\\0wclrtobot\\0wclrtoeol\\0\\\n waddch\\0wdelch\\0wdeleteln\\0werase\\0wgetch\\0wgetstr\\0winsch\\0winsertln\\0\\\n-wmove\\0wprintw\\0wrefresh\\0wscanw\\0wstandend\\0wstandout\\0\", NONE },\n+wmove\\0wprintw\\0wrefresh\\0wscanw\\0wstandend\\0wstandout\\0\" },\n \n-  { \"fcntl.h\", \"creat\\0fcntl\\0open\\0\", NONE },\n+  { \"fcntl.h\", POSIX1_SYMBOL, \"creat\\0fcntl\\0open\\0\" },\n \n   /* Maybe also \"getgrent fgetgrent setgrent endgrent\" */\n-  { \"grp.h\", \"getgrgid\\0getgrnam\\0\", NONE },\n+  { \"grp.h\", POSIX1_SYMBOL, \"getgrgid\\0getgrnam\\0\" },\n \n /*{ \"limit.h\", ... provided by gcc }, */\n \n-  { \"locale.h\", \"localeconv\\0setlocale\\0\", NONE },\n+  { \"locale.h\", ANSI_SYMBOL, \"localeconv\\0setlocale\\0\" },\n \n-  { \"math.h\", \"acos\\0asin\\0atan\\0atan2\\0ceil\\0cos\\0cosh\\0exp\\0\\\n+  { \"math.h\", ANSI_SYMBOL,\n+      \"acos\\0asin\\0atan\\0atan2\\0ceil\\0cos\\0cosh\\0exp\\0\\\n fabs\\0floor\\0fmod\\0frexp\\0ldexp\\0log10\\0log\\0modf\\0pow\\0sin\\0sinh\\0sqrt\\0\\\n-tan\\0tanh\\0\", \"HUGE_VAL\\0\" },\n+tan\\0tanh\\0\" },\n+\n+  { CONTINUED, ANSI_SYMBOL|MACRO_SYMBOL, \"HUGE_VAL\\0\" },\n \n-  { \"pwd.h\", \"getpwnam\\0getpwuid\\0\", NONE },\n+  { \"pwd.h\", POSIX1_SYMBOL, \"getpwnam\\0getpwuid\\0\" },\n \n   /* Left out siglongjmp sigsetjmp - these depend on sigjmp_buf. */\n-  { \"setjmp.h\", \"longjmp\\0setjmp\\0\", NONE },\n+  { \"setjmp.h\", ANSI_SYMBOL, \"longjmp\\0setjmp\\0\" },\n \n   /* Left out signal() - its prototype is too complex for us!\n      Also left out \"sigaction sigaddset sigdelset sigemptyset\n      sigfillset sigismember sigpending sigprocmask sigsuspend\"\n      because these need sigset_t or struct sigaction.\n      Most systems that provide them will also declare them. */\n-  { \"signal.h\", \"kill\\0raise\\0\", NONE },\n+  { \"signal.h\", ANSI_SYMBOL, \"kill\\0raise\\0\" },\n \n-  { \"stdio.h\", \"clearerr\\0fclose\\0feof\\0ferror\\0fflush\\0fgetc\\0fgetpos\\0\\\n+  { \"stdio.h\", ANSI_SYMBOL,\n+      \"clearerr\\0fclose\\0feof\\0ferror\\0fflush\\0fgetc\\0fgetpos\\0\\\n fgets\\0fopen\\0fprintf\\0fputc\\0fputs\\0fread\\0freopen\\0fscanf\\0fseek\\0\\\n-fsetpos\\0ftell\\0fwrite\\0getc\\0getchar\\0gets\\0pclose\\0perror\\0popen\\0\\\n+fsetpos\\0ftell\\0fwrite\\0getc\\0getchar\\0gets\\00perror\\0popen\\0\\\n printf\\0putc\\0putchar\\0puts\\0remove\\0rename\\0rewind\\0scanf\\0setbuf\\0\\\n setvbuf\\0sprintf\\0sscanf\\0vprintf\\0vsprintf\\0vfprintf\\0tmpfile\\0\\\n-tmpnam\\0ungetc\\0\", NONE },\n+tmpnam\\0ungetc\\0\" },\n+  { CONTINUED, POSIX1_SYMBOL, \"fdopen\\0fileno\\0\" },\n+  { CONTINUED, POSIX2_SYMBOL, \"pclose\\0popen\\0\" },  /* I think ... */\n /* Should perhaps also handle NULL, EOF, ... ? */\n \n   /* \"div ldiv\", - ignored because these depend on div_t, ldiv_t\n      ignore these: \"mblen mbstowcs mbstowc wcstombs wctomb\"\n      Left out getgroups, because SunOS4 has incompatible BSD and SVR4 versions.\n      Should perhaps also add NULL */\n-  { \"stdlib.h\", \"abort\\0abs\\0atexit\\0atof\\0atoi\\0atol\\0bsearch\\0calloc\\0\\\n+  { \"stdlib.h\", ANSI_SYMBOL,\n+      \"abort\\0abs\\0atexit\\0atof\\0atoi\\0atol\\0bsearch\\0calloc\\0\\\n exit\\0free\\0getenv\\0labs\\0malloc\\0putenv\\0qsort\\0rand\\0realloc\\0\\\n-srand\\0strtod\\0strtol\\0strtoul\\0system\\0\", NONE },\n+srand\\0strtod\\0strtol\\0strtoul\\0system\\0\" },\n \n-  { \"string.h\", \"memchr\\0memcmp\\0memcpy\\0memmove\\0memset\\0\\\n+  { \"string.h\", ANSI_SYMBOL, \"memchr\\0memcmp\\0memcpy\\0memmove\\0memset\\0\\\n strcat\\0strchr\\0strcmp\\0strcoll\\0strcpy\\0strcspn\\0strerror\\0\\\n strlen\\0strncat\\0strncmp\\0strncpy\\0strpbrk\\0strrchr\\0strspn\\0strstr\\0\\\n-strtok\\0strxfrm\\0\", NONE },\n+strtok\\0strxfrm\\0\" },\n /* Should perhaps also add NULL and size_t */\n \n-  { \"sys/stat.h\", \"chmod\\0fstat\\0mkdir\\0mkfifo\\0stat\\0lstat\\0umask\\0\",\n+  { \"sys/stat.h\", POSIX1_SYMBOL,\n+      \"chmod\\0fstat\\0mkdir\\0mkfifo\\0stat\\0lstat\\0umask\\0\" },\n+  { CONTINUED, POSIX1_SYMBOL|MACRO_SYMBOL,\n       \"S_ISDIR\\0S_ISBLK\\0S_ISCHR\\0S_ISFIFO\\0S_ISREG\\0S_ISLNK\\0S_IFDIR\\0\\\n S_IFBLK\\0S_IFCHR\\0S_IFIFO\\0S_IFREG\\0S_IFLNK\\0\" },\n \n-  { \"sys/times.h\", \"times\\0\", NONE },\n+  { \"sys/times.h\", POSIX1_SYMBOL, \"times\\0\" },\n   /* \"sys/types.h\" add types (not in old g++-include) */\n \n-  { \"sys/utsname.h\", \"uname\\0\", NONE },\n+  { \"sys/utsname.h\", POSIX1_SYMBOL, \"uname\\0\" },\n \n-  { \"sys/wait.h\", \"wait\\0waitpid\\0\",\n+  { \"sys/wait.h\", POSIX1_SYMBOL, \"wait\\0waitpid\\0\" },\n+  { CONTINUED, POSIX1_SYMBOL|MACRO_SYMBOL,\n       \"WEXITSTATUS\\0WIFEXITED\\0WIFSIGNALED\\0WIFSTOPPED\\0WSTOPSIG\\0\\\n WTERMSIG\\0WNOHANG\\0WNOTRACED\\0\" },\n \n-  { \"tar.h\", NONE, NONE },\n+  { \"tar.h\", POSIX1_SYMBOL, NONE },\n \n-  { \"termios.h\", \"cfgetispeed\\0cfgetospeed\\0cfsetispeed\\0cfsetospeed\\0tcdrain\\0tcflow\\0tcflush\\0tcgetattr\\0tcsendbreak\\0tcsetattr\\0\", NONE },\n+  { \"termios.h\", POSIX1_SYMBOL,\n+      \"cfgetispeed\\0cfgetospeed\\0cfsetispeed\\0cfsetospeed\\0tcdrain\\0tcflow\\0tcflush\\0tcgetattr\\0tcsendbreak\\0tcsetattr\\0\" },\n \n-  { \"time.h\", \"asctime\\0clock\\0ctime\\0difftime\\0gmtime\\0localtime\\0mktime\\0strftime\\0time\\0tzset\\0\", NONE },\n+  { \"time.h\", ANSI_SYMBOL,\n+      \"asctime\\0clock\\0ctime\\0difftime\\0gmtime\\0localtime\\0mktime\\0strftime\\0time\\0tzset\\0\" },\n \n-  { \"unistd.h\", \"_exit\\0access\\0alarm\\0chdir\\0chown\\0close\\0ctermid\\0cuserid\\0\\\n+  { \"unistd.h\", POSIX1_SYMBOL,\n+      \"_exit\\0access\\0alarm\\0chdir\\0chown\\0close\\0ctermid\\0cuserid\\0\\\n dup\\0dup2\\0execl\\0execle\\0execlp\\0execv\\0execve\\0execvp\\0fork\\0fpathconf\\0\\\n-getcwd\\0getegid\\0geteuid\\0getgid\\0getlogin\\0getopt\\0getpgrp\\0getpid\\0\\\n+getcwd\\0getegid\\0geteuid\\0getgid\\0getlogin\\0getpgrp\\0getpid\\0\\\n getppid\\0getuid\\0isatty\\0link\\0lseek\\0pathconf\\0pause\\0pipe\\0read\\0rmdir\\0\\\n setgid\\0setpgid\\0setsid\\0setuid\\0sleep\\0sysconf\\0tcgetpgrp\\0tcsetpgrp\\0\\\n-ttyname\\0unlink\\0write\\0\", NONE },\n+ttyname\\0unlink\\0write\\0\" },\n+  { CONTINUED, POSIX2_SYMBOL, \"getopt\\0\" },\n \n-  { 0, NONE, NONE }\n+  { NULL, 0, NONE }\n };\n \n enum special_file special_file_handling = no_special;\n@@ -320,7 +354,6 @@ sstring line;\n \n int lbrac_line, rbrac_line;\n \n-namelist required_functions_list;\n int required_unseen_count = 0;\n \n void \n@@ -519,6 +552,7 @@ read_scan_file (in_fname, argc, argv)\n   cpp_options scan_options;\n   struct fn_decl *fn;\n   int i;\n+  register struct symbol_list *cur_symbols;\n \n   obstack_init (&scan_file_obstack); \n \n@@ -532,8 +566,8 @@ read_scan_file (in_fname, argc, argv)\n   CPP_OPTIONS (&scan_in)->no_line_commands = 1;\n \n   scan_decls (&scan_in, argc, argv);\n-  check_macro_names (&scan_in, include_entry->required);\n-  check_macro_names (&scan_in, include_entry->extra);\n+  for (cur_symbols = &symbol_table[0]; cur_symbols->names; cur_symbols++)\n+    check_macro_names (&scan_in, cur_symbols->names);\n \n   if (verbose && (scan_in.errors + warnings) > 0)\n     fprintf (stderr, \"(%s: %d errors and %d warnings from cpp)\\n\",\n@@ -576,28 +610,21 @@ read_scan_file (in_fname, argc, argv)\n \t  int need_flsbuf\n \t    = flsbuf_fn && !SEEN (flsbuf_fn) && !REQUIRED (flsbuf_fn);\n \n-\t  /* Append \"_filbuf\" and/or \"_flsbuf\" to end of\n-\t     required_functions_list. */\n+\t  /* Append \"_filbuf\" and/or \"_flsbuf\" to the required functions. */\n \t  if (need_filbuf + need_flsbuf)\n \t    {\n-\t      int old_len = namelist_end (required_functions_list)\n-\t\t- required_functions_list;\n-\t      char *new_list = (char*) xmalloc (old_len + 20);\n-\t      bcopy (required_functions_list, new_list, old_len);\n+\t      char *new_list;\n \t      if (need_filbuf)\n-\t\t{\n-\t\t  strcpy (new_list + old_len, \"_filbuf\");\n-\t\t  old_len += 8;\n-\t\t  SET_REQUIRED (fn);\n-\t\t}\n+\t\tSET_REQUIRED (fn);\n \t      if (need_flsbuf)\n-\t\t{\n-\t\t  strcpy (new_list + old_len, \"_flsbuf\");\n-\t\t  old_len += 8;\n-\t\t  SET_REQUIRED (flsbuf_fn);\n-\t\t}\n-\t      new_list[old_len] = '\\0';\n-\t      required_functions_list = (namelist)new_list;\n+\t\tSET_REQUIRED (flsbuf_fn);\n+\t      if (need_flsbuf + need_filbuf == 2)\n+\t\tnew_list = \"_filbuf\\0_flsbuf\\0\";\n+\t      else if (need_flsbuf)\n+\t\tnew_list = \"_flsbuf\\0\";\n+\t      else /* if (need_flsbuf) */\n+\t\tnew_list = \"_filbuf\\0\";\n+\t      add_symbols (ANSI_SYMBOL, new_list);\n \t      required_unseen_count += need_filbuf + need_flsbuf;\n \t    }\n \t}\n@@ -637,50 +664,71 @@ write_rbrac ()\n {\n   struct fn_decl *fn;\n   const char *cptr;\n+  register struct symbol_list *cur_symbols;\n \n   if (required_unseen_count)\n     {\n-      fprintf (outf,\n-\t\"#if defined(__cplusplus) || defined(__USE_FIXED_PROTOTYPES__)\\n\");\n #ifdef NO_IMPLICIT_EXTERN_C\n       fprintf (outf, \"#ifdef __cplusplus\\nextern \\\"C\\\" {\\n#endif\\n\");\n #endif\n     }\n \n   /* Now we print out prototypes for those functions that we haven't seen. */\n-  for (cptr = required_functions_list; *cptr!= '\\0'; )\n+  for (cur_symbols = &symbol_table[0]; cur_symbols->names; cur_symbols++)\n     {\n-      int macro_protect = 0;\n-      int name_len = strlen (cptr);\n+      int if_was_emitted = 0;\n+      int name_len;\n+      cptr = cur_symbols->names;\n+      for ( ; (name_len = strlen (cptr)) != 0; cptr+= name_len + 1)\n+\t{\n+\t  int macro_protect = 0;\n \n-      fn = lookup_std_proto (cptr, name_len);\n-      cptr+= name_len + 1;\n-      if (fn == NULL || !REQUIRED (fn))\n-\tcontinue;\n+\t  if (cur_symbols->flags & MACRO_SYMBOL)\n+\t    continue;\n+\n+\t  fn = lookup_std_proto (cptr, name_len);\n+\t  if (fn == NULL || !REQUIRED (fn))\n+\t    continue;\n+\n+\t  if (!if_was_emitted)\n+\t    {\n+/*\t      what about curses. ??? or _flsbuf/_filbuf ??? */\n+\t      if (cur_symbols->flags & ANSI_SYMBOL)\n+\t\tfprintf (outf,\n+\t \"#if defined(__USE_FIXED_PROTOTYPES__) || defined(__cplusplus) || defined (__STRICT_ANSI__)\\n\");\n+\t      else\n+\t\tfprintf (outf,\n+       \"#if defined(__USE_FIXED_PROTOTYPES__) || (defined(__cplusplus) \\\\\\n\\\n+    ? (!defined(__STRICT_ANSI__) || defined(__POSIX_SOURCE__)) \\\\\\n\\\n+    : (defined(__STRICT_ANSI__) && defined(__POSIX_SOURCE__)))\\n\");\n+\t      if_was_emitted = 1;\n+\t    }\n \n-      /* In the case of memmove, protect in case the application\n-\t defines it as a macro before including the header.  */\n-      if (!strcmp (fn->fname, \"memmove\")\n-\t  || !strcmp (fn->fname, \"vprintf\")\n-\t  || !strcmp (fn->fname, \"vfprintf\")\n-\t  || !strcmp (fn->fname, \"vsprintf\")\n-\t  || !strcmp (fn->fname, \"rewinddir\"))\n-\tmacro_protect = 1;\n-\n-      if (macro_protect)\n-\tfprintf (outf, \"#ifndef %s\\n\", fn->fname);\n-      fprintf (outf, \"extern %s %s (%s);\\n\",\n-\t       fn->rtype, fn->fname, fn->params);\n-      if (macro_protect)\n-\tfprintf (outf, \"#endif\\n\");\n+\t  /* In the case of memmove, protect in case the application\n+\t     defines it as a macro before including the header.  */\n+\t  if (!strcmp (fn->fname, \"memmove\")\n+\t      || !strcmp (fn->fname, \"vprintf\")\n+\t      || !strcmp (fn->fname, \"vfprintf\")\n+\t      || !strcmp (fn->fname, \"vsprintf\")\n+\t      || !strcmp (fn->fname, \"rewinddir\"))\n+\t    macro_protect = 1;\n+\n+\t  if (macro_protect)\n+\t    fprintf (outf, \"#ifndef %s\\n\", fn->fname);\n+\t  fprintf (outf, \"extern %s %s (%s);\\n\",\n+\t\t   fn->rtype, fn->fname, fn->params);\n+\t  if (macro_protect)\n+\t    fprintf (outf, \"#endif\\n\");\n+\t}\n+      if (if_was_emitted)\n+\tfprintf (outf,\n+\t\t \"#endif /* defined(__USE_FIXED_PROTOTYPES__) || ... */\\n\");\n     }\n   if (required_unseen_count)\n     {\n #ifdef NO_IMPLICIT_EXTERN_C\n       fprintf (outf, \"#ifdef __cplusplus\\n}\\n#endif\\n\");\n #endif\n-      fprintf (outf,\n-\t\"#endif /* defined(__cplusplus) || defined(__USE_FIXED_PROTOTYPES__*/\\n\");\n     }\n \n   switch (special_file_handling)\n@@ -939,6 +987,7 @@ main (argc, argv)\n   int endif_line;\n   long to_read;\n   long int inf_size;\n+  register struct symbol_list *cur_symbols;\n \n   if (argv[0] && argv[0][0])\n     {\n@@ -988,22 +1037,41 @@ main (argc, argv)\n     special_file_handling = stdio_h;\n   include_entry = std_include_table;\n   while (include_entry->name != NULL\n-\t && strcmp (inc_filename, include_entry->name) != 0)\n+\t && (include_entry->name == CONTINUED\n+\t     || strcmp (inc_filename, include_entry->name) != 0))\n     include_entry++;\n \n-  required_functions_list = include_entry->required;\n+  if (include_entry->name != NULL)\n+    {\n+      struct std_include_entry *entry;\n+      cur_symbol_table_size = 0;\n+      for (entry = include_entry; ;)\n+\t{\n+\t  add_symbols (entry->flags, entry->names);\n+\t  entry++;\n+\t  if (entry->name != CONTINUED)\n+\t    break;\n+\t}\n+    }\n+  else\n+    symbol_table[0].names = NULL;\n \n   /* Count and mark the prototypes required for this include file. */ \n-  for (cptr = required_functions_list; *cptr!= '\\0'; )\n+  for (cur_symbols = &symbol_table[0]; cur_symbols->names; cur_symbols++)\n     {\n-      int name_len = strlen (cptr);\n-      struct fn_decl *fn = lookup_std_proto (cptr, name_len);\n-      required_unseen_count++;\n-      if (fn == NULL)\n-\tfprintf (stderr, \"Internal error:  No prototype for %s\\n\", cptr);\n-      else\n-\tSET_REQUIRED (fn);\n-      cptr += name_len + 1;\n+      int name_len;\n+      if (cur_symbols->flags & MACRO_SYMBOL)\n+\tcontinue;\n+      cptr = cur_symbols->names;\n+      for ( ; (name_len = strlen (cptr)) != 0; cptr+= name_len + 1)\n+\t{\n+\t  struct fn_decl *fn = lookup_std_proto (cptr, name_len);\n+\t  required_unseen_count++;\n+\t  if (fn == NULL)\n+\t    fprintf (stderr, \"Internal error:  No prototype for %s\\n\", cptr);\n+\t  else\n+\t    SET_REQUIRED (fn);\n+\t}\n     }\n \n   read_scan_file (argv[2], argc - 4, argv + 4);"}]}