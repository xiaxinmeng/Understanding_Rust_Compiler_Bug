{"sha": "9c21a7e7ae7182ca7ac006d245da4622c4af431e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWMyMWE3ZTdhZTcxODJjYTdhYzAwNmQyNDVkYTQ2MjJjNGFmNDMxZQ==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-02-21T06:17:54Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-02-21T06:17:54Z"}, "message": "Initial revision\n\nFrom-SVN: r350", "tree": {"sha": "7b1a34025b5534b2022e84f2b32b1cbd1dff2e0b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7b1a34025b5534b2022e84f2b32b1cbd1dff2e0b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9c21a7e7ae7182ca7ac006d245da4622c4af431e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c21a7e7ae7182ca7ac006d245da4622c4af431e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9c21a7e7ae7182ca7ac006d245da4622c4af431e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c21a7e7ae7182ca7ac006d245da4622c4af431e/comments", "author": null, "committer": null, "parents": [{"sha": "0aaa6af8c2920d6c15309a5cd853889df982abc7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0aaa6af8c2920d6c15309a5cd853889df982abc7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0aaa6af8c2920d6c15309a5cd853889df982abc7"}], "stats": {"total": 296, "additions": 296, "deletions": 0}, "files": [{"sha": "68743cd0f28ee686aff1b583f93f03d4fa5f6774", "filename": "gcc/config/vax/vax.c", "status": "added", "additions": 296, "deletions": 0, "changes": 296, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c21a7e7ae7182ca7ac006d245da4622c4af431e/gcc%2Fconfig%2Fvax%2Fvax.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c21a7e7ae7182ca7ac006d245da4622c4af431e/gcc%2Fconfig%2Fvax%2Fvax.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax.c?ref=9c21a7e7ae7182ca7ac006d245da4622c4af431e", "patch": "@@ -0,0 +1,296 @@\n+/* Subroutines for insn-output.c for Vax.\n+   Copyright (C) 1987 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#include <stdio.h>\n+#include \"config.h\"\n+#include \"rtl.h\"\n+#include \"regs.h\"\n+#include \"hard-reg-set.h\"\n+#include \"real.h\"\n+#include \"insn-config.h\"\n+#include \"conditions.h\"\n+#include \"insn-flags.h\"\n+#include \"output.h\"\n+#include \"insn-attr.h\"\n+\n+/* Return 1 if the operand is a REG, a SUBREG, or a MEM that is does not\n+   have an index.  This is used when we are using an operand in a different\n+   mode than the hardware expects.  See jlbc/jlbs.\n+\n+   This is nonimmedate_operand with a restriction on the type of MEM.  */\n+\n+int\n+reg_or_nxmem_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (! nonimmediate_operand (op, mode))\n+    return 0;\n+\n+  if (GET_CODE (op) != MEM)\n+    return 1;\n+\n+  GO_IF_NONINDEXED_ADDRESS (XEXP (op, 0), nonidx);\n+\n+  return 0;\n+\n+ nonidx:\n+  return 1;\n+}\n+\n+void\n+split_quadword_operands (operands, low, n)\n+     rtx *operands, *low;\n+     int n;\n+{\n+  int i;\n+  /* Split operands.  */\n+\n+  low[0] = low[1] = low[2] = 0;\n+  for (i = 0; i < 3; i++)\n+    {\n+      if (low[i])\n+\t/* it's already been figured out */;\n+      else if (GET_CODE (operands[i]) == MEM\n+\t       && (GET_CODE (XEXP (operands[i], 0)) == POST_INC))\n+\t{\n+\t  rtx addr = XEXP (operands[i], 0);\n+\t  operands[i] = low[i] = gen_rtx (MEM, SImode, addr);\n+\t  if (which_alternative == 0 && i == 0)\n+\t    {\n+\t      addr = XEXP (operands[i], 0);\n+\t      operands[i+1] = low[i+1] = gen_rtx (MEM, SImode, addr);\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  low[i] = operand_subword (operands[i], 0, 0, DImode);\n+\t  operands[i] = operand_subword (operands[i], 1, 0, DImode);\n+\t}\n+    }\n+}\n+\f\n+print_operand_address (file, addr)\n+     FILE *file;\n+     register rtx addr;\n+{\n+  register rtx reg1, reg2, breg, ireg;\n+  rtx offset;\n+\n+ retry:\n+  switch (GET_CODE (addr))\n+    {\n+    case MEM:\n+      fprintf (file, \"*\");\n+      addr = XEXP (addr, 0);\n+      goto retry;\n+\n+    case REG:\n+      fprintf (file, \"(%s)\", reg_names[REGNO (addr)]);\n+      break;\n+\n+    case PRE_DEC:\n+      fprintf (file, \"-(%s)\", reg_names[REGNO (XEXP (addr, 0))]);\n+      break;\n+\n+    case POST_INC:\n+      fprintf (file, \"(%s)+\", reg_names[REGNO (XEXP (addr, 0))]);\n+      break;\n+\n+    case PLUS:\n+      /* There can be either two or three things added here.  One must be a\n+\t REG.  One can be either a REG or a MULT of a REG and an appropriate\n+\t constant, and the third can only be a constant or a MEM.\n+\n+\t We get these two or three things and put the constant or MEM in\n+\t OFFSET, the MULT or REG in IREG, and the REG in BREG.  If we have\n+\t a register and can't tell yet if it is a base or index register,\n+\t put it into REG1.  */\n+\n+      reg1 = 0; ireg = 0; breg = 0; offset = 0;\n+\n+      if (CONSTANT_ADDRESS_P (XEXP (addr, 0))\n+\t  || GET_CODE (XEXP (addr, 0)) == MEM)\n+\t{\n+\t  offset = XEXP (addr, 0);\n+\t  addr = XEXP (addr, 1);\n+\t}\n+      else if (CONSTANT_ADDRESS_P (XEXP (addr, 1))\n+\t       || GET_CODE (XEXP (addr, 1)) == MEM)\n+\t{\n+\t  offset = XEXP (addr, 1);\n+\t  addr = XEXP (addr, 0);\n+\t}\n+      else if (GET_CODE (XEXP (addr, 1)) == MULT)\n+\t{\n+\t  ireg = XEXP (addr, 1);\n+\t  addr = XEXP (addr, 0);\n+\t}\n+      else if (GET_CODE (XEXP (addr, 0)) == MULT)\n+\t{\n+\t  ireg = XEXP (addr, 0);\n+\t  addr = XEXP (addr, 1);\n+\t}\n+      else if (GET_CODE (XEXP (addr, 1)) == REG)\n+\t{\n+\t  reg1 = XEXP (addr, 1);\n+\t  addr = XEXP (addr, 0);\n+\t}\n+      else\n+\tabort ();\n+\n+      if (GET_CODE (addr) == REG)\n+\t{\n+\t  if (reg1)\n+\t    ireg = addr;\n+\t  else\n+\t    reg1 = addr;\n+\t}\n+      else if (GET_CODE (addr) == MULT)\n+\tireg = addr;\n+      else if (GET_CODE (addr) == PLUS)\n+\t{\n+\t  if (CONSTANT_ADDRESS_P (XEXP (addr, 0))\n+\t      || GET_CODE (XEXP (addr, 0)) == MEM)\n+\t    {\n+\t      if (offset)\n+\t\t{\n+\t\t  if (GET_CODE (offset) == CONST_INT)\n+\t\t    offset = plus_constant (XEXP (addr, 0), INTVAL (offset));\n+\t\t  else if (GET_CODE (XEXP (addr, 0)) == CONST_INT)\n+\t\t    offset = plus_constant (offset, INTVAL (XEXP (addr, 0)));\n+\t\t  else\n+\t\t    abort ();\n+\t\t}\n+\t      offset = XEXP (addr, 0);\n+\t    }\n+\t  else if (GET_CODE (XEXP (addr, 0)) == REG)\n+\t    {\n+\t      if (reg1)\n+\t\tireg = reg1, breg = XEXP (addr, 0), reg1 = 0;\n+\t      else\n+\t\treg1 = XEXP (addr, 0);\n+\t    }\n+\t  else if (GET_CODE (XEXP (addr, 0)) == MULT)\n+\t    {\n+\t      if (ireg)\n+\t\tabort ();\n+\t      ireg = XEXP (addr, 0);\n+\t    }\n+\t  else\n+\t    abort ();\n+\n+\t  if (CONSTANT_ADDRESS_P (XEXP (addr, 1))\n+\t      || GET_CODE (XEXP (addr, 1)) == MEM)\n+\t    {\n+\t      if (offset)\n+\t\t{\n+\t\t  if (GET_CODE (offset) == CONST_INT)\n+\t\t    offset = plus_constant (XEXP (addr, 1), INTVAL (offset));\n+\t\t  else if (GET_CODE (XEXP (addr, 1)) == CONST_INT)\n+\t\t    offset = plus_constant (offset, INTVAL (XEXP (addr, 1)));\n+\t\t  else\n+\t\t    abort ();\n+\t\t}\n+\t      offset = XEXP (addr, 1);\n+\t    }\n+\t  else if (GET_CODE (XEXP (addr, 1)) == REG)\n+\t    {\n+\t      if (reg1)\n+\t\tireg = reg1, breg = XEXP (addr, 1), reg1 = 0;\n+\t      else\n+\t\treg1 = XEXP (addr, 1);\n+\t    }\n+\t  else if (GET_CODE (XEXP (addr, 1)) == MULT)\n+\t    {\n+\t      if (ireg)\n+\t\tabort ();\n+\t      ireg = XEXP (addr, 1);\n+\t    }\n+\t  else\n+\t    abort ();\n+\t}\n+      else\n+\tabort ();\n+\n+      /* If REG1 is non-zero, figure out if it is a base or index register.  */\n+      if (reg1)\n+\t{\n+\t  if (breg != 0 || (offset && GET_CODE (offset) == MEM))\n+\t    {\n+\t      if (ireg)\n+\t\tabort ();\n+\t      ireg = reg1;\n+\t    }\n+\t  else\n+\t    breg = reg1;\n+\t}\n+\n+      if (offset != 0)\n+\toutput_address (offset);\n+\n+      if (breg != 0)\n+\tfprintf (file, \"(%s)\", reg_names[REGNO (breg)]);\n+\n+      if (ireg != 0)\n+\t{\n+\t  if (GET_CODE (ireg) == MULT)\n+\t    ireg = XEXP (ireg, 0);\n+\t  if (GET_CODE (ireg) != REG)\n+\t    abort ();\n+\t  fprintf (file, \"[%s]\", reg_names[REGNO (ireg)]);\n+\t}\n+      break;\n+\n+    default:\n+      output_addr_const (file, addr);\n+    }\n+}\n+\f\n+char *\n+rev_cond_name (op)\n+     rtx op;\n+{\n+  switch (GET_CODE (op))\n+    {\n+    case EQ:\n+      return \"neq\";\n+    case NE:\n+      return \"eql\";\n+    case LT:\n+      return \"geq\";\n+    case LE:\n+      return \"gtr\";\n+    case GT:\n+      return \"leq\";\n+    case GE:\n+      return \"lss\";\n+    case LTU:\n+      return \"gequ\";\n+    case LEU:\n+      return \"gtru\";\n+    case GTU:\n+      return \"lequ\";\n+    case GEU:\n+      return \"lssu\";\n+\n+    default:\n+      abort ();\n+    }\n+}"}]}