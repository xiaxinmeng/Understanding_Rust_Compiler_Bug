{"sha": "93af36c5c18bae3a294d98e46300ea3a867ecf56", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTNhZjM2YzVjMThiYWUzYTI5NGQ5OGU0NjMwMGVhM2E4NjdlY2Y1Ng==", "commit": {"author": {"name": "Francois-Xavier Coudert", "email": "coudert@clipper.ens.fr", "date": "2005-12-04T18:13:59Z"}, "committer": {"name": "Fran\u00e7ois-Xavier Coudert", "email": "fxcoudert@gcc.gnu.org", "date": "2005-12-04T18:13:59Z"}, "message": "format.c: Removing unused code.\n\n\t* io/format.c: Removing unused code.\n\t* intrinsics/random.c: Likewise.\n\nFrom-SVN: r108014", "tree": {"sha": "437037f8e3415d485d132cfdb0607deadc2fcf78", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/437037f8e3415d485d132cfdb0607deadc2fcf78"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/93af36c5c18bae3a294d98e46300ea3a867ecf56", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93af36c5c18bae3a294d98e46300ea3a867ecf56", "html_url": "https://github.com/Rust-GCC/gccrs/commit/93af36c5c18bae3a294d98e46300ea3a867ecf56", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93af36c5c18bae3a294d98e46300ea3a867ecf56/comments", "author": null, "committer": {"login": "fxcoudert", "id": 1980544, "node_id": "MDQ6VXNlcjE5ODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1980544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fxcoudert", "html_url": "https://github.com/fxcoudert", "followers_url": "https://api.github.com/users/fxcoudert/followers", "following_url": "https://api.github.com/users/fxcoudert/following{/other_user}", "gists_url": "https://api.github.com/users/fxcoudert/gists{/gist_id}", "starred_url": "https://api.github.com/users/fxcoudert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fxcoudert/subscriptions", "organizations_url": "https://api.github.com/users/fxcoudert/orgs", "repos_url": "https://api.github.com/users/fxcoudert/repos", "events_url": "https://api.github.com/users/fxcoudert/events{/privacy}", "received_events_url": "https://api.github.com/users/fxcoudert/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0954310ff372dc9fc100b7cf1701f1c034dcff4a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0954310ff372dc9fc100b7cf1701f1c034dcff4a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0954310ff372dc9fc100b7cf1701f1c034dcff4a"}], "stats": {"total": 564, "additions": 20, "deletions": 544}, "files": [{"sha": "0fee7984bd4dc2977b6f1f8a995c2d9ca595e0c8", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93af36c5c18bae3a294d98e46300ea3a867ecf56/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93af36c5c18bae3a294d98e46300ea3a867ecf56/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=93af36c5c18bae3a294d98e46300ea3a867ecf56", "patch": "@@ -1,3 +1,8 @@\n+2005-12-04  Francois-Xavier Coudert  <coudert@clipper.ens.fr>\n+\n+\t* io/format.c: Removing unused code.\n+\t* intrinsics/random.c: Likewise.\n+\n 2005-12-02  Francois-Xavier Coudert  <coudert@clipper.ens.fr>\n \n \tPR libfortran/25116"}, {"sha": "d77a381583c728d5f806580ae0a833d4e94acdbc", "filename": "libgfortran/intrinsics/random.c", "status": "modified", "additions": 15, "deletions": 369, "changes": 384, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93af36c5c18bae3a294d98e46300ea3a867ecf56/libgfortran%2Fintrinsics%2Frandom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93af36c5c18bae3a294d98e46300ea3a867ecf56/libgfortran%2Fintrinsics%2Frandom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Frandom.c?ref=93af36c5c18bae3a294d98e46300ea3a867ecf56", "patch": "@@ -51,383 +51,30 @@ static __gthread_mutex_t random_lock = __GTHREAD_MUTEX_INIT;\n static __gthread_mutex_t random_lock;\n #endif\n \n-#if 0\n-\n-/*  The Mersenne Twister code is currently commented out due to\n-\n-    (1) Simple user specified seeds lead to really bad sequences for\n-        nearly 100000 random numbers.\n-    (2) open(), read(), and close() are not properly declared via header\n-        files.\n-    (3) The global index i is abused and causes unexpected behavior with\n-        GET and PUT.\n-    (4) See PR 15619.\n-\n-  The algorithm was taken from the paper :\n \n+/* libgfortran previously had a Mersenne Twister, taken from the paper:\n+  \n \tMersenne Twister:\t623-dimensionally equidistributed\n \t\t\t\tuniform pseudorandom generator.\n \n-\tby:\tMakoto Matsumoto\n-\t\tTakuji Nishimura\n-\n-\tWhich appeared in the: ACM Transactions on Modelling and Computer\n+\tby Makoto Matsumoto & Takuji Nishimura\n+\twhich appeared in the: ACM Transactions on Modelling and Computer\n \tSimulations: Special Issue on Uniform Random Number\n-\tGeneration. ( Early in 1998 ).  */\n-\n-\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <sys/types.h>\n-#include <sys/stat.h>\n-#include <fcntl.h>\n-\n-#ifdef HAVE_UNISTD_H\n-#include <unistd.h>\n-#endif\n-\n-/*Use the 'big' generator by default ( period -> 2**19937 ).  */\n-\n-#define MT19937\n-\n-/* Define the necessary constants for the algorithm.  */\n-\n-#ifdef  MT19937\n-enum constants\n-{\n-  N = 624, M = 397, R = 19, TU = 11, TS = 7, TT = 15, TL = 17\n-};\n-#define M_A\t0x9908B0DF\n-#define T_B\t0x9D2C5680\n-#define T_C\t0xEFC60000\n-#else\n-enum constants\n-{\n-  N = 351, M = 175, R = 19, TU = 11, TS = 7, TT = 15, TL = 17\n-};\n-#define M_A\t0xE4BD75F5\n-#define T_B\t0x655E5280\n-#define T_C\t0xFFD58000\n-#endif\n-\n-static int i = N;\n-static unsigned int seed[N];\n-\n-/* This is the routine which handles the seeding of the generator,\n-   and also reading and writing of the seed.  */\n-\n-void\n-random_seed (GFC_INTEGER_4 *size, gfc_array_i4 *put, gfc_array_i4 *get)\n-{\n-  __gthread_mutex_lock (&random_lock);\n-\n-  /* Initialize the seed in system dependent manner.  */\n-  if (get == NULL && put == NULL && size == NULL)\n-    {\n-      int fd;\n-      fd = open (\"/dev/urandom\", O_RDONLY);\n-      if (fd < 0)\n-\t{\n-\t  /* We dont have urandom.  */\n-\t  GFC_UINTEGER_4 s = (GFC_UINTEGER_4) seed;\n-\t  for (i = 0; i < N; i++)\n-\t    {\n-\t      s = s * 29943829 - 1;\n-\t      seed[i] = s;\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  /* Using urandom, might have a length issue.  */\n-\t  read (fd, &seed[0], sizeof (GFC_UINTEGER_4) * N);\n-\t  close (fd);\n-\t  i = N;\n-\t}\n-      goto return_unlock;\n-    }\n-\n-  /* Return the size of the seed */\n-  if (size != NULL)\n-    {\n-      *size = N;\n-      goto return_unlock;\n-    }\n-\n-  /* if we have gotten to this pount we have a get or put\n-   * now we check it the array fulfills the demands in the standard .\n-   */\n-\n-  /* Set the seed to PUT data */\n-  if (put != NULL)\n-    {\n-      /* if the rank of the array is not 1 abort */\n-      if (GFC_DESCRIPTOR_RANK (put) != 1)\n-\tabort ();\n-\n-      /* if the array is too small abort */\n-      if (((put->dim[0].ubound + 1 - put->dim[0].lbound)) < N)\n-\tabort ();\n-\n-      /* If this is the case the array is a temporary */\n-      if (put->dim[0].stride == 0)\n-\tgoto return_unlock;\n-\n-      /*  This code now should do correct strides. */\n-      for (i = 0; i < N; i++)\n-\tseed[i] = put->data[i * put->dim[0].stride];\n-    }\n-\n-  /* Return the seed to GET data */\n-  if (get != NULL)\n-    {\n-      /* if the rank of the array is not 1 abort */\n-      if (GFC_DESCRIPTOR_RANK (get) != 1)\n-\tabort ();\n-\n-      /* if the array is too small abort */\n-      if (((get->dim[0].ubound + 1 - get->dim[0].lbound)) < N)\n-\tabort ();\n-\n-      /* If this is the case the array is a temporary */\n-      if (get->dim[0].stride == 0)\n-\tgoto return_unlock;\n-\n-      /*  This code now should do correct strides. */\n-      for (i = 0; i < N; i++)\n-\tget->data[i * get->dim[0].stride] = seed[i];\n-    }\n-\n- random_unlock:\n-  __gthread_mutex_unlock (&random_lock);\n-}\n-iexport(random_seed);\n-\n-/* Here is the internal routine which generates the random numbers\n-   in 'batches' based upon the need for a new batch.\n-   It's an integer based routine known as 'Mersenne Twister'.\n-   This implementation still lacks 'tempering' and a good verification,\n-   but gives very good metrics.  */\n-\n-static void\n-random_generate (void)\n-{\n-  /* 32 bits.  */\n-  GFC_UINTEGER_4 y;\n-\n-  /* Generate batch of N.  */\n-  int k, m;\n-  for (k = 0, m = M; k < N - 1; k++)\n-    {\n-      y = (seed[k] & (-1 << R)) | (seed[k + 1] & ((1u << R) - 1));\n-      seed[k] = seed[m] ^ (y >> 1) ^ (-(GFC_INTEGER_4) (y & 1) & M_A);\n-      if (++m >= N)\n-\tm = 0;\n-    }\n-\n-  y = (seed[N - 1] & (-1 << R)) | (seed[0] & ((1u << R) - 1));\n-  seed[N - 1] = seed[M - 1] ^ (y >> 1) ^ (-(GFC_INTEGER_4) (y & 1) & M_A);\n-  i = 0;\n-}\n-\n-/* A routine to return a REAL(KIND=4).  */\n-\n-void\n-random_r4 (GFC_REAL_4 * harv)\n-{\n-  __gthread_mutex_lock (&random_lock);\n-\n-  /* Regenerate if we need to.  */\n-  if (i >= N)\n-    random_generate ();\n-\n-  /* Convert uint32 to REAL(KIND=4).  */\n-  *harv = (GFC_REAL_4) ((GFC_REAL_4) (GFC_UINTEGER_4) seed[i++] /\n-\t\t\t(GFC_REAL_4) (~(GFC_UINTEGER_4) 0));\n-  __gthread_mutex_unlock (&random_lock);\n-}\n-iexport(random_r4);\n-\n-/* A routine to return a REAL(KIND=8).  */\n-\n-void\n-random_r8 (GFC_REAL_8 * harv)\n-{\n-  __gthread_mutex_lock (&random_lock);\n-\n-  /* Regenerate if we need to, may waste one 32-bit value.  */\n-  if ((i + 1) >= N)\n-    random_generate ();\n-\n-  /* Convert two uint32 to a REAL(KIND=8).  */\n-  *harv = ((GFC_REAL_8) ((((GFC_UINTEGER_8) seed[i+1]) << 32) + seed[i])) /\n-\t  (GFC_REAL_8) (~(GFC_UINTEGER_8) 0);\n-  i += 2;\n-  __gthread_mutex_unlock (&random_lock);\n-}\n-iexport(random_r8);\n+\tGeneration. ( Early in 1998 ).\n \n-/* Code to handle arrays will follow here.  */\n+   The Mersenne Twister code was replaced due to\n \n-/* REAL(KIND=4) REAL array.  */\n-\n-void\n-arandom_r4 (gfc_array_r4 * harv)\n-{\n-  index_type count[GFC_MAX_DIMENSIONS];\n-  index_type extent[GFC_MAX_DIMENSIONS];\n-  index_type stride[GFC_MAX_DIMENSIONS];\n-  index_type stride0;\n-  index_type dim;\n-  GFC_REAL_4 *dest;\n-  int n;\n-\n-  dest = harv->data;\n-\n-  if (harv->dim[0].stride == 0)\n-    harv->dim[0].stride = 1;\n-\n-  dim = GFC_DESCRIPTOR_RANK (harv);\n-\n-  for (n = 0; n < dim; n++)\n-    {\n-      count[n] = 0;\n-      stride[n] = harv->dim[n].stride;\n-      extent[n] = harv->dim[n].ubound + 1 - harv->dim[n].lbound;\n-      if (extent[n] <= 0)\n-\treturn;\n-    }\n-\n-  stride0 = stride[0];\n-\n-  __gthread_mutex_lock (&random_lock);\n-\n-  while (dest)\n-    {\n-      /* Set the elements.  */\n-\n-      /* regenerate if we need to */\n-      if (i >= N)\n-\trandom_generate ();\n-\n-      /* Convert uint32 to float in a hopefully g95 compiant manner */\n-      *dest = (GFC_REAL_4) ((GFC_REAL_4) (GFC_UINTEGER_4) seed[i++] /\n-\t\t\t    (GFC_REAL_4) (~(GFC_UINTEGER_4) 0));\n-\n-      /* Advance to the next element.  */\n-      dest += stride0;\n-      count[0]++;\n-      /* Advance to the next source element.  */\n-      n = 0;\n-      while (count[n] == extent[n])\n-\t{\n-\t  /* When we get to the end of a dimension,\n-\t     reset it and increment\n-\t     the next dimension.  */\n-\t  count[n] = 0;\n-\t  /* We could precalculate these products,\n-\t     but this is a less\n-\t     frequently used path so proabably not worth it.  */\n-\t  dest -= stride[n] * extent[n];\n-\t  n++;\n-\t  if (n == dim)\n-\t    {\n-\t      dest = NULL;\n-\t      break;\n-\t    }\n-\t  else\n-\t    {\n-\t      count[n]++;\n-\t      dest += stride[n];\n-\t    }\n-\t}\n-    }\n-\n-  __gthread_mutex_unlock (&random_lock);\n-}\n-\n-/* REAL(KIND=8) array.  */\n-\n-void\n-arandom_r8 (gfc_array_r8 * harv)\n-{\n-  index_type count[GFC_MAX_DIMENSIONS];\n-  index_type extent[GFC_MAX_DIMENSIONS];\n-  index_type stride[GFC_MAX_DIMENSIONS];\n-  index_type stride0;\n-  index_type dim;\n-  GFC_REAL_8 *dest;\n-  int n;\n-\n-  dest = harv->data;\n-\n-  if (harv->dim[0].stride == 0)\n-    harv->dim[0].stride = 1;\n-\n-  dim = GFC_DESCRIPTOR_RANK (harv);\n-\n-  for (n = 0; n < dim; n++)\n-    {\n-      count[n] = 0;\n-      stride[n] = harv->dim[n].stride;\n-      extent[n] = harv->dim[n].ubound + 1 - harv->dim[n].lbound;\n-      if (extent[n] <= 0)\n-\treturn;\n-    }\n-\n-  stride0 = stride[0];\n-\n-  __gthread_mutex_lock (&random_lock);\n-\n-  while (dest)\n-    {\n-      /* Set the elements.  */\n-\n-      /* regenerate if we need to, may waste one 32-bit value */\n-      if ((i + 1) >= N)\n-\trandom_generate ();\n-\n-      /* Convert two uint32 to a REAL(KIND=8).  */\n-      *dest = ((GFC_REAL_8) ((((GFC_UINTEGER_8) seed[i+1]) << 32) + seed[i])) /\n-\t      (GFC_REAL_8) (~(GFC_UINTEGER_8) 0);\n-      i += 2;\n-\n-      /* Advance to the next element.  */\n-      dest += stride0;\n-      count[0]++;\n-      /* Advance to the next source element.  */\n-      n = 0;\n-      while (count[n] == extent[n])\n-\t{\n-\t  /* When we get to the end of a dimension,\n-\t     reset it and increment\n-\t     the next dimension.  */\n-\t  count[n] = 0;\n-\t  /* We could precalculate these products,\n-\t     but this is a less\n-\t     frequently used path so proabably not worth it.  */\n-\t  dest -= stride[n] * extent[n];\n-\t  n++;\n-\t  if (n == dim)\n-\t    {\n-\t      dest = NULL;\n-\t      break;\n-\t    }\n-\t  else\n-\t    {\n-\t      count[n]++;\n-\t      dest += stride[n];\n-\t    }\n-\t}\n-    }\n-\n-  __gthread_mutex_unlock (&random_lock);\n-}\n-\n-#else\n+    (1) Simple user specified seeds lead to really bad sequences for\n+        nearly 100000 random numbers.\n+    (2) open(), read(), and close() were not properly declared via header\n+        files.\n+    (3) The global index i was abused and caused unexpected behavior with\n+        GET and PUT.\n+    (4) See PR 15619.\n \n-/* George Marsaglia's KISS (Keep It Simple Stupid) random number generator.\n \n-   This PRNG combines:\n+   libgfortran currently uses George Marsaglia's KISS (Keep It Simple Stupid)\n+   random number generator.  This PRNG combines:\n \n    (1) The congruential generator x(n)=69069*x(n-1)+1327217885 with a period\n        of 2^32,\n@@ -733,7 +380,6 @@ random_seed (GFC_INTEGER_4 *size, gfc_array_i4 *put, gfc_array_i4 *get)\n }\n iexport(random_seed);\n \n-#endif /* mersenne twister */\n \n #ifndef __GTHREAD_MUTEX_INIT\n static void __attribute__((constructor))"}, {"sha": "23ea3175dc41aa6077d8959b2a1a5fc2c7743181", "filename": "libgfortran/io/format.c", "status": "modified", "additions": 0, "deletions": 175, "changes": 175, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93af36c5c18bae3a294d98e46300ea3a867ecf56/libgfortran%2Fio%2Fformat.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93af36c5c18bae3a294d98e46300ea3a867ecf56/libgfortran%2Fio%2Fformat.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fformat.c?ref=93af36c5c18bae3a294d98e46300ea3a867ecf56", "patch": "@@ -1117,178 +1117,3 @@ unget_format (st_parameter_dt *dtp, const fnode *f)\n   dtp->u.p.fmt->saved_format = f;\n }\n \n-\n-\n-\n-#if 0\n-\n-static void dump_format1 (fnode * f);\n-\n-/* dump_format0()-- Dump a single format node */\n-\n-void\n-dump_format0 (fnode * f)\n-{\n-  char *p;\n-  int i;\n-\n-  switch (f->format)\n-    {\n-    case FMT_COLON:\n-      st_printf (\" :\");\n-      break;\n-    case FMT_SLASH:\n-      st_printf (\" %d/\", f->u.r);\n-      break;\n-    case FMT_DOLLAR:\n-      st_printf (\" $\");\n-      break;\n-    case FMT_T:\n-      st_printf (\" T%d\", f->u.n);\n-      break;\n-    case FMT_TR:\n-      st_printf (\" TR%d\", f->u.n);\n-      break;\n-    case FMT_TL:\n-      st_printf (\" TL%d\", f->u.n);\n-      break;\n-    case FMT_X:\n-      st_printf (\" %dX\", f->u.n);\n-      break;\n-    case FMT_S:\n-      st_printf (\" S\");\n-      break;\n-    case FMT_SS:\n-      st_printf (\" SS\");\n-      break;\n-    case FMT_SP:\n-      st_printf (\" SP\");\n-      break;\n-\n-    case FMT_LPAREN:\n-      if (f->repeat == 1)\n-\tst_printf (\" (\");\n-      else\n-\tst_printf (\" %d(\", f->repeat);\n-\n-      dump_format1 (f->u.child);\n-      st_printf (\" )\");\n-      break;\n-\n-    case FMT_STRING:\n-      st_printf (\" '\");\n-      p = f->u.string.p;\n-      for (i = f->u.string.length; i > 0; i--)\n-\tst_printf (\"%c\", *p++);\n-\n-      st_printf (\"'\");\n-      break;\n-\n-    case FMT_P:\n-      st_printf (\" %dP\", f->u.k);\n-      break;\n-    case FMT_I:\n-      st_printf (\" %dI%d.%d\", f->repeat, f->u.integer.w, f->u.integer.m);\n-      break;\n-\n-    case FMT_B:\n-      st_printf (\" %dB%d.%d\", f->repeat, f->u.integer.w, f->u.integer.m);\n-      break;\n-\n-    case FMT_O:\n-      st_printf (\" %dO%d.%d\", f->repeat, f->u.integer.w, f->u.integer.m);\n-      break;\n-\n-    case FMT_Z:\n-      st_printf (\" %dZ%d.%d\", f->repeat, f->u.integer.w, f->u.integer.m);\n-      break;\n-\n-    case FMT_BN:\n-      st_printf (\" BN\");\n-      break;\n-    case FMT_BZ:\n-      st_printf (\" BZ\");\n-      break;\n-    case FMT_D:\n-      st_printf (\" %dD%d.%d\", f->repeat, f->u.real.w, f->u.real.d);\n-      break;\n-\n-    case FMT_EN:\n-      st_printf (\" %dEN%d.%dE%d\", f->repeat, f->u.real.w, f->u.real.d,\n-\t\t f->u.real.e);\n-      break;\n-\n-    case FMT_ES:\n-      st_printf (\" %dES%d.%dE%d\", f->repeat, f->u.real.w, f->u.real.d,\n-\t\t f->u.real.e);\n-      break;\n-\n-    case FMT_F:\n-      st_printf (\" %dF%d.%d\", f->repeat, f->u.real.w, f->u.real.d);\n-      break;\n-\n-    case FMT_E:\n-      st_printf (\" %dE%d.%dE%d\", f->repeat, f->u.real.w, f->u.real.d,\n-\t\t f->u.real.e);\n-      break;\n-\n-    case FMT_G:\n-      st_printf (\" %dG%d.%dE%d\", f->repeat, f->u.real.w, f->u.real.d,\n-\t\t f->u.real.e);\n-      break;\n-\n-    case FMT_L:\n-      st_printf (\" %dL%d\", f->repeat, f->u.w);\n-      break;\n-    case FMT_A:\n-      st_printf (\" %dA%d\", f->repeat, f->u.w);\n-      break;\n-\n-    default:\n-      st_printf (\" ???\");\n-      break;\n-    }\n-}\n-\n-\n-/* dump_format1()-- Dump a string of format nodes */\n-\n-static void\n-dump_format1 (fnode * f)\n-{\n-  for (; f; f = f->next)\n-    dump_format1 (f);\n-}\n-\n-/* dump_format()-- Dump the whole format node tree */\n-\n-void\n-dump_format (void)\n-{\n-  st_printf (\"format = \");\n-  dump_format0 (&array[0]);\n-  st_printf (\"\\n\");\n-}\n-\n-\n-void\n-next_test (st_parameter_dt *dtp)\n-{\n-  fnode *f;\n-  int i;\n-\n-  for (i = 0; i < 20; i++)\n-    {\n-      f = next_format (dtp);\n-      if (f == NULL)\n-\t{\n-\t  st_printf (\"No format!\\n\");\n-\t  break;\n-\t}\n-\n-      dump_format1 (f);\n-      st_printf (\"\\n\");\n-    }\n-}\n-\n-#endif"}]}