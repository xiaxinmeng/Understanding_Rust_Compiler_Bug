{"sha": "7bd8b2a885f2da446a65513fb713badf09a9793e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2JkOGIyYTg4NWYyZGE0NDZhNjU1MTNmYjcxM2JhZGYwOWE5NzkzZQ==", "commit": {"author": {"name": "Jeffrey A Law", "email": "law@cygnus.com", "date": "1998-07-05T23:59:03Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-07-05T23:59:03Z"}, "message": "cse.c (cse_insn): Second arg is an RTX now.\n\n        * cse.c (cse_insn): Second arg is an RTX now.  Update all callers.\n        (cse_basic_block): Keep track of the current RETVAL insn for a\n        libcall instead of just noting that we're in a libcall.\n\nFrom-SVN: r20936", "tree": {"sha": "6acb1ac91bbb9f5debf8f0c2c22f5155195b3d33", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6acb1ac91bbb9f5debf8f0c2c22f5155195b3d33"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7bd8b2a885f2da446a65513fb713badf09a9793e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7bd8b2a885f2da446a65513fb713badf09a9793e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7bd8b2a885f2da446a65513fb713badf09a9793e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7bd8b2a885f2da446a65513fb713badf09a9793e/comments", "author": null, "committer": null, "parents": [{"sha": "9de2c71a47cdd2531c359d20c839c1a0b6cccfe6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9de2c71a47cdd2531c359d20c839c1a0b6cccfe6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9de2c71a47cdd2531c359d20c839c1a0b6cccfe6"}], "stats": {"total": 37, "additions": 27, "deletions": 10}, "files": [{"sha": "296556e977c0bdf11d3190cce75932f8d27e6671", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bd8b2a885f2da446a65513fb713badf09a9793e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bd8b2a885f2da446a65513fb713badf09a9793e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7bd8b2a885f2da446a65513fb713badf09a9793e", "patch": "@@ -5,6 +5,10 @@ Mon Jul  6 00:28:43 1998  Mark Mitchell  <mark@markmitchell.com>\n \n Sun Jul  5 23:58:19 1998  Jeffrey A Law  (law@cygnus.com)\n \n+\t* cse.c (cse_insn): Second arg is an RTX now.  Update all callers.\n+\t(cse_basic_block): Keep track of the current RETVAL insn for a\n+\tlibcall instead of just noting that we're in a libcall.\n+\n \t* combine.c (simplify_comparison): Do not commute a AND into\n \ta paradoxical SUBREG if not WORD_REGISTER_OPERATIONS.\n "}, {"sha": "22a4a6d496adc268cfb23f93bbac42c1472e41a7", "filename": "gcc/cse.c", "status": "modified", "additions": 23, "deletions": 10, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bd8b2a885f2da446a65513fb713badf09a9793e/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bd8b2a885f2da446a65513fb713badf09a9793e/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=7bd8b2a885f2da446a65513fb713badf09a9793e", "patch": "@@ -641,7 +641,7 @@ static rtx equiv_constant\tPROTO((rtx));\n static void record_jump_equiv\tPROTO((rtx, int));\n static void record_jump_cond\tPROTO((enum rtx_code, enum machine_mode,\n \t\t\t\t       rtx, rtx, int));\n-static void cse_insn\t\tPROTO((rtx, int));\n+static void cse_insn\t\tPROTO((rtx, rtx));\n static int note_mem_written\tPROTO((rtx));\n static void invalidate_from_clobbers PROTO((rtx));\n static rtx cse_process_notes\tPROTO((rtx, rtx));\n@@ -6144,9 +6144,9 @@ struct set\n };\n \n static void\n-cse_insn (insn, in_libcall_block)\n+cse_insn (insn, libcall_insn)\n      rtx insn;\n-     int in_libcall_block;\n+     rtx libcall_insn;\n {\n   register rtx x = PATTERN (insn);\n   register int i;\n@@ -6839,7 +6839,7 @@ cse_insn (insn, in_libcall_block)\n          the current contents will be tested and will always be valid.  */\n       while (1)\n         {\n-          rtx trial;\n+          rtx trial, old_src;\n \n           /* Skip invalid entries.  */\n           while (elt && GET_CODE (elt->exp) != REG\n@@ -6905,6 +6905,10 @@ cse_insn (insn, in_libcall_block)\n \t     insert the substitution here and we will delete and re-emit\n \t     the insn later.  */\n \n+\t  /* Keep track of the original SET_SRC so that we can fix notes\n+\t     on libcall instructions.  */\n+ \t  old_src = SET_SRC (sets[i].rtl);\n+\n \t  if (n_sets == 1 && dest == pc_rtx\n \t      && (trial == pc_rtx\n \t\t  || (GET_CODE (trial) == LABEL_REF\n@@ -6929,6 +6933,13 @@ cse_insn (insn, in_libcall_block)\n \t  /* Look for a substitution that makes a valid insn.  */\n           else if (validate_change (insn, &SET_SRC (sets[i].rtl), trial, 0))\n \t    {\n+\t      /* If we just made a substitution inside a libcall, then we\n+\t\t need to make the same substitution in any notes attached\n+\t\t to the RETVAL insn.  */\n+\t      if (libcall_insn)\n+\t\treplace_rtx (REG_NOTES (libcall_insn), old_src, \n+\t\t\t     canon_reg (SET_SRC (sets[i].rtl), insn));\n+\n \t      /* The result of apply_change_group can be ignored; see\n \t\t canon_reg.  */\n \n@@ -7422,7 +7433,7 @@ cse_insn (insn, in_libcall_block)\n \t       since we might delete the libcall.  Things should have been set\n \t       up so we won't want to reuse such a value, but we play it safe\n \t       here.  */\n-\t    || in_libcall_block\n+\t    || libcall_insn\n \t    /* If we didn't put a REG_EQUAL value or a source into the hash\n \t       table, there is no point is recording DEST.  */\n \t    || sets[i].src_elt == 0\n@@ -8509,7 +8520,7 @@ cse_basic_block (from, to, next_branch, around_loop)\n {\n   register rtx insn;\n   int to_usage = 0;\n-  int in_libcall_block = 0;\n+  rtx libcall_insn = NULL_RTX;\n   int num_insns = 0;\n \n   /* Each of these arrays is undefined before max_reg, so only allocate\n@@ -8599,6 +8610,8 @@ cse_basic_block (from, to, next_branch, around_loop)\n \n       if (GET_RTX_CLASS (code) == 'i')\n \t{\n+\t  rtx p;\n+\n \t  /* Process notes first so we have all notes in canonical forms when\n \t     looking for duplicate operations.  */\n \n@@ -8611,12 +8624,12 @@ cse_basic_block (from, to, next_branch, around_loop)\n \t     its destination is the result of the block and hence should be\n \t     recorded.  */\n \n-\t  if (find_reg_note (insn, REG_LIBCALL, NULL_RTX))\n-\t    in_libcall_block = 1;\n+\t  if (p = find_reg_note (insn, REG_LIBCALL, NULL_RTX))\n+\t    libcall_insn = XEXP (p, 0);\n \t  else if (find_reg_note (insn, REG_RETVAL, NULL_RTX))\n-\t    in_libcall_block = 0;\n+\t    libcall_insn = NULL_RTX;\n \n-\t  cse_insn (insn, in_libcall_block);\n+\t  cse_insn (insn, libcall_insn);\n \t}\n \n       /* If INSN is now an unconditional jump, skip to the end of our"}]}