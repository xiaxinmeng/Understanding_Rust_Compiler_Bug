{"sha": "7f5b8ca7682f78f5c48e027a51d192d95e1ff35a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2Y1YjhjYTc2ODJmNzhmNWM0OGUwMjdhNTFkMTkyZDk1ZTFmZjM1YQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-05-10T14:33:50Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-05-10T14:33:50Z"}, "message": "Add declarations of static functions.\n\n(unroll_loop): Renumber reg local to loop for each unrolled iteration.\n\nFrom-SVN: r9610", "tree": {"sha": "e2335c497a42925f221c9d78cbbb8475d085aec7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e2335c497a42925f221c9d78cbbb8475d085aec7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7f5b8ca7682f78f5c48e027a51d192d95e1ff35a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f5b8ca7682f78f5c48e027a51d192d95e1ff35a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7f5b8ca7682f78f5c48e027a51d192d95e1ff35a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f5b8ca7682f78f5c48e027a51d192d95e1ff35a/comments", "author": null, "committer": null, "parents": [{"sha": "0af3ee306ab1694a1daa5180991454bb5e66c6ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0af3ee306ab1694a1daa5180991454bb5e66c6ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0af3ee306ab1694a1daa5180991454bb5e66c6ce"}], "stats": {"total": 55, "additions": 46, "deletions": 9}, "files": [{"sha": "d5a58208d83af9ab0408ae172c09edf333c58130", "filename": "gcc/unroll.c", "status": "modified", "additions": 46, "deletions": 9, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f5b8ca7682f78f5c48e027a51d192d95e1ff35a/gcc%2Funroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f5b8ca7682f78f5c48e027a51d192d95e1ff35a/gcc%2Funroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funroll.c?ref=7f5b8ca7682f78f5c48e027a51d192d95e1ff35a", "patch": "@@ -193,15 +193,22 @@ static rtx loop_final_value;\n \n /* Forward declarations.  */\n \n-static void init_reg_map ();\n-static int precondition_loop_p ();\n-static void copy_loop_body ();\n-static void iteration_info ();\n-static rtx approx_final_value ();\n-static int find_splittable_regs ();\n-static int find_splittable_givs ();\n-static rtx fold_rtx_mult_add ();\n-static rtx remap_split_bivs ();\n+static void init_reg_map PROTO((struct inline_remap *, int));\n+static int precondition_loop_p PROTO((rtx *, rtx *, rtx *, rtx, rtx));\n+static rtx calculate_giv_inc PROTO((rtx, rtx, int));\n+static rtx initial_reg_note_copy PROTO((rtx, struct inline_remap *));\n+static void final_reg_note_copy PROTO((rtx, struct inline_remap *));\n+static void copy_loop_body PROTO((rtx, rtx, struct inline_remap *, rtx, int,\n+\t\t\t\t  enum unroll_types, rtx, rtx, rtx, rtx));\n+static int back_branch_in_range_p PROTO((rtx, rtx, rtx));\n+static void iteration_info PROTO((rtx, rtx *, rtx *, rtx, rtx));\n+static rtx approx_final_value PROTO((enum rtx_code, rtx, int *, int *));\n+static int find_splittable_regs PROTO((enum unroll_types, rtx, rtx, rtx, int));\n+static int find_splittable_givs PROTO((struct iv_class *,enum unroll_types,\n+\t\t\t\t       rtx, rtx, rtx, int));\n+static int reg_dead_after_loop PROTO((rtx, rtx, rtx));\n+static rtx fold_rtx_mult_add PROTO((rtx, rtx, rtx, enum machine_mode));\n+static rtx remap_split_bivs PROTO((rtx));\n \n /* Try to unroll one loop and split induction variables in the loop.\n \n@@ -231,6 +238,7 @@ unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n   rtx insert_before;\n   struct inline_remap *map;\n   char *local_label;\n+  char *local_regno;\n   int maxregnum;\n   int new_maxregnum;\n   rtx exit_label = 0;\n@@ -711,6 +719,27 @@ unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n   addr_combined_regs\n     = (struct induction **) alloca (maxregnum * sizeof (struct induction *));\n   bzero ((char *) addr_combined_regs, maxregnum * sizeof (struct induction *));\n+  local_regno = (char *) alloca (maxregnum);\n+  bzero (local_regno, maxregnum);\n+\n+  /* Mark all local registers, i.e. the ones which are referenced only\n+     inside the loop. */\n+  {\n+    int copy_start_luid = INSN_LUID (copy_start);\n+    int copy_end_luid = INSN_LUID (copy_end);\n+\n+    for (j = 0; j < maxregnum; ++j)\n+      {\n+\tint first_uid = regno_first_uid[j];\n+\tint last_uid = regno_last_uid[j];\n+\n+\tif (first_uid > 0 && first_uid <= max_uid_for_loop\n+\t    && uid_luid[first_uid] >= copy_start_luid\n+\t    && last_uid > 0 && last_uid <= max_uid_for_loop\n+\t    && uid_luid[last_uid] <= copy_end_luid)\n+\t  local_regno[j] = 1;\n+      }\n+  }\n \n   /* If this loop requires exit tests when unrolled, check to see if we\n      can precondition the loop so as to make the exit tests unnecessary.\n@@ -923,6 +952,10 @@ unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n \t\tif (local_label[j])\n \t\t  map->label_map[j] = gen_label_rtx ();\n \n+\t      for (j = 0; j < maxregnum; j++)\n+\t\tif (local_regno[j])\n+\t\t  map->reg_map[j] = gen_reg_rtx (GET_MODE (regno_reg_rtx[j]));\n+\n \t      /* The last copy needs the compare/branch insns at the end,\n \t\t so reset copy_end here if the loop ends with a conditional\n \t\t branch.  */\n@@ -1060,6 +1093,10 @@ unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n \tif (local_label[j])\n \t  map->label_map[j] = gen_label_rtx ();\n \n+      for (j = 0; j < maxregnum; j++)\n+\tif (local_regno[j])\n+\t  map->reg_map[j] = gen_reg_rtx (GET_MODE (regno_reg_rtx[j]));\n+\n       /* If loop starts with a branch to the test, then fix it so that\n \t it points to the test of the first unrolled copy of the loop.  */\n       if (i == 0 && loop_start != copy_start)"}]}