{"sha": "9f34b780b0461ec7b2b2defe96e44ab616ea2aa3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWYzNGI3ODBiMDQ2MWVjN2IyYjJkZWZlOTZlNDRhYjYxNmVhMmFhMw==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-07-07T09:41:03Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-07-07T11:48:26Z"}, "message": "tree-optimization/99728 - improve LIM for loops with aggregate copies\n\nThis improves LIM by recording aggregate copies for disambiguation\npurposes instead of as UNANALYZABLE_MEM which will prevent any\ninvariant or store motion across it.  This allows four of the six\nreferences in the loop of the testcase to be promoted.\n\n2021-07-07  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/99728\n\t* tree-ssa-loop-im.c (gather_mem_refs_stmt): Record\n\taggregate copies.\n\t(mem_refs_may_alias_p): Add assert we handled aggregate\n\tcopies elsewhere.\n\t(sm_seq_valid_bb): Give up when running into aggregate copies.\n\t(ref_indep_loop_p): Handle aggregate copies as never\n\tbeing invariant themselves but allow other refs to be\n\tdisambiguated against them.\n\t(can_sm_ref_p): Do not try to apply store-motion to aggregate\n\tcopies.\n\n\t* g++.dg/opt/pr99728.C: New testcase.", "tree": {"sha": "2d8d45ef233f09fc56f46fb6926198c55d5727db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2d8d45ef233f09fc56f46fb6926198c55d5727db"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9f34b780b0461ec7b2b2defe96e44ab616ea2aa3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f34b780b0461ec7b2b2defe96e44ab616ea2aa3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9f34b780b0461ec7b2b2defe96e44ab616ea2aa3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f34b780b0461ec7b2b2defe96e44ab616ea2aa3/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "98bfd845e93937d92ca844d7fa7e853ad51c6193", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98bfd845e93937d92ca844d7fa7e853ad51c6193", "html_url": "https://github.com/Rust-GCC/gccrs/commit/98bfd845e93937d92ca844d7fa7e853ad51c6193"}], "stats": {"total": 109, "additions": 102, "deletions": 7}, "files": [{"sha": "d4393231b4c0f06a15ebbad12e353cd37681a8a2", "filename": "gcc/testsuite/g++.dg/opt/pr99728.C", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f34b780b0461ec7b2b2defe96e44ab616ea2aa3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fpr99728.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f34b780b0461ec7b2b2defe96e44ab616ea2aa3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fpr99728.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fpr99728.C?ref=9f34b780b0461ec7b2b2defe96e44ab616ea2aa3", "patch": "@@ -0,0 +1,50 @@\n+// PR/99728\n+// { dg-do compile }\n+// { dg-options \"-O2 -fdump-tree-lim2-details -w -Wno-psabi\" }\n+\n+typedef double __m256d __attribute__((vector_size(sizeof (double) * 4)));\n+extern __inline __m256d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm256_set1_pd (double __A)\n+{\n+  return __extension__ (__m256d){ __A, __A, __A, __A };\n+}\n+\n+// simple OO wrapper around __m256d\n+struct Tvsimple\n+  {\n+  __m256d v;\n+  Tvsimple &operator+=(const Tvsimple &other) {v+=other.v; return *this;}\n+  Tvsimple operator*(double val) const { Tvsimple res; res.v = v*_mm256_set1_pd(val); return res;}\n+  Tvsimple operator*(Tvsimple val) const { Tvsimple res; res.v = v*val.v; return res; }\n+  Tvsimple operator+(Tvsimple val) const { Tvsimple res; res.v = v+val.v; return res; }\n+  Tvsimple operator+(double val) const { Tvsimple res; res.v = v+_mm256_set1_pd(val); return res;}\n+  };\n+\n+template<typename vtype> struct s0data_s\n+  { vtype sth, corfac, scale, lam1, lam2, csq, p1r, p1i, p2r, p2i; };\n+\n+template<typename vtype> void foo(s0data_s<vtype> & __restrict__ d,\n+  const double * __restrict__ coef, const double * __restrict__ alm,\n+  unsigned long l, unsigned long il, unsigned long lmax)\n+  {\n+// critical loop\n+  while (l<=lmax)\n+    {\n+    d.p1r += d.lam2*alm[2*l];\n+    d.p1i += d.lam2*alm[2*l+1];\n+    d.p2r += d.lam2*alm[2*l+2];\n+    d.p2i += d.lam2*alm[2*l+3];\n+    Tvsimple tmp = d.lam2*(d.csq*coef[2*il] + coef[2*il+1]) + d.lam1;\n+    d.lam1 = d.lam2;\n+    d.lam2 = tmp;\n+    ++il; l+=2;\n+    }\n+  }\n+\n+// this version has dead stores at the end of the loop\n+template void foo<>(s0data_s<Tvsimple> & __restrict__ d,\n+  const double * __restrict__ coef, const double * __restrict__ alm,\n+  unsigned long l, unsigned long il, unsigned long lmax);\n+\n+// The aggregate copy in the IL should not prevent all store-motion\n+// { dg-final { scan-tree-dump-times \"Executing store motion\" 4 \"lim2\" } }"}, {"sha": "81b4ec21d6ea4875a7c0d22702a1b2c517a4d1a0", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 52, "deletions": 7, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f34b780b0461ec7b2b2defe96e44ab616ea2aa3/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f34b780b0461ec7b2b2defe96e44ab616ea2aa3/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=9f34b780b0461ec7b2b2defe96e44ab616ea2aa3", "patch": "@@ -122,16 +122,17 @@ class im_mem_ref\n   hashval_t hash;\t\t/* Its hash value.  */\n \n   /* The memory access itself and associated caching of alias-oracle\n-     query meta-data.  */\n+     query meta-data.  We are using mem.ref == error_mark_node for the\n+     case the reference is represented by its single access stmt\n+     in accesses_in_loop[0].  */\n   ao_ref mem;\n \n   bitmap stored;\t\t/* The set of loops in that this memory location\n \t\t\t\t   is stored to.  */\n   bitmap loaded;\t\t/* The set of loops in that this memory location\n \t\t\t\t   is loaded from.  */\n   vec<mem_ref_loc>\t\taccesses_in_loop;\n-\t\t\t\t/* The locations of the accesses.  Vector\n-\t\t\t\t   indexed by the loop number.  */\n+\t\t\t\t/* The locations of the accesses.  */\n \n   /* The following set is computed on demand.  */\n   bitmap_head dep_loop;\t\t/* The set of loops in that the memory\n@@ -1465,7 +1466,22 @@ gather_mem_refs_stmt (class loop *loop, gimple *stmt)\n     return;\n \n   mem = simple_mem_ref_in_stmt (stmt, &is_stored);\n-  if (!mem)\n+  if (!mem && is_gimple_assign (stmt))\n+    {\n+      /* For aggregate copies record distinct references but use them\n+\t only for disambiguation purposes.  */\n+      id = memory_accesses.refs_list.length ();\n+      ref = mem_ref_alloc (NULL, 0, id);\n+      memory_accesses.refs_list.safe_push (ref);\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  fprintf (dump_file, \"Unhandled memory reference %u: \", id);\n+\t  print_gimple_stmt (dump_file, stmt, 0, TDF_SLIM);\n+\t}\n+      record_mem_ref_loc (ref, stmt, mem);\n+      is_stored = gimple_vdef (stmt);\n+    }\n+  else if (!mem)\n     {\n       /* We use the shared mem_ref for all unanalyzable refs.  */\n       id = UNANALYZABLE_MEM_ID;\n@@ -1595,7 +1611,8 @@ gather_mem_refs_stmt (class loop *loop, gimple *stmt)\n       mark_ref_stored (ref, loop);\n     }\n   /* A not simple memory op is also a read when it is a write.  */\n-  if (!is_stored || id == UNANALYZABLE_MEM_ID)\n+  if (!is_stored || id == UNANALYZABLE_MEM_ID\n+      || ref->mem.ref == error_mark_node)\n     {\n       bitmap_set_bit (&memory_accesses.refs_loaded_in_loop[loop->num], ref->id);\n       mark_ref_loaded (ref, loop);\n@@ -1714,6 +1731,9 @@ mem_refs_may_alias_p (im_mem_ref *mem1, im_mem_ref *mem2,\n \t\t      hash_map<tree, name_expansion *> **ttae_cache,\n \t\t      bool tbaa_p)\n {\n+  gcc_checking_assert (mem1->mem.ref != error_mark_node\n+\t\t       && mem2->mem.ref != error_mark_node);\n+\n   /* Perform BASE + OFFSET analysis -- if MEM1 and MEM2 are based on the same\n      object and their offset differ in such a way that the locations cannot\n      overlap, then they cannot alias.  */\n@@ -2490,6 +2510,13 @@ sm_seq_valid_bb (class loop *loop, basic_block bb, tree vdef,\n       gcc_assert (data);\n       if (data->ref == UNANALYZABLE_MEM_ID)\n \treturn -1;\n+      /* Stop at memory references which we can't move.  */\n+      else if (memory_accesses.refs_list[data->ref]->mem.ref == error_mark_node)\n+\t{\n+\t  /* Mark refs_not_in_seq as unsupported.  */\n+\t  bitmap_ior_into (refs_not_supported, refs_not_in_seq);\n+\t  return 1;\n+\t}\n       /* One of the stores we want to apply SM to and we've not yet seen.  */\n       else if (bitmap_clear_bit (refs_not_in_seq, data->ref))\n \t{\n@@ -2798,7 +2825,8 @@ ref_indep_loop_p (class loop *loop, im_mem_ref *ref, dep_kind kind)\n   else\n     refs_to_check = &memory_accesses.refs_stored_in_loop[loop->num];\n \n-  if (bitmap_bit_p (refs_to_check, UNANALYZABLE_MEM_ID))\n+  if (bitmap_bit_p (refs_to_check, UNANALYZABLE_MEM_ID)\n+      || ref->mem.ref == error_mark_node)\n     indep_p = false;\n   else\n     {\n@@ -2825,7 +2853,20 @@ ref_indep_loop_p (class loop *loop, im_mem_ref *ref, dep_kind kind)\n \t  EXECUTE_IF_SET_IN_BITMAP (refs_to_check, 0, i, bi)\n \t    {\n \t      im_mem_ref *aref = memory_accesses.refs_list[i];\n-\t      if (!refs_independent_p (ref, aref, kind != sm_waw))\n+\t      if (aref->mem.ref == error_mark_node)\n+\t\t{\n+\t\t  gimple *stmt = aref->accesses_in_loop[0].stmt;\n+\t\t  if ((kind == sm_war\n+\t\t       && ref_maybe_used_by_stmt_p (stmt, &ref->mem,\n+\t\t\t\t\t\t    kind != sm_waw))\n+\t\t      || stmt_may_clobber_ref_p_1 (stmt, &ref->mem,\n+\t\t\t\t\t\t   kind != sm_waw))\n+\t\t    {\n+\t\t      indep_p = false;\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\t      else if (!refs_independent_p (ref, aref, kind != sm_waw))\n \t\t{\n \t\t  indep_p = false;\n \t\t  break;\n@@ -2858,6 +2899,10 @@ can_sm_ref_p (class loop *loop, im_mem_ref *ref)\n   if (!MEM_ANALYZABLE (ref))\n     return false;\n \n+  /* Can't hoist/sink aggregate copies.  */\n+  if (ref->mem.ref == error_mark_node)\n+    return false;\n+\n   /* It should be movable.  */\n   if (!is_gimple_reg_type (TREE_TYPE (ref->mem.ref))\n       || TREE_THIS_VOLATILE (ref->mem.ref)"}]}