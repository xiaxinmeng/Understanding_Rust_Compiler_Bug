{"sha": "17f4d4bfc102925666ffdf8b0b1567535e2daf64", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTdmNGQ0YmZjMTAyOTI1NjY2ZmZkZjhiMGIxNTY3NTM1ZTJkYWY2NA==", "commit": {"author": {"name": "Chris Schlumberger-Socha", "email": "chris.schlumberger-socha@arm.com", "date": "2013-05-29T12:57:33Z"}, "committer": {"name": "Marcus Shawcroft", "email": "mshawcroft@gcc.gnu.org", "date": "2013-05-29T12:57:33Z"}, "message": "[AArch64] Re-organize aarch64_classify_symbol.\n\nThis patch re-orgnaizes the implementation of aarch64_classify_symbol\nin preparation for tiny absolute memory model support.\n\n\nCo-Authored-By: Marcus Shawcroft <marcus.shawcroft@arm.com>\n\nFrom-SVN: r199407", "tree": {"sha": "5dc6c38771b22e0ee17f7166316a1bf3a9e34239", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5dc6c38771b22e0ee17f7166316a1bf3a9e34239"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/17f4d4bfc102925666ffdf8b0b1567535e2daf64", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17f4d4bfc102925666ffdf8b0b1567535e2daf64", "html_url": "https://github.com/Rust-GCC/gccrs/commit/17f4d4bfc102925666ffdf8b0b1567535e2daf64", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17f4d4bfc102925666ffdf8b0b1567535e2daf64/comments", "author": null, "committer": null, "parents": [{"sha": "c0186656108d130c8af13422b4f8c2dbe3f93862", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0186656108d130c8af13422b4f8c2dbe3f93862", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c0186656108d130c8af13422b4f8c2dbe3f93862"}], "stats": {"total": 59, "additions": 26, "deletions": 33}, "files": [{"sha": "6c4997351f0b2a8403cf934d7a1b5ae8ae045126", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17f4d4bfc102925666ffdf8b0b1567535e2daf64/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17f4d4bfc102925666ffdf8b0b1567535e2daf64/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=17f4d4bfc102925666ffdf8b0b1567535e2daf64", "patch": "@@ -1,3 +1,9 @@\n+2013-05-29  Chris Schlumberger-Socha <chris.schlumberger-socha@arm.com>\n+\t    Marcus Shawcroft  <marcus.shawcroft@arm.com>\n+\n+\t* config/aarch64/aarch64.c (aarch64_classify_symbol): Remove comment.\n+\tRefactor if/switch.  Replace gcc_assert with if.\n+\n 2013-05-29  Ganesh Gopalasubramanian  <Ganesh.Gopalasubramanian@amd.com>\n \n \t* config/i386/i386.c (initial_ix86_tune_features): Enable"}, {"sha": "59e6234291b47630e0ea1202228585d2bc974bfe", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 20, "deletions": 33, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17f4d4bfc102925666ffdf8b0b1567535e2daf64/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17f4d4bfc102925666ffdf8b0b1567535e2daf64/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=17f4d4bfc102925666ffdf8b0b1567535e2daf64", "patch": "@@ -5016,6 +5016,7 @@ aarch64_classify_tls_symbol (rtx x)\n \n /* Return the method that should be used to access SYMBOL_REF or\n    LABEL_REF X in context CONTEXT.  */\n+\n enum aarch64_symbol_type\n aarch64_classify_symbol (rtx x,\n \t\t\t enum aarch64_symbol_context context ATTRIBUTE_UNUSED)\n@@ -5038,48 +5039,34 @@ aarch64_classify_symbol (rtx x,\n \t}\n     }\n \n-  gcc_assert (GET_CODE (x) == SYMBOL_REF);\n-\n-  switch (aarch64_cmodel)\n+  if (GET_CODE (x) == SYMBOL_REF)\n     {\n-    case AARCH64_CMODEL_LARGE:\n-      return SYMBOL_FORCE_TO_MEM;\n-\n-    case AARCH64_CMODEL_TINY:\n-    case AARCH64_CMODEL_SMALL:\n-\n-      /* This is needed to get DFmode, TImode constants to be loaded off\n-         the constant pool.  Is it necessary to dump TImode values into\n-         the constant pool.  We don't handle TImode constant loads properly\n-         yet and hence need to use the constant pool.  */\n-      if (CONSTANT_POOL_ADDRESS_P (x))\n-\treturn SYMBOL_FORCE_TO_MEM;\n-\n-      if (aarch64_tls_symbol_p (x))\n-\treturn aarch64_classify_tls_symbol (x);\n-\n-      if (SYMBOL_REF_WEAK (x))\n-\treturn SYMBOL_FORCE_TO_MEM;\n-\n-      return SYMBOL_SMALL_ABSOLUTE;\n-\n-    case AARCH64_CMODEL_TINY_PIC:\n-    case AARCH64_CMODEL_SMALL_PIC:\n-\n-      if (CONSTANT_POOL_ADDRESS_P (x))\n+      if (aarch64_cmodel == AARCH64_CMODEL_LARGE\n+\t  || CONSTANT_POOL_ADDRESS_P (x))\n \treturn SYMBOL_FORCE_TO_MEM;\n \n       if (aarch64_tls_symbol_p (x))\n \treturn aarch64_classify_tls_symbol (x);\n \n-      if (!aarch64_symbol_binds_local_p (x))\n-\treturn SYMBOL_SMALL_GOT;\n+      switch (aarch64_cmodel)\n+\t{\n+\tcase AARCH64_CMODEL_TINY:\n+\tcase AARCH64_CMODEL_SMALL:\n+\t  if (SYMBOL_REF_WEAK (x))\n+\t    return SYMBOL_FORCE_TO_MEM;\n+\t  return SYMBOL_SMALL_ABSOLUTE;\n \n-      return SYMBOL_SMALL_ABSOLUTE;\n+\tcase AARCH64_CMODEL_TINY_PIC:\n+\tcase AARCH64_CMODEL_SMALL_PIC:\n+\t  if (!aarch64_symbol_binds_local_p (x))\n+\t    return SYMBOL_SMALL_GOT;\n+\t  return SYMBOL_SMALL_ABSOLUTE;\n \n-    default:\n-      gcc_unreachable ();\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n     }\n+\n   /* By default push everything into the constant pool.  */\n   return SYMBOL_FORCE_TO_MEM;\n }"}]}