{"sha": "a4796c80627e34e3fa2828225c70dfc3b65c62e6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTQ3OTZjODA2MjdlMzRlM2ZhMjgyODIyNWM3MGRmYzNiNjVjNjJlNg==", "commit": {"author": {"name": "Per Bothner", "email": "per@bothner.com", "date": "2001-01-21T21:50:37Z"}, "committer": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "2001-01-21T21:50:37Z"}, "message": "Various fixes to allow compiling a compressed .jar/.zip archive.\n\nFrom-SVN: r39175", "tree": {"sha": "5f463667ec157bb3f84a00b486e3f79eb8080f7e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5f463667ec157bb3f84a00b486e3f79eb8080f7e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a4796c80627e34e3fa2828225c70dfc3b65c62e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4796c80627e34e3fa2828225c70dfc3b65c62e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a4796c80627e34e3fa2828225c70dfc3b65c62e6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4796c80627e34e3fa2828225c70dfc3b65c62e6/comments", "author": {"login": "PerBothner", "id": 10293361, "node_id": "MDQ6VXNlcjEwMjkzMzYx", "avatar_url": "https://avatars.githubusercontent.com/u/10293361?v=4", "gravatar_id": "", "url": "https://api.github.com/users/PerBothner", "html_url": "https://github.com/PerBothner", "followers_url": "https://api.github.com/users/PerBothner/followers", "following_url": "https://api.github.com/users/PerBothner/following{/other_user}", "gists_url": "https://api.github.com/users/PerBothner/gists{/gist_id}", "starred_url": "https://api.github.com/users/PerBothner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/PerBothner/subscriptions", "organizations_url": "https://api.github.com/users/PerBothner/orgs", "repos_url": "https://api.github.com/users/PerBothner/repos", "events_url": "https://api.github.com/users/PerBothner/events{/privacy}", "received_events_url": "https://api.github.com/users/PerBothner/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b5c4fed92cb6d5fe30e6eac39d1299b2cf998c9d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5c4fed92cb6d5fe30e6eac39d1299b2cf998c9d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b5c4fed92cb6d5fe30e6eac39d1299b2cf998c9d"}], "stats": {"total": 170, "additions": 88, "deletions": 82}, "files": [{"sha": "cc768eadc2d0c786de87f6212728c6a6d4873dce", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4796c80627e34e3fa2828225c70dfc3b65c62e6/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4796c80627e34e3fa2828225c70dfc3b65c62e6/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=a4796c80627e34e3fa2828225c70dfc3b65c62e6", "patch": "@@ -1,3 +1,24 @@\n+2001-01-21  Per Bothner  <per@bothner.com>\n+\n+\tVarious fixes to allow compiling a compressed .jar/.zip archive.\n+\t* zipfile.h (struct ZipFileCache):  Replace by struct ZipFile.\n+\t(struct ZipFile):  Add fields name and next (from  ZipFileCache).\n+\t(struct ZipDirectory):  New field zipf points to owning ZipFile.\n+\t* jcf.h (struct ZipDirectory):  Add forward declaration.\n+\t(struct JCF):   Declare zipd field to have type struct ZipDirectory.\n+\tRemove seen_in_zip and zip_offset fields.\n+\t(JCF_SEEN_IN_ZIP):  New macro.\n+\t* zextract.c (read_zip_archive):  Set ZipDirectory's zipf field.\n+\t* jcf-io.c:  Change all ZipFileCache to ZipFile.\n+\t(read_zip_member):  New function.\n+\t(open_in_zip):  Call read_zip_member.\n+\t* jcf-parse.c (find_in_current_zip):  Remove function.\n+\t(read_class):  Merge in find_in_current_zip functionality.\n+\tCall read_zip_member if needed.\n+\t(parse_zip_file_entries):  Use read_zip_member.\n+\t(process_zip_dir):  Update for removed and added JCF fields.\n+\t(jcf_figure_file_type):  Re-use, don't copy initial ZipFile struct.\n+\n 2001-01-21  Per Bothner  <per@bothner.com>\n \n \tMinor optimization of static ggc roots."}, {"sha": "655e381200609cd4b7d3e6c2f696f461d19bfe16", "filename": "gcc/java/jcf-io.c", "status": "modified", "additions": 28, "deletions": 19, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4796c80627e34e3fa2828225c70dfc3b65c62e6/gcc%2Fjava%2Fjcf-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4796c80627e34e3fa2828225c70dfc3b65c62e6/gcc%2Fjava%2Fjcf-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-io.c?ref=a4796c80627e34e3fa2828225c70dfc3b65c62e6", "patch": "@@ -90,7 +90,7 @@ DEFUN(jcf_filbuf_from_stdio, (jcf, count),\n \n #include \"zipfile.h\"\n \n-struct ZipFileCache *SeenZipFiles = NULL;\n+struct ZipFile *SeenZipFiles = NULL;\n \n /* Open a zip file with the given name, and cache directory and file\n    descriptor.  If the file is missing, treat it as an empty archive.\n@@ -101,40 +101,40 @@ ZipFile *\n DEFUN(opendir_in_zip, (zipfile, is_system),\n       const char *zipfile AND int is_system)\n {\n-  struct ZipFileCache* zipf;\n+  struct ZipFile* zipf;\n   char magic [4];\n   int fd;\n   for (zipf = SeenZipFiles;  zipf != NULL;  zipf = zipf->next)\n     {\n       if (strcmp (zipf->name, zipfile) == 0)\n-\treturn &zipf->z;\n+\treturn zipf;\n     }\n \n-  zipf = ALLOC (sizeof (struct ZipFileCache) + strlen (zipfile) + 1);\n+  zipf = ALLOC (sizeof (struct ZipFile) + strlen (zipfile) + 1);\n   zipf->next = SeenZipFiles;\n   zipf->name = (char*)(zipf+1);\n   strcpy (zipf->name, zipfile);\n   SeenZipFiles = zipf;\n   fd = open (zipfile, O_RDONLY | O_BINARY);\n-  zipf->z.fd = fd;\n+  zipf->fd = fd;\n   if (fd < 0)\n     {\n       /* A missing zip file is not considered an error.\n        We may want to re-consider that.  FIXME. */\n-      zipf->z.count = 0;\n-      zipf->z.dir_size = 0;\n-      zipf->z.central_directory = NULL;\n+      zipf->count = 0;\n+      zipf->dir_size = 0;\n+      zipf->central_directory = NULL;\n     }\n   else\n     {\n       jcf_dependency_add_file (zipfile, is_system);\n       if (read (fd, magic, 4) != 4 || GET_u4 (magic) != (JCF_u4)ZIPMAGIC)\n \treturn NULL;\n       lseek (fd, 0L, SEEK_SET);\n-      if (read_zip_archive (&zipf->z) != 0)\n+      if (read_zip_archive (zipf) != 0)\n \treturn NULL;\n     }\n-  return &zipf->z;\n+  return zipf;\n }\n \n /* Returns:\n@@ -151,18 +151,13 @@ DEFUN(open_in_zip, (jcf, zipfile, zipmember, is_system),\n   ZipDirectory *zipd;\n   int i, len;\n   ZipFile *zipf = opendir_in_zip (zipfile, is_system);\n-  z_stream d_stream; /* decompression stream */\n \n   if (zipf == NULL)\n     return -2;\n \n   if (!zipmember)\n     return 0;\n \n-  d_stream.zalloc = (alloc_func) 0;\n-  d_stream.zfree = (free_func) 0;\n-  d_stream.opaque = (voidpf) 0;\n-\n   len = strlen (zipmember);\n   \n   zipd = (struct ZipDirectory*) zipf->central_directory;\n@@ -173,9 +168,21 @@ DEFUN(open_in_zip, (jcf, zipfile, zipmember, is_system),\n \t{\n \t  JCF_ZERO (jcf);\n \n-\t  jcf->filbuf = jcf_unexpected_eof;\n \t  jcf->filename = xstrdup (zipfile);\n \t  jcf->classname = xstrdup (zipmember);\n+\t  return read_zip_member(jcf, zipd, zipf);\n+\t}\n+    }\n+  return -1;\n+}\n+\n+/* Read data from zip archive member. */\n+\n+int\n+DEFUN(read_zip_member, (jcf, zipd, zipf),\n+      JCF *jcf AND  ZipDirectory *zipd AND ZipFile *zipf)\n+{\n+\t  jcf->filbuf = jcf_unexpected_eof;\n \t  jcf->zipd = (void *)zipd;\n \n \t  if (zipd->compression_method == Z_NO_COMPRESSION)\n@@ -191,6 +198,11 @@ DEFUN(open_in_zip, (jcf, zipfile, zipmember, is_system),\n \t  else\n \t    {\n \t      char *buffer;\n+\t      z_stream d_stream; /* decompression stream */\n+\t      d_stream.zalloc = (alloc_func) 0;\n+\t      d_stream.zfree = (free_func) 0;\n+\t      d_stream.opaque = (voidpf) 0;\n+\n \t      jcf->buffer = ALLOC (zipd->uncompressed_size);\n \t      d_stream.next_out = jcf->buffer;\n \t      d_stream.avail_out = zipd->uncompressed_size;\n@@ -212,9 +224,6 @@ DEFUN(open_in_zip, (jcf, zipfile, zipmember, is_system),\n \t    }\n \n \t  return 0;\n-\t}\n-    }\n-  return -1;\n }\n \n #if JCF_USE_STDIO"}, {"sha": "a4178c016d7de95739fca627678de16f9aaf065c", "filename": "gcc/java/jcf-parse.c", "status": "modified", "additions": 26, "deletions": 53, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4796c80627e34e3fa2828225c70dfc3b65c62e6/gcc%2Fjava%2Fjcf-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4796c80627e34e3fa2828225c70dfc3b65c62e6/gcc%2Fjava%2Fjcf-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-parse.c?ref=a4796c80627e34e3fa2828225c70dfc3b65c62e6", "patch": "@@ -91,7 +91,6 @@ static void process_zip_dir PARAMS ((FILE *));\n static void parse_source_file PARAMS ((tree, FILE *));\n static void jcf_parse_source PARAMS ((void));\n static int jcf_figure_file_type PARAMS ((JCF *));\n-static int find_in_current_zip PARAMS ((const char *, struct JCF **));\n static void parse_class_file PARAMS ((void));\n static void set_source_filename PARAMS ((JCF *, int));\n static int predefined_filename_p PARAMS ((tree));\n@@ -509,47 +508,49 @@ read_class (name)\n      tree name;\n {\n   JCF this_jcf, *jcf;\n+  tree icv, class;\n   tree save_current_class = current_class;\n   const char *save_input_filename = input_filename;\n   JCF *save_current_jcf = current_jcf;\n-  long saved_pos = 0;\n-  if (current_jcf->read_state)\n-    saved_pos = ftell (current_jcf->read_state);\n \n-  /* Search in current zip first.  */\n-  if (find_in_current_zip (IDENTIFIER_POINTER (name), &jcf) == 0)\n+  if ((icv = IDENTIFIER_CLASS_VALUE (name)) != NULL_TREE)\n     {\n+      class = TREE_TYPE (icv);\n+      jcf = TYPE_JCF (class);\n+    }\n+  else\n+    jcf = NULL;\n+\n+  if (jcf == NULL)\n+    {\n+      this_jcf.zipd = NULL;\n+      jcf = &this_jcf;\n       if (find_class (IDENTIFIER_POINTER (name), IDENTIFIER_LENGTH (name),\n \t\t      &this_jcf, 1) == 0)\n \treturn 0;\n-      else\n-\t{\n-\t  this_jcf.seen_in_zip = 0;\n-\t  current_jcf = &this_jcf;\n-\t}\n     }\n-  else\n-    current_jcf = jcf;\n+\n+  current_jcf = jcf;\n \n   if (current_jcf->java_source)\n     jcf_parse_source ();\n   else {\n     java_parser_context_save_global ();\n     java_push_parser_context ();\n     input_filename = current_jcf->filename;\n+    if (JCF_SEEN_IN_ZIP (current_jcf))\n+      read_zip_member(current_jcf, current_jcf->zipd, current_jcf->zipd->zipf);\n     jcf_parse (current_jcf);\n     java_pop_parser_context (0);\n     java_parser_context_restore_global ();\n   }\n \n-  if (!current_jcf->seen_in_zip)\n+  if (! JCF_SEEN_IN_ZIP (current_jcf))\n     JCF_FINISH (current_jcf);\n \n   current_class = save_current_class;\n   input_filename = save_input_filename;\n   current_jcf = save_current_jcf;\n-  if (current_jcf->read_state)\n-    fseek (current_jcf->read_state, saved_pos, SEEK_SET);\n   return 1;\n }\n \n@@ -673,7 +674,7 @@ jcf_parse (jcf)\n     all_class_list = tree_cons (NULL_TREE, \n \t\t\t\tTYPE_NAME (current_class), all_class_list );\n \n-  /* And if we came accross inner classes, load them now. */\n+  /* And if we came across inner classes, load them now. */\n   for (current = DECL_INNER_CLASS_LIST (TYPE_NAME (current_class)); current;\n        current = TREE_CHAIN (current))\n     load_class (DECL_NAME (TREE_PURPOSE (current)), 1);\n@@ -957,7 +958,7 @@ yyparse ()\n   return 0;\n }\n \n-static struct ZipFileCache *localToFile;\n+static struct ZipFile *localToFile;\n \n /* Process all class entries found in the zip file.  */\n static void\n@@ -966,8 +967,8 @@ parse_zip_file_entries (void)\n   struct ZipDirectory *zdir;\n   int i;\n \n-  for (i = 0, zdir = (ZipDirectory *)localToFile->z.central_directory;\n-       i < localToFile->z.count; i++, zdir = ZIPDIR_NEXT (zdir))\n+  for (i = 0, zdir = (ZipDirectory *)localToFile->central_directory;\n+       i < localToFile->count; i++, zdir = ZIPDIR_NEXT (zdir))\n     {\n       tree class;\n       \n@@ -981,7 +982,7 @@ parse_zip_file_entries (void)\n \n       if ( !CLASS_LOADED_P (class))\n \t{\n-          fseek (current_jcf->read_state, current_jcf->zip_offset, SEEK_SET);\n+\t  read_zip_member(current_jcf, zdir, localToFile);\n \t  jcf_parse (current_jcf);\n \t}\n \n@@ -1007,8 +1008,8 @@ process_zip_dir (FILE *finput)\n   int i;\n   ZipDirectory *zdir;\n \n-  for (i = 0, zdir = (ZipDirectory *)localToFile->z.central_directory;\n-       i < localToFile->z.count; i++, zdir = ZIPDIR_NEXT (zdir))\n+  for (i = 0, zdir = (ZipDirectory *)localToFile->central_directory;\n+       i < localToFile->count; i++, zdir = ZIPDIR_NEXT (zdir))\n     {\n       char *class_name, *file_name, *class_name_in_zip_dir;\n       tree class;\n@@ -1048,42 +1049,15 @@ process_zip_dir (FILE *finput)\n \n       jcf->read_state  = finput;\n       jcf->filbuf      = jcf_filbuf_from_stdio;\n-      jcf->seen_in_zip = 1;\n       jcf->java_source = 0;\n-      jcf->zip_offset  = zdir->filestart;\n       jcf->classname   = class_name;\n       jcf->filename    = file_name;\n+      jcf->zipd        = zdir;\n \n       TYPE_JCF (class) = jcf;\n     }\n }\n \n-/* Lookup class NAME and figure whether is a class already found in the current\n-   zip file.  */\n-static int\n-DEFUN(find_in_current_zip, (name, length, jcf),\n-      const char *name AND JCF **jcf)\n-{\n-  JCF *local_jcf;\n-  tree class_name = maybe_get_identifier (name), class, icv;\n-\n-  if (!class_name)\n-    return 0;\n-\n-  if (!(icv = IDENTIFIER_CLASS_VALUE (class_name)))\n-    return 0;\n-\n-  class = TREE_TYPE (icv);\n-\n-  /* Doesn't have jcf specific info ? It's not ours */\n-  if (!TYPE_JCF (class))\n-    return 0;\n-\n-  *jcf = local_jcf = TYPE_JCF (class);\n-  fseek (local_jcf->read_state, local_jcf->zip_offset, SEEK_SET);\n-  return 1;\n-}\n-\n /* Figure what kind of file we're dealing with */\n static int\n DEFUN(jcf_figure_file_type, (jcf),\n@@ -1105,8 +1079,7 @@ DEFUN(jcf_figure_file_type, (jcf),\n   if (magic ==  (JCF_u4)ZIPMAGIC\n       && !open_in_zip (jcf, input_filename, NULL, 0))\n     {\n-      localToFile = ALLOC (sizeof (struct ZipFileCache));\n-      memcpy (localToFile, SeenZipFiles, sizeof (struct ZipFileCache));\n+      localToFile = SeenZipFiles;\n       /* Register all the class defined there.  */\n       process_zip_dir (jcf->read_state);\n       return JCF_ZIP;"}, {"sha": "5bb53b05c46ce36099af6c595bc45c52826cd5cf", "filename": "gcc/java/jcf.h", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4796c80627e34e3fa2828225c70dfc3b65c62e6/gcc%2Fjava%2Fjcf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4796c80627e34e3fa2828225c70dfc3b65c62e6/gcc%2Fjava%2Fjcf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf.h?ref=a4796c80627e34e3fa2828225c70dfc3b65c62e6", "patch": "@@ -83,26 +83,28 @@ typedef struct CPool {\n   jword*\tdata;\n } CPool;\n \n+struct ZipDirectory;\n+\n /* JCF encapsulates the state of reading a Java Class File. */\n \n typedef struct JCF {\n   unsigned char *buffer;\n   unsigned char *buffer_end;\n   unsigned char *read_ptr;\n   unsigned char *read_end;\n-  int seen_in_zip;\n   int java_source;\n-  long zip_offset;    \n   jcf_filbuf_t filbuf;\n   void *read_state;\n   const char *filename;\n   const char *classname;\n-  void *zipd;\t\t\t/* Directory entry where it was found */\n+  struct ZipDirectory *zipd;\t/* Directory entry where it was found */\n   JCF_u2 access_flags, this_class, super_class;\n   CPool cpool;\n } JCF;\n /*typedef JCF*  JCF_FILE;*/\n \n+#define JCF_SEEN_IN_ZIP(JCF) ((JCF)->zipd != NULL)\n+\n /* The CPOOL macros take a (pointer to a) CPool.\n    The JPOOL macros take a (pointer to a) JCF.\n    Some of the latter should perhaps be deprecated or removed. */"}, {"sha": "2226eeac61965cc5c22318c99b227d6d30fb12ee", "filename": "gcc/java/zextract.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4796c80627e34e3fa2828225c70dfc3b65c62e6/gcc%2Fjava%2Fzextract.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4796c80627e34e3fa2828225c70dfc3b65c62e6/gcc%2Fjava%2Fzextract.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fzextract.c?ref=a4796c80627e34e3fa2828225c70dfc3b65c62e6", "patch": "@@ -331,6 +331,7 @@ read_zip_archive (zipf)\n       zipd->compression_method = compression_method;\n       zipd->size = size;\n       zipd->uncompressed_size = uncompressed_size;\n+      zipd->zipf = zipf;\n #ifdef __GNUC__\n #define DIR_ALIGN __alignof__(ZipDirectory)\n #else"}, {"sha": "f0be3cca4ecb9b30bda48c9276cf3f66720f55ee", "filename": "gcc/java/zipfile.h", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4796c80627e34e3fa2828225c70dfc3b65c62e6/gcc%2Fjava%2Fzipfile.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4796c80627e34e3fa2828225c70dfc3b65c62e6/gcc%2Fjava%2Fzipfile.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fzipfile.h?ref=a4796c80627e34e3fa2828225c70dfc3b65c62e6", "patch": "@@ -22,11 +22,15 @@ of Sun Microsystems, Inc. in the United States and other countries.\n The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n \n struct ZipFile {\n+  char *name;\n   int fd;\n   long size;\n   long count;\n   long dir_size;\n   char *central_directory;\n+\n+  /* Chain together in SeenZipFiles. */\n+  struct ZipFile *next;\n };\n \n typedef struct ZipFile ZipFile;\n@@ -38,6 +42,7 @@ struct ZipDirectory {\n   unsigned size; /* length of file */\n   unsigned uncompressed_size; /* length of uncompressed data */\n   unsigned filestart;  /* start of file in archive */\n+  ZipFile *zipf;\n   int filename_length;\n   /* char mid_padding[...]; */\n   /* char filename[filename_length]; */\n@@ -46,13 +51,7 @@ struct ZipDirectory {\n \n typedef struct ZipDirectory ZipDirectory;\n \n-struct ZipFileCache {\n-  struct ZipFile z;\n-  struct ZipFileCache *next;\n-  char *name;\n-};\n-\n-extern struct ZipFileCache *SeenZipFiles;\n+extern struct ZipFile *SeenZipFiles;\n \n #define ZIPDIR_FILENAME(ZIPD) ((char*)(ZIPD)+(ZIPD)->filename_offset)\n #define ZIPDIR_NEXT(ZIPD) \\\n@@ -62,6 +61,7 @@ extern struct ZipFileCache *SeenZipFiles;\n extern ZipFile * opendir_in_zip PARAMS ((const char *, int));\n extern int read_zip_archive PARAMS ((ZipFile *));\n #ifdef JCF_ZIP\n+extern int read_zip_member PARAMS ((JCF*, ZipDirectory*, ZipFile *));\n extern int open_in_zip PARAMS ((struct JCF *, const char *,\n \t\t\t       const char *, int));\n #endif"}]}