{"sha": "24c473a14d3cbe6fc44997122b532cb9406497cb", "node_id": "C_kwDOANBUbNoAKDI0YzQ3M2ExNGQzY2JlNmZjNDQ5OTcxMjJiNTMyY2I5NDA2NDk3Y2I", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2022-08-31T18:07:13Z"}, "committer": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2022-09-22T18:14:34Z"}, "message": "Adjust range_op_handler to store the handler directly.\n\nRange_op_handler currently stores a tree code and a type.  It defers\nchecking to see if there is a valid handler until asked.\nThis change checks at constuctor time and store a pointer to\nthe handler if there is one.\n\n\t* range-op.cc (range_op_handler::set_op_handler): Set new fields.\n\t(ange_op_handler::range_op_handler): Likewise.\n\t(range_op_handler::operator bool): Remove.\n\t(range_op_handler::fold_range): Use appropriate handler.\n\t(range_op_handler::op1_range): Likewise.\n\t(range_op_handler::op2_range): Likewise.\n\t(range_op_handler::lhs_op1_relation): Likewise.\n\t(range_op_handler::lhs_op2_relation): Likewise.\n\t(range_op_handler::op1_op2_relation): Likewise.\n\t* range-op.h (class range_op_handler): Store handler pointers.\n\t(range_op_handler:: operator bool): Inline.", "tree": {"sha": "715e347a616cd713117ab00e7b2d80f68344946f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/715e347a616cd713117ab00e7b2d80f68344946f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/24c473a14d3cbe6fc44997122b532cb9406497cb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24c473a14d3cbe6fc44997122b532cb9406497cb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/24c473a14d3cbe6fc44997122b532cb9406497cb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24c473a14d3cbe6fc44997122b532cb9406497cb/comments", "author": null, "committer": null, "parents": [{"sha": "3cba5cd6e019182dbff756f621af048d55cdda98", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3cba5cd6e019182dbff756f621af048d55cdda98", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3cba5cd6e019182dbff756f621af048d55cdda98"}], "stats": {"total": 254, "additions": 114, "deletions": 140}, "files": [{"sha": "f642b3f26de89247d910efa84ab4ed9038f0aa19", "filename": "gcc/range-op.cc", "status": "modified", "additions": 109, "deletions": 137, "changes": 246, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24c473a14d3cbe6fc44997122b532cb9406497cb/gcc%2Frange-op.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24c473a14d3cbe6fc44997122b532cb9406497cb/gcc%2Frange-op.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frange-op.cc?ref=24c473a14d3cbe6fc44997122b532cb9406497cb", "patch": "@@ -4159,48 +4159,63 @@ get_float_handler (enum tree_code code, tree)\n   return (*floating_tree_table)[code];\n }\n \n+void\n+range_op_handler::set_op_handler (tree_code code, tree type)\n+{\n+  if (irange::supports_p (type))\n+    {\n+      m_float = NULL;\n+      m_int = get_handler (code, type);\n+      m_valid = m_int != NULL;\n+    }\n+  else if (frange::supports_p (type))\n+    {\n+      m_int = NULL;\n+      m_float = get_float_handler (code, type);\n+      m_valid = m_float != NULL;\n+    }\n+  else\n+    {\n+      m_int = NULL;\n+      m_float = NULL;\n+      m_valid = false;\n+    }\n+}\n+\n range_op_handler::range_op_handler (tree_code code, tree type)\n-  : m_code (code), m_type (type)\n {\n+  set_op_handler (code, type);\n }\n \n range_op_handler::range_op_handler (const gimple *s)\n {\n+  tree_code code = NOP_EXPR;\n+  tree type = NULL_TREE;\n+\n   if (const gassign *ass = dyn_cast<const gassign *> (s))\n     {\n-      m_code = gimple_assign_rhs_code (ass);\n+      code = gimple_assign_rhs_code (ass);\n       // The LHS of a comparison is always an int, so we must look at\n       // the operands.\n-      if (TREE_CODE_CLASS (m_code) == tcc_comparison)\n-\tm_type = TREE_TYPE (gimple_assign_rhs1 (ass));\n+      if (TREE_CODE_CLASS (code) == tcc_comparison)\n+\ttype = TREE_TYPE (gimple_assign_rhs1 (ass));\n       else\n-\tm_type = TREE_TYPE (gimple_assign_lhs (ass));\n+\ttype = TREE_TYPE (gimple_assign_lhs (ass));\n     }\n   else if (const gcond *cond = dyn_cast<const gcond *> (s))\n     {\n-      m_code = gimple_cond_code (cond);\n-      m_type = TREE_TYPE (gimple_cond_lhs (cond));\n+      code = gimple_cond_code (cond);\n+      type = TREE_TYPE (gimple_cond_lhs (cond));\n     }\n-  else\n+\n+  if (!type)\n     {\n-      // A null type means there is no handler for this combination,\n-      // but the decision whether there is one or not, is delayed\n-      // until operator bool below is queried.\n-      m_code = NOP_EXPR;\n-      m_type = nullptr;\n+      m_int = NULL;\n+      m_float = NULL;\n+      m_valid = false;\n     }\n-}\n-\n-// Return TRUE if there is a handler available for the current\n-// combination of tree_code and type.\n-\n-range_op_handler::operator bool () const\n-{\n-  if (!m_type)\n-    return false;\n-  if (frange::supports_p (m_type))\n-    return get_float_handler (m_code, m_type);\n-  return get_handler (m_code, m_type);\n+  else\n+    set_op_handler (code, type);\n }\n \n bool\n@@ -4209,26 +4224,19 @@ range_op_handler::fold_range (vrange &r, tree type,\n \t\t\t      const vrange &rh,\n \t\t\t      relation_kind rel) const\n {\n-  if (irange::supports_p (m_type))\n-    {\n-      range_operator *op = get_handler (m_code, m_type);\n-      return op->fold_range (as_a <irange> (r), type,\n-\t\t\t     as_a <irange> (lh),\n-\t\t\t     as_a <irange> (rh), rel);\n-    }\n-  if (frange::supports_p (m_type))\n-    {\n-      range_operator_float *op = get_float_handler (m_code, m_type);\n-      if (is_a <irange> (r))\n-\treturn op->fold_range (as_a <irange> (r), type,\n-\t\t\t       as_a <frange> (lh),\n-\t\t\t       as_a <frange> (rh), rel);\n-      return op->fold_range (as_a <frange> (r), type,\n-\t\t\t     as_a <frange> (lh),\n-\t\t\t     as_a <frange> (rh), rel);\n-    }\n-  gcc_unreachable ();\n-  return false;\n+  gcc_checking_assert (m_valid);\n+  if (m_int)\n+    return m_int->fold_range (as_a <irange> (r), type,\n+\t\t\t   as_a <irange> (lh),\n+\t\t\t   as_a <irange> (rh), rel);\n+\n+  if (is_a <irange> (r))\n+    return m_float->fold_range (as_a <irange> (r), type,\n+\t\t\t\tas_a <frange> (lh),\n+\t\t\t\tas_a <frange> (rh), rel);\n+  return m_float->fold_range (as_a <frange> (r), type,\n+\t\t\t      as_a <frange> (lh),\n+\t\t\t      as_a <frange> (rh), rel);\n }\n \n bool\n@@ -4237,26 +4245,19 @@ range_op_handler::op1_range (vrange &r, tree type,\n \t\t\t     const vrange &op2,\n \t\t\t     relation_kind rel) const\n {\n-  if (irange::supports_p (m_type))\n-    {\n-      range_operator *op = get_handler (m_code, m_type);\n-      return op->op1_range (as_a <irange> (r), type,\n-\t\t\t    as_a <irange> (lhs),\n-\t\t\t    as_a <irange> (op2), rel);\n-    }\n-  if (frange::supports_p (m_type))\n-    {\n-      range_operator_float *op = get_float_handler (m_code, m_type);\n-      if (is_a <irange> (lhs))\n-\treturn op->op1_range (as_a <frange> (r), type,\n-\t\t\t      as_a <irange> (lhs),\n-\t\t\t      as_a <frange> (op2), rel);\n-      return op->op1_range (as_a <frange> (r), type,\n-\t\t\t    as_a <frange> (lhs),\n-\t\t\t    as_a <frange> (op2), rel);\n-    }\n-  gcc_unreachable ();\n-  return false;\n+  gcc_checking_assert (m_valid);\n+  if (m_int)\n+    return m_int->op1_range (as_a <irange> (r), type,\n+\t\t\t     as_a <irange> (lhs),\n+\t\t\t     as_a <irange> (op2), rel);\n+\n+  if (is_a <irange> (lhs))\n+    return m_float->op1_range (as_a <frange> (r), type,\n+\t\t\t       as_a <irange> (lhs),\n+\t\t\t       as_a <frange> (op2), rel);\n+  return m_float->op1_range (as_a <frange> (r), type,\n+\t\t\t     as_a <frange> (lhs),\n+\t\t\t     as_a <frange> (op2), rel);\n }\n \n bool\n@@ -4265,26 +4266,19 @@ range_op_handler::op2_range (vrange &r, tree type,\n \t\t\t     const vrange &op1,\n \t\t\t     relation_kind rel) const\n {\n-  if (irange::supports_p (m_type))\n-    {\n-      range_operator *op = get_handler (m_code, m_type);\n-      return op->op2_range (as_a <irange> (r), type,\n-\t\t\t    as_a <irange> (lhs),\n-\t\t\t    as_a <irange> (op1), rel);\n-    }\n-  if (frange::supports_p (m_type))\n-    {\n-      range_operator_float *op = get_float_handler (m_code, m_type);\n-      if (is_a <irange> (lhs))\n-\treturn op->op2_range (as_a <frange> (r), type,\n-\t\t\t      as_a <irange> (lhs),\n-\t\t\t      as_a <frange> (op1), rel);\n-      return op->op2_range (as_a <frange> (r), type,\n-\t\t\t    as_a <frange> (lhs),\n-\t\t\t    as_a <frange> (op1), rel);\n-    }\n-  gcc_unreachable ();\n-  return false;\n+  gcc_checking_assert (m_valid);\n+  if (m_int)\n+    return m_int->op2_range (as_a <irange> (r), type,\n+\t\t\t     as_a <irange> (lhs),\n+\t\t\t     as_a <irange> (op1), rel);\n+\n+  if (is_a <irange> (lhs))\n+    return m_float->op2_range (as_a <frange> (r), type,\n+\t\t\t       as_a <irange> (lhs),\n+\t\t\t       as_a <frange> (op1), rel);\n+  return m_float->op2_range (as_a <frange> (r), type,\n+\t\t\t     as_a <frange> (lhs),\n+\t\t\t     as_a <frange> (op1), rel);\n }\n \n relation_kind\n@@ -4293,26 +4287,19 @@ range_op_handler::lhs_op1_relation (const vrange &lhs,\n \t\t\t\t    const vrange &op2,\n \t\t\t\t    relation_kind rel) const\n {\n-  if (irange::supports_p (m_type))\n-    {\n-      range_operator *op = get_handler (m_code, m_type);\n-      return op->lhs_op1_relation (as_a <irange> (lhs),\n-\t\t\t\t   as_a <irange> (op1),\n-\t\t\t\t   as_a <irange> (op2), rel);\n-    }\n-  if (frange::supports_p (m_type))\n-    {\n-      range_operator_float *op = get_float_handler (m_code, m_type);\n-      if (is_a <irange> (lhs))\n-\treturn op->lhs_op1_relation (as_a <irange> (lhs),\n-\t\t\t\t     as_a <frange> (op1),\n-\t\t\t\t     as_a <frange> (op2), rel);\n-      return op->lhs_op1_relation (as_a <frange> (lhs),\n-\t\t\t\t   as_a <frange> (op1),\n-\t\t\t\t   as_a <frange> (op2), rel);\n-    }\n-  gcc_unreachable ();\n-  return VREL_VARYING;\n+  gcc_checking_assert (m_valid);\n+  if (m_int)\n+    return m_int->lhs_op1_relation (as_a <irange> (lhs),\n+\t\t\t\t    as_a <irange> (op1),\n+\t\t\t\t    as_a <irange> (op2), rel);\n+\n+  if (is_a <irange> (lhs))\n+    return m_float->lhs_op1_relation (as_a <irange> (lhs),\n+\t\t\t\t as_a <frange> (op1),\n+\t\t\t\t as_a <frange> (op2), rel);\n+  return m_float->lhs_op1_relation (as_a <frange> (lhs),\n+\t\t\t       as_a <frange> (op1),\n+\t\t\t       as_a <frange> (op2), rel);\n }\n \n relation_kind\n@@ -4321,43 +4308,28 @@ range_op_handler::lhs_op2_relation (const vrange &lhs,\n \t\t\t\t    const vrange &op2,\n \t\t\t\t    relation_kind rel) const\n {\n-  if (irange::supports_p (m_type))\n-    {\n-      range_operator *op = get_handler (m_code, m_type);\n-      return op->lhs_op2_relation (as_a <irange> (lhs),\n-\t\t\t\t   as_a <irange> (op1),\n-\t\t\t\t   as_a <irange> (op2), rel);\n-    }\n-  if (frange::supports_p (m_type))\n-    {\n-      range_operator_float *op = get_float_handler (m_code, m_type);\n-      if (is_a <irange> (lhs))\n-\treturn op->lhs_op2_relation (as_a <irange> (lhs),\n-\t\t\t\t     as_a <frange> (op1),\n-\t\t\t\t     as_a <frange> (op2), rel);\n-      return op->lhs_op2_relation (as_a <frange> (lhs),\n-\t\t\t\t   as_a <frange> (op1),\n-\t\t\t\t   as_a <frange> (op2), rel);\n-    }\n-  gcc_unreachable ();\n-  return VREL_VARYING;\n+  gcc_checking_assert (m_valid);\n+  if (m_int)\n+    return m_int->lhs_op2_relation (as_a <irange> (lhs),\n+\t\t\t\t    as_a <irange> (op1),\n+\t\t\t\t    as_a <irange> (op2), rel);\n+\n+  if (is_a <irange> (lhs))\n+    return m_float->lhs_op2_relation (as_a <irange> (lhs),\n+\t\t\t\t      as_a <frange> (op1),\n+\t\t\t\t      as_a <frange> (op2), rel);\n+  return m_float->lhs_op2_relation (as_a <frange> (lhs),\n+\t\t\t\t      as_a <frange> (op1),\n+\t\t\t\t      as_a <frange> (op2), rel);\n }\n \n relation_kind\n range_op_handler::op1_op2_relation (const vrange &lhs) const\n {\n-  if (irange::supports_p (m_type))\n-    {\n-      range_operator *op = get_handler (m_code, m_type);\n-      return op->op1_op2_relation (as_a <irange> (lhs));\n-    }\n-  if (frange::supports_p (m_type))\n-    {\n-      range_operator_float *op = get_float_handler (m_code, m_type);\n-      return op->op1_op2_relation (as_a <irange> (lhs));\n-    }\n-  gcc_unreachable ();\n-  return VREL_VARYING;\n+  gcc_checking_assert (m_valid);\n+  if (m_int)\n+    return m_int->op1_op2_relation (as_a <irange> (lhs));\n+  return m_float->op1_op2_relation (as_a <irange> (lhs));\n }\n \n // Cast the range in R to TYPE."}, {"sha": "56c57c46a8e6da246d523a3a2c6d70547f55bd21", "filename": "gcc/range-op.h", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24c473a14d3cbe6fc44997122b532cb9406497cb/gcc%2Frange-op.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24c473a14d3cbe6fc44997122b532cb9406497cb/gcc%2Frange-op.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frange-op.h?ref=24c473a14d3cbe6fc44997122b532cb9406497cb", "patch": "@@ -162,7 +162,7 @@ class range_op_handler\n public:\n   range_op_handler (enum tree_code code, tree type);\n   range_op_handler (const gimple *s);\n-  operator bool () const;\n+  inline operator bool () const { return m_valid; }\n \n   bool fold_range (vrange &r, tree type,\n \t\t   const vrange &lh,\n@@ -186,8 +186,10 @@ class range_op_handler\n \t\t\t\t  relation_kind = VREL_VARYING) const;\n   relation_kind op1_op2_relation (const vrange &lhs) const;\n private:\n-  enum tree_code m_code;\n-  tree m_type;\n+  void set_op_handler (enum tree_code code, tree type);\n+  bool m_valid;\n+  range_operator *m_int;\n+  range_operator_float *m_float;\n };\n \n extern bool range_cast (vrange &, tree type);"}]}