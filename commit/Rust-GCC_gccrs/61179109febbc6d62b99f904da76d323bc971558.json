{"sha": "61179109febbc6d62b99f904da76d323bc971558", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjExNzkxMDlmZWJiYzZkNjJiOTlmOTA0ZGE3NmQzMjNiYzk3MTU1OA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-09-29T17:23:41Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-09-29T17:23:41Z"}, "message": "(convert_for_assignment): When converting object to union...\n\n(convert_for_assignment): When converting object to union, allow\nconverting the constant zero into a pointer member of the union.\n\nFrom-SVN: r8162", "tree": {"sha": "551c94a0a9487f77cad6f5a16cb2f0e7d9d7202e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/551c94a0a9487f77cad6f5a16cb2f0e7d9d7202e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/61179109febbc6d62b99f904da76d323bc971558", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61179109febbc6d62b99f904da76d323bc971558", "html_url": "https://github.com/Rust-GCC/gccrs/commit/61179109febbc6d62b99f904da76d323bc971558", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61179109febbc6d62b99f904da76d323bc971558/comments", "author": null, "committer": null, "parents": [{"sha": "0407367d5352e159b08e72697db4409a4c05f094", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0407367d5352e159b08e72697db4409a4c05f094", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0407367d5352e159b08e72697db4409a4c05f094"}], "stats": {"total": 63, "additions": 31, "deletions": 32}, "files": [{"sha": "1a6713c2779a372881300817d78af46227283568", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 31, "deletions": 32, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61179109febbc6d62b99f904da76d323bc971558/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61179109febbc6d62b99f904da76d323bc971558/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=61179109febbc6d62b99f904da76d323bc971558", "patch": "@@ -1635,24 +1635,6 @@ convert_arguments (typelist, values, name, fundecl)\n \t    }\n \t  else\n \t    {\n-#if 0 /* This turns out not to win--there's no way to write a prototype\n-\t for a function whose arg type is a union with no tag.  */\n-\t      /* Nameless union automatically casts the types it contains.  */\n-\t      if (TREE_CODE (type) == UNION_TYPE && TYPE_NAME (type) == 0)\n-\t\t{\n-\t\t  tree field;\n-\n-\t\t  for (field = TYPE_FIELDS (type); field;\n-\t\t       field = TREE_CHAIN (field))\n-\t\t    if (comptypes (TYPE_MAIN_VARIANT (TREE_TYPE (field)),\n-\t\t\t\t   TYPE_MAIN_VARIANT (TREE_TYPE (val))))\n-\t\t      break;\n-\n-\t\t  if (field)\n-\t\t    val = build1 (CONVERT_EXPR, type, val);\n-\t\t}\n-#endif\n-\n \t      /* Optionally warn about conversions that\n \t\t differ from the default conversions.  */\n \t      if (warn_conversion)\n@@ -3892,14 +3874,15 @@ convert_for_assignment (type, rhs, errtype, fundecl, funname, parmnum)\n   /* Arithmetic types all interconvert, and enum is treated like int.  */\n   if ((codel == INTEGER_TYPE || codel == REAL_TYPE || codel == ENUMERAL_TYPE\n        || codel == COMPLEX_TYPE)\n-       &&\n-      (coder == INTEGER_TYPE || coder == REAL_TYPE || coder == ENUMERAL_TYPE\n-       || coder == COMPLEX_TYPE))\n+      && (coder == INTEGER_TYPE || coder == REAL_TYPE || coder == ENUMERAL_TYPE\n+\t  || coder == COMPLEX_TYPE))\n     return convert_and_check (type, rhs);\n+\n   /* Conversion to a union from its member types.  */\n   else if (codel == UNION_TYPE)\n     {\n       tree memb_types;\n+\n       for (memb_types = TYPE_FIELDS (type); memb_types;\n \t   memb_types = TREE_CHAIN (memb_types))\n \t{\n@@ -3910,6 +3893,7 @@ convert_for_assignment (type, rhs, errtype, fundecl, funname, parmnum)\n \t\tpedwarn (\"ANSI C prohibits argument conversion to union type\");\n \t      return build1 (NOP_EXPR, type, rhs);\n \t    }\n+\n \t  else if (coder == POINTER_TYPE\n \t\t   && TREE_CODE (TREE_TYPE (memb_types)) == POINTER_TYPE)\n \t    {\n@@ -3919,44 +3903,59 @@ convert_for_assignment (type, rhs, errtype, fundecl, funname, parmnum)\n \n \t      /* Any non-function converts to a [const][volatile] void *\n \t\t and vice versa; otherwise, targets must be the same.\n-\t\t Meanwhile, the lhs target must have all the qualifiers of the rhs.  */\n+\t\t Meanwhile, the lhs target must have all the qualifiers of\n+\t\t the rhs.  */\n \t      if (TYPE_MAIN_VARIANT (ttl) == void_type_node\n \t\t  || TYPE_MAIN_VARIANT (ttr) == void_type_node\n \t\t  || comp_target_types (memb_type, rhstype))\n \t\t{\n-\t\t  /* Const and volatile mean something different for function types,\n-\t\t     so the usual warnings are not appropriate.  */\n+\t\t  /* Const and volatile mean something different for function\n+\t\t     types, so the usual warnings are not appropriate.  */\n \t\t  if (TREE_CODE (ttr) != FUNCTION_TYPE\n \t\t      || TREE_CODE (ttl) != FUNCTION_TYPE)\n \t\t    {\n \t\t      if (! TYPE_READONLY (ttl) && TYPE_READONLY (ttr))\n \t\t\twarn_for_assignment (\"%s discards `const' from pointer target type\",\n-\t\t\t\t\t     get_spelling (errtype), funname, parmnum);\n+\t\t\t\t\t     get_spelling (errtype), funname,\n+\t\t\t\t\t     parmnum);\n \t\t      if (! TYPE_VOLATILE (ttl) && TYPE_VOLATILE (ttr))\n \t\t\twarn_for_assignment (\"%s discards `volatile' from pointer target type\",\n-\t\t\t\t\t     get_spelling (errtype), funname, parmnum);\n+\t\t\t\t\t     get_spelling (errtype), funname,\n+\t\t\t\t\t     parmnum);\n \t\t    }\n \t\t  else\n \t\t    {\n-\t\t      /* Because const and volatile on functions are restrictions\n-\t\t\t that say the function will not do certain things,\n-\t\t\t it is okay to use a const or volatile function\n-\t\t\t where an ordinary one is wanted, but not vice-versa.  */\n+\t\t      /* Because const and volatile on functions are\n+\t\t\t restrictions that say the function will not do\n+\t\t\t certain things, it is okay to use a const or volatile\n+\t\t\t function where an ordinary one is wanted, but not\n+\t\t\t vice-versa.  */\n \t\t      if (TYPE_READONLY (ttl) && ! TYPE_READONLY (ttr))\n \t\t\twarn_for_assignment (\"%s makes `const *' function pointer from non-const\",\n-\t\t\t\t\t     get_spelling (errtype), funname, parmnum);\n+\t\t\t\t\t     get_spelling (errtype), funname,\n+\t\t\t\t\t     parmnum);\n \t\t      if (TYPE_VOLATILE (ttl) && ! TYPE_VOLATILE (ttr))\n \t\t\twarn_for_assignment (\"%s makes `volatile *' function pointer from non-volatile\",\n-\t\t\t\t\t     get_spelling (errtype), funname, parmnum);\n+\t\t\t\t\t     get_spelling (errtype), funname,\n+\t\t\t\t\t     parmnum);\n \t\t    }\n+\n \t\t  if (pedantic\n \t\t      && !(fundecl != 0 && DECL_IN_SYSTEM_HEADER (fundecl)))\n \t\t    pedwarn (\"ANSI C prohibits argument conversion to union type\");\n \t\t  return build1 (NOP_EXPR, type, rhs);\n \t\t}\n \t    }\n+\n+\t  /* Can convert integer zero to any pointer type.  */\n+\t  else if (TREE_CODE (TREE_TYPE (memb_types)) == POINTER_TYPE\n+\t\t   && (integer_zerop (rhs)\n+\t\t       || (TREE_CODE (rhs) == NOP_EXPR\n+\t\t\t   && integer_zerop (TREE_OPERAND (rhs, 0)))))\n+\t    return build1 (NOP_EXPR, type, null_pointer_node);\n \t}\n     }\n+\n   /* Conversions among pointers */\n   else if (codel == POINTER_TYPE && coder == POINTER_TYPE)\n     {"}]}