{"sha": "4401bf245c6e45a270187245ef0e75bf7f706012", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDQwMWJmMjQ1YzZlNDVhMjcwMTg3MjQ1ZWYwZTc1YmY3ZjcwNjAxMg==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1997-09-16T04:39:46Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1997-09-16T04:39:46Z"}, "message": "dwarf2out.c (gen_subprogram_die): Handle redefinition of an extern inline function.\n\n        * dwarf2out.c (gen_subprogram_die): Handle redefinition of an\n        extern inline function.\n\n        * dwarf2out.c (reg_loc_descriptor): Fix prototype.\n        (concat_loc_descriptor): New function.\n        (loc_descriptor): Call it.\n        (add_AT_location_description): Also elide the descriptor if both\n        halves of a CONCAT are pseudos.\n        (add_location_or_const_value_attribute): Recognize CONCAT too.\nBring over from devo/fsf.\n\nFrom-SVN: r15470", "tree": {"sha": "dbc300dd68d894385ceb694f09b48927e72f4cbf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dbc300dd68d894385ceb694f09b48927e72f4cbf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4401bf245c6e45a270187245ef0e75bf7f706012", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4401bf245c6e45a270187245ef0e75bf7f706012", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4401bf245c6e45a270187245ef0e75bf7f706012", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4401bf245c6e45a270187245ef0e75bf7f706012/comments", "author": null, "committer": null, "parents": [{"sha": "33687242dc84a47422a1f3cd4903d8004d613055", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33687242dc84a47422a1f3cd4903d8004d613055", "html_url": "https://github.com/Rust-GCC/gccrs/commit/33687242dc84a47422a1f3cd4903d8004d613055"}], "stats": {"total": 66, "additions": 64, "deletions": 2}, "files": [{"sha": "1f98c85a38e4131ec621daea27644a19433038ae", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4401bf245c6e45a270187245ef0e75bf7f706012/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4401bf245c6e45a270187245ef0e75bf7f706012/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4401bf245c6e45a270187245ef0e75bf7f706012", "patch": "@@ -1,3 +1,17 @@\n+Mon Sep 15 22:40:55 1997  Jim Wilson  (wilson@cygnus.com)\n+\n+\t* dwarf2out.c (gen_subprogram_die): Handle redefinition of an\n+\textern inline function.\n+\n+Mon Sep 15 22:40:55 1997  Richard Henderson  (rth@cygnus.com)\n+\n+\t* dwarf2out.c (reg_loc_descriptor): Fix prototype.\n+\t(concat_loc_descriptor): New function.\n+\t(loc_descriptor): Call it.\n+\t(add_AT_location_description): Also elide the descriptor if both\n+\thalves of a CONCAT are pseudos.\n+\t(add_location_or_const_value_attribute): Recognize CONCAT too.\n+\n Mon Sep 15 15:24:00 1997  Richard Henderson  <rth@cygnus.com>\n \n \t* alpha.md (movdi): Handle CONST_DOUBLE for TARGET_BUILD_CONSTANTS."}, {"sha": "1b7548d47d5fb6c316e90271018e4dcc1ff964ab", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 50, "deletions": 2, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4401bf245c6e45a270187245ef0e75bf7f706012/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4401bf245c6e45a270187245ef0e75bf7f706012/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=4401bf245c6e45a270187245ef0e75bf7f706012", "patch": "@@ -2163,10 +2163,11 @@ static tree root_type\t\t\tPROTO((tree));\n static int is_base_type\t\t\tPROTO((tree));\n static dw_die_ref modified_type_die\tPROTO((tree, int, int, dw_die_ref));\n static int type_is_enum\t\t\tPROTO((tree));\n-static dw_loc_descr_ref reg_loc_descr_ref PROTO((rtx));\n+static dw_loc_descr_ref reg_loc_descriptor PROTO((rtx));\n static dw_loc_descr_ref based_loc_descr\tPROTO((unsigned, long));\n static int is_based_loc\t\t\tPROTO((rtx));\n static dw_loc_descr_ref mem_loc_descriptor PROTO((rtx));\n+static dw_loc_descr_ref concat_loc_descriptor PROTO((rtx, rtx));\n static dw_loc_descr_ref loc_descriptor\tPROTO((rtx));\n static unsigned ceiling\t\t\tPROTO((unsigned, unsigned));\n static tree field_type\t\t\tPROTO((tree));\n@@ -6188,6 +6189,30 @@ mem_loc_descriptor (rtl)\n   return mem_loc_result;\n }\n \n+/* Return a descriptor that describes the concatination of two locations.\n+   This is typically a complex variable.  */\n+\n+static dw_loc_descr_ref\n+concat_loc_descriptor (x0, x1)\n+     register rtx x0, x1;\n+{\n+  dw_loc_descr_ref cc_loc_result = NULL;\n+\n+  if (!is_pseudo_reg (x0)\n+      && (GET_CODE (x0) != MEM || !is_pseudo_reg (XEXP (x0, 0))))\n+    add_loc_descr (&cc_loc_result, loc_descriptor (x0));\n+  add_loc_descr (&cc_loc_result,\n+\t         new_loc_descr (DW_OP_piece, GET_MODE_SIZE (GET_MODE (x0)), 0));\n+\n+  if (!is_pseudo_reg (x1)\n+      && (GET_CODE (x1) != MEM || !is_pseudo_reg (XEXP (x1, 0))))\n+    add_loc_descr (&cc_loc_result, loc_descriptor (x1));\n+  add_loc_descr (&cc_loc_result,\n+\t\t new_loc_descr (DW_OP_piece, GET_MODE_SIZE (GET_MODE (x1)), 0));\n+\n+  return cc_loc_result;\n+}\n+\n /* Output a proper Dwarf location descriptor for a variable or parameter\n    which is either allocated in a register or in a memory location.  For a\n    register, we just generate an OP_REG and the register number.  For a\n@@ -6219,6 +6244,10 @@ loc_descriptor (rtl)\n       loc_result = mem_loc_descriptor (XEXP (rtl, 0));\n       break;\n \n+    case CONCAT:\n+      loc_result = concat_loc_descriptor (XEXP (rtl, 0), XEXP (rtl, 1));\n+      break;\n+\n     default:\n       abort ();\n     }\n@@ -6426,7 +6455,10 @@ add_AT_location_description (die, attr_kind, rtl)\n \n   if (is_pseudo_reg (rtl)\n       || (GET_CODE (rtl) == MEM\n-\t  && is_pseudo_reg (XEXP (rtl, 0))))\n+\t  && is_pseudo_reg (XEXP (rtl, 0)))\n+      || (GET_CODE (rtl) == CONCAT\n+\t  && is_pseudo_reg (XEXP (rtl, 0))\n+\t  && is_pseudo_reg (XEXP (rtl, 1))))\n     return;\n \n   add_AT_loc (die, attr_kind, loc_descriptor (rtl));\n@@ -6724,6 +6756,7 @@ add_location_or_const_value_attribute (die, decl)\n     case MEM:\n     case REG:\n     case SUBREG:\n+    case CONCAT:\n       add_AT_location_description (die, DW_AT_location, rtl);\n       break;\n \n@@ -7684,6 +7717,17 @@ gen_subprogram_die (decl, context_die)\n       subr_die = new_die (DW_TAG_subprogram, context_die);\n       add_abstract_origin_attribute (subr_die, origin);\n     }\n+  else if (old_die && DECL_ABSTRACT (decl)\n+\t   && get_AT_unsigned (old_die, DW_AT_inline))\n+    {\n+      /* This must be a redefinition of an extern inline function.\n+\t We can just reuse the old die here.  */\n+      subr_die = old_die;\n+\n+      /* Clear out the inlined attribute and parm types.  */\n+      remove_AT (subr_die, DW_AT_inline);\n+      remove_children (subr_die);\n+    }\n   else if (old_die)\n     {\n       register unsigned file_index\n@@ -7768,6 +7812,10 @@ gen_subprogram_die (decl, context_die)\n     }\n   else if (DECL_ABSTRACT (decl))\n     {\n+      /* ??? Checking DECL_DEFER_OUTPUT is correct for static inline functions,\n+\t but not for extern inline functions.  We can't get this completely\n+\t correct because information about whether the function was declared\n+\t inline is not saved anywhere.  */\n       if (DECL_DEFER_OUTPUT (decl))\n \t{\n \t  if (DECL_INLINE (decl))"}]}