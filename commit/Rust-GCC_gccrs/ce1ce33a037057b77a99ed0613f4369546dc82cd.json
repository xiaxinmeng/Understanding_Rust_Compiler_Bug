{"sha": "ce1ce33a037057b77a99ed0613f4369546dc82cd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2UxY2UzM2EwMzcwNTdiNzdhOTllZDA2MTNmNDM2OTU0NmRjODJjZA==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2014-08-25T21:19:23Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2014-08-25T21:19:23Z"}, "message": "Strengthen haifa_sched_info callbacks and 3 scheduler hooks\n\ngcc/\n\t* target.def (reorder): Strengthen param \"ready\" of this DEFHOOK\n\tfrom rtx * to rtx_insn **.\n\t(reorder2): Likewise.\n\t(dependencies_evaluation_hook): Strengthen params \"head\", \"tail\"\n\tfrom rtx to rtx_insn *.\n\n\t* doc/tm.texi: Update mechanically for above change to target.def.\n\n\t* sched-int.h (note_list): Strengthen this variable from rtx to\n\trtx_insn *.\n\t(remove_notes): Likewise for both params.\n\t(restore_other_notes): Likewise for return type and first param.\n\t(struct ready_list): Strengthen field \"vec\" from rtx * to\n\trtx_insn **.\n\t(struct dep_replacement): Strenghten field \"insn\" from rtx to\n\trtx_insn *.\n\t(struct deps_desc): Likewise for fields \"last_debug_insn\",\n\t\"last_args_size\".\n\t(struct haifa_sched_info): Likewise for callback field\n\t\"can_schedule_ready_p\"'s param, for first param of \"new_ready\"\n\tcallback field, for both params of \"rank\" callback field, for\n\tfirst field of \"print_insn\" callback field (with a const), for\n\tboth params of \"contributes_to_priority\" callback, for param\n\tof \"insn_finishes_block_p\" callback, for fields \"prev_head\",\n\t\"next_tail\", \"head\", \"tail\", for first param of \"add_remove_insn\"\n\tcallback, for first param of \"begin_schedule_ready\" callback, for\n\tboth params of \"begin_move_insn\" callback, and for second param\n\tof \"advance_target_bb\" callback.\n\t(add_dependence): Likewise for params 1 and 2.\n\t(sched_analyze): Likewise for params 2 and 3.\n\t(deps_analyze_insn): Likewise for param 2.\n\t(ready_element): Likewise for return type.\n\t(ready_lastpos): Strengthen return type from rtx * to rtx_insn **.\n\t(try_ready): Strenghten param from rtx to rtx_insn *.\n\t(sched_emit_insn): Likewise for return type.\n\t(record_delay_slot_pair): Likewise for params 1 and 2.\n\t(add_delay_dependencies): Likewise for param.\n\t(contributes_to_priority): Likewise for both params.\n\t(find_modifiable_mems): Likewise.\n\n\t* config/arm/arm.c (cortexa7_sched_reorder):  Strengthen param\n\t\"ready\" from rtx * to rtx_insn **.  Strengthen locals \"insn\",\n\t\"first_older_only_insn\" from rtx to rtx_insn *.\n\t(arm_sched_reorder):  Strengthen param \"ready\"  from rtx * to\n\trtx_insn **.\n\n\t* config/c6x/c6x.c (struct c6x_sched_context): Strengthen field\n\t\"last_scheduled_iter0\" from rtx to rtx_insn *.\n\t(init_sched_state): Replace use of NULL_RTX with NULL for insn.\n\t(c6x_sched_reorder_1): Strengthen param \"ready\" and locals\n\t\"e_ready\", \"insnp\" from rtx * to rtx_insn **.  Strengthen local\n\t\"insn\" from rtx to rtx_insn *.\n\t(c6x_sched_reorder): Strengthen param \"ready\" from rtx * to\n\trtx_insn **.\n\t(c6x_sched_reorder2): Strengthen param \"ready\" and locals\n\t\"e_ready\", \"insnp\" from rtx * to rtx_insn **. Strengthen local\n\t\"insn\" from rtx to rtx_insn *.\n\t(c6x_variable_issue):  Add a checked cast when assigning from insn\n\tto ss.last_scheduled_iter0.\n\t(split_delayed_branch): Strengthen param \"insn\" and local \"i1\"\n\tfrom rtx to rtx_insn *.\n\t(split_delayed_nonbranch): Likewise.\n\t(undo_split_delayed_nonbranch): Likewise for local \"insn\".\n\t(hwloop_optimize): Likewise for locals \"seq\", \"insn\", \"prev\",\n\t\"entry_after\", \"end_packet\", \"head_insn\", \"tail_insn\",\n\t\"new_insns\", \"last_insn\", \"this_iter\", \"prev_stage_insn\".\n\tStrengthen locals \"orig_vec\", \"copies\", \"insn_copies\" from rtx *\n\tto rtx_insn **.  Remove now-redundant checked cast on last_insn,\n\tbut add a checked cast on loop->start_label.  Consolidate calls to\n\tavoid assigning result of gen_spkernel to \"insn\", now an\n\trtx_insn *.\n\n\t* config/i386/i386.c (do_reorder_for_imul): Strengthen param\n\t\"ready\" from rtx * to rtx_insn **.  Strengthen local \"insn\" from\n\trtx to rtx_insn *.\n\t(swap_top_of_ready_list): Strengthen param \"ready\" from rtx * to\n\trtx_insn **.  Strengthen locals \"top\", \"next\" from rtx to\n\trtx_insn *.\n\t(ix86_sched_reorder): Strengthen param \"ready\" from rtx * to\n\trtx_insn **.  Strengthen local \"insn\" from rtx to rtx_insn *.\n\t(add_parameter_dependencies): Strengthen params \"call\", \"head\" and\n\tlocals \"insn\", \"last\", \"first_arg\" from rtx to rtx_insn *.\n\t(avoid_func_arg_motion): Likewise for params \"first_arg\", \"insn\".\n\t(add_dependee_for_func_arg): Likewise for param \"arg\" and local\n\t\"insn\".\n\t(ix86_dependencies_evaluation_hook): Likewise for params \"head\",\n\t\"tail\" and locals \"insn\", \"first_arg\".\n\n\t* config/ia64/ia64.c (ia64_dependencies_evaluation_hook): Likewise\n\tfor params \"head\", \"tail\" and locals \"insn\", \"next\", \"next_tail\".\n\t(ia64_dfa_sched_reorder): Strengthen param \"ready\" and locals\n\t\"e_ready\", \"insnp\" from rtx * to rtx_insn **. Strengthen locals\n\t\"insn\", \"lowest\", \"highest\" from rtx to rtx_insn *.\n\t(ia64_sched_reorder): Strengthen param \"ready\" from rtx * to\n\trtx_insn **.\n\t(ia64_sched_reorder2): Likewise.\n\n\t* config/mep/mep.c (mep_find_ready_insn): Strengthen return type\n\tand local \"insn\" from rtx to rtx_insn *.  Strengthen param \"ready\"\n\tfrom rtx * to rtx_insn **.\n\t(mep_move_ready_insn): Strengthen param \"ready\" from rtx * to\n\trtx_insn **.\n\t(mep_print_sched_insn): Strengthen param \"insn\" from rtx to\n\trtx_insn *.\n\t(mep_sched_reorder): Strengthen param \"ready\" from rtx * to\n\trtx_insn **.  Strengthen locals \"core_insn\", \"cop_insn\" from rtx\n\tto rtx_insn *.\n\n\t* config/mips/mips.c (mips_promote_ready): Strengthen param \"ready\"\n\tfrom rtx * to rtx_insn **.  Strengthen local \"new_head\" from rtx\n\tto rtx_insn *.\n\t(mips_maybe_swap_ready): Strengthen param \"ready\" from rtx * to\n\trtx_insn **.  Strengthen local \"temp\" from rtx to rtx_insn *.\n\t(mips_macc_chains_reorder): Strengthen param \"ready\" from rtx * to\n\trtx_insn **.\n\t(vr4130_reorder): Likewise.\n\t(mips_74k_agen_reorder): Likewise.  Strengthen local \"insn\" from\n\trtx to rtx_insn *.\n\t(mips_sched_reorder_1): Strengthen param \"ready\" from rtx * to\n\trtx_insn **.\n\t(mips_sched_reorder): Likewise.\n\t(mips_sched_reorder2): Likewise.\n\n\t* config/picochip/picochip.c (picochip_sched_reorder): Likewise.\n\n\t* config/rs6000/rs6000.c (rs6000_sched_reorder): Likewise.\n\tStrengthen local \"tmp\" from rtx to rtx_insn *.\n\t(rs6000_sched_reorder2): Likewise.\n\n\t* config/s390/s390.c (s390_z10_prevent_earlyload_conflicts):\n\tLikewise.  Update sizeof(rtx) to sizeof(rtx_insn *) in memmove.\n\t(s390_sched_reorder): Strengthen param \"ready\" from rtx * to\n\trtx_insn **.  Strengthen local \"tmp\" from rtx to rtx_insn *.\n\n\t* config/sh/sh.c (rank_for_reorder): Strengthen locals \"tmp\",\n\t\"tmp2\" from rtx to rtx_insn *.\n\t(swap_reorder): Strengthen param \"a\" from rtx * to rtx_insn **.\n\tStrengthen local \"insn\" from rtx to rtx_insn *.\n\t(ready_reorder): Strengthen param \"ready\" from rtx * to\n\trtx_insn **.  Update sizeof(rtx) to sizeof(rtx_insn *) in qsort.\n\t(sh_reorder):  Strengthen param \"ready\" from rtx * to rtx_insn **.\n\t(sh_reorder2): Likewise.\n\n\t* config/spu/spu.c (spu_sched_reorder): Likewise.  Strengthen\n\tlocal \"insn\" from rtx to rtx_insn *.\n\n\t* haifa-sched.c (note_list): Strengthen this variable from rtx to\n\trtx_insn *.\n\t(scheduled_insns): Strengthen this variable from vec<rtx> to\n\tvec<rtx_insn *>.\n\t(set_modulo_params): Likewise for locals \"i1\", \"i2\".\n\t(record_delay_slot_pair): Likewise for params \"i1\", \"i2\".\n\t(add_delay_dependencies): Likewise for param \"insn\".\n\t(cond_clobbered_p): Likewise.\n\t(recompute_todo_spec): Likewise for local \"prev\".\n\t(last_scheduled_insn): Likewise for this variable.\n\t(nonscheduled_insns_begin): Likewise.\n\t(model_set_excess_costs): Strengthen param \"insns\" from rtx * to\n\trtx_insn **.\n\t(rank_for_schedule): Strengthen locals \"tmp\", \"tmp2\" from rtx to\n\trtx_insn *.\n\t(swap_sort): Strengthen param \"a\" from rtx * to rtx_insn **.\n\tStrengthen local \"insn\" from rtx to rtx_insn *.\n\t(queue_insn): Strengthen param \"insn\" from rtx to rtx_insn *.\n\t(ready_lastpos): Strengthen return type from rtx * to rtx_insn **.\n\t(ready_add): Strengthen param \"insn\" from rtx to rtx_insn *.\n\t(ready_remove_first): Likewise for return type and local \"t\".\n\t(ready_element): Likewise for return type.\n\t(ready_remove): Likewise for return type and local \"t\".\n\t(ready_sort): Strengthen local \"first\" from rtx * to rtx_insn **.\n\t(check_clobbered_conditions): Strengthen local \"x\" from rtx to\n\trtx_insn *, adding a checked cast.\n\t(schedule_insn): Likewise for param \"insn\".\n\t(remove_notes): Likewise for params \"head\", \"tail\" and locals\n\t\"next_tail\", \"insn\", \"next\".\n\t(struct haifa_saved_data): Likewise for fields\n\t\"last_scheduled_insn\", \"nonscheduled_insns_begin\".\n\t(save_backtrack_point): Update for change to field \"vec\" of\n\tstruct ready_list.\n\t(toggle_cancelled_flags): Strengthen local \"first\" from rtx * to\n\trtx_insn **.\n\t(restore_last_backtrack_point): Likewise.  Strengthen local \"insn\"\n\tfrom rtx to rtx_insn *\n\t(resolve_dependencies): Strengthen param \"insn\" from rtx to\n\trtx_insn *\n\t(restore_other_notes): Likewise for return type, for param \"head\"\n\tand local \"note_head\".\n\t(undo_all_replacements): Likewise for local \"insn\".\n\t(first_nonscheduled_insn): Likewise for return type and local \"insn\".\n\t(queue_to_ready): Likewise for local \"insn\", adding checked casts.\n\t(early_queue_to_ready): Likewise for local \"insn\".\n\t(debug_ready_list_1): Strengthen local \"p\" from rtx * to\n\trtx_insn **.\n\t(move_insn): Strengthen param \"insn\" and local \"note\" from rtx to\n\trtx_insn *\n\t(insn_finishes_cycle_p): Likewise for param \"insn\".\n\t(max_issue): Likewise for local \"insn\".\n\t(choose_ready): Likewise.  Strengthen param \"insn_ptr\" from rtx *\n\tto rtx_insn **.\n\t(commit_schedule): Strengthen param \"prev_head\" and local \"insn\"\n\tfrom rtx to rtx_insn *\n\t(prune_ready_list): Likewise for local \"insn\".\n\t(schedule_block): Likewise for locals \"prev_head\", \"head\", \"tail\",\n\t\"skip_insn\", \"insn\", \"failed_insn\", \"x\", adding a checked cast.\n\t(set_priorities): Likewise for local \"prev_head\".\n\t(try_ready): Likewise for param \"next\".\n\t(fix_tick_ready): Likewise.\n\t(change_queue_index): Likewise.\n\t(sched_extend_ready_list): Update for change to field \"vec\" of\n\tstruct ready_list.\n\t(generate_recovery_code): Strengthen param \"insn\" from rtx to\n\trtx_insn *.\n\t(begin_speculative_block): Likewise.\n\t(create_check_block_twin): Likewise for param \"insn\" and locals\n\t\"label\", \"check\", \"twin\".  Introduce local \"check_pat\" to avoid\n\t\"check\" being used as a plain rtx before being used as an insn.\n\t(fix_recovery_deps): Add a checked cast to rtx_insn * when\n\textracting elements from ready_list.\n\t(sched_remove_insn): Strengthen param \"insn\" from rtx to\n\trtx_insn *.\n\t(sched_emit_insn): Likewise for return type.\n\t(ready_remove_first_dispatch): Likewise for return type and local\n\t\"insn\".\n\n\t* hw-doloop.c (discover_loop): Add a checked cast to rtx_insn *.\n\n\t* modulo-sched.c (sms_print_insn): Strengthen from const_rtx to\n\tconst rtx_insn *.\n\n\t* sched-deps.c (add_dependence): Strengthen params \"con\", \"pro\"\n\tfrom rtx to rtx_insn *.\n\t(add_dependence_list): Likewise for param \"insn\".  Add a checked\n\tcast.\n\t(add_dependence_list_and_free): Strengthen param \"insn\" from rtx\n\tto rtx_insn *.  Strengthen param \"list_p\" from rtx * to\n\trtx_insn **.\n\t(chain_to_prev_insn): Strengthen param \"insn\" and locals\n\t\"prec_nonnote\", \"i\" from rtx to rtx_insn *.\n\t(flush_pending_lists): Likewise for param \"insn\".\n\t(cur_insn): Likewise for this variable.\n\t(haifa_start_insn): Add a checked cast.\n\t(note_dep): Strengthen param \"e\" from rtx to rtx_insn *.\n\t(sched_analyze_reg): Likewise for param \"insn\".\n\t(sched_analyze_1): Likewise.\n\t(sched_analyze_2): Likewise.  Add checked casts.\n\t(sched_analyze_insn): Likewise.  Also for local \"prev\".\n\t(deps_analyze_insn): Likewise for param \"insn\".\n\t(sched_analyze): Likewise for params \"head\", \"tail\" and local \"insn\".\n\t(add_dependence_1): Likewise for params \"insn\", \"elem\".\n\t(struct mem_inc_info): Likewise for fields \"inc_insn\", \"mem_insn\".\n\t(parse_add_or_inc): Likewise for param \"insn\".\n\t(find_inc): Likewise for local \"inc_cand\".\n\t(find_modifiable_mems): Likewise for params \"head\", \"tail\" and\n\tlocals \"insn\", \"next_tail\".\n\n\t* sched-ebb.c (init_ready_list): Likewise for local \"insn\".\n\t(begin_schedule_ready): Likewise for param \"insn\".\n\t(begin_move_insn): Likewise for params \"insn\" and \"last\".\n\t(ebb_print_insn): Strengthen param \"insn\" from const_rtx to\n\tconst rtx_insn *.\n\t(rank): Strengthen params \"insn1\", \"insn2\" from rtx to rtx_insn *.\n\t(ebb_contributes_to_priority): Likewise for params \"next\", \"insn\".\n\t(ebb_add_remove_insn): Likewise for param \"insn\".\n\t(advance_target_bb): Likewise.\n\n\t* sched-rgn.c (rgn_estimate_number_of_insns): Likewise for local\n\t\"insn\".\n\t(check_live): Likewise for param \"insn\".\n\t(init_ready_list): Likewise for local \"insn\".\n\t(can_schedule_ready_p): Likewise for param \"insn\".\n\t(begin_schedule_ready): Likewise.\n\t(new_ready): Likewise for param \"next\".\n\t(rgn_print_insn): Likewise for param \"insn\".\n\t(rgn_rank): Likewise for params \"insn1\", \"insn2\".\n\t(contributes_to_priority): Likewise for params \"next\", \"insn\".\n\t(rgn_insn_finishes_block_p): Likewise for param \"insn\".\n\t(add_branch_dependences): Likewise for params \"head\", \"tail\" and\n\tlocals \"insn\", \"last\".\n\t(rgn_add_remove_insn): Likewise for param \"insn\".\n\t(advance_target_bb): Likewise.\n\n\t* sel-sched-dump.c (sel_print_insn): Strengthen param \"insn\" from\n\tconst_rtx to const rtx_insn *.\n\n\t* sel-sched-dump.h (sel_print_insn): Likewise.\n\n\t* sel-sched-ir.c (advance_deps_context): Add a checked cast.\n\t(deps_init_id): Likewise.\n\n\t* sel-sched.c (convert_vec_av_set_to_ready): Likewise.\n\t(invoke_reorder_hooks): Strengthen local \"arr\" from rtx * to\n\trtx_insn **.\n\nFrom-SVN: r214481", "tree": {"sha": "bf674dc0104d0e2f8915243f6f3e9e1b4acc1d1b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bf674dc0104d0e2f8915243f6f3e9e1b4acc1d1b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ce1ce33a037057b77a99ed0613f4369546dc82cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce1ce33a037057b77a99ed0613f4369546dc82cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce1ce33a037057b77a99ed0613f4369546dc82cd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce1ce33a037057b77a99ed0613f4369546dc82cd/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f0cb8ae0d93a2a6d262414b8a662682db5c13368", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0cb8ae0d93a2a6d262414b8a662682db5c13368", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f0cb8ae0d93a2a6d262414b8a662682db5c13368"}], "stats": {"total": 1014, "additions": 660, "deletions": 354}, "files": [{"sha": "665e2d77cf1f6b0818fb1e06e351819c51eff62e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 295, "deletions": 0, "changes": 295, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce1ce33a037057b77a99ed0613f4369546dc82cd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce1ce33a037057b77a99ed0613f4369546dc82cd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ce1ce33a037057b77a99ed0613f4369546dc82cd", "patch": "@@ -1,3 +1,298 @@\n+2014-08-25  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* target.def (reorder): Strengthen param \"ready\" of this DEFHOOK\n+\tfrom rtx * to rtx_insn **.\n+\t(reorder2): Likewise.\n+\t(dependencies_evaluation_hook): Strengthen params \"head\", \"tail\"\n+\tfrom rtx to rtx_insn *.\n+\n+\t* doc/tm.texi: Update mechanically for above change to target.def.\n+\n+\t* sched-int.h (note_list): Strengthen this variable from rtx to\n+\trtx_insn *.\n+\t(remove_notes): Likewise for both params.\n+\t(restore_other_notes): Likewise for return type and first param.\n+\t(struct ready_list): Strengthen field \"vec\" from rtx * to\n+\trtx_insn **.\n+\t(struct dep_replacement): Strenghten field \"insn\" from rtx to\n+\trtx_insn *.\n+\t(struct deps_desc): Likewise for fields \"last_debug_insn\",\n+\t\"last_args_size\".\n+\t(struct haifa_sched_info): Likewise for callback field\n+\t\"can_schedule_ready_p\"'s param, for first param of \"new_ready\"\n+\tcallback field, for both params of \"rank\" callback field, for\n+\tfirst field of \"print_insn\" callback field (with a const), for\n+\tboth params of \"contributes_to_priority\" callback, for param\n+\tof \"insn_finishes_block_p\" callback, for fields \"prev_head\",\n+\t\"next_tail\", \"head\", \"tail\", for first param of \"add_remove_insn\"\n+\tcallback, for first param of \"begin_schedule_ready\" callback, for\n+\tboth params of \"begin_move_insn\" callback, and for second param\n+\tof \"advance_target_bb\" callback.\n+\t(add_dependence): Likewise for params 1 and 2.\n+\t(sched_analyze): Likewise for params 2 and 3.\n+\t(deps_analyze_insn): Likewise for param 2.\n+\t(ready_element): Likewise for return type.\n+\t(ready_lastpos): Strengthen return type from rtx * to rtx_insn **.\n+\t(try_ready): Strenghten param from rtx to rtx_insn *.\n+\t(sched_emit_insn): Likewise for return type.\n+\t(record_delay_slot_pair): Likewise for params 1 and 2.\n+\t(add_delay_dependencies): Likewise for param.\n+\t(contributes_to_priority): Likewise for both params.\n+\t(find_modifiable_mems): Likewise.\n+\n+\t* config/arm/arm.c (cortexa7_sched_reorder):  Strengthen param\n+\t\"ready\" from rtx * to rtx_insn **.  Strengthen locals \"insn\",\n+\t\"first_older_only_insn\" from rtx to rtx_insn *.\n+\t(arm_sched_reorder):  Strengthen param \"ready\"  from rtx * to\n+\trtx_insn **.\n+\n+\t* config/c6x/c6x.c (struct c6x_sched_context): Strengthen field\n+\t\"last_scheduled_iter0\" from rtx to rtx_insn *.\n+\t(init_sched_state): Replace use of NULL_RTX with NULL for insn.\n+\t(c6x_sched_reorder_1): Strengthen param \"ready\" and locals\n+\t\"e_ready\", \"insnp\" from rtx * to rtx_insn **.  Strengthen local\n+\t\"insn\" from rtx to rtx_insn *.\n+\t(c6x_sched_reorder): Strengthen param \"ready\" from rtx * to\n+\trtx_insn **.\n+\t(c6x_sched_reorder2): Strengthen param \"ready\" and locals\n+\t\"e_ready\", \"insnp\" from rtx * to rtx_insn **. Strengthen local\n+\t\"insn\" from rtx to rtx_insn *.\n+\t(c6x_variable_issue):  Add a checked cast when assigning from insn\n+\tto ss.last_scheduled_iter0.\n+\t(split_delayed_branch): Strengthen param \"insn\" and local \"i1\"\n+\tfrom rtx to rtx_insn *.\n+\t(split_delayed_nonbranch): Likewise.\n+\t(undo_split_delayed_nonbranch): Likewise for local \"insn\".\n+\t(hwloop_optimize): Likewise for locals \"seq\", \"insn\", \"prev\",\n+\t\"entry_after\", \"end_packet\", \"head_insn\", \"tail_insn\",\n+\t\"new_insns\", \"last_insn\", \"this_iter\", \"prev_stage_insn\".\n+\tStrengthen locals \"orig_vec\", \"copies\", \"insn_copies\" from rtx *\n+\tto rtx_insn **.  Remove now-redundant checked cast on last_insn,\n+\tbut add a checked cast on loop->start_label.  Consolidate calls to\n+\tavoid assigning result of gen_spkernel to \"insn\", now an\n+\trtx_insn *.\n+\n+\t* config/i386/i386.c (do_reorder_for_imul): Strengthen param\n+\t\"ready\" from rtx * to rtx_insn **.  Strengthen local \"insn\" from\n+\trtx to rtx_insn *.\n+\t(swap_top_of_ready_list): Strengthen param \"ready\" from rtx * to\n+\trtx_insn **.  Strengthen locals \"top\", \"next\" from rtx to\n+\trtx_insn *.\n+\t(ix86_sched_reorder): Strengthen param \"ready\" from rtx * to\n+\trtx_insn **.  Strengthen local \"insn\" from rtx to rtx_insn *.\n+\t(add_parameter_dependencies): Strengthen params \"call\", \"head\" and\n+\tlocals \"insn\", \"last\", \"first_arg\" from rtx to rtx_insn *.\n+\t(avoid_func_arg_motion): Likewise for params \"first_arg\", \"insn\".\n+\t(add_dependee_for_func_arg): Likewise for param \"arg\" and local\n+\t\"insn\".\n+\t(ix86_dependencies_evaluation_hook): Likewise for params \"head\",\n+\t\"tail\" and locals \"insn\", \"first_arg\".\n+\n+\t* config/ia64/ia64.c (ia64_dependencies_evaluation_hook): Likewise\n+\tfor params \"head\", \"tail\" and locals \"insn\", \"next\", \"next_tail\".\n+\t(ia64_dfa_sched_reorder): Strengthen param \"ready\" and locals\n+\t\"e_ready\", \"insnp\" from rtx * to rtx_insn **. Strengthen locals\n+\t\"insn\", \"lowest\", \"highest\" from rtx to rtx_insn *.\n+\t(ia64_sched_reorder): Strengthen param \"ready\" from rtx * to\n+\trtx_insn **.\n+\t(ia64_sched_reorder2): Likewise.\n+\n+\t* config/mep/mep.c (mep_find_ready_insn): Strengthen return type\n+\tand local \"insn\" from rtx to rtx_insn *.  Strengthen param \"ready\"\n+\tfrom rtx * to rtx_insn **.\n+\t(mep_move_ready_insn): Strengthen param \"ready\" from rtx * to\n+\trtx_insn **.\n+\t(mep_print_sched_insn): Strengthen param \"insn\" from rtx to\n+\trtx_insn *.\n+\t(mep_sched_reorder): Strengthen param \"ready\" from rtx * to\n+\trtx_insn **.  Strengthen locals \"core_insn\", \"cop_insn\" from rtx\n+\tto rtx_insn *.\n+\n+\t* config/mips/mips.c (mips_promote_ready): Strengthen param \"ready\"\n+\tfrom rtx * to rtx_insn **.  Strengthen local \"new_head\" from rtx\n+\tto rtx_insn *.\n+\t(mips_maybe_swap_ready): Strengthen param \"ready\" from rtx * to\n+\trtx_insn **.  Strengthen local \"temp\" from rtx to rtx_insn *.\n+\t(mips_macc_chains_reorder): Strengthen param \"ready\" from rtx * to\n+\trtx_insn **.\n+\t(vr4130_reorder): Likewise.\n+\t(mips_74k_agen_reorder): Likewise.  Strengthen local \"insn\" from\n+\trtx to rtx_insn *.\n+\t(mips_sched_reorder_1): Strengthen param \"ready\" from rtx * to\n+\trtx_insn **.\n+\t(mips_sched_reorder): Likewise.\n+\t(mips_sched_reorder2): Likewise.\n+\n+\t* config/picochip/picochip.c (picochip_sched_reorder): Likewise.\n+\n+\t* config/rs6000/rs6000.c (rs6000_sched_reorder): Likewise.\n+\tStrengthen local \"tmp\" from rtx to rtx_insn *.\n+\t(rs6000_sched_reorder2): Likewise.\n+\n+\t* config/s390/s390.c (s390_z10_prevent_earlyload_conflicts):\n+\tLikewise.  Update sizeof(rtx) to sizeof(rtx_insn *) in memmove.\n+\t(s390_sched_reorder): Strengthen param \"ready\" from rtx * to\n+\trtx_insn **.  Strengthen local \"tmp\" from rtx to rtx_insn *.\n+\n+\t* config/sh/sh.c (rank_for_reorder): Strengthen locals \"tmp\",\n+\t\"tmp2\" from rtx to rtx_insn *.\n+\t(swap_reorder): Strengthen param \"a\" from rtx * to rtx_insn **.\n+\tStrengthen local \"insn\" from rtx to rtx_insn *.\n+\t(ready_reorder): Strengthen param \"ready\" from rtx * to\n+\trtx_insn **.  Update sizeof(rtx) to sizeof(rtx_insn *) in qsort.\n+\t(sh_reorder):  Strengthen param \"ready\" from rtx * to rtx_insn **.\n+\t(sh_reorder2): Likewise.\n+\n+\t* config/spu/spu.c (spu_sched_reorder): Likewise.  Strengthen\n+\tlocal \"insn\" from rtx to rtx_insn *.\n+\n+\t* haifa-sched.c (note_list): Strengthen this variable from rtx to\n+\trtx_insn *.\n+\t(scheduled_insns): Strengthen this variable from vec<rtx> to\n+\tvec<rtx_insn *>.\n+\t(set_modulo_params): Likewise for locals \"i1\", \"i2\".\n+\t(record_delay_slot_pair): Likewise for params \"i1\", \"i2\".\n+\t(add_delay_dependencies): Likewise for param \"insn\".\n+\t(cond_clobbered_p): Likewise.\n+\t(recompute_todo_spec): Likewise for local \"prev\".\n+\t(last_scheduled_insn): Likewise for this variable.\n+\t(nonscheduled_insns_begin): Likewise.\n+\t(model_set_excess_costs): Strengthen param \"insns\" from rtx * to\n+\trtx_insn **.\n+\t(rank_for_schedule): Strengthen locals \"tmp\", \"tmp2\" from rtx to\n+\trtx_insn *.\n+\t(swap_sort): Strengthen param \"a\" from rtx * to rtx_insn **.\n+\tStrengthen local \"insn\" from rtx to rtx_insn *.\n+\t(queue_insn): Strengthen param \"insn\" from rtx to rtx_insn *.\n+\t(ready_lastpos): Strengthen return type from rtx * to rtx_insn **.\n+\t(ready_add): Strengthen param \"insn\" from rtx to rtx_insn *.\n+\t(ready_remove_first): Likewise for return type and local \"t\".\n+\t(ready_element): Likewise for return type.\n+\t(ready_remove): Likewise for return type and local \"t\".\n+\t(ready_sort): Strengthen local \"first\" from rtx * to rtx_insn **.\n+\t(check_clobbered_conditions): Strengthen local \"x\" from rtx to\n+\trtx_insn *, adding a checked cast.\n+\t(schedule_insn): Likewise for param \"insn\".\n+\t(remove_notes): Likewise for params \"head\", \"tail\" and locals\n+\t\"next_tail\", \"insn\", \"next\".\n+\t(struct haifa_saved_data): Likewise for fields\n+\t\"last_scheduled_insn\", \"nonscheduled_insns_begin\".\n+\t(save_backtrack_point): Update for change to field \"vec\" of\n+\tstruct ready_list.\n+\t(toggle_cancelled_flags): Strengthen local \"first\" from rtx * to\n+\trtx_insn **.\n+\t(restore_last_backtrack_point): Likewise.  Strengthen local \"insn\"\n+\tfrom rtx to rtx_insn *\n+\t(resolve_dependencies): Strengthen param \"insn\" from rtx to\n+\trtx_insn *\n+\t(restore_other_notes): Likewise for return type, for param \"head\"\n+\tand local \"note_head\".\n+\t(undo_all_replacements): Likewise for local \"insn\".\n+\t(first_nonscheduled_insn): Likewise for return type and local \"insn\".\n+\t(queue_to_ready): Likewise for local \"insn\", adding checked casts.\n+\t(early_queue_to_ready): Likewise for local \"insn\".\n+\t(debug_ready_list_1): Strengthen local \"p\" from rtx * to\n+\trtx_insn **.\n+\t(move_insn): Strengthen param \"insn\" and local \"note\" from rtx to\n+\trtx_insn *\n+\t(insn_finishes_cycle_p): Likewise for param \"insn\".\n+\t(max_issue): Likewise for local \"insn\".\n+\t(choose_ready): Likewise.  Strengthen param \"insn_ptr\" from rtx *\n+\tto rtx_insn **.\n+\t(commit_schedule): Strengthen param \"prev_head\" and local \"insn\"\n+\tfrom rtx to rtx_insn *\n+\t(prune_ready_list): Likewise for local \"insn\".\n+\t(schedule_block): Likewise for locals \"prev_head\", \"head\", \"tail\",\n+\t\"skip_insn\", \"insn\", \"failed_insn\", \"x\", adding a checked cast.\n+\t(set_priorities): Likewise for local \"prev_head\".\n+\t(try_ready): Likewise for param \"next\".\n+\t(fix_tick_ready): Likewise.\n+\t(change_queue_index): Likewise.\n+\t(sched_extend_ready_list): Update for change to field \"vec\" of\n+\tstruct ready_list.\n+\t(generate_recovery_code): Strengthen param \"insn\" from rtx to\n+\trtx_insn *.\n+\t(begin_speculative_block): Likewise.\n+\t(create_check_block_twin): Likewise for param \"insn\" and locals\n+\t\"label\", \"check\", \"twin\".  Introduce local \"check_pat\" to avoid\n+\t\"check\" being used as a plain rtx before being used as an insn.\n+\t(fix_recovery_deps): Add a checked cast to rtx_insn * when\n+\textracting elements from ready_list.\n+\t(sched_remove_insn): Strengthen param \"insn\" from rtx to\n+\trtx_insn *.\n+\t(sched_emit_insn): Likewise for return type.\n+\t(ready_remove_first_dispatch): Likewise for return type and local\n+\t\"insn\".\n+\n+\t* hw-doloop.c (discover_loop): Add a checked cast to rtx_insn *.\n+\n+\t* modulo-sched.c (sms_print_insn): Strengthen from const_rtx to\n+\tconst rtx_insn *.\n+\n+\t* sched-deps.c (add_dependence): Strengthen params \"con\", \"pro\"\n+\tfrom rtx to rtx_insn *.\n+\t(add_dependence_list): Likewise for param \"insn\".  Add a checked\n+\tcast.\n+\t(add_dependence_list_and_free): Strengthen param \"insn\" from rtx\n+\tto rtx_insn *.  Strengthen param \"list_p\" from rtx * to\n+\trtx_insn **.\n+\t(chain_to_prev_insn): Strengthen param \"insn\" and locals\n+\t\"prec_nonnote\", \"i\" from rtx to rtx_insn *.\n+\t(flush_pending_lists): Likewise for param \"insn\".\n+\t(cur_insn): Likewise for this variable.\n+\t(haifa_start_insn): Add a checked cast.\n+\t(note_dep): Strengthen param \"e\" from rtx to rtx_insn *.\n+\t(sched_analyze_reg): Likewise for param \"insn\".\n+\t(sched_analyze_1): Likewise.\n+\t(sched_analyze_2): Likewise.  Add checked casts.\n+\t(sched_analyze_insn): Likewise.  Also for local \"prev\".\n+\t(deps_analyze_insn): Likewise for param \"insn\".\n+\t(sched_analyze): Likewise for params \"head\", \"tail\" and local \"insn\".\n+\t(add_dependence_1): Likewise for params \"insn\", \"elem\".\n+\t(struct mem_inc_info): Likewise for fields \"inc_insn\", \"mem_insn\".\n+\t(parse_add_or_inc): Likewise for param \"insn\".\n+\t(find_inc): Likewise for local \"inc_cand\".\n+\t(find_modifiable_mems): Likewise for params \"head\", \"tail\" and\n+\tlocals \"insn\", \"next_tail\".\n+\n+\t* sched-ebb.c (init_ready_list): Likewise for local \"insn\".\n+\t(begin_schedule_ready): Likewise for param \"insn\".\n+\t(begin_move_insn): Likewise for params \"insn\" and \"last\".\n+\t(ebb_print_insn): Strengthen param \"insn\" from const_rtx to\n+\tconst rtx_insn *.\n+\t(rank): Strengthen params \"insn1\", \"insn2\" from rtx to rtx_insn *.\n+\t(ebb_contributes_to_priority): Likewise for params \"next\", \"insn\".\n+\t(ebb_add_remove_insn): Likewise for param \"insn\".\n+\t(advance_target_bb): Likewise.\n+\n+\t* sched-rgn.c (rgn_estimate_number_of_insns): Likewise for local\n+\t\"insn\".\n+\t(check_live): Likewise for param \"insn\".\n+\t(init_ready_list): Likewise for local \"insn\".\n+\t(can_schedule_ready_p): Likewise for param \"insn\".\n+\t(begin_schedule_ready): Likewise.\n+\t(new_ready): Likewise for param \"next\".\n+\t(rgn_print_insn): Likewise for param \"insn\".\n+\t(rgn_rank): Likewise for params \"insn1\", \"insn2\".\n+\t(contributes_to_priority): Likewise for params \"next\", \"insn\".\n+\t(rgn_insn_finishes_block_p): Likewise for param \"insn\".\n+\t(add_branch_dependences): Likewise for params \"head\", \"tail\" and\n+\tlocals \"insn\", \"last\".\n+\t(rgn_add_remove_insn): Likewise for param \"insn\".\n+\t(advance_target_bb): Likewise.\n+\n+\t* sel-sched-dump.c (sel_print_insn): Strengthen param \"insn\" from\n+\tconst_rtx to const rtx_insn *.\n+\n+\t* sel-sched-dump.h (sel_print_insn): Likewise.\n+\n+\t* sel-sched-ir.c (advance_deps_context): Add a checked cast.\n+\t(deps_init_id): Likewise.\n+\n+\t* sel-sched.c (convert_vec_av_set_to_ready): Likewise.\n+\t(invoke_reorder_hooks): Strengthen local \"arr\" from rtx * to\n+\trtx_insn **.\n+\n 2014-08-25  David Malcolm  <dmalcolm@redhat.com>\n \n \t* output.h (final_start_function): Strengthen param 1 from rtx to"}, {"sha": "d9f38f4eeb659dbc0066dd0cc0e5b0b934ab9449", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce1ce33a037057b77a99ed0613f4369546dc82cd/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce1ce33a037057b77a99ed0613f4369546dc82cd/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=ce1ce33a037057b77a99ed0613f4369546dc82cd", "patch": "@@ -138,7 +138,7 @@ static void arm_output_function_prologue (FILE *, HOST_WIDE_INT);\n static int arm_comp_type_attributes (const_tree, const_tree);\n static void arm_set_default_type_attributes (tree);\n static int arm_adjust_cost (rtx, rtx, rtx, int);\n-static int arm_sched_reorder (FILE *, int, rtx *, int *, int);\n+static int arm_sched_reorder (FILE *, int, rtx_insn **, int *, int);\n static int optimal_immediate_sequence (enum rtx_code code,\n \t\t\t\t       unsigned HOST_WIDE_INT val,\n \t\t\t\t       struct four_ints *return_sequence);\n@@ -11797,8 +11797,8 @@ cortexa7_younger (FILE *file, int verbose, rtx insn)\n    instructions.  This heuristic may affect dual issue opportunities\n    in the current cycle.  */\n static void\n-cortexa7_sched_reorder (FILE *file, int verbose, rtx *ready, int *n_readyp,\n-                        int clock)\n+cortexa7_sched_reorder (FILE *file, int verbose, rtx_insn **ready,\n+\t\t\tint *n_readyp, int clock)\n {\n   int i;\n   int first_older_only = -1, first_younger = -1;\n@@ -11815,7 +11815,7 @@ cortexa7_sched_reorder (FILE *file, int verbose, rtx *ready, int *n_readyp,\n      older.  */\n   for (i = *n_readyp - 1; i >= 0; i--)\n     {\n-      rtx insn = ready[i];\n+      rtx_insn *insn = ready[i];\n       if (cortexa7_older_only (insn))\n         {\n           first_older_only = i;\n@@ -11850,7 +11850,7 @@ cortexa7_sched_reorder (FILE *file, int verbose, rtx *ready, int *n_readyp,\n     fprintf (file, \";; cortexa7_sched_reorder insn %d before %d\\n\",\n              INSN_UID(ready [first_older_only]),\n              INSN_UID(ready [first_younger]));\n-  rtx first_older_only_insn = ready [first_older_only];\n+  rtx_insn *first_older_only_insn = ready [first_older_only];\n   for (i = first_older_only; i < first_younger; i++)\n     {\n       ready[i] = ready[i+1];\n@@ -11862,7 +11862,7 @@ cortexa7_sched_reorder (FILE *file, int verbose, rtx *ready, int *n_readyp,\n \n /* Implement TARGET_SCHED_REORDER. */\n static int\n-arm_sched_reorder (FILE *file, int verbose, rtx *ready, int *n_readyp,\n+arm_sched_reorder (FILE *file, int verbose, rtx_insn **ready, int *n_readyp,\n                    int clock)\n {\n   switch (arm_tune)"}, {"sha": "2df5aaf75e810e5fcc1a7f3907e40e1febe34eed", "filename": "gcc/config/c6x/c6x.c", "status": "modified", "additions": 40, "deletions": 37, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce1ce33a037057b77a99ed0613f4369546dc82cd/gcc%2Fconfig%2Fc6x%2Fc6x.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce1ce33a037057b77a99ed0613f4369546dc82cd/gcc%2Fconfig%2Fc6x%2Fc6x.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc6x%2Fc6x.c?ref=ce1ce33a037057b77a99ed0613f4369546dc82cd", "patch": "@@ -3615,7 +3615,7 @@ typedef struct c6x_sched_context\n   /* The following variable value is the last issued insn.  */\n   rtx last_scheduled_insn;\n   /* The last issued insn that isn't a shadow of another.  */\n-  rtx last_scheduled_iter0;\n+  rtx_insn *last_scheduled_iter0;\n \n   /* The following variable value is DFA state before issuing the\n      first insn in the current clock cycle.  We do not use this member\n@@ -3845,7 +3845,7 @@ static void\n init_sched_state (c6x_sched_context_t sc)\n {\n   sc->last_scheduled_insn = NULL_RTX;\n-  sc->last_scheduled_iter0 = NULL_RTX;\n+  sc->last_scheduled_iter0 = NULL;\n   sc->issued_this_cycle = 0;\n   memset (sc->jump_cycles, 0, sizeof sc->jump_cycles);\n   memset (sc->jump_cond, 0, sizeof sc->jump_cond);\n@@ -4132,11 +4132,11 @@ c6x_registers_update (rtx insn)\n    number of non-unsafe insns.  */\n \n static int\n-c6x_sched_reorder_1 (rtx *ready, int *pn_ready, int clock_var)\n+c6x_sched_reorder_1 (rtx_insn **ready, int *pn_ready, int clock_var)\n {\n   int n_ready = *pn_ready;\n-  rtx *e_ready = ready + n_ready;\n-  rtx *insnp;\n+  rtx_insn **e_ready = ready + n_ready;\n+  rtx_insn **insnp;\n   int first_jump;\n \n   /* Keep track of conflicts due to a limit number of register accesses,\n@@ -4145,7 +4145,7 @@ c6x_sched_reorder_1 (rtx *ready, int *pn_ready, int clock_var)\n \n   for (insnp = ready; insnp < e_ready; insnp++)\n     {\n-      rtx insn = *insnp;\n+      rtx_insn *insn = *insnp;\n       int icode = recog_memoized (insn);\n       bool is_asm = (icode < 0\n \t\t     && (GET_CODE (PATTERN (insn)) == ASM_INPUT\n@@ -4206,7 +4206,7 @@ c6x_sched_reorder_1 (rtx *ready, int *pn_ready, int clock_var)\n \n       for (insnp = ready; insnp < e_ready; insnp++)\n \t{\n-\t  rtx insn = *insnp;\n+\t  rtx_insn *insn = *insnp;\n \t  int icode = recog_memoized (insn);\n \t  bool is_asm = (icode < 0\n \t\t\t && (GET_CODE (PATTERN (insn)) == ASM_INPUT\n@@ -4249,7 +4249,7 @@ c6x_sched_reorder_1 (rtx *ready, int *pn_ready, int clock_var)\n static int\n c6x_sched_reorder (FILE *dump ATTRIBUTE_UNUSED,\n \t\t   int sched_verbose ATTRIBUTE_UNUSED,\n-\t\t   rtx *ready ATTRIBUTE_UNUSED,\n+\t\t   rtx_insn **ready ATTRIBUTE_UNUSED,\n \t\t   int *pn_ready ATTRIBUTE_UNUSED, int clock_var)\n {\n   ss.curr_sched_clock = clock_var;\n@@ -4269,7 +4269,7 @@ c6x_sched_reorder (FILE *dump ATTRIBUTE_UNUSED,\n static int\n c6x_sched_reorder2 (FILE *dump ATTRIBUTE_UNUSED,\n \t\t    int sched_verbose ATTRIBUTE_UNUSED,\n-\t\t    rtx *ready ATTRIBUTE_UNUSED,\n+\t\t    rtx_insn **ready ATTRIBUTE_UNUSED,\n \t\t    int *pn_ready ATTRIBUTE_UNUSED, int clock_var)\n {\n   /* FIXME: the assembler rejects labels inside an execute packet.\n@@ -4282,12 +4282,12 @@ c6x_sched_reorder2 (FILE *dump ATTRIBUTE_UNUSED,\n \t  && get_attr_type (ss.last_scheduled_insn) == TYPE_ATOMIC))\n     {\n       int n_ready = *pn_ready;\n-      rtx *e_ready = ready + n_ready;\n-      rtx *insnp;\n+      rtx_insn **e_ready = ready + n_ready;\n+      rtx_insn **insnp;\n \n       for (insnp = ready; insnp < e_ready; insnp++)\n \t{\n-\t  rtx insn = *insnp;\n+\t  rtx_insn *insn = *insnp;\n \t  if (!shadow_p (insn))\n \t    {\n \t      memmove (ready + 1, ready, (insnp - ready) * sizeof (rtx));\n@@ -4362,7 +4362,7 @@ c6x_variable_issue (FILE *dump ATTRIBUTE_UNUSED,\n {\n   ss.last_scheduled_insn = insn;\n   if (INSN_UID (insn) < sploop_max_uid_iter0 && !JUMP_P (insn))\n-    ss.last_scheduled_iter0 = insn;\n+    ss.last_scheduled_iter0 = as_a <rtx_insn *> (insn);\n   if (GET_CODE (PATTERN (insn)) != USE && GET_CODE (PATTERN (insn)) != CLOBBER)\n     ss.issued_this_cycle++;\n   if (insn_info.exists ())\n@@ -5152,10 +5152,11 @@ reorg_emit_nops (rtx *call_labels)\n /* If possible, split INSN, which we know is either a jump or a call, into a real\n    insn and its shadow.  */\n static void\n-split_delayed_branch (rtx insn)\n+split_delayed_branch (rtx_insn *insn)\n {\n   int code = recog_memoized (insn);\n-  rtx i1, newpat;\n+  rtx_insn *i1;\n+  rtx newpat;\n   rtx pat = PATTERN (insn);\n \n   if (GET_CODE (pat) == COND_EXEC)\n@@ -5258,11 +5259,12 @@ split_delayed_branch (rtx insn)\n    with the possibility.  Currently we handle loads and most mpy2 and\n    mpy4 insns.  */\n static bool\n-split_delayed_nonbranch (rtx insn)\n+split_delayed_nonbranch (rtx_insn *insn)\n {\n   int code = recog_memoized (insn);\n   enum attr_type type;\n-  rtx i1, newpat, src, dest;\n+  rtx_insn *i1;\n+  rtx newpat, src, dest;\n   rtx pat = PATTERN (insn);\n   rtvec rtv;\n   int delay;\n@@ -5370,7 +5372,7 @@ undo_split_delayed_nonbranch (rtx insn)\n static void\n split_delayed_insns (void)\n {\n-  rtx insn;\n+  rtx_insn *insn;\n   for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n     {\n       if (JUMP_P (insn) || CALL_P (insn))\n@@ -5512,17 +5514,17 @@ static bool\n hwloop_optimize (hwloop_info loop)\n {\n   basic_block entry_bb, bb;\n-  rtx seq, insn, prev, entry_after, end_packet;\n-  rtx head_insn, tail_insn, new_insns, last_insn;\n+  rtx_insn *seq, *insn, *prev, *entry_after, *end_packet;\n+  rtx_insn *head_insn, *tail_insn, *new_insns, *last_insn;\n   int loop_earliest;\n   int n_execute_packets;\n   edge entry_edge;\n   unsigned ix;\n   int max_uid_before, delayed_splits;\n   int i, sp_ii, min_ii, max_ii, max_parallel, n_insns, n_real_insns, stages;\n-  rtx *orig_vec;\n-  rtx *copies;\n-  rtx **insn_copies;\n+  rtx_insn **orig_vec;\n+  rtx_insn **copies;\n+  rtx_insn ***insn_copies;\n \n   if (!c6x_flag_modulo_sched || !c6x_flag_schedule_insns2\n       || !TARGET_INSNS_64PLUS)\n@@ -5587,7 +5589,7 @@ hwloop_optimize (hwloop_info loop)\n       if (NONDEBUG_INSN_P (insn) && insn != loop->loop_end)\n \tn_real_insns++;\n     }\n-  orig_vec = XNEWVEC (rtx, n_insns);\n+  orig_vec = XNEWVEC (rtx_insn *, n_insns);\n   n_insns = 0;\n   FOR_BB_INSNS (bb, insn)\n     orig_vec[n_insns++] = insn;\n@@ -5605,8 +5607,8 @@ hwloop_optimize (hwloop_info loop)\n      to handle.  */\n   max_parallel = loop_earliest / min_ii + 1;\n \n-  copies = XCNEWVEC (rtx, (max_parallel + 1) * n_real_insns);\n-  insn_copies = XNEWVEC (rtx *, max_parallel + 1);\n+  copies = XCNEWVEC (rtx_insn *, (max_parallel + 1) * n_real_insns);\n+  insn_copies = XNEWVEC (rtx_insn **, max_parallel + 1);\n   for (i = 0; i < max_parallel + 1; i++)\n     insn_copies[i] = copies + i * n_real_insns;\n \n@@ -5626,20 +5628,20 @@ hwloop_optimize (hwloop_info loop)\n   for (i = 0; i < max_parallel; i++)\n     {\n       int j;\n-      rtx this_iter;\n+      rtx_insn *this_iter;\n \n       this_iter = duplicate_insn_chain (head_insn, tail_insn);\n       j = 0;\n       while (this_iter)\n \t{\n-\t  rtx prev_stage_insn = insn_copies[i][j];\n+\t  rtx_insn *prev_stage_insn = insn_copies[i][j];\n \t  gcc_assert (INSN_CODE (this_iter) == INSN_CODE (prev_stage_insn));\n \n \t  if (INSN_CODE (this_iter) >= 0\n \t      && (get_attr_type (this_iter) == TYPE_LOAD_SHADOW\n \t\t  || get_attr_type (this_iter) == TYPE_MULT_SHADOW))\n \t    {\n-\t      rtx prev = PREV_INSN (this_iter);\n+\t      rtx_insn *prev = PREV_INSN (this_iter);\n \t      record_delay_slot_pair (prev, this_iter,\n \t\t\t\t      get_attr_cycles (prev) - 1, 0);\n \t    }\n@@ -5670,9 +5672,7 @@ hwloop_optimize (hwloop_info loop)\n       schedule_ebbs_init ();\n       set_modulo_params (sp_ii, max_parallel, n_real_insns,\n \t\t\t sploop_max_uid_iter0);\n-      tmp_bb = schedule_ebb (BB_HEAD (bb),\n-\t\t\t     safe_as_a <rtx_insn *> (last_insn),\n-\t\t\t     true);\n+      tmp_bb = schedule_ebb (BB_HEAD (bb), last_insn, true);\n       schedule_ebbs_finish ();\n \n       if (tmp_bb)\n@@ -5725,9 +5725,11 @@ hwloop_optimize (hwloop_info loop)\n \n   /* Compute the number of execute packets the pipelined form of the loop will\n      require.  */\n-  prev = NULL_RTX;\n+  prev = NULL;\n   n_execute_packets = 0;\n-  for (insn = loop->start_label; insn != loop->loop_end; insn = NEXT_INSN (insn))\n+  for (insn = as_a <rtx_insn *> (loop->start_label);\n+       insn != loop->loop_end;\n+       insn = NEXT_INSN (insn))\n     {\n       if (NONDEBUG_INSN_P (insn) && GET_MODE (insn) == TImode\n \t  && !shadow_p (insn))\n@@ -5762,9 +5764,10 @@ hwloop_optimize (hwloop_info loop)\n      spot.  */\n   PUT_MODE (end_packet, VOIDmode);\n \n-  insn = gen_spkernel (GEN_INT (stages - 1),\n-\t\t       const0_rtx, JUMP_LABEL (loop->loop_end));\n-  insn = emit_jump_insn_before (insn, end_packet);\n+  insn = emit_jump_insn_before (\n+\t   gen_spkernel (GEN_INT (stages - 1),\n+\t\t\t const0_rtx, JUMP_LABEL (loop->loop_end)),\n+\t   end_packet);\n   JUMP_LABEL (insn) = JUMP_LABEL (loop->loop_end);\n   insn_set_clock (insn, loop_earliest);\n   PUT_MODE (insn, TImode);"}, {"sha": "3c7be0fc5dc6d8558f4cb3d27baceb855684cd73", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce1ce33a037057b77a99ed0613f4369546dc82cd/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce1ce33a037057b77a99ed0613f4369546dc82cd/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=ce1ce33a037057b77a99ed0613f4369546dc82cd", "patch": "@@ -25944,9 +25944,10 @@ ix86_macro_fusion_pair_p (rtx condgen, rtx condjmp)\n        ready list.\n    Return index of IMUL producer if it was found and -1 otherwise.  */\n static int\n-do_reorder_for_imul (rtx *ready, int n_ready)\n+do_reorder_for_imul (rtx_insn **ready, int n_ready)\n {\n-  rtx insn, set, insn1, insn2;\n+  rtx_insn *insn;\n+  rtx set, insn1, insn2;\n   sd_iterator_def sd_it;\n   dep_t dep;\n   int index = -1;\n@@ -26021,10 +26022,10 @@ do_reorder_for_imul (rtx *ready, int n_ready)\n    scheduled earlier. Applied for Silvermont only.\n    Return true if top 2 insns must be interchanged.  */\n static bool\n-swap_top_of_ready_list (rtx *ready, int n_ready)\n+swap_top_of_ready_list (rtx_insn **ready, int n_ready)\n {\n-  rtx top = ready[n_ready - 1];\n-  rtx next = ready[n_ready - 2];\n+  rtx_insn *top = ready[n_ready - 1];\n+  rtx_insn *next = ready[n_ready - 2];\n   rtx set;\n   sd_iterator_def sd_it;\n   dep_t dep;\n@@ -26092,13 +26093,13 @@ swap_top_of_ready_list (rtx *ready, int n_ready)\n /* Perform possible reodering of ready list for Atom/Silvermont only.\n    Return issue rate.  */\n static int\n-ix86_sched_reorder (FILE *dump, int sched_verbose, rtx *ready, int *pn_ready,\n-\t\t   int clock_var)\n+ix86_sched_reorder (FILE *dump, int sched_verbose, rtx_insn **ready,\n+\t\t    int *pn_ready, int clock_var)\n {\n   int issue_rate = -1;\n   int n_ready = *pn_ready;\n   int i;\n-  rtx insn;\n+  rtx_insn *insn;\n   int index = -1;\n \n   /* Set up issue rate.  */\n@@ -26178,12 +26179,12 @@ insn_is_function_arg (rtx insn, bool* is_spilled)\n /* Add output dependencies for chain of function adjacent arguments if only\n    there is a move to likely spilled HW register.  Return first argument\n    if at least one dependence was added or NULL otherwise.  */\n-static rtx\n-add_parameter_dependencies (rtx call, rtx head)\n+static rtx_insn *\n+add_parameter_dependencies (rtx_insn *call, rtx_insn *head)\n {\n-  rtx insn;\n-  rtx last = call;\n-  rtx first_arg = NULL;\n+  rtx_insn *insn;\n+  rtx_insn *last = call;\n+  rtx_insn *first_arg = NULL;\n   bool is_spilled = false;\n \n   head = PREV_INSN (head);\n@@ -26233,7 +26234,7 @@ add_parameter_dependencies (rtx call, rtx head)\n /* Add output or anti dependency from insn to first_arg to restrict its code\n    motion.  */\n static void\n-avoid_func_arg_motion (rtx first_arg, rtx insn)\n+avoid_func_arg_motion (rtx_insn *first_arg, rtx_insn *insn)\n {\n   rtx set;\n   rtx tmp;\n@@ -26255,9 +26256,9 @@ avoid_func_arg_motion (rtx first_arg, rtx insn)\n /* Avoid cross block motion of function argument through adding dependency\n    from the first non-jump instruction in bb.  */\n static void\n-add_dependee_for_func_arg (rtx arg, basic_block bb)\n+add_dependee_for_func_arg (rtx_insn *arg, basic_block bb)\n {\n-  rtx insn = BB_END (bb);\n+  rtx_insn *insn = BB_END (bb);\n \n   while (insn)\n     {\n@@ -26279,10 +26280,10 @@ add_dependee_for_func_arg (rtx arg, basic_block bb)\n /* Hook for pre-reload schedule - avoid motion of function arguments\n    passed in likely spilled HW registers.  */\n static void\n-ix86_dependencies_evaluation_hook (rtx head, rtx tail)\n+ix86_dependencies_evaluation_hook (rtx_insn *head, rtx_insn *tail)\n {\n-  rtx insn;\n-  rtx first_arg = NULL;\n+  rtx_insn *insn;\n+  rtx_insn *first_arg = NULL;\n   if (reload_completed)\n     return;\n   while (head != tail && DEBUG_INSN_P (head))"}, {"sha": "377ce449f2199c19861b80ad5418beca1149b869", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce1ce33a037057b77a99ed0613f4369546dc82cd/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce1ce33a037057b77a99ed0613f4369546dc82cd/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=ce1ce33a037057b77a99ed0613f4369546dc82cd", "patch": "@@ -166,7 +166,7 @@ static struct ia64_frame_info current_frame_info;\n static int emitted_frame_related_regs[number_of_ia64_frame_regs];\n \f\n static int ia64_first_cycle_multipass_dfa_lookahead (void);\n-static void ia64_dependencies_evaluation_hook (rtx, rtx);\n+static void ia64_dependencies_evaluation_hook (rtx_insn *, rtx_insn *);\n static void ia64_init_dfa_pre_cycle_insn (void);\n static rtx ia64_dfa_pre_cycle_insn (void);\n static int ia64_first_cycle_multipass_dfa_lookahead_guard (rtx, int);\n@@ -255,9 +255,9 @@ static void ia64_sched_init (FILE *, int, int);\n static void ia64_sched_init_global (FILE *, int, int);\n static void ia64_sched_finish_global (FILE *, int);\n static void ia64_sched_finish (FILE *, int);\n-static int ia64_dfa_sched_reorder (FILE *, int, rtx *, int *, int, int);\n-static int ia64_sched_reorder (FILE *, int, rtx *, int *, int);\n-static int ia64_sched_reorder2 (FILE *, int, rtx *, int *, int);\n+static int ia64_dfa_sched_reorder (FILE *, int, rtx_insn **, int *, int, int);\n+static int ia64_sched_reorder (FILE *, int, rtx_insn **, int *, int);\n+static int ia64_sched_reorder2 (FILE *, int, rtx_insn **, int *, int);\n static int ia64_variable_issue (FILE *, int, rtx, int);\n \n static void ia64_asm_unwind_emit (FILE *, rtx);\n@@ -7233,9 +7233,9 @@ ia64_emit_insn_before (rtx insn, rtx before)\n    `ia64_produce_address_p' and the DFA descriptions).  */\n \n static void\n-ia64_dependencies_evaluation_hook (rtx head, rtx tail)\n+ia64_dependencies_evaluation_hook (rtx_insn *head, rtx_insn *tail)\n {\n-  rtx insn, next, next_tail;\n+  rtx_insn *insn, *next, *next_tail;\n \n   /* Before reload, which_alternative is not set, which means that\n      ia64_safe_itanium_class will produce wrong results for (at least)\n@@ -7364,14 +7364,14 @@ record_memory_reference (rtx insn)\n    Override the default sort algorithm to better slot instructions.  */\n \n static int\n-ia64_dfa_sched_reorder (FILE *dump, int sched_verbose, rtx *ready,\n+ia64_dfa_sched_reorder (FILE *dump, int sched_verbose, rtx_insn **ready,\n \t\t\tint *pn_ready, int clock_var,\n \t\t\tint reorder_type)\n {\n   int n_asms;\n   int n_ready = *pn_ready;\n-  rtx *e_ready = ready + n_ready;\n-  rtx *insnp;\n+  rtx_insn **e_ready = ready + n_ready;\n+  rtx_insn **insnp;\n \n   if (sched_verbose)\n     fprintf (dump, \"// ia64_dfa_sched_reorder (type %d):\\n\", reorder_type);\n@@ -7383,21 +7383,21 @@ ia64_dfa_sched_reorder (FILE *dump, int sched_verbose, rtx *ready,\n       for (insnp = ready; insnp < e_ready; insnp++)\n \tif (insnp < e_ready)\n \t  {\n-\t    rtx insn = *insnp;\n+\t    rtx_insn *insn = *insnp;\n \t    enum attr_type t = ia64_safe_type (insn);\n \t    if (t == TYPE_UNKNOWN)\n \t      {\n \t\tif (GET_CODE (PATTERN (insn)) == ASM_INPUT\n \t\t    || asm_noperands (PATTERN (insn)) >= 0)\n \t\t  {\n-\t\t    rtx lowest = ready[n_asms];\n+\t\t    rtx_insn *lowest = ready[n_asms];\n \t\t    ready[n_asms] = insn;\n \t\t    *insnp = lowest;\n \t\t    n_asms++;\n \t\t  }\n \t\telse\n \t\t  {\n-\t\t    rtx highest = ready[n_ready - 1];\n+\t\t    rtx_insn *highest = ready[n_ready - 1];\n \t\t    ready[n_ready - 1] = insn;\n \t\t    *insnp = highest;\n \t\t    return 1;\n@@ -7434,7 +7434,7 @@ ia64_dfa_sched_reorder (FILE *dump, int sched_verbose, rtx *ready,\n       while (insnp-- > ready + deleted)\n \twhile (insnp >= ready + deleted)\n \t  {\n-\t    rtx insn = *insnp;\n+\t    rtx_insn *insn = *insnp;\n \t    if (! safe_group_barrier_needed (insn))\n \t      break;\n \t    memmove (ready + 1, ready, (insnp - ready) * sizeof (rtx));\n@@ -7455,7 +7455,7 @@ ia64_dfa_sched_reorder (FILE *dump, int sched_verbose, rtx *ready,\n       while (insnp-- > ready + moved)\n \twhile (insnp >= ready + moved)\n \t  {\n-\t    rtx insn = *insnp;\n+\t    rtx_insn *insn = *insnp;\n \t    if (! is_load_p (insn))\n \t      break;\n \t    memmove (ready + 1, ready, (insnp - ready) * sizeof (rtx));\n@@ -7473,8 +7473,8 @@ ia64_dfa_sched_reorder (FILE *dump, int sched_verbose, rtx *ready,\n    the default sort algorithm to better slot instructions.  */\n \n static int\n-ia64_sched_reorder (FILE *dump, int sched_verbose, rtx *ready, int *pn_ready,\n-\t\t    int clock_var)\n+ia64_sched_reorder (FILE *dump, int sched_verbose, rtx_insn **ready,\n+\t\t    int *pn_ready, int clock_var)\n {\n   return ia64_dfa_sched_reorder (dump, sched_verbose, ready,\n \t\t\t\t pn_ready, clock_var, 0);\n@@ -7485,7 +7485,7 @@ ia64_sched_reorder (FILE *dump, int sched_verbose, rtx *ready, int *pn_ready,\n \n static int\n ia64_sched_reorder2 (FILE *dump ATTRIBUTE_UNUSED,\n-\t\t     int sched_verbose ATTRIBUTE_UNUSED, rtx *ready,\n+\t\t     int sched_verbose ATTRIBUTE_UNUSED, rtx_insn **ready,\n \t\t     int *pn_ready, int clock_var)\n {\n   return ia64_dfa_sched_reorder (dump, sched_verbose, ready, pn_ready,"}, {"sha": "710a9b4ebd5dd2a30c6c4ad5118f752e7061e043", "filename": "gcc/config/mep/mep.c", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce1ce33a037057b77a99ed0613f4369546dc82cd/gcc%2Fconfig%2Fmep%2Fmep.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce1ce33a037057b77a99ed0613f4369546dc82cd/gcc%2Fconfig%2Fmep%2Fmep.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmep%2Fmep.c?ref=ce1ce33a037057b77a99ed0613f4369546dc82cd", "patch": "@@ -220,9 +220,9 @@ static void mep_incompatible_arg (const struct insn_operand_data *, rtx, int, tr\n static rtx mep_expand_builtin (tree, rtx, rtx, enum machine_mode, int);\n static int mep_adjust_cost (rtx, rtx, rtx, int);\n static int mep_issue_rate (void);\n-static rtx mep_find_ready_insn (rtx *, int, enum attr_slot, int);\n-static void mep_move_ready_insn (rtx *, int, rtx);\n-static int mep_sched_reorder (FILE *, int, rtx *, int *, int);\n+static rtx_insn *mep_find_ready_insn (rtx_insn **, int, enum attr_slot, int);\n+static void mep_move_ready_insn (rtx_insn **, int, rtx_insn *);\n+static int mep_sched_reorder (FILE *, int, rtx_insn **, int *, int);\n static rtx_insn *mep_make_bundle (rtx, rtx_insn *);\n static void mep_bundle_insns (rtx_insn *);\n static bool mep_rtx_cost (rtx, int, int, int, int *, bool);\n@@ -6540,25 +6540,26 @@ mep_vliw_function_p (tree decl)\n   return lookup_attribute (\"vliw\", TYPE_ATTRIBUTES (TREE_TYPE (decl))) != 0;\n }\n \n-static rtx\n-mep_find_ready_insn (rtx *ready, int nready, enum attr_slot slot, int length)\n+static rtx_insn *\n+mep_find_ready_insn (rtx_insn **ready, int nready, enum attr_slot slot,\n+\t\t     int length)\n {\n   int i;\n \n   for (i = nready - 1; i >= 0; --i)\n     {\n-      rtx insn = ready[i];\n+      rtx_insn *insn = ready[i];\n       if (recog_memoized (insn) >= 0\n \t  && get_attr_slot (insn) == slot\n \t  && get_attr_length (insn) == length)\n \treturn insn;\n     }\n \n-  return NULL_RTX;\n+  return NULL;\n }\n \n static void\n-mep_move_ready_insn (rtx *ready, int nready, rtx insn)\n+mep_move_ready_insn (rtx_insn **ready, int nready, rtx_insn *insn)\n {\n   int i;\n \n@@ -6575,7 +6576,7 @@ mep_move_ready_insn (rtx *ready, int nready, rtx insn)\n }\n \n static void\n-mep_print_sched_insn (FILE *dump, rtx insn)\n+mep_print_sched_insn (FILE *dump, rtx_insn *insn)\n {\n   const char *slots = \"none\";\n   const char *name = NULL;\n@@ -6620,11 +6621,11 @@ mep_print_sched_insn (FILE *dump, rtx insn)\n \n static int\n mep_sched_reorder (FILE *dump ATTRIBUTE_UNUSED,\n-\t\t   int sched_verbose ATTRIBUTE_UNUSED, rtx *ready,\n+\t\t   int sched_verbose ATTRIBUTE_UNUSED, rtx_insn **ready,\n \t\t   int *pnready, int clock ATTRIBUTE_UNUSED)\n {\n   int nready = *pnready;\n-  rtx core_insn, cop_insn;\n+  rtx_insn *core_insn, *cop_insn;\n   int i;\n \n   if (dump && sched_verbose > 1)"}, {"sha": "b4b1270514c6508ee47c20c56bc98ee29ee6400e", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce1ce33a037057b77a99ed0613f4369546dc82cd/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce1ce33a037057b77a99ed0613f4369546dc82cd/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=ce1ce33a037057b77a99ed0613f4369546dc82cd", "patch": "@@ -13334,9 +13334,9 @@ mips_multipass_dfa_lookahead (void)\n    be <= HIGHER.  */\n \n static void\n-mips_promote_ready (rtx *ready, int lower, int higher)\n+mips_promote_ready (rtx_insn **ready, int lower, int higher)\n {\n-  rtx new_head;\n+  rtx_insn *new_head;\n   int i;\n \n   new_head = ready[lower];\n@@ -13350,12 +13350,12 @@ mips_promote_ready (rtx *ready, int lower, int higher)\n    instructions if POS2 is not already less than POS1.  */\n \n static void\n-mips_maybe_swap_ready (rtx *ready, int pos1, int pos2, int limit)\n+mips_maybe_swap_ready (rtx_insn **ready, int pos1, int pos2, int limit)\n {\n   if (pos1 < pos2\n       && INSN_PRIORITY (ready[pos1]) + limit >= INSN_PRIORITY (ready[pos2]))\n     {\n-      rtx temp;\n+      rtx_insn *temp;\n \n       temp = ready[pos1];\n       ready[pos1] = ready[pos2];\n@@ -13384,7 +13384,7 @@ mips_macc_chains_record (rtx insn)\n    clobber hi or lo.  */\n \n static void\n-mips_macc_chains_reorder (rtx *ready, int nready)\n+mips_macc_chains_reorder (rtx_insn **ready, int nready)\n {\n   int i, j;\n \n@@ -13498,7 +13498,7 @@ vr4130_swap_insns_p (rtx insn1, rtx insn2)\n    vr4130_swap_insns_p says that it could be worthwhile.  */\n \n static void\n-vr4130_reorder (rtx *ready, int nready)\n+vr4130_reorder (rtx_insn **ready, int nready)\n {\n   if (vr4130_swap_insns_p (ready[nready - 1], ready[nready - 2]))\n     mips_promote_ready (ready, nready - 2, nready - 1);\n@@ -13528,7 +13528,7 @@ mips_74k_agen_init (rtx insn)\n    together.  Swap things around in the ready queue to make this happen.  */\n \n static void\n-mips_74k_agen_reorder (rtx *ready, int nready)\n+mips_74k_agen_reorder (rtx_insn **ready, int nready)\n {\n   int i;\n   int store_pos, load_pos;\n@@ -13538,7 +13538,7 @@ mips_74k_agen_reorder (rtx *ready, int nready)\n \n   for (i = nready - 1; i >= 0; i--)\n     {\n-      rtx insn = ready[i];\n+      rtx_insn *insn = ready[i];\n       if (USEFUL_INSN_P (insn))\n \tswitch (get_attr_type (insn))\n \t  {\n@@ -13598,7 +13598,7 @@ mips_sched_init (FILE *file ATTRIBUTE_UNUSED, int verbose ATTRIBUTE_UNUSED,\n \n static void\n mips_sched_reorder_1 (FILE *file ATTRIBUTE_UNUSED, int verbose ATTRIBUTE_UNUSED,\n-\t\t      rtx *ready, int *nreadyp, int cycle ATTRIBUTE_UNUSED)\n+\t\t      rtx_insn **ready, int *nreadyp, int cycle ATTRIBUTE_UNUSED)\n {\n   if (!reload_completed\n       && TUNE_MACC_CHAINS\n@@ -13619,7 +13619,7 @@ mips_sched_reorder_1 (FILE *file ATTRIBUTE_UNUSED, int verbose ATTRIBUTE_UNUSED,\n \n static int\n mips_sched_reorder (FILE *file ATTRIBUTE_UNUSED, int verbose ATTRIBUTE_UNUSED,\n-\t\t    rtx *ready, int *nreadyp, int cycle ATTRIBUTE_UNUSED)\n+\t\t    rtx_insn **ready, int *nreadyp, int cycle ATTRIBUTE_UNUSED)\n {\n   mips_sched_reorder_1 (file, verbose, ready, nreadyp, cycle);\n   return mips_issue_rate ();\n@@ -13629,7 +13629,7 @@ mips_sched_reorder (FILE *file ATTRIBUTE_UNUSED, int verbose ATTRIBUTE_UNUSED,\n \n static int\n mips_sched_reorder2 (FILE *file ATTRIBUTE_UNUSED, int verbose ATTRIBUTE_UNUSED,\n-\t\t     rtx *ready, int *nreadyp, int cycle ATTRIBUTE_UNUSED)\n+\t\t     rtx_insn **ready, int *nreadyp, int cycle ATTRIBUTE_UNUSED)\n {\n   mips_sched_reorder_1 (file, verbose, ready, nreadyp, cycle);\n   return cached_can_issue_more;"}, {"sha": "ff2b6abbc59882f8fb8fc269c92655812d5d67a0", "filename": "gcc/config/picochip/picochip.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce1ce33a037057b77a99ed0613f4369546dc82cd/gcc%2Fconfig%2Fpicochip%2Fpicochip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce1ce33a037057b77a99ed0613f4369546dc82cd/gcc%2Fconfig%2Fpicochip%2Fpicochip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpicochip%2Fpicochip.c?ref=ce1ce33a037057b77a99ed0613f4369546dc82cd", "patch": "@@ -100,7 +100,7 @@ int picochip_sched_lookahead (void);\n int picochip_sched_issue_rate (void);\n int picochip_sched_adjust_cost (rtx insn, rtx link,\n \t\t\t\t       rtx dep_insn, int cost);\n-int picochip_sched_reorder (FILE * file, int verbose, rtx * ready,\n+int picochip_sched_reorder (FILE * file, int verbose, rtx_insn ** ready,\n \t\t\t\t   int *n_readyp, int clock);\n \n void picochip_init_builtins (void);\n@@ -3507,7 +3507,7 @@ picochip_reset_vliw (rtx insn)\n \n int\n picochip_sched_reorder (FILE * file, int verbose,\n-\t\t\trtx * ready ATTRIBUTE_UNUSED,\n+\t\t\trtx_insn ** ready ATTRIBUTE_UNUSED,\n \t\t\tint *n_readyp ATTRIBUTE_UNUSED, int clock)\n {\n "}, {"sha": "c95c2957dd8e042247c55301e539fa56591a014d", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce1ce33a037057b77a99ed0613f4369546dc82cd/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce1ce33a037057b77a99ed0613f4369546dc82cd/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=ce1ce33a037057b77a99ed0613f4369546dc82cd", "patch": "@@ -27246,7 +27246,7 @@ get_next_active_insn (rtx insn, rtx tail)\n \n static int\n rs6000_sched_reorder (FILE *dump ATTRIBUTE_UNUSED, int sched_verbose,\n-                        rtx *ready ATTRIBUTE_UNUSED,\n+                        rtx_insn **ready ATTRIBUTE_UNUSED,\n                         int *pn_ready ATTRIBUTE_UNUSED,\n \t\t        int clock_var ATTRIBUTE_UNUSED)\n {\n@@ -27263,7 +27263,7 @@ rs6000_sched_reorder (FILE *dump ATTRIBUTE_UNUSED, int sched_verbose,\n         && (recog_memoized (ready[n_ready - 2]) > 0))\n       /* Simply swap first two insns.  */\n       {\n-\trtx tmp = ready[n_ready - 1];\n+\trtx_insn *tmp = ready[n_ready - 1];\n \tready[n_ready - 1] = ready[n_ready - 2];\n \tready[n_ready - 2] = tmp;\n       }\n@@ -27278,7 +27278,7 @@ rs6000_sched_reorder (FILE *dump ATTRIBUTE_UNUSED, int sched_verbose,\n /* Like rs6000_sched_reorder, but called after issuing each insn.  */\n \n static int\n-rs6000_sched_reorder2 (FILE *dump, int sched_verbose, rtx *ready,\n+rs6000_sched_reorder2 (FILE *dump, int sched_verbose, rtx_insn **ready,\n \t\t         int *pn_ready, int clock_var ATTRIBUTE_UNUSED)\n {\n   if (sched_verbose)\n@@ -27328,7 +27328,8 @@ rs6000_sched_reorder2 (FILE *dump, int sched_verbose, rtx *ready,\n     {\n       int pos;\n       int i;\n-      rtx tmp, load_mem, str_mem;\n+      rtx_insn *tmp;\n+      rtx load_mem, str_mem;\n \n       if (is_store_insn (last_scheduled_insn, &str_mem))\n         /* Issuing a store, swing the load_store_pendulum to the left */"}, {"sha": "2a8f70aa986ee608a88bd4ea5e98a734b7fa04d5", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce1ce33a037057b77a99ed0613f4369546dc82cd/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce1ce33a037057b77a99ed0613f4369546dc82cd/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=ce1ce33a037057b77a99ed0613f4369546dc82cd", "patch": "@@ -11482,11 +11482,11 @@ s390_fpload_toreg (rtx insn, unsigned int regno)\n    for Z10_EARLYLOAD_DISTANCE.  A problematic load instruction is\n    moved to the very end of the ready list.  */\n static void\n-s390_z10_prevent_earlyload_conflicts (rtx *ready, int *nready_p)\n+s390_z10_prevent_earlyload_conflicts (rtx_insn **ready, int *nready_p)\n {\n   unsigned int regno;\n   int nready = *nready_p;\n-  rtx tmp;\n+  rtx_insn *tmp;\n   int i;\n   rtx_insn *insn;\n   rtx set;\n@@ -11524,7 +11524,7 @@ s390_z10_prevent_earlyload_conflicts (rtx *ready, int *nready_p)\n     return;\n \n   tmp = ready[i];\n-  memmove (&ready[1], &ready[0], sizeof (rtx) * i);\n+  memmove (&ready[1], &ready[0], sizeof (rtx_insn *) * i);\n   ready[0] = tmp;\n }\n \n@@ -11627,7 +11627,7 @@ s390_sched_score (rtx insn)\n    conflicts in the floating point pipeline  */\n static int\n s390_sched_reorder (FILE *file, int verbose,\n-\t\t    rtx *ready, int *nreadyp, int clock ATTRIBUTE_UNUSED)\n+\t\t    rtx_insn **ready, int *nreadyp, int clock ATTRIBUTE_UNUSED)\n {\n   if (s390_tune == PROCESSOR_2097_Z10)\n     if (reload_completed && *nreadyp > 1)\n@@ -11641,7 +11641,7 @@ s390_sched_reorder (FILE *file, int verbose,\n       int last_index = *nreadyp - 1;\n       int max_index = -1;\n       int max_score = -1;\n-      rtx tmp;\n+      rtx_insn *tmp;\n \n       /* Just move the insn with the highest score to the top (the\n \t end) of the list.  A full sort is not needed since a conflict"}, {"sha": "d2eb34d52711eb49c679c93a7036c2f4bf42645e", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce1ce33a037057b77a99ed0613f4369546dc82cd/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce1ce33a037057b77a99ed0613f4369546dc82cd/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=ce1ce33a037057b77a99ed0613f4369546dc82cd", "patch": "@@ -237,11 +237,11 @@ static int find_r0_life_regions (basic_block);\n static void  sh_md_init_global (FILE *, int, int);\n static void  sh_md_finish_global (FILE *, int);\n static int rank_for_reorder (const void *, const void *);\n-static void swap_reorder (rtx *, int);\n-static void ready_reorder (rtx *, int);\n+static void swap_reorder (rtx_insn **, int);\n+static void ready_reorder (rtx_insn **, int);\n static bool high_pressure (enum machine_mode);\n-static int sh_reorder (FILE *, int, rtx *, int *, int);\n-static int sh_reorder2 (FILE *, int, rtx *, int *, int);\n+static int sh_reorder (FILE *, int, rtx_insn **, int *, int);\n+static int sh_reorder2 (FILE *, int, rtx_insn **, int *, int);\n static void sh_md_init (FILE *, int, int);\n static int sh_variable_issue (FILE *, int, rtx, int);\n \n@@ -11127,8 +11127,8 @@ find_regmode_weight (basic_block b, enum machine_mode mode)\n static int\n rank_for_reorder (const void *x, const void *y)\n {\n-  rtx tmp = *(const rtx *) y;\n-  rtx tmp2 = *(const rtx *) x;\n+  rtx_insn *tmp = *(rtx_insn * const *) y;\n+  rtx_insn *tmp2 = *(rtx_insn * const *) x;\n \n   /* The insn in a schedule group should be issued the first.  */\n   if (SCHED_GROUP_P (tmp) != SCHED_GROUP_P (tmp2))\n@@ -11142,9 +11142,9 @@ rank_for_reorder (const void *x, const void *y)\n \n /* Resort the array A in which only element at index N may be out of order.  */\n static void\n-swap_reorder (rtx *a, int n)\n+swap_reorder (rtx_insn **a, int n)\n {\n-  rtx insn = a[n - 1];\n+  rtx_insn *insn = a[n - 1];\n   int i = n - 2;\n \n   while (i >= 0 && rank_for_reorder (a + i, &insn) >= 0)\n@@ -11157,12 +11157,12 @@ swap_reorder (rtx *a, int n)\n \n /* Sort the ready list by ascending priority.  */\n static void\n-ready_reorder (rtx *ready, int nready)\n+ready_reorder (rtx_insn **ready, int nready)\n {\n   if (nready == 2)\n     swap_reorder (ready, nready);\n   else if (nready > 2)\n-     qsort (ready, nready, sizeof (rtx), rank_for_reorder);\n+     qsort (ready, nready, sizeof (rtx_insn *), rank_for_reorder);\n }\n \n /* Count life regions of r0 for a block.  */\n@@ -11326,7 +11326,7 @@ high_pressure (enum machine_mode mode)\n static int\n sh_reorder (FILE *dump ATTRIBUTE_UNUSED,\n \t    int sched_verbose ATTRIBUTE_UNUSED,\n-\t    rtx *ready,\n+\t    rtx_insn **ready,\n \t    int *n_readyp,\n \t    int clock_var ATTRIBUTE_UNUSED)\n {\n@@ -11345,7 +11345,7 @@ sh_reorder (FILE *dump ATTRIBUTE_UNUSED,\n static int\n sh_reorder2 (FILE *dump ATTRIBUTE_UNUSED,\n \t     int sched_verbose ATTRIBUTE_UNUSED,\n-\t     rtx *ready ATTRIBUTE_UNUSED,\n+\t     rtx_insn **ready ATTRIBUTE_UNUSED,\n \t     int *n_readyp ATTRIBUTE_UNUSED,\n \t     int clock_var ATTRIBUTE_UNUSED)\n {"}, {"sha": "5f17346f3f53ac3e6984114673bb2721e2f8aeeb", "filename": "gcc/config/spu/spu.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce1ce33a037057b77a99ed0613f4369546dc82cd/gcc%2Fconfig%2Fspu%2Fspu.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce1ce33a037057b77a99ed0613f4369546dc82cd/gcc%2Fconfig%2Fspu%2Fspu.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.c?ref=ce1ce33a037057b77a99ed0613f4369546dc82cd", "patch": "@@ -2861,11 +2861,11 @@ spu_sched_variable_issue (FILE *file ATTRIBUTE_UNUSED,\n    TARGET_SCHED_REORDER2.  */\n static int\n spu_sched_reorder (FILE *file ATTRIBUTE_UNUSED, int verbose ATTRIBUTE_UNUSED,\n-\t\t   rtx *ready, int *nreadyp, int clock)\n+\t\t   rtx_insn **ready, int *nreadyp, int clock)\n {\n   int i, nready = *nreadyp;\n   int pipe_0, pipe_1, pipe_hbrp, pipe_ls, schedule_i;\n-  rtx insn;\n+  rtx_insn *insn;\n \n   clock_var = clock;\n "}, {"sha": "4e0bab317e6824bbd0b931220de5711e0ff17ee0", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce1ce33a037057b77a99ed0613f4369546dc82cd/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce1ce33a037057b77a99ed0613f4369546dc82cd/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=ce1ce33a037057b77a99ed0613f4369546dc82cd", "patch": "@@ -6415,7 +6415,7 @@ later.  Do not define this hook if you do not need to adjust the\n scheduling priorities of insns.\n @end deftypefn\n \n-@deftypefn {Target Hook} int TARGET_SCHED_REORDER (FILE *@var{file}, int @var{verbose}, rtx *@var{ready}, int *@var{n_readyp}, int @var{clock})\n+@deftypefn {Target Hook} int TARGET_SCHED_REORDER (FILE *@var{file}, int @var{verbose}, rtx_insn **@var{ready}, int *@var{n_readyp}, int @var{clock})\n This hook is executed by the scheduler after it has scheduled the ready\n list, to allow the machine description to reorder it (for example to\n combine two small instructions together on @samp{VLIW} machines).\n@@ -6432,7 +6432,7 @@ can issue this cycle; normally this is just @code{issue_rate}.  See also\n @samp{TARGET_SCHED_REORDER2}.\n @end deftypefn\n \n-@deftypefn {Target Hook} int TARGET_SCHED_REORDER2 (FILE *@var{file}, int @var{verbose}, rtx *@var{ready}, int *@var{n_readyp}, int @var{clock})\n+@deftypefn {Target Hook} int TARGET_SCHED_REORDER2 (FILE *@var{file}, int @var{verbose}, rtx_insn **@var{ready}, int *@var{n_readyp}, int @var{clock})\n Like @samp{TARGET_SCHED_REORDER}, but called at a different time.  That\n function is called whenever the scheduler starts a new cycle.  This one\n is called once per iteration over a cycle, immediately after\n@@ -6454,7 +6454,7 @@ target microarchitecture. If this hook returns true for the given insn pair\n group, and they will not be scheduled apart.\n @end deftypefn\n \n-@deftypefn {Target Hook} void TARGET_SCHED_DEPENDENCIES_EVALUATION_HOOK (rtx @var{head}, rtx @var{tail})\n+@deftypefn {Target Hook} void TARGET_SCHED_DEPENDENCIES_EVALUATION_HOOK (rtx_insn *@var{head}, rtx_insn *@var{tail})\n This hook is called after evaluation forward dependencies of insns in\n chain given by two parameter values (@var{head} and @var{tail}\n correspondingly) but before insns scheduling of the insn chain.  For"}, {"sha": "18f5726903a9f6c59826a7d3ca506ec99567da3d", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 108, "deletions": 107, "changes": 215, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce1ce33a037057b77a99ed0613f4369546dc82cd/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce1ce33a037057b77a99ed0613f4369546dc82cd/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=ce1ce33a037057b77a99ed0613f4369546dc82cd", "patch": "@@ -241,7 +241,7 @@ struct common_sched_info_def *common_sched_info;\n \n /* List of important notes we must keep around.  This is a pointer to the\n    last element in the list.  */\n-rtx note_list;\n+rtx_insn *note_list;\n \n static struct spec_info_def spec_info_var;\n /* Description of the speculative part of the scheduling.\n@@ -370,7 +370,7 @@ int cycle_issued_insns;\n \n /* This records the actual schedule.  It is built up during the main phase\n    of schedule_block, and afterwards used to reorder the insns in the RTL.  */\n-static vec<rtx> scheduled_insns;\n+static vec<rtx_insn *> scheduled_insns;\n \n static int may_trap_exp (const_rtx, int);\n \n@@ -591,7 +591,7 @@ set_modulo_params (int ii, int max_stages, int insns, int max_uid)\n struct delay_pair\n {\n   struct delay_pair *next_same_i1;\n-  rtx i1, i2;\n+  rtx_insn *i1, *i2;\n   int cycles;\n   /* When doing modulo scheduling, we a delay_pair can also be used to\n      show that I1 and I2 are the same insn in a different stage.  If that\n@@ -726,7 +726,7 @@ discard_delay_pairs_above (int max_uid)\n    scheduling.  */\n \n void\n-record_delay_slot_pair (rtx i1, rtx i2, int cycles, int stages)\n+record_delay_slot_pair (rtx_insn *i1, rtx_insn *i2, int cycles, int stages)\n {\n   struct delay_pair *p = XNEW (struct delay_pair);\n   struct delay_pair **slot;\n@@ -780,7 +780,7 @@ pair_delay (struct delay_pair *p)\n    and add dependencies to the real insns to limit the amount of backtracking\n    needed.  */\n void\n-add_delay_dependencies (rtx insn)\n+add_delay_dependencies (rtx_insn *insn)\n {\n   struct delay_pair *pair;\n   sd_iterator_def sd_it;\n@@ -828,9 +828,9 @@ add_delay_dependencies (rtx insn)\n \n static int priority (rtx);\n static int rank_for_schedule (const void *, const void *);\n-static void swap_sort (rtx *, int);\n-static void queue_insn (rtx, int, const char *);\n-static int schedule_insn (rtx);\n+static void swap_sort (rtx_insn **, int);\n+static void queue_insn (rtx_insn *, int, const char *);\n+static int schedule_insn (rtx_insn *);\n static void adjust_priority (rtx);\n static void advance_one_cycle (void);\n static void extend_h_i_d (void);\n@@ -852,42 +852,42 @@ static void extend_h_i_d (void);\n    unlink_other_notes ()).  After scheduling the block, these notes are\n    inserted at the beginning of the block (in schedule_block()).  */\n \n-static void ready_add (struct ready_list *, rtx, bool);\n-static rtx ready_remove_first (struct ready_list *);\n-static rtx ready_remove_first_dispatch (struct ready_list *ready);\n+static void ready_add (struct ready_list *, rtx_insn *, bool);\n+static rtx_insn *ready_remove_first (struct ready_list *);\n+static rtx_insn *ready_remove_first_dispatch (struct ready_list *ready);\n \n static void queue_to_ready (struct ready_list *);\n static int early_queue_to_ready (state_t, struct ready_list *);\n \n /* The following functions are used to implement multi-pass scheduling\n    on the first cycle.  */\n-static rtx ready_remove (struct ready_list *, int);\n+static rtx_insn *ready_remove (struct ready_list *, int);\n static void ready_remove_insn (rtx);\n \n static void fix_inter_tick (rtx, rtx);\n-static int fix_tick_ready (rtx);\n-static void change_queue_index (rtx, int);\n+static int fix_tick_ready (rtx_insn *);\n+static void change_queue_index (rtx_insn *, int);\n \n /* The following functions are used to implement scheduling of data/control\n    speculative instructions.  */\n \n static void extend_h_i_d (void);\n static void init_h_i_d (rtx);\n static int haifa_speculate_insn (rtx, ds_t, rtx *);\n-static void generate_recovery_code (rtx);\n+static void generate_recovery_code (rtx_insn *);\n static void process_insn_forw_deps_be_in_spec (rtx, rtx, ds_t);\n-static void begin_speculative_block (rtx);\n+static void begin_speculative_block (rtx_insn *);\n static void add_to_speculative_block (rtx);\n static void init_before_recovery (basic_block *);\n-static void create_check_block_twin (rtx, bool);\n+static void create_check_block_twin (rtx_insn *, bool);\n static void fix_recovery_deps (basic_block);\n static bool haifa_change_pattern (rtx, rtx);\n static void dump_new_block_header (int, basic_block, rtx, rtx);\n static void restore_bb_notes (basic_block);\n static void fix_jump_move (rtx);\n static void move_block_after_check (rtx);\n static void move_succs (vec<edge, va_gc> **, basic_block);\n-static void sched_remove_insn (rtx);\n+static void sched_remove_insn (rtx_insn *);\n static void clear_priorities (rtx, rtx_vec_t *);\n static void calc_priorities (rtx_vec_t);\n static void add_jump_dependencies (rtx, rtx);\n@@ -1119,7 +1119,7 @@ print_curr_reg_pressure (void)\n /* Determine if INSN has a condition that is clobbered if a register\n    in SET_REGS is modified.  */\n static bool\n-cond_clobbered_p (rtx insn, HARD_REG_SET set_regs)\n+cond_clobbered_p (rtx_insn *insn, HARD_REG_SET set_regs)\n {\n   rtx pat = PATTERN (insn);\n   gcc_assert (GET_CODE (pat) == COND_EXEC);\n@@ -1271,7 +1271,7 @@ recompute_todo_spec (rtx next, bool for_backtrack)\n       rtx pro, other, new_pat;\n       rtx cond = NULL_RTX;\n       bool success;\n-      rtx prev = NULL_RTX;\n+      rtx_insn *prev = NULL;\n       int i;\n       unsigned regno;\n   \n@@ -1348,7 +1348,7 @@ recompute_todo_spec (rtx next, bool for_backtrack)\n }\n \f\n /* Pointer to the last instruction scheduled.  */\n-static rtx last_scheduled_insn;\n+static rtx_insn *last_scheduled_insn;\n \n /* Pointer to the last nondebug instruction scheduled within the\n    block, or the prev_head of the scheduling block.  Used by\n@@ -1359,7 +1359,7 @@ static rtx last_nondebug_scheduled_insn;\n /* Pointer that iterates through the list of unscheduled insns if we\n    have a dbg_cnt enabled.  It always points at an insn prior to the\n    first unscheduled one.  */\n-static rtx nonscheduled_insns_begin;\n+static rtx_insn *nonscheduled_insns_begin;\n \n /* Compute cost of executing INSN.\n    This is the number of cycles between instruction issue and\n@@ -2464,7 +2464,7 @@ model_dump_pressure_points (struct model_pressure_group *group)\n /* Set INSN_REG_PRESSURE_EXCESS_COST_CHANGE for INSNS[0...COUNT-1].  */\n \n static void\n-model_set_excess_costs (rtx *insns, int count)\n+model_set_excess_costs (rtx_insn **insns, int count)\n {\n   int i, cost, priority_base, priority;\n   bool print_p;\n@@ -2553,8 +2553,8 @@ rfs_result (enum rfs_decision decision, int result)\n static int\n rank_for_schedule (const void *x, const void *y)\n {\n-  rtx tmp = *(const rtx *) y;\n-  rtx tmp2 = *(const rtx *) x;\n+  rtx_insn *tmp = *(rtx_insn * const *) y;\n+  rtx_insn *tmp2 = *(rtx_insn * const *) x;\n   int tmp_class, tmp2_class;\n   int val, priority_val, info_val, diff;\n \n@@ -2722,9 +2722,9 @@ rank_for_schedule (const void *x, const void *y)\n /* Resort the array A in which only element at index N may be out of order.  */\n \n HAIFA_INLINE static void\n-swap_sort (rtx *a, int n)\n+swap_sort (rtx_insn **a, int n)\n {\n-  rtx insn = a[n - 1];\n+  rtx_insn *insn = a[n - 1];\n   int i = n - 2;\n \n   while (i >= 0 && rank_for_schedule (a + i, &insn) >= 0)\n@@ -2741,7 +2741,7 @@ swap_sort (rtx *a, int n)\n    output.  */\n \n HAIFA_INLINE static void\n-queue_insn (rtx insn, int n_cycles, const char *reason)\n+queue_insn (rtx_insn *insn, int n_cycles, const char *reason)\n {\n   int next_q = NEXT_Q_AFTER (q_ptr, n_cycles);\n   rtx link = alloc_INSN_LIST (insn, insn_queue[next_q]);\n@@ -2792,7 +2792,7 @@ queue_remove (rtx insn)\n /* Return a pointer to the bottom of the ready list, i.e. the insn\n    with the lowest priority.  */\n \n-rtx *\n+rtx_insn **\n ready_lastpos (struct ready_list *ready)\n {\n   gcc_assert (ready->n_ready >= 1);\n@@ -2803,7 +2803,7 @@ ready_lastpos (struct ready_list *ready)\n    lowest/highest priority depending on FIRST_P.  */\n \n HAIFA_INLINE static void\n-ready_add (struct ready_list *ready, rtx insn, bool first_p)\n+ready_add (struct ready_list *ready, rtx_insn *insn, bool first_p)\n {\n   if (!first_p)\n     {\n@@ -2847,10 +2847,10 @@ ready_add (struct ready_list *ready, rtx insn, bool first_p)\n /* Remove the element with the highest priority from the ready list and\n    return it.  */\n \n-HAIFA_INLINE static rtx\n+HAIFA_INLINE static rtx_insn *\n ready_remove_first (struct ready_list *ready)\n {\n-  rtx t;\n+  rtx_insn *t;\n \n   gcc_assert (ready->n_ready);\n   t = ready->vec[ready->first--];\n@@ -2875,7 +2875,7 @@ ready_remove_first (struct ready_list *ready)\n    insn with the highest priority is 0, and the lowest priority has\n    N_READY - 1.  */\n \n-rtx\n+rtx_insn *\n ready_element (struct ready_list *ready, int index)\n {\n   gcc_assert (ready->n_ready && index < ready->n_ready);\n@@ -2887,10 +2887,10 @@ ready_element (struct ready_list *ready, int index)\n    for insn with the highest priority is 0, and the lowest priority\n    has N_READY - 1.  */\n \n-HAIFA_INLINE static rtx\n+HAIFA_INLINE static rtx_insn *\n ready_remove (struct ready_list *ready, int index)\n {\n-  rtx t;\n+  rtx_insn *t;\n   int i;\n \n   if (index == 0)\n@@ -2948,7 +2948,7 @@ void\n ready_sort (struct ready_list *ready)\n {\n   int i;\n-  rtx *first = ready_lastpos (ready);\n+  rtx_insn **first = ready_lastpos (ready);\n \n   if (sched_pressure == SCHED_PRESSURE_WEIGHTED)\n     {\n@@ -3137,7 +3137,7 @@ check_clobbered_conditions (rtx insn)\n  restart:\n   for (i = 0; i < ready.n_ready; i++)\n     {\n-      rtx x = ready_element (&ready, i);\n+      rtx_insn *x = ready_element (&ready, i);\n       if (TODO_SPEC (x) == DEP_CONTROL && cond_clobbered_p (x, t))\n \t{\n \t  ready_remove_insn (x);\n@@ -3152,7 +3152,7 @@ check_clobbered_conditions (rtx insn)\n     restart_queue:\n       for (link = insn_queue[q]; link; link = XEXP (link, 1))\n \t{\n-\t  rtx x = XEXP (link, 0);\n+\t  rtx_insn *x = as_a <rtx_insn *> (XEXP (link, 0));\n \t  if (TODO_SPEC (x) == DEP_CONTROL && cond_clobbered_p (x, t))\n \t    {\n \t      queue_remove (x);\n@@ -3790,7 +3790,7 @@ struct sched_block_state\n    zero for insns in a schedule group).  */\n \n static int\n-schedule_insn (rtx insn)\n+schedule_insn (rtx_insn *insn)\n {\n   sd_iterator_def sd_it;\n   dep_t dep;\n@@ -4032,9 +4032,9 @@ concat_note_lists (rtx from_end, rtx *to_endp)\n /* Delete notes between HEAD and TAIL and put them in the chain\n    of notes ended by NOTE_LIST.  */\n void\n-remove_notes (rtx head, rtx tail)\n+remove_notes (rtx_insn *head, rtx_insn *tail)\n {\n-  rtx next_tail, insn, next;\n+  rtx_insn *next_tail, *insn, *next;\n \n   note_list = 0;\n   if (head == tail && !INSN_P (head))\n@@ -4100,9 +4100,9 @@ struct haifa_saved_data\n   struct ready_list ready;\n   state_t curr_state;\n \n-  rtx last_scheduled_insn;\n+  rtx_insn *last_scheduled_insn;\n   rtx last_nondebug_scheduled_insn;\n-  rtx nonscheduled_insns_begin;\n+  rtx_insn *nonscheduled_insns_begin;\n   int cycle_issued_insns;\n \n   /* Copies of state used in the inner loop of schedule_block.  */\n@@ -4159,7 +4159,7 @@ save_backtrack_point (struct delay_pair *pair,\n   save->ready.n_ready = ready.n_ready;\n   save->ready.n_debug = ready.n_debug;\n   save->ready.veclen = ready.veclen;\n-  save->ready.vec = XNEWVEC (rtx, ready.veclen);\n+  save->ready.vec = XNEWVEC (rtx_insn *, ready.veclen);\n   memcpy (save->ready.vec, ready.vec, ready.veclen * sizeof (rtx));\n \n   save->insn_queue = XNEWVEC (rtx, max_insn_queue_index + 1);\n@@ -4223,7 +4223,7 @@ toggle_cancelled_flags (bool set)\n \n   if (ready.n_ready > 0)\n     {\n-      rtx *first = ready_lastpos (&ready);\n+      rtx_insn **first = ready_lastpos (&ready);\n       for (i = 0; i < ready.n_ready; i++)\n \tFOR_EACH_DEP (first[i], SD_LIST_BACK, sd_it, dep)\n \t  if (!DEBUG_INSN_P (DEP_PRO (dep)))\n@@ -4370,10 +4370,10 @@ restore_last_backtrack_point (struct sched_block_state *psched_block)\n      of the queues.  */\n   if (ready.n_ready > 0)\n     {\n-      rtx *first = ready_lastpos (&ready);\n+      rtx_insn **first = ready_lastpos (&ready);\n       for (i = 0; i < ready.n_ready; i++)\n \t{\n-\t  rtx insn = first[i];\n+\t  rtx_insn *insn = first[i];\n \t  QUEUE_INDEX (insn) = QUEUE_NOWHERE;\n \t  INSN_TICK (insn) = INVALID_TICK;\n \t}\n@@ -4396,10 +4396,10 @@ restore_last_backtrack_point (struct sched_block_state *psched_block)\n \n   if (ready.n_ready > 0)\n     {\n-      rtx *first = ready_lastpos (&ready);\n+      rtx_insn **first = ready_lastpos (&ready);\n       for (i = 0; i < ready.n_ready; i++)\n \t{\n-\t  rtx insn = first[i];\n+\t  rtx_insn *insn = first[i];\n \t  QUEUE_INDEX (insn) = QUEUE_READY;\n \t  TODO_SPEC (insn) = recompute_todo_spec (insn, true);\n \t  INSN_TICK (insn) = save->clock_var;\n@@ -4688,7 +4688,7 @@ estimate_shadow_tick (struct delay_pair *p)\n /* If INSN has no unresolved backwards dependencies, add it to the schedule and\n    recursively resolve all its forward dependencies.  */\n static void\n-resolve_dependencies (rtx insn)\n+resolve_dependencies (rtx_insn *insn)\n {\n   sd_iterator_def sd_it;\n   dep_t dep;\n@@ -4843,12 +4843,12 @@ no_real_insns_p (const_rtx head, const_rtx tail)\n \n /* Restore-other-notes: NOTE_LIST is the end of a chain of notes\n    previously found among the insns.  Insert them just before HEAD.  */\n-rtx\n-restore_other_notes (rtx head, basic_block head_bb)\n+rtx_insn *\n+restore_other_notes (rtx_insn *head, basic_block head_bb)\n {\n   if (note_list != 0)\n     {\n-      rtx note_head = note_list;\n+      rtx_insn *note_head = note_list;\n \n       if (head)\n \thead_bb = BLOCK_FOR_INSN (head);\n@@ -4882,7 +4882,7 @@ restore_other_notes (rtx head, basic_block head_bb)\n static void\n undo_all_replacements (void)\n {\n-  rtx insn;\n+  rtx_insn *insn;\n   int i;\n \n   FOR_EACH_VEC_ELT (scheduled_insns, i, insn)\n@@ -4903,12 +4903,12 @@ undo_all_replacements (void)\n \n /* Return first non-scheduled insn in the current scheduling block.\n    This is mostly used for debug-counter purposes.  */\n-static rtx\n+static rtx_insn *\n first_nonscheduled_insn (void)\n {\n-  rtx insn = (nonscheduled_insns_begin != NULL_RTX\n-\t      ? nonscheduled_insns_begin\n-\t      : current_sched_info->prev_head);\n+  rtx_insn *insn = (nonscheduled_insns_begin != NULL_RTX\n+\t\t    ? nonscheduled_insns_begin\n+\t\t    : current_sched_info->prev_head);\n \n   do\n     {\n@@ -4924,7 +4924,7 @@ first_nonscheduled_insn (void)\n static void\n queue_to_ready (struct ready_list *ready)\n {\n-  rtx insn;\n+  rtx_insn *insn;\n   rtx link;\n   rtx skip_insn;\n \n@@ -4941,7 +4941,7 @@ queue_to_ready (struct ready_list *ready)\n      ready list.  */\n   for (link = insn_queue[q_ptr]; link; link = XEXP (link, 1))\n     {\n-      insn = XEXP (link, 0);\n+      insn = as_a <rtx_insn *> (XEXP (link, 0));\n       q_size -= 1;\n \n       if (sched_verbose >= 2)\n@@ -4989,7 +4989,7 @@ queue_to_ready (struct ready_list *ready)\n \t    {\n \t      for (; link; link = XEXP (link, 1))\n \t\t{\n-\t\t  insn = XEXP (link, 0);\n+\t\t  insn = as_a <rtx_insn *> (XEXP (link, 0));\n \t\t  q_size -= 1;\n \n \t\t  if (sched_verbose >= 2)\n@@ -5080,7 +5080,7 @@ ok_for_early_queue_removal (rtx insn)\n static int\n early_queue_to_ready (state_t state, struct ready_list *ready)\n {\n-  rtx insn;\n+  rtx_insn *insn;\n   rtx link;\n   rtx next_link;\n   rtx prev_link;\n@@ -5118,7 +5118,7 @@ early_queue_to_ready (state_t state, struct ready_list *ready)\n \t  while (link)\n \t    {\n \t      next_link = XEXP (link, 1);\n-\t      insn = XEXP (link, 0);\n+\t      insn = as_a <rtx_insn *> (XEXP (link, 0));\n \t      if (insn && sched_verbose > 6)\n \t\tprint_rtl_single (sched_dump, insn);\n \n@@ -5181,7 +5181,7 @@ early_queue_to_ready (state_t state, struct ready_list *ready)\n static void\n debug_ready_list_1 (struct ready_list *ready, signed char *ready_try)\n {\n-  rtx *p;\n+  rtx_insn **p;\n   int i;\n \n   if (ready->n_ready == 0)\n@@ -5240,12 +5240,12 @@ reemit_notes (rtx insn)\n \n /* Move INSN.  Reemit notes if needed.  Update CFG, if needed.  */\n static void\n-move_insn (rtx insn, rtx last, rtx nt)\n+move_insn (rtx_insn *insn, rtx last, rtx nt)\n {\n   if (PREV_INSN (insn) != last)\n     {\n       basic_block bb;\n-      rtx note;\n+      rtx_insn *note;\n       int jump_p = 0;\n \n       bb = BLOCK_FOR_INSN (insn);\n@@ -5325,7 +5325,7 @@ move_insn (rtx insn, rtx last, rtx nt)\n \n /* Return true if scheduling INSN will finish current clock cycle.  */\n static bool\n-insn_finishes_cycle_p (rtx insn)\n+insn_finishes_cycle_p (rtx_insn *insn)\n {\n   if (SCHED_GROUP_P (insn))\n     /* After issuing INSN, rest of the sched_group will be forced to issue\n@@ -5409,7 +5409,7 @@ max_issue (struct ready_list *ready, int privileged_n, state_t state,\n   int n, i, all, n_ready, best, delay, tries_num;\n   int more_issue;\n   struct choice_entry *top;\n-  rtx insn;\n+  rtx_insn *insn;\n \n   n_ready = ready->n_ready;\n   gcc_assert (dfa_lookahead >= 1 && privileged_n >= 0\n@@ -5579,7 +5579,7 @@ max_issue (struct ready_list *ready, int privileged_n, state_t state,\n    1 if choose_ready () should be restarted without advancing the cycle.  */\n static int\n choose_ready (struct ready_list *ready, bool first_cycle_insn_p,\n-\t      rtx *insn_ptr)\n+\t      rtx_insn **insn_ptr)\n {\n   int lookahead;\n \n@@ -5588,7 +5588,7 @@ choose_ready (struct ready_list *ready, bool first_cycle_insn_p,\n       if (nonscheduled_insns_begin == NULL_RTX)\n \tnonscheduled_insns_begin = current_sched_info->prev_head;\n \n-      rtx insn = first_nonscheduled_insn ();\n+      rtx_insn *insn = first_nonscheduled_insn ();\n \n       if (QUEUE_INDEX (insn) == QUEUE_READY)\n \t/* INSN is in the ready_list.  */\n@@ -5621,7 +5621,7 @@ choose_ready (struct ready_list *ready, bool first_cycle_insn_p,\n     {\n       /* Try to choose the best insn.  */\n       int index = 0, i;\n-      rtx insn;\n+      rtx_insn *insn;\n \n       insn = ready_element (ready, 0);\n       if (INSN_CODE (insn) < 0)\n@@ -5709,10 +5709,10 @@ choose_ready (struct ready_list *ready, bool first_cycle_insn_p,\n    block.  TARGET_BB is the argument passed to schedule_block.  */\n \n static void\n-commit_schedule (rtx prev_head, rtx tail, basic_block *target_bb)\n+commit_schedule (rtx_insn *prev_head, rtx tail, basic_block *target_bb)\n {\n   unsigned int i;\n-  rtx insn;\n+  rtx_insn *insn;\n \n   last_scheduled_insn = prev_head;\n   for (i = 0;\n@@ -5768,7 +5768,7 @@ prune_ready_list (state_t temp_state, bool first_cycle_insn_p,\n \n   for (i = 0; i < ready.n_ready; i++)\n     {\n-      rtx insn = ready_element (&ready, i);\n+      rtx_insn *insn = ready_element (&ready, i);\n       if (SCHED_GROUP_P (insn))\n \t{\n \t  sched_group_found = true;\n@@ -5784,7 +5784,7 @@ prune_ready_list (state_t temp_state, bool first_cycle_insn_p,\n       int n = ready.n_ready;\n       for (i = 0; i < n; i++)\n \t{\n-\t  rtx insn = ready_element (&ready, i);\n+\t  rtx_insn *insn = ready_element (&ready, i);\n \t  int cost = 0;\n \t  const char *reason = \"resource conflict\";\n \n@@ -5971,10 +5971,10 @@ schedule_block (basic_block *target_bb, state_t init_state)\n   int sort_p, advance, start_clock_var;\n \n   /* Head/tail info for this block.  */\n-  rtx prev_head = current_sched_info->prev_head;\n+  rtx_insn *prev_head = current_sched_info->prev_head;\n   rtx next_tail = current_sched_info->next_tail;\n-  rtx head = NEXT_INSN (prev_head);\n-  rtx tail = PREV_INSN (next_tail);\n+  rtx_insn *head = NEXT_INSN (prev_head);\n+  rtx_insn *tail = PREV_INSN (next_tail);\n \n   if ((current_sched_info->flags & DONT_BREAK_DEPENDENCIES) == 0\n       && sched_pressure != SCHED_PRESSURE_MODEL)\n@@ -6025,7 +6025,7 @@ schedule_block (basic_block *target_bb, state_t init_state)\n   /* We start inserting insns after PREV_HEAD.  */\n   last_scheduled_insn = prev_head;\n   last_nondebug_scheduled_insn = NULL_RTX;\n-  nonscheduled_insns_begin = NULL_RTX;\n+  nonscheduled_insns_begin = NULL;\n \n   gcc_assert ((NOTE_P (last_scheduled_insn)\n \t       || DEBUG_INSN_P (last_scheduled_insn))\n@@ -6075,16 +6075,16 @@ schedule_block (basic_block *target_bb, state_t init_state)\n \t activated make an exception for the insn right after\n \t nonscheduled_insns_begin.  */\n       {\n-\trtx skip_insn;\n+\trtx_insn *skip_insn;\n \n \tif (dbg_cnt (sched_insn) == false)\n \t  skip_insn = first_nonscheduled_insn ();\n \telse\n-\t  skip_insn = NULL_RTX;\n+\t  skip_insn = NULL;\n \n \twhile (i < ready.n_ready)\n \t  {\n-\t    rtx insn;\n+\t    rtx_insn *insn;\n \n \t    insn = ready_remove (&ready, i);\n \n@@ -6185,7 +6185,7 @@ schedule_block (basic_block *target_bb, state_t init_state)\n       ls.can_issue_more = issue_rate;\n       for (;;)\n \t{\n-\t  rtx insn;\n+\t  rtx_insn *insn;\n \t  int cost;\n \t  bool asm_p;\n \n@@ -6212,7 +6212,7 @@ schedule_block (basic_block *target_bb, state_t init_state)\n \t    {\n \t      while (ready.n_ready && DEBUG_INSN_P (ready_element (&ready, 0)))\n \t\t{\n-\t\t  rtx insn = ready_remove_first (&ready);\n+\t\t  rtx_insn *insn = ready_remove_first (&ready);\n \t\t  gcc_assert (DEBUG_INSN_P (insn));\n \t\t  (*current_sched_info->begin_schedule_ready) (insn);\n \t\t  scheduled_insns.safe_push (insn);\n@@ -6282,7 +6282,7 @@ schedule_block (basic_block *target_bb, state_t init_state)\n \t    {\n \t      int res;\n \n-\t      insn = NULL_RTX;\n+\t      insn = NULL;\n \t      res = choose_ready (&ready, ls.first_cycle_insn_p, &insn);\n \n \t      if (res < 0)\n@@ -6434,7 +6434,7 @@ schedule_block (basic_block *target_bb, state_t init_state)\n       while (must_backtrack)\n \t{\n \t  struct haifa_saved_data *failed;\n-\t  rtx failed_insn;\n+\t  rtx_insn *failed_insn;\n \n \t  must_backtrack = false;\n \t  failed = verify_shadows ();\n@@ -6494,7 +6494,7 @@ schedule_block (basic_block *target_bb, state_t init_state)\n \t}\n       for (i = ready.n_ready - 1; i >= 0; i--)\n \t{\n-\t  rtx x;\n+\t  rtx_insn *x;\n \n \t  x = ready_element (&ready, i);\n \t  resolve_dependencies (x);\n@@ -6504,7 +6504,7 @@ schedule_block (basic_block *target_bb, state_t init_state)\n \t  rtx link;\n \t  while ((link = insn_queue[i]) != NULL)\n \t    {\n-\t      rtx x = XEXP (link, 0);\n+\t      rtx_insn *x = as_a <rtx_insn *> (XEXP (link, 0));\n \t      insn_queue[i] = XEXP (link, 1);\n \t      QUEUE_INDEX (x) = QUEUE_NOWHERE;\n \t      free_INSN_LIST_node (link);\n@@ -6628,7 +6628,7 @@ set_priorities (rtx head, rtx tail)\n   int n_insn;\n   int sched_max_insns_priority =\n \tcurrent_sched_info->sched_max_insns_priority;\n-  rtx prev_head;\n+  rtx_insn *prev_head;\n \n   if (head == tail && ! INSN_P (head))\n     gcc_unreachable ();\n@@ -7024,7 +7024,7 @@ fix_inter_tick (rtx head, rtx tail)\n        0 - added to the ready list,\n    0 < N - queued for N cycles.  */\n int\n-try_ready (rtx next)\n+try_ready (rtx_insn *next)\n {\n   ds_t old_ts, new_ts;\n \n@@ -7156,7 +7156,7 @@ try_ready (rtx next)\n \n /* Calculate INSN_TICK of NEXT and add it to either ready or queue list.  */\n static int\n-fix_tick_ready (rtx next)\n+fix_tick_ready (rtx_insn *next)\n {\n   int tick, delay;\n \n@@ -7205,7 +7205,7 @@ fix_tick_ready (rtx next)\n    or add it to the ready list (DELAY == QUEUE_READY),\n    or remove it from ready and queue lists at all (DELAY == QUEUE_NOWHERE).  */\n static void\n-change_queue_index (rtx next, int delay)\n+change_queue_index (rtx_insn *next, int delay)\n {\n   int i = QUEUE_INDEX (next);\n \n@@ -7264,7 +7264,7 @@ sched_extend_ready_list (int new_sched_ready_n_insns)\n     i = sched_ready_n_insns + 1;\n \n   ready.veclen = new_sched_ready_n_insns + issue_rate;\n-  ready.vec = XRESIZEVEC (rtx, ready.vec, ready.veclen);\n+  ready.vec = XRESIZEVEC (rtx_insn *, ready.vec, ready.veclen);\n \n   gcc_assert (new_sched_ready_n_insns >= sched_ready_n_insns);\n \n@@ -7326,7 +7326,7 @@ haifa_luid_for_non_insn (rtx x)\n \n /* Generates recovery code for INSN.  */\n static void\n-generate_recovery_code (rtx insn)\n+generate_recovery_code (rtx_insn *insn)\n {\n   if (TODO_SPEC (insn) & BEGIN_SPEC)\n     begin_speculative_block (insn);\n@@ -7401,7 +7401,7 @@ process_insn_forw_deps_be_in_spec (rtx insn, rtx twin, ds_t fs)\n \n /* Generates recovery code for BEGIN speculative INSN.  */\n static void\n-begin_speculative_block (rtx insn)\n+begin_speculative_block (rtx_insn *insn)\n {\n   if (TODO_SPEC (insn) & BEGIN_DATA)\n     nr_begin_data++;\n@@ -7785,10 +7785,11 @@ sched_create_recovery_edges (basic_block first_bb, basic_block rec,\n /* This function creates recovery code for INSN.  If MUTATE_P is nonzero,\n    INSN is a simple check, that should be converted to branchy one.  */\n static void\n-create_check_block_twin (rtx insn, bool mutate_p)\n+create_check_block_twin (rtx_insn *insn, bool mutate_p)\n {\n   basic_block rec;\n-  rtx label, check, twin;\n+  rtx_insn *label, *check, *twin;\n+  rtx check_pat;\n   ds_t fs;\n   sd_iterator_def sd_it;\n   dep_t dep;\n@@ -7818,24 +7819,24 @@ create_check_block_twin (rtx insn, bool mutate_p)\n   else\n     {\n       rec = EXIT_BLOCK_PTR_FOR_FN (cfun);\n-      label = NULL_RTX;\n+      label = NULL;\n     }\n \n   /* Emit CHECK.  */\n-  check = targetm.sched.gen_spec_check (insn, label, todo_spec);\n+  check_pat = targetm.sched.gen_spec_check (insn, label, todo_spec);\n \n   if (rec != EXIT_BLOCK_PTR_FOR_FN (cfun))\n     {\n       /* To have mem_reg alive at the beginning of second_bb,\n \t we emit check BEFORE insn, so insn after splitting\n \t insn will be at the beginning of second_bb, which will\n \t provide us with the correct life information.  */\n-      check = emit_jump_insn_before (check, insn);\n+      check = emit_jump_insn_before (check_pat, insn);\n       JUMP_LABEL (check) = label;\n       LABEL_NUSES (label)++;\n     }\n   else\n-    check = emit_insn_before (check, insn);\n+    check = emit_insn_before (check_pat, insn);\n \n   /* Extend data structures.  */\n   haifa_init_insn (check);\n@@ -8109,7 +8110,7 @@ fix_recovery_deps (basic_block rec)\n \n   /* Try to add instructions to the ready or queue list.  */\n   for (link = ready_list; link; link = XEXP (link, 1))\n-    try_ready (XEXP (link, 0));\n+    try_ready (as_a <rtx_insn *> (XEXP (link, 0)));\n   free_INSN_LIST_list (&ready_list);\n \n   /* Fixing jump's dependences.  */\n@@ -8369,7 +8370,7 @@ move_succs (vec<edge, va_gc> **succsp, basic_block to)\n /* Remove INSN from the instruction stream.\n    INSN should have any dependencies.  */\n static void\n-sched_remove_insn (rtx insn)\n+sched_remove_insn (rtx_insn *insn)\n {\n   sd_finish_insn (insn);\n \n@@ -8647,10 +8648,10 @@ sched_create_empty_bb_1 (basic_block after)\n \n /* Insert PAT as an INSN into the schedule and update the necessary data\n    structures to account for it. */\n-rtx\n+rtx_insn *\n sched_emit_insn (rtx pat)\n {\n-  rtx insn = emit_insn_before (pat, first_nonscheduled_insn ());\n+  rtx_insn *insn = emit_insn_before (pat, first_nonscheduled_insn ());\n   haifa_init_insn (insn);\n \n   if (current_sched_info->add_remove_insn)\n@@ -8666,11 +8667,11 @@ sched_emit_insn (rtx pat)\n /* This function returns a candidate satisfying dispatch constraints from\n    the ready list.  */\n \n-static rtx\n+static rtx_insn *\n ready_remove_first_dispatch (struct ready_list *ready)\n {\n   int i;\n-  rtx insn = ready_element (ready, 0);\n+  rtx_insn *insn = ready_element (ready, 0);\n \n   if (ready->n_ready == 1\n       || !INSN_P (insn)"}, {"sha": "73621561f3817ffdb75e90a99931fbadb19f75bd", "filename": "gcc/hw-doloop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce1ce33a037057b77a99ed0613f4369546dc82cd/gcc%2Fhw-doloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce1ce33a037057b77a99ed0613f4369546dc82cd/gcc%2Fhw-doloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhw-doloop.c?ref=ce1ce33a037057b77a99ed0613f4369546dc82cd", "patch": "@@ -242,7 +242,7 @@ discover_loop (hwloop_info loop, basic_block tail_bb, rtx_insn *tail_insn, rtx r\n   loop->loop_end = tail_insn;\n   loop->iter_reg = reg;\n   vec_alloc (loop->incoming, 2);\n-  loop->start_label = JUMP_LABEL (tail_insn);\n+  loop->start_label = as_a <rtx_insn *> (JUMP_LABEL (tail_insn));\n \n   if (EDGE_COUNT (tail_bb->succs) != 2)\n     {"}, {"sha": "fc211ffd2d1ade862e318b13b957dae4e3fdf871", "filename": "gcc/modulo-sched.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce1ce33a037057b77a99ed0613f4369546dc82cd/gcc%2Fmodulo-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce1ce33a037057b77a99ed0613f4369546dc82cd/gcc%2Fmodulo-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmodulo-sched.c?ref=ce1ce33a037057b77a99ed0613f4369546dc82cd", "patch": "@@ -251,7 +251,7 @@ typedef struct node_sched_params node_sched_params;\n    code in order to use sched_analyze() for computing the dependencies.\n    They are used when initializing the sched_info structure.  */\n static const char *\n-sms_print_insn (const_rtx insn, int aligned ATTRIBUTE_UNUSED)\n+sms_print_insn (const rtx_insn *insn, int aligned ATTRIBUTE_UNUSED)\n {\n   static char tmp[80];\n "}, {"sha": "e86fa40d654454efbdbf8e5d0b595ef6a104065a", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 44, "deletions": 40, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce1ce33a037057b77a99ed0613f4369546dc82cd/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce1ce33a037057b77a99ed0613f4369546dc82cd/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=ce1ce33a037057b77a99ed0613f4369546dc82cd", "patch": "@@ -482,17 +482,17 @@ static int cache_size;\n static bool mark_as_hard;\n \n static int deps_may_trap_p (const_rtx);\n-static void add_dependence_1 (rtx, rtx, enum reg_note);\n-static void add_dependence_list (rtx, rtx, int, enum reg_note, bool);\n-static void add_dependence_list_and_free (struct deps_desc *, rtx,\n+static void add_dependence_1 (rtx_insn *, rtx_insn *, enum reg_note);\n+static void add_dependence_list (rtx_insn *, rtx, int, enum reg_note, bool);\n+static void add_dependence_list_and_free (struct deps_desc *, rtx_insn *,\n \t\t\t\t\t  rtx *, int, enum reg_note, bool);\n static void delete_all_dependences (rtx);\n-static void chain_to_prev_insn (rtx);\n+static void chain_to_prev_insn (rtx_insn *);\n \n-static void flush_pending_lists (struct deps_desc *, rtx, int, int);\n-static void sched_analyze_1 (struct deps_desc *, rtx, rtx);\n-static void sched_analyze_2 (struct deps_desc *, rtx, rtx);\n-static void sched_analyze_insn (struct deps_desc *, rtx, rtx);\n+static void flush_pending_lists (struct deps_desc *, rtx_insn *, int, int);\n+static void sched_analyze_1 (struct deps_desc *, rtx, rtx_insn *);\n+static void sched_analyze_2 (struct deps_desc *, rtx, rtx_insn *);\n+static void sched_analyze_insn (struct deps_desc *, rtx, rtx_insn *);\n \n static bool sched_has_condition_p (const_rtx);\n static int conditions_mutex_p (const_rtx, const_rtx, bool, bool);\n@@ -1513,7 +1513,7 @@ sd_debug_lists (rtx insn, sd_list_types_def types)\n    impossible; otherwise we add additional true dependencies on the\n    INSN_COND_DEPS list of the jump (which PRO must be).  */\n void\n-add_dependence (rtx con, rtx pro, enum reg_note dep_type)\n+add_dependence (rtx_insn *con, rtx_insn *pro, enum reg_note dep_type)\n {\n   if (dep_type == REG_DEP_CONTROL\n       && !(current_sched_info->flags & DO_PREDICATION))\n@@ -1561,14 +1561,14 @@ add_dependence (rtx con, rtx pro, enum reg_note dep_type)\n    true if DEP_NONREG should be set on newly created dependencies.  */\n \n static void\n-add_dependence_list (rtx insn, rtx list, int uncond, enum reg_note dep_type,\n+add_dependence_list (rtx_insn *insn, rtx list, int uncond, enum reg_note dep_type,\n \t\t     bool hard)\n {\n   mark_as_hard = hard;\n   for (; list; list = XEXP (list, 1))\n     {\n       if (uncond || ! sched_insns_conditions_mutex_p (insn, XEXP (list, 0)))\n-\tadd_dependence (insn, XEXP (list, 0), dep_type);\n+\tadd_dependence (insn, as_a <rtx_insn *> (XEXP (list, 0)), dep_type);\n     }\n   mark_as_hard = false;\n }\n@@ -1578,7 +1578,7 @@ add_dependence_list (rtx insn, rtx list, int uncond, enum reg_note dep_type,\n    newly created dependencies.  */\n \n static void\n-add_dependence_list_and_free (struct deps_desc *deps, rtx insn, rtx *listp,\n+add_dependence_list_and_free (struct deps_desc *deps, rtx_insn *insn, rtx *listp,\n                               int uncond, enum reg_note dep_type, bool hard)\n {\n   add_dependence_list (insn, *listp, uncond, dep_type, hard);\n@@ -1661,15 +1661,15 @@ delete_all_dependences (rtx insn)\n    the previous nonnote insn.  */\n \n static void\n-chain_to_prev_insn (rtx insn)\n+chain_to_prev_insn (rtx_insn *insn)\n {\n   sd_iterator_def sd_it;\n   dep_t dep;\n-  rtx prev_nonnote;\n+  rtx_insn *prev_nonnote;\n \n   FOR_EACH_DEP (insn, SD_LIST_BACK, sd_it, dep)\n     {\n-      rtx i = insn;\n+      rtx_insn *i = insn;\n       rtx_insn *pro = DEP_PRO (dep);\n \n       do\n@@ -1749,7 +1749,7 @@ add_insn_mem_dependence (struct deps_desc *deps, bool read_p,\n    dependencies for a read operation, similarly with FOR_WRITE.  */\n \n static void\n-flush_pending_lists (struct deps_desc *deps, rtx insn, int for_read,\n+flush_pending_lists (struct deps_desc *deps, rtx_insn *insn, int for_read,\n \t\t     int for_write)\n {\n   if (for_write)\n@@ -1796,7 +1796,7 @@ flush_pending_lists (struct deps_desc *deps, rtx insn, int for_read,\n }\n \f\n /* Instruction which dependencies we are analyzing.  */\n-static rtx cur_insn = NULL_RTX;\n+static rtx_insn *cur_insn = NULL;\n \n /* Implement hooks for haifa scheduler.  */\n \n@@ -1805,7 +1805,7 @@ haifa_start_insn (rtx insn)\n {\n   gcc_assert (insn && !cur_insn);\n \n-  cur_insn = insn;\n+  cur_insn = as_a <rtx_insn *> (insn);\n }\n \n static void\n@@ -1895,7 +1895,7 @@ note_mem_dep (rtx m1, rtx m2, rtx e, ds_t ds)\n }\n \n static void\n-note_dep (rtx e, ds_t ds)\n+note_dep (rtx_insn *e, ds_t ds)\n {\n   if (sched_deps_info->note_dep)\n     sched_deps_info->note_dep (e, ds);\n@@ -2298,7 +2298,7 @@ maybe_extend_reg_info_p (void)\n \n static void\n sched_analyze_reg (struct deps_desc *deps, int regno, enum machine_mode mode,\n-\t\t   enum rtx_code ref, rtx insn)\n+\t\t   enum rtx_code ref, rtx_insn *insn)\n {\n   /* We could emit new pseudos in renaming.  Extend the reg structures.  */\n   if (!reload_completed && sel_sched_p ()\n@@ -2376,7 +2376,7 @@ sched_analyze_reg (struct deps_desc *deps, int regno, enum machine_mode mode,\n    destination of X, and reads of everything mentioned.  */\n \n static void\n-sched_analyze_1 (struct deps_desc *deps, rtx x, rtx insn)\n+sched_analyze_1 (struct deps_desc *deps, rtx x, rtx_insn *insn)\n {\n   rtx dest = XEXP (x, 0);\n   enum rtx_code code = GET_CODE (x);\n@@ -2548,7 +2548,7 @@ sched_analyze_1 (struct deps_desc *deps, rtx x, rtx insn)\n \n /* Analyze the uses of memory and registers in rtx X in INSN.  */\n static void\n-sched_analyze_2 (struct deps_desc *deps, rtx x, rtx insn)\n+sched_analyze_2 (struct deps_desc *deps, rtx x, rtx_insn *insn)\n {\n   int i;\n   int j;\n@@ -2669,7 +2669,8 @@ sched_analyze_2 (struct deps_desc *deps, rtx x, rtx insn)\n \t      }\n \n \t    for (u = deps->last_pending_memory_flush; u; u = XEXP (u, 1))\n-\t      add_dependence (insn, XEXP (u, 0), REG_DEP_ANTI);\n+\t      add_dependence (insn, as_a <rtx_insn *> (XEXP (u, 0)),\n+\t\t\t      REG_DEP_ANTI);\n \n \t    for (u = deps->pending_jump_insns; u; u = XEXP (u, 1))\n \t      if (deps_may_trap_p (x))\n@@ -2680,10 +2681,11 @@ sched_analyze_2 (struct deps_desc *deps, rtx x, rtx insn)\n \t\t      ds_t ds = set_dep_weak (DEP_ANTI, BEGIN_CONTROL,\n \t\t\t\t\t      MAX_DEP_WEAK);\n \t\t      \n-\t\t      note_dep (XEXP (u, 0), ds);\n+\t\t      note_dep (as_a <rtx_insn *> (XEXP (u, 0)), ds);\n \t\t    }\n \t\t  else\n-\t\t    add_dependence (insn, XEXP (u, 0), REG_DEP_CONTROL);\n+\t\t    add_dependence (insn, as_a <rtx_insn *> (XEXP (u, 0)),\n+\t\t\t\t    REG_DEP_CONTROL);\n \t\t}\n \t  }\n \n@@ -2861,7 +2863,7 @@ sched_macro_fuse_insns (rtx insn)\n \n /* Analyze an INSN with pattern X to find all dependencies.  */\n static void\n-sched_analyze_insn (struct deps_desc *deps, rtx x, rtx insn)\n+sched_analyze_insn (struct deps_desc *deps, rtx x, rtx_insn *insn)\n {\n   RTX_CODE code = GET_CODE (x);\n   rtx link;\n@@ -3009,7 +3011,8 @@ sched_analyze_insn (struct deps_desc *deps, rtx x, rtx insn)\n \t  while (pending)\n \t    {\n \t      if (! sched_insns_conditions_mutex_p (insn, XEXP (pending, 0)))\n-\t\tadd_dependence (insn, XEXP (pending, 0), REG_DEP_OUTPUT);\n+\t\tadd_dependence (insn, as_a <rtx_insn *> (XEXP (pending, 0)),\n+\t\t\t\tREG_DEP_OUTPUT);\n \t      pending = XEXP (pending, 1);\n \t      pending_mem = XEXP (pending_mem, 1);\n \t    }\n@@ -3020,7 +3023,8 @@ sched_analyze_insn (struct deps_desc *deps, rtx x, rtx insn)\n \t    {\n \t      if (MEM_VOLATILE_P (XEXP (pending_mem, 0))\n \t\t  && ! sched_insns_conditions_mutex_p (insn, XEXP (pending, 0)))\n-\t\tadd_dependence (insn, XEXP (pending, 0), REG_DEP_OUTPUT);\n+\t\tadd_dependence (insn, as_a <rtx_insn *> (XEXP (pending, 0)),\n+\t\t\t\tREG_DEP_OUTPUT);\n \t      pending = XEXP (pending, 1);\n \t      pending_mem = XEXP (pending_mem, 1);\n \t    }\n@@ -3051,7 +3055,7 @@ sched_analyze_insn (struct deps_desc *deps, rtx x, rtx insn)\n   /* Add register dependencies for insn.  */\n   if (DEBUG_INSN_P (insn))\n     {\n-      rtx prev = deps->last_debug_insn;\n+      rtx_insn *prev = deps->last_debug_insn;\n       rtx u;\n \n       if (!deps->readonly)\n@@ -3065,7 +3069,7 @@ sched_analyze_insn (struct deps_desc *deps, rtx x, rtx insn)\n \n       if (!sel_sched_p ())\n \tfor (u = deps->last_pending_memory_flush; u; u = XEXP (u, 1))\n-\t  add_dependence (insn, XEXP (u, 0), REG_DEP_ANTI);\n+\t  add_dependence (insn, as_a <rtx_insn *> (XEXP (u, 0)), REG_DEP_ANTI);\n \n       EXECUTE_IF_SET_IN_REG_SET (reg_pending_uses, 0, i, rsi)\n \t{\n@@ -3585,7 +3589,7 @@ chain_to_prev_insn_p (rtx insn)\n \n /* Analyze INSN with DEPS as a context.  */\n void\n-deps_analyze_insn (struct deps_desc *deps, rtx insn)\n+deps_analyze_insn (struct deps_desc *deps, rtx_insn *insn)\n {\n   if (sched_deps_info->start_insn)\n     sched_deps_info->start_insn (insn);\n@@ -3770,9 +3774,9 @@ deps_start_bb (struct deps_desc *deps, rtx head)\n /* Analyze every insn between HEAD and TAIL inclusive, creating backward\n    dependencies for each insn.  */\n void\n-sched_analyze (struct deps_desc *deps, rtx head, rtx tail)\n+sched_analyze (struct deps_desc *deps, rtx_insn *head, rtx_insn *tail)\n {\n-  rtx insn;\n+  rtx_insn *insn;\n \n   if (sched_deps_info->use_cselib)\n     cselib_init (CSELIB_RECORD_MEMORY);\n@@ -4204,7 +4208,7 @@ estimate_dep_weak (rtx mem1, rtx mem2)\n    This function can handle same INSN and ELEM (INSN == ELEM).\n    It is a convenience wrapper.  */\n static void\n-add_dependence_1 (rtx insn, rtx elem, enum reg_note dep_type)\n+add_dependence_1 (rtx_insn *insn, rtx_insn *elem, enum reg_note dep_type)\n {\n   ds_t ds;\n   bool internal;\n@@ -4601,8 +4605,8 @@ check_dep (dep_t dep, bool relaxed_p)\n    insns which depend on each other, but could possibly be interchanged.  */\n struct mem_inc_info\n {\n-  rtx inc_insn;\n-  rtx mem_insn;\n+  rtx_insn *inc_insn;\n+  rtx_insn *mem_insn;\n \n   rtx *mem_loc;\n   /* A register occurring in the memory address for which we wish to break\n@@ -4657,7 +4661,7 @@ attempt_change (struct mem_inc_info *mii, rtx new_addr)\n    a corresponding memory reference.  */\n \n static bool\n-parse_add_or_inc (struct mem_inc_info *mii, rtx insn, bool before_mem)\n+parse_add_or_inc (struct mem_inc_info *mii, rtx_insn *insn, bool before_mem)\n {\n   rtx pat = single_set (insn);\n   rtx src, cst;\n@@ -4727,7 +4731,7 @@ find_inc (struct mem_inc_info *mii, bool backwards)\n       dep_node_t node = DEP_LINK_NODE (*sd_it.linkp);\n       rtx_insn *pro = DEP_PRO (dep);\n       rtx_insn *con = DEP_CON (dep);\n-      rtx inc_cand = backwards ? pro : con;\n+      rtx_insn *inc_cand = backwards ? pro : con;\n       if (DEP_NONREG (dep) || DEP_MULTIPLE (dep))\n \tgoto next;\n       if (parse_add_or_inc (mii, inc_cand, backwards))\n@@ -4894,9 +4898,9 @@ find_mem (struct mem_inc_info *mii, rtx *address_of_x)\n    dependencies that can be broken by modifying one of the patterns.  */\n \n void\n-find_modifiable_mems (rtx head, rtx tail)\n+find_modifiable_mems (rtx_insn *head, rtx_insn *tail)\n {\n-  rtx insn, next_tail = NEXT_INSN (tail);\n+  rtx_insn *insn, *next_tail = NEXT_INSN (tail);\n   int success_in_block = 0;\n \n   for (insn = head; insn != next_tail; insn = NEXT_INSN (insn))"}, {"sha": "621fddb69b4eeb403ff12a441b8c5f8d91547bc2", "filename": "gcc/sched-ebb.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce1ce33a037057b77a99ed0613f4369546dc82cd/gcc%2Fsched-ebb.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce1ce33a037057b77a99ed0613f4369546dc82cd/gcc%2Fsched-ebb.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-ebb.c?ref=ce1ce33a037057b77a99ed0613f4369546dc82cd", "patch": "@@ -55,18 +55,18 @@ static basic_block last_bb;\n \n /* Implementations of the sched_info functions for region scheduling.  */\n static void init_ready_list (void);\n-static void begin_schedule_ready (rtx);\n+static void begin_schedule_ready (rtx_insn *);\n static int schedule_more_p (void);\n-static const char *ebb_print_insn (const_rtx, int);\n-static int rank (rtx, rtx);\n-static int ebb_contributes_to_priority (rtx, rtx);\n+static const char *ebb_print_insn (const rtx_insn *, int);\n+static int rank (rtx_insn *, rtx_insn *);\n+static int ebb_contributes_to_priority (rtx_insn *, rtx_insn *);\n static basic_block earliest_block_with_similiar_load (basic_block, rtx);\n static void add_deps_for_risky_insns (rtx_insn *, rtx_insn *);\n static void debug_ebb_dependencies (rtx, rtx);\n \n-static void ebb_add_remove_insn (rtx, int);\n+static void ebb_add_remove_insn (rtx_insn *, int);\n static void ebb_add_block (basic_block, basic_block);\n-static basic_block advance_target_bb (basic_block, rtx);\n+static basic_block advance_target_bb (basic_block, rtx_insn *);\n static void ebb_fix_recovery_cfg (int, int, int);\n \n /* Allocate memory and store the state of the frontend.  Return the allocated\n@@ -118,7 +118,7 @@ init_ready_list (void)\n   int n = 0;\n   rtx prev_head = current_sched_info->prev_head;\n   rtx next_tail = current_sched_info->next_tail;\n-  rtx insn;\n+  rtx_insn *insn;\n \n   sched_rgn_n_insns = 0;\n \n@@ -139,14 +139,14 @@ init_ready_list (void)\n \n /* INSN is being scheduled after LAST.  Update counters.  */\n static void\n-begin_schedule_ready (rtx insn ATTRIBUTE_UNUSED)\n+begin_schedule_ready (rtx_insn *insn ATTRIBUTE_UNUSED)\n {\n   sched_rgn_n_insns++;\n }\n \n /* INSN is being moved to its place in the schedule, after LAST.  */\n static void\n-begin_move_insn (rtx insn, rtx last)\n+begin_move_insn (rtx_insn *insn, rtx_insn *last)\n {\n   if (BLOCK_FOR_INSN (insn) == last_bb\n       /* INSN is a jump in the last block, ...  */\n@@ -214,7 +214,7 @@ begin_move_insn (rtx insn, rtx last)\n    to be formatted so that multiple output lines will line up nicely.  */\n \n static const char *\n-ebb_print_insn (const_rtx insn, int aligned ATTRIBUTE_UNUSED)\n+ebb_print_insn (const rtx_insn *insn, int aligned ATTRIBUTE_UNUSED)\n {\n   static char tmp[80];\n \n@@ -232,7 +232,7 @@ ebb_print_insn (const_rtx insn, int aligned ATTRIBUTE_UNUSED)\n    is to be preferred.  Zero if they are equally good.  */\n \n static int\n-rank (rtx insn1, rtx insn2)\n+rank (rtx_insn *insn1, rtx_insn *insn2)\n {\n   basic_block bb1 = BLOCK_FOR_INSN (insn1);\n   basic_block bb2 = BLOCK_FOR_INSN (insn2);\n@@ -251,8 +251,8 @@ rank (rtx insn1, rtx insn2)\n    calculations.  */\n \n static int\n-ebb_contributes_to_priority (rtx next ATTRIBUTE_UNUSED,\n-                             rtx insn ATTRIBUTE_UNUSED)\n+ebb_contributes_to_priority (rtx_insn *next ATTRIBUTE_UNUSED,\n+                             rtx_insn *insn ATTRIBUTE_UNUSED)\n {\n   return 1;\n }\n@@ -668,7 +668,7 @@ schedule_ebbs (void)\n \n /* INSN has been added to/removed from current ebb.  */\n static void\n-ebb_add_remove_insn (rtx insn ATTRIBUTE_UNUSED, int remove_p)\n+ebb_add_remove_insn (rtx_insn *insn ATTRIBUTE_UNUSED, int remove_p)\n {\n   if (!remove_p)\n     rgn_n_insns++;\n@@ -692,7 +692,7 @@ ebb_add_block (basic_block bb, basic_block after)\n /* Return next block in ebb chain.  For parameter meaning please refer to\n    sched-int.h: struct sched_info: advance_target_bb.  */\n static basic_block\n-advance_target_bb (basic_block bb, rtx insn)\n+advance_target_bb (basic_block bb, rtx_insn *insn)\n {\n   if (insn)\n     {"}, {"sha": "2e527221ac0b8f0a34bfd7b3d7716f256df10385", "filename": "gcc/sched-int.h", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce1ce33a037057b77a99ed0613f4369546dc82cd/gcc%2Fsched-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce1ce33a037057b77a99ed0613f4369546dc82cd/gcc%2Fsched-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-int.h?ref=ce1ce33a037057b77a99ed0613f4369546dc82cd", "patch": "@@ -125,10 +125,10 @@ extern int insn_luid (rtx);\n /* This list holds ripped off notes from the current block.  These notes will\n    be attached to the beginning of the block when its scheduling is\n    finished.  */\n-extern rtx note_list;\n+extern rtx_insn *note_list;\n \n-extern void remove_notes (rtx, rtx);\n-extern rtx restore_other_notes (rtx, basic_block);\n+extern void remove_notes (rtx_insn *, rtx_insn *);\n+extern rtx_insn *restore_other_notes (rtx_insn *, basic_block);\n extern void sched_insns_init (rtx);\n extern void sched_insns_finish (void);\n \n@@ -163,7 +163,7 @@ extern bool sel_insn_is_speculation_check (rtx);\n    N_DEBUG determines how many debug insns are on the ready list.  */\n struct ready_list\n {\n-  rtx *vec;\n+  rtx_insn **vec;\n   int veclen;\n   int first;\n   int n_ready;\n@@ -211,7 +211,7 @@ struct dep_replacement\n   rtx *loc;\n   rtx orig;\n   rtx newval;\n-  rtx insn;\n+  rtx_insn *insn;\n };\n \n /* Information about the dependency.  */\n@@ -539,10 +539,10 @@ struct deps_desc\n   enum post_call_group in_post_call_group_p;\n \n   /* The last debug insn we've seen.  */\n-  rtx last_debug_insn;\n+  rtx_insn *last_debug_insn;\n \n   /* The last insn bearing REG_ARGS_SIZE that we've seen.  */\n-  rtx last_args_size;\n+  rtx_insn *last_args_size;\n \n   /* The maximum register number for the following arrays.  Before reload\n      this is max_reg_num; after reload it is FIRST_PSEUDO_REGISTER.  */\n@@ -580,38 +580,38 @@ struct haifa_sched_info\n   void (*init_ready_list) (void);\n   /* Called after taking an insn from the ready list.  Returns nonzero if\n      this insn can be scheduled, nonzero if we should silently discard it.  */\n-  int (*can_schedule_ready_p) (rtx);\n+  int (*can_schedule_ready_p) (rtx_insn *);\n   /* Return nonzero if there are more insns that should be scheduled.  */\n   int (*schedule_more_p) (void);\n   /* Called after an insn has all its hard dependencies resolved.\n      Adjusts status of instruction (which is passed through second parameter)\n      to indicate if instruction should be moved to the ready list or the\n      queue, or if it should silently discard it (until next resolved\n      dependence).  */\n-  ds_t (*new_ready) (rtx, ds_t);\n+  ds_t (*new_ready) (rtx_insn *, ds_t);\n   /* Compare priority of two insns.  Return a positive number if the second\n      insn is to be preferred for scheduling, and a negative one if the first\n      is to be preferred.  Zero if they are equally good.  */\n-  int (*rank) (rtx, rtx);\n+  int (*rank) (rtx_insn *, rtx_insn *);\n   /* Return a string that contains the insn uid and optionally anything else\n      necessary to identify this insn in an output.  It's valid to use a\n      static buffer for this.  The ALIGNED parameter should cause the string\n      to be formatted so that multiple output lines will line up nicely.  */\n-  const char *(*print_insn) (const_rtx, int);\n+  const char *(*print_insn) (const rtx_insn *, int);\n   /* Return nonzero if an insn should be included in priority\n      calculations.  */\n-  int (*contributes_to_priority) (rtx, rtx);\n+  int (*contributes_to_priority) (rtx_insn *, rtx_insn *);\n \n   /* Return true if scheduling insn (passed as the parameter) will trigger\n      finish of scheduling current block.  */\n-  bool (*insn_finishes_block_p) (rtx);\n+  bool (*insn_finishes_block_p) (rtx_insn *);\n \n   /* The boundaries of the set of insns to be scheduled.  */\n   rtx_insn *prev_head, *next_tail;\n \n   /* Filled in after the schedule is finished; the first and last scheduled\n      insns.  */\n-  rtx head, tail;\n+  rtx_insn *head, *tail;\n \n   /* If nonzero, enables an additional sanity check in schedule_block.  */\n   unsigned int queue_must_finish_empty:1;\n@@ -623,23 +623,23 @@ struct haifa_sched_info\n \n   /* Called to notify frontend that instruction is being added (second\n      parameter == 0) or removed (second parameter == 1).  */\n-  void (*add_remove_insn) (rtx, int);\n+  void (*add_remove_insn) (rtx_insn *, int);\n \n   /* Called to notify the frontend that instruction INSN is being\n      scheduled.  */\n-  void (*begin_schedule_ready) (rtx insn);\n+  void (*begin_schedule_ready) (rtx_insn *insn);\n \n   /* Called to notify the frontend that an instruction INSN is about to be\n      moved to its correct place in the final schedule.  This is done for all\n      insns in order of the schedule.  LAST indicates the last scheduled\n      instruction.  */\n-  void (*begin_move_insn) (rtx insn, rtx last);\n+  void (*begin_move_insn) (rtx_insn *insn, rtx_insn *last);\n \n   /* If the second parameter is not NULL, return nonnull value, if the\n      basic block should be advanced.\n      If the second parameter is NULL, return the next basic block in EBB.\n      The first parameter is the current basic block in EBB.  */\n-  basic_block (*advance_target_bb) (basic_block, rtx);\n+  basic_block (*advance_target_bb) (basic_block, rtx_insn *);\n \n   /* Allocate memory, store the frontend scheduler state in it, and\n      return it.  */\n@@ -1272,7 +1272,7 @@ struct sched_deps_info_def\n   void (*note_mem_dep) (rtx mem1, rtx mem2, rtx insn2, ds_t ds);\n \n   /* Note a dependence of type DS from the INSN.  */\n-  void (*note_dep) (rtx insn, ds_t ds);\n+  void (*note_dep) (rtx, ds_t ds);\n \n   /* Nonzero if we should use cselib for better alias analysis.  This\n      must be 0 if the dependency information is used after sched_analyze\n@@ -1296,14 +1296,14 @@ extern struct sched_deps_info_def *sched_deps_info;\n extern rtx sched_get_reverse_condition_uncached (const_rtx);\n extern bool sched_insns_conditions_mutex_p (const_rtx, const_rtx);\n extern bool sched_insn_is_legitimate_for_speculation_p (const_rtx, ds_t);\n-extern void add_dependence (rtx, rtx, enum reg_note);\n-extern void sched_analyze (struct deps_desc *, rtx, rtx);\n+extern void add_dependence (rtx_insn *, rtx_insn *, enum reg_note);\n+extern void sched_analyze (struct deps_desc *, rtx_insn *, rtx_insn *);\n extern void init_deps (struct deps_desc *, bool);\n extern void init_deps_reg_last (struct deps_desc *);\n extern void free_deps (struct deps_desc *);\n extern void init_deps_global (void);\n extern void finish_deps_global (void);\n-extern void deps_analyze_insn (struct deps_desc *, rtx);\n+extern void deps_analyze_insn (struct deps_desc *, rtx_insn *);\n extern void remove_from_deps (struct deps_desc *, rtx);\n extern void init_insn_reg_pressure_info (rtx);\n \n@@ -1359,10 +1359,10 @@ extern int issue_rate;\n extern int dfa_lookahead;\n \n extern void ready_sort (struct ready_list *);\n-extern rtx ready_element (struct ready_list *, int);\n-extern rtx *ready_lastpos (struct ready_list *);\n+extern rtx_insn *ready_element (struct ready_list *, int);\n+extern rtx_insn **ready_lastpos (struct ready_list *);\n \n-extern int try_ready (rtx);\n+extern int try_ready (rtx_insn *);\n extern void sched_extend_ready_list (int);\n extern void sched_finish_ready_list (void);\n extern void sched_change_pattern (rtx, rtx);\n@@ -1371,7 +1371,7 @@ extern void unlink_bb_notes (basic_block, basic_block);\n extern void add_block (basic_block, basic_block);\n extern rtx_note *bb_note (basic_block);\n extern void concat_note_lists (rtx, rtx *);\n-extern rtx sched_emit_insn (rtx);\n+extern rtx_insn *sched_emit_insn (rtx);\n extern rtx get_ready_element (int);\n extern int number_in_ready (void);\n \f\n@@ -1431,11 +1431,11 @@ extern int target_bb;\n extern bool sched_no_dce;\n \n extern void set_modulo_params (int, int, int, int);\n-extern void record_delay_slot_pair (rtx, rtx, int, int);\n+extern void record_delay_slot_pair (rtx_insn *, rtx_insn *, int, int);\n extern rtx real_insn_for_shadow (rtx);\n extern void discard_delay_pairs_above (int);\n extern void free_delay_pairs (void);\n-extern void add_delay_dependencies (rtx);\n+extern void add_delay_dependencies (rtx_insn *);\n extern bool sched_is_disabled_for_current_region_p (void);\n extern void sched_rgn_init (bool);\n extern void sched_rgn_finish (void);\n@@ -1452,7 +1452,7 @@ extern void increase_insn_priority (rtx, int);\n extern void debug_rgn_dependencies (int);\n extern void debug_dependencies (rtx, rtx);\n extern void free_rgn_deps (void);\n-extern int contributes_to_priority (rtx, rtx);\n+extern int contributes_to_priority (rtx_insn *, rtx_insn *);\n extern void extend_rgns (int *, int *, sbitmap, int *);\n extern void deps_join (struct deps_desc *, struct deps_desc *);\n \n@@ -1467,7 +1467,7 @@ extern void dump_region_dot_file (const char *, int);\n extern void haifa_sched_init (void);\n extern void haifa_sched_finish (void);\n \n-extern void find_modifiable_mems (rtx, rtx);\n+extern void find_modifiable_mems (rtx_insn *, rtx_insn *);\n \n /* sched-deps.c interface to walk, add, search, update, resolve, delete\n    and debug instruction dependencies.  */"}, {"sha": "f346816ef92d73f0382a11bc1a50b634cac7186c", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce1ce33a037057b77a99ed0613f4369546dc82cd/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce1ce33a037057b77a99ed0613f4369546dc82cd/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=ce1ce33a037057b77a99ed0613f4369546dc82cd", "patch": "@@ -236,7 +236,7 @@ static int is_exception_free (rtx, int, int);\n \n static bool sets_likely_spilled (rtx);\n static void sets_likely_spilled_1 (rtx, const_rtx, void *);\n-static void add_branch_dependences (rtx, rtx);\n+static void add_branch_dependences (rtx_insn *, rtx_insn *);\n static void compute_block_dependences (int);\n \n static void schedule_region (int);\n@@ -540,7 +540,7 @@ rgn_estimate_number_of_insns (basic_block bb)\n \n   if (MAY_HAVE_DEBUG_INSNS)\n     {\n-      rtx insn;\n+      rtx_insn *insn;\n \n       FOR_BB_INSNS (bb, insn)\n \tif (DEBUG_INSN_P (insn))\n@@ -1804,7 +1804,7 @@ update_live_1 (int src, rtx x)\n    ready-list or before the scheduling.  */\n \n static int\n-check_live (rtx insn, int src)\n+check_live (rtx_insn *insn, int src)\n {\n   /* Find the registers set by instruction.  */\n   if (GET_CODE (PATTERN (insn)) == SET\n@@ -2078,19 +2078,19 @@ static int sched_n_insns;\n \n /* Implementations of the sched_info functions for region scheduling.  */\n static void init_ready_list (void);\n-static int can_schedule_ready_p (rtx);\n-static void begin_schedule_ready (rtx);\n-static ds_t new_ready (rtx, ds_t);\n+static int can_schedule_ready_p (rtx_insn *);\n+static void begin_schedule_ready (rtx_insn *);\n+static ds_t new_ready (rtx_insn *, ds_t);\n static int schedule_more_p (void);\n-static const char *rgn_print_insn (const_rtx, int);\n-static int rgn_rank (rtx, rtx);\n+static const char *rgn_print_insn (const rtx_insn *, int);\n+static int rgn_rank (rtx_insn *, rtx_insn *);\n static void compute_jump_reg_dependencies (rtx, regset);\n \n /* Functions for speculative scheduling.  */\n-static void rgn_add_remove_insn (rtx, int);\n+static void rgn_add_remove_insn (rtx_insn *, int);\n static void rgn_add_block (basic_block, basic_block);\n static void rgn_fix_recovery_cfg (int, int, int);\n-static basic_block advance_target_bb (basic_block, rtx);\n+static basic_block advance_target_bb (basic_block, rtx_insn *);\n \n /* Return nonzero if there are more insns that should be scheduled.  */\n \n@@ -2109,7 +2109,7 @@ init_ready_list (void)\n   rtx prev_head = current_sched_info->prev_head;\n   rtx next_tail = current_sched_info->next_tail;\n   int bb_src;\n-  rtx insn;\n+  rtx_insn *insn;\n \n   target_n_insns = 0;\n   sched_target_n_insns = 0;\n@@ -2164,7 +2164,7 @@ init_ready_list (void)\n    insn can be scheduled, nonzero if we should silently discard it.  */\n \n static int\n-can_schedule_ready_p (rtx insn)\n+can_schedule_ready_p (rtx_insn *insn)\n {\n   /* An interblock motion?  */\n   if (INSN_BB (insn) != target_bb\n@@ -2180,7 +2180,7 @@ can_schedule_ready_p (rtx insn)\n    can_schedule_ready_p () differs from the one passed to\n    begin_schedule_ready ().  */\n static void\n-begin_schedule_ready (rtx insn)\n+begin_schedule_ready (rtx_insn *insn)\n {\n   /* An interblock motion?  */\n   if (INSN_BB (insn) != target_bb)\n@@ -2212,7 +2212,7 @@ begin_schedule_ready (rtx insn)\n    Return nonzero if it should be moved to the ready list or the queue, or zero\n    if we should silently discard it.  */\n static ds_t\n-new_ready (rtx next, ds_t ts)\n+new_ready (rtx_insn *next, ds_t ts)\n {\n   if (INSN_BB (next) != target_bb)\n     {\n@@ -2265,7 +2265,7 @@ new_ready (rtx next, ds_t ts)\n    to be formatted so that multiple output lines will line up nicely.  */\n \n static const char *\n-rgn_print_insn (const_rtx insn, int aligned)\n+rgn_print_insn (const rtx_insn *insn, int aligned)\n {\n   static char tmp[80];\n \n@@ -2286,7 +2286,7 @@ rgn_print_insn (const_rtx insn, int aligned)\n    is to be preferred.  Zero if they are equally good.  */\n \n static int\n-rgn_rank (rtx insn1, rtx insn2)\n+rgn_rank (rtx_insn *insn1, rtx_insn *insn2)\n {\n   /* Some comparison make sense in interblock scheduling only.  */\n   if (INSN_BB (insn1) != INSN_BB (insn2))\n@@ -2317,7 +2317,7 @@ rgn_rank (rtx insn1, rtx insn2)\n    calculations.  */\n \n int\n-contributes_to_priority (rtx next, rtx insn)\n+contributes_to_priority (rtx_insn *next, rtx_insn *insn)\n {\n   /* NEXT and INSN reside in one ebb.  */\n   return BLOCK_TO_BB (BLOCK_NUM (next)) == BLOCK_TO_BB (BLOCK_NUM (insn));\n@@ -2363,7 +2363,7 @@ static const struct sched_deps_info_def rgn_const_sel_sched_deps_info =\n /* Return true if scheduling INSN will trigger finish of scheduling\n    current block.  */\n static bool\n-rgn_insn_finishes_block_p (rtx insn)\n+rgn_insn_finishes_block_p (rtx_insn *insn)\n {\n   if (INSN_BB (insn) == target_bb\n       && sched_target_n_insns + 1 == target_n_insns)\n@@ -2440,9 +2440,9 @@ static sbitmap insn_referenced;\n /* Add dependences so that branches are scheduled to run last in their\n    block.  */\n static void\n-add_branch_dependences (rtx head, rtx tail)\n+add_branch_dependences (rtx_insn *head, rtx_insn *tail)\n {\n-  rtx insn, last;\n+  rtx_insn *insn, *last;\n \n   /* For all branches, calls, uses, clobbers, cc0 setters, and instructions\n      that can throw exceptions, force them to remain in order at the end of\n@@ -3425,7 +3425,7 @@ schedule_insns (void)\n \n /* INSN has been added to/removed from current region.  */\n static void\n-rgn_add_remove_insn (rtx insn, int remove_p)\n+rgn_add_remove_insn (rtx_insn *insn, int remove_p)\n {\n   if (!remove_p)\n     rgn_n_insns++;\n@@ -3580,7 +3580,7 @@ rgn_fix_recovery_cfg (int bbi, int check_bbi, int check_bb_nexti)\n /* Return next block in ebb chain.  For parameter meaning please refer to\n    sched-int.h: struct sched_info: advance_target_bb.  */\n static basic_block\n-advance_target_bb (basic_block bb, rtx insn)\n+advance_target_bb (basic_block bb, rtx_insn *insn)\n {\n   if (insn)\n     return 0;"}, {"sha": "8dc82c99d04366141c2f53445d31bf38eba14fad", "filename": "gcc/sel-sched-dump.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce1ce33a037057b77a99ed0613f4369546dc82cd/gcc%2Fsel-sched-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce1ce33a037057b77a99ed0613f4369546dc82cd/gcc%2Fsel-sched-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched-dump.c?ref=ce1ce33a037057b77a99ed0613f4369546dc82cd", "patch": "@@ -567,7 +567,7 @@ dump_hard_reg_set (const char *prefix, HARD_REG_SET set)\n \n /* Pretty print INSN.  This is used as a hook.  */\n const char *\n-sel_print_insn (const_rtx insn, int aligned ATTRIBUTE_UNUSED)\n+sel_print_insn (const rtx_insn *insn, int aligned ATTRIBUTE_UNUSED)\n {\n   static char buf[80];\n "}, {"sha": "cb9398106b7a9ded88a575644fc4ebfa960a8649", "filename": "gcc/sel-sched-dump.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce1ce33a037057b77a99ed0613f4369546dc82cd/gcc%2Fsel-sched-dump.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce1ce33a037057b77a99ed0613f4369546dc82cd/gcc%2Fsel-sched-dump.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched-dump.h?ref=ce1ce33a037057b77a99ed0613f4369546dc82cd", "patch": "@@ -196,7 +196,7 @@ extern bool sched_dump_to_dot_p;\n \n /* Functions from sel-sched-dump.c.  */\n extern void sel_print (const char *fmt, ...) ATTRIBUTE_PRINTF_1;\n-extern const char * sel_print_insn (const_rtx, int);\n+extern const char * sel_print_insn (const rtx_insn *, int);\n extern void free_sel_dump_data (void);\n \n extern void block_start (void);"}, {"sha": "0531b2863a4378a8f1e21f821f6dad4d985a29f3", "filename": "gcc/sel-sched-ir.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce1ce33a037057b77a99ed0613f4369546dc82cd/gcc%2Fsel-sched-ir.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce1ce33a037057b77a99ed0613f4369546dc82cd/gcc%2Fsel-sched-ir.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched-ir.c?ref=ce1ce33a037057b77a99ed0613f4369546dc82cd", "patch": "@@ -516,7 +516,7 @@ void\n advance_deps_context (deps_t dc, insn_t insn)\n {\n   sched_deps_info = &advance_deps_context_sched_deps_info;\n-  deps_analyze_insn (dc, insn);\n+  deps_analyze_insn (dc, as_a <rtx_insn *> (insn));\n }\n \f\n \n@@ -2748,7 +2748,7 @@ deps_init_id (idata_t id, insn_t insn, bool force_unique_p)\n \n   sched_deps_info = &deps_init_id_sched_deps_info;\n \n-  deps_analyze_insn (dc, insn);\n+  deps_analyze_insn (dc, as_a <rtx_insn *> (insn));\n \n   free_deps (dc);\n "}, {"sha": "91d194a56506a9a95f5f81278c19f4c59766b8dc", "filename": "gcc/sel-sched.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce1ce33a037057b77a99ed0613f4369546dc82cd/gcc%2Fsel-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce1ce33a037057b77a99ed0613f4369546dc82cd/gcc%2Fsel-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched.c?ref=ce1ce33a037057b77a99ed0613f4369546dc82cd", "patch": "@@ -4015,7 +4015,7 @@ convert_vec_av_set_to_ready (void)\n       insn_t insn = VINSN_INSN_RTX (vi);\n \n       ready_try[n] = 0;\n-      ready.vec[n] = insn;\n+      ready.vec[n] = as_a <rtx_insn *> (insn);\n     }\n }\n \n@@ -4154,7 +4154,7 @@ invoke_reorder_hooks (fence_t fence)\n   if (issue_more && ran_hook)\n     {\n       int i, j, n;\n-      rtx *arr = ready.vec;\n+      rtx_insn **arr = ready.vec;\n       expr_t *vec = vec_av_set.address ();\n \n       for (i = 0, n = ready.n_ready; i < n; i++)"}, {"sha": "07eae6c50340bbfe18fd44c90a9fdc3bdfd18556", "filename": "gcc/target.def", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce1ce33a037057b77a99ed0613f4369546dc82cd/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce1ce33a037057b77a99ed0613f4369546dc82cd/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=ce1ce33a037057b77a99ed0613f4369546dc82cd", "patch": "@@ -1027,7 +1027,7 @@ is the timer tick of the scheduler.  You may modify the ready list and\\n\\\n the number of ready insns.  The return value is the number of insns that\\n\\\n can issue this cycle; normally this is just @code{issue_rate}.  See also\\n\\\n @samp{TARGET_SCHED_REORDER2}.\",\n- int, (FILE *file, int verbose, rtx *ready, int *n_readyp, int clock), NULL)\n+ int, (FILE *file, int verbose, rtx_insn **ready, int *n_readyp, int clock), NULL)\n \n DEFHOOK\n (reorder2,\n@@ -1039,7 +1039,7 @@ return the number of insns to be scheduled in the same cycle.  Defining\\n\\\n this hook can be useful if there are frequent situations where\\n\\\n scheduling one insn causes other insns to become ready in the same\\n\\\n cycle.  These other insns can then be taken into account properly.\",\n- int, (FILE *file, int verbose, rtx *ready, int *n_readyp, int clock), NULL)\n+ int, (FILE *file, int verbose, rtx_insn **ready, int *n_readyp, int clock), NULL)\n \n DEFHOOK\n (macro_fusion_p,\n@@ -1066,7 +1066,7 @@ example, it can be used for better insn classification if it requires\\n\\\n analysis of dependencies.  This hook can use backward and forward\\n\\\n dependencies of the insn scheduler because they are already\\n\\\n calculated.\",\n- void, (rtx head, rtx tail), NULL)\n+ void, (rtx_insn *head, rtx_insn *tail), NULL)\n \n /* The values of the following four members are pointers to functions\n    used to simplify the automaton descriptions.  dfa_pre_cycle_insn and"}]}