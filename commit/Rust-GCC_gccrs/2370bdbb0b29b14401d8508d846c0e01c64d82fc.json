{"sha": "2370bdbb0b29b14401d8508d846c0e01c64d82fc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjM3MGJkYmIwYjI5YjE0NDAxZDg1MDhkODQ2YzBlMDFjNjRkODJmYw==", "commit": {"author": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2020-04-26T21:39:32Z"}, "committer": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2020-04-27T00:47:26Z"}, "message": "d: Fix ICE in assign_temp, at function.c:984 (PR94777)\n\nNamed arguments were being passed around by invisible reference, just\nnot variadic arguments.  There is a need to de-duplicate the routines\nthat handle declaration/parameter promotion and reference checking.\nHowever for now, the parameter helper functions have just been renamed\nto parameter_reference_p and parameter_type, to make it more clear that\nit is the Parameter equivalent to declaration_reference_p and\ndeclaration_type.\n\nOn writing the tests, a forward-reference bug was discovered on x86_64\nduring va_list type semantic.  This was due to fields not having their\nparent set-up correctly.\n\ngcc/d/ChangeLog:\n\n\tPR d/94777\n\t* d-builtins.cc (build_frontend_type): Set parent for generated\n\tfields of built-in types.\n\t* d-codegen.cc (argument_reference_p): Rename to ...\n\t(parameter_reference_p): ... this.\n\t(type_passed_as): Rename to ...\n\t(parameter_type): ... this.  Make TREE_ADDRESSABLE types restrict.\n\t(d_build_call): Move handling of non-POD types here from ...\n\t* d-convert.cc (convert_for_argument): ... here.\n\t* d-tree.h (argument_reference_p): Rename declaration to ...\n\t(parameter_reference_p): ... this.\n\t(type_passed_as): Rename declaration to ...\n\t(parameter_type): ... this.\n\t* types.cc (TypeVisitor::visit (TypeFunction *)): Update caller.\n\ngcc/testsuite/ChangeLog:\n\n\tPR d/94777\n\t* gdc.dg/pr94777a.d: New test.\n\t* gdc.dg/pr94777b.d: New test.", "tree": {"sha": "43016d247bb7f8fa7a5b397e862e30f29ef07456", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/43016d247bb7f8fa7a5b397e862e30f29ef07456"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2370bdbb0b29b14401d8508d846c0e01c64d82fc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2370bdbb0b29b14401d8508d846c0e01c64d82fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2370bdbb0b29b14401d8508d846c0e01c64d82fc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2370bdbb0b29b14401d8508d846c0e01c64d82fc/comments", "author": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f82e3a12955e484b4da7fcca93655a2a2e785e5b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f82e3a12955e484b4da7fcca93655a2a2e785e5b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f82e3a12955e484b4da7fcca93655a2a2e785e5b"}], "stats": {"total": 277, "additions": 254, "deletions": 23}, "files": [{"sha": "3b5fc12a8fd1515882dc3ebffffa818cc67d84b4", "filename": "gcc/d/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2370bdbb0b29b14401d8508d846c0e01c64d82fc/gcc%2Fd%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2370bdbb0b29b14401d8508d846c0e01c64d82fc/gcc%2Fd%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2FChangeLog?ref=2370bdbb0b29b14401d8508d846c0e01c64d82fc", "patch": "@@ -1,3 +1,20 @@\n+2020-04-27  Iain Buclaw  <ibuclaw@gdcproject.org>\n+\n+\tPR d/94777\n+\t* d-builtins.cc (build_frontend_type): Set parent for generated\n+\tfields of built-in types.\n+\t* d-codegen.cc (argument_reference_p): Rename to ...\n+\t(parameter_reference_p): ... this.\n+\t(type_passed_as): Rename to ...\n+\t(parameter_type): ... this.  Make TREE_ADDRESSABLE types restrict.\n+\t(d_build_call): Move handling of non-POD types here from ...\n+\t* d-convert.cc (convert_for_argument): ... here.\n+\t* d-tree.h (argument_reference_p): Rename declaration to ...\n+\t(parameter_reference_p): ... this.\n+\t(type_passed_as): Rename declaration to ...\n+\t(parameter_type): ... this.\n+\t* types.cc (TypeVisitor::visit (TypeFunction *)): Update caller.\n+\n 2020-04-26  Iain Buclaw  <ibuclaw@gdcproject.org>\n \n \t* decl.cc (get_symbol_decl): Set DECL_DECLARED_INLINE_P or"}, {"sha": "a5654a66bf5741db9947e9b8c36e87405caa44f9", "filename": "gcc/d/d-builtins.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2370bdbb0b29b14401d8508d846c0e01c64d82fc/gcc%2Fd%2Fd-builtins.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2370bdbb0b29b14401d8508d846c0e01c64d82fc/gcc%2Fd%2Fd-builtins.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-builtins.cc?ref=2370bdbb0b29b14401d8508d846c0e01c64d82fc", "patch": "@@ -253,6 +253,7 @@ build_frontend_type (tree type)\n \t    = Identifier::idPool (IDENTIFIER_POINTER (DECL_NAME (field)));\n \t  VarDeclaration *vd = VarDeclaration::create (Loc (), ftype, fident,\n \t\t\t\t\t\t       NULL);\n+\t  vd->parent = sdecl;\n \t  vd->offset = tree_to_uhwi (DECL_FIELD_OFFSET (field));\n \t  vd->semanticRun = PASSsemanticdone;\n \t  vd->csym = field;"}, {"sha": "12c6f13836207d00c0afe4df5c1a6b4023b253df", "filename": "gcc/d/d-codegen.cc", "status": "modified", "additions": 29, "deletions": 3, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2370bdbb0b29b14401d8508d846c0e01c64d82fc/gcc%2Fd%2Fd-codegen.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2370bdbb0b29b14401d8508d846c0e01c64d82fc/gcc%2Fd%2Fd-codegen.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-codegen.cc?ref=2370bdbb0b29b14401d8508d846c0e01c64d82fc", "patch": "@@ -172,7 +172,7 @@ declaration_type (Declaration *decl)\n    Return TRUE if parameter ARG is a reference type.  */\n \n bool\n-argument_reference_p (Parameter *arg)\n+parameter_reference_p (Parameter *arg)\n {\n   Type *tb = arg->type->toBasetype ();\n \n@@ -186,7 +186,7 @@ argument_reference_p (Parameter *arg)\n /* Returns the real type for parameter ARG.  */\n \n tree\n-type_passed_as (Parameter *arg)\n+parameter_type (Parameter *arg)\n {\n   /* Lazy parameters are converted to delegates.  */\n   if (arg->storageClass & STClazy)\n@@ -207,9 +207,18 @@ type_passed_as (Parameter *arg)\n   tree type = build_ctype (arg->type);\n \n   /* Parameter is passed by reference.  */\n-  if (TREE_ADDRESSABLE (type) || argument_reference_p (arg))\n+  if (parameter_reference_p (arg))\n     return build_reference_type (type);\n \n+  /* Pass non-POD structs by invisible reference.  */\n+  if (TREE_ADDRESSABLE (type))\n+    {\n+      type = build_reference_type (type);\n+      /* There are no other pointer to this temporary.  */\n+      type = build_qualified_type (type, TYPE_QUAL_RESTRICT);\n+    }\n+\n+  /* Front-end has already taken care of type promotions.  */\n   return type;\n }\n \n@@ -1954,6 +1963,23 @@ d_build_call (TypeFunction *tf, tree callable, tree object,\n \t      targ = build2 (COMPOUND_EXPR, TREE_TYPE (t), targ, t);\n \t    }\n \n+\t  /* Parameter is a struct passed by invisible reference.  */\n+\t  if (TREE_ADDRESSABLE (TREE_TYPE (targ)))\n+\t    {\n+\t      Type *t = arg->type->toBasetype ();\n+\t      gcc_assert (t->ty == Tstruct);\n+\t      StructDeclaration *sd = ((TypeStruct *) t)->sym;\n+\n+\t      /* Nested structs also have ADDRESSABLE set, but if the type has\n+\t\t neither a copy constructor nor a destructor available, then we\n+\t\t need to take care of copying its value before passing it.  */\n+\t      if (arg->op == TOKstructliteral || (!sd->postblit && !sd->dtor))\n+\t\ttarg = force_target_expr (targ);\n+\n+\t      targ = convert (build_reference_type (TREE_TYPE (targ)),\n+\t\t\t      build_address (targ));\n+\t    }\n+\n \t  vec_safe_push (args, targ);\n \t}\n     }"}, {"sha": "e2921ec33f0386416897eda36fa247244ad7e7d5", "filename": "gcc/d/d-convert.cc", "status": "modified", "additions": 2, "deletions": 17, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2370bdbb0b29b14401d8508d846c0e01c64d82fc/gcc%2Fd%2Fd-convert.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2370bdbb0b29b14401d8508d846c0e01c64d82fc/gcc%2Fd%2Fd-convert.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-convert.cc?ref=2370bdbb0b29b14401d8508d846c0e01c64d82fc", "patch": "@@ -672,25 +672,10 @@ convert_for_argument (tree expr, Parameter *arg)\n       if (!POINTER_TYPE_P (TREE_TYPE (expr)))\n \treturn build_address (expr);\n     }\n-  else if (argument_reference_p (arg))\n+  else if (parameter_reference_p (arg))\n     {\n       /* Front-end shouldn't automatically take the address.  */\n-      return convert (type_passed_as (arg), build_address (expr));\n-    }\n-  else if (TREE_ADDRESSABLE (TREE_TYPE (expr)))\n-    {\n-      /* Type is a struct passed by invisible reference.  */\n-      Type *t = arg->type->toBasetype ();\n-      gcc_assert (t->ty == Tstruct);\n-      StructDeclaration *sd = ((TypeStruct *) t)->sym;\n-\n-      /* Nested structs also have ADDRESSABLE set, but if the type has\n-\t neither a copy constructor nor a destructor available, then we\n-\t need to take care of copying its value before passing it.  */\n-      if (!sd->postblit && !sd->dtor)\n-\texpr = force_target_expr (expr);\n-\n-      return convert (type_passed_as (arg), build_address (expr));\n+      return convert (parameter_type (arg), build_address (expr));\n     }\n \n   return expr;"}, {"sha": "48587d96e3822b57c31e15f19947445349b6193a", "filename": "gcc/d/d-tree.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2370bdbb0b29b14401d8508d846c0e01c64d82fc/gcc%2Fd%2Fd-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2370bdbb0b29b14401d8508d846c0e01c64d82fc/gcc%2Fd%2Fd-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-tree.h?ref=2370bdbb0b29b14401d8508d846c0e01c64d82fc", "patch": "@@ -504,8 +504,8 @@ extern tree d_decl_context (Dsymbol *);\n extern tree copy_aggregate_type (tree);\n extern bool declaration_reference_p (Declaration *);\n extern tree declaration_type (Declaration *);\n-extern bool argument_reference_p (Parameter *);\n-extern tree type_passed_as (Parameter *);\n+extern bool parameter_reference_p (Parameter *);\n+extern tree parameter_type (Parameter *);\n extern tree build_integer_cst (dinteger_t, tree = d_int_type);\n extern tree build_float_cst (const real_t &, Type *);\n extern tree d_array_length (tree);"}, {"sha": "59a90b492438d301b02abd2cff7a9654a749a650", "filename": "gcc/d/types.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2370bdbb0b29b14401d8508d846c0e01c64d82fc/gcc%2Fd%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2370bdbb0b29b14401d8508d846c0e01c64d82fc/gcc%2Fd%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Ftypes.cc?ref=2370bdbb0b29b14401d8508d846c0e01c64d82fc", "patch": "@@ -720,7 +720,7 @@ class TypeVisitor : public Visitor\n \n \tfor (size_t i = 0; i < n_args; i++)\n \t  {\n-\t    tree type = type_passed_as (Parameter::getNth (t->parameters, i));\n+\t    tree type = parameter_type (Parameter::getNth (t->parameters, i));\n \t    fnparams = chainon (fnparams, build_tree_list (0, type));\n \t  }\n       }"}, {"sha": "1f412a0ef1dc0509b506f35dbc8894e9e661a6de", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2370bdbb0b29b14401d8508d846c0e01c64d82fc/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2370bdbb0b29b14401d8508d846c0e01c64d82fc/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2370bdbb0b29b14401d8508d846c0e01c64d82fc", "patch": "@@ -1,3 +1,9 @@\n+2020-04-27  Iain Buclaw  <ibuclaw@gdcproject.org>\n+\n+\tPR d/94777\n+\t* gdc.dg/pr94777a.d: New test.\n+\t* gdc.dg/pr94777b.d: New test.\n+\n 2020-04-26  Iain Sandoe  <iain@sandoe.co.uk>\n \n \tPR c++/94752"}, {"sha": "a58fa557e3519ba4fdcc6f9de26586a733fd3142", "filename": "gcc/testsuite/gdc.dg/pr94777a.d", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2370bdbb0b29b14401d8508d846c0e01c64d82fc/gcc%2Ftestsuite%2Fgdc.dg%2Fpr94777a.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2370bdbb0b29b14401d8508d846c0e01c64d82fc/gcc%2Ftestsuite%2Fgdc.dg%2Fpr94777a.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.dg%2Fpr94777a.d?ref=2370bdbb0b29b14401d8508d846c0e01c64d82fc", "patch": "@@ -0,0 +1,15 @@\n+// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=94777\n+// { dg-do compile }\n+\n+extern void variadic(...);\n+\n+void f94777()\n+{\n+    struct S94777\n+    {\n+        int fld;\n+        this(this) { }\n+    }\n+    auto var = S94777(0);\n+    variadic(var, S94777(1));\n+}"}, {"sha": "a230adb0cd94b70e7cc8ce553673c1fbb2c1cd82", "filename": "gcc/testsuite/gdc.dg/pr94777b.d", "status": "added", "additions": 181, "deletions": 0, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2370bdbb0b29b14401d8508d846c0e01c64d82fc/gcc%2Ftestsuite%2Fgdc.dg%2Fpr94777b.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2370bdbb0b29b14401d8508d846c0e01c64d82fc/gcc%2Ftestsuite%2Fgdc.dg%2Fpr94777b.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.dg%2Fpr94777b.d?ref=2370bdbb0b29b14401d8508d846c0e01c64d82fc", "patch": "@@ -0,0 +1,181 @@\n+// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=94777\n+// { dg-additional-options \"-fmain -funittest\" }\n+// { dg-do run { target hw } }\n+// { dg-skip-if \"needs gcc/config.d\" { ! d_runtime } }\n+\n+void testVariadic(T)(int nargs, ...)\n+{\n+    import core.stdc.stdarg;\n+    foreach(i; 0 .. nargs)\n+    {\n+        auto arg = va_arg!T(_argptr);\n+        static if (__traits(compiles, arg.value))\n+        {\n+            assert(arg.value == i);\n+        }\n+        else static if (__traits(compiles, arg[0]))\n+        {\n+            foreach (value; arg)\n+                assert(value == i);\n+        }\n+        else\n+        {\n+            assert(arg == T.init);\n+        }\n+    }\n+}\n+\n+/******************************************/\n+\n+struct Constructor\n+{\n+    static int count;\n+    int value;\n+    this(int v) { count++; this.value = v; }\n+}\n+\n+unittest\n+{\n+    auto a0 = Constructor(0);\n+    auto a1 = Constructor(1);\n+    auto a2 = Constructor(2);\n+    testVariadic!Constructor(3, a0, a1, a2);\n+    assert(Constructor.count == 3);\n+}\n+\n+/******************************************/\n+\n+struct Postblit\n+{\n+    static int count = 0;\n+    int value;\n+    this(this) { count++; }\n+}\n+\n+unittest\n+{\n+    auto a0 = Postblit(0);\n+    auto a1 = Postblit(1);\n+    auto a2 = Postblit(2);\n+    testVariadic!Postblit(3, a0, a1, a2);\n+    assert(Postblit.count == 3);\n+}\n+\n+/******************************************/\n+\n+struct Destructor\n+{\n+    static int count = 0;\n+    int value;\n+    ~this() { count++; }\n+}\n+\n+unittest\n+{\n+    {\n+        auto a0 = Destructor(0);\n+        auto a1 = Destructor(1);\n+        auto a2 = Destructor(2);\n+        static assert(!__traits(compiles, testVariadic!Destructor(3, a0, a1, a2)));\n+    }\n+    assert(Destructor.count == 3);\n+}\n+\n+/******************************************/\n+\n+struct CopyConstructor \n+{\n+    static int count = 0;\n+    int value;\n+    this(int v) { this.value = v; }\n+    this(ref typeof(this) other) { count++; this.value = other.value; }\n+}\n+\n+unittest\n+{\n+    auto a0 = CopyConstructor(0);\n+    auto a1 = CopyConstructor(1);\n+    auto a2 = CopyConstructor(2);\n+    testVariadic!CopyConstructor(3, a0, a1, a2);\n+    // NOTE: Cpctors are not implemented yet.\n+    assert(CopyConstructor.count == 0 || CopyConstructor.count == 3);\n+}\n+\n+/******************************************/\n+\n+unittest\n+{\n+    struct Nested\n+    {\n+        int value;\n+    }\n+\n+    auto a0 = Nested(0);\n+    auto a1 = Nested(1);\n+    auto a2 = Nested(2);\n+    testVariadic!Nested(3, a0, a1, a2);\n+}\n+\n+/******************************************/\n+\n+unittest\n+{\n+    struct Nested2\n+    {\n+        int value;\n+    }\n+\n+    void testVariadic2(int nargs, ...)\n+    {\n+        import core.stdc.stdarg;\n+        foreach(i; 0 .. nargs)\n+        {\n+            auto arg = va_arg!Nested2(_argptr);\n+            assert(arg.value == i);\n+        }\n+    }\n+\n+    auto a0 = Nested2(0);\n+    auto a1 = Nested2(1);\n+    auto a2 = Nested2(2);\n+    testVariadic2(3, a0, a1, a2);\n+}\n+\n+/******************************************/\n+\n+struct EmptyStruct\n+{\n+}\n+\n+unittest\n+{\n+    auto a0 = EmptyStruct();\n+    auto a1 = EmptyStruct();\n+    auto a2 = EmptyStruct();\n+    testVariadic!EmptyStruct(3, a0, a1, a2);\n+}\n+\n+/******************************************/\n+\n+alias StaticArray = int[4];\n+\n+unittest\n+{\n+    StaticArray a0 = 0;\n+    StaticArray a1 = 1;\n+    StaticArray a2 = 2;\n+    // XBUG: Front-end rewrites static arrays as dynamic arrays.\n+    //testVariadic!StaticArray(3, a0, a1, a2);\n+}\n+\n+/******************************************/\n+\n+alias EmptyArray = void[0];\n+\n+unittest\n+{\n+    auto a0 = EmptyArray.init;\n+    auto a1 = EmptyArray.init;\n+    auto a2 = EmptyArray.init;\n+    testVariadic!EmptyArray(3, a0, a1, a2);\n+}"}]}