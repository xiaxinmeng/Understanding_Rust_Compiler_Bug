{"sha": "b0cc57cd76f511f29cab233654249817312ec2a6", "node_id": "C_kwDOANBUbNoAKGIwY2M1N2NkNzZmNTExZjI5Y2FiMjMzNjU0MjQ5ODE3MzEyZWMyYTY", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2022-07-15T13:35:29Z"}, "committer": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2022-07-19T22:05:49Z"}, "message": "Remove recursion from range_from_dom.\n\nAvoid calling range_of_dom recursively by putting all nodes to be\ncalculated on the worklist, and figure out which kind they are\nwhen removed from the list.\n\n\t* gimple-range-cache.cc (ranger_cache::resolve_dom): New.\n\t(ranger_cache::range_from_dom): Put all nodes to be calculated\n\tin the worklist and resolve after the dom walk.\n\t* gimple-range-cache.h (resolve_dom): New prototype.", "tree": {"sha": "c8b6efb6e3bdff95e91cbd6e1ec9bfb0a043c8c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c8b6efb6e3bdff95e91cbd6e1ec9bfb0a043c8c9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b0cc57cd76f511f29cab233654249817312ec2a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0cc57cd76f511f29cab233654249817312ec2a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b0cc57cd76f511f29cab233654249817312ec2a6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0cc57cd76f511f29cab233654249817312ec2a6/comments", "author": null, "committer": null, "parents": [{"sha": "f838d15641d256e21ffc126c3277b290ed743928", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f838d15641d256e21ffc126c3277b290ed743928", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f838d15641d256e21ffc126c3277b290ed743928"}], "stats": {"total": 85, "additions": 48, "deletions": 37}, "files": [{"sha": "20dd5ead3bc0c2fe9c2d658ccc098ed13562474a", "filename": "gcc/gimple-range-cache.cc", "status": "modified", "additions": 47, "deletions": 37, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0cc57cd76f511f29cab233654249817312ec2a6/gcc%2Fgimple-range-cache.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0cc57cd76f511f29cab233654249817312ec2a6/gcc%2Fgimple-range-cache.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-cache.cc?ref=b0cc57cd76f511f29cab233654249817312ec2a6", "patch": "@@ -1312,6 +1312,38 @@ ranger_cache::fill_block_cache (tree name, basic_block bb, basic_block def_bb)\n     fprintf (dump_file, \"  Propagation update done.\\n\");\n }\n \n+// Resolve the range of BB if the dominators range is R by calculating incoming\n+// edges to this block.  All lead back to the dominator so should be cheap.\n+// The range for BB is set and returned in R.\n+\n+void\n+ranger_cache::resolve_dom (vrange &r, tree name, basic_block bb)\n+{\n+  basic_block def_bb = gimple_bb (SSA_NAME_DEF_STMT (name));\n+  basic_block dom_bb = get_immediate_dominator (CDI_DOMINATORS, bb);\n+\n+  // if it doesn't already have a value, store the incoming range.\n+  if (!m_on_entry.bb_range_p (name, dom_bb) && def_bb != dom_bb)\n+    {\n+      // If the range can't be store, don't try to accumulate\n+      // the range in PREV_BB due to excessive recalculations.\n+      if (!m_on_entry.set_bb_range (name, dom_bb, r))\n+\treturn;\n+    }\n+  // With the dominator set, we should be able to cheaply query\n+  // each incoming edge now and accumulate the results.\n+  r.set_undefined ();\n+  edge e;\n+  edge_iterator ei;\n+  Value_Range er (TREE_TYPE (name));\n+  FOR_EACH_EDGE (e, ei, bb->preds)\n+    {\n+      edge_range (er, e, name, RFD_READ_ONLY);\n+      r.union_ (er);\n+    }\n+  // Set the cache in PREV_BB so it is not calculated again.\n+  m_on_entry.set_bb_range (name, bb, r);\n+}\n \n // Get the range of NAME from dominators of BB and return it in R.  Search the\n // dominator tree based on MODE.\n@@ -1341,7 +1373,7 @@ ranger_cache::range_from_dom (vrange &r, tree name, basic_block start_bb,\n   // Default value is global range.\n   get_global_range (r, name);\n \n-  // Search until a value is found, pushing outgoing edges encountered.\n+  // Search until a value is found, pushing blocks which may need calculating.\n   for (bb = get_immediate_dominator (CDI_DOMINATORS, start_bb);\n        bb;\n        prev_bb = bb, bb = get_immediate_dominator (CDI_DOMINATORS, bb))\n@@ -1351,40 +1383,7 @@ ranger_cache::range_from_dom (vrange &r, tree name, basic_block start_bb,\n \n       // This block has an outgoing range.\n       if (m_gori.has_edge_range_p (name, bb))\n-\t{\n-\t  // Only outgoing ranges to single_pred blocks are dominated by\n-\t  // outgoing edge ranges, so those can be simply adjusted on the fly.\n-\t  edge e = find_edge (bb, prev_bb);\n-\t  if (e && single_pred_p (prev_bb))\n-\t    m_workback.quick_push (prev_bb);\n-\t  else if (mode == RFD_FILL)\n-\t    {\n-\t      // Multiple incoming edges, so recursively satisfy this block\n-\t      // if it doesn't already have a value, and store the range.\n-\t      if (!m_on_entry.bb_range_p (name, bb) && def_bb != bb)\n-\t\t{\n-\t\t  // If the dominator has not been set, look it up.\n-\t\t  range_from_dom (r, name, bb, RFD_FILL);\n-\t\t  // If the range can't be store, don't try to accumulate\n-\t\t  // the range in PREV_BB due to excessive recalculations.\n-\t\t  if (!m_on_entry.set_bb_range (name, bb, r))\n-\t\t    break;\n-\t\t}\n-\t      // With the dominator set, we should be able to cheaply query\n-\t      // each incoming edge now and accumulate the results.\n-\t      r.set_undefined ();\n-\t      edge_iterator ei;\n-\t      Value_Range er (TREE_TYPE (name));\n-\t      FOR_EACH_EDGE (e, ei, prev_bb->preds)\n-\t\t{\n-\t\t  edge_range (er, e, name, RFD_READ_ONLY);\n-\t\t  r.union_ (er);\n-\t\t}\n-\t      // Set the cache in PREV_BB so it is not calculated again.\n-\t      m_on_entry.set_bb_range (name, prev_bb, r);\n-\t      break;\n-\t    }\n-\t}\n+\tm_workback.quick_push (prev_bb);\n \n       if (def_bb == bb)\n \tbreak;\n@@ -1403,14 +1402,25 @@ ranger_cache::range_from_dom (vrange &r, tree name, basic_block start_bb,\n \tfprintf (dump_file, \" at function top\\n\");\n     }\n \n-  // Now process any outgoing edges that we seen along the way.\n+  // Now process any blocks wit incoming edges that nay have adjustemnts.\n   while (m_workback.length () > start_limit)\n     {\n       int_range_max er;\n       prev_bb = m_workback.pop ();\n+      if (!single_pred_p (prev_bb))\n+\t{\n+\t  // Non single pred means we need to cache a vsalue in the dominator\n+\t  // so we can cheaply calculate incoming edges to this block, and\n+\t  // then store the resulting value.  If processing mode is not\n+\t  // RFD_FILL, then the cache cant be stored to, so don't try.\n+\t  // Otherwise this becomes a quadratic timed calculation.\n+\t  if (mode == RFD_FILL)\n+\t    resolve_dom (r, name, prev_bb);\n+\t  continue;\n+\t}\n+\n       edge e = single_pred_edge (prev_bb);\n       bb = e->src;\n-\n       if (m_gori.outgoing_edge_range_p (er, e, name, *this))\n \t{\n \t  r.intersect (er);"}, {"sha": "45053b5873a2ae1d5b6648e3d93781962465c924", "filename": "gcc/gimple-range-cache.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0cc57cd76f511f29cab233654249817312ec2a6/gcc%2Fgimple-range-cache.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0cc57cd76f511f29cab233654249817312ec2a6/gcc%2Fgimple-range-cache.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-cache.h?ref=b0cc57cd76f511f29cab233654249817312ec2a6", "patch": "@@ -107,6 +107,7 @@ class ranger_cache : public range_query\n       RFD_FILL\t\t// Scan DOM tree, updating important nodes.\n     };\n   bool range_from_dom (vrange &r, tree name, basic_block bb, enum rfd_mode);\n+  void resolve_dom (vrange &r, tree name, basic_block bb);\n   void range_of_def (vrange &r, tree name, basic_block bb = NULL);\n   void entry_range (vrange &r, tree expr, basic_block bb, enum rfd_mode);\n   void exit_range (vrange &r, tree expr, basic_block bb, enum rfd_mode);"}]}