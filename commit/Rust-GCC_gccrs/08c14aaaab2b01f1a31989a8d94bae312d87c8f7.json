{"sha": "08c14aaaab2b01f1a31989a8d94bae312d87c8f7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDhjMTRhYWFhYjJiMDFmMWEzMTk4OWE4ZDk0YmFlMzEyZDg3YzhmNw==", "commit": {"author": {"name": "Tobias Burnus", "email": "tobias@codesourcery.com", "date": "2019-10-11T09:17:49Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2019-10-11T09:17:49Z"}, "message": "[OpenMP,Fortran] Fix several OpenMP use_device_addr/map/update errors\n\n\tgcc/fortran/\n\t* f95-lang.c (LANG_HOOKS_OMP_IS_ALLOCATABLE_OR_PTR): Re-define to\n\tgfc_omp_is_allocatable_or_ptr.\n\t* trans-decl.c (create_function_arglist): Set GFC_DECL_OPTIONAL_ARGUMENT\n\tonly if not passed by value.\n\t* trans-openmp.c (gfc_omp_is_allocatable_or_ptr): New.\n\t(gfc_trans_omp_clauses): For MAP, handle (present) optional arguments;\n\tfor target update, handle allocatable/pointer scalars.\n\t* trans.h (gfc_omp_is_allocatable_or_ptr): Declare.\n\n\tgcc/\n\t* langhooks-def.h (LANG_HOOKS_OMP_IS_ALLOCATABLE_OR_PTR): Define.\n\t(LANG_HOOKS_DECLS): Add it.\n\t* langhooks.h (lang_hooks_for_decls): Add omp_is_allocatable_or_ptr;\n\tupdate comment for omp_is_optional_argument.\n\t* omp-general.c (omp_is_allocatable_or_ptr): New.\n\t* omp-general.h (omp_is_allocatable_or_ptr): Declare.\n\t* omp-low.c (scan_sharing_clauses, lower_omp_target): Handle\n\tFortran's optional arguments and allocatable/pointer scalars\n\twith use_device_addr.\n\n\tlibgomp/\n\t* testsuite/libgomp.fortran/use_device_addr-1.f90: New.\n\t* testsuite/libgomp.fortran/use_device_addr-2.f90: New.\n\nFrom-SVN: r276875", "tree": {"sha": "57787b2cb0e1cad4b4370339157e8b47155b5e12", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/57787b2cb0e1cad4b4370339157e8b47155b5e12"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/08c14aaaab2b01f1a31989a8d94bae312d87c8f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08c14aaaab2b01f1a31989a8d94bae312d87c8f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/08c14aaaab2b01f1a31989a8d94bae312d87c8f7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08c14aaaab2b01f1a31989a8d94bae312d87c8f7/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b67e2ad80d3e080c5258ff64ddb6f40e8d783e0b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b67e2ad80d3e080c5258ff64ddb6f40e8d783e0b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b67e2ad80d3e080c5258ff64ddb6f40e8d783e0b"}], "stats": {"total": 2516, "additions": 2502, "deletions": 14}, "files": [{"sha": "cbc0b2fe1d96341fc6cf46bd21469aa089d093c3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c14aaaab2b01f1a31989a8d94bae312d87c8f7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c14aaaab2b01f1a31989a8d94bae312d87c8f7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=08c14aaaab2b01f1a31989a8d94bae312d87c8f7", "patch": "@@ -1,3 +1,15 @@\n+2019-10-11  Tobias Burnus  <tobias@codesourcery.com>\n+\n+\t* langhooks-def.h (LANG_HOOKS_OMP_IS_ALLOCATABLE_OR_PTR): Define.\n+\t(LANG_HOOKS_DECLS): Add it.\n+\t* langhooks.h (lang_hooks_for_decls): Add omp_is_allocatable_or_ptr;\n+\tupdate comment for omp_is_optional_argument.\n+\t* omp-general.c (omp_is_allocatable_or_ptr): New.\n+\t* omp-general.h (omp_is_allocatable_or_ptr): Declare.\n+\t* omp-low.c (scan_sharing_clauses, lower_omp_target): Handle\n+\tFortran's optional arguments and allocatable/pointer scalars\n+\twith use_device_addr.\n+\n 2019-10-11  Ilya Leoshkevich  <iii@linux.ibm.com>\n \n \tPR target/77918"}, {"sha": "82bc450fda6f953b9b611e685b0d6f9792e3f19d", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c14aaaab2b01f1a31989a8d94bae312d87c8f7/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c14aaaab2b01f1a31989a8d94bae312d87c8f7/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=08c14aaaab2b01f1a31989a8d94bae312d87c8f7", "patch": "@@ -1,3 +1,14 @@\n+2019-10-11  Tobias Burnus  <tobias@codesourcery.com>\n+\n+\t* f95-lang.c (LANG_HOOKS_OMP_IS_ALLOCATABLE_OR_PTR): Re-define to\n+\tgfc_omp_is_allocatable_or_ptr.\n+\t* trans-decl.c (create_function_arglist): Set GFC_DECL_OPTIONAL_ARGUMENT\n+\tonly if not passed by value.\n+\t* trans-openmp.c (gfc_omp_is_allocatable_or_ptr): New.\n+\t(gfc_trans_omp_clauses): For MAP, handle (present) optional arguments;\n+\tfor target update, handle allocatable/pointer scalars.\n+\t* trans.h (gfc_omp_is_allocatable_or_ptr): Declare.\n+\n 2019-10-10  Tobias Burnus  <tobias@codesourcery.com>\n \n \t* trans-openmp.c (gfc_trans_omp_clauses): Actually pass use_device_addr"}, {"sha": "0f72ab9e3b4feabc20dd51ec1b78f8e374d1bcb9", "filename": "gcc/fortran/f95-lang.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c14aaaab2b01f1a31989a8d94bae312d87c8f7/gcc%2Ffortran%2Ff95-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c14aaaab2b01f1a31989a8d94bae312d87c8f7/gcc%2Ffortran%2Ff95-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ff95-lang.c?ref=08c14aaaab2b01f1a31989a8d94bae312d87c8f7", "patch": "@@ -113,6 +113,7 @@ static const struct attribute_spec gfc_attribute_table[] =\n #undef LANG_HOOKS_TYPE_FOR_MODE\n #undef LANG_HOOKS_TYPE_FOR_SIZE\n #undef LANG_HOOKS_INIT_TS\n+#undef LANG_HOOKS_OMP_IS_ALLOCATABLE_OR_PTR\n #undef LANG_HOOKS_OMP_IS_OPTIONAL_ARGUMENT\n #undef LANG_HOOKS_OMP_PRIVATIZE_BY_REFERENCE\n #undef LANG_HOOKS_OMP_PREDETERMINED_SHARING\n@@ -146,6 +147,7 @@ static const struct attribute_spec gfc_attribute_table[] =\n #define LANG_HOOKS_TYPE_FOR_MODE\tgfc_type_for_mode\n #define LANG_HOOKS_TYPE_FOR_SIZE\tgfc_type_for_size\n #define LANG_HOOKS_INIT_TS\t\tgfc_init_ts\n+#define LANG_HOOKS_OMP_IS_ALLOCATABLE_OR_PTR\tgfc_omp_is_allocatable_or_ptr\n #define LANG_HOOKS_OMP_IS_OPTIONAL_ARGUMENT\tgfc_omp_is_optional_argument\n #define LANG_HOOKS_OMP_PRIVATIZE_BY_REFERENCE\tgfc_omp_privatize_by_reference\n #define LANG_HOOKS_OMP_PREDETERMINED_SHARING\tgfc_omp_predetermined_sharing"}, {"sha": "3ad802e5d83e846d426bdef1214af8859c45bb80", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c14aaaab2b01f1a31989a8d94bae312d87c8f7/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c14aaaab2b01f1a31989a8d94bae312d87c8f7/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=08c14aaaab2b01f1a31989a8d94bae312d87c8f7", "patch": "@@ -2691,8 +2691,9 @@ create_function_arglist (gfc_symbol * sym)\n \t  && (!f->sym->attr.proc_pointer\n \t      && f->sym->attr.flavor != FL_PROCEDURE))\n \tDECL_BY_REFERENCE (parm) = 1;\n-      if (f->sym->attr.optional)\n+      if (f->sym->attr.optional && !f->sym->attr.value)\n \t{\n+\t  /* With value, the argument is passed as is.  */\n \t  gfc_allocate_lang_decl (parm);\n \t  GFC_DECL_OPTIONAL_ARGUMENT (parm) = 1;\n \t}"}, {"sha": "dad11a24430d05276f6da70a241d27899d656278", "filename": "gcc/fortran/trans-openmp.c", "status": "modified", "additions": 28, "deletions": 4, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c14aaaab2b01f1a31989a8d94bae312d87c8f7/gcc%2Ffortran%2Ftrans-openmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c14aaaab2b01f1a31989a8d94bae312d87c8f7/gcc%2Ffortran%2Ftrans-openmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-openmp.c?ref=08c14aaaab2b01f1a31989a8d94bae312d87c8f7", "patch": "@@ -47,7 +47,21 @@ along with GCC; see the file COPYING3.  If not see\n \n int ompws_flags;\n \n-/* True if OpenMP should treat this DECL as an optional argument.  */\n+/* True if OpenMP should regard this DECL as being a scalar which has Fortran's\n+   allocatable or pointer attribute.  */\n+\n+bool\n+gfc_omp_is_allocatable_or_ptr (const_tree decl)\n+{\n+  return (DECL_P (decl)\n+\t  && (GFC_DECL_GET_SCALAR_POINTER (decl)\n+\t      || GFC_DECL_GET_SCALAR_ALLOCATABLE (decl)));\n+}\n+\n+/* True if OpenMP should treat this DECL as an optional argument;  note: for\n+   arguments with VALUE attribute, the DECL is identical to nonoptional\n+   arguments; hence, we return false here.  To check whether the variable is\n+   present, use the DECL which is passed as hidden argument.  */\n \n bool\n gfc_omp_is_optional_argument (const_tree decl)\n@@ -2173,7 +2187,8 @@ gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n \t\t      OMP_CLAUSE_DECL (node4) = decl;\n \t\t      OMP_CLAUSE_SIZE (node4) = size_int (0);\n \t\t      decl = build_fold_indirect_ref (decl);\n-\t\t      if (TREE_CODE (TREE_TYPE (orig_decl)) == REFERENCE_TYPE\n+\t\t      if ((TREE_CODE (TREE_TYPE (orig_decl)) == REFERENCE_TYPE\n+\t\t\t   || gfc_omp_is_optional_argument (orig_decl))\n \t\t\t  && (GFC_DECL_GET_SCALAR_POINTER (orig_decl)\n \t\t\t      || GFC_DECL_GET_SCALAR_ALLOCATABLE (orig_decl)))\n \t\t\t{\n@@ -2417,7 +2432,11 @@ gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n \t\t{\n \t\t  tree decl = gfc_trans_omp_variable (n->sym, false);\n \t\t  if (gfc_omp_privatize_by_reference (decl))\n-\t\t    decl = build_fold_indirect_ref (decl);\n+\t\t    {\n+\t\t      if (gfc_omp_is_allocatable_or_ptr (decl))\n+\t\t\tdecl = build_fold_indirect_ref (decl);\n+\t\t      decl = build_fold_indirect_ref (decl);\n+\t\t    }\n \t\t  else if (DECL_P (decl))\n \t\t    TREE_ADDRESSABLE (decl) = 1;\n \t\t  if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (decl)))\n@@ -2439,7 +2458,12 @@ gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n \t\t\t\t       OMP_CLAUSE_SIZE (node), elemsz);\n \t\t    }\n \t\t  else\n-\t\t    OMP_CLAUSE_DECL (node) = decl;\n+\t\t    {\n+\t\t      OMP_CLAUSE_DECL (node) = decl;\n+\t\t      if (gfc_omp_is_allocatable_or_ptr (decl))\n+\t\t\tOMP_CLAUSE_SIZE (node)\n+\t\t\t\t= TYPE_SIZE_UNIT (TREE_TYPE (TREE_TYPE (decl)));\n+\t\t    }\n \t\t}\n \t      else\n \t\t{"}, {"sha": "e96b22acc68f2f6b2c1c97a042f689c57ce713fe", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c14aaaab2b01f1a31989a8d94bae312d87c8f7/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c14aaaab2b01f1a31989a8d94bae312d87c8f7/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=08c14aaaab2b01f1a31989a8d94bae312d87c8f7", "patch": "@@ -786,6 +786,7 @@ struct array_descr_info;\n bool gfc_get_array_descr_info (const_tree, struct array_descr_info *);\n \n /* In trans-openmp.c */\n+bool gfc_omp_is_allocatable_or_ptr (const_tree);\n bool gfc_omp_is_optional_argument (const_tree);\n bool gfc_omp_privatize_by_reference (const_tree);\n enum omp_clause_default_kind gfc_omp_predetermined_sharing (tree);"}, {"sha": "c5dc83d1cc844f0bbc45b37dfdee19c9844b3fc7", "filename": "gcc/langhooks-def.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c14aaaab2b01f1a31989a8d94bae312d87c8f7/gcc%2Flanghooks-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c14aaaab2b01f1a31989a8d94bae312d87c8f7/gcc%2Flanghooks-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks-def.h?ref=08c14aaaab2b01f1a31989a8d94bae312d87c8f7", "patch": "@@ -236,6 +236,7 @@ extern tree lhd_unit_size_without_reusable_padding (tree);\n #define LANG_HOOKS_WARN_UNUSED_GLOBAL_DECL lhd_warn_unused_global_decl\n #define LANG_HOOKS_POST_COMPILATION_PARSING_CLEANUPS NULL\n #define LANG_HOOKS_DECL_OK_FOR_SIBCALL\tlhd_decl_ok_for_sibcall\n+#define LANG_HOOKS_OMP_IS_ALLOCATABLE_OR_PTR hook_bool_const_tree_false\n #define LANG_HOOKS_OMP_IS_OPTIONAL_ARGUMENT hook_bool_const_tree_false\n #define LANG_HOOKS_OMP_PRIVATIZE_BY_REFERENCE hook_bool_const_tree_false\n #define LANG_HOOKS_OMP_PREDETERMINED_SHARING lhd_omp_predetermined_sharing\n@@ -262,6 +263,7 @@ extern tree lhd_unit_size_without_reusable_padding (tree);\n   LANG_HOOKS_WARN_UNUSED_GLOBAL_DECL, \\\n   LANG_HOOKS_POST_COMPILATION_PARSING_CLEANUPS, \\\n   LANG_HOOKS_DECL_OK_FOR_SIBCALL, \\\n+  LANG_HOOKS_OMP_IS_ALLOCATABLE_OR_PTR, \\\n   LANG_HOOKS_OMP_IS_OPTIONAL_ARGUMENT, \\\n   LANG_HOOKS_OMP_PRIVATIZE_BY_REFERENCE, \\\n   LANG_HOOKS_OMP_PREDETERMINED_SHARING, \\"}, {"sha": "97e3186a41d3ae40c865faa76cdda8969a7d2c74", "filename": "gcc/langhooks.h", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c14aaaab2b01f1a31989a8d94bae312d87c8f7/gcc%2Flanghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c14aaaab2b01f1a31989a8d94bae312d87c8f7/gcc%2Flanghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.h?ref=08c14aaaab2b01f1a31989a8d94bae312d87c8f7", "patch": "@@ -222,7 +222,14 @@ struct lang_hooks_for_decls\n   /* True if this decl may be called via a sibcall.  */\n   bool (*ok_for_sibcall) (const_tree);\n \n-  /* True if OpenMP should treat DECL as a Fortran optional argument.  */\n+  /* True if OpenMP should regard this DECL as being a scalar which has Fortran's\n+     allocatable or pointer attribute.  */\n+  bool (*omp_is_allocatable_or_ptr) (const_tree);\n+\n+  /* True if OpenMP should treat DECL as a Fortran optional argument;  note: for\n+     arguments with VALUE attribute, the DECL is identical to nonoptional\n+     arguments; hence, we return false here.  To check whether the variable is\n+     present, use the DECL which is passed as hidden argument.  */\n   bool (*omp_is_optional_argument) (const_tree);\n \n   /* True if OpenMP should privatize what this DECL points to rather"}, {"sha": "1a78a70bd57056093effda7d33a6f2da3eaca0ec", "filename": "gcc/omp-general.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c14aaaab2b01f1a31989a8d94bae312d87c8f7/gcc%2Fomp-general.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c14aaaab2b01f1a31989a8d94bae312d87c8f7/gcc%2Fomp-general.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-general.c?ref=08c14aaaab2b01f1a31989a8d94bae312d87c8f7", "patch": "@@ -48,6 +48,14 @@ omp_find_clause (tree clauses, enum omp_clause_code kind)\n   return NULL_TREE;\n }\n \n+/* True if OpenMP should regard this DECL as being a scalar which has Fortran's\n+   allocatable or pointer attribute.  */\n+bool\n+omp_is_allocatable_or_ptr (tree decl)\n+{\n+  return lang_hooks.decls.omp_is_allocatable_or_ptr (decl);\n+}\n+\n /* Return true if DECL is a Fortran optional argument.  */\n \n bool"}, {"sha": "7cd1d216fc0bfb8af348d0e9e725edfeac2b2577", "filename": "gcc/omp-general.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c14aaaab2b01f1a31989a8d94bae312d87c8f7/gcc%2Fomp-general.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c14aaaab2b01f1a31989a8d94bae312d87c8f7/gcc%2Fomp-general.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-general.h?ref=08c14aaaab2b01f1a31989a8d94bae312d87c8f7", "patch": "@@ -73,6 +73,7 @@ struct omp_for_data\n #define OACC_FN_ATTRIB \"oacc function\"\n \n extern tree omp_find_clause (tree clauses, enum omp_clause_code kind);\n+extern bool omp_is_allocatable_or_ptr (tree decl);\n extern bool omp_is_optional_argument (tree decl);\n extern bool omp_is_reference (tree decl);\n extern void omp_adjust_for_condition (location_t loc, enum tree_code *cond_code,"}, {"sha": "279b6ef893ad704ce503860f5cf70f0652064779", "filename": "gcc/omp-low.c", "status": "modified", "additions": 30, "deletions": 8, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c14aaaab2b01f1a31989a8d94bae312d87c8f7/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c14aaaab2b01f1a31989a8d94bae312d87c8f7/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=08c14aaaab2b01f1a31989a8d94bae312d87c8f7", "patch": "@@ -1241,7 +1241,8 @@ scan_sharing_clauses (tree clauses, omp_context *ctx)\n \tcase OMP_CLAUSE_USE_DEVICE_ADDR:\n \t  decl = OMP_CLAUSE_DECL (c);\n \t  if ((OMP_CLAUSE_CODE (c) == OMP_CLAUSE_USE_DEVICE_ADDR\n-\t       && !omp_is_reference (decl))\n+\t       && !omp_is_reference (decl)\n+\t       && !omp_is_allocatable_or_ptr (decl))\n \t      || TREE_CODE (TREE_TYPE (decl)) == ARRAY_TYPE)\n \t    install_var_field (decl, true, 11, ctx);\n \t  else\n@@ -11483,7 +11484,8 @@ lower_omp_target (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t    DECL_HAS_VALUE_EXPR_P (new_var) = 1;\n \t  }\n \telse if ((OMP_CLAUSE_CODE (c) == OMP_CLAUSE_USE_DEVICE_ADDR\n-\t\t  && !omp_is_reference (var))\n+\t\t  && !omp_is_reference (var)\n+\t\t  && !omp_is_allocatable_or_ptr (var))\n \t\t || TREE_CODE (TREE_TYPE (var)) == ARRAY_TYPE)\n \t  {\n \t    tree new_var = lookup_decl (var, ctx);\n@@ -11678,7 +11680,18 @@ lower_omp_target (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t\t  }\n \t\telse\n \t\t  {\n-\t\t    var = build_fold_addr_expr (var);\n+\t\t    /* While MAP is handled explicitly by the FE,\n+\t\t       for 'target update', only the identified is passed.  */\n+\t\t    if ((OMP_CLAUSE_CODE (c) == OMP_CLAUSE_FROM\n+\t\t\t || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_TO)\n+\t\t\t&& (omp_is_allocatable_or_ptr (var)\n+\t\t\t    && omp_is_optional_argument (var)))\n+\t\t      var = build_fold_indirect_ref (var);\n+\t\t    else if ((OMP_CLAUSE_CODE (c) != OMP_CLAUSE_FROM\n+\t\t\t      && OMP_CLAUSE_CODE (c) != OMP_CLAUSE_TO)\n+\t\t\t     || (!omp_is_allocatable_or_ptr (var)\n+\t\t\t\t && !omp_is_optional_argument (var)))\n+\t\t      var = build_fold_addr_expr (var);\n \t\t    gimplify_assign (x, var, &ilist);\n \t\t  }\n \t      }\n@@ -11865,16 +11878,22 @@ lower_omp_target (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t      }\n \t    type = TREE_TYPE (ovar);\n \t    if ((OMP_CLAUSE_CODE (c) == OMP_CLAUSE_USE_DEVICE_ADDR\n-\t\t && !omp_is_reference (ovar))\n+\t\t && !omp_is_reference (ovar)\n+\t\t && !omp_is_allocatable_or_ptr (ovar))\n \t\t|| TREE_CODE (type) == ARRAY_TYPE)\n \t      var = build_fold_addr_expr (var);\n \t    else\n \t      {\n-\t\tif (omp_is_reference (ovar) || omp_is_optional_argument (ovar))\n+\t\tif (omp_is_reference (ovar)\n+\t\t    || omp_is_optional_argument (ovar)\n+\t\t    || omp_is_allocatable_or_ptr (ovar))\n \t\t  {\n \t\t    type = TREE_TYPE (type);\n \t\t    if (TREE_CODE (type) != ARRAY_TYPE\n-\t\t\t&& OMP_CLAUSE_CODE (c) != OMP_CLAUSE_USE_DEVICE_ADDR)\n+\t\t\t&& ((OMP_CLAUSE_CODE (c) != OMP_CLAUSE_USE_DEVICE_ADDR\n+\t\t\t    && !omp_is_allocatable_or_ptr (ovar))\n+\t\t\t   || (omp_is_reference (ovar)\n+\t\t\t       && omp_is_allocatable_or_ptr (ovar))))\n \t\t      var = build_simple_mem_ref (var);\n \t\t    var = fold_convert (TREE_TYPE (x), var);\n \t\t  }\n@@ -12045,7 +12064,8 @@ lower_omp_target (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t\t\t\t     gimple_build_assign (new_var, x));\n \t      }\n \t    else if ((OMP_CLAUSE_CODE (c) == OMP_CLAUSE_USE_DEVICE_ADDR\n-\t\t      && !omp_is_reference (var))\n+\t\t      && !omp_is_reference (var)\n+\t\t      && !omp_is_allocatable_or_ptr (var))\n \t\t     || TREE_CODE (TREE_TYPE (var)) == ARRAY_TYPE)\n \t      {\n \t\ttree new_var = lookup_decl (var, ctx);\n@@ -12065,7 +12085,9 @@ lower_omp_target (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t\t  {\n \t\t    type = TREE_TYPE (type);\n \t\t    if (TREE_CODE (type) != ARRAY_TYPE\n-\t\t\t&& OMP_CLAUSE_CODE (c) != OMP_CLAUSE_USE_DEVICE_ADDR)\n+\t\t\t&& (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_USE_DEVICE_ADDR\n+\t\t\t    || (omp_is_reference (var)\n+\t\t\t\t&& omp_is_allocatable_or_ptr (var))))\n \t\t      {\n \t\t\ttree v = create_tmp_var_raw (type, get_name (var));\n \t\t\tgimple_add_tmp_var (v);"}, {"sha": "8a3c98b8f9498b540eca94ac63d3be35d7abc546", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c14aaaab2b01f1a31989a8d94bae312d87c8f7/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c14aaaab2b01f1a31989a8d94bae312d87c8f7/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=08c14aaaab2b01f1a31989a8d94bae312d87c8f7", "patch": "@@ -1,3 +1,8 @@\n+2019-10-11  Tobias Burnus  <tobias@codesourcery.com>\n+\n+\t* testsuite/libgomp.fortran/use_device_addr-1.f90: New.\n+\t* testsuite/libgomp.fortran/use_device_addr-2.f90: New.\n+\n 2019-10-09  Thomas Schwinge  <thomas@codesourcery.com>\n \n \tPR middle-end/92036"}, {"sha": "2e5ce60d47caabc65c1c05161cc0f4791b2b1589", "filename": "libgomp/testsuite/libgomp.fortran/use_device_addr-1.f90", "status": "added", "additions": 1196, "deletions": 0, "changes": 1196, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c14aaaab2b01f1a31989a8d94bae312d87c8f7/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fuse_device_addr-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c14aaaab2b01f1a31989a8d94bae312d87c8f7/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fuse_device_addr-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fuse_device_addr-1.f90?ref=08c14aaaab2b01f1a31989a8d94bae312d87c8f7", "patch": "@@ -0,0 +1,1196 @@\n+! Comprehensive run-time test for use_device_addr\n+!\n+! Differs from use_device_addr-2.f90 by using a 8-byte variable (c_double)\n+!\n+! This test case assumes that a 'var' appearing in 'use_device_addr' is\n+! only used as 'c_loc(var)' - such that only the actual data is used/usable\n+! on the device - and not meta data ((dynamic) type information, 'present()'\n+! status, array shape).\n+!\n+! Untested in this test case are:\n+! - arrays with array descriptor\n+! - polymorphic variables\n+! - absent optional arguments\n+!\n+module target_procs\n+  use iso_c_binding\n+  implicit none (type, external)\n+  private\n+  public :: copy3_array, copy3_scalar\n+contains\n+  subroutine copy3_array_int(from_ptr, to_ptr, N)\n+    !$omp declare target\n+    real(c_double) :: from_ptr(:)\n+    real(c_double) :: to_ptr(:)\n+    integer, value :: N\n+    integer :: i\n+\n+    !$omp parallel do\n+    do i = 1, N\n+      to_ptr(i) = 3 * from_ptr(i)\n+    end do\n+    !$omp end parallel do\n+  end subroutine copy3_array_int\n+\n+  subroutine copy3_scalar_int(from, to)\n+    !$omp declare target\n+    real(c_double) :: from, to\n+\n+    to = 3 * from\n+  end subroutine copy3_scalar_int\n+\n+\n+  subroutine copy3_array(from, to, N)\n+    type(c_ptr), value :: from, to\n+    integer, value :: N\n+    real(c_double), pointer :: from_ptr(:), to_ptr(:)\n+\n+    call c_f_pointer(from, from_ptr, shape=[N])\n+    call c_f_pointer(to, to_ptr, shape=[N])\n+\n+    call do_offload_scalar(from_ptr,to_ptr)\n+  contains\n+    subroutine do_offload_scalar(from_r, to_r)\n+      real(c_double), target :: from_r(:), to_r(:)\n+      ! The extra function is needed as is_device_ptr\n+      ! requires non-value, non-pointer dummy arguments\n+\n+      !$omp target is_device_ptr(from_r, to_r)\n+      call copy3_array_int(from_r, to_r, N)\n+      !$omp end target\n+    end subroutine do_offload_scalar\n+  end subroutine copy3_array\n+\n+  subroutine copy3_scalar(from, to)\n+    type(c_ptr), value, target :: from, to\n+    real(c_double), pointer :: from_ptr(:), to_ptr(:)\n+\n+    ! Standard-conform detour of using an array as at time of writing\n+    ! is_device_ptr below does not handle scalars\n+    call c_f_pointer(from, from_ptr, shape=[1])\n+    call c_f_pointer(to, to_ptr, shape=[1])\n+\n+    call do_offload_scalar(from_ptr,to_ptr)\n+  contains\n+    subroutine do_offload_scalar(from_r, to_r)\n+      real(c_double), target :: from_r(:), to_r(:)\n+      ! The extra function is needed as is_device_ptr\n+      ! requires non-value, non-pointer dummy arguments\n+\n+      !$omp target is_device_ptr(from_r, to_r)\n+      call copy3_scalar_int(from_r(1), to_r(1))\n+      !$omp end target\n+    end subroutine do_offload_scalar\n+  end subroutine copy3_scalar\n+end module target_procs\n+\n+\n+\n+! Test local dummy arguments (w/o optional)\n+module test_dummies\n+  use iso_c_binding\n+  use target_procs\n+  implicit none (type, external)\n+  private\n+  public :: test_dummy_call_1, test_dummy_call_2\n+contains\n+  subroutine test_dummy_call_1()\n+     integer, parameter :: N = 1000\n+\n+     ! scalars\n+     real(c_double), target :: aa, bb\n+     real(c_double), target, allocatable :: cc, dd\n+     real(c_double), pointer :: ee, ff\n+\n+     ! non-descriptor arrays\n+     real(c_double), target :: gg(N), hh(N)\n+\n+     allocate(cc, dd, ee, ff)\n+\n+     aa = 11.0_c_double\n+     bb = 22.0_c_double\n+     cc = 33.0_c_double\n+     dd = 44.0_c_double\n+     ee = 55.0_c_double\n+     ff = 66.0_c_double\n+     gg = 77.0_c_double\n+     hh = 88.0_c_double\n+\n+     call test_dummy_callee_1(aa, bb, cc, dd, ee, ff, gg, hh, N)\n+     deallocate(ee, ff) ! pointers, only\n+  end subroutine test_dummy_call_1\n+\n+  subroutine test_dummy_callee_1(aa, bb, cc, dd, ee, ff, gg, hh, N)\n+     ! scalars\n+     real(c_double), target :: aa, bb\n+     real(c_double), target, allocatable :: cc, dd\n+     real(c_double), pointer :: ee, ff\n+\n+     ! non-descriptor arrays\n+     real(c_double), target :: gg(N), hh(N)\n+     integer, value :: N\n+\n+     !$omp target data map(to:aa) map(from:bb) use_device_addr(aa,bb)\n+     call copy3_scalar(c_loc(aa), c_loc(bb))\n+     !$omp end target data\n+     if (abs(aa - 11.0_c_double) > 10.0_c_double * epsilon(aa)) stop 1\n+     if (abs(3.0_c_double * aa - bb) > 10.0_c_double * epsilon(aa)) stop 1\n+\n+     !$omp target data map(to:cc) map(from:dd) use_device_addr(cc,dd)\n+     call copy3_scalar(c_loc(cc), c_loc(dd))\n+     !$omp end target data\n+     if (abs(cc - 33.0_c_double) > 10.0_c_double * epsilon(cc)) stop 1\n+     if (abs(3.0_c_double * cc - dd) > 10.0_c_double * epsilon(cc)) stop 1\n+\n+     !$omp target data map(to:ee) map(from:ff) use_device_addr(ee,ff)\n+     call copy3_scalar(c_loc(ee), c_loc(ff))\n+     !$omp end target data\n+     if (abs(ee - 55.0_c_double) > 10.0_c_double * epsilon(ee)) stop 1\n+     if (abs(3.0_c_double * ee - ff) > 10.0_c_double * epsilon(ee)) stop 1\n+\n+\n+     !$omp target data map(to:gg) map(from:hh) use_device_addr(gg,hh)\n+     call copy3_array(c_loc(gg), c_loc(hh), N)\n+     !$omp end target data\n+     if (any(abs(gg - 77.0_c_double) > 10.0_c_double * epsilon(gg))) stop 1\n+     if (any(abs(3.0_c_double * gg - hh) > 10.0_c_double * epsilon(gg))) stop 1\n+  end subroutine test_dummy_callee_1\n+\n+  ! Save device ptr - and recall pointer\n+  subroutine test_dummy_call_2()\n+     integer, parameter :: N = 1000\n+\n+     ! scalars\n+     real(c_double), target :: aa, bb\n+     real(c_double), target, allocatable :: cc, dd\n+     real(c_double), pointer :: ee, ff\n+\n+     ! non-descriptor arrays\n+     real(c_double), target :: gg(N), hh(N)\n+\n+     type(c_ptr) :: c_aptr, c_bptr, c_cptr, c_dptr, c_eptr, c_fptr, c_gptr, c_hptr\n+     real(c_double), pointer :: aptr, bptr, cptr, dptr, eptr, fptr\n+     real(c_double), pointer :: gptr(:), hptr(:)\n+\n+     allocate(cc, dd, ee, ff)\n+     call test_dummy_callee_2(aa, bb, cc, dd, ee, ff, gg, hh, &\n+                               c_aptr, c_bptr, c_cptr, c_dptr, c_eptr, c_fptr, c_gptr, c_hptr, &\n+                               aptr, bptr, cptr, dptr, eptr, fptr, gptr, hptr, &\n+                               N)\n+     deallocate(ee, ff)\n+  end subroutine test_dummy_call_2\n+\n+  subroutine test_dummy_callee_2(aa, bb, cc, dd, ee, ff, gg, hh, &\n+                                  c_aptr, c_bptr, c_cptr, c_dptr, c_eptr, c_fptr, c_gptr, c_hptr, &\n+                                  aptr, bptr, cptr, dptr, eptr, fptr, gptr, hptr, &\n+                                  N)\n+     ! scalars\n+     real(c_double), target :: aa, bb\n+     real(c_double), target, allocatable :: cc, dd\n+     real(c_double), pointer :: ee, ff\n+\n+     ! non-descriptor arrays\n+     real(c_double), target :: gg(N), hh(N)\n+\n+     type(c_ptr) :: c_aptr, c_bptr, c_cptr, c_dptr, c_eptr, c_fptr, c_gptr, c_hptr\n+     real(c_double), pointer :: aptr, bptr, cptr, dptr, eptr, fptr\n+     real(c_double), pointer :: gptr(:), hptr(:)\n+\n+     integer, value :: N\n+\n+     real(c_double) :: dummy\n+\n+     aa = 111.0_c_double\n+     bb = 222.0_c_double\n+     cc = 333.0_c_double\n+     dd = 444.0_c_double\n+     ee = 555.0_c_double\n+     ff = 666.0_c_double\n+     gg = 777.0_c_double\n+     hh = 888.0_c_double\n+\n+     !$omp target data map(to:aa) map(from:bb)\n+     !$omp target data map(alloc:dummy) use_device_addr(aa,bb)\n+     c_aptr = c_loc(aa)\n+     c_bptr = c_loc(bb)\n+     aptr => aa\n+     bptr => bb\n+     !$omp end target data\n+\n+     ! check c_loc ptr once\n+     call copy3_scalar(c_aptr, c_bptr)\n+     !$omp target update from(bb)\n+     if (abs(aa - 111.0_c_double) > 10.0_c_double * epsilon(aa)) stop 1\n+     if (abs(3.0_c_double * aa - bb) > 10.0_c_double * epsilon(aa)) stop 1\n+\n+     ! check c_loc ptr again after target-value modification\n+     aa = 1111.0_c_double\n+     !$omp target update to(aa)\n+     call copy3_scalar(c_aptr, c_bptr)\n+     !$omp target update from(bb)\n+     if (abs(aa - 1111.0_c_double) > 10.0_c_double * epsilon(aa)) stop 1\n+     if (abs(3.0_c_double * aa - bb) > 10.0_c_double * epsilon(aa)) stop 1\n+\n+     ! check Fortran pointer after target-value modification\n+     aa = 11111.0_c_double\n+     !$omp target update to(aa)\n+     call copy3_scalar(c_loc(aptr), c_loc(bptr))\n+     !$omp target update from(bb)\n+     if (abs(aa - 11111.0_c_double) > 10.0_c_double * epsilon(aa)) stop 1\n+     if (abs(3.0_c_double * aa - bb) > 10.0_c_double * epsilon(aa)) stop 1\n+     !$omp end target data\n+\n+     if (abs(aa - 11111.0_c_double) > 10.0_c_double * epsilon(aa)) stop 1\n+     if (abs(3.0_c_double * aa - bb) > 10.0_c_double * epsilon(aa)) stop 1\n+\n+\n+     !$omp target data map(to:cc) map(from:dd)\n+     !$omp target data map(alloc:dummy) use_device_addr(cc,dd)\n+     c_cptr = c_loc(cc)\n+     c_dptr = c_loc(dd)\n+     cptr => cc\n+     dptr => dd\n+     !$omp end target data\n+\n+     ! check c_loc ptr once\n+     call copy3_scalar(c_cptr, c_dptr)\n+     !$omp target update from(dd)\n+     if (abs(cc - 333.0_c_double) > 10.0_c_double * epsilon(cc)) stop 1\n+     if (abs(3.0_c_double * cc - dd) > 10.0_c_double * epsilon(cc)) stop 1\n+\n+     ! check c_loc ptr again after target-value modification\n+     cc = 3333.0_c_double\n+     !$omp target update to(cc)\n+     call copy3_scalar(c_cptr, c_dptr)\n+     !$omp target update from(dd)\n+     if (abs(cc - 3333.0_c_double) > 10.0_c_double * epsilon(cc)) stop 1\n+     if (abs(3.0_c_double * cc - dd) > 10.0_c_double * epsilon(cc)) stop 1\n+\n+     ! check Fortran pointer after target-value modification\n+     cc = 33333.0_c_double\n+     !$omp target update to(cc)\n+     call copy3_scalar(c_loc(cptr), c_loc(dptr))\n+     !$omp target update from(dd)\n+     if (abs(cc - 33333.0_c_double) > 10.0_c_double * epsilon(cc)) stop 1\n+     if (abs(3.0_c_double * cc - dd) > 10.0_c_double * epsilon(cc)) stop 1\n+     !$omp end target data\n+\n+     if (abs(cc - 33333.0_c_double) > 10.0_c_double * epsilon(dd)) stop 1\n+     if (abs(3.0_c_double * cc - dd) > 10.0_c_double * epsilon(dd)) stop 1\n+\n+\n+     !$omp target data map(to:ee) map(from:ff)\n+     !$omp target data map(alloc:dummy) use_device_addr(ee,ff)\n+     c_eptr = c_loc(ee)\n+     c_fptr = c_loc(ff)\n+     eptr => ee\n+     fptr => ff\n+     !$omp end target data\n+\n+     ! check c_loc ptr once\n+     call copy3_scalar(c_eptr, c_fptr)\n+     !$omp target update from(ff)\n+     if (abs(ee - 555.0_c_double) > 10.0_c_double * epsilon(ee)) stop 1\n+     if (abs(3.0_c_double * ee - ff) > 10.0_c_double * epsilon(ee)) stop 1\n+\n+     ! check c_loc ptr again after target-value modification\n+     ee = 5555.0_c_double\n+     !$omp target update to(ee)\n+     call copy3_scalar(c_eptr, c_fptr)\n+     !$omp target update from(ff)\n+     if (abs(ee - 5555.0_c_double) > 10.0_c_double * epsilon(ee)) stop 1\n+     if (abs(3.0_c_double * ee - ff) > 10.0_c_double * epsilon(ee)) stop 1\n+\n+     ! check Fortran pointer after target-value modification\n+     ee = 55555.0_c_double\n+     !$omp target update to(ee)\n+     call copy3_scalar(c_loc(eptr), c_loc(fptr))\n+     !$omp target update from(ff)\n+     if (abs(ee - 55555.0_c_double) > 10.0_c_double * epsilon(ee)) stop 1\n+     if (abs(3.0_c_double * ee - ff) > 10.0_c_double * epsilon(ff)) stop 1\n+     !$omp end target data\n+\n+     if (abs(ee - 55555.0_c_double) > 10.0_c_double * epsilon(ee)) stop 1\n+     if (abs(3.0_c_double * ee - ff) > 10.0_c_double * epsilon(ee)) stop 1\n+\n+\n+     !$omp target data map(to:gg) map(from:hh)\n+     !$omp target data map(alloc:dummy) use_device_addr(gg,hh)\n+     c_gptr = c_loc(gg)\n+     c_hptr = c_loc(hh)\n+     gptr => gg\n+     hptr => hh\n+     !$omp end target data\n+\n+     ! check c_loc ptr once\n+     call copy3_array(c_gptr, c_hptr, N)\n+     !$omp target update from(hh)\n+     if (any(abs(gg - 777.0_c_double) > 10.0_c_double * epsilon(gg))) stop 1\n+     if (any(abs(3.0_c_double * gg - hh) > 10.0_c_double * epsilon(hh))) stop 1\n+\n+     ! check c_loc ptr again after target-value modification\n+     gg = 7777.0_c_double\n+     !$omp target update to(gg)\n+     call copy3_array(c_gptr, c_hptr, N)\n+     !$omp target update from(hh)\n+     if (any(abs(gg - 7777.0_c_double) > 10.0_c_double * epsilon(gg))) stop 1\n+     if (any(abs(3.0_c_double * gg - hh) > 10.0_c_double * epsilon(gg))) stop 1\n+\n+     ! check Fortran pointer after target-value modification\n+     gg = 77777.0_c_double\n+     !$omp target update to(gg)\n+     call copy3_array(c_loc(gptr), c_loc(hptr), N)\n+     !$omp target update from(hh)\n+     if (any(abs(gg - 77777.0_c_double) > 10.0_c_double * epsilon(gg))) stop 1\n+     if (any(abs(3.0_c_double * gg - hh) > 10.0_c_double * epsilon(gg))) stop 1\n+     !$omp end target data\n+\n+     if (any(abs(gg - 77777.0_c_double) > 10.0_c_double * epsilon(gg))) stop 1\n+     if (any(abs(3.0_c_double * gg - hh) > 10.0_c_double * epsilon(gg))) stop 1\n+  end subroutine test_dummy_callee_2\n+end module test_dummies\n+\n+\n+\n+! Test local dummy arguments + VALUE (w/o optional)\n+module test_dummies_value\n+  use iso_c_binding\n+  use target_procs\n+  implicit none (type, external)\n+  private\n+  public :: test_dummy_val_call_1, test_dummy_val_call_2\n+contains\n+  subroutine test_dummy_val_call_1()\n+     ! scalars - with value, neither allocatable nor pointer no dimension permitted\n+     real(c_double), target :: aa, bb\n+\n+     aa = 11.0_c_double\n+     bb = 22.0_c_double\n+\n+     call test_dummy_val_callee_1(aa, bb)\n+  end subroutine test_dummy_val_call_1\n+\n+  subroutine test_dummy_val_callee_1(aa, bb)\n+     ! scalars\n+     real(c_double), value, target :: aa, bb\n+\n+     !$omp target data map(to:aa) map(from:bb) use_device_addr(aa,bb)\n+     call copy3_scalar(c_loc(aa), c_loc(bb))\n+     !$omp end target data\n+     if (abs(aa - 11.0_c_double) > 10.0_c_double * epsilon(aa)) stop 1\n+     if (abs(3.0_c_double * aa - bb) > 10.0_c_double * epsilon(aa)) stop 1\n+  end subroutine test_dummy_val_callee_1\n+\n+  ! Save device ptr - and recall pointer\n+  subroutine test_dummy_val_call_2()\n+     ! scalars - with value, neither allocatable nor pointer no dimension permitted\n+     real(c_double), target :: aa, bb\n+     type(c_ptr) :: c_aptr, c_bptr\n+     real(c_double), pointer :: aptr, bptr\n+\n+     call test_dummy_val_callee_2(aa, bb, c_aptr, c_bptr, aptr, bptr)\n+  end subroutine test_dummy_val_call_2\n+\n+  subroutine test_dummy_val_callee_2(aa, bb, c_aptr, c_bptr, aptr, bptr)\n+     real(c_double), value, target :: aa, bb\n+     type(c_ptr), value :: c_aptr, c_bptr\n+     real(c_double), pointer :: aptr, bptr\n+\n+     real(c_double) :: dummy\n+\n+     aa = 111.0_c_double\n+     bb = 222.0_c_double\n+\n+     !$omp target data map(to:aa) map(from:bb)\n+     !$omp target data map(alloc:dummy) use_device_addr(aa,bb)\n+     c_aptr = c_loc(aa)\n+     c_bptr = c_loc(bb)\n+     aptr => aa\n+     bptr => bb\n+     !$omp end target data\n+\n+     ! check c_loc ptr once\n+     call copy3_scalar(c_aptr, c_bptr)\n+     !$omp target update from(bb)\n+     if (abs(aa - 111.0_c_double) > 10.0_c_double * epsilon(aa)) stop 1\n+     if (abs(3.0_c_double * aa - bb) > 10.0_c_double * epsilon(aa)) stop 1\n+\n+     ! check c_loc ptr again after target-value modification\n+     aa = 1111.0_c_double\n+     !$omp target update to(aa)\n+     call copy3_scalar(c_aptr, c_bptr)\n+     !$omp target update from(bb)\n+     if (abs(aa - 1111.0_c_double) > 10.0_c_double * epsilon(aa)) stop 1\n+     if (abs(3.0_c_double * aa - bb) > 10.0_c_double * epsilon(aa)) stop 1\n+\n+     ! check Fortran pointer after target-value modification\n+     aa = 11111.0_c_double\n+     !$omp target update to(aa)\n+     call copy3_scalar(c_loc(aptr), c_loc(bptr))\n+     !$omp target update from(bb)\n+     if (abs(aa - 11111.0_c_double) > 10.0_c_double * epsilon(aa)) stop 1\n+     if (abs(3.0_c_double * aa - bb) > 10.0_c_double * epsilon(aa)) stop 1\n+     !$omp end target data\n+\n+     if (abs(aa - 11111.0_c_double) > 10.0_c_double * epsilon(aa)) stop 1\n+     if (abs(3.0_c_double * aa - bb) > 10.0_c_double * epsilon(aa)) stop 1\n+  end subroutine test_dummy_val_callee_2\n+end module test_dummies_value\n+\n+\n+\n+! Test local dummy arguments + OPTIONAL\n+! Values present and ptr associated to nonzero\n+module test_dummies_opt\n+  use iso_c_binding\n+  use target_procs\n+  implicit none (type, external)\n+  private\n+  public :: test_dummy_opt_call_1, test_dummy_opt_call_2\n+contains\n+  subroutine test_dummy_opt_call_1()\n+     integer, parameter :: N = 1000\n+\n+     ! scalars\n+     real(c_double), target :: aa, bb\n+     real(c_double), target, allocatable :: cc, dd\n+     real(c_double), pointer :: ee, ff\n+\n+     ! non-descriptor arrays\n+     real(c_double), target :: gg(N), hh(N)\n+\n+     allocate(cc, dd, ee, ff)\n+\n+     aa = 11.0_c_double\n+     bb = 22.0_c_double\n+     cc = 33.0_c_double\n+     dd = 44.0_c_double\n+     ee = 55.0_c_double\n+     ff = 66.0_c_double\n+     gg = 77.0_c_double\n+     hh = 88.0_c_double\n+\n+     call test_dummy_opt_callee_1(aa, bb, cc, dd, ee, ff, gg, hh, N)\n+     deallocate(ee, ff) ! pointers, only\n+  end subroutine test_dummy_opt_call_1\n+\n+  subroutine test_dummy_opt_callee_1(aa, bb, cc, dd, ee, ff, gg, hh, N)\n+     ! scalars\n+     real(c_double), optional, target :: aa, bb\n+     real(c_double), optional, target, allocatable :: cc, dd\n+     real(c_double), optional, pointer :: ee, ff\n+\n+     ! non-descriptor arrays\n+     real(c_double), optional, target :: gg(N), hh(N)\n+     integer, value :: N\n+\n+     ! All shall be present - and pointing to non-NULL\n+     if (.not.present(aa) .or. .not.present(bb)) stop 1\n+     if (.not.present(cc) .or. .not.present(dd)) stop 1\n+     if (.not.present(ee) .or. .not.present(ff)) stop 1\n+     if (.not.present(gg) .or. .not.present(hh)) stop 1\n+\n+     if (.not.associated(ee) .or. .not.associated(ff)) stop 1\n+\n+     !$omp target data map(to:aa) map(from:bb) use_device_addr(aa,bb)\n+     if (.not.present(aa) .or. .not.present(bb)) stop 1\n+     if (.not.c_associated(c_loc(aa)) .or. .not.c_associated(c_loc(bb))) stop 1\n+     call copy3_scalar(c_loc(aa), c_loc(bb))\n+     !$omp end target data\n+     if (abs(aa - 11.0_c_double) > 10.0_c_double * epsilon(aa)) stop 1\n+     if (abs(3.0_c_double * aa - bb) > 10.0_c_double * epsilon(aa)) stop 1\n+\n+     !$omp target data map(to:cc) map(from:dd) use_device_addr(cc,dd)\n+     if (.not.present(cc) .or. .not.present(dd)) stop 1\n+     if (.not.c_associated(c_loc(cc)) .or. .not.c_associated(c_loc(dd))) stop 1\n+     call copy3_scalar(c_loc(cc), c_loc(dd))\n+     !$omp end target data\n+     if (abs(cc - 33.0_c_double) > 10.0_c_double * epsilon(cc)) stop 1\n+     if (abs(3.0_c_double * cc - dd) > 10.0_c_double * epsilon(cc)) stop 1\n+\n+     !$omp target data map(to:ee) map(from:ff) use_device_addr(ee,ff)\n+     if (.not.present(ee) .or. .not.present(ff)) stop 1\n+     if (.not.associated(ee) .or. .not.associated(ff)) stop 1\n+     if (.not.c_associated(c_loc(ee)) .or. .not.c_associated(c_loc(ff))) stop 1\n+     call copy3_scalar(c_loc(ee), c_loc(ff))\n+     !$omp end target data\n+     if (abs(ee - 55.0_c_double) > 10.0_c_double * epsilon(ee)) stop 1\n+     if (abs(3.0_c_double * ee - ff) > 10.0_c_double * epsilon(ee)) stop 1\n+\n+     !$omp target data map(to:gg) map(from:hh) use_device_addr(gg,hh)\n+     if (.not.present(gg) .or. .not.present(hh)) stop 1\n+     if (.not.c_associated(c_loc(gg)) .or. .not.c_associated(c_loc(hh))) stop 1\n+     call copy3_array(c_loc(gg), c_loc(hh), N)\n+     !$omp end target data\n+     if (any(abs(gg - 77.0_c_double) > 10.0_c_double * epsilon(gg))) stop 1\n+     if (any(abs(3.0_c_double * gg - hh) > 10.0_c_double * epsilon(gg))) stop 1\n+  end subroutine test_dummy_opt_callee_1\n+\n+  ! Save device ptr - and recall pointer\n+  subroutine test_dummy_opt_call_2()\n+     integer, parameter :: N = 1000\n+\n+     ! scalars\n+     real(c_double), target :: aa, bb\n+     real(c_double), target, allocatable :: cc, dd\n+     real(c_double), pointer :: ee, ff\n+\n+     ! non-descriptor arrays\n+     real(c_double), target :: gg(N), hh(N)\n+\n+     type(c_ptr) :: c_aptr, c_bptr, c_cptr, c_dptr, c_eptr, c_fptr, c_gptr, c_hptr\n+     real(c_double), pointer :: aptr, bptr, cptr, dptr, eptr, fptr\n+     real(c_double), pointer :: gptr(:), hptr(:)\n+\n+     allocate(cc, dd, ee, ff)\n+     call test_dummy_opt_callee_2(aa, bb, cc, dd, ee, ff, gg, hh, &\n+                                   c_aptr, c_bptr, c_cptr, c_dptr, c_eptr, c_fptr, c_gptr, c_hptr, &\n+                                   aptr, bptr, cptr, dptr, eptr, fptr, gptr, hptr, &\n+                                   N)\n+     deallocate(ee, ff)\n+  end subroutine test_dummy_opt_call_2\n+\n+  subroutine test_dummy_opt_callee_2(aa, bb, cc, dd, ee, ff, gg, hh, &\n+                                      c_aptr, c_bptr, c_cptr, c_dptr, c_eptr, c_fptr, c_gptr, c_hptr, &\n+                                      aptr, bptr, cptr, dptr, eptr, fptr, gptr, hptr, &\n+                                      N)\n+     ! scalars\n+     real(c_double), optional, target :: aa, bb\n+     real(c_double), optional, target, allocatable :: cc, dd\n+     real(c_double), optional, pointer :: ee, ff\n+\n+     ! non-descriptor arrays\n+     real(c_double), optional, target :: gg(N), hh(N)\n+\n+     type(c_ptr) :: c_aptr, c_bptr, c_cptr, c_dptr, c_eptr, c_fptr, c_gptr, c_hptr\n+     real(c_double), optional, pointer :: aptr, bptr, cptr, dptr, eptr, fptr\n+     real(c_double), optional, pointer :: gptr(:), hptr(:)\n+\n+     integer, value :: N\n+\n+     real(c_double) :: dummy\n+\n+     ! All shall be present - and pointing to non-NULL\n+     if (.not.present(aa) .or. .not.present(bb)) stop 1\n+     if (.not.present(cc) .or. .not.present(dd)) stop 1\n+     if (.not.present(ee) .or. .not.present(ff)) stop 1\n+     if (.not.present(gg) .or. .not.present(hh)) stop 1\n+\n+     if (.not.associated(ee) .or. .not.associated(ff)) stop 1\n+\n+     aa = 111.0_c_double\n+     bb = 222.0_c_double\n+     cc = 333.0_c_double\n+     dd = 444.0_c_double\n+     ee = 555.0_c_double\n+     ff = 666.0_c_double\n+     gg = 777.0_c_double\n+     hh = 888.0_c_double\n+\n+     !$omp target data map(to:aa) map(from:bb)\n+     !$omp target data map(alloc:dummy) use_device_addr(aa,bb)\n+     if (.not.present(aa) .or. .not.present(bb)) stop 1\n+     if (.not.c_associated(c_loc(aa)) .or. .not.c_associated(c_loc(bb))) stop 1\n+     c_aptr = c_loc(aa)\n+     c_bptr = c_loc(bb)\n+     aptr => aa\n+     bptr => bb\n+     if (.not.c_associated(c_aptr) .or. .not.c_associated(c_bptr)) stop 1\n+     if (.not.associated(aptr) .or. .not.associated(bptr)) stop 1\n+     !$omp end target data\n+\n+     if (.not.present(aa) .or. .not.present(bb)) stop 1\n+     if (.not.c_associated(c_loc(aa)) .or. .not.c_associated(c_loc(bb))) stop 1\n+     if (.not.c_associated(c_aptr) .or. .not.c_associated(c_bptr)) stop 1\n+     if (.not.associated(aptr) .or. .not.associated(bptr)) stop 1\n+\n+     ! check c_loc ptr once\n+     call copy3_scalar(c_aptr, c_bptr)\n+     !$omp target update from(bb)\n+     if (abs(aa - 111.0_c_double) > 10.0_c_double * epsilon(aa)) stop 1\n+     if (abs(3.0_c_double * aa - bb) > 10.0_c_double * epsilon(aa)) stop 1\n+\n+     ! check c_loc ptr again after target-value modification\n+     aa = 1111.0_c_double\n+     !$omp target update to(aa)\n+     call copy3_scalar(c_aptr, c_bptr)\n+     !$omp target update from(bb)\n+     if (abs(aa - 1111.0_c_double) > 10.0_c_double * epsilon(aa)) stop 1\n+     if (abs(3.0_c_double * aa - bb) > 10.0_c_double * epsilon(aa)) stop 1\n+\n+     ! check Fortran pointer after target-value modification\n+     aa = 11111.0_c_double\n+     !$omp target update to(aa)\n+     call copy3_scalar(c_loc(aptr), c_loc(bptr))\n+     !$omp target update from(bb)\n+     if (abs(aa - 11111.0_c_double) > 10.0_c_double * epsilon(aa)) stop 1\n+     if (abs(3.0_c_double * aa - bb) > 10.0_c_double * epsilon(aa)) stop 1\n+     !$omp end target data\n+\n+     if (abs(aa - 11111.0_c_double) > 10.0_c_double * epsilon(aa)) stop 1\n+     if (abs(3.0_c_double * aa - bb) > 10.0_c_double * epsilon(aa)) stop 1\n+\n+\n+     !$omp target data map(to:cc) map(from:dd)\n+     !$omp target data map(alloc:dummy) use_device_addr(cc,dd)\n+     if (.not.present(cc) .or. .not.present(dd)) stop 1\n+     if (.not.c_associated(c_loc(cc)) .or. .not.c_associated(c_loc(dd))) stop 1\n+     c_cptr = c_loc(cc)\n+     c_dptr = c_loc(dd)\n+     cptr => cc\n+     dptr => dd\n+     if (.not.c_associated(c_cptr) .or. .not.c_associated(c_dptr)) stop 1\n+     if (.not.associated(cptr) .or. .not.associated(dptr)) stop 1\n+     !$omp end target data\n+     if (.not.present(cc) .or. .not.present(dd)) stop 1\n+     if (.not.c_associated(c_loc(cc)) .or. .not.c_associated(c_loc(dd))) stop 1\n+     if (.not.c_associated(c_cptr) .or. .not.c_associated(c_dptr)) stop 1\n+     if (.not.associated(cptr) .or. .not.associated(dptr)) stop 1\n+\n+     ! check c_loc ptr once\n+     call copy3_scalar(c_cptr, c_dptr)\n+     !$omp target update from(dd)\n+     if (abs(cc - 333.0_c_double) > 10.0_c_double * epsilon(cc)) stop 1\n+     if (abs(3.0_c_double * cc - dd) > 10.0_c_double * epsilon(cc)) stop 1\n+\n+     ! check c_loc ptr again after target-value modification\n+     cc = 3333.0_c_double\n+     !$omp target update to(cc)\n+     call copy3_scalar(c_cptr, c_dptr)\n+     !$omp target update from(dd)\n+     if (abs(cc - 3333.0_c_double) > 10.0_c_double * epsilon(cc)) stop 1\n+     if (abs(3.0_c_double * cc - dd) > 10.0_c_double * epsilon(cc)) stop 1\n+\n+     ! check Fortran pointer after target-value modification\n+     cc = 33333.0_c_double\n+     !$omp target update to(cc)\n+     call copy3_scalar(c_loc(cptr), c_loc(dptr))\n+     !$omp target update from(dd)\n+     if (abs(cc - 33333.0_c_double) > 10.0_c_double * epsilon(cc)) stop 1\n+     if (abs(3.0_c_double * cc - dd) > 10.0_c_double * epsilon(cc)) stop 1\n+     !$omp end target data\n+\n+     if (abs(cc - 33333.0_c_double) > 10.0_c_double * epsilon(dd)) stop 1\n+     if (abs(3.0_c_double * cc - dd) > 10.0_c_double * epsilon(dd)) stop 1\n+\n+\n+     !$omp target data map(to:ee) map(from:ff)\n+     !$omp target data map(alloc:dummy) use_device_addr(ee,ff)\n+     if (.not.present(ee) .or. .not.present(ff)) stop 1\n+     if (.not.associated(ee) .or. .not.associated(ff)) stop 1\n+     if (.not.c_associated(c_loc(ee)) .or. .not.c_associated(c_loc(ff))) stop 1\n+     c_eptr = c_loc(ee)\n+     c_fptr = c_loc(ff)\n+     eptr => ee\n+     fptr => ff\n+     if (.not.c_associated(c_eptr) .or. .not.c_associated(c_fptr)) stop 1\n+     if (.not.associated(eptr) .or. .not.associated(fptr)) stop 1\n+     !$omp end target data\n+     if (.not.present(ee) .or. .not.present(ff)) stop 1\n+     if (.not.associated(ee) .or. .not.associated(ff)) stop 1\n+     if (.not.c_associated(c_loc(ee)) .or. .not.c_associated(c_loc(ff))) stop 1\n+     if (.not.c_associated(c_eptr) .or. .not.c_associated(c_fptr)) stop 1\n+     if (.not.associated(eptr) .or. .not.associated(fptr)) stop 1\n+\n+     ! check c_loc ptr once\n+     call copy3_scalar(c_eptr, c_fptr)\n+     !$omp target update from(ff)\n+     if (abs(ee - 555.0_c_double) > 10.0_c_double * epsilon(ee)) stop 1\n+     if (abs(3.0_c_double * ee - ff) > 10.0_c_double * epsilon(ee)) stop 1\n+\n+     ! check c_loc ptr again after target-value modification\n+     ee = 5555.0_c_double\n+     !$omp target update to(ee)\n+     call copy3_scalar(c_eptr, c_fptr)\n+     !$omp target update from(ff)\n+     if (abs(ee - 5555.0_c_double) > 10.0_c_double * epsilon(ee)) stop 1\n+     if (abs(3.0_c_double * ee - ff) > 10.0_c_double * epsilon(ee)) stop 1\n+\n+     ! check Fortran pointer after target-value modification\n+     ee = 55555.0_c_double\n+     !$omp target update to(ee)\n+     call copy3_scalar(c_loc(eptr), c_loc(fptr))\n+     !$omp target update from(ff)\n+     if (abs(ee - 55555.0_c_double) > 10.0_c_double * epsilon(ee)) stop 1\n+     if (abs(3.0_c_double * ee - ff) > 10.0_c_double * epsilon(ff)) stop 1\n+     !$omp end target data\n+\n+     if (abs(ee - 55555.0_c_double) > 10.0_c_double * epsilon(ee)) stop 1\n+     if (abs(3.0_c_double * ee - ff) > 10.0_c_double * epsilon(ee)) stop 1\n+\n+\n+     !$omp target data map(to:gg) map(from:hh)\n+     !$omp target data map(alloc:dummy) use_device_addr(gg,hh)\n+     if (.not.present(gg) .or. .not.present(hh)) stop 1\n+     if (.not.c_associated(c_loc(gg)) .or. .not.c_associated(c_loc(hh))) stop 1\n+     c_gptr = c_loc(gg)\n+     c_hptr = c_loc(hh)\n+     gptr => gg\n+     hptr => hh\n+     if (.not.c_associated(c_gptr) .or. .not.c_associated(c_hptr)) stop 1\n+     if (.not.associated(gptr) .or. .not.associated(hptr)) stop 1\n+     !$omp end target data\n+     if (.not.present(gg) .or. .not.present(hh)) stop 1\n+     if (.not.c_associated(c_loc(gg)) .or. .not.c_associated(c_loc(hh))) stop 1\n+     if (.not.c_associated(c_gptr) .or. .not.c_associated(c_hptr)) stop 1\n+     if (.not.associated(gptr) .or. .not.associated(hptr)) stop 1\n+\n+     ! check c_loc ptr once\n+     call copy3_array(c_gptr, c_hptr, N)\n+     !$omp target update from(hh)\n+     if (any(abs(gg - 777.0_c_double) > 10.0_c_double * epsilon(gg))) stop 1\n+     if (any(abs(3.0_c_double * gg - hh) > 10.0_c_double * epsilon(hh))) stop 1\n+\n+     ! check c_loc ptr again after target-value modification\n+     gg = 7777.0_c_double\n+     !$omp target update to(gg)\n+     call copy3_array(c_gptr, c_hptr, N)\n+     !$omp target update from(hh)\n+     if (any(abs(gg - 7777.0_c_double) > 10.0_c_double * epsilon(gg))) stop 1\n+     if (any(abs(3.0_c_double * gg - hh) > 10.0_c_double * epsilon(gg))) stop 1\n+\n+     ! check Fortran pointer after target-value modification\n+     gg = 77777.0_c_double\n+     !$omp target update to(gg)\n+     call copy3_array(c_loc(gptr), c_loc(hptr), N)\n+     !$omp target update from(hh)\n+     if (any(abs(gg - 77777.0_c_double) > 10.0_c_double * epsilon(gg))) stop 1\n+     if (any(abs(3.0_c_double * gg - hh) > 10.0_c_double * epsilon(gg))) stop 1\n+     !$omp end target data\n+\n+     if (any(abs(gg - 77777.0_c_double) > 10.0_c_double * epsilon(gg))) stop 1\n+     if (any(abs(3.0_c_double * gg - hh) > 10.0_c_double * epsilon(gg))) stop 1\n+  end subroutine test_dummy_opt_callee_2\n+end module test_dummies_opt\n+\n+\n+\n+! Test local dummy arguments + OPTIONAL + VALUE\n+! Values present\n+module test_dummies_opt_value\n+  use iso_c_binding\n+  use target_procs\n+  implicit none (type, external)\n+  private\n+  public :: test_dummy_opt_val_call_1, test_dummy_opt_val_call_2\n+contains\n+  subroutine test_dummy_opt_val_call_1()\n+     ! scalars - with value, neither allocatable nor pointer no dimension permitted\n+     real(c_double), target :: aa, bb\n+\n+     aa = 11.0_c_double\n+     bb = 22.0_c_double\n+\n+     call test_dummy_opt_val_callee_1(aa, bb)\n+  end subroutine test_dummy_opt_val_call_1\n+\n+  subroutine test_dummy_opt_val_callee_1(aa, bb)\n+     ! scalars\n+     real(c_double), optional, value, target :: aa, bb\n+\n+     if (.not.present(aa) .or. .not.present(bb)) stop 1\n+\n+     !$omp target data map(to:aa) map(from:bb) use_device_addr(aa,bb)\n+     if (.not.present(aa) .or. .not.present(bb)) stop 1\n+     if (.not.c_associated(c_loc(aa)) .or. .not.c_associated(c_loc(bb))) stop 1\n+     call copy3_scalar(c_loc(aa), c_loc(bb))\n+     !$omp end target data\n+     if (abs(aa - 11.0_c_double) > 10.0_c_double * epsilon(aa)) stop 1\n+     if (abs(3.0_c_double * aa - bb) > 10.0_c_double * epsilon(aa)) stop 1\n+  end subroutine test_dummy_opt_val_callee_1\n+\n+  ! Save device ptr - and recall pointer\n+  subroutine test_dummy_opt_val_call_2()\n+     ! scalars - with value, neither allocatable nor pointer no dimension permitted\n+     real(c_double), target :: aa, bb\n+     type(c_ptr) :: c_aptr, c_bptr\n+     real(c_double), pointer :: aptr, bptr\n+\n+     call test_dummy_opt_val_callee_2(aa, bb, c_aptr, c_bptr, aptr, bptr)\n+  end subroutine test_dummy_opt_val_call_2\n+\n+  subroutine test_dummy_opt_val_callee_2(aa, bb, c_aptr, c_bptr, aptr, bptr)\n+     real(c_double), optional, value, target :: aa, bb\n+     type(c_ptr), optional, value :: c_aptr, c_bptr\n+     real(c_double), optional, pointer :: aptr, bptr\n+\n+     real(c_double) :: dummy\n+\n+     if (.not.present(aa) .or. .not.present(bb)) stop 1\n+     if (.not.present(c_aptr) .or. .not.present(c_bptr)) stop 1\n+     if (.not.present(aptr) .or. .not.present(bptr)) stop 1\n+\n+     aa = 111.0_c_double\n+     bb = 222.0_c_double\n+\n+     !$omp target data map(to:aa) map(from:bb)\n+     if (.not.present(aa) .or. .not.present(bb)) stop 1\n+     if (.not.present(c_aptr) .or. .not.present(c_bptr)) stop 1\n+     if (.not.present(aptr) .or. .not.present(bptr)) stop 1\n+\n+     !$omp target data map(alloc:dummy) use_device_addr(aa,bb)\n+     if (.not.present(aa) .or. .not.present(bb)) stop 1\n+     if (.not.present(c_aptr) .or. .not.present(c_bptr)) stop 1\n+     if (.not.present(aptr) .or. .not.present(bptr)) stop 1\n+\n+     c_aptr = c_loc(aa)\n+     c_bptr = c_loc(bb)\n+     aptr => aa\n+     bptr => bb\n+     if (.not.c_associated(c_aptr) .or. .not.c_associated(c_bptr)) stop 1\n+     if (.not.associated(aptr) .or. .not.associated(bptr)) stop 1\n+     !$omp end target data\n+\n+     ! check c_loc ptr once\n+     call copy3_scalar(c_aptr, c_bptr)\n+     !$omp target update from(bb)\n+     if (abs(aa - 111.0_c_double) > 10.0_c_double * epsilon(aa)) stop 1\n+     if (abs(3.0_c_double * aa - bb) > 10.0_c_double * epsilon(aa)) stop 1\n+\n+     ! check c_loc ptr again after target-value modification\n+     aa = 1111.0_c_double\n+     !$omp target update to(aa)\n+     call copy3_scalar(c_aptr, c_bptr)\n+     !$omp target update from(bb)\n+     if (abs(aa - 1111.0_c_double) > 10.0_c_double * epsilon(aa)) stop 1\n+     if (abs(3.0_c_double * aa - bb) > 10.0_c_double * epsilon(aa)) stop 1\n+\n+     ! check Fortran pointer after target-value modification\n+     aa = 11111.0_c_double\n+     !$omp target update to(aa)\n+     call copy3_scalar(c_loc(aptr), c_loc(bptr))\n+     !$omp target update from(bb)\n+     if (abs(aa - 11111.0_c_double) > 10.0_c_double * epsilon(aa)) stop 1\n+     if (abs(3.0_c_double * aa - bb) > 10.0_c_double * epsilon(aa)) stop 1\n+     !$omp end target data\n+\n+     if (abs(aa - 11111.0_c_double) > 10.0_c_double * epsilon(aa)) stop 1\n+     if (abs(3.0_c_double * aa - bb) > 10.0_c_double * epsilon(aa)) stop 1\n+  end subroutine test_dummy_opt_val_callee_2\n+end module test_dummies_opt_value\n+\n+\n+\n+! Test nullptr\n+module test_nullptr\n+  use iso_c_binding\n+  implicit none (type, external)\n+  private\n+  public :: test_nullptr_1\n+contains\n+  subroutine test_nullptr_1()\n+     ! scalars\n+     real(c_double), pointer :: aa, bb\n+     real(c_double), pointer :: ee, ff\n+\n+     type(c_ptr) :: c_aptr, c_bptr, c_eptr, c_fptr\n+     real(c_double), pointer :: aptr, bptr, eptr, fptr\n+\n+     aa => null()\n+     bb => null()\n+     ee => null()\n+     ff => null()\n+\n+     if (associated(aa) .or. associated(bb)) stop 1\n+     !$omp target data map(to:aa) map(from:bb) use_device_addr(aa,bb)\n+     if (c_associated(c_loc(aa)) .or. c_associated(c_loc(bb))) stop 1\n+     c_aptr = c_loc(aa)\n+     c_bptr = c_loc(bb)\n+     aptr => aa\n+     bptr => bb\n+     if (c_associated(c_aptr) .or. c_associated(c_bptr)) stop 1\n+     if (associated(aptr) .or. associated(bptr, bb)) stop 1\n+     !$omp end target data\n+     if (c_associated(c_aptr) .or. c_associated(c_bptr)) stop 1\n+     if (associated(aptr) .or. associated(bptr, bb)) stop 1\n+\n+     call test_dummy_opt_nullptr_callee_1(ee, ff, c_eptr, c_fptr, eptr, fptr)\n+  end subroutine test_nullptr_1\n+\n+  subroutine test_dummy_opt_nullptr_callee_1(ee, ff, c_eptr, c_fptr, eptr, fptr)\n+     ! scalars\n+     real(c_double), optional, pointer :: ee, ff\n+\n+     type(c_ptr), optional :: c_eptr, c_fptr\n+     real(c_double), optional, pointer :: eptr, fptr\n+\n+     if (.not.present(ee) .or. .not.present(ff)) stop 1\n+     if (associated(ee) .or. associated(ff)) stop 1\n+\n+     !$omp target data map(to:ee) map(from:ff) use_device_addr(ee,ff)\n+     if (.not.present(ee) .or. .not.present(ff)) stop 1\n+     if (associated(ee) .or. associated(ff)) stop 1\n+     if (c_associated(c_loc(ee)) .or. c_associated(c_loc(ff))) stop 1\n+     c_eptr = c_loc(ee)\n+     c_fptr = c_loc(ff)\n+     eptr => ee\n+     fptr => ff\n+     if (c_associated(c_eptr) .or. c_associated(c_fptr)) stop 1\n+     if (associated(eptr) .or. associated(fptr)) stop 1\n+     !$omp end target data\n+\n+     if (c_associated(c_eptr) .or. c_associated(c_fptr)) stop 1\n+     if (associated(eptr) .or. associated(fptr)) stop 1\n+  end subroutine test_dummy_opt_nullptr_callee_1\n+end module test_nullptr\n+\n+\n+\n+! Test local variables\n+module tests\n+  use iso_c_binding\n+  use target_procs\n+  implicit none (type, external)\n+  private\n+  public :: test_main_1, test_main_2\n+contains\n+   ! map + use_device_addr + c_loc\n+   subroutine test_main_1()\n+     integer, parameter :: N = 1000\n+\n+     ! scalars\n+     real(c_double), target :: aa, bb\n+     real(c_double), target, allocatable :: cc, dd\n+     real(c_double), pointer :: ee, ff\n+\n+     ! non-descriptor arrays\n+     real(c_double), target :: gg(N), hh(N)\n+\n+     allocate(cc, dd, ee, ff)\n+\n+\n+     aa = 11.0_c_double\n+     bb = 22.0_c_double\n+     cc = 33.0_c_double\n+     dd = 44.0_c_double\n+     ee = 55.0_c_double\n+     ff = 66.0_c_double\n+     gg = 77.0_c_double\n+     hh = 88.0_c_double\n+\n+     !$omp target data map(to:aa) map(from:bb) use_device_addr(aa,bb)\n+     call copy3_scalar(c_loc(aa), c_loc(bb))\n+     !$omp end target data\n+     if (abs(aa - 11.0_c_double) > 10.0_c_double * epsilon(aa)) stop 1\n+     if (abs(3.0_c_double * aa - bb) > 10.0_c_double * epsilon(aa)) stop 1\n+\n+     !$omp target data map(to:cc) map(from:dd) use_device_addr(cc,dd)\n+     call copy3_scalar(c_loc(cc), c_loc(dd))\n+     !$omp end target data\n+     if (abs(cc - 33.0_c_double) > 10.0_c_double * epsilon(cc)) stop 1\n+     if (abs(3.0_c_double * cc - dd) > 10.0_c_double * epsilon(cc)) stop 1\n+\n+     !$omp target data map(to:ee) map(from:ff) use_device_addr(ee,ff)\n+     call copy3_scalar(c_loc(ee), c_loc(ff))\n+     !$omp end target data\n+     if (abs(ee - 55.0_c_double) > 10.0_c_double * epsilon(ee)) stop 1\n+     if (abs(3.0_c_double * ee - ff) > 10.0_c_double * epsilon(ee)) stop 1\n+\n+\n+     !$omp target data map(to:gg) map(from:hh) use_device_addr(gg,hh)\n+     call copy3_array(c_loc(gg), c_loc(hh), N)\n+     !$omp end target data\n+     if (any(abs(gg - 77.0_c_double) > 10.0_c_double * epsilon(gg))) stop 1\n+     if (any(abs(3.0_c_double * gg - hh) > 10.0_c_double * epsilon(gg))) stop 1\n+\n+     deallocate(ee, ff) ! pointers, only\n+   end subroutine test_main_1\n+\n+   ! Save device ptr - and recall pointer\n+   subroutine test_main_2\n+     integer, parameter :: N = 1000\n+\n+     ! scalars\n+     real(c_double), target :: aa, bb\n+     real(c_double), target, allocatable :: cc, dd\n+     real(c_double), pointer :: ee, ff\n+\n+     ! non-descriptor arrays\n+     real(c_double), target :: gg(N), hh(N)\n+\n+     real(c_double) :: dummy\n+     type(c_ptr) :: c_aptr, c_bptr, c_cptr, c_dptr, c_eptr, c_fptr, c_gptr, c_hptr\n+     real(c_double), pointer :: aptr, bptr, cptr, dptr, eptr, fptr\n+     real(c_double), pointer :: gptr(:), hptr(:)\n+\n+     allocate(cc, dd, ee, ff)\n+\n+     aa = 111.0_c_double\n+     bb = 222.0_c_double\n+     cc = 333.0_c_double\n+     dd = 444.0_c_double\n+     ee = 555.0_c_double\n+     ff = 666.0_c_double\n+     gg = 777.0_c_double\n+     hh = 888.0_c_double\n+\n+     !$omp target data map(to:aa) map(from:bb)\n+     !$omp target data map(alloc:dummy) use_device_addr(aa,bb)\n+     c_aptr = c_loc(aa)\n+     c_bptr = c_loc(bb)\n+     aptr => aa\n+     bptr => bb\n+     !$omp end target data\n+\n+     ! check c_loc ptr once\n+     call copy3_scalar(c_aptr, c_bptr)\n+     !$omp target update from(bb)\n+     if (abs(aa - 111.0_c_double) > 10.0_c_double * epsilon(aa)) stop 1\n+     if (abs(3.0_c_double * aa - bb) > 10.0_c_double * epsilon(aa)) stop 1\n+\n+     ! check c_loc ptr again after target-value modification\n+     aa = 1111.0_c_double\n+     !$omp target update to(aa)\n+     call copy3_scalar(c_aptr, c_bptr)\n+     !$omp target update from(bb)\n+     if (abs(aa - 1111.0_c_double) > 10.0_c_double * epsilon(aa)) stop 1\n+     if (abs(3.0_c_double * aa - bb) > 10.0_c_double * epsilon(aa)) stop 1\n+\n+     ! check Fortran pointer after target-value modification\n+     aa = 11111.0_c_double\n+     !$omp target update to(aa)\n+     call copy3_scalar(c_loc(aptr), c_loc(bptr))\n+     !$omp target update from(bb)\n+     if (abs(aa - 11111.0_c_double) > 10.0_c_double * epsilon(aa)) stop 1\n+     if (abs(3.0_c_double * aa - bb) > 10.0_c_double * epsilon(aa)) stop 1\n+     !$omp end target data\n+\n+     if (abs(aa - 11111.0_c_double) > 10.0_c_double * epsilon(aa)) stop 1\n+     if (abs(3.0_c_double * aa - bb) > 10.0_c_double * epsilon(aa)) stop 1\n+\n+\n+     !$omp target data map(to:cc) map(from:dd)\n+     !$omp target data map(alloc:dummy) use_device_addr(cc,dd)\n+     c_cptr = c_loc(cc)\n+     c_dptr = c_loc(dd)\n+     cptr => cc\n+     dptr => dd\n+     !$omp end target data\n+\n+     ! check c_loc ptr once\n+     call copy3_scalar(c_cptr, c_dptr)\n+     !$omp target update from(dd)\n+     if (abs(cc - 333.0_c_double) > 10.0_c_double * epsilon(cc)) stop 1\n+     if (abs(3.0_c_double * cc - dd) > 10.0_c_double * epsilon(cc)) stop 1\n+\n+     ! check c_loc ptr again after target-value modification\n+     cc = 3333.0_c_double\n+     !$omp target update to(cc)\n+     call copy3_scalar(c_cptr, c_dptr)\n+     !$omp target update from(dd)\n+     if (abs(cc - 3333.0_c_double) > 10.0_c_double * epsilon(cc)) stop 1\n+     if (abs(3.0_c_double * cc - dd) > 10.0_c_double * epsilon(cc)) stop 1\n+\n+     ! check Fortran pointer after target-value modification\n+     cc = 33333.0_c_double\n+     !$omp target update to(cc)\n+     call copy3_scalar(c_loc(cptr), c_loc(dptr))\n+     !$omp target update from(dd)\n+     if (abs(cc - 33333.0_c_double) > 10.0_c_double * epsilon(cc)) stop 1\n+     if (abs(3.0_c_double * cc - dd) > 10.0_c_double * epsilon(cc)) stop 1\n+     !$omp end target data\n+\n+     if (abs(cc - 33333.0_c_double) > 10.0_c_double * epsilon(dd)) stop 1\n+     if (abs(3.0_c_double * cc - dd) > 10.0_c_double * epsilon(dd)) stop 1\n+\n+\n+     !$omp target data map(to:ee) map(from:ff)\n+     !$omp target data map(alloc:dummy) use_device_addr(ee,ff)\n+     c_eptr = c_loc(ee)\n+     c_fptr = c_loc(ff)\n+     eptr => ee\n+     fptr => ff\n+     !$omp end target data\n+\n+     ! check c_loc ptr once\n+     call copy3_scalar(c_eptr, c_fptr)\n+     !$omp target update from(ff)\n+     if (abs(ee - 555.0_c_double) > 10.0_c_double * epsilon(ee)) stop 1\n+     if (abs(3.0_c_double * ee - ff) > 10.0_c_double * epsilon(ee)) stop 1\n+\n+     ! check c_loc ptr again after target-value modification\n+     ee = 5555.0_c_double\n+     !$omp target update to(ee)\n+     call copy3_scalar(c_eptr, c_fptr)\n+     !$omp target update from(ff)\n+     if (abs(ee - 5555.0_c_double) > 10.0_c_double * epsilon(ee)) stop 1\n+     if (abs(3.0_c_double * ee - ff) > 10.0_c_double * epsilon(ee)) stop 1\n+\n+     ! check Fortran pointer after target-value modification\n+     ee = 55555.0_c_double\n+     !$omp target update to(ee)\n+     call copy3_scalar(c_loc(eptr), c_loc(fptr))\n+     !$omp target update from(ff)\n+     if (abs(ee - 55555.0_c_double) > 10.0_c_double * epsilon(ee)) stop 1\n+     if (abs(3.0_c_double * ee - ff) > 10.0_c_double * epsilon(ff)) stop 1\n+     !$omp end target data\n+\n+     if (abs(ee - 55555.0_c_double) > 10.0_c_double * epsilon(ee)) stop 1\n+     if (abs(3.0_c_double * ee - ff) > 10.0_c_double * epsilon(ee)) stop 1\n+\n+\n+     !$omp target data map(to:gg) map(from:hh)\n+     !$omp target data map(alloc:dummy) use_device_addr(gg,hh)\n+     c_gptr = c_loc(gg)\n+     c_hptr = c_loc(hh)\n+     gptr => gg\n+     hptr => hh\n+     !$omp end target data\n+\n+     ! check c_loc ptr once\n+     call copy3_array(c_gptr, c_hptr, N)\n+     !$omp target update from(hh)\n+     if (any(abs(gg - 777.0_c_double) > 10.0_c_double * epsilon(gg))) stop 1\n+     if (any(abs(3.0_c_double * gg - hh) > 10.0_c_double * epsilon(hh))) stop 1\n+\n+     ! check c_loc ptr again after target-value modification\n+     gg = 7777.0_c_double\n+     !$omp target update to(gg)\n+     call copy3_array(c_gptr, c_hptr, N)\n+     !$omp target update from(hh)\n+     if (any(abs(gg - 7777.0_c_double) > 10.0_c_double * epsilon(gg))) stop 1\n+     if (any(abs(3.0_c_double * gg - hh) > 10.0_c_double * epsilon(gg))) stop 1\n+\n+     ! check Fortran pointer after target-value modification\n+     gg = 77777.0_c_double\n+     !$omp target update to(gg)\n+     call copy3_array(c_loc(gptr), c_loc(hptr), N)\n+     !$omp target update from(hh)\n+     if (any(abs(gg - 77777.0_c_double) > 10.0_c_double * epsilon(gg))) stop 1\n+     if (any(abs(3.0_c_double * gg - hh) > 10.0_c_double * epsilon(gg))) stop 1\n+     !$omp end target data\n+\n+     if (any(abs(gg - 77777.0_c_double) > 10.0_c_double * epsilon(gg))) stop 1\n+     if (any(abs(3.0_c_double * gg - hh) > 10.0_c_double * epsilon(gg))) stop 1\n+\n+     deallocate(ee, ff)\n+   end subroutine test_main_2\n+end module tests\n+\n+\n+program omp_device_addr\n+  use tests\n+  use test_dummies\n+  use test_dummies_value\n+  use test_dummies_opt\n+  use test_dummies_opt_value\n+  use test_nullptr\n+  implicit none (type, external)\n+\n+  call test_main_1()\n+  call test_main_2()\n+\n+  call test_dummy_call_1()\n+  call test_dummy_call_2()\n+\n+  call test_dummy_val_call_1()\n+  call test_dummy_val_call_2()\n+\n+  call test_dummy_opt_call_1()\n+  call test_dummy_opt_call_2()\n+\n+  call test_dummy_opt_val_call_1()\n+  call test_dummy_opt_val_call_2()\n+\n+  call test_nullptr_1()\n+end program omp_device_addr"}, {"sha": "bddb449141454ec266856714f9ef391f13440c6d", "filename": "libgomp/testsuite/libgomp.fortran/use_device_addr-2.f90", "status": "added", "additions": 1196, "deletions": 0, "changes": 1196, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c14aaaab2b01f1a31989a8d94bae312d87c8f7/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fuse_device_addr-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c14aaaab2b01f1a31989a8d94bae312d87c8f7/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fuse_device_addr-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fuse_device_addr-2.f90?ref=08c14aaaab2b01f1a31989a8d94bae312d87c8f7", "patch": "@@ -0,0 +1,1196 @@\n+! Comprehensive run-time test for use_device_addr\n+!\n+! Differs from use_device_addr-1.f90 by using a 4-byte variable (c_float)\n+!\n+! This test case assumes that a 'var' appearing in 'use_device_addr' is\n+! only used as 'c_loc(var)' - such that only the actual data is used/usable\n+! on the device - and not meta data ((dynamic) type information, 'present()'\n+! status, array shape).\n+!\n+! Untested in this test case are:\n+! - arrays with array descriptor\n+! - polymorphic variables\n+! - absent optional arguments\n+!\n+module target_procs\n+  use iso_c_binding\n+  implicit none (type, external)\n+  private\n+  public :: copy3_array, copy3_scalar\n+contains\n+  subroutine copy3_array_int(from_ptr, to_ptr, N)\n+    !$omp declare target\n+    real(c_float) :: from_ptr(:)\n+    real(c_float) :: to_ptr(:)\n+    integer, value :: N\n+    integer :: i\n+\n+    !$omp parallel do\n+    do i = 1, N\n+      to_ptr(i) = 3 * from_ptr(i)\n+    end do\n+    !$omp end parallel do\n+  end subroutine copy3_array_int\n+\n+  subroutine copy3_scalar_int(from, to)\n+    !$omp declare target\n+    real(c_float) :: from, to\n+\n+    to = 3 * from\n+  end subroutine copy3_scalar_int\n+\n+\n+  subroutine copy3_array(from, to, N)\n+    type(c_ptr), value :: from, to\n+    integer, value :: N\n+    real(c_float), pointer :: from_ptr(:), to_ptr(:)\n+\n+    call c_f_pointer(from, from_ptr, shape=[N])\n+    call c_f_pointer(to, to_ptr, shape=[N])\n+\n+    call do_offload_scalar(from_ptr,to_ptr)\n+  contains\n+    subroutine do_offload_scalar(from_r, to_r)\n+      real(c_float), target :: from_r(:), to_r(:)\n+      ! The extra function is needed as is_device_ptr\n+      ! requires non-value, non-pointer dummy arguments\n+\n+      !$omp target is_device_ptr(from_r, to_r)\n+      call copy3_array_int(from_r, to_r, N)\n+      !$omp end target\n+    end subroutine do_offload_scalar\n+  end subroutine copy3_array\n+\n+  subroutine copy3_scalar(from, to)\n+    type(c_ptr), value, target :: from, to\n+    real(c_float), pointer :: from_ptr(:), to_ptr(:)\n+\n+    ! Standard-conform detour of using an array as at time of writing\n+    ! is_device_ptr below does not handle scalars\n+    call c_f_pointer(from, from_ptr, shape=[1])\n+    call c_f_pointer(to, to_ptr, shape=[1])\n+\n+    call do_offload_scalar(from_ptr,to_ptr)\n+  contains\n+    subroutine do_offload_scalar(from_r, to_r)\n+      real(c_float), target :: from_r(:), to_r(:)\n+      ! The extra function is needed as is_device_ptr\n+      ! requires non-value, non-pointer dummy arguments\n+\n+      !$omp target is_device_ptr(from_r, to_r)\n+      call copy3_scalar_int(from_r(1), to_r(1))\n+      !$omp end target\n+    end subroutine do_offload_scalar\n+  end subroutine copy3_scalar\n+end module target_procs\n+\n+\n+\n+! Test local dummy arguments (w/o optional)\n+module test_dummies\n+  use iso_c_binding\n+  use target_procs\n+  implicit none (type, external)\n+  private\n+  public :: test_dummy_call_1, test_dummy_call_2\n+contains\n+  subroutine test_dummy_call_1()\n+     integer, parameter :: N = 1000\n+\n+     ! scalars\n+     real(c_float), target :: aa, bb\n+     real(c_float), target, allocatable :: cc, dd\n+     real(c_float), pointer :: ee, ff\n+\n+     ! non-descriptor arrays\n+     real(c_float), target :: gg(N), hh(N)\n+\n+     allocate(cc, dd, ee, ff)\n+\n+     aa = 11.0_c_float\n+     bb = 22.0_c_float\n+     cc = 33.0_c_float\n+     dd = 44.0_c_float\n+     ee = 55.0_c_float\n+     ff = 66.0_c_float\n+     gg = 77.0_c_float\n+     hh = 88.0_c_float\n+\n+     call test_dummy_callee_1(aa, bb, cc, dd, ee, ff, gg, hh, N)\n+     deallocate(ee, ff) ! pointers, only\n+  end subroutine test_dummy_call_1\n+\n+  subroutine test_dummy_callee_1(aa, bb, cc, dd, ee, ff, gg, hh, N)\n+     ! scalars\n+     real(c_float), target :: aa, bb\n+     real(c_float), target, allocatable :: cc, dd\n+     real(c_float), pointer :: ee, ff\n+\n+     ! non-descriptor arrays\n+     real(c_float), target :: gg(N), hh(N)\n+     integer, value :: N\n+\n+     !$omp target data map(to:aa) map(from:bb) use_device_addr(aa,bb)\n+     call copy3_scalar(c_loc(aa), c_loc(bb))\n+     !$omp end target data\n+     if (abs(aa - 11.0_c_float) > 10.0_c_float * epsilon(aa)) stop 1\n+     if (abs(3.0_c_float * aa - bb) > 10.0_c_float * epsilon(aa)) stop 1\n+\n+     !$omp target data map(to:cc) map(from:dd) use_device_addr(cc,dd)\n+     call copy3_scalar(c_loc(cc), c_loc(dd))\n+     !$omp end target data\n+     if (abs(cc - 33.0_c_float) > 10.0_c_float * epsilon(cc)) stop 1\n+     if (abs(3.0_c_float * cc - dd) > 10.0_c_float * epsilon(cc)) stop 1\n+\n+     !$omp target data map(to:ee) map(from:ff) use_device_addr(ee,ff)\n+     call copy3_scalar(c_loc(ee), c_loc(ff))\n+     !$omp end target data\n+     if (abs(ee - 55.0_c_float) > 10.0_c_float * epsilon(ee)) stop 1\n+     if (abs(3.0_c_float * ee - ff) > 10.0_c_float * epsilon(ee)) stop 1\n+\n+\n+     !$omp target data map(to:gg) map(from:hh) use_device_addr(gg,hh)\n+     call copy3_array(c_loc(gg), c_loc(hh), N)\n+     !$omp end target data\n+     if (any(abs(gg - 77.0_c_float) > 10.0_c_float * epsilon(gg))) stop 1\n+     if (any(abs(3.0_c_float * gg - hh) > 10.0_c_float * epsilon(gg))) stop 1\n+  end subroutine test_dummy_callee_1\n+\n+  ! Save device ptr - and recall pointer\n+  subroutine test_dummy_call_2()\n+     integer, parameter :: N = 1000\n+\n+     ! scalars\n+     real(c_float), target :: aa, bb\n+     real(c_float), target, allocatable :: cc, dd\n+     real(c_float), pointer :: ee, ff\n+\n+     ! non-descriptor arrays\n+     real(c_float), target :: gg(N), hh(N)\n+\n+     type(c_ptr) :: c_aptr, c_bptr, c_cptr, c_dptr, c_eptr, c_fptr, c_gptr, c_hptr\n+     real(c_float), pointer :: aptr, bptr, cptr, dptr, eptr, fptr\n+     real(c_float), pointer :: gptr(:), hptr(:)\n+\n+     allocate(cc, dd, ee, ff)\n+     call test_dummy_callee_2(aa, bb, cc, dd, ee, ff, gg, hh, &\n+                               c_aptr, c_bptr, c_cptr, c_dptr, c_eptr, c_fptr, c_gptr, c_hptr, &\n+                               aptr, bptr, cptr, dptr, eptr, fptr, gptr, hptr, &\n+                               N)\n+     deallocate(ee, ff)\n+  end subroutine test_dummy_call_2\n+\n+  subroutine test_dummy_callee_2(aa, bb, cc, dd, ee, ff, gg, hh, &\n+                                  c_aptr, c_bptr, c_cptr, c_dptr, c_eptr, c_fptr, c_gptr, c_hptr, &\n+                                  aptr, bptr, cptr, dptr, eptr, fptr, gptr, hptr, &\n+                                  N)\n+     ! scalars\n+     real(c_float), target :: aa, bb\n+     real(c_float), target, allocatable :: cc, dd\n+     real(c_float), pointer :: ee, ff\n+\n+     ! non-descriptor arrays\n+     real(c_float), target :: gg(N), hh(N)\n+\n+     type(c_ptr) :: c_aptr, c_bptr, c_cptr, c_dptr, c_eptr, c_fptr, c_gptr, c_hptr\n+     real(c_float), pointer :: aptr, bptr, cptr, dptr, eptr, fptr\n+     real(c_float), pointer :: gptr(:), hptr(:)\n+\n+     integer, value :: N\n+\n+     real(c_float) :: dummy\n+\n+     aa = 111.0_c_float\n+     bb = 222.0_c_float\n+     cc = 333.0_c_float\n+     dd = 444.0_c_float\n+     ee = 555.0_c_float\n+     ff = 666.0_c_float\n+     gg = 777.0_c_float\n+     hh = 888.0_c_float\n+\n+     !$omp target data map(to:aa) map(from:bb)\n+     !$omp target data map(alloc:dummy) use_device_addr(aa,bb)\n+     c_aptr = c_loc(aa)\n+     c_bptr = c_loc(bb)\n+     aptr => aa\n+     bptr => bb\n+     !$omp end target data\n+\n+     ! check c_loc ptr once\n+     call copy3_scalar(c_aptr, c_bptr)\n+     !$omp target update from(bb)\n+     if (abs(aa - 111.0_c_float) > 10.0_c_float * epsilon(aa)) stop 1\n+     if (abs(3.0_c_float * aa - bb) > 10.0_c_float * epsilon(aa)) stop 1\n+\n+     ! check c_loc ptr again after target-value modification\n+     aa = 1111.0_c_float\n+     !$omp target update to(aa)\n+     call copy3_scalar(c_aptr, c_bptr)\n+     !$omp target update from(bb)\n+     if (abs(aa - 1111.0_c_float) > 10.0_c_float * epsilon(aa)) stop 1\n+     if (abs(3.0_c_float * aa - bb) > 10.0_c_float * epsilon(aa)) stop 1\n+\n+     ! check Fortran pointer after target-value modification\n+     aa = 11111.0_c_float\n+     !$omp target update to(aa)\n+     call copy3_scalar(c_loc(aptr), c_loc(bptr))\n+     !$omp target update from(bb)\n+     if (abs(aa - 11111.0_c_float) > 10.0_c_float * epsilon(aa)) stop 1\n+     if (abs(3.0_c_float * aa - bb) > 10.0_c_float * epsilon(aa)) stop 1\n+     !$omp end target data\n+\n+     if (abs(aa - 11111.0_c_float) > 10.0_c_float * epsilon(aa)) stop 1\n+     if (abs(3.0_c_float * aa - bb) > 10.0_c_float * epsilon(aa)) stop 1\n+\n+\n+     !$omp target data map(to:cc) map(from:dd)\n+     !$omp target data map(alloc:dummy) use_device_addr(cc,dd)\n+     c_cptr = c_loc(cc)\n+     c_dptr = c_loc(dd)\n+     cptr => cc\n+     dptr => dd\n+     !$omp end target data\n+\n+     ! check c_loc ptr once\n+     call copy3_scalar(c_cptr, c_dptr)\n+     !$omp target update from(dd)\n+     if (abs(cc - 333.0_c_float) > 10.0_c_float * epsilon(cc)) stop 1\n+     if (abs(3.0_c_float * cc - dd) > 10.0_c_float * epsilon(cc)) stop 1\n+\n+     ! check c_loc ptr again after target-value modification\n+     cc = 3333.0_c_float\n+     !$omp target update to(cc)\n+     call copy3_scalar(c_cptr, c_dptr)\n+     !$omp target update from(dd)\n+     if (abs(cc - 3333.0_c_float) > 10.0_c_float * epsilon(cc)) stop 1\n+     if (abs(3.0_c_float * cc - dd) > 10.0_c_float * epsilon(cc)) stop 1\n+\n+     ! check Fortran pointer after target-value modification\n+     cc = 33333.0_c_float\n+     !$omp target update to(cc)\n+     call copy3_scalar(c_loc(cptr), c_loc(dptr))\n+     !$omp target update from(dd)\n+     if (abs(cc - 33333.0_c_float) > 10.0_c_float * epsilon(cc)) stop 1\n+     if (abs(3.0_c_float * cc - dd) > 10.0_c_float * epsilon(cc)) stop 1\n+     !$omp end target data\n+\n+     if (abs(cc - 33333.0_c_float) > 10.0_c_float * epsilon(dd)) stop 1\n+     if (abs(3.0_c_float * cc - dd) > 10.0_c_float * epsilon(dd)) stop 1\n+\n+\n+     !$omp target data map(to:ee) map(from:ff)\n+     !$omp target data map(alloc:dummy) use_device_addr(ee,ff)\n+     c_eptr = c_loc(ee)\n+     c_fptr = c_loc(ff)\n+     eptr => ee\n+     fptr => ff\n+     !$omp end target data\n+\n+     ! check c_loc ptr once\n+     call copy3_scalar(c_eptr, c_fptr)\n+     !$omp target update from(ff)\n+     if (abs(ee - 555.0_c_float) > 10.0_c_float * epsilon(ee)) stop 1\n+     if (abs(3.0_c_float * ee - ff) > 10.0_c_float * epsilon(ee)) stop 1\n+\n+     ! check c_loc ptr again after target-value modification\n+     ee = 5555.0_c_float\n+     !$omp target update to(ee)\n+     call copy3_scalar(c_eptr, c_fptr)\n+     !$omp target update from(ff)\n+     if (abs(ee - 5555.0_c_float) > 10.0_c_float * epsilon(ee)) stop 1\n+     if (abs(3.0_c_float * ee - ff) > 10.0_c_float * epsilon(ee)) stop 1\n+\n+     ! check Fortran pointer after target-value modification\n+     ee = 55555.0_c_float\n+     !$omp target update to(ee)\n+     call copy3_scalar(c_loc(eptr), c_loc(fptr))\n+     !$omp target update from(ff)\n+     if (abs(ee - 55555.0_c_float) > 10.0_c_float * epsilon(ee)) stop 1\n+     if (abs(3.0_c_float * ee - ff) > 10.0_c_float * epsilon(ff)) stop 1\n+     !$omp end target data\n+\n+     if (abs(ee - 55555.0_c_float) > 10.0_c_float * epsilon(ee)) stop 1\n+     if (abs(3.0_c_float * ee - ff) > 10.0_c_float * epsilon(ee)) stop 1\n+\n+\n+     !$omp target data map(to:gg) map(from:hh)\n+     !$omp target data map(alloc:dummy) use_device_addr(gg,hh)\n+     c_gptr = c_loc(gg)\n+     c_hptr = c_loc(hh)\n+     gptr => gg\n+     hptr => hh\n+     !$omp end target data\n+\n+     ! check c_loc ptr once\n+     call copy3_array(c_gptr, c_hptr, N)\n+     !$omp target update from(hh)\n+     if (any(abs(gg - 777.0_c_float) > 10.0_c_float * epsilon(gg))) stop 1\n+     if (any(abs(3.0_c_float * gg - hh) > 10.0_c_float * epsilon(hh))) stop 1\n+\n+     ! check c_loc ptr again after target-value modification\n+     gg = 7777.0_c_float\n+     !$omp target update to(gg)\n+     call copy3_array(c_gptr, c_hptr, N)\n+     !$omp target update from(hh)\n+     if (any(abs(gg - 7777.0_c_float) > 10.0_c_float * epsilon(gg))) stop 1\n+     if (any(abs(3.0_c_float * gg - hh) > 10.0_c_float * epsilon(gg))) stop 1\n+\n+     ! check Fortran pointer after target-value modification\n+     gg = 77777.0_c_float\n+     !$omp target update to(gg)\n+     call copy3_array(c_loc(gptr), c_loc(hptr), N)\n+     !$omp target update from(hh)\n+     if (any(abs(gg - 77777.0_c_float) > 10.0_c_float * epsilon(gg))) stop 1\n+     if (any(abs(3.0_c_float * gg - hh) > 10.0_c_float * epsilon(gg))) stop 1\n+     !$omp end target data\n+\n+     if (any(abs(gg - 77777.0_c_float) > 10.0_c_float * epsilon(gg))) stop 1\n+     if (any(abs(3.0_c_float * gg - hh) > 10.0_c_float * epsilon(gg))) stop 1\n+  end subroutine test_dummy_callee_2\n+end module test_dummies\n+\n+\n+\n+! Test local dummy arguments + VALUE (w/o optional)\n+module test_dummies_value\n+  use iso_c_binding\n+  use target_procs\n+  implicit none (type, external)\n+  private\n+  public :: test_dummy_val_call_1, test_dummy_val_call_2\n+contains\n+  subroutine test_dummy_val_call_1()\n+     ! scalars - with value, neither allocatable nor pointer no dimension permitted\n+     real(c_float), target :: aa, bb\n+\n+     aa = 11.0_c_float\n+     bb = 22.0_c_float\n+\n+     call test_dummy_val_callee_1(aa, bb)\n+  end subroutine test_dummy_val_call_1\n+\n+  subroutine test_dummy_val_callee_1(aa, bb)\n+     ! scalars\n+     real(c_float), value, target :: aa, bb\n+\n+     !$omp target data map(to:aa) map(from:bb) use_device_addr(aa,bb)\n+     call copy3_scalar(c_loc(aa), c_loc(bb))\n+     !$omp end target data\n+     if (abs(aa - 11.0_c_float) > 10.0_c_float * epsilon(aa)) stop 1\n+     if (abs(3.0_c_float * aa - bb) > 10.0_c_float * epsilon(aa)) stop 1\n+  end subroutine test_dummy_val_callee_1\n+\n+  ! Save device ptr - and recall pointer\n+  subroutine test_dummy_val_call_2()\n+     ! scalars - with value, neither allocatable nor pointer no dimension permitted\n+     real(c_float), target :: aa, bb\n+     type(c_ptr) :: c_aptr, c_bptr\n+     real(c_float), pointer :: aptr, bptr\n+\n+     call test_dummy_val_callee_2(aa, bb, c_aptr, c_bptr, aptr, bptr)\n+  end subroutine test_dummy_val_call_2\n+\n+  subroutine test_dummy_val_callee_2(aa, bb, c_aptr, c_bptr, aptr, bptr)\n+     real(c_float), value, target :: aa, bb\n+     type(c_ptr), value :: c_aptr, c_bptr\n+     real(c_float), pointer :: aptr, bptr\n+\n+     real(c_float) :: dummy\n+\n+     aa = 111.0_c_float\n+     bb = 222.0_c_float\n+\n+     !$omp target data map(to:aa) map(from:bb)\n+     !$omp target data map(alloc:dummy) use_device_addr(aa,bb)\n+     c_aptr = c_loc(aa)\n+     c_bptr = c_loc(bb)\n+     aptr => aa\n+     bptr => bb\n+     !$omp end target data\n+\n+     ! check c_loc ptr once\n+     call copy3_scalar(c_aptr, c_bptr)\n+     !$omp target update from(bb)\n+     if (abs(aa - 111.0_c_float) > 10.0_c_float * epsilon(aa)) stop 1\n+     if (abs(3.0_c_float * aa - bb) > 10.0_c_float * epsilon(aa)) stop 1\n+\n+     ! check c_loc ptr again after target-value modification\n+     aa = 1111.0_c_float\n+     !$omp target update to(aa)\n+     call copy3_scalar(c_aptr, c_bptr)\n+     !$omp target update from(bb)\n+     if (abs(aa - 1111.0_c_float) > 10.0_c_float * epsilon(aa)) stop 1\n+     if (abs(3.0_c_float * aa - bb) > 10.0_c_float * epsilon(aa)) stop 1\n+\n+     ! check Fortran pointer after target-value modification\n+     aa = 11111.0_c_float\n+     !$omp target update to(aa)\n+     call copy3_scalar(c_loc(aptr), c_loc(bptr))\n+     !$omp target update from(bb)\n+     if (abs(aa - 11111.0_c_float) > 10.0_c_float * epsilon(aa)) stop 1\n+     if (abs(3.0_c_float * aa - bb) > 10.0_c_float * epsilon(aa)) stop 1\n+     !$omp end target data\n+\n+     if (abs(aa - 11111.0_c_float) > 10.0_c_float * epsilon(aa)) stop 1\n+     if (abs(3.0_c_float * aa - bb) > 10.0_c_float * epsilon(aa)) stop 1\n+  end subroutine test_dummy_val_callee_2\n+end module test_dummies_value\n+\n+\n+\n+! Test local dummy arguments + OPTIONAL\n+! Values present and ptr associated to nonzero\n+module test_dummies_opt\n+  use iso_c_binding\n+  use target_procs\n+  implicit none (type, external)\n+  private\n+  public :: test_dummy_opt_call_1, test_dummy_opt_call_2\n+contains\n+  subroutine test_dummy_opt_call_1()\n+     integer, parameter :: N = 1000\n+\n+     ! scalars\n+     real(c_float), target :: aa, bb\n+     real(c_float), target, allocatable :: cc, dd\n+     real(c_float), pointer :: ee, ff\n+\n+     ! non-descriptor arrays\n+     real(c_float), target :: gg(N), hh(N)\n+\n+     allocate(cc, dd, ee, ff)\n+\n+     aa = 11.0_c_float\n+     bb = 22.0_c_float\n+     cc = 33.0_c_float\n+     dd = 44.0_c_float\n+     ee = 55.0_c_float\n+     ff = 66.0_c_float\n+     gg = 77.0_c_float\n+     hh = 88.0_c_float\n+\n+     call test_dummy_opt_callee_1(aa, bb, cc, dd, ee, ff, gg, hh, N)\n+     deallocate(ee, ff) ! pointers, only\n+  end subroutine test_dummy_opt_call_1\n+\n+  subroutine test_dummy_opt_callee_1(aa, bb, cc, dd, ee, ff, gg, hh, N)\n+     ! scalars\n+     real(c_float), optional, target :: aa, bb\n+     real(c_float), optional, target, allocatable :: cc, dd\n+     real(c_float), optional, pointer :: ee, ff\n+\n+     ! non-descriptor arrays\n+     real(c_float), optional, target :: gg(N), hh(N)\n+     integer, value :: N\n+\n+     ! All shall be present - and pointing to non-NULL\n+     if (.not.present(aa) .or. .not.present(bb)) stop 1\n+     if (.not.present(cc) .or. .not.present(dd)) stop 1\n+     if (.not.present(ee) .or. .not.present(ff)) stop 1\n+     if (.not.present(gg) .or. .not.present(hh)) stop 1\n+\n+     if (.not.associated(ee) .or. .not.associated(ff)) stop 1\n+\n+     !$omp target data map(to:aa) map(from:bb) use_device_addr(aa,bb)\n+     if (.not.present(aa) .or. .not.present(bb)) stop 1\n+     if (.not.c_associated(c_loc(aa)) .or. .not.c_associated(c_loc(bb))) stop 1\n+     call copy3_scalar(c_loc(aa), c_loc(bb))\n+     !$omp end target data\n+     if (abs(aa - 11.0_c_float) > 10.0_c_float * epsilon(aa)) stop 1\n+     if (abs(3.0_c_float * aa - bb) > 10.0_c_float * epsilon(aa)) stop 1\n+\n+     !$omp target data map(to:cc) map(from:dd) use_device_addr(cc,dd)\n+     if (.not.present(cc) .or. .not.present(dd)) stop 1\n+     if (.not.c_associated(c_loc(cc)) .or. .not.c_associated(c_loc(dd))) stop 1\n+     call copy3_scalar(c_loc(cc), c_loc(dd))\n+     !$omp end target data\n+     if (abs(cc - 33.0_c_float) > 10.0_c_float * epsilon(cc)) stop 1\n+     if (abs(3.0_c_float * cc - dd) > 10.0_c_float * epsilon(cc)) stop 1\n+\n+     !$omp target data map(to:ee) map(from:ff) use_device_addr(ee,ff)\n+     if (.not.present(ee) .or. .not.present(ff)) stop 1\n+     if (.not.associated(ee) .or. .not.associated(ff)) stop 1\n+     if (.not.c_associated(c_loc(ee)) .or. .not.c_associated(c_loc(ff))) stop 1\n+     call copy3_scalar(c_loc(ee), c_loc(ff))\n+     !$omp end target data\n+     if (abs(ee - 55.0_c_float) > 10.0_c_float * epsilon(ee)) stop 1\n+     if (abs(3.0_c_float * ee - ff) > 10.0_c_float * epsilon(ee)) stop 1\n+\n+     !$omp target data map(to:gg) map(from:hh) use_device_addr(gg,hh)\n+     if (.not.present(gg) .or. .not.present(hh)) stop 1\n+     if (.not.c_associated(c_loc(gg)) .or. .not.c_associated(c_loc(hh))) stop 1\n+     call copy3_array(c_loc(gg), c_loc(hh), N)\n+     !$omp end target data\n+     if (any(abs(gg - 77.0_c_float) > 10.0_c_float * epsilon(gg))) stop 1\n+     if (any(abs(3.0_c_float * gg - hh) > 10.0_c_float * epsilon(gg))) stop 1\n+  end subroutine test_dummy_opt_callee_1\n+\n+  ! Save device ptr - and recall pointer\n+  subroutine test_dummy_opt_call_2()\n+     integer, parameter :: N = 1000\n+\n+     ! scalars\n+     real(c_float), target :: aa, bb\n+     real(c_float), target, allocatable :: cc, dd\n+     real(c_float), pointer :: ee, ff\n+\n+     ! non-descriptor arrays\n+     real(c_float), target :: gg(N), hh(N)\n+\n+     type(c_ptr) :: c_aptr, c_bptr, c_cptr, c_dptr, c_eptr, c_fptr, c_gptr, c_hptr\n+     real(c_float), pointer :: aptr, bptr, cptr, dptr, eptr, fptr\n+     real(c_float), pointer :: gptr(:), hptr(:)\n+\n+     allocate(cc, dd, ee, ff)\n+     call test_dummy_opt_callee_2(aa, bb, cc, dd, ee, ff, gg, hh, &\n+                                   c_aptr, c_bptr, c_cptr, c_dptr, c_eptr, c_fptr, c_gptr, c_hptr, &\n+                                   aptr, bptr, cptr, dptr, eptr, fptr, gptr, hptr, &\n+                                   N)\n+     deallocate(ee, ff)\n+  end subroutine test_dummy_opt_call_2\n+\n+  subroutine test_dummy_opt_callee_2(aa, bb, cc, dd, ee, ff, gg, hh, &\n+                                      c_aptr, c_bptr, c_cptr, c_dptr, c_eptr, c_fptr, c_gptr, c_hptr, &\n+                                      aptr, bptr, cptr, dptr, eptr, fptr, gptr, hptr, &\n+                                      N)\n+     ! scalars\n+     real(c_float), optional, target :: aa, bb\n+     real(c_float), optional, target, allocatable :: cc, dd\n+     real(c_float), optional, pointer :: ee, ff\n+\n+     ! non-descriptor arrays\n+     real(c_float), optional, target :: gg(N), hh(N)\n+\n+     type(c_ptr) :: c_aptr, c_bptr, c_cptr, c_dptr, c_eptr, c_fptr, c_gptr, c_hptr\n+     real(c_float), optional, pointer :: aptr, bptr, cptr, dptr, eptr, fptr\n+     real(c_float), optional, pointer :: gptr(:), hptr(:)\n+\n+     integer, value :: N\n+\n+     real(c_float) :: dummy\n+\n+     ! All shall be present - and pointing to non-NULL\n+     if (.not.present(aa) .or. .not.present(bb)) stop 1\n+     if (.not.present(cc) .or. .not.present(dd)) stop 1\n+     if (.not.present(ee) .or. .not.present(ff)) stop 1\n+     if (.not.present(gg) .or. .not.present(hh)) stop 1\n+\n+     if (.not.associated(ee) .or. .not.associated(ff)) stop 1\n+\n+     aa = 111.0_c_float\n+     bb = 222.0_c_float\n+     cc = 333.0_c_float\n+     dd = 444.0_c_float\n+     ee = 555.0_c_float\n+     ff = 666.0_c_float\n+     gg = 777.0_c_float\n+     hh = 888.0_c_float\n+\n+     !$omp target data map(to:aa) map(from:bb)\n+     !$omp target data map(alloc:dummy) use_device_addr(aa,bb)\n+     if (.not.present(aa) .or. .not.present(bb)) stop 1\n+     if (.not.c_associated(c_loc(aa)) .or. .not.c_associated(c_loc(bb))) stop 1\n+     c_aptr = c_loc(aa)\n+     c_bptr = c_loc(bb)\n+     aptr => aa\n+     bptr => bb\n+     if (.not.c_associated(c_aptr) .or. .not.c_associated(c_bptr)) stop 1\n+     if (.not.associated(aptr) .or. .not.associated(bptr)) stop 1\n+     !$omp end target data\n+\n+     if (.not.present(aa) .or. .not.present(bb)) stop 1\n+     if (.not.c_associated(c_loc(aa)) .or. .not.c_associated(c_loc(bb))) stop 1\n+     if (.not.c_associated(c_aptr) .or. .not.c_associated(c_bptr)) stop 1\n+     if (.not.associated(aptr) .or. .not.associated(bptr)) stop 1\n+\n+     ! check c_loc ptr once\n+     call copy3_scalar(c_aptr, c_bptr)\n+     !$omp target update from(bb)\n+     if (abs(aa - 111.0_c_float) > 10.0_c_float * epsilon(aa)) stop 1\n+     if (abs(3.0_c_float * aa - bb) > 10.0_c_float * epsilon(aa)) stop 1\n+\n+     ! check c_loc ptr again after target-value modification\n+     aa = 1111.0_c_float\n+     !$omp target update to(aa)\n+     call copy3_scalar(c_aptr, c_bptr)\n+     !$omp target update from(bb)\n+     if (abs(aa - 1111.0_c_float) > 10.0_c_float * epsilon(aa)) stop 1\n+     if (abs(3.0_c_float * aa - bb) > 10.0_c_float * epsilon(aa)) stop 1\n+\n+     ! check Fortran pointer after target-value modification\n+     aa = 11111.0_c_float\n+     !$omp target update to(aa)\n+     call copy3_scalar(c_loc(aptr), c_loc(bptr))\n+     !$omp target update from(bb)\n+     if (abs(aa - 11111.0_c_float) > 10.0_c_float * epsilon(aa)) stop 1\n+     if (abs(3.0_c_float * aa - bb) > 10.0_c_float * epsilon(aa)) stop 1\n+     !$omp end target data\n+\n+     if (abs(aa - 11111.0_c_float) > 10.0_c_float * epsilon(aa)) stop 1\n+     if (abs(3.0_c_float * aa - bb) > 10.0_c_float * epsilon(aa)) stop 1\n+\n+\n+     !$omp target data map(to:cc) map(from:dd)\n+     !$omp target data map(alloc:dummy) use_device_addr(cc,dd)\n+     if (.not.present(cc) .or. .not.present(dd)) stop 1\n+     if (.not.c_associated(c_loc(cc)) .or. .not.c_associated(c_loc(dd))) stop 1\n+     c_cptr = c_loc(cc)\n+     c_dptr = c_loc(dd)\n+     cptr => cc\n+     dptr => dd\n+     if (.not.c_associated(c_cptr) .or. .not.c_associated(c_dptr)) stop 1\n+     if (.not.associated(cptr) .or. .not.associated(dptr)) stop 1\n+     !$omp end target data\n+     if (.not.present(cc) .or. .not.present(dd)) stop 1\n+     if (.not.c_associated(c_loc(cc)) .or. .not.c_associated(c_loc(dd))) stop 1\n+     if (.not.c_associated(c_cptr) .or. .not.c_associated(c_dptr)) stop 1\n+     if (.not.associated(cptr) .or. .not.associated(dptr)) stop 1\n+\n+     ! check c_loc ptr once\n+     call copy3_scalar(c_cptr, c_dptr)\n+     !$omp target update from(dd)\n+     if (abs(cc - 333.0_c_float) > 10.0_c_float * epsilon(cc)) stop 1\n+     if (abs(3.0_c_float * cc - dd) > 10.0_c_float * epsilon(cc)) stop 1\n+\n+     ! check c_loc ptr again after target-value modification\n+     cc = 3333.0_c_float\n+     !$omp target update to(cc)\n+     call copy3_scalar(c_cptr, c_dptr)\n+     !$omp target update from(dd)\n+     if (abs(cc - 3333.0_c_float) > 10.0_c_float * epsilon(cc)) stop 1\n+     if (abs(3.0_c_float * cc - dd) > 10.0_c_float * epsilon(cc)) stop 1\n+\n+     ! check Fortran pointer after target-value modification\n+     cc = 33333.0_c_float\n+     !$omp target update to(cc)\n+     call copy3_scalar(c_loc(cptr), c_loc(dptr))\n+     !$omp target update from(dd)\n+     if (abs(cc - 33333.0_c_float) > 10.0_c_float * epsilon(cc)) stop 1\n+     if (abs(3.0_c_float * cc - dd) > 10.0_c_float * epsilon(cc)) stop 1\n+     !$omp end target data\n+\n+     if (abs(cc - 33333.0_c_float) > 10.0_c_float * epsilon(dd)) stop 1\n+     if (abs(3.0_c_float * cc - dd) > 10.0_c_float * epsilon(dd)) stop 1\n+\n+\n+     !$omp target data map(to:ee) map(from:ff)\n+     !$omp target data map(alloc:dummy) use_device_addr(ee,ff)\n+     if (.not.present(ee) .or. .not.present(ff)) stop 1\n+     if (.not.associated(ee) .or. .not.associated(ff)) stop 1\n+     if (.not.c_associated(c_loc(ee)) .or. .not.c_associated(c_loc(ff))) stop 1\n+     c_eptr = c_loc(ee)\n+     c_fptr = c_loc(ff)\n+     eptr => ee\n+     fptr => ff\n+     if (.not.c_associated(c_eptr) .or. .not.c_associated(c_fptr)) stop 1\n+     if (.not.associated(eptr) .or. .not.associated(fptr)) stop 1\n+     !$omp end target data\n+     if (.not.present(ee) .or. .not.present(ff)) stop 1\n+     if (.not.associated(ee) .or. .not.associated(ff)) stop 1\n+     if (.not.c_associated(c_loc(ee)) .or. .not.c_associated(c_loc(ff))) stop 1\n+     if (.not.c_associated(c_eptr) .or. .not.c_associated(c_fptr)) stop 1\n+     if (.not.associated(eptr) .or. .not.associated(fptr)) stop 1\n+\n+     ! check c_loc ptr once\n+     call copy3_scalar(c_eptr, c_fptr)\n+     !$omp target update from(ff)\n+     if (abs(ee - 555.0_c_float) > 10.0_c_float * epsilon(ee)) stop 1\n+     if (abs(3.0_c_float * ee - ff) > 10.0_c_float * epsilon(ee)) stop 1\n+\n+     ! check c_loc ptr again after target-value modification\n+     ee = 5555.0_c_float\n+     !$omp target update to(ee)\n+     call copy3_scalar(c_eptr, c_fptr)\n+     !$omp target update from(ff)\n+     if (abs(ee - 5555.0_c_float) > 10.0_c_float * epsilon(ee)) stop 1\n+     if (abs(3.0_c_float * ee - ff) > 10.0_c_float * epsilon(ee)) stop 1\n+\n+     ! check Fortran pointer after target-value modification\n+     ee = 55555.0_c_float\n+     !$omp target update to(ee)\n+     call copy3_scalar(c_loc(eptr), c_loc(fptr))\n+     !$omp target update from(ff)\n+     if (abs(ee - 55555.0_c_float) > 10.0_c_float * epsilon(ee)) stop 1\n+     if (abs(3.0_c_float * ee - ff) > 10.0_c_float * epsilon(ff)) stop 1\n+     !$omp end target data\n+\n+     if (abs(ee - 55555.0_c_float) > 10.0_c_float * epsilon(ee)) stop 1\n+     if (abs(3.0_c_float * ee - ff) > 10.0_c_float * epsilon(ee)) stop 1\n+\n+\n+     !$omp target data map(to:gg) map(from:hh)\n+     !$omp target data map(alloc:dummy) use_device_addr(gg,hh)\n+     if (.not.present(gg) .or. .not.present(hh)) stop 1\n+     if (.not.c_associated(c_loc(gg)) .or. .not.c_associated(c_loc(hh))) stop 1\n+     c_gptr = c_loc(gg)\n+     c_hptr = c_loc(hh)\n+     gptr => gg\n+     hptr => hh\n+     if (.not.c_associated(c_gptr) .or. .not.c_associated(c_hptr)) stop 1\n+     if (.not.associated(gptr) .or. .not.associated(hptr)) stop 1\n+     !$omp end target data\n+     if (.not.present(gg) .or. .not.present(hh)) stop 1\n+     if (.not.c_associated(c_loc(gg)) .or. .not.c_associated(c_loc(hh))) stop 1\n+     if (.not.c_associated(c_gptr) .or. .not.c_associated(c_hptr)) stop 1\n+     if (.not.associated(gptr) .or. .not.associated(hptr)) stop 1\n+\n+     ! check c_loc ptr once\n+     call copy3_array(c_gptr, c_hptr, N)\n+     !$omp target update from(hh)\n+     if (any(abs(gg - 777.0_c_float) > 10.0_c_float * epsilon(gg))) stop 1\n+     if (any(abs(3.0_c_float * gg - hh) > 10.0_c_float * epsilon(hh))) stop 1\n+\n+     ! check c_loc ptr again after target-value modification\n+     gg = 7777.0_c_float\n+     !$omp target update to(gg)\n+     call copy3_array(c_gptr, c_hptr, N)\n+     !$omp target update from(hh)\n+     if (any(abs(gg - 7777.0_c_float) > 10.0_c_float * epsilon(gg))) stop 1\n+     if (any(abs(3.0_c_float * gg - hh) > 10.0_c_float * epsilon(gg))) stop 1\n+\n+     ! check Fortran pointer after target-value modification\n+     gg = 77777.0_c_float\n+     !$omp target update to(gg)\n+     call copy3_array(c_loc(gptr), c_loc(hptr), N)\n+     !$omp target update from(hh)\n+     if (any(abs(gg - 77777.0_c_float) > 10.0_c_float * epsilon(gg))) stop 1\n+     if (any(abs(3.0_c_float * gg - hh) > 10.0_c_float * epsilon(gg))) stop 1\n+     !$omp end target data\n+\n+     if (any(abs(gg - 77777.0_c_float) > 10.0_c_float * epsilon(gg))) stop 1\n+     if (any(abs(3.0_c_float * gg - hh) > 10.0_c_float * epsilon(gg))) stop 1\n+  end subroutine test_dummy_opt_callee_2\n+end module test_dummies_opt\n+\n+\n+\n+! Test local dummy arguments + OPTIONAL + VALUE\n+! Values present\n+module test_dummies_opt_value\n+  use iso_c_binding\n+  use target_procs\n+  implicit none (type, external)\n+  private\n+  public :: test_dummy_opt_val_call_1, test_dummy_opt_val_call_2\n+contains\n+  subroutine test_dummy_opt_val_call_1()\n+     ! scalars - with value, neither allocatable nor pointer no dimension permitted\n+     real(c_float), target :: aa, bb\n+\n+     aa = 11.0_c_float\n+     bb = 22.0_c_float\n+\n+     call test_dummy_opt_val_callee_1(aa, bb)\n+  end subroutine test_dummy_opt_val_call_1\n+\n+  subroutine test_dummy_opt_val_callee_1(aa, bb)\n+     ! scalars\n+     real(c_float), optional, value, target :: aa, bb\n+\n+     if (.not.present(aa) .or. .not.present(bb)) stop 1\n+\n+     !$omp target data map(to:aa) map(from:bb) use_device_addr(aa,bb)\n+     if (.not.present(aa) .or. .not.present(bb)) stop 1\n+     if (.not.c_associated(c_loc(aa)) .or. .not.c_associated(c_loc(bb))) stop 1\n+     call copy3_scalar(c_loc(aa), c_loc(bb))\n+     !$omp end target data\n+     if (abs(aa - 11.0_c_float) > 10.0_c_float * epsilon(aa)) stop 1\n+     if (abs(3.0_c_float * aa - bb) > 10.0_c_float * epsilon(aa)) stop 1\n+  end subroutine test_dummy_opt_val_callee_1\n+\n+  ! Save device ptr - and recall pointer\n+  subroutine test_dummy_opt_val_call_2()\n+     ! scalars - with value, neither allocatable nor pointer no dimension permitted\n+     real(c_float), target :: aa, bb\n+     type(c_ptr) :: c_aptr, c_bptr\n+     real(c_float), pointer :: aptr, bptr\n+\n+     call test_dummy_opt_val_callee_2(aa, bb, c_aptr, c_bptr, aptr, bptr)\n+  end subroutine test_dummy_opt_val_call_2\n+\n+  subroutine test_dummy_opt_val_callee_2(aa, bb, c_aptr, c_bptr, aptr, bptr)\n+     real(c_float), optional, value, target :: aa, bb\n+     type(c_ptr), optional, value :: c_aptr, c_bptr\n+     real(c_float), optional, pointer :: aptr, bptr\n+\n+     real(c_float) :: dummy\n+\n+     if (.not.present(aa) .or. .not.present(bb)) stop 1\n+     if (.not.present(c_aptr) .or. .not.present(c_bptr)) stop 1\n+     if (.not.present(aptr) .or. .not.present(bptr)) stop 1\n+\n+     aa = 111.0_c_float\n+     bb = 222.0_c_float\n+\n+     !$omp target data map(to:aa) map(from:bb)\n+     if (.not.present(aa) .or. .not.present(bb)) stop 1\n+     if (.not.present(c_aptr) .or. .not.present(c_bptr)) stop 1\n+     if (.not.present(aptr) .or. .not.present(bptr)) stop 1\n+\n+     !$omp target data map(alloc:dummy) use_device_addr(aa,bb)\n+     if (.not.present(aa) .or. .not.present(bb)) stop 1\n+     if (.not.present(c_aptr) .or. .not.present(c_bptr)) stop 1\n+     if (.not.present(aptr) .or. .not.present(bptr)) stop 1\n+\n+     c_aptr = c_loc(aa)\n+     c_bptr = c_loc(bb)\n+     aptr => aa\n+     bptr => bb\n+     if (.not.c_associated(c_aptr) .or. .not.c_associated(c_bptr)) stop 1\n+     if (.not.associated(aptr) .or. .not.associated(bptr)) stop 1\n+     !$omp end target data\n+\n+     ! check c_loc ptr once\n+     call copy3_scalar(c_aptr, c_bptr)\n+     !$omp target update from(bb)\n+     if (abs(aa - 111.0_c_float) > 10.0_c_float * epsilon(aa)) stop 1\n+     if (abs(3.0_c_float * aa - bb) > 10.0_c_float * epsilon(aa)) stop 1\n+\n+     ! check c_loc ptr again after target-value modification\n+     aa = 1111.0_c_float\n+     !$omp target update to(aa)\n+     call copy3_scalar(c_aptr, c_bptr)\n+     !$omp target update from(bb)\n+     if (abs(aa - 1111.0_c_float) > 10.0_c_float * epsilon(aa)) stop 1\n+     if (abs(3.0_c_float * aa - bb) > 10.0_c_float * epsilon(aa)) stop 1\n+\n+     ! check Fortran pointer after target-value modification\n+     aa = 11111.0_c_float\n+     !$omp target update to(aa)\n+     call copy3_scalar(c_loc(aptr), c_loc(bptr))\n+     !$omp target update from(bb)\n+     if (abs(aa - 11111.0_c_float) > 10.0_c_float * epsilon(aa)) stop 1\n+     if (abs(3.0_c_float * aa - bb) > 10.0_c_float * epsilon(aa)) stop 1\n+     !$omp end target data\n+\n+     if (abs(aa - 11111.0_c_float) > 10.0_c_float * epsilon(aa)) stop 1\n+     if (abs(3.0_c_float * aa - bb) > 10.0_c_float * epsilon(aa)) stop 1\n+  end subroutine test_dummy_opt_val_callee_2\n+end module test_dummies_opt_value\n+\n+\n+\n+! Test nullptr\n+module test_nullptr\n+  use iso_c_binding\n+  implicit none (type, external)\n+  private\n+  public :: test_nullptr_1\n+contains\n+  subroutine test_nullptr_1()\n+     ! scalars\n+     real(c_float), pointer :: aa, bb\n+     real(c_float), pointer :: ee, ff\n+\n+     type(c_ptr) :: c_aptr, c_bptr, c_eptr, c_fptr\n+     real(c_float), pointer :: aptr, bptr, eptr, fptr\n+\n+     aa => null()\n+     bb => null()\n+     ee => null()\n+     ff => null()\n+\n+     if (associated(aa) .or. associated(bb)) stop 1\n+     !$omp target data map(to:aa) map(from:bb) use_device_addr(aa,bb)\n+     if (c_associated(c_loc(aa)) .or. c_associated(c_loc(bb))) stop 1\n+     c_aptr = c_loc(aa)\n+     c_bptr = c_loc(bb)\n+     aptr => aa\n+     bptr => bb\n+     if (c_associated(c_aptr) .or. c_associated(c_bptr)) stop 1\n+     if (associated(aptr) .or. associated(bptr, bb)) stop 1\n+     !$omp end target data\n+     if (c_associated(c_aptr) .or. c_associated(c_bptr)) stop 1\n+     if (associated(aptr) .or. associated(bptr, bb)) stop 1\n+\n+     call test_dummy_opt_nullptr_callee_1(ee, ff, c_eptr, c_fptr, eptr, fptr)\n+  end subroutine test_nullptr_1\n+\n+  subroutine test_dummy_opt_nullptr_callee_1(ee, ff, c_eptr, c_fptr, eptr, fptr)\n+     ! scalars\n+     real(c_float), optional, pointer :: ee, ff\n+\n+     type(c_ptr), optional :: c_eptr, c_fptr\n+     real(c_float), optional, pointer :: eptr, fptr\n+\n+     if (.not.present(ee) .or. .not.present(ff)) stop 1\n+     if (associated(ee) .or. associated(ff)) stop 1\n+\n+     !$omp target data map(to:ee) map(from:ff) use_device_addr(ee,ff)\n+     if (.not.present(ee) .or. .not.present(ff)) stop 1\n+     if (associated(ee) .or. associated(ff)) stop 1\n+     if (c_associated(c_loc(ee)) .or. c_associated(c_loc(ff))) stop 1\n+     c_eptr = c_loc(ee)\n+     c_fptr = c_loc(ff)\n+     eptr => ee\n+     fptr => ff\n+     if (c_associated(c_eptr) .or. c_associated(c_fptr)) stop 1\n+     if (associated(eptr) .or. associated(fptr)) stop 1\n+     !$omp end target data\n+\n+     if (c_associated(c_eptr) .or. c_associated(c_fptr)) stop 1\n+     if (associated(eptr) .or. associated(fptr)) stop 1\n+  end subroutine test_dummy_opt_nullptr_callee_1\n+end module test_nullptr\n+\n+\n+\n+! Test local variables\n+module tests\n+  use iso_c_binding\n+  use target_procs\n+  implicit none (type, external)\n+  private\n+  public :: test_main_1, test_main_2\n+contains\n+   ! map + use_device_addr + c_loc\n+   subroutine test_main_1()\n+     integer, parameter :: N = 1000\n+\n+     ! scalars\n+     real(c_float), target :: aa, bb\n+     real(c_float), target, allocatable :: cc, dd\n+     real(c_float), pointer :: ee, ff\n+\n+     ! non-descriptor arrays\n+     real(c_float), target :: gg(N), hh(N)\n+\n+     allocate(cc, dd, ee, ff)\n+\n+\n+     aa = 11.0_c_float\n+     bb = 22.0_c_float\n+     cc = 33.0_c_float\n+     dd = 44.0_c_float\n+     ee = 55.0_c_float\n+     ff = 66.0_c_float\n+     gg = 77.0_c_float\n+     hh = 88.0_c_float\n+\n+     !$omp target data map(to:aa) map(from:bb) use_device_addr(aa,bb)\n+     call copy3_scalar(c_loc(aa), c_loc(bb))\n+     !$omp end target data\n+     if (abs(aa - 11.0_c_float) > 10.0_c_float * epsilon(aa)) stop 1\n+     if (abs(3.0_c_float * aa - bb) > 10.0_c_float * epsilon(aa)) stop 1\n+\n+     !$omp target data map(to:cc) map(from:dd) use_device_addr(cc,dd)\n+     call copy3_scalar(c_loc(cc), c_loc(dd))\n+     !$omp end target data\n+     if (abs(cc - 33.0_c_float) > 10.0_c_float * epsilon(cc)) stop 1\n+     if (abs(3.0_c_float * cc - dd) > 10.0_c_float * epsilon(cc)) stop 1\n+\n+     !$omp target data map(to:ee) map(from:ff) use_device_addr(ee,ff)\n+     call copy3_scalar(c_loc(ee), c_loc(ff))\n+     !$omp end target data\n+     if (abs(ee - 55.0_c_float) > 10.0_c_float * epsilon(ee)) stop 1\n+     if (abs(3.0_c_float * ee - ff) > 10.0_c_float * epsilon(ee)) stop 1\n+\n+\n+     !$omp target data map(to:gg) map(from:hh) use_device_addr(gg,hh)\n+     call copy3_array(c_loc(gg), c_loc(hh), N)\n+     !$omp end target data\n+     if (any(abs(gg - 77.0_c_float) > 10.0_c_float * epsilon(gg))) stop 1\n+     if (any(abs(3.0_c_float * gg - hh) > 10.0_c_float * epsilon(gg))) stop 1\n+\n+     deallocate(ee, ff) ! pointers, only\n+   end subroutine test_main_1\n+\n+   ! Save device ptr - and recall pointer\n+   subroutine test_main_2\n+     integer, parameter :: N = 1000\n+\n+     ! scalars\n+     real(c_float), target :: aa, bb\n+     real(c_float), target, allocatable :: cc, dd\n+     real(c_float), pointer :: ee, ff\n+\n+     ! non-descriptor arrays\n+     real(c_float), target :: gg(N), hh(N)\n+\n+     real(c_float) :: dummy\n+     type(c_ptr) :: c_aptr, c_bptr, c_cptr, c_dptr, c_eptr, c_fptr, c_gptr, c_hptr\n+     real(c_float), pointer :: aptr, bptr, cptr, dptr, eptr, fptr\n+     real(c_float), pointer :: gptr(:), hptr(:)\n+\n+     allocate(cc, dd, ee, ff)\n+\n+     aa = 111.0_c_float\n+     bb = 222.0_c_float\n+     cc = 333.0_c_float\n+     dd = 444.0_c_float\n+     ee = 555.0_c_float\n+     ff = 666.0_c_float\n+     gg = 777.0_c_float\n+     hh = 888.0_c_float\n+\n+     !$omp target data map(to:aa) map(from:bb)\n+     !$omp target data map(alloc:dummy) use_device_addr(aa,bb)\n+     c_aptr = c_loc(aa)\n+     c_bptr = c_loc(bb)\n+     aptr => aa\n+     bptr => bb\n+     !$omp end target data\n+\n+     ! check c_loc ptr once\n+     call copy3_scalar(c_aptr, c_bptr)\n+     !$omp target update from(bb)\n+     if (abs(aa - 111.0_c_float) > 10.0_c_float * epsilon(aa)) stop 1\n+     if (abs(3.0_c_float * aa - bb) > 10.0_c_float * epsilon(aa)) stop 1\n+\n+     ! check c_loc ptr again after target-value modification\n+     aa = 1111.0_c_float\n+     !$omp target update to(aa)\n+     call copy3_scalar(c_aptr, c_bptr)\n+     !$omp target update from(bb)\n+     if (abs(aa - 1111.0_c_float) > 10.0_c_float * epsilon(aa)) stop 1\n+     if (abs(3.0_c_float * aa - bb) > 10.0_c_float * epsilon(aa)) stop 1\n+\n+     ! check Fortran pointer after target-value modification\n+     aa = 11111.0_c_float\n+     !$omp target update to(aa)\n+     call copy3_scalar(c_loc(aptr), c_loc(bptr))\n+     !$omp target update from(bb)\n+     if (abs(aa - 11111.0_c_float) > 10.0_c_float * epsilon(aa)) stop 1\n+     if (abs(3.0_c_float * aa - bb) > 10.0_c_float * epsilon(aa)) stop 1\n+     !$omp end target data\n+\n+     if (abs(aa - 11111.0_c_float) > 10.0_c_float * epsilon(aa)) stop 1\n+     if (abs(3.0_c_float * aa - bb) > 10.0_c_float * epsilon(aa)) stop 1\n+\n+\n+     !$omp target data map(to:cc) map(from:dd)\n+     !$omp target data map(alloc:dummy) use_device_addr(cc,dd)\n+     c_cptr = c_loc(cc)\n+     c_dptr = c_loc(dd)\n+     cptr => cc\n+     dptr => dd\n+     !$omp end target data\n+\n+     ! check c_loc ptr once\n+     call copy3_scalar(c_cptr, c_dptr)\n+     !$omp target update from(dd)\n+     if (abs(cc - 333.0_c_float) > 10.0_c_float * epsilon(cc)) stop 1\n+     if (abs(3.0_c_float * cc - dd) > 10.0_c_float * epsilon(cc)) stop 1\n+\n+     ! check c_loc ptr again after target-value modification\n+     cc = 3333.0_c_float\n+     !$omp target update to(cc)\n+     call copy3_scalar(c_cptr, c_dptr)\n+     !$omp target update from(dd)\n+     if (abs(cc - 3333.0_c_float) > 10.0_c_float * epsilon(cc)) stop 1\n+     if (abs(3.0_c_float * cc - dd) > 10.0_c_float * epsilon(cc)) stop 1\n+\n+     ! check Fortran pointer after target-value modification\n+     cc = 33333.0_c_float\n+     !$omp target update to(cc)\n+     call copy3_scalar(c_loc(cptr), c_loc(dptr))\n+     !$omp target update from(dd)\n+     if (abs(cc - 33333.0_c_float) > 10.0_c_float * epsilon(cc)) stop 1\n+     if (abs(3.0_c_float * cc - dd) > 10.0_c_float * epsilon(cc)) stop 1\n+     !$omp end target data\n+\n+     if (abs(cc - 33333.0_c_float) > 10.0_c_float * epsilon(dd)) stop 1\n+     if (abs(3.0_c_float * cc - dd) > 10.0_c_float * epsilon(dd)) stop 1\n+\n+\n+     !$omp target data map(to:ee) map(from:ff)\n+     !$omp target data map(alloc:dummy) use_device_addr(ee,ff)\n+     c_eptr = c_loc(ee)\n+     c_fptr = c_loc(ff)\n+     eptr => ee\n+     fptr => ff\n+     !$omp end target data\n+\n+     ! check c_loc ptr once\n+     call copy3_scalar(c_eptr, c_fptr)\n+     !$omp target update from(ff)\n+     if (abs(ee - 555.0_c_float) > 10.0_c_float * epsilon(ee)) stop 1\n+     if (abs(3.0_c_float * ee - ff) > 10.0_c_float * epsilon(ee)) stop 1\n+\n+     ! check c_loc ptr again after target-value modification\n+     ee = 5555.0_c_float\n+     !$omp target update to(ee)\n+     call copy3_scalar(c_eptr, c_fptr)\n+     !$omp target update from(ff)\n+     if (abs(ee - 5555.0_c_float) > 10.0_c_float * epsilon(ee)) stop 1\n+     if (abs(3.0_c_float * ee - ff) > 10.0_c_float * epsilon(ee)) stop 1\n+\n+     ! check Fortran pointer after target-value modification\n+     ee = 55555.0_c_float\n+     !$omp target update to(ee)\n+     call copy3_scalar(c_loc(eptr), c_loc(fptr))\n+     !$omp target update from(ff)\n+     if (abs(ee - 55555.0_c_float) > 10.0_c_float * epsilon(ee)) stop 1\n+     if (abs(3.0_c_float * ee - ff) > 10.0_c_float * epsilon(ff)) stop 1\n+     !$omp end target data\n+\n+     if (abs(ee - 55555.0_c_float) > 10.0_c_float * epsilon(ee)) stop 1\n+     if (abs(3.0_c_float * ee - ff) > 10.0_c_float * epsilon(ee)) stop 1\n+\n+\n+     !$omp target data map(to:gg) map(from:hh)\n+     !$omp target data map(alloc:dummy) use_device_addr(gg,hh)\n+     c_gptr = c_loc(gg)\n+     c_hptr = c_loc(hh)\n+     gptr => gg\n+     hptr => hh\n+     !$omp end target data\n+\n+     ! check c_loc ptr once\n+     call copy3_array(c_gptr, c_hptr, N)\n+     !$omp target update from(hh)\n+     if (any(abs(gg - 777.0_c_float) > 10.0_c_float * epsilon(gg))) stop 1\n+     if (any(abs(3.0_c_float * gg - hh) > 10.0_c_float * epsilon(hh))) stop 1\n+\n+     ! check c_loc ptr again after target-value modification\n+     gg = 7777.0_c_float\n+     !$omp target update to(gg)\n+     call copy3_array(c_gptr, c_hptr, N)\n+     !$omp target update from(hh)\n+     if (any(abs(gg - 7777.0_c_float) > 10.0_c_float * epsilon(gg))) stop 1\n+     if (any(abs(3.0_c_float * gg - hh) > 10.0_c_float * epsilon(gg))) stop 1\n+\n+     ! check Fortran pointer after target-value modification\n+     gg = 77777.0_c_float\n+     !$omp target update to(gg)\n+     call copy3_array(c_loc(gptr), c_loc(hptr), N)\n+     !$omp target update from(hh)\n+     if (any(abs(gg - 77777.0_c_float) > 10.0_c_float * epsilon(gg))) stop 1\n+     if (any(abs(3.0_c_float * gg - hh) > 10.0_c_float * epsilon(gg))) stop 1\n+     !$omp end target data\n+\n+     if (any(abs(gg - 77777.0_c_float) > 10.0_c_float * epsilon(gg))) stop 1\n+     if (any(abs(3.0_c_float * gg - hh) > 10.0_c_float * epsilon(gg))) stop 1\n+\n+     deallocate(ee, ff)\n+   end subroutine test_main_2\n+end module tests\n+\n+\n+program omp_device_addr\n+  use tests\n+  use test_dummies\n+  use test_dummies_value\n+  use test_dummies_opt\n+  use test_dummies_opt_value\n+  use test_nullptr\n+  implicit none (type, external)\n+\n+  call test_main_1()\n+  call test_main_2()\n+\n+  call test_dummy_call_1()\n+  call test_dummy_call_2()\n+\n+  call test_dummy_val_call_1()\n+  call test_dummy_val_call_2()\n+\n+  call test_dummy_opt_call_1()\n+  call test_dummy_opt_call_2()\n+\n+  call test_dummy_opt_val_call_1()\n+  call test_dummy_opt_val_call_2()\n+\n+  call test_nullptr_1()\n+end program omp_device_addr"}]}