{"sha": "87c8b4bed31dbbf4708549e10814197cac4d8249", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODdjOGI0YmVkMzFkYmJmNDcwODU0OWUxMDgxNDE5N2NhYzRkODI0OQ==", "commit": {"author": {"name": "Caroline Tice", "email": "ctice@gcc.gnu.org", "date": "2005-03-31T14:59:59Z"}, "committer": {"name": "Caroline Tice", "email": "ctice@gcc.gnu.org", "date": "2005-03-31T14:59:59Z"}, "message": "Fix problems with hot/cold partitioning optimization.\n\nFrom-SVN: r97322", "tree": {"sha": "ade60c4c4ed198b0036370e03ebd3a1f64ee4817", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ade60c4c4ed198b0036370e03ebd3a1f64ee4817"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/87c8b4bed31dbbf4708549e10814197cac4d8249", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87c8b4bed31dbbf4708549e10814197cac4d8249", "html_url": "https://github.com/Rust-GCC/gccrs/commit/87c8b4bed31dbbf4708549e10814197cac4d8249", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87c8b4bed31dbbf4708549e10814197cac4d8249/comments", "author": null, "committer": null, "parents": [{"sha": "68ec3111c0ff30d2dc2f172897379cc891ae180d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68ec3111c0ff30d2dc2f172897379cc891ae180d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/68ec3111c0ff30d2dc2f172897379cc891ae180d"}], "stats": {"total": 1127, "additions": 617, "deletions": 510}, "files": [{"sha": "5e7e495fa0eae78e6d022aed9827f9fec4b31f43", "filename": "gcc/Makefile.in", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87c8b4bed31dbbf4708549e10814197cac4d8249/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87c8b4bed31dbbf4708549e10814197cac4d8249/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=87c8b4bed31dbbf4708549e10814197cac4d8249", "patch": "@@ -1874,7 +1874,7 @@ rtlanal.o : rtlanal.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) toplev.h \\\n varasm.o : varasm.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) $(RTL_H) \\\n    $(FLAGS_H) function.h $(EXPR_H) hard-reg-set.h $(REGS_H) \\\n    output.h $(C_PRAGMA_H) toplev.h xcoffout.h debug.h $(GGC_H) $(TM_P_H) \\\n-   $(HASHTAB_H) $(TARGET_H) langhooks.h gt-varasm.h real.h\n+   $(HASHTAB_H) $(TARGET_H) langhooks.h gt-varasm.h real.h $(BASIC_BLOCK_H)\n function.o : function.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(TREE_H) $(CFGLAYOUT_H) $(TREE_GIMPLE_H) \\\n    $(FLAGS_H) function.h $(EXPR_H) $(OPTABS_H) libfuncs.h $(REGS_H) hard-reg-set.h \\\n@@ -2174,7 +2174,7 @@ lists.o: lists.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) toplev.h \\\n    $(RTL_H) $(GGC_H) gt-lists.h\n bb-reorder.o : bb-reorder.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(RTL_H) $(BASIC_BLOCK_H) $(FLAGS_H) $(TIMEVAR_H) output.h $(CFGLAYOUT_H) $(FIBHEAP_H) \\\n-   $(TARGET_H) function.h $(TM_P_H) $(OBSTACK_H) $(EXPR_H) $(REGS_H)\n+   $(TARGET_H) function.h $(TM_P_H) $(OBSTACK_H) $(EXPR_H) $(REGS_H) errors.h\n tracer.o : tracer.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) \\\n    $(BASIC_BLOCK_H) hard-reg-set.h output.h $(CFGLAYOUT_H) $(FLAGS_H) $(TIMEVAR_H) \\\n    $(PARAMS_H) $(COVERAGE_H)\n@@ -3731,7 +3731,7 @@ STAGEPROFILE_FLAGS_TO_PASS = \\\n # Files never linked into the final executable produces warnings about missing\n # profile.\n STAGEFEEDBACK_FLAGS_TO_PASS = \\\n-\tCFLAGS=\"$(BOOT_CFLAGS) -fprofile-use\"\n+\tCFLAGS=\"$(BOOT_CFLAGS) -fprofile-use -freorder-blocks-and-partition\"\n \n # Only build the C compiler for stage1, because that is the only one that\n # we can guarantee will build with the native compiler, and also it is the"}, {"sha": "b0c99b134e9708e4ff0f5ad734ab7399952ded74", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 146, "deletions": 165, "changes": 311, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87c8b4bed31dbbf4708549e10814197cac4d8249/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87c8b4bed31dbbf4708549e10814197cac4d8249/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=87c8b4bed31dbbf4708549e10814197cac4d8249", "patch": "@@ -81,6 +81,7 @@\n #include \"tm_p.h\"\n #include \"obstack.h\"\n #include \"expr.h\"\n+#include \"errors.h\"\n #include \"params.h\"\n \n /* The number of rounds.  In most cases there will only be 4 rounds, but\n@@ -119,6 +120,9 @@ typedef struct bbro_basic_block_data_def\n   /* Which trace is the bb end of (-1 means it is not an end of a trace).  */\n   int end_of_trace;\n \n+  /* Which trace is the bb in?  */\n+  int in_trace;\n+\n   /* Which heap is BB in (if any)?  */\n   fibheap_t heap;\n \n@@ -169,11 +173,9 @@ static void connect_traces (int, struct trace *);\n static bool copy_bb_p (basic_block, int);\n static int get_uncond_jump_length (void);\n static bool push_to_next_round_p (basic_block, int, int, int, gcov_type);\n-static void add_unlikely_executed_notes (void);\n static void find_rarely_executed_basic_blocks_and_crossing_edges (edge *, \n \t\t\t\t\t\t\t\t  int *,\n \t\t\t\t\t\t\t\t  int *);\n-static void mark_bb_for_unlikely_executed_section  (basic_block);\n static void add_labels_and_missing_jumps (edge *, int);\n static void add_reg_crossing_jump_notes (void);\n static void fix_up_fall_thru_edges (void);\n@@ -194,26 +196,16 @@ push_to_next_round_p (basic_block bb, int round, int number_of_rounds,\n \t\t      int exec_th, gcov_type count_th)\n {\n   bool there_exists_another_round;\n-  bool cold_block;\n   bool block_not_hot_enough;\n-  bool next_round_is_last;\n \n   there_exists_another_round = round < number_of_rounds - 1;\n-  next_round_is_last = round + 1 == number_of_rounds - 1;\n-\n-  cold_block = (flag_reorder_blocks_and_partition \n-\t\t&& BB_PARTITION (bb) == BB_COLD_PARTITION);\n \n   block_not_hot_enough = (bb->frequency < exec_th \n \t\t\t  || bb->count < count_th\n \t\t\t  || probably_never_executed_bb_p (bb));\n \n-  if (flag_reorder_blocks_and_partition\n-      && next_round_is_last\n-      && BB_PARTITION (bb) != BB_COLD_PARTITION)\n-    return false;\n-  else if (there_exists_another_round\n-      && (cold_block || block_not_hot_enough))\n+  if (there_exists_another_round\n+      && block_not_hot_enough)\n     return true;\n   else \n     return false;\n@@ -237,8 +229,6 @@ find_traces (int *n_traces, struct trace *traces)\n      cold blocks (and ONLY the cold blocks).  */\n \n   number_of_rounds = N_ROUNDS - 1;\n-  if (flag_reorder_blocks_and_partition)\n-    number_of_rounds = N_ROUNDS;\n \n   /* Insert entry points of function into heap.  */\n   heap = fibheap_new ();\n@@ -434,11 +424,6 @@ find_traces_1_round (int branch_th, int exec_th, gcov_type count_th,\n \t\t     struct trace *traces, int *n_traces, int round,\n \t\t     fibheap_t *heap, int number_of_rounds)\n {\n-  /* The following variable refers to the last round in which non-\"cold\" \n-     blocks may be collected into a trace.  */\n-\n-  int last_round = N_ROUNDS - 1;\n-\n   /* Heap for discarded basic blocks which are possible starting points for\n      the next round.  */\n   fibheap_t new_heap = fibheap_new ();\n@@ -481,6 +466,7 @@ find_traces_1_round (int branch_th, int exec_th, gcov_type count_th,\n       trace->first = bb;\n       trace->round = round;\n       trace->length = 0;\n+      bbd[bb->index].in_trace = *n_traces;\n       (*n_traces)++;\n \n       do\n@@ -514,8 +500,7 @@ find_traces_1_round (int branch_th, int exec_th, gcov_type count_th,\n \t\t  && e->dest->rbi->visited != *n_traces)\n \t\tcontinue;\n \n-\t      if (BB_PARTITION (e->dest) == BB_COLD_PARTITION\n-\t\t  && round < last_round)\n+\t      if (BB_PARTITION (e->dest) != BB_PARTITION (bb))\n \t\tcontinue;\n \n \t      prob = e->probability;\n@@ -646,6 +631,8 @@ find_traces_1_round (int branch_th, int exec_th, gcov_type count_th,\n \t\t\t\t\t   best_edge->dest->index, bb->index);\n \t\t\t\t}\n \t\t\t      bb->rbi->next = best_edge->dest;\n+\t\t\t      bbd[best_edge->dest->index].in_trace = \n+\t\t\t\t                             (*n_traces) - 1;\n \t\t\t      bb = rotate_loop (best_edge, trace, *n_traces);\n \t\t\t    }\n \t\t\t}\n@@ -658,6 +645,7 @@ find_traces_1_round (int branch_th, int exec_th, gcov_type count_th,\n \t\t\t    {\n \t\t\t      bb = copy_bb (best_edge->dest, best_edge, bb,\n \t\t\t\t\t    *n_traces);\n+\t\t\t      trace->length++;\n \t\t\t    }\n \t\t\t}\n \t\t    }\n@@ -695,7 +683,7 @@ find_traces_1_round (int branch_th, int exec_th, gcov_type count_th,\n \t\t\t&& !e->dest->rbi->visited\n \t\t\t&& single_pred_p (e->dest)\n \t\t\t&& !(e->flags & EDGE_CROSSING)\n-\t\t\t&& single_succ_p (e->dest) == 1\n+\t\t\t&& single_succ_p (e->dest)\n \t\t\t&& (single_succ_edge (e->dest)->flags\n \t\t\t    & EDGE_CAN_FALLTHRU)\n \t\t\t&& !(single_succ_edge (e->dest)->flags & EDGE_COMPLEX)\n@@ -710,6 +698,7 @@ find_traces_1_round (int branch_th, int exec_th, gcov_type count_th,\n \t\t      }\n \n \t\t  bb->rbi->next = best_edge->dest;\n+\t\t  bbd[best_edge->dest->index].in_trace = (*n_traces) - 1;\n \t\t  bb = best_edge->dest;\n \t\t}\n \t    }\n@@ -788,6 +777,7 @@ copy_bb (basic_block old_bb, edge e, basic_block bb, int trace)\n       for (i = array_size; i < new_size; i++)\n \t{\n \t  bbd[i].start_of_trace = -1;\n+\t  bbd[i].in_trace = -1;\n \t  bbd[i].end_of_trace = -1;\n \t  bbd[i].heap = NULL;\n \t  bbd[i].node = NULL;\n@@ -802,6 +792,8 @@ copy_bb (basic_block old_bb, edge e, basic_block bb, int trace)\n \t}\n     }\n \n+  bbd[new_bb->index].in_trace = trace;\n+\n   return new_bb;\n }\n \n@@ -899,11 +891,11 @@ static void\n connect_traces (int n_traces, struct trace *traces)\n {\n   int i;\n-  int unconnected_hot_trace_count = 0;\n-  bool cold_connected = true;\n   bool *connected;\n-  bool *cold_traces;\n+  bool two_passes;\n   int last_trace;\n+  int current_pass;\n+  int current_partition;\n   int freq_threshold;\n   gcov_type count_threshold;\n \n@@ -915,66 +907,47 @@ connect_traces (int n_traces, struct trace *traces)\n \n   connected = xcalloc (n_traces, sizeof (bool));\n   last_trace = -1;\n-\n-  /* If we are partitioning hot/cold basic blocks, mark the cold\n-     traces as already connected, to remove them from consideration\n-     for connection to the hot traces.  After the hot traces have all\n-     been connected (determined by \"unconnected_hot_trace_count\"), we\n-     will go back and connect the cold traces.  */\n-\n-  cold_traces = xcalloc (n_traces, sizeof (bool));\n+  current_pass = 1;\n+  current_partition = BB_PARTITION (traces[0].first);\n+  two_passes = false;\n \n   if (flag_reorder_blocks_and_partition)\n-    for (i = 0; i < n_traces; i++)\n-      {\n-\tif (BB_PARTITION (traces[i].first) == BB_COLD_PARTITION)\n-\t  {\n-\t    connected[i] = true;\n-\t    cold_traces[i] = true;\n-\t    cold_connected = false;\n-\t  }\n-\telse\n-\t  unconnected_hot_trace_count++;\n-      }\n-  \n-  for (i = 0; i < n_traces || !cold_connected ; i++)\n+    for (i = 0; i < n_traces && !two_passes; i++)\n+      if (BB_PARTITION (traces[0].first) \n+\t  != BB_PARTITION (traces[i].first))\n+\ttwo_passes = true;\n+\n+  for (i = 0; i < n_traces || (two_passes && current_pass == 1) ; i++)\n     {\n       int t = i;\n       int t2;\n       edge e, best;\n       int best_len;\n \n-      /* If we are partitioning hot/cold basic blocks, check to see\n-\t if all the hot traces have been connected.  If so, go back\n-\t and mark the cold traces as unconnected so we can connect\n-\t them up too.  Re-set \"i\" to the first (unconnected) cold\n-\t trace. Use flag \"cold_connected\" to make sure we don't do\n-         this step more than once.  */\n-\n-      if (flag_reorder_blocks_and_partition\n-\t  && (i >= n_traces || unconnected_hot_trace_count <= 0)\n-\t  && !cold_connected)\n+      if (i >= n_traces)\n \t{\n-\t  int j;\n-\t  int first_cold_trace = -1;\n-\n-\t  for (j = 0; j < n_traces; j++)\n-\t    if (cold_traces[j])\n-\t      {\n-\t\tconnected[j] = false;\n-\t\tif (first_cold_trace == -1)\n-\t\t  first_cold_trace = j;\n-\t      }\n-\t  i = t = first_cold_trace;\n-\t  cold_connected = true;\n+\t  if (two_passes && current_pass == 1)\n+\t    {\n+\t      i = 0;\n+\t      t = i;\n+\t      current_pass = 2;\n+\t      if (current_partition == BB_HOT_PARTITION)\n+\t\tcurrent_partition = BB_COLD_PARTITION;\n+\t      else\n+\t\tcurrent_partition = BB_HOT_PARTITION;\n+\t    }\n+\t  else\n+\t    abort ();\n \t}\n-\n+      \n       if (connected[t])\n \tcontinue;\n \n+      if (two_passes \n+\t  && BB_PARTITION (traces[t].first) != current_partition)\n+\tcontinue;\n+\n       connected[t] = true;\n-      if (unconnected_hot_trace_count > 0)\n-\tunconnected_hot_trace_count--;\n \n       /* Find the predecessor traces.  */\n       for (t2 = t; t2 > 0;)\n@@ -991,6 +964,7 @@ connect_traces (int n_traces, struct trace *traces)\n \t\t  && !(e->flags & EDGE_COMPLEX)\n \t\t  && bbd[si].end_of_trace >= 0\n \t\t  && !connected[bbd[si].end_of_trace]\n+\t\t  && (BB_PARTITION (e->src) == current_partition)\n \t\t  && (!best\n \t\t      || e->probability > best->probability\n \t\t      || (e->probability == best->probability\n@@ -1006,9 +980,6 @@ connect_traces (int n_traces, struct trace *traces)\n \t      t2 = bbd[best->src->index].end_of_trace;\n \t      connected[t2] = true;\n \n-\t      if (unconnected_hot_trace_count > 0)\n-\t\tunconnected_hot_trace_count--;\n-\n \t      if (dump_file)\n \t\t{\n \t\t  fprintf (dump_file, \"Connection: %d %d\\n\",\n@@ -1039,6 +1010,7 @@ connect_traces (int n_traces, struct trace *traces)\n \t\t  && !(e->flags & EDGE_COMPLEX)\n \t\t  && bbd[di].start_of_trace >= 0\n \t\t  && !connected[bbd[di].start_of_trace]\n+\t\t  && (BB_PARTITION (e->dest) == current_partition)\n \t\t  && (!best\n \t\t      || e->probability > best->probability\n \t\t      || (e->probability == best->probability\n@@ -1059,8 +1031,6 @@ connect_traces (int n_traces, struct trace *traces)\n \t      t = bbd[best->dest->index].start_of_trace;\n \t      traces[last_trace].last->rbi->next = traces[t].first;\n \t      connected[t] = true;\n-\t      if (unconnected_hot_trace_count > 0)\n-\t\tunconnected_hot_trace_count--;\n \t      last_trace = t;\n \t    }\n \t  else\n@@ -1101,6 +1071,7 @@ connect_traces (int n_traces, struct trace *traces)\n \t\t\t\t&& !(e2->flags & EDGE_COMPLEX)\n \t\t\t\t&& bbd[di].start_of_trace >= 0\n \t\t\t\t&& !connected[bbd[di].start_of_trace]\n+\t\t\t\t&& (BB_PARTITION (e2->dest) == current_partition)\n \t\t\t\t&& (EDGE_FREQUENCY (e2) >= freq_threshold)\n \t\t\t\t&& (e2->count >= count_threshold)\n \t\t\t\t&& (!best2\n@@ -1153,8 +1124,6 @@ connect_traces (int n_traces, struct trace *traces)\n \t\t      t = bbd[next_bb->index].start_of_trace;\n \t\t      traces[last_trace].last->rbi->next = traces[t].first;\n \t\t      connected[t] = true;\n-\t\t      if (unconnected_hot_trace_count > 0)\n-\t\t\tunconnected_hot_trace_count--;\n \t\t      last_trace = t;\n \t\t    }\n \t\t  else\n@@ -1178,7 +1147,6 @@ connect_traces (int n_traces, struct trace *traces)\n     }\n \n   FREE (connected);\n-  FREE (cold_traces);\n }\n \n /* Return true when BB can and should be copied. CODE_MAY_GROW is true\n@@ -1242,18 +1210,6 @@ get_uncond_jump_length (void)\n   return length;\n }\n \n-static void\n-add_unlikely_executed_notes (void)\n-{\n-  basic_block bb;\n-\n-  /* Add the UNLIKELY_EXECUTED_NOTES to each cold basic block.  */\n-\n-  FOR_EACH_BB (bb)\n-    if (BB_PARTITION (bb) == BB_COLD_PARTITION)\n-      mark_bb_for_unlikely_executed_section (bb);\n-}\n-\n /* Find the basic blocks that are rarely executed and need to be moved to\n    a separate section of the .o file (to cut down on paging and improve\n    cache locality).  */\n@@ -1282,18 +1238,6 @@ find_rarely_executed_basic_blocks_and_crossing_edges (edge *crossing_edges,\n \t}\n     }\n \n-  /* Since all \"hot\" basic blocks will eventually be scheduled before all\n-     cold basic blocks, make *sure* the real function entry block is in\n-     the hot partition (if there is one).  */\n-  \n-  if (has_hot_blocks)\n-    FOR_EACH_EDGE (e, ei, ENTRY_BLOCK_PTR->succs)\n-      if (e->dest->index >= 0)\n-\t{\n-\t  BB_SET_PARTITION (e->dest, BB_HOT_PARTITION);\n-\t  break;\n-\t}\n-\n   /* Mark every edge that crosses between sections.  */\n \n   i = 0;\n@@ -1322,39 +1266,6 @@ find_rarely_executed_basic_blocks_and_crossing_edges (edge *crossing_edges,\n   *n_crossing_edges = i;\n }\n \n-/* Add NOTE_INSN_UNLIKELY_EXECUTED_CODE to top of basic block.   This note\n-   is later used to mark the basic block to be put in the \n-   unlikely-to-be-executed section of the .o file.  */\n-\n-static void\n-mark_bb_for_unlikely_executed_section (basic_block bb) \n-{\n-  rtx cur_insn;\n-  rtx insert_insn = NULL;\n-  rtx new_note;\n-  \n-  /* Insert new NOTE immediately after  BASIC_BLOCK note.  */\n-\n-  for (cur_insn = BB_HEAD (bb); cur_insn != NEXT_INSN (BB_END (bb));\n-       cur_insn = NEXT_INSN (cur_insn))\n-    if (GET_CODE (cur_insn) == NOTE\n-\t&& NOTE_LINE_NUMBER (cur_insn) == NOTE_INSN_BASIC_BLOCK)\n-      {\n-\tinsert_insn = cur_insn;\n-\tbreak;\n-      }\n-    \n-  /* If basic block does not contain a NOTE_INSN_BASIC_BLOCK, there is\n-     a major problem.  */\n-  gcc_assert (insert_insn);\n-\n-  /* Insert note and assign basic block number to it.  */\n-  \n-  new_note = emit_note_after (NOTE_INSN_UNLIKELY_EXECUTED_CODE, \n-\t\t\t      insert_insn);\n-  NOTE_BASIC_BLOCK (new_note) = bb;\n-}\n-\n /* If any destination of a crossing edge does not have a label, add label;\n    Convert any fall-through crossing edges (for blocks that do not contain\n    a jump) to unconditional jumps.  */\n@@ -1782,6 +1693,10 @@ fix_crossing_unconditional_branches (void)\n   FOR_EACH_BB (cur_bb)\n     {\n       last_insn = BB_END (cur_bb);\n+\n+      if (EDGE_COUNT (cur_bb->succs) < 1)\n+\tcontinue;\n+\n       succ = EDGE_SUCC (cur_bb, 0);\n \n       /* Check to see if bb ends in a crossing (unconditional) jump.  At\n@@ -1864,19 +1779,19 @@ add_reg_crossing_jump_notes (void)\n \t\t\t\t\t\t\t\t  (e->src)));\n }\n \n-/* Basic blocks containing NOTE_INSN_UNLIKELY_EXECUTED_CODE will be\n-   put in a separate section of the .o file, to reduce paging and\n-   improve cache performance (hopefully).  This can result in bits of\n-   code from the same function being widely separated in the .o file.\n-   However this is not obvious to the current bb structure.  Therefore\n-   we must take care to ensure that: 1). There are no fall_thru edges\n-   that cross between sections;  2). For those architectures which\n-   have \"short\" conditional branches, all conditional branches that\n-   attempt to cross between sections are converted to unconditional\n-   branches; and, 3). For those architectures which have \"short\"\n-   unconditional branches, all unconditional branches that attempt\n-   to cross between sections are converted to indirect jumps.\n-   \n+/* Hot and cold basic blocks are partitioneed and put in separate\n+   sections of the .o file, to reduce paging and improve cache\n+   performance (hopefully).  This can result in bits of code from the\n+   same function being widely separated in the .o file.  However this\n+   is not obvious to the current bb structure.  Therefore we must take\n+   care to ensure that: 1). There are no fall_thru edges that cross\n+   between sections; 2). For those architectures which have \"short\"\n+   conditional branches, all conditional branches that attempt to\n+   cross between sections are converted to unconditional branches;\n+   and, 3). For those architectures which have \"short\" unconditional\n+   branches, all unconditional branches that attempt to cross between\n+   sections are converted to indirect jumps.\n+\n    The code for fixing up fall_thru edges that cross between hot and\n    cold basic blocks does so by creating new basic blocks containing \n    unconditional branches to the appropriate label in the \"other\" \n@@ -1942,6 +1857,44 @@ fix_edges_for_rarely_executed_code (edge *crossing_edges,\n     }\n }\n \n+/* Verify, in the basic block chain, that there is at most one switch\n+   between hot/cold partitions. This is modelled on\n+   rtl_verify_flow_info_1, but it cannot go inside that function\n+   because this condition will not be true until after\n+   reorder_basic_blocks is called.  */\n+\n+static void\n+verify_hot_cold_block_grouping (void)\n+{\n+  basic_block bb;\n+  int err = 0;\n+  bool switched_sections = false;\n+  int current_partition = 0;\n+  \n+  FOR_EACH_BB (bb)\n+    {\n+      if (!current_partition)\n+\tcurrent_partition = BB_PARTITION (bb);\n+      if (BB_PARTITION (bb) != current_partition)\n+\t{\n+\t  if (switched_sections)\n+\t    {\n+\t      error (\"Multiple hot/cold transitions found (bb %i)\",\n+\t\t     bb->index);\n+\t      err = 1;\n+\t    }\n+\t  else\n+\t    {\n+\t      switched_sections = true;\n+\t      current_partition = BB_PARTITION (bb);\n+\t    }\n+\t}\n+    }\n+  \n+  if (err)\n+    internal_error (\"verify_hot_cold_block_grouping failed\");\n+}\n+\n /* Reorder basic blocks.  The main entry point to this file.  FLAGS is\n    the set of flags to pass to cfg_layout_initialize().  */\n \n@@ -1976,6 +1929,7 @@ reorder_basic_blocks (unsigned int flags)\n   for (i = 0; i < array_size; i++)\n     {\n       bbd[i].start_of_trace = -1;\n+      bbd[i].in_trace = -1;\n       bbd[i].end_of_trace = -1;\n       bbd[i].heap = NULL;\n       bbd[i].node = NULL;\n@@ -1991,15 +1945,42 @@ reorder_basic_blocks (unsigned int flags)\n   if (dump_file)\n     dump_flow_info (dump_file);\n \n-  if (flag_reorder_blocks_and_partition\n-      && targetm.have_named_sections)\n-    add_unlikely_executed_notes ();\n-\n   cfg_layout_finalize ();\n+  verify_hot_cold_block_grouping ();\n \n   timevar_pop (TV_REORDER_BLOCKS);\n }\n \n+/* Determine which partition the first basic block in the function\n+   belongs to, then find the first basic block in the current function\n+   that belongs to a different section, and insert a\n+   NOTE_INSN_SWITCH_TEXT_SECTIONS note immediately before it in the\n+   instruction stream.  When writing out the assembly code,\n+   encountering this note will make the compiler switch between the\n+   hot and cold text sections.  */\n+\n+void\n+insert_section_boundary_note (void)\n+{\n+  basic_block bb;\n+  rtx new_note;\n+  int first_partition = 0;\n+  \n+  if (flag_reorder_blocks_and_partition\n+      && targetm.have_named_sections)\n+    FOR_EACH_BB (bb)\n+    {\n+      if (!first_partition)\n+\tfirst_partition = BB_PARTITION (bb);\n+      if (BB_PARTITION (bb) != first_partition)\n+\t{\n+\t  new_note = emit_note_before (NOTE_INSN_SWITCH_TEXT_SECTIONS,\n+\t\t\t\t       BB_HEAD (bb));\n+\t  break;\n+\t}\n+    }\n+}\n+\n /* Duplicate the blocks containing computed gotos.  This basically unfactors\n    computed gotos that were factored early on in the compilation process to\n    speed up edge based data flow.  We used to not unfactoring them again,\n@@ -2041,7 +2022,8 @@ duplicate_computed_gotos (void)\n \n       /* If the block ends in a computed jump and it is small enough,\n \t make it a candidate for duplication.  */\n-      if (computed_jump_p (BB_END (bb)))\n+      if (computed_jump_p (BB_END (bb))\n+\t  && !find_reg_note (BB_END (bb), REG_CROSSING_JUMP, NULL_RTX))\n \t{\n \t  rtx insn;\n \t  int size = 0;\n@@ -2110,15 +2092,14 @@ duplicate_computed_gotos (void)\n    function above).\n \n    This optimization checks the feedback information to determine\n-   which basic blocks are hot/cold and causes reorder_basic_blocks to\n-   add NOTE_INSN_UNLIKELY_EXECUTED_CODE to non-hot basic blocks.  The\n-   presence or absence of this note is later used for writing out\n-   sections in the .o file.  Because hot and cold sections can be\n-   arbitrarily large (within the bounds of memory), far beyond the\n-   size of a single function, it is necessary to fix up all edges that\n-   cross section boundaries, to make sure the instructions used can\n-   actually span the required distance.  The fixes are described\n-   below.\n+   which basic blocks are hot/cold, updates flags on the basic blocks\n+   to indicate which section they belong in.  This information is\n+   later used for writing out sections in the .o file.  Because hot\n+   and cold sections can be arbitrarily large (within the bounds of\n+   memory), far beyond the size of a single function, it is necessary\n+   to fix up all edges that cross section boundaries, to make sure the\n+   instructions used can actually span the required distance.  The\n+   fixes are described below.\n \n    Fall-through edges must be changed into jumps; it is not safe or\n    legal to fall through across a section boundary.  Whenever a"}, {"sha": "70bd28d173c8892c57b3333dd1d91106391e92b2", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 10, "deletions": 20, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87c8b4bed31dbbf4708549e10814197cac4d8249/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87c8b4bed31dbbf4708549e10814197cac4d8249/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=87c8b4bed31dbbf4708549e10814197cac4d8249", "patch": "@@ -155,9 +155,8 @@ try_simplify_condjump (basic_block cbranch_block)\n      partition boundaries).  See the comments at the top of \n      bb-reorder.c:partition_hot_cold_basic_blocks for complete details.  */\n \n-  if (flag_reorder_blocks_and_partition\n-      && (BB_PARTITION (jump_block) != BB_PARTITION (jump_dest_block)\n-\t  || (cbranch_jump_edge->flags & EDGE_CROSSING)))\n+  if (BB_PARTITION (jump_block) != BB_PARTITION (jump_dest_block)\n+      || (cbranch_jump_edge->flags & EDGE_CROSSING))\n     return false;\n \n   /* The conditional branch must target the block after the\n@@ -435,8 +434,7 @@ try_forward_edges (int mode, basic_block b)\n      partition boundaries).  See the comments at the top of \n      bb-reorder.c:partition_hot_cold_basic_blocks for complete details.  */\n \n-  if (flag_reorder_blocks_and_partition\n-      && find_reg_note (BB_END (b), REG_CROSSING_JUMP, NULL_RTX))\n+  if (find_reg_note (BB_END (b), REG_CROSSING_JUMP, NULL_RTX))\n     return false;\n \n   for (ei = ei_start (b->succs); (e = ei_safe_edge (ei)); )\n@@ -471,8 +469,7 @@ try_forward_edges (int mode, basic_block b)\n \t bb-reorder.c:partition_hot_cold_basic_blocks for complete\n \t details.  */\n \n-      if (flag_reorder_blocks_and_partition\n-\t  && first != EXIT_BLOCK_PTR\n+      if (first != EXIT_BLOCK_PTR\n \t  && find_reg_note (BB_END (first), REG_CROSSING_JUMP, NULL_RTX))\n \treturn false;\n \n@@ -684,9 +681,7 @@ merge_blocks_move_predecessor_nojumps (basic_block a, basic_block b)\n      partition boundaries).  See the comments at the top of \n      bb-reorder.c:partition_hot_cold_basic_blocks for complete details.  */\n \n-  if (flag_reorder_blocks_and_partition\n-      && (BB_PARTITION (a) != BB_PARTITION (b)\n-\t  || find_reg_note (BB_END (a), REG_CROSSING_JUMP, NULL_RTX)))\n+  if (BB_PARTITION (a) != BB_PARTITION (b))\n     return;\n \n   barrier = next_nonnote_insn (BB_END (a));\n@@ -742,9 +737,7 @@ merge_blocks_move_successor_nojumps (basic_block a, basic_block b)\n      partition boundaries).  See the comments at the top of \n      bb-reorder.c:partition_hot_cold_basic_blocks for complete details.  */\n \n-  if (flag_reorder_blocks_and_partition\n-      && (find_reg_note (BB_END (a), REG_CROSSING_JUMP, NULL_RTX)\n-\t  || BB_PARTITION (a) != BB_PARTITION (b)))\n+  if (BB_PARTITION (a) != BB_PARTITION (b))\n     return;\n \n   real_b_end = BB_END (b);\n@@ -814,10 +807,7 @@ merge_blocks_move (edge e, basic_block b, basic_block c, int mode)\n      partition boundaries).  See the comments at the top of \n      bb-reorder.c:partition_hot_cold_basic_blocks for complete details.  */\n \n-  if (flag_reorder_blocks_and_partition\n-      && (find_reg_note (BB_END (b), REG_CROSSING_JUMP, NULL_RTX)\n-\t  || find_reg_note (BB_END (c), REG_CROSSING_JUMP, NULL_RTX)\n-\t  || BB_PARTITION (b) != BB_PARTITION (c)))\n+  if (BB_PARTITION (b) != BB_PARTITION (c))\n     return NULL;\n       \n     \n@@ -1725,9 +1715,9 @@ try_crossjump_bb (int mode, basic_block bb)\n      partition boundaries).  See the comments at the top of \n      bb-reorder.c:partition_hot_cold_basic_blocks for complete details.  */\n \n-  if (flag_reorder_blocks_and_partition\n-      && (BB_PARTITION (EDGE_PRED (bb, 0)->src) != BB_PARTITION (EDGE_PRED (bb, 1)->src)\n-\t  || (EDGE_PRED (bb, 0)->flags & EDGE_CROSSING)))\n+  if (BB_PARTITION (EDGE_PRED (bb, 0)->src) != \n+                                        BB_PARTITION (EDGE_PRED (bb, 1)->src)\n+      || (EDGE_PRED (bb, 0)->flags & EDGE_CROSSING))\n     return false;\n \n   /* It is always cheapest to redirect a block that ends in a branch to"}, {"sha": "6b6006291d75c84bbe2fbad62d49d78c1e3bf72a", "filename": "gcc/cfglayout.c", "status": "modified", "additions": 7, "deletions": 41, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87c8b4bed31dbbf4708549e10814197cac4d8249/gcc%2Fcfglayout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87c8b4bed31dbbf4708549e10814197cac4d8249/gcc%2Fcfglayout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfglayout.c?ref=87c8b4bed31dbbf4708549e10814197cac4d8249", "patch": "@@ -51,7 +51,6 @@ static void change_scope (rtx, tree, tree);\n void verify_insn_chain (void);\n static void fixup_fallthru_exit_predecessor (void);\n static tree insn_scope (rtx);\n-static void update_unlikely_executed_notes (basic_block);\n \f\n rtx\n unlink_insn_chain (rtx first, rtx last)\n@@ -784,28 +783,12 @@ fixup_reorder_chain (void)\n \t     section boundaries).  */\n \t  BB_COPY_PARTITION (e_fall->src, single_pred (bb));\n \t  if (flag_reorder_blocks_and_partition\n-\t      && targetm.have_named_sections)\n-\t    {\n-\t      if (BB_PARTITION (single_pred (bb)) == BB_COLD_PARTITION)\n-\t\t{\n-\t\t  rtx new_note;\n-\t\t  rtx note = BB_HEAD (e_fall->src);\n-\t\t  \n-\t\t  while (!INSN_P (note)\n-\t\t\t && note != BB_END (e_fall->src))\n-\t\t    note = NEXT_INSN (note);\n-\t\t  \n-\t\t  new_note = emit_note_before \n-                                          (NOTE_INSN_UNLIKELY_EXECUTED_CODE, \n-\t\t\t\t\t   note);\n-\t\t  NOTE_BASIC_BLOCK (new_note) = bb;\n-\t\t}\n-\t      if (JUMP_P (BB_END (bb))\n-\t\t  && !any_condjump_p (BB_END (bb))\n-  \t\t  && (single_succ_edge (bb)->flags & EDGE_CROSSING))\n-\t\tREG_NOTES (BB_END (bb)) = gen_rtx_EXPR_LIST \n-\t\t  (REG_CROSSING_JUMP, NULL_RTX, REG_NOTES (BB_END (bb)));\n-\t    }\n+\t      && targetm.have_named_sections\n+\t      && JUMP_P (BB_END (bb))\n+\t      && !any_condjump_p (BB_END (bb))\n+\t      && (EDGE_SUCC (bb, 0)->flags & EDGE_CROSSING))\n+\t    REG_NOTES (BB_END (bb)) = gen_rtx_EXPR_LIST\n+\t      (REG_CROSSING_JUMP, NULL_RTX, REG_NOTES (BB_END (bb)));\n \t}\n     }\n \n@@ -840,8 +823,6 @@ fixup_reorder_chain (void)\n       bb->index = index;\n       BASIC_BLOCK (index) = bb;\n \n-      update_unlikely_executed_notes (bb);\n-\n       bb->prev_bb = prev_bb;\n       prev_bb->next_bb = bb;\n     }\n@@ -863,21 +844,6 @@ fixup_reorder_chain (void)\n     }\n }\n \f\n-/* Update the basic block number information in any \n-   NOTE_INSN_UNLIKELY_EXECUTED_CODE notes within the basic block.  */\n-\n-static void\n-update_unlikely_executed_notes (basic_block bb)\n-{\n-  rtx cur_insn;\n-\n-  for (cur_insn = BB_HEAD (bb); cur_insn != BB_END (bb); \n-       cur_insn = NEXT_INSN (cur_insn)) \n-    if (NOTE_P (cur_insn)\n-\t&& NOTE_LINE_NUMBER (cur_insn) == NOTE_INSN_UNLIKELY_EXECUTED_CODE)\n-      NOTE_BASIC_BLOCK (cur_insn) = bb;\n-}\n-\f\n /* Perform sanity checks on the insn chain.\n    1. Check that next/prev pointers are consistent in both the forward and\n       reverse direction.\n@@ -1046,7 +1012,7 @@ duplicate_insn_chain (rtx from, rtx to)\n \t      break;\n \n \t    case NOTE_INSN_REPEATED_LINE_NUMBER:\n-\t    case NOTE_INSN_UNLIKELY_EXECUTED_CODE:\n+\t    case NOTE_INSN_SWITCH_TEXT_SECTIONS:\n \t      emit_note_copy (insn);\n \t      break;\n "}, {"sha": "14105099054e9d75a22ab58b83c5763956ceef94", "filename": "gcc/cfglayout.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87c8b4bed31dbbf4708549e10814197cac4d8249/gcc%2Fcfglayout.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87c8b4bed31dbbf4708549e10814197cac4d8249/gcc%2Fcfglayout.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfglayout.h?ref=87c8b4bed31dbbf4708549e10814197cac4d8249", "patch": "@@ -32,7 +32,6 @@ extern void reemit_insn_block_notes (void);\n extern bool can_copy_bbs_p (basic_block *, unsigned);\n extern void copy_bbs (basic_block *, unsigned, basic_block *,\n \t\t      edge *, unsigned, edge *, struct loop *);\n-extern bool scan_ahead_for_unlikely_executed_note (rtx);\n extern rtx duplicate_insn_chain (rtx, rtx);\n \n #endif /* GCC_CFGLAYOUT_H */"}, {"sha": "d11db10b0e66fc8943bd97d7bd75b342a9b74840", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 16, "deletions": 46, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87c8b4bed31dbbf4708549e10814197cac4d8249/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87c8b4bed31dbbf4708549e10814197cac4d8249/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=87c8b4bed31dbbf4708549e10814197cac4d8249", "patch": "@@ -92,8 +92,7 @@ static int\n can_delete_note_p (rtx note)\n {\n   return (NOTE_LINE_NUMBER (note) == NOTE_INSN_DELETED\n-\t  || NOTE_LINE_NUMBER (note) == NOTE_INSN_BASIC_BLOCK\n-\t  || NOTE_LINE_NUMBER (note) == NOTE_INSN_UNLIKELY_EXECUTED_CODE);\n+\t  || NOTE_LINE_NUMBER (note) == NOTE_INSN_BASIC_BLOCK);\n }\n \n /* True if a given label can be deleted.  */\n@@ -616,10 +615,7 @@ rtl_can_merge_blocks (basic_block a,basic_block b)\n      partition boundaries).  See  the comments at the top of \n      bb-reorder.c:partition_hot_cold_basic_blocks for complete details.  */\n \n-  if (flag_reorder_blocks_and_partition\n-      && (find_reg_note (BB_END (a), REG_CROSSING_JUMP, NULL_RTX)\n-\t  || find_reg_note (BB_END (b), REG_CROSSING_JUMP, NULL_RTX)\n-\t  || BB_PARTITION (a) != BB_PARTITION (b)))\n+  if (BB_PARTITION (a) != BB_PARTITION (b))\n     return false;\n \n   /* There must be exactly one edge in between the blocks.  */\n@@ -678,9 +674,8 @@ try_redirect_by_replacing_jump (edge e, basic_block target, bool in_cfglayout)\n      partition boundaries).  See  the comments at the top of \n      bb-reorder.c:partition_hot_cold_basic_blocks for complete details.  */\n   \n-  if (flag_reorder_blocks_and_partition\n-      && (find_reg_note (insn, REG_CROSSING_JUMP, NULL_RTX)\n-\t  || BB_PARTITION (src) != BB_PARTITION (target)))\n+  if (find_reg_note (insn, REG_CROSSING_JUMP, NULL_RTX)\n+      || BB_PARTITION (src) != BB_PARTITION (target))\n     return NULL;\n \n   /* We can replace or remove a complex jump only when we have exactly\n@@ -1108,29 +1103,16 @@ force_nonfallthru_and_redirect (edge e, basic_block target)\n \n       BB_COPY_PARTITION (jump_block, e->src);\n       if (flag_reorder_blocks_and_partition\n-\t  && targetm.have_named_sections)\n-\t{\n-\t  if (BB_PARTITION (jump_block) == BB_COLD_PARTITION)\n-\t    {\n-\t      rtx bb_note, new_note;\n-\t      for (bb_note = BB_HEAD (jump_block); \n-\t\t   bb_note && bb_note != NEXT_INSN (BB_END (jump_block));\n-\t\t   bb_note = NEXT_INSN (bb_note))\n-\t\tif (NOTE_P (bb_note)\n-\t\t    && NOTE_LINE_NUMBER (bb_note) == NOTE_INSN_BASIC_BLOCK)\n-\t\t  break;\n-\t      new_note = emit_note_after (NOTE_INSN_UNLIKELY_EXECUTED_CODE,\n-\t\t\t\t\t  bb_note);\n-\t      NOTE_BASIC_BLOCK (new_note) = jump_block; \n-\t    }\n-\t  if (JUMP_P (BB_END (jump_block))\n-\t      && !any_condjump_p (BB_END (jump_block))\n-\t      && (single_succ_edge (jump_block)->flags & EDGE_CROSSING))\n-\t    REG_NOTES (BB_END (jump_block)) = gen_rtx_EXPR_LIST \n-\t      (REG_CROSSING_JUMP, NULL_RTX, \n-\t       REG_NOTES (BB_END (jump_block)));\n-\t}\n-\n+\t  && targetm.have_named_sections\n+\t  && JUMP_P (BB_END (jump_block))\n+\t  && !any_condjump_p (BB_END (jump_block))\n+\t  && (EDGE_SUCC (jump_block, 0)->flags & EDGE_CROSSING))\n+\tREG_NOTES (BB_END (jump_block)) = gen_rtx_EXPR_LIST (REG_CROSSING_JUMP,\n+\t\t\t\t\t\t\t     NULL_RTX,\n+\t\t\t\t\t\t\t     REG_NOTES\n+\t\t\t\t\t\t\t     (BB_END\n+                                                              (jump_block)));\n+      \n       /* Wire edge in.  */\n       new_edge = make_edge (e->src, jump_block, EDGE_FALLTHRU);\n       new_edge->probability = e->probability;\n@@ -1576,10 +1558,6 @@ commit_one_edge_insertion (edge e, int watch_calls)\n \t    tmp = NEXT_INSN (tmp);\n \t  if (NOTE_INSN_BASIC_BLOCK_P (tmp))\n \t    tmp = NEXT_INSN (tmp);\n-\t  if (tmp \n-\t      && NOTE_P (tmp)\n-\t      && NOTE_LINE_NUMBER (tmp) == NOTE_INSN_UNLIKELY_EXECUTED_CODE)\n-\t    tmp = NEXT_INSN (tmp);\n \t  if (tmp == BB_HEAD (bb))\n \t    before = tmp;\n \t  else if (tmp)\n@@ -1629,7 +1607,7 @@ commit_one_edge_insertion (edge e, int watch_calls)\n \t      && BB_PARTITION (e->src) == BB_COLD_PARTITION\n \t      && !(e->flags & EDGE_CROSSING))\n \t    {\n-\t      rtx bb_note, new_note, cur_insn;\n+\t      rtx bb_note, cur_insn;\n \n \t      bb_note = NULL_RTX;\n \t      for (cur_insn = BB_HEAD (bb); cur_insn != NEXT_INSN (BB_END (bb));\n@@ -1641,16 +1619,11 @@ commit_one_edge_insertion (edge e, int watch_calls)\n \t\t    break;\n \t\t  }\n \n-\t      new_note = emit_note_after (NOTE_INSN_UNLIKELY_EXECUTED_CODE,\n-\t\t\t\t\t  bb_note);\n-\t      NOTE_BASIC_BLOCK (new_note) = bb;\n \t      if (JUMP_P (BB_END (bb))\n \t\t  && !any_condjump_p (BB_END (bb))\n   \t\t  && (single_succ_edge (bb)->flags & EDGE_CROSSING))\n \t\tREG_NOTES (BB_END (bb)) = gen_rtx_EXPR_LIST \n \t\t  (REG_CROSSING_JUMP, NULL_RTX, REG_NOTES (BB_END (bb)));\n-\t      if (after == bb_note)\n-\t\tafter = new_note;\n \t    }\n \t}\n     }\n@@ -2717,10 +2690,7 @@ cfg_layout_can_merge_blocks_p (basic_block a, basic_block b)\n      partition boundaries).  See  the comments at the top of \n      bb-reorder.c:partition_hot_cold_basic_blocks for complete details.  */\n \n-  if (flag_reorder_blocks_and_partition\n-      && (find_reg_note (BB_END (a), REG_CROSSING_JUMP, NULL_RTX)\n-\t  || find_reg_note (BB_END (b), REG_CROSSING_JUMP, NULL_RTX)\n-\t  || BB_PARTITION (a) != BB_PARTITION (b)))\n+  if (BB_PARTITION (a) != BB_PARTITION (b))\n     return false;\n \n   /* There must be exactly one edge in between the blocks.  */"}, {"sha": "e6f41a22994ed63d350b148753687e82d6632874", "filename": "gcc/config/darwin.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87c8b4bed31dbbf4708549e10814197cac4d8249/gcc%2Fconfig%2Fdarwin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87c8b4bed31dbbf4708549e10814197cac4d8249/gcc%2Fconfig%2Fdarwin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdarwin.c?ref=87c8b4bed31dbbf4708549e10814197cac4d8249", "patch": "@@ -1016,12 +1016,17 @@ machopic_select_section (tree exp, int reloc,\n   bool weak_p = DECL_P (exp) && DECL_WEAK (exp);\n   static void (* const base_funs[][2])(void) = {\n     { text_section, text_coal_section },\n-    { text_unlikely_section, text_unlikely_coal_section },\n+    { unlikely_text_section, text_unlikely_coal_section },\n     { readonly_data_section, const_coal_section },\n     { const_data_section, const_data_coal_section },\n     { data_section, data_coal_section }\n   };\n \n+  if (reloc == 0\n+      && (last_text_section == in_text_unlikely\n+\t  || last_text_section == in_text_unlikely_coal))\n+    reloc = 1;\n+    \n   if (TREE_CODE (exp) == FUNCTION_DECL)\n     base_function = base_funs[reloc][weak_p];\n   else if (decl_readonly_section_1 (exp, reloc, MACHOPIC_INDIRECT))"}, {"sha": "25d1bcade86203148d6165f0c98b17c67685a52e", "filename": "gcc/config/darwin.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87c8b4bed31dbbf4708549e10814197cac4d8249/gcc%2Fconfig%2Fdarwin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87c8b4bed31dbbf4708549e10814197cac4d8249/gcc%2Fconfig%2Fdarwin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdarwin.h?ref=87c8b4bed31dbbf4708549e10814197cac4d8249", "patch": "@@ -621,6 +621,10 @@ FUNCTION (void)\t\t\t\t\t\t\t\t\\\n       if (asm_out_file)\t\t\t\t\t\t\t\\\n \tfputs (\"\\t\" DIRECTIVE \"\\n\", asm_out_file);\t\t\t\\\n       in_section = SECTION;\t\t\t\t\t\t\\\n+      if ((SECTION == in_text_coal)                                     \\\n+\t  || (SECTION == in_text_unlikely)                              \\\n+\t  || (SECTION == in_text_unlikely_coal))                        \\\n+        last_text_section = SECTION;                                    \\\n     }\t\t\t\t\t\t\t\t\t\\\n }\t\t\t\t\t\t\t\t\t\\\n \n@@ -660,10 +664,6 @@ SECTION_FUNCTION (text_coal_section,\t\t\t\t\\\n \t\t  in_text_coal,\t\t\t\t\t\\\n \t\t  \".section __TEXT,__textcoal_nt,coalesced,\"\t\\\n \t\t    \"pure_instructions\", 0)\t\t\t\\\n-SECTION_FUNCTION (text_unlikely_section,\t\t\t\\\n-\t\t  in_text_unlikely,\t\t\t\t\\\n-\t\t  \".section __TEXT,__text_unlikely,coalesced,\"\t\\\n-\t\t    \"pure_instructions\", 0)\t\t\t\\\n SECTION_FUNCTION (text_unlikely_coal_section,\t\t\t\\\n \t\t  in_text_unlikely_coal,\t\t\t\\\n \t\t  \".section __TEXT,__text_unlikely_coal,\"\t\\"}, {"sha": "340a3776958feea021a54c5ef23c1ab515c6b4d8", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87c8b4bed31dbbf4708549e10814197cac4d8249/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87c8b4bed31dbbf4708549e10814197cac4d8249/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=87c8b4bed31dbbf4708549e10814197cac4d8249", "patch": "@@ -8201,7 +8201,7 @@ sparc_output_deferred_case_vectors (void)\n     return;\n \n   /* Align to cache line in the function's code section.  */\n-  function_section (current_function_decl);\n+  current_function_section (current_function_decl);\n \n   align = floor_log2 (FUNCTION_BOUNDARY / BITS_PER_UNIT);\n   if (align > 0)"}, {"sha": "a15051f92029e49aff726919a9fba92b6c1d615c", "filename": "gcc/config/stormy16/stormy16.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87c8b4bed31dbbf4708549e10814197cac4d8249/gcc%2Fconfig%2Fstormy16%2Fstormy16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87c8b4bed31dbbf4708549e10814197cac4d8249/gcc%2Fconfig%2Fstormy16%2Fstormy16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fstormy16%2Fstormy16.c?ref=87c8b4bed31dbbf4708549e10814197cac4d8249", "patch": "@@ -2074,7 +2074,7 @@ xstormy16_output_addr_vec (FILE *file, rtx label ATTRIBUTE_UNUSED, rtx table)\n { \n   int vlen, idx;\n   \n-  function_section (current_function_decl);\n+  current_function_section (current_function_decl);\n \n   vlen = XVECLEN (table, 0);\n   for (idx = 0; idx < vlen; idx++)"}, {"sha": "b6084c9c5d2e599759f1cc8f935a5791320d91fd", "filename": "gcc/config/xtensa/xtensa.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87c8b4bed31dbbf4708549e10814197cac4d8249/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87c8b4bed31dbbf4708549e10814197cac4d8249/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.c?ref=87c8b4bed31dbbf4708549e10814197cac4d8249", "patch": "@@ -1560,6 +1560,15 @@ override_options (void)\n   /* There's no need for -fPIC (as opposed to -fpic) on Xtensa.  */\n   if (flag_pic > 1)\n     flag_pic = 1;\n+\n+  /* Hot/cold partitioning does not work on this architecture, because of\n+     constant pools (the load instruction cannot necessarily reach that far).\n+     Therefore disable it on this architecture.  */\n+  if (flag_reorder_blocks_and_partition)\n+    {\n+      flag_reorder_blocks_and_partition = 0;\n+      flag_reorder_blocks = 1;\n+    }\n }\n \n "}, {"sha": "ea830a62e9cde2cfca8757f6436d7f723c039e85", "filename": "gcc/dbxout.c", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87c8b4bed31dbbf4708549e10814197cac4d8249/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87c8b4bed31dbbf4708549e10814197cac4d8249/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=87c8b4bed31dbbf4708549e10814197cac4d8249", "patch": "@@ -275,7 +275,7 @@ static int pending_bincls = 0;\n static const char *base_input_file;\n \n #ifdef DEBUG_SYMS_TEXT\n-#define FORCE_TEXT function_section (current_function_decl);\n+#define FORCE_TEXT current_function_section (current_function_decl);\n #else\n #define FORCE_TEXT\n #endif\n@@ -379,6 +379,7 @@ const struct gcc_debug_hooks dbx_debug_hooks =\n   debug_nothing_rtx,\t\t         /* label */\n   dbxout_handle_pch,\t\t         /* handle_pch */\n   debug_nothing_rtx,\t\t         /* var_location */\n+  debug_nothing_void,                    /* switch_text_section */\n   0                                      /* start_end_main_source_file */\n };\n #endif /* DBX_DEBUGGING_INFO  */\n@@ -410,6 +411,7 @@ const struct gcc_debug_hooks xcoff_debug_hooks =\n   debug_nothing_rtx,\t\t         /* label */\n   dbxout_handle_pch,\t\t         /* handle_pch */\n   debug_nothing_rtx,\t\t         /* var_location */\n+  debug_nothing_void,                    /* switch_text_section */\n   0                                      /* start_end_main_source_file */\n };\n #endif /* XCOFF_DEBUGGING_INFO  */\n@@ -934,9 +936,21 @@ dbxout_function_end (tree decl)\n #ifdef DBX_OUTPUT_NFUN\n   DBX_OUTPUT_NFUN (asm_out_file, lscope_label_name, current_function_decl);\n #else\n-  dbxout_begin_empty_stabs (N_FUN);\n-  dbxout_stab_value_label_diff (lscope_label_name,\n-\t\t\t\tXSTR (XEXP (DECL_RTL (current_function_decl), 0), 0));\n+  if (flag_reorder_blocks_and_partition)\n+    {\n+      dbxout_begin_empty_stabs (N_FUN);\n+      dbxout_stab_value_label_diff (hot_section_end_label, hot_section_label);\n+      dbxout_begin_empty_stabs (N_FUN);\n+      dbxout_stab_value_label_diff (cold_section_end_label, \n+\t\t\t\t    unlikely_section_label);\n+    }\n+  else\n+    {\n+      dbxout_begin_empty_stabs (N_FUN);\n+      dbxout_stab_value_label_diff (lscope_label_name,\n+\t\t\t\t    XSTR (XEXP (DECL_RTL (current_function_decl), \n+\t\t\t\t\t\t0), 0));\n+    }\n \t\t\t\t\n #endif\n "}, {"sha": "e34b7b9f61b19826bbe2883bfe9de5cb58ffdb76", "filename": "gcc/debug.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87c8b4bed31dbbf4708549e10814197cac4d8249/gcc%2Fdebug.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87c8b4bed31dbbf4708549e10814197cac4d8249/gcc%2Fdebug.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdebug.c?ref=87c8b4bed31dbbf4708549e10814197cac4d8249", "patch": "@@ -48,6 +48,7 @@ const struct gcc_debug_hooks do_nothing_debug_hooks =\n   debug_nothing_rtx,\t\t         /* label */\n   debug_nothing_int,\t\t         /* handle_pch */\n   debug_nothing_rtx,\t\t         /* var_location */\n+  debug_nothing_void,                    /* switch_text_section */\n   0                                      /* start_end_main_source_file */\n };\n "}, {"sha": "5b4074b1294e97a3afd3257d29a0cbf6c11884c1", "filename": "gcc/debug.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87c8b4bed31dbbf4708549e10814197cac4d8249/gcc%2Fdebug.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87c8b4bed31dbbf4708549e10814197cac4d8249/gcc%2Fdebug.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdebug.h?ref=87c8b4bed31dbbf4708549e10814197cac4d8249", "patch": "@@ -120,6 +120,10 @@ struct gcc_debug_hooks\n   /* Called from final_scan_insn for any NOTE_INSN_VAR_LOCATION note.  */\n   void (* var_location) (rtx);\n \n+  /* Called from final_scan_insn if there is a switch between hot and cold\n+     text sections.  */\n+  void (* switch_text_section) (void);\n+\n   /* This is 1 if the debug writer wants to see start and end commands for the\n      main source files, and 0 otherwise.  */\n   int start_end_main_source_file;"}, {"sha": "43ab1b5d215680962f8cb87e7e0b212095e9771a", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 146, "deletions": 26, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87c8b4bed31dbbf4708549e10814197cac4d8249/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87c8b4bed31dbbf4708549e10814197cac4d8249/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=87c8b4bed31dbbf4708549e10814197cac4d8249", "patch": "@@ -253,6 +253,11 @@ typedef struct dw_fde_struct GTY(())\n   const char *dw_fde_begin;\n   const char *dw_fde_current_label;\n   const char *dw_fde_end;\n+  const char *dw_fde_hot_section_label;\n+  const char *dw_fde_hot_section_end_label;\n+  const char *dw_fde_unlikely_section_label;\n+  const char *dw_fde_unlikely_section_end_label;\n+  bool dw_fde_switched_sections;\n   dw_cfi_ref dw_fde_cfi;\n   unsigned funcdef_number;\n   unsigned all_throwers_are_sibcalls : 1;\n@@ -2273,17 +2278,57 @@ output_call_frame_info (int for_eh)\n \t  dw2_asm_output_encoded_addr_rtx (fde_encoding,\n \t\t\t\t\t   sym_ref,\n \t\t\t\t\t   \"FDE initial location\");\n-\t  dw2_asm_output_delta (size_of_encoded_value (fde_encoding),\n-\t\t\t\tfde->dw_fde_end, fde->dw_fde_begin,\n-\t\t\t\t\"FDE address range\");\n+\t  if (fde->dw_fde_switched_sections)\n+\t    {\n+\t      rtx sym_ref2 = gen_rtx_SYMBOL_REF (Pmode, \n+\t\t\t\t      fde->dw_fde_unlikely_section_label);\n+\t      rtx sym_ref3= gen_rtx_SYMBOL_REF (Pmode, \n+\t\t\t\t      fde->dw_fde_hot_section_label);\n+\t      SYMBOL_REF_FLAGS (sym_ref2) |= SYMBOL_FLAG_LOCAL;\n+\t      SYMBOL_REF_FLAGS (sym_ref3) |= SYMBOL_FLAG_LOCAL;\n+\t      dw2_asm_output_encoded_addr_rtx (fde_encoding, sym_ref3,\n+\t\t\t\t\t       \"FDE initial location\");\n+\t      dw2_asm_output_delta (size_of_encoded_value (fde_encoding),\n+\t\t\t\t    fde->dw_fde_hot_section_end_label,\n+\t\t\t\t    fde->dw_fde_hot_section_label,\n+\t\t\t\t    \"FDE address range\");\n+\t      dw2_asm_output_encoded_addr_rtx (fde_encoding, sym_ref2,\n+\t\t\t\t\t       \"FDE initial location\");\n+\t      dw2_asm_output_delta (size_of_encoded_value (fde_encoding),\n+\t\t\t\t    fde->dw_fde_unlikely_section_end_label,\n+\t\t\t\t    fde->dw_fde_unlikely_section_label,\n+\t\t\t\t    \"FDE address range\");\n+\t    }\n+\t  else\n+\t    dw2_asm_output_delta (size_of_encoded_value (fde_encoding),\n+\t\t\t\t  fde->dw_fde_end, fde->dw_fde_begin,\n+\t\t\t\t  \"FDE address range\");\n \t}\n       else\n \t{\n \t  dw2_asm_output_addr (DWARF2_ADDR_SIZE, fde->dw_fde_begin,\n \t\t\t       \"FDE initial location\");\n-\t  dw2_asm_output_delta (DWARF2_ADDR_SIZE,\n-\t\t\t\tfde->dw_fde_end, fde->dw_fde_begin,\n-\t\t\t\t\"FDE address range\");\n+\t  if (fde->dw_fde_switched_sections)\n+\t    {\n+\t      dw2_asm_output_addr (DWARF2_ADDR_SIZE,\n+\t\t\t\t   fde->dw_fde_hot_section_label,\n+\t\t\t\t   \"FDE initial location\");\n+\t      dw2_asm_output_delta (DWARF2_ADDR_SIZE,\n+\t\t\t\t    fde->dw_fde_hot_section_end_label,\n+\t\t\t\t    fde->dw_fde_hot_section_label,\n+\t\t\t\t    \"FDE address range\");\n+\t      dw2_asm_output_addr (DWARF2_ADDR_SIZE,\n+\t\t\t\t   fde->dw_fde_unlikely_section_label,\n+\t\t\t\t   \"FDE initial location\");\n+\t      dw2_asm_output_delta (DWARF2_ADDR_SIZE, \n+\t\t\t\t    fde->dw_fde_unlikely_section_end_label,\n+\t\t\t\t    fde->dw_fde_unlikely_section_label,\n+\t\t\t\t    \"FDE address range\");\n+\t    }\n+\t  else\n+\t    dw2_asm_output_delta (DWARF2_ADDR_SIZE,\n+\t\t\t\t  fde->dw_fde_end, fde->dw_fde_begin,\n+\t\t\t\t  \"FDE address range\");\n \t}\n \n       if (augmentation[0])\n@@ -2409,6 +2454,11 @@ dwarf2out_begin_prologue (unsigned int line ATTRIBUTE_UNUSED,\n   fde->decl = current_function_decl;\n   fde->dw_fde_begin = dup_label;\n   fde->dw_fde_current_label = NULL;\n+  fde->dw_fde_hot_section_label = NULL;\n+  fde->dw_fde_hot_section_end_label = NULL;\n+  fde->dw_fde_unlikely_section_label = NULL;\n+  fde->dw_fde_unlikely_section_end_label = NULL;\n+  fde->dw_fde_switched_sections = false;\n   fde->dw_fde_end = NULL;\n   fde->dw_fde_cfi = NULL;\n   fde->funcdef_number = current_function_funcdef_no;\n@@ -3418,6 +3468,7 @@ static void dwarf2out_imported_module_or_decl (tree, tree);\n static void dwarf2out_abstract_function (tree);\n static void dwarf2out_var_location (rtx);\n static void dwarf2out_begin_function (tree);\n+static void dwarf2out_switch_text_section (void);\n \n /* The debug hooks structure.  */\n \n@@ -3450,6 +3501,7 @@ const struct gcc_debug_hooks dwarf2_debug_hooks =\n   debug_nothing_rtx,\t\t/* label */\n   debug_nothing_int,\t\t/* handle_pch */\n   dwarf2out_var_location,\n+  dwarf2out_switch_text_section,\n   1                             /* start_end_main_source_file */\n };\n #endif\n@@ -3651,6 +3703,7 @@ struct var_loc_node GTY ((chain_next (\"%h.next\")))\n {\n   rtx GTY (()) var_loc_note;\n   const char * GTY (()) label;\n+  const char * GTY (()) section_label;\n   struct var_loc_node * GTY (()) next;\n };\n \n@@ -6742,6 +6795,20 @@ add_loc_descr_to_loc_list (dw_loc_list_ref *list_head, dw_loc_descr_ref descr,\n   *d = new_loc_list (descr, begin, end, section, 0);\n }\n \n+static void\n+dwarf2out_switch_text_section (void)\n+{\n+  dw_fde_ref fde;\n+\n+  fde = &fde_table[fde_table_in_use - 1];\n+  fde->dw_fde_switched_sections = true;\n+  fde->dw_fde_hot_section_label = xstrdup (hot_section_label);\n+  fde->dw_fde_hot_section_end_label = xstrdup (hot_section_end_label);\n+  fde->dw_fde_unlikely_section_label = xstrdup (unlikely_section_label);\n+  fde->dw_fde_unlikely_section_end_label = xstrdup (cold_section_end_label);\n+  separate_line_info_table_in_use++;\n+}\n+\n /* Output the location list given to us.  */\n \n static void\n@@ -7168,8 +7235,14 @@ output_aranges (void)\n     }\n \n   dw2_asm_output_addr (DWARF2_ADDR_SIZE, text_section_label, \"Address\");\n-  dw2_asm_output_delta (DWARF2_ADDR_SIZE, text_end_label,\n-\t\t\ttext_section_label, \"Length\");\n+  if (last_text_section == in_unlikely_executed_text\n+      || (last_text_section == in_named\n+\t  && last_text_section_name == unlikely_text_section_name))\n+    dw2_asm_output_delta (DWARF2_ADDR_SIZE, text_end_label,\n+\t\t\t  unlikely_section_label, \"Length\");\n+  else\n+    dw2_asm_output_delta (DWARF2_ADDR_SIZE, text_end_label,\n+\t\t\t  text_section_label, \"Length\");\n \n   for (i = 0; i < arange_table_in_use; i++)\n     {\n@@ -7259,11 +7332,24 @@ output_ranges (void)\n \t     base of the text section.  */\n \t  if (separate_line_info_table_in_use == 0)\n \t    {\n-\t      dw2_asm_output_delta (DWARF2_ADDR_SIZE, blabel,\n-\t\t\t\t    text_section_label,\n-\t\t\t\t    fmt, i * 2 * DWARF2_ADDR_SIZE);\n-\t      dw2_asm_output_delta (DWARF2_ADDR_SIZE, elabel,\n-\t\t\t\t    text_section_label, NULL);\n+\t      if (last_text_section == in_unlikely_executed_text\n+\t\t  || (last_text_section == in_named\n+\t\t      && last_text_section_name == unlikely_text_section_name))\n+\t\t{\n+\t\t  dw2_asm_output_delta (DWARF2_ADDR_SIZE, blabel,\n+\t\t\t\t\tunlikely_section_label,\n+\t\t\t\t\tfmt, i * 2 * DWARF2_ADDR_SIZE);\n+\t\t  dw2_asm_output_delta (DWARF2_ADDR_SIZE, elabel,\n+\t\t\t\t\tunlikely_section_label, NULL);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  dw2_asm_output_delta (DWARF2_ADDR_SIZE, blabel,\n+\t\t\t\t\ttext_section_label,\n+\t\t\t\t\tfmt, i * 2 * DWARF2_ADDR_SIZE);\n+\t\t  dw2_asm_output_delta (DWARF2_ADDR_SIZE, elabel,\n+\t\t\t\t\ttext_section_label, NULL);\n+\t\t}\n \t    }\n \n \t  /* Otherwise, we add a DW_AT_entry_pc attribute to force the\n@@ -7648,7 +7734,12 @@ output_line_info (void)\n      a series of state machine operations.  */\n   current_file = 1;\n   current_line = 1;\n-  strcpy (prev_line_label, text_section_label);\n+  if (last_text_section == in_unlikely_executed_text\n+      || (last_text_section == in_named\n+\t  && last_text_section_name == unlikely_text_section_name))\n+    strcpy (prev_line_label, unlikely_section_label);\n+  else\n+    strcpy (prev_line_label, text_section_label);\n   for (lt_index = 1; lt_index < line_info_table_in_use; ++lt_index)\n     {\n       dw_line_info_ref line_info = &line_info_table[lt_index];\n@@ -10028,6 +10119,10 @@ add_location_or_const_value_attribute (dw_die_ref die, tree decl,\n \t  tree sectree = DECL_SECTION_NAME (current_function_decl);\n \t  secname = TREE_STRING_POINTER (sectree);\n \t}\n+      else if (last_text_section == in_unlikely_executed_text\n+\t       || (last_text_section == in_named\n+\t\t   && last_text_section_name == unlikely_text_section_name))\n+\tsecname = unlikely_section_label;\n       else\n \tsecname = text_section_label;\n \n@@ -11334,15 +11429,33 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)\n       if (!old_die || !get_AT (old_die, DW_AT_inline))\n \tequate_decl_number_to_die (decl, subr_die);\n \n-      ASM_GENERATE_INTERNAL_LABEL (label_id, FUNC_BEGIN_LABEL,\n-\t\t\t\t   current_function_funcdef_no);\n-      add_AT_lbl_id (subr_die, DW_AT_low_pc, label_id);\n-      ASM_GENERATE_INTERNAL_LABEL (label_id, FUNC_END_LABEL,\n-\t\t\t\t   current_function_funcdef_no);\n-      add_AT_lbl_id (subr_die, DW_AT_high_pc, label_id);\n-\n-      add_pubname (decl, subr_die);\n-      add_arange (decl, subr_die);\n+      if (!flag_reorder_blocks_and_partition)\n+\t{\n+\t  ASM_GENERATE_INTERNAL_LABEL (label_id, FUNC_BEGIN_LABEL,\n+\t\t\t\t       current_function_funcdef_no);\n+\t  add_AT_lbl_id (subr_die, DW_AT_low_pc, label_id);\n+\t  ASM_GENERATE_INTERNAL_LABEL (label_id, FUNC_END_LABEL,\n+\t\t\t\t       current_function_funcdef_no);\n+\t  add_AT_lbl_id (subr_die, DW_AT_high_pc, label_id);\n+\t  \n+\t  add_pubname (decl, subr_die);\n+\t  add_arange (decl, subr_die);\n+\t}\n+      else\n+\t{  /* Do nothing for now; maybe need to duplicate die, one for\n+\t      hot section and ond for cold section, then use the hot/cold\n+\t      section begin/end labels to generate the aranges...  */\n+\t  /*\n+\t    add_AT_lbl_id (subr_die, DW_AT_low_pc, hot_section_label);\n+\t    add_AT_lbl_id (subr_die, DW_AT_high_pc, hot_section_end_label);\n+\t    add_AT_lbl_id (subr_die, DW_AT_lo_user, unlikely_section_label);\n+\t    add_AT_lbl_id (subr_die, DW_AT_hi_user, cold_section_end_label);\n+\n+\t    add_pubname (decl, subr_die);\n+\t    add_arange (decl, subr_die);\n+\t    add_arange (decl, subr_die);\n+\t   */\n+\t}\n \n #ifdef MIPS_DEBUGGING_INFO\n       /* Add a reference to the FDE for this routine.  */\n@@ -12956,7 +13069,7 @@ static void\n dwarf2out_begin_block (unsigned int line ATTRIBUTE_UNUSED,\n \t\t       unsigned int blocknum)\n {\n-  function_section (current_function_decl);\n+  current_function_section (current_function_decl);\n   ASM_OUTPUT_DEBUG_LABEL (asm_out_file, BLOCK_BEGIN_LABEL, blocknum);\n }\n \n@@ -12966,7 +13079,7 @@ dwarf2out_begin_block (unsigned int line ATTRIBUTE_UNUSED,\n static void\n dwarf2out_end_block (unsigned int line ATTRIBUTE_UNUSED, unsigned int blocknum)\n {\n-  function_section (current_function_decl);\n+  current_function_section (current_function_decl);\n   ASM_OUTPUT_DEBUG_LABEL (asm_out_file, BLOCK_END_LABEL, blocknum);\n }\n \n@@ -13107,6 +13220,13 @@ dwarf2out_var_location (rtx loc_note)\n   newloc->var_loc_note = loc_note;\n   newloc->next = NULL;\n \n+  if (last_text_section == in_unlikely_executed_text\n+      || (last_text_section == in_named\n+\t  && last_text_section_name == unlikely_text_section_name))\n+    newloc->section_label = unlikely_section_label;\n+  else\n+    newloc->section_label = text_section_label;\n+\n   last_insn = loc_note;\n   last_label = newloc->label;\n   decl = NOTE_VAR_LOCATION_DECL (loc_note);\n@@ -13137,7 +13257,7 @@ dwarf2out_source_line (unsigned int line, const char *filename)\n   if (debug_info_level >= DINFO_LEVEL_NORMAL\n       && line != 0)\n     {\n-      function_section (current_function_decl);\n+      current_function_section (current_function_decl);\n \n       /* If requested, emit something human-readable.  */\n       if (flag_debug_asm)"}, {"sha": "05834247d88c06850a2cce31573279805eb8d174", "filename": "gcc/except.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87c8b4bed31dbbf4708549e10814197cac4d8249/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87c8b4bed31dbbf4708549e10814197cac4d8249/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=87c8b4bed31dbbf4708549e10814197cac4d8249", "patch": "@@ -3434,7 +3434,7 @@ output_function_exception_table (void)\n     dw2_asm_output_data (1, VARRAY_UCHAR (cfun->eh->ehspec_data, i),\n \t\t\t (i ? NULL : \"Exception specification table\"));\n \n-  function_section (current_function_decl);\n+  current_function_section (current_function_decl);\n }\n \n #include \"gt-except.h\""}, {"sha": "76337244e4ac6238396ca7e276493f7f73ace942", "filename": "gcc/final.c", "status": "modified", "additions": 16, "deletions": 67, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87c8b4bed31dbbf4708549e10814197cac4d8249/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87c8b4bed31dbbf4708549e10814197cac4d8249/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=87c8b4bed31dbbf4708549e10814197cac4d8249", "patch": "@@ -1426,7 +1426,7 @@ profile_function (FILE *file ATTRIBUTE_UNUSED)\n       assemble_integer (const0_rtx, LONG_TYPE_SIZE / BITS_PER_UNIT, align, 1);\n     }\n \n-  function_section (current_function_decl);\n+  current_function_section (current_function_decl);\n \n #if defined(ASM_OUTPUT_REG_PUSH)\n   if (sval && svrtx != NULL_RTX && REG_P (svrtx))\n@@ -1619,35 +1619,6 @@ output_alternate_entry_point (FILE *file, rtx insn)\n     }\n }\n \n-/* Return boolean indicating if there is a NOTE_INSN_UNLIKELY_EXECUTED_CODE\n-   note in the instruction chain (going forward) between the current\n-   instruction, and the next 'executable' instruction.  */\n-\n-bool\n-scan_ahead_for_unlikely_executed_note (rtx insn)\n-{\n-  rtx temp;\n-  int bb_note_count = 0;\n-\n-  for (temp = insn; temp; temp = NEXT_INSN (temp))\n-    {\n-      if (NOTE_P (temp)\n-\t  && NOTE_LINE_NUMBER (temp) == NOTE_INSN_UNLIKELY_EXECUTED_CODE)\n-\treturn true;\n-      if (NOTE_P (temp)\n-\t  && NOTE_LINE_NUMBER (temp) == NOTE_INSN_BASIC_BLOCK)\n-\t{\n-\t  bb_note_count++;\n-\t  if (bb_note_count > 1)\n-\t    return false;\n-\t}\n-      if (INSN_P (temp))\n-\treturn false;\n-    }\n-  \n-  return false;\n-}\n-\n /* The final scan for one insn, INSN.\n    Args are same as in `final', except that INSN\n    is the insn being scanned.\n@@ -1691,30 +1662,27 @@ final_scan_insn (rtx insn, FILE *file, int optimize ATTRIBUTE_UNUSED,\n \tcase NOTE_INSN_EXPECTED_VALUE:\n \t  break;\n \n-\tcase NOTE_INSN_UNLIKELY_EXECUTED_CODE:\n+\tcase NOTE_INSN_SWITCH_TEXT_SECTIONS:\n \t  \n \t  /* The presence of this note indicates that this basic block\n \t     belongs in the \"cold\" section of the .o file.  If we are\n \t     not already writing to the cold section we need to change\n \t     to it.  */\n-\t  \n-\t  unlikely_text_section ();\n+\n+\t  if (last_text_section == in_text)\n+\t    {\n+\t      (*debug_hooks->switch_text_section) ();\n+\t      unlikely_text_section ();\n+\t    }\n+\t  else\n+\t    {\n+\t      (*debug_hooks->switch_text_section) ();\n+\t      text_section ();\n+\t    }\n \t  break;\n \t  \n \tcase NOTE_INSN_BASIC_BLOCK:\n \t  \n-\t  /* If we are performing the optimization that partitions\n-\t     basic blocks into hot & cold sections of the .o file,\n-\t     then at the start of each new basic block, before\n-\t     beginning to write code for the basic block, we need to\n-\t     check to see whether the basic block belongs in the hot\n-\t     or cold section of the .o file, and change the section we\n-\t     are writing to appropriately.  */\n-\t  \n-\t  if (flag_reorder_blocks_and_partition\n-\t      && !scan_ahead_for_unlikely_executed_note (insn))\n-\t    function_section (current_function_decl);\n-\n #ifdef TARGET_UNWIND_INFO\n \t  targetm.asm_out.unwind_emit (asm_out_file, insn);\n #endif\n@@ -1896,25 +1864,6 @@ final_scan_insn (rtx insn, FILE *file, int optimize ATTRIBUTE_UNUSED,\n       if (LABEL_NAME (insn))\n \t(*debug_hooks->label) (insn);\n \n-      /* If we are doing the optimization that partitions hot & cold\n-\t basic blocks into separate sections of the .o file, we need\n-\t to ensure the jump table ends up in the correct section...  */\n-      \n-      if (flag_reorder_blocks_and_partition\n-\t  && targetm.have_named_sections)\n-\t{\n-\t  rtx tmp_table, tmp_label;\n-\t  if (LABEL_P (insn)\n-\t      && tablejump_p (NEXT_INSN (insn), &tmp_label, &tmp_table))\n-\t    {\n-\t      /* Do nothing; Do NOT change the current section.  */\n-\t    }\n-\t  else if (scan_ahead_for_unlikely_executed_note (insn)) \n-\t    unlikely_text_section ();\n-\t  else if (in_unlikely_text_section ())\n-\t    function_section (current_function_decl);\n-\t}\n-\n       if (app_on)\n \t{\n \t  fputs (ASM_APP_OFF, file);\n@@ -1952,7 +1901,7 @@ final_scan_insn (rtx insn, FILE *file, int optimize ATTRIBUTE_UNUSED,\n \t\t  ASM_OUTPUT_ALIGN (file, log_align);\n \t\t}\n \t      else\n-\t\tfunction_section (current_function_decl);\n+\t\tcurrent_function_section (current_function_decl);\n \n #ifdef ASM_OUTPUT_CASE_LABEL\n \t      ASM_OUTPUT_CASE_LABEL (file, \"L\", CODE_LABEL_NUMBER (insn),\n@@ -2011,7 +1960,7 @@ final_scan_insn (rtx insn, FILE *file, int optimize ATTRIBUTE_UNUSED,\n \t    if (! JUMP_TABLES_IN_TEXT_SECTION)\n \t      targetm.asm_out.function_rodata_section (current_function_decl);\n \t    else\n-\t      function_section (current_function_decl);\n+\t      current_function_section (current_function_decl);\n \n \t    if (app_on)\n \t      {\n@@ -2069,7 +2018,7 @@ final_scan_insn (rtx insn, FILE *file, int optimize ATTRIBUTE_UNUSED,\n #endif\n #endif\n \n-\t    function_section (current_function_decl);\n+\t    current_function_section (current_function_decl);\n \n \t    break;\n \t  }"}, {"sha": "7a934ee6acfaa51f535b96dfc6826de846b79cef", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87c8b4bed31dbbf4708549e10814197cac4d8249/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87c8b4bed31dbbf4708549e10814197cac4d8249/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=87c8b4bed31dbbf4708549e10814197cac4d8249", "patch": "@@ -2865,12 +2865,13 @@ find_if_case_1 (basic_block test_bb, edge then_edge, edge else_edge)\n      partition boundaries).  See  the comments at the top of \n      bb-reorder.c:partition_hot_cold_basic_blocks for complete details.  */\n \n-  if (flag_reorder_blocks_and_partition\n-      && ((BB_END (then_bb) \n-\t   && find_reg_note (BB_END (then_bb), REG_CROSSING_JUMP, NULL_RTX))\n-\t  || (BB_END (else_bb)\n-\t      && find_reg_note (BB_END (else_bb), REG_CROSSING_JUMP, \n-\t\t\t\tNULL_RTX))))\n+  if ((BB_END (then_bb) \n+       && find_reg_note (BB_END (then_bb), REG_CROSSING_JUMP, NULL_RTX))\n+      || (BB_END (test_bb)\n+\t  && find_reg_note (BB_END (test_bb), REG_CROSSING_JUMP, NULL_RTX))\n+      || (BB_END (else_bb)\n+\t  && find_reg_note (BB_END (else_bb), REG_CROSSING_JUMP, \n+\t\t\t    NULL_RTX)))\n     return FALSE;\n \n   /* THEN has one successor.  */\n@@ -2970,12 +2971,13 @@ find_if_case_2 (basic_block test_bb, edge then_edge, edge else_edge)\n      partition boundaries).  See  the comments at the top of \n      bb-reorder.c:partition_hot_cold_basic_blocks for complete details.  */\n \n-  if (flag_reorder_blocks_and_partition\n-      && ((BB_END (then_bb)\n-\t   && find_reg_note (BB_END (then_bb), REG_CROSSING_JUMP, NULL_RTX))\n-\t  || (BB_END (else_bb) \n-\t      && find_reg_note (BB_END (else_bb), REG_CROSSING_JUMP, \n-\t\t\t\tNULL_RTX))))\n+  if ((BB_END (then_bb)\n+       && find_reg_note (BB_END (then_bb), REG_CROSSING_JUMP, NULL_RTX))\n+      || (BB_END (test_bb)\n+\t  && find_reg_note (BB_END (test_bb), REG_CROSSING_JUMP, NULL_RTX))\n+      || (BB_END (else_bb) \n+\t  && find_reg_note (BB_END (else_bb), REG_CROSSING_JUMP, \n+\t\t\t    NULL_RTX)))\n     return FALSE;\n \n   /* ELSE has one successor.  */"}, {"sha": "58f264da6d88b5bba6a238a01bb7d04865734acc", "filename": "gcc/insn-notes.def", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87c8b4bed31dbbf4708549e10814197cac4d8249/gcc%2Finsn-notes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87c8b4bed31dbbf4708549e10814197cac4d8249/gcc%2Finsn-notes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finsn-notes.def?ref=87c8b4bed31dbbf4708549e10814197cac4d8249", "patch": "@@ -88,9 +88,8 @@ INSN_NOTE (EXPECTED_VALUE)\n    now included in every insn.  */\n INSN_NOTE (BASIC_BLOCK)\n \n-/* Record that the current basic block is unlikely to be executed and\n-   should be moved to the UNLIKELY_EXECUTED_TEXT_SECTION.  FIXME: Make\n-   this a bit on the basic block structure.  */\n-INSN_NOTE (UNLIKELY_EXECUTED_CODE)\n+/* Mark the inflection point in the instruction stream where we switch\n+   between hot and cold text sections.  */\n+INSN_NOTE (SWITCH_TEXT_SECTIONS)\n \n #undef INSN_NOTE"}, {"sha": "bd971c8e3f9cf42b6985e2d6b4c491e754bc71a3", "filename": "gcc/opts.c", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87c8b4bed31dbbf4708549e10814197cac4d8249/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87c8b4bed31dbbf4708549e10814197cac4d8249/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=87c8b4bed31dbbf4708549e10814197cac4d8249", "patch": "@@ -669,24 +669,11 @@ decode_options (unsigned int argc, const char **argv)\n \n   if (flag_exceptions && flag_reorder_blocks_and_partition)\n     {\n-      warning \n+      inform \n \t    (\"-freorder-blocks-and-partition does not work with exceptions\");\n       flag_reorder_blocks_and_partition = 0;\n       flag_reorder_blocks = 1;\n     }\n-\n-  /* The optimization to partition hot and cold basic blocks into\n-     separate sections of the .o and executable files does not currently\n-     work correctly with DWARF debugging turned on.  Until this is fixed\n-     we will disable the optimization when DWARF debugging is set.  */\n-  \n-  if (flag_reorder_blocks_and_partition && write_symbols == DWARF2_DEBUG)\n-    {\n-      warning\n-\t(\"-freorder-blocks-and-partition does not work with -g (currently)\");\n-      flag_reorder_blocks_and_partition = 0;\n-      flag_reorder_blocks = 1;\n-    }\n }\n \n /* Handle target- and language-independent options.  Return zero to"}, {"sha": "4d9eabb49f75b5a7a3b7a3eddf4e654274640dfc", "filename": "gcc/output.h", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87c8b4bed31dbbf4708549e10814197cac4d8249/gcc%2Foutput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87c8b4bed31dbbf4708549e10814197cac4d8249/gcc%2Foutput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foutput.h?ref=87c8b4bed31dbbf4708549e10814197cac4d8249", "patch": "@@ -209,6 +209,9 @@ extern void named_section (tree, const char *, int);\n /* Tell assembler to switch to the section for function DECL.  */\n extern void function_section (tree);\n \n+/* Tell assembler to switch to the most recently used text section.  */\n+extern void current_function_section (tree);\n+\n /* Tell assembler to switch to the section for string merging.  */\n extern void mergeable_string_section (tree, unsigned HOST_WIDE_INT,\n \t\t\t\t      unsigned int);\n@@ -431,6 +434,34 @@ extern rtx this_is_asm_operands;\n extern int size_directive_output;\n extern tree last_assemble_variable_decl;\n \n+enum in_section { no_section, in_text, in_unlikely_executed_text, in_data,\n+                 in_named\n+#ifdef BSS_SECTION_ASM_OP\n+  , in_bss\n+#endif\n+#ifdef CTORS_SECTION_ASM_OP\n+  , in_ctors\n+#endif\n+#ifdef DTORS_SECTION_ASM_OP\n+  , in_dtors\n+#endif\n+#ifdef READONLY_DATA_SECTION_ASM_OP\n+  , in_readonly_data\n+#endif\n+#ifdef EXTRA_SECTIONS\n+  , EXTRA_SECTIONS\n+#endif\n+};\n+\n+extern char *unlikely_section_label;\n+extern char *hot_section_label;\n+extern char *hot_section_end_label;\n+extern char *cold_section_end_label;\n+extern char *unlikely_text_section_name;\n+extern const char *last_text_section_name;\n+extern enum in_section last_text_section;\n+extern bool first_function_block_is_cold;\n+\n /* Decide whether DECL needs to be in a writable section.\n    RELOC is the same as for SELECT_SECTION.  */\n extern bool decl_readonly_section (tree, int);\n@@ -519,6 +550,10 @@ extern bool default_valid_pointer_mode (enum machine_mode);\n \n extern int default_address_cost (rtx);\n \n+/* When performing hot/cold basic block partitioning, insert note in\n+   instruction stream indicating boundary between hot and cold sections.  */\n+extern void insert_section_boundary_note (void);\n+\n /* dbxout helper functions */\n #if defined DBX_DEBUGGING_INFO || defined XCOFF_DEBUGGING_INFO\n "}, {"sha": "2ded2b3ff7108f0d19f062ecbe0bed060747af36", "filename": "gcc/passes.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87c8b4bed31dbbf4708549e10814197cac4d8249/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87c8b4bed31dbbf4708549e10814197cac4d8249/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=87c8b4bed31dbbf4708549e10814197cac4d8249", "patch": "@@ -332,6 +332,8 @@ rest_of_handle_final (void)\n \n   timevar_push (TV_SYMOUT);\n   (*debug_hooks->function_decl) (current_function_decl);\n+  if (unlikely_text_section_name)\n+    free (unlikely_text_section_name);\n   timevar_pop (TV_SYMOUT);\n \n   ggc_collect ();"}, {"sha": "4f8c9a9bf3c65e2ccc72a44543baf9dc82dea253", "filename": "gcc/print-rtl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87c8b4bed31dbbf4708549e10814197cac4d8249/gcc%2Fprint-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87c8b4bed31dbbf4708549e10814197cac4d8249/gcc%2Fprint-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-rtl.c?ref=87c8b4bed31dbbf4708549e10814197cac4d8249", "patch": "@@ -319,7 +319,7 @@ print_rtx (rtx in_rtx)\n \t\t}\n \t\tbreak;\n \n-\t      case NOTE_INSN_UNLIKELY_EXECUTED_CODE:\n+\t      case NOTE_INSN_SWITCH_TEXT_SECTIONS:\n \t\t{\n #ifndef GENERATOR_FILE\n \t\t  basic_block bb = NOTE_BASIC_BLOCK (in_rtx);"}, {"sha": "f126d98461b44d4be54534efe602d246a207cfe5", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87c8b4bed31dbbf4708549e10814197cac4d8249/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87c8b4bed31dbbf4708549e10814197cac4d8249/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=87c8b4bed31dbbf4708549e10814197cac4d8249", "patch": "@@ -931,8 +931,6 @@ emit_swap_insn (rtx insn, stack regstack, rtx reg)\n \t  if (LABEL_P (tmp)\n \t      || CALL_P (tmp)\n \t      || NOTE_INSN_BASIC_BLOCK_P (tmp)\n-\t      || (NOTE_P (tmp)\n-\t\t  && NOTE_LINE_NUMBER (tmp) == NOTE_INSN_UNLIKELY_EXECUTED_CODE)\n \t      || (NONJUMP_INSN_P (tmp)\n \t\t  && stack_regs_mentioned (tmp)))\n \t    {"}, {"sha": "d5964323aef3e5d0ee8150bfa3130f30278f7d04", "filename": "gcc/sdbout.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87c8b4bed31dbbf4708549e10814197cac4d8249/gcc%2Fsdbout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87c8b4bed31dbbf4708549e10814197cac4d8249/gcc%2Fsdbout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsdbout.c?ref=87c8b4bed31dbbf4708549e10814197cac4d8249", "patch": "@@ -336,6 +336,7 @@ const struct gcc_debug_hooks sdb_debug_hooks =\n   sdbout_label,\t\t\t         /* label */\n   debug_nothing_int,\t\t         /* handle_pch */\n   debug_nothing_rtx,\t\t         /* var_location */\n+  debug_nothing_void,                    /* switch_text_section */\n   0                                      /* start_end_main_source_file */\n };\n "}, {"sha": "d2aeac6aabf4741c258311e9bab032669df953b3", "filename": "gcc/varasm.c", "status": "modified", "additions": 170, "deletions": 96, "changes": 266, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87c8b4bed31dbbf4708549e10814197cac4d8249/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87c8b4bed31dbbf4708549e10814197cac4d8249/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=87c8b4bed31dbbf4708549e10814197cac4d8249", "patch": "@@ -52,6 +52,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"tree-mudflap.h\"\n #include \"cgraph.h\"\n #include \"cfglayout.h\"\n+#include \"basic-block.h\"\n \n #ifdef XCOFF_DEBUGGING_INFO\n #include \"xcoffout.h\"\t\t/* Needed for external data\n@@ -95,25 +96,44 @@ int size_directive_output;\n \n tree last_assemble_variable_decl;\n \n-/* The following global variable indicates if the section label for the\n-   \"cold\" section of code has been output yet to the assembler.  The\n-   label is useful when running gdb.  This is part of the optimization that\n-   partitions hot and cold basic blocks into separate sections of the .o\n-   file.  */\n+/* The following global variable indicates if the first basic block\n+   in a function belongs to the cold partition or not.  */\n \n-static bool unlikely_section_label_printed = false;\n+bool first_function_block_is_cold;\n \n /* The following global variable indicates the label name to be put at\n    the start of the first cold section within each function, when\n-   partitioning basic blocks into hot and cold sections.  */\n+   partitioning basic blocks into hot and cold sections.  Used for\n+   debug info.  */\n \n-static char *unlikely_section_label = NULL;\n+char *unlikely_section_label;\n+\n+/* The following global variable indicates the label name to be put at\n+   the start of the first hot section within each function, when\n+   partitioning basic blocks into hot and cold sections.  Used for\n+   debug info.  */\n+\n+char *hot_section_label;\n+\n+/* The following global variable indicates the label name to be put at\n+   the end of the last hot section within each function, when\n+   partitioning basic blocks into hot and cold sections.  Used for\n+   debug info.  */\n+\n+char *hot_section_end_label;\n+\n+/* The following global variable indicates the label name to be put at\n+   the end of the last cold section within each function, when\n+   partitioning basic blocks into hot and cold sections.  Used for \n+   debug info.*/\n+\n+char *cold_section_end_label;\n  \n-/* The following global variable indicates the section name to be used\n-   for the current cold section, when partitioning hot and cold basic\n+/* The following global variable indicates the seciton name to be used\n+   for the current cold section, when partitiong hot and cold basic \n    blocks into separate sections.  */\n \n-static char *unlikely_text_section_name = NULL;\n+char *unlikely_text_section_name;\n \n /* We give all constants their own alias set.  Perhaps redundant with\n    MEM_READONLY_P, but pre-dates it.  */\n@@ -140,6 +160,7 @@ static void globalize_decl (tree);\n static void maybe_assemble_visibility (tree);\n static int in_named_entry_eq (const void *, const void *);\n static hashval_t in_named_entry_hash (const void *);\n+static void initialize_cold_section_name (void);\n #ifdef BSS_SECTION_ASM_OP\n #ifdef ASM_OUTPUT_BSS\n static void asm_output_bss (FILE *, tree, const char *,\n@@ -156,25 +177,8 @@ static bool asm_emit_uninitialised (tree, const char*,\n \t\t\t\t    unsigned HOST_WIDE_INT);\n static void mark_weak (tree);\n \f\n-enum in_section { no_section, in_text, in_unlikely_executed_text, in_data, \n-\t\t  in_named\n-#ifdef BSS_SECTION_ASM_OP\n-  , in_bss\n-#endif\n-#ifdef CTORS_SECTION_ASM_OP\n-  , in_ctors\n-#endif\n-#ifdef DTORS_SECTION_ASM_OP\n-  , in_dtors\n-#endif\n-#ifdef READONLY_DATA_SECTION_ASM_OP\n-  , in_readonly_data\n-#endif\n-#ifdef EXTRA_SECTIONS\n-  , EXTRA_SECTIONS\n-#endif\n-};\n static GTY(()) enum in_section in_section = no_section;\n+enum in_section last_text_section;\n \n /* Return a nonzero value if DECL has a section attribute.  */\n #ifndef IN_NAMED_SECTION\n@@ -185,6 +189,7 @@ static GTY(()) enum in_section in_section = no_section;\n \n /* Text of section name when in_section == in_named.  */\n static GTY(()) const char *in_named_name;\n+const char *last_text_section_name;\n \n /* Hash table of flags that have been used for a particular named section.  */\n \n@@ -202,24 +207,10 @@ static GTY((param_is (struct in_named_entry))) htab_t in_named_htab;\n EXTRA_SECTION_FUNCTIONS\n #endif\n \n-/* Tell assembler to switch to text section.  */\n-\n-void\n-text_section (void)\n-{\n-  if (in_section != in_text)\n-    {\n-      in_section = in_text;\n-      fprintf (asm_out_file, \"%s\\n\", TEXT_SECTION_ASM_OP);\n-    }\n-}\n-\n-/* Tell assembler to switch to unlikely-to-be-executed text section.  */\n-\n-void\n-unlikely_text_section (void)\n+static void\n+initialize_cold_section_name (void)\n {\n-  const char *name;\n+  const char* name;\n   int len;\n \n   if (! unlikely_text_section_name)\n@@ -235,31 +226,43 @@ unlikely_text_section (void)\n \t  name = TREE_STRING_POINTER (DECL_SECTION_NAME \n \t\t\t\t                   (current_function_decl));\n \t  len = strlen (name);\n-\t  unlikely_text_section_name = xmalloc ((len + 10) * sizeof (char));\n-\t  strcpy (unlikely_text_section_name, name);\n-\t  strcat (unlikely_text_section_name, \"_unlikely\");\n+\t  unlikely_text_section_name = xmalloc (len + 10);\n+\t  sprintf (unlikely_text_section_name, \"%s%s\", name, \"_unlikely\");\n \t}\n       else\n-\t{\n-\t  len = strlen (UNLIKELY_EXECUTED_TEXT_SECTION_NAME);\n-\t  unlikely_text_section_name = xmalloc (len+1 * sizeof (char));\n-\t  strcpy (unlikely_text_section_name, \n-\t\t  UNLIKELY_EXECUTED_TEXT_SECTION_NAME);\n-\t}\n+\tunlikely_text_section_name = \n+\t                      xstrdup (UNLIKELY_EXECUTED_TEXT_SECTION_NAME);\n+    }\n+}\n+\n+/* Tell assembler to switch to text section.  */\n+\n+void\n+text_section (void)\n+{\n+  if (in_section != in_text)\n+    {\n+      in_section = in_text;\n+      last_text_section = in_text;\n+      fprintf (asm_out_file, \"%s\\n\", TEXT_SECTION_ASM_OP);\n     }\n+}\n+\n+/* Tell assembler to switch to unlikely-to-be-executed text section.  */\n+\n+void\n+unlikely_text_section (void)\n+{\n+  if (! unlikely_text_section_name)\n+    initialize_cold_section_name ();\n \n   if ((in_section != in_unlikely_executed_text)\n       &&  (in_section != in_named \n \t   || strcmp (in_named_name, unlikely_text_section_name) != 0))\n     {\n       named_section (NULL_TREE, unlikely_text_section_name, 0);\n       in_section = in_unlikely_executed_text;\n-\n-      if (!unlikely_section_label_printed)\n-\t{\n-\t  ASM_OUTPUT_LABEL (asm_out_file, unlikely_section_label);\n-\t  unlikely_section_label_printed = true;\n-\t}\n+      last_text_section = in_unlikely_executed_text;\n     }\n }\n \n@@ -437,6 +440,12 @@ named_section_real (const char *name, unsigned int flags, tree decl)\n \t  in_section = in_named;\n \t}\n     }\n+\n+  if (in_text_section () || in_unlikely_text_section ())\n+    {\n+      last_text_section = in_section;\n+      last_text_section_name = name;\n+    }\n }\n \n /* Tell assembler to change to section NAME for DECL.\n@@ -565,28 +574,40 @@ asm_output_aligned_bss (FILE *file, tree decl ATTRIBUTE_UNUSED,\n void\n function_section (tree decl)\n {\n-  if (decl == NULL_TREE)\n-    text_section ();\n+  bool unlikely = false;\n+    \n+  if (first_function_block_is_cold)\n+    unlikely = true;\n+  \n+#ifdef USE_SELECT_SECTION_FOR_FUNCTIONS\n+  targetm.asm_out.select_section (decl, unlikely, DECL_ALIGN (decl));\n+#else\n+  if (decl != NULL_TREE\n+      && DECL_SECTION_NAME (decl) != NULL_TREE)\n+    named_section (decl, (char *) 0, 0);\n   else\n-    {\n-      /* ??? Typical use of this function maybe shouldn't be looking\n-\t for unlikely blocks at all - in the event that an entire\n-\t function is going into the unlikely-execute section, that\n-\t should be reflected in its DECL_SECTION_NAME.  */\n-      rtx insns = cfun && cfun->emit ? get_insns () : 0;\n-      bool unlikely = insns && scan_ahead_for_unlikely_executed_note (insns);\n+    text_section ();\n+#endif\n+}\n \n+void\n+current_function_section (tree decl)\n+{\n #ifdef USE_SELECT_SECTION_FOR_FUNCTIONS\n-      targetm.asm_out.select_section (decl, unlikely, DECL_ALIGN (decl));\n+  bool unlikely = (in_unlikely_text_section () \n+\t\t   || (last_text_section == in_unlikely_executed_text));\n+  \n+  targetm.asm_out.select_section (decl, unlikely, DECL_ALIGN (decl));\n #else\n-      if (unlikely)\n-\tunlikely_text_section ();\n-      else if (DECL_SECTION_NAME (decl))\n-\tnamed_section (decl, 0, 0);\n-      else\n-\ttext_section ();\n+  if (last_text_section == in_unlikely_executed_text)\n+    unlikely_text_section ();\n+  else if (last_text_section == in_text)\n+    text_section ();\n+  else if (last_text_section == in_named)\n+    named_section (NULL_TREE, last_text_section_name, 0);\n+  else\n+    function_section (decl);\n #endif\n-    }\n }\n \n /* Switch to read-only data section associated with function DECL.  */\n@@ -1203,39 +1224,87 @@ void\n assemble_start_function (tree decl, const char *fnname)\n {\n   int align;\n+  bool hot_label_written = false;\n \n-  if (unlikely_text_section_name)\n-    free (unlikely_text_section_name);\n-\n-  unlikely_section_label_printed = false;\n   unlikely_text_section_name = NULL;\n   \n+  first_function_block_is_cold = false;\n+  hot_section_label = reconcat (hot_section_label, fnname, \".hot_section\", NULL);\n   unlikely_section_label = reconcat (unlikely_section_label, \n \t\t\t\t     fnname, \".unlikely_section\", NULL);\n-  \n+  hot_section_end_label = reconcat (hot_section_end_label,\n+\t\t\t\t    fnname, \".end\", NULL);\n+  cold_section_end_label = reconcat (cold_section_end_label,\n+\t\t\t\t    fnname, \".end.cold\", NULL);\n+\n   /* The following code does not need preprocessing in the assembler.  */\n \n   app_disable ();\n \n   if (CONSTANT_POOL_BEFORE_FUNCTION)\n     output_constant_pool (fnname, decl);\n \n-  /* Make sure the cold text (code) section is properly aligned.  This\n-     is necessary here in the case where the function has both hot and\n-     cold sections, because we don't want to re-set the alignment when the\n-     section switch happens mid-function.  We don't need to set the hot\n-     section alignment here, because code further down in this function\n-     sets the alignment for whichever section comes first, and if there\n-     is a hot section it is guaranteed to be first.  */\n+  /* Make sure the not and cold text (code) sections are properly\n+     aligned.  This is necessary here in the case where the function\n+     has both hot and cold sections, because we don't want to re-set\n+     the alignment when the section switch happens mid-function.  */\n \n   if (flag_reorder_blocks_and_partition)\n     {\n       unlikely_text_section ();\n       assemble_align (FUNCTION_BOUNDARY);\n+      ASM_OUTPUT_LABEL (asm_out_file, unlikely_section_label);\n+      if (BB_PARTITION (ENTRY_BLOCK_PTR->next_bb) == BB_COLD_PARTITION)\n+\t{\n+\t  /* Since the function starts with a cold section, we need to\n+\t     explicitly align the hot section and write out the hot\n+\t     section label.  */\n+\t  text_section ();\n+\t  assemble_align (FUNCTION_BOUNDARY);\n+\t  ASM_OUTPUT_LABEL (asm_out_file, hot_section_label);\n+\t  hot_label_written = true;\n+\t  first_function_block_is_cold = true;\n+\t}\n     }\n+  else if (DECL_SECTION_NAME (decl))\n+    {\n+      /* Calls to function_section rely on first_function_block_is_cold\n+\t being accurate.  The first block may be cold even if we aren't\n+\t doing partitioning, if the entire function was decided by\n+\t choose_function_section (predict.c) to be cold.  */\n+\n+      int i;\n+      int len;\n+      char *s;\n \n+      initialize_cold_section_name ();\n+\n+      /* The following is necessary, because 'strcmp\n+\t(TREE_STRING_POINTER (DECL_SECTION_NAME (decl)), blah)' always\n+\tfails, presumably because TREE_STRING_POINTER is declared to\n+\tbe an array of size 1 of char.  */\n+\n+      len = TREE_STRING_LENGTH (DECL_SECTION_NAME (decl));\n+      s = (char *) xmalloc (len + 1);\n+\n+      for (i = 0; i < len; i ++)\n+\ts[i] = (TREE_STRING_POINTER (DECL_SECTION_NAME (decl)))[i];\n+      s[len] = '\\0';\n+      \n+      if (unlikely_text_section_name \n+\t  && (strcmp (s, unlikely_text_section_name) == 0))\n+\tfirst_function_block_is_cold = true;\n+    }\n+\n+  last_text_section = no_section;\n+  in_section = no_section;\n   resolve_unique_section (decl, 0, flag_function_sections);\n+\n+  /* Switch to the correct text section for the start of the function.  */\n+\n   function_section (decl);\n+  if (!hot_label_written)\n+    ASM_OUTPUT_LABEL (asm_out_file, hot_section_label);\n \n   /* Tell assembler to move to target machine's alignment for functions.  */\n   align = floor_log2 (FUNCTION_BOUNDARY / BITS_PER_UNIT);\n@@ -1288,12 +1357,7 @@ assemble_start_function (tree decl, const char *fnname)\n   ASM_OUTPUT_LABEL (asm_out_file, fnname);\n #endif /* ASM_DECLARE_FUNCTION_NAME */\n \n-  if (in_unlikely_text_section ()\n-      && !unlikely_section_label_printed)\n-    {\n-      ASM_OUTPUT_LABEL (asm_out_file, unlikely_section_label);\n-      unlikely_section_label_printed = true;\n-    }\n+  insert_section_boundary_note ();\n }\n \n /* Output assembler code associated with defining the size of the\n@@ -1302,6 +1366,7 @@ assemble_start_function (tree decl, const char *fnname)\n void\n assemble_end_function (tree decl, const char *fnname)\n {\n+  enum in_section save_text_section;\n #ifdef ASM_DECLARE_FUNCTION_SIZE\n   ASM_DECLARE_FUNCTION_SIZE (asm_out_file, fnname, decl);\n #endif\n@@ -1310,6 +1375,15 @@ assemble_end_function (tree decl, const char *fnname)\n       output_constant_pool (fnname, decl);\n       function_section (decl);\t/* need to switch back */\n     }\n+  /* Output labels for end of hot/cold text sections (to be used by\n+     debug info.)  */\n+  save_text_section = in_section;\n+  unlikely_text_section ();\n+  ASM_OUTPUT_LABEL (asm_out_file, cold_section_end_label);\n+  text_section ();\n+  ASM_OUTPUT_LABEL (asm_out_file, hot_section_end_label);\n+  if (save_text_section == in_unlikely_executed_text)\n+    unlikely_text_section ();\n }\n \f\n /* Assemble code to leave SIZE bytes of zeros.  */"}, {"sha": "d612479f6c611d43f4108363d29d5ef202db4cbb", "filename": "gcc/vmsdbgout.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87c8b4bed31dbbf4708549e10814197cac4d8249/gcc%2Fvmsdbgout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87c8b4bed31dbbf4708549e10814197cac4d8249/gcc%2Fvmsdbgout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvmsdbgout.c?ref=87c8b4bed31dbbf4708549e10814197cac4d8249", "patch": "@@ -210,6 +210,7 @@ const struct gcc_debug_hooks vmsdbg_debug_hooks\n    debug_nothing_rtx,\t\t  /* label */\n    debug_nothing_int,\t\t  /* handle_pch */\n    debug_nothing_rtx,\t\t  /* var_location */\n+   debug_nothing_void,            /* switch_text_section */\n    0                              /* start_end_main_source_file */\n };\n "}]}