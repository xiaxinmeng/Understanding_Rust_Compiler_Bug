{"sha": "2f18d7a1a8277ecc9538214375e3aad461b98b2c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmYxOGQ3YTFhODI3N2VjYzk1MzgyMTQzNzVlM2FhZDQ2MWI5OGIyYw==", "commit": {"author": {"name": "Jerry Quinn", "email": "jlquinn@optonline.net", "date": "2003-08-01T15:07:49Z"}, "committer": {"name": "Mark Wielaard", "email": "mark@gcc.gnu.org", "date": "2003-08-01T15:07:49Z"}, "message": "BigDecimal (divide): Correctly handle ROUND_HALF_EVEN when amount is greater than 0.5.\n\n2003-08-01  Jerry Quinn  <jlquinn@optonline.net>\n            Mark Wielaard  <mark@klomp.org>\n\n       * java/math/BigDecimal (divide): Correctly handle\n       ROUND_HALF_EVEN when amount is greater than 0.5.\n       Simplify and optimize code.\n\nCo-Authored-By: Mark Wielaard <mark@klomp.org>\n\nFrom-SVN: r70049", "tree": {"sha": "516907b72abe942439f69b308b68e11b098cd245", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/516907b72abe942439f69b308b68e11b098cd245"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2f18d7a1a8277ecc9538214375e3aad461b98b2c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f18d7a1a8277ecc9538214375e3aad461b98b2c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f18d7a1a8277ecc9538214375e3aad461b98b2c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f18d7a1a8277ecc9538214375e3aad461b98b2c/comments", "author": {"login": "jlquinn", "id": 826841, "node_id": "MDQ6VXNlcjgyNjg0MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/826841?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jlquinn", "html_url": "https://github.com/jlquinn", "followers_url": "https://api.github.com/users/jlquinn/followers", "following_url": "https://api.github.com/users/jlquinn/following{/other_user}", "gists_url": "https://api.github.com/users/jlquinn/gists{/gist_id}", "starred_url": "https://api.github.com/users/jlquinn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jlquinn/subscriptions", "organizations_url": "https://api.github.com/users/jlquinn/orgs", "repos_url": "https://api.github.com/users/jlquinn/repos", "events_url": "https://api.github.com/users/jlquinn/events{/privacy}", "received_events_url": "https://api.github.com/users/jlquinn/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "cbd63935d8cb0edec8d27a7c427106b41d85a29f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cbd63935d8cb0edec8d27a7c427106b41d85a29f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cbd63935d8cb0edec8d27a7c427106b41d85a29f"}], "stats": {"total": 80, "additions": 45, "deletions": 35}, "files": [{"sha": "51dc68723e6b87169d995c9fd730addd55e1f939", "filename": "libjava/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f18d7a1a8277ecc9538214375e3aad461b98b2c/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f18d7a1a8277ecc9538214375e3aad461b98b2c/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=2f18d7a1a8277ecc9538214375e3aad461b98b2c", "patch": "@@ -1,3 +1,10 @@\n+2003-08-01  Jerry Quinn  <jlquinn@optonline.net>\n+            Mark Wielaard  <mark@klomp.org>\n+\t    \n+\t* java/math/BigDecimal (divide): Correctly handle\n+\tROUND_HALF_EVEN when amount is greater than 0.5.\n+\tSimplify and optimize code.\n+\n 2003-07-31  Tom Tromey  <tromey@redhat.com>\n \n \tMore for PR libgcj/11737:"}, {"sha": "f9965add4c1643f6fd53b9ef9636e929c034738e", "filename": "libjava/java/math/BigDecimal.java", "status": "modified", "additions": 38, "deletions": 35, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f18d7a1a8277ecc9538214375e3aad461b98b2c/libjava%2Fjava%2Fmath%2FBigDecimal.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f18d7a1a8277ecc9538214375e3aad461b98b2c/libjava%2Fjava%2Fmath%2FBigDecimal.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fmath%2FBigDecimal.java?ref=2f18d7a1a8277ecc9538214375e3aad461b98b2c", "patch": "@@ -1,5 +1,5 @@\n /* java.math.BigDecimal -- Arbitrary precision decimals.\n-   Copyright (C) 1999, 2000, 2001 Free Software Foundation, Inc.\n+   Copyright (C) 1999, 2000, 2001, 2003 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -273,7 +273,7 @@ public BigDecimal divide(BigDecimal val, int newScale, int roundingMode)\n     // Ensure that pow gets a non-negative value.\n     int valScale = val.scale;\n     BigInteger valIntVal = val.intVal;\n-    int power = newScale + 1 - (scale - val.scale);\n+    int power = newScale - (scale - val.scale);\n     if (power < 0)\n       {\n \t// Effectively increase the scale of val to avoid an\n@@ -285,50 +285,53 @@ public BigDecimal divide(BigDecimal val, int newScale, int roundingMode)\n     BigInteger dividend = intVal.multiply (BigInteger.valueOf (10).pow (power));\n     \n     BigInteger parts[] = dividend.divideAndRemainder (valIntVal);\n-//      System.out.println(\"int: \" + parts[0]);\n-//      System.out.println(\"rem: \" + parts[1]);\n \n-    int roundDigit = parts[0].mod (BigInteger.valueOf (10)).intValue ();\n-    BigInteger unrounded = parts[0].divide (BigInteger.valueOf (10));\n-\n-    if (roundDigit == 0 && parts[1].signum () == 0) // no rounding necessary\n+    BigInteger unrounded = parts[0];\n+    if (parts[1].signum () == 0) // no remainder, no rounding necessary\n       return new BigDecimal (unrounded, newScale);\n \n-    int sign = unrounded.signum ();\n+    if (roundingMode == ROUND_UNNECESSARY)\n+      throw new ArithmeticException (\"newScale is not large enough\");\n+\n+    int sign = intVal.signum () * valIntVal.signum ();\n \n-    switch (roundingMode)\n+    if (roundingMode == ROUND_CEILING)\n+      roundingMode = (sign > 0) ? ROUND_UP : ROUND_DOWN;\n+    else if (roundingMode == ROUND_FLOOR)\n+      roundingMode = (sign < 0) ? ROUND_UP : ROUND_DOWN;\n+    else\n       {\n-      case ROUND_UNNECESSARY:\n-\tthrow new ArithmeticException (\"newScale is not large enough\");\n-      case ROUND_CEILING:\n-\troundingMode = (sign == 1) ? ROUND_UP : ROUND_DOWN;\n-\tbreak;\n-      case ROUND_FLOOR:\n-\troundingMode = (sign == 1) ? ROUND_DOWN : ROUND_UP;\n-\tbreak;\n-      case ROUND_HALF_UP:\n-\troundingMode = (roundDigit >= 5) ? ROUND_UP : ROUND_DOWN;\n-\tbreak;\n-      case ROUND_HALF_DOWN:\n-\troundingMode = (roundDigit > 5) ? ROUND_UP : ROUND_DOWN;\n-\tbreak;\n-      case ROUND_HALF_EVEN:\n-\tif (roundDigit < 5)\n-\t  roundingMode = ROUND_DOWN;\n-\telse\n+\t// half is -1 if remainder*2 < positive intValue (*power), 0 if equal,\n+\t// 1 if >. This implies that the remainder to round is less than,\n+\t// equal to, or greater than half way to the next digit.\n+\tBigInteger posRemainder\n+\t  = parts[1].signum () < 0 ? parts[1].negate() : parts[1];\n+\tvalIntVal = valIntVal.signum () < 0 ? valIntVal.negate () : valIntVal;\n+\tint half = posRemainder.shiftLeft(1).compareTo(valIntVal);\n+\n+\tswitch(roundingMode)\n \t  {\n-\t    int rightmost = \n-\t      unrounded.mod (BigInteger.valueOf (10)).intValue ();\n-\t    if (rightmost % 2 == 1) // odd, then ROUND_HALF_UP\n+\t  case ROUND_HALF_UP:\n+\t    roundingMode = (half < 0) ? ROUND_DOWN : ROUND_UP;\n+\t    break;\n+\t  case ROUND_HALF_DOWN:\n+\t    roundingMode = (half > 0) ? ROUND_UP : ROUND_DOWN;\n+\t    break;\n+\t  case ROUND_HALF_EVEN:\n+\t    if (half < 0)\n+\t      roundingMode = ROUND_DOWN;\n+\t    else if (half > 0)\n+\t      roundingMode = ROUND_UP;\n+\t    else if (unrounded.testBit(0)) // odd, then ROUND_HALF_UP\n \t      roundingMode = ROUND_UP;\n-\t    else // even, then ROUND_HALF_DOWN\n-\t      roundingMode = (roundDigit > 5) ? ROUND_UP : ROUND_DOWN;\n+\t    else                           // even, ROUND_HALF_DOWN\n+\t      roundingMode = ROUND_DOWN;\n+\t    break;\n \t  }\n-\tbreak;\n       }\n \n     if (roundingMode == ROUND_UP)\n-      return new BigDecimal (unrounded.add (BigInteger.valueOf (1)), newScale);\n+      unrounded = unrounded.add (BigInteger.valueOf (sign > 0 ? 1 : -1));\n \n     // roundingMode == ROUND_DOWN\n     return new BigDecimal (unrounded, newScale);"}]}