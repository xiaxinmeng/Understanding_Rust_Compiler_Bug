{"sha": "0fa2e4df4739bda990b1be0f8a0455ced48bc3b1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGZhMmU0ZGY0NzM5YmRhOTkwYjFiZTBmOGEwNDU1Y2VkNDhiYzNiMQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2005-05-26T18:15:27Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2005-05-26T18:15:27Z"}, "message": "c-common.c, [...]: Fix comment typos.\n\n\t* c-common.c, c-parser.c, cfgbuild.c, cfghooks.c, cfghooks.h,\n\tcfgrtl.c, cgraphunit.c, ddg.c, expr.h, gcse.c, ggc-page.c,\n\tggc-zone.c, gimplify.c, ipa-inline.c, longlong.h, targhooks.c,\n\ttree-flow-inline.h, tree-pass.h, tree-ssa-dse.c,\n\ttree-ssa-loop-im.c, tree-ssa-loop-ivopts.c,\n\ttree-ssa-operands.c, tree-vect-analyze.c,\n\ttree-vect-transform.c, tree-vectorizer.c, tree.c,\n\tconfig/arm/arm.c, config/bfin/bfin.c, config/frv/frv.c,\n\tconfig/frv/frv.md, config/i386/i386.c, config/i386/sse.md,\n\tconfig/m68hc11/m68hc11.c, config/m68hc11/m68hc11.h,\n\tconfig/mcore/mcore.c, config/mips/mips.c, config/mips/mips.md,\n\tconfig/rs6000/darwin-ldouble.c, config/rs6000/rs6000.c,\n\tconfig/rs6000/rs6000.h, config/sh/sh.c, config/sh/sh.md,\n\tconfig/sh/ushmedia.h, config/sparc/sparc.c,\n\tconfig/sparc/sparc.md, config/stormy16/stormy-abi: Fix comment\n\ttypos.  Follow spelling conventions.\n\t* doc/invoke.texi, doc/tm.texi, doc/tree-ssa.texi: Fix typos.\n\tFollow spelling conventions.\n\nFrom-SVN: r100218", "tree": {"sha": "86419139bff82ade0a6b2ca63276803b131a6d0b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/86419139bff82ade0a6b2ca63276803b131a6d0b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0fa2e4df4739bda990b1be0f8a0455ced48bc3b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0fa2e4df4739bda990b1be0f8a0455ced48bc3b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0fa2e4df4739bda990b1be0f8a0455ced48bc3b1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0fa2e4df4739bda990b1be0f8a0455ced48bc3b1/comments", "author": null, "committer": null, "parents": [{"sha": "e689b87000079f75748c0c105b869d22b3e6c9d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e689b87000079f75748c0c105b869d22b3e6c9d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e689b87000079f75748c0c105b869d22b3e6c9d4"}], "stats": {"total": 160, "additions": 90, "deletions": 70}, "files": [{"sha": "bc7e8f909f330c354786958aef478e61594932cb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fa2e4df4739bda990b1be0f8a0455ced48bc3b1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fa2e4df4739bda990b1be0f8a0455ced48bc3b1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0fa2e4df4739bda990b1be0f8a0455ced48bc3b1", "patch": "@@ -1,3 +1,24 @@\n+2005-05-26  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* c-common.c, c-parser.c, cfgbuild.c, cfghooks.c, cfghooks.h,\n+\tcfgrtl.c, cgraphunit.c, ddg.c, expr.h, gcse.c, ggc-page.c,\n+\tggc-zone.c, gimplify.c, ipa-inline.c, longlong.h, targhooks.c,\n+\ttree-flow-inline.h, tree-pass.h, tree-ssa-dse.c,\n+\ttree-ssa-loop-im.c, tree-ssa-loop-ivopts.c,\n+\ttree-ssa-operands.c, tree-vect-analyze.c,\n+\ttree-vect-transform.c, tree-vectorizer.c, tree.c,\n+\tconfig/arm/arm.c, config/bfin/bfin.c, config/frv/frv.c,\n+\tconfig/frv/frv.md, config/i386/i386.c, config/i386/sse.md,\n+\tconfig/m68hc11/m68hc11.c, config/m68hc11/m68hc11.h,\n+\tconfig/mcore/mcore.c, config/mips/mips.c, config/mips/mips.md,\n+\tconfig/rs6000/darwin-ldouble.c, config/rs6000/rs6000.c,\n+\tconfig/rs6000/rs6000.h, config/sh/sh.c, config/sh/sh.md,\n+\tconfig/sh/ushmedia.h, config/sparc/sparc.c,\n+\tconfig/sparc/sparc.md, config/stormy16/stormy-abi: Fix comment\n+\ttypos.  Follow spelling conventions.\n+\t* doc/invoke.texi, doc/tm.texi, doc/tree-ssa.texi: Fix typos.\n+\tFollow spelling conventions.\n+\n 2005-05-26  David Ung  <davidu@mips.com>\n \n \t* config/mips/mips.c (mips_use_ins_ext_p): New helper function"}, {"sha": "66fe3f2f27eee6bfad3f63ec4c67fa50064750d2", "filename": "gcc/c-common.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fa2e4df4739bda990b1be0f8a0455ced48bc3b1/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fa2e4df4739bda990b1be0f8a0455ced48bc3b1/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=0fa2e4df4739bda990b1be0f8a0455ced48bc3b1", "patch": "@@ -1445,7 +1445,7 @@ check_case_value (tree value)\n    if the case is not a case range.\n    The caller has to make sure that we are not called with NULL for\n    CASE_LOW_P (i.e. the default case).\n-   Returns true if the case label is in range of ORIG_TYPE (satured or\n+   Returns true if the case label is in range of ORIG_TYPE (saturated or\n    untouched) or false if the label is out of range.  */\n \n static bool"}, {"sha": "d0eec8db17d4d3ad479744fd544c3ee889e88bb5", "filename": "gcc/c-parser.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fa2e4df4739bda990b1be0f8a0455ced48bc3b1/gcc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fa2e4df4739bda990b1be0f8a0455ced48bc3b1/gcc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parser.c?ref=0fa2e4df4739bda990b1be0f8a0455ced48bc3b1", "patch": "@@ -2145,7 +2145,7 @@ c_parser_direct_declarator (c_parser *parser, bool type_seen_p, c_dtr_syn kind,\n      which is resolved in the direction of treating it as a typedef\n      name.  If a close parenthesis follows, it is also an empty\n      parameter list, as the syntax does not permit empty abstract\n-     declarators.  Otherwise, it is a parenthesised declarator (in\n+     declarators.  Otherwise, it is a parenthesized declarator (in\n      which case the analysis may be repeated inside it, recursively).\n \n      ??? There is an ambiguity in a parameter declaration \"int\n@@ -2155,7 +2155,7 @@ c_parser_direct_declarator (c_parser *parser, bool type_seen_p, c_dtr_syn kind,\n      documenting.  At present we follow an accident of the old\n      parser's implementation, whereby the first parameter must have\n      some declaration specifiers other than just attributes.  Thus as\n-     a parameter declaration it is treated as a parenthesised\n+     a parameter declaration it is treated as a parenthesized\n      parameter named x, and as an abstract declarator it is\n      rejected.\n \n@@ -5325,7 +5325,7 @@ c_parser_expr_list (c_parser *parser)\n \n    \"@interface identifier (\" must start \"@interface identifier (\n    identifier ) ...\": objc-methodprotolist in the first production may\n-   not start with a parenthesised identifier as a declarator of a data\n+   not start with a parenthesized identifier as a declarator of a data\n    definition with no declaration specifiers if the objc-superclass,\n    objc-protocol-refs and objc-class-instance-variables are omitted.  */\n "}, {"sha": "d87d6d35de56b45a7007b3d562210a4596fdea4e", "filename": "gcc/cfgbuild.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fa2e4df4739bda990b1be0f8a0455ced48bc3b1/gcc%2Fcfgbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fa2e4df4739bda990b1be0f8a0455ced48bc3b1/gcc%2Fcfgbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgbuild.c?ref=0fa2e4df4739bda990b1be0f8a0455ced48bc3b1", "patch": "@@ -225,8 +225,7 @@ enum state {\n \n   /* Basic blocks that may need splitting (due to a label appearing in\n      the middle, etc) belong to this state.  After splitting them,\n-     make_edges will create create edges going out of them as\n-     needed.  */\n+     make_edges will create edges going out of them as needed.  */\n   BLOCK_TO_SPLIT\n };\n "}, {"sha": "35e65a31c3114c784add2d26a1f0d97e7ebe86e1", "filename": "gcc/cfghooks.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fa2e4df4739bda990b1be0f8a0455ced48bc3b1/gcc%2Fcfghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fa2e4df4739bda990b1be0f8a0455ced48bc3b1/gcc%2Fcfghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfghooks.c?ref=0fa2e4df4739bda990b1be0f8a0455ced48bc3b1", "patch": "@@ -825,7 +825,7 @@ execute_on_shrinking_pred (edge e)\n }\n \n /* This is used inside loop versioning when we want to insert \n-   stmts/insns on the edges, which have a different behaviour \n+   stmts/insns on the edges, which have a different behavior \n    in tree's and in RTL, so we made a CFG hook.  */\n void\n lv_flush_pending_stmts (edge e)"}, {"sha": "5867d9727748ca92ac16ebf75192f1e180de34fe", "filename": "gcc/cfghooks.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fa2e4df4739bda990b1be0f8a0455ced48bc3b1/gcc%2Fcfghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fa2e4df4739bda990b1be0f8a0455ced48bc3b1/gcc%2Fcfghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfghooks.h?ref=0fa2e4df4739bda990b1be0f8a0455ced48bc3b1", "patch": "@@ -119,7 +119,7 @@ struct cfg_hooks\n \t\t\t\t\t\t  unsigned int *n_to_remove,\n \t\t\t\t\t\t  int flags);\n \n-  /* Add conition to new basic block and update CFG used in loop\n+  /* Add condition to new basic block and update CFG used in loop\n      versioning.  */\n   void (*lv_add_condition_to_bb) (basic_block, basic_block, basic_block,\n   \t\t\t\t  void *);"}, {"sha": "86b2435c30a0851c3351b7be7d3d33382cb4f1a5", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fa2e4df4739bda990b1be0f8a0455ced48bc3b1/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fa2e4df4739bda990b1be0f8a0455ced48bc3b1/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=0fa2e4df4739bda990b1be0f8a0455ced48bc3b1", "patch": "@@ -1190,7 +1190,7 @@ rtl_tidy_fallthru_edge (edge e)\n \n   /* ??? In a late-running flow pass, other folks may have deleted basic\n      blocks by nopping out blocks, leaving multiple BARRIERs between here\n-     and the target label. They ought to be chastized and fixed.\n+     and the target label. They ought to be chastised and fixed.\n \n      We can also wind up with a sequence of undeletable labels between\n      one block and the next."}, {"sha": "2f837672fb5274522994e59b0fdda52b55e6645b", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fa2e4df4739bda990b1be0f8a0455ced48bc3b1/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fa2e4df4739bda990b1be0f8a0455ced48bc3b1/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=0fa2e4df4739bda990b1be0f8a0455ced48bc3b1", "patch": "@@ -275,7 +275,7 @@ cgraph_varpool_analyze_pending_decls (void)\n /* Optimization of function bodies might've rendered some variables as\n    unnecessary so we want to avoid these from being compiled.\n \n-   This is done by prunning the queue and keeping only the variables that\n+   This is done by pruning the queue and keeping only the variables that\n    really appear needed (ie they are either externally visible or referenced\n    by compiled function). Re-doing the reachability analysis on variables\n    brings back the remaining variables referenced by these.  */"}, {"sha": "8924a490ff4ebe8ddd5ea8c937e960d575667699", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fa2e4df4739bda990b1be0f8a0455ced48bc3b1/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fa2e4df4739bda990b1be0f8a0455ced48bc3b1/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=0fa2e4df4739bda990b1be0f8a0455ced48bc3b1", "patch": "@@ -6976,7 +6976,7 @@ add_minipool_forward_ref (Mfix *fix)\n   /* If this fix's address is greater than the address of the first\n      entry, then we can't put the fix in this pool.  We subtract the\n      size of the current fix to ensure that if the table is fully\n-     packed we still have enough room to insert this value by suffling\n+     packed we still have enough room to insert this value by shuffling\n      the other fixes forwards.  */\n   if (minipool_vector_head &&\n       fix->address >= minipool_vector_head->max_address - fix->fix_size)\n@@ -13492,7 +13492,7 @@ thumb_output_function_prologue (FILE *f, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n       asm_fprintf (f, \"\\tmov\\t%r, %r\\t\\t%@ Backtrace structure created\\n\",\n \t\t   ARM_HARD_FRAME_POINTER_REGNUM, work_register);\n     }\n-  /* Optimisation:  If we are not pushing any low registers but we are going\n+  /* Optimization:  If we are not pushing any low registers but we are going\n      to push some high registers then delay our first push.  This will just\n      be a push of LR and we can combine it with the push of the first high\n      register.  */\n@@ -14436,7 +14436,7 @@ arm_cxx_guard_type (void)\n }\n \n \n-/* The EABI says test the least significan bit of a guard variable.  */\n+/* The EABI says test the least significant bit of a guard variable.  */\n \n static bool\n arm_cxx_guard_mask_bit (void)"}, {"sha": "da31338e4ba4e7d166a828f8d0493d7dc64042ea", "filename": "gcc/config/bfin/bfin.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fa2e4df4739bda990b1be0f8a0455ced48bc3b1/gcc%2Fconfig%2Fbfin%2Fbfin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fa2e4df4739bda990b1be0f8a0455ced48bc3b1/gcc%2Fconfig%2Fbfin%2Fbfin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.c?ref=0fa2e4df4739bda990b1be0f8a0455ced48bc3b1", "patch": "@@ -2466,7 +2466,7 @@ bfin_adjust_cost (rtx insn, rtx link, rtx dep_insn, int cost)\n    which perform the memory reference, are allowed to execute before the\n    jump condition is evaluated.\n    Therefore, we must insert additional instructions in all places where this\n-   could lead to incorrect behaviour.  The manual recommends CSYNC, while\n+   could lead to incorrect behavior.  The manual recommends CSYNC, while\n    VDSP seems to use NOPs (even though its corresponding compiler option is\n    named CSYNC).\n "}, {"sha": "cc9270c88bbcba739df767ebbefadeca7f898dc6", "filename": "gcc/config/frv/frv.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fa2e4df4739bda990b1be0f8a0455ced48bc3b1/gcc%2Fconfig%2Ffrv%2Ffrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fa2e4df4739bda990b1be0f8a0455ced48bc3b1/gcc%2Fconfig%2Ffrv%2Ffrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.c?ref=0fa2e4df4739bda990b1be0f8a0455ced48bc3b1", "patch": "@@ -8197,7 +8197,7 @@ frv_int_to_acc (enum insn_code icode, int opnum, rtx opval)\n   rtx reg;\n   int i;\n \n-  /* ACCs and ACCGs are implicity global registers if media intrinsics\n+  /* ACCs and ACCGs are implicit global registers if media intrinsics\n      are being used.  We set up this lazily to avoid creating lots of\n      unnecessary call_insn rtl in non-media code.  */\n   for (i = 0; i <= ACC_MASK; i++)\n@@ -8292,7 +8292,7 @@ frv_read_iacc_argument (enum machine_mode mode, tree *arglistptr)\n       op = const0_rtx;\n     }\n \n-  /* IACCs are implicity global registers.  We set up this lazily to\n+  /* IACCs are implicit global registers.  We set up this lazily to\n      avoid creating lots of unnecessary call_insn rtl when IACCs aren't\n      being used.  */\n   regno = INTVAL (op) + IACC_FIRST;\n@@ -8622,7 +8622,7 @@ frv_expand_mdpackh_builtin (tree arglist, rtx target)\n   op0 = gen_reg_rtx (DImode);\n   op1 = gen_reg_rtx (DImode);\n \n-  /* The high half of each word is not explicitly initialised, so indicate\n+  /* The high half of each word is not explicitly initialized, so indicate\n      that the input operands are not live before this point.  */\n   emit_insn (gen_rtx_CLOBBER (DImode, op0));\n   emit_insn (gen_rtx_CLOBBER (DImode, op1));"}, {"sha": "8514da2221aacdc351bccbe51cd79871369fe0c7", "filename": "gcc/config/frv/frv.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fa2e4df4739bda990b1be0f8a0455ced48bc3b1/gcc%2Fconfig%2Ffrv%2Ffrv.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fa2e4df4739bda990b1be0f8a0455ced48bc3b1/gcc%2Fconfig%2Ffrv%2Ffrv.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.md?ref=0fa2e4df4739bda990b1be0f8a0455ced48bc3b1", "patch": "@@ -1669,7 +1669,7 @@\n ;; Note - it is best to only have one movsi pattern and to handle\n ;; all the various contingencies by the use of alternatives.  This\n ;; allows reload the greatest amount of flexibility (since reload will\n-;; only choose amoungst alternatives for a selected insn, it will not\n+;; only choose amongst alternatives for a selected insn, it will not\n ;; replace the insn with another one).\n \n ;; Unfortunately, we do have to separate out load-type moves from the rest,"}, {"sha": "c63913b9e9dd531da31f43d068ea126231d2dd2a", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fa2e4df4739bda990b1be0f8a0455ced48bc3b1/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fa2e4df4739bda990b1be0f8a0455ced48bc3b1/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=0fa2e4df4739bda990b1be0f8a0455ced48bc3b1", "patch": "@@ -1511,7 +1511,7 @@ override_options (void)\n     target_flags &= ~MASK_NO_FANCY_MATH_387;\n \n   /* Likewise, if the target doesn't have a 387, or we've specified\n-     software floating point, don't use 387 inline instrinsics.  */\n+     software floating point, don't use 387 inline intrinsics.  */\n   if (!TARGET_80387)\n     target_flags |= MASK_NO_FANCY_MATH_387;\n \n@@ -1847,7 +1847,7 @@ ix86_comp_type_attributes (tree type1, tree type2)\n   return 1;\n }\n \f\n-/* Return the regparm value for a fuctio with the indicated TYPE and DECL.\n+/* Return the regparm value for a function with the indicated TYPE and DECL.\n    DECL may be NULL when calling function indirectly\n    or considering a libcall.  */\n \n@@ -15265,7 +15265,7 @@ ix86_cannot_change_mode_class (enum machine_mode from, enum machine_mode to,\n   if (from == to)\n     return false;\n \n-  /* x87 registers can't do subreg at all, as all values are reformated\n+  /* x87 registers can't do subreg at all, as all values are reformatted\n      to extended precision.  */\n   if (MAYBE_FLOAT_CLASS_P (class))\n     return true;"}, {"sha": "48b6cde169260ae37e319e85f125114af1ed4280", "filename": "gcc/config/i386/sse.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fa2e4df4739bda990b1be0f8a0455ced48bc3b1/gcc%2Fconfig%2Fi386%2Fsse.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fa2e4df4739bda990b1be0f8a0455ced48bc3b1/gcc%2Fconfig%2Fi386%2Fsse.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsse.md?ref=0fa2e4df4739bda990b1be0f8a0455ced48bc3b1", "patch": "@@ -1744,7 +1744,7 @@\n    (set_attr \"mode\" \"V2DF\")])\n \n ;; Also define scalar versions.  These are used for abs, neg, and\n-;; conditional move.  Using subregs into vector modes causes regiser\n+;; conditional move.  Using subregs into vector modes causes register\n ;; allocation lossage.  These patterns do not allow memory operands\n ;; because the native instructions read the full 128-bits.\n "}, {"sha": "30f2ff9e740a15c4d1b21b541bc5f073ee306022", "filename": "gcc/config/m68hc11/m68hc11.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fa2e4df4739bda990b1be0f8a0455ced48bc3b1/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fa2e4df4739bda990b1be0f8a0455ced48bc3b1/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c?ref=0fa2e4df4739bda990b1be0f8a0455ced48bc3b1", "patch": "@@ -5018,7 +5018,7 @@ m68hc11_reorg (void)\n      replacement, unshare everything.  */\n   unshare_all_rtl_again (first);\n \n-  /* Force a split of all splitable insn.  This is necessary for the\n+  /* Force a split of all splittable insn.  This is necessary for the\n      Z register replacement mechanism because we end up with basic insns.  */\n   split_all_insns_noflow ();\n   split_done = 1;"}, {"sha": "7ec76bf7cbd4707b35a4cb839225d821327402d3", "filename": "gcc/config/m68hc11/m68hc11.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fa2e4df4739bda990b1be0f8a0455ced48bc3b1/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fa2e4df4739bda990b1be0f8a0455ced48bc3b1/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.h?ref=0fa2e4df4739bda990b1be0f8a0455ced48bc3b1", "patch": "@@ -450,7 +450,7 @@ SOFT_REG_FIRST+28, SOFT_REG_FIRST+29,SOFT_REG_FIRST+30,SOFT_REG_FIRST+31\n    For any two classes, it is very desirable that there be another\n    class that represents their union.  */\n \n-/* The M68hc11 has so fiew registers that it's not possible for GCC to\n+/* The M68hc11 has so few registers that it's not possible for GCC to\n    do any register allocation without breaking. We extend the processor\n    registers by having soft registers. These registers are treated as\n    hard registers by GCC but they are located in memory and accessed by page0"}, {"sha": "a2c963aac8a60f9dc18da073911ab7d6eeee6f67", "filename": "gcc/config/mcore/mcore.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fa2e4df4739bda990b1be0f8a0455ced48bc3b1/gcc%2Fconfig%2Fmcore%2Fmcore.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fa2e4df4739bda990b1be0f8a0455ced48bc3b1/gcc%2Fconfig%2Fmcore%2Fmcore.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore.c?ref=0fa2e4df4739bda990b1be0f8a0455ced48bc3b1", "patch": "@@ -2117,7 +2117,7 @@ mcore_expand_epilog (void)\n \n /* The MCORE cannot load a large constant into a register, constants have to\n    come from a pc relative load.  The reference of a pc relative load\n-   instruction must be less than 1k infront of the instruction.  This\n+   instruction must be less than 1k in front of the instruction.  This\n    means that we often have to dump a constant inside a function, and\n    generate code to branch around it.\n "}, {"sha": "146af7ab60eb6addf3136470a6708683fabc8095", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fa2e4df4739bda990b1be0f8a0455ced48bc3b1/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fa2e4df4739bda990b1be0f8a0455ced48bc3b1/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=0fa2e4df4739bda990b1be0f8a0455ced48bc3b1", "patch": "@@ -4042,7 +4042,7 @@ mips_gimplify_va_arg_expr (tree valist, tree type, tree *pre_p, tree *post_p)\n    left-side instructions (lwl, swl, ldl, sdl).\n \n    *RIGHT is a QImode reference to the opposite end of the field and\n-   can be used in the parterning right-side instruction.  */\n+   can be used in the patterning right-side instruction.  */\n \n static bool\n mips_get_unaligned_mem (rtx *op, unsigned int width, int bitpos,"}, {"sha": "d9ce907af9226a6fea773103d6956c2b9f37ee22", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fa2e4df4739bda990b1be0f8a0455ced48bc3b1/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fa2e4df4739bda990b1be0f8a0455ced48bc3b1/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=0fa2e4df4739bda990b1be0f8a0455ced48bc3b1", "patch": "@@ -5367,7 +5367,7 @@ beq\\t%2,%.,1b\\;\\\n \f\n ; Thread-Local Storage\n \n-; The TLS base pointer is acessed via \"rdhwr $v1, $29\".  No current\n+; The TLS base pointer is accessed via \"rdhwr $v1, $29\".  No current\n ; MIPS architecture defines this register, and no current\n ; implementation provides it; instead, any OS which supports TLS is\n ; expected to trap and emulate this instruction.  rdhwr is part of the"}, {"sha": "9ac9a8a0e8ff7bc06b54a05843d326cf12ab0d8e", "filename": "gcc/config/rs6000/darwin-ldouble.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fa2e4df4739bda990b1be0f8a0455ced48bc3b1/gcc%2Fconfig%2Frs6000%2Fdarwin-ldouble.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fa2e4df4739bda990b1be0f8a0455ced48bc3b1/gcc%2Fconfig%2Frs6000%2Fdarwin-ldouble.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fdarwin-ldouble.c?ref=0fa2e4df4739bda990b1be0f8a0455ced48bc3b1", "patch": "@@ -68,7 +68,7 @@ extern long double __gcc_qmul (double, double, double, double);\n extern long double __gcc_qdiv (double, double, double, double);\n \n #if defined __ELF__ && defined SHARED\n-/* Provide definitions of the old symbol names to statisfy apps and\n+/* Provide definitions of the old symbol names to satisfy apps and\n    shared libs built against an older libgcc.  To access the _xlq\n    symbols an explicit version reference is needed, so these won't\n    satisfy an unadorned reference like _xlqadd.  If dot symbols are"}, {"sha": "b50ab94677192cb438d9b8f7a8e7bd6c60fced90", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fa2e4df4739bda990b1be0f8a0455ced48bc3b1/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fa2e4df4739bda990b1be0f8a0455ced48bc3b1/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=0fa2e4df4739bda990b1be0f8a0455ced48bc3b1", "patch": "@@ -16120,7 +16120,7 @@ force_new_group (int sched_verbose, FILE *dump, rtx *group_insns,\n    between the insns.\n \n    The function estimates the group boundaries that the processor will form as\n-   folllows:  It keeps track of how many vacant issue slots are available after\n+   follows:  It keeps track of how many vacant issue slots are available after\n    each insn.  A subsequent insn will start a new group if one of the following\n    4 cases applies:\n    - no more vacant issue slots remain in the current dispatch group."}, {"sha": "79fcc68c3cba5477190547e4cf018b35337afa9d", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fa2e4df4739bda990b1be0f8a0455ced48bc3b1/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fa2e4df4739bda990b1be0f8a0455ced48bc3b1/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=0fa2e4df4739bda990b1be0f8a0455ced48bc3b1", "patch": "@@ -136,7 +136,7 @@\n #define TARGET_MFCRF 0\n #endif\n \n-/* Define TARGET_POPCNTB if the target assembler does not suppport the\n+/* Define TARGET_POPCNTB if the target assembler does not support the\n    popcount byte instruction.  */\n \n #ifndef HAVE_AS_POPCNTB"}, {"sha": "be3e2bba44ed0bc205f83775ef642c08a92f97fb", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fa2e4df4739bda990b1be0f8a0455ced48bc3b1/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fa2e4df4739bda990b1be0f8a0455ced48bc3b1/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=0fa2e4df4739bda990b1be0f8a0455ced48bc3b1", "patch": "@@ -2909,7 +2909,7 @@ gen_datalabel_ref (rtx sym)\n \f\n /* The SH cannot load a large constant into a register, constants have to\n    come from a pc relative load.  The reference of a pc relative load\n-   instruction must be less than 1k infront of the instruction.  This\n+   instruction must be less than 1k in front of the instruction.  This\n    means that we often have to dump a constant inside a function, and\n    generate code to branch around it.\n "}, {"sha": "de46e08c82d3f046937e5f870283674597b89f3c", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fa2e4df4739bda990b1be0f8a0455ced48bc3b1/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fa2e4df4739bda990b1be0f8a0455ced48bc3b1/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=0fa2e4df4739bda990b1be0f8a0455ced48bc3b1", "patch": "@@ -1106,7 +1106,7 @@\n   rtx set1, set2;\n   rtx replacements[4];\n \n-  /* We want to replace occurences of operands[0] with operands[1] and\n+  /* We want to replace occurrences of operands[0] with operands[1] and\n      operands[2] with operands[0] in operands[4]/operands[5].\n      Doing just two replace_rtx calls naively would result in the second\n      replacement undoing all that the first did if operands[1] and operands[2]"}, {"sha": "98e9a5bd365e6dab5b18781578e67a3f3b83ae78", "filename": "gcc/config/sh/ushmedia.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fa2e4df4739bda990b1be0f8a0455ced48bc3b1/gcc%2Fconfig%2Fsh%2Fushmedia.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fa2e4df4739bda990b1be0f8a0455ced48bc3b1/gcc%2Fconfig%2Fsh%2Fushmedia.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fushmedia.h?ref=0fa2e4df4739bda990b1be0f8a0455ced48bc3b1", "patch": "@@ -720,14 +720,14 @@ sh_media_ADDZ_L (unsigned int mm, unsigned int mn)\n   return mm + mn;\n }\n \n-/* NOP and Synchronization instrinsics not implemented here.  */\n+/* NOP and Synchronization intrinsics not implemented here.  */\n \n static __inline__ void sh_media_PREFO(void *mm, int s)\n {\n   __builtin_sh_media_PREFO (mm + s, 0, 0);\n }\n \n-/* Event Handling instrinsics not implemented here.  */\n+/* Event Handling intrinsics not implemented here.  */\n \n /* Old asm stuff */\n "}, {"sha": "9d5edd183913bb48bfc0b7bb18b38906d8a435a4", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fa2e4df4739bda990b1be0f8a0455ced48bc3b1/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fa2e4df4739bda990b1be0f8a0455ced48bc3b1/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=0fa2e4df4739bda990b1be0f8a0455ced48bc3b1", "patch": "@@ -7839,7 +7839,7 @@ sparc_vis_init_builtins (void)\n }\n \n /* Handle TARGET_EXPAND_BUILTIN target hook.\n-   Expand builtin functions for sparc instrinsics.  */\n+   Expand builtin functions for sparc intrinsics.  */\n \n static rtx\n sparc_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,"}, {"sha": "cea956624df0f9922799caaec150a6835524da11", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fa2e4df4739bda990b1be0f8a0455ced48bc3b1/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fa2e4df4739bda990b1be0f8a0455ced48bc3b1/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=0fa2e4df4739bda990b1be0f8a0455ced48bc3b1", "patch": "@@ -854,7 +854,7 @@\n \n ;; The SEQ and SNE patterns are special because they can be done\n ;; without any branching and do not involve a COMPARE.  We want\n-;; them to always use the splitz below so the results can be\n+;; them to always use the splits below so the results can be\n ;; scheduled.\n \n (define_insn_and_split \"*snesi_zero\"\n@@ -8363,7 +8363,7 @@\n    (set_attr \"fptype\" \"double\")])\n \n ;; Using faligndata only makes sense after an alignaddr since the choice of\n-;; bytes to take out of each operand is dependant on the results of the last\n+;; bytes to take out of each operand is dependent on the results of the last\n ;; alignaddr.\n (define_insn \"faligndata<V64I:mode>_vis\"\n   [(set (match_operand:V64I 0 \"register_operand\" \"=e\")"}, {"sha": "8c6d590d4ec1dfc9b9b4c905e87ac157939fc0b1", "filename": "gcc/config/stormy16/stormy-abi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fa2e4df4739bda990b1be0f8a0455ced48bc3b1/gcc%2Fconfig%2Fstormy16%2Fstormy-abi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fa2e4df4739bda990b1be0f8a0455ced48bc3b1/gcc%2Fconfig%2Fstormy16%2Fstormy-abi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fstormy16%2Fstormy-abi?ref=0fa2e4df4739bda990b1be0f8a0455ced48bc3b1", "patch": "@@ -159,7 +159,7 @@ the reloc refers, 'A' is the addend, and 'P' represents the place of\n the storage unit being relocated.\n \n In the 'Overflow' column, 'none' means that any overflow of the\n-computation perfomed in the 'Calculation' column is ignored.\n+computation performed in the 'Calculation' column is ignored.\n 'signed' means that the overflow is only reported if it happens when\n the values are treated as signed quantities.  'unsigned' is the same,\n except that the values are treated as unsigned quantities.  'either'"}, {"sha": "cbdb18e72bc6dc8254c016625d99fd800ff240db", "filename": "gcc/ddg.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fa2e4df4739bda990b1be0f8a0455ced48bc3b1/gcc%2Fddg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fa2e4df4739bda990b1be0f8a0455ced48bc3b1/gcc%2Fddg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fddg.c?ref=0fa2e4df4739bda990b1be0f8a0455ced48bc3b1", "patch": "@@ -302,7 +302,7 @@ add_deps_for_use (ddg_ptr g, struct df *df, struct ref *use)\n      if (df_find_def (df, g->nodes[i].insn, use->reg))\n        return;\n   /* We must not add ANTI dep when there is an intra-loop TRUE dep in\n-     the opozite direction. If the first_def reaches the USE then there is\n+     the opposite direction. If the first_def reaches the USE then there is\n      such a dep.  */\n   if (! bitmap_bit_p (bb_info->rd_gen, first_def->id))\n     create_ddg_dep_no_link (g, use_node, def_node, ANTI_DEP, REG_DEP, 1);"}, {"sha": "4f8be566fdf31d04cadbeac5d3bde37b6a05523b", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fa2e4df4739bda990b1be0f8a0455ced48bc3b1/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fa2e4df4739bda990b1be0f8a0455ced48bc3b1/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=0fa2e4df4739bda990b1be0f8a0455ced48bc3b1", "patch": "@@ -4470,7 +4470,7 @@ See below for a documentation of the individual\n parameters controlling inlining.\n \n @emph{Note:} pseudo instruction represents, in this particular context, an\n-abstract measurement of function's size.  In no way, it represents a count\n+abstract measurement of function's size.  In no way does it represent a count\n of assembly instructions and as such its exact meaning might change from one\n release to an another.\n "}, {"sha": "a82d353dfbb6c1498365ca6a17d8c41cbde3c844", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fa2e4df4739bda990b1be0f8a0455ced48bc3b1/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fa2e4df4739bda990b1be0f8a0455ced48bc3b1/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=0fa2e4df4739bda990b1be0f8a0455ced48bc3b1", "patch": "@@ -9519,7 +9519,7 @@ low-overhead loop.\n Many targets use special registers for low-overhead looping. This function\n should return false for any instruction that clobbers these. \n By default, the RTL loop optimizer does not use a present doloop pattern for\n-loops containing function calls or brach on table instructions.  \n+loops containing function calls or branch on table instructions.  \n @end deftypefn\n \n @defmac MD_CAN_REDIRECT_BRANCH (@var{branch1}, @var{branch2})"}, {"sha": "56c605c0b57e564a745a8f6fbedeb49e7e70ff59", "filename": "gcc/doc/tree-ssa.texi", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fa2e4df4739bda990b1be0f8a0455ced48bc3b1/gcc%2Fdoc%2Ftree-ssa.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fa2e4df4739bda990b1be0f8a0455ced48bc3b1/gcc%2Fdoc%2Ftree-ssa.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftree-ssa.texi?ref=0fa2e4df4739bda990b1be0f8a0455ced48bc3b1", "patch": "@@ -1282,7 +1282,7 @@ After the replacement mappings have been registered and new symbols\n marked for renaming, a call to @code{update_ssa} makes the registered\n changes.  This can be done with an explicit call or by creating\n @code{TODO} flags in the @code{tree_opt_pass} structure for your pass.\n-There are several @code{TODO} flags that control the behaviour of\n+There are several @code{TODO} flags that control the behavior of\n @code{update_ssa}:\n \n @itemize @bullet\n@@ -1304,7 +1304,7 @@ There are several @code{TODO} flags that control the behaviour of\n \n \n @item @code{TODO_update_ssa_full_phi}.  Insert PHI nodes everywhere\n-      they are needed.  No prunning of the IDF is done.  This is used\n+      they are needed.  No pruning of the IDF is done.  This is used\n       by passes that need the PHI nodes for @code{O_j} even if it\n       means that some arguments will come from the default definition\n       of @code{O_j}'s symbol (e.g., @code{pass_linear_transform})@."}, {"sha": "550c0d0afc63c0632f1316589fc3dc26f530281e", "filename": "gcc/expr.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fa2e4df4739bda990b1be0f8a0455ced48bc3b1/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fa2e4df4739bda990b1be0f8a0455ced48bc3b1/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=0fa2e4df4739bda990b1be0f8a0455ced48bc3b1", "patch": "@@ -588,7 +588,7 @@ extern rtx eliminate_constant_term (rtx, rtx *);\n    by emitting insns to perform arithmetic if nec.  */\n extern rtx memory_address (enum machine_mode, rtx);\n \n-/* Like `memory_address' but pretent `flag_force_addr' is 0.  */\n+/* Like `memory_address' but pretend `flag_force_addr' is 0.  */\n extern rtx memory_address_noforce (enum machine_mode, rtx);\n \n /* Return a memory reference like MEMREF, but with its mode changed"}, {"sha": "0fe20ab0c75b410719a7b30e626dbd79cec26fa8", "filename": "gcc/gcse.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fa2e4df4739bda990b1be0f8a0455ced48bc3b1/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fa2e4df4739bda990b1be0f8a0455ced48bc3b1/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=0fa2e4df4739bda990b1be0f8a0455ced48bc3b1", "patch": "@@ -507,11 +507,11 @@ static int gcse_subst_count;\n static int gcse_create_count;\n /* Number of local constants propagated.  */\n static int local_const_prop_count;\n-/* Number of local copys propagated.  */\n+/* Number of local copies propagated.  */\n static int local_copy_prop_count;\n /* Number of global constants propagated.  */\n static int global_const_prop_count;\n-/* Number of global copys propagated.  */\n+/* Number of global copies propagated.  */\n static int global_copy_prop_count;\n \f\n /* For available exprs */"}, {"sha": "4da04b378bd346b50bd1f56a00da86b019fbdfc6", "filename": "gcc/ggc-page.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fa2e4df4739bda990b1be0f8a0455ced48bc3b1/gcc%2Fggc-page.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fa2e4df4739bda990b1be0f8a0455ced48bc3b1/gcc%2Fggc-page.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-page.c?ref=0fa2e4df4739bda990b1be0f8a0455ced48bc3b1", "patch": "@@ -75,7 +75,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #define USING_MALLOC_PAGE_GROUPS\n #endif\n \n-/* Stategy:\n+/* Strategy:\n \n    This garbage-collecting allocator allocates objects on one of a set\n    of pages.  Each page can allocate objects of a single size only;"}, {"sha": "eb4fc1484ef7ec96642d91bca014b13826b4c5d8", "filename": "gcc/ggc-zone.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fa2e4df4739bda990b1be0f8a0455ced48bc3b1/gcc%2Fggc-zone.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fa2e4df4739bda990b1be0f8a0455ced48bc3b1/gcc%2Fggc-zone.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-zone.c?ref=0fa2e4df4739bda990b1be0f8a0455ced48bc3b1", "patch": "@@ -100,7 +100,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    ggc_set_mark for any object in the garbage zone, which cuts off\n    marking quickly.  */\n \n-/* Stategy:\n+/* Strategy:\n \n    This garbage-collecting allocator segregates objects into zones.\n    It also segregates objects into \"large\" and \"small\" bins.  Large"}, {"sha": "9452973004e409ed01f62958369f3c815e30617d", "filename": "gcc/gimplify.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fa2e4df4739bda990b1be0f8a0455ced48bc3b1/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fa2e4df4739bda990b1be0f8a0455ced48bc3b1/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=0fa2e4df4739bda990b1be0f8a0455ced48bc3b1", "patch": "@@ -3017,7 +3017,7 @@ gimplify_modify_expr (tree *expr_p, tree *pre_p, tree *post_p, bool want_value)\n   if (gimplify_ctxp->into_ssa && is_gimple_reg (*to_p))\n     {\n       /* If we've somehow already got an SSA_NAME on the LHS, then\n-\t we're probably modifying it twice.  Not good.  */\n+\t we're probably modified it twice.  Not good.  */\n       gcc_assert (TREE_CODE (*to_p) != SSA_NAME);\n       *to_p = make_ssa_name (*to_p, *expr_p);\n     }"}, {"sha": "fbda466e558c58313916881a11800646d600f79c", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fa2e4df4739bda990b1be0f8a0455ced48bc3b1/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fa2e4df4739bda990b1be0f8a0455ced48bc3b1/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=0fa2e4df4739bda990b1be0f8a0455ced48bc3b1", "patch": "@@ -320,13 +320,13 @@ cgraph_maybe_hot_edge_p (struct cgraph_edge *edge)\n \n /* A cost model driving the inlining heuristics in a way so the edges with\n    smallest badness are inlined first.  After each inlining is performed\n-   the costs of all caller edges of nodes affected are recompted so the\n+   the costs of all caller edges of nodes affected are recomputed so the\n    metrics may accurately depend on values such as number of inlinable callers\n    of the function or function body size.\n \n    For the moment we use estimated growth caused by inlining callee into all\n    it's callers for driving the inlining but once we have loop depth or\n-   frequency information readilly available we should do better.\n+   frequency information readily available we should do better.\n \n    With profiling we use number of executions of each edge to drive the cost.\n    We also should distinguish hot and cold calls where the cold calls are\n@@ -344,7 +344,7 @@ cgraph_edge_badness (struct cgraph_edge *edge)\n \tcgraph_estimate_size_after_inlining (1, edge->caller, edge->callee);\n       growth -= edge->caller->global.insns;\n \n-      /* Always preffer inlining saving code size.  */\n+      /* Always prefer inlining saving code size.  */\n       if (growth <= 0)\n \treturn INT_MIN - growth;\n       return ((int)((double)edge->count * INT_MIN / max_count)) / growth;\n@@ -416,7 +416,7 @@ update_callee_keys (fibheap_t heap, struct cgraph_node *node,\n }\n \n /* Enqueue all recursive calls from NODE into priority queue depending on\n-   how likely we want to recursivly inline the call.  */\n+   how likely we want to recursively inline the call.  */\n \n static void\n lookup_recursive_calls (struct cgraph_node *node, struct cgraph_node *where,\n@@ -608,7 +608,7 @@ cgraph_decide_inlining_of_small_functions (void)\n \tcontinue;\n \n       /* When not having profile info ready we don't weight by any way the\n-         possition of call in procedure itself.  This means if call of\n+         position of call in procedure itself.  This means if call of\n \t function A from function B seems profitable to inline, the recursive\n \t call of function A in inline copy of A in B will look profitable too\n \t and we end up inlining until reaching maximal function growth.  This"}, {"sha": "57ae6343447086578109f058e5e3e82412c04b85", "filename": "gcc/longlong.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fa2e4df4739bda990b1be0f8a0455ced48bc3b1/gcc%2Flonglong.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fa2e4df4739bda990b1be0f8a0455ced48bc3b1/gcc%2Flonglong.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flonglong.h?ref=0fa2e4df4739bda990b1be0f8a0455ced48bc3b1", "patch": "@@ -46,8 +46,8 @@\n \n /* Define auxiliary asm macros.\n \n-   1) umul_ppmm(high_prod, low_prod, multipler, multiplicand) multiplies two\n-   UWtype integers MULTIPLER and MULTIPLICAND, and generates a two UWtype\n+   1) umul_ppmm(high_prod, low_prod, multiplier, multiplicand) multiplies two\n+   UWtype integers MULTIPLIER and MULTIPLICAND, and generates a two UWtype\n    word product in HIGH_PROD and LOW_PROD.\n \n    2) __umulsidi3(a,b) multiplies two UWtype integers A and B, and returns a"}, {"sha": "42992b78c34c3bc55b4033e2c9766300d73ba539", "filename": "gcc/targhooks.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fa2e4df4739bda990b1be0f8a0455ced48bc3b1/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fa2e4df4739bda990b1be0f8a0455ced48bc3b1/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=0fa2e4df4739bda990b1be0f8a0455ced48bc3b1", "patch": "@@ -264,7 +264,7 @@ default_scalar_mode_supported_p (enum machine_mode mode)\n \n /* TRUE if INSN insn is valid within a low-overhead loop.\n   \n-   This function checks wheter a given INSN is valid within a low-overhead\n+   This function checks whether a given INSN is valid within a low-overhead\n    loop.  A called function may clobber any special registers required for\n    low-overhead looping. Additionally, some targets (eg, PPC) use the count\n    register for branch on table instructions. We reject the doloop pattern in"}, {"sha": "31afd9d0893ae580e62c0ec668a261b9199a9d17", "filename": "gcc/tree-flow-inline.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fa2e4df4739bda990b1be0f8a0455ced48bc3b1/gcc%2Ftree-flow-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fa2e4df4739bda990b1be0f8a0455ced48bc3b1/gcc%2Ftree-flow-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow-inline.h?ref=0fa2e4df4739bda990b1be0f8a0455ced48bc3b1", "patch": "@@ -238,7 +238,7 @@ set_ssa_use_from_ptr (use_operand_p use, tree val)\n   link_imm_use (use, val);\n }\n \n-/* Link ssa_imm_use node LINKNODE into the chain for DEF, with use occuring \n+/* Link ssa_imm_use node LINKNODE into the chain for DEF, with use occurring \n    in STMT.  */\n static inline void\n link_imm_use_stmt (ssa_use_operand_t *linknode, tree def, tree stmt)\n@@ -267,7 +267,7 @@ relink_imm_use (ssa_use_operand_t *node, ssa_use_operand_t *old)\n     }\n }\n \n-/* Relink ssa_imm_use node LINKNODE into the chain for OLD, with use occuring \n+/* Relink ssa_imm_use node LINKNODE into the chain for OLD, with use occurring \n    in STMT.  */\n static inline void\n relink_imm_use_stmt (ssa_use_operand_t *linknode, ssa_use_operand_t *old, tree stmt)"}, {"sha": "8af9f83de88e639dacef770071ef295b7666ee83", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fa2e4df4739bda990b1be0f8a0455ced48bc3b1/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fa2e4df4739bda990b1be0f8a0455ced48bc3b1/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=0fa2e4df4739bda990b1be0f8a0455ced48bc3b1", "patch": "@@ -126,7 +126,7 @@ struct dump_file_info\n    chains for virtuals (e.g., DCE).  */\n #define TODO_update_ssa_no_phi\t\t(1 << 8)\n \n-/* Insert PHI nodes everywhere they are needed.  No prunning of the\n+/* Insert PHI nodes everywhere they are needed.  No pruning of the\n    IDF is done.  This is used by passes that need the PHI nodes for\n    O_j even if it means that some arguments will come from the default\n    definition of O_j's symbol (e.g., pass_linear_transform)."}, {"sha": "5461b3d0414628a788836e1883bf368ea8e32a02", "filename": "gcc/tree-ssa-dse.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fa2e4df4739bda990b1be0f8a0455ced48bc3b1/gcc%2Ftree-ssa-dse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fa2e4df4739bda990b1be0f8a0455ced48bc3b1/gcc%2Ftree-ssa-dse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dse.c?ref=0fa2e4df4739bda990b1be0f8a0455ced48bc3b1", "patch": "@@ -195,7 +195,7 @@ dse_optimize_stmt (struct dom_walk_data *walk_data,\n       /* We want to verify that each virtual definition in STMT has\n \t precisely one use and that all the virtual definitions are\n \t used by the same single statement.  When complete, we\n-\t want USE_STMT to refer to the one statment which uses\n+\t want USE_STMT to refer to the one statement which uses\n \t all of the virtual definitions from STMT.  */\n       use_stmt = NULL;\n       FOR_EACH_SSA_MUST_AND_MAY_DEF_OPERAND (var1, var2, stmt, op_iter)"}, {"sha": "99dab7e40538b4b4a1527d166e4649d94db1c8ca", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fa2e4df4739bda990b1be0f8a0455ced48bc3b1/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fa2e4df4739bda990b1be0f8a0455ced48bc3b1/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=0fa2e4df4739bda990b1be0f8a0455ced48bc3b1", "patch": "@@ -129,7 +129,7 @@ struct mem_ref\n \t\t\t\t   table, but the hash function depends\n \t\t\t\t   on values of pointers. Thus we cannot use\n \t\t\t\t   htab_traverse, since then we would get\n-\t\t\t\t   misscompares during bootstrap (although the\n+\t\t\t\t   miscompares during bootstrap (although the\n \t\t\t\t   produced code would be correct).  */\n };\n \n@@ -627,7 +627,7 @@ determine_invariantness_stmt (struct dom_walk_data *dw_data ATTRIBUTE_UNUSED,\n \t  bsi_insert_after (&bsi, stmt2, BSI_NEW_STMT);\n \t  SSA_NAME_DEF_STMT (lhs) = stmt2;\n \n-\t  /* Continue processing with invariant reciprocal statment.  */\n+\t  /* Continue processing with invariant reciprocal statement.  */\n \t  stmt = stmt1;\n \t}\n "}, {"sha": "7962d62cedba2fbede7adeb59160f882ad0cfd25", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fa2e4df4739bda990b1be0f8a0455ced48bc3b1/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fa2e4df4739bda990b1be0f8a0455ced48bc3b1/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=0fa2e4df4739bda990b1be0f8a0455ced48bc3b1", "patch": "@@ -1886,7 +1886,7 @@ strip_offset_1 (tree expr, bool inside_addr, bool top_compref,\n     TREE_OPERAND (expr, 1) = op1;\n \n   /* Inside address, we might strip the top level component references,\n-     thus changing type of the expresion.  Handling of ADDR_EXPR\n+     thus changing type of the expression.  Handling of ADDR_EXPR\n      will fix that.  */\n   expr = fold_convert (orig_type, expr);\n "}, {"sha": "ef7c553cde01a171f79f08a65f811d357f7a73c0", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fa2e4df4739bda990b1be0f8a0455ced48bc3b1/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fa2e4df4739bda990b1be0f8a0455ced48bc3b1/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=0fa2e4df4739bda990b1be0f8a0455ced48bc3b1", "patch": "@@ -1759,7 +1759,7 @@ add_stmt_operand (tree *var_p, stmt_ann_t s_ann, int flags)\n \n   /* If the variable cannot be modified and this is a V_MAY_DEF change\n      it into a VUSE.  This happens when read-only variables are marked\n-     call-clobbered and/or aliased to writeable variables.  So we only\n+     call-clobbered and/or aliased to writable variables.  So we only\n      check that this only happens on non-specific stores.\n \n      Note that if this is a specific store, i.e. associated with a"}, {"sha": "9e7918bf0b7b58136dc88a63a58ad0f1b7558f88", "filename": "gcc/tree-vect-analyze.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fa2e4df4739bda990b1be0f8a0455ced48bc3b1/gcc%2Ftree-vect-analyze.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fa2e4df4739bda990b1be0f8a0455ced48bc3b1/gcc%2Ftree-vect-analyze.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-analyze.c?ref=0fa2e4df4739bda990b1be0f8a0455ced48bc3b1", "patch": "@@ -1246,7 +1246,7 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n /* Function vect_analyze_data_refs_alignment\n \n    Analyze the alignment of the data-references in the loop.\n-   FOR NOW: Until support for misliagned accesses is in place, only if all\n+   FOR NOW: Until support for misaligned accesses is in place, only if all\n    accesses are aligned can the loop be vectorized. This restriction will be \n    relaxed.  */ \n \n@@ -1908,7 +1908,7 @@ vect_object_analysis (tree memref, tree stmt, bool is_read,\n           foreach ref\n \t     base_address = vect_object_analysis(ref)\n       1.1- vect_object_analysis(ref): \n-           Analyze ref, and build a DR (data_referece struct) for it;\n+           Analyze ref, and build a DR (data_reference struct) for it;\n            compute base, initial_offset, step and alignment. \n            Call get_inner_reference for refs handled in this function.\n            Call vect_addr_analysis(addr) to analyze pointer type expressions."}, {"sha": "0079fc887af03698fad1d3909c623ce3b86617b4", "filename": "gcc/tree-vect-transform.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fa2e4df4739bda990b1be0f8a0455ced48bc3b1/gcc%2Ftree-vect-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fa2e4df4739bda990b1be0f8a0455ced48bc3b1/gcc%2Ftree-vect-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-transform.c?ref=0fa2e4df4739bda990b1be0f8a0455ced48bc3b1", "patch": "@@ -231,7 +231,7 @@ vect_create_addr_base_for_vector_ref (tree stmt,\n \n /* Function vect_align_data_ref.\n \n-   Handle mislignment of a memory accesses.\n+   Handle misalignment of a memory accesses.\n \n    FORNOW: Can't handle misaligned accesses. \n    Make sure that the dataref is aligned.  */"}, {"sha": "b6ab7238af4169cb5834aabcb33232b3b96eee6b", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fa2e4df4739bda990b1be0f8a0455ced48bc3b1/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fa2e4df4739bda990b1be0f8a0455ced48bc3b1/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=0fa2e4df4739bda990b1be0f8a0455ced48bc3b1", "patch": "@@ -987,7 +987,7 @@ slpeel_verify_cfg_after_peeling (struct loop *first_loop,\n   /* 1. Verify that one of the successors of first_loopt->exit is the preheader\n         of second_loop.  */\n    \n-  /* The preheader of new_loop is expected to have two predessors:\n+  /* The preheader of new_loop is expected to have two predecessors:\n      first_loop->exit and the block that precedes first_loop.  */\n \n   gcc_assert (EDGE_COUNT (loop2_entry_bb->preds) == 2 "}, {"sha": "133feb8988181791583ddba69f1600a0feeb992a", "filename": "gcc/tree.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fa2e4df4739bda990b1be0f8a0455ced48bc3b1/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fa2e4df4739bda990b1be0f8a0455ced48bc3b1/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=0fa2e4df4739bda990b1be0f8a0455ced48bc3b1", "patch": "@@ -6600,7 +6600,7 @@ walk_tree (tree *tp, walk_tree_fn func, void *data, struct pointer_set_t *pset)\n \tcase SSA_NAME:\n \tcase FIELD_DECL:\n \tcase RESULT_DECL:\n-\t  /* None of thse have subtrees other than those already walked\n+\t  /* None of these have subtrees other than those already walked\n \t     above.  */\n \t  break;\n "}]}