{"sha": "6675c41604f61f041d894413b2daabe177fa57a9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjY3NWM0MTYwNGY2MWYwNDFkODk0NDEzYjJkYWFiZTE3N2ZhNTdhOQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-09-20T21:00:07Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-09-20T21:00:07Z"}, "message": "Implement goto restrictions.\n\nFrom-SVN: r179018", "tree": {"sha": "ef020738a977887d068fec88173fa59aff82bb42", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ef020738a977887d068fec88173fa59aff82bb42"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6675c41604f61f041d894413b2daabe177fa57a9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6675c41604f61f041d894413b2daabe177fa57a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6675c41604f61f041d894413b2daabe177fa57a9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6675c41604f61f041d894413b2daabe177fa57a9/comments", "author": null, "committer": null, "parents": [{"sha": "b432106bc016fe9f794a71629274244b94d1dfe0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b432106bc016fe9f794a71629274244b94d1dfe0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b432106bc016fe9f794a71629274244b94d1dfe0"}], "stats": {"total": 343, "additions": 280, "deletions": 63}, "files": [{"sha": "9df9402fcf3e319f9b971f503020d42fb3520054", "filename": "gcc/go/gofrontend/gogo.cc", "status": "modified", "additions": 147, "deletions": 21, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6675c41604f61f041d894413b2daabe177fa57a9/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6675c41604f61f041d894413b2daabe177fa57a9/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc?ref=6675c41604f61f041d894413b2daabe177fa57a9", "patch": "@@ -857,19 +857,29 @@ Gogo::add_label_definition(const std::string& label_name,\n {\n   go_assert(!this->functions_.empty());\n   Function* func = this->functions_.back().function->func_value();\n-  Label* label = func->add_label_definition(label_name, location);\n+  Label* label = func->add_label_definition(this, label_name, location);\n   this->add_statement(Statement::make_label_statement(label, location));\n   return label;\n }\n \n // Add a label reference.\n \n Label*\n-Gogo::add_label_reference(const std::string& label_name)\n+Gogo::add_label_reference(const std::string& label_name,\n+\t\t\t  source_location location, bool issue_goto_errors)\n {\n   go_assert(!this->functions_.empty());\n   Function* func = this->functions_.back().function->func_value();\n-  return func->add_label_reference(label_name);\n+  return func->add_label_reference(this, label_name, location,\n+\t\t\t\t   issue_goto_errors);\n+}\n+\n+// Return the current binding state.\n+\n+Bindings_snapshot*\n+Gogo::bindings_snapshot(source_location location)\n+{\n+  return new Bindings_snapshot(this->current_block(), location);\n }\n \n // Add a statement.\n@@ -2843,30 +2853,24 @@ Function::is_method() const\n // Add a label definition.\n \n Label*\n-Function::add_label_definition(const std::string& label_name,\n+Function::add_label_definition(Gogo* gogo, const std::string& label_name,\n \t\t\t       source_location location)\n {\n   Label* lnull = NULL;\n   std::pair<Labels::iterator, bool> ins =\n     this->labels_.insert(std::make_pair(label_name, lnull));\n+  Label* label;\n   if (ins.second)\n     {\n       // This is a new label.\n-      Label* label = new Label(label_name);\n-      label->define(location);\n+      label = new Label(label_name);\n       ins.first->second = label;\n-      return label;\n     }\n   else\n     {\n       // The label was already in the hash table.\n-      Label* label = ins.first->second;\n-      if (!label->is_defined())\n-\t{\n-\t  label->define(location);\n-\t  return label;\n-\t}\n-      else\n+      label = ins.first->second;\n+      if (label->is_defined())\n \t{\n \t  error_at(location, \"label %qs already defined\",\n \t\t   Gogo::message_name(label_name).c_str());\n@@ -2875,31 +2879,55 @@ Function::add_label_definition(const std::string& label_name,\n \t  return new Label(label_name);\n \t}\n     }\n+\n+  label->define(location, gogo->bindings_snapshot(location));\n+\n+  // Issue any errors appropriate for any previous goto's to this\n+  // label.\n+  const std::vector<Bindings_snapshot*>& refs(label->refs());\n+  for (std::vector<Bindings_snapshot*>::const_iterator p = refs.begin();\n+       p != refs.end();\n+       ++p)\n+    (*p)->check_goto_to(gogo->current_block());\n+  label->clear_refs();\n+\n+  return label;\n }\n \n // Add a reference to a label.\n \n Label*\n-Function::add_label_reference(const std::string& label_name)\n+Function::add_label_reference(Gogo* gogo, const std::string& label_name,\n+\t\t\t      source_location location, bool issue_goto_errors)\n {\n   Label* lnull = NULL;\n   std::pair<Labels::iterator, bool> ins =\n     this->labels_.insert(std::make_pair(label_name, lnull));\n+  Label* label;\n   if (!ins.second)\n     {\n       // The label was already in the hash table.\n-      Label* label = ins.first->second;\n-      label->set_is_used();\n-      return label;\n+      label = ins.first->second;\n     }\n   else\n     {\n       go_assert(ins.first->second == NULL);\n-      Label* label = new Label(label_name);\n+      label = new Label(label_name);\n       ins.first->second = label;\n-      label->set_is_used();\n-      return label;\n     }\n+\n+  label->set_is_used();\n+\n+  if (issue_goto_errors)\n+    {\n+      Bindings_snapshot* snapshot = label->snapshot();\n+      if (snapshot != NULL)\n+\tsnapshot->check_goto_from(gogo->current_block(), location);\n+      else\n+\tlabel->add_snapshot_ref(gogo->bindings_snapshot(location));\n+    }\n+\n+  return label;\n }\n \n // Warn about labels that are defined but not used.\n@@ -3407,6 +3435,92 @@ Block::get_backend(Translate_context* context)\n   return ret;\n }\n \n+// Class Bindings_snapshot.\n+\n+Bindings_snapshot::Bindings_snapshot(const Block* b, source_location location)\n+  : block_(b), counts_(), location_(location)\n+{\n+  while (b != NULL)\n+    {\n+      this->counts_.push_back(b->bindings()->size_definitions());\n+      b = b->enclosing();\n+    }\n+}\n+\n+// Report errors appropriate for a goto from B to this.\n+\n+void\n+Bindings_snapshot::check_goto_from(const Block* b, source_location loc)\n+{\n+  size_t dummy;\n+  if (!this->check_goto_block(loc, b, this->block_, &dummy))\n+    return;\n+  this->check_goto_defs(loc, this->block_,\n+\t\t\tthis->block_->bindings()->size_definitions(),\n+\t\t\tthis->counts_[0]);\n+}\n+\n+// Report errors appropriate for a goto from this to B.\n+\n+void\n+Bindings_snapshot::check_goto_to(const Block* b)\n+{\n+  size_t index;\n+  if (!this->check_goto_block(this->location_, this->block_, b, &index))\n+    return;\n+  this->check_goto_defs(this->location_, b, this->counts_[index],\n+\t\t\tb->bindings()->size_definitions());\n+}\n+\n+// Report errors appropriate for a goto at LOC from BFROM to BTO.\n+// Return true if all is well, false if we reported an error.  If this\n+// returns true, it sets *PINDEX to the number of blocks BTO is above\n+// BFROM.\n+\n+bool\n+Bindings_snapshot::check_goto_block(source_location loc, const Block* bfrom,\n+\t\t\t\t    const Block* bto, size_t* pindex)\n+{\n+  // It is an error if BTO is not either BFROM or above BFROM.\n+  size_t index = 0;\n+  for (const Block* pb = bfrom; pb != bto; pb = pb->enclosing(), ++index)\n+    {\n+      if (pb == NULL)\n+\t{\n+\t  error_at(loc, \"goto jumps into block\");\n+\t  inform(bto->start_location(), \"goto target block starts here\");\n+\t  return false;\n+\t}\n+    }\n+  *pindex = index;\n+  return true;\n+}\n+\n+// Report errors appropriate for a goto at LOC ending at BLOCK, where\n+// CFROM is the number of names defined at the point of the goto and\n+// CTO is the number of names defined at the point of the label.\n+\n+void\n+Bindings_snapshot::check_goto_defs(source_location loc, const Block* block,\n+\t\t\t\t   size_t cfrom, size_t cto)\n+{\n+  if (cfrom < cto)\n+    {\n+      Bindings::const_definitions_iterator p =\n+\tblock->bindings()->begin_definitions();\n+      for (size_t i = 0; i < cfrom; ++i)\n+\t{\n+\t  go_assert(p != block->bindings()->end_definitions());\n+\t  ++p;\n+\t}\n+      go_assert(p != block->bindings()->end_definitions());\n+\n+      std::string n = (*p)->message_name();\n+      error_at(loc, \"goto jumps over declaration of %qs\", n.c_str());\n+      inform((*p)->location(), \"%qs defined here\", n.c_str());\n+    }\n+}\n+\n // Class Variable.\n \n Variable::Variable(Type* type, Expression* init, bool is_global,\n@@ -4698,6 +4812,18 @@ Bindings::traverse(Traverse* traverse, bool is_global)\n \n // Class Label.\n \n+// Clear any references to this label.\n+\n+void\n+Label::clear_refs()\n+{\n+  for (std::vector<Bindings_snapshot*>::iterator p = this->refs_.begin();\n+       p != this->refs_.end();\n+       ++p)\n+    delete *p;\n+  this->refs_.clear();\n+}\n+\n // Get the backend representation for a label.\n \n Blabel*"}, {"sha": "91e814c31d8c9b720f9c4f65441ad53c38cc2c2f", "filename": "gcc/go/gofrontend/gogo.h", "status": "modified", "additions": 87, "deletions": 12, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6675c41604f61f041d894413b2daabe177fa57a9/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6675c41604f61f041d894413b2daabe177fa57a9/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.h?ref=6675c41604f61f041d894413b2daabe177fa57a9", "patch": "@@ -22,6 +22,7 @@ class Temporary_statement;\n class Block;\n class Function;\n class Bindings;\n+class Bindings_snapshot;\n class Package;\n class Variable;\n class Pointer_type;\n@@ -246,6 +247,10 @@ class Gogo\n   Named_object*\n   current_function() const;\n \n+  // Return the current block.\n+  Block*\n+  current_block();\n+\n   // Start a new block.  This is not initially associated with a\n   // function.\n   void\n@@ -269,9 +274,16 @@ class Gogo\n   Label*\n   add_label_definition(const std::string&, source_location);\n \n-  // Add a label reference.\n+  // Add a label reference.  ISSUE_GOTO_ERRORS is true if we should\n+  // report errors for a goto from the current location to the label\n+  // location.\n   Label*\n-  add_label_reference(const std::string&);\n+  add_label_reference(const std::string&, source_location,\n+\t\t      bool issue_goto_errors);\n+\n+  // Return a snapshot of the current binding state.\n+  Bindings_snapshot*\n+  bindings_snapshot(source_location);\n \n   // Add a statement to the current block.\n   void\n@@ -551,10 +563,6 @@ class Gogo\n   const Bindings*\n   current_bindings() const;\n \n-  // Return the current block.\n-  Block*\n-  current_block();\n-\n   // Get the name of the magic initialization function.\n   const std::string&\n   get_init_fn_name();\n@@ -833,11 +841,14 @@ class Function\n \n   // Add a label definition to the function.\n   Label*\n-  add_label_definition(const std::string& label_name, source_location);\n+  add_label_definition(Gogo*, const std::string& label_name, source_location);\n \n-  // Add a label reference to a function.\n+  // Add a label reference to a function.  ISSUE_GOTO_ERRORS is true\n+  // if we should report errors for a goto from the current location\n+  // to the label location.\n   Label*\n-  add_label_reference(const std::string& label_name);\n+  add_label_reference(Gogo*, const std::string& label_name,\n+\t\t      source_location, bool issue_goto_errors);\n \n   // Warn about labels that are defined but not used.\n   void\n@@ -980,6 +991,40 @@ class Function\n   bool has_recover_thunk_;\n };\n \n+// A snapshot of the current binding state.\n+\n+class Bindings_snapshot\n+{\n+ public:\n+  Bindings_snapshot(const Block*, source_location);\n+\n+  // Report any errors appropriate for a goto from the current binding\n+  // state of B to this one.\n+  void\n+  check_goto_from(const Block* b, source_location);\n+\n+  // Report any errors appropriate for a goto from this binding state\n+  // to the current state of B.\n+  void\n+  check_goto_to(const Block* b);\n+\n+ private:\n+  bool\n+  check_goto_block(source_location, const Block*, const Block*, size_t*);\n+\n+  void\n+  check_goto_defs(source_location, const Block*, size_t, size_t);\n+\n+  // The current block.\n+  const Block* block_;\n+  // The number of names currently defined in each open block.\n+  // Element 0 is this->block_, element 1 is\n+  // this->block_->enclosing(), etc.\n+  std::vector<size_t> counts_;\n+  // The location where this snapshot was taken.\n+  source_location location_;\n+};\n+\n // A function declaration.\n \n class Function_declaration\n@@ -2108,7 +2153,8 @@ class Label\n {\n  public:\n   Label(const std::string& name)\n-    : name_(name), location_(0), is_used_(false), blabel_(NULL)\n+    : name_(name), location_(0), snapshot_(NULL), refs_(), is_used_(false),\n+      blabel_(NULL)\n   { }\n \n   // Return the label's name.\n@@ -2136,12 +2182,36 @@ class Label\n   location() const\n   { return this->location_; }\n \n-  // Define the label at LOCATION.\n+  // Return the bindings snapshot.\n+  Bindings_snapshot*\n+  snapshot() const\n+  { return this->snapshot_; }\n+\n+  // Add a snapshot of a goto which refers to this label.\n   void\n-  define(source_location location)\n+  add_snapshot_ref(Bindings_snapshot* snapshot)\n   {\n     go_assert(this->location_ == 0);\n+    this->refs_.push_back(snapshot);\n+  }\n+\n+  // Return the list of snapshots of goto statements which refer to\n+  // this label.\n+  const std::vector<Bindings_snapshot*>&\n+  refs() const\n+  { return this->refs_; }\n+\n+  // Clear the references.\n+  void\n+  clear_refs();\n+\n+  // Define the label at LOCATION with the given bindings snapshot.\n+  void\n+  define(source_location location, Bindings_snapshot* snapshot)\n+  {\n+    go_assert(this->location_ == 0 && this->snapshot_ == NULL);\n     this->location_ = location;\n+    this->snapshot_ = snapshot;\n   }\n \n   // Return the backend representation for this label.\n@@ -2160,6 +2230,11 @@ class Label\n   // The location of the definition.  This is 0 if the label has not\n   // yet been defined.\n   source_location location_;\n+  // A snapshot of the set of bindings defined at this label, used to\n+  // issue errors about invalid goto statements.\n+  Bindings_snapshot* snapshot_;\n+  // A list of snapshots of goto statements which refer to this label.\n+  std::vector<Bindings_snapshot*> refs_;\n   // Whether the label has been used.\n   bool is_used_;\n   // The backend representation."}, {"sha": "2b651396b036c04ae6457901214327bac5446563", "filename": "gcc/go/gofrontend/parse.cc", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6675c41604f61f041d894413b2daabe177fa57a9/gcc%2Fgo%2Fgofrontend%2Fparse.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6675c41604f61f041d894413b2daabe177fa57a9/gcc%2Fgo%2Fgofrontend%2Fparse.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fparse.cc?ref=6675c41604f61f041d894413b2daabe177fa57a9", "patch": "@@ -3813,7 +3813,8 @@ Parse::return_stat()\n   this->gogo_->add_statement(Statement::make_return_statement(vals, location));\n }\n \n-// IfStmt    = \"if\" [ SimpleStmt \";\" ] Expression Block [ \"else\" Statement ] .\n+// IfStmt = \"if\" [ SimpleStmt \";\" ] Expression Block\n+//          [ \"else\" ( IfStmt | Block ) ] .\n \n void\n Parse::if_stat()\n@@ -3883,10 +3884,17 @@ Parse::if_stat()\n   Block* else_block = NULL;\n   if (this->peek_token()->is_keyword(KEYWORD_ELSE))\n     {\n-      this->advance_token();\n-      // We create a block to gather the statement.\n       this->gogo_->start_block(this->location());\n-      this->statement(NULL);\n+      const Token* token = this->advance_token();\n+      if (token->is_keyword(KEYWORD_IF))\n+\tthis->if_stat();\n+      else if (token->is_op(OPERATOR_LCURLY))\n+\tthis->block();\n+      else\n+\t{\n+\t  error_at(this->location(), \"expected %<if%> or %<{%>\");\n+\t  this->statement(NULL);\n+\t}\n       else_block = this->gogo_->finish_block(this->location());\n     }\n \n@@ -4914,7 +4922,7 @@ Parse::break_stat()\n \t{\n \t  // If there is a label with this name, mark it as used to\n \t  // avoid a useless error about an unused label.\n-\t  this->gogo_->add_label_reference(token->identifier());\n+\t  this->gogo_->add_label_reference(token->identifier(), 0, false);\n \n \t  error_at(token->location(), \"invalid break label %qs\",\n \t\t   Gogo::message_name(token->identifier()).c_str());\n@@ -4969,7 +4977,7 @@ Parse::continue_stat()\n \t{\n \t  // If there is a label with this name, mark it as used to\n \t  // avoid a useless error about an unused label.\n-\t  this->gogo_->add_label_reference(token->identifier());\n+\t  this->gogo_->add_label_reference(token->identifier(), 0, false);\n \n \t  error_at(token->location(), \"invalid continue label %qs\",\n \t\t   Gogo::message_name(token->identifier()).c_str());\n@@ -5003,7 +5011,8 @@ Parse::goto_stat()\n     error_at(this->location(), \"expected label for goto\");\n   else\n     {\n-      Label* label = this->gogo_->add_label_reference(token->identifier());\n+      Label* label = this->gogo_->add_label_reference(token->identifier(),\n+\t\t\t\t\t\t      location, true);\n       Statement* s = Statement::make_goto_statement(label, location);\n       this->gogo_->add_statement(s);\n       this->advance_token();"}, {"sha": "deb5d52f37fb366722006521f79210b38b668b3d", "filename": "gcc/go/gofrontend/statements.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6675c41604f61f041d894413b2daabe177fa57a9/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6675c41604f61f041d894413b2daabe177fa57a9/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.cc?ref=6675c41604f61f041d894413b2daabe177fa57a9", "patch": "@@ -2291,7 +2291,7 @@ Thunk_statement::build_thunk(Gogo* gogo, const std::string& thunk_name)\n   Label* retaddr_label = NULL;\n   if (may_call_recover)\n     {\n-      retaddr_label = gogo->add_label_reference(\"retaddr\");\n+      retaddr_label = gogo->add_label_reference(\"retaddr\", location, false);\n       Expression* arg = Expression::make_label_addr(retaddr_label, location);\n       Expression* call = Runtime::make_call(Runtime::SET_DEFER_RETADDR,\n \t\t\t\t\t    location, 1, arg);"}, {"sha": "441c57a4855dc56fd41d013247c69c3f002545e6", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug140.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6675c41604f61f041d894413b2daabe177fa57a9/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug140.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6675c41604f61f041d894413b2daabe177fa57a9/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug140.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug140.go?ref=6675c41604f61f041d894413b2daabe177fa57a9", "patch": "@@ -10,14 +10,14 @@ func main() {\n \tif true {\n \t} else {\n \tL1:\n+\t\tgoto L1\n \t}\n \tif true {\n \t} else {\n+\t\tgoto L2\n \tL2:\n \t\tmain()\n \t}\n-\tgoto L1\n-\tgoto L2\n }\n \n /*"}, {"sha": "a7ff09daeed3ec8d2285b501f3acb83c121aa999", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug178.go", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6675c41604f61f041d894413b2daabe177fa57a9/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug178.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6675c41604f61f041d894413b2daabe177fa57a9/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug178.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug178.go?ref=6675c41604f61f041d894413b2daabe177fa57a9", "patch": "@@ -14,6 +14,9 @@ L:\n \t\t\tbreak L\n \t\t}\n \t\tpanic(\"BUG: not reached - break\")\n+\t\tif false {\n+\t\t\tgoto L1\n+\t\t}\n \t}\n \n L2:\n@@ -23,11 +26,8 @@ L2:\n \t\t\tcontinue L2\n \t\t}\n \t\tpanic(\"BUG: not reached - continue\")\n-\t}\n-\tif false {\n-\t\tgoto L1\n-\t}\n-\tif false {\n-\t\tgoto L3\n+\t\tif false {\n+\t\t\tgoto L3\n+\t\t}\n \t}\n }"}, {"sha": "18a6715d7eb979bba97baf24585ea895d01d438c", "filename": "gcc/testsuite/go.test/test/if.go", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6675c41604f61f041d894413b2daabe177fa57a9/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fif.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6675c41604f61f041d894413b2daabe177fa57a9/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fif.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fif.go?ref=6675c41604f61f041d894413b2daabe177fa57a9", "patch": "@@ -53,25 +53,28 @@ func main() {\n \tcount = 0\n \tif true {\n \t\tcount = count + 1\n-\t} else\n+\t} else {\n \t\tcount = count - 1\n+\t}\n \tassertequal(count, 1, \"if else true\")\n \n \tcount = 0\n \tif false {\n \t\tcount = count + 1\n-\t} else\n+\t} else {\n \t\tcount = count - 1\n+\t}\n \tassertequal(count, -1, \"if else false\")\n \n \tcount = 0\n-\tif t:=1; false {\n+\tif t := 1; false {\n \t\tcount = count + 1\n \t\t_ = t\n \t\tt := 7\n \t\t_ = t\n-\t} else\n+\t} else {\n \t\tcount = count - t\n+\t}\n \tassertequal(count, -1, \"if else false var\")\n \n \tcount = 0\n@@ -80,8 +83,9 @@ func main() {\n \t\tcount = count + 1\n \t\tt := 7\n \t\t_ = t\n-\t} else\n+\t} else {\n \t\tcount = count - t\n+\t}\n \t_ = t\n \tassertequal(count, -1, \"if else false var outside\")\n }"}, {"sha": "8ad45f9aea58be960932f0b22b12c9a5185062f8", "filename": "libgo/syscalls/exec.go", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6675c41604f61f041d894413b2daabe177fa57a9/libgo%2Fsyscalls%2Fexec.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6675c41604f61f041d894413b2daabe177fa57a9/libgo%2Fsyscalls%2Fexec.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fsyscalls%2Fexec.go?ref=6675c41604f61f041d894413b2daabe177fa57a9", "patch": "@@ -231,6 +231,7 @@ var zeroSysProcAttr SysProcAttr\n \n func forkExec(argv0 string, argv []string, attr *ProcAttr) (pid int, err int) {\n \tvar p [2]int\n+\tvar n Ssize_t\n \tvar r1 int\n \tvar err1 uintptr\n \tvar wstatus WaitStatus\n@@ -283,20 +284,14 @@ func forkExec(argv0 string, argv []string, attr *ProcAttr) (pid int, err int) {\n \t// Kick off child.\n \tpid, err = forkAndExecInChild(argv0p, argvp, envvp, chroot, dir, attr, sys, p[1])\n \tif err != 0 {\n-\terror:\n-\t\tif p[0] >= 0 {\n-\t\t\tClose(p[0])\n-\t\t\tClose(p[1])\n-\t\t}\n-\t\tForkLock.Unlock()\n-\t\treturn 0, err\n+\t\tgoto error\n \t}\n \tForkLock.Unlock()\n \n \t// Read child error status from pipe.\n \tClose(p[1])\n-\tn := libc_read(p[0], (*byte)(unsafe.Pointer(&err1)),\n-\t\t       Size_t(unsafe.Sizeof(err1)))\n+\tn = libc_read(p[0], (*byte)(unsafe.Pointer(&err1)),\n+\t\t      Size_t(unsafe.Sizeof(err1)))\n \terr = 0\n \tif n < 0 {\n \t\terr = GetErrno()\n@@ -321,6 +316,14 @@ func forkExec(argv0 string, argv []string, attr *ProcAttr) (pid int, err int) {\n \n \t// Read got EOF, so pipe closed on exec, so exec succeeded.\n \treturn pid, 0\n+\n+error:\n+\tif p[0] >= 0 {\n+\t\tClose(p[0])\n+\t\tClose(p[1])\n+\t}\n+\tForkLock.Unlock()\n+\treturn 0, err\n }\n \n // Combination of fork and exec, careful to be thread safe."}]}