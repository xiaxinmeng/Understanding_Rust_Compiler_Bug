{"sha": "9139939530cd3a91f22d4b9b9551f56ebe4ca39b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTEzOTkzOTUzMGNkM2E5MWYyMmQ0YjliOTU1MWY1NmViZTRjYTM5Yg==", "commit": {"author": {"name": "Neil Booth", "email": "neilb@earthling.net", "date": "2000-07-15T02:56:01Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2000-07-15T02:56:01Z"}, "message": "* README.Portability: New file.\n\nFrom-SVN: r35039", "tree": {"sha": "65b2f5fe89915a36b0f4ab7637d521a1ca87bb88", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/65b2f5fe89915a36b0f4ab7637d521a1ca87bb88"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9139939530cd3a91f22d4b9b9551f56ebe4ca39b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9139939530cd3a91f22d4b9b9551f56ebe4ca39b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9139939530cd3a91f22d4b9b9551f56ebe4ca39b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9139939530cd3a91f22d4b9b9551f56ebe4ca39b/comments", "author": null, "committer": null, "parents": [{"sha": "245aefecd380b5793e97ff2fa605011152851ad7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/245aefecd380b5793e97ff2fa605011152851ad7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/245aefecd380b5793e97ff2fa605011152851ad7"}], "stats": {"total": 373, "additions": 373, "deletions": 0}, "files": [{"sha": "3fca30e3616f87a4c3a6eeeed1ae95fe49cf2719", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9139939530cd3a91f22d4b9b9551f56ebe4ca39b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9139939530cd3a91f22d4b9b9551f56ebe4ca39b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9139939530cd3a91f22d4b9b9551f56ebe4ca39b", "patch": "@@ -1,3 +1,7 @@\n+2000-07-15  Neil Booth  <NeilB@earthling.net>\n+\n+\t* README.Portability: New file.\n+\n Fri Jul 14 18:13:53 2000  Mark P Mitchell  <mark@codesourcery.com>\n \n \t* INSTALL: Give special instructions for building GCC on Irix 6."}, {"sha": "1c2df58edadd18e0b5f41124fd938734c35fadf5", "filename": "gcc/README.Portability", "status": "added", "additions": 369, "deletions": 0, "changes": 369, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9139939530cd3a91f22d4b9b9551f56ebe4ca39b/gcc%2FREADME.Portability", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9139939530cd3a91f22d4b9b9551f56ebe4ca39b/gcc%2FREADME.Portability", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FREADME.Portability?ref=9139939530cd3a91f22d4b9b9551f56ebe4ca39b", "patch": "@@ -0,0 +1,369 @@\n+Copyright (C) 2000 Free Software Foundation, Inc.\n+\n+This file is intended to contain a few notes about writing C code\n+within GCC so that it compiles without error on the full range of\n+compilers GCC needs to be able to compile on.\n+\n+The problem is that many ISO-standard constructs are not accepted by\n+either old or buggy compilers, and we keep getting bitten by them.\n+This knowledge until know has been sparsely spread around, so I\n+thought I'd collect it in one useful place.  Please add and correct\n+any problems as you come across them.\n+\n+I'm going to start from a base of the ISO C89 standard, since that is\n+probably what most people code to naturally.  Obviously using\n+constructs introduced after that is not a good idea.\n+\n+The first section of this file deals strictly with portability issues,\n+the second with common coding pitfalls.\n+\n+\n+\t\t\tPortability Issues\n+\t\t\t==================\n+\n+Unary +\n+-------\n+\n+K+R C compilers and preprocessors have no notion of unary '+'.  Thus\n+the following code snippet contains 2 portability problems.\n+\n+int x = +2;  /* int x = 2;  */\n+#if +1       /* #if 1  */\n+#endif\n+\n+\n+Pointers to void\n+----------------\n+\n+K+R C compilers did not have a void pointer, and used char * as the\n+pointer to anything.  The macro PTR is defined as either void * or\n+char * depending on whether you have a standards compliant compiler or\n+a K+R one.  Thus\n+\n+  free ((void *) h->value.expansion);\n+\n+should be written\n+\n+  free ((PTR) h->value.expansion);\n+\n+\n+String literals\n+---------------\n+\n+K+R C did not allow concatenation of string literals like\n+\n+  \"This is a \" \"single string literal\".\n+\n+Moreover, some compilers like MSVC++ have fairly low limits on the\n+maximum length of a string literal; 509 is the lowest we've come\n+across.  You may need to break up a long printf statement into many\n+smaller ones.\n+\n+\n+Empty macro arguments\n+---------------------\n+\n+ISO C (6.8.3 in the 1990 standard) specifies the following:\n+\n+If (before argument substitution) any argument consists of no\n+preprocessing tokens, the behavior is undefined.\n+\n+This was relaxed by ISO C99, but some older compilers emit an error,\n+so code like\n+\n+#define foo(x, y) x y\n+foo (bar, )\n+\n+needs to be coded in some other way.\n+\n+\n+signed keyword\n+--------------\n+\n+The signed keyword did not exist in K+R comilers, it was introduced in\n+ISO C89, so you cannot use it.  In both K+R and standard C,\n+unqualified char and bitfields may be signed or unsigned.  There is no\n+way to portably declare signed chars or signed bitfields.\n+\n+All other arithmetic types are signed unless you use the 'unsigned'\n+qualifier.  For instance, it is safe to write\n+\n+  short paramc;\n+\n+instead of\n+\n+  signed short paramc;\n+\n+If you have an algorithm that depends on signed char or signed\n+bitfields, you must find another way to write it before it can be\n+integrated into GCC.\n+\n+\n+Function prototypes\n+-------------------\n+\n+You need to provide a function prototype for every function before you\n+use it, and functions must be defined K+R style.  The function\n+prototype should use the PARAMS macro, which takes a single argument.\n+Therefore the parameter list must be enclosed in parentheses.  For\n+example,\n+\n+int myfunc PARAMS ((double, int *));\n+\n+int\n+myfunc (var1, var2)\n+\tdouble var1;\n+\tint *var2;\n+{\n+  ...\n+}\n+\n+You also need to use PARAMS when referring to function protypes in\n+other circumstances, for example see \"Calling functions through\n+pointers to functions\" below.\n+\n+Variable-argument functions are best described by example:-\n+\n+void cpp_ice PARAMS ((cpp_reader *, const char *msgid, ...));\n+\n+void\n+cpp_ice VPARAMS ((cpp_reader *pfile, const char *msgid, ...))\n+{  \n+#ifndef ANSI_PROTOTYPES\n+  cpp_reader *pfile;\n+  const char *msgid;\n+#endif\n+  va_list ap;\n+  \n+  VA_START (ap, msgid);\n+  \n+#ifndef ANSI_PROTOTYPES\n+  pfile = va_arg (ap, cpp_reader *);\n+  msgid = va_arg (ap, const char *);\n+#endif\n+\n+  ...\n+  va_end (ap);\n+}\n+\n+For the curious, here are the definitions of the above macros.  See\n+ansidecl.h for the definitions of the above macros and more.\n+\n+#define PARAMS(paramlist)  paramlist  /* ISO C.  */\n+#define VPARAMS(args)   args\n+\n+#define PARAMS(paramlist)  ()         /* K+R C.  */\n+#define VPARAMS(args)   (va_alist) va_dcl\n+\n+\n+Calling functions through pointers to functions\n+-----------------------------------------------\n+\n+K+R C compilers require brackets around the dereferenced pointer\n+variable.  For example\n+\n+typedef void (* cl_directive_handler) PARAMS ((cpp_reader *, const char *));\n+      p->handler (pfile, p->arg);\n+\n+needs to become\n+\n+      (p->handler) (pfile, p->arg);\n+\n+\n+Macros\n+------\n+\n+The rules under K+R C and ISO C for achieving stringification and\n+token pasting are quite different.  Therefore some macros have been\n+defined which will get it right depending upon the compiler.\n+\n+  CONCAT2(a,b) CONCAT3(a,b,c) and CONCAT4(a,b,c,d)\n+\n+will paste the tokens passed as arguments.  You must not leave any\n+space around the commas.  Also,\n+\n+  STRINGX(x)\n+\n+will stringify an argument; to get the same result on K+R and ISO\n+compilers x should not have spaces around it.\n+\n+\n+Enums\n+-----\n+\n+In K+R C, you have to cast enum types to use them as integers, and\n+some compilers in particular give lots of warnings for using an enum\n+as an array index.\n+\n+Bitfields\n+---------\n+\n+See also \"signed keyword\" above.  In K+R C only unsigned int bitfields\n+were defined (i.e. unsigned char, unsigned short, unsigned long.\n+Using plain int/short/long was not allowed).\n+\n+\n+free and realloc\n+----------------\n+\n+Some implementations crash upon attempts to free or realloc the null\n+pointer.  Thus if mem might be null, you need to write\n+\n+  if (mem)\n+    free (mem);\n+\n+\n+Reserved Keywords\n+-----------------\n+\n+K+R C has \"entry\" as a reserved keyword, so you should not use it for\n+your variable names.\n+\n+\n+Type promotions\n+---------------\n+\n+K+R used unsigned-preserving rules for arithmetic expresssions, while\n+ISO uses value-preserving.  This means an unsigned char compared to an\n+int is done as an unsigned comparison in K+R (since unsigned char\n+promotes to unsigned) while it is signed in ISO (since all of the\n+values in unsigned char fit in an int, it promotes to int).\n+\n+** Not having any argument whose type is a short type (char, short,\n+float of any flavor) and subject to promotion. **\n+\n+Trigraphs\n+---------\n+\n+You weren't going to use them anyway, but trigraphs were not defined\n+in K+R C, and some otherwise ISO C compliant compilers do not accept\n+them.\n+\n+\n+Suffixes on Integer Constants\n+-----------------------------\n+\n+**Using a 'u' suffix on integer constants.**\n+\n+\n+errno\n+-----\n+\n+errno might be declared as a macro.\n+\n+\n+\t\t\tCommon Coding Pitfalls\n+\t\t\t======================\n+Implicit int\n+------------\n+\n+In C, the 'int' keyword can often be omitted from type declarations.\n+For instance, you can write\n+\n+  unsigned variable;\n+\n+as shorthand for\n+\n+  unsigned int variable;\n+\n+There are several places where this can cause trouble.  First, suppose\n+'variable' is a long; then you might think\n+\n+  (unsigned) variable\n+\n+would convert it to unsigned long.  It does not.  It converts to\n+unsigned int.  This mostly causes problems on 64-bit platforms, where\n+long and int are not the same size.\n+\n+Second, if you write a function definition with no return type at\n+all:\n+\n+  operate(a, b)\n+      int a, b;\n+  {\n+    ...\n+  }\n+\n+that function is expected to return int, *not* void.  GCC will warn\n+about this.  K+R C has no problem with 'void' as a return type, so you\n+need not worry about that.\n+\n+Implicit function declarations always have return type int.  So if you\n+correct the above definition to\n+\n+  void\n+  operate(a, b)\n+      int a, b;\n+  ...\n+\n+but operate() is called above its definition, you will get an error\n+about a \"type mismatch with previous implicit declaration\".  The cure\n+is to prototype all functions at the top of the file, or in an\n+appropriate header.\n+\n+Char vs unsigned char vs int\n+----------------------------\n+\n+In C, unqualified 'char' may be either signed or unsigned; it is the\n+implementation's choice.  When you are processing 7-bit ASCII, it does\n+not matter.  But when your program must handle arbitrary binary data,\n+or fully 8-bit character sets, you have a problem.  The most obvious\n+issue is if you have a look-up table indexed by characters.\n+\n+For instance, the character '\\341' in ISO Latin 1 is SMALL LETTER A\n+WITH ACUTE ACCENT.  In the proper locale, isalpha('\\341') will be\n+true.  But if you read '\\341' from a file and store it in a plain\n+char, isalpha(c) may look up character 225, or it may look up\n+character -31.  And the ctype table has no entry at offset -31, so\n+your program will crash.  (If you're lucky.)\n+\n+It is wise to use unsigned char everywhere you possibly can.  This\n+avoids all these problems.  Unfortunately, the routines in <string.h>\n+take plain char arguments, so you have to remember to cast them back\n+and forth - or avoid the use of strxxx() functions, which is probably\n+a good idea anyway.\n+\n+Another common mistake is to use either char or unsigned char to\n+receive the result of getc() or related stdio functions.  They may\n+return EOF, which is outside the range of values representable by\n+char.  If you use char, some legal character value may be confused\n+with EOF, such as '\\377' (SMALL LETTER Y WITH UMLAUT, in Latin-1).\n+The correct choice is int.\n+\n+A more subtle version of the same mistake might look like this:\n+\n+  unsigned char pushback[NPUSHBACK];\n+  int pbidx;\n+  #define unget(c) (assert(pbidx < NPUSHBACK), pushback[pbidx++] = (c))\n+  #define get(c) (pbidx ? pushback[--pbidx] : getchar())\n+  ...\n+  unget(EOF);\n+\n+which will mysteriously turn a pushed-back EOF into a SMALL LETTER Y\n+WITH UMLAUT.\n+\n+\n+Other common pitfalls\n+---------------------\n+\n+o Expecting 'plain' char to be either sign or unsigned extending\n+\n+o Shifting an item by a negative amount or by greater than or equal to\n+  the number of bits in a type (expecting shifts by 32 to be sensible\n+  has caused quite a number of bugs at least in the early days).\n+\n+o Expecting ints shifted right to be sign extended.\n+\n+o Modifying the same value twice within one sequence point.\n+\n+o Host vs. target floating point representation, including emitting NaNs\n+  and Infinities in a form that the assembler handles.\n+\n+o qsort being an unstable sort function (unstable in the sense that\n+  multiple items that sort the same may be sorted in different orders\n+  by different qsort functions).\n+\n+o Passing incorrect types to fprintf and friends.\n+\n+o Adding a function declaration for a module declared in another file to\n+  a .c file instead of to a .h file."}]}