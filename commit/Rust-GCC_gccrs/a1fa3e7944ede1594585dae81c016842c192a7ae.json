{"sha": "a1fa3e7944ede1594585dae81c016842c192a7ae", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTFmYTNlNzk0NGVkZTE1OTQ1ODVkYWU4MWMwMTY4NDJjMTkyYTdhZQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2009-04-27T10:42:09Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2009-04-27T10:42:09Z"}, "message": "resource.c (find_basic_block): Use BLOCK_FOR_INSN to look up a label's basic block.\n\n\t* resource.c (find_basic_block): Use BLOCK_FOR_INSN to look up\n\ta label's basic block.\n\t(mark_target_live_regs): Tidy and rework obsolete comments.\n\tChange back DF problem to LIVE.  If a label starts a basic block,\n\tassume that all registers that used to be live then still are.\n\t(init_resource_info): If a label starts a basic block, set its\n\tBLOCK_FOR_INSN accordingly.\n\t(fini_resource_info): Undo the setting of BLOCK_FOR_INSN.\n\nFrom-SVN: r146829", "tree": {"sha": "7d4ab3be617c0759c6adda3d36ab588a7050f425", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7d4ab3be617c0759c6adda3d36ab588a7050f425"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a1fa3e7944ede1594585dae81c016842c192a7ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1fa3e7944ede1594585dae81c016842c192a7ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a1fa3e7944ede1594585dae81c016842c192a7ae", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1fa3e7944ede1594585dae81c016842c192a7ae/comments", "author": null, "committer": null, "parents": [{"sha": "33b223c0a6fccd7dc07d0181f32a85d9a2d5705b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33b223c0a6fccd7dc07d0181f32a85d9a2d5705b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/33b223c0a6fccd7dc07d0181f32a85d9a2d5705b"}], "stats": {"total": 102, "additions": 83, "deletions": 19}, "files": [{"sha": "e39039a5dd655f1605dde237ec8c8e36495a29c9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1fa3e7944ede1594585dae81c016842c192a7ae/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1fa3e7944ede1594585dae81c016842c192a7ae/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a1fa3e7944ede1594585dae81c016842c192a7ae", "patch": "@@ -1,3 +1,15 @@\n+2009-04-27  Richard Sandiford  <rdsandiford@googlemail.com>\n+            Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* resource.c (find_basic_block): Use BLOCK_FOR_INSN to look up\n+\ta label's basic block.\n+\t(mark_target_live_regs): Tidy and rework obsolete comments.\n+\tChange back DF problem to LIVE.  If a label starts a basic block,\n+\tassume that all registers that used to be live then still are.\n+\t(init_resource_info): If a label starts a basic block, set its\n+\tBLOCK_FOR_INSN accordingly.\n+\t(fini_resource_info): Undo the setting of BLOCK_FOR_INSN.\n+\n 2009-04-27  Richard Guenther  <rguenther@suse.de>\n \n \t* tree-flow-inline.h (function_ann): Remove."}, {"sha": "91b86c9573beb33275796234d012c9baa4af441f", "filename": "gcc/resource.c", "status": "modified", "additions": 36, "deletions": 19, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1fa3e7944ede1594585dae81c016842c192a7ae/gcc%2Fresource.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1fa3e7944ede1594585dae81c016842c192a7ae/gcc%2Fresource.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fresource.c?ref=a1fa3e7944ede1594585dae81c016842c192a7ae", "patch": "@@ -135,8 +135,6 @@ update_live_status (rtx dest, const_rtx x, void *data ATTRIBUTE_UNUSED)\n static int\n find_basic_block (rtx insn, int search_limit)\n {\n-  basic_block bb;\n-\n   /* Scan backwards to the previous BARRIER.  Then see if we can find a\n      label that starts a basic block.  Return the basic block number.  */\n   for (insn = prev_nonnote_insn (insn);\n@@ -157,11 +155,8 @@ find_basic_block (rtx insn, int search_limit)\n   for (insn = next_nonnote_insn (insn);\n        insn && LABEL_P (insn);\n        insn = next_nonnote_insn (insn))\n-    {\n-      FOR_EACH_BB (bb)\n-\tif (insn == BB_HEAD (bb))\n-\t  return bb->index;\n-    }\n+    if (BLOCK_FOR_INSN (insn))\n+      return BLOCK_FOR_INSN (insn)->index;\n \n   return -1;\n }\n@@ -848,13 +843,12 @@ return_insn_p (const_rtx insn)\n    (with no intervening active insns) to see if any of them start a basic\n    block.  If we hit the start of the function first, we use block 0.\n \n-   Once we have found a basic block and a corresponding first insns, we can\n-   accurately compute the live status from basic_block_live_regs and\n-   reg_renumber.  (By starting at a label following a BARRIER, we are immune\n-   to actions taken by reload and jump.)  Then we scan all insns between\n-   that point and our target.  For each CLOBBER (or for call-clobbered regs\n-   when we pass a CALL_INSN), mark the appropriate registers are dead.  For\n-   a SET, mark them as live.\n+   Once we have found a basic block and a corresponding first insn, we can\n+   accurately compute the live status (by starting at a label following a\n+   BARRIER, we are immune to actions taken by reload and jump.)  Then we\n+   scan all insns between that point and our target.  For each CLOBBER (or\n+   for call-clobbered regs when we pass a CALL_INSN), mark the appropriate\n+   registers are dead.  For a SET, mark them as live.\n \n    We have to be careful when using REG_DEAD notes because they are not\n    updated by such things as find_equiv_reg.  So keep track of registers\n@@ -954,13 +948,10 @@ mark_target_live_regs (rtx insns, rtx target, struct resources *res)\n      TARGET.  Otherwise, we must assume everything is live.  */\n   if (b != -1)\n     {\n-      regset regs_live = DF_LR_IN (BASIC_BLOCK (b));\n+      regset regs_live = df_get_live_in (BASIC_BLOCK (b));\n       rtx start_insn, stop_insn;\n \n-      /* Compute hard regs live at start of block -- this is the real hard regs\n-\t marked live, plus live pseudo regs that have been renumbered to\n-\t hard regs.  */\n-\n+      /* Compute hard regs live at start of block.  */\n       REG_SET_TO_HARD_REG_SET (current_live_regs, regs_live);\n \n       /* Get starting and ending insn, handling the case where each might\n@@ -1046,10 +1037,24 @@ mark_target_live_regs (rtx insns, rtx target, struct resources *res)\n \n \t  else if (LABEL_P (real_insn))\n \t    {\n+\t      basic_block bb;\n+\n \t      /* A label clobbers the pending dead registers since neither\n \t\t reload nor jump will propagate a value across a label.  */\n \t      AND_COMPL_HARD_REG_SET (current_live_regs, pending_dead_regs);\n \t      CLEAR_HARD_REG_SET (pending_dead_regs);\n+\n+\t      /* We must conservatively assume that all registers that used\n+\t\t to be live here still are.  The fallthrough edge may have\n+\t\t left a live register uninitialized.  */\n+\t      bb = BLOCK_FOR_INSN (real_insn);\n+\t      if (bb)\n+\t\t{\n+\t\t  HARD_REG_SET extra_live;\n+\n+\t\t  REG_SET_TO_HARD_REG_SET (extra_live, df_get_live_in (bb));\n+\t\t  IOR_HARD_REG_SET (current_live_regs, extra_live);\n+\t\t}\n \t    }\n \n \t  /* The beginning of the epilogue corresponds to the end of the\n@@ -1121,6 +1126,7 @@ void\n init_resource_info (rtx epilogue_insn)\n {\n   int i;\n+  basic_block bb;\n \n   /* Indicate what resources are required to be valid at the end of the current\n      function.  The condition code never is and memory always is.  If the\n@@ -1189,6 +1195,11 @@ init_resource_info (rtx epilogue_insn)\n   /* Allocate and initialize the tables used by mark_target_live_regs.  */\n   target_hash_table = XCNEWVEC (struct target_info *, TARGET_HASH_PRIME);\n   bb_ticks = XCNEWVEC (int, last_basic_block);\n+\n+  /* Set the BLOCK_FOR_INSN of each label that starts a basic block.  */\n+  FOR_EACH_BB (bb)\n+    if (LABEL_P (BB_HEAD (bb)))\n+      BLOCK_FOR_INSN (BB_HEAD (bb)) = bb;\n }\n \f\n /* Free up the resources allocated to mark_target_live_regs ().  This\n@@ -1197,6 +1208,8 @@ init_resource_info (rtx epilogue_insn)\n void\n free_resource_info (void)\n {\n+  basic_block bb;\n+\n   if (target_hash_table != NULL)\n     {\n       int i;\n@@ -1222,6 +1235,10 @@ free_resource_info (void)\n       free (bb_ticks);\n       bb_ticks = NULL;\n     }\n+\n+  FOR_EACH_BB (bb)\n+    if (LABEL_P (BB_HEAD (bb)))\n+      BLOCK_FOR_INSN (BB_HEAD (bb)) = NULL;\n }\n \f\n /* Clear any hashed information that we have stored for INSN.  */"}, {"sha": "d959bb48eedd339215850cc0ef4d2b177d039430", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1fa3e7944ede1594585dae81c016842c192a7ae/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1fa3e7944ede1594585dae81c016842c192a7ae/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a1fa3e7944ede1594585dae81c016842c192a7ae", "patch": "@@ -1,3 +1,7 @@\n+2009-04-27  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gnat.dg/opt2.adb: New test.\n+\n 2009-04-27  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/39875"}, {"sha": "a6c247fdb9be6bc8315b4dc89af666646b5c4e16", "filename": "gcc/testsuite/gnat.dg/opt2.adb", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1fa3e7944ede1594585dae81c016842c192a7ae/gcc%2Ftestsuite%2Fgnat.dg%2Fopt2.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1fa3e7944ede1594585dae81c016842c192a7ae/gcc%2Ftestsuite%2Fgnat.dg%2Fopt2.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fopt2.adb?ref=a1fa3e7944ede1594585dae81c016842c192a7ae", "patch": "@@ -0,0 +1,31 @@\n+-- { dg-do run }\n+-- { dg-options \"-O2 -fno-inline\" }\n+\n+procedure Opt2 is\n+   function Get return String is\n+   begin\n+      return \"[]\";\n+   end Get;\n+\n+   Message : String := Get;\n+\n+   F, L : Integer;\n+begin\n+   for J in Message'Range loop\n+      if Message (J) = '[' then\n+         F := J;\n+      elsif Message (J) = ']' then\n+         L := J;\n+         exit;\n+      end if;\n+   end loop;\n+\n+   declare\n+      M : String :=\n+         Message (Message'First .. F) & Message (L .. Message'Last);\n+   begin\n+      if M /= \"[]\" then\n+        raise Program_Error;\n+      end if;\n+   end;\n+end;"}]}