{"sha": "69eb4fde588c5c2e4e206aeba9a5a17fcaf5cecb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjllYjRmZGU1ODhjNWMyZTRlMjA2YWViYTlhNWExN2ZjYWY1Y2VjYg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2014-11-19T22:06:17Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2014-11-19T22:06:17Z"}, "message": "re PR c++/57979 (G++ accepts constant expression defined using floating point non-constexpr glvalue)\n\n\tPR c++/57979\n\t* init.c (decl_really_constant_value): Rename from\n\tintegral_constant_value.\n\t(scalar_constant_value): Similar but limited to scalar results.\n\t(decl_constant_value_safe): Remove.\n\t(constant_value_1): Respect return_aggregate_cst_ok_p.\n\t* typeck.c (decay_conversion): Use scalar_constant_value.\n\t* call.c (convert_like_real): Likewise.\n\t* cvt.c (ocp_convert): No need to check CLASS_TYPE_P.\n\t* typeck.c (decay_conversion): Or ARRAY_TYPE.\n\t* constexpr.c (struct constexpr_ctx): Add strict field.\n\t(cxx_eval_constant_expression) [VAR_DECL]: Use it to select between\n\tdecl_constant_value and decl_really_constant_value.\n\t(cxx_eval_outermost_constant_expr): Add strict parm.\n\t(maybe_constant_init): Not strict.\n\t(potential_constant_expression_1): Add strict parm.\n\tShorten most internal calls with RECUR macro.\n\t* cp-tree.h, pt.c, semantics.c: Adjust.\n\nFrom-SVN: r217814", "tree": {"sha": "7ab8f15cad76cb28be65015b3cbb7153217b4139", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7ab8f15cad76cb28be65015b3cbb7153217b4139"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/69eb4fde588c5c2e4e206aeba9a5a17fcaf5cecb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69eb4fde588c5c2e4e206aeba9a5a17fcaf5cecb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/69eb4fde588c5c2e4e206aeba9a5a17fcaf5cecb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69eb4fde588c5c2e4e206aeba9a5a17fcaf5cecb/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6d06c429dc7effbf2ecc26401c7d43f5ab192dd7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d06c429dc7effbf2ecc26401c7d43f5ab192dd7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6d06c429dc7effbf2ecc26401c7d43f5ab192dd7"}], "stats": {"total": 269, "additions": 144, "deletions": 125}, "files": [{"sha": "6f947b4b81143c365dbc3630dc3d102b08f60005", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69eb4fde588c5c2e4e206aeba9a5a17fcaf5cecb/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69eb4fde588c5c2e4e206aeba9a5a17fcaf5cecb/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=69eb4fde588c5c2e4e206aeba9a5a17fcaf5cecb", "patch": "@@ -1,3 +1,24 @@\n+2014-11-19  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/57979\n+\t* init.c (decl_really_constant_value): Rename from\n+\tintegral_constant_value.\n+\t(scalar_constant_value): Similar but limited to scalar results.\n+\t(decl_constant_value_safe): Remove.\n+\t(constant_value_1): Respect return_aggregate_cst_ok_p.\n+\t* typeck.c (decay_conversion): Use scalar_constant_value.\n+\t* call.c (convert_like_real): Likewise.\n+\t* cvt.c (ocp_convert): No need to check CLASS_TYPE_P.\n+\t* typeck.c (decay_conversion): Or ARRAY_TYPE.\n+\t* constexpr.c (struct constexpr_ctx): Add strict field.\n+\t(cxx_eval_constant_expression) [VAR_DECL]: Use it to select between\n+\tdecl_constant_value and decl_really_constant_value.\n+\t(cxx_eval_outermost_constant_expr): Add strict parm.\n+\t(maybe_constant_init): Not strict.\n+\t(potential_constant_expression_1): Add strict parm.\n+\tShorten most internal calls with RECUR macro.\n+\t* cp-tree.h, pt.c, semantics.c: Adjust.\n+\n 2014-11-19  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/63928"}, {"sha": "5cda1b1ee2bb35db1cc630214115db7e34a72226", "filename": "gcc/cp/call.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69eb4fde588c5c2e4e206aeba9a5a17fcaf5cecb/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69eb4fde588c5c2e4e206aeba9a5a17fcaf5cecb/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=69eb4fde588c5c2e4e206aeba9a5a17fcaf5cecb", "patch": "@@ -6247,7 +6247,7 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n \t leave it as an lvalue.  */\n       if (inner >= 0)\n         {   \n-          expr = decl_constant_value_safe (expr);\n+          expr = scalar_constant_value (expr);\n           if (expr == null_node && INTEGRAL_OR_UNSCOPED_ENUMERATION_TYPE_P (totype))\n             /* If __null has been converted to an integer type, we do not\n                want to warn about uses of EXPR as an integer, rather than"}, {"sha": "52685450edf3f4e97fae52288704fef9ebb22b21", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 87, "deletions": 80, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69eb4fde588c5c2e4e206aeba9a5a17fcaf5cecb/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69eb4fde588c5c2e4e206aeba9a5a17fcaf5cecb/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=69eb4fde588c5c2e4e206aeba9a5a17fcaf5cecb", "patch": "@@ -869,6 +869,7 @@ struct constexpr_ctx {\n   tree ctor;\n   tree object;\n   bool quiet;\n+  bool strict;\n };\n \n /* A table of all constexpr calls that have been evaluated by the\n@@ -2818,7 +2819,10 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \treturn t;\n       /* else fall through. */\n     case CONST_DECL:\n-      r = integral_constant_value (t);\n+      if (ctx->strict)\n+\tr = decl_really_constant_value (t);\n+      else\n+\tr = decl_constant_value (t);\n       if (TREE_CODE (r) == TARGET_EXPR\n \t  && TREE_CODE (TARGET_EXPR_INITIAL (r)) == CONSTRUCTOR)\n \tr = TARGET_EXPR_INITIAL (r);\n@@ -3302,11 +3306,11 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \n static tree\n cxx_eval_outermost_constant_expr (tree t, bool allow_non_constant,\n-\t\t\t\t  tree object = NULL_TREE)\n+\t\t\t\t  bool strict = true, tree object = NULL_TREE)\n {\n   bool non_constant_p = false;\n   bool overflow_p = false;\n-  constexpr_ctx ctx = { NULL, NULL, NULL, NULL, allow_non_constant };\n+  constexpr_ctx ctx = { NULL, NULL, NULL, NULL, allow_non_constant, strict };\n   hash_map<tree,tree> map;\n   ctx.values = &map;\n   tree type = initialized_type (t);\n@@ -3415,7 +3419,7 @@ is_sub_constant_expr (tree t)\n {\n   bool non_constant_p = false;\n   bool overflow_p = false;\n-  constexpr_ctx ctx = { NULL, NULL, NULL, NULL, true };\n+  constexpr_ctx ctx = { NULL, NULL, NULL, NULL, true, true };\n   hash_map <tree, tree> map;\n   ctx.values = &map;\n   cxx_eval_constant_expression (&ctx, t, false, &non_constant_p,\n@@ -3430,7 +3434,7 @@ is_sub_constant_expr (tree t)\n tree\n cxx_constant_value (tree t, tree decl)\n {\n-  return cxx_eval_outermost_constant_expr (t, false, decl);\n+  return cxx_eval_outermost_constant_expr (t, false, true, decl);\n }\n \n /* If T is a constant expression, returns its reduced value.\n@@ -3455,7 +3459,7 @@ maybe_constant_value (tree t, tree decl)\n       return t;\n     }\n \n-  r = cxx_eval_outermost_constant_expr (t, true, decl);\n+  r = cxx_eval_outermost_constant_expr (t, true, true, decl);\n #ifdef ENABLE_CHECKING\n   /* cp_tree_equal looks through NOPs, so allow them.  */\n   gcc_assert (r == t\n@@ -3515,7 +3519,7 @@ fold_non_dependent_expr (tree t)\n \t      return t;\n \t    }\n \n-\t  tree r = cxx_eval_outermost_constant_expr (t, true, NULL_TREE);\n+\t  tree r = cxx_eval_outermost_constant_expr (t, true, true, NULL_TREE);\n #ifdef ENABLE_CHECKING\n \t  /* cp_tree_equal looks through NOPs, so allow them.  */\n \t  gcc_assert (r == t\n@@ -3550,7 +3554,13 @@ maybe_constant_init (tree t, tree decl)\n     t = TREE_OPERAND (t, 0);\n   if (TREE_CODE (t) == INIT_EXPR)\n     t = TREE_OPERAND (t, 1);\n-  t = maybe_constant_value (t, decl);\n+  if (instantiation_dependent_expression_p (t)\n+      || type_unknown_p (t)\n+      || BRACE_ENCLOSED_INITIALIZER_P (t)\n+      || !potential_static_init_expression (t))\n+    /* Don't try to evaluate it.  */;\n+  else\n+    t = cxx_eval_outermost_constant_expr (t, true, false, decl);\n   if (TREE_CODE (t) == TARGET_EXPR)\n     {\n       tree init = TARGET_EXPR_INITIAL (t);\n@@ -3604,8 +3614,10 @@ check_automatic_or_tls (tree ref)\n       not evaluated are not considered.   */\n \n static bool\n-potential_constant_expression_1 (tree t, bool want_rval, tsubst_flags_t flags)\n+potential_constant_expression_1 (tree t, bool want_rval, bool strict,\n+\t\t\t\t tsubst_flags_t flags)\n {\n+#define RECUR(T,RV) potential_constant_expression_1 ((T), (RV), strict, flags)\n   enum { any = false, rval = true };\n   int i;\n   tree tmp;\n@@ -3698,14 +3710,14 @@ potential_constant_expression_1 (tree t, bool want_rval, tsubst_flags_t flags)\n \t\t    tree x = get_nth_callarg (t, 0);\n \t\t    if (is_this_parameter (x))\n \t\t      return true;\n-\t\t    else if (!potential_constant_expression_1 (x, rval, flags))\n+\t\t    else if (!RECUR (x, rval))\n \t\t      return false;\n \t\t    i = 1;\n \t\t  }\n \t      }\n \t    else\n \t      {\n-\t\tif (!potential_constant_expression_1 (fun, true, flags))\n+\t\tif (!RECUR (fun, true))\n \t\t  return false;\n \t\tfun = get_first_fn (fun);\n \t      }\n@@ -3716,15 +3728,15 @@ potential_constant_expression_1 (tree t, bool want_rval, tsubst_flags_t flags)\n \t  }\n \telse\n           {\n-\t    if (potential_constant_expression_1 (fun, rval, flags))\n+\t    if (RECUR (fun, rval))\n \t      /* Might end up being a constant function pointer.  */;\n \t    else\n \t      return false;\n           }\n         for (; i < nargs; ++i)\n           {\n             tree x = get_nth_callarg (t, i);\n-\t    if (!potential_constant_expression_1 (x, rval, flags))\n+\t    if (!RECUR (x, rval))\n \t      return false;\n           }\n         return true;\n@@ -3739,10 +3751,14 @@ potential_constant_expression_1 (tree t, bool want_rval, tsubst_flags_t flags)\n             -- an lvalue of literal type that refers to non-volatile\n                object defined with constexpr, or that refers to a\n                sub-object of such an object;  */\n-      return potential_constant_expression_1 (TREE_OPERAND (t, 0), rval, flags);\n+      return RECUR (TREE_OPERAND (t, 0), rval);\n \n     case VAR_DECL:\n-      if (want_rval && !decl_constant_var_p (t)\n+      if (want_rval\n+\t  && !decl_constant_var_p (t)\n+\t  && (strict\n+\t      || !CP_TYPE_CONST_NON_VOLATILE_P (TREE_TYPE (t))\n+\t      || !DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P (t))\n \t  && !var_in_constexpr_fn (t)\n \t  && !dependent_type_p (TREE_TYPE (t)))\n         {\n@@ -3768,8 +3784,7 @@ potential_constant_expression_1 (tree t, bool want_rval, tsubst_flags_t flags)\n \t\t\t\"reinterpret_cast from integer to pointer\");\n \t    return false;\n \t  }\n-        return (potential_constant_expression_1\n-\t\t(from, TREE_CODE (t) != VIEW_CONVERT_EXPR, flags));\n+        return (RECUR (from, TREE_CODE (t) != VIEW_CONVERT_EXPR));\n       }\n \n     case ADDR_EXPR:\n@@ -3797,7 +3812,7 @@ potential_constant_expression_1 (tree t, bool want_rval, tsubst_flags_t flags)\n           return false;\n         }\n #endif\n-      return potential_constant_expression_1 (t, any, flags);\n+      return RECUR (t, any);\n \n     case COMPONENT_REF:\n     case BIT_FIELD_REF:\n@@ -3807,12 +3822,10 @@ potential_constant_expression_1 (tree t, bool want_rval, tsubst_flags_t flags)\n             of literal type or of pointer to literal type.  */\n       /* This test would be redundant, as it follows from the\n \t postfix-expression being a potential constant expression.  */\n-      return potential_constant_expression_1 (TREE_OPERAND (t, 0),\n-\t\t\t\t\t      want_rval, flags);\n+      return RECUR (TREE_OPERAND (t, 0), want_rval);\n \n     case EXPR_PACK_EXPANSION:\n-      return potential_constant_expression_1 (PACK_EXPANSION_PATTERN (t),\n-\t\t\t\t\t      want_rval, flags);\n+      return RECUR (PACK_EXPANSION_PATTERN (t), want_rval);\n \n     case INDIRECT_REF:\n       {\n@@ -3829,15 +3842,15 @@ potential_constant_expression_1 (tree t, bool want_rval, tsubst_flags_t flags)\n \t      }\n \t    return true;\n \t  }\n-\treturn potential_constant_expression_1 (x, rval, flags);\n+\treturn RECUR (x, rval);\n       }\n \n     case STATEMENT_LIST:\n       {\n \ttree_stmt_iterator i;\n \tfor (i = tsi_start (t); !tsi_end_p (i); tsi_next (&i))\n \t  {\n-\t    if (!potential_constant_expression_1 (tsi_stmt (i), any, flags))\n+\t    if (!RECUR (tsi_stmt (i), any))\n \t      return false;\n \t  }\n \treturn true;\n@@ -3847,64 +3860,64 @@ potential_constant_expression_1 (tree t, bool want_rval, tsubst_flags_t flags)\n     case MODIFY_EXPR:\n       if (cxx_dialect < cxx14)\n \tgoto fail;\n-      if (!potential_constant_expression_1 (TREE_OPERAND (t, 0), any, flags))\n+      if (!RECUR (TREE_OPERAND (t, 0), any))\n \treturn false;\n-      if (!potential_constant_expression_1 (TREE_OPERAND (t, 1), rval, flags))\n+      if (!RECUR (TREE_OPERAND (t, 1), rval))\n \treturn false;\n       return true;\n \n     case MODOP_EXPR:\n       if (cxx_dialect < cxx14)\n \tgoto fail;\n-      if (!potential_constant_expression_1 (TREE_OPERAND (t, 0), rval, flags))\n+      if (!RECUR (TREE_OPERAND (t, 0), rval))\n \treturn false;\n-      if (!potential_constant_expression_1 (TREE_OPERAND (t, 2), rval, flags))\n+      if (!RECUR (TREE_OPERAND (t, 2), rval))\n \treturn false;\n       return true;\n \n     case IF_STMT:\n-      if (!potential_constant_expression_1 (IF_COND (t), rval, flags))\n+      if (!RECUR (IF_COND (t), rval))\n \treturn false;\n-      if (!potential_constant_expression_1 (THEN_CLAUSE (t), any, flags))\n+      if (!RECUR (THEN_CLAUSE (t), any))\n \treturn false;\n-      if (!potential_constant_expression_1 (ELSE_CLAUSE (t), any, flags))\n+      if (!RECUR (ELSE_CLAUSE (t), any))\n \treturn false;\n       return true;\n \n     case DO_STMT:\n-      if (!potential_constant_expression_1 (DO_COND (t), rval, flags))\n+      if (!RECUR (DO_COND (t), rval))\n \treturn false;\n-      if (!potential_constant_expression_1 (DO_BODY (t), any, flags))\n+      if (!RECUR (DO_BODY (t), any))\n \treturn false;\n       return true;\n \n     case FOR_STMT:\n-      if (!potential_constant_expression_1 (FOR_INIT_STMT (t), any, flags))\n+      if (!RECUR (FOR_INIT_STMT (t), any))\n \treturn false;\n-      if (!potential_constant_expression_1 (FOR_COND (t), rval, flags))\n+      if (!RECUR (FOR_COND (t), rval))\n \treturn false;\n-      if (!potential_constant_expression_1 (FOR_EXPR (t), any, flags))\n+      if (!RECUR (FOR_EXPR (t), any))\n \treturn false;\n-      if (!potential_constant_expression_1 (FOR_BODY (t), any, flags))\n+      if (!RECUR (FOR_BODY (t), any))\n \treturn false;\n       return true;\n \n     case WHILE_STMT:\n-      if (!potential_constant_expression_1 (WHILE_COND (t), rval, flags))\n+      if (!RECUR (WHILE_COND (t), rval))\n \treturn false;\n-      if (!potential_constant_expression_1 (WHILE_BODY (t), any, flags))\n+      if (!RECUR (WHILE_BODY (t), any))\n \treturn false;\n       return true;\n \n     case SWITCH_STMT:\n-      if (!potential_constant_expression_1 (SWITCH_STMT_COND (t), rval, flags))\n+      if (!RECUR (SWITCH_STMT_COND (t), rval))\n \treturn false;\n-      if (!potential_constant_expression_1 (SWITCH_STMT_BODY (t), any, flags))\n+      if (!RECUR (SWITCH_STMT_BODY (t), any))\n \treturn false;\n       return true;\n \n     case STMT_EXPR:\n-      return potential_constant_expression_1 (STMT_EXPR_STMT (t), rval, flags);\n+      return RECUR (STMT_EXPR_STMT (t), rval);\n \n     case LAMBDA_EXPR:\n     case DYNAMIC_CAST_EXPR:\n@@ -4002,8 +4015,7 @@ potential_constant_expression_1 (tree t, bool want_rval, tsubst_flags_t flags)\n     case FIXED_CONVERT_EXPR:\n     case UNARY_PLUS_EXPR:\n     unary:\n-      return potential_constant_expression_1 (TREE_OPERAND (t, 0), rval,\n-\t\t\t\t\t      flags);\n+      return RECUR (TREE_OPERAND (t, 0), rval);\n \n     case CAST_EXPR:\n     case CONST_CAST_EXPR:\n@@ -4022,13 +4034,11 @@ potential_constant_expression_1 (tree t, bool want_rval, tsubst_flags_t flags)\n \t  return false;\n \t}\n \n-      return (potential_constant_expression_1\n-\t      (TREE_OPERAND (t, 0),\n-\t       TREE_CODE (TREE_TYPE (t)) != REFERENCE_TYPE, flags));\n+      return (RECUR (TREE_OPERAND (t, 0),\n+\t\t     TREE_CODE (TREE_TYPE (t)) != REFERENCE_TYPE));\n \n     case BIND_EXPR:\n-      return potential_constant_expression_1 (BIND_EXPR_BODY (t),\n-\t\t\t\t\t      want_rval, flags);\n+      return RECUR (BIND_EXPR_BODY (t), want_rval);\n \n     case WITH_CLEANUP_EXPR:\n     case CLEANUP_POINT_EXPR:\n@@ -4041,12 +4051,10 @@ potential_constant_expression_1 (tree t, bool want_rval, tsubst_flags_t flags)\n     case NON_DEPENDENT_EXPR:\n       /* For convenience.  */\n     case RETURN_EXPR:\n-      return potential_constant_expression_1 (TREE_OPERAND (t, 0),\n-\t\t\t\t\t      want_rval, flags);\n+      return RECUR (TREE_OPERAND (t, 0), want_rval);\n \n     case SCOPE_REF:\n-      return potential_constant_expression_1 (TREE_OPERAND (t, 1),\n-\t\t\t\t\t      want_rval, flags);\n+      return RECUR (TREE_OPERAND (t, 1), want_rval);\n \n     case TARGET_EXPR:\n       if (!literal_type_p (TREE_TYPE (t)))\n@@ -4060,15 +4068,14 @@ potential_constant_expression_1 (tree t, bool want_rval, tsubst_flags_t flags)\n \t  return false;\n \t}\n     case INIT_EXPR:\n-      return potential_constant_expression_1 (TREE_OPERAND (t, 1),\n-\t\t\t\t\t      rval, flags);\n+      return RECUR (TREE_OPERAND (t, 1), rval);\n \n     case CONSTRUCTOR:\n       {\n         vec<constructor_elt, va_gc> *v = CONSTRUCTOR_ELTS (t);\n         constructor_elt *ce;\n         for (i = 0; vec_safe_iterate (v, i, &ce); ++i)\n-\t  if (!potential_constant_expression_1 (ce->value, want_rval, flags))\n+\t  if (!RECUR (ce->value, want_rval))\n \t    return false;\n \treturn true;\n       }\n@@ -4077,13 +4084,11 @@ potential_constant_expression_1 (tree t, bool want_rval, tsubst_flags_t flags)\n       {\n \tgcc_assert (TREE_PURPOSE (t) == NULL_TREE\n \t\t    || DECL_P (TREE_PURPOSE (t)));\n-\tif (!potential_constant_expression_1 (TREE_VALUE (t), want_rval,\n-\t\t\t\t\t      flags))\n+\tif (!RECUR (TREE_VALUE (t), want_rval))\n \t  return false;\n \tif (TREE_CHAIN (t) == NULL_TREE)\n \t  return true;\n-\treturn potential_constant_expression_1 (TREE_CHAIN (t), want_rval,\n-\t\t\t\t\t\tflags);\n+\treturn RECUR (TREE_CHAIN (t), want_rval);\n       }\n \n     case TRUNC_DIV_EXPR:\n@@ -4095,7 +4100,7 @@ potential_constant_expression_1 (tree t, bool want_rval, tsubst_flags_t flags)\n     case ROUND_MOD_EXPR:\n       {\n \ttree denom = TREE_OPERAND (t, 1);\n-\tif (!potential_constant_expression_1 (denom, rval, flags))\n+\tif (!RECUR (denom, rval))\n \t  return false;\n \t/* We can't call cxx_eval_outermost_constant_expr on an expression\n \t   that hasn't been through instantiate_non_dependent_expr yet.  */\n@@ -4110,8 +4115,7 @@ potential_constant_expression_1 (tree t, bool want_rval, tsubst_flags_t flags)\n \telse\n \t  {\n \t    want_rval = true;\n-\t    return potential_constant_expression_1 (TREE_OPERAND (t, 0),\n-\t\t\t\t\t\t    want_rval, flags);\n+\t    return RECUR (TREE_OPERAND (t, 0), want_rval);\n \t  }\n       }\n \n@@ -4125,7 +4129,7 @@ potential_constant_expression_1 (tree t, bool want_rval, tsubst_flags_t flags)\n \tSTRIP_NOPS (op1);\n \tif ((TREE_CODE (op0) == TARGET_EXPR && op1 == TARGET_EXPR_SLOT (op0))\n \t    || TREE_CODE (op1) == EMPTY_CLASS_EXPR)\n-\t  return potential_constant_expression_1 (op0, want_rval, flags);\n+\t  return RECUR (op0, want_rval);\n \telse\n \t  goto binary;\n       }\n@@ -4143,12 +4147,12 @@ potential_constant_expression_1 (tree t, bool want_rval, tsubst_flags_t flags)\n     truth:\n       {\n \ttree op = TREE_OPERAND (t, 0);\n-\tif (!potential_constant_expression_1 (op, rval, flags))\n+\tif (!RECUR (op, rval))\n \t  return false;\n \tif (!processing_template_decl)\n \t  op = cxx_eval_outermost_constant_expr (op, true);\n \tif (tree_int_cst_equal (op, tmp))\n-\t  return potential_constant_expression_1 (TREE_OPERAND (t, 1), rval, flags);\n+\t  return RECUR (TREE_OPERAND (t, 1), rval);\n \telse\n \t  return true;\n       }\n@@ -4186,8 +4190,7 @@ potential_constant_expression_1 (tree t, bool want_rval, tsubst_flags_t flags)\n     case DOTSTAR_EXPR:\n     binary:\n       for (i = 0; i < 2; ++i)\n-\tif (!potential_constant_expression_1 (TREE_OPERAND (t, i),\n-\t\t\t\t\t      want_rval, flags))\n+\tif (!RECUR (TREE_OPERAND (t, i), want_rval))\n \t  return false;\n       return true;\n \n@@ -4199,8 +4202,7 @@ potential_constant_expression_1 (tree t, bool want_rval, tsubst_flags_t flags)\n     case FMA_EXPR:\n     case VEC_PERM_EXPR:\n      for (i = 0; i < 3; ++i)\n-      if (!potential_constant_expression_1 (TREE_OPERAND (t, i),\n-\t\t\t\t\t    true, flags))\n+      if (!RECUR (TREE_OPERAND (t, i), true))\n \treturn false;\n      return true;\n \n@@ -4210,19 +4212,17 @@ potential_constant_expression_1 (tree t, bool want_rval, tsubst_flags_t flags)\n \t care about; otherwise we only require that the condition and\n \t either of the legs be potentially constant.  */\n       tmp = TREE_OPERAND (t, 0);\n-      if (!potential_constant_expression_1 (tmp, rval, flags))\n+      if (!RECUR (tmp, rval))\n \treturn false;\n       if (!processing_template_decl)\n \ttmp = cxx_eval_outermost_constant_expr (tmp, true);\n       if (integer_zerop (tmp))\n-\treturn potential_constant_expression_1 (TREE_OPERAND (t, 2),\n-\t\t\t\t\t\twant_rval, flags);\n+\treturn RECUR (TREE_OPERAND (t, 2), want_rval);\n       else if (TREE_CODE (tmp) == INTEGER_CST)\n-\treturn potential_constant_expression_1 (TREE_OPERAND (t, 1),\n-\t\t\t\t\t\twant_rval, flags);\n+\treturn RECUR (TREE_OPERAND (t, 1), want_rval);\n       for (i = 1; i < 3; ++i)\n \tif (potential_constant_expression_1 (TREE_OPERAND (t, i),\n-\t\t\t\t\t     want_rval, tf_none))\n+\t\t\t\t\t     want_rval, strict, tf_none))\n \t  return true;\n       if (flags & tf_error)\n         error (\"expression %qE is not a constant-expression\", t);\n@@ -4246,38 +4246,45 @@ potential_constant_expression_1 (tree t, bool want_rval, tsubst_flags_t flags)\n       gcc_unreachable();\n       return false;\n     }\n+#undef RECUR\n }\n \n /* The main entry point to the above.  */\n \n bool\n potential_constant_expression (tree t)\n {\n-  return potential_constant_expression_1 (t, false, tf_none);\n+  return potential_constant_expression_1 (t, false, true, tf_none);\n+}\n+\n+bool\n+potential_static_init_expression (tree t)\n+{\n+  return potential_constant_expression_1 (t, false, false, tf_none);\n }\n \n /* As above, but require a constant rvalue.  */\n \n bool\n potential_rvalue_constant_expression (tree t)\n {\n-  return potential_constant_expression_1 (t, true, tf_none);\n+  return potential_constant_expression_1 (t, true, true, tf_none);\n }\n \n /* Like above, but complain about non-constant expressions.  */\n \n bool\n require_potential_constant_expression (tree t)\n {\n-  return potential_constant_expression_1 (t, false, tf_warning_or_error);\n+  return potential_constant_expression_1 (t, false, true, tf_warning_or_error);\n }\n \n /* Cross product of the above.  */\n \n bool\n require_potential_rvalue_constant_expression (tree t)\n {\n-  return potential_constant_expression_1 (t, true, tf_warning_or_error);\n+  return potential_constant_expression_1 (t, true, true, tf_warning_or_error);\n }\n \n #include \"gt-cp-constexpr.h\""}, {"sha": "1e09629b4afa365907a4d65bd7b9c0d3fc9cb8b1", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69eb4fde588c5c2e4e206aeba9a5a17fcaf5cecb/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69eb4fde588c5c2e4e206aeba9a5a17fcaf5cecb/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=69eb4fde588c5c2e4e206aeba9a5a17fcaf5cecb", "patch": "@@ -5551,8 +5551,8 @@ extern tree build_vec_delete\t\t\t(tree, tree,\n extern tree create_temporary_var\t\t(tree);\n extern void initialize_vtbl_ptrs\t\t(tree);\n extern tree build_java_class_ref\t\t(tree);\n-extern tree integral_constant_value\t\t(tree);\n-extern tree decl_constant_value_safe\t        (tree);\n+extern tree scalar_constant_value\t\t(tree);\n+extern tree decl_really_constant_value\t\t(tree);\n extern int diagnose_uninitialized_cst_or_ref_member (tree, bool, bool);\n extern tree build_vtbl_address                  (tree);\n \n@@ -6349,6 +6349,7 @@ extern tree register_constexpr_fundef           (tree, tree);\n extern bool check_constexpr_ctor_body           (tree, tree, bool);\n extern tree ensure_literal_type_for_constexpr_object (tree);\n extern bool potential_constant_expression       (tree);\n+extern bool potential_static_init_expression    (tree);\n extern bool potential_rvalue_constant_expression (tree);\n extern bool require_potential_constant_expression (tree);\n extern bool require_potential_rvalue_constant_expression (tree);"}, {"sha": "aba75ff13e2066447610ee9f775334cb35dc9bcc", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69eb4fde588c5c2e4e206aeba9a5a17fcaf5cecb/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69eb4fde588c5c2e4e206aeba9a5a17fcaf5cecb/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=69eb4fde588c5c2e4e206aeba9a5a17fcaf5cecb", "patch": "@@ -675,9 +675,7 @@ ocp_convert (tree type, tree expr, int convtype, int flags,\n     }\n \n   /* FIXME remove when moving to c_fully_fold model.  */\n-  /* FIXME do we still need this test?  */\n-  if (!CLASS_TYPE_P (type))\n-    e = integral_constant_value (e);\n+  e = scalar_constant_value (e);\n   if (error_operand_p (e))\n     return error_mark_node;\n "}, {"sha": "899637f68f42526c55ddecc6925545981afbb61c", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69eb4fde588c5c2e4e206aeba9a5a17fcaf5cecb/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69eb4fde588c5c2e4e206aeba9a5a17fcaf5cecb/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=69eb4fde588c5c2e4e206aeba9a5a17fcaf5cecb", "patch": "@@ -12993,7 +12993,7 @@ build_enumerator (tree name, tree value, tree enumtype, location_t loc)\n   tree context;\n   tree type;\n \n-  /* integral_constant_value will pull out this expression, so make sure\n+  /* scalar_constant_value will pull out this expression, so make sure\n      it's folded as appropriate.  */\n   if (processing_template_decl)\n     value = fold_non_dependent_expr (value);"}, {"sha": "19e2cdd528562ba0963e7cafaafcef1ef29d7757", "filename": "gcc/cp/init.c", "status": "modified", "additions": 19, "deletions": 20, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69eb4fde588c5c2e4e206aeba9a5a17fcaf5cecb/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69eb4fde588c5c2e4e206aeba9a5a17fcaf5cecb/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=69eb4fde588c5c2e4e206aeba9a5a17fcaf5cecb", "patch": "@@ -2004,16 +2004,16 @@ build_offset_ref (tree type, tree member, bool address_p,\n \n /* If DECL is a scalar enumeration constant or variable with a\n    constant initializer, return the initializer (or, its initializers,\n-   recursively); otherwise, return DECL.  If INTEGRAL_P, the\n-   initializer is only returned if DECL is an integral\n+   recursively); otherwise, return DECL.  If STRICT_P, the\n+   initializer is only returned if DECL is a\n    constant-expression.  If RETURN_AGGREGATE_CST_OK_P, it is ok to\n    return an aggregate constant.  */\n \n static tree\n-constant_value_1 (tree decl, bool integral_p, bool return_aggregate_cst_ok_p)\n+constant_value_1 (tree decl, bool strict_p, bool return_aggregate_cst_ok_p)\n {\n   while (TREE_CODE (decl) == CONST_DECL\n-\t || (integral_p\n+\t || (strict_p\n \t     ? decl_constant_var_p (decl)\n \t     : (VAR_P (decl)\n \t\t&& CP_TYPE_CONST_NON_VOLATILE_P (TREE_TYPE (decl)))))\n@@ -2047,7 +2047,7 @@ constant_value_1 (tree decl, bool integral_p, bool return_aggregate_cst_ok_p)\n       if (!init\n \t  || !TREE_TYPE (init)\n \t  || !TREE_CONSTANT (init)\n-\t  || (!integral_p && !return_aggregate_cst_ok_p\n+\t  || (!return_aggregate_cst_ok_p\n \t      /* Unless RETURN_AGGREGATE_CST_OK_P is true, do not\n \t\t return an aggregate constant (of which string\n \t\t literals are a special case), as we do not want\n@@ -2062,36 +2062,35 @@ constant_value_1 (tree decl, bool integral_p, bool return_aggregate_cst_ok_p)\n   return decl;\n }\n \n-/* If DECL is a CONST_DECL, or a constant VAR_DECL initialized by\n-   constant of integral or enumeration type, then return that value.\n-   These are those variables permitted in constant expressions by\n-   [5.19/1].  */\n+/* If DECL is a CONST_DECL, or a constant VAR_DECL initialized by constant\n+   of integral or enumeration type, or a constexpr variable of scalar type,\n+   then return that value.  These are those variables permitted in constant\n+   expressions by [5.19/1].  */\n \n tree\n-integral_constant_value (tree decl)\n+scalar_constant_value (tree decl)\n {\n-  return constant_value_1 (decl, /*integral_p=*/true,\n+  return constant_value_1 (decl, /*strict_p=*/true,\n \t\t\t   /*return_aggregate_cst_ok_p=*/false);\n }\n \n-/* A more relaxed version of integral_constant_value, used by the\n-   common C/C++ code.  */\n+/* Like scalar_constant_value, but can also return aggregate initializers.  */\n \n tree\n-decl_constant_value (tree decl)\n+decl_really_constant_value (tree decl)\n {\n-  return constant_value_1 (decl, /*integral_p=*/processing_template_decl,\n+  return constant_value_1 (decl, /*strict_p=*/true,\n \t\t\t   /*return_aggregate_cst_ok_p=*/true);\n }\n \n-/* A version of integral_constant_value used by the C++ front end for\n-   optimization purposes.  */\n+/* A more relaxed version of scalar_constant_value, used by the\n+   common C/C++ code.  */\n \n tree\n-decl_constant_value_safe (tree decl)\n+decl_constant_value (tree decl)\n {\n-  return constant_value_1 (decl, /*integral_p=*/processing_template_decl,\n-\t\t\t   /*return_aggregate_cst_ok_p=*/false);\n+  return constant_value_1 (decl, /*strict_p=*/processing_template_decl,\n+\t\t\t   /*return_aggregate_cst_ok_p=*/true);\n }\n \f\n /* Common subroutines of build_new and build_vec_delete.  */"}, {"sha": "0b8fd7fd37f168717ba64bc7cd0415f0a84bdd75", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69eb4fde588c5c2e4e206aeba9a5a17fcaf5cecb/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69eb4fde588c5c2e4e206aeba9a5a17fcaf5cecb/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=69eb4fde588c5c2e4e206aeba9a5a17fcaf5cecb", "patch": "@@ -12805,7 +12805,7 @@ tsubst_copy (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t  return t;\n \t/* If ARGS is NULL, then T is known to be non-dependent.  */\n \tif (args == NULL_TREE)\n-\t  return integral_constant_value (t);\n+\t  return scalar_constant_value (t);\n \n \t/* Unfortunately, we cannot just call lookup_name here.\n \t   Consider:\n@@ -12936,7 +12936,7 @@ tsubst_copy (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t\t      else if (decl_constant_var_p (r))\n \t\t\t/* A use of a local constant decays to its value.\n \t\t\t   FIXME update for core DR 696.  */\n-\t\t\tr = integral_constant_value (r);\n+\t\t\tr = scalar_constant_value (r);\n \t\t    }\n \t\t}\n \t      /* Remember this for subsequent uses.  */\n@@ -18420,7 +18420,7 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict,\n     case CONST_DECL:\n       if (DECL_TEMPLATE_PARM_P (parm))\n \treturn unify (tparms, targs, DECL_INITIAL (parm), arg, strict, explain_p);\n-      if (arg != integral_constant_value (parm))\n+      if (arg != scalar_constant_value (parm))\n \treturn unify_template_argument_mismatch (explain_p, parm, arg);\n       return unify_success (explain_p);\n "}, {"sha": "639702a6e624df7584fd133785a05a7ee8518536", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69eb4fde588c5c2e4e206aeba9a5a17fcaf5cecb/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69eb4fde588c5c2e4e206aeba9a5a17fcaf5cecb/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=69eb4fde588c5c2e4e206aeba9a5a17fcaf5cecb", "patch": "@@ -3125,7 +3125,7 @@ process_outer_var_ref (tree decl, tsubst_flags_t complain)\n \t   form, so wait until instantiation time.  */\n \treturn decl;\n       else if (decl_constant_var_p (decl))\n-\treturn integral_constant_value (decl);\n+\treturn scalar_constant_value (decl);\n     }\n \n   if (parsing_nsdmi ())"}, {"sha": "53fe67afc90cd5a55b42b1d2b25f84b53e16d534", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69eb4fde588c5c2e4e206aeba9a5a17fcaf5cecb/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69eb4fde588c5c2e4e206aeba9a5a17fcaf5cecb/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=69eb4fde588c5c2e4e206aeba9a5a17fcaf5cecb", "patch": "@@ -1936,17 +1936,10 @@ decay_conversion (tree exp, tsubst_flags_t complain)\n \n   code = TREE_CODE (type);\n \n-  /* For an array decl decay_conversion should not try to return its\n-     initializer.  */\n-  if (code != ARRAY_TYPE)\n-    {\n-      /* FIXME remove? at least need to remember that this isn't really a\n-\t constant expression if EXP isn't decl_constant_var_p, like with\n-\t C_MAYBE_CONST_EXPR.  */\n-      exp = decl_constant_value_safe (exp);\n-      if (error_operand_p (exp))\n-\treturn error_mark_node;\n-    }\n+  /* FIXME remove for delayed folding.  */\n+  exp = scalar_constant_value (exp);\n+  if (error_operand_p (exp))\n+    return error_mark_node;\n \n   if (NULLPTR_TYPE_P (type) && !TREE_SIDE_EFFECTS (exp))\n     return nullptr_node;"}, {"sha": "bd146adb702264885ba965fc2a7002ebf485bf9f", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-object2.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69eb4fde588c5c2e4e206aeba9a5a17fcaf5cecb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-object2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69eb4fde588c5c2e4e206aeba9a5a17fcaf5cecb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-object2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-object2.C?ref=69eb4fde588c5c2e4e206aeba9a5a17fcaf5cecb", "patch": "@@ -3,9 +3,9 @@\n constexpr int verysquare(int x) { return x * x; }\n \n const double mass = 9.8;\n-constexpr double energy = mass * verysquare(56.6); // { dg-error \"mass\" \"\" { xfail *-*-* } }\n+constexpr double energy = mass * verysquare(56.6); // { dg-error \"mass\" }\n \n-int arr[(int)mass];\t\t// { dg-error \"mass\" \"\" { xfail *-*-* } }\n+int arr[(int)mass];\t\t// { dg-error \"\" }\n \n float array[verysquare(9)];         // OK -- not C99 VLA\n "}, {"sha": "396ac3a1fd725ff4fc42977cd1495f82afe52c01", "filename": "gcc/testsuite/g++.dg/cpp0x/nullptr06.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69eb4fde588c5c2e4e206aeba9a5a17fcaf5cecb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnullptr06.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69eb4fde588c5c2e4e206aeba9a5a17fcaf5cecb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnullptr06.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnullptr06.C?ref=69eb4fde588c5c2e4e206aeba9a5a17fcaf5cecb", "patch": "@@ -4,7 +4,7 @@\n \n #define assert_true(b) do { char c[2 * bool(b) - 1]; } while(0)\n \n-char* const cp1 = nullptr;\n+constexpr char* cp1 = nullptr;\n \n void fun()\n {"}]}