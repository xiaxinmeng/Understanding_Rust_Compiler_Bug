{"sha": "d2db36ddd24bb073aacc55b2d60936d0b477af2c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDJkYjM2ZGRkMjRiYjA3M2FhY2M1NWIyZDYwOTM2ZDBiNDc3YWYyYw==", "commit": {"author": {"name": "Kugan Vivekanandarajah", "email": "kuganv@linaro.org", "date": "2016-05-24T00:14:13Z"}, "committer": {"name": "Kugan Vivekanandarajah", "email": "kugan@gcc.gnu.org", "date": "2016-05-24T00:14:13Z"}, "message": "re PR tree-optimization/71170 (ICE in rewrite_expr_tree, at tree-ssa-reassoc.c:3898)\n\ngcc/ChangeLog:\n\n2016-05-24  Kugan Vivekanandarajah  <kuganv@linaro.org>\n\n\tPR middle-end/71170\n\t* tree-ssa-reassoc.c (struct operand_entry): Add field stmt_to_insert.\n\t(add_to_ops_vec): Add stmt_to_insert.\n\t(add_repeat_to_ops_vec): Init stmt_to_insert.\n\t(insert_stmt_before_use): New.\n\t(transform_add_to_multiply): Remove mult_stmt insertion and add it to ops vector.\n\t(get_ops): Init stmt_to_insert.\n\t(maybe_optimize_range_tests): Likewise.\n\t(rewrite_expr_tree): Insert stmt_to_insert before use stmt.\n\t(rewrite_expr_tree_parallel): Likewise.\n\t(reassociate_bb): Likewise.\n\nFrom-SVN: r236619", "tree": {"sha": "69a8d9c05c5f4d059f7e44e71efaef66b9533126", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/69a8d9c05c5f4d059f7e44e71efaef66b9533126"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d2db36ddd24bb073aacc55b2d60936d0b477af2c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2db36ddd24bb073aacc55b2d60936d0b477af2c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d2db36ddd24bb073aacc55b2d60936d0b477af2c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2db36ddd24bb073aacc55b2d60936d0b477af2c/comments", "author": null, "committer": null, "parents": [{"sha": "fe3f3340416fc6f2a197f2c057de4094f5974d9c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe3f3340416fc6f2a197f2c057de4094f5974d9c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe3f3340416fc6f2a197f2c057de4094f5974d9c"}], "stats": {"total": 94, "additions": 76, "deletions": 18}, "files": [{"sha": "d4d12b140526b6d79ce3cf3e16ba1be44409c7f3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2db36ddd24bb073aacc55b2d60936d0b477af2c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2db36ddd24bb073aacc55b2d60936d0b477af2c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d2db36ddd24bb073aacc55b2d60936d0b477af2c", "patch": "@@ -1,3 +1,17 @@\n+2016-05-24  Kugan Vivekanandarajah  <kuganv@linaro.org>\n+\n+\tPR middle-end/71170\n+\t* tree-ssa-reassoc.c (struct operand_entry): Add field stmt_to_insert.\n+\t(add_to_ops_vec): Add stmt_to_insert.\n+\t(add_repeat_to_ops_vec): Init stmt_to_insert.\n+\t(insert_stmt_before_use): New.\n+\t(transform_add_to_multiply): Remove mult_stmt insertion and add it to ops vector.\n+\t(get_ops): Init stmt_to_insert.\n+\t(maybe_optimize_range_tests): Likewise.\n+\t(rewrite_expr_tree): Insert stmt_to_insert before use stmt.\n+\t(rewrite_expr_tree_parallel): Likewise.\n+\t(reassociate_bb): Likewise.\n+\n 2016-05-23  Michael Meissner  <meissner@linux.vnet.ibm.com>\n \n \tPR target/71201"}, {"sha": "fb683adc9cc139f883a1c4228295934d0db2e096", "filename": "gcc/tree-ssa-reassoc.c", "status": "modified", "additions": 62, "deletions": 18, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2db36ddd24bb073aacc55b2d60936d0b477af2c/gcc%2Ftree-ssa-reassoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2db36ddd24bb073aacc55b2d60936d0b477af2c/gcc%2Ftree-ssa-reassoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-reassoc.c?ref=d2db36ddd24bb073aacc55b2d60936d0b477af2c", "patch": "@@ -195,6 +195,7 @@ struct operand_entry\n   int id;\n   tree op;\n   unsigned int count;\n+  gimple *stmt_to_insert;\n };\n \n static object_allocator<operand_entry> operand_entry_pool\n@@ -553,14 +554,15 @@ sort_by_operand_rank (const void *pa, const void *pb)\n /* Add an operand entry to *OPS for the tree operand OP.  */\n \n static void\n-add_to_ops_vec (vec<operand_entry *> *ops, tree op)\n+add_to_ops_vec (vec<operand_entry *> *ops, tree op, gimple *stmt_to_insert = NULL)\n {\n   operand_entry *oe = operand_entry_pool.allocate ();\n \n   oe->op = op;\n   oe->rank = get_rank (op);\n   oe->id = next_operand_entry_id++;\n   oe->count = 1;\n+  oe->stmt_to_insert = stmt_to_insert;\n   ops->safe_push (oe);\n }\n \n@@ -577,6 +579,7 @@ add_repeat_to_ops_vec (vec<operand_entry *> *ops, tree op,\n   oe->rank = get_rank (op);\n   oe->id = next_operand_entry_id++;\n   oe->count = repeat;\n+  oe->stmt_to_insert = NULL;\n   ops->safe_push (oe);\n \n   reassociate_stats.pows_encountered++;\n@@ -1756,10 +1759,21 @@ eliminate_redundant_comparison (enum tree_code opcode,\n   return false;\n }\n \n+/* If the stmt that defines operand has to be inserted, insert it\n+   before the use.  */\n+static void\n+insert_stmt_before_use (gimple *stmt, gimple *stmt_to_insert)\n+{\n+  gimple_stmt_iterator gsi = gsi_for_stmt (stmt);\n+  gimple_set_uid (stmt_to_insert, gimple_uid (stmt));\n+  gsi_insert_before (&gsi, stmt_to_insert, GSI_NEW_STMT);\n+}\n+\n+\n /* Transform repeated addition of same values into multiply with\n    constant.  */\n static bool\n-transform_add_to_multiply (gimple *stmt, vec<operand_entry *> *ops)\n+transform_add_to_multiply (vec<operand_entry *> *ops)\n {\n   operand_entry *oe;\n   tree op = NULL_TREE;\n@@ -1811,21 +1825,11 @@ transform_add_to_multiply (gimple *stmt, vec<operand_entry *> *ops)\n \tops->unordered_remove (i);\n       tree tmp = make_ssa_name (TREE_TYPE (op));\n       tree cst = build_int_cst (integer_type_node, count);\n-      gimple *def_stmt = SSA_NAME_DEF_STMT (op);\n       gassign *mul_stmt\n \t= gimple_build_assign (tmp, MULT_EXPR,\n \t\t\t       op, fold_convert (TREE_TYPE (op), cst));\n-      if (gimple_code (def_stmt) == GIMPLE_NOP\n-\t  || gimple_bb (stmt) != gimple_bb (def_stmt))\n-\t{\n-\t  gimple_stmt_iterator gsi = gsi_for_stmt (stmt);\n-\t  gimple_set_uid (mul_stmt, gimple_uid (stmt));\n-\t  gsi_insert_before (&gsi, mul_stmt, GSI_NEW_STMT);\n-\t}\n-      else\n-\tinsert_stmt_after (mul_stmt, def_stmt);\n       gimple_set_visited (mul_stmt, true);\n-      add_to_ops_vec (ops, tmp);\n+      add_to_ops_vec (ops, tmp, mul_stmt);\n       changed = true;\n     }\n \n@@ -3225,6 +3229,7 @@ get_ops (tree var, enum tree_code code, vec<operand_entry *> *ops,\n \toe->rank = code;\n \toe->id = 0;\n \toe->count = 1;\n+\toe->stmt_to_insert = NULL;\n \tops->safe_push (oe);\n       }\n   return true;\n@@ -3465,6 +3470,7 @@ maybe_optimize_range_tests (gimple *stmt)\n \t      oe->rank = code;\n \t      oe->id = 0;\n \t      oe->count = 1;\n+\t      oe->stmt_to_insert = NULL;\n \t      ops.safe_push (oe);\n \t      bb_ent.last_idx++;\n \t    }\n@@ -3502,6 +3508,7 @@ maybe_optimize_range_tests (gimple *stmt)\n \t     is.  */\n \t  oe->id = bb->index;\n \t  oe->count = 1;\n+\t  oe->stmt_to_insert = NULL;\n \t  ops.safe_push (oe);\n \t  bb_ent.op = NULL;\n \t  bb_ent.last_idx++;\n@@ -3818,6 +3825,12 @@ rewrite_expr_tree (gimple *stmt, unsigned int opindex,\n \t    {\n \t      gimple *insert_point\n \t\t= find_insert_point (stmt, oe1->op, oe2->op);\n+\t      /* If the stmt that defines operand has to be inserted, insert it\n+\t\t before the use.  */\n+\t      if (oe1->stmt_to_insert)\n+\t\tinsert_stmt_before_use (stmt, oe1->stmt_to_insert);\n+\t      if (oe2->stmt_to_insert)\n+\t\tinsert_stmt_before_use (stmt, oe2->stmt_to_insert);\n \t      lhs = make_ssa_name (TREE_TYPE (lhs));\n \t      stmt\n \t\t= gimple_build_assign (lhs, gimple_assign_rhs_code (stmt),\n@@ -3833,6 +3846,12 @@ rewrite_expr_tree (gimple *stmt, unsigned int opindex,\n \t    {\n \t      gcc_checking_assert (find_insert_point (stmt, oe1->op, oe2->op)\n \t\t\t\t   == stmt);\n+\t      /* If the stmt that defines operand has to be inserted, insert it\n+\t\t before the use.  */\n+\t      if (oe1->stmt_to_insert)\n+\t\tinsert_stmt_before_use (stmt, oe1->stmt_to_insert);\n+\t      if (oe2->stmt_to_insert)\n+\t\tinsert_stmt_before_use (stmt, oe2->stmt_to_insert);\n \t      gimple_assign_set_rhs1 (stmt, oe1->op);\n \t      gimple_assign_set_rhs2 (stmt, oe2->op);\n \t      update_stmt (stmt);\n@@ -3856,6 +3875,11 @@ rewrite_expr_tree (gimple *stmt, unsigned int opindex,\n   /* Rewrite the next operator.  */\n   oe = ops[opindex];\n \n+  /* If the stmt that defines operand has to be inserted, insert it\n+     before the use.  */\n+  if (oe->stmt_to_insert)\n+    insert_stmt_before_use (stmt, oe->stmt_to_insert);\n+\n   /* Recurse on the LHS of the binary operator, which is guaranteed to\n      be the non-leaf side.  */\n   tree new_rhs1\n@@ -4000,6 +4024,7 @@ rewrite_expr_tree_parallel (gassign *stmt, int width,\n   int stmt_index = 0;\n   int ready_stmts_end = 0;\n   int i = 0;\n+  gimple *stmt1 = NULL, *stmt2 = NULL;\n   tree last_rhs1 = gimple_assign_rhs1 (stmt);\n \n   /* We start expression rewriting from the top statements.\n@@ -4028,7 +4053,11 @@ rewrite_expr_tree_parallel (gassign *stmt, int width,\n \t  if (ready_stmts_end > stmt_index)\n \t    op2 = gimple_assign_lhs (stmts[stmt_index++]);\n \t  else if (op_index >= 0)\n-\t    op2 = ops[op_index--]->op;\n+\t    {\n+\t      operand_entry *oe = ops[op_index--];\n+\t      stmt2 = oe->stmt_to_insert;\n+\t      op2 = oe->op;\n+\t    }\n \t  else\n \t    {\n \t      gcc_assert (stmt_index < i);\n@@ -4042,8 +4071,12 @@ rewrite_expr_tree_parallel (gassign *stmt, int width,\n \t{\n \t  if (op_index > 1)\n \t    swap_ops_for_binary_stmt (ops, op_index - 2, NULL);\n-\t  op2 = ops[op_index--]->op;\n-\t  op1 = ops[op_index--]->op;\n+\t  operand_entry *oe2 = ops[op_index--];\n+\t  operand_entry *oe1 = ops[op_index--];\n+\t  op2 = oe2->op;\n+\t  stmt2 = oe2->stmt_to_insert;\n+\t  op1 = oe1->op;\n+\t  stmt1 = oe1->stmt_to_insert;\n \t}\n \n       /* If we emit the last statement then we should put\n@@ -4058,6 +4091,13 @@ rewrite_expr_tree_parallel (gassign *stmt, int width,\n \t  print_gimple_stmt (dump_file, stmts[i], 0, 0);\n \t}\n \n+      /* If the stmt that defines operand has to be inserted, insert it\n+\t before the use.  */\n+      if (stmt1)\n+\tinsert_stmt_before_use (stmts[i], stmt1);\n+      if (stmt2)\n+\tinsert_stmt_before_use (stmts[i], stmt2);\n+\n       /* We keep original statement only for the last one.  All\n \t others are recreated.  */\n       if (i == stmt_num - 1)\n@@ -5202,7 +5242,7 @@ reassociate_bb (basic_block bb)\n \t\t}\n \n \t      if (rhs_code == PLUS_EXPR\n-\t\t  && transform_add_to_multiply (stmt, &ops))\n+\t\t  && transform_add_to_multiply (&ops))\n \t\tops.qsort (sort_by_operand_rank);\n \n \t      if (rhs_code == BIT_IOR_EXPR || rhs_code == BIT_AND_EXPR)\n@@ -5247,7 +5287,11 @@ reassociate_bb (basic_block bb)\n \t      else if (ops.length () == 1)\n \t\t{\n \t\t  tree last_op = ops.last ()->op;\n-\t\t  \n+\n+\t\t  /* If the stmt that defines operand has to be inserted, insert it\n+\t\t     before the use.  */\n+\t\t  if (ops.last ()->stmt_to_insert)\n+\t\t    insert_stmt_before_use (stmt, ops.last ()->stmt_to_insert);\n \t\t  if (powi_result)\n \t\t    transform_stmt_to_multiply (&gsi, stmt, last_op,\n \t\t\t\t\t\tpowi_result);"}]}