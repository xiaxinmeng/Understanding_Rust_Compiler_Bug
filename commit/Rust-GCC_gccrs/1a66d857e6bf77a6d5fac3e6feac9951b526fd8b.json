{"sha": "1a66d857e6bf77a6d5fac3e6feac9951b526fd8b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWE2NmQ4NTdlNmJmNzdhNmQ1ZmFjM2U2ZmVhYzk5NTFiNTI2ZmQ4Yg==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2017-05-22T11:32:16Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2017-05-22T11:32:16Z"}, "message": "cp-tree.h (CPTI_TERMINATE, [...]): Rename to ...\n\n\t* cp-tree.h (CPTI_TERMINATE, CPTI_CALL_UNEXPECTED): Rename to ...\n\t(CPTI_TERMINATE_FN, CPTI_CALL_UNEXPECTED_FN): ... here.\n\t( CPTI_GET_EXCEPTION_PTR_FN, CPTI_BEGIN_CATCH_FN)\n\t(CPTI_END_CATCH_FN)\n\tCPTI_ALLOCATE_EXCEPTION_FN, CPTI_FREE_EXCEPTION_FN, CPTI_THROW_FN,\n\tCPTI_RETHROW_FN): New.\n\t(noexcept_deferred_spec): New.\n\t(terminate_node, call_unexpected_node): Rename to ...\n\t(terminate_fn, call_unexpected_fn): ... here.\n\t(get_exception_ptr_fn, begin_catch_fn, end_catch_fn)\n\tallocate_exception_fn, free_exception_fn, throw_fn, rethrow_fn):\n\tNew.\n\t* except.c (fn1..fn5, throw_fn, rethrow_rn, spec): Delete.\n\t(init_exception_processing): Adjust.\n\t(declare_library_fn): Create and push the fns here.\n\t(do_get_exception_ptr, do_begin_catch, do_end_catch)\n\tdo_allocate_exception_ptr, do_free_exception_ptr): Adjust\n\tdeclare_library_fn use.\n\t(unevaluated_noexcept_spec): Adjust.\n\t* cp-gimplify.c (genericize_eh_spec_block)\n\tgimplify_most_not_throw_expr): Adjust.\n((((--This line, and those below, will be ignored--\n\nM    cp/cp-tree.h\nM    cp/ChangeLog\nM    cp/cp-gimplify.c\nM    cp/except.c\n\nFrom-SVN: r248328", "tree": {"sha": "00a543671461e797078e0a30ce61b31bae1304f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/00a543671461e797078e0a30ce61b31bae1304f5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1a66d857e6bf77a6d5fac3e6feac9951b526fd8b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a66d857e6bf77a6d5fac3e6feac9951b526fd8b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a66d857e6bf77a6d5fac3e6feac9951b526fd8b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a66d857e6bf77a6d5fac3e6feac9951b526fd8b/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c405923d0202e2a173d6a87074b2c3dbfd9383de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c405923d0202e2a173d6a87074b2c3dbfd9383de", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c405923d0202e2a173d6a87074b2c3dbfd9383de"}], "stats": {"total": 274, "additions": 128, "deletions": 146}, "files": [{"sha": "893cd577104b6db5df06e042906d8e738198c439", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a66d857e6bf77a6d5fac3e6feac9951b526fd8b/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a66d857e6bf77a6d5fac3e6feac9951b526fd8b/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=1a66d857e6bf77a6d5fac3e6feac9951b526fd8b", "patch": "@@ -1,5 +1,25 @@\n 2017-05-22  Nathan Sidwell  <nathan@acm.org>\n \n+\t* cp-tree.h (CPTI_TERMINATE, CPTI_CALL_UNEXPECTED): Rename to ...\n+\t(CPTI_TERMINATE_FN, CPTI_CALL_UNEXPECTED_FN): ... here.\n+\t( CPTI_GET_EXCEPTION_PTR_FN, CPTI_BEGIN_CATCH_FN, CPTI_END_CATCH_FN,\n+\tCPTI_ALLOCATE_EXCEPTION_FN, CPTI_FREE_EXCEPTION_FN, CPTI_THROW_FN,\n+\tCPTI_RETHROW_FN): New.\n+\t(noexcept_deferred_spec): New.\n+\t(terminate_node, call_unexpected_node): Rename to ...\n+\t(terminate_fn, call_unexpected_fn): ... here.\n+\t(get_exception_ptr_fn, begin_catch_fn, end_catch_fn,\n+\tallocate_exception_fn, free_exception_fn, throw_fn, rethrow_fn): New.\n+\t* except.c (fn1..fn5, throw_fn, rethrow_rn, spec): Delete.\n+\t(init_exception_processing): Adjust.\n+\t(declare_library_fn): Create and push the fns here.\n+\t(do_get_exception_ptr, do_begin_catch, do_end_catch,\n+\tdo_allocate_exception_ptr, do_free_exception_ptr): Adjust\n+\tdeclare_library_fn use.\n+\t(unevaluated_noexcept_spec): Adjust.\n+\t* cp-gimplify.c (genericize_eh_spec_block,\n+\tgimplify_most_not_throw_expr): Adjust.\n+\n \t* name-lookup.c (pushdecl_top_level,\n \tpushdecl_top_level_and_finish): Move after namespace pushing and\n \tpopping functions."}, {"sha": "898a5ae2ae42cfa3bdf7ea6a1d2ad24735e466ab", "filename": "gcc/cp/cp-gimplify.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a66d857e6bf77a6d5fac3e6feac9951b526fd8b/gcc%2Fcp%2Fcp-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a66d857e6bf77a6d5fac3e6feac9951b526fd8b/gcc%2Fcp%2Fcp-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-gimplify.c?ref=1a66d857e6bf77a6d5fac3e6feac9951b526fd8b", "patch": "@@ -150,7 +150,7 @@ genericize_eh_spec_block (tree *stmt_p)\n {\n   tree body = EH_SPEC_STMTS (*stmt_p);\n   tree allowed = EH_SPEC_RAISES (*stmt_p);\n-  tree failure = build_call_n (call_unexpected_node, 1, build_exc_ptr ());\n+  tree failure = build_call_n (call_unexpected_fn, 1, build_exc_ptr ());\n \n   *stmt_p = build_gimple_eh_filter_tree (body, allowed, failure);\n   TREE_NO_WARNING (*stmt_p) = true;\n@@ -501,7 +501,7 @@ gimplify_must_not_throw_expr (tree *expr_p, gimple_seq *pre_p)\n   gimple *mnt;\n \n   gimplify_and_add (body, &try_);\n-  mnt = gimple_build_eh_must_not_throw (terminate_node);\n+  mnt = gimple_build_eh_must_not_throw (terminate_fn);\n   gimple_seq_add_stmt_without_update (&catch_, mnt);\n   mnt = gimple_build_try (try_, catch_, GIMPLE_TRY_CATCH);\n "}, {"sha": "1981fc01e91dae4113edbe4623317a11c520c4c9", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 26, "deletions": 10, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a66d857e6bf77a6d5fac3e6feac9951b526fd8b/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a66d857e6bf77a6d5fac3e6feac9951b526fd8b/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=1a66d857e6bf77a6d5fac3e6feac9951b526fd8b", "patch": "@@ -153,8 +153,17 @@ enum cp_tree_index\n     CPTI_EMPTY_EXCEPT_SPEC,\n     CPTI_NOEXCEPT_TRUE_SPEC,\n     CPTI_NOEXCEPT_FALSE_SPEC,\n-    CPTI_TERMINATE,\n-    CPTI_CALL_UNEXPECTED,\n+    CPTI_NOEXCEPT_DEFERRED_SPEC,\n+\n+    CPTI_TERMINATE_FN,\n+    CPTI_CALL_UNEXPECTED_FN,\n+    CPTI_GET_EXCEPTION_PTR_FN,\n+    CPTI_BEGIN_CATCH_FN,\n+    CPTI_END_CATCH_FN,\n+    CPTI_ALLOCATE_EXCEPTION_FN,\n+    CPTI_FREE_EXCEPTION_FN,\n+    CPTI_THROW_FN,\n+    CPTI_RETHROW_FN,\n     CPTI_ATEXIT_FN_PTR_TYPE,\n     CPTI_ATEXIT,\n     CPTI_DSO_HANDLE,\n@@ -242,17 +251,24 @@ extern GTY(()) tree cp_global_trees[CPTI_MAX];\n #define lang_name_c\t\t\tcp_global_trees[CPTI_LANG_NAME_C]\n #define lang_name_cplusplus\t\tcp_global_trees[CPTI_LANG_NAME_CPLUSPLUS]\n \n-/* Exception specifiers used for throw(), noexcept(true) and\n-   noexcept(false).  We rely on these being uncloned.  */\n+/* Exception specifiers used for throw(), noexcept(true),\n+   noexcept(false) and deferred noexcept.  We rely on these being\n+   uncloned.  */\n #define empty_except_spec\t\tcp_global_trees[CPTI_EMPTY_EXCEPT_SPEC]\n #define noexcept_true_spec\t\tcp_global_trees[CPTI_NOEXCEPT_TRUE_SPEC]\n #define noexcept_false_spec\t\tcp_global_trees[CPTI_NOEXCEPT_FALSE_SPEC]\n-\n-/* The declaration for `std::terminate'.  */\n-#define terminate_node\t\t\tcp_global_trees[CPTI_TERMINATE]\n-\n-/* The declaration for \"__cxa_call_unexpected\".  */\n-#define call_unexpected_node\t\tcp_global_trees[CPTI_CALL_UNEXPECTED]\n+#define noexcept_deferred_spec\t\tcp_global_trees[CPTI_NOEXCEPT_DEFERRED_SPEC]\n+\n+/* Exception handling function declarations.  */\n+#define terminate_fn\t\t\tcp_global_trees[CPTI_TERMINATE_FN]\n+#define call_unexpected_fn\t\tcp_global_trees[CPTI_CALL_UNEXPECTED_FN]\n+#define get_exception_ptr_fn\t\tcp_global_trees[CPTI_GET_EXCEPTION_PTR_FN]\n+#define begin_catch_fn\t\t\tcp_global_trees[CPTI_BEGIN_CATCH_FN]\n+#define end_catch_fn\t\t\tcp_global_trees[CPTI_END_CATCH_FN]\n+#define allocate_exception_fn\t\tcp_global_trees[CPTI_ALLOCATE_EXCEPTION_FN]\n+#define free_exception_fn\t\tcp_global_trees[CPTI_FREE_EXCEPTION_FN]\n+#define throw_fn\t\t\tcp_global_trees[CPTI_THROW_FN]\n+#define rethrow_fn\t\t\tcp_global_trees[CPTI_RETHROW_FN]\n \n /* The type of the function-pointer argument to \"__cxa_atexit\" (or\n    \"std::atexit\", if \"__cxa_atexit\" is not being used).  */"}, {"sha": "1795e6f1664fa0b376611483fa9ae2791f9cbc0b", "filename": "gcc/cp/except.c", "status": "modified", "additions": 80, "deletions": 134, "changes": 214, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a66d857e6bf77a6d5fac3e6feac9951b526fd8b/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a66d857e6bf77a6d5fac3e6feac9951b526fd8b/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=1a66d857e6bf77a6d5fac3e6feac9951b526fd8b", "patch": "@@ -42,15 +42,6 @@ static int complete_ptr_ref_or_void_ptr_p (tree, tree);\n static bool is_admissible_throw_operand_or_catch_parameter (tree, bool);\n static int can_convert_eh (tree, tree);\n \n-static GTY(()) tree fn1;\n-static GTY(()) tree fn2;\n-static GTY(()) tree fn3;\n-static GTY(()) tree fn4;\n-static GTY(()) tree fn5;\n-static GTY(()) tree throw_fn;\n-static GTY(()) tree rethrow_fn;\n-static GTY(()) tree spec;\n-\n /* Sets up all the global eh stuff that needs to be initialized at the\n    start of compilation.  */\n \n@@ -62,15 +53,15 @@ init_exception_processing (void)\n   /* void std::terminate (); */\n   push_namespace (std_identifier);\n   tmp = build_function_type_list (void_type_node, NULL_TREE);\n-  terminate_node = build_cp_library_fn_ptr (\"terminate\", tmp,\n+  terminate_fn = build_cp_library_fn_ptr (\"terminate\", tmp,\n \t\t\t\t\t   ECF_NOTHROW | ECF_NORETURN);\n-  TREE_THIS_VOLATILE (terminate_node) = 1;\n-  TREE_NOTHROW (terminate_node) = 1;\n+  TREE_THIS_VOLATILE (terminate_fn) = 1;\n+  TREE_NOTHROW (terminate_fn) = 1;\n   pop_namespace ();\n \n   /* void __cxa_call_unexpected(void *); */\n   tmp = build_function_type_list (void_type_node, ptr_type_node, NULL_TREE);\n-  call_unexpected_node\n+  call_unexpected_fn\n     = push_throw_library_fn (get_identifier (\"__cxa_call_unexpected\"), tmp);\n }\n \n@@ -84,7 +75,7 @@ cp_protect_cleanup_actions (void)\n \n      When the destruction of an object during stack unwinding exits\n      using an exception ... void terminate(); is called.  */\n-  return terminate_node;\n+  return terminate_fn;\n }\n \n static tree\n@@ -140,21 +131,39 @@ build_exc_ptr (void)\n \t\t       1, integer_zero_node);\n }\n \n-/* Declare a function NAME, returning RETURN_TYPE, taking a single\n-   parameter PARM_TYPE, with an empty exception specification.\n+/* Find or declare a function NAME, returning RTYPE, taking a single\n+   parameter PTYPE, with an empty exception specification. ECF are the\n+   library fn flags.  If TM_ECF is non-zero, also find or create a\n+   transaction variant and record it as a replacement, when flag_tm is\n+   in effect.\n \n    Note that the C++ ABI document does not have a throw-specifier on\n    the routines declared below via this function.  The declarations\n    are consistent with the actual implementations in libsupc++.  */\n \n static tree\n-declare_library_fn (tree name, tree return_type, tree parm_type, int ecf_flags)\n+declare_library_fn (const char *name, tree rtype, tree ptype,\n+\t\t    int ecf, int tm_ecf)\n {\n-  return push_library_fn (name, build_function_type_list (return_type,\n-\t\t\t\t\t\t\t  parm_type,\n-\t\t\t\t\t\t\t  NULL_TREE),\n-\t\t\t  empty_except_spec,\n-\t\t\t  ecf_flags);\n+  tree ident = get_identifier (name);\n+  tree res = IDENTIFIER_GLOBAL_VALUE (ident);\n+  if (!res)\n+    {\n+      tree type = build_function_type_list (rtype, ptype, NULL_TREE);\n+      tree except = ecf & ECF_NOTHROW ? empty_except_spec : NULL_TREE;\n+      res = push_library_fn (ident, type, except, ecf);\n+      if (tm_ecf && flag_tm)\n+\t{\n+\t  char *tm_name = concat (\"_ITM_\", name + 2, NULL_TREE);\n+\t  tree tm_ident = get_identifier (tm_name);\n+\t  free (tm_name);\n+\t  tree tm_fn = IDENTIFIER_GLOBAL_VALUE (tm_ident);\n+\t  if (!tm_fn)\n+\t    tm_fn = push_library_fn (tm_ident, type, except, ecf | tm_ecf);\n+\t  record_tm_replacement (res, tm_fn);\n+\t}\n+    }\n+  return res;\n }\n \n /* Build up a call to __cxa_get_exception_ptr so that we can build a\n@@ -163,18 +172,16 @@ declare_library_fn (tree name, tree return_type, tree parm_type, int ecf_flags)\n static tree\n do_get_exception_ptr (void)\n {\n-  if (!fn1)\n-    {\n-      tree name = get_identifier (\"__cxa_get_exception_ptr\");\n-      fn1 = IDENTIFIER_GLOBAL_VALUE (name);\n-      if (!fn1)\n-\t/* Declare void* __cxa_get_exception_ptr (void *) throw().  */\n-\tfn1 = declare_library_fn\n-\t  (name, ptr_type_node, ptr_type_node,\n-\t   ECF_NOTHROW | ECF_PURE | ECF_LEAF | ECF_TM_PURE);\n-    }\n-\n-  return cp_build_function_call_nary (fn1, tf_warning_or_error,\n+  if (!get_exception_ptr_fn)\n+    /* Declare void* __cxa_get_exception_ptr (void *) throw().  */\n+    get_exception_ptr_fn\n+      = declare_library_fn (\"__cxa_get_exception_ptr\",\n+\t\t\t    ptr_type_node, ptr_type_node,\n+\t\t\t    ECF_NOTHROW | ECF_PURE | ECF_LEAF | ECF_TM_PURE,\n+\t\t\t    0);\n+\n+  return cp_build_function_call_nary (get_exception_ptr_fn,\n+\t\t\t\t      tf_warning_or_error,\n \t\t\t\t      build_exc_ptr (), NULL_TREE);\n }\n \n@@ -184,31 +191,14 @@ do_get_exception_ptr (void)\n static tree\n do_begin_catch (void)\n {\n-  if (!fn2)\n-    {\n-      tree name = get_identifier (\"__cxa_begin_catch\");\n-      fn2 = IDENTIFIER_GLOBAL_VALUE (name);\n-      if (!fn2)\n-\t{\n-\t  /* Declare void* __cxa_begin_catch (void *) throw().  */\n-\t  fn2 = declare_library_fn\n-\t    (name, ptr_type_node, ptr_type_node, ECF_NOTHROW);\n-\n-\t  /* Create its transactional-memory equivalent.  */\n-\t  if (flag_tm)\n-\t    {\n-\t      tree itm_name = get_identifier (\"_ITM_cxa_begin_catch\");\n-\t      tree itm_fn = IDENTIFIER_GLOBAL_VALUE (itm_name);\n-\t      if (!itm_fn)\n-\t\titm_fn = declare_library_fn\n-\t\t  (itm_name, ptr_type_node, ptr_type_node,\n-\t\t   ECF_NOTHROW | ECF_TM_PURE);\n-\t      record_tm_replacement (fn2, itm_fn);\n-\t    }\n-\t}\n-    }\n-\n-  return cp_build_function_call_nary (fn2, tf_warning_or_error,\n+  if (!begin_catch_fn)\n+    /* Declare void* __cxa_begin_catch (void *) throw().  */\n+    begin_catch_fn\n+      = declare_library_fn (\"__cxa_begin_catch\",\n+\t\t\t    ptr_type_node, ptr_type_node, ECF_NOTHROW,\n+\t\t\t    ECF_TM_PURE);\n+\n+  return cp_build_function_call_nary (begin_catch_fn, tf_warning_or_error,\n \t\t\t\t      build_exc_ptr (), NULL_TREE);\n }\n \n@@ -236,30 +226,15 @@ dtor_nothrow (tree type)\n static tree\n do_end_catch (tree type)\n {\n-  if (!fn3)\n-    {\n-      tree name = get_identifier (\"__cxa_end_catch\");\n-      fn3 = IDENTIFIER_GLOBAL_VALUE (name);\n-      if (!fn3)\n-\t{\n-\t  /* Declare void __cxa_end_catch ().\n-\t     This can throw if the destructor for the exception throws.  */\n-\t  fn3 = push_void_library_fn (name, void_list_node, 0);\n-\n-\t  /* Create its transactional-memory equivalent.  */\n-\t  if (flag_tm)\n-\t    {\n-\t      tree itm_name = get_identifier (\"_ITM_cxa_end_catch\");\n-\t      tree itm_fn = IDENTIFIER_GLOBAL_VALUE (itm_name);\n-\t      if (!itm_fn)\n-\t\titm_fn = push_void_library_fn\n-\t\t  (itm_name, void_list_node, ECF_TM_PURE);\n-\t      record_tm_replacement (fn3, itm_fn);\n-\t    }\n-\t}\n-    }\n-\n-  tree cleanup = cp_build_function_call_vec (fn3, NULL, tf_warning_or_error);\n+  if (!end_catch_fn)\n+    /* Declare void __cxa_end_catch ().\n+       This can throw if the destructor for the exception throws.  */\n+    end_catch_fn\n+      = declare_library_fn (\"__cxa_end_catch\", void_type_node,\n+\t\t\t    NULL_TREE, 0, ECF_TM_PURE);\n+\n+  tree cleanup = cp_build_function_call_vec (end_catch_fn,\n+\t\t\t\t\t     NULL, tf_warning_or_error);\n   TREE_NOTHROW (cleanup) = dtor_nothrow (type);\n \n   return cleanup;\n@@ -519,30 +494,15 @@ finish_eh_spec_block (tree raw_raises, tree eh_spec_block)\n static tree\n do_allocate_exception (tree type)\n {\n-  if (!fn4)\n-    {\n-      tree name = get_identifier (\"__cxa_allocate_exception\");\n-      fn4 = IDENTIFIER_GLOBAL_VALUE (name);\n-      if (!fn4)\n-\t{\n-\t  /* Declare void *__cxa_allocate_exception(size_t) throw().  */\n-\t  fn4 = declare_library_fn (name, ptr_type_node, size_type_node,\n-\t\t\t\t    ECF_NOTHROW | ECF_MALLOC);\n-\n-\t  if (flag_tm)\n-\t    {\n-\t      tree itm_name = get_identifier (\"_ITM_cxa_allocate_exception\");\n-\t      tree itm_fn = IDENTIFIER_GLOBAL_VALUE (itm_name);\n-\t      if (!itm_fn)\n-\t\titm_fn = declare_library_fn\n-\t\t  (itm_name, ptr_type_node, size_type_node, \n-\t\t   ECF_NOTHROW | ECF_MALLOC | ECF_TM_PURE);\n-\t      record_tm_replacement (fn4, itm_fn);\n-\t    }\n-\t}\n-    }\n-\n-  return cp_build_function_call_nary (fn4, tf_warning_or_error,\n+  if (!allocate_exception_fn)\n+    /* Declare void *__cxa_allocate_exception(size_t) throw().  */\n+    allocate_exception_fn\n+      = declare_library_fn (\"__cxa_allocate_exception\",\n+\t\t\t    ptr_type_node, size_type_node,\n+\t\t\t    ECF_NOTHROW | ECF_MALLOC, ECF_TM_PURE);\n+\n+  return cp_build_function_call_nary (allocate_exception_fn,\n+\t\t\t\t      tf_warning_or_error,\n \t\t\t\t      size_in_bytes (type), NULL_TREE);\n }\n \n@@ -552,30 +512,15 @@ do_allocate_exception (tree type)\n static tree\n do_free_exception (tree ptr)\n {\n-  if (!fn5)\n-    {\n-      tree name = get_identifier (\"__cxa_free_exception\");\n-      fn5 = IDENTIFIER_GLOBAL_VALUE (name);\n-      if (!fn5)\n-\t{\n-\t  /* Declare void __cxa_free_exception (void *) throw().  */\n-\t  fn5 = declare_library_fn (name, void_type_node, ptr_type_node,\n-\t\t\t\t    ECF_NOTHROW | ECF_LEAF);\n-\n-\t  if (flag_tm)\n-\t    {\n-\t      tree itm_name = get_identifier (\"_ITM_cxa_free_exception\");\n-\t      tree itm_fn = IDENTIFIER_GLOBAL_VALUE (itm_name);\n-\t      if (!itm_fn)\n-\t\titm_fn = declare_library_fn\n-\t\t  (itm_name, void_type_node, ptr_type_node,\n-\t\t   ECF_NOTHROW | ECF_LEAF | ECF_TM_PURE);\n-\t      record_tm_replacement (fn5, itm_fn);\n-\t    }\n-\t}\n-    }\n-\n-  return cp_build_function_call_nary (fn5, tf_warning_or_error, ptr, NULL_TREE);\n+  if (!free_exception_fn)\n+    /* Declare void __cxa_free_exception (void *) throw().  */\n+    free_exception_fn\n+      = declare_library_fn (\"__cxa_free_exception\",\n+\t\t\t    void_type_node, ptr_type_node,\n+\t\t\t    ECF_NOTHROW | ECF_LEAF, ECF_TM_PURE);\n+\n+  return cp_build_function_call_nary (free_exception_fn,\n+\t\t\t\t      tf_warning_or_error, ptr, NULL_TREE);\n }\n \n /* Wrap all cleanups for TARGET_EXPRs in MUST_NOT_THROW_EXPR.\n@@ -1257,9 +1202,10 @@ build_noexcept_spec (tree expr, int complain)\n tree\n unevaluated_noexcept_spec (void)\n {\n-  if (spec == NULL_TREE)\n-    spec = build_noexcept_spec (make_node (DEFERRED_NOEXCEPT), tf_none);\n-  return spec;\n+  if (!noexcept_deferred_spec)\n+    noexcept_deferred_spec\n+      = build_noexcept_spec (make_node (DEFERRED_NOEXCEPT), tf_none);\n+  return noexcept_deferred_spec;\n }\n \n /* Returns a TRY_CATCH_EXPR that will put TRY_LIST and CATCH_LIST in the"}]}