{"sha": "f1a2d8b1b51ee77499ccf8ed3b4b49ca5307ddb4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjFhMmQ4YjFiNTFlZTc3NDk5Y2NmOGVkM2I0YjQ5Y2E1MzA3ZGRiNA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-02-07T22:04:55Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-02-07T22:04:55Z"}, "message": "runtime: don't call funcPC from a function\n    \n    The escape analysis support is not yet good enough to avoid escaping\n    the argument to funcPC.  This causes unnecessary and often harmful\n    memory allocation.  E.g., (*cpuProfile).addExtra can be called from a\n    signal handler, and it must not allocate memory.\n    \n    Move the calls to funcPC to use variables instead.  This was done in\n    the original migration to using funcPC, but was not done for newer code.\n    \n    In one case, in signal handling code, use getSigtramp.\n    \n    Reviewed-on: https://go-review.googlesource.com/92735\n\nFrom-SVN: r257463", "tree": {"sha": "11e6655920a67f8348528f9cd25ca6b1167eb6d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/11e6655920a67f8348528f9cd25ca6b1167eb6d1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f1a2d8b1b51ee77499ccf8ed3b4b49ca5307ddb4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1a2d8b1b51ee77499ccf8ed3b4b49ca5307ddb4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f1a2d8b1b51ee77499ccf8ed3b4b49ca5307ddb4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1a2d8b1b51ee77499ccf8ed3b4b49ca5307ddb4/comments", "author": null, "committer": null, "parents": [{"sha": "82e259b893021c9b82db80456d409ea6d6bc41d7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82e259b893021c9b82db80456d409ea6d6bc41d7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/82e259b893021c9b82db80456d409ea6d6bc41d7"}], "stats": {"total": 16, "additions": 9, "deletions": 7}, "files": [{"sha": "f1a437706908d7f0c360c1930ce8d398f3ae037a", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1a2d8b1b51ee77499ccf8ed3b4b49ca5307ddb4/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1a2d8b1b51ee77499ccf8ed3b4b49ca5307ddb4/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=f1a2d8b1b51ee77499ccf8ed3b4b49ca5307ddb4", "patch": "@@ -1,4 +1,4 @@\n-5fe998e4a18cc1dbbd4869be5c8202bda55adb33\n+cdc28627b7abfd73f5d552813db8eb4293b823b0\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "b1a7c3bcd1b3519fe28cbadf348f3bf2a2af1632", "filename": "libgo/go/runtime/cpuprof.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1a2d8b1b51ee77499ccf8ed3b4b49ca5307ddb4/libgo%2Fgo%2Fruntime%2Fcpuprof.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1a2d8b1b51ee77499ccf8ed3b4b49ca5307ddb4/libgo%2Fgo%2Fruntime%2Fcpuprof.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fcpuprof.go?ref=f1a2d8b1b51ee77499ccf8ed3b4b49ca5307ddb4", "patch": "@@ -156,8 +156,8 @@ func (p *cpuProfile) addExtra() {\n \tif p.lostExtra > 0 {\n \t\thdr := [1]uint64{p.lostExtra}\n \t\tlostStk := [2]uintptr{\n-\t\t\tfuncPC(_LostExternalCode) + sys.PCQuantum,\n-\t\t\tfuncPC(_ExternalCode) + sys.PCQuantum,\n+\t\t\t_LostExternalCodePC + sys.PCQuantum,\n+\t\t\t_ExternalCodePC + sys.PCQuantum,\n \t\t}\n \t\tcpuprof.log.write(nil, 0, hdr[:], lostStk[:])\n \t\tp.lostExtra = 0\n@@ -167,8 +167,8 @@ func (p *cpuProfile) addExtra() {\n func (p *cpuProfile) addLostAtomic64(count uint64) {\n \thdr := [1]uint64{count}\n \tlostStk := [2]uintptr{\n-\t\tfuncPC(_LostSIGPROFDuringAtomic64) + sys.PCQuantum,\n-\t\tfuncPC(_System) + sys.PCQuantum,\n+\t\t_LostSIGPROFDuringAtomic64PC + sys.PCQuantum,\n+\t\t_SystemPC + sys.PCQuantum,\n \t}\n \tcpuprof.log.write(nil, 0, hdr[:], lostStk[:])\n }"}, {"sha": "edf41405c1c11103f9ab116e5d207c6f4a060eef", "filename": "libgo/go/runtime/proc.go", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1a2d8b1b51ee77499ccf8ed3b4b49ca5307ddb4/libgo%2Fgo%2Fruntime%2Fproc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1a2d8b1b51ee77499ccf8ed3b4b49ca5307ddb4/libgo%2Fgo%2Fruntime%2Fproc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fproc.go?ref=f1a2d8b1b51ee77499ccf8ed3b4b49ca5307ddb4", "patch": "@@ -3369,7 +3369,9 @@ var lostAtomic64Count uint64\n \n var _SystemPC = funcPC(_System)\n var _ExternalCodePC = funcPC(_ExternalCode)\n+var _LostExternalCodePC = funcPC(_LostExternalCode)\n var _GCPC = funcPC(_GC)\n+var _LostSIGPROFDuringAtomic64PC = funcPC(_LostSIGPROFDuringAtomic64)\n \n // Called if we receive a SIGPROF signal.\n // Called by the signal handler, may run during STW.\n@@ -3469,7 +3471,7 @@ func sigprofNonGoPC(pc uintptr) {\n \tif prof.hz != 0 {\n \t\tstk := []uintptr{\n \t\t\tpc,\n-\t\t\tfuncPC(_ExternalCode) + sys.PCQuantum,\n+\t\t\t_ExternalCodePC + sys.PCQuantum,\n \t\t}\n \t\tcpuprof.addNonGo(stk)\n \t}"}, {"sha": "a8f77fa9bcfdc7fec171ff43e379548453c29a74", "filename": "libgo/go/runtime/signal_unix.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1a2d8b1b51ee77499ccf8ed3b4b49ca5307ddb4/libgo%2Fgo%2Fruntime%2Fsignal_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1a2d8b1b51ee77499ccf8ed3b4b49ca5307ddb4/libgo%2Fgo%2Fruntime%2Fsignal_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fsignal_unix.go?ref=f1a2d8b1b51ee77499ccf8ed3b4b49ca5307ddb4", "patch": "@@ -245,7 +245,7 @@ func setProcessCPUProfiler(hz int32) {\n \t\t// Enable the Go signal handler if not enabled.\n \t\tif atomic.Cas(&handlingSig[_SIGPROF], 0, 1) {\n \t\t\tatomic.Storeuintptr(&fwdSig[_SIGPROF], getsig(_SIGPROF))\n-\t\t\tsetsig(_SIGPROF, funcPC(sighandler))\n+\t\t\tsetsig(_SIGPROF, getSigtramp())\n \t\t}\n \t} else {\n \t\t// If the Go signal handler should be disabled by default,"}]}