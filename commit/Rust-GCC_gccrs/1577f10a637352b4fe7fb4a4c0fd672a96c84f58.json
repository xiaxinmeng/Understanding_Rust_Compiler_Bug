{"sha": "1577f10a637352b4fe7fb4a4c0fd672a96c84f58", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTU3N2YxMGE2MzczNTJiNGZlN2ZiNGE0YzBmZDY3MmE5NmM4NGY1OA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2018-03-09T21:40:55Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2018-03-09T21:40:55Z"}, "message": "PR c++/84726 - unnecessary capture of constant vars.\n\n\t* cp-tree.h (LAMBDA_CAPTURE_EXPLICIT_P)\n\t(LAMBDA_EXPR_CAPTURE_OPTIMIZED): New.\n\t* expr.c (mark_use): Set LAMBDA_EXPR_CAPTURE_OPTIMIZED.\n\t* lambda.c (is_constant_capture_proxy)\n\t(current_lambda_expr, var_to_maybe_prune, mark_const_cap_r)\n\t(prune_lambda_captures): New.\n\t(finish_lambda_function): Call prune_lambda_captures.\n\nFrom-SVN: r258398", "tree": {"sha": "afa0946e5089101e7d7a41bfed0009c943fdcfe8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/afa0946e5089101e7d7a41bfed0009c943fdcfe8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1577f10a637352b4fe7fb4a4c0fd672a96c84f58", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1577f10a637352b4fe7fb4a4c0fd672a96c84f58", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1577f10a637352b4fe7fb4a4c0fd672a96c84f58", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1577f10a637352b4fe7fb4a4c0fd672a96c84f58/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5f2440b05799cb854b8d4a7622d50d7abcfecb0f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f2440b05799cb854b8d4a7622d50d7abcfecb0f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f2440b05799cb854b8d4a7622d50d7abcfecb0f"}], "stats": {"total": 190, "additions": 188, "deletions": 2}, "files": [{"sha": "09bd33184820116d8414fed2ff5589236df14902", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1577f10a637352b4fe7fb4a4c0fd672a96c84f58/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1577f10a637352b4fe7fb4a4c0fd672a96c84f58/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=1577f10a637352b4fe7fb4a4c0fd672a96c84f58", "patch": "@@ -1,3 +1,14 @@\n+2018-03-09  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/84726 - unnecessary capture of constant vars.\n+\t* cp-tree.h (LAMBDA_CAPTURE_EXPLICIT_P)\n+\t(LAMBDA_EXPR_CAPTURE_OPTIMIZED): New.\n+\t* expr.c (mark_use): Set LAMBDA_EXPR_CAPTURE_OPTIMIZED.\n+\t* lambda.c (is_constant_capture_proxy)\n+\t(current_lambda_expr, var_to_maybe_prune, mark_const_cap_r)\n+\t(prune_lambda_captures): New.\n+\t(finish_lambda_function): Call prune_lambda_captures.\n+\n 2018-03-09  Jason Merrill  <jason@redhat.com>\n \t    Jakub Jelinek  <jakub@redhat.com>\n "}, {"sha": "4a406d2e9f5bcd57264916ba70f18f3ba364ef1c", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1577f10a637352b4fe7fb4a4c0fd672a96c84f58/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1577f10a637352b4fe7fb4a4c0fd672a96c84f58/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=1577f10a637352b4fe7fb4a4c0fd672a96c84f58", "patch": "@@ -352,6 +352,7 @@ extern GTY(()) tree cp_global_trees[CPTI_MAX];\n       TEMPLATE_PARM_PARAMETER_PACK (in TEMPLATE_PARM_INDEX)\n       ATTR_IS_DEPENDENT (in the TREE_LIST for an attribute)\n       ABI_TAG_IMPLICIT (in the TREE_LIST for the argument of abi_tag)\n+      LAMBDA_CAPTURE_EXPLICIT_P (in a TREE_LIST in LAMBDA_EXPR_CAPTURE_LIST)\n       CONSTRUCTOR_IS_DIRECT_INIT (in CONSTRUCTOR)\n       LAMBDA_EXPR_CAPTURES_THIS_P (in LAMBDA_EXPR)\n       DECLTYPE_FOR_LAMBDA_CAPTURE (in DECLTYPE_TYPE)\n@@ -403,6 +404,7 @@ extern GTY(()) tree cp_global_trees[CPTI_MAX];\n       CONSTRUCTOR_MUTABLE_POISON (in CONSTRUCTOR)\n       OVL_HIDDEN_P (in OVERLOAD)\n       SWITCH_STMT_NO_BREAK_P (in SWITCH_STMT)\n+      LAMBDA_EXPR_CAPTURE_OPTIMIZED (in LAMBDA_EXPR)\n    3: (TREE_REFERENCE_EXPR) (in NON_LVALUE_EXPR) (commented-out).\n       ICS_BAD_FLAG (in _CONV)\n       FN_TRY_BLOCK_P (in TRY_BLOCK)\n@@ -1258,6 +1260,15 @@ enum cp_lambda_default_capture_mode_type {\n #define LAMBDA_EXPR_MUTABLE_P(NODE) \\\n   TREE_LANG_FLAG_1 (LAMBDA_EXPR_CHECK (NODE))\n \n+/* True iff uses of a const variable capture were optimized away.  */\n+#define LAMBDA_EXPR_CAPTURE_OPTIMIZED(NODE) \\\n+  TREE_LANG_FLAG_2 (LAMBDA_EXPR_CHECK (NODE))\n+\n+/* True if this TREE_LIST in LAMBDA_EXPR_CAPTURE_LIST is for an explicit\n+   capture.  */\n+#define LAMBDA_CAPTURE_EXPLICIT_P(NODE) \\\n+  TREE_LANG_FLAG_0 (TREE_LIST_CHECK (NODE))\n+\n /* The source location of the lambda.  */\n #define LAMBDA_EXPR_LOCATION(NODE) \\\n   (((struct tree_lambda_expr *)LAMBDA_EXPR_CHECK (NODE))->locus)\n@@ -6895,13 +6906,15 @@ extern void insert_capture_proxy\t\t(tree);\n extern void insert_pending_capture_proxies\t(void);\n extern bool is_capture_proxy\t\t\t(tree);\n extern bool is_normal_capture_proxy             (tree);\n+extern bool is_constant_capture_proxy           (tree);\n extern void register_capture_members\t\t(tree);\n extern tree lambda_expr_this_capture            (tree, bool);\n extern void maybe_generic_this_capture\t\t(tree, tree);\n extern tree maybe_resolve_dummy\t\t\t(tree, bool);\n extern tree current_nonlambda_function\t\t(void);\n extern tree nonlambda_method_basetype\t\t(void);\n extern tree current_nonlambda_scope\t\t(void);\n+extern tree current_lambda_expr\t\t\t(void);\n extern bool generic_lambda_fn_p\t\t\t(tree);\n extern tree do_dependent_capture\t\t(tree, bool = false);\n extern bool lambda_fn_in_template_p\t\t(tree);"}, {"sha": "15894fc0b594a9f1f2048761ca4d99bfddf68aac", "filename": "gcc/cp/expr.c", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1577f10a637352b4fe7fb4a4c0fd672a96c84f58/gcc%2Fcp%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1577f10a637352b4fe7fb4a4c0fd672a96c84f58/gcc%2Fcp%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexpr.c?ref=1577f10a637352b4fe7fb4a4c0fd672a96c84f58", "patch": "@@ -117,7 +117,15 @@ mark_use (tree expr, bool rvalue_p, bool read_p,\n \t  tree cap = DECL_CAPTURED_VARIABLE (expr);\n \t  if (TREE_CODE (TREE_TYPE (cap)) == TREE_CODE (TREE_TYPE (expr))\n \t      && decl_constant_var_p (cap))\n-\t    return RECUR (cap);\n+\t    {\n+\t      tree val = RECUR (cap);\n+\t      if (!is_capture_proxy (val))\n+\t\t{\n+\t\t  tree l = current_lambda_expr ();\n+\t\t  LAMBDA_EXPR_CAPTURE_OPTIMIZED (l) = true;\n+\t\t}\n+\t      return val;\n+\t    }\n \t}\n       if (outer_automatic_var_p (expr)\n \t  && decl_constant_var_p (expr))\n@@ -160,7 +168,15 @@ mark_use (tree expr, bool rvalue_p, bool read_p,\n \t      tree cap = DECL_CAPTURED_VARIABLE (ref);\n \t      if (TREE_CODE (TREE_TYPE (cap)) != REFERENCE_TYPE\n \t\t  && decl_constant_var_p (cap))\n-\t\treturn RECUR (cap);\n+\t\t{\n+\t\t  tree val = RECUR (cap);\n+\t\t  if (!is_capture_proxy (val))\n+\t\t    {\n+\t\t      tree l = current_lambda_expr ();\n+\t\t      LAMBDA_EXPR_CAPTURE_OPTIMIZED (l) = true;\n+\t\t    }\n+\t\t  return val;\n+\t\t}\n \t    }\n \t  tree r = mark_rvalue_use (ref, loc, reject_builtin);\n \t  if (r != ref)"}, {"sha": "de064ffc85e48ce7a013cfe7bacde16749a4f422", "filename": "gcc/cp/lambda.c", "status": "modified", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1577f10a637352b4fe7fb4a4c0fd672a96c84f58/gcc%2Fcp%2Flambda.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1577f10a637352b4fe7fb4a4c0fd672a96c84f58/gcc%2Fcp%2Flambda.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flambda.c?ref=1577f10a637352b4fe7fb4a4c0fd672a96c84f58", "patch": "@@ -291,6 +291,17 @@ is_normal_capture_proxy (tree decl)\n   return DECL_NORMAL_CAPTURE_P (val);\n }\n \n+/* Returns true iff DECL is a capture proxy for a normal capture\n+   of a constant variable.  */\n+\n+bool\n+is_constant_capture_proxy (tree decl)\n+{\n+  if (is_normal_capture_proxy (decl))\n+    return decl_constant_var_p (DECL_CAPTURED_VARIABLE (decl));\n+  return false;\n+}\n+\n /* VAR is a capture proxy created by build_capture_proxy; add it to the\n    current function, which is the operator() for the appropriate lambda.  */\n \n@@ -650,6 +661,7 @@ add_capture (tree lambda, tree id, tree orig_init, bool by_reference_p,\n     return build_capture_proxy (member, initializer);\n   /* For explicit captures we haven't started the function yet, so we wait\n      and build the proxy from cp_parser_lambda_body.  */\n+  LAMBDA_CAPTURE_EXPLICIT_P (LAMBDA_EXPR_CAPTURE_LIST (lambda)) = true;\n   return NULL_TREE;\n }\n \n@@ -840,6 +852,20 @@ lambda_expr_this_capture (tree lambda, bool add_capture_p)\n   return result;\n }\n \n+/* Return the innermost LAMBDA_EXPR we're currently in, if any.  */\n+\n+tree\n+current_lambda_expr (void)\n+{\n+  tree type = current_class_type;\n+  while (type && !LAMBDA_TYPE_P (type))\n+    type = decl_type_context (TYPE_NAME (type));\n+  if (type)\n+    return CLASSTYPE_LAMBDA_EXPR (type);\n+  else\n+    return NULL_TREE;\n+}\n+\n /* Return the current LAMBDA_EXPR, if this is a resolvable dummy\n    object.  NULL otherwise..  */\n \n@@ -1374,11 +1400,120 @@ start_lambda_function (tree fco, tree lambda_expr)\n   return body;\n }\n \n+/* Subroutine of prune_lambda_captures: CAP is a node in\n+   LAMBDA_EXPR_CAPTURE_LIST.  Return the variable it captures for which we\n+   might optimize away the capture, or NULL_TREE if there is no such\n+   variable.  */\n+\n+static tree\n+var_to_maybe_prune (tree cap)\n+{\n+  if (LAMBDA_CAPTURE_EXPLICIT_P (cap))\n+    /* Don't prune explicit captures.  */\n+    return NULL_TREE;\n+\n+  tree mem = TREE_PURPOSE (cap);\n+  if (!DECL_P (mem) || !DECL_NORMAL_CAPTURE_P (mem))\n+    /* Packs and init-captures aren't captures of constant vars.  */\n+    return NULL_TREE;\n+\n+  tree init = TREE_VALUE (cap);\n+  if (is_normal_capture_proxy (init))\n+    init = DECL_CAPTURED_VARIABLE (init);\n+  if (decl_constant_var_p (init))\n+    return init;\n+\n+  return NULL_TREE;\n+}\n+\n+/* walk_tree helper for prune_lambda_captures: Remember which capture proxies\n+   for constant variables are actually used in the lambda body.\n+\n+   There will always be a DECL_EXPR for the capture proxy; remember it when we\n+   see it, but replace it with any other use.  */\n+\n+static tree\n+mark_const_cap_r (tree *t, int *walk_subtrees, void *data)\n+{\n+  hash_map<tree,tree*> &const_vars = *(hash_map<tree,tree*>*)data;\n+\n+  tree var = NULL_TREE;\n+  if (TREE_CODE (*t) == DECL_EXPR)\n+    {\n+      tree decl = DECL_EXPR_DECL (*t);\n+      if (is_constant_capture_proxy (decl))\n+\tvar = DECL_CAPTURED_VARIABLE (decl);\n+      *walk_subtrees = 0;\n+    }\n+  else if (is_constant_capture_proxy (*t))\n+    var = DECL_CAPTURED_VARIABLE (*t);\n+\n+  if (var)\n+    {\n+      tree *&slot = const_vars.get_or_insert (var);\n+      if (!slot || VAR_P (*t))\n+\tslot = t;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* We're at the end of processing a lambda; go back and remove any captures of\n+   constant variables for which we've folded away all uses.  */\n+\n+static void\n+prune_lambda_captures (tree body)\n+{\n+  tree lam = current_lambda_expr ();\n+  if (!LAMBDA_EXPR_CAPTURE_OPTIMIZED (lam))\n+    /* No uses were optimized away.  */\n+    return;\n+  if (LAMBDA_EXPR_DEFAULT_CAPTURE_MODE (lam) == CPLD_NONE)\n+    /* No default captures, and we don't prune explicit captures.  */\n+    return;\n+\n+  hash_map<tree,tree*> const_vars;\n+\n+  cp_walk_tree_without_duplicates (&body, mark_const_cap_r, &const_vars);\n+\n+  tree *fieldp = &TYPE_FIELDS (LAMBDA_EXPR_CLOSURE (lam));\n+  for (tree *capp = &LAMBDA_EXPR_CAPTURE_LIST (lam); *capp; )\n+    {\n+      tree cap = *capp;\n+      if (tree var = var_to_maybe_prune (cap))\n+\t{\n+\t  tree *use = *const_vars.get (var);\n+\t  if (TREE_CODE (*use) == DECL_EXPR)\n+\t    {\n+\t      /* All uses of this capture were folded away, leaving only the\n+\t\t proxy declaration.  */\n+\n+\t      /* Splice the capture out of LAMBDA_EXPR_CAPTURE_LIST.  */\n+\t      *capp = TREE_CHAIN (cap);\n+\n+\t      /* And out of TYPE_FIELDS.  */\n+\t      tree field = TREE_PURPOSE (cap);\n+\t      while (*fieldp != field)\n+\t\tfieldp = &DECL_CHAIN (*fieldp);\n+\t      *fieldp = DECL_CHAIN (*fieldp);\n+\n+\t      /* And remove the capture proxy declaration.  */\n+\t      *use = void_node;\n+\t      continue;\n+\t    }\n+\t}\n+\n+      capp = &TREE_CHAIN (cap);\n+    }\n+}\n+\n void\n finish_lambda_function (tree body)\n {\n   finish_function_body (body);\n \n+  prune_lambda_captures (body);\n+\n   /* Finish the function and generate code for it if necessary.  */\n   tree fn = finish_function (/*inline_p=*/true);\n "}, {"sha": "ad86eff876b493b27c1780e787d703e341a43723", "filename": "gcc/testsuite/g++.dg/abi/lambda-capture1.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1577f10a637352b4fe7fb4a4c0fd672a96c84f58/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Flambda-capture1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1577f10a637352b4fe7fb4a4c0fd672a96c84f58/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Flambda-capture1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Flambda-capture1.C?ref=1577f10a637352b4fe7fb4a4c0fd672a96c84f58", "patch": "@@ -0,0 +1,11 @@\n+// PR c++/84726\n+// { dg-do compile { target c++11 } }\n+\n+#define SA(X) static_assert (X, #X)\n+\n+int main()\n+{ \n+  const int i = 42;\n+  auto l = [=]{return i+i;};\n+  SA(sizeof(l) == 1);\n+}"}]}