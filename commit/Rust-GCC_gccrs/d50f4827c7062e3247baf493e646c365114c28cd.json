{"sha": "d50f4827c7062e3247baf493e646c365114c28cd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDUwZjQ4MjdjNzA2MmUzMjQ3YmFmNDkzZTY0NmMzNjUxMTRjMjhjZA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-05T14:29:43Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-05T14:29:43Z"}, "message": "[multiple changes]\n\n2011-08-05  Bob Duff  <duff@adacore.com>\n\n\t* sinfo.ads, sinfo.adb (Subpool_Handle_Name): New attribute for\n\tsubpools.\n\t* par-ch4.adb (P_Allocator): Parse new subpool specification syntax.\n\n2011-08-05  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch4.adb (Try_Container_Indexing): New procedure to implement the\n\tgeneral indexing aspects of Ada2012. Called when analyzing indexed\n\tcomponents when other interpretations fail.\n\t* sem_ch8.adb (Find_Direct_Name): check for implicit dereference only\n\tin an expression context where overloading is meaningful. This excludes\n\tthe occurrence in an aspect specification (efficiency only).\n\t* sem_attr.adb (Analyze_Attribute): indicate that the attributes\n\trelated to iterators can be set by an attribute specification, but\n\tcannot be queried.\n\t* sem_ch13.adb (Analyze_Aspect_Specifications): handle\n\tConstant_Indexing and Variable_Indexing.\n\t(Check_Indexing_Functions): New procedure to perform legality checks.\n\tAdditional semantic checks at end of declarations.\n\nFrom-SVN: r177446", "tree": {"sha": "e4f47a16c8f93fc574f67b26cbcf1e9166278c08", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e4f47a16c8f93fc574f67b26cbcf1e9166278c08"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d50f4827c7062e3247baf493e646c365114c28cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d50f4827c7062e3247baf493e646c365114c28cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d50f4827c7062e3247baf493e646c365114c28cd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d50f4827c7062e3247baf493e646c365114c28cd/comments", "author": null, "committer": null, "parents": [{"sha": "efe05dfc95b60b57abb6c57055982e25dc09c91e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/efe05dfc95b60b57abb6c57055982e25dc09c91e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/efe05dfc95b60b57abb6c57055982e25dc09c91e"}], "stats": {"total": 395, "additions": 371, "deletions": 24}, "files": [{"sha": "ce02f4f2889adf7e20d42f48421aa0dfa18d407f", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d50f4827c7062e3247baf493e646c365114c28cd/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d50f4827c7062e3247baf493e646c365114c28cd/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=d50f4827c7062e3247baf493e646c365114c28cd", "patch": "@@ -1,3 +1,25 @@\n+2011-08-05  Bob Duff  <duff@adacore.com>\n+\n+\t* sinfo.ads, sinfo.adb (Subpool_Handle_Name): New attribute for\n+\tsubpools.\n+\t* par-ch4.adb (P_Allocator): Parse new subpool specification syntax.\n+\n+2011-08-05  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch4.adb (Try_Container_Indexing): New procedure to implement the\n+\tgeneral indexing aspects of Ada2012. Called when analyzing indexed\n+\tcomponents when other interpretations fail.\n+\t* sem_ch8.adb (Find_Direct_Name): check for implicit dereference only\n+\tin an expression context where overloading is meaningful. This excludes\n+\tthe occurrence in an aspect specification (efficiency only).\n+\t* sem_attr.adb (Analyze_Attribute): indicate that the attributes\n+\trelated to iterators can be set by an attribute specification, but\n+\tcannot be queried.\n+\t* sem_ch13.adb (Analyze_Aspect_Specifications): handle\n+\tConstant_Indexing and Variable_Indexing.\n+\t(Check_Indexing_Functions): New procedure to perform legality checks.\n+\tAdditional semantic checks at end of declarations.\n+\n 2011-08-05  Sergey Rybin  <rybin@adacore.com>\n \n \t* tree_io.ads: Update ASIS_Version_Number because of the change of the"}, {"sha": "cbe68cfddaa150e399333ecfe4a0a92f6d8b4e13", "filename": "gcc/ada/par-ch4.adb", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d50f4827c7062e3247baf493e646c365114c28cd/gcc%2Fada%2Fpar-ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d50f4827c7062e3247baf493e646c365114c28cd/gcc%2Fada%2Fpar-ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch4.adb?ref=d50f4827c7062e3247baf493e646c365114c28cd", "patch": "@@ -2810,7 +2810,10 @@ package body Ch4 is\n    --------------------\n \n    --  ALLOCATOR ::=\n-   --    new [NULL_EXCLUSION] SUBTYPE_INDICATION | new QUALIFIED_EXPRESSION\n+   --      new [SUBPOOL_SPECIFICATION] SUBTYPE_INDICATION\n+   --    | new [SUBPOOL_SPECIFICATION] QUALIFIED_EXPRESSION\n+   --\n+   --  SUBPOOL_SPECIFICATION ::= (subpool_handle_NAME)\n \n    --  The caller has checked that the initial token is NEW\n \n@@ -2825,8 +2828,25 @@ package body Ch4 is\n       Alloc_Node := New_Node (N_Allocator, Token_Ptr);\n       T_New;\n \n+      --  Scan subpool_specification if present (Ada 2012 (AI05-0111-3))\n+\n       --  Scan Null_Exclusion if present (Ada 2005 (AI-231))\n \n+      if Token = Tok_Left_Paren then\n+         Scan; -- past (\n+         Set_Subpool_Handle_Name (Alloc_Node, P_Name);\n+         T_Right_Paren;\n+\n+         if Ada_Version < Ada_2012 then\n+            Error_Msg_N\n+              (\"|subpool specification is an Ada 2012 feature\",\n+               Subpool_Handle_Name (Alloc_Node));\n+            Error_Msg_N\n+              (\"\\|unit must be compiled with -gnat2012 switch\",\n+               Subpool_Handle_Name (Alloc_Node));\n+         end if;\n+      end if;\n+\n       Null_Exclusion_Present := P_Null_Exclusion;\n       Set_Null_Exclusion_Present (Alloc_Node, Null_Exclusion_Present);\n       Type_Node := P_Subtype_Mark_Resync;"}, {"sha": "5195e4f3a88da469d5fb557d62afdc996c0aa232", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d50f4827c7062e3247baf493e646c365114c28cd/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d50f4827c7062e3247baf493e646c365114c28cd/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=d50f4827c7062e3247baf493e646c365114c28cd", "patch": "@@ -2110,13 +2110,15 @@ package body Sem_Attr is\n \n       case Attr_Id is\n \n-         --  Attributes related to Ada2012 iterators (placeholder ???)\n-\n-         when Attribute_Constant_Indexing    => null;\n-         when Attribute_Default_Iterator     => null;\n-         when Attribute_Implicit_Dereference => null;\n-         when Attribute_Iterator_Element     => null;\n-         when Attribute_Variable_Indexing    => null;\n+         --  Attributes related to Ada2012 iterators. Attribute specifications\n+         --  exist for these, but they cannot be queried.\n+\n+         when Attribute_Constant_Indexing    |\n+              Attribute_Default_Iterator     |\n+              Attribute_Implicit_Dereference |\n+              Attribute_Iterator_Element     |\n+              Attribute_Variable_Indexing    =>\n+            Error_Msg_N (\"illegal attribute\", N);\n \n       ------------------\n       -- Abort_Signal --"}, {"sha": "f2075d0cae95d193f034e231e2cee02848ec0617", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 147, "deletions": 13, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d50f4827c7062e3247baf493e646c365114c28cd/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d50f4827c7062e3247baf493e646c365114c28cd/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=d50f4827c7062e3247baf493e646c365114c28cd", "patch": "@@ -946,13 +946,36 @@ package body Sem_Ch13 is\n \n                   Delay_Required := False;\n \n-               --  Aspects related to container iterators (fill in later???)\n+               --  Aspects related to container iterators. These aspects denote\n+               --  subprograms, and thus must be delayed.\n \n                when Aspect_Constant_Indexing    |\n-                    Aspect_Default_Iterator     |\n-                    Aspect_Iterator_Element     |\n                     Aspect_Variable_Indexing    =>\n-                  null;\n+\n+                  if not Is_Type (E) or else not Is_Tagged_Type (E) then\n+                     Error_Msg_N (\"indexing applies to a tagged type\", N);\n+                  end if;\n+\n+                  Aitem :=\n+                    Make_Attribute_Definition_Clause (Loc,\n+                      Name       => Ent,\n+                      Chars      => Chars (Id),\n+                      Expression => Relocate_Node (Expr));\n+\n+                  Delay_Required := True;\n+                  Set_Is_Delayed_Aspect (Aspect);\n+\n+               when Aspect_Default_Iterator     |\n+                    Aspect_Iterator_Element     =>\n+\n+                  Aitem :=\n+                    Make_Attribute_Definition_Clause (Loc,\n+                      Name       => Ent,\n+                      Chars      => Chars (Id),\n+                      Expression => Relocate_Node (Expr));\n+\n+                  Delay_Required := True;\n+                  Set_Is_Delayed_Aspect (Aspect);\n \n                when Aspect_Implicit_Dereference =>\n                   if not Is_Type (E)\n@@ -1511,6 +1534,11 @@ package body Sem_Ch13 is\n       --  and if so gives an error message. If there is a duplicate, True is\n       --  returned, otherwise if there is no error, False is returned.\n \n+      procedure Check_Indexing_Functions;\n+      --  Check that the function in Constant_Indexing or Variable_Indexing\n+      --  attribute has the proper type structure. If the name is overloaded,\n+      --  check that all interpretations are legal.\n+\n       -----------------------------------\n       -- Analyze_Stream_TSS_Definition --\n       -----------------------------------\n@@ -1648,6 +1676,89 @@ package body Sem_Ch13 is\n          end if;\n       end Analyze_Stream_TSS_Definition;\n \n+      ------------------------------\n+      -- Check_Indexing_Functions --\n+      ------------------------------\n+\n+      procedure Check_Indexing_Functions is\n+         Ctrl : Entity_Id;\n+\n+         procedure Check_One_Function (Subp : Entity_Id);\n+         --  Check one possible interpretation\n+\n+         ------------------------\n+         -- Check_One_Function --\n+         ------------------------\n+\n+         procedure Check_One_Function (Subp : Entity_Id) is\n+         begin\n+            if Ekind (Subp) /= E_Function then\n+               Error_Msg_N (\"indexing requires a function\", Subp);\n+            end if;\n+\n+            if No (First_Formal (Subp)) then\n+               Error_Msg_N\n+                 (\"function for indexing must have parameters\", Subp);\n+            else\n+               Ctrl := Etype (First_Formal (Subp));\n+            end if;\n+\n+            if Ctrl = Ent\n+              or else Ctrl = Class_Wide_Type (Ent)\n+              or else\n+                (Ekind (Ctrl) = E_Anonymous_Access_Type\n+                  and then\n+                    (Designated_Type (Ctrl) = Ent\n+                      or else Designated_Type (Ctrl) = Class_Wide_Type (Ent)))\n+            then\n+               null;\n+\n+            else\n+               Error_Msg_N (\"indexing function must apply to type&\", Subp);\n+            end if;\n+\n+            if No (Next_Formal (First_Formal (Subp))) then\n+               Error_Msg_N\n+                 (\"function for indexing must have two parameters\", Subp);\n+            end if;\n+\n+            if not Has_Implicit_Dereference (Etype (Subp)) then\n+               Error_Msg_N\n+                 (\"function for indexing must return a reference type\", Subp);\n+            end if;\n+         end Check_One_Function;\n+\n+      --  Start of processing for Check_Indexing_Functions\n+\n+      begin\n+         Analyze (Expr);\n+\n+         if not Is_Overloaded (Expr) then\n+            Check_One_Function (Entity (Expr));\n+\n+         else\n+            declare\n+               I : Interp_Index;\n+               It : Interp;\n+\n+            begin\n+               Get_First_Interp (Expr, I, It);\n+               while Present (It.Nam) loop\n+\n+                  --  Note that analysis will have added the interpretation\n+                  --  that corresponds to the dereference. We only check the\n+                  --  subprogram itself.\n+\n+                  if Is_Overloadable (It.Nam) then\n+                     Check_One_Function (It.Nam);\n+                  end if;\n+\n+                  Get_Next_Interp (I, It);\n+               end loop;\n+            end;\n+         end if;\n+      end Check_Indexing_Functions;\n+\n       ----------------------\n       -- Duplicate_Clause --\n       ----------------------\n@@ -2267,6 +2378,13 @@ package body Sem_Ch13 is\n             end if;\n          end Component_Size_Case;\n \n+         -----------------------\n+         -- Constant_Indexing --\n+         -----------------------\n+\n+         when Attribute_Constant_Indexing =>\n+            Check_Indexing_Functions;\n+\n          ------------------\n          -- External_Tag --\n          ------------------\n@@ -2845,6 +2963,13 @@ package body Sem_Ch13 is\n             end if;\n          end Value_Size;\n \n+         -----------------------\n+         -- Variable_Indexing --\n+         -----------------------\n+\n+         when Attribute_Variable_Indexing =>\n+            Check_Indexing_Functions;\n+\n          -----------\n          -- Write --\n          -----------\n@@ -5381,6 +5506,13 @@ package body Sem_Ch13 is\n          Analyze (End_Decl_Expr);\n          Err := Entity (End_Decl_Expr) /= Entity (Freeze_Expr);\n \n+      elsif A_Id = Aspect_Variable_Indexing or else\n+            A_Id = Aspect_Constant_Indexing\n+      then\n+         Analyze (End_Decl_Expr);\n+         Analyze (Aspect_Rep_Item (ASN));\n+         Err := Entity (End_Decl_Expr) /= Entity (Freeze_Expr);\n+\n       --  All other cases\n \n       else\n@@ -5485,15 +5617,6 @@ package body Sem_Ch13 is\n               Aspect_Value_Size     =>\n             T := Any_Integer;\n \n-         --  Following to be done later ???\n-\n-         when Aspect_Constant_Indexing    |\n-              Aspect_Default_Iterator     |\n-              Aspect_Iterator_Element     |\n-              Aspect_Implicit_Dereference |\n-              Aspect_Variable_Indexing    =>\n-            null;\n-\n          --  Stream attribute. Special case, the expression is just an entity\n          --  that does not need any resolution, so just analyze.\n \n@@ -5504,6 +5627,17 @@ package body Sem_Ch13 is\n             Analyze (Expression (ASN));\n             return;\n \n+         --  Same for Iterator aspects, where the expression is a function\n+         --  name. Legality rules are checked separately.\n+\n+         when Aspect_Constant_Indexing    |\n+              Aspect_Default_Iterator     |\n+              Aspect_Iterator_Element     |\n+              Aspect_Implicit_Dereference |\n+              Aspect_Variable_Indexing    =>\n+            Analyze (Expression (ASN));\n+            return;\n+\n          --  Suppress/Unsuppress/Warnings should never be delayed\n \n          when Aspect_Suppress   |"}, {"sha": "3d7b48ff075cd3e05ca7df3f688d5cb487e47ffb", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d50f4827c7062e3247baf493e646c365114c28cd/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d50f4827c7062e3247baf493e646c365114c28cd/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=d50f4827c7062e3247baf493e646c365114c28cd", "patch": "@@ -23,6 +23,7 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+with Aspects;  use Aspects;\n with Atree;    use Atree;\n with Debug;    use Debug;\n with Einfo;    use Einfo;\n@@ -248,6 +249,12 @@ package body Sem_Ch4 is\n    --  Ada 2005: implementation of AI-310. An abstract non-dispatching\n    --  operation is not a candidate interpretation.\n \n+   function Try_Container_Indexing\n+     (N      : Node_Id;\n+      Prefix : Node_Id;\n+      Expr   : Node_Id) return Boolean;\n+   --  AI05-0139: Generalized indexing to support iterators over containers\n+\n    function Try_Indexed_Call\n      (N          : Node_Id;\n       Nam        : Entity_Id;\n@@ -2032,6 +2039,9 @@ package body Sem_Ch4 is\n             then\n                return;\n \n+            elsif Try_Container_Indexing (N, P, Exp) then\n+               return;\n+\n             elsif Array_Type = Any_Type then\n                Set_Etype (N, Any_Type);\n \n@@ -6270,6 +6280,130 @@ package body Sem_Ch4 is\n       end if;\n    end Remove_Abstract_Operations;\n \n+   ----------------------------\n+   -- Try_Container_Indexing --\n+   ----------------------------\n+\n+   function Try_Container_Indexing\n+     (N      : Node_Id;\n+      Prefix : Node_Id;\n+      Expr   : Node_Id) return Boolean\n+   is\n+      Loc       : constant Source_Ptr := Sloc (N);\n+      Disc      : Entity_Id;\n+      Func      : Entity_Id;\n+      Func_Name : Node_Id;\n+      Indexing  : Node_Id;\n+      Is_Var    : Boolean;\n+      Ritem     : Node_Id;\n+\n+   begin\n+\n+      --  Check whether type has a specified indexing aspect.\n+\n+      Func_Name := Empty;\n+      Is_Var := False;\n+      Ritem := First_Rep_Item (Etype (Prefix));\n+\n+      while Present (Ritem) loop\n+         if Nkind (Ritem) = N_Aspect_Specification then\n+\n+            --  Prefer Variable_Indexing, but will settle for Constant.\n+\n+            if Get_Aspect_Id (Chars (Identifier (Ritem))) =\n+              Aspect_Constant_Indexing\n+            then\n+               Func_Name := Expression (Ritem);\n+\n+            elsif Get_Aspect_Id (Chars (Identifier (Ritem))) =\n+              Aspect_Variable_Indexing\n+            then\n+               Func_Name :=  Expression (Ritem);\n+               Is_Var := True;\n+               exit;\n+            end if;\n+         end if;\n+         Next_Rep_Item (Ritem);\n+      end loop;\n+\n+      --  If aspect does not exist the expression is illegal. Error is\n+      --  diagnosed in caller.\n+\n+      if No (Func_Name) then\n+         return False;\n+      end if;\n+\n+      if Is_Var\n+        and then not Is_Variable (Prefix)\n+      then\n+         Error_Msg_N (\"Variable indexing cannot be applied to a constant\", N);\n+      end if;\n+\n+      if not Is_Overloaded (Func_Name) then\n+         Func := Entity (Func_Name);\n+         Indexing := Make_Function_Call (Loc,\n+           Name => New_Occurrence_Of (Func, Loc),\n+           Parameter_Associations =>\n+             New_List (Relocate_Node (Prefix), Relocate_Node (Expr)));\n+         Rewrite (N, Indexing);\n+         Analyze (N);\n+\n+         --  The return type of the indexing function is a reference type, so\n+         --  add the dereference as a possible interpretation.\n+\n+         Disc := First_Discriminant (Etype (Func));\n+         while Present (Disc) loop\n+            if Has_Implicit_Dereference (Disc) then\n+               Add_One_Interp (N, Disc, Designated_Type (Etype (Disc)));\n+               exit;\n+            end if;\n+\n+            Next_Discriminant (Disc);\n+         end loop;\n+\n+      else\n+         Indexing := Make_Function_Call (Loc,\n+           Name => Make_Identifier (Loc, Chars (Func_Name)),\n+           Parameter_Associations =>\n+             New_List (Relocate_Node (Prefix), Relocate_Node (Expr)));\n+\n+         Rewrite (N, Indexing);\n+\n+         declare\n+            I  : Interp_Index;\n+            It : Interp;\n+            Success : Boolean;\n+\n+         begin\n+            Get_First_Interp (Func_Name, I, It);\n+            Set_Etype (N, Any_Type);\n+            while Present (It.Nam) loop\n+               Analyze_One_Call (N, It.Nam, False, Success);\n+               if Success then\n+                  Set_Etype (Name (N), It.Typ);\n+\n+                  --  Add implicit dereference interpretation.\n+\n+                  Disc := First_Discriminant (Etype (It.Nam));\n+\n+                  while Present (Disc) loop\n+                     if Has_Implicit_Dereference (Disc) then\n+                        Add_One_Interp\n+                          (N, Disc, Designated_Type (Etype (Disc)));\n+                        exit;\n+                     end if;\n+\n+                     Next_Discriminant (Disc);\n+                  end loop;\n+               end if;\n+               Get_Next_Interp (I, It);\n+            end loop;\n+         end;\n+      end if;\n+\n+      return True;\n+   end Try_Container_Indexing;\n+\n    -----------------------\n    -- Try_Indirect_Call --\n    -----------------------"}, {"sha": "cf623bef718672b9df4a7ea5d3e341fd0c5c610c", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d50f4827c7062e3247baf493e646c365114c28cd/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d50f4827c7062e3247baf493e646c365114c28cd/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=d50f4827c7062e3247baf493e646c365114c28cd", "patch": "@@ -4818,7 +4818,12 @@ package body Sem_Ch8 is\n             end if;\n \n             Set_Entity_Or_Discriminal (N, E);\n-            Check_Implicit_Dereference (N, Etype (E));\n+\n+            if Ada_Version >= Ada_2012\n+              and then Nkind (Parent (N)) in N_Subexpr\n+            then\n+               Check_Implicit_Dereference (N, Etype (E));\n+            end if;\n          end if;\n       end;\n    end Find_Direct_Name;"}, {"sha": "73b848946f2a22698f58a09ad8a241d8fdf3d2f5", "filename": "gcc/ada/sinfo.adb", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d50f4827c7062e3247baf493e646c365114c28cd/gcc%2Fada%2Fsinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d50f4827c7062e3247baf493e646c365114c28cd/gcc%2Fada%2Fsinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.adb?ref=d50f4827c7062e3247baf493e646c365114c28cd", "patch": "@@ -2844,6 +2844,14 @@ package body Sinfo is\n       return Node1 (N);\n    end Storage_Pool;\n \n+   function Subpool_Handle_Name\n+      (N : Node_Id) return Node_Id is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Allocator);\n+      return Node4 (N);\n+   end Subpool_Handle_Name;\n+\n    function Strval\n       (N : Node_Id) return String_Id is\n    begin\n@@ -5886,6 +5894,14 @@ package body Sinfo is\n       Set_Node1 (N, Val); -- semantic field, no parent set\n    end Set_Storage_Pool;\n \n+   procedure Set_Subpool_Handle_Name\n+      (N : Node_Id; Val : Node_Id) is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Allocator);\n+      Set_Node4_With_Parent (N, Val);\n+   end Set_Subpool_Handle_Name;\n+\n    procedure Set_Strval\n       (N : Node_Id; Val : String_Id) is\n    begin"}, {"sha": "eca688af230693dd68ed6d18f18a98c06f7ca6de", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d50f4827c7062e3247baf493e646c365114c28cd/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d50f4827c7062e3247baf493e646c365114c28cd/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=d50f4827c7062e3247baf493e646c365114c28cd", "patch": "@@ -3933,14 +3933,20 @@ package Sinfo is\n       --------------------\n \n       --  ALLOCATOR ::=\n-      --    new [NULL_EXCLUSION] SUBTYPE_INDICATION | new QUALIFIED_EXPRESSION\n+      --      new [SUBPOOL_SPECIFICATION] SUBTYPE_INDICATION\n+      --    | new [SUBPOOL_SPECIFICATION] QUALIFIED_EXPRESSION\n+      --\n+      --  SUBPOOL_SPECIFICATION ::= (subpool_handle_NAME)\n \n       --  Sprint syntax (when storage pool present)\n       --    new xxx (storage_pool = pool)\n+      --  or\n+      --    new (subpool) xxx (storage_pool = pool)\n \n       --  N_Allocator\n       --  Sloc points to NEW\n       --  Expression (Node3) subtype indication or qualified expression\n+      --  Subpool_Handle_Name (Node4) (set to Empty if not present)\n       --  Storage_Pool (Node1-Sem)\n       --  Procedure_To_Call (Node2-Sem)\n       --  Null_Exclusion_Present (Flag11)\n@@ -8911,6 +8917,9 @@ package Sinfo is\n    function Storage_Pool\n      (N : Node_Id) return Node_Id;    -- Node1\n \n+   function Subpool_Handle_Name\n+     (N : Node_Id) return Node_Id;    -- Node4\n+\n    function Strval\n      (N : Node_Id) return String_Id;  -- Str3\n \n@@ -9880,6 +9889,9 @@ package Sinfo is\n    procedure Set_Storage_Pool\n      (N : Node_Id; Val : Node_Id);            -- Node1\n \n+   procedure Set_Subpool_Handle_Name\n+     (N : Node_Id; Val : Node_Id);            -- Node4\n+\n    procedure Set_Strval\n      (N : Node_Id; Val : String_Id);          -- Str3\n \n@@ -10656,7 +10668,7 @@ package Sinfo is\n        (1 => False,   --  Storage_Pool (Node1-Sem)\n         2 => False,   --  Procedure_To_Call (Node2-Sem)\n         3 => True,    --  Expression (Node3)\n-        4 => False,   --  unused\n+        4 => True,    --  Subpool_Handle_Name (Node4)\n         5 => False),  --  Etype (Node5-Sem)\n \n      N_Null_Statement =>\n@@ -11997,6 +12009,7 @@ package Sinfo is\n    pragma Inline (Statements);\n    pragma Inline (Static_Processing_OK);\n    pragma Inline (Storage_Pool);\n+   pragma Inline (Subpool_Handle_Name);\n    pragma Inline (Strval);\n    pragma Inline (Subtype_Indication);\n    pragma Inline (Subtype_Mark);\n@@ -12316,6 +12329,7 @@ package Sinfo is\n    pragma Inline (Set_Statements);\n    pragma Inline (Set_Static_Processing_OK);\n    pragma Inline (Set_Storage_Pool);\n+   pragma Inline (Set_Subpool_Handle_Name);\n    pragma Inline (Set_Strval);\n    pragma Inline (Set_Subtype_Indication);\n    pragma Inline (Set_Subtype_Mark);"}]}