{"sha": "c56c2073a6268960931acd0b852b6186d4bde179", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzU2YzIwNzNhNjI2ODk2MDkzMWFjZDBiODUyYjYxODZkNGJkZTE3OQ==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@wolery.cumb.org", "date": "2000-05-02T16:09:12Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2000-05-02T16:09:12Z"}, "message": "cpplib.h (CPP_POP, [...]): Delete.\n\n\t* cpplib.h (CPP_POP, parse_cleanup_t): Delete.\n\t(cpp_buffer): Remove cleanup, seen_eof, manual_pop members.\n\n\t* cppfiles.c (file_cleanup): Delete.\n\t* cpphash.c (macro_cleanup): Delete.\n\t(collect_objlike_expansion, collect_funlike_expansion,\n\tmacarg, scan_arguments): Remove CPP_POP case.\n\n\t* cpplex.c (null_cleanup): Delete.\n\t(cpp_pop_buffer): Do the work that was done in the cleanups\n\there.  Call _cpp_unwind_if_stack from here.\n\t(_cpp_expand_to_buffer, cpp_scan_buffer_nooutput,\n\tcpp_scan_buffer): Run until we see CPP_EOF and the top of\n\tstack is the buffer _below_ the one we stacked.\n\t(cpp_get_token): Always pop an exhausted buffer.  Return\n\tCPP_EOF unless it's a macro buffer.  Don't call _cpp_handle_eof.\n\t* cpplib.c (skip_if_group): Don't call cpp_get_token to\n\tincrement the line number.\n\t(_cpp_handle_eof): Rename to _cpp_unwind_if_stack.\n\n\t* fix-header.c (read_scan_file) [parsing getchar()]: Run until\n\twe see CPP_EOF and the top of stack is the buffer _below_ the\n\tone we stacked.\n\t* scan-decls.c: Likewise.\n\nFrom-SVN: r33611", "tree": {"sha": "90422d7ae261276adf06a32d02442c9b52f52170", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/90422d7ae261276adf06a32d02442c9b52f52170"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c56c2073a6268960931acd0b852b6186d4bde179", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c56c2073a6268960931acd0b852b6186d4bde179", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c56c2073a6268960931acd0b852b6186d4bde179", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c56c2073a6268960931acd0b852b6186d4bde179/comments", "author": null, "committer": null, "parents": [{"sha": "753e6cf1b64ccc2e8f7946d4a7a010f82ff99c31", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/753e6cf1b64ccc2e8f7946d4a7a010f82ff99c31", "html_url": "https://github.com/Rust-GCC/gccrs/commit/753e6cf1b64ccc2e8f7946d4a7a010f82ff99c31"}], "stats": {"total": 257, "additions": 115, "deletions": 142}, "files": [{"sha": "f983bc7249fb7fcdc398d4a896f0b3e302429b18", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c56c2073a6268960931acd0b852b6186d4bde179/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c56c2073a6268960931acd0b852b6186d4bde179/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c56c2073a6268960931acd0b852b6186d4bde179", "patch": "@@ -1,3 +1,30 @@\n+2000-05-02  Zack Weinberg  <zack@wolery.cumb.org>\n+\n+\t* cpplib.h (CPP_POP, parse_cleanup_t): Delete.\n+\t(cpp_buffer): Remove cleanup, seen_eof, manual_pop members.\n+\n+\t* cppfiles.c (file_cleanup): Delete.\n+\t* cpphash.c (macro_cleanup): Delete.\n+\t(collect_objlike_expansion, collect_funlike_expansion,\n+\tmacarg, scan_arguments): Remove CPP_POP case.\n+\n+\t* cpplex.c (null_cleanup): Delete.\n+\t(cpp_pop_buffer): Do the work that was done in the cleanups\n+\there.  Call _cpp_unwind_if_stack from here.\n+\t(_cpp_expand_to_buffer, cpp_scan_buffer_nooutput,\n+\tcpp_scan_buffer): Run until we see CPP_EOF and the top of\n+\tstack is the buffer _below_ the one we stacked.\n+\t(cpp_get_token): Always pop an exhausted buffer.  Return\n+\tCPP_EOF unless it's a macro buffer.  Don't call _cpp_handle_eof.\n+\t* cpplib.c (skip_if_group): Don't call cpp_get_token to\n+\tincrement the line number.\n+\t(_cpp_handle_eof): Rename to _cpp_unwind_if_stack.\n+\n+\t* fix-header.c (read_scan_file) [parsing getchar()]: Run until\n+\twe see CPP_EOF and the top of stack is the buffer _below_ the\n+\tone we stacked.\n+\t* scan-decls.c: Likewise.\n+\n 2000-05-02  Andrew Haley  <aph@cygnus.com>\n \n \t* config/ia64/ia64.c (ia64_encode_section_info): Handle the case"}, {"sha": "5ec9d14f476afaea9790d3837c401e9cd452bbb5", "filename": "gcc/cppfiles.c", "status": "modified", "additions": 1, "deletions": 21, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c56c2073a6268960931acd0b852b6186d4bde179/gcc%2Fcppfiles.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c56c2073a6268960931acd0b852b6186d4bde179/gcc%2Fcppfiles.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppfiles.c?ref=c56c2073a6268960931acd0b852b6186d4bde179", "patch": "@@ -42,7 +42,6 @@ static struct file_name_list *actual_directory\n \t\t\t\tPARAMS ((cpp_reader *, const char *));\n static unsigned int hash_IHASH\tPARAMS ((const void *));\n static int eq_IHASH\t\tPARAMS ((const void *, const void *));\n-static int file_cleanup\t\tPARAMS ((cpp_buffer *, cpp_reader *));\n static int find_include_file\tPARAMS ((cpp_reader *, const char *,\n \t\t\t\t\tstruct file_name_list *,\n \t\t\t\t\tIHASH **, int *));\n@@ -194,24 +193,6 @@ make_IHASH (name, fname, path, hash, slot)\n   return ih;\n }\n \n-static int\n-file_cleanup (pbuf, pfile)\n-     cpp_buffer *pbuf;\n-     cpp_reader *pfile;\n-{\n-  if (pbuf->buf)\n-    free ((PTR) pbuf->buf);\n-  if (pfile->system_include_depth)\n-    pfile->system_include_depth--;\n-  if (pfile->potential_control_macro)\n-    {\n-      pbuf->ihash->control_macro = pfile->potential_control_macro;\n-      pfile->potential_control_macro = 0;\n-    }\n-  pfile->input_stack_listing_current = 0;\n-  return 0;\n-}\n-\n /* Centralize calls to open(2) here.  This provides a hook for future\n    changes which might, e.g. look for and open a precompiled version\n    of the header.  It also means all the magic currently associated\n@@ -639,7 +620,7 @@ _cpp_execute_include (pfile, fname, len, no_reinclude, search_start)\n   if (read_include_file (pfile, fd, ihash))\n     {\n       if (angle_brackets)\n-\tpfile->system_include_depth++;   /* Decremented in file_cleanup. */\n+\tpfile->system_include_depth++;\n     }\n }\n \n@@ -771,7 +752,6 @@ read_include_file (pfile, fd, ihash)\n       fp->system_header_p = ihash->foundhere->sysp;\n   fp->lineno = 1;\n   fp->line_base = fp->buf;\n-  fp->cleanup = file_cleanup;\n \n   /* The ->actual_dir field is only used when ignore_srcdir is not in effect;\n      see do_include */"}, {"sha": "6ad8350a69fc834f24b3dbdedeb37a7a3d39a8b4", "filename": "gcc/cpphash.c", "status": "modified", "additions": 6, "deletions": 28, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c56c2073a6268960931acd0b852b6186d4bde179/gcc%2Fcpphash.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c56c2073a6268960931acd0b852b6186d4bde179/gcc%2Fcpphash.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.c?ref=c56c2073a6268960931acd0b852b6186d4bde179", "patch": "@@ -113,7 +113,6 @@ static int dump_hash_helper\t  PARAMS ((void **, void *));\n static void push_macro_expansion PARAMS ((cpp_reader *, const U_CHAR *,\n \t\t\t\t\t  int, HASHNODE *));\n static int unsafe_chars\t\t PARAMS ((cpp_reader *, int, int));\n-static int macro_cleanup\t PARAMS ((cpp_buffer *, cpp_reader *));\n static enum cpp_ttype macarg\t PARAMS ((cpp_reader *, int));\n static void special_symbol\t PARAMS ((cpp_reader *, HASHNODE *));\n static int compare_defs\t\t PARAMS ((cpp_reader *,\n@@ -332,22 +331,6 @@ _cpp_free_definition (h)\n   h->value.cpval = NULL;\n }\n \n-static int\n-macro_cleanup (pbuf, pfile)\n-     cpp_buffer *pbuf;\n-     cpp_reader *pfile ATTRIBUTE_UNUSED;\n-{\n-  HASHNODE *m = pbuf->macro;\n-  \n-  m->disabled = 0;\n-  if ((m->type == T_FMACRO && pbuf->buf != m->value.fdefn->expansion)\n-      || m->type == T_SPECLINE || m->type == T_FILE\n-      || m->type == T_BASE_FILE || m->type == T_INCLUDE_LEVEL\n-      || m->type == T_STDC)\n-    free ((PTR) pbuf->buf);\n-  return 0;\n-}\n-\n /* Create pat nodes.  */\n \n static void\n@@ -485,7 +468,6 @@ collect_objlike_expansion (pfile, list)\n     {\n       switch (list->tokens[i].type)\n \t{\n-\tcase CPP_POP:\n \tcase CPP_EOF:\n \t  cpp_ice (pfile, \"EOF in collect_expansion\");\n \t  /* fall through */\n@@ -576,7 +558,6 @@ collect_funlike_expansion (pfile, list, arglist, replacement)\n       len = list->tokens[i].val.name.len;\n       switch (token)\n \t{\n-\tcase CPP_POP:\n \tcase CPP_EOF:\n \t  cpp_ice (pfile, \"EOF in collect_expansion\");\n \t  /* fall through */\n@@ -1034,14 +1015,9 @@ macarg (pfile, rest_args)\n       switch (token)\n \t{\n \tcase CPP_EOF:\n+\t  /* We've hit end of file; this is an error.\n+\t     Caller will report it.  */\n \t  return token;\n-\tcase CPP_POP:\n-\t  /* If we've hit end of file, it's an error (reported by caller).\n-\t     Ditto if it's the end of cpp_expand_to_buffer text.\n-\t     If we've hit end of macro, just continue.  */\n-\t  if (!CPP_IS_MACRO_BUFFER (CPP_BUFFER (pfile)))\n-\t    return token;\n-\t  break;\n \tcase CPP_OPEN_PAREN:\n \t  paren++;\n \t  break;\n@@ -1361,7 +1337,7 @@ scan_arguments (pfile, defn, args, name)\n \t}\n       else\n \ttoken = macarg (pfile, 0);\n-      if (token == CPP_EOF || token == CPP_POP)\n+      if (token == CPP_EOF)\n \tcpp_error_with_line (pfile, start_line, start_column,\n \t\t\t     \"unterminated macro call\");\n       i++;\n@@ -1663,6 +1639,9 @@ funlike_macroexpand (pfile, hp, args)\n   /* Now put the expansion on the input stack\n      so our caller will commence reading from it.  */\n   push_macro_expansion (pfile, xbuf, totlen, hp);\n+\n+  /* Overload buffer->mapped to indicate that xbuf needs to be freed.  */\n+  CPP_BUFFER (pfile)->mapped = 1;\n }\n \n /* Return 1 iff a token ending in C1 followed directly by a token C2\n@@ -1771,7 +1750,6 @@ push_macro_expansion (pfile, xbuf, len, hp)\n     return;\n   if (advance_cur)\n     mbuf->cur += 2;\n-  mbuf->cleanup = macro_cleanup;\n   mbuf->macro = hp;\n   mbuf->has_escapes = 1;\n "}, {"sha": "9512c7ac4d5a8c3c447453d7c86e37bac3d64e38", "filename": "gcc/cpphash.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c56c2073a6268960931acd0b852b6186d4bde179/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c56c2073a6268960931acd0b852b6186d4bde179/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=c56c2073a6268960931acd0b852b6186d4bde179", "patch": "@@ -253,7 +253,7 @@ extern void _cpp_scan_line\t\tPARAMS ((cpp_reader *, cpp_toklist *));\n \n /* In cpplib.c */\n extern int _cpp_handle_directive\tPARAMS ((cpp_reader *));\n-extern void _cpp_handle_eof\t\tPARAMS ((cpp_reader *));\n+extern void _cpp_unwind_if_stack\tPARAMS ((cpp_reader *, cpp_buffer *));\n extern void _cpp_check_directive        PARAMS((cpp_toklist *, cpp_token *));\n \n #endif"}, {"sha": "517b3d98cf08e87ce1cf67aff3ed36afb83dba27", "filename": "gcc/cpplex.c", "status": "modified", "additions": 42, "deletions": 54, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c56c2073a6268960931acd0b852b6186d4bde179/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c56c2073a6268960931acd0b852b6186d4bde179/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=c56c2073a6268960931acd0b852b6186d4bde179", "patch": "@@ -45,7 +45,6 @@ static int copy_comment\t\tPARAMS ((cpp_reader *, int));\n static void skip_string\t\tPARAMS ((cpp_reader *, int));\n static void parse_string\tPARAMS ((cpp_reader *, int));\n static U_CHAR *find_position\tPARAMS ((U_CHAR *, U_CHAR *, unsigned long *));\n-static int null_cleanup\t\tPARAMS ((cpp_buffer *, cpp_reader *));\n static void null_warning        PARAMS ((cpp_reader *, unsigned int));\n \n static void safe_fwrite\t\tPARAMS ((cpp_reader *, const U_CHAR *,\n@@ -77,14 +76,6 @@ _cpp_grow_token_buffer (pfile, n)\n   CPP_SET_WRITTEN (pfile, old_written);\n }\n \n-static int\n-null_cleanup (pbuf, pfile)\n-     cpp_buffer *pbuf ATTRIBUTE_UNUSED;\n-     cpp_reader *pfile ATTRIBUTE_UNUSED;\n-{\n-  return 0;\n-}\n-\n /* Allocate a new cpp_buffer for PFILE, and push it on the input buffer stack.\n    If BUFFER != NULL, then use the LENGTH characters in BUFFER\n    as the new input buffer.\n@@ -107,7 +98,6 @@ cpp_push_buffer (pfile, buffer, length)\n   new = (cpp_buffer *) xcalloc (1, sizeof (cpp_buffer));\n \n   new->if_stack = pfile->if_stack;\n-  new->cleanup = null_cleanup;\n   new->buf = new->cur = buffer;\n   new->rlimit = buffer + length;\n   new->prev = buf;\n@@ -125,7 +115,32 @@ cpp_pop_buffer (pfile)\n   cpp_buffer *buf = CPP_BUFFER (pfile);\n   if (ACTIVE_MARK_P (pfile))\n     cpp_ice (pfile, \"mark active in cpp_pop_buffer\");\n-  (*buf->cleanup) (buf, pfile);\n+\n+  if (buf->ihash)\n+    {\n+      _cpp_unwind_if_stack (pfile, buf);\n+      if (buf->buf)\n+\tfree ((PTR) buf->buf);\n+      if (pfile->system_include_depth)\n+\tpfile->system_include_depth--;\n+      if (pfile->potential_control_macro)\n+\t{\n+\t  buf->ihash->control_macro = pfile->potential_control_macro;\n+\t  pfile->potential_control_macro = 0;\n+\t}\n+      pfile->input_stack_listing_current = 0;\n+    }\n+  else if (buf->macro)\n+    {\n+      HASHNODE *m = buf->macro;\n+  \n+      m->disabled = 0;\n+      if ((m->type == T_FMACRO && buf->mapped)\n+\t  || m->type == T_SPECLINE || m->type == T_FILE\n+\t  || m->type == T_BASE_FILE || m->type == T_INCLUDE_LEVEL\n+\t  || m->type == T_STDC)\n+\tfree ((PTR) buf->buf);\n+    }\n   CPP_BUFFER (pfile) = CPP_PREV_BUFFER (buf);\n   free (buf);\n   pfile->buffer_stack_depth--;\n@@ -321,7 +336,7 @@ _cpp_expand_to_buffer (pfile, buf, length)\n      const U_CHAR *buf;\n      int length;\n {\n-  cpp_buffer *ip;\n+  cpp_buffer *stop;\n   enum cpp_ttype token;\n   U_CHAR *buf1;\n \n@@ -338,33 +353,27 @@ _cpp_expand_to_buffer (pfile, buf, length)\n   memcpy (buf1, buf, length);\n \n   /* Set up the input on the input stack.  */\n-  ip = cpp_push_buffer (pfile, buf1, length);\n-  if (ip == NULL)\n+  stop = CPP_BUFFER (pfile);\n+  if (cpp_push_buffer (pfile, buf1, length) == NULL)\n     return;\n-  ip->has_escapes = 1;\n+  CPP_BUFFER (pfile)->has_escapes = 1;\n \n   /* Scan the input, create the output.  */\n   for (;;)\n     {\n       token = cpp_get_token (pfile);\n-      if (token == CPP_EOF)\n+      if (token == CPP_EOF && CPP_BUFFER (pfile) == stop)\n \tbreak;\n-      if (token == CPP_POP && CPP_BUFFER (pfile) == ip)\n-\t{\n-\t  cpp_pop_buffer (pfile);\n-\t  break;\n-\t}\n     }\n }\n \n-/* Scan until CPP_BUFFER (PFILE) is exhausted, discarding output.\n-   Then pop the buffer.  */\n+/* Scan until CPP_BUFFER (PFILE) is exhausted, discarding output.  */\n \n void\n cpp_scan_buffer_nooutput (pfile)\n      cpp_reader *pfile;\n {\n-  cpp_buffer *buffer = CPP_BUFFER (pfile);\n+  cpp_buffer *stop = CPP_PREV_BUFFER (CPP_BUFFER (pfile));\n   enum cpp_ttype token;\n   unsigned int old_written = CPP_WRITTEN (pfile);\n   /* In no-output mode, we can ignore everything but directives.  */\n@@ -373,45 +382,33 @@ cpp_scan_buffer_nooutput (pfile)\n       if (! pfile->only_seen_white)\n \t_cpp_skip_rest_of_line (pfile);\n       token = cpp_get_token (pfile);\n-      if (token == CPP_EOF)\n+      if (token == CPP_EOF && CPP_BUFFER (pfile) == stop)\n \tbreak;\n-      if (token == CPP_POP && CPP_BUFFER (pfile) == buffer)\n-\t{\n-\t  cpp_pop_buffer (pfile);\n-\t  break;\n-\t}\n     }\n   CPP_SET_WRITTEN (pfile, old_written);\n }\n \n-/* Scan until CPP_BUFFER (pfile) is exhausted, writing output to PRINT.\n-   Then pop the buffer.  */\n+/* Scan until CPP_BUFFER (pfile) is exhausted, writing output to PRINT.  */\n \n void\n cpp_scan_buffer (pfile, print)\n      cpp_reader *pfile;\n      cpp_printer *print;\n {\n-  cpp_buffer *buffer = CPP_BUFFER (pfile);\n+  cpp_buffer *stop = CPP_PREV_BUFFER (CPP_BUFFER (pfile));\n   enum cpp_ttype token;\n \n   for (;;)\n     {\n       token = cpp_get_token (pfile);\n-      if ((token == CPP_POP && !CPP_IS_MACRO_BUFFER (CPP_BUFFER (pfile)))\n-\t  || token == CPP_EOF || token == CPP_VSPACE\n+      if (token == CPP_EOF || token == CPP_VSPACE\n \t  /* XXX Temporary kluge - force flush after #include only */\n \t  || (token == CPP_DIRECTIVE\n \t      && CPP_BUFFER (pfile)->nominal_fname != print->last_fname))\n \t{\n \t  cpp_output_tokens (pfile, print);\n-\t  if (token == CPP_EOF)\n+\t  if (token == CPP_EOF && CPP_BUFFER (pfile) == stop)\n \t    return;\n-\t  if (token == CPP_POP && CPP_BUFFER (pfile) == buffer)\n-\t    {\n-\t      cpp_pop_buffer (pfile);\n-\t      return;\n-\t    }\n \t}\n     }\n }\n@@ -1611,21 +1608,13 @@ cpp_get_token (pfile)\n     case CPP_EOF:\n       if (CPP_BUFFER (pfile) == NULL)\n \treturn CPP_EOF;\n-      if (CPP_BUFFER (pfile)->manual_pop)\n-\t/* If we've been reading from redirected input, the\n-\t   frontend will pop the buffer.  */\n-\treturn CPP_EOF;\n-\n-      if (CPP_BUFFER (pfile)->seen_eof)\n+      if (CPP_IS_MACRO_BUFFER (CPP_BUFFER (pfile)))\n \t{\n \t  cpp_pop_buffer (pfile);\n \t  goto get_next;\n \t}\n-      else\n-\t{\n-\t  _cpp_handle_eof (pfile);\n-\t  return CPP_POP;\n-\t}\n+      cpp_pop_buffer (pfile);\n+      return CPP_EOF;\n     }\n }\n \n@@ -1646,8 +1635,7 @@ cpp_get_non_space_token (pfile)\n }\n \n /* Like cpp_get_token, except that it does not execute directives,\n-   does not consume vertical space, discards horizontal space, and\n-   automatically pops off macro buffers.  */\n+   does not consume vertical space, and discards horizontal space.  */\n enum cpp_ttype\n _cpp_get_directive_token (pfile)\n      cpp_reader *pfile;"}, {"sha": "f96da23b83c3b8af2c651c91f705e8b7d1b1dd60", "filename": "gcc/cpplib.c", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c56c2073a6268960931acd0b852b6186d4bde179/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c56c2073a6268960931acd0b852b6186d4bde179/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=c56c2073a6268960931acd0b852b6186d4bde179", "patch": "@@ -215,8 +215,8 @@ _cpp_handle_directive (pfile)\n \treturn 0;\n \n       if (CPP_PEDANTIC (pfile)\n-\t  && ! CPP_OPTION (pfile, preprocessed)\n-\t  && ! CPP_BUFFER (pfile)->manual_pop)\n+\t  && CPP_BUFFER (pfile)->ihash\n+\t  && ! CPP_OPTION (pfile, preprocessed))\n \tcpp_pedwarn (pfile, \"# followed by integer\");\n       do_line (pfile);\n       return 1;\n@@ -1345,14 +1345,17 @@ skip_if_group (pfile)\n   pfile->no_macro_expand++;\n   for (;;)\n     {\n-      /* We are at the end of a line.  Only cpp_get_token knows how to\n-\t advance the line number correctly.  */\n-      token = cpp_get_token (pfile);\n-      if (token == CPP_POP)\n+      /* We are at the end of a line.\n+\t XXX Serious layering violation here.  */\n+      int c = CPP_BUF_PEEK (CPP_BUFFER (pfile));\n+      if (c == EOF)\n \tbreak;  /* Caller will issue error.  */\n-      else if (token != CPP_VSPACE)\n-\tcpp_ice (pfile, \"cpp_get_token returned %d in skip_if_group\", token);\n+      else if (c != '\\n')\n+\tcpp_ice (pfile, \"character %c at end of line in skip_if_group\", c);\n+      CPP_BUFFER (pfile)->cur++;\n+      CPP_BUMP_LINE (pfile);\n       CPP_SET_WRITTEN (pfile, old_written);\n+      pfile->only_seen_white = 1;\n \n       token = _cpp_get_directive_token (pfile);\n \n@@ -1458,15 +1461,18 @@ validate_else (pfile, directive)\n   pfile->no_macro_expand--;\n }\n \n+/* Called when we reach the end of a macro buffer.  Walk back up the\n+   conditional stack till we reach its level at entry to this file,\n+   issuing error messages.  */\n void\n-_cpp_handle_eof (pfile)\n+_cpp_unwind_if_stack (pfile, pbuf)\n      cpp_reader *pfile;\n+     cpp_buffer *pbuf;\n {\n   struct if_stack *ifs, *nifs;\n \n-  /* Unwind the conditional stack and generate error messages.  */\n   for (ifs = pfile->if_stack;\n-       ifs != CPP_BUFFER (pfile)->if_stack;\n+       ifs != pbuf->if_stack;\n        ifs = nifs)\n     {\n       cpp_error_with_line (pfile, ifs->lineno, 0,\n@@ -1477,7 +1483,6 @@ _cpp_handle_eof (pfile)\n       free (ifs);\n     }\n   pfile->if_stack = ifs;\n-  CPP_BUFFER (pfile)->seen_eof = 1;\n }\n \n static int\n@@ -1658,7 +1663,7 @@ cpp_undef (pfile, macro)\n   memcpy (buf, macro, len);\n   buf[len]     = '\\n';\n   buf[len + 1] = '\\0';\n-  if (cpp_push_buffer (pfile, buf, len + 1))\n+  if (cpp_push_buffer (pfile, buf, len + 1) != NULL)\n     {\n       do_undef (pfile);\n       cpp_pop_buffer (pfile);"}, {"sha": "4d005df0931917767ab10ad915f4c1b4d810e99b", "filename": "gcc/cpplib.h", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c56c2073a6268960931acd0b852b6186d4bde179/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c56c2073a6268960931acd0b852b6186d4bde179/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=c56c2073a6268960931acd0b852b6186d4bde179", "patch": "@@ -131,7 +131,6 @@ typedef struct cpp_name cpp_name;\n   /* Obsolete - will be removed when no code uses them still.  */\t\\\n   H(CPP_COMMENT,\t0)\t\t/* Only if output comments.  */ \\\n   N(CPP_HSPACE,\t\t0)\t\t/* Horizontal white space.  */\t\\\n-  N(CPP_POP,\t\t0)\t\t/* End of buffer.  */\t\t\\\n   N(CPP_DIRECTIVE,\t0)\t\t/* #define and the like */\t\\\n   N(CPP_MACRO,\t\t0)\t\t/* Like a NAME, but expanded.  */\n \n@@ -192,7 +191,6 @@ struct cpp_token\n #define SYNTAX_ASSERT  (1 << 9)\n \n typedef int (*directive_handler) PARAMS ((cpp_reader *));\n-typedef int (*parse_cleanup_t) PARAMS ((cpp_buffer *, cpp_reader *));\n \n struct cpp_toklist\n {\n@@ -238,8 +236,6 @@ struct cpp_buffer\n      to record control macros. */\n   struct ihash *ihash;\n \n-  parse_cleanup_t cleanup;\n-\n   /* If the buffer is the expansion of a macro, this points to the\n      macro's hash table entry.  */\n   struct hashnode *macro;\n@@ -254,9 +250,6 @@ struct cpp_buffer\n   /* True if this is a header file included using <FILENAME>.  */\n   char system_header_p;\n \n-  /* True if end-of-file has already been hit once in this buffer.  */\n-  char seen_eof;\n-\n   /* True if buffer contains escape sequences.\n      Currently there are two kinds:\n      \"\\r-\" means following identifier should not be macro-expanded.\n@@ -271,17 +264,15 @@ struct cpp_buffer\n      from macro expansion text in collect_expansion and/or macarg.  */\n   char has_escapes;\n \n-  /* Used by the C++ frontend to implement redirected input (such as for\n-     default argument and/or template parsing).  */\n-  char manual_pop;\n-\n   /* True if we have already warned about C++ comments in this file.\n      The warning happens only for C89 extended mode with -pedantic on,\n      or for -Wtraditional, and only once per file (otherwise it would\n      be far too noisy).  */\n   char warned_cplusplus_comments;\n \n-  /* True if this buffer's data is mmapped.  */\n+  /* In a file buffer, true if this buffer's data is mmapped\n+     (currently never the case).  In a macro buffer, true if this\n+     buffer's data must be freed.  */\n   char mapped;\n };\n "}, {"sha": "3740ce05ca91d2b4643c528c4835dbfe3e2d242c", "filename": "gcc/fix-header.c", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c56c2073a6268960931acd0b852b6186d4bde179/gcc%2Ffix-header.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c56c2073a6268960931acd0b852b6186d4bde179/gcc%2Ffix-header.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffix-header.c?ref=c56c2073a6268960931acd0b852b6186d4bde179", "patch": "@@ -658,10 +658,12 @@ read_scan_file (in_fname, argc, argv)\n       && (fn = lookup_std_proto (\"_filbuf\", 7)) != NULL)\n     {\n       static char getchar_call[] = \"getchar();\";\n-      cpp_buffer *buf\n-\t= cpp_push_buffer (&scan_in, getchar_call, sizeof(getchar_call) - 1);\n       int old_written = CPP_WRITTEN (&scan_in);\n       int seen_filbuf = 0;\n+      cpp_buffer *buf = CPP_BUFFER (&scan_in);\n+      if (cpp_push_buffer (&scan_in, getchar_call,\n+\t\t\t   sizeof(getchar_call) - 1) == NULL)\n+\treturn;\n \n       /* Scan the macro expansion of \"getchar();\".  */\n       for (;;)\n@@ -671,13 +673,8 @@ read_scan_file (in_fname, argc, argv)\n \t  unsigned char *id = scan_in.token_buffer + old_written;\n \t  \n \t  CPP_SET_WRITTEN (&scan_in, old_written);\n-\t  if (token == CPP_EOF) /* Should not happen ...  */\n+\t  if (token == CPP_EOF && CPP_BUFFER (&scan_in) == buf)\n \t    break;\n-\t  if (token == CPP_POP && CPP_BUFFER (&scan_in) == buf)\n-\t    {\n-\t      cpp_pop_buffer (&scan_in);\n-\t      break;\n-\t    }\n \t  if (token == CPP_NAME && cpp_idcmp (id, length, \"_filbuf\") == 0)\n \t    seen_filbuf++;\n \t}"}, {"sha": "e65d832fda0f1b364b1fd295f0c9cb56dc1edf12", "filename": "gcc/scan-decls.c", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c56c2073a6268960931acd0b852b6186d4bde179/gcc%2Fscan-decls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c56c2073a6268960931acd0b852b6186d4bde179/gcc%2Fscan-decls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fscan-decls.c?ref=c56c2073a6268960931acd0b852b6186d4bde179", "patch": "@@ -116,7 +116,12 @@ scan_decls (pfile, argc, argv)\n       goto new_statement;\n     }\n   if (token == CPP_EOF)\n-    return 0;\n+    {\n+      if (CPP_BUFFER (pfile) == NULL)\n+\treturn 0;\n+      else\n+\tgoto new_statement;\n+    }\n   if (token == CPP_SEMICOLON)\n     goto new_statement;\n   if (token != CPP_NAME)\n@@ -235,13 +240,15 @@ scan_decls (pfile, argc, argv)\n \t  prev_id_end = CPP_WRITTEN (pfile);\n \t  break;\n \n-\tcase CPP_EOF:\n-\t  return 0;\n-\n \tcase CPP_OPEN_BRACE:  case CPP_CLOSE_BRACE:  case CPP_DIRECTIVE:\n \t  goto new_statement;  /* handle_statement? */\n \t  \n-\tcase CPP_HSPACE:  case CPP_VSPACE:  case CPP_COMMENT:  case CPP_POP:\n+\tcase CPP_EOF:\n+\t  if (CPP_BUFFER (pfile) == NULL)\n+\t    return 0;\n+\t  /* else fall through */\n+\n+\tcase CPP_HSPACE:  case CPP_VSPACE:  case CPP_COMMENT:\n \t  /* Skip initial white space.  */\n \t  if (start_written == 0)\n \t    CPP_SET_WRITTEN (pfile, 0);"}]}