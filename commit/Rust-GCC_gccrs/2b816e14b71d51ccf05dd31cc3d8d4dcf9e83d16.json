{"sha": "2b816e14b71d51ccf05dd31cc3d8d4dcf9e83d16", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmI4MTZlMTRiNzFkNTFjY2YwNWRkMzFjYzNkOGQ0ZGNmOWU4M2QxNg==", "commit": {"author": {"name": "Ranjit Mathew", "email": "rmathew@hotmail.com", "date": "2005-01-10T18:14:36Z"}, "committer": {"name": "Ranjit Mathew", "email": "rmathew@gcc.gnu.org", "date": "2005-01-10T18:14:36Z"}, "message": "* verify.c: Revert to the version before the BC-ABI merge.\n\nFrom-SVN: r93147", "tree": {"sha": "df8407668f453f97bf29037381ae68cf66feaad5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/df8407668f453f97bf29037381ae68cf66feaad5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2b816e14b71d51ccf05dd31cc3d8d4dcf9e83d16", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b816e14b71d51ccf05dd31cc3d8d4dcf9e83d16", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b816e14b71d51ccf05dd31cc3d8d4dcf9e83d16", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b816e14b71d51ccf05dd31cc3d8d4dcf9e83d16/comments", "author": null, "committer": null, "parents": [{"sha": "4059e82d299fc8059e726e48b24b2c455b751a4a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4059e82d299fc8059e726e48b24b2c455b751a4a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4059e82d299fc8059e726e48b24b2c455b751a4a"}], "stats": {"total": 112, "additions": 38, "deletions": 74}, "files": [{"sha": "4fafdf7ec5579b4c51a7b4ae3b6a5921b63e3511", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b816e14b71d51ccf05dd31cc3d8d4dcf9e83d16/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b816e14b71d51ccf05dd31cc3d8d4dcf9e83d16/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=2b816e14b71d51ccf05dd31cc3d8d4dcf9e83d16", "patch": "@@ -1,3 +1,7 @@\n+2005-01-10  Ranjit Mathew  <rmathew@hotmail.com>\n+\n+\t* verify.c: Revert to the version before the BC-ABI merge.\n+\n 2005-01-10  Ranjit Mathew  <rmathew@hotmail.com>\n \n \tPR java/19277"}, {"sha": "f81936d7b6e4baf2c58e0878e2a48cdfc55894be", "filename": "gcc/java/verify.c", "status": "modified", "additions": 34, "deletions": 74, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b816e14b71d51ccf05dd31cc3d8d4dcf9e83d16/gcc%2Fjava%2Fverify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b816e14b71d51ccf05dd31cc3d8d4dcf9e83d16/gcc%2Fjava%2Fverify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fverify.c?ref=2b816e14b71d51ccf05dd31cc3d8d4dcf9e83d16", "patch": "@@ -1,6 +1,6 @@\n /* Handle verification of bytecoded methods for the GNU compiler for \n    the Java(TM) language.\n-   Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004\n+   Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -89,23 +89,23 @@ check_pending_block (tree target_label)\n \n   if (current_subr == NULL_TREE)\n     {\n-/*       if (LABEL_IN_SUBR (target_label)) */\n-/* \treturn \"might transfer control into subroutine\"; */\n+      if (LABEL_IN_SUBR (target_label))\n+\treturn \"might transfer control into subroutine\";\n     }\n   else\n     {\n       if (LABEL_IN_SUBR (target_label))\n \t{\n-/* \t  if (LABEL_SUBR_START (target_label) != current_subr) */\n-/* \t    return \"transfer out of subroutine\"; */\n+\t  if (LABEL_SUBR_START (target_label) != current_subr)\n+\t    return \"transfer out of subroutine\";\n \t}\n       else if (! LABEL_VERIFIED (target_label))\n \t{\n \t  LABEL_IN_SUBR (target_label) = 1;\n \t  LABEL_SUBR_START (target_label) = current_subr;\n \t}\n-/*       else */\n-/* \treturn \"transfer out of subroutine\"; */\n+      else\n+\treturn \"transfer out of subroutine\";\n     }\n   return NULL;\n }\n@@ -126,54 +126,6 @@ subroutine_nesting (tree label)\n   return nesting;\n }\n \n-static tree\n-defer_merging (tree type1, tree type2)\n-{\n-  /* FIXME: This is just a placeholder until we replace the verifier\n-     altogether.  We really need to ouput a type assertion for all of\n-     the types, every time they are used.  */\n-  return object_ptr_type_node;\n-\n-  if (TREE_CODE (type1) == POINTER_TYPE)\n-    type1 = TREE_TYPE (type1);\n-  if (TREE_CODE (type2) == POINTER_TYPE)\n-    type2 = TREE_TYPE (type2);\n-\n-  if (TREE_CODE (type1) == RECORD_TYPE && TREE_CODE (type2) == RECORD_TYPE)\n-    {\n-      tree list = build_tree_list (type1, NULL_TREE);\n-      list = tree_cons (type2, NULL_TREE, list);\n-      return list;\n-    }\n-\n-  if (TREE_CODE (type1) == TREE_LIST && TREE_CODE (type2) == TREE_LIST)\n-    {\n-      return chainon (copy_list (type1), copy_list (type2));\n-    }\n-\n-  if (TREE_CODE (type1) == TREE_LIST && TREE_CODE (type2) == RECORD_TYPE)\n-    {\n-      tree tmp = type1;\n-      do\n-\t{\n-\t  if (TREE_PURPOSE (tmp) == type2)\n-\t    return type1;\n-\t  tmp = TREE_CHAIN (tmp);\n-\t}\n-      while (tmp);\n-\n-      return tree_cons (type2, NULL_TREE, copy_list (type1));\n-    }\n-\n-  if (TREE_CODE (type2) == TREE_LIST && TREE_CODE (type1) == RECORD_TYPE)\n-    {\n-      return defer_merging (type2, type1);\n-    }\n-\n-  abort ();\n-}\n-\n-\n /* Return the \"merged\" types of TYPE1 and TYPE2.\n    If either is primitive, the other must match (after promotion to int).\n    For reference types, return the common super-class.\n@@ -186,11 +138,7 @@ merge_types (tree type1, tree type2)\n     return type1;\n   if (type1 == TYPE_UNKNOWN || type2 == TYPE_UNKNOWN\n       || type1 == TYPE_RETURN_ADDR || type2 == TYPE_RETURN_ADDR)\n-    return TYPE_UNKNOWN;  \n-\n-  if (TREE_CODE (type1) == TREE_LIST || TREE_CODE (type2) == TREE_LIST)\n-    return defer_merging (type1, type2);\n-\n+    return TYPE_UNKNOWN;\n   if (TREE_CODE (type1) == POINTER_TYPE && TREE_CODE (type2) == POINTER_TYPE)\n     {\n       int depth1, depth2;\n@@ -205,9 +153,6 @@ merge_types (tree type1, tree type2)\n       tt1 = TREE_TYPE (type1);\n       tt2 = TREE_TYPE (type2);\n \n-      if (TYPE_DUMMY (tt1) || TYPE_DUMMY (tt2))\n-\treturn defer_merging (tt1, tt2);\n-      \n       /* If tt{1,2} haven't been properly loaded, now is a good time\n          to do it. */\n       if (!TYPE_SIZE (tt1))\n@@ -248,10 +193,31 @@ merge_types (tree type1, tree type2)\n \t  return object_ptr_type_node;\n \t}\n \n-      if (CLASS_INTERFACE (TYPE_NAME (tt1))\n-\t  || (CLASS_INTERFACE (TYPE_NAME (tt2))))\n+      if (CLASS_INTERFACE (TYPE_NAME (tt1)))\n \t{\n-\t  return object_ptr_type_node;\n+\t  /* FIXME: should see if two interfaces have a common\n+\t     superinterface.  */\n+\t  if (CLASS_INTERFACE (TYPE_NAME (tt2)))\n+\t    {\n+\t      /* This is a kludge, but matches what Sun's verifier does.\n+\t\t It can be tricked, but is safe as long as type errors\n+\t\t (i.e. interface method calls) are caught at run-time. */\n+\t      return object_ptr_type_node;\n+\t    }\n+\t  else\n+\t    {\n+\t      if (can_widen_reference_to (tt2, tt1))\n+\t\treturn type1;\n+\t      else\n+\t\treturn object_ptr_type_node;\n+\t    }\n+\t}\n+      else if (CLASS_INTERFACE (TYPE_NAME (tt2)))\n+\t{\n+\t  if (can_widen_reference_to (tt1, tt2))\n+\t    return type2;\n+\t  else\n+\t    return object_ptr_type_node;\n \t}\n \n       type1 = tt1;\n@@ -709,8 +675,6 @@ verify_jvm_instructions (JCF* jcf, const unsigned char *byte_ops, long length)\n \t  VERIFICATION_ERROR_WITH_INDEX\n \t    (\"invalid local variable index %d in load\");\n \ttmp = type_map[index];\n-\tif (TREE_CODE (tmp) != TREE_LIST)\n-\t  {\n \tif (tmp == TYPE_UNKNOWN)\n \t  VERIFICATION_ERROR_WITH_INDEX\n \t    (\"loading local variable %d which has unknown type\");\n@@ -724,7 +688,6 @@ verify_jvm_instructions (JCF* jcf, const unsigned char *byte_ops, long length)\n \t\t: type != tmp))\n \t  VERIFICATION_ERROR_WITH_INDEX\n \t    (\"loading local variable %d which has invalid type\");\n-\t  }\n \tPUSH_TYPE (tmp);\n \tgoto note_used;\n \tcase OPCODE_istore:  type = int_type_node;  goto general_store;\n@@ -773,7 +736,7 @@ verify_jvm_instructions (JCF* jcf, const unsigned char *byte_ops, long length)\n \tprev_eh_ranges = NULL_EH_RANGE;\n \n \t/* Allocate decl for this variable now, so we get a temporary\n-\t   that survives the whole method. */\n+! \t   that survives the whole method. */\n \tfind_local_variable (index, type, oldpc);\n \n         if (TYPE_IS_WIDE (type))\n@@ -1129,10 +1092,6 @@ verify_jvm_instructions (JCF* jcf, const unsigned char *byte_ops, long length)\n \t    if (! CLASS_LOADED_P (self_type))\n \t      load_class (self_type, 1);\n \n-\t    if (TYPE_DUMMY (self_type) && op_code == OPCODE_invokeinterface)\n-\t      /* Assume we are an interface.  */\n-\t      CLASS_INTERFACE (TYPE_NAME (self_type)) = 1;\n-\n \t    self_is_interface = CLASS_INTERFACE (TYPE_NAME (self_type));\n \t    method_name = COMPONENT_REF_NAME (&current_jcf->cpool, index);\n \t    method_type = parse_signature_string ((const unsigned char *) IDENTIFIER_POINTER (sig),\n@@ -1170,6 +1129,7 @@ verify_jvm_instructions (JCF* jcf, const unsigned char *byte_ops, long length)\n \t\t  if (!nargs || notZero)\n \t\t      VERIFICATION_ERROR \n \t\t        (\"invalid argument number in invokeinterface\");\n+\n \t\t  /* If we verify/resolve the constant pool, as we should,\n \t\t     this test (and the one just following) are redundant.  */\n \t\t  if (! self_is_interface)"}]}