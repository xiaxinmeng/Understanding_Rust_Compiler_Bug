{"sha": "341c653c704e398070219534cd9fed97e56661b3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzQxYzY1M2M3MDRlMzk4MDcwMjE5NTM0Y2Q5ZmVkOTdlNTY2NjFiMw==", "commit": {"author": {"name": "Walter Lee", "email": "walt@tilera.com", "date": "2014-02-24T15:08:00Z"}, "committer": {"name": "Walter Lee", "email": "walt@gcc.gnu.org", "date": "2014-02-24T15:08:00Z"}, "message": "TILE-Gx big endian support.\n\n/:\n\t* configure.ac (tilepro-*-*) Change to tilepro*-*-*.\n\t(tilegx-*-*): Change to tilegx*-*-*.\n\t* configure: Regenerate.\n\ncontrib/:\n\t* config-list.mk (LIST): Add tilegxbe-linux-gnu.\n\nlibcpp/:\n\t* configure.ac: Change \"tilepro\" triplet to \"tilepro*\".\n\t* configure: Regenerate.\n\nlibgcc/:\n\t* config.host: Support \"tilegx*\" and \"tilepro*\" triplets.\n\t* config/tilegx/sfp-machine32.h (__BYTE_ORDER): Handle big endian.\n\t* config/tilegx/sfp-machine64.h (__BYTE_ORDER): Handle big endian.\n\ngcc/:\n\t* config.gcc (tilepro-*-*): Change to tilepro*-*-*.\n\t(tilegx-*-linux*): Change to tilegx*-*-linux*; Support tilegxbe\n\ttriplet.\n\t* common/config/tilegx/tilegx-common.c\n\t(TARGET_DEFAULT_TARGET_FLAGS): Define.\n\t* config/tilegx/linux.h (ASM_SPEC): Add endian_spec.\n\t(LINK_SPEC): Ditto.\n\t* config/tilegx/sync.md (atomic_test_and_set): Handle big endian.\n\t* config/tilegx/tilegx.c (tilegx_return_in_msb): New.\n\t(tilegx_gimplify_va_arg_expr): Handle big endian.\n\t(tilegx_expand_unaligned_load): Ditto.\n\t(tilegx_expand_unaligned_store): Ditto.\n\t(TARGET_RETURN_IN_MSB): New.\n\t* config/tilegx/tilegx.h (TARGET_DEFAULT): New.\n\t(TARGET_ENDIAN_DEFAULT): New.\n\t(TARGET_BIG_ENDIAN): Handle big endian.\n\t(BYTES_BIG_ENDIAN): Ditto.\n\t(WORDS_BIG_ENDIAN): Ditto.\n\t(FLOAT_WORDS_BIG_ENDIAN): Ditto.\n\t(ENDIAN_SPEC): New.\n\t(EXTRA_SPECS): New.\n\t* config/tilegx/tilegx.md (extv): Handle big endian.\n\t(extzv): Ditto.\n\t(insn_st<n>): Ditto.\n\t(insn_st<n>_add<bitsuffix>): Ditto.\n\t(insn_stnt<n>): Ditto.\n\t(insn_stnt<n>_add<bitsuffix>):Ditto.\n\t(vec_interleave_highv8qi): Handle big endian.\n\t(vec_interleave_highv8qi_be): New.\n\t(vec_interleave_highv8qi_le): New.\n\t(insn_v1int_h): Handle big endian.\n\t(vec_interleave_lowv8qi): Handle big endian.\n\t(vec_interleave_lowv8qi_be): New.\n\t(vec_interleave_lowv8qi_le): New.\n\t(insn_v1int_l): Handle big endian.\n\t(vec_interleave_highv4hi): Handle big endian.\n\t(vec_interleave_highv4hi_be): New.\n\t(vec_interleave_highv4hi_le): New.\n\t(insn_v2int_h): Handle big endian.\n\t(vec_interleave_lowv4hi): Handle big endian.\n\t(vec_interleave_lowv4hi_be): New.\n\t(vec_interleave_lowv4hi_le): New.\n\t(insn_v2int_l): Handle big endian.\n\t(vec_interleave_highv2si): Handle big endian.\n\t(vec_interleave_highv2si_be): New.\n\t(vec_interleave_highv2si_le): New.\n\t(insn_v4int_h): Handle big endian.\n\t(vec_interleave_lowv2si): Handle big endian.\n\t(vec_interleave_lowv2si_be): New.\n\t(vec_interleave_lowv2si_le): New.\n\t(insn_v4int_l): Handle big endian.\n\t* config/tilegx/tilegx.opt (mbig-endian): New option.\n\t(mlittle-endian): New option.\n\t* doc/install.texi: Document tilegxbe-linux.\n\t* doc/invoke.texi: Document -mbig-endian and -mlittle-endian.\n\nFrom-SVN: r208069", "tree": {"sha": "53162bb2cdbb19111069e925e278cefd4d970326", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/53162bb2cdbb19111069e925e278cefd4d970326"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/341c653c704e398070219534cd9fed97e56661b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/341c653c704e398070219534cd9fed97e56661b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/341c653c704e398070219534cd9fed97e56661b3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/341c653c704e398070219534cd9fed97e56661b3/comments", "author": {"login": "walt-tilera", "id": 6602917, "node_id": "MDQ6VXNlcjY2MDI5MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/6602917?v=4", "gravatar_id": "", "url": "https://api.github.com/users/walt-tilera", "html_url": "https://github.com/walt-tilera", "followers_url": "https://api.github.com/users/walt-tilera/followers", "following_url": "https://api.github.com/users/walt-tilera/following{/other_user}", "gists_url": "https://api.github.com/users/walt-tilera/gists{/gist_id}", "starred_url": "https://api.github.com/users/walt-tilera/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/walt-tilera/subscriptions", "organizations_url": "https://api.github.com/users/walt-tilera/orgs", "repos_url": "https://api.github.com/users/walt-tilera/repos", "events_url": "https://api.github.com/users/walt-tilera/events{/privacy}", "received_events_url": "https://api.github.com/users/walt-tilera/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c97d7285d9b949ac05ad04f0d76112579c50e240", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c97d7285d9b949ac05ad04f0d76112579c50e240", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c97d7285d9b949ac05ad04f0d76112579c50e240"}], "stats": {"total": 583, "additions": 502, "deletions": 81}, "files": [{"sha": "9510ce316b4aa522b05bada38bece0653c6a43bd", "filename": "ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/341c653c704e398070219534cd9fed97e56661b3/ChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/341c653c704e398070219534cd9fed97e56661b3/ChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/ChangeLog?ref=341c653c704e398070219534cd9fed97e56661b3", "patch": "@@ -1,3 +1,9 @@\n+2014-02-24  Walter Lee  <walt@tilera.com>\n+\n+\t* configure.ac (tilepro-*-*) Change to tilepro*-*-*.\n+\t(tilegx-*-*): Change to tilegx*-*-*.\n+\t* configure: Regenerate.\n+\n 2014-02-17  Loren J. Rittle  <ljrittle@acm.org>\n \n \t* MAINTAINERS (Various Maintainers: c++ runtime libs): Remove myself."}, {"sha": "57be42435a9d3221e21c63d85e6c967e8629c9c1", "filename": "configure", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/341c653c704e398070219534cd9fed97e56661b3/configure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/341c653c704e398070219534cd9fed97e56661b3/configure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/configure?ref=341c653c704e398070219534cd9fed97e56661b3", "patch": "@@ -3815,7 +3815,7 @@ case \"${target}\" in\n   tic6x-*-*)\n     noconfigdirs=\"$noconfigdirs sim\"\n     ;;\n-  tilepro-*-* | tilegx-*-*)\n+  tilepro*-*-* | tilegx*-*-*)\n     noconfigdirs=\"$noconfigdirs sim\"\n     ;;\n   v810-*-*)"}, {"sha": "aaeb96667cde229356166a1ef6fe08dd4ed74e77", "filename": "configure.ac", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/341c653c704e398070219534cd9fed97e56661b3/configure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/341c653c704e398070219534cd9fed97e56661b3/configure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/configure.ac?ref=341c653c704e398070219534cd9fed97e56661b3", "patch": "@@ -1145,7 +1145,7 @@ case \"${target}\" in\n   tic6x-*-*)\n     noconfigdirs=\"$noconfigdirs sim\"\n     ;;\n-  tilepro-*-* | tilegx-*-*)\n+  tilepro*-*-* | tilegx*-*-*)\n     noconfigdirs=\"$noconfigdirs sim\"\n     ;;\n   v810-*-*)"}, {"sha": "93906ca0ca89a17d1a2b4aa833d5f13152fc45aa", "filename": "contrib/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/341c653c704e398070219534cd9fed97e56661b3/contrib%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/341c653c704e398070219534cd9fed97e56661b3/contrib%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2FChangeLog?ref=341c653c704e398070219534cd9fed97e56661b3", "patch": "@@ -1,3 +1,7 @@\n+2014-02-24  Walter Lee  <walt@tilera.com>\n+\n+\t* config-list.mk (LIST): Add tilegxbe-linux-gnu.\n+\n 2014-02-13  Richard Biener  <rguenther@suse.de>\n \n \t* download_prerequisites: Update ISL and CLOOG versions."}, {"sha": "43454871da2a084bd5146b22ff200552e64628ec", "filename": "contrib/config-list.mk", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/341c653c704e398070219534cd9fed97e56661b3/contrib%2Fconfig-list.mk", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/341c653c704e398070219534cd9fed97e56661b3/contrib%2Fconfig-list.mk", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2Fconfig-list.mk?ref=341c653c704e398070219534cd9fed97e56661b3", "patch": "@@ -66,7 +66,8 @@ LIST = aarch64-elf aarch64-linux-gnu \\\n   sparc-leon3-linux-gnuOPT-enable-target=all sparc-netbsdelf \\\n   sparc64-sun-solaris2.10OPT-with-gnu-ldOPT-with-gnu-asOPT-enable-threads=posix \\\n   sparc-wrs-vxworks sparc64-elf sparc64-rtems sparc64-linux sparc64-freebsd6 \\\n-  sparc64-netbsd sparc64-openbsd spu-elf tilegx-linux-gnu tilepro-linux-gnu \\\n+  sparc64-netbsd sparc64-openbsd spu-elf \\\n+  tilegx-linux-gnu tilegxbe-linux-gnu tilepro-linux-gnu \\\n   v850e-elf v850-elf vax-linux-gnu \\\n   vax-netbsdelf vax-openbsd x86_64-apple-darwin \\\n   x86_64-pc-linux-gnuOPT-with-fpmath=avx \\"}, {"sha": "6371f2b9c3003d307aaa9e8152297099328ed887", "filename": "gcc/ChangeLog", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/341c653c704e398070219534cd9fed97e56661b3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/341c653c704e398070219534cd9fed97e56661b3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=341c653c704e398070219534cd9fed97e56661b3", "patch": "@@ -1,3 +1,61 @@\n+2014-02-24  Walter Lee  <walt@tilera.com>\n+\n+\t* config.gcc (tilepro-*-*): Change to tilepro*-*-*.\n+\t(tilegx-*-linux*): Change to tilegx*-*-linux*; Support tilegxbe\n+\ttriplet.\n+\t* common/config/tilegx/tilegx-common.c\n+\t(TARGET_DEFAULT_TARGET_FLAGS): Define.\n+\t* config/tilegx/linux.h (ASM_SPEC): Add endian_spec.\n+\t(LINK_SPEC): Ditto.\n+\t* config/tilegx/sync.md (atomic_test_and_set): Handle big endian.\n+\t* config/tilegx/tilegx.c (tilegx_return_in_msb): New.\n+\t(tilegx_gimplify_va_arg_expr): Handle big endian.\n+\t(tilegx_expand_unaligned_load): Ditto.\n+\t(tilegx_expand_unaligned_store): Ditto.\n+\t(TARGET_RETURN_IN_MSB): New.\n+\t* config/tilegx/tilegx.h (TARGET_DEFAULT): New.\n+\t(TARGET_ENDIAN_DEFAULT): New.\n+\t(TARGET_BIG_ENDIAN): Handle big endian.\n+\t(BYTES_BIG_ENDIAN): Ditto.\n+\t(WORDS_BIG_ENDIAN): Ditto.\n+\t(FLOAT_WORDS_BIG_ENDIAN): Ditto.\n+\t(ENDIAN_SPEC): New.\n+\t(EXTRA_SPECS): New.\n+\t* config/tilegx/tilegx.md (extv): Handle big endian.\n+\t(extzv): Ditto.\n+\t(insn_st<n>): Ditto.\n+\t(insn_st<n>_add<bitsuffix>): Ditto.\n+\t(insn_stnt<n>): Ditto.\n+\t(insn_stnt<n>_add<bitsuffix>):Ditto.\n+\t(vec_interleave_highv8qi): Handle big endian.\n+\t(vec_interleave_highv8qi_be): New.\n+\t(vec_interleave_highv8qi_le): New.\n+\t(insn_v1int_h): Handle big endian.\n+\t(vec_interleave_lowv8qi): Handle big endian.\n+\t(vec_interleave_lowv8qi_be): New.\n+\t(vec_interleave_lowv8qi_le): New.\n+\t(insn_v1int_l): Handle big endian.\n+\t(vec_interleave_highv4hi): Handle big endian.\n+\t(vec_interleave_highv4hi_be): New.\n+\t(vec_interleave_highv4hi_le): New.\n+\t(insn_v2int_h): Handle big endian.\n+\t(vec_interleave_lowv4hi): Handle big endian.\n+\t(vec_interleave_lowv4hi_be): New.\n+\t(vec_interleave_lowv4hi_le): New.\n+\t(insn_v2int_l): Handle big endian.\n+\t(vec_interleave_highv2si): Handle big endian.\n+\t(vec_interleave_highv2si_be): New.\n+\t(vec_interleave_highv2si_le): New.\n+\t(insn_v4int_h): Handle big endian.\n+\t(vec_interleave_lowv2si): Handle big endian.\n+\t(vec_interleave_lowv2si_be): New.\n+\t(vec_interleave_lowv2si_le): New.\n+\t(insn_v4int_l): Handle big endian.\n+\t* config/tilegx/tilegx.opt (mbig-endian): New option.\n+\t(mlittle-endian): New option.\n+\t* doc/install.texi: Document tilegxbe-linux.\n+\t* doc/invoke.texi: Document -mbig-endian and -mlittle-endian.\n+\n 2014-02-24  Martin Jambor  <mjambor@suse.cz>\n \n \tPR ipa/60266"}, {"sha": "ad6fdba2cbf6a3da20ba942fe3c3b3ca7055988d", "filename": "gcc/common/config/tilegx/tilegx-common.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/341c653c704e398070219534cd9fed97e56661b3/gcc%2Fcommon%2Fconfig%2Ftilegx%2Ftilegx-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/341c653c704e398070219534cd9fed97e56661b3/gcc%2Fcommon%2Fconfig%2Ftilegx%2Ftilegx-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon%2Fconfig%2Ftilegx%2Ftilegx-common.c?ref=341c653c704e398070219534cd9fed97e56661b3", "patch": "@@ -45,6 +45,11 @@ tilegx_option_init_struct (struct gcc_options *opts)\n }\n \n \n+#undef  TARGET_DEFAULT_TARGET_FLAGS\n+#define TARGET_DEFAULT_TARGET_FLAGS \\\n+  (TARGET_DEFAULT\t\t    \\\n+   | TARGET_ENDIAN_DEFAULT)\n+\n #undef  TARGET_OPTION_OPTIMIZATION_TABLE\n #define TARGET_OPTION_OPTIMIZATION_TABLE tilegx_option_optimization_table\n "}, {"sha": "2a3deaec92658ff7eda3f039e50481276cb8d48e", "filename": "gcc/config.gcc", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/341c653c704e398070219534cd9fed97e56661b3/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/341c653c704e398070219534cd9fed97e56661b3/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=341c653c704e398070219534cd9fed97e56661b3", "patch": "@@ -494,7 +494,7 @@ tilegx*-*-*)\n \tcpu_type=tilegx\n \tneed_64bit_hwint=yes\n \t;;\n-tilepro-*-*)\n+tilepro*-*-*)\n \tcpu_type=tilepro\n \tneed_64bit_hwint=yes\n \t;;\n@@ -2764,15 +2764,20 @@ tic6x-*-uclinux)\n \ttmake_file=\"${tmake_file} c6x/t-c6x c6x/t-c6x-elf c6x/t-c6x-uclinux\"\n \tuse_collect2=no\n \t;;\n-tilegx-*-linux*)\n+tilegx*-*-linux*)\n \ttm_file=\"elfos.h gnu-user.h linux.h glibc-stdint.h tilegx/linux.h ${tm_file}\"\n         tmake_file=\"${tmake_file} tilegx/t-tilegx\"\n \textra_objs=\"${extra_objs} mul-tables.o\"\n \tc_target_objs=\"${c_target_objs} tilegx-c.o\"\n \tcxx_target_objs=\"${cxx_target_objs} tilegx-c.o\"\n \textra_headers=\"feedback.h\"\n+\tcase $target in\n+\ttilegxbe-*)\n+\t\ttm_defines=\"${tm_defines} TARGET_BIG_ENDIAN_DEFAULT=1\"\n+ \t\t;;\n+\tesac\n \t;;\n-tilepro-*-linux*)\n+tilepro*-*-linux*)\n \ttm_file=\"elfos.h gnu-user.h linux.h glibc-stdint.h tilepro/linux.h ${tm_file}\"\n         tmake_file=\"${tmake_file} tilepro/t-tilepro\"\n \textra_objs=\"${extra_objs} mul-tables.o\""}, {"sha": "8cdedcbbe593665c10ccaa81d818872484e69b5f", "filename": "gcc/config/tilegx/linux.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/341c653c704e398070219534cd9fed97e56661b3/gcc%2Fconfig%2Ftilegx%2Flinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/341c653c704e398070219534cd9fed97e56661b3/gcc%2Fconfig%2Ftilegx%2Flinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilegx%2Flinux.h?ref=341c653c704e398070219534cd9fed97e56661b3", "patch": "@@ -22,10 +22,11 @@\n #define CPP_SPEC \"%{pthread:-D_REENTRANT}\"\n \n #undef ASM_SPEC\n-#define ASM_SPEC \"%{m32:--32} %{m64:--64}\"\n+#define ASM_SPEC \"%(endian_spec) %{m32:--32} %{m64:--64}\"\n \n #undef\tLINK_SPEC\n-#define LINK_SPEC \"%{m64:-m elf64tilegx} %{m32:-m elf32tilegx} \\\n+#define LINK_SPEC \"%(endian_spec) \\\n+  %{m64:-m elf64tilegx} %{m32:-m elf32tilegx} \\\n   %{shared:-shared} \\\n   %{!shared: \\\n     %{!static: \\"}, {"sha": "b32b662e67619a026b6b7a83e6910ee863a6a788", "filename": "gcc/config/tilegx/sync.md", "status": "modified", "additions": 19, "deletions": 9, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/341c653c704e398070219534cd9fed97e56661b3/gcc%2Fconfig%2Ftilegx%2Fsync.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/341c653c704e398070219534cd9fed97e56661b3/gcc%2Fconfig%2Ftilegx%2Fsync.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilegx%2Fsync.md?ref=341c653c704e398070219534cd9fed97e56661b3", "patch": "@@ -177,8 +177,7 @@\n    (match_operand:SI 2 \"const_int_operand\" \"\")]         ;; model\n   \"\"\n {\n-  rtx addr, aligned_addr, aligned_mem, offset, word, shmt;\n-  rtx tmp0, tmp1;\n+  rtx addr, aligned_addr, aligned_mem, offset, word, shmt, tmp;\n   rtx result = operands[0];\n   rtx mem = operands[1];\n   enum memmodel model = (enum memmodel) INTVAL (operands[2]);\n@@ -191,27 +190,38 @@\n   aligned_mem = change_address (mem, DImode, aligned_addr);\n   set_mem_alias_set (aligned_mem, 0);\n \n+  tmp = gen_reg_rtx (Pmode);\n+  if (BYTES_BIG_ENDIAN)\n+    {\n+      emit_move_insn (gen_lowpart (DImode, tmp),\n+                      gen_rtx_NOT (DImode, gen_lowpart (DImode, addr)));\n+    }\n+  else\n+    {\n+      tmp = addr;\n+    }\n+\n   offset = gen_reg_rtx (DImode);\n-  emit_move_insn (offset, gen_rtx_AND (DImode, gen_lowpart (DImode, addr),\n+  emit_move_insn (offset, gen_rtx_AND (DImode, gen_lowpart (DImode, tmp),\n                                        GEN_INT (7)));\n \n-  tmp0 = gen_reg_rtx (DImode);\n-  emit_move_insn (tmp0, GEN_INT (1));\n+  tmp = gen_reg_rtx (DImode);\n+  emit_move_insn (tmp, GEN_INT (1));\n \n   shmt = gen_reg_rtx (DImode);\n   emit_move_insn (shmt, gen_rtx_ASHIFT (DImode, offset, GEN_INT (3)));\n \n   word = gen_reg_rtx (DImode);\n-  emit_move_insn (word, gen_rtx_ASHIFT (DImode, tmp0,\n+  emit_move_insn (word, gen_rtx_ASHIFT (DImode, tmp,\n                                         gen_lowpart (SImode, shmt)));\n \n-  tmp1 = gen_reg_rtx (DImode);\n+  tmp = gen_reg_rtx (DImode);\n   tilegx_pre_atomic_barrier (model);\n-  emit_insn (gen_atomic_fetch_or_baredi (tmp1, aligned_mem, word));\n+  emit_insn (gen_atomic_fetch_or_baredi (tmp, aligned_mem, word));\n   tilegx_post_atomic_barrier (model);\n \n   emit_move_insn (gen_lowpart (DImode, result),\n-                  gen_rtx_LSHIFTRT (DImode, tmp1,\n+                  gen_rtx_LSHIFTRT (DImode, tmp,\n                                     gen_lowpart (SImode, shmt)));\n   DONE;\n })"}, {"sha": "c3b71261501bde22aea6c7ea7a4b4f5e64a092bd", "filename": "gcc/config/tilegx/tilegx.c", "status": "modified", "additions": 58, "deletions": 16, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/341c653c704e398070219534cd9fed97e56661b3/gcc%2Fconfig%2Ftilegx%2Ftilegx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/341c653c704e398070219534cd9fed97e56661b3/gcc%2Fconfig%2Ftilegx%2Ftilegx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilegx%2Ftilegx.c?ref=341c653c704e398070219534cd9fed97e56661b3", "patch": "@@ -175,6 +175,17 @@ tilegx_pass_by_reference (cumulative_args_t cum ATTRIBUTE_UNUSED,\n }\n \n \n+/* Implement TARGET_RETURN_IN_MSB.  We return a value in the most\n+   significant part of a register if:\n+   - the target is big-endian; and\n+   - the value has an aggregate type (e.g., structure or union).  */\n+static bool\n+tilegx_return_in_msb (const_tree valtype)\n+{\n+  return (TARGET_BIG_ENDIAN && AGGREGATE_TYPE_P (valtype));\n+}\n+\n+\n /* Implement TARGET_RETURN_IN_MEMORY.  */\n static bool\n tilegx_return_in_memory (const_tree type, const_tree fndecl ATTRIBUTE_UNUSED)\n@@ -440,7 +451,10 @@ tilegx_setup_incoming_varargs (cumulative_args_t cum,\n     else\n       addr = VALIST.__args;\n     VALIST.__args = addr + paddedsize;\n-    ret = *(TYPE *)addr;\n+    if (BYTES_BIG_ENDIAN)\n+      ret = *(TYPE *)(addr + paddedsize - sizeof(TYPE));\n+    else\n+      ret = *(TYPE *)addr;\n  */\n static tree\n tilegx_gimplify_va_arg_expr (tree valist, tree type, gimple_seq *pre_p,\n@@ -503,10 +517,17 @@ tilegx_gimplify_va_arg_expr (tree valist, tree type, gimple_seq *pre_p,\n \t\t\tsize_int (STACK_POINTER_OFFSET)),\n \t\tunshare_expr (args));\n \n+  /* Adjust the address of va_arg if it is in big endian mode.  */\n+  if (BYTES_BIG_ENDIAN && rsize > size)\n+    tmp = fold_build_pointer_plus_hwi (tmp, rsize - size);\n   gimplify_assign (addr, tmp, pre_p);\n \n   /* Update VALIST.__args.  */\n-  tmp = fold_build_pointer_plus_hwi (addr, rsize);\n+  \n+  if (BYTES_BIG_ENDIAN && rsize > size)\n+    tmp = fold_build_pointer_plus_hwi (addr, size);\n+  else\n+    tmp = fold_build_pointer_plus_hwi (addr, rsize);\n   gimplify_assign (unshare_expr (args), tmp, pre_p);\n \n   addr = fold_convert (build_pointer_type (type), addr);\n@@ -1847,39 +1868,51 @@ tilegx_expand_unaligned_load (rtx dest_reg, rtx mem, HOST_WIDE_INT bitsize,\n \n   mode = GET_MODE (dest_reg);\n \n-  hi = gen_reg_rtx (mode);\n-\n   if (bitsize == 2 * BITS_PER_UNIT && (bit_offset % BITS_PER_UNIT) == 0)\n     {\n+      rtx mem_left, mem_right;\n+      rtx left = gen_reg_rtx (mode);\n+\n       /* When just loading a two byte value, we can load the two bytes\n \t individually and combine them efficiently.  */\n \n       mem_lo = adjust_address (mem, QImode, byte_offset);\n       mem_hi = adjust_address (mem, QImode, byte_offset + 1);\n \n+      if (BYTES_BIG_ENDIAN)\n+\t{\n+\t  mem_left = mem_lo;\n+\t  mem_right = mem_hi;\n+\t}\n+      else\n+\t{\n+\t  mem_left = mem_hi;\n+\t  mem_right = mem_lo;\n+\t}\n+\n       if (sign)\n \t{\n \t  /* Do a signed load of the second byte and use bfins to set\n \t     the high bits of the result.  */\n \t  emit_insn (gen_zero_extendqidi2 (gen_lowpart (DImode, dest_reg),\n-\t\t\t\t\t   mem_lo));\n-\t  emit_insn (gen_extendqidi2 (gen_lowpart (DImode, hi), mem_hi));\n+\t\t\t\t\t   mem_right));\n+\t  emit_insn (gen_extendqidi2 (gen_lowpart (DImode, left), mem_left));\n \t  emit_insn (gen_insv (gen_lowpart (DImode, dest_reg),\n \t\t\t       GEN_INT (64 - 8), GEN_INT (8),\n-\t\t\t       gen_lowpart (DImode, hi)));\n+\t\t\t       gen_lowpart (DImode, left)));\n \t}\n       else\n \t{\n \t  /* Do two unsigned loads and use v1int_l to interleave\n \t     them.  */\n-\t  rtx lo = gen_reg_rtx (mode);\n-\t  emit_insn (gen_zero_extendqidi2 (gen_lowpart (DImode, lo),\n-\t\t\t\t\t   mem_lo));\n-\t  emit_insn (gen_zero_extendqidi2 (gen_lowpart (DImode, hi),\n-\t\t\t\t\t   mem_hi));\n+\t  rtx right = gen_reg_rtx (mode);\n+\t  emit_insn (gen_zero_extendqidi2 (gen_lowpart (DImode, right),\n+\t\t\t\t\t   mem_right));\n+\t  emit_insn (gen_zero_extendqidi2 (gen_lowpart (DImode, left),\n+\t\t\t\t\t   mem_left));\n \t  emit_insn (gen_insn_v1int_l (gen_lowpart (DImode, dest_reg),\n-\t\t\t\t       gen_lowpart (DImode, hi),\n-\t\t\t\t       gen_lowpart (DImode, lo)));\n+\t\t\t\t       gen_lowpart (DImode, left),\n+\t\t\t\t       gen_lowpart (DImode, right)));\n \t}\n \n       return;\n@@ -1917,6 +1950,7 @@ tilegx_expand_unaligned_load (rtx dest_reg, rtx mem, HOST_WIDE_INT bitsize,\n     }\n \n   /* Load hi first in case dest_reg is used in mema.  */\n+  hi = gen_reg_rtx (mode);\n   emit_move_insn (hi, mem_hi);\n   emit_move_insn (wide_result, mem_lo);\n \n@@ -1945,12 +1979,17 @@ tilegx_expand_unaligned_store (rtx mem, rtx src, HOST_WIDE_INT bitsize,\n {\n   HOST_WIDE_INT byte_offset = bit_offset / BITS_PER_UNIT;\n   HOST_WIDE_INT bytesize = bitsize / BITS_PER_UNIT;\n-  HOST_WIDE_INT shift_amt;\n+  HOST_WIDE_INT shift_init, shift_increment, shift_amt;\n   HOST_WIDE_INT i;\n   rtx mem_addr;\n   rtx store_val;\n \n-  for (i = 0, shift_amt = 0; i < bytesize; i++, shift_amt += BITS_PER_UNIT)\n+  shift_init = BYTES_BIG_ENDIAN ? (bitsize - BITS_PER_UNIT) : 0;\n+  shift_increment = BYTES_BIG_ENDIAN ? -BITS_PER_UNIT : BITS_PER_UNIT;\n+\n+  for (i = 0, shift_amt = shift_init;\n+       i < bytesize;\n+       i++, shift_amt += shift_increment)\n     {\n       mem_addr = adjust_address (mem, QImode, byte_offset + i);\n \n@@ -5530,6 +5569,9 @@ tilegx_file_end (void)\n #undef  TARGET_PASS_BY_REFERENCE\n #define TARGET_PASS_BY_REFERENCE tilegx_pass_by_reference\n \n+#undef  TARGET_RETURN_IN_MSB\n+#define TARGET_RETURN_IN_MSB tilegx_return_in_msb\n+\n #undef  TARGET_RETURN_IN_MEMORY\n #define TARGET_RETURN_IN_MEMORY tilegx_return_in_memory\n "}, {"sha": "f241fe4f244bef56bf4d460e0d98923eb6eabcea", "filename": "gcc/config/tilegx/tilegx.h", "status": "modified", "additions": 37, "deletions": 3, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/341c653c704e398070219534cd9fed97e56661b3/gcc%2Fconfig%2Ftilegx%2Ftilegx.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/341c653c704e398070219534cd9fed97e56661b3/gcc%2Fconfig%2Ftilegx%2Ftilegx.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilegx%2Ftilegx.h?ref=341c653c704e398070219534cd9fed97e56661b3", "patch": "@@ -18,6 +18,23 @@\n    along with GCC; see the file COPYING3.  If not see\n    <http://www.gnu.org/licenses/>.  */\n \n+/* Default target_flags if no switches are specified  */\n+#ifndef TARGET_DEFAULT\n+#define TARGET_DEFAULT 0\n+#endif\n+\n+#ifndef TARGET_BIG_ENDIAN_DEFAULT\n+#define TARGET_BIG_ENDIAN_DEFAULT 0\n+#endif\n+\n+#ifndef TARGET_ENDIAN_DEFAULT\n+#if TARGET_BIG_ENDIAN_DEFAULT\n+#define TARGET_ENDIAN_DEFAULT MASK_BIG_ENDIAN\n+#else\n+#define TARGET_ENDIAN_DEFAULT 0\n+#endif\n+#endif\n+\n /* This is used by tilegx_cpu_cpp_builtins to indicate the byte order\n    we're compiling for.  */\n #define TILEGX_CPU_CPP_ENDIAN_BUILTINS()\t\\\n@@ -52,10 +69,10 @@\n \n /* Target machine storage layout */\n \n-#define TARGET_BIG_ENDIAN 0\n #define BITS_BIG_ENDIAN 0\n-#define BYTES_BIG_ENDIAN TARGET_BIG_ENDIAN\n-#define WORDS_BIG_ENDIAN TARGET_BIG_ENDIAN\n+#define BYTES_BIG_ENDIAN (TARGET_BIG_ENDIAN != 0)\n+#define WORDS_BIG_ENDIAN (TARGET_BIG_ENDIAN != 0)\n+#define FLOAT_WORDS_BIG_ENDIAN (TARGET_BIG_ENDIAN != 0)\n \n #define UNITS_PER_WORD 8\n #define PARM_BOUNDARY BITS_PER_WORD\n@@ -520,3 +537,20 @@ typedef struct GTY(()) machine_function\n #ifndef HAVE_AS_TLS\n #define HAVE_AS_TLS 0\n #endif\n+\n+#ifndef ENDIAN_SPEC\n+#if TARGET_BIG_ENDIAN_DEFAULT\n+#define ENDIAN_SPEC \\\n+  \"%{!mlittle-endian:-EB} \\\n+   %{mlittle-endian:%{mbig-endian: \\\n+     %e-mbig-endian and -mlittle-endian may not be used together}-EL}\"\n+#else\n+#define ENDIAN_SPEC \\\n+  \"%{!mbig-endian:-EL} \\\n+   %{mbig-endian:%{mlittle-endian: \\\n+    %e-mbig-endian and -mlittle-endian may not be used together}-EB}\"\n+#endif\n+#endif\n+\n+#define EXTRA_SPECS\t\t\\\n+  { \"endian_spec\", ENDIAN_SPEC }"}, {"sha": "94946bb9b5629ea81727a37f8784899d4133d425", "filename": "gcc/config/tilegx/tilegx.md", "status": "modified", "additions": 243, "deletions": 38, "changes": 281, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/341c653c704e398070219534cd9fed97e56661b3/gcc%2Fconfig%2Ftilegx%2Ftilegx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/341c653c704e398070219534cd9fed97e56661b3/gcc%2Fconfig%2Ftilegx%2Ftilegx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilegx%2Ftilegx.md?ref=341c653c704e398070219534cd9fed97e56661b3", "patch": "@@ -824,6 +824,12 @@\n       bit_width = INTVAL (operands[2]);\n       bit_offset = INTVAL (operands[3]);\n \n+      /* NOTE: bit_offset is relative to the mode of operand\n+         1 (QImode).  It will be negative in big-endian mode\n+         here.  Convert that back to the real offset.  */\n+      if (BYTES_BIG_ENDIAN)\n+        bit_offset = GET_MODE_BITSIZE (QImode) - bit_width - bit_offset;\n+\n       /* Reject bitfields that can be done with a normal load.  */\n       if (MEM_ALIGN (operands[1]) >= bit_offset + bit_width)\n         FAIL;\n@@ -860,6 +866,12 @@\n       if (GET_MODE (operands[1]) != QImode)\n         FAIL;\n \n+      /* NOTE: bit_offset is relative to the mode of operand\n+         1 (QImode).  It will be negative in big-endian mode\n+         here. */\n+      if (BYTES_BIG_ENDIAN)\n+        bit_offset = GET_MODE_BITSIZE (QImode) - bit_width - bit_offset;\n+ \n       /* Reject bitfields that can be done with a normal load.  */\n       if (MEM_ALIGN (operands[1]) >= bit_offset + bit_width)\n         FAIL;\n@@ -3983,7 +3995,9 @@\n         (match_operand:DI 1 \"reg_or_0_operand\" \"\"))]\n   \"\"\n {\n-  operands[1] = simplify_gen_subreg (<MODE>mode, operands[1], DImode, 0);\n+  operands[1] = simplify_gen_subreg (<MODE>mode, operands[1], DImode,\n+                                     BYTES_BIG_ENDIAN\n+\t\t\t\t     ? UNITS_PER_WORD - <n>  : 0);\n })\n \n (define_expand \"insn_st<I124MODE:n>_add<I48MODE:bitsuffix>\"\n@@ -3996,7 +4010,9 @@\n   \"\"\n {\n   operands[1] = simplify_gen_subreg (<I124MODE:MODE>mode, operands[1],\n-\t\t\t\t     DImode, 0);\n+\t\t\t\t     DImode,\n+\t\t\t\t     BYTES_BIG_ENDIAN\n+\t\t\t\t     ? UNITS_PER_WORD - <I124MODE:n> : 0);\n })\n \n (define_insn \"*insn_st<I124MODE:n>_add<I48MODE:bitsuffix>\"\n@@ -4035,7 +4051,9 @@\n         (match_operand:DI 1 \"reg_or_0_operand\" \"\"))]\n   \"\"\n {\n-  operands[1] = simplify_gen_subreg (<MODE>mode, operands[1], DImode, 0);\n+  operands[1] = simplify_gen_subreg (<MODE>mode, operands[1], DImode,\n+                                     BYTES_BIG_ENDIAN\n+\t\t\t\t     ? UNITS_PER_WORD - <n> : 0);\n })\n \n (define_insn \"*insn_stnt<n>\"\n@@ -4056,7 +4074,9 @@\n   \"\"\n {\n   operands[1] = simplify_gen_subreg (<I124MODE:MODE>mode, operands[1],\n-\t\t\t\t     DImode, 0);\n+\t\t\t\t     DImode,\n+\t\t\t\t     BYTES_BIG_ENDIAN\n+\t\t\t\t     ? UNITS_PER_WORD - <n> : 0);\n })\n \n (define_insn \"*insn_stnt<I124MODE:n>_add<I48MODE:bitsuffix>\"\n@@ -4412,11 +4432,46 @@\n   DONE;\n })\n \n+;; Byte ordering of these vectors is endian dependent.  gcc concats\n+;; right-to-left for little endian, and left-to-right for big endian.\n+;; So we need different patterns that depend on endianness.  Our\n+;; instructions concat and interleave the way a big-endian target would\n+;; work in gcc, so for little endian, we need to reverse the source\n+;; operands.\n+\n ;; insn_v1int_h\n ;;    {B7,B6,B5,B4,B3,B2,B1,B0} {A7,A6,A5,A4,A3,A2,A1,A0}\n ;; => {A7,A6,A5,A4,A3,A2,A1,A0,B7,B6,B5,B4,B3,B2,B1,B0}\n ;; => {A7,B7,A6,B6,A5,B5,A4,B4}\n-(define_insn \"vec_interleave_highv8qi\"\n+(define_expand \"vec_interleave_highv8qi\"\n+  [(match_operand:V8QI 0 \"register_operand\" \"\")\n+   (match_operand:V8QI 1 \"reg_or_0_operand\" \"\")\n+   (match_operand:V8QI 2 \"reg_or_0_operand\" \"\")]\n+  \"\"\n+{\n+  if (BYTES_BIG_ENDIAN)\n+    emit_insn (gen_vec_interleave_highv8qi_be (operands[0], operands[1],\n+\t\t\t\t\t       operands[2]));\n+  else\n+    emit_insn (gen_vec_interleave_highv8qi_le (operands[0], operands[1],\n+\t\t\t\t\t       operands[2]));\n+  DONE;\n+})\n+\n+(define_insn \"vec_interleave_highv8qi_be\"\n+  [(set (match_operand:V8QI 0 \"register_operand\" \"=r\")\n+\t(vec_select:V8QI\n+\t (vec_concat:V16QI (match_operand:V8QI 1 \"reg_or_0_operand\" \"rO\")\n+\t\t\t   (match_operand:V8QI 2 \"reg_or_0_operand\" \"rO\"))\n+\t (parallel [(const_int 0) (const_int 8)\n+\t\t    (const_int 1) (const_int 9)\n+\t\t    (const_int 2) (const_int 10)\n+\t\t    (const_int 3) (const_int 11)])))]\n+  \"BYTES_BIG_ENDIAN\"\n+  \"v1int_h\\t%0, %r1, %r2\"\n+  [(set_attr \"type\" \"X01\")])\n+\n+(define_insn \"vec_interleave_highv8qi_le\"\n   [(set (match_operand:V8QI 0 \"register_operand\" \"=r\")\n \t(vec_select:V8QI\n \t (vec_concat:V16QI (match_operand:V8QI 1 \"reg_or_0_operand\" \"rO\")\n@@ -4425,7 +4480,7 @@\n \t\t    (const_int 5) (const_int 13) \n \t\t    (const_int 6) (const_int 14) \n \t\t    (const_int 7) (const_int 15)])))]\n-  \"\"\n+  \"!BYTES_BIG_ENDIAN\"\n   \"v1int_h\\t%0, %r2, %r1\"\n   [(set_attr \"type\" \"X01\")])\n \n@@ -4435,19 +4490,50 @@\n    (match_operand:DI 2 \"reg_or_0_operand\" \"\")]\n   \"\"\n {\n-  /* Our instruction interleaves opposite of the way vec_interleave\n-     works, so we need to reverse the source operands.  */\n+  /* For little endian, our instruction interleaves opposite of the\n+     way vec_interleave works, so we need to reverse the source\n+     operands.  */\n+  rtx opnd1 = BYTES_BIG_ENDIAN ? operands[1] : operands[2];\n+  rtx opnd2 = BYTES_BIG_ENDIAN ? operands[2] : operands[1];\n   tilegx_expand_builtin_vector_binop (gen_vec_interleave_highv8qi, V8QImode,\n-\t\t\t\t      operands[0], V8QImode, operands[2],\n-\t\t\t\t      operands[1], true);\n+\t\t\t\t      operands[0], V8QImode, opnd1, opnd2,\n+\t\t\t\t      true);\n   DONE;\n })\n \n ;; insn_v1int_l\n ;;    {B7,B6,B5,B4,B3,B2,B1,B0} {A7,A6,A5,A4,A3,A2,A1,A0}\n ;; => {A7,A6,A5,A4,A3,A2,A1,A0,B7,B6,B5,B4,B3,B2,B1,B0}\n ;; => {A3,B3,A2,B2,A1,B1,A0,B0}\n-(define_insn \"vec_interleave_lowv8qi\"\n+(define_expand \"vec_interleave_lowv8qi\"\n+  [(match_operand:V8QI 0 \"register_operand\" \"\")\n+   (match_operand:V8QI 1 \"reg_or_0_operand\" \"\")\n+   (match_operand:V8QI 2 \"reg_or_0_operand\" \"\")]\n+  \"\"\n+{\n+  if (BYTES_BIG_ENDIAN)\n+    emit_insn (gen_vec_interleave_lowv8qi_be (operands[0], operands[1],\n+\t\t\t\t\t      operands[2]));\n+  else\n+    emit_insn (gen_vec_interleave_lowv8qi_le (operands[0], operands[1],\n+\t\t\t\t\t      operands[2]));\n+  DONE;\n+})\n+\n+(define_insn \"vec_interleave_lowv8qi_be\"\n+  [(set (match_operand:V8QI 0 \"register_operand\" \"=r\")\n+\t(vec_select:V8QI\n+\t (vec_concat:V16QI (match_operand:V8QI 1 \"reg_or_0_operand\" \"rO\")\n+\t\t\t   (match_operand:V8QI 2 \"reg_or_0_operand\" \"rO\"))\n+\t (parallel [(const_int 4) (const_int 12)\n+\t\t    (const_int 5) (const_int 13)\n+\t\t    (const_int 6) (const_int 14)\n+\t\t    (const_int 7) (const_int 15)])))]\n+  \"BYTES_BIG_ENDIAN\"\n+  \"v1int_l\\t%0, %r1, %r2\"\n+  [(set_attr \"type\" \"X01\")])\n+\n+(define_insn \"vec_interleave_lowv8qi_le\"\n   [(set (match_operand:V8QI 0 \"register_operand\" \"=r\")\n \t(vec_select:V8QI\n \t (vec_concat:V16QI (match_operand:V8QI 1 \"reg_or_0_operand\" \"rO\")\n@@ -4456,7 +4542,7 @@\n \t\t    (const_int 1) (const_int 9)\n \t\t    (const_int 2) (const_int 10)\n \t\t    (const_int 3) (const_int 11)])))]\n-  \"\"\n+  \"!BYTES_BIG_ENDIAN\"\n   \"v1int_l\\t%0, %r2, %r1\"\n   [(set_attr \"type\" \"X01\")])\n \n@@ -4466,26 +4552,55 @@\n    (match_operand:DI 2 \"reg_or_0_operand\" \"\")]\n   \"\"\n {\n-  /* Our instruction interleaves opposite of the way vec_interleave\n-     works, so we need to reverse the source operands.  */\n+  /* For little endian, our instruction interleaves opposite of the\n+     way vec_interleave works, so we need to reverse the source\n+     operands.  */\n+  rtx opnd1 = BYTES_BIG_ENDIAN ? operands[1] : operands[2];\n+  rtx opnd2 = BYTES_BIG_ENDIAN ? operands[2] : operands[1];\n   tilegx_expand_builtin_vector_binop (gen_vec_interleave_lowv8qi, V8QImode,\n-\t\t\t\t      operands[0], V8QImode, operands[2],\n-\t\t\t\t      operands[1], true);\n+\t\t\t\t      operands[0], V8QImode, opnd1, opnd2,\n+\t\t\t\t      true);\n   DONE;\n })\n \n ;; insn_v2int_h\n ;;    {B3,B2,B1,B0} {A3,A2,A1,A0}\n ;; => {A3,A2,A1,A0,B3,B2,B1,B0}\n ;; => {A3,B3,A2,B2}\n-(define_insn \"vec_interleave_highv4hi\"\n+(define_expand \"vec_interleave_highv4hi\"\n+  [(match_operand:V4HI 0 \"register_operand\" \"\")\n+   (match_operand:V4HI 1 \"reg_or_0_operand\" \"\")\n+   (match_operand:V4HI 2 \"reg_or_0_operand\" \"\")]\n+  \"\"\n+{\n+  if (BYTES_BIG_ENDIAN)\n+    emit_insn (gen_vec_interleave_highv4hi_be (operands[0], operands[1],\n+\t\t\t\t\t       operands[2]));\n+  else\n+    emit_insn (gen_vec_interleave_highv4hi_le (operands[0], operands[1],\n+\t\t\t\t\t       operands[2]));\n+  DONE;\n+})\n+\n+(define_insn \"vec_interleave_highv4hi_be\"\n+  [(set (match_operand:V4HI 0 \"register_operand\" \"=r\")\n+\t(vec_select:V4HI\n+\t (vec_concat:V8HI (match_operand:V4HI 1 \"reg_or_0_operand\" \"rO\")\n+\t\t\t  (match_operand:V4HI 2 \"reg_or_0_operand\" \"rO\"))\n+\t (parallel [(const_int 0) (const_int 4)\n+\t\t    (const_int 1) (const_int 5)])))]\n+  \"BYTES_BIG_ENDIAN\"\n+  \"v2int_h\\t%0, %r1, %r2\"\n+  [(set_attr \"type\" \"X01\")])\n+\n+(define_insn \"vec_interleave_highv4hi_le\"\n   [(set (match_operand:V4HI 0 \"register_operand\" \"=r\")\n \t(vec_select:V4HI\n \t (vec_concat:V8HI (match_operand:V4HI 1 \"reg_or_0_operand\" \"rO\")\n \t\t\t  (match_operand:V4HI 2 \"reg_or_0_operand\" \"rO\"))\n \t (parallel [(const_int 2) (const_int 6)\n \t\t    (const_int 3) (const_int 7)])))]\n-  \"\"\n+  \"!BYTES_BIG_ENDIAN\"\n   \"v2int_h\\t%0, %r2, %r1\"\n   [(set_attr \"type\" \"X01\")])\n \n@@ -4495,26 +4610,55 @@\n    (match_operand:DI 2 \"reg_or_0_operand\" \"\")]\n   \"\"\n {\n-  /* Our instruction interleaves opposite of the way vec_interleave\n-     works, so we need to reverse the source operands.  */\n+  /* For little endian, our instruction interleaves opposite of the\n+     way vec_interleave works, so we need to reverse the source\n+     operands.  */\n+  rtx opnd1 = BYTES_BIG_ENDIAN ? operands[1] : operands[2];\n+  rtx opnd2 = BYTES_BIG_ENDIAN ? operands[2] : operands[1];\n   tilegx_expand_builtin_vector_binop (gen_vec_interleave_highv4hi, V4HImode,\n-                                      operands[0], V4HImode, operands[2],\n-\t\t\t\t      operands[1], true);\n+                                      operands[0], V4HImode, opnd1, opnd2,\n+\t\t\t\t      true);\n   DONE;\n })\n \n ;; insn_v2int_l\n ;;    {B3,B2,B1,B0} {A3,A2,A1,A0}\n ;; => {A3,A2,A1,A0,B3,B2,B1,B0}\n ;; => {A1,B1,A0,B0}\n-(define_insn \"vec_interleave_lowv4hi\"\n+(define_expand \"vec_interleave_lowv4hi\"\n+  [(match_operand:V4HI 0 \"register_operand\" \"\")\n+   (match_operand:V4HI 1 \"reg_or_0_operand\" \"\")\n+   (match_operand:V4HI 2 \"reg_or_0_operand\" \"\")]\n+  \"\"\n+{\n+  if (BYTES_BIG_ENDIAN)\n+    emit_insn (gen_vec_interleave_lowv4hi_be (operands[0], operands[1],\n+\t\t\t\t\t      operands[2]));\n+  else\n+    emit_insn (gen_vec_interleave_lowv4hi_le (operands[0], operands[1],\n+\t\t\t\t\t      operands[2]));\n+  DONE;\n+})\n+\n+(define_insn \"vec_interleave_lowv4hi_be\"\n+  [(set (match_operand:V4HI 0 \"register_operand\" \"=r\")\n+\t(vec_select:V4HI\n+\t (vec_concat:V8HI (match_operand:V4HI 1 \"reg_or_0_operand\" \"rO\")\n+\t\t\t  (match_operand:V4HI 2 \"reg_or_0_operand\" \"rO\"))\n+\t (parallel [(const_int 2) (const_int 6)\n+\t\t    (const_int 3) (const_int 7)])))]\n+  \"BYTES_BIG_ENDIAN\"\n+  \"v2int_l\\t%0, %r1, %r2\"\n+  [(set_attr \"type\" \"X01\")])\n+\n+(define_insn \"vec_interleave_lowv4hi_le\"\n   [(set (match_operand:V4HI 0 \"register_operand\" \"=r\")\n \t(vec_select:V4HI\n \t (vec_concat:V8HI (match_operand:V4HI 1 \"reg_or_0_operand\" \"rO\")\n \t\t\t  (match_operand:V4HI 2 \"reg_or_0_operand\" \"rO\"))\n \t (parallel [(const_int 0) (const_int 4)\n \t\t    (const_int 1) (const_int 5)])))]\n-  \"\"\n+  \"!BYTES_BIG_ENDIAN\"\n   \"v2int_l\\t%0, %r2, %r1\"\n   [(set_attr \"type\" \"X01\")])\n \n@@ -4524,23 +4668,53 @@\n    (match_operand:DI 2 \"reg_or_0_operand\" \"\")]\n   \"\"\n {\n+  /* For little endian, our instruction interleaves opposite of the\n+     way vec_interleave works, so we need to reverse the source\n+     operands.  */\n+  rtx opnd1 = BYTES_BIG_ENDIAN ? operands[1] : operands[2];\n+  rtx opnd2 = BYTES_BIG_ENDIAN ? operands[2] : operands[1];\n   tilegx_expand_builtin_vector_binop (gen_vec_interleave_lowv4hi, V4HImode,\n-                                      operands[0], V4HImode, operands[2],\n-\t\t\t\t      operands[1], true);\n+                                      operands[0], V4HImode, opnd1, opnd2,\n+\t\t\t\t      true);\n   DONE;\n })\n \n ;; insn_v4int_h\n ;;    {B1,B0} {A1,A0}\n ;; => {A1,A0,B1,B0}\n ;; => {A1,B1}\n-(define_insn \"vec_interleave_highv2si\"\n+(define_expand \"vec_interleave_highv2si\"\n+  [(match_operand:V2SI 0 \"register_operand\" \"\")\n+   (match_operand:V2SI 1 \"reg_or_0_operand\" \"\")\n+   (match_operand:V2SI 2 \"reg_or_0_operand\" \"\")]\n+  \"\"\n+{\n+  if (BYTES_BIG_ENDIAN)\n+    emit_insn (gen_vec_interleave_highv2si_be (operands[0], operands[1],\n+\t\t\t\t\t       operands[2]));\n+  else\n+    emit_insn (gen_vec_interleave_highv2si_le (operands[0], operands[1],\n+\t\t\t\t\t       operands[2]));\n+  DONE;\n+})\n+\n+(define_insn \"vec_interleave_highv2si_be\"\n+  [(set (match_operand:V2SI 0 \"register_operand\" \"=r\")\n+\t(vec_select:V2SI\n+\t (vec_concat:V4SI (match_operand:V2SI 1 \"reg_or_0_operand\" \"rO\")\n+\t\t\t  (match_operand:V2SI 2 \"reg_or_0_operand\" \"rO\"))\n+\t (parallel [(const_int 0) (const_int 2)])))]\n+  \"BYTES_BIG_ENDIAN\"\n+  \"v4int_h\\t%0, %r1, %r2\"\n+  [(set_attr \"type\" \"X01\")])\n+\n+(define_insn \"vec_interleave_highv2si_le\"\n   [(set (match_operand:V2SI 0 \"register_operand\" \"=r\")\n \t(vec_select:V2SI\n \t (vec_concat:V4SI (match_operand:V2SI 1 \"reg_or_0_operand\" \"rO\")\n \t\t\t  (match_operand:V2SI 2 \"reg_or_0_operand\" \"rO\"))\n \t (parallel [(const_int 1) (const_int 3)])))]\n-  \"\"\n+  \"!BYTES_BIG_ENDIAN\"\n   \"v4int_h\\t%0, %r2, %r1\"\n   [(set_attr \"type\" \"X01\")])\n \n@@ -4550,25 +4724,53 @@\n    (match_operand:DI 2 \"reg_or_0_operand\" \"\")]\n   \"\"\n {\n-  /* Our instruction interleaves opposite of the way vec_interleave\n-     works, so we need to reverse the source operands.  */\n+  /* For little endian, our instruction interleaves opposite of the\n+     way vec_interleave works, so we need to reverse the source\n+     operands.  */\n+  rtx opnd1 = BYTES_BIG_ENDIAN ? operands[1] : operands[2];\n+  rtx opnd2 = BYTES_BIG_ENDIAN ? operands[2] : operands[1];\n   tilegx_expand_builtin_vector_binop (gen_vec_interleave_highv2si, V2SImode,\n-                                      operands[0], V2SImode, operands[2],\n-\t\t\t\t      operands[1], true);\n+                                      operands[0], V2SImode, opnd1, opnd2,\n+\t\t\t\t      true);\n   DONE;\n })\n \n ;; insn_v4int_l\n ;;    {B1,B0} {A1,A0}\n ;; => {A1,A0,B1,B0}\n ;; => {A0,B0}\n-(define_insn \"vec_interleave_lowv2si\"\n+(define_expand \"vec_interleave_lowv2si\"\n+  [(match_operand:V2SI 0 \"register_operand\" \"\")\n+   (match_operand:V2SI 1 \"reg_or_0_operand\" \"\")\n+   (match_operand:V2SI 2 \"reg_or_0_operand\" \"\")]\n+  \"\"\n+{\n+  if (BYTES_BIG_ENDIAN)\n+    emit_insn (gen_vec_interleave_lowv2si_be (operands[0], operands[1],\n+\t\t\t\t\t      operands[2]));\n+  else\n+    emit_insn (gen_vec_interleave_lowv2si_le (operands[0], operands[1],\n+\t\t\t\t\t      operands[2]));\n+  DONE;\n+})\n+\n+(define_insn \"vec_interleave_lowv2si_be\"\n+  [(set (match_operand:V2SI 0 \"register_operand\" \"=r\")\n+\t(vec_select:V2SI\n+\t (vec_concat:V4SI (match_operand:V2SI 1 \"reg_or_0_operand\" \"rO\")\n+\t\t\t  (match_operand:V2SI 2 \"reg_or_0_operand\" \"rO\"))\n+\t (parallel [(const_int 1) (const_int 3)])))]\n+  \"BYTES_BIG_ENDIAN\"\n+  \"v4int_l\\t%0, %r1, %r2\"\n+  [(set_attr \"type\" \"X01\")])\n+\n+(define_insn \"vec_interleave_lowv2si_le\"\n   [(set (match_operand:V2SI 0 \"register_operand\" \"=r\")\n \t(vec_select:V2SI\n \t (vec_concat:V4SI (match_operand:V2SI 1 \"reg_or_0_operand\" \"rO\")\n \t\t\t  (match_operand:V2SI 2 \"reg_or_0_operand\" \"rO\"))\n \t (parallel [(const_int 0) (const_int 2)])))]\n-  \"\"\n+  \"!BYTES_BIG_ENDIAN\"\n   \"v4int_l\\t%0, %r2, %r1\"\n   [(set_attr \"type\" \"X01\")])\n \n@@ -4578,11 +4780,14 @@\n    (match_operand:DI 2 \"reg_or_0_operand\" \"\")]\n   \"\"\n {\n-  /* Our instruction interleaves opposite of the way vec_interleave\n-     works, so we need to reverse the source operands.  */\n+  /* For little endian, our instruction interleaves opposite of the\n+     way vec_interleave works, so we need to reverse the source\n+     operands.  */\n+  rtx opnd1 = BYTES_BIG_ENDIAN ? operands[1] : operands[2];\n+  rtx opnd2 = BYTES_BIG_ENDIAN ? operands[2] : operands[1];\n   tilegx_expand_builtin_vector_binop (gen_vec_interleave_lowv2si, V2SImode,\n-                                      operands[0], V2SImode, operands[2],\n-\t\t\t\t      operands[1], true);\n+                                      operands[0], V2SImode, opnd1, opnd2,\n+\t\t\t\t      true);\n   DONE;\n })\n "}, {"sha": "37c12fe1f4f1ad8b02d12b6e022f29d0cc63070b", "filename": "gcc/config/tilegx/tilegx.opt", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/341c653c704e398070219534cd9fed97e56661b3/gcc%2Fconfig%2Ftilegx%2Ftilegx.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/341c653c704e398070219534cd9fed97e56661b3/gcc%2Fconfig%2Ftilegx%2Ftilegx.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilegx%2Ftilegx.opt?ref=341c653c704e398070219534cd9fed97e56661b3", "patch": "@@ -40,6 +40,14 @@ m64\n Target Report RejectNegative Negative(m32) InverseMask(32BIT, 64BIT)\n Compile with 64 bit longs and pointers.\n \n+mbig-endian\n+Target Report RejectNegative Mask(BIG_ENDIAN)\n+Use big-endian byte order.\n+\n+mlittle-endian\n+Target Report RejectNegative InverseMask(BIG_ENDIAN)\n+Use little-endian byte order.\n+\n mcmodel=\n Target RejectNegative Joined Enum(cmodel) Var(tilegx_cmodel) Init(CM_SMALL)\n Use given TILE-Gx code model"}, {"sha": "dc040cbc387490d8833306c9f49638d89278bc6d", "filename": "gcc/doc/install.texi", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/341c653c704e398070219534cd9fed97e56661b3/gcc%2Fdoc%2Finstall.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/341c653c704e398070219534cd9fed97e56661b3/gcc%2Fdoc%2Finstall.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finstall.texi?ref=341c653c704e398070219534cd9fed97e56661b3", "patch": "@@ -3188,6 +3188,8 @@ information have to.\n @item\n @uref{#tilegx-x-linux,,tilegx-*-linux*}\n @item\n+@uref{#tilegxbe-x-linux,,tilegxbe-*-linux*}\n+@item\n @uref{#tilepro-x-linux,,tilepro-*-linux*}\n @item\n @uref{#x-x-vxworks,,*-*-vxworks*}\n@@ -4480,8 +4482,16 @@ The C6X family of processors. This port requires binutils-2.22 or newer.\n @end html\n @anchor{tilegx-*-linux}\n @heading tilegx-*-linux*\n-The TILE-Gx processor running GNU/Linux.  This port requires\n-binutils-2.22 or newer.\n+The TILE-Gx processor in little endian mode, running GNU/Linux.  This\n+port requires binutils-2.22 or newer.\n+\n+@html\n+<hr />\n+@end html\n+@anchor{tilegxbe-*-linux}\n+@heading tilegxbe-*-linux*\n+The TILE-Gx processor in big endian mode, running GNU/Linux.  This\n+port requires binutils-2.23 or newer.\n \n @html\n <hr />"}, {"sha": "3d4812f98c156dd8618a1a79800e2d6fa07bd021", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/341c653c704e398070219534cd9fed97e56661b3/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/341c653c704e398070219534cd9fed97e56661b3/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=341c653c704e398070219534cd9fed97e56661b3", "patch": "@@ -1012,7 +1012,8 @@ See RS/6000 and PowerPC Options.\n @gccoptlist{-Qy  -Qn  -YP,@var{paths}  -Ym,@var{dir}}\n \n @emph{TILE-Gx Options}\n-@gccoptlist{-mcpu=@var{cpu} -m32 -m64 -mcmodel=@var{code-model}}\n+@gccoptlist{-mcpu=CPU -m32 -m64 -mbig-endian -mlittle-endian @gol\n+-mcmodel=@var{code-model}}\n \n @emph{TILEPro Options}\n @gccoptlist{-mcpu=@var{cpu} -m32}\n@@ -21344,6 +21345,12 @@ type is @samp{tilegx}.\n Generate code for a 32-bit or 64-bit environment.  The 32-bit\n environment sets int, long, and pointer to 32 bits.  The 64-bit\n environment sets int to 32 bits and long and pointer to 64 bits.\n+\n+@item -mbig-endian\n+@itemx -mlittle-endian\n+@opindex mbig-endian\n+@opindex mlittle-endian\n+Generate code in big/little endian mode, respectively.\n @end table\n \n @node TILEPro Options"}, {"sha": "3a63434157b14b44d9545dfacf22988ad0cc9f4e", "filename": "libcpp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/341c653c704e398070219534cd9fed97e56661b3/libcpp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/341c653c704e398070219534cd9fed97e56661b3/libcpp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2FChangeLog?ref=341c653c704e398070219534cd9fed97e56661b3", "patch": "@@ -1,3 +1,8 @@\n+2014-02-24  Walter Lee  <walt@tilera.com>\n+\n+\t* configure.ac: Change \"tilepro\" triplet to \"tilepro*\".\n+\t* configure: Regenerate.\n+\n 2014-02-19  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR preprocessor/58844"}, {"sha": "b421e48fd9013e9dd0a56dd59f2626bb2d35f249", "filename": "libcpp/configure", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/341c653c704e398070219534cd9fed97e56661b3/libcpp%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/341c653c704e398070219534cd9fed97e56661b3/libcpp%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fconfigure?ref=341c653c704e398070219534cd9fed97e56661b3", "patch": "@@ -7168,7 +7168,7 @@ case $target in\n \tsparc*-*-* | \\\n \tspu-*-* | \\\n \tsh[123456789lbe]*-*-* | sh-*-* | \\\n-\ttilegx-*-* | tilepro-*-* )\n+\ttilegx*-*-* | tilepro*-*-* )\n \t\tneed_64bit_hwint=yes ;;\n \t*)\n \t\tneed_64bit_hwint=no ;;"}, {"sha": "8515abff2daf5d24ab9a6d67d13e1e658b599110", "filename": "libcpp/configure.ac", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/341c653c704e398070219534cd9fed97e56661b3/libcpp%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/341c653c704e398070219534cd9fed97e56661b3/libcpp%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fconfigure.ac?ref=341c653c704e398070219534cd9fed97e56661b3", "patch": "@@ -197,7 +197,7 @@ case $target in\n \tsparc*-*-* | \\\n \tspu-*-* | \\\n \tsh[123456789lbe]*-*-* | sh-*-* | \\\n-\ttilegx-*-* | tilepro-*-* )\n+\ttilegx*-*-* | tilepro*-*-* )\n \t\tneed_64bit_hwint=yes ;;\n \t*)\n \t\tneed_64bit_hwint=no ;;"}, {"sha": "167e7a90b3c6ea1975d27292f54ff0d0d14c4994", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/341c653c704e398070219534cd9fed97e56661b3/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/341c653c704e398070219534cd9fed97e56661b3/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=341c653c704e398070219534cd9fed97e56661b3", "patch": "@@ -1,3 +1,9 @@\n+2014-02-24  Walter Lee  <walt@tilera.com>\n+\n+\t* config.host: Support \"tilegx*\" and \"tilepro*\" triplets.\n+\t* config/tilegx/sfp-machine32.h (__BYTE_ORDER): Handle big endian.\n+\t* config/tilegx/sfp-machine64.h (__BYTE_ORDER): Handle big endian.\n+\n 2014-02-20  Sandra Loosemore  <sandra@codesourcery.com>\n \t    Chung-Lin Tang  <cltang@codesourcery.com>\n "}, {"sha": "185d40bf6766751258161245eb9ab6c8692445c9", "filename": "libgcc/config.host", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/341c653c704e398070219534cd9fed97e56661b3/libgcc%2Fconfig.host", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/341c653c704e398070219534cd9fed97e56661b3/libgcc%2Fconfig.host", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig.host?ref=341c653c704e398070219534cd9fed97e56661b3", "patch": "@@ -186,6 +186,12 @@ s390*-*-*)\n sh[123456789lbe]*-*-*)\n \tcpu_type=sh\n \t;;\n+tilegx*-*-*)\n+\tcpu_type=tilegx\n+\t;;\n+tilepro*-*-*)\n+\tcpu_type=tilepro\n+\t;;\n v850*-*-*)\n \tcpu_type=v850\n \t;;\n@@ -1177,11 +1183,11 @@ tic6x-*-elf)\n \textra_parts=\"$extra_parts crtbeginS.o crtendS.o crti.o crtn.o\"\n \tunwind_header=config/c6x/unwind-c6x.h\n \t;;\n-tilegx-*-linux*)\n+tilegx*-*-linux*)\n \ttmake_file=\"${tmake_file} tilegx/t-crtstuff t-softfp-sfdf tilegx/t-softfp t-softfp tilegx/t-tilegx\"\n \tmd_unwind_header=tilepro/linux-unwind.h\n         ;;\n-tilepro-*-linux*)\n+tilepro*-*-linux*)\n \ttmake_file=\"${tmake_file} tilepro/t-crtstuff t-softfp-sfdf t-softfp tilepro/t-tilepro\"\n \tmd_unwind_header=tilepro/linux-unwind.h\n         ;;"}, {"sha": "9fc281cc8ed91720c635c3f907f86f32aa19f9d3", "filename": "libgcc/config/tilegx/sfp-machine32.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/341c653c704e398070219534cd9fed97e56661b3/libgcc%2Fconfig%2Ftilegx%2Fsfp-machine32.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/341c653c704e398070219534cd9fed97e56661b3/libgcc%2Fconfig%2Ftilegx%2Fsfp-machine32.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Ftilegx%2Fsfp-machine32.h?ref=341c653c704e398070219534cd9fed97e56661b3", "patch": "@@ -55,7 +55,11 @@ typedef int __gcc_CMPtype __attribute__ ((mode (__libgcc_cmp_return__)));\n #define\t__LITTLE_ENDIAN\t1234\n #define\t__BIG_ENDIAN\t4321\n \n+#if defined __BIG_ENDIAN__\n+#define __BYTE_ORDER __BIG_ENDIAN\n+#else\n #define __BYTE_ORDER __LITTLE_ENDIAN\n+#endif\n \n /* Define ALIASNAME as a strong alias for NAME.  */\n # define strong_alias(name, aliasname) _strong_alias(name, aliasname)"}, {"sha": "5dbbe60c46b8014aae27fab465982ff9ad4470bc", "filename": "libgcc/config/tilegx/sfp-machine64.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/341c653c704e398070219534cd9fed97e56661b3/libgcc%2Fconfig%2Ftilegx%2Fsfp-machine64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/341c653c704e398070219534cd9fed97e56661b3/libgcc%2Fconfig%2Ftilegx%2Fsfp-machine64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Ftilegx%2Fsfp-machine64.h?ref=341c653c704e398070219534cd9fed97e56661b3", "patch": "@@ -55,7 +55,11 @@ typedef int __gcc_CMPtype __attribute__ ((mode (__libgcc_cmp_return__)));\n #define\t__LITTLE_ENDIAN\t1234\n #define\t__BIG_ENDIAN\t4321\n \n+#if defined __BIG_ENDIAN__\n+#define __BYTE_ORDER __BIG_ENDIAN\n+#else\n #define __BYTE_ORDER __LITTLE_ENDIAN\n+#endif\n \n /* Define ALIASNAME as a strong alias for NAME.  */\n # define strong_alias(name, aliasname) _strong_alias(name, aliasname)"}]}