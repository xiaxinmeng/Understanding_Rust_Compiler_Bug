{"sha": "d291dd49eebd5d36a0f52e37de12e24ea6c0f093", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDI5MWRkNDllZWJkNWQzNmEwZjUyZTM3ZGUxMmUyNGVhNmMwZjA5Mw==", "commit": {"author": {"name": "Jason Merrill", "email": "merrill@gnu.org", "date": "1996-10-09T01:52:26Z"}, "committer": {"name": "Jason Merrill", "email": "merrill@gnu.org", "date": "1996-10-09T01:52:26Z"}, "message": "DWARF2\n\nFrom-SVN: r12920", "tree": {"sha": "fc675e4aa6f4d32622ff44ff8b3a1c3aa963e31e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fc675e4aa6f4d32622ff44ff8b3a1c3aa963e31e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d291dd49eebd5d36a0f52e37de12e24ea6c0f093", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d291dd49eebd5d36a0f52e37de12e24ea6c0f093", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d291dd49eebd5d36a0f52e37de12e24ea6c0f093", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d291dd49eebd5d36a0f52e37de12e24ea6c0f093/comments", "author": null, "committer": null, "parents": [{"sha": "79c900b1c017b13543661428bbca31b7d9e44746", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79c900b1c017b13543661428bbca31b7d9e44746", "html_url": "https://github.com/Rust-GCC/gccrs/commit/79c900b1c017b13543661428bbca31b7d9e44746"}], "stats": {"total": 371, "additions": 257, "deletions": 114}, "files": [{"sha": "942828de85fb4ce1d7e91d56ae60fa79f9a64326", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 251, "deletions": 114, "changes": 365, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d291dd49eebd5d36a0f52e37de12e24ea6c0f093/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d291dd49eebd5d36a0f52e37de12e24ea6c0f093/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=d291dd49eebd5d36a0f52e37de12e24ea6c0f093", "patch": "@@ -110,6 +110,8 @@ typedef struct dw_loc_descr_struct *dw_loc_descr_ref;\n typedef struct dw_cfi_struct *dw_cfi_ref;\n typedef struct dw_fde_struct *dw_fde_ref;\n typedef union  dw_cfi_oprnd_struct *dw_cfi_oprnd_ref;\n+typedef struct pubname_struct *pubname_ref;\n+typedef dw_die_ref *arange_ref;\n \n /* Describe a double word constant value.  */\n typedef struct dw_double_const_struct\n@@ -237,6 +239,14 @@ typedef struct die_struct\n   }\n die_node;\n \n+/* The pubname structure */\n+typedef struct pubname_struct\n+{\n+  dw_die_ref die;\n+  char * name;\n+}\n+pubname_entry;\n+\n /* How to start an assembler comment.  */\n #ifndef ASM_COMMENT_START\n #define ASM_COMMENT_START \";#\"\n@@ -501,6 +511,34 @@ static unsigned fde_table_in_use;\n    fde_table.  */\n #define FDE_TABLE_INCREMENT 256\n \n+/* A pointer to the base of a table that contains a list of publicly\n+   accessible names.  */\n+static pubname_ref pubname_table;\n+\n+/* Number of elements currently allocated for pubname_table.  */\n+static unsigned pubname_table_allocated;\n+\n+/* Number of elements in pubname_table currently in use.  */\n+static unsigned pubname_table_in_use;\n+\n+/* Size (in elements) of increments by which we may expand the\n+   pubname_table.  */\n+#define PUBNAME_TABLE_INCREMENT 64\n+\n+/* A pointer to the base of a table that contains a list of publicly\n+   accessible names.  */\n+static arange_ref arange_table;\n+\n+/* Number of elements currently allocated for arange_table.  */\n+static unsigned arange_table_allocated;\n+\n+/* Number of elements in arange_table currently in use.  */\n+static unsigned arange_table_in_use;\n+\n+/* Size (in elements) of increments by which we may expand the\n+   arange_table.  */\n+#define ARANGE_TABLE_INCREMENT 64\n+\n /* The number of the current function definition for which debugging\n    information is being generated.  These numbers range from 1 up to the\n    maximum number of function definitions contained within the current\n@@ -718,6 +756,9 @@ static unsigned lookup_filename ();\n #ifndef BODY_END_LABEL_FMT\n #define BODY_END_LABEL_FMT\t\".L_b%u_e\"\n #endif\n+#ifndef FUNC_BEGIN_LABEL_FMT\n+#define FUNC_BEGIN_LABEL_FMT\t\".L_f%u\"\n+#endif\n #ifndef FUNC_END_LABEL_FMT\n #define FUNC_END_LABEL_FMT\t\".L_f%u_e\"\n #endif\n@@ -2121,29 +2162,70 @@ is_extern_subr_die (die)\n   return is_subr && is_extern;\n }\n \n-/* Return the \"low pc\" attribute value, typically associated with\n-   a subprogram DIE.  Return null if the \"low pc\" attribute is\n-   either not prsent, or if it cannot be represented as an\n-   assembler label identifier.  */\n-inline char *\n-get_AT_low_pc (die)\n+/* Get the attribute of type attr_kind.  */\n+inline dw_attr_ref\n+get_AT (die, attr_kind)\n      register dw_die_ref die;\n+     register enum dwarf_attribute attr_kind;\n {\n   register dw_attr_ref a;\n-  register char *low_pc = NULL;\n+  register dw_die_ref spec;\n+  \n   if (die != NULL)\n     {\n       for (a = die->die_attr; a != NULL; a = a->dw_attr_next)\n \t{\n-\t  if (a->dw_attr == DW_AT_low_pc\n-\t      && a->dw_attr_val.val_class == dw_val_class_lbl_id)\n-\t    {\n-\t      low_pc = a->dw_attr_val.v.val_lbl_id;\n-\t      break;\n-\t    }\n+\t  if (a->dw_attr == attr_kind)\n+\t    return a;\n+\t  if (a->dw_attr == DW_AT_specification\n+\t      || a->dw_attr == DW_AT_abstract_origin)\n+\t    spec = a->dw_attr_val.v.val_die_ref;\n \t}\n+      if (spec)\n+\treturn get_AT (spec, attr_kind);\n     }\n-  return low_pc;\n+  return NULL;\n+}\n+\n+/* Return the \"low pc\" attribute value, typically associated with\n+   a subprogram DIE.  Return null if the \"low pc\" attribute is\n+   either not prsent, or if it cannot be represented as an\n+   assembler label identifier.  */\n+inline char *\n+get_AT_low_pc (die)\n+     register dw_die_ref die;\n+{\n+  register dw_attr_ref a = get_AT (die, DW_AT_low_pc);\n+  if (a && a->dw_attr_val.val_class == dw_val_class_lbl_id)\n+    return a->dw_attr_val.v.val_lbl_id;\n+  return NULL;\n+}\n+\n+/* Return the \"high pc\" attribute value, typically associated with\n+   a subprogram DIE.  Return null if the \"high pc\" attribute is\n+   either not prsent, or if it cannot be represented as an\n+   assembler label identifier.  */\n+inline char *\n+get_AT_hi_pc (die)\n+     register dw_die_ref die;\n+{\n+  register dw_attr_ref a = get_AT (die, DW_AT_high_pc);\n+  if (a && a->dw_attr_val.val_class == dw_val_class_lbl_id)\n+    return a->dw_attr_val.v.val_lbl_id;\n+  return NULL;\n+}\n+\n+/* Return the value of the string attribute designated by ATTR_KIND, or\n+   NULL if it is not present.  */\n+inline char *\n+get_AT_string (die, attr_kind)\n+     register dw_die_ref die;\n+     register enum dwarf_attribute attr_kind;\n+{\n+  register dw_attr_ref a = get_AT (die, attr_kind);\n+  if (a && a->dw_attr_val.val_class == dw_val_class_str)\n+    return a->dw_attr_val.v.val_str;\n+  return NULL;\n }\n \n /* Return the value of the flag attribute designated by ATTR_KIND, or -1\n@@ -2153,16 +2235,9 @@ get_AT_flag (die, attr_kind)\n      register dw_die_ref die;\n      register enum dwarf_attribute attr_kind;\n {\n-  register dw_attr_ref a;\n-  if (die != NULL)\n-    {\n-      for (a = die->die_attr; a != NULL; a = a->dw_attr_next)\n-\t{\n-\t  if (a->dw_attr == attr_kind\n-\t      && a->dw_attr_val.val_class == dw_val_class_flag)\n-\t    return a->dw_attr_val.v.val_flag;\n-\t}\n-    }\n+  register dw_attr_ref a = get_AT (die, attr_kind);\n+  if (a && a->dw_attr_val.val_class == dw_val_class_flag)\n+    return a->dw_attr_val.v.val_flag;\n   return -1;\n }\n \n@@ -2173,44 +2248,12 @@ get_AT_unsigned (die, attr_kind)\n      register dw_die_ref die;\n      register enum dwarf_attribute attr_kind;\n {\n-  register dw_attr_ref a;\n-  if (die != NULL)\n-    {\n-      for (a = die->die_attr; a != NULL; a = a->dw_attr_next)\n-\t{\n-\t  if (a->dw_attr == attr_kind\n-\t      && a->dw_attr_val.val_class == dw_val_class_unsigned_const)\n-\t    return a->dw_attr_val.v.val_unsigned;\n-\t}\n-    }\n+  register dw_attr_ref a = get_AT (die, attr_kind);\n+  if (a && a->dw_attr_val.val_class == dw_val_class_unsigned_const)\n+    return a->dw_attr_val.v.val_unsigned;\n   return 0;\n }\n \n-/* Return the \"high pc\" attribute value, typically associated with\n-   a subprogram DIE.  Return null if the \"high pc\" attribute is\n-   either not prsent, or if it cannot be represented as an\n-   assembler label identifier.  */\n-inline char *\n-get_AT_hi_pc (die)\n-     register dw_die_ref die;\n-{\n-  register dw_attr_ref a;\n-  register char *hi_pc = NULL;\n-  if (die != NULL)\n-    {\n-      for (a = die->die_attr; a != NULL; a = a->dw_attr_next)\n-\t{\n-\t  if (a->dw_attr == DW_AT_high_pc\n-\t      && a->dw_attr_val.val_class == dw_val_class_lbl_id)\n-\t    {\n-\t      hi_pc = a->dw_attr_val.v.val_lbl_id;\n-\t      break;\n-\t    }\n-\t}\n-    }\n-  return hi_pc;\n-}\n-\n /* Remove the specified attribute if present.  */\n inline void\n remove_AT (die, attr_kind)\n@@ -3097,20 +3140,14 @@ size_of_line_info ()\n static unsigned long\n size_of_pubnames ()\n {\n-  dw_die_ref die;\n   register unsigned long size;\n+  register unsigned i;\n+\n   size = DWARF_PUBNAMES_HEADER_SIZE;\n-  for (die = comp_unit_die->die_child; die != NULL; die = die->die_sib)\n+  for (i = 0; i < pubname_table_in_use; ++i)\n     {\n-      if (is_extern_subr_die (die))\n-\t{\n-\t  char *low_pc = get_AT_low_pc (die);\n-\t  if (low_pc != NULL)\n-\t    {\n-\t      size += 4;\n-\t      size += size_of_string (low_pc);\n-\t    }\n-\t}\n+      register pubname_ref p = &pubname_table[i];\n+      size += 4 + size_of_string (p->name);\n     }\n   size += 4;\n   return size;\n@@ -3124,6 +3161,7 @@ size_of_aranges ()\n   size = DWARF_ARANGES_HEADER_SIZE;\n   /* Count the address/length pair for this compilation unit.  */\n   size += 8;\n+  size += 8 * arange_table_in_use;\n   /* Count the two zero words used to terminated the address range table.  */\n   size += 8;\n   return size;\n@@ -3945,15 +3983,39 @@ output_call_frame_info ()\n     }\n }\n \n+/* Add a new entry to .debug_pubnames if appropriate.  */\n+static void\n+add_pubname (decl, die)\n+     tree decl;\n+     dw_die_ref die;\n+{\n+  pubname_ref p;\n+\n+  if (! TREE_PUBLIC (decl))\n+    return;\n+\n+  if (pubname_table_in_use == pubname_table_allocated)\n+    {\n+      pubname_table_allocated += PUBNAME_TABLE_INCREMENT;\n+      pubname_table = (pubname_ref) xrealloc\n+\t(pubname_table, pubname_table_allocated * sizeof (pubname_entry));\n+    }\n+  p = &pubname_table[pubname_table_in_use++];\n+  p->die = die;\n+  p->name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));\n+}\n+\n /* Output the public names table used to speed up access to externally\n    visible names.  For now, only generate entries for externally\n    visible procedures.  */\n static void\n output_pubnames ()\n {\n-  dw_die_ref die;\n-  register unsigned long pubnames_length = size_of_pubnames ();\n-  ASM_OUTPUT_DWARF_DATA4 (asm_out_file, pubnames_length);\n+  register unsigned i;\n+  {\n+    register unsigned long pubnames_length = size_of_pubnames ();\n+    ASM_OUTPUT_DWARF_DATA4 (asm_out_file, pubnames_length);\n+  }\n   if (flag_verbose_asm)\n     {\n       fprintf (asm_out_file, \"\\t%s Length of Public Names Info.\",\n@@ -3981,43 +4043,58 @@ output_pubnames ()\n \t       ASM_COMMENT_START);\n     }\n   fputc ('\\n', asm_out_file);\n-  for (die = comp_unit_die->die_child; die != NULL; die = die->die_sib)\n+  for (i = 0; i < pubname_table_in_use; ++i)\n     {\n-      if (is_extern_subr_die (die))\n+      register pubname_ref pub = &pubname_table[i];\n+      ASM_OUTPUT_DWARF_DATA4 (asm_out_file, pub->die->die_offset);\n+      if (flag_verbose_asm)\n \t{\n-\t  char *low_pc = get_AT_low_pc (die);\n-\t  if (low_pc != NULL)\n-\t    {\n-\t      ASM_OUTPUT_DWARF_DATA4 (asm_out_file, die->die_offset);\n-\t      if (flag_verbose_asm)\n-\t\t{\n-\t\t  fprintf (asm_out_file, \"\\t%s DIE offset\",\n-\t\t\t   ASM_COMMENT_START);\n-\t\t}\n-\t      fputc ('\\n', asm_out_file);\n-\t      ASM_OUTPUT_DWARF_STRING (asm_out_file, low_pc);\n-\t      if (flag_verbose_asm)\n-\t\t{\n-\t\t  fprintf (asm_out_file, \"%s external name\",\n-\t\t\t   ASM_COMMENT_START);\n-\t\t}\n-\t      fputc ('\\n', asm_out_file);\n-\t    }\n+\t  fprintf (asm_out_file, \"\\t%s DIE offset\",\n+\t\t   ASM_COMMENT_START);\n \t}\n+      fputc ('\\n', asm_out_file);\n+\n+      ASM_OUTPUT_DWARF_STRING (asm_out_file, pub->name);\n+      if (flag_verbose_asm)\n+\t{\n+\t  fprintf (asm_out_file, \"%s external name\",\n+\t\t   ASM_COMMENT_START);\n+\t}\n+      fputc ('\\n', asm_out_file);\n     }\n   ASM_OUTPUT_DWARF_DATA4 (asm_out_file, 0);\n   fputc ('\\n', asm_out_file);\n }\n \n+/* Add a new entry to .debug_aranges if appropriate.  */\n+static void\n+add_arange (decl, die)\n+     tree decl;\n+     dw_die_ref die;\n+{\n+  if (! DECL_SECTION_NAME (decl))\n+    return;\n+\n+  if (arange_table_in_use == arange_table_allocated)\n+    {\n+      arange_table_allocated += ARANGE_TABLE_INCREMENT;\n+      arange_table = (arange_ref) xrealloc\n+\t(arange_table, arange_table_allocated * sizeof (dw_die_ref));\n+    }\n+  arange_table[arange_table_in_use++] = die;\n+}\n+\n /* Output the information that goes into the .debug_aranges table.\n    Namely, define the beginning and ending address range of the\n    text section generated for this compilation unit.  */\n static void\n output_aranges ()\n {\n-  dw_die_ref die;\n-  register unsigned long aranges_length = size_of_aranges ();\n-  ASM_OUTPUT_DWARF_DATA4 (asm_out_file, aranges_length);\n+  register unsigned i;\n+  {\n+    register unsigned long aranges_length = size_of_aranges ();\n+    ASM_OUTPUT_DWARF_DATA4 (asm_out_file, aranges_length);\n+  }\n   if (flag_verbose_asm)\n     {\n       fprintf (asm_out_file, \"\\t%s Length of Address Ranges Info.\",\n@@ -4071,6 +4148,30 @@ output_aranges ()\n       fprintf (asm_out_file, \"%s Length\", ASM_COMMENT_START);\n     }\n   fputc ('\\n', asm_out_file);\n+  for (i = 0; i < arange_table_in_use; ++i)\n+    {\n+      dw_die_ref a = arange_table[i];\n+      if (a->die_tag == DW_TAG_subprogram)\n+\tASM_OUTPUT_DWARF_ADDR (asm_out_file, get_AT_low_pc (a));\n+      else\n+\tASM_OUTPUT_DWARF_ADDR (asm_out_file, get_AT_string (a, DW_AT_name));\n+      if (flag_verbose_asm)\n+\t{\n+\t  fprintf (asm_out_file, \"\\t%s Address\", ASM_COMMENT_START);\n+\t}\n+      fputc ('\\n', asm_out_file);\n+      if (a->die_tag == DW_TAG_subprogram)\n+\tASM_OUTPUT_DWARF_DELTA4 (asm_out_file, get_AT_hi_pc (a),\n+\t\t\t\t get_AT_low_pc (a));\n+      else\n+\tASM_OUTPUT_DWARF_DATA4 (asm_out_file,\n+\t\t\t\tget_AT_unsigned (a, DW_AT_byte_size));\n+      if (flag_verbose_asm)\n+\t{\n+\t  fprintf (asm_out_file, \"%s Length\", ASM_COMMENT_START);\n+\t}\n+      fputc ('\\n', asm_out_file);\n+    }\n   /* Output the terminator words.  */\n   ASM_OUTPUT_DWARF_DATA4 (asm_out_file, 0);\n   fputc ('\\n', asm_out_file);\n@@ -5804,7 +5905,7 @@ add_name_and_src_coords_attributes (die, decl)\n      register dw_die_ref die;\n      register tree decl;\n {\n-  register tree decl_name = DECL_NAME (decl);\n+  register tree decl_name = DECL_ASSEMBLER_NAME (decl);\n   register unsigned file_index;\n   if (decl_name && IDENTIFIER_POINTER (decl_name))\n     {\n@@ -5955,10 +6056,10 @@ member_declared_type (member)\n     : TREE_TYPE (member);\n }\n \n-/* Get the function's label, as described by its RTL. This may be different\n+/* Get the decl's label, as described by its RTL. This may be different\n    from the DECL_NAME name used in the source file.  */\n static char *\n-function_start_label (decl)\n+decl_start_label (decl)\n      register tree decl;\n {\n   rtx x;\n@@ -6064,7 +6165,7 @@ gen_entry_point_die (decl, context_die)\n     }\n   else\n     {\n-      add_AT_lbl_id (decl_die, DW_AT_low_pc, function_start_label (decl));\n+      add_AT_lbl_id (decl_die, DW_AT_low_pc, decl_start_label (decl));\n     }\n }\n \n@@ -6381,10 +6482,20 @@ gen_subprogram_die (decl, context_die)\n     {\n       if (origin == NULL)\n \tequate_decl_number_to_die (decl, subr_die);\n-      add_AT_lbl_id (subr_die, DW_AT_low_pc, function_start_label (decl));\n+      if (DECL_WEAK (current_function_decl)\n+\t  || DECL_ONE_ONLY (current_function_decl))\n+\t{\n+\t  sprintf (label_id, FUNC_BEGIN_LABEL_FMT, current_funcdef_number);\n+\t  add_AT_lbl_id (subr_die, DW_AT_low_pc, label_id);\n+\t}\n+      else\n+\tadd_AT_lbl_id (subr_die, DW_AT_low_pc, decl_start_label (decl));\n       sprintf (label_id, FUNC_END_LABEL_FMT, current_funcdef_number);\n       add_AT_lbl_id (subr_die, DW_AT_high_pc, label_id);\n \n+      add_pubname (decl, subr_die);\n+      add_arange (decl, subr_die);\n+\n #ifdef MIPS_DEBUGGING_INFO\n \n       /* Add a reference to the FDE for this routine.  */\n@@ -6546,6 +6657,7 @@ gen_variable_die (decl, context_die)\n     {\n       equate_decl_number_to_die (decl, var_die);\n       add_location_or_const_value_attribute (var_die, decl);\n+      add_pubname (decl, var_die);\n     }\n   else if (decl_class_context (decl))\n     {\n@@ -7558,19 +7670,17 @@ dwarfout_label (insn)\n     }\n }\n \n-/* Output a marker (i.e. a label) for the point in the generated code where\n-   the real body of the function begins (after parameters have been moved to\n-   their home locations).  */\n+/* Output a marker (i.e. a label) for the beginning of a function, before\n+   the prologue.  */\n void\n-dwarfout_begin_function ()\n+dwarfout_begin_prologue ()\n {\n   char label[MAX_ARTIFICIAL_LABEL_BYTES];\n-  register long int offset;\n   register dw_fde_ref fde;\n   register dw_cfi_ref cfi;\n \n   function_section (current_function_decl);\n-  sprintf (label, BODY_BEGIN_LABEL_FMT, current_funcdef_number);\n+  sprintf (label, FUNC_BEGIN_LABEL_FMT, current_funcdef_number);\n   ASM_OUTPUT_LABEL (asm_out_file, label);\n \n   /* Expand the fde table if necessary.  */\n@@ -7586,11 +7696,35 @@ dwarfout_begin_function ()\n \n   /* Add the new FDE at the end of the fde_table.  */\n   fde = &fde_table[fde_table_in_use++];\n-  fde->dw_fde_begin = xstrdup (function_start_label (current_function_decl));\n-  fde->dw_fde_end_prolog = xstrdup (label);\n+  if (DECL_WEAK (current_function_decl)\n+      || DECL_ONE_ONLY (current_function_decl))\n+    fde->dw_fde_begin = xstrdup (label);\n+  else\n+    fde->dw_fde_begin = xstrdup (decl_start_label (current_function_decl));\n+  fde->dw_fde_end_prolog = NULL;\n   fde->dw_fde_begin_epilogue = NULL;\n   fde->dw_fde_end = NULL;\n   fde->dw_fde_cfi = NULL;\n+}\n+\n+/* Output a marker (i.e. a label) for the point in the generated code where\n+   the real body of the function begins (after parameters have been moved to\n+   their home locations).  */\n+void\n+dwarfout_begin_function ()\n+{\n+  char label[MAX_ARTIFICIAL_LABEL_BYTES];\n+  register long int offset;\n+  register dw_fde_ref fde;\n+  register dw_cfi_ref cfi;\n+\n+  function_section (current_function_decl);\n+  sprintf (label, BODY_BEGIN_LABEL_FMT, current_funcdef_number);\n+  ASM_OUTPUT_LABEL (asm_out_file, label);\n+\n+  /* Record the end-of-prolog location in the FDE.  */\n+  fde = &fde_table[fde_table_in_use - 1];\n+  fde->dw_fde_end_prolog = xstrdup (label);\n \n #ifdef MIPS_DEBUGGING_INFO\n \n@@ -8020,18 +8154,21 @@ dwarfout_finish ()\n   output_compilation_unit_header ();\n   output_die (comp_unit_die);\n \n+  if (pubname_table_in_use)\n+    {\n+      /* Output public names table.  */\n+      fputc ('\\n', asm_out_file);\n+      ASM_OUTPUT_SECTION (asm_out_file, PUBNAMES_SECTION);\n+      output_pubnames ();\n+    }\n+\n   if (fde_table_in_use)\n     {\n       /* Output call frame information.  */\n       fputc ('\\n', asm_out_file);\n       ASM_OUTPUT_SECTION (asm_out_file, FRAME_SECTION);\n       output_call_frame_info ();\n \n-      /* Output public names table.  */\n-      fputc ('\\n', asm_out_file);\n-      ASM_OUTPUT_SECTION (asm_out_file, PUBNAMES_SECTION);\n-      output_pubnames ();\n-\n       /* Output the address range information.  */\n       fputc ('\\n', asm_out_file);\n       ASM_OUTPUT_SECTION (asm_out_file, ARANGES_SECTION);"}, {"sha": "54eb26b1ba62ad87850c604a99c56a52a80de300", "filename": "gcc/final.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d291dd49eebd5d36a0f52e37de12e24ea6c0f093/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d291dd49eebd5d36a0f52e37de12e24ea6c0f093/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=d291dd49eebd5d36a0f52e37de12e24ea6c0f093", "patch": "@@ -895,6 +895,12 @@ final_start_function (first, file, optimize)\n     last_linenum = high_block_linenum = high_function_linenum\n       = NOTE_LINE_NUMBER (first);\n \n+#if defined (DWARF_DEBUGGING_INFO) && DWARF_VERSION == 2\n+  /* Output DWARF definition of the function.  */\n+  if (write_symbols == DWARF_DEBUG)\n+    dwarfout_begin_prologue ();\n+#endif\n+\n   /* For SDB and XCOFF, the function beginning must be marked between\n      the function label and the prologue.  We always need this, even when\n      -g1 was used.  Defer on MIPS systems so that parameter descriptions"}]}