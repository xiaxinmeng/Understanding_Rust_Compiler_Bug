{"sha": "265d5e86f26d6dff9a795dace55243ac7de12134", "node_id": "C_kwDOANBUbNoAKDI2NWQ1ZTg2ZjI2ZDZkZmY5YTc5NWRhY2U1NTI0M2FjN2RlMTIxMzQ", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-07-18T15:23:07Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-07-18T15:23:07Z"}, "message": "Merge #1358\n\n1358: Disambiguate generic args r=CohenArthur a=CohenArthur\n\nNeeds #1355. Only review the last commit.  The next steps are to typecheck const generics and then lower them to TREE\r\n\r\nThis removes all the hacks previously introduced to resolve ambiguous\r\ngeneric args as types, and adds proper disambiguation.\r\n\r\nThe algorithm is as follows:\r\n\r\nis that name referring to a type?\r\n-> disambiguate to a type\r\nis that name referring to a value?\r\n-> disambiguate to a const value\r\nelse\r\n-> disambiguate to type\r\n\r\nSince types are the default expected behavior, this allows us to report\r\ntype errors properly during typechecking.\r\n\r\n\r\n\n\nCo-authored-by: Arthur Cohen <arthur.cohen@embecosm.com>", "tree": {"sha": "fc9fb4feb468bbbbca8265420e2b2f67ef1fe5be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fc9fb4feb468bbbbca8265420e2b2f67ef1fe5be"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/265d5e86f26d6dff9a795dace55243ac7de12134", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJi1XrbCRBK7hj4Ov3rIwAAvnUIAIuXRUw1lo+D4wDGJi02sy6d\no8Au4WdG1kKIhz9pVxkCTxMT5lpV5IczPOA6kON8f3ndiy591GnMmnSE7bhw8hrc\n6yOOMmpoLhkA5Ev9GsOYY3KKwU6bUVssayU61h+qjZSLjvzor7dBqumqdXOzwRPW\nPvp/0NTVZX2o4FID57APyEAYP3tTubKYBpChUjpS3RPXrEv8RUWEOkrpHM+FTdaa\n6cmLPBO2HDFfYf4lkWYmctz7/KiD9QVr1a0vhs8vZ8sHl2MZ21M0bbDV38K3qfTN\nUtmMlA5R4WLUzLyFAhtglIz0liTPhwQalnAhff76+bjRKI5knNGzYnaB6nGezyg=\n=owDh\n-----END PGP SIGNATURE-----\n", "payload": "tree fc9fb4feb468bbbbca8265420e2b2f67ef1fe5be\nparent 6920d2294b3c6f106478fd3decaa511faf3cac84\nparent d82201be88ce09c92db709573171c869d94b55fd\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1658157787 +0000\ncommitter GitHub <noreply@github.com> 1658157787 +0000\n\nMerge #1358\n\n1358: Disambiguate generic args r=CohenArthur a=CohenArthur\n\nNeeds #1355. Only review the last commit.  The next steps are to typecheck const generics and then lower them to TREE\r\n\r\nThis removes all the hacks previously introduced to resolve ambiguous\r\ngeneric args as types, and adds proper disambiguation.\r\n\r\nThe algorithm is as follows:\r\n\r\nis that name referring to a type?\r\n-> disambiguate to a type\r\nis that name referring to a value?\r\n-> disambiguate to a const value\r\nelse\r\n-> disambiguate to type\r\n\r\nSince types are the default expected behavior, this allows us to report\r\ntype errors properly during typechecking.\r\n\r\n\r\n\n\nCo-authored-by: Arthur Cohen <arthur.cohen@embecosm.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/265d5e86f26d6dff9a795dace55243ac7de12134", "html_url": "https://github.com/Rust-GCC/gccrs/commit/265d5e86f26d6dff9a795dace55243ac7de12134", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/265d5e86f26d6dff9a795dace55243ac7de12134/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6920d2294b3c6f106478fd3decaa511faf3cac84", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6920d2294b3c6f106478fd3decaa511faf3cac84", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6920d2294b3c6f106478fd3decaa511faf3cac84"}, {"sha": "d82201be88ce09c92db709573171c869d94b55fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d82201be88ce09c92db709573171c869d94b55fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d82201be88ce09c92db709573171c869d94b55fd"}], "stats": {"total": 191, "additions": 140, "deletions": 51}, "files": [{"sha": "9332bb6ebfcbfcdfd27afdc0110ce957a7ac7a17", "filename": "gcc/rust/expand/rust-attribute-visitor.cc", "status": "modified", "additions": 28, "deletions": 13, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/265d5e86f26d6dff9a795dace55243ac7de12134/gcc%2Frust%2Fexpand%2Frust-attribute-visitor.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/265d5e86f26d6dff9a795dace55243ac7de12134/gcc%2Frust%2Fexpand%2Frust-attribute-visitor.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-attribute-visitor.cc?ref=265d5e86f26d6dff9a795dace55243ac7de12134", "patch": "@@ -134,20 +134,35 @@ AttrVisitor::expand_generic_args (AST::GenericArgs &args)\n   // expand type args - strip sub-types only\n   for (auto &arg : args.get_generic_args ())\n     {\n-      // FIXME: Arthur: Another ugly hack while waiting for disambiguation\n-      if (arg.get_kind () == AST::GenericArg::Kind::Either)\n-\targ = arg.disambiguate_to_type ();\n-\n-      if (arg.get_kind () == AST::GenericArg::Kind::Type)\n+      switch (arg.get_kind ())\n \t{\n-\t  auto &type = arg.get_type ();\n-\n-\t  type->accept_vis (*this);\n-\t  maybe_expand_type (type);\n-\n-\t  if (type->is_marked_for_strip ())\n-\t    rust_error_at (type->get_locus (),\n-\t\t\t   \"cannot strip type in this position\");\n+\t  case AST::GenericArg::Kind::Type: {\n+\t    auto &type = arg.get_type ();\n+\t    type->accept_vis (*this);\n+\t    maybe_expand_type (type);\n+\n+\t    if (type->is_marked_for_strip ())\n+\t      rust_error_at (type->get_locus (),\n+\t\t\t     \"cannot strip type in this position\");\n+\t    break;\n+\t  }\n+\t  case AST::GenericArg::Kind::Const: {\n+\t    auto &expr = arg.get_expression ();\n+\t    expr->accept_vis (*this);\n+\t    maybe_expand_expr (expr);\n+\n+\t    if (expr->is_marked_for_strip ())\n+\t      rust_error_at (expr->get_locus (),\n+\t\t\t     \"cannot strip expression in this position\");\n+\t    break;\n+\t  }\n+\tdefault:\n+\t  break;\n+\t  // FIXME: Figure out what to do here if there is ambiguity. Since the\n+\t  // resolver comes after the expansion, we need to figure out a way to\n+\t  // strip ambiguous values here\n+\t  // TODO: Arthur: Probably add a `mark_as_strip` method to `GenericArg`\n+\t  // or something. This would clean up this whole thing\n \t}\n     }\n "}, {"sha": "e31b95b07bda24294ef5356ad180e250475edb45", "filename": "gcc/rust/hir/rust-ast-lower-base.cc", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/265d5e86f26d6dff9a795dace55243ac7de12134/gcc%2Frust%2Fhir%2Frust-ast-lower-base.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/265d5e86f26d6dff9a795dace55243ac7de12134/gcc%2Frust%2Fhir%2Frust-ast-lower-base.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-base.cc?ref=265d5e86f26d6dff9a795dace55243ac7de12134", "patch": "@@ -623,13 +623,6 @@ ASTLoweringBase::lower_generic_args (AST::GenericArgs &args)\n \t\t\t\t    expr->get_locus ()));\n \t    break;\n \t  }\n-\t  // FIXME: Arthur: Other horrible hack waiting for disambiguation\n-\t  case AST::GenericArg::Kind::Either: {\n-\t    arg = arg.disambiguate_to_type ();\n-\t    auto type = ASTLoweringType::translate (arg.get_type ().get ());\n-\t    type_args.emplace_back (std::unique_ptr<HIR::Type> (type));\n-\t    break;\n-\t  }\n \tdefault:\n \t  gcc_unreachable ();\n \t}"}, {"sha": "46f765a3ea2cef7d02f10c73fdec5fbad6b77909", "filename": "gcc/rust/hir/rust-ast-lower-type.h", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/265d5e86f26d6dff9a795dace55243ac7de12134/gcc%2Frust%2Fhir%2Frust-ast-lower-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/265d5e86f26d6dff9a795dace55243ac7de12134/gcc%2Frust%2Fhir%2Frust-ast-lower-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-type.h?ref=265d5e86f26d6dff9a795dace55243ac7de12134", "patch": "@@ -356,12 +356,9 @@ class ASTLowerGenericParam : public ASTLoweringBase\n \t\t\t\t   mappings->get_next_localdef_id (crate_num));\n \n     auto type = ASTLoweringType::translate (param.get_type ().get ());\n-    // FIXME: Arthur: Remove the second guard once we disambiguate in the\n-    // resolveer\n+\n     HIR::Expr *default_expr = nullptr;\n-    if (param.has_default_value ()\n-\t&& param.get_default_value ().get_kind ()\n-\t     == AST::GenericArg::Kind::Const)\n+    if (param.has_default_value ())\n       default_expr = ASTLoweringExpr::translate (\n \tparam.get_default_value ().get_expression ().get ());\n "}, {"sha": "4cc4e26e3e94bbff6496b96834f35a70830e089a", "filename": "gcc/rust/resolve/rust-ast-resolve-expr.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/265d5e86f26d6dff9a795dace55243ac7de12134/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/265d5e86f26d6dff9a795dace55243ac7de12134/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.cc?ref=265d5e86f26d6dff9a795dace55243ac7de12134", "patch": "@@ -87,7 +87,7 @@ ResolveExpr::visit (AST::MethodCallExpr &expr)\n   if (expr.get_method_name ().has_generic_args ())\n     {\n       AST::GenericArgs &args = expr.get_method_name ().get_generic_args ();\n-      ResolveGenericArgs::go (args);\n+      ResolveGenericArgs::go (args, prefix, canonical_prefix);\n     }\n \n   auto const &in_params = expr.get_params ();"}, {"sha": "a8931ce72c2f60998b72381ac0becca52f266aab", "filename": "gcc/rust/resolve/rust-ast-resolve-type.cc", "status": "modified", "additions": 73, "deletions": 25, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/265d5e86f26d6dff9a795dace55243ac7de12134/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/265d5e86f26d6dff9a795dace55243ac7de12134/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.cc?ref=265d5e86f26d6dff9a795dace55243ac7de12134", "patch": "@@ -384,32 +384,21 @@ ResolveTypeToCanonicalPath::visit (AST::TypePath &path)\n \t    std::vector<CanonicalPath> args;\n \t    if (s->has_generic_args ())\n \t      {\n+\t\tResolveGenericArgs::go (s->get_generic_args ());\n \t\tfor (auto &generic : s->get_generic_args ().get_generic_args ())\n \t\t  {\n \t\t    // FIXME: What do we want to do here in case there is a\n \t\t    // constant or an ambiguous const generic?\n \t\t    // TODO: At that point, will all generics have been\n \t\t    // disambiguated? Can we thus canonical resolve types and\n \t\t    // const and `gcc_unreachable` on ambiguous types?\n-\t\t    //\n-\t\t    // FIXME: Arthur: This is an ugly hack to resolve just as\n-\t\t    // much as before despite not handling ambiguity yet. The\n-\t\t    // calls to `clone_type` will be removed.\n-\t\t    std::unique_ptr<AST::Type> gt = nullptr;\n-\n+\t\t    // This is probably fine as we just want to canonicalize\n+\t\t    // types, right?\n \t\t    if (generic.get_kind () == AST::GenericArg::Kind::Type)\n-\t\t      gt = generic.get_type ()->clone_type ();\n-\t\t    else if (generic.get_kind ()\n-\t\t\t     == AST::GenericArg::Kind::Either)\n-\t\t      gt = generic.disambiguate_to_type ()\n-\t\t\t     .get_type ()\n-\t\t\t     ->clone_type ();\n-\n-\t\t    if (gt)\n \t\t      {\n \t\t\tCanonicalPath arg = CanonicalPath::create_empty ();\n-\t\t\tbool ok\n-\t\t\t  = ResolveTypeToCanonicalPath::go (gt.get (), arg);\n+\t\t\tbool ok = ResolveTypeToCanonicalPath::go (\n+\t\t\t  generic.get_type ().get (), arg);\n \t\t\tif (ok)\n \t\t\t  args.push_back (std::move (arg));\n \t\t      }\n@@ -492,20 +481,79 @@ ResolveTypeToCanonicalPath::ResolveTypeToCanonicalPath ()\n   : ResolverBase (), result (CanonicalPath::create_empty ())\n {}\n \n+bool\n+ResolveGenericArgs::is_const_value_name (const CanonicalPath &path)\n+{\n+  NodeId resolved;\n+  auto found = resolver->get_name_scope ().lookup (path, &resolved);\n+\n+  return found;\n+}\n+\n+bool\n+ResolveGenericArgs::is_type_name (const CanonicalPath &path)\n+{\n+  NodeId resolved;\n+  auto found = resolver->get_type_scope ().lookup (path, &resolved);\n+\n+  return found;\n+}\n+\n void\n-ResolveGenericArgs::go (AST::GenericArgs &args)\n+ResolveGenericArgs::disambiguate (AST::GenericArg &arg)\n {\n-  for (auto &arg : args.get_generic_args ())\n+  auto path = canonical_prefix.append (\n+    CanonicalPath::new_seg (UNKNOWN_NODEID, arg.get_path ()));\n+\n+  auto is_type = is_type_name (path);\n+  auto is_value = is_const_value_name (path);\n+\n+  // In case we cannot find anything, we resolve the ambiguity to a type.\n+  // This causes the typechecker to error out properly and when necessary.\n+  // But types also take priority over const values in the case of\n+  // ambiguities, hence the weird control flow\n+  if (is_type || (!is_type && !is_value))\n+    arg = arg.disambiguate_to_type ();\n+  else if (is_value)\n+    arg = arg.disambiguate_to_const ();\n+}\n+\n+void\n+ResolveGenericArgs::resolve_disambiguated_generic (AST::GenericArg &arg)\n+{\n+  switch (arg.get_kind ())\n     {\n-      // FIXME: Arthur: Ugly hack while waiting for disambiguation\n-      if (arg.get_kind () == AST::GenericArg::Kind::Either)\n-\targ = arg.disambiguate_to_type ();\n+    case AST::GenericArg::Kind::Const:\n+      ResolveExpr::go (arg.get_expression ().get (), prefix, canonical_prefix);\n+      break;\n+    case AST::GenericArg::Kind::Type:\n+      ResolveType::go (arg.get_type ().get ());\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+void\n+ResolveGenericArgs::go (AST::GenericArgs &generic_args)\n+{\n+  auto empty = CanonicalPath::create_empty ();\n \n-      if (arg.get_kind () == AST::GenericArg::Kind::Type)\n-\tResolveType::go (arg.get_type ().get ());\n+  go (generic_args, empty, empty);\n+}\n+\n+void\n+ResolveGenericArgs::go (AST::GenericArgs &generic_args,\n+\t\t\tconst CanonicalPath &prefix,\n+\t\t\tconst CanonicalPath &canonical_prefix)\n+{\n+  auto resolver = ResolveGenericArgs (prefix, canonical_prefix);\n+\n+  for (auto &arg : generic_args.get_generic_args ())\n+    {\n+      if (arg.get_kind () == AST::GenericArg::Kind::Either)\n+\tresolver.disambiguate (arg);\n \n-      // else...\n-      // We need to use a switch instead\n+      resolver.resolve_disambiguated_generic (arg);\n     }\n }\n "}, {"sha": "b57b51386569c8a492c2c00c6d15e1092e34c1d4", "filename": "gcc/rust/resolve/rust-ast-resolve-type.h", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/265d5e86f26d6dff9a795dace55243ac7de12134/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/265d5e86f26d6dff9a795dace55243ac7de12134/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h?ref=265d5e86f26d6dff9a795dace55243ac7de12134", "patch": "@@ -254,6 +254,30 @@ class ResolveGenericArgs : public ResolverBase\n \n public:\n   static void go (AST::GenericArgs &generic_args);\n+  static void go (AST::GenericArgs &generic_args, const CanonicalPath &prefix,\n+\t\t  const CanonicalPath &canonical_prefix);\n+\n+private:\n+  ResolveGenericArgs (const CanonicalPath &prefix,\n+\t\t      const CanonicalPath &canonical_prefix)\n+    : ResolverBase (), prefix (prefix), canonical_prefix (canonical_prefix)\n+  {}\n+\n+  bool is_type_name (const CanonicalPath &path);\n+  bool is_const_value_name (const CanonicalPath &path);\n+\n+  /**\n+   * Resolve a disambiguated generic arg\n+   */\n+  void disambiguate (AST::GenericArg &arg);\n+\n+  /**\n+   * Resolve a disambiguated generic arg\n+   */\n+  void resolve_disambiguated_generic (AST::GenericArg &arg);\n+\n+  const CanonicalPath &prefix;\n+  const CanonicalPath &canonical_prefix;\n };\n \n } // namespace Resolver"}, {"sha": "5344e31a140499aff5de49c2c0a2f3096fcbc8d1", "filename": "gcc/testsuite/rust/compile/const_generics_5.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/265d5e86f26d6dff9a795dace55243ac7de12134/gcc%2Ftestsuite%2Frust%2Fcompile%2Fconst_generics_5.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/265d5e86f26d6dff9a795dace55243ac7de12134/gcc%2Ftestsuite%2Frust%2Fcompile%2Fconst_generics_5.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fconst_generics_5.rs?ref=265d5e86f26d6dff9a795dace55243ac7de12134", "patch": "@@ -0,0 +1,12 @@\n+struct Foo<const N: usize = { 14 }>;\n+\n+const M: usize = 15;\n+type N = Foo<3>;\n+\n+fn main() {\n+    let _: Foo<15> = Foo;\n+    let _: Foo<{ M }> = Foo;\n+    let _: Foo<M> = Foo;\n+    // bogus error, but it means the above const generic gets disambiguated properly\n+    let _: Foo<N> = Foo; // { dg-error \"TypePath Foo<N> declares generic arguments but the type Foo{Foo {}} does not have any\" }\n+}"}]}