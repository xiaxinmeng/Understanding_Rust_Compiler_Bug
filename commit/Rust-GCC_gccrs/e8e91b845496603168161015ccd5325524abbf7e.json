{"sha": "e8e91b845496603168161015ccd5325524abbf7e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZThlOTFiODQ1NDk2NjAzMTY4MTYxMDE1Y2NkNTMyNTUyNGFiYmY3ZQ==", "commit": {"author": {"name": "Cherry Zhang", "email": "cherryyz@google.com", "date": "2019-05-16T04:35:15Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2019-05-16T04:35:15Z"}, "message": "compiler: improve escape analysis on interface conversions\n    \n    If an interface does not escape, it doesn't need a heap\n    allocation to hold the data (for non-direct interface type).\n    This CL improves the escape analysis to track interface\n    conversions, and reduces these allocations.\n    \n    Implicit interface conversions were mostly added late in the\n    compilation pipeline, after the escape analysis. For the escape\n    analysis to see them, we move the introduction of these\n    conversions earlier, right before the escape analysis.\n    \n    Now that the compiler can generate interface conversions inlined,\n    gcc/testsuite/go.test/test/nilptr2.go needs to be adjusted as in\n    golang.org/cl/176579, so the use function does an actual use.\n    \n    Reviewed-on: https://go-review.googlesource.com/c/gofrontend/+/176459\n\n\t* go.test/test/nilptr2.go: Change use function to actually do\n\tsomething.\n\nFrom-SVN: r271276", "tree": {"sha": "042ec42badf35137c4249ed7ab62797a8a50cf48", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/042ec42badf35137c4249ed7ab62797a8a50cf48"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e8e91b845496603168161015ccd5325524abbf7e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8e91b845496603168161015ccd5325524abbf7e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e8e91b845496603168161015ccd5325524abbf7e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8e91b845496603168161015ccd5325524abbf7e/comments", "author": {"login": "cherrymui", "id": 14119929, "node_id": "MDQ6VXNlcjE0MTE5OTI5", "avatar_url": "https://avatars.githubusercontent.com/u/14119929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cherrymui", "html_url": "https://github.com/cherrymui", "followers_url": "https://api.github.com/users/cherrymui/followers", "following_url": "https://api.github.com/users/cherrymui/following{/other_user}", "gists_url": "https://api.github.com/users/cherrymui/gists{/gist_id}", "starred_url": "https://api.github.com/users/cherrymui/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cherrymui/subscriptions", "organizations_url": "https://api.github.com/users/cherrymui/orgs", "repos_url": "https://api.github.com/users/cherrymui/repos", "events_url": "https://api.github.com/users/cherrymui/events{/privacy}", "received_events_url": "https://api.github.com/users/cherrymui/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "92b8603c7c6789806879307a29ae3b85adaaaf14", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92b8603c7c6789806879307a29ae3b85adaaaf14", "html_url": "https://github.com/Rust-GCC/gccrs/commit/92b8603c7c6789806879307a29ae3b85adaaaf14"}], "stats": {"total": 392, "additions": 369, "deletions": 23}, "files": [{"sha": "fba3721f23d578f9a3680e7c76f1d7343854246b", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8e91b845496603168161015ccd5325524abbf7e/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8e91b845496603168161015ccd5325524abbf7e/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=e8e91b845496603168161015ccd5325524abbf7e", "patch": "@@ -1,4 +1,4 @@\n-6112f9b8fa9d57d2db8a709cc8b44a94d778d08a\n+2df0879e7880057293c0a59be6868a3e6ea5105b\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "47c133150eca26456e0e621a644f2d2842fc6dd7", "filename": "gcc/go/gofrontend/escape.cc", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8e91b845496603168161015ccd5325524abbf7e/gcc%2Fgo%2Fgofrontend%2Fescape.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8e91b845496603168161015ccd5325524abbf7e/gcc%2Fgo%2Fgofrontend%2Fescape.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fescape.cc?ref=e8e91b845496603168161015ccd5325524abbf7e", "patch": "@@ -2407,9 +2407,11 @@ Escape_analysis_assign::assign(Node* dst, Node* src)\n             Type* tt = tce->type();\n             if ((ft->is_string_type() && tt->is_slice_type())\n                 || (ft->is_slice_type() && tt->is_string_type())\n-                || (ft->integer_type() != NULL && tt->is_string_type()))\n+                || (ft->integer_type() != NULL && tt->is_string_type())\n+                || tt->interface_type() != NULL)\n               {\n-                // string([]byte), string([]rune), []byte(string), []rune(string), string(rune)\n+                // string([]byte), string([]rune), []byte(string), []rune(string), string(rune),\n+                // interface(T)\n                 this->flows(dst, src);\n                 break;\n               }\n@@ -3151,14 +3153,24 @@ Escape_analysis_flood::flood(Level level, Node* dst, Node* src,\n           Type* tt = tce->type();\n           if ((ft->is_string_type() && tt->is_slice_type())\n               || (ft->is_slice_type() && tt->is_string_type())\n-              || (ft->integer_type() != NULL && tt->is_string_type()))\n+              || (ft->integer_type() != NULL && tt->is_string_type())\n+              || tt->interface_type() != NULL)\n             {\n-              // string([]byte), string([]rune), []byte(string), []rune(string), string(rune)\n+              // string([]byte), string([]rune), []byte(string), []rune(string), string(rune),\n+              // interface(T)\n               src->set_encoding(Node::ESCAPE_HEAP);\n               if (debug_level != 0 && osrcesc != src->encoding())\n                 go_inform(src->location(), \"%s escapes to heap\",\n                           src->ast_format(gogo).c_str());\n               extra_loop_depth = mod_loop_depth;\n+              if (tt->interface_type() != NULL\n+                  && ft->has_pointer()\n+                  && !ft->is_direct_iface_type())\n+                // We're converting from a non-direct interface type.\n+                // The interface will hold a heap copy of the data\n+                // Flow the data to heap. See issue 29353.\n+                this->flood(level, this->context_->sink(),\n+                            Node::make_node(tce->expr()), -1);\n             }\n         }\n       else if (e->array_index_expression() != NULL"}, {"sha": "8af0dd43a88c6f0c82432bd759f660a2f3c74708", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 166, "deletions": 13, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8e91b845496603168161015ccd5325524abbf7e/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8e91b845496603168161015ccd5325524abbf7e/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=e8e91b845496603168161015ccd5325524abbf7e", "patch": "@@ -184,11 +184,10 @@ Expression::convert_for_assignment(Gogo*, Type* lhs_type,\n \t\t\t\t\t   NULL);\n   if (!are_identical && lhs_type->interface_type() != NULL)\n     {\n-      if (rhs_type->interface_type() == NULL)\n-        return Expression::convert_type_to_interface(lhs_type, rhs, location);\n-      else\n-        return Expression::convert_interface_to_interface(lhs_type, rhs, false,\n-                                                          location);\n+      // Type to interface conversions have been made explicit early.\n+      go_assert(rhs_type->interface_type() != NULL);\n+      return Expression::convert_interface_to_interface(lhs_type, rhs, false,\n+                                                        location);\n     }\n   else if (!are_identical && rhs_type->interface_type() != NULL)\n     return Expression::convert_interface_to_type(lhs_type, rhs, location);\n@@ -231,11 +230,12 @@ Expression::convert_for_assignment(Gogo*, Type* lhs_type,\n }\n \n // Return an expression for a conversion from a non-interface type to an\n-// interface type.\n+// interface type.  If ON_STACK is true, it can allocate the storage on\n+// stack.\n \n Expression*\n Expression::convert_type_to_interface(Type* lhs_type, Expression* rhs,\n-                                      Location location)\n+                                      bool on_stack, Location location)\n {\n   Interface_type* lhs_interface_type = lhs_type->interface_type();\n   bool lhs_is_empty = lhs_interface_type->is_empty();\n@@ -302,9 +302,9 @@ Expression::convert_type_to_interface(Type* lhs_type, Expression* rhs,\n     {\n       // We are assigning a non-pointer value to the interface; the\n       // interface gets a copy of the value in the heap if it escapes.\n-      // TODO(cmang): Associate escape state state of RHS with newly\n-      // created OBJ.\n       obj = Expression::make_heap_expression(rhs, location);\n+      if (on_stack)\n+        obj->heap_expression()->set_allocate_on_stack();\n     }\n \n   return Expression::make_interface_value(lhs_type, first_field, obj, location);\n@@ -3625,6 +3625,14 @@ Type_conversion_expression::do_flatten(Gogo*, Named_object*,\n       inserter->insert(temp);\n       this->expr_ = Expression::make_temporary_reference(temp, this->location());\n     }\n+\n+  // For interface conversion, decide if we can allocate on stack.\n+  if (this->type()->interface_type() != NULL)\n+    {\n+      Node* n = Node::make_node(this);\n+      if ((n->encoding() & ESCAPE_MASK) == Node::ESCAPE_NONE)\n+        this->no_escape_ = true;\n+    }\n   return this;\n }\n \n@@ -3812,12 +3820,20 @@ Type_conversion_expression::do_get_backend(Translate_context* context)\n       Bexpression* bexpr = this->expr_->get_backend(context);\n       return gogo->backend()->convert_expression(btype, bexpr, loc);\n     }\n+  else if (type->interface_type() != NULL\n+           && expr_type->interface_type() == NULL)\n+    {\n+      Expression* conversion =\n+          Expression::convert_type_to_interface(type, this->expr_,\n+                                                this->no_escape_, loc);\n+      return conversion->get_backend(context);\n+    }\n   else if (type->interface_type() != NULL\n \t   || expr_type->interface_type() != NULL)\n     {\n       Expression* conversion =\n           Expression::convert_for_assignment(gogo, type, this->expr_,\n-                                             this->location());\n+                                             loc);\n       return conversion->get_backend(context);\n     }\n   else if (type->is_string_type()\n@@ -8466,19 +8482,23 @@ Builtin_call_expression::flatten_append(Gogo* gogo, Named_object* function,\n           lhs->array_index_expression()->set_needs_bounds_check(false);\n \t  gogo->lower_expression(function, inserter, &lhs);\n \t  gogo->flatten_expression(function, inserter, &lhs);\n+      Expression* elem = *pa;\n+      if (!Type::are_identical(element_type, elem->type(), 0, NULL)\n+          && element_type->interface_type() != NULL)\n+        elem = Expression::make_cast(element_type, elem, loc);\n \t  // The flatten pass runs after the write barrier pass, so we\n \t  // need to insert a write barrier here if necessary.\n \t  // However, if ASSIGN_LHS is not NULL, we have been called\n \t  // directly before the write barrier pass.\n \t  Statement* assign;\n \t  if (assign_lhs != NULL\n \t      || !gogo->assign_needs_write_barrier(lhs))\n-\t    assign = Statement::make_assignment(lhs, *pa, loc);\n+\t    assign = Statement::make_assignment(lhs, elem, loc);\n \t  else\n \t    {\n \t      Function* f = function == NULL ? NULL : function->func_value();\n \t      assign = gogo->assign_with_write_barrier(f, NULL, inserter,\n-\t\t\t\t\t\t       lhs, *pa, loc);\n+\t\t\t\t\t\t       lhs, elem, loc);\n \t    }\n \t  inserter->insert(assign);\n \t}\n@@ -9840,7 +9860,7 @@ Builtin_call_expression::do_get_backend(Translate_context* context)\n \t  Type::make_empty_interface_type(Linemap::predeclared_location());\n \n \tExpression* nil = Expression::make_nil(location);\n-\tnil = Expression::convert_for_assignment(gogo, empty, nil, location);\n+        nil = Expression::make_interface_value(empty, nil, nil, location);\n \n \t// We need to handle a deferred call to recover specially,\n \t// because it changes whether it can recover a panic or not.\n@@ -10474,6 +10494,46 @@ Call_expression::do_flatten(Gogo* gogo, Named_object*,\n   return this;\n }\n \n+// Make implicit type conversions explicit.\n+\n+void\n+Call_expression::do_add_conversions()\n+{\n+  // Skip call that requires a thunk. We generate conversions inside the thunk.\n+  if (this->is_concurrent_ || this->is_deferred_)\n+    return;\n+\n+  if (this->args_ == NULL || this->args_->empty())\n+    return;\n+\n+  Function_type* fntype = this->get_function_type();\n+  if (fntype == NULL)\n+    {\n+      go_assert(saw_errors());\n+      return;\n+    }\n+  if (fntype->parameters() == NULL || fntype->parameters()->empty())\n+    return;\n+\n+  Location loc = this->location();\n+  Expression_list::iterator pa = this->args_->begin();\n+  Typed_identifier_list::const_iterator pp = fntype->parameters()->begin();\n+  bool is_interface_method =\n+    this->fn_->interface_field_reference_expression() != NULL;\n+  if (!is_interface_method && fntype->is_method())\n+    {\n+      // Skip the receiver argument, which cannot be interface.\n+      pa++;\n+    }\n+  for (; pa != this->args_->end(); ++pa, ++pp)\n+    {\n+      Type* pt = pp->type();\n+      if (!Type::are_identical(pt, (*pa)->type(), 0, NULL)\n+          && pt->interface_type() != NULL)\n+        *pa = Expression::make_cast(pt, *pa, loc);\n+    }\n+}\n+\n // Get the function type.  This can return NULL in error cases.\n \n Function_type*\n@@ -12250,6 +12310,21 @@ Map_index_expression::do_check_types(Gogo*)\n     }\n }\n \n+// Add explicit type conversions.\n+\n+void\n+Map_index_expression::do_add_conversions()\n+{\n+  Map_type* mt = this->get_map_type();\n+  if (mt == NULL)\n+    return;\n+  Type* lt = mt->key_type();\n+  Type* rt = this->index_->type();\n+  if (!Type::are_identical(lt, rt, 0, NULL)\n+      && lt->interface_type() != NULL)\n+    this->index_ = Expression::make_cast(lt, this->index_, this->location());\n+}\n+\n // Get the backend representation for a map index.\n \n Bexpression*\n@@ -13450,6 +13525,33 @@ Struct_construction_expression::do_flatten(Gogo*, Named_object*,\n   return this;\n }\n \n+// Make implicit type conversions explicit.\n+\n+void\n+Struct_construction_expression::do_add_conversions()\n+{\n+  if (this->vals() == NULL)\n+    return;\n+\n+  Location loc = this->location();\n+  const Struct_field_list* fields = this->type_->struct_type()->fields();\n+  Expression_list::iterator pv = this->vals()->begin();\n+  for (Struct_field_list::const_iterator pf = fields->begin();\n+       pf != fields->end();\n+       ++pf, ++pv)\n+    {\n+      if (pv == this->vals()->end())\n+        break;\n+      if (*pv != NULL)\n+        {\n+          Type* ft = pf->type();\n+          if (!Type::are_identical(ft, (*pv)->type(), 0, NULL)\n+              && ft->interface_type() != NULL)\n+           *pv = Expression::make_cast(ft, *pv, loc);\n+        }\n+    }\n+}\n+\n // Return the backend representation for constructing a struct.\n \n Bexpression*\n@@ -13698,6 +13800,26 @@ Array_construction_expression::do_flatten(Gogo*, Named_object*,\n   return this;\n }\n \n+// Make implicit type conversions explicit.\n+\n+void\n+Array_construction_expression::do_add_conversions()\n+{\n+  if (this->vals() == NULL)\n+    return;\n+\n+  Type* et = this->type_->array_type()->element_type();\n+  if (et->interface_type() == NULL)\n+    return;\n+\n+  Location loc = this->location();\n+  for (Expression_list::iterator pv = this->vals()->begin();\n+       pv != this->vals()->end();\n+       ++pv)\n+    if (!Type::are_identical(et, (*pv)->type(), 0, NULL))\n+      *pv = Expression::make_cast(et, *pv, loc);\n+}\n+\n // Get a constructor expression for the array values.\n \n Bexpression*\n@@ -14221,6 +14343,37 @@ Map_construction_expression::do_copy()\n \t\t\t\t\t this->location());\n }\n \n+// Make implicit type conversions explicit.\n+\n+void\n+Map_construction_expression::do_add_conversions()\n+{\n+  if (this->vals_ == NULL || this->vals_->empty())\n+    return;\n+\n+  Map_type* mt = this->type_->map_type();\n+  Type* kt = mt->key_type();\n+  Type* vt = mt->val_type();\n+  bool key_is_interface = (kt->interface_type() != NULL);\n+  bool val_is_interface = (vt->interface_type() != NULL);\n+  if (!key_is_interface && !val_is_interface)\n+    return;\n+\n+  Location loc = this->location();\n+  for (Expression_list::iterator pv = this->vals_->begin();\n+       pv != this->vals_->end();\n+       ++pv)\n+    {\n+      if (key_is_interface &&\n+          !Type::are_identical(kt, (*pv)->type(), 0, NULL))\n+        *pv = Expression::make_cast(kt, *pv, loc);\n+      ++pv;\n+      if (val_is_interface &&\n+          !Type::are_identical(vt, (*pv)->type(), 0, NULL))\n+        *pv = Expression::make_cast(vt, *pv, loc);\n+    }\n+}\n+\n // Return the backend representation for constructing a map.\n \n Bexpression*"}, {"sha": "b1811ea2f1f85734d1c21773da6fcf744df07fea", "filename": "gcc/go/gofrontend/expressions.h", "status": "modified", "additions": 36, "deletions": 4, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8e91b845496603168161015ccd5325524abbf7e/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8e91b845496603168161015ccd5325524abbf7e/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.h?ref=e8e91b845496603168161015ccd5325524abbf7e", "patch": "@@ -934,6 +934,11 @@ class Expression\n   flatten(Gogo* gogo, Named_object* function, Statement_inserter* inserter)\n   { return this->do_flatten(gogo, function, inserter); }\n \n+  // Make implicit type conversions explicit.\n+  void\n+  add_conversions()\n+  { this->do_add_conversions(); }\n+\n   // Determine the real type of an expression with abstract integer,\n   // floating point, or complex type.  TYPE_CONTEXT describes the\n   // expected type.\n@@ -1019,6 +1024,13 @@ class Expression\n                                  Expression* rhs, bool for_type_guard,\n                                  Location);\n \n+  // Return an expression for a conversion from a non-interface type to an\n+  // interface type.  If ON_STACK is true, it can allocate the storage on\n+  // stack.\n+  static Expression*\n+  convert_type_to_interface(Type* lhs_type, Expression* rhs,\n+                            bool on_stack, Location);\n+\n   // Return a backend expression implementing the comparison LEFT OP RIGHT.\n   // TYPE is the type of both sides.\n   static Bexpression*\n@@ -1070,6 +1082,10 @@ class Expression\n   do_flatten(Gogo*, Named_object*, Statement_inserter*)\n   { return this; }\n \n+  // Make implicit type conversions explicit.\n+  virtual void\n+  do_add_conversions()\n+  { }\n \n   // Return whether this is a constant expression.\n   virtual bool\n@@ -1214,9 +1230,6 @@ class Expression\n \t    : NULL);\n   }\n \n-  static Expression*\n-  convert_type_to_interface(Type*, Expression*, Location);\n-\n   static Expression*\n   unpack_direct_iface(Expression*, Location);\n \n@@ -1674,7 +1687,7 @@ class Type_conversion_expression : public Expression\n \t\t\t     Location location)\n     : Expression(EXPRESSION_CONVERSION, location),\n       type_(type), expr_(expr), may_convert_function_types_(false),\n-      no_copy_(false)\n+      no_copy_(false), no_escape_(false)\n   { }\n \n   // Return the type to which we are converting.\n@@ -1766,6 +1779,10 @@ class Type_conversion_expression : public Expression\n   // True if a string([]byte) conversion can reuse the backing store\n   // without copying.  Only used in string([]byte) conversion.\n   bool no_copy_;\n+  // True if a conversion to interface does not escape, so it does\n+  // not need a heap allocation.  Only used in type-to-interface\n+  // conversion.\n+  bool no_escape_;\n };\n \n // An unsafe type conversion, used to pass values to builtin functions.\n@@ -2402,6 +2419,9 @@ class Call_expression : public Expression\n   void\n   do_dump_expression(Ast_dump_context*) const;\n \n+  void\n+  do_add_conversions();\n+\n  private:\n   bool\n   check_argument_type(int, const Type*, const Type*, Location, bool);\n@@ -3162,6 +3182,9 @@ class Map_index_expression : public Expression\n   void\n   do_dump_expression(Ast_dump_context*) const;\n \n+  void\n+  do_add_conversions();\n+\n  private:\n   // The map we are looking into.\n   Expression* map_;\n@@ -3648,6 +3671,9 @@ class Struct_construction_expression : public Expression,\n   void\n   do_dump_expression(Ast_dump_context*) const;\n \n+  void\n+  do_add_conversions();\n+\n  private:\n   // The type of the struct to construct.\n   Type* type_;\n@@ -3721,6 +3747,9 @@ class Array_construction_expression : public Expression,\n   virtual void\n   dump_slice_storage_expression(Ast_dump_context*) const { }\n \n+  void\n+  do_add_conversions();\n+\n  private:\n   // The type of the array to construct.\n   Type* type_;\n@@ -3844,6 +3873,9 @@ class Map_construction_expression : public Expression\n   void\n   do_dump_expression(Ast_dump_context*) const;\n \n+  void\n+  do_add_conversions();\n+\n  private:\n   // The type of the map to construct.\n   Type* type_;"}, {"sha": "5106e8d043464109615f2d5961143e89f23c4368", "filename": "gcc/go/gofrontend/go.cc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8e91b845496603168161015ccd5325524abbf7e/gcc%2Fgo%2Fgofrontend%2Fgo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8e91b845496603168161015ccd5325524abbf7e/gcc%2Fgo%2Fgofrontend%2Fgo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgo.cc?ref=e8e91b845496603168161015ccd5325524abbf7e", "patch": "@@ -142,6 +142,10 @@ go_parse_input_files(const char** filenames, unsigned int filename_count,\n   if (only_check_syntax)\n     return;\n \n+  // Make implicit type conversions explicit.\n+  ::gogo->add_conversions();\n+\n+  // Analyze the program flow for escape information.\n   ::gogo->analyze_escape();\n \n   // Export global identifiers as appropriate."}, {"sha": "06657cb2be4b569afd0bfc5343d314f49de30c4d", "filename": "gcc/go/gofrontend/gogo.cc", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8e91b845496603168161015ccd5325524abbf7e/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8e91b845496603168161015ccd5325524abbf7e/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc?ref=e8e91b845496603168161015ccd5325524abbf7e", "patch": "@@ -2996,6 +2996,57 @@ Gogo::lower_constant(Named_object* no)\n   lower.constant(no, false);\n }\n \n+// Make implicit type conversions explicit.  Currently only does for\n+// interface conversions, so the escape analysis can see them and\n+// optimize.\n+\n+class Add_conversions : public Traverse\n+{\n+ public:\n+  Add_conversions()\n+    : Traverse(traverse_statements\n+               | traverse_expressions)\n+  { }\n+\n+  int\n+  statement(Block*, size_t* pindex, Statement*);\n+\n+  int\n+  expression(Expression**);\n+};\n+\n+// Add explicit conversions in a statement.\n+\n+int\n+Add_conversions::statement(Block*, size_t*, Statement* sorig)\n+{\n+  sorig->add_conversions();\n+  return TRAVERSE_CONTINUE;\n+}\n+\n+// Add explicit conversions in an expression.\n+\n+int\n+Add_conversions::expression(Expression** pexpr)\n+{\n+  (*pexpr)->add_conversions();\n+  return TRAVERSE_CONTINUE;\n+}\n+\n+void\n+Gogo::add_conversions()\n+{\n+  Add_conversions add_conversions;\n+  this->traverse(&add_conversions);\n+}\n+\n+void\n+Gogo::add_conversions_in_block(Block *b)\n+{\n+  Add_conversions add_conversions;\n+  b->traverse(&add_conversions);\n+}\n+\n // Traverse the tree to create function descriptors as needed.\n \n class Create_function_descriptors : public Traverse"}, {"sha": "448da0473164d58cf8f66393bde9a80545de5ca1", "filename": "gcc/go/gofrontend/gogo.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8e91b845496603168161015ccd5325524abbf7e/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8e91b845496603168161015ccd5325524abbf7e/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.h?ref=e8e91b845496603168161015ccd5325524abbf7e", "patch": "@@ -683,6 +683,14 @@ class Gogo\n   void\n   check_return_statements();\n \n+  // Make implicit type conversions explicit.\n+  void\n+  add_conversions();\n+\n+  // Make implicit type conversions explicit in a block.\n+  void\n+  add_conversions_in_block(Block*);\n+\n   // Analyze the program flow for escape information.\n   void\n   analyze_escape();"}, {"sha": "c850b49bebd564c8e1ad5700a2ffadc88a6b3ee2", "filename": "gcc/go/gofrontend/statements.cc", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8e91b845496603168161015ccd5325524abbf7e/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8e91b845496603168161015ccd5325524abbf7e/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.cc?ref=e8e91b845496603168161015ccd5325524abbf7e", "patch": "@@ -324,6 +324,22 @@ Variable_declaration_statement::do_flatten(Gogo* gogo, Named_object* function,\n   return this;\n }\n \n+// Add explicit type conversions.\n+\n+void\n+Variable_declaration_statement::do_add_conversions()\n+{\n+  Variable* var = this->var_->var_value();\n+  Expression* init = var->init();\n+  if (init == NULL)\n+    return;\n+  Type* lt = var->type();\n+  Type* rt = init->type();\n+  if (!Type::are_identical(lt, rt, 0, NULL)\n+      && lt->interface_type() != NULL)\n+    var->set_init(Expression::make_cast(lt, init, this->location()));\n+}\n+\n // Convert a variable declaration to the backend representation.\n \n Bstatement*\n@@ -582,6 +598,20 @@ Temporary_statement::do_flatten(Gogo*, Named_object*, Block*,\n   return this;\n }\n \n+// Add explicit type conversions.\n+\n+void\n+Temporary_statement::do_add_conversions()\n+{\n+  if (this->init_ == NULL)\n+    return;\n+  Type* lt = this->type();\n+  Type* rt = this->init_->type();\n+  if (!Type::are_identical(lt, rt, 0, NULL)\n+      && lt->interface_type() != NULL)\n+    this->init_ = Expression::make_cast(lt, this->init_, this->location());\n+}\n+\n // Convert to backend representation.\n \n Bstatement*\n@@ -960,6 +990,18 @@ Assignment_statement::do_flatten(Gogo*, Named_object*, Block*,\n   return this;\n }\n \n+// Add explicit type conversions.\n+\n+void\n+Assignment_statement::do_add_conversions()\n+{\n+  Type* lt = this->lhs_->type();\n+  Type* rt = this->rhs_->type();\n+  if (!Type::are_identical(lt, rt, 0, NULL)\n+      && lt->interface_type() != NULL)\n+    this->rhs_ = Expression::make_cast(lt, this->rhs_, this->location());\n+}\n+\n // Convert an assignment statement to the backend representation.\n \n Bstatement*\n@@ -2638,6 +2680,8 @@ Thunk_statement::build_thunk(Gogo* gogo, const std::string& thunk_name)\n   // just for the call statement now.  The other types are known.\n   call_statement->determine_types();\n \n+  gogo->add_conversions_in_block(b);\n+\n   gogo->flatten_block(function, b);\n \n   if (may_call_recover\n@@ -4543,6 +4587,18 @@ Send_statement::do_flatten(Gogo*, Named_object*, Block*,\n   return this;\n }\n \n+// Add explicit type conversions.\n+\n+void\n+Send_statement::do_add_conversions()\n+{\n+  Type* lt = this->channel_->type()->channel_type()->element_type();\n+  Type* rt = this->val_->type();\n+  if (!Type::are_identical(lt, rt, 0, NULL)\n+      && lt->interface_type() != NULL)\n+    this->val_ = Expression::make_cast(lt, this->val_, this->location());\n+}\n+\n // Convert a send statement to the backend representation.\n \n Bstatement*"}, {"sha": "2985daa6a722f53b9cf66d6d9844e56d11ebd496", "filename": "gcc/go/gofrontend/statements.h", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8e91b845496603168161015ccd5325524abbf7e/gcc%2Fgo%2Fgofrontend%2Fstatements.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8e91b845496603168161015ccd5325524abbf7e/gcc%2Fgo%2Fgofrontend%2Fstatements.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.h?ref=e8e91b845496603168161015ccd5325524abbf7e", "patch": "@@ -338,6 +338,11 @@ class Statement\n   export_statement(Export_function_body* efb)\n   { this->do_export_statement(efb); }\n \n+  // Make implicit type conversions explicit.\n+  void\n+  add_conversions()\n+  { this->do_add_conversions(); }\n+\n   // Read a statement from export data.  The location should be used\n   // for the returned statement.  Errors should be reported using the\n   // Import_function_body's location method.\n@@ -534,6 +539,11 @@ class Statement\n   virtual void\n   do_dump_statement(Ast_dump_context*) const = 0;\n \n+  // Implemented by child class: make implicit conversions explicit.\n+  virtual void\n+  do_add_conversions()\n+  { }\n+\n   // Traverse an expression in a statement.\n   int\n   traverse_expression(Traverse*, Expression**);\n@@ -645,6 +655,9 @@ class Assignment_statement : public Statement\n   void\n   do_dump_statement(Ast_dump_context*) const;\n \n+  void\n+  do_add_conversions();\n+\n  private:\n   // Left hand side--the lvalue.\n   Expression* lhs_;\n@@ -717,6 +730,9 @@ class Temporary_statement : public Statement\n   void\n   do_dump_statement(Ast_dump_context*) const;\n \n+  void\n+  do_add_conversions();\n+\n  private:\n   // The type of the temporary variable.\n   Type* type_;\n@@ -774,6 +790,9 @@ class Variable_declaration_statement : public Statement\n   void\n   do_dump_statement(Ast_dump_context*) const;\n \n+  void\n+  do_add_conversions();\n+\n  private:\n   Named_object* var_;\n };\n@@ -959,6 +978,9 @@ class Send_statement : public Statement\n   void\n   do_dump_statement(Ast_dump_context*) const;\n \n+  void\n+  do_add_conversions();\n+\n  private:\n   // The channel on which to send the value.\n   Expression* channel_;"}, {"sha": "835963b8f033a9d6dc0ffe7a1cab59b6a1d465c9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8e91b845496603168161015ccd5325524abbf7e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8e91b845496603168161015ccd5325524abbf7e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e8e91b845496603168161015ccd5325524abbf7e", "patch": "@@ -1,3 +1,8 @@\n+2019-05-15  Cherry Zhang  <cherryyz@google.com>\n+\n+\t* go.test/test/nilptr2.go: Change use function to actually do\n+\tsomething.\n+\n 2019-05-16  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR middle-end/90478"}, {"sha": "d2f4c912f6487cdb8b8f718de654b960f674b5f5", "filename": "gcc/testsuite/go.test/test/nilptr2.go", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8e91b845496603168161015ccd5325524abbf7e/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fnilptr2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8e91b845496603168161015ccd5325524abbf7e/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fnilptr2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fnilptr2.go?ref=e8e91b845496603168161015ccd5325524abbf7e", "patch": "@@ -35,7 +35,10 @@ var m *M\n var m1 *M1\n var m2 *M2\n \n-func use(interface{}) {\n+var V interface{}\n+\n+func use(x interface{}) {\n+\tV = x\n }\n \n var tests = []struct{"}]}