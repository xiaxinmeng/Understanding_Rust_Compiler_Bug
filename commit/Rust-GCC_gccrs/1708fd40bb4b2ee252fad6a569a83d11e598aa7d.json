{"sha": "1708fd40bb4b2ee252fad6a569a83d11e598aa7d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTcwOGZkNDBiYjRiMmVlMjUyZmFkNmE1NjlhODNkMTFlNTk4YWE3ZA==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@redhat.co.uk", "date": "2000-12-03T12:53:49Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2000-12-03T12:53:49Z"}, "message": "Try to separate region-specific code from generic parts in the scheuler.\n\nFrom-SVN: r37973", "tree": {"sha": "76bfc4f35ce9611f979c77fba7c771b3e6631668", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/76bfc4f35ce9611f979c77fba7c771b3e6631668"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1708fd40bb4b2ee252fad6a569a83d11e598aa7d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1708fd40bb4b2ee252fad6a569a83d11e598aa7d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1708fd40bb4b2ee252fad6a569a83d11e598aa7d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1708fd40bb4b2ee252fad6a569a83d11e598aa7d/comments", "author": null, "committer": null, "parents": [{"sha": "881bc7db37d9dc2e8836338d4167f23ab34a8163", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/881bc7db37d9dc2e8836338d4167f23ab34a8163", "html_url": "https://github.com/Rust-GCC/gccrs/commit/881bc7db37d9dc2e8836338d4167f23ab34a8163"}], "stats": {"total": 851, "additions": 529, "deletions": 322}, "files": [{"sha": "fe83a48df9bf0aafe0dcfab164a51149f1dbed5d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1708fd40bb4b2ee252fad6a569a83d11e598aa7d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1708fd40bb4b2ee252fad6a569a83d11e598aa7d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1708fd40bb4b2ee252fad6a569a83d11e598aa7d", "patch": "@@ -1,3 +1,30 @@\n+2000-12-03  Bernd Schmidt  <bernds@redhat.co.uk>\n+\n+\t* sched-int.h: New file.\n+\t* Makefile.in (haifa-sched.o): Depend on it.\n+\t* haifa-sched.c: Include it.\n+\t(no_real_insns_p): New function.\n+\t(current_sched_info): New static variable.\n+\t(__inline, HAIFA_INLINE): Moved to sched-int.h.\n+\t(get_block_head_tail): Minor cleanup.\n+\t(init_ready_list, can_schedule_ready_p, new_ready, schedule_more_p,\n+\trgn_print_insn, rgn_rank): New functions, broken out of\n+\trank_for_schedule, schedule_insn and schedule_block, where they\n+\tare now called through function pointers in current_sched_info.\n+\t(queue_insn, schedule_insn, queue_to_ready, debug_ready_list,\n+\tprint_insn): To display uid and block number, call the print_insn\n+\tfunction pointer in current_schedule_info.\n+\t(region_sched_info): New static variable.\n+\t(sched_target_n_insns, sched_n_insns, target_n_insns): New global\n+\tvariables, moved out of schedule_block.\n+\t(schedule_block): Return void.  All callers changed.\n+\tMove some of the setup code into schedule_region.  Get head/tail\n+\tfrom current_sched_info, and update it when done.\n+\t(schedule_region): Slightly rearranged, some code moved here from\n+\tschedule_block.  Call no_real_insns_p to avoid doing work for a\n+\tblock that consists only of notes and labels.\n+\t(schedule_insns): Initialize current_sched_info.\n+\n 2000-12-03  Neil Booth  <neilb@earthling.net>\n \n         * cppmacro.c (funlike_invocation_p): Re-disable macros enabled"}, {"sha": "7071c88dc788f6bcf2100cec23da64533ec44df3", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1708fd40bb4b2ee252fad6a569a83d11e598aa7d/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1708fd40bb4b2ee252fad6a569a83d11e598aa7d/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=1708fd40bb4b2ee252fad6a569a83d11e598aa7d", "patch": "@@ -1452,7 +1452,7 @@ alias.o : alias.c $(CONFIG_H) system.h $(RTL_H) flags.h hard-reg-set.h \\\n regmove.o : regmove.c $(CONFIG_H) system.h $(RTL_H) insn-config.h \\\n    $(RECOG_H) output.h $(REGS_H) hard-reg-set.h flags.h function.h \\\n    $(EXPR_H) insn-flags.h $(BASIC_BLOCK_H) toplev.h\n-haifa-sched.o : haifa-sched.c $(CONFIG_H) system.h $(RTL_H) \\\n+haifa-sched.o : haifa-sched.c $(CONFIG_H) system.h $(RTL_H) sched-int.h \\\n    $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h flags.h insn-config.h function.h \\\n    $(INSN_ATTR_H) toplev.h $(RECOG_H) except.h\n final.o : final.c $(CONFIG_H) system.h $(RTL_H) $(TREE_H) flags.h intl.h \\"}, {"sha": "6a07f3cea27e05d0c881f4361ce9c0fd5fd2a805", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 429, "deletions": 321, "changes": 750, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1708fd40bb4b2ee252fad6a569a83d11e598aa7d/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1708fd40bb4b2ee252fad6a569a83d11e598aa7d/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=1708fd40bb4b2ee252fad6a569a83d11e598aa7d", "patch": "@@ -170,6 +170,7 @@ the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"except.h\"\n #include \"toplev.h\"\n #include \"recog.h\"\n+#include \"sched-int.h\"\n \n extern char *reg_known_equiv_p;\n extern rtx *reg_known_value;\n@@ -523,7 +524,7 @@ static void swap_sort PARAMS ((rtx *, int));\n static void queue_insn PARAMS ((rtx, int));\n static void schedule_insn PARAMS ((rtx, struct ready_list *, int));\n static void find_insn_reg_weight PARAMS ((int));\n-static int schedule_block PARAMS ((int, int));\n+static void schedule_block PARAMS ((int, int));\n static char *safe_concat PARAMS ((char *, char *, const char *));\n static int insn_issue_delay PARAMS ((rtx));\n static void adjust_priority PARAMS ((rtx));\n@@ -789,6 +790,7 @@ static void rm_redundant_line_notes PARAMS ((void));\n static void rm_other_notes PARAMS ((rtx, rtx));\n static rtx reemit_notes PARAMS ((rtx, rtx));\n \n+static int no_real_insns_p PARAMS ((rtx, rtx));\n static void get_block_head_tail PARAMS ((int, rtx *, rtx *));\n static void get_bb_head_tail PARAMS ((int, rtx *, rtx *));\n \n@@ -829,6 +831,9 @@ static void propagate_deps PARAMS ((int, struct deps *, int));\n \n #endif /* INSN_SCHEDULING */\n \f\n+/* Point to state used for the current scheduling pass.  */\n+struct sched_info *current_sched_info;\n+\n #define SIZE_FOR_MODE(X) (GET_MODE_SIZE (GET_MODE (X)))\n \n /* Add ELEM wrapped in an INSN_LIST with reg note kind DEP_TYPE to the\n@@ -1137,13 +1142,6 @@ schedule_insns (dump_file)\n {\n }\n #else\n-#ifndef __GNUC__\n-#define __inline\n-#endif\n-\n-#ifndef HAIFA_INLINE\n-#define HAIFA_INLINE __inline\n-#endif\n \n /* Computation of memory dependencies.  */\n \n@@ -4170,7 +4168,7 @@ rank_for_schedule (x, y)\n   rtx tmp2 = *(const rtx *) x;\n   rtx link;\n   int tmp_class, tmp2_class, depend_count1, depend_count2;\n-  int val, priority_val, spec_val, prob_val, weight_val;\n+  int val, priority_val, weight_val, info_val;\n \n   /* Prefer insn with higher priority.  */\n   priority_val = INSN_PRIORITY (tmp2) - INSN_PRIORITY (tmp);\n@@ -4182,24 +4180,9 @@ rank_for_schedule (x, y)\n       (weight_val = INSN_REG_WEIGHT (tmp) - INSN_REG_WEIGHT (tmp2)))\n     return (weight_val);\n \n-  /* Some comparison make sense in interblock scheduling only.  */\n-  if (INSN_BB (tmp) != INSN_BB (tmp2))\n-    {\n-      /* Prefer an inblock motion on an interblock motion.  */\n-      if ((INSN_BB (tmp2) == target_bb) && (INSN_BB (tmp) != target_bb))\n-\treturn 1;\n-      if ((INSN_BB (tmp) == target_bb) && (INSN_BB (tmp2) != target_bb))\n-\treturn -1;\n-\n-      /* Prefer a useful motion on a speculative one.  */\n-      if ((spec_val = IS_SPECULATIVE_INSN (tmp) - IS_SPECULATIVE_INSN (tmp2)))\n-\treturn (spec_val);\n-\n-      /* Prefer a more probable (speculative) insn.  */\n-      prob_val = INSN_PROBABILITY (tmp2) - INSN_PROBABILITY (tmp);\n-      if (prob_val)\n-\treturn (prob_val);\n-    }\n+  info_val = (*current_sched_info->rank) (tmp, tmp2);\n+  if (info_val)\n+    return info_val;\n \n   /* Compare insns based on their relation to the last-scheduled-insn.  */\n   if (last_scheduled_insn)\n@@ -4284,10 +4267,8 @@ queue_insn (insn, n_cycles)\n \n   if (sched_verbose >= 2)\n     {\n-      fprintf (sched_dump, \";;\\t\\tReady-->Q: insn %d: \", INSN_UID (insn));\n-\n-      if (INSN_BB (insn) != target_bb)\n-\tfprintf (sched_dump, \"(b%d) \", BLOCK_NUM (insn));\n+      fprintf (sched_dump, \";;\\t\\tReady-->Q: insn %s: \",\n+\t       (*current_sched_info->print_insn) (insn, 0));\n \n       fprintf (sched_dump, \"queued for %d cycles.\\n\", n_cycles);\n     }\n@@ -4420,24 +4401,13 @@ schedule_insn (insn, ready, clock)\n \t{\n \t  int effective_cost = INSN_TICK (next) - clock;\n \n-\t  /* For speculative insns, before inserting to ready/queue,\n-\t     check live, exception-free, and issue-delay.  */\n-\t  if (INSN_BB (next) != target_bb\n-\t      && (!IS_VALID (INSN_BB (next))\n-\t\t  || CANT_MOVE (next)\n-\t\t  || (IS_SPECULATIVE_INSN (next)\n-\t\t      && (insn_issue_delay (next) > 3\n-\t\t\t  || !check_live (next, INSN_BB (next))\n-\t\t || !is_exception_free (next, INSN_BB (next), target_bb)))))\n+\t  if (! (*current_sched_info->new_ready) (next))\n \t    continue;\n \n \t  if (sched_verbose >= 2)\n \t    {\n-\t      fprintf (sched_dump, \";;\\t\\tdependences resolved: insn %d \",\n-\t\t       INSN_UID (next));\n-\n-\t      if (current_nr_blocks > 1 && INSN_BB (next) != target_bb)\n-\t\tfprintf (sched_dump, \"/b%d \", BLOCK_NUM (next));\n+\t      fprintf (sched_dump, \";;\\t\\tdependences resolved: insn %s \",\n+\t\t       (*current_sched_info->print_insn) (next, 0));\n \n \t      if (effective_cost < 1)\n \t\tfprintf (sched_dump, \"into ready\\n\");\n@@ -4549,13 +4519,9 @@ get_block_head_tail (b, headp, tailp)\n      rtx *headp;\n      rtx *tailp;\n {\n-\n-  rtx head;\n-  rtx tail;\n-\n   /* HEAD and TAIL delimit the basic block being scheduled.  */\n-  head = BLOCK_HEAD (b);\n-  tail = BLOCK_END (b);\n+  rtx head = BLOCK_HEAD (b);\n+  rtx tail = BLOCK_END (b);\n \n   /* Don't include any notes or labels at the beginning of the\n      basic block, or notes at the ends of basic blocks.  */\n@@ -4584,6 +4550,21 @@ get_bb_head_tail (bb, headp, tailp)\n   get_block_head_tail (BB_TO_BLOCK (bb), headp, tailp);\n }\n \n+/* Return nonzero if there are no real insns in the range [ HEAD, TAIL ].  */\n+\n+static int\n+no_real_insns_p (head, tail)\n+     rtx head, tail;\n+{\n+  while (head != NEXT_INSN (tail))\n+    {\n+      if (GET_CODE (head) != NOTE && GET_CODE (head) != CODE_LABEL)\n+\treturn 0;\n+      head = NEXT_INSN (head);\n+    }\n+  return 1;\n+}\n+\n /* Delete line notes from bb. Save them so they can be later restored\n    (in restore_line_notes ()).  */\n \n@@ -4878,10 +4859,8 @@ queue_to_ready (ready)\n       q_size -= 1;\n \n       if (sched_verbose >= 2)\n-\tfprintf (sched_dump, \";;\\t\\tQ-->Ready: insn %d: \", INSN_UID (insn));\n-\n-      if (sched_verbose >= 2 && INSN_BB (insn) != target_bb)\n-\tfprintf (sched_dump, \"(b%d) \", BLOCK_NUM (insn));\n+\tfprintf (sched_dump, \";;\\t\\tQ-->Ready: insn %s: \",\n+\t\t (*current_sched_info->print_insn) (insn, 0));\n \n       ready_add (ready, insn);\n       if (sched_verbose >= 2)\n@@ -4905,11 +4884,8 @@ queue_to_ready (ready)\n \t\t  q_size -= 1;\n \n \t\t  if (sched_verbose >= 2)\n-\t\t    fprintf (sched_dump, \";;\\t\\tQ-->Ready: insn %d: \",\n-\t\t\t     INSN_UID (insn));\n-\n-\t\t  if (sched_verbose >= 2 && INSN_BB (insn) != target_bb)\n-\t\t    fprintf (sched_dump, \"(b%d) \", BLOCK_NUM (insn));\n+\t\t    fprintf (sched_dump, \";;\\t\\tQ-->Ready: insn %s: \",\n+\t\t\t     (*current_sched_info->print_insn) (insn, 0));\n \n \t\t  ready_add (ready, insn);\n \t\t  if (sched_verbose >= 2)\n@@ -4943,11 +4919,7 @@ debug_ready_list (ready)\n \n   p = ready_lastpos (ready);\n   for (i = 0; i < ready->n_ready; i++)\n-    {\n-      fprintf (sched_dump, \"  %d\", INSN_UID (p[i]));\n-      if (current_nr_blocks > 1 && INSN_BB (p[i]) != target_bb)\n-\tfprintf (sched_dump, \"/b%d\", BLOCK_NUM (p[i]));\n-    }\n+    fprintf (sched_dump, \"  %s\", (*current_sched_info->print_insn) (p[i], 0));\n   fprintf (sched_dump, \"\\n\");\n }\n \n@@ -5655,16 +5627,16 @@ print_insn (buf, x, verbose)\n     case INSN:\n       print_pattern (t, PATTERN (x), verbose);\n       if (verbose)\n-\tsprintf (buf, \"b%d: i% 4d: %s\", INSN_BB (x),\n-\t\t INSN_UID (x), t);\n+\tsprintf (buf, \"%s: %s\", (*current_sched_info->print_insn) (x, 1),\n+\t\t t);\n       else\n \tsprintf (buf, \"%-4d %s\", INSN_UID (x), t);\n       break;\n     case JUMP_INSN:\n       print_pattern (t, PATTERN (x), verbose);\n       if (verbose)\n-\tsprintf (buf, \"b%d: i% 4d: jump %s\", INSN_BB (x),\n-\t\t INSN_UID (x), t);\n+\tsprintf (buf, \"%s: jump %s\", (*current_sched_info->print_insn) (x, 1),\n+\t\t t);\n       else\n \tsprintf (buf, \"%-4d %s\", INSN_UID (x), t);\n       break;\n@@ -5678,8 +5650,7 @@ print_insn (buf, x, verbose)\n       else\n \tstrcpy (t, \"call <...>\");\n       if (verbose)\n-\tsprintf (buf, \"b%d: i% 4d: %s\", INSN_BB (insn),\n-\t\t INSN_UID (insn), t);\n+\tsprintf (buf, \"%s: %s\", (*current_sched_info->print_insn) (x, 1), t);\n       else\n \tsprintf (buf, \"%-4d %s\", INSN_UID (insn), t);\n       break;\n@@ -5819,6 +5790,292 @@ visualize_stall_cycles (b, stalls)\n   sprintf (visual_tbl + strlen (visual_tbl), \"\\n\");\n }\n \n+/* The number of insns from the current block scheduled so far.  */\n+static int sched_target_n_insns;\n+/* The number of insns from the current block to be scheduled in total.  */\n+static int target_n_insns;\n+/* The number of insns from the entire region scheduled so far.  */\n+static int sched_n_insns;\n+\n+/* Implementations of the sched_info functions for region scheduling.  */\n+static void init_ready_list PARAMS ((struct ready_list *));\n+static int can_schedule_ready_p PARAMS ((rtx));\n+static int new_ready PARAMS ((rtx));\n+static int schedule_more_p PARAMS ((void));\n+static const char *rgn_print_insn PARAMS ((rtx, int));\n+static int rgn_rank PARAMS ((rtx, rtx));\n+\n+/* Return nonzero if there are more insns that should be scheduled.  */\n+\n+static int\n+schedule_more_p ()\n+{\n+  return sched_target_n_insns < target_n_insns;\n+}\n+\n+/* Add all insns that are initially ready to the ready list READY.  Called\n+   once before scheduling a set of insns.  */\n+\n+static void\n+init_ready_list (ready)\n+     struct ready_list *ready;\n+{\n+  rtx prev_head = current_sched_info->prev_head;\n+  rtx next_tail = current_sched_info->next_tail;\n+  int bb_src;\n+  rtx insn;\n+\n+  target_n_insns = 0;\n+  sched_target_n_insns = 0;\n+  sched_n_insns = 0;\n+\n+  /* Print debugging information.  */\n+  if (sched_verbose >= 5)\n+    debug_dependencies ();\n+\n+  /* Prepare current target block info.  */\n+  if (current_nr_blocks > 1)\n+    {\n+      candidate_table = (candidate *) xmalloc (current_nr_blocks\n+\t\t\t\t\t       * sizeof (candidate));\n+\n+      bblst_last = 0;\n+      /* bblst_table holds split blocks and update blocks for each block after\n+\t the current one in the region.  split blocks and update blocks are\n+\t the TO blocks of region edges, so there can be at most rgn_nr_edges\n+\t of them.  */\n+      bblst_size = (current_nr_blocks - target_bb) * rgn_nr_edges;\n+      bblst_table = (int *) xmalloc (bblst_size * sizeof (int));\n+\n+      bitlst_table_last = 0;\n+      bitlst_table_size = rgn_nr_edges;\n+      bitlst_table = (int *) xmalloc (rgn_nr_edges * sizeof (int));\n+\n+      compute_trg_info (target_bb);\n+    }\n+\n+  /* Initialize ready list with all 'ready' insns in target block.\n+     Count number of insns in the target block being scheduled.  */\n+  for (insn = NEXT_INSN (prev_head); insn != next_tail; insn = NEXT_INSN (insn))\n+    {\n+      rtx next;\n+\n+      if (! INSN_P (insn))\n+\tcontinue;\n+      next = NEXT_INSN (insn);\n+\n+      if (INSN_DEP_COUNT (insn) == 0\n+\t  && (SCHED_GROUP_P (next) == 0 || ! INSN_P (next)))\n+\tready_add (ready, insn);\n+      if (!(SCHED_GROUP_P (insn)))\n+\ttarget_n_insns++;\n+    }\n+\n+  /* Add to ready list all 'ready' insns in valid source blocks.\n+     For speculative insns, check-live, exception-free, and\n+     issue-delay.  */\n+  for (bb_src = target_bb + 1; bb_src < current_nr_blocks; bb_src++)\n+    if (IS_VALID (bb_src))\n+      {\n+\trtx src_head;\n+\trtx src_next_tail;\n+\trtx tail, head;\n+\n+\tget_bb_head_tail (bb_src, &head, &tail);\n+\tsrc_next_tail = NEXT_INSN (tail);\n+\tsrc_head = head;\n+\n+\tfor (insn = src_head; insn != src_next_tail; insn = NEXT_INSN (insn))\n+\t  {\n+\t    if (! INSN_P (insn))\n+\t      continue;\n+\n+\t    if (!CANT_MOVE (insn)\n+\t\t&& (!IS_SPECULATIVE_INSN (insn)\n+\t\t    || (insn_issue_delay (insn) <= 3\n+\t\t\t&& check_live (insn, bb_src)\n+\t\t\t&& is_exception_free (insn, bb_src, target_bb))))\n+\t      {\n+\t\trtx next;\n+\n+\t\t/* Note that we havn't squirrled away the notes for\n+\t\t   blocks other than the current.  So if this is a\n+\t\t   speculative insn, NEXT might otherwise be a note.  */\n+\t\tnext = next_nonnote_insn (insn);\n+\t\tif (INSN_DEP_COUNT (insn) == 0\n+\t\t    && (! next\n+\t\t\t|| SCHED_GROUP_P (next) == 0\n+\t\t\t|| ! INSN_P (next)))\n+\t\t  ready_add (ready, insn);\n+\t      }\n+\t  }\n+      }\n+}\n+\n+/* Called after taking INSN from the ready list.  Returns nonzero if this\n+   insn can be scheduled, nonzero if we should silently discard it.  */\n+\n+static int\n+can_schedule_ready_p (insn)\n+     rtx insn;\n+{\n+  /* An interblock motion?  */\n+  if (INSN_BB (insn) != target_bb)\n+    {\n+      rtx temp;\n+      basic_block b1;\n+\n+      if (IS_SPECULATIVE_INSN (insn))\n+\t{\n+\t  if (!check_live (insn, INSN_BB (insn)))\n+\t    return 0;\n+\t  update_live (insn, INSN_BB (insn));\n+\n+\t  /* For speculative load, mark insns fed by it.  */\n+\t  if (IS_LOAD_INSN (insn) || FED_BY_SPEC_LOAD (insn))\n+\t    set_spec_fed (insn);\n+\n+\t  nr_spec++;\n+\t}\n+      nr_inter++;\n+\n+      /* Find the beginning of the scheduling group.  */\n+      /* ??? Ought to update basic block here, but later bits of\n+\t schedule_block assumes the original insn block is\n+\t still intact.  */\n+\n+      temp = insn;\n+      while (SCHED_GROUP_P (temp))\n+\ttemp = PREV_INSN (temp);\n+\n+      /* Update source block boundaries.   */\n+      b1 = BLOCK_FOR_INSN (temp);\n+      if (temp == b1->head && insn == b1->end)\n+\t{\n+\t  /* We moved all the insns in the basic block.\n+\t     Emit a note after the last insn and update the\n+\t     begin/end boundaries to point to the note.  */\n+\t  rtx note = emit_note_after (NOTE_INSN_DELETED, insn);\n+\t  b1->head = note;\n+\t  b1->end = note;\n+\t}\n+      else if (insn == b1->end)\n+\t{\n+\t  /* We took insns from the end of the basic block,\n+\t     so update the end of block boundary so that it\n+\t     points to the first insn we did not move.  */\n+\t  b1->end = PREV_INSN (temp);\n+\t}\n+      else if (temp == b1->head)\n+\t{\n+\t  /* We took insns from the start of the basic block,\n+\t     so update the start of block boundary so that\n+\t     it points to the first insn we did not move.  */\n+\t  b1->head = NEXT_INSN (insn);\n+\t}\n+    }\n+  else\n+    {\n+      /* In block motion.  */\n+      sched_target_n_insns++;\n+    }\n+  sched_n_insns++;\n+\n+  return 1;\n+}\n+\n+/* Called after INSN has all its dependencies resolved.  Return nonzero\n+   if it should be moved to the ready list or the queue, or zero if we\n+   should silently discard it.  */\n+static int\n+new_ready (next)\n+     rtx next;\n+{\n+  /* For speculative insns, before inserting to ready/queue,\n+     check live, exception-free, and issue-delay.  */\n+  if (INSN_BB (next) != target_bb\n+      && (!IS_VALID (INSN_BB (next))\n+\t  || CANT_MOVE (next)\n+\t  || (IS_SPECULATIVE_INSN (next)\n+\t      && (insn_issue_delay (next) > 3\n+\t\t  || !check_live (next, INSN_BB (next))\n+\t\t  || !is_exception_free (next, INSN_BB (next), target_bb)))))\n+    return 0;\n+  return 1;\n+}\n+\n+/* Return a string that contains the insn uid and optionally anything else\n+   necessary to identify this insn in an output.  It's valid to use a\n+   static buffer for this.  The ALIGNED parameter should cause the string\n+   to be formatted so that multiple output lines will line up nicely.  */\n+\n+static const char *\n+rgn_print_insn (insn, aligned)\n+     rtx insn;\n+     int aligned;\n+{\n+  static char tmp[80];\n+\n+  if (aligned)\n+    sprintf (tmp, \"b%3d: i%4d\", INSN_BB (insn), INSN_UID (insn));\n+  else\n+    {\n+      sprintf (tmp, \"%d\", INSN_UID (insn));\n+      if (current_nr_blocks > 1 && INSN_BB (insn) != target_bb)\n+\tsprintf (tmp, \"/b%d \", INSN_BB (insn));\n+    }\n+  return tmp;\n+}\n+\n+/* Compare priority of two insns.  Return a positive number if the second\n+   insn is to be preferred for scheduling, and a negative one if the first\n+   is to be preferred.  Zero if they are equally good.  */\n+\n+static int\n+rgn_rank (insn1, insn2)\n+     rtx insn1, insn2;\n+{\n+  /* Some comparison make sense in interblock scheduling only.  */\n+  if (INSN_BB (insn1) != INSN_BB (insn2))\n+    {\n+      int spec_val, prob_val;\n+\n+      /* Prefer an inblock motion on an interblock motion.  */\n+      if ((INSN_BB (insn2) == target_bb) && (INSN_BB (insn1) != target_bb))\n+\treturn 1;\n+      if ((INSN_BB (insn1) == target_bb) && (INSN_BB (insn2) != target_bb))\n+\treturn -1;\n+\n+      /* Prefer a useful motion on a speculative one.  */\n+      spec_val = IS_SPECULATIVE_INSN (insn1) - IS_SPECULATIVE_INSN (insn2);\n+      if (spec_val)\n+\treturn spec_val;\n+\n+      /* Prefer a more probable (speculative) insn.  */\n+      prob_val = INSN_PROBABILITY (insn2) - INSN_PROBABILITY (insn1);\n+      if (prob_val)\n+\treturn prob_val;\n+    }\n+  return 0;\n+}\n+\n+/* Used in schedule_insns to initialize current_sched_info for scheduling\n+   regions (or single basic blocks).  */\n+\n+static struct sched_info region_sched_info =\n+{\n+  init_ready_list,\n+  can_schedule_ready_p,\n+  schedule_more_p,\n+  new_ready,\n+  rgn_rank,\n+  rgn_print_insn,\n+\n+  NULL, NULL,\n+  NULL, NULL,\n+  0\n+};\n+\n /* move_insn1: Remove INSN from insn chain, and link it after LAST insn.  */\n \n static rtx\n@@ -5950,83 +6207,35 @@ group_leader (insn)\n }\n \n /* Use forward list scheduling to rearrange insns of block BB in region RGN,\n-   possibly bringing insns from subsequent blocks in the same region.\n-   Return number of insns scheduled.  */\n+   possibly bringing insns from subsequent blocks in the same region.  */\n \n-static int\n+static void\n schedule_block (bb, rgn_n_insns)\n      int bb;\n      int rgn_n_insns;\n {\n-  /* Local variables.  */\n-  rtx insn, last;\n+  rtx last;\n   struct ready_list ready;\n   int can_issue_more;\n \n   /* Flow block of this bb.  */\n   int b = BB_TO_BLOCK (bb);\n \n-  /* target_n_insns == number of insns in b before scheduling starts.\n-     sched_target_n_insns == how many of b's insns were scheduled.\n-     sched_n_insns == how many insns were scheduled in b.  */\n-  int target_n_insns = 0;\n-  int sched_target_n_insns = 0;\n-  int sched_n_insns = 0;\n-\n-#define NEED_NOTHING\t0\n-#define NEED_HEAD\t1\n-#define NEED_TAIL\t2\n-  int new_needs;\n-\n   /* Head/tail info for this block.  */\n-  rtx prev_head;\n-  rtx next_tail;\n-  rtx head;\n-  rtx tail;\n-  int bb_src;\n+  rtx prev_head = current_sched_info->prev_head;\n+  rtx next_tail = current_sched_info->next_tail;\n+  rtx head = NEXT_INSN (prev_head);\n+  rtx tail = PREV_INSN (next_tail);\n \n   /* We used to have code to avoid getting parameters moved from hard\n      argument registers into pseudos.\n \n      However, it was removed when it proved to be of marginal benefit\n      and caused problems because schedule_block and compute_forward_dependences\n      had different notions of what the \"head\" insn was.  */\n-  get_bb_head_tail (bb, &head, &tail);\n-\n-  /* rm_other_notes only removes notes which are _inside_ the\n-     block---that is, it won't remove notes before the first real insn\n-     or after the last real insn of the block.  So if the first insn\n-     has a REG_SAVE_NOTE which would otherwise be emitted before the\n-     insn, it is redundant with the note before the start of the\n-     block, and so we have to take it out.\n-\n-     FIXME: Probably the same thing should be done with REG_SAVE_NOTEs\n-     referencing NOTE_INSN_SETJMP at the end of the block.  */\n-  if (INSN_P (head))\n-    {\n-      rtx note;\n \n-      for (note = REG_NOTES (head); note; note = XEXP (note, 1))\n-\tif (REG_NOTE_KIND (note) == REG_SAVE_NOTE)\n-\t  {\n-\t    if (INTVAL (XEXP (note, 0)) != NOTE_INSN_SETJMP)\n-\t      {\n-\t\tremove_note (head, note);\n-\t\tnote = XEXP (note, 1);\n-\t\tremove_note (head, note);\n-\t      }\n-\t    else\n-\t      note = XEXP (note, 1);\n-\t  }\n-    }\n-\n-  next_tail = NEXT_INSN (tail);\n-  prev_head = PREV_INSN (head);\n-\n-  /* If the only insn left is a NOTE or a CODE_LABEL, then there is no need\n-     to schedule this block.  */\n   if (head == tail && (! INSN_P (head)))\n-    return (sched_n_insns);\n+    abort ();\n \n   /* Debug info.  */\n   if (sched_verbose)\n@@ -6043,35 +6252,6 @@ schedule_block (bb, rgn_n_insns)\n       init_block_visualization ();\n     }\n \n-  /* Remove remaining note insns from the block, save them in\n-     note_list.  These notes are restored at the end of\n-     schedule_block ().  */\n-  note_list = 0;\n-  rm_other_notes (head, tail);\n-\n-  target_bb = bb;\n-\n-  /* Prepare current target block info.  */\n-  if (current_nr_blocks > 1)\n-    {\n-      candidate_table = (candidate *) xmalloc (current_nr_blocks\n-\t\t\t\t\t       * sizeof (candidate));\n-\n-      bblst_last = 0;\n-      /* bblst_table holds split blocks and update blocks for each block after\n-\t the current one in the region.  split blocks and update blocks are\n-\t the TO blocks of region edges, so there can be at most rgn_nr_edges\n-\t of them.  */\n-      bblst_size = (current_nr_blocks - bb) * rgn_nr_edges;\n-      bblst_table = (int *) xmalloc (bblst_size * sizeof (int));\n-\n-      bitlst_table_last = 0;\n-      bitlst_table_size = rgn_nr_edges;\n-      bitlst_table = (int *) xmalloc (rgn_nr_edges * sizeof (int));\n-\n-      compute_trg_info (bb);\n-    }\n-\n   clear_units ();\n \n   /* Allocate the ready list.  */\n@@ -6080,69 +6260,7 @@ schedule_block (bb, rgn_n_insns)\n   ready.vec = (rtx *) xmalloc (ready.veclen * sizeof (rtx));\n   ready.n_ready = 0;\n \n-  /* Print debugging information.  */\n-  if (sched_verbose >= 5)\n-    debug_dependencies ();\n-\n-  /* Initialize ready list with all 'ready' insns in target block.\n-     Count number of insns in the target block being scheduled.  */\n-  for (insn = head; insn != next_tail; insn = NEXT_INSN (insn))\n-    {\n-      rtx next;\n-\n-      if (! INSN_P (insn))\n-\tcontinue;\n-      next = NEXT_INSN (insn);\n-\n-      if (INSN_DEP_COUNT (insn) == 0\n-\t  && (SCHED_GROUP_P (next) == 0 || ! INSN_P (next)))\n-\tready_add (&ready, insn);\n-      if (!(SCHED_GROUP_P (insn)))\n-\ttarget_n_insns++;\n-    }\n-\n-  /* Add to ready list all 'ready' insns in valid source blocks.\n-     For speculative insns, check-live, exception-free, and\n-     issue-delay.  */\n-  for (bb_src = bb + 1; bb_src < current_nr_blocks; bb_src++)\n-    if (IS_VALID (bb_src))\n-      {\n-\trtx src_head;\n-\trtx src_next_tail;\n-\trtx tail, head;\n-\n-\tget_bb_head_tail (bb_src, &head, &tail);\n-\tsrc_next_tail = NEXT_INSN (tail);\n-\tsrc_head = head;\n-\n-\tif (head == tail && (! INSN_P (head)))\n-\t  continue;\n-\n-\tfor (insn = src_head; insn != src_next_tail; insn = NEXT_INSN (insn))\n-\t  {\n-\t    if (! INSN_P (insn))\n-\t      continue;\n-\n-\t    if (!CANT_MOVE (insn)\n-\t\t&& (!IS_SPECULATIVE_INSN (insn)\n-\t\t    || (insn_issue_delay (insn) <= 3\n-\t\t\t&& check_live (insn, bb_src)\n-\t\t\t&& is_exception_free (insn, bb_src, target_bb))))\n-\t      {\n-\t\trtx next;\n-\n-\t\t/* Note that we havn't squirrled away the notes for\n-\t\t   blocks other than the current.  So if this is a\n-\t\t   speculative insn, NEXT might otherwise be a note.  */\n-\t\tnext = next_nonnote_insn (insn);\n-\t\tif (INSN_DEP_COUNT (insn) == 0\n-\t\t    && (! next\n-\t\t\t|| SCHED_GROUP_P (next) == 0\n-\t\t\t|| ! INSN_P (next)))\n-\t\t  ready_add (&ready, insn);\n-\t      }\n-\t  }\n-      }\n+  (*current_sched_info->init_ready_list) (&ready);\n \n #ifdef MD_SCHED_INIT\n   MD_SCHED_INIT (sched_dump, sched_verbose);\n@@ -6151,7 +6269,8 @@ schedule_block (bb, rgn_n_insns)\n   /* No insns scheduled in this block yet.  */\n   last_scheduled_insn = 0;\n \n-  /* Q_SIZE is the total number of insns in the queue.  */\n+  /* Initialize INSN_QUEUE.  Q_SIZE is the total number of insns in the\n+     queue.  */\n   q_ptr = 0;\n   q_size = 0;\n   last_clock_var = 0;\n@@ -6163,14 +6282,8 @@ schedule_block (bb, rgn_n_insns)\n   /* We start inserting insns after PREV_HEAD.  */\n   last = prev_head;\n \n-  /* Initialize INSN_QUEUE, LIST and NEW_NEEDS.  */\n-  new_needs = (NEXT_INSN (prev_head) == BLOCK_HEAD (b)\n-\t       ? NEED_HEAD : NEED_NOTHING);\n-  if (PREV_INSN (next_tail) == BLOCK_END (b))\n-    new_needs |= NEED_TAIL;\n-\n   /* Loop until all the insns in BB are scheduled.  */\n-  while (sched_target_n_insns < target_n_insns)\n+  while ((*current_sched_info->schedule_more_p) ())\n     {\n       clock_var++;\n \n@@ -6220,70 +6333,11 @@ schedule_block (bb, rgn_n_insns)\n \t      continue;\n \t    }\n \n-\t  /* An interblock motion?  */\n-\t  if (INSN_BB (insn) != target_bb)\n-\t    {\n-\t      rtx temp;\n-\t      basic_block b1;\n-\n-\t      if (IS_SPECULATIVE_INSN (insn))\n-\t\t{\n-\t\t  if (!check_live (insn, INSN_BB (insn)))\n-\t\t    continue;\n-\t\t  update_live (insn, INSN_BB (insn));\n-\n-\t\t  /* For speculative load, mark insns fed by it.  */\n-\t\t  if (IS_LOAD_INSN (insn) || FED_BY_SPEC_LOAD (insn))\n-\t\t    set_spec_fed (insn);\n-\n-\t\t  nr_spec++;\n-\t\t}\n-\t      nr_inter++;\n-\n-\t      /* Find the beginning of the scheduling group.  */\n-\t      /* ??? Ought to update basic block here, but later bits of\n-\t\t schedule_block assumes the original insn block is\n-\t\t still intact.  */\n-\n-\t      temp = insn;\n-\t      while (SCHED_GROUP_P (temp))\n-\t\ttemp = PREV_INSN (temp);\n-\n-\t      /* Update source block boundaries.   */\n-\t      b1 = BLOCK_FOR_INSN (temp);\n-\t      if (temp == b1->head && insn == b1->end)\n-\t\t{\n-\t\t  /* We moved all the insns in the basic block.\n-\t\t     Emit a note after the last insn and update the\n-\t\t     begin/end boundaries to point to the note.  */\n-\t\t  rtx note = emit_note_after (NOTE_INSN_DELETED, insn);\n-\t\t  b1->head = note;\n-\t\t  b1->end = note;\n-\t\t}\n-\t      else if (insn == b1->end)\n-\t\t{\n-\t\t  /* We took insns from the end of the basic block,\n-\t\t     so update the end of block boundary so that it\n-\t\t     points to the first insn we did not move.  */\n-\t\t  b1->end = PREV_INSN (temp);\n-\t\t}\n-\t      else if (temp == b1->head)\n-\t\t{\n-\t\t  /* We took insns from the start of the basic block,\n-\t\t     so update the start of block boundary so that\n-\t\t     it points to the first insn we did not move.  */\n-\t\t  b1->head = NEXT_INSN (insn);\n-\t\t}\n-\t    }\n-\t  else\n-\t    {\n-\t      /* In block motion.  */\n-\t      sched_target_n_insns++;\n-\t    }\n+\t  if (! (*current_sched_info->can_schedule_ready_p) (insn))\n+\t    goto next;\n \n \t  last_scheduled_insn = insn;\n \t  last = move_insn (insn, last);\n-\t  sched_n_insns++;\n \n #ifdef MD_SCHED_VARIABLE_ISSUE\n \t  MD_SCHED_VARIABLE_ISSUE (sched_dump, sched_verbose, insn,\n@@ -6294,6 +6348,7 @@ schedule_block (bb, rgn_n_insns)\n \n \t  schedule_insn (insn, &ready, clock_var);\n \n+\tnext:\n \t  /* Close this block after scheduling its jump.  */\n \t  if (GET_CODE (last_scheduled_insn) == JUMP_INSN)\n \t    break;\n@@ -6314,8 +6369,7 @@ schedule_block (bb, rgn_n_insns)\n \n   /* Sanity check -- queue must be empty now.  Meaningless if region has\n      multiple bbs.  */\n-  if (current_nr_blocks > 1)\n-    if (!flag_schedule_interblock && q_size != 0)\n+  if (current_sched_info->queue_must_finish_empty && q_size != 0)\n       abort ();\n \n   /* Update head/tail boundaries.  */\n@@ -6341,32 +6395,21 @@ schedule_block (bb, rgn_n_insns)\n       head = note_head;\n     }\n \n-  /* Update target block boundaries.  */\n-  if (new_needs & NEED_HEAD)\n-    BLOCK_HEAD (b) = head;\n-\n-  if (new_needs & NEED_TAIL)\n-    BLOCK_END (b) = tail;\n-\n   /* Debugging.  */\n   if (sched_verbose)\n     {\n-      fprintf (sched_dump, \";;   total time = %d\\n;;   new basic block head = %d\\n\",\n-\t       clock_var, INSN_UID (BLOCK_HEAD (b)));\n-      fprintf (sched_dump, \";;   new basic block end = %d\\n\\n\",\n-\t       INSN_UID (BLOCK_END (b)));\n+      fprintf (sched_dump, \";;   total time = %d\\n;;   new head = %d\\n\",\n+\t       clock_var, INSN_UID (head));\n+      fprintf (sched_dump, \";;   new tail = %d\\n\\n\",\n+\t       INSN_UID (tail));\n     }\n \n-  /* Clean up.  */\n-  if (current_nr_blocks > 1)\n-    {\n-      free (candidate_table);\n-      free (bblst_table);\n-      free (bitlst_table);\n-    }\n+  current_sched_info->head = head;\n+  current_sched_info->tail = tail;\n+\n   free (ready.vec);\n \n-  return (sched_n_insns);\n+  return 1;\n }\n \f\n /* Print the bit-set of registers, S, callable from debugger.  */\n@@ -6869,7 +6912,6 @@ set_priorities (bb)\n   n_insn = 0;\n   for (insn = tail; insn != prev_head; insn = PREV_INSN (insn))\n     {\n-\n       if (GET_CODE (insn) == NOTE)\n \tcontinue;\n \n@@ -6921,17 +6963,9 @@ schedule_region (rgn)\n       compute_forward_dependences (head, tail);\n     }\n \n-  /* Delete line notes and set priorities.  */\n+  /* Set priorities.  */\n   for (bb = 0; bb < current_nr_blocks; bb++)\n-    {\n-      if (write_symbols != NO_DEBUG)\n-\t{\n-\t  save_line_notes (bb);\n-\t  rm_line_notes (bb);\n-\t}\n-\n-      rgn_n_insns += set_priorities (bb);\n-    }\n+    rgn_n_insns += set_priorities (bb);\n \n   /* Compute interblock info: probabilities, split-edges, dominators, etc.  */\n   if (current_nr_blocks > 1)\n@@ -6979,7 +7013,79 @@ schedule_region (rgn)\n \n   /* Now we can schedule all blocks.  */\n   for (bb = 0; bb < current_nr_blocks; bb++)\n-    sched_rgn_n_insns += schedule_block (bb, rgn_n_insns);\n+    {\n+      rtx head, tail;\n+      int b = BB_TO_BLOCK (bb);\n+\n+      get_block_head_tail (b, &head, &tail);\n+\n+      if (no_real_insns_p (head, tail))\n+\tcontinue;\n+\n+      current_sched_info->prev_head = PREV_INSN (head);\n+      current_sched_info->next_tail = NEXT_INSN (tail);\n+\n+      if (write_symbols != NO_DEBUG)\n+\t{\n+\t  save_line_notes (bb);\n+\t  rm_line_notes (bb);\n+\t}\n+\n+      /* rm_other_notes only removes notes which are _inside_ the\n+\t block---that is, it won't remove notes before the first real insn\n+ \t or after the last real insn of the block.  So if the first insn\n+\t has a REG_SAVE_NOTE which would otherwise be emitted before the\n+\t insn, it is redundant with the note before the start of the\n+\t block, and so we have to take it out.\n+\n+\t FIXME: Probably the same thing should be done with REG_SAVE_NOTEs\n+\t referencing NOTE_INSN_SETJMP at the end of the block.  */\n+      if (INSN_P (head))\n+\t{\n+\t  rtx note;\n+\n+\t  for (note = REG_NOTES (head); note; note = XEXP (note, 1))\n+\t    if (REG_NOTE_KIND (note) == REG_SAVE_NOTE)\n+\t      {\n+\t\tif (INTVAL (XEXP (note, 0)) != NOTE_INSN_SETJMP)\n+\t\t  {\n+\t\t    remove_note (head, note);\n+\t\t    note = XEXP (note, 1);\n+\t\t    remove_note (head, note);\n+\t\t  }\n+\t\telse\n+\t\t  note = XEXP (note, 1);\n+\t      }\n+\t}\n+\n+      /* Remove remaining note insns from the block, save them in\n+\t note_list.  These notes are restored at the end of\n+\t schedule_block ().  */\n+      note_list = 0;\n+      rm_other_notes (head, tail);\n+\n+      target_bb = bb;\n+\n+      current_sched_info->queue_must_finish_empty\n+\t= current_nr_blocks > 1 && !flag_schedule_interblock;\n+\n+      schedule_block (bb, rgn_n_insns);\n+      sched_rgn_n_insns += sched_n_insns;\n+\n+      /* Update target block boundaries.  */\n+      if (head == BLOCK_HEAD (b))\n+\tBLOCK_HEAD (b) = current_sched_info->head;\n+      if (tail == BLOCK_END (b))\n+\tBLOCK_END (b) = current_sched_info->tail;\n+\n+      /* Clean up.  */\n+      if (current_nr_blocks > 1)\n+\t{\n+\t  free (candidate_table);\n+\t  free (bblst_table);\n+\t  free (bitlst_table);\n+\t}\n+    }\n \n   /* Sanity check: verify that all region insns were scheduled.  */\n   if (sched_rgn_n_insns != rgn_n_insns)\n@@ -7240,6 +7346,8 @@ schedule_insns (dump_file)\n \n   init_regions ();\n \n+  current_sched_info = &region_sched_info;\n+  \n   /* Schedule every region in the subroutine.  */\n   for (rgn = 0; rgn < nr_regions; rgn++)\n     schedule_region (rgn);"}, {"sha": "bf14faa4ca2d9ea4502bd744b3b61e7c9fb9a470", "filename": "gcc/sched-int.h", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1708fd40bb4b2ee252fad6a569a83d11e598aa7d/gcc%2Fsched-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1708fd40bb4b2ee252fad6a569a83d11e598aa7d/gcc%2Fsched-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-int.h?ref=1708fd40bb4b2ee252fad6a569a83d11e598aa7d", "patch": "@@ -0,0 +1,72 @@\n+/* Instruction scheduling pass.  This file contains definitions used\n+   internally in the scheduler.\n+   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n+   1999, 2000 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 2, or (at your option) any\n+later version.\n+\n+GNU CC is distributed in the hope that it will be useful, but WITHOUT\n+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to the Free\n+the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+02111-1307, USA.  */\n+\n+/* Forward declaration.  */\n+struct ready_list;\n+\n+/* This structure holds some state of the current scheduling pass, and\n+   contains some function pointers that abstract out some of the non-generic\n+   functionality from functions such as schedule_block or schedule_insn.\n+   There is one global variable, current_sched_info, which points to the\n+   sched_info structure currently in use.  */\n+struct sched_info\n+{\n+  /* Add all insns that are initially ready to the ready list.  Called once\n+     before scheduling a set of insns.  */\n+  void (*init_ready_list) PARAMS ((struct ready_list *));\n+  /* Called after taking an insn from the ready list.  Returns nonzero if\n+     this insn can be scheduled, nonzero if we should silently discard it.  */\n+  int (*can_schedule_ready_p) PARAMS ((rtx));\n+  /* Return nonzero if there are more insns that should be scheduled.  */\n+  int (*schedule_more_p) PARAMS ((void));\n+  /* Called after an insn has all its dependencies resolved.  Return nonzero\n+     if it should be moved to the ready list or the queue, or zero if we\n+     should silently discard it.  */\n+  int (*new_ready) PARAMS ((rtx));\n+  /* Compare priority of two insns.  Return a positive number if the second\n+     insn is to be preferred for scheduling, and a negative one if the first\n+     is to be preferred.  Zero if they are equally good.  */\n+  int (*rank) PARAMS ((rtx, rtx));\n+  /* Return a string that contains the insn uid and optionally anything else\n+     necessary to identify this insn in an output.  It's valid to use a\n+     static buffer for this.  The ALIGNED parameter should cause the string\n+     to be formatted so that multiple output lines will line up nicely.  */\n+  const char *(*print_insn) PARAMS ((rtx, int));\n+\n+  /* The boundaries of the set of insns to be scheduled.  */\n+  rtx prev_head, next_tail;\n+\n+  /* Filled in after the schedule is finished; the first and last scheduled\n+     insns.  */\n+  rtx head, tail;\n+\n+  /* If nonzero, enables an additional sanity check in schedule_block.  */\n+  int queue_must_finish_empty;\n+};\n+\n+#ifndef __GNUC__\n+#define __inline\n+#endif\n+\n+#ifndef HAIFA_INLINE\n+#define HAIFA_INLINE __inline\n+#endif"}]}