{"sha": "6cb784b639c3de7505674b56f542c8b714d7df8a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmNiNzg0YjYzOWMzZGU3NTA1Njc0YjU2ZjU0MmM4YjcxNGQ3ZGY4YQ==", "commit": {"author": {"name": "Tim Shen", "email": "timshen91@gmail.com", "date": "2013-08-07T16:27:36Z"}, "committer": {"name": "Tim Shen", "email": "timshen@gcc.gnu.org", "date": "2013-08-07T16:27:36Z"}, "message": "Makefile.am: Adjust to new files.\n\n2013-08-07  Tim Shen  <timshen91@gmail.com>\n\n\t* include/Makefile.am: Adjust to new files.\n\t* include/Makefile.in: Regenerate.\n\t* include/bits/regex.h: Adjust to new interfaces.\n\t* include/bits/regex_automaton.h: New.\n\t* include/bits/regex_automaton.tcc: New.\n\t* include/bits/regex_compiler.h: Adjust to new files.\n\t* include/bits/regex_compiler.tcc: New.\n\t* include/bits/regex_constants.h: Tail spaces.\n\t* include/bits/regex_error.h: Likewise.\n\t* include/bits/regex_executor.h: New.\n\t* include/bits/regex_executor.tcc: New.\n\t* include/std/regex: Adjust to new files.\n\t* testsuite/28_regex/algorithms/regex_match/extended/\n\tstring_dispatch_01.cc: Adjust to new interfaces.\n\nFrom-SVN: r201573", "tree": {"sha": "4f7d7817ecc1c16e1953e9d0fd4f391d5a5dce2d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4f7d7817ecc1c16e1953e9d0fd4f391d5a5dce2d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6cb784b639c3de7505674b56f542c8b714d7df8a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6cb784b639c3de7505674b56f542c8b714d7df8a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6cb784b639c3de7505674b56f542c8b714d7df8a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6cb784b639c3de7505674b56f542c8b714d7df8a/comments", "author": {"login": "timshen91", "id": 1157432, "node_id": "MDQ6VXNlcjExNTc0MzI=", "avatar_url": "https://avatars.githubusercontent.com/u/1157432?v=4", "gravatar_id": "", "url": "https://api.github.com/users/timshen91", "html_url": "https://github.com/timshen91", "followers_url": "https://api.github.com/users/timshen91/followers", "following_url": "https://api.github.com/users/timshen91/following{/other_user}", "gists_url": "https://api.github.com/users/timshen91/gists{/gist_id}", "starred_url": "https://api.github.com/users/timshen91/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/timshen91/subscriptions", "organizations_url": "https://api.github.com/users/timshen91/orgs", "repos_url": "https://api.github.com/users/timshen91/repos", "events_url": "https://api.github.com/users/timshen91/events{/privacy}", "received_events_url": "https://api.github.com/users/timshen91/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5ee5b32cb20051b96dee793ef1c34355b43f8889", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ee5b32cb20051b96dee793ef1c34355b43f8889", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5ee5b32cb20051b96dee793ef1c34355b43f8889"}], "stats": {"total": 4473, "additions": 2128, "deletions": 2345}, "files": [{"sha": "025b482bc46414d073cd4c2b3878017ff86c1a97", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cb784b639c3de7505674b56f542c8b714d7df8a/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cb784b639c3de7505674b56f542c8b714d7df8a/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=6cb784b639c3de7505674b56f542c8b714d7df8a", "patch": "@@ -1,3 +1,20 @@\n+2013-08-07  Tim Shen  <timshen91@gmail.com>\n+\n+\t* include/Makefile.am: Adjust to new files.\n+\t* include/Makefile.in: Regenerate.\n+\t* include/bits/regex.h: Adjust to new interfaces.\n+\t* include/bits/regex_automaton.h: New.\n+\t* include/bits/regex_automaton.tcc: New.\n+\t* include/bits/regex_compiler.h: Adjust to new files.\n+\t* include/bits/regex_compiler.tcc: New.\n+\t* include/bits/regex_constants.h: Tail spaces.\n+\t* include/bits/regex_error.h: Likewise.\n+\t* include/bits/regex_executor.h: New.\n+\t* include/bits/regex_executor.tcc: New.\n+\t* include/std/regex: Adjust to new files.\n+\t* testsuite/28_regex/algorithms/regex_match/extended/\n+\tstring_dispatch_01.cc: Adjust to new interfaces.\n+\n 2013-08-07  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \t* include/ext/atomicity.h: Add #pragma GCC system_header."}, {"sha": "5971af3edc150dd4cb06d16123d495c8b0153da4", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cb784b639c3de7505674b56f542c8b714d7df8a/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cb784b639c3de7505674b56f542c8b714d7df8a/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=6cb784b639c3de7505674b56f542c8b714d7df8a", "patch": "@@ -126,14 +126,14 @@ bits_headers = \\\n \t${bits_srcdir}/random.tcc \\\n \t${bits_srcdir}/range_access.h \\\n \t${bits_srcdir}/regex.h \\\n-\t${bits_srcdir}/regex_compiler.h \\\n \t${bits_srcdir}/regex_constants.h \\\n-\t${bits_srcdir}/regex_cursor.h \\\n \t${bits_srcdir}/regex_error.h \\\n-\t${bits_srcdir}/regex_grep_matcher.h \\\n-\t${bits_srcdir}/regex_grep_matcher.tcc \\\n-\t${bits_srcdir}/regex_nfa.h \\\n-\t${bits_srcdir}/regex_nfa.tcc \\\n+\t${bits_srcdir}/regex_automaton.h \\\n+\t${bits_srcdir}/regex_automaton.tcc \\\n+\t${bits_srcdir}/regex_compiler.h \\\n+\t${bits_srcdir}/regex_compiler.tcc \\\n+\t${bits_srcdir}/regex_executor.h \\\n+\t${bits_srcdir}/regex_executor.tcc \\\n \t${bits_srcdir}/stream_iterator.h \\\n \t${bits_srcdir}/streambuf_iterator.h \\\n \t${bits_srcdir}/shared_ptr.h \\"}, {"sha": "aa8ef43b22426cf62f48b5943575145539546cb0", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cb784b639c3de7505674b56f542c8b714d7df8a/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cb784b639c3de7505674b56f542c8b714d7df8a/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=6cb784b639c3de7505674b56f542c8b714d7df8a", "patch": "@@ -393,14 +393,14 @@ bits_headers = \\\n \t${bits_srcdir}/random.tcc \\\n \t${bits_srcdir}/range_access.h \\\n \t${bits_srcdir}/regex.h \\\n-\t${bits_srcdir}/regex_compiler.h \\\n \t${bits_srcdir}/regex_constants.h \\\n-\t${bits_srcdir}/regex_cursor.h \\\n \t${bits_srcdir}/regex_error.h \\\n-\t${bits_srcdir}/regex_grep_matcher.h \\\n-\t${bits_srcdir}/regex_grep_matcher.tcc \\\n-\t${bits_srcdir}/regex_nfa.h \\\n-\t${bits_srcdir}/regex_nfa.tcc \\\n+\t${bits_srcdir}/regex_automaton.h \\\n+\t${bits_srcdir}/regex_automaton.tcc \\\n+\t${bits_srcdir}/regex_compiler.h \\\n+\t${bits_srcdir}/regex_compiler.tcc \\\n+\t${bits_srcdir}/regex_executor.h \\\n+\t${bits_srcdir}/regex_executor.tcc \\\n \t${bits_srcdir}/stream_iterator.h \\\n \t${bits_srcdir}/streambuf_iterator.h \\\n \t${bits_srcdir}/shared_ptr.h \\"}, {"sha": "ea32ade3f8eb14f1aca4690a7da0733b0dd45e46", "filename": "libstdc++-v3/include/bits/regex.h", "status": "modified", "additions": 167, "deletions": 123, "changes": 290, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cb784b639c3de7505674b56f542c8b714d7df8a/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cb784b639c3de7505674b56f542c8b714d7df8a/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex.h?ref=6cb784b639c3de7505674b56f542c8b714d7df8a", "patch": "@@ -40,7 +40,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   /**\n    * @brief Class regex_traits. Describes aspects of a regular expression.\n    *\n-   * A regular expression traits class that satisfies the requirements of \n+   * A regular expression traits class that satisfies the requirements of\n    * section [28.7].\n    *\n    * The class %regex is parameterized around a set of related types and\n@@ -61,7 +61,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n           _BaseType _M_base;\n           unsigned char _M_extended;\n           static constexpr unsigned char _S_under = 1 << 0;\n-          // FIXME: _S_blank should be removed in the future, when locale's complete.\n+          // FIXME: _S_blank should be removed in the future,\n+          // when locale's complete.\n           static constexpr unsigned char _S_blank = 1 << 1;\n           static constexpr unsigned char _S_valid_mask = 0x3;\n \n@@ -128,7 +129,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n        * @brief Constructs a default traits object.\n        */\n       regex_traits() { }\n-      \n+\n       /**\n        * @brief Gives the length of a C-style string starting at @p __p.\n        *\n@@ -153,7 +154,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       char_type\n       translate(char_type __c) const\n       { return __c; }\n-      \n+\n       /**\n        * @brief Translates a character into a case-insensitive equivalent.\n        *\n@@ -165,12 +166,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n        */\n       char_type\n       translate_nocase(char_type __c) const\n-      { \n+      {\n \ttypedef std::ctype<char_type> __ctype_type;\n \tconst __ctype_type& __fctyp(use_facet<__ctype_type>(_M_locale));\n-\treturn __fctyp.tolower(__c); \n+\treturn __fctyp.tolower(__c);\n       }\n-      \n+\n       /**\n        * @brief Gets a sort key for a character sequence.\n        *\n@@ -209,7 +210,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n        *\n        * Effects: if typeid(use_facet<collate<_Ch_type> >) ==\n        * typeid(collate_byname<_Ch_type>) and the form of the sort key\n-       * returned by collate_byname<_Ch_type>::transform(__first, __last) \n+       * returned by collate_byname<_Ch_type>::transform(__first, __last)\n        * is known and can be converted into a primary sort key\n        * then returns that key, otherwise returns an empty string.\n        *\n@@ -239,7 +240,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n        *\n        * @param __first beginning of the collation element name.\n        * @param __last  one-past-the-end of the collation element name.\n-       * \n+       *\n        * @returns a sequence of one or more characters that represents the\n        * collating element consisting of the character sequence designated by\n        * the iterator range [__first, __last). Returns an empty string if the\n@@ -312,13 +313,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n        * @param __ch    a character representing a digit.\n        * @param __radix the radix if the numeric conversion (limited to 8, 10,\n        *              or 16).\n-       * \n+       *\n        * @returns the value represented by the digit __ch in base radix if the\n        * character __ch is a valid digit in base radix; otherwise returns -1.\n        */\n       int\n       value(_Ch_type __ch, int __radix) const;\n-      \n+\n       /**\n        * @brief Imbues the regex_traits object with a copy of a new locale.\n        *\n@@ -336,15 +337,15 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \tstd::swap(_M_locale, __loc);\n \treturn __loc;\n       }\n-      \n+\n       /**\n        * @brief Gets a copy of the current locale in use by the regex_traits\n        * object.\n        */\n       locale_type\n       getloc() const\n       { return _M_locale; }\n-      \n+\n     protected:\n       locale_type _M_locale;\n     };\n@@ -579,7 +580,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n           if (__s == __it->first)\n             {\n               if (__icase\n-                  && ((__it->second & (ctype_base::lower | ctype_base::upper)) != 0))\n+                  && ((__it->second\n+                       & (ctype_base::lower | ctype_base::upper)) != 0))\n                 return ctype_base::alpha;\n               return __it->second;\n             }\n@@ -594,7 +596,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     {\n       typedef std::ctype<char_type> __ctype_type;\n       const __ctype_type& __fctyp(use_facet<__ctype_type>(_M_locale));\n-      \n+\n       return __fctyp.is(__f._M_base, __c)\n         // [[:w:]]\n         || ((__f._M_extended & _RegexMask::_S_under)\n@@ -662,9 +664,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n        * character sequence.\n        */\n       basic_regex()\n-      : _M_flags(ECMAScript),\n-        _M_automaton(__detail::__compile<const _Ch_type*, _Rx_traits>(0, 0,\n-                     _M_traits, _M_flags))\n+      : _M_flags(ECMAScript), _M_automaton(nullptr)\n       { }\n \n       /**\n@@ -680,9 +680,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n        */\n       explicit\n       basic_regex(const _Ch_type* __p, flag_type __f = ECMAScript)\n-      : _M_flags(__f),\n-        _M_automaton(__detail::__compile(__p, __p + _Rx_traits::length(__p),\n-        \t\t\t\t_M_traits, _M_flags))\n+      : basic_regex(__p, __p + _Rx_traits::length(__p), __f)\n       { }\n \n       /**\n@@ -697,20 +695,17 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n        *\n        * @throws regex_error if @p __p is not a valid regular expression.\n        */\n-      basic_regex(const _Ch_type* __p, std::size_t __len, flag_type __f)\n-      : _M_flags(__f),\n-        _M_automaton(__detail::__compile(__p, __p + __len, _M_traits, _M_flags))\n+      basic_regex(const _Ch_type* __p,\n+                  std::size_t __len, flag_type __f = ECMAScript)\n+      : basic_regex(__p, __p + __len, __f)\n       { }\n \n       /**\n        * @brief Copy-constructs a basic regular expression.\n        *\n        * @param __rhs A @p regex object.\n        */\n-      basic_regex(const basic_regex& __rhs)\n-      : _M_flags(__rhs._M_flags), _M_traits(__rhs._M_traits),\n-        _M_automaton(__rhs._M_automaton)\n-      { }\n+      basic_regex(const basic_regex& __rhs) = default;\n \n       /**\n        * @brief Move-constructs a basic regular expression.\n@@ -733,12 +728,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n        */\n       template<typename _Ch_traits, typename _Ch_alloc>\n         explicit\n-        basic_regex(const std::basic_string<_Ch_type, _Ch_traits, \n+        basic_regex(const std::basic_string<_Ch_type, _Ch_traits,\n \t\t\t\t\t    _Ch_alloc>& __s,\n \t\t    flag_type __f = ECMAScript)\n-\t: _M_flags(__f),\n-\t  _M_automaton(__detail::__compile(__s.begin(), __s.end(),\n-\t  \t\t\t\t  _M_traits, _M_flags))\n+\t: basic_regex(__s.begin(), __s.end(), __f)\n         { }\n \n       /**\n@@ -755,10 +748,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n        *         expression.\n        */\n       template<typename _InputIterator>\n-        basic_regex(_InputIterator __first, _InputIterator __last, \n+        basic_regex(_InputIterator __first, _InputIterator __last,\n \t\t    flag_type __f = ECMAScript)\n \t: _M_flags(__f),\n-\t  _M_automaton(__detail::__compile(__first, __last, _M_traits, _M_flags))\n+          _M_automaton(__detail::_Compiler<_InputIterator, _Ch_type, _Rx_traits>\n+                       (__first, __last, _M_traits, _M_flags)._M_get_nfa())\n         { }\n \n       /**\n@@ -771,17 +765,15 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n        */\n       basic_regex(initializer_list<_Ch_type> __l,\n \t\t  flag_type __f = ECMAScript)\n-      : _M_flags(__f),\n-        _M_automaton(__detail::__compile(__l.begin(), __l.end(),\n-        \t\t\t\t_M_traits, _M_flags))\n+      : basic_regex(__l.begin(), __l.end(), __f)\n       { }\n \n       /**\n        * @brief Destroys a basic regular expression.\n        */\n       ~basic_regex()\n       { }\n-      \n+\n       /**\n        * @brief Assigns one regular expression to another.\n        */\n@@ -806,7 +798,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       basic_regex&\n       operator=(const _Ch_type* __p)\n       { return this->assign(__p, flags()); }\n-      \n+\n       /**\n        * @brief Replaces a regular expression with a new one constructed from\n        * a string.\n@@ -831,7 +823,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \tthis->swap(__tmp);\n \treturn *this;\n       }\n-      \n+\n       /**\n        * @brief The move-assignment operator.\n        *\n@@ -880,7 +872,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       { return this->assign(string_type(__p, __len), __flags); }\n \n       /**\n-       * @brief Assigns a new regular expression to a regex object from a \n+       * @brief Assigns a new regular expression to a regex object from a\n        * string containing a regular expression pattern.\n        *\n        * @param __s     A string containing a regular expression pattern.\n@@ -894,7 +886,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n         basic_regex&\n         assign(const basic_string<_Ch_type, _Ch_typeraits, _Alloc>& __s,\n \t       flag_type __flags = ECMAScript)\n-        { \n+        {\n \t  basic_regex __tmp(__s, __flags);\n \t  this->swap(__tmp);\n \t  return *this;\n@@ -942,15 +934,15 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       unsigned int\n       mark_count() const\n       { return _M_automaton->_M_sub_count() - 1; }\n-      \n+\n       /**\n        * @brief Gets the flags used to construct the regular expression\n        * or in the last call to assign().\n        */\n       flag_type\n       flags() const\n       { return _M_flags; }\n-      \n+\n       // [7.8.5] locale\n       /**\n        * @brief Imbues the regular expression object with the given locale.\n@@ -960,15 +952,15 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       locale_type\n       imbue(locale_type __loc)\n       { return _M_traits.imbue(__loc); }\n-      \n+\n       /**\n        * @brief Gets the locale currently imbued in the regular expression\n        *        object.\n        */\n       locale_type\n       getloc() const\n       { return _M_traits.getloc(); }\n-      \n+\n       // [7.8.6] swap\n       /**\n        * @brief Swaps the contents of two regular expression objects.\n@@ -988,17 +980,40 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _M_dot(std::ostream& __ostr)\n       { _M_automaton->_M_dot(__ostr); }\n #endif\n-      \n-      const __detail::_AutomatonPtr&\n-      _M_get_automaton() const\n-      { return _M_automaton; }\n \n     protected:\n-      flag_type              _M_flags;\n-      _Rx_traits             _M_traits;\n-      __detail::_AutomatonPtr _M_automaton;\n+      typedef std::shared_ptr<__detail::_Automaton<_Ch_type, _Rx_traits>>\n+        _AutomatonPtr;\n+\n+      template<typename _BiIter, typename _Alloc,\n+        typename _CharT, typename _TraitsT>\n+        friend std::unique_ptr<\n+          __detail::_Executor<_BiIter, _Alloc, _CharT, _TraitsT>>\n+        __detail::__get_executor(_BiIter,\n+                                 _BiIter,\n+                                 match_results<_BiIter, _Alloc>&,\n+                                 const basic_regex<_CharT, _TraitsT>&,\n+                                 regex_constants::match_flag_type);\n+\n+      template<typename _B, typename _A, typename _C, typename _R>\n+        friend bool\n+        regex_match(_B, _B,\n+                    match_results<_B, _A>&,\n+                    const basic_regex<_C, _R>&,\n+                    regex_constants::match_flag_type);\n+\n+      template<typename _B, typename _A, typename _C, typename _R>\n+        friend bool\n+        regex_search(_B, _B,\n+                     match_results<_B, _A>&,\n+                     const basic_regex<_C, _R>&,\n+                     regex_constants::match_flag_type);\n+\n+      flag_type     _M_flags;\n+      _Rx_traits    _M_traits;\n+      _AutomatonPtr _M_automaton;\n     };\n-  \n+\n   /** @brief Standard regular expressions. */\n   typedef basic_regex<char>    regex;\n \n@@ -1046,7 +1061,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       typedef std::basic_string<value_type>             string_type;\n \n       bool matched;\n-      \n+\n       constexpr sub_match() : matched() { }\n \n       /**\n@@ -1072,7 +1087,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  ? string_type(this->first, this->second)\n \t  : string_type();\n       }\n-      \n+\n       /**\n        * @brief Gets the matching sequence as a string.\n        *\n@@ -1085,7 +1100,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  ? string_type(this->first, this->second)\n \t  : string_type();\n       }\n-      \n+\n       /**\n        * @brief Compares this and another matched sequence.\n        *\n@@ -1111,7 +1126,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       int\n       compare(const string_type& __s) const\n       { return this->str().compare(__s); }\n-      \n+\n       /**\n        * @brief Compares this sub_match to a C-style string.\n        *\n@@ -1125,8 +1140,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       compare(const value_type* __s) const\n       { return this->str().compare(__s); }\n     };\n-  \n-  \n+\n+\n   /** @brief Standard regex submatch over a C-style null-terminated string. */\n   typedef sub_match<const char*>             csub_match;\n \n@@ -1142,7 +1157,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n #endif\n \n   // [7.9.2] sub_match non-member operators\n-  \n+\n   /**\n    * @brief Tests the equivalence of two regular expression submatches.\n    * @param __lhs First regular expression submatch.\n@@ -1760,7 +1775,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       typedef std::basic_string<char_type>                 string_type;\n       //@}\n-  \n+\n     public:\n       /**\n        * @name 28.10.1 Construction, Copying, and Destruction\n@@ -1815,7 +1830,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n        */\n       ~match_results()\n       { }\n-      \n+\n       //@}\n \n       // 28.10.2, state:\n@@ -1846,7 +1861,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       \tsize_type __size = _Base_type::size();\n       \treturn (__size && _Base_type::operator[](0).matched) ? __size - 2 : 0;\n       }\n-      \n+\n       size_type\n       max_size() const\n       { return _Base_type::max_size(); }\n@@ -1859,7 +1874,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       bool\n       empty() const\n       { return size() == 0; }\n-      \n+\n       //@}\n \n       /**\n@@ -1911,7 +1926,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       string_type\n       str(size_type __sub = 0) const\n       { return (*this)[__sub].str(); }\n-      \n+\n       /**\n        * @brief Gets a %sub_match reference for the match or submatch.\n        * @param __sub indicates the submatch.\n@@ -1925,7 +1940,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n        */\n       const_reference\n       operator[](size_type __sub) const\n-      { \n+      {\n       \t_GLIBCXX_DEBUG_ASSERT( ready() );\n       \treturn __sub < size()\n \t       ?  _Base_type::operator[](__sub)\n@@ -1972,7 +1987,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       const_iterator\n       begin() const\n       { return _Base_type::begin(); }\n-      \n+\n       /**\n        * @brief Gets an iterator to the start of the %sub_match collection.\n        */\n@@ -1986,7 +2001,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       const_iterator\n       end() const\n       { return !empty() ? _Base_type::end() - 2 : _Base_type::end(); }\n-      \n+\n       /**\n        * @brief Gets an iterator to one-past-the-end of the collection.\n        */\n@@ -2047,48 +2062,70 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n        */\n       string_type\n       format(const char_type* __fmt,\n-\t     match_flag_type __flags = regex_constants::format_default) const\n+             match_flag_type __flags = regex_constants::format_default) const\n       {\n         string_type __result;\n         format(std::back_inserter(__result),\n+               __fmt,\n                __fmt + char_traits<char_type>::length(__fmt),\n                __flags);\n         return __result;\n       }\n \n-      //@} \n+      //@}\n \n       /**\n        * @name 10.5 Allocator\n        */\n-      //@{ \n+      //@{\n \n       /**\n        * @brief Gets a copy of the allocator.\n        */\n       allocator_type\n       get_allocator() const\n       { return _Base_type::get_allocator(); }\n-      \n-      //@} \n+\n+      //@}\n \n       /**\n        * @name 10.6 Swap\n        */\n-       //@{ \n+       //@{\n \n       /**\n        * @brief Swaps the contents of two match_results.\n        */\n       void\n       swap(match_results& __that)\n       { _Base_type::swap(__that); }\n-      //@} \n-      \n+      //@}\n+\n     private:\n-      friend class __detail::_SpecializedResults<_Bi_iter, _Alloc>;\n+      template<typename, typename, typename, typename>\n+        friend class __detail::_Executor;\n+\n+      template<typename, typename, typename, typename>\n+        friend class __detail::_DFSExecutor;\n+\n+      template<typename, typename, typename, typename>\n+        friend class __detail::_BFSExecutor;\n+\n+      template<typename _B, typename _A, typename _Ch_type, typename _Rx_traits>\n+        friend bool\n+        regex_match(_B, _B, match_results<_B, _A>&,\n+                    const basic_regex<_Ch_type,\n+                    _Rx_traits>&,\n+                    regex_constants::match_flag_type);\n+\n+      template<typename _B, typename _A, typename _Ch_type, typename _Rx_traits>\n+        friend bool\n+        regex_search(_B, _B, match_results<_B, _A>&,\n+                     const basic_regex<_Ch_type,\n+                     _Rx_traits>&,\n+                     regex_constants::match_flag_type);\n     };\n-  \n+\n   typedef match_results<const char*>             cmatch;\n   typedef match_results<string::const_iterator>  smatch;\n #ifdef _GLIBCXX_USE_WCHAR_T\n@@ -2179,11 +2216,22 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n                 regex_constants::match_flag_type         __flags\n                                = regex_constants::match_default)\n     {\n-      __detail::_AutomatonPtr __a = __re._M_get_automaton();\n-      __detail::_Automaton::_SizeT __sz = __a->_M_sub_count();\n-      __detail::_SpecializedCursor<_Bi_iter> __cs(__s, __e);\n-      __detail::_SpecializedResults<_Bi_iter, _Alloc> __r(__sz, __cs, __m);\n-      return __a->_M_get_matcher(__cs, __r, __a, __flags)->_M_match();\n+      if (__re._M_automaton == nullptr)\n+        return false;\n+      if (__detail::__get_executor(__s, __e, __m, __re, __flags)->_M_match())\n+        {\n+          for (auto __it : __m)\n+            if (!__it.matched)\n+              __it.first = __it.second = __e;\n+          __m.at(__m.size()).matched = false;\n+          __m.at(__m.size()).first = __s;\n+          __m.at(__m.size()).second = __s;\n+          __m.at(__m.size()+1).matched = false;\n+          __m.at(__m.size()+1).first = __e;\n+          __m.at(__m.size()+1).second = __e;\n+          return true;\n+        }\n+      return false;\n     }\n \n   /**\n@@ -2206,7 +2254,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\tconst basic_regex<_Ch_type, _Rx_traits>& __re,\n \t\tregex_constants::match_flag_type __flags\n \t\t= regex_constants::match_default)\n-    { \n+    {\n       match_results<_Bi_iter> __what;\n       return regex_match(__first, __last, __what, __re, __flags);\n     }\n@@ -2252,7 +2300,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t   typename _Alloc, typename _Ch_type, typename _Rx_traits>\n     inline bool\n     regex_match(const basic_string<_Ch_type, _Ch_traits, _Ch_alloc>& __s,\n-\t\tmatch_results<typename basic_string<_Ch_type, \n+\t\tmatch_results<typename basic_string<_Ch_type,\n \t\t_Ch_traits, _Ch_alloc>::const_iterator, _Alloc>& __m,\n \t\tconst basic_regex<_Ch_type, _Rx_traits>& __re,\n \t\tregex_constants::match_flag_type __flags\n@@ -2327,29 +2375,25 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n                  regex_constants::match_flag_type __flags\n                  = regex_constants::match_default)\n     {\n-      __detail::_AutomatonPtr __a = __re._M_get_automaton();\n-      __detail::_Automaton::_SizeT __sz = __a->_M_sub_count();\n-      __detail::_SpecializedCursor<_Bi_iter> __cs(__first, __last);\n-      __detail::_SpecializedResults<_Bi_iter, _Alloc> __r(__sz, __cs, __m);\n+      if (__re._M_automaton == nullptr)\n+        return false;\n       for (auto __cur = __first; __cur != __last; ++__cur) // Any KMP-like algo?\n-        {\n-          __detail::_SpecializedCursor<_Bi_iter> __curs(__cur, __last);\n-          auto __matcher = __a->_M_get_matcher(__curs, __r, __a, __flags);\n-          if (__matcher->_M_search_from_first())\n-            {\n-              __r._M_set_range(__m.size(),\n-                               __detail::_SpecializedCursor<_Bi_iter>\n-                                 {__first, __m[0].first});\n-              __r._M_set_range(__m.size()+1,\n-                               __detail::_SpecializedCursor<_Bi_iter>\n-                                 {__m[0].second, __last});\n-              __r._M_set_matched(__m.size(),\n-                                 __m.prefix().first != __m.prefix().second);\n-              __r._M_set_matched(__m.size()+1,\n-                                 __m.suffix().first != __m.suffix().second);\n-              return true;\n-            }\n-        }\n+        if (__detail::__get_executor(__cur, __last, __m, __re, __flags)\n+              ->_M_search_from_first())\n+          {\n+            for (auto __it : __m)\n+              if (!__it.matched)\n+                __it.first = __it.second = __last;\n+            __m.at(__m.size()).first = __first;\n+            __m.at(__m.size()).second = __m[0].first;\n+            __m.at(__m.size()+1).first = __m[0].second;\n+            __m.at(__m.size()+1).second = __last;\n+            __m.at(__m.size()).matched =\n+              (__m.prefix().first != __m.prefix().second);\n+            __m.at(__m.size()+1).matched =\n+              (__m.suffix().first != __m.suffix().second);\n+            return true;\n+          }\n       return false;\n     }\n \n@@ -2513,7 +2557,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   // std [28.12] Class template regex_iterator\n   /**\n-   * An iterator adaptor that will provide repeated calls of regex_search over \n+   * An iterator adaptor that will provide repeated calls of regex_search over\n    * a range until no more matches remain.\n    */\n   template<typename _Bi_iter,\n@@ -2536,7 +2580,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       regex_iterator()\n       : _M_match()\n       { }\n-      \n+\n       /**\n        * Constructs a %regex_iterator...\n        * @param __a  [IN] The start of a text range to search.\n@@ -2554,46 +2598,46 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n        * Copy constructs a %regex_iterator.\n        */\n       regex_iterator(const regex_iterator& __rhs) = default;\n-      \n+\n       /**\n        * @brief Assigns one %regex_iterator to another.\n        */\n       regex_iterator&\n       operator=(const regex_iterator& __rhs) = default;\n-      \n+\n       /**\n        * @brief Tests the equivalence of two regex iterators.\n        */\n       bool\n       operator==(const regex_iterator& __rhs) const;\n-      \n+\n       /**\n        * @brief Tests the inequivalence of two regex iterators.\n        */\n       bool\n       operator!=(const regex_iterator& __rhs) const\n       { return !(*this == __rhs); }\n-      \n+\n       /**\n        * @brief Dereferences a %regex_iterator.\n        */\n       const value_type&\n       operator*() const\n       { return _M_match; }\n-      \n+\n       /**\n        * @brief Selects a %regex_iterator member.\n        */\n       const value_type*\n       operator->() const\n       { return &_M_match; }\n-      \n+\n       /**\n        * @brief Increments a %regex_iterator.\n        */\n       regex_iterator&\n       operator++();\n-      \n+\n       /**\n        * @brief Postincrements a %regex_iterator.\n        */\n@@ -2604,7 +2648,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n         ++(*this);\n         return __tmp;\n       }\n-      \n+\n     private:\n       _Bi_iter                         _M_begin;\n       _Bi_iter                         _M_end;\n@@ -2665,7 +2709,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n         }\n       return *this;\n     }\n-  \n+\n   typedef regex_iterator<const char*>             cregex_iterator;\n   typedef regex_iterator<string::const_iterator>  sregex_iterator;\n #ifdef _GLIBCXX_USE_WCHAR_T\n@@ -2693,19 +2737,19 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       typedef const value_type*                 pointer;\n       typedef const value_type&                 reference;\n       typedef std::forward_iterator_tag         iterator_category;\n-      \n+\n     public:\n       /**\n        * @brief Default constructs a %regex_token_iterator.\n-       * \n+       *\n        * A default-constructed %regex_token_iterator is a singular iterator\n        * that will compare equal to the one-past-the-end value for any\n        * iterator of the same type.\n        */\n       regex_token_iterator()\n       : _M_position(), _M_result(nullptr), _M_suffix(), _M_n(0), _M_subs()\n       { }\n-      \n+\n       /**\n        * Constructs a %regex_token_iterator...\n        * @param __a          [IN] The start of the text to search.\n@@ -2987,7 +3031,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   /** @brief Token iterator for standard wide-character strings. */\n   typedef regex_token_iterator<wstring::const_iterator> wsregex_token_iterator;\n #endif\n-  \n+\n   //@} // group regex\n _GLIBCXX_END_NAMESPACE_VERSION\n } // namespace"}, {"sha": "5817156aadf3b4bba3264112b0616e9984ea8479", "filename": "libstdc++-v3/include/bits/regex_automaton.h", "status": "added", "additions": 274, "deletions": 0, "changes": 274, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cb784b639c3de7505674b56f542c8b714d7df8a/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_automaton.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cb784b639c3de7505674b56f542c8b714d7df8a/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_automaton.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_automaton.h?ref=6cb784b639c3de7505674b56f542c8b714d7df8a", "patch": "@@ -0,0 +1,274 @@\n+// class template regex -*- C++ -*-\n+\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/**\n+ *  @file bits/regex_automaton.h\n+ *  This is an internal header file, included by other library headers.\n+ *  Do not attempt to use it directly. @headername{regex}\n+ */\n+\n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+namespace __detail\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+  /**\n+   *  @defgroup regex-detail Base and Implementation Classes\n+   *  @ingroup regex\n+   *  @{\n+   */\n+\n+  typedef int _StateIdT;\n+  typedef std::set<_StateIdT> _StateSet;\n+  static const _StateIdT _S_invalid_state_id  = -1;\n+\n+  template<typename _CharT>\n+    using _Matcher = std::function<bool (_CharT)>;\n+\n+  /// Operation codes that define the type of transitions within the base NFA\n+  /// that represents the regular expression.\n+  enum _Opcode\n+  {\n+      _S_opcode_unknown       =   0,\n+      _S_opcode_alternative   =   1,\n+      _S_opcode_subexpr_begin =   4,\n+      _S_opcode_subexpr_end   =   5,\n+      _S_opcode_match         = 100,\n+      _S_opcode_accept        = 255\n+  };\n+\n+  template<typename _CharT, typename _TraitsT>\n+    class _State\n+    {\n+    public:\n+      typedef int                        _OpcodeT;\n+      typedef _Matcher<_CharT>           _MatcherT;\n+\n+      _OpcodeT     _M_opcode;    // type of outgoing transition\n+      _StateIdT    _M_next;      // outgoing transition\n+      _StateIdT    _M_alt;       // for _S_opcode_alternative\n+      unsigned int _M_subexpr;   // for _S_opcode_subexpr_*\n+      _MatcherT    _M_matches;   // for _S_opcode_match\n+\n+      explicit _State(_OpcodeT __opcode)\n+      : _M_opcode(__opcode), _M_next(_S_invalid_state_id)\n+      { }\n+\n+      _State(const _MatcherT& __m)\n+      : _M_opcode(_S_opcode_match), _M_next(_S_invalid_state_id),\n+        _M_matches(__m)\n+      { }\n+\n+      _State(_OpcodeT __opcode, unsigned __index)\n+      : _M_opcode(__opcode), _M_next(_S_invalid_state_id), _M_subexpr(__index)\n+      { }\n+\n+      _State(_StateIdT __next, _StateIdT __alt)\n+      : _M_opcode(_S_opcode_alternative), _M_next(__next), _M_alt(__alt)\n+      { }\n+\n+#ifdef _GLIBCXX_DEBUG\n+      std::ostream&\n+      _M_print(std::ostream& ostr) const;\n+\n+      // Prints graphviz dot commands for state.\n+      std::ostream&\n+      _M_dot(std::ostream& __ostr, _StateIdT __id) const;\n+#endif\n+    };\n+\n+  /// Base class for, um, automata.  Could be an NFA or a DFA.  Your choice.\n+  template<typename _CharT, typename _TraitsT>\n+    class _Automaton\n+    {\n+    public:\n+      typedef unsigned int _SizeT;\n+\n+    public:\n+      virtual _SizeT\n+      _M_sub_count() const = 0;\n+\n+#ifdef _GLIBCXX_DEBUG\n+      virtual std::ostream&\n+      _M_dot(std::ostream& __ostr) const = 0;\n+#endif\n+    };\n+\n+  template<typename _CharT, typename _TraitsT>\n+    class _NFA\n+    : public _Automaton<_CharT, _TraitsT>,\n+      public std::vector<_State<_CharT, _TraitsT>>\n+    {\n+    public:\n+      typedef _State<_CharT, _TraitsT>            _StateT;\n+      typedef const _Matcher<_CharT>&             _MatcherT;\n+      typedef unsigned int                        _SizeT;\n+      typedef regex_constants::syntax_option_type _FlagT;\n+\n+      _NFA(_FlagT __f)\n+      : _M_flags(__f), _M_start_state(0), _M_subexpr_count(0),\n+      _M_has_backref(false)\n+      { }\n+\n+      _FlagT\n+      _M_options() const\n+      { return _M_flags; }\n+\n+      _StateIdT\n+      _M_start() const\n+      { return _M_start_state; }\n+\n+      const _StateSet&\n+      _M_final_states() const\n+      { return _M_accepting_states; }\n+\n+      _SizeT\n+      _M_sub_count() const\n+      { return _M_subexpr_count; }\n+\n+      _StateIdT\n+      _M_insert_accept()\n+      {\n+        this->push_back(_StateT(_S_opcode_accept));\n+        _M_accepting_states.insert(this->size()-1);\n+        return this->size()-1;\n+      }\n+\n+      _StateIdT\n+      _M_insert_alt(_StateIdT __next, _StateIdT __alt)\n+      {\n+        this->push_back(_StateT(__next, __alt));\n+        return this->size()-1;\n+      }\n+\n+      _StateIdT\n+      _M_insert_matcher(_MatcherT __m)\n+      {\n+        this->push_back(_StateT(__m));\n+        return this->size()-1;\n+      }\n+\n+      _StateIdT\n+      _M_insert_subexpr_begin()\n+      {\n+        auto __id = _M_subexpr_count++;\n+        _M_paren_stack.push(__id);\n+        this->push_back(_StateT(_S_opcode_subexpr_begin, __id));\n+        return this->size()-1;\n+      }\n+\n+      _StateIdT\n+      _M_insert_subexpr_end()\n+      {\n+        this->push_back(_StateT(_S_opcode_subexpr_end, _M_paren_stack.top()));\n+        _M_paren_stack.pop();\n+        return this->size()-1;\n+      }\n+\n+      void\n+      _M_set_backref(bool __b)\n+      { _M_has_backref = __b; }\n+\n+#ifdef _GLIBCXX_DEBUG\n+      std::ostream&\n+      _M_dot(std::ostream& __ostr) const;\n+#endif\n+\n+      _FlagT                   _M_flags;\n+      _StateIdT                _M_start_state;\n+      _StateSet                _M_accepting_states;\n+      _SizeT                   _M_subexpr_count;\n+      bool                     _M_has_backref;\n+      std::stack<unsigned int> _M_paren_stack;\n+    };\n+\n+  /// Describes a sequence of one or more %_State, its current start\n+  /// and end(s).  This structure contains fragments of an NFA during\n+  /// construction.\n+  template<typename _CharT, typename _TraitsT>\n+    class _StateSeq\n+    {\n+    public:\n+      typedef _NFA<_CharT, _TraitsT> _RegexT;\n+    public:\n+      // Constructs a single-node sequence\n+      _StateSeq(_RegexT& __ss, _StateIdT __s,\n+                _StateIdT __e = _S_invalid_state_id)\n+      : _M_nfa(__ss), _M_start(__s), _M_end1(__s), _M_end2(__e)\n+      { }\n+      // Constructs a split sequence from two other sequencces\n+      _StateSeq(const _StateSeq& __e1, const _StateSeq& __e2)\n+      : _M_nfa(__e1._M_nfa),\n+        _M_start(_M_nfa._M_insert_alt(__e1._M_start, __e2._M_start)),\n+        _M_end1(__e1._M_end1), _M_end2(__e2._M_end1)\n+      { }\n+\n+      // Constructs a split sequence from a single sequence\n+      _StateSeq(const _StateSeq& __e, _StateIdT __id)\n+      : _M_nfa(__e._M_nfa),\n+        _M_start(_M_nfa._M_insert_alt(__id, __e._M_start)),\n+        _M_end1(__id), _M_end2(__e._M_end1)\n+      { }\n+\n+      // Constructs a copy of a %_StateSeq\n+      _StateSeq(const _StateSeq& __rhs)\n+      : _M_nfa(__rhs._M_nfa), _M_start(__rhs._M_start),\n+        _M_end1(__rhs._M_end1), _M_end2(__rhs._M_end2)\n+      { }\n+\n+      _StateSeq& operator=(const _StateSeq& __rhs);\n+\n+      _StateIdT\n+      _M_front() const\n+      { return _M_start; }\n+\n+      // Extends a sequence by one.\n+      void\n+      _M_push_back(_StateIdT __id);\n+\n+      // Extends and maybe joins a sequence.\n+      void\n+      _M_append(_StateIdT __id);\n+\n+      void\n+      _M_append(_StateSeq& __rhs);\n+\n+      // Clones an entire sequence.\n+      _StateIdT\n+      _M_clone();\n+\n+    private:\n+      _RegexT&  _M_nfa;\n+      _StateIdT _M_start;\n+      _StateIdT _M_end1;\n+      _StateIdT _M_end2;\n+    };\n+\n+ //@} regex-detail\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace __detail\n+} // namespace std\n+\n+#include <bits/regex_automaton.tcc>"}, {"sha": "cf9c8eb31478878711c683f43b97b91b7e3bcd9f", "filename": "libstdc++-v3/include/bits/regex_automaton.tcc", "status": "added", "additions": 181, "deletions": 0, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cb784b639c3de7505674b56f542c8b714d7df8a/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_automaton.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cb784b639c3de7505674b56f542c8b714d7df8a/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_automaton.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_automaton.tcc?ref=6cb784b639c3de7505674b56f542c8b714d7df8a", "patch": "@@ -0,0 +1,181 @@\n+// class template regex -*- C++ -*-\n+\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/**\n+ *  @file bits/regex_automaton.tcc\n+ *  This is an internal header file, included by other library headers.\n+ *  Do not attempt to use it directly. @headername{regex}\n+ */\n+\n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+namespace __detail\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+#ifdef _GLIBCXX_DEBUG\n+  template<typename _CharT, typename _TraitsT>\n+    std::ostream& _State<_CharT, _TraitsT>::\n+    _M_print(std::ostream& ostr) const\n+    {\n+      switch (_M_opcode)\n+      {\n+        case _S_opcode_alternative:\n+          ostr << \"alt next=\" << _M_next << \" alt=\" << _M_alt;\n+          break;\n+        case _S_opcode_subexpr_begin:\n+          ostr << \"subexpr begin next=\" << _M_next << \" index=\" << _M_subexpr;\n+          break;\n+        case _S_opcode_subexpr_end:\n+          ostr << \"subexpr end next=\" << _M_next << \" index=\" << _M_subexpr;\n+          break;\n+        case _S_opcode_match:\n+          ostr << \"match next=\" << _M_next;\n+          break;\n+        case _S_opcode_accept:\n+          ostr << \"accept next=\" << _M_next;\n+          break;\n+        default:\n+          ostr << \"unknown next=\" << _M_next;\n+          break;\n+      }\n+      return ostr;\n+    }\n+\n+  // Prints graphviz dot commands for state.\n+  template<typename _CharT, typename _TraitsT>\n+    std::ostream& _State<_CharT, _TraitsT>::\n+    _M_dot(std::ostream& __ostr, _StateIdT __id) const\n+    {\n+      switch (_M_opcode)\n+      {\n+        case _S_opcode_alternative:\n+          __ostr << __id << \" [label=\\\"\" << __id << \"\\\\nALT\\\"];\\n\"\n+                 << __id << \" -> \" << _M_next\n+                 << \" [label=\\\"epsilon\\\", tailport=\\\"s\\\"];\\n\"\n+                 << __id << \" -> \" << _M_alt\n+                 << \" [label=\\\"epsilon\\\", tailport=\\\"n\\\"];\\n\";\n+          break;\n+        case _S_opcode_subexpr_begin:\n+          __ostr << __id << \" [label=\\\"\" << __id << \"\\\\nSBEGIN \"\n+                 << _M_subexpr << \"\\\"];\\n\"\n+                 << __id << \" -> \" << _M_next << \" [label=\\\"epsilon\\\"];\\n\";\n+          break;\n+        case _S_opcode_subexpr_end:\n+          __ostr << __id << \" [label=\\\"\" << __id << \"\\\\nSEND \"\n+                 << _M_subexpr << \"\\\"];\\n\"\n+                 << __id << \" -> \" << _M_next << \" [label=\\\"epsilon\\\"];\\n\";\n+          break;\n+        case _S_opcode_match:\n+          __ostr << __id << \" [label=\\\"\" << __id << \"\\\\nMATCH\\\"];\\n\"\n+                 << __id << \" -> \" << _M_next << \" [label=\\\"<match>\\\"];\\n\";\n+          break;\n+        case _S_opcode_accept:\n+          __ostr << __id << \" [label=\\\"\" << __id << \"\\\\nACC\\\"];\\n\" ;\n+          break;\n+        default:\n+          __ostr << __id << \" [label=\\\"\" << __id << \"\\\\nUNK\\\"];\\n\"\n+                 << __id << \" -> \" << _M_next << \" [label=\\\"?\\\"];\\n\";\n+          break;\n+      }\n+      return __ostr;\n+    }\n+\n+  template<typename _CharT, typename _TraitsT>\n+    std::ostream& _NFA<_CharT, _TraitsT>::\n+    _M_dot(std::ostream& __ostr) const\n+    {\n+      __ostr << \"digraph _Nfa {\\n\"\n+       << \"  rankdir=LR;\\n\";\n+      for (unsigned int __i = 0; __i < this->size(); ++__i)\n+      { this->at(__i)._M_dot(__ostr, __i); }\n+      __ostr << \"}\\n\";\n+      return __ostr;\n+    }\n+#endif\n+\n+  template<typename _CharT, typename _TraitsT>\n+    _StateSeq<_CharT, _TraitsT>& _StateSeq<_CharT, _TraitsT>::\n+    operator=(const _StateSeq& __rhs)\n+    {\n+      _M_start = __rhs._M_start;\n+      _M_end1  = __rhs._M_end1;\n+      _M_end2  = __rhs._M_end2;\n+      return *this;\n+    }\n+\n+  template<typename _CharT, typename _TraitsT>\n+    void _StateSeq<_CharT, _TraitsT>::\n+    _M_push_back(_StateIdT __id)\n+    {\n+      if (_M_end1 != _S_invalid_state_id)\n+        _M_nfa[_M_end1]._M_next = __id;\n+      _M_end1 = __id;\n+    }\n+\n+  template<typename _CharT, typename _TraitsT>\n+    void _StateSeq<_CharT, _TraitsT>::\n+    _M_append(_StateIdT __id)\n+    {\n+      if (_M_end2 != _S_invalid_state_id)\n+      {\n+        if (_M_end2 == _M_end1)\n+          _M_nfa[_M_end2]._M_alt = __id;\n+        else\n+          _M_nfa[_M_end2]._M_next = __id;\n+        _M_end2 = _S_invalid_state_id;\n+      }\n+      if (_M_end1 != _S_invalid_state_id)\n+        _M_nfa[_M_end1]._M_next = __id;\n+      _M_end1 = __id;\n+    }\n+\n+  template<typename _CharT, typename _TraitsT>\n+    void _StateSeq<_CharT, _TraitsT>::\n+    _M_append(_StateSeq& __rhs)\n+    {\n+      if (_M_end2 != _S_invalid_state_id)\n+      {\n+        if (_M_end2 == _M_end1)\n+          _M_nfa[_M_end2]._M_alt = __rhs._M_start;\n+        else\n+          _M_nfa[_M_end2]._M_next = __rhs._M_start;\n+        _M_end2 = _S_invalid_state_id;\n+      }\n+      if (__rhs._M_end2 != _S_invalid_state_id)\n+        _M_end2 = __rhs._M_end2;\n+      if (_M_end1 != _S_invalid_state_id)\n+        _M_nfa[_M_end1]._M_next = __rhs._M_start;\n+      _M_end1 = __rhs._M_end1;\n+    }\n+\n+  // @todo implement this function.\n+  template<typename _CharT, typename _TraitsT>\n+    _StateIdT _StateSeq<_CharT, _TraitsT>::\n+    _M_clone()\n+    { return 0; }\n+\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace __detail\n+} // namespace"}, {"sha": "93147999528307d65d4e877d07e3c1c48cf4843f", "filename": "libstdc++-v3/include/bits/regex_compiler.h", "status": "modified", "additions": 113, "deletions": 858, "changes": 971, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cb784b639c3de7505674b56f542c8b714d7df8a/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_compiler.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cb784b639c3de7505674b56f542c8b714d7df8a/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_compiler.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_compiler.h?ref=6cb784b639c3de7505674b56f542c8b714d7df8a", "patch": "@@ -39,16 +39,89 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n    * @{\n    */\n \n-  /// Base class for scanner.\n-  struct _Scanner_base\n-  {\n-    typedef unsigned int _StateT;\n+  /// Matches a character range (bracket expression)\n+  template<typename _CharT, typename _TraitsT>\n+    struct _BracketMatcher\n+    {\n+      typedef typename _TraitsT::char_class_type  _CharClassT;\n+      typedef typename _TraitsT::string_type      _StringT;\n+      typedef regex_constants::syntax_option_type _FlagT;\n+\n+      explicit\n+      _BracketMatcher(bool __is_non_matching,\n+                      const _TraitsT& __t,\n+                      _FlagT __flags)\n+      : _M_is_non_matching(__is_non_matching), _M_traits(__t),\n+        _M_flags(__flags), _M_class_set(0)\n+      { }\n+\n+      bool\n+      operator()(_CharT) const;\n+\n+      void\n+      _M_add_char(_CharT __c)\n+      {\n+        if (_M_flags & regex_constants::collate)\n+          if (_M_is_icase())\n+            _M_char_set.push_back(_M_traits.translate_nocase(__c));\n+          else\n+            _M_char_set.push_back(_M_traits.translate(__c));\n+        else\n+          _M_char_set.push_back(__c);\n+      }\n+\n+      void\n+      _M_add_collating_element(const _StringT& __s)\n+      {\n+        auto __st = _M_traits.lookup_collatename(&*__s.begin(), &*__s.end());\n+        if (__st.empty())\n+          __throw_regex_error(regex_constants::error_collate);\n+        // TODO: digraph\n+        _M_char_set.push_back(__st[0]);\n+      }\n \n-    static constexpr _StateT _S_state_in_brace    = 1 << 0;\n-    static constexpr _StateT _S_state_in_bracket  = 1 << 1;\n+      void\n+      _M_add_equivalence_class(const _StringT& __s)\n+      {\n+        _M_add_character_class(\n+          _M_traits.transform_primary(&*__s.begin(), &*__s.end()));\n+      }\n \n-    virtual ~_Scanner_base() { };\n-  };\n+      void\n+      _M_add_character_class(const _StringT& __s)\n+      {\n+        auto __st = _M_traits.\n+          lookup_classname(&*__s.begin(), &*__s.end(), _M_is_icase());\n+        if (__st == 0)\n+          __throw_regex_error(regex_constants::error_ctype);\n+        _M_class_set |= __st;\n+      }\n+\n+      void\n+      _M_make_range(_CharT __l, _CharT __r)\n+      { _M_range_set.push_back(make_pair(_M_get_str(__l), _M_get_str(__r))); }\n+\n+      bool\n+      _M_is_icase() const\n+      { return _M_flags & regex_constants::icase; }\n+\n+      _StringT\n+      _M_get_str(_CharT __c) const\n+      {\n+        auto __s = _StringT(1,\n+                            _M_is_icase()\n+                            ? _M_traits.translate_nocase(__c)\n+                            : _M_traits.translate(__c));\n+        return _M_traits.transform(__s.begin(), __s.end());\n+      }\n+\n+      _TraitsT                              _M_traits;\n+      _FlagT                                _M_flags;\n+      bool                                  _M_is_non_matching;\n+      std::vector<_CharT>                   _M_char_set;\n+      std::vector<pair<_StringT, _StringT>> _M_range_set;\n+      _CharClassT                           _M_class_set;\n+    };\n \n   /**\n    * @brief struct _Scanner. Scans an input range for regex tokens.\n@@ -60,12 +133,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n    * constructor: different regular expression grammars will interpret\n    * the same input pattern in syntactically different ways.\n    */\n-  template<typename _InputIterator>\n-    class _Scanner: public _Scanner_base\n+  template<typename _InputIter>\n+    class _Scanner\n     {\n     public:\n-      typedef _InputIterator                                        _IteratorT;\n-      typedef typename std::iterator_traits<_IteratorT>::value_type _CharT;\n+      typedef unsigned int                                          _StateT;\n+      typedef typename std::iterator_traits<_InputIter>::value_type _CharT;\n       typedef std::basic_string<_CharT>                             _StringT;\n       typedef regex_constants::syntax_option_type                   _FlagT;\n       typedef const std::ctype<_CharT>                              _CtypeT;\n@@ -103,8 +176,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t_S_token_unknown\n       };\n \n-      _Scanner(_IteratorT __begin, _IteratorT __end, _FlagT __flags,\n-\t       std::locale __loc)\n+      _Scanner(_InputIter __begin, _InputIter __end,\n+               _FlagT __flags, std::locale __loc)\n       : _M_current(__begin) , _M_end(__end) , _M_flags(__flags),\n         _M_ctype(std::use_facet<_CtypeT>(__loc)), _M_state(0)\n       { _M_advance(); }\n@@ -144,529 +217,39 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       void\n       _M_eat_collsymbol();\n \n-      _IteratorT  _M_current;\n-      _IteratorT  _M_end;\n+      static constexpr _StateT _S_state_in_brace    = 1 << 0;\n+      static constexpr _StateT _S_state_in_bracket  = 1 << 1;\n+      _InputIter  _M_current;\n+      _InputIter  _M_end;\n       _FlagT      _M_flags;\n       _CtypeT&    _M_ctype;\n       _TokenT     _M_curToken;\n       _StringT    _M_curValue;\n       _StateT     _M_state;\n     };\n \n-  template<typename _InputIterator>\n-    void\n-    _Scanner<_InputIterator>::\n-    _M_advance()\n-    {\n-      if (_M_current == _M_end)\n-\t{\n-\t  _M_curToken = _S_token_eof;\n-\t  return;\n-\t}\n-\n-      _CharT __c = *_M_current;\n-      if (_M_state & _S_state_in_bracket)\n-\t{\n-\t  _M_scan_in_bracket();\n-\t  return;\n-\t}\n-      if (_M_state & _S_state_in_brace)\n-\t{\n-\t  _M_scan_in_brace();\n-\t  return;\n-\t}\n-#if 0\n-      // TODO: re-enable line anchors when _M_assertion is implemented.\n-      // See PR libstdc++/47724\n-      else if (_M_state & _S_state_at_start && __c == _M_ctype.widen('^'))\n-\t{\n-\t  _M_curToken = _S_token_line_begin;\n-\t  ++_M_current;\n-\t  return;\n-\t}\n-      else if (__c == _M_ctype.widen('$'))\n-\t{\n-\t  _M_curToken = _S_token_line_end;\n-\t  ++_M_current;\n-\t  return;\n-\t}\n-#endif\n-      else if (__c == _M_ctype.widen('.'))\n-\t{\n-\t  _M_curToken = _S_token_anychar;\n-\t  ++_M_current;\n-\t  return;\n-\t}\n-      else if (__c == _M_ctype.widen('*'))\n-\t{\n-\t  _M_curToken = _S_token_closure0;\n-\t  ++_M_current;\n-\t  return;\n-\t}\n-      else if (__c == _M_ctype.widen('+'))\n-\t{\n-\t  _M_curToken = _S_token_closure1;\n-\t  ++_M_current;\n-\t  return;\n-\t}\n-      else if (__c == _M_ctype.widen('|'))\n-\t{\n-\t  _M_curToken = _S_token_or;\n-\t  ++_M_current;\n-\t  return;\n-\t}\n-      else if (__c == _M_ctype.widen('['))\n-\t{\n-          if (*++_M_current == _M_ctype.widen('^'))\n-            {\n-              _M_curToken = _S_token_bracket_inverse_begin;\n-              ++_M_current;\n-            }\n-          else\n-            _M_curToken = _S_token_bracket_begin;\n-\t  _M_state |= _S_state_in_bracket;\n-\t  return;\n-\t}\n-      else if (__c == _M_ctype.widen('\\\\'))\n-\t{\n-\t  _M_eat_escape();\n-\t  return;\n-\t}\n-      else if (!(_M_flags & (regex_constants::basic | regex_constants::grep)))\n-\t{\n-\t  if (__c == _M_ctype.widen('('))\n-\t    {\n-\t      _M_curToken = _S_token_subexpr_begin;\n-\t      ++_M_current;\n-\t      return;\n-\t    }\n-\t  else if (__c == _M_ctype.widen(')'))\n-\t    {\n-\t      _M_curToken = _S_token_subexpr_end;\n-\t      ++_M_current;\n-\t      return;\n-\t    }\n-\t  else if (__c == _M_ctype.widen('{'))\n-\t    {\n-\t      _M_curToken = _S_token_interval_begin;\n-\t      _M_state |= _S_state_in_brace;\n-\t      ++_M_current;\n-\t      return;\n-\t    }\n-\t}\n-\n-      _M_curToken = _S_token_ord_char;\n-      _M_curValue.assign(1, __c);\n-      ++_M_current;\n-    }\n-\n-\n-  template<typename _InputIterator>\n-    void\n-    _Scanner<_InputIterator>::\n-    _M_scan_in_brace()\n-    {\n-      if (_M_ctype.is(_CtypeT::digit, *_M_current))\n-\t{\n-\t  _M_curToken = _S_token_dup_count;\n-\t  _M_curValue.assign(1, *_M_current);\n-\t  ++_M_current;\n-\t  while (_M_current != _M_end\n-\t\t && _M_ctype.is(_CtypeT::digit, *_M_current))\n-\t    {\n-\t      _M_curValue += *_M_current;\n-\t      ++_M_current;\n-\t    }\n-\t  return;\n-\t}\n-      else if (*_M_current == _M_ctype.widen(','))\n-\t{\n-\t  _M_curToken = _S_token_comma;\n-\t  ++_M_current;\n-\t  return;\n-\t}\n-      if (_M_flags & (regex_constants::basic | regex_constants::grep))\n-\t{\n-\t  if (*_M_current == _M_ctype.widen('\\\\'))\n-\t    _M_eat_escape();\n-\t}\n-      else \n-\t{\n-\t  if (*_M_current == _M_ctype.widen('}'))\n-\t    {\n-\t      _M_curToken = _S_token_interval_end;\n-\t      _M_state &= ~_S_state_in_brace;\n-\t      ++_M_current;\n-\t      return;\n-\t    }\n-\t}\n-    }\n-\n-  template<typename _InputIterator>\n-    void\n-    _Scanner<_InputIterator>::\n-    _M_scan_in_bracket()\n-    {\n-      if (*_M_current == _M_ctype.widen('['))\n-\t{\n-\t  ++_M_current;\n-\t  if (_M_current == _M_end)\n-\t    {\n-\t      _M_curToken = _S_token_eof;\n-\t      return;\n-\t    }\n-\n-\t  if (*_M_current == _M_ctype.widen('.'))\n-\t    {\n-\t      _M_curToken = _S_token_collsymbol;\n-\t      _M_eat_collsymbol();\n-\t      return;\n-\t    }\n-\t  else if (*_M_current == _M_ctype.widen(':'))\n-\t    {\n-\t      _M_curToken = _S_token_char_class_name;\n-\t      _M_eat_charclass();\n-\t      return;\n-\t    }\n-\t  else if (*_M_current == _M_ctype.widen('='))\n-\t    {\n-\t      _M_curToken = _S_token_equiv_class_name;\n-\t      _M_eat_equivclass();\n-\t      return;\n-\t    }\n-\t}\n-      else if (*_M_current == _M_ctype.widen('-'))\n-\t{\n-\t  _M_curToken = _S_token_dash;\n-\t  ++_M_current;\n-\t  return;\n-\t}\n-      else if (*_M_current == _M_ctype.widen(']'))\n-\t{\n-          _M_curToken = _S_token_bracket_end;\n-          _M_state &= ~_S_state_in_bracket;\n-          ++_M_current;\n-          return;\n-\t}\n-      else if (*_M_current == _M_ctype.widen('\\\\'))\n-        {\n-\t  _M_eat_escape();\n-\t  return;\n-        }\n-      _M_curToken = _S_token_collelem_single;\n-      _M_curValue.assign(1, *_M_current);\n-      ++_M_current;\n-    }\n-\n-  // TODO implement it.\n-  template<typename _InputIterator>\n-    void\n-    _Scanner<_InputIterator>::\n-    _M_eat_escape()\n-    {\n-      ++_M_current;\n-      if (_M_current == _M_end)\n-\t{\n-\t  _M_curToken = _S_token_eof;\n-\t  return;\n-\t}\n-      _CharT __c = *_M_current;\n-      ++_M_current;\n-\n-      if (__c == _M_ctype.widen('('))\n-\t{\n-\t  if (!(_M_flags & (regex_constants::basic | regex_constants::grep)))\n-\t    {\n-\t      _M_curToken = _S_token_ord_char;\n-\t      _M_curValue.assign(1, __c);\n-\t    }\n-\t  else\n-\t    _M_curToken = _S_token_subexpr_begin;\n-\t}\n-      else if (__c == _M_ctype.widen(')'))\n-\t{\n-\t  if (!(_M_flags & (regex_constants::basic | regex_constants::grep)))\n-\t    {\n-\t      _M_curToken = _S_token_ord_char;\n-\t      _M_curValue.assign(1, __c);\n-\t    }\n-\t  else\n-\t    _M_curToken = _S_token_subexpr_end;\n-\t}\n-      else if (__c == _M_ctype.widen('{'))\n-\t{\n-\t  if (!(_M_flags & (regex_constants::basic | regex_constants::grep)))\n-\t    {\n-\t      _M_curToken = _S_token_ord_char;\n-\t      _M_curValue.assign(1, __c);\n-\t    }\n-\t  else\n-\t    {\n-\t      _M_curToken = _S_token_interval_begin;\n-\t      _M_state |= _S_state_in_brace;\n-\t    }\n-\t}\n-      else if (__c == _M_ctype.widen('}'))\n-\t{\n-\t  if (!(_M_flags & (regex_constants::basic | regex_constants::grep)))\n-\t    {\n-\t      _M_curToken = _S_token_ord_char;\n-\t      _M_curValue.assign(1, __c);\n-\t    }\n-\t  else\n-\t    {\n-\t      if (!(_M_state && _S_state_in_brace))\n-\t\t__throw_regex_error(regex_constants::error_badbrace);\n-\t      _M_state &= ~_S_state_in_brace;\n-\t      _M_curToken = _S_token_interval_end;\n-\t    }\n-\t}\n-      else if (__c == _M_ctype.widen('x'))\n-\t{\n-\t  ++_M_current;\n-\t  if (_M_current == _M_end)\n-\t    {\n-\t      _M_curToken = _S_token_eof;\n-\t      return;\n-\t    }\n-\t  if (_M_ctype.is(_CtypeT::digit, *_M_current))\n-\t    {\n-\t      _M_curValue.assign(1, *_M_current);\n-\t      ++_M_current;\n-\t      if (_M_current == _M_end)\n-\t\t{\n-\t\t  _M_curToken = _S_token_eof;\n-\t\t  return;\n-\t\t}\n-\t      if (_M_ctype.is(_CtypeT::digit, *_M_current))\n-\t\t{\n-\t\t  _M_curValue += *_M_current;\n-\t\t  ++_M_current;\n-\t\t  return;\n-\t\t}\n-\t    }\n-\t}\n-      else if (__c == _M_ctype.widen('^')\n-\t       || __c == _M_ctype.widen('.')\n-\t       || __c == _M_ctype.widen('*')\n-\t       || __c == _M_ctype.widen('$')\n-\t       || __c == _M_ctype.widen('\\\\'))\n-\t{\n-\t  _M_curToken = _S_token_ord_char;\n-\t  _M_curValue.assign(1, __c);\n-\t}\n-      else if (_M_ctype.is(_CtypeT::digit, __c))\n-\t{\n-\t  _M_curToken = _S_token_backref;\n-\t  _M_curValue.assign(1, __c);\n-\t}\n-      else if (_M_state & _S_state_in_bracket)\n-        {\n-          if (__c == _M_ctype.widen('-')\n-              || __c == _M_ctype.widen('[')\n-              || __c == _M_ctype.widen(']'))\n-            {\n-              _M_curToken = _S_token_ord_char;\n-              _M_curValue.assign(1, __c);\n-            }\n-          else if ((_M_flags & regex_constants::ECMAScript)\n-                   && __c == _M_ctype.widen('b'))\n-            {\n-              _M_curToken = _S_token_ord_char;\n-              _M_curValue.assign(1, _M_ctype.widen(' '));\n-            }\n-          else\n-            __throw_regex_error(regex_constants::error_escape);\n-        }\n-      else\n-\t__throw_regex_error(regex_constants::error_escape);\n-    }\n-\n-  // Eats a character class or throwns an exception.\n-  // current point to ':' delimiter on entry, char after ']' on return\n-  template<typename _InputIterator>\n-    void\n-    _Scanner<_InputIterator>::\n-    _M_eat_charclass()\n-    {\n-      ++_M_current; // skip ':'\n-      if (_M_current == _M_end)\n-\t__throw_regex_error(regex_constants::error_ctype);\n-      for (_M_curValue.clear();\n-\t   _M_current != _M_end && *_M_current != _M_ctype.widen(':');\n-\t   ++_M_current)\n-\t_M_curValue += *_M_current;\n-      if (_M_current == _M_end)\n-\t__throw_regex_error(regex_constants::error_ctype);\n-      ++_M_current; // skip ':'\n-      if (*_M_current != _M_ctype.widen(']'))\n-\t__throw_regex_error(regex_constants::error_ctype);\n-      ++_M_current; // skip ']'\n-    }\n-\n-\n-  template<typename _InputIterator>\n-    void\n-    _Scanner<_InputIterator>::\n-    _M_eat_equivclass()\n-    {\n-      ++_M_current; // skip '='\n-      if (_M_current == _M_end)\n-\t__throw_regex_error(regex_constants::error_collate);\n-      for (_M_curValue.clear();\n-\t   _M_current != _M_end && *_M_current != _M_ctype.widen('=');\n-\t   ++_M_current)\n-\t_M_curValue += *_M_current;\n-      if (_M_current == _M_end)\n-\t__throw_regex_error(regex_constants::error_collate);\n-      ++_M_current; // skip '='\n-      if (*_M_current != _M_ctype.widen(']'))\n-\t__throw_regex_error(regex_constants::error_collate);\n-      ++_M_current; // skip ']'\n-    }\n-\n-\n-  template<typename _InputIterator>\n-    void\n-    _Scanner<_InputIterator>::\n-    _M_eat_collsymbol()\n-    {\n-      ++_M_current; // skip '.'\n-      if (_M_current == _M_end)\n-\t__throw_regex_error(regex_constants::error_collate);\n-      for (_M_curValue.clear();\n-\t   _M_current != _M_end && *_M_current != _M_ctype.widen('.');\n-\t   ++_M_current)\n-\t_M_curValue += *_M_current;\n-      if (_M_current == _M_end)\n-\t__throw_regex_error(regex_constants::error_collate);\n-      ++_M_current; // skip '.'\n-      if (*_M_current != _M_ctype.widen(']'))\n-\t__throw_regex_error(regex_constants::error_collate);\n-      ++_M_current; // skip ']'\n-    }\n-\n-#ifdef _GLIBCXX_DEBUG\n-  template<typename _InputIterator>\n-    std::ostream&\n-    _Scanner<_InputIterator>::\n-    _M_print(std::ostream& ostr)\n-    {\n-      switch (_M_curToken)\n-      {\n-\tcase _S_token_anychar:\n-\t  ostr << \"any-character\\n\";\n-\t  break;\n-\tcase _S_token_backref:\n-\t  ostr << \"backref\\n\";\n-\t  break;\n-\tcase _S_token_bracket_begin:\n-\t  ostr << \"bracket-begin\\n\";\n-\t  break;\n-\tcase _S_token_bracket_inverse_begin:\n-          ostr << \"bracket-inverse-begin\\n\";\n-          break;\n-\tcase _S_token_bracket_end:\n-\t  ostr << \"bracket-end\\n\";\n-\t  break;\n-\tcase _S_token_char_class_name:\n-\t  ostr << \"char-class-name \\\"\" << _M_curValue << \"\\\"\\n\";\n-\t  break;\n-\tcase _S_token_closure0:\n-\t  ostr << \"closure0\\n\";\n-\t  break;\n-\tcase _S_token_closure1:\n-\t  ostr << \"closure1\\n\";\n-\t  break;\n-\tcase _S_token_collelem_multi:\n-\t  ostr << \"coll-elem-multi \\\"\" << _M_curValue << \"\\\"\\n\";\n-\t  break;\n-\tcase _S_token_collelem_single:\n-\t  ostr << \"coll-elem-single \\\"\" << _M_curValue << \"\\\"\\n\";\n-\t  break;\n-\tcase _S_token_collsymbol:\n-\t  ostr << \"collsymbol \\\"\" << _M_curValue << \"\\\"\\n\";\n-\t  break;\n-\tcase _S_token_comma:\n-\t  ostr << \"comma\\n\";\n-\t  break;\n-\tcase _S_token_dash:\n-\t  ostr << \"dash\\n\";\n-\t  break;\n-\tcase _S_token_dup_count:\n-\t  ostr << \"dup count: \" << _M_curValue << \"\\n\";\n-\t  break;\n-\tcase _S_token_eof:\n-\t  ostr << \"EOF\\n\";\n-\t  break;\n-\tcase _S_token_equiv_class_name:\n-\t  ostr << \"equiv-class-name \\\"\" << _M_curValue << \"\\\"\\n\";\n-\t  break;\n-\tcase _S_token_interval_begin:\n-\t  ostr << \"interval begin\\n\";\n-\t  break;\n-\tcase _S_token_interval_end:\n-\t  ostr << \"interval end\\n\";\n-\t  break;\n-\tcase _S_token_line_begin:\n-\t  ostr << \"line begin\\n\";\n-\t  break;\n-\tcase _S_token_line_end:\n-\t  ostr << \"line end\\n\";\n-\t  break;\n-\tcase _S_token_opt:\n-\t  ostr << \"opt\\n\";\n-\t  break;\n-\tcase _S_token_or:\n-\t  ostr << \"or\\n\";\n-\t  break;\n-\tcase _S_token_ord_char:\n-\t  ostr << \"ordinary character: \\\"\" << _M_value() << \"\\\"\\n\";\n-\t  break;\n-\tcase _S_token_subexpr_begin:\n-\t  ostr << \"subexpr begin\\n\";\n-\t  break;\n-\tcase _S_token_subexpr_end:\n-\t  ostr << \"subexpr end\\n\";\n-\t  break;\n-\tcase _S_token_word_begin:\n-\t  ostr << \"word begin\\n\";\n-\t  break;\n-\tcase _S_token_word_end:\n-\t  ostr << \"word end\\n\";\n-\t  break;\n-\tcase _S_token_unknown:\n-\t  ostr << \"-- unknown token --\\n\";\n-\t  break;\n-        default:\n-          _GLIBCXX_DEBUG_ASSERT(false);\n-      }\n-      return ostr;\n-    }\n-#endif\n-\n   /// Builds an NFA from an input iterator interval.\n-  template<typename _InIter, typename _TraitsT>\n+  template<typename _InputIter, typename _CharT, typename _TraitsT>\n     class _Compiler\n     {\n     public:\n-      typedef _InIter                                            _IterT;\n-      typedef typename std::iterator_traits<_InIter>::value_type _CharT;\n-      typedef std::basic_string<_CharT>                          _StringT;\n-      typedef regex_constants::syntax_option_type                _FlagT;\n+      typedef typename _TraitsT::string_type      _StringT;\n+      typedef _NFA<_CharT, _TraitsT>              _RegexT;\n+      typedef regex_constants::syntax_option_type _FlagT;\n \n-      _Compiler(const _InIter& __b, const _InIter& __e,\n-\t\t_TraitsT& __traits, _FlagT __flags);\n+      _Compiler(_InputIter __b, _InputIter __e,\n+                const _TraitsT& __traits, _FlagT __flags);\n \n-      const _Nfa&\n-      _M_nfa() const\n-      { return _M_state_store; }\n+      std::shared_ptr<_RegexT>\n+      _M_get_nfa() const\n+      { return std::shared_ptr<_RegexT>(new _RegexT(_M_state_store)); }\n \n     private:\n-      typedef _Scanner<_InIter>                              _ScannerT;\n-      typedef typename _ScannerT::_TokenT                    _TokenT;\n-      typedef std::stack<_StateSeq, std::vector<_StateSeq> > _StackT;\n-      typedef _BracketMatcher<_InIter, _TraitsT>             _BMatcherT;\n+      typedef _Scanner<_InputIter>                            _ScannerT;\n+      typedef typename _ScannerT::_TokenT                     _TokenT;\n+      typedef _StateSeq<_CharT, _TraitsT>                     _StateSeqT;\n+      typedef std::stack<_StateSeqT, std::vector<_StateSeqT>> _StackT;\n+      typedef _BracketMatcher<_CharT, _TraitsT>               _BMatcherT;\n \n       // accepts a specific token or returns false.\n       bool\n@@ -720,345 +303,17 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       int\n       _M_cur_int_value(int __radix);\n \n-      _TraitsT&      _M_traits;\n-      _ScannerT      _M_scanner;\n-      _StringT       _M_cur_value;\n-      _Nfa           _M_state_store;\n-      _StackT        _M_stack;\n-      _FlagT         _M_flags;\n+      const _TraitsT& _M_traits;\n+      _ScannerT       _M_scanner;\n+      _StringT        _M_cur_value;\n+      _RegexT         _M_state_store;\n+      _StackT         _M_stack;\n+      _FlagT          _M_flags;\n     };\n \n-  template<typename _InIter, typename _TraitsT>\n-    _Compiler<_InIter, _TraitsT>::\n-    _Compiler(const _InIter& __b, const _InIter& __e, _TraitsT& __traits,\n-\t      _Compiler<_InIter, _TraitsT>::_FlagT __flags)\n-    : _M_traits(__traits), _M_scanner(__b, __e, __flags, _M_traits.getloc()),\n-      _M_state_store(__flags), _M_flags(__flags)\n-    {\n-      typedef _StartTagger<_InIter, _TraitsT> _Start;\n-      typedef _EndTagger<_InIter, _TraitsT> _End;\n-\n-      _StateSeq __r(_M_state_store,\n-      \t\t    _M_state_store._M_insert_subexpr_begin(_Start(0)));\n-      _M_disjunction();\n-      if (!_M_stack.empty())\n-\t{\n-\t  __r._M_append(_M_stack.top());\n-\t  _M_stack.pop();\n-\t}\n-      __r._M_append(_M_state_store._M_insert_subexpr_end(0, _End(0)));\n-      __r._M_append(_M_state_store._M_insert_accept());\n-    }\n-\n-  template<typename _InIter, typename _TraitsT>\n-    bool\n-    _Compiler<_InIter, _TraitsT>::\n-    _M_match_token(_Compiler<_InIter, _TraitsT>::_TokenT token)\n-    { \n-      if (token == _M_scanner._M_token())\n-\t{\n-          _M_cur_value = _M_scanner._M_value();\n-          _M_scanner._M_advance();\n-\t  return true;\n-\t}\n-      return false;\n-    }\n-\n-  template<typename _InIter, typename _TraitsT>\n-    void\n-    _Compiler<_InIter, _TraitsT>::\n-    _M_disjunction()\n-    {\n-      this->_M_alternative();\n-      if (_M_match_token(_ScannerT::_S_token_or))\n-\t{\n-\t  _StateSeq __alt1 = _M_stack.top(); _M_stack.pop();\n-\t  this->_M_disjunction();\n-\t  _StateSeq __alt2 = _M_stack.top(); _M_stack.pop();\n-\t  _M_stack.push(_StateSeq(__alt1, __alt2));\n-\t}\n-    }\n-\n-  template<typename _InIter, typename _TraitsT>\n-    void\n-    _Compiler<_InIter, _TraitsT>::\n-    _M_alternative()\n-    {\n-      if (this->_M_term())\n-\t{\n-\t  _StateSeq __re = _M_stack.top(); _M_stack.pop();\n-\t  this->_M_alternative();\n-\t  if (!_M_stack.empty())\n-\t    {\n-\t      __re._M_append(_M_stack.top());\n-\t      _M_stack.pop();\n-\t    }\n-\t  _M_stack.push(__re);\n-\t}\n-    }\n-\n-  template<typename _InIter, typename _TraitsT>\n-    bool\n-    _Compiler<_InIter, _TraitsT>::\n-    _M_term()\n-    {\n-      if (this->_M_assertion())\n-\treturn true;\n-      if (this->_M_atom())\n-\t{\n-\t  this->_M_quantifier();\n-\t  return true;\n-\t}\n-      return false;\n-    }\n-\n-  template<typename _InIter, typename _TraitsT>\n-    bool\n-    _Compiler<_InIter, _TraitsT>::\n-    _M_assertion()\n-    {\n-      if (_M_match_token(_ScannerT::_S_token_line_begin))\n-\t{\n-\t  // __m.push(_Matcher::_S_opcode_line_begin);\n-\t  return true;\n-\t}\n-      if (_M_match_token(_ScannerT::_S_token_line_end))\n-\t{\n-\t  // __m.push(_Matcher::_S_opcode_line_end);\n-\t  return true;\n-\t}\n-      if (_M_match_token(_ScannerT::_S_token_word_begin))\n-\t{\n-\t  // __m.push(_Matcher::_S_opcode_word_begin);\n-\t  return true;\n-\t}\n-      if (_M_match_token(_ScannerT::_S_token_word_end))\n-\t{\n-\t  // __m.push(_Matcher::_S_opcode_word_end);\n-\t  return true;\n-\t}\n-      return false;\n-    }\n-\n-  template<typename _InIter, typename _TraitsT>\n-    void\n-    _Compiler<_InIter, _TraitsT>::\n-    _M_quantifier()\n-    {\n-      if (_M_match_token(_ScannerT::_S_token_closure0))\n-\t{\n-\t  if (_M_stack.empty())\n-\t    __throw_regex_error(regex_constants::error_badrepeat);\n-\t  _StateSeq __r(_M_stack.top(), -1);\n-\t  __r._M_append(__r._M_front());\n-\t  _M_stack.pop();\n-\t  _M_stack.push(__r);\n-\t  return;\n-\t}\n-      if (_M_match_token(_ScannerT::_S_token_closure1))\n-\t{\n-\t  if (_M_stack.empty())\n-\t    __throw_regex_error(regex_constants::error_badrepeat);\n-\t  _StateSeq __r(_M_state_store,\n-\t\t\t_M_state_store.\n-\t\t\t_M_insert_alt(_S_invalid_state_id,\n-\t\t\t\t      _M_stack.top()._M_front()));\n-\t  _M_stack.top()._M_append(__r);\n-\t  return;\n-\t}\n-      if (_M_match_token(_ScannerT::_S_token_opt))\n-\t{\n-\t  if (_M_stack.empty())\n-\t  __throw_regex_error(regex_constants::error_badrepeat);\n-\t  _StateSeq __r(_M_stack.top(), -1);\n-\t  _M_stack.pop();\n-\t  _M_stack.push(__r);\n-\t  return;\n-\t}\n-      if (_M_match_token(_ScannerT::_S_token_interval_begin))\n-\t{\n-\t  if (_M_stack.empty())\n-\t    __throw_regex_error(regex_constants::error_badrepeat);\n-\t  if (!_M_match_token(_ScannerT::_S_token_dup_count))\n-\t    __throw_regex_error(regex_constants::error_badbrace);\n-\t  _StateSeq __r(_M_stack.top());\n-\t  int __min_rep = _M_cur_int_value(10);\n-\t  for (int __i = 1; __i < __min_rep; ++__i)\n-\t    _M_stack.top()._M_append(__r._M_clone()); \n-\t  if (_M_match_token(_ScannerT::_S_token_comma))\n-\t    if (_M_match_token(_ScannerT::_S_token_dup_count))\n-\t      {\n-\t\tint __n = _M_cur_int_value(10) - __min_rep;\n-\t\tif (__n < 0)\n-\t\t  __throw_regex_error(regex_constants::error_badbrace);\n-\t\tfor (int __i = 0; __i < __n; ++__i)\n-\t\t  {\n-\t\t    _StateSeq __r(_M_state_store,\n-\t\t\t\t  _M_state_store.\n-\t\t\t\t  _M_insert_alt(_S_invalid_state_id,\n-\t\t\t\t\t\t_M_stack.top()._M_front()));\n-\t\t    _M_stack.top()._M_append(__r);\n-\t\t  }\n-\t      }\n-\t    else\n-\t      {\n-\t\t_StateSeq __r(_M_stack.top(), -1);\n-\t\t__r._M_push_back(__r._M_front());\n-\t\t_M_stack.pop();\n-\t\t_M_stack.push(__r);\n-\t      }\n-\t  if (!_M_match_token(_ScannerT::_S_token_interval_end))\n-\t    __throw_regex_error(regex_constants::error_brace);\n-\t  return;\n-\t}\n-    }\n-\n-  template<typename _InIter, typename _TraitsT>\n-    bool\n-    _Compiler<_InIter, _TraitsT>::\n-    _M_atom()\n-    {\n-      typedef _CharMatcher<_InIter, _TraitsT> _CMatcher;\n-      typedef _StartTagger<_InIter, _TraitsT> _Start;\n-      typedef _EndTagger<_InIter, _TraitsT> _End;\n-\n-      if (_M_match_token(_ScannerT::_S_token_anychar))\n-\t{\n-\t  _M_stack.push(_StateSeq(_M_state_store,\n-                                  _M_state_store._M_insert_matcher\n-                                  (_AnyMatcher)));\n-\t  return true;\n-\t}\n-      if (_M_match_token(_ScannerT::_S_token_ord_char))\n-\t{\n-\t  _M_stack.push(_StateSeq(_M_state_store,\n-                                  _M_state_store._M_insert_matcher\n-                                  (_CMatcher(_M_cur_value[0], _M_flags, _M_traits))));\n-\t  return true;\n-\t}\n-      if (_M_match_token(_ScannerT::_S_token_backref))\n-\t{\n-\t  // __m.push(_Matcher::_S_opcode_ordchar, _M_cur_value);\n-          _M_state_store._M_set_back_ref(true);\n-\t  //return true;\n-\t}\n-      if (_M_match_token(_ScannerT::_S_token_subexpr_begin))\n-\t{\n-\t  int __mark = _M_state_store._M_sub_count();\n-\t  _StateSeq __r(_M_state_store,\n-\t\t\t_M_state_store.\n-\t\t\t_M_insert_subexpr_begin(_Start(__mark)));\n-\t  this->_M_disjunction();\n-\t  if (!_M_match_token(_ScannerT::_S_token_subexpr_end))\n-\t    __throw_regex_error(regex_constants::error_paren);\n-\t  if (!_M_stack.empty())\n-\t    {\n-\t      __r._M_append(_M_stack.top());\n-\t      _M_stack.pop();\n-\t    }\n-\t  __r._M_append(_M_state_store._M_insert_subexpr_end\n-\t\t\t(__mark, _End(__mark)));\n-\t  _M_stack.push(__r);\n-\t  return true;\n-\t}\n-      return _M_bracket_expression();\n-    }\n-\n-  template<typename _InIter, typename _TraitsT>\n-    bool\n-    _Compiler<_InIter, _TraitsT>::\n-    _M_bracket_expression()\n-    {\n-      bool __inverse =\n-        _M_match_token(_ScannerT::_S_token_bracket_inverse_begin);\n-      if (!(__inverse || _M_match_token(_ScannerT::_S_token_bracket_begin)))\n-        return false;\n-      _BMatcherT __matcher( __inverse, _M_flags, _M_traits);\n-      // special case: only if  _not_ chr first after\n-      // '[' or '[^' or if ECMAscript\n-      if (!_M_bracket_list(__matcher) // list is empty\n-          && !(_M_flags & regex_constants::ECMAScript))\n-        __throw_regex_error(regex_constants::error_brack);\n-      _M_stack.push(_StateSeq(_M_state_store,\n-                              _M_state_store._M_insert_matcher(__matcher)));\n-      return true;\n-    }\n-\n-  template<typename _InIter, typename _TraitsT>\n-    bool // list is non-empty\n-    _Compiler<_InIter, _TraitsT>::\n-    _M_bracket_list(_BMatcherT& __matcher)\n-    {\n-      if (_M_match_token(_ScannerT::_S_token_bracket_end))\n-        return false;\n-      _M_expression_term(__matcher);\n-      _M_bracket_list(__matcher);\n-      return true;\n-    }\n-\n-  template<typename _InIter, typename _TraitsT>\n-    void\n-    _Compiler<_InIter, _TraitsT>::\n-    _M_expression_term(_BMatcherT& __matcher)\n-    {\n-      if (_M_match_token(_ScannerT::_S_token_collsymbol))\n-\t{\n-\t  __matcher._M_add_collating_element(_M_cur_value);\n-\t  return;\n-\t}\n-      if (_M_match_token(_ScannerT::_S_token_equiv_class_name))\n-\t{\n-\t  __matcher._M_add_equivalence_class(_M_cur_value);\n-\t  return;\n-\t}\n-      if (_M_match_token(_ScannerT::_S_token_char_class_name))\n-\t{\n-\t  __matcher._M_add_character_class(_M_cur_value);\n-\t  return;\n-\t}\n-      if (_M_match_token(_ScannerT::_S_token_collelem_single)) // [a\n-        {\n-          auto __ch = _M_cur_value[0];\n-          if (_M_match_token(_ScannerT::_S_token_dash)) // [a-\n-            {\n-              // If the dash is the last character in the bracket expression,\n-              // it is not special.\n-              if (_M_scanner._M_token() == _ScannerT::_S_token_bracket_end)\n-                __matcher._M_add_char(_M_cur_value[0]); // [a-] <=> [a\\-]\n-              else // [a-z]\n-                {\n-                  if (!_M_match_token(_ScannerT::_S_token_collelem_single))\n-                    __throw_regex_error(regex_constants::error_range);\n-                  __matcher._M_make_range(__ch, _M_cur_value[0]);\n-                }\n-            }\n-          else // [a]\n-            __matcher._M_add_char(__ch);\n-          return;\n-        }\n-      __throw_regex_error(regex_constants::error_brack);\n-    }\n-\n-  template<typename _InIter, typename _TraitsT>\n-    int\n-    _Compiler<_InIter, _TraitsT>::\n-    _M_cur_int_value(int __radix)\n-    {\n-      int __v = 0;\n-      for (typename _StringT::size_type __i = 0;\n-\t   __i < _M_cur_value.length(); ++__i)\n-\t__v =__v * __radix + _M_traits.value(_M_cur_value[__i], __radix);\n-      return __v;\n-    }\n-\n-  template<typename _InIter, typename _TraitsT>\n-    _AutomatonPtr\n-    __compile(const _InIter& __b, const _InIter& __e, _TraitsT& __t,\n-\t      regex_constants::syntax_option_type __f)\n-    { return _AutomatonPtr(new _Nfa(_Compiler<_InIter, _TraitsT>(__b, __e, __t,\n-                                        __f)._M_nfa())); }\n-\n  //@} regex-detail\n _GLIBCXX_END_NAMESPACE_VERSION\n } // namespace __detail\n } // namespace std\n+\n+#include <bits/regex_compiler.tcc>"}, {"sha": "04301e4934650caf7bd59bcd5fa20afc0ee9aa2d", "filename": "libstdc++-v3/include/bits/regex_compiler.tcc", "status": "added", "additions": 896, "deletions": 0, "changes": 896, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cb784b639c3de7505674b56f542c8b714d7df8a/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_compiler.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cb784b639c3de7505674b56f542c8b714d7df8a/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_compiler.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_compiler.tcc?ref=6cb784b639c3de7505674b56f542c8b714d7df8a", "patch": "@@ -0,0 +1,896 @@\n+// class template regex -*- C++ -*-\n+\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/**\n+ *  @file bits/regex_compiler.tcc\n+ *  This is an internal header file, included by other library headers.\n+ *  Do not attempt to use it directly. @headername{regex}\n+ */\n+\n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+namespace __detail\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+  template<typename _BiIter>\n+    void\n+    _Scanner<_BiIter>::\n+    _M_advance()\n+    {\n+      if (_M_current == _M_end)\n+\t{\n+\t  _M_curToken = _S_token_eof;\n+\t  return;\n+\t}\n+\n+      _CharT __c = *_M_current;\n+      if (_M_state & _S_state_in_bracket)\n+\t{\n+\t  _M_scan_in_bracket();\n+\t  return;\n+\t}\n+      if (_M_state & _S_state_in_brace)\n+\t{\n+\t  _M_scan_in_brace();\n+\t  return;\n+\t}\n+#if 0\n+      // TODO: re-enable line anchors when _M_assertion is implemented.\n+      // See PR libstdc++/47724\n+      else if (_M_state & _S_state_at_start && __c == _M_ctype.widen('^'))\n+\t{\n+\t  _M_curToken = _S_token_line_begin;\n+\t  ++_M_current;\n+\t  return;\n+\t}\n+      else if (__c == _M_ctype.widen('$'))\n+\t{\n+\t  _M_curToken = _S_token_line_end;\n+\t  ++_M_current;\n+\t  return;\n+\t}\n+#endif\n+      else if (__c == _M_ctype.widen('.'))\n+\t{\n+\t  _M_curToken = _S_token_anychar;\n+\t  ++_M_current;\n+\t  return;\n+\t}\n+      else if (__c == _M_ctype.widen('*'))\n+\t{\n+\t  _M_curToken = _S_token_closure0;\n+\t  ++_M_current;\n+\t  return;\n+\t}\n+      else if (__c == _M_ctype.widen('+'))\n+\t{\n+\t  _M_curToken = _S_token_closure1;\n+\t  ++_M_current;\n+\t  return;\n+\t}\n+      else if (__c == _M_ctype.widen('|'))\n+\t{\n+\t  _M_curToken = _S_token_or;\n+\t  ++_M_current;\n+\t  return;\n+\t}\n+      else if (__c == _M_ctype.widen('['))\n+\t{\n+          if (*++_M_current == _M_ctype.widen('^'))\n+            {\n+              _M_curToken = _S_token_bracket_inverse_begin;\n+              ++_M_current;\n+            }\n+          else\n+            _M_curToken = _S_token_bracket_begin;\n+\t  _M_state |= _S_state_in_bracket;\n+\t  return;\n+\t}\n+      else if (__c == _M_ctype.widen('\\\\'))\n+\t{\n+\t  _M_eat_escape();\n+\t  return;\n+\t}\n+      else if (!(_M_flags & (regex_constants::basic | regex_constants::grep)))\n+\t{\n+\t  if (__c == _M_ctype.widen('('))\n+\t    {\n+\t      _M_curToken = _S_token_subexpr_begin;\n+\t      ++_M_current;\n+\t      return;\n+\t    }\n+\t  else if (__c == _M_ctype.widen(')'))\n+\t    {\n+\t      _M_curToken = _S_token_subexpr_end;\n+\t      ++_M_current;\n+\t      return;\n+\t    }\n+\t  else if (__c == _M_ctype.widen('{'))\n+\t    {\n+\t      _M_curToken = _S_token_interval_begin;\n+\t      _M_state |= _S_state_in_brace;\n+\t      ++_M_current;\n+\t      return;\n+\t    }\n+\t}\n+\n+      _M_curToken = _S_token_ord_char;\n+      _M_curValue.assign(1, __c);\n+      ++_M_current;\n+    }\n+\n+  template<typename _BiIter>\n+    void\n+    _Scanner<_BiIter>::\n+    _M_scan_in_brace()\n+    {\n+      if (_M_ctype.is(_CtypeT::digit, *_M_current))\n+\t{\n+\t  _M_curToken = _S_token_dup_count;\n+\t  _M_curValue.assign(1, *_M_current);\n+\t  ++_M_current;\n+\t  while (_M_current != _M_end\n+\t\t && _M_ctype.is(_CtypeT::digit, *_M_current))\n+\t    {\n+\t      _M_curValue += *_M_current;\n+\t      ++_M_current;\n+\t    }\n+\t  return;\n+\t}\n+      else if (*_M_current == _M_ctype.widen(','))\n+\t{\n+\t  _M_curToken = _S_token_comma;\n+\t  ++_M_current;\n+\t  return;\n+\t}\n+      if (_M_flags & (regex_constants::basic | regex_constants::grep))\n+\t{\n+\t  if (*_M_current == _M_ctype.widen('\\\\'))\n+\t    _M_eat_escape();\n+\t}\n+      else\n+\t{\n+\t  if (*_M_current == _M_ctype.widen('}'))\n+\t    {\n+\t      _M_curToken = _S_token_interval_end;\n+\t      _M_state &= ~_S_state_in_brace;\n+\t      ++_M_current;\n+\t      return;\n+\t    }\n+\t}\n+    }\n+\n+  template<typename _BiIter>\n+    void\n+    _Scanner<_BiIter>::\n+    _M_scan_in_bracket()\n+    {\n+      if (*_M_current == _M_ctype.widen('['))\n+\t{\n+\t  ++_M_current;\n+\t  if (_M_current == _M_end)\n+\t    {\n+\t      _M_curToken = _S_token_eof;\n+\t      return;\n+\t    }\n+\n+\t  if (*_M_current == _M_ctype.widen('.'))\n+\t    {\n+\t      _M_curToken = _S_token_collsymbol;\n+\t      _M_eat_collsymbol();\n+\t      return;\n+\t    }\n+\t  else if (*_M_current == _M_ctype.widen(':'))\n+\t    {\n+\t      _M_curToken = _S_token_char_class_name;\n+\t      _M_eat_charclass();\n+\t      return;\n+\t    }\n+\t  else if (*_M_current == _M_ctype.widen('='))\n+\t    {\n+\t      _M_curToken = _S_token_equiv_class_name;\n+\t      _M_eat_equivclass();\n+\t      return;\n+\t    }\n+\t}\n+      else if (*_M_current == _M_ctype.widen('-'))\n+\t{\n+\t  _M_curToken = _S_token_dash;\n+\t  ++_M_current;\n+\t  return;\n+\t}\n+      else if (*_M_current == _M_ctype.widen(']'))\n+\t{\n+          _M_curToken = _S_token_bracket_end;\n+          _M_state &= ~_S_state_in_bracket;\n+          ++_M_current;\n+          return;\n+\t}\n+      else if (*_M_current == _M_ctype.widen('\\\\'))\n+        {\n+\t  _M_eat_escape();\n+\t  return;\n+        }\n+      _M_curToken = _S_token_collelem_single;\n+      _M_curValue.assign(1, *_M_current);\n+      ++_M_current;\n+    }\n+\n+  // TODO Complete it.\n+  template<typename _BiIter>\n+    void\n+    _Scanner<_BiIter>::\n+    _M_eat_escape()\n+    {\n+      ++_M_current;\n+      if (_M_current == _M_end)\n+\t{\n+\t  _M_curToken = _S_token_eof;\n+\t  return;\n+\t}\n+      _CharT __c = *_M_current;\n+      ++_M_current;\n+\n+      if (__c == _M_ctype.widen('('))\n+\t{\n+\t  if (!(_M_flags & (regex_constants::basic | regex_constants::grep)))\n+\t    {\n+\t      _M_curToken = _S_token_ord_char;\n+\t      _M_curValue.assign(1, __c);\n+\t    }\n+\t  else\n+\t    _M_curToken = _S_token_subexpr_begin;\n+\t}\n+      else if (__c == _M_ctype.widen(')'))\n+\t{\n+\t  if (!(_M_flags & (regex_constants::basic | regex_constants::grep)))\n+\t    {\n+\t      _M_curToken = _S_token_ord_char;\n+\t      _M_curValue.assign(1, __c);\n+\t    }\n+\t  else\n+\t    _M_curToken = _S_token_subexpr_end;\n+\t}\n+      else if (__c == _M_ctype.widen('{'))\n+\t{\n+\t  if (!(_M_flags & (regex_constants::basic | regex_constants::grep)))\n+\t    {\n+\t      _M_curToken = _S_token_ord_char;\n+\t      _M_curValue.assign(1, __c);\n+\t    }\n+\t  else\n+\t    {\n+\t      _M_curToken = _S_token_interval_begin;\n+\t      _M_state |= _S_state_in_brace;\n+\t    }\n+\t}\n+      else if (__c == _M_ctype.widen('}'))\n+\t{\n+\t  if (!(_M_flags & (regex_constants::basic | regex_constants::grep)))\n+\t    {\n+\t      _M_curToken = _S_token_ord_char;\n+\t      _M_curValue.assign(1, __c);\n+\t    }\n+\t  else\n+\t    {\n+\t      if (!(_M_state && _S_state_in_brace))\n+\t\t__throw_regex_error(regex_constants::error_badbrace);\n+\t      _M_state &= ~_S_state_in_brace;\n+\t      _M_curToken = _S_token_interval_end;\n+\t    }\n+\t}\n+      else if (__c == _M_ctype.widen('x'))\n+\t{\n+\t  ++_M_current;\n+\t  if (_M_current == _M_end)\n+\t    {\n+\t      _M_curToken = _S_token_eof;\n+\t      return;\n+\t    }\n+\t  if (_M_ctype.is(_CtypeT::digit, *_M_current))\n+\t    {\n+\t      _M_curValue.assign(1, *_M_current);\n+\t      ++_M_current;\n+\t      if (_M_current == _M_end)\n+\t\t{\n+\t\t  _M_curToken = _S_token_eof;\n+\t\t  return;\n+\t\t}\n+\t      if (_M_ctype.is(_CtypeT::digit, *_M_current))\n+\t\t{\n+\t\t  _M_curValue += *_M_current;\n+\t\t  ++_M_current;\n+\t\t  return;\n+\t\t}\n+\t    }\n+\t}\n+      else if (__c == _M_ctype.widen('^')\n+\t       || __c == _M_ctype.widen('.')\n+\t       || __c == _M_ctype.widen('*')\n+\t       || __c == _M_ctype.widen('$')\n+\t       || __c == _M_ctype.widen('\\\\'))\n+\t{\n+\t  _M_curToken = _S_token_ord_char;\n+\t  _M_curValue.assign(1, __c);\n+\t}\n+      else if (_M_ctype.is(_CtypeT::digit, __c))\n+\t{\n+\t  _M_curToken = _S_token_backref;\n+\t  _M_curValue.assign(1, __c);\n+\t}\n+      else if (_M_state & _S_state_in_bracket)\n+        {\n+          if (__c == _M_ctype.widen('-')\n+              || __c == _M_ctype.widen('[')\n+              || __c == _M_ctype.widen(']'))\n+            {\n+              _M_curToken = _S_token_ord_char;\n+              _M_curValue.assign(1, __c);\n+            }\n+          else if ((_M_flags & regex_constants::ECMAScript)\n+                   && __c == _M_ctype.widen('b'))\n+            {\n+              _M_curToken = _S_token_ord_char;\n+              _M_curValue.assign(1, _M_ctype.widen(' '));\n+            }\n+          else\n+            __throw_regex_error(regex_constants::error_escape);\n+        }\n+      else\n+\t__throw_regex_error(regex_constants::error_escape);\n+    }\n+\n+  // Eats a character class or throwns an exception.\n+  // current point to ':' delimiter on entry, char after ']' on return\n+  template<typename _BiIter>\n+    void\n+    _Scanner<_BiIter>::\n+    _M_eat_charclass()\n+    {\n+      ++_M_current; // skip ':'\n+      if (_M_current == _M_end)\n+\t__throw_regex_error(regex_constants::error_ctype);\n+      for (_M_curValue.clear();\n+\t   _M_current != _M_end && *_M_current != _M_ctype.widen(':');\n+\t   ++_M_current)\n+\t_M_curValue += *_M_current;\n+      if (_M_current == _M_end)\n+\t__throw_regex_error(regex_constants::error_ctype);\n+      ++_M_current; // skip ':'\n+      if (*_M_current != _M_ctype.widen(']'))\n+\t__throw_regex_error(regex_constants::error_ctype);\n+      ++_M_current; // skip ']'\n+    }\n+\n+\n+  template<typename _BiIter>\n+    void\n+    _Scanner<_BiIter>::\n+    _M_eat_equivclass()\n+    {\n+      ++_M_current; // skip '='\n+      if (_M_current == _M_end)\n+\t__throw_regex_error(regex_constants::error_collate);\n+      for (_M_curValue.clear();\n+\t   _M_current != _M_end && *_M_current != _M_ctype.widen('=');\n+\t   ++_M_current)\n+\t_M_curValue += *_M_current;\n+      if (_M_current == _M_end)\n+\t__throw_regex_error(regex_constants::error_collate);\n+      ++_M_current; // skip '='\n+      if (*_M_current != _M_ctype.widen(']'))\n+\t__throw_regex_error(regex_constants::error_collate);\n+      ++_M_current; // skip ']'\n+    }\n+\n+\n+  template<typename _BiIter>\n+    void\n+    _Scanner<_BiIter>::\n+    _M_eat_collsymbol()\n+    {\n+      ++_M_current; // skip '.'\n+      if (_M_current == _M_end)\n+\t__throw_regex_error(regex_constants::error_collate);\n+      for (_M_curValue.clear();\n+\t   _M_current != _M_end && *_M_current != _M_ctype.widen('.');\n+\t   ++_M_current)\n+\t_M_curValue += *_M_current;\n+      if (_M_current == _M_end)\n+\t__throw_regex_error(regex_constants::error_collate);\n+      ++_M_current; // skip '.'\n+      if (*_M_current != _M_ctype.widen(']'))\n+\t__throw_regex_error(regex_constants::error_collate);\n+      ++_M_current; // skip ']'\n+    }\n+\n+#ifdef _GLIBCXX_DEBUG\n+  template<typename _BiIter>\n+    std::ostream&\n+    _Scanner<_BiIter>::\n+    _M_print(std::ostream& ostr)\n+    {\n+      switch (_M_curToken)\n+      {\n+\tcase _S_token_anychar:\n+\t  ostr << \"any-character\\n\";\n+\t  break;\n+\tcase _S_token_backref:\n+\t  ostr << \"backref\\n\";\n+\t  break;\n+\tcase _S_token_bracket_begin:\n+\t  ostr << \"bracket-begin\\n\";\n+\t  break;\n+\tcase _S_token_bracket_inverse_begin:\n+          ostr << \"bracket-inverse-begin\\n\";\n+          break;\n+\tcase _S_token_bracket_end:\n+\t  ostr << \"bracket-end\\n\";\n+\t  break;\n+\tcase _S_token_char_class_name:\n+\t  ostr << \"char-class-name \\\"\" << _M_curValue << \"\\\"\\n\";\n+\t  break;\n+\tcase _S_token_closure0:\n+\t  ostr << \"closure0\\n\";\n+\t  break;\n+\tcase _S_token_closure1:\n+\t  ostr << \"closure1\\n\";\n+\t  break;\n+\tcase _S_token_collelem_multi:\n+\t  ostr << \"coll-elem-multi \\\"\" << _M_curValue << \"\\\"\\n\";\n+\t  break;\n+\tcase _S_token_collelem_single:\n+\t  ostr << \"coll-elem-single \\\"\" << _M_curValue << \"\\\"\\n\";\n+\t  break;\n+\tcase _S_token_collsymbol:\n+\t  ostr << \"collsymbol \\\"\" << _M_curValue << \"\\\"\\n\";\n+\t  break;\n+\tcase _S_token_comma:\n+\t  ostr << \"comma\\n\";\n+\t  break;\n+\tcase _S_token_dash:\n+\t  ostr << \"dash\\n\";\n+\t  break;\n+\tcase _S_token_dup_count:\n+\t  ostr << \"dup count: \" << _M_curValue << \"\\n\";\n+\t  break;\n+\tcase _S_token_eof:\n+\t  ostr << \"EOF\\n\";\n+\t  break;\n+\tcase _S_token_equiv_class_name:\n+\t  ostr << \"equiv-class-name \\\"\" << _M_curValue << \"\\\"\\n\";\n+\t  break;\n+\tcase _S_token_interval_begin:\n+\t  ostr << \"interval begin\\n\";\n+\t  break;\n+\tcase _S_token_interval_end:\n+\t  ostr << \"interval end\\n\";\n+\t  break;\n+\tcase _S_token_line_begin:\n+\t  ostr << \"line begin\\n\";\n+\t  break;\n+\tcase _S_token_line_end:\n+\t  ostr << \"line end\\n\";\n+\t  break;\n+\tcase _S_token_opt:\n+\t  ostr << \"opt\\n\";\n+\t  break;\n+\tcase _S_token_or:\n+\t  ostr << \"or\\n\";\n+\t  break;\n+\tcase _S_token_ord_char:\n+\t  ostr << \"ordinary character: \\\"\" << _M_value() << \"\\\"\\n\";\n+\t  break;\n+\tcase _S_token_subexpr_begin:\n+\t  ostr << \"subexpr begin\\n\";\n+\t  break;\n+\tcase _S_token_subexpr_end:\n+\t  ostr << \"subexpr end\\n\";\n+\t  break;\n+\tcase _S_token_word_begin:\n+\t  ostr << \"word begin\\n\";\n+\t  break;\n+\tcase _S_token_word_end:\n+\t  ostr << \"word end\\n\";\n+\t  break;\n+\tcase _S_token_unknown:\n+\t  ostr << \"-- unknown token --\\n\";\n+\t  break;\n+        default:\n+          _GLIBCXX_DEBUG_ASSERT(false);\n+      }\n+      return ostr;\n+    }\n+#endif\n+\n+  template<typename _InputIter, typename _CharT, typename _TraitsT>\n+    _Compiler<_InputIter, _CharT, _TraitsT>::\n+    _Compiler(_InputIter __b, _InputIter __e,\n+              const _TraitsT& __traits, _FlagT __flags)\n+    : _M_traits(__traits), _M_scanner(__b, __e, __flags, _M_traits.getloc()),\n+      _M_state_store(__flags), _M_flags(__flags)\n+    {\n+      _StateSeqT __r(_M_state_store,\n+      \t\t    _M_state_store._M_insert_subexpr_begin());\n+      _M_disjunction();\n+      if (!_M_stack.empty())\n+\t{\n+\t  __r._M_append(_M_stack.top());\n+\t  _M_stack.pop();\n+\t}\n+      __r._M_append(_M_state_store._M_insert_subexpr_end());\n+      __r._M_append(_M_state_store._M_insert_accept());\n+    }\n+\n+  template<typename _InputIter, typename _CharT, typename _TraitsT>\n+    bool\n+    _Compiler<_InputIter, _CharT, _TraitsT>::\n+    _M_match_token(_Compiler<_InputIter, _CharT, _TraitsT>::_TokenT token)\n+    {\n+      if (token == _M_scanner._M_token())\n+\t{\n+          _M_cur_value = _M_scanner._M_value();\n+          _M_scanner._M_advance();\n+\t  return true;\n+\t}\n+      return false;\n+    }\n+\n+  template<typename _InputIter, typename _CharT, typename _TraitsT>\n+    void\n+    _Compiler<_InputIter, _CharT, _TraitsT>::\n+    _M_disjunction()\n+    {\n+      this->_M_alternative();\n+      if (_M_match_token(_ScannerT::_S_token_or))\n+\t{\n+\t  _StateSeqT __alt1 = _M_stack.top(); _M_stack.pop();\n+\t  this->_M_disjunction();\n+\t  _StateSeqT __alt2 = _M_stack.top(); _M_stack.pop();\n+\t  _M_stack.push(_StateSeqT(__alt1, __alt2));\n+\t}\n+    }\n+\n+  template<typename _InputIter, typename _CharT, typename _TraitsT>\n+    void\n+    _Compiler<_InputIter, _CharT, _TraitsT>::\n+    _M_alternative()\n+    {\n+      if (this->_M_term())\n+\t{\n+\t  _StateSeqT __re = _M_stack.top(); _M_stack.pop();\n+\t  this->_M_alternative();\n+\t  if (!_M_stack.empty())\n+\t    {\n+\t      __re._M_append(_M_stack.top());\n+\t      _M_stack.pop();\n+\t    }\n+\t  _M_stack.push(__re);\n+\t}\n+    }\n+\n+  template<typename _InputIter, typename _CharT, typename _TraitsT>\n+    bool\n+    _Compiler<_InputIter, _CharT, _TraitsT>::\n+    _M_term()\n+    {\n+      if (this->_M_assertion())\n+\treturn true;\n+      if (this->_M_atom())\n+\t{\n+\t  this->_M_quantifier();\n+\t  return true;\n+\t}\n+      return false;\n+    }\n+\n+  template<typename _InputIter, typename _CharT, typename _TraitsT>\n+    bool\n+    _Compiler<_InputIter, _CharT, _TraitsT>::\n+    _M_assertion()\n+    {\n+      if (_M_match_token(_ScannerT::_S_token_line_begin))\n+\t{\n+\t  // __m.push(_Matcher::_S_opcode_line_begin);\n+\t  return true;\n+\t}\n+      if (_M_match_token(_ScannerT::_S_token_line_end))\n+\t{\n+\t  // __m.push(_Matcher::_S_opcode_line_end);\n+\t  return true;\n+\t}\n+      if (_M_match_token(_ScannerT::_S_token_word_begin))\n+\t{\n+\t  // __m.push(_Matcher::_S_opcode_word_begin);\n+\t  return true;\n+\t}\n+      if (_M_match_token(_ScannerT::_S_token_word_end))\n+\t{\n+\t  // __m.push(_Matcher::_S_opcode_word_end);\n+\t  return true;\n+\t}\n+      return false;\n+    }\n+\n+  template<typename _InputIter, typename _CharT, typename _TraitsT>\n+    void\n+    _Compiler<_InputIter, _CharT, _TraitsT>::\n+    _M_quantifier()\n+    {\n+      if (_M_match_token(_ScannerT::_S_token_closure0))\n+\t{\n+\t  if (_M_stack.empty())\n+\t    __throw_regex_error(regex_constants::error_badrepeat);\n+\t  _StateSeqT __r(_M_stack.top(), -1);\n+\t  __r._M_append(__r._M_front());\n+\t  _M_stack.pop();\n+\t  _M_stack.push(__r);\n+\t  return;\n+\t}\n+      if (_M_match_token(_ScannerT::_S_token_closure1))\n+\t{\n+\t  if (_M_stack.empty())\n+\t    __throw_regex_error(regex_constants::error_badrepeat);\n+\t  _StateSeqT __r(_M_state_store,\n+\t\t\t_M_state_store.\n+\t\t\t_M_insert_alt(_S_invalid_state_id,\n+\t\t\t\t      _M_stack.top()._M_front()));\n+\t  _M_stack.top()._M_append(__r);\n+\t  return;\n+\t}\n+      if (_M_match_token(_ScannerT::_S_token_opt))\n+\t{\n+\t  if (_M_stack.empty())\n+\t  __throw_regex_error(regex_constants::error_badrepeat);\n+\t  _StateSeqT __r(_M_stack.top(), -1);\n+\t  _M_stack.pop();\n+\t  _M_stack.push(__r);\n+\t  return;\n+\t}\n+      if (_M_match_token(_ScannerT::_S_token_interval_begin))\n+\t{\n+\t  if (_M_stack.empty())\n+\t    __throw_regex_error(regex_constants::error_badrepeat);\n+\t  if (!_M_match_token(_ScannerT::_S_token_dup_count))\n+\t    __throw_regex_error(regex_constants::error_badbrace);\n+\t  _StateSeqT __r(_M_stack.top());\n+\t  int __min_rep = _M_cur_int_value(10);\n+\t  for (int __i = 1; __i < __min_rep; ++__i)\n+\t    _M_stack.top()._M_append(__r._M_clone());\n+\t  if (_M_match_token(_ScannerT::_S_token_comma))\n+\t    if (_M_match_token(_ScannerT::_S_token_dup_count))\n+\t      {\n+\t\tint __n = _M_cur_int_value(10) - __min_rep;\n+\t\tif (__n < 0)\n+\t\t  __throw_regex_error(regex_constants::error_badbrace);\n+\t\tfor (int __i = 0; __i < __n; ++__i)\n+\t\t  {\n+\t\t    _StateSeqT __r(_M_state_store,\n+\t\t\t\t  _M_state_store.\n+\t\t\t\t  _M_insert_alt(_S_invalid_state_id,\n+\t\t\t\t\t\t_M_stack.top()._M_front()));\n+\t\t    _M_stack.top()._M_append(__r);\n+\t\t  }\n+\t      }\n+\t    else\n+\t      {\n+\t\t_StateSeqT __r(_M_stack.top(), -1);\n+\t\t__r._M_push_back(__r._M_front());\n+\t\t_M_stack.pop();\n+\t\t_M_stack.push(__r);\n+\t      }\n+\t  if (!_M_match_token(_ScannerT::_S_token_interval_end))\n+\t    __throw_regex_error(regex_constants::error_brace);\n+\t  return;\n+\t}\n+    }\n+\n+  template<typename _InputIter, typename _CharT, typename _TraitsT>\n+    bool\n+    _Compiler<_InputIter, _CharT, _TraitsT>::\n+    _M_atom()\n+    {\n+      if (_M_match_token(_ScannerT::_S_token_anychar))\n+\t{\n+          const static auto&\n+          __any_matcher = [](_CharT) -> bool\n+          { return true; };\n+\n+\t  _M_stack.push(_StateSeqT(_M_state_store,\n+                                  _M_state_store._M_insert_matcher\n+                                  (__any_matcher)));\n+\t  return true;\n+\t}\n+      if (_M_match_token(_ScannerT::_S_token_ord_char))\n+\t{\n+          auto __c = _M_cur_value[0];\n+          __detail::_Matcher<_CharT> f;\n+          if (_M_flags & regex_constants::icase)\n+            {\n+              auto __traits = this->_M_traits;\n+              __c = __traits.translate_nocase(__c);\n+              f = [__traits, __c](_CharT __ch) -> bool\n+              { return __traits.translate_nocase(__ch) == __c; };\n+            }\n+          else\n+            f = [__c](_CharT __ch) -> bool\n+            { return __ch == __c; };\n+\n+\t  _M_stack.push(_StateSeqT(_M_state_store,\n+                                   _M_state_store._M_insert_matcher(f)));\n+\t  return true;\n+\t}\n+      if (_M_match_token(_ScannerT::_S_token_backref))\n+\t{\n+\t  // __m.push(_Matcher::_S_opcode_ordchar, _M_cur_value);\n+          _M_state_store._M_set_backref(true);\n+\t  //return true;\n+\t}\n+      if (_M_match_token(_ScannerT::_S_token_subexpr_begin))\n+\t{\n+\t  int __mark = _M_state_store._M_sub_count();\n+\t  _StateSeqT __r(_M_state_store,\n+\t\t\t_M_state_store.\n+\t\t\t_M_insert_subexpr_begin());\n+\t  this->_M_disjunction();\n+\t  if (!_M_match_token(_ScannerT::_S_token_subexpr_end))\n+\t    __throw_regex_error(regex_constants::error_paren);\n+\t  if (!_M_stack.empty())\n+\t    {\n+\t      __r._M_append(_M_stack.top());\n+\t      _M_stack.pop();\n+\t    }\n+\t  __r._M_append(_M_state_store._M_insert_subexpr_end());\n+\t  _M_stack.push(__r);\n+\t  return true;\n+\t}\n+      return _M_bracket_expression();\n+    }\n+\n+  template<typename _InputIter, typename _CharT, typename _TraitsT>\n+    bool\n+    _Compiler<_InputIter, _CharT, _TraitsT>::\n+    _M_bracket_expression()\n+    {\n+      bool __inverse =\n+        _M_match_token(_ScannerT::_S_token_bracket_inverse_begin);\n+      if (!(__inverse || _M_match_token(_ScannerT::_S_token_bracket_begin)))\n+        return false;\n+      _BMatcherT __matcher( __inverse, _M_traits, _M_flags);\n+      // special case: only if  _not_ chr first after\n+      // '[' or '[^' or if ECMAscript\n+      if (!_M_bracket_list(__matcher) // list is empty\n+          && !(_M_flags & regex_constants::ECMAScript))\n+        __throw_regex_error(regex_constants::error_brack);\n+      _M_stack.push(_StateSeqT(_M_state_store,\n+                              _M_state_store._M_insert_matcher(__matcher)));\n+      return true;\n+    }\n+\n+  template<typename _InputIter, typename _CharT, typename _TraitsT>\n+    bool // list is non-empty\n+    _Compiler<_InputIter, _CharT, _TraitsT>::\n+    _M_bracket_list(_BMatcherT& __matcher)\n+    {\n+      if (_M_match_token(_ScannerT::_S_token_bracket_end))\n+        return false;\n+      _M_expression_term(__matcher);\n+      _M_bracket_list(__matcher);\n+      return true;\n+    }\n+\n+  template<typename _InputIter, typename _CharT, typename _TraitsT>\n+    void\n+    _Compiler<_InputIter, _CharT, _TraitsT>::\n+    _M_expression_term(_BMatcherT& __matcher)\n+    {\n+      if (_M_match_token(_ScannerT::_S_token_collsymbol))\n+\t{\n+\t  __matcher._M_add_collating_element(_M_cur_value);\n+\t  return;\n+\t}\n+      if (_M_match_token(_ScannerT::_S_token_equiv_class_name))\n+\t{\n+\t  __matcher._M_add_equivalence_class(_M_cur_value);\n+\t  return;\n+\t}\n+      if (_M_match_token(_ScannerT::_S_token_char_class_name))\n+\t{\n+\t  __matcher._M_add_character_class(_M_cur_value);\n+\t  return;\n+\t}\n+      if (_M_match_token(_ScannerT::_S_token_collelem_single)) // [a\n+        {\n+          auto __ch = _M_cur_value[0];\n+          if (_M_match_token(_ScannerT::_S_token_dash)) // [a-\n+            {\n+              // If the dash is the last character in the bracket expression,\n+              // it is not special.\n+              if (_M_scanner._M_token() == _ScannerT::_S_token_bracket_end)\n+                __matcher._M_add_char(_M_cur_value[0]); // [a-] <=> [a\\-]\n+              else // [a-z]\n+                {\n+                  if (!_M_match_token(_ScannerT::_S_token_collelem_single))\n+                    __throw_regex_error(regex_constants::error_range);\n+                  __matcher._M_make_range(__ch, _M_cur_value[0]);\n+                }\n+            }\n+          else // [a]\n+            __matcher._M_add_char(__ch);\n+          return;\n+        }\n+      __throw_regex_error(regex_constants::error_brack);\n+    }\n+\n+  template<typename _InputIter, typename _CharT, typename _TraitsT>\n+    int\n+    _Compiler<_InputIter, _CharT, _TraitsT>::\n+    _M_cur_int_value(int __radix)\n+    {\n+      int __v = 0;\n+      for (typename _StringT::size_type __i = 0;\n+\t   __i < _M_cur_value.length(); ++__i)\n+\t__v =__v * __radix + _M_traits.value(_M_cur_value[__i], __radix);\n+      return __v;\n+    }\n+\n+  template<typename _CharT, typename _TraitsT>\n+    bool _BracketMatcher<_CharT, _TraitsT>::\n+    operator()(_CharT __ch) const\n+    {\n+      auto __oldch = __ch;\n+      if (_M_flags & regex_constants::collate)\n+        if (_M_is_icase())\n+          __ch = _M_traits.translate_nocase(__ch);\n+        else\n+          __ch = _M_traits.translate(__ch);\n+\n+      bool __ret = false;\n+      for (auto __c : _M_char_set)\n+        if (__c == __ch)\n+          {\n+            __ret = true;\n+            break;\n+          }\n+      if (!__ret && _M_traits.isctype(__oldch, _M_class_set))\n+        __ret = true;\n+      else\n+        {\n+          _StringT __s = _M_get_str(__ch);\n+          for (auto& __it : _M_range_set)\n+            if (__it.first <= __s && __s <= __it.second)\n+              {\n+                __ret = true;\n+                break;\n+              }\n+        }\n+      if (_M_is_non_matching)\n+        __ret = !__ret;\n+      return __ret;\n+    }\n+\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace __detail\n+} // namespace"}, {"sha": "8c163cc0b3efd0bbd5758928be8253b19883e235", "filename": "libstdc++-v3/include/bits/regex_constants.h", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cb784b639c3de7505674b56f542c8b714d7df8a/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_constants.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cb784b639c3de7505674b56f542c8b714d7df8a/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_constants.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_constants.h?ref=6cb784b639c3de7505674b56f542c8b714d7df8a", "patch": "@@ -79,7 +79,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n    */\n   typedef unsigned int syntax_option_type;\n \n-  /** \n+  /**\n    * Specifies that the matching of regular expressions against a character\n    * sequence shall be performed without regard to case.\n    */\n@@ -139,7 +139,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n    * identical to syntax_option_type extended, except that C-style escape\n    * sequences are supported.  These sequences are:\n    * \\\\\\\\, \\\\a, \\\\b, \\\\f, \\\\n, \\\\r, \\\\t , \\\\v, \\\\&apos;, &apos;,\n-   * and \\\\ddd (where ddd is one, two, or three octal digits).  \n+   * and \\\\ddd (where ddd is one, two, or three octal digits).\n    */\n   constexpr syntax_option_type awk        = 1 << _S_awk;\n \n@@ -154,7 +154,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   /**\n    * Specifies that the grammar recognized by the regular expression engine is\n    * that used by POSIX utility grep when given the -E option in\n-   * IEEE Std 1003.1-2001.  This option is identical to syntax_option_type \n+   * IEEE Std 1003.1-2001.  This option is identical to syntax_option_type\n    * extended, except that newlines are treated as whitespace.\n    */\n   constexpr syntax_option_type egrep      = 1 << _S_egrep;\n@@ -215,35 +215,35 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n    * expression shall not match [last, last).\n    */\n   constexpr match_flag_type match_not_eol     = 1 << _S_not_eol;\n-   \n+\n   /**\n    * The expression \\\\b is not matched against the sub-sequence\n    * [first,first).\n    */\n   constexpr match_flag_type match_not_bow     = 1 << _S_not_bow;\n-   \n+\n   /**\n    * The expression \\\\b should not be matched against the sub-sequence\n    * [last,last).\n    */\n   constexpr match_flag_type match_not_eow     = 1 << _S_not_eow;\n-   \n+\n   /**\n    * If more than one match is possible then any match is an acceptable\n    * result.\n    */\n   constexpr match_flag_type match_any         = 1 << _S_any;\n-   \n+\n   /**\n    * The expression does not match an empty sequence.\n    */\n   constexpr match_flag_type match_not_null    = 1 << _S_not_null;\n-   \n+\n   /**\n    * The expression only matches a sub-sequence that begins at first .\n    */\n   constexpr match_flag_type match_continuous  = 1 << _S_continuous;\n-   \n+\n   /**\n    * --first is a valid iterator position.  When this flag is set then the\n    * flags match_not_bol and match_not_bow are ignored by the regular\n@@ -260,7 +260,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n    * operations all non-overlapping occurrences of the regular expression\n    * are located and replaced, and sections of the input that did not match\n    * the expression are copied unchanged to the output string.\n-   * \n+   *\n    * Format strings (from ECMA-262 [15.5.4.11]):\n    * @li $$  The dollar-sign itself ($)\n    * @li $&  The matched substring."}, {"sha": "444d07ae2631ca588e2af83ecd04306c3e111171", "filename": "libstdc++-v3/include/bits/regex_cursor.h", "status": "removed", "additions": 0, "deletions": 105, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ee5b32cb20051b96dee793ef1c34355b43f8889/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_cursor.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ee5b32cb20051b96dee793ef1c34355b43f8889/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_cursor.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_cursor.h?ref=5ee5b32cb20051b96dee793ef1c34355b43f8889", "patch": "@@ -1,105 +0,0 @@\n-// class template regex -*- C++ -*-\n-\n-// Copyright (C) 2010-2013 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 3, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// Under Section 7 of GPL version 3, you are granted additional\n-// permissions described in the GCC Runtime Library Exception, version\n-// 3.1, as published by the Free Software Foundation.\n-\n-// You should have received a copy of the GNU General Public License and\n-// a copy of the GCC Runtime Library Exception along with this program;\n-// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-// <http://www.gnu.org/licenses/>.\n-\n-/**\n- *  @file bits/regex_cursor.h\n- *  This is an internal header file, included by other library headers.\n- *  Do not attempt to use it directly. @headername{regex}\n- */\n-\n-namespace std _GLIBCXX_VISIBILITY(default)\n-{\n-namespace __detail\n-{\n-_GLIBCXX_BEGIN_NAMESPACE_VERSION\n-\n-  /**\n-   *  @defgroup regex-detail Base and Implementation Classes\n-   *  @ingroup regex\n-   *  @{\n-   */\n-\n-  /// ABC for pattern matching\n-  struct _PatternCursor\n-  {\n-    virtual ~_PatternCursor() { };\n-    virtual void _M_next() = 0;\n-    virtual void _M_prev() = 0;\n-    virtual bool _M_at_end() const = 0;\n-  };\n-\n-  /// Provides a cursor into the specific target string.\n-  template<typename _FwdIterT>\n-    class _SpecializedCursor\n-    : public _PatternCursor\n-    {\n-    public:\n-      _SpecializedCursor(const _FwdIterT& __b, const _FwdIterT __e)\n-      : _M_b(__b), _M_c(__b), _M_e(__e)\n-      { }\n-\n-      typename std::iterator_traits<_FwdIterT>::value_type\n-      _M_current() const\n-      { return *_M_c; }\n-\n-      void\n-      _M_next()\n-      { ++_M_c; }\n-\n-      void\n-      _M_prev()\n-      { --_M_c; }\n-\n-      _FwdIterT\n-      _M_pos() const\n-      { return _M_c; }\n-\n-      const _FwdIterT&\n-      _M_begin() const\n-      { return _M_b; }\n-\n-      const _FwdIterT&\n-      _M_end() const\n-      { return _M_e; }\n-\n-      bool\n-      _M_at_end() const\n-      { return _M_c == _M_e; }\n-\n-    private:\n-      _FwdIterT _M_b;\n-      _FwdIterT _M_c;\n-      _FwdIterT _M_e;\n-    };\n-\n-  // Helper function to create a cursor specialized for an iterator class.\n-  template<typename _FwdIterT>\n-    inline _SpecializedCursor<_FwdIterT>\n-    __cursor(const _FwdIterT& __b, const _FwdIterT __e)\n-    { return _SpecializedCursor<_FwdIterT>(__b, __e); }\n-\n- //@} regex-detail\n-_GLIBCXX_END_NAMESPACE_VERSION\n-} // namespace __detail\n-} // namespace"}, {"sha": "7f06727bfae50ded55b030078fdac416a8b83c4d", "filename": "libstdc++-v3/include/bits/regex_error.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cb784b639c3de7505674b56f542c8b714d7df8a/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_error.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cb784b639c3de7505674b56f542c8b714d7df8a/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_error.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_error.h?ref=6cb784b639c3de7505674b56f542c8b714d7df8a", "patch": "@@ -45,7 +45,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n    * @name 5.3 Error Types\n    */\n   //@{\n- \n+\n   enum error_type\n     {\n       _S_error_collate,"}, {"sha": "afac8d0381617dbe9b50080b9dd279da890d8972", "filename": "libstdc++-v3/include/bits/regex_executor.h", "status": "added", "additions": 199, "deletions": 0, "changes": 199, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cb784b639c3de7505674b56f542c8b714d7df8a/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_executor.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cb784b639c3de7505674b56f542c8b714d7df8a/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_executor.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_executor.h?ref=6cb784b639c3de7505674b56f542c8b714d7df8a", "patch": "@@ -0,0 +1,199 @@\n+// class template regex -*- C++ -*-\n+\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/**\n+ *  @file bits/regex_executor.h\n+ *  This is an internal header file, included by other library headers.\n+ *  Do not attempt to use it directly. @headername{regex}\n+ */\n+\n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+  template<typename, typename>\n+    class basic_regex;\n+\n+  template<typename, typename>\n+    class match_results;\n+_GLIBCXX_END_NAMESPACE_VERSION\n+\n+namespace __detail\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+  /**\n+   * @addtogroup regex-detail\n+   * @{\n+   */\n+\n+  template<typename _BiIter, typename _Alloc,\n+    typename _CharT, typename _TraitsT>\n+    class _Executor\n+    {\n+    public:\n+      typedef match_results<_BiIter, _Alloc>   _ResultsT;\n+      typedef regex_constants::match_flag_type _FlagT;\n+\n+      virtual\n+      ~_Executor()\n+      { }\n+\n+      // Set matched when string exactly match the pattern.\n+      virtual bool\n+      _M_match() = 0;\n+\n+      // Set matched when some prefix of the string matches the pattern.\n+      virtual bool\n+      _M_search_from_first() = 0;\n+\n+    protected:\n+      typedef typename _NFA<_CharT, _TraitsT>::_SizeT _SizeT;\n+      _Executor(_BiIter    __begin,\n+                _BiIter    __end,\n+                _ResultsT& __results,\n+                _FlagT     __flags,\n+                _SizeT     __size)\n+      : _M_current(__begin), _M_end(__end),\n+        _M_results(__results), _M_flags(__flags)\n+      {\n+        __results.resize(__size + 2);\n+        for (auto __it : __results)\n+          __it.matched = false;\n+      }\n+\n+      _BiIter   _M_current;\n+      _BiIter   _M_end;\n+      _ResultsT& _M_results;\n+      _FlagT    _M_flags;\n+    };\n+\n+  template<typename _BiIter, typename _Alloc,\n+    typename _CharT, typename _TraitsT>\n+    class _DFSExecutor\n+    : public _Executor<_BiIter, _Alloc, _CharT, _TraitsT>\n+    {\n+    public:\n+      typedef _Executor<_BiIter, _Alloc, _CharT, _TraitsT> _BaseT;\n+      typedef _NFA<_CharT, _TraitsT>                       _RegexT;\n+      typedef typename _BaseT::_ResultsT                    _ResultsT;\n+      typedef regex_constants::match_flag_type             _FlagT;\n+\n+      _DFSExecutor(_BiIter        __begin,\n+                   _BiIter        __end,\n+                   _ResultsT&      __results,\n+                   const _RegexT& __nfa,\n+                   _FlagT         __flags)\n+      : _BaseT(__begin, __end, __results, __flags, __nfa._M_sub_count()),\n+        _M_nfa(__nfa)\n+      { }\n+\n+      bool\n+      _M_match()\n+      { return _M_dfs<true>(_M_nfa._M_start()); }\n+\n+      bool\n+      _M_search_from_first()\n+      { return _M_dfs<false>(_M_nfa._M_start()); }\n+\n+    private:\n+      template<bool __match_mode>\n+        bool\n+        _M_dfs(_StateIdT __i);\n+\n+      const _RegexT& _M_nfa;\n+    };\n+\n+  // It's essentially a variant of Single-Source-Shortest-Path problem, where,\n+  // the matching results is the final distance and should be minimized.\n+  // Instead of using Dijkstra Algorithm, I pick up the queue-optimizaed\n+  // (BFS-like) Bellman-Ford algorithm,\n+  // SPFA(http://en.wikipedia.org/wiki/Shortest_Path_Faster_Algorithm).\n+  //\n+  // Every entry of _M_covered saves the solution(grouping status) for every\n+  // matching head. When states transfer, solutions will be compared and\n+  // deduplicated(based on which greedy mode we have).\n+  //\n+  // Time complexity: O(_M_str_cur.size() * _M_nfa.size())\n+  // Space complexity: O(_M_nfa.size() * _M_nfa.mark_count())\n+  template<typename _BiIter, typename _Alloc,\n+    typename _CharT, typename _TraitsT>\n+    class _BFSExecutor\n+    : public _Executor<_BiIter, _Alloc, _CharT, _TraitsT>\n+    {\n+    public:\n+      typedef _Executor<_BiIter, _Alloc, _CharT, _TraitsT> _BaseT;\n+      typedef _NFA<_CharT, _TraitsT>                       _RegexT;\n+      typedef typename _BaseT::_ResultsT                   _ResultsT;\n+      typedef std::unique_ptr<_ResultsT>                   _ResultsPtr;\n+      typedef regex_constants::match_flag_type             _FlagT;\n+\n+      _BFSExecutor(_BiIter        __begin,\n+                   _BiIter        __end,\n+                   _ResultsT&      __results,\n+                   const _RegexT& __nfa,\n+                   _FlagT         __flags)\n+      : _BaseT(__begin, __end, __results, __flags, __nfa._M_sub_count()),\n+        _M_nfa(__nfa)\n+      {\n+        if (_M_nfa._M_start() != _S_invalid_state_id)\n+          _M_covered[_M_nfa._M_start()] =\n+            _ResultsPtr(new _ResultsT(this->_M_results));\n+        _M_e_closure();\n+      }\n+\n+      bool\n+      _M_match()\n+      { return _M_main_loop<true>(); }\n+\n+      bool\n+      _M_search_from_first()\n+      { return _M_main_loop<false>(); }\n+\n+    private:\n+      template<bool __match_mode>\n+        bool\n+        _M_main_loop();\n+\n+      void\n+      _M_e_closure();\n+\n+      void\n+      _M_move();\n+\n+      bool\n+      _M_match_less_than(_StateIdT __u, _StateIdT __v) const;\n+\n+      bool\n+      _M_includes_some() const;\n+\n+      std::map<_StateIdT, _ResultsPtr>     _M_covered;\n+      const _RegexT& _M_nfa;\n+    };\n+\n+ //@} regex-detail\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace __detail\n+} // namespace std\n+\n+#include <bits/regex_executor.tcc>"}, {"sha": "32d153762e410c7c085b59ba71494f9d690b8f48", "filename": "libstdc++-v3/include/bits/regex_executor.tcc", "status": "added", "additions": 252, "deletions": 0, "changes": 252, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cb784b639c3de7505674b56f542c8b714d7df8a/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_executor.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cb784b639c3de7505674b56f542c8b714d7df8a/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_executor.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_executor.tcc?ref=6cb784b639c3de7505674b56f542c8b714d7df8a", "patch": "@@ -0,0 +1,252 @@\n+// class template regex -*- C++ -*-\n+\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/**\n+ *  @file bits/regex_executor.tcc\n+ *  This is an internal header file, included by other library headers.\n+ *  Do not attempt to use it directly. @headername{regex}\n+ */\n+\n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+namespace __detail\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+  // TODO: This is too slow. Try to compile the NFA to a DFA.\n+  template<typename _BiIter, typename _Alloc,\n+    typename _CharT, typename _TraitsT>\n+  template<bool __match_mode>\n+    bool _DFSExecutor<_BiIter, _Alloc, _CharT, _TraitsT>::\n+    _M_dfs(_StateIdT __i)\n+    {\n+      auto& __current = this->_M_current;\n+      auto& __end = this->_M_end;\n+      auto& __results = this->_M_results;\n+      if (__i == _S_invalid_state_id)\n+        // This is not that certain. Need deeper investigate.\n+        return false;\n+      const auto& __state = _M_nfa[__i];\n+      bool __ret = false;\n+      switch (__state._M_opcode)\n+        {\n+        case _S_opcode_alternative:\n+          // Greedy mode by default. For non-greedy mode,\n+          // swap _M_alt and _M_next.\n+          // TODO: Add greedy mode option.\n+          __ret = _M_dfs<__match_mode>(__state._M_alt)\n+            || _M_dfs<__match_mode>(__state._M_next);\n+          break;\n+        case _S_opcode_subexpr_begin:\n+          __results.at(__state._M_subexpr).first = __current;\n+          __ret = _M_dfs<__match_mode>(__state._M_next);\n+          break;\n+        case _S_opcode_subexpr_end:\n+          __ret = _M_dfs<__match_mode>(__state._M_next);\n+          __results.at(__state._M_subexpr).second = __current;\n+          __results.at(__state._M_subexpr).matched = __ret;\n+          break;\n+        case _S_opcode_match:\n+          if (__current != __end && __state._M_matches(*__current))\n+            {\n+              ++__current;\n+              __ret = _M_dfs<__match_mode>(__state._M_next);\n+              --__current;\n+            }\n+          break;\n+        case _S_opcode_accept:\n+          if (__match_mode)\n+            __ret = __current == __end;\n+          else\n+            __ret = true;\n+          break;\n+        default:\n+          _GLIBCXX_DEBUG_ASSERT(false);\n+        }\n+      return __ret;\n+    }\n+\n+  template<typename _BiIter, typename _Alloc,\n+    typename _CharT, typename _TraitsT>\n+  template<bool __match_mode>\n+    bool _BFSExecutor<_BiIter, _Alloc, _CharT, _TraitsT>::\n+    _M_main_loop()\n+    {\n+      while (this->_M_current != this->_M_end)\n+        {\n+          if (!__match_mode)\n+            if (_M_includes_some())\n+              return true;\n+          _M_move();\n+          ++this->_M_current;\n+          _M_e_closure();\n+        }\n+      return _M_includes_some();\n+    }\n+\n+  // The SPFA approach.\n+  template<typename _BiIter, typename _Alloc,\n+    typename _CharT, typename _TraitsT>\n+    void _BFSExecutor<_BiIter, _Alloc, _CharT, _TraitsT>::\n+    _M_e_closure()\n+    {\n+      auto& __current = this->_M_current;\n+      std::queue<_StateIdT> __q;\n+      std::vector<bool> __in_q(_M_nfa.size(), false);\n+      for (auto& __it : _M_covered)\n+        {\n+          __in_q[__it.first] = true;\n+          __q.push(__it.first);\n+        }\n+      while (!__q.empty())\n+        {\n+          auto __u = __q.front();\n+          __q.pop();\n+          __in_q[__u] = false;\n+          const auto& __state = _M_nfa[__u];\n+\n+          // Can be implemented using method, but there're too much arguments.\n+          auto __add_visited_state = [&](_StateIdT __v)\n+          {\n+            if (__v == _S_invalid_state_id)\n+              return;\n+            if (_M_match_less_than(__u, __v))\n+              {\n+                _M_covered[__v] = _ResultsPtr(new _ResultsT(*_M_covered[__u]));\n+                // if a state is updated, it's outgoing neighbors should be\n+                // reconsidered too. Push them to the queue.\n+                if (!__in_q[__v])\n+                  {\n+                    __in_q[__v] = true;\n+                    __q.push(__v);\n+                  }\n+              }\n+          };\n+\n+          switch (__state._M_opcode)\n+            {\n+              case _S_opcode_alternative:\n+                __add_visited_state(__state._M_next);\n+                __add_visited_state(__state._M_alt);\n+                break;\n+              case _S_opcode_subexpr_begin:\n+                _M_covered[__u]->at(__state._M_subexpr).first = __current;\n+                __add_visited_state(__state._M_next);\n+                break;\n+              case _S_opcode_subexpr_end:\n+                _M_covered[__u]->at(__state._M_subexpr).second = __current;\n+                _M_covered[__u]->at(__state._M_subexpr).matched = true;\n+                __add_visited_state(__state._M_next);\n+                break;\n+              case _S_opcode_match:\n+                break;\n+              case _S_opcode_accept:\n+                __add_visited_state(__state._M_next);\n+                break;\n+              default:\n+                _GLIBCXX_DEBUG_ASSERT(false);\n+            }\n+        }\n+    }\n+\n+  template<typename _BiIter, typename _Alloc,\n+    typename _CharT, typename _TraitsT>\n+    void _BFSExecutor<_BiIter, _Alloc, _CharT, _TraitsT>::\n+    _M_move()\n+    {\n+      decltype(_M_covered) __next;\n+      for (auto& __it : _M_covered)\n+        {\n+          const auto& __state = _M_nfa[__it.first];\n+          if (__state._M_opcode == _S_opcode_match\n+              && __state._M_matches(*this->_M_current))\n+            if (_M_match_less_than(__it.first, __state._M_next)\n+                && __state._M_next != _S_invalid_state_id)\n+              __next[__state._M_next] = move(__it.second);\n+        }\n+      _M_covered = move(__next);\n+    }\n+\n+  template<typename _BiIter, typename _Alloc,\n+    typename _CharT, typename _TraitsT>\n+    bool _BFSExecutor<_BiIter, _Alloc, _CharT, _TraitsT>::\n+    _M_match_less_than(_StateIdT __u, _StateIdT __v) const\n+    {\n+      if (_M_covered.count(__u) == 0)\n+        return false;\n+      if (_M_covered.count(__v) > 0)\n+        return true;\n+      // TODO: Greedy and Non-greedy support\n+      return true;\n+    }\n+\n+  template<typename _BiIter, typename _Alloc,\n+    typename _CharT, typename _TraitsT>\n+    bool _BFSExecutor<_BiIter, _Alloc, _CharT, _TraitsT>::\n+    _M_includes_some() const\n+    {\n+      auto& __s = _M_nfa._M_final_states();\n+      auto& __t = _M_covered;\n+      if (__s.size() > 0 && __t.size() > 0)\n+        {\n+          auto __first = __s.begin();\n+          auto __second = __t.begin();\n+          while (__first != __s.end() && __second != __t.end())\n+            {\n+              if (*__first < __second->first)\n+                ++__first;\n+              else if (__second->first < *__first)\n+                ++__second;\n+              else\n+                {\n+                  this->_M_results = *__second->second;\n+                  return true;\n+                }\n+            }\n+        }\n+      return false;\n+    }\n+\n+  template<typename _BiIter, typename _Alloc,\n+    typename _CharT, typename _TraitsT>\n+    std::unique_ptr<_Executor<_BiIter, _Alloc, _CharT, _TraitsT>>\n+    __get_executor(_BiIter __b,\n+                   _BiIter __e,\n+                   match_results<_BiIter, _Alloc>& __m,\n+                   const basic_regex<_CharT, _TraitsT>& __re,\n+                   regex_constants::match_flag_type __flags)\n+    {\n+      typedef std::unique_ptr<_Executor<_BiIter, _Alloc, _CharT, _TraitsT>>\n+        _ExecutorPtr;\n+      typedef _DFSExecutor<_BiIter, _Alloc, _CharT, _TraitsT> _DFSExecutorT;\n+      auto __p = std::static_pointer_cast<_NFA<_CharT, _TraitsT>>\n+        (__re._M_automaton);\n+      if (__p->_M_has_backref)\n+        return _ExecutorPtr(new _DFSExecutorT(__b, __e, __m, *__p, __flags));\n+      return _ExecutorPtr(new _DFSExecutorT(__b, __e, __m, *__p, __flags));\n+    }\n+\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace __detail\n+} // namespace"}, {"sha": "474d8a291142e71d83eb020d22c5f87c92e2962e", "filename": "libstdc++-v3/include/bits/regex_grep_matcher.h", "status": "removed", "additions": 0, "deletions": 260, "changes": 260, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ee5b32cb20051b96dee793ef1c34355b43f8889/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_grep_matcher.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ee5b32cb20051b96dee793ef1c34355b43f8889/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_grep_matcher.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_grep_matcher.h?ref=5ee5b32cb20051b96dee793ef1c34355b43f8889", "patch": "@@ -1,260 +0,0 @@\n-// class template regex -*- C++ -*-\n-\n-// Copyright (C) 2010-2013 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 3, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// Under Section 7 of GPL version 3, you are granted additional\n-// permissions described in the GCC Runtime Library Exception, version\n-// 3.1, as published by the Free Software Foundation.\n-\n-// You should have received a copy of the GNU General Public License and\n-// a copy of the GCC Runtime Library Exception along with this program;\n-// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-// <http://www.gnu.org/licenses/>.\n-\n-/**\n- *  @file bits/regex_grep_matcher.h\n- *  This is an internal header file, included by other library headers.\n- *  Do not attempt to use it directly. @headername{regex}\n- */\n-\n-namespace std _GLIBCXX_VISIBILITY(default)\n-{\n-_GLIBCXX_BEGIN_NAMESPACE_VERSION\n-\n-  template<typename _BiIter>\n-    class sub_match;\n-\n-  template<typename _Bi_iter, typename _Allocator>\n-    class match_results;\n-\n-_GLIBCXX_END_NAMESPACE_VERSION\n-  \n-namespace __detail\n-{\n-_GLIBCXX_BEGIN_NAMESPACE_VERSION\n-\n-  /**\n-   *  @defgroup regex-detail Base and Implementation Classes\n-   *  @ingroup regex\n-   *  @{\n-   */\n-\n-  /// A _Results facade specialized for wrapping a templated match_results.\n-  template<typename _FwdIterT, typename _Alloc>\n-    class _SpecializedResults\n-    : public _Results\n-    {\n-    public:\n-      _SpecializedResults(const _Automaton::_SizeT __size,\n-\t\t\t  const _SpecializedCursor<_FwdIterT>& __cursor,\n-\t\t\t  match_results<_FwdIterT, _Alloc>& __m);\n-\n-      ~_SpecializedResults()\n-      {\n-        if (_M_managed)\n-          delete &_M_results;\n-      }\n-\n-    private:\n-      _SpecializedResults(const _SpecializedResults& __rhs)\n-      : _M_results(*new match_results<_FwdIterT, _Alloc>(__rhs._M_results)),\n-      _M_managed(true)\n-      { }\n-\n-    public:\n-      void\n-      _M_set_pos(int __i, int __j, const _PatternCursor& __pc);\n-\n-      void\n-      _M_set_range(int __i, const _PatternCursor& __pc)\n-      {\n-        typedef const _SpecializedCursor<_FwdIterT>& _CursorT;\n-        _CursorT __c = static_cast<_CursorT>(__pc);\n-        _M_results.at(__i).first = __c._M_begin();\n-        _M_results.at(__i).second = __c._M_end();\n-      }\n-\n-      void\n-      _M_set_matched(int __i, bool __is_matched)\n-      { _M_results.at(__i).matched = __is_matched; }\n-\n-      std::unique_ptr<_Results>\n-      _M_clone() const\n-      { return unique_ptr<_Results>(new _SpecializedResults(*this)); }\n-\n-      void\n-      _M_assign(const _Results& __rhs)\n-      {\n-        auto __r = static_cast<const _SpecializedResults*>(&__rhs);\n-        _M_results = __r->_M_results;\n-      }\n-\n-    private:\n-      match_results<_FwdIterT, _Alloc>& _M_results;\n-      bool                              _M_managed;\n-    };\n-\n-  template<typename _FwdIterT, typename _Alloc>\n-    _SpecializedResults<_FwdIterT, _Alloc>::\n-    _SpecializedResults(const _Automaton::_SizeT __size,\n-    \t\t\tconst _SpecializedCursor<_FwdIterT>& __cursor,\n-                        match_results<_FwdIterT, _Alloc>& __m)\n-    : _M_results(__m), _M_managed(false)\n-    {\n-      _M_results.clear();\n-      _M_results.reserve(__size + 2);\n-      _M_results.resize(__size);\n-      typename match_results<_FwdIterT, _Alloc>::value_type __sm;\n-      __sm.first = __sm.second = __cursor._M_begin();\n-      _M_results.push_back(__sm);\n-      __sm.first = __sm.second = __cursor._M_end();\n-      _M_results.push_back(__sm);\n-    }\n-\n-  template<typename _FwdIterT, typename _Alloc>\n-    void\n-    _SpecializedResults<_FwdIterT, _Alloc>::\n-    _M_set_pos(int __i, int __j, const _PatternCursor& __pc)\n-    { \n-      typedef const _SpecializedCursor<_FwdIterT>& _CursorT;\n-      _CursorT __c = static_cast<_CursorT>(__pc);\n-      if (__j == 0)\n-        _M_results.at(__i).first = __c._M_pos();\n-      else\n-        _M_results.at(__i).second = __c._M_pos();\n-    }\n-\n-  /// Executes a regular expression NFA/DFA over a range using a\n-  /// variant of the parallel execution algorithm featured in the grep\n-  /// utility, modified to use Laurikari tags.\n-  class _Grep_matcher\n-  {\n-  public:\n-    _Grep_matcher(_PatternCursor&                   __p,\n-                  _Results&                         __r,\n-                  const _AutomatonPtr&              __automaton,\n-                  regex_constants::match_flag_type  __flags)\n-    : _M_nfa(static_pointer_cast<_Nfa>(__automaton)),\n-      _M_str_cur(__p), _M_results(__r)\n-    { }\n-\n-    virtual\n-    ~_Grep_matcher()\n-    { }\n-\n-    // Set matched when string exactly match the pattern.\n-    virtual bool\n-    _M_match() = 0;\n-\n-    // Set matched when some prefix of the string matches the pattern.\n-    virtual bool\n-    _M_search_from_first() = 0;\n-\n-  protected:\n-    const std::shared_ptr<_Nfa>        _M_nfa;\n-    _PatternCursor&                    _M_str_cur;\n-    _Results&                          _M_results;\n-  };\n-\n-  // Time complexity: exponential\n-  // Space complexity: O(_M_str_cur.size())\n-  // _M_dfs() take a state, along with current string cursor(_M_str_cur),\n-  // trying to match current state with current character.\n-  // Only _S_opcode_match will consume a character.\n-  class _DFSMatcher\n-  : public _Grep_matcher\n-  {\n-  public:\n-    _DFSMatcher(_PatternCursor&                   __p,\n-                _Results&                         __r,\n-                const _AutomatonPtr&              __automaton,\n-                regex_constants::match_flag_type  __flags)\n-    : _Grep_matcher(__p, __r, __automaton, __flags)\n-    { }\n-\n-    bool\n-    _M_match()\n-    { return _M_dfs<true>(_M_nfa->_M_start()); }\n-\n-    bool\n-    _M_search_from_first()\n-    { return _M_dfs<false>(_M_nfa->_M_start()); }\n-\n-  private:\n-    template<bool __match_mode>\n-      bool\n-      _M_dfs(_StateIdT __i);\n-  };\n-\n-  // It's essentially a variant of Single-Source-Shortest-Path problem, where,\n-  // the matching results is the final distance and should be minimized.\n-  // Instead of using Dijkstra Algorithm, I pick up the queue-optimizaed\n-  // (BFS-like) Bellman-Ford algorithm,\n-  // SPFA(http://en.wikipedia.org/wiki/Shortest_Path_Faster_Algorithm).\n-  //\n-  // Every entry of _M_current saves the solution(grouping status) for every\n-  // matching head. When states transfer, solutions will be compared and\n-  // deduplicated(based on which greedy mode we have).\n-  //\n-  // Time complexity: O(_M_str_cur.size() * _M_nfa.size())\n-  // Space complexity: O(_M_nfa.size() * _M_nfa.mark_count())\n-  class _BFSMatcher\n-  : public _Grep_matcher\n-  {\n-  public:\n-    _BFSMatcher(_PatternCursor&                   __p,\n-                _Results&                         __r,\n-                const _AutomatonPtr&              __automaton,\n-                regex_constants::match_flag_type  __flags)\n-    : _Grep_matcher(__p, __r, __automaton, __flags)\n-    {\n-      if (_M_nfa->_M_start() != _S_invalid_state_id)\n-        _M_current[_M_nfa->_M_start()] = _M_results._M_clone();\n-      _M_e_closure();\n-    }\n-\n-    bool\n-    _M_match()\n-    { return _M_main_loop<true>(); }\n-\n-    bool\n-    _M_search_from_first()\n-    { return _M_main_loop<false>(); }\n-\n-  private:\n-    template<bool __match_mode>\n-      bool\n-      _M_main_loop();\n-\n-    void\n-    _M_e_closure();\n-\n-    void\n-    _M_move();\n-\n-    bool\n-    _M_match_less_than(_StateIdT __u, _StateIdT __v) const;\n-\n-    bool\n-    _M_includes_some() const;\n-\n-    std::map<_StateIdT, std::unique_ptr<_Results>>     _M_current;\n-  };\n-\n- //@} regex-detail\n-_GLIBCXX_END_NAMESPACE_VERSION\n-} // namespace __detail\n-} // namespace std\n-\n-#include <bits/regex_grep_matcher.tcc>"}, {"sha": "8ea7998474de8f2aa8feb6dd63223c7d57e1697b", "filename": "libstdc++-v3/include/bits/regex_grep_matcher.tcc", "status": "removed", "additions": 0, "deletions": 243, "changes": 243, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ee5b32cb20051b96dee793ef1c34355b43f8889/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_grep_matcher.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ee5b32cb20051b96dee793ef1c34355b43f8889/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_grep_matcher.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_grep_matcher.tcc?ref=5ee5b32cb20051b96dee793ef1c34355b43f8889", "patch": "@@ -1,243 +0,0 @@\n-// class template regex -*- C++ -*-\n-\n-// Copyright (C) 2010-2013 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 3, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// Under Section 7 of GPL version 3, you are granted additional\n-// permissions described in the GCC Runtime Library Exception, version\n-// 3.1, as published by the Free Software Foundation.\n-\n-// You should have received a copy of the GNU General Public License and\n-// a copy of the GCC Runtime Library Exception along with this program;\n-// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-// <http://www.gnu.org/licenses/>.\n-\n-/**\n- *  @file bits/regex_grep_matcher.tcc\n- *  This is an internal header file, included by other library headers.\n- *  Do not attempt to use it directly. @headername{regex}\n- */\n-\n-#include <regex>\n-\n-namespace std _GLIBCXX_VISIBILITY(default)\n-{\n-namespace __detail\n-{\n-_GLIBCXX_BEGIN_NAMESPACE_VERSION\n-\n-  // TODO: This is too slow. Try to compile the NFA to a DFA.\n-  template<bool __match_mode>\n-    bool _DFSMatcher::\n-    _M_dfs(_StateIdT __i)\n-    {\n-      if (__i == _S_invalid_state_id)\n-        // This is not that certain. Need deeper investigate.\n-        return false;\n-      const auto& __state = (*_M_nfa)[__i];\n-      bool __ret = false;\n-      switch (__state._M_opcode)\n-        {\n-        case _S_opcode_alternative:\n-          // Greedy mode by default. For non-greedy mode,\n-          // swap _M_alt and _M_next.\n-          // TODO: Add greedy mode option.\n-          __ret = _M_dfs<__match_mode>(__state._M_alt)\n-            || _M_dfs<__match_mode>(__state._M_next);\n-          break;\n-        case _S_opcode_subexpr_begin:\n-          __state._M_tagger(_M_str_cur, _M_results);\n-          __ret = _M_dfs<__match_mode>(__state._M_next);\n-          break;\n-        case _S_opcode_subexpr_end:\n-          __state._M_tagger(_M_str_cur, _M_results);\n-          __ret = _M_dfs<__match_mode>(__state._M_next);\n-          _M_results._M_set_matched(__state._M_subexpr, __ret);\n-          break;\n-        case _S_opcode_match:\n-          if (!_M_str_cur._M_at_end() && __state._M_matches(_M_str_cur))\n-            {\n-              _M_str_cur._M_next();\n-              __ret = _M_dfs<__match_mode>(__state._M_next);\n-              _M_str_cur._M_prev();\n-            }\n-          break;\n-        case _S_opcode_accept:\n-          if (__match_mode)\n-            __ret = _M_str_cur._M_at_end();\n-          else\n-            __ret = true;\n-          break;\n-        default:\n-          _GLIBCXX_DEBUG_ASSERT(false);\n-        }\n-      return __ret;\n-    }\n-\n-  template<bool __match_mode>\n-    bool _BFSMatcher::\n-    _M_main_loop()\n-    {\n-      while (!_M_str_cur._M_at_end())\n-        {\n-          if (!__match_mode)\n-            if (_M_includes_some())\n-              return true;\n-          _M_move();\n-          _M_str_cur._M_next();\n-          _M_e_closure();\n-        }\n-      return _M_includes_some();\n-    }\n-\n-  // The SPFA approach.\n-  // FIXME: move it to src/c++11 when it's stable, and make it not inlined.\n-  inline\n-  void _BFSMatcher::\n-  _M_e_closure()\n-  {\n-    std::queue<_StateIdT> __q;\n-    std::vector<bool> __in_q(_M_nfa->size(), false);\n-    for (auto& __it : _M_current)\n-      {\n-        __in_q[__it.first] = true;\n-        __q.push(__it.first);\n-      }\n-    while (!__q.empty())\n-      {\n-        auto __u = __q.front();\n-        __q.pop();\n-        __in_q[__u] = false;\n-        const auto& __state = (*_M_nfa)[__u];\n-\n-        // Can be implemented using method, but there're too much arguments.\n-        auto __add_visited_state = [&](_StateIdT __v)\n-        {\n-          if (__v == _S_invalid_state_id)\n-            return;\n-          if (_M_match_less_than(__u, __v))\n-            {\n-              _M_current[__v] = _M_current[__u]->_M_clone();\n-              // if a state is updated, it's outgoing neighbors should be\n-              // reconsidered too. Push them to the queue.\n-              if (!__in_q[__v])\n-                {\n-                  __in_q[__v] = true;\n-                  __q.push(__v);\n-                }\n-            }\n-        };\n-\n-        switch (__state._M_opcode)\n-          {\n-            case _S_opcode_alternative:\n-              __add_visited_state(__state._M_next);\n-              __add_visited_state(__state._M_alt);\n-              break;\n-            case _S_opcode_subexpr_begin:\n-              __state._M_tagger(_M_str_cur, *_M_current[__u]);\n-              __add_visited_state(__state._M_next);\n-              break;\n-            case _S_opcode_subexpr_end:\n-              __state._M_tagger(_M_str_cur, *_M_current[__u]);\n-              _M_current[__u]->_M_set_matched(__state._M_subexpr, true);\n-              __add_visited_state(__state._M_next);\n-              break;\n-            case _S_opcode_match:\n-              break;\n-            case _S_opcode_accept:\n-              __add_visited_state(__state._M_next);\n-              break;\n-            default:\n-              _GLIBCXX_DEBUG_ASSERT(false);\n-          }\n-      }\n-  }\n-\n-  // FIXME: move it to src/c++11 when it's stable, and make it not inlined.\n-  inline\n-  void _BFSMatcher::\n-  _M_move()\n-  {\n-    decltype(_M_current) __next;\n-    for (auto& __it : _M_current)\n-      {\n-        const auto& __state = (*_M_nfa)[__it.first];\n-        if (__state._M_opcode == _S_opcode_match\n-            && __state._M_matches(_M_str_cur))\n-          if (_M_match_less_than(__it.first, __state._M_next)\n-              && __state._M_next != _S_invalid_state_id)\n-            __next[__state._M_next] = __it.second->_M_clone();\n-      }\n-    _M_current = move(__next);\n-  }\n-\n-  // FIXME: move it to src/c++11 when it's stable, and make it not inlined.\n-  inline\n-  bool _BFSMatcher::\n-  _M_match_less_than(_StateIdT __u, _StateIdT __v) const\n-  {\n-    if (_M_current.count(__u) == 0)\n-      return false;\n-    if (_M_current.count(__v) > 0)\n-      return true;\n-    // TODO: Greedy and Non-greedy support\n-    return true;\n-  }\n-\n-  // FIXME: move it to src/c++11 when it's stable, and make it not inlined.\n-  inline\n-  bool _BFSMatcher::\n-  _M_includes_some() const\n-  {\n-    auto& __s = _M_nfa->_M_final_states();\n-    auto& __t = _M_current;\n-    if (__s.size() > 0 && __t.size() > 0)\n-      {\n-\tauto __first = __s.begin();\n-\tauto __second = __t.begin();\n-\twhile (__first != __s.end() && __second != __t.end())\n-\t  {\n-\t    if (*__first < __second->first)\n-\t      ++__first;\n-\t    else if (__second->first < *__first)\n-\t      ++__second;\n-\t    else\n-              {\n-                _M_results._M_assign(*__second->second);\n-                return true;\n-              }\n-\t  }\n-      }\n-    return false;\n-  }\n-\n-  // FIXME: move it to src/c++11 when it's stable, and make it not inlined.\n-  inline\n-  std::unique_ptr<_Grep_matcher> _Nfa::\n-  _M_get_matcher(_PatternCursor&                   __p,\n-                 _Results&                         __r,\n-                 const _AutomatonPtr&              __a,\n-                 regex_constants::match_flag_type  __flags)\n-  {\n-    if (_M_has_back_ref)\n-      return unique_ptr<_Grep_matcher>(\n-        new _DFSMatcher(__p, __r, __a, __flags));\n-    else\n-      return unique_ptr<_Grep_matcher>(\n-        new _BFSMatcher(__p, __r, __a, __flags));\n-  }\n-\n-_GLIBCXX_END_NAMESPACE_VERSION\n-} // namespace __detail\n-} // namespace"}, {"sha": "b4ac452fbaa3db4f15c77a3815195fb54cbe5f57", "filename": "libstdc++-v3/include/bits/regex_nfa.h", "status": "removed", "additions": 0, "deletions": 491, "changes": 491, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ee5b32cb20051b96dee793ef1c34355b43f8889/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_nfa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ee5b32cb20051b96dee793ef1c34355b43f8889/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_nfa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_nfa.h?ref=5ee5b32cb20051b96dee793ef1c34355b43f8889", "patch": "@@ -1,491 +0,0 @@\n-// class template regex -*- C++ -*-\n-\n-// Copyright (C) 2010-2013 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 3, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// Under Section 7 of GPL version 3, you are granted additional\n-// permissions described in the GCC Runtime Library Exception, version\n-// 3.1, as published by the Free Software Foundation.\n-\n-// You should have received a copy of the GNU General Public License and\n-// a copy of the GCC Runtime Library Exception along with this program;\n-// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-// <http://www.gnu.org/licenses/>.\n-\n-/**\n- *  @file bits/regex_nfa.h\n- *  This is an internal header file, included by other library headers.\n- *  Do not attempt to use it directly. @headername{regex}\n- */\n-\n-namespace std _GLIBCXX_VISIBILITY(default)\n-{\n-namespace __detail\n-{\n-_GLIBCXX_BEGIN_NAMESPACE_VERSION\n-\n-  /**\n-   * @addtogroup regex-detail\n-   * @{\n-   */\n-\n-  /// Provides a generic facade for a templated match_results.\n-  struct _Results\n-  {\n-    virtual\n-    ~_Results()\n-    { }\n-    virtual void _M_set_pos(int __i, int __j, const _PatternCursor& __p) = 0;\n-    virtual void _M_set_matched(int __i, bool __is_matched) = 0;\n-    virtual std::unique_ptr<_Results> _M_clone() const = 0;\n-    virtual void _M_assign(const _Results& __rhs) = 0;\n-  };\n-\n-  class _Grep_matcher;\n-  class _Automaton;\n-\n-  /// Generic shared pointer to an automaton.\n-  typedef std::shared_ptr<_Automaton> _AutomatonPtr;\n-\n-  /// Base class for, um, automata.  Could be an NFA or a DFA.  Your choice.\n-  class _Automaton\n-  {\n-  public:\n-    typedef unsigned int _SizeT;\n-\n-  public:\n-    virtual\n-    ~_Automaton() { }\n-\n-    virtual _SizeT\n-    _M_sub_count() const = 0;\n-\n-    virtual std::unique_ptr<_Grep_matcher>\n-    _M_get_matcher(_PatternCursor&                   __p,\n-                   _Results&                         __r,\n-                   const _AutomatonPtr&              __automaton,\n-                   regex_constants::match_flag_type  __flags) = 0;\n-\n-#ifdef _GLIBCXX_DEBUG\n-    virtual std::ostream&\n-    _M_dot(std::ostream& __ostr) const = 0;\n-#endif\n-  };\n-\n-  /// Operation codes that define the type of transitions within the base NFA\n-  /// that represents the regular expression.\n-  enum _Opcode\n-  {\n-      _S_opcode_unknown       =   0,\n-      _S_opcode_alternative   =   1,\n-      _S_opcode_subexpr_begin =   4,\n-      _S_opcode_subexpr_end   =   5,\n-      _S_opcode_match         = 100,\n-      _S_opcode_accept        = 255\n-  };\n-\n-  /// Tags current state (for subexpr begin/end).\n-  typedef std::function<void (const _PatternCursor&, _Results&)> _Tagger;\n-\n-  /// Start state tag.\n-  template<typename _FwdIterT, typename _TraitsT>\n-    struct _StartTagger\n-    {\n-      explicit\n-      _StartTagger(int __i)\n-      : _M_index(__i)\n-      { }\n-\n-      void\n-      operator()(const _PatternCursor& __pc, _Results& __r)\n-      { __r._M_set_pos(_M_index, 0, __pc); }\n-\n-      int       _M_index;\n-    };\n-\n-  /// End state tag.\n-  template<typename _FwdIterT, typename _TraitsT>\n-    struct _EndTagger\n-    {\n-      explicit\n-      _EndTagger(int __i)\n-      : _M_index(__i)\n-      { }\n-\n-      void\n-      operator()(const _PatternCursor& __pc, _Results& __r)\n-      { __r._M_set_pos(_M_index, 1, __pc); }\n-\n-      int       _M_index;\n-    };\n-\n-  // TODO For now we use an all-in-one comparator. In the future there may be\n-  // optimizations based on regex_traits::translate and regex_transform.\n-  template<typename _InIterT, typename _TraitsT>\n-    struct _Comparator\n-    {\n-      typedef regex_constants::syntax_option_type _FlagT;\n-      typedef typename _TraitsT::char_type        _CharT;\n-      typedef std::basic_string<_CharT>           _StringT;\n-\n-      _Comparator(_FlagT __flags, const _TraitsT& __traits)\n-      : _M_flags(__flags), _M_traits(__traits)\n-      { }\n-\n-      bool\n-      _M_equ(_CharT __a, _CharT __b) const;\n-\n-      bool\n-      _M_le(_CharT __a, _CharT __b) const;\n-\n-      _FlagT                              _M_flags;\n-      _TraitsT                            _M_traits;\n-    };\n-\n-  /// Indicates if current state matches cursor current.\n-  typedef std::function<bool (const _PatternCursor&)> _Matcher;\n-\n-  /// Matches any character\n-  inline bool\n-  _AnyMatcher(const _PatternCursor&)\n-  { return true; }\n-\n-  /// Matches a single character\n-  template<typename _InIterT, typename _TraitsT>\n-    struct _CharMatcher\n-    : public _Comparator<_InIterT, _TraitsT>\n-    {\n-      typedef _Comparator<_InIterT, _TraitsT>     _BaseT;\n-      typedef typename _TraitsT::char_type        _CharT;\n-      typedef regex_constants::syntax_option_type _FlagT;\n-\n-      explicit\n-      _CharMatcher(_CharT __c, _FlagT __flags, const _TraitsT& __t)\n-      : _BaseT(__flags, __t), _M_c(__c)\n-      { }\n-\n-      bool\n-      operator()(const _PatternCursor& __pc) const\n-      {\n-\ttypedef const _SpecializedCursor<_InIterT>& _CursorT;\n-\t_CursorT __c = static_cast<_CursorT>(__pc);\n-        return this->_M_equ(__c._M_current(), _M_c);\n-      }\n-\n-      _CharT       _M_c;\n-    };\n-\n-  /// Matches a character range (bracket expression)\n-  template<typename _InIterT, typename _TraitsT>\n-    struct _BracketMatcher\n-    : public _Comparator<_InIterT, _TraitsT>\n-    {\n-      typedef _Comparator<_InIterT, _TraitsT>     _BaseT;\n-      typedef typename _TraitsT::char_class_type  _CharClassT;\n-      typedef regex_constants::syntax_option_type _FlagT;\n-      typedef typename _TraitsT::char_type        _CharT;\n-      typedef std::basic_string<_CharT>           _StringT;\n-\n-      explicit\n-      _BracketMatcher(bool __is_non_matching,\n-                    _FlagT __flags,\n-                    const _TraitsT& __t)\n-      : _BaseT(__flags, __t), _M_flags(__flags), _M_traits(__t),\n-      _M_is_non_matching(__is_non_matching), _M_class_set(0)\n-      { }\n-\n-      bool\n-      operator()(const _PatternCursor& __pc) const;\n-\n-      void\n-      _M_add_char(_CharT __c)\n-      { _M_char_set.push_back(__c); }\n-\n-      void\n-      _M_add_collating_element(const _StringT& __s)\n-      {\n-        auto __st = _M_traits.lookup_collatename(&*__s.begin(), &*__s.end());\n-        if (__st.empty())\n-          __throw_regex_error(regex_constants::error_collate);\n-        // TODO: digraph\n-        _M_char_set.push_back(__st[0]);\n-      }\n-\n-      void\n-      _M_add_equivalence_class(const _StringT& __s)\n-      {\n-        _M_add_character_class(\n-          _M_traits.transform_primary(&*__s.begin(), &*__s.end()));\n-      }\n-\n-      void\n-      _M_add_character_class(const _StringT& __s)\n-      {\n-        auto __st = _M_traits.lookup_classname(\n-          &*__s.begin(), &*__s.end(), (_M_flags & regex_constants::icase));\n-        if (__st == 0)\n-          __throw_regex_error(regex_constants::error_ctype);\n-        _M_class_set |= __st;\n-      }\n-\n-      void\n-      _M_make_range(_CharT __l, _CharT __r)\n-      {\n-        if (!this->_M_le(__l, __r))\n-          __throw_regex_error(regex_constants::error_range);\n-        _M_range_set.push_back(make_pair(__l, __r));\n-      }\n-\n-      _FlagT                              _M_flags;\n-      _TraitsT                            _M_traits;\n-      bool                                _M_is_non_matching;\n-      std::vector<_CharT>                 _M_char_set;\n-      std::vector<pair<_CharT, _CharT>>   _M_range_set;\n-      _CharClassT                         _M_class_set;\n-    };\n-\n-  /// Identifies a state in the NFA.\n-  typedef int _StateIdT;\n-\n-  /// The special case in which a state identifier is not an index.\n-  static const _StateIdT _S_invalid_state_id  = -1;\n-\n-\n-  /**\n-   * @brief struct _State\n-   *\n-   * An individual state in an NFA\n-   *\n-   * In this case a \"state\" is an entry in the NFA definition coupled\n-   * with its outgoing transition(s).  All states have a single outgoing\n-   * transition, except for accepting states (which have no outgoing\n-   * transitions) and alt states, which have two outgoing transitions.\n-   */\n-  struct _State\n-  {\n-    typedef int  _OpcodeT;\n-\n-    _OpcodeT     _M_opcode;    // type of outgoing transition\n-    _StateIdT    _M_next;      // outgoing transition\n-    _StateIdT    _M_alt;       // for _S_opcode_alternative\n-    unsigned int _M_subexpr;   // for _S_opcode_subexpr_*\n-    _Tagger      _M_tagger;    // for _S_opcode_subexpr_*\n-    _Matcher     _M_matches;   // for _S_opcode_match\n-\n-    explicit _State(_OpcodeT __opcode)\n-    : _M_opcode(__opcode), _M_next(_S_invalid_state_id)\n-    { }\n-\n-    _State(const _Matcher& __m)\n-    : _M_opcode(_S_opcode_match), _M_next(_S_invalid_state_id), _M_matches(__m)\n-    { }\n-\n-    _State(_OpcodeT __opcode, unsigned int __s, const _Tagger& __t)\n-    : _M_opcode(__opcode), _M_next(_S_invalid_state_id), _M_subexpr(__s),\n-      _M_tagger(__t)\n-    { }\n-\n-    _State(_StateIdT __next, _StateIdT __alt)\n-    : _M_opcode(_S_opcode_alternative), _M_next(__next), _M_alt(__alt)\n-    { }\n-\n-#ifdef _GLIBCXX_DEBUG\n-    std::ostream&\n-    _M_print(std::ostream& ostr) const;\n-\n-    // Prints graphviz dot commands for state.\n-    std::ostream&\n-    _M_dot(std::ostream& __ostr, _StateIdT __id) const;\n-#endif\n-  };\n-\n-  \n-  /// The Grep Matcher works on sets of states.  Here are sets of states.\n-  typedef std::set<_StateIdT> _StateSet;\n-\n-  /**\n-   * @brief struct _Nfa\n-   *\n-   * A collection of all states making up an NFA.\n-   *\n-   * An NFA is a 4-tuple M = (K, S, s, F), where\n-   *    K is a finite set of states,\n-   *    S is the alphabet of the NFA,\n-   *    s is the initial state,\n-   *    F is a set of final (accepting) states.\n-   *\n-   * This NFA class is templated on S, a type that will hold values of the\n-   * underlying alphabet (without regard to semantics of that alphabet).  The\n-   * other elements of the tuple are generated during construction of the NFA\n-   * and are available through accessor member functions.\n-   */\n-  class _Nfa\n-  : public _Automaton, public std::vector<_State>\n-  {\n-  public:\n-    typedef _State                              _StateT;\n-    typedef unsigned int                        _SizeT;\n-    typedef regex_constants::syntax_option_type _FlagT;\n-\n-    _Nfa(_FlagT __f)\n-    : _M_flags(__f), _M_start_state(0), _M_subexpr_count(0),\n-    // TODO: BFS by default. Your choice. Need to be set by the compiler.\n-    _M_has_back_ref(false)\n-    { }\n-\n-    ~_Nfa()\n-    { }\n-\n-    _FlagT\n-    _M_options() const\n-    { return _M_flags; }\n-\n-    _StateIdT\n-    _M_start() const\n-    { return _M_start_state; }\n-\n-    const _StateSet&\n-    _M_final_states() const\n-    { return _M_accepting_states; }\n-\n-    _SizeT\n-    _M_sub_count() const\n-    { return _M_subexpr_count; }\n-\n-    _StateIdT\n-    _M_insert_accept()\n-    {\n-      this->push_back(_StateT(_S_opcode_accept));\n-      _M_accepting_states.insert(this->size()-1);\n-      return this->size()-1;\n-    }\n-\n-    _StateIdT\n-    _M_insert_alt(_StateIdT __next, _StateIdT __alt)\n-    {\n-      this->push_back(_StateT(__next, __alt));\n-      return this->size()-1;\n-    }\n-\n-    _StateIdT\n-    _M_insert_matcher(_Matcher __m)\n-    {\n-      this->push_back(_StateT(__m));\n-      return this->size()-1;\n-    }\n-\n-    _StateIdT\n-    _M_insert_subexpr_begin(const _Tagger& __t)\n-    {\n-      this->push_back(_StateT(_S_opcode_subexpr_begin, _M_subexpr_count++,\n-\t\t\t      __t));\n-      return this->size()-1;\n-    }\n-\n-    _StateIdT \n-    _M_insert_subexpr_end(unsigned int __i, const _Tagger& __t)\n-    {\n-      this->push_back(_StateT(_S_opcode_subexpr_end, __i, __t));\n-      return this->size()-1;\n-    }\n-\n-    void\n-    _M_set_back_ref(bool __b)\n-    { _M_has_back_ref = __b; }\n-\n-    std::unique_ptr<_Grep_matcher>\n-    _M_get_matcher(_PatternCursor&                   __p,\n-                   _Results&                         __r,\n-                   const _AutomatonPtr&              __automaton,\n-                   regex_constants::match_flag_type  __flags);\n-\n-#ifdef _GLIBCXX_DEBUG\n-    std::ostream&\n-    _M_dot(std::ostream& __ostr) const;\n-#endif\n-\n-  private:\n-    _FlagT     _M_flags;\n-    _StateIdT  _M_start_state;\n-    _StateSet  _M_accepting_states;\n-    _SizeT     _M_subexpr_count;\n-    bool       _M_has_back_ref;\n-  };\n-\n-  /// Describes a sequence of one or more %_State, its current start\n-  /// and end(s).  This structure contains fragments of an NFA during\n-  /// construction.\n-  class _StateSeq\n-  {\n-  public:\n-    // Constructs a single-node sequence\n-    _StateSeq(_Nfa& __ss, _StateIdT __s, _StateIdT __e = _S_invalid_state_id)\n-    : _M_nfa(__ss), _M_start(__s), _M_end1(__s), _M_end2(__e)\n-    { }\n-    // Constructs a split sequence from two other sequencces\n-    _StateSeq(const _StateSeq& __e1, const _StateSeq& __e2)\n-    : _M_nfa(__e1._M_nfa),\n-      _M_start(_M_nfa._M_insert_alt(__e1._M_start, __e2._M_start)),\n-      _M_end1(__e1._M_end1), _M_end2(__e2._M_end1)\n-    { }\n-\n-    // Constructs a split sequence from a single sequence\n-    _StateSeq(const _StateSeq& __e, _StateIdT __id)\n-    : _M_nfa(__e._M_nfa),\n-      _M_start(_M_nfa._M_insert_alt(__id, __e._M_start)),\n-      _M_end1(__id), _M_end2(__e._M_end1)\n-    { }\n-\n-    // Constructs a copy of a %_StateSeq\n-    _StateSeq(const _StateSeq& __rhs)\n-    : _M_nfa(__rhs._M_nfa), _M_start(__rhs._M_start),\n-      _M_end1(__rhs._M_end1), _M_end2(__rhs._M_end2)\n-    { }\n-\n-\n-    _StateSeq& operator=(const _StateSeq& __rhs);\n-\n-    _StateIdT\n-    _M_front() const\n-    { return _M_start; }\n-\n-    // Extends a sequence by one.\n-    void\n-    _M_push_back(_StateIdT __id);\n-\n-    // Extends and maybe joins a sequence.\n-    void\n-    _M_append(_StateIdT __id);\n-\n-    void\n-    _M_append(_StateSeq& __rhs);\n-\n-    // Clones an entire sequence.\n-    _StateIdT\n-    _M_clone();\n-\n-  private:\n-    _Nfa&     _M_nfa;\n-    _StateIdT _M_start;\n-    _StateIdT _M_end1;\n-    _StateIdT _M_end2;\n-\n-  };\n-\n- //@} regex-detail\n-_GLIBCXX_END_NAMESPACE_VERSION\n-} // namespace __detail\n-} // namespace std\n-\n-#include <bits/regex_nfa.tcc>\n-"}, {"sha": "12f6fe825a541345ffeedc4b38a83870a9e6d2c0", "filename": "libstdc++-v3/include/bits/regex_nfa.tcc", "status": "removed", "additions": 0, "deletions": 232, "changes": 232, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ee5b32cb20051b96dee793ef1c34355b43f8889/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_nfa.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ee5b32cb20051b96dee793ef1c34355b43f8889/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_nfa.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_nfa.tcc?ref=5ee5b32cb20051b96dee793ef1c34355b43f8889", "patch": "@@ -1,232 +0,0 @@\n-// class template regex -*- C++ -*-\n-\n-// Copyright (C) 2010-2013 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 3, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// Under Section 7 of GPL version 3, you are granted additional\n-// permissions described in the GCC Runtime Library Exception, version\n-// 3.1, as published by the Free Software Foundation.\n-\n-// You should have received a copy of the GNU General Public License and\n-// a copy of the GCC Runtime Library Exception along with this program;\n-// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-// <http://www.gnu.org/licenses/>.\n-\n-/**\n- * @file bits/regex_nfa.tcc\n- *  This is an internal header file, included by other library headers.\n- *  Do not attempt to use it directly. @headername{regex}\n- */\n-#include <regex>\n-\n-namespace std _GLIBCXX_VISIBILITY(default)\n-{\n-namespace __detail\n-{\n-_GLIBCXX_BEGIN_NAMESPACE_VERSION\n-\n-  template<typename _InIterT, typename _TraitsT>\n-    bool _BracketMatcher<_InIterT, _TraitsT>::\n-    operator()(const _PatternCursor& __pc) const\n-    {\n-      typedef const _SpecializedCursor<_InIterT>& _CursorT;\n-      _CursorT __c = static_cast<_CursorT>(__pc);\n-      _CharT __ch = __c._M_current();\n-      bool __ret = false;\n-      for (auto __c : _M_char_set)\n-        if (this->_M_equ(__c, __ch))\n-          {\n-            __ret = true;\n-            break;\n-          }\n-      if (!__ret && _M_traits.isctype(__ch, _M_class_set))\n-        __ret = true;\n-      else\n-        {\n-          for (auto& __it : _M_range_set)\n-            if (this->_M_le(__it.first, __ch) && this->_M_le(__ch, __it.second))\n-              {\n-                __ret = true;\n-                break;\n-              }\n-        }\n-      if (_M_is_non_matching)\n-        __ret = !__ret;\n-      return __ret;\n-    }\n-\n-  template<typename _InIterT, typename _TraitsT>\n-    bool _Comparator<_InIterT, _TraitsT>::\n-    _M_equ(_CharT __a, _CharT __b) const\n-    {\n-      if (_M_flags & regex_constants::icase)\n-        return _M_traits.translate_nocase(__a)\n-          == _M_traits.translate_nocase(__b);\n-      if (_M_flags & regex_constants::collate)\n-        return _M_traits.translate(__a) == _M_traits.translate(__b);\n-      return __a == __b;\n-    }\n-\n-  template<typename _InIterT, typename _TraitsT>\n-    bool _Comparator<_InIterT, _TraitsT>::\n-    _M_le(_CharT __a, _CharT __b) const\n-    {\n-      _StringT __str1 = _StringT(1,\n-                                 _M_flags & regex_constants::icase\n-                                 ? _M_traits.translate_nocase(__a)\n-                                 : _M_traits.translate(__a));\n-      _StringT __str2 = _StringT(1,\n-                                 _M_flags & regex_constants::icase\n-                                 ? _M_traits.translate_nocase(__b)\n-                                 : _M_traits.translate(__b));\n-      return _M_traits.transform(__str1.begin(), __str1.end())\n-        <= _M_traits.transform(__str2.begin(), __str2.end());\n-    }\n-\n-#ifdef _GLIBCXX_DEBUG\n-inline std::ostream& _State::\n-_M_print(std::ostream& ostr) const\n-{\n-  switch (_M_opcode)\n-  {\n-    case _S_opcode_alternative:\n-      ostr << \"alt next=\" << _M_next << \" alt=\" << _M_alt;\n-      break;\n-    case _S_opcode_subexpr_begin:\n-      ostr << \"subexpr begin next=\" << _M_next << \" index=\" << _M_subexpr;\n-      break;\n-    case _S_opcode_subexpr_end:\n-      ostr << \"subexpr end next=\" << _M_next << \" index=\" << _M_subexpr;\n-      break;\n-    case _S_opcode_match:\n-      ostr << \"match next=\" << _M_next;\n-      break;\n-    case _S_opcode_accept:\n-      ostr << \"accept next=\" << _M_next;\n-      break;\n-    default:\n-      ostr << \"unknown next=\" << _M_next;\n-      break;\n-  }\n-  return ostr;\n-}\n-\n-// Prints graphviz dot commands for state.\n-inline std::ostream& _State::\n-_M_dot(std::ostream& __ostr, _StateIdT __id) const\n-{\n-  switch (_M_opcode)\n-  {\n-    case _S_opcode_alternative:\n-      __ostr << __id << \" [label=\\\"\" << __id << \"\\\\nALT\\\"];\\n\" \n-             << __id << \" -> \" << _M_next\n-             << \" [label=\\\"epsilon\\\", tailport=\\\"s\\\"];\\n\"\n-             << __id << \" -> \" << _M_alt \n-             << \" [label=\\\"epsilon\\\", tailport=\\\"n\\\"];\\n\";\n-      break;\n-    case _S_opcode_subexpr_begin:\n-      __ostr << __id << \" [label=\\\"\" << __id << \"\\\\nSBEGIN \"\n-             << _M_subexpr << \"\\\"];\\n\" \n-             << __id << \" -> \" << _M_next << \" [label=\\\"epsilon\\\"];\\n\";\n-      break;\n-    case _S_opcode_subexpr_end:\n-      __ostr << __id << \" [label=\\\"\" << __id << \"\\\\nSEND \"\n-             << _M_subexpr << \"\\\"];\\n\" \n-             << __id << \" -> \" << _M_next << \" [label=\\\"epsilon\\\"];\\n\";\n-      break;\n-    case _S_opcode_match:\n-      __ostr << __id << \" [label=\\\"\" << __id << \"\\\\nMATCH\\\"];\\n\" \n-             << __id << \" -> \" << _M_next << \" [label=\\\"<match>\\\"];\\n\";\n-      break;\n-    case _S_opcode_accept:\n-      __ostr << __id << \" [label=\\\"\" << __id << \"\\\\nACC\\\"];\\n\" ;\n-      break;\n-    default:\n-      __ostr << __id << \" [label=\\\"\" << __id << \"\\\\nUNK\\\"];\\n\" \n-             << __id << \" -> \" << _M_next << \" [label=\\\"?\\\"];\\n\";\n-      break;\n-  }\n-  return __ostr;\n-}\n-\n-inline std::ostream& _Nfa::\n-_M_dot(std::ostream& __ostr) const\n-{\n-  __ostr << \"digraph _Nfa {\\n\"\n-   << \"  rankdir=LR;\\n\";\n-  for (unsigned int __i = 0; __i < this->size(); ++__i)\n-  { this->at(__i)._M_dot(__ostr, __i); }\n-  __ostr << \"}\\n\";\n-  return __ostr;\n-}\n-#endif\n-\n-inline _StateSeq& _StateSeq::\n-operator=(const _StateSeq& __rhs)\n-{\n-  _M_start = __rhs._M_start;\n-  _M_end1  = __rhs._M_end1;\n-  _M_end2  = __rhs._M_end2;\n-  return *this;\n-}\n-\n-inline void _StateSeq::\n-_M_push_back(_StateIdT __id)\n-{\n-  if (_M_end1 != _S_invalid_state_id)\n-    _M_nfa[_M_end1]._M_next = __id;\n-  _M_end1 = __id;\n-}\n-\n-inline void _StateSeq::\n-_M_append(_StateIdT __id)\n-{\n-  if (_M_end2 != _S_invalid_state_id)\n-  {\n-    if (_M_end2 == _M_end1)\n-      _M_nfa[_M_end2]._M_alt = __id;\n-    else\n-      _M_nfa[_M_end2]._M_next = __id;\n-    _M_end2 = _S_invalid_state_id;\n-  }\n-  if (_M_end1 != _S_invalid_state_id)\n-    _M_nfa[_M_end1]._M_next = __id;\n-  _M_end1 = __id;\n-}\n-\n-inline void _StateSeq::\n-_M_append(_StateSeq& __rhs)\n-{\n-  if (_M_end2 != _S_invalid_state_id)\n-  {\n-    if (_M_end2 == _M_end1)\n-      _M_nfa[_M_end2]._M_alt = __rhs._M_start;\n-    else\n-      _M_nfa[_M_end2]._M_next = __rhs._M_start;\n-    _M_end2 = _S_invalid_state_id;\n-  }\n-  if (__rhs._M_end2 != _S_invalid_state_id)\n-    _M_end2 = __rhs._M_end2;\n-  if (_M_end1 != _S_invalid_state_id)\n-    _M_nfa[_M_end1]._M_next = __rhs._M_start;\n-  _M_end1 = __rhs._M_end1;\n-}\n-\n-// @todo implement this function.\n-inline _StateIdT _StateSeq::\n-_M_clone()\n-{ return 0; }\n-\n-_GLIBCXX_END_NAMESPACE_VERSION\n-} // namespace __detail\n-} // namespace"}, {"sha": "ac9a2a85b9b2a82aa0c088fca82a01f8257fac45", "filename": "libstdc++-v3/include/std/regex", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cb784b639c3de7505674b56f542c8b714d7df8a/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fregex", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cb784b639c3de7505674b56f542c8b714d7df8a/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fregex", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fregex?ref=6cb784b639c3de7505674b56f542c8b714d7df8a", "patch": "@@ -54,13 +54,11 @@\n #include <utility>\n #include <vector>\n \n-#include <bits/range_access.h>\n #include <bits/regex_constants.h>\n #include <bits/regex_error.h>\n-#include <bits/regex_cursor.h>\n-#include <bits/regex_nfa.h>\n+#include <bits/regex_automaton.h>\n #include <bits/regex_compiler.h>\n-#include <bits/regex_grep_matcher.h>\n+#include <bits/regex_executor.h>\n #include <bits/regex.h>\n \n #endif // C++11"}, {"sha": "cb502eadfb4a83e7c912de333f3a0b6f6a6463e4", "filename": "libstdc++-v3/testsuite/28_regex/algorithms/regex_match/extended/string_dispatch_01.cc", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cb784b639c3de7505674b56f542c8b714d7df8a/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Falgorithms%2Fregex_match%2Fextended%2Fstring_dispatch_01.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cb784b639c3de7505674b56f542c8b714d7df8a/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Falgorithms%2Fregex_match%2Fextended%2Fstring_dispatch_01.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Falgorithms%2Fregex_match%2Fextended%2Fstring_dispatch_01.cc?ref=6cb784b639c3de7505674b56f542c8b714d7df8a", "patch": "@@ -38,12 +38,10 @@ template<typename _Bi_iter, typename _Alloc,\n              regex_constants::match_flag_type         __flags\n                             = regex_constants::match_default)\n   {\n-    __detail::_AutomatonPtr __a = __re._M_get_automaton();\n-    __detail::_Automaton::_SizeT __sz = __a->_M_sub_count();\n-    __detail::_SpecializedCursor<_Bi_iter> __cs(__s, __e);\n-    __detail::_SpecializedResults<_Bi_iter, _Alloc> __r(__sz, __cs, __m);\n-    VERIFY( dynamic_cast<__detail::_DFSMatcher *>(\n-              &*__a->_M_get_matcher(__cs, __r, __a, __flags)) != nullptr );\n+    VERIFY( (dynamic_cast\n+             <__detail::_DFSExecutor<_Bi_iter, _Alloc, _Ch_type, _Rx_traits>*>\n+             (&*__detail::__get_executor(__s, __e, __m, __re, __flags))\n+             != nullptr) );\n   }\n \n void"}]}