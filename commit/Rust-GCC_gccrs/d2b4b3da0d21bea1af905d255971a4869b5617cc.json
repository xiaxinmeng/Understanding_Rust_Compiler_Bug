{"sha": "d2b4b3da0d21bea1af905d255971a4869b5617cc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDJiNGIzZGEwZDIxYmVhMWFmOTA1ZDI1NTk3MWE0ODY5YjU2MTdjYw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-31T08:52:34Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-31T08:52:34Z"}, "message": "[multiple changes]\n\n2011-08-31  Yannick Moy  <moy@adacore.com>\n\n\t* sem_ch4.adb: Code clean up.\n\n2011-08-31  Yannick Moy  <moy@adacore.com>\n\n\t* exp_alfa.adb, exp_alfa.ads: Minor correction of copyright notice.\n\n2011-08-31  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_ch7.adb (Build_Array_Deep_Procs): Do not generate Deep_Finalize\n\tand TSS primitive Finalize_Address if finalization is suppressed.\n\t(Build_Record_Deep_Procs): Do not generate Deep_Finalize and TSS\n\tprimitive Finalize_Address if finalization is suppressed.\n\n2011-08-31  Jose Ruiz  <ruiz@adacore.com>\n\n\t* s-mudido-affinity.adb, s-taprop-linux.adb, s-taprop-mingw.adb,\n\ts-taprop-solaris.adb, s-taprop-vxworks.adb (Set_Task_Affinity): Make\n\tsure that the underlying task has already been created before trying\n\tto change its affinity.\n\t(Set_CPU): Use the term processor instead of CPU, as we do in\n\tAssign_Task.\n\n2011-08-31  Vincent Celier  <celier@adacore.com>\n\n\t* prj-attr.adb: New Compiler attribute Source_File_Switches.\n\t* prj-nmsc.adb (Process_Compiler): Process attribute\n\tSource_File_Switches.\n\t* prj.ads (Language_Config): New name list component\n\tName_Source_File_Switches.\n\t* snames.ads-tmpl (Name_Source_File_Switches): New standard name.\n\n2011-08-31  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_attr.adb (Analyze_Attribute, case 'Old): If prefix may be a\n\tdiscriminated component of an actual, expand at once to prevent\n\touf-of-order references with generated subtypes.\n\n2011-08-31  Yannick Moy  <moy@adacore.com>\n\n\t* lib-xref-alfa.adb (Add_Alfa_Xrefs): Do not take into account read\n\treference to operator in Alfa xrefs.\n\n2011-08-31  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sem_ch12.adb (Freeze_Subprogram_Body): Add code to handle the case\n\twhere the parent instance was frozen before the current instance due to\n\tthe presence of a source body. Update calls to Insert_After_Last_Decl.\n\t(Insert_After_Last_Decl): Renamed to Insert_Freeze_Node_For_Instance.\n\tUpdate the comment which illustrates the purpose of the routine.\n\tPackage instances are now frozen by source bodies which appear after\n\tthe instance. This ensures that entities coming from within the\n\tinstance are available for use in the said bodies.\n\t(Install_Body): Add code to handle the case where the parent instance\n\twas frozen before the current instance due to the presence of a source\n\tbody. Update calls to Insert_After_Last_Decl.\n\nFrom-SVN: r178360", "tree": {"sha": "0c2f94cab822bc88416087991bfbbfc801389ebd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0c2f94cab822bc88416087991bfbbfc801389ebd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d2b4b3da0d21bea1af905d255971a4869b5617cc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2b4b3da0d21bea1af905d255971a4869b5617cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d2b4b3da0d21bea1af905d255971a4869b5617cc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2b4b3da0d21bea1af905d255971a4869b5617cc/comments", "author": null, "committer": null, "parents": [{"sha": "16c3301a61b99c5e55c90f3fa73d83c9478798d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16c3301a61b99c5e55c90f3fa73d83c9478798d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16c3301a61b99c5e55c90f3fa73d83c9478798d9"}], "stats": {"total": 453, "additions": 365, "deletions": 88}, "files": [{"sha": "53aed0db311fdf6c96a1495f45b51c52da6503b9", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2b4b3da0d21bea1af905d255971a4869b5617cc/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2b4b3da0d21bea1af905d255971a4869b5617cc/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=d2b4b3da0d21bea1af905d255971a4869b5617cc", "patch": "@@ -1,3 +1,61 @@\n+2011-08-31  Yannick Moy  <moy@adacore.com>\n+\n+\t* sem_ch4.adb: Code clean up.\n+\n+2011-08-31  Yannick Moy  <moy@adacore.com>\n+\n+\t* exp_alfa.adb, exp_alfa.ads: Minor correction of copyright notice.\n+\n+2011-08-31  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_ch7.adb (Build_Array_Deep_Procs): Do not generate Deep_Finalize\n+\tand TSS primitive Finalize_Address if finalization is suppressed.\n+\t(Build_Record_Deep_Procs): Do not generate Deep_Finalize and TSS\n+\tprimitive Finalize_Address if finalization is suppressed.\n+\n+2011-08-31  Jose Ruiz  <ruiz@adacore.com>\n+\n+\t* s-mudido-affinity.adb, s-taprop-linux.adb, s-taprop-mingw.adb,\n+\ts-taprop-solaris.adb, s-taprop-vxworks.adb (Set_Task_Affinity): Make\n+\tsure that the underlying task has already been created before trying\n+\tto change its affinity.\n+\t(Set_CPU): Use the term processor instead of CPU, as we do in\n+\tAssign_Task.\n+\n+2011-08-31  Vincent Celier  <celier@adacore.com>\n+\n+\t* prj-attr.adb: New Compiler attribute Source_File_Switches.\n+\t* prj-nmsc.adb (Process_Compiler): Process attribute\n+\tSource_File_Switches.\n+\t* prj.ads (Language_Config): New name list component\n+\tName_Source_File_Switches.\n+\t* snames.ads-tmpl (Name_Source_File_Switches): New standard name.\n+\n+2011-08-31  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_attr.adb (Analyze_Attribute, case 'Old): If prefix may be a\n+\tdiscriminated component of an actual, expand at once to prevent\n+\touf-of-order references with generated subtypes.\n+\n+2011-08-31  Yannick Moy  <moy@adacore.com>\n+\n+\t* lib-xref-alfa.adb (Add_Alfa_Xrefs): Do not take into account read\n+\treference to operator in Alfa xrefs.\n+\n+2011-08-31  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_ch12.adb (Freeze_Subprogram_Body): Add code to handle the case\n+\twhere the parent instance was frozen before the current instance due to\n+\tthe presence of a source body. Update calls to Insert_After_Last_Decl.\n+\t(Insert_After_Last_Decl): Renamed to Insert_Freeze_Node_For_Instance.\n+\tUpdate the comment which illustrates the purpose of the routine.\n+\tPackage instances are now frozen by source bodies which appear after\n+\tthe instance. This ensures that entities coming from within the\n+\tinstance are available for use in the said bodies.\n+\t(Install_Body): Add code to handle the case where the parent instance\n+\twas frozen before the current instance due to the presence of a source\n+\tbody. Update calls to Insert_After_Last_Decl.\n+\n 2011-08-31  Jose Ruiz  <ruiz@adacore.com>\n \n \t* s-taprop-linux.adb (Set_Task_Affinity): Avoid the use of anonymous"}, {"sha": "56092c1da84c65b5642a54df86c878c274099652", "filename": "gcc/ada/exp_alfa.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2b4b3da0d21bea1af905d255971a4869b5617cc/gcc%2Fada%2Fexp_alfa.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2b4b3da0d21bea1af905d255971a4869b5617cc/gcc%2Fada%2Fexp_alfa.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_alfa.adb?ref=d2b4b3da0d21bea1af905d255971a4869b5617cc", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---             Copyright (C) 2011, Free Software Foundation, Inc.           --\n+--          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --"}, {"sha": "0e882bef98d808d61f075020d320ca254f97e3f4", "filename": "gcc/ada/exp_alfa.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2b4b3da0d21bea1af905d255971a4869b5617cc/gcc%2Fada%2Fexp_alfa.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2b4b3da0d21bea1af905d255971a4869b5617cc/gcc%2Fada%2Fexp_alfa.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_alfa.ads?ref=d2b4b3da0d21bea1af905d255971a4869b5617cc", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---             Copyright (C) 2011, Free Software Foundation, Inc.           --\n+--          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --"}, {"sha": "74de4b00ac57261db97060a189868bc47c93723d", "filename": "gcc/ada/exp_ch7.adb", "status": "modified", "additions": 32, "deletions": 22, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2b4b3da0d21bea1af905d255971a4869b5617cc/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2b4b3da0d21bea1af905d255971a4869b5617cc/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=d2b4b3da0d21bea1af905d255971a4869b5617cc", "patch": "@@ -434,21 +434,26 @@ package body Exp_Ch7 is\n               Stmts => Make_Deep_Array_Body (Adjust_Case, Typ)));\n       end if;\n \n-      Set_TSS (Typ,\n-        Make_Deep_Proc\n-          (Prim  => Finalize_Case,\n-           Typ   => Typ,\n-           Stmts => Make_Deep_Array_Body (Finalize_Case, Typ)));\n+      --  Do not generate Deep_Finalize and Finalize_Address if finalization is\n+      --  suppressed since these routine will not be used.\n \n-      --  Create TSS primitive Finalize_Address for non-VM targets. JVM and\n-      --  .NET do not support address arithmetic and unchecked conversions.\n-\n-      if VM_Target = No_VM then\n+      if not Restriction_Active (No_Finalization) then\n          Set_TSS (Typ,\n            Make_Deep_Proc\n-             (Prim  => Address_Case,\n+             (Prim  => Finalize_Case,\n               Typ   => Typ,\n-              Stmts => Make_Deep_Array_Body (Address_Case, Typ)));\n+              Stmts => Make_Deep_Array_Body (Finalize_Case, Typ)));\n+\n+         --  Create TSS primitive Finalize_Address for non-VM targets. JVM and\n+         --  .NET do not support address arithmetic and unchecked conversions.\n+\n+         if VM_Target = No_VM then\n+            Set_TSS (Typ,\n+              Make_Deep_Proc\n+                (Prim  => Address_Case,\n+                 Typ   => Typ,\n+                 Stmts => Make_Deep_Array_Body (Address_Case, Typ)));\n+         end if;\n       end if;\n    end Build_Array_Deep_Procs;\n \n@@ -3090,21 +3095,26 @@ package body Exp_Ch7 is\n               Stmts => Make_Deep_Record_Body (Adjust_Case, Typ)));\n       end if;\n \n-      Set_TSS (Typ,\n-        Make_Deep_Proc\n-          (Prim  => Finalize_Case,\n-           Typ   => Typ,\n-           Stmts => Make_Deep_Record_Body (Finalize_Case, Typ)));\n+      --  Do not generate Deep_Finalize and Finalize_Address if finalization is\n+      --  suppressed since these routine will not be used.\n \n-      --  Create TSS primitive Finalize_Address for non-VM targets. JVM and\n-      --  .NET do not support address arithmetic and unchecked conversions.\n-\n-      if VM_Target = No_VM then\n+      if not Restriction_Active (No_Finalization) then\n          Set_TSS (Typ,\n            Make_Deep_Proc\n-             (Prim  => Address_Case,\n+             (Prim  => Finalize_Case,\n               Typ   => Typ,\n-              Stmts => Make_Deep_Record_Body (Address_Case, Typ)));\n+              Stmts => Make_Deep_Record_Body (Finalize_Case, Typ)));\n+\n+         --  Create TSS primitive Finalize_Address for non-VM targets. JVM and\n+         --  .NET do not support address arithmetic and unchecked conversions.\n+\n+         if VM_Target = No_VM then\n+            Set_TSS (Typ,\n+              Make_Deep_Proc\n+                (Prim  => Address_Case,\n+                 Typ   => Typ,\n+                 Stmts => Make_Deep_Record_Body (Address_Case, Typ)));\n+         end if;\n       end if;\n    end Build_Record_Deep_Procs;\n "}, {"sha": "6f1f393d7dabe93d2314b7a1997da6891ba4cb85", "filename": "gcc/ada/lib-xref-alfa.adb", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2b4b3da0d21bea1af905d255971a4869b5617cc/gcc%2Fada%2Flib-xref-alfa.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2b4b3da0d21bea1af905d255971a4869b5617cc/gcc%2Fada%2Flib-xref-alfa.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-xref-alfa.adb?ref=d2b4b3da0d21bea1af905d255971a4869b5617cc", "patch": "@@ -576,13 +576,37 @@ package body Alfa is\n       Eliminate_Before_Sort : declare\n          NR : Nat;\n \n+         function Is_Alfa_Reference\n+           (E   : Entity_Id;\n+            Typ : Character) return Boolean;\n+         --  Return whether the reference is adequate for this entity\n+\n          function Is_Alfa_Scope (E : Entity_Id) return Boolean;\n          --  Return whether the entity or reference scope is adequate\n \n          function Is_Global_Constant (E : Entity_Id) return Boolean;\n          --  Return True if E is a global constant for which we should ignore\n          --  reads in Alfa.\n \n+         -----------------------\n+         -- Is_Alfa_Reference --\n+         -----------------------\n+\n+         function Is_Alfa_Reference\n+           (E   : Entity_Id;\n+            Typ : Character) return Boolean is\n+         begin\n+            --  The only references of interest on callable entities are calls.\n+            --  On non-callable entities, the only references of interest are\n+            --  reads and writes.\n+\n+            if Ekind (E) in Overloadable_Kind then\n+               return Typ = 's';\n+            else\n+               return Typ = 'r' or else Typ = 'm';\n+            end if;\n+         end Is_Alfa_Reference;\n+\n          -------------------\n          -- Is_Alfa_Scope --\n          -------------------\n@@ -617,6 +641,8 @@ package body Alfa is\n               and then Is_Alfa_Scope (Xrefs.Table (Rnums (J)).Ent_Scope)\n               and then Is_Alfa_Scope (Xrefs.Table (Rnums (J)).Ref_Scope)\n               and then not Is_Global_Constant (Xrefs.Table (Rnums (J)).Ent)\n+              and then Is_Alfa_Reference (Xrefs.Table (Rnums (J)).Ent,\n+                                          Xrefs.Table (Rnums (J)).Typ)\n             then\n                Nrefs         := Nrefs + 1;\n                Rnums (Nrefs) := Rnums (J);"}, {"sha": "f8084619d89059e2870d06a97d91ad4d66b5dff7", "filename": "gcc/ada/prj-attr.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2b4b3da0d21bea1af905d255971a4869b5617cc/gcc%2Fada%2Fprj-attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2b4b3da0d21bea1af905d255971a4869b5617cc/gcc%2Fada%2Fprj-attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-attr.adb?ref=d2b4b3da0d21bea1af905d255971a4869b5617cc", "patch": "@@ -190,6 +190,7 @@ package body Prj.Attr is\n    \"Latrailing_required_switches#\" &\n    \"Lapic_option#\" &\n    \"Sapath_syntax#\" &\n+   \"Sasource_file_switches#\" &\n    \"Saobject_file_suffix#\" &\n    \"Laobject_file_switches#\" &\n    \"Lamulti_unit_switches#\" &"}, {"sha": "28c93265dc5c503a206f47bc4a26b6c5f3a90283", "filename": "gcc/ada/prj-nmsc.adb", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2b4b3da0d21bea1af905d255971a4869b5617cc/gcc%2Fada%2Fprj-nmsc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2b4b3da0d21bea1af905d255971a4869b5617cc/gcc%2Fada%2Fprj-nmsc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-nmsc.adb?ref=d2b4b3da0d21bea1af905d255971a4869b5617cc", "patch": "@@ -1470,6 +1470,12 @@ package body Prj.Nmsc is\n                                     Element.Value.Location, Project);\n                            end;\n \n+                        when Name_Source_File_Switches =>\n+                           Put (Into_List =>\n+                                  Lang_Index.Config.Source_File_Switches,\n+                                From_List => Element.Value.Values,\n+                                In_Tree   => Data.Tree);\n+\n                         when Name_Object_File_Suffix =>\n                            if Get_Name_String (Element.Value.Value) = \"\" then\n                               Error_Msg"}, {"sha": "5cb84fb50dddf0b72156cce41c6c795f40224d0b", "filename": "gcc/ada/prj.ads", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2b4b3da0d21bea1af905d255971a4869b5617cc/gcc%2Fada%2Fprj.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2b4b3da0d21bea1af905d255971a4869b5617cc/gcc%2Fada%2Fprj.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj.ads?ref=d2b4b3da0d21bea1af905d255971a4869b5617cc", "patch": "@@ -447,6 +447,11 @@ package Prj is\n       --  Value may be Canonical (Unix style) or Host (host syntax, for example\n       --  on VMS for DEC C).\n \n+      Source_File_Switches : Name_List_Index := No_Name_List;\n+      --  Optional switches to be put before the source file. The source file\n+      --  path name is appended to the last switch in the list.\n+      --  Example: (\"-i\", \"\");\n+\n       Object_File_Suffix : Name_Id := No_Name;\n       --  Optional alternate object file suffix\n \n@@ -580,6 +585,7 @@ package Prj is\n                            Multi_Unit_Switches          => No_Name_List,\n                            Multi_Unit_Object_Separator  => ' ',\n                            Path_Syntax                  => Canonical,\n+                           Source_File_Switches         => No_Name_List,\n                            Object_File_Suffix           => No_Name,\n                            Object_File_Switches         => No_Name_List,\n                            Compilation_PIC_Option       => No_Name_List,"}, {"sha": "c72dc39d6d77b0c78b03fc504be87a6004775b6f", "filename": "gcc/ada/s-mudido-affinity.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2b4b3da0d21bea1af905d255971a4869b5617cc/gcc%2Fada%2Fs-mudido-affinity.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2b4b3da0d21bea1af905d255971a4869b5617cc/gcc%2Fada%2Fs-mudido-affinity.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-mudido-affinity.adb?ref=d2b4b3da0d21bea1af905d255971a4869b5617cc", "patch": "@@ -337,7 +337,7 @@ package body System.Multiprocessors.Dispatching_Domains is\n          not Target.Common.Domain (CPU))\n       then\n          raise Dispatching_Domain_Error with\n-           \"CPU does not belong to the task's dispatching domain\";\n+           \"processor does not belong to the task's dispatching domain\";\n       end if;\n \n       Unchecked_Set_Affinity (Target.Common.Domain, CPU, Target);"}, {"sha": "a47e4b1a0a0b513fc90f2b664d935fa7ed435cfc", "filename": "gcc/ada/s-taprop-linux.adb", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2b4b3da0d21bea1af905d255971a4869b5617cc/gcc%2Fada%2Fs-taprop-linux.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2b4b3da0d21bea1af905d255971a4869b5617cc/gcc%2Fada%2Fs-taprop-linux.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-linux.adb?ref=d2b4b3da0d21bea1af905d255971a4869b5617cc", "patch": "@@ -38,7 +38,6 @@ pragma Polling (Off);\n --  Turn off polling, we do not want ATC polling to take place during tasking\n --  operations. It causes infinite loops and other problems.\n \n-with Ada.Unchecked_Conversion;\n with Ada.Unchecked_Deallocation;\n \n with Interfaces.C;\n@@ -113,6 +112,10 @@ package body System.Task_Primitives.Operations is\n    Abort_Handler_Installed : Boolean := False;\n    --  True if a handler for the abort signal is installed\n \n+   Null_Thread_Id : constant pthread_t := pthread_t'Last;\n+   --  Constant to indicate that the thread identifier has not yet been\n+   --  initialized.\n+\n    --------------------\n    -- Local Packages --\n    --------------------\n@@ -154,13 +157,8 @@ package body System.Task_Primitives.Operations is\n    -- Local Subprograms --\n    -----------------------\n \n-   subtype unsigned_long is Interfaces.C.unsigned_long;\n-\n    procedure Abort_Handler (signo : Signal);\n \n-   function To_pthread_t is new Ada.Unchecked_Conversion\n-     (unsigned_long, System.OS_Interface.pthread_t);\n-\n    -------------------\n    -- Abort_Handler --\n    -------------------\n@@ -773,7 +771,7 @@ package body System.Task_Primitives.Operations is\n       Next_Serial_Number := Next_Serial_Number + 1;\n       pragma Assert (Next_Serial_Number /= 0);\n \n-      Self_ID.Common.LL.Thread := To_pthread_t (-1);\n+      Self_ID.Common.LL.Thread := Null_Thread_Id;\n \n       if not Single_Lock then\n          Result := pthread_mutex_init (Self_ID.Common.LL.L'Access,\n@@ -1363,7 +1361,14 @@ package body System.Task_Primitives.Operations is\n       use type System.Multiprocessors.CPU_Range;\n \n    begin\n-      if pthread_setaffinity_np'Address /= System.Null_Address then\n+      --  Do nothing if there is no support for setting affinities or the\n+      --  underlying thread has not yet been created. If the thread has not\n+      --  yet been created then the proper affinity will be set during its\n+      --  creation.\n+\n+      if pthread_setaffinity_np'Address /= System.Null_Address\n+        and then T.Common.LL.Thread /= Null_Thread_Id\n+      then\n          declare\n             type cpu_set_t_ptr is access all cpu_set_t;\n "}, {"sha": "a56b8e7bf4233f06a5adc27495edf3691410e92a", "filename": "gcc/ada/s-taprop-mingw.adb", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2b4b3da0d21bea1af905d255971a4869b5617cc/gcc%2Fada%2Fs-taprop-mingw.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2b4b3da0d21bea1af905d255971a4869b5617cc/gcc%2Fada%2Fs-taprop-mingw.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-mingw.adb?ref=d2b4b3da0d21bea1af905d255971a4869b5617cc", "patch": "@@ -131,6 +131,10 @@ package body System.Task_Primitives.Operations is\n    Annex_D : Boolean := False;\n    --  Set to True if running with Annex-D semantics\n \n+   Null_Thread_Id : constant Thread_Id := 0;\n+   --  Constant to indicate that the thread identifier has not yet been\n+   --  initialized.\n+\n    ------------------------------------\n    -- The thread local storage index --\n    ------------------------------------\n@@ -853,7 +857,7 @@ package body System.Task_Primitives.Operations is\n       --  Initialize thread ID to 0, this is needed to detect threads that\n       --  are not yet activated.\n \n-      Self_ID.Common.LL.Thread := 0;\n+      Self_ID.Common.LL.Thread := Null_Thread_Id;\n \n       Initialize_Cond (Self_ID.Common.LL.CV'Access);\n \n@@ -1362,9 +1366,16 @@ package body System.Task_Primitives.Operations is\n       use type System.Multiprocessors.CPU_Range;\n \n    begin\n+      --  Do nothing if the underlying thread has not yet been created. If the\n+      --  thread has not yet been created then the proper affinity will be set\n+      --  during its creation.\n+\n+      if T.Common.LL.Thread = Null_Thread_Id then\n+         null;\n+\n       --  pragma CPU\n \n-      if T.Common.Base_CPU /= System.Multiprocessors.Not_A_Specific_CPU then\n+      elsif T.Common.Base_CPU /= Multiprocessors.Not_A_Specific_CPU then\n \n          --  The CPU numbering in pragma CPU starts at 1 while the subprogram\n          --  to set the affinity starts at 0, therefore we must substract 1."}, {"sha": "6461c9f9e164310f2e0d9370bbd246ebd372e2c5", "filename": "gcc/ada/s-taprop-solaris.adb", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2b4b3da0d21bea1af905d255971a4869b5617cc/gcc%2Fada%2Fs-taprop-solaris.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2b4b3da0d21bea1af905d255971a4869b5617cc/gcc%2Fada%2Fs-taprop-solaris.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-solaris.adb?ref=d2b4b3da0d21bea1af905d255971a4869b5617cc", "patch": "@@ -101,6 +101,10 @@ package body System.Task_Primitives.Operations is\n    Abort_Handler_Installed : Boolean := False;\n    --  True if a handler for the abort signal is installed\n \n+   Null_Thread_Id : constant Thread_Id := Thread_Id'Last;\n+   --  Constant to indicate that the thread identifier has not yet been\n+   --  initialized.\n+\n    ----------------------\n    -- Priority Support --\n    ----------------------\n@@ -917,7 +921,7 @@ package body System.Task_Primitives.Operations is\n       Next_Serial_Number := Next_Serial_Number + 1;\n       pragma Assert (Next_Serial_Number /= 0);\n \n-      Self_ID.Common.LL.Thread := To_thread_t (-1);\n+      Self_ID.Common.LL.Thread := Null_Thread_Id;\n \n       if not Single_Lock then\n          Result :=\n@@ -1021,7 +1025,7 @@ package body System.Task_Primitives.Operations is\n         Ada.Unchecked_Deallocation (Ada_Task_Control_Block, Task_Id);\n \n    begin\n-      T.Common.LL.Thread := To_thread_t (0);\n+      T.Common.LL.Thread := Null_Thread_Id;\n \n       if not Single_Lock then\n          Result := mutex_destroy (T.Common.LL.L.L'Access);\n@@ -1944,9 +1948,16 @@ package body System.Task_Primitives.Operations is\n       use type System.Multiprocessors.CPU_Range;\n \n    begin\n+      --  Do nothing if the underlying thread has not yet been created. If the\n+      --  thread has not yet been created then the proper affinity will be set\n+      --  during its creation.\n+\n+      if T.Common.LL.Thread = Null_Thread_Id then\n+         null;\n+\n       --  pragma CPU\n \n-      if T.Common.Base_CPU /=\n+      elsif T.Common.Base_CPU /=\n            System.Multiprocessors.Not_A_Specific_CPU\n       then\n          --  The CPU numbering in pragma CPU starts at 1 while the subprogram"}, {"sha": "a9f89f58ee456030bb683e6601fb18e76adffe87", "filename": "gcc/ada/s-taprop-vxworks.adb", "status": "modified", "additions": 20, "deletions": 9, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2b4b3da0d21bea1af905d255971a4869b5617cc/gcc%2Fada%2Fs-taprop-vxworks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2b4b3da0d21bea1af905d255971a4869b5617cc/gcc%2Fada%2Fs-taprop-vxworks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-vxworks.adb?ref=d2b4b3da0d21bea1af905d255971a4869b5617cc", "patch": "@@ -105,6 +105,10 @@ package body System.Task_Primitives.Operations is\n    Time_Slice_Val : Integer;\n    pragma Import (C, Time_Slice_Val, \"__gl_time_slice_val\");\n \n+   Null_Thread_Id : constant Thread_Id := 0;\n+   --  Constant to indicate that the thread identifier has not yet been\n+   --  initialized.\n+\n    --------------------\n    -- Local Packages --\n    --------------------\n@@ -859,7 +863,7 @@ package body System.Task_Primitives.Operations is\n    procedure Initialize_TCB (Self_ID : Task_Id; Succeeded : out Boolean) is\n    begin\n       Self_ID.Common.LL.CV := semBCreate (SEM_Q_PRIORITY, SEM_EMPTY);\n-      Self_ID.Common.LL.Thread := 0;\n+      Self_ID.Common.LL.Thread := Null_Thread_Id;\n \n       if Self_ID.Common.LL.CV = 0 then\n          Succeeded := False;\n@@ -952,7 +956,7 @@ package body System.Task_Primitives.Operations is\n \n       Set_Task_Affinity (T);\n \n-      if T.Common.LL.Thread <= 0 then\n+      if T.Common.LL.Thread <= Null_Thread_Id then\n          Succeeded := False;\n       else\n          Succeeded := True;\n@@ -979,7 +983,7 @@ package body System.Task_Primitives.Operations is\n          pragma Assert (Result = 0);\n       end if;\n \n-      T.Common.LL.Thread := 0;\n+      T.Common.LL.Thread := Null_Thread_Id;\n \n       Result := semDelete (T.Common.LL.CV);\n       pragma Assert (Result = 0);\n@@ -1254,7 +1258,7 @@ package body System.Task_Primitives.Operations is\n       Thread_Self : Thread_Id) return Boolean\n    is\n    begin\n-      if T.Common.LL.Thread /= 0\n+      if T.Common.LL.Thread /= Null_Thread_Id\n         and then T.Common.LL.Thread /= Thread_Self\n       then\n          return taskSuspend (T.Common.LL.Thread) = 0;\n@@ -1272,7 +1276,7 @@ package body System.Task_Primitives.Operations is\n       Thread_Self : Thread_Id) return Boolean\n    is\n    begin\n-      if T.Common.LL.Thread /= 0\n+      if T.Common.LL.Thread /= Null_Thread_Id\n         and then T.Common.LL.Thread /= Thread_Self\n       then\n          return taskResume (T.Common.LL.Thread) = 0;\n@@ -1298,7 +1302,7 @@ package body System.Task_Primitives.Operations is\n \n       C := All_Tasks_List;\n       while C /= null loop\n-         if C.Common.LL.Thread /= 0\n+         if C.Common.LL.Thread /= Null_Thread_Id\n            and then C.Common.LL.Thread /= Thread_Self\n          then\n             Dummy := Task_Stop (C.Common.LL.Thread);\n@@ -1316,7 +1320,7 @@ package body System.Task_Primitives.Operations is\n \n    function Stop_Task (T : ST.Task_Id) return Boolean is\n    begin\n-      if T.Common.LL.Thread /= 0 then\n+      if T.Common.LL.Thread /= Null_Thread_Id then\n          return Task_Stop (T.Common.LL.Thread) = 0;\n       else\n          return True;\n@@ -1330,7 +1334,7 @@ package body System.Task_Primitives.Operations is\n    function Continue_Task (T : ST.Task_Id) return Boolean\n    is\n    begin\n-      if T.Common.LL.Thread /= 0 then\n+      if T.Common.LL.Thread /= Null_Thread_Id then\n          return Task_Cont (T.Common.LL.Thread) = 0;\n       else\n          return True;\n@@ -1408,9 +1412,16 @@ package body System.Task_Primitives.Operations is\n       use type System.Multiprocessors.CPU_Range;\n \n    begin\n+      --  Do nothing if the underlying thread has not yet been created. If the\n+      --  thread has not yet been created then the proper affinity will be set\n+      --  during its creation.\n+\n+      if T.Common.LL.Thread = Null_Thread_Id then\n+         null;\n+\n       --  pragma CPU\n \n-      if T.Common.Base_CPU /= System.Multiprocessors.Not_A_Specific_CPU then\n+      elsif T.Common.Base_CPU /= Multiprocessors.Not_A_Specific_CPU then\n \n          --  Ada 2012 pragma CPU uses CPU numbers starting from 1, while on\n          --  VxWorks the first CPU is identified by a 0, so we need to adjust."}, {"sha": "cf93ec763017a1b5fe3a8b5d912a9519a2e733b1", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2b4b3da0d21bea1af905d255971a4869b5617cc/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2b4b3da0d21bea1af905d255971a4869b5617cc/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=d2b4b3da0d21bea1af905d255971a4869b5617cc", "patch": "@@ -1939,7 +1939,7 @@ package body Sem_Attr is\n       --  Analyze prefix and exit if error in analysis. If the prefix is an\n       --  incomplete type, use full view if available. Note that there are\n       --  some attributes for which we do not analyze the prefix, since the\n-      --  prefix is not a normal name.\n+      --  prefix is not a normal name, or else needs special handling.\n \n       if Aname /= Name_Elab_Body\n            and then\n@@ -1950,6 +1950,8 @@ package body Sem_Attr is\n          Aname /= Name_UET_Address\n            and then\n          Aname /= Name_Enabled\n+           and then\n+         Aname /= Name_Old\n       then\n          Analyze (P);\n          P_Type := Etype (P);\n@@ -3772,6 +3774,12 @@ package body Sem_Attr is\n          end if;\n \n          Check_E0;\n+\n+         --  Prefix has not been analyzed yet, and its full analysis will take\n+         --  place during expansion (see below).\n+\n+         Preanalyze_And_Resolve (P);\n+         P_Type := Etype (P);\n          Set_Etype (N, P_Type);\n \n          if No (Current_Subprogram) then\n@@ -3852,6 +3860,24 @@ package body Sem_Attr is\n             end if;\n          end Check_Local;\n \n+         --  The attribute ppears within a pre/postcondition, but refers to\n+         --  an entity in the enclosing subprogram. If it is a component of a\n+         --  formal its expansion might generate actual subtypes that may be\n+         --  referenced in an inner context, and which must be elaborated\n+         --  within the subprogram itself. As a result we create a declaration\n+         --  for it and insert it at the start of the enclosing subprogram\n+         --  This is properly an expansion activity but it has to be performed\n+         --  now to prevent out-of-order issues.\n+\n+         if Nkind (P) = N_Selected_Component\n+           and then Has_Discriminants (Etype (Prefix (P)))\n+         then\n+            P_Type := Base_Type (P_Type);\n+            Set_Etype (N, P_Type);\n+            Set_Etype (P, P_Type);\n+            Expand (N);\n+         end if;\n+\n       ------------\n       -- Output --\n       ------------"}, {"sha": "ad6d482e7651438de6920d56f661742f5eec792f", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 140, "deletions": 37, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2b4b3da0d21bea1af905d255971a4869b5617cc/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2b4b3da0d21bea1af905d255971a4869b5617cc/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=d2b4b3da0d21bea1af905d255971a4869b5617cc", "patch": "@@ -516,11 +516,22 @@ package body Sem_Ch12 is\n    --  of packages that are early instantiations are delayed, and their freeze\n    --  node appears after the generic body.\n \n-   procedure Insert_After_Last_Decl (N : Node_Id; F_Node : Node_Id);\n-   --  Insert freeze node at the end of the declarative part that includes the\n-   --  instance node N. If N is in the visible part of an enclosing package\n-   --  declaration, the freeze node has to be inserted at the end of the\n-   --  private declarations, if any.\n+   procedure Insert_Freeze_Node_For_Instance\n+     (N      : Node_Id;\n+      F_Node : Node_Id);\n+   --  N is an instance and F_Node is its corresponding freeze node. Insert\n+   --  F_Node depending on the enclosing context and placement of N in the\n+   --  following manner:\n+   --\n+   --    1) N is a package instance - Attempt to insert the freeze node before\n+   --    a source package or subprogram body which follows immediately after N.\n+   --    If no such body is found, perform the actions in 2).\n+   --\n+   --    2) N is a subprogram instance or a package instance not followed by\n+   --    a source body - Insert the freeze node at the end of the declarations\n+   --    list which contains N. If N is in the visible part of an enclosing\n+   --    package declaration, the freeze node is inserted at the end of the\n+   --    private declarations.\n \n    procedure Freeze_Subprogram_Body\n      (Inst_Node : Node_Id;\n@@ -6698,12 +6709,12 @@ package body Sem_Ch12 is\n       Gen_Body  : Node_Id;\n       Pack_Id   : Entity_Id)\n   is\n-      F_Node   : Node_Id;\n       Gen_Unit : constant Entity_Id := Get_Generic_Entity (Inst_Node);\n       Par      : constant Entity_Id := Scope (Gen_Unit);\n+      E_G_Id   : Entity_Id;\n       Enc_G    : Entity_Id;\n       Enc_I    : Node_Id;\n-      E_G_Id   : Entity_Id;\n+      F_Node   : Node_Id;\n \n       function Earlier (N1, N2 : Node_Id) return Boolean;\n       --  Yields True if N1 and N2 appear in the same compilation unit,\n@@ -6881,15 +6892,37 @@ package body Sem_Ch12 is\n \n       if Is_Generic_Instance (Par)\n         and then Present (Freeze_Node (Par))\n-        and then\n-          In_Same_Declarative_Part (Freeze_Node (Par), Inst_Node)\n+        and then In_Same_Declarative_Part (Freeze_Node (Par), Inst_Node)\n       then\n-         if ABE_Is_Certain (Get_Package_Instantiation_Node (Par)) then\n+         --  The parent was a premature instantiation. Insert freeze node at\n+         --  the end the current declarative part.\n \n-            --  The parent was a premature instantiation. Insert freeze node at\n-            --  the end the current declarative part.\n-\n-            Insert_After_Last_Decl (Inst_Node, F_Node);\n+         if ABE_Is_Certain (Get_Package_Instantiation_Node (Par)) then\n+            Insert_Freeze_Node_For_Instance (Inst_Node, F_Node);\n+\n+         --  Handle the following case:\n+         --\n+         --    package Parent_Inst is new ...\n+         --    Parent_Inst []\n+         --\n+         --    procedure P ...  --  this body freezes Parent_Inst\n+         --\n+         --    package Inst is new ...\n+         --\n+         --  In this particular scenario, the freeze node for Inst must be\n+         --  inserted in the same manner as that of Parent_Inst - before the\n+         --  next source body or at the end of the declarative list (body not\n+         --  available). If body P did not exist and Parent_Inst was frozen\n+         --  after Inst, either by a body following Inst or at the end of the\n+         --  declarative region, the freeze node for Inst must be inserted\n+         --  after that of Parent_Inst. This relation is established by\n+         --  comparing the Slocs of Parent_Inst freeze node and Inst.\n+\n+         elsif List_Containing (Get_Package_Instantiation_Node (Par)) =\n+               List_Containing (Inst_Node)\n+           and then Sloc (Freeze_Node (Par)) < Sloc (Inst_Node)\n+         then\n+            Insert_Freeze_Node_For_Instance (Inst_Node, F_Node);\n \n          else\n             Insert_After (Freeze_Node (Par), F_Node);\n@@ -6917,11 +6950,11 @@ package body Sem_Ch12 is\n             --  node, we place it at the end of the declarative part of the\n             --  parent of the generic.\n \n-            Insert_After_Last_Decl\n+            Insert_Freeze_Node_For_Instance\n               (Freeze_Node (Par), Package_Freeze_Node (Enc_I));\n          end if;\n \n-         Insert_After_Last_Decl (Inst_Node, F_Node);\n+         Insert_Freeze_Node_For_Instance (Inst_Node, F_Node);\n \n       elsif Present (Enc_G)\n         and then Present (Enc_I)\n@@ -6955,7 +6988,8 @@ package body Sem_Ch12 is\n             end if;\n \n             if Parent (List_Containing (Enc_G)) /= Enclosing_Body then\n-               Insert_After_Last_Decl (Enc_G, Package_Freeze_Node (Enc_I));\n+               Insert_Freeze_Node_For_Instance\n+                 (Enc_G, Package_Freeze_Node (Enc_I));\n             end if;\n          end;\n \n@@ -6967,13 +7001,13 @@ package body Sem_Ch12 is\n             Insert_After (Enc_G, Freeze_Node (E_G_Id));\n          end if;\n \n-         Insert_After_Last_Decl (Inst_Node, F_Node);\n+         Insert_Freeze_Node_For_Instance (Inst_Node, F_Node);\n \n       else\n          --  If none of the above, insert freeze node at the end of the current\n          --  declarative part.\n \n-         Insert_After_Last_Decl (Inst_Node, F_Node);\n+         Insert_Freeze_Node_For_Instance (Inst_Node, F_Node);\n       end if;\n    end Freeze_Subprogram_Body;\n \n@@ -7197,7 +7231,7 @@ package body Sem_Ch12 is\n             return False;\n \n          elsif Nkind (Nod) = N_Subunit then\n-            Nod :=  Corresponding_Stub (Nod);\n+            Nod := Corresponding_Stub (Nod);\n \n          elsif Nkind (Nod) = N_Compilation_Unit then\n             return False;\n@@ -7319,27 +7353,69 @@ package body Sem_Ch12 is\n       Hidden_Entities      := No_Elist;\n    end Initialize;\n \n-   ----------------------------\n-   -- Insert_After_Last_Decl --\n-   ----------------------------\n+   -------------------------------------\n+   -- Insert_Freeze_Node_For_Instance --\n+   -------------------------------------\n \n-   procedure Insert_After_Last_Decl (N : Node_Id; F_Node : Node_Id) is\n-      L : List_Id          := List_Containing (N);\n-      P : constant Node_Id := Parent (L);\n+   procedure Insert_Freeze_Node_For_Instance\n+     (N      : Node_Id;\n+      F_Node : Node_Id)\n+   is\n+      Inst  : constant Entity_Id := Entity (F_Node);\n+      Decl  : Node_Id;\n+      Decls : List_Id;\n+      Par_N : Node_Id;\n \n    begin\n       if not Is_List_Member (F_Node) then\n-         if Nkind (P) = N_Package_Specification\n-           and then L = Visible_Declarations (P)\n-           and then Present (Private_Declarations (P))\n-           and then not Is_Empty_List (Private_Declarations (P))\n+         Decls := List_Containing (N);\n+         Par_N := Parent (Decls);\n+         Decl  := N;\n+\n+         --  When the instantiation occurs in a package declaration, append the\n+         --  freeze node to the private declarations (if any).\n+\n+         if Nkind (Par_N) = N_Package_Specification\n+           and then Decls = Visible_Declarations (Par_N)\n+           and then Present (Private_Declarations (Par_N))\n+           and then not Is_Empty_List (Private_Declarations (Par_N))\n+         then\n+            Decls := Private_Declarations (Par_N);\n+            Decl  := First (Decls);\n+         end if;\n+\n+         --  Determine the proper freeze point of a package instantiation. We\n+         --  adhere to the general rule of a package or subprogram body causing\n+         --  freezing of anything before it in the same declarative region. In\n+         --  this case, the proper freeze point of a package instantiation is\n+         --  before the first source body which follows. This ensures that\n+         --  entities coming from the instance are already frozen and usable\n+         --  in source bodies.\n+\n+         if Nkind (Par_N) /= N_Package_Declaration\n+           and then Ekind (Inst) = E_Package\n+           and then Is_Generic_Instance (Inst)\n+           and then\n+             not In_Same_Source_Unit (Generic_Parent (Parent (Inst)), Inst)\n          then\n-            L := Private_Declarations (P);\n+            while Present (Decl) loop\n+               if Nkind_In (Decl, N_Package_Body, N_Subprogram_Body)\n+                 and then Comes_From_Source (Decl)\n+               then\n+                  Insert_Before (Decl, F_Node);\n+                  return;\n+               end if;\n+\n+               Next (Decl);\n+            end loop;\n          end if;\n \n-         Insert_After (Last (L), F_Node);\n+         --  In a package declaration, or if no previous body, insert at end\n+         --  of list.\n+\n+         Insert_After (Last (Decls), F_Node);\n       end if;\n-   end Insert_After_Last_Decl;\n+   end Insert_Freeze_Node_For_Instance;\n \n    ------------------\n    -- Install_Body --\n@@ -7475,7 +7551,34 @@ package body Sem_Ch12 is\n             --  generic.\n \n             if In_Same_Declarative_Part (Freeze_Node (Par), N) then\n-               Insert_After (Freeze_Node (Par), F_Node);\n+\n+               --  Handle the following case:\n+               --\n+               --    package Parent_Inst is new ...\n+               --    Parent_Inst []\n+               --\n+               --    procedure P ...  --  this body freezes Parent_Inst\n+               --\n+               --    package Inst is new ...\n+               --\n+               --  In this particular scenario, the freeze node for Inst must\n+               --  be inserted in the same manner as that of Parent_Inst -\n+               --  before the next source body or at the end of the declarative\n+               --  list (body not available). If body P did not exist and\n+               --  Parent_Inst was frozen after Inst, either by a body\n+               --  following Inst or at the end of the declarative region, the\n+               --  freeze node for Inst must be inserted after that of\n+               --  Parent_Inst. This relation is established by comparing the\n+               --  Slocs of Parent_Inst freeze node and Inst.\n+\n+               if List_Containing (Get_Package_Instantiation_Node (Par)) =\n+                  List_Containing (N)\n+                 and then Sloc (Freeze_Node (Par)) < Sloc (N)\n+               then\n+                  Insert_Freeze_Node_For_Instance (N, F_Node);\n+               else\n+                  Insert_After (Freeze_Node (Par), F_Node);\n+               end if;\n \n             --  Freeze package enclosing instance of inner generic after\n             --  instance of enclosing generic.\n@@ -7489,7 +7592,7 @@ package body Sem_Ch12 is\n                                 Corresponding_Spec (Parent (N));\n \n                begin\n-                  Insert_After_Last_Decl (N, F_Node);\n+                  Insert_Freeze_Node_For_Instance (N, F_Node);\n                   Ensure_Freeze_Node (Enclosing);\n \n                   if not Is_List_Member (Freeze_Node (Enclosing)) then\n@@ -7498,11 +7601,11 @@ package body Sem_Ch12 is\n                end;\n \n             else\n-               Insert_After_Last_Decl (N, F_Node);\n+               Insert_Freeze_Node_For_Instance (N, F_Node);\n             end if;\n \n          else\n-            Insert_After_Last_Decl (N, F_Node);\n+            Insert_Freeze_Node_For_Instance (N, F_Node);\n          end if;\n       end if;\n "}, {"sha": "34df78348c67255730f1a7e853e8f80237b0ce72", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2b4b3da0d21bea1af905d255971a4869b5617cc/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2b4b3da0d21bea1af905d255971a4869b5617cc/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=d2b4b3da0d21bea1af905d255971a4869b5617cc", "patch": "@@ -3357,10 +3357,12 @@ package body Sem_Ch4 is\n \n       Check_SPARK_Restriction (\"quantified expression is not allowed\", N);\n \n-      --  If expansion is enabled, the condition is analyzed after rewritten\n-      --  as a loop. Otherwise we only need to set the type.\n+      --  If expansion is enabled (and not in Alfa mode), the condition is\n+      --  analyzed after rewritten as a loop. So we only need to set the type.\n \n-      if Operating_Mode /= Check_Semantics then\n+      if Operating_Mode /= Check_Semantics\n+        and then not Alfa_Mode\n+      then\n          Set_Etype (N, Standard_Boolean);\n          return;\n       end if;"}, {"sha": "36b11d520c804c8309095bbe90467f9ba77bfef7", "filename": "gcc/ada/snames.ads-tmpl", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2b4b3da0d21bea1af905d255971a4869b5617cc/gcc%2Fada%2Fsnames.ads-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2b4b3da0d21bea1af905d255971a4869b5617cc/gcc%2Fada%2Fsnames.ads-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads-tmpl?ref=d2b4b3da0d21bea1af905d255971a4869b5617cc", "patch": "@@ -1193,6 +1193,7 @@ package Snames is\n    Name_Shared_Library_Suffix            : constant Name_Id := N + $;\n    Name_Separate_Suffix                  : constant Name_Id := N + $;\n    Name_Source_Dirs                      : constant Name_Id := N + $;\n+   Name_Source_File_Switches             : constant Name_Id := N + $;\n    Name_Source_Files                     : constant Name_Id := N + $;\n    Name_Source_List_File                 : constant Name_Id := N + $;\n    Name_Spec                             : constant Name_Id := N + $;"}]}