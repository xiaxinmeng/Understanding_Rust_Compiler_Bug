{"sha": "567fb6602c70e0c7341a0b1a39b017419669027b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTY3ZmI2NjAyYzcwZTBjNzM0MWEwYjFhMzliMDE3NDE5NjY5MDI3Yg==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@codesourcery.com", "date": "2005-06-26T03:49:20Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2005-06-26T03:49:20Z"}, "message": "re PR tree-optimization/22026 (ACATS FAIL C45331A fixed point wrong code (VRP related))\n\ngcc/\n\tPR tree-optimization/22026\n\t* tree-vrp.c (extract_range_from_binary_expr): Drop to\n\tVR_VARYING if a binary expression involving VR_ANTI_RANGE is\n\tPLUS_EXPR, MINUS_EXPR, or unsigned MULT_EXPR.\n\ntestsuite/\n\tPR tree-optimization/22026\n\t* gcc.dg/tree-ssa/pr22026.c: New.\n\nFrom-SVN: r101328", "tree": {"sha": "46e58ccdccdc24fd647e7fd019278bafcdc726f2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/46e58ccdccdc24fd647e7fd019278bafcdc726f2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/567fb6602c70e0c7341a0b1a39b017419669027b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/567fb6602c70e0c7341a0b1a39b017419669027b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/567fb6602c70e0c7341a0b1a39b017419669027b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/567fb6602c70e0c7341a0b1a39b017419669027b/comments", "author": null, "committer": null, "parents": [{"sha": "e4ca1c958e931abb30c966f04baa565f21bdf14f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4ca1c958e931abb30c966f04baa565f21bdf14f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e4ca1c958e931abb30c966f04baa565f21bdf14f"}], "stats": {"total": 105, "additions": 104, "deletions": 1}, "files": [{"sha": "18c7e41ea01500d20b098827b09983eae057aa8d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/567fb6602c70e0c7341a0b1a39b017419669027b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/567fb6602c70e0c7341a0b1a39b017419669027b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=567fb6602c70e0c7341a0b1a39b017419669027b", "patch": "@@ -1,4 +1,11 @@\n-2005-06-25  Kazu Hirata  <kazu@codesourcery.com>\n+2005-06-26  Kazu Hirata  <kazu@codesourcery.com>\n+\n+\tPR tree-optimization/22026\n+\t* tree-vrp.c (extract_range_from_binary_expr): Drop to\n+\tVR_VARYING if a binary expression involving VR_ANTI_RANGE is\n+\tPLUS_EXPR, MINUS_EXPR, or unsigned MULT_EXPR.\n+\n+2005-06-26  Kazu Hirata  <kazu@codesourcery.com>\n \n \t* Makefile.in (OBJS-common): Remove duplicate object file\n \tnames."}, {"sha": "71961848bd3ac1c2642340d242c7ecedba4f91e5", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/567fb6602c70e0c7341a0b1a39b017419669027b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/567fb6602c70e0c7341a0b1a39b017419669027b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=567fb6602c70e0c7341a0b1a39b017419669027b", "patch": "@@ -1,3 +1,8 @@\n+2005-06-26  Kazu Hirata  <kazu@codesourcery.com>\n+\n+\tPR tree-optimization/22026\n+\t* gcc.dg/tree-ssa/pr22026.c: New.\n+\n 2005-06-25  Thomas Koenig <Thomas.Koenig@online.de>\n \n \tPR libfortran/21144"}, {"sha": "e56e4a124adbf0e3e236c9d374e2228e24a06497", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr22026.c", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/567fb6602c70e0c7341a0b1a39b017419669027b/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr22026.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/567fb6602c70e0c7341a0b1a39b017419669027b/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr22026.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr22026.c?ref=567fb6602c70e0c7341a0b1a39b017419669027b", "patch": "@@ -0,0 +1,49 @@\n+/* PR tree-optimization/22026\n+   VRP used think that ~[0,0] + ~[0,0] = ~[0,0], which is wrong.  The\n+   same applies to subtraction and unsigned multiplication.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-vrp\" } */\n+\n+int\n+plus (int x, int y)\n+{\n+  if (x != 0)\n+    if (y != 0)\n+      {\n+        int z = x + y;\n+        if (z != 0)\n+          return 1;\n+      }\n+  return 0;\n+}\n+\n+int\n+minus (int x, int y)\n+{\n+  if (x != 0)\n+    if (y != 0)\n+      {\n+        int z = x - y;\n+        if (z != 0)\n+          return 1;\n+      }\n+  return 0;\n+}\n+\n+int\n+mult (unsigned x, unsigned y)\n+{\n+  if (x != 0)\n+    if (y != 0)\n+      {\n+\tunsigned z = x * y;\n+\tif (z != 0)\n+\t  return 1;\n+      }\n+  return 0;\n+}\n+\n+/* None of the predicates can be folded in these functions.  */\n+/* { dg-final { scan-tree-dump-times \"Folding predicate\" 0 \"vrp\" } } */\n+/* { dg-final { cleanup-tree-dump \"vrp\" } } */"}, {"sha": "e733a8de7b97f4fea9247775baf9a6df862f8d61", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/567fb6602c70e0c7341a0b1a39b017419669027b/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/567fb6602c70e0c7341a0b1a39b017419669027b/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=567fb6602c70e0c7341a0b1a39b017419669027b", "patch": "@@ -1107,6 +1107,19 @@ extract_range_from_binary_expr (value_range_t *vr, tree expr)\n \t   || code == MIN_EXPR\n \t   || code == MAX_EXPR)\n     {\n+      /* If we have a PLUS_EXPR with two VR_ANTI_RANGEs, drop to\n+\t VR_VARYING.  It would take more effort to compute a precise\n+\t range for such a case.  For example, if we have op0 == 1 and\n+\t op1 == -1 with their ranges both being ~[0,0], we would have\n+\t op0 + op1 == 0, so we cannot claim that the sum is in ~[0,0].\n+\t Note that we are guaranteed to have vr0.type == vr1.type at\n+\t this point.  */\n+      if (code == PLUS_EXPR && vr0.type == VR_ANTI_RANGE)\n+\t{\n+\t  set_value_range_to_varying (vr);\n+\t  return;\n+\t}\n+\n       /* For operations that make the resulting range directly\n \t proportional to the original ranges, apply the operation to\n \t the same end of each range.  */\n@@ -1123,6 +1136,22 @@ extract_range_from_binary_expr (value_range_t *vr, tree expr)\n       tree val[4];\n       size_t i;\n \n+      /* If we have an unsigned MULT_EXPR with two VR_ANTI_RANGEs,\n+\t drop to VR_VARYING.  It would take more effort to compute a\n+\t precise range for such a case.  For example, if we have\n+\t op0 == 65536 and op1 == 65536 with their ranges both being\n+\t ~[0,0] on a 32-bit machine, we would have op0 * op1 == 0, so\n+\t we cannot claim that the product is in ~[0,0].  Note that we\n+\t are guaranteed to have vr0.type == vr1.type at this\n+\t point.  */\n+      if (code == MULT_EXPR\n+\t  && vr0.type == VR_ANTI_RANGE\n+\t  && (flag_wrapv || TYPE_UNSIGNED (TREE_TYPE (op0))))\n+\t{\n+\t  set_value_range_to_varying (vr);\n+\t  return;\n+\t}\n+\n       /* Multiplications and divisions are a bit tricky to handle,\n \t depending on the mix of signs we have in the two ranges, we\n \t need to operate on different values to get the minimum and\n@@ -1188,6 +1217,19 @@ extract_range_from_binary_expr (value_range_t *vr, tree expr)\n     }\n   else if (code == MINUS_EXPR)\n     {\n+      /* If we have a MINUS_EXPR with two VR_ANTI_RANGEs, drop to\n+\t VR_VARYING.  It would take more effort to compute a precise\n+\t range for such a case.  For example, if we have op0 == 1 and\n+\t op1 == 1 with their ranges both being ~[0,0], we would have\n+\t op0 - op1 == 0, so we cannot claim that the difference is in\n+\t ~[0,0].  Note that we are guaranteed to have\n+\t vr0.type == vr1.type at this point.  */\n+      if (vr0.type == VR_ANTI_RANGE)\n+\t{\n+\t  set_value_range_to_varying (vr);\n+\t  return;\n+\t}\n+\n       /* For MINUS_EXPR, apply the operation to the opposite ends of\n \t each range.  */\n       min = vrp_int_const_binop (code, vr0.min, vr1.max);"}]}