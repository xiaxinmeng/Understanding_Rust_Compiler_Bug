{"sha": "929634d86bcd5007915a67ef38e50a56e0e6bfd9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTI5NjM0ZDg2YmNkNTAwNzkxNWE2N2VmMzhlNTBhNTZlMGU2YmZkOQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2012-10-20T21:00:23Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2012-10-20T21:00:23Z"}, "message": "re PR middle-end/54315 (unnecessary copy of return value for union)\n\n\tPR rtl-optimization/54315\n\t* calls.c (expand_call): Don't deal specifically with BLKmode values\n\treturned in naked registers.\n\t* expr.h (copy_blkmode_from_reg): Adjust prototype.\n\t* expr.c (copy_blkmode_from_reg): Rename first parameter into TARGET and\n\tmake it required.  Assert that SRCREG hasn't BLKmode.  Add a couple of \n\tshort-circuits for common cases and be prepared for sub-word registers.\n\t(expand_assignment): Call copy_blkmode_from_reg for BLKmode values\n\treturned in naked registers.\n\t(store_expr): Likewise.\n\t(store_field): Likewise.\n\nFrom-SVN: r192641", "tree": {"sha": "98407a614491ba2e6e3f90bd531334efd0366b60", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/98407a614491ba2e6e3f90bd531334efd0366b60"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/929634d86bcd5007915a67ef38e50a56e0e6bfd9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/929634d86bcd5007915a67ef38e50a56e0e6bfd9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/929634d86bcd5007915a67ef38e50a56e0e6bfd9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/929634d86bcd5007915a67ef38e50a56e0e6bfd9/comments", "author": null, "committer": null, "parents": [{"sha": "e598c332d81d419ecdfce59051bb4657c685e53f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e598c332d81d419ecdfce59051bb4657c685e53f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e598c332d81d419ecdfce59051bb4657c685e53f"}], "stats": {"total": 157, "additions": 98, "deletions": 59}, "files": [{"sha": "7a1aff9b2487876bcd691c2fe932110c7eef3cc4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/929634d86bcd5007915a67ef38e50a56e0e6bfd9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/929634d86bcd5007915a67ef38e50a56e0e6bfd9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=929634d86bcd5007915a67ef38e50a56e0e6bfd9", "patch": "@@ -1,3 +1,17 @@\n+2012-10-20  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\tPR rtl-optimization/54315\n+\t* calls.c (expand_call): Don't deal specifically with BLKmode values\n+\treturned in naked registers.\n+\t* expr.h (copy_blkmode_from_reg): Adjust prototype.\n+\t* expr.c (copy_blkmode_from_reg): Rename first parameter into TARGET and\n+\tmake it required.  Assert that SRCREG hasn't BLKmode.  Add a couple of \n+\tshort-circuits for common cases and be prepared for sub-word registers.\n+\t(expand_assignment): Call copy_blkmode_from_reg for BLKmode values\n+\treturned in naked registers.\n+\t(store_expr): Likewise.\n+\t(store_field): Likewise.\n+\n 2012-10-20  Jan Hubicka  <jh@suse.cz>\n \n \t* loop-unroll.c (decide_unroll_constant_iterations): Don't"}, {"sha": "64e4b09870cad252bf13aba30cb36e0955b92bd7", "filename": "gcc/calls.c", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/929634d86bcd5007915a67ef38e50a56e0e6bfd9/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/929634d86bcd5007915a67ef38e50a56e0e6bfd9/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=929634d86bcd5007915a67ef38e50a56e0e6bfd9", "patch": "@@ -3327,16 +3327,6 @@ expand_call (tree exp, rtx target, int ignore)\n \t\tsibcall_failure = 1;\n \t    }\n \t}\n-      else if (TYPE_MODE (rettype) == BLKmode)\n-\t{\n-\t  rtx val = valreg;\n-\t  if (GET_MODE (val) != BLKmode)\n-\t    val = avoid_likely_spilled_reg (val);\n-\t  target = copy_blkmode_from_reg (target, val, rettype);\n-\n-\t  /* We can not support sibling calls for this case.  */\n-\t  sibcall_failure = 1;\n-\t}\n       else\n \ttarget = copy_to_reg (avoid_likely_spilled_reg (valreg));\n "}, {"sha": "f00ae6a9eac95e15f7005c9aec2c5129987df1f0", "filename": "gcc/expr.c", "status": "modified", "additions": 83, "deletions": 48, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/929634d86bcd5007915a67ef38e50a56e0e6bfd9/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/929634d86bcd5007915a67ef38e50a56e0e6bfd9/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=929634d86bcd5007915a67ef38e50a56e0e6bfd9", "patch": "@@ -2086,39 +2086,23 @@ emit_group_store (rtx orig_dst, rtx src, tree type ATTRIBUTE_UNUSED, int ssize)\n     emit_move_insn (orig_dst, dst);\n }\n \n-/* Generate code to copy a BLKmode object of TYPE out of a\n-   set of registers starting with SRCREG into TGTBLK.  If TGTBLK\n-   is null, a stack temporary is created.  TGTBLK is returned.\n+/* Copy a BLKmode object of TYPE out of a register SRCREG into TARGET.\n \n-   The purpose of this routine is to handle functions that return\n-   BLKmode structures in registers.  Some machines (the PA for example)\n-   want to return all small structures in registers regardless of the\n-   structure's alignment.  */\n+   This is used on targets that return BLKmode values in registers.  */\n \n-rtx\n-copy_blkmode_from_reg (rtx tgtblk, rtx srcreg, tree type)\n+void\n+copy_blkmode_from_reg (rtx target, rtx srcreg, tree type)\n {\n   unsigned HOST_WIDE_INT bytes = int_size_in_bytes (type);\n   rtx src = NULL, dst = NULL;\n   unsigned HOST_WIDE_INT bitsize = MIN (TYPE_ALIGN (type), BITS_PER_WORD);\n   unsigned HOST_WIDE_INT bitpos, xbitpos, padding_correction = 0;\n+  enum machine_mode mode = GET_MODE (srcreg);\n+  enum machine_mode tmode = GET_MODE (target);\n   enum machine_mode copy_mode;\n \n-  if (tgtblk == 0)\n-    {\n-      tgtblk = assign_temp (build_qualified_type (type,\n-\t\t\t\t\t\t  (TYPE_QUALS (type)\n-\t\t\t\t\t\t   | TYPE_QUAL_CONST)),\n-\t\t\t    1, 1);\n-      preserve_temp_slots (tgtblk);\n-    }\n-\n-  /* This code assumes srcreg is at least a full word.  If it isn't, copy it\n-     into a new pseudo which is a full word.  */\n-\n-  if (GET_MODE (srcreg) != BLKmode\n-      && GET_MODE_SIZE (GET_MODE (srcreg)) < UNITS_PER_WORD)\n-    srcreg = convert_to_mode (word_mode, srcreg, TYPE_UNSIGNED (type));\n+  /* BLKmode registers created in the back-end shouldn't have survived.  */\n+  gcc_assert (mode != BLKmode);\n \n   /* If the structure doesn't take up a whole number of words, see whether\n      SRCREG is padded on the left or on the right.  If it's on the left,\n@@ -2136,22 +2120,54 @@ copy_blkmode_from_reg (rtx tgtblk, rtx srcreg, tree type)\n     padding_correction\n       = (BITS_PER_WORD - ((bytes % UNITS_PER_WORD) * BITS_PER_UNIT));\n \n+  /* We can use a single move if we have an exact mode for the size.  */\n+  else if (MEM_P (target)\n+\t   && (!SLOW_UNALIGNED_ACCESS (mode, MEM_ALIGN (target))\n+\t       || MEM_ALIGN (target) >= GET_MODE_ALIGNMENT (mode))\n+\t   && bytes == GET_MODE_SIZE (mode))\n+  {\n+    emit_move_insn (adjust_address (target, mode, 0), srcreg);\n+    return;\n+  }\n+\n+  /* And if we additionally have the same mode for a register.  */\n+  else if (REG_P (target)\n+\t   && GET_MODE (target) == mode\n+\t   && bytes == GET_MODE_SIZE (mode))\n+  {\n+    emit_move_insn (target, srcreg);\n+    return;\n+  }\n+\n+  /* This code assumes srcreg is at least a full word.  If it isn't, copy it\n+     into a new pseudo which is a full word.  */\n+  if (GET_MODE_SIZE (mode) < UNITS_PER_WORD)\n+    {\n+      srcreg = convert_to_mode (word_mode, srcreg, TYPE_UNSIGNED (type));\n+      mode = word_mode;\n+    }\n+\n   /* Copy the structure BITSIZE bits at a time.  If the target lives in\n      memory, take care of not reading/writing past its end by selecting\n      a copy mode suited to BITSIZE.  This should always be possible given\n      how it is computed.\n \n+     If the target lives in register, make sure not to select a copy mode\n+     larger than the mode of the register.\n+\n      We could probably emit more efficient code for machines which do not use\n      strict alignment, but it doesn't seem worth the effort at the current\n      time.  */\n \n   copy_mode = word_mode;\n-  if (MEM_P (tgtblk))\n+  if (MEM_P (target))\n     {\n       enum machine_mode mem_mode = mode_for_size (bitsize, MODE_INT, 1);\n       if (mem_mode != BLKmode)\n \tcopy_mode = mem_mode;\n     }\n+  else if (REG_P (target) && GET_MODE_BITSIZE (tmode) < BITS_PER_WORD)\n+    copy_mode = tmode;\n \n   for (bitpos = 0, xbitpos = padding_correction;\n        bitpos < bytes * BITS_PER_UNIT;\n@@ -2160,15 +2176,15 @@ copy_blkmode_from_reg (rtx tgtblk, rtx srcreg, tree type)\n       /* We need a new source operand each time xbitpos is on a\n \t word boundary and when xbitpos == padding_correction\n \t (the first time through).  */\n-      if (xbitpos % BITS_PER_WORD == 0\n-\t  || xbitpos == padding_correction)\n-\tsrc = operand_subword_force (srcreg, xbitpos / BITS_PER_WORD,\n-\t\t\t\t     GET_MODE (srcreg));\n+      if (xbitpos % BITS_PER_WORD == 0 || xbitpos == padding_correction)\n+\tsrc = operand_subword_force (srcreg, xbitpos / BITS_PER_WORD, mode);\n \n       /* We need a new destination operand each time bitpos is on\n \t a word boundary.  */\n-      if (bitpos % BITS_PER_WORD == 0)\n-\tdst = operand_subword (tgtblk, bitpos / BITS_PER_WORD, 1, BLKmode);\n+      if (REG_P (target) && GET_MODE_BITSIZE (tmode) < BITS_PER_WORD)\n+\tdst = target;\n+      else if (bitpos % BITS_PER_WORD == 0)\n+\tdst = operand_subword (target, bitpos / BITS_PER_WORD, 1, tmode);\n \n       /* Use xbitpos for the source extraction (right justified) and\n \t bitpos for the destination store (left justified).  */\n@@ -2177,8 +2193,6 @@ copy_blkmode_from_reg (rtx tgtblk, rtx srcreg, tree type)\n \t\t\t\t\t  xbitpos % BITS_PER_WORD, 1, false,\n \t\t\t\t\t  NULL_RTX, copy_mode, copy_mode));\n     }\n-\n-  return tgtblk;\n }\n \n /* Copy BLKmode value SRC into a register of mode MODE.  Return the\n@@ -4883,7 +4897,12 @@ expand_assignment (tree to, tree from, bool nontemporal)\n \temit_group_store (to_rtx, value, TREE_TYPE (from),\n \t\t\t  int_size_in_bytes (TREE_TYPE (from)));\n       else if (GET_MODE (to_rtx) == BLKmode)\n-\temit_block_move (to_rtx, value, expr_size (from), BLOCK_OP_NORMAL);\n+\t{\n+\t  if (REG_P (value))\n+\t    copy_blkmode_from_reg (to_rtx, value, TREE_TYPE (from));\n+\t  else\n+\t    emit_block_move (to_rtx, value, expr_size (from), BLOCK_OP_NORMAL);\n+\t}\n       else\n \t{\n \t  if (POINTER_TYPE_P (TREE_TYPE (to)))\n@@ -5225,21 +5244,26 @@ store_expr (tree exp, rtx target, int call_param_p, bool nontemporal)\n \t supposed to be bit-copied or bit-initialized.  */\n       && expr_size (exp) != const0_rtx)\n     {\n-      if (GET_MODE (temp) != GET_MODE (target)\n-\t  && GET_MODE (temp) != VOIDmode)\n+      if (GET_MODE (temp) != GET_MODE (target) && GET_MODE (temp) != VOIDmode)\n \t{\n-\t  int unsignedp = TYPE_UNSIGNED (TREE_TYPE (exp));\n-\t  if (GET_MODE (target) == BLKmode\n-\t      && GET_MODE (temp) == BLKmode)\n-\t    emit_block_move (target, temp, expr_size (exp),\n-\t\t\t     (call_param_p\n-\t\t\t      ? BLOCK_OP_CALL_PARM\n-\t\t\t      : BLOCK_OP_NORMAL));\n-\t  else if (GET_MODE (target) == BLKmode)\n-\t    store_bit_field (target, INTVAL (expr_size (exp)) * BITS_PER_UNIT,\n-\t\t\t     0, 0, 0, GET_MODE (temp), temp);\n+\t  if (GET_MODE (target) == BLKmode)\n+\t    {\n+\t      if (REG_P (temp))\n+\t        {\n+\t\t  if (TREE_CODE (exp) == CALL_EXPR)\n+\t\t    copy_blkmode_from_reg (target, temp, TREE_TYPE (exp));\n+\t\t  else\n+\t\t    store_bit_field (target,\n+\t\t\t\t     INTVAL (expr_size (exp)) * BITS_PER_UNIT,\n+\t\t\t\t     0, 0, 0, GET_MODE (temp), temp);\n+\t\t}\n+\t      else\n+\t\temit_block_move (target, temp, expr_size (exp),\n+\t\t\t\t (call_param_p\n+\t\t\t\t  ? BLOCK_OP_CALL_PARM : BLOCK_OP_NORMAL));\n+\t    }\n \t  else\n-\t    convert_move (target, temp, unsignedp);\n+\t    convert_move (target, temp, TYPE_UNSIGNED (TREE_TYPE (exp)));\n \t}\n \n       else if (GET_MODE (temp) == BLKmode && TREE_CODE (exp) == STRING_CST)\n@@ -6328,7 +6352,8 @@ store_field (rtx target, HOST_WIDE_INT bitsize, HOST_WIDE_INT bitpos,\n      twice, once with emit_move_insn and once via store_field.  */\n \n   if (mode == BLKmode\n-      && (REG_P (target) || GET_CODE (target) == SUBREG))\n+      && (REG_P (target) || GET_CODE (target) == SUBREG)\n+      && TREE_CODE (exp) != CALL_EXPR)\n     {\n       rtx object = assign_temp (type, 1, 1);\n       rtx blk_object = adjust_address (object, BLKmode, 0);\n@@ -6477,6 +6502,16 @@ store_field (rtx target, HOST_WIDE_INT bitsize, HOST_WIDE_INT bitpos,\n \t  temp = temp_target;\n \t}\n \n+      /* Handle calls that return BLKmode values in registers.  */\n+      else if (mode == BLKmode\n+\t       && REG_P (temp)\n+\t       && TREE_CODE (exp) == CALL_EXPR)\n+\t{\n+\t  rtx temp_target = gen_reg_rtx (GET_MODE (temp));\n+\t  copy_blkmode_from_reg (temp_target, temp, TREE_TYPE (exp));\n+\t  temp = temp_target;\n+\t}\n+\n       /* Store the value in the bitfield.  */\n       store_bit_field (target, bitsize, bitpos,\n \t\t       bitregion_start, bitregion_end,"}, {"sha": "0f5e8541fb07e5c35c5c208777e5edfd9f6f328e", "filename": "gcc/expr.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/929634d86bcd5007915a67ef38e50a56e0e6bfd9/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/929634d86bcd5007915a67ef38e50a56e0e6bfd9/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=929634d86bcd5007915a67ef38e50a56e0e6bfd9", "patch": "@@ -335,7 +335,7 @@ extern rtx emit_group_move_into_temps (rtx);\n extern void emit_group_store (rtx, rtx, tree, int);\n \n /* Copy BLKmode object from a set of registers.  */\n-extern rtx copy_blkmode_from_reg (rtx, rtx, tree);\n+extern void copy_blkmode_from_reg (rtx, rtx, tree);\n \n /* Mark REG as holding a parameter for the next CALL_INSN.\n    Mode is TYPE_MODE of the non-promoted parameter, or VOIDmode.  */"}]}