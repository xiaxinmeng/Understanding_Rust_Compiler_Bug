{"sha": "26958509940f82795f35673f4003a16e60cb5da1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjY5NTg1MDk5NDBmODI3OTVmMzU2NzNmNDAwM2ExNmU2MGNiNWRhMQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-04-10T14:56:02Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-04-10T14:56:02Z"}, "message": "(add/sub): Correct predicates and constraints for sNaddX and addX insns...\n\n(add/sub): Correct predicates and constraints for sNaddX and addX insns; we\ncan use sNsubX and subX to add small negative constants.\nDon't split addition to SP since we want to update it just once.\n(beq, bne): Use subtract, not compare for ints; it's more efficient.\n(define_split for comparisons): Always prefer add/sub if it will work.\n(probe_stack, allocate_stack): New patterns.\n\nFrom-SVN: r4078", "tree": {"sha": "7f61f97c45311eec3f4712a40fa35b3f075bf8db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7f61f97c45311eec3f4712a40fa35b3f075bf8db"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/26958509940f82795f35673f4003a16e60cb5da1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26958509940f82795f35673f4003a16e60cb5da1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/26958509940f82795f35673f4003a16e60cb5da1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26958509940f82795f35673f4003a16e60cb5da1/comments", "author": null, "committer": null, "parents": [{"sha": "c72fc2d9d984e877d5f912c3e59e8a12d1aad03c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c72fc2d9d984e877d5f912c3e59e8a12d1aad03c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c72fc2d9d984e877d5f912c3e59e8a12d1aad03c"}], "stats": {"total": 277, "additions": 221, "deletions": 56}, "files": [{"sha": "02af736f107cb67710563addc8b68d8154a5b26d", "filename": "gcc/config/alpha/alpha.md", "status": "modified", "additions": 221, "deletions": 56, "changes": 277, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26958509940f82795f35673f4003a16e60cb5da1/gcc%2Fconfig%2Falpha%2Falpha.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26958509940f82795f35673f4003a16e60cb5da1/gcc%2Fconfig%2Falpha%2Falpha.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.md?ref=26958509940f82795f35673f4003a16e60cb5da1", "patch": "@@ -85,12 +85,13 @@\n   [(set_attr \"type\" \"iaddlog,ld,fpop\")])\n \n (define_insn \"addsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r\")\n-\t(plus:SI (match_operand:SI 1 \"reg_or_0_operand\" \"%rJ,%rJ,%rJ\")\n-\t\t (match_operand:SI 2 \"add_operand\" \"rI,K,L\")))]\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r,r\")\n+\t(plus:SI (match_operand:SI 1 \"reg_or_0_operand\" \"%rJ,%rJ,%rJ,%rJ\")\n+\t\t (match_operand:SI 2 \"add_operand\" \"rI,O,K,L\")))]\n   \"\"\n   \"@\n    addl %r1,%2,%0\n+   subl %r1,%n2,%0\n    lda %0,%2(%r1)\n    ldah %0,%h2(%r1)\"\n   [(set_attr \"type\" \"iaddlog\")])\n@@ -129,7 +130,7 @@\n \t (plus:SI (match_operand:SI 1 \"register_operand\" \"\")\n \t\t  (match_operand:SI 2 \"const_int_operand\" \"\"))))\n    (clobber (match_operand:SI 3 \"register_operand\" \"\"))]\n-  \"! add_operand (operands[2], SImode) && INTVAL (operands[2]) > 0\n+  \"! sext_add_operand (operands[2], SImode) && INTVAL (operands[2]) > 0\n    && INTVAL (operands[2]) % 4 == 0\"\n   [(set (match_dup 3) (match_dup 4))\n    (set (match_dup 0) (sign_extend:DI (plus:SI (mult:SI (match_dup 3)\n@@ -148,21 +149,25 @@\n }\")\n \n (define_insn \"adddi3\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r,r,r\")\n-\t(plus:DI (match_operand:DI 1 \"reg_or_0_operand\" \"%rJ,%rJ,%rJ\")\n-\t\t (match_operand:DI 2 \"add_operand\" \"rI,K,L\")))]\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r,r,r,r\")\n+\t(plus:DI (match_operand:DI 1 \"reg_or_0_operand\" \"%rJ,%rJ,%rJ,%rJ\")\n+\t\t (match_operand:DI 2 \"add_operand\" \"rI,O,K,L\")))]\n   \"\"\n   \"@\n    addq %r1,%2,%0\n+   subq %r1,%n2,%0\n    lda %0,%2(%r1)\n    ldah %0,%h2(%r1)\"\n   [(set_attr \"type\" \"iaddlog\")])\n \n+;; Don't do this if we are adjusting SP since we don't want to do\n+;; it in two steps. \n (define_split\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n \t(plus:DI (match_operand:DI 1 \"register_operand\" \"\")\n \t\t (match_operand:DI 2 \"const_int_operand\" \"\")))]\n-  \"! add_operand (operands[2], DImode)\"\n+  \"! add_operand (operands[2], DImode)\n+   && REGNO (operands[0]) != STACK_POINTER_REGNUM\"\n   [(set (match_dup 0) (plus:DI (match_dup 1) (match_dup 3)))\n    (set (match_dup 0) (plus:DI (match_dup 0) (match_dup 4)))]\n   \"\n@@ -176,31 +181,37 @@\n }\")\n \n (define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(plus:SI (mult:SI (match_operand:SI 1 \"reg_or_0_operand\" \"rJ\")\n-\t\t\t  (match_operand:SI 2 \"const48_operand\" \"I\"))\n-\t\t (match_operand:SI 3 \"reg_or_8bit_operand\" \"rI\")))]\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(plus:SI (mult:SI (match_operand:SI 1 \"reg_or_0_operand\" \"rJ,rJ\")\n+\t\t\t  (match_operand:SI 2 \"const48_operand\" \"I,I\"))\n+\t\t (match_operand:SI 3 \"sext_add_operand\" \"rI,O\")))]\n   \"\"\n-  \"s%2addl %r1,%3,%0\"\n+  \"@\n+   s%2addl %r1,%3,%0\n+   s%2subl %r1,%n3,%0\"\n   [(set_attr \"type\" \"iaddlog\")])\n \n (define_insn \"\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r,r\")\n \t(sign_extend:DI\n-\t (plus:SI (mult:SI (match_operand:SI 1 \"reg_or_0_operand\" \"rJ\")\n-\t\t\t   (match_operand:SI 2 \"const48_operand\" \"I\"))\n-\t\t  (match_operand:SI 3 \"reg_or_8bit_operand\" \"rI\"))))]\n+\t (plus:SI (mult:SI (match_operand:SI 1 \"reg_or_0_operand\" \"rJ,rJ\")\n+\t\t\t   (match_operand:SI 2 \"const48_operand\" \"I,I\"))\n+\t\t  (match_operand:SI 3 \"sext_add_operand\" \"rI,O\"))))]\n   \"\"\n-  \"s%2addl %r1,%3,%0\"\n+  \"@\n+   s%2addl %r1,%3,%0\n+   s%2subl %r1,%n3,%0\"\n   [(set_attr \"type\" \"iaddlog\")])\n \n (define_insn \"\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(plus:DI (mult:DI (match_operand:DI 1 \"reg_or_0_operand\" \"rJ\")\n-\t\t\t  (match_operand:DI 2 \"const48_operand\" \"I\"))\n-\t\t (match_operand:DI 3 \"reg_or_8bit_operand\" \"rI\")))]\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r,r\")\n+\t(plus:DI (mult:DI (match_operand:DI 1 \"reg_or_0_operand\" \"rJ,rJ\")\n+\t\t\t  (match_operand:DI 2 \"const48_operand\" \"I,I\"))\n+\t\t (match_operand:DI 3 \"reg_or_8bit_operand\" \"rI,O\")))]\n   \"\"\n-  \"s%2addq %r1,%3,%0\"\n+  \"@\n+   s%2addq %r1,%3,%0\n+   s%2subq %1,%n3,%0\"\n   [(set_attr \"type\" \"iaddlog\")])\n \n ;; These variants of the above insns can occur if the third operand\n@@ -1763,10 +1774,26 @@\n   \"\"\n   \"\n {\n-  enum machine_mode mode = alpha_compare_fp_p ? DFmode : DImode;\n+  enum machine_mode mode;\n+  enum rtx_code compare_code, branch_code;\n+\n+  if (alpha_compare_fp_p)\n+    mode = DFmode, compare_code = EQ, branch_code = NE;\n+  else\n+    {\n+      mode = DImode, compare_code = MINUS, branch_code = EQ;\n+      if (GET_CODE (alpha_compare_op1) == CONST_INT)\n+\t{\n+\t  compare_code = PLUS;\n+\t  alpha_compare_op1 = GEN_INT (- INTVAL (alpha_compare_op1));\n+\t}\n+    }\n+\n   operands[1] = gen_reg_rtx (mode);\n-  operands[2] = gen_rtx (EQ, mode, alpha_compare_op0, alpha_compare_op1);\n-  operands[3] = gen_rtx (NE, VOIDmode, operands[1], CONST0_RTX (mode));\n+  operands[2] = gen_rtx (compare_code, mode,\n+\t\t\t alpha_compare_op0, alpha_compare_op1);\n+  operands[3] = gen_rtx (branch_code, VOIDmode,\n+\t\t\t operands[1], CONST0_RTX (mode));\n }\")\n \n (define_expand \"bne\"\n@@ -1778,10 +1805,26 @@\n   \"\"\n   \"\n {\n-  enum machine_mode mode = alpha_compare_fp_p ? DFmode : DImode;\n+  enum machine_mode mode;\n+  enum rtx_code compare_code, branch_code;\n+\n+  if (alpha_compare_fp_p)\n+    mode = DFmode, compare_code = EQ, branch_code = EQ;\n+  else\n+    {\n+      mode = DImode, compare_code = MINUS, branch_code = NE;\n+      if (GET_CODE (alpha_compare_op1) == CONST_INT)\n+\t{\n+\t  compare_code = PLUS;\n+\t  alpha_compare_op1 = GEN_INT (- INTVAL (alpha_compare_op1));\n+\t}\n+    }\n+\n   operands[1] = gen_reg_rtx (mode);\n-  operands[2] = gen_rtx (EQ, mode, alpha_compare_op0, alpha_compare_op1);\n-  operands[3] = gen_rtx (EQ, VOIDmode, operands[1], CONST0_RTX (mode));\n+  operands[2] = gen_rtx (compare_code, mode,\n+\t\t\t alpha_compare_op0, alpha_compare_op1);\n+  operands[3] = gen_rtx (branch_code, VOIDmode,\n+\t\t\t operands[1], CONST0_RTX (mode));\n }\")\n \n (define_expand \"blt\"\n@@ -2049,10 +2092,11 @@\n ;; not generate valid insns.\n ;;\n ;; We can also handle equality comparisons (and inequality comparisons in\n-;; cases where the resulting add cannot overflow) with out-of-range numbers by\n-;; doing an add followed by a comparison with zero.  For this case, we\n-;; also have an SImode pattern since we can merge the add and sign\n-;; extend and the order doesn't matter.\n+;; cases where the resulting add cannot overflow) by doing an add followed by\n+;; a comparison with zero.  This is faster since the addition takes one\n+;; less cycle than a compare when feeding into a conditional move.\n+;; For this case, we also have an SImode pattern since we can merge the add\n+;; and sign extend and the order doesn't matter.\n ;;\n ;; We do not do this for floating-point, since it isn't clear how the \"wrong\"\n ;; operation could have been generated.\n@@ -2087,14 +2131,16 @@\n \t   && rtx_equal_p (operands[5], operands[3]))\n     operands[5] = operands[2];\n \n-  if ((code == NE || code == EQ\n-       || (extended_count (operands[2], DImode, unsignedp) >= 1\n-\t   && extended_count (operands[3], DImode, unsignedp) >= 1))\n-      && GET_CODE (operands[3]) == CONST_INT\n-      && (unsigned) INTVAL (operands[3]) > 255)\n+  if (code == NE || code == EQ\n+      || (extended_count (operands[2], DImode, unsignedp) >= 1\n+\t  && extended_count (operands[3], DImode, unsignedp) >= 1))\n     {\n-      operands[7] = gen_rtx (PLUS, DImode, operands[2],\n-\t\t\t     GEN_INT (- INTVAL (operands[3])));\n+      if (GET_CODE (operands[3]) == CONST_INT)\n+\toperands[7] = gen_rtx (PLUS, DImode, operands[2],\n+\t\t\t       GEN_INT (- INTVAL (operands[3])));\n+      else\n+\toperands[7] = gen_rtx (MINUS, DImode, operands[2], operands[3]);\n+\n       operands[8] = gen_rtx (code, VOIDmode, operands[6], const0_rtx);\n     }\n \n@@ -2117,26 +2163,32 @@\n \t(if_then_else:DI\n \t (match_operator 1 \"comparison_operator\"\n \t\t\t [(match_operand:SI 2 \"reg_or_0_operand\" \"\")\n-\t\t\t  (match_operand:SI 3 \"const_int_operand\" \"\")])\n+\t\t\t  (match_operand:SI 3 \"reg_or_cint_operand\" \"\")])\n \t (match_operand:DI 4 \"reg_or_8bit_operand\" \"\")\n \t (match_operand:DI 5 \"reg_or_8bit_operand\" \"\")))\n    (clobber (match_operand:DI 6 \"register_operand\" \"\"))]\n-  \"(unsigned) INTVAL (operands[3]) > 255\"\n+  \"operands[3] != const0_rtx\n+   && (GET_CODE (operands[1]) == EQ || GET_CODE (operands[1]) == NE)\"\n   [(set (match_dup 6) (match_dup 7))\n    (set (match_dup 0)\n \t(if_then_else:DI (match_dup 8) (match_dup 4) (match_dup 5)))]\n   \"\n { enum rtx_code code = GET_CODE (operands[1]);\n   int unsignedp = (code == GEU || code == LEU || code == GTU || code == LTU);\n+  rtx tem;\n \n   if ((code != NE && code != EQ\n        && ! (extended_count (operands[2], DImode, unsignedp) >= 1\n \t     && extended_count (operands[3], DImode, unsignedp) >= 1)))\n     FAIL;\n  \n-  operands[7] = gen_rtx (SIGN_EXTEND, DImode,\n-\t\t\t gen_rtx (PLUS, SImode, operands[2],\n-\t\t\t\t  GEN_INT (- INTVAL (operands[3]))));\n+  if (GET_CODE (operands[3]) == CONST_INT)\n+    tem = gen_rtx (PLUS, SImode, operands[2],\n+\t\t   GEN_INT (- INTVAL (operands[3])));\n+  else\n+    tem = gen_rtx (MINUS, SImode, operands[2], operands[3]);\n+\n+  operands[7] = gen_rtx (SIGN_EXTEND, DImode, tem);\n   operands[8] = gen_rtx (GET_CODE (operands[1]), VOIDmode, operands[6],\n \t\t\t const0_rtx);\n }\")\n@@ -2157,14 +2209,16 @@\n { enum rtx_code code = GET_CODE (operands[1]);\n   int unsignedp = (code == GEU || code == LEU || code == GTU || code == LTU);\n \n-  if ((code == NE || code == EQ\n-       || (extended_count (operands[2], DImode, unsignedp) >= 1\n-\t   && extended_count (operands[3], DImode, unsignedp) >= 1))\n-      && GET_CODE (operands[3]) == CONST_INT\n-      && (unsigned) INTVAL (operands[3]) > 255)\n+  if (code == NE || code == EQ\n+      || (extended_count (operands[2], DImode, unsignedp) >= 1\n+\t  && extended_count (operands[3], DImode, unsignedp) >= 1))\n     {\n-      operands[5] = gen_rtx (PLUS, DImode, operands[2],\n-\t\t\t     GEN_INT (- INTVAL (operands[3])));\n+      if (GET_CODE (operands[3]) == CONST_INT)\n+\toperands[5] = gen_rtx (PLUS, DImode, operands[2],\n+\t\t\t       GEN_INT (- INTVAL (operands[3])));\n+      else\n+\toperands[5] = gen_rtx (MINUS, DImode, operands[2], operands[3]);\n+\n       operands[6] = gen_rtx (code, VOIDmode, operands[4], const0_rtx);\n     }\n \n@@ -2191,14 +2245,20 @@\n \t (label_ref (match_operand 0 \"\" \"\"))\n \t (pc)))\n    (clobber (match_operand:DI 4 \"register_operand\" \"\"))]\n-  \"INTVAL (operands[3]) < 0\n+  \"operands[3] != const0_rtx\n    && (GET_CODE (operands[1]) == EQ || GET_CODE (operands[1]) == NE)\"\n   [(set (match_dup 4) (match_dup 5))\n    (set (pc) (if_then_else (match_dup 6) (label_ref (match_dup 0)) (pc)))]\n   \"\n-{ operands[5] = gen_rtx (SIGN_EXTEND, DImode,\n-\t\t\t gen_rtx (PLUS, SImode, operands[2],\n-\t\t\t\t  GEN_INT (- INTVAL (operands[3]))));\n+{ rtx tem;\n+\n+  if (GET_CODE (operands[3]) == CONST_INT)\n+    tem = gen_rtx (PLUS, SImode, operands[2],\n+\t\t   GEN_INT (- INTVAL (operands[3])));\n+  else\n+    tem = gen_rtx (MINUS, SImode, operands[2], operands[3]);\n+  \n+  operands[5] = gen_rtx (SIGN_EXTEND, DImode, tem);\n   operands[6] = gen_rtx (GET_CODE (operands[1]), VOIDmode,\n \t\t\t operands[4], const0_rtx);\n }\")\n@@ -3052,3 +3112,108 @@\n \n   DONE;\n }\")\n+\f\n+;; Subroutine of stack space allocation.  Perform a stack probe.\n+(define_expand \"probe_stack\"\n+  [(set (match_dup 1) (match_operand:DI 0 \"const_int_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  operands[0] = gen_rtx (MEM, DImode, plus_constant (stack_pointer_rtx,\n+\t\t\t\t\t\t     INTVAL (operands[0])));\n+  MEM_VOLATILE_P (operands[0]) = 1;\n+\n+  operands[1] = gen_reg_rtx (DImode);\n+}\")\n+\n+;; This is how we allocate stack space.  If we are allocating a\n+;; constant amount of space and we know it is less than 4096\n+;; bytes, we need do nothing.\n+;;\n+;; If it is more than 4096 bytes, we need to probe the stack\n+;; periodically. \n+(define_expand \"allocate_stack\"\n+  [(set (reg:DI 30)\n+\t(plus:DI (reg:DI 30)\n+\t\t (match_operand:DI 0 \"reg_or_cint_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (GET_CODE (operands[0]) == CONST_INT\n+\t   && INTVAL (operands[0]) < 32768)\n+    {\n+      if (INTVAL (operands[0]) >= 4096)\n+\t{\n+\t  /* We do this the same way as in the prologue and generate explicit\n+\t     probes.  Then we update the stack by the constant.  */\n+\n+\t  int probed = 4096;\n+\n+\t  emit_insn (gen_probe_stack (GEN_INT (- probed)));\n+\t  while (probed + 8192 < INTVAL (operands[0]))\n+\t    emit_insn (gen_probe_stack (GEN_INT (- (probed += 8192))));\n+\n+\t  if (probed + 4096 < INTVAL (operands[0]))\n+\t    emit_insn (gen_probe_stack (GEN_INT (- (probed += 4096))));\n+\t}\n+\n+      operands[0] = GEN_INT (- INTVAL (operands[0]));\n+    }\n+  else\n+    {\n+      rtx out_label = 0;\n+      rtx loop_label = gen_label_rtx ();\n+      rtx count = gen_reg_rtx (DImode);\n+      rtx access = gen_reg_rtx (Pmode);\n+      rtx memref = gen_rtx (MEM, DImode, access);\n+\n+      MEM_VOLATILE_P (memref) = 1;\n+\n+      /* If the amount to be allocated is not a constant, we only need to\n+\t do something special if it is >= 4096.  */\n+\n+      if (GET_CODE (operands[0]) != CONST_INT)\n+\t{\n+\t  operands[0] = force_reg (DImode, operands[0]);\n+\t  out_label = gen_label_rtx ();\n+\t  emit_insn (gen_cmpdi (operands[0],\n+\t\t\t\tforce_reg (DImode, GEN_INT (4096))));\n+\t  emit_jump_insn (gen_ble (out_label));\n+\n+\t  /* Compute COUNT = (N + 4096) / 8192.  N is known positive.  */\n+\t  emit_insn (gen_adddi3 (count, operands[0], GEN_INT (4096)));\n+\t  emit_insn (gen_lshrdi3 (count, count, GEN_INT (13)));\n+\t}\n+      else\n+\temit_move_insn (count, GEN_INT ((INTVAL (operands[0]) + 4096) >> 13));\n+\n+      /* ACCESS = SP + 4096.  */\n+      emit_insn (gen_adddi3 (access, stack_pointer_rtx, GEN_INT (4096)));\n+      emit_label (loop_label);\n+\n+      /* Each iteration subtracts 8192 from ACCESS and references it.  */\n+      emit_insn (gen_adddi3 (count, count, constm1_rtx));\n+      emit_insn (gen_adddi3 (access, access, GEN_INT (-8192)));\n+      emit_move_insn (gen_reg_rtx (DImode), memref);\n+      emit_insn (gen_cmpdi (count, const0_rtx));\n+      emit_jump_insn (gen_bgt (loop_label));\n+\n+      if (out_label)\n+\temit_label (out_label);\n+\n+      /* We need to subtract operands[0] from SP.  We know it isn't a\n+\t constant less than 32768, so we know we have to load it into\n+\t a register.  */\n+\n+      emit_insn (gen_subdi3 (stack_pointer_rtx, stack_pointer_rtx,\n+\t\t\t     force_reg (Pmode, operands[0])));\n+\n+      /* Now, unless we have a constant and we know that we are within\n+\t 4096 from the end, we need to access sp + 4096.  */\n+      if (! (GET_CODE (operands[0]) == CONST_INT\n+\t     && (INTVAL (operands[0]) % 8192) < 4096))\n+\temit_insn (gen_probe_stack (GEN_INT (4096)));\n+\n+      DONE;\n+    }\n+}\")"}]}