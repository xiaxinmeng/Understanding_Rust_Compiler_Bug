{"sha": "52b70b1bef33b0a6a339c631b084cf030bc501e9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTJiNzBiMWJlZjMzYjBhNmEzMzljNjMxYjA4NGNmMDMwYmM1MDFlOQ==", "commit": {"author": {"name": "Thomas Quinot", "email": "quinot@adacore.com", "date": "2017-01-23T11:33:13Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-01-23T11:33:13Z"}, "message": "sem_ch13.adb (Adjust_Record_For_Reverse_Bit_Order): Split original Ada 95 part off into new subprogram below.\n\n2017-01-23  Thomas Quinot  <quinot@adacore.com>\n\n\t* sem_ch13.adb (Adjust_Record_For_Reverse_Bit_Order):\n\tSplit original Ada 95 part off into new subprogram\n\tbelow. Call that subprogram (instead of proceeding with\n\tAI95-0133 behaviour) if debug switch -gnatd.p is in use.\n\t(Adjust_Record_For_Reverse_Bit_Order_Ada_95): ... new subprogram\n\t* debug.adb Document new switch -gnatd.p\n\t* freeze.adb (Freeze_Entity.Freeze_Record_Type): Do not adjust\n\trecord for reverse bit order if an error has already been posted\n\ton the record type.  This avoids generating extraneous \"info:\"\n\tmessages for illegal code.\n\nFrom-SVN: r244786", "tree": {"sha": "f3f25445d145ac100f2433babca3f8a02c79478d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f3f25445d145ac100f2433babca3f8a02c79478d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/52b70b1bef33b0a6a339c631b084cf030bc501e9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52b70b1bef33b0a6a339c631b084cf030bc501e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/52b70b1bef33b0a6a339c631b084cf030bc501e9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52b70b1bef33b0a6a339c631b084cf030bc501e9/comments", "author": null, "committer": null, "parents": [{"sha": "2a02fa985d8c474e0855f1354746f54a2b3fc749", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a02fa985d8c474e0855f1354746f54a2b3fc749", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a02fa985d8c474e0855f1354746f54a2b3fc749"}], "stats": {"total": 692, "additions": 364, "deletions": 328}, "files": [{"sha": "91aaddae5d33bae367e22e4aac7e69d371b8f8aa", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52b70b1bef33b0a6a339c631b084cf030bc501e9/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52b70b1bef33b0a6a339c631b084cf030bc501e9/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=52b70b1bef33b0a6a339c631b084cf030bc501e9", "patch": "@@ -1,3 +1,16 @@\n+2017-01-23  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* sem_ch13.adb (Adjust_Record_For_Reverse_Bit_Order):\n+\tSplit original Ada 95 part off into new subprogram\n+\tbelow. Call that subprogram (instead of proceeding with\n+\tAI95-0133 behaviour) if debug switch -gnatd.p is in use.\n+\t(Adjust_Record_For_Reverse_Bit_Order_Ada_95): ... new subprogram\n+\t* debug.adb Document new switch -gnatd.p\n+\t* freeze.adb (Freeze_Entity.Freeze_Record_Type): Do not adjust\n+\trecord for reverse bit order if an error has already been posted\n+\ton the record type.  This avoids generating extraneous \"info:\"\n+\tmessages for illegal code.\n+\n 2017-01-23  Justin Squirek  <squirek@adacore.com>\n \n \t* sem_ch3.adb (Analyze_Declarations): Correct comments"}, {"sha": "01144f558834daf6b2a261545e958906873f59c2", "filename": "gcc/ada/debug.adb", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52b70b1bef33b0a6a339c631b084cf030bc501e9/gcc%2Fada%2Fdebug.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52b70b1bef33b0a6a339c631b084cf030bc501e9/gcc%2Fada%2Fdebug.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdebug.adb?ref=52b70b1bef33b0a6a339c631b084cf030bc501e9", "patch": "@@ -106,7 +106,7 @@ package body Debug is\n    --  d.m  For -gnatl, print full source only for main unit\n    --  d.n  Print source file names\n    --  d.o  Conservative elaboration order for indirect calls\n-   --  d.p\n+   --  d.p  Use original Ada 95 semantics for Bit_Order (disable AI95-0133)\n    --  d.q\n    --  d.r  Enable OK_To_Reorder_Components in non-variant records\n    --  d.s\n@@ -558,6 +558,10 @@ package body Debug is\n    --  d.o  Conservative elaboration order for indirect calls. This causes\n    --       P'Access to be treated as a call in more cases.\n \n+   --  d.p  In Ada 95 (or 83) mode, use original Ada 95 behaviour for the\n+   --       interpretation of component clauses crossing byte boundaries when\n+   --       using the non-default bit order (i.e. ignore AI95-0133).\n+\n    --  d.r  Forces the flag OK_To_Reorder_Components to be set in all record\n    --       base types that have no discriminants.\n "}, {"sha": "0dd558713e01aec3494e073312fb58283ec52d8f", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52b70b1bef33b0a6a339c631b084cf030bc501e9/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52b70b1bef33b0a6a339c631b084cf030bc501e9/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=52b70b1bef33b0a6a339c631b084cf030bc501e9", "patch": "@@ -4262,10 +4262,14 @@ package body Freeze is\n                  (\"\\??since no component clauses were specified\", ADC);\n \n             --  Here is where we do the processing to adjust component clauses\n-            --  for reversed bit order, when not using reverse SSO.\n+            --  for reversed bit order, when not using reverse SSO. If an error\n+            --  has been reported on Rec already (such as SSO incompatible with\n+            --  bit order), don't bother adjusting as this may generate extra\n+            --  noise.\n \n             elsif Reverse_Bit_Order (Rec)\n               and then not Reverse_Storage_Order (Rec)\n+              and then not Error_Posted (Rec)\n             then\n                Adjust_Record_For_Reverse_Bit_Order (Rec);\n "}, {"sha": "99568146a6fced2d9279db438f3674f159f63cbb", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 338, "deletions": 324, "changes": 662, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52b70b1bef33b0a6a339c631b084cf030bc501e9/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52b70b1bef33b0a6a339c631b084cf030bc501e9/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=52b70b1bef33b0a6a339c631b084cf030bc501e9", "patch": "@@ -80,6 +80,10 @@ package body Sem_Ch13 is\n    -- Local Subprograms --\n    -----------------------\n \n+   procedure Adjust_Record_For_Reverse_Bit_Order_Ada_95 (R : Entity_Id);\n+   --  Helper routine providing the original (pre-AI95-0133) behaviour for\n+   --  Adjust_Record_For_Reverse_Bit_Order.\n+\n    procedure Alignment_Check_For_Size_Change (Typ : Entity_Id; Size : Uint);\n    --  This routine is called after setting one of the sizes of type entity\n    --  Typ to Size. The purpose is to deal with the situation of a derived\n@@ -351,372 +355,404 @@ package body Sem_Ch13 is\n       Comp : Node_Id;\n       CC   : Node_Id;\n \n-   begin\n-      --  Processing depends on version of Ada\n+      Max_Machine_Scalar_Size : constant Uint :=\n+                                  UI_From_Int\n+                                    (Standard_Long_Long_Integer_Size);\n+      --  We use this as the maximum machine scalar size\n \n-      --  For Ada 95, we just renumber bits within a storage unit. We do the\n-      --  same for Ada 83 mode, since we recognize the Bit_Order attribute in\n-      --  Ada 83, and are free to add this extension.\n+      Num_CC : Natural;\n+      SSU    : constant Uint := UI_From_Int (System_Storage_Unit);\n \n-      if Ada_Version < Ada_2005 then\n-         Comp := First_Component_Or_Discriminant (R);\n-         while Present (Comp) loop\n-            CC := Component_Clause (Comp);\n+   begin\n+      --  Processing here used to depend on Ada version: the behaviour was\n+      --  changed by AI95-0133. However this AI is a Binding interpretation,\n+      --  so we now implement it even in Ada 95 mode. The original behaviour\n+      --  from unamended Ada 95 is still available for compatibility under\n+      --  debugging switch -gnatd.\n+\n+      if Ada_Version < Ada_2005 and then Debug_Flag_Dot_P then\n+         Adjust_Record_For_Reverse_Bit_Order_Ada_95 (R);\n+         return;\n+      end if;\n+\n+      --  For Ada 2005, we do machine scalar processing, as fully described In\n+      --  AI-133. This involves gathering all components which start at the\n+      --  same byte offset and processing them together. Same approach is still\n+      --  valid in later versions including Ada 2012.\n \n-            --  If component clause is present, then deal with the non-default\n-            --  bit order case for Ada 95 mode.\n+      --  This first loop through components does two things. First it\n+      --  deals with the case of components with component clauses whose\n+      --  length is greater than the maximum machine scalar size (either\n+      --  accepting them or rejecting as needed). Second, it counts the\n+      --  number of components with component clauses whose length does\n+      --  not exceed this maximum for later processing.\n \n-            --  We only do this processing for the base type, and in fact that\n-            --  is important, since otherwise if there are record subtypes, we\n-            --  could reverse the bits once for each subtype, which is wrong.\n+      Num_CC := 0;\n+      Comp   := First_Component_Or_Discriminant (R);\n+      while Present (Comp) loop\n+         CC := Component_Clause (Comp);\n \n-            if Present (CC) and then Ekind (R) = E_Record_Type then\n-               declare\n-                  CFB : constant Uint    := Component_Bit_Offset (Comp);\n-                  CSZ : constant Uint    := Esize (Comp);\n-                  CLC : constant Node_Id := Component_Clause (Comp);\n-                  Pos : constant Node_Id := Position (CLC);\n-                  FB  : constant Node_Id := First_Bit (CLC);\n+         if Present (CC) then\n+            declare\n+               Fbit : constant Uint := Static_Integer (First_Bit (CC));\n+               Lbit : constant Uint := Static_Integer (Last_Bit (CC));\n \n-                  Storage_Unit_Offset : constant Uint :=\n-                                          CFB / System_Storage_Unit;\n+            begin\n+               --  Case of component with last bit >= max machine scalar\n \n-                  Start_Bit : constant Uint :=\n-                                CFB mod System_Storage_Unit;\n+               if Lbit >= Max_Machine_Scalar_Size then\n \n-               begin\n-                  --  Cases where field goes over storage unit boundary\n+                  --  This is allowed only if first bit is zero, and\n+                  --  last bit + 1 is a multiple of storage unit size.\n \n-                  if Start_Bit + CSZ > System_Storage_Unit then\n+                  if Fbit = 0 and then (Lbit + 1) mod SSU = 0 then\n \n-                     --  Allow multi-byte field but generate warning\n+                     --  This is the case to give a warning if enabled\n \n-                     if Start_Bit mod System_Storage_Unit = 0\n-                       and then CSZ mod System_Storage_Unit = 0\n-                     then\n+                     if Warn_On_Reverse_Bit_Order then\n                         Error_Msg_N\n                           (\"info: multi-byte field specified with \"\n-                           & \"non-standard Bit_Order?V?\", CLC);\n+                           & \"non-standard Bit_Order?V?\", CC);\n \n                         if Bytes_Big_Endian then\n                            Error_Msg_N\n                              (\"\\bytes are not reversed \"\n-                              & \"(component is big-endian)?V?\", CLC);\n+                              & \"(component is big-endian)?V?\", CC);\n                         else\n                            Error_Msg_N\n                              (\"\\bytes are not reversed \"\n-                              & \"(component is little-endian)?V?\", CLC);\n+                              & \"(component is little-endian)?V?\", CC);\n                         end if;\n+                     end if;\n \n-                     --  Do not allow non-contiguous field\n+                  --  Give error message for RM 13.5.1(10) violation\n+\n+                  else\n+                     Error_Msg_FE\n+                       (\"machine scalar rules not followed for&\",\n+                        First_Bit (CC), Comp);\n+\n+                     Error_Msg_Uint_1 := Lbit + 1;\n+                     Error_Msg_Uint_2 := Max_Machine_Scalar_Size;\n+                     Error_Msg_F\n+                       (\"\\last bit + 1 (^) exceeds maximum machine \"\n+                        & \"scalar size (^)\",\n+                        First_Bit (CC));\n+\n+                     if (Lbit + 1) mod SSU /= 0 then\n+                        Error_Msg_Uint_1 := SSU;\n+                        Error_Msg_F\n+                          (\"\\and is not a multiple of Storage_Unit (^) \"\n+                           & \"(RM 13.5.1(10))\",\n+                           First_Bit (CC));\n \n                      else\n-                        Error_Msg_N\n-                          (\"attempt to specify non-contiguous field \"\n-                           & \"not permitted\", CLC);\n-                        Error_Msg_N\n-                          (\"\\caused by non-standard Bit_Order \"\n-                           & \"specified\", CLC);\n-                        Error_Msg_N\n-                          (\"\\consider possibility of using \"\n-                           & \"Ada 2005 mode here\", CLC);\n+                        Error_Msg_Uint_1 := Fbit;\n+                        Error_Msg_F\n+                          (\"\\and first bit (^) is non-zero \"\n+                           & \"(RM 13.4.1(10))\",\n+                           First_Bit (CC));\n                      end if;\n+                  end if;\n \n-                  --  Case where field fits in one storage unit\n+               --  OK case of machine scalar related component clause,\n+               --  For now, just count them.\n \n-                  else\n-                     --  Give warning if suspicious component clause\n+               else\n+                  Num_CC := Num_CC + 1;\n+               end if;\n+            end;\n+         end if;\n \n-                     if Intval (FB) >= System_Storage_Unit\n-                       and then Warn_On_Reverse_Bit_Order\n-                     then\n-                        Error_Msg_N\n-                          (\"info: Bit_Order clause does not affect \" &\n-                           \"byte ordering?V?\", Pos);\n-                        Error_Msg_Uint_1 :=\n-                          Intval (Pos) + Intval (FB) /\n-                          System_Storage_Unit;\n-                        Error_Msg_N\n-                          (\"info: position normalized to ^ before bit \" &\n-                           \"order interpreted?V?\", Pos);\n-                     end if;\n+         Next_Component_Or_Discriminant (Comp);\n+      end loop;\n \n-                     --  Here is where we fix up the Component_Bit_Offset value\n-                     --  to account for the reverse bit order. Some examples of\n-                     --  what needs to be done are:\n+      --  We need to sort the component clauses on the basis of the\n+      --  Position values in the clause, so we can group clauses with\n+      --  the same Position together to determine the relevant machine\n+      --  scalar size.\n \n-                     --    First_Bit .. Last_Bit     Component_Bit_Offset\n-                     --      old          new          old       new\n+      Sort_CC : declare\n+         Comps : array (0 .. Num_CC) of Entity_Id;\n+         --  Array to collect component and discriminant entities. The\n+         --  data starts at index 1, the 0'th entry is for the sort\n+         --  routine.\n \n-                     --     0 .. 0       7 .. 7         0         7\n-                     --     0 .. 1       6 .. 7         0         6\n-                     --     0 .. 2       5 .. 7         0         5\n-                     --     0 .. 7       0 .. 7         0         4\n+         function CP_Lt (Op1, Op2 : Natural) return Boolean;\n+         --  Compare routine for Sort\n \n-                     --     1 .. 1       6 .. 6         1         6\n-                     --     1 .. 4       3 .. 6         1         3\n-                     --     4 .. 7       0 .. 3         4         0\n+         procedure CP_Move (From : Natural; To : Natural);\n+         --  Move routine for Sort\n \n-                     --  The rule is that the first bit is is obtained by\n-                     --  subtracting the old ending bit from storage_unit - 1.\n+         package Sorting is new GNAT.Heap_Sort_G (CP_Move, CP_Lt);\n \n-                     Set_Component_Bit_Offset\n-                       (Comp,\n-                        (Storage_Unit_Offset * System_Storage_Unit) +\n-                          (System_Storage_Unit - 1) -\n-                          (Start_Bit + CSZ - 1));\n+         Start : Natural;\n+         Stop  : Natural;\n+         --  Start and stop positions in the component list of the set of\n+         --  components with the same starting position (that constitute\n+         --  components in a single machine scalar).\n \n-                     Set_Normalized_First_Bit\n-                       (Comp,\n-                        Component_Bit_Offset (Comp) mod\n-                          System_Storage_Unit);\n-                  end if;\n-               end;\n-            end if;\n+         MaxL  : Uint;\n+         --  Maximum last bit value of any component in this set\n \n-            Next_Component_Or_Discriminant (Comp);\n-         end loop;\n+         MSS   : Uint;\n+         --  Corresponding machine scalar size\n \n-      --  For Ada 2005, we do machine scalar processing, as fully described In\n-      --  AI-133. This involves gathering all components which start at the\n-      --  same byte offset and processing them together. Same approach is still\n-      --  valid in later versions including Ada 2012.\n+         -----------\n+         -- CP_Lt --\n+         -----------\n \n-      else\n-         declare\n-            Max_Machine_Scalar_Size : constant Uint :=\n-                                        UI_From_Int\n-                                          (Standard_Long_Long_Integer_Size);\n-            --  We use this as the maximum machine scalar size\n+         function CP_Lt (Op1, Op2 : Natural) return Boolean is\n+         begin\n+            return Position (Component_Clause (Comps (Op1))) <\n+              Position (Component_Clause (Comps (Op2)));\n+         end CP_Lt;\n \n-            Num_CC : Natural;\n-            SSU    : constant Uint := UI_From_Int (System_Storage_Unit);\n+         -------------\n+         -- CP_Move --\n+         -------------\n \n+         procedure CP_Move (From : Natural; To : Natural) is\n          begin\n-            --  This first loop through components does two things. First it\n-            --  deals with the case of components with component clauses whose\n-            --  length is greater than the maximum machine scalar size (either\n-            --  accepting them or rejecting as needed). Second, it counts the\n-            --  number of components with component clauses whose length does\n-            --  not exceed this maximum for later processing.\n-\n-            Num_CC := 0;\n-            Comp   := First_Component_Or_Discriminant (R);\n-            while Present (Comp) loop\n-               CC := Component_Clause (Comp);\n+            Comps (To) := Comps (From);\n+         end CP_Move;\n \n-               if Present (CC) then\n-                  declare\n-                     Fbit : constant Uint := Static_Integer (First_Bit (CC));\n-                     Lbit : constant Uint := Static_Integer (Last_Bit (CC));\n+      --  Start of processing for Sort_CC\n \n-                  begin\n-                     --  Case of component with last bit >= max machine scalar\n+      begin\n+         --  Collect the machine scalar relevant component clauses\n \n-                     if Lbit >= Max_Machine_Scalar_Size then\n+         Num_CC := 0;\n+         Comp   := First_Component_Or_Discriminant (R);\n+         while Present (Comp) loop\n+            declare\n+               CC   : constant Node_Id := Component_Clause (Comp);\n \n-                        --  This is allowed only if first bit is zero, and\n-                        --  last bit + 1 is a multiple of storage unit size.\n+            begin\n+               --  Collect only component clauses whose last bit is less\n+               --  than machine scalar size. Any component clause whose\n+               --  last bit exceeds this value does not take part in\n+               --  machine scalar layout considerations. The test for\n+               --  Error_Posted makes sure we exclude component clauses\n+               --  for which we already posted an error.\n+\n+               if Present (CC)\n+                 and then not Error_Posted (Last_Bit (CC))\n+                 and then Static_Integer (Last_Bit (CC)) <\n+                                              Max_Machine_Scalar_Size\n+               then\n+                  Num_CC := Num_CC + 1;\n+                  Comps (Num_CC) := Comp;\n+               end if;\n+            end;\n \n-                        if Fbit = 0 and then (Lbit + 1) mod SSU = 0 then\n+            Next_Component_Or_Discriminant (Comp);\n+         end loop;\n \n-                           --  This is the case to give a warning if enabled\n+         --  Sort by ascending position number\n+\n+         Sorting.Sort (Num_CC);\n+\n+         --  We now have all the components whose size does not exceed\n+         --  the max machine scalar value, sorted by starting position.\n+         --  In this loop we gather groups of clauses starting at the\n+         --  same position, to process them in accordance with AI-133.\n+\n+         Stop := 0;\n+         while Stop < Num_CC loop\n+            Start := Stop + 1;\n+            Stop  := Start;\n+            MaxL  :=\n+              Static_Integer\n+                (Last_Bit (Component_Clause (Comps (Start))));\n+            while Stop < Num_CC loop\n+               if Static_Integer\n+                    (Position (Component_Clause (Comps (Stop + 1)))) =\n+                  Static_Integer\n+                    (Position (Component_Clause (Comps (Stop))))\n+               then\n+                  Stop := Stop + 1;\n+                  MaxL :=\n+                    UI_Max\n+                      (MaxL,\n+                       Static_Integer\n+                         (Last_Bit\n+                            (Component_Clause (Comps (Stop)))));\n+               else\n+                  exit;\n+               end if;\n+            end loop;\n \n-                           if Warn_On_Reverse_Bit_Order then\n-                              Error_Msg_N\n-                                (\"info: multi-byte field specified with \"\n-                                 & \"non-standard Bit_Order?V?\", CC);\n-\n-                              if Bytes_Big_Endian then\n-                                 Error_Msg_N\n-                                   (\"\\bytes are not reversed \"\n-                                    & \"(component is big-endian)?V?\", CC);\n-                              else\n-                                 Error_Msg_N\n-                                   (\"\\bytes are not reversed \"\n-                                    & \"(component is little-endian)?V?\", CC);\n-                              end if;\n-                           end if;\n+            --  Now we have a group of component clauses from Start to\n+            --  Stop whose positions are identical, and MaxL is the\n+            --  maximum last bit value of any of these components.\n \n-                        --  Give error message for RM 13.5.1(10) violation\n+            --  We need to determine the corresponding machine scalar\n+            --  size. This loop assumes that machine scalar sizes are\n+            --  even, and that each possible machine scalar has twice\n+            --  as many bits as the next smaller one.\n \n-                        else\n-                           Error_Msg_FE\n-                             (\"machine scalar rules not followed for&\",\n-                              First_Bit (CC), Comp);\n+            MSS := Max_Machine_Scalar_Size;\n+            while MSS mod 2 = 0\n+              and then (MSS / 2) >= SSU\n+              and then (MSS / 2) > MaxL\n+            loop\n+               MSS := MSS / 2;\n+            end loop;\n \n-                           Error_Msg_Uint_1 := Lbit + 1;\n-                           Error_Msg_Uint_2 := Max_Machine_Scalar_Size;\n-                           Error_Msg_F\n-                             (\"\\last bit + 1 (^) exceeds maximum machine \"\n-                              & \"scalar size (^)\",\n-                              First_Bit (CC));\n+            --  Here is where we fix up the Component_Bit_Offset value\n+            --  to account for the reverse bit order. Some examples of\n+            --  what needs to be done for the case of a machine scalar\n+            --  size of 8 are:\n \n-                           if (Lbit + 1) mod SSU /= 0 then\n-                              Error_Msg_Uint_1 := SSU;\n-                              Error_Msg_F\n-                                (\"\\and is not a multiple of Storage_Unit (^) \"\n-                                 & \"(RM 13.5.1(10))\",\n-                                 First_Bit (CC));\n+            --    First_Bit .. Last_Bit     Component_Bit_Offset\n+            --      old          new          old       new\n \n-                           else\n-                              Error_Msg_Uint_1 := Fbit;\n-                              Error_Msg_F\n-                                (\"\\and first bit (^) is non-zero \"\n-                                 & \"(RM 13.4.1(10))\",\n-                                 First_Bit (CC));\n-                           end if;\n-                        end if;\n+            --     0 .. 0       7 .. 7         0         7\n+            --     0 .. 1       6 .. 7         0         6\n+            --     0 .. 2       5 .. 7         0         5\n+            --     0 .. 7       0 .. 7         0         4\n \n-                     --  OK case of machine scalar related component clause,\n-                     --  For now, just count them.\n+            --     1 .. 1       6 .. 6         1         6\n+            --     1 .. 4       3 .. 6         1         3\n+            --     4 .. 7       0 .. 3         4         0\n \n-                     else\n-                        Num_CC := Num_CC + 1;\n-                     end if;\n-                  end;\n-               end if;\n+            --  The rule is that the first bit is obtained by subtracting\n+            --  the old ending bit from machine scalar size - 1.\n \n-               Next_Component_Or_Discriminant (Comp);\n-            end loop;\n+            for C in Start .. Stop loop\n+               declare\n+                  Comp : constant Entity_Id := Comps (C);\n+                  CC   : constant Node_Id   := Component_Clause (Comp);\n \n-            --  We need to sort the component clauses on the basis of the\n-            --  Position values in the clause, so we can group clauses with\n-            --  the same Position together to determine the relevant machine\n-            --  scalar size.\n+                  LB   : constant Uint := Static_Integer (Last_Bit (CC));\n+                  NFB  : constant Uint := MSS - Uint_1 - LB;\n+                  NLB  : constant Uint := NFB + Esize (Comp) - 1;\n+                  Pos  : constant Uint := Static_Integer (Position (CC));\n \n-            Sort_CC : declare\n-               Comps : array (0 .. Num_CC) of Entity_Id;\n-               --  Array to collect component and discriminant entities. The\n-               --  data starts at index 1, the 0'th entry is for the sort\n-               --  routine.\n+               begin\n+                  if Warn_On_Reverse_Bit_Order then\n+                     Error_Msg_Uint_1 := MSS;\n+                     Error_Msg_N\n+                       (\"info: reverse bit order in machine \" &\n+                        \"scalar of length^?V?\", First_Bit (CC));\n+                     Error_Msg_Uint_1 := NFB;\n+                     Error_Msg_Uint_2 := NLB;\n \n-               function CP_Lt (Op1, Op2 : Natural) return Boolean;\n-               --  Compare routine for Sort\n+                     if Bytes_Big_Endian then\n+                        Error_Msg_NE\n+                          (\"\\big-endian range for component \"\n+                           & \"& is ^ .. ^?V?\", First_Bit (CC), Comp);\n+                     else\n+                        Error_Msg_NE\n+                          (\"\\little-endian range for component\"\n+                           & \"& is ^ .. ^?V?\", First_Bit (CC), Comp);\n+                     end if;\n+                  end if;\n \n-               procedure CP_Move (From : Natural; To : Natural);\n-               --  Move routine for Sort\n+                  Set_Component_Bit_Offset (Comp, Pos * SSU + NFB);\n+                  Set_Normalized_First_Bit (Comp, NFB mod SSU);\n+               end;\n+            end loop;\n+         end loop;\n+      end Sort_CC;\n+   end Adjust_Record_For_Reverse_Bit_Order;\n \n-               package Sorting is new GNAT.Heap_Sort_G (CP_Move, CP_Lt);\n+   ------------------------------------------------\n+   -- Adjust_Record_For_Reverse_Bit_Order_Ada_95 --\n+   ------------------------------------------------\n \n-               Start : Natural;\n-               Stop  : Natural;\n-               --  Start and stop positions in the component list of the set of\n-               --  components with the same starting position (that constitute\n-               --  components in a single machine scalar).\n+   procedure Adjust_Record_For_Reverse_Bit_Order_Ada_95 (R : Entity_Id) is\n+      Comp : Node_Id;\n+      CC   : Node_Id;\n \n-               MaxL  : Uint;\n-               --  Maximum last bit value of any component in this set\n+   begin\n+      --  For Ada 95, we just renumber bits within a storage unit. We do the\n+      --  same for Ada 83 mode, since we recognize the Bit_Order attribute in\n+      --  Ada 83, and are free to add this extension.\n \n-               MSS   : Uint;\n-               --  Corresponding machine scalar size\n+      Comp := First_Component_Or_Discriminant (R);\n+      while Present (Comp) loop\n+         CC := Component_Clause (Comp);\n \n-               -----------\n-               -- CP_Lt --\n-               -----------\n+         --  If component clause is present, then deal with the non-default\n+         --  bit order case for Ada 95 mode.\n \n-               function CP_Lt (Op1, Op2 : Natural) return Boolean is\n-               begin\n-                  return Position (Component_Clause (Comps (Op1))) <\n-                    Position (Component_Clause (Comps (Op2)));\n-               end CP_Lt;\n+         --  We only do this processing for the base type, and in fact that\n+         --  is important, since otherwise if there are record subtypes, we\n+         --  could reverse the bits once for each subtype, which is wrong.\n \n-               -------------\n-               -- CP_Move --\n-               -------------\n+         if Present (CC) and then Ekind (R) = E_Record_Type then\n+            declare\n+               CFB : constant Uint    := Component_Bit_Offset (Comp);\n+               CSZ : constant Uint    := Esize (Comp);\n+               CLC : constant Node_Id := Component_Clause (Comp);\n+               Pos : constant Node_Id := Position (CLC);\n+               FB  : constant Node_Id := First_Bit (CLC);\n \n-               procedure CP_Move (From : Natural; To : Natural) is\n-               begin\n-                  Comps (To) := Comps (From);\n-               end CP_Move;\n+               Storage_Unit_Offset : constant Uint :=\n+                                       CFB / System_Storage_Unit;\n \n-            --  Start of processing for Sort_CC\n+               Start_Bit : constant Uint :=\n+                             CFB mod System_Storage_Unit;\n \n             begin\n-               --  Collect the machine scalar relevant component clauses\n+               --  Cases where field goes over storage unit boundary\n \n-               Num_CC := 0;\n-               Comp   := First_Component_Or_Discriminant (R);\n-               while Present (Comp) loop\n-                  declare\n-                     CC   : constant Node_Id := Component_Clause (Comp);\n+               if Start_Bit + CSZ > System_Storage_Unit then\n \n-                  begin\n-                     --  Collect only component clauses whose last bit is less\n-                     --  than machine scalar size. Any component clause whose\n-                     --  last bit exceeds this value does not take part in\n-                     --  machine scalar layout considerations. The test for\n-                     --  Error_Posted makes sure we exclude component clauses\n-                     --  for which we already posted an error.\n-\n-                     if Present (CC)\n-                       and then not Error_Posted (Last_Bit (CC))\n-                       and then Static_Integer (Last_Bit (CC)) <\n-                                                    Max_Machine_Scalar_Size\n-                     then\n-                        Num_CC := Num_CC + 1;\n-                        Comps (Num_CC) := Comp;\n-                     end if;\n-                  end;\n+                  --  Allow multi-byte field but generate warning\n \n-                  Next_Component_Or_Discriminant (Comp);\n-               end loop;\n+                  if Start_Bit mod System_Storage_Unit = 0\n+                    and then CSZ mod System_Storage_Unit = 0\n+                  then\n+                     Error_Msg_N\n+                       (\"info: multi-byte field specified with \"\n+                        & \"non-standard Bit_Order?V?\", CLC);\n \n-               --  Sort by ascending position number\n-\n-               Sorting.Sort (Num_CC);\n-\n-               --  We now have all the components whose size does not exceed\n-               --  the max machine scalar value, sorted by starting position.\n-               --  In this loop we gather groups of clauses starting at the\n-               --  same position, to process them in accordance with AI-133.\n-\n-               Stop := 0;\n-               while Stop < Num_CC loop\n-                  Start := Stop + 1;\n-                  Stop  := Start;\n-                  MaxL  :=\n-                    Static_Integer\n-                      (Last_Bit (Component_Clause (Comps (Start))));\n-                  while Stop < Num_CC loop\n-                     if Static_Integer\n-                          (Position (Component_Clause (Comps (Stop + 1)))) =\n-                        Static_Integer\n-                          (Position (Component_Clause (Comps (Stop))))\n-                     then\n-                        Stop := Stop + 1;\n-                        MaxL :=\n-                          UI_Max\n-                            (MaxL,\n-                             Static_Integer\n-                               (Last_Bit\n-                                  (Component_Clause (Comps (Stop)))));\n+                     if Bytes_Big_Endian then\n+                        Error_Msg_N\n+                          (\"\\bytes are not reversed \"\n+                           & \"(component is big-endian)?V?\", CLC);\n                      else\n-                        exit;\n+                        Error_Msg_N\n+                          (\"\\bytes are not reversed \"\n+                           & \"(component is little-endian)?V?\", CLC);\n                      end if;\n-                  end loop;\n \n-                  --  Now we have a group of component clauses from Start to\n-                  --  Stop whose positions are identical, and MaxL is the\n-                  --  maximum last bit value of any of these components.\n-\n-                  --  We need to determine the corresponding machine scalar\n-                  --  size. This loop assumes that machine scalar sizes are\n-                  --  even, and that each possible machine scalar has twice\n-                  --  as many bits as the next smaller one.\n-\n-                  MSS := Max_Machine_Scalar_Size;\n-                  while MSS mod 2 = 0\n-                    and then (MSS / 2) >= SSU\n-                    and then (MSS / 2) > MaxL\n-                  loop\n-                     MSS := MSS / 2;\n-                  end loop;\n+                  --  Do not allow non-contiguous field\n+\n+                  else\n+                     Error_Msg_N\n+                       (\"attempt to specify non-contiguous field \"\n+                        & \"not permitted\", CLC);\n+                     Error_Msg_N\n+                       (\"\\caused by non-standard Bit_Order \"\n+                        & \"specified in legacy Ada 95 mode\", CLC);\n+                  end if;\n+\n+               --  Case where field fits in one storage unit\n+\n+               else\n+                  --  Give warning if suspicious component clause\n+\n+                  if Intval (FB) >= System_Storage_Unit\n+                    and then Warn_On_Reverse_Bit_Order\n+                  then\n+                     Error_Msg_N\n+                       (\"info: Bit_Order clause does not affect \" &\n+                        \"byte ordering?V?\", Pos);\n+                     Error_Msg_Uint_1 :=\n+                       Intval (Pos) + Intval (FB) /\n+                       System_Storage_Unit;\n+                     Error_Msg_N\n+                       (\"info: position normalized to ^ before bit \" &\n+                        \"order interpreted?V?\", Pos);\n+                  end if;\n \n                   --  Here is where we fix up the Component_Bit_Offset value\n                   --  to account for the reverse bit order. Some examples of\n-                  --  what needs to be done for the case of a machine scalar\n-                  --  size of 8 are:\n+                  --  what needs to be done are:\n \n                   --    First_Bit .. Last_Bit     Component_Bit_Offset\n                   --      old          new          old       new\n@@ -730,48 +766,26 @@ package body Sem_Ch13 is\n                   --     1 .. 4       3 .. 6         1         3\n                   --     4 .. 7       0 .. 3         4         0\n \n-                  --  The rule is that the first bit is obtained by subtracting\n-                  --  the old ending bit from machine scalar size - 1.\n-\n-                  for C in Start .. Stop loop\n-                     declare\n-                        Comp : constant Entity_Id := Comps (C);\n-                        CC   : constant Node_Id   := Component_Clause (Comp);\n+                  --  The rule is that the first bit is is obtained by\n+                  --  subtracting the old ending bit from storage_unit - 1.\n \n-                        LB   : constant Uint := Static_Integer (Last_Bit (CC));\n-                        NFB  : constant Uint := MSS - Uint_1 - LB;\n-                        NLB  : constant Uint := NFB + Esize (Comp) - 1;\n-                        Pos  : constant Uint := Static_Integer (Position (CC));\n+                  Set_Component_Bit_Offset\n+                    (Comp,\n+                     (Storage_Unit_Offset * System_Storage_Unit) +\n+                       (System_Storage_Unit - 1) -\n+                       (Start_Bit + CSZ - 1));\n \n-                     begin\n-                        if Warn_On_Reverse_Bit_Order then\n-                           Error_Msg_Uint_1 := MSS;\n-                           Error_Msg_N\n-                             (\"info: reverse bit order in machine \" &\n-                              \"scalar of length^?V?\", First_Bit (CC));\n-                           Error_Msg_Uint_1 := NFB;\n-                           Error_Msg_Uint_2 := NLB;\n-\n-                           if Bytes_Big_Endian then\n-                              Error_Msg_NE\n-                                (\"\\big-endian range for component \"\n-                                 & \"& is ^ .. ^?V?\", First_Bit (CC), Comp);\n-                           else\n-                              Error_Msg_NE\n-                                (\"\\little-endian range for component\"\n-                                 & \"& is ^ .. ^?V?\", First_Bit (CC), Comp);\n-                           end if;\n-                        end if;\n+                  Set_Normalized_First_Bit\n+                    (Comp,\n+                     Component_Bit_Offset (Comp) mod\n+                       System_Storage_Unit);\n+               end if;\n+            end;\n+         end if;\n \n-                        Set_Component_Bit_Offset (Comp, Pos * SSU + NFB);\n-                        Set_Normalized_First_Bit (Comp, NFB mod SSU);\n-                     end;\n-                  end loop;\n-               end loop;\n-            end Sort_CC;\n-         end;\n-      end if;\n-   end Adjust_Record_For_Reverse_Bit_Order;\n+         Next_Component_Or_Discriminant (Comp);\n+      end loop;\n+   end Adjust_Record_For_Reverse_Bit_Order_Ada_95;\n \n    -------------------------------------\n    -- Alignment_Check_For_Size_Change --"}, {"sha": "b99c56fa1b4dfa436acd9ae833b29e8972ba1ab5", "filename": "gcc/ada/sem_ch13.ads", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52b70b1bef33b0a6a339c631b084cf030bc501e9/gcc%2Fada%2Fsem_ch13.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52b70b1bef33b0a6a339c631b084cf030bc501e9/gcc%2Fada%2Fsem_ch13.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.ads?ref=52b70b1bef33b0a6a339c631b084cf030bc501e9", "patch": "@@ -50,8 +50,9 @@ package Sem_Ch13 is\n \n    procedure Adjust_Record_For_Reverse_Bit_Order (R : Entity_Id);\n    --  Called from Freeze where R is a record entity for which reverse bit\n-   --  order is specified and there is at least one component clause. Adjusts\n-   --  component positions according to either Ada 95 or Ada 2005 (AI-133).\n+   --  order is specified and there is at least one component clause. Note:\n+   --  component positions are normally adjusted as per AI95-0133, unless\n+   --  -gnatd.p is used to restore original Ada 95 mode.\n \n    procedure Check_Record_Representation_Clause (N : Node_Id);\n    --  This procedure completes the analysis of a record representation clause"}]}