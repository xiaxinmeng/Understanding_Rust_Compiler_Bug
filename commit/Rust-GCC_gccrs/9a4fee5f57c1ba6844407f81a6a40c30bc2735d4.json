{"sha": "9a4fee5f57c1ba6844407f81a6a40c30bc2735d4", "node_id": "C_kwDOANBUbNoAKDlhNGZlZTVmNTdjMWJhNjg0NDQwN2Y4MWE2YTQwYzMwYmMyNzM1ZDQ", "commit": {"author": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-08-23T15:26:37Z"}, "committer": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-12-13T13:00:05Z"}, "message": "gccrs: Add implementation of Optional\n\nThis adds an Optional<T> class to improve error handling.\n\n\tgcc/rust/\n\t* util/rust-optional-test.cc: New.\n\t* util/rust-optional.h: New.", "tree": {"sha": "5f812646cae384c4787dbfcddfce9d66aa2fc47a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5f812646cae384c4787dbfcddfce9d66aa2fc47a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9a4fee5f57c1ba6844407f81a6a40c30bc2735d4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a4fee5f57c1ba6844407f81a6a40c30bc2735d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a4fee5f57c1ba6844407f81a6a40c30bc2735d4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a4fee5f57c1ba6844407f81a6a40c30bc2735d4/comments", "author": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eb10bc5225e03c32175b32c4778e937e64f7ddaa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb10bc5225e03c32175b32c4778e937e64f7ddaa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb10bc5225e03c32175b32c4778e937e64f7ddaa"}], "stats": {"total": 388, "additions": 388, "deletions": 0}, "files": [{"sha": "43fa175fa402eaf5d2a9a116f01628ca272324ce", "filename": "gcc/rust/util/rust-optional-test.cc", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a4fee5f57c1ba6844407f81a6a40c30bc2735d4/gcc%2Frust%2Futil%2Frust-optional-test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a4fee5f57c1ba6844407f81a6a40c30bc2735d4/gcc%2Frust%2Futil%2Frust-optional-test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-optional-test.cc?ref=9a4fee5f57c1ba6844407f81a6a40c30bc2735d4", "patch": "@@ -0,0 +1,110 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-system.h\"\n+#include \"rust-optional.h\"\n+#include \"selftest.h\"\n+\n+#if CHECKING_P\n+\n+static void\n+rust_optional_create ()\n+{\n+  auto opt = Rust::Optional<int>::some (15);\n+\n+  ASSERT_TRUE (opt.is_some ());\n+  ASSERT_EQ (opt.get (), 15);\n+\n+  Rust::Optional<int> const_opt = Rust::Optional<int>::some (15);\n+  const int &value = const_opt.get ();\n+\n+  ASSERT_EQ (value, 15);\n+}\n+\n+static void\n+rust_optional_operators ()\n+{\n+  auto opt = Rust::Optional<int>::some (15);\n+\n+  // as bool\n+  ASSERT_TRUE (opt);\n+\n+  // deref\n+  ASSERT_EQ (*opt, 15);\n+\n+  class Methodable\n+  {\n+  public:\n+    int method () { return 15; }\n+  };\n+\n+  auto m_opt = Rust::Optional<Methodable>::some (Methodable ());\n+  ASSERT_EQ (m_opt->method (), 15);\n+}\n+\n+static void\n+rust_optional_take ()\n+{\n+  auto opt = Rust::Optional<int>::some (15);\n+  auto value = opt.take ();\n+\n+  ASSERT_EQ (value, 15);\n+  ASSERT_TRUE (opt.is_none ());\n+}\n+\n+static void\n+rust_optional_map ()\n+{\n+  auto opt = Rust::Optional<int>::some (15);\n+  auto twice = opt.map<int> ([] (int value) { return value * 2; });\n+\n+  ASSERT_FALSE (opt);\n+  ASSERT_TRUE (twice);\n+  ASSERT_EQ (*twice, 30);\n+}\n+\n+static void\n+rust_optional_reference ()\n+{\n+  auto value = std::vector<std::string> ();\n+  value.emplace_back (\"rust\");\n+  value.emplace_back (\"+\");\n+  value.emplace_back (\"gcc\");\n+  value.emplace_back (\"=\");\n+  value.emplace_back (\"<3\");\n+\n+  auto opt = Rust::Optional<std::vector<std::string> &>::some (value);\n+\n+  ASSERT_EQ (opt->at (0), \"rust\");\n+  ASSERT_EQ (opt->at (2), \"gcc\");\n+}\n+\n+#endif /* #if CHECKING_P */\n+\n+void\n+rust_optional_test ()\n+{\n+#if CHECKING_P\n+  rust_optional_create ();\n+  rust_optional_operators ();\n+  rust_optional_take ();\n+  rust_optional_map ();\n+  rust_optional_reference ();\n+\n+#endif /* #if CHECKING_P */\n+}"}, {"sha": "56465400250f096b7811c57784e1fe545c8c2028", "filename": "gcc/rust/util/rust-optional.h", "status": "added", "additions": 278, "deletions": 0, "changes": 278, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a4fee5f57c1ba6844407f81a6a40c30bc2735d4/gcc%2Frust%2Futil%2Frust-optional.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a4fee5f57c1ba6844407f81a6a40c30bc2735d4/gcc%2Frust%2Futil%2Frust-optional.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-optional.h?ref=9a4fee5f57c1ba6844407f81a6a40c30bc2735d4", "patch": "@@ -0,0 +1,278 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_OPTIONAL_H\n+#define RUST_OPTIONAL_H\n+\n+#include \"config.h\"\n+#include \"rust-system.h\"\n+\n+#include \"selftest.h\"\n+\n+namespace Rust {\n+\n+/**\n+ * Tagged union to try and simulate a sum type. This is safer and more ergonomic\n+ * than one of the two alternatives we're currently using in the compiler:\n+ *\n+ * 1. Storing a raw pointer, which can be `nullptr` or valid\n+ *\n+ * This is wildly unsafe, and usable in conjunction with local references, stack\n+ * variables, or pointers managed elsewhere, which can cause crashes, hard to\n+ * debug issues or undefined behavior. Likewise, if you do not check for the\n+ * pointer's validity, this will cause a crash.\n+ *\n+ * 2. Storing an extra boolean alongside the object\n+ *\n+ * This causes implementors to use a \"dummy object\": Either an empty version or\n+ * an error version. But what happens if what you really wanted to store was\n+ * the empty or error version? You can also easily incorporate logic bugs if you\n+ * forget to check for the associated boolean.\n+ *\n+ * The `Optional<T>` type has the same \"ergonomic\" cost: You need to check\n+ * whether your option is valid or not. However, the main advantage is that it\n+ * is more restrictive: You can only acess the member it contains \"safely\".\n+ * It is similar to storing a value + an associated boolean, but has the\n+ * advantage of making up only one member in your class.\n+ * You also benefit from some helper methods such as `map()`.\n+ *\n+ * You also get helper functions and operator overloading to \"seamlessly\"\n+ * replace raw pointer alternatives.\n+ *\n+ * ```c++\n+ * MyType *raw_pointer = something_that_can_fail();\n+ * if (raw_pointer)\n+ *     raw_pointer->method();\n+ *\n+ * // or\n+ *\n+ * Optional<MyType> opt = something_that_can_fail2();\n+ * if (opt)\n+ *     opt->method();\n+ *\n+ * // equivalent to\n+ *\n+ * if (opt.is_some())\n+ *     opt.get().method();\n+ * ```\n+ */\n+template <typename T> class Optional\n+{\n+private:\n+  struct Empty\n+  {\n+  };\n+\n+  enum Kind\n+  {\n+    Some,\n+    None\n+  } kind;\n+\n+  union Content\n+  {\n+    Empty empty;\n+    T value;\n+\n+    Content () = default;\n+  } content;\n+\n+  Optional<T> (Kind kind, Content content) : kind (kind), content (content) {}\n+\n+public:\n+  Optional (const Optional &other) = default;\n+  Optional &operator= (const Optional &other) = default;\n+  Optional (Optional &&other) = default;\n+\n+  static Optional<T> some (T value)\n+  {\n+    Content content;\n+    content.value = value;\n+\n+    return Optional (Kind::Some, content);\n+  }\n+\n+  static Optional<T> none ()\n+  {\n+    Content content;\n+    content.empty = Empty ();\n+\n+    return Optional (Kind::None, content);\n+  }\n+\n+  bool is_some () const { return kind == Kind::Some; }\n+  bool is_none () const { return !is_some (); }\n+\n+  /**\n+   * Enable boolean-like comparisons.\n+   */\n+  operator bool () { return is_some (); }\n+\n+  /**\n+   * Enables dereferencing to access the contained value\n+   */\n+  T &operator* () { return get (); }\n+  const T &operator* () const { return get (); }\n+  T *operator-> () { return &get (); }\n+  const T *operator-> () const { return &get (); }\n+\n+  const T &get () const\n+  {\n+    rust_assert (is_some ());\n+\n+    return content.value;\n+  }\n+\n+  T &get ()\n+  {\n+    rust_assert (is_some ());\n+\n+    return content.value;\n+  }\n+\n+  T take ()\n+  {\n+    rust_assert (is_some ());\n+\n+    auto to_return = std::move (content.value);\n+\n+    content.empty = Empty ();\n+    kind = Kind::None;\n+\n+    return to_return;\n+  }\n+\n+  template <typename U> Optional<U> map (std::function<U (T)> functor)\n+  {\n+    if (is_none ())\n+      return Optional::none ();\n+\n+    auto value = functor (take ());\n+\n+    return Optional::some (value);\n+  }\n+};\n+\n+template <typename T> class Optional<T &>\n+{\n+private:\n+  struct Empty\n+  {\n+  };\n+\n+  enum Kind\n+  {\n+    Some,\n+    None\n+  } kind;\n+\n+  union Content\n+  {\n+    Empty empty;\n+    T *value;\n+\n+    Content () = default;\n+  } content;\n+\n+  Optional<T &> (Kind kind, Content content) : kind (kind), content (content) {}\n+\n+public:\n+  Optional (const Optional &other) = default;\n+  Optional (Optional &&other) = default;\n+\n+  static Optional<T &> some (T &value)\n+  {\n+    Content content;\n+    content.value = &value;\n+\n+    return Optional (Kind::Some, content);\n+  }\n+\n+  static Optional<T &> none ()\n+  {\n+    Content content;\n+    content.empty = Empty ();\n+\n+    return Optional (Kind::None, content);\n+  }\n+\n+  bool is_some () const { return kind == Kind::Some; }\n+  bool is_none () const { return !is_some (); }\n+\n+  // FIXME: Can we factor this in a single class?\n+\n+  /**\n+   * Enable boolean-like comparisons.\n+   */\n+  operator bool () { return is_some (); }\n+\n+  /**\n+   * Enables dereferencing to access the contained value\n+   */\n+  T &operator* () { return get (); }\n+  const T &operator* () const { return get (); }\n+  T *operator-> () { return &get (); }\n+  const T *operator-> () const { return &get (); }\n+\n+  const T &get () const\n+  {\n+    rust_assert (is_some ());\n+\n+    return *content.value;\n+  }\n+\n+  T &get ()\n+  {\n+    rust_assert (is_some ());\n+\n+    return *content.value;\n+  }\n+\n+  T &take ()\n+  {\n+    rust_assert (is_some ());\n+\n+    auto to_return = std::move (content.value);\n+\n+    content.empty = Empty ();\n+    kind = Kind::None;\n+\n+    return *to_return;\n+  }\n+\n+  template <typename U> Optional<U &> map (std::function<U &(T &)> functor)\n+  {\n+    if (is_none ())\n+      return Optional::none ();\n+\n+    auto value = functor (take ());\n+\n+    return Optional::some (value);\n+  }\n+};\n+\n+} // namespace Rust\n+\n+#ifdef CHECKING_P\n+\n+void\n+rust_optional_test ();\n+\n+#endif // !CHECKING_P\n+\n+#endif // !RUST_OPTIONAL_H"}]}