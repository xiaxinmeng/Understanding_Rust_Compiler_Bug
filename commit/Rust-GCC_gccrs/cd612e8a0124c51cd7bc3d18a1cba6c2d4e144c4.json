{"sha": "cd612e8a0124c51cd7bc3d18a1cba6c2d4e144c4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2Q2MTJlOGEwMTI0YzUxY2Q3YmMzZDE4YTFjYmE2YzJkNGUxNDRjNA==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2016-10-26T14:48:02Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2016-10-26T14:48:02Z"}, "message": "re PR fortran/78108 (Generic type-bound operator conflicts)\n\n2016-10-26  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/78108\n\t* resolve.c (resolve_typebound_intrinsic_op): For submodules\n\tsuppress the error and return if the same procedure symbol\n\tis added more than once to the interface.\n\n2016-10-26  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/78108\n\t* gfortran.dg/submodule_18.f08: New test.\n\t* gfortran.dg/submodule_19.f08: New test.\n\nFrom-SVN: r241555", "tree": {"sha": "5e5e9659a8da5c68bbeb2621896a64a1aa0f6446", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5e5e9659a8da5c68bbeb2621896a64a1aa0f6446"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cd612e8a0124c51cd7bc3d18a1cba6c2d4e144c4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd612e8a0124c51cd7bc3d18a1cba6c2d4e144c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd612e8a0124c51cd7bc3d18a1cba6c2d4e144c4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd612e8a0124c51cd7bc3d18a1cba6c2d4e144c4/comments", "author": null, "committer": null, "parents": [{"sha": "b4e7e6bf229664045926633aae90a287e39f6454", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4e7e6bf229664045926633aae90a287e39f6454", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b4e7e6bf229664045926633aae90a287e39f6454"}], "stats": {"total": 133, "additions": 132, "deletions": 1}, "files": [{"sha": "bae08b8c8ac568b4fb72c1994ac324afef439aff", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd612e8a0124c51cd7bc3d18a1cba6c2d4e144c4/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd612e8a0124c51cd7bc3d18a1cba6c2d4e144c4/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=cd612e8a0124c51cd7bc3d18a1cba6c2d4e144c4", "patch": "@@ -1,3 +1,10 @@\n+2016-10-26  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/78108\n+\t* resolve.c (resolve_typebound_intrinsic_op): For submodules\n+\tsuppress the error and return if the same procedure symbol\n+\tis added more than once to the interface.\n+\n 2016-10-26  Fritz Reese <fritzoreese@gmail.com>\n \n \t* frontend-passes.c (gfc_code_walker): Add SHARE and CARRIAGECONTROL."}, {"sha": "fe966aa537dbe05a5a99218023d65878e02dfa72", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd612e8a0124c51cd7bc3d18a1cba6c2d4e144c4/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd612e8a0124c51cd7bc3d18a1cba6c2d4e144c4/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=cd612e8a0124c51cd7bc3d18a1cba6c2d4e144c4", "patch": "@@ -12797,7 +12797,17 @@ resolve_typebound_intrinsic_op (gfc_symbol* derived, gfc_intrinsic_op op,\n \t  && p->access != ACCESS_PRIVATE && derived->ns == gfc_current_ns)\n \t{\n \t  gfc_interface *head, *intr;\n-\t  if (!gfc_check_new_interface (derived->ns->op[op], target_proc, p->where))\n+\n+\t  /* Preempt 'gfc_check_new_interface' for submodules, where the\n+\t     mechanism for handling module procedures winds up resolving\n+\t     operator interfaces twice and would otherwise cause an error.  */\n+\t  for (intr = derived->ns->op[op]; intr; intr = intr->next)\n+\t    if (intr->sym == target_proc\n+\t\t&& target_proc->attr.used_in_submodule)\n+\t      return true;\n+\n+\t  if (!gfc_check_new_interface (derived->ns->op[op],\n+\t\t\t\t\ttarget_proc, p->where))\n \t    return false;\n \t  head = derived->ns->op[op];\n \t  intr = gfc_get_interface ();"}, {"sha": "84dc56df1135cbc0770184a6cb21293459320027", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd612e8a0124c51cd7bc3d18a1cba6c2d4e144c4/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd612e8a0124c51cd7bc3d18a1cba6c2d4e144c4/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=cd612e8a0124c51cd7bc3d18a1cba6c2d4e144c4", "patch": "@@ -1,3 +1,9 @@\n+2016-10-26  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/78108\n+\t* gfortran.dg/submodule_18.f08: New test.\n+\t* gfortran.dg/submodule_19.f08: New test.\n+\n 2016-10-26  Michael Matz  <matz@suse.de>\n \n \t* g++.dg/pr78060.C: New test."}, {"sha": "14fac75635cd1167ddc52d484390a716e7ea1ff1", "filename": "gcc/testsuite/gfortran.dg/submodule_18.f08", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd612e8a0124c51cd7bc3d18a1cba6c2d4e144c4/gcc%2Ftestsuite%2Fgfortran.dg%2Fsubmodule_18.f08", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd612e8a0124c51cd7bc3d18a1cba6c2d4e144c4/gcc%2Ftestsuite%2Fgfortran.dg%2Fsubmodule_18.f08", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fsubmodule_18.f08?ref=cd612e8a0124c51cd7bc3d18a1cba6c2d4e144c4", "patch": "@@ -0,0 +1,49 @@\n+! { dg-do run }\n+!\n+! Tests the fix for PR78108 in which an error was\n+! triggered by the module procedures being added twice\n+! to the operator interfaces.\n+!\n+! Contributed by Damian Rouson  <damian@sourceryinstitute.org>\n+!\n+module foo_interface\n+  implicit none\n+  type foo\n+    integer :: x\n+  contains\n+    procedure :: add\n+    generic :: operator(+) => add\n+    procedure :: mult\n+    generic :: operator(*) => mult\n+  end type\n+  interface\n+    integer module function add(lhs,rhs)\n+      implicit none\n+      class(foo), intent(in) :: lhs,rhs\n+    end function\n+    integer module function mult(lhs,rhs)\n+      implicit none\n+      class(foo), intent(in) :: lhs,rhs\n+    end function\n+  end interface\n+end module\n+submodule(foo_interface) foo_implementation\n+contains\n+    integer module function add(lhs,rhs)\n+      implicit none\n+      class(foo), intent(in) :: lhs,rhs\n+      add = lhs % x + rhs % x\n+    end function\n+    integer module function mult(lhs,rhs)\n+      implicit none\n+      class(foo), intent(in) :: lhs,rhs\n+      mult = lhs % x * rhs % x\n+    end function\n+end submodule\n+\n+  use foo_interface\n+  type(foo) :: a = foo (42)\n+  type(foo) :: b = foo (99)\n+  if (a + b .ne. 141) call abort\n+  if (a * b .ne. 4158) call abort\n+end"}, {"sha": "bc840081436a5abaafd3c1056a4c1bc09078e0b6", "filename": "gcc/testsuite/gfortran.dg/submodule_19.f08", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd612e8a0124c51cd7bc3d18a1cba6c2d4e144c4/gcc%2Ftestsuite%2Fgfortran.dg%2Fsubmodule_19.f08", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd612e8a0124c51cd7bc3d18a1cba6c2d4e144c4/gcc%2Ftestsuite%2Fgfortran.dg%2Fsubmodule_19.f08", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fsubmodule_19.f08?ref=cd612e8a0124c51cd7bc3d18a1cba6c2d4e144c4", "patch": "@@ -0,0 +1,59 @@\n+! { dg-do compile }\n+!\n+! Tests the fix for PR78108 in which an error was triggered by the\n+! generic operator being resolved more than once in submodules. This\n+! test checks that the error is triggered when the specific procedure\n+! really is inserted more than once in the interface.\n+!\n+! Note that adding the extra interface to the module produces two\n+! errors; the one below and 'Duplicate EXTERNAL attribute specified at (1)'\n+!\n+! Contributed by Damian Rouson  <damian@sourceryinstitute.org>\n+!\n+module foo_interface\n+  implicit none\n+  type foo\n+    integer :: x\n+  contains\n+    procedure :: add\n+    generic :: operator(+) => add\n+    procedure :: mult\n+    generic :: operator(*) => mult\n+  end type\n+  interface\n+    integer module function add(lhs,rhs)\n+      implicit none\n+      class(foo), intent(in) :: lhs,rhs\n+    end function\n+    integer module function mult(lhs,rhs)\n+      implicit none\n+      class(foo), intent(in) :: lhs,rhs\n+    end function\n+  end interface\n+end module\n+submodule(foo_interface) foo_implementation\n+  interface operator (+)\n+    integer module function add(lhs,rhs)\n+      implicit none\n+      class(foo), intent(in) :: lhs,rhs\n+    end function    ! { dg-error \"is already present in the interface\" }\n+  end interface\n+contains\n+    integer module function add(lhs,rhs)\n+      implicit none\n+      class(foo), intent(in) :: lhs,rhs\n+      add = lhs % x + rhs % x\n+    end function\n+    integer module function mult(lhs,rhs)\n+      implicit none\n+      class(foo), intent(in) :: lhs,rhs\n+      mult = lhs % x * rhs % x\n+    end function\n+end submodule\n+\n+  use foo_interface\n+  type(foo) :: a = foo (42)\n+  type(foo) :: b = foo (99)\n+  if (a + b .ne. 141) call abort\n+  if (a * b .ne. 4158) call abort\n+end"}]}