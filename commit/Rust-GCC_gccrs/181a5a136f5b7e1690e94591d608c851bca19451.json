{"sha": "181a5a136f5b7e1690e94591d608c851bca19451", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTgxYTVhMTM2ZjViN2UxNjkwZTk0NTkxZDYwOGM4NTFiY2ExOTQ1MQ==", "commit": {"author": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2012-08-13T19:43:19Z"}, "committer": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2012-08-13T19:43:19Z"}, "message": "2012-08-10  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n\t    Ollie Wild  <aaw@google.com>\n\n\t* include/bits/hashtable.h\n\t(_Hashtable<>_M_insert_multi_node(hash_code, node_type*)): New.\n\t(_Hashtable<>_M_insert(_Args&&, false_type)): Use latter.\n\t(_Hashtable<>::_M_emplace(false_type, _Args&&...)): Likewise.\n\t(_Hashtable<>::_M_insert_bucket): Replace by ...\n\t(_Hashtable<>::_M_insert_unique_node(size_type, hash_code, node_type*)):\n\t... this, new.\n\t(_Hashtable<>::_M_insert(_Args&&, true_type)): Use latter.\n\t(_Hashtable<>::_M_emplace(true_type, _Args&&...)): Likewise.\n\t* include/bits/hashtable_policy.h (_Map_base<>::operator[]): Use\n\tlatter, emplace the value_type rather than insert.\n\t* include/std/unordered_map: Include tuple.\n\t* include/std/unordered_set: Likewise.\n\t* testsuite/util/testsuite_counter_type.h: New.\n\t* testsuite/23_containers/unordered_map/operators/2.cc: New.\n\nCo-Authored-By: Ollie Wild <aaw@google.com>\n\nFrom-SVN: r190355", "tree": {"sha": "0dc575864cfe869f2d5cba5d2728a0ccc9f3ce3a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0dc575864cfe869f2d5cba5d2728a0ccc9f3ce3a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/181a5a136f5b7e1690e94591d608c851bca19451", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/181a5a136f5b7e1690e94591d608c851bca19451", "html_url": "https://github.com/Rust-GCC/gccrs/commit/181a5a136f5b7e1690e94591d608c851bca19451", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/181a5a136f5b7e1690e94591d608c851bca19451/comments", "author": null, "committer": null, "parents": [{"sha": "a327112f68b8e92ef04582002180fa5d8f715276", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a327112f68b8e92ef04582002180fa5d8f715276", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a327112f68b8e92ef04582002180fa5d8f715276"}], "stats": {"total": 529, "additions": 371, "deletions": 158}, "files": [{"sha": "69a77c56dc7905cd4f501d7c6061f435eaeaf8c9", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/181a5a136f5b7e1690e94591d608c851bca19451/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/181a5a136f5b7e1690e94591d608c851bca19451/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=181a5a136f5b7e1690e94591d608c851bca19451", "patch": "@@ -1,3 +1,22 @@\n+2012-08-13  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n+\t    Ollie Wild  <aaw@google.com>\n+\n+\t* include/bits/hashtable.h\n+\t(_Hashtable<>_M_insert_multi_node(hash_code, node_type*)): New.\n+\t(_Hashtable<>_M_insert(_Args&&, false_type)): Use latter.\n+\t(_Hashtable<>::_M_emplace(false_type, _Args&&...)): Likewise.\n+\t(_Hashtable<>::_M_insert_bucket): Replace by ...\n+\t(_Hashtable<>::_M_insert_unique_node(size_type, hash_code, node_type*)):\n+\t... this, new.\n+\t(_Hashtable<>::_M_insert(_Args&&, true_type)): Use latter.\n+\t(_Hashtable<>::_M_emplace(true_type, _Args&&...)): Likewise.\n+\t* include/bits/hashtable_policy.h (_Map_base<>::operator[]): Use\n+\tlatter, emplace the value_type rather than insert.\n+\t* include/std/unordered_map: Include tuple.\n+\t* include/std/unordered_set: Likewise.\n+\t* testsuite/util/testsuite_counter_type.h: New.\n+\t* testsuite/23_containers/unordered_map/operators/2.cc: New.\n+\n 2012-08-13  Marc Glisse  <marc.glisse@inria.fr>\n \n \tPR libstdc++/54112"}, {"sha": "2018575dea7f44d0abee9c3969b77f8d7d63dc0c", "filename": "libstdc++-v3/include/bits/hashtable.h", "status": "modified", "additions": 123, "deletions": 153, "changes": 276, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/181a5a136f5b7e1690e94591d608c851bca19451/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/181a5a136f5b7e1690e94591d608c851bca19451/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h?ref=181a5a136f5b7e1690e94591d608c851bca19451", "patch": "@@ -584,10 +584,17 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       __node_base*\n       _M_get_previous_node(size_type __bkt, __node_base* __n);\n \n-      template<typename _Arg>\n-\titerator\n-\t_M_insert_bucket(_Arg&&, size_type, __hash_code);\n+      // Insert node with hash code __code, in bucket bkt if no rehash (assumes\n+      // no element with its key already present). Take ownership of the node,\n+      // deallocate it on exception.\n+      iterator\n+      _M_insert_unique_node(size_type __bkt, __hash_code __code,\n+\t\t\t    __node_type* __n);\n \n+      // Insert node with hash code __code. Take ownership of the node,\n+      // deallocate it on exception.\n+      iterator\n+      _M_insert_multi_node(__hash_code __code, __node_type* __n);\n \n       template<typename... _Args>\n \tstd::pair<iterator, bool>\n@@ -1214,42 +1221,29 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       {\n \t// First build the node to get access to the hash code\n \t__node_type* __node = _M_allocate_node(std::forward<_Args>(__args)...);\n+\tconst key_type& __k = this->_M_extract()(__node->_M_v);\n+\t__hash_code __code;\n \t__try\n \t  {\n-\t    const key_type& __k = this->_M_extract()(__node->_M_v);\n-\t    __hash_code __code = this->_M_hash_code(__k);\n-\t    size_type __bkt = _M_bucket_index(__k, __code);\n-\n-\t    if (__node_type* __p = _M_find_node(__bkt, __k, __code))\n-\t      {\n-\t\t// There is already an equivalent node, no insertion\n-\t\t_M_deallocate_node(__node);\n-\t\treturn std::make_pair(iterator(__p), false);\n-\t      }\n-\n-\t    // We are going to insert this node\n-\t    this->_M_store_code(__node, __code);\n-\t    const __rehash_state& __saved_state\n-\t      = _M_rehash_policy._M_state();\n-\t    std::pair<bool, std::size_t> __do_rehash\n-\t      = _M_rehash_policy._M_need_rehash(_M_bucket_count,\n-\t\t\t\t\t\t_M_element_count, 1);\n-\n-\t    if (__do_rehash.first)\n-\t      {\n-\t\t_M_rehash(__do_rehash.second, __saved_state);\n-\t\t__bkt = _M_bucket_index(__k, __code);\n-\t      }\n-\n-\t    _M_insert_bucket_begin(__bkt, __node);\n-\t    ++_M_element_count;\n-\t    return std::make_pair(iterator(__node), true);\n+\t    __code = this->_M_hash_code(__k);\n \t  }\n \t__catch(...)\n \t  {\n \t    _M_deallocate_node(__node);\n \t    __throw_exception_again;\n \t  }\n+\n+\tsize_type __bkt = _M_bucket_index(__k, __code);\n+\tif (__node_type* __p = _M_find_node(__bkt, __k, __code))\n+\t  {\n+\t    // There is already an equivalent node, no insertion\n+\t    _M_deallocate_node(__node);\n+\t    return std::make_pair(iterator(__p), false);\n+\t  }\n+\n+\t// Insert the node\n+\treturn std::make_pair(_M_insert_unique_node(__bkt, __code, __node),\n+\t\t\t      true);\n       }\n \n   template<typename _Key, typename _Value,\n@@ -1264,97 +1258,110 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n       _M_emplace(std::false_type, _Args&&... __args)\n       {\n-\tconst __rehash_state& __saved_state = _M_rehash_policy._M_state();\n-\tstd::pair<bool, std::size_t> __do_rehash\n-\t  = _M_rehash_policy._M_need_rehash(_M_bucket_count,\n-\t\t\t\t\t    _M_element_count, 1);\n-\n \t// First build the node to get its hash code.\n \t__node_type* __node = _M_allocate_node(std::forward<_Args>(__args)...);\n+\n+\t__hash_code __code;\n \t__try\n \t  {\n-\t    const key_type& __k = this->_M_extract()(__node->_M_v);\n-\t    __hash_code __code = this->_M_hash_code(__k);\n-\t    this->_M_store_code(__node, __code);\n-\n-\t    // Second, do rehash if necessary.\n-\t    if (__do_rehash.first)\n-\t\t_M_rehash(__do_rehash.second, __saved_state);\n-\n-\t    // Third, find the node before an equivalent one.\n-\t    size_type __bkt = _M_bucket_index(__k, __code);\n-\t    __node_base* __prev = _M_find_before_node(__bkt, __k, __code);\n-\n-\t    if (__prev)\n-\t      {\n-\t\t// Insert after the node before the equivalent one.\n-\t\t__node->_M_nxt = __prev->_M_nxt;\n-\t\t__prev->_M_nxt = __node;\n-\t      }\n-\t    else\n-\t      // The inserted node has no equivalent in the\n-\t      // hashtable. We must insert the new node at the\n-\t      // beginning of the bucket to preserve equivalent\n-\t      // elements relative positions.\n-\t      _M_insert_bucket_begin(__bkt, __node);\n-\t    ++_M_element_count;\n-\t    return iterator(__node);\n+\t    __code = this->_M_hash_code(this->_M_extract()(__node->_M_v));\n \t  }\n \t__catch(...)\n \t  {\n \t    _M_deallocate_node(__node);\n \t    __throw_exception_again;\n \t  }\n+\n+\treturn _M_insert_multi_node(__code, __node);\n       }\n \n-  // Insert v in bucket n (assumes no element with its key already present).\n   template<typename _Key, typename _Value,\n \t   typename _Alloc, typename _ExtractKey, typename _Equal,\n \t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n \t   typename _Traits>\n-    template<typename _Arg>\n-      typename _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n-\t\t\t  _H1, _H2, _Hash, _RehashPolicy,\n-\t\t\t  _Traits>::iterator\n-      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n-\t\t _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n-      _M_insert_bucket(_Arg&& __v, size_type __n, __hash_code __code)\n-      {\n-\tconst __rehash_state& __saved_state = _M_rehash_policy._M_state();\n-\tstd::pair<bool, std::size_t> __do_rehash\n-\t  = _M_rehash_policy._M_need_rehash(_M_bucket_count,\n-\t\t\t\t\t    _M_element_count, 1);\n-\n-\tif (__do_rehash.first)\n-\t  {\n-\t    const key_type& __k = this->_M_extract()(__v);\n-\t    __n = __hash_code_base::_M_bucket_index(__k, __code,\n-\t\t\t\t\t\t    __do_rehash.second);\n-\t  }\n+    typename _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n+\t\t\t_H1, _H2, _Hash, _RehashPolicy,\n+\t\t\t_Traits>::iterator\n+    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n+    _M_insert_unique_node(size_type __bkt, __hash_code __code,\n+\t\t\t  __node_type* __node)\n+    {\n+      const __rehash_state& __saved_state = _M_rehash_policy._M_state();\n+      std::pair<bool, std::size_t> __do_rehash\n+\t= _M_rehash_policy._M_need_rehash(_M_bucket_count, _M_element_count, 1);\n \n-\t__node_type* __node = nullptr;\n-\t__try\n-\t  {\n-\t    // Allocate the new node before doing the rehash so that we\n-\t    // don't do a rehash if the allocation throws.\n-\t    __node = _M_allocate_node(std::forward<_Arg>(__v));\n-\t    this->_M_store_code(__node, __code);\n-\t    if (__do_rehash.first)\n+      __try\n+\t{\n+\t  if (__do_rehash.first)\n+\t    {\n \t      _M_rehash(__do_rehash.second, __saved_state);\n+\t      __bkt = _M_bucket_index(this->_M_extract()(__node->_M_v), __code);\n+\t    }\n \n-\t    _M_insert_bucket_begin(__n, __node);\n-\t    ++_M_element_count;\n-\t    return iterator(__node);\n-\t  }\n-\t__catch(...)\n-\t  {\n-\t    if (!__node)\n-\t      _M_rehash_policy._M_reset(__saved_state);\n-\t    else\n-\t      _M_deallocate_node(__node);\n-\t    __throw_exception_again;\n-\t  }\n-      }\n+\t  this->_M_store_code(__node, __code);\n+\n+\t  // Always insert at the begining of the bucket.\n+\t  _M_insert_bucket_begin(__bkt, __node);\n+\t  ++_M_element_count;\n+\t  return iterator(__node);\n+\t}\n+      __catch(...)\n+\t{\n+\t  _M_deallocate_node(__node);\n+\t  __throw_exception_again;\n+\t}\n+    }\n+\n+  // Insert node, in bucket bkt if no rehash (assumes no element with its key\n+  // already present). Take ownership of the node, deallocate it on exception.\n+  template<typename _Key, typename _Value,\n+\t   typename _Alloc, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   typename _Traits>\n+    typename _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n+\t\t\t_H1, _H2, _Hash, _RehashPolicy,\n+\t\t\t_Traits>::iterator\n+    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n+    _M_insert_multi_node(__hash_code __code, __node_type* __node)\n+    {\n+      const __rehash_state& __saved_state = _M_rehash_policy._M_state();\n+      std::pair<bool, std::size_t> __do_rehash\n+\t= _M_rehash_policy._M_need_rehash(_M_bucket_count, _M_element_count, 1);\n+\n+      __try\n+\t{\n+\t  if (__do_rehash.first)\n+\t    _M_rehash(__do_rehash.second, __saved_state);\n+\n+\t  this->_M_store_code(__node, __code);\n+\t  const key_type& __k = this->_M_extract()(__node->_M_v);\n+\t  size_type __bkt = _M_bucket_index(__k, __code);\n+\n+\t  // Find the node before an equivalent one.\n+\t  __node_base* __prev = _M_find_before_node(__bkt, __k, __code);\n+\t  if (__prev)\n+\t    {\n+\t      // Insert after the node before the equivalent one.\n+\t      __node->_M_nxt = __prev->_M_nxt;\n+\t      __prev->_M_nxt = __node;\n+\t    }\n+\t  else\n+\t    // The inserted node has no equivalent in the\n+\t    // hashtable. We must insert the new node at the\n+\t    // beginning of the bucket to preserve equivalent\n+\t    // elements relative positions.\n+\t    _M_insert_bucket_begin(__bkt, __node);\n+\t  ++_M_element_count;\n+\t  return iterator(__node);\n+\t}\n+      __catch(...)\n+\t{\n+\t  _M_deallocate_node(__node);\n+\t  __throw_exception_again;\n+\t}\n+    }\n \n   // Insert v if no element with its key is already present.\n   template<typename _Key, typename _Value,\n@@ -1372,12 +1379,14 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       {\n \tconst key_type& __k = this->_M_extract()(__v);\n \t__hash_code __code = this->_M_hash_code(__k);\n-\tsize_type __n = _M_bucket_index(__k, __code);\n+\tsize_type __bkt = _M_bucket_index(__k, __code);\n \n-\tif (__node_type* __p = _M_find_node(__n, __k, __code))\n-\t  return std::make_pair(iterator(__p), false);\n-\treturn std::make_pair(_M_insert_bucket(std::forward<_Arg>(__v),\n-\t\t\t      __n, __code), true);\n+\t__node_type* __n = _M_find_node(__bkt, __k, __code);\n+\tif (__n)\n+\t  return std::make_pair(iterator(__n), false);\n+\n+\t__n = _M_allocate_node(std::forward<_Arg>(__v));\n+\treturn std::make_pair(_M_insert_unique_node(__bkt, __code, __n), true);\n       }\n \n   // Insert v unconditionally.\n@@ -1393,54 +1402,15 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n       _M_insert(_Arg&& __v, std::false_type)\n       {\n-\tconst __rehash_state& __saved_state = _M_rehash_policy._M_state();\n-\tstd::pair<bool, std::size_t> __do_rehash\n-\t  = _M_rehash_policy._M_need_rehash(_M_bucket_count,\n-\t\t\t\t\t    _M_element_count, 1);\n-\n-\t// First compute the hash code so that we don't do anything if\n-\t// it throws.\n+\t// First compute the hash code so that we don't do anything if it\n+\t// throws.\n \t__hash_code __code = this->_M_hash_code(this->_M_extract()(__v));\n \n-\t__node_type* __node = nullptr;\n-\t__try\n-\t  {\n-\t    // Second allocate new node so that we don't rehash if it throws.\n-\t    __node = _M_allocate_node(std::forward<_Arg>(__v));\n-\t    this->_M_store_code(__node, __code);\n-\t    if (__do_rehash.first)\n-\t\t_M_rehash(__do_rehash.second, __saved_state);\n-\n-\t    // Third, find the node before an equivalent one.\n-\t    size_type __bkt = _M_bucket_index(__node);\n-\t    __node_base* __prev\n-\t      = _M_find_before_node(__bkt, this->_M_extract()(__node->_M_v),\n-\t\t\t\t    __code);\n-\t    if (__prev)\n-\t      {\n-\t\t// Insert after the node before the equivalent one.\n-\t\t__node->_M_nxt = __prev->_M_nxt;\n-\t\t__prev->_M_nxt = __node;\n-\t      }\n-\t    else\n-\t      // The inserted node has no equivalent in the\n-\t      // hashtable. We must insert the new node at the\n-\t      // beginning of the bucket to preserve equivalent\n-\t      // elements relative positions.\n-\t      _M_insert_bucket_begin(__bkt, __node);\n-\t    ++_M_element_count;\n-\t    return iterator(__node);\n-\t  }\n-\t__catch(...)\n-\t  {\n-\t    if (!__node)\n-\t      _M_rehash_policy._M_reset(__saved_state);\n-\t    else\n-\t      _M_deallocate_node(__node);\n-\t    __throw_exception_again;\n-\t  }\n-      }\n+\t// Second allocate new node so that we don't rehash if it throws.\n+\t__node_type* __node = _M_allocate_node(std::forward<_Arg>(__v));\n \n+\treturn _M_insert_multi_node(__code, __node);\n+      }\n \n   template<typename _Key, typename _Value,\n \t   typename _Alloc, typename _ExtractKey, typename _Equal,"}, {"sha": "6350ae622e4a0d8d9fbaf5fc1fb77ef885afd641", "filename": "libstdc++-v3/include/bits/hashtable_policy.h", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/181a5a136f5b7e1690e94591d608c851bca19451/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/181a5a136f5b7e1690e94591d608c851bca19451/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h?ref=181a5a136f5b7e1690e94591d608c851bca19451", "patch": "@@ -577,8 +577,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       __node_type* __p = __h->_M_find_node(__n, __k, __code);\n \n       if (!__p)\n-\treturn __h->_M_insert_bucket(std::make_pair(__k, mapped_type()),\n-\t\t\t\t     __n, __code)->second;\n+\t{\n+\t  __p = __h->_M_allocate_node(std::piecewise_construct,\n+\t\t\t\t      std::tuple<const key_type&>(__k),\n+\t\t\t\t      std::tuple<>());\n+\t  return __h->_M_insert_unique_node(__n, __code, __p)->second;\n+\t}\n+\n       return (__p->_M_v).second;\n     }\n \n@@ -598,9 +603,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       __node_type* __p = __h->_M_find_node(__n, __k, __code);\n \n       if (!__p)\n-\treturn __h->_M_insert_bucket(std::make_pair(std::move(__k),\n-\t\t\t\t\t\t    mapped_type()),\n-\t\t\t\t     __n, __code)->second;\n+\t{\n+\t  __p = __h->_M_allocate_node(std::piecewise_construct,\n+\t\t\t\t      std::forward_as_tuple(std::move(__k)),\n+\t\t\t\t      std::tuple<>());\n+\t  return __h->_M_insert_unique_node(__n, __code, __p)->second;\n+\t}\n+\n       return (__p->_M_v).second;\n     }\n "}, {"sha": "9241f30f82e33aeed138549e219a5152a8a1b4e8", "filename": "libstdc++-v3/include/std/unordered_map", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/181a5a136f5b7e1690e94591d608c851bca19451/libstdc%2B%2B-v3%2Finclude%2Fstd%2Funordered_map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/181a5a136f5b7e1690e94591d608c851bca19451/libstdc%2B%2B-v3%2Finclude%2Fstd%2Funordered_map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Funordered_map?ref=181a5a136f5b7e1690e94591d608c851bca19451", "patch": "@@ -38,6 +38,7 @@\n #include <utility>\n #include <type_traits>\n #include <initializer_list>\n+#include <tuple>\n #include <bits/stl_algobase.h>\n #include <bits/allocator.h>\n #include <bits/stl_function.h> // equal_to, _Identity, _Select1st"}, {"sha": "4d4517b451c69d16a6ae2a58bc104a6954805418", "filename": "libstdc++-v3/include/std/unordered_set", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/181a5a136f5b7e1690e94591d608c851bca19451/libstdc%2B%2B-v3%2Finclude%2Fstd%2Funordered_set", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/181a5a136f5b7e1690e94591d608c851bca19451/libstdc%2B%2B-v3%2Finclude%2Fstd%2Funordered_set", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Funordered_set?ref=181a5a136f5b7e1690e94591d608c851bca19451", "patch": "@@ -38,6 +38,7 @@\n #include <utility>\n #include <type_traits>\n #include <initializer_list>\n+#include <tuple>\n #include <bits/stl_algobase.h>\n #include <bits/allocator.h>\n #include <bits/stl_function.h> // equal_to, _Identity, _Select1st"}, {"sha": "8c3282442e064b8ad07a5bb4b750116e99eea9cc", "filename": "libstdc++-v3/testsuite/23_containers/unordered_map/operators/2.cc", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/181a5a136f5b7e1690e94591d608c851bca19451/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Foperators%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/181a5a136f5b7e1690e94591d608c851bca19451/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Foperators%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Foperators%2F2.cc?ref=181a5a136f5b7e1690e94591d608c851bca19451", "patch": "@@ -0,0 +1,91 @@\n+// Copyright (C) 2012 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 23.5.4 template class unordered_map\n+\n+// This test verifies that the value type of a unordered_map need not be\n+// default copyable.\n+\n+// { dg-options \"-std=gnu++11\" }\n+\n+#include <unordered_map>\n+#include <testsuite_hooks.h>\n+#include <testsuite_rvalref.h>\n+#include <testsuite_counter_type.h>\n+\n+struct Mapped\n+{\n+  Mapped() = default;\n+  explicit Mapped(const Mapped&) = default;\n+};\n+\n+struct DefaultConstructibleType\n+{\n+  int val;\n+\n+  DefaultConstructibleType() : val(123)\n+  {}\n+\n+  DefaultConstructibleType(const DefaultConstructibleType&) = delete;\n+  DefaultConstructibleType(DefaultConstructibleType&&) = delete;\n+\n+  DefaultConstructibleType& operator=(int x)\n+  {\n+    val = x;\n+    return *this;\n+  }\n+};\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  using __gnu_test::rvalstruct;\n+  using __gnu_test::counter_type;\n+\n+  std::unordered_map<int, Mapped> m1;\n+  m1[0] = Mapped();\n+\n+  std::unordered_map<int, rvalstruct> m2;\n+  m2[0] = rvalstruct(13);\n+\n+  std::unordered_map<int, DefaultConstructibleType> m3;\n+  VERIFY( m3[0].val == 123 );\n+  VERIFY( m3.size() == 1 );\n+  m3[0] = 2;\n+  VERIFY( m3[0].val == 2 );\n+\n+  std::unordered_map<counter_type, int,\n+\t\t     __gnu_test::counter_type_hasher> m4;\n+  VERIFY( m4[counter_type(1)] == 0 );\n+  VERIFY( counter_type::specialize_count == 1 );\n+  VERIFY( counter_type::copy_count == 0 );\n+  VERIFY( counter_type::move_count == 1 );\n+  \n+  counter_type k(2);\n+  counter_type::reset();\n+\n+  VERIFY( m4[k] == 0 );\n+  VERIFY( counter_type::copy_count == 1 );\n+  VERIFY( counter_type::move_count == 0 );\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "2b7063da170de1949365f27be7eba0edfbbc8ef1", "filename": "libstdc++-v3/testsuite/util/testsuite_counter_type.h", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/181a5a136f5b7e1690e94591d608c851bca19451/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_counter_type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/181a5a136f5b7e1690e94591d608c851bca19451/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_counter_type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_counter_type.h?ref=181a5a136f5b7e1690e94591d608c851bca19451", "patch": "@@ -0,0 +1,122 @@\n+// -*- C++ -*-\n+//\n+// Copyright (C) 2012 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+//\n+\n+#ifndef _TESTSUITE_COUNTER_TYPE_H\n+#define _TESTSUITE_COUNTER_TYPE_H 1\n+\n+namespace __gnu_test\n+{\n+  // Type counting how many constructors or assign operators are invoked.\n+  struct counter_type\n+  {\n+    // Constructor counters:\n+    static int default_count;\n+    static int specialize_count;\n+    static int copy_count;\n+    static int copy_assign_count;\n+    static int less_compare_count;\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+    static int move_count;\n+    static int move_assign_count;\n+#endif\n+\n+    int val;\n+    \n+    counter_type() : val(0)\n+    {\n+      ++default_count;\n+    }\n+\n+    counter_type(int inval) : val(inval)\n+    {\n+      ++specialize_count;\n+    }\n+\n+    counter_type(const counter_type& in) : val(in.val)\n+    {\n+      ++copy_count;\n+    }\n+\n+    counter_type&\n+    operator=(const counter_type& in)\n+    {\n+      val = in.val;\n+      ++copy_assign_count;\n+      return *this;\n+    }\n+\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+    counter_type(counter_type&& in) noexcept\n+    {\n+      val = in.val;\n+      ++move_count;\n+    }\n+\n+    counter_type&\n+    operator=(counter_type&& rhs)\n+    {\n+      val = rhs.val;\n+      ++move_assign_count;\n+      return *this;\n+    }\n+#endif\n+\n+    static void\n+    reset()\n+    {\n+      default_count = 0;\n+      specialize_count = 0;\n+      copy_count = 0;\n+      copy_assign_count = 0;\n+      less_compare_count = 0;\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      move_count = 0;\n+      move_assign_count = 0;\n+#endif\n+    }\n+\n+    bool operator==(const counter_type& rhs) const\n+    { return val == rhs.val; }\n+\n+    bool operator<(const counter_type& rhs) const\n+    { return val < rhs.val; }\n+  };\n+\n+  int counter_type::default_count = 0;\n+  int counter_type::specialize_count = 0;\n+  int counter_type::copy_count = 0;\n+  int counter_type::copy_assign_count = 0;\n+  int counter_type::less_compare_count = 0;\n+\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+  int counter_type::move_count = 0;\n+  int counter_type::move_assign_count = 0;\n+#endif\n+\n+  struct counter_type_hasher\n+  {\n+    std::size_t operator()(const counter_type& c) const\n+    {\n+      return c.val;\n+    }\n+  };\n+\n+} // namespace __gnu_test\n+#endif"}]}