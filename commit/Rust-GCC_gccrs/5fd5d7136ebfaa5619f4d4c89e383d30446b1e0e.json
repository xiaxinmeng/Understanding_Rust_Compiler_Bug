{"sha": "5fd5d7136ebfaa5619f4d4c89e383d30446b1e0e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWZkNWQ3MTM2ZWJmYWE1NjE5ZjRkNGM4OWUzODNkMzA0NDZiMWUwZQ==", "commit": {"author": {"name": "DJ Delorie", "email": "dj@redhat.com", "date": "2010-10-22T21:41:42Z"}, "committer": {"name": "DJ Delorie", "email": "dj@gcc.gnu.org", "date": "2010-10-22T21:41:42Z"}, "message": "m32c-pragma.c (m32c_register_pragmas): Register the __far address space.\n\n* config/m32c/m32c-pragma.c (m32c_register_pragmas): Register the\n__far address space.\n* config/m32c/m32c.h (ADDR_SPACE_FAR): New.  Add support for\n\"__far\" address space for R8C and M16C processor variants.\n* config/m32c/m32c.c (m32c_addr_space_legitimate_address_p): New.\n(far_addr_space_p): New.\n(encode_pattern_1): Add sign and zero extend support.\n(m32c_hard_regno_nregs_1): Large pointers in A16 mode are SImode.\n(m32c_extra_constraint_p2): Add SF constraint.\n(m32c_legitimate_address_p): Support __far addresses.\n(m32c_addr_space_pointer_mode): New.\n(m32c_addr_space_address_mode): New.\n(m32c_addr_space_legitimate_address_p): New.\n(m32c_addr_space_legitimize_address): New.\n(m32c_addr_space_subset_p): New.\n(m32c_addr_space_convert): New.\n(conversions): Add __far operand patterns.\n(m32c_prepare_move): Force constants into registers for __far\nmoves.\n(m32c_split_move): __far moves are always split.\n* config/m32c/addsub.md (addsi3_1): Support SImode symbols.\n* config/m32c/mov.md (mov<mode>_far_op1): New.\n(mov<mode>_far_op2): New.\n(movqi_op): Add __far (SF) support.\n(movhi_op): Likewise.\n(movsi_splittable): Split A1A0 also.\n\nFrom-SVN: r165865", "tree": {"sha": "b6dbbd15876d30a787f5216576faf685f010fc8a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b6dbbd15876d30a787f5216576faf685f010fc8a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5fd5d7136ebfaa5619f4d4c89e383d30446b1e0e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5fd5d7136ebfaa5619f4d4c89e383d30446b1e0e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5fd5d7136ebfaa5619f4d4c89e383d30446b1e0e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5fd5d7136ebfaa5619f4d4c89e383d30446b1e0e/comments", "author": null, "committer": null, "parents": [{"sha": "bf1a7f6635cfa29d92d27550b731a8a16f3da8e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf1a7f6635cfa29d92d27550b731a8a16f3da8e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bf1a7f6635cfa29d92d27550b731a8a16f3da8e3"}], "stats": {"total": 380, "additions": 366, "deletions": 14}, "files": [{"sha": "2ddd304756e523bbaecc40e7ae0c4292b143535d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd5d7136ebfaa5619f4d4c89e383d30446b1e0e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd5d7136ebfaa5619f4d4c89e383d30446b1e0e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5fd5d7136ebfaa5619f4d4c89e383d30446b1e0e", "patch": "@@ -1,3 +1,32 @@\n+2010-10-22  DJ Delorie  <dj@redhat.com>\n+\n+\t* config/m32c/m32c-pragma.c (m32c_register_pragmas): Register the\n+\t__far address space.\n+\t* config/m32c/m32c.h (ADDR_SPACE_FAR): New.  Add support for\n+\t\"__far\" address space for R8C and M16C processor variants.\n+\t* config/m32c/m32c.c (m32c_addr_space_legitimate_address_p): New.\n+\t(far_addr_space_p): New.\n+\t(encode_pattern_1): Add sign and zero extend support.\n+\t(m32c_hard_regno_nregs_1): Large pointers in A16 mode are SImode.\n+\t(m32c_extra_constraint_p2): Add SF constraint.\n+\t(m32c_legitimate_address_p): Support __far addresses.\n+\t(m32c_addr_space_pointer_mode): New.\n+\t(m32c_addr_space_address_mode): New.\n+\t(m32c_addr_space_legitimate_address_p): New.\n+\t(m32c_addr_space_legitimize_address): New.\n+\t(m32c_addr_space_subset_p): New.\n+\t(m32c_addr_space_convert): New.\n+\t(conversions): Add __far operand patterns.\n+\t(m32c_prepare_move): Force constants into registers for __far\n+\tmoves.\n+\t(m32c_split_move): __far moves are always split.\n+\t* config/m32c/addsub.md (addsi3_1): Support SImode symbols.\n+\t* config/m32c/mov.md (mov<mode>_far_op1): New.\n+\t(mov<mode>_far_op2): New.\n+\t(movqi_op): Add __far (SF) support.\n+\t(movhi_op): Likewise.\n+\t(movsi_splittable): Split A1A0 also.\n+\n 2010-10-22  Artjoms Sinkarovs <artyom.shinakroff@gmail.com>\n \tAndrew Pinski <pinskia@gmail.com>\n "}, {"sha": "446327370ae290b7a057ee6aafc1517c61c8b954", "filename": "gcc/config/m32c/addsub.md", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd5d7136ebfaa5619f4d4c89e383d30446b1e0e/gcc%2Fconfig%2Fm32c%2Faddsub.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd5d7136ebfaa5619f4d4c89e383d30446b1e0e/gcc%2Fconfig%2Fm32c%2Faddsub.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Faddsub.md?ref=5fd5d7136ebfaa5619f4d4c89e383d30446b1e0e", "patch": "@@ -93,9 +93,17 @@\n     case 1:\n       return \\\"add.w %X2,%h0\\;adcf.w %H0\\\";\n     case 2:\n-      output_asm_insn (\\\"add.w %X2,%h0\\\",operands);\n-      operands[2]= GEN_INT (INTVAL (operands[2]) >> 16);\n-      return \\\"adc.w %X2,%H0\\\";\n+      if (GET_CODE (operands[2]) == SYMBOL_REF)\n+        {\n+          output_asm_insn (\\\"add.w #%%lo(%d2),%h0\\\",operands);\n+          return \\\"adc.w #%%hi(%d2),%H0\\\";\n+        }\n+      else\n+        {\n+          output_asm_insn (\\\"add.w %X2,%h0\\\",operands);\n+          operands[2]= GEN_INT (INTVAL (operands[2]) >> 16);\n+          return \\\"adc.w %X2,%H0\\\";\n+        }\n     case 3:\n       return \\\"add.w %h2,%h0\\;adc.w %H2,%H0\\\";\n     case 4:"}, {"sha": "f8a66ad115d0526010cbe317da61e3a1abfeca67", "filename": "gcc/config/m32c/m32c-pragma.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd5d7136ebfaa5619f4d4c89e383d30446b1e0e/gcc%2Fconfig%2Fm32c%2Fm32c-pragma.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd5d7136ebfaa5619f4d4c89e383d30446b1e0e/gcc%2Fconfig%2Fm32c%2Fm32c-pragma.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fm32c-pragma.c?ref=5fd5d7136ebfaa5619f4d4c89e383d30446b1e0e", "patch": "@@ -131,4 +131,13 @@ m32c_register_pragmas (void)\n   c_register_pragma (\"GCC\", \"memregs\", m32c_pragma_memregs);\n   c_register_pragma (NULL, \"ADDRESS\", m32c_pragma_address);\n   c_register_pragma (NULL, \"address\", m32c_pragma_address);\n+\n+  /* R8C and M16C have 16-bit pointers in a 20-bit address zpace.\n+     M32C has 24-bit pointers in a 24-bit address space, so does not\n+     need far pointers, but we accept the qualifier anyway, as a\n+     no-op.  */\n+  if (TARGET_A16)\n+    c_register_addr_space (\"__far\", ADDR_SPACE_FAR);\n+  else\n+    c_register_addr_space (\"__far\", ADDR_SPACE_GENERIC);\n }"}, {"sha": "4659db366f74b32769527510fc4e78c26c0ccd12", "filename": "gcc/config/m32c/m32c.c", "status": "modified", "additions": 279, "deletions": 2, "changes": 281, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd5d7136ebfaa5619f4d4c89e383d30446b1e0e/gcc%2Fconfig%2Fm32c%2Fm32c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd5d7136ebfaa5619f4d4c89e383d30446b1e0e/gcc%2Fconfig%2Fm32c%2Fm32c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fm32c.c?ref=5fd5d7136ebfaa5619f4d4c89e383d30446b1e0e", "patch": "@@ -73,6 +73,7 @@ static bool m32c_fixed_condition_code_regs (unsigned int *, unsigned int *);\n static struct machine_function *m32c_init_machine_status (void);\n static void m32c_insert_attributes (tree, tree *);\n static bool m32c_legitimate_address_p (enum machine_mode, rtx, bool);\n+static bool m32c_addr_space_legitimate_address_p (enum machine_mode, rtx, bool, addr_space_t);\n static rtx m32_function_arg (CUMULATIVE_ARGS *, enum machine_mode\n \t\t\t     const_tree, bool);\n static bool m32c_pass_by_reference (CUMULATIVE_ARGS *, enum machine_mode,\n@@ -124,6 +125,18 @@ static GTY(()) rtx patternr[30];\n #define IS_CR_REGNO(regno) ((regno) >= SB_REGNO && (regno) <= PC_REGNO)\n #define IS_CR_REG(rtx) (GET_CODE (rtx) == REG && IS_CR_REGNO (REGNO (rtx)))\n \n+static int\n+far_addr_space_p (rtx x)\n+{\n+  if (GET_CODE (x) != MEM)\n+    return 0;\n+#if DEBUG0\n+  fprintf(stderr, \"\\033[35mfar_addr_space: \"); debug_rtx(x);\n+  fprintf(stderr, \" = %d\\033[0m\\n\", MEM_ADDR_SPACE (x) == ADDR_SPACE_FAR);\n+#endif\n+  return MEM_ADDR_SPACE (x) == ADDR_SPACE_FAR;\n+}\n+\n /* We do most RTX matching by converting the RTX into a string, and\n    using string compares.  This vastly simplifies the logic in many of\n    the functions in this file.\n@@ -166,6 +179,16 @@ encode_pattern_1 (rtx x)\n     case CONST:\n       encode_pattern_1 (XEXP (x, 0));\n       break;\n+    case SIGN_EXTEND:\n+      *patternp++ = '^';\n+      *patternp++ = 'S';\n+      encode_pattern_1 (XEXP (x, 0));\n+      break;\n+    case ZERO_EXTEND:\n+      *patternp++ = '^';\n+      *patternp++ = 'Z';\n+      encode_pattern_1 (XEXP (x, 0));\n+      break;\n     case PLUS:\n       *patternp++ = '+';\n       encode_pattern_1 (XEXP (x, 0));\n@@ -553,7 +576,7 @@ m32c_hard_regno_nregs_1 (int regno, enum machine_mode mode)\n     return nregs_table[regno].qi_regs;\n   if (GET_MODE_SIZE (mode) <= 2)\n     return nregs_table[regno].hi_regs;\n-  if (regno == A0_REGNO && mode == PSImode && TARGET_A16)\n+  if (regno == A0_REGNO && mode == SImode && TARGET_A16)\n     return 2;\n   if ((GET_MODE_SIZE (mode) <= 3 || mode == PSImode) && TARGET_A24)\n     return nregs_table[regno].pi_regs;\n@@ -993,13 +1016,38 @@ m32c_const_ok_for_constraint_p (HOST_WIDE_INT value,\n   return 0;\n }\n \n+#define A0_OR_PSEUDO(x) (IS_REG(x, A0_REGNO) || REGNO (x) >= FIRST_PSEUDO_REGISTER)\n+\n /* Implements EXTRA_CONSTRAINT_STR (see next function too).  'S' is\n    for memory constraints, plus \"Rpa\" for PARALLEL rtx's we use for\n    call return values.  */\n int\n m32c_extra_constraint_p2 (rtx value, char c ATTRIBUTE_UNUSED, const char *str)\n {\n   encode_pattern (value);\n+\n+  if (far_addr_space_p (value))\n+    {\n+      if (memcmp (str, \"SF\", 2) == 0)\n+\t{\n+\t  return (   (RTX_IS (\"mr\")\n+\t\t      && A0_OR_PSEUDO (patternr[1])\n+\t\t      && GET_MODE (patternr[1]) == SImode)\n+\t\t     || (RTX_IS (\"m+^Sri\")\n+\t\t\t && A0_OR_PSEUDO (patternr[4])\n+\t\t\t && GET_MODE (patternr[4]) == HImode)\n+\t\t     || (RTX_IS (\"m+^Srs\")\n+\t\t\t && A0_OR_PSEUDO (patternr[4])\n+\t\t\t && GET_MODE (patternr[4]) == HImode)\n+\t\t     || (RTX_IS (\"m+^S+ris\")\n+\t\t\t && A0_OR_PSEUDO (patternr[5])\n+\t\t\t && GET_MODE (patternr[5]) == HImode)\n+\t\t     || RTX_IS (\"ms\")\n+\t\t     );\n+\t}\n+      return 0;\n+    }\n+\n   if (memcmp (str, \"Sd\", 2) == 0)\n     {\n       /* This is the common \"src/dest\" address */\n@@ -1067,6 +1115,10 @@ m32c_extra_constraint_p2 (rtx value, char c ATTRIBUTE_UNUSED, const char *str)\n     {\n       return r1h_operand (value, QImode);\n     }\n+  else if (memcmp (str, \"SF\", 2) == 0)\n+    {\n+      return 0;\n+    }\n \n   gcc_assert (str[0] != 'S');\n \n@@ -1837,6 +1889,11 @@ m32c_legitimate_address_p (enum machine_mode mode, rtx x, bool strict)\n   if (CONSTANT_P (x))\n     return 1;\n \n+  if (TARGET_A16 && GET_MODE (x) != HImode && GET_MODE (x) != SImode)\n+    return 0;\n+  if (TARGET_A24 && GET_MODE (x) != PSImode)\n+    return 0;\n+\n   /* Wide references to memory will be split after reload, so we must\n      ensure that all parts of such splits remain legitimate\n      addresses.  */\n@@ -1871,11 +1928,13 @@ m32c_legitimate_address_p (enum machine_mode mode, rtx x, bool strict)\n \t to please the assembler.  */\n       switch (REGNO (patternr[0]))\n \t{\n-\tcase A0_REGNO:\n \tcase A1_REGNO:\n \tcase SB_REGNO:\n \tcase FB_REGNO:\n \tcase SP_REGNO:\n+\t  if (TARGET_A16 && GET_MODE (x) == SImode)\n+\t    return 0;\n+\tcase A0_REGNO:\n \t  return 1;\n \n \tdefault:\n@@ -1884,6 +1943,10 @@ m32c_legitimate_address_p (enum machine_mode mode, rtx x, bool strict)\n \t  return 0;\n \t}\n     }\n+\n+  if (TARGET_A16 && GET_MODE (x) == SImode)\n+    return 0;\n+\n   if (RTX_IS (\"+ri\"))\n     {\n       /* This is more interesting, because different base registers\n@@ -2097,6 +2160,204 @@ m32c_legitimate_constant_p (rtx x ATTRIBUTE_UNUSED)\n }\n \n \n+/* Return the appropriate mode for a named address pointer.  */\n+#undef TARGET_ADDR_SPACE_POINTER_MODE\n+#define TARGET_ADDR_SPACE_POINTER_MODE m32c_addr_space_pointer_mode\n+static enum machine_mode\n+m32c_addr_space_pointer_mode (addr_space_t addrspace)\n+{\n+  switch (addrspace)\n+    {\n+    case ADDR_SPACE_GENERIC:\n+      return TARGET_A24 ? PSImode : HImode;\n+    case ADDR_SPACE_FAR:\n+      return SImode;\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+/* Return the appropriate mode for a named address address.  */\n+#undef TARGET_ADDR_SPACE_ADDRESS_MODE\n+#define TARGET_ADDR_SPACE_ADDRESS_MODE m32c_addr_space_address_mode\n+static enum machine_mode\n+m32c_addr_space_address_mode (addr_space_t addrspace)\n+{\n+  switch (addrspace)\n+    {\n+    case ADDR_SPACE_GENERIC:\n+      return TARGET_A24 ? PSImode : HImode;\n+    case ADDR_SPACE_FAR:\n+      return SImode;\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+/* Like m32c_legitimate_address_p, except with named addresses.  */\n+#undef TARGET_ADDR_SPACE_LEGITIMATE_ADDRESS_P\n+#define TARGET_ADDR_SPACE_LEGITIMATE_ADDRESS_P \\\n+  m32c_addr_space_legitimate_address_p\n+static bool\n+m32c_addr_space_legitimate_address_p (enum machine_mode mode, rtx x,\n+\t\t\t\t      bool strict, addr_space_t as)\n+{\n+  if (as == ADDR_SPACE_FAR)\n+    {\n+      if (TARGET_A24)\n+\treturn 0;\n+      encode_pattern (x);\n+      if (RTX_IS (\"r\"))\n+\t{\n+\t  if (GET_MODE (x) != SImode)\n+\t    return 0;\n+\t  switch (REGNO (patternr[0]))\n+\t    {\n+\t    case A0_REGNO:\n+\t      return 1;\n+\n+\t    default:\n+\t      if (IS_PSEUDO (patternr[0], strict))\n+\t\treturn 1;\n+\t      return 0;\n+\t    }\n+\t}\n+      if (RTX_IS (\"+^Sri\"))\n+\t{\n+\t  int rn = REGNO (patternr[3]);\n+\t  HOST_WIDE_INT offs = INTVAL (patternr[4]);\n+\t  if (GET_MODE (patternr[3]) != HImode)\n+\t    return 0;\n+\t  switch (rn)\n+\t    {\n+\t    case A0_REGNO:\n+\t      return (offs >= 0 && offs <= 0xfffff);\n+\n+\t    default:\n+\t      if (IS_PSEUDO (patternr[3], strict))\n+\t\treturn 1;\n+\t      return 0;\n+\t    }\n+\t}\n+      if (RTX_IS (\"+^Srs\"))\n+\t{\n+\t  int rn = REGNO (patternr[3]);\n+\t  if (GET_MODE (patternr[3]) != HImode)\n+\t    return 0;\n+\t  switch (rn)\n+\t    {\n+\t    case A0_REGNO:\n+\t      return 1;\n+\n+\t    default:\n+\t      if (IS_PSEUDO (patternr[3], strict))\n+\t\treturn 1;\n+\t      return 0;\n+\t    }\n+\t}\n+      if (RTX_IS (\"+^S+ris\"))\n+\t{\n+\t  int rn = REGNO (patternr[4]);\n+\t  if (GET_MODE (patternr[4]) != HImode)\n+\t    return 0;\n+\t  switch (rn)\n+\t    {\n+\t    case A0_REGNO:\n+\t      return 1;\n+\n+\t    default:\n+\t      if (IS_PSEUDO (patternr[4], strict))\n+\t\treturn 1;\n+\t      return 0;\n+\t    }\n+\t}\n+      if (RTX_IS (\"s\"))\n+\t{\n+\t  return 1;\n+\t}\n+      return 0;\n+    }\n+\n+  else if (as != ADDR_SPACE_GENERIC)\n+    gcc_unreachable ();\n+\n+  return m32c_legitimate_address_p (mode, x, strict);\n+}\n+\n+/* Like m32c_legitimate_address, except with named address support.  */\n+#undef TARGET_ADDR_SPACE_LEGITIMIZE_ADDRESS\n+#define TARGET_ADDR_SPACE_LEGITIMIZE_ADDRESS m32c_addr_space_legitimize_address\n+static rtx\n+m32c_addr_space_legitimize_address (rtx x, rtx oldx, enum machine_mode mode,\n+\t\t\t\t    addr_space_t as)\n+{\n+  if (as != ADDR_SPACE_GENERIC)\n+    {\n+#if DEBUG0\n+      fprintf (stderr, \"\\033[36mm32c_addr_space_legitimize_address for mode %s\\033[0m\\n\", mode_name[mode]);\n+      debug_rtx (x);\n+      fprintf (stderr, \"\\n\");\n+#endif\n+\n+      if (GET_CODE (x) != REG)\n+\t{\n+\t  x = force_reg (SImode, x);\n+\t}\n+      return x;\n+    }\n+\n+  return m32c_legitimize_address (x, oldx, mode);\n+}\n+\n+/* Determine if one named address space is a subset of another.  */\n+#undef TARGET_ADDR_SPACE_SUBSET_P\n+#define TARGET_ADDR_SPACE_SUBSET_P m32c_addr_space_subset_p\n+static bool\n+m32c_addr_space_subset_p (addr_space_t subset, addr_space_t superset)\n+{\n+  gcc_assert (subset == ADDR_SPACE_GENERIC || subset == ADDR_SPACE_FAR);\n+  gcc_assert (superset == ADDR_SPACE_GENERIC || superset == ADDR_SPACE_FAR);\n+\n+  if (subset == superset)\n+    return true;\n+\n+  else\n+    return (subset == ADDR_SPACE_GENERIC && superset == ADDR_SPACE_FAR);\n+}\n+\n+#undef TARGET_ADDR_SPACE_CONVERT\n+#define TARGET_ADDR_SPACE_CONVERT m32c_addr_space_convert\n+/* Convert from one address space to another.  */\n+static rtx\n+m32c_addr_space_convert (rtx op, tree from_type, tree to_type)\n+{\n+  addr_space_t from_as = TYPE_ADDR_SPACE (TREE_TYPE (from_type));\n+  addr_space_t to_as = TYPE_ADDR_SPACE (TREE_TYPE (to_type));\n+  rtx result;\n+\n+  gcc_assert (from_as == ADDR_SPACE_GENERIC || from_as == ADDR_SPACE_FAR);\n+  gcc_assert (to_as == ADDR_SPACE_GENERIC || to_as == ADDR_SPACE_FAR);\n+\n+  if (to_as == ADDR_SPACE_GENERIC && from_as == ADDR_SPACE_FAR)\n+    {\n+      /* This is unpredictable, as we're truncating off usable address\n+\t bits.  */\n+\n+      result = gen_reg_rtx (HImode);\n+      emit_move_insn (result, simplify_subreg (HImode, op, SImode, 0));\n+      return result;\n+    }\n+  else if (to_as == ADDR_SPACE_FAR && from_as == ADDR_SPACE_GENERIC)\n+    {\n+      /* This always works.  */\n+      result = gen_reg_rtx (SImode);\n+      emit_insn (gen_zero_extendhisi2 (result, op));\n+      return result;\n+    }\n+  else\n+    gcc_unreachable ();\n+}\n+\n /* Condition Code Status */\n \n #undef TARGET_FIXED_CONDITION_CODE_REGS\n@@ -2350,6 +2611,12 @@ const conversions[] = {\n   { 0, \"mr\", \"z[1]\" },\n   { 0, \"m+ri\", \"3[2]\" },\n   { 0, \"m+rs\", \"3[2]\" },\n+  { 0, \"m+^Zrs\", \"5[4]\" },\n+  { 0, \"m+^Zri\", \"5[4]\" },\n+  { 0, \"m+^Z+ris\", \"7+6[5]\" },\n+  { 0, \"m+^Srs\", \"5[4]\" },\n+  { 0, \"m+^Sri\", \"5[4]\" },\n+  { 0, \"m+^S+ris\", \"7+6[5]\" },\n   { 0, \"m+r+si\", \"4+5[2]\" },\n   { 0, \"ms\", \"1\" },\n   { 0, \"mi\", \"1\" },\n@@ -3392,6 +3659,11 @@ m32c_subreg (enum machine_mode outer,\n int\n m32c_prepare_move (rtx * operands, enum machine_mode mode)\n {\n+  if (far_addr_space_p (operands[0])\n+      && CONSTANT_P (operands[1]))\n+    {\n+      operands[1] = force_reg (GET_MODE (operands[0]), operands[1]);\n+    }\n   if (TARGET_A16 && mode == PSImode)\n     return m32c_split_move (operands, mode, 1);\n   if ((GET_CODE (operands[0]) == MEM)\n@@ -3497,6 +3769,11 @@ m32c_split_move (rtx * operands, enum machine_mode mode, int split_all)\n   if (m32c_extra_constraint_p (operands[0], 'S', \"Ss\"))\n     split_all = 3;\n \n+  if (TARGET_A16\n+      && (far_addr_space_p (operands[0])\n+\t  || far_addr_space_p (operands[1])))\n+    split_all |= 1;\n+\n   /* We don't need to split these.  */\n   if (TARGET_A24\n       && split_all != 3"}, {"sha": "2159e5c08b3cdd958c9a76d5031312657a61047b", "filename": "gcc/config/m32c/m32c.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd5d7136ebfaa5619f4d4c89e383d30446b1e0e/gcc%2Fconfig%2Fm32c%2Fm32c.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd5d7136ebfaa5619f4d4c89e383d30446b1e0e/gcc%2Fconfig%2Fm32c%2Fm32c.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fm32c.h?ref=5fd5d7136ebfaa5619f4d4c89e383d30446b1e0e", "patch": "@@ -567,6 +567,10 @@ typedef struct m32c_cumulative_args\n \n #define LEGITIMATE_CONSTANT_P(X) m32c_legitimate_constant_p (X)\n \n+/* Address spaces.  */\n+#define ADDR_SPACE_FAR\t1\n+\n+\n /* Condition Code Status */\n \n #define REVERSIBLE_CC_MODE(MODE) 1"}, {"sha": "5ebd3845f719b8f0a570fe9426f1faa04b993771", "filename": "gcc/config/m32c/mov.md", "status": "modified", "additions": 34, "deletions": 9, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd5d7136ebfaa5619f4d4c89e383d30446b1e0e/gcc%2Fconfig%2Fm32c%2Fmov.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd5d7136ebfaa5619f4d4c89e383d30446b1e0e/gcc%2Fconfig%2Fm32c%2Fmov.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fmov.md?ref=5fd5d7136ebfaa5619f4d4c89e383d30446b1e0e", "patch": "@@ -28,22 +28,45 @@\n ;; example is code like this: a = *b where both a and b are spilled to\n ;; the stack.\n \n+(define_insn \"mov<mode>_far_op1\"\n+  [(set (match_operand:QHI 0 \"register_operand\" \"=Rhi\")\n+\t(mem:QHI (plus:SI (sign_extend:SI (match_operand:HI 1 \"register_operand\" \"Ra0\"))\n+\t\t\t (match_operand 2 \"immediate_operand\" \"si\"))))\n+   ]\n+  \"\"\n+  \"lde.<bwl>\\t%D2[%1],%0\"\n+  [(set_attr \"flags\" \"sz\")]\n+  )\n+\n+(define_insn \"mov<mode>_far_op2\"\n+  [(set (mem:QHI (plus:SI (sign_extend:SI (match_operand:HI 0 \"register_operand\" \"Ra0\"))\n+\t\t\t (match_operand 1 \"immediate_operand\" \"si\")))\n+\t(match_operand:QHI 2 \"register_operand\"\n+\t\t\t  \"=Rhi\"))\n+   ]\n+  \"\"\n+  \"ste.<bwl>\\t%2,%D1[%0]\"\n+  [(set_attr \"flags\" \"sz\")]\n+  )\n+\n ;; Match push/pop before mov.b for passing char as arg,\n ;; e.g. stdlib/efgcvt.c.\n (define_insn \"movqi_op\"\n   [(set (match_operand:QI 0 \"m32c_nonimmediate_operand\"\n-\t\t\t  \"=Rqi*Rmm, <,          RqiSd*Rmm, SdSs,    Rqi*Rmm, Sd\")\n+\t\t\t  \"=SF,Rhi*Rmm, Rqi*Rmm, <,          RqiSd*Rmm, SdSs,    Rqi*Rmm, Sd\")\n \t(match_operand:QI 1 \"m32c_any_operand\"\n-\t\t\t  \"iRqi*Rmm, iRqiSd*Rmm, >,         Rqi*Rmm, SdSs,    i\"))]\n+\t\t\t  \"Rhi*Rmm,SF, iRqi*Rmm, iRqiSd*Rmm, >,         Rqi*Rmm, SdSs,    i\"))]\n   \"m32c_mov_ok (operands, QImode)\"\n   \"@\n+    lde.b\\t%1,%0\n+    ste.b\\t%1,%0\n     mov.b\\t%1,%0\n     push.b\\t%1\n     pop.b\\t%0\n     mov.b\\t%1,%0\n     mov.b\\t%1,%0\n     mov.b\\t%1,%0\"\n-  [(set_attr \"flags\" \"sz,*,*,sz,sz,sz\")]\n+  [(set_attr \"flags\" \"sz,sz,sz,*,*,sz,sz,sz\")]\n   )\n \n (define_expand \"movqi\"\n@@ -56,11 +79,13 @@\n \n (define_insn \"movhi_op\"\n   [(set (match_operand:HI 0 \"m32c_nonimmediate_operand\"\n-\t\t\t  \"=Rhi*Rmm,     Sd, SdSs,   *Rcr, RhiSd*Rmm, <, RhiSd*Rmm, <, *Rcr\")\n+\t\t\t  \"=SF,Rhi*Rmm, Rhi*Rmm,     Sd, SdSs,   *Rcr, RhiSd*Rmm, <, RhiSd*Rmm, <, *Rcr\")\n \t(match_operand:HI 1 \"m32c_any_operand\"\n-\t\t\t  \"iRhi*RmmSdSs, i, Rhi*Rmm, RhiSd*Rmm, *Rcr, iRhiSd*Rmm, >, *Rcr, >\"))]\n+\t\t\t  \" Rhi*Rmm,SF, iRhi*RmmSdSs, i, Rhi*Rmm, RhiSd*Rmm, *Rcr, iRhiSd*Rmm, >, *Rcr, >\"))]\n   \"m32c_mov_ok (operands, HImode)\"\n   \"@\n+   ste.w\\t%1,%0\n+   lde.w\\t%1,%0\n    mov.w\\t%1,%0\n    mov.w\\t%1,%0\n    mov.w\\t%1,%0\n@@ -70,7 +95,7 @@\n    pop.w\\t%0\n    pushc\\t%1\n    popc\\t%0\"\n-  [(set_attr \"flags\" \"sz,sz,sz,n,n,n,n,n,n\")]\n+  [(set_attr \"flags\" \"sz,sz,sz,sz,sz,n,n,n,n,n,n\")]\n   )\n \n (define_expand \"movhi\"\n@@ -176,11 +201,11 @@\n \n ; All SI moves are split if TARGET_A16\n (define_insn_and_split \"movsi_splittable\"\n-  [(set (match_operand:SI 0 \"m32c_nonimmediate_operand\" \"=Rsi<*Rmm,RsiSd*Rmm,Ss\")\n-\t(match_operand:SI 1 \"m32c_any_operand\" \"iRsiSd*Rmm,iRsi>*Rmm,Rsi*Rmm\"))]\n+  [(set (match_operand:SI 0 \"m32c_nonimmediate_operand\" \"=RsiRaa<*Rmm,  RsiRaaSd*Rmm,  Ss\")\n+\t(match_operand:SI 1 \"m32c_any_operand\" \"iRsiRaaSd*Rmm,  iRsiRaa>*Rmm,  RsiRaa*Rmm\"))]\n   \"TARGET_A16\"\n   \"#\"\n-  \"TARGET_A16 && reload_completed\"\n+  \"TARGET_A16\"\n   [(pc)]\n   \"m32c_split_move (operands, SImode, 1); DONE;\"\n   )"}]}