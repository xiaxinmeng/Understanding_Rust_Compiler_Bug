{"sha": "3d9a9f947fd29c85f7ed17f1b92000bff510de20", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2Q5YTlmOTQ3ZmQyOWM4NWY3ZWQxN2YxYjkyMDAwYmZmNTEwZGUyMA==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "2008-06-20T18:34:07Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "2008-06-20T18:34:07Z"}, "message": "ggc.h (GGC_RESIZEVAR): New, reorder macros.\n\n\t* ggc.h (GGC_RESIZEVAR): New, reorder macros.\n\t* tracer.c (tail_duplicate): Fix for -Wc++-compat.\n\t* tree-affine.c (aff_combination_expand, free_name_expansion):\n\tLikewise.\n\t* tree-cfg.c (replace_by_duplicate_decl, replace_ssa_name,\n\tmove_stmt_r, new_label_mapper): Likewise.\n\t* tree-complex.c (cvc_lookup): Likewise.\n\t* tree-dfa.c (create_function_ann): Likewise.\n\t* tree-dump.c (dump_register): Likewise.\n\t* tree-if-conv.c (tree_if_conversion, add_to_predicate_list,\n\tfind_phi_replacement_condition): Likewise.\n\t* tree-inline.c (copy_phis_for_bb, estimate_num_insns_1,\n\ttree_function_versioning): Likewise.\n\t* tree-into-ssa.c (cmp_dfsnum): Likewise.\n\t* tree-iterator.c (tsi_link_before, tsi_link_after): Likewise.\n\t* tree-nested.c (lookup_field_for_decl, lookup_tramp_for_decl,\n\tget_nonlocal_debug_decl, convert_nonlocal_reference,\n\tconvert_nonlocal_omp_clauses, get_local_debug_decl,\n\tconvert_local_reference, convert_local_omp_clauses,\n\tconvert_nl_goto_reference, convert_nl_goto_receiver,\n\tconvert_tramp_reference, convert_call_expr): Likewise.\n\t* tree-outof-ssa.c (contains_tree_r): Likewise.\n\t* tree-parloops.c (reduction_phi, initialize_reductions,\n\teliminate_local_variables_1, add_field_for_reduction,\n\tadd_field_for_name, create_phi_for_local_result,\n\tcreate_call_for_reduction_1, create_loads_for_reductions,\n\tcreate_stores_for_reduction, create_loads_and_stores_for_name):\n\tLikewise.\n\t* tree-phinodes.c (allocate_phi_node): Likewise.\n\t* tree-predcom.c (order_drefs, execute_pred_commoning_cbck):\n\tLikewise.\n\t* tree-sra.c (sra_elt_hash, sra_elt_eq, lookup_element):\n\tLikewise.\n\t* tree-ssa-alias.c (get_mem_sym_stats_for): Likewise.\n\t* tree-ssa-coalesce.c (compare_pairs): Likewise.\n\t* tree-ssa-loop-im.c (mem_ref_in_stmt, memref_hash, memref_eq,\n\tmemref_free, gather_mem_refs_stmt, vtoe_hash, vtoe_eq, vtoe_free,\n\trecord_vop_access, get_vop_accesses, get_vop_stores): Likewise.\n\t* tree-ssa-loop-prefetch.c (determine_loop_nest_reuse): Likewise. \n\t* tree-ssa-sccvn.c (VN_INFO_GET, free_phi, free_reference,\n\tvn_nary_op_insert): Likewise.\n\t* tree-ssa.c (redirect_edge_var_map_add,\n\tredirect_edge_var_map_clear, redirect_edge_var_map_dup): Likewise.\n\t* tree-vectorizer.c (vectorize_loops): Likewise.\n\t* tree.c (make_node_stat, copy_node_stat, build_int_cst_wide,\n\tbuild_fixed, build_real, make_tree_binfo_stat, make_tree_vec_stat,\n\ttree_cons_stat, build1_stat, build_variant_type_copy,\n\tdecl_init_priority_lookup, decl_fini_priority_lookup,\n\tdecl_priority_info, decl_restrict_base_lookup,\n\tdecl_restrict_base_insert, decl_debug_expr_lookup,\n\tdecl_debug_expr_insert, decl_value_expr_lookup,\n\tdecl_value_expr_insert, type_hash_eq, type_hash_lookup,\n\ttype_hash_add, get_file_function_name, tree_check_failed,\n\ttree_not_check_failed, tree_range_check_failed,\n\tomp_clause_range_check_failed, build_omp_clause,\n\tbuild_vl_exp_stat): Likewise.\n\t* value-prof.c (gimple_histogram_value,\n\tgimple_duplicate_stmt_histograms): Likewise.\n\t* var-tracking.c (attrs_list_insert, attrs_list_copy,\n\tunshare_variable, variable_union_info_cmp_pos, variable_union,\n\tdataflow_set_different_1, dataflow_set_different_2,\n\tvt_find_locations, variable_was_changed, set_variable_part,\n\temit_notes_for_differences_1, emit_notes_for_differences_2):\n\tLikewise.\n\t* varasm.c (prefix_name, emutls_decl, section_entry_eq,\n\tsection_entry_hash, object_block_entry_eq,\n\tobject_block_entry_hash, create_block_symbol,\n\tinitialize_cold_section_name, default_function_rodata_section,\n\tstrip_reg_name, set_user_assembler_name, const_desc_eq,\n\tbuild_constant_desc, output_constant_def, lookup_constant_def,\n\tconst_desc_rtx_hash, const_desc_rtx_eq, const_rtx_hash_1,\n\tcreate_constant_pool, force_const_mem, compute_reloc_for_rtx_1,\n\tdefault_internal_label): Likewise.\n\t* varray.c (varray_init, varray_grow): Likewise.\n\t* vec.c (vec_gc_o_reserve_1, vec_heap_o_reserve_1): Likewise.\n\nFrom-SVN: r136992", "tree": {"sha": "679f2f8dd5627c5293b9fec2a4c2fc13e5a73c6a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/679f2f8dd5627c5293b9fec2a4c2fc13e5a73c6a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3d9a9f947fd29c85f7ed17f1b92000bff510de20", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d9a9f947fd29c85f7ed17f1b92000bff510de20", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3d9a9f947fd29c85f7ed17f1b92000bff510de20", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d9a9f947fd29c85f7ed17f1b92000bff510de20/comments", "author": null, "committer": null, "parents": [{"sha": "952137502b559919c0cf1c6087ac7d4f3ba3a32c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/952137502b559919c0cf1c6087ac7d4f3ba3a32c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/952137502b559919c0cf1c6087ac7d4f3ba3a32c"}], "stats": {"total": 472, "additions": 287, "deletions": 185}, "files": [{"sha": "3a1c90baac9004870d496f0c53c001d63bcd9831", "filename": "gcc/ChangeLog", "status": "modified", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d9a9f947fd29c85f7ed17f1b92000bff510de20/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d9a9f947fd29c85f7ed17f1b92000bff510de20/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3d9a9f947fd29c85f7ed17f1b92000bff510de20", "patch": "@@ -1,3 +1,81 @@\n+2008-06-20  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* ggc.h (GGC_RESIZEVAR): New, reorder macros.\n+\t* tracer.c (tail_duplicate): Fix for -Wc++-compat.\n+\t* tree-affine.c (aff_combination_expand, free_name_expansion):\n+\tLikewise.\n+\t* tree-cfg.c (replace_by_duplicate_decl, replace_ssa_name,\n+\tmove_stmt_r, new_label_mapper): Likewise.\n+\t* tree-complex.c (cvc_lookup): Likewise.\n+\t* tree-dfa.c (create_function_ann): Likewise.\n+\t* tree-dump.c (dump_register): Likewise.\n+\t* tree-if-conv.c (tree_if_conversion, add_to_predicate_list,\n+\tfind_phi_replacement_condition): Likewise.\n+\t* tree-inline.c (copy_phis_for_bb, estimate_num_insns_1,\n+\ttree_function_versioning): Likewise.\n+\t* tree-into-ssa.c (cmp_dfsnum): Likewise.\n+\t* tree-iterator.c (tsi_link_before, tsi_link_after): Likewise.\n+\t* tree-nested.c (lookup_field_for_decl, lookup_tramp_for_decl,\n+\tget_nonlocal_debug_decl, convert_nonlocal_reference,\n+\tconvert_nonlocal_omp_clauses, get_local_debug_decl,\n+\tconvert_local_reference, convert_local_omp_clauses,\n+\tconvert_nl_goto_reference, convert_nl_goto_receiver,\n+\tconvert_tramp_reference, convert_call_expr): Likewise.\n+\t* tree-outof-ssa.c (contains_tree_r): Likewise.\n+\t* tree-parloops.c (reduction_phi, initialize_reductions,\n+\teliminate_local_variables_1, add_field_for_reduction,\n+\tadd_field_for_name, create_phi_for_local_result,\n+\tcreate_call_for_reduction_1, create_loads_for_reductions,\n+\tcreate_stores_for_reduction, create_loads_and_stores_for_name):\n+\tLikewise.\n+\t* tree-phinodes.c (allocate_phi_node): Likewise.\n+\t* tree-predcom.c (order_drefs, execute_pred_commoning_cbck):\n+\tLikewise.\n+\t* tree-sra.c (sra_elt_hash, sra_elt_eq, lookup_element):\n+\tLikewise.\n+\t* tree-ssa-alias.c (get_mem_sym_stats_for): Likewise.\n+\t* tree-ssa-coalesce.c (compare_pairs): Likewise.\n+\t* tree-ssa-loop-im.c (mem_ref_in_stmt, memref_hash, memref_eq,\n+\tmemref_free, gather_mem_refs_stmt, vtoe_hash, vtoe_eq, vtoe_free,\n+\trecord_vop_access, get_vop_accesses, get_vop_stores): Likewise.\n+\t* tree-ssa-loop-prefetch.c (determine_loop_nest_reuse): Likewise. \n+\t* tree-ssa-sccvn.c (VN_INFO_GET, free_phi, free_reference,\n+\tvn_nary_op_insert): Likewise.\n+\t* tree-ssa.c (redirect_edge_var_map_add,\n+\tredirect_edge_var_map_clear, redirect_edge_var_map_dup): Likewise.\n+\t* tree-vectorizer.c (vectorize_loops): Likewise.\n+\t* tree.c (make_node_stat, copy_node_stat, build_int_cst_wide,\n+\tbuild_fixed, build_real, make_tree_binfo_stat, make_tree_vec_stat,\n+\ttree_cons_stat, build1_stat, build_variant_type_copy,\n+\tdecl_init_priority_lookup, decl_fini_priority_lookup,\n+\tdecl_priority_info, decl_restrict_base_lookup,\n+\tdecl_restrict_base_insert, decl_debug_expr_lookup,\n+\tdecl_debug_expr_insert, decl_value_expr_lookup,\n+\tdecl_value_expr_insert, type_hash_eq, type_hash_lookup,\n+\ttype_hash_add, get_file_function_name, tree_check_failed,\n+\ttree_not_check_failed, tree_range_check_failed,\n+\tomp_clause_range_check_failed, build_omp_clause,\n+\tbuild_vl_exp_stat): Likewise.\n+\t* value-prof.c (gimple_histogram_value,\n+\tgimple_duplicate_stmt_histograms): Likewise.\n+\t* var-tracking.c (attrs_list_insert, attrs_list_copy,\n+\tunshare_variable, variable_union_info_cmp_pos, variable_union,\n+\tdataflow_set_different_1, dataflow_set_different_2,\n+\tvt_find_locations, variable_was_changed, set_variable_part,\n+\temit_notes_for_differences_1, emit_notes_for_differences_2):\n+\tLikewise.\n+\t* varasm.c (prefix_name, emutls_decl, section_entry_eq,\n+\tsection_entry_hash, object_block_entry_eq,\n+\tobject_block_entry_hash, create_block_symbol,\n+\tinitialize_cold_section_name, default_function_rodata_section,\n+\tstrip_reg_name, set_user_assembler_name, const_desc_eq,\n+\tbuild_constant_desc, output_constant_def, lookup_constant_def,\n+\tconst_desc_rtx_hash, const_desc_rtx_eq, const_rtx_hash_1,\n+\tcreate_constant_pool, force_const_mem, compute_reloc_for_rtx_1,\n+\tdefault_internal_label): Likewise.\n+\t* varray.c (varray_init, varray_grow): Likewise.\n+\t* vec.c (vec_gc_o_reserve_1, vec_heap_o_reserve_1): Likewise.\n+\n 2008-06-20  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/i386.md (*jcc_fused_1): Handle all valid compare"}, {"sha": "74c36394d1c13f08990718d811a9b0b698a3168e", "filename": "gcc/ggc.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d9a9f947fd29c85f7ed17f1b92000bff510de20/gcc%2Fggc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d9a9f947fd29c85f7ed17f1b92000bff510de20/gcc%2Fggc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc.h?ref=3d9a9f947fd29c85f7ed17f1b92000bff510de20", "patch": "@@ -237,9 +237,10 @@ extern void dump_ggc_loc_statistics (bool);\n #define GGC_CNEW(T)\t\t((T *) ggc_alloc_cleared (sizeof (T)))\n #define GGC_NEWVEC(T, N)\t((T *) ggc_alloc ((N) * sizeof(T)))\n #define GGC_CNEWVEC(T, N)\t((T *) ggc_alloc_cleared ((N) * sizeof(T)))\n+#define GGC_RESIZEVEC(T, P, N)  ((T *) ggc_realloc ((P), (N) * sizeof (T)))\n #define GGC_NEWVAR(T, S)\t((T *) ggc_alloc ((S)))\n #define GGC_CNEWVAR(T, S)\t((T *) ggc_alloc_cleared ((S)))\n-#define GGC_RESIZEVEC(T, P, N)  ((T *) ggc_realloc ((P), (N) * sizeof (T)))\n+#define GGC_RESIZEVAR(T, P, N)  ((T *) ggc_realloc ((P), (N)))\n \n #define ggc_alloc_rtvec(NELT)\t\t\t\t\t\t \\\n   ((rtvec) ggc_alloc_zone (sizeof (struct rtvec_def) + ((NELT) - 1)\t \\"}, {"sha": "98f66cea949428106995f031c1e984a24e4bc249", "filename": "gcc/tracer.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d9a9f947fd29c85f7ed17f1b92000bff510de20/gcc%2Ftracer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d9a9f947fd29c85f7ed17f1b92000bff510de20/gcc%2Ftracer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftracer.c?ref=3d9a9f947fd29c85f7ed17f1b92000bff510de20", "patch": "@@ -265,7 +265,7 @@ tail_duplicate (void)\n   while (traced_insns < cover_insns && nduplicated < max_dup_insns\n          && !fibheap_empty (heap))\n     {\n-      basic_block bb = fibheap_extract_min (heap);\n+      basic_block bb = (basic_block) fibheap_extract_min (heap);\n       int n, pos;\n \n       if (!bb)"}, {"sha": "59ac3d786b41c7f040b1d4090f118f169f59ec28", "filename": "gcc/tree-affine.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d9a9f947fd29c85f7ed17f1b92000bff510de20/gcc%2Ftree-affine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d9a9f947fd29c85f7ed17f1b92000bff510de20/gcc%2Ftree-affine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-affine.c?ref=3d9a9f947fd29c85f7ed17f1b92000bff510de20", "patch": "@@ -609,7 +609,7 @@ aff_combination_expand (aff_tree *comb, struct pointer_map_t **cache)\n       if (!*cache)\n \t*cache = pointer_map_create ();\n       slot = pointer_map_insert (*cache, e);\n-      exp = *slot;\n+      exp = (struct name_expansion *) *slot;\n \n       if (!exp)\n \t{\n@@ -690,7 +690,7 @@ static bool\n free_name_expansion (const void *key ATTRIBUTE_UNUSED, void **value,\n \t\t     void *data ATTRIBUTE_UNUSED)\n {\n-  struct name_expansion *exp = *value;\n+  struct name_expansion *const exp = (struct name_expansion *) *value;\n \n   free (exp);\n   return true;"}, {"sha": "50f53a080e83ffa4846c3ca1bc1268c22646c3d1", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d9a9f947fd29c85f7ed17f1b92000bff510de20/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d9a9f947fd29c85f7ed17f1b92000bff510de20/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=3d9a9f947fd29c85f7ed17f1b92000bff510de20", "patch": "@@ -5622,7 +5622,7 @@ replace_by_duplicate_decl (tree *tp, struct pointer_map_t *vars_map,\n       *loc = new_t;\n     }\n   else\n-    new_t = *loc;\n+    new_t = (tree) *loc;\n \n   *tp = new_t;\n }\n@@ -5658,7 +5658,7 @@ replace_ssa_name (tree name, struct pointer_map_t *vars_map,\n       *loc = new_name;\n     }\n   else\n-    new_name = *loc;\n+    new_name = (tree) *loc;\n \n   return new_name;\n }\n@@ -5713,7 +5713,8 @@ move_stmt_r (tree *tp, int *walk_subtrees, void *data)\n \t    {\n \t      struct tree_map in, *out;\n \t      in.base.from = t;\n-\t      out = htab_find_with_hash (p->new_label_map, &in, DECL_UID (t));\n+\t      out = (struct tree_map *)\n+\t\thtab_find_with_hash (p->new_label_map, &in, DECL_UID (t));\n \t      if (out)\n \t\t*tp = t = out->to;\n \t    }\n@@ -5972,7 +5973,7 @@ new_label_mapper (tree decl, void *data)\n \n   gcc_assert (TREE_CODE (decl) == LABEL_DECL);\n \n-  m = xmalloc (sizeof (struct tree_map));\n+  m = XNEW (struct tree_map);\n   m->hash = DECL_UID (decl);\n   m->base.from = decl;\n   m->to = create_artificial_label ();"}, {"sha": "0fc1cc5f305d948eb7d2c4506f1d4aeeb38e9462", "filename": "gcc/tree-complex.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d9a9f947fd29c85f7ed17f1b92000bff510de20/gcc%2Ftree-complex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d9a9f947fd29c85f7ed17f1b92000bff510de20/gcc%2Ftree-complex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-complex.c?ref=3d9a9f947fd29c85f7ed17f1b92000bff510de20", "patch": "@@ -66,7 +66,7 @@ cvc_lookup (unsigned int uid)\n {\n   struct int_tree_map *h, in;\n   in.uid = uid;\n-  h = htab_find_with_hash (complex_variable_components, &in, uid);\n+  h = (struct int_tree_map *) htab_find_with_hash (complex_variable_components, &in, uid);\n   return h ? h->to : NULL;\n }\n  "}, {"sha": "a1780399cc6c5fc6002396dc845e3b63a9970865", "filename": "gcc/tree-dfa.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d9a9f947fd29c85f7ed17f1b92000bff510de20/gcc%2Ftree-dfa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d9a9f947fd29c85f7ed17f1b92000bff510de20/gcc%2Ftree-dfa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dfa.c?ref=3d9a9f947fd29c85f7ed17f1b92000bff510de20", "patch": "@@ -166,7 +166,7 @@ create_function_ann (tree t)\n   gcc_assert (TREE_CODE (t) == FUNCTION_DECL);\n   gcc_assert (!t->base.ann || t->base.ann->common.type == FUNCTION_ANN);\n \n-  ann = ggc_alloc (sizeof (*ann));\n+  ann = (function_ann_t) ggc_alloc (sizeof (*ann));\n   memset ((void *) ann, 0, sizeof (*ann));\n \n   ann->common.type = FUNCTION_ANN;"}, {"sha": "b7363c377c00e05e47e2d5abc9982a680b464de1", "filename": "gcc/tree-dump.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d9a9f947fd29c85f7ed17f1b92000bff510de20/gcc%2Ftree-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d9a9f947fd29c85f7ed17f1b92000bff510de20/gcc%2Ftree-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dump.c?ref=3d9a9f947fd29c85f7ed17f1b92000bff510de20", "patch": "@@ -843,9 +843,9 @@ dump_register (const char *suffix, const char *swtch, const char *glob,\n \textra_dump_files_alloced = 32;\n       else\n \textra_dump_files_alloced *= 2;\n-      extra_dump_files = xrealloc (extra_dump_files,\n-\t\t\t\t   sizeof (struct dump_file_info)\n-\t\t\t\t   * extra_dump_files_alloced);\n+      extra_dump_files = XRESIZEVEC (struct dump_file_info,\n+\t\t\t\t     extra_dump_files,\n+\t\t\t\t     extra_dump_files_alloced);\n     }\n \n   memset (&extra_dump_files[this], 0, sizeof (struct dump_file_info));"}, {"sha": "78b29a4a64bd0b442d511101c4ca6b1164e8bf6c", "filename": "gcc/tree-if-conv.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d9a9f947fd29c85f7ed17f1b92000bff510de20/gcc%2Ftree-if-conv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d9a9f947fd29c85f7ed17f1b92000bff510de20/gcc%2Ftree-if-conv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-if-conv.c?ref=3d9a9f947fd29c85f7ed17f1b92000bff510de20", "patch": "@@ -171,7 +171,7 @@ tree_if_conversion (struct loop *loop, bool for_vectorizer)\n       bb = ifc_bbs [i];\n \n       /* Update condition using predicate list.  */\n-      cond = bb->aux;\n+      cond = (tree) bb->aux;\n \n       /* Process all statements in this basic block.\n \t Remove conditional expression, if any, and annotate\n@@ -620,7 +620,7 @@ if_convertible_loop_p (struct loop *loop, bool for_vectorizer ATTRIBUTE_UNUSED)\n static void\n add_to_predicate_list (basic_block bb, tree new_cond)\n {\n-  tree cond = bb->aux;\n+  tree cond = (tree) bb->aux;\n \n   if (cond)\n     cond = fold_build2 (TRUTH_OR_EXPR, boolean_type_node,\n@@ -737,7 +737,7 @@ find_phi_replacement_condition (struct loop *loop,\n         See PR23115.  */\n \n   /* Select condition that is not TRUTH_NOT_EXPR.  */\n-  tmp_cond = (first_edge->src)->aux;\n+  tmp_cond = (tree) (first_edge->src)->aux;\n   gcc_assert (tmp_cond);\n \n   if (TREE_CODE (tmp_cond) == TRUTH_NOT_EXPR)\n@@ -755,13 +755,13 @@ find_phi_replacement_condition (struct loop *loop,\n       || dominated_by_p (CDI_DOMINATORS,\n \t\t\t second_edge->src, first_edge->src))\n     {\n-      *cond = (second_edge->src)->aux;\n+      *cond = (tree) (second_edge->src)->aux;\n \n       /* If there is a condition on an incoming edge,\n \t AND it with the incoming bb predicate.  */\n       if (second_edge->aux)\n \t*cond = build2 (TRUTH_AND_EXPR, boolean_type_node,\n-\t\t\t*cond, second_edge->aux);\n+\t\t\t*cond, (tree) second_edge->aux);\n \n       if (TREE_CODE (*cond) == TRUTH_NOT_EXPR)\n \t/* We can be smart here and choose inverted\n@@ -774,13 +774,13 @@ find_phi_replacement_condition (struct loop *loop,\n   else\n     {\n       /* FIRST_BB is not loop header */\n-      *cond = (first_edge->src)->aux;\n+      *cond = (tree) (first_edge->src)->aux;\n \n       /* If there is a condition on an incoming edge,\n \t AND it with the incoming bb predicate.  */\n       if (first_edge->aux)\n \t*cond = build2 (TRUTH_AND_EXPR, boolean_type_node,\n-\t\t\t*cond, first_edge->aux);\n+\t\t\t*cond, (tree) first_edge->aux);\n     }\n \n   /* Create temp. for the condition. Vectorizer prefers to have gimple"}, {"sha": "0f1a8bd1720b13761cdb3fa05eec82f829749f5a", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d9a9f947fd29c85f7ed17f1b92000bff510de20/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d9a9f947fd29c85f7ed17f1b92000bff510de20/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=3d9a9f947fd29c85f7ed17f1b92000bff510de20", "patch": "@@ -1201,7 +1201,7 @@ copy_edges_for_bb (basic_block bb, gcov_type count_scale, basic_block ret_bb)\n static void\n copy_phis_for_bb (basic_block bb, copy_body_data *id)\n {\n-  basic_block new_bb = bb->aux;\n+  basic_block const new_bb = (basic_block) bb->aux;\n   edge_iterator ei;\n   tree phi;\n \n@@ -1219,7 +1219,7 @@ copy_phis_for_bb (basic_block bb, copy_body_data *id)\n \t    = new_phi = create_phi_node (new_res, new_bb);\n \t  FOR_EACH_EDGE (new_edge, ei, new_bb->preds)\n \t    {\n-\t      edge old_edge = find_edge (new_edge->src->aux, bb);\n+\t      edge const old_edge = find_edge ((basic_block) new_edge->src->aux, bb);\n \t      tree arg = PHI_ARG_DEF_FROM_EDGE (phi, old_edge);\n \t      tree new_arg = arg;\n \n@@ -2173,7 +2173,7 @@ struct eni_data\n static tree\n estimate_num_insns_1 (tree *tp, int *walk_subtrees, void *data)\n {\n-  struct eni_data *d = data;\n+  struct eni_data *const d = (struct eni_data *) data;\n   tree x = *tp;\n   unsigned cost;\n \n@@ -3589,7 +3589,7 @@ tree_function_versioning (tree old_decl, tree new_decl, varray_type tree_map,\n   if (tree_map)\n     for (i = 0; i < VARRAY_ACTIVE_SIZE (tree_map); i++)\n       {\n-\treplace_info = VARRAY_GENERIC_PTR (tree_map, i);\n+\treplace_info = (struct ipa_replace_map *) VARRAY_GENERIC_PTR (tree_map, i);\n \tif (replace_info->replace_p)\n \t  insert_decl_map (&id, replace_info->old_tree,\n \t\t\t   replace_info->new_tree);"}, {"sha": "c0bebf73bf0b7385e73b8cb5d3feca223ab00b7d", "filename": "gcc/tree-into-ssa.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d9a9f947fd29c85f7ed17f1b92000bff510de20/gcc%2Ftree-into-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d9a9f947fd29c85f7ed17f1b92000bff510de20/gcc%2Ftree-into-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-into-ssa.c?ref=3d9a9f947fd29c85f7ed17f1b92000bff510de20", "patch": "@@ -787,8 +787,8 @@ struct dom_dfsnum\n static int\n cmp_dfsnum (const void *a, const void *b)\n {\n-  const struct dom_dfsnum *da = a;\n-  const struct dom_dfsnum *db = b;\n+  const struct dom_dfsnum *const da = (const struct dom_dfsnum *) a;\n+  const struct dom_dfsnum *const db = (const struct dom_dfsnum *) b;\n \n   return (int) da->dfs_num - (int) db->dfs_num;\n }"}, {"sha": "9816f249e1b7e650da743f1194fcbe41c0dee107", "filename": "gcc/tree-iterator.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d9a9f947fd29c85f7ed17f1b92000bff510de20/gcc%2Ftree-iterator.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d9a9f947fd29c85f7ed17f1b92000bff510de20/gcc%2Ftree-iterator.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-iterator.c?ref=3d9a9f947fd29c85f7ed17f1b92000bff510de20", "patch": "@@ -89,7 +89,7 @@ tsi_link_before (tree_stmt_iterator *i, tree t, enum tsi_iterator_update mode)\n     }\n   else\n     {\n-      head = ggc_alloc (sizeof (*head));\n+      head = GGC_NEW (struct tree_statement_list_node);\n       head->prev = NULL;\n       head->next = NULL;\n       head->stmt = t;\n@@ -165,7 +165,7 @@ tsi_link_after (tree_stmt_iterator *i, tree t, enum tsi_iterator_update mode)\n     }\n   else\n     {\n-      head = ggc_alloc (sizeof (*head));\n+      head = GGC_NEW (struct tree_statement_list_node);\n       head->prev = NULL;\n       head->next = NULL;\n       head->stmt = t;"}, {"sha": "225605071cc5f5fbc14bad0e64fd1aec98bb7de6", "filename": "gcc/tree-nested.c", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d9a9f947fd29c85f7ed17f1b92000bff510de20/gcc%2Ftree-nested.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d9a9f947fd29c85f7ed17f1b92000bff510de20/gcc%2Ftree-nested.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nested.c?ref=3d9a9f947fd29c85f7ed17f1b92000bff510de20", "patch": "@@ -258,7 +258,7 @@ lookup_field_for_decl (struct nesting_info *info, tree decl,\n   if (insert == NO_INSERT)\n     {\n       slot = pointer_map_contains (info->field_map, decl);\n-      return slot ? *slot : NULL;\n+      return slot ? (tree) *slot : NULL_TREE;\n     }\n \n   slot = pointer_map_insert (info->field_map, decl);\n@@ -291,7 +291,7 @@ lookup_field_for_decl (struct nesting_info *info, tree decl,\n \tinfo->any_parm_remapped = true;\n     }\n \n-  return *slot;\n+  return (tree) *slot;\n }\n \n /* Build or return the variable that holds the static chain within\n@@ -450,7 +450,7 @@ lookup_tramp_for_decl (struct nesting_info *info, tree decl,\n   if (insert == NO_INSERT)\n     {\n       slot = pointer_map_contains (info->var_map, decl);\n-      return slot ? *slot : NULL;\n+      return slot ? (tree) *slot : NULL_TREE;\n     }\n \n   slot = pointer_map_insert (info->var_map, decl);\n@@ -467,7 +467,7 @@ lookup_tramp_for_decl (struct nesting_info *info, tree decl,\n       info->any_tramp_created = true;\n     }\n \n-  return *slot;\n+  return (tree) *slot;\n } \n \n /* Build or return the field within the non-local frame state that holds\n@@ -896,7 +896,7 @@ get_nonlocal_debug_decl (struct nesting_info *info, tree decl)\n   slot = pointer_map_insert (info->var_map, decl);\n \n   if (*slot)\n-    return *slot;\n+    return (tree) *slot;\n \n   target_context = decl_function_context (decl);\n \n@@ -961,7 +961,7 @@ static tree\n convert_nonlocal_reference (tree *tp, int *walk_subtrees, void *data)\n {\n   struct walk_stmt_info *wi = (struct walk_stmt_info *) data;\n-  struct nesting_info *info = wi->info;\n+  struct nesting_info *const info = (struct nesting_info *) wi->info;\n   tree t = *tp;\n   tree save_local_var_chain;\n   bitmap save_suppress;\n@@ -1053,7 +1053,8 @@ convert_nonlocal_reference (tree *tp, int *walk_subtrees, void *data)\n \t       where we only accept variables (and min_invariant, presumably),\n \t       then compute the address into a temporary.  */\n \t    if (save_val_only)\n-\t      *tp = tsi_gimplify_val (wi->info, t, &wi->tsi);\n+\t      *tp = tsi_gimplify_val ((struct nesting_info *) wi->info,\n+\t\t\t\t      t, &wi->tsi);\n \t  }\n       }\n       break;\n@@ -1165,7 +1166,7 @@ convert_nonlocal_reference (tree *tp, int *walk_subtrees, void *data)\n static bool\n convert_nonlocal_omp_clauses (tree *pclauses, struct walk_stmt_info *wi)\n {\n-  struct nesting_info *info = wi->info;\n+  struct nesting_info *const info = (struct nesting_info *) wi->info;\n   bool need_chain = false, need_stmts = false;\n   tree clause, decl;\n   int dummy;\n@@ -1277,7 +1278,7 @@ get_local_debug_decl (struct nesting_info *info, tree decl, tree field)\n \n   slot = pointer_map_insert (info->var_map, decl);\n   if (*slot)\n-    return *slot;\n+    return (tree) *slot;\n \n   /* Make sure frame_decl gets created.  */\n   (void) get_frame_type (info);\n@@ -1318,7 +1319,7 @@ static tree\n convert_local_reference (tree *tp, int *walk_subtrees, void *data)\n {\n   struct walk_stmt_info *wi = (struct walk_stmt_info *) data;\n-  struct nesting_info *info = wi->info;\n+  struct nesting_info *const info = (struct nesting_info *) wi->info;\n   tree t = *tp, field, x;\n   bool save_val_only;\n   tree save_local_var_chain;\n@@ -1388,7 +1389,7 @@ convert_local_reference (tree *tp, int *walk_subtrees, void *data)\n \t  /* If we are in a context where we only accept values, then\n \t     compute the address into a temporary.  */\n \t  if (save_val_only)\n-\t    *tp = tsi_gimplify_val (wi->info, t, &wi->tsi);\n+\t    *tp = tsi_gimplify_val ((struct nesting_info *)wi->info, t, &wi->tsi);\n \t}\n       break;\n \n@@ -1501,7 +1502,7 @@ convert_local_reference (tree *tp, int *walk_subtrees, void *data)\n static bool\n convert_local_omp_clauses (tree *pclauses, struct walk_stmt_info *wi)\n {\n-  struct nesting_info *info = wi->info;\n+  struct nesting_info *const info = (struct nesting_info *) wi->info;\n   bool need_frame = false, need_stmts = false;\n   tree clause, decl;\n   int dummy;\n@@ -1613,7 +1614,7 @@ static tree\n convert_nl_goto_reference (tree *tp, int *walk_subtrees, void *data)\n {\n   struct walk_stmt_info *wi = (struct walk_stmt_info *) data;\n-  struct nesting_info *info = wi->info, *i;\n+  struct nesting_info *const info = (struct nesting_info *) wi->info, *i;\n   tree t = *tp, label, new_label, target_context, x, field;\n   void **slot;\n \n@@ -1645,7 +1646,7 @@ convert_nl_goto_reference (tree *tp, int *walk_subtrees, void *data)\n       *slot = new_label;\n     }\n   else\n-    new_label = *slot;\n+    new_label = (tree) *slot;\n   \n   /* Build: __builtin_nl_goto(new_label, &chain->nl_goto_field).  */\n   field = get_nl_goto_field (i);\n@@ -1671,7 +1672,7 @@ static tree\n convert_nl_goto_receiver (tree *tp, int *walk_subtrees, void *data)\n {\n   struct walk_stmt_info *wi = (struct walk_stmt_info *) data;\n-  struct nesting_info *info = wi->info;\n+  struct nesting_info *const info = (struct nesting_info *) wi->info;\n   tree t = *tp, label, new_label, x;\n   tree_stmt_iterator tmp_tsi;\n   void **slot;\n@@ -1710,7 +1711,7 @@ static tree\n convert_tramp_reference (tree *tp, int *walk_subtrees, void *data)\n {\n   struct walk_stmt_info *wi = (struct walk_stmt_info *) data;\n-  struct nesting_info *info = wi->info, *i;\n+  struct nesting_info *const info = (struct nesting_info *) wi->info, *i;\n   tree t = *tp, decl, target_context, x;\n \n   *walk_subtrees = 0;\n@@ -1793,7 +1794,7 @@ static tree\n convert_call_expr (tree *tp, int *walk_subtrees, void *data)\n {\n   struct walk_stmt_info *wi = (struct walk_stmt_info *) data;\n-  struct nesting_info *info = wi->info;\n+  struct nesting_info *const info = (struct nesting_info *) wi->info;\n   tree t = *tp, decl, target_context;\n   char save_static_chain_added;\n   int i;"}, {"sha": "40c1d3f9c3bb9de2fb3b62ad79d1729acee8520a", "filename": "gcc/tree-outof-ssa.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d9a9f947fd29c85f7ed17f1b92000bff510de20/gcc%2Ftree-outof-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d9a9f947fd29c85f7ed17f1b92000bff510de20/gcc%2Ftree-outof-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-outof-ssa.c?ref=3d9a9f947fd29c85f7ed17f1b92000bff510de20", "patch": "@@ -881,7 +881,7 @@ contains_tree_r (tree * tp, int *walk_subtrees, void *data)\n   if (*tp == data)\n     {\n       *walk_subtrees = 0;\n-      return data;\n+      return (tree) data;\n     }\n   else\n     return NULL_TREE;"}, {"sha": "be0fd9cbac42c1cf0aa5a95aece33f508658f24c", "filename": "gcc/tree-parloops.c", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d9a9f947fd29c85f7ed17f1b92000bff510de20/gcc%2Ftree-parloops.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d9a9f947fd29c85f7ed17f1b92000bff510de20/gcc%2Ftree-parloops.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-parloops.c?ref=3d9a9f947fd29c85f7ed17f1b92000bff510de20", "patch": "@@ -208,7 +208,7 @@ reduction_phi (htab_t reduction_list, tree phi)\n     return NULL;\n \n   tmpred.reduc_phi = phi;\n-  red = htab_find (reduction_list, &tmpred);\n+  red = (struct reduction_info *) htab_find (reduction_list, &tmpred);\n \n   return red;\n }\n@@ -527,7 +527,7 @@ initialize_reductions (void **slot, void *data)\n   tree bvar, type, arg;\n   edge e;\n \n-  struct reduction_info *reduc = *slot;\n+  struct reduction_info *const reduc = (struct reduction_info *) *slot;\n   struct loop *loop = (struct loop *) data;\n \n   /* Create initialization in preheader: \n@@ -583,7 +583,7 @@ struct elv_data\n static tree\n eliminate_local_variables_1 (tree *tp, int *walk_subtrees, void *data)\n {\n-  struct elv_data *dta = data;\n+  struct elv_data *const dta = (struct elv_data *) data;\n   tree t = *tp, var, addr, addr_type, type, obj;\n \n   if (DECL_P (t))\n@@ -853,8 +853,8 @@ static int\n add_field_for_reduction (void **slot, void *data)\n {\n   \n-  struct reduction_info *red = *slot;\n-  tree type = data;\n+  struct reduction_info *const red = (struct reduction_info *) *slot;\n+  tree const type = (tree) data;\n   tree var = SSA_NAME_VAR (GIMPLE_STMT_OPERAND (red->reduc_stmt, 0));\n   tree field = build_decl (FIELD_DECL, DECL_NAME (var), TREE_TYPE (var));\n \n@@ -871,8 +871,8 @@ add_field_for_reduction (void **slot, void *data)\n static int\n add_field_for_name (void **slot, void *data)\n {\n-  struct name_to_copy_elt *elt = *slot;\n-  tree type = data;\n+  struct name_to_copy_elt *const elt = (struct name_to_copy_elt *) *slot;\n+  tree type = (tree) data;\n   tree name = ssa_name (elt->version);\n   tree var = SSA_NAME_VAR (name);\n   tree field = build_decl (FIELD_DECL, DECL_NAME (var), TREE_TYPE (var));\n@@ -893,8 +893,8 @@ add_field_for_name (void **slot, void *data)\n static int\n create_phi_for_local_result (void **slot, void *data)\n {\n-  struct reduction_info *reduc = *slot;\n-  struct loop *loop = data;\n+  struct reduction_info *const reduc = (struct reduction_info *) *slot;\n+  const struct loop *const loop = (const struct loop *) data;\n   edge e;\n   tree new_phi;\n   basic_block store_bb;\n@@ -942,8 +942,8 @@ struct clsn_data\n static int\n create_call_for_reduction_1 (void **slot, void *data)\n {\n-  struct reduction_info *reduc = *slot;\n-  struct clsn_data *clsn_data = data;\n+  struct reduction_info *const reduc = (struct reduction_info *) *slot;\n+  struct clsn_data *const clsn_data = (struct clsn_data *) data;\n   block_stmt_iterator bsi;\n   tree type = TREE_TYPE (PHI_RESULT (reduc->reduc_phi));\n   tree struct_type = TREE_TYPE (TREE_TYPE (clsn_data->load));\n@@ -1013,8 +1013,8 @@ create_call_for_reduction (struct loop *loop, htab_t reduction_list,\n static int\n create_loads_for_reductions (void **slot, void *data)\n {\n-  struct reduction_info *red = *slot;\n-  struct clsn_data *clsn_data = data;\n+  struct reduction_info *const red = (struct reduction_info *) *slot;\n+  struct clsn_data *const clsn_data = (struct clsn_data *) data;\n   tree stmt;\n   block_stmt_iterator bsi;\n   tree type = TREE_TYPE (GIMPLE_STMT_OPERAND (red->reduc_stmt, 0));\n@@ -1074,8 +1074,8 @@ create_final_loads_for_reduction (htab_t reduction_list,\n static int\n create_stores_for_reduction (void **slot, void *data)\n {\n-  struct reduction_info *red = *slot;\n-  struct clsn_data *clsn_data = data;\n+  struct reduction_info *const red = (struct reduction_info *) *slot;\n+  struct clsn_data *const clsn_data = (struct clsn_data *) data;\n   tree stmt;\n   block_stmt_iterator bsi;\n   tree type = TREE_TYPE (GIMPLE_STMT_OPERAND (red->reduc_stmt, 0));\n@@ -1099,8 +1099,8 @@ create_stores_for_reduction (void **slot, void *data)\n static int\n create_loads_and_stores_for_name (void **slot, void *data)\n {\n-  struct name_to_copy_elt *elt = *slot;\n-  struct clsn_data *clsn_data = data;\n+  struct name_to_copy_elt *const elt = (struct name_to_copy_elt *) *slot;\n+  struct clsn_data *const clsn_data = (struct clsn_data *) data;\n   tree stmt;\n   block_stmt_iterator bsi;\n   tree type = TREE_TYPE (elt->new_name);"}, {"sha": "9d20b0e64c96b144bf6476cc29bcea6a8a20f4e4", "filename": "gcc/tree-phinodes.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d9a9f947fd29c85f7ed17f1b92000bff510de20/gcc%2Ftree-phinodes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d9a9f947fd29c85f7ed17f1b92000bff510de20/gcc%2Ftree-phinodes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-phinodes.c?ref=3d9a9f947fd29c85f7ed17f1b92000bff510de20", "patch": "@@ -152,7 +152,7 @@ allocate_phi_node (int len)\n     }\n   else\n     {\n-      phi = ggc_alloc (size);\n+      phi = (tree) ggc_alloc (size);\n #ifdef GATHER_STATISTICS\n       phi_nodes_created++;\n       tree_node_counts[(int) phi_kind]++;"}, {"sha": "32d7fbe00ca924368d86fd39c9722882d6a871b3", "filename": "gcc/tree-predcom.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d9a9f947fd29c85f7ed17f1b92000bff510de20/gcc%2Ftree-predcom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d9a9f947fd29c85f7ed17f1b92000bff510de20/gcc%2Ftree-predcom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-predcom.c?ref=3d9a9f947fd29c85f7ed17f1b92000bff510de20", "patch": "@@ -885,8 +885,8 @@ filter_suitable_components (struct loop *loop, struct component *comps)\n static int\n order_drefs (const void *a, const void *b)\n {\n-  const dref *da = a;\n-  const dref *db = b;\n+  const dref *const da = (const dref *) a;\n+  const dref *const db = (const dref *) b;\n   int offcmp = double_int_scmp ((*da)->offset, (*db)->offset);\n \n   if (offcmp != 0)\n@@ -1843,7 +1843,7 @@ struct epcc_data\n static void\n execute_pred_commoning_cbck (struct loop *loop, void *data)\n {\n-  struct epcc_data *dta = data;\n+  struct epcc_data *const dta = (struct epcc_data *) data;\n \n   /* Restore phi nodes that were replaced by ssa names before\n      tree_transform_and_unroll_loop (see detailed description in"}, {"sha": "69d0700b7d28ddafe1324c312b534c8d25250550", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d9a9f947fd29c85f7ed17f1b92000bff510de20/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d9a9f947fd29c85f7ed17f1b92000bff510de20/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=3d9a9f947fd29c85f7ed17f1b92000bff510de20", "patch": "@@ -487,7 +487,7 @@ sra_hash_tree (tree t)\n static hashval_t\n sra_elt_hash (const void *x)\n {\n-  const struct sra_elt *e = x;\n+  const struct sra_elt *const e = (const struct sra_elt *) x;\n   const struct sra_elt *p;\n   hashval_t h;\n \n@@ -510,8 +510,8 @@ sra_elt_hash (const void *x)\n static int\n sra_elt_eq (const void *x, const void *y)\n {\n-  const struct sra_elt *a = x;\n-  const struct sra_elt *b = y;\n+  const struct sra_elt *const a = (const struct sra_elt *) x;\n+  const struct sra_elt *const b = (const struct sra_elt *) y;\n   tree ae, be;\n   const struct sra_elt *ap = a->parent;\n   const struct sra_elt *bp = b->parent;\n@@ -592,7 +592,7 @@ lookup_element (struct sra_elt *parent, tree child, tree type,\n   elt = *slot;\n   if (!elt && insert == INSERT)\n     {\n-      *slot = elt = obstack_alloc (&sra_obstack, sizeof (*elt));\n+      *slot = elt = XOBNEW (&sra_obstack, struct sra_elt);\n       memset (elt, 0, sizeof (*elt));\n \n       elt->parent = parent;"}, {"sha": "748ff31684e88e8749021939a83e5ef43543f0fb", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d9a9f947fd29c85f7ed17f1b92000bff510de20/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d9a9f947fd29c85f7ed17f1b92000bff510de20/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=3d9a9f947fd29c85f7ed17f1b92000bff510de20", "patch": "@@ -228,7 +228,7 @@ get_mem_sym_stats_for (tree var)\n   slot = pointer_map_insert (map, var);\n   if (*slot == NULL)\n     {\n-      stats = pool_alloc (mem_sym_stats_pool);\n+      stats = (struct mem_sym_stats_d *) pool_alloc (mem_sym_stats_pool);\n       memset (stats, 0, sizeof (*stats));\n       stats->var = var;\n       *slot = (void *) stats;"}, {"sha": "388437d44bb09310dfb527b6fa962444e18aecba", "filename": "gcc/tree-ssa-coalesce.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d9a9f947fd29c85f7ed17f1b92000bff510de20/gcc%2Ftree-ssa-coalesce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d9a9f947fd29c85f7ed17f1b92000bff510de20/gcc%2Ftree-ssa-coalesce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-coalesce.c?ref=3d9a9f947fd29c85f7ed17f1b92000bff510de20", "patch": "@@ -315,8 +315,8 @@ add_coalesce (coalesce_list_p cl, int p1, int p2,\n static int \n compare_pairs (const void *p1, const void *p2)\n {\n-  const_coalesce_pair_p const * pp1 = p1;\n-  const_coalesce_pair_p const * pp2 = p2;\n+  const_coalesce_pair_p const *const pp1 = (const_coalesce_pair_p const *) p1;\n+  const_coalesce_pair_p const *const pp2 = (const_coalesce_pair_p const *) p2;\n   int result;\n \n   result = (* pp2)->cost - (* pp1)->cost;"}, {"sha": "899eb8ab1a9ed2d465e58d3f24d12acfcca82cec", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d9a9f947fd29c85f7ed17f1b92000bff510de20/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d9a9f947fd29c85f7ed17f1b92000bff510de20/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=3d9a9f947fd29c85f7ed17f1b92000bff510de20", "patch": "@@ -619,7 +619,7 @@ mem_ref_in_stmt (tree stmt)\n   gcc_assert (!store);\n \n   hash = iterative_hash_expr (*mem, 0);\n-  ref = htab_find_with_hash (memory_accesses.refs, *mem, hash);\n+  ref = (mem_ref_p) htab_find_with_hash (memory_accesses.refs, *mem, hash);\n \n   gcc_assert (ref != NULL);\n   return ref;\n@@ -1165,7 +1165,7 @@ force_move_till (tree ref, tree *index, void *data)\n static hashval_t\n memref_hash (const void *obj)\n {\n-  const struct mem_ref *mem = obj;\n+  const struct mem_ref *const mem = (const struct mem_ref *) obj;\n \n   return mem->hash;\n }\n@@ -1176,9 +1176,9 @@ memref_hash (const void *obj)\n static int\n memref_eq (const void *obj1, const void *obj2)\n {\n-  const struct mem_ref *mem1 = obj1;\n+  const struct mem_ref *const mem1 = (const struct mem_ref *) obj1;\n \n-  return operand_equal_p (mem1->mem, (tree) obj2, 0);\n+  return operand_equal_p (mem1->mem, (const_tree) obj2, 0);\n }\n \n /* Releases list of memory reference locations ACCS.  */\n@@ -1203,7 +1203,7 @@ free_mem_ref_locs (mem_ref_locs_p accs)\n static void\n memref_free (void *obj)\n {\n-  struct mem_ref *mem = obj;\n+  struct mem_ref *const mem = (struct mem_ref *) obj;\n   unsigned i;\n   mem_ref_locs_p accs;\n \n@@ -1322,7 +1322,7 @@ gather_mem_refs_stmt (struct loop *loop, tree stmt)\n \n   if (*slot)\n     {\n-      ref = *slot;\n+      ref = (mem_ref_p) *slot;\n       id = ref->id;\n     }\n   else\n@@ -1416,7 +1416,8 @@ struct vop_to_refs_elt\n static hashval_t\n vtoe_hash (const void *obj)\n {\n-  const struct vop_to_refs_elt *vtoe = obj;\n+  const struct vop_to_refs_elt *const vtoe =\n+    (const struct vop_to_refs_elt *) obj;\n \n   return vtoe->uid;\n }\n@@ -1427,8 +1428,9 @@ vtoe_hash (const void *obj)\n static int\n vtoe_eq (const void *obj1, const void *obj2)\n {\n-  const struct vop_to_refs_elt *vtoe = obj1;\n-  const unsigned *uid = obj2;\n+  const struct vop_to_refs_elt *const vtoe =\n+    (const struct vop_to_refs_elt *) obj1;\n+  const unsigned *const uid = (const unsigned *) obj2;\n \n   return vtoe->uid == *uid;\n }\n@@ -1438,7 +1440,8 @@ vtoe_eq (const void *obj1, const void *obj2)\n static void\n vtoe_free (void *obj)\n {\n-  struct vop_to_refs_elt *vtoe = obj;\n+  struct vop_to_refs_elt *const vtoe =\n+    (struct vop_to_refs_elt *) obj;\n \n   BITMAP_FREE (vtoe->refs_all);\n   BITMAP_FREE (vtoe->refs_stored);\n@@ -1463,7 +1466,7 @@ record_vop_access (htab_t vop_to_refs, unsigned vop, unsigned ref, bool stored)\n       *slot = vtoe;\n     }\n   else\n-    vtoe = *slot;\n+    vtoe = (struct vop_to_refs_elt *) *slot;\n \n   bitmap_set_bit (vtoe->refs_all, ref);\n   if (stored)\n@@ -1476,7 +1479,8 @@ record_vop_access (htab_t vop_to_refs, unsigned vop, unsigned ref, bool stored)\n static bitmap\n get_vop_accesses (htab_t vop_to_refs, unsigned vop)\n {\n-  struct vop_to_refs_elt *vtoe = htab_find_with_hash (vop_to_refs, &vop, vop);\n+  struct vop_to_refs_elt *const vtoe =\n+    (struct vop_to_refs_elt *) htab_find_with_hash (vop_to_refs, &vop, vop);\n   return vtoe->refs_all;\n }\n \n@@ -1486,7 +1490,8 @@ get_vop_accesses (htab_t vop_to_refs, unsigned vop)\n static bitmap\n get_vop_stores (htab_t vop_to_refs, unsigned vop)\n {\n-  struct vop_to_refs_elt *vtoe = htab_find_with_hash (vop_to_refs, &vop, vop);\n+  struct vop_to_refs_elt *const vtoe =\n+    (struct vop_to_refs_elt *) htab_find_with_hash (vop_to_refs, &vop, vop);\n   return vtoe->refs_stored;\n }\n "}, {"sha": "651ccbb5227bad292f2ffbb5e7ada2654f64cbe9", "filename": "gcc/tree-ssa-loop-prefetch.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d9a9f947fd29c85f7ed17f1b92000bff510de20/gcc%2Ftree-ssa-loop-prefetch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d9a9f947fd29c85f7ed17f1b92000bff510de20/gcc%2Ftree-ssa-loop-prefetch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-prefetch.c?ref=3d9a9f947fd29c85f7ed17f1b92000bff510de20", "patch": "@@ -1355,7 +1355,7 @@ determine_loop_nest_reuse (struct loop *loop, struct mem_ref_group *refs,\n   for (i = 0; VEC_iterate (data_reference_p, datarefs, i, dr); i++)\n     {\n       dist = self_reuse_distance (dr, loop_data_size, n, loop);\n-      ref = dr->aux;\n+      ref = (struct mem_ref *) dr->aux;\n       if (ref->reuse_distance > dist)\n \tref->reuse_distance = dist;\n \n@@ -1370,8 +1370,8 @@ determine_loop_nest_reuse (struct loop *loop, struct mem_ref_group *refs,\n       if (DDR_ARE_DEPENDENT (dep) == chrec_known)\n \tcontinue;\n \n-      ref = DDR_A (dep)->aux;\n-      refb = DDR_B (dep)->aux;\n+      ref = (struct mem_ref *) DDR_A (dep)->aux;\n+      refb = (struct mem_ref *) DDR_B (dep)->aux;\n \n       if (DDR_ARE_DEPENDENT (dep) == chrec_dont_know\n \t  || DDR_NUM_DIST_VECTS (dep) == 0)"}, {"sha": "99cc08d844518867cdc77726ee19e7d1f85e610f", "filename": "gcc/tree-ssa-sccvn.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d9a9f947fd29c85f7ed17f1b92000bff510de20/gcc%2Ftree-ssa-sccvn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d9a9f947fd29c85f7ed17f1b92000bff510de20/gcc%2Ftree-ssa-sccvn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.c?ref=3d9a9f947fd29c85f7ed17f1b92000bff510de20", "patch": "@@ -261,7 +261,7 @@ VN_INFO_GET (tree name)\n {\n   vn_ssa_aux_t newinfo;\n \n-  newinfo = obstack_alloc (&vn_ssa_aux_obstack, sizeof (struct vn_ssa_aux));\n+  newinfo = XOBNEW (&vn_ssa_aux_obstack, struct vn_ssa_aux);\n   memset (newinfo, 0, sizeof (struct vn_ssa_aux));\n   if (SSA_NAME_VERSION (name) >= VEC_length (vn_ssa_aux_t, vn_ssa_aux_table))\n     VEC_safe_grow (vn_ssa_aux_t, heap, vn_ssa_aux_table,\n@@ -277,7 +277,7 @@ VN_INFO_GET (tree name)\n static void\n free_phi (void *vp)\n {\n-  vn_phi_t phi = vp;\n+  vn_phi_t phi = (vn_phi_t) vp;\n   VEC_free (tree, heap, phi->phiargs);\n }\n \n@@ -286,7 +286,7 @@ free_phi (void *vp)\n static void\n free_reference (void *vp)\n {\n-  vn_reference_t vr = vp;\n+  vn_reference_t vr = (vn_reference_t) vp;\n   VEC_free (vn_reference_op_s, heap, vr->operands);\n }\n \n@@ -921,7 +921,7 @@ vn_nary_op_insert (tree op, tree result)\n   vn_nary_op_t vno1;\n   unsigned i;\n \n-  vno1 = obstack_alloc (&current_info->nary_obstack,\n+  vno1 = (vn_nary_op_t) obstack_alloc (&current_info->nary_obstack,\n \t\t\t(sizeof (struct vn_nary_op_s)\n \t\t\t - sizeof (tree) * (4 - length)));\n   vno1->opcode = TREE_CODE (op);"}, {"sha": "5a7446482719bbf0a347619227adcd39512c1947", "filename": "gcc/tree-ssa.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d9a9f947fd29c85f7ed17f1b92000bff510de20/gcc%2Ftree-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d9a9f947fd29c85f7ed17f1b92000bff510de20/gcc%2Ftree-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.c?ref=3d9a9f947fd29c85f7ed17f1b92000bff510de20", "patch": "@@ -63,7 +63,7 @@ redirect_edge_var_map_add (edge e, tree result, tree def)\n     edge_var_maps = pointer_map_create ();\n \n   slot = pointer_map_insert (edge_var_maps, e);\n-  old_head = head = *slot;\n+  old_head = head = (edge_var_map_vector) *slot;\n   if (!head)\n     {\n       head = VEC_alloc (edge_var_map, heap, 5);\n@@ -96,7 +96,7 @@ redirect_edge_var_map_clear (edge e)\n \n   if (slot)\n     {\n-      head = *slot;\n+      head = (edge_var_map_vector) *slot;\n       VEC_free (edge_var_map, heap, head);\n       *slot = NULL;\n     }\n@@ -121,7 +121,7 @@ redirect_edge_var_map_dup (edge newe, edge olde)\n   old_slot = pointer_map_contains (edge_var_maps, olde);\n   if (!old_slot)\n     return;\n-  head = *old_slot;\n+  head = (edge_var_map_vector) *old_slot;\n \n   if (head)\n     *new_slot = VEC_copy (edge_var_map, heap, head);"}, {"sha": "5bfa30b21d4b92421c76d3abd6d2893056c5d8bf", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d9a9f947fd29c85f7ed17f1b92000bff510de20/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d9a9f947fd29c85f7ed17f1b92000bff510de20/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=3d9a9f947fd29c85f7ed17f1b92000bff510de20", "patch": "@@ -2712,7 +2712,7 @@ vectorize_loops (void)\n       loop = get_loop (i);\n       if (!loop)\n \tcontinue;\n-      loop_vinfo = loop->aux;\n+      loop_vinfo = (loop_vec_info) loop->aux;\n       destroy_loop_vec_info (loop_vinfo, true);\n       loop->aux = NULL;\n     }"}, {"sha": "469555a8739ffcbffe2f307d5a4b9db93afe7e91", "filename": "gcc/tree.c", "status": "modified", "additions": 38, "deletions": 32, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d9a9f947fd29c85f7ed17f1b92000bff510de20/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d9a9f947fd29c85f7ed17f1b92000bff510de20/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=3d9a9f947fd29c85f7ed17f1b92000bff510de20", "patch": "@@ -569,9 +569,9 @@ make_node_stat (enum tree_code code MEM_STAT_DECL)\n #endif\n \n   if (code == IDENTIFIER_NODE)\n-    t = ggc_alloc_zone_pass_stat (length, &tree_id_zone);\n+    t = (tree) ggc_alloc_zone_pass_stat (length, &tree_id_zone);\n   else\n-    t = ggc_alloc_zone_pass_stat (length, &tree_zone);\n+    t = (tree) ggc_alloc_zone_pass_stat (length, &tree_zone);\n \n   memset (t, 0, length);\n \n@@ -674,7 +674,7 @@ copy_node_stat (tree node MEM_STAT_DECL)\n   gcc_assert (code != STATEMENT_LIST);\n \n   length = tree_size (node);\n-  t = ggc_alloc_zone_pass_stat (length, &tree_zone);\n+  t = (tree) ggc_alloc_zone_pass_stat (length, &tree_zone);\n   memcpy (t, node, length);\n \n   if (!GIMPLE_TUPLE_P (node))\n@@ -928,7 +928,7 @@ build_int_cst_wide (tree type, unsigned HOST_WIDE_INT low, HOST_WIDE_INT hi)\n       TREE_TYPE (int_cst_node) = type;\n \n       slot = htab_find_slot (int_cst_hash_table, int_cst_node, INSERT);\n-      t = *slot;\n+      t = (tree) *slot;\n       if (!t)\n \t{\n \t  /* Insert this one into the hash table.  */\n@@ -1104,7 +1104,7 @@ build_fixed (tree type, FIXED_VALUE_TYPE f)\n   FIXED_VALUE_TYPE *fp;\n \n   v = make_node (FIXED_CST);\n-  fp = ggc_alloc (sizeof (FIXED_VALUE_TYPE));\n+  fp = GGC_NEW (FIXED_VALUE_TYPE);\n   memcpy (fp, &f, sizeof (FIXED_VALUE_TYPE));\n \n   TREE_TYPE (v) = type;\n@@ -1125,7 +1125,7 @@ build_real (tree type, REAL_VALUE_TYPE d)\n      Consider doing it via real_convert now.  */\n \n   v = make_node (REAL_CST);\n-  dp = ggc_alloc (sizeof (REAL_VALUE_TYPE));\n+  dp = GGC_NEW (REAL_VALUE_TYPE);\n   memcpy (dp, &d, sizeof (REAL_VALUE_TYPE));\n \n   TREE_TYPE (v) = type;\n@@ -1274,7 +1274,7 @@ make_tree_binfo_stat (unsigned base_binfos MEM_STAT_DECL)\n   tree_node_sizes[(int) binfo_kind] += length;\n #endif\n \n-  t = ggc_alloc_zone_pass_stat (length, &tree_zone);\n+  t = (tree) ggc_alloc_zone_pass_stat (length, &tree_zone);\n \n   memset (t, 0, offsetof (struct tree_binfo, base_binfos));\n \n@@ -1299,7 +1299,7 @@ make_tree_vec_stat (int len MEM_STAT_DECL)\n   tree_node_sizes[(int) vec_kind] += length;\n #endif\n \n-  t = ggc_alloc_zone_pass_stat (length, &tree_zone);\n+  t = (tree) ggc_alloc_zone_pass_stat (length, &tree_zone);\n \n   memset (t, 0, length);\n \n@@ -1773,7 +1773,7 @@ tree_cons_stat (tree purpose, tree value, tree chain MEM_STAT_DECL)\n {\n   tree node;\n \n-  node = ggc_alloc_zone_pass_stat (sizeof (struct tree_list), &tree_zone);\n+  node = (tree) ggc_alloc_zone_pass_stat (sizeof (struct tree_list), &tree_zone);\n \n   memset (node, 0, sizeof (struct tree_common));\n \n@@ -3097,7 +3097,7 @@ build1_stat (enum tree_code code, tree type, tree node MEM_STAT_DECL)\n \n   gcc_assert (TREE_CODE_LENGTH (code) == 1);\n \n-  t = ggc_alloc_zone_pass_stat (length, &tree_zone);\n+  t = (tree) ggc_alloc_zone_pass_stat (length, &tree_zone);\n \n   memset (t, 0, sizeof (struct tree_common));\n \n@@ -4275,7 +4275,8 @@ build_variant_type_copy (tree type)\n int\n tree_map_base_eq (const void *va, const void *vb)\n {\n-  const struct tree_map_base  *const a = va, *const b = vb;\n+  const struct tree_map_base  *const a = (const struct tree_map_base *) va,\n+    *const b = (const struct tree_map_base *) vb;\n   return (a->from == b->from);\n }\n \n@@ -4313,7 +4314,7 @@ decl_init_priority_lookup (tree decl)\n \n   gcc_assert (VAR_OR_FUNCTION_DECL_P (decl));\n   in.from = decl;\n-  h = htab_find (init_priority_for_decl, &in);\n+  h = (struct tree_priority_map *) htab_find (init_priority_for_decl, &in);\n   return h ? h->init : DEFAULT_INIT_PRIORITY;\n }\n \n@@ -4327,7 +4328,7 @@ decl_fini_priority_lookup (tree decl)\n \n   gcc_assert (TREE_CODE (decl) == FUNCTION_DECL);\n   in.from = decl;\n-  h = htab_find (init_priority_for_decl, &in);\n+  h = (struct tree_priority_map *) htab_find (init_priority_for_decl, &in);\n   return h ? h->fini : DEFAULT_INIT_PRIORITY;\n }\n \n@@ -4344,7 +4345,7 @@ decl_priority_info (tree decl)\n \n   in.base.from = decl;\n   loc = htab_find_slot (init_priority_for_decl, &in, INSERT);\n-  h = *loc;\n+  h = (struct tree_priority_map *) *loc;\n   if (!h)\n     {\n       h = GGC_CNEW (struct tree_priority_map);\n@@ -4390,8 +4391,8 @@ decl_restrict_base_lookup (tree from)\n   struct tree_map in;\n \n   in.base.from = from;\n-  h = htab_find_with_hash (restrict_base_for_decl, &in,\n-\t\t\t   htab_hash_pointer (from));\n+  h = (struct tree_map *) htab_find_with_hash (restrict_base_for_decl, &in,\n+\t\t\t\t\t       htab_hash_pointer (from));\n   return h ? h->to : NULL_TREE;\n }\n \n@@ -4403,7 +4404,7 @@ decl_restrict_base_insert (tree from, tree to)\n   struct tree_map *h;\n   void **loc;\n \n-  h = ggc_alloc (sizeof (struct tree_map));\n+  h = GGC_NEW (struct tree_map);\n   h->hash = htab_hash_pointer (from);\n   h->base.from = from;\n   h->to = to;\n@@ -4455,7 +4456,8 @@ decl_debug_expr_lookup (tree from)\n   struct tree_map *h, in;\n   in.base.from = from;\n \n-  h = htab_find_with_hash (debug_expr_for_decl, &in, htab_hash_pointer (from));\n+  h = (struct tree_map *) htab_find_with_hash (debug_expr_for_decl, &in,\n+\t\t\t\t\t       htab_hash_pointer (from));\n   if (h)\n     return h->to;\n   return NULL_TREE;\n@@ -4469,7 +4471,7 @@ decl_debug_expr_insert (tree from, tree to)\n   struct tree_map *h;\n   void **loc;\n \n-  h = ggc_alloc (sizeof (struct tree_map));\n+  h = GGC_NEW (struct tree_map);\n   h->hash = htab_hash_pointer (from);\n   h->base.from = from;\n   h->to = to;\n@@ -4485,7 +4487,8 @@ decl_value_expr_lookup (tree from)\n   struct tree_map *h, in;\n   in.base.from = from;\n \n-  h = htab_find_with_hash (value_expr_for_decl, &in, htab_hash_pointer (from));\n+  h = (struct tree_map *) htab_find_with_hash (value_expr_for_decl, &in,\n+\t\t\t\t\t       htab_hash_pointer (from));\n   if (h)\n     return h->to;\n   return NULL_TREE;\n@@ -4499,7 +4502,7 @@ decl_value_expr_insert (tree from, tree to)\n   struct tree_map *h;\n   void **loc;\n \n-  h = ggc_alloc (sizeof (struct tree_map));\n+  h = GGC_NEW (struct tree_map);\n   h->hash = htab_hash_pointer (from);\n   h->base.from = from;\n   h->to = to;\n@@ -4534,7 +4537,8 @@ type_hash_list (const_tree list, hashval_t hashcode)\n static int\n type_hash_eq (const void *va, const void *vb)\n {\n-  const struct type_hash *const a = va, *const b = vb;\n+  const struct type_hash *const a = (const struct type_hash *) va,\n+    *const b = (const struct type_hash *) vb;\n \n   /* First test the things that are the same for all types.  */\n   if (a->hash != b->hash\n@@ -4653,7 +4657,8 @@ type_hash_lookup (hashval_t hashcode, tree type)\n   in.hash = hashcode;\n   in.type = type;\n \n-  h = htab_find_with_hash (type_hash_table, &in, hashcode);\n+  h = (struct type_hash *) htab_find_with_hash (type_hash_table, &in,\n+\t\t\t\t\t\thashcode);\n   if (h)\n     return h->type;\n   return NULL_TREE;\n@@ -4668,7 +4673,7 @@ type_hash_add (hashval_t hashcode, tree type)\n   struct type_hash *h;\n   void **loc;\n \n-  h = ggc_alloc (sizeof (struct type_hash));\n+  h = GGC_NEW (struct type_hash);\n   h->hash = hashcode;\n   h->type = type;\n   loc = htab_find_slot_with_hash (type_hash_table, h, hashcode, INSERT);\n@@ -6703,7 +6708,7 @@ get_file_function_name (const char *type)\n \tfile = input_filename;\n \n       len = strlen (file);\n-      q = alloca (9 * 2 + len + 1);\n+      q = (char *) alloca (9 * 2 + len + 1);\n       memcpy (q, file, len + 1);\n       clean_symbol_name (q);\n \n@@ -6713,7 +6718,8 @@ get_file_function_name (const char *type)\n       p = q;\n     }\n \n-  buf = alloca (sizeof (FILE_FUNCTION_FORMAT) + strlen (p) + strlen (type));\n+  buf = (char *) alloca (sizeof (FILE_FUNCTION_FORMAT) + strlen (p)\n+\t\t\t + strlen (type));\n \n   /* Set up the name of the file-level functions we may need.\n      Use a global object (which is already required to be unique over\n@@ -6749,7 +6755,7 @@ tree_check_failed (const_tree node, const char *file,\n       char *tmp;\n       va_start (args, function);\n       length += strlen (\"expected \");\n-      buffer = tmp = alloca (length);\n+      buffer = tmp = (char *) alloca (length);\n       length = 0;\n       while ((code = va_arg (args, int)))\n \t{\n@@ -6788,7 +6794,7 @@ tree_not_check_failed (const_tree node, const char *file,\n     length += 4 + strlen (tree_code_name[code]);\n   va_end (args);\n   va_start (args, function);\n-  buffer = alloca (length);\n+  buffer = (char *) alloca (length);\n   length = 0;\n   while ((code = va_arg (args, int)))\n     {\n@@ -6837,7 +6843,7 @@ tree_range_check_failed (const_tree node, const char *file, int line,\n     length += 4 + strlen (tree_code_name[c]);\n \n   length += strlen (\"expected \");\n-  buffer = alloca (length);\n+  buffer = (char *) alloca (length);\n   length = 0;\n \n   for (c = c1; c <= c2; ++c)\n@@ -6898,7 +6904,7 @@ omp_clause_range_check_failed (const_tree node, const char *file, int line,\n     length += 4 + strlen (omp_clause_code_name[c]);\n \n   length += strlen (\"expected \");\n-  buffer = alloca (length);\n+  buffer = (char *) alloca (length);\n   length = 0;\n \n   for (c = c1; c <= c2; ++c)\n@@ -7720,7 +7726,7 @@ build_omp_clause (enum omp_clause_code code)\n   length = omp_clause_num_ops[code];\n   size = (sizeof (struct tree_omp_clause) + (length - 1) * sizeof (tree));\n \n-  t = ggc_alloc (size);\n+  t = GGC_NEWVAR (union tree_node, size);\n   memset (t, 0, size);\n   TREE_SET_CODE (t, OMP_CLAUSE);\n   OMP_CLAUSE_SET_CODE (t, code);\n@@ -7787,7 +7793,7 @@ build_vl_exp_stat (enum tree_code code, int len MEM_STAT_DECL)\n   tree_node_sizes[(int) e_kind] += length;\n #endif\n \n-  t = ggc_alloc_zone_pass_stat (length, &tree_zone);\n+  t = (tree) ggc_alloc_zone_pass_stat (length, &tree_zone);\n \n   memset (t, 0, length);\n "}, {"sha": "a16e7d483780436ef2626937d19eac2ca139fdf3", "filename": "gcc/value-prof.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d9a9f947fd29c85f7ed17f1b92000bff510de20/gcc%2Fvalue-prof.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d9a9f947fd29c85f7ed17f1b92000bff510de20/gcc%2Fvalue-prof.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.c?ref=3d9a9f947fd29c85f7ed17f1b92000bff510de20", "patch": "@@ -148,8 +148,8 @@ gimple_histogram_value (struct function *fun, tree stmt)\n {\n   if (!VALUE_HISTOGRAMS (fun))\n     return NULL;\n-  return htab_find_with_hash (VALUE_HISTOGRAMS (fun), stmt,\n-                              htab_hash_pointer (stmt));\n+  return (histogram_value) htab_find_with_hash (VALUE_HISTOGRAMS (fun), stmt,\n+\t\t\t\t\t\thtab_hash_pointer (stmt));\n }\n \n /* Add histogram for STMT.  */\n@@ -331,7 +331,7 @@ gimple_duplicate_stmt_histograms (struct function *fun, tree stmt,\n       histogram_value new = gimple_alloc_histogram_value (fun, val->type, NULL, NULL);\n       memcpy (new, val, sizeof (*val));\n       new->hvalue.stmt = stmt;\n-      new->hvalue.counters = xmalloc (sizeof (*new->hvalue.counters) * new->n_counters);\n+      new->hvalue.counters = XNEWVAR (gcov_type, sizeof (*new->hvalue.counters) * new->n_counters);\n       memcpy (new->hvalue.counters, val->hvalue.counters, sizeof (*new->hvalue.counters) * new->n_counters);\n       gimple_add_histogram_value (fun, stmt, new);\n     }"}, {"sha": "ab4d93cb76b89298a9cfc2aa019a5e84f65d71bf", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 19, "deletions": 17, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d9a9f947fd29c85f7ed17f1b92000bff510de20/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d9a9f947fd29c85f7ed17f1b92000bff510de20/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=3d9a9f947fd29c85f7ed17f1b92000bff510de20", "patch": "@@ -693,7 +693,7 @@ attrs_list_insert (attrs *listp, tree decl, HOST_WIDE_INT offset, rtx loc)\n {\n   attrs list;\n \n-  list = pool_alloc (attrs_pool);\n+  list = (attrs) pool_alloc (attrs_pool);\n   list->loc = loc;\n   list->decl = decl;\n   list->offset = offset;\n@@ -711,7 +711,7 @@ attrs_list_copy (attrs *dstp, attrs src)\n   attrs_list_clear (dstp);\n   for (; src; src = src->next)\n     {\n-      n = pool_alloc (attrs_pool);\n+      n = (attrs) pool_alloc (attrs_pool);\n       n->loc = src->loc;\n       n->decl = src->decl;\n       n->offset = src->offset;\n@@ -750,7 +750,7 @@ unshare_variable (dataflow_set *set, variable var,\n   variable new_var;\n   int i;\n \n-  new_var = pool_alloc (var_pool);\n+  new_var = (variable) pool_alloc (var_pool);\n   new_var->decl = var->decl;\n   new_var->refcount = 1;\n   var->refcount--;\n@@ -767,7 +767,7 @@ unshare_variable (dataflow_set *set, variable var,\n \t{\n \t  location_chain new_lc;\n \n-\t  new_lc = pool_alloc (loc_chain_pool);\n+\t  new_lc = (location_chain) pool_alloc (loc_chain_pool);\n \t  new_lc->next = NULL;\n \t  if (node->init > initialized)\n \t    new_lc->init = node->init;\n@@ -1095,8 +1095,10 @@ struct variable_union_info\n static int\n variable_union_info_cmp_pos (const void *n1, const void *n2)\n {\n-  const struct variable_union_info *i1 = n1;\n-  const struct variable_union_info *i2 = n2;\n+  const struct variable_union_info *const i1 =\n+    (const struct variable_union_info *) n1;\n+  const struct variable_union_info *const i2 =\n+    ( const struct variable_union_info *) n2;\n \n   if (i1->pos != i2->pos)\n     return i1->pos - i2->pos;\n@@ -1275,7 +1277,7 @@ variable_union (void **slot, void *data)\n \t\t  location_chain new_node;\n \n \t\t  /* Copy the location from SRC.  */\n-\t\t  new_node = pool_alloc (loc_chain_pool);\n+\t\t  new_node = (location_chain) pool_alloc (loc_chain_pool);\n \t\t  new_node->loc = node->loc;\n \t\t  new_node->init = node->init;\n \t\t  if (!node->set_src || MEM_P (node->set_src))\n@@ -1326,7 +1328,7 @@ variable_union (void **slot, void *data)\n \t    {\n \t      location_chain new_lc;\n \n-\t      new_lc = pool_alloc (loc_chain_pool);\n+\t      new_lc = (location_chain) pool_alloc (loc_chain_pool);\n \t      new_lc->next = NULL;\n \t      new_lc->init = node->init;\n \t      if (!node->set_src || MEM_P (node->set_src))\n@@ -1455,7 +1457,7 @@ dataflow_set_different_1 (void **slot, void *data)\n   variable var1, var2;\n \n   var1 = *(variable *) slot;\n-  var2 = htab_find_with_hash (htab, var1->decl,\n+  var2 = (variable) htab_find_with_hash (htab, var1->decl,\n \t\t\t      VARIABLE_HASH_VAL (var1->decl));\n   if (!var2)\n     {\n@@ -1487,7 +1489,7 @@ dataflow_set_different_2 (void **slot, void *data)\n   variable var1, var2;\n \n   var1 = *(variable *) slot;\n-  var2 = htab_find_with_hash (htab, var1->decl,\n+  var2 = (variable) htab_find_with_hash (htab, var1->decl,\n \t\t\t      VARIABLE_HASH_VAL (var1->decl));\n   if (!var2)\n     {\n@@ -2177,7 +2179,7 @@ vt_find_locations (void)\n \n       while (!fibheap_empty (worklist))\n \t{\n-\t  bb = fibheap_extract_min (worklist);\n+\t  bb = (basic_block) fibheap_extract_min (worklist);\n \t  RESET_BIT (in_worklist, bb->index);\n \t  if (!TEST_BIT (visited, bb->index))\n \t    {\n@@ -2352,7 +2354,7 @@ variable_was_changed (variable var, htab_t htab)\n \t  variable empty_var;\n \t  void **old;\n \n-\t  empty_var = pool_alloc (var_pool);\n+\t  empty_var = (variable) pool_alloc (var_pool);\n \t  empty_var->decl = var->decl;\n \t  empty_var->refcount = 1;\n \t  empty_var->n_var_parts = 0;\n@@ -2433,7 +2435,7 @@ set_variable_part (dataflow_set *set, rtx loc, tree decl, HOST_WIDE_INT offset,\n   if (!*slot)\n     {\n       /* Create new variable information.  */\n-      var = pool_alloc (var_pool);\n+      var = (variable) pool_alloc (var_pool);\n       var->decl = decl;\n       var->refcount = 1;\n       var->n_var_parts = 1;\n@@ -2525,7 +2527,7 @@ set_variable_part (dataflow_set *set, rtx loc, tree decl, HOST_WIDE_INT offset,\n     }\n \n   /* Add the location to the beginning.  */\n-  node = pool_alloc (loc_chain_pool);\n+  node = (location_chain) pool_alloc (loc_chain_pool);\n   node->loc = loc;\n   node->init = initialized;\n   node->set_src = set_src;\n@@ -2888,15 +2890,15 @@ emit_notes_for_differences_1 (void **slot, void *data)\n   variable old_var, new_var;\n \n   old_var = *(variable *) slot;\n-  new_var = htab_find_with_hash (new_vars, old_var->decl,\n+  new_var = (variable) htab_find_with_hash (new_vars, old_var->decl,\n \t\t\t\t VARIABLE_HASH_VAL (old_var->decl));\n \n   if (!new_var)\n     {\n       /* Variable has disappeared.  */\n       variable empty_var;\n \n-      empty_var = pool_alloc (var_pool);\n+      empty_var = (variable) pool_alloc (var_pool);\n       empty_var->decl = old_var->decl;\n       empty_var->refcount = 1;\n       empty_var->n_var_parts = 0;\n@@ -2921,7 +2923,7 @@ emit_notes_for_differences_2 (void **slot, void *data)\n   variable old_var, new_var;\n \n   new_var = *(variable *) slot;\n-  old_var = htab_find_with_hash (old_vars, new_var->decl,\n+  old_var = (variable) htab_find_with_hash (old_vars, new_var->decl,\n \t\t\t\t VARIABLE_HASH_VAL (new_var->decl));\n   if (!old_var)\n     {"}, {"sha": "f8390a43bc878c839976f248cf1188c00cc1069c", "filename": "gcc/varasm.c", "status": "modified", "additions": 35, "deletions": 29, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d9a9f947fd29c85f7ed17f1b92000bff510de20/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d9a9f947fd29c85f7ed17f1b92000bff510de20/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=3d9a9f947fd29c85f7ed17f1b92000bff510de20", "patch": "@@ -216,7 +216,7 @@ prefix_name (const char *prefix, tree name)\n {\n   unsigned plen = strlen (prefix);\n   unsigned nlen = strlen (IDENTIFIER_POINTER (name));\n-  char *toname = alloca (plen + nlen + 1);\n+  char *toname = (char *) alloca (plen + nlen + 1);\n   \n   memcpy (toname, prefix, plen);\n   memcpy (toname + plen, IDENTIFIER_POINTER (name), nlen + 1);\n@@ -366,15 +366,15 @@ emutls_decl (tree decl)\n   in.hash = htab_hash_string (IDENTIFIER_POINTER (name));\n   in.base.from = decl;\n   loc = htab_find_slot_with_hash (emutls_htab, &in, in.hash, INSERT);\n-  h = *loc;\n+  h = (struct tree_map *) *loc;\n   if (h != NULL)\n     to = h->to;\n   else\n     {\n       to = build_decl (VAR_DECL, get_emutls_object_name (name),\n \t\t       get_emutls_object_type ());\n \n-      h = ggc_alloc (sizeof (struct tree_map));\n+      h = GGC_NEW (struct tree_map);\n       h->hash = in.hash;\n       h->base.from = decl;\n       h->to = to;\n@@ -469,16 +469,16 @@ emutls_finish (void)\n static int\n section_entry_eq (const void *p1, const void *p2)\n {\n-  const section *old = p1;\n-  const char *new = p2;\n+  const section *old = (const section *) p1;\n+  const char *new = (const char *) p2;\n \n   return strcmp (old->named.name, new) == 0;\n }\n \n static hashval_t\n section_entry_hash (const void *p)\n {\n-  const section *old = p;\n+  const section *old = (const section *) p;\n   return htab_hash_string (old->named.name);\n }\n \n@@ -497,16 +497,16 @@ hash_section (section *sect)\n static int\n object_block_entry_eq (const void *p1, const void *p2)\n {\n-  const struct object_block *old = p1;\n-  const section *new = p2;\n+  const struct object_block *old = (const struct object_block *) p1;\n+  const section *new = (const section *) p2;\n \n   return old->sect == new;\n }\n \n static hashval_t\n object_block_entry_hash (const void *p)\n {\n-  const struct object_block *old = p;\n+  const struct object_block *old = (const struct object_block *) p;\n   return hash_section (old->sect);\n }\n \n@@ -626,7 +626,7 @@ create_block_symbol (const char *label, struct object_block *block,\n \n   /* Create the extended SYMBOL_REF.  */\n   size = RTX_HDR_SIZE + sizeof (struct block_symbol);\n-  symbol = ggc_alloc_zone (size, &rtl_zone);\n+  symbol = (rtx) ggc_alloc_zone (size, &rtl_zone);\n \n   /* Initialize the normal SYMBOL_REF fields.  */\n   memset (symbol, 0, size);\n@@ -656,7 +656,7 @@ initialize_cold_section_name (void)\n   dsn = DECL_SECTION_NAME (current_function_decl);\n   if (flag_function_sections && dsn)\n     {\n-      name = alloca (TREE_STRING_LENGTH (dsn) + 1);\n+      name = (char *) alloca (TREE_STRING_LENGTH (dsn) + 1);\n       memcpy (name, TREE_STRING_POINTER (dsn), TREE_STRING_LENGTH (dsn) + 1);\n \n       stripped_name = targetm.strip_name_encoding (name);\n@@ -870,7 +870,7 @@ default_function_rodata_section (tree decl)\n       if (DECL_ONE_ONLY (decl) && HAVE_COMDAT_GROUP)\n         {\n \t  size_t len = strlen (name) + 3;\n-\t  char* rname = alloca (len);\n+\t  char* rname = (char *) alloca (len);\n \n \t  strcpy (rname, \".rodata\");\n \t  strcat (rname, name + 5);\n@@ -881,7 +881,7 @@ default_function_rodata_section (tree decl)\n \t       && strncmp (name, \".gnu.linkonce.t.\", 16) == 0)\n \t{\n \t  size_t len = strlen (name) + 1;\n-\t  char *rname = alloca (len);\n+\t  char *rname = (char *) alloca (len);\n \n \t  memcpy (rname, name, len);\n \t  rname[14] = 'r';\n@@ -892,7 +892,7 @@ default_function_rodata_section (tree decl)\n \t       && strncmp (name, \".text.\", 6) == 0)\n \t{\n \t  size_t len = strlen (name) + 1;\n-\t  char *rname = alloca (len + 2);\n+\t  char *rname = (char *) alloca (len + 2);\n \n \t  memcpy (rname, \".rodata\", 7);\n \t  memcpy (rname + 7, name + 5, len - 5);\n@@ -1015,7 +1015,7 @@ strip_reg_name (const char *name)\n void\n set_user_assembler_name (tree decl, const char *name)\n {\n-  char *starred = alloca (strlen (name) + 2);\n+  char *starred = (char *) alloca (strlen (name) + 2);\n   starred[0] = '*';\n   strcpy (starred + 1, name);\n   change_decl_assembler_name (decl, get_identifier (starred));\n@@ -2887,8 +2887,10 @@ const_hash_1 (const tree exp)\n static int\n const_desc_eq (const void *p1, const void *p2)\n {\n-  const struct constant_descriptor_tree *c1 = p1;\n-  const struct constant_descriptor_tree *c2 = p2;\n+  const struct constant_descriptor_tree *const c1\n+    = (const struct constant_descriptor_tree *) p1;\n+  const struct constant_descriptor_tree *const c2\n+    = (const struct constant_descriptor_tree *) p2;\n   if (c1->hash != c2->hash)\n     return 0;\n   return compare_constant (c1->value, c2->value);\n@@ -3151,7 +3153,7 @@ build_constant_desc (tree exp)\n   int labelno;\n   struct constant_descriptor_tree *desc;\n \n-  desc = ggc_alloc (sizeof (*desc));\n+  desc = GGC_NEW (struct constant_descriptor_tree);\n   desc->value = copy_constant (exp);\n \n   /* Propagate marked-ness to copied constant.  */\n@@ -3219,7 +3221,7 @@ output_constant_def (tree exp, int defer)\n   key.hash = const_hash_1 (exp);\n   loc = htab_find_slot_with_hash (const_desc_htab, &key, key.hash, INSERT);\n \n-  desc = *loc;\n+  desc = (struct constant_descriptor_tree *) *loc;\n   if (desc == 0)\n     {\n       desc = build_constant_desc (exp);\n@@ -3330,7 +3332,8 @@ lookup_constant_def (tree exp)\n \n   key.value = exp;\n   key.hash = const_hash_1 (exp);\n-  desc = htab_find_with_hash (const_desc_htab, &key, key.hash);\n+  desc = (struct constant_descriptor_tree *)\n+    htab_find_with_hash (const_desc_htab, &key, key.hash);\n \n   return (desc ? desc->rtl : NULL_RTX);\n }\n@@ -3378,15 +3381,18 @@ struct constant_descriptor_rtx GTY((chain_next (\"%h.next\")))\n static hashval_t\n const_desc_rtx_hash (const void *ptr)\n {\n-  const struct constant_descriptor_rtx *desc = ptr;\n+  const struct constant_descriptor_rtx *const desc\n+    = (const struct constant_descriptor_rtx *) ptr;\n   return desc->hash;\n }\n \n static int\n const_desc_rtx_eq (const void *a, const void *b)\n {\n-  const struct constant_descriptor_rtx *x = a;\n-  const struct constant_descriptor_rtx *y = b;\n+  const struct constant_descriptor_rtx *const x\n+    = (const struct constant_descriptor_rtx *) a;\n+  const struct constant_descriptor_rtx *const y\n+    = (const struct constant_descriptor_rtx *) b;\n \n   if (x->mode != y->mode)\n     return 0;\n@@ -3467,7 +3473,7 @@ const_rtx_hash_1 (rtx *xp, void *data)\n       break;\n     }\n \n-  hp = data;\n+  hp = (hashval_t *) data;\n   *hp = *hp * 509 + h;\n   return 0;\n }\n@@ -3490,7 +3496,7 @@ create_constant_pool (void)\n {\n   struct rtx_constant_pool *pool;\n \n-  pool = ggc_alloc (sizeof (struct rtx_constant_pool));\n+  pool = GGC_NEW (struct rtx_constant_pool);\n   pool->const_rtx_htab = htab_create_ggc (31, const_desc_rtx_hash,\n \t\t\t\t\t  const_desc_rtx_eq, NULL);\n   pool->first = NULL;\n@@ -3549,14 +3555,14 @@ force_const_mem (enum machine_mode mode, rtx x)\n   tmp.mode = mode;\n   hash = const_rtx_hash (x);\n   slot = htab_find_slot_with_hash (pool->const_rtx_htab, &tmp, hash, INSERT);\n-  desc = *slot;\n+  desc = (struct constant_descriptor_rtx *) *slot;\n \n   /* If the constant was already present, return its memory.  */\n   if (desc)\n     return copy_rtx (desc->mem);\n \n   /* Otherwise, create a new descriptor.  */\n-  desc = ggc_alloc (sizeof (*desc));\n+  desc = GGC_NEW (struct constant_descriptor_rtx);\n   *slot = desc;\n \n   /* Align the location counter as required by EXP's data type.  */\n@@ -6046,7 +6052,7 @@ default_unique_section (tree decl, int reloc)\n static int\n compute_reloc_for_rtx_1 (rtx *xp, void *data)\n {\n-  int *preloc = data;\n+  int *preloc = (int *) data;\n   rtx x = *xp;\n \n   switch (GET_CODE (x))\n@@ -6323,7 +6329,7 @@ void\n default_internal_label (FILE *stream, const char *prefix,\n \t\t\tunsigned long labelno)\n {\n-  char *const buf = alloca (40 + strlen (prefix));\n+  char *const buf = (char *) alloca (40 + strlen (prefix));\n   ASM_GENERATE_INTERNAL_LABEL (buf, prefix, labelno);\n   ASM_OUTPUT_INTERNAL_LABEL (stream, buf);\n }"}, {"sha": "45330397e0eaf5035a24dfd61f8872e54d908a06", "filename": "gcc/varray.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d9a9f947fd29c85f7ed17f1b92000bff510de20/gcc%2Fvarray.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d9a9f947fd29c85f7ed17f1b92000bff510de20/gcc%2Fvarray.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarray.c?ref=3d9a9f947fd29c85f7ed17f1b92000bff510de20", "patch": "@@ -126,9 +126,9 @@ varray_init (size_t num_elements, enum varray_data_enum element_kind,\n   desc->allocated += data_size + VARRAY_HDR_SIZE;\n #endif\n   if (element[element_kind].uses_ggc)\n-    ptr = ggc_alloc_cleared (VARRAY_HDR_SIZE + data_size);\n+    ptr = GGC_CNEWVAR (struct varray_head_tag, VARRAY_HDR_SIZE + data_size);\n   else\n-    ptr = xcalloc (VARRAY_HDR_SIZE + data_size, 1);\n+    ptr = XCNEWVAR (struct varray_head_tag, VARRAY_HDR_SIZE + data_size);\n \n   ptr->num_elements = num_elements;\n   ptr->elements_used = 0;\n@@ -159,9 +159,11 @@ varray_grow (varray_type va, size_t n)\n \n \n       if (element[va->type].uses_ggc)\n-\tva = ggc_realloc (va, VARRAY_HDR_SIZE + data_size);\n+\tva = GGC_RESIZEVAR (struct varray_head_tag, va,\n+\t\t\t    VARRAY_HDR_SIZE + data_size);\n       else\n-\tva = xrealloc (va, VARRAY_HDR_SIZE + data_size);\n+\tva = XRESIZEVAR (struct varray_head_tag, va,\n+\t\t\t VARRAY_HDR_SIZE + data_size);\n       va->num_elements = n;\n       if (n > old_elements)\n \tmemset (&va->data.vdt_c[old_data_size], 0, data_size - old_data_size);"}, {"sha": "288af00a8577b32d82021db0237cd969165151c5", "filename": "gcc/vec.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d9a9f947fd29c85f7ed17f1b92000bff510de20/gcc%2Fvec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d9a9f947fd29c85f7ed17f1b92000bff510de20/gcc%2Fvec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvec.c?ref=3d9a9f947fd29c85f7ed17f1b92000bff510de20", "patch": "@@ -95,7 +95,7 @@ static void *\n vec_gc_o_reserve_1 (void *vec, int reserve, size_t vec_offset, size_t elt_size,\n \t\t    bool exact MEM_STAT_DECL)\n {\n-  struct vec_prefix *pfx = vec;\n+  struct vec_prefix *pfx = (struct vec_prefix *) vec;\n   unsigned alloc = alloc = calculate_allocation (pfx, reserve, exact);\n   \n   if (!alloc)\n@@ -167,7 +167,7 @@ static void *\n vec_heap_o_reserve_1 (void *vec, int reserve, size_t vec_offset,\n \t\t      size_t elt_size, bool exact MEM_STAT_DECL)\n {\n-  struct vec_prefix *pfx = vec;\n+  struct vec_prefix *pfx = (struct vec_prefix *) vec;\n   unsigned alloc = calculate_allocation (pfx, reserve, exact);\n \n   if (!alloc)"}]}