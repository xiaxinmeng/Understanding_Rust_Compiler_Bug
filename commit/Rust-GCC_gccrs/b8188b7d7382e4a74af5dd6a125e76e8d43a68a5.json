{"sha": "b8188b7d7382e4a74af5dd6a125e76e8d43a68a5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjgxODhiN2Q3MzgyZTRhNzRhZjVkZDZhMTI1ZTc2ZThkNDNhNjhhNQ==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2021-03-05T16:25:20Z"}, "committer": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2021-03-05T16:25:20Z"}, "message": "ipa: Fix resolving speculations through cgraph_edge::set_call_stmt\n\nIn the PR 98078 testcase, speculative call-graph edges which were\ncreated by IPA-CP are confirmed during inlining but\ncgraph_edge::set_call_stmt does not take it very well.\n\nThe function enters the update_speculative branch and updates the\nedges in the speculation bundle separately (by a recursive call), but\nwhen it processes the first direct edge, most of the bundle actually\nceases to exist because it is devirtualized.  It nevertheless goes on\nto attempt to update the indirect edge (that has just been removed),\nwhich surprisingly gets as far as adding the edge to the\ncall_site_hash, the same devirtualized edge for the second time, and\nthat triggers an assert.\n\nFixed by this patch which makes the function aware that it is about to\nresolve a speculation and do so instead of updating components of\nspeculation.  Also, it does so before dealing with the hash because\nthe speculation resolution code needs the hash to point to the first\nspeculative direct edge and also cleans the hash up by calling\nupdate_call_stmt_hash_for_removing_direct_edge.\n\nBootstrapped and tested on x86_64-linux, also profile-LTO-bootstrapped\non the same system.\n\ngcc/ChangeLog:\n\n2021-01-20  Martin Jambor  <mjambor@suse.cz>\n\n\tPR ipa/98078\n\t* cgraph.c (cgraph_edge::set_call_stmt): Do not update all\n\tcorresponding speculative edges if we are about to resolve\n\tsepculation.  Make edge direct (and so resolve speculations) before\n\tremoving it from call_site_hash.\n\t(cgraph_edge::make_direct): Relax the initial assert to allow calling\n\tthe function on speculative direct edges.", "tree": {"sha": "07146382e6e57a3461e427260df237f43b29f46d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/07146382e6e57a3461e427260df237f43b29f46d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b8188b7d7382e4a74af5dd6a125e76e8d43a68a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8188b7d7382e4a74af5dd6a125e76e8d43a68a5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b8188b7d7382e4a74af5dd6a125e76e8d43a68a5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8188b7d7382e4a74af5dd6a125e76e8d43a68a5/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4d66685e49d20e0c7a87c5fa0757c7eb63ffcdaa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d66685e49d20e0c7a87c5fa0757c7eb63ffcdaa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d66685e49d20e0c7a87c5fa0757c7eb63ffcdaa"}], "stats": {"total": 37, "additions": 22, "deletions": 15}, "files": [{"sha": "80140757d16ea86ba058f570c3f4b7481d18e95b", "filename": "gcc/cgraph.c", "status": "modified", "additions": 22, "deletions": 15, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8188b7d7382e4a74af5dd6a125e76e8d43a68a5/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8188b7d7382e4a74af5dd6a125e76e8d43a68a5/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=b8188b7d7382e4a74af5dd6a125e76e8d43a68a5", "patch": "@@ -789,9 +789,22 @@ cgraph_edge::set_call_stmt (cgraph_edge *e, gcall *new_stmt,\n {\n   tree decl;\n \n+  cgraph_node *new_direct_callee = NULL;\n+  if ((e->indirect_unknown_callee || e->speculative)\n+      && (decl = gimple_call_fndecl (new_stmt)))\n+    {\n+      /* Constant propagation and especially inlining can turn an indirect call\n+\t into a direct one.  */\n+      new_direct_callee = cgraph_node::get (decl);\n+      gcc_checking_assert (new_direct_callee);\n+    }\n+\n   /* Speculative edges has three component, update all of them\n      when asked to.  */\n-  if (update_speculative && e->speculative)\n+  if (update_speculative && e->speculative\n+      /* If we are about to resolve the speculation by calling make_direct\n+\t below, do not bother going over all the speculative edges now.  */\n+      && !new_direct_callee)\n     {\n       cgraph_edge *direct, *indirect, *next;\n       ipa_ref *ref;\n@@ -821,6 +834,9 @@ cgraph_edge::set_call_stmt (cgraph_edge *e, gcall *new_stmt,\n       return e_indirect ? indirect : direct;\n     }\n \n+  if (new_direct_callee)\n+    e = make_direct (e, new_direct_callee);\n+\n   /* Only direct speculative edges go to call_site_hash.  */\n   if (e->caller->call_site_hash\n       && (!e->speculative || !e->indirect_unknown_callee)\n@@ -831,16 +847,6 @@ cgraph_edge::set_call_stmt (cgraph_edge *e, gcall *new_stmt,\n       (e->call_stmt, cgraph_edge_hasher::hash (e->call_stmt));\n \n   e->call_stmt = new_stmt;\n-  if (e->indirect_unknown_callee\n-      && (decl = gimple_call_fndecl (new_stmt)))\n-    {\n-      /* Constant propagation (and possibly also inlining?) can turn an\n-\t indirect call into a direct one.  */\n-      cgraph_node *new_callee = cgraph_node::get (decl);\n-\n-      gcc_checking_assert (new_callee);\n-      e = make_direct (e, new_callee);\n-    }\n \n   function *fun = DECL_STRUCT_FUNCTION (e->caller->decl);\n   e->can_throw_external = stmt_can_throw_external (fun, new_stmt);\n@@ -1279,14 +1285,15 @@ cgraph_edge::speculative_call_for_target (cgraph_node *target)\n   return NULL;\n }\n \n-/* Make an indirect edge with an unknown callee an ordinary edge leading to\n-   CALLEE.  Speculations can be resolved in the process and EDGE can be removed\n-   and deallocated.  Return the edge that now represents the call.  */\n+/* Make an indirect or speculative EDGE with an unknown callee an ordinary edge\n+   leading to CALLEE.  Speculations can be resolved in the process and EDGE can\n+   be removed and deallocated.  Return the edge that now represents the\n+   call.  */\n \n cgraph_edge *\n cgraph_edge::make_direct (cgraph_edge *edge, cgraph_node *callee)\n {\n-  gcc_assert (edge->indirect_unknown_callee);\n+  gcc_assert (edge->indirect_unknown_callee || edge->speculative);\n \n   /* If we are redirecting speculative call, make it non-speculative.  */\n   if (edge->speculative)"}]}