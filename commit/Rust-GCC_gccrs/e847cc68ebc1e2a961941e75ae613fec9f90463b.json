{"sha": "e847cc68ebc1e2a961941e75ae613fec9f90463b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTg0N2NjNjhlYmMxZTJhOTYxOTQxZTc1YWU2MTNmZWM5ZjkwNDYzYg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2004-07-28T01:17:00Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-07-28T01:17:00Z"}, "message": "gimplify.c (is_gimple_addr_expr_arg_or_indirect): Remove.\n\n        * gimplify.c (is_gimple_addr_expr_arg_or_indirect): Remove.\n        (gimplify_modify_expr, gimplify_addr_expr, gimplify_expr): Use\n        is_gimple_addressable.\n        * tree-gimple.c (is_gimple_addressable): Rename from\n        is_gimple_addr_expr_arg; accept INDIRECT_REF.\n        (is_gimple_lvalue): Don't test INDIRECT_REF directly.\n        * tree-gimple.h, tree-sra.c, tree-ssa-loop-im.c: Update for\n        rename to is_gimple_addressable.\n\nFrom-SVN: r85243", "tree": {"sha": "0c30f61b19cf213402a8b9492ba3424c41e1602b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0c30f61b19cf213402a8b9492ba3424c41e1602b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e847cc68ebc1e2a961941e75ae613fec9f90463b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e847cc68ebc1e2a961941e75ae613fec9f90463b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e847cc68ebc1e2a961941e75ae613fec9f90463b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e847cc68ebc1e2a961941e75ae613fec9f90463b/comments", "author": null, "committer": null, "parents": [{"sha": "b91accd685798cd0cb4f775bfcdcc40c18efbdb6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b91accd685798cd0cb4f775bfcdcc40c18efbdb6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b91accd685798cd0cb4f775bfcdcc40c18efbdb6"}], "stats": {"total": 52, "additions": 28, "deletions": 24}, "files": [{"sha": "f19695ff364fd6c44de6670f177f89c93d81f298", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e847cc68ebc1e2a961941e75ae613fec9f90463b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e847cc68ebc1e2a961941e75ae613fec9f90463b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e847cc68ebc1e2a961941e75ae613fec9f90463b", "patch": "@@ -1,3 +1,14 @@\n+2004-07-27  Richard Henderson  <rth@redhat.com>\n+\n+\t* gimplify.c (is_gimple_addr_expr_arg_or_indirect): Remove.\n+\t(gimplify_modify_expr, gimplify_addr_expr, gimplify_expr): Use\n+\tis_gimple_addressable.\n+\t* tree-gimple.c (is_gimple_addressable): Rename from\n+\tis_gimple_addr_expr_arg; accept INDIRECT_REF.\n+\t(is_gimple_lvalue): Don't test INDIRECT_REF directly.\n+\t* tree-gimple.h, tree-sra.c, tree-ssa-loop-im.c: Update for\n+\trename to is_gimple_addressable.\n+\n 2004-07-28  Alan Modra  <amodra@bigpond.net.au>\n \n \t* config/rs6000/rs6000.c (function_arg_padding): Pad SFmode upwards."}, {"sha": "fc260c8ce4deef8614a8c26448ca2fed4c3e2c6f", "filename": "gcc/gimplify.c", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e847cc68ebc1e2a961941e75ae613fec9f90463b/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e847cc68ebc1e2a961941e75ae613fec9f90463b/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=e847cc68ebc1e2a961941e75ae613fec9f90463b", "patch": "@@ -2709,15 +2709,6 @@ gimplify_modify_expr_rhs (tree *expr_p, tree *from_p, tree *to_p, tree *pre_p,\n   return ret;\n }\n \n-/* Return true if T is either a valid GIMPLE operand or is an\n-   INDIRECT_REF (the latter is valid since we'll strip it off).  */\n-\n-static bool\n-is_gimple_addr_expr_arg_or_indirect (tree t)\n-{\n-  return (TREE_CODE (t) == INDIRECT_REF || is_gimple_addr_expr_arg (t));\n-}\n-\n /* Gimplify the MODIFY_EXPR node pointed by EXPR_P.\n \n       modify_expr\n@@ -2788,7 +2779,7 @@ gimplify_modify_expr (tree *expr_p, tree *pre_p, tree *post_p, bool want_value)\n \n       if (TREE_CODE (from) == CONSTRUCTOR)\n \treturn gimplify_modify_expr_to_memset (expr_p, size, want_value);\n-      if (is_gimple_addr_expr_arg (from))\n+      if (is_gimple_addressable (from))\n \t{\n \t  *from_p = from;\n \t  return gimplify_modify_expr_to_memcpy (expr_p, size, want_value);\n@@ -3027,7 +3018,7 @@ gimplify_addr_expr (tree *expr_p, tree *pre_p, tree *post_p)\n       /* We use fb_either here because the C frontend sometimes takes\n \t the address of a call that returns a struct.  */\n       ret = gimplify_expr (&TREE_OPERAND (expr, 0), pre_p, post_p,\n-\t\t\t   is_gimple_addr_expr_arg_or_indirect, fb_either);\n+\t\t\t   is_gimple_addressable, fb_either);\n       if (ret != GS_ERROR)\n \t{\n \t  /* The above may have made an INDIRECT ref (e.g, Ada's NULL_EXPR),\n@@ -3930,7 +3921,7 @@ gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p,\n      postqueue; we need to copy the value out first, which means an\n      rvalue.  */\n   if ((fallback & fb_lvalue) && !internal_post\n-      && is_gimple_addr_expr_arg (*expr_p))\n+      && is_gimple_addressable (*expr_p))\n     {\n       /* An lvalue will do.  Take the address of the expression, store it\n \t in a temporary, and replace the expression with an INDIRECT_REF of"}, {"sha": "4f26a084fc03f087f8a5b86ccc9aa27d92eab3dc", "filename": "gcc/tree-gimple.c", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e847cc68ebc1e2a961941e75ae613fec9f90463b/gcc%2Ftree-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e847cc68ebc1e2a961941e75ae613fec9f90463b/gcc%2Ftree-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-gimple.c?ref=e847cc68ebc1e2a961941e75ae613fec9f90463b", "patch": "@@ -118,16 +118,17 @@ Boston, MA 02111-1307, USA.  */\n    addr-expr-arg: ID\n \t\t| compref\n \n-   with-size-arg: addr-expr-arg\n+   addressable\t: addr-expr-arg\n \t\t| indirectref\n+\n+   with-size-arg: addressable\n \t\t| call-stmt\n \n    indirectref\t: INDIRECT_REF\n \t\t\top0 -> val\n \n-   lhs\t\t: addr-expr-arg\n+   lhs\t\t: addressable\n \t\t| bitfieldref\n-\t\t| indirectref\n \t\t| WITH_SIZE_EXPR\n \t\t\top0 -> with-size-arg\n \t\t\top1 -> val\n@@ -300,8 +301,7 @@ is_gimple_constructor_elt (tree t)\n bool\n is_gimple_lvalue (tree t)\n {\n-  return (is_gimple_addr_expr_arg (t)\n-\t  || TREE_CODE (t) == INDIRECT_REF\n+  return (is_gimple_addressable (t)\n \t  || TREE_CODE (t) == WITH_SIZE_EXPR\n \t  /* These are complex lvalues, but don't have addresses, so they\n \t     go here.  */\n@@ -317,13 +317,15 @@ is_gimple_condexpr (tree t)\n \t  || TREE_CODE_CLASS (TREE_CODE (t)) == '<');\n }\n \n-/*  Return true if T is a valid operand for ADDR_EXPR.  */\n+/*  Return true if T is something whose address can be taken.  */\n \n bool\n-is_gimple_addr_expr_arg (tree t)\n+is_gimple_addressable (tree t)\n {\n   return (is_gimple_id (t) || handled_component_p (t)\n-\t  || TREE_CODE (t) == REALPART_EXPR || TREE_CODE (t) == IMAGPART_EXPR);\n+\t  || TREE_CODE (t) == REALPART_EXPR\n+\t  || TREE_CODE (t) == IMAGPART_EXPR\n+\t  || TREE_CODE (t) == INDIRECT_REF);\n }\n \n /* Return true if T is function invariant.  Or rather a restricted"}, {"sha": "0fb376694e43f5572626beda75f01b0e7996ec31", "filename": "gcc/tree-gimple.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e847cc68ebc1e2a961941e75ae613fec9f90463b/gcc%2Ftree-gimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e847cc68ebc1e2a961941e75ae613fec9f90463b/gcc%2Ftree-gimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-gimple.h?ref=e847cc68ebc1e2a961941e75ae613fec9f90463b", "patch": "@@ -55,8 +55,8 @@ extern bool is_gimple_tmp_reg (tree);\n extern bool is_gimple_variable (tree);\n /* Returns true iff T is a variable or an INDIRECT_REF (of a variable).  */\n extern bool is_gimple_min_lval (tree);\n-/* Returns true iff T is an lvalue other than an INDIRECT_REF.  */\n-extern bool is_gimple_addr_expr_arg (tree);\n+/* Returns true iff T is something whose address can be taken.  */\n+extern bool is_gimple_addressable (tree);\n /* Returns true iff T is any valid GIMPLE lvalue.  */\n extern bool is_gimple_lvalue (tree);\n "}, {"sha": "30d8e34d32b08f6e084b02b69d5106044311648b", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e847cc68ebc1e2a961941e75ae613fec9f90463b/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e847cc68ebc1e2a961941e75ae613fec9f90463b/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=e847cc68ebc1e2a961941e75ae613fec9f90463b", "patch": "@@ -826,7 +826,7 @@ sra_walk_modify_expr (tree expr, block_stmt_iterator *bsi,\n \t The lvalue requirement prevents us from trying to directly scalarize\n \t the result of a function call.  Which would result in trying to call\n \t the function multiple times, and other evil things.  */\n-      else if (!lhs_elt->is_scalar && is_gimple_addr_expr_arg (rhs))\n+      else if (!lhs_elt->is_scalar && is_gimple_addressable (rhs))\n \tfns->ldst (lhs_elt, rhs, bsi, true);\n \t\n       /* Otherwise we're being used in some context that requires the"}, {"sha": "d8c70a9489f4e460ec4ea12816c1713c71b16748", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e847cc68ebc1e2a961941e75ae613fec9f90463b/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e847cc68ebc1e2a961941e75ae613fec9f90463b/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=e847cc68ebc1e2a961941e75ae613fec9f90463b", "patch": "@@ -350,7 +350,7 @@ stmt_cost (tree stmt)\n   /* Hoisting memory references out should almost surely be a win.  */\n   if (!is_gimple_variable (lhs))\n     cost += 20;\n-  if (is_gimple_addr_expr_arg (rhs) && !is_gimple_variable (rhs))\n+  if (is_gimple_addressable (rhs) && !is_gimple_variable (rhs))\n     cost += 20;\n \n   switch (TREE_CODE (rhs))"}]}