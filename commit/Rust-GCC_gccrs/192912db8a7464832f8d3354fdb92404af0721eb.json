{"sha": "192912db8a7464832f8d3354fdb92404af0721eb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTkyOTEyZGI4YTc0NjQ4MzJmOGQzMzU0ZmRiOTI0MDRhZjA3MjFlYg==", "commit": {"author": {"name": "Bin Cheng", "email": "bin.cheng@arm.com", "date": "2016-03-02T14:10:56Z"}, "committer": {"name": "Bin Cheng", "email": "amker@gcc.gnu.org", "date": "2016-03-02T14:10:56Z"}, "message": "re PR rtl-optimization/69052 (Performance regression after r229402.)\n\n\n\tPR tree-optimization/69052\n\t* loop-invariant.c (canonicalize_address): New function.\n\t(inv_can_prop_to_addr_use): Check validity of address expression\n\twhich is canonicalized by above function.\n\n\tgcc/testsuite/ChangeLog\n\tPR tree-optimization/69052\n\t* gcc.target/i386/pr69052.c: New test.\n\nFrom-SVN: r233907", "tree": {"sha": "d5112463859fd99405ffe1e93be6a083bdeec259", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d5112463859fd99405ffe1e93be6a083bdeec259"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/192912db8a7464832f8d3354fdb92404af0721eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/192912db8a7464832f8d3354fdb92404af0721eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/192912db8a7464832f8d3354fdb92404af0721eb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/192912db8a7464832f8d3354fdb92404af0721eb/comments", "author": null, "committer": null, "parents": [{"sha": "90a7a40b65d1057bff07961dd9c8b0c05c345ba8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90a7a40b65d1057bff07961dd9c8b0c05c345ba8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/90a7a40b65d1057bff07961dd9c8b0c05c345ba8"}], "stats": {"total": 216, "additions": 215, "deletions": 1}, "files": [{"sha": "e0911625ce91aae7a389a699b415415ec305c57b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/192912db8a7464832f8d3354fdb92404af0721eb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/192912db8a7464832f8d3354fdb92404af0721eb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=192912db8a7464832f8d3354fdb92404af0721eb", "patch": "@@ -1,3 +1,10 @@\n+2016-03-02  Bin Cheng  <bin.cheng@arm.com>\n+\n+\tPR tree-optimization/69052\n+\t* loop-invariant.c (canonicalize_address): New function.\n+\t(inv_can_prop_to_addr_use): Check validity of address expression\n+\twhich is canonicalized by above function.\n+\n 2016-03-02  Alan Modra  <amodra@gmail.com>\n \n \tPR ipa/69990"}, {"sha": "dcbe9326a5b86eb855f03988c622ebb00d4cd5df", "filename": "gcc/loop-invariant.c", "status": "modified", "additions": 149, "deletions": 1, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/192912db8a7464832f8d3354fdb92404af0721eb/gcc%2Floop-invariant.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/192912db8a7464832f8d3354fdb92404af0721eb/gcc%2Floop-invariant.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-invariant.c?ref=192912db8a7464832f8d3354fdb92404af0721eb", "patch": "@@ -52,6 +52,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cfgloop.h\"\n #include \"expr.h\"\n #include \"params.h\"\n+#include \"rtl-iter.h\"\n #include \"dumpfile.h\"\n \n /* The data stored for the loop.  */\n@@ -754,14 +755,138 @@ create_new_invariant (struct def *def, rtx_insn *insn, bitmap depends_on,\n   return inv;\n }\n \n+/* Return a canonical version of X for the address, from the point of view,\n+   that all multiplications are represented as MULT instead of the multiply\n+   by a power of 2 being represented as ASHIFT.\n+\n+   Callers should prepare a copy of X because this function may modify it\n+   in place.  */\n+\n+static void\n+canonicalize_address_mult (rtx x)\n+{\n+  subrtx_var_iterator::array_type array;\n+  FOR_EACH_SUBRTX_VAR (iter, array, x, NONCONST)\n+    {\n+      rtx sub = *iter;\n+\n+      if (GET_CODE (sub) == ASHIFT\n+\t  && CONST_INT_P (XEXP (sub, 1))\n+\t  && INTVAL (XEXP (sub, 1)) < GET_MODE_BITSIZE (GET_MODE (sub))\n+\t  && INTVAL (XEXP (sub, 1)) >= 0)\n+\t{\n+\t  HOST_WIDE_INT shift = INTVAL (XEXP (sub, 1));\n+\t  PUT_CODE (sub, MULT);\n+\t  XEXP (sub, 1) = gen_int_mode ((HOST_WIDE_INT) 1 << shift,\n+\t\t\t\t\tGET_MODE (sub));\n+\t  iter.skip_subrtxes ();\n+\t}\n+    }\n+}\n+\n+/* Maximum number of sub expressions in address.  We set it to\n+   a small integer since it's unlikely to have a complicated\n+   address expression.  */\n+\n+#define MAX_CANON_ADDR_PARTS (5)\n+\n+/* Collect sub expressions in address X with PLUS as the seperator.\n+   Sub expressions are stored in vector ADDR_PARTS.  */\n+\n+static void\n+collect_address_parts (rtx x, vec<rtx> *addr_parts)\n+{\n+  subrtx_var_iterator::array_type array;\n+  FOR_EACH_SUBRTX_VAR (iter, array, x, NONCONST)\n+    {\n+      rtx sub = *iter;\n+\n+      if (GET_CODE (sub) != PLUS)\n+\t{\n+\t  addr_parts->safe_push (sub);\n+\t  iter.skip_subrtxes ();\n+\t}\n+    }\n+}\n+\n+/* Compare function for sorting sub expressions X and Y based on\n+   precedence defined for communitive operations.  */\n+\n+static int\n+compare_address_parts (const void *x, const void *y)\n+{\n+  const rtx *rx = (const rtx *)x;\n+  const rtx *ry = (const rtx *)y;\n+  int px = commutative_operand_precedence (*rx);\n+  int py = commutative_operand_precedence (*ry);\n+\n+  return (py - px);\n+}\n+\n+/* Return a canonical version address for X by following steps:\n+     1) Rewrite ASHIFT into MULT recursively.\n+     2) Divide address into sub expressions with PLUS as the\n+\tseparator.\n+     3) Sort sub expressions according to precedence defined\n+\tfor communative operations.\n+     4) Simplify CONST_INT_P sub expressions.\n+     5) Create new canonicalized address and return.\n+   Callers should prepare a copy of X because this function may\n+   modify it in place.  */\n+\n+static rtx\n+canonicalize_address (rtx x)\n+{\n+  rtx res;\n+  unsigned int i, j;\n+  machine_mode mode = GET_MODE (x);\n+  auto_vec<rtx, MAX_CANON_ADDR_PARTS> addr_parts;\n+\n+  /* Rewrite ASHIFT into MULT.  */\n+  canonicalize_address_mult (x);\n+  /* Divide address into sub expressions.  */\n+  collect_address_parts (x, &addr_parts);\n+  /* Unlikely to have very complicated address.  */\n+  if (addr_parts.length () < 2\n+      || addr_parts.length () > MAX_CANON_ADDR_PARTS)\n+    return x;\n+\n+  /* Sort sub expressions according to canonicalization precedence.  */\n+  addr_parts.qsort (compare_address_parts);\n+\n+  /* Simplify all constant int summary if possible.  */\n+  for (i = 0; i < addr_parts.length (); i++)\n+    if (CONST_INT_P (addr_parts[i]))\n+      break;\n+\n+  for (j = i + 1; j < addr_parts.length (); j++)\n+    {\n+      gcc_assert (CONST_INT_P (addr_parts[j]));\n+      addr_parts[i] = simplify_gen_binary (PLUS, mode,\n+\t\t\t\t\t   addr_parts[i],\n+\t\t\t\t\t   addr_parts[j]);\n+    }\n+\n+  /* Chain PLUS operators to the left for !CONST_INT_P sub expressions.  */\n+  res = addr_parts[0];\n+  for (j = 1; j < i; j++)\n+    res = simplify_gen_binary (PLUS, mode, res, addr_parts[j]);\n+\n+  /* Pickup the last CONST_INT_P sub expression.  */\n+  if (i < addr_parts.length ())\n+    res = simplify_gen_binary (PLUS, mode, res, addr_parts[i]);\n+\n+  return res;\n+}\n+\n /* Given invariant DEF and its address USE, check if the corresponding\n    invariant expr can be propagated into the use or not.  */\n \n static bool\n inv_can_prop_to_addr_use (struct def *def, df_ref use)\n {\n   struct invariant *inv;\n-  rtx *pos = DF_REF_REAL_LOC (use), def_set;\n+  rtx *pos = DF_REF_REAL_LOC (use), def_set, use_set;\n   rtx_insn *use_insn = DF_REF_INSN (use);\n   rtx_insn *def_insn;\n   bool ok;\n@@ -778,6 +903,29 @@ inv_can_prop_to_addr_use (struct def *def, df_ref use)\n \n   validate_unshare_change (use_insn, pos, SET_SRC (def_set), true);\n   ok = verify_changes (0);\n+  /* Try harder with canonicalization in address expression.  */\n+  if (!ok && (use_set = single_set (use_insn)) != NULL_RTX)\n+    {\n+      rtx src, dest, mem = NULL_RTX;\n+\n+      src = SET_SRC (use_set);\n+      dest = SET_DEST (use_set);\n+      if (MEM_P (src))\n+\tmem = src;\n+      else if (MEM_P (dest))\n+\tmem = dest;\n+\n+      if (mem != NULL_RTX\n+\t  && !memory_address_addr_space_p (GET_MODE (mem),\n+\t\t\t\t\t   XEXP (mem, 0),\n+\t\t\t\t\t   MEM_ADDR_SPACE (mem)))\n+\t{\n+\t  rtx addr = canonicalize_address (copy_rtx (XEXP (mem, 0)));\n+\t  if (memory_address_addr_space_p (GET_MODE (mem),\n+\t\t\t\t\t   addr, MEM_ADDR_SPACE (mem)))\n+\t    ok = true;\n+\t}\n+    }\n   cancel_changes (0);\n   return ok;\n }"}, {"sha": "b94e1dffb045a82715c65c001d2629533df492dd", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/192912db8a7464832f8d3354fdb92404af0721eb/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/192912db8a7464832f8d3354fdb92404af0721eb/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=192912db8a7464832f8d3354fdb92404af0721eb", "patch": "@@ -1,3 +1,8 @@\n+2016-03-02  Bin Cheng  <bin.cheng@arm.com>\n+\n+\tPR tree-optimization/69052\n+\t* gcc.target/i386/pr69052.c: New test.\n+\n 2016-03-02  Alan Modra  <amodra@gmail.com>\n \n \t* gcc.dg/pr69990.c: New."}, {"sha": "6f491e9ab5391eb411cd057654c2e14ee4120d08", "filename": "gcc/testsuite/gcc.target/i386/pr69052.c", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/192912db8a7464832f8d3354fdb92404af0721eb/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr69052.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/192912db8a7464832f8d3354fdb92404af0721eb/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr69052.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr69052.c?ref=192912db8a7464832f8d3354fdb92404af0721eb", "patch": "@@ -0,0 +1,54 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target pie } */\n+/* { dg-options \"-O2 -fPIE -pie\" } */\n+\n+int look_nbits[256], loop_sym[256];\n+const int ind[] = {\n+  0,  1,  8, 16,  9,  2,  3, 10, 17, 24, 32, 25, 18, 11,  4,  5,\n+ 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13,  6,  7, 14, 21, 28,\n+ 35, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51,\n+ 58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63\n+};\n+int out[256];\n+extern void bar (int *, int *);\n+void foo (int *l1, int *l2, int *v, int *v1, int *m1, int i)\n+{\n+  int L = i + 1, b = 20;\n+  int result, k;\n+\n+  for (k = 1; k < 64; k++)\n+    {\n+      int look = (((L >> (b - 8))) & ((1 << 8) - 1));\n+      int nb = l1[look];\n+      int code;\n+      int r;\n+\n+      if (nb)\n+\t{\n+\t  b -= nb;\n+\t  result = l2[look];\n+\t}\n+      else\n+\t{\n+\t  nb = 9;\n+\t  code = (((L >> (b -= nb))) & ((1 << nb) - 1));\n+\t  result = v[(code + v1[nb])];\n+\t}\n+      r = result >> 4;\n+      result &= 15;\n+      if (result)\n+\t{\n+\t  k += r;\n+\t  r = (((L >> (b -= result))) & ((1 << result) - 1));\n+\t  if (r < (1 << (result - 1)))\n+\t    result = r + (((-1) << result) + 1);\n+\t  else\n+\t    result = r;\n+\n+\t  out[ind[k]] = result;\n+\t}\n+      bar (&L, &b);\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-not \"leal\\[ \\t\\]ind@GOTOFF\\\\(%\\[^,\\]*\\\\), %\" { target ia32 } } } */"}]}