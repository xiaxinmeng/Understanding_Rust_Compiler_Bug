{"sha": "1ba91a49a97955057bb8a07b42feb901ee9cee4e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWJhOTFhNDlhOTc5NTUwNTdiYjhhMDdiNDJmZWI5MDFlZTljZWU0ZQ==", "commit": {"author": {"name": "Alan Lawrence", "email": "alan.lawrence@arm.com", "date": "2015-11-13T16:12:52Z"}, "committer": {"name": "Alan Lawrence", "email": "alalaw01@gcc.gnu.org", "date": "2015-11-13T16:12:52Z"}, "message": "PR/67682, break SLP groups up if only some elements match\n\ngcc/:\n\n\t* tree-vect-slp.c (vect_split_slp_store_group): New.\n\t(vect_analyze_slp_instance): During basic block SLP, recurse on\n\tsubgroups if vect_build_slp_tree fails after 1st vector.\n\ngcc/testsuite/:\n\n\t* gcc.dg/vect/bb-slp-7.c (main1): Make subgroups non-isomorphic.\n\t* gcc.dg/vect/bb-slp-subgroups-1.c: New.\n\t* gcc.dg/vect/bb-slp-subgroups-2.c: New.\n\t* gcc.dg/vect/bb-slp-subgroups-3.c: New.\n\nFrom-SVN: r230330", "tree": {"sha": "6ea06f2a6842cc5405852cc266757b80eeddbc2f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6ea06f2a6842cc5405852cc266757b80eeddbc2f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1ba91a49a97955057bb8a07b42feb901ee9cee4e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ba91a49a97955057bb8a07b42feb901ee9cee4e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ba91a49a97955057bb8a07b42feb901ee9cee4e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ba91a49a97955057bb8a07b42feb901ee9cee4e/comments", "author": null, "committer": null, "parents": [{"sha": "4216708a0073b10ffca943dc05c861d4d16f9c33", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4216708a0073b10ffca943dc05c861d4d16f9c33", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4216708a0073b10ffca943dc05c861d4d16f9c33"}], "stats": {"total": 236, "additions": 230, "deletions": 6}, "files": [{"sha": "9b2bd332845fca861ca93a9b56f68c56944d18a4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ba91a49a97955057bb8a07b42feb901ee9cee4e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ba91a49a97955057bb8a07b42feb901ee9cee4e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1ba91a49a97955057bb8a07b42feb901ee9cee4e", "patch": "@@ -1,3 +1,10 @@\n+2015-11-13  Alan Lawrence  <alan.lawrence@arm.com>\n+\n+\tPR tree-optimization/67682\n+\t* tree-vect-slp.c (vect_split_slp_store_group): New.\n+\t(vect_analyze_slp_instance): During basic block SLP, recurse on\n+\tsubgroups if vect_build_slp_tree fails after 1st vector.\n+\n 2015-11-13  Christian Bruel  <christian.bruel@st.com>\n \n \tPR target/65837"}, {"sha": "ed4d7cb8aee7f143d2f0ebc44f5905f5ccbfaafa", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ba91a49a97955057bb8a07b42feb901ee9cee4e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ba91a49a97955057bb8a07b42feb901ee9cee4e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=1ba91a49a97955057bb8a07b42feb901ee9cee4e", "patch": "@@ -1,3 +1,11 @@\n+2015-11-13  Alan Lawrence  <alan.lawrence@arm.com>\n+\n+\tPR tree-optimization/67682\n+\t* gcc.dg/vect/bb-slp-7.c (main1): Make subgroups non-isomorphic.\n+\t* gcc.dg/vect/bb-slp-subgroups-1.c: New.\n+\t* gcc.dg/vect/bb-slp-subgroups-2.c: New.\n+\t* gcc.dg/vect/bb-slp-subgroups-3.c: New.\n+\n 2015-11-13  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \t* gcc.target/aarch64/umaddl_combine_1.c: New test."}, {"sha": "b8bef8cffb4173eea6264901f1adcb57295ec61b", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-7.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ba91a49a97955057bb8a07b42feb901ee9cee4e/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ba91a49a97955057bb8a07b42feb901ee9cee4e/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-7.c?ref=1ba91a49a97955057bb8a07b42feb901ee9cee4e", "patch": "@@ -16,20 +16,20 @@ main1 (unsigned int x, unsigned int y)\n   unsigned int *pout = &out[0];\n   unsigned int a0, a1, a2, a3;\n \n-  /* Non isomorphic.  */\n+  /* Non isomorphic, even 64-bit subgroups.  */\n   a0 = *pin++ + 23;\n-  a1 = *pin++ + 142;\n+  a1 = *pin++ * 142;\n   a2 = *pin++ + 2;\n   a3 = *pin++ * 31;\n-  \n+\n   *pout++ = a0 * x;\n   *pout++ = a1 * y;\n   *pout++ = a2 * x;\n   *pout++ = a3 * y;\n \n   /* Check results.  */\n   if (out[0] != (in[0] + 23) * x\n-      || out[1] != (in[1] + 142) * y\n+      || out[1] != (in[1] * 142) * y\n       || out[2] != (in[2] + 2) * x\n       || out[3] != (in[3] * 31) * y)\n     abort();\n@@ -47,4 +47,4 @@ int main (void)\n }\n \n /* { dg-final { scan-tree-dump-times \"basic block vectorized\" 0 \"slp2\" } } */\n-  \n+"}, {"sha": "39c23c397e7ed18652488907e9473efe8bcd43dc", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-subgroups-1.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ba91a49a97955057bb8a07b42feb901ee9cee4e/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-subgroups-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ba91a49a97955057bb8a07b42feb901ee9cee4e/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-subgroups-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-subgroups-1.c?ref=1ba91a49a97955057bb8a07b42feb901ee9cee4e", "patch": "@@ -0,0 +1,44 @@\n+/* { dg-require-effective-target vect_int } */\n+/* PR tree-optimization/67682.  */\n+\n+#include \"tree-vect.h\"\n+\n+int __attribute__((__aligned__(8))) a[8];\n+int __attribute__((__aligned__(8))) b[4];\n+\n+__attribute__ ((noinline)) void\n+test ()\n+{\n+    a[0] = b[0];\n+    a[1] = b[1];\n+    a[2] = b[2];\n+    a[3] = b[3];\n+    a[4] = 0;\n+    a[5] = 0;\n+    a[6] = 0;\n+    a[7] = 0;\n+}\n+\n+int\n+main (int argc, char **argv)\n+{\n+  check_vect ();\n+\n+  for (int i = 0; i < 8; i++)\n+    a[i] = 1;\n+  for (int i = 0; i < 4; i++)\n+    b[i] = i + 4;\n+  __asm__ volatile (\"\" : : : \"memory\");\n+  test (a, b);\n+  __asm__ volatile (\"\" : : : \"memory\");\n+  for (int i = 0; i < 4; i++)\n+    if (a[i] != i+4)\n+      abort ();\n+  for (int i = 4; i < 8; i++)\n+    if (a[i] != 0)\n+      abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Basic block will be vectorized using SLP\" 1 \"slp2\" } } */\n+/* { dg-final { scan-tree-dump-times \"basic block vectorized\" 1 \"slp2\" } } */"}, {"sha": "13c51f3440bf2fd13ac27e6855002bcdabb3d801", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-subgroups-2.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ba91a49a97955057bb8a07b42feb901ee9cee4e/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-subgroups-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ba91a49a97955057bb8a07b42feb901ee9cee4e/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-subgroups-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-subgroups-2.c?ref=1ba91a49a97955057bb8a07b42feb901ee9cee4e", "patch": "@@ -0,0 +1,41 @@\n+/* { dg-require-effective-target vect_int } */\n+/* PR tree-optimization/67682.  */\n+\n+#include \"tree-vect.h\"\n+\n+int __attribute__((__aligned__(8))) a[8];\n+int __attribute__((__aligned__(8))) b[4];\n+\n+__attribute__ ((noinline)) void\n+test ()\n+{\n+    a[0] = b[2] + 1;\n+    a[1] = b[0] + 2;\n+    a[2] = b[1] + 3;\n+    a[3] = b[1] + 4;\n+    a[4] = b[3] * 3;\n+    a[5] = b[0] * 4;\n+    a[6] = b[2] * 5;\n+    a[7] = b[1] * 7;\n+}\n+\n+int\n+main (int argc, char **argv)\n+{\n+  check_vect ();\n+\n+  for (int i = 0; i < 8; i++)\n+    a[i] = 1;\n+  for (int i = 0; i < 4; i++)\n+    b[i] = i + 4;\n+  __asm__ volatile (\"\" : : : \"memory\");\n+  test (a, b);\n+  __asm__ volatile (\"\" : : : \"memory\");\n+  if ((a[0] != 7) || a[1] != 6 || (a[2] != 8) || (a[3] != 9)\n+      || (a[4] != 21) || (a[5] != 16) || (a[6] != 30) || (a[7] != 35))\n+    abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Basic block will be vectorized using SLP\" 1 \"slp2\" } } */\n+/* { dg-final { scan-tree-dump-times \"basic block vectorized\" 1 \"slp2\" } } */"}, {"sha": "6ae9a8976865f5f0f6d87521003e847df7faef98", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-subgroups-3.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ba91a49a97955057bb8a07b42feb901ee9cee4e/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-subgroups-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ba91a49a97955057bb8a07b42feb901ee9cee4e/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-subgroups-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-subgroups-3.c?ref=1ba91a49a97955057bb8a07b42feb901ee9cee4e", "patch": "@@ -0,0 +1,41 @@\n+/* { dg-require-effective-target vect_int } */\n+/* PR tree-optimization/67682.  */\n+\n+#include \"tree-vect.h\"\n+\n+int __attribute__((__aligned__(8))) a[8];\n+int __attribute__((__aligned__(8))) b[8];\n+\n+__attribute__ ((noinline)) void\n+test ()\n+{\n+    a[0] = b[0] + 1;\n+    a[1] = b[1] + 2;\n+    a[2] = b[2] + 3;\n+    a[3] = b[3] + 4;\n+    a[4] = b[0] * 3;\n+    a[5] = b[2] * 4;\n+    a[6] = b[4] * 5;\n+    a[7] = b[6] * 7;\n+}\n+\n+int\n+main (int argc, char **argv)\n+{\n+  check_vect ();\n+\n+  for (int i = 0; i < 8; i++)\n+    a[i] = 1;\n+  for (int i = 0; i < 8; i++)\n+    b[i] = i + 4;\n+  __asm__ volatile (\"\" : : : \"memory\");\n+  test (a, b);\n+  __asm__ volatile (\"\" : : : \"memory\");\n+  if ((a[0] != 5) || (a[1] != 7) || (a[2] != 9) || (a[3] != 11)\n+      || (a[4] != 12) || (a[5] != 24) || (a[6] != 40) || (a[7] != 70))\n+    abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Basic block will be vectorized using SLP\" 1 \"slp2\" } } */\n+/* { dg-final { scan-tree-dump-times \"basic block vectorized\" 1 \"slp2\" } } */"}, {"sha": "704f42fd886c7db636e20ecf2c71e4cf4f93e357", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 84, "deletions": 1, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ba91a49a97955057bb8a07b42feb901ee9cee4e/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ba91a49a97955057bb8a07b42feb901ee9cee4e/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=1ba91a49a97955057bb8a07b42feb901ee9cee4e", "patch": "@@ -1565,6 +1565,54 @@ vect_analyze_slp_cost (slp_instance instance, void *data)\n   body_cost_vec.release ();\n }\n \n+/* Splits a group of stores, currently beginning at FIRST_STMT, into two groups:\n+   one (still beginning at FIRST_STMT) of size GROUP1_SIZE (also containing\n+   the first GROUP1_SIZE stmts, since stores are consecutive), the second\n+   containing the remainder.\n+   Return the first stmt in the second group.  */\n+\n+static gimple *\n+vect_split_slp_store_group (gimple *first_stmt, unsigned group1_size)\n+{\n+  stmt_vec_info first_vinfo = vinfo_for_stmt (first_stmt);\n+  gcc_assert (GROUP_FIRST_ELEMENT (first_vinfo) == first_stmt);\n+  gcc_assert (group1_size > 0);\n+  int group2_size = GROUP_SIZE (first_vinfo) - group1_size;\n+  gcc_assert (group2_size > 0);\n+  GROUP_SIZE (first_vinfo) = group1_size;\n+\n+  gimple *stmt = first_stmt;\n+  for (unsigned i = group1_size; i > 1; i--)\n+    {\n+      stmt = GROUP_NEXT_ELEMENT (vinfo_for_stmt (stmt));\n+      gcc_assert (GROUP_GAP (vinfo_for_stmt (stmt)) == 1);\n+    }\n+  /* STMT is now the last element of the first group.  */\n+  gimple *group2 = GROUP_NEXT_ELEMENT (vinfo_for_stmt (stmt));\n+  GROUP_NEXT_ELEMENT (vinfo_for_stmt (stmt)) = 0;\n+\n+  GROUP_SIZE (vinfo_for_stmt (group2)) = group2_size;\n+  for (stmt = group2; stmt; stmt = GROUP_NEXT_ELEMENT (vinfo_for_stmt (stmt)))\n+    {\n+      GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt)) = group2;\n+      gcc_assert (GROUP_GAP (vinfo_for_stmt (stmt)) == 1);\n+    }\n+\n+  /* For the second group, the GROUP_GAP is that before the original group,\n+     plus skipping over the first vector.  */\n+  GROUP_GAP (vinfo_for_stmt (group2)) =\n+    GROUP_GAP (first_vinfo) + group1_size;\n+\n+  /* GROUP_GAP of the first group now has to skip over the second group too.  */\n+  GROUP_GAP (first_vinfo) += group2_size;\n+\n+  if (dump_enabled_p ())\n+    dump_printf_loc (MSG_NOTE, vect_location, \"Split group into %d and %d\\n\",\n+\t\t     group1_size, group2_size);\n+\n+  return group2;\n+}\n+\n /* Analyze an SLP instance starting from a group of grouped stores.  Call\n    vect_build_slp_tree to build a tree of packed stmts if possible.\n    Return FALSE if it's impossible to SLP any stmt in the loop.  */\n@@ -1580,7 +1628,7 @@ vect_analyze_slp_instance (vec_info *vinfo,\n   tree vectype, scalar_type = NULL_TREE;\n   gimple *next;\n   unsigned int vectorization_factor = 0;\n-  int i;\n+  unsigned int i;\n   unsigned int max_nunits = 0;\n   vec<slp_tree> loads;\n   struct data_reference *dr = STMT_VINFO_DATA_REF (vinfo_for_stmt (stmt));\n@@ -1774,6 +1822,41 @@ vect_analyze_slp_instance (vec_info *vinfo,\n   vect_free_slp_tree (node);\n   loads.release ();\n \n+  /* For basic block SLP, try to break the group up into multiples of the\n+     vectorization factor.  */\n+  if (is_a <bb_vec_info> (vinfo)\n+      && GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt))\n+      && STMT_VINFO_GROUPED_ACCESS (vinfo_for_stmt (stmt)))\n+    {\n+      /* We consider breaking the group only on VF boundaries from the existing\n+\t start.  */\n+      for (i = 0; i < group_size; i++)\n+\tif (!matches[i]) break;\n+\n+      if (i >= vectorization_factor && i < group_size)\n+\t{\n+\t  /* Split into two groups at the first vector boundary before i.  */\n+\t  gcc_assert ((vectorization_factor & (vectorization_factor - 1)) == 0);\n+\t  unsigned group1_size = i & ~(vectorization_factor - 1);\n+\n+\t  gimple *rest = vect_split_slp_store_group (stmt, group1_size);\n+\t  bool res = vect_analyze_slp_instance (vinfo, stmt, max_tree_size);\n+\t  /* If the first non-match was in the middle of a vector,\n+\t     skip the rest of that vector.  */\n+\t  if (group1_size < i)\n+\t    {\n+\t      i = group1_size + vectorization_factor;\n+\t      if (i < group_size)\n+\t\trest = vect_split_slp_store_group (rest, vectorization_factor);\n+\t    }\n+\t  if (i < group_size)\n+\t    res |= vect_analyze_slp_instance (vinfo, rest, max_tree_size);\n+\t  return res;\n+\t}\n+      /* Even though the first vector did not all match, we might be able to SLP\n+\t (some) of the remainder.  FORNOW ignore this possibility.  */\n+    }\n+\n   return false;\n }\n "}]}