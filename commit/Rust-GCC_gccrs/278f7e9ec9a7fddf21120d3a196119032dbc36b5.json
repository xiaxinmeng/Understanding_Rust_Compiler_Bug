{"sha": "278f7e9ec9a7fddf21120d3a196119032dbc36b5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mjc4ZjdlOWVjOWE3ZmRkZjIxMTIwZDNhMTk2MTE5MDMyZGJjMzZiNQ==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-05-20T22:06:42Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-05-20T22:06:42Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r1034", "tree": {"sha": "e18e343fb33b771168915c65e1a7a5585efb15c3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e18e343fb33b771168915c65e1a7a5585efb15c3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/278f7e9ec9a7fddf21120d3a196119032dbc36b5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/278f7e9ec9a7fddf21120d3a196119032dbc36b5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/278f7e9ec9a7fddf21120d3a196119032dbc36b5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/278f7e9ec9a7fddf21120d3a196119032dbc36b5/comments", "author": null, "committer": null, "parents": [{"sha": "df6ee5528e3d1d6edf822fa421a16f3c511995b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df6ee5528e3d1d6edf822fa421a16f3c511995b0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df6ee5528e3d1d6edf822fa421a16f3c511995b0"}], "stats": {"total": 58, "additions": 51, "deletions": 7}, "files": [{"sha": "4597703422b9829a511b17f36d4ef0444bb7fa2a", "filename": "gcc/reload1.c", "status": "modified", "additions": 51, "deletions": 7, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/278f7e9ec9a7fddf21120d3a196119032dbc36b5/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/278f7e9ec9a7fddf21120d3a196119032dbc36b5/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=278f7e9ec9a7fddf21120d3a196119032dbc36b5", "patch": "@@ -4479,6 +4479,7 @@ emit_reload_insns (insn)\n   int special;\n   /* Values to be put in spill_reg_store are put here first.  */\n   rtx new_spill_reg_store[FIRST_PSEUDO_REGISTER];\n+  int is_asm = asm_noperands (PATTERN (insn)) >= 0;\n \n   /* If this is a CALL_INSN preceded by USE insns, any reload insns\n      must go in front of the first USE insn, not in front of INSN.  */\n@@ -4850,7 +4851,15 @@ emit_reload_insns (insn)\n \t\t\t    {\n \t\t\t      reload_insn\n \t\t\t\t= gen_input_reload (second_reload_reg,\n-\t\t\t\t\t\t    oldequiv, where);\n+\t\t\t\t\t\t    oldequiv, where, is_asm);\n+\t\t\t      /* If we can't create the reload insn,\n+\t\t\t\t report an error and give up.  */\n+\t\t\t      if (reload_insn == 0)\n+\t\t\t\t{\n+\t\t\t\t  error_for_asm (insn,\n+\t\t\t\t\t\t \"`asm' operand requires impossible reload\");\n+\t\t\t\t  return;\n+\t\t\t\t}\n \t\t\t      if (this_reload_insn == 0)\n \t\t\t\tthis_reload_insn = reload_insn;\n \t\t\t      oldequiv = second_reload_reg;\n@@ -4863,7 +4872,15 @@ emit_reload_insns (insn)\n \t      if (! special)\n \t\t{\n \t\t  reload_insn = gen_input_reload (reloadreg,\n-\t\t\t\t\t\t  oldequiv, where);\n+\t\t\t\t\t\t  oldequiv, where, is_asm);\n+\t\t  /* If we can't create the reload insn,\n+\t\t     report an error and give up.  */\n+\t\t  if (reload_insn == 0)\n+\t\t    {\n+\t\t      error_for_asm (insn,\n+\t\t\t\t     \"`asm' operand requires impossible reload\");\n+\t\t      return;\n+\t\t    }\n \t\t  if (this_reload_insn == 0)\n \t\t    this_reload_insn = reload_insn;\n \t\t}\n@@ -5379,13 +5396,17 @@ emit_reload_insns (insn)\n }\n \f\n /* Emit code before BEFORE_INSN to perform an input reload of IN to RELOADREG.\n-   Returns first insn emitted.  */\n+   Returns first insn emitted.\n+\n+   If IS_ASM, check the emitted insns for validity.\n+   If they are invalid, delete them and return 0.  */\n \n rtx\n-gen_input_reload (reloadreg, in, before_insn)\n+gen_input_reload (reloadreg, in, before_insn, is_asm)\n      rtx reloadreg;\n      rtx in;\n      rtx before_insn;\n+     int is_asm;\n {\n   register rtx prev_insn = PREV_INSN (before_insn);\n \n@@ -5493,16 +5514,39 @@ gen_input_reload (reloadreg, in, before_insn)\n \n   /* If IN is a simple operand, use gen_move_insn.  */\n   else if (GET_RTX_CLASS (GET_CODE (in)) == 'o' || GET_CODE (in) == SUBREG)\n-    emit_insn_before (gen_move_insn (reloadreg, in), before_insn);\n+    {\n+      rtx x = emit_insn_before (gen_move_insn (reloadreg, in), before_insn);\n+      if (is_asm && recog_memoized (x) < 0)\n+\t{\n+\t  delete_insn (x);\n+\t  return 0;\n+\t}\n+    }\n \n #ifdef HAVE_reload_load_address\n   else if (HAVE_reload_load_address)\n-    emit_insn_before (gen_reload_load_address (reloadreg, in), before_insn);\n+    {\n+      rtx x = emit_insn_before (gen_reload_load_address (reloadreg, in),\n+\t\t\t\tbefore_insn);\n+      if (is_asm && recog_memoized (x) < 0)\n+\t{\n+\t  delete_insn (x);\n+\t  return 0;\n+\t}\n+    }\n #endif\n \n   /* Otherwise, just write (set REGLOADREG IN) and hope for the best.  */\n   else\n-    emit_insn_before (gen_rtx (SET, VOIDmode, reloadreg, in), before_insn);\n+    {\n+      rtx x = emit_insn_before (gen_rtx (SET, VOIDmode, reloadreg, in),\n+\t\t\t\tbefore_insn);\n+      if (is_asm && recog_memoized (x) < 0)\n+\t{\n+\t  delete_insn (x);\n+\t  return 0;\n+\t}\n+    }\n \n   /* Return the first insn emitted.\n      We can not just return PREV_INSN (before_insn), because there may have"}]}